00:16:13 * hackagebot cab 0.1.0 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.0 (KazuYamamoto)
00:51:05 <frerich> How do you call the '(Eq a)' part of 'f :: (Eq a) -> a -> a -> Bool'? "Constraint"? "Requirement"?
00:52:34 <idivyanshu> :t Data.System.I0.hGetContents
00:52:35 <lambdabot> Couldn't find qualified module.
00:52:43 <idivyanshu> :t Data.System.IO.hGetContents
00:52:44 <lambdabot> Couldn't find qualified module.
00:52:51 <idivyanshu> :t System.IO.hGetContents
00:52:51 <lambdabot> GHC.IO.Handle.Types.Handle -> IO String
00:53:26 <frerich> Err, 'f :: (Eq a) => a -> a -> Bool' even.
00:53:59 <Cin> freedrull: A class constraint.
00:57:25 <erus_> myFunction = id what does this do?
00:58:33 <Cin> Declares at the top-level that the value of ‘myFunction’ is ‘id’.
00:59:01 <frerich> :t compare
00:59:02 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
00:59:08 <frerich> :t comparing id
00:59:09 <lambdabot> forall b. (Ord b) => b -> b -> Ordering
01:01:12 <erus_> I can't see id defined anywhere else in this snippet
01:03:06 <erus_> http://paste.ubuntu.com/590624/ its from here
01:03:52 <Cin> erk_: ‘id’ is in Prelude. The Prelude module is implicitly imported.
01:04:02 <Cin> @hoogle id
01:04:02 <lambdabot> Prelude id :: a -> a
01:04:02 <lambdabot> Control.Category id :: Category cat => cat a a
01:04:02 <lambdabot> Data.Function id :: a -> a
01:04:02 <c_wraith> @hoogle id
01:04:02 <lambdabot> Prelude id :: a -> a
01:04:02 <lambdabot> Control.Category id :: Category cat => cat a a
01:04:04 <lambdabot> Data.Function id :: a -> a
01:06:26 <erus_> ah ok
01:21:19 <erus_> How long did it take you guys to 'get' functional programming?
01:22:09 <erus_> I feel I can't create the same kind of things I can creat in C yet
01:22:35 <erus_> I can see all the building blocks there (kind of)
01:22:46 <erus_> but I can't put it all together yet
01:23:20 <c_wraith> haskell is a different beast than any other FP-oriented language.  laziness, purity, the very strong type system.
01:23:27 <MasseR> erus_: I first opened learnyouahaskell last summer. I'm at a point (been for a while already) where I can create functional programs, which I think are haskelly, but I'm not quite there yet
01:24:21 <c_wraith> It probably took me 6 months of working with haskell to really feel like I knew what was going on with it.  *way* longer than it took me to reach similar points in even O'Caml, just because there's so much different about it.
01:24:50 <jlouis> I'd say about 6 months for some level of fluency
01:25:14 <jlouis> It took about the same time with Erlang
01:25:43 <c_wraith> Well.  I picked up Erlang after haskell.  Given that, I felt like Erlang was a 15-minute job.  Except for never-ending swearing at its syntax. :)
01:26:02 <jlouis> c_wraith: you cannot learn OTP in 15 minutes, which is the interesting part
01:26:30 <c_wraith> jlouis: sure, and I still don't really know the OTP.  I just use things built on top of it.
01:26:42 <jlouis> The semantics of the base language is a walkover though, yes
01:27:59 <jlouis> and then there are all the small things. foo x x = ... is valid in Erlang and will only match if the first and second argument unifies
01:28:43 <shachaf> Erlang is in general more Prology than Haskell.
01:28:45 <c_wraith> and the looseness of string pattern matching, etc
01:30:11 <Cin> jlouis: I think it's the case that many people expect foo x x = … to try to unify, in Haskell.
01:30:25 <edon> the hardest part about switching to a functional languange mindset is that you have to stop thinking like a turing machine
01:30:30 <jlouis> erus_: The trick is to write toy things. And be ignorant to the fact that "this could have been expressed with a higher abstraction feature"
01:30:52 <jlouis> then pile the abstraction on top later
01:31:08 <frerich> erus_: My approach is just to play around. I'm only doing the fun stuff. And usually the 'fun' stuff actually soon turns into useful stuff (because the simple stuff becomes boring).
01:31:18 <jlouis> Cin: yep. foo("Prefixx" ++ T) -> ... is valid too :)
01:32:08 <jlouis> edon: to be honest, nothing works like a turing machine. Perhaps people start thinking as if the underlying machine is a Random Access Machine (RAM)
01:33:34 <jlouis> And the RAM and PRAM are quite bad models of the actual hardware too
01:35:32 <Cin> You can probably get solid statistics about learning Haskell from this channel's IRC logs.
01:36:05 <edon> jlouis: yeah i meant the state manipulating kind of approach to problems :)
01:36:07 <Cin> Count when people first entered and asked their newbie questions, then judge at what point they display competence.
01:37:16 * shachaf greps the logs for when augustss did the former.
01:37:42 <jlouis> The fallacy of thinking the memory in a computer is shared is one of my major pet peeves
01:37:52 <jlouis> it has not been for 15 years :)
01:38:42 <jlouis> shachaf: he never did :)
01:39:01 <Cin> Many people do, though, so you could get good stats.
01:43:23 <Cin> 2009-03-09 20:22:55 <c_wraith> beginner question:  how do I re-write a function of the form "f x = g $ h x" to not use a parameter?  This feels like it should be obvious, but I'm not seeing it.
01:43:42 <Cin> Perfect example. There's the start of c_wraith's learning.
01:43:46 <c_wraith> I remember that conversation
01:44:09 <unfo-> was the answer: f = g . h ?
01:44:11 <c_wraith> and the craziness of the @pl results
01:44:18 <Cin> :-P
01:44:18 <c_wraith> yes.
01:44:37 <c_wraith> I really wanted to ask about g $ h x y though
01:44:42 <unfo-> yay. at least i have learned me some haskell for great good
01:44:48 <Botje> *sniff* they grow up so fast
01:45:06 <c_wraith> @pl \x y -> g $ h x y
01:45:06 <lambdabot> (g .) . h
01:45:16 <c_wraith> @pl \x y z -> g $ h x y z
01:45:16 <lambdabot> ((g .) .) . h
01:45:23 <c_wraith> yeah, the fun of that
01:45:31 <unfo-> how can i do that @pl in my ghci ?
01:45:41 <mauke> @pl \g h x y -> g $ h x y
01:45:41 <lambdabot> (.) . (.)
01:45:45 <unfo-> hahah
01:45:46 <Cin> unfo-: You need something like GHCi on Acid for that.
01:46:21 <Cin> 2006-10-22 18:19:40 <Botje> pejo: I guess. I'm learning haskell too, out of interest.
01:46:30 <Cin> Botje: They do. *Wipes tear*
01:46:54 <jlouis> haha
01:46:54 <unfo-> Cin, thanks!
01:46:58 <nlogax> i just installed pointfree/ful from hackage and added to my .ghci
01:47:02 <jlouis> Cin: how far back do you have logs?
01:47:15 <jlouis> Cin: I'll guess I am around 2004/2005
01:47:17 <Cin> 2001.
01:47:35 <Botje> Cin: :P
01:47:37 <Cin> 2001-12-17 13:00:36 <shapr> hi hi!
01:48:04 <jlouis> Haskells was merely a toy in 2001
01:48:15 <jlouis> Nowadays, I think it is leading the path
01:48:38 <Cin> 2005-02-27 15:47:21 <mauke> I wrote my first haskell program!
01:48:44 <mauke> .oO( news: lead found in toy )
01:48:58 <jlouis> mauke: haha
01:50:54 <frerich> It feels kind of nice (me being a newbie right now) to see that all the gurus started simple, too :-)
01:52:14 <companion_cube> if someone has some logs that show dons beginning, that should be collector :)
01:53:17 <shachaf> <dons> hi guys how do i monad?
01:53:39 <Cin> frerich: Of course. :-)
01:54:11 <Cin> dons knew Haskell a long time before joining the IRC. He'd already written hs-plugins.
01:58:32 <rostayob> Stupid question, since nlogax mentioned .ghci: how do I use that conf file? like if I want to put -Wall as default (and maybe the same for ghc as well)
01:58:54 <Cin> :set -Wall
01:59:07 <Cin> Everything in it is what you could write in GHCi as :foo.
01:59:13 <rostayob> oh ok, cool
01:59:15 <rostayob> thanks
01:59:21 <rostayob> what about ghc?
01:59:43 <Cin> I don't know about that.
01:59:50 <rostayob> actually runhaskell more than ghc, but I guess than setting ghc will do. right now I have an alias
02:03:53 <nlogax> you can set it in the .cabal file for your projects, other than that idunno
02:04:36 <rostayob> nlogax: yeah but I always go runhaskell when working on something
02:04:42 <rostayob> but I've got an alias is good enough....
02:06:25 <erus_> could someone check what i am doing wrong here http://paste.ubuntu.com/590648/ 
02:07:01 <mauke> yeah, you're uinsg y z in a pattern
02:07:33 <rostayob> erus_: it should be (V2 x y)
02:07:48 <rostayob> you're pattern matchin two things there
02:07:56 <rostayob> while you want to match one (the V2)
02:08:05 <rostayob> also, when calling v2length
02:08:37 <rostayob> and also the command line arguments :P
02:08:57 <rostayob> also the let...
02:09:05 <mauke> rostayob: what?
02:09:35 <rostayob> mauke: he's pattern matching the args with a tuple
02:09:38 <mauke> minimum change required to make this compile: (y z) => [y, z]
02:09:52 <shachaf> mauke: No, because v2length's type is wrong.
02:10:00 <shachaf> Or implementation.
02:10:05 <mauke> ah
02:10:09 <rostayob> mauke: nono, that V2
02:10:11 <rostayob> also
02:10:23 <rostayob> the let block doesn have an "in" :P
02:10:31 <mauke> rostayob: that's fine
02:10:37 <rostayob> is it? oh right
02:10:47 <toby> it's in a "do" - "let" doesn't have "in" inside "do"
02:11:01 <rostayob> yeah yeah of course
02:11:07 <rostayob> just woke up
02:11:38 <rostayob> ah also, you have to "read" the parameters
02:12:52 <rostayob> erus_: http://hpaste.org/45415/erus
02:13:41 <toby> doesn't work
02:13:57 <rostayob> toby: no? I didn't try
02:14:21 <toby> you'd have to do something with the result of "map read"
02:14:30 <rostayob> ah yeah
02:14:32 <erus_> how does it know to read to doubles?
02:14:56 <toby> http://hpaste.org/45416/v2_fixed
02:15:00 <rostayob> erus_: http://hpaste.org/paste/45415/erus_annotation#p45417
02:15:10 <toby> (hope this wasn't a homework assignment)
02:15:27 <rostayob> erus_: the type of "read x" is inferred automatically by the type checker
02:15:51 <erus_> toby: i wish i went to uni :P
02:15:53 <rostayob> so it knows it has to convert the string to a double, since V2 :: Double -> Double -> V2
02:16:08 <erus_> rostayob: it reads backwards all that way?
02:16:16 <rostayob> erus_: what do you mean?
02:17:14 <rostayob> erus_: "read" basically tries to convert anything that we know how to convert (everything that has been instantiated with the typeclass Read) to a string
02:17:34 <rostayob> no sorry, convert *from* a string :P
02:17:45 <rostayob> to what you want
02:17:52 <erus_> well first it would have to read the expected type of v2length, then see that it expects a list of doubles for the case, etc
02:17:59 <Cin> erus_: Why can you put anything in a list?
02:18:21 <mauke> erus_: yes
02:18:30 <mauke> it does that for all expressions anyway
02:18:40 <mauke> otherwise it couldn't detect type errors properly
02:18:41 <pmurias> how should i use the derive library (i want to write a new derivation)
02:18:44 <rostayob> erus_: yes, it doesn't need you to tell him what to expect
02:19:04 <rostayob> pmurias: you mean you want to define your own "derive" directive? you can't
02:19:06 * hackagebot cab 0.1.1 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.1 (KazuYamamoto)
02:19:12 <rostayob> afaik
02:19:20 <erus_> its kinda like dynamic typing
02:19:29 <rostayob> erus_: no!
02:19:53 <mauke> erus_: more like static typing :-)
02:20:13 <rostayob> no no, it's not dynamic at all, but since haskell typing system is well defined, it can figure out the type by itself
02:20:20 <mauke> erus_: what programming languages do you know?
02:20:22 <Cin> erus_: What type is the `id' function?
02:20:29 <erus_> maybe i mean its not explicitly typed
02:20:40 <rostayob> erus_: ok, that's totally different
02:20:42 <mauke> that's true
02:20:43 <pmurias> rostayob: http://community.haskell.org/~ndm/darcs/derive/derive.htm claims i can
02:20:50 <shachaf> rostayob: ...pmurias mentioned the name of the library.
02:21:11 <erus_> mauke: C / C++ mainly but i can program in anything other than haskell and lispy languages 
02:21:30 <mauke> can you program in perl?
02:21:32 <shachaf> *Any*thing?
02:21:37 <rostayob> pmurias: oh ok, I didn't know about that, I use template haskell when I need to derive stuff automatically
02:21:46 <erus_> brainfuck
02:21:58 <flamingspinach> can you program in malbolge
02:22:06 <shachaf> erus_: That's just a subset of C.
02:22:08 <Cin> erus_: Try answering my question, it might help you understand.
02:22:28 <rostayob> shachaf, pmurias: that thing runs a preprocessor
02:22:36 <rostayob> or something like that
02:22:37 <pmurias> or uses template haskell
02:22:57 <rostayob> pmurias: that's something I did that does that: https://github.com/rostayob/reskell/blob/master/src/Data/Bson/Mapping.hs
02:23:00 <erus_> Cin a function that takes a (type a) and returns a (type a) ?
02:23:30 <Cin> erus_: Okay, a -> a. So what is the type of this? id 'a'
02:23:49 <erus_> anonymous type?
02:24:01 <mauke> a is clearly nonymous
02:24:26 <Cin> erk_: Do you know what polymorphism is?
02:24:31 <rostayob> pmurias: right now is really limited but it should give you an idea... you need template haskell anyway
02:24:34 <mauke> tabfail
02:24:47 <Cin> Thanks.
02:24:47 <Cin> erus_: Do you know what polymorphism is?
02:25:06 <erus_> yes; so its a base type of some sort Object or Value or something
02:25:14 <Cin> mauke: XChat's tab-completion doesn't behave as I expect.
02:25:30 <mauke> erus_: this isn't subtyping or inheritance, though
02:26:00 <mauke> speaking in C++ terms we can sort of do this using templates
02:26:23 <erus_> mauke: yer thats how i understood it at the moment
02:26:24 <mauke> template<typename a> a id(a); ... what is the type of id('a')?
02:26:35 <Cin> erus_: Would you say that + is polymorphic because it can either add two integers or two decimals?
02:27:10 <erus_> mauke: errr Template value? im not sure of the terminology 
02:27:18 <erus_> Cin: yes.... ?
02:27:26 <mauke> erus_: huh? I don't understand "template value?"
02:27:38 <erus_> type
02:27:46 <mauke> the type of id('a') is char
02:28:08 <erus_> o sorry i mis understood the question
02:28:17 * frerich thinks it would be sufficient if either Cin or mauke teases erus_' brain, instead of both of you guys doing so. I can already see little smoke clouds coming out of his ears
02:28:40 * Cin thinks mauke's example works well
02:28:45 <mauke> I actually have a point somewhere
02:28:48 <mauke> erus_: do you know perl?
02:28:56 <erus_> a little
02:29:03 <mauke> do you know about scalar/list context?
02:29:15 <erus_> i think so
02:29:24 <mauke> this is how read works
02:29:32 <mauke> except in haskell every type has its own "context"
02:29:33 <rostayob> erus_: you'd probably be better off reading this: http://learnyouahaskell.com/chapters
02:30:04 <erus_> mauke: i understood how read works i just didnt see where it got the context from
02:30:06 <mauke> viewed through C++ this means haskell supports return type based overloading
02:30:18 <erus_> now i understand it looks ahead until it can find a type
02:30:27 <mauke> it doesn't look ahead, really
02:30:41 <mauke> and it's not "until it can find a type"
02:30:59 <mauke> every (sub-)expression already has a type
02:31:05 <shachaf> erus_: Do you know Prolog?
02:31:05 <shachaf> That's neither LISP nor Haskell.
02:31:06 <Cin> Really the problem is unification, yeah.
02:31:21 <mauke> that is, the type checker goes through the program and assigns a type to every part of it
02:42:00 <Saizan> woot, an unicode vs. ascii war on the haskell prime mailing list
02:43:54 <mauke> is that like static vs. dynamic typing?
02:46:39 <Saizan> somewhat, "let's say in the report that the default encoding for haskell source files is utf-8" vs. "but that would encourage people to use fancy symbols!"
02:47:30 <vegai> Haskell is all about not allowing programmers to do something, isn't it? :P
02:47:44 <shachaf> Should the report deal with encoding?
02:48:11 <pmurias> vegai: that's the purpose of a type system
02:48:24 <merijn> shachaf: Yes, or at least specify a minimal subset of allowed encodings
02:48:33 <pmurias> vegai: and haskell seems to be a lot about types
02:48:35 <Saizan> actually, the purpouse of a type system is to allow more expressiveness :)
02:48:45 <ezyang> no it's not... 
02:48:56 <merijn> ezyang: It depends
02:49:11 <merijn> ezyang: There's two ways of looking at expressiveness
02:49:26 <ezyang> I'm looking at the "valid programs" angle 
02:49:38 <Saizan> http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/
02:50:11 <Saizan> the program simply says more about what it's supposed to do
02:50:28 <merijn> ezyang: Oh, wait. Depends on what you were disagreeing with, I suppose. If you disagreed with whether that is the purpose of the type system you could be right.
02:50:37 <Cin> λ> decode "1" :: Result Int
02:50:37 <Cin> Ok 1
02:50:37 <Cin> λ> decode "1" :: Result [Int]
02:50:43 <Cin> This is hard without types.
02:50:44 <Saizan> i.e. the type system allows you to put more information in your code than otherwise :)
02:50:51 <merijn> Saizan: That is only true if your static language has an inconsistent type system, of course
02:51:04 <merijn> Because STLC is strictly less expressive then UTLC
02:51:21 <merijn> And so is any other language with a consistent type system, afaik
02:51:25 <mauke> decode("1", Result(Int))
02:51:36 <Saizan> no, i actually think consistency helps
02:52:42 <ezyang> When you tell me how I can write a fixpoint combinator in a statically typed language, we can talk :-) 
02:52:45 <merijn> Saizan: Depends, we are at the edge of my knowledge. Is it possible to have a non-strongly terminating type system which is consistent?
02:52:56 <Saizan> ezyang: just use the non-termination monad :)
02:52:59 <mauke> ezyang: you use recursive let
02:53:01 <Cin> mauke: Now this :-P do (x,_) <- decode …; y <- decode …; ks <- decode …; return map (+((x+y)/2)) ks;
02:53:17 <ezyang> ah, but that's putting more power in the language to compensate for type system restrictions :-) 
02:53:27 <mauke> fine with me
02:53:38 <mauke> power to the people!
02:53:45 <Saizan> no, it's just using a sufficiently powerful type system to actually express what you want
02:53:46 <ezyang> (note: I prefer type systems. But they do restrict the range of allowed programs) 
02:54:15 <mauke> ezyang: sure, but the other side is that they also simplify many allowed programs
02:54:23 <merijn> Speaking of powerful type systems and expressiveness. Anyone familiar with Oleg? :p
02:54:24 <Saizan> yeah, i'm disputing the claim that expressiveness is to be measured by the range of allowed programs :)
02:54:41 <Cin> merijn: Oleg is a celebrity.
02:54:45 <ezyang> Oh, if you dispute that, then I have no ground to stand on :-) 
02:54:50 <merijn> Cin: The type system, not the person
02:54:55 <Botje> what was *his* first IRC line, I wonder
02:55:06 <mauke> Cin: don't make me add Λ and type passing everywhere
02:55:13 <Cin> mauke: :-)
02:55:23 <nlogax> Botje: i imagine something like "I have arrived." 
02:56:42 <merijn> Cin: It's from McBride's phd thesis and then the same ideas are used in Epigram, which I've been trying to understand.
02:56:48 <frerich> It seems to be really en vogue among Haskellers on IRC to use Unicode characters for stuff like ellipses. Me being a mere mortal, I'd write "...". :-}
02:56:58 <Cin> ‘I'm talking from an IRC client written in the type system.’
02:57:25 <Saizan> merijn: i've heard of "LEGO", maybe Oleg was the old name?
02:57:36 <Botje> frerich: some clients auto-replace that
02:57:41 <merijn> Saizan: Oleg is an inspired by/adaptation of LEGO
02:58:33 <Saizan> merijn: ah, so many languages by McBride..
02:58:34 <Cin> freedrull: Botje: I just use a compose key.
02:58:55 <merijn> It adds more sensible machinery for dealing with holes, which is then used by the whole "Elimination With a Motive" business (which I'm guessing you've at least heard of hanging around in #epigram :p)
02:59:12 <frerich> Cin: Your tab completion is suffering from namespace conflicts! :-)
02:59:18 <Saizan> merijn: yeah
02:59:32 <Cin> Bleh. I should stop using XChat, its completion never behaves as I expect.
02:59:54 <Saizan> merijn: is the stuff covered in "Elimination With a Motive" also covered in the thesis?
02:59:57 <frerich> Bleh: That's ok, I have context-sensitive pattern matching
03:00:08 <shachaf> Cin: Why did you start using it?
03:00:27 <merijn> Saizan: Yes, much more in depth. I started reading it because Elimination With a Motive was just out of my league of understanding
03:00:45 <Saizan> merijn: i should do the same
03:01:15 <Cin> shachaf: ‘Cause it has built-in notify-osd support, and I can’t presently be bothered adding the same level of support to ERC.
03:01:45 <mauke> that sounds like something an irssi script could do
03:01:47 <merijn> Saizan: Afaik one of the ideas is that elimination of a function is similar to eliminating a data structure. In that you can see pattern matching/cases in functions as similar to distinction between constructors during elimination of data types.
03:02:49 <merijn> But unfortunately there's very few persons on this planet which can actually verify if my understanding is right, let alone explain if I'm wrong :p
03:03:24 <flamingspinach> [2011-04-07 18:09:33] <Cin> Bleh. I should stop using XChat, its completion never behaves as I expect.
03:03:27 <flamingspinach> completion of what?
03:03:31 <mauke> nicks
03:03:38 <flamingspinach> oh right
03:03:45 <flamingspinach> there's a setting for that, you know
03:04:08 <flamingspinach> /set completion_sort
03:04:24 <erus_> main = do { args <- getArgs; print foldl (++) args; } -- Whats wrong with that?
03:04:41 <mauke> erus_: print only takes 1 arg, not 3
03:04:51 <Saizan> merijn: by elimination of a function you mean e.g. constructing an induction principle to prove stuff about (++) ?
03:05:04 <merijn> erus_: You probably want "print $ fold..."
03:05:05 <erus_> i did have a dollar in there before, whoops
03:05:08 <McManiaC> main = getArgs >>= print . foldl (++) ""
03:05:25 <flamingspinach> interesting... do haskell programmers refer to functions having multiple arguments despite the type system indicating that everything is curried?
03:05:35 <merijn> flamingspinach: Yes
03:05:36 <mauke> flamingspinach: often, yes
03:05:40 <flamingspinach> (at least as far as I understand it)
03:06:02 <merijn> flamingspinach: Your understanding is correct, but unnecessarily verbose in speech :p
03:06:13 <flamingspinach> what?
03:06:18 <flamingspinach> how would you put it, then? :)
03:06:26 <mauke> every function takes exactly one arg, but we like to squint a bit
03:06:39 <sipa> a function has one argument
03:06:43 <merijn> flamingspinach: I meant that referring to functions as something else then "having multiple arguments" is to verbose
03:06:46 <sipa> a specific function call can have many :)
03:06:54 <erus_> ah fold takes an initial value ofcorse!
03:07:05 <mauke> erus_: concat
03:07:51 <shachaf> What's the equivalent of currying for functions returning multiple values?
03:07:54 <shachaf> Curried CPS?
03:10:13 <Cin_> Ah, it works.
03:10:25 <Cin_> Used notify.pl.
03:10:57 <shachaf> Cin_: Have a notification.
03:11:05 <Cin_> :-)
03:11:42 <Cin_> Does Irssi support nick-completion based upon who spoke more recently and/or someone I referenced recently?
03:11:46 <merijn> Saizan: Well, some of the examples in the thesis have as example the inductively defined relation <= and then he is constructing a function which partially applies that relation "<=0". And the example seems to replace that function application with a natural number indexed proposition. But there is not much explanation about how or why exactly. Which is sorta what I wanted to find out
03:11:47 * shachaf made do with an URGENT hint instead of fancy OSD notify.
03:11:58 <mauke> Cin_: I think it does
03:12:13 <shachaf> Cin_: I'm pretty sure it does, but this is mainly based on it usually getting notification right.
03:12:14 <Cin_> Yeah, I think it does, now that people have spoke; I can just hit mTAB => mauke. Nice.
03:12:18 <sipa> Cin_: either most recent person you addressed, or last active person
03:12:34 * mauke displays urgent hints with osd
03:12:35 <Cin_> I'm used to this kind of completion. Sweet.
03:13:33 <Saizan> merijn: page?
03:16:37 <merijn> Saizan: The entire stuff is in the start of chapter 3 (page fifty-ish) the specific example is on page 60-64 (natural number equality and lte relation)
03:18:44 <Cin> K, I'm connected to my bouncer. Hurrah.
03:19:43 <shachaf> Bouncer?
03:19:52 <mauke> irc proxy
03:20:00 <shachaf> Ah.
03:21:02 <Cin> mauke: Finding your windows is hard. How do you navigate yours? Just memorize alt+n?
03:22:13 <mauke> I have numbers + channel names in my activity list
03:22:17 <mauke> but mostly alt+a
03:31:29 <Cin> Haha. These guys are really getting into this encoding issue.
03:31:36 <Cin> Proposal: add ghc -fwarn-non-ascii warning flag
03:31:40 * shachaf has 82 windows open in irssi. :-(
03:31:53 <Cin> shachaf: How do you navigate them?
03:32:00 <shachaf> I... Don't.
03:32:07 <shachaf> Other than alt-a.
03:32:08 <Cin> My boss showed me I can use arrow keys, which is nice.
03:32:34 <shachaf> Yes, I do use that (well, ctrl-n/ctrl-p).
03:33:03 <frerich> Maybe you need a feature to jump to channels by searching for them by name (specifying a regexp). Like 'b' in vim :)
03:33:30 * shachaf notes that there are very few good UIs.
03:33:40 <shachaf> Where "good" means "works well for me".
03:33:46 <Cin> frerich: That's what I do with ERC. C-x b and then type a substring of the chan. That's nice. Presumably there's an irssi plugin to do this?
04:15:57 <hvr_> does 'cabal update' use conditional get-request based on etag/last-modified?
04:16:54 <Saizan> ezyang: i backtrack, expressivity can be measured by the range of allowed programs, but you can't expect that the same program in a untyped or typed by an inconsistent type system should look the same in a consistent one, anymore that you'd expect a program to look the same in Java and C
04:17:30 <Saizan> ezyang: you've to allow for an embedding transformation
04:20:44 <Saizan> at that point saying that you can't write a fix combinator in e.g. Agda is the same as saying you can't do I/O in haskell
04:24:16 <ezyang> Saizan: But in the particular case of the typed/untyped lambda calculi, all typed lambda calculus terms are valid in the untyped lambda calculus with types erased, and have the same behavior too. 
04:28:27 <Saizan> ezyang: type erasure loses information though, you could start with a program that says "i'm accepting only strong normalizing terms of type X", once you erase the types you've no decidable way to get that part of the program back
04:28:57 <ezyang> Yes. Types have information, I agree. 
04:29:12 <Saizan> "of type X" can be said without referring to types, btw
04:29:18 <ezyang> That's why my argumentative position has no ground if you argue expressivity is not just "what programs are allowed" 
04:29:35 <Saizan> expressivity is that
04:30:02 <Saizan> but programs aren't just their computational content
04:30:32 <ezyang> I am stubbornly disagreeing on that point :-) 
04:30:53 <brbr> hello
04:31:03 <brbr> head' = foldr1 (\x _ -> x)
04:31:28 <brbr> this seems inefficient because you traverse whole list from right-to-left and return the last element
04:31:53 <brbr> but is this actually efficient bc haskell is lazy? e.g. does this compile to just "get first element of list"
04:32:01 <mauke> yes
04:32:10 <mauke> foldr doesn't traverse the whole list
04:32:31 <erus_> why not?
04:32:36 <mauke> @src foldr
04:32:36 <lambdabot> foldr f z []     = z
04:32:36 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:32:40 <mauke> see that last line?
04:32:44 <mauke> it simply calls f
04:33:27 <brbr> but there's a recursive call on the tail (xs)...
04:33:36 <mauke> not yet
04:33:44 <mauke> your f ignores that argument (_)
04:33:48 <mauke> so it's simply thrown away
04:33:54 <Jafet> @pl \x _ -> x
04:33:54 <lambdabot> const
04:34:34 <Jafet> Though I never expected head = foldr1 const
04:35:06 <xplat> if types in haskell/agda/whatever were just annotations on untyped terms, then they would have intersection types instead of polymorphic foralls
04:35:24 <xplat> instead, the types are part of the terms
04:35:45 <xplat> therefore, haskell, at least, allows more programs than untyped lambda calculus
04:35:46 <brbr> how come it looks like foldr traverses from left-to-right ?
04:35:59 <mauke> because it does
04:36:15 <brbr> @src foldl
04:36:15 <lambdabot> foldl f z []     = z
04:36:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:36:42 <brbr> oh wow
04:36:43 <Jafet> > foldr f 0 [1,2,3,4,5] :: Expr
04:36:44 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 0))))
04:36:47 <Jafet> > foldl f 0 [1,2,3,4,5] :: Expr
04:36:48 <lambdabot>   f (f (f (f (f 0 1) 2) 3) 4) 5
04:36:56 <Jafet> You'll get used to it.
04:39:40 <Veinor> i'm vaguely tempted to play around with haskore
04:39:56 <mauke> http://upload.wikimedia.org/wikipedia/commons/3/3e/Right-fold-transformation.png
04:40:02 <Veinor> are there any good tutorials for it?
04:40:06 <mauke> http://upload.wikimedia.org/wikipedia/commons/5/5a/Left-fold-transformation.png
04:42:46 <frerich> Jafet: Hmm is there any way to get this 'Expr' in ghci? Just asked hoogle where it comes from, but it doesn't seem to be something standard, right? I think this way of seeing how a recursion expands to nested calls is really enlightening.
04:43:12 <Eelis> :t f
04:43:14 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
04:43:23 <Eelis> a clue appears!
04:43:31 <frerich> Aha!
04:44:10 <frerich> Hm, Hackage has it, but hoogle doesn't know.
04:45:36 <Tomsik> Lambda calculus alone is not a programming language
04:45:48 <Tomsik> you need to couple it with an evaluation strategy too
04:46:36 <Eduard_Munteanu> And side-effects :)
04:48:15 <Veinor> frerich: hoogle I think only searches what you get in a basic install by default
04:49:57 <erus_> why do mathematicians leave out the multiply sign but programming language designers leave it in?
04:50:23 <Eelis> erus_: because juxtaposition in programming often means something else, for instance function application
04:51:19 <Tomsik> ernst: there's a parodical paper about doing that in C++
04:51:26 <Tomsik> "whitespace operator"
04:51:53 <espringe> Can you overload it? :P
04:51:53 <sipa> because in certain mathematical domains, multiplication was the most common operator, so people decided not to write it anymore when it was unambiguous, i suppose
04:51:57 <burp> erus_: mathematica handles whitespace as multiplication
04:51:58 <Eelis> Tomsik: is it not perfectly possible to write all kinds of fun lambda expressions that compute stuff regardless of evaluation strategy? if so, saying it's not a programming language seems a bit weird
04:52:02 <Tomsik> they ended up with necessity of one-letter variable names IIRC :p
04:52:05 <sipa> while in programming languages, that's hardly the case
04:52:58 <Tomsik> Eelis: it's mostly boring terms that are strong-normalizing
04:53:13 <Tomsik> no fixpoint etc.
04:53:33 <Eelis> Tomsik: still seems kinda mean spirited to say that that's not programming
04:53:42 <Tomsik> it's not turing-complete
04:53:52 <Eelis> my favorite programming language is not turing complete
04:53:53 <Eelis> (Coq)
04:54:33 <Eelis> so using turing completeness to decide what's a programming language and what isn't seems demonstrably absurd to me
04:56:58 <synonymous> in haskell specifically i guess you could tell unambiguously whether you've got a function application or a multiplication? is there a counter example?
04:57:19 <merijn> synonymous: Well, in haskell multiplication is a function anyway, so...
04:59:39 <mauke> > 2 * 3
04:59:40 <lambdabot>   6
04:59:42 <mauke> > 2 3
04:59:43 <lambdabot>   2
04:59:44 <synonymous> merijn: ok right, but i mean would be feasible to add language support for multiplication omitting the operator?
04:59:50 <mauke> obviously not
04:59:55 <Tomsik> Eelis: I have a feeling strongly-normalizing terms are a very narrow class of terms, not sure though
05:00:29 <Cin> class Mult a b | a -> b where (·) :: a -> b -> b; instance Mult (Int -> Int) Int where f · b = f b; instance Mult Int Int where a · b = a * b
05:00:36 <Eelis> Tomsik: then i suggest browsing through the Coq contrib repository. it's got lots and lots of programs that compute all kinds of things. so say that that's not programming is borderline bigotry :)
05:00:56 <Eelis> s/so say/to say/
05:01:03 <Cin> @instances Num
05:01:03 <lambdabot> Double, Float, Int, Integer
05:01:17 <Eelis> mauke: how come lambdabot thinks "2 3" evaluates to 2?
05:01:21 <Cin> :t (2 :: a -> a)
05:01:22 <lambdabot>     Could not deduce (Num a) from the context ()
05:01:22 <lambdabot>       arising from the literal `2' at <interactive>:1:1
05:01:22 <lambdabot>     Possible fix:
05:01:24 <mauke> Eelis: because it does :-)
05:01:29 <Cin> :t (2 :: Num a => a -> a)
05:01:30 <lambdabot> forall a. (Num a) => a -> a
05:01:32 <Eelis> mauke: ...
05:01:36 <Eelis> mauke: i asked "how come"
05:01:43 <Cin> Num a => (a -> a) is an instance
05:01:47 <Tomsik> Eelis: I suppose Coq has codata and corecursion then?
05:01:49 <sipa> Eelis: instance Num a => Num (a -> a)
05:01:50 <Cin> :t fromInteger
05:01:51 <lambdabot> forall a. (Num a) => Integer -> a
05:01:56 <Eelis> Tomsik: it does, but it's not used that much
05:01:59 <mauke> Eelis: for a much more general implementation of the idea, see http://mauke.dyndns.org/stuff/haskell/fun.hs
05:03:08 <Eelis> great, all kinds of bogus instances..
05:03:17 <Tomsik> And Coq is strong-normalizing?
05:03:19 <cheater> hi
05:03:26 <Eelis> Tomsik: yes
05:03:29 <Tomsik> Darn. :)
05:03:52 <Tomsik> I guess you're right then
05:04:05 <mauke> the bogus instances are because of Num's crazy superclasses
05:05:10 <Cin> Yeah… I often define newtypes like newtype UserId = UserId { unUserId :: Integer } deriving (Num)
05:05:19 <erus_> mauke: I like your javascript a* search :)
05:05:21 <MasseR> Btw why does Num have Show as superclass?
05:05:21 <Cin> —Except, I can't just write that. I have to derive every class under the sun.
05:06:15 <Cin> (Show,Num,Eq,Ord,Enum,Real,Integral)
05:06:59 <Cin> TemplateHaskell to the rescue.
05:26:52 <adlsaks> I'm writing a QuickCheck property - I have a function f that has :t Integer -> Integer -> [Integer] -> Integer
05:27:45 <Eelis> excellent work. keep it up!
05:27:56 <adlsaks> and an inverse function finv, that has :t Integer -> Integer -> Integer -> [Integer]
05:28:06 <Eelis> even better!
05:28:11 <adlsaks> I'd like to test them such that I can confirm the inverse property
05:28:13 <adlsaks> I've tried 
05:29:08 <mauke> \x y z -> finv x y (f x y z) == z
05:29:50 <adlsaks> Ah, yes, that's close
05:30:02 <adlsaks> Now, x and y have to be positive integers
05:30:16 <adlsaks> so, I've said (a > 0) ==> (b > 0) ==? 
05:30:17 <Eelis> positive or nonnegative?
05:30:21 <adlsaks> ==?* even
05:30:42 <adlsaks> actually, non-negative ;) but i'll settle for help with either case ;) 
05:30:58 <Eelis> doesn't QuickCheck have some newtype wrappers for such things?
05:31:28 <dmwit> \a b c -> (a >= 0) ==> (b >= 0) ==> finv a b (f a b c) == c -- ?
05:31:49 <Eelis> adlsaks: http://hackage.haskell.org/packages/archive/QuickCheck/2.4.0.1/doc/html/Test-QuickCheck-Modifiers.html
05:32:13 <Eelis> adlsaks: you'd make the property of type   Positive Integer -> Positive Integer -> Bool   instead of   Integer->Integer->Bool
05:32:55 <Eelis> adlsaks: the Arbitrary instance for Positive will only generate positive values
05:32:57 <erus_> can i specify a type in here > let myNumber = read $ head args;    just so its a bit easier to read? (i use myNumber as a Num later)
05:33:22 <mauke> erus_: Num is not a type
05:33:29 <erus_> Int
05:33:32 <dmwit> erus_: Sure you can.
05:33:41 <dmwit> let myNumber :: Int; myNumber = read $ head args
05:33:50 <mauke> let myNumber = read $ head args :: Int
05:33:57 <adlsaks> thanks Eelis!
05:34:08 <Eelis> my pleasure
05:34:14 <adlsaks> thanks dmwit!
05:38:15 <erus_> ok lets say i have a function that takes 3 ints and a list of 3 ints. Is there a quick way to unpack the ints so i can pass them into the function
05:38:37 <mauke> let [x,y,z] = list
05:39:22 <Jafet> case list of [x,y,z] -> ...; _ -> error "Oh wait, this is bottom too."
05:42:40 <erus_> can i return mulitple args?
05:43:08 <erus_> no
05:43:11 <mauke> every function takes one argument and returns one value
05:43:16 <Twey> You can return a tuple
05:43:18 <mauke> that value can be a tuple or a list, though
05:45:06 <erus_> oh god i really dont know what im doing
05:45:16 <erus_> im just typing characters and hoping for the best
05:45:45 <jaspervdj> tibbe: Alright, my application is finally up
05:46:14 <adlsaks> hrm..  So, I'm trying to make the types explicit for my property rather than have ghc figure them out - I've gone with what ghci told me about another property's return type
05:46:21 <adlsaks> I've ended up with Positive Integer -> Positive Integer -> [Positive Integer] -> Test.QuickCheck.Property.Property
05:46:28 <adlsaks> Why is this incorrect? 
05:46:30 <erus_> http://hpaste.org/45422/fail
05:46:44 <adlsaks> ie: it barfs on the Test.QuickCheck property
05:46:52 <mauke> erus_: map takes 2 args, not 1
05:46:59 <Eelis> adlsaks: what is the error?
05:47:07 <dmwit> adlsaks: I doubt anyone could possibly say without seeing some code and/or the error.
05:47:10 <adlsaks>    Not in scope:
05:47:10 <adlsaks>       type constructor or class `Test.QuickCheck.Property.Property'
05:47:18 <Eelis> adlsaks: try just making it Bool
05:47:20 <adlsaks> However, I've imported Test.QuickCheck
05:47:20 <mauke> erus_: px py is not a valid pattern
05:47:25 <Eelis> the inferred type may be needlessly general
05:47:27 <dmwit> adlsaks: Have you imported Test.QuickCheck.Property?
05:48:08 <dmwit> erus_: let (px, py) = project x y z
05:48:29 <erus_> ah thanks guys
05:48:41 <jonkri> is it possible to have an ordered map in haskell, which is not ordered by the keys but by the sequence
05:48:43 <jonkri> of insertion
05:48:52 <mauke> jonkri: you mean a list?
05:49:20 <jonkri> mauke, yes, but with key-based access functions
05:49:29 <mauke> :t lookup
05:49:30 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
05:49:37 <jonkri> wonderful :)
05:49:44 <adlsaks> Eelis: "Gen Prop" worked
05:49:57 <adlsaks> dmwit: Importing Test.QuickCheck.Property worked
05:50:17 <adlsaks> interestingly, now it complains that a Positive Integer is not an Integer
05:50:23 <adlsaks> ... I can sort of see its point
05:50:34 <Eelis> adlsaks: you may need to project the Integer out of it
05:50:41 <erus_> :show bindings
05:51:37 <Eelis> adlsaks: alternatively, do the pattern match immediately in the parameter list:   myprop (Positive x) (Positive y) = ...
05:52:05 <adlsaks> eelis: I've tried googling a few variations of projecting types - could you give me a pointer to somewhere that i can read more? 
05:52:37 <Eelis> adlsaks: oh, i really mean nothing more than pattern matching to expose the (sole) constructor and its data field
05:52:52 <Eelis> sometimes there's a function that does this, which can be said to "project" the field out of the thing
05:53:10 <Eelis> @src snd
05:53:10 <lambdabot> snd (_,y) =  y
05:53:12 <Eelis> like that.
05:53:25 <Eelis> but for a newtype it's even simpler :)
05:53:28 <adlsaks> ah 
05:54:28 <tromp_> :t (flip .) . (.) . (flip flip . join)
05:54:29 <lambdabot> forall (f :: * -> *) a b (m :: * -> *) a1. (Functor f, Monad m) => m (m a1) -> f (a -> m a1 -> b) -> a -> f b
05:55:31 <erus_> is there something like show that converts to string without quotes?
05:55:52 <erus_> ignore that
05:56:05 <ManateeLazyCat> Lemmih: Hey.
05:56:10 <tibbe> jaspervdj, yay!
05:56:54 <adlsaks> hrmm- do I need to define my match recursively to pattern match a [Positive Integer] type? 
05:56:55 <tromp_> id shows a string without quotes:)
05:57:08 <adlsaks> ie: clearly [Positive z] won't work in the match
05:57:34 <ManateeLazyCat> I remember someone want to learn Chinese at today morning
05:57:34 <erus_> is there support for variable length arguments in Haskell?
05:57:49 <ManateeLazyCat> erus_: Yes, Nested Tuple
05:57:56 <adlsaks> can do I do better than Positive z:zs = z myProp (zs)? 
05:58:24 <mauke> erus_: not really, but it's doable
05:58:45 <mauke> erus_: if the arguments are all the same type, the easiest way is to use a list instead
05:58:45 <erus_> so could one make a print function like pythons?
05:59:00 <ManateeLazyCat> erus_: If you talk about *same* function can accept different number argument, it can't
05:59:07 <mauke> > "watch: " ++ printf "hello, %s %d" "world" 42
05:59:08 <lambdabot>   "watch: hello, world 42"
05:59:16 <Eelis> adlsaks: hm, i'd define   positive (Positive x) = x  and then do   map positive zs   to turn the [Positive Integer] into an [Integer]
05:59:46 <adlsaks> eeli: Thanks again :) 
05:59:55 <Eelis> i wonder why QuickCheck doesn't provide the projection out of the box though
05:59:57 <ManateeLazyCat> And funny thing, i ask at #python "could Python do some like Haskell" .:)
06:00:19 <tromp_> :t printf
06:00:20 <lambdabot> forall r. (PrintfType r) => String -> r
06:00:26 <tibbe> jaspervdj, are you prepared to learn Core for this project? you most likely will have to
06:00:48 <mauke> printf is plain old H98
06:01:35 <adlsaks> eel: it's probably just me learning rather than QuickCheck.. i'm still constantly running into the type system
06:02:28 <Eelis> adlsaks: if you use my full nick, my client notifies me of your message
06:03:15 <Eelis> adlsaks: if typing a whole nick is too hard, see if your client has nick completion (e.g. with "tab")
06:03:25 <erus_> have any of you tried pure?
06:03:29 <coredump|br> So... I am reading LYAHFGG and I feel like someone punched me in the head. When does this sensation goes away? :P
06:04:01 <Eelis> coredump|br: after your third monad tutorial. by then it feels like you've got no more head.
06:04:05 <dmwit> coredump|br: If you're lucky, not until you die!
06:04:07 <Saizan> coredump|br: after your head gets soft enough
06:04:31 <dmwit> When the sensation goes away, that means you're not learning quickly enough. ;-)
06:05:51 <adlsaks> Eelis, yes - i just hadn't hit tab ;) thanks!
06:07:24 <jaspervdj> tibbe: I know a little Core, and I'm very interested in learning more
06:09:04 <tibbe> jaspervdj, good
06:09:14 <tibbe> jaspervdj, it's the best way to really figure out what's going on
06:09:20 <tibbe> jaspervdj, takes the guessing out of it
06:09:47 <jaspervdj> Yeah, it's pretty much an invaluable skill once you go low-level enough imo
06:09:54 <tibbe> jaspervdj, I found the reason binary is slower than blaze-builder by reading the core for an hour :)
06:09:59 <tibbe> jaspervdj, yes
06:10:04 <tibbe> jaspervdj, it's also fun!
06:10:08 <jaspervdj> :-D
06:10:11 <erus_> should one only ever use 'do' when performing an unpure operation?
06:10:13 <tibbe> teaches you a lot about GHC
06:10:43 <cheater> is it generally good to use "do" as far outside as possible?
06:11:07 <hpc> eh?
06:11:09 <cheater> if i put it very far "inside", will ghc be unable to perform many optimizations?
06:11:30 <hpc> do-notation is just syntax sugar for (>>=)
06:11:39 <cheater> hpc: say i have 20 nested function calls, is it better to put "do" in the one that is nested most or least?
06:11:48 <cheater> if i have a choice
06:12:11 <hpc> cheater: as opposed to...
06:12:19 <hpc> just calling (>>=) yourself?
06:12:28 <cheater> no, inside as opposed to outside
06:12:46 <cheater> say i call a, a calls b, calls c, calls d, ..., calls z
06:12:47 <jaspervdj> tibbe: I might write up another proposal if I have time tonight but it will be less elaborate
06:12:54 <erus_> hpc he means should he use unpure code in a function that is called by many functions
06:12:57 <hpc> i have no idea what you mean; do-notation vanishes very early in the compilation process
06:12:58 <cheater> is it better to have a "do" in the body of z, or in the body of a?
06:13:06 <mauke> why not all of them?
06:13:23 <hpc> cheater: are you asking about IO or do-notation?
06:13:24 <wlangstroth> tibbe, any good resources on Core you could share?
06:13:27 <cheater> i mean a calls b, b calls c, c calls d
06:13:29 <coredump|br> Eelis, dmwit Saizan sometimes I wanna cry
06:13:36 <mauke> > do (do 1 + do 2)
06:13:36 <cheater> i am talking about do notation.
06:13:36 <lambdabot>   3
06:13:46 <mauke> just put 'do' everywhere
06:14:10 <cheater> so it's not like ghc has a harder time handling functions with do in em?
06:14:14 <mauke> what
06:14:30 <tromp_> it's only sugar
06:14:33 <erus_> > let pure <- do getLine
06:14:34 <lambdabot>   <no location info>: parse error on input `<-'
06:14:38 <cheater> dunno, i'm just new to haskell and what is better and what is worse
06:14:43 <hpc> cheater: do-notation is removed very early in compilation, and replaced with (>>=)
06:14:43 <ion> It does, but you can pay it a bit better tip and it’ll be happy.
06:14:46 <mauke> cheater: it makes no difference
06:14:51 <cheater> ok thanks guys
06:14:57 <mauke> cheater: this is like asking if you should use vowels in your variable names or not
06:15:23 <cheater> well you know
06:15:39 <hpc> vowels are too slow for haskell
06:15:43 <hpc> consonants are webscale
06:15:45 <cheater> it makes sense if you ask "in php, should my loop be inside or outside five chained function calls?"
06:15:57 <erus_> can i ever get a value from a do from outside a do?
06:16:00 <ceii_> I thought GHC had a hard limit of 128 vowels per source file
06:16:07 <tibbe> wlangstroth, not so many I'm afraid. I intend to write some. Hold on a sec.
06:16:09 <mauke> erus_: yes, I just demonstrated it
06:16:11 <cheater> of course, haskell is not php, but i was wondering if it has a similar thing with do
06:16:12 <ion> It makes no sense to ask “in PHP, …”
06:16:18 <hpc> ^
06:16:19 <cheater> ion: yes :D
06:16:32 <erus_> :t do (do 1 + do 2)
06:16:33 <lambdabot> forall t. (Num t) => t
06:16:53 <hpc> @undo do {x <- y; z}
06:16:53 <lambdabot> y >>= \ x -> z
06:16:54 <ion> > do do do do do do do do do do do do do do do do do do do do do do 42
06:16:55 <lambdabot>   42
06:16:57 <wlangstroth> one of the great things about haskell is that it's not php
06:17:00 <tibbe> wlangstroth, http://johantibell.com/files/slides.pdf starting at the slide "GHC Core"
06:17:16 <erus_> :t do "Hello"
06:17:17 <lambdabot> [Char]
06:17:22 <hpc> cheater: use @undo and @do to see what different bits of code translate to
06:17:28 <hpc> @do y >>= \x -> z
06:17:29 <lambdabot> do { x <- y; z}
06:17:35 <erus_> :t do print "Hello"; "goodbye"
06:17:35 <dmwit> do "Hello" === "Hello"
06:17:36 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[Char]'
06:17:36 <lambdabot>     In the expression: "goodbye"
06:17:36 <lambdabot>     In the expression:
06:18:08 <wlangstroth> tibbe - thanks!
06:18:26 <ceii_> :t do 12
06:18:26 <lambdabot> forall t. (Num t) => t
06:18:51 <dmwit> You guys. This isn't that hard to understand.
06:18:56 <ceii_> oh, I didn't realize "do a" desugared to a without even requiring a monadic type
06:19:02 <dmwit> When your do block only has one line left in it, the translation is just "remove the do".
06:19:08 <ceii_> this is awesome confusion material
06:20:28 <erus_> > do { print "hi"; "goodbye" }
06:20:29 <lambdabot>   Couldn't match expected type `GHC.Types.IO b'
06:20:29 <lambdabot>         against inferred type...
06:21:20 <cheater> hpc: how do i use them? directly in ghci?
06:21:36 <hpc> cheater: lambdabot
06:21:51 <Jafet> @hackage lambdabot
06:21:52 <lambdabot> http://hackage.haskell.org/package/lambdabot
06:21:57 <cheater> thanks
06:22:07 <cheater> can i get my own lambdabot interpreter? :)
06:22:11 <cheater> that would be way cool
06:22:19 <erus_> ghci?
06:22:21 <monoidal> cheater: cabal install lambdabot
06:22:22 <hpc> you can /query lambdabot, for when you are on irc
06:22:23 <cheater> in my local shell have a lambdabot
06:22:28 <hpc> also cabal install :P
06:22:30 <cheater> which would be like /query lambdabot
06:22:34 <monoidal> cheater: I don't know if it compiles under newer ghc though
06:23:47 <erus_> Could one write a function that gets a line of input from stdin, converts it to an Int an returns it? or will it allways be an IO Int or whatever?
06:23:58 <monoidal> erus_: it will be IO Int
06:24:00 <hpc> erus_: it will be IO Int
06:24:08 <hpc> hivemind lol
06:24:51 <erus_> and you cant convert that to an Int?
06:24:54 <sipa> no
06:25:10 <sipa> but you can use it inside other IO a functions
06:25:11 <hpc> :t unsafePerformIO -- erus_
06:25:11 <lambdabot> Not in scope: `unsafePerformIO'
06:25:18 <monoidal> erus_: in Haskell, "Int" is an integer as in mathematics. It cannot use IO. It's like int x in C, not int x(void);
06:25:19 <sipa> which can pass it to normal functions as well
06:25:45 <sipa> erus_: oh, and technically, something of type "IO Int" is not a function
06:25:48 <sipa> it's an action
06:25:50 <hpc> erus_: unsafePerformIO is an eeeeeevil function
06:26:02 <monoidal> erus_: what do you want to do with the integer?
06:26:07 <Saizan> erus_: there's no need to convert IO Int to Int, because any function that accepts Int can be lifted to accept IO Int 
06:26:23 <monoidal> erus_: if you want to pass it into a function Int -> X, use fmap which will go IO Int -> IO X
06:26:54 <monoidal> erus_: if you want to pass it into a function Int -> IO X, use (>>=)
06:27:30 <erus_> so I cant get an Int from the keyboard and ever use it in a normal function? I have to write special function that take IO Ints?
06:27:40 <mauke> erus_: no
06:27:45 <monoidal> erus_: you can lift the function
06:27:45 <mauke> you never do that
06:27:49 <gio123> is there chanell for computer science?
06:27:54 <toby> erus_: you might like this tutorial: http://www.libra-aries-books.co.uk/software/doio
06:28:04 <mauke> erus_: what you get from the keyboard is not an IO Int
06:28:08 <wlangstroth> lifting is the key
06:28:10 <hpc> gio123: #categorytheory is at least an interesting subset
06:28:13 <mauke> erus_: the IO Int is the thing that gets stuff from the keyboard
06:28:17 <hpc> dunno of one for general CS though
06:28:21 <hpc> perhaps -blah, too
06:28:53 <gio123> hpc: empty chanell 
06:28:55 <gio123> :)
06:29:06 <hpc> er, ##categorytheory
06:29:20 <monoidal> preflex: seen byorgey
06:29:20 <preflex>  byorgey was last seen on #haskell 17 hours, 21 minutes and 58 seconds ago, saying: Maxdamantus, xplat: -blah please =)
06:30:56 <wlangstroth> anyone else on ox x having a hard time getting cabal to see c libraries?
06:31:13 <wlangstroth> *os x
06:31:36 <sipa> you need the frameworks system, i suppose
06:39:57 <erus_> http://hpaste.org/45423/fail2
06:40:20 <erus_> Can anyone infer what im trying todo and adapt it so that it builds?
06:41:29 <erus_> ah
06:41:36 <erus_> missed the brackets around arguement
06:41:40 <monoidal> erus_: canvas (x, y)
06:42:47 <erus_> now how the hell do i do this in one expression :/
06:42:57 <monoidal> erus_: in definition
06:43:08 <monoidal> where canvas (x, y) = ...
06:44:44 <frerich> erus_: 'project' returns a single value (a tuple of two doubles) but your 'canvas' function takes two arguments.
06:45:09 <erus_> yer its working now thanks guys
06:45:21 <merijn> Also (not necessary here, but useful for the future)
06:45:24 <merijn> :t curry
06:45:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:45:36 <hpc> :t curry `asTypeOf` uncurry
06:45:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = ((a, b), b1)
06:45:37 <lambdabot>       Expected type: a
06:45:37 <lambdabot>       Inferred type: ((a, b), b1)
06:45:47 <merijn> :t asTypeOf
06:45:48 <lambdabot> forall a. a -> a -> a
06:45:50 <hpc> aw, that would have been cool
06:45:55 <hpc> :t uncurry
06:45:56 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:46:00 <merijn> Color me confused...
06:46:18 <merijn> Oh, wait. I missed an a there
06:46:25 <hpc> asTypeOf :: a -> a -> a; asTypeOf x _ = x
06:46:37 <hpc> it's a very clever trick
06:46:48 <merijn> @src asTypeOf
06:46:48 <lambdabot> asTypeOf = const
06:46:54 <merijn> :t const
06:46:55 <lambdabot> forall a b. a -> b -> a
06:50:50 <jonkri> in "data PubsubNode = PubsubNode NodeName [(ItemID, a)] [Subscriber]", how can i specify that a should be of the type class XMLable?
06:51:03 <jonkri> data PubsubNode a*
06:51:23 <dmwit> The usual advice is: don't.
06:51:52 <dmwit> Let functions that require it put XMLable a => in their context, and functions that produce it likewise.
06:52:09 <monoidal> jonkri: in theory you could do data XMLable a => PubsubNode = ...". However, this is only a burden, and is planned to be removed in haskell 2011
06:52:42 <jonkri> ok, thanks
06:56:56 <erus_> its so insanely hard to do anything simple in haskell
06:57:28 <fryguybob> erus_: such as?
06:57:43 <Botje> erus_: yes, but it makes the impossible absurdly easy, so not everything is a loss :]
06:58:15 <erus_> set up a structure that would work like a nested for loop in C
06:59:04 <merijn> erus_: Use multiple map calls?
06:59:12 <luite_> erus_: keep in mind that you can often use lists where you'd use a for lop in imperative languages
06:59:22 <merijn> Or nested list comprehensions, etc
06:59:28 <eikke> erus_: from my experience, you might be tackling things the wrong way
06:59:30 <luite_> erus_: list comprehensions or the list monad should make your life easier
06:59:35 <Tomsik_> for loop is basically a fold
06:59:37 <merijn> erus_: Also approaching problems like "how do I do thing from language X in Haskell" that's a method doomed for failure and confusion
06:59:38 <hpc> or a sequence_
06:59:41 <Tomsik_> at least that's how I feel it
06:59:57 <eikke> erus_: if you got a problem you want to solve using Haskell, you shouldnt think "How would I do this using C? Ah, using nested for loops! Let me try this in Haskell"
07:00:03 <merijn> Tomsik_: I think about 75% of my for loops are maps, 25% are folds
07:00:30 <eikke> erus_: what you want is: "I don't care about C, Haskell is a rather different language. Let me think how I'd do this in Haskell, even though my knowledge might be minimal"
07:00:48 <hpc> i find most of my loops end up being map f . map g . map h...
07:01:22 <eikke> hpc: that's map (f . g . h), right? :)
07:01:26 <Cin> hpc: Does FUSION convert them to map (f . g . h)?
07:01:28 <hpc> eikke: indeed :P
07:01:29 <erus_> i cant use map because it doesnt provide an index
07:01:43 <hpc> Cin: that's a rewrite rule in ghc, iirc
07:01:44 <Cin> :t map f . zip [1..]
07:01:45 <lambdabot> forall b b1. (Show b1, SimpleReflect.FromExpr b) => [b1] -> [b]
07:01:47 <merijn> erus_: Why do you need an index? i.e. what are you trying to do...
07:02:10 <hpc> :t map ?f . zip [1..]
07:02:11 <lambdabot> forall b t b1. (?f::(t, b1) -> b, Num t, Enum t) => [b1] -> [b]
07:02:12 <Cin> hpc: Nice.
07:02:16 <frerich> erus_: You can use something like 'zip [0..] list' to turn some list in a list of tuples (and the first tuple element is the index)
07:02:24 <hpc> :t map (curry ?f) . zip [1..]
07:02:25 <lambdabot> forall b c t b1. (?f::((t, b1), b) -> c, Num t, Enum t) => [b1] -> [b -> c]
07:02:31 <hpc> :t map (uncurry ?f) . zip [1..]
07:02:32 <lambdabot> forall a b c. (?f::a -> b -> c, Num a, Enum a) => [b] -> [c]
07:02:36 <hpc> ha!
07:02:37 <eikke> erus_: map (\i e -> ...) $ zip [1..] mylist
07:02:41 <merijn> It is disquieting people are already suggesting solutions before they know what the problem is :(
07:03:19 <erus_> canvas (x, y) =  map (\x -> if x % 5 == 0 then ' \n' else ' ')  (take (5*5) [0..])
07:03:21 <luite_> erus_: typically you'd use zipWith f [1..] myList
07:03:32 <luite_> instead of map $ zip ...
07:04:24 <merijn> erus_: So your *actual* problem is "how do I insert a given element in a list every N entries?"
07:04:27 <erus_> concat $ map (\x -> if x `mod` 5 == 0 then " \n" else " ")  (take (5*5) [0..])
07:04:30 <Cin> merijn: c'est la #haskell
07:04:36 <erus_> merijn: no thats just making a blank canvas
07:04:44 <erus_> now i have to plot my point inside :)
07:04:55 <erus_> *brain explode*
07:05:33 <merijn> erus_: Yes you are. You basically want you serial list of output to be turned into an NxN grid, no?
07:06:09 <merijn> erus_: So essentially if you keep it a list until the final conversion to a [String] then you can at the end just insert a newline every N elements...
07:06:53 <wlangstroth> are we making ascii art?
07:06:59 <erus_> wlangstroth: basicly
07:07:08 <erus_> just plotting a 3d point 
07:07:33 <wlangstroth> oh, and you're testing out 2d first?
07:07:46 <luite_> erus_: so you want to change an element somewhere in the middle of a list?
07:07:46 <monoidal> erus_: try [f x y | x <- [1..5], y <- [1..5]]
07:07:49 <erus_> buffer[(y * buffer_width) + x % buffer_width] = 'x';
07:08:40 <luite_> erus_: ah, you could write a function: update :: Int -> a -> [a] -> [a]   first, that updates the element at some position of a one-dimensional list
07:09:10 <monoidal> erus_: do you have a list of (x,y) coordinates where to put 'x'?
07:09:21 <erus_> monoidal:  no a single point for now
07:09:44 <luite_> erus_: so update 2 'x' ['a','a','a','a'] = ['a','a','x','a']
07:10:06 <monoidal> erus_: [[if (x,y)==(x1,y1) then 'x' else ' ' | x <- [1..5]] | y <- [1..5]] - this gives 2d list
07:10:08 <erus_> ok
07:10:17 <luite_> erus_: you can write this function with Data.List.break, (++) and tail
07:10:42 <monoidal> erus_: given the list l, use intersperse ' ' (map join l)
07:10:46 <lars9> how is yi-editor's status now?
07:10:54 <luite_> erus_: keep in mind that you're basically copying the entire list up to the point that you update
07:11:05 <luite_> erus_: so this is highly inefficient, but a good exercise
07:11:35 <wlangstroth> no reason to optimize the ascii art just yet
07:11:55 <luite_> erus_: but fear not, more efficient ways are possible, even without monads :)
07:13:15 <erus_> I hope i just picked an awkward problem
07:13:28 <erus_> and not everything is as long winded to tackle in haskell
07:13:29 <monoidal> erus_: try different approach
07:13:41 <erus_> monoidal: draw x y z = addNewLines $ updateCanvas x y blankCanvas	
07:14:28 <HugoDaniel> how is the google summer of code filling up ?
07:14:31 <monoidal> erus_: what about this: start with list of lists of coordinates, like [[(0,0),(0,1)],[(1,0),(1,1)]]
07:14:49 <monoidal> erus_: then, map each point to character how it should be displayed
07:14:49 <HugoDaniel> are there already hackers for everything haskell ?
07:15:08 <monoidal> erus_: then, concatenate internal lists to get [[' ', ' '], ['x', ' ']]
07:15:12 <erus_> monoidal: ah thats a good idea
07:15:14 <merijn> HugoDaniel: Signs point to yes :p
07:15:34 <merijn> Oh, GSoC...then I don't know :p
07:15:37 <merijn> Reading is hard >.>
07:16:30 <monoidal> erus_: then, use intercalate "\n" which works like this: intercalate "a" ["x","y","z"] = "xayaz"
07:17:23 <monoidal> erus_: or, if you want last entry to have endline, concat $ map (++"\n") l
07:18:16 <fryguybob> @type unlines
07:18:17 <lambdabot> [String] -> String
07:19:20 <frerich> How do you people name your functions? I found that I'm often writing a lot of tiny little functions, but this means I have to come up with a lot of names. I can never decide whether a function should be named what it does (like, 'convertWeights', starts with a verb, suggests what argument it takes, or maybe 'convertWeightsToTree' which also suggests what it returns) or rather something like 'weightsAsTrees' or so.
07:19:29 <frerich> I can never decide whether I should use a verb or not. :-}
07:20:09 <merijn> frerich: I tend to use verbs and try to keep them as short as possible (especially if they are in where clauses, since they only have limited scope anyway)
07:20:43 <luite_> how many one-letter verbs are there? :p
07:20:54 <Twey> Don't you love it when you write twenty lines of code, come back to it in the morning, and think ‘oh, that's a filterM’ and rewrite it in two?
07:21:03 <Twey> luite_: Hmm
07:21:14 <luite_> 'f' must be a verb :p
07:21:16 <Twey> b, c, f, p
07:21:31 <Twey> q, r
07:21:42 <Twey> t
07:21:46 <Twey> Think that's it
07:22:15 <luite_> should be enough for the average where clause
07:22:21 <Twey> Should be, should be
07:25:31 <Eelis> Twey: i love it even more when, a year later, i see the filterM, have no idea what it does, and only understand the code once i expand it to the 20 line version :)
07:25:42 <Twey> Hahah
07:26:02 <Twey> I had it stuck in my head for some reason that filterM is one of those functions that really ought to be in the standard libraries but isn't
07:26:26 <Twey> So I Googled around for a version I could steal rather than bothering to figure it out myself, and stumbled onto one… in Control.Monad
07:26:48 <hpc> Twey: fancy that! :P
07:27:37 <Twey> Haha, indeed
07:27:45 <erus_> how can i convert between number types? specifically Double -> Int ?
07:27:53 <Twey> @quote fromIntegral
07:27:53 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
07:28:06 <Twey> @quote need.a.Double
07:28:06 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
07:28:10 <Twey> Aw.
07:28:20 <Twey> Where'd that quote get to?
07:28:21 <dmwit> :t (floor, ceiling, round)
07:28:22 <lambdabot> forall a b a1 b1 a2 b2. (RealFrac a, Integral b, RealFrac a1, Integral b1, RealFrac a2, Integral b2) => (a -> b, a1 -> b1, a2 -> b2)
07:28:34 <Twey> Hah, yes, not the right type anyway in this case.  D'oh.
07:28:35 <dmwit> :t [floor, ceiling, round] -- duh
07:28:35 <lambdabot> forall a b. (RealFrac a, Integral b) => [a -> b]
07:28:45 <erus_> :t round
07:28:46 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:29:10 <aristid> :t floor
07:29:10 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:29:13 <dmwit> > (round 2.5, round 3.5) -- be careful, though
07:29:14 <lambdabot>   (2,4)
07:29:32 <aristid> > (round***round) (2.5, 3.5)
07:29:33 <lambdabot>   (2,4)
07:29:40 <dmwit> > [1.5 .. 3.5] -- a particularly weird consequence
07:29:41 <lambdabot>   [1.5,2.5,3.5]
07:29:44 <aristid> wow i actually picked the right one out of *** and &&&
07:29:45 <dmwit> err
07:29:50 <frerich> :t map (\x -> (head x, length x)) . group . sort
07:29:51 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
07:29:52 <dmwit> > [1.5 .. 3] -- a particularly weird consequence
07:29:52 <lambdabot>   [1.5,2.5,3.5]
07:29:55 <hpc> > (round *** round *** round) (1,(2,3))
07:29:55 <lambdabot>   (1,(2,3))
07:29:59 <hpc> ha!
07:29:59 <aristid> > [1.5,1.6 .. 3]
07:30:00 <lambdabot>   [1.5,1.6,1.7000000000000002,1.8000000000000003,1.9000000000000004,2.0000000...
07:30:20 <hpc> FT: it would be really nice if (1,2,3) == (1,(2,3))
07:30:26 <dmwit> > [2.7, 2.8 .. 3]
07:30:26 <lambdabot>   [2.7,2.8,2.8999999999999995,2.999999999999999]
07:30:50 <Phyx-> hmm I accidently connected to EFnet just now and was wondering what happened to #haskell, lol
07:31:36 <Twey> Oh no!  Quick, flee!
07:32:15 <aristid> > [2.7,2.8..]
07:32:16 <lambdabot>   [2.7,2.8,2.8999999999999995,2.999999999999999,3.0999999999999988,3.19999999...
07:32:19 * frerich loves this fuzzy feeling when you whip up a simple function composed of three to five other functions. That's about the number of compositions I need to think I have a real gem.
07:32:22 <Cin> EFnet doesn't exist. It's just a tale old Freenode veterans tell to scare the newbies.
07:32:31 <Phyx-> rofl
07:32:36 <ion> > [1.5,1.6 .. 3] :: [Ratio]
07:32:37 <lambdabot>   `GHC.Real.Ratio' is not applied to enough type arguments
07:32:37 <lambdabot>  Expected kind `*'...
07:32:57 <Cin> > [1.5,1.6 .. 3] :: [Ratio Integer Integer]
07:32:58 <lambdabot>   `GHC.Real.Ratio' is applied to too many type arguments
07:33:00 <ion> > [1.5,1.6 .. 3] :: [Rational]
07:33:00 <lambdabot>   [3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1,21 % 10,11 % 5,23 % 10,12 % 5,5 % ...
07:33:09 <Cin> > [1.5,1.6 .. 3] :: [Ratio Integer] -- Oops.
07:33:10 <lambdabot>   [3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1,21 % 10,11 % 5,23 % 10,12 % 5,5 % ...
07:33:16 <Cin> @src Rational
07:33:16 <lambdabot> type Rational = Ratio Integer
07:33:36 <dmwit> > [1.5 .. 3] :: [Rational]
07:33:37 <lambdabot>   [3 % 2,5 % 2,7 % 2]
07:33:50 <hpc> > map fromIntegral ((%) <$> [1..] <*> [2..]) :: Double
07:33:52 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
07:33:52 <lambdabot>         against inferred ty...
07:34:02 <hpc> :t fromIntegral
07:34:02 <lambdabot> forall a b. (Integral a, Num b) => a -> b
07:34:06 <hpc> oh, derp
07:34:15 <ion> > map fromRational ([1.5,1.6 .. 3] :: [Rational])
07:34:16 <lambdabot>   [1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.0]
07:34:17 <Phyx-> :t x
07:34:17 <lambdabot> Expr
07:34:24 <Phyx-> :t x * x
07:34:25 <lambdabot> Expr
07:34:44 <Phyx-> :t @src Num Expr
07:34:45 <lambdabot> parse error on input `@'
07:34:48 <Phyx-> @src Num Expr
07:34:48 <lambdabot> Source not found.
07:34:57 <Phyx-> @src Expr Num
07:34:57 <lambdabot> Source not found. My pet ferret can type better than you!
07:35:01 <Phyx-> :/
07:35:14 <dmwit> The instance isn't very interesting.
07:35:19 <Phyx-> sheesh, first insulted on a website, now by a bot
07:35:20 <dmwit> (*) = op "*"
07:35:22 <dmwit> etc.
07:36:06 <Phyx-> dmwit: aha
07:36:15 <Phyx-> what's that Expr type?
07:36:16 <dmwit> Expr is the free Num (where "free" has the same sense as in "free monoid", "free monad", etc.)
07:36:16 <Phyx-> TH?
07:36:27 <dmwit> No, no template-haskell needed.
07:36:31 <dmwit> Just something like
07:36:42 <dmwit> Well, why not read the blog post yourself?
07:36:46 <dmwit> ?hackage simple-reflect
07:36:46 <lambdabot> http://hackage.haskell.org/package/simple-reflect
07:37:04 <dmwit> The home page listed there describes it.
07:37:15 <Phyx-> cool thanks:)
07:38:35 <Phyx-> neat!
07:38:43 <erus_> monoidal: i have it working :) i just need to split my string every n characters and add a new line after each split. any ideas?
07:39:04 <dmwit> erus_: Check Data.List.Split, from the split package.
07:39:09 <dmwit> Also,
07:39:11 <dmwit> :t intersperse
07:39:11 <lambdabot> forall a. a -> [a] -> [a]
07:39:19 <dmwit> :t intercalate
07:39:20 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:39:24 <Phyx-> > foldr (fun "f") (var "x") [1...5]
07:39:24 <lambdabot>   Not in scope: `...'
07:39:26 <Saizan> :t unlines
07:39:27 <lambdabot> [String] -> String
07:39:31 <Phyx-> > foldr (fun "f") (var "x") [1..5]
07:39:31 <lambdabot>   No instance for (SimpleReflect.FromExpr
07:39:31 <lambdabot>                     (Data.Number.Sy...
07:39:46 <Phyx-> > foldr (fun "f") (var "x") [1..(5 :: Int)] 
07:39:47 <lambdabot>   No instance for (SimpleReflect.FromExpr
07:39:47 <lambdabot>                     (Data.Number.Sy...
07:39:56 <dmwit> Man, I always forget about unlines and unwords. yeesh
07:40:03 <aristid> :t fun
07:40:03 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
07:40:11 <dmwit> > foldr (fun "f") (var "x") [1..5 :: Expr]
07:40:12 <lambdabot>   No instance for (SimpleReflect.FromExpr
07:40:12 <lambdabot>                     (Data.Number.Sy...
07:40:17 <Phyx-> :t foldr (fun "f") (var "x") [1..5]
07:40:17 <lambdabot> forall a. (Show a, SimpleReflect.FromExpr (Sym a)) => Sym a
07:40:27 <erus_> Phyx-: i cant fold because i have to insert chars to the list not just change them
07:40:30 <aristid> > foldr (fun "f") (var "x") [1..5] :: Sym Expr
07:40:31 <lambdabot>   No instance for (SimpleReflect.FromExpr
07:40:31 <lambdabot>                     (Data.Number.Sy...
07:40:42 <aristid> :t var
07:40:43 <lambdabot> forall a. String -> Sym a
07:40:44 <dmwit> > foldr (fun "f") (var "x") [1..5]
07:40:45 <lambdabot>   No instance for (SimpleReflect.FromExpr
07:40:45 <lambdabot>                     (Data.Number.Sy...
07:40:49 <dmwit> bleh
07:40:49 <aristid> oh. var is evil.
07:40:52 <Saizan> > foldr (fun "f") (fun "x") [1..5] :: [
07:40:52 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:40:58 <Saizan> > foldr (fun "f") (fun "x") [1..5] :: [Expr]
07:40:58 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
07:40:59 <lambdabot>    arising fr...
07:41:00 <aristid> lol
07:41:07 <Phyx-> erus_: it wasn't meant as an answer for your question :)
07:41:10 <aristid> Saizan: Expr not [Expr]
07:41:17 <erus_> oh :P carry on
07:41:21 <Saizan> > foldr (fun "f") (fun "x") [1..5] :: Expr
07:41:22 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 x))))
07:41:25 <Saizan> yay.
07:41:27 <monoidal> erus: Do you have it in 2d list?
07:41:27 <Phyx-> lol
07:41:42 <Phyx-> @Saizan++
07:41:42 <lambdabot> Unknown command, try @list
07:41:43 <erus_> monoidal: yep
07:41:52 <Phyx-> @karma++ Saizan
07:41:52 <lambdabot> Saizan's karma raised to 22.
07:42:03 <Phyx-> 22, karma god
07:42:03 <monoidal> erus_: use map join
07:42:14 <monoidal> erus_: if you don't have a list of strings
07:42:18 <monoidal> erus_: and then "unlines"
07:42:31 <monoidal> > unlines ["aaa", "bbb", "ccc"] -- erus__
07:42:32 <lambdabot>   "aaa\nbbb\nccc\n"
07:42:34 <erus_> no i have a list of chars representing pixels
07:42:38 <ezyang> > "\SOH" 
07:42:38 <lambdabot>   "\SOH"
07:42:45 <ezyang> what is \SOH? 
07:43:31 <monoidal> erus_: so you have a single string? Maybe you can change it so it will be a list of lists
07:43:38 <Twey> ezyang: ASCII Start Of Heading control character
07:43:45 <aavogt> > '\FAH'
07:43:46 <lambdabot>   <no location info>:
07:43:46 <lambdabot>      lexical error in string/character literal at chara...
07:43:46 <Phyx-> > '\SOH'
07:43:47 <lambdabot>   '\SOH'
07:43:53 <monoidal> erus_: paste code?
07:43:58 <ezyang> ah, I see. 
07:44:02 <tromp_> > - (0 :+ 1 :: Complex Int)
07:44:03 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
07:44:03 <lambdabot>    arising from a use o...
07:44:08 <tromp_> why is that??
07:44:17 <erus_> monoidal: yes i would like to split it into a list of strings    String -> [String]    then   unlines it
07:44:32 <aavogt> > - (0 :+ 1 :: Complex Rational)
07:44:32 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Real.Rational)
07:44:33 <lambdabot>    arising from a u...
07:44:45 <dmwit> erus_: Have you looked at Data.List.Split yet?
07:44:55 <monoidal> erus_: Given your task, it would be better to build it as [String]
07:44:57 <aristid> tromp_: Int is not a valid type for Complex calculations
07:45:00 <erus_> http://hpaste.org/45426/plotter
07:45:02 <erus_> dmwit: lookin now
07:45:06 <Saizan> tromp_: some unfortunate use of datatype constraints, though you need RealFloat for the Num instance
07:45:13 <Jafet> aavogt: get real!
07:45:16 <aristid> > - (0 :+ 1 :: Complex CReal)
07:45:16 <lambdabot>   0.0 :+ (-1.0)
07:45:38 <dmwit> > - (0 :+ 1 :: Complex Double)
07:45:39 <lambdabot>   (-0.0) :+ (-1.0)
07:45:40 <tromp_> but i only use operations that preserve ints:(
07:45:43 <Phyx-> > foldr f x [1..5]
07:45:43 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 x))))
07:45:48 <Phyx-> lol, that was easy
07:46:17 <dmwit> erus_: What are these semicolons doing in my Haskell??
07:46:26 <Phyx-> let (.) = \f g x = f (g x) in const x . const y
07:46:32 <Phyx-> > let (.) = \f g x = f (g x) in const x . const y
07:46:32 <lambdabot>   <no location info>: parse error on input `='
07:46:41 <Phyx-> > let (.) = \f g x -> f (g x) in const x . const y
07:46:42 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> SimpleReflect.Expr)
07:46:42 <lambdabot>    arisin...
07:46:49 <monoidal> erus_: I strongly recommend to change code to use tuples (x,y) instead of a single number
07:47:02 <monoidal> and divide it into (a/size, a%size)
07:47:04 <Phyx-> > let (.) = \f g x -> f (g x) in (const x . const y) z
07:47:05 <lambdabot>   x
07:47:09 <frerich> @src replicate
07:47:09 <lambdabot> replicate n x = take n (repeat x)
07:47:29 <dmwit> erus_: Also, why the deuce are you doing this with String and not, say, Array (Int, Int) Bool?
07:47:35 <Phyx-> > let (.) = \f g x -> f (g x) in  x . y) z
07:47:36 <lambdabot>   <no location info>: parse error on input `)'
07:47:42 <Phyx-> > let (.) = \f g x -> f (g x) in  (x . y) z
07:47:43 <lambdabot>   Couldn't match expected type `t -> t1'
07:47:43 <lambdabot>         against inferred type `Simpl...
07:47:52 <Phyx-> right
07:47:53 <monoidal> erus_: anyway, you can zip the list with cycle [0..n] and then replace places where there's 0 with '\n'
07:48:07 <Phyx-> > let (.) = \f g x -> f (g x) in  (x . y) 0
07:48:08 <lambdabot>   Couldn't match expected type `t -> t1'
07:48:08 <lambdabot>         against inferred type `Simpl...
07:48:13 <dmwit> String is such a lousy representation for rich data.
07:48:19 <Phyx-> well i'm confused
07:48:21 <Phyx-> why isn't that working
07:48:31 <dmwit> > f . g $ x
07:48:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:48:32 <lambdabot>    `GHC.Show.Show a'
07:48:32 <lambdabot>      a...
07:48:41 <erus_> im representing pixels in my shell
07:48:47 <erus_> they are characters
07:48:55 <erus_> 0 = blank space and X = my point
07:48:55 <monoidal> erus_: (if (a == (round(y) * canvasWidth) + (round(x) `mod` canvasWidth)) then "X" else "0") ++ (if a `mod` canvasWidth == 0 then "\n" else "")
07:49:15 <dmwit> erus_: If there are only two possible values, it's not a character, it's a Bool.
07:49:17 <monoidal> erus_: still, I recommend 2-dimensional array
07:49:28 <erus_> monoidal: i cant do ++ on chars
07:49:34 <dmwit> erus_: Now, how you *print* the data is completely different than how you store it.
07:49:38 <monoidal> erus_: I used strings not chars
07:49:55 <monoidal> erus_: You'll get a list like ['0', '0\n', 'X', '0\n']
07:50:02 <erus_> dmwit: who stores a pixel array as locations?
07:50:10 <monoidal> erus_: whoops, ["0", "0\n", "X", "0\n"]
07:50:18 <monoidal> erus_: then, use concat to join
07:50:25 <erus_> ah super
07:50:53 <monoidal> erus_: still, please try list comprehensions, that will be much easier
07:51:22 <dmwit> erus_: I don't even know what that question means.
07:52:59 <monoidal> > unlines [[if (x,y) == (2,3) then 'X' else '0' | y <- [1..4]] | x <- [1..4]]   -- erus_
07:53:00 <lambdabot>   "0000\n00X0\n0000\n0000\n"
07:55:09 <Veinor> > let merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs [] = xs; merge [] ys = ys in merge [2,5,8] [3,4,7]
07:55:10 <lambdabot>   [2,3,4,5,7,8]
07:55:41 <Veinor> > let merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs [] = xs; merge [] ys = ys; smooth = (1:) $ merge (map (2*) smooth) (map (3*) smooth) in take 10 smooth
07:55:42 <lambdabot>   [1,2,3,4,6,6,8,9,12,12]
07:55:46 <erus_> monoidal: thats a bloody easy way to do it :)
07:55:52 <Veinor> close enough!
07:56:09 <dmwit> > let merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs ys = xs ++ ys in merge [2,5,8] [3,4,7]
07:56:10 <lambdabot>   [2,3,4,5,7,8]
07:56:29 <Veinor> ah, true
07:57:02 <Veinor> > let merge (x:xs) (y:ys) | x == y = x : merge xs ys | x < y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs ys = xs ++ ys;  smooth = (1:) $ merge (map (2*) smooth) (map (3*) smooth) in take 10 smooth
07:57:04 <lambdabot>   [1,2,3,4,6,8,9,12,16,18]
07:57:25 <Veinor> try doing that imperatively :P
07:57:44 <Jafet> > let divisors n = filter ((==0).mod n) [1..n]; strand (x:xs) = x:filter (>x) xs in strand $ map (length.divisors) [1..]
07:57:46 <lambdabot>   [1,2,2,3,2,4,2,4,3,4,2,6,2,4,4,5,2,6,2,6,4,4,2,8,3,4,4,6,2,8,2,6,4,4,4,9,2,...
07:58:28 <Jafet> > let divisors n = filter ((==0).mod n) [1..n]; strand f (x:xs) = x:filter ((>f x).f) xs in strand (length.divisors) [1..]
07:58:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:59:22 <aristid> Jafet: nice way to get a list of numbers.
07:59:34 <monoidal> Veinor: assuming P is a priority queue: P.push(1); while (1) { x = P.pop(); print(x); P.push(x*2); P.push(x*3); }
07:59:37 <dmwit> > let isElement 1 = True; isElement x = (x `mod` 2 == 0 && isElement (x `div` 2)) || (x `mod` 3 == 0 && isElement (x `div` 3)) in filter isElement [1..]
07:59:40 <lambdabot>   mueval-core: Time limit exceeded
07:59:49 <dmwit> > let isElement 1 = True; isElement x = (x `mod` 2 == 0 && isElement (x `div` 2)) || (x `mod` 3 == 0 && isElement (x `div` 3)) in filter isElement [1..20]
07:59:50 <lambdabot>   [1,2,3,4,6,8,9,12,16,18]
08:00:01 <dmwit> That version is easily translated into imperative code.
08:00:07 <Veinor> monoidal: true
08:01:48 <Jafet> > let divisors n = filter ((==0).mod n) [1..n]; strand f (x:xs) = x:strand f (filter ((>f x).f) xs) in strand (length.divisors) [1..]
08:01:52 <lambdabot>   mueval-core: Time limit exceeded
08:02:25 <erus_> yey http://hpaste.org/45427/finished
08:02:43 <erus_> can i split the list thingymebobby over multiple lines
08:02:47 <erus_> ?
08:02:51 <Phyx-> 17:09:19 < aristid> Jafet: nice way to get a list of numbers. <--- loool
08:03:16 <Veinor> dmwit: i don't know if your version is as fast, though
08:03:26 <dmwit> Probably not.
08:03:48 <dmwit> ?faq can i split the list thingymebobby over multiple lines
08:03:48 <lambdabot> The answer is: Yes! Haskell can do that.
08:04:13 <Veinor> i want to say my version is O(n) to generate n 3-smooth numbers, whereas yours is O(n log n)
08:04:33 <monoidal> Veinor: my version?
08:04:34 <Botje> erus_: any good reason why you're nesting list comprehensions like that?
08:04:40 <aristid> @faq can haskell solve the halting problem?
08:04:40 <lambdabot> The answer is: Yes! Haskell can do that.
08:04:46 <erus_> monoidal: told me to
08:04:58 <erus_> :)
08:05:04 <Botje> erus_: and you could shift the if..then..else inside your list comps to a helper function
08:05:06 <Veinor> monoidal: your version is probably O(n log n) as well, yeah
08:05:36 <Veinor> or... faster than that if you use a vEB tree
08:05:49 <Veinor> the point is it's not linear!
08:06:01 <dmwit> Veinor: Yours is not linear, either.
08:06:19 <Veinor> it's not?
08:06:47 <dmwit> Let's see...
08:06:48 <pumpkin> :t assoc
08:06:49 <lambdabot> forall a b b1. ((a, b), b1) -> (a, (b, b1))
08:06:56 <pumpkin> :t first fst
08:06:56 <lambdabot> forall c b d. ((c, b), d) -> (c, d)
08:07:05 <pumpkin> :t second snd . assoc
08:07:05 <lambdabot> forall a b d. ((d, a), b) -> (d, b)
08:07:16 <pumpkin> TRIANGLE
08:07:35 <kowey> somebody cooked up a  small library with versions of zip, zipWith, etc that crash on lists with mismatching length
08:07:38 <kowey> anybody know the name of it?
08:07:48 <monoidal> Botje: to use unlines
08:08:09 <Botje> monoidal: ah, i see
08:08:28 <kowey> ah, I think I mean list-extras
08:09:09 <dmwit> Veinor: time ./test 1000000 -> 0.49s; time ./test 10000000 -> 11.42s
08:09:14 <dmwit> Veinor: Not linear. =)
08:09:27 <dmwit> Whoops, can't conclude that from two data points, hold on.
08:09:31 <opqdonut_> :D
08:09:35 <Veinor> eh, that looks pretty non-linear to me
08:09:38 <Veinor> unless the coefficient is massive
08:09:41 <opqdonut_> dmwit: well, an implied 0 -> 0
08:11:05 <nyingen> the combination of hexpat-pickle, fgl, and graphviz for visualizing graphlike data structures encoded in XML is pretty slick
08:11:33 <nyingen> the next step is to write some kind of abstraction layer that automatically converts graphlike data structures to the fgl graph type
08:11:39 <nyingen> syb-like
08:12:00 <nyingen> I was actually kind of surprised that graphviz didn't do that already, but the FAQ says it may be in the works
08:13:23 <dmwit> 0.49s, 11.42s, >178s (I got bored)
08:14:33 <dmwit> huh
08:14:38 <Veinor> yeah, that's definitely nonlinear :P
08:14:47 <dmwit> > '\n' `isElem` show (10^1000)
08:14:47 <lambdabot>   Not in scope: `isElem'
08:14:54 <dmwit> > '\n' `elem` show (10^1000)
08:14:54 <lambdabot>   False
08:15:14 <Cin> @src elem
08:15:14 <lambdabot> elem x    =  any (== x)
08:15:26 <Cin> @src any
08:15:26 <lambdabot> any p =  or . map p
08:15:29 <Cin> lol
08:15:37 <Cin> @src or
08:15:37 <lambdabot> or    =  foldr (||) False
08:16:54 <dmwit> Cin: Keep going! you haven't looked at the source for map, foldr, or (||) yet. ;-)
08:17:04 <Veinor> @src foldr
08:17:04 <lambdabot> foldr f z []     = z
08:17:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:17:09 <Veinor> I N C E P T I O N
08:18:00 <aristid> @src map
08:18:00 <lambdabot> map _ []     = []
08:18:01 <lambdabot> map f (x:xs) = f x : map f xs
08:18:04 <aristid> @src (||)
08:18:05 <lambdabot> True  || _ =  True
08:18:05 <lambdabot> False || x =  x
08:18:47 <dmwit> (||) is left-biased! I knew it, the Haskell-designers were LEFTISTS!
08:18:51 <int-e> @type ?i?n?c?e?p?t?i?o?n
08:18:51 <lambdabot> Top level:
08:18:51 <lambdabot>     Occurs check: cannot construct the infinite type:
08:18:51 <lambdabot>       t = t1 -> t2 -> t3 -> t4 -> t5 -> t -> t6 -> t7 -> t8
08:19:22 <dmwit> > (True || undefined, undefined || True)
08:19:23 <lambdabot>   (True,*Exception: Prelude.undefined
08:20:06 <dmwit> :t lub
08:20:07 <lambdabot> Not in scope: `lub'
08:20:11 <dmwit> too bad
08:21:19 <monoidal> :t unamb
08:21:20 <lambdabot> Not in scope: `unamb'
08:22:14 <Aune> can you declare new types (like data Foo = ..) and or declare types to be members of type classes in ghci?
08:22:25 <dmwit> No.
08:22:27 <opqdonut_> no
08:22:31 <Aune> damn
08:22:40 <KirinDave> Aune: I feel your pain.
08:22:46 <dmwit> Success!
08:22:50 <dmwit> Prelude Data.Unamb> (newOr undefined True, newOr True undefined)
08:22:50 <dmwit> (True,True)
08:23:37 <aristid> @type ?I?n?c?e?p?t?i?o?N
08:23:38 <lambdabot> parse error on input `?'
08:23:46 <aristid> damn :D
08:24:14 <KirinDave> download-0.3.1.1 doesn't work with my haskell-platform. :\
08:24:18 <KirinDave> Is there a good alternative?
08:24:25 <int-e> Ah. GADTs make it easy. *Main> :t I N C E P T I O N    ==> I N C E P T I O N :: X
08:26:11 <int-e> (http://hpaste.org/45428)
08:27:09 <Veinor> incepto, the newest marvel superhero!
08:29:13 <aristid> KirinDave: if you don't mind a slightly less high-level interface, there would be http-enumerator and curl. i don't know which of the high-level interfaces are good.
08:29:32 <KirinDave> aristid: Thanks.
08:29:38 <KirinDave> I was just looking at http-enumerator.
08:30:33 <monoidal> it should be INCEPTION :: INCEPTION
08:30:56 <ezyang> no, it should be INCEPTION_1 :: INCEPTION_2 
08:30:59 <ezyang> stratified universe of types yo 
08:31:14 <Veinor> I N C E P T I O N is a bunch of data constructors though ;)
08:31:45 <aristid> int-e: type classes might make it possible too :)
08:31:48 <monochrom> data Inception = Inception Inception
08:32:11 <Veinor> INCEPTION :: BWAAAAMP
08:38:25 * hackagebot monad-par 0.1 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.1 (SimonMarlow)
08:40:32 <int-e> aristid: yeah. but it's hard to put data constructors into type classes :-)
08:40:54 <aristid> int-e: i n c e p t i o n
08:41:28 <monochrom> haha
08:41:31 <Phyx-> is it "data type" or "datatype"
08:41:47 <monochrom> depends on english or german
08:41:56 <Phyx-> lol
08:41:59 <Phyx-> english
08:42:05 <monochrom> data type
08:42:22 <Phyx-> ok, thanks
08:43:45 <Jafet> Wait, is it Datenart or Datentyp?
08:44:03 <int-e> typ.
08:44:27 <Berengal> In norwegian: datatype
08:44:28 * hackagebot monad-par 0.1.0.1 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.1.0.1 (SimonMarlow)
08:45:08 <nyingen> datatyper? datatypar?
08:45:11 <nyingen> (svenska)
08:45:40 <Berengal> Both.Two national languages :) (Actually three)
08:47:26 <Aune> datatyper in swedish
08:48:24 <luite_> datatype in Dutch, but with a different pronunciation
08:51:26 <paolino> hello, I have this function cycleDetect :: Ord a => [(a,Set a)] ->  Bool, I was thinking if using a Map a (Set a) I can make it  O (n * log n)
08:52:10 <paolino> I think my implementation is O (n^ 2)
08:52:20 <int-e> paolino: what's n?
08:52:34 <paolino> length of list
08:52:49 <mercury^> What does your function do?
08:53:00 <int-e> paolino: if this is a graph with n nodes and m edges, you'll have to look at every edge at least once. so that makes it quadratic.
08:53:15 <paolino> @paste
08:53:16 <lambdabot> Haskell pastebin: http://hpaste.org/
08:54:21 <paolino> mercury^: http://hpaste.org/45429/cycle_detect
08:55:09 <paolino> well, mine is worse then quadratic
08:56:35 <wharrrgarbl> @free wharrgarbl :: ((c1, c'1) -> c) -> ((c1, c'1) -> c') -> (a -> c1) -> (a -> c'1) -> a -> (c, c')
08:56:35 <lambdabot> h . q = f1 . $map_Pair f g => k . f2 = f3 . $map_Pair f g => f . f4 = f5 . p => g . f6 = f7 . p => $map_Pair h k . wharrgarbl q f2 f4 f6 = wharrgarbl f1 f3 f5 f7 . p
08:59:18 <int-e> paolino: O(m log n + n) is possible using a depth first search. [mark nodes white, grey or black; initially all nodes are white. As you visit a node, mark it grey, then visit its children. once that is done, mark it black. now visit all nodes in turn. the graph is cyclic if you ever visit a grey node.)
08:59:48 <int-e> paolino: ah and if you visit a black node you return immediately.
09:00:55 <jonkri> how can i put this typeclass-using function in a record? http://hpaste.org/45430/typeclass_function_in_record
09:01:00 <int-e> I'm sure this algorithm has a name, but I've learned about it in the context of (scavenging) garbage collection.
09:01:34 <paolino> int-e , it looks it needs mutable cells
09:02:04 <int-e> paolino: yeah but you can similate them with Data.Map. This is included in the log n factor.
09:02:15 <wharzl> are there things you can do with lisp macros that you can't do with pass by name?
09:02:16 <int-e> simulate.
09:03:16 <paolino> int-e Map a (Set a, Color) ?
09:04:00 <int-e> paolino: yes, that should work.
09:04:50 <ski> wharzl : create binders
09:05:15 <int-e> paolino: I'm not sure whether there's a nicer algorithm with almost quadratic (almost linear in the number of edges) complexity.
09:05:49 <ski> ("almost" ?)
09:06:05 <Veinor> int-e: wait, how do you return immediately if you visit a black node?
09:06:19 <Veinor> is this on directed or undirected edges?
09:06:57 <int-e> Veinor: directed
09:07:17 <paolino> an undirected edge is a cycle ?
09:07:31 <Veinor> then what if you have a grpah A -> B, A -> C, B -> D, C -> D
09:07:50 <ski> that's a DAG
09:07:50 <Saizan> jonkri: define the record like data Test = Test { testA :: Eq a => (a -> Bool) }
09:07:53 <Veinor> right
09:08:01 <Veinor> but his algorithm returns true unless i"m misinterpreting things
09:08:15 * ski wants to hand Saizan a `forall'
09:08:46 <Saizan> data Test = Test { testA :: forall a. Eq a => (a -> Bool) }
09:09:00 <Veinor> because you visit D twice; the second time, it's marked black, so you return, despite the fact that there's no cycles
09:09:09 <int-e> then you visit A (gray now), then B (gray), then D (gray, then black), return to B (black now), to A, from where you visit B (gray), D again (but it's black), return to B (black now), return to A (which now becomes black). Then you visit B, C and D, but all of them are black already.
09:09:42 <Veinor> oh
09:09:43 <ski> jonkri : how are you intending to make `Test' an instance of `Eq' ?
09:09:52 <Veinor> i misinterpreted what you meant by 'if you visit a black node you return immediately'
09:10:15 <int-e> I see. Yes, "return" is ambguous I guess.
09:10:22 <ski> jonkri : (i assume `testA t' is meant to be `testA b t' for some `Bool' `b')
09:10:32 <paolino> it's a don't go deeper
09:10:46 <Veinor> yeah, in that case it works
09:11:24 <ski> jonkri : oh, `testA' is not `test' .. what's the type of `testA', then ?
09:11:39 <ski> .. now i see it's the selector
09:12:18 <Saizan> "testA t" lacks an argument
09:12:21 * ski misunderstood what the code was trying to do
09:13:09 <ski> yes
09:13:36 <jonkri> let me see
09:13:47 <jonkri> never used this forall thing before :P
09:14:01 <ski> `testA t' has type `a -> Bool' for whatever type `a' you like
09:14:21 <jonkri> i don't want to specify it when i'm constructing the record though
09:14:25 <ski> well, any such type which is in `Eq'
09:14:52 <ski> yeah, so you want what Saizan wrote above, for the declaration of `Test'
09:15:24 <int-e> Veinor, paolino  http://hpaste.org/45431/acyclic  implements this algorithm (using arrays though, because I hade nodes labeled from 0 to size-1 already)
09:15:33 <ski> jonkri : but you still presumably want to pass some value to the function `testA t' of type `a -> Bool'
09:15:49 <ski> otherwise you're passing a function to `show', which i don't think you want to do
09:17:18 <int-e> Veinor, paolino  and andM is missing. but it's really liftM (&&)  except it does short-cut evaluation.  So  andM a b = do  a' <- a; if a' then b else return False
09:17:40 <ski> jonkri : saying `data Test = Test { testA :: forall a. Eq a => a -> Bool }' will make the constructor accept a *polymorphic* function (instead of a monomorphic *instance* of it), so then you can specify which instance you want, when you extract the field with `testA'
09:18:17 <ski> (you'll need a language extension to be able to have polymorphic constructor arguments/fields, though)
09:18:38 <jonkri> aha... that's what causing "Illegal symbol '.' in type"?
09:18:52 <ski> your not having enabled said extension
09:19:30 <ski>   {-# LANGUAGE PolymorphicComponents #-}
09:19:39 <ski> try adding that to the top of the source file
09:20:01 <Veinor> int-e: nice.
09:20:36 <jonkri> interesting :)
09:20:48 <ski> it works now ?
09:21:01 <ski> have you added an extra argument to `testA t' ?
09:21:17 <jonkri> yes, i get "False". why is "forall a." needed?
09:21:19 <int-e> Veinor, paolino: and my 'n' is the number of nodes plus the number of edges. so it's quadratic in the sense of paolino's original problem.
09:21:45 <jonkri> nevermind, i'll read up on it :)
09:21:50 <jonkri> thanks ski and Saizan :)
09:21:56 <ski> jonkri : i'm not definitely sure if it is actually needed or not, but in any case i think it's good to write it explicitly
09:22:23 <c_wraith> ski: how does that extension differ from Rank2Types?  (clearly, that's just defining a couple rank-2 functions)
09:22:26 <jonkri> ski, it wasn't needed in this case, but ok
09:22:33 <ski> jonkri : `forall' is what makes thing polymorphic .. in this case the component (i.e. argument/field)
09:22:45 <ski> if you write
09:22:48 <c_wraith> Oh, it differs in that the explicit forall isn't required?
09:22:51 <ski>   test :: Eq a => Bool -> a -> Bool
09:22:56 <ski> then this is short for
09:23:00 <ski>   test :: forall a. Eq a => Bool -> a -> Bool
09:23:16 <ski> (unless the type variable `a' is already in scope)
09:23:25 <jonkri> crazy :)
09:23:57 <ski> (there's another difference too, on type signatures for value/function definitions, but it's not important here)
09:24:30 <ski> mind that `forall' is not Haskell 98 though -- it is an extension
09:25:26 <ski> c_wraith : i don't recall the details, but i think it just enabled data constructors to be rank-2, as opposed to also any defined operation
09:25:59 <barshirtcliff_> what's a point-free way to convert decimal numbers to binary numbers?
09:26:12 <barshirtcliff_> I have one, but it hangs.  :(
09:26:24 <barshirtcliff_> (and it is not point-free!)
09:26:33 <Botje> :t showIntAtBase
09:26:34 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
09:26:58 <barshirtcliff_> Botje: cool.
09:27:07 <Botje> > showIntAtBase 2 ("01"!!) 12345 ""
09:27:08 <lambdabot>   "11000000111001"
09:27:26 <Botje> that's one way i know off-hand
09:27:30 <Botje> there's probably nicer ones
09:27:45 <jonkri> ski, a very useful extension imo... the thing that i want to do would be very hard to do without this. is it going to be included in haskell 2011?
09:28:13 <jonkri> not that it matters (for me)
09:28:15 <jonkri> :P
09:30:07 <jonkri> i got to go, take care :)
09:31:43 <ski> hm
09:32:51 <freedrull> Cin: i believe you have completed me as someone else
09:35:06 <ski> > ((showIntAtBase 2 intToDigit `flip` "") . foldl ((. digitToInt) . (+) . (10 *)) 0) "142857"  -- barshirtcliff
09:35:07 <lambdabot>   "100010111000001001"
09:35:46 <barshirtcliff> whoa!
09:35:59 <barshirtcliff> ski: pretty cool trick.
09:36:00 <ski> > ((showIntAtBase 10 intToDigit `flip` "") . foldl ((. digitToInt) . (+) . (10 *)) 0) "142857"
09:36:02 <lambdabot>   "142857"
09:36:24 <ski> (though here i think an explicit lambda is clearer than that `.'-jumble)
09:36:42 <FUZxxl> Is there a channel for discussions about GHC?
09:37:20 <ski> FUZxxl : #ghc ?
09:38:17 <FUZxxl> ski: thx
09:39:03 <ski> @unpl foldl ((. digitToInt) . (+) . (10 *)) 0
09:39:03 <lambdabot> foldl (\ e k -> (10 * e) + (digitToInt k)) 0
09:39:15 <barshirtcliff> Prelude Char> (showIntAtBase 10 intToDigit `flip` "") . foldl ((. digitToInt) . (+) . (10 *)) 0) "142857"
09:39:15 <barshirtcliff> <interactive>:1:82: parse error on input `)'
09:39:41 <ski> you missed an initial bracket
09:39:52 <ski> though maybe
09:39:52 <barshirtcliff> Ah.  so I did.
09:40:06 <ski> > (flip showIntAtBase 2 intToDigit "" . foldl ((. digitToInt) . (+) . (10 *)) 0) "142857"
09:40:07 <lambdabot>   Couldn't match expected type `GHC.Types.Int -> GHC.Types.Char'
09:40:07 <lambdabot>         agai...
09:40:12 <ski> er
09:40:21 <ski> ah
09:40:26 <ski> > (flip (showIntAtBase 2 intToDigit) "" . foldl ((. digitToInt) . (+) . (10 *)) 0) "142857"
09:40:28 <lambdabot>   "100010111000001001"
09:40:35 <ski> is clearer to you ?
09:41:03 <ski> or
09:41:24 <ski> > (showIntAtBase 2 intToDigit . foldl ((. digitToInt) . (+) . (10 *)) 0) "142857" ""
09:41:25 <lambdabot>   "100010111000001001"
09:42:28 <barshirtcliff> yeah, that's clearer, although it's still kind of mystifying.
09:43:08 <mm_freak> i think, i have already asked this once, but it's a difficult question:  how would you define a monad transformer combining Iteratee and StateT?
09:43:12 <Botje> why not just use a read? too boring?
09:43:59 <mm_freak> mainly i have two approaches:  'Iteratee a (StateT s m)' or 'StateT s (Iteratee a m)'
09:44:04 <mm_freak> both are not really satisfactory
09:44:22 <mm_freak> (talking about the enumerator package)
09:45:05 <ski> Botje : well, `reads' also handles minus sign .. and only base ten
09:45:29 <Botje> ah, that's a requirement
09:45:30 * ski doesn't grok `Iteratee'
09:45:30 <Botje> okay :)
09:45:31 <mm_freak> i would say, the former version is more convenient and more elegant, but less composable (i can't turn 'Iteratee a (StateT s m)' into 'Iteratee a m')
09:45:49 <mm_freak> ski: iteratees are easiest to learn by just using them
09:46:15 <ski> Botje : it might not be, but talking about different bases suggested to me to generalize the question to handle any two bases (greater than one)
09:46:44 <Egbert9e9> so i'm trying to write a simple stupid step counting monad and i'm terribly confused by all the errors ghci is complaining about. sec, pastebining
09:47:30 <Egbert9e9> http://pastebin.com/c1jjQQuN
09:47:44 <Egbert9e9> wht am i doing wrong?
09:48:32 * ski is always irritated when lots of calculators and things can diplay decimal fractions, but not binary or hexadecimal or sexagesimal fractions ..
09:49:16 <Egbert9e9> ski: that's lots of calculators for lots of people who don't need those features
09:49:29 <mrcarrot> how should i do to create a function that will generate (x,y,z) where each one is an integer between 1 and 10? 
09:51:04 <mrcarrot> randomly
09:51:11 <ClaudiusMaximus> > let x = 2 ; y = 3 ; z = 9 in (x,y,z) :: (Integer, Integer, Integer) -- like this?  or do you need all combinations in a certain order with/without repeats, or one at random, or something else?
09:51:12 <lambdabot>   (2,3,9)
09:51:15 <ski> Egbert9e9 : yeah sorry, i should have clarified : i mean when such calculators can display other bases at all
09:51:29 <nyingen> mrcarrot: you could just generate the list of all combinations, then pick from that randomly
09:51:35 <mrcarrot> ClaudiusMaximus: i forgot to mention the word random...
09:51:37 <ClaudiusMaximus> :t randomR
09:51:38 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:51:44 <ClaudiusMaximus> :t getStdGen
09:51:45 <lambdabot> IO StdGen
09:56:56 <ClaudiusMaximus> are tuples instances of Random ?  if not, why not?
09:58:15 <ski> mrcarrot : try
09:58:16 <ski>   getStdRandom (replicateM 3 (State (randomR (1,10))) `runState`)
09:58:54 * ski irritably wonders who hid `State' (and `Cont' and probably others) from lambdabot
09:59:16 <mrcarrot> what do i need to import to get State?
09:59:24 <ski> @index State
09:59:24 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS, Test.HUnit.Base, Test.HUnit, Test.HUnit.Base, Test.HUnit, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.
09:59:24 <lambdabot> Parsec, Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
09:59:28 <ski> the first one
10:00:22 <Saizan> ski: new mtl only has ContT and StateT, though there's state, maybe there's cont too
10:00:31 <ski> @type Cont
10:00:32 <lambdabot> Not in scope: data constructor `Cont'
10:00:34 <ski> @type runCont
10:00:34 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
10:00:38 <ski> i mean that
10:00:46 <Saizan> > runCont
10:00:47 <lambdabot>   Overlapping instances for GHC.Show.Show
10:00:47 <lambdabot>                              (Contr...
10:00:52 <ski> > Cont
10:00:54 <lambdabot>   Not in scope: data constructor `Cont'
10:00:56 <mrcarrot>     Ambiguous module name `Control.Monad.State':
10:00:56 <mrcarrot>       it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.1.0.1
10:01:02 <Saizan> > cont
10:01:03 <lambdabot>   Overlapping instances for GHC.Show.Show
10:01:03 <lambdabot>                              (((a -...
10:01:09 <ski> @type cont
10:01:10 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
10:01:12 <ski> hm
10:01:14 <mm_freak> does anyone still write monadic code?  i only write monad-transformic code lol
10:01:18 <ski> @type state
10:01:19 <lambdabot> forall s a. (s -> (a, s)) -> State s a
10:01:37 <Saizan> ski: type Cont r = ContT r Id
10:01:37 <ski> monad transformers yield monads
10:01:58 <ski> Saizan : oh, i see
10:02:20 <ski> Saizan : here i think my idea about having multiple `newtype' declarations for a type could help ..
10:02:41 <mm_freak> ski: i wanted to say, i use StateT even when State would suffice
10:03:00 <ski> polymorphic ?
10:03:02 <monoidal> anyone know any example of indexed comonad?
10:03:04 <mm_freak> yeah
10:03:35 <monoidal> i.e. coreturn :: m s s a -> a, cojoin :: m s1 s2 a -> m s1 s3 (m s3 s2 a)
10:03:35 <nejucomo> I'm writing a library with a separate unittest executable.  On another machine, I was able to define the library as a build-depends for the unittests in the .cabal...
10:03:43 <ski> monoidal : `newtype Cont2 o p a = MkCont2 ((a -> p) -> o)' and `newtype State2 s t a = MkState2 (s -> (t,a))'
10:04:02 <nejucomo> On this machine I get an error about circular dependencies.
10:04:11 <nejucomo> How do I work around this?
10:04:21 <monoidal> ski: these are indexed monads
10:04:26 <ski> (monoidal : or maybe the first two arguments of `Cont2' should be flipped -- i can never recall. trying to define `(>>=)'/`join' will show which)
10:04:36 <ski> monoidal : oh, sorry, i misread
10:04:44 <ski> monoidal : so, state in context
10:04:55 <monoidal> what is state in context?
10:05:02 <mm_freak> nejucomo: just leave the Build-depends field out
10:05:17 <ski>   newtype Store2 s t a = MkStore s (t -> a)  -- maybe flip `s' and `t' here
10:05:20 <monoidal> ski: something like (s1 -> a, s2)?
10:05:21 <ski> monoidal : ^
10:05:24 <ski> yes
10:05:27 <monoidal> ski: thanks, will check
10:05:30 <ski> (s/newtype/data/)
10:05:36 <mm_freak> nejucomo: if you use Hs-Source-Dirs for the executable, be sure to include '.' for the library
10:06:26 <mm_freak> nejucomo: if you want to include the library really as a library instead of a set of modules, you'll have to write two separate packages…  unless a recent cabal version has solved this
10:06:34 <nejucomo> mm_freak: Thanks.  I also noticed my previous platform was 2011.something for osx, and this is 1010.1 on debian.
10:07:06 <nejucomo> mm_freak: What's the difference between "really as a library" versus "a set of modules" ?
10:07:39 <mm_freak> nejucomo: if the executable is in the same project as a library, then it doesn't use the library as a dependency, but really just uses its source files
10:07:48 <nejucomo> I see.
10:08:00 <mm_freak> you will notice that the library modules in use get compiled twice
10:08:13 <Saizan> you can use the library as a dependency with a recent enough cabal
10:08:24 <mm_freak> Saizan: how?
10:08:31 <mm_freak> i'd like that, too
10:08:37 <Saizan> just put it in the build-depends: and use separate hs-source-dirs
10:08:53 <Saizan> though there's still a bug wrt haddock, iirc
10:11:17 <nejucomo> Saizan: So previously for the unittest executable I had "hs-source-dirs: test" but if I try "hs-source-dirs: test, src" it still fails.
10:11:56 <nejucomo> Maybe I should try to manually install a newer haskell platform, but I like aiming for standard stable debian dependencies...
10:12:28 <mm_freak> debian has always been a nightmare to me, when it comes to development
10:12:32 <mm_freak> especially haskell
10:12:48 <nyingen> yes, it is tricky
10:12:51 <cheater> i am not having a bad experience with ubuntu
10:13:02 <nyingen> I'm a debian user, but I gave up on 'apt' for haskell libs and now I just use cabal
10:13:53 <Saizan> nejucomo: if you cabal there is too old you'll also need to remove the library from the build-depends
10:14:03 <nejucomo> nyingen: I installed the "haskell-platform" debian, then ran "cabal update; cabal install cabal-install", so I think the haskell packages on top of the platform are recent, but the platform itself is still old.
10:14:18 <nyingen> nejucomo: ah, that may well be the case
10:14:22 <nejucomo> Saizan: I believe that's the case.  This is 2010.1.*
10:14:39 <nyingen> I may have actually compiled ghc and its libs from source to address that problem, but I can't remember
10:14:45 <nyingen> either that or I installed ghc from unstable
10:14:58 * nejucomo wonders if installing the unstable debian package or building from source is smoother.
10:15:20 <Saizan> www.haskell.org/ghc/ has nice generic linux binaries :)
10:15:36 <nyingen> Saizan: oh wait, I think that's what I did
10:15:43 <nyingen> it was a while back
10:16:23 * nejucomo starts building from source.
10:16:47 <nejucomo> So I'm a bit confused about the relationship between haskell-platform and ghc.  Does one depend on the other, or do they have a mutual dependency?
10:17:08 <bss03> Is there a way to compile and use a haskell shared library?  I'm pretty sure these is, but when I ldd my binaries, they don't seem to link to any of the haskell libraries I used.
10:17:30 <bss03> nejucomo: GHC is part of the haskell platform.
10:17:55 <bss03> So, the platform depends on GHC.  GHC also depends on a few packages from the platform, but not all of them.
10:18:32 <TomMD> nejucomo: GHC is a Haskell compiler.  The Haskell Platform bundles this compiler along with many common libraries and tools to give the developers a common set to work from.
10:23:12 <nejucomo> TomMD: That makes sense, but seems overly simplified.  For example, I cannot build the platform from source because my ghc is too old.  But my ghc depends on some platform packages?  I don't understand how the initial bootstrap works, but I'm about to find out.
10:23:18 * nejucomo starts building a newer ghc from source.
10:26:23 <Saizan> you usually download a ghc binary of the right version and then build the platform with it
10:28:51 <nejucomo> Saizan: I prefer either building from source or debian packages; I'm wary of non-debian pre-compiled binaries.
10:28:53 <Jafet> ghcs = unfoldr (Just.bootstrap) ghc
10:29:07 <nejucomo> The build appears quite smooth of ghc (bootstrapped from debian stable ghc).
10:31:38 * ski . o O ( `ghc = (foldr lub undefined . unfoldr (Just . bootstrap)) ghc' )
10:32:13 <Tomsik> :t lub
10:32:14 <lambdabot> Not in scope: `lub'
10:32:55 <newsham> http://haskell.org/haskellwiki/Lub
10:33:08 <Heikenashi> i love haskell.
10:33:51 <newsham> ?faq is haskell capable of love?
10:33:51 <lambdabot> The answer is: Yes! Haskell can do that.
10:34:14 <Heikenashi> ?faq can haskell solve world hunger
10:34:14 <lambdabot> The answer is: Yes! Haskell can do that.
10:34:56 <nyingen> @keal
10:34:56 <lambdabot> one prollem. T broke confines of the visual basic langage and would not compile
10:35:41 <mrcarrot> i am a beginner with haskell and i am still fighting with trying to get random tuples. can anyone explain why this code is not working: http://pastebin.com/hLZbKFAX
10:36:00 <Cin> @faq Has Haskell really been far even as decided to use even go want to do look more like?
10:36:00 <lambdabot> The answer is: Yes! Haskell can do that.
10:36:09 <aristid> random tuple: (4,4)
10:36:41 <aristid> :t getStdRandom
10:36:42 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
10:36:56 <ski> mrcarrot : you need `IO'
10:37:02 <aristid> :t randomR
10:37:02 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:37:16 <aristid> :t getStdRandom (randomR (1,10))
10:37:17 <lambdabot> forall t. (Num t, Random t) => IO t
10:37:32 <aristid> mrcarrot: why do you do these contortions with State?
10:37:52 <aristid> mrcarrot: also, you need to do everything in IO
10:37:54 <ski>   randomHeaps :: IO (Integer,Integer,Integer)
10:37:57 <mrcarrot> honestly, i do not know... i am trying to make use of the code i got earlier
10:38:00 <ski>   randomHeaps = do
10:38:08 <ski>     (a,b,c) <- getStdRandom (replicateM 3 (State (randomR (1,10))) `runState`)
10:38:11 <ion> > let f = (,) <$> r (1,10) <*> r (1,10); r = State . randomR in evalState f (mkStdGen 0)
10:38:11 <ski> er
10:38:12 <lambdabot>   Not in scope: data constructor `State'
10:38:15 <ski>     [a,b,c] <- getStdRandom (replicateM 3 (State (randomR (1,10))) `runState`)
10:38:18 <ski>     return (a,b,c)
10:38:41 <aristid> ski: i would just replicateM 3 on the outer getStdRandom
10:38:48 <rostayob> @hoogle [a] -> Bool
10:38:48 <lambdabot> Prelude null :: [a] -> Bool
10:38:48 <lambdabot> Data.List null :: [a] -> Bool
10:38:48 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
10:38:49 <aristid> or just copy the statement three times
10:38:56 <aristid> no reason to involve State there
10:39:24 <ski> mrcarrot : `replicateM 3' will give an `IO'-action that gives a list of three numbers, but you wanted a triple, so i matched on the list and `return'ed the triple
10:40:04 <ski> aristid : hm, i suppose .. (what about other threads ?)
10:40:57 <aristid> i think the standard random number interface sucks balls, btw
10:41:32 <ion> > let f = replicateM 10 $ (,) <$> r (1,10) <*> r (1,10); r = state . randomR in evalState f (mkStdGen 0)
10:41:34 <lambdabot>   [(6,6),(6,1),(3,10),(4,4),(4,9),(6,3),(5,3),(7,8),(3,4),(8,5)]
10:43:00 <ski> > let f = replicateM 10 $ liftM2 (,) `join` (state . randomR) (1,10) in evalState f (mkStdGen 42)
10:43:01 <lambdabot>   [(2,2),(8,5),(7,2),(9,2),(9,6),(6,10),(7,9),(5,6),(8,2),(4,7)]
10:43:47 <ski> aristid : any idea of improvement ?
10:44:40 <aristid> ski: random-fu has a mostly sane interface (it does abuse typeclasses somewhat)
10:45:03 <mrcarrot> thanks, now i have it working!
10:45:44 <nejucomo> Isn't this simpler for a newcomer?  let randomIntTriple = do { a <- randomIO; b <- randomIO; c <- randomIO; return (a, b, c) } :: IO (Int, Int, Int)
10:46:14 <ion> > let f = replicateM 5 $ (,,) <$> r <*> r <*> r; r = state $ randomR (1,10) in evalState f (mkStdGen 0)
10:46:15 <lambdabot>   [(6,6,6),(1,3,10),(4,4,4),(9,6,3),(5,3,7)]
10:46:20 <nejucomo> If you're more familiar with procedure oriented programming, that might be simpler to understand.
10:46:31 <sipa> :t randomIO
10:46:32 <lambdabot> forall a. (Random a) => IO a
10:46:40 <ion> @pl \r -> (,,) <$> r <*> r <*> r
10:46:40 <lambdabot> ((,,) <$>) . ((<*>) =<< join (<*>))
10:46:53 <ski> @type randomRIO
10:46:53 <lambdabot> forall a. (Random a) => (a, a) -> IO a
10:47:03 <ion> @pl \r -> liftM3 (,,) r r r
10:47:04 <lambdabot> join (join (liftM3 (,,)))
10:47:41 <dfilimon> hi guys, i'm having trouble using a variable bound through a <- in a where expression
10:47:47 <dfilimon> the code is here http://hpaste.org/45433/monad_fail
10:47:54 <mrcarrot> nejucomo: in your example, how do i get the numbers to be between 1 and 10?
10:47:56 <dfilimon> could anyone please take a look?
10:47:59 <aristid> ski: yeah i guess randomRIO is a good choice too :)
10:48:09 <aristid> :t replicateM 3 (randomRIO (1,10))
10:48:10 <lambdabot> forall t. (Num t, Random t) => IO [t]
10:48:55 <ion> dfilimon: In foo = bar where baz, variables bound in baz are available in the scope of bar, but not the other way around.
10:49:31 <dfilimon> yes, but i have args <- getArgs and then I try to use args in a where
10:49:36 <dfilimon> to make which = args !! 0
10:49:42 <dfilimon> and it says that args is not in scope
10:49:48 <dfilimon> why is that?
10:49:49 <ski> @. pl unpl join (.) join (liftM3 (,,))
10:49:49 <lambdabot> join (join (liftM3 (,,)))
10:50:39 <ClaudiusMaximus> > do { a <- return 3 ; let b = 3 * a ; return b } :: [Int] -- syntax of 'let' differs slightly in a do block (you don't need the 'in')
10:50:40 <lambdabot>   <no location info>: parse error on input `}'
10:50:48 <nejucomo> mrcarrot: Not quite sure, let's see:
10:50:58 <nejucomo> > :t randomRIO
10:50:59 <lambdabot>   <no location info>: parse error on input `:'
10:50:59 * ClaudiusMaximus fails..
10:51:18 <ski> > do { a <- return 3 ; let {b = 3 * a} ; return b } :: [Int]
10:51:18 <lambdabot>   [9]
10:51:22 <byorgey> dfilimon: if you have   x <- blah  in a do-block, the x is only in scope within the remainder of the do-block
10:51:25 <nejucomo> :t randomIO
10:51:25 <lambdabot> forall a. (Random a) => IO a
10:51:37 <nejucomo> > randomRIO (1, 10)
10:51:38 <lambdabot>   <IO Integer>
10:51:52 <byorgey> dfilimon: in a 'where' block, the only things in scope are parameters to the function the where is attached to
10:51:55 <nejucomo> Can lambdabot run IO?
10:52:06 <byorgey> nejucomo: no.
10:52:07 <dfilimon> oh :) my bad then
10:52:13 <dfilimon> i thought it was the same as a let
10:52:15 <ski> mrcarrot,nejucomo : `randomRIO (1,10)'
10:52:27 <byorgey> dfilimon: they are often interchangeable but not exactly the same.
10:52:27 <nejucomo> do { a <- randomRIO (1, 10); b <- randomRIO (1, 7); return (a, b) } :: IO (Int, Int)
10:53:08 <nejucomo> :t do { a <- randomRIO (1, 10); b <- randomRIO (1, 3); return (a, b) }
10:53:09 <lambdabot> forall t t1. (Num t, Random t, Num t1, Random t1) => IO (t, t1)
10:53:16 <byorgey> dfilimon: in particular, let ... in ...  is an expression which can be used anywhere.  'where' is special syntax that can only go after a declaration
10:53:34 <ski> byorgey : .. and `case' branches
10:53:42 <nejucomo> mrcarrot: Does that make sense?
10:53:51 <byorgey> ski: huh, I didn't know that!
10:54:15 <ski> > case () of () | True -> x where x = ()
10:54:16 <lambdabot>   ()
10:54:27 <nejucomo> The :t output says that code will work as long as the stuff in the tuple has Num and Random instances.
10:54:38 <ski> if you think about it, it makes sense
10:54:55 <dfilimon> well, now i get a different error at least and it sees the which
10:55:02 <dfilimon> although i still need to use a let
10:55:19 <dfilimon> also, you're saying there should be no 'in' if i use a let inside a do block ?
10:55:28 <byorgey> ski: you're right, because declarations with pattern matching are just sugar for case
10:55:29 <mrcarrot> i ended up trying this... but the sort is not working:
10:55:32 <mrcarrot> [a,b,c] <- sort (replicateM 3 (randomRIO (1,10)))
10:55:33 <ski> dfilimon : yes
10:55:41 <nejucomo> :t sort
10:55:41 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:55:47 <nejucomo> :t replicateM 3
10:55:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
10:55:48 <dfilimon> thanks guys :)
10:55:51 <ski> (if you use it as a `do'-command, rather than as an expression)
10:56:07 <dfilimon> also, can i put a do inside an if inside another do block to have it also print stuff?
10:56:18 <nejucomo> You are trying to sort an "m [a]" but you can only sort "[a]".
10:56:22 <byorgey> dfilimon: sure.
10:56:32 <ski> dfilimon : yes, `do' makes an expression
10:56:36 <nejucomo> This is of key importance in haskell.
10:56:48 <aristid> nejucomo: of course you can sort an m [a].
10:56:51 <aristid> :t fmap sort
10:56:52 <lambdabot> forall a (f :: * -> *). (Ord a, Functor f) => f [a] -> f [a]
10:57:11 <Twey> That's not sorting an m [a]
10:57:24 <Twey> That's adding a hook to sort the output when it comes out
10:57:27 <ski> > sort ([[],[1,4,2],[8],[5,7]] :: [] [Integer])
10:57:27 <lambdabot>   [[],[1,4,2],[5,7],[8]]
10:57:35 <Twey> Hah!
10:57:48 <dfilimon> ah, and adding the 'do' makes is return an IO type
10:57:52 <Twey> No
10:57:53 <dfilimon> so i need to use a <- instead of an =
10:57:59 <nejucomo> aristid: Yes, I realize that, but mrcarrot needs to understand the purpose of fmap (or I was going to suggest a do-construct, because IMO that's easier to understand at first for many procedural-backgrounded programmers).
10:58:12 <ski> dfilimon : adding `do' makes the type `m a' for a monad `m' and any type `a'
10:58:22 <ski> dfilimon : `IO' is a monad, but it's not the only one
10:58:22 <Twey> (not necessarily)
10:58:31 <dfilimon> how does it _know_ it's an IO monad?
10:58:33 <dfilimon> hmm, oh wait
10:58:37 <ski> > do ()
10:58:38 <lambdabot>   ()
10:58:40 <dfilimon> i used putStrLn
10:58:42 <dfilimon> :)
10:58:47 <Veinor> :t do ()
10:58:48 <lambdabot> ()
10:58:52 <byorgey> dfilimon: yes, type inference is smart =)
10:58:57 <Twey> dfilimon: Also it's probably called from main, directly or otherwise
10:59:03 <Twey> And main :: IO ()
10:59:13 <dfilimon> yup
10:59:14 <nejucomo> So mrcarrot: do { list <- replicateM 3 (randomRIO (1,10)); return (sort list) } 
10:59:22 <dfilimon> thanks for the help everyone
10:59:38 <Twey> dfilimon: do-notation is just sugar for >>= and >>
10:59:39 <ski> Prelude> :t \x -> do y <- x; x
10:59:40 <ski> \x -> do y <- x; x :: (Monad m) => m b -> m b
10:59:44 <sm> persistent requires db table names to be capitalised, is that right ?
10:59:57 <Twey> It's >>= and >> that require it to be a Monad, not the do-notation; that's just a trivial syntactic decoration
11:00:13 <ski> Twey : ok
11:00:24 <ski> (is that in Haskell98 ?)
11:00:31 <dfilimon> it makes it easier for us beginners use it though ;)
11:00:33 <Twey> ski: I have no idea
11:00:39 <Twey> dfilimon: Maybe
11:00:45 <Twey> dfilimon: Monads aren't as scary as people think they are
11:00:46 * nejucomo recommends realworldhaskell.org.
11:01:04 <Twey> Yeah, RWH and LYAH both have good explanations of monads.
11:01:41 <nejucomo> When I first ran into haskell, I tried something called "a gentle introduction ..." and was totally lost.  I also tried reading stdlib docs and was totally lost.  realworldhaskell.org was much smoother.
11:01:46 <nejucomo> What's LYAH?
11:01:54 <dfilimon> learn you a haskell
11:01:57 <nejucomo> Ah.
11:02:00 <djahandarie> LYAH is the easiest of them all
11:02:06 <dfilimon> it's really fun :)
11:02:12 * ski thought the gentle introduction was nice ..
11:02:27 <ski> .. but then i read it after "Haskell: The Craft of Functional Programming"
11:03:17 <djahandarie> ski, "Because Haskell is a purely functional language, all computations are done via the evaluation of expressions (syntactic terms) to yield values (abstract entities that we regard as answers). Every value has an associated type. (Intuitively, we can think of types as sets of values.)"
11:03:22 <djahandarie> You _really_ think that is gentle?
11:03:30 <djahandarie> That's the first line after the introduction
11:03:34 <Twey> Haha
11:03:43 <ski> djahandarie : *now* i do
11:03:43 <Twey> The Gentle Introduction set back my education by about six months
11:03:55 <ski> (and after reading Thompsons book, too)
11:04:18 <nejucomo> twey: hehe...
11:05:02 <nejucomo> It depends on the audience:  hackers who learn how to get stuff done via tutorials and are familiar with python/javascript/perl/c/bash -or- more mathy/academic computer sciencey types.
11:05:23 <ski> (i'm not saying i would have found it gentle if i hadn't read anything else on functional programming before)
11:05:59 <Twey> Maybe the Gentle Introduction is gentle from the point of view of someone with a mathematics Ph.D.
11:06:02 <Twey> I don't know
11:06:47 <ski> (probably it is gentle to someone who's seen e.g. SML before)
11:06:57 <djahandarie> It reads to me as if the audience should already know a language almost exactly like Haskell, and it will just be very explicit about things to clear up the differences
11:06:57 <nejucomo> I find the library docs take a long time to grok.  "The Data class comprehends a fundamental primitive gfoldl for folding over constructor applications, say terms. This primitive can be instantiated in several ways to map over the immediate subterms of a term"
11:07:17 <ski> @type gfoldl
11:07:18 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
11:07:27 <Twey> ski, djahandarie: Yes, perhaps that's it
11:07:34 * ski isn't really comfortable with `gfoldl'
11:07:45 * Twey either.
11:08:20 <ski> i can probably figure out how to make it do what i want, if i want to, but i can't explain why it's like it is, exactly
11:09:15 <jvoorhis> i just installed the latest haskell platform on my mac, and cabal can't find the ghc-prim headers needed to install the primitive package
11:09:21 <nejucomo> -instead of "The Data class makes it possible to write functions that can walk over arbitrary types."
11:09:31 <nejucomo> No that's not quite right...
11:09:37 <jvoorhis> is there an additional package for those? help appreciated!
11:33:41 <robin_> Hello everyone
11:33:44 <adorablepuppy> hi
11:33:56 <mm_freak> ok, StateT over Iteratee sucks
11:34:03 <mm_freak> i'm going back to Iteratee over StateT
11:34:24 <robin_> Can you help me with the word-wrapping in the haskell please, i am complete beginner and I have project to do in haskell.
11:34:46 <byorgey> mm_freak: they are almost certainly not equivalent
11:34:50 <robin_> i found on the wiki about this channel
11:34:57 <adorablepuppy> Do you have some code, robin_?
11:35:09 <saml> robin_, what is word-wrapping?
11:35:20 <mm_freak> byorgey: yes, i know, and i'm trying to find out (since weeks), which is the better approach
11:35:22 <saml> you mean how to wrap haskell code in vim?
11:35:34 <mrcarrot> how can i print my random triple? this is at least not working in main: http://pastebin.com/Caibu0gS
11:35:38 <mm_freak> i used to have Iteratee over StateT, but realized that i'm running into some problems with it
11:35:48 <robin_> one second i will rewrite the info here
11:36:12 <saml> http://www.haskell.org/ghc/docs/latest/html/libraries/pretty-1.0.1.2/Text-PrettyPrint-HughesPJ.html
11:36:17 <adorablepuppy> robin_ are you trying to break text over lines or are you having issues formatting haskell code?
11:37:06 <byorgey> mrcarrot: instead of  let a = randomHeaps,  use  a <- randomHeaps
11:37:16 <mrcarrot> byorgey: okay, thanks
11:37:28 <mm_freak> byorgey: do you see a way to handle iteratee exceptions in StateT over Iteratee, without giving up the state updates, when an exception occurs?
11:37:54 <mightybyte> Anyone here know how to solve the recent unix-compat build problem on Red Hat?
11:37:55 <byorgey> mrcarrot: if a = randomHeaps then a has type  IO (Integer, Integer, Integer),  so printing a is trying to print an IO action, which does not make sense
11:38:09 <robin_> ok text= " on monday      I have sent      message,  which you      can see below.\nCan you  please    answer         on it.\nWe have      lot of work so please     answer on it\nThank you for understanding."   lineLenght = 25 ; whitespace = " \n\t\r"
11:38:13 <mm_freak> i.e. i have a StateT/Iteratee computation, which may update the state as well as throw an exception, but in my current approach, if an exception is thrown, then all state updates of the computation are lost
11:38:18 <byorgey> mrcarrot: but with  a <- randomHeaps  a has type  (Integer, Integer, Integer), so a will be a triple, which is probably what you want
11:38:43 <aristid> mm_freak: StateT (Iteratee x m) a?
11:38:52 <aristid> +s
11:38:53 <mm_freak> aristid: yes (almost)
11:39:03 <aristid> yeah i forgot one parameter
11:39:13 <adorablepuppy> robin_: Where are you trying to split the words though?
11:39:16 <robin_> the project is about to split text to words and then back to text with lineLenght 25 chars where words will be separated with space and assigned to the left.
11:39:19 <mm_freak> StateT r Config (Iteratee a m) b
11:39:23 <adorablepuppy> I don't see it in the code
11:39:25 <mm_freak> i'm using a CPS-transformed StateT
11:39:33 <mm_freak> hence the 'r' parameter
11:39:44 <nejucomo> mm_freak: You can swap which monad transformer is inner or outer to change those semantics.
11:39:55 <mm_freak> nejucomo: read above
11:40:10 <byorgey> mm_freak: no, with StateT (Iteratee ...)  iteratee exceptions causing the state to get thrown away is exactly what I would expect
11:40:34 <mm_freak> yeah, understandable…  ok, back to Iteratee over StateT
11:40:41 <adorablepuppy> robin_: I'm not comfortable doing someone's homework for them, especially when it's such a trivial task, and you haven't really shown any effort to do it yourself. Maybe someone else will help.
11:41:35 <nejucomo> robin_: Perhaps if you ask very specific questions people are more likely to be helpful.
11:42:18 <byorgey> robin_: people here are happy to help, but it works best to ask specific questions, like "I do not understand what X means, can someone explain it", or "Here is some code which is supposed to do X but I get error Y, can someone help me figure out why?"
11:43:32 <byorgey> robin_: if you have no idea how to even get started on the project you should go ask your professor/lecturer or teaching assistant for help.
11:44:17 <dahankzter> Labs are where you really learn to program at first, don't take shortcuts with them
11:44:22 <adamvh> So I'm poking around inside the source code for Data.Vector, and I'm seeing this idiom a lot:INTERNAL_CHECK(someCheck) "functionName" args
11:44:23 <robin_> Okay I understand :) maybe you can help me out because for true i see haskell for the second time in my life and you know when you study there are many different project and limited time and when someone cannot know everything right:) so i will try to figure it out and thank you for help ;) i will stay and if i see i cannot get something to work i ll ask then. Thanks
11:44:53 <adamvh> Does anyone here no what is the deal with INTERNAL_CHECK?
11:45:04 <adamvh> Is it a C preprocessor macro or something?
11:45:06 <byorgey> adamvh: maybe it is a CPP macro?
11:45:13 <adorablepuppy_> robin_: BONUS has a very nice tutorial for beginners. http://www.learnyouahaskell.com, it would most definitely help you. 
11:45:23 <adamvh> byorgey: that's my suspicion
11:45:42 <robin_> adorablepuppy_: thank you will check
11:45:43 <merijn> I was just about to recommend Learn You A Haskell as well :p
11:45:57 <adamvh> Do you know where in the source tree the c preprocessor macros would live?
11:46:18 <adorablepuppy_> robin_: It's less of a tutorial and more like a book. Because, well, it is a book.
11:47:27 <adorablepuppy_> If you like it, show your support to BONUS and buy it. It's like half off from the site right now.
11:47:59 <byorgey> adamvh: I don't know, sorry
11:49:43 <adorablepuppy_> On a side note, Notepad++ has been messing up my indentation, causing me a lot of frustration. Is there anything anyone recommends highly that isn't Vim?
11:49:58 <gigamonkey> If I have multiple instances of 'f x' in my code, are they necessarily all compiled into the same thunk so as to only be evaluated once?
11:51:09 <ion> I might have misunderstood something but i’m under the impression you should assign f x to a variable and use it to make sure.
11:51:09 <Entroacceptor> adorablepuppy_: emacs a possibility?
11:51:36 <adorablepuppy_> Do they have emacs for windows? I used to love an emacs derivative on linux.
11:51:37 <dolio> gigamonkey: No.
11:51:46 <Entroacceptor> adorablepuppy_: yes, there is
11:51:46 <adamvh> Ah - found it.  CPP macro indeed
11:51:52 <adorablepuppy_> Awesome. Thanks.
11:51:58 <dolio> gigamonkey: They are almost certainly not.
11:52:02 <gigamonkey> ion: meaning with a let or a where?
11:52:04 <adamvh> adorablepuppy_ EmacsW32
11:52:11 <gigamonkey> dolio: how about within one function?
11:52:17 <ion> For instance.
11:52:17 <dolio> No.
11:52:25 <dolio> gigamonkey: Naming something is what shares it.
11:52:25 <adamvh> adorablepuppy_: is a distribution specifically tailored for Windows
11:52:30 <dolio> 'let y = f x in ...'
11:52:36 <dolio> Then you use y.
11:52:40 <adorablepuppy_> Thanks adamvh, Entroacceptor
11:52:49 <erus_> is data parallel haskell getting updated any further?
11:53:12 <gigamonkey> dolio: though the compiler *could* do what I'm saying, right, without changing the semantics?
11:53:28 <dolio> It could. But it's not always an optimization, so it doesn't.
11:53:50 <aavogt> it'll do the other way around more often
11:53:51 <gigamonkey> I.e. that's the whole point of a pure lazy language.
11:54:18 <dolio> The only time it does that is when it sees something like: 'let e = f x in ... f x ...'
11:54:20 <gigamonkey> dolio: when is it not an optimization? (I believe you; I just lack imagination.)
11:54:30 <dolio> It may substitute e for the latter f x.
11:55:15 <dolio> gigamonkey: The standard example is: pset (x:xs) = pset xs ++ map (x:) (pset xs)
11:55:39 <dolio> Versus pulling out the 'pset xs' call into one shared value.
11:56:06 <dolio> The way I wrote it, it will run in constant space, as I recall.
11:56:20 <dolio> If you share the recursive call, it will eat memory.
11:56:32 <byorgey> yes, that looks like it will run in constant space
11:56:35 <gigamonkey> And 'let foo = pset xs in foo ++ map (x:) foo' won't?
11:57:01 <gigamonkey> Is that because the let is defeating some other optimization?
11:57:25 <ion> Another example: ‘repeat x = x:repeat x’ vs. ‘repeat x = xs where xs = x:xs’
11:57:33 <dolio> When it's not shared, the first pset xs can be garbage collected immediately after it's used.
11:58:15 <dolio> When it's shared, it gets held in memory until you finish using it in the 'map (x:) (pset xs)' part.
11:58:25 <dolio> And power sets get exponentially large.
11:59:37 <dolio> So if you're printing it out, the first one generates an element, prints it, and collects.
11:59:49 <dolio> The second one generates, prints, and holds on to it until the second half of the list.
12:00:41 <dolio> So you need enough memory to hold a list of size around 2^n.
12:00:50 <dolio> n being the size of your input list.
12:01:43 <gigamonkey> Okay, I think I get it. (Still a bit fuzzy in my head but that's okay.)
12:01:45 <gigamonkey> Thanks.
12:02:29 <mauke> I was about to ask you if you were that guy but then I had a deja vu
12:02:34 <monoidal> is (a ~ b) completely equivalent with Equal a b?
12:02:38 <mauke> like I'd already asked you before
12:03:00 <monoidal> where data Equal a b where Eq :: Equal a a
12:04:22 <dolio> monoidal: In theory, GHC translates that to 'data Equal a b where Eq :: (a ~ b) => Equal a b'.
12:04:47 <byorgey> it's not even just theory.
12:04:52 <c_wraith> Huh.  I'm looking at ghc-core output, and wondering how to figure out what assembly code corresponds to which core code
12:05:09 <frerich_> :t Data.ByteString.map
12:05:10 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
12:05:26 <dolio> byorgey: I think it has subtly different interaction with other compiler features when written that way.
12:06:05 <byorgey> dolio: that may be true.  I just meant that internally, it really does get translated into a constructor with a coercion argument.
12:06:11 <dolio> Yeah.
12:06:30 <gigamonkey> I was inspired to ask my original question when I was thinking about a comprehension in Python which I think might be translated into Haskell something like: [ f x | x <- [1..], somepredicate f x ]
12:06:55 <gigamonkey> In a case like that, I was hoping 'f x' would only be evaluated once.
12:07:10 <gigamonkey> (In Haskell. So I could make fun of the Python guys.)
12:07:25 <c_wraith> gigamonkey: in general, GHC can't make that optimization, because it's often the case that calculating f x is cheaper than keeping its result in memory
12:07:37 <dolio> [ y | x <- [1..], let y = f x, pred y ] should work
12:08:12 <gigamonkey> dolio: so the let binding in the guard is visible in whatever you call the part that produces the value?
12:08:31 <aristid> @let guardPred pred v = guard (pred v) >> return v
12:08:32 <lambdabot>  Defined.
12:08:37 <aristid> :t guardPred
12:08:38 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
12:08:45 <c_wraith> gigamonkey: in fact, there are several bug reports against GHC because it *is* doing that optimization in some places where it results in a space leak
12:08:57 <aristid> guardPred f [1..] :)
12:09:08 <aristid> wait no
12:09:20 <aristid> guardPred pred (map f [1..])
12:09:27 <rostayob> @hoogle ExpQ -> String
12:09:27 <lambdabot> Prelude show :: Show a => a -> String
12:09:27 <lambdabot> Text.Show show :: Show a => a -> String
12:09:27 <lambdabot> Language.Haskell.TH pprint :: Ppr a => a -> String
12:09:48 <rostayob> @hoogle Q Exp -> String
12:09:48 <lambdabot> Prelude show :: Show a => a -> String
12:09:48 <lambdabot> Text.Show show :: Show a => a -> String
12:09:48 <lambdabot> Language.Haskell.TH pprint :: Ppr a => a -> String
12:09:52 <rostayob> why's that?
12:13:37 <irr> test...
12:14:14 <osoleve> failed :(
12:15:14 <byorgey> rostayob: why's what?
12:22:44 <Taslem> What should I use for graphics? Any of you used them before for a recommendation?
12:23:04 <rostayob> byorgey: it's a template haskell type... I was wondering why hoogle returns that
12:23:46 <byorgey> rostayob: because it can't find anything with that specific type, so it tries to look for more general types that match your query
12:24:01 <byorgey> rostayob: I think pprint is actually what you want.
12:24:51 <byorgey> but you might have to do something like  runQ . fmap pprint
12:25:16 <byorgey> which can give you an IO String
12:25:56 <byorgey> Taslem: "graphics" is quite broad, what exactly do you want to do?
12:26:12 <ClaudiusMaximus> Taslem: what kind of graphics?  i've used cairo for 2D vector display, opengl for 3D (and 2D too), plain haskell arrays for simple bitmap/raster stuff, dirty bad wrong string stuff for svg file output...
12:26:26 <inetic> hi, I'm playing with the deepseq thingy and have noticed that if I deepseq a list of size 2*10^6 it allocates 128MB of RAM, that is 60 bytes per node, am I understanding it right? how is it justified?
12:26:45 <Taslem> I'm trying to output to the screen, not to image files. Any opinions on what's simplest/fastest/easiest?
12:28:07 <byorgey> Taslem: Cairo is nice, but fairly low-level
12:28:27 <Taslem> Is it fast?
12:29:43 <byorgey> should be, the actual cairo library is written in C, the Haskell cairo library is just bindings to it
12:30:12 <byorgey> I've never done any benchmarking but a lot of work has gone into it so I presume they've spent time optimizing it
12:30:14 <ClaudiusMaximus> cairo is not exactly fast, but the quality is good
12:30:55 <byorgey> Taslem: what sort of graphics do you want to output?
12:30:57 <ClaudiusMaximus> at least, in my experience i can easily peg a core of my machine (consumed by Xorg) by doing too much each frame in animation
12:31:11 <Taslem> I think just simple vector stuff for now.
12:31:15 <rostayob> byorgey: ah ok, thanks
12:31:48 <rostayob> byorgey: also, is there a way to get a Pat from a normal data type constructor?
12:32:01 <rostayob> I mean I wrote my own function but it seems something pretty common to do
12:32:13 <byorgey> rostayob: I don't remember, sorry, it's been a while since I've worked with TH
12:32:25 <ClaudiusMaximus> possibly i'm doing it wrong.  cairo + gtk is a lot nicer than opengl + glut, and opengl + gtk is a bit fiddly to get working (but works well when it does)
12:32:42 <rostayob> byorgey: np thanks anyway
12:33:34 <Taslem> Egh. I have no idea how to use Cabal.
12:35:39 * sm wrestles with haskell for rdbms work again
12:36:03 <byorgey> Taslem: cabal install foo
12:36:16 <byorgey> Taslem: are you getting an error?
12:36:56 <sm> I think I've learned: hdbc takes sql statement strings and doesn't convert rows to haskell types. haskelldb takes sql statement types and doesn't convert rows to haskell types either. persistent does convert rows to haskell types but doesn't work well with existing schemas. 
12:36:58 <byorgey> should be possible to 'cabal install cairo'.  Note, however, that you will have to first install the cairo development library through your OS's package manager
12:36:58 <barshirtcliff> I asked earlier about binary representation of Ints.  Now I'm back.  I have a problem, which is that I need a string, but I'm getting a ShowS.  What should I do?
12:37:50 <barshirtcliff> showIntAtBase 2 ("01"!!) 123
12:37:56 <byorgey> barshirtcliff: ShowS is a synonym for String -> String, apply it to ""
12:38:03 <byorgey> > showIntAtBase 2 ("01"!!) 123 ""
12:38:04 <lambdabot>   "1111011"
12:38:08 <barshirtcliff> okay.
12:38:29 <byorgey> > showIntAtBase 2 ("01"!!) 123 "andotherstuff"
12:38:30 <lambdabot>   "1111011andotherstuff"
12:38:33 <Taslem> "The exception was: ExitFailure 1"
12:38:34 <barshirtcliff> that did it.  thanks!
12:38:45 <ClaudiusMaximus> byorgey: and the gtk2hs build tools, which might require some other tools?  but yes, once you've got that set up "cabal install cairo" works; i just upgraded to the 0.12 versions today, and didn't have to change any code
12:39:06 <byorgey> Taslem: ah, yeah, the error messages can be a pain.  Does it give any more information? Does it say which package it was trying to install?
12:39:29 <Taslem> cabal: Error: some packages failed to install: cairo-0.12.0 failed during the configure step. The exception was: ExitFailure 1
12:39:33 <byorgey> Taslem: oh, right, cabal install gtk2hs-buildtools first
12:39:43 <byorgey> I forgot you needed that for cairo
12:39:51 <Taslem> Ah, okay.
12:40:39 <Taslem> This whole process seems more than slightly over complicated.  You'd think it would make more sense to use GHC to import libraries..
12:41:03 <ClaudiusMaximus> if it would be useful, i have a fresh minimal debian squeeze install that i need to get haskell'd up in the coming days; i could document the haskell + gtk + cairo installation process (but i suspect there are instructions somewhere already)
12:41:21 <Taslem> Same error...
12:41:22 <aavogt> sm: the records used in haskelldb for rows are not haskell types?
12:41:33 <Taslem> Actually, not quite the same.
12:41:44 <byorgey> Taslem: if you scroll up, can you find any other error messages?
12:41:47 <ClaudiusMaximus> Taslem: it's a deep issue; cabal relies on the compiler to keep track of stuff, but the compiler only tracks libraries, not executables (like other tools needed to build things)
12:41:48 <Taslem> setup.exe: The program pkg-config version >=0.9.0 is required but it could not be found. cabal: Error: some packages failed to install: cairo-0.12.0 failed during the configure step. The exception was: ExitFailure 1
12:42:11 <Taslem> Well, why couldn't you just keep all the libraries in a "lib" folder or something with the project?
12:42:18 <Taslem> Lots more portable and simpler...
12:42:38 <sm> aavogt: they are of course, but I mean rich application-specific types - eg Person {name::String, address::String} from the persons table
12:42:44 <lispy> ClaudiusMaximus: actually, we could build a tool that sits between cabal and the OS/packagemanager and solve the problem the same way we solve libraries via ghc-pkg
12:43:00 <rostayob> lispy: it's already there for archlinux
12:43:02 <byorgey> Taslem: you'll have to install pkg-config through your OS's package manager
12:43:12 <Taslem> What package manager?
12:43:17 <rostayob> lispy: cabal2arch
12:43:26 <byorgey> Taslem: what OS are you on?
12:43:32 <Taslem> Windows Vista.
12:43:33 <aavogt> sm: it isn't clear why you'd want something more restrictive like that
12:43:33 <luite_> Taslem: download the binary gtk distribution for windows, extract it somewhere, and add its bin directory to your %PATH%
12:43:57 <byorgey> Taslem: ah, so listen to luite_ not me =)
12:44:05 <luite_> Taslem: this one: http://ftp.gnome.org/pub/gnome/binaries/win32/gtk+/2.22/gtk+-bundle_2.22.1-20101227_win32.zip
12:44:33 <Taslem> Why exactly do so many sites use tar.gz rather than zip?
12:44:53 <aavogt> sm: if it was written like that you'd have lots of boilerplate to make new rows out of existing ones
12:45:02 <lispy> Taslem: install 7-zip and it won't be something you have to worry about :)
12:45:11 <parcs> Taslem: zip is non-free or something
12:45:35 <NisseP> i thought pkzip was public domain
12:46:39 <Cin> Using TemplateHaskell can I, given a string that refers to a value in scope and get the type of it?
12:46:58 <sm> aavogt: I don't get it. Are you suggesting I should work with [Record a] throughout this complex app, instead of modelling entities with more readable haskell types ?
12:47:28 <NisseP> [never mind, it wasn't. the format is though.]
12:47:47 <aavogt> @hoogle reify
12:47:47 <lambdabot> Language.Haskell.TH reify :: Name -> Q Info
12:47:47 <lambdabot> Language.Haskell.TH.Syntax reify :: Name -> Q Info
12:47:47 <lambdabot> Language.Haskell.TH.Syntax qReify :: Quasi m => Name -> m Info
12:47:56 <Cin> @i Info
12:47:56 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
12:47:56 <aavogt> @hoogle String -> Name
12:47:56 <lambdabot> Language.Haskell.TH mkName :: String -> Name
12:47:56 <lambdabot> Language.Haskell.TH.Syntax mkName :: String -> Name
12:47:56 <lambdabot> Language.Haskell.TH.Syntax mkNameL :: String -> Uniq -> Name
12:47:58 <sm> I know that converting between these two representations requires a lot of boilerplate. haskelldb provides some of that, persistent provides more. 
12:48:15 <Cin> aavogt: Hm, nice. I wonder what's in that Info data type. *Looks on Haddock*
12:48:35 <aavogt> probably Info doesn't include everything you need :(
12:49:23 <Cin> I basically just want to know ‘is this symbol a TH function, i.e. Q …’?
12:49:38 <Cin> VarI Name Type (Maybe Dec) Fixity
12:49:42 <Cin> This looks sufficient.
12:49:43 * Cin tries
12:50:09 <Taslem> Trying to install with cabal is not fun....
12:50:22 <Cin> Taslem: Why not?
12:50:39 <frerich_> @src insertBy
12:50:39 <lambdabot> insertBy _   x [] = [x]
12:50:39 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
12:50:39 <lambdabot>                                  GT -> y : insertBy cmp x ys'
12:50:39 <lambdabot>                                  _  -> x : ys
12:50:44 <Taslem> Because every time I get it to run, there's an error, and I need to download a NEW file.
12:51:10 <Cin> Taslem: BTW, you *can* put all your libraries in a lib/ directory, if you want. And then use cabal-dev to have a directory-local repository with which you develop your project.
12:51:21 <aavogt> sm: why do you like the named fields that come with haskell so much anyways? Is it the prettiness in type signatures?
12:51:53 <sm> aavogt: uh, readability and clarity of code ? isn't that why they exist ?
12:52:03 <Taslem> What is pkg-config?
12:52:11 <Cin> sm: I use template haskell with haskelldb, it's a chore without.
12:52:11 <sm> not to mention type safety ?
12:52:21 <aavogt> sm: readability and clarity isn't very concrete
12:52:37 <Cin> field "Id" "id" "id" [t|Int|]
12:52:44 <sm> Cin: would you be able to share some example code ?
12:53:40 <Taslem> What the heck is pkg-config, and why can't cabal find it?????/
12:54:07 <Cin> sm: http://hpaste.org/45437/haskelldb_th
12:54:45 <Cin> Then: field "Created" "created" "created" [t|CalendarTime|]
12:54:46 <Cin> field "StartDate" "startDate" "t_start" [t|Maybe CalendarTime|]
12:54:46 <Cin> etc.
12:54:54 <Saizan> Taslem: pkg-config is a fairly standard unix tool to query information about installed C libs
12:55:14 <Taslem> And why exactly would WIndows have a Unix tool?
12:55:15 <Saizan> Taslem: you should get it from your distro
12:55:41 <sm> Cin: thanks a lot, but isn't that equivalent to what haskelldb's dbdirect generates ? (see annotation)
12:55:48 <c_wraith> Taslem: sounds like you're attempting to install a binding to a unix C lib on windows.
12:55:59 <wardy> hi
12:56:10 <sm> ie, table and field types, but not a row type representing the entity itself
12:56:18 <Cin> λ> runQ $ reify (mkName "id")
12:56:18 <Cin> Template Haskell error: Can't do `reify' in the IO monad
12:56:21 <lispy> Taslem: have you read this? http://markshroyer.com/2010/10/gtk2hs-on-windows/
12:56:24 <Cin> Heh. Uhm, 'k.
12:57:23 * sm generated modules for all tables/fields with: DBDirect-hdbc-postgresql --identifier-style=camel-case $(DBMODULE) $(DBNAME) dbname=$(DBNAME)
12:57:26 <aavogt> Cin: http://www.haskell.org/haskellwiki/Template_Haskell#Why_does_runQ_crash_if_I_try_to_reify_something.3F
12:57:27 <Cin> sm: This is different because you have control over the field names. HDB's dbdirect assumes you are happy with having the same naming and types for your code as the database you're conecting to, which isn't the case for me.
12:57:34 <sm> aha
12:57:42 <Taslem> If I could install Cairo, which is one of the files gtk is dependant on, I wouldn't be having this problem...
12:58:50 <Cin> aavogt: Ah, perfect.
12:58:52 <Cin> λ> $(reify (mkName "id") >>= stringE . show)
12:58:52 <Cin> "VarI GHC.Base.id (ForallT [PlainTV a_1627394053] [] (AppT (AppT ArrowT (VarT a_1627394053)) (VarT a_1627394053))) Nothing (Fixity 9 InfixL)"
12:59:11 <Taslem> This is making me go insane...
12:59:17 <lispy> Taslem: did you read the link I sent you?
12:59:19 <lispy> Taslem: "The gtk2hs documentation claims you don’t need MinGW installed to build on Windows, but this isn’t strictly true from our perspective: you’ll need MinGW’s gpp in order to build Haskell’s Cairo bindings, upon which the GTK module depends."
12:59:22 <Cin> aavogt: Thanks!
12:59:55 <Taslem> This looks to me like I'm going to have to download 10 GB of dependent files before I asctually even get this running...
13:00:30 <lispy> Certainly not 10GB
13:00:30 <ezyang> 'sounds like Windows to me' 
13:00:54 <lispy> But, GTK+ is a huge pain.  What are you doing with it?
13:01:06 <lispy> Maybe you'd be better off with wx?
13:01:21 <byorgey> lispy: no, Taslem wants to draw stuff
13:01:26 <byorgey> so we suggested cairo
13:01:29 <lispy> ah
13:01:33 <lispy> Taslem: try gloss
13:01:48 <lispy> Taslem: http://hackage.haskell.org/package/gloss-1.0.0.1
13:01:57 <lispy> sorry, that was not the latest version
13:02:06 <lispy> Taslem: you actually want this link: http://hackage.haskell.org/package/gloss-1.3.1.2
13:02:21 <Taslem> SO what do I need to do with the Cabal Source package it provides?
13:02:21 <luite_> Taslem: pkg-config is included in that file I linked, that's why you need to add its bin directory to your %PATH%
13:02:43 <luite_> Taslem: (and you need to start a new command prompt after changing the %PATH% variable)
13:03:06 <robin_> in haskell script how do I save command result to variable? for instance I want to save result of: words "Hello this    is   test   sentence: " to variable words, so I can use it afterward. 
13:03:11 <lispy> gloss should just work on windows
13:03:20 <lispy> and it's all about doing 2d vector drawing/animation simply
13:03:47 <lispy> You'll need to install glut32.dll but that's just 1 download.  Get it from freeglut
13:04:09 <lispy> gloss examples at the end of this page: http://trac.ouroborus.net/gloss
13:04:28 <luite_> lispy: gtk2hs actually only takes one download, it's not nearly as bad as it used to be
13:04:41 <lispy> "Its main goal is to allow total beginners to get something working with a minimum of fuss."
13:04:44 <luite_> one manual download that is
13:04:51 <lispy> Taslem: that's from the gloss manual ^^
13:05:21 <Taslem> Okay, I see.
13:05:23 <luite_> but I suspect some linker issues with ghc 7.0.x, I have some problems with cairo, while it worked flawlessly with 6.12
13:05:33 <Taslem> I've downloaded and extracted the Gloss folder to where I want it.
13:05:35 <luite_> but other people have been able to install it just fine
13:05:44 <Taslem> What exactly do I need to do?
13:06:09 <lispy> Taslem: that wiki page gives directions for installing it.  You should be using cabal-install.
13:06:27 <lispy> This wiki page: http://trac.ouroborus.net/gloss
13:07:15 <lispy> Taslem: and you'll need the glut32.dll from freeglut: http://freeglut.sourceforge.net/index.php#download
13:07:33 <luite_> Taslem: if you use gloss you should bug lispy (I don't know anything about it), if you decide to use cairo instead and have problems installing it, feel free to bug me about it later
13:07:34 <lispy> Taslem: that dll goes in the same folder as the exe you want to run
13:08:21 <magnicida> hello!
13:08:42 <magnicida> i am trying to find, without luck, how to build an inmutable hashtable
13:09:16 <Taslem> So, if I use GHCi, should I put the DLL in the folder with the .hs files?
13:09:22 <mauke> magnicida: why do you need that?
13:09:31 <lispy> Taslem: I think so.  I haven't tried that before.
13:09:46 <luite_> magnicida: do you want to build your own? or do you just want to use one?
13:09:49 <wharrrgarbl> there's http://hackage.haskell.org/package/PerfectHash
13:09:57 <lispy> Taslem: I don't tend to use ghci for graphical things because ghci tends to have issues with GLUT/gtk/etc
13:10:06 <Taslem> Right, I can imagine.
13:10:08 <magnicida> luite_: i want to use
13:10:16 <Taslem> Can you use GHCi to compile?
13:10:24 <TomMD> magnicida: I'd use the HashMap in unordered-containers.
13:10:24 <mauke> magnicida: why do you need that?
13:10:39 <TomMD> @hoogle unordered-containers
13:10:39 <lambdabot> No results found
13:10:50 <TomMD> bad bot!
13:10:53 <lispy> Taslem: You can say -O2 when you start ghci and it will optimize stuff, but ghci is fundamentally an interpreter.  IF you wantt to compile your haskell you use ghc
13:10:56 <mauke> bad user
13:11:00 <TomMD> @hackage unordered-containers
13:11:00 <lambdabot> http://hackage.haskell.org/package/unordered-containers
13:11:03 <TomMD> Yes, I know.
13:11:08 <magnicida> mauke: I thought it would be a quite efficient solution to implement this algo: http://en.wikipedia.org/wiki/Baby-step_giant-step
13:11:12 <TomMD> But lambdabot should be mind reading, really.
13:11:24 <lispy> TomMD: write a plugin! ;)
13:11:27 <Taslem> Well, okay.  I've installed Gloss using Cabal... How do I actually use it in a Haskell project?
13:11:35 <dons> look at the examples?
13:11:42 <TomMD> Taslem: cabal unpack gloss-examples
13:11:50 <TomMD> and look at what they do, learn.
13:11:50 <dons> http://gloss.ouroborus.net/ 
13:12:13 <mauke> magnicida: why not use Data.Map?
13:12:16 <lispy> Taslem: example code here: http://code.ouroborus.net/gloss/gloss-stable/examples/
13:12:24 <dons> lispy: are you on vacation?
13:12:35 <lispy> dons: yes, but my IRC addiction is getting in the way
13:12:40 <lispy> dons: :)
13:12:42 <dons> lispy: go to the beach. turn off your computer
13:12:44 <TomMD> lispy: Go play frisbee.
13:12:58 <TomMD> Or jog Powell Butte with me - it will get me out of the house.
13:13:02 <companion_cube> lispy, go learn java, to relax your brain
13:13:03 <lispy> dons: today is actually get caught up on chores day.  My actual vacation is in SF
13:13:09 <dons> lispy: you won't feel refreshed if you stay online all vacation. TomMD ... nice idea.
13:13:11 <magnicida> mauke: becuase the table i need does not mutate, i thought i could gain some cycles by using the table
13:13:20 <lispy> dons: I fly out in the morning
13:13:23 <dons> k.
13:13:34 <magnicida> mauke: actually, not even a map is needed, an associative list would suffice because it does not mutate
13:13:45 <mauke> an "associative list" is a map
13:13:50 <lispy> dons: you're absolutely right though.  /me buggers off.
13:13:58 <magnicida> mauke: what do you mean?
13:14:09 <magnicida> I would expect a map to be a balanced binary tree :p
13:14:14 <mauke> magnicida: why?
13:15:08 <magnicida> mauke: I am stupid, I was thinking of an associative array
13:15:12 <magnicida> i mean, an array sorted by the key
13:15:43 * shachaf is still not sure why people use the term "associative array".
13:15:54 <magnicida> ok, I think I am going to use map to avoid depending on external libraries, thanks a lot mauke :)
13:16:20 <luite_> Data.Map is implemented as a binary tree indeed
13:17:38 <magnicida> luite_: that is what i expected
13:17:58 <magnicida> maybe later I will try with hash tables, but performance is not important now
13:18:22 <Taslem> Um...  The example I'm running... closes instantly.
13:18:29 <frerich_> dons: Hi there, thanks for 'Real World Haskell'! It's been quite a brain teaser for me, but it's still my nightly reading (despite the fact that my youngest son peed over it while changing diapers...).
13:18:42 <luite_> magnicida: not completely balanced though, they allow some slight imbalance to decrease the number of required updates due to balancing
13:18:45 <Taslem> Oh, I see, nevermind.
13:18:52 <Taslem> Where can I get Glut32 again?
13:19:43 <Taslem> Oh, found it.
13:21:21 <Taslem> I got the freeglut folder...  What exactly do I do with it?
13:23:35 <Taslem> Where can I get a GLUT32.DLL?
13:25:14 <Cin> You have to pay Microsoft one thousand pounds. Or alternatively, get it with MinGW.
13:25:50 <Taslem> AGH!!!!  I am TIRED OF DOWNLOADING FILES TO MAKE EVERYTHING COMPATIBLE.
13:26:45 <merijn> Taslem: Solution: switch to a posix platform :>
13:26:47 <luite_> Taslem: you only needed one file, right?
13:26:51 <ion> That’s what you get for developing in such a platform. :-P
13:26:52 <Cin> Such is the life with Windows.
13:27:27 <Taslem> It would be nice if Haskell were a bit more cross-platform. :P
13:27:44 <ion> Please define more crossplatform.
13:27:58 <Cin> Taslem: You gonna help out? :-)
13:28:10 <merijn> Haskell is cross-platform, not all the libraries are, though. Mostly because Windows sucks as a development platform :>
13:28:23 <Taslem> I would, assuming I could get any of the librariers needed to do so to RUN ON WINDOWS.
13:28:25 <c_wraith> Taslem: eh.  windows is garbage platform.  No one who writes libraries cares about it. :)
13:28:55 <Taslem> I know it's not that great, but it's sadly the only platform I have any experience with at all.
13:29:05 <luite_> actually most libraries work quite well on windows
13:29:08 <cafesofie> "i wish haskell would be a bit more cross platform" "define cross platform" "works on windows" "windows sucks, don't use it"
13:29:32 <merijn> Taslem: You are never to young (or old) to learn ;p
13:29:56 <Taslem> I know. But for one, no one else in my family knows anything about it either, and they use my computer sometimes.
13:30:07 <Cin> Taslem: The problem is more using POSIX libraries, rather than being particular to Haskell. It's arguable that Haskell should have some automated things to make this easier. The trouble is getting Windows users to contribute this support. I don't think there are many contributing Windows users in Haskell atm.
13:30:24 <luite_> Taslem: you only need glut32.dll, and the problem is that the freeglut distribution is source-only, right?
13:30:36 <Taslem> That's what it looks like.
13:30:46 <Cin> Taslem: Try this: http://www.transmissionzero.co.uk/computing/using-glut-with-mingw/
13:30:49 <luite_> ok, let my fire up my windows box and see if I can build it for you
13:32:02 <Cin> Taslem: Or: http://www.xmission.com/~nate/glut.html
13:32:23 <magnicida> btw, does anybody now how to add hoogle as chrome/chromium search engine?
13:32:29 <merijn> Taslem: On unrelated note, if your interested in learning other OSes, check out Oracle's VirtualBox. It's a free (for personal use anyway) virtual machine which runs excellently on Windows
13:32:34 <magnicida> it usually detects it but it did not for hoogle :(
13:33:34 <luite_> Taslem: getting things to run on windows is a bit annoying since you have to do more work yourself, but most things actually do work. eventually you probably want to get a properly functioning MSYS installation, so that you can compile the libraries you need
13:34:18 <fryguybob> magnicida: I have it set using http://haskell.org/hoogle/?hoogle=%s
13:34:19 <luite_> Taslem: even then, it would help to get acquainted with the "unix way" of compiling things, with autoconf, since that's what you have to use with those libraries
13:34:19 <Egbert9e9> guise, i have a pastebin of a very incorrectly written and unworking monad here: http://pastebin.com/fL6SRHX7
13:34:23 <Cin> What does SPJ use?
13:34:23 <Egbert9e9> can you comment on that?
13:34:31 <Cin> (He's the only Windows Haskell developer I know.)
13:35:57 <merijn> Egbert9e9: >>= doesn't return a Blah
13:36:10 <Taslem> The GlossExample closes as soon as I open it.
13:36:22 <fryguybob> magnicida: But I had to add it manually under chrome://settings/searchEngines
13:36:22 <luite_> Taslem: how do you open it?
13:36:22 <Egbert9e9> merijn: hmmm.. lets see
13:36:34 <Taslem> Just running the executable, is that wrong?
13:36:50 <luite_> Taslem: try running it from a command prompt, you might see an error message
13:37:07 <c_wraith> Egbert9e9: your *first* problem is that "Blah (a, b)" is very different from "Blah a b"
13:37:08 <merijn> Egbert9e9: It should probably be: "Blah (a, b) >>= f = Blah (f a, b+1)"?
13:37:19 <Egbert9e9> merijn: ah!
13:37:24 <c_wraith> merijn: that's not right at all, though
13:37:33 <Taslem> "Segmentation fault/access violation in generated code."
13:37:47 <merijn> c_wraith: Oh, right. I glossed over the top declaration >.> My bad
13:37:51 <luite_> hehe, hmm, that is an error message, but a terribly unhelpful one :)
13:38:11 <c_wraith> Egbert9e9: The last problem you'll run into, after you get all this working, is that what you're doing isn't actually a monad.
13:38:26 <Egbert9e9> c_wraith: hmmm... can you expand on the Blah (a,b) vs. Blah a b?
13:38:38 <Egbert9e9> c_wraith: O_O
13:38:42 <Egbert9e9> how come?
13:38:43 <Taslem> Tell me about it... I'm assuming it's about incorrectly accessing one of the libraries..
13:38:48 <merijn> Egbert9e9: (a, b) is one argument (an a/b tuple), a b is two arguments
13:40:09 <Egbert9e9> merijn: oooh
13:40:13 <Egbert9e9> i see that now
13:40:15 <c_wraith> Egbert9e9: It doesn't satisfy the monad laws.  That won't keep it from compiling, though.  It'll just make it not work the way people expect
13:40:21 <Taslem> You REALLY ought to just make able to put a folder called whatever it is you want to import, then stick it in with the rest of the project's .hs files, and compile with it..
13:40:30 <luite_> Taslem: I was able to build freeglut here, let me see if I can get this to work
13:40:50 <Taslem> I don't think freeglut is the issue, though I'm not sure.
13:41:52 <SoleSoul> Hello guys. Newbie here. I need a bit of help. I have this part of function: "translateLines (sourceH:sourceT) n = (toAsm (words sourceH) n) : translateLines sourceT (n+1)"  The error i get from ghc is "No instance for (Num [Char])       arising from the literal `1' " . I don't understand what it says. Can you give me a hint? thanks!
13:41:59 <frerich_> Hm neat, the gloss-styrene demo is fun
13:42:28 <luite_> Taslem: which example were you trying to run?
13:42:42 <byorgey> SoleSoul: what is the type of toAsm ?
13:42:47 <Taslem> "Tree" or something like it.
13:43:07 <byorgey> SoleSoul: and what is the type of translateLines?
13:43:27 <c_wraith> Egbert9e9: http://stackoverflow.com/questions/4765260/criticize-simple-monad This will tell you just about everything you need to know about what you're doing, how it can be implemented, and why it's not a monad.
13:43:31 <luite_> Taslem: ok, I have to install the required packages first, so I'll try in a couple of minutes
13:43:31 <byorgey> SoleSoul: the error means that there is some variable which you think is supposed to be a number, but GHC has decided it must be a String
13:44:08 <SoleSoul> byorgey: I didn't supply them. They are autodetected. I don't want to make a mistake guessing their type. I can copy a line from them to show you or I can try to determine the type anyway.
13:45:04 <byorgey> SoleSoul: Let me try to convince you that you *do* want to make mistakes guessing their types.  Because that is when the mistakes are easiest to correct =)
13:45:24 <byorgey> SoleSoul: I recommend always starting by writing down the type you think a function should have, and THEN try to implement it.
13:45:38 <byorgey> SoleSoul: it helps you organize your thoughts, and you get much better error messages too
13:45:53 <SoleSoul> byorgey: hmm, so you recommend always doing it?
13:46:00 <merijn> SoleSoul: Basically, the error means "GHC inferred one of you functions is expecting a "Num a" (i.e. number) and it got a [Char], so you probably confused something there
13:46:12 <byorgey> SoleSoul: yes.
13:46:37 <merijn> SoleSoul: I only do it for top level functions, but yes. I usually start by thinking "what type is the function I want?" before trying to write it
13:46:53 <SoleSoul> then I'll try to supply all of the types myself and then get back here?
13:47:10 <Egbert9e9> c_wraith: lol, thanks! will it also tell me what other simple silly monad i should implement instead? it's just an exercise in writing a monad.
13:47:16 <byorgey> SoleSoul: sure. probably you have switched the order of arguments somewhere or something like that.  Adding types will help you find where it is.
13:47:33 <merijn> Egbert9e9: You could implement your own version of Maybe
13:47:40 <SoleSoul> byorgey: Ok thank you all! I'll be back :)
13:47:40 <byorgey> SoleSoul: without specified types, the error may show up in some code far away from where the real problem is
13:47:43 <merijn> Egbert9e9: (or the list monad) both are relatively easy
13:47:59 <c_wraith> Egbert9e9: Nah, it's just about that one thing.  You might implement things like Maybe, Either, List, or State
13:48:19 <byorgey> SoleSoul: because if you (say) swap the order of some arguments, GHC may be happy to infer a type for you which is not the type you wanted, and you'll only have a problem when you try to use that function later
13:48:22 <Egbert9e9> merijn: that'd be cheating because i've been reading these few days the LYAH guide
13:48:52 <merijn> Egbert9e9: Do it without looking at LYAH and see if you can get it to work ;)
13:49:11 <RichardBarrell> Egbert9e9: do at least the State monad anyway just to show yourself that you're internalised it. :)
13:49:13 <byorgey> perhaps I will write a blog post ranting about that silly idea "type inference is great because you don't have to write your types"
13:49:20 <byorgey> type inference IS great, but that isn't the reason!
13:49:32 <luite_> Taslem: ok, I havve gloss-tree working here
13:49:54 <byorgey> type inference is great because if we had to write explicit type arguments to all our polymorphic functions we would be tearing our hair out.
13:49:59 <Taslem> Where did you get/place the Glut, and how?
13:49:59 <SoleSoul> byorgey and merijn: ok. I am trying to do it now. Thanks
13:50:17 <Egbert9e9> RichardBarrell, merijn, c_wraith: okay guys!
13:50:21 <Egbert9e9> thank you all!
13:50:37 <olsner> byorgey: isn't that just part of what "not writing the types" means?
13:51:06 <byorgey> olsner: I think what people usually mean by "not writing the types" is "not having to write type signatures for top-level functions"
13:51:51 <byorgey> I should have been more specific.
13:52:19 <luite_> Taslem: I compiled freeglut 2.6.0 from source, with MSYS, using gcc from the mingw distribution included with ghc 7.0.3. then I copied the installation to this mingw folder. I did cabal install gloss, but it failed because GLUT would not install, it depends on libglut32, but freeglut provides libglut. So I manually edited the GLUT.cabal file to change the dependency
13:52:38 <merijn> Most people who are new to non-sucky static typing haven't yet learned that types are a programming tool
13:53:01 <luite_> Taslem: I can give you the required freeglut binaries if you want
13:53:19 <luite_> Taslem: and give you some additional instructions on how to make it work
13:53:24 <byorgey> length Char (map Int String (show Int) ([1,2,3] :: [Int]))
13:53:47 <Taslem> I don't think so for today. I'm tired enough after trying for so long to get the thing to work.
13:53:49 <luite_> it's great that this works, I never had a properly working freeglut with ghc before :)
13:53:56 <Taslem> I might work on some java for a while..
13:53:59 <luite_> Taslem: it should only take a few minutes
13:54:10 <Taslem> Well, okay then.
13:54:17 <Taslem> What do I need to do first?
13:54:32 <luite_> first find youd where you have ghc installed
13:54:38 <luite_> find out
13:54:55 <Egbert9e9> merijn: hoogle's type search engine is enough to say types are awesome
13:54:57 <byorgey> merijn: indeed.  But if someone is learning how to ride a bike you shouldn't tell them "bikes are great because when you are going downhill you don't have to expend any energy!"
13:55:09 <byorgey> that's probably a horrible analogy.  anyway. =)
13:55:19 <Taslem> I have the Haskell Platform. Would it be in there?
13:55:20 <merijn> Egbert9e9: Very true
13:55:44 <luite_> Taslem: yes
13:55:55 <Taslem> I see GHCi, not GHC. Could it be hidden?
13:56:04 <merijn> I got tired of arguing why types are awesome, so at one point I wrote my view on it as a Hacker News comment (http://news.ycombinator.com/item?id=2322920) and I just link to that now :p 
13:56:09 <luite_> Taslem: you don't run it from the start menu
13:56:23 <Taslem> No, I went to the folder where Haskell Platform was installed.
13:57:04 <luite_> Taslem: do you see a mingw directory in there?
13:57:38 <Taslem> No, I do not have Mingw.
13:57:51 <Taslem> Search of my computer shows no GHC...  Only GHCi.
13:58:21 <luite_> Taslem: there must be a ghc.exe, you should probably not use the windows search function, but explorer, or a command prompt
13:58:53 <Taslem> I'm using Windows Explorer to search, and usually it works. How might I search with command prmpt?
13:59:15 <luite_> Taslem: the problem is that the search feature by default only searches indexed locations
13:59:35 <Taslem> I'm pretty sure I've fixed that before... But how can I use command prompt to find it?
13:59:38 <fryguybob> luite_: cabal install gloss works for me.  My HP mingw has libglut32.
14:00:13 <luite_> fryguybob: oh I just used the ghc 7.0.3 mingw
14:00:22 <fryguybob> Ah ok
14:00:32 <luite_> didn't know that glut was included
14:00:50 <luite_> fryguybob: can you run any of the examples in gloss-examples?
14:01:10 <fryguybob> Yeah all the ones I tried worked.
14:01:19 <luite_> hmm, this is annoying
14:01:21 <fryguybob> They did give an error message when closing them.
14:01:34 <luite_> yeah I had a similar issue, out of memory when closing...
14:03:26 <luite_> Taslem: it might take a little longer now, I'm installing the haskell platform to see which differences there are
14:03:40 <Taslem> How long will that take?
14:04:47 <luite_> no idea :) you should probably do something else if you don't want it to take too long :)
14:04:59 <luite_> fryguybob: the included glut does seem to be a different one
14:05:31 <Taslem> Yeah, I'm going to eat. I will be back in a while.
14:06:00 <erus_> > zipWith (\a b -> a + b) [0..10] [10..0]
14:06:01 <lambdabot>   []
14:06:16 <erus_> why you no work?
14:06:18 <luite_> > [10..0]
14:06:19 <lambdabot>   []
14:06:23 <luite_> > [10,9..0]
14:06:24 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
14:06:32 <luite_> that's why :)
14:06:56 <erus_> > zipWith (\a b -> a + b) [0..10] [10,9..0]
14:06:57 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10]
14:07:01 <erus_> :D
14:07:31 <erus_> proposal #1337 : make ranges smart enough to know when to step down
14:07:38 <ion> (\a b -> a + b) is also known as (+) ;-)
14:08:23 <Jafet> @src Num
14:08:23 <lambdabot> class  (Eq a, Show a) => Num a  where
14:08:23 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:08:23 <lambdabot>     negate, abs, signum     :: a -> a
14:08:23 <lambdabot>     fromInteger             :: Integer -> a
14:08:36 <mauke> erus_: they are
14:08:41 <Jafet> Oh wait, it uses Enum.
14:08:44 <Twey> zipWith (\a b -> a + b) [0..10] [10,9..0] is also known as ‘replicate 11 10’
14:08:50 <Twey> :þ
14:09:03 <mauke> erus_: [10 .. 0] == [] is the Right Thing™
14:09:07 <mauke> (perl agrees)
14:09:22 <Jafet> (for what that's worth)
14:09:27 <merijn> mauke: I'm pretty sure that's an argument for it being the Wrong Thing(TM)
14:09:34 <erus_> which way does python go?
14:09:42 <erus_> *ducks*
14:09:54 <mauke> merijn: well, in #perl I argue that it's right because it's how haskell does it
14:09:57 <luite_> fryguybob: did you get a glut32.dll from somewhere?
14:09:58 <Jafet> Around your vitals
14:10:07 <wardy> hey guys.. im accessing this irc channel through a web page - (tryhaskell.org) .  is there a better way to do it?
14:10:17 <erus_> wardy: http://webchat.freenode.net/
14:10:22 <luite_> wardy: yes, irc.freenode.net, #haskell
14:10:22 <mauke> merijn: (perl actually gets a lot of things right)
14:10:29 <wardy> thanks
14:10:29 <merijn> erus_: Python also returns empty list unless you provide a specific negative stepsize
14:10:30 <erus_> or a real irc client
14:10:32 <fryguybob> luite_: I'll check.
14:10:42 <erus_> what about ruby
14:10:57 <merijn> I'm to cool for Ruby :>
14:11:18 <erus_> i cant get ruby to print it :P
14:11:23 <erus_> just keeps printing [10..]
14:11:23 <luite_> fryguybob: glut32.a seems to be too small to provide the whole glut library, but I don't see the dll in the haskell platform
14:11:41 <Twey> wardy: http://www.irssi.org/
14:11:50 <Twey> http://quassel-irc.org/
14:12:31 <Jafet> glut is pretty small
14:12:57 <merijn> Glut is just a really small wrapper around OpenGL, afaik
14:13:07 <luite_> Jafet: the .a file is 84kB, my glut dll is 645kB
14:13:32 <Jafet> I don't know anything about windows, but I wouldn't be surprised if that was the whole thing
14:13:35 <erus_> merijn: ok ruby doesnt either
14:13:39 <erus_> but my point still stands
14:13:40 <fryguybob> luite_: humm, I have a couple, one came from graphviz.
14:13:45 <luite_> and my statically linked glut is 726kB
14:13:55 <kalven> 700kb for the teapot
14:13:57 <erus_> we have [10..] for infinity
14:14:19 <Jafet> That's a low-res teapot
14:14:38 <erus_> isnt the teapot procedural? 
14:15:17 <Jafet> Oh wait, kalven wasn't fully joking. glut does have a teapot.
14:15:23 <luite_> I thought the teapot would be a hardware primitive by now ;)
14:16:45 <Jafet> Only a software implementation can serve BS 6008 tea
14:16:49 <erus_> I watched a video on Data Parallel Haskell and it was great
14:18:13 <luite_> fryguybob: how big is your gloss-tree.exe by the way?
14:18:40 <fryguybob> 12mb
14:18:53 <luite_> whoah, and I thought mine was big (4.5MB)
14:19:18 <fryguybob> luite_: If I rename the glut dll's it fails to run.
14:19:29 <luite_> ooh the styrene one is fun
14:20:57 <tromp_> :t on
14:20:57 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:21:06 <tromp_> @hoogle on
14:21:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:21:06 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
14:21:06 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
14:21:27 <luite_> fryguybob: mine seems to be statically linked, if I rename libglut-0.dll, it still works
14:21:37 <erus_> has anyone here tried the pure programming language?
14:21:56 <erus_> its a dynamicaly typed functional language
14:22:01 <tromp_> @src on
14:22:01 <lambdabot> (*) `on` f = \x y -> f x * f y
14:22:38 <gwern> gaah. github is not as easy to use as is advertised
14:22:51 <erus_> gwern: why?
14:22:53 <Jafet> = liftM2 (*) f f
14:23:14 * gwern is confused by this whole branch business. I followed the help guide to add an 'upstream' branch, and it appears in my local copy, but not in my github repo, and the pull request guide assumes you have that working
14:23:16 <c_wraith> erus_: looks ok, though that syntax seems a bit odd
14:23:39 <c_wraith> gwern: that's not github, it's just git.  And anyone who claims git is easy to use is lying.
14:23:56 <MasseR> Bah humbug
14:24:00 <luite_> fryguybob: which glut32 was it using now, where did you get it?
14:24:24 <erus_> gwern: just clone a repository and make another branch. then work in your new branch
14:24:43 <erus_> making an upstream branch is the wrong way round i think
14:24:48 <wardy_> have any of you tried the CloudHaskell yet?
14:24:55 <tromp_> :t by
14:24:56 <lambdabot> Not in scope: `by'
14:25:38 <fryguybob> luite_: I'm trying to figure that out.  It is the same size as the one from graphviz, but has an older file creation date and appeared in my cabal/bin folder about a year ago :D
14:25:49 <wardy_> https://github.com/jepst/CloudHaskell
14:25:52 <thoughtpolice> gwern: 'git push github <branchname>' or you can do 'git push --all github' to push all of your branches/tags to the remote location
14:26:06 <thoughtpolice> (where 'github' is a remote ref pointing to your repository URL)
14:26:13 <luite_> fryguybob: you could diff or md5sum them :)
14:26:37 <wardy_> ...and http://www.reddit.com/r/programming/comments/gk18u/cloud_haskell_erlanglike_extensions_to_ghc_for/
14:26:41 <pmurias> how can i patter match against the three first elements of the array and capture the rest
14:26:48 <fryguybob> Humm looks like I built gloss on that same day.
14:26:54 <ion> jafet: Are you sure it’s the same function?
14:26:59 <thoughtpolice> c_wraith: i find git pretty easy to use, personally. in my day to day work i use maybe only a handful of commands, no more than any other revision control system IMO.
14:27:13 <thoughtpolice> i do think that some commands could be renamed though
14:27:32 <luite_> I'm quite happy that I can finally run opengl haskell thingies now :) (although I hadn't tried to make it work for a long time)
14:27:37 <ion> :t on (*) (+1)
14:27:38 <lambdabot> forall a. (Num a) => a -> a -> a
14:27:41 <c_wraith> thoughtpolice: I've learned to use it, but the model it uses (especially things like the staging area) are clear as mud initially.
14:27:44 <luite_> last time I tried, I failed miserably :)
14:27:47 <ion> :t liftM2 (*) (+1) (+1)
14:27:48 <lambdabot> forall a. (Num a) => a -> a
14:28:11 <thoughtpolice> (e.g. 'git checkout' vs 'git branch', where you would normally assume 'branch' switches/creates branches and checkout is something different. in reality, branch creates branches, and checkout will put your HEAD ref to point to whereever you want it, including branches, or even individual commits in the history)
14:28:59 <thoughtpolice> granted, checkout is useful for much more than switching between branches here and there, it's useful to get to 'checkout' any state in the history. so it's really a bit more than just switching branches
14:29:14 <c_wraith> thoughtpolice: I've even learned to think like it.  I recently figured out how to create remote branches from arbitrary points in the tree, just as an expansion of other ideas it uses.  But the initial learning process is a constant stream of "why did that happen?"
14:29:38 <thoughtpolice> (combined with git reflog, which is the ultimate safety net, you can check your repository in any point in time and test it.)
14:30:24 <fryguybob> luite_: Hashes match.
14:30:26 <thoughtpolice> pmurias: let (x:y:z:xs) = [1,2,3,4,5]
14:30:36 <thoughtpolice> x = 1, y = 2, 3 = z, xs = [4,5]
14:30:58 <thoughtpolice> i also have no idea why i arbitrarily wrote '3 = z' instead of 'z = 3'
14:30:59 <Jafet> curry (liftM2 (*) (f.fst) (f.snd))
14:31:09 <Jafet> Okay, I goofed up
14:31:11 <mrakan> Is there a good implementation of fast sorted binary trees available on Hackage? 
14:31:45 <Taslem> I think I've had enough of Haskell for one day.... Bye...
14:31:51 <luite_> fryguybob: great, I ahve the same file then :)
14:31:53 <luite_> aarhg
14:32:03 <luite_> I was jsut about to give him a direct url to that glut32.dll
14:32:13 <luite_> it might have just worked if he put that file in his cabal dir
14:32:23 <fryguybob> yeah
14:33:21 <erus_> :t readFile
14:33:22 <lambdabot> FilePath -> IO String
14:33:48 <SoleSoul> byorgey: It worked! I forgot somewhere down there to "show" n while concatenating it so ghc inferred it as a string instead of an integer. One problem down. I have another one which I couldn't solve yet. Can I ask you for help here also?
14:34:12 <erus_> :t lines
14:34:13 <lambdabot> String -> [String]
14:34:27 <erus_> :t init
14:34:28 <lambdabot> forall a. [a] -> [a]
14:34:40 <erus_> how do i get last element of list?
14:34:47 <sipa> :t last
14:34:48 <erus_> :t last
14:34:48 <lambdabot> forall a. [a] -> a
14:34:49 <lambdabot> forall a. [a] -> a
14:34:57 <erus_> doh!
14:35:31 <c_wraith> > last []
14:35:32 <lambdabot>   *Exception: Prelude.last: empty list
14:35:39 <mrakan> I think the AvlTree package looks great, but I'm having a hard time figuring out how a simple push of a value to the tree works.
14:35:57 <erus_> :t x <- readFile
14:35:57 <lambdabot> <no location info>: not an expression: `x <- readFile'
14:36:07 <erus_> :t x <- readFile "meh"
14:36:07 <lambdabot> <no location info>: not an expression: `x <- readFile "meh"'
14:36:29 <erus_> :t readFile
14:36:29 <lambdabot> FilePath -> IO String
14:36:59 <erus_> will x be an IO String when x <- readFile?
14:37:09 <mrakan> For instance, (push (\e -> Eq 3) 3 $ singleton 1) seems to overwrite the 1 with the 3.
14:39:20 <NisseP> erus_: [assuming you mean readFile "something"] x will be a String.
14:39:35 <erus_> words = lines dicfile     is a parse error,     let words = lines dicfile     is not
14:39:48 <NisseP> The whole expression do { x <- readFile "..."; return x } is an IO String, though.
14:39:48 <erus_> wtf haskell
14:40:22 <NisseP> also, for the parse error, is this in GHCI?
14:40:33 <erus_> NisseP: no
14:40:44 <erus_> well runghc
14:40:49 <hpc> erus_: yeah, that's how it has to be in a do block
14:41:06 <NisseP> oh right you mean in a do
14:41:32 <NisseP> well, same thing; I was going to say "ghci works as if everything's in a massive do" anyway
14:41:49 <erus_> so i need let in a do
14:42:03 <NisseP> yes
14:42:04 * thoughtpolice longs for the day when GHCi can understand the full GHC syntax, and we can write data types inside of it
14:42:42 <thoughtpolice> hbc had this like 15 years ago. i wonder what would be necessary for it to work with the GHC library...
14:43:16 <erus_> NisseP: is there a built in contains/isin function or do i have to use filter?
14:43:31 <c_wraith> :t elem
14:43:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:43:51 <Jafet> Haskell can have locally scoped data types, I think
14:44:02 <Jafet> But no one's really bothered
14:44:07 <mauke> erus_: hoogle is your friend
14:44:46 <thoughtpolice> Jafet: is that part of the standard? the only thing I know even remotely close to something like that is UHC, which actually allows local class instances for typeclasses, but I don't think any implementation nor the standard allows for scoped data types
14:44:51 <thoughtpolice> or maybe i'm just thinking wrong
14:45:09 <Jafet> I mean, adding local data types to Haskell seems theoretically possible
14:45:51 <thoughtpolice> oh, in that case I would agree. in the mean time, i would just like to be able to write 'data P n = S n | Z' or somesuch in GHCi directly. :)
14:46:09 <Jafet> The only formal model for ghci so far is that it runs everything in pretty much a do, and no one's written a language extension that lets you define data types inside expressions
14:47:35 <olsner> local data types would be pretty cool
14:47:45 <thoughtpolice> really what most people can want from what I understand is just the full haskell syntax + GHC extensions to be available to you at the repl, although local data types would be interesting.
14:47:47 <olsner> local as in "inside expressions"
14:48:29 <erus_> if i do this:     filter (checkMatch y) xs     will the first arguement of checkMatch be y or an element in xs?
14:48:39 <gwern> thoughtpolice: neither of those worked, incidentally.
14:48:48 <thoughtpolice> gwern: neither of what?
14:48:53 <thoughtpolice> oh, the git commands?
14:48:56 <gwern> yes
14:49:11 <Jafet> thoughtpolice: everybody wants them, but no one's worked out the formal semantics for them
14:49:22 <maurer_> I need to do something horribly unsafe. How can I change a Word64 into a Ptr a ?
14:49:27 <Jafet> At least, not that I'm aware of
14:49:34 <thoughtpolice> gwern: so you have a branch in your local repo and you want that branch to be viewable on github, yes? if that's the case then like I said, 'git push <remote> <branchname>' should work just fine
14:49:42 <ion> @src filter
14:49:42 <lambdabot> filter _ []     = []
14:49:42 <lambdabot> filter p (x:xs)
14:49:42 <lambdabot>     | p x       = x : filter p xs
14:49:42 <lambdabot>     | otherwise = filter p xs
14:49:52 * gwern deletes the repo and starts over
14:49:53 <thoughtpolice> Jafet: nobody has worked out a formal semantics for haskell, period, much less what GHCi accepts. :)
14:50:02 <ion> erus: | p x, where p = checkMatch y, so (checkMatch y) x
14:50:10 <thoughtpolice> i'd be willing to give up the 'implicit do-block' in GHCi if I could easily define data types etc inside GHCi for example
14:50:16 <Jafet> They have! They just haven't bothered to write it down yet!
14:50:21 <thoughtpolice> having to shift that stuff out into a file and constantly reload it is rather annoying
14:50:38 <thoughtpolice> Jafet: ah, laziness is wonderful :)
14:50:50 <thoughtpolice> they won't get to writing it until we start attempting to read it :)
14:50:50 <NisseP> maurer_: unsafeCoerce# and the Word64 constructor in GHC.Word or wherever, but you didn't hear it from me
14:51:10 <NisseP> (i think)
14:52:53 <mauke> maurer_: intPtrToPtr . fromIntegral
14:53:06 <int80_h> http://hpaste.org/45443/i_need_to_remove_some_code_fro
14:54:03 <gwern> (auuguh damn these crappy unreadable github screenshots)
14:54:21 <mauke> maurer_: wordPtrToPtr actually
14:54:39 <erus_> lol gwern are you making your own project or forking someone elses?
14:55:07 <maurer_> mauke: Thanks. This is actually one of the rare places where it's proably OK (ptrace interaction, I've extracted a pointer from a program register)
14:55:21 <gwern> erus_: forking, which is suppose to be the signature easy operation in github -_-
14:55:38 <ion> int80_h: You’ll need to pass content as a parameter to json as well and call it like ‘json page content’ after the content <- … line, i guess.,
14:55:54 <erus_> gwern: press fork and get the url for your repo
14:56:25 <ion> int80_h: Although needing IO for page content but not for page title seems very strange.
14:56:35 <erus_> gwern: then git clone <url>
14:56:42 <erus_> make your changes
14:56:47 <erus_> git add .
14:57:03 <SoleSoul> Newbie here. I need a bit of help with a ghc error I get. The error is "Couldn't match expected type `[String]'  with actual type `a0 -> [String]'" in the line "translate s = unlines (translateLines (clean (lines s)))"  Thank you! :)
14:57:19 <mauke> SoleSoul: what are the types?
14:57:30 <SoleSoul> translate :: String -> String
14:57:40 <SoleSoul> translateLines :: (Num a) => [String] -> a -> [String]
14:57:45 <SoleSoul> what else?
14:57:48 <erus_> git remote add upstream <url> first actaully
14:57:48 <mauke> SoleSoul: missing argument in call to translateLines
14:57:57 <erus_> il pm you
14:58:39 <SoleSoul> mauke: owww... Stupid me. Thank you!
14:58:44 <int80_h> ion: The thinking I had behind page title was that title's wouldn't ever be very long. But content would be arbitrarily long, and I didn't want to be keeping a whole list of arbitrarily long contents.
14:58:57 <gwern> hrm, you would think that if I navigated to the original gitit repo's pull request page, and hit the button for 'your fork', it might do something like make a pull request for my new patches, but no, it just returns me to my fork. -_-
15:00:11 <int80_h> ion: I made the change you mentioned, but still get the same error
15:00:44 <int80_h> ion: I'm passing content, as well as page
15:04:20 <ion> int80_h: The amount of content is completely unrelated to whether it’s an IO action or not.
15:07:09 <int80_h> ion: The relation I am making is that, I can either store an action to read a file, or the content of the file. I'm choosing to store the action to read the file.
15:07:26 <int80_h> ion: But that doesn't solve my do block problem
15:07:59 <Alan> what's the difference between "data" and "newtype"?
15:08:13 <companion_cube> newtype is just an alias, that disappears at compilation
15:08:25 <int80_h> ion: eventually I won't be storing an action to read a text file, it will be a gif.
15:08:28 <companion_cube> data is a real data type, and you can have union of types
15:08:39 <Alan> i thought "type" was an alias...
15:08:47 <Alan> type = newtype ?
15:08:53 <sipa> no
15:09:00 <sipa> type introduces a type alias
15:09:17 <NisseP> With `newtype N = T`, N ≠ T to the typechecker
15:09:26 <sipa> newtype introduce a new data type, which is representationally equal, but not semantically
15:09:55 <companion_cube> so you can have different typeclasses instances for N and T, e.g.
15:10:43 <Alan> oh, interesting
15:11:00 <Alan> so type is type alias, newtype is type duplicate?
15:11:08 <sipa> you could call it that way
15:11:21 <sipa> type is C's #define, newtype is C's typedef
15:11:32 <mauke> wrong
15:11:39 <mauke> type is C's typedef
15:11:46 <sipa> right
15:11:58 <sipa> newtype is rather a struct with one element
15:12:05 <mauke> that would be data
15:12:51 <NisseP> http://hpaste.org/45444/type__newtype
15:13:31 <NisseP> the difference between newtype & one-constructor data is that there's no extra layer of non-strictness
15:14:30 <NisseP> so with data D = D Int; newtype N = N Int, D _|_ /= _|_, but N _|_ == _|_
15:14:56 <NisseP> also one less pointer indirection after compiling.
15:15:34 <Alan> interesting....
15:16:33 <Alan> just noticing that "learn you a haskell" likes to use "newtype Foo = Foo { bar :: SomeType }" a lot
15:16:43 <sipa> mauke: newtype A = B c    <~>    typedef struct { c B; } A;
15:17:11 <mauke> not really
15:17:20 <sipa> not exactly of course
15:17:27 <mauke> C doesn't guarantee that A has the same representation as c
15:17:28 <Alan> am i right in guessing you can't "newtype Foo = ... | ... | ..." ?
15:17:34 <mauke> Alan: yes
15:18:00 <sipa> Alan: newtype requires that there is only one constructor, with exactly one argument
15:18:12 <NisseP> Alan: you also can't do "newtype Foo = Ctor A B C", of course (but yes to "Ctor (A, B, C)")
15:18:40 <hpc> the idea is that a newtype is a wrapper around exactly one value
15:18:49 <NisseP> yes
15:18:50 <Alan> ok, so then the question is: why?
15:18:58 <mauke> why not?
15:19:06 <hpc> Alan: for when you don't want the overhead of an entire data type
15:19:09 <parcs> with newtypes you can also derive all class instances of the inner type
15:19:11 <hpc> @src Reader
15:19:11 <lambdabot> Source not found. I feel much better now.
15:19:27 <Alan> Seems like a strange language construct
15:19:27 <hpc> it is mostly used for instances
15:19:34 <hpc> newtype Sum a = Sum a
15:19:34 <NisseP> also, you can not if you prefer, with no compile time overhead
15:19:39 <mauke> Alan: why do you think it's strange?
15:20:05 <NisseP> like how the mtl transformers are newtypes for simple things like (r ->) with extra instances
15:20:20 <hpc> mauke: it is kinda strange, having a language feature that is only unique from another from extra restrictions and an optimization
15:20:51 <mauke> it's not just optimization
15:20:56 <mauke> newtype is semantically different
15:21:09 <NisseP> the difference of strictness shows up in the Actual Language
15:21:17 <hpc> oh right
15:21:28 <mauke> do we have Identity?
15:21:34 <hpc> @src Identity
15:21:34 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
15:21:36 <mauke> > Identity ()
15:21:36 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity ()))
15:21:37 <lambdabot>    aris...
15:21:40 <TomMD> If not, we have identity crisis.
15:21:41 <mauke> good enough
15:21:50 <siplux> Why does `a = writer (1,"foo") >>= (\x -> return x)` result in a type of WriterT [Char] Data.Functor.Identity.Identity Integer unless I explicitly type it to `Writer String Integer` ?
15:21:58 <mauke> > case error "hi" of Identity _ -> "yay"
15:21:59 <lambdabot>   "yay"
15:22:01 <hpc> so Identity a has exactly the same bottoms as a
15:22:14 <Alan> I find it hard to see where it's useful, instead of just having an optimisation case for single-value single-constructor datatypes
15:22:22 <NisseP> siplux: because "type Writer w = WriterT w Identity"
15:22:29 <NisseP> (or whatever order the params go)
15:22:31 <mauke> Alan: <mauke> it's not just optimization
15:22:36 <mauke> Alan: <mauke> newtype is semantically different
15:22:38 <Alan> What is the usecase that makes it worthwhile as a language construct rather than a compiler task?
15:22:40 <TomMD> siplux: Writer is defined by WriterT and Identity, it's just a type alias.  GHCi will show aliases if they have already been explicitly used but not otherwise.
15:22:57 <hpc> @src Writer
15:22:57 <lambdabot> Source not found. There are some things that I just don't know.
15:23:09 <parcs> Alan: generalized newtype deriving
15:23:24 <siplux> TomMD: Ah - that makes sense, thank you
15:23:34 <pastorn> hpc: newtype Writer w a = Writer { runWriter (w,a) } -- (Monoid w)
15:23:36 <Alan> parcs: expand?
15:24:01 <parcs> with newtypes you can also derive all class instances of the inner type
15:27:01 <Alan> parcs: automatically?
15:27:12 <parcs> yeah
15:27:17 <parcs> and selectively
15:27:38 <parcs> which is useful when a single representation can have multiple semantic meanings
15:27:42 <parcs> see ZipList
15:27:46 <NisseP> (this is an extension, -XGeneralizedNewtypeDeriving, not H98)
15:29:21 <int80_h> http://hpaste.org/paste/45443/i_need_to_remove_some_code_fro#p45445
15:29:22 <gwern> so, it turns out that something in my firefox profile but not an extension was removing the pull request button on github entirely from display
15:29:26 <gwern> what a mystery
15:29:33 <Alan> but then where's the point in wrapping around the inner type at all?
15:29:50 <parcs> to redefine a specific class instance
15:30:16 <Alan> I see...
15:30:30 <Alan> as in "act like this other thing, but with this small change"?
15:30:38 <parcs> yep
15:31:06 <mauke> maybe you just want a different type
15:31:11 <gwern> aha, and the button reappears with my usual profile but run in -safe-mode, suggesting it's the *theme*'s fault
15:31:23 <mauke> like "this is a length, this is an area, don't confuse the two"
15:31:46 <Alan> ah, now that makes sense for that usecase
15:32:29 <mauke> also, newtype lets you create types with no values
15:32:58 <sipa> such as?
15:33:29 <mauke> newtype Void = Gaze Void
15:34:17 <sipa> right, but does that differ in any way from data Void ?
15:34:30 <mauke> yes; it's H98
15:34:49 <mauke> ('data Void' is a syntax error)
15:35:03 <gwern> or... not. with normal profile, none of the other extensions restores the button. hm.
15:35:27 <int80_h> mauke: do you have a moment to look at my hpaste?
15:35:39 <gwern> (not the plugins either)
15:36:16 <mauke> int80_h: what is that code supposed to do?
15:36:55 <mauke> int80_h: note that if you remove 'json' from the block, 'content' is not in scope
15:37:08 <gwern> phew, at least it isn't the dictionaries for the spellchecker. I would have had kittens if that were the cause
15:37:45 <int80_h> mauke: well I could paste more code to give context, hold on
15:38:53 <gwern> so, I guess it must be something in about:config. I can't think what else it could be
15:43:14 <osoleve> is it safe to skip the regexp section in RWH and go back to it when I need it?
15:43:34 <int80_h> mauke: http://hpaste.org/paste/45443/i_need_to_remove_some_code_fro#p45446
15:43:56 <hpc> osoleve: probably; parsec is perhaps the more useful one to learn
15:43:56 <mauke> what the heck
15:44:04 <osoleve> hpc: thanks
15:44:12 <mauke> int80_h: what is that code supposed to do?
15:46:47 <rostayob> Is there a way in template haskell to automatically pattern match a constructor?
15:47:12 <rostayob> like the whole thing, so that if I want to pattern match Foo x y I can just use a function
15:47:35 <rostayob> I mean, I want to pattern match but I don't care about the single values
15:47:56 <gwern> screw it. I'll just delete my FF profile.
15:47:58 <mauke> > case Identity 42 of Identity{} -> "whatever"
15:47:58 <ryant5000> has anyone gotten gtk-0.12 running on Windows 7?
15:47:59 <lambdabot>   "whatever"
15:48:51 <rostayob> mauke: that mattern matches but you don't get the thing as a single variable
15:48:59 <TomMD> rostayob: I'm really unclear on what you're asking, could you provide an example?  Right now, I feel like answering "just use the field name to access the desired field"
15:49:12 <mauke> > case Identity 42 of x@Identity{} -> x
15:49:13 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity t))
15:49:13 <lambdabot>    arisi...
15:49:18 <mauke> > case Identity 42 of x@Identity{} -> runIdentity x
15:49:19 <lambdabot>   42
15:49:37 <aristid> mauke: ?
15:49:40 <rostayob> mauke: oh right, I guess I can quasi quote that. thanks
15:49:55 <aristid> mauke: why the case?
15:50:02 <mauke> because pattern matching
15:50:22 <aristid> at least in this example just using runIdentity makes mroe sense
15:50:49 <mauke> why?
15:50:50 <int80_h> mauke: The code I am having trouble with is supposed to lift 'pageCOntent' out of it's monad, where it can then be used to create a jsonMap. The return type is a mystery to me.
15:50:53 <TomMD> aristid: The whole point was to show pattern matching and use of '@' to rostayob
15:51:19 <mauke> int80_h: when should pageContent be executed?
15:51:21 <aristid> TomMD: hmm
15:51:28 <aristid> i looked at the code in isolation :)
15:51:34 <rostayob> TomMD: well acatually what I needed is {} + @ :P
15:51:42 <rostayob> I didn't think of that
15:51:45 <int80_h> mauke: when someone clicks on a certain link on the web page.
15:51:56 <mauke> int80_h: I mean where in that code?
15:52:10 <mauke> right now it's just sitting around in the file
15:52:15 <mauke> (that doesn't work)
15:53:33 <rostayob> :t asP i (recP name [])
15:53:34 <lambdabot> Not in scope: `asP'
15:53:34 <lambdabot> Not in scope: `recP'
15:53:34 <lambdabot> Not in scope: `name'
15:53:37 <rostayob> oh right
15:53:44 <rostayob> anyway it should be asP i (recP name []) in TH...
15:53:53 <rostayob> where i and name are names
15:54:03 <int80_h> mauke: look for <div id="content"> that should be around where the link gets generated. I'm n ot sure, I was going to study the html that gets generated when I got what I have to compile. But I think I'm right.
15:54:30 <mauke> int80_h: you've lost me
15:54:40 <mauke> int80_h: ... do you know haskell?
15:59:27 <osoleve> what does </> do?
15:59:50 <Zao> osoleve: Depends on from where it is.
15:59:55 <osoleve> oh, right
16:00:02 <Zao> osoleve: In the case of FilePath, it adds a filename/directory onto a FilePath.
16:00:03 <osoleve> System.FilePath
16:00:05 <aristid> osoleve: it makes a new path with a directory seperator between them
16:00:18 <osoleve> okay, thank you
16:00:21 <aristid> > "/home" </> "./osoleve"
16:00:21 <lambdabot>   Not in scope: `</>'
16:00:26 <aristid> dang :D
16:00:38 <Zao> aristid: Eew, hardcoded unixisms in the paths.
16:01:02 <Zao> let f = some_directory </> "kittehs.jpg"
16:01:13 <aristid> Zao: well, assume those paths come from environment variables :P
16:01:41 <aristid> i also wanted to test if </> eliminates redundant .-pieces
16:02:05 <Zao> Aren't there canonicalization functions for that?
16:06:39 <aristid> Zao: maybe? haven't checked :)
16:06:40 <int80_h> mauke: I only know a little but. Yesod makes ample use of quasi-quoting and other things strange to me.
16:06:48 <int80_h> s/but/but.
16:07:00 <int80_h> agh! I mean but :)
16:07:02 <int80_h> bit!
16:07:06 <int80_h> jebus 
16:08:10 <Zao> aristid: I'd expect such a function to be impure, as it probably would need to hit the FS in some situations.
16:08:45 <Zao> In the precense of links, you cannot really assume nullification of foo/..
16:08:50 <Zao> Filesystems are tricky :D
16:09:22 <aristid> Zao: you CAN assume nullification of ./././x to x
16:09:46 <aristid> i don't even want to imagine a system where . is pointing to some other place
16:10:11 <Zao> Hehe.
16:10:29 <aristid> System.FilePath> "/a" </> "/b"
16:10:29 <aristid> "/b"
16:10:34 <aristid> that's interesting.
16:10:40 <Zao> I'd throw out any path type that would canonicalize things behind my back unless asked to.
16:10:55 <Zao> aristid: Nice.
16:24:41 <rostayob> If I have a name of a constructor in TH, the only thing I have to do is "varE name" to get it right?
16:24:58 <rostayob> because I get "invalid variable *constructor name*"
16:25:38 <rostayob> ah no, it's conE maybe
16:27:48 <rostayob> yep
16:46:54 <ChongLi> hi
16:47:05 <ChongLi> anyone here use UI.NCurses?
17:10:14 <ddarius> It's quiet... too quiet...
17:10:43 <ChongLi> yeah
17:10:55 <luite_> vewy vewy quiet
17:11:03 <shachaf> You broke the spell.
17:11:20 <ChongLi> so I guess nobody uses it? heh
17:12:14 <shachaf> ChongLi: Why do you care whether someone uses it?
17:12:24 <ChongLi> I was wondering if anyone else was able to build it
17:12:46 <ChongLi> without hand-tweaking the type signature of one of the foreign imports
17:13:36 <shachaf> So you should ask that. :-)
17:13:53 <ChongLi> I was easing my way into it :P
17:14:46 <SoleSoul> Hello. I'm quite new to haskell. I used the function getCurrentDirectory and got an IO FilePath. I want to print the path but I couldn't "show" it nor "print" it. Is this type significantly different than a String? How can I show it? Thanks!
17:14:56 <shachaf> People don't usually like saying "yes, I use X", because then they feel kind of responsible for helping you. What if it turns out they can't help you? Then they'll feel bad.
17:15:23 <shachaf> SoleSoul: FilePath = String.
17:15:28 <shachaf> @src FilePath
17:15:28 <lambdabot> type FilePath = String
17:15:30 <ChongLi> shachaf: ahh, I don't want anyone to feel bad
17:15:45 <SoleSoul> שחף?
17:15:48 <shachaf> IO String /= String.
17:15:57 <shachaf> Yep.
17:16:00 <SoleSoul> :)
17:16:04 <luite_> SoleSoul: yes it's very different. a String is just that, a list of characters. an IO FilePath = IO String is an IO action, that when executed, produces a String
17:16:13 <ChongLi> shachaf: I was hoping for the odd chance that someone here might have a lot of experience with it
17:16:21 <SoleSoul> ghc gives me that: No instance for (Show (IO FilePath))
17:16:22 <ChongLi> or c2hs for that matter
17:16:28 <shachaf> ChongLi: Probably still better off asking that question.
17:16:48 <ChongLi> shachaf: yeah, now I know
17:17:00 <shachaf> SoleSoul: IO FilePath isn't something that can be shown.
17:17:27 <SoleSoul> luite_: how do I "execute" an IO type to produce the show-able type, if this is the way to do it... ?
17:17:47 <shachaf> SoleSoul: In ghci, you can just type it.
17:17:53 <luite_> SoleSoul: you have to do something like this:  do { path <- youGettheIOFilePathHere; putStrLn path }
17:18:08 <shachaf> SoleSoul: Otherwise, you can turn it into another IO action. Eventually main gets executed.
17:18:08 <SoleSoul> ow
17:18:24 <luite_> SoleSoul: the result is a new, larger, IO action
17:18:25 <SoleSoul> then this <- is the key!
17:18:25 <shachaf> "ow"?
17:18:30 <luite_> SoleSoul: yes
17:18:38 <shachaf> "<-" is just syntax sugar to the key.
17:18:49 <shachaf> @. pl undo do { path <- youGettheIOFilePathHere; putStrLn path }
17:18:49 <lambdabot> putStrLn =<< youGettheIOFilePathHere
17:18:59 <SoleSoul> ow means I think I understand now :)
17:21:03 <luite_> SoleSoul: keep in mind that the type of that whole do { ... } thing is always IO Something. While you can do stuff with your filepath using <-  (or with >>=), you can never actually write something that converts an IO FilePath to a FilePath
17:22:09 <shachaf> @ty unsafePerformIO -- NEVER!
17:22:10 <lambdabot> forall a. IO a -> a
17:22:35 <luite_> SoleSoul: don't listen to the evil shachaf
17:23:05 <luite_> ChongLi: ncurses compiled fine here by the way, ubuntu 10.10
17:23:19 <ChongLi> luite_: hmmm, thanks
17:23:30 <luite_> with ghc 7.0.3
17:23:36 <luite_> 64 bit
17:24:00 <ChongLi> ahh, I'm on 6.10.4
17:24:05 <ChongLi> (FreeBSD)
17:24:58 <ChongLi> I got it working anyway, just had to edit the generated .hs file from c2hs
17:25:19 <shachaf> > unsafePerformIO (putStrLn "It even works in lambdabot!")
17:25:21 <lambdabot>   It even works in lambdabot!
17:25:34 <ion> hah
17:25:44 <SoleSoul> shachaf and luite_: Thank you. Now I see the difference.
17:25:53 <hpc> @undefine
17:25:56 <luite_> ghc 7 should be ok for general consumption now, but I don't know how well it works on freebsd  
17:25:58 <hpc> shachaf: try that again ;)
17:26:24 <shachaf> > putStrLn "<IO ()>"
17:26:25 <lambdabot>   <IO ()>
17:26:38 <hpc> hah, well played :D
17:27:10 <c_wraith> you forgot to put two spaces at the start
17:27:10 <ChongLi> luite_: I'm kinda lazy, waiting for haskell platform to be checked into the ports collection
17:27:40 <shachaf> c_wraith: Those are inserted by lambdabot when you print things.
17:29:51 <KirinDave> I've run into several libraries i wanted that break when compiled under the aegis of GHC7
17:29:58 <KirinDave> download being the most recent.
17:30:07 <KirinDave> A Tough Time To Start: Dave's story of learning haskell formally.
17:30:42 <josh04> I'm trying to compile wxwidgets with -split-obj
17:30:49 <josh04> bugs in ld.exe ahoy
17:44:31 <osoleve> if all i've written in Haskell so far is a basic calculator, do you think it'd be absurd for me to try writing an IRC server?
17:44:55 <ChongLi> osoleve: have you written an IRC server in an other language?
17:45:01 <osoleve> nnnnope :D
17:45:12 <c_wraith> then yes, it would be absurd.
17:45:18 <c_wraith> IRC is an absurd protocol
17:45:19 <c_wraith> :)
17:45:48 <osoleve> ...how absurd? i'm pretty hard-headed.
17:46:10 <osoleve> how about just an echo server, then? i really want a project to work on :/
17:46:18 <Zao> Try it and see?
17:46:25 <c_wraith> An echo server's a good place to start.  It can go wrong in some surprising places. :)
17:46:43 <osoleve> excellent. thanks for the advice
17:46:53 * Zao blackholes c_wraith 
17:53:19 <osoleve> okay, it was suggested to me that I try something like a sudoku solver first
17:53:28 <osoleve> i'm going to work on that, i suppose
17:59:47 <wavewave> hi. 
18:01:03 <wavewave> could anyone tell me how to set up cabal for installing share file to common /usr/share directory?
18:01:35 <wavewave> I am reading user's guide but it's quite hard to find relevant information. 
18:02:32 <wavewave> I want to copy some files from source code directory to share directory when installing.
18:02:44 <m3ga> wavewave: what os are you on?
18:02:53 <wavewave> linux and mac os
18:02:59 <wavewave> it does not have to be /usr/share.. 
18:03:01 <m3ga> which linux?
18:03:14 <wavewave> just some designated data directory
18:03:19 <wavewave> I am using debian.
18:03:24 <Saizan> wavewave: you want to use the data-files: field in your .cabal file
18:03:38 <m3ga> why no use the debian packages from debian?
18:04:14 <Saizan> wavewave: look for data-files: here http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#buildinfo
18:04:16 <wavewave> Saizan: if I specify data-files, then does it automatically install those files?
18:04:37 <Saizan> yep
18:04:47 <wavewave> m3ga: I am developing a program, but not yet at a debian-package level. 
18:05:02 <wavewave> Saizan: thank you very much :-)
18:06:03 <Saizan> np :)
18:16:13 <JoeyA> Although it's a tad crazy (and inefficient in large cases), could a (non-traversable) key/value map be implemented like this? :
18:16:14 <JoeyA> type Map k v = forall a. k -> a -> (v -> a) -> a
18:17:00 <JoeyA> It's a function such that, when given a key, a failure value, and a success function, it will return the failure value if the key is not present, or call the success function with the value if the key is present.
18:17:29 <JoeyA> Instead of: case lookup k v of {Nothing -> error "Key not found"; Just x -> x}
18:17:55 <JoeyA> err, lookup k m, where m is the map
18:17:57 <magicman> You need at least an Eq constraint on k for that to work, but yes.
18:18:02 <JoeyA> Right
18:18:30 <JoeyA> you could just do: m k (error "Key not found") id
18:19:11 <mauke> type Map k v = k -> Maybe v
18:19:18 <mauke> reified.
18:19:48 <magicman> Yeah. And (forall a. a -> (v -> a) -> a) is the Church-encoding of Maybe v.
18:20:04 <magicman> (unless I'm messing up my encodings <_<)
18:20:37 <osoleve> okay, i'm already in over my head defining the sudoku board
18:20:40 <osoleve> is this an okay start?
18:20:43 <osoleve> http://pastebin.com/mCakJuVv
18:20:47 <shachaf> JoeyA: Why is that inefficient in large cases?
18:21:11 <JoeyA> shachaf: Well, if a bunch of these are chained, it's a linear search (as opposed to logarithmic)
18:21:36 <JoeyA> Are forall a. k -> a -> (v -> a) -> a and k -> (forall a. a -> (v -> a) -> a) different?
18:21:44 <shachaf> Well, sure, but that almost counts as traversing.
18:21:48 <magicman> Actually a fun mental exercise. Redefining various "Maybe v" functions for "forall a. a -> (v -> a) -> a".
18:22:09 <mauke> it's just CPS plus predereferencing
18:22:13 <magicman> Though I guess with fromMaybe and toMaybe you'd be there. Still :p
18:22:23 <shachaf> @ty undefined :: k -> (forall a. a -> (v -> a) -> a) -- No.
18:22:24 <lambdabot> forall k a v. k -> a -> (v -> a) -> a
18:23:08 <shachaf> @ty toMaybe
18:23:09 <lambdabot> Not in scope: `toMaybe'
18:24:05 <magicman> :t \f -> f Nothing Just
18:24:05 <lambdabot> forall a a1 t. (Maybe a -> (a1 -> Maybe a1) -> t) -> t
18:24:26 <Charuru> oi
18:26:44 <osoleve> no pointers?
18:26:52 <osoleve> i feel SO over my head :)
18:27:00 <osoleve> s/over/in over/
18:29:17 <JoeyA> osoleve: That's correct, but based on my little bit of experience, you may find yourself writing a lot of repetitive code because you can't just "map over" all the boxes in a board (without writing a function to do it).
18:29:17 <shachaf> > addrOf []
18:29:19 <lambdabot>   0x6bc19b0
18:30:13 <osoleve> JoeyA: thanks
18:30:52 <copumpkin> :t addrOf
18:30:53 <lambdabot> Not in scope: `addrOf'
18:30:53 <luite_> osoleve: I'd probably just use [[Int]], or possibly an array indexed by (Int,Int)
18:31:00 <copumpkin> :t addrOf
18:31:01 <lambdabot> Not in scope: `addrOf'
18:31:13 <copumpkin> :)
18:31:37 <luite_> osoleve: you could also represent a cell by Maybe Int, where Nothing is an empty cell
18:31:48 <osoleve> luite_: oooh
18:31:54 <osoleve> good point
18:33:37 <luite_> osoleve: with [[Cell]] you can probably check rows fairly easily (or columns), and you can use Data.List.transpose to do the other
18:33:49 <luite_> with the same function
18:34:18 <osoleve> would a box be [[Cell]] and the board be [[[Cell]]]?
18:34:58 <luite_> you could do that, but then it wouldn't work like I said, but other things would be slightly easier
18:35:16 <luite_> I'd probably have a list of rows
18:35:26 <luite_> so the board would be [[Cell]]
18:36:25 <luite_> now you can check whether a combination is valid by just inspecting it row by row. and using transpose, you can check the columns. the only minor difficulty is extracting the boxes from this
18:37:35 <osoleve> okay, the gears in my head are grinding
18:37:40 <osoleve> give me a second to think this through, haha
18:37:50 <luite_> you could for example write a function that chops a length 9 list [Cell] into ([Cell], [Cell], [Cell]), three length-three lists
18:38:31 <luite_> > transpose [[1,2,3],[1,2,3],[1,2,3]]
18:38:32 <lambdabot>   [[1,1,1],[2,2,2],[3,3,3]]
18:38:39 <parcs> or just use Data.List.Split.splitEvery
18:39:17 <gio123> is there anobody who works on terminations?
18:39:19 <luite_> parcs: but that would give you a list, I personally think a 3-tuple is somewhat nicer here
18:39:33 <luite_> although you could just as well pattern match on the 3 list elements
18:39:33 <ion> gio123: I heard Arnold Schwartzenegger used to.
18:39:44 <gio123> :)
18:39:48 <gio123> heh
18:39:56 <gio123> ion: for what?
18:40:10 <shachaf> luite_: I think a Sudoku that generalizes to NxN reasonably easily is nice.
18:40:12 <parcs> i think a three-tuple and a list are equally bad in this case
18:40:51 <wavewave> Saizan: wow, I really like this cabal data-files thing. I can refer to the files by using Paths_packagename
18:41:37 <luite_> shachaf: I'd rather have used something with a fixed length for this particular example, but those things aren't as easy to work with as lists
18:43:00 <bougyman> what would you say are the worst things about haskell?
18:43:11 <osoleve> that i don't get it
18:43:15 <osoleve> :)
18:43:18 <mauke> the questions in #haskell
18:43:31 <bougyman> mauke: common, i suspect.
18:43:45 <luite_> shachaf: I wonder if it's possible to have a data structure that can only represent valid board sizes, but in a general way
18:43:48 <bougyman> i meant about the language, though.
18:44:05 <wavewave> record system?
18:44:11 <bougyman> i assume there are day-to-day haskell programmers in here, they get frustrated with something or other, no?
18:44:39 <djahandarie> Records are definitely something that are kind of ugly
18:44:50 <wavewave> sometimes I miss OOP when using a data type with many record.
18:45:01 <bougyman> i can name a lot more bad things about languages I use day to day than I can about ones I just learn from a book or from a course.
18:45:03 <djahandarie> There are solutions to the record issue, but they aren't perfect either
18:45:20 <bougyman> but I think the more important question is: what's the downside.
18:45:31 <copumpkin> bougyman: many of the standard library classes
18:45:35 <djahandarie> The downside of Haskell?
18:45:36 <wavewave> djahandarie: would you kindly introduce them to me?
18:45:44 <bougyman> djahandarie: yes.
18:45:46 <copumpkin> the record system, the (lack of a meaningful) module system
18:45:56 <djahandarie> wavewave, fclabels is a fairly common one
18:46:00 <osoleve> luite_: is this better?
18:46:02 <osoleve> http://codepad.org/gDk78nj4
18:46:18 <djahandarie> bougyman, it makes using other languages pretty depressing, if that's a downside :)
18:46:45 <bougyman> djahandarie: nice switcheroo :)
18:47:00 <copumpkin> it's not untrue
18:47:02 <ion> That really happens.
18:47:07 <bougyman> i just caught a haskell intro in 'seven programming languages in 7 weeks'
18:47:13 <copumpkin> ugh
18:47:13 <luite_> osoleve: yeah at least you can use more existing functions to do your work. but a disadvantage is of course that you can have inconsistent boards, with rows of different lengths for example
18:47:25 <djahandarie> bougyman, something more tangible is perhaps that reasoning about space usage can be hard.
18:47:32 <bougyman> but let's face it, it's a big commitment to go from trivially learning a bit of syntax and philosophy to using a language day-to-day or competently.
18:47:34 <packie36> I have a [Int] who's element length is always divisible by 4. How can I turn it into a [(Int,Int,Int,Int)]?
18:47:47 <wavewave> fclabels seems interesting. interesting word : lenses.... 
18:48:17 <djahandarie> wavewave, http://blog.ezyang.com/2010/04/inessential-guide-to-fclabels/ is useful
18:48:17 <packie36> By which I mean, take 4 from it until and pack it into a tuple and a new list until I've done it to all the ints in the list
18:48:32 <bougyman> i can't believe they didn't include a lisp in those 7 :(
18:48:35 <luite_> packie36: [1,2,3,4,5,6,7,8] -> ([1,5],[2,6],[3,7],[4,8]) ?
18:48:36 <bougyman> but it was fun to see Io.
18:48:37 <josh04> I'm trying to use -split-obj to make my program smaller. How much stuff do I need to recompile? All the way down?
18:48:48 <aavogt> > unfoldr (\x -> case x of a:b:c:d:xs -> Just ((a,b,c,d),xs); _ -> Nothing) [1..8]
18:48:49 <lambdabot>   [(1,2,3,4),(5,6,7,8)]
18:49:02 <luite_> oh oops
18:49:05 <luite_> wrong way around :)
18:49:11 <packie36> luite_: More like [1,2,3,4,5,6,7,8] -> [(1,2,3,4),(5,6,7,8)]
18:49:18 <djahandarie> bougyman, a pretty relevant downside about Haskell is that it can be tough to learn.
18:49:30 <aavogt> > unfoldr (\x -> case x of a:b:c:d:xs -> Just ((a,b,c,d),xs); _ -> Nothing) [1..10] -- you need a check for this case then?
18:49:31 <lambdabot>   [(1,2,3,4),(5,6,7,8)]
18:49:43 <bougyman> djahandarie: i guess that didn't seem hard to me.
18:49:46 <djahandarie> Each concept alone is usually pretty simple, but there is a lot of new stuff, and trying to learn a concept which relies on a bunch of other ones you don't know can lead to frustration.
18:49:46 <wavewave> in fact, it is tough to unlearn, not to learn :-)
18:49:53 <copumpkin> bougyman: you didn't look deep enough then
18:49:55 <bougyman> the syntax is pretty clear
18:50:01 <wavewave> I mean tough to unlearn imperative programming.
18:50:12 <djahandarie> bougyman, it'll get difficult.
18:50:14 <bougyman> oh, i've done FP in erlang and lisps and such
18:50:14 <luite_> I don't think you need to unlearn
18:50:19 <packie36> thanks. I'm going to go back to the books.
18:50:23 <copumpkin> bougyman: so had I, when I started :P
18:50:28 <copumpkin> still takes months to get good at
18:50:29 <djahandarie> bougyman, that'll help some.
18:50:33 <copumpkin> or even understand some things
18:50:47 <bougyman> i heard monads are where people contemplate suicide.
18:50:54 <bougyman> that's to maintain state, right?
18:50:56 <mauke> no
18:51:00 <ion> There are some things in Erlang i’ve really hoped to see in Haskell. Now it seems they’re actually becoming a reality.
18:51:01 <bougyman> no?
18:51:02 <parcs> wavewave: it's tougher to unlearn functional programming :D
18:51:11 <luite_> bougyman: not necessarily, but there are monads for maintaining state
18:51:15 <mauke> "monads" are useless
18:51:19 <wavewave> frankly, when I google haskell-related thing, we have too much theoretical information. 
18:51:25 <copumpkin> http://dl.dropbox.com/u/361503/holycrap.txt
18:51:25 <mauke> they're paper thin
18:51:26 <djahandarie> bougyman, it's because it's a concept you learn after learning a bunch of smaller and simpler things. Which no one learns.
18:51:33 <copumpkin> how many languages do you know where you get 762KB of types?
18:51:41 <mauke> copumpkin: C++
18:51:53 <djahandarie> bougyman, follow a guide like Learn You a Haskell and it'll be fairly smooth, hopefully.
18:51:53 <copumpkin> mauke: I don't think even c++ gets quite this bad :P
18:52:01 <djahandarie> @where lyah
18:52:01 <lambdabot> http://www.learnyouahaskell.com/
18:52:07 <wavewave> that's scary to people. once I got used to it, i started to know what's essential to know. 
18:52:07 <mauke> bougyman: do you grok 'flip id'?
18:52:44 <wavewave> but I think this will change since haskell popularity is rapidly growing. 
18:53:18 <JoeyA> I'm trying to implement a key/value map something like this:  type Map k v = k -> (forall a. a -> (v -> a) -> a)
18:53:37 <JoeyA> This program's code is correct, but it doesn't type check (so I added some unsafeCoerces): http://hpaste.org/45451/rank2_problem_with_churchenc
18:54:17 <dmwit> That's not a rank-2 type, by the way.
18:54:21 <JoeyA> It says (without the unsafeCoerces): Inferred type is less polymorphic than expected  Quantified type variable `a' escapes
18:54:24 <dmwit> That's a plain old H98 type.
18:54:33 <mauke> how is 'forall' H98
18:54:51 <wavewave> djahandarie: fclabels seems something I am looking for a long time. thanks! :-)
18:54:52 <copumpkin> dmwit: when he uses Map in other types it is rank 2
18:54:54 <copumpkin> insert :: (Eq k) => k -> v -> Map k v -> Map k v
18:54:56 <copumpkin> stuff like that?
18:54:59 <dmwit> Ah, well, the syntax isn't H98. But the type is.
18:55:12 <dmwit> Ah.
18:55:13 <dmwit> Yes, okay.
18:55:35 <JoeyA> But where it's used makes it rank 2, doesn't it?
18:55:36 <JoeyA> insert :: (Eq k) => k -> v -> Map k v -> Map k v
18:55:37 <djahandarie> wavewave, yw :)
18:55:42 <dmwit> Yep, you're right.
18:55:49 <dmwit> It won't be the last time I'm wrong, either. =)
18:55:57 <JoeyA> insert :: (Eq k) => k -> v -> (k -> (forall a. a -> (v -> a) -> a)) -> k -> (forall a. a -> (v -> a) -> a)
18:56:13 <copumpkin> JoeyA: when you write code like that, you kind of need to turn yourself inside-out to not piss off the typechecker
18:56:15 <JoeyA> So, by itself, k -> (forall a. a -> (v -> a) -> a) is not a rank-2 type?
18:56:24 <copumpkin> JoeyA: you can float the forall a outwards
18:57:02 <JoeyA> So I'd need to say type Map k v a ?
18:57:36 <copumpkin> nah, writing type Map k v = k -> (forall a. a -> (v -> a) -> a) is equivalent to type Map k v = forall a. k -> a -> (v -> a) -> a
18:57:53 <copumpkin> but then when you go to substitute Map k v into another type, it'll probably be rank-2
18:57:56 <copumpkin> or even impredicative!
18:58:04 <djahandarie> \o/
18:58:08 <dmwit> JoeyA: Just lift the type annotation on 'm' a bit.
18:58:15 <dmwit> JoeyA: I got it to compile with no unsafeCoerces by doing
18:58:23 <dmwit> let m :: Map Int Char; m = fromList [...]
18:59:02 <dmwit> JoeyA: Basically, the type ascription was telling the type of the RHS, but not nailing down the type of the LHS properly.
19:01:53 <dmwit> (I think GHC probably refuses to infer rank-2 types for anything, only assigning rank-2 types to things if you explicitly request them.)
19:13:33 <JoeyA> @ty forall a. a -> (forall b. b -> [b])
19:13:34 <lambdabot> parse error on input `->'
19:13:38 <JoeyA> @ty undefined :: forall a. a -> (forall b. b -> [b])
19:13:39 <lambdabot> forall a b. a -> b -> [b]
19:13:55 <dmwit> =)
19:14:09 <JoeyA> @ty undefined :: forall a. a -> forall b. b -> (forall c. c -> [c])
19:14:09 <lambdabot> forall a b c. a -> b -> c -> [c]
19:14:13 <dmwit> @ty let m :: forall a. a -> (forall b. b -> [b]); m = undefined in m
19:14:14 <lambdabot> forall a b. a -> b -> [b]
19:14:29 <dmwit> \bot probably doesn't have rank-2 types on, anyway.
19:14:52 <dmwit> Oh, wait, those aren't rank-2.
19:15:16 <dmwit> @ty let m :: (forall a. a -> a) -> (forall b. b); m = undefined in m
19:15:17 <lambdabot> forall b. (forall a. a -> a) -> b
19:15:27 <ddarius> copumpkin: Stop using Unicode and your types will take less memory.
19:15:33 <dmwit> @ty undefined :: (forall a. a -> a) -> (forall b. b)
19:15:34 <lambdabot> forall b. (forall a. a -> a) -> b
19:15:39 <copumpkin> ddarius: somehow I doubt that's the issue here :)
19:17:52 <JoeyA> http://hpaste.org/paste/45451/rank2_problem_with_churchenc#p45452
19:18:13 <JoeyA> type Map k v = k -> (forall a. a -> (v -> a) -> a) type checks, but type Map k v = (forall a. k -> a -> (v -> a) -> a) doesn't.
19:18:51 <mm_freak> great reply, if someone rants about haskellers being afraid of side effects: haskell ist das heilmittel ohne nebenwirkungen (haskell is the cure without side effects)
19:19:11 <mm_freak> just wanted to share =)
19:19:53 <ddarius> Haskell ist das Zuckerpille.
19:20:40 * ddarius doesn't know the gender of "pille."
19:20:50 <ddarius> Probably feminine.
19:21:57 * ddarius is afraid of side effects.
19:32:07 * ddarius should probably make Ashitaka to San into a duet... (don't say it)
19:44:42 <mm_freak> ddarius: feminine
19:44:46 <mm_freak> die pille
19:45:41 <ddarius> Yeah, that one is pretty easy.  Not like der/die/das Band.
19:52:07 <mauke> heh
19:52:10 <mauke> nice
20:37:25 <Dashkal> Terminology check.  What do you call a monad for which m a -> a is defined?
20:39:01 <copumpkin> copointed, if that's forall a
20:39:21 <Dashkal> "copointed".  danke
20:39:27 * Dashkal continues reading
20:44:32 <Dashkal> Ok, far less confused now.  Thanks for pointing me in the right direction.
20:44:42 <copumpkin> np :)
20:44:53 <Dashkal> "forall"  Rather important there.
20:45:10 <Dashkal> I was trying to figure out how the hell Maybe was Foldable, but I missed the (Monoid m) bit
20:45:17 <copumpkin> yep, otherwise you might call it an f-algebra
20:46:02 <Dashkal> mmm, in that case about the only Monad I can thing of that's clearly copointed would be the identity monad.
20:46:36 <NisseP> writer?
20:47:33 <Dashkal> given that Writer m requires m to be a monoid, yeah, that fits.
20:47:50 <Dashkal> also a writer you write only one thing to IS Value.
20:47:51 <ddarius> It doesn't require a to be a monoid.
20:48:01 <Dashkal> class (Monoid w, Monad m) => MonadWriter w m | m -> w where
20:48:25 <Dashkal> only the state, not the free a
20:48:44 <Dashkal> Else, how does accumulation work?
20:49:40 <NisseP> Well, ok. But the copoint (`fst . runWriter`) doesn't require w to be a monoid at least
20:51:34 <copumpkin> you only need the monoid for the point
20:51:42 <NisseP> yeah
20:51:54 <Dashkal> white true, it's not exactly useful at that point.
20:52:07 <Dashkal> while*
20:52:39 <ddarius> (m, a) is a comonad. m -> a is a monad.  Monoid m => (m, a) is a monad.  Monoid m => m -> a is a comonad.
20:53:31 <josh04> Where does cabal do all it's compiling? If my compile fails, can I resume it at least part of the way through?
20:53:46 <kmc> it puts output in dist/ by default
20:53:47 <kmc> and yes
20:53:51 <jmcarthur> it will resume automatically as long as you don't run cabal clean
20:54:10 <kmc> cabal uses ghc --make so it has the ghc dependency tracking
20:54:10 <jmcarthur> s/automatically/by default/
20:54:12 <robin_> hello anyone maybe u can help me now i have unwords (words "Testuji      test tets  aaaaaa    test") I Want to give it to Line maxLenght = 25, where should I look for this?
21:08:18 <ddarius> Exercise for Dashkal.  Find the connection between the above monads and comonads.
21:10:37 <applicative> robin_: what is your trouble about words (unwords "Testuji      test tets  aaaaaa    test") ?
21:23:47 <copumpkin> dons: where was the old uvector statistics code?
21:23:53 <copumpkin> I can't remember the package name and can't seem to find it
21:25:19 * copumpkin is confused
21:27:01 <copumpkin> aha, statistics-fusion
21:27:40 <copumpkin> wow, it's gone from hackage
21:27:47 <copumpkin> I didn't think anything could ever disappear from hackage
21:28:21 <copumpkin> maybe not
21:33:37 <lispy> copumpkin: things can be hidden from view but it requires administrative manual override from someone like dcoutts
21:33:46 <copumpkin> ah okay
21:34:25 <lispy> copumpkin: I added a crapload more functions to my freetype2 binding
21:34:32 <copumpkin> cool :)
21:34:40 <lispy> It's probably actually usable but I didn't have time to code up good test/example programs yet
21:34:40 <copumpkin> I'll check it out this weekend
21:34:53 <lispy> (or haskell specific docs either)
21:35:09 <lispy> It would be great if you could try it out and give me feedback/bug reports/etc
21:35:14 <lispy> That would make me /cheer
21:42:31 <nyingen> > iterate (*) (+3)
21:42:32 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
21:47:33 <ion> > ($ 1) <$> iterate ((*2) .) (+3)
21:47:35 <lambdabot>   [4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2621...
22:08:42 <shachaf> > ($ 1) <$> iterate (*2) (+3)
22:08:43 <lambdabot>   [4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2621...
22:15:23 <nyingen> ion: that was quite instructive
22:15:51 <ion> :t iterate
22:15:51 <lambdabot> forall a. (a -> a) -> a -> [a]
22:16:20 <nyingen> thanks for the one line lesson
22:16:25 <ion> :t (+3)
22:16:25 <lambdabot> forall a. (Num a) => a -> a
22:16:49 * hackagebot bytestring-progress 1.0.1 - A library for tracking the consumption of a lazy ByteString  http://hackage.haskell.org/package/bytestring-progress-1.0.1 (AdamWick)
22:17:13 <ion> If a in the type of iterate stands for (Num n) => n -> n, the (a -> a) must stand for Num n => (n -> n) -> (n -> n)
22:17:31 <ion> In which case the return value is of type Num n => [(n -> n)]
22:19:26 <nyingen> right
22:20:06 <nyingen> a friend and I picked that apart a few minutes ago, and we were as usual impressed with the flexibility of type-safe functional programming :)
22:20:22 <nyingen> I'm new enough to haskell that it doesn't usually occur to me to try things like that
22:29:46 <unfo-> damnit. i really need to set my hilite more accurately here... can't just have /unfo/ .. damn you unfold and unfoldr ;)
22:31:51 <ion> I’d use the regexp \<unfo([^l]|\>) (depending on the dialect) if you need other inflections in whatever language or just \<unfo\> if just the word is adequate.
22:32:19 <unfo-> prolly unfo-? is good enough for this channel :)
23:51:44 <frerich> I'm trying to get my terminology right: What do you call the 'Eq a' part of something like 'elem :: Eq a => a -> [a] -> Bool'? A constraint? A requirement? A concept?
23:52:26 <accel> how do I tell pasec: this argument is optional?
23:53:04 <Botje> frerich: typeclass constraint
23:53:24 <Botje> frerich: and all constraints together are called context
23:53:37 <Botje> so if you ever see ghc complain about reducing context, that's why
23:53:47 <frerich> Botje: Ah, that's what context means, thanks!
