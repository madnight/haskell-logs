00:03:58 <applicative> sanjoyd: maybe these two actions will distinguish readLn and getLine, etc?  http://hpaste.org/paste/45521/iomonad_annotation#p45522
00:12:09 <applicative> > [1,2,3] >> {4,5,6]
00:12:09 <lambdabot>   <no location info>: parse error on input `{'
00:12:21 <applicative> > [1,2,3] >> [4,5,6]
00:12:22 <lambdabot>   [4,5,6,4,5,6,4,5,6]
00:36:43 <dct25> Morning all
00:38:29 <adorablepuppy> I just thought of the solution for my recursion issues. I can just take x amount from the list comprehension. This will allow me to halt the current program nicely.
00:38:50 <dct25> I'm having some trouble understanding namespaces in hexpat: http://hpaste.org/45523
00:39:29 <dct25> It does unexpected things with default namespaces and with unqualified attributes
00:39:50 <dct25> Can anyone help?
00:42:18 <fligan> http://www.reddit.com/r/reddit.com/comments/gmlkm/trolls_on_freenode_reddit_irc_channel/
00:59:16 <monadic_kid> Is there a better to do cross-referencing, I'm not liking any of these options, index, string, guid, IORef/MVar/TVar. mutable cells seems the to be the best option but it nearly all of my module functions in IO
01:03:08 <dolio> Harper's students are getting asymptotic speedups from parallel processing?
01:04:08 <dolio> Has CMU developed a processor with infinitely many cores?
01:13:38 <adrake> dolio: it's generally reserved for graduate students :P
01:14:43 <dct25> monadic_kid: You could make your own class for handling cross-referencing, then only the caller need know it's using IORefs
01:16:37 <monadic_kid> dct25: how does that help to prevent an explosion of IO actions?
01:20:38 <roconnor> monadic_kid: what do you mean by cross-referencing?
01:21:22 <monadic_kid> roconnor: multiple data-structures that reference elements between them
01:22:09 <roconnor> with lazy data structures you can build (immutable) data with an arbitrary network of "links"
01:23:33 <monadic_kid> when i say data structures i mean containers
01:24:32 <roconnor> containers are a kind of data structure, often lazy
01:24:36 <Phyx-> what's the size of a FunPtr? is it just 4 bytes on 32bit platforms or?
01:26:02 <shachaf> Phyx-: Perhaps sizeOf will tell you?
01:26:19 <monadic_kid> roconnor: I know this but can you be a bit less vague about the "links", it sounds like you're talking about zippers
01:27:24 <roconnor> well they are really substructures, but I didn't want to make you think of substructures as being well-founded.  Take cycle as a simple example
01:27:26 <roconnor> @src cycle
01:27:27 <lambdabot> cycle [] = undefined
01:27:27 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
01:29:26 <roconnor> internally a list is stored a a linked list
01:29:39 <roconnor> so this sort of "link" is what I'm refering to
01:31:12 <roconnor> more generally you can build infinite recursive structures where as you go deeper inside them you end up traversing parts you already have been to, and this is all done in constant space
01:31:29 <shachaf> roconnor: "internally"?
01:32:41 <monadic_kid> I have a masters & instance lists and there is a mapping from instance -> masters (at the moment IORef to masters), ideally i want amortized constant time look-up and i need to maintain a priority queue of instances
01:33:01 <roconnor> shachaf: how GHC store the data structure
01:33:32 <RayNbow> @src []
01:33:32 <lambdabot> data [] a = [] | a : [a]
01:33:36 <roconnor> here is a more complicated example than cycle: http://twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell
01:33:37 <shachaf> roconnor: I meant that externally it behaves like a linked list too.
01:34:03 <roconnor> shachaf: you can't compare "pointers" in Haskell
01:34:14 <monadic_kid> this where things get ugly because most containers that use predicates to order elements use pure functions to compare, then you  need to use unsafePerformIO to be able to compare IORefs
01:35:27 <roconnor> why not use a map or a function or an association list?
01:35:38 <roconnor> why bring IO into this at all?
01:36:36 * roconnor didn't realize Twan wrote that KMP implementation
01:36:42 <roconnor> Twan is a genius!
01:37:15 <pastorn> monadic_kid: you can use syntactic overloading :)
01:37:55 <pastorn> it allows you do to "if liftM2 (==) (readIORef var0) (readIORef var1) then bla else blu"
01:39:08 <monadic_kid> pastorn: I know how to lift, I meant you need to implement Ord/Eq with some containers that accept a custom predicate and even then you still to use unsafePerformIO
01:39:29 <monadic_kid> *still have to use unsfafePerformIO
01:39:54 <monadic_kid> *that don't accept custom predicates
01:39:59 <pastorn> monadic_kid: it's not the liftM that's the point here...
01:43:12 <roconnor> monadic_kid: I don't quite know what you are doing here, but I think using IORef is a mistake
01:43:51 <dct25> monadic_kid: What I meant was roughly http://hpaste.org/45524
01:44:05 <dct25> But it sounds like you might not need IORefs at all
01:44:42 <pastorn> monadic_kid: http://blog.n-sch.de/2010/11/27/rebindable-if-then-else-expressions/
01:47:14 <monadic_kid> xchat decided to die on me...
01:51:54 <monadic_kid> roconnor: I don't want bring IO into this, that is what i was originally asking. I have multiple containers/elements which need to cross-reference but elements can "mutate" over time so "modifying" an element as an immutable structure means I will not see the changes in the other structures if I just store the same element in multiple containers I will need to update them all
01:52:17 <dct25> monadic_kid: What I meant was roughly http://hpaste.org/45524
01:52:41 <dct25> But it sounds like you might not need IORefs at all
01:53:17 <Berengal> monadic_kid: Take a look at zippers
01:53:24 <roconnor> monadic_kid: In the past I've used functional references (aka lenses) to, well, refer to things, although I never pushed that project far enough to really test that it worked well.
01:54:10 <Berengal> Although I don't know how zippers work on self-referencing structures...
01:54:26 <monadic_kid> also if I use Data.Map then I need to figure what type of key I will use, strings, index, guids? all of them are not ideal to me
01:54:59 <roconnor> monadic_kid: I had a large "game state" structure at as the root of a heirarchy of object, and subobjects, etc.
01:55:23 <roconnor> monadic_kid: if you use a lens, it will abstract away from the type of key you use
01:55:24 <monadic_kid> roconnor: I don't have a problem with that
01:56:27 <monadic_kid> i thinking I'm leaning towards mappings with guids
01:56:49 <roconnor> like I say, a lens abstracts such implementation details
01:57:11 <roconnor> although at the cost of not being able to compare references for equality
01:57:30 <monadic_kid> i do need to use them in a priority queue
01:58:44 * monadic_kid will brb
01:58:56 <Phyx-> I should ditch this tuple...
01:59:05 <Phyx-> it's already a 4-tuple
01:59:32 <roconnor> yes
02:00:58 <dct25> monadic_kid: One of the biggest leaps for me from OO to functional programming was that objects automatically have identity (i.e. you can compare reference equality) whereas you have to explicitly build it in if you want it for values in a functional language
02:01:48 <shachaf> dct25: That's equality, not identity.
02:02:37 <roconnor> dct25: right, one can't compare references themselves for equality but if you add identities to the values they point to, then you can compare that.
02:02:52 <roconnor> (by references I mean functional references, aka lenses)
02:05:23 <dct25> shachaf: No, I mean identity. You can have two equal objects (by overriding .Equals()) which have distinct identities, and in particular you might be able to mutate one so that they cease to be equal
02:11:43 <monadic_kid> okay i will explain in more detail what i'm doing 
02:11:46 <roconnor> :)
02:13:10 <monadic_kid> I'm just refactoring my game which also complete but become a bit of mess, I wanted to refactor the game objects in a way similar to a component based system and keep the different aspects seperate. At the moment I'm re-doing the rendering system where I have a renderer module, a data structure which has a container of renderables, a container of renderable "instances" of those renderables. The render instances need to be able to refer ther
02:13:10 <monadic_kid> e masters. I also need to maintain a priority queue of renderable instances for draw order. A game object will also need to refer to it's rendeable instance (if it needs one)
02:13:20 <monadic_kid> *my game which is almost complete
02:14:44 * roconnor doesn't see anything mutable here
02:14:47 <monadic_kid> renderable instances will mutate over time, I will also need to support removal of both masters & instances
02:15:08 <monadic_kid> so index based referencing wont cut it
02:15:08 <roconnor> do they mutate while being rendered?
02:15:36 <monadic_kid> they shouldn't
02:15:52 <pastorn> monadic_kid: do you really need to keep render order? can't you just have a sorted list from lowest z-value to highest?
02:16:01 <pastorn> or vice versa
02:16:11 <pastorn> then just bubble sort it after mutation
02:16:30 <pastorn> (if it's a mutable array, which i think it should be...)
02:16:32 <roconnor> I'd keep the game state as an immutable object, and create new game state everytime something changes.
02:19:22 <pastorn> monadic_kid: and why does the renderable need to refer to their masters?
02:23:51 <monadic_kid> pastorn: I do need a z-ordering unless I'm really careful about the order in which renderable (instances) gets inserted and I need to be able to insert/delete over the duration of the game (because of text rendering unless I pre-create all the text surfaces). I was already thinking about that just re-sorting a list. Yes I'm already using mutatable arrays from vector package, vector-algorithm supports heap operations. There needs to be a map
02:23:51 <monadic_kid> ping from instances to masters because I'm storing all the instances in a priority queue which will get iterated over for rendering
02:24:40 <monadic_kid> roconnor: technically my game already does this as I'm using monad transformers, i'm not going to change that aspect of it so much
02:24:47 <roconnor> :)
02:25:06 <roconnor> no need for IO then
02:25:33 <pastorn> monadic_kid: i'm just suggesting you use list/array which is sorted by Z value
02:25:45 <pastorn> then when mutation happends you bubble sort over it
02:26:18 <monadic_kid> well I only need to sort on insertion/deletion, I don't think z-order will dynamically change
02:26:26 <pastorn> oh, ok
02:26:31 <monadic_kid> it hasn't at the moment
02:26:37 <pastorn> hehe
02:26:55 <pastorn> monadic_kid: what kind of game is it?
02:30:03 <monadic_kid> it's clone of space invaders, i'd tried to stick every aspect of the original in there, breakable walls, enemy and player bullets colliding,  start up intro. I has sound and music already. It's pretty much done except I need to tie something togethers but I want re-factor first before I do that
02:30:42 <monadic_kid> I'll do another game after this
02:30:48 <pastorn> monadic_kid: have you played any of the space invader games for the DS?
02:30:58 <monadic_kid> never had a DS
02:31:11 <Phyx-> i've had all gameboys
02:31:22 <pastorn> monadic_kid: http://www.youtube.com/watch?v=ESnxkKbRkIA
02:31:26 <Phyx-> except the 3ds, which I think is a waste of money
02:31:44 <Phyx-> lemme rephrase, I've had one of every generation of gameboys
02:31:48 <pastorn> Phyx-: have you actually played it?
02:32:05 <pastorn> Phyx-: even Virtual Boy?
02:32:27 <Phyx-> pastorn: yes, and the 3d thing is overrated. the games are kinda dull, and the battery live is an abomination
02:32:42 <Phyx-> pastorn: lol, i'm not that old.. I've started at the fat gameboy
02:33:17 <pastorn> Phyx-: virtual boy is newer than the first gameboy
02:33:27 <Phyx-> I can play my ds lite for an entire trancontinental flight, 9-10 hours, the 3ds would die 3 hours into it
02:33:48 <Phyx-> pastorn: it is? o.O
02:33:52 <monadic_kid> pastorn: my game is no where near as sophisticated as that lol, It's really tempted to add those elements but i really want to move on to something new
02:33:55 <pastorn> Phyx-: gameboy 1989, virtualboy 1995
02:34:01 <Phyx-> hmmm 
02:34:13 <Phyx-> well no, guess i can't make my claim anymore
02:34:37 <navaati> hello
02:34:45 <pastorn> Phyx-: you're right about the battery time, but not about the 3d
02:34:50 <pastorn> navaati: heyo
02:35:37 <Phyx-> pastorn: the 3d might be cool, if they actually get some decent games for it
02:35:43 <Phyx-> that are not gimmicky
02:35:59 <Phyx-> eventually games game out that used the mic, and touchscreen of the ds in fun ways too
02:36:06 <navaati> I've got an error "The class method `getSize' mentions none of the type variables of the class Value v When checking the class method: getSize :: Int In the class declaration for `Value'", is this really mandatory ?
02:36:41 <pastorn> navaati: could you paste the class definition?
02:36:45 <pastorn> @where paste
02:36:45 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
02:36:48 <mauke> navaati: getSize :: Int? so how does it know which getSize you mean?
02:37:13 <navaati> mauke: oh... yeah...
02:38:41 <navaati> http://hpaste.org/45526/class_value
02:39:06 <pastorn> navaati: right... it can't choose an instance unless a 'v' is provided
02:39:28 <pastorn> i tried to do a component based class with 'help :: [String]' like that... obvious but stupid :/
02:39:49 * pastorn wants names for typeclass instances
02:40:17 <navaati> then how can I do... v -> Int with const ? ugly as hell
02:41:43 <pastorn> navaati: indeed
02:42:11 <pastorn> navaati: how many instances of Value do you have?
02:42:22 <navaati> a lot
02:43:03 <pastorn> navaati: well, :: v -> Int; is probably the only way to go here
02:45:50 <navaati> hum… it could be a good thing after all, if one day i need dynamically sized values…
02:46:53 <pastorn> navaati: you could do something like zeroAndSize :: (v,Int)
02:46:57 <pastorn> if that's useful
02:47:17 <pastorn> for any null/zero/identity elements of your Value type
02:47:19 <pastorn> s
02:48:48 <navaati> i don't have this kind of values : values will be actually typed containers for hardware addresses (the hardware is a µC)
02:50:11 <pastorn> navaati: why the typeclass? why not just constructors for each port?
02:50:47 <navaati> uh ? what do you call a port ?
02:51:19 <pastorn> data Port = IO_CTRL | IO_DATA | LOL_CTRL | LOL_DATA etc. etc.
02:52:21 <monadic_kid> pastorn,roconnor: ah so what did you guys think i should do?
02:52:46 <pastorn> monadic_kid: not dissapear on 1 hour breaks?
02:52:51 <navaati> hum, no, types will be more like "PicWord8", "AVRInt32"
02:52:53 <pastorn> :p
02:53:02 <roconnor> monadic_kid: I don't see where you need references at all :)
02:53:24 <pastorn> monadic_kid: what roconnor said... try keeping it as a pure structure if you can
02:54:41 <pastorn> (which shouldn't be too hard for space invaders)
02:54:46 <navaati> pastorn: arg, the getSize :: v -> Int doesn't work, since i need getSize in a function "newAddress :: Value v => ProgramMonad v", so i don't have any value at this time ><
02:55:10 <mauke> you don't need a value
02:55:35 <mauke> undefined is sufficient
02:55:42 <pastorn> navaati: exactly
02:55:49 <pastorn> undefAndSize :: (v,Int)
02:58:07 <navaati> undefined as a type annotation, yes, thanks !
03:02:08 <pastorn> When are the first notions of lambda calculus from?
03:02:21 <Botje> church's thesis, probably
03:02:52 <pastorn> i'm reading some stuff about learning mathematics and it mentions "computational process" and "well defined method of getting from one system to another", dated 1971
03:03:12 <monadic_kid> roconnor: ah i think I may cause some confusing with the word instance, "renderable instance" is actually another data structure
03:03:47 <monadic_kid> roconnor: it's a record of instance info, positional, z-order,  visibility, etc
03:03:59 <roconnor> monadic_kid: and this structure that referens via an IORef to the master currently?
03:04:59 <rostayob> what do I do if I simply want a lock? I can use a MVar but I don't really need to put anything in it, Is there some more specific data type if I need a lock?
03:05:28 <mauke> I'd use a MVar ()
03:05:34 <pastorn> rostayob: QSem
03:05:36 <monadic_kid> roconnor: yep
03:05:54 <rostayob> mauke: and what I put in it? undefined?
03:06:09 <monadic_kid> rostayob: () is it's value
03:06:10 <mauke> ()
03:06:17 <pastorn> rostayob: () in an MVar, 1 in a QSem
03:06:18 <rostayob> oh right :P
03:06:47 <rostayob> mauke: oh that seems reasonable, thanks
03:06:50 <rostayob> also, one thing
03:07:13 <pastorn> why are people hating on QSem?
03:07:27 <mauke> too many numbers
03:07:31 <rostayob> I basically have to take and put values, takeMVar is not atomic right? Should I use TMVars?
03:07:44 <mauke> takeMVar is atomic
03:07:47 <rostayob> well not take and put values, I hae to take and put on the MVar
03:07:51 <roconnor> monadic_kid: why is it an IOref to the master instead of mater being as subfield?
03:08:40 <rostayob> mauke: ok... I remembered someone who had a deadlock that had to do with taking MVars
03:08:51 <rostayob> so STM is just to execute more than one action atomically
03:09:05 <mauke> in some sense, yes
03:09:07 <pastorn> roconnor: i'd use 'withMVar lock $ \_ -> do { what; ever; i; need; here; return }
03:09:20 <pastorn> *return ()
03:10:14 <Saizan> ?type withMVar
03:10:15 <lambdabot> Not in scope: `withMVar'
03:10:24 <Saizan> ?type Control.Concurrent.withMVar
03:10:25 <lambdabot> forall a b. GHC.MVar.MVar a -> (a -> IO b) -> IO b
03:10:30 <pastorn> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html
03:10:43 <Saizan> so you don't have to return ()
03:10:58 <monadic_kid> roconnor: one reason is that I've stuck the instance list as field of the master, thinking about it I could just keep the master a subfield as the master will not change only the instance list will be added/removed to. I will need to support deleting a master and removing all it's instances
03:12:32 <roconnor> monadic_kid: why do you need to delete a master?  Once all instances holding a master are deleted, the master will garbage collected
03:13:01 <pastorn> @src withMVar
03:13:01 <lambdabot> Source not found. My mind is going. I can feel it.
03:13:07 <rostayob> pastorn: that message was probably for me, I think I'll do that
03:14:08 <monadic_kid> roconnor: I have a list/array of masters, there needs to be a way to be able to refer to those as well when you want to add a new instance, "Hey I want to make a new instance of this master". The module will be dishing out "handles"
03:15:25 <roconnor> monadic_kid: why are masters not types?
03:15:32 <monadic_kid> roconnor: there is
03:15:44 <monadic_kid> roconnor: Renderable Record and Renderable Instance record
03:15:52 <drbean> @src swap
03:15:52 <lambdabot> Source not found. There are some things that I just don't know.
03:15:54 <pastorn> monadic_kid: could you condense your code into some semi-haskellish stuff so when can get an oversight?
03:15:58 <roconnor> what is the purpose of this master datatype?
03:16:58 <monadic_kid> roconnor: he hold surface, optional sprite sheet mapping, and list of instance, the instance list doesn't have to go there I just put there to make it cheap to delete a master and all it's instances
03:17:10 <monadic_kid> he holds?
03:17:11 <monadic_kid> lol
03:17:41 <roconnor> monadic_kid: how are the masters created?
03:18:50 <monadic_kid> roconnor: you give it a surface & optionally a sprite sheet map, adds to list and it gives back a "handle" to be able to refer to them when you want instance a master
03:18:59 <kevinqcs> hi, I have a question of using Network.Curl. I can use curlGetString to get the response of HTTP GET, but how can I get the response data of HTTP POST? curlPost just returns  IO ().
03:19:42 <roconnor> monadic_kid: when do you create and delete masters?
03:19:52 <monadic_kid> roconnor,pastorn: I can post what I've done so far, I've written as self-contained module which isn't part of game refactor yet, just playing with ideas
03:20:03 <Saizan> kevinqcs: i think you've to set a callback through the list of options
03:20:19 <pastorn> monadic_kid: type signatures for createMaster and createChild/createSlave would be nice
03:20:28 <roconnor> monadic_kid: sure, but this Q&A is also helpful for me to try and understand how and why you've structured your code your way.
03:20:42 <roconnor> monadic_kid: it feels very OO :D
03:20:51 <pastorn> monadic_kid: not the actual types, but just signatures so we can understand the idea of your design
03:21:31 <pastorn> roconnor: i've noticed that when doing games i tend to gravitate towards oo designs, even though i'm not very keen on oo to begin with
03:21:43 <monadic_kid> roconnor: I don't find it particularly OO, instancing isn't a concept the belongs to OO only
03:21:47 <roconnor> pastorn: I think it has been hammered into our heads :(
03:21:49 <Saizan> kevinqcs: nevermind that, i don't know
03:22:02 <kevinqcs> Saizan: OK. I will check that. 
03:22:06 <monadic_kid> roconnor,pastorn: I'll post some types & signatures
03:22:07 <pastorn> roconnor: heh, actually i learned haskell way before any OO
03:23:11 <kevinqcs> Saizan: I think your method could work, but I suspect there's a better way, like curlGetString
03:23:22 <pastorn> roconnor: i played in QBasic when i was 14 (without a mentor or study material, didn't get far beyound the SOUND function) for about a week, that's all programming i ever did before i was 23 when i got to learn haskell as part of the uni coricculum
03:23:52 <roconnor> It kinda feels like these masters ought to simply be named constants in your program.
03:28:19 <monadic_kid> roconnor,pastorn: http://hpaste.org/45530/renderer
03:28:46 <tomh-> hmm after a getChar are you supposed to hit enter to continue or?
03:29:13 <aristid> pastorn: you didn't do any programming before taking up CS?
03:29:56 <monadic_kid> aristid: I didn't, I started uni a bit late as well
03:30:02 <monadic_kid> aristid: unfortunately
03:31:03 <monadic_kid> I never even heard of let alone knew what programming was when I was younger
03:31:16 <aristid> poor kids :P
03:31:36 <aristid> they say basic pollutes your mind, but i say it's better than no programming at all :P
03:31:52 <Berengal> monadic_kid: Ditto, except when I learned it when I got at uni, it turned out I had been programming in the small for at least ten years
03:31:52 <monadic_kid> I envy the people who around my age and had parents who knew something and gave them computers and basic book
03:32:14 <tomh-> my first programming language was php :<
03:32:25 <monadic_kid> mine was pascal
03:32:29 <Berengal> Mine was batch
03:32:53 <roconnor> monadic_kid: when do you create and delete masters?
03:35:41 <monadic_kid> roconnor: I haven't got that far yet but creation will happen on game start-up and level change, this has to be in an IO action because of the way surfaces are created. They will also be created every time an text surface gets created a that moment that happen most through the duration of the game. Master deletion at the moment will only happens for bits of texts
03:36:38 <monadic_kid> roconnor: deletion because I need to add/delete new surfaces when I'm doing scrolling text or text that pops up for a short period of time
03:36:42 <aristid> monadic_kid: i didn't have parents who gave me books. but i had the internet.
03:37:54 <monadic_kid> aristid: I didn't have my own PC until 1999, I had spectrum very late in it's life time but my was second hand and had no basic book
03:38:49 <pastorn> aristid: no, but i noticed that i was reading slashdot *every day*, so it seemed like the right choice
03:39:15 <pastorn> aristid: i had a lot of friends who were hackers, but none of them were very keen of mentoring me :/
03:39:19 <aristid> pastorn: given that you seem to like haskell, it may have even been the right choice :)
03:40:46 <monadic_kid> I've learnt/looked into lots of languages over the years, Pascal, vb, c/c++, Scheme, Common lisp, SML, Ocaml, F#, Haskell, a bit of Prolog, Nermele, C# probably others I can't even remember now
03:40:47 <pastorn> aristid: well, you would think one of them could have told me to buy sicp or something
03:40:48 <roconnor> heh, this seems all very convoluted.
03:41:01 <aristid> pastorn: i bet they used PHP :P
03:41:07 <pastorn> aristid: nah, c++
03:41:27 <aristid> oh, that's what i used most of the time, before i came upon haskell :D
03:41:43 <pastorn> and they all used freebsd, told me to start using it, but never helped out when i was stuck in a terminal with no internet connection
03:41:47 <monadic_kid> learning C++ well takes a 10 years
03:41:56 <monadic_kid> even then
03:41:57 <pastorn> (and without X or anything fancy)
03:42:04 <mauke> monadic_kid: that seems optimistic
03:42:07 <aristid> so i was thinking about a strongly typed data interchange format, like JSON is for dynamic typing
03:42:38 <pastorn> monadic_kid: feels like RenderableHandle should hold a Unique, not an Int
03:42:50 <roconnor> if surfaces need to be created and delated, then their lifetimes ought to be managed by a bracket operation.
03:43:02 <aristid> with GADTs as the base, and a few (only a few) primitive types
03:43:06 <pastorn> monadic_kid: you've seen Data.Unique?
03:43:07 <roconnor> otherwise you are asking for memory leaks and "null pointer deferencing"
03:43:43 <monadic_kid> pastorn: just looking at it now, I was looking for something like this
03:44:01 <roconnor> but since I've never done Haskell SDL programming maybe I'm not in a good position to comment
03:44:21 <monadic_kid> roconnor: Surface is a foreign ptr
03:44:43 <pastorn> roconnor: it's not that difficult
03:45:06 <roconnor> explicit create / delete functions are bad style
03:45:10 <pastorn> monadic_kid: lolz? type InstanceConfig = (String,Word32,(Int,Int),(Int,Int),Bool)
03:45:14 <pastorn> hello semantics :D
03:45:28 <monadic_kid> pastorn lol well I was trying to hide the IORef at the time
03:45:56 <pastorn> monadic_kid: just a small tip... you should prefix your record field names
03:46:18 <pastorn> master ==> riMaster; surface rSurface etc. etc.
03:46:42 <monadic_kid> pastorn: up this is me just coding up ideas, I use fclabels usually but I'll probably not use it here
03:46:46 <pastorn> words like 'surface' and 'master' seems too general to be taken
03:47:30 <roconnor> monadic_kid: what function frees an allocated surface?
03:47:43 <pastorn> monadic_kid: what's your monad? a state one?
03:47:55 <roconnor> ah
03:47:56 <roconnor> freesurface
03:48:07 <monadic_kid> roconnor: there is a FFI function for SDL_FreeSurface and it's attached to the forieng ptr
03:48:44 <roconnor> monadic_kid: so it just needs to be garbage collected to be freed?
03:48:49 <monadic_kid> pastorn: It's a monad transformer stack of state, reader and io
03:49:02 <roconnor> so I don't really see why you need a list of masters
03:49:25 <roconnor> just have a containter of instances with "master" fields
03:49:47 <pastorn> monadic_kid: just saw your cycle...
03:50:42 <monadic_kid> roconnor: I need a way to say which renderable i'm instancing
03:50:49 <pastorn> master ==> the ioref ==> instances ==> back again
03:51:02 <roconnor> mauke: sure, but that renderable doesn't have to be from a list of masters
03:51:05 <pastorn> monadic_kid: i'm thinking you should do this more like a tree
03:51:05 <roconnor> it can be any old renderable
03:51:12 <pastorn> so no references going up
03:53:44 <pastorn> so if a 'master' surface gets translated, that translation is run on all objects held by the master
03:53:47 <pastorn> like fmap
03:54:41 <pastorn> monadic_kid: i also don't see why you're using IORefs... it seems like an odd choice when you can have pure code
03:54:46 <roconnor> monadic_kid: a link to an IORef for a master is only useful if masters mutate
03:54:52 <roconnor> heh
03:54:57 <roconnor> basically what pastorn said
03:55:06 <pastorn> monadic_kid: here, this is how you write a game loop: http://evanr.infinitymotel.net/misc/loops.html
03:55:25 <pastorn> monadic_kid: basically it's this:
03:56:16 <pastorn> gameLoop state = do { ticks <- getTimeDiff; state' <- tick ticks state; render state'; gameLoop state' }
03:56:38 <monadic_kid> sorry was in the loo
03:57:08 <monadic_kid> pastorn: I've already got a game loop, as I was saying earlier my game is mostly complete, I'm just refactoring code
03:57:45 <pastorn> monadic_kid: well, try to rewrite it tree-like
03:57:55 <pastorn> and keep it pure if you can
03:58:12 * pastorn needs to go...
03:58:22 <pastorn> monadic_kid: i'll check back later :)
03:58:34 <monadic_kid> pastorn: okay, thanks for trying
03:59:42 <monadic_kid> roconnor: the master list was there because later on in time you may need to instance a renderable but outside the module the other components dont have a renderable and I don't want to expose this record to be honest
04:00:05 <roconnor> you don't need to expose the record, just the type
04:00:20 <monadic_kid> true
04:04:38 <monadic_kid> okay that just leaves me with the renderable instances which will mutate a lot throught the duration of the program
04:05:06 <roconnor> but not during rendering
04:06:16 <monadic_kid> well not when rendering but updating happens as frequently as rendering.
04:11:42 <burp> preflex: seen mmorrow
04:11:42 <preflex>  mmorrow was last seen on #ghc 1 year, 82 days, 8 hours and 26 minutes ago, saying: * mmorrow is rtfm'ing
04:12:00 <mauke> preflex: seen PoppaVic
04:12:01 <preflex>  PoppaVic was last seen on ##c 4 hours, 4 minutes and 59 seconds ago, saying: not knowing anything about C?
04:33:48 <Twey> Hrmph
04:34:05 <Twey> What's the syntax to import all fields of a record?
04:35:12 <ivanm> same as importing all constructors
04:35:17 <aristid> (..)
04:35:39 <Twey> import SomeModule (SomeType (SomeRecord (..)))?
04:36:10 <ivanm> where SomeRecord is a constructor? then yes
04:36:20 <Twey> 'kay, thanks
04:36:25 <ivanm> (I think... :p)
04:36:29 <Twey> (that's a lot of brackets)
04:36:56 <Berengal> ((You're usually supposed to put things inbetween them))
04:37:29 <Twey> Hehe
04:37:31 <ivanm> (((Berengal: ((O ((RLY)))) ((?))))) ?
04:38:19 * Berengal is glad those match up
04:38:32 <ivanm> of course they do!
04:45:21 <Twey> Haha
04:45:44 <Twey> I want to type a single left bracket here, but I can't bring myself to do it
04:46:21 <MasseR> I thought I ended up in #lisp or something
04:46:26 <shachaf> (Twey
04:46:31 <Twey> >.-
04:46:35 <zygoloid> eek! )
04:46:42 <Twey> Haha
04:46:46 <Twey> zygoloid: I was resisting
04:46:49 <shachaf> Here, have another one: )
04:46:54 <shachaf> (Fix *that*.)
04:47:19 <Twey> Strangely that one doesn't bother me as much
04:47:28 <shachaf> )Twey(
04:47:34 <Twey> I was just thinking
04:47:43 <Twey> What if there were a language that used brackets like )this(?
04:47:55 <Twey> Some languages use the guillemets like »this«
04:47:59 <zygoloid> so a biologist, a physicist and a mathematician are sitting at a coffee shop. they see two people enter an empty building across from them. later, they see three people leave.
04:48:45 <zygoloid> the biologist says 'clearly they have reproduced'. the physicist says 'clearly an experimental error'. the mathematician says 'ah, if one more person enters, the building will be empty'.
04:48:52 <zygoloid> long story short, ( now we're ok again
04:49:02 <Twey> Haha
04:49:09 <shachaf> > )"fair enough"(
04:49:10 <lambdabot>   <no location info>: parse error on input `)'
04:55:51 <pmurias> will the implicit Maybe extension for view patterns be implemented?
04:56:16 <pmurias> http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns#ImplicitMaybe
05:19:48 <navaati> why can't we do recursive type-synonyms ? it would be so convenient. Isn't there an extension permiting this ?
05:20:36 <xplat> you can use a Mu type in your type synonyms
05:20:37 <Eelis> navaati: can you give an example of what you think should be allowed?
05:21:10 <navaati> type Supplier r v = (r -> (v, Supplier r v))
05:21:35 <Eelis> navaati: but a type synonym is just a shorthand for writing a type. your type would expand to an infinite type
05:21:47 <xplat> there are a couple in libraries or you can define your own as data Mu f = In { out :: f Mu f }
05:22:03 <xplat> or better yet, newtype
05:22:26 <navaati> newtype forces me to box/unbox my values, that's annoying
05:22:46 <ezyang> That's the point. 
05:23:16 <shachaf> It would be nice if boxing/unboxing was more convenient.
05:23:23 <xplat> hm, i guess in general you need Compose as well as Mu for this
05:23:27 <ezyang> @package newtype 
05:23:27 <lambdabot> http://hackage.haskell.org/package/newtype
05:23:43 <Saizan> navaati: such "equirecursive" types, as they are called, would be nice, but type systems that allow them tend to allow any sort of nonsense too
05:24:25 <Eelis> it would make type synonyms into a whole other thing
05:24:28 <xplat> does anyone remember the uri of the article someone pasted a while back on why equirecursivity is scary?
05:25:30 <xplat> anyway, the upshot of it is that a lot of those 'Occurs check' errors you get when you mix up how deep your lists should be or whatever would instead become programs that do the wrong thing at runtime
05:26:20 <xplat> and while newtype boxing/unboxing can be inconvenient it's more than worth it to prevent that stuff from happening
05:28:39 <navaati> well, it works fine with a newtype aswell...
05:38:44 <Twey> Should Data.Text or Data.Text.Lazy be used as the default?
05:43:45 <navaati> xplat: I just got one of these Occurs Check. So it appears that haskell is lazy in values, but not in types ?
05:45:46 <Twey> navaati: Well, in order to type-check a program, the type-level program has to be completely evaluated
05:45:59 <Twey> So you can have lazy types, but your program won't get compiled ;)
05:46:10 <Twey> (or you'll get something like dynamic typing, I guess… hmmm…)
05:47:05 <mercury^> Haha, that's a nice way to look at it.
05:47:10 <Saizan> you could have a type system that unfolds only a prefix of such infinite types, when needed
05:47:12 <mercury^> Dynamic typing is lazy typing.
05:47:24 <Saizan> it's described somewhere in TAPL
05:47:36 <Twey> Yeah, I thought so.
05:47:40 <Twey> Saizan: Hm, interesting
05:47:50 <navaati> argh, i hope my idea of suppliers is possible in haskell
05:47:55 <Twey> Saizan: Does that work?
05:48:15 <Twey> I mean, is it ever useful?  Don't you have to completely evaluate the type for the value to make sense?
05:48:27 <Twey> Oh, I guess not if it's a function or something and you don't care about the type of the result
05:48:54 <Saizan> given type Supplier r v = (r -> (v, Supplier r v))
05:49:29 <Saizan> then evaluating "Supplier r v" shouldn't terminate
05:49:40 <Saizan> you get a larger and larger nesting of -> and (,)
05:49:40 <xplat> Saizan: or parametric polymorphism and uniform representation can rescue you -- anything unifies with an unconstrained type variable
05:49:44 <mercury^> But Haskell already does that type of lazy type evaluation, does it not?
05:50:39 <navaati> i'm constructiong a monad over this, based on the state monad, an providing a method request :: r -> m v
05:50:40 <Saizan> but in reality you just need to expand it a finite amount, and keep "Supplier r v" tail
05:51:00 <Saizan> you still know exactly what the type of everything is
05:51:01 <xplat> mercury^: it does, kind of.  it's not too hard to modify HM to allow equirecursive types, the resulting system just has the bad properties i mentioned
05:51:21 * hackagebot serialport 0.4.0 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.0 (JorisPutcuyps)
05:51:44 <Saizan> s/keep/keep a/
05:52:32 <xplat> there is at least one paper that models dynamic typing as lazy typechecking, but it's an odd kind of 'lazy', it's more like the inverse of partial evaluation
05:52:39 <xplat> partial un-evaluation or something
05:54:59 <xplat> if you do lazy or non-strict typechecking in the usual senses everything that's going to happen at all will still happen at compile time, just maybe later on during it
05:56:59 <Phyx-> wtf,. when did I write this and why is it working
05:58:03 <Saizan> it probably isn't
05:58:20 <Phyx-> but that's the odd part, it is
05:58:43 <xplat> maybe the easter bunny wrote it for you
05:58:54 <Phyx-> I never met him before
05:58:58 <Phyx-> he never leaves eggs for me
05:59:12 <shachaf> Perhaps Oleg wrote it.
05:59:17 <Saizan> why should a bunny leave eggs?
05:59:28 <Saizan> anyhow, it looks like it's working, but there's a subtle bug
05:59:43 <Phyx-> heh
05:59:45 <xplat> a bug ... or an easter egg?
05:59:53 <shachaf> So subtle you'll never come across it.
06:00:06 <navaati> yeah, the supplier thing works perfectly, the error only occurs in ghci
06:00:10 * shachaf grumbles at xplat.
06:00:36 <Phyx-> I need to add something to it
06:00:42 <Phyx-> but can't figure out how it's working
06:00:42 <Phyx-> lol
06:00:45 * Phyx- rewrites
06:01:23 * hackagebot serialport 0.4.0.1 - Cross platform serial port library.  http://hackage.haskell.org/package/serialport-0.4.0.1 (JorisPutcuyps)
06:01:29 <dct25> Hi all, I'm having some trouble understanding namespaces in hexpat: http://hpaste.org/45523
06:01:40 <dct25> It does unexpected things with default namespaces and with unqualified attributes
06:01:45 <dct25> Can anyone help?
06:05:39 <tom__> mm is darcs not windows compatible?
06:06:35 <tom__> ah cool they have prebuild binaries nvm
06:06:36 <Phyx-> yes it is'
06:06:48 <tom__> cabal install darcs doesn't work unfortunately 
06:07:16 <Phyx-> it probably would in msys or cygwin
06:07:16 <ivanm> the C libraries make it tricky, that's all
06:29:53 <sanjoyd> Is reverse O(n)? Does such a question make sense in a language like Haskell?
06:31:01 <cheater99> no because haskell is lazy
06:31:22 <sanjoyd> Thanks. I thought so.
06:31:53 <aristid> well, head $ reverse xs is O(n)
06:32:01 <aristid> once evaluated
06:32:20 <ivanm> cheater99: huh? it still makes sense
06:32:33 <sanjoyd> But would it not be more effective to have an implementation which really represents a list as a doubly-linked list?
06:32:44 <sanjoyd> Since then reverse would be O(1)?
06:32:51 <cheater99> ivanm: how does it make sense
06:33:09 <ivanm> cheater99: what is the runtime complexity of reversing the list?
06:33:15 <cheater99> ivanm: haskell is lazy, you do not know what the underlying data structure is
06:33:17 <ivanm> e.g. print $ reverse xs
06:33:26 <ivanm> cheater99: WTF?
06:33:28 <cheater99> you cannot talk about the runtime complexity because you don't know what "list" is
06:33:38 <tom__> you do know that
06:33:42 <tom__> atleast I do -.-
06:33:46 <sanjoyd> ivanm: suppose my haskell compiler represents a list as a doubly linked list?
06:33:47 <aristid> the type of list tells you what a list is
06:33:56 <aristid> sanjoyd: it can't.
06:33:57 <cheater99> it might be a million different things that are reversible
06:34:01 <sanjoyd> aristid: why not?
06:34:02 <ivanm> That's just being ridiculous
06:34:05 <cheater99> you don't know the internal workings
06:34:08 <ivanm> @src reverse
06:34:08 <lambdabot> reverse = foldl (flip (:)) []
06:34:11 <aristid> sanjoyd: because that would not allow infinite lists
06:34:17 <cheater99> it's not being ridiculous
06:34:19 <ivanm> sanjoyd: ^^ that's what reverse is
06:34:20 <sanjoyd> aristid: okay. Makes sense.
06:34:36 <ivanm> you can still work out the complexity of lazy algorithms
06:34:53 <ivanm> that's why they appear in papers of algorithm comparison, etc.
06:35:11 <cheater99> but the complexity will still depend on what that algorithm is being fed
06:35:12 <ivanm> cheater99: the internal workings of the list data type don't make sense
06:35:26 <ivanm> in the same way they don't make sense for algorithms in Java, etc.
06:35:34 <cheater99> of course they do because the final complexity can be overwhelmed
06:35:54 <ivanm> and complexity is based upon the language spec, not the implementation
06:37:06 <sanjoyd> Does the Haskell spec say anything about, say, head and : being a constant time operation?
06:37:14 <niteria> :t ((.)$(.))
06:37:15 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
06:37:19 <ivanm> sanjoyd: it gives the implementation...
06:37:21 <aristid> data [a] = [] | a : [a]
06:37:22 <ivanm> @src head
06:37:22 <lambdabot> head (x:_) = x
06:37:22 <lambdabot> head []    = undefined
06:37:32 <cheater99> but if my list is a linked list with no direct way of finding an indexed item except for following the links from the top, what how do you get your O(1) algorithm that works on it to really be O(1)?
06:37:34 <ivanm> pretty sure you can work out from there that it's O(1)
06:37:37 <cheater99> you don't
06:37:46 <sanjoyd> So the complexity depends on how fast the pattern matching is?
06:37:53 <aristid> matching constructors can be ASSUMED to be O(1)
06:37:53 <ivanm> no
06:39:07 <Saizan> you can parametrize your analysis by the cost of primitive operations, then instantiate it for the values used by any implementation you care about?
06:39:38 <Saizan> pattern matching is constant time in any implementation i know of
06:39:49 <sanjoyd> Saizan: makes sense. If I can say reverse = O(n * O(:)) or something ...
06:40:02 <sanjoyd> (In a loose mathematical sense).
06:40:33 <Saizan> ..abusing notation like crazy
06:40:43 <ivanm> that's no different than in any other language where you assume the cost of setting a pointer is O(1), etc.
06:41:19 <Saizan> right
06:44:42 <mauke> class Constable a where const :: a -> b -> a
06:45:52 <Phyx-> wtf
06:45:56 <shachaf> instance Constable Bool where const _ _ = False -- It's for constant functions, right?
06:46:00 <Phyx-> what's the point of that class?
06:46:06 <mauke> bad puns
06:46:38 <Phyx-> lol
06:47:36 <cheater99> Saizan: yes, that's exactly what i mean
06:47:37 <hpc> that's one lazy constable
06:47:41 <hpc> i wouldn't live there :P
06:48:13 <Phyx-> would be a great pun though
06:48:18 <cheater99> you can't really talk about complexity of algorithms on their own, you need to know what model that algorithm is working on
06:48:23 <mauke> cheater99: how is that related to haskell or laziness?
06:48:23 <Phyx-> import Prelude hiding (const)
06:48:24 <Phyx-> lol
06:48:29 <mauke> cheater99: you've got the same problem in C
06:48:42 <cheater99> mauke: yes, but in C you can define what struct you're taking etc.
06:48:58 <merijn> cheater99: You still have issues with caches
06:49:00 <mauke> and in Haskell you can define what data you're taking
06:49:20 <cheater99> merijn: yes, but caches are outside of the realm of what sane people care about ;)
06:49:29 <cheater99> mauke: not really
06:49:36 <mauke> I compile C to Haskell; your argument is invalid
06:49:36 <merijn> Most complexity analysis of algorithms assumes uniform memory access and is thus "worthless" in the real world
06:49:44 <cheater99> you can have lots of different things that are Ord
06:50:01 <cheater99> and Ord is the only prerequisite for reverse, if you think about it
06:50:05 <mauke> what
06:50:21 <mauke> :t reverse
06:50:22 <lambdabot> forall a. [a] -> [a]
06:50:24 <merijn> cheater99: "outside the realm of what sane people care about" using a suboptimal algorithm with better caching behaviour can result in an order of magnitude speedup...
06:50:26 <tom__> @src reverse
06:50:26 <lambdabot> reverse = foldl (flip (:)) []
06:50:29 <tom__> O_o
06:50:44 <cheater99> merijn: i know! funny, isn't it?
06:50:45 <Phyx-> why O_o
06:50:45 <mauke> cheater99: I thought about it and it isn't
06:50:46 <Phyx-> lol
06:50:51 <Phyx-> @src map
06:50:51 <lambdabot> map _ []     = []
06:50:51 <lambdabot> map f (x:xs) = f x : map f xs
06:50:58 <Phyx-> why isn't map defined as a fold!
06:51:10 <cheater99> mauke: how are you going to reverse things that do not have order?
06:51:18 <merijn> Phyx-: Why would it be?
06:51:21 <mauke> cheater99: I'm reversing a list
06:51:24 <cheater99> things in a list very obviously have order
06:51:30 <mauke> cheater99: unrelated to Ord
06:51:35 <Phyx-> merijn: because reverse is? consistency!
06:51:49 <merijn> Phyx-: Clarity trumps consistency :p
06:52:03 <Phyx-> lol
06:52:05 <cheater99> mauke: that's a special case of reverse.
06:52:11 <mauke> cheater99: no
06:52:11 <cheater99> mauke: you can reverse other things!
06:52:17 <merijn> cheater99: Like?
06:52:24 <mauke> cheater99: look at the goddamn type
06:52:25 <Phyx-> :t \f -> foldl ((:).f) []
06:52:26 <lambdabot> forall a. ([a] -> a) -> [[a]] -> [a]
06:52:27 <merijn> cheater99: How do I reverse a number?
06:52:38 <cheater99> DAGs, graphs, deques, ...
06:52:44 <mauke> cheater99: look at the goddamn type
06:52:44 <cheater99> er minus graphs
06:52:54 <Phyx-> :t \f -> foldr ((:).f) []
06:52:55 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
06:52:57 <merijn> Phyx-: If you like fold I know a good paper to read :p
06:53:06 <cheater99> mauke: yes, please stop swearing, thanks
06:53:15 <mauke> fuck this shit
06:53:28 <aristid> :t  \f -> foldl (flip$(:).f) []
06:53:29 <Phyx-> merijn: sure , hit me :)
06:53:29 <lambdabot> forall a b. (b -> a) -> [b] -> [a]
06:53:43 <sanjoyd> Phyx-: is it actually possible to implement a map as a fold?
06:53:43 <aristid> Phyx-: did you mean that?:)
06:53:45 <merijn> Phyx-: A tutorial on the universality and expressiveness of fold by Graham Hutton, it shows how any recrusive function can be written as fold plus a trivial function (and vice versa)
06:53:49 <aristid> sanjoyd: yes.
06:53:52 <Phyx-> sanjoyd: yes
06:53:59 * sanjoyd googles.
06:54:21 <merijn> http://www.cs.nott.ac.uk/~gmh/fold.pdf
06:54:26 <Phyx-> aristid: yeah, I didn't flip it, :P
06:54:27 <sanjoyd> merijn: thanks.
06:54:44 <aristid> Phyx-: that's reverseMap, i think
06:54:48 <Phyx-> merijn: cool, thanks
06:55:03 <aristid> > (\f -> foldl (flip$(:).f) []) (*2) [1..5]
06:55:04 <lambdabot>   [10,8,6,4,2]
06:55:11 <merijn> And actually quite readable, which is a nice change from the usual incomprehensible papers :p
06:55:34 <Phyx-> > (\f -> foldr ((:).f) []) (*2) [1..5]
06:55:36 <lambdabot>   [2,4,6,8,10]
06:55:52 <sanjoyd> @src flip
06:55:52 <lambdabot> flip f x y = f y x
06:56:50 <Saizan> implementing map with fold*l* is a sin against nature, btw
06:57:34 <merijn> :t liftM
06:57:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:58:11 <Phyx-> aristid: the foldl version wouldn't be right anyway, it won't give partial results on infinite lists
06:58:48 <aristid> Phyx-: besides from reversing the list?
06:58:57 <Phyx-> aristid: lol, yeah, besides that
06:59:23 <tom__> >(\f -> foldr ((:).f) []) (+1) [1,2,3]
06:59:34 <aristid> > (\f -> foldl ((++) . return . f) []) (*2) [1..5]
06:59:35 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
06:59:44 <shachaf> > (\f -> reverse . foldl (flip$(:).f) []) (*2) [1..5]
06:59:45 <tom__> > (\f -> foldr ((:).f) []) (+1) [1,2,3]
06:59:47 <lambdabot>   [2,4,6,8,10]
06:59:47 <lambdabot>   [2,3,4]
07:01:56 <tom__> so ... mm when you have a state and you want to modify it, is the best way to create a StateT for it?
07:14:35 * hackagebot uuagc 0.9.38.0 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.38.0 (ArieMiddelkoop)
07:17:23 <ksf_> http://img706.imageshack.us/img706/2189/1224707819435.jpg
07:18:04 <rostayob> @pl \context ct -> runReaderT ct context >>= return
07:18:04 <lambdabot> flip flip return . ((>>=) .) . flip runReaderT
07:20:52 <Tomsik> @t flip flip
07:20:52 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:21:01 <Tomsik> :t flip flip
07:21:02 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
07:21:12 <hpc> :t flip
07:21:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
07:21:18 <hpc> :t flip flip flip
07:21:19 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b
07:21:27 <hpc> <.<
07:21:27 <Tomsik> Wait
07:21:42 <Tomsik> That type of flip doesn't look like what I'm used to
07:21:46 <Tomsik> :t fmap
07:21:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:21:49 <rostayob> @pl \context ct -> (`liftM` (runReaderT ct context))
07:21:49 <lambdabot> (flip fmap .) . flip runReaderT
07:21:54 <rostayob> mh. that's better.
07:21:57 <Tomsik> :t (<*>)
07:21:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:22:15 <hpc> Tomsik: flip is given some crazy functor magic in lambdabot
07:22:18 <rostayob> :t  \context ct -> (`liftM` (runReaderT ct context))
07:22:19 <hpc> :t Prelude.flip
07:22:19 <lambdabot> forall a1 r r1 (m :: * -> *). (Monad m) => r1 -> ReaderT r1 m a1 -> (a1 -> r) -> m r
07:22:20 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:22:32 <Tomsik> :t flip
07:22:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
07:22:34 <rostayob> :t \context ct -> runReaderT ct context >>= return
07:22:35 <lambdabot> forall r (m :: * -> *) a. (Monad m) => r -> ReaderT r m a -> m a
07:22:40 <Tomsik> :t (=<<)
07:22:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
07:22:41 <hpc> :t (\ff x -> fmap ($x) ff)
07:22:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
07:22:50 <rostayob> lambdabot orgy!
07:23:10 <hpc> Tomsik: flip = (\ff x -> fmap ($x) ff)
07:23:24 <Tomsik> heh
07:30:14 <hpc> :t (<=<) `asTypeOf` (.)
07:30:15 <lambdabot>     Occurs check: cannot construct the infinite type: b = m b
07:30:15 <lambdabot>       Expected type: a -> m b
07:30:15 <lambdabot>       Inferred type: a -> b
07:30:18 <hpc> poo
07:34:12 <Tomsik> It's kind of annoying that there's >>=, =<<, >=>, <=< and >>
07:34:15 <Tomsik> but there's no <<
07:34:30 <hpc> Tomsik: it is debated what order (<<) should perform side effects in
07:34:34 <Tomsik> and I have to define it myself
07:35:14 <hpc> should a << b = a >> b or do {x <- b; a; return x}?
07:35:21 <Tomsik> Why should you debate that, why wouldn't it be just that you take a >>= b >> c >> d and just turn it around to d << c << b =<< a
07:36:51 <Saizan> do {x <- b; a; return x} = b <* a
07:37:42 <hpc> Tomsik: (a << b) could be interpreted as "run a first, then b, then return value of a"
07:37:47 <hpc> ie, (<<) = flip (>>)
07:38:03 <hpc> er, the other one is flip (>>)
07:38:13 <tom__> mm no way to derive Show for a type right?
07:38:33 <hpc> but the question is, do you read the side effects as going from left to right?
07:38:40 <hpc> there are situations where that is useful
07:38:48 <hpc> like parsing a parenthesized expression
07:38:54 <rostayob> tom__: what do you mean? you want a different Show for a type synonym?
07:39:00 <hpc> openParen >> expr << closeParen
07:39:16 <tom__> rostayob, yeah, I need it in order to derive Show on a datatype which uses it
07:39:24 <tom__> but im not sure if you can derive show for a function type
07:39:27 * hpc has confused himself horribly
07:39:37 <tom__> like type A = Some->Thing
07:40:49 <rostayob> tom__: mhm idk
07:41:01 <tom__> I guess I manually build a show instance
07:42:00 <rostayob> tom__: I don't think I understood what you want to do
07:42:29 <tom__> I have a data type data A = B Sometype and type Sometype = Bla->Bli
07:43:11 <tom__> if I derive show on A, it is not possible because it needs to have a show instance for Sometype aswell
07:44:39 <rostayob> tom__: 1) I didn't know you could do that (type Sometype = Bla -> Bli) 2) I'd guess tt's impossible to have Show for a function that's not unary
07:45:06 <tom__> yeah
07:45:17 <tom__> so I juist made a custom instance for A now
07:45:22 <hpc> lambdabot has a show instance for functions
07:45:29 <rostayob> no sorry for a kind that's not unary
07:45:30 <hpc> (it actually has two...)
07:45:35 <hpc> > (+1)
07:45:35 <tom__> hmm
07:45:36 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:45:36 <lambdabot>    arising from a use of `...
07:45:41 <navaati> > const
07:45:42 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> a)
07:45:42 <lambdabot>    arising from a use...
07:46:21 <hpc> @ask Cale who do we have to bug to get the Show instance for functions working?
07:46:21 <lambdabot> Consider it noted.
07:46:23 <Saizan> yeah, the instance would only show the type or something like that though
07:46:33 <hpc> oh, boring
07:46:39 <rostayob> I mean how can you show a function
07:46:50 <Saizan> hpc: what did you expect?
07:47:24 <hpc> i half-expected some nightmarish GHC feature to pop out of the woodwork
07:47:42 <rostayob> it could get the AST and print that!
07:47:43 <Saizan> smallcheck has another for types of its Arbitrary-like typeclass, showing (input,output) paris
07:47:46 <Saizan> *pairs
07:47:57 <Saizan> as if the ast was there!
07:48:52 <rostayob> Saizan: ?
07:49:52 <Saizan> most of the source is forgotten during compilation
07:50:23 <rostayob> Saizan: well I mean a TH kind of AST... I wasn't talking seriously anyway
07:51:10 <Saizan> also breaking extensionality (i.e. that two functions are equal iff they agree for all inputs) is not something you'd generally like 
07:52:22 <rostayob> Saizan: Why is that relevant to Show?
07:54:00 <rostayob> I mean in haskell a == b doesn't imply show a == show b
07:54:01 <Saizan> rostayob: if you use the ast then show (*2) /= show (\x -> x + x), so show would be an impossible function that returns different results for equal inputs
07:54:30 <rostayob> Saizan: yeah but Show and Eq are not the same
07:54:45 <Saizan> i'm not actually talking about Eq
07:55:15 <rostayob> Saizan: than I don't see why having two functions with a different syntax tree would imply that they're "different"
07:55:39 <Saizan> though an Eq instance that considers equal things observably different would not be on a firm moral ground either :)
07:56:11 <Saizan> rostayob: because equal inputs should produce equal outputs, always
07:56:40 <hpc> Saizan: then perhaps they should be different
07:56:56 <roconnor> > -(0.0) == 0.0
07:56:56 <lambdabot>   True
07:57:06 <roconnor> > isNegativeZero (-0.0)
07:57:07 <lambdabot>   True
07:57:09 <roconnor> > isNegativeZero (0.0)
07:57:10 <lambdabot>   False
07:57:26 <hpc> roconnor: floats break so many properties anyway
07:57:29 <rostayob> Saizan: I've got a lot of things that look different but they show different, in haskell :P
07:57:43 <roconnor> > (0.0/0.0) = (0.0/0.0)
07:57:44 <lambdabot>   <no location info>: parse error on input `='
07:57:46 <Saizan> rostayob: what?
07:57:47 <roconnor> > (0.0/0.0) == (0.0/0.0)
07:57:48 <lambdabot>   False
07:58:21 <Saizan> hpc: then you break extensionality, and my point was that you don't want to do that without thinking about the larger consequences
07:58:43 <rostayob> Saizan: no I was saying that things can be "the same", but show differently
07:58:45 <hpc> Saizan: i don't think you do, because we can't prove they are the same
07:58:55 <hpc> not without solving the halting problem, at least
07:58:55 * roconnor is okay with (==) being a parital equivalence relation
07:58:58 <Saizan> hpc: you can prove they are different!
07:59:08 <Saizan> hpc: once you have this show
07:59:26 <rostayob> Saizan: and \x -> x + x and (*2), are not the same input
07:59:30 <rostayob> they're very different
07:59:34 <rostayob> they do the same
07:59:40 <rostayob> but they're not the same imput
07:59:42 <rostayob> *input
08:02:10 <rostayob> I was talking about Eq becaue what you said makes sense to me if Eq compared the ASTs
08:02:21 <Saizan> the problem is that most of the code transformations you do are guaranteed to be semantics preserving only if you assume that extensionality holds, if you break it you've a lot more to worry about
08:03:25 <rostayob> Saizan: I'm arguing that you don't break extensionality that way, since '\x -> x + x' and (*2) are not the same input
08:03:48 <Darkone> I feel stupid asking this, but doesn't  ab = (a*b) and not a*b?
08:03:55 <Darkone> In math in general.
08:03:58 <Darkone> I'm pretty sure it does
08:04:26 <Saizan> rostayob: heh, for all inputs those agree, so they are the same by extensionality
08:04:50 <Darkone> Wait, I'm being stupid. My example works out the same both ways.
08:04:53 <Darkone> :S
08:04:54 <rostayob> Saizan: but comparing the result of Show doesn't tell you if two things are the same, that's my point
08:04:56 <Saizan> then you have the paradoxical fact that show doesn't agree with itself
08:05:11 <FUZxxl> Hello! Is there a Haskell library for https?
08:05:12 <Saizan> rostayob: it does tell me if they are different
08:05:28 <azaq23> Darkone: * is associative and commutative, makes no difference anyway yep, assuming you mean the parenthesis
08:05:32 <Saizan> rostayob: no function can map equal things to different things, unless your notion of equality is borked
08:06:18 <rostayob> Saizan: ok we're going in circles here: in my notion Show just gives you a representation of something, and nothing else
08:06:53 <Saizan> rostayob: can f n ever be different from f n? in any way?
08:06:53 <rostayob> if it wasn't that way, Show would imply Eq
08:07:02 <Saizan> it's this you're saying.
08:07:04 <Darkone> azaq23, here's the one I'm confused on, is ab / cd  written single line, using the division sign instead of the slash. Is that still (ab) / (cd), or does it become a * b / c * d? I know that when you write it over and under, it's actually a fraction.
08:07:45 <rostayob> Saizan: show (\x -> x + x) it's not the same as show (*2) because if you choose to represent functions by the AST with Show, the ast is not the same.
08:08:32 <rostayob> but Show doesn't tell you much about the nature of what's being showed
08:08:43 <rostayob> at least that's how I treat Show
08:08:46 <Darkone> Mostly it's just that a single line equation like that is ambiguous
08:09:00 <Darkone> But I assume it still means (ab) / (cd)
08:09:01 <Saizan> rostayob: the AST is not the same, but if you assume extensionality then (\x -> x + x) and (*2) are the same, so i should be able to substitute (\x -> x + x) with (*2) in my program anywhere and get the same result
08:09:07 <Saizan> rostayob: but your show breaks that!
08:09:21 <azaq23> Darkone: You're talking about math in irc and so on, yep? Well, math is ambiguous due to crappy notation from 200 years ago anyway. I always write equations using as much parenthesis as possible and in the way programming languages usually interpret it, so it is unambiguous
08:09:49 <azaq23> Darkone: You can only guess what someone means in the case of ab / cd. But likely, he wants it to be read as (a*b)/(c*d)
08:10:08 <rostayob> Saizan: no, because as far Show is concerned, (\x -> x + x) and (*2) are *not* the same!
08:10:16 <azaq23> Darkone: Because it seems like he tried to write a fraction down, just as you also noticed.
08:10:18 <rostayob> the bottom line is that I agree that it would be a stupid idea to define it like that
08:10:24 <rostayob> but I don't see it as wrong
08:10:25 <Darkone> That's the problem, there shouldn't be abiguity
08:11:03 <Saizan> rostayob: i'm saying that it's inconsistent with extensionality, by the simple fact that it considers different things that for extensionality are equal.
08:11:18 <Saizan> rostayob: which you just admitted, btw
08:11:24 <Darkone> If someone writes abcd, there is supposed to be a clear order of operations.
08:11:40 <rostayob> Saizan: well that's true, but that's not the point of show
08:12:12 <rostayob> I was talking about the extensionality of 'show', you were talking about the extensionality of those two functions
08:12:38 <Saizan> i'm talking about extensionality as a property of the language, it has to hold for every function
08:12:47 <Saizan> but yeah, i wasn't using it on show
08:13:39 * ksf_ wants cabal install-deps
08:13:45 <azaq23> Darkone: Yes, there should be. But just look at the math channel for a day and you see very much ambiguity from people asking questions. There simply is no convention regarding ASCII math notation. You'll have to ask someone writing things ambiguously what he means and try to write as unambiguously as possible
08:13:46 <rostayob> Saizan: yes but the concept of equality would be different for show and for other stuff
08:13:48 <Saizan> ksf_: there is
08:13:49 <rostayob> of function equality
08:14:16 <rostayob> because, again, show doesn't care about what its showing "means"
08:14:18 <azaq23> well except for the "convention" to write things like one would in a programming language
08:14:27 <Saizan> rostayob: if anywhere in the language that concept of equality is differnt than extensionality doesn't hold as a way to reason about your code
08:14:37 <azaq23> but this is only done by people who program regularely anyways
08:14:45 <ksf_> Saizan, I can't find it in the help
08:14:57 <Saizan> rostayob: but i care about what my programs mean, and they might contain show
08:15:13 <ksf_> and I'm running 0.10.0/1.10.1.0, here.
08:15:30 <Saizan> ksf_: --only-dependencies
08:15:59 <ksf_> thx
08:16:13 <Saizan> "different, then"
08:16:19 <rostayob> Saizan: I just don't feel that show should honor the meaning of what its showing
08:16:45 <ksf_> show alone can't.
08:16:54 <ksf_> it's read/show that form a full set.
08:17:57 <Darkone> azaq23, actually this is on paper. I think I've puzzled it out though, that "ab" being a binomial, is a single unit.
08:17:57 <Saizan> it's not about show honoring, it's about wheter i can go replacing (\x -> x+x) with (x*2) anywhere being sure my program won't change meaning or not
08:18:30 <rostayob> Saizan: if you don't read back the strings, the code won't change meaning
08:18:39 <rostayob> I mean... wait
08:19:00 <Saizan> rostayob: main = print (*2); vs. main = print (\x -> x + x)
08:19:29 <hpc> Saizan: (* 2) and join (+) aren't guaranteed to be the same
08:19:38 <rostayob> Saizan: what do you mean by meaning of the program? because those two would do the same thing for me
08:19:42 <rostayob> even if they print different ASTs
08:19:45 <Tomsik> :t join (+)
08:19:46 <lambdabot> forall a. (Num a) => a -> a
08:19:49 <Tomsik> :t join
08:19:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:20:06 <Tomsik> m = (->) here?
08:20:06 <hpc> Tomsik: for functions, join f x = f x x
08:20:15 <Saizan> hpc: oh, you know that's beside the point :) anyhow let's specialize them to some type for which they do
08:20:53 <hpc> Saizan: how about floats :P
08:21:14 <ksf_> I think shake should support generating a shell script that can build (and no more) a project
08:21:57 <ksf_> ...think about bootstrapping with minimal dependencies.
08:22:31 <ksf_> also, people are never going to pick it up when end-users absolutely have to install haskell just to build the thing.
08:22:42 <Saizan> rostayob: main = let str = show (*2) in if show (\x -> x + x) == str then launchNuclearMissiles else signPeaceTreaty, vs. with (*2) in both arguments to show, do they still mean the same?
08:23:04 <schlicht> ksf_, ui, whats the topic :) ?
08:23:16 <rostayob> no no wait, you're implying that Show implies Eq!
08:23:21 <rostayob> I never said that!
08:23:33 <Saizan> rostayob: i'm just comparing the resulting strings!
08:23:35 <hpc> rostayob: it does, because String is Eq
08:23:41 <Saizan> i'm not making it imply anything.
08:23:44 <ksf_> schlicht, I'm talking about shake
08:23:53 <ksf_> https://github.com/batterseapower/openshake
08:24:12 <Saizan> it just so happens that my program is particularly sensible on how those strings look :)
08:24:14 <rostayob> Saizan: so what? I never said that show should be consistend in that way
08:24:15 <ksf_> also, http://community.haskell.org/~ndm/shake/
08:24:42 <Saizan> rostayob: again, if i go replacing (*2) with (\x -> x+x) that program changes meaning. 
08:24:53 <schlicht> ksf_, thanks
08:25:05 <Saizan> rostayob: if extensionality holds i'm guaranteed such a change won't change the meaning of my programs.
08:25:22 <rostayob> Saizan: so you're saying that you should be able to do "instance Show a => Eq a where; (==) = show"?
08:25:29 <rostayob> always?
08:25:35 <Saizan> rostayob: i don't care about Eq!
08:25:43 <rostayob> you do, that's what you're doing
08:25:52 <rostayob> you're using (==)
08:25:56 <Saizan> fine
08:26:13 <rostayob> btw it would be
08:26:30 <hpc> show `on` (==)
08:26:33 <rostayob> (==) = (==) . show, not what I wrote before
08:26:39 <rostayob> no sorry :P
08:26:44 <rostayob> a == b = show a == show b
08:26:48 <hpc> :t show `on` (==)
08:26:49 <lambdabot>     Couldn't match expected type `b -> c'
08:26:49 <lambdabot>            against inferred type `String'
08:26:49 <lambdabot>     In the first argument of `on', namely `show'
08:26:55 <hpc> :t (==) `on` show
08:26:56 <lambdabot> forall a. (Show a) => a -> a -> Bool
08:27:02 <rostayob> yeah, that one eheh
08:27:14 <Saizan> rostayob: f ('(':'*':'2':')':[]) =  launchNuclearMissiles; f _ = signPeaceTreaty; main = f (show (*2)) vs. main = f (show (\x -> x + x))
08:27:50 <hpc> Saizan: so what about floats?
08:28:00 <Saizan> hpc: why do i care?
08:28:01 <hpc> Saizan: what about CReal, which also breaks extensionality?
08:28:10 <Saizan> hpc: how?
08:28:22 <hpc> > show (pi :: CReal)
08:28:23 <lambdabot>   "3.1415926535897932384626433832795028841972"
08:28:26 <rostayob> Saizan: no you're still comparing things... I don't think that equal things necessary lead to equal 'show's
08:28:47 <hpc> > show (pi :: CReal) == show (3.14159265358979323846264338327950288419721111111111111111111111111111111111 :: CReal)
08:28:48 <lambdabot>   True
08:28:54 <hpc> oh look, i broke extensionality
08:29:03 <Saizan> that's not breaking extensionality
08:29:08 <rostayob> why not?
08:29:20 <shachaf> > [f x | f <- [(*2),join (+)]]
08:29:21 <lambdabot>   [x * 2,x + x]
08:29:33 <rostayob> anyway I badly need to study, you two can continue if you want
08:30:01 <Saizan> hpc: extensionality = forall f g. f = g iff forall x. f x = g x
08:30:16 <Saizan> hpc: how is that a counterexample of that?
08:30:18 <hpc> Saizan: "iff" means the arrow goes both ways
08:30:25 <hpc> f x = g x iff f = g
08:30:25 <Saizan> right
08:30:31 <hpc> pi /= that big thing
08:30:35 <Saizan> forall x.
08:30:39 <hpc> ergo, show pi should not equal that big thing
08:30:50 <Saizan> no.
08:31:00 <Saizan> you forgot the forall and that's crucial
08:31:12 <doserj> hpc: with that reasoning (^2) would break extensionality, because (-1)^2 = 1^2
08:31:19 <Saizan> right
08:31:34 <hpc> oh, i see
08:31:41 <Saizan> functions are allowed to not be injective
08:33:27 <shachaf> Some "functions" those are. Next you'll be legalizing relations and then arbitrary sets.
08:33:31 <Saizan> in fact i don't see what you were trying to deduce from f x = g x iff f = g even, your argument is a bit like f x = g y, but f = g then x = y, which holds only if f is injective
08:33:54 <hpc> yeah, i got mixed up
08:34:28 <hpc> oh, i see your logic
08:34:41 <hpc> your example sucks though, btw
08:34:53 <Saizan> i think the confusion is about me wanting show to be somehow faithful to whatever it's showing, i don't care
08:34:58 <hpc> so your logic is, \a -> a equals \b -> b, by extensionality
08:35:04 <Saizan> yes
08:35:15 <hpc> Saizan: so show (\a -> a) should equal show (\b -> b), also by extensionality
08:35:41 <hpc> so yeah, then a show instance for functions would require solving the halting problem
08:35:43 <Saizan> well, not quite by extensionality alone
08:36:01 <Saizan> you've to assume that if x = y then f x = f y
08:36:20 <Saizan> which is basic susbtitutivity of equals for equals
08:37:17 <ksf_> hmmm, there's no haskell->POSIX sh compiler is there? ;)
08:37:44 <hpc> so if we throw out (x = y => f x = f y), then we don't have to care about alpha equivalence and all that jazz
08:37:50 <rostayob> Saizan: just one thing, and then I close IRC otherwise I can't study: following your reasoning, you can say a == b = show a == show b, right?
08:37:57 <hpc> i suppose that's easier than throwing out extensionality
08:38:08 <Saizan> rostayob: no
08:38:13 <hpc> er
08:38:19 <rostayob> Saizan: why not?
08:38:28 * hpc is being dumb again
08:38:33 <shachaf> instance Show T where show _ = ""
08:38:40 <Saizan> what shachaf said
08:38:43 <hpc> tossing that means tossing referential transparency
08:38:50 <Saizan> hpc: bingo!
08:38:54 <rostayob> oh right
08:38:58 <hpc> so yeah, ill shut up :P
08:39:19 <ksf_> shachaf, you're guilty of breaking the show . read == id law.
08:39:23 <ksf_> someone do the verdict.
08:39:45 <shachaf> ksf_: No instance Read for my type.
08:39:46 <rostayob> mhm... I still don't think what show produces "matters" in terms of meaning of the program, but yeah I guess you're right
08:40:10 <ksf_> then you are aquitted and haskell is found guilty of not separating showing and serialising
08:40:20 <roconnor_> I don't think show . read == id is a reasonable law
08:40:35 <roconnor_> show/read is more like a galois connection I think
08:40:37 <hpc> roconnor_: read . show is the law
08:40:37 <ksf_> ...up to semantic equality.
08:40:46 <rostayob> and not, goodbye ehe
08:40:48 <shachaf> data T = T; instance Show T where show !x = ""; instance Read T where read _ = T
08:40:55 <hpc> show . read entails that there be exactly one parse
08:41:03 <shachaf> I mean read "".
08:41:03 <hpc> > read "Just      5" :: Maybe Int
08:41:04 <lambdabot>   Just 5
08:41:05 <roconnor_> hpc: that is more reasonable
08:41:25 <ksf_> > show . read $ "Just 5" :: String
08:41:27 <lambdabot>   "*Exception: Prelude.read: no parse
08:41:29 <ksf_> wooosh
08:41:39 <hpc> > read . show (Just 5)
08:41:39 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:41:40 <lambdabot>         against inferred ty...
08:41:40 <ksf_> > (show . read $ "Just 5") :: String
08:41:41 <lambdabot>   "*Exception: Prelude.read: no parse
08:41:48 <hpc> > read . show (Just 5) :: Maybe Int
08:41:49 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Base.String'
08:41:49 <lambdabot>         aga...
08:41:52 <hpc> > read . show $(Just 5) :: Maybe Int
08:41:54 <lambdabot>   Just 5
08:42:33 <paolino> :t \n f -> foldM (const f) [] [1..n]
08:42:34 <lambdabot> forall b (m :: * -> *) a. (Num b, Enum b, Monad m) => b -> (b -> m [a]) -> m [a]
08:42:34 <ksf_> the whole thing is broken by design.
08:43:00 <hpc> Saizan: in any event, a show instance for functions would be a cool thing for something like Debug.Trace
08:43:09 <shachaf> > show x
08:43:10 <lambdabot>   "x"
08:43:12 <ksf_> read shouldn't be used for parsing (use parsing combinators), and while show generating haskell code is a commendable goal, it doesn't work out due to imports.
08:43:20 <shachaf> > read "x" :: Expr
08:43:21 <lambdabot>   No instance for (GHC.Read.Read SimpleReflect.Expr)
08:43:21 <lambdabot>    arising from a use of...
08:43:23 <hpc> where everything's made up and math doesn't matter
08:43:24 <ksf_> there's a gazillion things that use fromList
08:43:35 <paolino> :t \n f -> foldM (flip const f) [] [1..n]
08:43:36 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> m a
08:43:36 <lambdabot>     Probable cause: `const' is applied to too many arguments
08:43:36 <lambdabot>     In the first argument of `flip', namely `const'
08:44:13 <paolino> :t \n f -> foldM (const $ flip f) [] [1..n]
08:44:14 <lambdabot> forall (f :: * -> *) a a1. (Functor f, Num a, Enum a, Monad f) => a -> f (a -> [a1]) -> f [a1]
08:44:23 <shachaf> instance Show (a -> b) where show = disassemble . unsafeAddrOf
08:44:24 <ksf_> there should be a show that actually pretty-prints stuff, and a serialise which can generate ebml, xml, humanly-readable, whatever you want.
08:44:31 <ClaudiusMaximus> > sum{- old version -}[92.970,93.462,93.138] / sum{- new version -}[2.894,2.91,2.901] -- hooray, using a better algorithm gave me massive speed gains
08:44:31 <lambdabot>   32.11602527283171
08:44:43 <Saizan> hpc: yeah, for debuggers you'd like all sorts of evil things, like a way of printing some representation even for polymorphic types with no Show context
08:45:07 <ksf_> that, too.
08:45:17 <ksf_> I'd call that reflection, though.
08:45:37 <paolino> :t \n f -> foldM (\x _ -> f x) [] [1..n]
08:45:38 <lambdabot> forall b (m :: * -> *) a. (Num b, Enum b, Monad m) => b -> ([a] -> m [a]) -> m [a]
08:45:40 <ksf_> sounds like a case for an automatically-derived magic typeclass.
08:45:58 <hpc> i remember back when i was in high school learning java, and we "invented" first-class functions with reflection
08:46:03 <Saizan> i think it sounds like a case for some tool that let you navigate the heap :)
08:46:10 <ksf_> doing all that reify-graph stuff and everything.
08:46:46 <ksf_> I think such a tool should come as a library with the compiler
08:46:57 <Saizan> pausing the mutator to do it interactively, etc..
08:47:18 <paolino> :t \n f y -> foldM (\x _ -> f x) y [1..n]
08:47:19 <lambdabot> forall a b (m :: * -> *). (Num b, Enum b, Monad m) => b -> (a -> m a) -> a -> m a
08:47:27 <ksf_> manually messing with the result of strictness analysis.
08:48:47 <Saizan> hpc: with reflection?
08:48:55 <jonkri> if i want to send the same events to multiple threads, should i then iterate over a list of chan everytime i want to write to the chans? (creating something like "writeChans") or should i use something other than chans?
08:48:56 <hpc> Saizan: iirc, yes
08:49:23 <hpc> to pass static Method objects around
08:49:31 <Saizan> ah, i see
08:49:41 <Saizan> jonkri: you could use dupChan
08:49:47 <hpc> it was horribly verbose lol
08:49:47 <paolino> :t \n f y -> take n . iterate f $ y
08:49:47 <paolino> :t \n f y -> foldM (const . f) y [1..n]
08:49:48 <lambdabot> forall a. Int -> (a -> a) -> a -> [a]
08:49:48 <lambdabot> forall b (m :: * -> *) a. (Num b, Enum b, Monad m) => b -> (a -> m a) -> a -> m a
08:49:59 <hpc> but we were graded by number of lines, for whatever reason
08:50:38 <Saizan> ..that's even more disturbing than paid by number of lines
08:50:44 <ksf_> hpc, you don't need reflection for first-class functions.
08:50:54 <ksf_> objects are sufficient closures.
08:51:21 <Saizan> Method is already a generic function object
08:51:22 <hpc> ksf_: probably; we were in our second year of programming at that point though
08:51:35 <ksf_> foo.registerHandler( new FooBazHandler { void handleFoo { ... } } );
08:51:36 <Saizan> why create another?:)
08:52:55 <ksf_> though at least back in the days there where people that considered anonymous classes a misfeature.
08:53:26 <ksf_> and at work I was strictly forbidden to use such stuff, anyway.
08:53:40 <paolino> is there an alternative way to foldM on a finite list ignoring its contents, to define "\n f y -> foldM (const . f) y [1..n]" ?
08:53:54 <ksf_> we had our preprocessor that stuffed all code into exactly one midlet and one canvas.
08:54:25 <ksf_> when we wanted callbacks, we wrote tiny trampolining interpreters.
08:54:47 <ksf_> nothing beats having to code java without using objects...
08:55:13 <hpc> paolino: what type do you want?
08:55:14 <ksf_> imagine C without structs, that comes close.
08:55:19 <hpc> ksf_: eeew
08:55:25 <ksf_> only that you don't have unsigned types, either.
08:55:34 <revenantphx> ksf_: sounds pretty derp
08:55:44 <hpc> man, at least C has function pointers
08:56:03 <revenantphx> hpc: and closures with an extension :)
08:56:07 <ksf_> well, it was due to technical limitations.
08:56:20 <hpc> C extensions sound even eviler than haskell extensions
08:56:28 <ksf_> running java on handsets, back then, wasn't a sane technological decision.
08:56:31 <paolino> hpc_ : I think, b -> ([a] -> m [a]) -> m [a]
08:56:32 <hpc> the language already has enough undefined behaviors :P
08:56:39 <revenantphx> hpc: http://clang.llvm.org/docs/Block-ABI-Apple.txt
08:56:42 <revenantphx> It's pretty well defined there.
08:56:59 <revenantphx> I've personally fucked with this a lot manually,
08:57:05 <ksf_> and when it comes to core game code, the proper way to go is writing a non-TC lisp, anyway...
08:57:05 <revenantphx> and I can confirm its all as it says.
08:57:29 <revenantphx> hpc: we're on the same side of the split.
08:57:30 <revenantphx> :)
08:57:30 <hpc> paolino: what is b doing in that type? it can't be used for anything
08:57:33 <hpc> :D
08:57:42 <revenantphx> This is the cool side.
08:58:21 <revenantphx> hpc: it could be doing something like changing how many times [a] -> m [a] is applied...
08:58:24 <revenantphx> or something like that.
08:58:39 <hpc> not with that much polymorphism
08:58:48 <hpc> :t forM_
08:58:48 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
08:58:54 <hpc> :t forM
08:58:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
08:59:06 <hpc> :t sequence
08:59:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:59:18 <paolino> hpc: maybe it remembers too much a for loop :) It's impossible in haskell 
09:00:06 <hpc> @hoogle Int -> m a -> m [a]
09:00:07 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
09:00:07 <lambdabot> Text.ParserCombinators.ReadP count :: Int -> ReadP a -> ReadP [a]
09:00:07 <lambdabot> Prelude drop :: Int -> [a] -> [a]
09:00:23 <paolino> :t \n f y -> sequence . take n . iterate f $ y
09:00:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (m a -> m a) -> m a -> m [a]
09:02:07 <paolino> :t \n f y -> sequence . take n . iterate (>>= f) $ y
09:02:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (a -> m a) -> m a -> m [a]
09:02:34 <paolino> :t \n f y -> sequence . take n . iterate (>>= f) $ return y
09:02:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> (a -> m a) -> a -> m [a]
09:02:48 <jystic_> Does anyone know if it is possible to automatically derive 'Arbitrary' instances for QuickCheck?
09:04:37 <Saizan> the derive package on hackage does, with TH
09:05:44 <jystic_> Saizan: great! thanks, i'll take a look
09:08:53 <paolino> :t \n f -> foldM (const . f) [] [1..n]
09:08:53 <paolino> this is correct
09:08:54 <lambdabot> forall b (m :: * -> *) a. (Num b, Enum b, Monad m) => b -> ([a] -> m [a]) -> m [a]
09:09:31 <nihtml> :t const
09:09:32 <lambdabot> forall a b. a -> b -> a
09:11:08 <dfilimon> hi guys, i'm having trouble with some nested list comprehensions
09:11:17 <dfilimon> [http://hpaste.org/45532/diag_elems]
09:11:35 <dfilimon> and also: [[(board b) ! (i, i + d) | i <- [k..k + 3]] | k <- [1..(9 - d - 3)], d <- [1..5]]
09:11:47 <dfilimon> i'm trying to generate all lists of 4 elements
09:12:01 <dfilimon> on diagonals parallel to the main one
09:12:18 <dfilimon> i think i nailed the formula
09:12:31 <dfilimon> however it says that 'd' is not in scope
09:13:04 <ClaudiusMaximus> k depends on d, but d is afterwards
09:13:54 <dfilimon> :)
09:13:56 <dfilimon> oh...
09:14:07 <dfilimon> i thought that's the way it was supposed to work
09:14:11 <dfilimon> roght
09:14:16 <dfilimon> thanks :D
09:26:43 <sordina> Hey. Why does quick check run tests with no parameters multiple times?
09:29:08 <Saizan> probably because not many people pass it tests with no parameters
09:30:03 <dfilimon> how do i un-import a module in ghci?
09:30:16 <Saizan> "unit tests" are done with "HUnit" maybe, or some of the other test frameworks wrapping over QuickCheck (and possibly HUnit ?)
09:30:23 <shachaf> @scheck True
09:30:23 <lambdabot>   "OK, passed 500 tests."
09:30:52 <Saizan> dfilimon: there's :m - ThatModule, iirc
09:30:57 <shachaf> Oh, er, @scheck doesn't actually exist.
09:31:09 <dfilimon> excellent, thanks!
09:31:35 <kuznero> Hi All!
09:31:50 <dmwit> howdy
09:32:47 <kuznero> Short question regarding Data.ConfigFile... why do I get error when running in GHCi: readfile emptyCP "filename"
09:32:47 <dfilimon> hello!
09:32:48 <kuznero> <interactive>:1:8:
09:32:48 <kuznero>     No instance for (MonadError CPError m0)
09:32:48 <kuznero>       arising from a use of `readfile'
09:32:48 <kuznero>     Possible fix:
09:32:49 <kuznero>       add an instance declaration for (MonadError CPError m0)
09:32:51 <kuznero>     In a stmt of an interactive GHCi command:
09:32:53 <kuznero>         val <- readfile emptyCP "sample.cfg"
09:33:00 <dmwit> In future, please use an online past service, don't paste in-channel.
09:33:06 <dmwit> hpaste is popular for this.
09:33:14 <kuznero> ok, great, tnx!
09:35:29 <Saizan> kuznero: you've to annotate it to tell what 'm' should be, since readfile :: MonadError CPError m => ConfigParser -> FilePath -> IO (m ConfigParser)
09:35:34 <dmwit> Perhaps you'd like to import Control.Monad.Error or Control.Monad.Instances (depending on which version of GHC you have).
09:36:18 <kuznero> All imports are in place: Prelude Control.Monad.Error Data.ConfigFile>
09:36:56 <kuznero> Why do I need Instances?
09:37:29 <kuznero> same error with or without instances.
09:37:45 <kuznero> Saizan, I don't quite understand. Could you show an example?
09:37:47 <Saizan> val <- readfile emptyCP "sample.cfg" :: IO (Either CPError ConfigParser)
09:39:23 <kuznero> Saizan, thanks. That works. So, what was the issue here? (MonadError CPError m) vs (Either CPError ConfigParser)?
09:40:00 <Saizan> kuznero: the issue was that it didn't know which type to pick for 'm'
09:40:34 <Saizan> kuznero: readfile works for any 'm' for which an instance of "MonadError CPError m" exists
09:40:58 <Saizan> kuznero: (Either CPError) is one, but there are others, and ghci won't guess one for you
09:41:32 <Saizan> the error message could be phrased better though.
09:42:09 <kuznero> Saizan, ah... so that's because MonadError is just a typeclass but not exact implementation. That is why I needed to define something concrete?
09:42:41 <Saizan> kuznero: yeah
09:43:13 <Saizan> you can't run code if you only know the interface, you also need to know which implementation of the interface you want to use
09:43:14 <kuznero> Saizan: and that also means that Either should implement MonadError, right? That is not easy to figure out just by looking at code...
09:43:38 <merijn> kuznero: "Either e" needs to implement MonadError, yes
09:44:09 <kuznero> merijn: correct, one type parameter for monads :) thanks
09:44:16 <kuznero> Saizan: thanks for help!
09:44:45 <Saizan> kuznero: tbf, the examples here mention Either and ErrorT http://hackage.haskell.org/packages/archive/ConfigFile/latest/doc/html/Data-ConfigFile.html#g:9
09:46:15 <kuznero> Saizan: Yeah, now it's more clear when I see that type is inferred from later usage - in one case Either and in other ErrorT
09:46:18 <kuznero> Thanks!
09:47:58 <merijn> Can someone point out something other then -> which is an instance of Arrow?
09:48:34 <Saizan> yampa
09:48:47 <Saizan> some parser combinators
09:48:57 <Saizan> not much more :)
09:49:03 <merijn> I guess that's yet another reason to look at yampa
09:50:41 <aristid> hmm, i guess enumerators could be said to be arrows, albeit without having an actualy instance
09:51:17 <merijn> Yeah, enumerators seemed like arrows when I read about them. But then I'm not sure I understand enumerators either :p
09:51:49 <luite_> hxt also uses them
09:53:43 <haskellnoob> test
09:53:53 <sipa> test
09:53:57 <aristid> merijn: i'm not sure if i understand enumerators fully, but i think i can use them :D
09:55:03 <aristid> their parameter is an acceptor for output
09:55:23 <aristid> so they effectively output data streams
09:57:16 <Egbert9e9> so i'm in front of ghci typing in data.
09:57:34 <Egbert9e9> and i want to use getLine to type in a list of strings
09:57:39 <haskellnoob> Hello guys. I am new to haskell and in need of advice. In main, I have to get the contents of some files into a string. I succeeded with that, but there are two cases. If the first is true I have to run a certain block of IO code to get the data. If the first is false I have to run another block of IO code to get the data. What is the right way to do it? I know C++ but I'm not sure it should be the same here, am I wrong?
09:58:10 <haskellnoob> I tried with if then else but something messed up.I got errors like "the last statement in a do block must be an expression"
09:58:23 <mauke> sounds like you got your indentation wrong
09:58:30 <Egbert9e9> instead of actually writting a [String] i want to use getLine and press Enter between each list item
09:58:31 <hpc> haskellnoob: x <- if cond then act1 else act2
09:59:03 <hpc> i assume you are ending the then/else blocks with x <- thing, which isn't valid
09:59:30 <haskellnoob> hpc: how do I tell ghc that act1 is one block? are there any parenthesis required?
09:59:54 <haskellnoob> mauke: I converted all of the tabs to spaces but it didn't help. I couldn't find anything.
10:00:13 <hpc> haskellnoob: you use indentation; i don't use if-then-else much, and am working on other things atm
10:00:18 <haskellnoob> hpc: I am ending the block with it
10:00:20 <hpc> so can't make an example
10:00:21 <merijn> haskellnoob: Could you paste your code on hpaste.org?
10:01:16 <haskellnoob> merijn: sure. one moment.
10:03:51 <haskellnoob> merijn: I have pasted it. it's number is #45535
10:03:59 <haskellnoob> merijn: should I supply a link?
10:04:07 <merijn> Yeah
10:04:13 <hpc> haskellnoob: yes; we don't have all the pastebin urls memorized ;)
10:04:14 <haskellnoob> http://hpaste.org/45535/if_then_else_help
10:04:34 <mauke> remove 'vmCode <-'
10:05:14 <haskellnoob> where should I put it then? I mean, where would the result go?
10:05:25 <merijn> haskellnoob: Yeah, a do block will automatically return the last line as its result
10:05:34 <mauke> nowhere, you don't use vmCode anyway
10:05:39 <merijn> Well, where do you expect vmCode to go?
10:05:54 <dmwit> If you change your mind and actually want to use vmCode, then you should do something like
10:06:08 <dmwit> vmCode <- if doesDirectoryExist source then readThisFile else readThatFile
10:06:19 <dmwit> i.e. lift the vmCode binding out of the if
10:06:37 <dmwit> (Bindings made in a do-block only last to the end of that block, anyway.)
10:07:18 <haskellnoob> mauke: oh, excuse me but I have a mistake there. The last "source" should be "vmCode" I haven't compiled it so I missed that. I translate the string vmCode with the function "translate"
10:07:46 <merijn> haskellnoob: As dmwit says, you want to store the result of the if in vmCode then, then use vmCode in your last line
10:08:03 <merijn> As a consolation: It's not you btw, I still think do-blocks are confusing :p
10:08:42 <merijn> I prefer writing without do-sugar (but maybe that'll change when I write longer blocks...)
10:08:43 <tswett> What are the indentation rules for if statements?
10:08:57 <dmwit> if does not start a block
10:09:01 <dmwit> That is the rule.
10:09:01 <hpc> merijn: without do, some things become a lot of typing
10:09:11 <hpc> a LOT
10:09:11 * tswett nods.
10:09:17 <mauke> tswett: if statements have no indentation rules
10:09:26 <merijn> hpc: I know, that's why I said I might change opinion when I start writing less trivial monad code
10:09:41 <dmwit> tswett: I guess you mean, how do you indent "if" properly inside another block?
10:10:02 <dmwit> tswett: Then the answer is: if you put "then" at the same indentation level as "if", it will think it is a new line in the block, and will not associate it with the "if".
10:10:39 <haskellnoob> Thank you all for the answer! I am trying it now.
10:12:53 <b0fh_ua> Hello! I have GHC version 7.0.2 installed, and datetime package complains now that it wants base <4
10:13:18 <b0fh_ua> what are the options to deal with this error - install base-3 somehow, update datetime or something else?
10:13:31 <monochrom> is datetime that old?
10:13:47 <dmwit> Probably the easiest is updating the dependencies in datetime's cabal file and giving it a shot.
10:14:47 <monochrom> yeah, it doesn't use exceptions, so it should work with base 4 just fine
10:14:50 <b0fh_ua> dmwit: that will work for me, but not for somebody else - they will have to update dependency as well
10:15:47 <monochrom> last upload was just a year ago. I wonder why the author didn't bother to relax to base <= 4
10:16:13 <b0fh_ua> okay, then it is better to not use this package. What are the alternatives?
10:16:20 <b0fh_ua> Data.Time ?
10:16:23 <monochrom> it was not like the obsoletion of base 3 was unknown in january 2010
10:18:27 <monochrom> well depends on what you used to use from datetime. the gregorian things and julian things are already there in time, just more scattered. the tosqlstring thing is probably hard to find elsewhere (unless you go all out to add a sql package)
10:19:22 <monochrom> alternatively find someone to upload a relaxed version (does not have to be the author; anyone with a hackage account can do it)
10:19:31 <tswett> dmwit: ah.  Thank you.
10:19:45 <b0fh_ua> aha
10:19:51 <b0fh_ua> monochrom: than I will do that :)
10:20:01 <dmwit> If it compiles, send the maintainer a patch and call it a day.
10:20:01 <dmwit> DateTime looks like a pretty thin wrapper around the real Data.Time interface though; why not just use that?
10:20:01 <dmwit> Oh, never mind, there does seem to be some interesting stuff.
10:20:01 <dmwit> toSqlString/fromSqlString
10:21:12 <monochrom> alternatively, this is a one-module package. just copy the source code and include in your own package or source code. mind the GPL though. credit the guy and GPL your stuff. :)
10:21:20 <dmwit> b0fh_ua: Send him a patch, and depend on a newer version than is on Hackage...?
10:22:13 <b0fh_ua> dmwit: may I just upload patched version to hackage?
10:22:27 <dmwit> I suppose so, but you should still tell the maintainer. =)
10:22:36 * dmwit shudders at Hackage's security model
10:23:04 <b0fh_ua> sure thing
10:23:22 <monochrom> https://github.com/esessoms/datetime is a 404
10:23:25 <b0fh_ua> btw the question - how to convert Word32 to LocalTime is still open :)
10:23:38 <tswett> Is Hackage wiki-like?
10:23:49 <monochrom> and https://github.com/esessoms/ still exists, and no longer lists the datetime repo.
10:24:02 <shachaf> dmwit: At Hackage's what?
10:24:33 <dmwit> shachaf: exactly
10:25:22 <monochrom> it seems to me the author has abandoned the package
10:25:30 <Eduard_Munteanu> time-1.1.4.1 - Reverted vandalism :P
10:26:27 <dmwit> b0fh_ua: D.T.Localtime has half a dozen different functions for creating TimeOfDay values and Day values. Pick which one you like, I guess.
10:26:59 <Eduard_Munteanu> It's a bit like Firefox's addon repository.
10:27:16 <dmwit> b0fh_ua: e.g. timeToTimeOfDay :: DiffTime -> TimeOfDay, so timeToTimeOfDay . fromIntegral :: Word32 -> TimeOfDay
10:28:06 <Eduard_Munteanu> Or like Sourceforge, except people go installing random packages from it with a cmdline utility.
10:29:13 <ksf__> anyone know of a cabal package that comes with a Makefile?
10:29:23 <dmwit> ksf__: X11, I think
10:29:36 <ksf__> (that doesn't belong to merely included upstream C code)
10:29:44 <monochrom> oh haha, the damge is done, b0fh_ua's upload has appeared!
10:30:47 <ksf__> doesn't look like it.
10:30:52 <ksf__> it uses autoconf, yes.
10:30:56 * tswett begins to regret his decision to write a function that takes two sorted lists and returns a sorted version of their Cartesian product.
10:31:01 <dmwit> whoops, sorry
10:31:24 <tswett> While evaluating as little as possible.
10:31:34 <dmwit> > liftM2 (,) [1..5] [3..9]
10:31:35 <lambdabot>   [(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(2,3),(2,4),(2,5),(2,6),(2,7),(2...
10:31:35 <Eduard_Munteanu> Hrm, I was going to say Agda, but I only know about the standard lib's makefile.
10:31:43 <dmwit> tswett: ?
10:31:43 <Eduard_Munteanu> (which is a separate pkg)
10:32:49 <tswett> Suppose the first list begins with [18, 15, 10], and the second list begins with [7, 6, 2].  You know your output is going to begin with... uh...
10:33:03 <tswett> > liftM2 (+) [18,15,10] [7,6,2]
10:33:04 <lambdabot>   [25,24,20,22,21,17,17,16,12]
10:33:21 <dmwit> > liftM2 (,) [18, 15, 10] [7, 6, 2]
10:33:22 <lambdabot>   [(18,7),(18,6),(18,2),(15,7),(15,6),(15,2),(10,7),(10,6),(10,2)]
10:33:34 <tswett> With [25,24,22,21,20], I think.
10:33:50 <dmwit> Oh, that's something more interesting than a Cartesian product, then.
10:33:54 <tswett> So if someone only requests the first 5 elements of the output, you only have to calculate the first 3 elements of each input.
10:34:13 <dmwit> Or rather, the ordering you're using is more interesting than the lexicographical ordering.
10:34:22 <tswett> Well, it's a maximally lazy version of sort $ liftM2 (+) x y.
10:34:58 <dmwit> > sort $ liftM2 (+) (18:15:10:undefined) (7:6:2:undefined)
10:34:59 <lambdabot>   *Exception: Prelude.undefined
10:35:13 <tswett> > head $ sort $ liftM2 (+) (18:15:10:undefined) (7:6:2:undefined)
10:35:14 <lambdabot>   *Exception: Prelude.undefined
10:35:15 <dmwit> Ah, I see, yes.
10:35:25 <tswett> You can calculate the first 5 elements of that, I think.
10:35:50 <dmwit> :t merge
10:35:51 <lambdabot> Not in scope: `merge'
10:36:22 <ksf__> epic comes with one.
10:37:06 <ksf__> too simplish, though.
10:37:10 <tswett> Are you talking about the coffee house, the medical systems company, the poetry format, or the criteria for morphisms?  :P
10:37:22 <augur> coffee! \o/
10:37:37 <dmwit> > let merge (x:xs) (y:ys) | x > y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs ys = xs ++ ys; sums (x:xs) ys = merge (map (x+) ys) (sums xs ys); sums [] ys = ys in sums [18,15,10] [7,6,2]
10:37:39 <lambdabot>   [25,24,22,21,20,17,17,16,12,7,6,2]
10:37:46 <augur> morphism is a gateway drug to heroism
10:37:49 <augur> or something
10:37:52 <dmwit> > let merge (x:xs) (y:ys) | x > y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs ys = xs ++ ys; sums (x:xs) ys = merge (map (x+) ys) (sums xs ys); sums [] ys = ys in sums (18:15:10:undefined) (7:6:2:undefined)
10:37:54 <lambdabot>   *Exception: Prelude.undefined
10:38:04 <ksf__> tswett, I'm talking about the virtual machine
10:38:09 <dmwit> Argh, yes, again.
10:38:17 <dmwit> Neat problem. =)
10:38:18 <ksf__> or, rather, compiler backend.
10:38:29 <ksf__> idris uses it
10:38:38 <ksf__> and epigram too, probably
10:39:32 <ksf__> a truly epic project would be to do any of the haskell compiler's build system
10:40:14 <ksf__> oh, gf.
10:40:16 <tswett> dmwit: well, it's not going to work unless you say "take 5".
10:40:32 <tswett> > let merge (x:xs) (y:ys) | x > y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs ys = xs ++ ys; sums (x:xs) ys = merge (map (x+) ys) (sums xs ys); sums [] ys = ys in take 5 $ sums (18:15:10:undefined) (7:6:2:undefined)
10:40:34 <lambdabot>   *Exception: Prelude.undefined
10:40:42 <tswett> > let merge (x:xs) (y:ys) | x > y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys; merge xs ys = xs ++ ys; sums (x:xs) ys = merge (map (x+) ys) (sums xs ys); sums [] ys = ys in take 3 $ sums (18:15:10:undefined) (7:6:2:undefined)
10:40:44 <lambdabot>   *Exception: Prelude.undefined
10:40:57 <dmwit> tswett: Nonsense. See:
10:41:02 <dmwit> > (5:4:3:2:1:undefined)
10:41:03 <lambdabot>   [5,4,3,2,1*Exception: Prelude.undefined
10:41:09 <dmwit> It works as hard as it can. =)
10:41:09 <tswett> Oh, you're right.
10:43:22 <dmwit> Well, I've got one that works as long as one of the two lists has no undefined in it. =)
10:47:03 <byorgey> might require something like unamb to implement with maximal laziness.
10:47:19 <dmwit> Yep, I needed unamb even to get as far as the one I suggested.
10:48:13 <tswett> Huh.  What happens if you do "unamb True False"?
10:48:33 <dmwit> undefined behavior
10:48:34 <tswett> Oleg appears and beats you with a stick?
10:49:11 <ezyang> You'll get either True or False. 
10:49:18 <ezyang> but then it will stay that way. Maybe. 
10:49:34 <ezyang> "Don't do it" 
10:49:38 <tswett> So it's the Oleg thing.  Got it.
10:50:22 <tswett> @index unamb
10:50:22 <lambdabot> bzzt
10:50:30 <tswett> What module is it in?
10:50:47 <dmwit> Ah! Here's a key insight, I think: sums (x:xs) (y:ys) always starts with x+y.
10:50:50 <tswett> Here we go, Data.Unamb.
10:50:54 <akahn> The httpLbs function in http-enumerator takes a Manager argument, but the newManager function returns an IO Manager. How can I get a manager from this?
10:50:55 <dmwit> Let's see here.
10:51:08 <tswett> I think I know how to write it; I just don't know how to write it quickly and easily.  :P
10:51:19 <tswett> I'm assuming that x and y will always be small.
10:51:30 <Botje> akahn: newManager >>= \manager -> ...
10:51:35 <Botje> akahn: welcome to the IO monad :)
10:51:48 <tswett> So I'm essentially starting with x+y, and seeing if each value in [x+y..0], in turn, is in the output.
10:53:26 <akahn> Botje: great, thank you
10:55:19 <akahn> now, to learn about exceptions ;) (*** Exception: error received: Error_Packet "invalid type") but at least my request was made!
10:56:16 <Botje> @hoogle catchIO
10:56:16 <lambdabot> Network.HTTP.Base catchIO :: IO a -> (IOException -> IO a) -> IO a
10:56:16 <lambdabot> Network.HTTP.Base catchIO_ :: IO a -> IO a -> IO a
10:58:10 <dmwit> tswett: http://hpaste.org/45540/finding_sums_in_order
10:58:48 <dmwit> *Main> sums (-7: -6: -2:undefined) (-18: -15: -10:undefined)
10:58:50 <dmwit> [-25,-24,-22,-21,-20*** Exception: BothBottom
10:59:49 <dmwit> tswett: Not bad, eh?
10:59:53 <tswett> Awesome.  :)
10:59:59 <tswett> Thank you.
11:05:56 <haskellnoob> Hello again. You really helped me with the if-else thing. I have another question if I may ask. Here is the whole code for reference http://hpaste.org/paste/45539/moreproblems_annotation#p45541  It is my first Haskell program so you might find weird things there :).  I get the following error from ghc: :12:32: Couldn't match expected type `IO t0' with actual type `[Char]' Expected type: IO t0 Actual type: String .   Can you plea
11:06:38 <dmwit> perhaps you meant "liftM unlines (mapM ...)"
11:07:52 <haskellnoob> dmwit: No chance I meant that :) I didn't know about this function before you mentioned it. I will read about it now.
11:08:42 <Botje> unlines returns a [Char] where your IO monad block expects IO something
11:09:11 <Botje> if you fix that, the second error will complain about giving unlines an [IO String] where it expects [String]
11:09:24 <Botje> (make that IO [String])
11:10:20 <Botje> haskellnoob: so you have unlines :: [String] -> String, which you want to give an IO [String] and get back a IO String
11:10:33 <Botje> that's what liftM does, it trnasforms [String] -> String to IO [String] -> IO String
11:11:47 <applicative> fmap would be a little friendlier than liftM
11:11:57 <haskellnoob> Botje: Ah thank you!
11:12:13 <haskellnoob> dmwit: Thank you! it works.
11:12:14 <applicative> fmap unlines (mapM readFile files)
11:13:08 <haskellnoob> I have to seriously learn monads..
11:13:31 <applicative> it looks like you are doing well
11:13:33 <haskellnoob> last time I stopped at the category theory thing
11:13:38 * dmwit finds the fmap/liftM/<$$*#whatever debate somewhat humorous
11:13:40 <haskellnoob> :)
11:13:45 <byorgey> you don't need to learn category theory to learn about monads.
11:13:48 <Peaker_> haskellnoob, You can understand "fmap" and "liftM" and "mapM" for the IO case specifically and learn the Monad generalization only later
11:14:09 <ion> haskellnoob: You were reading the wrong thing.
11:14:14 <Peaker_> haskellnoob, it's probably better to first understand a couple of specific examples before understanding a generalization
11:14:18 <dmwit> Learning several specific monads before learning about the monad generalization: highly recommended.
11:14:42 <haskellnoob> sounds encouraging
11:14:53 <akahn> hm, looks like my HTTP request actually isn't being made, but rather the error is happening somewhere else
11:14:56 <applicative> his trouble here was with IO as Functor, that's why I mentioned fmap
11:15:23 <byorgey> haskellnoob: do you know about Functor?  if not you should learn about that before learning about monads anyway.
11:16:17 <haskellnoob> byorgey: This is the chapter in lyah I am starting to read right now. It is simply long and I didn't read it yet
11:16:33 <byorgey> ok =)
11:17:30 <haskellnoob> This community is life savior. Maybe it is more correct to say haskell noobs savior.
11:17:41 <haskellnoob> so many good people here
11:19:21 <dct25> Hi all, I'm having some trouble understanding how hexpat d
11:19:25 <dct25> eals with namespaces
11:19:51 <dct25> it seems to put attributes without namespace prefixes into the default namespace
11:20:15 <dct25> e.g. <t:foo xmlns:t='http://www.example.com' attr='bar'/> becomes ... t:attr='bar'/>
11:21:25 <dct25> sorry, ignore the word 'default' above - just namespaces
11:21:41 <dct25> I've put some failing tests at http://hpaste.org/45523
11:21:52 <dct25> is it just my understanding that's flawed?
11:22:44 <Eduard_Munteanu> :t runST
11:22:44 <lambdabot> forall a. (forall s. ST s a) -> a
11:22:52 <tswett> @source all
11:22:52 <lambdabot> all not available
11:24:10 <dfilimon> do you know of any way of breaking out of a function?
11:24:16 <dfilimon> say, i'm in a let
11:24:17 <dfilimon> doing a fold
11:24:29 <dfilimon> and suddenly i realize that there's no need to go on
11:24:40 <Zao> throw?
11:24:43 <dfilimon> and i'd like to break and return a value
11:24:48 <Saizan> which fold?
11:25:01 <Saizan> if it's foldr you just have to return it
11:25:06 <dfilimon> does it matter which fold?
11:25:18 <dfilimon> i'd like something akin to an imperative return
11:25:20 <Saizan> yeah, foldl will consume the whole list no matter what
11:25:24 <ksf__> shake is great.
11:25:31 <ion> ErrorT
11:25:49 <dfilimon> well, not an error really, just an ordinary value
11:25:53 <ion> Or just Either
11:25:54 <ksf__> two major gripes, though: the Oracle environment isn't inferred, and oracle dependencies are bugged.
11:25:54 <Saizan> there is nothing like an imperative return unless you're willing to use IO or some other monad with exception-like behaviour
11:26:46 <dfilimon> i see
11:26:55 <dfilimon> well, that's that
11:27:01 <Saizan> but you could make use of lazy evaluation
11:27:03 <ksf__> ...and I say that as someone who has experienced omake first-hand
11:27:12 <c_wraith> you can usually structure your computation to not need an explicit return.
11:27:14 <Saizan> depending on which fold you're using.
11:27:17 <cheater99> what is exception-like behaviour?
11:27:34 <dmwit> non-local control flow
11:27:42 <ksf__> which is great, but has the major disadvantage of using an informally-specified dialect of (impure!!) ML.
11:27:43 <dfilimon> i was thinking more along the lines of beta-cutoff in alpha-beta pruning
11:28:07 <dfilimon> if the new score is greater than beta
11:28:07 <xplat> what is a good library for writing simple curses-style console apps in haskell?
11:28:10 <dfilimon> i can simply return
11:28:13 <ksf__> return is an artifact of do-notation, mostly.
11:28:36 <c_wraith> dfilimon: sure.  You can do the same thing.  Instead of recursive further, just provide a result
11:28:44 <c_wraith> err, *recursing further
11:28:45 <dfilimon> but return doesn't actually return, it just applies a monad to a normal value... right?
11:28:50 <dmwit> ?hackage ncurses
11:28:50 <lambdabot> http://hackage.haskell.org/package/ncurses
11:28:52 <dfilimon> well c_wratith, i would
11:28:56 <dmwit> xplat: ?
11:28:58 <ksf__> one can't apply a monad, but, yes.
11:28:59 <dfilimon> but this is inside a let
11:29:03 <dct25> dfilimon: foldM in the Maybe monad would work wouldn't it?
11:29:10 <ksf__> think of injecting a value into a monad.
11:29:11 <Confusionist> I'm sure this function already exists somewhere, but I can't seem to find it: zippedWithIndex xs = zip [1..length(xs)] xs
11:29:15 <Saizan> dfilimon: show the code, please
11:29:19 <dct25> return Just something if you want to continue and Nothing if not
11:29:23 <Botje> Confusionist: just zip [1..] xs
11:29:27 <Botje> no need to grab the length
11:29:29 <xplat> dmwit: well, yeah, but i figured that was probably kind of low-level
11:29:37 <Saizan> dfilimon: we're just generating confusion otherwise
11:29:41 <xplat> and that people might have other recs
11:29:49 <c_wraith> dfilimon: which is why I said "maybe with restructuring the code".  As Saizan suggested, put the code on a pastebin, and we'll take a look
11:29:53 <ksf__> the founding fathers of haskell named the function "return" as to confuse newbies.
11:29:53 <Confusionist> Botje: Of course, thanks
11:29:53 <rothwell> :t lift
11:29:54 <lambdabot>     Ambiguous occurrence `lift'
11:29:54 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
11:29:54 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
11:30:02 <dfilimon> gere it is
11:30:04 <dfilimon> *here
11:30:05 <dfilimon> http://hpaste.org/45543/negamax
11:30:15 <c_wraith> I hate that lambdabot is giving that error message, as those are the same lift
11:30:16 <ksf__> in the same way that germans always confuse to become and to get/have
11:30:20 <ion> > let goodComputation = return "ok"; bail = throwError "meh" in do goodComputation; goodComputation; bail; goodComputation :: Either String String
11:30:21 <lambdabot>   Left "meh"
11:30:22 <ksf__> "I'm becoming a baby"
11:30:33 <dmwit> xplat: Well, you might consider binding to Gaim's GUI library.
11:30:49 <dfilimon> so, what i'm doing now
11:31:18 <dfilimon> is getting through a triplet (Int, Int, Bool) = (position, score, stop?)
11:31:45 <xplat> anyway besides ncurses there's also hscurses and nanocurses
11:31:45 <dfilimon> and i do the cutoff by continuing the fold with stop set to True
11:32:02 <dfilimon> but... i'd like to just terminate the whole thing
11:32:31 <c_wraith> dfilimon: You're really close to terminating the whole thing anyway, except you're not quite lazy enough.
11:32:37 <c_wraith> dfilimon: given that it's using foldr
11:33:09 <xplat> yeah, it's easy to bail out of a foldr early if your step function is lazy enough
11:33:23 <dfilimon> what does that mean exactly?
11:33:28 <dfilimon> could you please elaborate?
11:33:50 <xplat> dfilimon: you can bail out of a foldr at any stage just by not evaluating the accumulator argument
11:34:46 <dfilimon> and... how am i supposed to do that?
11:34:50 <c_wraith> :t foldr
11:34:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:34:50 <dfilimon> i still need
11:34:55 <dfilimon> to ask something, right?
11:34:58 <dfilimon> as in, an if
11:34:59 <xplat> (and not returning it as part of your return value either, because then someone else could evaluate it and start the fold again)
11:35:46 <c_wraith> Uh.  strange.  I'm not sure foldr is actually what you want there.
11:35:54 <xplat> (although letting the caller decide when you bail out can be a good idea too sometimes)
11:36:31 <dfilimon> i chose foldr because it's constant in stack space, (isn't it?)
11:36:35 <c_wraith> As the stop information is propogating the wrong way
11:36:51 <c_wraith> With that step function, it's not constant stack space.
11:36:53 <rostayob> Since exceptions may be catch only in IO, if I have a monad transformer with IO inside, if I want to use stuff like withMVar I have to run the monad transformer, get into IO, and then restart, right?
11:37:12 <dmwit> yep
11:37:17 <dfilimon> well, it's still better than a foldl, right?
11:37:48 <tswett> This line of code I just wrote makes me sad:
11:37:49 <tswett> array ((1, 1), (size, size)) [((x, y), x == y || (x, y) `elem` edges || (y, x) `elem` edges) | x <- [1..size], y <- [1..size]]
11:37:58 <rostayob> dmwit: the yep was for me?
11:38:06 <dmwit> yep
11:38:08 <c_wraith> I suspect this is a case where explicit recursion is easier to get correct than a fold
11:38:15 <xplat> dfilimon: do the nextMoves come in any particular order?
11:38:16 <rostayob> ahah ok, thanks
11:38:25 <dmwit> tswett: Why not use listArray?
11:38:59 <dfilimon> nextMoves for this case (since it's a connect-4 game on a 9x9 board) are simply the moves generated by adding a chip at positions  1..9
11:39:15 <dmwit> tswett: ... and (x,y) <- range ((1,1),(size,size))
11:40:07 <tswett> dmwit: yes, that would work better.  Thank you.
11:40:16 <dfilimon> @tswett, did you also specify exactly what type of array you want created (:: Array (Int, Int) a) ?
11:40:16 <lambdabot> Unknown command, try @list
11:40:46 <tswett> dfilimon: there is a type signature here, yes, if that's what you're asking.
11:41:02 <dfilimon> yes, i needed an explicit one in ghci at some point
11:41:05 <dfilimon> that's why i was asking
11:41:16 <dfilimon> it would give a huge cryptic error without one
11:42:07 <dfilimon> also, i could replace the fold, but i thought the whole point of folds was that they are awesome and should be use :)
11:42:09 <dfilimon> *used
11:42:24 <xplat> okay, so change foldLoop to \(newPos, newMove) (pos, score) -> let (_, newScore) = negamax newMove (nextMove turn) (-beta) (-alpha) (depthLeft - 1) in if newScore >= beta then (newPos, beta) else if newScore > alpha then (newPos, alpha) else (pos, score)
11:42:43 <tswett> I seem to remember a function that gets a line of input and applies "read" to it.  Does that exist, or was I dreaming?
11:42:53 <xplat> dfilimon: i don't think that that will do what you want, but it will do what you're doing, faster
11:42:58 <ddarius_> @hoogle readLn
11:42:58 <lambdabot> Prelude readLn :: Read a => IO a
11:42:58 <lambdabot> System.IO readLn :: Read a => IO a
11:43:06 <tswett> That's it.  Thank you.
11:43:22 * hackagebot ltk 0.10.0 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.10.0 (JuergenNicklischFranken)
11:43:30 <dfilimon> i'll try xplat, thanks
11:44:22 * hackagebot leksah-server 0.10.0 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.10.0 (JuergenNicklischFranken)
11:45:23 <dfilimon> @xplat, but if i use that, won't it _always_ call negamax ?
11:45:23 <lambdabot> Unknown command, try @list
11:45:23 <xplat> dfilimon: oh, and you should put a ~ on the second tuple in what i wrote, like so: ~(pos, score)
11:46:00 <dfilimon> what does that do?
11:46:12 <Philonous> > flip runCont id  . callCC $ \exit -> foldM (\xs x -> if x == 'o' then exit xs else return (xs++[x])) "" "Hello World!"
11:46:12 <c_wraith> I always forget about ~ matches.  So important to remember.
11:46:13 <xplat> dfilimon: that part is actually very important.  also please say 'xplat:' or 'xplat,' instead of @xplat because @splat confuses poor lambdabot :)
11:46:13 <lambdabot>   "Hell"
11:46:22 * hackagebot leksah 0.10.0.0 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.10.0.0 (JuergenNicklischFranken)
11:47:01 <dfilimon> sure xplat, but why is that important again?
11:47:03 <c_wraith> dfilimon: ~ makes the match "irrefutable", which means the compiler doesn't actually check that it matches the pattern until you use one of the variables bound in the pattern.
11:47:28 <c_wraith> dfilimon: In this case, it means that the second argument of the function won't be pattern matched unless you need it.
11:47:42 <c_wraith> dfilimon: which means that it will avoid evaluating the rest of the fold
11:48:20 <Philonous> dfilimon: callCC gives you pure, abortive behaviour.
11:48:20 <dfilimon> that sounds odd... i should probably read up on it to wrap my head around what exactly it does
11:48:25 <c_wraith> I should really say "until you make use of one of the names bound in the pattern"
11:48:29 <c_wraith> @src unzip
11:48:29 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
11:48:36 <dfilimon> ah, i used to love call/cc in scheme :)
11:48:39 <dfilimon> the memories...
11:48:47 <c_wraith> unzip is a good example of where the ~ pattern match is useful
11:49:06 <xplat> of course in the new version it doesn't look inside (pos, score) except to put it right back together into (pos, score), so it could just be called 'answer' and avert the whole issue
11:49:43 <c_wraith> Heh.  That would be better.
11:50:12 <xplat> that's why i don't think the original loop was doing the right thing, though, because it seems like relative scores that are between alpha and beta should matter and they don't
11:50:29 <c_wraith> yeah, I'm pretty sure foldr is the wrong logic anyway
11:50:41 <xplat> no, foldr is fine, the problem is that if nest
11:50:48 <c_wraith> oh, I see what you mean.
11:51:06 <Cale> anyone happen to know offhand if -fwarn-unused-imports will produce its warnings even if ghc is in Makefile generating mode? (-M)
11:51:06 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:51:14 <xplat> the 'stop' accumulator was sort of obscuring the fact, but alpha was actually being treated almost exactly like beta
11:51:21 <Cale> (I will find out soon :)
11:51:31 <kleinucopia> is anyone familiar with hs-twitter?
11:51:41 <dfilimon> you know, you're right
11:51:46 <dfilimon> the origin imperative code
11:51:48 <c_wraith> Cale, can you change lambdabot's imports so that "@type lift" works?
11:51:50 <dfilimon> i'm trying to translate this from
11:51:53 <Cale> @type lift
11:51:54 <lambdabot>     Ambiguous occurrence `lift'
11:51:54 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
11:51:54 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
11:51:57 <Cale> ah
11:51:59 <dfilimon> is supposed to change the value of alpha
11:52:08 <Cale> hmm...
11:52:20 <Cale> @type Control.Monad.Error.lift
11:52:20 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
11:52:37 <Cale> @type Control.Monad.Logic.lift
11:52:38 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
11:52:43 <Cale> ...
11:52:43 <c_wraith> They're both re-exports of Control.Monad.Trans
11:52:46 <Cale> lol
11:52:56 <Cale> If I import Control.Monad.Trans, will it fix it?
11:53:07 <c_wraith> I don't know that much about import behavior.
11:53:38 <Cale> @undef
11:54:01 <Cale> @type lift
11:54:02 <lambdabot>     Ambiguous occurrence `lift'
11:54:02 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
11:54:02 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
11:54:05 <Cale> hmm
11:54:33 <c_wraith> are they different Control.Monad.Trans or something?
11:54:42 <Cale> doubt that...
11:54:51 <Cale> but it would make sense
11:55:05 <c_wraith> well, I've gotta run, but thanks for looking at it
11:55:23 <Cale> @type lift
11:55:24 <lambdabot>     Ambiguous occurrence `lift'
11:55:24 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
11:55:24 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
11:55:27 <Cale> hm
11:55:48 <Cale> I'm always confused about where @type gets its imports
11:56:27 <ddarius> Aren't you the person who sets it?
11:56:55 <jonkri> coming from erlang, i often find myself doing things like this: http://hpaste.org/45545/message_passing ... am i Doing It Wrong? advice on any level is appreciated :)
11:57:00 <Cale> yes
11:57:01 <Eduard_Munteanu> What's a Haskell array that doesn't do any bounds checking?
11:57:08 <Jafet> The dreaded logic error
11:57:14 <Cale> (I'm the person who sets it, but I always forget how it works)
11:57:18 <Eduard_Munteanu> I'm unsure about STUArray.
11:57:34 <Cale> I didn't write it in the first place, and it's a confusing mess.
11:57:43 <Jafet> Eduard_Munteanu: grep "unsafe"
11:58:37 <Cale> jonkri: Not necessarily. That can certainly work.
11:58:56 <Jafet> If you don't like unsafe, oleg has some bounded access embedded proof thing
11:59:02 <Jafet> It's almost comprehensible
11:59:12 <xplat> could just do foldr (\(newPos, newScore) acc@~(pos, score) -> if (newScore > beta || newScore > score) then (newPos, newScore) else acc) (1, alpha) . map (fst &&& snd . \newMove -> negamax newMove (nextMove turn) (-beta) (-alpha) (depthLeft - 1)) $ nextMoves board turn
11:59:27 <ksf__> Eduard_Munteanu, unsafeAt
11:59:29 <xplat> dfilimon: ^^^
11:59:30 <ksf__> that is, any.
11:59:43 <Cale> jonkri: That's basically how Chan was intended to be used. Note that if you want to control read/write access, you can pass (readChan c) to the event loop
11:59:53 <Eduard_Munteanu> Oh, so it works for any array, thanks.
11:59:58 <Cale> (Or writeChan c)
12:00:01 <ksf__> don't look at the haddock, they kept it hidden.
12:00:06 <morphles> is it possible to have something like list, well maybe even lists, but not of some concrete type, but of some typeclass?
12:00:08 <merijn> jonkri: Looks okay to me (bit verbose typenames, but whatever)
12:00:25 <merijn> morphles: Yes
12:00:30 <Cale> morphles: Sort of, what are you trying to achieve?
12:00:30 <dfilimon> xplat, i'll just copy that out of there and take a look
12:00:39 <merijn> But I forgot the syntax, someone will probably remind me soon
12:00:43 <Jafet> @hoogle unsafeAt
12:00:43 <lambdabot> No results found
12:00:45 * Eduard_Munteanu is making some dependently-typed array for Agda, trying to do static bounds check elimination.
12:00:55 <morphles> i dont yet know :), im kinda quite new in haskell, but im contemplating various posiblities :)
12:01:24 <ksf__> letMeImAgdaAt
12:01:37 <Cale> morphles: Usually you want all the values belonging to a list to be of the same type. If there are different types of things going into a list, the least you could do is construct a type big enough to hold them all. :)
12:01:39 <xplat> dfilimon: what i just gave you can probably be further optimized, but maybe not by using foldr
12:01:44 <jonkri> thanks Cale and merijn... :)
12:01:50 <Eduard_Munteanu> Heh.
12:01:56 <Jafet> In der Agda?
12:01:58 <jonkri> are there any alternatives to this way of message passing?
12:02:00 <tswett> Eduard_Munteanu: I didn't know it was possible to mention Agda and bounds checking in the same sentence.  :P
12:02:01 <ddarius> jonkri: You may want to look at CML.
12:02:04 <dfilimon> i updated that part to actually use the newScore too :)
12:02:05 <dfilimon> it was quite silly
12:02:08 <dfilimon> to disregard it
12:02:13 <xplat> but at least it bails out once it finds something better than beta
12:02:14 <Eduard_Munteanu> Yep.
12:02:22 <dfilimon> is &&& an operator or a tyop?
12:02:33 <xplat> &&& is an operator
12:02:36 <dmwit> > (head &&& length) [1, 2, 3]
12:02:37 <lambdabot>   (1,3)
12:02:40 <xplat> you need to import Control.Arrow
12:02:42 <Zao> @src (&&&)
12:02:42 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
12:02:47 <dfilimon> i ah, shiny
12:02:58 <Cale> morphles: If it's supporting all the operations of a typeclass that you want, you can construct an "existential wrapper" which discards the type information apart from the typeclass constraint
12:03:04 <Zao> If your Haskell source looks like it's full of censored curses, you're on the right track.
12:03:11 <morphles> Cale: well suposs id want to make something like rpg, ant it would have items, and items would have various modifiers, so i would want to hook up the list of modifiers to each item, of course all modifiers would be of same typcelass, but not necsasary of same tyme, otho most likely they could just be functions :D
12:03:14 <tswett> jonkri: let me take a look.
12:03:22 <morphles> and since this is fp functions are first oreder
12:03:43 <Cale> morphles: Decide what operations you want items to support, and then make an item be a record consisting of those operations.
12:03:44 <morphles> hm cale that seems interesting
12:03:45 <xplat> morphles: if they're functions they'd probably be of the same type
12:03:56 <Berengal> > let rle = map (head &&& length) . group in rle "aaassdddddfffgg"
12:03:58 <lambdabot>   [('a',3),('s',2),('d',5),('f',3),('g',2)]
12:04:11 <merijn> dfilimon: Read up on the arrow typeclass (I think the Haskell wikibook has a good explanation)
12:04:13 <xplat> like ItemStats -> ItemStats or something
12:04:15 <merijn> dfilimon: Blew my mind :>
12:04:19 <morphles> yeah, i was still being kinda infected with imperative programing :)
12:04:27 <morphles> i store functions and its all cool :D
12:04:47 <Cale> morphles: yeah. In fact, this is the essence of OO programming though, encoded in FP :)
12:04:52 <dfilimon> i was still toying around with monads, arrows seem to be kind of hardcore
12:04:55 <morphles> if i ever get to implement what im thinking about  ill see how this will work
12:05:11 <morphles> Cale: ?
12:05:14 <merijn> dfilimon: Not really, I find Arrows are almost easier then monads
12:05:21 <Cale> morphles: OOP, to me, is all about identifying values with their responses to messages (operations)
12:05:39 <dfilimon> alright, i'll take a look at it soon :)
12:05:40 <dfilimon> thanks
12:05:50 <tswett> dfilimon: arguably, arrows are simpler than monads.  The definition of an arrow has fewer criteria, and the things you can do with an arrow are more straightforward.
12:05:53 <xplat> morphles: basically the record means you pass around a vtable except all the methods are preapplied to 'this'
12:05:54 <morphles> and i dont like that message passing paradigm :)
12:05:54 <Cale> morphles: So rather than a cat, you have a meow and an eat, etc. (all the cat methods/messages)
12:05:57 <merijn> dfilimon: http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
12:06:08 <dfilimon> awesome :)
12:06:09 <merijn> dfilimon: The illustrations really cleared up things for me
12:06:11 <tswett> I like to think of an arrow value as a fluorescent light.  :P
12:06:13 <Eduard_Munteanu> Dang, I'm unsure how to deal with typeclasses.
12:06:28 <Eduard_Munteanu> Damn you Agda for not having them.
12:06:42 <Cale> tswett: Fewer criteria, really?
12:06:48 <xplat> i guess you could sort of call it 'duck subclassing'
12:07:08 <morphles> hm i contrast oop with functional in this way: oop you have earth and moon, and they do stuf to each other to stay in orbit. in fp they are just some stuf on with universal lawas apply :)
12:07:13 <Jafet> morphles: read chapters 2–3 of http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html
12:07:16 <morphles> i have a weird look at this :D
12:07:19 <tswett> Cale: well, every monad forms an arrow, but not vice versa, right?  You can do all of the arrow operations on monads.
12:07:33 <Cale> tswett: Well, weaker criteria, in a sense :)
12:07:40 <morphles> Jafet: thanks
12:08:01 <Cale> But fewer is harder to say, given that there are a whole bunch of arrow methods which need to be related to one another :)
12:08:11 <Cale> (there are 9 arrow laws)
12:08:16 <xplat> it doesn't do anything ducklike on the type level, but as long as you roll up methods of the right type you don't need a 'class', that just becomes a convenience to make a lot of objects that are similar
12:08:17 <merijn> hmm
12:08:17 <Cale> (and 3 monad laws)
12:08:46 <Cale> Well, and that's just with first, arr, (>>>)
12:08:58 <xplat> it's kind of like the way you roll up a map full of methods into an interface instance in groovy
12:09:04 <merijn> I just realized if you make ((->) r) a monad instance >>= would just be function composition, no?
12:09:30 <merijn> oh wait
12:09:31 <merijn> No
12:09:35 <Botje> not quite
12:09:43 <Botje> the second function woud have type a -> r -> b
12:09:43 <merijn> Now I confused myself :p
12:10:22 <Philonous> Cale: Actually 5 arrow laws suffice, as Wadler et al. have shown
12:10:36 <xplat> Cale: yeah, the arrow laws are weaker, but more numerous
12:10:37 <Cale> Philonous: ah, cool, still moar than 3 :)
12:10:41 <merijn> I guess that would be "(r -> a) -> (a -> r -> b) -> r -> b", no clue what the hell you'd use that for, though
12:10:45 <Cale> morphles: Traditional FP puts a heavy emphasis on polymorphism through universal quantification of types: you have things like  length :: forall a. [a] -> Integer, which works on all list types because it doesn't care about the elements of the list, only the structure.
12:10:52 <Botje> merijn: working it out by hand is very instructive
12:11:08 <morphles> Cale: and thats ultra cool imho :)
12:11:28 <Botje> try to work out what f >>= g means, for example
12:11:38 <Cale> morphles: Traditional OO on the other hand gets its polymorphism through a sort of existential quantification of types -- you often only know that some class *exists* which is a subclass of X and is the type of your object.
12:11:40 <morphles> for me at least, i kinda like this high level of generalization
12:12:14 <aristid> @hoogle (a -> m b) -> m (a -> b)
12:12:14 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
12:12:49 <Cale> Traditional FP has a lot of sum types with multiple data constructors, while traditional OO focuses more heavily on product types with lots of fields and methods.
12:13:25 <morphles> hm sum types, product types? thats a bit confusing
12:13:30 <merijn> And then there is non-traditional FP which is invented by people who've been staring into to many Lovecraftian abysses >.>
12:13:40 <Cale> data Colour = Red | Green | Blue
12:13:42 <azaq23> @src -> (>>=)
12:13:42 <lambdabot> Source not found. Just try something else.
12:13:44 <Cale> ^^ this is a sum type
12:13:45 <xplat> morphles: sum types are variants, product types are records/tuples
12:13:54 <azaq23> @src (->) (>>=)
12:13:54 <lambdabot> f >>= k = \ r -> k (f r) r
12:13:59 <morphles> sum type = kinda enum?
12:14:10 <c_wraith> no, sum type is multiple constructors
12:14:15 <morphles> ah
12:14:18 <merijn> morphles: More like union
12:14:18 <c_wraith> data Foo = Foo Int | Bar String
12:14:22 <c_wraith> is also a sum type
12:14:32 <Cale> Yeah, sum = disjoint/discriminated union
12:14:43 <merijn> \o/
12:14:47 <merijn> I got something right :)
12:14:54 <Cale> But enum types are sum types :)
12:14:59 <morphles> hm abd why you called oop types prodyct types?
12:15:05 <morphles> and*
12:15:15 <Jafet> C is cooler, it lets you have non-disjoint unions
12:15:27 <Cale> Are you familiar with Cartesian product from mathematics?
12:15:36 <merijn> morphles: A product type would be for example "data Foo a b = Foo a b"
12:15:48 <merijn> i.e. a constructor which takes multiple types as arguments
12:15:53 <xplat> although the opposition is not really all THAT stark -- FP types are usually sum-of-products, and OO types are open-sum of products, and OO concrete classes are product-of-open-sums
12:15:57 <Cale> multiple values as arguments
12:16:03 <morphles> ala record/struct?
12:16:04 <azaq23> merijn: f >>= g >>= h is \r -> h (g (f r) r) r) r, I think it's easier to see what that might be useful for using 3 bind applications
12:16:06 <Cale> yeah
12:16:37 <Cale> Data types in Haskell are sums of products (and they can be recursive and polymorphic too, but ignore that for the moment :)
12:16:41 <c_wraith> You can think of "sum" and "product" as referring to the cardinality, also.
12:17:09 <Cale> data Employee = Boss Name Salary | Peon Name
12:17:24 <c_wraith> data Foo a b = Foo a | Bar b -- the cardinality of Foo is (approximately, ignoring bottoms) the cardinality of a + the cardinality of b
12:17:28 <xplat> c_wraith: although interesting things only happen for the cardinality of sums and products when the types involved are finite
12:18:06 <xplat> because + and * both become 'max' at all infinite cardinalities
12:18:08 <morphles> i think ill need to learn a bit more haskell to make ends meet in all you are telling me :)
12:18:09 <Cale> So, an Employee is either (sum) a Boss, or a Peon, and a Boss consists of both (product) a Name and a Salary
12:18:17 <c_wraith> data Foo a b = Foo a b -- the cardinality of FOo is (once again, ignoring bottoms) the cardinality of a * the cardinality of b
12:18:23 <morphles> havent yet writenn my own type declarations
12:18:25 <morphles> data*
12:18:29 <Cale> morphles: ah, okay
12:18:32 <morphles> data,type,class
12:18:38 <morphles> but read about them in learn you a haskell
12:18:39 <Jafet> (Does [Bool] have cardinality of the continuum?)
12:18:49 <morphles> hm no?
12:18:53 <morphles> no way id say
12:18:59 <morphles> but what do i know:)
12:19:00 <Cale> But basically, data declarations in Haskell unify enum, struct and (safe uses of) union from C.
12:19:16 <morphles> i like lists :D
12:19:25 <morphles> that kinda only thinkg i hot my hands on
12:19:54 <xplat> hm, ncurses is higher-level than i would have thought
12:19:54 <morphles> got*
12:19:58 <Jafet> ((That was a trick question))
12:20:04 <morphles> Jafet: :)
12:20:19 <xplat> not sure how much i trust millikin, though
12:20:22 <morphles> i thunk answer would be that real is contrinum ints and bool are not
12:21:25 <xplat> morphles: [Bool] are lists of Bool.  and they can be infinite.  and the real answer is 'it depends'.
12:21:33 <morphles> ah
12:21:46 <morphles> i miseed *[*Bool*]* :)
12:22:04 <Tomsik_> [Bool] does not have a cardinality of continuum
12:22:09 <morphles> i gues they cant be continum since, thats bacily
12:22:12 <morphles> int
12:22:18 <morphles> [Bool] = int
12:22:25 <Tomsik_> as they are _computable_ lists of bools
12:22:27 <morphles> list of bits
12:22:33 <Tomsik_> and thus even if infinitely long
12:22:35 <morphles> is int
12:22:43 <Tomsik_> there is only at most alef-0 of them
12:22:48 <Tomsik_> nay
12:22:55 <Tomsik_> it'd have to be an infinitely long int sometimes
12:22:59 <Jafet> But if you allow unsafePerformIO...
12:23:02 <Tomsik_> :t repeat
12:23:03 <lambdabot> forall a. a -> [a]
12:23:08 <Tomsik_> >repeat False
12:23:10 <c_wraith> or even unsafeInterleaveIO
12:23:19 <Tomsik_> > repeat True
12:23:20 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
12:23:24 <morphles> well mathematicaly ints go to infinity
12:23:24 <xplat> Tomsik_: there are two ways you can interpret [Bool] to have the cardinality of the continuum, and one doesn't even involve noncomputable lists.
12:24:11 <Tomsik_> xplat: like?
12:25:37 <aristid> :t conat . repeat
12:25:38 <lambdabot> Not in scope: `conat'
12:25:40 <Philonous> Is there a fundamental difference between unsafeInterleaveIO and return . unsafePerformIO (with it's type restricted to IO )?
12:25:42 <aristid> :t concat . repeat
12:25:43 <lambdabot> forall a. [a] -> [a]
12:25:55 <xplat> Tomsik_: one of course is to interpret [Bool] as all the set-theoretic lists of Bools (plus bottoms and partial values).  because even if a haskell program can't generate them from nothing, it can compute functions with noncomputable lists as input and produce other noncomputable lists, assuming you have somewhere to get them to start with.
12:25:57 <Saizan> Philonous: no
12:26:29 <rothwell> hm... i'm trying to understand how to implement a custom monad that only allows one or two specific side effects (like putStrLn) as a learning exercise
12:26:46 <rothwell> is there an example anywhere that DOESN'T use generalized newtype deriving, monad transformers, and so on?
12:26:52 <xplat> Tomsik_: the other is to look at an 'internal logic' view from a modest set theory, where everything is computable and even the computable lists of bools have the cardinality of the continuum.
12:27:02 <azaq23> that is in fact the definition of unsafeInterleaveIO in the source file on System.IO.Unsafe, IIRC
12:27:07 <rothwell> want a small example that i can rip apart...
12:27:13 <c_wraith> rothwell: it's not all that hard, actually.  You don't need to use generalized newtype deriving or monad transformers.
12:27:29 <rothwell> c_wraith: i'm aware, it's just that every custom monad i can find uses them
12:27:50 <rothwell> i want to see the boilerplate that's being generated, y'know...
12:28:00 <c_wraith> rothwell: give me 5 minutes :)
12:28:05 <rothwell> c_wraith: thanks very much
12:28:16 * rothwell wanders off for a few minutes
12:28:22 <Tomsik_> xplat: continuum of computable _anything_? That doesn't make sense, there isn't a continuum programs in the first place.
12:28:24 <hpc> rothwell: i can write one
12:28:29 <hpc> oh, c_wraith is
12:29:10 <morphles> i dont see how [Bool] != Int in math sence
12:29:11 <dmwit> rothwell: module OnlyPutStrLn (OnlyPutStrLn, putStrLn) where newtype OnlyPutStrLn a = OnlyPutStrLn { unOnlyPutStrLn :: IO a }; instance Monad OnlyPutStrLn where { return = OnlyPutStrLn . return; (OnlyPutStrLn m) >>= f = OnlyPutStrLn (m >>= unOnlyPutStrLn . f) }; putStrLn = OnlyPutStrLn . putStrLn
12:29:18 <xplat> Tomsik_: from the point of view of a set theory where only computable functions exist, to say something has countable cardinality it must have a COMPUTABLE injection to the naturals
12:29:20 <Berengal> rothwell: http://hpaste.org/45546/io
12:29:32 <Berengal> (Not checked for correctness)
12:30:30 <xplat> Tomsik_: (also in that set theory cardinals are not a nice linear order like in ZFC)
12:30:34 <morphles> [] = 0, [true] = 1 , [true,false] = 2 ... = int imho :) but i dunno much, im low level on this
12:30:41 <dmwit> morphles: Suppose "f" were a bijection between [Bool] and Integer.
12:30:45 * azaq23 is wrong, unsafeInterleaveIO could be defined as return . unsafePerformIO, but it isn't in System.IO.Unsafe source / GHC source
12:30:58 <dmwit> morphles: Actually, let's do [Bool] and Natural, it's a bit easier to see.
12:31:07 <morphles> So
12:31:12 <morphles> i wrot how i understand that
12:31:21 <dmwit> morphles: So, that means there's a [Bool] for each Natural. List them out in order.
12:31:24 <ezyang> azaq23: That wouldn't be a very interesting unsafeInterleaveIO... 
12:31:29 <dmwit> morphles: Then, construct the following [Bool]:
12:31:31 <Tomsik_> So you're saying that you can take an incomputable subset of naturals and have it be more than alef-0?
12:31:40 <merijn> morphles: The problem is then that [true,true] and [true,false] and [false, true] would all be 2, no?
12:31:51 <morphles> ah
12:31:54 <xplat> Tomsik_: yes
12:32:03 <dmwit> morphles: The first element is not (f 0 !! 0); the second element is not (f 1 !! 1); the third is not (f 2 !! 2), etc.
12:32:11 <merijn> morphles: So you have multiple [Bool] mapping to the same Int
12:32:17 <Tomsik_> What is this model named?
12:32:21 <morphles> merijn: i got your point
12:32:21 <merijn> And then pigeon hole principle, etc
12:32:22 <morphles> hm
12:32:23 <Tomsik_> Or rather theor
12:32:31 <dmwit> morphles: If f i doesn't have an i'th element, then we can pick either True or False for that element of our newly constructed list.
12:32:53 <c_wraith> rothwell: http://hpaste.org/45547/myio
12:32:54 <xplat> Tomsik_: look up modest sets, the effective topos, and realizability
12:32:58 <dmwit> morphles: The result of this is that we know that our constructed [Bool] is not equal to (f i) for any i -- because it differs on the i'th element.
12:33:08 <dfilimon> merijn: that link was cool, i ended up using both &&& and *** for the first time, and it worked!
12:33:09 <azaq23> ezyang: I thought you could define it like that. Saizan, too, for he first answered Philonous' question regarding this exact thins.
12:33:15 <dmwit> morphles: So f isn't a bijection -- it's not surjective -- and we have a contradiction.
12:33:17 <c_wraith> rothwell: that's a very primitive example, supporting just one operation
12:33:24 <merijn> dfilimon: \o/
12:33:47 <neophyte> Is anyone familiar with elemmentary computability theory
12:33:51 <rothwell> c_wraith: thanks
12:33:56 * rothwell pulls the example to pieces
12:34:43 <morphles> dmwit: but such proof is weird to me, its like you can say taht binary representation of ints is kinda more than ints
12:34:50 <ezyang> ah, actually, I think I'm mistaken. 
12:34:55 <morphles> i know that what i said is big missuse of language :)
12:34:56 <dfilimon> is there by any chance a way of not writing sum *** sum, maybe like... apply it to both parts?
12:34:57 <dmwit> rothwell: For c_wraith's example to work, you must also ask the module not to export the MyIO constructor, as in my example.
12:35:20 <dmwit> morphles: No, it's like saying that the binary representation of Ints is not [Bool].
12:35:24 <dmwit> morphles: Which it isn't.
12:35:28 <xplat> morphles: there are no integers that have an infinite-length binary representation (except maybe one with an infinite number of zeros but no infinite number of any other digit)
12:35:29 <dmwit> morphles: So there's nothing strange about that.
12:36:09 <dmwit> morphles: The binary representation of Ints is (exists n. Vec n Bool), where "Vec n Bool" is a *finite* list of length exactly n.
12:36:12 <xplat> well, actually you can have up to two digits that you can have an infinite number of, but not an infinite number of both in the same number
12:36:14 <c_wraith> Hmm.  I wonder if you can use module exports and then override part of what they export
14:39:43 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
14:39:43 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:19 2011]
14:40:03 <neophyte> xplat, that is basically proving that L is undecidable
14:41:07 <xplat> > [1..15]++[1,3..9]++[1,4,7,3,1,1,3,1,1,0]
14:41:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:41:21 <erus_> no thats cheating
14:41:26 <erus_> you have to use a map and a zip
14:41:30 <erus_> ;)
14:41:40 <neophyte> xplat, I think i can prove that the complement of L is not R but i'm not sure how to show that the complement of L is R.E.
14:41:57 <neophyte> proving somehting is not recursice is easy
14:42:07 <neophyte> proving somehting is R.E. is harder
14:42:40 <neophyte> because I need to prove that <M> | L(M) > 3 can be enumerated
14:42:46 <xplat> neophyte: try proving the direct implication, not the contrapositive.
14:43:11 <erus_> > map (\(x, y) -> x `mod` y) $ zip [1..30] [30,29..1]
14:43:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:43:25 <xplat> neophyte: that is, given that L is RE and ~L is RE, prove L is recursive
14:43:53 <ion> > (uncurry mod) . zip [1..30] [30,29..1]
14:43:54 <aristid> > zipWith mod [1..30] [30,29..1]
14:43:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:43:55 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:44:13 <ion> ah, zipWith :-)
14:44:21 <neophyte> L={ <M> | |L(M)| < 3} is NOT R.E. so we can't say L is R.E.
14:44:27 <Silvah> xplat: I thought about the accumulator of course. Thanks for pointing out it won't work for all Nums - my mind is not working in Haskell mode now.
14:44:46 <neophyte> I'm trying to use the complement of L somehow  to show it isn't R.E.
14:45:00 <xplat> >zipWith(\x->x`mod`31-x)[1..30]
14:45:04 <xplat> > zipWith(\x->x`mod`31-x)[1..30]
14:45:05 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [c])
14:45:05 <lambdabot>    arising from a use ...
14:45:25 <xplat> > map(\x->x`mod`31-x)[1..30]
14:45:26 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
14:45:31 <xplat> oop
14:45:35 <copumpkin> wrong associativity
14:45:40 <xplat> > map(\x->mod x$31-x)[1..30]
14:45:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:45:58 <ion> @pl \x -> mod x (31-x)
14:45:58 <lambdabot> ap mod ((-) 31)
14:46:52 <shachaf> > [mod x$31-x|x<-[1..30]]
14:46:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:47:05 <xplat> > (mod<*>xor 31)<$>[1..30]
14:47:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:49:20 <ion> > ap mod(31-)<$>[1..30]
14:49:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:49:43 <ion> > ap mod(31-).[1..30]
14:49:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
14:49:56 <xplat> ion: cheating :)
14:50:00 <shachaf> ion: That's not proper Haskell.
14:50:03 <ion> No shit :-)
14:50:12 * shachaf develops a sudden resentment for Cale.
14:50:42 * shachaf ceases.
14:50:52 <erus_> ap mod(31-)<$>[1..30] doesnt work for me in ghci
14:51:02 <ion> erus: :m +Control.Applicative
14:51:14 <copumpkin> you guys trying to golf the shortest way to write that sequence?
14:51:16 <shachaf> Maybe also Control.Monad.Instances or something.
14:51:22 <ion> :m +Control.Monad
14:51:23 <shachaf> copumpkin: Apparently.
14:51:24 <xplat> you need to import Control.Applicative, but everyone does that anyway so it doesn't count against the number :)
14:51:32 <erus_> @src ap
14:51:32 <lambdabot> ap = liftM2 id
14:51:38 <erus_> @src <$>
14:51:39 <lambdabot> f <$> a = fmap f a
14:51:39 <shachaf> Control.Applicative should be part of the Prelude.
14:51:42 <shachaf> Except with better names.
14:52:39 <erus_> [mod x$31-x|x<-[1..30]] winner winner chicken dinner shachaf 
14:52:47 <shachaf> No, ion wins.
14:52:56 <ion> With the help of pl
14:53:23 <shachaf> lambdabot wins, then.
14:53:27 <ion> yes :-)
14:53:27 <shachaf> @karma+ lambdabot
14:53:28 <lambdabot> lambdabot's karma raised to 7.
14:53:49 <shachaf> Who wrote @pl, anyway?
14:53:50 <xplat> lambdabot always wins
14:54:40 <ion> xplat: Yeah, this channel is rigged.
14:54:44 <ksf> is there a name for the hell that code turns into when it contains too many Just, Nothing, Left and Rights?
14:56:30 <chomp> any sufficiently unmaintainable code can either be called "legacy code" or "someone else's problem" imho
14:57:07 <neophyte> xplat. I know if a language and its complement is recursively enumerable then it is said to be decidable. Somehow I was thinking we could use reducibility and reducethe complement of L to L_ne={<M> | L(M) =/= 0} which is R.E. 
14:57:13 <ksf> also, 130 lines are way too long for a function.
14:57:19 <ksf> even if every other line is a comment.
14:57:33 <chomp> if every other line is a comment, that's even worse
14:57:34 <shachaf> > 130 / 2 -- Yes.
14:57:35 <lambdabot>   65.0
14:57:48 <ksf> especially if said lines wrap my 160 character console.
14:58:00 <xplat> ksf: wtf
14:58:15 <xplat> i thought this was written in haskell?
14:58:26 <chomp> by monkeys, perhaps
14:58:30 <xplat> somebody needs a few helper functions ...
14:58:33 <ksf> max bolingbroke.
14:58:58 <Jafet> @quote abstractions
14:58:58 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
14:58:58 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
14:59:06 <Jafet> @quote good.abstractions
14:59:06 <lambdabot> monochrom says: the road to haskell is paved with good abstractions
14:59:14 <ksf> it's not like he can't code, but he either a) never cared to clean it up or b) suffers betriebsblindheit
14:59:28 <ksf> (I'm quite sure there's no adequate english word for that)
14:59:45 <xplat> what's the adequate english paragraph then?
15:00:09 <ksf> blindness induced by being over-accustomed to what one's working on.
15:00:17 <ion> Btw, an alternative way to put it (but still the same character count): ‘mod<*>(31-)<$>[1..30]’. Fun to see <*> and <$> in that order. :-)
15:01:21 <ksf> ...it doesn't help that it's the fucking core function of shake, which isn't exactly self-explanatory.
15:02:03 <Jafet> We have enough beamtenenglisch as it is, thank you
15:02:17 <aristid> beamtenenglisch? oO
15:02:53 <ksf> Jafet, but it certainly has eigenvalue.
15:03:15 <merijn> something something entscheidungsproblem
15:03:15 <xplat> ksf: what does the betriebs part mean literally in english?
15:03:29 <ksf> not company.
15:03:30 <erus_> how can i do this [x | x <- getLine] ?
15:03:41 <ksf> operation, rather.
15:03:48 <merijn> xplat: "occupied with", I think?
15:03:49 <shachaf> @undo [x | x <- getLine]
15:03:49 <lambdabot> concatMap (\ x -> [x]) getLine
15:03:52 <ksf> but also plant, or factory.
15:04:06 <aristid> in this case operation is more appropriate
15:04:10 <shachaf> If monad comprehensions were valid, you could just say getLine.
15:04:23 <ksf> definitely.
15:04:28 <xplat> ksf: because i want to import that word, but i'm sure that only like 2 people i know could pronounce or remember it ...
15:04:53 <ksf> it's rooted in betreiben.
15:05:00 <erus_> can i do undo in ghci somehow?
15:05:00 <ksf> treiben means to drive.
15:05:07 <ion> erus: What do you actually want? The non-simplified version of the list comprehension, please.
15:05:07 <aristid> @. pl undo [x | x <- getLine]
15:05:08 <lambdabot> getLine
15:05:19 <aristid> haha, @pl for the fun
15:05:26 <erus_> @undo [x | x <- [1..10]
15:05:26 <lambdabot>  Parse error at end of input
15:05:30 <erus_> @undo [x | x <- [1..10]]
15:05:30 <lambdabot> concatMap (\ x -> [x]) [1 .. 10]
15:05:42 <xplat> ksf: this is not sounding mnemonic or catchy in english :(
15:05:49 <shachaf> lambdabot should have @plundo
15:06:06 <xplat> i'm going to be stuck with painful language envy again :(
15:06:35 <ion> @unpl (+1)
15:06:36 <lambdabot> (\ a -> a + 1)
15:06:40 <aristid> shachaf: why? @. pl undo works fine and isn't that much more to write
15:06:48 <ksf> so, transitive-drive-noun-blind-state
15:06:53 <erus_> ion: i was just trying to write the whole program in a list comprehension... 
15:07:12 <xplat> driving-blindness ...
15:07:19 <xplat> not working
15:07:35 <ksf> rather operational blindness.
15:07:38 <merijn> xplat: driving isn't really part of that word
15:07:43 <ksf> it is.
15:07:50 <ksf> but it's transitivised and nounised.
15:07:56 * shachaf suddenly remembers @@.
15:08:06 <ksf> german is more generative than even most germans realise.
15:08:48 <aristid> ksf: we can make new words for everything! but unfortunately they tend to be long
15:08:49 <ksf> erm, wait, wrong word.
15:08:58 <merijn> ksf: Your saying betrieben is just another form of trieben? This confirms my suspicion that German grammar is quite possibly even less comprehensible then Dutch grammar...
15:09:25 <ksf> synthetic is the word.
15:09:51 <ksf> merijn, what's On-view-council-with-link-plural-completion-collect-noun ?
15:10:03 <aristid> merijn: betreiben is not a form of treiben. it's an entirely different word.
15:10:20 <merijn> aristid: That's what I said, but ksf said I was wrong
15:10:26 <aristid> merijn: it just happens to be treiben with a prefix of be, but that doesn't mean it's the same word.
15:10:30 <ksf> Aufsichtsratsmitgliederversammlung consists of more of four parts.
15:10:40 <merijn> That'd be like bedrijven and drijven being the same in Dutch, which is insane
15:10:52 <aristid> no no
15:11:00 <ksf> it's not the same.
15:11:07 <aristid> merijn: so dutch has the same prefixisation thing?
15:11:11 <ksf> but one is synthesised from the other.
15:11:14 <merijn> ksf: They're not even related
15:11:28 <ksf> of course they're related.
15:11:31 <aristid> of course they're related, in a vague and long-forgotten way
15:11:43 <merijn> aristid: Which is the same as saying they're not :)
15:11:45 <aristid> ksf: my statement is more detailed :P
15:11:48 <ksf> most people don't have the grammar subroutines to parse the be-, though.
15:12:38 <ksf> even worse is ver-, which is the perfect aspect.
15:13:03 <aristid> merijn: treiben is doing something, and betreiben is operating, which is a restricted form of doing
15:13:44 <aristid> ksf: i'm at a loss to find any semantic relationship between treiben and vertreiben
15:13:47 <ksf> I'd translate treiben with causing something to run, here.
15:13:51 <aristid> maybe doing something so they go "ver"?
15:14:10 <ksf> aristid, to have finished driving away.
15:14:32 <ksf> like in bleiben and verbleiben.
15:14:33 <aristid> treiben is such a useful word core.
15:14:40 <merijn> aristid: I take it back, German is still insane :p
15:14:44 <merijn> Anyhoo, bedtime
15:14:52 <aristid> merijn: there's also auftreiben
15:15:00 <aristid> and antreiben
15:15:18 <ksf> zutreiben and wegtreiben
15:15:26 <aristid> zutreiben? what's that?
15:15:27 <ksf> vorsichhertreiben.
15:15:38 <aristid> hertreiben
15:15:52 <ksf> jemanden etwas zutreiben.
15:15:57 <ksf> like, pigs to the butcher.
15:15:57 <aristid> hmmm
15:16:30 <aristid> man that's a lot of -treiben words :D
15:16:47 <ksf> abtreiben
15:16:50 <ksf> austreiben
15:16:51 <aristid> enttreiben
15:16:53 <ksf> eintreiben
15:17:09 <ksf> http://de.wikipedia.org/wiki/Prfix
15:18:18 <ksf> english has a gazillion of probably all roman-rooted words for those.
15:18:51 <aristid> i wonder how scandinavian languages deal with it.
15:19:12 <pmo> where haskell is used , i mean which sort of application is haskell popular ? web ? gui / qt ? anywhere else ?
15:19:17 <ksf> old norse-descentent languages should do the same.
15:19:21 <ksf> finnish is agglutinative.
15:19:46 <aristid> ksf: so english is the outlier in the germanic group?
15:19:48 <ksf> russian is even more synthetic than german
15:19:57 <ksf> it's not a germanic language in my book.
15:19:58 * shachaf should learn Finnish.
15:20:19 <KirinDave> English is an outlier everywhere
15:20:28 <aristid> ksf: it is. http://en.wikipedia.org/wiki/Germanic_languages
15:20:32 <shachaf> pmo: Shh, we're talking about important languages now.
15:20:36 <KirinDave> It's an absolutely enormous language.
15:20:47 <hpc> shachaf: lol
15:20:52 <hpc> pmo: haskell is very general purpose
15:21:00 <handonson> can I *upgrade* from GHC 7.0.2 to 7.0.3 instead of having a separate copy of 7.0.3 installed?
15:21:02 <chomp> is haskell germanic?
15:21:23 <KirinDave> What does haskell gui code look like?
15:21:27 <ksf> it's dictionary is mostly english and greek.
15:21:27 <aristid> chomp: no, it's mlific ;)
15:21:30 <pmo> i don't know much about haskell, used ruby for years.. on spare time.. a bit of java.. and C.. 
15:21:33 <shachaf> pmo: It's a general-purpose language. It seems to be popular for people writing Haskell compilers.
15:21:35 <ivanm> handonson: you mean in-place?
15:21:38 <ivanm> then no
15:21:43 <handonson> i mean, when I install a new version of GHC, it seems I have to redo all the cabal install... can I avoid that?
15:21:49 <ivanm> no
15:21:50 <pmo> shachaf, sort of "self concern" :)
15:21:50 <ksf> handonson, nope.
15:22:06 <hpc> KirinDave: i understand haskell gtk code looks like whatever any other language's gtk code looks like
15:22:06 <handonson> oh.
15:22:12 <hpc> dunno about qt
15:22:13 <shachaf> KirinDave: That depends. Imperative GUI code looks a lot like imperative GUI code in other languages.
15:22:19 <ksf> the ABI changes virtually every release
15:22:21 <pmo> i have the overall impression java need some serious replacement.. 
15:22:31 <ksf> flame SPJ and the rest if you want.
15:22:33 <aristid> pmo: scala?
15:22:45 <handonson> then how do you guys manage? you do all the cabal install over and over again?
15:22:47 <KirinDave> Well I'm wondering if there is some cleverness the Haskell community has uneathed from academia and applied to the problem.
15:22:50 <pmo> aristid, i dont know, maybe.. 
15:22:53 <ksf> handonson, yep.
15:23:06 <aristid> KirinDave: FRP seems to be unable to leap from research to reality
15:23:11 <ksf> that, and I don't upgrade my system ghc nearly as often as my development ghc
15:23:15 <shachaf> KirinDave: All sorts of cleverness, but probably none of it is practical at this point.
15:23:41 <pmo> aristid, but i'd like to try guess, which one will be elected, it shoudl be a popular one.. and haskell seem to be popular, while at some point it looks like ruby.. but it can compiled as i heard
15:23:52 <ksf> syntax-wise, I think haskell is a close relative of lojban.
15:24:00 <KirinDave> I've also had trouble finding good replacements for actors when working with distributed and certain types of concurrent code. People mutter at me about applicative styles.
15:24:04 <ksf> all programming languages are, in a way.
15:24:16 <aristid> pmo: scala has some popularity, too
15:24:20 <KirinDave> But then when it's time to talk turkey, I wasn't terribly impressed by some of the things people showed me.
15:24:25 <shachaf> pmo: Don't learn Haskell because you're guessing it'll be popular sometime.
15:24:27 <pmo> aristid, yes, new comer
15:24:53 <KirinDave> like, pi calculus has been hailed at me as a replacement for the actor model.
15:24:54 <KirinDave> But...
15:25:00 <KirinDave> Maybe I just didn't see a good demo.
15:25:13 <aristid> KirinDave: where can i read what the actor model is?
15:25:21 <pmo> usually it gets popular, because it had some quality people are looking for, hence it's good to learn / know about those intrinsec qualities
15:25:23 <KirinDave> aristid: Erlang.
15:25:25 <KirinDave> but, uh
15:25:29 <KirinDave> standby, I have it in my papers.app
15:25:30 <dobblego> KirinDave: pi-calculus is a formalisation of the actor model
15:25:36 <dobblego> it is not a replacement
15:25:44 <KirinDave> dobblego: Ah, perhaps it was oversold to me, then
15:25:49 <handonson> how do you uninstall an older version of ghc on linux?
15:25:57 <KirinDave> dobblego: I saw a talk the other day where someone actually tried to sell it to me as a practical replacement.
15:25:59 <pmo> in terms of syntax java look awfully outdated to me.. 
15:26:22 * shachaf wonders what makes a syntax outdated.
15:26:25 <KirinDave> pmo: Look dude. Some people LIKE writing the same code over and over. It's a zen thing. :)
15:26:29 <shachaf> Other than using all capital letters or something.
15:26:31 <erus_> Whats wrong with this: http://hpaste.org/45555/dountilzero
15:26:45 <KirinDave> shachaf: What makes C look so outdated? :)
15:27:04 <shachaf> erus_: Maybe you're missing "ero"?
15:27:11 <aristid> KirinDave: did you read this? http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
15:27:11 <Philonous> pmo: If that was the problem all you needed is a source-to-source translator
15:27:12 <shachaf> Also, parentheses.
15:27:22 <shachaf> KirinDave: C looks outdated?
15:27:26 <erus_> i just put compiler message as an annotion
15:27:29 <KirinDave> shachaf: I'd argue it does.
15:27:51 <KirinDave> shachaf: I hear old-timey music in my head every time I see the "union" keyword.
15:27:54 <azaq23> @type let p :: [Int]; p = [10]; result :: Int; result = 20 in p : [result] -- This is wrong with it erus_
15:27:55 <lambdabot>     Couldn't match expected type `[Int]' against inferred type `Int'
15:27:55 <lambdabot>     In the expression: result
15:27:55 <lambdabot>     In the second argument of `(:)', namely `[result]'
15:27:56 <dobblego> there is rust on the top of the curve of the C, look closer
15:27:58 <shachaf> C-style syntax is still probably the most popular programming language syntax.
15:28:31 <aristid> KirinDave: from a cursory glance, "actor model" seems to be mostly about isolated processes with message passing as the main synchronization mechanism
15:28:38 <KirinDave> aristid: Yes.
15:28:49 <KirinDave> aristid: Although the execution strategy is not necessarily "isolated processes"
15:29:08 <shachaf> union isn't that bad.
15:29:12 <KirinDave> aristid: And an underlying assumption of the model is that individual actors are extremely lightweight. Even older erlang implementations can have 500k.
15:29:13 <shachaf> ...If you're already writing in C.
15:29:30 <erus_> azaq23: i dont understand
15:29:39 <azaq23> erus_: ok you pattern matched on the first argument with [xs], which is very usual. It also doesn't make sense. This will only match for singular lists like [10], not [10, 2, 3]
15:29:44 <erus_> oh i cant concatinate that?
15:29:46 <azaq23> *very unusual I mean
15:29:49 <aristid> KirinDave: then you should totally read the paper i linked a few lines above
15:29:57 <erus_> ah ok
15:30:10 <KirinDave> aristid: I will.
15:30:16 <azaq23> erus_: I though you had a list of type [Int], and tried to to xs : [result], which doesn't type match
15:30:18 <pmo> Oracle will kill java with their policy.. and i'll never regret, both syntax.. and their memory managment
15:30:38 <KirinDave> pmo: Yeah but there aren't many other widespread, widely-targeted VMs to fill the gap.
15:30:46 <KirinDave> pmo: You're going to trust in the CLR-family?
15:30:46 <erus_> yeah how do i push to the FRONT of a list?
15:30:55 <aristid> KirinDave: however, i think cheap threads + message passing is something that haskell already has. the paper above is mostly about making it also work across multiple machines
15:30:58 <dobblego> erus_: with (:)
15:31:13 <erus_> i mean back
15:31:19 <erus_> whoops
15:31:25 <pmo> KirinDave, you are right.. but scala offers an alternative.. i don't know about haskell tho
15:31:28 <shachaf> Pushing is an illusion.
15:31:35 <KirinDave> aristid: As someone who's made large distributed systems in Erlang, that excites me.
15:31:39 <dobblego> erus_: usually you use a better data structure, but otherwise, ++ [x]
15:31:39 <shachaf> And you don't do anything with the back of the lit.
15:32:00 <KirinDave> But a lot of what makes erlang so great is the robust stdlib.
15:32:03 <dobblego> scala has completely messed up the actor model
15:32:24 <dobblego> nkpart!!
15:32:45 <KirinDave> dobblego: Scala's base actors suck.
15:32:49 <azaq23> > let f xs fn r = if res == 0 then ret else f ret fn r where ret = xs ++ [result]; res = fn x in f [] (- 1) 10
15:32:50 <lambdabot>   Not in scope: `result'
15:32:52 <KirinDave> dobblego: Akka is doing a better job of it.
15:32:57 <dobblego> so does much of the standard library
15:33:01 <KirinDave> yes.
15:33:06 <azaq23> > let f xs fn r = if res == 0 then ret else f ret fn r where ret = xs ++ [res]; res = fn x in f [] (- 1) 10
15:33:10 <erus_> it works hurrah
15:33:10 <lambdabot>   mueval-core: Time limit exceeded
15:33:24 <KirinDave> dobblego: The nice thing we can say: at least it got a lot better between 2.7* and 2.8*
15:33:32 <ksf> https://github.com/batterseapower/openshake/blob/c5b629375f1ce8f5dcb96dbfe40cb0a6ec2f5676/Development/Shake/Core.hs
15:33:35 <KirinDave> Still a lot of work to do.
15:33:40 <ksf> someone please explain findAllRules to me
15:33:50 <erus_> I wish i could use Num as a typ
15:33:56 <pmo> so what sort of language would you recommend that maybe today or tommorow, i'll be able to use everywhere on top / or replcament of java.. and with those sort of pretty nice syntax / easy to learn / facilities i have on ruby.. and will prevail, when java will just disappear ?
15:34:07 <azaq23> > let f xs fn r = if res == 0 then ret else f ret fn res where ret = xs ++ [res]; res = fn x in f [] (- 1) 10
15:34:11 <lambdabot>   mueval-core: Time limit exceeded
15:34:24 <KirinDave> ksf: Did you know you can click on a line number (or shift click on 2 line numbers) and make a new link that takes us RIGHT to your point of intnerest?
15:34:27 <ksf> that's the wrong reason to learn a language.
15:34:27 <hpc> pmo: there's no possible way to predict what language will get popular
15:34:29 <ksf> that said, haskell.
15:34:39 <hpc> also what ksf said
15:34:47 <ksf> https://github.com/batterseapower/openshake/blob/c5b629375f1ce8f5dcb96dbfe40cb0a6ec2f5676/Development/Shake/Core.hs#L518
15:34:50 <ksf> no, I didn't.
15:34:51 <shachaf> hpc: No possible way?
15:35:00 <KirinDave> ksf: There you go. :)
15:35:01 <pmo> ksf, the idea is to make an application portable.. 
15:35:04 * shachaf can beat hpc in language predictions.
15:35:13 <ksf> haskell is good for portability.
15:35:14 <hpc> shachaf: have fun
15:35:26 <KirinDave> Jesus too many comments in that code.
15:35:35 <ksf> well, as long as what your'e running on is an x86. 
15:35:56 <ksf> jay.
15:36:00 <ksf> jap, I mean.
15:36:14 <hpc> ksf: i like your imports
15:36:25 <ksf> I think I should forget about code layout for now and try to incorporate the comments into the actual code.
15:36:27 <ksf> they're not mine.
15:36:38 <xplat> english is ex-germanic.  it's the artist formerly known as anglo-saxon.
15:36:39 <erus_> can i use Num as a function type somehow?
15:36:59 <ksf> anglo-saxon changed, too, though.
15:37:02 <shachaf> erus_: You should read an introduction to Haskell. Type classes and such.
15:37:17 <ksf> one curious thing is that it dropped the ge- prefix, too.
15:37:29 <erus_> shachaf: yes i want to be able to use all the Num types 
15:37:32 <aristid> ksf: ?
15:37:41 <azaq23> @type ((+ 1), (- 1)) - yay really nice
15:37:42 <aristid> oh gedriven -> driven?
15:37:42 <lambdabot> Not in scope: `yay'
15:37:42 <lambdabot> Not in scope: `really'
15:37:42 <lambdabot> Not in scope: `nice'
15:37:45 <ksf> ik hev secht.
15:37:50 <ksf> not ich habe gesagt
15:37:54 <azaq23> @type ((+ 1), (- 1)) -- yay really nice
15:37:55 <lambdabot> forall a t. (Num a, Num t) => (a -> a, t)
15:37:56 <ksf> cf. I have said.
15:37:58 <chomp> erus_, you want a constraint, as in    f :: (Num a) => a -> [a]   
15:38:14 <copumpkin> azaq23: wonderful, eh
15:38:17 <shachaf> erus_: What book/introduction are you reading?
15:38:24 <erus_> ah cool
15:38:41 <ksf> aristid, exactly
15:38:43 <azaq23> copumpkin: you just got to love vector-space
15:38:44 <pmo> well, whatever thank you all, sorry to have bothered you maybe too much.. and thanks for your comments.. cheers..
15:38:46 <erus_> shachaf: I read a bit of lyahfgg and real worl haskell
15:38:47 <chomp> Also, you should probably work through LYAH (http://learnyouahaskell.com/) because it is badass and awesome.
15:38:57 <copumpkin> azaq23: why vector-space?
15:39:07 <KirinDave> erus_: You really, really, really are gonna wanna go over typeclasses before you continue. Chomp has A Link Relevant To Your Interests there.
15:39:09 <copumpkin> that's haskell
15:39:23 <shachaf> erus_: You should read more. They'll answer your questions with more detail (and probably more patience) than #haskell. :-)
15:39:54 <hpc> lyah++
15:39:57 <erus_> I think i know about types. Just not the syntax of using classes as punction params
15:40:08 <chomp> book, read
15:40:17 <chomp> learn, happy
15:40:33 <shachaf> chomp, listen
15:41:48 <azaq23> copumpkin: I assumed this had something do to with the fact that literals can be turned into const functions by vector-space, for I tried to use (- 1) in my code above, where it would have to be a function, but this doesn't match with the given type of (- 1), as I noticed
15:42:02 <copumpkin> nah
15:42:11 <Jafet> > (- 1)
15:42:12 <lambdabot>   -1
15:42:12 <copumpkin> (-1) is a literal, (+1) is a section
15:42:17 <Jafet> > (negate 1)
15:42:18 <lambdabot>   -1
15:42:18 <copumpkin> annoying
15:42:24 <kuznero> Hi gents, can anybody look at compilation issue with Data.ConfigFile: http://hpaste.org/45557/compilation_error
15:42:31 <Jafet> Er, brain-bbq
15:42:32 <aristid> :t subtract 1
15:42:33 <lambdabot> forall t. (Num t) => t -> t
15:42:35 <Jafet> > (subtract 1)
15:42:36 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
15:42:36 <lambdabot>    arising from a use of `...
15:42:46 <aristid> subtract 1 is what (-1) should be.
15:42:46 <Jafet> And cale should unoverlap that too
15:42:55 <shachaf> > (-1+) 5
15:42:56 <lambdabot>   4
15:43:03 <azaq23> @type let f xs fn r = if res == 0 then ret else f ret fn res where ret = xs ++ [res]; res = fn x in f
15:43:04 <lambdabot> forall t. (Num t) => [t] -> (Expr -> t) -> t -> [t]
15:43:04 <xplat> haskell is good for portability.  it can run well on any sort of x86 unix, which is all there is after all.
15:43:15 <aristid> xplat: haha.
15:43:23 <shachaf> xplat: Also x86_64!
15:43:28 <aristid> @remember xplat haskell is good for portability.  it can run well on any sort of x86 unix, which is all there is after all.
15:43:28 <lambdabot> Okay.
15:43:34 <copumpkin> > (+-1) 5
15:43:35 <lambdabot>   Not in scope: `+-'
15:43:38 <copumpkin> > (+ -1) 5
15:43:39 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
15:43:39 <lambdabot>      must have lower prece...
15:43:42 <copumpkin> boo
15:43:43 <aristid> @quote portability
15:43:43 <lambdabot> sieni says: C provides people with the expressiveness of fortran combined with the portability of assembler
15:44:14 <shachaf> @quote portable
15:44:14 <lambdabot> No quotes match. Take a stress pill and think things over.
15:44:34 <shachaf> @quote stress.pill
15:44:34 <lambdabot> No quotes match. Sorry.
15:44:47 <xplat> azaq23: that's not because of vector-space
15:45:16 <kuznero> http://hpaste.org/45557/compilation_error
15:45:17 <kuznero> ??
15:46:34 <kuznero> Gents, could someone please have a look at it?
15:47:22 <azaq23> xplat, copumpkin: Yep, it's not because of it. I had more than one wrong assumptions. I did let f fn = ... where r = fn x, not noticing that I would use x :: Expr and not fn as a function, and gave it (- 1) as fn. Because I assumed that this wouldn't typecheck when (- 1) was a literal, I though about const (-1), which turns the functions into an endless loop
15:47:32 <azaq23> @type (- 1) :: Num t => Expr -> t
15:47:32 <lambdabot> forall t. (Num t) => Expr -> t
15:47:33 * monochrom politically opposes overlapping instances
15:48:07 <shachaf> > (-1) 0 -- Success!
15:48:08 <lambdabot>   -1
15:48:20 <azaq23> > - 1 "this is from vector-space, (- 1) gets turned into const (-1)"
15:48:21 <lambdabot>   -1
15:50:47 <copumpkin> yeah
15:53:07 <parcs> why does ghc disallow instance declarations such as "instance Num a ⇒ IsString a where …"
15:54:23 <xplat> parcs: it doesn't, but that pretty much has to be the ONLY instance declaration for that class, which makes it sort of useless
15:55:08 <ivanm> and you then can't add any more instances
15:55:19 <Saizan> well, you need UndecidableInstances and in the case of IsString also OverlappingInstances, since there's already one
15:55:32 <ivanm> also, isn't that instance rather useless?
15:55:41 <ivanm> how is "random string" turned into a Num ?
15:55:54 <xplat> parcs: the issue is that the context (like Num a =>) isn't part of what it matches on to determine which instance applies
15:56:06 <Saizan> the first extension is needed because e.g. if someone adds instance IsString a => Num a then instance resolution could loop between the two
15:56:15 <copumpkin> ivanm: presumably by reading it into an Integer and then using fromInteger
15:56:28 <ivanm> copumpkin: heh
15:56:34 <parcs> Saizan: ah
15:56:53 <xplat> parcs: instead it matches on 'a' and then applies the constraint 'Num a' at the use site
15:57:08 <copumpkin> parcs: ideally it wants to consume a level of type constructor-ness at every resolution
15:57:17 <copumpkin> since that very definitely always terminates
15:57:18 <copumpkin> (assuming you have finite types)
15:57:24 <parcs> i see
16:03:04 <parcs> is this a deficiency of ghc or is such an instance simply illogical (for lack of a better term)?
16:03:26 <copumpkin> it's just not obviously terminating
16:03:35 <copumpkin> and it likes to keep its type system obviously terminating
16:19:08 <xplat> so i thought, 'maybe i'll try designing this DSL as a monad and see where it falls down'.  and it fell down immediately; i need an indexed monad.
16:20:18 <NisseP> xplat: rmonad might help?
16:20:51 <xplat> NisseP: probably.
16:21:50 <xplat> i think what i need is sort of an amalgamation of (indexed) state, list, and writer...
16:24:31 <copumpkin> indexed and rmonad are kind of different
16:26:12 <xplat> hm, yeah, rmonad is wrong
16:26:23 <xplat> (not universally, but for this)
16:27:28 <NisseP> i don't actually know much about indexed monads, so maybe i should've shut up. :D sorry for the naff suggestion.
16:27:52 <xplat> the idea is that i have a 'context' value, and a data/constraint store, and maybe some other junk
16:29:08 <xplat> and i kind of go through, stepping through the context by applying functions to extract parts of it, and throwing in constraints based on it, and i can take more than one 'step' from each context
16:29:23 <copumpkin> :O
16:29:29 <copumpkin> whatcha making?
16:29:54 <xplat> i guess what i want is to have a current 'key' and add constraints on a per-key basis
16:30:30 <xplat> copumpkin: a dsl to extract data from flabby or otherwise inconvenient formats
16:30:45 <xplat> (mostly xml/html)
16:30:56 <copumpkin> oh fun
16:32:54 <pastorn> @seen lispy
16:32:54 <preflex>  lispy was last seen on #haskell 2 days, 18 hours, 59 minutes and 10 seconds ago, saying: That would make me /cheer
16:32:55 <lambdabot> Unknown command, try @list
16:33:29 <shachaf> pastorn: Wasn't he in SF this weekend?
16:33:40 <pastorn> shachaf: i have no clue
16:34:24 <pastorn> shachaf: last thing he said to me was "I'm going to sleep. Good bye!"
16:39:56 <TheZimm> I just gotta say to yall, thank you for enlightening me with haskell! :D
16:40:38 * ddarius gingerly places the Haskell stick down to allow it a brief respite.
16:42:28 * WHARRGARBL grabs the haskell stick ddarius put down and whacks TheZimm some more with it
16:42:49 <TheZimm> whatd i do? >.< :P
16:42:56 <WHARRGARBL> NEED MOAR HASKELL
16:43:10 <nihtml> YEAH
16:43:17 <nihtml> sry.
16:45:33 <xplat> hm, maybe a regular monad would work.  it seems other than the context i don't actually have a return value i want to use
16:46:36 <xplat> that means i'd probably find it easier to use >>= most of the time than use 'do' and come up with a million stupid names for contexts :)
16:46:52 <aristid> xplat: or even >=>?
16:47:20 <hpc> aristid: at that point you want a Category though
16:47:27 <aristid> hpc: do you?
16:47:43 <aristid> hpc: dealing with Kleisli wrappers is a pain in the ass :)
16:47:55 <nihtml> :t (>>=)
16:47:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:48:02 <aristid> :t (>=>)
16:48:03 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
16:48:08 <hpc> aristid: i mean give your thing its own instance of Category
16:48:19 <hpc> if (>=>) is your main means of interaction with it
16:48:21 <ion> :t \f g -> const f >=> g $ ()
16:48:21 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
16:48:25 <aristid> hpc: that would require incorporating the function into the thing
16:48:36 <hpc> ion: ooh, nice
16:49:12 <cartouche> hello
16:49:25 <aristid> hpc: btw. i wrote a generic Category-like class for Reader-like monads :)
16:49:37 <cartouche> what does mean instance of a Show class?
16:49:47 <cartouche> show method
16:49:52 <aristid> hpc: http://hackage.haskell.org/packages/archive/transformers-compose/0.1/doc/html/Control-Monad-Compose-Class.html
16:50:25 <cartouche> I should write a show method  of a type and output it to the screen
16:50:37 <cartouche> line by line 
16:50:47 <cartouche> but I could not succed...
16:50:51 <nihtml> :t show
16:50:52 <lambdabot> forall a. (Show a) => a -> String
16:50:56 <hpc> aristid: your fundeps are confuzzling
16:50:58 <xplat> i'm starting to see how hxt ended up with arrows :-7
16:51:21 <TheZimm> lambdabot show 1
16:51:30 <TheZimm> :show 1
16:51:32 <aristid> hpc: they work out to simulating a Category without having the right kind :)
16:51:33 <TheZimm> lol
16:51:34 <ddarius> The arrow in HXT is an ArrowApply anyway, I think, so it's a monad anyway.
16:51:48 <TheZimm> i forgot how to use the bot
16:51:52 <nihtml> cartouche: show method returns a string, you don't print anything
16:51:54 <TheZimm> lambdabot help me!
16:51:56 <hpc> > show 1
16:51:57 <lambdabot>   "1"
16:52:05 <TheZimm> ah the >
16:52:14 <hpc> > 1 -- is a command
16:52:15 <lambdabot>   1
16:52:18 <aristid> ddarius: a ReaderT on something else, i guess
16:52:20 <hpc> @eval 1 -- is another command
16:52:23 <xplat> @eval 1
16:52:28 <hpc> er
16:52:30 <hpc> @run 1
16:52:31 <lambdabot>   1
16:52:34 <TheZimm> @eval show 1
16:52:38 <cartouche> show mytype a b then out a  nextline b
16:52:38 <TheZimm> ah ok
16:52:42 <ddarius> @help eval
16:52:42 <lambdabot> eval. Do nothing (perversely)
16:52:45 <xplat> my incorrect command was ninja'd O_o
16:52:46 <TheZimm> what language is lambdabot written in
16:52:47 <hpc> :t 1 -- and some of the ghci commands are supported
16:52:49 <lambdabot> forall t. (Num t) => t
16:52:52 <aristid> TheZimm: haskell!
16:52:53 <hpc> TheZimm: duh :P
16:52:57 <TheZimm> seriously?!?
16:53:01 <TheZimm> is it os
16:53:01 <aristid> yes!!!
16:53:03 <TheZimm> open source?
16:53:05 <aristid> yes!!!
16:53:07 <TheZimm> WHRRE
16:53:08 <hpc> @hackage lambdabot
16:53:09 <TheZimm> lol
16:53:09 <lambdabot> http://hackage.haskell.org/package/lambdabot
16:53:09 <nihtml> cartouche: wait what
16:53:15 <TheZimm> OMFG
16:53:19 <hpc> it's kind of a pain to install
16:53:24 <TheZimm> any yall wanna play minecraft?
16:53:34 <ddarius> And thus began the great exclamation mark shortage of 2011...
16:53:48 <nihtml> minecraft :)
16:53:50 <aristid> TheZimm: if you want to talk about minecraft, maybe #haskell-blah is better for that.
16:53:55 <TheZimm> ':P
16:53:55 <monochrom> I'll pay $10000 for the next exclamation mark
16:53:56 <cartouche> nithtml  show mytype a b --->  a    nextline b
16:53:58 <xplat> exclamation mark shortage?  NO1111111111111111111111111111111111111111111111111111111111111111111111111111
16:54:03 <TheZimm> i was just asking in general
16:54:19 <aristid> xplat: WAIT I HAVE MORE EXCLAMATION MARKS!!!!!!!!!!!!!!!!!!! DO!! NOT!! WORRY!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
16:54:25 <pastorn> ddarius: it's cool, i have exclamation stamps left from last year, valid up until 2014
16:54:25 <TheZimm> lol
16:54:33 <monochrom> I need exclamation marks to build hotels in monopoly
16:54:52 <ion> ‽⁈？！
16:55:05 <nihtml> cartouche: show (mytype a b) = show a ++ "\n" ++ show b ?
16:55:10 <xplat> i need exclamation marks to conserve on explicit seqs
16:55:20 <pastorn> @type (!!) . (!!) . (!!) . (!!) . (!!) . (!!)
16:55:21 <lambdabot>     Couldn't match expected type `[a]'
16:55:21 <lambdabot>            against inferred type `Int -> a1'
16:55:21 <lambdabot>     In the first argument of `(.)', namely `(!!)'
16:55:38 <xplat> :t (!!) .: (!!)
16:55:39 <lambdabot> forall a. [[a]] -> Int -> Int -> a
16:55:43 <aristid> haskell is just full of these things.
16:55:52 <aristid> :t flip (!!)
16:55:52 <ion> @type (!!1) . (!!1) . (!!1) . (!!1) . (!!1) . (!!1)
16:55:52 <lambdabot> forall b. Int -> [b] -> b
16:55:53 <lambdabot> forall a. [[[[[[a]]]]]] -> a
16:55:54 <nihtml> :t (.:)
16:55:55 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
16:55:57 <xplat> :t (!!) .: (!!) .: (!!) -- associate right or wrong?
16:55:58 <lambdabot>     Couldn't match expected type `[a]'
16:55:58 <lambdabot>            against inferred type `Int -> a1'
16:55:58 <lambdabot>     In the first argument of `(.:)', namely `(!!)'
16:56:00 <aristid> :t flip (!!) . flip (!!)
16:56:00 <pastorn> @type (!!) .: (!!) .: (!!) .: (!!) .: (!!) .: (!!)
16:56:01 <lambdabot>     Couldn't match expected type `Int' against inferred type `[b] -> b'
16:56:01 <lambdabot>     Probable cause: `flip' is applied to too few arguments
16:56:01 <lambdabot>     In the second argument of `(.)', namely `flip (!!)'
16:56:03 <lambdabot>     Couldn't match expected type `[a]'
16:56:05 <lambdabot>            against inferred type `Int -> a1'
16:56:06 <lambdabot>     In the first argument of `(.:)', namely `(!!)'
16:56:23 <pastorn> ion: nice :D
16:56:30 <cartouche> nihtml::yes, output should like this...
16:57:05 <nihtml> and does it work as u want?
16:57:22 <xplat> :t (!!)<*>(!!)<*>(!!)
16:57:23 <lambdabot>     Couldn't match expected type `Int'
16:57:23 <lambdabot>            against inferred type `Int -> a -> b'
16:57:23 <lambdabot>     In the second argument of `(<*>)', namely `(!!)'
16:57:30 <xplat> aw.
16:58:07 <WHARRGARBL> failxplat
16:58:10 <xplat> (i don't even know what i expected that to do :I)
16:58:21 <nihtml> cartouche: does it work?
16:58:35 <aristid> xplat: but it sure looks shiny :)
17:01:53 * ddarius does kind of want actual Japanese ramen now.
17:04:45 <xplat> @type let f = (.: (!!)) in f.f.f.f.f.f.f $ (!!)
17:04:46 <lambdabot> forall a. [[[[[[[[a]]]]]]]] -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> a
17:06:12 <ddarius> I'm sure that function will be useful to you.
17:07:01 <TheZimm> is there regex in haskell?'
17:07:15 <xplat> @faq is there regex in haskell?
17:07:15 <lambdabot> The answer is: Yes! Haskell can do that.
17:07:53 <NisseP> haha
17:08:30 <NisseP> isn't there a regex library in the platform? it'll probably be most painless to use that
17:10:00 <xplat> questioner already left
17:10:28 <NisseP> oh yeah, nevermind
17:13:29 <buggi22> hi all -- i could use some help debugging a program (i'm not asking you to fix it for me, but would like advice on how to pinpoint the source of problems like this one)...  here's the source:  http://ideone.com/iJynU
17:13:48 <buggi22> is there any way to watch how the evaluation proceeds step-by-step in a program like this?
17:14:56 <Jafet> You can use the ghci debugger.
17:15:30 <Jafet> Or you can use Debug.Trace...
17:16:06 <aavogt> that determinant is going to be very slow
17:16:45 <aavogt> but it's probably ok up to around 10x10
17:16:58 <buggi22> any resources for how to use those?  in ghci, i tried   ":break det", followed by "det testMatrix" and ":step" , but i don't understand the output at all
17:17:50 <buggi22> aavogt:  true -- i'm not using this for speed, though -- just trying to learn Data.Array a little better
17:18:40 <aavogt> buggi22: I think you get to force intermediate values, such as those in the where. So you either use :force variable  or :show variable  I think
17:19:21 * aavogt thinks the ghci debugger isn't that popular because it doesn't help so much
17:19:29 <rothwell> is there a pleasant way to see what code has been generated by a deriving clause?
17:19:37 <rothwell> as in... haskell source
17:19:46 <WHARRGARBL> no, unless it has a type error :P
17:20:02 <rothwell> hmph!
17:20:12 <xplat> i doubt that would be very pleasant
17:20:23 <aavogt> rothwell: try -ddump-deriv
17:20:47 <WHARRGARBL> you can see what it would do by asking it to derive Ord on a GADT that refines its instances
17:20:51 <WHARRGARBL> it's indices, even
17:21:03 <buggi22> aavogt:  ah, ok -- so the idea is that if i'm stopped at a breakpoint inside "det", i could try ":show factors" to see what it evaluates to?
17:21:43 <aavogt> buggi22: I guess, I have not used the ghci debugger in a while, so you're probably better off looking at the manual
17:22:01 <qwer> i'm trying to wrap my head around this magic: sequence $ map (\x -> getLine) [1..n]
17:22:22 <buggi22> aavogt:  got it -- thanks for pointing me in the right direction
17:22:22 <WHARRGARBL> qwer: that's replicateM getLine
17:22:34 <Axman6> that's just replicateM (n-1) getLine
17:22:42 <WHARRGARBL> fine
17:22:48 <Axman6> :P
17:23:01 <gwern> > length "ttps:/github.com"
17:23:01 <lambdabot>   16
17:23:24 <qwer> hmm.. lets look into its source code
17:23:38 <Axman6> > replicateM 4 (Just 4)
17:23:40 <lambdabot>   Just [4,4,4,4]
17:23:46 <Axman6> > replicateM 4 ([4])
17:23:47 <lambdabot>   [[4,4,4,4]]
17:23:48 <ion> qwer should be known as qwern for maximum confusion.
17:23:51 <Axman6> > replicateM 4 ([4,5])
17:23:53 <lambdabot>   [[4,4,4,4],[4,4,4,5],[4,4,5,4],[4,4,5,5],[4,5,4,4],[4,5,4,5],[4,5,5,4],[4,5...
17:24:21 <qwern> what's a qwern?
17:24:38 <xplat> a gwern with a damaged descender
17:24:47 <xplat> or a qwer with an extra n
17:25:16 <gwern> > drop 17 "https://www.github.com/sergeyastanin/simpleea"
17:25:16 <lambdabot>   "b.com/sergeyastanin/simpleea"
17:25:21 <aristid> qwern: gwern is a regular user, and now your nick is very similar to his.
17:25:34 <gwern> > drop 24 "https://www.github.com/sergeyastanin/simpleea"
17:25:35 <lambdabot>   "ergeyastanin/simpleea"
17:25:42 <qwern> oooh, middle earth reference
17:26:53 <qwern> oh wait, that's real folklore
17:29:09 <ddarius> aristid: They hash to different colors.
17:29:35 <aristid> ddarius: glorious irc-client-of-ddarius.
17:29:50 * gwern frowns at qwern. you qwer, always making us gwer look bad!
17:30:17 * geheimdienst ponders calling himself queern
17:30:44 <espringe> What's the function to search a string for a substring? 
17:30:53 <espringe> Can't seem to find anything
17:30:57 <Jafet> isInfixOf
17:31:26 <espringe> Jafet: thanks
17:31:30 <aristid> wow, "Functional Programming with Overloading and Higher-Order Polymorphism" is a long paper. i wonder what it's actually about.
17:31:45 <Axman6> > "dog" `isInfixOf` "The quick brown fox jumped over the laxy dog"
17:31:46 <lambdabot>   True
17:31:50 <Axman6> z* -_-
17:31:52 <Jafet> Sounds like a list of things it does to your brain, aristid
17:32:27 <aristid> Jafet: ?
17:32:51 <aristid> Axman6: i'm sure YOUR dog is laxy
17:33:01 <ddarius> aristid: Constructor classes.
17:33:21 <aristid> ddarius: meaning?
17:33:22 <Axman6> i hope not
17:34:35 <aristid> i think i should just read the thing. and all because i want to know the motivation behind RWST
17:34:37 <ddarius> aristid: What are now called type classes.
17:34:44 <aristid> ddarius: oh
17:34:51 <NisseP> classes where the types are kinded more than just *
17:35:05 <aristid> ddarius: but they already call them type classes in the paper.
17:35:27 <ddarius> There's a little diagram that shows the progression and has constructor classes.
17:35:42 <aristid> hmm
17:35:43 <NisseP> since in class Monad (m :: *), or whatever, m is a type constructor not just a plain ol' type.
17:36:01 <aristid> the diagram has both type classes and constructor classes
17:36:11 <NisseP> m :: * -> *, obviously. dur
17:36:14 <justin___> noob question, how do i call a map function with state threaded through it in the state monad?
17:36:34 <aristid> justin___: mapM?
17:36:52 <ddarius> Haskell 1.0 had type classes which were restricted to "types of kind *", e.g. Eq or Ord but not Functor.  Gofer supported higher kinds, i.e. type constructor classes.  Nowadays "type classes" is used to mean "type constructor classes."
17:37:17 <ddarius> aristid: Yes, type classes are a special case of constructor classes.
17:37:59 <ddarius> However, supporting higher kinded constructor classes is a non-trivial step beyond just type classes in both expressiveness and implementation complexity.
17:38:07 <aristid> haskell 1.0 did not support Functor?
17:38:31 <ddarius> Correct.
17:38:43 <aristid> interesting.
17:39:41 <justin___> aristid: mapM doesn't look like it modifies the state as it goes, is that accurate?
17:39:55 <Jafet> @src mapM
17:39:55 <lambdabot> mapM f as = sequence (map f as)
17:40:04 <Jafet> If it isn't obvious enough by now
17:40:31 <qwern> okay, this is extremely weird: let a = replicate 2 getLine; let a = sequence a; a -> endless input
17:40:54 <ddarius> Why is that weird?
17:40:56 <aristid> :t mapM :: (a -> State s b) -> [a] -> State s [b]
17:40:57 <lambdabot> forall a s b. (a -> State s b) -> [a] -> State s [b]
17:41:29 <aristid> justin___: this is the type of mapM specialized to State.
17:41:33 <qwern> i thought it'd just ask for two lines and return me an IO'd list of strings
17:41:34 <nihtml> :t sequence
17:41:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:41:39 <qwern> ddarius: 
17:41:59 <Jafet> > let a = "lo" ++ a in a
17:42:01 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
17:42:04 <ddarius> qwern: If you literally wrote that though, that would be equivalent to fix sequence which would be a type error.
17:42:07 <ddarius> :t fix sequence
17:42:07 <WHARRGARBL> qwern: a variable can refer to itself
17:42:08 <lambdabot> forall a. [[a]]
17:42:12 <aristid> Jafet: endless output! amazing.
17:42:13 <ddarius> Well, in the IO monad.
17:42:26 <WHARRGARBL> :t fix (ap sequence)
17:42:27 <lambdabot> forall a. [[a] -> a] -> [a]
17:42:32 * WHARRGARBL coughs
17:42:57 <qwern> oh, i see. it disregards the previous let declaration
17:43:03 <WHARRGARBL> > fix (ap sequence) [(+1) . (!!1), const 2, (*3) . (!!0)]
17:43:05 <lambdabot>   [3,2,9]
17:43:06 <Axman6> > fix (ap sequence) [concat, head]
17:43:06 <ddarius> qwern: No, let is recursive.
17:43:08 <lambdabot>   [*Exception: stack overflow
17:43:12 <nihtml> :t sequence [Just 3,Just 4,Just 5]
17:43:13 <lambdabot> forall t. (Num t) => Maybe [t]
17:43:45 <handonson> ugh, can't cabal install xmonad. says "/usr/bin/ld: cannot find -lgmp" ... wasn't this bug fixed in GHC 6.6?
17:43:52 <qwern> no, i mean, i first said a is replicate 2 getLine and then said a is sequence of a
17:43:53 <nihtml> interesting.
17:44:10 <Axman6> handonson: have you install gmp?
17:44:21 <qwern> so the second let declaration ignored the first
17:44:29 <handonson> Axman6: isn't that included in GHC 7?
17:44:59 <aristid> qwern: replicateM 2 getLine is the easy way to do both at the same time.
17:44:59 <qwern> so writing let a = 1; let a = a+1 will endlessly add 1
17:45:00 <Axman6> it's a C library...
17:45:00 <Axman6> you need your system's gmp i think
17:45:03 <thoughtpolice> handonson: no
17:45:14 <handonson> oh.
17:45:19 <justin___> aristid: thanks, that got it
17:45:23 <thoughtpolice> it's not included in binary distributions, and when it compiles, it'll try to link using the compiler's -lgmp option
17:45:54 <aristid> justin___: ghci's :t command is your best friend :)
17:45:54 <nihtml> qwern: yeah
17:46:01 <qwern> aristid: ya, i was just trying to replicate (heh) the replicateM function as defined in http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/src/Control-Monad.html#replicateM
17:46:10 <Cale> It *shadows* the previous let declaration
17:46:13 <aristid> qwern: ah :)
17:46:15 <nihtml> because of recursivity
17:46:32 <aristid> qwern: -Wall should catch shadowing
17:46:41 <ion> let a = a+1. a expands to a+1 which expands to (a+1)+1 which expands to ((a+1)+1) which expands to (((a+1)+1)+1…
17:46:46 <justin___> aristid: I don't know the haskell libraries well enough to even know what to call :t on at this point :)
17:46:55 <nihtml> let a = a+1 is recursive.
17:47:15 <qwern> where's the function which does something similar to $ but instead of rtl it's ltr?
17:47:22 <aristid> justin___: heh
17:47:24 <qwern> i think it's "|-" but not sure
17:47:28 <ion> :t flip ($)
17:47:28 <lambdabot> forall a b. a -> (a -> b) -> b
17:47:36 <aristid> qwern: no standard function for that.
17:47:44 <Axman6> @hoogle 1 -> (a -> b) -> b
17:47:44 <lambdabot> Parse error:
17:47:44 <lambdabot>   --count=20 "1 -> (a -> b) -> b"
17:47:44 <lambdabot>              ^
17:47:45 <qwern> ion: lol
17:47:49 <Axman6> @hoogle a -> (a -> b) -> b
17:47:49 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:47:49 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:47:49 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
17:47:56 <Axman6> fail
17:48:39 <Axman6> @hoogle Arrow arr => a -> arr a b -> b
17:48:40 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
17:48:40 <Axman6> hmm
17:48:40 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
17:48:40 <lambdabot> Control.Monad.State.Strict evalState :: State s a -> s -> a
17:48:46 <aristid> hoogle sometimes mocks you.
17:49:00 <ion> aristid: It’s that time of the month.
17:50:09 <ion> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:a%20-%3E%20(a%20-%3E%20b)%20-%3E%20b except that hayoo is broken and that link doesn’t actually work.
17:50:16 <qwern> aristid: heh
17:50:47 <ion> @hoogle (Util.Computation.#)
17:50:48 <lambdabot> Parse error:
17:50:48 <lambdabot>   --count=20 (Util.Computation.#)
17:50:48 <lambdabot>                   ^
17:51:34 <aristid> :D
17:51:44 <dons> ?pl bestOf metric options = maximumBy (compare `on` metric) options
17:51:44 <lambdabot> bestOf = maximumBy . (compare `on`)
17:52:54 <ddarius> Add more space.
17:55:22 <aristid> dons: maximumBy . on compare would be even shorter.
17:55:42 <WHARRGARBL> comparing ?
17:56:09 <aristid> WHARRGARBL: number of characters in the code
17:56:16 <WHARRGARBL> I mean
17:56:23 <WHARRGARBL> :t maximumBy . comparing
17:56:24 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
17:56:42 <aristid> > map length ["bestOf metric options = maximumBy (compare `on` metric) options", "bestOf = maximumBy . (compare `on`)", "bestOf = maximumBy . on compare"]
17:56:42 <lambdabot>   [63,35,31]
17:57:02 <aristid> > map length ["bestOf metric options = maximumBy (compare `on` metric) options", "bestOf = maximumBy . (compare `on`)", "bestOf = maximumBy . on compare", "bestOf = maximumBy . comparing"]
17:57:03 <lambdabot>   [63,35,31,30]
17:57:12 <WHARRGARBL> aristid: I think you can do better
17:57:25 <WHARRGARBL> > maximumBy . comparing length $ ["bestOf metric options = maximumBy (compare `on` metric) options", "bestOf = maximumBy . (compare `on`)", "bestOf = maximumBy . on compare", "bestOf = maximumBy . comparing"]
17:57:26 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
17:57:26 <lambdabot>         against...
17:57:36 <WHARRGARBL> > (maximumBy . comparing) length ["bestOf metric options = maximumBy (compare `on` metric) options", "bestOf = maximumBy . (compare `on`)", "bestOf = maximumBy . on compare", "bestOf = maximumBy . comparing"]
17:57:38 <lambdabot>   "bestOf metric options = maximumBy (compare `on` metric) options"
17:57:43 <WHARRGARBL> :P
17:57:45 <ion> :-)
17:57:49 <WHARRGARBL> > (minimumBy . comparing) length ["bestOf metric options = maximumBy (compare `on` metric) options", "bestOf = maximumBy . (compare `on`)", "bestOf = maximumBy . on compare", "bestOf = maximumBy . comparing"]
17:57:50 <lambdabot>   "bestOf = maximumBy . comparing"
17:57:53 <aristid> :D
17:57:53 <WHARRGARBL> yay
17:57:57 <qwern>    pi                  =  3.141592653589793238
17:58:04 <gwern> > "mueval-irc.git" // ".git"
17:58:05 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
17:58:05 <lambdabot>         against inferred t...
17:58:08 <qwern> that's how haskell knows what's pi
17:58:09 <gwern> > "mueval-irc.git" / ".git"
17:58:10 <lambdabot>   No instance for (GHC.Real.Fractional [GHC.Types.Char])
17:58:10 <lambdabot>    arising from a us...
17:58:15 <aristid> > showCReal 100 pi
17:58:15 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
17:58:20 <gwern> @hoogle [a] -> [a] -> [a]
17:58:21 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
17:58:21 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
17:58:21 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
17:58:31 <Zao> gwern: Looking for System.FilePath.(</>)?
17:58:31 <ion> pi = 3
17:58:41 <aristid> qwern: no, pi is obviously defined much more precisely, depending on the data type :)
17:58:48 <nihtml> :t comparing
17:58:49 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:58:51 <aristid> qwern: CReal knows pi with infinite precision
17:58:56 <gwern> Zao: nah, I want to strip .git but without doing the usual reverse . drop 4 . reverse dance
17:59:16 <aristid> gwern: look in System.FilePath maybe?
17:59:19 <gwern> > "mueval-irc.git" \\ ".git"
17:59:19 <Jafet> You mean (reverse.).(.reverse)?
17:59:20 <lambdabot>   "mueval-rci"
17:59:24 <aristid> :D
17:59:54 <qwern> aristid: ooh.
18:00:06 <qwern> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/src/GHC-Float.html#pi
18:00:29 <gwern> we even have a strip prefix function, but no strip suffix. hrm
18:00:32 <qwern> so it depends on which library defines it
18:00:59 <dibblego> where is instance Traversable (Writer w) ?
18:01:10 <qwern> and i see there are two definitions, one for double and one for float
18:01:40 <aristid> gwern: http://hackage.haskell.org/packages/archive/filepath/latest/doc/html/System-FilePath-Posix.html#3
18:02:18 <aristid> > dropExtension "mueval-irc.git"
18:02:19 <lambdabot>   Not in scope: `dropExtension'
18:02:29 <aristid> > System.FilePath.dropExtension "mueval-irc.git"
18:02:30 <lambdabot>   Not in scope: `System.FilePath.dropExtension'
18:02:32 <aristid> :(
18:03:01 <gwern> aristid: I see
18:04:07 <ion> qwern: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/src/Data-Number-CReal.html
18:04:23 <nihtml> > System.FilePath.Posix.dropExtension "mueval-irc.git"
18:04:24 <lambdabot>   Not in scope: `System.FilePath.Posix.dropExtension'
18:07:51 <aristid> :t pi
18:07:52 <lambdabot> forall a. (Floating a) => a
18:07:57 <aristid> @instances Floating
18:07:58 <lambdabot> Double, Float
18:08:06 <aristid> not quite comprehensive
18:08:53 <mm_freak> dibblego: how is a writer traversable?
18:09:03 <dibblego> traverse f (Writer w a) = fmap (Writer w) (f a)
18:10:27 <aristid> :t traverse
18:10:28 <lambdabot> Not in scope: `traverse'
18:10:35 <aristid> :t T.traverse
18:10:36 <lambdabot> Couldn't find qualified module.
18:10:52 <aristid> :t Data.Traversable.traverse
18:10:53 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
18:11:02 <azaq23> > foldr `id` const (+) undefined `id` 0 `id` [0 .. 10]
18:11:03 <lambdabot>   55
18:22:52 <aristid> @hoogle Dual
18:22:52 <lambdabot> Data.Monoid newtype Dual a
18:22:53 <lambdabot> Data.Monoid Dual :: a -> Dual a
18:22:53 <lambdabot> Data.Monoid getDual :: Dual a -> a
18:26:23 <gwern> preflex: @seen jaspervdj 
18:26:23 <preflex>  jaspervdj was last seen on #haskell 3 days, 12 hours, 15 minutes and 29 seconds ago, saying: tibbe: I might write up another proposal if I have time tonight but it will be less elaborate
18:57:15 <metaliving> i'm trying to install the network library but i get this
18:57:16 <metaliving> Network/Socket.hsc:1701:11: Ambiguous occurrence `closeFdWith'
18:57:16 <metaliving>     It could refer to either `Network.Socket.closeFdWith',
18:57:16 <metaliving>                              defined at Network/Socket.hsc:1046:1
18:57:16 <metaliving>                           or `GHC.Conc.closeFdWith',
18:58:17 <mm_freak> metaliving: perhaps you should start with the haskell platform, where 'network' and many other useful libraries are already included
18:58:52 <mm_freak> metaliving: http://hackage.haskell.org/platform/
18:59:09 <metaliving> ok, thanks, i'll do that
18:59:39 <metaliving> though it's strange because the fix is supposedly to upgrade cabal but cabal can't upgrade if it can't install network
18:59:43 <metaliving> anyway
19:07:08 * hackagebot LibClang 0.0.6 - Haskell bindings for libclang (a C++ parsing library)  http://hackage.haskell.org/package/LibClang-0.0.6 (ChetanTaralekar)
19:24:17 <chomp> Given this: foldl (\acc x -> do putStrLn x; (:)<$>getLine<*>acc) (return []) ["a:","b:","c:"]
19:24:34 <chomp> I would expect to be prompted in sequence by "a:", "b:", then "c:"
19:24:50 <chomp> i'm obviously wrong, because it happens in the reverse of that order.  why?
19:25:18 <byorgey> > foldl (+) 0 [a,b,c]
19:25:19 <lambdabot>   0 + a + b + c
19:25:20 <shachaf> > foldl f z [a,b,c]
19:25:21 <lambdabot>   f (f (f z a) b) c
19:25:27 <ivanm> use foldr rather than foldl
19:25:47 <byorgey> > foldr f z [a,b,c]
19:25:48 <lambdabot>   f a (f b (f c z))
19:26:24 <sanjoyd>  > (\x -> x x) (\x -> x x)
19:26:43 <shachaf> Also, use mapM rather than a fold. :-)
19:27:03 <chomp> well yeah, i'm just experimenting though ^^
19:27:07 <shachaf> > mapM (\x -> do putStr x; getLine) ["a:","b:","c:"]
19:27:08 <lambdabot>   <IO [[Char]]>
19:27:09 <sanjoyd> chomp: what is <$>?
19:27:14 <shachaf> @src <$>
19:27:15 <lambdabot> f <$> a = fmap f a
19:27:24 <Berengal> Foldl actually works from the end of the list and forward. Foldr actually works from the start of the list and backwards.
19:27:30 <sanjoyd> @src <*>
19:27:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:28:15 <chomp> oh, Berengal.  that clears it up.  so the direction is the direction of motion, not which end of the input starts the fold
19:28:31 <chomp> err.
19:28:55 <shachaf> chomp: The direction is the associativity of the parentheses.
19:29:14 <shachaf> foldr f z replaces : with `f` and [] with z
19:29:41 <handonson> oh GOD
19:29:52 <handonson> the xmonad website says “That was easy. xmonad rocks!”
19:29:53 <handonson> LIAR
19:30:04 <Berengal> chomp: In a strict language, it's the opposite. In a lazy language however, foldl has to traverse the entire list first, pushing every element onto a "stack" (the final expression is a deeply nested one). The top of the stack is then the last element. Typically, however, it will force the rest of the stack before returning anything
19:30:09 <handonson> spent the whole morning and still can't get it working
19:30:18 <djahandarie> handonson, is there something you need help with? #xmonad provides xmonad-specific help
19:30:18 <mm_freak> NixOS sounds like a great idea…  has anyone used it in production and/or is doing haskell development on it?
19:30:49 <handonson> oh cool
19:31:00 <JoeyA> I can implement a windowing manager using Xmonad.  It's really easy.
19:31:10 <JoeyA> Done.
19:31:14 <JoeyA> I even have a website up: http://xmonad.org/
19:31:29 <JoeyA> (kidding, of course.  I had nothing to do with it)
19:33:05 <mm_freak> although "purely functional package management" sounds funny, it seems to be serious stuff, and the documentation makes it sound really tasty…  i like the declarative system configuration approach
19:33:08 <ivanm> mm_freak: kosmikus does I believe
19:33:37 <JoeyA> I've had fantasies of a lazy functional file system.
19:33:46 <Eduard_Munteanu> Like NixOS stuff?
19:33:57 <mm_freak> Eduard_Munteanu: NixOS is what i'm talking about
19:34:12 <Eduard_Munteanu> Ah.
19:34:19 <JoeyA> Instead of invoking a "build" command, a program's build could be defined as a function.
19:34:22 * ddarius didn't know "rustic" could be made into a verb.
19:34:23 <mm_freak> JoeyA: i don't care so much for lazy filesystems, but i'd really like a typed filesystem
19:34:40 <JoeyA> I feel the same way about C.
19:35:12 <chomp> i want a lazy database
19:35:15 <mm_freak> but i think it's almost impossible to get a typed filesystem in any of the currently existing operating systems
19:35:18 <JoeyA> Yup.
19:35:31 <JoeyA> chomp: One idea I thought of for that would be a "single-value store".
19:35:35 <Eduard_Munteanu> What would be typed about a filesystem?
19:35:39 <JoeyA> That's not something you can do in a non-lazy language.
19:35:52 <mm_freak> Eduard_Munteanu: files would have types
19:35:57 <JoeyA> The interface would be little more than getting and setting a typed value stored in a file.
19:36:08 <mm_freak> Eduard_Munteanu: readFile :: FileType a => FilePath -> IO a
19:36:26 <mm_freak> Eduard_Munteanu: well, almost
19:36:48 <mm_freak> a typed filesystem would probably through exceptions instead of static checking
19:36:59 <mm_freak> through → throw
19:37:00 <Anpheus__> I was in here a few weeks ago
19:37:10 <Anpheus__> and someone showed symbolic differentiation in Haskell
19:37:27 <Anpheus> What module was that and where can I find the source?
19:37:35 <Anpheus> It was on lambdabot but I don't know how to invoke it.
19:37:35 <Eduard_Munteanu> @hackage ad
19:37:35 <lambdabot> http://hackage.haskell.org/package/ad
19:37:43 <Anpheus> Thank you very much
19:37:44 <jmcarthur> ad isn't symbolic differentiation
19:37:54 <chomp> or perhaps no exceptions and just readFile :: FileType a => FilePath -> Maybe (IO a) 
19:37:56 <Eduard_Munteanu> jmcarthur: how come?
19:37:57 <jmcarthur> it's automatic differentiation, isn't it?
19:38:07 <mm_freak> chomp: Maybe (IO a)?
19:38:08 <JoeyA> The internal implementation of a "single-value store" would use stablenames to optimize.
19:38:25 <JoeyA> So you could say: alterDB (1:) "file.db"
19:38:39 <jmcarthur> Eduard_Munteanu: automatic differentiation is not the same as symbolic differentiation
19:38:57 <chomp> IO (Maybe a), rather
19:39:02 <Eduard_Munteanu> @hoogle deriv
19:39:02 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
19:39:08 <Eduard_Munteanu> > deriv sin $ x
19:39:08 <lambdabot>   1 * cos x
19:39:19 <mm_freak> chomp: makes sense, but i don't like that approach
19:39:20 <JoeyA> It would semantically take the contents of the database, prepend a number, then store the result into the file.  Stable names could prevent having to rewrite all those values, allowing you to manipulate the database in an efficient and functional manner.
19:39:20 <jmcarthur> yeah ad can't do that
19:39:21 <Eduard_Munteanu> Hrm, I thought that's what AD did.
19:39:28 <Axman6> > deriv sin $ 2 * x
19:39:29 <lambdabot>   1 * cos (2 * x)
19:39:29 <jmcarthur> ad works with values
19:39:33 <chomp> i'm not a fan myself, but i was only joking :)
19:39:34 <jmcarthur> err, numbers
19:39:50 <mm_freak> chomp: though you were joking that approach is actually used in practical haskell
19:39:53 <Eduard_Munteanu> Anpheus: you might want to get lambdabot then and look inside
19:39:56 <parcs> > deriv $ sin ^ 2 $ x
19:39:56 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
19:39:57 <lambdabot>                        ...
19:39:59 <mm_freak> chomp: the 'catch' combinator uses it, for example
19:40:17 <mm_freak> chomp: kind of RTTI
19:40:32 <Anpheus> Ok, is there any implementation of symbolic differentiation in Haskell using, I'd guess GADTs?
19:40:33 <jmcarthur> actually ad could probably do it if you defined some expression adt with a Num instance and used it with ad
19:40:39 <mm_freak> that's why exception types need to be an instance of Typeable
19:40:49 <chomp> interesting
19:40:54 <Eduard_Munteanu> Yeah, Oleg did it, thought not using GADTs AFAIK.
19:41:01 <jmcarthur> but it might not give the simplest results unless you write a simplifier too
19:41:02 <parcs> > deriv (sin ^ 2) x
19:41:03 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x)
19:41:03 <Eduard_Munteanu> *though
19:41:29 <Eduard_Munteanu> > deriv atan x
19:41:30 <lambdabot>   1 * recip (x * x - 1)
19:41:37 <Anpheus> @src deriv
19:41:37 <lambdabot> Source not found. My brain just exploded
19:41:40 <Anpheus> :/
19:41:43 <sanjoyd> What is this deriv? How does it work?
19:41:46 <Anpheus> Where is that coming from?
19:41:52 <jmcarthur> hmm, this is looking a lot like what ad does, just symbolically :)
19:42:11 <shachaf> @google automatic differentiation in haskell
19:42:11 <lambdabot> http://www.haskell.org/haskellwiki/Automatic_Differentiation
19:42:12 <lambdabot> Title: Automatic Differentiation - HaskellWiki
19:42:17 <thoughtpolice> you can do symbolic-style differentiation using the 'numbers' package by lennart
19:42:26 <thoughtpolice> http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Dif.html
19:42:45 <thoughtpolice> it'll also do automatic differentiation on actual numbers, e.g. f x = x*x, deriv f = 2*x
19:43:05 <ian_mi> why can't I use a State s a as a StateT s Identity a?
19:43:33 <sanjoyd> deriv exp x
19:43:36 <sanjoyd>  > deriv exp x
19:43:51 <jmcarthur> ian_mi: i believe they are literally the same thing in mtl 2, but maybe not in mtl 1
19:43:53 <thoughtpolice> > deriv $ x * x
19:43:53 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
19:43:53 <lambdabot>                        ...
19:43:59 <thoughtpolice> haha
19:44:02 <ian_mi> oh :(
19:44:03 <thoughtpolice> it uses the numbers package
19:44:06 <thoughtpolice> question answered :)
19:44:27 <shachaf> > deriv (\x -> x*x) x
19:44:28 <lambdabot>   1 * x + x * 1
19:44:38 <Eduard_Munteanu> Anpheus: ^
19:44:47 <sanjoyd>  > deriv exp x x
19:45:01 <sanjoyd>  > deriv (exp x) x
19:45:06 <Axman6> > deriv exp x x
19:45:07 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
19:45:07 <lambdabot>         against infe...
19:45:07 <coWHARRGARBL> > deriv exp x
19:45:07 <shachaf> > deriv exp x -- It only works if your name doesn't start with 's'.
19:45:08 <lambdabot>   1 * exp x
19:45:08 <lambdabot>   1 * exp x
19:45:10 <jmcarthur> > iterate deriv $ (sin ^ 2) x
19:45:11 <lambdabot>   Occurs check: cannot construct the infinite type:
19:45:11 <lambdabot>    a = Data.Number.Dif.Di...
19:45:19 <Axman6> > deriv exp x $ x
19:45:19 <lambdabot>   Couldn't match expected type `a -> b'
19:45:20 <lambdabot>         against inferred type `Simple...
19:45:20 <jmcarthur> :t deriv
19:45:21 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
19:45:25 <jmcarthur> aha
19:47:52 <parcs> > deriv id x
19:47:52 <lambdabot>   1
19:48:58 <shachaf> > deriv (deriv id) x
19:48:59 <lambdabot>   0
19:49:24 <parcs> > deriv 5 x
19:49:25 <lambdabot>   0
19:49:37 <parcs> another awesome application of the function instance of Num :P
19:49:56 <shachaf> > deriv (id^2 + 5 * id) x
19:49:57 <lambdabot>   1 * x + x * 1 + 5 * 1
19:51:07 <Eduard_Munteanu> > deriv (x*y) x
19:51:08 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
19:51:08 <lambdabot>                        ...
19:51:55 <Eduard_Munteanu> > deriv show x    -- :P
19:51:56 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif b'
19:51:56 <lambdabot>         against inferr...
19:53:10 <sanjoyd> Where is the source for deriv?
19:55:20 <parcs> sanjoyd: http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/src/Data-Number-Dif.html#deriv
19:59:33 <chomp> > ap mod<*>(31-)<$>[1..30]
19:59:34 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
19:59:43 <chomp> nonsense
20:00:13 <chomp> wat do.  ghci has no problem with that.
20:01:37 <coWHARRGARBL> > mod<*>(31-)<$>[1..30]
20:01:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,1,3,5,7,9,1,4,7,3,1,1,3,1,1,0]
20:01:46 <coWHARRGARBL> I'd hope it would have a problem with that
20:02:28 <chomp> i've only inferred from observation that the "ap" was needed to utilize applicatives in on lambdabot
20:02:33 <chomp> guess i don't know wtf is going on ^^
20:02:48 <shachaf> chomp: ap x y z = x z (y z)
20:02:58 <chomp> oh, shows what i know.  
20:03:07 <sanjoyd> ap is S combinator?
20:03:09 <coWHARRGARBL> ap is a function like any other
20:03:17 <shachaf> sanjoyd: In the (r ->) monad, yes.
20:03:22 <chomp> well either way i think i win the golf from like 4 hours ago :)
20:03:29 <Eduard_Munteanu> :t ap
20:03:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:03:48 <ion> > ap f g a
20:03:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:03:49 <lambdabot>    `GHC.Show.Show a'
20:03:49 <lambdabot>      a...
20:03:55 <ion> > ap f g a :: Expr
20:03:55 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:03:56 <lambdabot>    `SimpleReflect.FromExpr ...
20:03:57 <ion> meh
20:04:05 <chomp> ah, i was unaware of the existence of ap
20:05:23 <coWHARRGARBL> > ap (f :: Expr -> Expr -> Expr) g a
20:05:27 <lambdabot>   f a (g a)
20:05:45 <sanjoyd> :t Expr
20:05:46 <lambdabot> Not in scope: data constructor `Expr'
20:05:56 <chomp> that looks familiar... same form as <*> but over Monads?
20:06:11 <ion> Ah, thanks
20:06:51 <ian_mi> can someone help me understand why I have m :: StateT a IO () and x :: a I can't do evalState (forever m) x and see the IO with each state transformation?
20:15:11 <ian_mi> either that or suggest an alternative approach to what I'm string to do?
20:16:03 <ian_mi> trying even
20:16:03 <ivanm> ian_mi: if I understand what you're saying, it's because the evalState basically hides the fact that all the intermediate state operations are combined into one big one
20:16:19 <ivanm> and thus there's only one "real" StateT operation to evaluate
20:17:54 <ian_mi> hmm, I guess I was thinking that as it tries to evaluate that StateT it would perform IO
20:19:19 <ian_mi> but you're saying it has to evaluate the StateT before it can perform any IO
20:19:30 <ian_mi> ?
20:20:08 <ivanm> ummmm, I'm a little hazy on transformers like that
20:20:27 <ian_mi> ah, oh well
20:26:54 <ian_mi> haha, ok but evalState (foldM_ (const (const m)) () (repeat ())) x works
20:28:22 <ian_mi> as does evalState (sequence_ (repeat m)) x
20:29:10 <ian_mi> would have thought that forever = sequence_ . repeat
20:57:15 <Berengal> Does anyone want to check this function for correctness? http://hpaste.org/45561/wbs
20:57:38 <osoleve> looks good to me, but what do i know?
20:57:46 <dibblego> feels correct in my bones
20:57:50 <ddarius> It correctly does whatever it is that it does.
20:58:38 <Berengal> Eh, typoes: http://hpaste.org/45562/wbs_annotation
20:59:49 <Berengal> It's basically a way to call C-functions of (foo *data, size_t len) with bytestrings
20:59:58 <ddarius> Berengal: See kmc's slides.  There's a function similar to this.
21:01:10 <Berengal> ddarius: I lost the link
21:01:41 <djahandarie> Berengal, http://t0rch.org
21:01:52 <djahandarie> I don't remember a function like this though
21:02:02 <djahandarie> ddarius has better memory than me though so it's probably there :p
21:02:45 <ddarius> setInputBuffer on slide 16 does a similar sort of thing for a particular case.
21:02:51 <ddarius> At any rate, Berengal's code seems fine.
21:03:07 <djahandarie> Ah
21:03:56 <Berengal> His code is what basically what I had before, but then I encountered sizeof(a[0]) == 2 arrays...
21:04:11 * hackagebot silently 1.1.1 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.1.1 (TrystanSpangler)
21:04:22 <Berengal> So I had to adjust the size
21:05:27 <Berengal> Anyway, thanks for the help guys
21:05:36 <ddarius> If these are arrays of a's, you need to worry about alignment issues as well.
21:06:40 <ddarius> Though I guess as long as the initial pointer is aligned (which it should be) the rest will be handled correctly.
21:09:15 <Berengal> Yes, /someone/ needs to worry about alignment issues, but that someone isn't me. It's whomever's constructing the array in the first place.
21:34:28 <copumpkin> this is a cute idea: https://github.com/trystan/silently
21:35:25 <JoeyA> cool
21:35:32 <Jafet> With hidden razor fangs
21:35:49 <JoeyA> Then someone will write a yell :: String -> IO ()
21:36:19 <JoeyA> Then a ShutTheFunctorUp module might crop up later.
21:36:35 <copumpkin> lol
21:36:53 <copumpkin> hmm, it creates a temporary file
21:36:58 <copumpkin> looks like it could get by easily with a pipe
21:37:14 <ivanm> copumpkin: it creates a file on non-standard OSs
21:37:29 <ivanm> on Windows, OSX and Linux it uses /dev/null and equivalents
21:37:32 <copumpkin> I just looked in the unix folder and it creates a file for capture
21:37:41 <chomp> seems to create a tmp file on all platforms
21:37:45 <ivanm> oh? you mean the release notes lied? :o
21:37:56 <copumpkin> well, it does use /dev/null on unix for silence
21:37:59 <copumpkin> but not for capture
21:38:03 <ivanm> ahhhhh
21:38:03 <copumpkin> it could use a pipe for capture and silence
21:38:29 <ivanm> are pipes cross-platform?
21:38:34 <ivanm> i.e. does Windows have pipes?
21:38:38 <copumpkin> I doubt it, but it's good enough for unix
21:38:42 <copumpkin> which is all I care about :P
21:38:47 <copumpkin> I'm sure windows has something vaguely similar
21:39:02 <copumpkin> oh it appears to
21:39:19 <ddarius> Yes, it does.
21:39:19 <chomp> sure does
21:39:42 <ddarius> NTFS has actually been able to do quite a few interesting things for a long while that apparently no one ever uses.
21:39:44 <chomp> i think it got named pipes in win2k
21:39:51 <copumpkin> oh, but I mean non-file pipes
21:39:53 <copumpkin> like man 2 pipe
21:40:23 <copumpkin> I'd imagine it probably has something like that too
21:40:51 <chomp> yeah most posix stuff exists in the runtime under ugly names like _pipe
21:40:53 <Jafet> It even has some kind of file resource forks, similar to mac os's
21:41:13 <copumpkin> ah
21:42:52 <ddarius> Jafet: Yep.
21:43:22 <Jafet> Naturally, approximately zero percent of windows programs know it exists
21:48:04 <chomp> wasn't familiar with resource forks at all, but at a glance it seems like a poor abstraction
21:52:23 <saikobee> What is this sort of feature called in Haskell?   foo {bar=baz, jim=jill}
21:52:30 <saikobee> I wanna know so I can go read up on it
21:53:05 <c_wraith> it's record update syntax
21:53:13 <Jafet> @where cheatsheet
21:53:13 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
21:53:35 <saikobee> Thanks c_wraith Jafet
22:28:05 <hinkes> Hey all, newbie question for the haskell masses.
22:28:50 <hinkes> How do I use Data.Binary.decode with a Data.ByteString?
22:31:21 <shachaf> hinkes: Seems like it gets a lazy ByteString.
22:33:53 <hinkes> it looks like it takes a: bytestring-0.9.1.5:Data.ByteString.Lazy.Internal.ByteString
22:39:43 <shachaf> hinkes: You are not contradicting what I said.
22:40:47 <hinkes> Yeah, I have a simple Data.ByteString.ByteString and decode won't take it ;-(
22:41:57 <hinkes> correction Data.ByteString.Lazy.ByteString
22:43:45 <copumpkin> it's harblcat!
22:43:52 <copumpkin> preflex: seen harblcat
22:43:52 <preflex>  harblcat was last seen on #haskell-blah 275 days, 23 hours, 39 minutes and 33 seconds ago, saying: I'm going to ruminate on this a bit. thanks for the information :)
22:44:35 <harblcat> hi?
22:46:15 <olsner> ruminating for 275 days, well done!
22:47:11 <harblcat> haha, I actually forget what I was ruminating on...
22:48:46 <harblcat> Oh, it was something to do with entropy and information content, in relation to using a string of die rolls to get any dX result
22:51:44 <hinkes> Ahh .. I think I have two versions of binary and bytestring (local versus global)
23:13:25 <lpsmith> Explicit constructor signatures are kind of sweet
23:14:01 <lpsmith> on the other hand,  it makes the fact that Functor and Applicative are not superclasses of Monad a bit frustrating
23:21:34 <hinkes> Ok, got it to work
23:21:47 <hinkes> I had to shoot cabal and remove ~/.cabal and ~/.ghc
23:31:28 * hackagebot tls-extra 0.1.9 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.9 (VincentHanquez)
23:36:27 <Dashkal> Need a nudge.  I'm trying to write an indexing function [a] -> Map b [a] where be is an attribute of a.  This sounds like a solved problem but I can only think of a sequential/imperative way to do it.
23:37:55 <dibblego> "b is an attribute of a" meaning there exists a function (a -> b) ?
23:38:04 <Dashkal> yes
23:39:43 <Dashkal> So [a] -> (a -> b) -> Map b [a]
23:40:07 <dibblego> [a] -> (a -> b) -> Map b a ?
23:40:15 <mauke> @hoogle [a] -> (a -> b) -> Map b [a]
23:40:15 <lambdabot> No results found
23:40:34 <Dashkal> No, Map b [a].  There may be multiple as for a given b.
23:40:58 <dibblego> then Eq a => ?
23:41:26 <Dashkal> sorry?
23:41:51 <mauke> :t \f -> foldl' (\z x -> M.insertWith' (++) (f x) [x] z) M.empty
23:41:51 <lambdabot> forall b k. (Ord k) => (b -> k) -> [b] -> M.Map k [b]
23:42:26 <Dashkal> that does indeed look right
23:42:32 <Axman6> why not?
23:42:43 <Axman6> that's almost exactly what i was about to type
23:42:57 <Dashkal> ? I said it looks right
23:42:57 <Axman6> but with it being less wrong than what i was going to type =)
23:43:23 <Axman6> urgh, lack of sleep is having a very bad affect on me i see -_-
23:43:42 <Dashkal> Now I just need insertWith for the maps I'm working with, but I can deal with that.  Thank you :)
23:43:59 <mauke> \t -> M.fromListWith (++) . map (f &&& return)
23:44:04 <mauke> :t \f -> M.fromListWith (++) . map (f &&& return)
23:44:04 <lambdabot> forall k a (m :: * -> *). (Monoid (m a), Ord k, Monad m) => (a -> k) -> [a] -> M.Map k (m a)
23:44:05 <dibblego> scala has no equivalent, it's maps are busted
23:44:44 <mauke> :t \f -> M.fromListWith (++) . map (f &&& (: []))
23:44:45 <lambdabot> forall k a. (Ord k) => (a -> k) -> [a] -> M.Map k [a]
23:48:48 <Dashkal> dibblego: I was planning on sidestepping that by working with (b, a)
23:49:36 <Dashkal> I should be able to do Eq b => [(b, a)] -> [(b, [a])]
23:50:09 <dibblego> you probably want NonEmptyList a and not [a]
23:50:47 <Dashkal> Actually, that doesn't matter for my purpose.  It won't break things to get an empty a (even if it's nonsensical)
23:51:20 <mauke> :t groupBy
23:51:21 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
23:51:24 <Dashkal> I just iterate over the [a] in my lookup code.  If it's empty, there were no results.
23:51:33 <mauke> :t groupBy ((==) `on` fst)
23:51:35 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [[(a, b)]]
23:52:27 <mauke> :t map ((fst . head) &&& map snd) . groupBy ((==) `on` fst)
23:52:27 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [(a, [b])]
23:54:54 <Dashkal> Perfect.  Thanks for the help.  Now to make this work in my case.  groupBy should do it.
