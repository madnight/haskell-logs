00:00:40 <lispy> Balahla: http://www.zlib.net/zlib_faq.html#faq11
00:01:17 <lispy> Balahla: maybe this library does what you want? http://hackage.haskell.org/package/zip-archive
00:02:49 <Balahla> Thanks. I'm gonna try it.
00:03:37 <amalloy> i'm currently working through LYAH from just the ghci repl, rather than messing with editing source files and having it load them. but i can't figure out how to define a new data type: when i enter anything starting with "data", it complains about a parse error
00:04:04 <ion> At the moment you can't.
00:05:58 <lispy> amalloy: ghci is for loading code, browsing defintions, and evaluating expressions.  defining new data types requires using a file
00:06:29 <lispy> amalloy: you can easily reload the file once you have it by typing :r
00:06:36 <amalloy> well, color me surprised. okay, anyone know where i can find a decent emacs haskell-mode? various documentation seems to suggest it should be able to interact with ghci in an inferior-haskell sort of buffer, but i haven't found a version that actually does this?
00:07:40 <ivanm> amalloy: they all do...
00:07:50 <ivanm> C-c C-l will load your file in ghci
00:08:37 <amalloy> ivanm: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs, for example, links to an empty directory
00:08:42 <amalloy> and is the first hit on google
00:08:58 <ivanm> yes; it hasn't been updated after the server migration
00:09:01 <ion> Anyone's free to contribute an extension for local types. It would be appreciated. :-)
00:09:09 <lispy> amalloy: http://code.haskell.org/haskellmode-emacs/
00:09:42 <ivanm> lispy: dammit, you beat me to it!
00:10:14 <ivanm> @ask Baughn a few people have commented that the haskellmode home page ( http://projects.haskell.org/haskellmode-emacs/ ) wasn't updated after the server migration
00:10:14 <lambdabot> Consider it noted.
00:10:26 <amalloy> thank you. i've found a remarkable number of out-of-date modes
00:10:30 <amalloy> this one looks good
00:10:42 * lispy has given up on the server migration stuff getting fixed and now just uses other urls.
00:11:02 <ivanm> I really should re-activate my account and put the stuff back up there...
00:11:11 <ivanm> but that involved turning another machine on to get the ssh key off of it :s
00:11:49 <lispy> I'm just moving more and more stuff into the cloud elsewhere.  I'm happy with the reliability and speed of github so far so I've been using that almost exclusively.
00:12:03 <ivanm> I still like darcs
00:12:06 <amalloy> hrm. but...there's no apparent tgz file or anything. surely i'm not supposed to download each file separately?
00:12:11 <ivanm> and the ability to chuck random files up in my page
00:12:16 <ivanm> amalloy: yup
00:12:19 <ivanm> wget ftw! ;)
00:12:24 <amalloy> ouch
00:12:45 * ivanm looks for a tarball
00:12:50 <amalloy> but okay, so long as i'm not missing something better
00:12:55 <lispy> ivanm: Being forced to learn git for work and then discovering github made me switch.  Github is really the best part about git and it's ahead of the darcs competetion by a lot (patch-tag/darcsden)
00:13:07 <lispy> amalloy: darcs get http://code.haskell.org/haskellmode-emacs/
00:13:17 <ivanm> lispy: I'm having to use git for some other projects; it makes sense, but i still prefer git
00:13:23 <ivanm> and I'm still resisting getting a github account ;)
00:13:27 <lispy> ivanm: you mean prefer darcs?
00:13:29 <amalloy> yeah, then i'd have to use darcs instead of git :)
00:13:35 <ivanm> lispy: ummm, yeah ;)
00:13:41 <ivanm> amalloy: it already uses darcs...
00:13:48 <ivanm> I think there are some git mirrors of it on github though
00:13:58 <amalloy> ivanm: my point is i don't have darcs installed and have no real plans to learn it
00:14:23 <lispy> amalloy: cabal install darcs && darcs get http://code.haskell.org/haskellmode-emacs/ # done, nothing to learn and files downloaded
00:14:26 <ivanm> amalloy: "cabal install darcs", use that command that lispy gave you, and then that's it
00:14:36 <ivanm> lispy: --lazy!
00:14:43 <lispy> ivanm: good call
00:14:51 <ivanm> assuming it's a darcs-2 repo; but I think it's new enough to be
00:15:04 <lispy> if it's not, darcs will just do something reasonable
00:15:13 <lispy> Like, degrade gracefully
00:15:19 <ivanm> yup
00:16:45 <lispy> someone really needs to write git-darcs
00:16:55 <lispy> if you could put your darcs repos on github that would be really swell
00:17:24 <lispy> instant ability to do code-reviews and patch tracking on any darcs project via github
00:17:54 <ivanm> I'm not sure how well they'll integrate
00:17:59 <ivanm> especially with git branches
00:18:25 <ivanm> took me a while to "get" git because I didn't realise the existence of the staging area
00:18:45 * ivanm still prefers darcs' UI and workflow
00:19:30 <blackdog> ivanm: curmudgeon:)
00:19:31 <lambdabot> blackdog: You have 1 new message. '/msg lambdabot @messages' to read it.
00:19:42 <ivanm> blackdog: in what sense?
00:19:48 <lispy> ivanm: well, if someone can solve those problems with svn inside git, then I'm sure we can solve darcs inside git.
00:20:26 <ivanm> from what I recall from SVN (only used it for a brief period about 5 years ago), it's general workflow is closer to git's than git's is to darcs'
00:20:26 <blackdog> @tell mzero hasn't happened yet - meaning to ask, how long did it take to get through those three chapters?
00:20:27 <lambdabot> Consider it noted.
00:20:38 <ivanm> especially since darcs lets you do patches that aren't an entire file
00:21:18 <blackdog> ivanm: remnants of a long argument about github
00:21:28 <blackdog> ivanm: git lets you do that too...
00:21:37 <ivanm> oh? how?
00:21:55 <ivanm> AFAICT it's just "git add <files> && git commit"
00:22:07 <ivanm> I haven't seen any way of recording which sub-parts you want to commit
00:22:10 <MatrixFrog> not sure what you mean, but look at "git add -p"
00:22:11 <blackdog> look for git commit --interactive
00:22:19 <ivanm> ooooh
00:22:20 <blackdog> you can choose individual hunks of changes in a file
00:22:42 <ivanm> though didn't someone (nomeata?) write a program to use darcs-as-a-library just to be able to do that?
00:22:49 <ivanm> or is it just because git's UI sucks?
00:22:49 <lispy> ipatch
00:23:09 <lispy> http://hackage.haskell.org/package/ipatch
00:23:35 <ivanm> still using darcs-beta? :s
00:24:45 <td123> I have a simple question, why does foldr max 0 [] not error out? since max requires to parameters and we supply a base (0) but the list is empty, so we can't feed it the 2nd parameter
00:25:00 <amalloy> td123: you never call max at all
00:25:07 <ivanm> td123: because when it gets to the empty list, it doesn't use the function
00:25:10 <ivanm> just returns the value
00:25:15 <ivanm> > foldr f a []
00:25:15 <td123> ah
00:25:16 <lispy> ?src foldr
00:25:16 <lambdabot>   a
00:25:16 <lambdabot> foldr f z []     = z
00:25:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:25:20 <boegel> when I do something like "take 5 $ sort list", does the list get sorting completely to determine the 5 smallest elements (list is way bigger than 5 in my case)
00:25:34 <ivanm> boegel: just the first 5
00:25:42 <td123> ok thanks!
00:26:13 <lispy> > take 4 $ sort [1,2,3,4,5,undefined]
00:26:14 <lambdabot>   *Exception: Prelude.undefined
00:26:31 <boegel> ivanm: how does that work exactly? laziness is part of it, but I don't see how sort can "short-circuit" if you apply take to its result... does the compiler take care of translating that expression to something else?
00:26:42 <boegel> lispy: ouch :)
00:26:44 <amalloy> lispy: i don't think it's necessarily *exactly* the first five that get sorted, surely?
00:26:48 <amalloy> but not all of them
00:26:54 <ivanm> boegel: laziness
00:27:18 <lispy> boegel: it does have to compare all of them
00:27:29 <lispy> It's not clear to me how lazy Prelude.sort is
00:27:32 <ivanm> lispy: well, it will still look through all of them, won't it?
00:27:40 <ivanm> since it needs to find the smallest value, etc.
00:27:46 <lispy> boegel: if you have an Ord constraint, Data.Set is actually faster when you have only unique elements.
00:27:48 <ivanm> it just won't bother finding the 6th smallest value
00:27:50 <boegel> ivanm: the runtime knows only the first part of the list needs to be sorted?
00:28:01 <ivanm> boegel: maybe I misunderstood what you were asking
00:28:12 <boegel> lispy: list is not just unique elements in my case
00:28:25 <ivanm> boegel: it will find the first 5 smallest values but won't bother sorting the rest
00:28:40 <ivanm> so it _will_ go through the entire list
00:28:43 <boegel> ivanm: makes sense, but I'm just wondering how that can work
00:28:55 <boegel> ivanm: it need to, to determine the 5 smallest :)
00:28:59 <ivanm> you could probably go with a selection sort to make it even lazier
00:29:13 <ivanm> because GHC uses a merge sort IIRC
00:29:13 <lispy> boegel: So, given a sufficiently lazy "sort", it would only have to produce the first 5 elements of the list.  But, what I'm not sure about is whether the implementation of sort in the Prelude is that lazy.  It's a merge sort, and you could use equational reasoning based on the actual implementation to figure this out, I think.
00:29:20 <boegel> ivanm: I can imagine that implementing my own sort would be faster
00:29:44 <amalloy> boegel: people who say that are rarely right :P
00:29:50 <amalloy> in general
00:30:01 <boegel> amalloy: heh, point taken :)
00:30:18 <boegel> amalloy: I mean, specifically for this purpose
00:30:37 <boegel> amalloy: I'd implement findFirstK :: Int -> [a] -> [a]
00:30:59 <boegel> amalloy: which incorporates boh the take and "sort" operations
00:31:08 <lispy> boegel: Data.Map a [a] :)
00:31:11 <amalloy> boegel: funny, someone was just asking about doing that in #clojure today
00:31:18 <lispy> boegel: just keep it sorted from the beginning :)
00:31:29 <amalloy> it aint as easy as any of us think
00:31:45 <MatrixFrog> :src sort
00:31:45 <boegel> lispy: I'm working with (possibly non-unique) doubles
00:32:22 <boegel> lispy: not an option, I'm doing something like "map detDouble list"
00:32:23 <lispy> boegel: well, that's why I suggested a multiset (eg., Data.Map Double [Double]), but doubles make for sucky equality comparisons anyway.
00:32:34 <MatrixFrog> (did i do that right?)
00:32:47 <lispy> MatrixFrog: need a ? or an @
00:32:51 <MatrixFrog> ?src sort
00:32:51 <lambdabot> sort = sortBy compare
00:32:51 <lispy> ?src sort
00:32:52 <lambdabot> sort = sortBy compare
00:32:59 <ivanm> there's a multiset package on hackage
00:33:03 <MatrixFrog> okaaay then
00:33:05 <ivanm> by default it uses Map a Int
00:33:06 <MatrixFrog> ?src sortBy
00:33:06 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
00:33:07 <lispy> MatrixFrog: but, that's not guaranteed to be the implementation that GHC uses :(
00:33:20 <ivanm> (i.e. it assumes equality is actual literal equality instead of equivalence)
00:33:44 <ivanm> lispy: it's mergeBy compare IIRC
00:33:48 <ivanm> @src mergeBy
00:33:48 <lambdabot> Source not found. Maybe you made a typo?
00:33:54 <boegel> lispy: that too, and also most of the values will be unique (possible all, but there's no way to tell)
00:35:20 <boegel> lispy: with sucky, did you mean slow or possible incorrect?
00:35:40 <lispy> boegel: floats are approximate but equality on them is exact
00:36:00 <lispy> boegel: so there is always a mismatch between the model you're using an the operations you're given
00:36:39 <boegel> lispy: I see
00:36:56 <lispy> as far as I know, the actual comparison is fast because it's just a bitwise comparison
00:37:49 <amalloy> after cabal install darcs, my shell still complains that darcs doesn't exist. is there some haskelly shell needed to run cabal-gotten stuff?
00:38:49 <lispy> amalloy: is ~/.cabal/bin in your path?
00:39:00 <amalloy> seems so unlikely :). i'll check
00:39:08 <ivanm> better make that $HOME/.cabal/bin, not ~
00:39:20 <ivanm> for when you need to use happy or alex with cabal-install...
00:39:32 <MatrixFrog> lispy: there might be a slight extra complication to make sure that 0 and "negative 0" are equal, but yes
00:39:40 <MatrixFrog> and other stuff like dealing with NaNs
00:39:59 <lispy> > 0.0 == (-0.0)
00:40:00 <lambdabot>   True
00:40:12 <MatrixFrog> show (-0.0)
00:40:16 <MatrixFrog> > show (-0.0)
00:40:17 <lambdabot>   "-0.0"
00:40:23 <MatrixFrog> ok so yeah
00:40:34 <lispy> > (-0.0)/0.0
00:40:34 <lambdabot>   NaN
00:40:43 <lispy> > 0.0/0.0
00:40:43 <lambdabot>   NaN
00:40:52 <lispy> > 1/(-0.0)
00:40:52 <lambdabot>   -Infinity
00:40:55 <MatrixFrog> i really don't know much about haskell but i do know that there are a good number of tricky things going on with floating point
00:40:57 <lispy> > 1/(0.0)
00:40:57 <lambdabot>   Infinity
00:41:12 <lispy> Yeah, floating point should almost be a certification
00:41:24 <ivanm> lol
00:41:32 <lispy> "I'm IEEE 754 certified, let me at that scientific code!"
00:41:43 <ivanm> well, IEEE floating point anyway... CReals aren't as tricky in that respect; just in terms of performance
00:42:23 <boegel> ivanm, lispy: http://apfelmus.nfshost.com/articles/quicksearch.html
00:42:44 <lispy> wow, what a bright site.  That must be a recent redeisgn
00:43:23 <ivanm> IIRC, bird's latest book has something similar to the k'th element
00:43:32 <ivanm> he uses an array in some cases to make it even better
00:45:46 <lispy> boegel: I think I read that thread when it was happening.  Looks vaguely familiar
00:46:02 <lispy> Although, I wouldn't have been able to quote the complexities
00:47:08 <boegel> seems to suggest the quicksort would be more efficient for my purposes than mergesort
00:47:14 <boegel> if a good pivot is chosen
01:07:16 <boegel> how can I determine which instances exist for a given type class (e.g. like ghci gives you with :i), from within Haskell code?
01:07:42 <ivanm> boegel: I would randomly guess TH... :s
01:07:47 <boegel> something like "listInstancesFor Data.Bits.Bits", which would return a list of Strings e.g.
01:08:03 <boegel> ivanm: yeah, but that doesn't allow determining something like this at runtime...
01:08:10 <boegel> ivanm: how does ghci do it?
01:08:12 <ivanm> oh, right
01:08:30 <boegel> any easy way to figure that out?
01:08:53 <ivanm> can Data.Dynamic do anything?
01:09:34 <ivanm> it seems impossible to have an isInstanceOf function, at least at compile-time...
01:10:25 <monadic_kid> vector package has some annoying limitations, 1. They aren't like typical vector containers which have capacity as well as a size and doesn't support automatically growing. 2. All the generic options for various types of vectors are only written for immutable vector types
01:11:06 <ivanm> I thought vector was just optimised arrays...
01:11:14 <ivanm> how do arrays automatically grow? :s
01:11:48 <monadic_kid> vector modules automatically grow when you push a new element, they have a grow factor typically of 1.5x the origional size
01:12:15 <monadic_kid> you don't want to be growing vectors just by 1 element every time
01:12:20 <ivanm> right
01:12:30 <ivanm> admittedly, I"ve never used vector
01:12:48 <ivanm> but I was under the impression that it was just for statically-sized arrays
01:13:27 <monadic_kid> no, maybe you're thinking of different library, one based on dependent type way?
01:13:49 <monadic_kid> where size is given as part of it's type
01:14:15 <monadic_kid> this is the one i'm talking about: http://hackage.haskell.org/package/vector
01:15:09 <ivanm> well, I've never really even looked at it tbh :p
01:16:18 <monadic_kid> i'm just expressing my frustation
01:22:05 <boegel> ivamn, lispy: version with (take n . sort) on list with 70k elements takes 11m55s, version with own qsort takes 7m25 (same list)
01:22:35 <boegel> amalloy_: you were saying? (see ^) ;)
01:22:41 <roconnor> monadic_kid: it is the CS people who have usurped the name "vector" to mean something different than the mathematical definition.
01:23:40 <flamingspinach> the mathematical definition has nothing to do with statically sized arrays either
01:23:43 <flamingspinach> that's the engineering definition :P
01:24:02 <roconnor> flamingspinach: nothing to do?
01:24:28 <flamingspinach> a vector is just an element of a vector space which is an algebraic structure with some operations and axioms
01:24:39 <monadic_kid> well this isn't particularly useful discussion
01:24:53 <roconnor> flamingspinach: yes but every vector space has a basis (according to some)
01:25:07 <flamingspinach> a possibly uncountable one, which has pretty much nothing to do with statically sized arrays
01:25:40 <roconnor> flamingspinach: then vectors can be represented by an array of uncountable size
01:25:51 <roconnor> flamingspinach: so it is somewhat related
01:25:56 <flamingspinach> mm hmm...
01:26:45 <flamingspinach> I can see how you could extend the concept of a finite array to a countable array, but once you get into uncountable cardinalities you're basically talking about a function, really - which is how cartesian products are defined in general :)
01:27:11 <roconnor> flamingspinach: arrays are isomorphic to functions on finite types
01:27:20 <flamingspinach> yup
01:27:32 <flamingspinach> well, I don't know what a finite type is, but I guess you're right :)
01:27:46 <roconnor> flamingspinach: a type with a finite number of values
01:28:12 <roconnor> flamingspinach: but anyhow you are mostly right
01:28:35 <roconnor> flamingspinach: since fields have nothing to do with the enginnering notion of a vector
01:28:57 <roconnor> making the gap really big
01:29:10 <flamingspinach> what's this about fields now?
01:29:56 <roconnor> there is a field action on vectors in mathematics (ie. scaler multiplication)
01:30:16 <roconnor> no such operation exists on the container definition
01:30:29 <flamingspinach> oh, so you mean that IEEE floating point numbers do not form a true field (?)
01:31:05 <flamingspinach> well, I guess in general "vector" types don't have to be possible to multiply by "number" types at all
01:31:12 <roconnor> no that if I have a containter of apples, there is no scaler multiplication for those.
01:31:24 <roconnor> a "vector" of Apples
01:31:38 <roconnor> Where Apple is some random type
01:31:44 <flamingspinach> yup, true
01:31:46 <roconnor> maybe I should use "Foo"
01:34:37 <lispy> boegel: Try it with the multiset package on hackage.  Does it get even better?
01:35:59 <jonkri> todays challenge: learning the basics of haskelldb
01:36:10 * jonkri is getting tired of sql's weak typing
01:41:13 <monadic_kid> great it gets worse, vector-algorithms only work with mutable vectors, unsafeFreeze/Thaw up the wazoo!
01:44:09 <roconnor> I still kinda intrigued by the fact that we can find tangent lines to curves on finite fields.
01:54:21 <osfameron> huh?  why did the Haskell Platform installer just open up *Safari* ?
01:54:27 <osfameron> doesn't it honour the default browser settings?
02:00:18 <osfameron> ah, older version of platform wrote 'cabal' to /usr/local/bin?
02:00:31 <osfameron> this one writes to /usr/bin which is then shadowed by the existing one
02:00:35 * osfameron cleans up a bit
02:05:40 <vegai> that reminds me
02:06:02 <vegai> what would be the nice way to open up an arbitrary file so that the system will decide which program to start it with?
02:06:10 <vegai> preferably so that it works on all systems
02:07:05 <koninkje> On OSX you can use `open`, but I don't know of a portable way to do what you want.
02:08:20 <ivanm> in linux you typically use xdg-open
02:08:27 <ivanm> there are also gnome and kde-specific variants
02:08:40 <ivanm> but xdg-open isn't always that smart, and typically resorts to "open in browser" :s
02:09:11 <vegai> also, it seems to manage to open with a different browser than I had defined :P
02:09:18 <Ke> heh that would be bad since eg. chromium uses xdg-open
02:09:40 <vegai> odd, chromium is my system browser
02:09:50 <vegai> so would chromium also start firefox if it use xdg-open on an html file..
02:10:23 <Ke> mostly the situation is just bad
02:10:32 <kolmodin> ?yarr!
02:10:33 <lambdabot> Where d' all t' pirates come from?
02:10:33 <lambdabot> Great Yarrmouth!
02:10:35 <kolmodin> morning!
02:10:41 <Ke> morning
02:11:48 <kolmodin> :)
02:11:53 <vegai> sounds almost like a fillable hole for a nifty small haskell library...
02:12:26 <Ke> from what I hear this problem would require rather a huge library
02:13:48 <Ke> this problem is 99% solved for me, when firefox5 gets a sandbox and pdf renderer
02:14:16 <ivanm> Ke: hell no, I prefer a standalone app for pdf viewing
02:14:42 <ivanm> but yeah, you need a case for windows, one for OSX, one for KDE, one for GNOME, and one for xdg-open
02:14:51 <ivanm> if you really want to be fancy, I think xfce has it's own launcher as well
02:15:26 <Ke> I'd bet you can still use external pdf viewers with firefox5
02:15:57 <Ke> still running anything specified by adobe outside a sandbox is pure madness
02:16:00 <ivanm> probably
02:16:19 <ivanm> it's still bad enough that firefox seemingly has its own mime type association list (e.g. using evince instead of okular for pdfs)
02:16:26 <ivanm> Ke: heh
02:16:54 <Ke> firefox also has it's own mime editor like konqueror
02:17:20 <ivanm> well, flash wasn't originally from adobe...
02:17:27 <Ke> true
02:17:30 <ivanm> and if you disable javascript PDF isn't _too_ insecure...
02:18:09 <Ke> it allows you to run external arbitrary commands by the spec
02:18:15 <Ke> that is really bad
02:19:16 <Ke> I really prefer having hard sandbox there so that it in no circumstances actually adheres to the specs
02:49:38 <roconnor> Do comments nest in Haskell?
02:50:32 <ivanm> roconnor: as in {- ... -} quotes? I think so
02:50:52 <roconnor> as it {- this is a comment {- this is a comment  -} this is still a comment -}
02:51:07 <roconnor> *as in
02:51:17 <ivanm> I think that works; but don't have ghc on this box to check :s
02:51:24 <roconnor> ivanm: hugs?
02:51:24 <ivanm> @google haskell nest comments
02:51:25 <lambdabot> http://www.youtube.com/watch?v=-ZIPGw55dII
02:51:25 <lambdabot> Title: YouTube - One Flew Over The Cuckoos Nest Haskell Wexler In The Heat of the Night
02:51:35 <ivanm> roconnor: don't have it installed either
02:51:37 <merijn> Swing and a miss :>
02:51:55 <ivanm> and it's not available on this distro anyway ;)
02:52:18 <roconnor> ivanm: you should switch to nixos
02:52:46 * ivanm passes
02:53:02 <ivanm> I'm going to work on adding cabal support to paludis and thus fix up the mess of haskell packages on exherbo
02:53:13 <merijn> Comments nest according to my quick test
02:53:19 <ivanm> because the people that packaged it don't really know what they're doing for the most part
02:53:35 <roconnor> okay, but you are missing out on the party
02:53:52 <merijn> (at least "main = {-do comments{- nest in haskell-}?-} undefined" compiles and runs without problems...)
02:54:27 <ivanm> roconnor: I did consider nixos; but I'm more than happy to rebuild my system after upgrading a package
03:05:13 <Feuerbach> ivanm: "because the people that packaged it don't really know what they're doing for the most part" -- that's funny, their website says "A distribution 'designed for people who know what they're doing with Linux'"
03:05:43 <ivanm> Feuerbach: linux, yes; haskell, no
03:05:49 <merijn> Feuerbach: Aside from a handful of commiters I don't think such people exist :>
03:06:00 <ivanm> e.g. actual packages for containers, etc. :s
03:06:45 <ivanm> (we're working out how to deal with boot libraries, and the current idea is to still have packages for them but leave them as virtual ones; this saves having to filter out dependencies like container from actual packages)
03:07:00 <ivanm> oh, and mandatory QuickCheck :s
03:18:13 <Feuerbach> Why is concat implemented as "foldr (++) []" instead of O(n) implementation? Is it because of possible fusion?
03:20:24 <ivanm> Feuerbach: which O(n) implementation?
03:20:39 <ivanm> isn't foldr (++) [] O(n) ?
03:20:41 <merijn> I suspect the foldr version is O(n) because of laziness, but I'm not sure enough to guarantee that
03:20:45 <ivanm> and yeah, fusion is probably good
03:20:53 <ivanm> merijn: what does laziness have to do with it?
03:21:04 <ivanm> > foldr (++) [] [as,bs,cs]
03:21:04 <lambdabot>   Not in scope: `as'Not in scope: `bs'Not in scope: `cs'
03:21:12 <ivanm> > foldr (++) [] [a,b,c]
03:21:13 <lambdabot>   Couldn't match expected type `[a]'
03:21:13 <lambdabot>         against inferred type `SimpleRef...
03:21:17 <ivanm> lambdabot: wakey-wakey!
03:21:41 <merijn> ivan: Because you don't need to run to the end of the last list which you would have to if foldr were strict?
03:22:04 <ivanm> merijn: huh? even if you did it strictly I'm pretty sure it turns out to be O(n)
03:22:24 <merijn> Oh, duh. Because you don't create thunks when you're strict >.>
03:22:24 <Feuerbach> ivanm: I believe it's something like O(n^2), since (++) is O(n) (where in the latter case n is the size of the left operand)
03:22:35 <ivanm> Feuerbach: it's foldr not foldl though
03:22:46 <ivanm> so the rest of the list gets concat'd first; _then_ the first element is put on the front
03:22:51 <Feuerbach> ah indeed
03:22:55 <ivanm> > foldr (++) [] [a,b,c]
03:22:55 <lambdabot>   Couldn't match expected type `[a]'
03:22:56 <lambdabot>         against inferred type `SimpleRef...
03:23:02 <ivanm> hmmm.....
03:23:03 <ivanm> *shrug*
03:23:18 <ivanm> that becomes a ++ (b ++ (c ++ []))
03:24:05 <sipa> that's still O(n) with n the length of the resulting list, no?
03:24:20 <merijn> sipa: Why?
03:24:45 <ivanm> merijn: because concat (a;as) becomes a ++ concat as
03:24:57 <merijn> hmm, yeah you're right
03:26:29 <mao> http://conal.net/blog/posts/everything-is-a-function-in-haskell/ Hello, I just read that article and I am not saying that everything is a function in haskell, but why can't `x = 5' be a function (in mathematical sense) which maps x: () -> R ?
03:26:54 <Feuerbach> mao: it's *isomorphic* to that function
03:26:57 <mao> Or having empy set as a function domain is bad?
03:26:59 <Feuerbach> but it's not the same
03:27:10 <mao> huh
03:27:18 <mao> what's isomorphic?
03:27:22 <merijn> mao: Because that would require you to pass () as an input to x
03:27:23 <mao> to what function?
03:27:29 <ivanm> mao: think "equivalent"
03:27:44 <ivanm> "x = 5" is a value; you can tell because it doesn't take an input
03:27:45 <shachaf> Feuerbach: Except for _|_, perhaps. :-)
03:27:47 <mao> no, i know what `isomorphic' means
03:27:51 <roconnor> ivanm: functions are values too
03:28:00 <Feuerbach> shachaf: I was just going to make that disclaimer ;)
03:28:11 <mao> you see "take input" has nothing to do with math
03:28:12 <mao> imo
03:28:43 <sipa> the thing that makes haskell a functional language, is NOT that everything is a function, but rather that contrary to many other languages, functions are values
03:28:52 <Feuerbach> mao: in math things are often considered modulo isomorphism
03:28:57 <shachaf> Yes, the usual meaning of a function in #math is a set of pairs.
03:29:04 <ivanm> roconnor: true
03:29:17 <ivanm> mao: ummm, saying "x = 5" in math doens't make it a function
03:29:27 <ivanm> unless you're talking about church encoding or something
03:29:32 <mao> Again, I am NOT trying to say that everything is a funcion in haskell
03:29:35 <sipa> shachaf: with not both (a,b) and (a,c) existing
03:29:39 <merijn> sipa: "many other languages"? Really? I'd say first class functions are rather common by now
03:29:39 <mao> ivanm: church encoding?
03:29:39 <ivanm> shachaf: yeah, works for me
03:29:40 <mao> what
03:29:43 <mao> what the..
03:29:48 <ivanm> mao: do you know peano arithmetic?
03:29:58 <shachaf> sipa: Sure; I didn't say "any set of pairs". :-)
03:30:11 <mao> do you mean church's lambda calculs?
03:30:17 <Feuerbach> mao: e.g. you usually identify carthesian product A x (B x C) with a set of triples, although it's a set of pairs (a, (b,c))
03:30:19 <mao> no, im not talkinb about lambda-calculus
03:30:26 <merijn> sipa: I mean, other then Java/C/C++ (and Java is getting anonymous functions Real Soon Now(TM)) I don't know any important languages *without* first class functions
03:30:30 <mao> however in math i can say `f = f(x)'
03:30:30 <ivanm> merijn: really? Java has higher-ordered functions now?
03:30:39 <Feuerbach> mao: the same is about values of type X and functions of type () -> X
03:30:45 <shachaf> mao: Can you? That's kind of meaningless.
03:30:45 <roconnor> mao: in math a function is usually represented by a graph, but 5 isn't a graph.
03:31:01 <merijn> ivanm: They will in the massively delayed version 7 or 8
03:31:02 <ivanm> mao: church encoding uses lambda calculus, yes; it isn't the same thing though
03:31:02 <roconnor> {(),5} is a graph 
03:31:04 <roconnor> er
03:31:07 <ivanm> roconnor: ahem; that's not a graph!
03:31:08 <roconnor> {((),5)} is a graph 
03:31:16 <ivanm> a plot, yes; but not a graph! ;)
03:31:17 <mao> ^
03:31:23 <roconnor> really?
03:31:29 <ivanm> merijn: O RLY?
03:31:42 <sipa> merijn: nice
03:31:49 <ivanm> roconnor: oh, wait, I see what you mean...
03:31:56 <roconnor> I think graph is a proper term here
03:32:02 <merijn> ivanm: Yeah, they're really smug about this "awesome new invention", too
03:32:03 <roconnor> though I admit it's use in math is overloaded
03:32:04 <ivanm> I thought you were doing the more usual "y = f(x) plot"
03:32:59 <ivanm> mao: still, if I say "x = 5" in mathematics, is it a function?
03:33:03 <mao> Ok. So can function domain be an empty set?
03:33:08 <sipa> ivanm: no
03:33:17 <sipa> it's an equation :)
03:33:18 <ivanm> sipa: hey, he's the one arguing it is!
03:33:20 <roconnor> mao: yes, but ther is only one such function
03:33:22 <mao> ivanm: uh, what if I say x(z) = 5?
03:33:32 <ivanm> mao: then it's a constant function
03:33:35 <sipa> mao: that is a function definition, yes
03:33:36 <merijn> mao: Yes, but that's not the same, now is it?
03:33:36 <shachaf> roconnor: But it can have many codomains!
03:33:42 <ivanm> which is equivalent to "x = const 5" in Haskell
03:33:47 <roconnor> shachaf: no it can only have 1 condomain
03:33:49 <mao> merijn: what's the difference?
03:33:52 <merijn> > const 5 "foo"
03:33:53 <lambdabot>   5
03:33:53 <sipa> and (const 5) *is* a function in haskell
03:33:55 <ivanm> (with appropriate type sig if required)
03:33:58 <sipa> :t (const 5)
03:33:59 <lambdabot> forall t b. (Num t) => b -> t
03:34:03 <merijn> mao: Functions require input, values do not
03:34:04 <mao> roconnor: why there is only 1 such function?
03:34:09 <roconnor> shachaf: wait I'm wrong
03:34:11 <roconnor> shachaf: sorry
03:34:15 <roconnor> I was mixed up
03:34:23 <Feuerbach> mao: first of all, () does not represent empty set; it's a singleton set (again ignoring bottoms)
03:34:24 <mao> merijn: `y = f(x)' is y a funcion or a value?
03:34:32 <Feuerbach> that's what roconnor means I think
03:34:36 <shachaf> mao: All functions are values.
03:34:37 <roconnor> Feuerbach: that is a very good point to make
03:34:45 <merijn> mao: y is a name for the value "f(x)" which is a function
03:34:49 <shachaf> mao: In that case, y is a value; we don't know if it's a function because we don't know the type of f(x).
03:35:00 <sipa> merijn: strictly, f(x) is not a function, f is
03:35:10 <ivanm> sipa: agreed
03:35:16 <sipa> but both are values
03:35:18 <merijn> In the x=5 case x is a name for a value which is 5. In the case of
03:35:46 <merijn> Whereas in x(z)=5, x is a name for a value which is a function (which always returns 5)
03:35:54 <mao> Ok anyway
03:36:04 <mao> Why there is only 1 function which has empty set as domain?
03:36:17 <merijn> In the first case "x(4)" is a syntax error, in the latter case "x(4)" is 5
03:38:25 <jonkri> how are forkIO threads generally timed-out? (for example, let's say that you have a thread waiting for a http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/Control-Concurrent-CML.html#v:receive sync) http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/System-Timeout.html?
03:38:30 <Feuerbach> mao: because, if you define the function as a set of pairs, there's only one function with empty domain, namely, the empty set
03:39:15 <roconnor> mao: a^b is the number of function with domain sized b and codomain sized a.  a^0 is always 1.
03:40:15 <mao> so
03:40:20 <mao> what's the codomain?
03:40:52 <roconnor> mao: I was mistaken before.  There are many functions with domain the empty set but only one for each codomain.
03:41:27 <roconnor> (OTOH there is only one function with codomain the empty set and it has domain the empty set)
03:42:44 <mao>  there's only one function with empty domain,
03:42:44 <mao>                    namely, the empty set
03:42:49 <mao> the function is a set?
03:43:00 <mao> I haven't heard that before, where can I read more about this?
03:43:21 <roconnor> er
03:43:29 <roconnor> I should have said the empty function
03:43:39 <roconnor> (OTOH there is only one function with codomain the empty set and it has domain the empty function)
03:44:10 <roconnor> though often the empty function is represented by it's graph which in this case is the empty set.
03:44:25 <Feuerbach> mao: http://en.wikipedia.org/wiki/Function_(mathematics)#Definition
03:45:19 <mao> Some authors (especially in set theory) define a function as simply its graph f, with the restriction that the graph should not contain two distinct ordered pairs with the same first element.
03:45:20 <mao> uh duh
03:45:29 <mao> i thought it would be something interesting
03:47:06 <mao> So all in all, there can be a function which maps an empty set to set X but there is only 1 function with that type and other functions are just isomorphic?
03:47:40 <roconnor>  there can be a function which maps an empty set to set X but there is only 1 function with that type
03:47:44 <roconnor> that part is true
03:48:53 <mao> and all other functions with the same type are isomorphic to that original function* ?
03:49:27 <roconnor> there are no other functions with the same empty set to X
03:49:47 <roconnor> however the types (empty set to X) and (empty set to Y) are isomorphic types.
03:50:28 <mao> okay, can i show me an example of function which maps empty set to R?
03:50:38 <mao> (i am not trying to argue here, just trying to undestand)
03:51:00 <roconnor> mao: in haskell, or in set theory, or what represenation do you want for functions?
03:52:02 <crystal-cola> I don't understand bad merge at all
03:52:13 <roconnor> crystal-cola: oh?
03:52:13 <crystal-cola> it seems like an arbitrary choice
03:52:18 <roconnor> it isn't
03:52:23 <crystal-cola> but it says "darcs is right and svn is wrong"
03:52:29 <mao> in general math notation? 
03:53:05 <roconnor> mao: in set theory, we define a function by giving it's graph.  In this case the unique funciton from {} to R is defined by the graph {}
03:53:21 <roconnor> crystal-cola: I think I have a better explaination somewhere
03:53:27 <mao> what about in not set theory?
03:53:29 <roconnor> crystal-cola: let me see if I can find it.
03:53:35 <crystal-cola> infact I think svn is right
03:53:36 <crystal-cola> http://tahoe-lafs.org/~zooko/badmerge/concrete-good-semantics.html
03:53:37 <crystal-cola> in this example
03:53:50 <crystal-cola> c1 changed the x to 0 in square
03:54:03 <roconnor> mao: in pseudo-hasekll I'd write: f :: Void -> R   f x = case x of {}
03:54:06 <crystal-cola> darcs merge incorperates that change into slow_square
03:54:22 * ivanm points out #darcs to crystal-cola 
03:55:36 <shachaf> @djinn Void -> a
03:55:37 <lambdabot> f = void
03:55:52 <merijn> :t void
03:55:53 <lambdabot> Not in scope: `void'
03:55:58 <roconnor> crystal-cola: http://www.reddit.com/r/haskell/comments/ezgvs/rfc_migrating_ghc_development_to_git/c1c7rrz
03:55:59 <ivanm> @hoogle void
03:55:59 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
03:56:02 <shachaf> void :: Void -> a
03:56:06 <shachaf> Not all that helpful.
03:56:29 <roconnor> Git doesn't satisfy the merge law: Merging change 1 then merging change 2 is equal to merging both change1 and change2 together.
03:56:52 <roconnor> crystal-cola: darcs satifies that property
03:57:02 <roconnor> and that is what makes darcs correct (in this regard)
03:57:21 <crystal-cola> roconnor: That appeals to me because I am biased towards "algebraic" things
03:57:31 <crystal-cola> roconnor: but the concrete example still looks darcs did the wrong thing to me
03:57:33 <roconnor> crystal-cola: I think I have an even better thread on -cafe
03:57:44 <roconnor> crystal-cola: I find the "concrete" example confusing too
03:57:47 <ivanm> roconnor: and in every other regard (except for when it's wrong) :p
03:57:54 <mao> ok thanks roconnor 
03:57:59 <crystal-cola> in any case the idea of automatically merging two peices of source code together seems like insanity
03:58:09 <crystal-cola> I can't beleive people actually do this!
03:58:10 <ousado> roconner: the "merge law"? what's that?
03:58:17 <roconnor> crystal-cola: it is a little bit insane
03:58:23 <Baughn> crystal-cola: Having tests helps
03:58:24 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
03:58:34 <roconnor> crystal-cola: especially because they do that without knowledge of the AST!
04:00:05 <tmhrtly> y
04:00:18 * hackagebot text-json-qq 0.3.0 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/text-json-qq-0.3.0 (OscarFinnsson)
04:00:40 <tmhrtly> Does anyone know of a way to generate keypresses in Haskell? kind of like the Robot class in Java
04:00:53 <ivanm> tmhrtly: z
04:01:20 <efie> is there a proper way solving this http://codepad.org/CjInaUqe without entering n=0?
04:01:26 <tmhrtly> succ 'z'
04:01:26 <roconnor> mao Void has no constructors.  f x does case analysis on x, there are no cases, so the number of branches in the case body is 0.  All the branches (of which there are none) have type R, so this type checks.
04:01:33 <ivanm> > succ 'z'
04:01:34 <lambdabot>   '{'
04:01:44 <merijn> crystal-cola: Simple, interoperability with other people is more important then correctness
04:01:44 <tmhrtly> Sounds reasonable to me
04:01:51 <Silvah> ivanm: ä
04:02:15 <shachaf> roconnor: To say that that type checks is a bit of a stretch, given that it doesn't even syntax-check. :-)
04:02:27 <sipa> efie: use a where clause
04:02:28 <crystal-cola> What I don't understand about software correctness is that it isn't binary.
04:02:29 <ivanm> Silvah: OK, now you're just being silly...
04:02:30 <ivanm> ;)
04:02:38 <merijn> Darcs is all nice and good, but until it can interface with Mercurial and Git it is effectively useless to me. Because I'm not going to use 2 VCS and have to constantly switch
04:02:43 <crystal-cola> I would expect that if a program was not correct it would be useless
04:02:45 <roconnor> shachaf: oh, not even with empty data decl?
04:02:45 <shachaf> > pred 'ä'
04:02:46 <lambdabot>   '\227'
04:02:50 <sipa> efie: maxlength = maxlength_ 0 where ...
04:02:51 <ousado> roconner: or rather, is there some other name for it that I could google
04:02:59 <tmhrtly> I don't mind if its a separate module or something I have to download, I'm just interested in doing it ;)
04:03:07 <sipa> and then your current definition as maxlength_
04:03:31 <shachaf> roconnor: Not as far as I know.
04:03:32 <merijn> crystal-cola: Why would it be binary? "Mostly works" is obviously better then "Does not work at all", therefore correctness is clearly not a binary value
04:03:36 <mao> sorry to bother you again guys, but does anybody know a good and easy book on lambda calculus?
04:04:11 <efie> sipa: thanks for the hint, i havent used where yet, ill try to figure it out
04:04:24 <merijn> mao: There isn't really one for programmers atm, I can send you the link to course notes for lambda calculus classes here
04:04:24 <mao> i only read a wikipedia page and Sussman's paper
04:04:56 <crystal-cola> I would expect software correctness to be binary because I expect a single mistake in code to be amplified massively during iterations
04:04:58 <mao> merijn: well, i am not looking for a book for programmers tbh
04:04:58 <sipa> efie: you can use let as well, maxlength = let { maxlength_ ... = } in maxlength_ 0 
04:05:23 <ousado> err, roconnor, is there some other name for "merge law" that I could google?
04:05:34 <crystal-cola> It's amazing that it isn't and I don't see how it's not
04:05:35 <shachaf> mao: SPJ's _The Implementation of Functional Programming Languages_ has a pretty nice introduction, I seem to recall.
04:05:37 <merijn> mao: These are the course notes for the logical verification class here, start with propositional logic and simply typed lambda calculus and builds from there http://www.cs.vu.nl/~femke/courses/lv/notes/notes.pdf
04:05:47 <efie> im not familiar with this as well :)
04:05:48 <roconnor> ousado: I just made up the term in january
04:05:50 <shachaf> I might be wrong, though.
04:05:57 <merijn> Basics of Curry-Howard and all that
04:05:58 <mao> what about untyped lambda-calculus?
04:06:02 <shachaf> (That is, it might be oriented towards people who are already familiar with it.)
04:06:16 <mao> shachaf: i am looking for something.. pure
04:06:20 <roconnor> crystal-cola: simon marlow had an script that illustrated the problem with git: http://www.haskell.org/pipermail/glasgow-haskell-users/2011-January/019801.html
04:06:28 <roconnor> crystal-cola: it appears to be gone from hpaste :(
04:06:31 <mao> which has nothing to do with programming 
04:06:35 <merijn> mao: The only notes I have on that are not in English, unfortunately
04:06:51 <shachaf> mao: Why do you care about "easy"?
04:07:15 <shachaf> The general concepts are presumably the same concepts, so if they're difficult, a good book will still be difficult no matter what.
04:08:05 <merijn> shachaf: Because there are easy to understand explanations and hard to understand ones, regardless of the topics difficulty. Mostly related to the writers teaching skills
04:08:08 <ivanm> roconnor: because hpaste is down! ;)
04:08:17 <mao> merijn: exactly!
04:08:28 <merijn> And in my experience most mathematicians are sorely lacking in the teaching skills department
04:08:34 <shachaf> merijn: OK, but asking for an "easy" book limits what people can recommend significantly.
04:08:48 <shachaf> Because it might be that the topic is just not easy.
04:09:05 <merijn> Easy is relative to the topic
04:09:11 <shachaf> In which case people can only recommend books that don't talk about the topic.
04:09:24 <merijn> An easy book on category theory is obviously going to be harder then an easy book on arithmetic
04:09:36 <shachaf> I disagree.
04:09:41 <merijn> (Or even a hard book on arithmetic)
04:09:48 <shachaf> Anyway, I think asking for just a good book is sufficient.
04:09:59 <shachaf> And you'll get better recommendations too.
04:10:16 <mao> Well, there are some book which require more background, for example
04:10:21 <ousado> mao: you know TAPL, right? 
04:10:40 <mao> Types and Programming Languages?
04:10:43 <ousado> yes
04:11:28 <roconnor> crystal-cola: http://webcache.googleusercontent.com/search?q=cache:DDjBJ29EktAJ:hpaste.org/42953/git_mismerge+http://hpaste.org/42953/git_mismerge&cd=1&hl=en&ct=clnk&gl=fr&client=firefox-a&source=www.google.fr
04:11:39 <roconnor> crystal-cola: I think that shell script is really clear
04:11:39 <crystal-cola> thanks
04:11:59 <crystal-cola> why is there an annotation?
04:13:00 <roconnor> I forget
04:13:06 <crystal-cola> ill ignore it then
04:13:06 <roconnor> presumably my script is even better :D
04:13:08 <crystal-cola> hmm
04:13:40 <roconnor> I think my script illustrates the failure of the merge law
04:13:56 <roconnor> where as simon's script, like bad merge, just claims a single merge is wrong.
04:14:07 <crystal-cola> roconnor: aha I see why it is wrong now
04:15:52 <roconnor> I should post that script on my blog
04:16:27 <ivanm> with an explanation, of course!
04:17:40 <roconnor> yes
04:20:49 <tryinghaskell> hi! i'm in the try haskell online repl (or whatever it's called), and i have a question: when using something  like "map (*99) [1..10], are you passing a tuple containing *99, or are the parenthesis used differently there?
04:21:11 <ivanm> differently
04:21:16 <shachaf> tryinghaskell: You're passing a function that multiplies its argument by 99.
04:21:19 <ivanm> that's known as a "section"
04:21:25 <shachaf> This is called a "section"; it's a special-case of Haskell syntax.
04:21:32 <shachaf> It means the same as (\x -> x * 99)
04:21:33 <ivanm> it's equivalent to (\x -> x * 99)
04:21:42 <tryinghaskell> okay, thank you ivanm shachaf
04:21:57 <ivanm> tryinghaskell: np
04:23:59 <merijn> tryinghaskell: If you want more reading material (later) I recommend Learn You a Haskell. I see tryhaskell recommends Real World Haskell, which is good but I think LYAH is better for people who are completely new :)
04:24:35 <ivanm> merijn: well, tryhaskell was aimed at being an alternate tutorial
04:24:47 <ivanm> but it appears chrisdone hasn't done much recently with it :s
04:25:03 <sipa> efie: http://pastebin.com/hE7VW3dQ
04:25:03 <merijn> ivan: I know, but still. Personally I found RWH rather scary while starting :p
04:25:30 <tryinghaskell> merijn: thank you.  I actually started reading TYAH, but since i haven't installed haskell yet, i quickly got to the point where i was like "i'm getting lost, i need to actually use this"
04:25:33 <sipa> efie: oh, and add an underscore to the recursive call
04:26:22 <merijn> tryinghaskell: Ah, yeah. Without an interpreter to play with things get confusing :)
04:35:04 <mao> Can someome please explain these rules to me: http://i.imgur.com/IvX9J.png ?
04:35:25 <mao> I think I am not familiar with notation
04:35:55 <efie> sipa: "maxlength = maxlength_ 0 " dont you have to commit the list like   "maxlength (x:xs) = maxlength_ 0 (x:xs) " or something like this?
04:36:06 <crystal-cola> mao: it means if p is okay and q is okay then (qp) is okayu
04:36:22 <crystal-cola> mao: so e.g. if a,b,c,d are all okay then ((ab)(cd)) is okay
04:36:31 <roconnor> @hoogle fix
04:36:31 <lambdabot> Data.Function fix :: (a -> a) -> a
04:36:31 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
04:36:31 <lambdabot> module Control.Monad.Fix
04:37:34 <dixie> @hoogle breake
04:37:34 <lambdabot> Data.ByteString breakEnd :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
04:37:34 <lambdabot> Data.ByteString.Char8 breakEnd :: (Char -> Bool) -> ByteString -> (ByteString, ByteString)
04:37:38 <dixie> @hoogle break
04:37:39 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
04:37:39 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
04:37:39 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
04:38:10 <mao> crystal-cola: okay, and what about the second rule?
04:38:26 <crystal-cola> what about it?
04:41:35 <mao> crystal-cola: how can I inteper it? If term `r' is okay and can be applied to x (?) then lambda x.r is okay?
04:42:15 <crystal-cola> mao: it's not written in a sensible way
04:43:17 <merijn> mao: No, I'd say it means "if you have a term r containing a free variable x, then you can construct \x.r" (effectively binding the free variable x inside r)
04:44:41 <mao> oh thanks
04:44:59 <crystal-cola> bear in mind the way the author has written that is not normal
04:48:09 * hackagebot swish 0.3.0.3 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.0.3 (DouglasBurke)
05:43:33 <McManiaC> why do I need network 2.2 for almost every package and why doesn't the haskell platform containt that aswell? the installation keeps on failing all the time on my sys :(
05:44:25 <Zao> McManiaC: Because Cabal optimistically recommends the Latest and Greatest, even if a lesser one you have would suffice.
05:44:28 <Zao> ?
05:44:40 <McManiaC> I have 2.3
05:44:41 <McManiaC> :S
05:44:56 <Zao> Ah.
05:46:31 <RichardO> @pl h x y = g (f x y)
05:46:31 <lambdabot> h = (g .) . f
05:46:39 <gienah> McManiaC: I never use cabal, so not really sure, maybe sed the .cabal files to remove any dependencies on network-bytestring and allow network 2.3
05:48:22 <RichardO> @pl h x y = f a b where (a, b) = g x y
05:48:23 <lambdabot> (line 1, column 28):
05:48:23 <lambdabot> unexpected "="
05:48:23 <lambdabot> expecting variable, "(", operator or end of input
05:49:10 <RichardO> @pl h x y = uncurry f (g x y)
05:49:10 <lambdabot> h = (uncurry f .) . g
05:51:11 <RichardO> @pl h x y = uncurry f . second g . j x y
05:51:11 <lambdabot> h = (((uncurry f . second g) .) .) . j
05:56:10 <RichardO> @pl f x y = f1 (x, f2 y)
05:56:10 <lambdabot> f = (f1 .) . (. f2) . (,)
05:56:54 <boegel> when +RTS -s reports that your program has 50% GC activity, what are the best ways to lower that? +RTS -H1G (or bigger?)
06:00:35 <ClaudiusMaximus> boegel: reducing -H might make more frequent garbage collections each taking less time; there's a tool that graphs the GC parameter space.. http://hackage.haskell.org/package/ghc-gc-tune
06:01:54 <boegel> ClaudiusMaximus: but it seems that -H isn't the only option controlling max memory usage?
06:02:10 <boegel> ClaudiusMaximus: I've set it to -H1G, but my tool is using over 2G of memory...
06:02:53 <RichardO> @pl f x y = f1 x (f2 (f3 x) y)
06:02:53 <lambdabot> f = liftM2 (.) f1 (f2 . f3)
06:03:02 <boegel> I guess I need to set -M too
06:04:48 <RichardO> @pl f x y = uncurry f1 (second (liftM2 (.) (f2 . f3))) (f4 (f5 x) y)) 
06:04:48 <lambdabot> (line 1, column 65):
06:04:48 <lambdabot> unexpected ")"
06:04:48 <lambdabot> expecting variable, "(", operator or end of input
06:05:08 <ClaudiusMaximus> boegel: hm, using FFI?  (I think -H is only for Haskell values)
06:05:24 <RichardO> @pl f x y = uncurry f1 ((second (liftM2 (.) (f2 . f3))) (f4 (f5 x) y))
06:05:24 <lambdabot> f = ((uncurry f1 . second (liftM2 (.) (f2 . f3))) .) . f4 . f5
06:05:52 <boegel> ClaudiusMaximus: no, but I am running with +RTS -s, that might be why?
06:06:13 <boegel> I bet that introduces quite a bit of overhead...
06:06:35 <RichardO> @pl f x y = uncurry f1 ((second (liftM2 (.) f2 (f3 . f4))) (f5 (f6 x) y))
06:06:35 <lambdabot> f = ((uncurry f1 . second (liftM2 (.) f2 (f3 . f4))) .) . f5 . f6
06:10:55 <ClaudiusMaximus> boegel: http://stackoverflow.com/questions/3171922/ghcs-rts-options-for-garbage-collection might have some useful tips too
06:11:13 <boegel> ClaudiusMaximus: k, thx
06:22:26 <dafis> boegel: -H sets initial heap size, it can grow from that, to limit heap size, use -M
06:22:40 * roconnor writes a function returning Maybe (Maybe Foo)
06:23:02 <boegel> dafis: I'm doing exactly that, but then my tool crashes because it requires more than 2G :(
06:23:11 <dafis> boegel: another interesting flag is -A which sets the allocation area, try increasing that (default is 512K iirc)
06:23:18 <boegel> dafis: I doubt I have that much data that's long-lived though
06:23:44 <dafis> boegel: you set e.g. -M1G but it uses 2G?
06:24:00 <boegel> actually, I'm pretty sure... I adjusted a function that basically emits a Double, but processes more intermediate lists now
06:24:13 <boegel> dafis: I'm using +RTS -H1G -M2G -s
06:24:56 <boegel> dafis: it uses a little more than 2G (which is OK), but it crashes with Current maximum heap size is 2147483648 bytes (2048 MB); use `+RTS -M<size>' to increase it.
06:25:07 <boegel> seems like laziness is biting me in the ass once more ^^
06:25:30 <dafis> boegel: try -M1536M
06:26:26 <boegel> dafis: how will lowering the maximum help me?
06:26:29 <dafis> oh, wait, no, it seems it *needs* more than 2G
06:26:48 <boegel> dafis: indeed
06:27:00 <dafis> boegel: have you more than 2G ?
06:27:16 <boegel> dafis: I do process big lists though, if the runtime is storing it all because of laziness, that might be the problem
06:27:34 <boegel> dafis: I have 4G in my system, but have other stuff running and don't want to kill my system :)
06:27:41 <boegel> dafis: 2G should be more than enough imho
06:27:59 * boegel adds some seqs
06:28:07 <dafis> boegel: may well be. can you trim it down and do a profiling run?
06:28:38 <boegel> dafis: I think I can
06:29:01 <dafis> that should tell you what's using all the memory
06:29:02 <boegel> dafis: I can drop 90% of the data set it's working on ;)
06:29:08 <boegel> dafis: yeah, good idea
06:29:42 <dafis> boegel: then you can narrow down the places possibly needing more strictness
06:30:13 <dafis> boegel: if the code is not too long, I could take a look at hpaste
06:30:36 <boegel> dafis: it's quite long, and spread across multiple modules
06:31:05 <dafis> boegel: then I'm not too keen on seeing it :)
06:31:44 <dafis> boegel: what's it doing in broad terms?
06:51:53 <boegel> dafis: trying to win $3M, that's what it's doing :)
06:52:11 <boegel> dafis: see http://www.heritagehealthprize.com
06:52:11 <dafis> boegel: how?
07:18:02 <boegel> dafis: profiling does help, it's telling me the problem lies somewhere totally different than I was expecting :)
07:18:25 <dafis> boegel: ah-hah, kind of where?
07:19:00 <boegel> dafis: my qsort function
07:19:20 <dafis> boegel: qsort, like quicksort?
07:19:30 <dafis> boegel: lists or arrays?
07:19:57 <boegel> dafis: it's probably using a bad pivot, which it wasnt doing before
07:20:02 <boegel> dafis: lists
07:20:25 <dafis> boegel: what's wrong with Data.List.sort?
07:20:41 <dafis> or sortBy
07:20:48 <boegel> dafis: it's sorting a list of 77k elements with the large input
07:21:08 <boegel> dafis: that's merge sort, which doesn't go well with the fact that I only need the smallest k values in the list
07:21:26 <boegel> dafis: take n . qsortBy is a lot faster than take n . sortBy
07:21:27 <dafis> boegel, the merge is lazy
07:21:36 <boegel> dafis: yes, so is my qsort
07:21:42 <dafis> boegel: have you benchmarked?
07:21:47 <boegel> dafis: and qsort works better when you only need to first k
07:21:50 <boegel> dafis: I did
07:22:02 <boegel> dafis: but I was aware that the pivot used matters a lot
07:22:12 <boegel> dafis: it worked out fine before, but it seems to fail now
07:22:45 <boegel> let's see if sortBy does better space-wise...
07:24:00 <boegel> dafis: with sortBy, the issue disappears
07:24:17 <boegel> dafis: seems like the warning on the qsort pivot choice was important afterall ;)
07:24:41 <dafis> boegel: yes,pivot choice is pivotal
07:24:56 <dafis> boegel: is sortBy slower than qsort?
07:25:15 <boegel> dafis: when you only need the k first elements, it was on my end
07:25:40 <dafis> boegel: for what kind of values of k (and length xs)?
07:25:41 <boegel> dafis: -> [10:36]  <boegel> ivamn, lispy: version with (take n . sort) on list with 70k elements takes 11m55s, version with own qsort takes 7m25 (same list)
07:25:54 <boegel> dafis: k=3, xs of about 77K elements
07:26:09 <boegel> dafis: I have to admit, I didn't benchmark it thoroughly
07:26:15 <dafis> boegel: how do you choose the pivot?
07:26:27 <boegel> dafis: the values in the list are different now, sizes are the same
07:26:28 * hackagebot json-qq 0.4.0 - Json Quasiquatation library for Haskell.  http://hackage.haskell.org/package/json-qq-0.4.0 (OscarFinnsson)
07:26:36 <boegel> dafis: wait, I'll show you the qsort code
07:26:40 <boegel> @paste
07:26:40 <lambdabot> Haskell pastebin: http://hpaste.org/
07:27:02 <boegel> hpaste is broken? :(
07:27:33 <boegel> dafis: http://pastebin.com/jTuW3szh
07:27:38 <boegel> dafis: gotta run, bbl
07:28:29 * hackagebot aeson-qq 0.4.0 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/aeson-qq-0.4.0 (OscarFinnsson)
07:29:29 * hackagebot text-json-qq 0.4.0 - Json Quasiquatation for Haskell.  http://hackage.haskell.org/package/text-json-qq-0.4.0 (OscarFinnsson)
07:48:37 <jonkri> how are forkIO threads generally timed-out? (for example, let's say that you have a thread waiting for a http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/Control-Concurrent-CML.html#v:receive sync) http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/System-Timeout.html?
07:56:26 <nihtml> :t foldl2 (flip (:) . (+)) []
07:56:26 <lambdabot> Not in scope: `foldl2'
07:58:34 <RichardO> is there a function (a -> a -> c) -> [a] -> [c]?
07:59:46 <mauke> :t map . join
07:59:47 <lambdabot> forall a b. (a -> a -> b) -> [a] -> [b]
07:59:48 <dafis> RichardO: zipWith foo xs (tail xs) ?
08:02:48 <RichardO> I want something like [x1 'f' x2, x2 'f' x3, x3 'f' x4, ...]
08:03:51 <mauke> no, `f`
08:04:08 <Saizan> > let xs = [a,b,c,d] in zipWith f xs (tail xs)
08:04:09 <lambdabot>   Ambiguous type variable `c' in the constraints:
08:04:09 <lambdabot>    `GHC.Show.Show c'
08:04:09 <lambdabot>      a...
08:04:23 <RichardO> ad zipWith xs (tail xs) is what I want
08:04:25 <Saizan> > let xs = [a,b,c,d] :: [Expr] in zipWith f xs (tail xs)
08:04:26 <lambdabot>   Ambiguous type variable `c' in the constraints:
08:04:26 <lambdabot>    `GHC.Show.Show c'
08:04:26 <lambdabot>      a...
08:04:35 <dafis> RichardO: that's zipWith f xs (tail xs)
08:04:51 <mauke> Saizan: [a,b,c,d] is monomorphic
08:05:08 <Saizan> > let xs = [a,b,c,d] in zipWith f xs (tail xs) :: [Expr]
08:05:09 <lambdabot>   [f a b,f b c,f c d]
08:05:12 <Saizan> :t a
08:05:13 <lambdabot> Expr
08:05:43 <siracusa> :t f
08:05:44 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
08:06:54 <RichardO> i feel like (a -> a -> b) -> [a] -> [b] should be in the list library
08:07:01 <RichardO> called reduce
08:07:04 <RichardO> or something
08:07:37 <mauke> reduce is usually foldl
08:09:01 <philed> RichardO: How would that function work?
08:09:12 <copumpkin> :t foldl1
08:09:13 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
08:09:13 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
08:09:30 <RichardO> like reduce f xs = zipWith f xs (tail xs)
08:10:12 <philed> Ah, that's not much like fold.
08:10:20 <aristid> :t let reduce f xs = zipWith f xs (tail xs) in reduce
08:10:21 <lambdabot> forall a c. (a -> a -> c) -> [a] -> [c]
08:10:31 <RichardO> it's like a one layer reduction
08:10:42 <copumpkin> doesn't seem that useful to me, tbh
08:11:22 <RichardO> it's great for relating adjacent elements in a sequence
08:11:37 <copumpkin> for which I'd write zipWith f xs (tail xs) :P
08:11:48 <copumpkin> which isn't much longer than the name of some standardized function
08:12:09 <copumpkin> what if I want to look at three adjacent elements at a time in a sequence?
08:12:11 <philed> Yeah, I think zipping a list with its tail is a recognisable enough idiom that it doesn't need its own function.
08:12:18 <aristid> :t \f -> zipWith f <*> tail
08:12:18 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
08:12:20 <RichardO> i just find zipping a list with itself to be a useful abstraction
08:13:19 <crystal-cola> haskell is all about abstraction
08:13:30 <Xaratas> a is way to generic -.-
08:13:44 <aristid> @pl \f -> zipWith f <*> tail
08:13:45 <lambdabot> (<*> tail) . zipWith
08:14:03 <aristid> :t flip ap tail . zipWith
08:14:04 <lambdabot> forall b c. (b -> b -> c) -> [b] -> [c]
08:14:34 * hackagebot utility-ht 0.0.7 - Various small helper functions for Lists, Maybes, Tuples, Functions  http://hackage.haskell.org/package/utility-ht-0.0.7 (HenningThielemann)
08:14:45 <Skoala> Admittedly not a necessarily Haskell-related question, but: If any of you have to write software specs in your jobs, do you have a certain template that you base the spec on?
08:15:15 <Xaratas> i have a bintree of a and a function which returns the greatest value in the tree, but > wouldn't like any a, which is ok, but if i want to restrict the function for some a, like int, char and so on how much i have to write  more than one time?
08:15:36 * hackagebot enumset 0.0.2 - Sets of enumeration values represented by machine words  http://hackage.haskell.org/package/enumset-0.0.2 (HenningThielemann)
08:15:44 <copumpkin> Xaratas??
08:15:58 <Xaratas> ok, with code ^^
08:15:59 <crystal-cola> Xaratas: just don't type out a signature the computer will figure it out
08:16:08 <merijn> Xaratas: You mean "I want to find the max value in a binary tree but don't know how to implement > for arbitrary a's"?
08:16:29 <Xaratas> greatest :: BinTree a -> Maybe a <-- i have no more signature than this
08:16:34 <crystal-cola> Xaratas: dont' type it out
08:16:36 <RichardO> also I see map inits . tails alot in code. Seems like there could be a name for that
08:16:52 <merijn> Xaratas: Do you know about typeclasses?
08:17:25 <Xaratas> merijn: not yet, they come later in my course
08:17:59 <merijn> Xaratas: Because you basically want to use the "Ord a" typeclass. If you don't mind reading, http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101 is a good explanation
08:18:01 <Xaratas> crystal-cola: interesting, without the line the compiler dont have any problem
08:18:26 <merijn> Xaratas: Yes, because without your type signature the compiler figures the typeclass stuff out for you ;)
08:20:10 <nihtml> @plpow n e = product $ take e $ repeat n
08:20:10 <lambdabot> Unknown command, try @list
08:20:14 <nihtml> @pl pow n e = product $ take e $ repeat n
08:20:15 <lambdabot> pow = (product .) . flip take . repeat
08:24:15 <Saizan> Xaratas: without typeclasse you could just take the comparison function as an argument, still having no code duplication
08:24:27 <RichardO> @pl f x y = g x (map (h x) y)
08:24:27 <lambdabot> f = liftM2 (.) g (map . h)
08:24:42 <Saizan> Xaratas: i.e. greatest :: (a -> a -> Bool) -> BinTree a -> Maybe a
08:25:24 <RichardO> @pl f x = g (map h x)
08:25:24 <lambdabot> f = g . map h
08:26:59 <mzero> RichardO: careful, some of those will only work if you have the right modules imported
08:26:59 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
08:28:35 * hackagebot alsa-seq 0.5.1 - Binding to the ALSA Library API (MIDI sequencer).  http://hackage.haskell.org/package/alsa-seq-0.5.1 (HenningThielemann)
08:30:01 <RichardO> @pl f x = nub (map f (g y z))
08:30:01 <lambdabot> f = fix (const . nub . flip map (g y z))
08:30:02 <Xaratas> Saizan: yes, the exercise used this pattern for the insert function
08:30:58 <RichardO> @pl h x = nub (map f (g y z))
08:30:59 <lambdabot> h = const (nub (map f (g y z)))
08:32:19 <roconnor> coq says that my various numbers are prime
08:32:22 <mzero> point-free: sometimes more clear.... sometimes not!
08:32:51 <RichardO> mzero: Yeah, I'm trying to see what the differences are between the two styles
08:33:00 <RichardO> Trying to get a better intuition for it
08:33:05 <roconnor> Lemma prime_p : prime 115792089237316195423570985008687907852837564279074904382605163141518161494337.
08:33:06 <mzero> a good think to play with
08:33:07 <copumpkin> chances are it won't be very revealing if you don't use the variable parameters you're eliminating
08:33:23 <RichardO> yea, just noticed that
08:33:29 <copumpkin> roconnor: no, sorruy
08:33:38 <copumpkin> okay fine, you can have it
08:35:24 <roconnor> laurent called my numbers "quite small"
08:35:43 <copumpkin> yeah!
08:37:01 <crystal-cola> roconnor: how do prove that number is prime?
08:37:09 <RichardO> Is there a function like flip uncurry?
08:37:37 <DrSyzygy> RichardO: There is flip uncurry
08:37:40 <roconnor> crystal-cola: for these small numbers you use a program to create a pocklinton certificate, and then you use coq to verify the certificate.  I'll hpaste the proof
08:37:52 <nihtml> :t uncurry
08:37:53 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
08:38:01 <crystal-cola> I don't knowmuch about the algorithms I will look up pocklinton certificate
08:38:03 <roconnor> oh wait, is hpaste down?
08:38:20 <RichardO> DrSyzygy: Haha, just curious if there's a difference name for it. I feel like uncurry should be a infix operator.
08:38:56 <copumpkin> o.O
08:38:59 <olsner> it is if you write it `uncurry` :)
08:39:08 <DrSyzygy> RichardO: You can also do things like > f `uncurry` (a,b)
08:39:26 <roconnor> crystal-cola: http://pastebin.com/CSqAGD99
08:39:41 <RichardO> that's what I do, but uncurry is kinda like a special type of function application
08:39:57 <copumpkin> roconnor: oh man
08:40:11 <RichardO> a infix symbol for it in the Control.Arrow might be usefull
08:40:44 <crystal-cola> that's funny you have to prove a bunch of smaller numbers are prmie
08:40:46 <crystal-cola> prime4051
08:40:58 <copumpkin> pocklington's theorem?
08:43:23 <roconnor> copumpkin: yes
08:44:50 <luite> hmm, I didn't know that theorem. but what do you use the primality of those numbers for?
08:46:00 <_nickel> does anyone know where I can find docs/info on how to get ghc to generate C for me?
08:47:39 <copumpkin> _nickel: that is now deprecated
08:48:24 <copumpkin> _nickel: the C it generates isn't portable, anyway
08:48:30 <_nickel> copumpkin: ah!
08:48:38 <copumpkin> jhc generates better C
08:48:59 <_nickel> copumpkin: alright I'll start there
08:49:02 <_nickel> copumpkin: thanks for the direction
08:49:05 <copumpkin> np
08:52:10 <ClaudiusMaximus> hooray, got hmpfr working with ghc-7.0.3/integer-simple : http://pastebin.com/kPF7Gzbr
08:53:43 <copumpkin> ClaudiusMaximus: I was working with edwardk to make it work with integer-gmp
08:53:51 <copumpkin> since it isn't actually that hard
08:54:09 <copumpkin> but I've been really busy
08:54:13 <ClaudiusMaximus> copumpkin: cool
08:54:34 <ClaudiusMaximus> copumpkin: this is my procrastination project instead of what i should really be spending time doing...
08:54:41 <copumpkin> ah :)
09:14:38 <sameed> hi there!
09:15:51 <sameed> how is haskell different from C
09:16:11 <copumpkin> in just about every possible way
09:16:27 <sameed> great someone responded at lasr
09:16:31 <sameed> **last
09:16:35 <Saizan> unless you ask conal
09:16:36 <copumpkin> it took 20 seconds
09:17:17 <sameed> ya,, i said said hello before that.. anyway
09:17:18 <luite> 20 seconds is actually rather slow for this channel, and there was only one response!
09:17:59 <mzero> it *is* Saturday... 
09:20:00 <crystal-cola> the data type of natural numbers has all sorts of amazing structure like prime numbers, addition distributing over multiplication and so on... Are there any more complex data types (like trees or something) that have that sort of stuff?
09:20:09 <tswett> "(++) <$> flip take g1 <*> flip drop g2 <$> pivot" -- is that really clearer than "take pivot g1 ++ drop pivot g2"?
09:20:25 <copumpkin> tswett: no
09:20:51 <mzero> :t splitAt
09:20:52 <lambdabot> forall a. Int -> [a] -> ([a], [a])
09:20:52 <copumpkin> crystal-cola: lists have fun structure too!
09:21:34 <mzero> so    uncurry (++) $ splitAt pivot g1
09:22:06 <crystal-cola> is it distinct from natural numbers?
09:22:09 <mzero> mind you -- I think that is   === id
09:22:34 <kmc> good morning haskellions
09:22:38 <mzero> perhaps you wanted   filp (++)
09:22:49 <tswett> crystal-cola: well, the natural numbers are so full of amazing structure and stuff that there's an entire branch of mathematics devoted to them.  You'd have difficulty finding a data structure with that much stuff, but it may be possible.
09:23:06 <crystal-cola> tswett: well that's what I am asking :)
09:23:13 <mzero> > let rotate n = uncurry (flip (++)) . splitAt n   in    rotate 3 "hakellions"
09:23:15 <lambdabot>   "ellionshak"
09:23:46 <tswett> crystal-cola: right.  :)  Well, you might want to take a look at graphs.
09:24:02 <crystal-cola> good point!
09:24:08 <kmc> aren't the natural numbers a data structure?
09:24:08 <tswett> Or, a bit more adventurously, knots.
09:24:33 <tswett> kmc: yeah, they are.  I guess I should have said "another data structure".
09:24:55 <crystal-cola> I feel like graphs and knots aren't "inductive" in the same way natural numbers are. Maybe natural numbers already say everything e.g. trees can.
09:24:55 <kmc> you could also port all the results of number theory to "list theory" by ignoring the elements
09:25:16 <crystal-cola> kmc: that's trivial though
09:25:24 <kmc> yeah, i don't know of a good way to build graphs inductively
09:25:47 <kmc> if i give you a graph there's not a single clear way to decompose it for a proof
09:25:53 <tswett> Anyway, whoever wrote that line of code I quoted above should be thwapped with a copy of the 1961 Vladivostok telephone directory.
09:25:57 <HugoDaniel> hi
09:26:22 <HugoDaniel> is the Data.Text prefered over Data.ByteString ?
09:26:31 <HugoDaniel> what are the differences between them ?
09:26:41 <kmc> Text stores characters, ByteString stores bytes
09:27:01 <tswett> crystal-cola: well, in a sense, natural numbers say everything that any computer can say, since computer programs can be represented, in various ways, as natural numbers.
09:27:09 <HugoDaniel> kmc: well, there is a Data.ByteString.Char8
09:27:18 <kmc> HugoDaniel, that module is an abomination
09:27:27 <kmc> it doesn't store characters, it stores "characters as long as you speak English"
09:27:27 <HugoDaniel> kmc, really ?
09:27:35 <kmc> yes, really
09:27:37 <HugoDaniel> oh
09:27:39 <HugoDaniel> :/
09:27:48 <tswett> kmc: does it store only the first 256 characters of Unicode or something?
09:27:54 <kmc> yes
09:28:06 <kmc> if you want to encode a sequence of Unicode characters as a sequence of bytes
09:28:10 <kmc> there are many right ways to do that
09:28:14 <kmc> ByteString.Char8 is none of those
09:29:02 <kmc> so neither ByteString nor Text is universally preferred over the other; they have totally different roles
09:29:42 <kmc> functions of type Text -> ByteString are called "Unicode encodings" and functions of type ByteString -> Text are called "Unicode decodings"
09:30:06 <kmc> and (since there are many such pairs of functions) you can't consider the two types equivalent in any easy way
09:30:25 <HugoDaniel> hmm
09:30:34 <HugoDaniel> i want to build a suffix tree
09:30:56 <HugoDaniel> for a given string, unicode string
09:30:58 <HugoDaniel> which one should i use ?
09:31:11 <HugoDaniel> ByteString ? :/
09:31:19 <kmc> why would you use ByteString?
09:31:57 <HugoDaniel> well, since ByteString -> Text is a "Unicode decoding" function, im guessing ByteString is more appropriate
09:32:04 <HugoDaniel> thats just guessing
09:32:38 <kmc> Text stores Unicode strings
09:32:42 <kmc> ByteString stores strings of bytes
09:32:55 <kmc> a "Unicode encoding" is a scheme for representing a Unicode string as a string of bytes
09:33:38 <kmc> (of course Text's internal representation uses specific bytes too, because computers use bytes, but you're not supposed to care which encoding any more than you'd care whether Int is big or little endian)
09:34:10 <HugoDaniel> ah ok
09:34:23 <HugoDaniel> then Text is the way to go
09:34:26 <kmc> maybe read http://www.joelonsoftware.com/articles/Unicode.html
09:34:32 <HugoDaniel> i have
09:34:41 <HugoDaniel> i have read that one before yes
09:35:22 <HugoDaniel> i really couldn't understand the diff. between bytestrings and text since they have similar functions :/
09:35:44 <HugoDaniel> they seem to overlap about 80% of their code
09:35:51 <kmc> the types of ByteString functions all have "Word8" where the Text functions have "Char"
09:36:06 <kmc> that pretty much says what the difference is
09:36:12 <monochrom> this implies bytestring is binary data
09:36:14 <HugoDaniel> yeah, except ByteString.Char8
09:36:26 <kmc> yeah, but ByteString.Char8 is an abomination, as discussed
09:36:31 <HugoDaniel> then why doesn't Text use ByteString as a backend ?
09:36:38 <kmc> it probably could
09:36:41 <HugoDaniel> yeah, i didn't knew that
09:37:06 <kmc> "Manipulate ByteStrings using Char operations. All Chars will be truncated to 8 bits... More specifically these byte strings are taken to be in the subset of Unicode covered by code points 0-255. This covers Unicode Basic Latin, Latin-1 Supplement and C0+C1 Controls."
09:37:07 <HugoDaniel> ok
09:37:09 <HugoDaniel> thanx
09:37:16 <JimmyRcom> asn1rt has some binary utf8 convert functions
09:37:33 <kmc> so does utf8-string and text itself
09:38:02 <roconnor> luite: elliptic curve cryptography
09:38:08 <monochrom> ByteString.Char8 belonged to an era when the western imperialists thought iso-8859-1 would rule the world
09:38:23 <HugoDaniel> ok
09:38:30 <kmc> ByteString.Char8 is like if i made a module with functions like "addInt :: Int -> Int -> Int" but actually they only work on numbers 1 - 10
09:38:38 <JimmyRcom> "utf8-string and text itself"?
09:38:53 <kmc> the 'text' package and the 'utf8-string' package
09:40:13 <_bitbucket> Is there a Haskell function which produces the intersection of 2 infinite lists, provided that the lists are sorted?
09:40:28 <copumpkin> @hackage data-ordlist
09:40:29 <lambdabot> http://hackage.haskell.org/package/data-ordlist
09:40:46 <_bitbucket> Ah, that's what I was looking for
09:40:48 <JimmyRcom> hurr hurr >_< I thought I was in the erlang channel
09:40:58 <monochrom> why has kmc abandoned us?!
09:41:09 <copumpkin> ddarius: food? :D
09:41:15 <copumpkin> monochrom: he's too cool
09:41:35 <monochrom> you two just had dinner together last night
09:42:09 <copumpkin> monochrom: you should come to boston too, then you can join in!
09:44:20 <dfilimon> hi; does anyone know the rules of phutball?
09:44:32 <dfilimon> i have a specific move type i'm not sure if i'm allowed to make
09:45:22 <dfilimon> the situation i'm talking about is
09:45:31 <dfilimon> what happens if i have a row/column/diagonal of Men
09:45:36 <dfilimon> and my ball is at one end
09:45:48 <dfilimon> and this continuous line ends at the edge of the board
09:46:09 <dfilimon> normally, jumping over the men would mean jumping outside the board
09:46:34 <dfilimon> so, can i jump over all of them and land at the edge of the board
09:46:40 <dfilimon> or is the move prohibited?
09:47:05 <copumpkin> um
09:47:09 <copumpkin> haskell?
09:47:09 * mzero wonders how this is related to #haskell.... perhaps phutball is a Monad, or a Cofunctor, or maybe a Coalgebra....
09:47:44 <dfilimon> well, it's not really related, it's just that i'm implementing it in haskell and i can't seem to find a phutball channel
09:47:53 <dfilimon> and since it's mathematically interesting
09:47:54 <tswett> dfilimon: hi!
09:47:56 <copumpkin> I certainly don't know :)
09:47:58 <dfilimon> maybe some of you might know
09:48:10 <dfilimon> tswett: hi!
09:48:13 <mzero> where are the rules defined?
09:48:13 <tswett> dfilimon: I'm pretty sure that if the line of men goes all the way to the edge of the board, you simply can't jump it.
09:48:28 <tswett> Since that would mean landing beyond the edge of the board, which you can't do.
09:48:50 <dfilimon> right
09:48:54 <dfilimon> i thought maybe you could
09:48:57 <dfilimon> land on the edge
09:49:01 <dfilimon> as in... have an exception
09:49:03 <dfilimon> or something
09:49:11 <dfilimon> well, i implemented it wrong then
09:49:17 <dfilimon> thanks for the help :D
09:49:29 <tswett> You're welcome.
09:56:03 * hackagebot acid-state 0.3.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.3.1 (DavidHimmelstrup)
09:59:09 <dfilimon> tswett: also, jumping outside the board is ok if it's the last move and it's across the last line, right?
09:59:49 <tswett> dfilimon: yes, I think jumping beyond the ends of the board is okay.  Just not the sides.
10:00:04 <dfilimon> so like, if i'm Ecks
10:00:11 <dfilimon> i can jump beyond my goal post?
10:00:16 <dfilimon> or only beyond that of Ohs?
10:00:32 <tswett> Well, wouldn't jumping beyond your own goal post cause you to lose?
10:00:44 <tswett> I'd say sure, why not.  :)
10:00:52 <dfilimon> apparently not: f the football passes through your goal line, but ends up elsewhere due to further jumps, the game continues.
10:00:57 <dfilimon> [ http://en.wikipedia.org/wiki/Phutball ]
10:01:14 <tswett> Ah, right.
10:01:51 <dfilimon> hmm, that would make it all rather complicated
10:02:04 <dfilimon> it should therefore have 2 extra rows
10:02:10 <dfilimon> (my matrix)
10:02:24 <osfameron> is there a function that iterates a list, returning before/after contexts for each position?
10:02:30 <osfameron> e.g. something like Int -> Int -> [a] -> [([a], a, [a])]  ?
10:02:35 <tswett> dfilimon: wouldn't one extra row suffice?
10:02:38 <osfameron> (Hoohle doesn't have that exact signature)
10:02:43 <osfameron> *hoogle
10:03:10 <dfilimon> tswett: well, if i'll be able to jump beyond my own goal line as well, i'm guessing not
10:03:33 <osfameron> e.g. context 2 2 [1..10] would give ([],1, [2,3]), ([1], 2, [3,4]) etc.
10:03:49 <Tyr42> hoogle has nothing
10:04:08 <BMeph> osfameron: Check out the local Zipper modules, I'd say.
10:04:21 <dfilimon> osfameron: couldn't you write one?
10:04:35 <dfilimon> you'd just need to accumulate the previous elements in the list
10:04:44 <osfameron> BMeph: ooo, hadn't thought of zippers.  I get the concept, ish, but not the usage of the Zipper modules I've seen
10:04:50 <osfameron> dfilimon: yeah, I think I know how to write it
10:04:53 <dfilimon> and you'd make a new tuple with the accumulated list, the current element and the rest of the list
10:04:56 <Tyr42> just a quick question
10:05:04 <dfilimon> i'm guessing it would be easier :)
10:05:04 <osfameron> but wasn't sure I'd do it the most elegant way ;-)
10:05:27 <Tyr42> "do return x" should be the same as x, right?
10:05:47 <tswett> Tyr42: it's the same as "return x".
10:05:51 <BMeph> osfameron: We'll help! :)
10:05:52 <osfameron> the only trickyish part is making sure the before-context is the right length.  e.g. tail'ing it once it's got to the desired length
10:05:55 <Tyr42> ok
10:06:11 <osfameron> BMeph: hehe, I'll prototype it then and watch #haskell tear it apart ;-)
10:06:21 <dfilimon> have fun ;)
10:06:25 <BMeph> osfameron: What do the two Ints signify?
10:06:37 <osfameron> BMeph: how much before/after context you want
10:07:37 <BMeph> osfameron: Ah, so kind of like "zipper" meets "window", right? :)
10:08:01 <tswett> This is a lot like cojoin for the list comonad, isn't it?
10:08:10 <osfameron> BMeph: er, possibly. 
10:08:23 <osfameron> I only know "window" vaguely from reading about text-editor data structures
10:08:38 <osfameron> I'm thinking of something that would implement contextual grep
10:08:43 <Fuco> is it possible to pass a type constructor as an argument? I have "data Expr = Plus Int Int | Minus Int Int" and I'd like to pass Plus or Minus to a function that would build the result (based on what the parser reads)
10:08:52 <osfameron> e.g.  grep --context=10
10:09:17 <tswett> Fuco: well, Plus and Minus are data structures there, not type constructors.
10:09:23 <tswett> Er, data constructors.
10:09:32 <tswett> And data constructors can be passed just like any other function.
10:09:46 <BMeph> Fuco: "Yes, Haskell can do that!" ;þ
10:09:51 <tswett> Plus and Minus there have the type Int -> Int -> Expr.
10:09:59 <Fuco> ok, I see
10:14:10 <monochrom> type class is a way to pass a type constructor as argument
10:31:00 <dafis> ping boegel ?
10:34:27 <osfameron> ok, here's my contextual list thingy I was talking about above: https://gist.github.com/923338
10:34:53 <osfameron> what's my next step to make it prettier/better? ;-)
10:41:50 <dfilimon> osfameron: why change it?
10:42:23 <osfameron> dfilimon: well, no reason really.  It does seem to *work* ;-)
10:42:32 <dfilimon> maybe... you could unify the cases where b is 0 and not 0
10:42:34 <dfilimon> with an if
10:42:41 <dfilimon> i personally would do that
10:43:00 <dfilimon> they seem to look quite similar hmmm
10:43:03 <dfilimon> well not really
10:43:05 <osfameron> on the other hand, I don't know if it's that efficient.  for example, I'm having to take the after-context every time, perhaps there are cleverer things I could do with that
10:43:17 <osfameron> which might be where BMeph's suggestion of zipper/window stuff comes in
10:43:38 <osfameron> though I suppose I don't *really* need to micro-optimize it yet, just curious
10:43:42 <dfilimon> well, maybe
10:43:49 <dfilimon> if you'd keep your last
10:43:54 <dfilimon> value in the list somewhere
10:44:04 <dfilimon> you could just do it in one step
10:44:12 <dfilimon> get the head out of xs
10:44:17 <dfilimon> and stick it in bs
10:44:25 <dfilimon> or rather
10:44:27 <dfilimon> stick a in bs
10:44:33 <dfilimon> and pus x in the middle
10:44:39 <dfilimon> that seems to be what you're doing, right?
10:45:14 <osfameron> yeah
10:45:38 <dfilimon> that would seem a wee bit more efficient
10:45:49 <dfilimon> but still, you'd be going over the list
10:45:52 <dfilimon> once at each step
10:45:54 <dfilimon> for the append
10:46:02 <dfilimon> so really, it would still be O(n^2)
10:46:32 <dfilimon> except if haskell has some lazy magic up its sleeve but hmm
10:46:33 <osfameron> whereas if I had a zipper, I'd merely need to take elements in both directions of the zipper
10:47:45 <osfameron> although a zipper would mean having to remember every line forever
10:47:56 <osfameron> which I don't *really* want to do
10:48:05 <dfilimon> well, you *could* do something else perhaps, maybe
10:48:11 <dfilimon> have both the list and the reversed list
10:48:13 <osfameron> if grepping through a very long file, when you only want a fairly small context
10:48:14 <dfilimon> and use both
10:48:39 <dfilimon> for [1, 2, 3, 4] you want
10:49:09 <dfilimon> [([], 1, [2, 3, 4]), ([1], 2, [3, 4]), ([1, 2], 3, [4]), ([1, 2, 3], 4, [])]
10:49:13 <dfilimon> right?
10:49:51 <osfameron> dfilimon: yes, if I wanted before/after context of 3+
10:51:08 <dfilimon> hmm, no, having the reversed list wouldn't help i think
10:51:47 <osfameron> I think reversed-list is conceptually the same case as Zipper
10:51:55 <dfilimon> or maybe hmm
10:52:22 <jix> if you don't want to store all lines forever just use some queue
10:52:28 <dfilimon> try building the part on the left as you're going back up the tree
10:52:33 <dfilimon> (call tree)
10:53:23 <osfameron> jix: yeah.
10:53:23 <dfilimon> or yes, a queue
10:53:49 <dfilimon> queue is exactly what you need really, but how do you use one in haskell?
10:53:59 * osfameron looks at http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Queue.html
10:54:04 <osfameron> oh, that's deprecated
10:54:24 <osfameron> and the doc-page is for hugs
10:54:29 * osfameron looks on hoogle instead...
10:54:35 <jix> there is dequeue on hackage
10:55:52 <osfameron> ta
10:55:59 <osfameron> hackage is very slow...
10:56:08 <dfilimon> these look like just the thing - http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html
10:56:49 <jens_> #haskell-in-depth
10:57:05 <jix> dfilimon: that one will do, but since it allows way more than constant time access to both ends it isn't the fastest one if you just need a queue
10:57:27 <osoleve> could someone help me out with a type error here? https://ideone.com/vTtPV
10:57:35 <dfilimon> that one uses finger trees doesn't it?
10:57:40 <jix> it does
10:57:47 <osoleve> i'm getting 'Couldn't match expected type [[Int32]] with actual type IO [Int32]
10:57:50 <dfilimon> while the one to use is to keep 2 lists
10:57:58 <dfilimon> i mean, how you normally would implement queues
10:58:08 <osoleve> on line 70
10:58:12 <jix> dfilimon: yeah banker's queue ... that one is implemented in the dequeue package
10:59:08 <osoleve> WAVESample is type Int32, by the way
10:59:18 <osoleve> and WAVESamples is [[Int32]]
11:01:16 <megajosh2> Is anyone familliar with http-enumerator? I'm confused as to how exactly I should send a form using POST
11:01:18 <osfameron> dammit, hackage docs don't have a SYNOPSIS section
11:01:32 * osfameron hugs CPAN and its readable perldocs...
11:01:52 <megajosh2> I thought you'd just use parseURL and attach it to the end of the URL like it was using GET
11:02:03 <megajosh2> Then change the method to POST with the resulting Request type
11:02:10 <dfilimon> osolve: i don't understand, getWavSamples seems to be IO [Int32]
11:02:22 <Saizan> osfameron: each module has one, but it's in the silly js hideable panel
11:02:26 <Saizan> osfameron: on the right
11:02:33 <dfilimon> extendNotes is only [Int32]
11:02:39 <dfilimon> where did you get rid of the IO ?
11:02:57 <osoleve> dfilimon: in the <$>, i thought
11:03:03 <dafis> dfilimon: not, that's the cause of the error
11:03:16 <osoleve> ohhhh
11:03:19 <osoleve> i need to extract it
11:03:20 <osoleve> right.
11:03:26 <dfilimon> unsafePerformIO ?
11:03:27 <osfameron> Saizan: ah, interesting, thanks... though... that looks like an auto-generated list of members
11:03:37 <osfameron> I'm thinking of a "here's a minimal example of how to use this"
11:04:00 <osfameron> (which is what perldocs synopsis section usually means, sorry if my terminology is overloaded wrongly here ;-)
11:04:04 <dfilimon> i'm not actually familiar with fmap
11:04:35 <Tyr42> is hpaste down?
11:04:51 <osfameron> Tyr42: was for me earlier
11:05:22 <Tyr42> darn
11:05:32 <Saizan> osfameron: ah, that usually goes in the blub of text on top of modules' docs, but it's not so widespread to include such stuff
11:05:38 <osfameron> Tyr42: http://gist.github.com/ ?
11:05:42 <dafis> Tyr42: pastebin?
11:05:53 <osoleve> okay, so I changed samples to getWavSamples >>= \s -> extendNotes s >>= map (:[])
11:06:00 <osfameron> Saizan: that's a Bad Thing, I think ;-)
11:06:18 <osoleve> now I get "Couldn't match expected type [a0] with actual type IO [Int32]
11:06:30 <osfameron> for example, I have no idea how I'd use BankersQueue from that page
11:06:54 <osfameron> (or why, though ok, the doc defers to Osaki for that)
11:07:06 <osfameron> *Okasaki
11:07:21 <Saizan> osoleve: the "map (:[])" part is the culprit
11:07:37 <Saizan> osoleve: replace it with "return . map (:[])"
11:08:06 <osoleve> Saizan: same error, it's complaining about getWavSamples
11:08:31 <Saizan> osoleve: i guess you had more than one problem then :)
11:08:36 <rovar> https://gist.github.com/923372
11:09:04 <Saizan> osfameron: what's unclear to you? the API is so small and simple
11:09:07 <rovar> in this particular example.. DB.:= constructs a DB.Field  from a String and a DB.Value
11:09:30 <osfameron> Saizan: how do I create one?
11:09:52 <osfameron> Saizan: bearing in mind I haven't programmed Haskell for a year or more now... an example really helps get my mental juices ticking
11:10:01 <Saizan> osfameron: are you talking about this http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Queue.html ?
11:10:11 <osfameron> Saizan: no, http://hackage.haskell.org/packages/archive/dequeue/0.1.5/doc/html/Data-Dequeue.html
11:10:17 <rovar> Int is a DB.Value.. and when I do  ([1,2..] ::Int)  I would expect this to work.. but it fails with Couldn't match expected type `DB.Value' with actual type `Int'
11:10:46 <rovar> do I have to construct a DB.Value one at a time from each list? 
11:11:36 <rovar> I guess i could flip the DB.:= and then combine it with DB.Val
11:11:48 <rovar> will try that..
11:12:15 <Saizan> osfameron: ah, anyhow, since BankersDequeue is an instance of Dequeue then "empty" is an empty BankersDequeue, and you can add to it with pushFront and pushBack
11:12:47 <osfameron> Saizan: so it doesn't have a fixed length?  I have to keep track of that myself?
11:12:55 <osfameron> I just tried using fromList and got a strange type error
11:13:00 <Saizan> osfameron: there's a length method too
11:13:13 <Saizan> osfameron: you probably need to add a type signature
11:13:24 <osfameron> right... fromList [1,2,3] :: BankersDequeue Int
11:13:47 <osfameron> point being that having a couple of examples of how to go about using it would help... hence me asking about a Synopsis
11:14:02 <osfameron> might not be useful for non-numpties I suppose...
11:16:33 <osoleve> Saizan: now I get "Couldn't match expected type [a0] with actual type 'IO String' in getNotesAndOctaves on line 92
11:16:36 <osoleve> https://ideone.com/vTtPV#view_edit_box
11:16:46 <osoleve> I'm getting really frustrated :(
11:18:15 <mauke> that's because the type signature of getWavSamples is wrong
11:18:39 <osoleve> it is?
11:19:54 <Saizan> yes
11:19:58 <osoleve> hrm
11:20:11 <Saizan> see the type singnature of (>>=)
11:20:15 <Saizan> ?type (>>=)
11:20:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:20:37 <Saizan> here you're using it with getNotesAndOctaves as first argument
11:20:46 <Saizan> which has type IO String
11:20:50 <Saizan> then m = IO
11:20:54 <osoleve> so it returns IO [Int32]
11:21:05 <osoleve> or, evaluates to
11:21:12 <mauke> (not returns, is)
11:21:17 <Saizan> neither, "is"
11:21:32 <Saizan> well, "has type" :)
11:21:43 <osoleve> okay, thanks, i'll see if I can work through from here :)
11:24:10 <td123> does haskell support tail recursion?
11:24:42 <mauke> ...
11:24:59 <Rotaerk_> lol
11:25:04 <Saizan> it's hard to think of a language that doesn't support tail recursion, if you're thinking of "tail recursion optimization" then yes
11:25:27 <td123> ah
11:25:34 <td123> I'm thinking about optimization thanks
11:25:40 <Saizan> but some tail recursive programs might still give you a stack overflow if you aren't careful about lazyness.
11:26:52 <Saizan> because the recursion is done in constant stack, but it produces a big unevaluated thunk that might need O(n) stack to evaluate, if the functions involved are strict
11:27:00 <monochrom> the short answer is yes
11:27:26 <mauke> the long answer is hell yes, motherfucker
11:28:00 <td123> mauke: "motherfucker" do you know something I don't? :P
11:28:20 <monochrom> the short answer is yes for this too
11:28:45 <Saizan> i'm impressed that noone specified that only implementations can support optimizations
11:28:56 <osoleve> only imple-- oh
11:29:02 <monochrom> that's for the longlong answer
11:30:27 <mauke> "the short answer is no. the long answer is yes."
11:32:01 <td123> good deal
11:32:57 <td123> I was working on a project in python, when I realized I will either need a really expensive computer or another language to do the computations I need in a reasonable amount of time
11:33:45 <megajosh2> Hey, does anybody know how to get a list of packages a Haskell module linked in?
11:33:49 <td123> already knew ocaml, never used haskell for a personal project, but the pure functionality drove me to it :)
11:33:56 <megajosh2> I know it had something to do with .hi files but I can't remember
11:35:27 <monochrom> you're in for a surprise because haskell evaluation order uproots all your expectations
11:39:38 <osoleve> okay, i'm stumped again :(
11:39:58 <osoleve> https://ideone.com/7pMVn "Couldn't match expected type [t0] with actual type IO String'
11:40:15 <osoleve> on line 92, n<- getNotesAndOctaves
11:40:33 <mauke> type signature is still wrong
11:41:30 <osoleve> I thought <- syntax pulled values out of monads?
11:41:31 <osoleve> gah
11:42:06 <mauke> no, out of monadic values
11:42:19 <mauke> but that doesn't change the type of the whole thing
11:42:34 <osoleve> okay, so that one is IO [WAVESample]
11:43:33 <siracusa> megajosh2: ghc --show-iface M.hi
11:43:51 <megajosh2> siracusa: Thanks :D
11:46:09 <Guest90122> is there any haskell construct, monad, idiom,don't know, that see [] as "fail" ? i mean if the result of computation is a list goes on, if is an empty list it stops?
11:46:55 <mauke> yes
11:47:24 <Guest90122> which?
11:47:31 <boegel> dafis: pong
11:47:45 <mauke> [] and its monad instance
11:48:04 <Guest90122> but it is defined as a fold...
11:48:11 <dafis> boegel: can it be that your list is almost sorted in decreasing order?
11:48:21 <Guest90122> if it is [] it only appends
11:48:37 <boegel> dafis: that would surprise me
11:49:00 <dafis> boegel: me too, but it would explain the memory behaviour
11:49:16 <boegel> dafis: thinking about the data, it would be really surprising
11:49:32 <monochrom> > fail "does not matter" :: [Int]
11:49:33 <lambdabot>   []
11:49:41 <boegel> dafis: the value I'm sorting is determined by various features of elements of another list
11:50:08 <roconnor> @where TTFP
11:50:08 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
11:50:09 <boegel> dafis: and I don't think it makes sense that earlier values would be bigger than later values
11:50:12 <jix> > [] >>= undefined
11:50:13 <lambdabot>   []
11:50:36 <Guest90122> no, i mean run some function on a list, if the result of that is [] ,hangs not matter the rest of input
11:50:49 <dafis> boegel: in your qsort, if you replace ls = filter ...; rs = filter ...; with (ls, rs) = partition ((== GT) . cmp x), does the space behaviour change?
11:51:28 <boegel> dafis: I can check
11:51:42 <boegel> dafis: that would make a lot of sense actually, only going over the list once :)
11:53:14 <boegel> dafis: using sortBy however, the sortBy is no longer a bottleneck whatsoever (other functions are); just did a profile run
11:53:29 <boegel> dafis: let's see if partition instead of 2x filter helps...
11:54:59 <dafis> boegel: since you only take a handful of the smallest elements, you'll only go over most of the parts once, and partition allocates a lot of (,), so it won't be faster generally, but it guarantees O(n) space instead of worst case O(n^2) you can have with two filters
11:55:00 <BMeph> > head [2,3,4]
11:55:00 <lambdabot>   2
11:55:27 <BMeph> > sequence . head [[2,3,4],[2,3],[]]
11:55:27 <lambdabot>   No instance for (GHC.Num.Num [m a])
11:55:28 <lambdabot>    arising from a use of `e_123423' at ...
11:55:32 <BMeph> > sequence . head $ [[2,3,4],[2,3],[]]
11:55:33 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
11:55:34 <lambdabot>    arising from a use of `M55364956...
11:55:51 <BMeph> ...never mind.
11:56:59 <siracusa> Guest90122: Can you give an example of what you want?
12:00:40 <boegel> dafis: you're absolutely right
12:00:46 <boegel> dafis: anyway, I have to go, ttyl
12:00:55 <dafis> ttyl?
12:01:03 <boegel> dafis: talk to you later :)
12:01:21 <dafis> boegel: okay
12:01:22 <boegel> dafis: using partition seems to be helping a lot, thx for the suggestion!
12:17:36 <ClaudiusMaximus> 15% of my sparks are getting pruned, should i worry?
12:18:52 <luite> I think that should be ok, I'd worry more if 15% of your prunes is getting sparked
12:25:55 <bkadoctaj> Hi all. :)  Just exploring Haskell with a CS major friend of mine and we're trying to figure out a simple, hopefully built-in way to add elements of two equally long lists.
12:26:04 <bkadoctaj> Does such a function exist?
12:26:12 <lispy> bkadoctaj: zipWith
12:26:46 <lispy> bkadoctaj: I'll let you figure out the rest :)
12:26:55 <luite> which even works with lists of different length (but then the result will be as short as the shortest one)
12:27:03 <bkadoctaj> Thanks!  :)
12:27:29 <lispy> :t zipWith
12:27:30 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:43:56 <dsimon> okay, i have a silly haskell question :-)
12:44:16 <dsimon> i'm sure it's silly, but i will nevertheless ask it because i think the answer will be educational to me
12:44:59 <dsimon> when haskell runs out of working memory due to keeping things around to be lazily executed later... why, rather than crashing, doesn't it simply execute some of that stuff to make room?
12:45:39 <monochrom> it is undecidable whether that frees memory or consumes more memory
12:45:58 <c_wraith> dsimon: it's not really feasible to tell, for a particular expression, if that will use more memory or less.  and monochrom beat me to it.
12:46:29 <dsimon> ah, yeah
12:46:45 <dsimon> that does make sense
12:46:59 <monochrom> but we do look forward to a bright future where...
12:47:24 <monochrom> if you code up bubble sort, the compiler is smart enough to replace your code by merge sort or quick sort
12:47:43 <c_wraith> but, but.  there is a use case where bubble sort is faster than those!
12:48:04 <c_wraith> ...  Though that use case hasn't been relevant in 30 years.
12:48:11 <path[l]> haha
12:48:12 <luite> but then programmers would never learn! it should refuse to compile the code with a stupid programmer error
12:48:23 <monochrom> the compiler is smart enough to either prove that you are not in that use case, or add fast code for that use case
12:48:25 <dsimon> luite, if it could do that, then we wouldn't need programmers
12:48:34 <ClaudiusMaximus> oh dear.  "internal error: heapCensus, unknown object: 44571"
12:48:44 <dsimon> just have something generate randomish code with a GA until the compiler finds a local minimum of stupidity
12:48:53 <lispy> ClaudiusMaximus: what version of ghc?
12:49:13 <ClaudiusMaximus> lispy:  (GHC version 7.0.3 for x86_64_unknown_linux)  self-compiled with integer-simple
12:49:14 <conal> dsimon: what you're suggesting is a good idea. could be very helpful in many cases. wadler suggested the same thing in an old paper for the special case of 'fst (a,b)' and 'snd (a,b)'.
12:49:57 <dsimon> conal, perhaps it could be generalized in order to mark any function that tends to have smaller outputs than inputs?
12:50:05 <lispy> ClaudiusMaximus: weird!  do you need integer-simple?
12:50:33 <lispy> dsimon: have you ever looked at memoization stuff?  They have some similar challenges
12:50:38 <ClaudiusMaximus> lispy: well, hmpfr says i do, and if i use 6.12.3 without integer-simple i get random crashes and wrong output
12:50:53 <dsimon> lispy, nope, let me google it
12:50:58 <lispy> ClaudiusMaximus: but you're getting a random crash now too :)
12:51:06 <conal> dsimon: yes. also for functions that are known to terminate on non-_|_ arguments.
12:51:36 <lispy> ah, bottom.  It makes everything harder :)
12:51:38 <ClaudiusMaximus> lispy: true..  only noticed it when adding rts options like +RTS -N -A2.5M -s -hT -RTS
12:51:44 <conal> dsimon: i.e., avoid losing termination.
12:52:32 <lispy> Either you can't express everything or you're inconsistent.  Curse you Goedel!
12:52:55 <dsimon> lispy, ah, with memoization though, it seems crucially different, because it's always safe to throw away the memo cache, right?
12:53:06 <conal> pure laziness (postpone as much computing as possible) just scratches the surface of possible strategies for managing space & time.
12:53:48 <lispy> dsimon: Kind of.  You have a big run-time hit for doing that.  The similarity I'm thinking of is in how they decide when to keep something vs. when to recompute.
12:54:57 <lispy> dsimon: memoization has to consider the space to store it (and balance that with available space) and consider the time to recompute.  It can make the difference between an algo that won't terminate this year and one that will.
12:55:17 <lispy> dsimon: so the first problem, balancing storage seems similar at least te me
12:56:38 <lispy> if we memoized every computable function that we compute and had O(1) lookup time.  What would the universe be like?
12:56:50 <dsimon> much bigger than our universe, i suspect :-)
12:57:17 <luite> at least that would settle the question whether it is infinite in size
12:57:39 <dsimon> i mean, are there anything like enough atoms in our light cone to hold a hash table for all possible functions from a domain width of, say, 1024 bits?
12:57:39 <conal> lispy: i like that thought experiment. including ghc as one of the computable functions.
12:58:28 <conal> lispy: and then combined with other thought experiments on more flexible strategies for evaluation&gc.
12:58:46 <dsimon> well, although i guess that depends on how you use the atoms as storage space...
12:59:26 <dsimon> anyways, even if the universe was infinitely large and could hold as big a hash table as you like, once it got big enough some parts of it would not be accessible from any given reference point
12:59:45 <dsimon> and if you care about having stuff anytime soon, than anything even further than a lightyear away would probably get to be impractical...
12:59:46 <lispy> conal: it seems like in that world that iteration would become one of the more expensive things
12:59:54 <lispy> conal: at least the first time you iterate
13:00:15 <conal> lispy: maybe that universe is a sort of Collective Mind. in that when one member (person etc) figures something out, the others all know it. i.e., the need only "remember", not compute.
13:00:28 <Xaratas> is there a pattern matching rule to distingush strings with one and strings with more than one character?
13:00:46 <conal> Xaratas: what's a "pattern matching rule"?
13:00:54 <lispy> Xaratas: yes.  String is just a list of Char.  so you use a list pattern to match that
13:00:59 <Xaratas> something like (x:xs)
13:01:29 <ClaudiusMaximus> > case "hello world" of 'h':'e':'l':'l':'o':' ':you -> you
13:01:30 <lambdabot>   "world"
13:02:15 <Taslem> Anyone know of any simple, low-level audio libraries?
13:02:23 <Xaratas> so just one letter would match to (x:[]) ?
13:02:23 <byorgey> strings with one character match [_].  Strings with more than one match (_:_:_).
13:02:44 <mauke> Xaratas: yes
13:02:48 <conal> that hello world match example is so much more elegant in prolog.
13:02:50 <lispy> Xaratas: yeah, (x:[]) is going to be the same as [x]
13:02:55 <Xaratas> good to know :) thanks
13:03:16 <Taslem> *high-level, I mean. Like, "PlaySoundFile" functions, etc.
13:03:17 <lispy> > map (:[]) "happy monkey face"
13:03:18 <lambdabot>   ["h","a","p","p","y"," ","m","o","n","k","e","y"," ","f","a","c","e"]
13:04:34 <dsimon> > map (:[] . :[]) "meta happy monkey face"
13:04:35 <lambdabot>   <no location info>: parse error on input `:'
13:04:54 <dsimon> > map ((:[]) . (:[])) "meta happy monkey face"
13:04:56 <lambdabot>   [["m"],["e"],["t"],["a"],[" "],["h"],["a"],["p"],["p"],["y"],[" "],["m"],["...
13:05:13 <Taslem> Can anyone help me with audio?
13:05:26 <lispy> Taslem: sorry but I can't.  Have you looked at hackage?
13:05:55 <Taslem> No, haven't yet.
13:09:00 <lispy> Taslem: I'd check there.  If it's not on hackage it doesn't exist :)
13:09:13 <Taslem> Yeah, it's just hard to find one that works how I need it.
13:09:45 <lispy> Taslem: if there is a C library that does what you want you could bind to it using the FFI and put your binding on hackage for others.
13:11:16 <Berengal> Taslem: If you can't find anything on hackage, you could check out this pre-alpha package: https://github.com/Berengal/SFML---Haskell-bindings
13:14:54 * Berengal rhymes like a coder, write code while listening to Ocean Loader
13:16:16 <zomg> YO.
13:16:21 <zomg> There, now your rhyme is complete
13:16:35 <ClaudiusMaximus> d.c. al coda
13:18:13 <RichardO> What's the precedence of ($)?
13:18:31 <Saizan> infixr 0
13:19:19 <ClaudiusMaximus> RichardO: :info ($) in ghci will tell you
13:19:27 <RichardO> k, thanks
13:21:44 <RichardO> Does anyone think $& is a good symbol for uncurry. uncurry is kinda like function application, but you convert a pair into two separate arguments.
13:22:21 <monochrom> I think so.
13:22:33 <mm_freak> is there a way to get the current package's version number?
13:22:49 <tomh-> ugh I hate custom operators
13:22:56 <mauke> yes Paths_something
13:23:08 <RichardO> I almost only use uncurry as `uncurry`
13:23:21 <monochrom> why do you hate custom operators? do you also hate custom functions?
13:23:39 <tomh-> monochrom: no, a custom operator doesn't describe what it does, a properly named function does
13:23:47 <mm_freak> RichardO: i almost always use it like (uncurry f .)
13:23:52 <mm_freak> so i see no use for an operator for me
13:24:02 <RichardO> I only like custom operators for abstract things
13:24:11 <RichardO> i feel uncurry is very abstract
13:24:15 <monochrom> "properly named function" is a non-existent ideal
13:24:24 <mauke> addTwoNumbers
13:24:38 <tomh-> well + is a well known operator
13:24:43 <monochrom> at least as long as there are self-inflicted limits on length and character set used in names
13:24:46 <mm_freak> i think there is no good name for 'return'
13:24:57 <dsimon> mm_freak, i always though 'enclose' would be nice
13:25:01 <mauke> mm_freak: cons, obviously
13:25:06 <tomh-> the return in haskell is kinda weirdly chosen I guess
13:25:13 <jaspervdj> or, `pure`, like in applicative
13:25:14 <RichardO> curry is some guys name. how does that describe a function which is basically function application
13:25:16 <mm_freak> dsimon: doesn't play well with state-like monads or the unit monad
13:25:36 <mm_freak> dsimon: the "proper" name for 'return' depends on the monad and its interpretation
13:26:01 <mm_freak> fromPure
13:26:08 <mm_freak> perhaps, but that doesn't describe at all what it does
13:26:26 <mauke> proper :: a -> m a
13:26:31 <RichardO> again, I actually think return could be a symbol. The only problem is no one uses unicode
13:26:31 <mauke> now that's a proper name
13:26:41 <mm_freak> a "proper" name, yes =)
13:26:54 <tomh-> I prefer no symbols
13:26:58 <jaspervdj> A perhaps something like `lift` for the current return
13:27:01 <mm_freak> RichardO: like what?
13:27:02 <jaspervdj> *Or
13:27:07 <mm_freak> 'unit'
13:27:13 <tomh-> I just want to program with ascii :P
13:27:18 <Zao> RichardO: Recycling circle? :D
13:27:23 <tomh-> and some special characters available on my keyboard
13:27:26 <mm_freak> but 'unit' would make monads even more scary to beginners =)
13:27:32 <mauke> tomh-: ascii? that's so 1980s
13:27:44 <tomh-> yeah, oldschool :)
13:27:59 <monochrom> Monad's return is aka η in category theory books. that's your symbol there.
13:28:01 <mm_freak> if editor support were better, i would use unicode =)
13:28:31 <mm_freak> but → looks so ugly in a fixed font
13:28:37 <monochrom> people who believe in "proper" english "name"s can go back to cobol
13:29:13 <mm_freak> monochrom: cobol can be emulated well in haskell, if you "id" to "please"
13:29:24 <mm_freak> main = please print 3
13:29:32 <mm_freak> you → you rename
13:30:00 <monochrom> but how do you do "multiply x by y to z"?
13:30:01 <RichardO> Certain functions have physical analogues and can be named intelligently. Some functions are very abstract, and usually don't change semantics significantly. I think the second class should be symbols
13:30:29 <RichardO> the function return is almost like boilerplate
13:31:13 <mm_freak> monochrom: rename "=" to "be"
13:31:20 <mm_freak> let y be multiply x by y
13:31:22 <RichardO> when you have a tuple, and want to pass the elements individually to a function, it should be painless; like ($) for regular application
13:31:22 <mm_freak> by = undefined
13:31:31 <mm_freak> multiply :: Num a => a -> b -> a -> a
13:32:00 <mm_freak> or
13:32:11 <monochrom> "by = undefined" breaks things
13:32:15 <mm_freak> let z be x `multiplied` by y
13:32:23 <mm_freak> then you can have by = id
13:32:33 <mm_freak> and multiplied = (*)
13:32:44 <monochrom> well, I guess unless you define "multiply" suitably
13:33:04 <mm_freak> RichardO: you know, mathematicians are often blamed for using only symbols and single-letter names
13:33:10 <mm_freak> RichardO: i prefer words
13:33:18 <mm_freak> even if they are not accurate
13:34:26 <monochrom> all names are cultural references only
13:35:12 <mm_freak> > let z = the product of 3 and 4 in z
13:35:13 <lambdabot>   <no location info>: parse error on input `of'
13:35:49 <mm_freak> uh
13:37:03 <mm_freak> > case analysis of syntax -> bullshit
13:37:05 <lambdabot>   True
13:37:33 <mm_freak> @undef
13:38:32 <Xaratas> is there a way to use parts of records in patternmatching?
13:39:11 <mauke> yes
13:40:09 <BMeph> @remember  mm_freak > case analysis of syntax -> bullshit  <lambdabot>   True
13:40:09 <lambdabot> Okay.
13:40:30 <mauke> case programmer of P{ drunk = FileNotFound } -> wat
13:41:25 <mm_freak> Xaratas: MyType { field = patternName }
13:41:49 <mm_freak> if you need the whole record, too, use @ syntax
13:42:11 <mm_freak> cfg@(MyConfig { configTimeout = timeout }
13:42:13 <mm_freak> )
13:42:20 <mauke> ( ) not actually needed
13:42:41 <mm_freak> oh, ok
13:42:46 <Taslem> Makes it a bit more clear most of the time, though, doesn't it?
13:43:19 <mm_freak> Taslem: it's not ambiguous
13:43:43 <mm_freak> record stuff binds tighter than function application
13:43:52 <mm_freak> f MyConfig { … }
13:44:02 <Taslem> I know. But humans oftentimes misinterpret stuff. Like interpreting cfg@MyConfig { configTimeout = timeout } as  cfg@(MyConfig) { configTimeout = timeout }
13:44:10 <boegel> dafis: mail arrived, but I'm off to bed now, will read it later :)
13:44:14 <mauke> that's why I don't put a space before {
13:44:22 <mm_freak> Taslem: how would that make sense?
13:44:42 <Taslem> It doesn't. But someone who rarely uses it, or glances over it, might misread it.
13:44:44 <Xaratas> :)
13:45:02 <Taslem> Which could confuse them.
13:46:30 <Taslem> Could you explain what the "sig y" means in this type: (Handle -> sig y -> IO ())
13:47:09 <shachaf> Taslem: Is "sig" lowercase?
13:47:25 <Taslem> Yes.
13:47:34 <shachaf> Is there a class constraint, then?
13:47:50 <Taslem> C y.
13:48:11 <byorgey> Taslem: sig is a variable standing for some type constructor
13:48:38 <Taslem> Hm.  Okay. Doesn't make sense why they'd do it like that. Oh well.
13:49:10 <byorgey> e.g. sig could be Maybe
13:49:30 <byorgey> hmm, is this one of Henning's libraries?
13:49:41 <Taslem> Yep.
13:49:46 <Taslem> How'd you guess?
13:49:54 <byorgey> ok, then there's more to the C than meets the eye =)
13:50:13 <byorgey> it is probably something actually like  Foo.Blah.C, but Haddock is displaying only C
13:50:24 <byorgey> unfortunately to know what it is you have to look at the source.
13:51:01 <roconnor> ivanm: rant posted:llsping
13:51:06 <monochrom> if it is a hyperlink, click on it to see where it brings you
13:51:25 <byorgey> Henning likes this style where every module defines a type called T and a class called C, and to use them you have to import qualified and write  Some.Module.T or .C
13:51:40 * dafis abhors that style
13:51:45 <byorgey> it's not a bad style as it goes, but doesn't (yet) work very well with Haddock
13:51:47 * crystal-cola abhors a vacuum
13:52:13 <roconnor> ivanm: oops
13:52:19 <TTimo> looks like ghc programs don't like being passed a -N[n] where n > physical cores on the system .. I passed 4 on a dual core and it tanked out hard .. it's totally fine at 2
13:52:25 <Peaker> byorgey, Why not: import Data.Map(Map)?
13:52:38 <Peaker> byorgey, so you have Map the module and Map the type?
13:52:43 <roconnor> ivanm, crystal-cola: http://r6.ca/blog/20110416T204742Z.html
13:52:45 <Taslem> Don't you find it more than slightly creepy you can identify a programmer by his code? And not his comments? :P
13:52:46 <Peaker> Instead of Map.T?
13:52:55 <Xaratas> ? wtf? why should more than one module use a type SomeName if it is not the same? that does not sound like good code
13:53:26 <shachaf> Xaratas: Why? Just import them qualified. It's "the type of SomeModule".
13:54:12 <byorgey> Xaratas: if you follow that logic to its extreme, why have a hierarchical module system and qualified imports at all?  everyone should just use different names for everything.
13:54:17 <Xaratas> but everywhere everything named as T and C looks really stange
13:54:22 <mauke> standard OO Perl example is $dog->bark and $tree->bark
13:54:47 <shachaf> Xaratas: Do you object to foo_t and bar_t in C++, say?
13:54:50 <mauke> you've got Map.empty, Map.insert, and Map.T for the type of maps
13:55:00 <shachaf> Just replace the underscores and it looks the same. :-)
13:55:05 * roconnor uses GUIDs for all his variable names
13:56:41 <Xaratas> i am used to meaningfull varible/ datatype/ classnames, and C is only meaningfull for the speed of light
13:56:47 <byorgey> newtype ApplicativeMonoid f m = AM (f m);  instance (Monoid m, Applicative f) => Monoid (ApplicativeMonoid f m) where mempty = AM $ pure mempty; (AM f1) `mappend` (AM f2) = AM $ fmap mappend f1 <*> f2
13:56:57 <byorgey> anyone ever used/seen that Monoid instance before?
13:57:02 <shachaf> Xaratas: But the name isn't "C"; it's "Some.Module.C".
13:57:46 <Saizan> byorgey: not fleshed out in haskell code
13:58:49 <byorgey> Saizan: I don't care if it was fleshed out in haskell code or not, just seeing if anyone knows of any interesting references/connections
14:00:30 <Xaratas> its java.lang.Syestem.out.println in java, not java.lang.C.o.println …
14:02:33 <dsimon> Xaratas, as far as i'm concerned that's a mark against java :-)
14:03:33 <Xaratas> dsimon: the java.lang part is automatically added by the compiler
14:03:44 <roconnor> how do I get cabal to generate a reg file?
14:04:15 <Peaker> byorgey, I think I have that code somewhere
14:04:27 <Peaker> byorgey, conal described that instance in some place, too, iirc
14:04:33 <byorgey> Peaker: cool, what did you use it for?
14:04:45 <Saizan> roconnor: register --gen-pkg-config
14:04:54 <Peaker> byorgey, I don't remember :) not sure if it was real code
14:04:58 <byorgey> ok =)
14:09:11 <Peaker> byorgey, I described that instance in: http://www.reddit.com/r/haskell/comments/g7vcj/open_quark_on_github_haskell_like_lang_on_the_jvm/c1ln6sg
14:09:23 <conal> i often use that monoid instance in specialized forms, though i don't use a common newtype for it.
14:10:37 <byorgey> Peaker: ah, neat. I hadn't noticed that the instance for (a -> b) was a special case.
14:11:03 <Saizan> Maybe too
14:11:12 <mm_freak> Taslem: in haskell you can identify a programmer by only looking at the extensions =)
14:11:14 <conal> and i usually write it of the style of mempty = pure mempty; mappend = inAM (liftA2 mappend)
14:11:35 <mm_freak> if every file starts with {-# LANGUAGE ScopedTypeVariables #-}, then that's probably me ;)
14:12:51 <byorgey> conal: ah, nice
14:13:10 <mm_freak> and (ThisMonad m, ThatMonad m, OtherMonad m, MonadPeelIO m, YetAnotherMonad m) => SomeType -> (SomeOtherType -> Iteratee Blah m a) -> Iteratee Blah m a
14:13:15 <mm_freak> also indicates me =)
14:13:18 <conal> oops. make that mempty = AM (pure mempty)
14:13:21 <samantha_> hello
14:14:08 <mm_freak> or, add 'forall a m'
14:14:11 <samantha_> How can I paste code
14:14:12 <samantha_> ?
14:14:18 <mm_freak> because of the scoped type variables ;)
14:14:22 <mm_freak> samantha_: hpaste.org
14:14:23 <Taslem> Is there any existing way to parse Haskell from Java?
14:14:37 <crystal-cola> mempty = AM (pure mempty) <-- haskell programmes love recursion so much they make stuff that isn't even recursion look like it
14:14:39 <conal> byorgey: oh, and inAM2. and really neither wrapper since i don't usually make a newtype. sry for the noise.
14:14:40 <Taslem> That is, besides writing the parser myself?
14:14:42 <samantha_> thank you
14:14:44 <dafis> samantha_: if hpaste is still down, pastebin.com
14:15:00 <mm_freak> or codepad.org
14:15:12 <dafis> or gist.github
14:15:12 <mm_freak> Taslem: well, likely you'll write a parser
14:15:36 <samantha_> can someone help me with this please 
14:15:40 <samantha_> Link http://paste.org/pastebin/view/31855
14:15:45 <Taslem> Hm...  Think it would make sense to write a parser in Java and use it to use Java classes for libraries?
14:15:45 <byorgey> conal: well, you can get away with mempty = pure mempty if you derive an Applicative instance for the newtype =)
14:15:53 <Taslem> Make it a bit easier to use them on Windows.
14:16:09 <Taslem> And more multiplatform too, since Java is for them most part.
14:16:15 <mm_freak> samantha_: hpaste.org, not paste.org, because then you get syntax highlighting for haskell
14:16:17 <Taslem> Though also slower.... Have to weigh that out.
14:16:35 <byorgey> conal: you just turn on OverlappingInstances ?
14:16:45 <samantha_> mm_freak: is not Haskel  is pure algorithm Haskell is like that too rite
14:17:15 <conal> byorgey: no. i don't give a general declaration for applicative-of-monoid. since there are two natural choices. i think there's a comment to that effect in TypeCompose
14:17:23 <mm_freak> samantha_: some people might want to help you with other languages, but in general you will get better help in the corresponding language channel
14:17:37 <conal> byorgey: tho i might be misinterpreting your question.
14:17:42 <samantha_> oh ok thank you
14:18:05 <byorgey> conal: oh, right, I get it.
14:20:14 <ian_mi> how does fix work without Eq?
14:20:27 <byorgey> conal: do you know of a nice way to prove the monoid laws for that instance?  I proved them, but it got rather ugly (involving things like ((. mappend) . (.) . mappend)  )
14:20:36 <dafis> samantha_: you could of course run them and have a counter to find out the complexities
14:20:37 <byorgey> ian_mi: why would fix need Eq?
14:20:41 <Saizan> @google you could have invented fix too
14:20:42 <lambdabot> http://www.vex.net/~trebla/haskell/fix.xhtml
14:20:58 <conal> byorgey: hm. i haven't thought about it. nice question, though.
14:21:06 <conal> s/, though//
14:21:18 <samantha_> dafis: can u tell what type are they?
14:21:41 <conal> byorgey: so fix can know when it reaches a fixed point.
14:21:59 <ian_mi> yes
14:22:13 <dafis> samantha_: looks like homework, so you'll learn more if you find it out yourself
14:22:19 <byorgey> aha, I see =)
14:22:32 <samantha_> dafis: no is not 
14:22:55 <samantha_> dafis: I am preparing myself for the Major Achievement Field test 
14:22:56 <conal> ian_mi: fix isn't that kind of fixed point. it finds the *least* fixed point, where "least" is w.r.t. information ordering, ie has the least information.
14:23:14 <samantha_> dafis: I will not be able to run them while taking the test 
14:23:43 <ian_mi> conal: information ordering?
14:23:47 <byorgey> ian_mi: fix f = f (f (f (f (f ...  and so on to infinity (intuitively).
14:23:53 <byorgey> it does not check when to stop.
14:23:56 <conal> ian_mi: for instance fix f == _|_, for all strict f.
14:24:11 <byorgey> but because of laziness it may terminate if f decides not to use its argument at some point.
14:24:18 <samantha_> dafis: Can you please explain me
14:24:37 <kuznero> Hi All!
14:24:48 <conal> ian_mi: yeah. information ordering is the heart of the meaning of functional programs. for instance, _|_ means "no information". written "undefined" in haskell.
14:25:18 <conal> ian_mi: while (_|_,4) is the pair where we know nothing about the first element and we know that the second element is exactly 4.
14:25:26 <Saizan> ian_mi: a fixed point is a value x such that x = f x, right? that's how fix is defined: fix f = f (fix f)
14:25:42 <dafis> samantha_:  in A, i runs from j to n, so the inner loop runs (n-j+1) times, j goes n, n/2, n/4, ... ,1 so it's sum [(n-n/(2^k)+1) | k <- [0 .. ?]]
14:25:48 <ian_mi> Saizan: ah
14:26:13 <conal> ian_mi: dana scott came up with this info ordering idea to makes sense of (give denotation for) the lambda calculus.
14:26:31 <Saizan> it's actually defined like fix f = let x = f x in x, because that optimizes better.
14:26:32 <dafis> samantha_: the inner things are all Theta(n) [except for k = 0], so all you have to do is find out what ? is
14:27:31 <dafis> samantha_: the same principle for B, find the length of the inner loop and sum over the iterations of the outer loop
14:28:30 <samantha_> dafis: so the answer is this Agorithm A: Ɵ(n logn) Algorithm B: Ɵ (n logn) 
14:28:39 <dafis> yup
14:29:18 <ian_mi> so the existance of a fixed point is not enough for fix to work
14:29:36 <Saizan> fix finds the "least defined" fixed point
14:29:46 <samantha_> dafis: thank you so much
14:29:52 <dafis> which most of the time is _|_
14:30:07 <ian_mi> oh
14:30:16 <dafis> (the least defined fixed point)
14:30:24 <Saizan> ian_mi: http://www.vex.net/~trebla/haskell/fix.xhtml <- fix is about implementing recursion
14:30:24 <ian_mi> when is _|_ not a fixed point?
14:30:30 <dafis> > fix (1:)
14:30:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:30:43 <conal> ian_mi: fix always works. it's not a fixed point when a function is not strict
14:30:53 <conal> ian_mi: where strict means that f _|_ == _|_
14:31:04 <ian_mi> I see
14:31:23 <conal> ian_mi: so non-strictness is key for recursion (i.e. fix) to be useful.
14:31:54 <conal> ian_mi: that's why languages usually have at least one non-strict building block, typically if-then-else
14:33:06 <tener_> > :t fix id
14:33:07 <lambdabot>   <no location info>: parse error on input `:'
14:33:22 <samantha_> dafis: can i check something with you
14:33:26 <tener_> how to ask lambdabot for type annotation?
14:33:33 <dafis> samantha_: maybe
14:33:33 <Cale> :t fix id
14:33:34 <lambdabot> forall a. a
14:33:38 <samantha_> ok
14:33:44 <samantha_> dafis: I have the answer 
14:34:00 <samantha_> dafis: But i want to make sure
14:34:05 <dafis> samantha_: and what was the question?
14:34:15 <samantha_> ok
14:35:24 <samantha_> dafis: http://paste.org/pastebin/view/31857
14:35:32 <samantha_> dafis: I answer C
14:35:42 <byorgey> ian_mi: in dafis's example, _|_ is not a fixed point of (1:), since  (1:) _|_ = 1 : _|_
14:35:47 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
14:35:49 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
14:35:50 <lambdabot>   3628800
14:36:19 <kuznero> More general question for beginner: does it make sense to create configuration state monad to run application within so that it will be always easy to get (and put) configuration? Is it a good reason for creating separate monad for this purpose?
14:36:26 <kuznero> from beginner*
14:36:31 <tener_> what is TSO and THUNK_1_0 on heap profile obtained with +RTS -hT?
14:37:13 <Cale> kuznero: that's a bit of a style question. Some people would do it. I often prefer just making a datatype for the configuration and using explicit parameter passing, at least initially.
14:37:15 <dafis> samantha_: I agree
14:37:22 <samantha_> dafis: so I am ok
14:37:29 <Saizan> TSO is a Thread Stack Object iirc, and THUNK_1_0 is some unevaluated closure
14:37:46 <samantha_> dafis: so I am ok?
14:38:00 <tener_> ok, so _1_0 doens't mean anything then
14:38:17 <dafis> samantha_: wait, I'm not sure, might be A, have to think a bit
14:38:24 <samantha_> dafis: ok
14:38:27 <kuznero> Cale: but if configuration becomes rather complex is it fine to go for creating monad, otherwise it's gonna be rather clamsy code, isn't it?
14:38:49 <Saizan> tener_: i think those refer to the number of things the thunk closes over
14:39:03 <Saizan> tener_: one for the boxed the other unboxed, but i'm not sure
14:40:25 <Saizan> kuznero: what matters is how much you've to thread it around, not how complex the configuration type is
14:41:02 <Cale> kuznero: Well, if you end up having a lot of code where you're updating the configuration as you go, and you have to write things like  foo config = let (config', value) = bar config; (config'', value2) = quux config' in ...
14:41:07 <Cale> then use a state monad
14:41:25 <Cale> because it'll clean that up nicely
14:41:29 <dafis> samantha_: It's not A, so C indeed
14:41:56 <samantha_> thank you
14:41:56 <byorgey> dafis: why isn't it A?
14:42:15 <kuznero> Saizan: normally configuration will be set once or updated from only one thread, but will be read from many different threads. What issues do you think I might face in multi-threaded environment?
14:42:36 <dafis> byorgey: because we have additional operations in each step
14:42:36 <Cale> But if you're just passing a configuration value from the top level down without any alteration, I'm not sure that using a reader monad is always worth it. There are definitely times where it can work out nicely if you have some limited set of things you want to do, or you have some local changes to say, an interpreter's environment.
14:43:13 <Cale> kuznero: Well, if you're already using the IO monad, I'd recommend just using the facilities it already provides for state.
14:43:21 <roconnor> @hoogle local
14:43:21 <lambdabot> Control.Monad.Reader.Class local :: MonadReader r m => (r -> r) -> m a -> m a
14:43:22 <lambdabot> Trace.Hpc.Mix LocalBox :: [String] -> BoxLabel
14:43:22 <lambdabot> Data.Time.LocalTime localDay :: LocalTime -> Day
14:43:27 <ezyang> http://blog.ezyang.com/img/heap/title.png 
14:43:28 <Cale> (you will be using IO if you write concurrent code)
14:43:39 <byorgey> dafis: the call tree of power(n,x) is a binary tree with O(n) leaves, and we do a constant number of operations at each node
14:43:52 <byorgey> binary trees with O(n) leaves also have O(n) internal nodes
14:44:16 <kuznero> Cale: I'm not aware of any state mechanisms of IO monad in this sense? Can you recommend something?
14:44:41 <Cale> kuznero: You can use, say, an MVar for managing a piece of state from multiple threads.
14:44:47 <ezyang> kuznero: IORefs for single-threaded state management. 
14:44:48 <byorgey> ezyang: =D
14:45:03 <ezyang> byorgey: Should be good fun :-) 
14:45:14 <dafis> byorgey: drat, you're right, it's O(n + log n)
14:45:25 <Saizan> then you've the problem of passing that MVar/IORef around
14:45:35 <Cale> An MVar is like a box which may be empty or full. takeMVar will read the value and empty the MVar if it's full, and block if it's empty (waiting for it to fill)
14:45:50 <byorgey> dafis: yeah
14:45:54 <Cale> putMVar will write the value if empty, and block if it's full (waiting for it to empty)
14:46:07 <KSkrzet> I'm having hard time debugging this code...
14:46:08 <KSkrzet> http://hpaste.org/45749/simple_parsing_with_stack_over
14:46:21 <KSkrzet> I get stack overflows no matter how big the stack I set
14:46:44 <Cale> Whoa tail recursion city :)
14:47:41 <Cale> KSkrzet: First thing to understand is that the GHC stack doesn't mean the same thing it does in many strict language implementations.
14:47:45 <kuznero> Cale: to me it sounds better to do this within State monad and then just call get all over the places (except one in the start of the programe where I will read configuration and put it into state). But going low-level and managing MVars sounds a bit more complicated. Can you tell if there will be any problems with myState monad and just reading scenario from different threads?
14:48:09 <Cale> kuznero: The State monad doesn't interact at all with threads
14:48:26 <Cale> (it's really just a trick for constructing functions s -> (s,a)
14:48:27 <Cale> )
14:49:06 <Cale> KSkrzet: the stack consists of pattern matches which are waiting for their scrutinee to be evaluated enough that they can pattern match
14:49:24 <kuznero> Cale: I see. Ok, then there should be something like MState that could handle State from different threads?
14:49:56 <byorgey> someone just posted something about this recently...
14:49:59 <Cale> KSkrzet: Usually a stack overflow means that a very large expression was accumulated consisting of strict functions
14:50:47 <byorgey> kuznero: see http://blog.n-sch.de/2011/04/05/mstate-a-concurrent-state-monad/
14:51:26 <Cale> KSkrzet: I would be suspicious of your accumulating variables in the tail-recursive functions you've written... it's too bad that you haven't used foldl because then we could just replace that with foldl', but instead, let's add {-# LANGUAGE BangPatterns #-} to the top of the file and try sticking ! before some of the 'acc' parameters, which aren't being pattern matched as the recursion happens.
14:51:50 <Cale> kuznero: Well, there is, it's called IO :P
14:51:59 <Cale> kuznero: and MVars :)
14:52:07 <Cale> (or even IORefs)
14:52:28 <kuznero> Cale: I meant something wrapping this into something higher-level :)
14:52:30 <byorgey> Cale, there's that library I just linked to which aims to abstract away from the low-level details of MVars and such
14:52:40 <KSkrzet> Cale: I'll try that
14:52:48 <TomMD> TVars!  (don't know what the conversation is, but I had to throw that in)
14:52:57 <kuznero> :)
14:53:00 <Cale> Yeah, STM is pretty nice too
14:53:03 <KSkrzet> Cale: though it's unclear to my why simply creating a list would cause stack overflow...
14:53:20 <Cale> KSkrzet: yeah, it's probably not that one... let's see
14:53:33 <KSkrzet> Cale: I suspect graph code
14:53:33 <Cale> More likely the m0
14:53:48 <Cale> (in memoptimize)
14:53:49 <KSkrzet> Cale: specifically mkMapGraph
14:53:58 <KSkrzet> Cale: but I don't know how to verify this claim
14:54:16 <Cale> oh, wait, but you do have a case there
14:54:19 <Cale> hmmmm
14:54:35 <kuznero> byorgey: thanks for the link. Did you have change to use this library already? It's marked as unstable...
14:55:14 <Cale> Let me download this and try it :)
14:55:18 <byorgey> kuznero: ah, don't pay attention to the "stability" field, it is basically meaningless =)
14:55:33 <byorgey> kuznero: everyone always puts "unstable" and then forgets to change it to "stable" later ;)
14:55:42 <kuznero> byorgey: ok, will try it :)
14:55:57 <Cale> KSkrzet: Where can I get your data file?
14:56:24 <KSkrzet> wget "http://www.ii.uni.wroc.pl/~prych/text_mining/wikilinki.txt.gz"
14:56:59 <Cale> wow, that's pretty large :)
14:57:18 <KSkrzet> a bit :-)
14:57:19 <Cale> Downloading at 2MB/s though, so I'll be able to test :)
14:59:14 <KSkrzet> Cale: be sure to have few Gb or RAM though... I'm running this on 64bit with 8 gb
15:00:07 <KSkrzet> btw here is stack trace: http://dl.dropbox.com/u/1479187/textmining-zajecia07_08-zad1.pdf
15:00:43 <Cale> Where is Data.HashMap.Strict from?
15:01:18 <luite> unordered-containers
15:01:23 <Cale> ah, 
15:01:23 <Cale> k
15:01:26 <luite> unless there are more packages with that module :)
15:03:17 <Cale> okay, I clearly don't have enough memory for this
15:03:26 <Cale> KSkrzet: How far does it get before dying?
15:04:16 <Cale> aha, made it :)
15:04:21 <Cale> okay
15:04:25 <KSkrzet> Cale: :-)
15:04:40 <KSkrzet> Cale: the parsing finishes I think
15:05:33 <Cale> 1150000
15:05:39 <Cale> is where it died for me
15:06:17 <KSkrzet> it goes to 115000 and then starts graph contruction, because it sits there for a while
15:06:22 <KSkrzet> and then it dies
15:07:10 <Cale> Well, it's not quite dead yet on my modified version...
15:07:23 <Endiannes> lambdabot, > ""
15:07:26 <Cale> oh, well, it took longer to die :)
15:07:31 <Endiannes> Bah
15:07:33 <KSkrzet> :D
15:07:47 <Endiannes> > v
15:07:49 <lambdabot>   v
15:07:54 <Endiannes> Sorry about that
15:07:58 * Endiannes leaves
15:10:49 <KSkrzet> hmm... can it be that concat . map /= concatMap in terms of stack overflows etc?
15:11:41 <Cale> um...
15:11:53 <Cale> well, if you're compiling with -O2, I'm not sure there's a difference
15:12:05 <Cale> But otherwise, concatMap is probably more efficient
15:12:20 <KSkrzet> Cale: nvm, it has died anyway
15:13:21 <lispy> Cale: has ipwn released anything for android yet?
15:14:09 <Cale> To the best of my knowledge, iPwn hasn't released anything at all yet.
15:15:02 <lispy> ah
15:15:31 <azaq23> just a guess, but maybe concatMap the expression of concatMap as (\f -> join . fmap f)
15:15:36 <azaq23> is of relevance
15:15:39 <lispy> Cale: BTW, we have a budding haskell group for game dev.  For example, we have #haskell-game now
15:15:54 <Cale> cool
15:16:14 <roconnor> Cale is iPwn interested in more Canadian haskell consultants?
15:16:16 <roconnor> :D
15:16:28 <Cale> roconnor: Ask RyanT5000
15:16:39 <Cale> (when he's on)
15:16:50 <shachaf> (Which he is.)
15:17:33 <phrackSipsin> do you mostly use frp for game dev?
15:17:41 <roconnor> hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
15:17:46 <roconnor> ^^ what does this error mean?
15:18:01 <Cale> phrackSipsin: Well, we have our own FRP library for our game.
15:18:06 <dmwit> roconnor: It tried to read something, but decoding failed.
15:18:14 <TeXitoi> roconnor: invalid UTF8?
15:18:14 <Cale> roconnor: Means invalid UTF-8
15:18:21 <dmwit> roconnor: Maybe you meant to set the handle to binary mode?
15:18:30 <roconnor> I have iso-latin-1 files
15:18:36 <roconnor> how do I set the mode to read that?
15:18:47 <dmwit> ?hoogle binary
15:18:47 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
15:18:47 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
15:18:47 <lambdabot> System.IO openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
15:18:55 <phrackSipsin> ah nice is it available to browse?
15:18:57 <dmwit> ?hoogle encoding
15:18:57 <lambdabot> Network.CGI newtype ContentEncoding
15:18:57 <lambdabot> Network.CGI ContentEncoding :: String -> ContentEncoding
15:18:57 <lambdabot> Network.HTTP.Headers HdrAcceptEncoding :: HeaderName
15:19:15 <dmwit> roconnor: Hm. I'm not sure, but I think there's an hSetEncoding somewhere in the newest libraries.
15:19:16 <KSkrzet> see GHC.IO.Encoding.Latin1
15:19:49 <KSkrzet> roconnor: and GHC.IO.Encoding in general
15:19:52 <roconnor> dmwit: I'm using readfile
15:20:01 <Cale> hSetEncoding :: Handle -> TextEncoding -> IO ()
15:20:05 <lispy> Cale: well, I look forward to bloodknight when it's out :)
15:20:06 <Cale> latin1 :: TextEncoding
15:20:13 <dmwit> roconnor: You'll have to stop doing that, then.
15:20:18 <Cale> (In System.IO)
15:20:23 <dmwit> roconnor: readFile is great when it works, but anything complicated you have to do yourself.
15:20:24 * roconnor pulls out his hair
15:20:38 <roconnor> @src readFile
15:20:38 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
15:20:45 <Cale> you can use withFile
15:21:23 <Cale> withFile "foo.txt" ReadMode (\h -> hSetEncoding h latin1 >> hGetContents h)
15:21:40 <Cale> something like that
15:22:15 <roconnor> hoolge openFile
15:22:18 <roconnor> @hoolge openFile
15:22:19 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
15:22:22 <Cale> file:///usr/local/share/doc/ghc/html/libraries/base-4.3.1.0/System-IO.html
15:22:24 <Cale> oops
15:22:26 <Cale> lol
15:22:33 <Cale> too used to using the online versions of things
15:22:45 <Cale> (well, that link may still work for you ;)
15:22:46 <KSkrzet> Cale: works for me
15:22:59 <roconnor> @hoogle hSetEncoding
15:22:59 <lambdabot> No results found
15:23:09 <roconnor> what is the module name?
15:23:12 <Cale> I think hoogle's database is old
15:23:14 <Cale> System.IO
15:23:17 <geheimdienst> omg i'm looking at the html file from cale's hard drive!
15:23:22 <Cale> It's part of the new IO system
15:23:35 <roconnor> oh thank god
15:23:38 <roconnor> it works
15:23:43 <Cale> :D
15:23:55 <Peaker> I think the bare file handling stuff ought to be ByteString rather than String based...
15:24:09 <Peaker> readFile getting decoding errors is bah
15:24:14 <lispy_> Peaker: there are bytestring things for some of that.
15:24:17 <Cale> Okay, let's figure out what KSkrzet's code is doing and rewrite it more idiomatically and see if that helps :)
15:24:27 * roconnor after 2 hours of work, his atom feed is updated
15:24:38 <lispy_> Prelude.readFile just plain sucks though.  I pretty much always use dons' strict package when I need readFile
15:25:04 <Peaker> lispy, It's so annoying when you want to interactively toy with something.. I still open up a Python REPL for this.. :(
15:25:05 <lispy_> Granted, I should probably use enumeratee a bit more frequently
15:25:35 <Cale> There's Data.Text
15:25:55 <KSkrzet> Cale: the whole thing is rather simple: read link graph and print it out reversed, so that if we have article A that links to B, in the output we see B pointing to A
15:26:03 <Cale> okay
15:26:30 <Cale>  w' = B.copy w  -- what is the purpose of this?
15:26:39 <KSkrzet> Cale: ah, this one :-)
15:26:47 <KSkrzet> Cale: see, the file is big
15:27:06 <lispy_> link to code please?
15:27:11 * lispy_ wants to see too
15:27:11 <KSkrzet> Cale: the "memoptimize" stuff makes sure each article title is remembered only once
15:27:26 <Cale> http://hpaste.org/45749/simple_parsing_with_stack_over
15:27:29 <lispy_> memo-ptimiz or mem-optimize?
15:27:36 <Cale> lol
15:28:27 <lispy_> KSkrzet: what is your native language?
15:28:31 <Cale> Polish
15:28:35 <Cale> ?
15:28:35 <KSkrzet> yep
15:28:41 <Cale> KSkrzet: Wouldn't just sticking them all into a HashMap and then getting the elements of that HashMap again work?
15:28:52 <lispy_> ah, ha lazy io
15:28:59 <Cale> reverse is suspicious :)
15:29:04 <lispy_> okay, so my guess of Welsh would have been way off :)
15:29:24 <KSkrzet> KSkrzet: sure, but I want the order to be the same
15:29:37 <Cale> ah, okay
15:29:45 <KSkrzet> lispy_: well, my English sure have it's oddities :-)
15:30:07 <lispy_> Atto.many could be potentially problematic, IIRC
15:30:13 <Cale> I don't think ę occurs in anything but Polish.
15:30:27 <KSkrzet> Cale: you might be right
15:31:05 <lispy_> My only exposure to Polish culture (this is a sad confession) is the food cart near my office (which is very tasty)
15:31:10 <KSkrzet> (btw. I love that Haskell doesn't mind native characters in identifiers)
15:31:49 <Cale> Yeah, it's very sensible that way :)
15:32:06 <lispy_> KSkrzet: just a style note, when I have a line like this: "memoptimize m xs = let go acc m0 (w:ws) ="  I tend to put a \n right after the equal sign and then indent a tiny bit like 2 spaces.
15:32:10 <KSkrzet> lispy_: the parsing seems to be right, i.e. it doesn't loop or anything, so I think many is ok
15:32:16 * ddarius says nothing about the practical history.
15:32:36 <Cale> I'm still not sure why copying is required
15:32:42 <Cale> Let's try without it
15:32:57 <lispy_> KSkrzet: I do that just so my code is less horizontal.
15:33:08 <KSkrzet> Cale: I'm not sure it is, but I don't know how attoparsec is building the bytestrings
15:33:29 <Cale> Seems to cut memory usage a little to drop it
15:33:43 <Cale> but it doesn't fix the problem
15:33:45 <KSkrzet> Cale: odd
15:34:01 <Cale> Well, these things are pure :)
15:34:24 <lispy_> Cale: what about making the acc strict in wczytajGraf 
15:34:31 <Cale> I've done all that
15:34:41 <Cale> (made all the accumulating parameters strict)
15:34:47 <KSkrzet> btw, did you have a look pdf graph I linked?
15:35:08 <lispy_> KSkrzet: I did not.  I didn't see that link
15:35:08 <Cale> But I'd prefer somehow avoiding explicit tail recursion...
15:35:11 <KSkrzet> the heuristic is that 
15:35:16 <KSkrzet> uhm
15:35:20 <KSkrzet> http://dl.dropbox.com/u/1479187/textmining-zajecia07_08-zad1.pdf
15:35:20 <KSkrzet> here
15:35:39 <lispy_> KSkrzet: thanks
15:36:04 <Cale> Pretty much what you'd expect :)
15:36:08 <Cale> lots of list cells
15:36:14 <Cale> lots of packed strings
15:36:51 <lispy_> Hrm
15:36:58 <lispy_> But, we should be able to smooth it out
15:36:59 <Cale> Is HashMap a whole lot better than Map?
15:37:03 <KSkrzet> it looks like after 60s the parsing is done, then it does something, and then it starts building graph
15:37:10 <KSkrzet> Cale: a whole lot better
15:37:19 <Cale> Interesting
15:37:29 <lispy_> Cale: I guess memoptimize could matter if the Attoparsec uses strict bs when KSkrzet is reading a lazy one?
15:37:36 <KSkrzet> Cale: the keys are bytestrings, so comparison is expensive
15:37:59 <KSkrzet> lispy_: no, the case is the same strings are parsed multiple times
15:38:31 <KSkrzet> A
15:38:31 <KSkrzet>    B
15:38:31 <KSkrzet>    C
15:38:40 <KSkrzet> B and C will be remembered just once
15:38:59 <Cale> You were going out of your way to make multiple copies of them...
15:39:05 <Cale> I'm not sure why :)
15:39:16 <KSkrzet> Cale: no, I only make copy if there is no previous entry
15:39:27 <KSkrzet> Cale: so I only make one when I insert the first copy
15:39:30 <Cale> Yeah, but why not use the one which is already in memory?
15:39:44 <Cale> (the one from the list)
15:39:49 <KSkrzet> Cale: to break any data dependencies it might have
15:39:52 <Cale> hmm
15:40:14 <KSkrzet> as I said, i'm not sure how does attoparsec create these bytestrings
15:41:06 <lispy_> KSkrzet: IIRC it gives you spices of the ones it has
15:41:15 <lispy_> KSkrzet: eg., the typical way to use bytestring
15:42:21 <mauke> herbls and spices
15:43:05 <lispy_> splice :)
15:43:05 <Cale> oh, huh...
15:43:07 * lispy_ can't type
15:43:11 <Cale> it might be mkMapGraph's fault
15:43:12 <KSkrzet> lispy_: spices?
15:43:19 <lispy_> KSkrzet: I meant splice.
15:43:19 <Cale> mkMapGraph :: (Ord a, DynGraph g) => [a] -> [(a, a, b)] -> (g a b, NodeMap a)
15:43:19 <Cale> mkMapGraph ns es =
15:43:19 <Cale>     let (ns', m') = mkNodes new ns
15:43:19 <Cale> 	Just es' = mkEdges m' es
15:43:19 <Cale>     in (mkGraph ns' es', m')
15:43:28 <Cale> lol, tab character
15:43:38 <Cale> Someone needs to be sacked.
15:43:49 <KSkrzet> Cale: tab is bat for performance I guess ;-)
15:43:51 <KSkrzet> bad*
15:44:12 <Cale> Just bad for copy/paste and code editing sanity :)
15:44:15 <KSkrzet> actually there are some preassumptions missing in documentation
15:44:33 <Cale> so hmm
15:44:34 <KSkrzet> but that's fixed in my code already
15:44:43 <Cale> let's see how these mkGraph etc. work
15:45:18 <Cale> I wonder if anyone's actually used FGL on such large graphs before :P
15:45:36 <KSkrzet> Cale: hah, I started wondering that too actually
15:46:11 <Cale>     mkGraph vs es   = (insEdges' . insNodes vs) empty
15:46:11 <Cale>         where
15:46:11 <Cale>           insEdges' g = foldl' (flip insEdge) g es
15:46:11 <KSkrzet> Cale: FGL is really nice when it comes to API, but I'm wondering if it's production ready
15:46:14 <Cale> that looks okay
15:46:30 <polypus> best way to get every other list element, is there a standard function?
15:46:37 <lispy_> ivanm: did you hear that?  Sounds like fighting words ;)
15:47:02 <KSkrzet> Cale: my bet would be NodeMap code
15:47:10 <lispy_> > zipWith const [1..5] (tail [1..5])
15:47:11 <lambdabot>   [1,2,3,4]
15:47:19 <ivanm> lispy_: eh, I've got to go have breakfast
15:47:40 <lispy_> ivanm: someone was questioning the efficacy of FGL for production work
15:47:46 <ivanm> I noticed
15:47:59 <ivanm> I've never really found anyone defining what "production ready" actually meant
15:48:05 <ivanm> as such, there's nothing that can really be argued
15:48:07 <Cale> It doesn't mean anything
15:48:08 <lispy_> ivanm: no bugs, high performance
15:48:19 <ivanm> nfi about the performance
15:48:21 <KSkrzet> ivanm: + good documentation
15:48:23 <lispy_> or at lesat, no bugs they care about :)
15:48:33 <Cale> There are of course production environments requiring graphs with no more than a couple hundred vertices.
15:48:39 <ivanm> there are no bugs per se, but the API can be improved IMHO
15:48:52 <ivanm> KSkrzet: documentation for FGL is quite good
15:48:59 <polypus> as in: foo [1, 4, 6, 2, 3] = [1, 6, 3]
15:49:09 <Cale> (so even a fairly poor graph library might be production ready by some standards)
15:49:10 <KSkrzet> ivanm: it is, but it can always be impoved :-)
15:49:18 <ivanm> KSkrzet: have a look at edwardk's graphs package then
15:49:30 <Cale> Let's try just using a HashMap for our graph.
15:49:43 <ivanm> when I have time, I plan on trying to expand upon it for pure graphs as well and slowly port FGL over to it
15:49:59 <ivanm> since it has the advantage of being released as opposed to my efforts which I keep restarting :p
15:50:15 * ivanm -> breakfast
15:50:47 <KSkrzet> ivanm: I didn't notice that package before, thanks for the tip
15:50:59 <KSkrzet> Cale: what do you mean by switching to HashMap?
15:51:14 <ivanm> KSkrzet: well, there's not much there though, so YMMV
15:51:23 <Cale> I suppose you want to compute sccs, so it'd be kinda nice just to be able to use a graph library
15:51:25 <ivanm> I think Cale means tibbe's new unordered-containers library
15:51:51 <KSkrzet> Cale: actaully I just wanted nice API, scc is there for a test ;-)
15:52:46 <KSkrzet> ivsanm: I'm using that library in my code, I just don't know how to make straightforward switch with graph code
15:54:15 <Tyr42> hey, in windows, tab-completion works in GHCi, but not WinGHCi
15:54:27 <Cale> KSkrzet: I normally just use an adjacency map... like  Map Vertex (Set Vertex)  to represent graphs
15:54:35 <Tyr42> would this be hard to fix?
15:54:45 <KSkrzet> Cale: well yeah, actually I can do fine without any graph library at all if I rewrite my code
15:54:47 <Cale> I suppose that doesn't have the most efficient transposition, but it might be worth a shot.
15:54:48 <Tyr42> i.e. could I try and fix it?
15:55:17 <polypus> best way to get every other list element, is there a standard function?
15:55:27 <dsimon> Tyr42, this is open source; you don't have to ask permission :-)
15:55:30 <MHD0> is there no inbuild way of loading textures in HOpenGL/GLUT?
15:55:55 <Tyr42> dsimon I haven't really contributed anything before
15:55:56 <Cale> Tyr42: I don't know anything about WinGHCi, but if you're familiar with the windows API, it might be easy enough...
15:55:57 <lispy_> MHD0: you mean load them from a .bmp?
15:56:09 <dmwit> polypus: No, no standard function. In fact, it's a bit of a smell that you want to do that; is list really the right data structure for what you want to do?
15:56:10 <MHD0> lispy_: Yeah
15:56:20 <lispy_> MHD0: Hmm....I have some code that I wrote that will load them.
15:56:38 <dmwit> polypus: (However, take a look at Data.List.Split from the "split" package. It has functions that will make what you want to do easy.)
15:56:47 <dmwit> > map head . chunk 2 $ "abcdefg"
15:56:48 <lambdabot>   Not in scope: `chunk'
15:57:00 <lispy_> MHD0: But, No, I don't think GLUT or the OpenGL bindings have it.  There are some package on hackage to do it.  Like, sdl and some bitmap packages
15:57:02 <Tyr42> dsimon, cale:  I'll go take a look
15:57:18 <polypus> dmwit: ty, i'll have a look
15:57:20 <lispy_> MHD0: https://github.com/dagit/nehe-tuts/blob/master/Util.hs  That's my code
15:57:24 <Cale> > map head . takeWhile (not . null) . iterate (drop 2) $ [1..10]
15:57:25 <lambdabot>   [1,3,5,7,9]
15:57:31 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ [1..10]
15:57:33 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10]]
15:57:43 <dmwit> polypus: If you tell us a bit more about what you want to do, we might be able to do a better job of helping you.
15:57:56 <MHD0> lispy_: Okay
15:58:11 <Cale> > [x | (k,x) <- zip [0..] "hello, world!", even k]
15:58:12 <lambdabot>   "hlo ol!"
15:58:15 <Cale> > [x | (k,x) <- zip [0..] "hello, world!", odd k]
15:58:15 <lispy_> MHD0: but you're probably better off with a more mature library like this: http://hackage.haskell.org/package/bitmaps
15:58:16 <lambdabot>   "el,wrd"
15:58:39 <lispy_> MHD0: and this one seems to even target the opengl bindings: http://hackage.haskell.org/package/bitmap-opengl
15:58:44 <MHD0> lispy_: Thanks
15:58:55 <KSkrzet> ivanm: is this even remotely possible that there is a leak in the way NodeMap uses FiniteMap?
15:59:07 <dmwit> > groupBy ((==) `on` (\x -> fst x `div` 2)) . zip [0..] $ "hello, world!"
15:59:08 <lambdabot>   [[(0,'h'),(1,'e')],[(2,'l'),(3,'l')],[(4,'o'),(5,',')],[(6,' '),(7,'w')],[(...
15:59:25 <dmwit> > map (snd . head) . groupBy ((==) `on` (\x -> fst x `div` 2)) . zip [0..] $ "hello, world!"
15:59:26 <lambdabot>   "hlo ol!"
15:59:34 <copumpkin> FiniteMap?
15:59:42 <copumpkin> :O
15:59:42 <KSkrzet> http://hackage.haskell.org/packages/archive/fgl/5.4.2.3/doc/html/Data-Graph-Inductive-Internal-FiniteMap.html
15:59:45 <copumpkin> isn't that long-gone?
15:59:46 <copumpkin> ah
15:59:54 <copumpkin> oh man
15:59:57 <KSkrzet> it's not
15:59:57 <copumpkin> a constraint on a data type
15:59:58 <KSkrzet> :-)
16:00:01 <copumpkin> that's just all kinds of wrong
16:00:16 <ivanm> KSkrzet: quite possibly; I don't use the NodeMap stuff in FGL
16:00:28 <ivanm> I ended up just using it as a data structure and coding my own algorithms for the most part
16:00:38 <lispy_> copumpkin: Yeah, I heard FiniteMap was no longer needed.
16:00:48 <ivanm> copumpkin: yeah, I like the idea behind FGL; the implementation sucks a lot though
16:01:07 <Cale> The use of the internal old finitemap type is a bit suspicious... what's wrong with using the one from containers at least?
16:01:12 <lispy_> ivanm: oh you students with your "uni classes to pass".  Work on open source instead :P
16:01:40 <lispy_> ivanm: you don't actually need a degree do you?
16:02:07 <ivanm> lispy_: I'm a PhD student actually
16:02:11 <polypus> dmwit: i've got a list (history) of player moves (coordinates), and to keep things simple i have a datatype (Play Player History). A play is tells me the last player to make a move, and the way i can get all the moves by that player i just take every other one. i know there are plenty of other ways of doing it, but doing it this way simplified my code in other places
16:02:14 <ivanm> and lately I've been doing more theory than code
16:02:22 <ivanm> Cale: *shrug*
16:02:33 <ivanm> that's pretty much why tomberek and I were going to do a rewrite
16:02:38 * ivanm goes back to cooking breakfast
16:03:06 <KSkrzet> ivanm: breakfast at 1 AM is weird. oh wait...
16:03:20 <dmwit> polypus: If the data type records which player made the move, you might get away with just a plain old filter.
16:03:26 <lispy_> ivanm: ah that makes sense.  What is your area of expertise?
16:03:48 <lispy_> ?localtime ivanm
16:03:51 <lambdabot> Local time for ivanm is Sat Apr 16 23:14:14
16:04:01 <polypus> dmwit: no, only the Play types specifies the player, the history is just [(X,Y)]
16:04:11 <KSkrzet> ?localtime KSkrzet
16:04:12 <lambdabot> Local time for KSkrzet is Sun Apr 17 01:19:21
16:04:19 <KSkrzet> works for me...
16:05:02 <dmwit> polypus: Okay. This sounds pretty reasonable, actually. =)
16:05:15 <polypus> dmwit: ty for the tips
16:05:38 <ivanm> lispy_: that time lies!
16:05:43 <ivanm> (it's set to UTC atm for some reason)
16:05:57 <ivanm> I'm working on graph generation algorithms; atm I'm trying to prove some stuff to do with fullerenes
16:06:05 <ivanm> where "prove" == "bash my head against a wall" :s
16:06:09 <lispy_> ivanm: yeah, you should be apr 17 in your time zone right? so I figured it was wrong
16:06:15 <ivanm> yup
16:06:29 <lispy_> tell me what the future is like!
16:07:06 <lispy_> ivanm: do you do pen and paper/chalkboard proofs or are you using an automated proof checker of any sort?
16:09:51 <polypus> dmwit: btw, i'm doing this exercise for fun http://bit.ly/eRNzF2
16:10:18 <lispy_> polypus: cool
16:10:40 <lispy_> polypus: I saw that and I thought about doing it in H2010 (if possible), but I didn't actually bother :)
16:11:02 <KSkrzet> Cale: I think I will actually use your idea: HashMap already have unique node names so I just have to extract and enumerate them
16:12:32 <polypus> lispy_: yeah, i just wanted to see if i could code to all his constraints. i haven't looked at his java code yet, just to try from scratch. will probably post up as a gist or something for feedback when done.
16:13:04 <dmwit> Sounds like fun.
16:13:52 <polypus> dmwit: it is, and illuminating
16:13:52 <KSkrzet> polypus: when dealing with history zippers can be fun application, but I'm not sure if they are in your application
16:15:59 <polypus> KSkrzet: nah, probably won't get that complex with this one
16:16:48 <polypus> KSkrzet: on second thought, would be good exercise as well
16:20:07 <polypus> so what's the deal with monad fail. i've seen it discouraged a bunch, but then http://bit.ly/38ajo1 is emphatically encouraging its use?
16:21:12 <hpc> polypus: the notion of monadic failure is good, in a vacuum
16:21:23 <dmwit> That doesn't look like it's emphatically encouraging it to me.
16:21:29 <hpc> the discouragement is from it being placed in Monad itself, not MonadFail or similar
16:22:08 <polypus> dmwit: end of section 4, he says please "please consider using this error-reporting method."
16:23:08 <dmwit> If all your errors are strings.
16:23:14 <monochrom> > fail "do you see this error report?" :: [Int]
16:23:15 <lambdabot>   []
16:23:19 <monochrom> does not report error
16:23:26 <dmwit> But as has been pointed out to me several times over the last few days, String is a lousy representation of rich data.
16:24:00 <Philippa> yeah, the monadic fail is, well, made of fail
16:24:15 <Philippa> being polymorphic in your error handling is good, but fail is about the worst way to do it
16:25:39 <polypus> so guess it's really context specific which method to choose. which is harder to judge for a noob like me
16:25:39 <hpc> > fail "OMG!" :: Either String Int
16:25:41 <lambdabot>   Overlapping instances for GHC.Base.Monad
16:25:41 <lambdabot>                              (Data...
16:25:45 <hpc> humbug
16:26:22 <Philippa> polypus: Either and Error(T) are good, related picks
16:26:32 <hpc> fail is worthwhile for the rare occasions when you have a monad where the only failure information you need to convey is a string
16:26:44 <hpc> a website might be a good example
16:27:07 <monochrom> I think I understand now. it's similar to "please use /dev/null to report errors" :)
16:27:17 <hpc> and asside from the poor implementation, the way it works in do-notation is kind of nice to use
16:27:22 <Philippa> not really. For example, it lands you with strings throughout
16:27:32 <Philippa> and the use in do-notation doesn't really use the string (properly) either
16:27:34 <KSkrzet> if you doing simple stuff in IO monad then fail is ok i think
16:27:50 <Philippa> basically, use fail if you wouldn't think /too/ hard about using error
16:28:08 <Philippa> if you intend to do 'real engineering', don't use fail
16:28:45 <KSkrzet> for some programs if something fails there is no recovery plan really and fail "oh my" is perfect
16:29:26 <Philippa> ksandstr: "if you wouldn't think /too/ hard about using error" :p
16:29:50 <Philippa> (a particularly good criterion given that error is the default implementation of fail)
16:30:16 <Philippa> most stuff at least accumulates a degree of reporting on failure as it grows though
16:31:07 <Philippa> (you don't want to have to handle i18n or l10n for your error messages with fail!)
16:32:06 <polypus> so if i were writing a not too comples API for public cunsumption, where i'm not handling any errors myself, would fail be a good choice?
16:32:11 <polypus> complex*
16:32:16 <applicative> > fail "YIKES!" :: Maybe Doc
16:32:17 <lambdabot>   Nothing
16:32:42 <KSkrzet> Philippa: I find that localised error messages are harder to understand than english ones
16:33:21 <Philippa> ...d'oh
16:33:36 <KSkrzet> Philippa: translators have funny ideas how to translate certain words and there is hardly consensu
16:33:38 <Philippa> KSkrzet: yeah, that happens sometimes. But that's not a good excuse for never doing it at all ever
16:33:51 <Philippa> (you can always set it back, right?)
16:33:53 <KSkrzet> consensus*
16:34:04 <KSkrzet> Philippa: not always unfortunately
16:34:32 <Philippa> that does suck :-( But still, seems like an argument for doing it right, not one for not doing it at all
16:34:39 <KSkrzet> Philippa: for example some websites
16:34:55 <lispy_> polypus: I imagine you'll need rank2 types
16:34:57 <Philippa> urgh, yeah, geolocation-determines-all on web sites etc etc
16:35:12 <KSkrzet> Philippa: agreed, sometimes it makes perfect sense, like for most users ;-) but not for programmers I think
16:36:05 <lispy_> polypus: I was thinking that with rank2 types it should be fairly easy to ensure that during the game only game state changing things can be called
16:36:29 <lispy_> polypus: analogous to ST monad
16:38:04 <polypus> lispy_: i don't grok those yet. i'm just using type classes with different types of game states, some of which instances of Movable, some of MovableBack, etc.
16:38:28 <lispy_> polypus: ah
16:38:39 <Philippa> KSkrzet: even when it's like that, attaching error messages to source locations can have consistency problems and so forth too. I've found myself doing 'clever' things that left me needing a proper error representation pretty fast
16:40:27 <polypus> but lispy_ would like to see what you come up with, if you give it a go
16:40:55 <KSkrzet> Philippa: If you need to handle errors in intelligent way, then no wonder they have to be represented somewhere in the code
16:42:51 <applicative> Is the purpose of "newtype F = F Int" supposed principally to be to get different instances for typeclasses?
16:43:21 <Philippa> KSkrzet: exactly. The error function is for when you'd happily start the error message "DERP!" and show it to your boss, fail likewise
16:43:37 <Saizan> applicative: or more precise types
16:44:02 <Philippa> yeah. F might be Farenheight, for example
16:44:14 <lispy_> polypus: if I do give it a go I would definitely blog about it
16:44:24 <dmwit> applicative: It's also a way to do smart constructors and stuff.
16:44:25 <lispy_> polypus: do you follow the haskell subreddit?
16:44:57 <applicative> I was thinking of this sentence of R. Harper "There are two fundamental problems with type classes.  The first is that they insist that a type can implement a type class in exactly one way."
16:45:25 <applicative> I would have thought it was second nature to get new instances by  newtyping.  Of course it's  a bit of a bore. 
16:45:56 <Philippa> yeah. It's a trade-off - personally I have a mixed opinion of it, taste varies
16:46:25 <applicative> There is also the point that the really interesting typeclasses are e.g. Functor Monad etc, and it's not like things have a thousand and one ways of instancing them
16:46:27 <KSkrzet> applicative: what is the second problem?
16:46:31 <Philippa> it's mostly taste rather than anything else, but Haskell still needs a better module system - even if it's just a layer of sugar on top of type classes, which is perfectly achievable
16:46:52 <Philippa> applicative: you'd be amazed how many functors, monoid etc are definable on some types
16:47:03 <Philippa> there are at least two monads on [], too
16:47:05 <applicative> Really.  Monoid, yes of course.
16:47:15 <hpc> i thought there was a proof that a type can have exactly zero or one functor instances?
16:47:22 <djahandarie> (This is where we use 'ala')
16:47:36 <applicative> I was already regretting what I said, thinking of that.  But note, there are even pre existing Sum and Product wrappers etc. 
16:47:48 <djahandarie> > ala Sum Data.Foldable.foldMap [1,2,3,4]
16:47:49 <lambdabot>   10
16:47:51 <applicative> 'ala' rules
16:47:52 <djahandarie> > ala Product Data.Foldable.foldMap [1,2,3,4]
16:47:53 <lambdabot>   24
16:48:05 <applicative> hah, it's in lambabot
16:48:07 <djahandarie> Easy newtype wrapping/unwrapping
16:48:16 <dmwit> That looks like magic.
16:48:18 <dmwit> :t ala
16:48:19 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
16:48:28 <Philippa> hpc: there can't be a general one, n-tuples support n completely trivial ones
16:48:30 <applicative> djahandarie: are you the one who wrote the hackage package?
16:48:34 <djahandarie> applicative, yeah
16:48:38 <hpc> Philippa: oh, duh
16:48:45 <hpc> Philippa: hmm, i wonder what i was thinking of then
16:48:54 <djahandarie> I actually have an update for it, I should push that out
16:49:14 <applicative> Nice. I was dissapointed it didn't use type families (though for sensible reasons)
16:49:30 <djahandarie> Yeah, I wanted type families but it was really making GHC <7 blow the hell up
16:49:36 <applicative> In only finally noticed it a week or two ago, but its been a while. 
16:49:53 <KSkrzet> what's the package name anyway?
16:49:57 <djahandarie> newtype
16:50:00 <djahandarie> @hackage newtype
16:50:00 <lambdabot> http://hackage.haskell.org/package/newtype
16:50:07 <KSkrzet> thanks
16:50:26 <djahandarie> (It could have been called isomorphism but that is scarrier ;))
16:50:35 <djahandarie> Oops, I was suppose to be working, brb
16:50:43 <applicative> KSkrzet: second objection to type classes I cant follow yet: The second is that they confound two separate issues: specifying how a type implements a type class and specifying when such a specification should be used during type inference. 
16:51:29 <KSkrzet> applicative: I dont get it either.
16:52:10 <applicative> KSkrzet: http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/  He seems generally pleasing, dons has been linking his posts.
16:53:29 <aristid> applicative: i find him painful, not pleasing :)
16:54:13 <applicative> aristid: Of course I want to object :)  
16:54:57 <applicative> aristid: the attack on "boolean blindness" made a cognitive impression on me, though maybe only because i should have noticed earlier
16:55:11 <RichardO> @pl f x = g (h x, h x)
16:55:11 <lambdabot> f = g . liftM2 (,) h h
16:55:50 <Saizan> applicative: i think he's referring to all the limitations imposed on what instances you can make just because the typechecker also has to automatically figure out when to use which for you
16:56:18 <ivanm> lispy_: pen and paper proofs
16:56:19 * ivanm heads off
16:56:30 <aristid> Saizan: don't newtypes eliminate that limitation?
16:58:04 <applicative> Saizan, say more, I'm not quite there yet/
16:59:59 <applicative> Saizan: how does a module system protect against this?  I need to study more ML
17:00:11 <Saizan> when you make an instance, you aren't just saying "given some prerequisites the type X is an instance of class C", you're also instructing the typechecker on how to solve constraints like "C .."
17:00:15 <RichardO> @pl f x = (g x, g x)
17:00:16 <lambdabot> f = liftM2 (,) g g
17:00:46 <parcs> :t join (***)
17:00:47 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
17:01:14 <Philippa> Saizan: yeah, typeclasses insist on there being at most one instance of a class for a given type
17:01:25 <Philippa> that's the root of what he's talking about
17:01:28 <ion> > join (&&&) (+1) 42
17:01:29 <lambdabot>   (43,43)
17:01:40 <Philippa> (the rest can be fugly on occasion, but it's not The Issue)
17:02:02 <applicative> philippa, but doesn't it seem kind of weak, this objection, we just make a copy.
17:02:15 <Saizan> applicative: ML functors simply don't have any "resolution" feature, the user specifies quite explicitly which "instance" is to be used
17:02:46 <aristid> :t ala
17:02:47 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
17:03:43 <Saizan> so the "when" is not determined in any way by declaring some module satisfies some signature
17:03:53 <applicative> whereas we just use the class related functions, like + or mappend or whatever, and it slowly dawns on the compiler what types are at issue
17:03:55 <KSkrzet> Saizan: when do you specify which instance to use? once per module or once per usage?
17:04:03 <aristid> Saizan: often there IS a sane default instance, or even only one logically possible instance. ML functors seem to throw away that possibility?
17:04:03 <applicative> to speak crudely. 
17:04:53 <applicative> aristid, right I was wondering if he was missing the extent to which the 'types' that instance our 'classes' are of kind * -> * 
17:05:35 <applicative> so there are constraints on the way they can instance, akin to free theorems I suppose.
17:05:57 <Saizan> KSkrzet: i think both are possibilities, it's a bit like importing modules in haskell, you can just bring their symbols in scope or instead use them qualified
17:06:42 <aristid> applicative: isn't Functor a good example of type (constructor) classes? IIRC there is always only one possible way for a type of kind * -> * to be a functor
17:07:01 <Philippa> applicative: it means we have to do tedious encoding that gets in the way of working in a modular fashion. It sure pisses me off when I'm looking through that lens rather than the regular haskell one
17:07:18 <applicative> aristid, that was the point. Of course it could be exaggerated 
17:07:46 <Philippa> aristid: I can think of three for the newtype around (a,a) :p
17:07:55 <Saizan> sometimes it seems ML functors and typeclasses are really about solving different problems.
17:07:55 <aristid> Philippa: you can?
17:07:57 <Philippa> ...wait, no, forget that
17:08:02 <Philippa> didn't propagate the constraints fully
17:08:09 <aristid> :)
17:08:09 <Philippa> (it's late, I'm tired and it's been a shitty week)
17:08:20 <applicative> Philippa, but do you think ML has it all over Haskell in this sort of area?  I only started learing it (ocaml) a few weeks ago, sub-dilletantishly
17:08:21 <Philippa> Saizan: yes, very much so
17:08:42 <Philippa> applicative: for modularity, yes. But you'd only end up wanting type classes in ML too
17:08:54 <Philippa> the real solution is a /good/ unified system
17:09:14 <Philippa> and that gets surprisingly tricky despite all the commonality
17:09:47 <Philippa> Saizan: being able to write "uninstantiated instances" and explicitly instantiate them for types they subsume would help/be nice
17:09:49 <applicative> Is this why the Haskell committee et al didn't cook up a 'module system'?  
17:09:58 <Philippa> no
17:10:13 <Philippa> that happened because they were an active research area at the time and they chose to punt, same as for records
17:10:35 <Philippa> those were the ML community's job, we got laziness and type classes
17:10:36 <applicative> I see
17:10:53 <Philippa> as it happened, type classes turn out to be intimately connected to both modules and records. C'est la vie.
17:11:05 <Saizan> Philippa: yeah, like the Applicative f , Monoid a => Monoid (f a) from byorgey above, which we instead duplicate all over
17:11:13 <Philippa> (it took a lot of research past that point to realise it!)
17:11:25 <applicative> type classes lead to all sorts of trouble, but i feel that they are in a way idiot simple and put you on to amazing abstractions in no type. 
17:11:33 <applicative> take Monad and Functor 
17:11:35 <applicative> please
17:11:40 <Philippa> Saizan: right, I just want to name that and then call it to generate an instance
17:12:40 <Philippa> we might not be able to break the instances rule for structures, but we really ought to do it for our functor analogues
17:12:47 <brbr> hi haskell
17:12:53 <applicative> hi brbr
17:13:00 <Saizan> Coq has typeclasses implemented in LTac as a specific proof strategy to look up definitions of record types, i guess it should be easy there
17:13:27 <brbr> silly question, but is there any group of haskellers that do code reviews?
17:13:37 <applicative> #haskell ?
17:14:01 <applicative> @where hpaste
17:14:02 <lambdabot> http://hpaste.org/
17:14:20 <Philippa> Saizan: I guess I should add "write something for TMR about the tensions in unifying modules and type classes" to my to-probably-never-do list
17:15:29 <applicative> I wonder where I can find skillful unfancy use of the module system?  It's not so easy finding exemplary ML/ocaml code, I find.  But i haven't made it far yet
17:15:35 <Saizan> Philippa: yep :)
17:16:02 <Saizan> and going in the other direction from above, i often wish i could get the functor out of a Foo a => Foo (F a) instance
17:16:10 <applicative> Phillipa, sounds like an excellent topic
17:16:13 <brbr> http://hpaste.org/45750/ecd
17:16:53 <applicative> brbr, not the first code review is from HLint, at the bottom of the page. 
17:17:20 <brbr> applicative: neat!
17:18:22 <Mathnerd314> I'm trying to run a server on windows and I keep getting 'Server error: DeleteFile "%TEMP%\\err4024": permission denied (The process cannot access the file because it is being used by another process.)'
17:18:31 <brbr> is there a more elegant way to write the "if then if then else else" ?
17:18:44 <Philippa> brbr: I don't know of an explicit group beyond here, but it's responsive. If you want something longer-running and you've got the energy, I imagine organising such a group'd attract a fair number of people
17:19:33 <gienah> Mathnerd314: you could use handle from sysinternal to find out which processes are using the file
17:20:46 <gienah> Mathnerd314: http://technet.microsoft.com/en-us/sysinternals/bb896655
17:24:18 <Mathnerd314> gienah: looks like it's just the Haskell code
17:24:56 <KSkrzet> Mathnerd314: is it possible you are using lazy IO?
17:25:20 <Mathnerd314> it's not my program; how would I tell?
17:25:39 <KSkrzet> Mathnerd314: ah
17:29:48 <Mathnerd314> how would I force it to use strict IO?
17:29:57 <monochrom> rewrite program
17:30:25 <monochrom> or at least, recompile program but sneak in replacement libs
17:30:25 <Mathnerd314> ... how would I rewrite it?
17:30:37 <monochrom> that's undecidable
17:30:40 <KSkrzet> what is this program anyway?
17:31:01 <Mathnerd314> http://hackage.haskell.org/package/gitit
17:31:28 <monochrom> alternatively, switch to linux, so you are allowed to delete files
17:31:36 <monochrom> solaris works too
17:32:24 <monochrom> essentially, you now know why many windows updates require reboots
17:32:36 <KSkrzet> Mathnerd314: it is possible it uses posix trick with deleting open files for the sake of something
17:32:48 <RichardO> Can anyone tell me how to write a function like this: getFst :: State (Int, Int) a -> State Int a
17:32:55 <Mathnerd314> monochrom: I am going to do that, but I need a week which I don't have
17:33:27 <Philippa> run it in a VM?
17:33:57 <parcs> RichardO: fmap fst get
17:34:26 <Mathnerd314> Philippa: good idea.
17:34:34 <BMeph> RichardO: I would say, "Yes." But then, my wife says I'm a smart-ass. ;)
17:36:51 <RichardO> parcs: Doesn't have the right type. Am I missing something?
17:36:55 <RichardO> :t fmap fst get
17:36:55 <lambdabot> forall a b (f :: * -> *). (MonadState (a, b) f, Functor f) => f a
17:38:35 <Saizan> the name doesn't match the type, also the type doesn't make much sense, can you clarify what it should do?
17:39:08 <parcs> RichardO: yeah, i
17:39:12 <parcs> i'm wrong :)
17:39:14 <RichardO> I would like to get the first element in the tuple and return a new state with that element
17:39:58 <KSkrzet> uhm
17:40:04 <KSkrzet> i don't think it can be done
17:40:07 <Saizan> "State (Int, Int) a" doesn't contain a (Int,Int) tuple
17:40:17 <KSkrzet> say
17:40:21 <RichardO> It doesn't?
17:40:51 <KSkrzet> (\(x,y) -> x+y `fmap` get) :: State (Int,Int) Int
17:40:53 <Saizan> "State (Int, Int) a" is a transformation on (Int,Int) tuples which also produces an 'a'
17:41:06 <KSkrzet> how do you make it work with single Int state?
17:41:31 <Saizan> ?src State
17:41:31 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:42:06 <Saizan> RichardO: State (Int,Int) a = (Int,Int) -> (a,(Int,Int)), modulo newtype constructors
17:42:45 <RichardO> I thought (Int, Int) is the "state" and a is the return type
17:43:18 <Saizan> (Int,Int) is the type of the state here
17:43:21 <RichardO> get and put work on (Int, Int)
17:43:31 <Saizan> yeah
17:43:35 <luite> hmm, I've seen things like this, but cannot find the source
17:43:51 <luite> not with the regular state monad, but I believe it was called a type-indexed monad
17:44:02 <Saizan> but "State (Int,Int) a" won't contain a (Int,Int)
17:44:41 <RichardO> Hmmm, I think I see what you're saying
17:44:58 <Saizan> not anymore than a function of type Int -> Int -> Int contains an Int
17:47:35 <RichardO> Say I have this code, http://hpaste.org/45752/writert_state_stack. Is there a way to write it this way, http://hpaste.org/paste/45752/writert_state_stack_annotatio#p45753?
17:48:03 <koninkje> Does anyone know if Utf-8 can ever use the bytes 0x00..0x08,0x0B..0x1F other than encoding those ASCII characters?
17:48:13 * koninkje thinks not, but wants to check
17:48:14 <Saizan> RichardO: yes
17:48:24 <Saizan> RichardO: getFst = fmap fst get
17:48:59 <Saizan> getFst :: State (Int,Int) Int
17:49:52 <parcs> :t gets fst
17:49:53 <lambdabot> forall a b (m :: * -> *). (MonadState (a, b) m) => m a
17:50:02 <RichardO> What functor is fmap working on?
17:50:08 <RichardO> MonadState functor?
17:50:13 <Saizan> State (Int,Int)
17:50:33 <monochrom> koninkje: your guess is right
17:50:45 <koninkje> monochrom: cool. Just wanted to be sure
17:50:51 <Saizan> "getFst = do (a,b) <- get; return a" would also work
17:51:15 <monochrom> all non-ascii code points are encoded by byte values > 0x80
17:52:03 <koninkje> monochrom: That's what I thought, what with utf8 trying to be an easy upgrade path for ascii programs
17:52:16 <RichardO> I wasn't aware (State a) was a functor
17:52:59 <Saizan> most monads will have Functor instances, and all should have
17:53:14 <Saizan> fmap = liftM for them
17:53:33 <RichardO> ah, of course
17:56:04 <RichardO> looks like gets fst works as well
17:58:32 <monochrom> I know a chinese encoding (big-5) that uses 2 bytes per chinese character, but unfortunately the second byte can clash with ascii such as ' " %. if you include such bytes in a sql query and be careless, you run into much trouble
18:02:44 <KSkrzet> monochrom: sql injection must be fun in chinese webpages
18:05:13 <RichardO> is there a way to index into a tuple?
18:07:25 <KSkrzet> RichardO: I've seen a typeclass for it recently but I can't remember the package
18:07:45 <RichardO> k, probably isn't that easy to use
18:07:54 <KSkrzet> RichardO: you can try to look for something related to type level programming or smth
18:08:03 <KSkrzet> RichardO: true, I ended up using lists
18:08:04 <brbr> is there any easy way to augment a recursive function to print its arguments for every step?
18:08:16 <KSkrzet> brbr: Debug.Trace ?
18:08:19 <applicative> brbr: does this version of `decompose` look less clogged?  Maybe it needs to be rethought. http://hpaste.org/paste/45750/ecd_annotation#p45754
18:08:34 <applicative> @type Debug.Trace.trace
18:08:34 <lambdabot> forall a. String -> a -> a
18:10:25 <brbr> applicative: slick.   i like it
18:12:45 <brbr> KSkrzet: thanks. the trace seems to reveal more type info
18:12:47 <applicative> brbr, import Debug.Trace inside ghci, then fiddle with things like "let f x y = x + trace "plus" y  in foldr f 0 [1..10]"
18:13:17 <applicative> brbr, sorry, didn't see your last remark :)
18:13:28 <brbr> before, all i was seeing was: exception: Non-exhaustive patterns in case
18:13:57 <brbr> would be more helpful to also print what doesn't match in the case
18:14:11 <applicative> > head []
18:14:11 <lambdabot>   *Exception: Prelude.head: empty list
18:14:33 <applicative> @quote oasis
18:14:33 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:14:51 <applicative> I can never resist the temptation to quote this ^^^
18:14:52 <KSkrzet> brbr: it is tricky to get it right
18:14:59 <brbr> :)
18:16:03 <KSkrzet> brbr: imagine the case when matched types are lazy and infinite, and trying to printing error message would need infinite time and memory...
18:16:37 * applicative needs an audacious leader like Autrijus/Audrey to tell him what to do.
18:16:38 <KSkrzet> brbr: or in case of web server or other app, error message may go to the user and print them some data that arent supposed to be leaked
18:17:34 <KSkrzet> the first case I found out myself in recent code
18:17:37 <KSkrzet>           f@(Atto.Fail _ _ _) -> print "Fail!" >> error (take 10000 . show $ f)
18:17:48 * brbr hucks Debug.Trace.trace into the toolbox
18:17:53 <KSkrzet> "take 10000" is there because of the memory problem
18:21:01 <brbr> is there a way to do errors/exceptions instead of having every function return "Either String Type" where String is your error string and Type is a correct result?
18:21:19 <brbr> or is using Either the standard way for this sort of thing
18:21:35 <dmwit> brbr: Either is pretty good.
18:21:41 <dmwit> You can generalize to MonadError if you like.
18:21:50 <parcs> brbr: for monadic code, see ErrorT
18:22:02 <koninkje> Any Posix/OSX portability gurus in the house?
18:42:18 <geekosaur> after a fashion
18:45:28 <Kaidelong> brbr: Either is perfectly fine, remember you can fmap over it
18:51:58 <KSkrzet>             4326 MB total memory in use (0 MB lost due to fragmentation)
18:51:59 <KSkrzet> ouch
18:52:14 <KSkrzet> that is memory usage for processing 2Mb text file
18:53:09 <KSkrzet> It's either fgl not being efficient or me not understanding how to write efficient fgl code....
18:55:05 <ManateeLazyCat> Hi all! :)
18:56:05 <applicative> hi ManateeLazyCat!
18:56:11 <ManateeLazyCat> applicative: Hi. :)
18:56:35 <ManateeLazyCat> I miss you guys, maybe two week haven't login here. :)
18:57:15 * ManateeLazyCat Just push new patches make Manatee can save/restore window configuration between startup.
18:57:47 <ManateeLazyCat> Now you can read some book or write some code, and shutdown Manatee, Manatee will restore all those layout state when you next startup.
18:58:32 <ManateeLazyCat> And restore state is daemon fast since Daemon process just restore window layout, all application state restore in sub-process, so speed is daemon fast. :)
18:59:48 <ManateeLazyCat> Keep going on refactory input-completion code, hope i can release new version in next weekend.
19:00:12 <ManateeLazyCat> Of course, i can release new version if i can finish input-completion job today. :)
19:02:10 <applicative> can it be that the syntax highlighter for the emacs ocaml mode doesn't know what to do with long (* ........ *) comments?  
19:02:38 * applicative is feeling smugly but groundlessly superior after R. Harper's put downs.
19:03:49 <Kaidelong> R. Harper's put downs?
19:04:26 <ManateeLazyCat> Editor module stilling in toy level, i will find time improve editor module after i finish mail-client.
19:05:25 <applicative> Kaidelong: yes
19:05:39 <Kaidelong> what put downs in particular?
19:06:04 <applicative> modules good, type classes bad
19:06:15 <KSkrzet> can unfoldr cause space leak?
19:06:39 <applicative> Kaidelong: http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/  It's a bit over my head, this one. 
19:06:48 <Kaidelong> do modules give you the same lack of having to implement them locally that type classes do?
19:06:50 <applicative> KSkrzet: yes
19:07:23 <applicative> oh wait KSkrzet ignore that, i don't know
19:08:10 * applicative continues learing about module systems.
19:08:28 <applicative> Harper doesn't seem to know what the real secret power of Haskell is, as against MLs
19:09:45 <geekosaur> first class modules in Haskell would be a Good Thing, but type classes go well beyond merely being a hacky way to simulate modules
19:12:33 <ManateeLazyCat> @juhp Pull develop version, you will love it. :)
19:12:33 <lambdabot> Unknown command, try @list
19:12:40 <ManateeLazyCat> @tell juhp Pull develop version, you will love it. :)
19:12:40 <lambdabot> Consider it noted.
19:12:55 <ManateeLazyCat> Ok, it's time to coding, goodbye all. :)
19:13:27 <Kaidelong>  The second is that they confound two separate issues: specifying how a type implements a type class and specifying when such a specification should be used during type inference.
19:13:34 <Kaidelong> I am not understanding what he is saying here at all
19:14:17 <applicative> Kaidelong: I asked about that earlier. Saizan said: 
19:14:18 <applicative> applicative: i think he's referring to all the limitations imposed on what instances you can make just because the typechecker also has to automatically figure out when to use which for you
19:14:51 <Kaidelong> but you can save that to the point where you need a monomorphic type
19:15:08 <Philippa> Kaidelong: you can't declare "all Monads are Applicative" without fixing the Applicative instances of all Monads, for example
19:15:24 <Philippa> the former is specifying how a type implements a type class
19:15:37 <Philippa> the latter is specifying when to use a substitution
19:15:44 <Kaidelong> Philippa: that wouldn't be a problem with typeclasses fundamentally though
19:15:54 <Philippa> that said, it looks like (I haven't read all of the post yet) he brushes the issue of generative functors under the carpet
19:16:01 <Philippa> yes it is
19:16:11 * applicative thinks: generative functors?
19:16:13 <Philippa> the one type, one instance mapping is fundamental to type classes
19:16:19 <Kaidelong> you could come up with implementations of typeclasses where an applicative instance for all monads can be overriden
19:16:28 <Kaidelong> in special cases
19:16:41 <Philippa> applicative: functors in the ML sense (modules with 'sockets' for other modules) that generate new types each time - as opposed to applicative ones
19:17:33 <Philippa> Kaidelong: this is only technically true. You can't do so without breaking some pretty fundamental properties of type classes, or redesigning the rest of the type system to match
19:17:39 <Kaidelong> you can distinguish more general from more specific instances with a partial ordering.
19:18:01 <Kaidelong> when trying to find an appropriate instance
19:18:04 <Philippa> (the 'obvious' redesign: let Set parameterise on the Eq instance, etc etc - turns out to be surprisingly painful)
19:18:38 <Philippa> except you can't, because you don't know that someone else the opposite side of the codebase introduced a more specific instance
19:18:42 <Philippa> it breaks modularity
19:19:46 <Kaidelong> so one module can propogate fundamental changes accross the whole program
19:19:49 <applicative> someone on the other side of the codebase introduced a more specific instance of Set?
19:19:57 <Kaidelong> that does not sound like a bad thing
19:21:38 <Philippa> Kaidelong: it means you can't pick instances until link time
19:21:50 <Kaidelong> Right
19:21:54 <Philippa> (and breaks run-time staging completely)
19:23:41 <Philippa> that last point matters: you lose hs-plugins-based apps
19:23:44 <Tyr42> Does anybody know about what version of Visual Studio was used to build WinGHCi?  Is it free?  (I'm trying to fix tab completion)
19:23:57 * applicative feels a new admiration for laziness when the ocaml interpreter loops trying to interpret his module
19:24:48 <Kaidelong> I am not understanding what he means when he says Haskell is commited to laziness
19:25:04 <Kaidelong> my understanding was that the commitee set out very specifically not to do this
19:25:13 <Kaidelong> (exactly with parallelism in mind)
19:25:14 <Philippa> he means non-strictness
19:26:45 <jmillikin> Is there a standard word for the result of a function? In a procedural language I would say "this function returns a list of...", but in Haskell "return" implies monadic involvement.
19:26:59 <applicative> value ?
19:27:03 <dmwit> "returns" is fine.
19:27:11 <dmwit> "evaluates to" if it's particularly important that you avoid confusion
19:27:15 <dmwit> e.g.
19:27:26 <dmwit> "map succ xs evaluates to a list ..."
19:27:52 <Philippa> "yields" can work too, as can "gives", anything in that ballpark. But returns and evaluates are the formal ones
19:28:18 <applicative> people do say 'it takes a --- and yields a ...."
19:28:36 <applicative> strangely, I meant to write returns not yields
19:29:21 <jmillikin> "yields" it is -- "evaluates to" sounds awkward, but in this context I need to avoid confusion between values and actions. Thanks.
19:29:22 <applicative> yields gives and returns all suggest activity
19:29:45 <Kaidelong> I'm struggling to understand why you can't do proofs of haskell programs by induction
19:29:45 <applicative> but at least yields doesn'tinvite confusion with our special 'return'
19:29:50 <Kaidelong> that sounds like pedantry to me
19:30:21 <applicative> Kaidelong: You hadn't seen these posts?  Maybe I'm sorry for mentioning them.  
19:30:21 <Tyr42> but it has meaning to pythoners
19:30:28 <Kaidelong> at least as far as pedagogy is concerned
19:30:32 <Tyr42> so be careful when saying yeild to them
19:30:50 <Tyr42> *yield, sorry
19:31:15 <Philippa> Kaidelong: because induction is for finite values rather than infinite ones, basically. You /can/ do it anyway on the principle that 'fast and loose reasoning is morally correct' - you can use induction for proofs about a bottomless fragment and it'll work on real code so long as you don't feed it any bottoms
19:31:23 <applicative> hm jmillikin, why not make like math class and say the function is from ... to ____ ?
19:31:45 <Philippa> Tyr42: if they make that mistake when talking about Haskell, they deserve the cognitive dissonance
19:31:50 <Kaidelong> Philippa: that'd still be good enough to teach that kind of reasoning to students
19:32:01 <applicative> Philippa, isn't it enough that fast and loose reasoning is morally correct?  
19:32:25 <Kaidelong> So I don't understand the argument that Haskell shouldn't be taught because sometimes induction isn't enough
19:32:28 <jmillikin> applicative: It's for a docstring. I'm trying to use plain english, as the function's behavior is a bit ugly and non-obvious.
19:32:34 <applicative> Philippa: I see you have spared yourself the irritation of studying these posts.  Good plan. 
19:32:41 <Kaidelong> the syntax is cleaner and it is more popular
19:32:44 <Tyr42> Well, it the main way of being lazy in python, so it comes up when comparing the two languages
19:32:59 <Kaidelong> and the latter does matter
19:33:10 <applicative> 'the syntax is cleaner' is putting it mildly. 
19:33:14 <Kaidelong> learning about Java and Python is so easy largely because it is easy to find help
19:33:14 <Philippa> applicative: Bob Harper's? I got round to the rest. He's not free of problems, but he's a lot closer to being on target than many
19:33:32 <applicative> Philippa: yes, I like most of what he says, of course
19:34:13 <applicative> I am just trying to figure out the anti-Haskell bits, as they appear, but my ML fu is ... uh ... 
19:34:27 <applicative> under development
19:34:40 <Kaidelong> the only thing I recall when I went back to ML after haskell was being annoyed at a lot of things
19:34:52 <Kaidelong> but then again I never really heavily employed functors or modules
19:34:53 <applicative> haskells syntax is ravishingly beautiful. 
19:35:06 <applicative> It makes me mad with joy.
19:35:07 <Philippa> he's still got some point left re fast and loose too: we don't have a good way to put "bottoms not approved" in our types
19:35:08 <applicative> end;;
19:35:24 <Kaidelong> and I agree that Haskell could use a better implementation of typeclasses but I like the idea
19:35:50 <applicative> would a type extension that said that be a disaster? 
19:35:58 <applicative> i mean "bottoms not approved"
19:36:08 <Tyr42> But knowing if it will evaluate to bottom is a part of the halting problem
19:36:11 <Kaidelong> applicative: wouldn't that require a whole new language?
19:36:30 <Kaidelong> like Tyr42 said, one that isn't turing complete
19:36:33 <applicative> Probably.  
19:37:01 <Kaidelong> I think the approach is not to worry about bottom so much, except when you have to
19:37:14 <Kaidelong> you could treat haskell like a strict language in your thinking and be right a lot of the time
19:37:18 <applicative> But then, the ocaml interpreter is still trying to load my module, which contains a term for 'bottom' that would be pleasantly productive in Haskell
19:37:41 <Tyr42> add more lambda's around it?
19:38:21 <dmwit> Well, Haskell doesn't distinguish between data and codata, either. So that would be an issue to consider when designing a bottom-free fragment.
19:38:42 <Kaidelong> wb Philippa
19:38:44 <applicative> > let a = 0 : b ; b = 0 : a in take 3 a 
19:38:44 <lambdabot>   [0,0,0]
19:38:51 <Philippa> Kaidelong: cheers
19:39:10 <Philippa> Kaidelong: sadly there's no 'good enough' implementation of type classes that meets Harper's (implicit) criteria
19:40:01 <Kaidelong> do ML modules manage to do so?
19:40:04 <Philippa> that bit I mentioned about run-time staging/hs-plugins? That's a problem, and I doubt it's one he'd accept
19:40:06 <Philippa> yes, they do
19:42:33 <Philippa> (you could substantially improve Haskell's situation: make it possible to declare instances-in-potentia without making them instances, then separately make them instances)
19:43:02 <Philippa> (but there's also the thing where each time you want to meet a new interface, you have to do all the work explicitly: ML doesn't have the "superclass problem")
19:43:06 <Tyr42> hey, are you talking about http://existentialtype.wordpress.com/2011/04/16/modules-matter-most/
19:43:14 <Philippa> Tyr42: yep
19:43:28 <Tyr42> oh, hey I read that before coming here
19:44:08 <Tyr42> is there a good explanation of ML's module system somewhere?
19:44:35 <applicative> and good examples of people using it for practical purposes.
19:44:37 <applicative> ?
19:44:38 <Philippa> no doubt somewhere. I'm guessing Harper's book on Standard ML at least isn't a complete disaster: it's available in PDF online
19:44:48 <Tyr42> ok
19:44:51 <Tyr42> finding it now
19:45:10 <Philippa> applicative: how practical do you want? I don't know where to look myself, but certainly there've been not-just-theoretical discussions
19:45:15 <applicative> I remember a talk by the Jane Street guy, say, "Oh yes, do use functors" etc. like it doesn't happen much.
19:45:38 <Philippa> yeah, that's because when people come from other langs they don't think to
19:45:59 <Philippa> Newspeak is doing something equivalent to "make all modules that import be functors" though, and for good reason
19:45:59 <Tyr42> oh, hey I already had it open in one tab.
19:46:02 <m3ga> trying to 'cabal install base-unicode-symbols' and i'm getting "Control/Arrow/Unicode.hs:88:7: Not in scope: `>>>'". clues?
19:46:35 <Kaidelong> Newspeak is somewhat interesting
19:46:37 <applicative> that's strange.  is it a unicode >>>, so to say?
19:46:47 <Philippa> functors are how you say "I want to import something but someone else can tell me which instance", basically
19:46:51 <Kaidelong> although Bracha seems to have missed the point when with typeclasses somewhat
19:47:02 <KSkrzet> at some point >>> was moved around to different module
19:47:16 <KSkrzet> dependencies must be off
19:47:18 <Kaidelong> >>> is arrow-composition?
19:47:28 <Kaidelong> isn't that a fundamental arrow methods?
19:47:35 <Philippa> it is, yes
19:47:37 <Kaidelong> I thought arrows were like categories without id
19:48:06 <Philippa> heh. They've /got/ id (it's "arr id"), they've just got more structure on top
19:48:16 <Tyr42> oh, ya I remember that being moved
19:48:54 <Kaidelong> oh I see
19:48:59 <Kaidelong> (Category a) => Arrow a
19:49:08 <Kaidelong> hmm
19:49:21 <Tyr42> m3ga:  Try importing Control.Category
19:49:22 <Kaidelong> there was a typeclass somewhere that was a category without id
19:49:36 <Kaidelong> but it is not Arrow, clearly
19:50:05 <Tyr42> m3ga: or updating your Haskell platform
19:50:26 <Kaidelong> KSkrzet: >>> lives in Control.Category
19:51:06 <KSkrzet> has anyone ever written *fast* code in fgl?
19:51:08 <Kaidelong> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Category.html#t:Category
19:51:19 <m3ga> i don't have root access on this machine. i bootstrapped with ghc and cabal-install, so i don't have haskell-platform
19:54:21 <m3ga> is it even possible to install the haskell-platform as a non-root user? ie to my home directory on a linux machine?
19:54:44 <m3ga> i have ghc, tried to install HP from source and it bombed out.
19:54:49 <KSkrzet> ./configure --prefix=path ?
19:55:10 <KSkrzet> it works for GHC for sure
19:55:33 <KSkrzet> and given GHC you can compile HP rather easily
19:56:54 <dmwit> m3ga: Can you give a more specific error message than "it bombed out"?
19:57:15 <dmwit> m3ga: You may need to install -dev versions of some libraries, for example, and the error message might help us tell which ones.
19:58:08 <m3ga> dmwit: i thought i'd raise a bug in the haskell bug tracker instead :-) <command line>: cannot satisfy -package Cabal-1.10.1.0:
20:04:25 <copumpkin> ddarius: http://www.mitflea.com/index.html tomorrow?
20:05:45 <djahandarie> That website is very ghetto
20:05:50 <copumpkin> don't be hatin'
20:10:57 <dmwit> m3ga: There should be some more information after that line.
20:11:16 <dmwit> (Sorry for the slow reply -- our roof sprung a leak.)
20:13:42 <m3ga> :-( bout the leak. anyway, i;m past that. fixed by doing 'cabal install cabal --reinstall'. now it bombs out on Could not find module `Control.DeepSeq': Perhaps you haven't installed the profiling libraries for package `deepseq-1.1.0.2'?
20:14:05 <m3ga> now doing 'cabal install deepseq --reinstall' and trying again.
20:14:12 <dmwit> Enable profiling in your ~/.cabal/config and reinstall all your libraries.
20:14:13 <dmwit> yeah
20:14:31 <KSkrzet> use cabal-dev and dont reinstall anything
20:15:22 <KSkrzet> oh, sorry
20:15:23 <KSkrzet> i just read the whole context
20:16:00 <m3ga> is there an easy command to reinstall everythng?
20:16:09 <dmwit> no =(
20:16:36 <dmwit> ghc-pkg list will show what's installed, and you might be able to hack something together that does a for-loop in sh
20:16:40 <dmwit> But there's nothing elegant.
20:16:48 <m3ga> meh!
20:17:07 <amalloy> if there were an easy command to reinstall everything, it would be on the support-drone checklist for windows support
20:17:54 <KSkrzet> you can try to check which packages are leafes in dependency graph
20:18:02 <KSkrzet> remove old database by rm -rf
20:18:05 <jmcarthur> "cabal upgrade" currently will give you a list of packages that it *would* have installed if the functionality wasn't removed, but that doesn't mean you should reinstall all of them packages it lists. the reason it's disabled is because it would reinstall packages that really shouldn't be reinstalled, like base
20:18:12 <KSkrzet> and cabal install --enable-library-profiling those leaf packages
20:18:30 <jmcarthur> oh but that's only upgrades
20:18:32 <jmcarthur> ignore me
20:19:04 <parcs> recent versions of cabal support "cabal install world"
20:19:15 <KSkrzet> what?
20:19:24 <RichardO> @pl f x = g (+x)
20:19:25 <lambdabot> f = g . (+)
20:19:46 <RichardO> @pl f x = g (x+)
20:19:46 <lambdabot> f = g . (+)
20:19:55 <m3ga> There is no package named world. Perhaps you need to run 'cabal update' first?
20:20:36 <KSkrzet> parcs: I really miss cabal-install documentation, like I had no idea about this world stuff. Do you happen to know where to find decent docs?
20:20:38 <RichardO> @pl f x = g (flip h x)
20:20:39 <lambdabot> f = g . flip h
20:21:14 <dmwit> KSkrzet: You're on the Internet now. Recalibrate your sarcasm detector.
20:21:40 <KSkrzet> dmwit: cabal install world actually works
20:22:13 <KSkrzet> or almost works
20:22:21 <KSkrzet> ~/ cabal install world --dry-run
20:22:21 <KSkrzet> Warning: The following 'world' packages will be ignored because they refer to
20:22:21 <KSkrzet> packages that cannot be found: http, dsh, mongodb, hdbc-sqlite3, perfecthash,
20:22:26 <KSkrzet> For the dependency on warp ==0.3.0 there are these packages: warp-0.3.0.
20:22:30 <KSkrzet> However none of them are available.
20:22:32 <KSkrzet> warp-0.3.0 was excluded because warp-0.3.3 was selected instead
20:22:34 <KSkrzet> warp-0.3.0 was excluded because yesod-0.7.3 requires warp >=0.3.3 && <0.4
20:25:17 <Tyr42> I'm now trying to write the TicTacToe API from http://blog.tmorris.net/understanding-practical-api-design-static-typing-and-functional-programming/
20:25:29 <Tyr42> and I have move and undoMove working
20:25:40 <Tyr42> with type level numbers
20:26:15 <Tyr42> but I am not sure how to make the finished board
20:27:05 <Tyr42> should it be a boolean that is also passed around at the type level?
20:29:44 <dmwit> yes
20:33:33 <Tyr42> but it's going to need to have three states, unstarted, started, and finished, but move needs to work on both unstarted and started
20:34:15 <Tyr42> do I have to make another typeclass for every used combination of the two possible states?
20:35:40 <m3ga> hmm, trying to reinstall network to get profiling i get "Ambiguous occurrence `closeFdWith': It could refer to either `Network.Socket.closeFdWith' or 'GHC.Conc.closeFdWith'"
20:35:49 <Tyr42> yes
20:35:52 <Tyr42> that's what I got
20:36:03 <Tyr42> before I installed ghc from source
20:36:29 <Tyr42> http://askubuntu.com/questions/34390/problem-installing-cabal-1-8-0-2
20:36:51 <Tyr42> wait
20:37:09 <Tyr42> I still had the problem
20:37:18 <Tyr42> afterwards
20:37:31 <Tyr42> I looked at the source
20:38:00 <Tyr42> and the two definitions of closeFdWith are protected by #ifdefs
20:38:10 <Tyr42> but with two #s
20:38:15 <Tyr42> ##ifdef
20:38:44 <Tyr42> ##if on MIN_VERSION_base(4,3,1)
20:39:08 <Tyr42> and it's negation
20:40:56 <Tyr42> you could try editing the source to remove the one that doesn't apply
20:41:14 <Tyr42> to force it to compile properly on your machine
20:41:56 <m3ga> meh! i give up. going back to installing from debian packages.
20:58:56 <convulsive> m3ga, i had the same problem
20:59:13 <convulsive> ended up installing the platform instead
20:59:54 <m3ga> convulsive: how did you install HP? can you do it as a non-root user?
21:01:08 <convulsive> compile from source?
21:02:45 <m3ga> compiling platform from source is failing for me. looks like i have to compile ghc from source and i'm not sure i have the patience.
21:02:51 <monochrom> it can certainly be done as non-root user from source
21:03:09 <monochrom> no, no need to compile ghc
21:03:20 <RichardO> Is there a function like this: f (>5) 6 = Just 6; f (>5) 4 = Nothing?
21:03:33 <m3ga> monochrom: when i tried i ran into a world of pain and broken-ness
21:04:09 <RichardO> f :: (a -> Bool) -> a -> Maybe a
21:05:37 <monochrom> what is your "ghc -v" output and "ghc-pkg -v" output before haskell platform?
21:05:47 <monochrom> err "ghc-pkg list -v"
21:07:32 <osoleve> is it possible to do splitOn (x | y)?
21:10:31 <osoleve> oh, splitOneOf
21:11:01 <aavogt> @ty \p x -> guard (p x) >> return x
21:11:02 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => (b -> Bool) -> b -> m b
21:11:29 <jeffz> @let let r f a = case f a of; True -> Just a; False -> Nothing
21:11:30 <lambdabot>   Parse error: ;
21:11:33 <jeffz> hm
21:11:33 <luite> hehe that's exactly what I had
21:11:41 <luite> until I realized that using find is shorter :p
21:11:49 <luite> f p a = find p [a]
21:12:00 <luite> not as elegant maybe :)
21:12:18 <jeffz> @let r f a = case f a of True -> Just a; False -> Nothing;
21:12:18 <lambdabot>  <local>:1:0:
21:12:19 <lambdabot>      Warning: Pattern match(es) are overlapped
21:12:19 <lambdabot>               In...
21:12:37 <jeffz> > let (>5) 6
21:12:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:12:41 <jeffz> :/
21:12:48 <jeffz> > r (>5) 6
21:12:49 <lambdabot>   Ambiguous occurrence `r'
21:12:49 <lambdabot>  It could refer to either `L.r', defined at <local...
21:14:45 <jeffz> > rfoo (>5) 6
21:14:46 <lambdabot>   Just 6
21:14:48 <jeffz> :D
21:16:22 <path[l]> er
21:17:01 <monochrom> 10 minutes has passed. I see that he/she is more interested in calling it a bug then proving PEBKAC.
21:17:07 <monochrom> s/then/than/
21:18:55 <djahandarie> Would anyone directly be interested in proving that the real issue is PEBKAC?
21:19:14 <monochrom> not directly
21:19:59 <ivanm> what is this supposed instance of PEBKAC?
21:19:59 <monochrom> I am interested in diagnosing the problem and finding how to fix it. but this necessitates him/her disclosing information that will eventually reveal PEBKAC
21:21:11 <monochrom> a likely scenerio is by revealing "ghc -v" and "ghc-pkg list -v", one exposes oneself to "you messed with package xxx, you should not do that. ever."
21:21:57 <monochrom> a self-protection mechanism in brain takes measures to prevent that
21:23:23 <accel> window 6
21:23:51 <m3ga> monochrom: you mean me? i blew away the cabal and ghc installs. it was taking to much time going round in circles. i'm also not completely clueless. i am a debian haskell group mainatiner and i have at least three patches in the ghc git repo.
21:24:25 <monochrom> well, has anyone else reproduced the problem?
21:24:44 <m3ga> at least one person in this channel says they had the same problem
21:24:46 <ivanm> preflex: seen roconnor 
21:24:46 <preflex>  roconnor was last seen on #haskell-blah 5 hours, 40 minutes and 12 seconds ago, saying: good on you
21:25:16 <monochrom> alright then. I will build the new haskell platfom tomorrow anyway
21:27:32 <monochrom> since you are a debian haskell group maintainer, I want you to read my criticism in http://www.vex.net/~trebla/haskell/sicp.xhtml
21:29:33 <m3ga> monochrom: i have now given up on using cabal after every single try. i keep on learning that apt-get install works far better (for me).
21:29:43 <ivanm> monochrom: note that your article assumes that GHC is installed in /usr/local
21:29:47 <ivanm> I mean /usr
21:30:01 <m3ga> i also preach "do not mix apt-get and cabal"
21:30:15 <ivanm> monochrom: actually, you contradict yourself in the next bit
21:30:37 <ivanm> no, wait, I can't read...
21:30:38 <ivanm> >_>
21:31:00 <ivanm> no, wait, I was right the first time
21:31:11 <monochrom> where do I assume that ghc is in /usr?
21:31:27 <ivanm> monochrom: in your definition of prefix, you don't talk about where GHC is
21:31:35 <ivanm> you say so later on
21:31:56 <ivanm> which threw me
21:32:54 <monochrom> do you mean this sentence? "if global from your Linux distro, prefix = /usr"
21:33:06 <monochrom> which exact sentence? I need to see it
21:33:43 <ivanm> well, in that whole section it isn't clear IMHO that you're talking about packages installed after GHC
21:34:00 <ivanm> there's nothing making the "Packages that come with GHC" bit stand out
21:35:13 <ivanm> lol @ "The promiscuous upgrade whore"
21:36:06 <monochrom> "if global but not from GHC or your Linux distro, prefix = /usr/local" says that it refers to packages after ghc
21:36:46 <ivanm> right; it wasn't clear that you were referring to boot packages seperately from the bit just beforehand
21:37:47 <ivanm> monochrom: I think you're missing an important conclusion in your "only safe ways to install packages": distros get some way to easily create packages for hackage packages (or have native support) and you contribute new packages that you want but aren't already available to the repo
21:38:35 <djahandarie> Man I love Dijkstra
21:38:38 <ivanm> for most packages, there's nothing fancy that needs doing and it can all be automated
21:38:48 <ivanm> the only tricky bit is working out how to deal with deps on boot packages
21:38:50 <copumpkin> djahandarie: MAYBE YOU SHOULD MARRY HIM THEN
21:39:09 <djahandarie> copumpkin coming out of nowhere with that one
21:39:41 <ivanm> first he goes and mugs someone, know he's a big hulking mafia matchmaker...
21:39:55 <djahandarie> Haha
21:39:55 * ivanm wonders what copumpkin's career choice for tomorrow is going to be
21:40:01 <copumpkin> MURTHER
21:48:20 * hackagebot safecopy 0.4.2 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.4.2 (DavidHimmelstrup)
21:50:21 <crystal-cola> wheres anyone talking
21:50:52 <ddarius> copumpkin: If only you had Shae.
21:52:49 <crystal-cola> any good haskell
21:53:50 <Philippa> nah, only malevolent stuff. Missiles everywhere
21:53:52 <Axman6> huh?
21:53:58 <crystal-cola> haha Philippa 
21:55:25 <Philippa> Axman6: never seen "unsafePerformIO launchMissiles"?
21:55:39 <Axman6> my response was to crystal-cola 
21:56:03 <crystal-cola> im fed up  need something fun to do whats new in haskell
21:56:21 <ddarius> crystal-cola: Go rock climbing.
21:56:38 <crystal-cola> I used to do that but im scared of heights so I can only go up half way
21:56:59 <ian_mi> go running then :)
21:57:25 <ian_mi> you stay comfortably close to the ground
21:59:10 <crystal-cola> dose aynone do syntax based revision control?
22:00:13 <Philippa> approximately half the most expensive windows apps do, they just don't generally show the source to users
22:12:50 * ddarius wonders if Paul Taylor is that "unorthodox."
22:13:08 <crystal-cola> religiously or axiomatically?
22:17:14 <crystal-cola> today is boring
22:22:03 <copumpkin> roconnor: zooko appreciates your blog post
22:26:23 <elventear> Anyone awake willing to lend a hand to a noob? I am trying to use Takusen and I can't for anything in the world make it do what I want.
22:30:52 <monochrom> well, the new haskell platform builds from source just fine for non-root (./configure --prefix=/home/blah/hp)
22:37:55 <gienah> elventear: I haven't used takusen, so I don't really know. an idea is you could cheat and use acid-state then come back to figuring out how to use a rdbms later.
22:47:57 <TomMD> is there an emacs mode for happy?
22:55:50 <tango> hello from the Philippines!
22:56:49 * ivanm waves at tango 
22:57:00 <ivanm> tango: we're planning on having a Hackathon in Sydney in July; interested?
22:57:32 <tango> thanks, but at the moment i am working on a project and cannot travel
22:57:44 <ivanm> fair enough
22:57:46 <amalloy> TomMD: not sure what you mean (and wouldn't have an answer anyway), but i love the idea of M-x prozac
22:57:47 <ivanm> just figured I'd let you know
23:00:09 <tango> i am trying out different languages and it seem that the haskell tutorial seems like ruby's and/or python's
23:03:14 <Lemmih> preflex: @seen ksf 
23:03:15 <preflex>  ksf was last seen on #haskell-blah 44 seconds ago, saying: and never hestitate confusing logicians by using functional programming in your formulas.
23:03:29 <ksf> hey
23:04:51 <Lemmih> ksf: Do you happen to have any other changes you'd like to see in acid-state?
23:05:01 <ddarius> copumpkin: Did you guys prepare a dough?
23:05:45 <ksf> Lemmih, none so far, no
23:06:36 * ddarius <3 fibred adjunctions.
23:06:52 <Lemmih> ksf: Excellent. If you come across something which you think is insufficiently documented or lacks an example to illustrate clearly, please let me know.
23:07:00 <ksf> will do
23:07:37 <crystal-cola> :/
23:08:30 <Lemmih> ksf: How do you handle changing your data type definitions, if you don't mind me asking? Do you use Happstack.Serialize?
23:08:43 <ksf> so far, not at all
23:10:34 <ksf> on a quick glance, it'd be good to have a way to version the db's, have some more control over serialising... not just the data itself, but also the Typeable name.
23:11:15 <Lemmih> ksf: I've put information about the SafeCopy package on the acid-state wiki. SafeCopy seems fairly good but I'm not confident enough to make it the default for acid-state. If you're interested, I'd love some feedback on that package as well.
23:11:50 <ksf> if acid-state can load a database into an arbitrarily-named ADT, changing stuff shouldn't be a problem
23:14:11 <Lemmih> acid-state defers parsing to Data.Binary. If Data.Binary can't parse the state then acid-state fails.
23:14:36 <ksf> one could just pass two functions to the core, no need for a typeclass
23:14:47 <Lemmih> Two functions?
23:14:56 <ksf> one for serialising, one for deserialising
23:15:12 <Lemmih> Oh, right. But that wouldn't buy you anything, would it?
23:15:37 <ksf> so I could, for example, serialise as ebml or whatever if I happened to have serialisers ready for that.
23:15:40 <Lemmih> Thing is, you need a deserialiser that can deserialise several versions of the state.
23:16:34 <Lemmih> Ah yes, serialising to something with a fixed schema is an option.
23:16:40 <ksf> deserialise :: ByteString -> Either Version1 (Either Version2 Version3)
23:17:27 <ksf> or, well, deserialise :: ByteString -> EBML
23:17:36 <Lemmih> SafeCopy makes it less error-prone to write exactly such deserialiser.
23:18:11 <ksf> yep, but that doesn't mean you have to hardcode it.
23:22:12 <Lemmih> Whatever solution you pick, I'd love to hear how it worked and which problems you encountered.
23:28:03 <mrrk> is there a ghci equivalent of ipython's %time (which works like the unix command line tool `time`)?
23:28:44 <shachaf> mrrk: :set +s, maybe?
23:29:35 <mrrk> that's perfect, thank you!
23:53:33 <auastro> pl \a b f -> a . b f
23:53:53 <ChongLi> hey
23:54:10 <auastro> hey
23:54:14 <ChongLi> I'm having a go at re-implementing ken perlin's improved noise in haskell
23:54:22 <auastro> cool
23:54:31 <ddarius> You may also want to look at wavelet noise.
23:54:44 <ChongLi> I probably will check it out
23:55:07 <boegel> ChongLi: check out HRay, which has an implementation of Perlin's noise
23:55:46 <boegel> ChongLi: see http://boegel.kejo.be/ELIS/Haskell/HRay/
23:55:50 <ChongLi> I was wondering if anybody knew of a really clean way to run all the lerps with some kind of higher order function
23:56:01 <ChongLi> like a hold or something
23:56:26 <ChongLi> there are 7 lerp function calls nested in a tree
23:57:13 <ChongLi> I'm still quite a haskell newbie
