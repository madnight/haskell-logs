00:01:54 <ClaudiusMaximus> balor: yes, it's possible, but i don't know if it's in any library..
00:04:21 <ClaudiusMaximus> balor: want to see my solution?  i used case analysis on Data.Set.minView, recursing with union/map/insert
00:05:38 <balor> ClaudiusMaximus, Can you hpaste it please?
00:06:36 <ClaudiusMaximus> > let power s = case S.minView s of { Nothing -> S.singleton S.empty ; Just (e, s') -> let t = power s' in t `union` S.map (S.insert e) t } in power (fromList "yes")
00:06:37 <lambdabot>   Couldn't match expected type `[a]'
00:06:37 <lambdabot>         against inferred type `Data.Set....
00:06:53 <ClaudiusMaximus> > let power s = case S.minView s of { Nothing -> S.singleton S.empty ; Just (e, s') -> let t = power s' in t `S.union` S.map (S.insert e) t } in power (fromList "yes")
00:06:54 <lambdabot>   Couldn't match expected type `(a, GHC.Real.Rational)'
00:06:54 <lambdabot>         against infer...
00:07:24 <ClaudiusMaximus> > let power s = case S.minView s of { Nothing -> S.singleton S.empty ; Just (e, s') -> let t = power s' in t `S.union` S.map (S.insert e) t } in power (S.fromList "yes") -- well, hopefully...
00:07:25 <lambdabot>   fromList [fromList "",fromList "e",fromList "es",fromList "esy",fromList "e...
00:09:08 <ClaudiusMaximus> @hoogle disjoint
00:09:08 <lambdabot> No results found
00:09:49 <balor> ClaudiusMaximus, Thanks. it's very similar to how I've done it for lists.  The minView use is nice
00:14:31 <ClaudiusMaximus> but lists are probably "better", as they're lazier, and power sets are large...
01:00:17 <fabbb> @pl zipWithX f (a:as) (b:bs) = (f a b : fst x, snd x) where x = zipWithX f as bs
01:00:17 <lambdabot> (line 1, column 59):
01:00:17 <lambdabot> unexpected "="
01:00:18 <lambdabot> expecting variable, "(", operator or end of input
01:00:46 <fabbb> @pl (f a b : fst x, snd x) where x = zipWithX f as bs
01:00:46 <lambdabot> (line 1, column 32):
01:00:46 <lambdabot> unexpected "="
01:00:46 <lambdabot> expecting variable, "(", operator or end of input
01:00:58 <fabbb> @pl let x = zipWithX f as bs in (f a b : fst x, snd x)
01:00:58 <lambdabot> (f a b : fst (zipWithX f as bs), snd (zipWithX f as bs))
01:19:09 <ohwow> Hello, how are you doing this fine day?
01:20:00 <ohwow> I am reading this Introduction to Lambda-calculus paper, and I have a questions. They say that lambda-term (\xx)z /= z
01:20:04 <ohwow> why  is it  so?
01:20:59 * hackagebot archlinux 1.1 - Support for working with Arch Linux packages.  http://hackage.haskell.org/package/archlinux-1.1 (PeterSimons)
01:21:20 <ohwow> (M = N denotes that M and N are the same term or can be obtained from each other by renaiming bound variables)
01:22:09 <FUZxxl> Isn't this just ß-reduction?
01:22:46 <quicksilver> ohwow: why are they not equal? well, because they aren't.
01:23:07 <quicksilver> ohwow: that equality is syntactical. The only thing it permits is renaming bound variables as you just said.
01:23:18 <quicksilver> so (\x.x)z = (\a.a)z
01:23:27 <quicksilver> but does not = z
01:23:56 <ohwow> quicksilver: oh, i see
01:23:58 <ohwow> thanks
01:32:00 <Botje> ohwow: equal is not the same as 'reduces to'
01:36:01 <Eduard_Munteanu> Something interesting crossed my mind. What if you had a programming language (with a sufficiently powerful type system) where you could only write types, more or less? Say proofs were restricted to some terms or had to be inferred by the compiler altogether.
01:37:27 <adnam> Eduard_Munteanu: hmm, what would the benefit be?
01:37:33 <Eduard_Munteanu> So if one can type his program in enough detail that the compiler can figure out the implementation (at least up to some constants), perhaps such a program would have really strong guarantees.
01:37:40 <Botje> seems to work just fine for oleg.
01:39:01 * hackagebot iteratee-compress 0.2.1.0 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.2.1.0 (MaciejPiechotka)
01:43:09 <Eduard_Munteanu> adnam: well I was considering how often one ends up with less type information than is possible
01:43:28 <Eduard_Munteanu> In such a case, some properties of the resulting program might not be proven.
01:44:02 <Eduard_Munteanu> As a simple example, consider normal lists vs dependently typed lists (indexed by length)
01:44:42 <Eduard_Munteanu> Or arrays. Arguably the "more typed" version is safer.
01:45:45 <balor> I'm trying to write "rand :: Int" for use with quickcheck.  I've currently got something like "rand = oneof (randoms mkStdGen)" or "rand=snd (random mkStdGen)" as I thought the standard generator generated "Int".  Neither are correct, but I don't understand why. Could someone enlighten me?
01:46:48 <Eduard_Munteanu> So my idea was to force the programmer to encode as much as possible in types.
01:49:18 * Eduard_Munteanu thinks he picked the wrong time to have half a revelation, everybody usually sleeps now :)
01:50:11 <balor> Ah, I was doing it wrong "rand = fst (random (mkStdGen 1))" :)  But obviously, now, that doesn't do what I want it to!
01:53:37 <jeffz> Eduard_Munteanu: what would it look like?
01:55:05 <alpounet> Eduard_Munteanu, you mean that the compiler would be like @djinn at a large scale ?
01:55:07 <alpounet> larger*
01:55:12 <Eduard_Munteanu> id :: a -> a     id = <let the compiler infer>
01:56:06 <Eduard_Munteanu> alpounet: it needn't be really smart, if one encodes sufficient information in types (, but yeah
01:56:11 <Eduard_Munteanu> *(I guess)
01:57:13 <Eduard_Munteanu> Or like Agda's Agsy/Auto.
02:10:05 <andras> hi guys
02:10:46 <andras> I have a data type for which I want to define filter -- how do I do it, what class does my type need to be an instance of?
02:11:09 <shachaf> @ty filter
02:11:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
02:11:22 <shachaf> You can't use the same function, since it only works on lists.
02:11:39 <shachaf> You can export your own function by the same name, though:
02:11:43 <shachaf> @ty M.filter
02:11:44 <lambdabot> forall a k. (Ord k) => (a -> Bool) -> M.Map k a -> M.Map k a
02:11:47 <shachaf> @ty S.filter
02:11:48 <lambdabot> forall a. (Ord a) => (a -> Bool) -> S.Set a -> S.Set a
02:11:48 <merijn> @hoogle (a -> Bool) -> f a -> f a
02:11:49 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
02:11:49 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
02:11:49 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
02:12:29 <merijn> andras: Doesn't seem to be a typeclass for that, so you'll have to implement something yourself
02:13:02 <andras> that means I can't use the name filter for my own type, will have to use a different name instead, right?
02:13:46 <merijn> andras: You could probably shadow the Prelude version of filter inside your own package and make people use a qualified version
02:16:21 <andras> merijn: ok, so I can't write my code so that "filter" (without any module names etc.) can be applied both to lists and to my own type in the same source code, right?
02:16:38 <merijn> andras: Correct
02:16:48 <andras> ok guys, thanks a lot, that's it for now
02:18:07 <shachaf> angstrom: Well, you...
02:18:11 <shachaf> Ha.
02:23:08 <navaati> hello
02:26:21 <PeakerWork> hmm, cabal install -v tells me it will install an older version of the directory package, which I don't want.  how can I know which dependency is forcing that version of directory?
02:26:52 <dcoutts> PeakerWork: cabal install --dry-run -v3 should provide a bit more info
02:27:04 <dcoutts> you'll see where it picks something that excludes the later version
02:27:26 <PeakerWork> dcoutts: thanks
02:27:56 <PeakerWork> dcoutts: seems the output is identical/similar with -v3
02:28:28 <dcoutts> PeakerWork: look in the earlier part of the log where it goes through saying what it's selecting and discarding
02:28:48 <dcoutts> PeakerWork: another trick is to use --constraint='directory >= x.y'
02:28:58 <dcoutts> and then see what it says conflicts with that constraint
02:29:49 <PeakerWork> dcoutts: ah that'd probably work, thanks
02:35:26 <PeakerWork> ok, so I had cabal-install 0.8.2 from ghc 6.12 and was using that with ghc 7.. leksah didn't like that
02:40:37 <angel_de_vicente> Hi, I'm just reading through "The Craft of Functional Programming", the section on classes. A brief question: can I query GHCi to tell me the instances of (for instance) the class Eq? thanks
02:41:09 <navaati> :i Eq
02:41:23 <merijn> angel_de_vicente: ":info Eq"
02:41:38 <merijn> But that only returns instances which are currently in scope
02:42:00 <angel_de_vicente> OK, thanks a lot
02:42:02 <merijn> Alternatively, Hoogle can probably search for that sorta thing too
02:50:35 <balor> Given the definition of Foo in http://hpaste.org/46099/quickcheck_arbitrary_example How can I proved an arbitrary generator that enforces that (subset Foo) is a subset of (set Foo)?
02:53:33 <fabbb> @pl \ritem -> (getRReservationNumber ritem, getRFromStationId ritem, getRToStationId ritem, getRTrainId ritem, getRCarId ritem, fromJust $ getRSeatId ritem)
02:53:33 <lambdabot> ap (ap (ap (ap (liftM2 (,,,,,) getRReservationNumber getRFromStationId) getRToStationId) getRTrainId) getRCarId) (fromJust . getRSeatId)
02:53:48 <merijn> Yeah, that's much better! ;)
02:53:55 <fabbb> not really :-)
02:54:33 <PeakerWork> how old is the dude presenting the Leksah tutorial in parts on Youtube? he seems pretty young
02:59:20 * hackagebot reactive-banana 0.2.0.1 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.2.0.1 (HeinrichApfelmus)
03:06:18 <rostayob> is there a way to show the type of any function in the current scope in emacs?
03:06:35 <rostayob> right now I can only get stuff from the prelude
03:08:03 <merijn> I think there is a haskell mode for emacs which let you do things like that?
03:08:38 <merijn> Alternatively I always just import the file I'm working on in ghci and save/reload often so I can play around with what I'm writing
03:09:37 <rostayob> merijn: there is, but what it does is just loading up ghci and doing :t foo
03:09:42 <rostayob> with nothing loaded
03:09:53 <rostayob> i'd like something that loads up ghci with all the modules of the current file
03:10:03 <rostayob> or maybe incrementally adds modules to ghci
03:10:51 <merijn> You can just run ":load yourfile.hs"? Of course that won't interact with emacs automatically, which should be possible too, but since I don't use emacs I dunno
03:11:52 <rostayob> merijn: you can do that, but that's quite impractical
03:12:43 <rostayob> I mean it shouldn't be too hard to have the modules loaded on the fly
03:21:46 <balphas> anyone here a Network.Riak user that could shed some light on a problem?
03:21:59 <balphas> (or, does anyone use it and have it working?)
03:25:14 <quicksilver> rostayob: no, the haskell-mode does (try to) load the current file.
03:25:20 <quicksilver> rostayob: (which then includes all its modules automatically)
03:25:30 <quicksilver> rostayob: if it doesn't appear to be doing that, something has has gone wrong.
03:33:48 * hackagebot reactive-banana-wx 0.2.0.1 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.2.0.1 (HeinrichApfelmus)
03:34:43 <rostayob> quicksilver: so if you type C-c C-t and then get the type of something, it loads the current file?
03:36:22 <quicksilver> rostayob: Yes. That is the intended behaviour and that's the way it worked for me last time it tried.
03:36:38 <quicksilver> rostayob: it should do the equivalent of C-c C-l first (which loads current file)
03:36:44 <quicksilver> C-c C-l certainly has always worked fo rme
03:37:09 <rostayob> quicksilver: ok, so what you do is to load the current file into the ghci instance, and then C-c C-t
03:37:58 <quicksilver> rostayob: I don't do anything manually. C-c C-t does it all for me.
03:38:12 <rostayob> quicksilver: ok, it doesn't do it here. strange.
03:38:13 <quicksilver> rostayob: but what I'm describing is how C-c C-t (is intended to) work
03:38:22 <quicksilver> does C-c C-l work for you?
03:38:27 <rostayob> yes
03:38:29 <quicksilver> are you using a recent haskell-mode?
03:38:44 <c63> hey, may i run a haskell program as user which itself may login into another user to read its home directory? (linux)
03:38:47 <rostayob> quicksilver: yeah I guess so, let me check
03:39:48 <navaati> c63: it's not a haskell question, it's a linux question
03:39:48 <navaati> but i guess that you could using some kind of fork()
03:40:10 <rostayob> quicksilver: 2.8
03:40:38 <quicksilver> rostayob: yes, that's what I'm using. Odd.
03:40:44 <whald> hello, is there a quick way/library which would allow me to show a progress reporter on the console like what wget does when downloading? like this: [............                    ]
03:42:16 <c63> thought some has dont so before
03:42:17 <rostayob> quicksilver: mhm... does it actually say in the ghci buffer "loading this" when doing C-c C-t?
03:42:24 <rostayob> because it doesn't try at all here
03:43:54 <rostayob> quicksilver: also, I've got another problem with C-c C-l: it a mess with local modules, because it loads the file from the file directory
03:44:45 <rostayob> so if I have One/File.hs and Two/File.hs and I import Two.File from One/File.hs it can't load it in the ghci buffer. if I :cd manually, it doesn't find the file.
03:48:45 <angel_de_vicente> hi, another question about the book "The Craft of Functional Programming". It states that foldr1 f(x:xs) = foldr f x xs but this is not always right. Is this an error in the book or do I miss something? 
03:50:27 <rostayob> angel_de_vicente: that is always right
03:50:47 <rostayob> @check foldr1 f (x:xs) == foldr f x xs
03:50:47 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
03:50:56 <rostayob> oh, I don't know how to use that :P
03:51:16 <c63> navaati: can i somehow verify the credentials a user passes me?
03:51:42 <FrederikVds> It's not identical though, foldr1 has type (a -> a -> a) -> [a] -> a while foldr has type (a -> b -> b) -> b -> [a] -> b. It's only identical when a == b
03:51:47 <c63> running the program as root i could use setUserID from System.Posix.User afterwards
03:51:54 <rostayob> @check \(x:xs) -> foldr1 f (x:xs) == foldr f x xs
03:51:54 <lambdabot>   Add a type signature
03:52:31 <zygoloid> @check let f = (++) in \x xs -> foldr1 f (x:xs) == foldr f (x::String) xs
03:52:32 <lambdabot>   "Falsifiable, after 1 tests:\n\"\\772337\\411756\\551904\"\n[\"\\953958\\10...
03:52:35 <rostayob> @check \(x:xs) -> foldr1 f (x:xs) == foldr f x xs :: [Int] -> Bool
03:52:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Int] -> GHC.Bool.Bool'
03:52:47 <angel_de_vicente> Prelude Data.List> foldr1 (-) [4,5,6]
03:52:47 <angel_de_vicente> 5
03:52:48 <angel_de_vicente> Prelude Data.List> foldr (-) 4 [5,6]
03:52:48 <angel_de_vicente> 3
03:53:06 <rostayob> @src foldr1
03:53:06 <lambdabot> foldr1 _ [x]    = x
03:53:06 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
03:53:06 <lambdabot> foldr1 _ []     = undefined
03:53:36 <azaq23> @check ((\xs -> if null xs then True else foldr1 f (tail xs) == foldr f (head xs) (tail xs)) :: [Int] -> Bool)
03:53:38 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Types.Int)
03:53:38 <lambdabot>    arising from a us...
03:53:46 <merijn> angel_de_vicente: You're correct that foldr1 and foldr are not always the same
03:54:10 <zygoloid> > (foldr1 f [a, b], foldr f a [b])
03:54:11 <lambdabot>   (f a b,f b a)
03:54:37 <zygoloid> @src foldr1
03:54:38 <lambdabot> foldr1 _ [x]    = x
03:54:38 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
03:54:38 <lambdabot> foldr1 _ []     = undefined
03:54:41 <navaati> c63: you may launch a new process from the user process, and lauch it like "su " ++ theuseryouwant ++ " -c '" ++ thecommand ++ "'"
03:54:43 <rostayob> angel_de_vicente: oh, right, well spotted
03:55:03 <angel_de_vicente> Prelude Data.List>
03:55:31 <zygoloid> > (foldr1 (*) [a, b, c, d], foldr (*) a [b, c, d])
03:55:32 <lambdabot>   (a * (b * (c * d)),b * (c * (d * a)))
03:55:38 <angel_de_vicente> sorry, my first (almost) time with IRC... I still don't know how to send stuff properly :-(
03:55:54 <zygoloid> foldr1 f xs@(_:_) = foldr f (last xs) (init xs)
03:56:09 <c63> navaati: that looks really ugly to me ...
03:56:31 <angel_de_vicente> never used @check or @src before Can I just use this in ghci out of the box?
03:56:45 <navaati> c63: less ugly than changing the permissions of a running process, i don't even know if it is possible
03:57:07 <azaq23> angel_de_vicente: @src does not exist in ghci, @check uses Test.QuickCheck
03:57:15 <merijn> c63: No, you can't verify a users credentials in any sane way
03:57:16 <azaq23> those things are lambdabot plugins
03:57:16 <navaati> angel_de_vicente: no, it's a feature of lambdabot
03:57:25 <c63> why shouldnt it be? a daemon may su to nobody during startup
03:57:27 <osfameron> is there an AV monad, for calculating election results? ;-)
03:57:38 <c63> merijn: what about pam?
03:57:45 <navaati> c63: yes, and for doing so it forks
03:58:04 <zygoloid> osfameron: for modelling when your elected representatives themselves vote on issues?
03:58:25 <merijn> c63: Programs not run as root can NEVER, NEVER, EVER trust *anything*
03:58:33 <osfameron> zygoloid: well, for modelling how you'd vote under AV, in general.
03:58:36 <angel_de_vicente> thanks, I will check lambdabot
03:58:56 <merijn> c63: Your program calls PAM to verify credentials. I launch gdb and skip your verification code. Bam! Security by-passed
03:59:04 <osfameron> actually, not sure it'd need to be a monad, as it does only return 1 answer, so it's not nondeterministic, like the probability monad
03:59:12 <azaq23> @check ((\a b -> (a + b) ^ 2 == a^2 + 2*a*b + b^2) :: Int -> Int -> Bool)
03:59:13 <c63> so i have to run my program as root, fork()ing for each user which authenticates to read its home directory?
03:59:13 <lambdabot>   "OK, passed 500 tests."
03:59:24 <azaq23> angel_de_vicente: regarding @check, ^
03:59:29 <merijn> c63: What does your program do?
03:59:53 <c63> merijn: i would like to create a simple happs webapp to browse my home directory
04:00:28 <c63> but im not sure how to do so
04:00:51 <osfameron> !hoogle on
04:00:56 <merijn> c63: And you need to prevent code in users home dir from taking over the machine (which could happen if your server is root)?
04:00:58 <osfameron> @hoogle on
04:00:58 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:00:58 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
04:00:58 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
04:01:32 <merijn> c63: Or you mean a web front-end for your filesystem?
04:01:42 <c63> yeah right, the latter
04:01:52 <c63> view/read/write/upload files
04:02:29 <c63> using the linux user accounts as valid login information
04:02:30 <merijn> c63: And your server runs as root?
04:02:42 <c63> not unless it has to
04:03:08 <c63> im not sure how to do it in a proper way, so i dont know if its the only way
04:03:43 <angel_de_vicente> @src foldr1
04:03:43 <lambdabot> foldr1 _ [x]    = x
04:03:43 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
04:03:43 <lambdabot> foldr1 _ []     = undefined
04:04:05 <angel_de_vicente> sorry for the noise... just testing lambdabot
04:04:15 <merijn> c63: Well, it also depends on your threat model. Do you trust everyone with access to the machine? If so, you could try to verify credentials without running as root
04:04:44 <azaq23> angel_de_vicente: you can message lambdabot privately, /msg lambdabot.
04:04:51 <c63> merijn: how could i do so?
04:05:16 <angel_de_vicente> /msg lambdabot @src foldr1
04:05:17 <c63> merijn: Maybe i could trust everyone whos in a specific group?
04:05:35 <angel_de_vicente> oops... newbie here
04:05:49 <quicksilver> rostayob: C-c C-l makes some effort to fine the root directory of your 'project'
04:06:00 <quicksilver> I'm not sure it always works if you don't have a .cabal file to guide it
04:06:15 <quicksilver> touch dummy.cabal in the right dir might guide it althoug that's an ugly hack.
04:08:11 <merijn> c63: Well, the more I think about this. The more I realize doing this securely is *really* hard.
04:08:43 <c63> it would be some kind of ftp server
04:09:00 <c63> verify credentials, chroot, setuid, serve
04:09:18 <merijn> That is probably the best way, yes
04:09:37 <merijn> You have to be really careful that the code running as root is not exploitable, though
04:10:29 <c63> well, maybe your willing to help me?
04:10:38 <merijn> You should also limit the number of authentication attempts so people can brute-force your webinterface to obtain passwords
04:10:48 <osfameron> @hoogle dup
04:10:48 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
04:10:48 <lambdabot> Control.Concurrent.STM.TChan dupTChan :: TChan a -> STM (TChan a)
04:10:48 <lambdabot> Language.Haskell.Syntax data HsFieldUpdate
04:15:16 <ManateeLazyCat> Hi all. :)
04:15:20 <merijn> c63: Unfortunately I barely have time to finish my own stuff ;) It boils down to a few simple rules, though. 1) NEVER trust ANY input you got from a user/the web 2) Check that input is 100% as you expect and ignore everything else (keep in mind people can construct HTTP requests without browsers thus sending any random input to you) 3) Get rid of root privileges as quick as possible 4) Always limit the number of login attempts
04:17:58 <c63> ok, i gotta go now but i keep these in mind
04:22:19 <osfameron> > (\x -> (length x, x)) $ [1,2,3,4]
04:22:20 <lambdabot>   (4,[1,2,3,4])
04:22:27 <osfameron> > (length *** id) . join (,) $ [1,2,3,4]
04:22:29 <lambdabot>   (4,[1,2,3,4])
04:22:42 <quicksilver> > length x &&& id $ [1,2,3,4]
04:22:43 <lambdabot>   Couldn't match expected type `[a]'
04:22:43 <lambdabot>         against inferred type `SimpleRef...
04:22:53 <quicksilver> bah
04:22:59 <quicksilver> > length &&& id $ [1,2,3,4]
04:23:00 <lambdabot>   (4,[1,2,3,4])
04:23:12 <quicksilver> osfameron: congratulations you've discovered the relationship between *** and &&& :)
04:23:19 <merijn> :t (***)
04:23:20 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:23:30 <hpc> :t (&&&)
04:23:30 <osfameron> quicksilver: not really.  All I know is that they "put commas in stuff" ;-)
04:23:31 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:23:34 <merijn> oooooooh
04:23:52 <navaati> angel_de_vicente: you can talk in private with lambdabot
04:24:16 <hpc> you can talk in private with anyone
04:24:18 <navaati> oops already said
04:24:28 <hpc> :P
04:24:54 <quicksilver> osfameron: well, no, *** allows a pair of functions to work under a comma
04:24:56 <osfameron> quicksilver: what's an Arrow?  which part of that expression is the arrow?
04:25:05 <hpc> incidentally, responding to a PM is simpler than responding to what someone says in a channel
04:25:07 <merijn> osfameron: Functions are arrows
04:25:16 <quicksilver> osfameron: whilst &&& creates a comma by acting a pair of functions on a single input.
04:25:33 <aristid> @let inprivate p1 p2 = text $ p1 ++ ": You can talk in private with " ++ p2
04:25:33 <lambdabot>  Defined.
04:25:34 <quicksilver> osfameron: in this case, the arrow is just functions, yes.
04:25:47 <hpc> osfameron: do you know what Category is?
04:25:53 <osfameron> hpc: no, tbh
04:25:54 <aristid> > "navaati" `inprivate` "hpc"
04:25:54 <quicksilver> osfameron: so, length is a function, id is a function.
04:25:55 <lambdabot>   navaati: You can talk in private with hpc
04:25:59 <hpc> osfameron: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8
04:26:05 <hpc> osfameron: arrows are categories with perks
04:26:15 <hpc> but categories are what you want to understand first
04:26:17 <quicksilver> osfameron: and you're using &&& and *** on the functions length and id in the 'function arrow'
04:26:20 <hpc> it makes the whole concept so much easier
04:26:51 <osfameron> hpc: though, really, "stuff that makes 2 functions work on a single input" is easy enough to understand, in the first instance
04:27:00 <merijn> osfameron: It always made more sense thinking like this: "(Arrow a) => a b c -> a b c' -> a b (c, c')" -> "(Arrow (->)) => ((->) b c) -> ((->) b c') -> ((->) b (c, c'))" or, more traditionally: "(Arrow (->)) => (b -> c) -> (b -> c') -> b -> (c, c')
04:27:24 <osfameron> merijn: eeek!
04:27:55 <merijn> It only looks scary until the point where your brain melts :>
04:28:27 <osfameron> merijn: you're overloading "->" to mean ( "this type" is equivalent to "that type" ) ?
04:29:03 <osfameron> ok, it ends with an arrow (->) b (c,c') i.e. with a function (b -> (c,c'))
04:29:04 <merijn> osfameron: Yeah, the -> in between was a bit silly
04:29:19 <merijn> I should have probably used "is the same as" instead
04:29:32 <navaati> merijn: if you say "Arrow (~>) =>" is less ambiguous
04:29:47 <osfameron> ok: so it's equivalent to (a -> c) -> (a->c') -> (a-> (c,c'))
04:29:49 <osfameron> which I knew
04:30:00 <osfameron> but writing it as Arrow a   instead makes it more general?
04:30:11 <merijn> osfameron: Arrow is just a typeclass
04:30:18 <osfameron> what else is an Arrow then?
04:30:18 <merijn> Like Monad, Monoid, Eq, etc
04:30:30 <merijn> osfameron: If only I knew, last time I asked no one had any examples :p
04:30:40 <osfameron> hehe
04:30:54 <osfameron> a Map maybe?
04:31:03 <merijn> I think Iteratees/Enumerators might be arrows?
04:31:26 <merijn> But I don't fully understand those yet either :p
04:31:45 <osfameron> heh
04:32:04 * osfameron adds the Categories link above to instapaper
04:32:19 <osfameron> but I do like (&&&)
04:32:26 <fryguybob> @instances Arrow
04:32:27 <lambdabot> (->), Kleisli m
04:32:29 <osfameron> I wish it had a less general type, so it didn't confuse me as much when reading about it
04:32:52 <merijn> osfameron: Agreed
04:33:02 <aristid> @instances Category
04:33:03 <lambdabot> Couldn't find class `Category'. Try @instances-importing
04:33:04 <merijn> That goes for a lot of the more advanced type theory/category stuff, though
04:33:13 <merijn> It's so generic it becomes hard to see what's going on
04:33:13 <osfameron> (abstraction is all well and good, but not when it means you have to understand several more things in category theory when a) you have a simple requirement and b) your brain is already melting out of your ears ;-)
04:33:14 <aristid> @instances-importing Control.Category Category
04:33:15 <lambdabot> (->), Kleisli m
04:33:32 <aristid> but don't forget Cokleisli
04:33:46 <osfameron> aristid: I drink Pepsleisli myself
04:33:58 <merijn> I think I co-understand arrows >.>
04:33:59 <quicksilver> osfameron: the only other common arrow is the kleisli one, i.e. "a -> IO b"
04:34:18 <quicksilver> osfameron: but, I mean, that is an arrow from a to b (not from a to IO b - which is just the function one again!)
04:34:26 <osfameron> quicksilver: why isn't that just a function arrow itself?
04:34:31 <quicksilver> because of the IO.
04:34:45 <quicksilver> you can compose "a -> IO b" and "b -> IO c" to get "a -> IO c"
04:35:00 <aristid> newtype Kleisli m a = K (a -> m a)
04:35:01 <osfameron> you can do that anyway in a monad can't you?
04:35:06 <aristid> so Kleisli m is a Category
04:35:07 <quicksilver> osfameron: *EXACTLY*
04:35:25 <quicksilver> osfameron: it is precisely the fact that IO is a monad which makes a -> IO b an arrow.
04:35:38 <quicksilver> osfameron: kleisli arrows are the same thing as monads viewed from a different angle.
04:35:39 <aristid> Arrow is totally out of favor
04:36:31 <osfameron> quicksilver: pozorvlak has promised/threatened to give a Category theory talk to glasgow.pm soon.  I think I might trek up for that ;-)
04:44:40 <rostayob> @pl \userName -> Ix.getOne (userSet db @= UserNameIx userName)
04:44:40 <lambdabot> Ix.getOne . (userSet db @=) . UserNameIx
05:22:12 <elkng> do I have to install GHC before "Haskell Platform" ?
05:22:31 <Zao> elkng: Depends on OS.
05:22:35 <Zao> On Windows, it includes a GHC.
05:22:50 <elkng> *nix
05:23:01 <Zao> elkng: That means nothing.
05:23:09 <elkng> ok
05:23:19 <Zao> Please say what your real OS is, instead of a vague non-descript undefined term.
05:23:38 <balor> elkng, If you're on a Linux distro, there are normally packages available from your distro provider
05:24:00 <Zao> http://hackage.haskell.org/platform/linux.html <- oh look, instructions :D
05:24:26 <Zao> The tl;dr version is: if there's packages, the packages handle the dependencies.
05:24:31 <elkng> I want "Build from source"
05:24:33 <Zao> If there's no packages, you need a GHC to build/install the HP.
05:24:37 <Zao> Then you need a GHC.
05:24:45 <Zao> (in particular, 7.0.3 for the current HP)
05:25:55 <elkng> first, compile and install GHC, then compile and install "Haskell Platform" right ?
05:25:55 <ohwow> A combinator is a lambda expressions which has no free variables, right?
05:25:55 <elkng> dunno
05:26:32 <elkng> people arnt welcome nowadays
05:26:46 <ohwow> what?
05:26:57 <Eduard_Munteanu> Check what your distro provides, even if the HP website doesn't say anything about it.
05:27:22 <elkng> it provides SlackBuild's
05:27:35 <Eduard_Munteanu> In Gentoo, for example, GHC is normally available as a separate package.
05:27:47 <Eduard_Munteanu> (not as the platform)
05:36:16 --- topic: '["Paste code/errors: http://hpaste.org", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
05:36:16 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Mar 26 17:29:19 2011]
05:36:16 --- names: list (clog_ koninkje1away mundkur_ blackdog_ jamwt_ eZet- sipa_ DevHC_ kai_ gemelen_ drbean ivartj_ _bitbuck1t seats_ dilinger_ jix_ Igloo_ tew88_ stroan_ Entroacc1ptor ttblrs djanatyn_ CosmicRa` PhilRod_ edwtjo_ Bfv9000 applicative navaati pokkerface geheimdienst emacsenlee gbeshers elkng solidsnack tavelram noam Modius_ tibell_ mblomqvist Necrosporus flamingspinach Hunner pmetzger Ethan mxweas libertas kamatsu synonymous bens ccc BFG9000 tauntaun jem777 artefon)
05:36:16 --- names: list (Philippa siracusa papermachine owst Apocalisp hiptobecubic tensai_cirno barik fryguybob JimmyRcom Silvah eb4890 derdon phyrex1an gemelen Sunhay shepheb sepp2k MrFahrenheit owain ab3 alip Amadiro balphas ]OLI[ damg jrib lopex Argue maxJadi beastaugh cwkx Aune blueonyx arnihermann mun snearch hipertracker angel_de_vicente whald roconnor levitation[A] rtharper lanthan merijn helgikrs dimmy iratsu clanehin mceier nu11ptr DevHC jejansse Innominate Nightwolf)
05:36:16 --- names: list (idnar Eduard_Munteanu jeffz jeltsch ohwow magthe noonoooo gal_bolle seafood Vorpal rsuniev2 preflex Ornedan tomh djl m3ga jaspervdj solarus dct25 sjanssen eikke Fuco jlewis Volatile edon kaf3ii duosrx twn yottis Hugglesworth jamii Boxo frerich insomniaSalt dschoepe hackagebot Olathe balor azaq23 lsthemes cubi Palmik pacak alexsuraci tessier joe6 wtw em damex MaskRay shintah zul_netbsd astertronistic RayNbow`TU scm adrake tyler-iphone s76__ mmaruseacph2)
05:36:16 --- names: list (Jafet ablokzijl hzh_ ExtraSpice Locke1689 araujo kermit pi8027 Nisstyre otto_s_ SyntaxNinja Cobra zodiak kakos _Ray_ smarmy twobitsprite _bitbucket neurocyt` cwillu_at_work lowasser Quant alek_br ngochai ryant5000 novas0x2a|laptop moshee jsgf_ twofish luoq cloudhea2 dropdrive gienah theorbtwo Cale dankna nmodprime DasIch mimico alfa_y_omega_ stepkut eskimod jnj welterde adaptable Entroacceptor aiko miloshadzic Philonous albel727 ksf_ rostayob pingveno)
05:36:16 --- names: list (RSchulzM1 RSchulzB RSchulzM RSchulz caligula_ akosch_ Saizan erg0t mafs xinming mpiechotka ajhager wagle Nshag Optimo canvon Taggnostr3 Berengal barshirtcliff iFire` anonus Muad_Dibber ville ninegrid RobotCaleb derrotebaron stuartmackie gwern ChongLi lomeo obcode jon_of_arc kniu borism Younder metazilla ace2001ac MoALTz empity Kerris sunnavy kalivha dreixel ketil Anpheus__ wtetzner Bwild_ sohum TML smop sshc tommd shiduke Draconx andersk pantski [mth]_)
05:36:16 --- names: list (Astro thetallguy1 Zeiris_ Alan JaffaCake afarmer parcs osoleve integral EvanCarroll stepnem Jonno_FTW teratorn mrd klugez PeakerWork mikeg unfo- noddy Neronus_ Raku^ ivartj cyanoacry Zephyrus cheater99 edwardk chromakode CindyLinz vili milkpost aculich_ zax sajkr mlh tildedave Mitar mikmorg snr setmeaway waern_ hamishmack Paradox924X orbitz comex sShintah mjrosenb comak chrissbx ddarius exlevan Cthulhon| endojelly kai__ yell0 amiri jedai_ ortmage djanatyn)
05:36:16 --- names: list (dMazz jaj byorgey Igloo perlite anders^^ KaneTW SimonRC Zao Evious a11235 znutar RogueShadow przyszlem Vq dcolish FDFlock thetallguy dual mojavy McManiaC boris`` wto jbauman_ bs338 sonnym novas0x2a DrSyzygy mm_freak Adman65 JamesH__ almostsix astrolabe electrogeek ezyang ben ps-auxw mimi_vx arcatan thorkilnaur robinbb DustyDingo earthy vinc jix abojep hgolden arkx sanjoyd Nereid Guest56585 monochrom zwuwmad ormaaj Runar MK_FG elventear erikano gentx ousado)
05:36:16 --- names: list (tomaw alexsdutton CosmicRay wjt snorble CalJohn zong_sharo absentia trez dafrito Maxdamantus waern Khisanth elliottt dons rakete larsrh UniArch TheMoonMaster etabot milli tamiko zaphar_ps saati geekosaur ski dqd mauke flux ahf sipa OnionKnight pettter karld c3l dfeuer deavid bremner mjo qz dmwit sgronblo ahihi2 reacocard gerard0 JaredW companion_cube Botje hvr jyyou freedrull micahjohnston joeytwiddle adnam LeNsTR|off Draggor xplat wolverian Starfire `0660)
05:36:16 --- names: list (npouillard robinsmidsrod dogmaT hhulkko mornfall Gracenotes davean TeXitoi seats schroedinbug ccasin ivan whoops int-e neurogeek skaar bl4ck andrewsw_ xian zomg wunki zorzar jml kevinww szbalint kelvie ricky ray Tinned_Tuna slabanja_ stesh tengen_ nyingen shatly shachaf nihtml erk confound vav cjay Intensity Draconx|Laptop ReinH mercury^ BONUS jackhill traviscline Verge niko erenrich aristid Boney joni6128 ion liesen brisbin janne hammi Baughn hpc Martty)
05:36:16 --- names: list (nlogax tyfon joaopizani ian_mi brixen jrockway poucet Snufsen mietek quicksilver Totramon jayne snarkyboojum tew88 xenocryst erg nniro samferry eno __marius__ Dashkal guerrilla mux mundkur hiredman tromp_ c1de0x nominolo stroan lantti esg cynick Ke Arnar burp drhodes sbok psychouroboros tridactyla Derander chitragupt jd10 nnunley inetic ezrakilty dom96 davidL dino- nazgjunk srcerer StoneToad dixie Liskni_si lunaris dcoutts gseitz anssik taruti phrst)
05:36:16 --- names: list (rokoteko MasseR dionoea sordina noj xrl raek edenc [mth] PreciousMetals septomin clog ehamberg Bassetts tlk yahooooo rwbarton ibid jho freeformz tataa thoughtpolice pesco kaol Ferdirand cizra2 lpsmith osfameron ToRA Zol palmje tafryn birkenfeld marienz blackdog olsner inr bezik kosmikus flippo liyang ia0 Obfuscate etpace timchen1` Yahovah malorie savy dorkitude sutats ziman cibs MacCoaster jlouis Raynes politik david` zygoloid fabjan periodic Twey xarch)
05:36:16 --- names: list (ernst impl zenzike yrlnry Laney angstrom suiside Lemmih SonicvanaJr shutdown_-h_now hc smly- magicman Belgarion_ regalia oc And[y] luite tlockney willb1 DRMacIver duairc freiksenet bd_ agemo kalven Vulpyne dilinger faj tmuki flori mike1703 kamin PHO_ eZet jamwt Rooz Seta00 edwtjo copton koala_man Eliel geekounet eyck scree xinitrc koninkje_away ttblrs_ zakwilson inimino Veinor ixzkn saurik majoh ihckt_ emias Gunni felipe_ uber_mort domme djahandarie _soro_)
05:36:16 --- names: list (Jaak kloeri qebab ve BrianHV AnAdorableNick mattam mrshoe norm2782 _mpu cncl gdsx pastorn Aisling lambdabot hellige carrbs nornagon harlekin johs opqdonut_ Silex gereedy scsibug_ jcapper_ alpounet tumdum mortberg bqf KitB hyko _erik_ dumael moshisushi alios wires profmakx pr ido nimred udoprog saiam @ChanServ idoru aleator Nanar appamatto cathper jvogel Gilly)
05:36:37 <navaati> Alan: but RWS doesn't fit if you don't need Reader
05:36:38 <Eduard_Munteanu> Yeah, you also don't need to lift like in general monad transformers.
05:36:39 <elkng> what are the famous programms written in haskell ? just curious to see, what people wrote in haskell
05:37:14 <navaati> Eduard_Munteanu: with the typeclasses you don't need to lift as proper instances are already defined
05:37:14 <Eduard_Munteanu> elkng: http://www.haskell.org/haskellwiki/Applications_and_libraries
05:37:32 <Eduard_Munteanu> navaati: yeah, though only for R, W, S combos
05:37:32 <navaati> elkng: xmonad, darcs, or the prototype of Perl6, for example
05:38:00 <elkng> Games ! =)
05:38:05 <Eduard_Munteanu> Yup.
05:38:22 <elkng> I see
05:38:33 <navaati> @hoogle (MonadReader m r) => m r
05:38:33 <lambdabot> Control.Monad.Reader.Class ask :: MonadReader r m => m r
05:38:34 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
05:38:34 <lambdabot> Control.Monad.Reader.Class local :: MonadReader r m => (r -> r) -> m a -> m a
05:38:41 <navaati> ah, it's ask !
05:39:03 <navaati> :t runRWS $ ask >>= (\() -> return 'a')
05:39:04 <lambdabot> forall w s. (Monoid w) => () -> s -> (Char, s, w)
05:39:57 <xplat> :t runRWS $ ask >>= tell
05:39:57 <lambdabot> forall w s. (Monoid w) => w -> s -> ((), s, w)
05:41:01 <xplat> :t runRWS $ ask >>= forever . tell
05:41:02 <lambdabot> forall w s a. (Monoid w) => w -> s -> (a, s, w)
05:42:18 <xplat> > let (_,_,x) = runRWS $ ask >>= forever . tell "hello" () in x
05:42:18 <lambdabot>   Couldn't match expected type `a
05:42:19 <lambdabot>                                -> Control.M...
05:42:37 <xplat> > let (_,_,x) = runRWS (ask >>= forever . tell) "hello" () in x
05:42:39 <lambdabot>   "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohell...
05:44:12 <xplat> > let (_,_,x) = runRWS (forever $ ask >>= tell) "hello" () in x
05:44:13 <lambdabot>   "hellohellohellohellohellohellohellohellohellohellohellohellohellohellohell...
05:46:34 <xplat> > let (_,_,x) = runRWS (forever $ do { ask >>= tell; get >>= tell; modify (' ':) }) "hello" "" in x
05:46:35 <lambdabot>   "hellohello hello  hello   hello    hello     hello      hello       hello ...
05:49:35 <xplat> > intersperse "hello" $ "":inits (repeat " ") -- with less monads
05:49:36 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:49:37 <lambdabot>         against inferred type...
05:49:47 <xplat> > intersperse "hello" $ "":inits (repeat ' ') -- with less monads
05:49:48 <lambdabot>   ["","hello","","hello"," ","hello","  ","hello","   ","hello","    ","hello...
05:50:05 <xplat> er.
05:50:06 <navaati> > concat $ intersperse "hello" $ "":inits (repeat ' ') -- with less monads
05:50:07 <lambdabot>   "hellohello hello  hello   hello    hello     hello      hello       hello ...
05:50:29 <xplat> > intercalate "hello" $ "":inits (repeat ' ') -- i always mix those up
05:50:29 <lambdabot>   "hellohello hello  hello   hello    hello     hello      hello       hello ...
05:50:42 <navaati> :t intercalate
05:50:43 <lambdabot> forall a. [a] -> [[a]] -> [a]
05:57:31 <navaati> :t inits
05:57:31 <lambdabot> forall a. [a] -> [[a]]
05:57:38 <navaati> inits "lolilol"
05:57:45 <navaati> > inits "lolilol"
05:57:46 <lambdabot>   ["","l","lo","lol","loli","lolil","lolilo","lolilol"]
05:58:19 <navaati> > inits $ repeat 'a'
05:58:20 <lambdabot>   ["","a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa"...
06:05:48 <navaati> i've got this http://hpaste.org/46101/ttgvtgvtdgsv
06:06:31 <balor> If ":type (rank x)" is "Maybe Int" why is "((rank x)/= Nothing)" not a valid boolean condition for filter?
06:06:47 <navaati> and I don't understand why it makes me these nc6 and nc7 : the nc type variable should be the same everywhere
06:07:17 <merijn> balor: Full error + code?
06:07:31 <hpc> balor: perhaps you are passing a Bool where it wants a -> Bool
06:07:49 <navaati> merijn: there are 23 errors -_-
06:08:34 <balor> merijn, http://hpaste.org/46102/an_error
06:08:46 * hackagebot uuid 1.2.2 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.2 (AntoineLatter)
06:09:09 <hpc> balor: rank :: Foot -> Maybe Int?
06:09:16 <navaati> code is here : http://hpaste.org/46103/csucksfullcode
06:10:01 <hpc> balor: (rank x /= Nothing) :: Bool; Set.filter wants to see something of type (Foot -> Bool)
06:10:09 <balor> hpc, yeah
06:10:25 <hpc> balor: so replace (rank x /= Nothing) with (\x -> rank x /= Nothing)
06:10:38 <merijn> @pl \x -> rank x /= Nothing
06:10:38 <lambdabot> (Nothing /=) . rank
06:10:47 <merijn> There you go :p
06:11:07 <hpc> the clarity here outweighs the terseness of pointless style :P
06:11:22 <balor> hpc, merijn: thanks
06:12:16 <hpc> balor: in general, the type error "Couldn't match expected type `Foo' with actual type `Bar'" means exactly what it says
06:12:31 <hpc> balor: it thought it was going to get something of type Foo, but got Bar instead
06:13:09 <hpc> also, nice computer name :P
06:16:47 * hackagebot uuid-quasi 0.1 - Supplemental package for 'uuid' allowing quasiquotation.  http://hackage.haskell.org/package/uuid-quasi-0.1 (LarsPetersen)
06:27:22 <da-x> ghc 7.0.3-x86-64 doing 'cabal install glib' - and it breaks, is only for me? how to fix it? http://hpaste.org/46115/glib_broken
06:28:00 <dcoutts> da-x: see the #warning. What is says there is the issue.
06:28:39 <dcoutts> tip of the day: read error messages, they're sometimes useful!
06:28:52 <merijn> dcoutts: Crazy talk!
06:29:11 <dcoutts> yeah, controversial
06:29:30 <merijn> dcoutts: Next you'll tell me not to disable warnings or use unsafe*
06:29:39 <Igloo_> I feel compelled to point out that it isn't an error message
06:30:19 <merijn> Warnings are errors!
06:30:44 <dcoutts> merijn: now that is just crazy talk
06:33:49 * hackagebot yesod-auth 0.4.0.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.4.0.1 (MichaelSnoyman)
06:34:03 <rostayob> @pl \user -> @= UserNameIx user
06:34:03 <lambdabot> (line 1, column 10):
06:34:03 <lambdabot> unexpected "@"
06:34:03 <lambdabot> expecting lambda abstraction or expression
06:34:15 <rostayob> @pl \user -> (@= UserNameIx user)
06:34:16 <lambdabot> flip (@=) . UserNameIx
06:38:32 <ketil> merijn: if warnings are errors, why not just disable them?
06:38:43 * ketil would like to disable errors in his programs.
06:39:48 <navaati> with associated type synonyms, if there is a type family "TypeFunc a", does t1 = t2 implies that (TypeFunc t1) = (TypeFunc t2) ?
06:41:43 <hpc> navaati: yes
06:41:53 <hpc> navaati: for all f, x, y where x = y, f x = f y
06:43:22 <navaati> so how it is possible to have this ?
06:43:24 <navaati> http://hpaste.org/46101/ttgvtgvtdgsv
06:44:21 <hpc> navaati: i don't even know what those type classes are
06:44:43 <hpc> oh, type families
06:44:55 <hpc> i don't know type families at all
06:45:04 <navaati> ah
06:45:09 * hpc thought it was just a plain constructor
06:45:25 <quicksilver> navaati: because type functions are not injective
06:45:36 <quicksilver> you can't deduce "nc6" from "ReqAddr nc6"
06:45:54 <quicksilver> two different types "a" and "b" might be such that "ReqAddr a" is the same type as "ReqAddr b"
06:46:16 <quicksilver> associated data (different from associated type synonym) is injective by construction but requires you to create fresh types.
06:46:19 <da-x> dcoutts: I've read the warning, but thought it wasn't related to the error that followed. you know why? because usually when I run 'cabal install' on commonly used packages, I get warnings here and there but it builds successfully. I'd take this educated guess...okay, so --ghc-option='-DCABAL_VERSION_MINOR=8'  fixed it. The warning could have been clearer, though...
06:46:23 <quicksilver> although they can be newtype wrappers.
06:47:02 <dcoutts> da-x: in this case the warning comes from the authors of the package in question
06:48:37 <navaati> quicksilver: but i have (NativeCode nc, Parameters nc v, Parameters nc w), so nc must be the same everywhere, no ?
06:48:39 <da-x> now, the next problem, gtk2hs-buildtools, when you get 'process-1.0.1.5-cfd9f7c6398d9518b5b3479ef3f4488f is shadowed by package process-1.0.1.5-55dfaccf3a91c4cb8f6284a0bafef198' what the preferred way to tackle this (btw this is frustrating - this is *after* I zeroed my .ghc and .cabal directories today...)
06:48:52 * hackagebot zampolit 0.2 - A tool for checking how much work is done on group projects.  http://hackage.haskell.org/package/zampolit-0.2 (BrianSniffen)
06:48:54 * hackagebot acid-state 0.4.1 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.4.1 (DavidHimmelstrup)
06:49:34 <dcoutts> da-x: the solution is to eliminate the duplicate and then when you install things to check with --dry-run first
06:51:11 <da-x> dcoutts: yeah, ghc-pkg list shows I indeed have two process-1.0.1.5. Mini-mini-miny-mo...
06:51:32 <dcoutts> da-x: remove the one in the user package db, keep the global one
06:51:39 <dcoutts> ie don't use sudo :-)
06:52:45 <da-x> dcoutts: and 'ghc-pkg unregister process-1.0.1.5' knows which one to remove? it complaines that I'd break cabal among others..
06:53:11 <da-x> ahh, --user
06:53:13 <dcoutts> da-x: use ghc-pkg --user to be explicit
06:54:54 <da-x> now a general question
06:56:31 <quicksilver> navaati: your paste contained nothing like enough context for me to answer that. Even if it did, I'm afraid I don't have time :(
06:56:33 <da-x> when authors publish packages on hackage, why isn't there a daemon on that server that automatically validates all dependencies of all hackage packages, ensuring proper dependencies across all packages at all times?
06:57:10 <hpc> da-x: it wouldn't be perfect
06:57:20 <hpc> and might even be wrong at times
06:57:36 <nihtml> @pl  foldr (const (+1)) 0
06:57:36 <lambdabot> foldr (const (1 +)) 0
06:57:36 <kosmikus> da-x: what do you mean, "validate"? it already tries building it.
06:57:38 <hpc> it could be interesting though
06:57:42 <nihtml> @pf  foldr (const (+1)) 0
06:57:43 <lambdabot> Maybe you meant: bf pl
06:57:47 <nihtml> @bf  foldr (const (+1)) 0
06:57:47 <lambdabot>  Done.
06:57:55 <hpc> nihtml: it's already pointfree
06:58:05 <hpc> @unpl foldr (const (+1)) 0
06:58:05 <lambdabot> foldr (\ _ b -> b + 1) 0
06:58:31 <navaati> quicksilver: associated datatypes worked, but they are also more annoying to use
06:58:37 <hpc> isn't that (+1) . last?
06:58:37 <quicksilver> navaati: yes.
06:58:49 <da-x> okay, I'm not familiar at all with the hackage publishing process
06:58:55 <hpc> > foldr (const (+1)) 0
06:58:56 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> a1)
06:58:56 <lambdabot>    arising from a use o...
06:59:02 <navaati> the full code is here, you mightwant to see the definition of NativeCode : http://hpaste.org/46103/csucksfullcode
06:59:04 <hpc> > foldr (const (+1)) 0 [1..10]
06:59:05 <lambdabot>   10
06:59:12 <hpc> > [1..10]
06:59:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
06:59:15 <hpc> huh
07:00:03 <da-x> okay - only problem with glib now is that it depends on the '--user' version of cabal that depends on the process-1.0.1.5 that I've unregistered. http://hpaste.org/46117/glib
07:00:41 <dcoutts> da-x: so that package has to be rebuilt
07:01:20 <dcoutts> and this is where you use --dry-run to check it will not rebuild the process lib or any other core libs
07:01:54 <quicksilver> navaati: well, as I said, I don't have time :( hopefully someone else does.
07:02:34 <navaati> quicksilver: thank you anyway for the datatype solution :)
07:04:55 <Saizan> navaati: the supplier method of NativeCode can't be used, because the typeclass parameter 'nc' appears only as an argument to a type family in its type
07:06:22 <navaati> Saizan: so it's ambiguous… damn you are right, it seems that i'm stuck with datatypes
07:06:57 <Saizan> navaati: sicne type families are not necessarily injective ghc can't deduce nc1 ~ nc2 from ReqAddr nc1 ~ ReqAddr nc2, so there's no way for it to figure out which nc you want when you use it
07:07:18 <da-x> problem magically fixed after I removed the .conf files of the packages I've unregistered from my .ghc/x86_64-linux-7.0.3/package.conf.d/ dir.
07:07:22 <Saizan> (if we had explicit instantiation instead..)
07:08:07 <Saizan> da-x: were those owned by root, or something like that?
07:08:39 <da-x> nope
07:08:54 <dcoutts> da-x: you should use ghc-pkg unregister rather than fiddling with the files directly
07:09:06 <da-x> dcoutts: makes sense
07:09:13 <dcoutts> there's a cache that has to be kept in sync
07:10:32 * Saizan thought he had ghc-pkg unregister'ed them and then also had to remove the files directly
07:14:09 <sm> morning all. When building a -fhpc binary I use -outputdir to keep the .o files separate. I should do the same with -prof binaries, right ?
07:15:11 <sm> (when doing non-cabal builds)
07:25:50 <gal_bolle> hi all, is there a function for creating a temporary directory, à la openTempFile (or alternatively, an openTempFile that returns the name but does not create the file)
07:31:03 <waern_> gal_bolle: I don't think there's such a standard function. no
07:33:03 <mekeor> is there a function :: Eq a => Integer -> [a] -> [[a]]
07:33:04 <mekeor> e.g. such that "f 2 [1..10] == [[1,3,5,7,9],[2,4,6,8]" — ?
07:33:13 <sm> gal_bolle: http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:getTemporaryDirectory
07:33:16 <mekeor> * "]"
07:33:43 <sm> also http://hackage.haskell.org/package/temporary
07:34:17 <navaati> @hoogle Eq a => Integer -> [a] -> [[a]]
07:34:17 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
07:34:17 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
07:34:17 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
07:34:54 <mekeor> navaati: that means "no"??
07:36:19 <navaati> mekeor: I think the right type for your function is Eq a => Integer -> [a] -> ([a],[a])
07:36:19 <navaati> and i don't think it exists in base, but it souldn't be so hard to write
07:36:25 <azaq23> > partition (\x -> x % 2 == 0) [1 .. 10]
07:36:26 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
07:36:35 <navaati> :t partition
07:36:35 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:36:52 <azaq23> > partition (\x -> x `mod` 2 == 0) [1 .. 10]
07:36:53 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
07:37:30 <mekeor> well azaq23, a is not neccessarily an integer :( — its just in "Eq" …
07:37:55 <mekeor> > partition (\x -> x `mod` 2 == 0) [1 .. 10]
07:37:56 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
07:38:00 <mekeor> > partition (\x -> x `mod` 2) [1 .. 10]
07:38:01 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
07:38:01 <lambdabot>    arising from a use of ...
07:38:15 <navaati> :t \n -> partition (\x -> x `mod` n == 0) [1 .. 10]
07:38:15 <lambdabot> forall a. (Integral a) => a -> ([a], [a])
07:38:42 <navaati> :t \n l -> partition (\x -> x `mod` n == 0) l
07:38:43 <lambdabot> forall a. (Integral a) => a -> [a] -> ([a], [a])
07:38:44 <azaq23> oh, you don't want to part into even and odd but only get every second element, didn't say that
07:38:51 <azaq23> *saw
07:39:01 <mekeor> azaq23: sry about that :(
07:39:27 <navaati> yeah, i was thinking the same as azaq23 ^^
07:40:10 <mekeor> thanks anyway
07:40:23 <navaati> mekeor: could you give an example in which the result list contains more than 2 lists ?
07:41:36 <azaq23> try something using partition / search for stuff like partition (should be basically the same type signature) and zip
07:41:47 <elkng> what the best book for learning haskell for beginners ?
07:42:08 <Zao> Give LYAH a try?
07:47:34 <mustmovies> 04hello ppl check out our new blog about MUST SEE UPCOMING MOVIES -> > >   http://mustsee-newmovies.blogspot.com/  < < <-  (help us improve by visiting the blog + clicking some advertisment) thanks a lot :D
07:48:00 <opqdonut_> @ops
07:48:01 <lambdabot> Maybe you meant: docs oeis pl
07:48:05 <opqdonut_> gah
07:48:16 <elkng> mustmovies: red is sucks
07:49:07 --- mode: ChanServ set +o shapr
07:49:13 --- kick: mustmovies was kicked by shapr (Kicked by shapr)
07:50:13 <Kerris> I'm trying to load a file into ghci, it tells me "stdm.lhs:1160:14: Parse error in pattern: n + 1"
07:50:36 <Kerris> http://hpaste.org/46120/software_tools_for_discrete_ma
07:51:04 <navaati> Kerris: n+k patterns are ugly…
07:51:12 <Kerris> navaati: It's from http://www.dcs.gla.ac.uk/~jtod/discrete-mathematics/
07:51:33 <Kerris> I discovered that I bought the book on Kindle awhile ago, maybe when I was drinking heavily around New Year.
07:51:50 <Silvah> Kerris: n+k patterns aren't well-formed Haskell anymore, IIRC.
07:51:51 <Kerris> oops, said too much. don't mind me, I don't drink and Haskell
07:52:01 <navaati> :D maybe you need to enable an extension
07:52:24 <Kerris> oh boy, how would I find out which extension to enable?
07:52:54 <Kerris> what's the graceful way to quit ghci again, I keep going back to ^D
07:53:17 <shapr> Kerris: :q
07:53:20 <shapr> Kerris: or :quit
07:53:27 <Kerris> thanks
07:53:34 <azaq23> ^D seems to work just fine, it even prints "Leaving GHCI."
07:53:49 <Silvah> Kerris: change the code so it doesn't use n+k patterns anymore?
07:54:16 <Silvah> Huh, GHC documentation says that n+k patterns are enabled by default.
07:54:31 <Kerris> Silvah: I'm just a little nooblet starting to learn
07:54:54 <Kerris> it does look like something I could copy and paste from LYAH
07:55:09 <navaati> Haskell 2010 adds the Foreign Function Interface (FFI) to Haskell,  allowing for bindings to other programming languages, fixes some syntax  issues (changes in the formal grammar) and bans so-called  "n-plus-k-patterns",
07:55:14 <navaati> from wikipedia
07:55:37 <navaati> try to enable "NPlusKPatterns"
07:58:56 <Olathe> Are there any libraries to control the mouse and read the screen?
07:59:36 <Olathe> Need to do some automation.
08:00:05 <Kerris> navaati: googling "enable NPlusKPatterns" doesn't give me what I'm looking for :(
08:00:10 <Silvah> Kerris: {-# LANGUAGE NPlusKPatterns #-}
08:00:49 <Kerris> Silvah: do I just eval that in ghci?
08:01:36 <Kerris> I did and reloaded stdm.lhs, still gave me that error.
08:01:56 <Kerris> next, quit ghci, appended that to the file, restarted ghci and loaded file, still gave error
08:02:03 <Silvah> Kerris: You have to put that on the top of the source file.
08:02:08 <mauke> s/ap/pre/
08:02:53 <navaati> Olathe: the XLib ?
08:03:03 <Kerris> oops, meant to say prepend
08:03:08 <Kerris> yeah, still gives me that error
08:03:13 <Kerris> Should I just try hugs instead?
08:03:47 <Silvah> Kerris: works for me.
08:03:58 <mauke> you may need >
08:04:44 <Kerris> mauke: thank you very much :-D
08:04:52 <Kerris> thank you too Silvah
08:06:19 <Silvah> Oh, so it was a literal Haskell source?
08:06:20 <mm_freak> Olathe: haskell is per se not connected to any graphics system, so you will want to choose one of the portable libraries to do that
08:06:25 <mm_freak> Olathe: for example SDL
08:06:51 <mm_freak> it has good haskell bindings
08:06:51 <mauke> <Kerris> I'm trying to load a file into ghci, it tells me "stdm.lhs
08:08:03 <Silvah> s/literal/literate/
08:12:47 <Alan> ... you've got to be kidding me...
08:12:57 <Alan> you can do [2,4..] to get even numbers?
08:13:16 <Olathe> Thanks for the info :)
08:13:19 <Alan> crazy
08:13:35 <Olathe> Alan: Yeah, and [2, 4..8]
08:14:43 <Axman6> Alan: [..] syntax is just rewritten to enumFrom, enumFromTo and enumFromThenTo
08:14:55 <Axman6> > enumFromTehnTo 2 4 8
08:14:56 <lambdabot>   Not in scope: `enumFromTehnTo'
08:15:00 <Axman6> > enumFromThenTo 2 4 8
08:15:01 <lambdabot>   [2,4,6,8]
08:15:45 <SoleSoul> enumFromThenTo 2 4 8
08:15:46 <Alan> > enumFromThenTo 2 4 7
08:15:47 <lambdabot>   [2,4,6]
08:15:57 <SoleSoul> > enumFromThenTo 2 4 8
08:15:58 <Alan> interesting
08:15:59 <lambdabot>   [2,4,6,8]
08:16:10 <SoleSoul> > enumFromThenTo 2 10 100
08:16:11 <lambdabot>   [2,10,18,26,34,42,50,58,66,74,82,90,98]
08:16:49 <SoleSoul> > enumFromThenTo 2 10.1 50
08:16:50 <lambdabot>   [2.0,10.1,18.2,26.299999999999997,34.39999999999999,42.499999999999986,50.5...
08:17:54 <SoleSoul> don't use it on floats
08:18:05 <byorgey> Every time you use Enum with floating point numbers a kitten dies.
08:18:18 <Alan> which is the better way, between "array (i1, i2) [(i, 0) | i <- [i1..i2]]" and "listArray (i1, i2) (repeat 0)" ?
08:18:33 <Alan> > listArray (0, 5) (repeat 0)
08:18:34 <lambdabot>   array (0,5) [(0,0),(1,0),(2,0),(3,0),(4,0),(5,0)]
08:18:48 <byorgey> Alan: I'd use the second.  Why bother giving a name to the index i?
08:18:55 <Alan> hmm, yeah
08:19:43 <byorgey> the second one is easier to read, too: "an array full of zeros".
08:19:52 <Alan> yeah
08:20:06 <Alan> I think to start with I didn't know if it was equivalent or not
08:20:35 <Alan> hmm, that reminds me...
08:20:39 <byorgey> sure, one must be careful of course, but yes, they are equivalent.
08:20:52 <Alan> > listArray (0, -1) (repeat 0)
08:20:54 <lambdabot>   array (0,-1) []
08:21:04 <Alan> good, that is valid
08:21:11 <Alan> a bit bizarre
08:21:19 <Alan> but the only way to get an "empty" array?
08:21:35 <Olathe> @pl [1, 2..10]
08:21:35 <lambdabot> [1,2..10]
08:21:40 <Olathe> Hmm...
08:22:11 <byorgey> Alan: yes, I suppose so
08:22:21 <byorgey> seems reasonable as a "degenerate" case
08:22:39 <Olathe> @unpl \a b c -> [a, b..c]
08:22:39 <lambdabot> \ a b c -> [a, b .. c]
08:22:43 <Olathe> @pl \a b c -> [a, b..c]
08:22:44 <lambdabot> enumFromThenTo
08:22:47 <Olathe> Ahh, there :)
08:23:12 <Olathe> Ahh, there :)
08:23:50 <osfameron> @hoogle Enum a => a -> a -> a -> [a]
08:23:50 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
08:23:51 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
08:23:51 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:24:06 <osfameron> I'm impressed that @pl knew that
08:25:18 <Alan> byorgey: well I have a stack of arrays, each of different sizes, sometimes n=0
08:25:32 <byorgey> Alan: sure, that makes sense
08:26:07 <parcs> i don't think @pl knows that but rather the interface it uses to parse the expression converts list comprehensions to their corresponding functional equivalents before @pl touches it
08:26:59 <Silvah> @unpl enumFromThenTo
08:26:59 <lambdabot> enumFromThenTo
08:29:38 <ben> o_o
08:30:33 <whald> hmm, anyone successfully used the random-shuffle package? for me it gives System/Random/Shuffle.hs:(66,7)-(79,49): Non-exhaustive patterns in function extractTree, which is less perfect than i expected
08:31:01 <azaq23> [a, b .. c] is not a list comprehension
08:34:19 <parcs> yeah my bad
08:34:38 <aristid> whald: you need to use it correctly. it's a bit evil :)
08:36:47 <whald> aristid: "correctly" is a bit difficult given the documentation: http://hackage.haskell.org/packages/archive/random-shuffle/0.0.2/doc/html/System-Random-Shuffle.html :-)
08:37:14 <aristid> whald: use shuffle'. and the Int has to be the length of the list.
08:38:43 <whald> aristid: shuffle' is a bit problematic, but i think i see the problem now, i provide out-of-range values in the second parameter to sample
08:39:37 <aristid> why is shuffle' problematic?
08:40:56 <whald> aristid: i need a randomgen, but then, i can seed it with the ints a was previously stuffing into shuffle
08:41:17 <whald> aristid: probably that's really better, thanks
08:41:41 <aristid> :t getStdRandomGen
08:41:42 <lambdabot> Not in scope: `getStdRandomGen'
08:42:12 <whald> aristid: i'm not in IO
08:42:32 <aristid> well you need to get your random number generator from somewhere
08:42:49 <aristid> the function is also getStdGen
08:43:02 <whald> aristid: i have one, but it's mwc-random which does not supply an RandomGen instance
08:43:15 <aristid> whald: consider using random-fu.
08:43:27 <aristid> it has an interface to mwc-random, and is pure
08:43:37 <aristid> it also has a nicer to use adaptation of shuffle
08:44:42 <osfameron> is there a Monad for actions that might succeed but with warnings?
08:45:00 <osfameron> i.e. like Either, but where you can have the Left part at the same time as success
08:45:06 <osfameron> oh, I guess that's State
08:45:17 <whald> aristid: random-fu seems to offer a lot.. i'll check it out
08:45:30 <osfameron> well, the action might fail entirely, so some bastard offspring of State and Either
08:46:50 <aristid> osfameron: Writer can be used to log warnings
08:47:43 <osfameron> aristid: ah, good point. How would I *also* get the Maybe-like semantics, if I want to error rather than just warn?
08:47:48 <osfameron> is that what transformers do?
08:49:10 <ceii> osfameron, yes, what you want is probably ErrorT YourErrorType (Writer YourWarningType)
08:50:03 <osfameron> ceii: ohhh, ErrorT?  I've not come across the Error monad yet (only Maybe/Either/a bit of IO error stuff)  is that documented in RWH for example?
08:50:04 <ceii> in this order you can access the warnings on the way to an error, in the other order they'd be forgotten if an error occurs
08:51:14 <ceii> osfameron, no idea if it's in RWH. But it's a simple generalisation of Either.
08:51:30 <ceii> Look at the documentation from the transformers package
08:51:33 <osfameron> the monad textbook I've followed most closely so far is LYAH, which doesn't get as far as transformers
08:52:32 <whald> osfameron: i can really recommend the chapter from real-world-haskell
08:52:44 <osfameron> ceii: http://hackage.haskell.org/package/transformers-0.1.4.0 ?
08:52:46 <whald> osfameron: bought the book after reading it
08:53:32 <osfameron> whald: ah cool.  I bought it ages ago, didn't really read it, now have "upgraded" to the ebook version, and have worked through much more of it ;-)
08:53:39 <osfameron> (but not as far as transformers)
08:54:17 <ceii> osfameron: yes. There are also other monad transformer libraries, but they all have mostly the same interface.
08:54:44 <osfameron> ceii: I find the haskell docs very tricky to read... http://hackage.haskell.org/packages/archive/transformers/0.1.4.0/doc/html/Control-Monad-Trans-Error.html doesn't give an *example* usage even
08:54:55 <whald> osfameron: i also read it online, but then i just thought "they deserve the money" :-) the chapter on transformers is really good and easy to get
08:55:46 <osfameron> whald: yeah, I meant to read during the beta process, but didn't get around to it.  I got it from the O'Reilly user-group discount programme (from a Perl conference, natch)
08:56:01 <whald> osfameron: :-
08:56:06 <whald> osfameron: :-)
08:56:16 <osfameron> aha! http://hackage.haskell.org/packages/archive/transformers/0.1.4.0/doc/html/Control-Monad-Trans.html has some examples
08:56:30 <osfameron> oh, only 2.  But still.
08:57:33 <pmetzger> when I load a file I'm working on in ghci, it informs me that only main is visible to me (presumably because it is the only thing the main module exports). How can I ask it to let me do things like :t'ing ALL the functions in the file?
08:57:39 <pmetzger> do I have to use something other than :load?
08:59:04 <ceii> pmetzger: :load should put even private definitions in scope, as long as you load a testual source file.
08:59:18 <ceii> It won't work if you load a compiled file though
08:59:27 <ceii> textual*
08:59:56 <quicksilver> under some circumstances it will laod the compiled file if that exists
09:00:09 <Saizan> you can use :load *module.hs to make sure it brings everything into scope
09:01:16 <pmetzger> what does the * mean? does it mean "load the text" or does it mean "load all symbols"?
09:02:01 <Saizan> probably the former
09:03:22 <monochrom> * means expose module internals, this includes what it imports
09:03:35 <pmetzger> cool, thanks.
09:03:56 <KirinDave> I wish there was some good documentation on how to put together the core of a medium-sized haskell program
09:04:02 <monochrom> compulsory reading http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope
09:04:02 <ceii> pmetzger, I don't think GHC compiled modules have a notion of "all symbols"
09:04:16 <KirinDave> Like what strategies to take, how to make decisions on what kind of monads to use, should you use transformers or not?
09:04:27 <gwern> KirinDave: that sounds rather domain specific
09:04:34 <KirinDave> gwern: Really?
09:04:43 <pmetzger> ceii: well, regardless, it did work...
09:04:47 <KirinDave> Because it seems like every non-trivial application needs those decisions? 
09:05:04 <gwern> KirinDave: if there were such things - design patterns we might call them - that could generalize over all domains...
09:05:05 <pmetzger> monochrom: thanks a lot!
09:05:18 <pmetzger> monochrom: that's indeed a really useful thing to read
09:05:32 <monochrom> it works because explicit ":load *" says ignore the compiled code, go back to interpreted mode
09:05:40 <KirinDave> gwern: I'm not asking for some sort of algorithmic process for arbitrary computation here. :) 
09:05:53 <KirinDave> gwern: As a Haskell newb I'm not even familiar with the tradeoffs between the various choices.
09:05:58 <monochrom> if you have installed ghc, you have a copy of it on your disk too
09:06:01 <KirinDave> gwern: Every passage leaving this room is unlit.
09:06:42 <gwern> KirinDave: well, you see my point hopefully. what's idiomatic and best for XML processing will be structured way differently from what is best for the xmonad internals. any tutorial that covered them equally well is so hugely general it speaks to a langauge or design failing
09:07:04 <monochrom> people spend lifetimes browsing petabytes of the web outside, and not one minute browsing merely gigabytes of their own disks
09:07:08 <gwern> a C tutorial on avoiding memory leaks can be general to pretty much every domain you use C, to give an example
09:07:24 <merijn> KirinDave: There is no magic bullet. When to use what depends on what you are doing
09:07:27 <gwern> monochrom: comparative advantage. google is so much better browsing those petabytes than people are browsing those gigabytes
09:07:30 <KirinDave> merijn: Right
09:07:40 <KirinDave> merijn: But I don't even have the cost factors for the various tradeoffs
09:07:41 <ceii> KirinDave, I have a feeling that what you're looking for is Real World Haskell
09:07:44 <monochrom> download google desktop to bring that to your own disk
09:07:45 <pmetzger> spotlight on macs is pretty fast.
09:07:47 <KirinDave> ceii: Nope
09:07:47 <ceii> have you read it?
09:07:49 <KirinDave> Yes I have.
09:07:52 <monochrom> there is no longer any excuse
09:08:00 * osfameron thinks KirinDave has a point... oh, but yes, RWH is probably full of that kind of thing, yeah
09:08:07 <KirinDave> It's not full of that kind of thing.
09:08:18 <merijn> KirinDave: My approach is "start coding, after a while, look at what I wrote, if it looks like it could be cleaner, rewrite/refactor until it's clean enough"
09:08:21 <osfameron> are the examples too big?  too small?
09:08:24 <merijn> Repeat until satisfied
09:08:37 <monochrom> KirinDave: Jackson structured design is still relevant today and particularly suitable to functional programming
09:08:45 <KirinDave> merijn: So it's impossible to talk about WHY one might choose a custom monad versus stacked transformers?
09:09:02 <KirinDave> It's impossible to talk about pitfalls one might associate with the various practices?
09:09:07 <ceii> It's possible, but it's domain specific
09:09:13 <merijn> KirinDave: My universal room of thumb for all code in all languages is "which looks cleaner?"
09:09:14 <KirinDave> That's pretty shitty if that's the case.
09:09:19 <ceii> why do you think design equals monads in Haskell?
09:09:29 <osfameron> KirinDave: that doesn't sound like the question you asked before
09:09:30 <KirinDave> ceii: I don't
09:09:41 <osfameron> KirinDave: which was about how to go about designing a medium-size program, iirc
09:09:55 <KirinDave> osfameron: Actually it's exactly what I asked before. I wish there was discussion on the subject of a medium sized program and the decisions you can make.
09:10:06 <newbieee> hello, I can't figure out why this don't compile :( http://pastebin.com/8v9isp8X
09:10:09 <KirinDave> Pure code doesn't need much in the way of assistance, most functional languages make this very clear.
09:10:14 <edwardk> @tell ksf_ not likely ;)
09:10:14 <lambdabot> Consider it noted.
09:10:22 <newbieee> if anyone can give some help
09:10:26 <merijn> KirinDave: What is your approach in languages other then Haskell?
09:10:26 <newbieee> it's short
09:10:27 <monochrom> stack-up-monads vs monolithic-monad is merely optimization
09:10:30 <newbieee> thanks in advance
09:10:48 <KirinDave> monochrom: Oh?
09:11:10 <ceii> newbieee, what error do you get?
09:11:28 <KirinDave> merijn: Because you don't need to braid your program around IO in other languages, I suspect you need to plan ahead a little less in, say, Scala.
09:11:30 <newbieee>  parse error on input `drawO'
09:11:33 <pmetzger> newbieee: the compiler is probably telling you why it doesn't compile if you read the error messages.
09:11:43 <newbieee> sadly, not more than this
09:11:46 <merijn> KirinDave: Yes you do
09:11:47 <pmetzger> what line does it say that is on
09:11:54 <newbieee> only  "parse error on input `drawO'"
09:11:56 <pmetzger> newbieee: it is telling you more, it is pointing to a character.
09:12:04 <newbieee> line 12
09:12:04 <pmetzger> newbieee: at least if you are using ghc
09:12:08 <newbieee> on what  Ipaste
09:12:11 <pmetzger> so what is on line 12?
09:12:11 <newbieee> on what I paste
09:12:23 <merijn> KirinDave: If you do networking or web programming all event driven frameworks essentially have you braid your program around IO
09:12:23 <ceii> actually I see two problems: your if expression lacks an else, and rhe indentation in your do block is borked
09:12:29 <newbieee> it's the first line of the deinition of draw0
09:12:40 <pmetzger> and more to the point, what is on line 11?
09:12:57 <newbieee> definition or structure map
09:12:57 <merijn> KirinDave: The same for C systems coding, because IO tends to fail and you need to structure around that.
09:12:59 <KirinDave> merijn: IO is everywhere in, say, Scala. THere is no difference between IO a and a
09:13:01 <pmetzger> his indentation is bizarre and there is no else
09:13:09 <newbieee> ok, thanks very much
09:13:19 <newbieee> I'll start by looking for the else
09:13:24 <KirinDave> merijn: Yes. So now we're getting somewhere.
09:13:46 <KirinDave> merijn: What are some of the practical patterns people use in haskell for that sort of work?
09:14:06 <KirinDave> Let's take your C example... those techniques are fairly general.
09:14:23 <KirinDave> You need to watch your results for NULL or -1 or whatever your error value is.
09:15:04 <KirinDave> These sorts of checks take one of 2 standard forms, either inline conditional or the approach popularized by the Network Programming book, which is Capitalized versions of methods that handle some of these problems internally. 
09:15:40 <merijn> KirinDave: Well, what sort of stuff are you writing? Is it a server (with like a main loop)? Or something like command line tools which just perform a sequence of things?
09:15:57 <KirinDave> merijn: Let's say it's a server, that seems like a nice non-trivial case.
09:16:16 <KirinDave> A command line tool performing a sequence of things probably has a shorter lifespan and is smaller, so it's easier to track.
09:17:53 <merijn> KirinDave: Well, a main loop would in theory just be a function which does "block for new connection, spawn of thread to handle new connection, call itself" i.e. infinite recursive loop. Then the thread you spawn would be an IO thing again which handles sequential stuff for that connection.
09:19:16 <merijn> KirinDave: If you don't have a strictly sequential handler that gets spawned, spawn a thread per concrete task and have them exchange events over Chan's like you would write any other message passing concurrent system
09:19:23 <Mkman> Hey!
09:21:54 <merijn> KirinDave: Essentially start at an extremely high level and keep decomposing until you have pieces you know how to implement
09:22:23 <KirinDave> merijn: Maybe I just need to find some examples.
09:23:35 <merijn> KirinDave: Maybe browse hackage/github for examples and look at the code?
09:29:42 <McManiaC> hey emacs users - how do I change my pwd for the C-c C-l command (ghci)?
09:30:19 <McManiaC> Prelude> :cd c:/Users/nils/dev/npaste.de/
09:30:22 <McManiaC> Prelude> :load "src/NPaste/Types.hs"
09:30:29 <McManiaC> that 'cd' should be somewhere else
09:30:30 <McManiaC> :>
09:30:40 <McManiaC> (in that src folder)
09:30:49 <monochrom> KirinDave: to a large extent, "go with your heart" is a sufficient guideline. this works for haskell because inelegance in haskell code tends to stand out (several reasons: terse syntax, elegant syntax, more abstraction opportunities, ugly code has less places to hide), when you see code you already have feelings
09:31:11 <monochrom> s/less/fewer/
09:35:09 <shapr> What's the solution to lambdabot's cabal-install errors again?
09:35:35 <lispy> shapr: I'm about to enter a meeting, but if you could hpaste the errors maybe I could help a little
09:37:37 <shapr> Eh, it's the same old "can't find a version of quickcheck that satisfies all dependencies"
09:38:13 <stepkut> the javascript 'this' keyword is for more difficult to understand than Monads in my opinion
09:38:18 <newbieee> hello, I'm back with a more concise question
09:38:19 <newbieee> http://pastebin.com/Va42bcuE
09:38:23 <xplat> stepkut++
09:38:23 <newbieee> all is here
09:38:30 <newbieee> what to do ...!?
09:38:36 <newbieee> I'm stuck once more
09:40:21 <newbieee> or maybe someone know a better place to ask for help?
09:40:52 <shapr> newbieee: Can you give a succint one-line description of your problem?
09:41:28 <newbieee> yes
09:41:55 <elkng> newbieee: try #friendly-coders channel
09:42:07 <elkng> they are more friendly =)
09:42:28 <xplat> we are friendly, there is just not enough information here
09:42:52 <newbieee> according to the type of the first argument ,in once case, I call recursively the same function 8 times, and in an other case, I call the draw function that draw a cube in 3d, and that had IO type
09:43:01 <sm> sure there is, newbieee is looking for an explanation of the ghc error pasted
09:43:16 <newbieee> the problem is that I think I understand the error
09:43:30 <newbieee> not the same returned type according to each type ( I think)
09:43:38 <newbieee> but what to do
09:43:38 <pmetzger> newbieee: what does the error say?
09:43:41 <xplat> right
09:43:44 <newbieee> I can't find a way to solve
09:43:51 <newbieee> the error says exactly :
09:44:00 <newbieee> the error says exactly :
09:44:05 <xplat> try 'otherwise = return ()' maybe
09:44:26 <pmetzger> newbieee: what is the type of draw0?
09:44:34 <newbieee> Couldn't match expected type `t0 -> a0 -> Map -> t0 -> a1'   with actual type `IO ()'
09:44:36 <pmetzger> newbieee: precisely, what is its type?
09:44:45 <xplat> drawO, and yes i am wondering that too
09:44:49 <newbieee> draw0 has type just wrote up there
09:44:54 <pmetzger> newbieee: what is the type of draw? precisely, what is its type?
09:44:59 <xplat> because i don't see wehre the Map and all that comes from
09:45:02 <newbieee> and return() -> yes, thanks, but not the problem
09:45:05 <pmetzger> don't say "has the type I wrote up there", type it.
09:45:16 <newbieee> t0 -> a0 -> Map -> t0 -> a1
09:45:20 <xplat> that looks like it is declared to take more arguments than are used in the equations
09:45:20 <pmetzger> okay, good.
09:45:32 <pmetzger> what is the expression you are returning as the value of draw0?
09:45:42 <pmetzger> on line 11?
09:45:44 <newbieee> http://pastebin.com/Va42bcuE
09:45:46 <newbieee> nothing
09:45:48 <pmetzger> type it.
09:45:51 <newbieee> I wanted to return nothing
09:45:51 <pmetzger> no, there is an expression
09:45:57 <pmetzger> you are returning that expression's value.
09:46:00 <newbieee> this function was just here to call other functions
09:46:00 <pmetzger> you can't return nothing
09:46:05 <pmetzger> this isn't C
09:46:05 <newbieee> hm...
09:46:07 <pmetzger> this is Haskell.
09:46:10 <sm> newbieee: if you haven't already, try adding type signatures to your top-level functions, you'll get better error messages
09:46:10 <pmetzger> everything has a value
09:46:16 <pmetzger> there is no such thing as something with no value.
09:46:27 <pmetzger> even if you return unit, that's a value.
09:46:36 <newbieee> ohh, I'd better learn more before annoying you
09:46:39 <newbieee> thanks very much
09:46:44 <pmetzger> wait.
09:46:52 <newbieee> yes?
09:46:54 <pmetzger> so, what is the expression who's value you are returning on line 11?
09:47:09 <newbieee> an IO value ?
09:47:14 <newbieee> draw s is IO
09:47:15 <pmetzger> no, what is the EXPRESSION
09:47:29 <pmetzger> but yes, draw s is an IO ()
09:47:33 <newbieee> expression of draw s?
09:47:37 <pmetzger> (not an IO, IO () )
09:47:41 <pmetzger> draw s is the expression
09:47:51 <pmetzger> so the return value of draw s is the return value of the whole function, right?
09:47:57 <newbieee> draw :: GL.GLfloat -> IO ()
09:48:02 <xplat> IO () is the type of draw s
09:48:06 <pmetzger> now what is to the right of the last -> in the type of draw0?
09:48:24 <newbieee> t0 -> a0 -> Map -> t0 -> a1
09:48:30 <pmetzger> so what is to the right of the last ->?
09:48:31 <newbieee> so a1
09:48:32 <sm> "#haskell - you WILL be helped"
09:48:33 <pmetzger> right
09:48:40 <newbieee> abstract type?
09:48:42 <pmetzger> so is a1 the same as IO ()?
09:49:09 <newbieee> hm...
09:49:11 <xplat> a1 could be the same as IO () but it doesn't get the chance
09:49:12 <newbieee> good question
09:49:14 <newbieee> probably not
09:49:17 <pmetzger> more to the point, look at the whole type signature
09:49:19 <newbieee> otherwise, I wouldn't have error
09:49:23 <pmetzger> how many parameters have you passed to draw0?
09:49:26 <pmetzger> how many does it take?
09:49:29 <newbieee> 2
09:49:31 <pmetzger> how many arrows are in its type?
09:49:37 <newbieee> s, wich is a gl float
09:49:41 <pmetzger> 2 is not correct
09:49:47 <pmetzger> what is the type of draw0 again?
09:49:52 <sm> don't be bringing arrows into this...
09:49:52 <newbieee> ah yes.. o_O
09:50:06 <xplat> sm: arrows, not arrows
09:50:10 <pmetzger> each -> implies another parameter unless you are currying.
09:50:15 <newbieee> yes
09:50:16 <newbieee> strange
09:50:19 <pmetzger> and I doubt you are intending to curry, are you?
09:50:21 <pmetzger> not strange.
09:50:29 <pmetzger> how about you start with this:
09:50:30 <newbieee> not especially
09:50:43 <xplat> the main problem is probably at the calling site
09:50:47 <pmetzger> 1) declare the type of draw0, don't just let the inferencer figure it out. that way you'll know if you made a mistake earlier.
09:50:49 <newbieee> but this should be a -> Map -> IO()
09:50:58 <xplat> you probably do not have a type signature for drawO
09:50:59 <pmetzger> but it isn't, now, is it?
09:51:03 <pmetzger> the inferencer told you that it isn't.
09:51:09 <xplat> and you are calling it with extra arguments it doesn't want
09:51:14 <newbieee> ok
09:51:15 <newbieee> ccol
09:51:15 <pmetzger> so declare what you think it should be and you'll get an error earlier
09:51:20 <pmetzger> where you made the real mistake.
09:51:20 <newbieee> I'll declare
09:51:24 <newbieee> thanks
09:51:31 * sm chants, add type signatures to functions for better error messages
09:52:13 <pmetzger> newbieee: however, I think you don't quite get the type system yet, and you need to understand that better. what are you using to learn?
09:52:19 <xplat> add type signature to every function for great diagnosis
09:52:30 <newbieee> done
09:52:34 <pmetzger> xplat is right on that -- the more type signatures, the better your error messages.
09:52:43 <newbieee> and here comes something I never saw.. `IO' is not applied to enough type arguments
09:52:58 <newbieee> and obviously, don't understand neither
09:53:03 <xplat> you wrote a type signature like 'foo -> IO'
09:53:14 <newbieee> GL.GLfloat -> Map -> IO
09:53:19 <pmetzger> newbieee: IO is not a type
09:53:23 <xplat> it needs to say something like 'foo -> IO Int' or 'foo -> IO ()'
09:53:23 <pmetzger> it is a type CONSTRUCTOR
09:53:27 <pmetzger> it needs to be passed a type.
09:53:32 <newbieee> and IO ()
09:53:34 <newbieee> is type
09:53:36 <pmetzger> () means "unit"
09:53:39 <newbieee> because () is a type?
09:53:41 <newbieee> ok
09:53:41 <pmetzger> so IO () is a type
09:53:47 <newbieee> .... ooookk!
09:53:50 <pmetzger> "unit" is sort of like "void" in C.
09:53:56 <newbieee> cool o_O
09:53:59 <pmetzger> it is a type with only one value
09:54:02 <newbieee> didn't reliezed
09:54:06 <newbieee> thanks
09:54:07 <pmetzger> what book are you learning from?
09:54:21 <newbieee> code from other people
09:54:22 <xplat> () is two things in haskell.  a value, and a type that contains only that value
09:54:29 <newbieee> my habitual methode
09:54:36 <newbieee> I started yesterday
09:54:39 <newbieee> but hm...
09:54:41 <pmetzger> newbieee: unless you have experience with ML or a similar language, you need to read a bit.
09:54:42 <newbieee> any good books?
09:54:56 <newbieee> ok
09:55:01 <pmetzger> newbieee: I suggest looking at the list of tutorials on haskell.org
09:55:06 <newbieee> ok, thanks
09:55:10 <pmetzger> there are several good short tutorials and a few good books online
09:55:22 <newbieee> so, here I go :)
09:55:25 <xplat> so writing «f ()» means giving «f» the argument «()».  it doesn't mean giving «f» no arguments.
09:55:31 <newbieee> see you... probably soon
09:55:34 <pmetzger> newbieee: http://www.haskell.org/haskellwiki/Tutorials
09:55:39 <newbieee> ok
09:55:44 <pmetzger> newbieee: http://www.haskell.org/haskellwiki/Books
09:56:08 <newbieee> and  a = 3
09:56:11 <newbieee> ok
09:56:16 <newbieee> forget
09:56:21 <newbieee> I understand
09:56:28 <pmetzger> newbieee: what languages do you know already?
09:56:49 <newbieee> c / c++ / gml (yes, I started with this...)
09:56:53 <newbieee> and some labview
09:57:00 <newbieee> and mathermatica
09:57:04 <pmetzger> I don't know what gml is.
09:57:15 <newbieee> game maker
09:57:21 <newbieee> script
09:57:30 <xplat> haskell is more like mathematica than like C/C++
09:57:33 <pmetzger> however: haskell does not look like C at all. it is purely functional, it has a rather unusual type system
09:57:42 <pmetzger> the syntax is very minimal, much like the pure lambda calculus
09:57:47 <newbieee> I like this
09:57:49 <pmetzger> you need to take time to learn it, slowly.
09:57:49 <newbieee> I like maaath
09:57:54 <newbieee> ok
09:58:01 <pmetzger> because it is not much like C.
09:58:08 <newbieee> I understood :)
09:58:17 <newbieee> thanks very much
09:58:22 <pmetzger> you are welcome.
09:58:25 <newbieee> was the first time I tried to ask for help online
09:58:36 <newbieee> much more kind what what I expected
09:58:42 <newbieee> I'm quite surprised !
09:58:54 <pmetzger> "real world haskell" and "learn you a haskell for great good" are both on line, as are others
09:58:56 <newbieee> friendly, I mean*
09:59:21 <newbieee> learn you a haskell for great good looks beatifully illustrated
09:59:24 <newbieee> I'll go there
09:59:33 <pmetzger> it is a good book if you have no functional programming experience
09:59:41 <Blkt> evening everyone
10:00:03 <newbieee> ok
10:03:24 <slyfox> hia! HCAR entries are to be expected in .tex format with some specific style? can you help me to generate html from it?
10:03:35 <slyfox> (pdf is also fine)
10:04:10 <pmetzger> so question for those with actual haskell experience (i.e. not me). I have a working lexical analyzer I've written for a simple language. It doesn't yet keep track of lines and characters, so my error messages in case of failure suck. what's a good paradigm for handling that?
10:04:25 <pmetzger> as it stands, I'm just passing the lexer a string with the whole file in it.
10:04:37 <dmwit> slyfox: pdflatex seems like the go-to program for creating PDFs from TeX.
10:05:05 <pmetzger> I could just pass the current position around the entire set of functions in the lexer (I currently pass around the remaining string to be parsed) but this seems a bit clunky
10:05:07 <slyfox> dmwit: it needs some .fmt (aka style in latex?) it complains on me
10:05:13 <dmwit> pmetzger: This is a hand-rolled lexer, not, say, using Parsec or so?
10:05:22 <xplat> pmetzger: that's easy with the state monad
10:05:22 <pmetzger> correct. I'm doing it to learn.
10:05:36 <slyfox> http://paste.pocoo.org/show/379790/ <- the error
10:05:41 <pmetzger> I was thinking a monad might be the thing to do...
10:05:42 <dmwit> pmetzger: Then, yep, the State or StateT monad seem like the way to go.
10:06:11 <pmetzger> though I may try doing it both ways. I'm trying to learn after all.
10:07:14 <sm> urgh.. could somebody write a HCAR submission generator ? cabal hcar .. pretty please ?
10:07:28 <dcoutts> heh
10:07:37 <pmetzger> hrm. is there a longer tutorial than http://www.haskell.org/haskellwiki/State_Monad ?
10:07:50 <dmwit> ?google meet the monads
10:07:52 <lambdabot> http://www.haskell.org/haskellwiki/Meet_Bob_The_Monadic_Lover
10:07:52 <lambdabot> Title: Meet Bob The Monadic Lover - HaskellWiki
10:07:57 <dmwit> eh... not that
10:08:01 <dmwit> ?google all about monads
10:08:03 <lambdabot> http://horna.org.ua/books/All_About_Monads.pdf
10:08:03 <lambdabot> Title: All About Monads Contents
10:08:31 <pmetzger> thanks
10:08:53 <pmetzger> I think with another week or so much of this will be more natural to me.
10:08:58 <dmwit> see also http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
10:11:30 <pmetzger> dmwit: thanks much.
10:14:46 <sm> so which is better, capri or cabal-dev ?
10:17:44 <Athas> How can I write 'map (uncurry $ flip (,))' in a shorter way?
10:18:03 <aristid> :t uncurry $ flip (,)
10:18:03 <lambdabot> forall a b. (a, b) -> (b, a)
10:18:14 <aristid> :t snd &&& fst
10:18:15 <lambdabot> forall a c. (a, c) -> (c, a)
10:18:22 <aristid> Athas: map (snd &&& fst)
10:18:33 <ben> woah
10:18:33 <aristid> &&& from Control.Arrow
10:18:37 <ben> Arrows are scary
10:18:42 <djahandarie> WHOA Control.Arrow
10:18:42 <aristid> lol
10:18:46 <Athas> They are indeed.
10:18:47 <aristid> WHOA WHOA WHOA
10:18:54 <djahandarie> aristid, calm down
10:18:57 <Athas> but I do understand that, thanks.
10:19:09 <aristid> djahandarie: i was just mocking you guys :)
10:19:16 <djahandarie> I know :p
10:20:50 <dschoepe> kinda reminds me of http://ro-che.info/ccc/12.html
10:21:19 <dmwit> > \xs -> [(a, b) | (b, a) <- xs]
10:21:20 <lambdabot>   Overlapping instances for GHC.Show.Show ([(t, t1)] -> [(t1, t)])
10:21:20 <lambdabot>    arising...
10:21:23 <dmwit> :t \xs -> [(a, b) | (b, a) <- xs]
10:21:24 <lambdabot> forall t t1. [(t, t1)] -> [(t1, t)]
10:21:53 <dmwit> No need to make it hard to understand. =)
10:22:22 <dmwit> I wonder if GHC could be extended to use the term variable name as its type variable instead of t and t1.
10:22:35 <dmwit> That would be pretty cool.
10:23:08 <djahandarie> dschoepe, heh, that comic was pretty funny. The typeclass is unfortunetly more useless than it needs to be due to 'arr' though.
10:23:18 <edwardk> hac phi needs to happen more than once a year ;)
10:23:48 <dmwit> Hi, edwardk!
10:23:51 <djahandarie> edwardk, why? Can't make it to this one?
10:24:01 <edwardk> i can
10:24:07 <dmwit> Because he wants to come to more than one per year, like any sane person!
10:24:08 <djahandarie> So you just want a double dose? :p
10:24:12 <edwardk> yes
10:24:17 <djahandarie> lol
10:24:24 * dmwit too
10:24:27 <edwardk> by the time the next one comes around i've typically been in hac phi withdrawal for 6 months
10:24:50 <edwardk> so i figure at least 2 a year is optimal ;)
10:24:50 <djahandarie> Can't we supplement it with Boston Haskell meetings? :p
10:25:13 <edwardk> djahandarie: true. i suppose i should also try and figure out if we can get a hac bos together
10:25:27 <djahandarie> Yes. >:)
10:25:30 <edwardk> we were going to have one last year before ravi bailed to singapore
10:25:41 <edwardk> and then it kind of fell apart
10:25:46 <dmwit> Ooooo, Boston is close.
10:25:53 <edwardk> as he had more pressing concerns
10:26:39 <edwardk> dmwit: would you make it down to a mid-winter boston hackathon?
10:26:48 <dmwit> I would.
10:26:54 <dmwit> err
10:27:00 <dmwit> Let me double-check that there's a bus or train or something.
10:27:04 <dmwit> But I'm pretty sure I would.
10:27:06 <edwardk> there is
10:27:09 <djahandarie> amtrak gets pretty close
10:27:11 <djahandarie> Dunno how close
10:27:12 <edwardk> the one i take to get there ;)
10:27:59 <dmwit> Then yes. =)
10:28:00 <edwardk> i figure anything we do will probably be at mit. the trick will be getting a space for a few days running and figuring out wifi connectivity
10:28:38 <edwardk> I should be able to get clarifi to fund food and stuff
10:28:41 <djahandarie> Does anyone at Boston Haskell even... go to MIT?
10:28:49 <edwardk> yeah
10:29:11 <edwardk> nirav, ed yang (back when he actively came before he started flitting from cambridge to cambridge) ;)
10:29:26 <copumpkin> djahandarie: I think Veinor went once
10:29:29 <copumpkin> but he doesn't like us
10:29:33 <djahandarie> Yeah Veinor went once
10:29:34 <copumpkin> and especially doesn't want to meet me
10:29:36 <Veinor> :(
10:29:44 <Veinor> last time i was busy!
10:29:47 <djahandarie> I'm just curious how you manage to land that room
10:29:54 <copumpkin> pretty sweet room, eh
10:29:55 * djahandarie suspects extortion
10:30:26 <edwardk> mostly by intimidation
10:30:50 <djahandarie> You start blabing about category theory and they go "OKAY, okay, we'll give you the room!!"
10:30:53 <djahandarie> ?
10:31:09 <edwardk> yep. its either that or they won't get any work done for days
10:31:12 <djahandarie> Hahaha
10:31:20 <copumpkin> a formal CT proof that giving ed the room is the only possible course of action
10:31:54 <dmwit> So... djahandarie... I can't help noticing your name isn't registered for Hac Phi...
10:32:06 * copumpkin glares at djahandarie 
10:32:10 <ezyang> We all should do a Hac Bos when I get back :^) 
10:32:14 <dankna> do I need to do something to register?  I expect to be there
10:32:17 <edwardk> Ladies and gentlemen, this is Chewbacca. Chewbacca is a Wookiee from the planet Kashyyyk. But Chewbacca lives on the planet Endor. Now think about it; that does not make sense! ... so you must give me the room
10:32:17 <copumpkin> ezyang: YES!
10:32:31 <copumpkin> dankna: you send your info to dmwit 
10:32:34 <dmwit> dankna: Send me an email!
10:32:35 <edwardk> ezyang: when do you get back?
10:32:47 <djahandarie> dmwit, haha, yes, I'll send that email at some point...
10:32:49 <dmwit> dankna: Instructions here: http://www.haskell.org/haskellwiki/Hac_%CF%86/Register
10:33:07 <djahandarie> I need to figure out where I'm actually going to stay during that time
10:33:13 <copumpkin> so do most of us
10:33:23 <dankna> I'm fortunate enough to have a relative in the area :)
10:33:26 <edwardk> djahandarie: the suggested hotel is actually rather nice
10:33:33 <ezyang> Late August, hopefully. But I think I'm planning on visiting sometime over the summer (I'll be in NY) 
10:34:07 <edwardk> fair nuff. i think the original plan was for some time in january or december to coincide with something MITish, but i'll have to look
10:34:16 <sm> how do I find out which of my dependencies is forcing a dependency on mtl 1 ? cabal install -v3 says just https://gist.github.com/946869 
10:34:35 <edwardk> really it'll come down to when/where/how we get space and wifi
10:35:00 <dcoutts> sm: use --constraint='mtl >= 2'
10:35:28 <ezyang> Sounds good :-) 
10:36:01 <sm> dcoutts: that doesn't change the message.. it still just says rss2irc requires mtl 1, and not why
10:36:12 <sm> there's no direct dependency, unless I'm going blind
10:36:29 <dcoutts> sm: ok, so you want to know which dependency pulls in rss2irc
10:36:49 <sm> no, I'm in the rss2irc source dir doing cabal install
10:36:49 <dmwit> sm: mtl-1.1.* seems to be in its dependency list.
10:36:59 <dmwit> (According to hackage.)
10:37:14 <dankna> there, my registration email is sent
10:37:21 <dmwit> Yay!
10:37:39 <dcoutts> sm: presumably because the rss2irc specifies mtl < 2
10:37:46 <dcoutts> sm: in the .cabal file
10:38:02 <sm> "mtl" does not occur in the cabal file
10:38:03 <djahandarie> dmwit, me too
10:38:10 <koeien> does using GADTs entail a runtime overhead?
10:38:13 <sm> The output does say "selecting rss2irc-0.4.99 (hackage)" which I thought was odd. Could it be using rss2irc 0.4.2 from hackage ?
10:38:26 <copumpkin> koeien: no
10:38:31 <koeien> copumpkin: cool. thought so
10:38:33 <dcoutts> sm: no, it really means '(source)'
10:38:37 <sm> ok good
10:39:31 <dcoutts> sm: can you post the .cabal file
10:39:31 <djahandarie> Now all we need to do is convince ddarius to go and we'll have all the Ds going!
10:39:36 <dankna> haha
10:39:47 <dmwit> ha!
10:39:51 <djahandarie> Oh, I suppose dcoutts counts too :)
10:40:02 <dcoutts> heh
10:41:24 <sm> http://joyful.com/repos/rss2irc/rss2irc.cabal but no need to look.. you forced my brain to look at the modeline and notice I was looking at some other cabal file than I though. So sorry :)
10:41:43 <dmwit> dcoutts seems to be across a largish ocean from Philadelphia.
10:41:55 <dcoutts> sm: ok, good, the universe is not misbehaving :-)
10:42:06 <sm> yes phew. Thanks all
10:42:15 <dcoutts> dmwit: I thought it was just a pond
10:42:51 <dmwit> middling-sized for a pond, but largish for an ocean ;-)
10:56:14 <rata_> hi
10:56:35 <koeien> hello! how can we help?
11:06:59 <navaati> implementing Eq for IO a would be resolving the halting problem, right ?
11:07:58 <dmwit> Not necessarily.
11:08:04 <yrlnry> Depends on if you want it to yield correct answers.
11:08:13 <copumpkin> pff, correctness is overrated
11:08:18 <yrlnry> And what your definition of "correct" is in this case.
11:08:20 <dmwit> You could model IO with a free monad over all possible primitive IO actions, then Eq would be easy.
11:08:48 <dmwit> or... hm
11:08:52 <dmwit> Maybe it wouldn't.
11:09:03 <dmwit> Okay, yeah, it's probably halting-problematic.
11:09:04 <yrlnry> Consider launch_the_missiles :: IO ()   and launch_the_missiles == return ()
11:09:06 <navaati> hum, wouldn't it require to implement Eq for a ->b ?
11:09:17 <mm_freak> you could restrict haskell to the subset of agda, making it turing-incomplete
11:09:21 <yrlnry> Do you want that to return true or false?
11:09:21 <mm_freak> then Eq would indeed be easy
11:09:46 <copumpkin> dmwit: if you have no binds in your IO action, sure :)
11:09:51 <copumpkin> but it wouldn't be very exciting
11:10:00 <dmwit> yea
11:10:05 <dmwit> That's what I realized. =P
11:12:05 <navaati> hum, yeah, impossible
11:12:25 <copumpkin> if your inner types are enumerable
11:12:29 <copumpkin> finitely enumerable
11:12:31 <copumpkin> you can decide it
11:12:38 <copumpkin> using my enumerable package!
11:12:48 <copumpkin> if it's infinitely enumerable, then you can semidecide it
11:13:20 <robnik> Are there any extensions to Haskell that allow overloading without type classes?  Ie, 2+ functions with different, unrelated types.  Would that mess up the type inference, or have some other negative effect?
11:13:24 <yrlnry> Oh, that reminds me that I would like to read up on the sense in which the natural numbers are not topologically compact. but you can compactify them by adding an Infinity element.  Can anyone suggest a reference?
11:14:04 <copumpkin> robnik: insanity
11:14:07 <copumpkin> robnik: but otherwise, no
11:14:14 <copumpkin> not allowing it was a design decision
11:14:21 <yrlnry> There's apparently some way to topologize Haskell types so that continuous functions are precisely those that preserve upper bounds of sequences, or something.
11:14:22 <Veinor> well, a compact set is a set such that any open cover has a finite subcover
11:14:36 <Veinor> and the cover {{0}, {1}, {2}, ...} has no finite subcover, obviously
11:15:12 <Veinor> alternately, since N is a subset of R, since N has a sequence without a convergent subsequence, it's not compact
11:15:30 <yrlnry> Veinor:  thanks, but I know this already and it is not specific enough.
11:15:38 <robnik> For the most part I'm not missing it.  
11:15:45 <yrlnry> See 2m ago.
11:16:44 <yrlnry> There is some *specific* way to topologize Scott domains that gets you a particular set of nice properties, one of which is that compact sets admit exhaustive search.
11:17:43 <Veinor> ah. sorry, don't know about that then.
11:19:38 <yrlnry> Maybe what I want is "topological domain theory".
11:31:50 * hackagebot zeno 0.2.0.0 - An automated proof system for Haskell programs  http://hackage.haskell.org/package/zeno-0.2.0.0 (WilliamSonnex)
11:40:09 <dmwit> yrlnry: Perhaps there are some pointers to citations in the transitive closure of links from here: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
11:40:54 <Alan> dmwit: what percentage of the searchable internet is the transitive closure of any such page going to contain? :|
11:41:18 <dmwit> Naturally I expect yrlnry to do some heuristic pruning.
11:42:27 <yrlnry> I was going to start with the bibliography of the Martín Escardó paper that is linked at the top of that page, so I agree that that is likely to bear fruit.
11:43:02 <yrlnry> Unfortunately a significant fraction of the references I marked in that paper for followup are written in German.
11:43:26 <dmwit> heh
11:43:58 <djahandarie> There's an easily solution to that problem!
11:44:03 <djahandarie> Learn german!
11:44:29 <monochrom> use google translate
11:45:28 <gwern> "The story is that young Boltzmann was dissatisfied with the rigor of his physics textbooks. Finally he heard about a textbook of impeccable logic. He rushed to check it out, but found the library had already loaned it; and it was in English. He went home dismayed, but his wiser older brother comforted him: 'A few weeks for a good book is not too long to wait. Further, if it is truly logical then the author will surely explain each term carefully ...
11:45:34 <gwern> ... before using it; so the language can't <i>really</i> matter.' Boltzman implies that this event cured him of trying to be too deductive in his physics."
11:46:25 <pmetzger> rigor mortis...
11:46:34 * ksf_ shudders at the thought of a CS paper in German
11:46:34 <lambdabot> ksf_: You have 1 new message. '/msg lambdabot @messages' to read it.
11:46:59 <crystal-cola> I don't understand the story
11:47:08 <crystal-cola> since he couldn't get th book he stopped looking for it?
11:48:28 <pmetzger> The story is odd for another reason. Boltzmann's contributions to physics are among the purest insights out there, not very connected to experiment.
11:49:09 <pmetzger> S = k log w -- that's not some sort of curve fitting job or patchwork.
11:49:18 <pmetzger> it is pure deduction really.
11:49:35 <ksf_> though in principle, german can express scientific rigour way better than english.
11:49:39 <crystal-cola> yeah
11:50:23 <ksf_> but wrt. CS, there's just too many established english terminology, and translating that stuff only induces confusion.
11:50:50 <Kerris> it is late and this simple partial application + higher order example just blew my mind
11:50:58 <Kerris> okay sleep
11:52:35 <monochrom> applikativfunktorzcht
11:53:28 <ksf_> "Applikativer Funktor" would work. but they'd probably call it "Anwendungsfunktor"
11:53:41 <djahandarie> I wonder what happened to FunctorSalad
11:53:53 <djahandarie> Or 'FunktorSalat' I think he used to go by :p
11:53:56 <aristid> preflex: seen FunctorSalad
11:54:07 <djahandarie> preflex_: seen preflex
11:54:08 <preflex_>  Sorry, I haven't seen preflex
11:54:26 <ksf_> preflex_, seen FunctorSalad
11:54:27 <preflex_>  FunctorSalad was last seen on #haskell-blah 51 days, 16 hours, 18 minutes and 50 seconds ago, saying: good night :)
11:55:19 <mauke> preflex_: nick preflex
11:56:36 <postflex> FunctorSalad was first seen on #haskell 4 years, 23 days, 1 hour, 53 minutes and 2 seconds ago, saying: hi!
11:57:48 <djahandarie> Hahaha
11:58:10 <djahandarie> (And who would enter this room with that nick?)
11:58:57 <circumflex> FunctorSalad wâs never seen on #haskell-world-conquest -4 years, 3 days, 7i minutes and 0 seconds ago, saying: RELEASE THE KRAKEN!
11:58:59 <Veinor> what about inflex?
11:59:14 <xplat> it was taken
11:59:31 <postflex> :)
12:00:33 <xplat> presumably mixflex would report every time FunctorSalad was seen, and get kicked
12:00:54 <dmwit> Aw, reflex was already taken.
12:01:05 <dmwit> I was going to say
12:01:15 <dmwit> (: ʇɥƃıu pooƃ :ƃuıʎɐs 'oƃɐ spuoɔǝs 05 puɐ sǝʇnuıɯ 81 'sɹnoɥ 91 'sʎɐp 15 ɥɐʃq-ʃʃǝʞsɐɥ# uo uǝǝs ʇsɐʃ sɐʍ pɐʃɐSɹoʇɔunℲ
12:01:17 <dorsiflex> FunctorSalad was last seen on #haskell-football 64 days, 7 minutes and 0 seconds ago, saying: Yeah, but you can't properly train it in american football.
12:01:58 <djahandarie> @remember #haskell <aristid> preflex: seen FunctorSalad  * preflex_ is now known as preflex. * copumpkin is now known as postflex. * xplat is now known as circumflex. < circumflex> FunctorSalad wâs never seen on #haskell-world-conquest -4 years, 3 days, 7i minutes and 0 seconds ago, saying: RELEASE THE KRAKEN!
12:01:58 <lambdabot> I will never forget.
12:02:35 <aristid> djahandarie: i would almost have missed that, had you not highlighted me :)
12:02:58 <sm> in bracket's "release resource" handler, you can't easily get at the exception that was raised, if there was one - right ?
12:04:38 <dmwit> sm: right
12:05:14 <sm> good, thanks dmwit
12:06:09 <xplat> robnik: there are type systems for arbitrary overloaded functions, but i've heard they tend to produce really large types
12:06:55 <sm> well it's not good, but at least I'm getting a bit more of a grip on exception handling
12:08:03 <robnik> xplat: large types?  I'm wondering why. 
12:08:15 <xplat> these include Camarão and Figueiredo's System CT
12:09:43 <xplat> robnik: well, they basically amount to 'duck types', and thus they tend to include detailed descriptions of what a duck is
12:10:04 <djahandarie> I've never had a solid understanding of duck typing
12:10:22 <monochrom> you could also get and use huge record types in ocaml
12:10:40 <monochrom> (same reason)
12:10:42 <ksf> there's also static duck typing.
12:10:46 <ksf> it's more about behaviour.
12:10:46 <xplat> like instead of 'Duck -> String' it's 'Quacking Yellow Swimming Flying Feathered Beak-Bearing Biped -> String'
12:10:59 <monochrom> yeah, ocaml is static duck typing
12:11:17 <ksf> e.g. when you have 1 :: Int * 3 :: Float - "5" :: String to result in a Double.
12:11:26 <xplat> but at least then if you have a function on ducks that doesn't need the feathers you won't be stopped from using it
12:11:58 <xplat> ksf: that's somewhat distinct from duck typing
12:12:04 <ksf> an example of that is in the fun with type functions paper
12:12:50 <ksf> ...figuring out the codomain by the two domain types and doing all the conversions implicitely.
12:13:21 <Somelauw> Haskell has no duck typing.
12:13:33 <ksf> not in the standard libraries, no.
12:13:54 <xplat> @faq can Haskell type ducks?
12:13:54 <lambdabot> The answer is: Yes! Haskell can do that.
12:14:11 <ksf> well, though "1 :: Num a => a" is related.
12:14:41 <ksf> I'd call that egg-typing. the duck hasn't hatched, yet.
12:15:04 <monochrom> haha
12:15:05 * hackagebot AES 0.2.8 - Fast AES encryption/decryption for bytestrings  http://hackage.haskell.org/package/AES-0.2.8 (SveinOveAas)
12:15:08 <xplat> duck-typing is more related to structural typing than to type classes
12:15:15 <monochrom> protoplasm typing
12:16:30 <xplat> although in functional languages particularly it does have some similarity to type classes as well
12:17:28 <Somelauw> you can in most lisp dialects.
12:18:17 <robnik> I thought duck typing was like Scheme/Python where the object carries a pointer to type so you find it's type at run time even if it was compile-time-typed as 'any'.
12:18:57 <xplat> robnik: that's dynamic typing
12:19:06 * hackagebot zeno 0.2.0.1 - An automated proof system for Haskell programs  http://hackage.haskell.org/package/zeno-0.2.0.1 (WilliamSonnex)
12:19:18 <DrSyzygy> robnik: Nah. “Walks like a duck, quacks like a duck, must be a duck” — it's when type membership is a matter of displaying th right member methods.
12:19:35 <Somelauw> Duck is like using interfaces without declaring them. So like a.fun and a can be any class that has a fun method.
12:19:57 <Somelauw> But a doesn't need to implement an interface.
12:20:11 <byorgey> in particular you could (in principle) design a statically-typed system that used duck typing.
12:20:14 <monochrom> duck typing is often implemented with the help of dynamic typing, thus the mixup
12:20:25 <robnik> Ah, okay.   I've seen that in Python too.  I see the difference with dynamic typing though.  Thx.
12:20:35 <monochrom> duck type can be more safely implemented with the help of dependent typing
12:20:45 <Cale> Duck typing seems like an informal way of saying structural subtyping to me.
12:20:57 <Somelauw> And I think creating interfaces is boring.
12:21:06 * hackagebot gd 3000.6.2 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.6.2 (ChrisDone)
12:21:15 <monochrom> meanwhile, ocaml provides a middleground of duck typing implemented by decidable static typing
12:21:32 <dmwit> Wow, talk about version bloat.
12:22:34 <pmetzger> monochrom: dependent typing may be more safely implemented by providing an algorithm to generate proofs over ω-complete formal systems.
12:23:03 <pmetzger> :)
12:23:21 <robnik> "dependent typing" ... I don't know that one either.  Back to wikipedia...
12:23:22 <monochrom> oh I agree about getting rid of humans altogether
12:23:41 <pmetzger> :)
12:24:39 <pmetzger> robnik: dependent typing is great, as it allows lots more things to be strongly typed and allows great specificity in what types mean. it has the slight flaw of rendering your type system undecidable, but hey, no one is perfect. :)
12:24:42 <Cale> robnik: You might also like to look at http://en.wikipedia.org/wiki/Structural_type_system
12:25:04 <crystal-cola> pmetzger: what's undecidable about it?
12:25:12 <monochrom> dependent typing simply means you can use arbitrary formal specifications for your types, e.g., "this function takes a prime number as parameter and returns a record that has at least a field called fmap such that fmap satisfies all the Functor axioms"
12:25:25 <pmetzger> in a full scale dependent type system, proving types means the same thing as proving the specification of the program. :)
12:25:26 <djahandarie> pmetzger, you mean it makes HM-style inference impossible, right?
12:25:29 <pmetzger> or can.
12:25:44 <crystal-cola> oh right because you can just put your program in the type
12:25:44 <crystal-cola> lool
12:25:50 <pmetzger> which means that you have to prove arbitrary theorems in order to show that the types are correct.
12:25:58 <Cale> Though that page does bring up a decent point that "duck typing" as used by dynamically typed languages is only checking the part of the structure which is actually accessed at runtime.
12:26:02 <dmwit> pmetzger: Even type-checking a fully-annotated program can be hard.
12:26:03 <pmetzger> which means that you have to provide an algorithm to generate proofs for arbitrary theorems.
12:26:05 <monochrom> you can do all of math in agda
12:26:17 <Cale> (because hey, it's dynamically typed)
12:26:18 <rostayob> I'm compiling crypto-api, and the memory fills up quickly at the second pass, and the compilation doesn't terminate
12:26:26 <rostayob> basically while doing this "[1 of 9] Compiling Crypto.CPoly     ( Crypto/CPoly.hs, dist/build/Crypto/CPoly.dyn_o )
12:26:32 <monochrom> in fact, following your recent remark on agda, you can solve all millenium problems in agda
12:26:55 <xplat> Cale: the difference between duck typing and mere structural (sub)typing is that in duck typing you can often condition on the existence of outside entities.  like 'a duck is accepted as an argument of print'.
12:27:08 <dmwit> err... that was supposed to be aimed at djahandarie, not pmetzger.
12:27:28 <pmetzger> but of course, merely because dependent typing renders the type system as powerful as, say, ZF set theory is no reason not to do research on it, in fact it makes it more interesting.
12:27:32 <Cale> rostayob: That module is ridiculously large
12:27:38 <pmetzger> but also much less practical in an unrestricted form.
12:27:42 <crystal-cola> what about using it for programming
12:27:54 <rostayob> Cale: yeah but filling up 4GB of memory? something is wrong.
12:28:12 <rostayob> Cale: what's that second pass anyway? the one with the dyn_o files
12:28:53 <xplat> linking
12:29:08 * hackagebot gd 3000.7 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.7 (ChrisDone)
12:29:08 <Cale> I'll compile it myself and see
12:29:11 <rostayob> why doesn't it do it when I install directly with cabal?
12:29:18 <rostayob> oh
12:29:24 <rostayob> because it compiles statically?
12:29:39 <pmetzger> dependent types let you say "this function returns a list who's members are sorted", or even more surprisingly, "if the parameter to this function is greater than five, the return is a list, otherwise it is a float"
12:29:58 * roconnor is confused by pmetzger's comments
12:29:58 <Cale> Only uses 100MB here
12:29:59 <Cale> still takes a little while
12:30:01 * djahandarie is confused by pmetzger's comments as well
12:30:09 <pmetzger> types and propositions are fully unified. Coq is, in this sense, a dependently typed language.
12:30:11 <Cale> (but not more than 10 seconds)
12:30:37 <pmetzger> a type can be an arbitrary proposition about the object.
12:31:01 <rostayob> Cale: do you go through that dyn_o phase? because I can compile it fine as well without that, I think it's caused by split-objs or shared
12:31:08 <roconnor> typechecking is decidable in Coq (hopefully)
12:31:12 <xplat> or 'this function returns either a proof that its parameter is prime, or a divisor of its parameter' where in either case that is statically guaranteed to be true wrt the actual parameter
12:31:20 <pmetzger> roconnor: it is not!
12:31:31 <djahandarie> It isn't?
12:31:36 <pmetzger> roconnor: if it was, you would have an algorithm to prove arbitrary statements!
12:31:37 <Cale> I've never seen a dyn_o file in my life.
12:31:41 <djahandarie> Sans bugs..
12:31:45 <Cale> Could be
12:31:56 <roconnor> pmetzger: type checking doesn't provide an algorithm to prove arbitrary statements.
12:31:58 <pmetzger> in coq, a proposition is a type. the inhabitants of that type are the proofs of the proposition!
12:32:01 <rostayob> Cale: I package everything in archlinux packages
12:32:11 <RLa> if you consider so general dep type systems, can't you also express halting problem in it?
12:32:19 <copumpkin> pmetzger: same in haskell!
12:32:23 <roconnor> pmetzger: type inhabitation is undecidable, not type checking
12:32:26 <copumpkin> it just happens to be a fucked-up logic
12:32:27 <edwardk> pmetzger: sure it is, roconnor decided it was decidable ;)
12:32:29 <djahandarie> pmetzger, what does a typeCHECKING algorithm have to do proving arbitrary theorems?
12:32:36 <pmetzger> copumpkin: but in haskell you can't express as rich a proposition as a type
12:32:44 <rostayob> Cale: yes, enabling those two make it work
12:32:44 <copumpkin> sure
12:32:53 <pmetzger> djahandarie: learn about the Curry-Howard Isomorphism
12:32:54 <xplat> pmetzger: type checking can be decidable in a dependently typed language, type inference almost never is (but it can be if the 'values' in types are different from runtime values like in ATS)
12:33:00 <pmetzger> proofs are programs, programs are proofs.
12:33:25 <roconnor> pmetzger: to quote Bob Harper, "You are wrong."
12:33:25 <crystal-cola> whats the use if you can't get the computer to write the program for you
12:33:33 <copumpkin> lol
12:33:34 <pmetzger> xplat: well, yah, I suppose if you insist on a proof being there yah, a type checker available.
12:33:37 <edwardk> hah
12:33:41 <copumpkin> end of conversation
12:33:41 <xplat> pmetzger: typechecking is proof-checking, not proving
12:33:45 <pmetzger> okay, I screwed up my terminology.
12:33:54 <ulfdoz> &aw
12:34:00 <djahandarie> pmetzger, pretty critically.
12:34:04 <xplat> pmetzger: if you can't check your proofs, you don't have a very useful logic :)
12:34:07 <pmetzger> yah, true.
12:34:26 <pmetzger> shows you how good I am at this crap. :)
12:34:34 <pmetzger> (not sufficiently!)
12:34:41 * copumpkin slaps pmetzger 
12:34:46 <monochrom> proof-checking is pretty easy, due to pushing the problem towards the proof author. "elaborate this step"
12:34:48 <copumpkin> (with a trout)
12:34:55 <dmwit> ?slap pmetzger
12:34:56 <lambdabot> I don't perform such side effects on command!
12:35:11 * djahandarie read command as comonad. 'Le sigh.
12:35:16 <pmetzger> monochrom: but the point is, that generating proofs is hard.
12:35:20 * copumpkin le slaps djahandarie 
12:35:26 <copumpkin> pmetzger: nobody denies that :)
12:35:28 <monochrom> however in practice most proof-checkers actually are way better than humans regarding very basic logic
12:35:33 <roconnor> monochrom: if you mean easy as in O(oh-my-god-the-ackerman-function-might-as-well-be-O(1))
12:35:35 <crystal-cola> why is generating proofs hard?
12:35:45 <pmetzger> crystal-cola: see Kurt Goedel.
12:35:47 <rostayob> ok, it turns out that compiling crypto-api with --enable-shared is impossible.
12:35:49 <copumpkin> depends, if you're working in a specific theory it might be fine
12:35:54 <crystal-cola> what
12:36:00 <monochrom> see for example http://www.umsu.de/logik/trees/
12:36:01 <dmwit> crystal-cola: Because there's so damn many of them.
12:36:09 <copumpkin> crystal-cola: peano arithmetic is undecidable :(
12:36:24 <roconnor> robinson arithmetic is undecidable.
12:36:27 <pmetzger> crystal-cola: there is no algorithm to produce a proof of an arbitrary proposition provided the logic is rich enough to have induction.
12:36:32 <copumpkin> presburger on the other hand is nice!
12:36:34 <copumpkin> but rather boring :(
12:36:46 <roconnor> robinson arithmetic more or less doesn't have induction
12:36:50 <pmetzger> presbuger arithmetic is useful in coq, you have that magic proof tactic to prove things with it.
12:37:01 <crystal-cola> what does that have to do with generating proofs?
12:37:01 <xplat> there are a lot of proofs, but most of them prove something else
12:37:22 <pmetzger> roconnor: I don't know it, but I presume if it is undecidable it is omega complete.
12:37:30 <monochrom> presburger arithmetic is probably all you need regarding arithmetic in many programs, i.e., checking array bounds
12:37:41 <copumpkin> crystal-cola: finding that proof is effectively a decision procedure
12:37:59 <pmetzger> monochrom: is the decision procedure for pressbuger arithmetic polynomial?
12:38:06 <roconnor> omega-complete?
12:38:07 <monochrom> no, exponential or worse
12:38:08 <copumpkin> hell no
12:38:12 <pmetzger> monochrom: sigh.
12:38:13 <copumpkin> doubly exponential iirc
12:38:21 <copumpkin> in the number of quantifier alternations
12:38:25 <copumpkin> or something scary like that
12:38:28 <pmetzger> so it isn't very practical for proving array bounds. :(
12:38:31 <copumpkin> well
12:38:31 <roconnor> http://en.wikipedia.org/wiki/Robinson_arithmetic
12:38:37 <copumpkin> in many cases you don't have many alternations
12:38:46 <xplat> i think possibly the most useful characterization is 'any language where you can express all instances of the halting problem is undecidable'
12:38:58 <crystal-cola> anyone time someone starts talking about godel I lose track of what the hell anyone is talking about anymore
12:39:19 <monochrom> welcome to the field of automated formal verification. here, NPC problems are "fast", exponential is "ok", doubly-exponential is "daily life"
12:39:24 <copumpkin> I think most talk about godel tends to be wrong
12:39:25 <copumpkin> in general
12:39:36 <pmetzger> crystal-cola: you don't know Goedel's theorem?
12:39:54 <xplat> Robinson arithmetic is pretty significant because the natural assumption when you hear 'peano arithmetic is incomplete/undecidable' is that the induction axiom is at fault
12:39:55 <copumpkin> monochrom: I like the automatic prover for real-closed fields
12:39:59 <copumpkin> with nonelementary time complexity
12:40:16 <copumpkin> (i.e, it's not bounded by any finite power tower)
12:40:16 <pmetzger> xplat: very cool. I didn't know about Robinson arithmetic.
12:40:22 <monochrom> integer programming is "fast" because it's "merely" NPC
12:40:38 <pmetzger> "integer programming"?
12:40:44 <pmetzger> you mean integer linear programming?
12:40:45 <Bfig> integer programming is fast?
12:40:45 <monochrom> presburger arithmetic is pretty practical these days
12:40:54 <copumpkin> we even have a presburger solver on hackage
12:40:54 <Bfig> integer programming is np complete iirc
12:40:58 <copumpkin> guess what it's called!
12:40:59 <monochrom> yes integer linear programming
12:41:05 <copumpkin> Bfig: np-complete is "easy" in this context :P
12:41:16 <Bfig> lol, what's the context?
12:41:17 <monochrom> Bfig please refer to my earlier comment in your scroll buffer
12:41:18 <pmetzger> monochrom: having used the pressburger arithmetic solver in Coq I know that, but I'm surprised that it was useful given the time complexity
12:41:21 <copumpkin> Bfig: automatic proof generation
12:41:27 <Bfig> monochrom, i just joined
12:41:43 <monochrom> I'll serve it then
12:41:48 <monochrom> welcome to the field of automated formal verification. here, NPC problems are "fast", exponential is "ok", doubly-exponential is "daily life"
12:41:51 <crystal-cola> I know the theorem - just don't know why it would be relevant
12:42:32 <pmetzger> crystal-cola: if you know Goedel's Theorem, it should be obvious that no algorithm for generating correct proofs can exist in a sufficiently rich logical system
12:42:45 <copumpkin> one of his results was that peano arithmetic was undecidable, wasn't it?
12:42:46 <Bfig> sounds interesting. today it flashed in my head how complex this would have to be when thinking about lagrangian relaxations
12:42:50 * djahandarie hates the word obvious
12:42:53 <crystal-cola> yeah but you're talking about proving EVERY theorem
12:43:13 <crystal-cola> I only want to prove the theorems that I need to justify that my program is correct
12:43:21 <Bfig> ie, how to for example how complex would your system have to be to state for example the duality theorems
12:43:21 <pmetzger> crystal-cola: if you can prove arbitrary theorems you can prove every theorem.
12:43:33 <roconnor> in general deciding if pi_1 sentences are true is undecidable.
12:43:36 <pmetzger> crystal-cola: your program might require arbitrary theorems to be proven to show it is correct
12:43:58 <copumpkin> roconnor: haven't you done godel's stuff in coq?
12:44:04 <roconnor> yes
12:44:21 <Philippa> this is undecidable in a sense that subsumes semi-decidable, though
12:44:27 <roconnor> yes
12:44:38 <pmetzger> so the reason a pressburger solver is practical is only that many common interesting cases are small enough, eh?
12:44:41 <roconnor> pi_1's are falsafiable
12:44:48 <crystal-cola> This is theory you are talking about
12:44:52 <crystal-cola> I am talking about in practice
12:44:56 <pmetzger> but if it is double exponential, I imagine it is trivial to produce an instance that takes a very long time to solve...
12:45:00 <copumpkin> pmetzger: well, it supports quantifier elimination, which makes it fairly easy to check if something is true
12:45:11 <copumpkin> but while eliminating them there quantifiers, the expression gets rather large
12:45:13 <Philippa> crystal-cola: then in practice, you /also/ have to worry about time spent
12:45:15 <xplat> robinson arithmetic shows that all you need for essentially undecidable is 0, successor, +, *, and 'every number is either 0 or the successor of some number'
12:45:18 <crystal-cola> None of this nonsense about formal languages and godel have anything to do with theory
12:45:22 <crystal-cola> sorry
12:45:24 <crystal-cola> nothing to do with practice
12:45:30 <pmetzger> yes they do.
12:45:33 <xplat> that last is sort of a coinduction principle
12:45:37 <pmetzger> you hit undecidable problems in CS all the time.
12:45:53 <xplat> it lets you pattern-match but it doesn't guarantee that you'll ever hit a base case if you recurse
12:45:53 <Philippa> crystal-cola: you've got a perfect virus detector, then?
12:46:04 <pmetzger> virus detection is an obvious one, yes.
12:46:57 <pmetzger> and, trivially, if you could prove arbitrary statements and do it quickly, you could just formally state what your program should do, hand the program and the proposition off to a prover, and know if it was bug free in a brief time.
12:47:09 * djahandarie also hates the word trivial
12:47:14 <xplat> it's weak enough that you need special axioms to define addition and multiplication
12:47:25 * obviouslytrivial trolls djahandarie 
12:47:26 <crystal-cola> I think we need to take out head out of the clouds and figure out how this stuff relates to actual programming
12:47:27 <Philippa> pmetzger: for bonus points, you wouldn't need a program - you'd just ask for a constructive proof that the spec is implementable
12:47:30 <crystal-cola> the kind where you get stuff done
12:47:32 <djahandarie> :(
12:47:35 <Bfig> it's interesting how we end up in paradox quite fast, ie, if we even want to talk about the 'language of all provable statements' we have to 1)assume the statements we use are provable or 2)build a decider for membership to that set (ie, undecidable)
12:47:47 <crystal-cola> none of this pathological self modifying introspecive nonsense
12:47:54 <Philippa> crystal-cola: it tells you the things you definitely can't done - it's exactly *what* gets your head out of the clouds
12:48:00 <crystal-cola> how do I write a program that doesn't crash
12:48:02 <Philippa> *can't get done
12:48:09 <pmetzger> crystal-cola: I'm not a theory guy. This IS important.
12:48:12 <Philippa> you write NOP
12:48:14 <Philippa> HTH HAND
12:48:47 <crystal-cola> this is the prbolem with you theory folks, it's too comfortable to lay back and relax in a sea of formal grammars
12:48:53 <Bfig> decidability rates among the most important stuff you can say about a problem
12:48:55 <Philippa> (you find chunks of logics that /are/ decidable, and you find ways to encode things that 'look' like they're not decidable into them)
12:48:56 <pmetzger> crystal-cola: I'm not a theory guy.
12:49:10 <pmetzger> crystal-cola: I'm really, if you get down to it, a kernel hacker.
12:49:22 <pmetzger> crystal-cola: though I've kind of left that behind.
12:50:10 <Philippa> I'm mostly a cranky scripter-and-gamedevver-and-user-of-apps-that-should-be-programmable. Mostly.
12:50:19 <pmetzger> anyway, if you look at a tool like Coverity's C checker, you're staring undecidability in the face.
12:50:21 <obviouslytrivial> I'm bug a vegetable
12:50:24 <obviouslytrivial> *but
12:50:35 <djahandarie> obviouslytrivial, obviously.
12:50:35 <pmetzger> the reason it isn't perfect and can't be is because of undecidability.
12:50:41 <xplat> i'm mostly a dog, but nobody on the internet knows
12:50:49 <pmetzger> xplat: what breed?
12:50:52 <obviouslytrivial> xplat: now we do
12:50:56 <obviouslytrivial> obviously
12:51:01 <Bfig> he's a yorkshire terrier i bet
12:51:02 <pmetzger> trivially!
12:51:07 <xplat> obviouslytrivial: that assumes you believe me
12:51:13 <Philippa> obviouslytrivial: no, we only suspect - we wouldn't know until we saw proof :-)
12:51:17 * obviouslytrivial glares at triviallyobvious 
12:51:27 <obviouslytrivial> Philippa: I can't think of anything else he could be, so he must be a dog
12:51:29 * triviallyobvious glares at obviouslytrivial
12:51:41 <obviouslytrivial> :)
12:51:41 <Philippa> he could be a yo-yo?
12:51:43 <Bfig> but it's undecidable... unless we get a cam.
12:53:11 <pmetzger> my cat has the hiccups. obviously from reading this conversation. I blame all of you.
12:53:17 <Philippa> re arithmetic and exponential: H-M inference is exponential too, except it's linear in the size of the types involved. Is there an equivalent property for presburger arithmetic?
12:53:17 <crystal-cola> lol
12:53:46 <tomwys_> Can I retrieve constructor used to create some object?
12:54:15 <Philippa> tomwys_: Could you rephrase that? We don't have objects in haskell, for the most part
12:54:16 <pmetzger> tomwys_: what do you mean by "retrieve"? you can pattern match on it...
12:54:20 <crystal-cola> tomwys_: you probably need an equivalent of map
12:54:25 <Philippa> and what pmetzger said
12:54:29 <crystal-cola> to e.g. change  Just 3 into Just "three"
12:55:50 <monochrom> pmetzger: in practice what we measure is: we try it (a verifier) on toy programs and it takes just a few seconds, then we try it on some real code (like part of linux kernel) and it takes maybe 5 minutes or maybe 2 hours, and it's already a very short time because the verifier finds 5 new bugs that have been lurking for 2 years. so we are talking about hours vs years, doubly exponential is still faster than human code review
12:55:54 <tomwys_> data FooBar = Foo String | Bar Int | ...; getConstructorName :: FooBar -> String; getConstructorName (Foo_) = "Foo"; ...
12:56:09 <tomwys_> I want to generate something like getConstructorName automatically from FooBar
12:56:23 <dmwit> tomwys_: How about deriving Show?
12:56:27 <dmwit> That's pretty automatic.
12:56:32 <xplat> tomwys_: add deriving (Data, Typeable)
12:56:37 <Philippa> you get the constructor's children too, though
12:56:49 <dmwit> Yes.
12:56:53 <pmetzger> monochrom: I violently agree, but the problem is, if it goes too far and it takes 3 years to find a bug that has been lurking for 2 years it isn't as useful.
12:57:09 <monochrom> I don't think that will happen
12:57:17 <xplat> (and {-# LANGUAGE DerivingDataTypeable #-} at the top of the file)
12:57:22 <dmwit> I would also point out that this is something of a code smell. It's a weird thing to want, which suggests that there may be a better way to achieve your top-level goal.
12:57:50 <pmetzger> monochrom: not my field. not even my ring. I have to take your word for it.
12:58:01 <monochrom> real code complexity is ceillinged by human coders' insistence on "human-readable", and I feel that such ceiling has already been hit.
12:58:51 <robnik> What is the meaning of the Functor instance for [::] ?   Or rather, what is [::] ?   I didn't think of it as a type.
12:58:55 <djahandarie> dons, new hostmask?
12:59:16 <monochrom> the whole "human-comprehensible" koolaid means that code is modularized to a very large degree but each module is dumbed down to a large degree. this is a piece of cake for even doubly exponential decision procedures 
12:59:21 <xplat> robnik: that's DPH, isn't it?  (Data Parallel Haskell)
12:59:29 <copumpkin> yeah
12:59:31 <copumpkin> parallel arrays
12:59:34 * djahandarie suggests a @haskell/... hostmask
12:59:51 <Philippa> monochrom: only until they interact in some weird way that got left out of the axiomatisation, though
13:00:29 <pmetzger> anyway, having made a fool of myself earlier, what's the correct compact way to say "if types are arbitrary propositions it can be undecidable to show that a piece of arbitrary code meets the type"
13:00:40 <robnik> Ah, okay.  
13:01:22 <Philippa> the real solution is "don't write arbitrary, unannotated code", of course
13:01:28 <pmetzger> not my question.
13:01:39 <pmetzger> I'm trying not to say it incorrectly in the future.
13:02:09 <Philippa> Rice's Theorem is probably the one you want?
13:02:23 <pmetzger> again, not my question. :)
13:02:39 <monochrom> no, interaction complexity is also indirectly bounded
13:03:23 <Philippa> (technically it applies to 'functions' rather than arbitrary code, but arbitrary code isn't necessarily any better annotated than being a raw function)
13:03:35 <monochrom> in practice, weird unknown interactions are still found by verifiers efficiently, i.e., within hours
13:03:36 <crystal-cola> I don't understand Rices theorem
13:03:54 <pmetzger> Rice's theorem is a generalization of Turing's, Godel's etc.
13:04:04 <pmetzger> what don't you understand?
13:04:14 <crystal-cola> I read it like "predicates on turing machines are trivial or undecidable"
13:04:15 <Philippa> yeah, it says you're SOL for a much wider range of propositions (which he happens to call 'interesting')
13:04:23 <Philippa> (or 'non-trivial' or...)
13:04:33 <crystal-cola> does it mean on the source code of turing machines?
13:04:38 <crystal-cola> its vauge
13:04:45 <pmetzger> "source code" = turing machine
13:04:48 <Philippa> it really means on any arbitrary computable function
13:05:05 <Philippa> doesn't matter how it's encoded, so long as the structure you're looking at is fundamentally a function
13:05:12 <pmetzger> a turing machine is just a way of mechanizing the idea of "computable function"
13:05:14 <crystal-cola> if it's just "given a possibly non-terminating algorithm" .. then the theorem is trivial?
13:05:15 <Philippa> (if it's fundamentally a function+big proof, that's different)
13:05:25 <crystal-cola> because you can't run the bloody thing without getting sucked into a loop
13:05:27 <pmetzger> a trivial property is true of all functions or of none
13:05:45 <pmetzger> any property true of only some computable functions is non-trivial
13:05:59 <Philippa> crystal-cola: it's not quite trivial even given turing, you have to show that you'd /have/ to run it to find out
13:06:01 <crystal-cola> if you're given the source code of a turing machine then "has source code length > 10 lines" is a non-trivial relation
13:06:16 <pmetzger> "does the input function halt on all inputs" is an example of a non-trivial property
13:06:29 <Philippa> crystal-cola: properties of the machine's behaviour, not of the source per se
13:06:58 <crystal-cola> so the predicate is defined on the source code of a turing machine and has to respect extentional equivalence of programs?
13:07:03 <Philippa> you can inspect it, but the proposition needs to be one that applies equally to arbitrary denotation-preserving transformations
13:07:18 <pingveno> Is Mu@i.a@ib something that is significant in Haskell? One of my profs that has a hardon for Haskell used it in class, but I can't find the syntax anywhere.
13:07:33 <pmetzger> crystal-cola: read a proof of Rice's theorem and you will understand it better.
13:08:00 <monochrom> I have never seen "Mu@i.a@ib"
13:08:02 <crystal-cola> do you know the answer to my q? 
13:08:12 <dmwit> pingveno: Well, Mu, @, i, ., a, and ib are all valid syntax. But the way you put them together is somewhat nonsensical.
13:08:33 <Philippa> yeah, i.a isn't a valid pattern
13:08:35 <pingveno> So apparently my prof is trolling the class...
13:08:40 <dmwit> Philippa: sure it is
13:08:47 <monochrom> there are, actually, many substandard profs who have a hardon for haskell
13:08:53 <pmetzger> crystal-cola: it is prhased formally about what languages a TM recognizes, not about the TM itself
13:08:58 <Philippa> dmwit: oh, are non-Constructor module names legit?
13:09:00 <copumpkin> > let f (mu@i:a@ib) = (mu, i, a, ib) in f [1..5]
13:09:01 <lambdabot>   (1,1,[2,3,4,5],[2,3,4,5])
13:09:05 <copumpkin> almost :)
13:09:15 <crystal-cola> so why isn't "source code is longer than 10 lines" a non-trivial predicate?
13:09:17 <Philippa> (if so, they... shouldn't be)
13:09:17 <pmetzger> crystal-cola: the formal phrasing makes it clear what applies and what doesn't.
13:09:25 <pmetzger> crystal-cola: read a formal statement of the theorem.
13:09:27 <dmwit> > let mu@i.a@ib = \x -> i (a x) in concat . map return $ [1, 2, 3]
13:09:28 <lambdabot>   [1,2,3]
13:09:36 <dmwit> perfectly cromulent
13:09:40 <pmetzger> crystal-cola: here:
13:09:42 <crystal-cola> I stated it above
13:09:45 <pmetzger> Let S be a set of languages that is nontrivial, meaning
13:09:45 <pmetzger> there exists a Turing machine that recognizes a language in S
13:09:45 <pmetzger> there exists a Turing machine that recognizes a language not in S
13:09:46 <pmetzger> Then, it is undecidable to determine whether the language decided by an arbitrary Turing machine lies in S.
13:09:47 <crystal-cola> I claim the theorem is trivial
13:09:49 <pingveno> Oh, and it's supposed to be on the midterm.
13:10:02 <pingveno> The midterm that is in 30 minutes.
13:10:18 <dmwit> Philippa: ...and the answer to your question is no.
13:10:22 * pingveno -> studying
13:10:51 <pmetzger> crystal-cola: so as you can see, the question is phrased in terms of languages recognized by TMs, and thus it isn't an arbitrary predicate like "this turing machine uses the symbol G on its tape"
13:10:55 <Philippa> dmwit: what am I missing? It can't be function composition as a pattern, and I don't recall @ being legit outside patterns?
13:10:56 <monochrom> pingveno you're better off not quoting out of context if you mean business
13:11:07 <crystal-cola> oh I understand now
13:11:25 <dmwit> Philippa: mu@i.a@ib = ... is defining the function (.), using (mu@i) and (a@ib) as the patterns for its two arguments. =)
13:11:32 <Philippa> ... d'oh
13:11:32 <crystal-cola> so how do we prove it?
13:11:38 <pmetzger> diagonalization.
13:11:40 <Philippa> yeah, that's a "your professor is an arsehole" case :-)
13:11:45 <crystal-cola> okay
13:11:47 <pmetzger> almost like the way you prove the halting problem.
13:11:51 <crystal-cola> yeah
13:11:54 <pmetzger> read an article on it, it is very quick.
13:12:34 <pmetzger> wikipedia has a good article which does a reduction to the halting problem.
13:12:49 <pmetzger> or rather!
13:12:54 <pmetzger> a reduction FROM the halting problem.
13:13:41 <pmetzger> that is, if I can solve the problem posed in Rice's Theorem I can solve the halting problem, so I can't solve the problem posed by Rice's Theorem.
13:14:22 <pmetzger> go read it, it is easier than my inexpertly butchering an explanation.
13:15:02 <edwardk> halting is vastly overrated ;)
13:16:08 <edwardk> i propose the 'boredom problem'. which states the computer will run the algorithm until i get bored enough to turn it off. so under those conditions, will it terminate before i get bored?
13:16:18 <dmwit> unrestricted recursion is vastly overrated
13:16:49 <pmetzger> bounded loops. our languages should only allow bounded loops.
13:16:54 <c_wraith> edwardk: do you call problems that you turn the computer off before solving boredom-complete or boredom-incomplete?
13:16:54 <pmetzger> nothing past the primitive recursive.
13:17:26 <monochrom> first you need to formalize edwardk :)
13:17:57 <crystal-cola> So the analogy is turing machines/languages <=> functional programs/(expressive) types    I guess?
13:18:09 <Philippa> yeah
13:18:17 * hackagebot mysql 0.1.0.0 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.0.0 (BryanOSullivan)
13:18:22 <crystal-cola> seems flawed
13:18:22 <pmetzger> monochrom: I am a finite automaton. I should be easy to formalize.
13:18:30 <Philippa> how so?
13:18:45 <Philippa> given a naive set-theoretic interpretation of "type" and "language" it's trivially true, for example
13:18:48 <crystal-cola> the type of a functional program can have a lot of logical structure to it, which can be used to guide the programmer (be they man or machine)
13:18:49 <edwardk> you are allowed to formulate a 'boredom oracle' that can work by taking measurements of my current blood sugar level, or by polling me with simple questionnaires, but the problem regresses, because i may get bored with the questionnaire and turn it off
13:18:50 <monochrom> you will not decide the language { 0^n 1^n | n natural } :)
13:18:51 <sm> would anyone know which exception or library is behind this message ? "getAddrInfo: does not exist (Name or service not known)"
13:19:03 <pmetzger> crystal-cola: http://en.wikipedia.org/wiki/Curry-Howard_correspondence
13:19:09 <Philippa> oh, right. It's not functional programs - it's /unannotated functions/
13:19:24 <sm> or how I could track it down other than downloading and grepping a bunch of packages ?
13:19:36 <Philippa> you can do type inference all you like, but even needing to go as far as arbitrary System F'll throw you and that's not even turing complete
13:19:46 * sm gets some ideas.. it never fails!
13:20:30 <monochrom> sm: likely some client-side socket connection that begins by dns lookup and fails?
13:20:38 <sm> yeah
13:20:56 <Philippa> crystal-cola: a program in, say, Coq is /not/ the same thing at all - it's merely something you can project a function from
13:21:17 <Philippa> and to that extent, yes, Rice's Theorem doesn't mean you can't provide code + proof
13:21:17 <sm> I'm trying to detect which particular exceptions are "permanent" and which "transient"
13:21:30 <edwardk> c_wraith: boredom-complete would be systems capable of running any program you could run on a turing machine that I know how to turn off
13:21:44 <Philippa> it just means generating the proof from scratch for an arbitrarily uncooperative program isn't any fun at all (or necessarily going to give you a result, ever)
13:21:45 <rata_> is there a function like "f Nothing = False; f Just _ = True"?
13:21:56 <pmetzger> edwardk: so is the trick to produce TMs you cannot turn off?
13:21:59 <edwardk> :t isJust
13:22:00 <lambdabot> forall a. Maybe a -> Bool
13:22:06 * copumpkin shudders
13:22:10 <copumpkin> the attack of the evil Bool
13:22:11 <c_wraith> edwardk: doesn't that reduce to "any program I can compile"?
13:22:26 <rata_> thanks edwardk
13:22:29 <edwardk> c_wraith: well turing completeness is a property of the machine, not the program
13:22:38 <c_wraith> oh
13:22:40 <c_wraith> I misread that
13:22:45 * monochrom hopes that edwardk's oracle has a fixed point
13:22:47 <pmetzger> copumpkin: Bool weevils?
13:22:55 <copumpkin> yep
13:23:02 * copumpkin applies insecticide 
13:23:08 <rata_> edwardk: I don't have isJust... is it part of a module?
13:23:14 <edwardk> Data.Maybe
13:23:29 <rata_> thanks
13:24:02 <edwardk> another version is (/= Nothing) -- but that only works if your contents are Eq'able.
13:24:44 <pmetzger> Every time I see the typeclass "Ix" I think of Dune. I have to wipe that out of my head.
13:24:48 <dmwit> Often you can get away without the boolean, though.
13:24:59 <copumpkin> always, I'd hope
13:25:04 <dmwit> if isJust x then foo else bar -> maybe (const foo) bar x
13:25:09 * copumpkin resumes his crusade against the evil Bool
13:25:18 <edwardk> :t (==0) . Data.Data.toConstr
13:25:19 <lambdabot>     No instance for (Num Constr)
13:25:19 <lambdabot>       arising from the literal `0' at <interactive>:1:3
13:25:19 <lambdabot>     Possible fix: add an instance declaration for (Num Constr)
13:25:26 * monochrom joins copumpkin
13:25:38 <copumpkin> we must travel far and wide
13:25:39 <dmwit> if isJust x then foo (fromJust x) else bar -> maybe foo bar x -- even more common
13:25:47 <edwardk> er woops
13:25:49 <copumpkin> dmwit: aaah
13:25:53 <navaati> :t Data.Data.toConstr
13:25:53 <lambdabot> forall a. (Data a) => a -> Constr
13:25:59 <monochrom> we must fight against lispism schemism
13:26:05 <edwardk> dmwit: fighting nausea now
13:26:34 <navaati> > Data.Data.toConst $ Just "onche"
13:26:34 <lambdabot>   Not in scope: `Data.Data.toConst'
13:26:36 <pmetzger> why are bools (we)evil?
13:26:42 <navaati> > Data.Data.toConstr $ Just "onche"
13:26:43 <lambdabot>   Not in scope: `Data.Data.toConstr'
13:26:49 <edwardk> dmwit: or more directly: maybe ;)
13:26:51 <dmwit> It has become a fad to love Prop over Bool.
13:27:02 <dmwit> edwardk: indeed =)
13:27:04 <astor> any ghc implementors here?
13:27:07 <pmetzger> any particular cause for the fad?
13:27:14 <dmwit> Bob Harper's blog
13:27:16 <copumpkin> dmwit: Prop?
13:27:23 <sm> "Performing hClose on a handle that has already been closed has no effect".. but when I do it I see  <stdout>: hPutStr: illegal operation (handle is closed) on console
13:27:24 <copumpkin> oh, I hated Bool long before it was cool to hate Bool
13:27:30 <copumpkin> </hipster>
13:27:31 <dmwit> copumpkin: data hipster
13:27:34 <edwardk> dmwit: copumpkin is an agda hipster
13:27:44 <copumpkin> dmwit: Dec seems closer
13:28:11 <aristid> sm: no material affect other than spamming stdout, i guess?
13:28:16 <aristid> -affect+effect
13:28:31 <dmwit> copumpkin: But also much less well-known, and so having less explanatory power. =P
13:28:32 <alderz> is there a function like a conditional map? I mean, only apply map when a given condition is true
13:28:52 <dmwit> :t \f p xs -> [f x | x <- xs, p x]
13:28:53 <lambdabot> forall t t1. (t -> t1) -> (t -> Bool) -> [t] -> [t1]
13:29:02 <copumpkin> dmwit: fair enough :)
13:29:12 <copumpkin> Either a (Not a) <- much better than Bool
13:29:15 <dmwit> :t \f p -> map f . filter p -- another possible meaning of that question
13:29:16 <lambdabot> forall a b. (a -> b) -> (a -> Bool) -> [a] -> [b]
13:29:32 <dmwit> err...
13:29:49 <alderz> I may have explained wrong, only apply when the condition is true, return unodified otherwise
13:29:51 <dmwit> :t \f p xs -> [if p x then f x else x | x <- xs] -- what I meant for the first meaning
13:29:52 <lambdabot> forall t. (t -> t) -> (t -> Bool) -> [t] -> [t]
13:29:52 * sm sees an opportunity to refine his types
13:30:22 <pmetzger> sm: does one use distillation or something closer to the Bessemer process?
13:30:30 <dmwit> alderz: That's just a map of a modified function. =)
13:30:49 <dmwit> alderz: (As demonstrated by that last list comprehension above.)
13:31:09 <sm> pmetzger: one uses emacs, of course
13:31:30 <pmetzger> sm: my favorite operating system.
13:31:32 <alderz> dmwit, thanks :-), that is what I was doing but I supposed that there was a better way
13:31:58 <pmetzger> I'm shocked that at this point someone hasn't produced an emacs-style editor using Haskell as the extension language.
13:32:01 <dmwit> :t guard
13:32:01 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
13:32:07 <dmwit> pmetzger: yi?
13:32:14 <pmetzger> there is one then.
13:32:50 <navaati> is yi usable ?
13:32:54 <pmetzger> wild.
13:33:28 <pmetzger> last post on the yi blog is over 2 years ago. hrm.
13:33:35 <navaati> hum… i'm a bit unsatisfied with leksah
13:33:54 <alpounet> leksah has really been getting better and better lastly
13:34:13 <navaati> yeah, i'm going to install the 0.10
13:34:35 <navaati> but it lacks things, like darcs management
13:34:38 <dmwit> yi lost momentum, yeah
13:34:48 <alpounet> i remember trying it when i started learning haskell, i just couldn't use it
13:34:55 <alpounet> but i quite liked the 0.10 yeah
13:35:04 <dmwit> Everybody said they wanted a Haskell-based editor, but it turned out they didn't, really.
13:35:16 <dmwit> People don't really know what they want -- no big surprise.
13:35:43 <navaati> dmwit: really ? what make you say that ? (the former statement, not the last :D)
13:36:27 <dmwit> Nobody uses yi.
13:36:29 <pmetzger> I'm used to emacs. I'm even used to the terrible extension language.
13:38:06 <tensorpudding> elisp isn't that terrible
13:39:15 <lispy> tensorpudding: dynamic scope, limited recursion depth, lack of threading, and inefficient interpreters kind of bug me.
13:39:30 <pmetzger> the inefficiency doesn't matter
13:39:32 <tensorpudding> the lack of good concurrency is a huge problem
13:39:47 <tensorpudding> but can be avoided by not using blocking applications
13:39:48 <pmetzger> the dynamic scope, lack of proper tail recursion, no threading, no proper namespace management
13:39:51 <tensorpudding> or anything that's unstable
13:39:51 <pmetzger> those are all sucky
13:40:12 <tensorpudding> for this reason among many others, i refrain from using gnus or erc
13:40:14 <alpounet> lispy, what do you use when programming in Haskell ?
13:40:21 <alpounet> (i mean, which editor)
13:40:26 <pmetzger> I used gnus as my mail reader for a decade or so.
13:40:34 <pmetzger> it was hard to escape.
13:40:46 <tensorpudding> the first time i tried gnus it caused my emacs to crash with unsaved data, and i was furious
13:41:04 <pmetzger> never had that.
13:41:07 <pmetzger> or anything quite like it.
13:41:34 <tensorpudding> over time, i've decided to pare everything from my emacs that wasn't related to coding
13:42:07 <tensorpudding> well, not true, i still use org mode for one thing, and the calculator
13:42:23 <lispy> alpounet: all of them?
13:42:41 <lispy> alpounet: I use emacs and vim primarily.
13:43:35 <lispy> tensorpudding: I use workflowy.com instead of org mode
13:43:46 <alpounet> ok
13:44:04 <tensorpudding> i don't think that's what i want
13:44:06 <lispy> alpounet: I sometimes use both of them in the same session
13:44:29 <tensorpudding> the thing i use org mode for is an ad-hoc encrypted password table
13:44:42 <lispy> I used to do everything in emacs.  But, I think I'm like tensorpudding in that I found I didn't like that.
13:45:00 <tensorpudding> my .emacs is still huge though
13:45:05 <tensorpudding> about 500 lines
13:45:14 <lispy> I used to do email, IRC, newsgroups, editing, and shell commands all from emacs.
13:45:34 <alpounet> never been *that* far with emacs
13:45:58 <tensorpudding> i still use eshell
13:46:13 <tensorpudding> it integrates with ecb
13:46:23 <adnam> i stopped using eshell for some reason, don't remember
13:47:04 <shachaf> ~111222
13:47:35 <lispy> alpounet: I even started writing my own elisp compiler at one point.  Never finished it though.
13:47:45 <lispy> alpounet: my goal at that time was to provide elisp support for yi
13:47:54 <shachaf> Ahem.
13:48:11 <Locke1689> sup erybody
13:48:45 <tensorpudding> a dozen or so major modes, auctex, proof general, linum, column-marker, color-theme, cedet/ecb, epa, midnight, yasnippet, flymake, nxhtml, magit, custom keybindings
13:49:24 <monochrom> proof general is very cool :)
13:49:32 <beastaugh> Locke1689: Two Treatises fan?
13:49:46 <Locke1689> beastaugh: Yup :)
13:50:04 <Locke1689> not just the two treatises though
13:50:18 <Locke1689> he published most of his seminal works in 1689
13:50:32 <tensorpudding> i haven't used proof general recently
13:50:40 <tensorpudding> it was a bit fiddly when i was messing with coq
13:51:45 <alpounet> lispy, so your ideal editor would be along the lines of yi
13:51:49 <alpounet> but pushed further
13:54:08 <lispy> alpounet: how is that?
13:54:31 <alpounet> lispy, that was a question
13:54:42 <alpounet> (yeah, forgot the question mark)
13:54:50 <lispy> alpounet: For me, ubiquity and default settings matter a lot these days.  I deliberately stop myself from the configuration ad naseum
13:55:23 <lispy> alpounet: I in part learned vim so that I can have an editor on just about any machine I connect to that is running linux
13:55:45 <alpounet> yeah ok
13:55:56 <lispy> I intentionally stay away from all the advanced editor features.  As soon as I learn them I seem to get forced into using something that doesn't have it :)
13:56:15 <lispy> best to just be adaptable
13:56:29 <lispy> (but, I know lots of folks who would disagree with that)
13:56:41 <sgronblo> yeah if you use both, it makes it sound like you know neither at a high level
13:57:23 <Locke1689> lispy: I have a highly configured Vim experience, but I also have no problem working in basic Vi when I have to. I think it's the best of both worlds
13:59:22 <lispy> sgronblo: I know emacs quite well but vim less so.  In vim I know enough to do the day to day editing, like selections, input modes, and navigation, but advance stuff like macros are unfamiliar to me.
13:59:36 <lispy> I have been meaning to learn them a bit
13:59:45 <lispy> but, I tend to wait till I have a need :)
14:00:57 <rata_> how do I import Observe in ghc?
14:01:40 <monochrom> ":m + Observe" or "import Observe"
14:02:31 <Kazuo> would anyone happen to know about the status of the GpuGen project?
14:02:31 <Kazuo> http://corp.galois.com/blog/2008/8/29/bringing-the-power-of-gpus-to-haskell.html
14:02:42 <rata_> monochrom: it says it couldn't find the Observe module
14:02:59 <Kazuo> I can only seem to find a set of slides from 2008, and a paper published in 2009
14:05:06 <jgrimes> What is generally considered the best matrix/linear algebra package?
14:05:09 <navaati> there is GPipe
14:05:33 <navaati> (in response to Kazuo, not jgrimes)
14:05:34 <monochrom> I don't know which package has Observe. I thought you already installed it.
14:06:18 <Kazuo> ooh, thanks navaati!
14:12:41 <navaati> Kazuo: i found it a bit limited : for example if I remember well, there are no conditionnal tests, and of course no Haskell features like pattern matching since it doesn't really compile haskell for GPUUs
14:15:34 <Kazuo> navaati: anything out there that does really compile Haskell for GPUs?
14:19:35 <Kazuo> I suppose there's this: http://www.eecs.harvard.edu/~mainland/projects/nikola/
14:22:34 <thoughtpolice> Kazuo: the accelerate package works for that purpose
14:22:37 <thoughtpolice> @hackage accelerate
14:22:38 <lambdabot> http://hackage.haskell.org/package/accelerate
14:22:54 <thoughtpolice> currently CUDA only, although I think there are plans are for an opencl backend too
14:23:55 <rata_> monochrom: I don't know what package does it have it... I just following the instructions here: http://www.haskell.org/haskellwiki/Debugging
14:26:04 <monochrom> I wonder what "A more powerful alternative for this approach is Hood. Even if it hasn't been updated in some time, Hood works perfectly with the current ghc distribution. Even more, Hugs has it already integrated, see the manual page." means
14:31:09 <o1iver> hi
14:31:46 <jmcarthur> hi
14:32:28 <o1iver> which of these is better "form" (or just least supid :-p): ['c'] ++ "ba" || "c" ++ "ba" || 'c' :: "ba" (my guess the last)
14:32:39 <o1iver> out of interest
14:32:47 <tommd> 'c' : "ba" is the most basic
14:32:58 <ezyang> "c" ++ "ba" is not too bad. 
14:33:11 <hpc> 'c':"ba" is the most reduced
14:33:11 <tommd> But defined in terms of cons.
14:33:12 <ezyang> And I'm pretty sure they'll get optimized to be the same thing. 
14:33:21 <tommd> yes, agreed
14:33:22 <Nereid> o1iver: if, conceivably, you might want to replace "c" with a longer string later, then I'd put "c"
14:33:34 <o1iver> yeah that makes sense
14:33:51 <Nereid> if you know you're just adding a single character, 'c' is fine
14:33:55 <ion> For arbitrary strings, difference lists may be a good fit.
14:34:04 <o1iver> it asked myself because I thought this ( 'a' : f a ++ "bdede") looked strange
14:34:39 <o1iver> i would have written "^" ++ f a ++ "bdede"
14:34:42 <hpc> o1iver: it's kind of hard to write natural-looking string code
14:34:48 <dfff> can I run java from haskell? (and get some values back from java into haskell)
14:34:52 <Nereid> o1iver: if you prefer the latter, go ahead :>
14:35:10 <hpc> dfff: does it have to perform even remotely well?
14:35:16 <o1iver> I am starting off so I don't want to get into bad habits right away :-p
14:35:36 <dfff> hpc: well yes actually, I need access to a database, and that database only has a java api
14:35:43 <o1iver> i will go with ++s :-)
14:35:46 <o1iver> cheers
14:36:28 <hpc> dfff: then... i don't know
14:36:45 <hpc> dfff: if the api is open source, you might be able to duplicate the functionality in haskell
14:37:01 <o1iver> dfff, what kind of database is it (out of interest)...
14:37:16 <dfff> hpc: with duplicate, you mean writing c code? (database is orientdb)
14:56:42 * hackagebot blaze-textual 0.1.0.0 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.1.0.0 (BryanOSullivan)
14:56:44 * hackagebot aeson 0.3.2.5 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.3.2.5 (BryanOSullivan)
15:10:44 * hackagebot kit 0.7.0 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.0 (NickPartridge)
15:22:55 <navaati> how does work branching with darcs ?
15:23:06 <o1iver> hi guys, i am confused by why I can access functions from a module although they are not exported from the module (ie. not in module XX (<here>))? Here is the paste: http://hpaste.org/46134/p1
15:23:34 <o1iver> and for some reason in ghci i can access globToRegex'
15:23:42 <o1iver> and escape etc...
15:24:03 <monochrom> when your module is interpreted, unexported things are accessible, to help you test internals
15:24:29 <o1iver> monochrom: ah ok, but if its compiled they wont be accessible...
15:24:43 <o1iver> makes sense
15:24:43 <o1iver> thx
15:25:10 <jmcarthur> navaati: you just clone the repo, and that's a branch
15:25:17 <jmcarthur> navaati: it's not in-place like git
15:26:52 <navaati> so i only must "cd ..; mkdir myproject-ZEbranch; cd myproject-ZEbranch; darcs get ../myproject" ?
15:28:19 <navaati> and pull from the HEAD in my branches to get new modifs in them ? hum, interesting…
15:30:37 <jmcarthur> navaati: i would just cd ..; darcs clone myproject mybranch
15:30:51 <navaati> ah, there is a darcs clone
15:30:55 <navaati> ok, thanks
15:34:47 <gio123> can one help me to undestand confluence proof?
15:36:27 <navaati> WTH, xmonad just crashed oO
15:36:47 <c_wraith> blame it on a native binding.  it's the haskell way!
15:36:52 <c_wraith> :)
15:37:44 <navaati> oh, no, it's that my $HOME disk is having problems… un-reliable usb hard disks -_-
15:38:18 <navaati> excuse me you St. xmonad-spirit for blaming you
15:38:59 <T_S_> anybody using haskell/haskell platform on ubuntu 11 (natty)?
15:39:03 <c_wraith> native binding to the filesystem!
15:39:36 <navaati> c_wraith: exactly, we should all live in a pure functionnal lazy world
15:46:49 * hackagebot FileManipCompat 0.17 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/FileManipCompat-0.17 (ThomasHartman)
15:47:26 <gio123> is there chanel abou lambda calculus?
15:47:54 <ezyang> ...#haskell? :-) 
15:48:18 <ezyang> I think most of us will happily answer questions about the lambda calculus. 
15:51:15 <aristid> ezyang: "most" is probably a dangerous generalization already.
15:51:50 <ezyang> heh. 
15:56:25 <elliotstern> I'm trying to write a function that generates the "group" a game piece is in, where a group is a collection of connected pieces of a given color.  I wrote a function, and tried testing it, but it just maxed out my cpu for about 30 seconds before I killed it, so I assume I've got some sort of infinite loop.  I'm trying to do a depth-first search of the neighbors of a piece, using foldl to...
15:56:27 <elliotstern> ...thread the collected group in the recursion.  http://hpaste.org/46136/accidental_infinite_recursion  
15:57:22 <ezyang> group as a list is a super-inefficient way of keeping track of handled points. 
15:57:54 <elliotstern> You would suggest a tree or set?
15:58:19 <elliotstern> Still, do you see where I'm going wrong in the algorithm?
15:58:23 <ezyang> A set. 
15:58:40 <ezyang> I assume you're using small test input? 
15:58:54 <ezyang> are points neighbors of themselves? 
15:59:06 <elliotstern> no
15:59:16 <elliotstern> it's a 4x11 group, so there's 44 members
15:59:27 <elliotstern> i.e. a 4x11 block of peices
15:59:33 <ezyang> isInGroupAndNotYetVisited is named strangely. 
16:00:00 <elliotstern> I couldn't think of a better name.  Any ideas?
16:00:05 <ezyang> oh, should be ok. 
16:00:53 <ezyang> You fail to propagate neighborsInGroup correctly. 
16:00:55 <elliotstern> What's that old quote?  "The only hard problem in CS is naming things", or something like that? :p
16:00:58 <elliotstern> ah
16:01:20 <ezyang> erm, curGroup, I meancrerm. 
16:01:23 <ezyang> *erm. 
16:02:53 * hackagebot FileManipCompat 0.18 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/FileManipCompat-0.18 (ThomasHartman)
16:03:49 <ezyang> I think the code is correct, just really inefficient. 
16:04:00 <ezyang> have you tried a super small input? 
16:04:07 <ezyang> What is the representation of Board? 
16:04:15 <elliotstern> I'll go try it now
16:04:20 <ezyang> Have you tried tracing the function? 
16:04:56 <elliotstern> Board is a IntMap Maybe Color, mostly
16:05:09 <jgrimes> What is generally considered the best matrix/linear algebra library?
16:05:15 <volko> anyone here tried adding color to their ghci prompt?
16:05:18 <volko> It is messing up readline pretty bad
16:06:22 <ezyang> Anwyay, I think tracing will definitively settle if it's looping or just really inefficient. 
16:06:32 <tromp_> my haskell Go code determines connected groups
16:06:39 <ezyang> But based on reading the code I don't see anything obviously wrong. It's written a little strangely. 
16:07:06 <c_wraith> tromp_: does it also identify live groups?
16:07:12 <Saizan> volko: it's using haskeline if it's a recent version
16:07:32 <volko> Ah, ok
16:07:38 <volko> well it's messing it up regardless
16:07:41 <tromp_> no, it only implements rules, and live is not part of that:(
16:08:28 <elliotstern> Well, if you implement the rules, you're 90% of the way to a simple monte-carlo program
16:09:39 <tromp_> i think i'm only10% of the way:(
16:10:01 <elliotstern> Do you understand the basic monte-carlo algorithm?
16:10:11 <tromp_> sure
16:10:45 <tromp_> make random playouts; pick most frequently winning first move
16:11:17 <tromp_> a good algorithm would build a UCT tree on top
16:11:26 <c_wraith> does help that there are varying levels of liveness.  alive no matter what, alive if you make one move for each move your opponent attacks with, alive if you start responding to your opponents attacks eventually, etc.
16:11:33 <c_wraith> err, *doesn't
16:11:41 <elliotstern> If your candidate move selection is just picking a random empty spot (and making sure it isn't illegal), you don't need much more than that
16:12:04 <elliotstern> Well, there are various statuses, too
16:12:05 <tromp_> you do at least need to avoid filling in single point eyes
16:12:09 <c_wraith> huh.  Is it legal to play in an eye for no gain?  I suppose it is
16:12:16 <c_wraith> yay for -1 pt plays!
16:12:18 <elliotstern> Living and dying with sente, for one
16:12:30 <elliotstern> All you need to do is score using chinese rules
16:12:42 <c_wraith> well.  - opportunity cost, then
16:12:43 <elliotstern> then playing in your territory is a net wash
16:12:47 <ezyang> c_wraith: Might be useful if you need to stall. 
16:12:54 <c_wraith> ezyang: you can always pass
16:13:02 <ezyang> oh, that's right 
16:13:08 <elliotstern> The game ends when two players pass in succession
16:13:18 <tromp_> i was talking about polaying in your own eye
16:13:28 <c_wraith> oh, yeah, that's quite a lot worse
16:13:30 <tromp_> playing in opponent eye would be illegal
16:13:31 <elliotstern> Tromp_: I assume you play go?
16:13:42 <tromp_> yes, i do
16:13:48 <c_wraith> playing a piece in an opponent's eye isn't illegal, it just gets self-captured
16:13:56 <c_wraith> so it's dumb
16:13:59 <c_wraith> but not illegal!
16:14:03 <tromp_> that would repeat the position
16:14:08 <tromp_> which superko forbids
16:14:19 <c_wraith> not really
16:14:26 <c_wraith> not if other moves have been made on the board
16:14:31 <c_wraith> oh
16:14:32 <c_wraith> I see
16:14:35 <c_wraith> you're right
16:14:49 <c_wraith> It repeats the turn previous
16:14:57 <tromp_> yes, a 1-cycle
16:15:23 <tromp_> it would be allowed under situational superko
16:15:35 <elliotstern> Playing a peice in an opponents eye is illegal because the stone would be captured 
16:15:37 <tromp_> which is one more reason to prefer positional superko:)
16:15:43 <Saizan> i thought japanese rules considered any kind of suicide illegal
16:15:44 <elliotstern> and you're not allowed to cause yourself to be captured
16:15:57 <elliotstern> Japanese rules do disallow suicide
16:16:09 <elliotstern> at any rate, here's a simple eye-algorithm
16:16:12 <tromp_> but japanese rules have many other problems
16:16:20 <tromp_> they're somewhat ill-defined
16:16:28 <elliotstern> ;; stupid definition of an eye.  Guarenteed to be an eye, but not all eyes will;; register.  takes a liberty and a player whose eye it can be
16:16:29 <elliotstern> (defmethod eyep ((b board) point player)
16:16:31 <elliotstern>   (let* ((neighbors (get-neighbors point))
16:16:32 <elliotstern>         (diagonals (get-diagonals point))
16:16:34 <elliotstern>         (color-neighbors (intersection neighbors
16:16:35 <elliotstern>                                        (players-stones b player)))
16:16:37 <elliotstern>         (color-diagonals (intersection diagonals
16:16:38 <elliotstern>                                        (players-stones b player))))
16:17:10 <monochrom> eye and go and lisp. I must be in the wrong channel
16:17:44 <monochrom> do you know of a good haskell channel I can go to? :)
16:17:44 <elliotstern> Do you play on kgs at all, Tromp?
16:17:45 <c_wraith> the japanese rules are inconsistent in many cases involving bad play
16:17:45 <o1iver> monochrom: haha
16:17:58 * hackagebot happstack-helpers 0.53 - Convenience functions for Happstack.  http://hackage.haskell.org/package/happstack-helpers-0.53 (ThomasHartman)
16:17:59 <tromp_> i'm an admin on kgs
16:18:12 <elliotstern> Oh, cool
16:18:17 <dibblego> is there a way to write MaybeT and Maybe such that type Maybe a = MaybeT Identity a?
16:18:20 <tromp_> although i rarely login as admin:(
16:18:33 <elliotstern> I kinda let my account expire, but I recently renewed it
16:18:46 <c_wraith> dibblego: I would assume so
16:18:47 <elliotstern> I'm a member of the Empty Sky club, if you're familiar with us
16:18:57 <djahandarie> dibblego, does the existing MaybeT not do that?
16:19:03 <c_wraith> dibblego: though you'd have to change the definition of MaybeT to not depend on Maybe :)
16:19:05 <tromp_> your getGroup code looks a little convoluted
16:19:09 <dibblego> djahandarie: no, it uses m (Maybe a)
16:19:24 <monochrom> to define Maybe, you must first define Maybe?
16:19:25 <elliotstern> Any suggestions on how to rewrite it simpler?
16:19:27 <djahandarie> Ah.
16:19:30 <dibblego> c_wraith: right, I could do it with rank-n types I suppose, but is there a better way?
16:19:35 <tromp_> compare with my code at http://homepages.cwi.nl/~tromp/go/Go.hs
16:19:39 <c_wraith> dibblego: CPS it?
16:19:45 <dibblego> monochrom: StateT doesn't require State, why does MaybeT require Maybe?
16:19:50 <dibblego> c_wraith: right, but ick
16:20:05 <djahandarie> What is that ick?
16:20:06 <monochrom> StateT requires -> and (,)
16:20:07 <djahandarie> Why*
16:20:23 <djahandarie> Try using Codensity for the CPS transform
16:20:30 <dibblego> well, it's ick for me because I am using  language for which rank-2 is a PITA
16:20:30 <djahandarie> ...I don't know if that'd work well or not
16:21:09 <dibblego> {-# LANGUAGE RankNTypes #-} newtype MaybeT m a = MaybeT (forall x. m ((a -> x) -> x -> x))
16:22:00 * hackagebot kit 0.7.1 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.1 (NickPartridge)
16:23:30 <monochrom> @unmtl StateT Int IO Bool
16:23:30 <lambdabot> Int -> IO (Bool, Int)
16:23:34 <beherit> having some trouble with utf-8 data and getArgs: i start my application with an "å" as the only argument and then putStr it. It's garbage. `locale` reports sv_SE.UTF-8 for all entries though. anything i can test?
16:23:58 <monochrom> @unmtl WriterT Int IO Bool
16:23:58 <lambdabot> IO (Bool, Int)
16:24:46 <monochrom> newtype MaybeT m a = MaybeT (m (Either () a))
16:25:07 <dibblego> ok I get the point, thanks
16:30:16 <monochrom> beherit: ghc version? os?
16:30:28 <dfff> hi, so I know almost nothing about haskell yet, but before I go into it, one thing: Can I autoformat code? 
16:30:29 <ezyang> Uff. Text for garbage collection comic is done, now I just have to draw the pictures ^_^ 
16:30:37 <djahandarie> ^_^
16:30:38 <ezyang> dfff: Yes! 
16:30:46 <ezyang> -ddump-parsed, I think. 
16:30:47 <monochrom> also there is terminal setting of your xterm or rvxt or ...
16:30:51 <dfff> ezyang: Awesome, which IDE are you using?
16:31:06 <ezyang> "GHC" 
16:31:26 <ezyang> type unformatted code, and then ask GHC to pretty-print it for you. 
16:31:45 <dfff> but it will just print it into the console won't it?
16:31:49 <monochrom> typing unformatted code by hand is horrible and tricky
16:31:50 <dons> http://www.haskell.org/haskellwiki/Indent 
16:31:51 <ezyang> Yes. 
16:32:46 <monochrom> example: do { m0; let { x = 0 }; m1 }  <--- most people forget the inner {} and scratch head for hours
16:32:49 <dfff> monochrom: woooooooow, what do you mean? does autoformating work well or not so well?
16:33:04 <monochrom> I mean what I say.
16:33:25 <monochrom> I could repeat what I say if you like
16:33:34 <dfff> it was ambiguous
16:33:50 <dfff> so repetition wouldnt solve anything
16:34:26 <monochrom> sorry, I don't see an ambiguity. perhaps you could point it out
16:34:34 * BMeph thought that repetition was the mother of learning. BMeph is confused, now...
16:34:35 <ion> Ooh, -ddump-parsed works very nicely in ghci, too.
16:34:49 <dfff> how do you define: "horrible and tricky"
16:35:02 <beherit> monochrom: ghc 7.0.3, os x snow leopard
16:35:05 <ion> It would be nice if it showed precedence with parentheses, too.
16:35:11 <monochrom> tricky means error-prone. I just showed an example
16:35:19 <monochrom> horrible means a lot of work
16:35:33 <monochrom> and ugly
16:36:03 <dfff> so I have to deduce that auto formating doesnt work properly
16:36:17 <dfff> otherwise you would hardly describe it as a lot of work to type unformatted
16:36:20 <ezyang> ion: I think it would... 
16:36:45 <ezyang> oh, it's too early in the chain. 
16:37:14 <dfff> correct?
16:37:27 <beherit> monochrom: utf-8 input works in other applications as far as i can tell, but that might not count for anything
16:38:10 <monochrom> indeed, autoformatting is provably impossible. since you're sensitive to ambiguity, I'll show you a paste of an example of ambiguity the computer would encounter when trying to autoformat
16:38:44 <kfish> m3ga, wanna try posting some of the enumerator stuff you've tried (re: haskell-cafe)
16:39:19 * kfish is in the mood for some incremental processing
16:40:02 <m3ga> kfish, you mean here? or rather a hpaste?
16:40:18 <m3ga> or emailed to you?
16:40:52 <monochrom> http://hpaste.org/46140/ambiguity shows two valid formattings with different semantics. formatting is undecidable.
16:40:58 <kfish> m3ga, hpaste :)
16:42:59 <tauntaun> Suppose I have modules A.B (A/B.hs) and C.D (C/D.hs).  How do I get C.D to import A.B?
16:43:24 <Saizan> import A.B
16:43:29 <tauntaun> doesn't work
16:43:39 <Saizan> make sure you've module A.B where in B.hs
16:43:49 * BMeph wagers that tauntaun...is doin it robg...
16:43:51 <Saizan> and that your CWD is on top of both A and C
16:44:02 * BMeph meant "RONG"!
16:44:11 <dfff> monochrom: Thanks, I think this is fine as long as it formats whitespace correctly. (if I put too much indention, it should remove it - even if the whitespace would be legal)
16:44:26 <Saizan> or that you use -i to specify the searchpaths explicitly
16:44:34 <m3ga> i have some code that works here : http://hpaste.org/46141/nee_to_make_thismore_lazy
16:44:36 <monochrom> beherit: interesting, I can reproduce the effect on linux, utf-8 environment too
16:44:38 <tauntaun> Saizan: I've never seen the "in B.hs" syntax in a module declaration...I'll look it up.
16:44:55 <Saizan> tauntaun: in B.hs was part of the sentence
16:45:06 <monochrom> I will call it a bug of getArgs. I know how it comes to this
16:45:17 <Saizan> tauntaun: "module A.B where" is what you need to have in B.hs
16:45:30 <m3ga> its a simple http proxy. current problem is that the response isn't generated until the download is complete.
16:45:53 <beherit> monochrom: http://hackage.haskell.org/trac/ghc/ticket/3307 that might apply
16:45:59 <tauntaun> Saizan: I see....and I already have that...and ghci can't find the module.
16:46:22 <monochrom> yeah
16:46:33 <Saizan> tauntaun: so the problem is the searchpath probably
16:47:02 <Saizan> tauntaun: are both A and C in the same directory? did you start ghci from there?
16:47:31 <tauntaun> Saizan: I can make it work if I run ghci in the directory that A and C are in.  Is this a necessary condition for success?
16:48:03 <Saizan> tauntaun: the other possibility is to start ghci with -i path/to/that/directory
16:48:17 <tauntaun> ok...grazie
16:49:07 <m3ga> kfish: just corrected it
16:49:10 <Saizan> np
16:51:17 <kfish> m3ga, what does a ResponseEnumerator do?
16:52:20 <m3ga> kfish: its one of the constructors for Wai.Response. see http://hackage.haskell.org/packages/archive/wai/0.4.0/doc/html/Network-Wai.html#t:Response
16:52:26 <kfish> ta
16:53:08 <gwern> > (200*100)/178
16:53:09 <lambdabot>   112.35955056179775
16:53:21 <gwern> > (200*200)/315
16:53:21 <lambdabot>   126.98412698412699
16:55:39 <beherit> monochrom: seems like people are working on it. import System.Environment.UTF8 (getArgs) works fine.
16:57:14 <m3ga> kfish: you'll need to cabal install wai, warp and http-enumerator. that lot has a huge bunch of dependencies so you have time to get coffee :-)
16:57:51 <kfish> heh :)
16:58:02 <kfish> used to it ... we're using snap here, which has similar dependencies
16:58:03 <shachaf> m3ga: Ha! My computer is too fast to justify coffee!
16:58:40 <shachaf> (Well, actually, I just don't drink coffee.)
16:59:16 <m3ga> shachaf: i know kfish likes his coffee so i thought i'd give him an excuse
16:59:24 <m3ga> to indulge
16:59:33 <kfish> (thanks to liyang, we have a coffee machine and roaster at tsuru :)
16:59:55 <m3ga> nice! (although i don't drink coffee either)
17:01:51 <kfish> m3ga, anyway in general i don't think you want your code to be more lazy, you want to use the http origin reading enumerator to pass a strict bs chunk to the client
17:02:42 <m3ga> well yes, i suppose that is a more accurate description of what's required.
17:07:36 <m3ga> kfish: looking at the Wai.responseEnumerator implementation (http://hackage.haskell.org/packages/archive/wai/0.4.0/doc/html/src/Network-Wai.html#responseEnumerator) maybe i need to use the ResponseBuilder constructor instead.
17:17:37 <m3ga> kfish: http://www.yesodweb.com/blog/announcing-warp look for the ResonseEnumerator heading
17:22:00 <ezyang> Also rewrote big bits of the function heap post. 
17:22:13 <ezyang> I'm also looking at the bit where the function does heap allocation, and I'm not so sure anymore. 
17:22:24 <ezyang> Maybe the caller does the heap allocation? I should double check that... 
17:22:40 <ezyang> (or maybe it gets stuck on the stack? *shivers*) 
17:37:38 <brbr> hello
17:38:15 <brbr> i am trying to install criterion, but it fails with: <command line>: cannot satisfy -package-id deepseq-1.1.0.2-09b3aed0c4982bbc6569c668100876fa
17:54:46 <gwern> > 131.95 /  26.39 
17:54:47 <lambdabot>   4.999999999999999
17:55:17 <gwern> > 26.39 / 131.95 
17:55:18 <lambdabot>   0.2
17:55:19 <gwern> > 39.59 / 197.95  
17:55:20 <lambdabot>   0.20000000000000004
17:56:36 <ion> > 39.59 / 197.95 :: Rational
17:56:37 <lambdabot>   1 % 5
17:59:45 <mustseemovies> 04hello ppl check out our new blog about MUST SEE UPCOMING MOVIES -> > >   http://mustsee-newmovies.blogspot.com/  < < <-  (help us improve by visiting the blog + clicking some advertisment) thanks a lot :D
17:59:54 --- mode: ChanServ set +o monochrom
18:00:02 --- mode: monochrom set +c
18:00:02 <gio123> lambda calculus! is there expert in this are?
18:00:06 --- mode: monochrom set -o monochrom
18:00:21 <TheZimm> well its like... math xD
18:00:49 <gio123> ?
18:00:56 <ion> There might be.
18:02:39 <DrSyzygy> gio123: What do you need?
18:02:55 <gio123> confluence proof :)
18:03:11 <gio123> of beta rule
18:03:18 <DrSyzygy> Not good enough for that. Sorry.
18:03:29 <gio123> ok
18:03:45 <gio123> i am reading the proof but could not undestand something...
18:03:46 <ezyang> gio123: confluence for lambda calculus is a fairly widely known result. Is there something specifically you're stuck on?
18:03:58 <gio123> noo
18:04:05 <gio123> I want to undestand the proof
18:04:09 <gio123> martin lof
18:04:30 <gio123> proof
18:05:41 <gio123> proof which is given in HINDLEY  and SELDIN book
18:05:45 <ezyang> Yeah. The standard confluence proof method.
18:05:50 <ezyang> But what specifically are you stuck on?
18:06:04 <ezyang> Do you see the big picture?
18:06:11 <ezyang> Is there a technical lemma that's giving you trouble?
18:06:42 <gio123> I do not undestand concept of paraller reduction
18:06:51 <gio123> but seems this is offtopic of this chanell
18:06:55 <ezyang> OK, that's a start.
18:07:02 <gio123> could you go to haskel-blah
18:07:08 <gio123> ?
18:23:42 <gwern> > (200*200) / ((180 - (180*0.2))-10)
18:23:43 <lambdabot>   298.5074626865672
18:26:02 <gwern> > (10*200) / 3
18:26:03 <lambdabot>   666.6666666666666
18:26:13 <pastorn> nice
18:26:28 <pastorn> extra evil
18:26:39 <napping> How evil?
18:26:39 <lambdabot> napping: You have 3 new messages. '/msg lambdabot @messages' to read them.
18:27:42 <gwern> > 666.666666 `gt` 9000
18:27:44 <lambdabot>   True
18:27:59 <gwern> napping: IT's OVER 9000!!!!
18:28:23 <Saizan> :t gt
18:28:24 <lambdabot> forall t t1. t -> t1 -> Bool
18:28:38 <ddarius> More cleverness could have been used.
18:28:40 <Philippa> are there any arguments for the current fixity of $ beyond compatibility?
18:28:51 <Philippa> rather, the current associativity?
18:28:55 <ddarius> But given the context, that is probably a bit much to ask.
18:29:09 <gwern> > 666.666666 `gt` 9000
18:29:11 <lambdabot>   True
18:29:24 <gwern> you can't argue with the facts
18:29:27 <gwern> it's just that evil
18:29:41 <JoeyA> > (*5) $ (+4) $ (`mod` 20) $ 10000000
18:29:42 <lambdabot>   20
18:30:21 <napping> oh, you're just messing around with division
18:30:50 <JoeyA> Philippa: It's easier to chain a series of operations when $ is right-associative.
18:31:11 <Saizan> JoeyA: that's not so compelling since you could have used . instead
18:31:24 <napping> two steps into the standard argument
18:31:25 <ddarius> Who wants ..$ when you could have $$$ ?
18:31:49 <DasIch_> :t $$$
18:31:50 <lambdabot> parse error on input `$$$'
18:31:51 <Philippa> napping: has it been wikified yet?
18:32:08 <napping> I don't know, but it's been argued on the list
18:32:25 <Saizan> i vaguely remember some more complex situation which made infixl $ look quite fragile
18:32:42 <JoeyA> What about $!
18:32:59 <JoeyA> or does that argue more in favor of left-associativity?
18:33:29 <Saizan> $! is the one where infixr is most annoying
18:33:29 <JoeyA> e.g. Foo $! a $! b $! c (to force a, b, and c, then construct Foo, using a left-associative $! operator)
18:33:52 <JoeyA> Is there a program, or way to invoke GHC or Hugs, that interprets/compiles the STG language ("Spineless Tagless G-machine", 1992) directly?
18:34:24 <JoeyA> Although it's an abstract language, the paper gives a concrete syntax for it.
18:34:38 <napping> there's an intermediate language called "stg"
18:35:37 <JoeyA> Right.  I'm wondering if there's a utility I can use to compile STG code directly (mainly to understand it better)
18:36:05 <napping> to STG bytecodes?
18:36:37 <napping> pastorn: I found something much eviler
18:36:43 <Philippa> are the evaluation rules syntax directed? If so, code 'em up
18:37:16 <napping> data Box a = Box a; addressOf :: a -> Ptr a; addressOf x = unsafeCoerce# (Box x)
18:37:29 <JoeyA> I don't mean compile to STG, I mean compile/interpret code that's already in STG.
18:39:26 <Saizan> napping: evil
18:39:45 <Saizan> napping: i guess that also survives GC's moving x around
18:39:55 <Philippa> JoeyA: that's what I meant too
18:39:58 <napping> Hmm
18:40:02 <napping> I don't know.
18:40:29 <ddarius> Philippa: JoeyA was responding to napping
18:41:23 <napping> I guess it probably has the wrong info table for a Ptr, so the GC might actually update it
18:41:53 <napping> probably breaks lots of other stuff
18:41:57 <Philippa> JoeyA: does http://uebb.cs.tu-berlin.de/lehre/2004WScompilerbau/ergebnisse/stg.pdf help any?
18:44:08 <JoeyA> I'm still reading through the paper I linked above.  I was just wondering if someone had already written a tool that interprets STG so I can get a better grip of it.
18:45:24 <napping> Saizan: it seems to not work right at all, actually
18:45:50 <napping> *Main> let p1 = addressOf "purity" in (p1, Ptr (case p1 of Ptr x -> x))
18:45:55 <napping> (0x007f6a74ab5c7000,0x00007f6a74ab5c70)
18:46:01 <napping> looks like there is an extra padding byte or something
19:04:02 <napping> what version of cabal-install does cabal-dev want?
19:18:13 <napping> I'm getting an error unrecognized option `--verbose=1' when I try cabal-dev init
19:29:03 <dolio> caseyh is the strangest spam bot I've ever seen.
19:29:15 <djahandarie> Is that a challenge?
19:29:34 <dolio> It sounded like a statement.
19:30:04 <djahandarie> :p I meant a challenge to make an even stranger spam bot
19:30:08 <adorablepuppy> I know there probably isn't, but is there some way to embed resources inside an executable generated by ghc?
19:30:30 <danharaj> adorablepuppy: You mean windows resources?
19:30:36 * djahandarie builds a markov chain from #haskell logs and functional programming ads
19:30:56 <ddarius> djahandarie: CosmicRay did that.
19:31:25 <ddarius> adorablepuppy: Use a standard resource editor.
19:31:53 <adorablepuppy> ddarius: What I really wanted to do was embed the sdl dlls into one
19:32:27 <adorablepuppy> in C#, I'd do that, and extract it later when the program needed it/
19:32:29 <napping> Can't you do that with a linker?
19:33:15 <dolio> This is different from static linking?
19:34:24 <adorablepuppy> I've no idea. Don't come from a C or C++ background, so I don't have any idea about linking. All I know is ghc usually does it for me.
19:35:03 <dolio> Static linking sticks all the library code inside an executable at link-time.
19:35:33 <dolio> Dynamic linking arranges for the executable to delay that until run time.
19:36:04 <dolio> Bundling the dynamic link libraries with an executable and only using them sounds like the worst of both worlds.
19:36:39 <pastorn> if you're distributing a closed source application with a statically linked lgpl library you're in violation of its license
19:36:45 <pastorn> i think sdl is lgpl
19:37:05 <dolio> Ah.
19:37:13 <jmcarthur> some lgpl projects add a clause for static linking though. it's a good idea to at least check
19:37:17 <dolio> I typically don't concern myself much with that.
19:37:56 * Saizan reports dolio to the license police
19:38:18 <dolio> Go ahead.
19:38:31 * pastorn is curious on how many closed source apps dolio is distributing
19:38:53 <dolio> I think the answer is 0.
19:39:24 <pastorn> dolio++
19:40:35 <ksf_> http://www.haskell.org/haskellwiki/Zeno
19:40:59 <ksf_> If I was a say ##c or #perl regular instead of #haskell, I'd be looking at taillights, now.
19:41:02 * hackagebot kit 0.7.2 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.2 (NickPartridge)
19:41:20 <jmcarthur> i don't understand that phrase
19:41:58 <ksf_> that's just miles ahead of anything any other language has.
19:42:03 <jmcarthur> ah
19:42:09 <ksf_> and, imo, just the right thing to do.
19:42:22 <ksf_> that is, introduce proofs into haskell in a quickcheck-like manner.
19:42:40 <ksf_> keeping them optional while refining the techniques.
19:43:12 <danharaj> "Works with full Haskell98 along with any GHC extensions not related to the type system. "
19:43:32 <ksf_> that should apply, for example, to the xmonad core.
19:43:40 <danharaj> I'm curious how much Hackage code (proportioned by popularity) is Haskell98.
19:43:57 <dolio> Not that much.
19:44:16 <ksf_> it's only a matter of days until someone will have come up with a blogpost that either deems xmonad to be completely bugfree or goes on to rage about a single one.
19:44:42 <dolio> Strictly speaking, it's likely that no Hackage code is Haskell98.
19:44:54 <danharaj> That's probably true.
19:45:23 <danharaj> I feel like an idiot because I'm using 5 type extensions in my project.
19:45:41 <dolio> I wouldn't get ahead of yourself. Is xmonad simple enough for this program to handle it?
19:45:41 * ksf_ okular zeno.pdf
19:46:28 <ksf_> well, absence of head and fromJust exception's already been proven.
19:46:46 <ksf_> and all core functions should be total.
19:47:13 <ksf_> there's also a battalion of quickcheck properties to build on.
19:48:05 <dolio> Is correct functioning of xmonad completely specifiable via inductively provable properties?
19:48:13 <ksf_> hell no.
19:48:24 <dolio> Then how is Zeno going to be used to prove it has no bugs?
19:48:25 <ksf_> X is too fuzzy for that.
19:48:37 <danharaj> Any bugs should be X's fault :p
19:48:56 <ksf_> well, zeno can prove that you e.g. never loose a window out of the data structures unless you actually remove it.
19:52:12 <ddarius> "Daddy he once told me 'Son, you be hard working man.'  And Momma she once told me 'Son, you do the best you can.'"
19:56:29 <Alan> Hmm, how easy would it be to mapM_ over a lazy-evaluated list where each element depends on the state of a State monad?
19:57:22 <Alan> ok, that was really badly phrased
19:57:39 <Alan> let's go for a concrete question instead...
19:57:54 <Saizan> use types
19:58:30 <Alan> I have an emulator, my execution function is a -> State s b
19:58:40 <ddarius> What Saizan meant to say was "Use the types, Luke."
19:58:55 <Alan> I have a [a] of instructions, and part of s is the current program counter
19:59:14 <Alan> actually, not a [a] of instructions but an array of instructions
20:00:29 <Alan> hmm, starting to wonder if this kinda rapes referential transparency in the face...
20:00:49 <Saizan> exec :: a -> State s b; xs :: Array i a; mapM_ exec (elems xs) :: State s ()
20:01:08 <Saizan> which is fine if you're only interested in the final 's'
20:01:29 <Alan> the problem is it's not a linear execution
20:01:42 <Alan> a program counter is used because there are jumps, function calls, etc.
20:02:05 * hackagebot kit 0.7.3 - A dependency manager for Xcode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.7.3 (NickPartridge)
20:02:06 <Alan> i want to lazy-evaluate the instructions to execute from the array of instructions and the program counter state
20:02:58 <Saizan> if you have conditional jumps you're going to need more than that
20:03:23 <Alan> i do have conditional jumps
20:05:14 <Saizan> so you need something like run xs = do i <- fetchInstruction; exec i; b <- halt; if b then return () else run xs
20:05:41 <Saizan> where fetchInstruction looks at the program counter
20:06:12 <Saizan> and "executing a jump" changes it
20:06:16 <Alan> yeah, so that's kinda what I suspected, I can't decompose it to use a mapM because they're too tightly linked?
20:07:52 <Saizan> in the worst case by the time you know what the next instruction is you've already executed the current one
20:08:37 <Saizan> you could look ahead up to the next jump though
20:10:34 <Alan> hmm, i really need to write a proof-of-concept for this i think...
20:12:03 <Saizan> run xs = do is <- fetchInstructions; mapM_ exec is; b <- halt; if b then return () else run xs; where fetchInstructions = do pc <- getPC; return (takeWhile notJump (elemsFrom pc xs))
20:12:16 <Saizan> elemsFrom probably doesn't exist
20:14:04 <Saizan> something like that :)
20:16:27 <danharaj> ugh I have to learn how GLSL uniforms work :|
20:16:41 <danharaj> My code output is bottle-necked by my ability to learn things.
20:17:35 <ksf_> simple enough concept.
20:17:48 <ksf_> an uniform is a variable that stays constant between shaders.
20:17:58 <ksf_> as opposed to variables you use in individual shaders.
20:18:16 <danharaj> ksf: that's true, but I'm trying to encode the uniforms a shader takes in its haskell type, and I have to think about things like how Struct uniforms work, and Uniform Blocks.
20:18:25 <ksf_> that is, they're read-only input to shaders you write with the cpu.
20:18:27 <danharaj> and whether I want to even bother with those right now.
20:18:40 <ksf_> don't.
20:18:46 <ksf_> and have a look at gpipe.
20:18:53 <danharaj> ok what's gpipe?
20:19:02 <ksf_> but, for the love of efficiency, do care about textures.
20:19:14 <ksf_> it's a glsl edsl.
20:19:26 <danharaj> Oh I looked at gpipe before.
20:19:31 <danharaj> I don't like it because it uses the Vec package.
20:19:40 <danharaj> I'm building my interface over Repa
20:20:13 <ksf_> it's a great concept, but the implementation is a mess, which makes it virtually impossible to fix the issues it has without rewriting it.
20:20:52 <ksf_> the core of it is independent of vec, though, iirc.
20:21:50 <danharaj> ksf_: mm. I don't want to do much other than type shaders by their inputs. I've already done it for non-struct non-array attributes.
20:22:09 <danharaj> And I know how to extend to those cases.
20:22:47 <pastorn> danharaj: how are you typing shaders?
20:22:59 <pastorn> i mean, a shader is just an arbitrary string
20:23:41 <danharaj> pastorn: I am giving it a type based on the in variables it uses.
20:23:58 <pastorn> i was thinknig of that for OpenGL
20:24:07 <Alan> in "repeat x", is x evaluated only once?
20:24:12 <danharaj> pastorn: my load function takes a list of vertex shader files, fragment shader files, and the names of the attributes and uniforms.
20:24:17 <ddarius> Alan: mu.
20:24:24 * lispy_ waves
20:24:29 <pastorn> but i don't really know how... so say that you have "uniform vec3 col1; uniform vec4 light_pos;"
20:24:36 <pastorn> how do you encode that?
20:24:53 <danharaj> pastorn: I am doing it like this. Here's an example shader type:
20:25:09 <Alan> bah, i guess for a referentially transparent "repeat", every element must be the same because x can only refer to one thing...
20:25:34 <napping> operationally, it should be shared
20:25:39 <pastorn> Alan: pointer-o-rama
20:25:48 <danharaj> type ShaderType = ShaderObj (SAttrib (SVec4 Float) :*: SAttrib (SVec4 Float)) (SUniform (SVec3 Float) :*: SUniform (SVec4 Float))
20:26:11 <danharaj> Now it's pretty ugly looking in IRC, but it's not as bad in a text editor, and I think I might sugar it using Template Haskell.
20:26:21 <pastorn> danharaj: but don't you need to know all the shader types at compile time then?
20:26:54 <Alan> OOH
20:27:21 <danharaj> pastorn: You need to have a shader type you expect. If you try to load a shader and it doesn't have the Attribute/Uniform Locations you claim it has, you get a run-time error.
20:27:48 <gwern> sounds like data.dynamic?
20:28:10 <pastorn> dhttp://hpaste.org/46148/danharajs_shaderthingy
20:28:43 <danharaj> It doesn't actually check that the type of the in variable is the same as you asserted. The type parameter is only used to determine the size/stride/etc. when making VertexArrayDescriptors and what-not.
20:29:47 <pastorn> danharaj: Do you think this is something stealable for the new version of OpenGL?
20:29:58 <pastorn> How easy/difficult is it to work with?
20:30:21 <danharaj> pastorn: I am not sure yet. I have a test example of an OpenGL program I'm working with. I have to see how I'm going to deal with uniforms.
20:30:25 <pastorn> btw, "hello! i'm the opengl summer of code guy"
20:30:32 <danharaj> oh! hahaha sup
20:30:58 <danharaj> If you want to take a gander at my code I'll eventually be cabalizing it and haddocking it and putting it on github or something.
20:31:05 <danharaj> Probably the weekend when I'm not completely sleep deprived.
20:31:36 <pastorn> haha... sounds good... i still have school, so i'll have to nag you about it once things clear up a bit for me
20:32:41 <danharaj> pastorn: I added an annotation to the paste showing how you can load a shader. You have to annotate the type.
20:33:39 <pastorn> danharaj: ":t (:*:)"?
20:33:54 <danharaj> data a :*: b = a :*: b
20:34:15 <pastorn> what's wrong with (,)?
20:34:24 <pastorn> doesn't look as cooL
20:34:26 <pastorn> ?
20:34:41 <danharaj> You can't use tuples recursively.
20:35:09 <danharaj> at some point I am defining data families on lists of types. :*: is my way of making lists of types.
20:35:17 <danharaj> If there's a standard way I would love to know :p
20:35:24 <pastorn> > ("yes", ("i", ("can","!")))
20:35:24 <lambdabot>   ("yes",("i",("can","!")))
20:35:37 <lispy_> danharaj: HList
20:35:42 <danharaj> do you really want to type that instead of "yes" :*: "i" :*: "can" :*: "!" :p
20:35:49 <danharaj> lispy_: looking now.
20:36:06 <pastorn> danharaj: oh, this reminds me of going from liftM* to <*>
20:36:14 <danharaj> yeah it's like that.
20:36:46 <danharaj> holy crap the HList docs are impossible to navigate :p
20:36:46 <lispy_> danharaj: I don't really know if it's standard, but it's an oleg creation and it basically gives you tuples of arbitrary size.  That is, heterogeneous finite lists
20:37:01 <danharaj> lispy_: it looks insanely heavy-weight compared with what I'm doing.
20:37:28 <Saizan> danharaj: it's exactly the same as your :*:, it just builds more utilities on top of that
20:37:45 <danharaj> Saizan: I can't find where the basic stuff is defined in the hackage docs :p
20:38:06 <lispy_> danharaj: you might want to read the paper that goes with it
20:38:21 <danharaj> god that makes so much sense. I really need some sleep.
20:38:47 <Saizan> http://hackage.haskell.org/packages/archive/HList/0.2.3/doc/html/Data-HList-HListPrelude.html#t:HCons
20:38:54 <Saizan> and HNil above
20:40:46 <danharaj> Saizan: thanks.
20:41:02 <pastorn> that's a *lot* of instances
20:41:12 <danharaj> Hmm I may just switch to this. Although I'd have to weigh the benefits vs. adding a template-haskell dependency.
20:41:33 <danharaj> (Well if I decide to use Repa I'll have that anyway...)
20:41:58 <pastorn> danharaj: what i don't get is how you can parse your shader into this arbitrary type...
20:42:08 <danharaj> pastorn: what do you mean?
20:42:16 <pastorn> i get that you can verify your shader from the code in your program, but not the other way aroun
20:43:02 <danharaj> pastorn: the only relevant information to the shader is the names of the attributes and uniforms.
20:43:26 <pastorn> sure
20:43:42 <Alan> hmmm
20:43:55 <Alan> so so far i've got: runState (sequence_ $ repeat $ fetch >>= execute) 0
20:44:01 <Alan> but now i need an exit condition...
20:44:13 <pastorn> Alan: you need ContT!!
20:44:16 <pastorn> the BEST monad
20:44:32 <danharaj> The types on the Haskell side say a few things: How many attributes/uniforms you have, and what their types are. The types tell you how many components they have and the size in bytes of that type, so it can do VertexArrayDescriptor bookkeeping for you.
20:44:44 <pastorn> Alan: or maybe StateT Cont will do
20:44:46 <Alan> pastorn: why?
20:44:49 <Jafet> @quote klein bottle
20:44:50 <lambdabot> No quotes for this person. It can only be attributed to human error.
20:44:55 <Jafet> @quote klein.bottle
20:44:55 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
20:45:11 <Twey> Haha
20:45:14 <Twey> Good analogy
20:45:38 <Alan> pastorn: StateT Cont and not ContT State?
20:45:48 <pastorn> Alan: look into the "all about monads" page on the continuation monad
20:46:28 <pastorn> Alan: StateT Cont returns (Cont (State a)), ContT State returns (State Cont a)
20:46:30 <pastorn> sort of
20:46:38 <Saizan> what?
20:46:48 <pastorn> well, their respective run functions
20:46:58 <pastorn> @type runStateT
20:46:59 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
20:47:04 <pastorn> @type runContT
20:47:05 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
20:47:09 <Saizan> @unmtl StateT s (Cont r) a
20:47:09 <lambdabot> s -> (a -> s -> r) -> r
20:47:21 <Alan> pastorn: so are you just trolling me, or do continuations fit what i'm trying to do?
20:47:27 <Saizan> @unmtl ContT r (State s) a
20:47:28 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
20:47:42 <danharaj> http://hpaste.org/paste/46148/danharajs_shaderthingy_annot#p46150
20:47:42 <pastorn> Alan: continuations is how you cleanly exit out of a 'forever' loop
20:47:59 <pastorn> Alan: look at the "all about monads" page, it's quite nice
20:48:03 <Saizan> those are pretty much the same
20:48:15 <Alan> pastorn: so my execute function actually returns a continuation, which in my "HALT" case won't do anything?
20:48:22 <Alan> pastorn: looking at it now
20:48:37 <danharaj> pastorn: I wrote a function for example, that automatically gives you the information needed to load a bunch of attributes from a VBO as if they were tightly packed.
20:48:48 <Saizan> Alan: an easier way to exit from a loop would be ErrorT or MaybeT
20:48:56 <pastorn> Alan: just stick that "\exit -> " in a variable in your state
20:48:57 <danharaj> pastorn: If you want more complicated layouts you can do it piece-wise and combine the descriptors.
20:49:08 <jmcarthur> danharaj: what kind of interface does that function have?
20:49:24 <jmcarthur> i kind of have my own way of doing something like that. it's nice, but a little complicated
20:49:41 <jmcarthur> well, in implementation. the interface is fairly simple
20:49:47 <danharaj> jmcarthur: It's in the paste, but not all of the context is there. The return type (AttribData a) encodes the number and types of the attributes in the order they appear.
20:50:06 <jmcarthur> ah
20:50:17 <Saizan> and you don't need to store the continuation anywhere if you just want to exit, use abort x = ContT $ \ _ -> return x
20:50:55 <danharaj> unfortunately it doesn't look like A :*: B :*: C, because it's a data family, so I use another operator. This is understandably ugly. I'll clean up the interface in that regard eventually so you can do things piece-wise more intuitively.
20:50:58 <pastorn> Alan: ^^^^^^
20:51:59 <Alan> pastorn: hmm.
20:52:38 <pastorn> Alan: i know it's quite difficult to grasp...
20:52:53 <pastorn> Alan: if you're only doing IO you can cheat with System.Exit :D
20:52:58 <jmcarthur> here's mine:   vertexAttribPointer :: (AttribData c, Storable a, Storable b) => Buffer Array a -> Attribute -> (a -> b) -> (a -> c) -> IO ()
20:53:03 <Alan> I actually studied continuations last year too....
20:53:06 <danharaj> Now if anyone is experienced in openGL code, should I offer specialized interfaces for individual uniforms, or would it be ok to work entirely with Uniform Blocks?
20:54:42 <danharaj> I also intend on treating Samplers as distinct from other Uniforms.
20:55:34 <jmcarthur> danharaj: my driver doesn't even support uniform buffers :(
20:56:02 <jmcarthur> intel gm45 + mesa
20:56:11 <danharaj> oh god intel :(
20:56:19 <jmcarthur> i guess it's not like a gamer's card or anything though, of course
20:57:05 <danharaj> Well I am writing this for my own use, but if others are interested in me releasing this for public consumption I should accomodate for backwards compatibility.
20:57:07 <pastorn> jmcarthur: does that mean you won't be able to use the new OpenGL bindings? (will require OpenGL 3.1+)
20:57:17 <jmcarthur> they will *require* it?
20:57:22 <jmcarthur> yeah, then i can't use tem
20:57:24 <jmcarthur> *them
20:57:32 <danharaj> I'm not even sure my card can handle OpenGL 3.1
20:57:46 <danharaj> I get errors when I try to bump the shader version up in my shaders.
20:57:47 <jmcarthur> why will the new bindings require it?
20:58:13 <luite> is there a simple library for experimenting with image processing algorithms? something that can load some common image file formats, convert the image data to some color space (like HSV, Lab or RGB), and that can show the result of the processing in a window or save it to a file?
20:58:28 <pastorn> maybe they can be made without requiring it, but i'm not gonna expose anything that got removed in 3.1
20:58:39 <pastorn> so no primitive mode, no matrix stack
20:58:46 <danharaj> oh that's fine I'm pretty sure.
20:58:52 <danharaj> That stuff was outdated before 3.1.
20:58:57 <danharaj> Just not deprecated/removed.
20:59:01 <jmcarthur> pastorn: see the OpenGLRaw21 package. it exposes only non-deprecated functionality that works in opengl 2.1
20:59:30 <jmcarthur> i made it so i could avoid deprecated stuff
20:59:41 <danharaj> jmcarthur: good on ya :p
21:00:37 <pastorn> luite: devil might be helpful, but it depends on a c++ library, might be difficult to get it running (i know i had a little trouble once)
21:01:08 <danharaj> luite: for the actual image processing, I think Repa-Examples has some image processing example code using the Repa array library.
21:01:17 <jmcarthur> there is a devil library on hackage due to luqui, and i've been able to bind to it myself before without much trouble
21:01:24 <znutar> primitive mode's still implemented in the hardware, sadly.
21:01:35 <znutar> Some cruft never dies
21:01:53 <luite> pastorn: ah thanks, I'm on windows so I'll see if I can get this compiled :)
21:02:17 <napping> A20!
21:02:19 <luite> danharaj: yes I already saw some of the examples
21:02:37 <Alan> pastorn: still not entirely sure how i use StateT Cont
21:03:15 <pastorn> @type runCont
21:03:16 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
21:03:44 <pastorn> @type runStateT
21:03:44 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:04:51 * ddarius loves recursive helping.
21:04:55 * pastorn thinks
21:05:09 <ddarius> :t mapAccumL
21:05:10 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
21:06:24 <pastorn> @type runContT
21:06:25 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
21:07:15 <Alan> i'm almost getting how Cont works
21:07:22 * pastorn realizes that 6:20 AM is too early to think about continuations
21:07:28 <Alan> but not sure which way to nest them
21:07:47 <Alan> pastorn: or more to the point, 5:30 AM is too late to think about continuations...
21:07:50 <djahandarie> pastorn, or it's too late...
21:07:52 <djahandarie> Haha
21:07:53 <pastorn> Alan: you want to be able to grab the \exit before your runState so you can put it into your starting state
21:08:19 <luite> hmm, repa-examples doesn't install on my windows box
21:08:24 <pastorn> perhaps you can have runStateT first, but put 'undefined' as your { ... exit :: ? ... }
21:09:11 <Alan> i still want to find a solution that lazy-evaluates something into sequence_ instead...
21:09:17 <Alan>  might be a  little easier to understand....
21:10:01 <Alan> Let me see if I get this correctly...
21:10:09 <pastorn> Alan: are you sure you need all this? how about a named function "f = do { ...; if end then return something else f }
21:10:19 <Alan> Continuation-passing style, you call a function and give it the function to pass it's result to?
21:10:39 <ksf_> in a nutshell, yes.
21:11:04 <ksf_> quite often, you give more than one function.
21:11:10 <ddarius> Consider how functions work at the assembly level.
21:11:23 <Alan> and what pastorn is saying is that I want to store the "exit function", the one passed to runCont, so i can basically jump out whenever i want by calling that instead of going further into runState?
21:12:04 <pastorn> i'm just saying it's a (sort of) easy way to break out of 'forever'
21:12:24 <pastorn> which is basically what you have with (sequence_ . repeat)
21:12:35 <pastorn> @src forever
21:12:36 <lambdabot> Source not found. I am sorry.
21:12:42 <pastorn> forever f = f >> forever f
21:12:43 <Alan> pastorn: well i have my state, my fetch function (State s Op) and my execute function (Op -> State s ())
21:12:53 <ksf_> anecdotally speaking, complex monadic code tends to degenerate into CPS quite fast (at least under my fingers)
21:13:07 <Alan> and I feel i should somehow be able to define the emulator as a sequence_ or mapM_ or something
21:13:22 <Alan> rather than creating a top-level great-big-pile-o-hacks
21:13:22 <napping> why not just fetch >>= execute?
21:13:30 * ksf_ doesn't share that intuition.
21:13:41 <Alan> napping: that's what i have at the moment, but somehow i need to break out of that...
21:14:09 <Alan> runState (mapM_ $ repeat $ fetch >>= execute) 0
21:14:22 <pastorn> @type repeat
21:14:23 <lambdabot> forall a. a -> [a]
21:14:28 <Alan> I don't want to embed the "what do i call next" logic into execute
21:14:29 <pastorn> Alan: :t fetch?
21:14:37 <pastorn> and execute too, please :)
21:14:50 <Alan> 05:34 < Alan> pastorn: well i have my state, my fetch function (State s Op) and my  execute function (Op -> State s ())
21:14:54 <dolio> Use a different monad.
21:14:57 <ksf_> but don't you want to pipe the result of execute into fetch?
21:15:14 <Alan> the program counter is part of the state
21:15:36 <dolio> One that supports throw and catch.
21:16:05 <Alan> dolio: you mean treating the "halt" condition as an exception rather than "coming to the end"?
21:16:30 <dolio> throw and catch don't have to be about exceptions.
21:16:42 <dolio> They're just control flow constructs.
21:16:56 <danharaj> well, halting *is* exceptional behavior for programs :p
21:23:27 <Alan> hmmm, i'll have to take another look at this tomorrow i think...
21:23:28 <ddarius> Indeed, notice the low halting probability.
21:24:38 <Alan> low halting probability?
21:24:39 <Alan> what?
21:33:42 <Kerris> Alan: maybe it's just a giant while loop :V
21:35:03 <ksf_> % uptime
21:35:03 <ksf_>  06:56:40 up 8 days, 14:36,  6 users,  load average: 1.45, 1.28, 1.28
21:35:17 <ksf_> my system seems to have a low halting probability, yes.
21:39:15 * hackagebot ieee754 0.7.3 - Utilities for dealing with IEEE floating point numbers  http://hackage.haskell.org/package/ieee754-0.7.3 (PatrickPerry)
21:46:16 * hackagebot placeholders 0.1 - Placeholders for use while developing Haskell code  http://hackage.haskell.org/package/placeholders-0.1 (AndreasHammar)
22:09:18 * hackagebot Interpolation 0.2.5.2 - Multiline strings, interpolation and templating.  http://hackage.haskell.org/package/Interpolation-0.2.5.2 (VilleTirronen)
22:23:22 <wkh> test
22:24:36 <applicative> countertest?
22:38:57 <killing-joke> this is cool. makes beautiful images  ...  http://nodebox.net/code/index.php/Graph
22:39:03 <killing-joke> but it is Python. is there something like it for Haskell?
22:42:27 <applicative> killing-joke: I can't remember all the possibilities, see e.g. http://ooxo.org/hubigraph/
22:46:03 <applicative> killing-joke: the use of it for representing haskell 'data structures' I remember was pleasing http://hackage.haskell.org/package/vacuum-ubigraph
22:46:31 <applicative> it's hardly pure haskell since it requires the ubigraph server
22:46:50 <killing-joke> ah well. the output is still gorgeous.
22:47:11 <killing-joke> http://ubietylab.net/ubigraph/content/Demos/index.html
22:47:29 <killing-joke> wowww
22:48:34 <killing-joke> applicative, many thanks.
22:52:25 <ion> Ubigraph seems to be nonfree.
22:55:45 <killing-joke> blechhh. binary-only distribution. too bad.
22:57:24 * hackagebot hack-handler-simpleserver 0.2.0.2 - A simplistic HTTP server handler for Hack.  http://hackage.haskell.org/package/hack-handler-simpleserver-0.2.0.2 (UweSchmidt)
23:01:44 <MatrixFrog> ok i feel like i must be doing something super dumb...
23:01:55 <MatrixFrog> i read about this cool Zeno thing on reddit, right?
23:02:22 <MatrixFrog> so i go "cabal install zeno" and it works, then i cd into the place where it installed it, and i go "zeno Example.hs" because there's an example there
23:02:35 <MatrixFrog> and it says: unexpected RTS argument: "-N"
23:02:41 <MatrixFrog> i'm super sure i did not type -N at any point
23:05:48 <MatrixFrog> i should remember to do haskelly stuff earlier in the day when people are in here :(
23:08:10 <applicative> ion killing-joke I think the binary is 'free', but it is just a sort of server; you bounce your commands on it and get pretty pictures.
23:11:24 <applicative> MatrixFrog, yes, I wonder what's up the cabal file has   if impl(ghc >= 7)  ghc-options:  -with-rtsopts="-N"
23:12:33 <applicative> the idea would be that it is checking for the number of cores and using them, but I wonder if this is the way to go about it.
23:12:43 <applicative> or I think that's whats up
23:14:57 <MatrixFrog> so what if i try taking that line out
23:15:05 <MatrixFrog> cabal unpack zeno?
23:15:08 <MatrixFrog> and then delete that line?
23:15:23 <MatrixFrog> and then cd into where it is, and... cabal build? or something
23:15:39 <applicative> MatrixFrog: yes, i just did it, then, e.g. zeno --help works
23:16:29 <applicative> cabal unpack zeno  cd zeno-... kill the if ghc... line then 'cabal install --user' should work
23:17:01 * applicative has no idea what this mysterious zeno executable is.  he will study
23:17:31 <applicative> oh cool
23:18:08 <applicative> "zeno Examples.hs" is proving up a storm
23:20:02 <MatrixFrog> :) me too
23:20:02 <applicative> " Disproved "Zeno.proveBool : p = True"  with [ p -> False ] " -- makes QuickCheck look primitive
23:21:57 <killing-joke> http://stackoverflow.com/questions/5557100/free-alternative-to-ubigraph  (spoiler: no, there doesn't seem to be one)
23:22:08 <applicative> MatrixFrog: it is compiled with --threaded so you might get an advantage with "zeno MyFile.hs +RTS -N
23:22:24 <applicative> killing-joke: well, thats dismal.
23:23:04 <killing-joke> :\
23:24:09 <applicative> killing-joke: I think at other times of day people might have other things to mention. I can't imagine anything is going to look like this swanky nodebox
23:26:29 <killing-joke> ah well, then. time to sprain my personal aversion to syntactical whitespace.
23:26:49 <killing-joke> there are far worse languages than Python
23:33:10 <killing-joke> ahhhh. java.
23:33:20 <killing-joke> applicative, http://gephi.org/features/
23:33:51 <applicative> killing-joke: ha, I just notice that the nodebox machinery is java.  You use python to script it
23:34:34 <killing-joke> what!
23:35:29 * hackagebot reactive-banana 0.2.0.2 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.2.0.2 (HeinrichApfelmus)
23:36:13 <applicative> indeed github lists it as a java repository https://github.com/nodebox/nodebox
23:36:15 <killing-joke> applicative, gephi recommends < 1M nodes + edges
23:37:21 <applicative> what, my imagined chiliagon , the myriagon of my dreams?
23:41:49 <applicative> MatrixFrog: I think I see what went wrong with zeno.cabal  you might add -rtsopts to the line that has other ghc-options, then cabal clean then cabal install --user
23:42:43 <applicative> MatrixFrog: then you can add +RTS -N for what good many cores will do you
23:45:06 <applicative> MatrixFrog, I'm using OS X, it may be that their original incantation was sound in principle; I think there's a new feature they're taking advantage of with RTS options
23:46:31 <MatrixFrog> cool cool thanks
