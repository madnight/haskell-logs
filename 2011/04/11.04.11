00:22:04 <ivanm> preflex: seen Berengal 
00:22:04 <preflex>  Berengal was last seen on #haskell 3 hours, 12 minutes and 53 seconds ago, saying: Yes, /someone/ needs to worry about alignment issues, but that someone isn't me. It's whomever's constructing the array in the first place.
00:25:40 <Lycurgus> ghc says STOP that HP has it all-in-one but HP says to get ghc 7.0.2
00:29:00 <ivanm> Lycurgus: yes, there will be an update of HP in the next week or so
00:29:04 <Dashkal> :t (&&&)
00:29:05 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:30:30 <ivanm> @ask Berengal with your SFML bindings, are you aware that using Cabal-1.8 will prevent haddock from working?
00:30:30 <lambdabot> Consider it noted.
00:30:35 <Lycurgus> ivanm, even though its home page says the next release will be in July, in a similar deal
00:30:57 <ivanm> Lycurgus: the 7.0.3 release was a bugfix one; dons said they'll update HP Real Soon Now!
00:31:10 <Lycurgus> mkay
00:32:22 <ivanm> http://www.mail-archive.com/haskell-platform@projects.haskell.org/msg01489.html
00:33:33 <Lycurgus> the STOP biz has been there for a long time
00:34:09 <ivanm> Lycurgus: it's _always_ there
00:34:17 <ivanm> since for most people it's recommended to get the platform
00:34:33 <ivanm> yet some stupid students still only got GHC and then bitched about why didn't they have GLUT installed... :s
00:34:35 <ivanm> Axman6: ^^
00:34:52 <Axman6> -_-
00:35:28 <Lycurgus> crush all stupid students
00:36:05 <ivanm> Axman6: case in point: TSG used cabal-install to install glut rather than using the actual Ubuntu packages!
00:36:11 <ivanm> so why should the students do any better?
00:57:17 <mrcarrot> if you would have to pick a haskell web framework for a site that needs i18n, which one would you pick? are there any really good options?
01:03:58 <koala_man> are instances of type classes per module? ie can two modules use different instances for the same type in the same program?
01:04:12 <Axman6> no
01:04:24 <ivanm> instances are implicitly exported and imported
01:07:29 <dolio> Different modules can use different instances if you arrange things right. But I wouldn't recommend it.
01:08:12 <dolio> If multiple instances are in scope, though, trying to use the class will result in an error.
01:09:30 <dolio> Or, trying to use the class at the ambiguous instance.
01:10:38 <blackh> Or in other words: Choose the names of your type classes carefully. :)
01:11:17 <dolio> Names of type classes are scoped.
01:11:40 <dolio> You can have a class Foo.C and a class Bar.C.
01:11:41 <blackh> Oh yeah. Ignore me.
01:13:04 <dolio> Type classes are kind of designed with instances being global, though.
01:13:48 <dolio> They aren't, but it's probably best to think of them that way.
01:14:26 <dolio> Although that's kind of a bad thing.
01:14:39 <zul_netbsd>  i3status is a small program (less than 1000 SLOC) for generating a status bar for dzen2, xmobar or similar programs. It is designed to be very efficient by issuing a very small number of system calls, as one generally wants to update such a status line every second. This ensures that even under high load, your status bar is updated correctly. Also, it saves a bit of energy by not hogging your CPU as much as spawning the corresponding amount of
01:14:48 <zul_netbsd> oups
01:14:51 <zul_netbsd> sorry for the noise
01:14:56 <zul_netbsd> bad copy paste
01:59:43 <MacMagnus> how do i divide two integers, such that e.g. 15/4 = 3?
02:00:00 <ArnoVanLumig> 15`div`4
02:00:03 <BONUS> > 15 `div` 4
02:00:04 <lambdabot>   3
02:00:05 <BONUS> agh, beaten
02:00:12 <MacMagnus> oh :) thanks!
02:03:00 <yitz> hi
02:05:01 <pastorn> hello
02:05:23 <yitz> new irc client. what is my nick showing as?
02:05:32 <BONUS> hi yitz
02:05:32 <pastorn> "yitz"
02:05:36 <BONUS> its yitz
02:05:40 <yitz> oh good. thanks!
02:05:52 <liyang> da
02:05:57 <liyang> w
02:06:01 <liyang> ack, sorry.
02:06:07 <Twey> Gah
02:06:22 <Twey> haskell-mode fills Haddock comments with a | before each line
02:06:30 <liyang> earthquake making me hit the enter key unnecessarily or something.
02:06:49 <Twey> … but Haddock only wants the first one; the rest are included in the output >.<
02:07:03 <yitz> oh this is annoying though. i'll probably switch to something else. this is empathy on ubuntu - it's showing each message as a huge "balloon" pointing to an avatar.
02:07:17 <Twey> yitz: Haha, urgh.
02:07:36 <pastorn> yitz: which client are you using?
02:07:38 <Twey> irssi's where it's at.
02:07:47 <pastorn> Twey: bah! weechat
02:07:49 <BONUS> yeah, irssi ftw.
02:07:57 <Twey> pastorn: < yitz> this is empathy on ubuntu
02:08:09 <yitz> just installed ubuntu on a new machine. (natty narwhal) the default is "empathy".
02:08:20 <Twey> pastorn: I don't like Weechat because it breaks copy/paste
02:08:21 <ArnoVanLumig> yitz: you can change the theme, but that will also change the theme of the non-IRC chats
02:08:24 <pastorn> yitz: use xchat if you want a non-terminal client
02:08:30 <Twey> And the input line behaviour is weird
02:08:43 <Lycurgus> there's no haskell client?
02:08:50 <Twey> Lycurgus: Hircules
02:08:52 <yitz> ArnoVanLumig: thanks i'll look for that. i wouldn't use this theme for *anything*
02:09:03 <Twey> Haven't tried it; might be good
02:09:07 <Lycurgus> Twey, is it any good?
02:09:18 <ArnoVanLumig> yitz: in the contact list, edit -> preferences -> themes
02:09:20 <Lycurgus> (compared to xchat)
02:09:20 <yitz> pastorn: irssi in a terminal has been fine for me until now
02:09:27 <Twey> I do not know
02:09:27 <ArnoVanLumig> yitz: I like the "Clean" theme
02:09:32 <Twey> Possibly
02:09:39 <yitz> ArnoVanLumig: ok thanks
02:10:47 <liyang> Is David Waern here? I don't know if he has an obvious nick, if he IRCs at all.
02:11:33 <yitz> ArnoVanLumig: yes much better thanks. still not sure what this gives me over irssi though.
02:12:09 <ArnoVanLumig> yitz: Nothing, except you can use the same client you use for irc for xmpp and msn and stuff
02:25:41 * Lycurgus used irssi for a few years before switching to xchat about 3 years ago
02:26:45 * sipa used xchat for a few months before switching to irssi about 6 years ago
02:26:49 * Lycurgus wouldn't mess with Hircule, looks vestigial. 
02:26:59 <blackdog> anyone know how to restrict ghci to the packages specified in a cabal file?
02:27:42 <Lycurgus> might inflame the little gray cells with fulminations against haskell half assery
02:27:47 <blackdog> it seems like it loads a bunch of extra packages automatically... i want to write a console that's specific to a cabalised lib/app
02:28:52 <blackdog> ah, maybe --hide-all-packages
02:31:07 <ivanm> blackdog: isn't that kind of what those wrappers around cabal-install are meant to do?
02:31:11 <ivanm> cabal-dev or something?
02:32:01 <blackdog> ivanm: does cabal-dev give you a console?
02:32:42 <blackdog> ivanm: i think they're more for isolating package installs so they're not in the main package database
02:33:06 <blackdog> what i want is a console command that gives me in ghci what i'm going to see in a compiled cabal environment
02:36:19 <ivanm> hmmm...
02:36:34 <ivanm> I think you can do "cabal-dev ghci"
02:36:38 <blackdog> you say that every time you disagree with me:)
02:37:03 <ivanm> hey, I'm not disagreeing with you!
02:37:10 <ivanm> and I say that in other situations as well!
02:37:14 <Lycurgus> e meant "hmmm"
02:37:58 <markmywords> what is the best method to retrieve the size of a file in haskell?
02:38:14 <markmywords> platform independent if possible
02:38:37 <blackdog> ivanm: hrm. doesn't seem to work :/
02:40:07 <blackdog> ah, i need cabal-dev install first
02:40:18 <Athas> I want to use Parsec to create a parse tree where every node is annotated with information about its position in the input; the intent being that the compiler that later processes the parse tree can tell the user exactly where things went wrong.
02:40:35 <blackdog> actually, that reminds me - is there a way to fetch & build all the deps of a cabalised project without actually installing the project itself?
02:40:50 <Athas> What is usual procedure do to this?  Any handy tools?
02:41:18 <xarch_> hello, what are module morphisms?
02:41:34 <xarch_> I haven't found a lot about that
02:41:48 <xarch_> and it seems there's no wikipedia page about them
02:42:00 <ivanm> blackdog: not AFAIK
02:42:06 <ivanm> but it's an oft-requested feature
02:42:17 <ivanm> maybe that cab wrapper that's been advertised can do something like that?
02:42:23 <ivanm> xarch_: no idea
02:42:25 <blackdog> Athas: I think Parsec does that natively - at least if there's an error, the ParseError contains the information?
02:42:41 <blackdog> are you sure you can't structure it as a single-pass parse?
02:43:03 <Athas> Pretty sure, and it would be really ugly even if I could.
02:43:33 <Athas> Mixing parsing and compilation doesn't sound like a very good idea.
02:43:45 <xarch_> oh, actually it seems they're juste morphisms in the category of R-modules
02:43:51 <blackdog> ivanm: hm. that's kazu's project... he does some good work, i'll check it out.
02:44:09 <erus_> @hoogle orc
02:44:10 <lambdabot> Control.Exception data ErrorCall
02:44:10 <lambdabot> Control.Exception ErrorCall :: String -> ErrorCall
02:44:10 <lambdabot> Control.OldException ErrorCall :: String -> Exception
02:44:12 <erus_> @hoogle ord
02:44:12 <lambdabot> Data.Char ord :: Char -> Int
02:44:12 <lambdabot> module Data.Ord
02:44:12 <lambdabot> Prelude class Eq a => Ord a
02:44:29 <blackdog> Athas: depends on what sort of errors you're talking about, i suppose.
02:44:43 <jkff> Hi. Anyone know when ICFP Contest '2011 is going to take place, or any idea of when that date's to be announced?..
02:44:55 <Athas> blackdog: type errors, unknown variable errors, semantic errors, the usual stuff.
02:45:26 <jkff> hm. "The contest date will be annonced later (maybe in April), but it will be in the usual season (perhaps June or July).  Thank you!"
02:46:05 <jkff> that sucks. I'm traveling to CA around that period and I'd absolutely hate for ICFPC to coincide with a day-in-flight..
02:51:10 <erus_> how can i do this: increase the element n in an array by one returning a new array?
02:51:29 <erus_> is there a swap function or something?
02:51:50 <erus_> or should i just map over a zip with indicies
02:51:51 <jkff> :t (//)
02:51:52 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
02:52:14 <jkff> erus_, does that answer your question?
02:52:31 <erus_> Im sure it does but i dont really understand
02:52:40 <erus_> whats an Ix?
02:52:42 <Veinor> erus_: do you mean arrays or lists?
02:52:46 <erus_> list
02:52:53 <jkff> it's a typeclass for things that can be indices to arrays
02:53:06 <jkff> ints, enums etc
02:53:08 <sipa> it takes an array and a list of (index,value) pairs, and returns a new array
02:53:17 <sipa> with the selected positions updated
02:53:18 <Veinor> oh, okay
02:53:29 <Veinor> so you want, like, an Int -> (a -> a) -> [a] -> [a]
02:53:32 <jkff> erus_: do you really need an array? why don't you use Data.Map or Data.IntMap?
02:53:38 <erus_> jkff: can i do than with a list?
02:54:00 <jkff> and do you really need a Data.Array array, not STArray or STUArray (if for some reason Map doesn't fit you)
02:54:17 <sipa> erus_: wait, you want a list, not an array?
02:54:21 <jkff> erus_: indexed access to lists is just weird. you can, but since noone does that, there's no standard function for that.
02:54:32 <sipa> you shouldn't use lists for random-access
02:54:45 <erus_> bugger
02:54:58 <erus_> im writing a bf interpretter
02:55:08 <erus_> i guess i need to model memory as something else then
02:55:27 <erus_> any suggestions? 
02:55:46 <jkff> Data.Map is more than ok for that
02:56:03 <sipa> or if you really want efficient, STUArray
02:56:28 <jkff> if you're writing a "very fast" bf interpreter, then Data.IntMap. If you're writing a "freakin' fast" interpreter, then write it with the llvm package and do runtime code generation :)
02:56:31 <sipa> but that is harder to use, since you need the ST monad
02:57:25 <erus_> jkff: just one that works first. I can do a LLVM compiling bf another day
02:58:09 <jkff> Data.Map is ok and Data.IntMap is a drop-in replacement IIRC.
02:59:10 <erus_> i need a word8 map
02:59:18 <erus_> so i can just use Data.Map
02:59:33 <erus_> i thought maps where key value pairs, is this different in haskell?
02:59:43 <sipa> no
03:00:02 <sipa> but Data.IntMap is a specialized, more efficient, version where the keys are Int's
03:00:24 <sipa> Data.Map uses generic keys
03:01:57 <erus_> i only need a fixed size array
03:02:10 <erus_> with indecies
03:02:27 <erus_> IntMap asks for a kay every time i insert
03:02:47 <sipa> of course
03:02:56 <sipa> how can you insert without knowing where?
03:03:08 <erus_> ok
03:05:44 <erus_> if i wanna insert x 0 elements into a new IntMap
03:06:08 <kamatsu> hi all
03:06:18 <kamatsu> does anyone know of any code floating around anywhere that:
03:06:19 <roelvandijk> Hi!
03:06:23 <kamatsu> takes a haskell ast
03:06:28 <kamatsu> and produces a new haskell ast
03:06:34 <kamatsu> with fully qualified names everywhere?
03:06:44 <erus_> map (\x -> insert x 0 (IntMap a)) [0..(max-1)]
03:06:50 <erus_> something like that?
03:07:00 <sipa> erus_: map transforms a list into a new list
03:07:02 <erus_> this creates a new map every iteration
03:07:04 <sipa> you want a fold
03:07:18 <sipa> is it just for initialization?
03:07:21 <kamatsu> i need to do some mechanical translation of Haskell and I was wondering if someone had already written that sort of analysis
03:07:21 <lunaris> kamatsu: Not off the top of my head
03:07:27 <erus_> yeah just to create it
03:07:38 <sipa> erus_: in that case, use IntMap.fromList [ (x,0) | x <- [0..255] ]
03:07:44 <Eduard_Munteanu> You can create a map from a list.
03:07:53 <erus_> ah awesome
03:07:54 <lunaris> kamatsu: In case you need the other way, you could try: everywhere (mkT (mkName . nameBase))
03:08:03 <lunaris> kamatsu: Sorry :/
03:08:03 <roelvandijk> kamatsu: Are you using something like haskell-src-exts?
03:08:09 <Eduard_Munteanu> :t fromAscList
03:08:10 <lambdabot> Not in scope: `fromAscList'
03:08:29 <kamatsu> roelvandijk: yeah
03:08:38 <kamatsu> roelvandijk: happy to use something else (e.g GHC API) if needed
03:08:41 <lunaris> roelvandijk: How's the TH going? :P
03:08:56 <roelvandijk> lunaris: It compiles! And it broke haddock :-(
03:09:09 <erus_> sipa: can i still use the !! operator?
03:09:17 <lunaris> roelvandijk: Haddock needs to man up :)
03:09:33 <roelvandijk> kamatsu: Unfortunately I am unfamiliar with both, exept for knowing what they do
03:09:49 <Eduard_Munteanu> I think fromAscList might be faster.
03:09:57 <roelvandijk> lunaris: I'm trying to reduce the problem so I can submit a ticket for Haddock
03:11:54 <Eduard_Munteanu> erus_: (!!) is for lists
03:12:00 <Eduard_Munteanu> :t (!)
03:12:01 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
03:12:08 <Eduard_Munteanu> @hoogle (!)
03:12:09 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
03:12:09 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
03:12:09 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
03:12:15 <Eduard_Munteanu> @hoogle lookup
03:12:15 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
03:12:15 <lambdabot> Data.HashTable lookup :: HashTable key val -> key -> IO (Maybe val)
03:12:15 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
03:13:32 <lunaris> kamatsu: I guess you'd be forced to do an everywhereM (mkM qualify) or something
03:13:40 <lunaris> kamatsu: Where qualify :: Name -> Q Name
03:13:49 <lunaris> kamatsu: And it uses reify.
03:13:58 <erus_> thanks Eduard_Munteanu 
03:13:59 <lunaris> kamatsu: But that's with TH, and perhaps a bad solution anyhow.
03:14:36 <erus_> It doesnt  like this function declaration brainfuck :: String -> IntMap -> Int -> Int -> String
03:14:59 <erus_> it complains about IntMap is not applied to enough arguements
03:15:10 <lunaris> erus_: What is the value type?
03:15:12 <sipa> erus_: what are the values of the IntMap?
03:15:13 <lunaris> IntMap v
03:16:00 <markmywords> what is the best method to retrieve the size of a file in haskell?
03:16:01 <erus_> :t IntMap
03:16:01 <lambdabot> Not in scope: data constructor `IntMap'
03:16:16 <Eduard_Munteanu> * -> *
03:16:16 <erus_> @import Data.IntMap
03:16:16 <lambdabot> Unknown command, try @list
03:16:22 <sipa> :k IntMap
03:16:23 <lambdabot> Not in scope: type constructor or class `IntMap'
03:16:30 <sipa> :k Data.IntMap.IntMap
03:16:30 <lambdabot> * -> *
03:24:12 <erus_> > map (+1) {1..10
03:24:13 <lambdabot>   <no location info>: parse error on input `1'
03:24:17 <erus_> > map (+1) [1..10]
03:24:18 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
03:24:22 <erus_> > map (-1) [1..10]
03:24:23 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
03:24:35 <erus_> > map (+ -1) [1..10]
03:24:36 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
03:24:36 <lambdabot>      must have lower prece...
03:24:39 <kamatsu> lunaris: i need to parse a separate haskell file
03:24:44 <kamatsu> i don't think TH is what I want here
03:24:54 <erus_> is there a quick way todo -1 ?
03:25:16 <unfo-> erm map (- 1) [1..10] ?
03:26:22 <erus_> > map (- 1) [1..10]
03:26:23 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
03:26:50 <unfo-> > map (+ (-1)) [1..10]
03:26:52 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
03:26:59 <gienah> kamatsu: I am still trying to figure this stuff out, so I don't really know if this would work or not, but anyway: I wonder if you could do it with instant-generics
03:27:35 <erus_> yey thanks unfo- 
03:27:39 <unfo-> erus_, np :)
03:28:06 <erus_> well i have brainfuck without the loops
03:29:04 <gienah> kamatsu: http://www.cse.unsw.edu.au/~chak/project/generics/ then look at Paradise.hs ans Company.hs in the examples, and the research paper
03:30:29 <rs46> hi, I'm having a problem loading the module `unix-2.4.2.0', with this error message:
03:30:54 <rs46> Loading package unix-2.4.2.0 ... linking ... ghc: ~/.cabal/lib/unix-2.4.2.0/ghc-6.12.3/HSunix-2.4.2.0.o: unknown symbol `rtsTimerSignal'
03:31:17 <kamatsu> gienah: The three guys that wrote that work at the university I work at.
03:31:22 <kamatsu> gienah: this may be helpful.
03:31:27 <rs46> cabal has no problem reinstalling: cabal install unix-2.4.2.0 --reinstall
03:31:39 <kamatsu> except rl, he's gone now
03:31:54 <rs46> but nevertheless, trying to load the module always throws that error. Anyone any clues?
03:32:00 <gienah> kamatsu: it looks really cool to me, I'm trying to figure out how to use it
03:33:49 <kamatsu> I don't think it solves the problem i'm trying to solve
03:33:57 <kamatsu> makes it easier to walk over the AST, sure
03:35:00 <kamatsu> but what I'm trying to figure out is module exports etc.
03:35:09 <Twey> rs46: Did you use --make?
03:35:45 <morphles> in ghci, that is in interactive interpreter, there is no way to do data declarations?
03:36:01 <Twey> morphles: Other than writing them to a file and then loading it, no
03:36:11 <morphles> so sad :)
03:36:19 <rs46> Twey: --make, on which module ?
03:36:32 <Twey> erus_: No; -1 is a wart.  Use ‘subtract’ and ‘negate’.
03:36:40 <Twey> Or, in this case, ‘pred’
03:36:45 <Twey> > map pred [1 .. 10]
03:36:46 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
03:36:51 <believa> Is there a "graceful" way to clean out your cabal installed libraries (in .cabal) so as to start a fresh?
03:36:54 <gienah> kamatsu: I sort of thought that you could write a function for particular nodes in the AST while walking over it to fully qualify those. Also this tech report on generic programming is useful: http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-025.pdf
03:37:05 <Twey> believa: rm -rf
03:37:24 <rs46> Twey: I've tried both :load [my source file] and also ghc --make [my source file] with the same result
03:37:27 <believa> Twey: rm -rf .cabal ?
03:37:35 <kamatsu> gienah: that's true, but doesn't solve my problem. I need something that's aware of what is exported by a module
03:37:40 <Twey> rm -rf ~/.{cabal,ghc} is an operation I have performed many a time
03:37:40 <rs46> ghc: ~/.cabal/lib/unix-2.4.2.0/ghc-6.12.3/HSunix-2.4.2.0.o: unknown symbol `rtsTimerSignal'
03:37:49 <kamatsu> so it needs to know about ghc's api
03:38:35 <ivanm> Twey: backing up ~/.cabal/config first though?
03:39:07 <Twey> ivanm: I don't have anything in my ~/.cabal/config
03:39:20 <Twey> Apart from the defaults
03:39:21 <ivanm> oh?
03:39:26 <ivanm> fair enough then
03:39:36 <ivanm> I take it you don't "cabal upload" anything...
03:40:26 <Twey> I don't have a Hackage account :-\
03:42:02 <aristid> there's a cabal upload command? and i always used the website!
03:43:10 <aristid> Twey: easy to get one: http://hackage.haskell.org/packages/accounts.html
03:44:33 <Twey> It involves a human
03:44:52 <ezyang> Twey: We don't bite! 
03:45:27 <Twey> Eek!
03:46:02 <Twey> I'll finish my package first
03:46:59 <Twey> What happens if there are two JohnSmiths?
03:47:39 <Twey> I hold that user-generated handles are much better identifiers than realnames
03:53:51 <dsdeiz> hi! where do i find info about operators such as '$' or '|||' or '<+>'? :D
03:54:05 <sipa> :t ($)
03:54:06 <lambdabot> forall a b. (a -> b) -> a -> b
03:54:09 <sipa> :t (|||)
03:54:09 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
03:54:15 <sipa> :t (<+>)
03:54:16 <lambdabot>     Ambiguous occurrence `<+>'
03:54:16 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
03:54:16 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:54:0-46
03:54:30 <sipa> @hoogle (<+>)
03:54:30 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
03:54:31 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
03:54:31 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
03:55:54 <dsdeiz> i have no idea what those means, sorry. maybe a beginner's guide that explains about it?
04:00:36 <believa> Twey: thanks.
04:01:24 <Twey> dsdeiz: I'm guessing you're using xmonad?
04:11:26 <rs46> Does anyone have a clue how to fix this ticket:
04:11:27 <rs46> http://hackage.haskell.org/trac/hackage/ticket/808
04:11:36 <rs46> It appears that I am suffering the same issue
04:17:16 <ivanm> same version of GHC?
04:17:39 <ivanm> rs46: which version of Cabal do you already have?
04:17:59 <rs46> using version 1.8.0.6 of the Cabal library
04:19:12 <gienah> rs46: unix is a ghc core library, so I guess that cabal should link with the ghc unix
04:19:15 <ivanm> rs46: is that what "ghc-pkg list Cabal" says?
04:19:42 <Saizan> i don't think Cabal is relevant here
04:19:57 <rs46> /usr/lib/ghc-6.12.3/package.conf.d Cabal-1.8.0.6
04:20:05 <rs46> /u1/pg/rs46/.ghc/i386-linux-6.12.3/package.conf.d
04:20:06 <Saizan> building anything involving the unix package would probably produce the same error
04:20:28 <ivanm> rs46: are you trying to compile Cabal?
04:20:36 <ivanm> if so, why are you trying to compile a lower version than the one there?
04:21:02 <rs46> I'm trying to compile eden
04:21:14 <rs46> which is packaged with an older version of cabal
04:21:27 <ivanm> uh, what?
04:21:33 <dsdeiz> Twey: yea, hehe wanted to only know the basics so i know how to configure this wm
04:21:34 <ivanm> why does it come with a copy of Cabal?
04:21:45 <Saizan> ivanm: eden is a fork of ghc
04:21:50 <ivanm> :o
04:21:57 <ivanm> @google eden haskell
04:21:58 <lambdabot> http://www.mathematik.uni-marburg.de/~eden/
04:21:58 <lambdabot> Title: Eden: Parallel Functional Programming
04:22:30 <dankna> that's not going to be hard to maintain at ALL
04:22:46 <rs46> I also have the same issue when trying to run a haskell program with ghc. here's an example of a --make output of it:
04:23:00 <ivanm> dankna: of course not!
04:23:03 <dankna> heh :)
04:23:08 <fryguybob> rs46: I don't think that version of the unix library works with 6.12.3.
04:29:16 <Saizan> rs46: if you have ghc-6.12.1 you should try ghc-6.12.3 instead or maybe ghc-7.0.2, since this sounds like a bug in ghc or how it got built
04:29:43 <Saizan> http://askubuntu.com/questions/34390/problem-installing-cabal-1-8-0-2
04:29:44 <rs46> Saizan: thanks, I'll give 6.12.3 a shot now.
04:30:03 <ivanm> Saizan: if eden is a fork of GHC, then shouldn't he use an older GHC than when eden was forked?
04:30:12 <ivanm> since IIRC GHC can't build older versions of itself too well
04:30:45 <Saizan> i think eden is kept fairly up to date
04:31:52 <ivanm> ahhh, OK
04:32:23 <fryguybob> rs46: rtsTimerSignal was added in the following commits https://github.com/ghc/ghc/commit/47808bdc0bae8e5ba2910c85ea6c0699af01e97c  https://github.com/ghc/packages-unix/commit/04ba2812edb81fa07b05295b8487bfd1ff399f16
04:32:29 <Saizan> The Parallel Haskell Compilation System, version 6.12.3.20110124 <- output of ghc -V from my eden installation
04:33:11 <rs46> fryguybob: ah great !
04:33:20 <rs46> Fairly recent commit, 8th December.
04:33:28 <Saizan> which i've built with ,("Booter version","6.12.3")
04:34:04 <rs46> so rtsTimerSignal should be built into 6.12.3 ?
04:34:50 <fryguybob> rs46: It sounds to me like you just need to pick a version of the unix library that matches 6.12.3
04:34:56 <vegai> anyone used any graph database on Haskell?
04:35:05 <vegai> or more specifically, any RDF store?
04:35:08 <Saizan> i think so, but i can only be sure that eden built with vanilla ghc-6.12.3 on 19th january
04:35:37 <rs46> right, great. I'll go try and find a unix library version that loads w/o this error.
04:35:42 <rs46> cheers, I'll let you know
04:36:00 <ezyang> Folds don't, in general, preserve the original structure, correct? 
04:36:17 <rs46> vegai: look at the  Swish package
04:36:27 <pastorn> ezyang: true
04:36:27 <Twey> dsdeiz: I don't think you'll really get the benefit of XMonad unless you learn Haskell
04:36:32 <ezyang> Erm, as in, it is possible for me to write a valid fold function for which it is impossible to retrieve the original function. 
04:36:36 <pastorn> ezyang: sum = foldl (+) 0
04:36:41 <vegai> rs46: I was just looking at that, yes
04:36:43 <ezyang> *structure 
04:36:49 <ezyang> The former statement is trivial :-) 
04:38:09 <dsdeiz> Twey: I tried learnyouahaskell last time though since I don't use haskell and don't modify my configuration often, I tend to forget how things work.. heheh, anyway i guess i'll give myself another try w/ learnyouahaskell. thx!
04:39:22 <aristid> dsdeiz: learning haskell is also a good idea independent of xmonad :)
04:39:55 <Twey> dsdeiz: You're welcome ☺
04:39:55 <Twey> Yes
04:40:22 <Twey> xmonad is really designed for people who know Haskell and are comfortable extending it with their own code
04:40:36 <Twey> You can use it without knowing much Haskell, but you'll probably find the experience rather unsatisfactory
04:40:55 <ezyang> If you're good enough at cargo culting, you can manage. That's how I managed :-) 
04:40:58 <Twey> (I know I did)
04:41:17 <Twey> ezyang: Yeah, but just managing is not a very good argument for using something :þ
04:42:00 <Entroacceptor> cargo culting?
04:42:18 <quicksilver> I'm not sure it's true to say it's designed for people who are comfrotable extending it
04:42:30 <quicksilver> "the examples are intended to be useful and understandable for those users who do not know Haskell and don't want to have to learn it just to configure xmonad"
04:42:33 <quicksilver> from the docs.
04:42:36 <Twey> Entroacceptor: Copy-pasting idioms without understanding them
04:43:02 <Entroacceptor> ah
04:43:17 <Twey> quicksilver: It's usable, but it's not going to be very pleasant
04:44:39 <quicksilver> sure
04:44:55 <quicksilver> I was just (pedantically?) taking issue with your suggestion that's it's designed for haskell programmers.
04:45:11 <quicksilver> I'm fairly sure that, historically, the xmonad team has always hope it would be usable by non-haskell programmers.
04:45:16 <quicksilver> As to whether they succeeded...
04:45:26 <Twey> I thought that was what Bluetile was for
04:46:22 <Entroacceptor> it succeeded with me
04:52:36 <Eduard_Munteanu> Bah, it seems to be a while since the last xmonad release.
04:56:26 <ezyang> arguably, for a window manager, that's the way it should be. 
04:56:31 <ksf> shake rules should be able to mark themselves as non-changing after running.
04:56:46 <ksf> that is, nuke themselves from other rules' dependencies.
04:57:29 <ksf> there's also a quick hack that fixes the oracle-bug, but it's not at all as nice.
04:59:14 <ksf> one could use that to e.g. avoid rebuilding everything when CFLAGS changed by having an additional stripped-cflags target that can figure out that it didn't change after re-scanning CFLAGS
04:59:43 <ksf> also, more optionality.
04:59:45 <rootnode> hi
05:00:31 <ksf> like saying "look if warn-flags changed, but don't bother rebuilding stuff where that is the only changed dependency"
05:01:13 <rootnode> anyone here built ghc on snow leopard from source recently?
05:01:45 <ksf> and I'm not sure how to do "look if libfoo is available" properly in shake yet, either.
05:02:37 <ksf> the general sentiment is that when you have to ask, you should be using the binary.
05:03:04 <ksf> building ghc oneself has questionable benefits and not for the faint of heart.
05:06:56 <ksf> wait, I think shake already does the rebuild thing.
05:14:52 <rootnode> curse you libiconv!
05:25:58 <ksf> my ghc doesnt' link against iconv
05:26:23 <ksf> could be in ncurses, though.
05:29:55 <rootnode> guess I'll have to stick to 7.0.2 then
05:29:59 <rootnode> damn, I wanna use dph
05:32:34 <ahihi2> is it possible to tell cabal to look for libraries in a non-standard location before /usr, /usr/local etc when configuring?
05:34:13 <ksf> cabal uses pkgconf
05:34:45 <ksf> so try PKG_CONFIG_PATH
05:34:50 <ksf> (and man pkg-config)
05:34:51 <fryguybob> ahihi2: --extra-lib-dirs=PATH and --extra-include-dirs=PATH
05:35:00 <ksf> yeah, but that's lame.
05:37:32 <ahihi2> won't it still look in the standard locations first if you use the extra- options?
05:37:45 <ahihi2> I'll look at pkg-config, thanks
05:41:48 <ksf> PKG_CONFIG_PATH is something you can safely set in your .profile , which is why I prefer that over giving paths to configure each and every invocation.
05:45:23 <ksf> actually, no. from the dependency tracking side, shake is perfect, if I may say so. 
05:46:21 <ksf> building up lists like libflags+=lifboo_linkflags is still an open problem, though.
05:46:44 <ksf> probably by globbing over target names.
05:48:01 <ksf> this is awesome, we actually have a make system that is powerful enough to implement autoconf with.
05:50:01 <ksf> I shall go ahead and write a shakefile to build gnu make, just for audacity and hack value.
05:52:58 * Berengal now has music
05:52:58 <lambdabot> Berengal: You have 1 new message. '/msg lambdabot @messages' to read it.
05:55:26 <Berengal> ivanm: Yes, I'm aware. It's because of the Executable declaration, which is only there for development purposes anyway. If the bug causing it isn't fixed before it's released, I'll just comment it out.
05:55:39 <ivanm> good-o
05:55:47 * ivanm doesn't like that bug either...
05:56:02 <ksf> otoh, make has a way too long config.h
06:12:07 <rs46> Hi, I am having an issue linking package: HSUnix
06:12:30 <rs46>  ghc: /home/me/.cabal/lib/unix-2.4.2.0/ghc-7.0.1/HSunix-2.4.2.0.o: unknown symbol `rtsTimerSignal'
06:12:42 <rs46> I am running ghc 7.0.3
06:12:56 <rs46> *7.0.1
06:13:24 <ivanm> rs46: _still_? :o
06:13:25 <rs46> $ ghc --version
06:13:26 <rs46> The Glorious Glasgow Haskell Compilation System, version 7.0.1
06:13:30 <rs46> yup :-*(
06:13:35 <rs46> :-(
06:13:44 <rs46> but now running ghc 7.0.1
06:13:49 <ivanm> rs46: wait, unix comes with GHC
06:13:53 <ivanm> so why do you have a local copy?
06:14:08 <ivanm> that's _bad_
06:14:17 <ivanm> though 7.0.1 only comes with 2.4.1.0
06:14:41 <rs46> oh, let me look again st ghc-pkg
06:15:21 <Saizan> ksf: do you have some shakefile example to show?
06:15:33 <Spockz> I'm running GHC 6.12 and when using Debug.Trace.trace we lose UTF8 chars.
06:15:45 <ivanm> Spockz: "lose" ?
06:15:45 <Spockz> Debug.Trace.trace "τ" 1 results in ?\n1
06:16:06 <Spockz> ivanm: did you get my message?
06:16:08 <ivanm> that doesn't look like the escape code for it...
06:16:18 <ivanm> Spockz: the tau resulting in ?\n1 ?
06:16:38 <Spockz> well the 1 is from the constant one and \n is the newline char
06:17:22 <Spockz> ivanm: http://hpaste.org/45572/debugtracetrace_with_utf8
06:18:14 <ksf> Saizan, have a look at the tarball and neil's slides
06:18:31 <ivanm> Spockz: looks like it does that by design
06:18:35 <ksf> imagine make rolled into a dsl, and you're close.
06:18:37 <ivanm> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Debug-Trace.html
06:18:45 <ksf> the actual difference are the guts.
06:19:18 <ivanm> Spockz: of course, you shouldn't be _relying_ on Debug.Trace for anything...
06:19:29 <Spockz> ivanm: we are not relying :p
06:19:39 <Spockz> we just wanted to see some intermediate results
06:19:51 <Spockz> but enabling the glasgow extensions might help
06:19:53 * ivanm notes Spockz's usage of the royal "we"... :p
06:20:03 <ivanm> Spockz: no, extensions probably won't do anything
06:20:14 <Spockz> ivanm: me and my coding parnter :P
06:20:28 <ivanm> looks like ghc uses withCString instead of hPutStrLn for performance or something
06:20:39 <ksf> Saizan, it took 12 lines to make it track environment variables.
06:20:51 <ksf> that is, properly rebuild everything when cflags changes etc.
06:20:59 <Spockz> ivanm: yes
06:21:06 <rs46> ivanm: thanks, removed unix-2.4.2.0 and all looks good, cheers.
06:21:12 <ivanm> Spockz: asking the mailing list might help
06:21:24 <ivanm> rs46: remember: with the exception of Cabal, never touch any library that comes with GHC
06:21:28 <Spockz> ivanm: ah wait, I read the conditional incorrectly
06:21:32 <ivanm> Cabal can be upgraded, but leave the old version there
06:21:33 <rs46> very useful to know !
06:21:39 <rs46> thanks.
06:21:42 <ivanm> np
06:22:01 * ivanm wishes ghc-pkg had metadata to let you know when something was a boot library
06:22:16 <ksf> Spockz, just code up your own
06:22:35 <Spockz> ksf: doing it that right now
06:22:52 <Spockz> it's just that my first name isn't Simon so I'm not allowed to use unsafePerformIO :P
06:23:33 <aristid> @remember Spockz it's just that my first name isn't Simon so I'm not allowed to use unsafePerformIO :P
06:23:33 <lambdabot> I will remember.
06:23:38 <ksf> ...or even use hsLogger and unsafePerformIO to it.
06:23:44 <ksf> in the end, it's cleaner.
06:24:02 <ivanm> or "dons"
06:24:10 <ivanm> (to Spockz's quote)
06:24:24 <Spockz> ghehe
06:25:34 <Jesin> hmm...
06:25:38 <Jesin> instance Foldable f => Foldable (Stream f) where
06:25:39 <Jesin>   foldMap f (a :< as) = f a `mappend` foldMap (foldMap f) as
06:25:52 <Jesin> shouldn't that work, in this module? http://hackage.haskell.org/packages/archive/streams/latest/doc/html/Data-Stream-Branching.html
06:29:02 <Saizan> which error do you get?
06:29:10 <rootnode> damnit
06:29:35 <rootnode> anyone willing to give me some hints on how to install DPH on ghc 7.0.3?
06:29:41 <rootnode> (OSX)
06:35:58 * ksf would like a stalin-like compiler that generates one big, portable(!) C file.
06:37:49 <ksf> I always liked stalin's way of bootstrapping, it just ships with a .c file generated by running the compiler on itself.
06:38:02 <ksf> no other scheme needed.
06:39:39 <ksf> whereas .hc files are by definition unportable, due to being generated from preprocessed .hs files.
06:45:23 <aristid> stalin is a really bad name.
06:46:22 <co_dh> greeting, it seemed that haskellmode-emacs under http://projects.haskell.org/haskellmode-emacs/ is empty. 
06:46:36 <co_dh> anywhere else that I can find emacs mode for haskell? 
06:47:03 <ksf> ghc -M doesn't track -XCPP includes.
06:47:06 <Twey> Your package manager?
06:47:07 <ksf> neither does --make
06:47:18 <Saizan> co_dh: http://code.haskell.org/haskellmode-emacs/
06:47:19 <Twey> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
06:47:42 <co_dh> Saizan : thanks . 
06:49:53 <rootnode> Twey: at whom did you target that question?
06:50:04 <Twey> co_dh
06:51:22 <RSchulz> Morning, folks. I have Programming in Haskell, Real World Haskell and Haskell: The Craft of Functional Programming. For long-time programmer whose only exposure to anything remotely like a functional programming language is a few years of Scala, which book should I start with to learn Haskell?
06:52:05 <Saizan> the most introductory is the first
06:52:47 <zygoloid> there's also Learn You A Haskell, but it's aimed at less experienced programmers
06:53:26 <RSchulz> Programming Haskell is also the slimmest volume. OK, I'll start there. Thanks.
06:53:47 <RSchulz> What do people think of Pierce's Category Theory for Computer Scientists?
06:54:28 <Saizan> no excitement about it :)
06:55:06 <magicman> Grrr.
06:55:09 <gienah> RSchulz: that it doesn't match the standard of his book on type theory
06:55:15 <magicman> "head: Empty list" is the nullPointerException of Haskell...
06:55:54 <xarch_> someone said it was short and too much fast paced, I think
06:56:25 <RSchulz> gienah: That being TAPL?
06:56:45 <gienah> RSchulz: yes, TAPL is a great book
06:57:11 <RSchulz> Yes, I've heard only good things about it.
06:57:14 <RSchulz> Thanks.
06:57:29 <frerich> @src gcd
06:57:29 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
06:57:30 <lambdabot> gcd x y = gcd' (abs x) (abs y)
06:57:30 <lambdabot>    where gcd' a 0  =  a
06:57:30 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
06:58:03 <frerich> Is there any way to rewrite the 'gcd 0 0' case above so that it's just "gcd 0 0 = undefined" and it yields the same (or at least equally descriptive) erro rmessage?
06:58:14 <Jesin> umm
06:58:32 <Jesin> "undefined" is actually defined in the prelude as
06:58:41 <Jesin> undefined = error "Prelude.undefined"
06:58:51 <Jesin> :P
06:58:52 <frerich> Exactly.
06:59:03 <sipa> @src undefined
06:59:03 <lambdabot> undefined =  error "Prelude.undefined"
06:59:08 <Jesin> "error" is what you use if you want to specify the error message
06:59:14 <frerich> Right.
06:59:24 <Jesin> if you don't want a descriptive error message you use "undefined"
06:59:45 <Jesin> so, if you want something that acts like "undefined" but with a descriptive error message, you use error
07:00:02 <frerich> My point is - it seems odd to write 'f 0 = error "f 0 is undefined"'. It would be neat if I could do something like 'f 0 = undefined' and evaluating 'f 0' will then make the program yield an error with the text 'f 0 is undefined'
07:00:58 <Jesin> well, it's not always clear what expression should go in that string.
07:01:20 <Jesin> That'd need a special compiler extension, I guess
07:01:50 <frerich> It would be nice if this "cool_undefined" function could use some sort of reflection to tell how/where it was invoked.
07:02:20 <frerich> but yes, I see your point, in something like 'f (1 - 1)', should it print "f 0 is undefined" or "f (1-1) is undefined"? I  guess the former.
07:02:50 <Jesin> what about stuff like this, though:
07:03:11 <Jesin> f x | x <= 0 = undefined
07:03:13 <Jesin>     | otherwise = otherstuff
07:03:34 <Jesin> or
07:03:59 <Jesin> f x = case g x of
07:04:00 <Jesin>   foo -> undefined
07:04:02 <Jesin>   _ -> baz
07:04:10 <Jesin> ...meh.
07:04:17 <Jesin> It just sounds like it'd be a pain to write
07:04:24 <Jesin> for minimal benefit
07:04:57 <Jesin> error "Module.function: function bad arguments is undefined"
07:05:04 <Jesin> is not too hard to write, I think?
07:05:20 <frerich> I didn't claim it's easy. I guess another problem is having arguments without an instance of Show
07:05:34 <Jesin> ^ yeah that
07:05:42 <amitava> hi, I git cloned the ghc git repo but can't find the source for the standard libraries like Prelude - does anyone know the right place to go?
07:06:07 <ezyang> amitava: You need to use ./sync-all to get the rest of the repositories 
07:06:11 <Twey> Why does haskell-mode fill paragraphs of Haddock documentation by repeating | on each line?  Haddock doesn't like this >.<
07:06:29 <ezyang> http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources 
07:10:13 <amitava> ezyang: i did ./sync-all --testsuite get  - is there a command to just bring in all the sources?
07:10:25 <ezyang> That should have done it. 
07:10:36 <amitava> thx
07:18:13 <kstt> jaspervdj: hello
07:19:23 <jaspervdj> kstt: hi
07:20:01 <kstt> my associate finaly took some time to play with blaze and loved it (we are demotera, the french cpny using hakyll). That's great news for us, as if he starts embrassing haskell, we might turn more and more of our offers to it.
07:20:17 <kstt> and that exciting really :)
07:20:42 <jaspervdj>  Ah, great :-)
07:22:06 <kstt> So, he tried it, and came back with lots of praises, but also a problem : he wants to generate successive spans, separated by blanks (there seems to be a semantic associated to blanks in HTML, but I don't know much of it). He said he could not find how to do so in Blaze, as successive spans are joined.
07:23:25 <kstt> Here, a 'blank' it either a space, a newline or a tab AFAIK
07:24:12 <kstt> Does that make sense to you ?
07:24:58 <ksf> kstt, sucessive whitespace is collapsed in html renderers
07:25:16 <mrcarrot> what is blaze?
07:25:39 <ksf> if blaze uses the backend I think it does, it even uses <foo\n> for formatting as that's the only way to format stuff without injecting text spaces.
07:25:44 <ksf> a html builder
07:26:13 <mrcarrot> is it working like a web framework?
07:26:26 <ksf> it's working like a template engine
07:26:32 <mrcarrot> okay
07:26:39 <kstt> ksf: yes, there is no semantic difference in any of [:blank:]+
07:26:40 <mrcarrot> does it support i18n?
07:26:51 <ksf> it's a viable component of both web frameworks and say static page generators.
07:27:06 <ksf> or do you mean the <span> tag?
07:27:08 <kstt> ksf: but there is a semantic difference between no blank and some blank(s).
07:27:13 <jaspervdj> kstt: http://hpaste.org/45577/blaze_separating_spans
07:27:15 <ksf> yes.
07:27:21 <jaspervdj> (solution to your earlier question)
07:27:52 <jaspervdj> mrcarrot: It's easy to add i18n to blaze since it's embedded in haskell
07:27:54 <ksf> blaze just doesn't insert blanks between tags.
07:28:25 <kstt> jaspervdj: ok thanks :)  That's what I  proposed, but I was not aware of the ability to directly type strings in. That's neat :)
07:28:29 <ksf> and haskell has the most awesome massive-overkill i18n solution ever.
07:28:43 <ksf> http://www.grammaticalframework.org/
07:28:48 <kstt> Is that offered by the overloaded strings ext ?
07:28:54 <jaspervdj> kstt: yes
07:29:16 <kstt> That rox, I must read the code that make that possible !
07:29:47 <ksf> is blaze yet another monoid that poses as monad?
07:30:00 <jaspervdj> ksf: Yeah
07:30:54 <ksf> makes me wonder whether we should allow do-notation for monoids
07:31:34 <ksf> or introduce a "combine" keyword.
07:31:59 <ksf> or, rather list. you can mconcat the stuff, then.
07:33:26 * ksf is looking for a project to try out shake on.
07:33:29 <quicksilver> ksf: I've pondered a layout construct for lists. or for functions which take lists.
07:33:50 <quicksilver> ksf: but really, I don't understand the objection to [ ... ]
07:33:51 <ksf> anyone of you got a moderately-sized c or something project without insanely big autconf?
07:34:07 <quicksilver> that is, I don't find mconcat $ [ \n .... \n ] ugly.
07:34:14 <ksf> syntacticlal cleansines
07:34:20 <quicksilver> except, possibly for the ugliness of the word 'mconcat' itself.
07:34:22 <ksf> it's the cancer of the comma.
07:34:32 <frerich> ksf: ccache
07:35:20 <ksf> ...that, preferrably, is in urgent need of a new build system.
07:35:32 <jaspervdj> ksf: iirc we made a GHC ticket
07:35:56 <Jafet> Hm, takeWhile f = fst.span f, shaving off one char
07:36:10 <Jafet> Wonder why I never found this sooner
07:37:20 <ksf> regarding ccache in particular, basically the only reason it exists is because people don't know how to use make
07:37:42 <ksf> as it speeds up the usual fix for broken builds, that being make clean; make
07:38:15 <flux> ksf, so how should I use make properly, when I often switch between branches of the same code base and I would like to reuse previous object files?
07:38:26 <Jafet> make is easy to misuse, since you have to write the dependencies
07:38:29 <flux> (yeah, can be done, but ccache is just easy ;-))
07:38:45 <Jafet> There is sometimes no easy way to express the dependencies
07:38:55 <ksf> flux, does your vcs change the mtimes of untouched files?
07:39:04 <ksf> if yes, I argue it's broken.
07:39:15 <flux> ksf, obviously not, but a small change in a C header file can cause everything to be rebuilt
07:39:17 <ksf> make sucks when it comes to generated files, yes.
07:39:19 <ksf> shake doesn't.
07:39:36 <ksf> split up your headers. that's C's fault.
07:39:53 <ksf> and autoconf, which defaults to one big config.h
07:39:54 <flux> even so, it can cause a significant part of code to be rebuilt
07:40:08 <ksf> well, and it bloody well should.
07:40:21 <flux> and ccache avoids that, if you just recently built that particular branch
07:40:42 <ksf> vcs integration is an interesting topic, though.
07:40:55 <frerich> ksf: The only reason why ccache exists is for builds from scratch, which is what many projects do during nightly tests (or for releases). In particular, Samba does it (which is what ccache was written for).
07:41:05 <frerich> ksf: It's not meant to work around incomplete dependencies of build systems.
07:41:15 <ksf> ...different build dirs for each branch.
07:41:37 <ksf> it's also meant for failed emerges.
07:41:43 <ksf> at least that's why I have it installed.
07:41:50 <MasseR> ksf: You testing Shake or OpenShake?
07:41:55 <ksf> openshake
07:41:59 <flux> ksf, and which one of the solutions do I have now, which is as easy to use as CC=ccache\ cc is?-)
07:43:09 <ksf> well, shake can be smart enough to rebuild when CFLAGS change but still not do it when filtered-cflags stay the same.
07:43:29 <ksf> most of its power is still a mere potential
07:43:35 <MasseR> ksf: Is shake mature enough for any real projects?
07:43:47 <ksf> I'd say so.
07:43:51 <MasseR> I find it interesting, but not enough to try it on any project
07:43:54 <ksf> well, and that's what I want to try.
07:44:02 <flux> btw, while staying on the topic of being off-topic, what would be a decent make replacement that deals with white spaces in file names and would be suitable for bulk media conversions as well?
07:44:11 <MasseR> Err disregard my previous sentence. Makes no sense
07:44:36 <ksf> shake doesn't get confused by whitespace
07:44:53 <ksf> what do you mean with bulk media conversion?
07:45:02 <klugez> http://hpaste.org/45579/compile_error_in_cabal_install - I get a compile error when trying to install network.
07:45:40 <ksf> that looks like a version mismatch.
07:45:50 <ksf> either use a newer network or ghc
07:46:29 <flux> ksf, that it's not geared too much towards program compilation and has pattern rules
07:46:51 <ksf> MasseR, it's stable, that is, and the core seems to be darn mature.
07:46:59 <ksf> driver and library not so much
07:47:05 <MasseR> ksf: Is there some documentation for openshake or are you going by the shake pdf presentation from 2010 workshop?
07:47:12 <ksf> I'm going by the source code.
07:47:23 <ksf> shake uses pattern rules
07:47:32 <ksf> in that aspect, it's very, very make-like.
07:47:48 <MasseR> If you get something done and have time left, do write about it :)
07:48:00 <MasseR> At the very least, I'm interested
07:48:05 <ksf> though files is only one namespace you can depend on, you can code your own.
07:48:11 <klugez> ksf: I have Debian's GHC 7.0.3-1 and seems like that is the newest network it's trying to install with "cabal install network".
07:49:01 <ksf> well, don't use 7.0.3
07:49:10 <ksf> the latest platform release is 7.0.2
07:49:30 <ksf> it always takes some time for  hackage to catch up
07:50:11 <klugez> OK.
07:51:02 <TomMD> I have 7.0.3 and network installed
07:51:39 <klugez> network-2.3.0.2 ?
07:52:08 <TomMD> klugez: Not sure about cabal-installing it, but 2.3.0.2 is installed (perhaps from cabal perhaps it was included in the ghc binary install)
07:53:19 <TomMD> klugez: It has to have been from cabal, it's in my user directory, not the global.
07:54:18 <klugez> Interesting. Any other possible explanations for this?
07:54:31 <TomMD> Johan does a good job keeping network up.  If a version of GHC is going to be released (is in a .0 stage) then I'm sure he'd have it building on that.
07:55:47 <tromp_> anyone know the apl derivative K?
07:56:29 <TomMD> klugez: Yes, I found it.
07:56:39 <tromp_> was reading an introduction at http://www.kuro5hin.org/story/2002/11/14/22741/791
07:56:50 <TomMD> Look at the network source, you see it defines closeFdWith only if... #if !MIN_VERSION_base(4,3,1)
07:57:00 <tromp_> hard to see how anyone that knows haskell could appreciate that language:(
07:57:35 <TomMD> So I guess either thats wrong, and you have a version of base less than 4.3.1 but great enough to have a closeFdWith function... or the cabal MIN_VERSION macro is broken.
07:57:44 <TomMD> what version of base is being used in this build, klugez?
07:58:58 <blueonyx> hey, how to define a postInst hook which depends on the package just installed?
07:59:04 <klugez> base-4.3.1.0 is installed.
07:59:06 <blueonyx> (for Setup.sh)
07:59:25 <TomMD> klugez: But is that what the cabal install of network is using?
07:59:36 <klugez> How can I check that?
08:01:52 <TomMD> klugez: cabal install network --verbose
08:01:52 <TomMD> You'll see a line such as "Dependency base ==4.3.1.0: using base-4.3.1.0"
08:02:12 <TomMD> might want to pipe it into a "less" instance so you can search automatically.
08:03:00 <klugez> Dependency base ==4.3.1.0: using base-4.3.1.0
08:08:29 <mauke> I can't use coinduction; my coinducts are clogged
08:09:57 * hackagebot music-diatonic 0.0.1 - Implementation of basic western musical theory objects.  http://hackage.haskell.org/package/music-diatonic-0.0.1 (PatrickLeBoutillier)
08:10:11 <TomMD> klugez: So you have either a broken cabal (causing broken macros) or a bad copy of the network package.  If you look at the code you can clearly see GHC.Conc's importing that function is mutually exclusive with the function being defined locally.
08:13:43 <FUZxxl> @pl \k _ -> `elem` k
08:13:44 <lambdabot> (line 1, column 9):
08:13:44 <lambdabot> unexpected "`"
08:13:44 <lambdabot> expecting lambda abstraction or expression
08:13:49 <FUZxxl> @pl \k _ -> (`elem` k)
08:13:49 <lambdabot> const . flip elem
08:14:09 <FUZxxl> @pl \k _ -> (k `elem` l)
08:14:09 <lambdabot> const . (`elem` l)
08:14:33 <klugez> TomMD: Alright, maybe I'll try with a different cabal.
08:15:39 <ksf> oh. continuous integration support would be nice.
08:16:06 <ksf> that is, shake &, then edit a file and have shake pick it up and automatically rebuild.
08:16:45 <ksf> needs more concurrency support, that is, concurrent shake invokations, and a hell of a logging framework.
08:16:53 <navaati> hello
08:17:03 <byorgey> hi navaati 
08:17:35 <ksf> but it'd finally be strictly more powerful than ghc --make for building vanilla projects, then.
08:17:38 <blueonyx> is it possible to define a Setup.hs postInst hook which depends on the package just installed?
08:18:10 <yitz> byorgey: anything interesting come out of linear lambda terms in the end?
08:18:20 <ksf> recent cabal versions can have executables that depend on the package's library, so your chances aren't bad.
08:19:16 <ksf> wait, what am I saying, no.
08:19:23 <ksf> your setup.hs is compiled beforehand.
08:19:48 <ksf> you can shell out, though.
08:19:55 <navaati> in this piece of code http://pastebin.com/mdaU321w, where "getSize" is a typeclass method, GHC doesn't want to bind the v of the instance to the v of ":: (Int, v)", ans so it can't find what instance call for getSize
08:20:20 <navaati> how can i bind it properly (in the error messages the v in ":: (Int, v)" is called v1 -_-
08:20:21 <mauke> that's a different v
08:20:34 <navaati> yes, but how can I make it the same ?
08:20:42 <mauke> what's the type of newAddresses?
08:21:00 <navaati> class Parameters p where
08:21:00 <navaati>   newAddresses :: ProgramMonad p
08:22:05 <mauke> newAddresses = do { (size, v) <- getSize; addr <- request size; return (newAddress addr `asTypeOf` v) }
08:22:19 <mauke> hmm, that makes no sense
08:22:29 <mauke> let { (size, v) = getSize };
08:23:44 <navaati> the second member of the tuple is always equal to undefined :: I use it as a type marker to permit GHC to select the right instance… it it seems it doesn't work
08:23:59 <mauke> did you try my code?
08:24:05 <navaati> `asTypeOf` ?
08:24:12 <navaati> i'll see this…
08:26:01 <navaati> wow, amazingly magic, i didn't known this "asTypeOf", thanks a lot
08:26:25 <mauke> @src asTypeOf
08:26:25 <lambdabot> asTypeOf = const
08:26:34 <klugez> TomMD: Now I succeeded. New cabal-install helped. Thanks for your help!
08:27:23 <RSchulzB> Cabal is the Haskell package manager, yes? What's the origin of that name??
08:28:24 <int-e> @type asTypeOf
08:28:25 <lambdabot> forall a. a -> a -> a
08:29:54 <blueonyx> thanks ksf!
08:36:41 <TomMD> klugez: no problem
08:56:57 <blueonyx> what to do on: cabal: failed to parse output of 'ghc-pkg dump'?
08:57:38 <blueonyx> oh upgrade cabal-install xD
08:58:14 <int-e> yeah.
09:01:03 <blueonyx> hm i got a old one in ~/.cabal/bin but a 0.10.2 in /usr/bin but the latter says the same O.o
09:01:54 <int-e> hmm, what version of the cabal library does it use?
09:02:26 <blueonyx> 1.10.1.0
09:04:57 <blueonyx> ah there's a new version of ghc anyhow, i'll come back later
09:12:47 <Berengal> I have a C function that takes a callback, then goes off and spawn a new thread, calling the callback there. Is this a problem?
09:13:54 <c_wraith> potentially.  depends on what is in the callback.
09:14:07 <c_wraith> You can certainly put things in the callback that won't work with that.
09:14:07 <Berengal> I want it to be a haskell function, of course
09:14:52 <c_wraith> The same thing applies.  If you're using OpenGL, for instance, all use of the haskell bindings must be from the same thread
09:15:44 <c_wraith> Though in general, Haskell functions are less likely to use threadlocal state, so that situation is most likely to arise from bindings to C code
09:16:10 <tarrasch> Hello! Do anyone know any good articles where they use quickcheck to test c-code? Is that something painful or worthwhile?
09:16:27 <Berengal> That's not something I can guard against. If you're using a single-threaded library, the onus is on you to make sure you're only using a single thread
09:16:46 <Berengal> I can make sure it could possibly work at all though
09:16:52 <tarrasch> I don't find any splendid results when googling, mostly people using quickcheck alongside for 'similiar functions'
09:17:29 <Berengal> I'm asking because I don't quite know exactly what a "safe" ffi call can do that an unsafe one can't
09:17:51 <c_wraith> you absolutely would need a safe call for this
09:18:20 <Berengal> I guessed as much, but the call itself returns almost immediately
09:18:40 <developernotes> I am trying to define a type like an associative array such as something like this: http://pastie.org/1783341 but I get an error on the first item ("bar" in the example).  Any thoughts?
09:18:49 <c_wraith> Well.  under most load conditions.  remember that threads don't guarantee execution order :)
09:19:38 <Berengal> Yes, indeed, and there's a reason the c-library is forking off a different thread, namely so it can run for a long time
09:19:58 <developernotes> How can I tell it to expect a [String], it looks like it is looking for just a Char, but is getting [Char].
09:20:11 <Berengal> So I'm wondering if the provisions a safe call provide are still valid after it returns somehow
09:20:25 <Berengal> I don't know exactly what provisions it does make however...
09:20:42 <c_wraith> basically, it guards the RTS state.
09:21:02 <c_wraith> an unsafe call is inlined into the code, for all intents and purposes.
09:21:36 <Berengal> How long does it guard it for? Until it's GCed?
09:22:35 <Berengal> And I assume from your previous comments that it's guarded across all threads
09:23:54 <c_wraith> well, a safe call executes the native call in a different OS thread than the RTS is using, and just sets the RTS thread to block until it gets a result.
09:24:14 <c_wraith> So, for all intents and purposes, it's just another thread blocked on IO
09:24:40 <c_wraith> And since the execution context is an entirely different thread, you need to put real effort into screwing up the RTS
09:25:12 <c_wraith> The RTS keeps a pool of extra threads around for making safe native calls
09:25:16 <Berengal> The foreign call can call back into haskell. Does this somehow create a new RTS context then?
09:25:33 <yitz> > let items = [("foo", ["bar", "baz", "qux"]), ("a", ["b","c"])] in lookup "foo" items -- developernotes
09:25:33 <lambdabot>   Just ["bar","baz","qux"]
09:25:34 <ski> developernotes : maybe you wanted `items = [("foo", ["bar", "baz", "qux"])]' ?
09:25:35 <NisseP> developernotes: all the items in a list have to be the same type. you might want a list of tuples or something: [("foo", ["bar", "baz", "quux"]), ("another", ["a", "b", "c"])]
09:25:50 * hackagebot xml 1.3.8 - A simple XML library.  http://hackage.haskell.org/package/xml-1.3.8 (IavorDiatchki)
09:26:15 <c_wraith> Berengal: nah, callbacks into haskell in safe calls are set up to schedule a new RTS thread for executing the callback.
09:26:30 <NisseP> developernotes: alternatively, the module Data.Map
09:26:41 <developernotes> NisseP: will that allow be to treat foo as the key and get ["bar", "baz", "quux"] back from the map?
09:26:48 <ski> yes
09:27:04 <ski> developernotes : see yitz' example with lambdabot above
09:27:10 <developernotes> NisseP: I had imported Data.Map, but wasn't sure how to use it with this structure?
09:27:19 <Berengal> c_wraith: Does this go for all callbacks? Because the function I'm calling definitely doesn't do the callback itself, it just passes the pointer along to the new thread it creates
09:27:22 <NisseP> :t Data.Map.fromList
09:27:23 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
09:28:07 <yitz> > let items = M.fromList [("foo", ["bar", "baz", "qux"]), ("a", ["b","c"])] in M.lookup "foo" items -- developernotes
09:28:08 <lambdabot>   Just ["bar","baz","qux"]
09:28:11 <developernotes> yitz: ski: NisseP: thanks!
09:28:18 <c_wraith> Berengal: It's part of the FunPtr wrapping, if I remember this properly
09:28:35 <yitz> developernotes: in lambdabot, M stands for Data.Map
09:28:44 <Berengal> So then I could actually do an unsafe call...
09:29:40 <developernotes> yitz: so M is aliased to Data.Map? Is that a default setting?
09:30:07 <yitz> developernotes: no, only here in #haskell, for lambdabot
09:30:22 <developernotes> yitz: gotcha, thanks!
09:30:24 <c_wraith> Berengal: only if you can guarantee the OS scheduler will *never* run your thread that does the callback before the unsafe call finishes.  That's not something most OSes can promise you, under bizarre load conditions
09:30:46 <yitz> developernotes: you can do that in your code too, though, if you want. "import qualified Data.Map as M". It's a common idiom.
09:31:09 <yitz> developernotes: in GHC 7, you can even do that at the GHCi prompt now.
09:31:28 <Berengal> c_wraith: Wait, so what's the difference if another thread does the callback before and after the spawning call is finished?
09:32:22 <c_wraith> Berengal: the RTS state is not guaranteed to be in a place where it can handle the callback during an unsafe call
09:33:14 <Berengal> c_wraith: How is that different from all the other unsafe calls I could be making at other times?
09:33:46 <Berengal> Here's the relevant code, if it helps you understand: https://github.com/LaurentGomila/SFML/blob/master/src/SFML/Audio/SoundRecorder.cpp
09:34:49 <c_wraith> Ah, audio.
09:43:04 <ksf> gragh pandoc doesn't do internal links
09:46:24 <outsid3r> hi, i cant import Char to a file
09:46:44 <outsid3r> on ghci it says that file name does not match module name 'Main'
09:46:53 <outsid3r> when i try to load it
09:46:58 <Berengal> Argh! "The second major omission is the definition of the interaction with multithreading in the foreign language and, in particular, the treatment of thread-local state, and so these details are currently implementation-defined."
09:47:19 <ksf> when you leave out the module Foo where ...  thing ghc assumes you want to call it Main
09:47:31 <outsid3r> so what i should do?
09:47:57 <ksf> prepend "module Char where" to your file
09:48:12 <ksf> (in case my crystal ball isn't mistaken)
09:48:34 <outsid3r> and what i do to import Char?
09:49:48 <ksf> write "import Char" between module ... and your functions into another file.
09:50:42 <outsid3r> it gives me errors
09:50:56 * hackagebot xorshift 2.0.1 - Haskell implementation of the xorshift random generator.  http://hackage.haskell.org/package/xorshift-2.0.1 (RobertClausecker)
09:51:34 <ksf> can you paste all the relevant files and the error?
09:51:37 <ksf> @where hpaste
09:51:37 <lambdabot> http://hpaste.org/
09:52:17 <ksf> also, to the general audience, I'm still in search of a moderately-sized project that needs a new build system.
09:52:44 <ian_mi> crap, now that I've discovered monad transformers I'm doing everything imperatively again
09:53:00 <ksf> I don't care what you build as long as it's not haskell or any other language that has --make
09:53:51 <Berengal> ksf: Java
09:53:51 <ksf> in other news, haskell has been discovered to be the best imperative language, again.
09:53:56 <outsid3r> http://hpaste.org/45583/aa
09:54:24 <ksf> well, a) building java is usually a matter of javac *.java, b) java isn't a project
09:54:52 <ksf> I've seen one ant script in my whole life, and I was glad I had it.
09:55:16 <ksf> could've been a .bat file for what it's worth, though.
09:55:37 <Berengal> Pshaw. Ant... -_-
09:55:42 <outsid3r> so what's the problem?
09:55:49 <ksf> that looks fine.
09:55:52 <Berengal> I was thinking more polyglot jvm, but I can't think of a project...
09:55:54 <Berengal> Clojure maybe?
09:56:05 <ksf> ...if it's in a file called Char.hs
09:56:19 <outsid3r> why it must be in a file called Char.hs?
09:56:28 <ksf> because it's named Char.
09:56:39 <ksf> what you're actually going at, though, I think, is "chr".
09:56:45 <ksf> ...which lives in Data.Char iirc.
09:57:09 <outsid3r> oh
09:57:24 <ksf> yep, it does.
09:57:27 <outsid3r> i want to use Char function
09:57:30 <outsid3r> functions
09:57:39 <Berengal> Also Char
09:57:46 <ski> @index chr
09:57:46 <lambdabot> Data.Char
09:57:47 <ksf> import Data.Char
09:57:55 <Berengal> (Char is defined in Haskell-98)
09:57:57 <outsid3r> i thought that 'module Char' was actually importing char
09:58:13 <ksf> no, it's giving the name of the module, and optional export list.
09:58:17 <ski> `module Char' is saying that you name the module you're currentry writing, as `Char'
09:58:21 <kjslag> Is there a way to tell ghci to use a different show function?
09:58:25 <outsid3r> but import Data.Char does not work also
09:59:06 <outsid3r> it gives me that error, 'file name does not match module name  'Main''
09:59:54 <ksf> that's unrelated to the import, though.
10:00:16 <outsid3r> so, is related to what?
10:00:27 <ksf> tbh, I have no idea
10:00:35 <outsid3r> windows maybe?
10:00:46 <outsid3r> im using ghci on windows
10:00:48 <Berengal> How are you loading the file?
10:00:50 <ksf> what's the exact way you're trying to run it and the full error?
10:00:59 <outsid3r> using :load
10:01:06 <outsid3r> on ghci
10:01:21 <ski> kjslag : i don't think so (in Hugs, there's `:s -u' to diable use of `show') .. what for ?
10:01:26 <Berengal> Does the module still have a "module Char where" declaration?
10:02:08 <outsid3r> module Char where
10:02:10 <outsid3r> import Char
10:02:12 <outsid3r> like this?
10:02:17 <ksf> that *should* work, here.
10:02:25 <ksf> import Data.Char
10:02:31 <ksf> you can leave out the module line
10:02:44 <magnicida> hello
10:02:59 <Berengal> Try to load it by starting ghci with "ghci <yourfile>" instead
10:03:11 <outsid3r> if i do import Data.Char it gives me the same error about module main
10:03:15 <magnicida> is there any function equivalent to [(a, b) | a <- l1, b <- l2]
10:03:22 <byorgey> yitz: it turned out that taking pairs into account was much more difficult than I thought, and then I got busy doing other things.
10:03:26 <magnicida> this is, the product of two lists
10:03:31 <ski> magnicida : there's `liftM2 (,)' ..
10:03:35 <byorgey> yitz: if I get time I'll try to at least write about why pairs are difficult.
10:03:38 <outsid3r> it worked !
10:03:40 <ski> > liftM2 (,) "abc" "01"
10:03:40 <magnicida> thanks a lot ski!
10:03:40 <Berengal> magnicida: zip
10:03:41 <lambdabot>   [('a','0'),('a','1'),('b','0'),('b','1'),('c','0'),('c','1')]
10:03:41 <outsid3r> i restarted ghci
10:03:52 <outsid3r> so it was some kind of ghci bug
10:03:52 <byorgey> Berengal: zip isn't the same thing.
10:03:59 <ski> (you'll need `Control.Monad' for `liftM2')
10:04:04 <Berengal> byorgey: Right, I thought those looked like pipes for a seconds...
10:04:23 <ksf> outsid3r, http://hpaste.org/45584/foo
10:04:39 * Berengal doesn't use his coding font in IRC
10:04:40 <ski> > sequence ["abc","01"]  -- magnicida, also this
10:04:41 <lambdabot>   ["a0","a1","b0","b1","c0","c1"]
10:04:48 <outsid3r> ksf: the problem is fixed already, i restarted ghci...
10:04:59 <yitz> byorgey: interesting. reading the beginning, it looked like it was going to turn out be trivial. i guess that almost never happens with the lambda calculus...
10:05:27 <ski> > [(a, b) | a <- "abc" | b <- "01"]
10:05:28 <lambdabot>   [('a','0'),('b','1')]
10:05:34 <ski> > zip "abc" "01"
10:05:35 <lambdabot>   [('a','0'),('b','1')]
10:06:14 <byorgey> yitz: I thought it was going to turn out to be trivial too!  what it basically boiled down to was that you can't just destruct pairs as soon as you get them -- you need to guess in what context each pair should be destructed.
10:06:24 <ski> > zipWith (,) "abc" "01"
10:06:25 <lambdabot>   [('a','0'),('b','1')]
10:06:55 <ski> > getZipList (liftA2 (,) (ZipList "abc") (ZipList "01"))
10:06:56 <lambdabot>   [('a','0'),('b','1')]
10:07:17 <byorgey> yitz: so I guess in theory it shouldn't be too hard to have a ridiculously inefficient version that works, but the search space gets huge really fast.
10:08:05 * ski idly wonders what byorgey is talking about
10:10:27 <byorgey> ski: http://byorgey.wordpress.com/2011/02/24/enumerating-linear-inhabitants/
10:10:37 <byorgey> extending it to handle pair types
10:11:27 <magnicida> ski: what is the tip for reasoning of a list as a Monad?
10:11:33 <ski> > getZipList (Data.Traversable.sequenceA [ZipList "abc",ZipList "01"])
10:11:34 <lambdabot>   ["a0","b1"]
10:11:57 <ski> byorgey : ok. is this re species ?
10:12:06 <ski> magnicida : sorry ?
10:12:19 <ski> i'm not sure if there's a single tip
10:12:32 <magnicida> ski: I mean, liftM2 did what it should
10:12:32 <byorgey> ski: not really.  well, I'm sure there are connections, but I don't know what they are.
10:12:50 <zygoloid> magnicida: nondeterminism and backtracking search are two interesting viewpoints on the list monad
10:12:59 <ski> one useful way of thinking is that if you have `X -> [Y]' you think of this as a function that given an `X' returns an "ambiguous" `Y'
10:13:01 <magnicida> but, is there a simple way to reason about monads such that i could derive by myself that liftM2 would do that for a List
10:13:21 <ski> (backtracking is more or less one implementation of (angelic) nondeterminsm)
10:14:06 <magnicida> mmm
10:14:50 <magnicida> actually
10:14:53 <ski> magnicida : ok, well in `liftM2 (,) "abc" "01"' you think of the two lists (strings) as ambiguously specifying two characters, then "arbitrary select" one instance for each, and apply the function `(,)' to them .. but since this was ambiguous characters, you get not a pair but a list of pairs back
10:14:58 <ski> > (,) 'a' '0'
10:14:59 <lambdabot>   ('a','0')
10:15:06 <magnicida> I think that my question is more precise now: what is the difference between liftM and fmap?
10:15:22 <zygoloid> magnicida: there is no difference in the case where both are available
10:15:25 <ski> magnicida : `liftM' and `fmap' is basically the same thing
10:15:27 <Berengal> magnicida: liftM2 f m n = do {x <- m; y <- n; return (f x y)}. You then need to understand what (>>=) means for the monad you're using to understand what liftM2 does
10:16:05 <magnicida> ok, I think now I get it
10:16:22 <Berengal> A somewhat more generic claim is that liftM2 f m n means "do m, then do n, then call f with both results"
10:16:33 <magnicida> I usually think of fmap as: apply a "structure preserving" operation inside the monad
10:16:33 <ski> magnicida : btw, note that for list monad, `do {x <- m; y <- n; return (f x y)}' is the same as `[f x y | x <- m, y <- n]'
10:16:48 <Berengal> (This doesn't work for all monads, for example lists; it's hard to "do" a list)
10:17:31 <magnicida> I guess that I can think of liftM2 as "apply a structure preserving operation on every pair of the given monads", where how those pairs are built depend on the monad implementation ...
10:17:32 <ski> magnicida : right. another way to think about it is that given any function of type `a -> b' `fmap' lifts this into a function of type `f a -> f b' -- i.e. where both the argument and the result type have been lifted/wrapped with `f'
10:17:54 <magnicida> nice :D
10:17:55 <ski> magnicida : and then `liftM2' takes you from `a -> b -> c' to `f a -> f b -> f c' (provided `f' is a `Monad')
10:17:58 <ski> @type fmap
10:17:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:18:00 <ski> @type liftM
10:18:00 <ski> @type liftM2
10:18:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:18:01 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:18:13 <ski> also, `return' can be thought of as `liftM0'
10:18:16 <ski> @type return
10:18:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:18:49 <magnicida> nice, now I a think I can understand what that code does
10:18:57 <ski> Berengal : for lists, "do" means "arbitrary select one element" :)
10:19:04 <magnicida> now it is only matter of time to get used to find that I have to use that stuff when writing my own code :;D
10:19:32 <Berengal> ski: or, my favorite, "select the BEST element"
10:19:42 <ski> (: indeed
10:19:58 <ski> (hence *angelic* nondeterminism)
10:20:52 <Berengal> But it's less lists and more nondeterministic values when you think of it like that. They just sort of happen to be the same type
10:21:29 <ski> yeah, i often write type signatures like `select :: [a] -> [] (a,[a])' to emphasize the two different intentions
10:21:46 <Berengal> (Or the list type is just an implementation detail, as the Logic monad demonstrates by being another implementation of the same concept)
10:21:59 <navaati> hum, implementing context-restricted arrows is hard… I get a lot of context errors -_-
10:23:32 <jmcarthur> magnicida: i like to think of these as function transformers. e.g.   liftM :: Monad m => (a -> b) -> (m a -> m b) ; liftM2 :: Monad m => (a -> b -> c) -> (m a -> m b -> m c) ; liftM3 :: Monad m => (a -> b -> c -> d) -> (m a -> m b -> m c -> m d)
10:23:46 <jmcarthur> magnicida: (note the extra parens)
10:24:15 <jmcarthur> oh, that was already pointed out to you
10:24:21 <jmcarthur> i hate it when i do that
10:24:24 <ski> byorgey : hm, it's some kind of djinn / logic-programming implementation for linear logic ?
10:25:18 <byorgey> ski: exactly.
10:25:24 <ski> have you seen lolli ?
10:25:35 <byorgey> I'm sure it's been done before, I was just playing around
10:25:38 <byorgey> no, what's lolli?
10:26:16 <ski> @where lolli
10:26:16 <lambdabot> I know nothing about lolli.
10:26:24 <byorgey> don't worry, I found it
10:26:28 <ski> @where+ lolli <http://www.lix.polytechnique.fr/~dale/lolli>
10:26:29 <lambdabot> Nice!
10:26:32 <ski> @where lambdaProlog
10:26:33 <lambdabot> <http://www.lix.polytechnique.fr/~dale/lProlog/>
10:26:49 <ski> lolli is (more or less) a variant of lambdaProlog, but using linear logic
10:26:54 <kjslag> ski: Why I want to change the ghci's show function: I use a custom MyShow class with a slightly different type for showsPrec (I need to distinguish left and right associativity) and custom showsPrec functions for some standard prelude types.
10:27:47 <ski> you're changing the amount of brackets and/or whitespace ?
10:27:59 <ski> (or are you also deviating from Haskell syntax ?)
10:28:47 <ski> kjslag : anyway, i dunno about it. you could try hunting through the `:set' options and command line flags in the GHC user manual, and/or maybe ask in #ghc, i suppose
10:28:48 <kjslag> I want to distinguish left and right associativity to reduce the amount of brackets
10:28:58 <ski> do you have an example ?
10:29:13 <byorgey> oh, hah, lolli was developed at UPenn =)
10:29:19 <kjslag> (7*x)/y -> 7*x/y
10:31:08 <ski> (byorgey : i assume you've seen lambdaProlog before ..)
10:31:21 <drvitek> http://hpaste.org/45585/instantiating_classes_for_type how can i instantiate a typeclass for a type synonym?
10:31:36 <kjslag> ski: thx for help. I don't see it in :set, so I'll try #ghc
10:31:44 <byorgey> ski: I know of it.  I haven't looked at it in any detail before.
10:33:21 <ski> > (7*x)/y :: Expr
10:33:22 <lambdabot>   7 * x / y
10:33:45 <navaati> drvitek: I think you need the language extension FlexibleInstances
10:34:06 <magnicida> ok now I have another problem
10:34:08 <ski> byorgey : ok, then if something seems unclear in lolli, it could be helpful to check lambdaProlog
10:34:45 <drvitek> navaati: thanks, i'll take a look
10:34:48 <byorgey> ski: thanks
10:34:53 <magnicida> what I am writing is some performance tests for a list of functions, so I am storing the functions in a list and erasing their heterogenous return type with void $! evaluate $! rnf
10:35:11 <ski> kjslag : interesting .. i had assumed that `deriving Show' would not print brackets there, but apparently it does
10:35:19 <magnicida> but I am getting runtime 0 for all of them so I believe that they are not getting executed
10:37:39 <ski> byorgey : there's also a linear variant <http://www.cs.cmu.edu/~fp/courses/98-linear/ltwelf.html> of Twelf <http://twelf.plparty.org/>, but i haven't tried that
10:37:42 <ski> @where twelf
10:37:42 <lambdabot> http://www.cs.cmu.edu/~twelf/
10:38:47 <ski> @where+ ltwelf Linear Twelf <http://www.cs.cmu.edu/~fp/courses/98-linear/ltwelf.html>
10:38:48 <lambdabot> Done.
10:39:40 <ski> @type Foreign.void
10:39:41 <lambdabot> forall a. IO a -> IO ()
10:40:08 <ski> @type Control.Exception.evaluate
10:40:08 <lambdabot> forall a. a -> IO a
10:41:07 <byorgey> drvitek: you also need TypeSynonymInstances.
10:41:39 <kjslag> > (7*x)/y :: Expr
10:41:40 <lambdabot>   7 * x / y
10:41:40 <ski> magnicida : and you're doing `void $! evaluate $! rnf myList' ?
10:41:42 <byorgey> well, and you may need OverlappingInstances as well, since there is already a Show instance for tuples.
10:42:09 <magnicida> ski: No, I am defining the functions to evaluate as:
10:42:14 <ksf> hmmm.
10:42:21 <magnicida>       tests    = [("maybePrime", \a b -> void $! evaluate $! rnf $! maybePrime b 1), 
10:42:21 <magnicida>                   ("gcde'",      \a b -> void $! evaluate $! rnf $! gcde' a b),
10:42:21 <magnicida> ...
10:42:22 <byorgey> drvitek: this seems like a silly path to go down.  Why not just (a) make Result a newtype, or (b) make a function (other than 'show') for displaying Results?
10:42:25 <magnicida> and the list goes on
10:42:29 <ski> kjslag : i think that's special cased .. i tried with `data X = L Integer | X :* X | X :/ X deriving Show; infixl 7 :*,:/', and got brackets for both associations
10:43:55 <ski> drvitek : i would change that `type' into a `newtype'
10:43:59 <kjslag> ski: I think you're starting to go above my head :) thx for showing me that Expr exists :)
10:44:06 <ski> (or possibly a `data')
10:44:13 <magnicida> ski: maybe void is failing to properly execute the evaluate?
10:44:22 <magnicida> I am going to try to change evaluate for return..
10:44:41 <Cin> If I import Data.List to use intercalate, does GHC output the code for *all* of Data.List, or just the used function, intercalate?
10:45:03 <magnicida> no luck..
10:45:38 <thoughtpolice> Cin: depends.
10:45:41 <ski> kjslag : that example is just a datatype with two infix constructors, with given fixity and precedence .. try putting that into a module, loading it, and evaluate `(L 2 :* L 3) */ L 4' and `L 2 :* (L 3 */ L 4)' (and `L 2 :* L 3 :/ L 4' as well if you want to)
10:45:46 <Cin> thoughtpolice: On what?
10:46:05 <thoughtpolice> Cin: due to the way GHC does module initialization, the linker can't remove as much dead code as it normally might. that's only module-level though, and lots of other things will get stripped (but you'll still have some of Data.List in there)
10:46:11 <magnicida> I think I'm just going to stop trying to store the tests in a list...
10:46:11 <ski> magnicida> :t rnf
10:46:12 <magnicida> :(
10:46:27 <thoughtpolice> OTOH, if intercalate was defined as INLINE or INLINEABLE, then the full definition will be persisted to an interface file
10:46:39 <thoughtpolice> if that's all you use, it'll be inlined appropriately and the rest shouldn't be linked
10:46:40 <magnicida> ski: rnf stands for recursive normal form
10:46:43 <magnicida> a -> a
10:46:52 <magnicida> it is in the DeepSeq package
10:46:56 <thoughtpolice> (NB: this is a ridiculously superficial overview, but that's something of the gist of it)
10:47:03 <magnicida> I use it to make sure that everything gets computed 
10:47:33 <kjslag> ski: I see. And I guess that still demonstrates ones of the issues I'm trying to solve. 'L 4 :* L 3 :/ L 2' prints '(L 4 :* L 3) :/ L 2' instead of just 'L 4 :* L 3 :/ L 2'.
10:47:45 <kjslag> brb
10:47:47 <thoughtpolice> Cin: but in terms of 'gigantic code bloat'? no, the linker should do plenty of dead code removal. parts of the module will be left, but that's normal.
10:48:04 <magnicida> I think I just found a more elegant solution
10:48:19 <ski> magnicida : you could probably do `\a b -> seq (rnf (maybePrime b 1)) ()' instead, so instead of `Int -> Int -> IO ()' you get `Int -> Int -> ()'
10:48:30 <thoughtpolice> (the whole module initialization thing becomes much more problematic when you link into, GHC for example, or you use template haskell - the module initializtion infrastructure will force lots of shit to get linked that otherwise should be removable)
10:48:31 <ski> and then you just need to force all the `()'s
10:48:37 <magnicida> well, not exactly more elegant
10:48:46 <magnicida> ski, yes
10:49:06 <ksf> .oO( --as-needed )
10:49:19 <Cin> thoughtpolice: Hm, makes sense, thanks.
10:49:34 <ski> kjslag : yeah. i was expecting `L 2 :* L 3 :/ L 4' to print as just that, instead of as `(L 2 :* L 3) */ L 4', since it was accepted as legal code
10:49:45 <ksf> feel free to google for that and "gentoo" to get an impression of the pain and borkage that occured when switching to it.
10:49:47 <Berengal> "When the program is linked with -threaded, then you may invoke foreign exported functions from multiple OS threads concurrently." Does this mean that with a -threaded runtime it's safe for any thread to call back into Haskell at any time? -> http://haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html#id689034
10:50:24 <ksf> Berengal, why don't you just try?
10:50:39 <ksf> the worst thing that can happen is that you wrote the ghc guys a stress test, for free.
10:51:18 <Berengal> ksf: "Try" is for whimps. I write my code, and then it works :P
10:51:50 <Berengal> But yes... I've apparently gained tunnel vision shaving this yak...
10:52:07 <thoughtpolice> Berengal: I think that only applies to foreign exported functions, i.e. functions that you call directly from C-land using a regular C call. for foreign imported functions for example, it's only safe for FFI calls to call back into haskell if they're marked with 'safe'
10:52:08 <ksf> lua is too simple.
10:52:28 <ksf> well, it's not too simple, but the code is just to mindfuckingly beautiful so that it's trivial to build.
10:52:29 <Berengal> thoughtpolice: You can't mark another thread as safe
10:52:51 <thoughtpolice> Berengal: ? I mean you mark the FFI-imported call with 'safe' - that is required if the C function you call for example, takes a funptr and calls back into haskell
10:52:51 <Berengal> Especially one you don't know about
10:53:13 <thoughtpolice> for foreign exported functions, it seems that if you link with -threaded, it's just safe to call any C function exported by haskell from multiple OS threads, safely
10:53:17 <ksf> heck why use autohell if you can rightfully claim to adhere to POSIX and ANSI C
10:53:19 <Berengal> thoughtpolice: The function that takes the funptr isn't the one that calls back into haskell. Indeed, none of the function I call call back into haskell
10:53:23 <kjslag> ski: sorry, I'm back
10:54:01 <ksf> does building .a's speed up linking, at all?
10:54:12 <ksf> I'd be surprised if.
10:55:25 * ksf , again, considers ghc to try out shake on.
10:56:42 <ski> "The result of show is a syntactically correct Haskell expression containing only constants, ... Parentheses are only added where needed, ignoring associativity."
10:57:06 <ski> "Associativity is not used to reduce the occurrence of parentheses, although precedence may be."
10:57:07 <thoughtpolice> Berengal: then I think I misunderstood your question. what exactly are you asking? the posted quote relates only to foreign exported functions, and all it says is that in a C program that uses exported haskell functions, you can call haskell-exported functions from any OS thread, provided the runtime is -threaded - what exactly do you want to do?
10:57:14 <ski> see <http://www.haskell.org/onlinereport/derived.html#derived-text>
10:57:49 <thoughtpolice> Berengal: I was just pointing out that in the most general case, calling into/out of haskell both happens for foreign imports and exports, and in the case of imports, if C code calls into haskell, it needs to be marked as safe, so just -threaded isn't enough. sorry if that was confusing
10:57:59 <mrcarrot> what can i do to get cabal to recognize that i have already some packages installed through package manager of the OS?
10:58:18 <Berengal> thoughtpolice: I want to pass an arbitrary haskell function (wrapped using foreign import "wrapper") to C for use as a callback, which will happen in another OS thread created by the C code
10:58:18 <ski> kjslag : it appears the Haskell report is specifying it to ignore associativity, when omitting brackets
10:58:20 <thoughtpolice> mrcarrot: --extra-include-dirs and --extra-lib-dirs to specify the location of the C headers/libraries
10:58:37 <thoughtpolice> mrcarrot: you can also get cabal to use pkg-config somehow, i can't exactly remember how though
10:58:43 <ski> i find that a strange decision, though (no rationale given, from what i can see)
10:59:02 <monochrom> sample code > narrative
10:59:44 <thoughtpolice> Berengal: aaahh. if that's the case, i'm not so sure tbh, JaffaCake would be the one to know I presume
11:01:34 <kjslag> ski: nice link! I guess the rationale is probably simplicity. but it can make large output less readable
11:02:12 <monochrom> the quoted paragraph from the user guide seems to say it is safe to do that.
11:03:04 <mmmulani> how can I import a newtype definition from a module?
11:03:13 <ski> (kjslag : also <http://www.haskell.org/onlinereport/basic.html#sect6.3.3> is relevant ..)
11:03:32 <monochrom> I would just go ahead and do it. just to be sure, I would cook up a self-contained complete reproducible example for asking for confirmation on the ghc user mailing list
11:03:46 <mmmulani> well specifically, I want to use MkNominalDiffTime so I can decompose NominalDiffTime from Data.Time.Clock
11:03:51 <kjslag> ski: thx
11:04:35 <ski>   It should be the case that `(x,"")' is an element of `(readsPrec d (showsPrec d x ""))'
11:04:38 <ski> :)
11:08:10 <gwern> @quote catch
11:08:10 <lambdabot> gwern says: amazing `catch` (how sweet the type), that saved an exception like me! I once was thrown, but now am caught; was impure, but now pure be
11:08:15 <magnicida> ski, actually... I made some tests and I am starting to believe that it did work but the program just performed too well :D
11:08:21 <gwern> (hee hee)
11:11:16 <Berengal> preflex: seen JaffaCake
11:11:16 <preflex>  JaffaCake was last seen on #ghc 2 hours, 37 minutes and 4 seconds ago, saying: ezyang: just download the binary distribution of GHC and install it in your home dir, that's what I do on Ubuntu
11:13:51 <byorgey> gwern: =)
11:17:25 <morphles> you can only extract elements from tuple by using let binding or the like? there is no way to iterate over tuple elemens like with list, as i undestand?
11:17:54 <mauke> right
11:18:04 <mauke> (if you could, what would its type be?)
11:18:17 <monochrom> (a dependent type)
11:18:21 <morphles> dunno :) Maybe something :D
11:24:35 <mm_freak> morphles: you can write a fold function for specific tuple types
11:24:39 <mm_freak> but not for tuples in general
11:25:19 <morphles> yeah thas kinda trivial to understand
11:36:37 <kuznero> Hi all!
11:37:14 <kuznero> Can anyone tell if there is a chaining function defined in std modules doing same as this: Either a b -> (b -> Either a d) -> Either a d
11:37:46 <mauke> that looks like >>=
11:38:06 <NisseP> >>=, as seen in Control.Monad.Error I think
11:39:05 <NisseP> Control.Monad.Instances, even
11:39:05 <kuznero> Yep, tried that already, but something is not working there :) trying to figure out...
11:39:58 <kuznero> Something that I need is a little bit more specific then monadic >>=, is not it?
11:39:59 * ski suspects the noxious `Error' class is at work
11:40:23 <NisseP> :t (>>=) :: Either a b -> (b -> Either a d) -> Either a d
11:40:26 <lambdabot>     Overlapping instances for Monad (Either a)
11:40:28 <lambdabot>       arising from a use of `>>=' at <interactive>:1:0-4
11:40:30 <NisseP> um
11:40:30 <lambdabot>     Matching instances:
11:41:22 <kuznero> Sounds like it :) Let me try it
11:53:41 * hackagebot tls 0.6.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.6.0 (VincentHanquez)
11:54:45 * hackagebot tls-extra 0.2.0 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.2.0 (VincentHanquez)
11:54:57 <mbernstein> At the risk of having an entirely silly question - how would you go about returning a file as a [ByteString] rather than an IO [ByteString] ?
11:55:24 <mauke> you can't return a file "as an IO [ByteString]"
11:55:34 <mauke> IO [ByteString] is a command to read a file
11:56:28 <shachaf> Wouldn't that usually be IO ByteString?
11:56:37 <mauke> oh, right
11:56:48 <xarch> is there a petition for removing fail from Monad somewhere?
11:56:49 <mauke> (a lazy bytestring is basically [ByteString], though)
11:57:02 <xarch> or something like that
11:58:17 <norm2782> mbernstein: you probably want to do something along these lines? http://pastie.org/pastes/1783947
11:58:54 <norm2782> where getIOByteStrings is whatever function you're using to get your btestrings
11:59:01 <mbernstein> Okay, well - let's just use a String since ByteString is irrelevent in this context and I'm rather new to Haskell in general.  If I have a function that simply String -> [String], and I say contents <- readfile a - I have an IO String - going to check out the pastie now
11:59:12 <HugoDaniel> hi
11:59:20 <mbernstein> i'm obviously running into typing issues, etc :) 1sec, looking
11:59:24 <HugoDaniel> what are the pros and cons of using the impredicativetypes extensions ?
11:59:29 <HugoDaniel> ghc told me to use it 
12:00:12 <navaati> is there a difference between "lift . lift $ Nothing" and "lift $ lift $ Nothing" ?
12:00:27 <opqdonut_> no
12:00:28 <norm2782> mbernstein: probably like this then http://pastie.org/1783947
12:00:30 <HugoDaniel> nop
12:00:46 * hackagebot aeson 0.3.2.3 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.3.2.3 (BryanOSullivan)
12:00:49 <opqdonut_> f . g . h $ x === f $ g $ h $ x === f (g (h x))
12:01:03 <dons> big new project at galois, plenty of haskell,  http://corp.galois.com/blog/2011/4/11/galois-to-help-darpa-proceed-advancing-the-science-of-secure.html
12:01:19 <navaati> opqdonut_: then it's really weird that one gives me an error and one doesn't (this one : lift $ lift $ Nothing)
12:01:46 <HugoDaniel> :D
12:01:46 <opqdonut_> then there's some context you're not telling about
12:01:50 <navaati> (this one doesn't : lift $ lift $ Nothing)
12:01:55 <HugoDaniel> here i was coding my l33t rest api typeclass
12:02:02 <norm2782> dons: nice, gratz with that project :)
12:02:43 <navaati> opqdonut_: you think it could be because of another implementation of (.) ? i'm playing with Control.Category and Control.Arrow…
12:02:46 <HugoDaniel> and i tried to do something funny to see what kind of error ghc would get me, and it told me to use the ImpredicativeTypes extension: http://hpaste.org/45586/rest
12:02:59 <HugoDaniel> in the collections module
12:03:07 <HugoDaniel> is there a better way to do that ?
12:03:15 <opqdonut_> navaati: that might be, of course. but mostly the different (.)s are generalisations of Prelude's (.)
12:03:43 <mbernstein> norm2782: Maybe I'm missing something, but when I call thingsWithStrings, it complains I'm calling it with type IO t0 instead of String
12:03:45 <navaati> yeah, and i don't see how it could select another one than the one for functions
12:04:10 <mbernstein> I'll pastie it fast
12:04:12 <opqdonut_> navaati: paste the code and the error somewhere
12:05:23 <navaati> opqdonut_: oh, i found, it was stupid : I was hiding the prelude's (.) and I was not providing a (->) instance for Category, so… mea culpa
12:05:56 <mbernstein> norm2782: http://pastie.org/1783979
12:06:24 <mbernstein> norm2782: ignore me forgetting to return a string in thingsWithStrings - it can be anything really in that example
12:06:26 <norm2782> mbernstein: ah, you're making a couple of type errors there
12:06:29 <opqdonut_> navaati: hah, okay
12:06:52 <norm2782> mbernstein: if you take off the type signatures, it should work
12:07:21 <norm2782> so do that and then dive into ghci to see what the types really should be :)
12:07:47 <norm2782> (hint: you're missing a couple of IO String s)
12:08:19 <navaati> is it possible that the inference engine doesn't select the most general type for a function ?
12:08:36 <mbernstein> norm2782: Is there any reason to not let the compiler infer the types?  I'm assuming for others when they look at the given functions - but from a compiler standpoint other than making it compile faster, is there a reason?  The question might be silly
12:08:45 <norm2782> mbernstein: though ideally you want to get the string from your file (which requires IO), and then pass that string to some pure function to do stuff with it
12:09:17 <norm2782> mbernstein: there are some more advanced constructs that require type signatures.. the compiler  cant figure them out itself
12:09:25 <mbernstein> norm2782: Okay, that was the idea I just wasn't sure syntactically how to do it quite yet >.<, thank you very much, it definitely works now - I just have to figure out my typing here
12:10:09 <norm2782> mbernstein: so just to get things working, having the compiler infer the types is fine, though it is easier to think about your code when the signatures are there
12:10:19 <norm2782> also it's good practice to try and infer the types yourself
12:10:29 <norm2782> also, glad that it works :)
12:11:41 <mbernstein> norm2782: Inside of haskell and not ghci, is there a way to get the type of data (mostly to output it mid function rather than hitting ghci and :t each time manually)?
12:12:07 <mbernstein> like, if I said thingsWithStrings str = return str - is there a way before the return str to just output the type that went in
12:12:59 <norm2782> mbernstein: hmm.. not sure.. maybe the Debug module has something, though I'm not too familiar with it
12:13:29 <norm2782> I generally use ghci, or just think about the code that's there (or the code I'm about to write)
12:13:44 <monochrom> yikes, Haskell 98 addendum FFI 1.0 and Haskell 2010 FFI have seemingly incompatible differences
12:14:47 <norm2782> mbernstein: you could also use haskellmode for vim or emacs
12:15:08 <norm2782> they both support getting the type for a function
12:15:23 <monochrom> FFI 1.0 marshallable foreign type permits renamed datatype of a marshallable foreign type (without saying the data constructor should be visible)
12:15:50 <monochrom> Haskell 2010 FFI explicit says the data constructor must be visible
12:22:48 <mbernstein> norm2782: So, if I say tws = return "hello" , it's actually returning an IO String and not a String?
12:23:19 <c_wraith> well.  IO String is one type it could have.  return is polymorphic, so it could be other things, too
12:23:40 <merijn> mbernstein: return "hello" has the type IO String yes, be warned that "return" is not like return in imperative languages, though
12:23:47 <ksf> > return "hello" :: [String]
12:23:47 <c_wraith> > return "hello" :: Maybe String
12:23:48 <lambdabot>   ["hello"]
12:23:48 <lambdabot>   Just "hello"
12:24:13 <monochrom> > do { return 5; return 6 } :: [Int]
12:24:14 <lambdabot>   [6]
12:24:59 <mbernstein> merijn: I'm assuming you mean that it's not necessarily evaluated as in an imperative language?  (I'm reading through the learn you as haskell book while trying to parse some logs to do something demonstrably useful)
12:25:43 <ksf> you can get the imperative behaviour with ContT
12:25:46 <ion> return is just a function that wraps a value in a monadic container.
12:26:03 <merijn> mbernstein: Well, I mean "return" is a function which results in an "m a" (for whatever relevant m and value a), it does not "return from a function" like it would in say C/Java/Python
12:26:05 <ksf> it's a complete misnomer.
12:26:18 <monochrom> merijn means "return" is not a control-flow thing
12:26:21 <merijn> As monochrom's example nicely demonstrates
12:26:31 <mbernstein> merijn: Okay, that explains pretty much every problem I've been having :)
12:27:05 <merijn> Scroll back a few lines and look what lambdabot returns, that should show it :)
12:27:10 <ksf> monadic code tends to get more CPSish when there's more complicated control flow
12:27:11 <mbernstein> and makes a lot of sense - so when in doubt I should really just use implicit returns instead since there's specific behavior that comes from explicitly calling return, and not flow control, etc - makes sense
12:27:16 <mbernstein> thank you guys a ton - i appreciate it a lot
12:27:20 <merijn> A function just returns the last expression in a do block
12:28:07 <merijn> mbernstein: Well, the trick is...there is no spoon. (Or implicit return or whatever :p)
12:29:04 <norm2782> return should be named insert or wrap or something..
12:29:17 <merijn> Personally do notation really confused me, I believe the desugared code using >>= and return explicitly is much more convenient to understand when you meditate on >>='s type signature
12:29:17 <c_wraith> mbernstein: it might be better to think of it as "in haskell, an expression has a value, not returns a value"
12:29:58 <merijn> mbernstein: My advice, continue reading LYAH until they explain the Maybe monad, then meditate on >>='s type signature until enlightenment is achieved
12:30:02 <merijn> :t (>>=)
12:30:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:30:20 <merijn> (Ignore everything before the => for now :p)
12:30:46 <lpsmith> Ok,  I'm playing with impredicative types at the moment,   with a little Iterator library.   I have the type constructor "Iterator i o m a" which is a monad transformer of kind ":: * -> * -> (* -> *) -> *"
12:30:53 <mbernstein> merijn: noted :)
12:31:16 <lpsmith> Anyway,  I want to write "Iterator i o (forall m . m) a" but can't seem to get it right for some reason
12:33:53 <monochrom> "return" could be called "pointed". http://hackage.haskell.org/packages/archive/pointed/0.1.0/doc/html/Data-Pointed.html
12:34:08 <monochrom> err, "point".
12:34:13 <ksf> "wrap".
12:34:28 <ksf> or, actually, "tortilla"
12:34:56 <merijn> I liked the argument that comonad's are like a tortilla. Nearly impossible to keep things inside :>
12:35:16 <edbond> Is it possible to select tags using tagsoup lib using css selectors?
12:35:16 <boegel> does anyone know how I populate hoogle's databases on OS X?
12:35:16 <monochrom> haha
12:35:19 <lpsmith> Is there some kind of higher-kinded quantification?
12:35:30 <boegel> using "hoogle data", I'm getting this: /bin/sh: wget: command not found
12:36:04 <lpsmith> boegel,  do you not have wget on your system?
12:36:21 <lpsmith> try $   wget http://google.com
12:36:22 <boegel> lpsmith: OS X doesn't by default, no
12:36:30 <boegel> lpsmith: it only has curl
12:36:33 <boegel> lpsmith: I 
12:36:34 <merijn> boegel: So get wget then? :p
12:36:50 <boegel> lpsmith: I can install it though, but I was wondering if there's another way
12:37:08 <boegel> merijn: that doesn't work, I'm getting "command not found" :P
12:37:21 <merijn> boegel: You could hack the code to replace wget with curl, but whether that's worth it...
12:37:46 <boegel> merijn: yeah, idd, wondering the same thing
12:39:31 * boegel takes the easy way out and installs wget
12:40:01 <lpsmith> http://hpaste.org/45587/higherkinded_quantification
12:40:03 <boegel> another question: is ghci's type inference available as a function somehow?
12:40:29 <boegel> e.g. something like getType: String -> a -> Type
12:40:48 <monochrom> somewhere deep in the ghc api there is something like that
12:40:52 <merijn> boegel: For use in code or for humans?
12:41:04 <boegel> merijn: code
12:41:38 <boegel> merijn: and for combining with hoogle somehow too
12:41:39 <TomMD> merijn: Do you want a string showing the type or just some unique representation of the type?
12:41:52 <lpsmith> can GHC do what I'm trying to do in the post above?
12:41:53 <monochrom> actually GHC.exprType :)
12:41:59 <boegel> merijn: I have a nitfy idea in my head, but finding myself in a place I've never been before: type tricker
12:42:02 <boegel> *trickery
12:42:19 <TomMD> merijn: The Typeable class might do what you want (note I'm not actually sure what you want)
12:42:33 <boegel> TomMD: are you talking to me?
12:42:46 <boegel> @info Typeable
12:42:46 <lambdabot> Typeable
12:43:01 <boegel> @vixen thanks, great help
12:43:02 <lambdabot> you're very welcome!
12:43:07 <TomMD> boegel, merijn: yes, I somehow switched your names.  Sorry
12:43:09 * boegel slaps lambdabot 
12:43:22 <shachaf> @info do { x <- y; f x }
12:43:23 <lambdabot> y >>= \ x -> f x
12:43:23 <boegel> TomMD: np, thx for the suggestion, I'll look into it
12:43:23 <TomMD> @boegel: Yes, I think you want typeable but again, not sure what you want.
12:43:24 <lambdabot> Unknown command, try @list
12:43:56 <boegel> TomMD: basically, I want to start from some value, use Hoogle to apply function to it, and then determine the type of the result
12:44:12 <boegel> TomMD: depending on the actual function I chose from the list that hoogle returns
12:44:16 <TomMD> Use hoogle as a library?
12:44:27 <TomMD> huh, sounds like a genetic algorithm taking place.
12:45:17 <monochrom> oh I have a horrible construct to show you... :)
12:45:18 <boegel> TomMD: idd :)
12:45:19 <monochrom> > let c c plus рlus = c plus рlus in c (++) "c" "++"
12:45:21 <lambdabot>   "c++"
12:45:38 <boegel> TomMD: I'd like to use hoogle to do genetic programming in Haskell
12:45:56 <boegel> TomMD: having some trouble getting kickstarted though, but I'd like to dive into it
12:46:03 <ezyang> classy. 
12:47:10 * boegel hopes he can get it to work
12:49:34 <boegel> TomMD: typeOf in Data.Typeable seems like exactly what I need, thanks!
12:52:35 <ksf> boegel, if you want more solid ground, you could rework openshake's HList-thingy to automatically infer its type.
12:52:48 <ksf> Development.Shake.Composition
12:54:30 <Tomsik> I'm sort of confused what Yesod actually is and if it could do what I want to do
12:54:39 * hackagebot TCache 0.8.0 - Data caching and Persistent STM transactions  http://hackage.haskell.org/package/TCache-0.8.0 (AlbertoCorona)
12:54:43 <Tomsik> Could you for example write forum like PHP BB in it?
12:55:10 <ksf> it's basically haskell on a rollercoaster.
12:55:38 <Tomsik> Well, Haskell basically is one huge rollercoaster
12:55:47 <Tomsik> but I'm not quite sure what I could do in it
12:55:55 <Tomsik> in yesod, not haskell
12:56:26 <ksf> I'm not sure you could write software like phpbb with any haskell library.
12:56:40 <ksf> it's just way too hard to implement all the bugs it ships with.
12:56:51 <Botje> not to mention the SQL exploits.
12:56:55 <Tomsik> geez, don't be a smartass
12:57:00 <Tomsik> I'm asking an actual question here
12:57:32 <ksf> I'm afraid your forum would come with a complete webserver, then, so, no.
12:57:41 <aristid> Tomsik: why do you think there's anything you CAN'T write?
12:57:56 <Tomsik> I'm wondering what language/framework/library to use for a project
12:58:15 <ksf> if it's web, the answers are yesod, happstack, snap
12:58:26 <Tomsik> I want to present users data from database and let them enter some data
12:58:42 <Tomsik> thus it's kind of similar to an internet forum
12:58:46 <ksf> or just plain old fastcgi and a db backend of your choosing
12:59:20 <ksf> the main difference between those frameworks is whether they come with batteries included or microfusion cells.
12:59:27 <Tomsik> So, Yesod compiles to a webserver that can do dynamic pages?
12:59:35 <ksf> yap.
12:59:40 <Tomsik> okay
12:59:51 <ksf> iirc it can also work with fastcgi
12:59:53 <Tomsik> and how does that compare to happstack/snap?
13:00:03 <ksf> they're doing vastly similar stuff
13:00:05 <siplux> there's also loli - which is like ruby's sinatra
13:00:09 <siplux> https://github.com/nfjinjing/loli
13:00:12 <Tomsik> Hmm
13:00:28 <Tomsik> I guess I'll still have to learn HTML, CSS and Javascript
13:00:34 <Tomsik> but everything is better than PHP
13:00:42 <ksf> up to a certain degree, yes.
13:00:58 <ksf> javascript is still one of the big things to tackle
13:01:06 <Tomsik> yeah
13:01:25 <ksf> and there doesn't seem to be any high-profile project around to get ghc to produce js
13:01:35 <ksf> uhc does it, though.
13:01:53 <Tomsik> is there a haskell wrapper over SQL that you can't shoot yourself in the foot with?
13:02:02 <ksf> and I've heard about some hakish ghc-llvm-> js compiler
13:02:08 <ksf> multiple.
13:02:20 <ksf> use what comes with your framework or what you like best
13:02:48 <ksf> there's also a veritable zoo of templating libraries
13:02:55 <Tomsik> I remember using hsql and it wasn't too great
13:03:17 <mightybyte> Tomsik: HaskellDB provides type-safe SQL queries
13:03:27 <Tomsik> That sounds better :)
13:03:29 <ksf> happstack comes with its own ACID in-memory DB
13:03:51 <ksf> yesod and snap use sql backends iirc
13:03:52 <mightybyte> Tomsik: It works pretty well, but the documentation is sparse, so it's harder to get started.
13:04:11 <mightybyte> Snap as backend-agnostic.
13:04:15 <mightybyte> s/as/is/
13:08:36 <Tomsik> it says on yesod page that is supports postgres well
13:08:39 <Tomsik> that'd be okay
13:10:36 <Cin> Do GHC devs hang in here?
13:10:55 <aristid> Cin: more in #ghc
13:10:55 <ddarius> Occasionally.
13:22:13 <cads> do you guys think that there are category theory aspects of haskell and perhaps all of FP that you guys think should really be more well known by practicing mathematicians?
13:22:58 <Tomsik_> mathematicians of what alignment?
13:23:02 <Tomsik_> I mean
13:23:10 <Tomsik_> if you talk about people who do set theory 
13:23:12 <cads> like, if someone studying cohomology were to adopt haskell, what kinds of unique things would he be delighted to find out about haskell?
13:23:24 <Tomsik_> and if you talk about people who do numeric analysis
13:23:36 <cads> true
13:23:48 <cads> two different worlds wrt. haskell, perhaps
13:24:12 <Tomsik_> Well, I'm not sure what cohomology is
13:24:14 <cads> I'm asking more about fields like algebra and group theory, where there's very heavy category theory used
13:24:42 <cads> Tomsik_: it's studying groups by studying sequences of functors between certain categories created around those groups, I believe
13:24:51 <cads> it studies*
13:25:03 <Tomsik_> ah
13:25:32 <cads> heh, don't you love how saying that makes it sound instantly less scary
13:25:48 <cads> the people who developed it didn't even know about functors,  I think
13:25:59 <Tomsik_> It's wonderful how you can explain anything in language of CT 
13:27:29 <cads> so I wonder what a category theorist would say about the depth of theory that you can emdedd in haskell
13:27:41 <Tomsik_> Well, I'm not sure about FP, but Coq&Co. could be pretty interesting to them
13:27:57 <Tomsik_> cads: "depends on the extensions" ;)
13:28:02 <cads> probably there are theories that talk about just that, stuff like bisimilarity
13:28:44 * hackagebot crypto-api 0.6 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.6 (ThomasDuBuisson)
13:28:49 <cads> so it's a question for me to research  for my own interest
13:29:00 <cads> I will get back to reading
13:29:01 <cads> cheers
13:29:45 <thegeekinside> Hello, I'm newbe in the chatroom (and Haskell as well), and I have a question: which library for YAML is the recomended te use?
13:30:20 <thegeekinside> I read about data-object-yaml, but is the only one?
13:30:44 * hackagebot crypto-api 0.6.1 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.6.1 (ThomasDuBuisson)
13:34:38 <Lycurgus> do "real" category theorist dirty their hands with computer programming?
13:35:29 <Lycurgus> *theorists
13:36:07 <monochrom> I believe no.
13:36:27 <monochrom> they probably dirty their hands with algebraic topology instead
13:36:33 <Tomsik_> I hear they sit around R-modulus
13:36:40 <Tomsik_> or something named like this
13:40:10 <developernotes> I am getting a parse error on input '=' with the following:
13:40:11 <developernotes>                  http://hpaste.org/45589/which_function Any thoughts?
13:40:45 <Tomsik_> which '='?
13:41:07 <ion> where seems to be indented incorrectly.
13:41:38 <ion> The definition of match as well.
13:41:45 <developernotes> Tomsik_: ghci says <interactive>:1:144: parse error on input `='
13:43:56 <developernotes> ion: that's what I was thinking, if ghci is saying position 144 I think that would be around the match definition, but I thought it looked correct.
13:44:31 <ion> Fix the indentation and see what ghc says then.
13:45:15 <developernotes> ion: what exactly is the problem with the indention?
13:45:55 <ion> where is on the same level as let although it should be semantically under it. The beginning of ‘match … =’ isn’t aligned with ‘directory =’.
13:46:35 <ion> Why is let in the first column, btw? If you want to create a top-level definition, don’t use let.
13:47:02 <ion> What is “let which bin” even supposed to be?
13:47:22 <ion> Ah, sorry, i misread.
13:48:20 <developernotes> ion: I was trying to define a function called which, I thought I needed to use a let within ghci for that.
13:48:31 <monochrom> eh? "_" is inappropriate in guards
13:48:49 <developernotes> monochrom: should I use otherwise instead?
13:48:53 <monochrom> yes
13:48:57 <monochrom> or True
13:53:13 <ion> developernotes: http://hpaste.org/paste/45589/which_function_annotation#p45591
13:59:27 <developernotes> ion: I've updated it according to your reccommendations (I think), however I am getting a parse error on input `|' position 10: http://hpaste.org/45589/which_function_annotation#p45593  Thoughts?
13:59:27 <developernotes>  
13:59:27 <developernotes>  
13:59:27 <developernotes>  
14:04:45 <megajosh2> Has anyone gotten the curl package to work as-is on Windows?
14:05:48 <akahn> I saw a great paper recently about implementing Erlang-style message passing in Haskell recently, but I can't find it. Anyone know the paper I'm thinking of?
14:06:12 <lispy> megajosh2: not that I know of.  Darcs uses curl via it's own bindings and I think those can work on windows but requires cygwin
14:07:00 <lispy> megajosh2: for windows stuff I think people usually use the less feature full HTTP library
14:08:59 <akahn> aha, it's 'haskell for the cloud' http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
14:14:19 <Mathnerd314> is there an option -XAllExts or similar for when it's shorter to turn unneeded language extensions off rather than wanted language extensions on?
14:22:03 <bos> lambdabot: poing
14:22:03 <Eduard_Munteanu> Mathnerd314: -fglasgow-exts ?
14:22:17 <Eduard_Munteanu> I'm not sure whether that works anymore, though.
14:22:31 <Eduard_Munteanu> It might throw obnoxious warnings that it's deprecated.
14:22:57 <Eduard_Munteanu> (I'm also unsure it turns on everything.)
14:23:18 <Mathnerd314> yeah, it's missing things like -XGADTs
14:23:49 <Mathnerd314> (and it's deprecated)
14:24:17 <Eduard_Munteanu> Well, just how many extensions are you using? You should be using LANGUAGE pragmas though.
14:25:49 <Mathnerd314> 14, and I am using LANGUAGE pragmas
14:27:06 <Mathnerd314> but I think I'll need more, and adding them by hand is annoying
14:29:58 <monochrom> I am writing a toy multi-threaded C program. I just want to fork two threads, and they won't be sharing variables or syncing. Could you point me to a few man pages I should read? thanks
14:30:15 <ezyang> mmm... man pthreads? :-) 
14:30:29 <monochrom> yeah, that works :)
14:30:30 <elliottt> monochrom:  man pthread_create
14:31:06 <ezyang> If you want to be cross-platform compatible things are a bit knottier. 
14:31:14 <monochrom> just linux
14:31:21 <elliottt> could just fork() :)
14:31:30 <Lycurgus> boost_threads works xplatform
14:31:43 <ezyang> ...does anyone actually use boost_threads? 
14:31:46 <elliottt> sdl provides a thread abstraction, too
14:31:56 * ezyang was under the impression everyone built their own thread abstrations... 
14:32:10 <elliottt> ezyang is under the right impression.
14:32:23 <Eduard_Munteanu> OpenMP threads might work too.
14:32:46 <Lycurgus> ezyang, yeah I do in an application that was already using boost
14:32:57 <Eduard_Munteanu> But if they're not sharing anything and you don't care about per-thread footprint, you could just go with processes, i.e. fork().
14:33:08 <shachaf> Lycurgus: "already using boost" is not a reason to use all of Boost.
14:33:26 <Lycurgus> well using all of boost would be a stretch
14:33:41 <Eduard_Munteanu> (though that's POSIX too)
14:34:22 <thoughtpolice> 99% of boost is header files, so you can just #include it. some parts are more useful than others, we use maybe 5 boost libraries here at work (including boost_thread, I think)
14:35:22 <neophyte> Is anyone familiar with applying rice's theorem to show that certain languages are undecidable?
14:35:28 <thoughtpolice> i just don't want to re-invent that shit, and boost thread works quite well. whether or not we would continue using said parts of boost if we could rewrite is another question entirely (probably still use boost thread, but fuck boost::filesystem like the plague it is)
14:35:31 <shachaf> Doesn't everyone just write their own cooperative threading library, anyway?
14:35:39 <ezyang> neophyte: It's not too difficult :-) 
14:36:02 <ezyang> "This property is nontrivial. Therefore this language is undecidable." 
14:36:56 <thoughtpolice> (funny enough, I basically did end up rewriting a lot of boost::filesystem at work because boost's implementation was so terrible at the time, but thank god I didn't have to rewrite boost_thread)
14:37:13 <neophyte> ezyang yes you show two R.E. languages where one has the property P of the language in question and another R.E. language that doesn't have that property P but I am having trouble concocting a R.E. language that satifies the language L={<M> | M acceps an odd number of odd-length strings and an infinite number of even-lenght strings}
14:37:28 <Lycurgus> the header only pkg percentage is less than that but a lot are
14:37:28 <Lycurgus> some may have changed there's a drift out of header only status
14:37:29 <Lycurgus> drift, creep, whatever
14:37:32 * Lycurgus afk
14:37:36 <neophyte> I have a R.E. language that doesn't have that property
14:37:45 <neophyte> but i can't think of one that does\
14:37:57 <neophyte> because L itself is not R.E.
14:39:01 <ezyang> neophyte: If this makes anything clearer, "If contradiction, therefore a" is trivially true. 
14:39:08 <Liskni_si> neophyte: any finite language doesn't have that property
14:39:40 <ezyang> If indeed there is no decidable procedure for L, then deciding if a machine is L is trivial. 
14:40:03 <ezyang> "i.e. it's not" 
14:40:50 <ezyang> Though your wording is a little unclear. Do you have the original question? 
14:40:57 <neophyte> Yes.
14:41:05 <neophyte> Let me state it
14:42:15 <neophyte> Prove whether the following language is recursive or not recursive. All Turing machines are assumed to be over input alphabet {0,1}: L={<M> | M accepts an odd number of odd-length strings and an infinite number of even-length strings} 
14:42:44 <neophyte> I thought Rice's Theorem would apply here, and that this language is not recursive.
14:43:31 <neophyte> So I was trying to find an example of a language that is R.E. that does not satisfy property P of L, and a R.E. language that does satisfy the property P of L to show it is "non-trivial"
14:43:46 <ezyang> Ah, you're working on the wrong level of abstraction. 
14:44:01 <neophyte> The language containing one string is R.E. and does not satisfy the property P of L
14:44:19 <neophyte> But now I need a R.E. language that does satisfy that property to show it is "non-trvivial"
14:45:18 <ezyang> neophyte: If a language is recursively enumerable, there exists a TM that will halt and accept any string that is in the language. 
14:45:40 <neophyte> correct
14:45:45 <ezyang> So if L is recursively enumerable, then there exists a TM that takes descriptions of machines and says whether or not those machines accept an odd number of ... 
14:46:21 <neophyte> yes that is correct
14:46:58 <tromp_> huh?
14:47:07 <tromp_> that wld require L to be recursive
14:47:19 <ezyang> OK, so all I need to do is show a machine that accepts an odd number of even length strings and an infinite number of even-length strings 
14:47:25 <ezyang> and a machine that doesn't fit that bill. 
14:47:31 <ezyang> and then I can apply Rice's theorem. 
14:47:42 <neophyte> eZet I got the machine that doesnt fit that bill, but not one that does
14:47:47 <neophyte> ezyang*
14:48:06 <neophyte> I'm currently trying to construct one that does fit the bill to invoke rice's theorem
14:48:18 <ezyang> Oh. I guess that seems very easy to me. 
14:48:58 <tromp_> seems trivial
14:49:07 <neophyte> ezyang can you explain such a machine that is R.E. and satisfies the property?
14:49:25 <neophyte> I got one that doesnt that was easy
14:49:54 <ezyang> Write a TM that accepts the string '0', and all strings that are even. 
14:50:24 <monochrom> hrm, eventually pthread_create man page is only in manpages-posix-dev, which is in the multiverse. (ubuntu)
14:50:27 <ezyang> Even-ness is something you can check using just a finite-automata; you don't even need turing computability. 
14:50:35 <ezyang> monochrom: orly? 
14:50:36 <monochrom> oh oh oh TM!
14:51:03 <ezyang> I know it doesn't come installed by default, but I thought it was in a normal repos. 
14:51:05 <monochrom> I would actually love to know if I'm doing it wrong...
14:51:26 <Taslem> Is it possible to define >> in Haskell (or a duplicate) without referencing >> or any function dependent on it?
14:51:28 <neophyte> ezyang, so you are saying write a machine that accepts the string '0' AND all strings that are even?
14:51:44 <mauke> Taslem: which >> ?
14:51:44 <ion> taslem: Huh?
14:51:51 <ezyang> Yes. That shouldn't be too hard, right? 
14:51:55 <ezyang> Taslem: Easily. 
14:52:05 <neophyte> no
14:52:25 <neophyte> because it satifies both requirements of L
14:52:30 <neophyte> thus satisfying P of L
14:52:35 <ion> f >> g = f >>= const g
14:52:39 <ezyang> If you actually have to write out the turing machine, that might be a bit tedious, but usually if you're at the point of Rice's theorem, you can take the constructability of something like that easily. 
14:52:47 <Taslem> I'm getting mixed answers... I think..
14:52:56 <neophyte> ezyang thanks for the help that makes sense
14:53:02 <mauke> Taslem: you're asking mixed questions
14:53:10 <neophyte> i was hung up on the conjunction
14:53:21 <neophyte> the oddness && evenness part
14:53:34 <ezyang> Ah, sure. You should review the closure of TM-recognizability and decidability under various operations. 
14:54:12 <ezyang> In particular, the conjunction of two TM-recognizable languages is also TM-recognizable. (Exercise: Prove it.) 
14:54:50 <Taslem> I'm asking if it's possible to define the >> operator (for monads like IO) in Haskell. As in, is it possible to rewrite the Monad typeclass from scratch and make a >> operator for it without referencing the existing Monad typeclass or its operators.
14:55:07 <ezyang> Taslem: Not in Haskell98, for IO. 
14:55:14 <ezyang> Yes for GHC Haskell. But it's not pretty :-) 
14:55:17 <mauke> Taslem: yes, easy
14:55:20 <Taslem> How?
14:55:29 <neophyte> i dont think L={<M> | M accepts an infinite number of even-lenght strings} is R.E.
14:55:37 <mauke> Taslem: instance Monad m where (>>) :: m a -> m b -> m b
14:55:39 <mauke> er
14:55:42 <mauke> *class Monad
14:55:46 <ezyang> neophyte: Why not? 
14:55:55 <ezyang> erm, you're confusing things again. 
14:55:59 <ezyang> There are two turing machines: 
14:56:12 <ezyang> The TM that recognizes L, and the TM referenced by "M" 
14:56:25 <ezyang> L is not recursively enumerable. 
14:56:30 <ezyang> M is. 
14:56:30 <Taslem> But would that "evaluate" IO correctly?  Like  putStrLn "Hello, " >> putStrLn "World."
14:56:51 <mauke> Taslem: no, because IO won't be an instance of it
14:56:56 <mauke> Taslem: you wanted a new class
14:57:01 <ezyang> (there's a universal quantifier hiding somewhere in there) 
14:57:22 <neophyte> L={<M> | M accepts an infinite number of even-lenght strings}  can be reduced to L1 = {<M> : M accepts infinitely many strings},
14:57:25 <neophyte> is what i thought
14:57:27 <ezyang> neophyte: The distinction between "language" and "turing machine" was definitely something that tripped me up when I originally learned this. 
14:57:32 <Taslem> I know. And could you make IO an instance of it, and then would that work?
14:57:41 <neophyte> oh i have a misunderstanding somewhere
14:57:56 <mauke> Taslem: yes, but that depends on IO internals
14:57:59 <ezyang> What do you mean by "reduced"? They're both undecidable, if that's what you mean. 
14:58:03 <neophyte> yes
14:58:04 <mauke> Taslem: well, not (>>) itself, but (>>=)
14:58:30 <Taslem> How exactly is >> or >>= defined for IO?  Is it defined only in the compiler/interpreter and not part of the language?
14:58:33 <ezyang> neophyte: For me, it's a lot easier to translate statements about languages into statements about turing machines. 
14:58:39 <ezyang> Taslem: Yes. 
14:58:50 <neophyte> I think I'm confused between languages and turing machines at this point
14:58:57 <ezyang> Yes. Review that equivalence. 
14:59:00 <mauke> Taslem: it's probably in a library somewhere, but implementation details are not part of the language proper
14:59:07 <Taslem> THought so.
14:59:38 <ezyang> "A language is recursively enumerable IFF there exists a TM that recognizes input in that language" 
14:59:52 <ezyang> Your lectures should have given you the proof in both directions. 
14:59:59 <Taslem> Hm.... I think I have an idea to remedy half of that problem. :/ But it isn't pretty either.
15:00:17 <mauke> problem?
15:00:27 <neophyte>  Okay, I think that proof is in my book
15:00:57 <ion> taslem: http://www.haskell.org/haskellwiki/IO_Semantics
15:01:02 <Taslem> Arguably, IO is missing from Haskell's definition, because it isn't strictly possible to do in the language's strict sense, you have to control it from outside.
15:01:05 <jmcarthur> Taslem: GHC uses a horrible token-passing trick for its implementation of >>= for IO, but it doesn't reflect the semantics very accurately
15:01:22 <mauke> Taslem: this is just like C, basically
15:01:22 <jmcarthur> Taslem: it gets hard when you start trying to factor in things like concurrency
15:01:41 <mauke> C has no I/O built into the language either, just a library interface
15:02:35 <Mathnerd314> > do { "ab"; "cd" } -- wouldn't it be nice if this was "abcd" ?
15:02:36 <lambdabot>   "cdcd"
15:02:40 <benmachine> what instances of a multiparamtypeclass *don't* require FlexibleInstances?
15:02:48 <mauke> Mathnerd314: no
15:03:21 <ion> mathnerd314: no
15:03:25 <benmachine> Mathnerd314: technically you could define a completely perverse "monad" in which it was
15:03:28 <benmachine> but it would still be stupid
15:03:32 <ezyang> benmachine: You could put it in another module :-) 
15:03:38 <benmachine> ezyang: >_>
15:03:39 <Mathnerd314> I'd even accept runStuff $ do { ... }
15:04:03 <jmcarthur> Mathnerd314: define an instance of IsString for Writer String a  ;)
15:04:18 <benmachine> hah
15:04:20 <benmachine> cute
15:04:21 <jmcarthur> *Writer String ()
15:04:34 <jmcarthur> i've done a similar trick for builders before
15:04:49 <jmcarthur> but i prefer Monoid for such things, usually
15:05:18 <jmcarthur> woops, i mean   instance IsString str => IsString (Writer str ())
15:05:31 <benmachine> ofc
15:06:01 <benmachine> http://hpaste.org/45594/mptc_flexibleinstances <-- what of those conditions do I not meet?
15:06:10 <Mathnerd314> oh, that's more useful
15:06:25 <ezyang> (MaybeT m) is not a type variable. 
15:06:53 <ezyang> FlexibleInstances is about as non-controversial as it gets. 
15:06:55 <benmachine> ezyang: sure, but it's T a1 ... sn
15:07:04 <benmachine> *an
15:07:14 <jmcarthur> it specifies that it must be a type variable though
15:07:27 <jmcarthur> oh, no it doesn't
15:07:32 <benmachine> it says all instance types
15:07:39 <benmachine> I assume that means, both fields of the mptc
15:08:58 <Volatile> Forgive my noobishness, but would it be possible to make a monad transformer out of http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/ ?
15:09:20 <benmachine> hm, I think it's something about the context
15:09:57 <ezyang> It might not terminate, for most interesting cases... 
15:10:37 <benmachine> ezyang: the reverse state, or my thing? Volatile: I see no reason why not
15:10:45 <Mathnerd314> hmm, maybe I just need a printf
15:11:14 <ezyang> reverse state 
15:15:11 <Volatile> benmachine: ah, good. Since I've never written one before, it would be nice to know if it were actually doable before troing to do it... ;)
15:15:22 <Mathnerd314> hmm, where is Mu from?
15:15:31 <benmachine> Volatile: I don't know! it might or might not be possible, but I reckon it is
15:16:21 <Mathnerd314> @hoogle Mu
15:16:21 <lambdabot> Text.Html multiple :: HtmlAttr
15:16:21 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
15:16:21 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
15:16:46 <Mathnerd314> and why is hoogle useless?
15:16:47 <Volatile> ezyang: I need a transformer, since I need testled rstate monads, since I think it is impossible to get a value out of an RState monad, add something and put it back.
15:17:00 <benmachine> Mathnerd314: it's not defined in any common libraries, it may have a corner of hackage somewhere
15:17:08 <benmachine> Mathnerd314: I think lambdabot has her own version
15:17:14 <Volatile> (hence I cannot have an RState of a list and add items to the list)
15:17:33 <benmachine> Volatile: sure you can, they just get sent back in time
15:17:36 <benmachine> that's how it works, right?
15:17:42 <Volatile> benmachine: works for me. ;) Just wanted someone elses opinion.
15:17:56 <Volatile> benmachine: hmm
15:18:21 <benmachine> Volatile: hm, it may require MonadFix
15:18:36 <Volatile> benmachine: the problem is that if you get the list, you cannot add a list item before, because the variable is not bound yet
15:18:57 <Volatile> benmachine: What is that? :)
15:19:27 <benmachine> Volatile: something that allows recursive do-bindings
15:19:48 <Mathnerd314> benmachine: I remember finding it somewhere in a package with type composition
15:19:51 <benmachine> yeah I can make it work iff I use do rec
15:19:58 <benmachine> Mathnerd314: TypeCompose, at a guess?
15:20:02 <Volatile> oh
15:20:15 <benmachine> hm, or not
15:20:55 <benmachine> Volatile: http://haskell.org/haskellwiki/MonadFix this may help, and then again it may not
15:22:04 <ezyang> Can you automatically derive a transformer instance from any monad? (My guts say no...) 
15:22:16 <Volatile> benmachine: hmkay...
15:22:42 <benmachine> ezyang: pretty sure IOT doesn't exist
15:23:01 <ezyang> erm, given an implementation, of course :-) 
15:23:01 <jmcarthur> no you can't
15:23:09 <jmcarthur> hmm
15:23:14 <jmcarthur> maybe i spoke too soon
15:23:24 <ezyang> It certainly would not be unique, c.f. Cont and STate. 
15:23:29 <jmcarthur> i know there are more than one way to compose monads
15:23:57 <jmcarthur> there are three or four ways discussed in Composing Monads alone
15:23:59 <Mathnerd314> benmachine: category-extras, actually
15:25:02 <Mathnerd314> but hackage says "This package is obsolete."
15:26:43 <benmachine> Mathnerd314: oh, it's probably been split into another package
15:26:57 <Mathnerd314> so... where is it? :p
15:27:07 <jmcarthur> i don't think it's been split off yet
15:27:39 <mm_freak> i'm an iteratee guy, but from time to time i hit the limits of iteratees…  is there a design pattern, which is more general and equally powerful?
15:27:53 <mm_freak> or more powerful
15:28:01 <jmcarthur> generalized in what sense?
15:28:07 <mm_freak> some people referred to coroutines at some point
15:28:39 <mm_freak> jmcarthur: well, for example it's very difficult to write a useful stateful iteratee
15:28:40 <Mathnerd314> jmcarthur: so what do I use in the meantime? it doesn't build on ghc 7.
15:28:41 <benmachine> as far as I understand it, iteratees are coroutines
15:28:52 <mm_freak> benmachine: but coroutines are not iteratees
15:29:04 <benmachine> aren't they? I thought they were :P
15:29:30 <mm_freak> they are more general, and i only scratched the surface
15:29:32 <jmcarthur> Mathnerd314: dunno
15:29:32 <benmachine> the Iteratee type is a monad transformer, isn't it?
15:29:38 <mm_freak> benmachine: yes
15:29:47 <benmachine> mm_freak: so transform State?
15:30:18 <mm_freak> i'm doing that, but it comes with problems
15:31:01 <mm_freak> benmachine: the problem becomes visible as soon as you write two independent libraries with stateful iteratees and a third library needs to combine both
15:31:19 <jmcarthur> why is that a problem?
15:33:05 <mm_freak> jmcarthur: obviously 'Iteratee a (StateT s m) b' stops working, because you need both states
15:33:12 <Volatile> Hm, seems I went in over my head in this. I really would need to either have a RStateT monad, though, or I'll be forced rewrite a LOT of code. Anyone up for either writing an RStateT monad for me or helping me do so?
15:33:25 <Volatile> s/either//
15:33:31 <jmcarthur> mm_freak: i wouldn't expose that implementation anyway. i'd wrap it in a newtype
15:34:03 <mm_freak> jmcarthur: no, that completely destroys the flexibility of the libraries
15:34:53 <mm_freak> jmcarthur: i expose that interface precisely to be able to compose the two libraries…  for example one library implements a proxy client, the other implements an SMTP client
15:35:17 <mm_freak> this combination works well, because the proxy client uses a stateless iteratee
15:35:50 <jmcarthur> i don't see why you can't just make your newtype(s) composable
15:36:21 <mm_freak> because then i would need either to wrap everything or to write wrappers around everything
15:36:42 <mm_freak> and i don't see any problem with exposing the interface
15:36:43 <benmachine> Volatile: what are you actually using reverse state for? I'm intrigued that there's a genuine application
15:37:55 <mm_freak> coroutine seems to be too general…  i would have to reimplement the whole stream processing idea, and i don't know how to express an enumeratee
15:38:02 <jmcarthur> i see a problem. it makes it not composable :P
15:38:12 <benmachine> Volatile: I have an implementation but like I said, it needs MonadFix
15:38:58 <mm_freak> jmcarthur: for example the proxy client is not an isolated stream processor…  you use the iteratee to initiate a proxy connection and then go on with another iteratee
15:39:05 <mm_freak> newtype wrapping would make this extremely difficult
15:39:08 <benmachine> Volatile: so it depends what you want to transform
15:41:13 <mm_freak> by the way, does anyone know how to compose enumeratees?
15:41:31 <lispy> mm_freak: that one guy on -Cafe had a nice tutorial about it
15:41:50 <lispy> You know, that one guy
15:42:10 <lispy> mm_freak: http://www.mew.org/~kazu/proj/enumerator/  Kazu is "that one guy"
15:42:31 <neophyte> ezyang, I believed I proved a few of these problems and am getting the hang of it, but I'm trying to decide whether the language L={<M> | L(M) is recursive enumerable} is recursive, isn;t this a non-trivial property?
15:43:01 <Volatile> benmachine: I have a parser that adds line numbers to each statement in a block of code. When it reaches the end, it puts the last line number in a reverse state, so that I can add a jump instruction to after the block before parsing it, so the jump instruction gets the correct line number. For each function I do something similar: I add a function head in before parsing the blocks in the function. This function hea
15:43:07 <neophyte> i'm getting a bit confused because i can think of a R.E. language that satifies that property
15:43:07 <mm_freak> lispy: thanks
15:43:14 <tromp_> what L(M) would not be RE?
15:43:55 <neophyte> Well in order to invoke rice's theorem you haver to think of two R.E. languages that satisfty the property and one that doesnt
15:44:06 <neophyte> but it doesn't make sense to say some R.E. isnt R.E.?
15:44:17 <neophyte> have*
15:45:03 <neophyte> a L(M) that is not RE would be the empty language
15:45:53 <mm_freak> lispy: that tutorial doesn't seem to solve my problem
15:46:01 <lispy> mm_freak: hmmm
15:46:27 <mm_freak> i need a combinator of this type:  Enumeratee a b m d -> Enumeratee b c m d -> Enumeratee a c m d
15:46:52 <lispy> mm_freak: this is for a different implementation, but maybe the docs help? http://john-millikin.com/articles/understanding-iteratees/
15:47:24 <neophyte> tromp_, but in order to use rice's theorem you have to have two R.E. languages where one satisfies the property and where one does not, correct?
15:48:09 <mm_freak> lispy: the same
15:48:38 <ezyang> neophyte: What is the domain of M? 
15:48:43 <ezyang> What does L indicate? 
15:49:01 <mm_freak> lispy: there are combinators for composing almost everything, but nothing for composing enumeratees =/
15:49:03 <ezyang> the language recognized by a turing machine is by definition recursively enumerable. 
15:49:15 <ezyang> so if M ranges over Turing Machines, this is a trivial property. 
15:49:30 <tromp_> yes, the proprty must be non trivial
15:49:37 <neophyte> no, L={<M> | L(M) is recursively enumerable} over the input alphabet {0,1}
15:49:42 <neophyte> is all it states
15:49:57 <neophyte> trying to determine whether it is recursive
15:50:19 <ezyang> Does <M> indicate the encoding of some turing machine? In which case, the domain is effectively turing machines. 
15:50:43 <neophyte> yes <M> indicates the encoding of some turing machine
15:51:44 <tromp_> neophyte, is there an M that fails the property?
15:51:47 <ezyang> Basically, I can't accidentally write down the encoding of a turing machine that recognizes some undecidable language. 
15:52:05 <neophyte> i thought we could use rice's theorem to show that is a non-trivial property of a turing machine but it doesn't make sense to have a R.E. language that isn't R.E.
15:52:30 <ezyang> This is a case where rice's theorem fails. 
15:52:55 <neophyte> then what other way can i go about proving it is undecidable? because i feel like it would be
15:53:35 <ezyang> L is decidable. Just make sure M is a valid turing machine description, and then output 1. 
15:53:47 <ezyang> erm, <M> 
15:54:10 <neophyte> ezyang, but the question is whether or not L is decidable
15:54:27 <ezyang> Yes. I claimed it was decidable, and gave you a decision procedure. 
15:54:36 * hackagebot DRBG 0.2 - Deterministic random bit generator (aka RNG, PRNG) based HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.2 (ThomasDuBuisson)
15:54:42 <neophyte> so if it fails rice's theorem then it is decidable?
15:54:47 <ezyang> I should stop giving you answers ^_^ 
15:55:08 <ezyang> Rice's theorem is an if-and-only-if relation, yes. 
15:55:14 <neophyte> I don't quite understand your procedure of outputing "1". 
15:55:37 <neophyte> Okay well i see that it is decidable since I cant get a R.E. language that isn't R.E.
15:56:05 <neophyte> but that doesn't prove that L is recursive, so i need to construct a turing machine M
15:56:08 <neophyte> that shows it is decidable
15:56:29 <ezyang> Yes. But don't call it M since that's confusing. 
15:56:33 <ezyang> Call it, uh, metaM. 
15:56:40 <neophyte> Okay.
15:56:44 <ezyang> I describved metaM for you. It's trivial, since it's a trivial language. 
15:56:49 <ezyang> (L) 
15:57:31 <neophyte> It seems like most of these problems are quite trivial, but to a novice in computability they force you to understand the theorems and definitions, and sometimes that isn't obvious, but it becomes easier to do once you solve a few problems
15:58:08 <ezyang> If you're looking for a way to ace the exam, there aren't very many types of decidability question, so you just need to learn how to recognize them. 
15:58:36 <ezyang> If you're trying to develop a good intuitive feel for these questions, the key is being able to juggle turing machines that take turing machines that take turing machines as inputs, and not get confused. 
15:58:46 <neophyte> Alright
15:58:52 <neophyte> I want to do the latter
15:59:20 <neophyte> is this the basics to what computability theorist study
15:59:38 <ezyang> Decidability isn't a very hot field, is my impression. 
15:59:56 <neophyte> so would undecidability be where all of the interesting problems are?
16:00:36 <ezyang> http://en.wikipedia.org/wiki/Computability_theory#Areas_of_research_in_recursion_theory 
16:00:50 <neophyte> ty
16:00:56 <ezyang> No, as in, whether or not something is decidable is something that has been studied pretty in depth. 
16:01:30 <neophyte> is this also studied within the computer science department, or is it mainly a field of mathematics. most theory groups i seen within CS focus in complexity theory\
16:01:32 <Mathnerd314> complexity is where all of the interesting problems are. (e.g. P = NP)
16:02:10 <neophyte> yes we are being introduced to complexity theory very soon.
16:02:39 <neophyte> i think this stuff is the most interesting subject i came across within cs
16:02:57 <lispy> mm_freak: I'm pretty sure there is.  I seem to recall Oleg's original treatment covering that topic.
16:03:12 <cvic> Michael Sipser's book is pretty good 
16:03:28 <ezyang> It's pretty good. I liked computability and complexity a lot and got an A+ when I took it. 
16:03:52 <cvic> Also "Introduction to Automata Theory, Languages, and Computation" 
16:03:56 <ezyang> but like most undergrad subjects, you have to specialize a bit more to get to the active research areas. 
16:03:56 <cvic> the automata bible haha
16:04:13 <lispy> mm_freak: even if it's just as simple as (.) or (>>=).
16:04:58 <neophyte> we are currently using sipser's text
16:05:29 <cvic> it's a good textbook 
16:05:30 <neophyte> it is very concise and nicely written
16:05:34 <cvic> Exactly 
16:05:43 <cvic> Hopcroft & co is heavy 
16:05:58 <neophyte> i like mathematical logic a lot as well, i'd have to say it is my favorite field of mathematics.
16:07:11 <neophyte> ezyang, what is a good follow up book to sipser's 
16:07:21 * ezyang doesn't know 
16:07:24 <neophyte> that gets a bit more invovled in computability and complexity
16:07:25 <neophyte> alright
16:07:31 <cvic> Hmmm... let's see 
16:07:34 <TomMD> Yay, new crypto-api and DRBG are out at last.
16:07:36 <kmc> papadimitriou
16:07:45 <cvic> kmc: exactly 
16:07:49 <kmc> "computational complexity"
16:07:54 <kmc> fantastic book
16:08:05 <cvic> Computational Complexity - Christos Papadimitriou
16:08:25 <neophyte> i'll check it out.
16:08:34 <neophyte> what assumed mathematical background is assumed
16:08:38 <neophyte> erm
16:08:47 <copumpkin> bos: I could've sworn I've done that multiple times before
16:09:04 <bos> copumpkin: they seem to break it quite frequently
16:09:07 <copumpkin> ah, okay
16:09:10 <cvic> related http://www.amazon.com/Undecidable-Propositions-Unsolvable-Computable-Functions/dp/0486432289/
16:09:18 <bos> googling for "github refork repo" gets a lot of hits
16:09:34 <copumpkin> ah :(
16:09:45 <neophyte> thanks for the recommendations
16:10:44 <cvic> no problem. If you can't find them in digital format, let me know 
16:10:57 <lispy> bos: i just saw your tweet.  So what is the solution?
16:11:17 <bos> lispy: there isn't one, except "file a ticket"
16:11:35 <lispy> bos: wow.  Their UI is usually much smoother than that.
16:15:26 <ian_mi> is it possible to switch the order of monad transformers?
16:15:44 <hpc> ian_mi: you can change the meaning of your program that way
16:15:50 <hpc> but mostly, yes
16:15:56 <mm_freak> lispy: after trying to use approaches, which made sense in typing, which didn't work, i fell back to brutefurce
16:16:00 <mm_freak> and i really tried everything
16:16:34 <ian_mi> hpc: oh, is there an easy way to do so?
16:16:46 <lispy> mm_freak: and nothing worked?
16:17:02 <hpc> ian_mi: not really
16:17:09 <ian_mi> oh
16:17:14 <hpc> if you are doing things with transformers that requires that much control, roll your own type
16:17:25 <mm_freak> lispy: i haven't even found something, which type-checked
16:17:28 <hpc> it isn't too hard if you understand transformers
16:17:33 <hpc> and @unmtl is your friend
16:18:52 <lispy> mm_freak: Maybe you should an email to haskell-cafe with a description and example code.  I think you need people like Oleg or John Lato or John Milikin to comment
16:22:10 <mm_freak> lispy: yeah, seems so, but as said i'm currently looking for alternatives to iteratees anyway, or for cleaner methods to have stateful iteratees
16:24:23 <cvic> hmm, this cryptol is interesting 
16:28:23 <lpsmith> http://hpaste.org/45587/higherkinded_quantification
16:28:34 <lpsmith> Nobody has any suggestions?  =)
16:29:49 <copumpkin> yay impredicativity
16:31:39 <Lemmih> lpsmith: Using 'm1' and 'm2' doesn't work?
16:32:48 <lpsmith> Lemmih: well, I'm trying to capture that "NeedAction" is never used in the type system
16:33:17 <Lemmih> Ah.
16:46:30 <BMeph> So, am I off-base for thinking, "shift/reset is a way of specifying a reverse continuation"? 
16:46:58 <osoleve> @type fmap
16:46:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:58:38 <BMeph> Or rather, a delimited everse continuation?
16:58:43 <BMeph> *reverse
17:00:01 <monochrom> I don't think shift/reset reverses anything. they're just delimiting.
17:02:19 <ville> every time I see BMeph's nick I quickly read it as bmesh and think there're some exciting news about bmesh for blender.
17:04:19 <lpsmith> if a continuation is a record of where you are going,  wouldn't a reverse continuation be a record of where you've been?
17:04:31 <lpsmith> BMeph: have you seen time-travel debugging at all?
17:10:31 <dolio> This isn't really accurate, but: continuations sort of let you capture the stack where you're at, and replace the existing stack with one you've captured.
17:11:11 <dolio> Delimited continuations put marks on the stack, so you only capture up to a mark. And you don't replace the entire stack with what you've captured, you only push it on the front.
17:15:25 <deech> Hi all, sometimes when I load a Haskell file in GHCI through Emacs it gives me a "Could not find module ..." for one of my modules which is in the same directory. Any idea why this happens?
17:17:59 <BMeph> deech: My first guess is: "UR DOIN IT RONG!" ;)
17:18:49 <BMeph> deech: But seriously, check your pwd; you're likely not starting your inf-haskell in the directory you think you are... ;)
17:19:53 <deech> Hmmm... M-x pwd looks correct to me. 
17:19:57 <BMeph> lpsmith: Exactly, and that's just what reset and shift do!  Also, I'm not sure what that "time-travel debugging" refers to... :S
17:20:15 <deech> Maybe I'll restart GHCI. The exact same code works on the command line.
17:20:46 <BMeph> deech: In the ghci buffer, do ":!pwd" and see if it's the same as M-x pwd.
17:21:21 <lpsmith> BMeph:  there are a couple different "time travel" debuggers that let you step backwards as well as forwards
17:22:04 <lpsmith> BMeph: i'm not sure I agree with that characterization,  though I admit it's all very confusing
17:22:09 <BMeph> lpsmith: Sounds like a life saver for Java programmers everywhere! ;)
17:22:39 <lpsmith> funny you should say that,  the first time-travel debuggers (as far as I'm aware) were for Java :)
17:23:02 <deech> BMeph: Ah-hah, my code is in /blah/src/Main.hs, but when I load it Emacs and GHCI think that the current directory is /blah/ and can't find /blah/src/Other.hs. When I do a :cd src in GHCI things load fine. Strange.
17:23:11 <BMeph> lpsmith: Do you have a feel for where my characterization "fails" for you, or is it just an "analogy smell" for you?
17:23:47 <deech> BMeph: Thanks for your help!
17:23:57 <hpc> heh, i got to see the creator of Achron speak to my class; he talked about how the mechanics of his game accidentally created a time-travel debugger
17:24:09 <hpc> if you see a bug, you go back in time and save the game
17:24:23 <BMeph> deech: Excellent! I'm glad I helped, if only a little. I'm also glad I got to legitimately tell someone "UR DOIN IT RONG"... :D
17:24:27 <lpsmith> BMeph: a continuatio records the control context,  so in a sense it's the operations you've already "visited",  but haven't been able to actually *execute*  yet because you didn't have all the information you needed.
17:24:48 <lpsmith> so in a sense it feels like the past,  even though it's really the future.
17:25:59 <lpsmith> although,  a continuation must necessarily record part of the past so that you know what you have to do in the future.
17:26:33 <lpsmith> I dunno if that makes sense.  :-P
17:26:46 <elliottt> :t (1,)
17:26:47 <lambdabot> Illegal tuple section: use -XTupleSections
17:27:04 <elliottt> :set -XTupleSections
17:27:07 <elliottt> doh! :)
17:27:18 <mauke> :t (,)1
17:27:18 <lambdabot> forall t b. (Num t) => b -> (t, b)
17:28:26 <elliottt> :t fst . until ((<= 1) . snd) (uncurry (*) &&& (subtract 1 . snd)) . (,)1
17:28:27 <lambdabot> forall b. (Num b, Ord b) => b -> b
17:30:45 <BMeph> lpsmith: So, it's still a regular continuation, just delimited and defined so explictly that folks who otherwise might get lost can feel safer with them? ;)
17:31:28 <lpsmith> Well, basically.   Although I don't know that they are any less confusing than "regular" continuations  :)
17:32:19 <lpsmith> http://lambda-the-ultimate.org/node/2009#comment-65303    I liked Ehud's response.
17:35:02 <BMeph> lpsmith: 's funny, it sounds like it's in the tenor of the "monad comment," but it sounds direct to me, not jokingly obfuscatory. I keep trying to figure out why don't they make less sense to me than they seem to do to most everyone else.
18:01:54 <monochrom> "FfiExample" is another reason why camel case fails
18:02:18 <monochrom> http://www.haskell.org/haskellwiki/FFI_Introduction#GHC
18:02:46 <acfoltzer> I usually have an acronym exception to my camel case uses
18:02:51 <acfoltzer> for exactly that reason
18:03:09 <monochrom> well FFIExample is just as ugly and more unreadable
18:03:28 <acfoltzer> eh, more readable to me at least
18:03:31 <parcs> ffi-example is ideal imo
18:03:35 <monochrom> I would use FFI'example and it's perfectly clear
18:08:52 <amacleod> Is it possible to define functions interactively in ghci?
18:09:17 <monochrom> yes. type in "let f x = x && x && x" for example
18:12:06 <smarmy> any opinions on json parsing libs these days?  i see lots of options.  investigating aeson just because i like bos...
18:15:13 <amacleod> monochrom, thanks.  I see that the let is not necessary when defining functions in files.  Is there an implied let there for convenience?
18:15:49 <monochrom> not really. just consider ghci to be special
18:15:58 <amacleod> Okay :)
18:16:22 <flazz> ghc complains that -fllvm is imcomplatible with -fPIC and -dynamic on my platform (darwin), how can i play with llvm?
18:16:48 <amacleod> Can you disable PIC and -dynamic?
18:31:56 <helgikrs> @let e = exp 1
18:31:57 <lambdabot>  Defined.
18:32:05 <helgikrs> > e - (pi^4 + pi^5)**(1/6)
18:32:05 <lambdabot>   Ambiguous occurrence `e'
18:32:06 <lambdabot>  It could refer to either `L.e', defined at <local...
18:32:14 <helgikrs> > exp 1 - (pi^4 + pi^5)**(1/6)
18:32:15 <lambdabot>   1.9847130161565474e-8
18:32:29 <helgikrs> magic :O
18:33:38 <shachaf> > (pi^4+pi^5)**(1/6)
18:33:39 <lambdabot>   2.718281808611915
18:33:49 <helgikrs> > exp 1
18:33:50 <lambdabot>   2.718281828459045
18:34:11 <amacleod> What version of Haskell does lambdabot serve?
18:34:54 <Draconx> amacleod, It's commonly referred to as Caleskell.
18:35:01 <amacleod> 'cause typing the first 2 lines into ghci 6.12.1 seemed to work for me.
18:35:41 <monochrom> a much loaded version of haskell
18:35:49 <monochrom> observe:
18:35:51 <monochrom> > 2 3
18:35:52 <lambdabot>   2
18:35:56 <monochrom> nonsense
18:35:59 <amacleod> o_O
18:36:04 <helgikrs> wha
18:36:10 <monochrom> do not trust lambdabot
18:36:26 <amacleod> Is it treating 2 as a function there?
18:36:30 <monochrom> yes
18:36:30 <Draconx> yes.
18:36:32 <helgikrs> @type 2
18:36:33 <lambdabot> forall t. (Num t) => t
18:36:58 <amacleod> Is there a way to inspect the type of an object in ghci?
18:37:03 <helgikrs> :t
18:37:07 <Boxo> > 2 () "lol"
18:37:08 <lambdabot>   2
18:37:13 <monochrom>  :type map
18:37:34 <shachaf> monochrom: Hah, the space wasn't necessary there.
18:37:38 <shachaf> :type 512
18:37:41 <helgikrs> > 3 2
18:37:42 <lambdabot>   3
18:37:46 <helgikrs> strange
18:37:54 <shachaf> Every number in lambdabot is like Unlambda's "v" operator.
18:40:01 <Boxo> A failure of abstraction?: it should be the case that for every typeclass C, C a => C (x -> a)
18:40:22 <shachaf> Boxo: Huh?
18:40:38 <shachaf> Eq a => Eq (x -> a)?
18:41:11 <Boxo> well there goes that theory
18:41:24 * shachaf is not sure what theory Boxo had in mind.
18:42:05 <Boxo> a stupid one
18:44:31 <Boxo> I got it from noticing that functions of type A -> V where V is a vector space themselves form a vector space, and maybe the same was true for typeclasses
18:46:12 <jmcarthur> Boxo: many things are like this:  (Applicative f, Foo a) => Foo (f a)
18:47:13 <jmcarthur> Boxo: but it doesn't work for all Foo, obviously
18:47:42 <Balahla> Guys. Need Help. I need to unzip and zip an archive. Please, tell me how to do?
18:48:04 <jmcarthur> > unzip $ zip [1..] ['a'..]
18:48:04 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:49:21 <Balahla> No. I mean zip and unzip an archive (a file - extract, add, etc.).
18:49:37 <jmcarthur> (it was a subtle hint that this is the wrong channel for that)
18:49:38 <Philippa> Boxo: if you've only got a finite number of points it'll always work. That's pretty boring though
18:50:15 <Balahla> I'm not in the Haskell channel?!
18:50:51 <Balahla> I'm asking if someone know a library with functions to zip and unzip archives...
18:51:02 <jmcarthur> oh!
18:51:05 <jmcarthur> haha
18:51:13 <jmcarthur> i thought you were asking about the command line or something
18:51:51 <tensorpudding> Balahla: try Codec.Archive.Zip
18:51:56 <Balahla> I'm learning Haskell and would like to study solving a real problem of mine... 
18:52:22 <Balahla> Gets worse... I don't know how to install the package...
18:52:30 <tensorpudding> use cabal
18:52:33 <Balahla> Window xp
18:52:52 <acfoltzer> Balahla: I've had good luck with the zlib package
18:52:54 <Balahla> I don't know how to run cabal on windows...
18:52:56 <acfoltzer> cabal install zlib
18:53:13 <Balahla> I'm gonna try. Thanks a lot.
18:53:29 <acfoltzer> here's the documentation on Hackage: http://hackage.haskell.org/package/zlib
18:53:42 <acfoltzer> I've mostly used the GZip side of it, rather than Zlib
18:54:50 <monochrom> that is what you get for "diving" into "real world" tasks too quickly. you haven't even learned the ropes
18:55:15 <lpsmith> BMeph: Ehud's got a pretty dry sense of humor.   And I think a lot of people *think* they understand continuations when they don't.   And I've spent nearly 10 years understanding them now,  and they often make my head hurt to this day :)
18:55:24 <tensorpudding> zlib has the stuff needed to do compression and decompression but does it support the zip archive format?
18:56:05 <Balahla> About dive to soon in real world problems... I can't help it. I'm eager...
18:56:17 <acfoltzer> tensorpudding, I didn't think about that distinction
18:56:21 <acfoltzer> you might be right though
18:56:27 <tensorpudding> in any case
18:56:38 <monochrom> a 40-year-old american, who has only known english for all his life, one day decides to learn chinese. his approach: "hi, I'm learning chinese by real world applications, I want to write a movie review in chinese for a chinese movie. now"
18:56:51 <monochrom> sorry, not going to work
18:56:52 <tensorpudding> you can install the platform on windows and it comes with cabal
18:57:00 <Balahla> LOL... 
18:57:56 <acfoltzer> yeah, upon checking Codec.Archive.Zip, that's probably what you're looking for
18:57:56 <monochrom> it might work if you're just going from american english to chinese english
19:01:47 <sordina> Is there a way to convert a NominalDiffTime to a DiffTime?
19:01:59 <monochrom> yes if you know all about leap seconds
19:02:08 <monochrom> look into Data.Time.Clock.TAI
19:02:21 <monochrom> or perhaps you just fake leap seconds
19:03:20 <sordina> I just really want a better representation
19:03:40 <sordina> of the time rather than an integer that it shows when I print a difftime
19:04:39 <monochrom> I would just stick to UTCTime and NominalDiffTime
19:05:02 <monochrom> the latter being only necessary when I add or subtract
19:06:17 <sordina> But isn't UTCTime an absolute time?
19:06:33 <sordina> I'd like to be able to say X happened 7 months ago
19:14:52 <neophyte> I'm trying to apply rice's theorem to the language L={<M> | L(M) is context-free, but not regular} over the alphabet {0,1} on a turing machine is recursive or not. I am thinking it is not decidable but I'm not sure if my examples are R.E., I chose L1={a^n b^n | n>0} that satisfies the property, but is that R.E.?
19:16:40 <christo_m> does anyone here know about the buildExpressionParser function for basic expression parsing
19:16:47 <christo_m> in Paresc
19:16:49 <christo_m> parsec*
19:16:57 <shachaf> christo_m: That seems quite likely.
19:17:20 * shachaf will guess that the answer is "yes", so you should go ahead and ask your question.
19:17:31 <monochrom> example at http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
19:18:02 <christo_m> monochrom: yes youve shown me that link before
19:18:11 <monochrom> but I think I am seeing your name for the 4th time
19:18:12 <christo_m> its just im doing things a bit differently because its a compiler for LUA
19:18:18 <christo_m> yup
19:18:22 <christo_m> and probably many more times till the 15th
19:18:44 <christo_m> i want my return values to be nodes in my AST dont i?
19:19:24 * shachaf wonders what will happen on the 15th.
19:19:43 <christo_m> working compiler?
19:20:07 <monochrom> on the 15th, a new version of lua will come out, with a totally different grammar
19:20:12 <christo_m> :O
19:44:54 <Luke> dons: i think bytestring-mmap is broken in cabal
19:45:02 <Luke> anyone else having problems with the package?
19:48:25 <Luke> http://hpaste.org/45601/bytestringmmap021_error
19:51:08 <lispy> Luke: os and version of ghc?
19:51:54 <Luke> ubuntu 11.04 and ghc version 6.12.3
19:53:18 <TomMD> @luke It has lots of warnings for me but installs.
19:53:18 <lambdabot> Unknown command, try @list
19:53:25 <TomMD> grr, luke ^^
19:53:35 <lispy> Luke: those errors are crazy low level so I bet it's something weird with your ghc
19:53:47 <Luke> hmm
19:53:52 <Luke> could be broken in beta ubuntu
19:53:53 <applicative> Luke, it built and builds fine here on os x.  there is a complaint about -fvia-C and fPIC which is a mac thing.
19:53:55 <Luke> thanks
19:54:09 <Luke> thanks a lot guys
19:54:47 <monochrom> w00t, ubuntu 11.04 already?
19:55:01 <Luke> yeah i was seeing if the haskell package situation got any better
19:55:24 <christo_m> *Lua> parseTest exp_exp "3.0 - 3.0"
19:55:24 <christo_m> BinOp "Minus" (Number 3.0) (Number 3.0)
19:55:27 <christo_m> thats the best thing ive seen all day
19:56:45 <lispy> christo_m: why do you parse minus to a string literal?
19:57:17 <lispy> christo_m: I mean, congrats and all!  It just seems like an unusual thing to do
19:57:49 <monochrom> the next revision will fix that
19:58:04 <christo_m> i guess i could actually do the evaluation as quickly as possible
19:58:08 <christo_m> i just did it for internal representation
19:59:21 <shachaf> christo_m: lispy is asking why you're using ('M':'i':'n':'u':'s':[]) to represent subtraction.
19:59:30 <shachaf> Not why you're not evaluating it as your pase.
19:59:43 * shachaf wonders how that r moved three characters to the left.
20:00:01 <lispy> You're parser is pase.
20:00:10 <lispy> Not sure why I added the '
20:00:59 <lispy> christo_m: Yeah, I just thought it was odd that you noticed the minus and converted it to "Minus" instead of having some other representation or leaving it as "-"
20:01:14 <christo_m> why do you all hate me so much :(
20:01:15 <christo_m> im a nub
20:02:22 <lispy> christo_m: sorry mate.  I'm happy for you and I just wondered...
20:02:31 <lispy> christo_m: I'm not saying it's wrong :)
20:03:32 <christo_m> lispy: s'all good
20:03:33 <lispy> christo_m: and I actually wouldn't combine parsing with simplification, but that's just me.
20:03:51 <christo_m> honestly this is my first time using haskell, doing real functional programming that isnt a toy example
20:03:58 <lispy> cool
20:04:01 <christo_m> and first time doing any interpreting, compiling, parsing, any of that
20:04:15 <christo_m> so i expect to make a lot of mistakes and do very unorthodox things, i thank you for pointing it out
20:04:51 <lispy> christo_m: there used to be a really good interpreter tutorial here but I'm getting a 404: http://user.cs.tu-berlin.de/~magr/pub/Transformers.en.html
20:06:07 <lispy> christo_m: oh, try this one: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.71.596
20:06:40 <christo_m> well im writing a compiler , i just mentioned interpreting
20:06:44 <christo_m> but thank you ill look into it
20:06:55 <lispy> christo_m: At some point you'll probably think, "Hmm...how do I package up all the steps for parsing, evaluating, handling errors, managing state, and producing a result?"  That paper gives a nice approach.
20:07:53 <applicative> christo_m I don't think lispy and shachaf mean to be anything but supportive.  ... at least, to judge from the last few minutes worth of discussion. 
20:08:14 <christo_m> applicative: oh i wasnt actually distraught, it was in jest.
20:08:41 <applicative> oh, okay, good.
20:08:45 <lispy> THERE ARE NO JOKES IN #HASKELL
20:08:49 * lispy gets the ban hammer out
20:09:07 <lispy> crap, if the ban hammer is behind glass how will I get it out...
20:09:17 <TomMD> Can anyone else install chalkboard?   I think 7.0.3 might have a bug that chalkboard hits.  (Needs the C library libdevil-dev installed)
20:09:35 <TomMD> Hackage says "7.0" built ok, whatever version 7.0 is.
20:09:47 <TomMD> wait, no, read that wrong, somehow
20:09:49 <TomMD> never mind.
20:10:06 <lispy> TomMD: what is chalkboard?
20:10:38 <TomMD> Andy Gill's library used to perform/teach basic graphics in a functional way (or so I understand)
20:11:11 <lispy> oh cool
20:11:30 <lispy> TomMD: oh!  You need a patched version of openglraw to get good performance with that
20:11:42 <TomMD> lispy: But despite Gill maintaining / using it I don't think there has been a moment in time when I could cabal install it!
20:11:59 <lispy> :(
20:12:07 <TomMD> lispy: Will you be taking over OpenGLRaw?
20:12:31 <lispy> TomMD: http://www.haskell.org/pipermail/hopengl/2009-December/000945.html
20:12:56 <lispy> TomMD: yeah, looks that way.  Not a single objection to my email saying I would take over and I made sure to CC a lot of listst.
20:13:38 <christo_m> lispy: http://hpaste.org/45602/error, any reason im getting this
20:13:43 <christo_m> did i mess something up with the AssocLeft?
20:14:00 <christo_m> if i dont put it, does it default to AssocRight?
20:14:35 <lispy> christo_m: is that parsec?
20:14:55 <christo_m> lispy: yes
20:16:20 <lispy> christo_m: it's the first line that's wrong actually
20:16:23 <lispy> christo_m: [Infix  (reservedOp "^"   >> return (BinOp "^")) ]
20:16:39 <lispy> christo_m: Infix has to be giving an assosciativty
20:16:55 <christo_m> ah
20:17:17 <christo_m> i have a question for you
20:17:25 <christo_m> in Lua, Number is by default IEEE double float
20:17:45 <christo_m> but when im parsing,i want to be able to accept 3 as well as 3.0 and represent them both as a Number (for typechecking and sanity etc)
20:17:59 <lispy> > read "3" :: Double
20:17:59 <lambdabot>   3.0
20:18:04 <christo_m> weird
20:18:28 <christo_m> number    = P.float lexer
20:18:33 <kmc> needed a REPL for a C library
20:18:34 <christo_m> its because of this
20:18:34 <lispy> > reads "3" :: [(Double, String)]
20:18:35 <lambdabot>   [(3.0,"")]
20:18:39 <kmc> writing Haskell imports and using ghci seemed easiest
20:18:46 <kmc> something might be wrong with me
20:19:03 <lispy> kmc: hehe.  There is that C++ interpreter, gordi?
20:19:09 <lispy> geordi?
20:19:09 <kmc> written in haskell :)
20:19:12 <kmc> there's also gdb
20:19:17 <kmc> and Cint and another
20:19:26 <Kaidelong> how difficult is the FFI to use?
20:19:33 <kmc> not very difficult
20:19:35 <lispy> Kaidelong: it ain't no thing
20:19:36 <kmc> RWH has a good intro
20:19:46 <kmc> FFI programming is difficult because it's still C programming
20:19:48 <lispy> Kaidelong: Just make sure to use hsc2hs or c2sh
20:19:53 <lispy> Kaidelong: sorry, c2hs
20:19:57 <christo_m> naturalOrFloat 
20:19:58 <christo_m> got it
20:20:17 <christo_m> ah wait a minute..
20:20:18 <kmc> and it takes a lot of tricks to turn a C-level API into something Haskellers will want to use
20:20:20 <christo_m> that changes everything
20:20:21 <lispy> christo_m: oh right, you want to use parsec stuff not reads :)  Sorry
20:20:31 <kmc> but the basic step of calling a C function with C types is nearly trivial
20:20:33 <christo_m> lispy: now im going to have to have Either Integer Double
20:20:36 <christo_m> but i dont want that.
20:20:38 <kmc> far easier than JNI, fwiw
20:20:41 <christo_m> i want Number to always be strictly Double
20:20:45 <lispy> :t either
20:20:45 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
20:21:02 <pastorn> C ]
20:21:09 <pastorn> e.krpat .m
20:21:13 <lispy> :t either fromIntegral id
20:21:14 <lambdabot> forall a b. (Integral a, Num b) => Either a b -> b
20:21:32 <pastorn> aoeuiäqjkxbmhtnsgclrl/å,.åå,.å,.å,.å,å
20:21:45 <lispy> christo_m: You can just convert the Integer into a Double.
20:21:54 <pastorn> hi
20:22:08 <pastorn> lrcp.,pyfgcrff
20:22:11 <christo_m> lispy: i wasnt aware there was some sort of casting
20:22:13 <christo_m> how do you do that
20:22:27 <lispy> > fromIntegral 112313123131313 :: Double
20:22:28 <lambdabot>   1.12313123131313e14
20:22:51 <christo_m> what?
20:23:01 <lispy> > (either fromIntegral id) (Left 3.0)
20:23:01 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:23:01 <lambdabot>    `GHC.Real.Fractional a'
20:23:01 <lambdabot> ...
20:23:04 <lispy> > (either fromIntegral id) (Left 3)
20:23:05 <lambdabot>   3
20:23:11 <monochrom> why do you need naturalOrFloat? float alone would suffice...
20:23:12 <lispy> > (either fromIntegral id) (Right 3.0)
20:23:12 <lambdabot>   3.0
20:23:37 <lispy> christo_m: fromIntegral is how you convert from Integer to Double
20:23:59 <monochrom> @quote monochrom Double
20:23:59 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
20:24:12 <christo_m> liftM Number number
20:24:15 <christo_m> so from here
20:24:19 <christo_m> ill have to do it right
20:25:00 <lispy> christo_m: does the parsec float parser really not accept 123?
20:25:12 * lispy hasn't read the docs
20:25:26 <christo_m> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html
20:25:33 <christo_m> i can parse integers or floats
20:25:57 <christo_m> and then of course, naturalOrFloat which i think is what i want
20:26:20 <lispy> christo_m: it says, "The number is parsed according to the grammar rules defined in the Haskell report."
20:26:22 <christo_m> if i leave it at float, it gives parse errors for 3, but not 3.0 
20:26:35 <lispy> weird
20:26:42 <lispy> > read "123" :: Double
20:26:43 <lambdabot>   123.0
20:26:50 <lispy> That seems like a parsec bug
20:26:55 <lispy> ddarius: ^^ ?
20:27:11 <lispy> ddarius: How do we explain this?
20:28:02 <pastorn> do win
20:28:36 <lispy> > do win where win = text "win"
20:28:37 <lambdabot>   <no location info>: parse error on input `where'
20:28:54 <lispy> > do let win = text win; win
20:28:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:29:02 <ddarius> The rules in the report for the production 'float' are float -> decimal . decimal [exponent] and float -> decimal exponent and exponent is not nullable.
20:29:02 <lispy> ?let win = text "win"
20:29:03 <lambdabot>  Defined.
20:29:17 <lispy> > do win
20:29:18 <lambdabot>   win
20:29:45 <pastorn> =)
20:29:57 <lispy> ddarius: So, why does read accept it?  That definition doesn't apply to read?
20:31:55 <monochrom> > 3 :: Double
20:31:56 <lambdabot>   3.0
20:32:10 <monochrom> clearly "3" is valid double for haskell
20:32:29 <pastorn> kernel -321
20:33:13 <monochrom> oh oops, haskell 2010 wants "3.0", nevermind
20:33:28 <christo_m> *Lua> parseTest exp_exp "3"
20:33:29 <christo_m> parse error at (line 1, column 2):
20:33:29 <christo_m> unexpected end of input
20:33:29 <christo_m> expecting digit, fraction or exponent
20:33:50 <ddarius> > fromInteger 3 :: Double
20:33:51 <lambdabot>   3.0
20:34:02 <pastorn> 2010 -- 2011 2012 --
20:34:04 <monochrom> or else "3e4"
20:34:14 <ddarius> lispy: As far as I can tell, the Report says absolutely nothing about the Read instance of Double.
20:34:32 <christo_m> :(
20:34:49 <lispy> monochrom: if you test with "> 3 :: Double", there is an implicit fromIntegral since 3 :: Num a => a
20:35:00 <lispy> At least, I think it's fromIntegral
20:35:02 <ddarius> fromInteger
20:35:09 <monochrom> yeah, I didn't read the doc first
20:35:17 <applicative> why does ghc say 'a' is not in scope in this GADT?  http://hpaste.org/45603/chalkboard  
20:35:41 <applicative> sorry  I mean in the constructor Fmap
20:36:09 <lispy> applicative: because of the explicit forall
20:36:15 <BMeph> christo_m: "liftM (either fromIntegral id) naturalOrFloat"? ;)
20:36:17 <pastorn> fluxx lisp
20:36:17 <ddarius> applicative: You can't explicitly quantify only some variables.
20:36:33 <applicative> Yes, does that kill a's hope. i see,
20:36:41 <lispy> applicative: it doesn't mention 'a'.  Keep in mind, the 'a' in "data Board a where" is ignored.  It's only used to figure out the kind of Board.
20:36:45 <ddarius> applicative: Also (in case it's not clear) the 'a' in the first line is not a binding instance.
20:37:02 * ddarius recommends using the kind signature notation for GADTs.
20:37:31 * BMeph recommends the ddarius.
20:37:37 <lispy> Yeah, this is one of those beginner traps with GADTs
20:37:40 <applicative> hmm.  It's the chalkboard package, it used to compile :)
20:37:57 <pastorn> dvorak .....
20:38:17 <lispy> pastorn: did someone steal your computer?
20:38:47 <pastorn> no
20:39:18 <lispy> pastorn: ah, you seem full of nonsequitors :)
20:39:32 <applicative> ddarius, leaving the details of this case aside, the a in "data Board a where..." just shows the kind?  
20:40:05 <pastorn> dvorak is hard
20:40:14 <monochrom> let's go qwertying
20:40:34 <pastorn> å,.ppyfgfgrcaoeuuidhhnts-äqjkxbmwvz
20:41:12 <pastorn> å,.pyfgcrl/=aoeuidhtns-;öäqjkxbmwvz
20:41:46 <applicative> ddarius, I see, in this case forall a b . is no different from what was desired 
20:41:57 <lars9> @pl map (:[])
20:41:57 <lambdabot> map return
20:42:03 <lars9> @pl map (:[1])
20:42:03 <lambdabot> map (: [1])
20:42:21 <lars9> @pl \lst -> map (:lst)
20:42:22 <lambdabot> map . flip (:)
20:43:22 <lars9> > foldM (map . flip (:)) [] ["123", "abc", "+-="]
20:43:24 <lambdabot>   ["+a1","-a1","=a1","+b1","-b1","=b1","+c1","-c1","=c1","+a2","-a2","=a2","+...
20:43:32 <lars9> > foldM (map . flip (:)) [] ["123", "abc"]
20:43:34 <lambdabot>   ["a1","b1","c1","a2","b2","c2","a3","b3","c3"]
20:44:30 <lars9> point-free awesome
20:45:15 <shachaf> kmc: I've been using gdb a lot as a REPL lately.
20:45:20 <shachaf> Ahem, was scrolled up.
20:46:20 <shachaf> Anyway, it generally works nicely but it's annoying to write/compile/link-with-relevant-libraries a program whenever I want to use it.
20:46:38 <shachaf> Also it's almost-but-not-quite-C(++).
20:48:26 <neybis> very random question and im not sure if im in the right place but i recently began using xmonad and dzen but my status bar is unclickable (i know this is associated with dzen  not xmonad)
20:48:36 <neybis> do I have to enable the mouse or something in xmonad?
20:48:48 <pastorn> im no pastor
20:49:44 <pastorn> dvorak is hard
20:50:11 <neybis> ok, must be wrong place
20:50:13 <neybis> sry to bother guys
20:51:53 <applicative> neybis, is anyone awake in #xmonad
20:52:34 <neybis> i can check, it appears to be something related to dzen as the mouse works in xmonad just not on the dzen status bar when clicks are enabled
20:52:47 <neybis> ty tho applicative, I will check : )
20:53:09 <pastorn> testing dvorak typing skills
20:56:46 <Berengal> Why does memory management have to be so irksome?
20:59:48 <monochrom> pastorn you should type in interesting haskell code if you plan to testing typing in #haskell!
21:00:57 <Berengal> Wait, someone tell me if I'm crazy: I'm passing FunPtrs to C. These need to be freed when they're not needed. The problem is that they're used in another thread, so they might still be needed even though Haskell loses all references to them
21:01:40 <Berengal> However, the same goes for the struct that contains them; if you lose any references to it in Haskell-land, the ForeignPtr functionality will destroy it, and the thread will be SOL
21:02:12 <Berengal> But then again, there's no use for that thread anyway if you lose all references to it, so it might just as well be allowed to fail
21:02:33 <Berengal> Which means that I can freely free whatever I want when all references are lost
21:03:21 <Berengal> Is this madness?
21:03:33 <osoleve> this. is. SPARTA.
21:03:37 <osoleve> sorry :[
21:03:40 * Berengal was waiting for that
21:04:22 <osoleve> is Haskore pleasant to use for real time midi generation?
21:07:47 <applicative> thanks lispy ddarius, I think I have a much better understanding of whats up with GADTs suddenly, thinking this through, obvious as it is on reflection.
21:08:26 * applicative needs a GADT to build.
21:09:56 <christo_m> im sorry
21:10:02 <lispy> applicative: yeah, it's an important detail that is easily overlooked
21:10:03 <christo_m> i think lispy was helping me?
21:10:06 <christo_m> my internet borked
21:12:06 <lispy> Berengal: could you  use a withFunPtr function to do the clean up automatically?
21:12:37 * BMeph wonders how fun that "withFunPtr" is, anyway...
21:12:50 <monochrom> "the funnest ptr"
21:12:52 <lispy> Berengal: something like, withFunPtr :: FunPtr a -> (b -> IO c) -> IO c
21:13:05 <kmc> what does that do for FunPtr?
21:13:05 <lispy> Berengal: maybe the b is unneeded
21:13:59 <lispy> something like, withFunPtr = bracket (return ()) freeHaskellFunPtr
21:14:06 <lispy> :t bracket
21:14:07 <lambdabot> Not in scope: `bracket'
21:14:15 <christo_m> lispy: what was the verdict on how i should be treating doubles ?
21:14:29 <liyang> gently.
21:14:53 <kmc> you're making these FunPtrs with foreign import "wrapper"?
21:14:56 <lispy> christo_m: you need that natuarlOrFloat function
21:15:04 <christo_m> lispy: and convert or?
21:15:23 <lispy> christo_m: sure
21:15:45 <lispy> christo_m: the link to the logs is in the /topic if you feel like you're missing anything :)
21:16:20 <lispy> ?hoogle bracket
21:16:20 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:16:20 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:16:20 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:17:16 <christo_m> lispy:  <|> liftM Number (fromIntegral number :: Double)
21:17:21 <christo_m> would i be doing something like that?
21:17:30 <christo_m> i dont think thatll work actually
21:17:32 <christo_m> one sec
21:19:34 <lispy> I guess withFunPtr can't be written in terms of bracket unless you had IO (FunPtr a)
21:19:53 <Berengal> lispy: I'd like a ForeignFunPtr instead, since things aren't cleanly scoped. However, keeping references around in different threads makes the scoping even harder
21:20:54 <kmc> well you can cast a FunPtr into Ptr and then add a finalizer to make it a ForeignPtr
21:21:12 <lispy> kmc: that won't work on all architectures
21:21:16 <kmc> that's true
21:21:28 <lispy> "Note: this is valid only on architectures where data and function pointers range over the same set of addresses, and should only be used for bindings to external libraries whose interface already relies on this assumption."
21:21:30 <Berengal> I'm starting to think there might not even be a way of doing it properly unless the two threads shared a common resource-manager (i.e. GC), which C-threads don't, obviously.
21:21:33 <lispy> I don't know how serious that is?
21:21:49 <kmc> the bigger problem is that GHC can't see whether your C library still has a copy of the function pointer
21:21:54 <lispy> Berengal: is SFML threaded?
21:22:02 <Berengal> lispy: Yes, at least parts of it
21:22:18 <lispy> Berengal: ah.  freetype isn't, fwiw
21:22:29 <lispy> it's thread-safe but it doesn't assume them internally
21:22:49 <kmc> Berengal, so you're turning a Haskell function into a FunPtr... what do you do with it then?
21:23:08 <Berengal> kmc: Give it to a C-function that spawns a thread and has its way with it there
21:23:21 <lispy> kmc: well, with ForeignPtr there is a way to touch the Ptr and a nice wrapper, withForeignPtr.  Surely we could write something similar for FunPtr?
21:23:46 <kmc> you could invent ForeignFunPtr
21:24:09 <kmc> FunPtrs don't intrinsically have anything to "touch" or a resource to acquire
21:24:46 <Berengal> lispy: I'm thinking of a way where you could use Haskell's threads instead of C threads in SFML instead. This would require manual forking by the Haskell user, but it would solve the resource management problem
21:24:54 <kmc> FunPtr and Ptr are nearly the same thing
21:25:16 <kmc> and i think the FunPtr <-> Ptr cast will work on all popular platforms
21:25:28 <ddarius> kmc: Very likely.
21:25:43 <ddarius> Though there may be issues on some 64-bit setups, I think.
21:26:05 <kmc> anyway ForeignPtr is most useful when the resource is being used and eventually abandoned on the Haskell side
21:26:08 <anon1> #haskell:  Way more enthusiasm than the evangelical christians, way more intelligence than the athiests…all that with none of the vitriol.
21:26:20 <kmc> but if you're making FunPtrs you're expecting them to be used in the C side
21:26:31 <Berengal> If there was a way to attach a haskell-defined finalizer to ForeignPtrs...
21:26:43 <kmc> there is (in GHC)
21:26:53 <Berengal> Using the foreign import "wrapper"?
21:27:36 <lispy> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/GHC-ForeignPtr.html
21:27:40 <kmc> using Foreign.Concurrent.addForeignPtrFinalizer
21:27:54 <kmc> "These functions generalize their namesakes in the portable Foreign.ForeignPtr module by allowing arbitrary IO actions as finalizers. These finalizers necessarily run in a separate thread, cf. Destructors, Finalizers and Synchronization, by Hans Boehm, POPL, 2003."
21:28:27 <kmc> otherwise you could do it with "wrapper" as well (but who will finalize the finalizers?!?)
21:28:48 <Berengal> kmc: That could probably be fixed ;)
21:29:14 <lispy> ForeignFunPtr would be a nice addition I think
21:29:20 <Berengal> It would
21:29:22 <monochrom> in case of "wrapper" finalizer, you can do a singleton pattern so you don't need to deallocate
21:29:34 <kmc> lispy, i don't see the point
21:29:35 <lispy> Berengal: you could add them here: http://hackage.haskell.org/package/missing-foreign
21:29:48 * ddarius is with kmc on this.
21:30:29 <kmc> if you're making a FunPtr then you're passing it to C
21:30:31 <lispy> So, I guess I'm not understanding why you wouldn't want your funptrs to be garbage collected
21:30:42 * Berengal has a feeling this will eventually lead to some magnificent kludges
21:31:07 <kmc> once you pass that FunPtr to C, the GHC storage manager can't track it
21:31:21 <lispy> Same problem with Ptr
21:32:08 <kmc> ForeignPtr is useful when you *get* the pointer from C and *use* it in Haskell and want to tell the C library when it's no longer used
21:32:27 <Berengal> kmc: Consider a C++ abstract class with a virtual function. C cannot subclass, of course, so instead it has a constructor that takes a function pointer. Now, the haskell bindings pass it a haskell FunPtr. When do you free the FunPtr?
21:33:05 <lispy> Berengal: I think kmc is saying never because the C++ side may use it later
21:33:28 <kmc> if you do the opposite, allocate a structure in Haskell and pass it to C, then either you can use withForeignPtr or you can't
21:33:50 <kmc> if you can use withForeignPtr then the C library's use of your structure is sufficiently local that you might as well use bracketing allocation, e.g. alloca
21:34:12 <kmc> if you can't use withForeignPtr, you have to use unsafeTouchForeignPtr and you might as well do the same unsafe allocation / freeing on raw Ptrs
21:34:24 <kmc> either way, ForeignPtr gives you little advantage when allocating in Haskell and passing to C
21:34:45 <kmc> now, why would you be using foreign import "wrapper" and freeHaskellFunPtr if you're not allocating in Haskell and passing to C
21:35:04 <kmc> therefore, ForeignFunPtr is not very useful. □
21:35:43 <lispy> I don't think that's the full story for ForeignFunPtr
21:35:44 <lispy> er
21:35:47 <lispy> sorry, for ForeignPTr
21:36:23 <Berengal> kmc: ForeignPtrs have use beyond being scopeable in withForeignPtr; you can put them in Haskell datastructures and have the GC track them 
21:36:43 <kmc> that is the point of ForeignPtr, yes
21:36:51 <lispy> kmc: what about instances where you need a ptr to a struct that exists on the C side?  Then you use a ForeignPtr and you may never be able to peek it into a Haskell value.
21:37:01 <kmc> but you can't rely on that GC if you've at any point coerced it to a raw Ptr and passed that to C
21:37:43 <kmc> lispy, yes, ForeignPtr is useful when a struct is allocated in C side and you want to access it from Haskell and tell the C library when it's no longer needed
21:38:01 <Berengal> kmc: That's a point where tiny dragons start appearing, but they're certainly not the only ones. You just have to be sure you're keeping a reference to the ForeignPtr on the haskell side for as long as the C side has the pointer
21:38:08 <kmc> yes
21:38:33 <kmc> that's my point though
21:38:43 <kmc> that you're not gaining much from ForeignPtr then
21:38:46 <ddarius> kmc: Clearly the use of ForeignFunPtr is to accept Haskell FunPtr's from other instances of the Haskell run-time.
21:39:01 <kmc> because you still have to call unsafeTouchForeignPtr later -- might as well call "free" instead
21:40:17 <kmc> i recently uploaded an FFI library which uses unsafeForeignPtrToPtr in this way
21:40:43 <kmc> the benefit there was that there were also Haskell-side references to the data, external to my library, and this way I don't have to copy the data before I pass it to C
21:41:00 <kmc> but ForeignPtr is not providing any safety to the C interface itself
21:41:39 <kmc> btw GHC also has interfaces for attaching finalizers to arbitrary values
21:41:46 <kmc> and to MVars
21:42:11 <Berengal> It does? This could be useful...
21:42:31 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/System-Mem-Weak.html
21:42:41 <Berengal> Neat.
21:43:03 <Berengal> Unfortunately I have work now. Will look at it later
21:44:21 <lispy> oh, I didn't realize that castPtr = flip plusPtr 0
21:45:01 <lispy> I guess it has to be though
21:46:05 <lispy> ?pl p (!) i = peek $ p `plusPtr` i
21:46:06 <lambdabot> (line 1, column 9):
21:46:06 <lambdabot> unexpected "="
21:46:06 <lambdabot> expecting variable, "(", operator or end of input
21:46:18 <lispy> ?pl let p (!) i = peek $ p `plusPtr` i in (!)
21:46:18 <lambdabot> (line 1, column 8):
21:46:18 <lambdabot> unexpected "!"
21:46:18 <lambdabot> expecting pattern
21:46:22 <lispy> ?pl let p ! i = peek $ p `plusPtr` i in (!)
21:46:22 <lambdabot> (line 1, column 7):
21:46:22 <lambdabot> unexpected "!"
21:46:22 <lambdabot> expecting pattern or "="
21:47:29 <lispy> hmm... (peek .) . plusPtr, does not seem very readable :)
21:47:58 <christo_m> Return [Expr]
21:48:05 <christo_m> thats how i represent return for my AST
21:48:15 <christo_m> laststat ::= return [explist] | break  , you see here that explist is optional to return
21:48:17 <lispy> I guess, that's just peekBytOff
21:48:30 * BMeph likes peek .: plusPtr
21:48:41 <lispy> :t (.:)
21:48:41 <christo_m> so if i use "optional" defined in http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-ParserCombinators-Parsec-Combinator.html
21:48:42 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
21:48:45 <christo_m> ill get () as return
21:49:00 <lispy> BMeph: I've not seen that before.  Is that a lambdabot-ism?
21:49:04 <christo_m> option looks better nvm
21:50:00 <BMeph> lispy: Call it "semi-official"; it's something used so often that it was tossed in.
21:50:46 <lispy> ?hoogle (.:)
21:50:46 <lambdabot> No results found
21:51:12 <lispy> :t \f g -> (f .) . g
21:51:13 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
21:51:36 <BMeph> christo_m: Are you hosting your code somewhere, or is this a passing thing? I'm working on mentally consuming an Io (Levien) interpreter currently.
21:52:29 <lispy> BMeph: this is much easier to grok when I ask for the type outside of lambdabot :)
21:52:31 <BMeph> christo_m: Plus, Lua is my favorite (non-Haskell) scripting language. ;)
21:52:46 <lispy> \f g -> (f .) . g :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
21:52:52 <christo_m> BMeph: im in this compilers course with a bunch of graduate students (im an undergrad) .. the class is very conceptual
21:53:07 <christo_m> i mean, we learn about concepts like code optimization, generation. but the actual stuff ive had to figure out on my own and off examples
21:53:19 <BMeph> christo_m: Ah. Good luck, and...Enjoy!
21:53:28 <christo_m> BMeph: i can show you my code but its nothing to learn off of at all
21:53:46 <christo_m> this assignment is actually 50 percent of the grade.. the midterm was 20, and the exam i have tmw for it is 30
21:53:57 <christo_m> i got 88 on the midterm, and im sure ill do fine on the exam. but this assignment is a whole other beast
21:54:36 <BMeph> lispy: lambdabot gives tough-to-grasp answers? I hadn't noticed... ;þ
21:56:11 <BMeph> christo_m: Sounds fun. I have a couple of compiler books (including a 1st or 2nd ed. "Dragon" book) hanging around, but never got into it. So many fields, so little brain...
21:56:26 <lispy> heh
21:56:35 * lispy was never really fond of the dragon book
21:56:50 <lispy> I guess I haven't had to write enough C compilers
21:58:31 <monochrom> I like Appel's series better.
21:58:37 <christo_m> BMeph: the thing thats messing up now is scope
21:58:41 <christo_m> messing me up rather
21:58:48 <christo_m> im not sure if i should keep some sort of list for the environment
21:59:01 <christo_m> and lua's dynamic.. how will i be doing type checking?? argh, so much to do
21:59:01 <lispy> christo_m: reader monads work well for lexical scope
21:59:02 <christo_m> no time
22:00:50 <Dashkal> That was oddly satisfying.  I just managed to express to someone the illusion of mutability.
22:01:02 <jmcarthur> :D
22:01:05 <monochrom> congrats
22:01:17 <monochrom> what argument did you use?
22:01:20 <BMeph> Dashkal: Channeling Hinckey? ;þ
22:01:42 <Dashkal> Anything that requires "mutation" can be done by calling yourself.
22:01:48 <Dashkal> (IO was left alone for now)
22:03:22 <lispy> ?hoogle Storable a => a -> IO (ForeignPtr a)
22:03:23 <lambdabot> Foreign.ForeignPtr mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
22:03:23 <lambdabot> Foreign.ForeignPtr mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
22:03:23 <lambdabot> Foreign.ForeignPtr newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
22:04:14 <lispy> Dashkal: Is that why haskell programmers always know their own phone#?
22:04:26 * Dashkal snickers
22:04:55 <BMeph> lispy: Is that why Haskell programmers are so good at playing poker? ;þ
22:05:16 <monochrom> Berengal: there is "void hs_free_fun_ptr    (HsFunPtr fp);" available to the c side
22:05:29 * RayNbow`TU sucks at poker though :p
22:05:54 <christo_m> lispy: you said the Reader Monad
22:05:57 <christo_m> was that in the paper you sent me?
22:06:29 <lispy> christo_m: I think that paper uses ReaderT because it's all about building a monad transformer stack.  There are better docs if you just want to grok Reader
22:07:03 <lispy> ui fail
22:07:10 <christo_m> better than net fail
22:07:23 <lispy> christo_m: does lua use lexical scope?
22:07:29 <christo_m> lispy: i believe so
22:07:32 <christo_m> thats what do..end is
22:09:00 <christo_m> *Lua> parseTest block "while true do break end"
22:09:00 <christo_m> [While (Bool True) (Block [Break])]
22:09:02 <christo_m> that isnt bad
22:09:04 <lispy> christo_m: you might try this: http://www.muitovar.com/monad/moncow.xhtml#reader
22:14:54 <christo_m> lispy: this may be over my head.. just sayin
22:18:56 <lispy> christo_m: the Reader monad is very simple though.  It just gives you an environment that you can reference.  It also gives you a super simple way to implement lexical scope.
22:20:00 <christo_m> right.
22:20:35 <christo_m> so now, i basically have to do this for each Block right?
22:20:42 <christo_m> each block should be considered to have its own scope
22:20:46 <christo_m> unless i have a globally defined variable.. but im omitting that for now
22:21:02 <christo_m> actually that shouldnt be hard either, if its not in a block, its global
22:43:17 <handonson> how can I get the day of the week with time-1.2?
22:43:47 <handonson> I thought Data.Time.Calendar.WeekDate would do, but I was wrong
23:00:27 * hackagebot ghc-mod 0.5.5 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.5.5 (KazuYamamoto)
23:14:36 <lispy> christo_m: You could implement global scope via the Reader too.
23:14:40 <TomMD> handonson: You have the right module, what's the issue?
23:15:52 <TomMD> handonson: (\(_,_,d) -> d) . toWeekDate . utctDay
23:17:20 <TomMD> > getCurrentTime
23:17:21 <lambdabot>   Not in scope: `getCurrentTime'
23:17:28 <TomMD> > Data.Time.getCurrentTime
23:17:29 <lambdabot>   Not in scope: `Data.Time.getCurrentTime'
23:17:47 <BMeph> @hoogle getCurrentTime
23:17:48 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
23:17:48 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
23:17:55 <TomMD> > Data.Time.Clock.getCurrentTime
23:17:56 <lambdabot>   Not in scope: `Data.Time.Clock.getCurrentTime'
23:18:18 <TomMD> stupid no IO bot.
23:18:57 <shachaf> TomMD: Having no IO is separate from having not having a module imported.
23:19:23 <shachaf> > putStrLn "<IO ()>"
23:19:24 <lambdabot>   <IO ()>
23:21:23 <ion> ghci> :t Data.Time.getCurrentTime
23:21:28 <ion> Data.Time.getCurrentTime :: IO time-1.1.4:Data.Time.Clock.UTC.UTCTime
23:21:33 <ion> Huh. I haven’t seen that before.
23:21:59 <ion> I guess i have only used :t with imported modules in the past.
23:22:23 <handonson> TomMD: I don't think so.
23:23:08 <handonson> afaik, toWeekDate always gives you 1 for the first date of every year.
23:24:22 <christo_m> lispy: im not sure how id use it still
23:24:30 <christo_m> like , i think i understand some of the examples, but how would i apply it here
23:25:11 <TomMD> handonson: That isn't what the haddock says.  I'm getting desirable behavior with: liftM ((\(_,_,d) -> d) . toWeekDate . utctDay) getCurrentTime
23:27:53 <handonson> TomMD: really? because my haddock says "Note that "Week" years are not quite the same as Gregorian years, as the first day of the year is always a Monday."
23:34:41 <TomMD> handonson: Right you are, and my behavior isn't desireable (2 /= Monday).   Huh, not sure then.  Sad that such behavior seems to have disappeared with the passing of old-time.
23:38:45 <TomMD> handonson: ah-ha! liftM (formatTime defaultTimeLocale "%a" . utctDay) getCurrentTime
23:39:06 <handonson> ...
23:39:12 <handonson> Oh.
23:39:16 <handonson> formatTime.
23:39:24 <handonson> yeah, that will do
23:39:29 <handonson> thanks a lot
23:39:49 <TomMD> Sadly that's just leveraging the old-locale package, but it's a build dep so I guess that works.
23:39:50 <handonson> but that doesn't seem right... is it really the best we can get?
23:41:38 <TomMD> handonson: I know a haskeller who computed which day it was on the  unix epoch because of this... it's a Tuesday.
