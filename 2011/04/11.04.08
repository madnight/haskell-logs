00:01:13 <accel> @type modify
00:01:14 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
00:06:35 * hackagebot blaze-html 0.4.1.1 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.4.1.1 (JasperVanDerJeugt)
00:10:49 <Twey> Gah.
00:11:02 <Twey> I cannot for the life of me get dbus-client working
00:11:58 <Twey> dbus-monitor shows the signal being delivered, and I can ‘receive’ it, but processMessage doesn't seem to match it even when I use a basic signal like matchAll { matchType = Just Signal }
00:12:52 <Twey> Er, a basic handler, that is
00:13:46 <accel> how to I kill the first 2 elements of a list?
00:15:26 <Twey> http://hpaste.org/45454/dbusclient_never_processes_s — any ideas?
00:15:40 <Twey> accel: Maybe you want ‘drop 2 list’
00:15:40 <Botje> accel: drop 2
00:15:46 <Twey> > drop 2 [1 .. 5]
00:15:46 <lambdabot>   [3,4,5]
00:18:54 <Itkovian> Is there something like iterate that can work inside a monad (e.g., IO). Should have the type like (a-> IO a) -> a -> IO [a]
00:19:01 <accel> > tail []
00:19:02 <lambdabot>   *Exception: Prelude.tail: empty list
00:20:06 <Itkovian> meuning boegel
00:20:33 <boegel> y0
00:20:34 <ClaudiusMaximus> Itkovian: http://www.haskell.org/hoogle/?hoogle=iterate+%2Bmonad-loops perhaps; there's a problem with your type, though - can you guess what it is?
00:21:06 <boegel> ClaudiusMaximus: you're talking to Itkovian like he's a script kiddie
00:21:09 <ClaudiusMaximus> (at least, i think there is a problem, but i've only had 1/2 a cup of coffee today..)
00:21:24 <Itkovian> ClaudiusMaximus: yeah, but the initial function certainly needs to execute stuff inside IO
00:22:27 <Itkovian> so it's definitely not some (a -> b) thingie
00:22:28 <Twey> :t iterateM
00:22:29 <lambdabot> Not in scope: `iterateM'
00:23:23 <ClaudiusMaximus> right - i'm thinking that IO is strict enough (without hax) that you can't translate iterate into something with that type and expect a result list in finite amount of time/memory
00:24:24 <Itkovian> hmmz
00:24:37 <Itkovian> ok, recursion it is then. 
00:28:02 <ClaudiusMaximus> boegel, Itkovian - sorry if my tone was off
00:29:22 <Itkovian> ClaudiusMaximus: heh, no worries
00:29:28 <Itkovian> this is IRC after all
00:31:52 * fgump is away: I'm busy
00:40:47 <ClaudiusMaximus> which released tarballs of Cabal/cabal-install are recommended for ghc-7.0.3 ?  i had some problems bootstrapping, resolved now (forgot the details, but darcs was involved) so it's not too urgent, i'm just curious
00:41:08 <boegel> ClaudiusMaximus: I was just kidding
00:41:20 <ClaudiusMaximus> boegel: heh ok
00:41:34 <Itkovian> boegel: seriously?
00:43:32 * ClaudiusMaximus bbl; various engineers here, 
00:43:36 <taotree> What would be a reasonable data structure to use when I most often need to: add one to front, access and remove one from back
00:43:43 <accel> queue
00:44:19 <taotree> Util.Queue?
00:46:00 <taotree> Data.Sequence?
00:46:56 <Twey> Yep, Data.Sequence is the one to go for
00:47:03 <taotree> looks like it, thanks!
00:55:42 <nejucomo> :t parse
00:55:43 <lambdabot> Not in scope: `parse'
00:55:57 <nejucomo> :t Text.ParserCombinators.Parsec.parse
00:55:58 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
00:56:48 <nejucomo> If I have a parser of type "GenParser tok MyState t" how can I ever parse with it?  parse requires a state of ()
00:56:58 <nejucomo> How can I change the type of state?
00:59:04 <nejucomo> Ah...
00:59:15 <nejucomo> :t Text.ParserCombinators.Parsec.runParser
00:59:16 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> st -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError
00:59:16 <lambdabot> a
00:59:17 <Twey> nejucomo: >> return ()
00:59:43 <Twey> Oh, sorry — it's the MyState that is the issue
01:00:01 <nejucomo> Twey: exactly.
01:00:19 <Twey> Yes, I think runParser is the way forward
01:00:23 <nejucomo> So probably: parse = runParser ()
01:00:29 <Twey> Yeah
01:04:12 <frerich> Is there a Haskell implementation of a sequence data structure which supports extracting elements at front and inserting at a given position in constant time? I have a sequence of sorted elements. I need to take the one at the front, do something about it, then insert it into the sorted range (so that it's still sorted afterwards).
01:04:20 <nejucomo> hrm.  I'm running into a case where I want syntactically scoped types, which is a language extension.  Is there always a way to rewrite without syntactically scoped types without that language extension?
01:04:33 * nejucomo opens up codepad.org.
01:05:01 <quicksilver> frerich: constant time is a lie.
01:05:16 <nejucomo> http://codepad.org/INgteVA7
01:05:17 <quicksilver> frerich: consider Data.Sequence, Data.Map, Data.IntMap and erm, the new unordered-containers package
01:05:50 <ClaudiusMaximus> @hoogle minView
01:05:50 <lambdabot> Data.IntMap minView :: IntMap a -> Maybe (a, IntMap a)
01:05:50 <lambdabot> Data.IntSet minView :: IntSet -> Maybe (Int, IntSet)
01:05:50 <lambdabot> Data.Map minView :: Map k a -> Maybe (a, Map k a)
01:05:54 <frerich> quicksilver: Ok, just anything which is better at inserting an element in the middle of the list than 'insertBy' :-}
01:05:59 <quicksilver> nejucomo: yes, there always is. Although I wouldn't worry too much it's not exactly harmful.
01:06:34 <nejucomo> Alright.  I like syntactically scoped types anyway.  They seem natural and I haven't thought of- or run into- any problems with them yet.
01:07:40 <ClaudiusMaximus> frerich: i think i've used Data.Map.minViewWithKey for that kind of thing, can't remember when/where though (actually it might have been maxViewWithKey to generate a new Integer not used as a key in the Map, which is a different scenario)
01:08:05 <quicksilver> nejucomo: heavily nested where clauses considered a bit ugly :)
01:08:34 <ilyak> !hoogle [a] -> [(a, a)]
01:12:30 <ClaudiusMaximus> frerich: also, http://www.haskell.org/hoogle/?hoogle=priority+%2bpackage and related searches might have something you're after?
01:13:22 <nejucomo> quicksilver: "are considered" ?  By whom?  :-)
01:14:11 <quicksilver> nejucomo: by me.
01:14:17 <nejucomo> heh...
01:14:35 <quicksilver> nejucomo: you don't need to nest where clauses unless they refer to local variables within subordinate definitions
01:14:48 <nejucomo> I'm a fan of top-down definition plus syntactic scoping, but I haven't read much haskell others have written.
01:15:23 <quicksilver> sure. top-down defintion overall is nice
01:15:30 <quicksilver> just easier to read with less indentation :)
01:15:31 <nejucomo> quicksilver: I nest them as tightly as possible with their use.
01:15:48 <frerich> ClaudiusMaximus : That might be helpful, yep. Thanks!
01:15:57 * nejucomo looks at his code and realizes that's not true.
01:16:14 <quicksilver> I see that's what you're trying to do. that's the opposite of how i'd arrange it
01:16:25 <quicksilver> I'd nest them as loosely as possible given their captures
01:16:53 <nejucomo> Hm.  That might make sense.
01:16:57 <quicksilver> also, "mayExpected = Just expected", seems pointless - it's simple and only used once, why not inline it?
01:17:13 <quicksilver> so the line before becomes assertEqual (show input) (Just expected) mayResult
01:17:13 <nejucomo> What if you had a single where clause that had 100 definitions.  The dependencies between definitions would become hard to follow.
01:17:25 <quicksilver> yes. That would be hard to follow.
01:17:28 <quicksilver> I've never seen that though :)
01:19:04 <nejucomo> I suppose my opinions about style don't have any weight until this thing compiles.  :-)
01:20:46 <nejucomo> This latest iteration still suffers from inference/expectation mismatch: http://codepad.org/om3d2S65
01:21:27 <quicksilver> that's because you're not actually using ScopedTypeVariables correctly, I think
01:21:42 <cartouche> hello
01:21:48 <quicksilver> you need explicit foralls to introduce the scopes
01:22:03 <nejucomo> I don't think the instance clause counts for ...   oh.
01:22:13 <quicksilver> instance forall tok t st . (Show tok, Eq t, Show t) => Testable (ParsecTest tok st t)
01:22:13 * nejucomo rtfms the ghc user guide.
01:22:17 <quicksilver> I think 
01:22:27 <nejucomo> Thanks, I'll try it.
01:22:27 <quicksilver> not entirely sure if that goes outside or inside the brackets
01:23:03 <cartouche> How can open a .example.hs file in haskell browser vesion and load it?
01:24:33 <nejucomo> cartouche: I don't understand your question.  Do you want to edit source code in a file?
01:24:57 <cartouche> yes,exactly...
01:25:27 <cartouche> but I want to do it in the haskel versin that is used in the browser..
01:28:52 <cartouche> Let me explain,  There is a option in main page of haskell.org.Option is that "TRY HASKEL in your browser".  After I open the page,haskell can be used via WEB. In this screen I want to open a .hs file and load it
01:29:46 <quicksilver> I don't think you can cartouche.
01:30:51 <nejucomo> Can you not cut and paste?
01:33:38 <Axman6> cartouche: if you want to work with haskell files, install the haskell platform and get playing
01:34:38 <nejucomo> Doh, I had {- LANGUAGE ScopedTypeVariables -} instead of {-# ... #-}.  Once I properly enabled the feature, I didn't need the forall (in class/instance declarations, all type variables are scoped to their enclosed methods).
01:34:43 <cartouche> Yes,I know this.but in the office I have to work in browser
01:35:13 <Axman6> tryhaskell.org is designed as a very basical introduction to haskell, nothing more
01:37:52 <cartouche> okk thanks a laot Axman6
01:37:58 <quicksilver> nejucomo: ah, good :)
01:38:17 <Axman6> basic* how on earth did i get basical...
01:39:16 <shachaf> Axman6: basically - ly
01:40:00 <Axman6> i think i was thinking about adding the word tutorial and they got smooshed
01:49:05 <nejucomo> Ok, I bundled that codepad stuff into a public repo: https://bitbucket.org/nejucomo/hunit-parsec
01:58:34 * hackagebot alpino-tools 0.1.0 - Alpino data manipulation tools  http://hackage.haskell.org/package/alpino-tools-0.1.0 (DanielDeKok)
02:06:00 <erus_> can i do integer division in haskell? like // in ruby?
02:06:07 <erus_> without using round?
02:06:22 <sipa> use `div`
02:06:31 <sipa> :t div
02:06:32 <lambdabot> forall a. (Integral a) => a -> a -> a
02:06:56 <merijn> > div 12 5
02:06:57 <lambdabot>   2
02:06:59 <merijn> Or
02:07:00 <sipa> > 14 `div` 3
02:07:00 <lambdabot>   4
02:07:04 <merijn> >12 `div` 5
02:07:11 <merijn> Dammit, I'm to slow :<
02:07:24 <shachaf> erus_: Since when does // do integer division in Ruby?
02:07:30 <erus_> python
02:07:33 <erus_> i meant python
02:18:37 * hackagebot cab 0.1.3 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.3 (KazuYamamoto)
02:22:37 <erus_> how can i do a condition in a list comprehension?
02:23:29 <ceii_> > [x | x <- [1..10], div x 2 == 0]
02:23:29 <lambdabot>   [1]
02:23:59 <erus_> how does it know... haskell is clever. 
02:24:21 <erus_> also why does haskell not use % for `mod` like every other language?
02:24:21 <merijn> erus_: How does it know what?
02:24:23 <ceii_> the '<-' arrow indicates a generator
02:24:36 <erus_> ceii_: which is a generator and which is a condition
02:24:38 * hackagebot mstate 0.2.3 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.2.3 (NilsSchweinsberg)
02:25:19 <merijn> erus_: Probably because Haskell has a more academic background and in math modulo is usually written down as 'mod'
02:25:42 <McManiaC> erus_: because % doesn't actually make sense?
02:25:43 <McManiaC> :>
02:25:49 <merijn> erus_: In other words, historical reasons, but it is trivial to define % as mod if you want...
02:26:10 <merijn> > let x % y = mod x y in 10 % 2
02:26:11 <lambdabot>   0
02:26:41 <erus_> lets rally to get it standardised :)
02:26:52 <McManiaC> same with != vs /=
02:26:56 <ceii_> except % is already used for - division - by the Data.Ratio module
02:27:00 <ceii_> :s
02:27:02 <erus_> McManiaC: yeah lets change tha too
02:27:06 <merijn> Ah, right
02:27:07 <ClaudiusMaximus> i thought % is more commonly `rem` than `mod`
02:27:19 <merijn> ClaudiusMaximus: It is not
02:27:31 <merijn> In C, python and Java % is mod
02:27:58 <ClaudiusMaximus> merijn: thanks, i wasn't sure
02:29:02 <Eelis> > let (≠) = (/=) in 3 ≠ 2
02:29:02 <lambdabot>   True
02:29:10 <McManiaC> =)
02:29:21 <merijn> More unicode!
02:29:44 <Eelis> i'm sure there's a modulo symbol in there somewhere
02:29:57 <wires> Haskell has no problems with unicode source?
02:29:58 <McManiaC> I personally dont like unicode source code
02:30:03 <Eelis> wires: not at all
02:30:08 <wires> yay
02:30:32 <Eelis> wires: in fact, there's the really nice UnicodeSyntax extension that lets you write -> as →, => as ⇒, and so on
02:30:39 <Eelis> i use it for everything.
02:30:40 <merijn> wires: I don't know what the default encoding is, I'm guessing UTF-8. But GHC probably accepts some pragma to set this
02:30:43 <wires> Which encodings does it support then?
02:30:58 <wires> Ah :)
02:31:01 <Eelis> dunno, i only care about UTF-8
02:31:13 <merijn> UTF-8 or death!
02:31:17 <wires> Yes, I don't mind, but just so that I know which encoding to use :)
02:31:25 <wires> and indeed.. utf-8 preferred
02:31:32 <merijn> If you see only questions marks you are probably using WTF-8 ;)
02:31:37 <erus_> also lets the get the templates from c++, the .net library, dynamic types from javascript
02:31:49 <espringe> http://hpaste.org/paste/45458/word_pronunciation_annotation#p45459
02:31:49 <merijn> erus_: Why do we need templates?
02:31:49 <espringe> Anyone could help getting that to compile?
02:31:51 <McManiaC> what about utf16? :>
02:32:08 <merijn> erus_: Typeclass and abstract data types already do what C++ templates try to accomplish
02:32:14 <ClaudiusMaximus> merijn: hm, http://hpaste.org/45460/mod_vs
02:32:52 <Eelis> merijn: C++ templates have several features not available in Haskell. among them are proper support for efficient specialization, and values at the type level
02:32:55 <McManiaC> espringe: putStrLn . generateProgramm =<< readFile input"
02:32:58 <McManiaC> -"
02:33:11 <McManiaC> (or do notation)
02:33:29 <merijn> Eelis: Well Haskell has limited support for values at the type level. And for the rest we just need to wait for Agda/Epigram to take over the world :>
02:33:47 <merijn> ClaudiusMaximus: Hmm, maybe you're right...I don't deal with negative numbers and modulo that much :>
02:33:56 <ClaudiusMaximus> merijn: nor me!
02:34:06 <Axman6> Eelis: the efficient specialisation can be achieved using the SPECIALIZE pragma in GHC 7
02:34:18 <merijn> Eelis: As far as efficient specialization goes...I invoke the sufficiently smart compiler conjecture!
02:34:22 <Axman6> well, at least for functions, and possibly data types
02:35:24 <espringe> McManiaC: is this right?
02:35:25 <espringe> main = do
02:35:25 <espringe> 	[input, output] <- getArgs
02:35:25 <ClaudiusMaximus> isn't the type data family stuff useable for "proper" specialization?
02:35:25 <espringe> 	putStrLn . generateProgram =<< readFile $ lines input
02:35:30 * ClaudiusMaximus never used it though
02:35:45 <espringe> oh wait, nvm i see my error
02:36:09 <espringe> putStrLn . generateProgram =<< lines $ readFile input
02:36:13 <espringe> Still doesn't work though
02:36:21 <Axman6> :t lines
02:36:22 <lambdabot> String -> [String]
02:36:25 <Axman6> :t readFile
02:36:26 <lambdabot> FilePath -> IO String
02:36:37 <espringe> How do I strip the IO part of readFile ?
02:36:40 <Axman6> :t \x -> lines (readFile x)
02:36:41 <lambdabot>     Couldn't match expected type `String'
02:36:41 <lambdabot>            against inferred type `IO String'
02:36:41 <lambdabot>     In the first argument of `lines', namely `(readFile x)'
02:36:56 <McManiaC> espringe: putStrLn . generateProgram . lines =<< readFile input
02:37:00 <Axman6> i think you want generateProgram . lines =<<
02:37:14 <merijn> :t (=<<)
02:37:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:37:22 <merijn> :t (>>=)
02:37:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:37:44 <espringe> Ok, sweet. That got rid of my first compile error
02:37:53 <McManiaC> or: lines `fmap` readFile input… but then again this probably wont work with the =<< notations
02:37:56 <McManiaC> ^^
02:38:12 <McManiaC> do ls <- lines `fmap` readFile input; putStrLn $ generateProgram ls
02:38:15 <Eelis> Axman6: the SPECIALIZE pragma is not only nonstandard Haskell, it also doesn't do the same thing. in C++ i can write a generic map<T,U> container, and then provide a specialization that will use a more optimized representation for T=int, for example. Haskell cannot do this, and so we have these horrible Map/IntMap and Set/IntSet distinctions
02:38:27 <espringe> What's wrong with line 102:
02:38:28 <espringe> http://hpaste.org/paste/45458/word_pronunciation_annotation#108
02:38:41 <espringe> That's still giving a compile error about concat, but I don't see why
02:39:28 <McManiaC> espringe: you can also use \ instead of " ++ to use multiline strings in haskell
02:39:28 <illissius> ClaudiusMaximus: not quite, because type/data families don't allow overlap
02:39:32 <McManiaC> "foo\n\
02:39:34 <McManiaC> \bar"
02:39:40 <illissius> that's basically the biggest difference
02:40:36 <ClaudiusMaximus> illissius: ah, ok
02:40:52 <espringe> McManiaC: cool, although I might have to pass on that -- as it causes my syntax highlighting to blow up :(
02:40:53 <McManiaC> espringe: and basicly ($) will try to apply "map cmuToHs cmulines" to the while string ++ ... thing on the right
02:41:08 <McManiaC> espringe: so you will need " ++ concat (map...)" instead
02:41:24 <McManiaC> espringe: lol fair enough
02:41:26 <Axman6> or concatMap
02:41:30 <Cale> I recommend using concat and a list whenever you have more than a couple (++)'s
02:41:32 <McManiaC> …or concatMap :)
02:41:36 <ClaudiusMaximus> merijn: for completeness, there's a large table here with the different % in different languages with sign info: http://en.wikipedia.org/wiki/Modulo_operation
02:41:40 <quicksilver> Eelis: ...although the reason for that is quite fundamental. C++ style specialisation would force specialisation of all polymorphic functions.
02:42:02 <quicksilver> Eelis: which would break GHC's notion of separate compilation.
02:42:04 <Eelis> quicksilver: yes, it's what makes C++ templates fast.
02:42:11 <quicksilver> Eelis: agreed.
02:42:12 <Eelis> and it's something i've long wished Haskel had.
02:42:15 <Eelis> *Haskell
02:42:29 <quicksilver> but it requires a pretty substantial compiler rethink.
02:42:41 <c_wraith> eh.  GHC 7 can do it.
02:42:42 <espringe> McManiaC: Thank you! You rock. Got it working!
02:42:48 <McManiaC> np :)
02:42:53 <c_wraith> that's what the INLINEABLE pragma is for.
02:43:20 <quicksilver> c_wraith: INLINEABLE doesn't let you specialise entire datastructures.
02:43:25 <Eelis> quicksilver: i think it's a *profound* embarrassment that in Haskell one pays (by default) an abstraction penalty when one takes a concrete function and tries to write a generic function that subsumes it
02:44:05 <quicksilver> Eelis: I find it less embarassing because I like the payoff in polymorphic compilation, but I agree it's a problem.
02:49:10 <Axman6> Eelis: you understand GHC is predominantly a research compiler, and has only really in recent years really needed to worry about high performance right?
02:49:58 <Eelis> Axman6: i care nothing about history. i care about what various languages/tools actually offer :)
02:51:16 <Axman6> well, what you've requested is certainly possible, it's just not implemented
02:51:48 <roelvandijk> I have a question about template haskell
02:52:00 <roelvandijk> How does "InstanceD Cxt Type [Dec]" map to an instance declaration
02:52:31 <Axman6> @src Num
02:52:31 <lambdabot> class  (Eq a, Show a) => Num a  where
02:52:31 <lambdabot>     (+), (-), (*)           :: a -> a -> a
02:52:31 <lambdabot>     negate, abs, signum     :: a -> a
02:52:31 <lambdabot>     fromInteger             :: Integer -> a
02:52:45 <kosmikus> roelvandijk: instance Cxt => Type where [Decl] ?
02:52:55 <illissius> right
02:53:03 <illissius> iirc the class itself is part of Type, somewhat confusingly
02:53:03 <Axman6> Ctx would be the (Eq a, Show a), a would be the type, and the definitions of the functions would be [Dec]
02:53:11 <roelvandijk> Ah ok
02:53:14 <Axman6> ew :\
02:53:17 <roelvandijk> That was the source of my confusion
02:53:26 <roelvandijk> I didn't see a difference between the class and the type
02:54:57 <erus_> can i do a reduce/fold type operation in a list comprehension?
02:55:22 <Axman6> no
02:55:37 <sipa> no, but you can do a fold on a list comprehension
02:56:35 <McManiaC> uhm not sure what youre trying to do
02:57:03 <McManiaC> but with the uhm…
02:57:51 <McManiaC> TransformListComp extension (or soon-to-hopefully-be-in-ghc MonadComprehensions) you can use "then" statement in listcomps
02:58:06 <McManiaC> > [ x | x <- [1..], then take 5 ]
02:58:07 <lambdabot>   Illegal transform or grouping list comprehension: use -XTransformListComp
02:58:14 <McManiaC> meh
02:58:15 <McManiaC> ^^
02:58:47 <Starfire_> What's this 'then' thing?
02:59:10 <McManiaC> basicly it translates to something like "take 5 [x | x <- [1..]]"
02:59:39 <Starfire_> OK.
02:59:44 <Axman6> also lets you do lots fo SQL like things with lists, which can be cool
02:59:45 <McManiaC> the translation gets slightly more complicated as soon as there are additional statements behind that then
02:59:48 <McManiaC> :)
03:05:06 <erus_> holy crap ghc compiler errors are starting to make sense 
03:05:17 <McManiaC> haha
03:05:40 <Phyx-> it's all downhill after that
03:05:47 <Phyx-> you'll be given your white jacket soon
03:05:48 <shachaf> Time to upgrade erus_ to the real GHC.
03:05:51 <Phyx-> and your walls padded
03:06:41 <burp> McManiaC: do you have a more complicated example?
03:06:56 <McManiaC> burp: about transform list comps?
03:07:07 <burp> McManiaC: yes
03:07:16 <McManiaC> hm
03:07:48 <McManiaC> Prelude> [ x + y | x <- [1..], then take 5, y <- [1..x] ]
03:07:49 <McManiaC> [2,3,4,4,5,6,5,6,7,8,6,7,8,9,10]
03:07:58 <McManiaC> it also supports group etc
03:08:09 <burp> uh, I see
03:08:41 <McManiaC> Prelude> [ x | x <- [1,2,1,2,1], then group by x ]
03:08:42 <McManiaC> [[1,1,1],[2,2]]#
03:08:44 <McManiaC> -#
03:09:36 <burp> I'm not sure I whether I like this or not :>
03:10:03 <McManiaC> ^^
03:12:04 <McManiaC> we already used monad comprehensions for SQL statements :)
03:12:10 <McManiaC> with DSH
03:12:36 <roelvandijk> Are monad comprehensions a language extension? (I knew they where removed from the standard)
03:12:46 <McManiaC> yes, its still in development
03:12:51 <roelvandijk> Cool
03:12:57 <McManiaC> spj promised to get it in to GHC 7.2
03:13:14 <Twey> 111641 < shachaf> Time to upgrade erus_ to the real GHC.
03:13:19 <Twey> shachaf: You mean Agda?  ;)
03:13:26 <McManiaC> http://hackage.haskell.org/trac/ghc/ticket/4370#comment:50
03:13:31 <roelvandijk> I wonder how much of TransformListComp can be achieved using QuasiQuotation
03:13:55 <Twey> We're getting monad comprehensions back?!
03:14:02 <Twey> This *is* exciting news
03:14:06 <McManiaC> roelvandijk: DSH is currently using quasi quotation, and supports basicly all features implemented by TransformListComp
03:14:18 <McManiaC> but QQ is a pain to debug :S
03:14:19 <roelvandijk> McManiaC: Nice!
03:14:38 <roelvandijk> McManiaC: I agree. It is also painfully lacking in documentation
03:14:57 <erus_> in haskell might a brainfuck interpreter be written as a recursive function that passes the state to itself?
03:15:05 <mauke> sure, why not?
03:15:36 <shachaf> Twey: Back?
03:15:54 * shachaf hasn't been around that long.
03:15:59 <merijn> shachaf: Monad comprehensions used to exist but they were removed in Haskell98, I think
03:16:49 <Twey> erus_: Sure, I've done that
03:16:57 <McManiaC> http://blog.n-sch.de/2010/11/27/fun-with-monad-comprehensions/ =)
03:17:38 <shachaf> merijn: Yes, but *I've* never had them.
03:17:39 <cartouche> do you know a available haskell code for the implementation of pushdown automaton   
03:18:16 <Axman6> PDA's are pretty trivial to implement in haskell from scratch
03:18:31 <merijn> erus_: An interpreter is really just a parser which calls some computational behaviour when it finishes parsing and recursive descent parsing is a really easy to understand approach to parsing. Especially in Haskell
03:19:19 <erus_> there is nothing to parse in bf?
03:19:44 <merijn> Sure there is
03:20:08 <Axman6> parsing is the name given to taking text and extracting the meaning of it
03:20:14 <burp> McManiaC: nice!
03:20:28 <shachaf> Admittedly tokenizing is just id. :-)
03:20:33 <merijn> The fact that Brainfuck syntax is *really easy* to parse, doesn't mean you don't parse :p
03:20:50 <Jafet> More like filter (`elem` "+-<>,.[]")
03:21:07 <Jafet> And more complicated if you do the prog:data convention
03:21:21 <Axman6> you still need matched ['s and ]'s in BF right?
03:21:22 <shachaf> Jafet: Really? There's comment support?
03:21:44 <mauke> Axman6: yes
03:21:47 <merijn> You still need some data structure to store the parsed code in in a way that makes it convenient to add computational behaviour
03:21:48 <Axman6> then it definitely needs to be parsed before executing, at least partially
03:21:48 <Jafet> Well, everything that isn't an instruction is a comment...
03:22:13 <Jafet> Or you can just try to run it and fail if they weren't matched
03:22:19 <Axman6> yeah
03:22:46 <erus_> Jafet: yeah you can treat any other char as a nop
03:23:00 <espringe> gedit asplodes trying to syntax highlight my 50k line (auto-generated) haskell file :(
03:23:01 <shachaf> You can, but that's kind of weird to do.
03:23:10 <espringe> Maybe i need a better editor
03:23:41 <erus_> i think im the only person to use gedit on windows
03:23:52 <shachaf> erus_: Unlikely.
03:24:01 <Twey> gedit runs on Windows?
03:24:17 <Jafet> shachaf: a binary executable to compile brainfuck will probably use more instructions to do error handling than it will to actually translate the code
03:24:21 <merijn> gvim on Windows is the only way :>
03:24:31 <Twey> ergoemacs has a Windows package… ;)
03:24:32 <Phyx-> notepad++
03:24:35 <Jafet> Given that brainfuck was designed precisely for that purpose, it's not surprising that anything goes
03:24:38 <shachaf> I know of at least one guide that suggests installing gedit on Windows.
03:24:42 <shachaf> @karma notepad
03:24:42 <lambdabot> notepad has a karma of 75
03:24:52 <Twey> Oh boy
03:24:54 <shachaf> We all know whose karma that *really* is.
03:25:00 <Twey> Heheh
03:25:00 <Jafet> notepad isn't bad. It's better than ed.
03:25:05 <Phyx-> @karma shachaf 
03:25:05 <lambdabot> shachaf has a karma of 2
03:25:07 <Twey> Disagree
03:25:09 <Twey> I'd take ed any day
03:25:16 <mauke> http://mauke.dyndns.org/stuff/perl/bfc.pl  # compiles brainfuck to OISC
03:25:20 <Phyx-> I actually meant "Notepad++" not Notepad
03:25:22 <Phyx-> lol
03:25:34 <merijn> Notepad++ is very different from Notepad
03:25:45 <Twey> mauke: That's a suprisingly long program
03:25:46 <Phyx-> well.. yeah
03:25:47 <merijn> Since it includes syntax highlighting, auto indent, etc
03:25:55 <shachaf> ed is probably better than notepad.
03:26:02 <Phyx-> notepad is just a menu on a textbox
03:26:11 <Twey> Perl looks like line-noise to me, though, so I have no idea what it actually does
03:26:12 * shachaf should probably learn to use ed properly sometime.
03:26:25 <Twey> shachaf: ed is the standard editor!
03:26:35 <Phyx-> i thought pico was :P
03:26:40 <Twey> Nope
03:26:41 <Twey> It's ed
03:26:46 <Twey> It said so in the manpage
03:26:50 <mauke> Twey: what, all of it?
03:26:58 <Jafet> use strict; means that the perl code you're reading is subtly obfuscated, instead of obviously obfuscated
03:27:03 <mauke> you should understand at least parts of it
03:27:15 <Phyx-> someone actually reads man pages?
03:27:17 <Twey> I can understand some scattered lines
03:27:22 <erus_> how can i get item from index n in haskell?
03:27:22 <shachaf> mauke is good at subtle obfuscation.
03:27:31 <mauke> erus_: for lists: !!
03:27:33 <merijn> erus_: "!!"
03:27:34 <Twey> But not enough to understand what it actually does
03:27:41 <merijn> > [1..] !! 100
03:27:42 <lambdabot>   101
03:27:42 <Twey> erus_: But using !! is an indication you're doing something wrong
03:27:52 <mauke> Twey: what's the first thing that makes no sense?
03:27:56 <Twey> Lists are not meant for random access
03:27:56 <shachaf> I propose renaming it to evil!!
03:27:59 <merijn> Phyx-: Its surprisingly common to read manpages for non-linux users
03:28:15 <merijn> Phyx-: Linux users don't read manpages because linux man pages freaking suck
03:28:29 <Phyx-> lol, all manuals suck
03:28:32 <Twey> mauke: ‘my $s = shift;’
03:28:52 <Phyx-> if you force programmers to write manuals, they'll always suck
03:28:53 <Phyx-> lol
03:28:58 <shachaf> Doesn't Perl support named arguments by now?
03:29:17 <mauke> Twey: 'my' creates local variables, $s is a (scalar) variable, = is assignment, 'shift' removes the first element of an array (unspecified here, so it uses the argument list, @_)
03:29:27 <mauke> shachaf: sadly, no
03:29:32 <mauke> I have a half-working fix
03:29:32 <Twey> mauke: Oh, of course.
03:29:37 <Phyx-> I... need t get some work done
03:29:46 * Phyx- moves irssi to another desktop
03:29:54 <ClaudiusMaximus> man pages on linux are better with 'most' as pager and a terminal that supports colour, but anyway, ot..
03:29:59 <erus_> Twey: i need to get the instruction from the index [ip] from my list of instructions and execute it
03:30:00 <Jafet> mauke: er, which OISC?
03:30:12 <quicksilver> mauke: well, moosex::declare and friends.
03:30:19 <Twey> erus_: You should probably be using an Array instead
03:30:30 <McManiaC> 12:39       Phyx- if you force programmers to write manuals, they'll always suck
03:30:34 <McManiaC> thats why I only write haddocks
03:30:35 <Twey> (a STUArray, even, if you care about efficiency)
03:30:35 <McManiaC> :D
03:30:38 <erus_> Twey: because its O(n)?
03:30:48 <mauke> Jafet: subtract-and-jump-if-negative implemented using sub/js on x86
03:30:49 <Twey> erus_: Yes, and because it has no bound checks
03:31:02 <merijn> > [1..10] !! 12
03:31:03 <lambdabot>   *Exception: Prelude.(!!): index too large
03:31:15 <Twey> erus_: And because it's immutable
03:31:19 <erus_> passing my whole state around so i dont think i need to worry about optimizing yet
03:31:27 * shachaf hasn't heard of most.
03:31:34 <shachaf> Why doesn't hjkl work? This seems broken.
03:31:34 <Twey> Br**nfuck requires that you mutate the memory
03:31:40 <mauke> for a functional bf I'd probably use IntMap or Seq
03:32:08 <Twey> Emulating that with an immutable list is going to be very awkward
03:32:09 <mauke> Twey++  # "br**nfuck"
03:32:21 <mauke> Twey: splitAt, but yes
03:32:29 <Twey> mauke: Like I said, very awkward
03:32:44 <merijn> I really think Haskell should've been called Brainfuck instead of the current Brainfuck :>
03:33:04 <Twey> Does Seq have element updates?  I don't recall
03:33:09 <Jafet> It is called brainfuck, but its name is Haskell.
03:33:12 <mauke> sample compiler output: http://mauke.dyndns.org/stuff/asm/factor.s
03:33:18 <mauke> Jafet: but what is its name called?
03:33:18 <shachaf> Jafet: What is its name called?
03:33:32 <mauke> glassmind
03:33:45 <Twey> Heh
03:34:21 <merijn> Of all package/library managing systems, I must say Haskell has the only properly "world domination" sounding one :>
03:34:26 <mauke> observe the beautiful label names
03:34:37 <espringe> Hm, ghc doesn't seem particularly efficient at compiling a large file :(
03:34:38 <shachaf> `Or else it doesn't, you know. The name of the song is called "Haddocks' Eyes."'
03:34:41 <shachaf> I guess that's appropriate.
03:34:58 <espringe> It's using 1.2GiB, and been a few minutes compiling a large switch statement
03:35:31 <Skola> Is there a simple way to write the names of the files in a folder to a file?
03:35:40 <mauke> ls folder > file
03:36:12 <merijn> espringe: They say that if you say SPJ's full name three times while looking into a mirror, he will appear and fix your GHC problems :>
03:36:25 <dmwit> getDirectoryContents >>= writeFile "file" . unlines
03:36:35 <mauke> Peyton `Simon` Jones
03:36:35 <dmwit> err
03:36:44 <dmwit> getDirectoryContents "directory" >>= writeFile "file" . unlines
03:36:49 <Skola> cheers
03:37:04 <merijn> mauke: I prefer to think of him as Dr. Jones and wearing a fedora + whip :)
03:37:47 <quicksilver> merijn: understandable. Unfortunately, he is no Dr ;)
03:37:59 <merijn> "Python, why did it have to be python!"
03:38:08 <Jafet> writeFile "file" . intercalate "\NUL"
03:38:30 <merijn> quicksilver: He should hurry up and get his phd then, this knowledge is making me sad...
03:38:53 <quicksilver> I think when you've already been a professor, you no longer need the phd ;)
03:38:59 <espringe> Oh crap. ghc just went into massive memory growth stage, and ate 3GB of memory before making my computer start swapping
03:39:07 <mauke> om nom nom
03:39:11 <espringe> Which was 6 minutes into the compile :P
03:39:25 <Axman6> what're you compiling?
03:39:25 <espringe> I guess compiling a dictionary into a haskell application is a bad idea
03:39:30 <erus_> somone should make a minimal functional language like brainfuck
03:39:37 <espringe> A dictionary of words and their pronunciation 
03:39:37 <mauke> erus_: lambda calculus
03:39:47 <merijn> erus_: Lisp and/or lambda calculus :p
03:39:55 <mauke> lisp isn't functional or minimal
03:39:56 <espringe> I'm doing it c-style, where I convert it into a "resource" than compile the resource
03:39:59 <Jafet> SK is pretty minimal
03:40:20 <espringe> /s/than/then
03:40:36 <Jafet> And jot is a functional binary code
03:40:44 <ClaudiusMaximus> espringe: cmudict?
03:40:48 <merijn> mauke: Depends on your definition of functional I suppose. Also, depends whether you consider the Lisp stuff which is implemented in Lisp as part of Lisp or a convenience addon
03:40:51 <espringe> ClaudiusMaximus: yup
03:41:22 <ClaudiusMaximus> espringe: cool, i used that a bit from haskell
03:41:33 <ClaudiusMaximus> espringe: parsed it at runtime, though
03:41:34 <Jafet> McCarthian LISP has about a dozen forms
03:41:50 <Jafet> And it can interpret itself in about two pages of code
03:42:15 <espringe> ClaudiusMaximus: Yeah, I could load it at runtime, but it seems pretty ghetto :(
03:42:25 <Axman6> espringe: you may find that reading it in at runtime is a better idea... (you can serialise it which might speed things up a little)
03:42:25 <mauke> is old LISP turing complete?
03:42:26 <merijn> I should really finish the McCarthy paper sometime, I got about halfway before getting distracted...
03:42:52 <Jafet> I'm pretty sure it is
03:43:01 <Jafet> It takes geniune talent for your language not to be
03:43:12 <espringe> I really don't want to have to ship the cmudict with my app. And I'd rather the cost done at compile time, then runtime
03:43:55 <Jafet> How does ghc store (string) literals in binaries?
03:44:00 <Jafet> It might be horribly inefficient.
03:44:34 <espringe> http://hpaste.org/45461/creatingprogram
03:44:35 <espringe> That's what I'm using to generate the source file
03:44:44 <espringe> Perhaps there's a better way, then using a big switch statement?
03:44:45 <ClaudiusMaximus> espringe: you could use assembler/linker tricks to embed it in a .o file and access it as a bytestring - i started a thingy to do that, but ran into cross-platform issues (i only have linux x86 and x86_64 to test with)
03:44:51 <shachaf> Jafet: I think it stores them contiguously.
03:45:16 <Jafet> As utf-8? That matters too
03:45:32 <espringe> ClaudiusMaximus: Yeah, well I could just do this in c -- and then use the FFI
03:45:52 <espringe> gcc compiles this stuff at around ~100k loc a second on my computer
03:46:13 <shachaf> Hmm, looks like non-ASCII gets special treatment.
03:46:42 <shachaf> No, looks like I'm wrong.
03:47:14 <ClaudiusMaximus> espringe: curious, why not separate the stress from the phoneme in the data definition(s)?
03:47:44 <espringe> ClaudiusMaximus: I no doubt will, this is just my very first attempt at getting something working
03:47:55 <shachaf> Looks like it stores them as UTF-8.
03:50:25 <ClaudiusMaximus> espringe: http://hpaste.org/45462/slow_poetry is one experiment...
03:51:15 <erus_> whats the equivalent of  mylist[index] ++; in haskell?
03:51:21 <erus_> how the hell do i do that
03:51:29 <erus_> map and check index?
03:51:35 <espringe> ClaudiusMaximus: What's a sample 'poetry.words' file, and I'll give it a run :D
03:52:14 <ClaudiusMaximus> espringe: i generated a word list from the en.wikipedia article on "poetry"
03:52:26 <merijn> erus_: You can't really do that with lists, that's why someone(forgot who) recommended Array earlier
03:52:29 * hackagebot splot 0.1.14 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.1.14 (EugeneKirpichov)
03:52:50 <merijn> erus_: http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.3.0.2/Data-Array.html
03:52:50 <Jafet> erus: take and drop
03:53:20 <erus_> ah cheers
03:55:12 <ClaudiusMaximus> espringe: /usr/share/dict/words might also be suitable (assuming english locale)
03:55:39 <espringe> http://hackage.haskell.org/trac/ghc/captcha.png
03:55:43 <espringe> Is that supposed to be readable :/
03:55:56 <espringe> I'm going to have to write a program to parse these things, cause I obviously can't...
03:55:59 <Phyx-> 404
03:56:38 <Phyx-> espringe: it's to deter you from filing bugs :P they have enough to do already :P
03:57:03 <espringe> phyx: You're right!              Trac detected an internal error:             OperationalError: database is locked           
03:57:30 <Phyx-> yeah, the ghc bugtrac is kinda buggy
03:57:44 <Phyx-> sometimes even though I'm logged in it posts as "Guest"
03:57:46 <merijn> Probably not written in Haskell, then
03:58:01 <Phyx-> trac is written in python if i'm not mistaken
03:58:30 <merijn> Time to go invent a Bug algebra and then see if I can distill it into Arrows or Monads...
03:58:44 <espringe> The captcha looks really stupid. It's got this word, and then they sprinkle the image with noise. But if you keep refreshing the captcha, they have the exact smae base image -- just the noise changed
03:59:02 <espringe> So it'd be trivial to remove the noise for a computer, but enough to make it hard to read for a human
03:59:14 <Phyx-> maybe you get one image per session?
03:59:25 <merijn> Most captcha's suck anyway
03:59:28 <Phyx-> yup
03:59:29 <lol_i_troll_u> Where can I go to see real benchmarks between Haskell and other languages
03:59:35 <lol_i_troll_u> not just microbenchmarks
03:59:38 <Jafet> CAPTCHAs are for shutting out access to anti-anti-CAPTCHA measures
03:59:42 <lol_i_troll_u> like fron the lang. shootout.
03:59:51 <merijn> I actually read a nice paper on the effectiveness of captcha's and new approaches to captcha's
04:00:10 <Phyx-> Jafet: don't those two anti's cancel eachother out? :P
04:00:14 <merijn> Those ideas seemed much more interesting (i.e. contextual decisions about images)
04:00:50 <Jafet> Phyx-: yes. That's why people have to keep on making more elaborate CAPTCHAs
04:00:53 <Phyx-> bleh, 1pm and I haven't coded a single line today..
04:01:24 <Phyx-> Jafet: lol
04:01:27 <merijn> lol_i_troll_u: I don't think there are a lot of those, because they are hard to make
04:01:50 <Phyx-> http://www.smashingmagazine.com/2011/03/04/in-search-of-the-perfect-captcha/
04:01:50 <merijn> lol_i_troll_u: And it depends on the sort of benchmarks you are interested in
04:01:59 <Phyx-> nice atticle on Captchas
04:02:03 <lol_i_troll_u> parsers for example
04:02:23 <lol_i_troll_u> that should be reasonably simple to test
04:02:25 <cartouche> how can I get the tail of tuple like in the list_  for example my_tail  (a,b,c,d)  = (b,c,d)
04:02:39 <Phyx-> cartouche: you write a function to do it
04:02:41 <shachaf> cartouche: Just like that.
04:02:43 <merijn> lol_i_troll_u: The general opinion is that Haskell rules for writing parsers. Maybe the Parsec site has benchmarks? But I don't know...
04:02:54 <Phyx-> lol, indeed, just like that
04:03:11 <merijn> > let my_tail (a,b,c,d) = (b,c,d) in my_tail (1,2,3,4)
04:03:12 <lambdabot>   (2,3,4)
04:03:38 <shachaf> cartouche: Anyway, you don't actually want this operation.
04:03:54 <Jafet> You want HList!
04:04:11 <shachaf> Yes, what Jafet said.
04:04:12 <cartouche> I wonder whether any built in funtion for this
04:04:13 <Jafet> Shamwow sold separately.
04:04:15 <aleator> lol_i_troll_u: http://www.serpentine.com/blog/2011/02/25/faster-better-cleaner-new-aeson-and-attoparsec-releases/ has something on parsing json
04:04:15 <shachaf> Everybody wants HList.
04:04:25 <Phyx-> looking at the abstract syntax for Tuples in both GHC and UHC, why aren't there generic functions for tuples? e.g. take 3 (1,2,3,4,5,6). 
04:04:25 <shachaf> cartouche: No, because it's a weird operation.
04:04:30 <shachaf> Tuples aren't lists.
04:04:39 <cartouche> ok thanks...
04:04:47 <Jafet> Phyx-: and what is the type of take?
04:05:41 <Phyx-> Jafet: can't say for GHC, but in UHC the type would stay the same actually, RowTyExpr
04:05:42 <merijn> Jafet: Very easy, we just first need to implement dependent types in Haskell :>
04:06:20 <Jafet> There's a package that uses flimsy type classes
04:06:56 <Phyx-> Jafet: you just lose an outer quantifier if one of the elements you removed was polymorphic.
04:07:06 <merijn> Dependently typed languages are like flying cars, people keep promising them to me, but I never see them :<
04:07:17 <Jafet> Oh, I don't know that extension
04:08:03 <Jafet> merijn: they only exist in highly academic or experimental settings
04:08:13 <Phyx-> merijn: lool
04:08:13 <Jafet> And do not deliver the advertised benefits
04:08:19 <Phyx-> yet
04:08:20 <merijn> I know :\
04:08:37 <Phyx-> It's not because they can't be delivered.. it's just that no one has
04:08:51 <Phyx-> Jafet: what extension?
04:09:02 <merijn> well, Ur seems interesting and is supposedly used for real world programming
04:09:18 <Jafet> Wait, what's RowTyExpr?
04:09:56 <Phyx-> Jafet: the internal type representation of among other Tuples in UHC. It's just a recursive structure
04:10:19 <Jafet> Oh
04:11:11 <Phyx-> IT doesn't have any polymorphic component and can hold anything that is a TyExpr. so defining take 3 (1,2,3,4,5) should be pretty straightforward
04:11:16 <Jafet> You can do that in ghc, I suppose: data Tuple n a = Tuple (Head a) (Tuple (Pred n) (Tail a))
04:11:29 <merijn> Phyx-: You're at UU, then? Any interesting phd positions related to Haskell there? :>
04:11:43 <Jafet> With type-level naturals
04:12:00 <Phyx-> but you can't actually define it *in* haskell itself without dept types, but a build in function would do
04:12:32 <Phyx-> merijn: I only know of one, having to do with Typed-Core
04:13:31 <merijn> I need to start looking for a PhD spot, but its hard to figure out where the interesting things are happening :p
04:13:47 <Phyx-> Jafet: would that work? wouldn't that a force it to be homogenous tuples?
04:14:14 <Jafet> Where a is a type list and Head and Tail do the appropriate magic
04:14:15 <Phyx-> homogeneous*
04:14:25 <Jafet> And I don't know how to write the base case... type families?
04:14:43 * Jafet forgets how HList works.
04:14:51 <Phyx-> never used that package
04:14:56 <Phyx-> always wrote my own
04:14:59 <Phyx-> it's like 3 lines :/
04:15:45 <Phyx-> last time I used heterogeneous was to be able to specify a list of types that SYB functions shouldn't enter
04:15:54 <Phyx-> kinda an exclusion list
04:20:33 <Phyx-> :k *
04:20:34 <lambdabot> parse error on input `*'
04:20:40 <Phyx-> :k (->)
04:20:41 <lambdabot> ?? -> ? -> *
04:21:28 <toby> i'm trying to get Text.Regex.Posix.=~ to return the string matched by a parenthesized subexpression
04:21:33 <toby> for example,
04:21:37 <toby> "x:1 y:2 z:3" =~ "y:([0-9]+)" :: String
04:21:52 <toby> yields "y:2"... but I just want to get "2"
04:22:05 <toby> i think i need AllTextMatches, but can't work out how to use it
04:22:26 <mauke> > "x:1 y:2 z:3" =~ "y:([0-9]+)" :: String
04:22:27 <lambdabot>   "y:2"
04:22:33 <mauke> > "x:1 y:2 z:3" =~ "y:([0-9]+)" :: [String]
04:22:34 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
04:22:34 <lambdabot>                    ...
04:23:36 <quicksilver> > "x:1 y:2 z:3" =~ "y:([0-9]+)" :: [[String]]
04:23:37 <lambdabot>   [["y:2","2"]]
04:23:39 <quicksilver> toby: ^^
04:23:44 <mauke> > mrSubList ("x:1 y:2 z:3" =~ "y:([0-9]+)")
04:23:44 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
04:23:44 <lambdabot>                    ...
04:23:54 <quicksilver> the overloadings for ~= are many and painful
04:24:15 <mauke> it's =~
04:24:24 <quicksilver> yes, that's the one :)
04:24:37 <toby> many thanks, quicksilver
04:24:45 <quicksilver> > "x:1 y:2 y:3" =~ "y:([0-9]+)" :: [[String]]
04:24:46 <lambdabot>   [["y:2","2"],["y:3","3"]]
04:24:54 <quicksilver> ^^ that's why it is [[String]] not [String]
04:25:19 <mauke> why doesn't it also do [String]?
04:25:52 <toby> dunno: Real World Haskell says it should
04:25:57 <quicksilver> "why" is such a good question for the regex module.
04:26:09 <toby> :-)
04:26:28 <quicksilver> I never use regexps in haskell
04:26:38 <quicksilver> and that module's interface is part of what showed me the light ;)
04:26:52 <toby> what do you use? parsec?
04:30:45 <Arnar> if I installed the platform 2010.1 from a ubuntu pkg, do you guys think it is safe just to install 2011.2 (and ghc7) from the sources over it?
04:32:53 <kosmikus> Arnar: I probably wouldn't install it "over it". but if you install the new stuff to, say, /usr/local/, then both versions should coexist peacefully
04:33:03 <Arnar> kosmikus: right
04:33:06 <Arnar> kosmikus: thanks
04:33:12 <Arnar> and cabal won't get confused?
04:33:25 <kosmikus> Arnar: cabal will usually pick the ghc that's in PATH
04:33:41 <kosmikus> and then not get confused
04:33:59 <Arnar> ok, thanks
04:34:04 <Arnar> I'll just try something
04:34:10 <Arnar> not much to lose at the moment
04:34:38 <toby> quicksilver: i'm intrigued: how would you concisely extract "2" from "x:1 y:2 z:3" without using regexps?
04:35:08 <opqdonut_> > "x:1 y:2 z:3" !! 5
04:35:08 <lambdabot>   ':'
04:35:19 <opqdonut_> > "x:1 y:2 z:3" !! 6 -- oops :)
04:35:19 <lambdabot>   '2'
04:35:36 <shachaf> > const "2" "x:1 y:2 z:3"
04:35:36 <lambdabot>   "2"
04:36:23 <toby> ok, we were discussing the regexp "y:([0-9]+)", so i'd also like to extract 93 from "y:93 otherjunk" and 17 from "p:11 q:103.5 y:17"
04:36:30 <quicksilver> toby: probably I'd use a real parser
04:36:46 <mauke> clunky
04:36:57 <echo`> @help
04:36:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:37:02 <quicksilver> but there are cases, especially simple hacks, where regexps are the quick solution.
04:37:02 <merijn> Anyone willing to give me a short explanation of the "inversion principle"? Search engines are only turning up some OO gobbledy-gook instead of the natural deduction context I'm looking for :\
04:37:21 <toby> mauke: true, but at least if you choose to code up a real parser you've decided exactly what the problem is
04:37:31 <mauke> same for regexes
04:38:16 <quicksilver> yes, but regexes are an ugly DSL for describing parsing
04:38:39 <quicksilver> and some things are very fiddly in regexps - such as nesting or escaping.
04:38:46 <merijn> s/describing parsing/describing the parsing of regular grammar/
04:38:54 <mauke> escaping is reasonably straightforward
04:39:00 <quicksilver> there exist other much less ugly DSLs for descriping parsing.
04:39:01 <mauke> nesting is impossible
04:39:18 <quicksilver> (and more featureful too)
04:39:28 <quicksilver> regexps are a very poor tradeoff
04:39:32 <mauke> I doubt that
04:39:47 <quicksilver> they justify their existance for interactive uses - such as the editor which prompts the user for a regexp
04:40:37 <mauke> what would be a more powerful replacement for regexes?
04:41:06 <fryguybob> > filter (isPrefixOf "y:") . words $ "x:1 y:2 z:3"
04:41:07 <lambdabot>   ["y:2"]
04:41:33 <quicksilver> mauke: Parsec/do notation/applicative notation is a better DSL than regexps for actual programming.
04:41:42 <quicksilver> and in point of fact I prefer other combinator libraries to parsec.
04:41:43 <mauke> parsec isn't more powerful
04:41:50 <quicksilver> but I prefer *any* combinator library to regexp.
04:42:13 <mauke> combinator libraries are often too verbose
04:42:21 <quicksilver> this is a question of taste.
04:42:26 <quicksilver> I vehemently disagreed.
04:42:38 <quicksilver> parsec handles nesting with ease - that's "more powerful"
04:42:42 <mauke> no
04:42:54 <mauke> "more powerful" implies that it is a superset of regex functionality
04:42:56 <merijn> Well, yes. More powerful, not necessarily more usable
04:43:31 * quicksilver shrugs.
04:43:38 <quicksilver> it is a superset, in the sense which matters
04:43:56 <quicksilver> which is that because it's a DSL hosted in haskell, you can patch together whatever else you need at the haskell level
04:44:00 <fryguybob> > let searchPrefix p = catMaybes . map (stripPrefix p) . words in searchPrefix "y:" "x:1 y:2 z:3"
04:44:01 <lambdabot>   ["2"]
04:44:26 <mauke> so how do say $foo =~ /(?<!\S)bar(?!\S)/ in parsec?
04:45:37 <quicksilver> if that's literally all you want to say, then regexp will be much shorter.
04:45:47 <quicksilver> In many practical cases what you actually want to do is parse the file
04:45:57 <quicksilver> and then run a test on the parse tree to see if that bit is there.
04:46:10 <mauke> it's not a file, it's a single setting in irssi
04:46:53 <mauke> and then I don't need parsec, because that's just "bar" `elem` words foo
04:48:49 <mauke> I've been thinking how to handle escaping in parsec
04:49:04 <mauke> seems to be as "fiddly" as with regex
04:49:34 <mauke> in fact, I use my regex brains to think about parsec; maybe that's part of the problem
04:49:46 <quicksilver> I do it in stages, mauke
04:49:53 <quicksilver> lex first and handle escaping in the lexer
04:50:09 <mauke> that seems even more complicated
04:50:12 * quicksilver shrugs
04:50:18 <quicksilver> it is complicated, in a sense
04:50:23 <quicksilver> but it's easy to understand and maintainable
04:50:32 <mauke> does your lexer use regexes?
04:50:36 <quicksilver> no.
04:50:57 <quicksilver> either write the lexer using parser combinators, or write the lexer using simple string recursions
04:51:06 <Jafet> Can't you write CFGs in perl now?
04:51:16 <Jafet> There's a recursive regexp feature or something
04:51:19 <mauke> manual recursion? I'd rather use a regex
04:51:33 <McManiaC> is it possible to write "type Foo a = Bar [a]" without that a? so you can write type synonym instances for Foo ?
04:51:55 <McManiaC> where Foo :: * -> *
04:52:21 <merijn> McManiaC: "type Foo = forall a. Bar [a]"? (note: I may have screwd up the syntax there)
04:52:33 <ski> merijn : that's not the same thing
04:52:38 <McManiaC> merijn: that would result in Foo :: *
04:52:39 <ski> McManiaC : no
04:52:42 <sipa> McManiaC: you want something like a type-level . ?
04:52:46 <merijn> ski: Yeah, I missed the secondline
04:52:49 <McManiaC> sipa: yeah :S
04:52:50 <sipa> type Foo = Bar . []
04:52:58 <mauke> " ( [^\\"] | \\. )* "
04:53:00 <McManiaC> that works? hmm
04:53:03 <sipa> no it doesn't
04:53:20 <sipa> i don't think it's possible
04:53:26 <mauke> char '"' *> many (noneOf "\\\"" <|> (char '\\' >> anyChar)) <* char '"'
05:00:18 <McManiaC> think I got it
05:00:31 <McManiaC> type FF a = Bar [a]; type Foo = FF
05:00:35 <McManiaC> ;P
05:00:45 <mauke> does that syntax?
05:01:07 <McManiaC> hmmm
05:01:14 <McManiaC>     Type synonym `LQ' should have 1 argument, but has been given none
05:01:15 <McManiaC> damn
05:01:16 <McManiaC> ^^
05:02:48 <dixie> hmmm, is there plan for gtk3hs ? :)
05:12:08 <cartouche> what is the difference between data and type    ,for example data A and type B
05:12:27 <mauke> 'data' creates a new type
05:12:34 <mauke> 'type' creates a new name for an existing type
05:12:58 <cartouche> could you give me simple examlple?
05:13:00 <mauke> in C terms, data = struct+union+enum, type = typedef
05:13:17 <mauke> type String = [Char]
05:13:24 <mauke> data Maybe a = Nothing | Just a
05:14:00 <sipa> after type String = [Char], you can use String and [Char] interchangably
05:14:30 <cartouche> you say data is like strcuture in C?
05:14:31 <sipa> while data Maybe a introduces a actual new type
05:14:47 <mauke> there is no strcuture in C
05:15:01 <cartouche> struct I mean
05:15:15 <mauke> I'm saying it's like struct and union and enum, all in one
05:15:27 <cartouche> for example struct a {int b,int c,char *f };
05:15:48 <mauke> data A = Foo{ b, c :: Int; f :: Ptr Char }
05:16:28 <frerich> Are there good rules of thumbs for making it easy to port code from a plain list to something like Data.Sequence or ByteString? I notice that I usually start with lists (since they are very easy to work with) but eventually I'd like to use a more memory or CPU efficient representation.
05:17:05 <frerich> And when moving to e.g. ByteString I saw that (:) is called cons and [] is empty etc. So if I had aliases like that for lists, porting the code would have been very easy.
05:17:50 <luite_> there's the ListLike package
05:19:03 <frerich> luite_: Cool, that's pretty neat!
05:19:07 <luite_> and in general, you could perhaps more generic typeclasses instead of the functions for list, like Functor, Traversable, Foldable
05:19:45 <luite_> oh I totally the verb in that sentence
05:19:50 <frerich> ;-)
05:20:01 <frerich> I think using type classes is an even better idea
05:21:21 <frerich> Actually, that's indeed how I usually start. I write [Int] in the beginning and later I realize that it actually works for [a] (in some context) and then I realize it works for anything which can be folded or so.
05:21:52 <luite_> yeah but those are more limited than ListLike, and there are probably things that you cannot implement as efficiently
05:36:41 * hackagebot Biobase 0.3.1.1 - Base library for bioinformatics  http://hackage.haskell.org/package/Biobase-0.3.1.1 (ChristianHoener)
05:44:14 <dblhelix> @seen dcoutts
05:44:14 <lambdabot> Unknown command, try @list
05:44:14 <preflex>  dcoutts was last seen on #ghc 1 day, 12 hours, 28 minutes and 37 seconds ago, saying: cool, g'night
05:44:51 <dblhelix> #join cabal
05:47:27 <navaati> hello
05:49:39 <nlogax> was reading this, http://qconlondon.com/dl/qcon-london-2011/slides/GregoryCollins_HighPerformanceWebApplicationsInHaskell.pdf , and saw "but for C
05:49:40 <nlogax> calls that would block it transparently switches to threaded scheduling."
05:49:42 <navaati> it seems it isn't possible to use type classes with type synonyms, is there a way ?
05:49:51 <nlogax> how does that work? sounds magical :)
05:51:19 <merijn> nlogax: Probably lots of dark voodoo
05:52:17 <ski> navaati : there's an extension that allows it, but only in a trivial sense
05:53:15 <merijn> nlogax: I suspect the runtime has a pool of idle threads (in addition to the pool running the green threads), then when one of the C calls which block causes one of the pool threads executing green threads to block, the runtime detects this and picks one of the idle threads to pick up the slack
05:53:23 <navaati> ski: interesting, what is this extension ?
05:53:32 <merijn> nlogax: Note that this is all conjecture from my side, since I haven't actually looked into how it works :p
05:53:45 <ski> i don't recall the same, maybe something like `TypeSynonymInstances'
05:54:39 <nlogax> merijn: that would make sense :)
05:54:53 <nlogax> i will look but doubt i understand anything
05:55:25 <merijn> nlogax: I suspect what it actually does isn't that hard, but finding a clear explanation of what/how (or even ANY explanation) might be hard :p
05:56:09 <ski> navaati : see `TypeSynonymInstances' at "7.6.3.1.Relaxed rules for the instance head" <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#flexible-instance-head>
05:57:17 <ski> (navaati : especially note the "As always, ..." part)
05:57:34 <ski> (er, the latter of those, in that subsection, i meant)
05:59:29 <McManiaC> TIL that "forall" isn't always optional :>
06:00:36 <quicksilver> scoped type variables and higher rank types
06:00:44 <quicksilver> although I think scoped typed variables are never, strictly, necessary.
06:01:16 <McManiaC> yes they are
06:01:18 <ski> iirc, with DMR, they are
06:02:02 <quicksilver> I think you can always do tricks like "asTypeOf"
06:02:15 <quicksilver> to add constraints to type inference
06:02:18 * Saizan used the DMR to avoid STV more than once
06:02:20 <McManiaC> return :: forall a. QA a => Q a -> Q [a]
06:02:20 <McManiaC> return (Q x) = Q (ListE [x] $ reify (undefined :: [a]))
06:02:28 <McManiaC> this example won't work without forall
06:02:57 <McManiaC> reify :: a -> Type
06:03:09 <mauke> should be trivial
06:03:31 <McManiaC> nope
06:03:34 <mauke> unQ :: Q a -> a; unQ = undefined
06:03:54 <mauke> return (Q x) = r where r = Q (ListE [x] $ reify (unQ r))
06:04:00 <Saizan> return q@(Q x) = Q (ListE [x] $ reify (type_ q)) where type_ :: Q a -> [a]; type_ = undefined
06:04:08 <quicksilver> exactly.
06:04:15 <quicksilver> that's what I meant by 'asTypeOf' tricks.
06:04:15 <McManiaC> "Q a" is a pseudo type variable
06:04:18 <merijn> Ok, now I'm scared...
06:04:25 <McManiaC> newtype Q a = Q Exp
06:04:33 <mauke> McManiaC: and?
06:05:09 <McManiaC> hm
06:06:56 <Berengal> merijn: Are you familiar with select/epoll?
06:07:44 <merijn> Berengal: Yes
06:08:18 <merijn> Berengal: If you are referring to the earlier discussion about blocking threads, then you probably misread the discussion :)
06:09:02 * Berengal rereads
06:09:39 <merijn> Berengal: The issue was FFI C calls which block, not Haskell's native IO calls. The latter are of course handled in the runtime trivially with select/epoll
06:10:04 <merijn> But the Google presentation implies the runtime also works around blocking FFI C calls, and the discussion was how *that* was handled
06:12:17 <SoleSoul> Hi guys. I need an advice. I'm have to combine the content of a list of files to one long file. let fileList be the list of filenames of type [String]. Since I'm quite new and the operation combines using IO types with pure string I'm a bit confused how I am supposed to think about it.
06:13:00 <mauke> :t mapM readFile
06:13:01 <lambdabot> [FilePath] -> IO [String]
06:13:12 <mauke> :t liftM concat . mapM readFile
06:13:12 <lambdabot> [FilePath] -> IO [Char]
06:13:22 <McManiaC> SoleSoul: do files <- mapM readFile ["file1", "file2"]; writeFile "combined" (concat files)
06:13:34 <McManiaC> sth like this
06:13:36 <Cin> mauke, solving homework problems since 2006.
06:13:41 <McManiaC> :D
06:13:56 <SoleSoul> Thank you! I never heard of map<
06:13:59 <SoleSoul> *mapM
06:14:13 <Berengal> merijn: Not only implies. It pretty much states it outright. Now I'm curious as to how they do that too (maybe link their own libc?)
06:14:19 <mauke> :t (join .) . (`forM` readFile)
06:14:20 <lambdabot> [FilePath] -> IO [Char]
06:14:21 <shachaf> @ty sequence
06:14:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:14:24 <SoleSoul> I am indeed doing homework but I chose to do it in haskell because I want to learn haskell
06:14:48 <Cin> That'll be fun for your teacher.
06:15:21 <SoleSoul> lol I don't think he will take the time to really understand everything
06:16:02 <navaati> I'm with SoleSoul : let's show these teachers what a nicer language than their C and Java is !
06:16:23 <navaati> (i'm doing school work with haskell too)
06:17:28 <merijn> Berengal: That makes no sense, because blocking libraries written in C called via the FFI would still be susceptible. As I said, the most reasonable explanation seems that when you have M green threads pooled on N OS threads, you have P idle OS threads and then detect when a green thread has blocked an OS thread then swap in one of the P idle threads
06:18:17 <Berengal> merijn: libc is usually dynamically linked, isn't it?
06:19:07 <navaati> Berengal: it's possible to replace dynamically linked libs at runtime (in fact it's easier, as they are dyncamically linked)
06:19:33 <Berengal> Also, if I read the wiki on FFI correctly, only safe foreign calls will work this way. They're run on a separate, bound OS thread from the regular scheduler
06:20:20 <navaati> I have a type "(Compiler c) => Program c a b = <some stuff>", is it possible to make it an instance of Arrow ?
06:21:47 <_KY_> Is interfacing Haskell with C++ robust?
06:23:42 <merijn> _KY_: Interfacing with C is easy and robust, so by extension C++ should be relatively easy/robust, but I don't know much about that
06:24:02 <_KY_> I see...
06:24:09 <Berengal> _KY_: If the C++ library in question has C bindings then it's easy
06:24:10 <luite_> except that interfacing with C++ is much trickier
06:24:29 <Berengal> There's no support for interfacing with C++ as such
06:24:38 <Berengal> (In fact, even C++ has trouble interfacing with C++)
06:24:51 <_KY_> Heh...
06:25:06 <_KY_> Sounds bad...
06:25:08 <luite_> even if the C++ library has a C interface, you could run into some annoying limitations
06:25:21 <Berengal> luite_: Such as?
06:26:37 <luite_> Berengal: the ghci linker (at least on windows) not supporting "strange" sections in the object files, for global initializers for example
06:26:55 <luite_> so you can only use your library with ghc, not in ghci
06:27:20 <Berengal> Ah, I haven't encountered that...
06:29:48 <Axman6> _KY_: afaict, C++ is a horrible beast to try and interface with. wrapping in C is usually a much better idea
06:30:38 <_KY_> But what if people have existing C++ code that I need to call?
06:31:01 <Berengal> _KY_: Write a C binding for it
06:31:02 <Axman6> then wrap it in C
06:31:10 <Axman6> C++--
06:31:12 <Berengal> There are probably tools that lets you do that easy enough
06:31:19 <_KY_> Hehe
06:31:25 <Axman6> @karma C++
06:31:25 <lambdabot> C++ has a karma of -1
06:31:30 <burp> huh
06:31:37 <Berengal> @karma C
06:31:37 <lambdabot> C has a karma of 4
06:31:38 <Axman6> that used to be lower i swear
06:31:40 <mauke> preflex: karma C++
06:31:40 <preflex>  C++: -54
06:31:47 <Axman6> better
06:31:51 <burp> it was at least -200 or -300
06:31:51 <luite_> Axman6: but unfortunately that doesn't solve the linker issues I mentioned
06:32:00 <Axman6> sure
06:32:47 <mauke> preflex: karma C
06:32:48 <preflex>  C: 165563
06:33:01 <Berengal> > logBase 2 165563
06:33:02 <lambdabot>   17.337020769975044
06:35:44 <ski> navaati : i think that would depend on the details of `<some stuff>' ..
06:42:15 <pastorn> ok, so i have my summer of code proposal
06:42:24 <pastorn> i can't find what to do with it...
06:42:49 <pastorn> should i put it on the bugtracker or somewhere else?
06:45:04 <merijn> Isn't GSoC already closed?
06:47:22 <stepkut> is this the most recent location for haskell-mode, http://code.haskell.org/haskellmode-emacs
06:47:35 <merijn> pastorn: You have to submit the proposal to Google, but the deadline closed yesterday
06:48:26 <pastorn> merijn: no, today
06:48:58 <aristid> depending on the timezone?
06:49:10 <pastorn> merijn: still 5 hours...
06:49:11 <merijn> pastorn: I was looking at the haskel SOC site: http://hackage.haskell.org/trac/summer-of-code/wiki/Soc2011
06:49:33 <merijn> That says "The deadline for submitting your application to Google is 7th April 2011, so it is a good idea to start working on it now."
06:50:27 <fryguybob> http://google-opensource.blogspot.com/2011/04/final-hours-to-submit-your-google.html
06:50:41 <merijn> Anyhoo, that seems to suggest you should submit at the GSoC site itself, not a Haskell site
06:51:00 <sipa> you're at GMT -19 ?
06:51:07 <pastorn> sweden
06:51:11 <aristid> sipa: does that even exist? :D
06:51:22 <merijn> aristid: If you're travelling really fast
06:51:28 <sipa> in sweden it is currently 4pm, april 8th
06:51:43 <aristid> sweden is currently GMT+2 i think
06:51:45 <aristid> stupid DST
06:51:53 <sipa> correct
06:52:00 <merijn> sipa: Well, the blogpost fryguybob linked says the deadline is GMT19.00 on April 8th
06:52:06 <merijn> So maybe the Haskell wiki is out of data
06:52:07 <sipa> ah :)
06:52:10 <merijn> s/data/date
06:52:21 <aristid> UTC 19 means Sweden time 21
06:53:00 <merijn> Oh, yeah, UTC not GMT
06:53:41 <aristid> i think "GMT+2" is only used sometimes for historical reasons
06:53:42 <sipa> UTC and GMT are for all practical purpose the same thing
06:53:42 <josh04> Could anyone take a look at this for me: http://pastebin.com/Suh3EZXY
06:53:49 <josh04> It's a linking error
06:53:55 <merijn> sipa: Does UTC have DST?
06:53:59 <aristid> merijn: no.
06:54:04 <sipa> no, neither does GMT
06:54:06 <aristid> but GMT doesn't either afaik
06:54:12 <aristid> much like CET doesn't
06:54:20 <merijn> Ah
06:54:24 <aristid> it's just that sweden (and germany) switch from CET to CEST in summer
06:54:41 <merijn> So do the Netherlands, France and Belgium and probably more
06:54:58 <aristid> yeah.
06:55:00 <sipa> and britain switches from GMT to BST
06:56:10 <PhilRod_> as a Brit in America, I find it confusing that *ST is "summer time" back home, but "standard time" here
06:56:43 <merijn> Yeah, but Americans are weird, they can't help it
06:56:50 <Berengal> As a programmer, I find it confusing that we have timezones
06:56:58 <merijn> I concur
06:57:10 <aristid> timezones are OK
06:57:12 <merijn> Also, months of unequal lengths and leap seconds
06:57:12 <stepkut> timezones are awesome
06:57:22 <aristid> but DST sucks
06:57:40 <aristid> merijn: it's relatively sanely possible to ignore leap seconds
06:57:45 <Berengal> merijn: Neither of which are any problem if all time was milliseconds since epoch
06:57:56 <merijn> Berengal: Until we overflow :>
06:58:07 <Berengal> merijn: Add more jiggabits!
06:58:09 <aristid> Berengal: no, then actually leap seconds would be a problem
06:58:14 <sipa> 1.21 jiggabit!
06:58:28 <Berengal> aristid: How so?
06:59:00 <aristid> Berengal: well, POSIX dictates that leap seconds be ignored so you can convert from POSIX seconds since the epoch to days and years
06:59:15 <zygoloid> Berengal: what about relativistic problems? won't somebody please think of the interstellar travellers
06:59:24 <aristid> Berengal: if it was a real second counter, the conversion to days and years would require a leap second table
06:59:51 * zygoloid imagines that within a few hundred years, people will be cursing us for being so shortsighted and storing time as a mere /number/ :)
06:59:59 <blah0o> ??
07:00:02 <merijn> zygoloid: That's not a problem
07:00:04 <blah0o> wtf?
07:00:15 <blah0o> this is actually a real chat?
07:00:20 <merijn> We should all just ditch continuous time and move to something based on Lamport's logical clock
07:00:42 <merijn> blah0o: This is the #haskell IRC channel on FreeNode, yes
07:00:44 <Berengal> aristid: It already does, except the table is applied lower in the stack
07:01:08 <aristid> Berengal: which is very convenient.
07:01:33 <blah0o> lol, k.. was going through the tutorial and landed here.. thought it was gonna show me a prototype or something... wasnt expecting a real irc
07:02:13 <merijn> Oh wait, I suppose we need relative time for planning purposes. So the logical clock won't work...
07:02:56 <Berengal> aristid: It is... when you're still using days and years
07:03:13 <aristid> Berengal: do you sleep at night?
07:03:26 <blah0o> so uhmm... can we only chat about haskell or general topic too?
07:03:39 <Berengal> aristid: Sometimes. Sometimes I sleep during the day
07:03:56 <aristid> blah0o: haskell and related topics
07:03:58 <Berengal> blah0o: Mostly haskell, but we like to digress
07:04:05 <merijn> blah0o: In theory the topic is haskell and related programming issues. But people tend to digress "occasionally", such as now on the topic of timezones :p
07:04:08 <Saizan> not haskell should switch to 
07:04:13 <Saizan> #haskell-blah
07:04:21 <Saizan> if it prevents haskell discussion
07:04:26 <aristid> merijn: i think timezones are somewhat related because it is relevant for programming :)
07:04:30 <merijn> aristid: We were arguing in favor of abandoning days and years in favor of counting seconds
07:04:42 <merijn> Then leap seconds are moot
07:04:46 <aristid> TAI does that
07:05:02 <blah0o> lol, for interest sake, isit possible to create a group? 
07:05:10 <burp> zygoloid: what instead of a number should time be stored as?
07:05:10 <aristid> blah0o: a what?
07:05:13 <blah0o> like #general?
07:05:29 <aristid> blah0o: yes, you can create new channels.
07:05:32 <bss03> So, rem does truncated division, and mod does floored division, maybe we should have (%) do euclidean division.
07:05:41 <aristid> blah0o: read the freenode documentation to know what is required.
07:05:42 <merijn> blah0o: Those already exist, take a look at http://freenode.net/
07:05:53 <blah0o> ah cool
07:05:57 <bss03> Similarly, quot does truncated division, and div does floored division, maybe we should have (//) do euclidean division.
07:06:04 <aristid> bss03: what is euclidean division?
07:06:04 <zygoloid> burp: *shrug* maybe a point in spacetime? :)
07:06:09 <Berengal> burp: a list of seconds and velocity vectors (relative to the velocity of origin)
07:06:10 <burp> zygoloid: oh yes
07:06:19 <burp> you know, special relativity ^^
07:06:26 <merijn> burp: I suggested a logical clock, but that makes planning difficult
07:06:42 <bss03> aristid: Always corresponds to the results of Euclid's division algorithm.
07:06:58 <bss03> aristid: So, remainder is always positive.
07:07:17 <bss03> All defined here: http://en.wikipedia.org/wiki/Modulo_operation#Remainder_calculation_for_the_modulo_operation
07:08:14 <merijn> Positive/negative is irrelevant in the case of modulo
07:08:49 <burp> Berengal: what origin?
07:08:54 <merijn> Because negative numbers are interchangeable with positive numbers
07:09:08 <Berengal> burp: Doesn't matter, as long as it's known and uniform. Same as with epoch
07:09:17 <merijn> -1 mod 5 == 4 mod 5
07:09:35 <Berengal> merijn: 4 mod 5 != 4 mod -5
07:09:51 <merijn> Berengal: Obviously, because you changed the modulo
07:10:01 <bss03> > -1 `mod` 5 == 4 `mod` 5
07:10:02 <lambdabot>   False
07:10:11 <merijn> I meant for the same modolu the remainder is irrelevant
07:10:28 <bss03> > -1 `rem` 5 == 4 `rem` 5
07:10:28 <lambdabot>   False
07:10:43 <merijn> bss03: That's because -1 mod 5 returns -1 in Haskell
07:10:55 <merijn> But -1 mod 5 and 4 mod 5 are mathematically equivalent
07:11:05 <bss03> merjin: And I'm arguing for a (%) that doesn't return megative numbers.
07:11:09 <merijn> If you are calculating in Z mod p anyway
07:11:32 <ezyang> Are there rules of thumb for taking lazy data structures and making them strict and unpacked? 
07:11:36 <bss03> merjin: Yes, I know that -1 == 4 (mod 5), but that's not what `mod` in Haskell is used for.
07:11:38 <Berengal> bss03: Is euclidean remained the same as fmap fmap fmap abs mod?
07:11:38 <Saizan> > (-1) `mod` 5 == 4 `mod` 5
07:11:39 <lambdabot>   True
07:11:59 <merijn> > (-1) `mod` 5
07:12:00 <lambdabot>   4
07:12:08 <hpc> > -1 `mod` 5
07:12:08 <lambdabot>   -1
07:12:09 <merijn> Curse you, unary minus!
07:12:27 <sshc> I have an IO-like monad type that's like IO except, instead of being able to describe any arbitrary IO, can only describe a certain subset of IO.  I wonder how I could use it (or a transformer version of it) in a stack, perhaps requiring that the base be IO.
07:12:28 <merijn> Biggest Haskell pet peeve...
07:12:32 * hpc is kind of amazed it didn't try to read it as subtraction
07:13:14 <Berengal> sshc: Don't implement liftIO
07:13:20 <hpc> ^
07:13:38 <hpc> write your own version for whatever IO commands you need, then don't expose them
07:13:45 <hpc> er, expose the lift
07:14:01 <hpc> also don't expose the constructor for your monad
07:14:17 <Berengal> For a transformer, just require that the base be a MonadIO, but don't implement it yourself
07:15:11 <copumpkin> sshc: check out http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
07:15:27 <copumpkin> and/or ST, and/or monadic-regions, for ideas
07:15:35 <Eduard_Munteanu> You should have stuff that's IO-ish / ST-ish at the base of the transformers stack, e.g. WriterT over IO, not having a transformer for it.
07:15:58 <sshc> Berengal, copumpkin: Thanks
07:16:29 <sshc> Eduard_Munteanu: I want something along the lines of "StateT Foo (SubIOThingT (IO))"
07:17:16 <Berengal> newtype deriving (NotMonadIO)
07:18:15 <bss03> @let (//%) x y | y < 0 = let (d,m) = divMod x (-y) in (-d, m) | otherwise = divMod x y
07:18:16 <lambdabot>  Defined.
07:18:43 <Eduard_Munteanu> I see, though I'm unsure whether that can break referential transparency in subtle ways.
07:18:48 <Eduard_Munteanu> Like STT does.
07:18:57 <bss03> @let (//) x y = fst $ x //% y
07:18:58 <lambdabot>  Defined.
07:19:08 <bss03> @let (/%) x y = snd $ x //% y
07:19:09 <lambdabot>  Defined.
07:19:13 <hpc> an IO transformer would require unsafe* to escape from it
07:19:16 <hpc> :t runReader
07:19:17 <lambdabot> forall r a. Reader r a -> r -> a
07:19:18 <bss03> > 1 % (-3)
07:19:19 <lambdabot>   (-1) % 3
07:19:26 <sipa> > (-5) `rem` 4
07:19:26 <bss03> > 1 /% (-3)
07:19:27 <lambdabot>   -1
07:19:28 <lambdabot>   1
07:19:37 <sipa> > (-1) `rem` 4
07:19:37 <bss03> > 1 // (-3)
07:19:38 <lambdabot>   -1
07:19:38 <lambdabot>   Ambiguous occurrence `//'
07:19:38 <lambdabot>  It could refer to either `L.//', defined at <loc...
07:19:42 <sipa> > (-1) `div` 4
07:19:43 <lambdabot>   -1
07:19:46 <hpc> :t runReaderT
07:19:47 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
07:20:05 <hpc> yeah, runIOT :: IOT m a -> m a
07:20:29 <hpc> which can only be safe if m is MonadIO
07:20:39 <hpc> but if that's the case, IOT isn't giving you anything
07:21:17 <sshc> I see
07:21:45 <bss03> :t (,,,) <$> fst <*> snd <*> uncurry quotRem <*> uncurry divMod
07:21:46 <lambdabot> forall b. (Integral b) => (b, b) -> (b, b, (b, b), (b, b))
07:21:52 <roelvandijk> Weird question: Is it possible to use template haskell to generate template haskell?
07:22:27 <merijn> roelvandijk: I admire your recklessness :D
07:22:32 <roelvandijk> And is that more or less evil than CPP?
07:22:42 <lunaris> roelvandijk: I think the answer is that it depends
07:22:45 <roelvandijk> merijn: >:-)
07:22:50 <sipa> a single run of CPP is not turing complete
07:22:57 <sipa> so i'd say it's more evil :)
07:22:58 <lunaris> I recently got stuck trying to call typeclass methods at compile time.
07:23:14 <lunaris> Because it always boiled down to requiring a double-splice.
07:23:24 <bss03> ((,,,) <$> fst <*> snd <*> uncurry quotRem <*> uncurry divMod) `fmap` [(x,y) | x <- [3, -3], y <- [2, -2]]
07:23:31 <bss03> :t ((,,,) <$> fst <*> snd <*> uncurry quotRem <*> uncurry divMod) `fmap` [(x,y) | x <- [3, -3], y <- [2, -2]]
07:23:32 <lambdabot> forall a. (Integral a) => [(a, a, (a, a), (a, a))]
07:24:07 <roelvandijk> I think another problem is that I would need at least 3 modules
07:24:21 <aristid> > ((,,,) <$> fst <*> snd <*> uncurry quotRem <*> uncurry divMod) `fmap` [(x,y) | x <- [3, -3], y <- [2, -2]]
07:24:22 <lambdabot>   [(3,2,(1,1),(1,1)),(3,-2,(-1,1),(-2,-1)),(-3,2,(-1,-1),(-2,1)),(-3,-2,(1,-1...
07:24:31 <lunaris> roelvandijk: That's not a problem -- modules are like violence -- if you haven't got enough then you just use more.
07:25:01 <roelvandijk> lunaris: So I can solve any problem by just creating more modules?
07:25:07 <roelvandijk> lunaris: I like that :-)
07:25:15 <lunaris> roelvandijk: No comment :)
07:25:48 <lunaris> roelvandijk: I even tried using hint to evaluate code at compile time.
07:26:02 <lunaris> But that didn't help me (runtime linker errors if I wasn't careful which modules I loaded).
07:26:06 <lunaris> Ah well.
07:26:16 <lunaris> Probably should have just used CPP.
07:26:18 <lunaris> xD
07:26:39 <roelvandijk> lunaris: I already broke haddock
07:27:00 <roelvandijk> lunaris: Combination of type level numbers, type families, CPP, template haskell
07:27:56 <lunaris> Rofl
07:27:59 <lunaris> I never use Haddock
07:28:01 <lunaris> Problem solved.
07:28:08 <lunaris> Comments are the least of my worries :)
07:28:22 <lunaris> God I'm a terrible programmer
07:28:53 <xplat> > let (f . g) x = f (g x) in const 3 . const 2 $ 1
07:28:54 <lambdabot>   3
07:29:16 <roelvandijk> lunaris: Generate comments with template haskell, problem solved! (or created)
07:29:23 <lunaris> Rofl
07:29:28 <lunaris> :i Exp
07:29:38 <lunaris> ... | CommentE [String] | ...
07:29:40 <merijn> Become a professor and make your grad students do all the programming, problem solved!
07:29:55 <lunaris> roelvandijk: I've just written a quasiquoter for comments!
07:30:08 <lunaris> merijn: I'll concentrate on the prerequisites first.
07:30:20 <lunaris> The first rule of tautology club is the first rule of tautology club.
07:30:34 <roelvandijk> lunaris: Now use markov chains to generate comments
07:31:01 <lunaris> roelvandijk: I actually need amortised constant time access to the first and last comments I wrote, so I'm reworking it.
07:31:03 <merijn> roelvandijk: And code! Then use an evolutionary algorithm to determine how close the program is to the one you wanted :>
07:31:15 <lunaris> ... | CommentE (FingerTree Usefulness String | ...
07:31:37 <lunaris> data Usefulness = Helpful | Vital | HereByDragons | ReturnXReturnsX
07:31:49 <lunaris> HereBeDragons*
07:31:57 <lunaris> rebase quick!
07:32:59 <lunaris> roelvandijk: What do you need TH to generate TH for anyway?
07:33:54 <Berengal> lunaris: What do you need lisp macros to generate lisp macros for anyway?
07:34:01 <roelvandijk> lunaris: I have a long list of (phantom) data types, some of them a parametrised with other types (type level numbers)
07:34:10 <roelvandijk> lunaris: Those type level numbers are also generated with TH
07:35:01 <roelvandijk> lunaris: I would like a single TH function that generates both (1) the data type and (2) another TH function which constructs such data types
07:35:03 <lunaris> Berengal: I (personally) don't hear many people complaining about the ``can't splice in same module'' limitation of TH, so I'm wondering how often people need that.
07:35:16 <roelvandijk> lunaris: This is all for convenience so I don't have to type so much
07:35:33 <roelvandijk> lunaris: But now I am also slightly worried for the eventual readers of my code
07:35:40 <lunaris> roelvandijk: Screw them
07:35:40 <Berengal> lunaris: Well, me for one, I'm not complaining about it because I don't use TH, because I can't splice in the same module...
07:35:48 <lunaris> Berengal: :)
07:36:18 <roelvandijk> lunaris: The actual code is used to talk with a microcontroller via direct peeks and pokes
07:36:27 <lunaris> roelvandijk: Awesome.
07:36:29 <roelvandijk> lunaris: All the type level stuff ensures that it is reasonably safe
07:36:32 <Berengal> I see there's some circular logic in my actions... but I don't use TH, so it's not a problem
07:36:56 <lunaris> Berengal: I see there's some circular logic in your actions, but I don't reason using logic, so it's not a problem.
07:37:32 <lunaris> roelvandijk: Got a small HPaste of such a type and the maker function?
07:37:34 <frerich> "In particular, the IO monad has evolved into a ‘sin bin’ that encapsulates every kind of side effect from addFinalizer to zeroMemory." hehe
07:37:45 <frerich> First time I read 'sin bin'.
07:37:45 <lunaris> roelvandijk: If it's the kind of thing you're willing to divulge :)
07:38:43 <roelvandijk> lunaris: Sure, moment
07:42:38 <roelvandijk> lunrais: http://hpaste.org/45463/th_for_the_win
07:43:16 <roelvandijk> lunaris: nT is a TH function which constructs a type level nat
07:43:55 <roelvandijk> lunaris: I use that code to control the pin connect module of an LPC2378 microcontroller
07:44:04 <lunaris> Cool.
07:45:33 <lunaris> roelvandijk: First thing -- could dT line = [t| D $(nT line) |] ?
07:45:46 <lunaris> roelvandijk: Similarly for dE
07:46:52 <roelvandijk> lunaris: Yes, that is what I do now. Bit more typing, but more clear
07:47:22 <roelvandijk> lunaris: There are also some thing which take 2 arguments, and some which take 0
07:48:10 <adorablepuppy> I have MinGW on Windows and I'm trying to install SDL, but it'
07:48:18 <adorablepuppy> it's not working *
07:49:17 <lunaris> roelvandijk: http://hpaste.org/paste/45463/th_for_the_win_annotation#p45464
07:49:24 <lunaris> roelvandijk: Might clear things up.
07:49:34 <adorablepuppy> Through cabal, I should say.
07:49:35 <lunaris> roelvandijk: Not sure it typechecks, but looks about right.
07:50:03 <roelvandijk> lunaris: That is a cool idea! I have a lot of those boring definition lists
07:50:40 <roelvandijk> lunaris: I have about 320 of those instEF splices
07:54:05 <lunaris> roelvandijk: http://hpaste.org/paste/45463/th_for_the_win_annotation#p45465
07:54:11 <lunaris> That also might save some typing
07:54:28 <lunaris> (Excuse lack of Unicode)
07:58:33 <roelvandijk> lunaris: The lack of Unicode is compensated with judicious use of folds
07:59:03 <roelvandijk> lunaris: Your concatMapM idea works with the modified type concatMapM ∷ (Monad m) ⇒ (a → m [b]) → [a] → m [b]
07:59:46 <roelvandijk> lunaris: And because it is a top level splice I can simply write
07:59:49 <roelvandijk> lunaris: concatMapM (\i → instEF 3 i 1 (dT i)) [0..7]
08:00:02 <lunaris> roelvandijk: Yes, sorry, I screwed the type up.
08:00:14 <lunaris> roelvandijk: And yes, you can lose the $()
08:00:17 <djahandarie> Suddenly, unicode.
08:00:38 <djahandarie> I avoid unicode in Agda and it still manages to bite me in Haskell
08:01:52 <roelvandijk> djahandarie: ωhαt αrε you ταlking αβouτ?
08:02:32 <sipa> ɥƃnoɥʇ 'ǝpoɔıun ɥʇıʍ ɟɟnʇs unɟ op uɐɔ noʎ :ǝıɹɐpuɐɥɐɾp
08:02:52 <mauke> Ｉ ｋｎｏｗ， ｒｉｇｈｔ
08:03:13 <FauxFaux> Ⓘ ⓢⓣⓘⓛⓛ ⓟⓡⓔⓕⓔⓡ ⓣⓗⓘⓢ ⓞⓝⓔ.
08:03:54 <sipa> ẁốẅ, ì ďŏņ'ţ ķņơẃ ţĥǎŧ óňē
08:04:39 <mauke> I ᴄᴀɴ'ᴛ ʀᴇᴀᴅ ᴛʜᴀᴛ
08:04:56 <roelvandijk> :-)
08:05:24 <roelvandijk> Ok, time to go home so I can code on my personal Haskell stuff
08:05:34 <roelvandijk> Bye
08:15:26 <webuser1> @pl f x = complement x
08:15:27 <lambdabot> f = complement
08:15:43 <webuser1> @pl f x = complement . f (complement x)
08:15:43 <lambdabot> f = fix (((complement .) .) . (. complement))
08:16:13 <Jafet> @vixen ooh, flip my bits!
08:16:14 <hpc> heh
08:16:38 <lambdabot> Plugin `vixen' failed with: thread killed
08:17:30 <xplat> ℴℎ ℳℽ ⅁ℴⅆ ʬℎÅ₮  Å℞℮ ℽℴ℧ ℊ℧ℽ$ ⅆℴℹℼℊ‽
08:17:56 <hpc> @vixen nice crash...
08:17:56 <lambdabot> bad is better than nice ;)
08:18:31 <luite_> xplat: that's pushing the limits of readability :)
08:18:36 <adorablepuppy> :') I got my first real haskell program working.
08:18:57 <luite_> what does it do?
08:19:25 <adorablepuppy> reads a bitmap into a list of Pixels, then parses the pixels for color values for input. 
08:19:40 <adorablepuppy> Basically I'm hiding hex codes in the bitmaps.
08:19:58 <hpc> ooh, fun
08:20:29 <navaati> stenography, eh ?
08:20:32 <adorablepuppy> I'm making a game where magic is based on sigils the player has to draw themselves (with assistance, of course)
08:21:53 <luite_> navaati: steganography
08:22:16 <adorablepuppy> But the player will literally have the ability to do almost anything inside the game world by commands through the bitmaps. Changing it around them. Of course, they'll need a certain level of willpower to cast a spell from any given sigil, which will be calculated from the complexity of the data inside.
08:22:30 <xplat> luite_: ℹ ℎÅ℣℮ ℽℴ℧℞ ⅆℴℊ
08:23:59 <xplat> luite_: also, i think navaati was just as close the first time :)
08:29:06 <adorablepuppy> Silly question here probably. I want to make this game in haskell, using SDL. But I want the users to receive a compiled form of the game, the exe. Is it possible to allow a user to write their own scripts and have them interpreted through the exe somehow, without having haskell installed?
08:29:07 <solistic> Does anybody know I can work with a Module in ghci that uses macros from cabal_macros.h?
08:29:24 <xplat> adorablepuppy: haskell scripts?
08:29:40 <xplat> you could compile in hint or something
08:29:41 <adorablepuppy> xplat: Preferably. Everyone does lua, but I want to do haskell.
08:31:03 <adorablepuppy> xplat: Thanks, I didn't know about hint.
08:31:06 <Eduard_Munteanu> Or embed an EDSL.
08:31:44 <adorablepuppy> hmm
08:31:57 <gio123> Eduard_Munteanu:?
08:32:01 <xplat> the acronym EDSL should never be used
08:32:04 <Eduard_Munteanu> How likely it is your users could deal with Haskell?
08:32:25 <djahandarie> http://hackage.haskell.org/package/plugins-1.5.1.4 could also be of use
08:32:28 <adorablepuppy> Eduard_Munteanu: No idea.
08:32:38 <thoughtpolice> adorablepuppy: if you just want scripts, you can use hslua on hackage. it comes with a copy of lua in the distribution, so it has no outside dependencies
08:32:41 <Eduard_Munteanu> xplat: why?
08:32:42 <xplat> it covers the same range of meanings as DSL, but people will think you mean something more specific and half the time they'll get burned
08:32:51 <djahandarie> Oh, if it's not Haskell users writing this stuff, use Lua or something
08:32:52 <Eduard_Munteanu> Ah.
08:33:21 <djahandarie> xplat, DSL can mean an entirely different language though. EDSL usually implies that Haskell is the host language
08:33:31 <adorablepuppy> thoughtpolice: I'll look into it. Though I did want to use haskell. However, it seems most players should be able to use lua easily, so I might have to settle.
08:34:06 <adorablepuppy> Maybe I'll offer both
08:34:33 <xplat> djahandarie: see, if you mean 'embedded dsl' rather than 'external dsl' you're off point
08:35:23 <djahandarie> xplat, huh? I don't ever think I've seen the acronym mean the latter
08:35:34 <xplat> djahandarie: i think for most people lua is still in the 'learn this annoying language just to script this stupid app' range
08:36:27 <thoughtpolice> from what i've used, lua is really quite a nice language. it's purpose is education and to be a lightweight way to script things.
08:37:11 <xplat> most people don't know any programming language, but for people who do knowing python or ruby is more likely.  unfortunately they are much more heavyweight to embed :(
08:37:25 <thoughtpolice> and with luajit, it's also incredibly fast (and oh man, is the info:line ratio in the luajit source code insane)
08:37:43 <adorablepuppy> The target for the scripting languages will be modders of course. For regular users, the regular game should be good enough.
08:38:00 <navaati> is it possible to restrain the range of values an arrow operates on ?
08:38:00 <navaati> So "Programm a b" will be an instance of "Arrow a b" where a and b are instances of a particular typeclass
08:38:06 <thoughtpolice> lua seems like the perfect fit then. 0 outside dependencies for one, and easy to embed
08:38:13 <xplat> oh, or JS.  which also has fast engines, although not as lightweight
08:38:28 <thoughtpolice> luajit pretty much destroys every JS engine out there i think
08:38:39 <xplat> actually JS is probably the most likely language for people to know, even though it sucks
08:38:40 <thoughtpolice> luajit's interpreter is like 3x faster than v8's actual compiler
08:38:56 <adorablepuppy> thoughtpolice: I think you're right. I'll think on it more, I'm nowhere near the point to even enable modding yet.
08:39:24 <xplat> thoughtpolice: how is luajit so fast?
08:39:31 <thoughtpolice> not sure what the difference is with the new v8 crankshaft stuff. mike pall put an insane amount of work into luajit in order to get the design right, and furthermore, lua is from what i can tell, not such a crappy language
08:39:44 <thoughtpolice> xplat: mike said it himself it's nothing super-special, it just has a lot of attention to detail. everywhere.
08:40:07 <thoughtpolice> xplat: but for one, luajit's interpreter is actually written in assembly.
08:40:32 <thoughtpolice> that's why it's so fast, even on platforms that don't support lj's JIT backend
08:40:35 <xplat> thoughtpolice: that doesn't seem very portable.
08:40:59 <thoughtpolice> xplat: no. mike actually is sponsored by lots of companies to implement support for their CPUs however
08:41:13 <thoughtpolice> the regular lua source code is in fact extremely portable. luajit at least depends on it having support for your CPU architecture
08:41:26 <thoughtpolice> and on some platforms, JIT compilation isn't supported (sponsors don't need/want/can't have it)
08:41:39 <deech> Hi all, I have a web application that I am trying to test by slamming it with 'n' requests. I'd like to write a Haskell test that spawns off 'n' threads, but only fires them when they're all ready. I was thinking of having them all wait in a 'retry' loop on an STM variable. Is this a good strategy?
08:42:36 <adorablepuppy> I'll have to check their supported platforms, portability is key.
08:42:38 <thoughtpolice> xplat: it seems to be part of the way mike set up the project. he makes proposals for concrete, implementable things, and lots of companies tend to pay him for the ports. i believe qualcomm is paying for an ARM port, google paid for the x86_64 port, some anonymous company paid for PPC support, etc.
08:42:44 <xplat> thoughtpolice: it sounds like lua's advantage here is less 'doesn't suck' and more 'is so minimal that implementing a dozen different full interpreters from scratch is acceptable overhead'
08:42:47 <thoughtpolice> adorablepuppy: just use lua if it's that huge of a problem.
08:43:04 <adorablepuppy> not a problem, more like a desire.
08:43:59 <xplat> deech: no
08:44:04 <thoughtpolice> xplat: maybe. mike has done a hell of a lot of design work though, and the result is a ridiculously fast implementation and the fast interpreter is one of the key points
08:44:22 <djahandarie> thoughtpolice, does the debian shootout thing use luajit?
08:44:26 <thoughtpolice> yeah
08:44:30 <thoughtpolice> it has regular lua and luajit
08:44:36 <thoughtpolice> i don't know if it's using the latest luajit2 beta
08:44:54 <xplat> deech: the current STM implementation doesn't deal well with thundering herds afai have heard
08:44:57 <adorablepuppy> luajit seems to be supported on all my target CPUs, so it seems it won't be a problem. It's even on PPC.
08:45:28 <djahandarie> Ah, it was only on one of the boxes
08:45:29 <deech> xplat : So what's the best way of ensuring that the threads all fire off at once.
08:45:38 <thoughtpolice> xplat: http://lua-users.org/lists/lua-l/2009-11/msg00089.html
08:45:47 <thoughtpolice> ^^ some of the thought mike put into it.
08:46:25 <thoughtpolice> it's actually a pretty non trivial implementation honestly. there's not a ton of original work, mike just pulled all the existing research and did a lot of design/testing
08:46:37 <xplat> deech: although maybe it would work in your case because 'read one variable and if it's not true retry' is so simple and only reads.  it might be worth a try to see if it works well enough, if you're already comfortable with STM and not the other concurrent stuff
08:46:49 <thoughtpolice> something like, 3 years of research before he released the first public version of luajit2
08:47:06 <thoughtpolice> (1 year of actual implementation tweaks etc)
08:47:21 <djahandarie> Yeah, seems to use luajit 2.0.0-beta6
08:47:30 <djahandarie> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=luajit&lang2=ghc
08:47:39 <deech> xplat : I am comfortable with STM. But are there other concurrent libraries that are better?
08:47:42 <thoughtpolice> ISTR at one point luajit2 was actually getting really close to fortran on some of the shootout benchmarks
08:47:47 <mun_> hi
08:47:58 <companion_cube> wow, that's impressive
08:48:13 <deech> thoughtpolice : Do all the existing lua libraries work with LuaJIT?
08:48:52 <thoughtpolice> deech: it's ABI and API compatible with the existing lua source code in all ways
08:49:05 <thoughtpolice> you can actually force your LD_LIBRARY_PATH to look at luajit.so instead of lua.so and it'll "just work"
08:49:10 <deech> thoughtpolice: what's ABI?
08:49:24 <mun_> For 2 functions, such that f(a,b) = g(b,a), how can the relationship between f and g be described? they don't share the same type.. they take permuted arguments though. is there a term for this?
08:49:26 <thoughtpolice> deech: the application binary interface, basically the interface the binary code exports
08:49:33 <thoughtpolice> (so you can call it from other code)
08:50:13 <jmcarthur> woah, luajit is that fast? holy crap
08:50:18 <thoughtpolice> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=luajit&lang2=v8 < yeah, pretty much destroys V8
08:50:24 <deech> thoughtpolice: neat, it's probably been discussed but there is a working (if not full-featured) binding to Haskell.
08:50:28 <thoughtpolice> jmcarthur: yes. it's ridiculously fast.
08:51:01 <ksf> can someone give me some hints as to why {->,_|_} is minimally functionally complete?
08:51:10 <ksf> or, rather, funcitonally complete at all?
08:51:15 <ksf> -> and not is quite clear.
08:51:17 <xplat> deech: the other concurrent libs are not so much 'better' as 'better for some use cases'
08:52:08 <ksf> erm, wait, nvm.
08:52:14 <djahandarie> mun_, wouldn't this just be flip?
08:53:01 <mun_> djahandarie, is "flip" the proper way to describe the relationship between f and g?
08:53:16 <Taslem> If a program could parse, optimise, and obfuscate Haskell and the interpret it at run-time by being run by another program... Would it be a fully-functioning compiler?
08:53:17 <ksf> not x = _|_ -> x
08:53:31 <mun_> djahandarie, also, in a more general case, e.g., f(a,b,c) = g(c,a,b), etc. these aren't just flips, right?
08:53:32 <ksf> nonsense.
08:53:50 <djahandarie> mun_, what context is this? A Haskell program?
08:53:53 <xplat> ksf: not x = x -> _|_
08:53:53 <ksf> not x = x -> _|_
08:54:05 <mun_> djahandarie, just in the general logical context.
08:54:44 <xplat> mun_: the types of those functions are isomorphic, and the functions are related by the isomorphism
08:55:44 <djahandarie> Two functions having isomorphic types can mean more than just permuted arguments though
08:56:09 <mun_> what other implications are there?
08:56:34 <xplat> djahandarie: sure, but the most useful generalization can be more important than the minimal generalization
08:59:40 <mun_> xplat, so why aren't 2 functions taking permuted arguments necessarily isomorphic?
08:59:43 <djahandarie> mun_, basically, given a : A, b : B, if you have a function f : A->B, and another function g : B->A, f . g = g . f = id
08:59:55 <djahandarie> Then those two functions are isomorphic
08:59:59 <djahandarie> Erm
09:00:09 <djahandarie> Then the types of a and b are isomorphic
09:01:30 <djahandarie> So A -> B -> C and B -> A -> C are isomorphic if we let f = g = flip
09:02:40 <djahandarie> But this notion certainly covers far more than just permuted arguments
09:04:41 <mun_> djahandarie, i see that f:A->B and g:B->A case because g is the inverse of f, so f . g = g . f = id.
09:04:42 <xplat> mun_: 2 functions taking permuted arguments are necessarily related by an isomorphism, but so are, say, a function taking two arguments by currying and a function taking two arguments as a pair
09:05:01 <mun_> djahandarie, but if f :: A -> B -> C and g :: B -> A -> C, why is f . g = id?
09:05:09 <djahandarie> mun_, don't change f and g.
09:05:13 <djahandarie> mun_, we're changing a and b.
09:05:29 <xplat> mun_: they are related by the isomorphism 'uncurry/curry'
09:05:36 <djahandarie> f and g are describing the function required for A and B to be isomorphic
09:06:03 <xplat> mun_: just like in your first example they are related by 'flip/flip'
09:06:40 <xplat> mun_: djahandarie's f, g, A, and B refer to different items than yours
09:07:35 <djahandarie> a : A -> B -> C,  b : B -> A -> C;  f = g = flip : forall a b c. (a -> b -> c) -> b -> a -> c
09:08:46 <xplat> mun_: in the case of your example, his A is your 'A -> B -> C', his B is your 'B -> A -> C', his f is 'flip', his g is also 'flip'
09:10:21 <mun_> right. let me digest this...
09:10:23 <djahandarie> a : (a, b) -> b,  b : a -> b -> b, f = curry : forall a b c. ((a, b) -> c) -> a -> b -> c, g = uncurry : forall a b c. (a -> b -> c) -> (a, b) -> c
09:10:29 <djahandarie> Damn notation
09:10:38 <djahandarie> Ah fuck, meant to use concrete types for a and b
09:10:43 <xplat> afk for lunch
09:10:49 <djahandarie> a : (A, B) -> B,  b : A -> B -> B, f = curry : forall a b c. ((a, b) -> c) -> a -> b -> c, g = uncurry : forall a b c. (a -> b -> c) -> (a, b) -> c
09:11:51 <djahandarie> a and b are two types. f and g prove that they are isomorphic
09:13:29 <mun_> aah. i get it now.
09:14:25 <djahandarie> I'm being sloppy. a and b are two values. f and g prove that a and b's types are isomoprhic.
09:14:43 <mun_> thanks for that
09:15:27 <mun_> it seems that "isomorphic functions" types is broader than "functions taking permuted arguments"
09:15:35 <djahandarie> Yes, as noted.
09:16:02 <mun_> yeah.
09:16:38 <djahandarie> I think xplat was trying to say that the notion of 'permuted arguments' isn't particular useful.
09:16:57 <djahandarie> While the notion of an isomorphism (which subsumes permuted arguments) is very useful
09:17:32 <mun_> djahandarie, why is isomorphism so useful?
09:17:36 <deech> djahandarie:  OT: I saw your username on bash.org's Top 100 a while ago.  Was that you?
09:18:34 <Eduard_Munteanu> mun_: generally because you can have laws/results/theorems that hold for things which are isomorphic.
09:18:55 <Eduard_Munteanu> It's also a way to say two things are equivalent in some sense.
09:19:31 <mun_> Eduard_Munteanu, i see. but are they equivalent or "inversed"?
09:20:12 <Eduard_Munteanu> They're not the *same*, but you can easily make one into the other.
09:20:17 <djahandarie> mun_, isomorphic is often what people mean when they say "equivalent".
09:20:30 <djahandarie> I.e., you can change A into B after doing something, not that A = B.
09:20:41 <mun_> i see.
09:20:41 <djahandarie> (And B into A)
09:21:09 <Eduard_Munteanu> Here's an example...
09:21:15 <djahandarie> deech, yeah
09:21:43 <deech> djahandarie: Awesome. 
09:21:44 <Eduard_Munteanu> data Pair a b = Pair a b   vs   (a, b)
09:22:21 <Eduard_Munteanu> Every function that works on (a, b) can easily be made to work on Pair a b.
09:23:54 <Eduard_Munteanu> Or... Either a a vs data MyEither a a = MyEither Bool a
09:24:03 <Eduard_Munteanu> They're not the same thing, but equivalent.
09:54:53 <zzzzzbogus> hello! what is the current home of hoopl? the git repo is dead, and the hackage version is outdated.. or they are not?
09:56:24 <lars9> simon python's suggestions to record type 8 years ago: http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
09:56:27 <lars9> i like it
09:57:13 <lars9> and appearantly not implemented in haskell yet.
09:57:45 <nyingen> lol python
09:58:19 <xplat> lambdacats are cuter than lolpythons
09:58:27 <aristid> lars9: it's custom to write just spj, so his name is easier and shorter to write :)
09:59:12 <lars9> my mind was thinking pyton and my figures were just typing python
09:59:58 <xplat> i can hasssssssss whole pig ssssssandwich?
10:00:03 <Taslem_> I was thinking, and a good way to make developing on Windows better with Haskell would be if there was an interpreter/compiler in Java that could use Java Classes/Jars for accessing new input/output modules.
10:00:58 <xplat> Taslem_: or you could just use scala
10:01:18 <nyingen> good old scala
10:01:27 <nyingen> the language I keep trying to convince myself to learn
10:01:28 <luite_> Taslem_: hey did you get glut32 to work? I can give an url to a glut32.dll file, that you can put in your cabal bin directory, and then it might just work
10:02:15 <Taslem_> I actually gave up on it, I was too annoyed...  I could try getting a copy of Glut32 and putting it in cabal.
10:02:18 <Taslem_> Could you link me?
10:02:59 <luite_> Taslem_: http://jabberwock.xs4all.nl/glut32.dll
10:03:47 <luite_> Taslem_: put it in the cabal bin dir, i.e. the dir where gloss-tree.exe ends up after you do > cabal install gloss-examples
10:03:48 <xplat> (i like haskell better than scala, but i don't think haskell could ever be as good at java interop as scala is)
10:05:07 <Taslem_> THANKS! It works! So happy!
10:05:14 <xplat> and JVM is not exactly a premier environment for developing on windows either.  CLR maybe.
10:05:18 <Taslem_> And then, I just distribute the exe with the Glut in the same file?
10:05:23 <Taslem_> *folder
10:05:50 <Taslem_> By the way... What are the .hi and .o files that are generated when I compile?
10:06:06 <luite_> Taslem_: yeah, but as long as the glut32.dll file is somewhere in your %PATH%, you don't need to have it in the same folder
10:06:15 <luite_> but yes, if you distribute it to others, you need to include the file
10:06:21 <Taslem_> Thought so.
10:06:32 <xplat> .hi is a binary file describing the interface of your .hs file, .o is the actual code.
10:06:41 <luite_> .o is an object file, similar to what you get from gcc
10:06:46 <luite_> .hi is the binary interface file
10:06:46 <Taslem_> Oh, and the exe just sort of parses the two?
10:06:56 <xplat> (.hi can contain code too, but specifically for the purpose of inlining)
10:07:06 <luite_> the exe is built by linking the .o files together
10:07:18 <luite_> combined with runtime stuff and libraries :(
10:07:24 <luite_> err, :)
10:07:55 <Taslem_> Well, glad I got graphics. Now I can actually make something USEFUL. And/or distracting and pointless. :D
10:08:18 <xplat> runtime stuff and libraries :◗
10:08:29 <Taslem_> When I closed the program, there was an error. What caused that and how can I fix it?
10:09:06 <luite_> yeah I noticed the same problem with a different freeglut dll, fryguybob did too, with the same file as you used
10:09:43 <Taslem_> Happen to know the issue? Did you figure out how to correct it? Is there an uncaught exception or something?
10:09:53 <luite_> some other opengl programs don't have the problem, possibly just a matter of properly handling the window close event
10:10:06 <luite_> sorry, don't know
10:10:11 <Taslem_> Hm, okay.
10:10:18 <luite_> it seems to end up in an infinite loop
10:10:26 <Mekanik> 0
10:10:54 <Taslem_> Think this is it? "Window close callback "
10:11:28 <luite_> sorry, really don't know, I just installed gloss yesterday to see if i could get it to work on windows
10:11:29 <Taslem_> "type CloseCallback = IO () "  "closeCallback :: SettableStateVar (Maybe CloseCallback) "
10:11:36 <Taslem_> Hm, okay.
10:11:37 <luite_> havent actually used it at all
10:12:01 <Taslem> Actually, from the look of this, it's actually standard to GLUT, not neccesarily Gloss.
10:12:16 <Cin> ‘Phew, that was a close callback…’
10:13:13 <luite_> Taslem_: have you been able to install cairo by the way?
10:13:16 <Taslem> Har har. Can you be any actual help on the issue? :P
10:13:29 <Taslem> I did not manage to install Cairo, no.
10:13:43 <Taslem> This is the first time I've gotten any package running from cabal or otherwise.
10:14:01 <luite_> oh how far did you get? did you extract the .zip archive I linked, and add its bin directory to your %PATH%?
10:14:35 <Taslem_> I can't remember.
10:15:52 <luite_> oh ok, no problem. feel free to ask if you want to install it later. some interesting packages use cairo, and you probably want gtk if you want to write programs with buttons and other widgets and stuff :)
10:16:06 <sipa> ;;bc,blocks
10:24:30 <magicman> "fail" in RWST uses the "fail" method of the Monad instance inside, yes?
10:29:47 <applicative> magicman: that seems to follow from the monad instance, no?     fail msg = RWST $ \_ _ -> fail msg
10:30:43 <applicative> where the unmtl of RWST is r -> s -> m (a, s, w)
10:30:58 <applicative> @untml RWST
10:30:58 <lambdabot> Maybe you meant: unmtl unpl
10:31:06 <applicative> @unmtl RWST
10:31:06 <lambdabot> err: `RWST' is not applied to enough arguments, giving `/\A B C D E. A -> C -> D (E, C, B)'
10:31:10 <applicative> ggggrrrrrrr
10:31:50 <copumpkin> @unmtl RWST a b c
10:31:50 <lambdabot> err: `RWST a b c' is not applied to enough arguments, giving `/\A B. a -> c -> A (B, c, b)'
10:31:55 <copumpkin> @unmtl RWST a b c d e
10:31:56 <lambdabot> a -> c -> d (e, c, b)
10:33:28 <magicman> applicative: It could've used the "error s" thingy, but that wouldn't make much sense if the underlying Monad knows how to do proper failure.
10:33:31 <magicman> But thanks :)
10:35:38 <taktoa> does anyone know of a function that will swap out an element of a list for another datum
10:36:12 <taktoa> like, if you did "func 5 3 [1, 2, 3, 4, 5, 6]
10:36:16 <taktoa> it would output
10:36:27 <taktoa> [1, 2, 5, 4, 5, 6]
10:36:51 <taktoa> swap out the third element of the list for "5"
10:37:50 <rothwell> how do i uninstall cabal packages?
10:37:54 <rothwell> don't see an obvious option to do it
10:38:18 <Taslem> @pl (\a b -> f a (f2 b))
10:38:18 <lambdabot> (. f2) . f
10:39:25 <Jafet> rothwell, ghc-pkg unregister then rm
10:40:30 <applicative> rothwell: I just ghc-pkg unregister them , then when a new ghc comes out I blow up the past completely
10:40:51 <rothwell> silly question, but how do i know what to rm?
10:41:12 <taktoa> in other words, set a given element of a list
10:41:22 <Jafet> rothwell, ghc-pkg describe
10:41:25 <fryguybob> > let f x n = uncurry (++) . second (x:) . (take (n-1) &&& drop n) in f 9 3 [1,2,3,4,5]
10:41:27 <lambdabot>   [1,2,9,4,5]
10:41:46 <rothwell> Jafet: thanks
10:41:53 <rothwell> applicative: i'm a fan of the nuke and pave approach
10:42:01 <rothwell> i wish OS package managers would take the same approach...
10:42:17 <Jafet> That's called Microsoft Windows.
10:42:25 <rothwell> hehe
10:42:47 <jamwt> hmm.. if I wanted a to block in a forkIO thread on either network recv() or, say, a Chan , is there any way to do such a thing?
10:43:20 <magicman> > let f x n = uncurry (++) . second (x:) . (take (n-1) &&& drop n) in f 9 3 [1,2]
10:43:21 <lambdabot>   [1,2,9]
10:43:27 <fryguybob> > let f x 1 (a:as) = x:as; f x n (a:as) = a : f x (n-1) as in f 9 3 [1,2,3,4,5]
10:43:27 <lambdabot>   [1,2,9,4,5]
10:43:52 <Jafet> That modified the third element, not element 3
10:44:38 <aristid> > let f x 0 (a:as) = x:as; f x n (a:as) = a : f x (n-1) as in f 9 3 [1,2,3,4,5]
10:44:39 <wlangstroth> what's the &&& operator?
10:44:39 <lambdabot>   [1,2,3,9,5]
10:44:57 <aristid> Jafet: better? :P
10:45:02 <azaq23> @src (&&&)
10:45:02 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
10:45:16 <aristid> arr is evil
10:45:17 <taktoa> aristid: looks good
10:45:22 <magicman> (f &&& g) a = (f a, g a)
10:45:34 <Jafet> modifyAt f n xs = let (i,(x:t)) = splitAt n xs in i ++ [f x] ++ t
10:45:42 <wlangstroth> ah, thanks
10:46:09 <Jafet> > let modifyAt f n xs = let (i,(x:t)) = splitAt n xs in i ++ [f x] ++ t in modifyAt (const 9) 3 [1..5]
10:46:11 <lambdabot>   [1,2,3,9,5]
10:46:24 <Jafet> > let modifyAt f n xs = let (i,(x:t)) = splitAt n xs in i ++ [f x] ++ t in modifyAt (const 9) 10 [1..5]
10:46:25 <lambdabot>   *Exception: <interactive>:3:26-49: Irrefutable pattern failed for pattern (...
10:47:53 <aristid> :t let modifyAt f n xs = case splitAt n xs of (i,[]) -> i; (i,(x:t)) -> i ++ [f x] ++ t in modifyAt
10:47:54 <lambdabot> forall a. (a -> a) -> Int -> [a] -> [a]
10:48:13 <aristid> > let modifyAt f n xs = case splitAt n xs of (i,[]) -> i; (i,(x:t)) -> i ++ [f x] ++ t in modifyAt (const 9) 10 [1..5]
10:48:15 <lambdabot>   [1,2,3,4,5]
10:48:53 <Taslem> How do you define fromInteger?
10:49:23 <Taslem> fromInteger x = P (x,0)        P is of the type (Float,Float) -> NPoint.
10:50:08 <byorgey> I think you want  fromInteger x = P (fromInteger x, 0)
10:50:22 <byorgey> x is an Integer so you need to convert it to a Float
10:50:23 <Taslem> Oh, thanks.
10:59:29 <Taslem> Is there a built-in function that takes a list of function, and an argument, and applies that argument to all the functions in the list?
10:59:56 <byorgey> > map ($ 3) [succ, pred, (^2)]
10:59:57 <lambdabot>   [4,2,9]
11:00:37 <djahandarie> Taslem, change your question to this: is there a function that takes a list of functions, and a function (a -> b) -> b and applies it, then the answer is yes. ;)
11:00:51 <djahandarie> And that function is map
11:00:51 <byorgey> so mapArg fs arg = map ($arg) fs
11:01:30 <djahandarie> You have a list of (a -> b), and a function (a -> b) -> b. Clearly, map will get you a list of bs.
11:02:05 <Taslem> Oh, right.   You'd do map ($ arg) functions
11:08:25 <copumpkin> > flip [succ, pred, (^2)] 4
11:08:26 <lambdabot>   [5,3,16]
11:08:34 <copumpkin> > sequence [succ, pred, (^2)] 4
11:08:35 <lambdabot>   [5,3,16]
11:08:45 <copumpkin> flip == sequence, QED
11:09:21 <copumpkin> Taslem ^
11:09:26 <Jafet> @check \x -> flip x == sequence x
11:09:27 <lambdabot>   Couldn't match expected type `[m a]'
11:09:57 <copumpkin> pff
11:10:07 <warzl> so I'm thinking maybe the reason that companies with big messy imperative code bases don't refactor is because imperative code is too hard to refactor
11:10:09 <copumpkin> they are clearly equal
11:10:50 <copumpkin> warzl: I work for a company and just refactored a big messy imperative codebase into a nice, elegant, more featureful, (almost) purely functional one
11:11:07 <copumpkin> and faster
11:11:21 <warzl> where do you work?
11:11:28 <warzl> sounds like a good place
11:11:40 <copumpkin> http://www.clarifi.com/
11:11:59 <dons> ocaml?
11:12:04 <copumpkin> scala
11:12:08 <warzl> what language did you refactor from and to?
11:12:11 <dons> ah
11:12:18 <copumpkin> java to (haskell-like) scala
11:12:23 <dons> heh
11:12:26 <copumpkin> lots of iteratees, reducers, and associated goodness
11:12:33 <warzl> that's awesome
11:12:41 <nyingen> copumpkin: how big was the codebase?
11:12:48 <copumpkin> plus, edwardk gives weekly category theory seminars
11:13:27 <copumpkin> nyingen: well, we didn't change the whole thing over yet. This is a piece of it that our parent company uses too, but it was around 15k lines of java iirc. It's about 1/10 of that in scala
11:13:33 <nyingen> I would love to do something similar to this project I'm working on (which I mostly didn't write), but it's 250kloc :(
11:13:38 <copumpkin> it was quite satisfying getting rid of all the java
11:13:44 <warzl> hehe
11:13:47 <nyingen> I can imagine
11:13:47 <warzl> I bet
11:13:52 <rothwell> copumpkin: i might do the exact same thing
11:14:14 <warzl> the scenario I had in mind was a refactoring half million line C++ codebase to C++
11:14:28 <warzl> from god awful C++ to bearable C++
11:14:32 <Eduard_Munteanu> djahandarie: btw, did edwardk get around to posting those vids?
11:14:36 <djahandarie> Eduard_Munteanu, no
11:14:39 <warzl> I just don't know if such an undertaking is practical
11:14:40 <Eduard_Munteanu> Now, that copumpkin mentioned those seminars.
11:14:41 <Eduard_Munteanu> Ah.
11:14:46 <rothwell> i'd only be going from 30k lines of java
11:15:03 <djahandarie> We have a short video of derek talking about fibrations too
11:15:15 <djahandarie> Which I don't think he even knows we took
11:15:26 <warzl> and it would explain why we only make the code worse instead of fixing it
11:15:32 <monochrom> warzl's statement is still right with the implicit assumption "don't change language"
11:16:04 <monochrom> if you change language you can make magic
11:16:06 <warzl> and 30k lines is really small
11:16:17 <warzl> (at least in C-family languages)
11:16:38 <rothwell> yeah, it's annoying... java makes everything so huge
11:16:41 <rothwell> it's not a large program
11:16:45 <rothwell> source is just bulky
11:16:52 <nyingen> even 250kloc doesn't feel all that big, but there are so, so many dark corners and needless verbosity
11:16:52 <warzl> where I work you could never get people to but into another language
11:17:07 <warzl> so true
11:17:16 <warzl> it's a big ball of mud in every sense
11:17:51 <nyingen> I've thought about rewriting some modules in scala, especially some parts that do graph-building and traversal, but I haven't gotten the impression that mixing Scala and Java in such a large project would work well 
11:17:59 <rothwell> this one's in good shape... is just annoyingly big for what it is
11:18:23 <warzl> I've never seen a commercial code base in good shape myself
11:18:29 <warzl> makes you wonder if it's even possible
11:18:50 <wlangstroth> warzl: it's possible, it's just slow going
11:19:17 <rothwell> have to have people that are willing to say "no" to stupid additions, too
11:19:26 <warzl> nice code would make a huge difference in quality of life
11:20:18 <warzl> nothing worse than spineless developers >:)
11:21:44 <rothwell> in other news... http://imagebin.org/index.php?mode=image&id=147197
11:21:51 <copumpkin> clueless loud developers are probably worse
11:21:58 <copumpkin> lucky we don't have any :D
11:22:06 <copumpkin> or none that I've encountered
11:22:13 <rothwell> the clueless ones always seem to be loudest
11:22:55 <osoleve> what do i do if i cabal-install a package, but ghc can't find it?
11:23:21 <dons> osoleve: hmm. might not have installed
11:23:23 <dons> check ghc-pkg list
11:23:44 <monochrom> clueless and loud are highly correlated
11:23:54 <osoleve> it's in the list
11:24:04 <osoleve> should i try to reinstall and see what happens?
11:24:27 <monochrom> some proverb says the empty bottle is the loudest (when you hit it with a stick)
11:24:43 <rothwell> that's familiar...
11:24:59 <osoleve> i restarted ghci and it worked, nevermind
11:25:44 <monochrom> people go the reinstall route too wantonly. it causes more cabal problems not fewer
11:26:23 <tromp_> :t sequence
11:26:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:27:45 <dons> osoleve: if its in the list, ghci prob. just needs to be restarted
11:27:49 <dons> ah 
11:27:51 <dons> yes. :)
11:27:57 <tromp_> is there a definition of divisors somehwere?
11:29:16 <monochrom> a crazy proposal: some of the trust-the-human cabal commands (--force, --reinstall, etc) should be guarded by one of two protection mechanisms: the user chooses one of:
11:29:54 <monochrom> 1. take an exam on unix/windows/mac system administration, ghc-pkg database internals, and cabal internals
11:30:20 <monochrom> 2. an authorization code obtained from and digitally signed by dcoutts
11:30:29 <opqdonut_> :D
11:30:52 <Eduard_Munteanu> Mmm --reinstall is mostly harmless, I think.
11:31:22 <monochrom> seriously if you haven't even read my http://www.vex.net/~trebla/haskell/sicp.xhtml you do not even know what --reinstall gets you
11:31:38 <aristid> monochrom: or better yet, make them safe.
11:31:40 * Eduard_Munteanu looks
11:32:01 <monochrom> the way to safety is to not trust humans
11:32:38 <monochrom> seriously what's so safe about --force?
11:32:45 <aristid> and that does not require involving exams or approval by a superior
11:33:17 <monochrom> as for --reinstall, that's safe for c libs because of stable ABI, but unsafe for ghc libs because of unstable ABI
11:33:20 <aristid> well, most cabal commands are safe insofar as you can just delete ~/.ghc and re-install everything
11:33:29 <Eduard_Munteanu> IDK, I thought using --reinstall to get profiling libs or change optimization flags was rather safe :/
11:33:52 <quantum> How do I make haskell work in a different base?
11:33:58 <aristid> quantum: ?
11:33:59 <quantum> I want numbers in base 12
11:34:05 <quantum> all through out haskell
11:34:09 <dons> quantum: you want to print numbers in base 12?
11:34:13 <dons> or write literals in base  12?
11:34:14 <tromp_> my program uses import Primes, and the compiler bombs with Primes.hs:1:0: File name does not match module name: Saw: `Main' Expected: `Primes'
11:34:15 <aristid> > 0o10
11:34:16 <lambdabot>   8
11:34:19 <quantum> all literals printed and read in base 12
11:34:27 <dons> use the "Numeric" module
11:34:31 <quantum> thanks
11:34:34 <quantum> how do I get that
11:34:35 <aristid> quantum: you can use 0oXYZ
11:34:41 <aristid> import Numeric
11:34:46 <aristid> but that doesn't change your literals
11:34:53 <aristid> also, changing ALL your literals would be insane.
11:35:01 <quantum> call it insane if you want
11:35:11 <doserj> tromp_: put "module Primes where" at the top of the file that you import
11:35:23 <dons> you could write a Num instance for Base12 Int
11:35:26 <Nibble> Does what order function definitions are matter at all?
11:35:27 <dons> if you wanted to be insane
11:35:33 <Eduard_Munteanu> Mm, why do you want that?
11:35:34 <Nibble> Cause this seems to indicate it
11:36:06 <aristid> quantum: just use 0oXYZ and showIntAtBase.
11:36:09 <aristid> :t showIntAtBase.
11:36:10 <lambdabot> parse error (possibly incorrect indentation)
11:36:12 <Eduard_Munteanu> Nibble: for the same function and pattern matching yeah
11:36:14 <aristid> :t showIntAtBase
11:36:15 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
11:36:15 <quantum> ill make a calculator
11:36:18 <Eduard_Munteanu> Nibble: otherwise no.
11:36:18 <tromp_> i don't know were ghc found the file Prime.hs
11:36:28 <Nibble> That has caused me a lot of trouble :(
11:36:31 <aristid> quantum: wait, you don't want it for literals, you want it for STRINGS?
11:36:35 <quantum> literals
11:36:43 <Nibble> Strange that I haven't seen anyone mention it before
11:36:50 <aristid> quantum: no, strings.
11:37:05 <aristid> quantum: calculators work on strings.
11:37:54 <quantum> since haskell doesnt support this I will make a calculator
11:38:14 <quantum> I th/ught it would just be a flag or whatever
11:38:54 <monochrom> you could do some TH thing
11:40:51 <Glycan> Some guy to,d me to come here, after I told him  i needed a programing channal that was languag-independent
11:41:10 <Glycan> Is this a good place?
11:41:19 <aristid> Glycan: this channel is NOT language-independent.
11:41:24 <Jafet> It is a good place, because it isn't language-independent
11:41:45 <dolio> We have the best language, so you don't need to worry about the others.
11:41:53 <Glycan> Hah.
11:41:58 <Jafet> I can't imagine how disjointed a "generic programming channel" would be like.
11:42:04 <Nibble> THE BEST THE BEST THE BEST THE BEST
11:42:10 <Glycan> Well, more like meta-programing.
11:42:43 <warzl> one thing imperative programmers cannot understand is that better abstraction almost always improves performance
11:42:51 <monochrom> this channel is dominated by english, so it is language-dependent or language-independent depending on your perspective
11:43:00 <Glycan> Are you as easy to use, inutive, fast, wellsupposered, and so on as python, but that can be non-manually ported to .swf?
11:43:05 <warzl> if your program is too complex to reason about by one mind, it is impossible to optimize fully
11:43:14 <Jafet> Only if your compiler knows about the abstraction
11:43:21 * rothwell chokes
11:43:24 <aristid> Glycan: there is no compiler from haskell to swf.
11:43:25 <Jafet> And your abstraction is mappable to the implementation
11:43:27 <Glycan> What exactly is imparitive programing?
11:43:40 <Glycan> Well, is there *anything* that fits?
11:43:58 <warzl> Jafet, I sort of took that as a given :)
11:44:04 <Jafet> No, Haskell will never stoop to where Python is.
11:44:11 <Glycan> ??
11:44:14 <monochrom> warzl: they mix up "better abstraction" with "more abstraction", that's why
11:44:15 <dolio> Imperative programming is where you give a list of instructions about what is supposed to happen.
11:44:24 <Glycan> As apposed to...?
11:44:58 <dolio> Writing down how things are defined, and what values are mapped to other values.
11:45:00 <Jafet> warzl: FRP is a recent example, the naïve abstraction doesn't map to the implementation efficiently
11:45:09 <quantum> declarative programming where you pretend not to tell the computer what to do
11:45:22 <Glycan> You lost me.
11:45:54 <aristid> Glycan: you should read this :) http://learnyouahaskell.com/chapters
11:46:09 <monochrom> you lost me too, because I have never learned python, so I don't know what is meant by "like python"
11:46:15 <Glycan> Here's my full question: Givin that my meathod is horrid, and my goal is to write games in a py-like laguage (fast, non-redunant, inuitve, scipting, high-level) and have them come out in ,swf, what should I do? (Text games)[My meathod is having the .swf write out a py file (or, idk, some sort of standalone version thereof) with a socket in it, and then having the other part of the .swf (a 
11:46:15 <Glycan> console) make requests to the py. Possibly requiring the user to run the .py]
11:46:25 <tromp_> @hoogle primePowerFactors
11:46:25 <lambdabot> No results found
11:46:32 <Glycan> (Copy pasta, of course)
11:46:57 <Jafet> Your english is horrid, too
11:47:21 <pmetzger> On an entirely different topic -- I have "cabal install darcs" exploding on me while trying to build terminfo. I'm kind of stumped.
11:47:40 <aristid> pmetzger: exploding as in, it fails?
11:47:45 <pmetzger> I suspect the problem is that the mac I'm using also has macports installed.
11:47:48 <monochrom> does terminfo need some c libs?
11:47:50 <aristid> pmetzger: what's the error message?
11:48:04 <Saizan> terminfo does need some c libs
11:48:24 <pmetzger> It appears to be dying while running configure -- it finds ncurses.h but that file includes some stuff from macports...
11:48:47 <pmetzger> Unfortunately, I don't grok the inside of cabal's build system well. I can cut and paste errors if that will help.
11:48:49 <Glycan> No, my english is subliem. My spelling is horrid.
11:48:54 <Glycan> sublime*
11:50:28 <Saizan> pmetzger: yes, it tends to help, we might need the -v3 output though
11:51:03 <pmetzger> so I should run what command? and should I put it on hpaste?
11:51:26 <flamingspinach> "But few people want to use Haskell because of its pure functional nature and the fact that any code with side effects has to be wrapped in a monoid. (Of course the same is true of C++, as someone recently pointed out. C++ is purely functional and everything with side effects has to be wrapped in the C monoid.)"
11:51:28 <tromp_> @hoogle RandomGenerator
11:51:28 <lambdabot> No results found
11:51:28 <flamingspinach> lol, what
11:51:33 <Saizan> pmetzger: cabal install terminfo -v3 , and yes
11:51:42 <pmetzger> running.
11:51:53 <pmetzger> I probably should have shoved the whole stdout into a file, but never mind...
11:51:56 <monochrom> paste early. paste often. paste completely.
11:52:17 <monochrom> actually some of it may go to stderr instead
11:52:56 <aristid> flamingspinach: wtf? who wrote that?
11:52:58 <Glycan> So... no answer?
11:53:06 <pmetzger> yowza that's verbose. I'm not sure I can really cut and paste the whole thing, it is many many pages of output.
11:53:19 <pmetzger> perhaps I should shove it on a web site, hang on.
11:53:21 <aristid> Glycan: well, for SWF generation you should probably use Actionscript or how the Flash language is called.
11:53:42 <Twey> @src (>=>)
11:53:42 <lambdabot> Source not found. My mind is going. I can feel it.
11:53:55 <flamingspinach> aristid: http://groups.google.com/d/msg/sage-flame/EOoT7GHeVA8/zZyCXB53-LUJ
11:53:56 <aristid> Glycan: if you do not want to restrict yourself to SWF, you could also use javascript to write a browsergame, or haskell (or python) to write a downloadable game
11:55:07 <aristid> flamingspinach: what is [sage-flame]? a list for flamewars?
11:55:21 <flamingspinach> yeah, apparently... lol
11:55:29 <pmetzger> okay, full thing is at http://www.panix.com/~perry/hackage-errors.txt
11:55:43 <pmetzger> that's the output of cabal -v3 install darcs
11:56:00 <aristid> pmetzger: you need the ncurses header files.
11:56:15 <pmetzger> I have it. it is in /usr/include/ncurses.h
11:56:22 <pmetzger> first thing I checked.
11:56:33 <mercury^> @pl (>=>) f g = (>>= g) . f
11:56:34 <lambdabot> (line 1, column 11):
11:56:34 <lambdabot> unexpected "="
11:56:34 <lambdabot> expecting variable, "(", operator or end of input
11:56:36 <pmetzger> I think this is related to running macports and hackage at the same time...
11:56:36 <aristid> pmetzger: then no idea, sorry :)
11:56:42 <Nibble> haskell is so easy
11:56:44 <monochrom> "configure: WARNING: ncurses.h: present but cannot be compiled" looks bad
11:56:54 <Nibble> like making a function that removes duplicates of entries in a list
11:56:55 <mercury^> @pl \f g -> (>>= g) . f
11:56:55 <lambdabot> flip ((.) . (=<<))
11:57:02 <mercury^> Twey: there you go.
11:57:06 <pmetzger> yes. I think ncurses.h refers to some things in /opt/local/ that were installed by macports.
11:57:40 <ion> @pl \x -> foo x >>= bar -- Does pl know >=> btw?
11:57:41 <lambdabot> (bar =<<) . foo
11:58:13 <ion> Hm.
11:58:24 <pmetzger> I was secretly hoping someone else runs a mac with macports and hackage simultaneously...
11:58:48 <monochrom> yeah, I don't understand mac stuff
11:59:32 <pmetzger> maybe the trick would be to build terminfo on its own outside of hackage.
11:59:42 <pmetzger> how can I find the config file in hackage for the terminfo package?
11:59:51 <monochrom> --extra-include-dirs=/opt/local/include ?
11:59:54 <pmetzger> in ~/.cabal somewhere?
12:00:06 <Saizan> pmetzger: cabal unpack terminfo
12:00:22 <Saizan> but try monochrom's suggestion first
12:00:23 <pmetzger> monochrom: to do that I'd have to understand more than I do about altering cabal builds, which is part of why I'm here. :)
12:00:51 <Saizan> pmetzger: that's a flag you pass to cabal install terminfo
12:01:06 <monochrom> that's just for cabal install. "cabal install --extra-include-dirs=/opt/local/include -v3 terminfo"
12:01:17 <pmetzger> hrm. that might work. lets give it a whirl.
12:02:04 <Saizan> btw, -v3 is not needed if there's an actual configure script, it won't tell much anyway :)
12:02:26 <pmetzger> hah! now ncurses.h is complaining it can't find stdio.h or stdbool.h, as though it no longer knew about /usr/include at all.
12:02:50 * hackagebot monoid-statistics 0.3.1 - Monoids for calculation of statistics of sample  http://hackage.haskell.org/package/monoid-statistics-0.3.1 (AlexeyKhudyakov)
12:03:32 <pmetzger> can I force hackage to install its own local copy of ncurses even if there is a global one?
12:03:35 <pmetzger> that might fix it.
12:03:43 <Saizan> hackage doesn't install C libs.
12:03:59 <Saizan> well, doesn't provide, since hackage doesn't install anything
12:04:12 <pmetzger> so what does it do if it needs something like ncurses that doesn't always exist?
12:04:33 <Eduard_Munteanu> Your distro is supposed to supply it.
12:04:33 <Saizan> complains to the user :)
12:05:04 <monochrom> I am a bit puzzled by "checking for stdlib.h... no" "checking for string.h... no". shouldn't those be, like. ANSI C?
12:05:25 <pmetzger> they are POSIX
12:05:39 <pmetzger> I can't remember if they're C99 but they're universal.
12:05:53 <pmurias> i can't derive Show for GADTs?
12:05:53 <Eduard_Munteanu> Technically configure scripts should allow a package to compile even with non-C99 compilers.
12:05:59 <Eduard_Munteanu> I don't think those are strictly C99.
12:06:29 <monochrom> they were already in the very first version of ANSI C way back
12:06:46 <pmurias> monochrom: what do you use?
12:06:50 <pmetzger> I meant ANSI C, not C99 in particular, my goof.
12:07:32 <dankna> ANSI C actually refers to C89
12:07:36 <dankna> C99 is an ISO standard
12:07:54 <dankna> so you meant "standard C" if you meant either of those generically
12:08:07 <pmetzger> probably. :)
12:08:10 <dankna> anyway they are both standard C :)
12:08:13 <Eduard_Munteanu> But only C99 is standard nowadays :P
12:08:19 <Bfig> is there any nice way to write the concatenation of two lists?
12:08:23 <dankna> fair point
12:08:34 <pmetzger> Bfig: you mean ++?
12:08:35 <Eduard_Munteanu> Bfig: (++)
12:08:48 <Bfig> damn, i feel like an idiot.
12:08:52 <Bfig> thanks
12:08:58 <monochrom> if even C89-required headers can't be found, I can't expect ncurses.h to work
12:09:00 <Bfig> too much syntax :p
12:09:23 <pmetzger> okay, libcurses is installed by default on the mac.
12:09:25 <Eduard_Munteanu> I'm not really sure, maybe it's for non-standard / embedded glibcs.
12:09:35 <pmetzger> does terminfo actually need ncurses vs. curses?
12:10:01 <Eduard_Munteanu> Then again, autoconf can easily be put in a state where it checks for things it shouldn't really check for.
12:11:10 <monochrom> it seems ncurses.h wants stdarg.h at the very least
12:11:35 <monochrom> if stdlib.h can't be found, I don't have any confidence that stdarg.h can be found
12:11:57 <pmetzger> stdlib.h and stdarg.h are in /usr/include where they should be
12:12:11 <pmetzger> something is clearly way screwed up in the include path, but I don't get how.
12:12:25 <dankna> it's problems of this nature that are the reason I don't try to use macports, heh
12:12:30 <dankna> I install what I need in /usr/local
12:12:46 <pmetzger> terminfo appears not to require ncurses per se.
12:12:50 <monochrom> I go all the way and just declare I'm scared by mac :)
12:12:57 <dankna> using macports is a legitimate choice, but I can't help with it :/
12:13:01 <dankna> haha I see
12:13:03 <pmetzger> and I am now thinking the macports thing is incorrect, it appears independent of macports entirely.
12:13:20 <pmetzger> that was a red herring
12:13:36 <dankna> okay
12:14:02 <aristid> isn't homebrew what the cool kids use now?
12:14:11 <wlangstroth> no brew formula for ncurses
12:14:16 <aristid> i mean, i'm happy with my apt-get ;)
12:14:33 <aristid> wlangstroth: does ncurses ship with os x?
12:15:16 <monochrom> I do not know whether terminfo can work with curses, to answer your question
12:15:43 <pmetzger> ncurses does ship with os x.
12:15:59 <pmetzger> I think I have a theory, testing now.
12:16:31 <dankna> pretty sure that if you have ncurses in /opt/local where macports puts it, that will override the one that ships with the Mac unless you take steps to ensure otherwise
12:17:01 <wlangstroth> aristid: yup, thus no brew formula
12:17:14 <pmetzger> theory failed.
12:17:36 <pmetzger> now I wonder i this involves having xcode 4 installed.
12:17:42 <dankna> possible
12:18:10 <Bfig> if you use something like ( $.... ), does that correctly go up to the inside of )?
12:18:25 <monochrom> yes
12:18:29 <Bfig> cool :)
12:18:40 <nyingen> what do people use to edit haskell programs these days? emacs? vim? how are the haskell IDEs?
12:18:55 <nyingen> I'm currently using emacs, but not particularly satisfied
12:18:56 <rostayob> nyingen: emacs + haskell mode
12:19:04 <monochrom> I use emacs
12:19:11 <rostayob> nyingen: me neithere, vim haskell mode is better, but emacs is emacs
12:19:14 <rostayob> *neither
12:19:32 <rostayob> nyingen: autocomplete mode works quite well with emacs if you didn't know
12:19:39 <pmetzger> found the problem, but I don't understand it.
12:19:48 <pmetzger> cabal is invoking gcc with -isysroot!
12:19:57 <pmetzger> that nukes the knowledge the compiler has of where the system includes are.
12:20:07 <pmetzger> now can someone help me explain why that is?
12:20:19 <pmetzger> I use emacs
12:20:28 <nyingen> I like the ability to compile and have the attached ghci window, but it's not so useful that I wouldn't move to some other editor if it provided other good features
12:21:06 <rostayob> nyingen: if you are not addicted  to emacs as I am, try vim haskell mode
12:21:27 <pmetzger> worse, it invokes -isysroot pointing at a non-existent mac os x sdk, specifically for 10.5 instead of 10.6!
12:21:37 <pmetzger> okay, this is a very big WTF.
12:21:51 <wlangstroth> pmetzger: I've been having the same problem
12:21:54 <jmcarthur> i also use emacs
12:22:08 <pmetzger> wlangstroth: what version of os x and xcode?
12:22:24 <nyingen> rostayob: I'm actually mostly a vim user, but I was already using emacs for lisp so I tried haskell-mode and it seemed ok. I should try the vim mode too
12:22:31 <rostayob> for emacs user: http://madscientist.jp/~ikegami/diary/20090215.html#p01
12:22:46 <rostayob> nyingen: it's really cool, look it up
12:22:48 <pmetzger> there are other editors besides emacs?
12:23:02 <monochrom> yes, there is notepad :)
12:23:06 <raichoo> What is emacs? Some kind of vim?
12:23:17 <rostayob> raichoo: actually, yes.
12:23:18 <wlangstroth> pmetzger: 10.6.7, 3.2.5
12:23:19 <nyingen> how about leksah?
12:23:24 <rostayob> viper mode ftw
12:23:32 <systemfault> Stallman wanted an OS in his OS so he invented emacs.. :/
12:23:35 <pmetzger> wlangstroth: do you get the -isysroot issue on gcc invocation?
12:23:42 <barshirtcliff> ghc-mod on emacs showed up on the haskell-cafe list today.  sounds good.
12:23:49 <rostayob> emacs is a good os, but it lacks a good editor
12:23:51 <raichoo> systemfault: Sup dawg… i herd… oh well
12:23:59 <wlangstroth> pmetzger: yeah, and the 10.5 thing, too
12:24:18 <dcoutts> pmetzger: cabal itself does not use -isysroot, so if cabal is calling it with that flag, it's being passed that flag in by some other tool
12:24:43 <pmetzger> where does cabal get such flags from? no tool I know of is going to invoke that.
12:24:49 <pmetzger> hrm.
12:24:57 <monochrom> oh hi dcoutts, pmetzger's entire -v3 log is at http://www.panix.com/~perry/hackage-errors.txt
12:25:06 <dcoutts> monochrom: ta
12:25:21 <pmetzger> will the -v3 log reveal what is generating the command line for gcc?
12:26:03 <pmetzger> I can't seem to figure that part out but I'm not a qualified haruspex
12:26:30 <dcoutts> pmetzger: what does ghc --info report? can you paste it somewhere
12:26:44 <pmetzger> one sec
12:27:30 <pmetzger> http://www.panix.com/~perry/ghc-info.txt
12:27:37 <pmetzger> it seems to think it is on 10.5!
12:27:42 <pmetzger> which is crazy, it is on 10.6
12:28:04 <wlangstroth> how might one configure the c flags for ghc?
12:28:25 <wlangstroth> (if this is common knowledge, feel free to say so)
12:28:41 <pmetzger> presumably they're compiled in or something, but I'm no ghc haruspex either.
12:28:53 <pmetzger> if only I'd spent more of my youth looking at livers and intestines.
12:28:57 <dcoutts> pmetzger: oh oops, that's the same file as you pasted before, we need the output from running ghc --info
12:29:02 <monochrom> there is a longish Environment: [("SUDO_PS1"... line. one of it is ("CFLAGS","-march=i686 -m32 -isysroot /Developer/SDKs/MacOSX10.5.sdk -mmacosx-version-min=10.5 -fno-stack-protector -march=i686 -m32 -isysroot /Developer/SDKs/MacOSX10.5.sdk -mmacosx-version-min=10.5"). is that yours?
12:29:05 <pmetzger> sorry, I'll fix
12:29:16 <pmetzger> fixed
12:29:32 <dcoutts> "C compiler flags","[\"-march=i686\",\"-m32\",\"-isysroot\"
12:29:40 <monochrom> yeah, did you set CFLAGS yourself?
12:29:43 <pmetzger> no.
12:29:52 <pmetzger> set on my command line shows no such things
12:30:10 <monochrom> no no, echo $CFLAGS
12:30:19 <dcoutts> pmetzger, monochrom: so with recent versions of cabal + ghc, cabal will get its default gcc and linker flags from ghc, since it's pretty important that they match
12:30:23 <pmetzger> set shows all the environment
12:30:27 <pmetzger> CFLAGS is not set.
12:30:31 <wlangstroth> ditto
12:30:46 <pmetzger> if you don't know about "set" try it. env does something similar.
12:31:00 <pmetzger> anyway, no CFLAGS and I can grep and I find no instance of any of that in the environment at all.
12:31:03 <dcoutts> monochrom: e.g. previously we had the problem that ghc on osx was using gcc -m32 (since osx gcc started defaulting to 64bit) and so if cabal didn't also match what ghc was doing then it'd all break.
12:31:38 <dcoutts> pmetzger: so that's the reason, ghc is using those gcc settings, so cabal just follows suit
12:31:42 <monochrom> perhaps ghc installer instituted it
12:31:43 <pmetzger> yup, env | fgrep finds nothing like this.
12:31:53 <pmetzger> dcoutts: yes, but why is the question.
12:32:05 <pmetzger> clearly this is because ghc wants things that way, but where is that set for ghc?
12:32:10 <monochrom> you crashed dcoutts :)
12:32:27 <wlangstroth> haskell platform
12:32:47 <pmetzger> why is the haskell platform setting things this way is the question, and how do I fix that. :|
12:32:48 <monochrom> ghc is a shell script that sets more environment variables like this before calling the real ghc
12:33:05 <pmetzger> well, time for me to examine the liver then.
12:33:15 <dcoutts> pmetzger: it's likely nothing to do with the environment, it's just the gcc settings that ghc uses
12:33:57 <monochrom> oh nevermind, ghc's shell script probably doesn't set CFLAGS
12:34:04 <pmetzger> indeed, it does not
12:34:09 <Igloo> What's the problem? And do you have XCode 4?
12:34:24 <pmetzger> I have xcode 4. but wlangstroth has xcode 3 and has the same issue
12:34:25 * dcoutts was just about to ask that
12:34:40 <Igloo> If you have XCode 4, you need GHC 7.0.3
12:34:53 <monochrom> yikes
12:35:02 <pmetzger> is that available in the convenient haskell platform spray can?
12:35:10 <monochrom> not yet
12:35:10 <Igloo> It will be soon
12:35:12 <dcoutts> it will be in due course
12:35:30 <pmetzger> okay, so what do I do in the meanwhile?
12:35:38 <dcoutts> install XCode 3? :-)
12:35:39 <pmetzger> and why is wlangstroth also losing?
12:35:53 <pmetzger> he uses xcode 3
12:36:10 <wlangstroth> check out /usr/bin/ghc
12:36:13 <monochrom> "I propose we have a minor release in the next week." from dons on the haskell platform mailing list April 2
12:36:27 <pmetzger> the fact that it is trying to force os x 10.5 is very very weird. why would it hard code that?
12:36:42 <monochrom> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable?version=43#Minorrevision:2011.2.0.1
12:36:44 <wlangstroth> I think it's in the GHC framework
12:36:54 <monochrom> wait, it says April 8, that's today!
12:37:12 <dcoutts> pmetzger: I think that just means it uses that version of the sdk, which presumably is available on 10.5 and 10.6
12:37:21 <tromp_> @hoogle Math.Sieve.Factor
12:37:21 <pmetzger> no, it isn't.
12:37:21 <lambdabot> No results found
12:37:31 <pmetzger> the sdk that's installed is 10.6 only.
12:37:42 <pmetzger> if I look at the directory it points at, it does not exist
12:37:50 <Igloo> pmetzger: It is in XCode 3
12:37:51 <dcoutts> perhaps that's the XCode 3 thing
12:38:07 <pmetzger> ah, but again, wlangstroth uses xcode 3.
12:38:44 <monochrom> oh single mac os x seems to be more fragmented than debian, ubuntu, fedora, gentoo, arch combined
12:38:51 <monochrom> s/oh/one/
12:38:53 <dcoutts> pmetzger: are you sure it's exactly the same problem?
12:39:08 <pmetzger> nope. wlangstroth would have to pipe up, but he seemed to indicate that it was identical.
12:39:32 <mightybyte> Are there any commonly used type classes for working with generic sequences of values other than ListLike?
12:39:35 <dcoutts> monochrom: certainly less backwards compatability
12:39:37 <wlangstroth> yes, my cflags list is exactly the same
12:39:51 <pmetzger> however, if a new haskell platform is to be released within hours, it would seem stupid to waste lots of time fixing this if that will fix it.
12:39:54 <dcoutts> monochrom: seemed to be quite hard to make a build + installer that works on both 10.5 and .6
12:40:12 <wlangstroth> yeah, pretty sure it's the mac os x installer
12:40:15 <Igloo> wlangstroth: The cflags are supposed to say 10.5. What's the problem?
12:40:41 <pmetzger> saying 10.5 breaks anyone who didn't install the 10.5 sdk. that's not mandatory in xcode.
12:40:57 <pmetzger> wasn't even in xcode 3...
12:41:20 <pmetzger> anyway, why is this pointing at the xcode includes instead of just /usr/include?
12:41:30 <pmetzger> there really is no need for that so far as I can tell.
12:41:39 <pmetzger> and it creates issues like this...
12:41:52 <dcoutts> pmetzger: because the installed libraries were built against that version
12:41:58 <pmetzger> (well, "as far as I can tell", I know not what dark arts lie within ghc...)
12:41:58 <wlangstroth> pmetzger: I think the current maintainer of the installer is looking for someone to take over
12:43:14 <wlangstroth> if it's still gcollins, then I *know* he wants someone else to take it over
12:43:54 <pmetzger> and to think all I wanted to do was use darcs to read the language.c sources.
12:44:10 <pmetzger> my day has been entirely lost in yak shaving.
12:46:29 <monochrom> call it a black friday :)
12:47:09 <aristid> .oO(a mention of git would surely be dangerous)
12:48:10 <monochrom> perhaps language.c is not on git, that's why
12:49:53 <copumpkin> I wish someone would GSOC a Language.ObjectiveC
12:56:13 <pmetzger> doing an objective C parser on top of the current C parser would be trivial.
12:56:30 <pmetzger> but it is just an AST generator...
12:56:56 <copumpkin> that's fine
12:57:00 <copumpkin> I'd also like something going the other way
12:57:03 <copumpkin> for generating code
12:57:14 <copumpkin> Language.C could also be improved to generate code more nicely
12:57:25 <copumpkin> since currently it just takes its AST representation before outputting it
12:57:33 <copumpkin> and that means you need to sprinkle source locations into it
12:57:41 <pmetzger> I don't know much about its innards. that is how I started down this damnable waste of time today.
12:58:01 <pmetzger> screw it, I'm going to tell macports to build me Yet Another ghc+darcs.
12:58:16 <copumpkin> why have it build it?
12:58:22 <copumpkin> just use the package distributions
12:58:22 <pmetzger> I'll fix everything "correctly" later...
12:58:39 <pmetzger> copumkin: you mean use hackage? scroll up to see why.
12:58:55 <copumpkin> http://hackage.haskell.org/platform/
12:58:59 <pmetzger> er, copumpkin.
12:59:10 <copumpkin> oh, you have xcode 4?
12:59:14 <Saizan> is there a binary package for darcs on mac osx?
12:59:15 <pmetzger> yes, I know, but scroll up. that is broken for me right now on OS X, yes.
12:59:37 <copumpkin> yeah, the new platform with a fixed ghc should be going up any day now I think
12:59:46 <copumpkin> dons proposed an unscheduled release a few days ago
13:00:26 <RenJuan> issat 7.1?
13:03:36 <Bfig> i'm having a huge problem with a stack overflow on a polynomial division algorithm
13:03:59 <dons> well, i scheduled a release :) 
13:04:03 <dons> looks likely for monday
13:04:09 <int80_h> dons: release of what?
13:04:18 <quantum> Bfig: its thei same as normal division
13:04:43 <Bfig> my representation is [Float] with the index representing the coefficients of x^n
13:05:03 <Bfig> quantum, i don't understand, what do you mean? i didn't even state my problem :p
13:05:12 <quantum> you can't use float
13:05:23 <pmetzger> Can I build the new version of the haskell platform myself before the release?
13:05:27 <Bfig> mmm, the inverses are not properly computed?
13:05:30 <pmetzger> or do I not want to go there?
13:05:52 <acowley> pmetzger: to what end?
13:05:54 <Bfig> quantum, what should i use?
13:05:59 <quantum> Integer
13:06:20 <pmetzger> acowley: so that I can actually build stuff over the weekend. I'm dead in the water, apparently because of xcode 4 issues
13:06:32 <dons> int80_h: HP
13:06:46 <Bfig> quantum, how would i compute the inverses needed then?
13:06:47 <acowley> pmetzger: ah, and just upgrading GHC won't work for you?
13:06:52 <quantum> division algorhtm
13:07:06 <Bfig> division algorithm of what?
13:07:11 <pmetzger> maybe, I have no idea.
13:07:15 <Bfig> integer division?
13:10:19 <wlangstroth> dons: awesome
13:12:36 <pmetzger> okay, I've set macports off building ghc and darcs. I'll live with that for a day or two.
13:12:38 <Twey> I have a simple-ish read loop on a socket handle with a ‘flip catch print’ attached to it, but when it disconnects from the other end, instead of throwing just *one* ‘end of file’ exception, it seems to throw one for every line read, with the ‘print’ handler being called each time
13:12:52 <acowley> pmetzger: do you need to use macports?
13:13:08 <pmetzger> no, but I have no better solution that I'm quickly aware of.
13:13:18 <acowley> pmetzger: downloading a binary or building your own
13:13:42 <pmetzger> this is fairly automated and I just need it for a couple of days anyway.
13:13:50 <acowley> pmetzger: http://www.haskell.org/ghc/download_ghc_7_0_3
13:14:01 <acowley> pmetzger: okay, it's just that macports can cause some difficulties
13:14:41 <pmetzger> this claims to need xcode 3.
13:14:45 <pmetzger> and I have xcode 4
13:15:06 <pmetzger> and I can yank the macports version with one command on monday or whenever.
13:16:50 <pmetzger> hrm. it seems that it will do xcode 4. I'll try installing
13:17:46 <pmetzger> wow. slowww download.
13:18:10 <acowley> I noticed that a week or two ago when I downloaded it
13:21:40 <Bfig> found my error... swapped to  length a - length b from length b - length a.
13:31:41 <erus_> is there a function to check if a list contains a sub list? like elem
13:31:52 <c_wraith> :t isInfixOf
13:31:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
13:32:10 <c_wraith> > [2..5] `isInfixOf` [1..10]
13:32:10 <lambdabot>   True
13:32:14 <S11001001> pmetzger: aye, I had the same problem with 7.0.2 fixed with 7.0.3
13:32:16 <c_wraith> > [2..5] `isInfixOf` [1..4]
13:32:17 <lambdabot>   False
13:32:18 <hpc> > "12345" `isInfixOf` map show [1..]
13:32:19 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:32:19 <lambdabot>         against inferred type...
13:32:28 <hpc> > "12345" `isInfixOf` map (head . show) [1..]
13:32:30 <lambdabot>   True
13:32:32 <erus_> thanks c_wraith 
13:32:34 <ryant5000> has anyone here built haskell programs against Visual Studio .lib files?
13:32:38 <augur> are there any tree diff algos in haskell?
13:33:09 <c_wraith> augur: I'm really tempted to answer that with "yes, but I'm not sure if anyone has implemented them". :P
13:33:17 <augur> :P
13:33:52 <erus_> also does anyone know of a "babys first parallel haskell program" type tutorial?
13:34:07 <acowley> forkIO $ return ()
13:34:14 <c_wraith> that's concurrent. :P
13:34:18 <acowley> :(
13:34:28 <c_wraith> erus_: are you looking for parallelism or concurrency?
13:34:53 <c_wraith> erus_: they are typically done in entirely different ways in haskell.
13:35:26 <erus_> parallelism is where i do a simple operation over a list in parallel right?
13:35:31 <erus_> that one
13:35:35 <hpc> x `par` y `pseq` x + y
13:35:38 <hpc> that's parallel :P
13:35:42 <c_wraith> erus_: yeah, that sounds like parallelism.
13:36:08 <c_wraith> Honestly, I'd look at simon marlow's new library.  No one has much experience with it, but it looks *way* easier to understand the details
13:36:28 <acowley> Now that I think about it, I don't know that forkIO $ return () is concurrent (as opposed to parallel)
13:36:32 <acowley> there's no interaction
13:36:50 <acowley> I had a negative reaction to that new library actually
13:36:57 <c_wraith> depends on if you bind the new return value
13:37:10 <c_wraith> holding on to the thread id does *something*, even if it's not what you want
13:37:15 <acowley> I suppose I haven't read the paper close enough
13:37:36 <acowley> but it didn't initially strike me as being an improvement in terms of usability
13:37:45 <c_wraith> acowley: the list of reasons why they created the new library is pretty convincing to me.  It's *hard* to get pseq and par to actually work usefully.
13:38:05 <acowley> c_wraith: even if I hold on to the thread id, if what follows the fork doesn't mention it, I think it's parallel to the forked thread
13:38:19 <acowley> c_wraith: I agree with the last thing you said
13:38:33 <c_wraith> well.  That's a starting point, at least :)
13:38:53 <c_wraith> I didn't actually try anything with the new lib, but it looked reasonable-ish.
13:39:22 <Peaker_> c_wraith: really? I thought it was wonderful to just throw around "par" everywhere it seems to be worth it
13:39:25 <acowley> Sure, compared to forkIO + IORefs it is an improvement
13:39:50 <acowley> Peaker: the trouble is knowing when things will happen
13:39:53 <c_wraith> Peaker: there are many cases where that just doesn't help.
13:39:56 <xplat> which one is simon marlow's new library?
13:40:00 <acowley> monad-par
13:40:08 <Peaker> c_wraith: elaborate?
13:40:08 <lambdabot> Peaker: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:41:09 <acowley> c_wraith: the issue is that forkIO+MVar is much nicer than forkIO+IORef, and the advantages of fork+IVar weren't overwhelming to me
13:41:18 <c_wraith> Peaker: look at all the cases on -cafe or stackoverflow where someone has said "help me out with this parallel program, I can't get any actual speedup," and it takes an answer from don or simon before it gets straightened out why there's no parallel speedup
13:41:53 <c_wraith> acowley: I'm pretty sure the main advantage is runPar :: Par a -> a
13:42:05 <acowley> I'm sure there are advantages, but at this point things that look like silver bullets are all the rage. Parallel maps are easy to use, for example, while having to monkey with single assignment requires thought.
13:42:10 <acowley> c_wraith: yes
13:42:36 <acowley> c_wraith: but I hoped for more
13:42:55 <Peaker> c_wraith: I don't read -cafe..
13:43:46 <acowley> I suppose I still have hope for new libraries built atop monad-par, but I don't find STM or old-fashioned forkIO+MVars all that bad for cases where it makes sense for me to think about individual threads
13:44:27 <Peaker> I think it would be nice if we had an IDE that allowed annotating pure code semi-automatically based on profile results
13:45:16 <Twey> mercury^: Oh… thanks ☺
13:45:41 <erus_> acowley: the Data.Array.Parallel stuff is not ready for the big time
13:45:44 <Peaker> The problem with completely automatic parallelization is that the overhead/spark may be too expensive, right? So the "problem" should only be -- marking computations as smaller or larger than that threshold... Profiling can do a lot of that work, and annotations of "par" is what I saw as the current temp solution to that
13:45:57 <erus_> parallel code has to be in its own module and compiled with special flags
13:45:59 <erus_> what a pain
13:46:07 <c_wraith> own module?
13:46:22 <c_wraith> you must be looking at data-parallel haskell
13:46:35 <erus_> yeah i was...
13:46:49 <c_wraith> par/pseq-based stuff doesn't require that.  Though it does require being compiled with the threaded runtime
13:47:04 <c_wraith> At least, in order to *help*, it requires the threaded runtime
13:47:44 <c_wraith> I wonder how expressive a layer on top of monad-par that hides all explicit IVar operations would be...  If it used fork :: Par a -> Par a, and used an implicit IVar there, how much would it hurt expressiveness?
13:47:54 <Peaker> so the reason we need more than just "par" (e.g: pseq) is because we also want to control cache thrashing -- i.e: which computations run in which threads?
13:48:40 <c_wraith> Peaker: No, it's so that you actually wait for parallel operations to run, so that you're not just generating sparks for no benefit
13:49:12 <Peaker> c_wraith: wait, you dove under the abstraction I'm talking about :)
13:49:49 <Peaker> c_wraith: let's start from complete auto-parallelization of pure code..
13:50:06 <Peaker> c_wraith: the problem is parallelization overhead for small computations, as I understand it
13:50:37 <c_wraith> acowley: did you drop out right as I was musing about an implicit-IVar-only version of monad-par?
13:50:54 <acowley> c_wraith: unfortunately, yes
13:52:00 <erus_> haha
13:52:05 <c_wraith> Wasn't much to it.  Just wondering if it could be similarly expressive.
13:52:11 <acowley> c_wraith: which sounds like what I was going to mention, too. Part of my objection is the syntactic heavyness of monad-par, when what I want is to put a little mark on identifiers and have it all happen automatically
13:52:11 <christo_m> hello, im trying to parse the LUA language with haskell/Parsec.. this particular grammar rule right here chunk ::= {stat [`;´]}
13:52:22 <christo_m> means a chunk is a bunch of statements, optionally followed by a semi colon right
13:52:34 <tromp_> what haskell module can split lists in e.g. chunks of given size
13:52:39 <christo_m> option stat (manyTill stat (try (string ";"))  <- i tried to define it like this with parsec, not sure if thats right
13:52:51 <acowley> tromp: probably split
13:52:54 <christo_m> option x p , means if p fails, we go with x right
13:53:09 <tromp_> ah, of course:)
13:53:44 <Peaker> Can anyone explain why pseq is useful (other than for the same reasons "seq" is useful, which is trade-off'ing computation for memory and reducing stack depth)?
13:53:46 <c_wraith> acowley: that's really just the same as par/pseq, but with a bit more sugar.  It'd have the same kinds of issues.
13:54:28 <acowley> c_wraith: I suppose so, but I think of it more as forcing the evaluation to happen in a new spark, so much like an implicit pseq
13:55:14 <acowley> I'm sure simonmar knows better. I'm just rambling about what I'd like the world to look like
13:55:37 <c_wraith> the monadic approach is definitely syntactically heavier...  But it's also much clearer, in terms of expressing parallelism in terms of data flow.
13:56:07 <hpc> Peaker: pseq runs the first argument as a spark, which means you could get threading advantages
13:56:20 <hpc> depending on compilation flags and what way the wind is blowing
13:56:31 <pmetzger> ah, 7.0.3 does everything correctly. good thing.
13:56:46 <xplat> Peaker: data locality can be another big issue with sparks, not just the size
13:56:46 <ddarius> The difference between seq and pseq is just operational behavior.  They are semantically identical.  pseq is usually what people actually want.  seq, however, is useful for cases where evidence is being passed around as a value.  You need to force it to make sure it is actually legitimate.
13:56:58 <Peaker> xplat: yeah, I mentioned data locality above but c_wraith said it was not the reason
13:57:01 <Berengal> Are bytestrings the standard way to pass byte arrays to C?
13:57:24 <hpc> Berengal: i believe so; haven't had to do ffi stuff though
13:57:32 <c_wraith> Berengal: yeah, they are
13:57:39 <Berengal> Coolbeans
13:57:41 <copumpkin> Berengal: ByteArray# will also give C the pointer
13:57:46 <acowley> Berengal: the underlying ForeignPtr is where the action happens
13:57:55 <Peaker> ddarius: but "pseq" is constantly mentioned in the context of parallelism
13:58:02 <Peaker> ddarius: and I am wondering why it makes sense there
13:58:20 <Peaker> (except for helping with data-locality)
13:58:22 <ddarius> Peaker: The only difference between par and const is operational as well.
13:58:31 <ddarius> (flip const)
13:58:44 <Berengal> acowley: Yeah, I have this (toForeignPtr >>=) . withForeignPtr construct
13:58:48 <Peaker> so in the context of parallelism, why are the operational semantics of pseq useful?
13:58:52 <copumpkin> pseq actually enforces order of evaluation
13:58:53 <Berengal> Wait, other way around
13:58:56 <Berengal> But yeah
13:58:58 <ddarius> Peaker: Because it has one.
13:59:01 <Peaker> copumpkin: why would you want to do that?
13:59:28 <Peaker> copumpkin: (in the parallelism context, not the "make sure a proof exists" context, or the "avoid deep thunks causing stack overflow" context)
13:59:49 <acowley> Berengal: your code just broke my brain
13:59:56 <xplat> Peaker: it's not the reason for pseq, but it is another reason (besides size) to not throw an automatic 'par' on everything
13:59:59 <copumpkin> because if you fork off two sparks that compute two prerequisites to a third calculation
14:00:07 <copumpkin> you don't want the third calculation to evaluate before the two sparks do
14:00:13 <copumpkin> or the parallelism will be pointless
14:00:16 <dolio> Peaker: Because you usually want to execute your subexpressions in parallel before using them.
14:00:17 <acowley> Berengal: But yes, that's the backwards version of the usual thing as long as your C code doesn't poke the pointer
14:00:27 <ddarius> Peaker: The "make sure a proof exists" is not an operational concern.
14:01:01 <Peaker> ddarius: yeah, I understand
14:01:31 <Peaker> dolio: why is it not enough to have a `par` b `par` a+b   to make sure a and b are evaluated in parallel before they are used by a+b?
14:01:32 <dolio> Instead of accidentally having the main thread evaluate the thing that's forked.
14:01:45 <copumpkin> Peaker: the a + b will happen at same time as the other two
14:01:49 <copumpkin> thereby making the other two irrelevant
14:01:55 <pmetzger> as long as I'm here... other than language.c, are there any other existing C parsing frameworks that people like?
14:01:59 <copumpkin> Peaker: potentially at the same time, anyway
14:02:15 <ddarius> Peaker: That doesn't even say to evaluate a+b before a and b.
14:02:18 <Peaker> copumpkin: why can't it "encounter" the 'a' and 'b' as "during execution" and wait for them to complete?
14:02:38 <copumpkin> Peaker: because it isn't that clever
14:02:42 <copumpkin> and would possibly need to figure that out at runtime
14:02:53 <ddarius> copumpkin: That's what does happen.
14:03:05 <ddarius> The problem is that that happens the other way too.
14:03:09 <acowley> ddarius: except that a+b can start evaluating first
14:03:13 <Peaker> well, I understand why it isn't clever enough to completely auto-parallelize everything, but it sounds like it should be reasonably possible to require just annotations of what's worth parallelizing and what isn't?
14:04:02 <Peaker> ddarius: it sounds like if it starts a+b first, that would be okay too
14:04:15 <copumpkin> if it starts a + b first, it's fine, but you won't gain any efficiency
14:04:22 <Peaker> (it will start evaluating 'a', and 'b' can evaluate in parallel until the (a+b) needs it and either waits or has it ready)
14:04:22 <ddarius> Peaker: Any order is okay as far as semantics are concerned.
14:04:34 <Peaker> ddarius: I mean for the correct operational behavior too
14:05:14 <dolio> Peaker: Consider 'a `par` a + b'. That says, evaluate a in parallel with a + b. But a + b may start evaluating a on its own. And if it runs first, the parallel thread won't have a chance, so you get no parallelism.
14:05:15 <Peaker> copumpkin: why not? The a+b will demand the "a", and negate the "a" par part, but the "b" par part will be in parallel, and the "a" part might even run in parallel too, if the a+b didn't yet get around to requiring "a"
14:05:17 <copumpkin> ddarius: I thought it would happily evaluate all of those separately
14:05:31 <copumpkin> I thought part of the point of this was that GHC didn't want to artificially insert waits
14:05:40 <copumpkin> unless you explicitly request them with pseq
14:06:02 <copumpkin> since things are pure, it's fine to run them multiple times
14:06:09 <copumpkin> it's just a waste
14:06:10 <dolio> So, instead, people use 'a `par` b `pseq` a + b' which says: before evaluating a + b, evaluate a `par` b. And b is presumably independent of a, so they can legitimately be computed in parallel.
14:06:33 <ddarius> copumpkin: pseq doesn't insert waits, and GHC doesn't insert waits.  It blackholes the thunks containing a and b.  There's a race condition where multiple things -can- be evaluated at once, but GHC tries to avoid that to the extent that it can for free.
14:07:05 <copumpkin> well I don't mean explicit waits as in blocking on some mutex, just in the sense that "this should be done before that"
14:07:10 <Peaker> dolio: it seems the worst-case and best-case parallelism of   a `par` a+b    are very similar, so I'm not sure it's a good example
14:07:56 <Berengal> Peaker: assuming a and b takes equally long to evaluaate, a `par` a + b can take twice as long
14:08:12 <Peaker> Berengal: only if (+) doesn't actually force its left-side argument first?
14:08:45 <ddarius> Which is to say, the worst-case in that situation is no parallelism and the best case is the ideal parallism.
14:08:57 <dolio> a `par` b + a if you prefer.
14:09:20 <dolio> What matters is that the right may start evaluating a before the parallelism happens, in which case you get no parallelism.
14:09:30 <c_wraith> Peaker: (+) is free to evaluate its arguments in whatever order it wants
14:09:51 <Peaker> but in a `par` b+a   the only case where you lose out on parallelism, is if you had something keeping different cores busy (with ideal parallelism) long enough to avoid evaluating "a" before the (b) and (+) got a chance to, so it doesn't sound like a big problem
14:09:56 <Berengal> Peaker: If (+) forces the left side first, the parallel evaluation of a won't work right. Either it will be evaluated in the main thread, or the main thread will blackhole on it, essentially block until the parallel evaluation is done
14:10:18 <Peaker> Berengal: that's what I meant by best-case and worst-case being essentially the same --> almost no parallelism
14:10:46 <ddarius> In one case, a and b can be completely parallel.  In the other they are completely sequential.
14:10:51 <Berengal> Peaker: In the best case, (+) evaluates b first, giving time to evaluate a in parallel
14:10:58 <ddarius> The point here is the parallelism between a and b, not a and a+b.
14:11:14 <cheater99> :t first
14:11:15 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:11:37 <cheater99> what does this type mean? a (b, d) (c, d)
14:11:42 <Peaker> ddarius: it sounds like if a `par` b+a  ended up sequential, then:   a `par` b `pseq` a+b   should also be sequential -- the a `par` b will end up evaluating one in full before giving a chance to the other
14:12:31 <Berengal> cheater99: a is an arrow of (b, d) and (c, d). One such instance is (b, d) -> (c, d)
14:12:36 <ddarius> Peaker: Why do you think that?
14:13:00 <cheater99> ok thanks
14:13:35 <copumpkin> :t first `asTypeIn` (\f -> f (+1))
14:13:35 <lambdabot> forall b d. (Num b) => (b -> b) -> (b, d) -> (b, d)
14:13:37 <hpc> cheater99: to understand arrows, you should probably learn categories first
14:13:38 <Peaker> ddarius: because a `par` b+a  should either run a and b evaluations in parallel, or get the first to wait long enough to become sequential.  similarly, the a `par` b  that is before the (a+b) in the pseq would either run in parallel, or one of these would have to wait long enough so that in effect it runs sequentially to the other
14:13:39 <hpc> cheater99: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8
14:14:55 <Berengal> Peaker: a `par` b means "fork a, then evaluate b", x `pseq` y means "evaluate x then evaluate y". a `par` b `pseq` a + b therefore means "fork a, evaluate b, evaluate a + b"
14:15:04 <copumpkin> to understand initial algebras, you must first understand initial algebras?
14:15:16 <ddarius> copumpkin: And last.
14:15:18 <hpc> heh
14:15:26 <monochrom> haha
14:16:10 <dolio> Peaker: You're making assumptions about what order (+) evaluates its arguments. a `par` b `pseq` f a b has no dependence on that for a and b to be evaluated in parallel.
14:16:46 <cheater99> hpc: this uses too much high fly haskell for me
14:16:53 <cheater99> hpc: i am only somewhat beginning
14:16:55 <Peaker> dolio: well, a `par` b `par` a+b   will also take away the assumptions -- and should similarly get the same amount of parallelism (though par may have more overhead than pseq, but that's a different concern)
14:16:59 <erus_> monads add mutable states to haskell?
14:17:02 <hpc> cheater99: ah, nvm then :P
14:17:03 <cheater99> hpc: i bet i could understand the mathematics though.
14:17:19 <erus_> @faq monads add mutable states to haskell?
14:17:19 <lambdabot> The answer is: Yes! Haskell can do that.
14:17:42 <dolio> Peaker: a `par` b `par` f a b adds extra overhead.
14:17:45 <copumpkin> cheater99: ##categorytheory
14:17:57 <copumpkin> cheater99: they're extremely simple structures, but lots of fun stuff can be done with them
14:18:07 <cheater99> but haskell categories are not mathematics theories!
14:18:08 <dolio> Assuming computation of f a b depends on one of a or b, you're creating a spark that will never be used for one of them.
14:18:22 <dolio> Depends immediately, that is.
14:18:37 <cheater99> copumpkin: from what i understand categories are basically like graphs.. then graphs on graphs.. then graphs on those
14:18:40 <copumpkin> cheater99: they sort of are
14:18:41 <cheater99> and so on, right?
14:18:42 <dolio> Or, may never be used.
14:18:46 <copumpkin> not graphs on graphs
14:18:47 <copumpkin> just graphs
14:18:51 <copumpkin> but graphs with all paths
14:18:58 <cheater99> but can't you point an arrow at an arrow?
14:19:02 <Taslem> Could I get some help installing Cairo?
14:19:05 <copumpkin> not in plain ol' categories
14:19:15 <copumpkin> once you move up you can
14:19:16 <Peaker> dolio: well, I was trying to understand why "pseq" was needed in the context of parallelism -- so it is not that it's needed to maximize parallelism (it's already possible with par alone) but to maximize parallelism with less unnecessary sparks, I guess
14:19:20 <ddarius> An (∞,1)-category would be like graphs on graphs.
14:19:23 <cheater99> "move up"?
14:19:40 <Berengal> Categories are typed monoids, no?
14:19:43 <copumpkin> cheater99: "higher category theory"
14:19:43 <ddarius> Peaker: The whole point of parallelism is performance.
14:19:46 <ddarius> Berengal: They are.
14:19:47 <hpc> Berengal: yes
14:19:51 <cheater99> ok.
14:20:04 <copumpkin> cheater99: but plenty can be done with the plain old categories before you get there
14:20:06 <monochrom> Taslem: yes. first you get c lib libgtk2.0-dev or some such if you're on linux.
14:20:08 <dolio> Peaker: I think it's pretty likely that evaluating 'f <v>' in parallel with all its arguments is likely to be a waste.
14:20:11 <hpc> categories form a monoid where mempty = id and mappend = (.)
14:20:28 <Peaker> though ideally -- the language has all the information about data-dependency (in the sense of args/return values) and the only information GHC should in theory need from the user for minimizing sparks with maximal parallelism -- is which computations are expensive enough to warrant sparks
14:20:30 <hpc> or rather, cat a a forms a monoid
14:20:31 <Berengal> dolio: Depends on the strictness of f, of course
14:20:35 <Taslem> I'm not on linux.
14:20:37 <cheater99> copumpkin: oh?
14:20:48 <dolio> Berengal: Sure.
14:20:59 <cheater99> copumpkins: but if it's "just a graph", then why not just call it a graph?
14:21:04 <copumpkin> cheater99: I mean there are lots of really interesting structures you can explore on plain old 1-categories
14:21:07 <dolio> Peaker: Because it would have to be doing quite a bit of work while not looking at any of them for that to be a win.
14:21:08 <copumpkin> it isn't "just" a graph
14:21:18 <cheater99> what's the difference then?
14:21:43 <aristid> hpc: Endo could be extended to all categories, eh?
14:21:45 <copumpkin> cheater99: it's a multigraph with loops such that if there is a path between two objects, there's an edge between them
14:22:02 <Peaker> dolio: Yeah, I understand -- the only thing I am missing is why we can't give the minimum amount of information that GHC lacks (which computations are expensive enough to warrant sparks) and have GHC/RTS infer the rest of th decisions for parallelism. What other information is missing to deduce a good evaluation order?
14:22:02 <cheater99> is that all?
14:22:06 <christo_m> http://hpaste.org/45468/lua_parsing
14:22:07 <copumpkin> cheater99: yeah
14:22:09 <cheater99> ok
14:22:12 <christo_m> can anyone explain how to get rid of this error
14:22:18 <cheater99> why is that so cool?
14:22:19 <copumpkin> cheater99: well, there are certain conditions on it
14:22:27 <aristid> data EndoCat c a = EndoCat { runEndoCat :: c a a }
14:22:29 <christo_m> apparently symanticaly, a block and chunk are equivalent, but its posing some issues for me
14:22:32 <cheater99> oh
14:22:34 <cheater99> what conditions?
14:22:48 <niteria> (&&) (n > m + 1) $ (==) x $ n*(n+1)*(2*n+1) - m*(m+1)*(2*m+1) looks lispy
14:22:54 <monochrom> Taslem: then I refer you to http://article.gmane.org/gmane.comp.lang.haskell.cafe/87456/ if you're on windows
14:22:56 <Peaker> dolio: viewed from this angle, par/pseq seem like low-level annotations whereas some sort of "this_computation_is_expensive" seems like a higher-level annotation
14:23:02 <aristid> niteria: that's pretty unidiomatic
14:23:15 <niteria> can I make it better without additional parenthesis
14:23:16 <niteria> ?
14:23:23 <ddarius> Peaker: They are low-level annotations.
14:23:34 <aristid> niteria: i would make (&&) and (==) infix.
14:24:29 <Peaker> ddarius: I remember being disappointed/surprised that Haskell couldn't auto-parallelize everything, given purity.. Of course I was naive to think it would be possible -- but am I still naive to think "this_computation_is_expensive" should be enough of an annotation? :)
14:24:42 <copumpkin> cheater99: edges are called morphisms or arrows and vertices are called objects. A category has an operation called composition saying that if you have a -> b and b -> c, you can get a -> c, and every object has an identity morphism that when composed on either side with other arrows to and from that object is equal to the other arrow
14:24:48 <niteria> (n > m + 1) && x == n*(n+1)*(2*n+1) - m*(m+1)*(2*m+1)
14:24:59 <niteria> I hope it does what I mean
14:25:00 <dolio> Peaker: I don't know if anyone's ever tried that angle.
14:25:03 <ddarius> Peaker: It's trivially possible to parallelize everything in Haskell.
14:25:05 <aristid> niteria: n > m + 1 && x == n*(n+1)*(2*n+1) - m*(m+1)*(2*m+1)
14:25:10 <cheater99> copumpkin: doesn't sound too difficult
14:25:20 <Berengal> Peaker: I think what you're asking for requires whole-program optimization
14:25:24 <christo_m> Anyone good with Parsec here?
14:25:24 <copumpkin> cheater99: it isn't, but you can get remarkably abstract with the basic framework
14:25:26 <cheater99> copumpkin: so what's the most unexpected thing you can do with 'em?
14:25:26 <dolio> I'm not exactly sure how to add it to the language, either.
14:25:28 <Peaker> ddarius: sorry, I meant beneficially auto-parallelize everything :)
14:25:45 <niteria> oops
14:25:46 <copumpkin> cheater99: "do" is a strong word. what can you do with a semiring?
14:26:07 <Peaker> dolio: maybe have a function that's semantically "id", but annotates the computation as worthy of a spark's overhead?
14:26:10 <niteria> aristid: I thought == bound stronger
14:26:12 <ddarius> Peaker: You can build you annotation on top of par and pseq.
14:26:14 <copumpkin> cheater99: we can model all sorts of things as categories and find possibly unexpected connections between them
14:26:19 <niteria> thanks anyway
14:26:22 <aristid> niteria: no. but you can ask ghci :)
14:26:24 <aristid> :info ==
14:26:30 <aristid> :info &&
14:26:32 <aristid> :info >
14:26:33 <aristid> and so on
14:26:50 <monochrom> in fact, :info == && >  to collect them all!
14:26:59 <Peaker> ddarius: not sure the "this_is_expensive" (semantically id) is implementable without magic
14:27:00 <aristid> monochrom: oh, i did not know that trick
14:28:10 <copumpkin> Peaker: "this_is_expensive" meaning evaluating it to whnf is expensive?
14:28:13 <Berengal> Peaker: It's not, but par and pseq are, sort of. They're only a foreign call away anyway, while "this_is_expensive" would require compiler support
14:28:20 <Peaker> copumpkin: I guess so
14:28:21 <copumpkin> if it returns a structure containing expensive thunks that's tricky
14:28:52 <monochrom> @free fst
14:28:52 <lambdabot> f . fst = fst . $map_Pair f g
14:29:19 <copumpkin> :t assoc
14:29:20 <lambdabot> Not in scope: `assoc'
14:29:38 <Peaker> Berengal: I understand why par/pseq would be implemented before something that requires compiler support, but I think this_is_expensive could be much easier to get right (if it is implementable reasonably at all)
14:29:56 <cheater99> is it possible to force haskell to evaluate a computation?
14:30:10 <Peaker> copumpkin: the thunks inside it were also generated with code that could have annotated the thunks it generates
14:30:15 <niteria> (/=) [] $ filter (check n) $ map pot $ divisors (6*n)
14:30:27 <dolio> Peaker: I think part of the issue is: you need two expensive things to derive benefit.
14:30:36 <dolio> One to fork, and one to evaluate while it's forked.
14:30:40 <niteria> it seems application is strongest
14:30:48 <Peaker> dolio: or N things for N processors?
14:31:02 <gwern> > 2004 - 1987
14:31:03 <lambdabot>   17
14:31:26 <dolio> I guess. But perhaps that can come from the expensive things identifying expensive sub-things.
14:31:50 <ddarius> thisIsExpensive = Left; thisIsCheap = Right; parPlus (Left e) b = e `par` b; parPlus (Right e) b
14:31:53 <Peaker> dolio: I wonder how much overhead it would be to add a test on the "parallel evaluation queue size" to each evaluation of a thunk annotated with "expensive" -- so that if it is lower than a threshold, it spawns a spark for that evaluation into the queue and goes to the next independent thing
14:31:59 <copumpkin> cheater99: anyway, there are a lot of people in ##categorytheory if you're interested in hearing more
14:32:12 <niteria> ([] /=) $ filter (check n) $ map pot $ divisors (6*n) works too
14:32:33 <cheater99> copumpkin: let me hang out :)
14:32:39 <ddarius> niteria: Never, ever compare [] for (in)equality.
14:32:43 <dmitryguru> hello
14:32:47 <dolio> But, you need two independent expensive things at the same time before you can do any parallelizing, and marking single things as expensive still requires work for the compiler.
14:32:57 <dmitryguru> does anyone here know any java? im having so much trouble and I reallly need some help
14:33:08 <dolio> Not that that work couldn't be done, but it hasn't, I guess.
14:33:15 <dmitryguru> just an intro to computer science assigment
14:33:31 <Peaker> dolio: yeah, it seems like it would also need the compiler to know about functions being strict on multiple arguments they have -- even before they actually use them
14:33:36 <Berengal> Peaker: Haskell programs don't have a sequence, but a this_is_expensive annotation depends on sequence to be useful. That's why par doesn't just take one argument, so you can declare two values to be chronologically related
14:33:40 <ryant5000> dmitryguru: try ##java
14:33:50 <niteria> any (check n) $ map pot $ divisors (6*n) works too
14:33:51 <niteria> ok
14:33:55 <niteria> thats better
14:34:10 <aavogt> @ty ([]/=)
14:34:11 <lambdabot> forall a. (Eq a) => [a] -> Bool
14:34:37 <Peaker> Berengal: you don't actually need a sequence -- you just need to be able to figure out that a function will (at least likely) use an extra argument or expression besides the current one, and if it is "expensive" you can spark it
14:35:16 <dolio> Peaker: And Berengal makes another good point. a `par` b `pseq` f a b groups things together in a way that "this is expensive" doesn't.
14:35:29 <dolio> When you want f a b, it makes sense to evaluate a and b in parallel first.
14:35:29 <acowley> niteria: are you just trying to improve the style of that line?
14:35:37 <aavogt> > (length "[]/=", length "not.null")
14:35:38 <lambdabot>   (4,8)
14:35:39 <dolio> You don't want to spin evaluating any old thing.
14:35:51 <Peaker> dolio: but issuing a spark for "a" may actually have it sit in a queue for a while?
14:36:30 <RyanPridgeon> hello
14:36:37 <RyanPridgeon> does anyone know why im getting this; "Last generator in do {...} must be an expression" ?
14:36:46 <mauke> because your code is wrong
14:36:53 <Berengal> RyanPridgeon: "x <- y" is not an expression
14:37:03 <copumpkin> nor is let x = y
14:37:27 <RyanPridgeon> whats a generator?
14:37:30 <RyanPridgeon> this is my code btw http://pastebin.com/UriGRwdK
14:37:36 <Peaker> dolio, Berengal: I agree that the par/pseq conveys more useful information to the compiler about data locality that "This is expensive" doesn't -- sounds like it could be mostly figured-out from the data-flow though?
14:37:39 <c_wraith> Sometimes that error message can be caused by a mis-parse, like an extra close paren, or something
14:37:44 <monochrom> the "x <- y" syntax is a generator
14:37:49 <mauke> RyanPridgeon: your indentation is broken
14:37:59 <c_wraith> Or, yes, broken indentation
14:38:01 <warzl> why is it so hard for some programmers to leverage abstraction?
14:38:15 <RyanPridgeon> that would cause the error? or do you just mean its making it hard to read 
14:38:20 <Berengal> RyanPridgeon: You wouldn't happen to use tabs for indentation, do you?
14:38:22 <c_wraith> that causes it
14:38:23 <dolio> Peaker: This example is contrived, but for instance: length [expensive (ack 4 4) + expensive (ack 4 4)].
14:38:25 <monochrom> because it is so hard for some humans to leverage abstraction, warzl
14:39:00 <mauke> RyanPridgeon: how does the compiler know where a 'do' block ends?
14:39:04 <monochrom> I should just block the css of pastebin.com :)
14:39:07 <dolio> Peaker: You don't want to fork threads to evaluate the Ackermann function even though they're expensive, because they're useless.
14:39:11 <RyanPridgeon> i dont know
14:39:17 <RyanPridgeon> im very new to haskell
14:39:19 <mauke> RyanPridgeon: indentation
14:39:23 <RyanPridgeon> ah ok
14:39:29 <warzl> why do we hire programmers that can't abstract well?
14:39:29 <hpc> aristid: sorry, getting food; RE: 17:32 < aristid> hpc: Endo could be extended to all categories, eh?
14:39:36 <dolio> But, if you have something that demands the result, it may make sense to evaluate them in parallel.
14:39:38 <hpc> aristid: yes, i think so
14:39:42 <warzl> and then promote them
14:39:54 <niteria> acowley: yes
14:39:56 <hpc> data Endo arr a = Endo {appEndo :: arr a a}
14:39:56 <Berengal> warzl: Because interviews focus on rote learning
14:40:09 <Berengal> warzl: And we promote them to keep them from causing harm
14:40:18 <RyanPridgeon> so
14:40:21 <RyanPridgeon> hm
14:40:39 <warzl> Berengal, sounds about right. I've never had an interview that tested my abstraction ability
14:41:02 <Peaker> dolio: Sure, I think all sparks/evaluations are pull-based.. the evaluation of (+) should somehow be aware (+) is strict in both args, so it can spark both (or as an optimization, instead of sparking the last spark, if it has nothing more to do, it can directly start evaluating it)
14:41:24 <acowley> niteria: any (check n) . map pot . divisors $ 6*n
14:41:51 <dolio> Peaker: So, that's at least starting to sound like a more difficult problem, I think.
14:41:52 <monochrom> eh? someone who asks for ackermann deserves whatever fork bomb that follows :)
14:41:54 <c_wraith> warzl: here's a fun one I ask people who will be working in haskell.  "Explain to me what this 'monad' thing is".  No one's come even reasonably close to giving me an answer that indicates they grasp why the abstraction exists.
14:41:57 <Peaker> dolio: the "expensive" mark matters for something you need to evaluate anyway -- makes it be sparked rather than evaluated (if we have more expressions we know are needed)
14:42:01 <warzl> The problem with promoting them is that they end up hiring programmers who, like themself, cannot abstraction
14:42:08 <warzl> that's what happened where I work
14:42:22 <warzl> *abstract
14:42:46 <monochrom> HR people can't abstract. and they guard hiring.
14:43:00 <dons> heh
14:43:05 <warzl> c_wraith, I would like to try to answer :)
14:43:12 <Peaker> dolio: I think the main difficulty I missed - is that of identifying future-needed evaluations.. i.e: in a naive implementation of (+) that cases over the first arg -- how do you know if you're going to need the 2nd arg?  in (a `par` b ...) it is explicitly mentioned.  though if you think about it -- (+) for inductive naturals may not actually need the latter arg
14:44:17 <Peaker> i.e: a `par` b `pseq` a+b thus may not make sense if the (+) is for inductive naturals in some cases
14:44:19 <monochrom> so for example you (team leader) has interviewed Erdös and has asked HR to hire him. well HR looks at his CV and goes "why the hell has he been homeless and employerless for the last 10 years? reject"
14:44:58 <copumpkin> c_wraith: not one person? :(
14:45:31 <Berengal> monochrom: I'd be more concerned about his health, to be honest :P
14:45:50 <acowley> Where do you work that hiring Erdos is your top priority?
14:45:56 <Peaker> dolio: the awesome thing about "this_is_expensive" annotations, is that they're probably much much easier to automatically derive from profile-results (e.g: correlate argument values with expensiveness, and set threshold for arguments)
14:46:08 <c_wraith> warzl: go ahead.
14:46:16 <dolio> Yeah, that's true.
14:46:22 <Berengal> Peaker: Have profiles drive the annotations automatically!
14:46:24 <copumpkin> c_wraith: anyone say they were burritos?
14:46:28 <RyanPridgeon> which indentation needs to line up for the do blocks?
14:46:36 <RyanPridgeon> is it at the d or after the space?
14:46:38 <c_wraith> copumpkin: Most people tell me what monads can be used for.  No one's told me why it's a useful abstraction
14:46:52 <int80_h> when I see this "Module foo (Bar (..))", what is the meaning of (..)?
14:46:54 <c_wraith> copumpkin: burritos would be a better answer than "it's about hiding state!"
14:46:54 <Berengal> RyanPridgeon: the first character after "do" determines the indentation level
14:46:58 <dolio> That'd solve the problem with 'this-is-expensive' still being ugly when littered all over your program. :)
14:47:01 <copumpkin> c_wraith: ah
14:47:13 <Berengal> RyanPridgeon: Alternatively, use brackets and semi-colons
14:47:23 <copumpkin> 2 + !!5
14:47:29 <copumpkin> where !! means that 5 is very expensive
14:47:31 <RyanPridgeon> you can use brackets and semi colons?
14:47:35 <mauke> RyanPridgeon: sure
14:47:36 <RyanPridgeon> C-style, like { bla; } ?
14:47:39 <mauke> exactly
14:47:45 <acowley> don't
14:47:45 <monochrom> c_wraith: I feel that it depends sensitively on how you phrase your question. "what is monad?" is interpreted a million different ways, for example.
14:47:46 <RyanPridgeon> ah nice
14:47:49 <mauke> do { putStr "hi"; x <- getLine; return 42 }
14:47:51 <Peaker> dolio: Well, par/pseq are not much better, especially as they may leak abstractions, implementation details about the machine (e.g: price of non-locality), ..
14:47:52 <acowley> work out your white space issues
14:47:52 <copumpkin> RyanPridgeon: for some values of nice
14:48:01 <RyanPridgeon> well this is a huge mess
14:48:03 <acowley> it will pay off in the long run
14:48:06 <mauke> RyanPridgeon: return () is a no-op, btw
14:48:08 <dolio> Peaker: They're certainly not better.
14:48:27 <monochrom> if you explicitly ask "why/how does monad help abstraction", that is clear
14:48:28 <niteria> acowley: cool, thanks
14:48:32 <hpc> int80_h: it means export the type Bar and all its constructors/accessors
14:48:45 <hpc> iirc
14:48:45 <Peaker> c_wraith: are you posing the question for discussion, or are you asking?
14:48:57 <c_wraith> monochrom: the phrasing I generally use is "Suppose you have a co-worker who doesn't know Haskell, but wants to learn it.  They ask you what the heck the whole 'monad' thing is about.  What do you tell them?"  I give bonus points if they answer "I tell them not to worry about it." :)
14:49:04 <int80_h> hpc: thanks :)
14:49:25 <monochrom> alright that's also a clear question
14:49:28 <dolio> Peaker: Ultimately, it's better, though nowhere near ideal, to build combinators out of par and pseq instead of putting them in your program directly.
14:49:35 <cheater99> c_wraith: a monoid in the category of endofunctors
14:49:51 <copumpkin> cheater99: most people who cite that probably don't know what it means
14:49:51 <clsmith> c_wraith: unfortunately i have yet to recieve a clear answer for that from anyone
14:49:55 <acowley> you have to follow that with ", what's the problem?"
14:49:56 <monochrom> at least I did give my answer at http://groups.google.com/group/comp.lang.functional/msg/f42e5d7169837b37
14:50:00 <cheater99> copumpkin: provably so
14:50:03 <Peaker> dolio: but I feel it is sad that we have purity -- but are not using all the benefits purity can give us
14:50:07 <dolio> Though that still leaves you with a mess of different functions that are all denotationally the same.
14:50:19 <cheater99> copumpkin: but the axioms do look roughly the same
14:50:26 <cheater99> copumpkin: i remember that much :d
14:50:28 <cheater99> :D
14:50:28 <Berengal> c_wraith: Monads are for putting one thing after another in a way that doesn't specify what that actually means.
14:50:50 <cheater99> c_wraith: monads are like burritos
14:51:09 <clsmith> Berengal: like steps in front of man who walks sideways?
14:51:25 <copumpkin> "monads are for dealing with side effects in haskell"
14:51:26 * copumpkin runs
14:51:33 <KirinDave> Ha
14:51:36 <c_wraith> My answer, assuming that "don't worry about it" is rejected, would be along the lines of "monads are a pattern of composition that allows you to build large values/computations from smaller ones in a common way."
14:51:38 <KirinDave> I heard monads are like horses
14:51:54 <mauke> monads are like an analogy
14:52:00 <KirinDave> Or was it circus peanuts?
14:52:00 <elliottt> KirinDave: no, it's buritos that you're thinking of.
14:52:03 <acowley> Ah, so we're hiring Erdos to finally teach copumpkin some math
14:52:07 <Berengal> I liked the unicorn analogy...
14:52:17 <KirinDave> Oh, they're like objects!
14:52:25 <cheater99> c_wraith: but you've just defined function composition
14:52:33 <clsmith> okay can someone please answer this question i have: why are monads used for anything other than I/O? surely besides that everything is predeterminable?
14:52:46 <cheater99> elliottt: thanks for supporting my point
14:52:48 <ddarius> cheater99: He's just defined any n-ary operation at all.
14:52:51 <c_wraith> cheater99: function composition is one pattern for doing that.  It's a slightly different pattern than the one monads describe.
14:52:53 <RyanPridgeon> does anybody know a plce to learn how to indent properly?
14:52:56 <RyanPridgeon> i cant get this at all
14:53:05 <ddarius> For any n > 0.
14:53:07 <KirinDave> clsmith: That's a weird question.
14:53:15 <clsmith> KirinDave: how so?
14:53:20 <cheater99> c_wraith: i don't see that
14:53:22 <acowley> RyanPridgeon: still with the do blocks?
14:53:23 <clsmith> i am genuinely really confused about this
14:53:24 <KirinDave> clsmith: Why do people use the singleton pattern (besides, of course, a universal hatred for other men)
14:53:27 <RyanPridgeon> yeah
14:53:27 <mauke> clsmith: what do monads have to do with predeterminism?
14:53:40 <KirinDave> clsmith: Monads are an observation. "Hey, a lot of things look like THIS, so let's formalize THIS."
14:53:44 <dobblego> KirinDave: monad metaphors serve no educational purpose
14:53:44 <c_wraith> mauke: I think he means purity/deterministic calculation
14:53:48 <mauke> yes
14:53:52 <KirinDave> dobblego: Indeed, I was making a joke about that.
14:53:57 <clsmith> mauke: surely beisdes monads every function, given a parameter, will always return the same value
14:53:57 <mauke> what's that to do with monads?
14:54:00 <luite_> clsmith: for most things other than IO, you can do exactly the same without monads... except that the pattern is just appropriate, and can simplify the code
14:54:01 <acowley> RyanPridgeon: when you write "do foo", subsequent lines that are part of the do block should begin with their first non-whitespace character underneat the "f"
14:54:21 <mauke> clsmith: surely besides linked lists every function, given a parameter, will always return the same value
14:54:22 <dobblego> clsmith: monads do not change the fact that all functions return the same value for given parameters
14:54:26 <RyanPridgeon> i must be doing something else wrong then
14:54:34 <mauke> clsmith: linked lists aren't functions, so that's kinda irrelevant
14:54:45 <RyanPridgeon> are there any indent rules for case ?
14:54:47 <acowley> mauke: most programmers would call getch() a function
14:54:49 <RyanPridgeon> like case bla of
14:54:53 <acowley> which is hte problem
14:54:57 <mauke> acowley: only in DOS
14:55:00 <clsmith> dobblego: but they do. readFile can return different values
14:55:03 <Kaidelong> luite_: "
14:55:04 <mauke> clsmith: no, it can't
14:55:07 <Kaidelong> other than IO"?
14:55:08 <dobblego> clsmith: no, actually, it can't
14:55:08 <clsmith> luite_: is that seriously it?
14:55:13 <c_wraith> in any case.  My point is that monads aren't special.  They're just one pattern of composition, out of many.  The pattern happens to have many uses and sufficient power to encode turing-complete logic, so it's a handy abstraction.  But that's all it is.  An abstraction.
14:55:29 <luite_> Kaidelong: you cannot implement ST in pure haskell
14:55:30 <clsmith> dobblego: but it can. readFile "eg" will return different values depending on the time of day
14:55:33 <acowley> RyanPridgeon: just indent the branches of the case to the right of the "c" in "case" (I use two spaces)
14:55:36 <mauke> clsmith: no, it won't
14:55:38 <mauke> clsmith: getChar isn't even a function
14:55:43 <dobblego> clsmith: and even if it did, monads are totally irrelevant there
14:55:43 <KirinDave> clsmith: And monads AREN'T a universally applicable pattern. There are other ways of composing computations that are related but different. It's just monads sit in the middle of the utility/complexity spectrum.
14:55:43 <mauke> it's a constant
14:55:44 <Berengal> clsmith: readFile isn't a function
14:55:47 <KirinDave> clsmith: You might as well ask why everything is a Functor?
14:55:48 <dobblego> IO may be a monad, but it is a zillion other things -- that it is a monad is totally irrelevant
14:55:51 <RyanPridgeon> hmm i must be doing something else wrong then
14:55:53 <mauke> Berengal: yes, it is
14:56:07 <RyanPridgeon> Last generator in do {...} must be an expression......
14:56:13 <Berengal> mauke: Oh yes, you're right
14:56:15 <dobblego> readFile :: FilePath -> RealWorld -> (RealWorld, String)
14:56:18 <Kaidelong> luite_: IO does not require the same extensions as ST though does it?
14:56:20 <mauke> dobblego: oh god, no
14:56:22 <c_wraith> RyanPridgeon: are you using tabs in your source?
14:56:27 <RyanPridgeon> spaces
14:56:30 <Berengal> dobblego: No, readFile :: FilePath -> IO String
14:56:37 <dobblego> Berengal: that's what I said
14:56:42 <warzl> god I need a job doing functional programming
14:56:43 <mauke> there is no RealWorld
14:56:47 <mauke> and I hate that "explanation"
14:56:56 <luite_> clsmith: yes, the list monad is used because its bind (>>=) and return methods (and that is what the whole monad is, basically) make sense in a lot of situations, so the code is simpler than trying to do the same without the monad
14:56:56 <KirinDave> warzl: They're not hard to find.
14:56:57 <warzl> i can't take these imperative programmers any more
14:56:57 <clsmith> okay ... so ... how do monads work if they .. aren't functions (:???!?!!)
14:57:00 <Berengal> dobblego: Fake RealWorld state is fake
14:57:04 <RyanPridgeon> this is it currently http://pastebin.com/iRrUfVYD
14:57:05 <dobblego> mauke: me too, except to force the admission that it always returns the same value
14:57:06 <KirinDave> warzl: Sonian was hiring recently.
14:57:07 <mauke> clsmith: every monad works differently
14:57:19 <mauke> dobblego: strongly disagree
14:57:26 <dobblego> clsmith: monads and IO have nothing to do with each other
14:57:29 <mauke> dobblego: haskell doesn't actually pipe the universe through your computer
14:57:32 <elliottt> Kaidelong: IO doesn't require the same extensions as ST, as you can't run it from a pure context.
14:57:33 <warzl> I think I'll get out of the game industry and just be a function programmer
14:57:40 <warzl> funk it
14:57:41 <luite_> clsmith: the same goes for State (not ST, that's a different, much more complex one) monad, you can do the same, but it just makes sens to use the Monad, because it makes the code simpler and more readable
14:57:44 <dobblego> mauke: nor does it pipe the physical number 2 when you add 2+2
14:57:47 <RyanPridgeon> oh my god i didnt have one lined up
14:57:49 <RyanPridgeon> now it works fine
14:57:49 <RyanPridgeon> haha
14:57:50 <elliottt> Kaidelong: no need to reign in the mutation when you're in a context where mutation is welcome :)
14:57:53 <mauke> dobblego: there is no physical number 2
14:57:58 <dobblego> mauke: precisely
14:58:07 <mauke> there is a world, though
14:58:10 <luite_> Kaidelong: IO doesn't require a rank 2 type, but I believe its implementation is very similar to ST
14:58:14 <dobblego> there is a representation of the concept of 2
14:58:26 <acowley> RyanPridgeon: figure out how to make your editor help you with this
14:58:41 <RyanPridgeon> ah i will later
14:58:46 <RyanPridgeon> for now im in short time
14:58:46 <acowley> RyanPridgeon: with haskell-mode in emacs, hitting tab a bunch will cycle through possible indentations
14:58:54 <Berengal> luite_: ST and IO *are* the same implementation under the hood in GHC
14:58:56 <clsmith> so ... how do monads work in terms of graph reduction, and why do we need monads other than I/O, besides (as luite_ is saying) for simplicity?
14:59:03 <mauke> dobblego: but there is no representation of the real world
14:59:05 <acowley> RyanPridgeon: it's a *huge* help if your editor does that stuff for you as much as possible
14:59:06 <RyanPridgeon> to be honest with you i didnt touch haskell before today, and had an assignment due in less than an hour
14:59:08 <RyanPridgeon> haah
14:59:13 <dobblego> mauke: data RealWorld
14:59:14 <mauke> clsmith: we don't need monads for I/O
14:59:22 <mauke> dobblego: doesn't exist
14:59:25 <RyanPridgeon> massive thanks for the help
14:59:39 <clsmith> mauke: i figure we only need to specific time, right? why do we use monads for I/O?
14:59:41 <dobblego> neither does the constructor 2
14:59:45 <copumpkin> clsmith: we don't _need_ monads for anything at all
14:59:51 <copumpkin> clsmith: just like we don't need the Num typeclass
14:59:54 <mauke> clsmith: no, IO happens to form a monad
14:59:55 <clsmith> so why are they used?
14:59:57 <elliottt> clsmith: what do you mean by time?
15:00:02 <KirinDave> clsmith: Because it's convenient.
15:00:04 <copumpkin> clsmith: because they're handy, just like Num
15:00:05 <Berengal> clsmith: Monads for IO are used because they're convenient
15:00:05 <dobblego> clsmith: you need to stop conflating IO and monads
15:00:07 <mauke> clsmith: but we could use the IO functions without defining a Monad typeclass
15:00:15 <clsmith> elliottt: reading at different times would result in a different value
15:00:19 <KirinDave> clsmith: Monads in Haskell are an abstraction. They're just A Way Of Doing Things.
15:00:31 <mauke> clsmith: do you know Java?
15:00:36 <clsmith> mauke: yeah
15:00:38 <elliottt> clsmith: so instead of an IO monad we'd have an frp like thing?
15:00:42 <mauke> clsmith: javascript?
15:00:52 <clsmith> mauke: various languages, yes
15:00:52 <dobblego> clsmith: the relationship of IO to monads is the same one as bananas to reversing a list. You can reverse a list of bananas, but this doesn't mean that reverse function is related to bananas.
15:01:13 <clsmith> so you're (all) telling me we don't need monads?
15:01:15 <mauke> clsmith: so why do we use Comparable in Java?
15:01:24 <clsmith> why do monads exist in haskell then, seemingly as a primitive?
15:01:31 <mauke> it's not a primitive
15:01:36 <mauke> it's a normal library
15:01:51 <Taslem> Monads encapsulate data in a way that can protect it from functions. In terms of IO, it maintains purity.
15:01:53 <mauke> why does Comparable exist in Java?
15:01:57 <dobblego> clsmith: the monad abstraction cannot be represented in Java -- since its type system is too weak -- but at a first-order level (generics), you can see the same usefulness by Comparator
15:02:00 <clsmith> mauke: it isn't, though. do notation, at least, is built in. i'm not sure to what extent they are
15:02:08 <luite_> clsmith: in practice, you do need at least the IO monad, and possibly ST, because so much is built around them... but not because some inherent functionality that only monads provide. in fact, haskell started without the IO monad
15:02:14 <mauke> clsmith: do notation is, yes. but it simply desugars to calls to >>=
15:02:18 <dobblego> clsmith: Java has for notation for java.lang.Iterable, so what?
15:02:22 <mauke> and >>= is a library function
15:02:39 <elliottt> clsmith: monads aren't a primitive in haskell
15:02:42 <mauke> you don't need "the IO monad", you need IO
15:02:43 <elliottt> on the IO monad is primitive
15:02:57 <mauke> I wish people would stop saying "monad" every time they mention IO
15:03:01 <Taslem> How exactly do State monads work?
15:03:05 <acowley> I wish IO wasn't a monad. There, I said it.
15:03:05 <Berengal> clsmith: do notation is a *very* simplistic syntactic sugar. I'm pretty sure Java's foreach is more complicated...
15:03:19 <elliottt> acowley: why's that?
15:03:23 <dobblego> Java's foreach works on any java.lang.Iterable or array
15:03:32 <acowley> elliottt: because we (programmers) end up in discussions like this
15:03:42 <acowley> and it's all backwards
15:03:45 <elliottt> acowley: if we didn't talk about monads, we'd talk about something else :)
15:03:48 <Berengal> dobblego: Two cases. Do notation only works on monads, nothing else
15:03:49 <luite_> Taslem: you can find out by looking at its source, but actually you could write it yourself and you'd likely end up with almost the same code, once you figure out what you want it to do
15:03:54 <clsmith> so -- and i suppose this is the question i'm asking -- how does a non-monad, then, assuming they are not primitives, escape the haskell lazily-evaluated every-function-equals-a-value universe?
15:03:59 <companion_cube> Taslem, by composing functions that pass a state around
15:04:00 <elliottt> acowley: and it's a useful abstraction
15:04:02 <acowley> new Haskellers get the impression IO works in Haskell because it is a monad
15:04:03 <mauke> clsmith: it doesn't
15:04:11 <elliottt> acowley: being able to completely customize your programming language is a nice feature
15:04:12 <dobblego> Berengal: yep, and only because Java is broken to begin with
15:04:18 <mauke> clsmith: ... and how would monads change this?
15:04:25 <Kaidelong> IO works in haskell because it is IO
15:04:34 <companion_cube> yeah, in java you cannot do foreach on an Iterator :/
15:04:35 <acowley> monads are great! And when you find yourself needing to collapse the structure of a type, they make all kinds of sense.
15:04:39 <Berengal> dobblego: It's not broken, it clearly works, it just doesn't work *well*
15:04:43 <acowley> but we have IO
15:04:45 <acowley> it's just IO
15:04:47 <clsmith> mauke: so how does anything which is not predeterminable (and hence cannot be lazily evaluated) return X at time N but not M? 
15:04:49 <dobblego> clsmith: I once gave a talk that undermined the conflation that you keep alluding to
15:04:53 <mauke> clsmith: it doesn't
15:04:55 <copumpkin> clsmith: it doesn't
15:05:14 <clsmith> but getLine clearly returns a value that it doesn't return when it's been changed
15:05:16 <copumpkin> clsmith: we build up an abstract description of what we want to do that interacts with the outside world, then the runtime runs that (conceptually)
15:05:19 <mauke> clsmith: no, it doesn't
15:05:21 <nazgjunk> acowley: that's definitely the impression I've had so far - I haven't reached that bit in lyah, but from what I hear around me monads and io are tightly associated :P
15:05:25 <Berengal> clsmith: getLine doesn't return anything. It's not a function
15:05:28 <mauke> clsmith: getLine doesn't return anything because it's not a function. it's a constant
15:05:34 <copumpkin> clsmith: getLine is a description of a computation that returns a string represneting a line
15:05:35 <acowley> getLine is a value
15:05:43 <clsmith> but if it were a constant surely it would return the same thing every time
15:05:46 <clsmith> but it doesn't
15:05:47 <acowley> the magic non-function part is IO
15:05:53 <copumpkin> @hoogle getline
15:05:53 <lambdabot> Prelude getLine :: IO String
15:05:54 <lambdabot> Data.ByteString getLine :: IO ByteString
15:05:54 <lambdabot> System.IO getLine :: IO String
15:05:54 <Berengal> clsmith: Constants don't return anything either. It's a value
15:05:56 <mauke> clsmith: if it were a constant, it wouldn't return anything
15:06:07 <copumpkin> clsmith: you're confusing evaluation with execution
15:06:13 <acowley> it doesn't return anything ever
15:06:17 <mauke> forget execution
15:06:18 <clsmith> so why does getLine change value?
15:06:21 <mauke> clsmith: it doesn't
15:06:21 <dobblego> clsmith: the IO String is very very different to String -- the function doesn't just return "a String with some IO attached to it"
15:06:22 <copumpkin> clsmith: think of IO as a string of python code that we feed into the python evaluator later
15:06:30 <Taslem> Strictly speaking, getLine is defined as hGetLine commandline   or something like that.
15:06:31 <acowley> IO is magic, monads aren't
15:06:38 <Berengal> clsmith: If you write a java program that reads a line then prints it out, it would do different things when you run it at different times, but the program itself doesn't change.
15:06:47 <Taslem> Where the handle passed is the standard input/output stream in the program.
15:06:52 <copumpkin> clsmith: sticking IO actions together is appending these strings of python so that they do things one after the other
15:06:55 <clsmith> Berengal: of course, but java is imperative, not functional, that's not the point
15:06:56 <mauke> clsmith: http://mauke.dyndns.org/stuff/haskell/how-to-io.html - may or may not help you
15:06:58 <dobblego> so now that we've told you all the things that monads are not...
15:07:05 <copumpkin> clsmith: but the python string for getting a line is always the same
15:07:17 <dobblego> clsmith: Java has an embedded functional language
15:07:26 <companion_cube> clsmith, it is the point, because the value getLine is like a piece of code, it does not change, only its input/output changes
15:07:29 <dobblego> clsmith: all 51 Java operators are functions
15:07:34 <companion_cube> i love this chan \o/
15:07:34 <Berengal> clsmith: It has nothing to do with imperative vs functional. The program still doesn't change. That program is a constant, and so is getLine in Haskell
15:07:41 <dobblego> clsmith: so is every library that is mentioned in the JLS and VMS
15:08:04 <clsmith> but clearly the value that getChar returns, at any given instant, is different!
15:08:12 <mauke> clsmith: getChar doesn't return values
15:08:12 <clsmith> so how can that be, given lazy evaluation?
15:08:14 <copumpkin> clsmith: have you been reading what I wrote?
15:08:14 <mauke> clsmith: getChar doesn't return values
15:08:17 <mauke> clsmith: getChar doesn't return values
15:08:21 <companion_cube> :D
15:08:25 <Berengal> clsmith: getChar isn't evaluated.
15:08:28 <clsmith> copumpkin: i have yes
15:08:29 <mauke> Berengal: yes, it is
15:08:30 <Berengal> clsmith: Only functions are evaluated
15:08:32 <companion_cube> well, good night
15:08:34 <mauke> Berengal: wtf?
15:09:06 <copumpkin> clsmith: say you had a string containing the python code for getting a line.
15:09:10 <copumpkin> clsmith: would that string change?
15:09:16 <copumpkin> this is python _source code_
15:09:21 <Berengal> mauke: well, it's a constant. It doesn't need evaluation
15:09:29 <copumpkin> Berengal: sure it does
15:09:31 <copumpkin> this is haskell
15:09:35 <clsmith> copumpkin: but that's irrelevant! python isn't purely functional
15:09:36 <Kaidelong> @ty getChar
15:09:37 <lambdabot> IO Char
15:09:43 <copumpkin> clsmith: no, I mean in haskell
15:09:50 <copumpkin> clsmith: say IO was just a wrapper around a string of python code
15:09:54 <mauke> clsmith: what does "purely functional" have to do with this?
15:09:56 <Kaidelong> getChar is a program that outputs a Char
15:10:28 <companion_cube> it reminds me of some blog post which states that C source code is purely functional
15:10:30 <Kaidelong> getChar >>= print is a program that gets a character and prints out that character surrounded by single quotes as a side effect and then outputs nothing
15:10:34 <KirinDave> Kaidelong: Isn't it a program that, given an IO context, gets a char and a new modified IO context? :)
15:10:41 <mauke> clsmith: btw, it would help if you're familiar with XmlHttpRequest and setTimeout
15:10:47 <mauke> KirinDave: no, it's an imperative program
15:10:49 <Kaidelong> KirinDave: Details! Yes.
15:10:52 <clsmith> my confusion is that surely if everything is guaranteed to return the same value (it is "referentially transparent?") it cannot change during runtime
15:10:53 <Kaidelong> well
15:10:57 <Kaidelong> that is one way to look at it
15:11:03 <mauke> clsmith: that's right
15:11:04 <clsmith> mauke: i am
15:11:05 <Kaidelong> in this case it really side-effects the world
15:11:06 <copumpkin> clsmith: what I said
15:11:10 <dons> clsmith: the same parameters **given the same arguments**
15:11:12 <dobblego> clsmith: correct, the same IO Char is returned each and every time
15:11:23 <mauke> clsmith: well, the point is, async XmlHttpRequest is all callback based
15:11:29 <mauke> clsmith: and so is IO
15:11:33 <dobblego> clsmith: and again, do not confuse "IO Char" and "Char" -- they are very different
15:11:33 <clsmith> so does what differs? because clearly the same char is *not* returned
15:11:41 <copumpkin> GAH
15:11:43 <mauke> clsmith: you don't "call getLine", you register a callback for user input
15:11:44 <dobblego> clsmith: the same IO Char is returned
15:11:45 <dobblego> clsmith: the same IO Char is returned
15:11:46 <KirinDave> mauke: Not to derail this, but I thought saying "getChar" made an IO action.
15:12:01 <KirinDave> mauke: Or rather, provided one. (if it is new or not is unimportant)
15:12:03 <mauke> clsmith: so what happens is that the outside world calls YOU, not the other way around
15:12:12 <clsmith> dobblego: so what does the "IO" contain, information-wise, within it?
15:12:15 <companion_cube> nice way of thinking
15:12:21 <Kaidelong> "foo" is a string
15:12:23 <copumpkin> clsmith: a description of the program that gets a line
15:12:28 <copumpkin> clsmith: not a line
15:12:28 <acowley> KirinDave: getChar is an IO action
15:12:30 <dobblego> clsmith: a program that when run, gives you a Char
15:12:31 <pmurias> clsmith: getChar returns an "actions" which reads a Char not a Char
15:12:35 <mauke> clsmith: python source code
15:12:43 <mauke> pmurias: don't make me +q you
15:12:44 <copumpkin> clsmith: that's why I keep going on about it containing a string representing source code in another language
15:12:44 <Kaidelong> cat /proc/mounts is an IO string
15:12:47 <clsmith> copumpkin: but the program that gets a line neevr changes, but when you run it the second time it will be different from the first
15:12:57 <pmurias> mauke: sorry
15:13:02 <Kaidelong> cat /proc/mounts itself never changes as far as you are concerned
15:13:06 <copumpkin> clsmith: yes, if I run a python program twice, it can return different values
15:13:08 <Kaidelong> but what it outputs might change
15:13:11 <KirinDave> clsmith: Yeah well, that's the real world for you. :)
15:13:13 <companion_cube> clsmith, i do not change my programs every time i run them
15:13:33 <clsmith> copumpkin: which is why it isn't purely functional!obviously it returns different values because it's imperative
15:13:35 <Kaidelong> (>>=) is a pipe
15:13:46 <Kaidelong> (for IO)
15:13:57 <copumpkin> clsmith: yes!
15:14:08 <mauke> but only when you actually run it
15:14:12 <copumpkin> clsmith: so IO is a way for us to BUILD UP PROGRAMS IN ANOTHER LANGUAGE
15:14:13 <mauke> before that it's just a string
15:14:22 <copumpkin> clsmith: we construct programs in a purely functional way
15:14:28 <copumpkin> that when executed are not purely functional
15:14:33 <clsmith> so why does getLine change when you evaluate it twice?
15:14:41 <Athas> Man, I just did my first real weird lazy evaluation hack.  I'm writing a compiler and put the symbol table in a shared environment in a reader monad, but I provide the value for that environment from the return value of the compiler!
15:14:41 <mauke> ...
15:14:43 * copumpkin gives up
15:14:45 <Kaidelong> clsmith: getLine itself does not change
15:14:46 <KirinDave> clsmith: getLine doesn't. The result of evaluating it does.
15:14:50 <mauke> KirinDave: wrong
15:14:56 <KirinDave> mauke: Oh?
15:15:00 <copumpkin> the result of _executing_ it does
15:15:02 <mauke> KirinDave: getLine is a constant
15:15:08 <Kaidelong> KirinDave: the result of evaluating it is stil the same program
15:15:10 <KirinDave> mauke: Fair enough, my bad for being inspecific.
15:15:13 <dobblego> I have another tact
15:15:20 <Kaidelong> the thing it outputs when you run the program can change though
15:15:20 <KirinDave> erhem, unspecific.
15:15:24 <clsmith> no no, please, i really need to know this. i don't understand the distinction between evaluation and symbol if it's referentially transparent
15:15:39 <mauke> clsmith: did you read my link?
15:15:54 <dobblego> clsmith: when you implement a method that returns a java.lang.Iterable, you can keep returning the same one right? but not java.util.Iterator
15:16:09 <Kaidelong> clsmith: You do not use the IO directly in haskell. It's fairer to think of what you are doing as generating a program that will be run later.
15:16:23 <Kaidelong> (ignoring stuff like unsafePerformIO)
15:16:37 <KirinDave> Kaidelong: Experience Bij. :)
15:16:49 <clsmith> mauke: yes.
15:17:07 <copumpkin> clsmith: think of haskell as nothing more than a code generator for another language. When I generate code, I can do so purely. The other language's interpreter then goes and runs the generated program
15:17:09 <Kaidelong> so the immutable values you are working with are programs
15:17:20 <mauke> clsmith: did you understand all of it?
15:17:28 <KirinDave> copumpkin: I can see how that model is valid and useful, but I'm not sure he's getting it. :)
15:17:31 <Kaidelong> and a haskell program with a main IO can almost be thought of as a shell script
15:17:35 <copumpkin> KirinDave: yeah, I guess not
15:17:39 <acowley> copumpkin: so Haskell is a typed lisp!
15:17:41 <copumpkin> KirinDave: I really don't know how else to describe it
15:18:05 <KirinDave> I didn't really understand why IO was done the way it was done until someone asked me to implement a random number generator.
15:18:14 <Kaidelong> oh yeah
15:18:17 <Kaidelong> take a look at MonadRandom
15:18:20 <KirinDave> I sorta understood monads as a pattern and the idea behind IO in one go with that project.
15:18:23 <Kaidelong> it will help you understand IO
15:18:31 <clsmith> mauke: i would say so, but clealry if everyone's shouting at me possible not. my problem is not the runtime, but that during runtime getChar can result in a different value being passed via <-
15:18:51 <mauke> clsmith: yeah, but <- doesn't actually execute anything
15:18:56 <mauke> clsmith: <- simply registers a callback
15:19:07 <Berengal> clsmith: evaluation is not execution.
15:19:08 <mauke> within that callback, everything's purely functional and all
15:19:08 <acowley> The runtime is special
15:19:10 <dobblego> KirinDave: I agree, not only is conflating IO and monads common, but learning about monads using IO is the worst possible way
15:19:17 <KirinDave> clsmith: So like, a do block for IO basically makes a new function which expects an IO context to run in.
15:19:23 <mauke> KirinDave: oh god, no
15:19:28 <KirinDave> mauke: Look dude
15:19:31 <KirinDave> I said it was LIKE that.
15:19:34 <mauke> can we stop this IO context stuff?
15:19:38 <acowley> oh man, I want a burrito
15:19:39 <mauke> it's obviously not a function
15:19:42 <Kaidelong> clsmith: Think of it this way. The <- translates into a pipe, when the result ends up being run, the whole script excutes the same getChar program several times, and pipes its output into other programs
15:19:45 <companion_cube> mauke, when you talk about callbacks, is it really how the implementation works ?
15:19:48 <mauke> companion_cube: yes
15:19:50 * copumpkin eats a burrito
15:19:54 <companion_cube> oh, neat
15:20:02 <mauke> I mean, look at the type of (>>=)
15:20:03 <companion_cube> it should be handy for concurrenty
15:20:08 <companion_cube> concurrency*
15:20:12 <mauke> companion_cube: guess how threads are implemented :-)
15:20:19 * companion_cube feeds monads to copumpkin 
15:20:21 <Kaidelong> dobblego: Why is IO a bad way to think about monads? It keeps people from falling too hard into the idea that monads are always data structures that contain things
15:20:37 <KirinDave> mauke: I dunno man. At some point wittgenstein's ladder is better than shouting at someone to understand your model. :)
15:20:39 <c_wraith> Kaidelong: so does State.
15:20:42 <clsmith> mauke: so you're saying, ghc actually just ignores io until runtime, at whic point it makes up whatever (assuming it's the right type)?
15:20:47 <acowley> Kaidelong: because running an IO program is the runtime's job
15:20:49 <Kaidelong> c_wraith: Yeah, State is a good one
15:20:50 <companion_cube> mauke, like this discussion about asynchronous vs threads not so long ago on this chan ?
15:20:50 <mauke> clsmith: huh?
15:20:56 <dobblego> Kaidelong: because of this exact conversation -- note the disproportionate amount of effort expended and the amount of progress
15:21:04 <dobblego> KirinDave: because of this exact conversation -- note the disproportionate amount of effort expended and the amount of progress
15:21:11 <dobblego> oops sorry
15:21:26 <Kaidelong> Mmm, State and MonadRandom are both good choices over IO I suppose
15:21:29 <monochrom> what is wittgenstein's ladder?
15:21:35 <acowley> dobblego: I think we should have motivated the discussion of IO by starting a Mac Lane reading group
15:21:51 <companion_cube> like a ladder for philosophers, probably
15:21:56 <dobblego> acowley: I teach haskell, we don't see IO for a long time -- it works much more efficiently
15:21:59 <dncr> dobblego: monadic io is bad bc ppl talk about it?
15:22:06 <KirinDave> monochrom: It's an incorrect explanation that is only useful for didactic purposes. You construct a series of incorrect but easily digestible explanations that refine a student's understanding. 
15:22:14 <mauke> clsmith: your haskell program constructs an imperative program, which is then executed. this imperative program can call back into haskell code
15:22:17 <dobblego> dncr: no, not sure how you go that out of the given explanation
15:22:25 <Kaidelong> clsmith: Anyway, if you're familiar with shell scripting, it is a useful enough analogy to IO, and motivates a lot of how I actually use Haskell
15:22:26 <KirinDave> monochrom: For example, how we teach students what * means. :)
15:22:41 <dncr> dobblego: perhaps by not dereferrencing *conversation enough
15:22:48 <Kaidelong> I basically use Haskell as a nicer looking Perl or Python a lot of the time
15:23:03 <dobblego> dncr: lots of effort, little (no) progress -- this conversation is testament to this fact
15:23:18 <clsmith> mauke: i just don't understand how we can distinguish between monadic and pure evaluation if the environment knows nothing about the concept of being 'impure'
15:23:29 <acowley> dncr: The problem is that it makes the implementation of IO in Haskell seem different than in other languages, and it suggests that monads are the key to performing IO
15:23:29 <mauke> clsmith: there is no such thing as monadic evaluation
15:23:32 <clsmith> Kaidelong: i am familiar with shell scripting, i don't understand how it helsp
15:23:38 <Kaidelong> clsmith: I guess the answer in short is that IO is not evaluated
15:23:51 <Berengal> clsmith: There is execution of IO, and evaluation of expressions. These things are not the same
15:23:54 <Kaidelong> it is rather "run" as a "script"
15:24:00 <clsmith> so surely the environment must understand the concept of IO!
15:24:08 <mauke> what do you mean by "the concept of IO"?
15:24:14 <Kaidelong> clsmith: Yeah, "main" is magical
15:24:18 <clsmith> because otherwise there cannot be "constant" non-constants
15:24:24 <Berengal> Some expressions denote values of type "IO something", these can be executed, but do not have to be
15:24:25 <mauke> huh?
15:24:34 <Kaidelong> but other than that the language does not really know anything about IO
15:24:35 <mauke> all constants are constant
15:24:44 <acowley> clsmith: the runtime turns a value of type "IO ()" into a warm CPU
15:24:48 <clsmith> mauke: so how do they change from runtime to runtime?
15:24:54 <mauke> clsmith: they don't
15:25:08 <dobblego> clsmith: I have a question. What does this print? new Runnable() { public void run() { System.out.println("booby"); } }
15:25:10 <acowley> what the runtime does with those constants changes
15:25:14 <clsmith> mauke: so how does *anything* differ from runtime to runtime?
15:25:18 * monochrom had a more productive time explaining why a function of polymorphic type (a,b)->a such as fst must give back the first element if terminates on comp.lang.haskell
15:25:25 <KirinDave> dobblego: Ahh, good idea
15:25:30 <mauke> clsmith: because the real world changes
15:25:30 <Kaidelong> clsmith: Would you expect what the LS program does to change every time you boot your system?
15:25:35 <Kaidelong> ls*
15:25:43 <mauke> clsmith: basically, you've got time, files, user input, network, etc
15:26:00 <clsmith> mauke: of course. so the runtime environment *does* change according to those
15:26:01 <Kaidelong> I mean sure, you can change it, but it's not something you'd expect to do
15:26:08 <Kaidelong> so you can think of it as an "IO String"
15:26:11 <clsmith> dobblego: sorry, that doesn't help
15:26:19 <dobblego> clsmith: do you not know the answer?
15:26:29 <erus_> booby!
15:26:34 <companion_cube> nothing
15:26:39 <clsmith> dobblego: i do. but java makes no attempt to be functional in any sense
15:26:40 <companion_cube> it waits to be called
15:26:45 <dobblego> clsmith: yes it does
15:26:47 <KirinDave> clsmith: What dobblego's saying is that that's an object that, when used properly, should output "booby". That's not a bad metaphor to understand IO.
15:27:03 <dobblego> clsmith: back to the point, can you tell me the answer please?
15:27:23 <companion_cube> actually the haskell equivalent of dobblego's code is   print "booby"
15:27:29 <clsmith> dobblego: booby :p
15:27:36 <companion_cube> > let x = putStrLn "booby" in x
15:27:36 <lambdabot>   <IO ()>
15:27:38 <mauke> no, it's putStrLn "booby
15:27:39 <dobblego> clsmith: no, it doesn't, would you like me to tell you the answer?
15:27:48 <Berengal> clsmith: Go try it out
15:27:48 <companion_cube> > putStrLn "booby"
15:27:48 <lambdabot>   <IO ()>
15:27:48 <monochrom> it prints <IO ()> :)
15:27:57 <companion_cube> aww
15:28:02 <KirinDave> Haha
15:28:04 <KirinDave> monochrom: Point
15:28:06 <monochrom> > putStrLn "<IO ()>"
15:28:07 <dobblego> clsmith: it prints nothing at all, right?
15:28:07 <shachaf> > putStrLn "<IO ()>"
15:28:09 <lambdabot>   <IO ()>
15:28:09 <lambdabot>   <IO ()>
15:28:36 <clsmith> dobblego: right, unless the jvm calls it if it's included in main
15:28:47 <dobblego> clsmith: even if it is main, it still prints nothing, right?
15:28:50 <Kaidelong> main is magical!
15:29:02 <erus_> clsmith: i think your struggling with the same thing as I did: when you use a getLine or something, you can never return a pure value. so all getLine functions have to be in do's which are inpure. an inpure function cannot be called by a pure one 
15:29:11 <mauke> erus_: wrong
15:29:14 <dobblego> class C { public static void main(String[] args) { new Runnable() { public void run() { System.out.println("booby"); } } } }
15:29:34 <dobblego> clsmith: that program prints nothing right?
15:29:34 <Kaidelong> @hoogle a -> IO b
15:29:34 <lambdabot> Control.Exception evaluate :: a -> IO a
15:29:34 <lambdabot> Control.OldException evaluate :: a -> IO a
15:29:34 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
15:29:36 <Kaidelong> those are some impure functions
15:29:56 <mauke> there are no impure functions
15:29:56 <acowley> they look good to me
15:29:56 <clsmith> dobblego: i don't understand what you mean. if run is called it clearly does print something
15:30:16 <Kaidelong> well in another sense they are pure
15:30:16 <mauke> clsmith: is run called?
15:30:16 <KirinDave> clsmith: Who calls run?
15:30:16 <dobblego> clsmith: so let's be clear, it is *necessary* for run to be called before you see anything -- do you agree?
15:30:18 <Kaidelong> they are pure functions that return impure values
15:30:23 * dncr is sure all the pedants will get around to coding an alternative to monadic IO right after they get done badgering everyone out of their current useful partial understandings
15:30:30 <mauke> wbat's an impure value?
15:30:35 <acowley> mauke: greed
15:30:59 <Taslem> If you abstract it to the lambda calculus, you can see that all output functions are basically \_ -> IO (), and all inputs read from an invisible oracle machine.
15:31:12 <djahandarie> mauke, unsafePerformIO is an impure function
15:31:52 <elliottt> acowley: nice one.
15:31:52 <monochrom> haha
15:31:52 <dobblego> clsmith: do you also agree that I could assign that to a Runnable reference and be sure that it is always the same program when I do run it?
15:31:52 <mauke> djahandarie: ah, now we're getting somewhere
15:31:52 <KirinDave> dncr: I was thinking of doing it right after a serious round of self-inflicted genital mutilation. And then I was going to put my hand in a hot waffle iron for a good 5 minutes. THEN I'll code up a new IO implementation. It'll be like I'm on a roll.
15:31:52 <djahandarie> mauke, I thought "greed" was good too
15:32:09 <clsmith> dobblego: sure. but to be sure of that we'd need the runtime to realise that, surely
15:32:18 <dobblego> clsmith: no, the language guarantees it
15:32:24 <djahandarie> KirinDave, you probably want to tone that language down...
15:32:24 <clsmith> how?
15:32:35 <dncr> should non-monadic io still be made of combinators
15:32:40 <KirinDave> djahandarie: Language?
15:32:41 <dobblego> clsmith: because in Java, you can only close over final values
15:32:55 <Berengal> clsmith: A program doesn't require a runtime to exist, it only needs a defined language
15:32:57 <djahandarie> KirinDave, "self-inflicted genital mutiliation" etc.
15:33:01 <dobblego> clsmith: is it not obviously the same program?
15:33:21 <erus_> KirinDave: yeah a little less haskell please
15:33:21 <dncr> should you still be stringing together, in (main), a recipe of your interactions with the real world
15:33:50 <pmetzger> would genital mutilation inflicted by third parties be more or less pure?
15:33:50 <clsmith> erus_: rofl
15:33:50 <monochrom> haha
15:33:50 <acowley> At the dawn of time, #haskell said, "import Language.PG13"
15:34:04 <dncr> pmetzger: wouldn't the effects be less predictable
15:34:17 <clsmith> dobblego: ... no. why can't it be a single runtime? does that differ simple because the "input" constant differs?
15:34:20 <monochrom> oh, did you know that April 30 will be the 10th anniversary of the dawn of time? :)
15:34:23 <pmurias> clsmith: you are aware what the "do" notation is desugared to?
15:35:40 <KirinDave> djahandarie: I'm pretty sure you what you meant to say and what you said are different things.
15:35:40 <clsmith> pmurias: yes
15:35:40 <clsmith> dobblego: and if that's the case, how can we be sure that the output is sequential
15:35:40 <dobblego> clsmith: I have no idea what motivated that question. 
15:35:40 <Kaidelong> @undo do { x <- getLine; y <- map toUpper x; print y }
15:35:40 <lambdabot> getLine >>= \ x -> map toUpper x >>= \ y -> print y
15:35:40 <dobblego> clsmith: do you understand that new Runnable returns a reference?
15:35:40 <KirinDave> djahandarie: I *think* what you mean was, "the superlative description of uncomfortable things involving self-mutilation made me uncomfortable", but instead you implied I used naughty words.
15:35:40 <Kaidelong> eta contract and you get
15:35:40 <clsmith> dobblego: yes
15:35:40 <acowley> monochrom: how did Erdos's interview go?
15:35:40 <Kaidelong> getLine >>= liftM map toUpper >>= print
15:35:40 <dobblego> clsmith: if I assign that reference to a value, call it r, then r represents a program -- one that if run, does the same thing
15:35:40 <KirinDave> djahandarie: If I'm understanding you right, sorry to freak you out. It was simply hyperbole.
15:37:30 <Kaidelong> or
15:37:30 <clsmith> dobblego: unless the input changes
15:37:30 <dobblego> clsmith: no, always
15:37:30 <dobblego> there is no "input"
15:37:30 <djahandarie> KirinDave, you are understanding me correctly.
15:37:30 <monochrom> "Actions, however, must be ordered in a well-defined manner for program execution – and I/O in particular – to be meaningful. Haskell’s I/O monad provides the user with a way to specify the sequential chaining of actions, and an implementation is obliged to preserve this order." from the haskell 2010 report
15:37:30 <erus_> this channel has some of the smartest people on freenode. Even the flame wars and subtle trolling is smart
15:37:30 <ddarius> monochrom: The next anniversary for the dawn of the sun is tomorrow.
15:37:30 <dobblego> erus_: it's distracting and annoying actually
15:37:30 <Kaidelong> "pipe the output from getLine into a program that maps the pure function map toUpper on its input and pipe that thing's output into the print program
15:37:30 <monochrom> the dawn of the sun is less interesting
15:37:30 <KirinDave> erus_: Entirely too few inception-glaring-dicaprio image macros though.
15:37:30 <acowley> When is dawn on the sun?
15:37:30 <clsmith> monochrom: so surely the implementation must understand the concept of sequential input and output, aside from purely-functional (arbitrarily parallel) graph reduction
15:37:30 <KirinDave> erus_: I know a good technical debate in 2011 when I see one, and I am certain it involves dicaprio glaring.
15:37:30 <clsmith> :|
15:37:32 <maurer_> Can someone link me to some of the rants against lazy IO?
15:39:14 <mauke> clsmith: sure, the runtime is impure
15:39:14 <Kaidelong> the haskell language is not its implementation though
15:39:14 <acowley> we look the other way when the runtime is involved
15:39:14 <djahandarie> maurer_, if no one can, I'm sure someone can lazily generate one right now.
15:39:14 * dobblego gives up and eats burritos with copumpkin 
15:39:14 <KirinDave> Aren't all runtimes impure, eventually.
15:39:14 <KirinDave> After all: cosmic rays.
15:39:14 <acowley> depends what you want out of it
15:39:14 * ddarius also recommends that dobblego preemptively gives up on people.
15:39:14 <clsmith> mauke: so the runtime must understand the concept of IO being dependent on time and place/
15:39:14 <acowley> my runtime has no input or output
15:39:14 <dobblego> ddarius: ?
15:39:14 <Kaidelong> KirinDave: well barring that, I guess you could point to stuff like Lazy K that can't do any IO at all and thus are completely useless
15:39:14 <mauke> clsmith: well, not really
15:39:14 <monochrom> every oleg's iteratee article probably contains a rant against lazy I/O
15:39:14 <maurer_> djahandarie: I'm thinking about if there's a way to still do lazy IO, but not get all the annoying problems. I think I've addressed the concerns, but would like to check against more stuff.
15:39:14 <mauke> clsmith: I don't think any of my C programs "understand" anything
15:39:21 <KirinDave> Kaidelong: I do not know, sir, but I know a ycombinator evaluating a ycombinator makes my computer FEEL busy. Not sure exactly what it's computing, but it's computing a lot of it.
15:39:21 <clsmith> mauke: they should, it would make compilation less annyoing :p
15:39:30 <KirinDave> What we need is to mapreduce Y Y
15:39:35 <Kaidelong> right, it is useful as a space heater
15:39:36 <djahandarie> maurer_, the usual solution to fixing all the problems with lazy IO is not using it.
15:39:43 <monochrom> @quote anthrop
15:39:43 <lambdabot> ion says: ddarius: Yeah, abstract concepts absolutely hate being anthropomorphized.
15:39:49 <companion_cube> how many haskell programmers will end their life as burrito sellers?
15:39:56 <acowley> djahandarie is spot on
15:40:18 <acowley> it's surprising how vicious laziness can be
15:40:31 <Berengal> clsmith: A haskell program is a purely functional definition of a value of type "IO something". If a runtime decides it wants to execute it after it's done evaluating the program, that's it's business
15:40:39 <maurer_> djahandarie: Sure, but I like the idea of a lazy stream--the only valid complaints I've seen seem to have to deal with error handling, which seems fixable...
15:40:50 <clsmith> once haskell inspired me to be a little too lazy and i never left the house
15:40:54 <monochrom> @quote anthropomorphize computers
15:40:54 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
15:41:00 <monochrom> @quote anthropomorphize.computers
15:41:00 <lambdabot> Aaron_Denney says: "Don't anthropomorphize computers.  They hate it when you do that."
15:41:04 <maurer_> djahandarie: If there are actual performance issues, I'd like to see the examples so I can play with them.
15:41:38 <KirinDave> maurer_: I seem to recall another argument is the extent of file descriptors?
15:42:08 <KirinDave> maurer_: If you're dealing with many files, it can be tricky to know when they're closed.
15:43:22 <djahandarie> maurer_, http://groups.google.com/group/fa.haskell/browse_thread/thread/50cc28a0ae61c38e/bbbe80401f0b8cc2
15:43:25 <gronkalonk> I suspect freenode has been infiltrated by a reptilian shape shifter. They might be posing as someone else in this very channel.
15:43:36 --- mode: ChanServ set +o mauke
15:43:36 --- mode: mauke set +q *!*@gateway/web/freenode/ip.80.212.74.204
15:44:26 --- mode: mauke set -o mauke
15:44:45 <acowley> maurer_: do you have some lazy IO code that want people to bang against?
15:46:37 <monochrom> oh, the haskell report uses "datatype" rather than "data type"
15:46:38 <rothwell> > withFile "file.txt" ReadMode return >>= hGetLine
15:46:38 <lambdabot>   Not in scope: `withFile'Not in scope: data constructor `ReadMode'Not in sco...
15:46:39 <maurer_> acowley: Not specifically. The only real change I've been thinking of at the moment is using streams similar to the structure of lazy bytestrings, with the idea being that people would be able to pattern match with a view pattern, getting a sequence of elements hooked together like a list, but with the terminator being the cause of termination
15:47:04 <maurer_> acowley: It's simple enough that I'm fairly certain it doesn't address all issues, so I was mostly looking to find out what issues others had encountered.
15:47:23 <acowley> maurer_: One problem I've encountered with lazy IO streams is to, say, take two elements, then force the second before the first
15:47:38 <Kaidelong> rothwell: Lambdabot will not do IO and does not import System.IO I do not believe
15:47:40 <acowley> You really need the sequential evaluation implied by IO
15:47:42 <Kaidelong> @hoogle withFile
15:47:42 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
15:47:45 <dobblego> clsmith: http://blog.tmorris.net/what-does-monad-mean/
15:47:50 <rothwell> Kaidelong: was just an example of a problem with lazy IO
15:47:54 <acowley> which fights against Haskell's general laziness
15:47:57 <Kaidelong> ah okay
15:48:16 <rothwell> Kaidelong: the file descriptor/handle will be closed before hGetline can get near it
15:48:29 <KirinDave> dobblego: I liked those slides btw. They were helpful in getting my head into a more efficacious space. 
15:48:34 <rothwell> it's from something oleg wrote, but i can't find it right now
15:48:35 <dobblego> KirinDave: great
15:48:38 <maurer_> acowley: For non-network IO, that's frequently doable (e.g. files)
15:48:59 <maurer_> acowley: Why do you need sequential evaluation?
15:49:12 <thoughtpolice> rothwell: probably an example in everything oleg ever wrote about iteratees vs. lazy io. :)
15:49:25 <rothwell> could well be!
15:49:44 <KirinDave> dobblego: You should do one on "What Does Pattern Mean?"
15:49:57 <KirinDave> dobblego: If someone says, "Oh, implement a singleton" at me one more time... :\
15:50:21 <monochrom> pattern means (x:xs)
15:50:27 <dobblego> KirinDave: I did one on the reader and writer monads, which is usually what "singleton" actually is (or state)
15:50:30 <djahandarie> lol
15:50:31 <thoughtpolice> his main concerns seem to be that lazy IO is a theoretical abomination and goes against what we value - any pure function essentially, by means of say, pattern matching on a list, suddenly has implicit side effects if the list came from hGetContents, etc.
15:50:40 <monochrom> [x] is the singleton pattern
15:50:45 <acowley> maurer_: it's not that I need it, it's that the monad may in fact be sequential
15:50:46 <KirinDave> monochrom: Trololo, but I meant in the context of Fowler's OO work.
15:50:48 <dobblego> KirinDave: I also gave a guest lecture about "design patterns" to Java third years once, but I don't own the video
15:51:04 <monochrom> I probably don't know Fowler's work at all
15:51:12 <dobblego> monochrom: you are luckier than most
15:51:17 <thoughtpolice> oleg interestingly also did work into the whole file handle scoping issue, which is somewhat unrelated to lazy IO (although lazy IO is certainly a way to trigger it,) and he did that with monadic regions. regions and iteratees are two of his best things he talks about, imo
15:51:33 <thoughtpolice> (where 'file handle scoping' = lazy IO from file handle. when is the handle closed?)
15:51:35 <maurer_> acowley: Sure, but you can create that structure without IO
15:51:35 <djahandarie> monochrom, it's the usual Java design pattern stuff.
15:51:36 <monochrom> I'm also very glad that I have never learned yacc bison etc
15:51:40 <maurer_> acowley: See scanl and friends.
15:51:49 <maurer_> Accessing the nth element calculates all the ones before it
15:52:03 <KirinDave> I know and respect people who don't really understand patterns should be descriptive, not prescriptive.
15:52:12 <KirinDave> (anymore than language informs thought normally)
15:52:50 <monochrom> ooohhhh!
15:52:54 <acowley> maurer_: I asked for code to avoid this discussion! :) I don't think I can produce an concise, IRC argument for why lazy IO can never work.
15:53:31 <monochrom> "the main is not the recipe for the action. the main is the action" - monochrom McLuhan :)
15:53:49 <acowley> maurer_: It's the kind of thing where some actual code let's one produce examples of things going wrong
15:54:04 <digitteknohippie> hrmm.. i thought there was an audiobook version of real world haskell.   ... did i imagine that?   it'd really help dislexics.
15:54:41 <Eduard_Munteanu> Uh, this bugs me...   Loading package terminfo-0.3.1.1 ... can't load .so/.DLL for: ncursesw (/usr/lib64/libncursesw.so: invalid ELF header)
15:55:03 <monochrom> there is no argument for why lazy IO can never work, since there is some lazy IO code that works. you can only argue that it is error-prone.
15:55:06 <Berengal> Eduard_Munteanu: reinstall ncurses?
15:55:07 <Eduard_Munteanu> /usr/lib64/libncursesw.so is a linker script, not a true .so
15:55:13 <maurer_> acowley: The problem with actual code is that you can then demonstrate "Either maurer_ sucks or Lazy IO sucks" not "Lazy IO sucks"
15:55:24 <acowley> maurer_: that's really the point though!
15:55:24 <Eduard_Munteanu> Berengal: I'll try, but I don't think it fixes anything.
15:55:30 <acowley> maurer_: you don't suck
15:55:41 <acowley> maurer_: so by the LEM, lazy IO sucks
15:55:45 <acowley> ahem
15:56:06 <maurer_> acowley: It's an expression--when you see a paper that tried to do X, but it didn't work out, you're left wondering if X sucks or they suck.
15:56:15 * hackagebot SafeSemaphore 0.4 - Much safer replacement for QSemN and QSem  http://hackage.haskell.org/package/SafeSemaphore-0.4 (ChrisKuklewicz)
15:56:35 <acowley> I know, which is why we must be vigilant in maintaining that it's lazy IO that sucks rather than all of us
15:57:09 <Berengal> lazy IO works in interact.
15:57:14 <monochrom> I easily agree that lazy I/O sucks without much argument
15:57:16 <Berengal> But other than that, it sucks, yes.
15:57:58 <acowley> Berengal: like monochrom said, it actually works in many places. When it doesn't work, it turns out that solutions are awkward, nonobvious, or both.
15:58:11 * byorgey sends the intuitionist police after acowley 
15:58:19 <acowley> hahahaha
15:58:37 <Eduard_Munteanu> Berengal: nope, re-emerged it, same thing
15:58:38 <acowley> I now know how to summon byorgey 
15:58:44 <maurer_> acowley: Maybe a sort of partially lazy IO could make sense? e.g. one where you as the programmer are not expecting the IO to be _actually_ lazy, but are instead letting the IO manager decide when it wants to get this shit done?
15:58:50 <monochrom> just fight the intuitionist police by asking: to arrest or not to arrest, that's the question!
15:58:54 <byorgey> yes, I have a highlight set on "LEM"
15:59:06 <Eduard_Munteanu> I think GHC is so goddamn stubborn and stupid. Why doesn't it use the system linker already? :/
15:59:17 <Berengal> Eduard_Munteanu: Yeah, since it's a linker script that probably wouldn't fix it. I'm entirely unexperienced in such matters however, sorry.
15:59:31 <monochrom> LEMMA 0: a ∧ ¬0 ⇒ ⊥
15:59:37 <Berengal> Eduard_Munteanu: You could try linking manually
15:59:54 <acowley> maurer_: I have no answers really. I spent a considerable amount of time on a lazy IO streams thing before chucking it for something that makes the monad explicit and offers me almost the same level of abstraction and compositionality.
16:00:08 <byorgey> GHC is an inanimate entity incapable of attributes such as "stubbornness"
16:00:39 <dons> it is, however, "glorious"
16:00:41 <Eduard_Munteanu> Berengal: I was debugging why Agda freezes Emacs, it turns out   :set -package Agda-2.2.6   in ghci stumbles upon that thing
16:00:43 <monochrom> my installation of ghc uses whatever "ld" that appears first in PATH just fine without effort
16:00:59 <byorgey> dons: good point.
16:01:02 <dons> much as the other great constructs of human design are, e.g. the pyramids
16:01:07 <Eduard_Munteanu> I'm not sure how I could fix it.
16:01:09 <maurer_> acowley: My main goal here is to avoid having to think about IO when doing processing code, but not require all of input to be there before I start the processing code.
16:01:21 <monochrom> oh! so ghc is a glorious pyramid scheme?
16:01:40 <byorgey> monochrom: a glorious pyramid HASKELL
16:01:41 <Berengal> byorgey: If inanimate objects are incapable of stubbornness, why do we have the expression "stubborn as a rock"?
16:02:05 <monochrom> rocks also hate to be anthropomorphized, you know...
16:02:06 <Eduard_Munteanu> monochrom: well IDK, but then I suppose it should grok linker scripts posing as libs just fine
16:02:14 <KirinDave> monochrom: If that is the case, recruit Jeff Atwood and Joel Spolsky immediately. Those people could sell a pregnant cow milk and have the cow thank them for the privilege of buying. 
16:02:22 <acowley> Berengal: that phrase was originally "stubborn as the rock", but due to trademark issues, we changed it to "a"
16:02:24 <monochrom> oh, *.so linker script, that's another story
16:02:29 <KirinDave> Berengal: Because we're stupid?
16:02:46 <acowley> maurer_: that is what I addressed with my solution, which is rather like iteratees in spirit
16:03:13 <Eduard_Munteanu> Can you tell that story? :)
16:03:25 <Eduard_Munteanu> I mean, the happy end.
16:03:30 <maurer_> acowley: Link me to your solution?
16:03:41 <Berengal> Eduard_Munteanu: "And then he played with Agda forever and ever"
16:03:48 <Eduard_Munteanu> Heh.
16:04:09 <rothwell> not quite forever... it terminated
16:04:14 <rothwell> ... sorry
16:04:19 <Eduard_Munteanu> :)
16:04:45 <Berengal> rothwell: No, but it was always productive
16:04:49 <acowley> maurer_: it's tied into a much larger library, the stream bit is here: http://github.com/acowley/roshask/blob/master/Ros/Topic.hs
16:09:09 <gwern> @quote agda
16:09:09 <lambdabot> kmc_ says: agda is super mutant haskell
16:09:21 <tomh-> hey guys, anyone aware of some study on the amount of influence of a static type system vs the amount of bugs ?
16:09:25 <luite_> super mutant ninja haskell
16:10:28 <pmetzger> teenage mutant ninja haskell is better with the youth market.
16:12:13 <cartouche> hello
16:12:17 <cartouche> how I can print ['a','b'] as ['a','b'] not "ab" to the screen using putStrLn.  print_charlist ['a','b']    -----> will be seen as ['a','b'] not "ab" 
16:12:34 <mauke> why do you want to do that?
16:12:49 <gwern> cartouche: sounds like homework
16:12:50 <acowley> newtype
16:12:55 <cartouche> yes
16:13:14 <gwern> cartouche: think about your base cases
16:13:25 <cartouche> I have to do like this
16:13:29 <mauke> :t intersperse
16:13:30 <lambdabot> forall a. a -> [a] -> [a]
16:13:56 <mauke> :t printf "[%s]" . interperse ',' . map show
16:13:57 <lambdabot> Not in scope: `interperse'
16:14:04 <mauke> :t printf "[%s]" . intersperse ',' . map show
16:14:04 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
16:14:04 <lambdabot>     In the first argument of `map', namely `show'
16:14:04 <lambdabot>     In the second argument of `(.)', namely `map show'
16:14:15 <mauke> my emperor
16:14:27 <mauke> ok, intercalate
16:14:28 <gwern> mauke: heh. you're going to give him an answer that the professor will know he didn't write, eh? :)
16:14:52 <cartouche> I could not find such a method
16:15:02 <mauke> define "method"
16:15:26 <shachaf> @wn method
16:15:27 <lambdabot> *** "method" wn "WordNet (r) 2.0"
16:15:27 <lambdabot> method
16:15:27 <lambdabot>      n : a way of doing something, especially a systematic way;
16:15:29 <lambdabot>          implies an orderly logical arrangement (usually in steps)
16:15:45 <cartouche> hımmm okey 
16:18:52 <gwern> cartouche: you need to recurse over your string argument
16:18:57 <gwern> as I said, think about your base cases
16:19:19 <mauke> or write intercalate first
16:20:09 <RenJuan> dons, will this HP release make everything alright the way the Squeak people did with all-in-one?
16:21:34 <RenJuan> a light unto the nations and stuff>
16:21:41 <RenJuan> s/>/?/
16:24:09 <gwern> RenJuan: sarcasm is unbecoming in youth
16:24:29 <RenJuan> and in the superannuated?
16:24:37 <gwern> forgiveable
16:24:44 <RenJuan> peccavi
16:24:58 <gwern> (you are forgiven, but go and sin no more)
16:26:37 <RenJuan> .oO(boy, I'm glad I didn't get all "confessional" about how you don't want HP to become the darcs of pkging)Oo.
16:27:53 <KSkrzet> is there a way to deal with leaking class instances?
16:28:29 <acowley> Nothing you'll like
16:28:38 <acowley> unexported newtypes
16:28:46 <KSkrzet> my problem is that Data.ByteString.Lex.Double leaks IsString ByteString from Data.ByteString.UTF8...
16:29:00 <KSkrzet> *Data.ByteString.Char8
16:29:28 <KSkrzet> acowley: mind to explain that idea?
16:29:31 <acowley> Only one person gets to define IsString for ByteString, and that person should either be the author of ByteString or the author of IsString.
16:29:51 <acowley> KSkrzet: newtype Foo = Foo {unF :: ByteString}
16:30:00 <acowley> KSkrzet: instance IsString Foo where
16:30:56 <KSkrzet> acowley: actually I like this it
16:31:12 <KSkrzet> s/it/way
16:31:48 <acowley> I'm glad!
16:34:26 <lars9> morning asia
16:34:29 <christo_m> can anyone help me write a compiler for LUA
16:34:40 <christo_m> i have some base code here , just confused with the way im parsing and assigning to my AST
16:34:56 <christo_m> ok help is the wrong word , maybe point me in the right direction
16:35:00 <RenJuan> kina off-topic here
16:35:12 <christo_m> well, its written in haskell..
16:35:17 <christo_m> using Parsec
16:35:19 <RenJuan> but get a grammar and then you can do it anywhere
16:35:33 <christo_m> i have it, the LUA grammar is right in the reference manual, that isnt the issue
16:35:40 <christo_m> i think its the way im going about the actual parsing/lexing
16:35:43 <RenJuan> google LUA and BNF
16:35:55 <christo_m> .. no , i have it. that isnt the issue.
16:35:57 <acowley> christo_m: can you distill your problem down into a small example
16:36:21 <christo_m> i pasted some stuff earlier in the channel but it was flooded with people talking about way more serious things than my mind can fathom
16:36:27 <christo_m> one moment
16:37:04 <RenJuan> ah, then you just need to go ahead and get your first practical experience with syntax directed recursive descent parsing with that grammar and your parsing toolkit of choice
16:37:25 <RenJuan> (or apply that experience you already have)
16:38:00 <christo_m> http://hpaste.org/45471/luahs   <- parser/lexer (incomplete)
16:38:06 <RenJuan> haskell has several and there's no dearth of them generally
16:38:07 <christo_m> http://hpaste.org/45472/luaas  AST
16:38:25 <Eduard_Munteanu> A-ha!
16:38:31 <christo_m> it gets confusing because i have Recursive data types
16:38:39 <Eduard_Munteanu> Triumph over GHC!
16:38:43 <christo_m> im pretty new to the whole functional thing, so im trying to rap my head around this
16:38:48 <christo_m> wrap*
16:38:52 * Eduard_Munteanu got Agda running in Emacs
16:39:14 <RenJuan> maybe haskell is the wrong lang choice then
16:39:25 <christo_m> well, its a bit late to switch
16:39:38 <christo_m> and from my understanding its way easier to write a compiler in it, than in C for example
16:39:41 <acowley> RenJuan: He started out saying he had the grammar and is using parsec
16:39:59 <RenJuan> no way is Haskell easier than C
16:40:07 <Eduard_Munteanu> A couple of symlinks to real .so's in a local dir and an LD_LIBRARY_PATH wrapper
16:40:11 <christo_m> im not talking about ease of use, language wise
16:40:21 <christo_m> im talking about Domain specific.. haskell is better for writing compilers in
16:40:22 <Eduard_Munteanu> (for emacs/ghci)
16:40:50 <acowley> christo_m: okay, so where are things going wonky?
16:41:00 <christo_m> http://www.lua.org/manual/5.1/manual.html#8  theres the grammar 
16:41:14 <christo_m> acowley: well, just by looking at it, does everything look like it makes sense?
16:41:20 <christo_m> i dont want to start doing everything and realize i went about it wrong
16:41:27 <Eduard_Munteanu> Also this is a bit misleading, it doesn't seem fixed in 6.12.3: http://hackage.haskell.org/trac/ghc/ticket/2615
16:41:45 <Eduard_Munteanu> Yet the bug is closed as fixed.
16:41:49 <christo_m> specifically at this time im stuck at this error: http://hpaste.org/45473/error
16:42:24 <acowley> christo_m: that looks like a tiny problem
16:42:32 <acowley> christo_m: you want return $ DO b
16:42:35 <acowley> return $ Do b
16:42:39 <christo_m> ah
16:42:43 <christo_m> paranthesis
16:42:51 <acowley> maybe
16:42:53 <RenJuan> acowley, no he didn't start out saying that, but he did say it shortly thereafter
16:43:35 --- mode: ChanServ set +o mauke
16:43:35 --- mode: mauke set -q *!*@gateway/web/freenode/ip.80.212.74.204
16:43:44 <christo_m> Couldn't match expected type `Block' against inferred type `Stmt'
16:43:50 <christo_m> im starting to think my type signatures are incorrect
16:44:06 <christo_m> ugh, i dont wanna be pestering you guys with these small things either, this is like my 15 minutes to get as many questions in from the community
16:44:16 <acowley> christo_m: the AST look okay to me, but I haven't used Lua in many years
16:44:25 --- mode: mauke set -o mauke
16:44:32 <acowley> christo_m: so your parser gives you a Stmt
16:44:39 <acowley> and you need to pass a Block to Do
16:44:40 <acowley> ?
16:45:00 <christo_m> yes
16:45:16 <christo_m> a block is just a series of statements
16:45:49 <christo_m> acowley: also, do you see how i have option () semi
16:45:58 <christo_m> apparently, you can optionally terminate statements with semicolons
16:46:02 <christo_m> however i wasnt able to get that to work either
16:46:05 <christo_m> very depressing
16:46:19 <acowley> christo_m: there are several options
16:46:37 <acowley> one is to make Block a constructor of Stmt, and deal with the weaker typing whenever applying the Do constructor
16:46:44 <acowley> another is to make your parsers return Either Stmt Block
16:47:14 <acowley> another is to hijack parsec to get the input, feed it to a parser that returns a Block and the remaining input, then apply Do to that Block
16:47:54 <acowley> well, actually
16:48:18 <acowley> doh
16:48:30 <christo_m> ?
16:48:31 <acowley> all you need to do is: return $ Do (Block b)
16:48:38 <acowley> or return . Do . Block $ b
16:48:39 <christo_m> grrr
16:48:42 <acowley> or however you like to group things
16:48:56 <acowley> assuming b :: [Stmt]
16:49:10 <christo_m> right. well
16:49:19 <christo_m> data Block = Block [Stmt]
16:49:21 <christo_m> thats how i have it
16:49:25 <acowley> sorry for the digressions on alternatives! I should have read more closely.
16:49:41 <acowley> Yeah, but I forget the type of between
16:49:42 <christo_m> also, with the option () line.. i have this
16:49:44 <christo_m> Couldn't match expected type `()' against inferred type `[Char]'
16:49:56 <christo_m> between should return a block
16:50:02 <acowley> what's the type of option?
16:50:09 <christo_m> i have no idea
16:50:17 <acowley> to hackage!
16:50:30 <christo_m> option x p tries to apply parser p. If p fails without consuming input, it returns the value x, otherwise the value returned by p.
16:50:36 <christo_m> option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
16:51:01 <acowley> if you really don't care about the semicolon
16:51:06 <acowley> then just option undefined p
16:51:34 <acowley> but it seems like option isn't quite the right combinator
16:51:56 <christo_m> well, i could either have a statement
16:52:01 <christo_m> or i could have a statement with a semicolon
16:52:04 <christo_m> thats why i figured option would work best
16:52:35 <acowley> optional
16:52:41 <acowley> that looks better
16:53:19 <christo_m> Lua.hs:50:29: Couldn't match expected type `[Stmt]' against inferred type `Stmt'
16:53:24 <christo_m> :|
16:53:58 <acowley> many1
16:54:08 <acowley> that is
16:54:23 <christo_m> im sorry, instead of optional?
16:54:25 <acowley> between (reserved "do") (reserved "end") (many1 block)
16:54:26 <acowley> no
16:54:29 <acowley> in doStmt
16:54:42 <acowley> now b::[Stmt]
16:54:49 <acowley> so you can return $ Do (Block b)
16:54:52 <christo_m> wait
16:54:56 <christo_m> insead of between?
16:54:58 <christo_m> im confused sorry..
16:55:06 <acowley> I'm not being very clear
16:55:14 <christo_m> im also very dumb, im sorry
16:55:15 <christo_m> :(
16:55:16 <acowley> the optional combinator goes into the block parser
16:55:25 <acowley> to deal with the semicolon that may or may not be present
16:55:26 <christo_m> got that.
16:55:42 <acowley> in doStmt, between is the right idea to capture the delimiters of the block
16:55:51 <acowley> but in between the delimiters, you expect 1 or more statements
16:56:02 <acowley> between (reserved "do") (reserved "end") (many1 block)
16:56:14 <acowley> look at the type
16:56:29 <acowley> between gives you the result of the last parser
16:56:35 <acowley> and you want somethign of type [Stmt]
16:56:51 <acowley> while your block parser gives you a single Stmt
16:57:34 <acowley> If you'd like, you could push the many1 into block, and have its return type be [Stmt]
16:58:09 <christo_m> i think in block itd make sense
16:58:12 <christo_m> since thats what it is
16:58:15 <christo_m> how would i put it into block though
16:58:18 <acowley> agreed
16:58:19 <christo_m> s <- many1 stat?
16:58:25 <acowley> no
16:58:45 <acowley> many1 (do {s <- stat; optional semi; return s})
16:58:54 <acowley> or something to that effect
16:59:06 <acowley> remember that each statement may be terminated by a semicolon
17:00:24 <christo_m> right
17:00:34 <christo_m> now to build my expression table
17:00:44 <christo_m> leftassociative ,right associative.. i dont think i can get very far till thats done
17:00:48 <christo_m> considering how many things rely on expressions.
17:03:53 <christo_m> acowley: you gonna be around ? i might have to harrass you more
17:04:22 <acowley> christo_m: probably not for much longer tonight
17:04:38 <christo_m> http://www.haskell.org/haskellwiki/Parsing_a_simple_imperative_language  <- well ill use this tut then
17:06:31 <christo_m> thanks again
17:06:56 <acowley> np
17:16:29 <BMeph> That looks like what "sepEndBy" was made for... ;)
17:20:14 <christo_m> BMeph: you're right
17:20:23 <christo_m> sepEndBy1 probably though
17:22:16 <christo_m> not sure how id rewrite it right now anyway
17:22:19 <christo_m> focusing on exprs
17:27:41 <Berengal> Can I use a Ptr Float wherever a Ptr CFloat is required?
17:28:12 <Berengal> Or are the Storable instances different?
17:29:48 <Berengal> Eh, Float stores as HSFloat...
17:33:54 <KSkrzet> Berengal: according to standard this isn't correct
17:34:17 <KSkrzet> see http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1690008.6, part 8.7
17:34:43 <KSkrzet> HsFloat can be Double for example
17:34:58 <KSkrzet> or rather double
17:42:45 <monochrom> you can use realToFrac to convert between CFloat and Float if you don't mind
17:43:06 <Berengal> monochrom: I am, but it's bothersome to write the wrapper function that does that
17:43:21 <Alan> Hmm, what's going on here...
17:43:24 <Berengal> c2hs has built-in support for converting between Float and CFloat
17:43:25 <Alan> HWAM/Func/CodeGen.hs:17:21: Not in scope: data constructor `State'
17:43:39 <monochrom> that's nicer
17:43:40 <Alan> i've got "import Control.Monad.State"
17:43:45 <Berengal> But it doesn't work for float pointers, obviously
17:43:54 <Berengal> (that I alloca and peek)
17:44:05 <Alan> and line 17 is: appendCode newcode = State $ \s -> ((), s { code = (code s) ++ newcode })
17:44:27 <monochrom> another tactic is to use CFloat in haskell code throughtout, don't bother converting
17:45:09 <Berengal> A real option, true, since most Haskell code wouldn't use Floats anyway
17:45:23 <Berengal> But I've already written all of the code thus far to use Float
17:45:31 <monochrom> mtl-1 has State but mtl-2 gets rid of it. appendCode newcode = state $ \s -> ((), s { code = (code s) ++ newcode })
17:45:43 <Alan> Actually, what the hell am i missing? i have "import Control.Monad.State", yet apparently i can't get at State...
17:45:44 <hpc> i suppose all that begs the question of why aren't you using doubles?
17:45:51 <monochrom> alternatively go back to mtl-1
17:45:56 <mauke> Alan: there is no State
17:45:59 <acowley> What's wrong with Float?
17:46:04 <Berengal> hpc: The C code uses floats
17:46:07 <hpc> i mean, if you have surrendered yourself to floats, you might as well pay the extra word for precision that isn't atrocious
17:46:19 <hpc> > 1 + 2 :: Float
17:46:19 <lambdabot>   3.0
17:46:27 <hpc> > 1.5 + 1.5 :: Float
17:46:27 <lambdabot>   3.0
17:46:29 <Alan> mauke: crap, i misunderstood the article i was reading  :(
17:46:31 <hpc> hmm
17:46:31 <Berengal> The extra word isn't going to mean anything since you have to convert to float anyway
17:46:41 <hpc> ah, nvm
17:46:43 <Alan> or maybe i didn't...
17:46:47 <monochrom> "the article" is outdated
17:47:04 <Alan> http://learnyouahaskell.com/for-a-few-monads-more#state
17:47:07 <KSkrzet> > 1 + 2 :: CFloat
17:47:07 <lambdabot>   Not in scope: type constructor or class `CFloat'
17:47:09 <Alan> that's what i'm reading
17:47:13 <monochrom> yes, it's outdated
17:47:14 <byorgey> Alan: the newest version of the transformers library defines State in terms of StateT, so there is no State constructor
17:47:29 <byorgey> Alan: you can use the 'state' function in its place
17:47:31 <monochrom> we're so talking across each other
17:47:45 <Alan> huh
17:47:51 <Alan> that's strange and weird and stuff...
17:47:59 <Alan> so what should the type for my stateful computations be?
17:48:03 <RenJuan> why does the ghc main page claim that ghc has "particularly good" support for concurrency and parallelism and compared to what?
17:48:09 <byorgey> Alan: the types are the same.
17:48:22 <KSkrzet> Alan: State = StateT Identity
17:48:24 <Berengal> RenJuan: Because it does, and compared to most things
17:48:31 <Alan> weird...
17:48:32 <KSkrzet> Alan: so it's ok
17:48:33 <byorgey> Alan: it's just the internal implementation of State that has changed a bit.
17:49:03 <byorgey> Alan: I assure you, it is not weird at all =)
17:49:04 <monochrom> software changes. API changes. static books become version-mismatched with new software. this is not weird.
17:49:09 <RenJuan> doesn't add up, especially compared to packages that are about nothing else
17:49:37 <Alan> ok, fail enough...
17:49:39 <Alan> *fair enough
17:49:48 <monochrom> yes yes, despite the book being printed on paper just 3 months ago
17:50:10 <RenJuan> is concurrent haskell included in base ghc now?
17:50:15 <monochrom> because the book was written a year ago or more
17:50:15 <Alan> So instead of "State $ \s -> ...", what should that function look like?
17:50:28 <byorgey> just replace State with state
17:50:28 <monochrom> <monochrom> mtl-1 has State but mtl-2 gets rid of it. appendCode newcode = state $ \s -> ((), s { code = (code s) ++ newcode })
17:50:32 <Berengal> RenJuan: ghc has had threading for a long time
17:50:36 <monochrom> <byorgey> Alan: you can use the 'state' function in its place
17:50:40 <monochrom> did you see them?
17:50:46 <Alan> oh, sorry, i didn't know what you meant by mtl-1
17:50:52 <Alan> etc.
17:51:02 <RenJuan> Berengal, that wasn't my question, do you know what concurrent haskell is?
17:51:07 <monochrom> but you probably know "appendCode"
17:51:18 <Alan> and yes, i saw those, the question is, is that what i should be using, or just the way to keep the code looking teh same?
17:51:18 <mauke> RenJuan: threading?
17:51:29 * RenJuan gives up.
17:51:37 <monochrom> did you see appendCode newcode = state $ \s -> ((), s { code = (code s) ++ newcode }) for the 3rd time?
17:51:43 <byorgey> Alan: yes, that's what you should be using
17:51:48 <Alan> monochrom: yes, i did
17:51:50 <byorgey> monochrom: lighten up =)
17:51:58 <monochrom> > "State" == "state"
17:51:58 <lambdabot>   False
17:52:05 <Alan> haha
17:52:12 <KSkrzet> RenJuan: you mean MVars and stuff?
17:52:39 <Alan> byorgey: ok, i shall do that then...
17:52:41 <Berengal> RenJuan: Concurrent Haskell was the project to implement threading in GHC, and specify a model for concurrent execution in the Haskell standard, yes?
17:53:37 <monochrom> this is why I say the 3rd book you read is the best book.
17:54:10 <Alan> the whole "state $ ..." thing seems a bit strange, but then i still don't fully grasp the state monad (or even monads in general...)
17:54:30 * RenJuan is working on a haskell epiphany, tied up with that.
17:55:41 <monochrom> the constructor "State" has been killed. the function "state" is added to help users change old code to new code by just s/State/state/
17:56:06 <Alan> ok, so that actually re-raises my question
17:56:20 <Alan> is that just a syntactic convenience, when really "new code" should look different?
17:56:46 <Alan> i want to know if i'm doing it in the correct style
17:57:05 <monochrom> it's already correct style, even when you use "state".
17:57:27 <Alan> what's the alternative to using "state $ ..."?
17:57:29 <Alan> is there one?
17:57:42 <monochrom> write a lot of "put"s and "get"s and "modify"s
17:58:33 <monochrom> but sometimes it's more direct to write "state $ \s -> ...". it's up to you. go with your heart.
17:58:50 <shachaf> The constructor "State" is gone? Why?
17:58:59 <byorgey> shachaf: because State = StateT Identity
17:59:01 <shachaf> Is it using StateT now?
17:59:01 <monochrom> because the type State is also gone
17:59:04 <shachaf> Ah. :-)
17:59:32 <monochrom> a conspiracy to slowly kill all concrete types
17:59:39 <Berengal> byorgey: Does this mean that transformers are not as slow anymore?
18:00:31 <monochrom> it probably means computers are not as slow anymore :)
18:01:01 <Berengal> monochrom: Where do you get these new fast computers? My computer hasn't moved in years!
18:01:12 <monochrom> best buy
18:01:26 <monochrom> but actually I bought mine at Staples
18:01:44 <Berengal> How do they move exactly? I'd think wheels, but tracks'd probably be better for getting up stairs and such
18:01:54 <Alan> ok, so is state something that takes a function of type s -> (a, s), and wraps a "put s; return a" around it?
18:01:57 <Alan> or something like that?
18:01:59 <monochrom> and oh, Apple Store, for those who like to get into trouble changing Xcode 3 to Xcode 4
18:02:12 <Alan> i'm trying to understand how this works...
18:02:29 <pmetzger> the Xcode 3 -> 4 thing was irritating.
18:02:38 <monochrom> oh I see what you mean. yeah they still have to be moved by you, but faster now since lighter :)
18:02:46 <ddarius> :t \f -> do s <- get; let (a,s') = f s; put s'; return a
18:02:47 <lambdabot> parse error on input `;'
18:02:56 <ddarius> :t \f -> do s <- get; let {(a,s') = f s}; put s'; return a
18:02:57 <lambdabot> forall (m :: * -> *) s b. (MonadState s m) => (s -> (b, s)) -> m b
18:03:05 <Alan> ah, i see
18:03:18 <Alan> so kinda, but a bit more complicated?
18:03:31 <Berengal> Alan: A "State" as defined by mtl is exactly a function of type s -> (a, s).
18:03:43 <Alan> so basically it's a convenience for making a "s -> (a, s)" into something State monad compatible?
18:04:01 <ddarius> :t State
18:04:02 <lambdabot> Not in scope: data constructor `State'
18:04:02 <shachaf> Well, it's a new type.
18:04:12 <shachaf> @ty state
18:04:13 <lambdabot> forall s a. (s -> (a, s)) -> State s a
18:04:24 <shachaf> This is actually a change that's in effect?
18:04:29 <Berengal> Alan: The State monad and the (s -> (a, s)) monad are the same (modulo newtypes)
18:04:59 <byorgey> the 'state' function just wraps up a function of type  (s -> (a,s)) into a value of type  State s a
18:05:04 <aristid> Berengal: (s -> (PLACEHOLDER, s)) is no monad
18:05:43 <hpc> that's no monad; that's a space station!
18:05:52 <copumpkin> holy shit
18:05:58 <dncr> groanad
18:06:10 <hpc> sorry, had to
18:06:16 <Alan> dncr: i giggled a little...
18:06:24 <Alan> @ groanad
18:06:32 <Alan> because that's how they're making me feel at the moment
18:06:34 <dncr> +1
18:07:14 <McManiaC> anyone familiar with HDBC, postgresql and binary data? I have a postgresql table with a "bytea" column and I try to store a ByteString in it, but I always get "invalid bytesquence for encoding 'UTF8': 0xe1cc63". any ideas?
18:07:36 <McManiaC> *bytesequence
18:07:56 <RenJuan> what version of pg?
18:08:00 <McManiaC> 9.0.3
18:08:10 <RenJuan> that could be it
18:08:16 <McManiaC> why?
18:08:27 <RenJuan> because it's new
18:08:56 <McManiaC> I'm new to hdbc
18:08:57 <Alan> Berengal: do you mean that "state" is being used in the sense of "a sequence of states", so each "state" is a function on the previous state?
18:08:59 <RenJuan> and HDBC isn't
18:09:01 <McManiaC> doesn't that count?
18:09:02 <McManiaC> :>
18:09:23 <Alan> or something like that?
18:09:48 <McManiaC> run connection "INSERT INTO users (u_pwd) VALUES (?)" [SqlByteString pwd]  -- is that correct RenJuan ?
18:10:32 <hpc> why would a bytes column be using utf8 for anything?
18:10:35 <RenJuan> i dunno McManiaC, I've never used HDBC
18:11:09 <RenJuan> but I know it's been around for a while and pg 9 is new
18:11:11 <hpc> McManiaC: that's the right syntax, at least
18:11:21 <hpc> though the preferred style is to use toSql
18:11:36 <Berengal> Alan: Yes, that's about it. There are many ways to model state; reading and writing memory locations are one (used in imperative programming), a series of functions where one "value" is threaded through each one is another one, and it's this model the State monad uses. In addition to taking the previous state as input and returning the next state as output, a State can also return any other arbitrary value
18:11:45 <McManiaC> If you are handling some sort of binary data that is not in UTF-8, you can of course work with the ByteString directly, which will bypass any conversion.
18:11:51 <McManiaC> that's why I did it by hand hpc 
18:12:28 <hpc> hmm, that has me curious now
18:12:38 * hpc looks up the convertible instance
18:13:10 <Alan> Berengal: thanks :) really helping my understanding of wtf is going on here
18:13:42 <bens> McManiaC: there's a pgsql config option bytea_output which defaults to 'hex' in v9, try setting it to 'escape'.
18:13:42 <lambdabot> bens: You have 1 new message. '/msg lambdabot @messages' to read it.
18:13:45 <Berengal> Alan: So the State monad is basically defined as the type s -> (a, s), a function "return :: a -> (s -> (a, s))" and a function "(>>=) :: (s -> (a, s)) -> (a -> (s -> (b, s)) -> (s -> (b, s)"
18:14:05 <hpc> McManiaC: toSql already uses SqlByteString
18:14:29 <McManiaC> hpc: yep just saw that too
18:14:31 <Alan> Berengal: so >>= is "state composition"?
18:14:44 <McManiaC> bens: where would you set that option? in the connection string?
18:14:53 <Berengal> Alan: The types start to become a little complicated at this point, as you can see, and we might like to use the type (s -> (a, s)) for other things as well, so we define "type State s a = (s -> (a, s))"
18:15:08 <Berengal> Alan: Well, State-computation composition
18:15:51 <Alan> Berengal: right, but since a state is an individual computation on a previous state... doesn't that mean >>= could be views as composing 2 states into 1?
18:15:56 <bens> McManiaC: /etc/postgresql/9.0/main/postgresql.conf most likely
18:16:19 <McManiaC> ah k
18:17:00 <Berengal> Alan: When I hear "State" I think "value at point in time" (time not neccessarily defined as real-world time), whereas the State monad isn't exactly that. It's a computation on state
18:17:01 <acowley`> No, it's threading a state through two computations
18:17:17 <Berengal> So a computation that takes an old state as input and returns a new state as output
18:17:31 <Berengal> StateComputation is a bit of a mouthful though
18:18:01 <Alan> Berengal: yeah, that's what I thought - understanding what the State monad means by "state" makes a HUGE difference!
18:18:27 <Berengal> Composing two states might mean many different things; after all a "state" isn't a defined thing; it might be an int, or a string, and composition might be any of addition, multiplication, concatenation etc. etc.
18:19:18 <McManiaC> bens: nope :(
18:19:22 <McManiaC> same error
18:19:22 <Alan> Berengal: ok, i can see where i got a bit over-excited with terminology there :P
18:19:31 <Berengal> Composing two stateful computations, on the other hand, has just one clear meaning; produce a new stateful computation that gives the old state to the first computation, then gives the resulting state to the second computation and finally returning the final state
18:20:30 <Alan> Now i've just found my way to my first ever use of mapM_ :D
18:21:05 <Berengal> (>>) does that. (>>=) composes a stateful computation and a function returning a stateful computation, by applying the function to the non-state result of the first computation, then threading the state just like (>>)
18:21:15 <bens> McManiaC: to #haskell-blah?
18:21:30 <McManiaC> ok
18:22:13 <Berengal> Alan: I prefer forM_. It's the same, but with arguments flipped
18:22:27 <Berengal> (Reads more like a foreach)
18:22:56 <Alan> Berengal: i guess in the context of a State monad, maybe makes more sense
18:23:09 <Alan> i.e. looks like sequential stateful code
18:23:45 <Berengal> Alan: It's just a personal preference...
18:23:53 <Berengal> Alan: Also, if you want your mind broken; http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
18:24:26 <Alan> Berengal: i'll put it in my "to-read" list - i've only just managed to get this straight in my head!
18:24:31 <acowley`> I much prefer mapM_ because it is like map, and I usually want to partially apply it to a function rather than a list.
18:25:22 <jmcarthur> forM_ is convenient when the function is a big do block though
18:25:49 <acowley`> true, but that's already a code smell
18:26:02 <jmcarthur> not if you are using the opengl bindings :P
18:26:25 <Berengal> ... maybe that's the code smell...
18:26:32 <jmcarthur> okay, it's still a smell, but it's not my fault
18:26:40 * Berengal haven't used the openGL bindings
18:26:52 <jmcarthur> the opengl bindings are basically just low level C
18:26:53 <acowley> no, the solution is to factor out the function
18:27:12 <acowley> no matter the smellyness of the library in use
18:27:30 <jmcarthur> sure, if you can also find a decent way to pass all the free variables as parameters or create a complicated structure for them to all go in
18:27:32 <Berengal> The weird thing is I used to use mapM_ all the time, but now I use forM_ all the time. In the same way, I used to use list comprehensions all the time before, but now I use pointfree composition of list functions instead
18:28:21 <acowley> how are they the same?
18:28:22 <ddarius> Isn't the weird thing that those are opposite "ways?"
18:28:48 <Berengal> ddarius: What do you mean by "ways"?
18:28:52 <acowley> the distinction between forM_ and mapM_ is purely whether you are more likely to partially apply to a function or a list
18:29:01 <acowley> unless you're doing some big inline definition like jmcarthur is talkinga bout
18:29:13 <jmcarthur> IMO, mapM_ is more like the point free style than forM_ is
18:29:25 <Berengal> acowley: Well, the distinction between forM_ and mapM_ is more wether you are going to partially apply it or not...
18:30:00 <acowley> jmcarthur: agreed
18:30:16 <acowley> Berengal: that was implied in what I said
18:30:24 <Berengal> Often when I use forM_ I've got something like 'do {list <- getList; forM_ list $ \item -> do {...}}
18:30:31 <acowley> if you're not going to partially apply it, then there is no distinction other than convention of for vs. map
18:30:42 <acowley> that's the case jmcarthur is talking about
18:30:57 <jmcarthur> Berengal: why not:   mapM_ (\item -> ...) =<< getList   ?
18:31:07 <acowley> but that's a case where I put the function in a where
18:31:08 <jmcarthur> (and if you do well you get rid of \item ->
18:31:16 <jmcarthur> )
18:31:19 <acowley> right
18:31:20 <int80_h> http://hpaste.org/45475/question_about_write_yourself
18:31:28 <acowley> mapM_ (foo . bar) =<< getList
18:31:45 <Berengal> jmcarthur: The other way would probably work better for the large blocks; getList >>= mapM_ \item -> ...
18:31:52 <ddarius> Having a giant local definition is hardly much better than having a giant expression.
18:32:00 <Berengal> It's not always quite that clear though
18:32:27 <jmcarthur> Berengal: i agree. goes back to my opengl example. i just hate it when the code is so context-sensitive that that seems like such a good choice
18:32:29 <acowley> ddarius: sure it is! better pattern matching syntax and an easier move to the top-level if re-use is desired
18:33:00 <jmcarthur> local definitions smell almost as bad to me as big local functions
18:33:11 <acowley> They are local functions
18:33:13 <Berengal> jmcarthur: Agreed. Our different styles might just be a function of different library contexts
18:33:19 <jmcarthur> s/functions/expression/
18:33:24 <acowley> with better pattern matching syntax and an easier road to the top-level if needed :P
18:33:47 <acowley> oviously anything "big" is probably bad, but sometimes hard to avoid
18:33:53 <jmcarthur> acowley: yes, they are preferable to big do block parameters or something, but they have the same design smells
18:34:25 <jmcarthur> acowley: in the sense that they still have almost the same big context they would if they were inline
18:34:50 <Berengal> int80_h: "digit" is a parser. It's defined in the Parsec library used by the tutorial
18:34:52 <acowley> I think there's also an indentation argument about keeping things from going too far right
18:35:21 <int80_h> Berengal: thanks :)
18:35:47 <Berengal> acowley: Haskell indentation is flexible enough that you can avoid right-leaning code with a bit of practice
18:35:50 <int80_h> Berengal: so this must be an example of partial application, right?
18:36:11 <jmcarthur> Berengal: but indentation that's too deep is also a sign of that same context-sesitivity :\
18:36:18 <Berengal> int80_h: Not exactly. many1 has type Parser a -> Parser [a]
18:36:18 <acowley> Berengal: yes, practice like using where!
18:36:44 <jmcarthur> int80_h: digit is more like a value than a function, at least as exposed in the parsec interface
18:37:15 <jmcarthur> err, not that values and functions are mutually exclusive..
18:37:18 <Berengal> acowley: I was thinking more along tricks like unparethesized lambdas and hanging indents..
18:37:27 <ddarius> Code running off to the right is indicative of a potential problem, not a problem in and of itself (unless, I guess, your code is shear off the page.)
18:37:36 <Berengal> acowley: Not to say that using where isn't the better choice
18:38:18 <int80_h> jmcarthur: thanks, I think I need to play around with this. But tha's what it's for.
18:38:21 * ddarius has had triply, maybe even quadruply, nested where clauses.
18:38:39 <acowley> ddarius: not in polite company, I hope
18:38:41 <int80_h> that must look hideous
18:38:52 <jmcarthur> it looks hideous in my mind
18:39:14 * int80_h banished ddarius to the php channel to think about what he's done.
18:39:31 <Berengal> ddarius: Me too. At that point, however, I usually go off to define a new datatype, or if I'm feeling lazy, put lambdas everywhere
18:51:18 <christo_m> acowley: hey i have a question
18:51:39 <christo_m> im trying to do some basic expressions, like nil false and true.. its telling me Expr is not in scope, yet its clearly defined in LuaAS.hs which i have imported
18:51:45 <christo_m> especially since i was able to do the same with Block earlier
18:52:11 <christo_m> acowley: http://hpaste.org/45476/expr , doing something like that, not sure how right it is
18:52:24 <christo_m> ive built a small expression table for simple arithmetic operations right now also
18:53:30 <acowley> I guess LuaAS isn't exporting the data constructor
18:54:31 <christo_m> acowley: weird.. 
18:54:51 <acowley> do you have a link to LuaAS.hs?
18:55:32 <christo_m> http://hpaste.org/45472/luaas
18:55:57 <acowley> Expr isn't a data constructor
18:56:22 <acowley> just delete the token "Expr" from the exp parser
18:56:28 <acowley> it is a type
18:56:36 <acowley> it has constructors Nil, Bool, etc.
18:57:36 <christo_m> acowley:     Couldn't match expected type `GenParser tok st a'
18:57:37 <christo_m>            against inferred type `Expr'
18:57:55 <christo_m> type signatures.. again
18:58:01 <christo_m> im so nub
18:58:05 <acowley> well that may be a problem with your indentation and grouping
18:58:54 <acowley> I think it's the low precedence of $
18:59:09 <acowley> you could try using return (Expr Nil) 
18:59:11 <acowley> and so on
18:59:45 <christo_m> should i be using do here?
19:00:01 <acowley> no
19:00:06 <acowley> well, I wouldn't
19:00:22 <christo_m> thought so
19:00:22 <acowley> exp = (reserved nil >> return (ExprNil)) <|> ...
19:00:28 <christo_m> right
19:00:30 <christo_m> thats what i was doing
19:00:30 <acowley> I don't know if those parens are needed
19:00:36 <christo_m> ill put them anyway
19:00:38 <christo_m> lisp stylez
19:01:15 <acowley> isn't there a combinator "foo" so you can do: foo ExprNil (reserved nil)
19:01:16 <acowley> ?
19:02:46 <acowley> maybe not
19:02:51 <christo_m> i dont think so
19:03:18 <christo_m> http://www.haskell.org/haskellwiki/Parsing_a_simple_imperative_language -> they do it the same way you did here
19:03:22 <christo_m> for expressions
19:03:58 <acowley> I suppose that's a good sign
19:04:08 <christo_m> unless this tut is deprecated..
19:04:19 <christo_m> a lot of the docs i find are old..
19:04:20 <acowley> Though, I'd write that combinator myself and use it here
19:04:36 <acowley> res v p = p >> return v
19:04:50 <acowley> I don't know if res is a good name
19:04:57 <acowley> well, I know it's not a good name
19:06:26 <christo_m> haha now i cant think of a name 
19:06:30 <christo_m> least of my worries anyway
19:07:07 <acowley> As long as you don't export it, giving it a lame name isn't the end of the world
19:09:40 <christo_m>     Couldn't match expected type `Expr'
19:09:41 <christo_m>            against inferred type `CharParser () ()'
19:09:53 <christo_m> is it because of the reserved strings?
19:10:52 <christo_m> i put exp :: Parser Expr
19:11:10 <christo_m> when i remove it, it infers type expr.. weird
19:11:32 <acowley> paste the new exp
19:12:20 <christo_m> http://hpaste.org/45477/exp
19:13:12 <monochrom> my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements is less outdated, i.e., it uses Parsec 3 :)
19:13:44 <ddarius> @hoogle ($>)
19:13:44 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
19:13:45 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
19:13:45 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
19:13:47 <acowley> Annotate simpleexp with its type
19:13:50 <christo_m> monochrom: thank you
19:14:09 <monochrom> to be fair, to a large extent, you just have to change imports
19:14:15 <ddarius> @hoogle (<$)
19:14:15 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
19:14:15 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
19:14:15 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
19:14:48 <ddarius> Oh, I flipped the order anyway, so it is just (<$).
19:15:40 <christo_m> monochrom: when i switch to their imports it breaks..
19:15:44 <christo_m> i think ill just keep the way i have it now
19:17:03 <christo_m> acowley: im not sure i know its type
19:17:13 <christo_m> i dont know what reserved returns
19:17:19 <christo_m> i know p is of type Expr
19:18:02 <christo_m> sorry v
19:18:41 <monochrom> reserved :: GenTokenParser s u m -> String -> ParsecT s u m ()
19:19:10 <acowley> I think it can be something like a -> Parser b -> Parser a
19:19:14 <monochrom> there is good chance you can pretend s=String, u=(), m=Identity
19:20:17 <christo_m>     Couldn't match expected type `Expr'
19:20:18 <christo_m>            against inferred type `CharParser () ()'
19:20:20 <christo_m> still getting this
19:21:13 <acowley> that error is on exp?
19:21:32 <christo_m> yes
19:22:38 <acowley> I'm not sure why that's happening
19:23:45 <christo_m> acowley: http://hpaste.org/45479/exp
19:23:47 <christo_m> exactly what i have
19:25:56 <monochrom> do you really have a type called Expr?
19:26:27 <acowley> Where is the Parser type defined?
19:26:33 * hackagebot husk-scheme 2.3 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-2.3 (JustinEthier)
19:27:28 <monochrom> hopefully type Parser = Parsec String () from Text.ParserCombinators.Parsec.Prim?
19:28:01 <christo_m> monochrom: yes
19:28:01 <christo_m> acowley: umm
19:29:16 <christo_m> i dont know where parser is defined either
19:29:19 <christo_m> i cant find it in the docs
19:29:21 <christo_m> or api rather
19:30:51 <Berengal> This C++ library I'm writing bindings for has lots of mutable state. Mostly typical stuff like get/set and related functions (move/scale/rotate etc). What are the best options for making those cases more suited to Haskell?
19:31:45 <parcs> the State monad
19:31:56 <acowley`> Oh
19:32:02 <christo_m> acowley`: ?
19:32:17 <djahandarie> You can simply hide the mutable state entirely if it is not core to the actual function of the library.
19:32:26 <Berengal> djahandarie: It's pretty core
19:32:36 <djahandarie> i.e., if you can present it as a single pure function, then just hide anything about mutation
19:32:42 <djahandarie> Berengal, in terms of operation or semantics?
19:32:44 <acowley`> reserved wants a lexer
19:32:51 <christo_m> acowley`: maybe i shouldnt have this combinator
19:33:08 <christo_m> because it compiled before
19:33:45 <christo_m> acowley`: reserved  = P.reserved lexer
19:33:46 <christo_m> i have this
19:33:54 <Berengal> djahandarie: Operation is semantics in this case mostly
19:34:06 <acowley`> You can use the LanguageDef stuff, and it's very helpful, but I don't know what you've defined so far
19:34:15 <Berengal> djahandarie: Most operations are clearly in IO, but the data it operates on is also mutable.
19:34:26 <JoeyA> Is it possible to define a type constructor alias?  (e.g. make P be a synonym of (,))
19:34:30 <acowley`> I've also got to head out now, so best of luck christo_m, I"m sure other #haskellers will be able to help!
19:34:32 <JoeyA> I just want to do it temporarily while I refactor something.
19:34:45 <JoeyA> err, data constructor
19:34:50 <Berengal> djahandarie: The operations *do* belong in IO, I have no qualms about that. Modifying the data, however, seems like it could be fixed better
19:34:54 <JoeyA> type P a b = (a, b)  (that's for types)
19:35:03 <christo_m> okay , thanks
19:36:50 <ddarius> JoeyA: Not so that you can pattern match, which I assume is what you want.  Otherwise it's just a function.
19:37:13 <JoeyA> ddarius: Right, that's what I wanted.
19:37:23 <JoeyA> but it's not a big deal
19:37:34 <christo_m> whats >> mean in haskell?
19:37:45 <ddarius> @src (>>)
19:37:45 <lambdabot> m >> k      = m >>= \_ -> k
19:37:46 <ddarius> That.
19:37:51 <JoeyA> > putStr "Hello " >> putStrLn "world!"
19:37:51 <lambdabot>   <IO ()>
19:38:01 <djahandarie> Berengal, take a look at these slides by kmc: http://www.ugcs.caltech.edu/~keegan/talks/high-level-ffi/talk.html . I don't know if they have an exact answer for what you are doing (he managed to roll everything into a single pure function), but there are some neat tricks in there
19:38:12 <christo_m> now im more confused.
19:38:53 <Berengal> djahandarie: I've looked at them. I can't roll everything into a single function like he did, but there are *some* things I can do
19:38:58 <JoeyA> christo_m: Think of it as: do two actions, one after the other (ignore the result of the first action, but return that of the second action)
19:39:22 <Berengal> Just trying to find the best overall approach right now...
19:39:24 <aristid> christo_m: if you have two IO actions, like putStr "Hello " and putStrLn "World!", you can chain them together with >>, so they result in an IO action that will perform both sequentially
19:39:37 <JoeyA> It's like a semicolon :-)
19:40:12 <Berengal> > [1,2] >> [3,4]
19:40:12 <lambdabot>   [3,4,3,4]
19:40:19 <JoeyA> Another use of >> (and its cousin, the monadic bind operator >>=) is to confuse new Haskellers.
19:40:25 <JoeyA> > "Hello, world" >> "AA"
19:40:26 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAA"
19:40:40 <Alan> wut the wut?
19:40:50 <christo_m> ahh
19:40:50 <christo_m> okay
19:41:04 <Berengal> > "Hello, world" >>= \c -> [c, '!']
19:41:05 <lambdabot>   "H!e!l!l!o!,! !w!o!r!l!d!"
19:42:04 <dankna> but confusing new Haskellers isn't very friendly is it, haha
19:42:06 <djahandarie> Berengal, I'm not to sure then. I don't think there is a particularly nice solution for managing state/getters/setters if you need them no matter what
19:42:48 <JoeyA> dankna: Oh, but it is.  Friends don't let friends Haskell.
19:42:49 <Berengal> djahandarie: Freeze/thaw is better than just giving up and exposing the C-api directly at least (assuming copying doesn't become too much of a bother)
19:43:29 <lars9> is XMonad.hsc generated by compiler or written by dons?
19:44:04 <shachaf> Trick question! dons is a compiler.
19:44:22 <aristid> > "Hello, " >> "World"
19:44:23 <lambdabot>   "WorldWorldWorldWorldWorldWorldWorld"
19:44:41 <Berengal> lars9: Probably written, but maybe with some tool help
19:44:44 <lars9> > [1..] >> [1..]
19:44:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:44:59 <shachaf> lambdabot: Where you do see an XMonad.hsc?
19:44:59 <magicman> > [1..] >> "a"
19:45:00 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:45:10 <shachaf> s/mbdabot/rs9/
19:45:14 <christo_m> > [1..]
19:45:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:45:18 <aristid> :t concatMap . const
19:45:18 <lambdabot> forall a b. [b] -> [a] -> [b]
19:45:20 <christo_m> mhm
19:45:25 <aristid> :t flip $ concatMap . const
19:45:26 <lambdabot> forall a b. [a] -> [b] -> [b]
19:45:27 <Berengal> > [1..] >>= \i -> map (*i) [1..3]
19:45:28 <lambdabot>   [1,2,3,2,4,6,3,6,9,4,8,12,5,10,15,6,12,18,7,14,21,8,16,24,9,18,27,10,20,30,...
19:47:32 <lars9> Berengal: when is hsc needed?
19:47:55 <koninkje> whenever dealing with *.hsc files
19:48:04 <Berengal> lars9: hsc files are regular haskell files except for some preprocessor directives for the hsc2hs preprocessor
19:48:08 <koninkje> not to be confused with *.chs files
19:48:28 <Berengal> It's to help with writing C-bindings
19:48:31 <lars9> Berengal: oh, it has special annotations?
19:48:49 <Berengal> Yes
19:49:16 <lars9> such as?
19:49:27 <Alan> hmm, is there an easy way to get an order-preserved set of something?
19:49:32 <koninkje> lars9: Check out http://community.haskell.org/~wren/unix-bytestring/src/System/Posix/Types/Iovec.hsc
19:49:56 <koninkje> lars9: In particular, the Storable CIovec instance
19:51:06 <Berengal> lars9: .chs files are similar, but for the c2hs preprocessor instead
19:51:44 <lars9> koninkje: what is alignment _ = #{alignment struct iovec} ?
19:51:47 <koninkje> lars9: the #{peek}, #{poke}, #{size}, and #{alignment} macros allow portably getting the right answer based of the C header files 
19:52:56 <Berengal> lars9: It's replaced by the preprocessor to for example "4" before handing it off to the compiler
19:52:57 <koninkje> it's defining the 'alignment' function, ignoring the argument (which is only passed for type-checking), by using the #{alignment} hsc2hs macro (which is defined in the #let macro just above the instance
19:52:59 <ddarius> koninkje: It doesn't rely on the C headers.
19:53:07 <ddarius> (At least not directly.)
19:53:20 <koninkje> ddarius: well, it does when linking against them (as I'm doing there)
19:53:23 * ddarius loves how hsc2hs works.
19:53:29 <koninkje> but yes, not directly
19:53:55 <Berengal> hsc2hs is pretty funky in its workings...
19:54:18 <koninkje> lars9: the alignment function is for finding out what kind of alignment something needs (you know about alignment constraints?)
19:54:44 <koninkje> Basically I'm just passing the #{alignment} macro the "struct iovec" C type
19:54:51 <lars9> 4 bytes align in c's structs? 
19:55:02 <koninkje> well, it depends on the struct
19:55:09 <Berengal> And the platform
19:55:30 <koninkje> right
19:55:45 <lars9> koninkje: seems i can understand some hsc annots now, thanks
19:56:25 <koninkje> if you want to see what the output looks like, check out http://community.haskell.org/~wren/unix-bytestring/dist/doc/html/unix-bytestring/src/System-Posix-Types-Iovec.html
19:56:41 <koninkje> it's nice not to have to maintain all those magic numbers
19:57:28 <lars9> yeah
19:58:02 <lars9> does haskell make a copy of everything? otherwise how does it know when to drop return value to gc?
19:58:29 <Berengal> lars9: Haskell has a ForeignPtr type, which is basically a C-pointer plus finalizers
19:58:46 <koninkje> Computers: Solving the problems we have with computers since 1801.
19:59:24 <Berengal> When writing C-bindings, you put any pointers you get which you have to free yourself into a ForeignPtr and associate the appropriate finalizer call
19:59:59 <Berengal> lars9: For example, take a look at https://github.com/Berengal/SFML---Haskell-bindings/blob/master/SFML/System/Internal/Clock.chs
20:00:00 <lars9> Berengal: and hsc2hs can do that magically?
20:00:12 <Berengal> lars9: That's not hsc2hs, that's the haskell runtime
20:01:00 <Berengal> That file is using c2hs, not hsc2hs by the way.
20:01:55 <kmc> lars9, did you read the RWH chapter on FFI?
20:02:20 <lars9> i meant to figure out how to destroy a c pointer, like the clockDestroy in that link
20:02:24 <kmc> i think it mentions ForeignPtr? not sure actually
20:02:27 <lars9> who did that?
20:02:36 <kmc> what does "destroy a c pointer" mean?
20:02:41 <lars9> kmc: oh i skipped it...
20:03:04 <lars9> finalize
20:03:45 <kmc> it depends on how you got the pointer
20:03:51 <Berengal> lars9: If you look at the Clock_Create function, the last part saying "`Clock' mkClock*" means that "this function returns a Clock (defined as ForeignPtr Clock) after being converted by the mkClock function"
20:04:16 <kmc> if it came from 'malloc', you call 'free', same as in C
20:04:28 <Berengal> As you can see, the mkClock function takes the raw pointer, then creates a ForeignPtr using the raw pointer and a finalizer (clockDestroy :: FinalizerPtr Clock)
20:04:29 <kmc> if your library handles its own allocation, then you have to conform to that
20:05:07 <lars9> for example, from function type: const char * mysubstring (char *, int, int), there is no way to figure out if we can call free () on returned substring.
20:05:25 <kmc> yeah, you have to read the library's documentation to know what to do
20:05:27 <Berengal> lars9: That's true in C as well
20:05:30 <kmc> same as if you were using that library from C
20:06:23 <lars9> oh i see
20:06:32 <Berengal> lars9: Take a look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Alloc.html
20:07:09 <lars9> there is no "free" in XMonad.hsc though.
20:07:17 <lars9> Berengal: ok thanks
20:07:49 <kmc> sadly C is still C even in Haskell
20:09:42 <lars9> now i like ocaml's style of using module: use module name as prefix all the time, it saves a lot of time when reading code.
20:09:57 <kmc> you can do that in Haskell too
20:10:06 <lars9> like import every module using qualified as
20:10:16 <Berengal> kmc: But it's not very common
20:10:21 <kmc> yeah, i typically do that for everything except "standard" modules
20:10:28 <kmc> but qualified to short names
20:10:40 <Berengal> I try to do it, but the problem is that doing it doesn't help me in any way
20:10:50 <kmc> i find it helps me
20:10:56 <kmc> easier refactoring
20:11:08 <kmc> if i want to ditch module X for module Y, it's easy to see where I'm using X
20:11:08 <Berengal> It only makes it more bothersome to write the code, and I have no need for better reading comprehension
20:11:19 <kmc> you don't need to read the code that you write?
20:11:43 <Berengal> I don't need to build comprehension of the code that I write
20:11:50 <Berengal> I did that before I wrote it
20:12:00 <Berengal> (And I have very good memory)
20:12:04 <kmc> don't you come back to code you wrote a month ago and think "wtf"
20:12:28 <Berengal> Well, I do go "wtf" sometimes, but not because I don't understand it
20:12:33 <lars9> there is a function called "asks" in xmonad's code, and grep "^asks" gives no results
20:12:41 <kmc> ok, then you're a better programmer than me Berengal :)
20:12:51 <gwern> lars9: asks is a helper function in the Reader monad
20:12:57 <Berengal> kmc: No, as I said, I just have good memory
20:13:10 <lars9> gwern: thanks
20:13:16 <Berengal> lars9: cabal install hoogle
20:13:23 <Berengal> @hoogle asks
20:13:23 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
20:13:38 <gwern> lars9: reader monad is just named variables being passed around invisibly, x_1, x_2, ... x_n; so you do 'asks x_2' to get its value
20:13:58 <gwern> lars9: or in the case of xmonad, 'asks terminal' or whatever
20:14:08 <kmc> @src asks
20:14:08 <lambdabot> asks f = do
20:14:08 <lambdabot>     r <- ask
20:14:08 <lambdabot>     return (f r)
20:14:24 <lars9> isn't is get?
20:14:28 <lars9> @hoogle get
20:14:29 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
20:14:29 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
20:14:29 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
20:14:44 <kmc> or more succinctly "asks f = f <$> ask" or "asks = (<$> ask)"
20:14:49 <lars9> oh it's StateT
20:14:52 <kmc> get is for State; ask is for Reader
20:14:53 <Berengal> get is for the State monad, but it does the same
20:15:04 <gwern> States = Writer + reader, iirc
20:15:10 * kmc wishes we could stop using the word "monad" for all types that happen to be monads
20:15:24 <Berengal> gwern: Reader + Writer - Monoid
20:15:33 <shachaf> ...Kind of.
20:15:40 <lars9> gwern: then what is RWS? i was always wondering
20:16:12 <shachaf> ReaderT r (WriterT w (State s ...))
20:16:34 <lars9> if state = reader + writer, why we need state again?
20:16:54 <kmc> if you want to break up your state into read-only, write-only, and read-write parts
20:16:58 <kmc> to make it easier to manage 
20:17:12 <kmc> xmonad has read-only config and updated state
20:17:19 <lars9> kmc: oh get it.
20:17:22 <Berengal> lars9: Often you have some things you can only read (for example command line args), some things you can only write (logs) and some things you can do both for (program state)
20:17:27 <kmc> you don't "need" any of these
20:17:45 <shachaf> More "append-only" than "write-only".
20:18:08 <Berengal> mappend-only...
20:18:46 <shachaf> @ty (++)
20:18:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:20:12 <lars9> i'm trying to figure out if xmonad's write writing whole xstate or just write the diff
20:20:27 <kmc> in what sense do you mean
20:21:20 <kmc> in GHC's runtime system, all your record fields are pointers
20:21:48 <kmc> when you update a record at a single field, the old fields hold the same pointer values
20:22:36 <lars9> for example, there are 100 windows, i focus to next window and nothing else changes, is xmonad writing a whole new xstate and refresh everything or just the diff of old and new state
20:22:46 <kmc> you mean writing to X?
20:23:12 <lars9> yeah
20:23:35 <lars9> newtype X a = X (ReaderT XConf (StateT XState IO) a)
20:24:00 <kmc> that's the X monad ;)
20:24:03 * copumpkin wants an IOT
20:24:51 <kmc> copumpkin, be careful what you wish for
20:25:28 <vagif> is there a way to quickly check which of the installed packages has a new version on hackage ?
20:26:01 <vagif> something like "cabal whatsnew" ?
20:31:48 <Berengal> vagif: You can use "cabal install --upgrade-dependencies --dry-run" to see if a particular package has updated requirements
20:33:04 <Berengal> "cabal upgrade" used to list packages with updated versions, but now it just lists a static deprecation warning
20:37:55 <Alan> Bah, silly function naming....
20:38:18 <Alan> I just implemented my own "unique list" thing because i didn't know about "nub"
20:38:20 <Alan> :t nub
20:38:21 <lambdabot> forall a. (Eq a) => [a] -> [a]
20:40:12 <djahandarie> Thankfully, it isn't that hard to write your own if you know a bunch of other functions with silly names
20:40:18 <djahandarie> :t map head . group . sort
20:40:19 <lambdabot> forall a. (Ord a) => [a] -> [a]
20:40:59 <djahandarie> This one has an Ord constraint on it, but it's also O(n * lg n) compared to nub which is O(n^2)
20:42:40 <Alan> djahandarie: but that's absolutely not what i want, and not what nub does
20:42:49 <Alan> i think, anyway
20:42:57 <Alan> the "sort" implies as much
20:43:14 <Alan> nub "preserves the first occurence", which means i'll keep the order in which they appeared
20:43:20 <djahandarie> Yes, this is true.
20:43:32 <djahandarie> If order matters then map head . group . sort is no good
20:43:44 <applicative> > (,) <$> nub <*> (map head . group . sort) $ "Alcatraz"
20:43:45 <lambdabot>   ("Alcatrz","Aaclrtz")
20:43:58 <Alan> map head . group . sort == Set.toList . Set.fromList
20:43:58 <Alan> ?
20:44:05 <lars9> > Set.fromList
20:44:06 <lambdabot>   Not in scope: `Set.fromList'
20:44:22 <djahandarie> Alan, not operationally. The results will be the same though.
20:44:46 <c_wraith> Alan: nub is also lazy.
20:44:46 <djahandarie> Actually, I'm not sure about the order of what Set will return, might not be sorted.
20:44:56 <lars9> Alan: you can use State to speed up though
20:44:59 <c_wraith> > take 20 $ nub [1..]
20:44:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
20:45:00 <Alan> djahandarie: it is sorted
20:45:15 <Berengal> djahandarie: It'll return a sorted list, but only by coincidence in the implementation of Set
20:45:25 <djahandarie> Yeah
20:45:31 <Berengal> djahandarie: There is a toAscList if you require ordering
20:51:52 <jmcarthur> Data.Set.toList should permute the output just to spite people
20:54:20 <Berengal> I think we should add a Data.Set.realToList that shows the list and preprocesses C-trigraphsm, just for good measure
20:55:25 <lars9> how to use qualified import in ghci?
20:56:09 <kmc> in GHC 7 you just write the same you'd write in a file
20:56:15 <kmc> before that, you can't directly
20:56:22 <kmc> but you can load a file with a qualified import
20:56:48 <lars9> mine is 7.0.2
20:57:52 <lars9> import qualified Data.Set as S,   then use S.empty ..., then got Failed to load interface for `S'
21:00:13 <dncr> lars9: works for me
21:00:38 <dncr> ghci --version
21:00:38 <dncr> The Glorious Glasgow Haskell Compilation System, version 7.0.2
21:01:58 <lars9> same version
21:02:13 <ian_mi> are you sure you have the glorious one?
21:02:14 <applicative> this 'import qualified ...' in ghci is really awesome. 
21:02:17 <ourfrank> Does anyone know how to artifically send events to windows using the gtk binding? I can't seem to figure this out.
21:02:41 <dmwit> ourfrank: Windows you control?
21:02:48 <ourfrank> dmwit: Yes.
21:02:51 <lars9> The Glorious Glasgow Haskell Compilation System, version 7.0.2
21:03:01 <ian_mi> ah, ok
21:03:17 <ourfrank> dmwit: I have the Window value and I'd like to send a keypress event to it.
21:03:20 <lars9> >import Data.Set; empty
21:03:27 <lars9> > import Data.Set; empty
21:03:28 <lambdabot>   <no location info>: parse error on input `import'
21:03:39 <lars9> > +m Data.Set; empty
21:03:39 <lambdabot>   <no location info>: parse error on input `+'
21:03:49 <dncr> :t empty
21:03:50 <lambdabot>     Ambiguous occurrence `empty'
21:03:50 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
21:03:50 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
21:04:01 <dncr> :t S.empty
21:04:02 <lambdabot> forall a. S.Set a
21:04:22 <ourfrank> dmwit: It seems "widgetEvent" or "mainDoEvent" might have something to do with this, but I can't figure out how to actually use them.
21:04:51 <lars9> > Data.Set.empty
21:04:52 <lambdabot>   Not in scope: `Data.Set.empty'
21:08:23 <ourfrank> It seems refiring events is not possible with the Haskell bindings: http://is.gd/LS9Ld3
21:11:08 <osoleve> how do i run hlint if i cabal install it?
21:11:21 <dobblego> osoleve: ~/.cabal/bin/hlint
21:11:30 <osoleve> thanks
21:17:06 <ddarius> pumpkin: There's an STT for some values of "is."
21:26:12 <dmwit> ourfrank: Why not just call the same function you've installed as the key handler?
21:33:01 <osoleve> how do you desugar a do with a (a <- b) in it?
21:33:04 <osoleve> just curious
21:35:21 <jmcarthur> @undo do { x <- foo ; bar x }
21:35:21 <lambdabot> foo >>= \ x -> bar x
21:35:21 <applicative> you mean do { a <- b ; print a} ?
21:35:49 <osoleve> neat, thanks
21:35:56 <osoleve> i didn't know about @undo
21:37:25 <applicative> @do b >>= \ a -> grr b
21:37:25 <lambdabot> do { a <- b; grr b}
21:37:58 <osoleve> last question for now, if i'm doing { catch (hGetLine h) (...) } what can go in place of (...)?
21:38:13 <osoleve> i'm having trouble with that
21:50:27 <osoleve> hey, i figured it out!
21:50:29 <osoleve> :D
22:03:22 <ourfrank> dmwit: Because I haven't installed any. It's an inbuilt handler, a treeview filter which searches for whatever is typed when the treeview has focus. I need to somehow notify this filter that, say, the 'A' key has been pressed. Thanks for trying, I'm grateful for any help. :)
22:05:43 <Bfig_> what's the best place to read about monads?
22:05:52 <Bfig_> i just need a brief intro to I/O
22:06:20 <osoleve> http://book.realworldhaskell.org/read/io.html
22:07:21 <accel> any phd thesis on category theory
22:07:48 <t-cell> (I hope this is not off topic, but) Does anyone know how to get Hackage packages added to FreeBSD Ports? I do web programming in Haskell and my hosting company is picky about where they accept packages from.
22:07:50 <Bfig_> mmm i just found something cool. can i use \ _ -> to read from the 'stdin' ? p
22:07:51 <Bfig_> :p *
22:08:43 <osoleve> getLine >>= \foo -> print foo ?
22:08:57 <Bfig_> yes
22:09:23 <conal> Bfig_: note that IO is almost entirely not about monad(s). so if you're mainly interested in IO, don't worry much about Monad.
22:09:49 <Bfig_> i need a monad i think to save some variables
22:10:36 <conal> Bfig_: the main idea of IO is a data type of actions as values. it so happens to be a monad, but most of the action comes from IO-specific operations, not the Monad interface.
22:11:07 <Bfig_> ie, i have variables A, B, C... Z and they can have a polyinomial in them. i must read from the stdin and perform CRUD
22:12:05 <Bfig_> so i need a monad to save the variables, and i need the io monad to interact with the user
22:12:37 <conal> there is nothing about variables in the Monad interface.
22:12:54 <Bfig_> how do you have states then?
22:14:50 <conal> Bfig_: with a specific type that supports state, which may or may not have a corresponding Monad instance (along with instances of other type classes, such as Functor, Applicative, and Monoid). the monad-ness (or not) has nothing to do with the statefulness.
22:15:33 <applicative> Bfig_ maybe you should say more about the problem
22:16:16 <DocTijn> I'm running ubuntu 10.10, I installed ghc6 but when I do 'cabal install haddock' it says that I need ghc7 or higher... Is there a way to install haddock for ghc6?
22:16:47 <applicative> is there a haddock available for ubuntu too?  
22:17:03 <DocTijn> does not appear in the package manager
22:17:23 <Bfig_> applicative, i need to read from stdin, parse some manipulation of a polynomial expression (ie: " A = 2x^3 + P + Q + 1 + ( 24x^5 + 3x^2)/ (x^2 + 3)" ), and do something (compute result and show, save in variable)
22:17:44 <applicative> DocTijn, something like this?  http://packages.ubuntu.com/natty/ghc6-haddock
22:18:32 <Bfig_> i'd need to make a command parser, a polynomial expr parser, some way to save state of the variables (A to Z)
22:18:34 <DocTijn> applicative: that might look like an answer. I'll try it. thnx!
22:18:58 <Bfig_> the polynomial sum, mult, sub, integer division and mod are already solved
22:20:27 <applicative> what are the things you are getting from stdin?
22:21:30 <copumpkin> it's funny how we can detect class assignments
22:21:38 <applicative> if it is all a string, and all you need is to produce a string, you can reduce the problem to main = interact bfig where bfig parses, solves etc
22:21:39 <copumpkin> when a bunch of different people pop into the channel asking the same question in a short period
22:22:15 <applicative> copumpkin: is that where the polynomials are coming from? 
22:22:21 <copumpkin> I'm guessing
22:22:30 <copumpkin> I could've sworn there was someone else with the same stuff the other day
22:22:32 <applicative> in any case, I have taken the occasion to mention interact !
22:23:13 <Bfig_> applicative, that sounds what i have to do, is interact like a do ... while (..  ) ?
22:23:31 <copumpkin> not really
22:23:31 <Bfig_> that obviously takes input from stdin
22:27:49 <applicative> Bfig, it takes a string from stdin and gives a string to stdout.  if you need further user interaction its trouble, but it can handle all sorts of intervening calculations
22:28:01 <applicative> @type interact
22:28:02 <lambdabot> (String -> String) -> IO ()
22:31:35 <copumpkin> well
22:31:44 <copumpkin> you can actually write interactive prompts using interact
22:31:47 <copumpkin> but that's tricky
22:32:17 <applicative> yes, thats why I said it's trouble.  
22:32:27 <applicative> but a pleasing kind of trouble.
22:32:53 <applicative> @type getContents
22:32:53 <lambdabot> IO String
22:33:50 <Bfig> lol
22:36:03 <applicative> Bfig: getContents is the action of reading from  stdin and 'returning' the string for further calculation
22:36:39 <applicative> so main = getContents >>= putStrLn , if you compile it to 'myecho' gives :  echo "haha" | ./myecho   
22:36:42 <applicative> haha
22:38:54 <Bfig> instead of putStrLn i would put my parse function there right? and then modify whatever data i had and putStrLn right?
22:39:48 <applicative> you wont be modifying any data.  you will define a function from data to other data.
22:39:53 <Bfig> ie, getContents >>= putStrLn . parseString, with parseString :: [Char]->[Char].
22:39:59 <applicative> exactly
22:40:23 <Bfig> but i have to hold data there... so i need to keep an array of variables. how can i do that?
22:41:03 <Bfig> wait, >>= binds looser than anything else right?
22:41:14 <applicative> and if there's a function parsePoly :: String -> Polynomial , and Polynomial things are in Show, then getContents >>= putStrLn . show . parsePoly
22:41:21 <applicative> will show the parsed version
22:41:46 <applicative> why do you need to keep an array of variables?  You can get arrays, for sure.
22:42:09 <applicative> I mean, there are various array types
22:42:14 <newsham> putStrLn . show . parsePoly =<< getContents
22:42:23 <applicative> stylin'
22:42:28 <newsham> why mix left/right with right/left?
22:42:46 <applicative> yes, it's much clearer that way
22:42:49 <Bfig> the  =<< is the same but args flipped?
22:42:53 <applicative> yes
22:43:16 <Bfig> ok. i need the array of variables because that's what i need :P
22:43:38 <Bfig> i want to be able to do two things: 1) compute expressions, 2 ) save expressions in variables (for further computing)
22:43:49 <applicative> on the left you have a function from a pure value, e.g. a number, to an action.  on the right you have an action that returns such a value, not such a value itself, 
22:44:09 <applicative> so you need =<< to fit them together
22:44:32 <Bfig> an example flow would be in : store A x^2 + 4, in: store B A + 2x^2 / A, in: compute B * A, out: ....
22:44:44 <applicative> once you define one big action like that, ghc can make your machine perform it....
22:45:00 <absentia> https://github.com/downloads/ieure/sicp/sicp.epub
22:48:50 <applicative> > let grr x = ( let a = x ^ 2 ; b = a + 2* (x^2) in b) in grr 33
22:48:51 <lambdabot>   3267
22:48:56 <applicative> what did I store
22:49:43 <Bfig> applicative, let me see if i understood the ineract stuff
22:51:42 <Bfig> i parse the command, write to standard input with putStrLn, then recursively call the parser?
22:52:55 <applicative> do you get things from the user or stdin or whatever more than once?
22:53:11 <Bfig> it would look like a stream of digits  "lakjeaabnae\nawklrjaw'/.oawerj;\naslkjraw...", and whenever i find a \n i stop parsing, and print + call the parser again with what's left of the input?
22:53:32 <Bfig> yes, it is an interactive prompt
22:54:18 <newsham> ?type interact
22:54:18 <lambdabot> (String -> String) -> IO ()
22:55:18 <applicative> i don't think interact will be so easy in that case.  does the user basically keep giving you new polynomials to substitute into theold ones?
22:55:48 <Bfig> he gives commands like this: "<command> <parameters>"
22:56:21 <applicative> and then you write something based on them, and something about previous commands
22:56:28 <Bfig> ie, possible input strings: "eval A+B", "reduce x^2 * x^3 + P/Q"
22:56:37 <newsham> ?type \f -> join . f . lines
22:56:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => ([String] -> m (m a)) -> String -> m a
22:57:04 <newsham> ?type \f -> concatMap f . lines
22:57:05 <lambdabot> forall b. (String -> [b]) -> String -> [b]
22:57:28 <applicative> so when they write "eval x + y" we already know what x and y are from past commands
22:57:55 <newsham> ?type \f -> interact (concatMap f . lines)
22:57:56 <lambdabot> (String -> [Char]) -> IO ()
23:00:37 <Bfig> mmm... well, i appreciate you trying to explain this, i think i'll read a bit more because this is confusing :|
23:02:06 <Bfig> i thnk i fried my brain. time to take a break. g night
23:02:16 <applicative> it sounds like the principal function will be something like an array of polynomials and a string to an IO thing of the same type
23:03:24 <Bfig> applicative, yep, that's what i was thinking... but it'll have to wait for tomorrow. it's 3 am and i can barely think, and i'd hate to waste more of your time. thanks for all the help so far
23:03:38 <applicative> Bfig: good luck
23:06:10 <lars9> @hoogle allocaXEvent
23:06:10 <lambdabot> No results found
23:13:23 <pablo> hello
23:14:50 <applicative> hello pablo, what are your expected and intended types?
23:15:32 <DocTijn> Applicative: I downloaded the package and try to install it but it still says that I have the wrong version of ghc... : Conflicts with the installed package 'ghc6' 
23:17:15 <applicative> grrr
23:17:39 <applicative> is there no haskell-platform package on your ubuntu? 
23:18:05 <ourfrank> Does anyone know how to insert text *at the cursor* in a simple entrybox, using the gtk binding?
23:18:25 <ourfrank> I can append and prepend and replace, but the cursor stays at position 0.
23:18:41 <ourfrank> I want it to move to the end of the entrybox text.
23:19:07 <applicative> DocTijn, like this http://packages.ubuntu.com/search?keywords=haskell-platform
23:20:02 <applicative> it should manage ghc, cabal install, haddock, etc.
23:21:00 <applicative> DocTijn: see the things listed here http://packages.ubuntu.com/maverick/haskell-platform  
23:22:16 <tab> ourfrank: you can always use the set_position of the editable parent class to put the cursor at the end
23:23:48 <ourfrank> tab: I'm not sure I follow. What set_position? I cannot find it in the docs of both the Entry and any of its parent classes.
23:24:32 <ourfrank> tab: The entry itself does have a cursorPosition attribute, but it seems to be read-only.
23:24:57 <tab> ourfrank: editableSetPosition
23:25:20 <tab> ourfrank: yes it's read-only in entry, since it's a parent (editable) property
23:25:45 <ourfrank> tab: Ah, I've found it! Thank you very much!
23:26:40 <tab> ourfrank: you're welcome
23:59:02 * hackagebot normaldistribution 1.0 - Minimum fuss normally distributed random values.  http://hackage.haskell.org/package/normaldistribution-1.0 (BjornBuckwalter)
23:59:32 <ManateeLazyCat> HI all. :)
