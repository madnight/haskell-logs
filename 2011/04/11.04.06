00:02:10 <frerich> Hm, are there ready-made type classes for 'Sequences' (which provide functions like 'cons' and 'nil') and maybe some type class 'RandomAccessSequence' which also provides O(1) random-access (like (!!))? Or is that impractical? I just wonder whether I could write this code which works on [a] to be more generic so that it actually works on any type which instantiates an abstract 'Sequence' class.
00:02:19 <frerich> The idea is that hte same function can be used to byte strings and lists, for instance.
00:02:42 <dankna> look into Foldable, it might be relevant
00:02:57 <frerich> Ah, yes!
00:03:31 <frerich> dankna: Foldable and Traversable, looks relevant. Thanks for the pointer!
00:03:36 <dankna> np!
00:04:36 <ddarius> Foldable is equivalent to a hypothetical ToList class with one method f a -> [a].
00:08:48 <frerich> Hm, does anybody know why the minimap complete definition for Num is 'all except negate or (-)'? Wouldn't (+) and negate be sufficient?
00:09:31 <ddarius> That's what the "or" means.
00:10:36 <frerich> Oh, so it's '(all except negate) or ((-))' instead of 'all except (negate or (-))'?
00:11:16 <Berengal> So instead of returning the array of structs, I copied each struct into a malloced pointer and return an array of those, then on the haskell side I made that into a list. Was this a bad idea?
00:12:01 <ddarius> Berengal: Yes.
00:12:31 <ddarius> Unless you don't have a Storable instance.
00:12:38 <Berengal> I don't, but I could write one
00:13:17 <Berengal> I'm struggling a bit with how to import the c function however
00:13:22 <ddarius> If you have a Storable instance, you can just do a peekArray.  If you at least know the sizes of the structs, you can just index into the array.
00:14:18 <Berengal> peekArray == peekElemOff?
00:14:30 <ddarius> @hoogle peekArray
00:14:30 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
00:14:31 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
00:17:30 <Berengal> I think some of my confusion has been lifted
00:22:01 <Berengal> I'm thinking I need a separate type for this...
00:22:23 <Berengal> Since I'm working with pointers, I've defined my type to be "newtype Foo = Foo (Ptr Foo)"
00:22:41 <Berengal> But I can't rightly write a Storable instance for that..
00:23:01 <dankna> I usually do
00:23:03 <dankna> type Foo = Ptr ()
00:23:17 <Berengal> This is the same, but typesafer
00:23:22 <dankna> hmm okay
00:24:19 <Berengal> A newtyped Ptr is still just a Ptr (and the FFI allows that), and Ptrs parameter is just a phantom type anyway
00:24:26 <ddarius> You write Storable instances for actual Haskell data types.
00:24:51 <lispy> I like the EmptyDataDecls personally
00:24:54 <Berengal> I was planning on introducing those later
00:25:12 <lispy> data Foo_; type Foo = Ptr Foo_; instance Storable Foo_ where ...
00:25:38 <ddarius> lispy: That instance makes no sense.
00:25:44 <Berengal> lispy: This is generated by c2hs, which presumably uses the sneaky recursive variant to avoid that extra extension
00:25:46 <lispy> ddarius: actually does
00:25:53 <shachaf> lispy: What's sizeOf?
00:26:06 <ddarius> lispy: What does peek return?
00:26:07 <lispy> sizeOf _ = #size struct foo_
00:26:26 <lispy> ddarius: instead of implementing peek/poke, you can use #ptr to define accessors
00:27:02 <lispy> So what you get is a handle that can be malloc'd on the Haskell side (using mallocForeignPtr or similar), mutated on the C side and accessed on the Haskell side
00:27:08 <ddarius> lispy: Nevertheless, you need to define peek for an instance of Storable, so what do you define it as.
00:27:24 <lispy> peek = error "peek not implemented for Foo_"
00:27:44 <ddarius> So how does that not not make sense?
00:27:52 <lispy> So what you get is a handle that can be malloc'd on the Haskell side (using mallocForeignPtr or similar), mutated on the C side and accessed on the Haskell side
00:28:02 <ddarius> You don't need Storable for that.
00:28:45 <lispy> mallocForeignPtr :: Storable a => IO (ForeignPtr a)
00:29:14 <ddarius> Use a different malloc.
00:29:43 <shapr> ddarius: What party plans for the tenth anniversary of #haskell ?
00:30:28 <lispy> ddarius: Well, then I'd need to define class Allocable.  I may do that eventually.
00:30:45 <lispy> it's not necessary, but it would make it nice
00:31:17 <Skola> might be a silly question, but what is " -- " about in Haskell?
00:31:22 <Skola> ie 12 -- 4
00:31:26 <Skola> yields 12
00:31:35 <ddarius> You just use mallocForeignPtrBytes with your #size struct foo_.  You can readily wrap that in a function, and stick functions like that in a class if you want.
00:31:42 <RayNbow`TU> > 0 -- this is just a comment
00:31:43 <lambdabot>   0
00:31:52 <lispy> it would be nice if Storable was split into, class Allocable a where sizeOf :: a -> Int; alignment :: a -> Int; class Allocable a => Storable a where ...
00:31:54 <Skola> right of course
00:32:28 <Berengal> lispy: How do you get structs out of arrays then?
00:32:42 * hackagebot hakyll 3.1.0.0 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.1.0.0 (JasperVanDerJeugt)
00:33:09 <lispy> Berengal: I don't have a Haskell representation for these structs so I can't peek them.
00:33:11 <shachaf> > 12 –– 4
00:33:12 <lambdabot>   4
00:33:16 <lispy> Berengal: doing so would be problematic anyway.
00:33:39 <lispy> Berengal: all Haskell needs to know is that it has an opaque handle to something on the C side
00:33:41 <Berengal> I'm thinking maybe I malloc a new foreign ptr and copy the struct into that
00:34:23 <Berengal> That way I can free the array afterwards...
00:34:36 <lispy> ddarius: Keep in mind, the API I'm talking about is just the Raw binding.  I don't plan on Haskell programmers using it for more than acess to the C guts so they can build a better API.
00:35:02 <Anm> noob looking for enlightening simplification:
00:35:02 <ddarius> lispy: Which makes it make even less sense to provide a Storable instance.
00:35:04 <Anm> > let permutePairs max =foldl (\ acc i -> foldl (\ acc2 j -> (i,j):acc2) acc [max,max-1 .. i+1] ) [] [max-1,max-2 .. 0]
00:35:05 <lambdabot>   not an expression: `let permutePairs max =foldl (\ acc i -> foldl (\ acc2 j...
00:35:17 <ddarius> Anm: Don't use foldl.
00:35:34 <Berengal> lispy: The API I'm working with now seems pretty useable out of the box with just a few minor adjustments here and there
00:35:52 <lispy> ddarius: nah, it's fine.
00:36:05 <lispy> ddarius: You're just objecting to the fact that I didn't implement the full class.
00:36:21 <lispy> But, I could easily replace Storable with my Allocable if that's a big problem for people
00:36:33 <lispy> I just haven't taken the time to write Allocable.
00:36:35 <Anm> wise master, how may I replace my foldl
00:36:41 <ddarius> lispy: People won't find out until their programs just randomly crash.
00:36:46 <lispy> I could easily add Allocable to my missing-foreign package
00:37:03 <ddarius> Anm: Just use foldr instead.
00:37:30 <lispy> ddarius: It's pretty obvious that you can't use peek/poke on these few structs that are setup this way.
00:37:53 <lispy> One look at the haddocks and you'd instantly know better
00:38:36 <Veinor>  03:42:36         <shachaf> > 12 –– 4
00:38:38 <Veinor> 03:42:37       <lambdabot>   4
00:38:39 <Veinor> what
00:38:47 <shachaf> It's the anti-comment.
00:38:49 <Veinor> > 12 -- what
00:38:50 <lambdabot>   12
00:38:52 <Veinor> > 12 -- 4
00:38:53 <lambdabot>   12
00:38:58 <Veinor> uh
00:39:17 <lispy> let (---) = (-) in 12 --- 4
00:39:23 <lispy> > let (---) = (-) in 12 --- 4
00:39:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:39:44 <lispy> oh, maybe the third char has to be a non -
00:39:51 <lispy> > let (--=) = (-) in 12 --= 4
00:39:52 <lambdabot>   8
00:41:09 <Berengal> > undefined –– "bar"
00:41:11 <lambdabot>   "bar"
00:42:11 <ddarius> lispy: Your approach seems like a bad solution to a problem that doesn't exist.
00:42:24 <quantum> did you hear, thy managed to teach haskell to a cat
00:42:36 <lispy> ddarius: You're really stuck on this aren't you?
00:42:40 <quantum> I just watched a docoumentry ab out it on nation geomgraphic
00:42:56 <burp> –– looks more like flip const
00:43:03 <burp> > anti comment test :P –– 1
00:43:03 <lambdabot>   Not in scope: `anti'Not in scope: `comment'Not in scope: `test'Not in scope...
00:43:05 <Axman6> weren't you banned already?
00:43:13 <lispy> ddarius: It's a perfectly valid way to get malloc support without first taking the time to implement Allocable and then make variants of the Storable stuff in terms of it.
00:43:24 <lispy> ddarius: it's a time saving device that can be fixed up later.
00:45:42 <ddarius> What time is it saving?
00:46:05 <lispy> The work of implementing one-off mallocs or creating a class for it
00:46:10 <Berengal> How do you figure out alignment anyway?
00:46:18 <ddarius> They take less time than making an instance of Storable.
00:46:25 <lispy> Berengal: I found a nice hsc macro for it that mauke wrote.  Hang on
00:46:33 <Berengal> lispy: I'm using c2hs
00:47:05 <lispy> Berengal: then you'll have to adapt it: #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
00:47:20 <Anm> ddarius: why would foldr be preferable given the cons nature of lists and their possible lazy implementation?  Wouldn't foldr have to unwind the list into stack variables first?
00:47:34 * Berengal considers just dropping the storable and malloc pointers in c instead
00:48:10 <lispy> Berengal: alignment in most cases is just the widest individual field in the struct
00:48:19 <lispy> maybe all cases?
00:48:34 <lispy> on x86 it only seems to impact performance
00:48:50 <Berengal> I have extremely little C experience so I couldn't say
00:49:32 <lispy> Berengal: well, that alignment macro just asks C for the alignment
00:49:49 <lispy> Berengal: that offsetof function is some sort of magic.  I assume it's gcc specific.
00:49:59 <Berengal> c2hs doesn't generate c code like hsc2hs does
00:50:35 <Berengal> So I can't just ask C
00:50:37 <lispy> Berengal: I think you could put that in a CPP define in a C file that you include
00:51:14 <Berengal> Assuming cpp does constant replacement...
00:51:45 <Berengal> If I understand c2hs correctly, it uses Language.C to parse C on its own. It doesn't shell out to a c compiler the way hsc2hs does
00:51:59 <lispy> I would use hsc2hs then
00:52:06 <lispy> I wouldn't trust c2hs
00:52:18 <lispy> But, that's me
00:52:48 <Berengal> I really have no idea which of the two I should be using, but I've chosen c2hs this time at least
00:53:20 <Berengal> During the 15 minutes I spent looking at them both, it had slightly more understandable documentation
00:54:17 <Berengal> Hah, I could just write an alignment function in c, then have Storable's alignment ffi to that :P
00:56:14 <lispy> isn't there some alignof thing?
00:56:22 <lispy> Berengal: there must be a standard way to do this in c2hs
00:58:06 <quantum> Whats new with haskel
00:58:14 <quantum> any cool news
00:58:31 <Jafet> gcc has an __alignof__ extension
01:01:28 <Berengal> lispy: I don't intend to write a Storable instance anymore anyway
01:05:54 <Berengal> I also need to stop typing PitsBerBixel...
01:07:13 <Twey> Haha
01:07:56 <Jafet> The pitiful little pits
01:09:41 <dankna> haha
01:13:10 <Berengal> Hmm, c2hs *has* an alignment directive, but it's not documented anywhere
01:19:49 <Twey> dom96: I'm trying to use your SimpleIRC library, but it seems that about ten times to the dozen it just exits with 0 immediately without connecting
01:36:00 <lispy> Berengal: cool.  I figured it did :)
01:36:36 <Berengal> lispy: Actually, it's not released. I found references to it in commits...
01:36:50 <lispy> ddarius: You'll be happy to know that I've removed all my nefarious Storable instances.
01:37:17 <Berengal> ...old commits
01:37:35 <lispy> Berengal: is it called alignof?
01:37:41 <Berengal> Yes
01:37:46 <lispy> if so, I found it in googles but when I couldn't find it in the docs I didn't mention it
01:37:47 <lispy> Sorry
01:38:21 <Berengal> Eh, it works
01:38:58 <Berengal> I don't need no stinkin' release or documentation to use features
01:39:06 <lispy> I do have one Haskell type that I think is incorrectly modeling the C.....
01:39:11 <lispy> heh
01:39:32 <erus_> http://paste.ubuntu.com/590119/ what am I doing wrong here?
01:39:42 <lispy> How should I deal with this type: https://github.com/dagit/freetype2/blob/cabalization/Graphics/Rendering/FreeType/Internal/BitmapGlyph.hs
01:40:09 <lispy> BitmapGlyph is a "subclass" of Glyph (the root field of its record).  And I don't implement Glyph.
01:40:20 <lispy> My Glyphs are just opaque handles.
01:40:56 <lispy> So I think I need to define BitmapGlyph as a newtype around a Ptr Glyph and have a cast :: Ptr Glyph -> Maybe (Ptr BitmapGlyph)
01:41:53 <lispy> erus_: did you mean v2length instead of length?
01:42:05 <lispy> erus_: length is defined on lists
01:42:10 <erus_> lol yes :)
01:42:12 <erus_> thanks
01:42:18 <erus_> i was scratching my head there
01:42:29 <lispy> fresh eyes help on problems like that :)
01:43:38 <Berengal> I'll soon have a hello world window up :)
01:43:51 <Berengal> Possibly one that even reacts to close events
01:44:12 <Silex> ship it!
01:44:15 <freiksenet> what is a function to create tuples in haskell? a non-literal ones
01:44:19 <freiksenet> one*
01:44:22 <freiksenet> so one that I can ma
01:44:23 <freiksenet> p
01:44:29 <Berengal> freiksenet: (,)
01:44:32 <Berengal> > (,) 1 2
01:44:33 <lambdabot>   (1,2)
01:44:35 <freiksenet> Berengal: thanks!
01:44:41 <Berengal> map ((,) 1) [1..4]
01:44:45 <Berengal> > map ((,) 1) [1..4]
01:44:46 <lambdabot>   [(1,1),(1,2),(1,3),(1,4)]
01:45:04 <ClaudiusMaximus> > zipWith3 (,,) [1,2,3] "abc" [Nothing, Just True, Nothing]
01:45:04 <lambdabot>   [(1,'a',Nothing),(2,'b',Just True),(3,'c',Nothing)]
01:45:12 <Twey> > map (1, ) [1 .. 4]
01:45:13 <lambdabot>   Illegal tuple section: use -XTupleSections
01:45:15 <Twey> :<
01:45:35 <Berengal> @type (,,,,,,,,,,,,,,,,,,,,,,)
01:45:36 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (a, b, c, d, e, f, g, h, i, j,
01:45:36 <lambdabot>  k, l, m, n, o, p, q, r, s, t, u, v, w)
01:46:04 <freiksenet> ol
01:47:32 <Berengal> Interesting... Apparantly my display supports "VideoMode {videoModeWidth = 320, videoModeHeight = 175, videoModeBitsPerPixel = 1}"
01:47:39 <Berengal> Must... make... indie game
01:48:33 * Berengal wonders if there are any audio systems that support a bit-depth of 1
01:48:41 <erus_> yeah lets all make platformers with shit graphics
01:48:42 <Twey> Berengal: Haha
01:49:01 <lispy> Berengal: what are you making a binding to?
01:49:03 <Twey> dom96, anybody with knowledge of this library: http://hpaste.org/45358/simpleirc_disconnect
01:49:07 <Berengal> lispy: SFML
01:49:13 <lispy> Berengal: hehe
01:49:18 <lispy> Berengal: I'm making a freetype binding
01:49:25 <lispy> Berengal: fonts all over the place :)
01:49:49 <Berengal> SFML is surprisingly well-contained
01:50:08 <Berengal> Almost like what you'd expect from a PPR lib
01:50:22 <lispy> Before I started on this I had narrowed it down to freetype and SFML
01:50:26 <lispy> PPR?
01:50:32 <Berengal> Perl/Python/Ruby
01:50:34 <lispy> both of them seem like nice libraries
01:51:15 <Berengal> I partook in the reddit game jam last week and kinda got hooked on making games (again)
01:51:45 <lispy> cool, what was the reddit game jam?
01:52:02 <Berengal> I wanted to get back to Haskell since it's been a while since I did something real in it, but hackage has a baren wasteland full of unusable game libs
01:52:18 <Berengal> http://www.reddit.com/r/RedditGameJam/
01:53:33 <lispy> Berengal: have you joined #haskell-game ?
01:53:34 <Berengal> One thing haskell should be better at if nothing else; packaging should be easier with the "link the world" attitude
01:53:45 <Berengal> There is such a channel?
01:53:49 <lispy> yeah
01:53:59 <lispy> There seems to be a growing SIG for game devs in Haskell
01:54:10 <lispy> Berengal: there some stuff on haskellers.com too
01:55:20 <Berengal> Ah, cool. As I said, I haven't been paying too much attention to Haskell for the past year or so up until a couple of weeks ago
01:57:18 <lispy> Berengal: I'm currently waiting for the opengl maintainer to reappear but in a few days I'm going to announce an OpenGL binding maintenance effort
01:57:30 <lispy> Berengal: there are a bunch of minor things to clean up
01:58:15 <Berengal> I haven't done any OpenGL programming yet at all, actually
01:58:44 <Berengal> Been mostly content with just pushing bitmaps to the screen in various states of position, scale and rotation
01:59:39 <lispy> cool
02:10:03 <lispy> I think I might make a new hackage release
02:10:20 <lispy> I think the only unsupported thing is using custom render functions, but that's a very advanced feature
02:13:13 <Berengal> What's the best way to handle enums that haven't been typedefed?
02:15:08 <pastorn> lispy: was it you who were about to do a takeover?
02:15:09 <lispy> Berengal: the examples in RWH create a newtype
02:15:41 <lispy> pastorn: I may start taking actions, but I'll ask before just taking over
02:15:59 <lispy> pastorn: it was me that was talking about leading a clean up effort though to get a new package on hackage
02:16:23 <erus_> is there a gentle introduction to haskell control structures (loops and stuff) anywhere? Learn you a haskell didnt help much
02:16:24 <lispy> I don't care about being maintainer per se, but I would like to get some things updated
02:16:47 <Berengal> erus_: Haskell doesn't have many control structures
02:16:49 <pastorn> erus_: heh, "loops"
02:16:51 <pastorn> lol
02:16:58 <lispy> erus_: you'll want to look at map and list comprehensions, forM_, sequence, etc
02:17:02 <pastorn> erus_: recursion is how you do it :)
02:17:14 <erus_> i can map over user input though can I?
02:17:21 <Berengal> There's "case"... and a few different sugars for it
02:17:25 <quantum> hasekll
02:17:27 <pastorn> erus_: sure
02:17:30 <erus_> i want to do something with getLine until a condition
02:17:39 <ClaudiusMaximus> there's a monad-loops package if you must..
02:17:55 <lispy> erus_: interact
02:17:55 * Berengal is fond of "forever"
02:17:57 <lispy> :t interact
02:17:58 <lambdabot> (String -> String) -> IO ()
02:18:03 <pastorn> erus_: f = do { l <- getLine; doStuff l; if (breakFor l) then return () else f }
02:18:30 <erus_> stack overflow?
02:18:34 <pastorn> erus_: nope
02:18:48 <pastorn> you migth if you want to keep results from "doStuff"
02:18:52 <Berengal> and "foreverFrom :: (Monad m) => a -> (a -> m a) -> m b", but I don't think that's in any standard library
02:19:00 <lispy> erus_: so, with input from the external world we usually get the input (requires IO) then once we have it we pass it to some pure stuff (like map)
02:19:24 <pastorn> lispy: i kinda like the way you allocate resources on the graphics card
02:19:42 <pastorn> lispy: the typeclass and you get a newtyped glint or whatever
02:20:30 <lispy> pastorn: Not sure what you're referring to.  Opengl obviously, but more specifically?
02:21:13 <pastorn> i don't remember the name... what function do you call for allocating a resource in VRAM (for textures, models or shaders or whatever)? I'm talking about that functions typeclass
02:22:13 <erus_> Why does this recursive function not stack overflow?
02:22:14 <pastorn> lispy: ah, "ObjectName"
02:22:24 <erus_> because theres no return type?
02:22:29 <Berengal> erus_: Because it's tail recursive
02:22:37 <pastorn> erus_: because no data is saved from each computation of 'doStuff'
02:22:43 <pastorn> erus_: you might have this instead:
02:23:10 <lispy> erus_: lazy evalutaion is sneaky
02:23:14 <erus_> this is warping my C++ brain :P
02:23:31 <pastorn> erus_: f = do { l <- getLine; x <- doStuff l; if (breakFor l) then return [x] else do { xs <- f; return (x:xs) } }
02:23:46 <pastorn> erus_: ^^^ that one could cause a stack overflow
02:24:10 <erus_> ah ok
02:24:14 <erus_> i have to be careful then
02:24:25 <pastorn> erus_: try writing getLine using only getChar :)
02:24:29 <pastorn> good exercise :)
02:24:46 <ukl> hello #haskell; sorry for the noise, should have chosen #xmonad when using hpaste a few minutes ago
02:24:53 <pastorn> (and don't look at the code i just wrote!)
02:25:19 <erus_> pastorn: you shouldnt have said that :P i didnt even notice what it was
02:25:32 <pastorn> lispy: http://hackage.haskell.org/packages/archive/ObjectName/1.0.0.0/doc/html/Data-ObjectName.html
02:25:57 <lispy> ah
02:26:07 <lispy> pastorn: I haven't tried that api, but it seems like it might be handy
02:26:37 <pastorn> lispy: indeed it is
02:26:52 <pastorn> there's quite a lot of the code in the library 'OpenGL' that's useful
02:27:13 <pastorn> lispy: i've messed a bit with it, so i know where most of it is :)
02:27:31 <lispy> I'm mostly interested in modifying the *Raw packages
02:27:49 <pastorn> what's wrong with it now?
02:28:07 <lispy> missing some RULES
02:28:12 <lispy> Needs cabal file updates
02:28:22 <lispy> Doesn't support opengl 4.1 yet
02:28:33 <lispy> Doesn't give deprecation warnings for deprecated things
02:28:58 <pastorn> oh
02:28:59 <lispy> Could potentially have instances so that you can make unboxed arrays of things like GLfloat
02:29:20 <pastorn> yeah, that would be pretty awesome
02:29:53 <pastorn> so maybe raw needs an update, but OpenGL needs a complete overhaul
02:30:12 <lispy> OpenGL is confusing to me
02:30:18 <lispy> So I stick to Raw
02:30:19 <lispy> :)
02:30:45 <lispy> I should go to bed
02:30:50 <pastorn> i mean, it's sort of nice, but i think the *nice* haskell-y bindings should actually be like Raw, but with nice types instead
02:31:22 <pastorn> so enumerator types for all the GL_COLOR32_BGRA magic numbers etc.
02:31:36 <pastorn> and maybe instancens of 'Bits' for those
02:32:12 <pastorn> and exposed typeclasses!
02:32:16 <lispy> one of my co-workers made a good point.  You tend to use *Raw to write some higher level abstraction.  And that the OpenGL bindings are in an ackward spot.  They're not raw enough to match the C documentation and they're not high enough level to allow people to easily do stuff.
02:33:09 <lispy> Yeah, actually, I don't like the idea of hidden modules in packages.
02:33:17 <lispy> Clearly mark internal things as "use at your own risk" but expose them anyway
02:33:26 <pastorn> like how there's no support for using a Mat44 as a shader variable, and no way to actually write proper code for supporting that
02:33:48 <lispy> This way people can write packages around your package that use it clever ways without having to a) reimplement your stuff or b) send you patches
02:33:55 * hackagebot stringsearch 0.3.4 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.4 (DanielFischer)
02:34:11 <pastorn> lispy: will you be making a *GLChar -> String thingy?
02:34:44 <lispy> pastorn: it would be nice to put the opengl repos somewhere with a bug tracker and start making a list of to do items
02:34:55 * hackagebot json2 0.8.1 - Library provides support for JSON.  http://hackage.haskell.org/package/json2-0.8.1 (YuriyIskra)
02:35:12 <lispy> I say github, but they're in darcs currently and I don't know how people feel about moving them.  But right now NO ONE contributes to them so it seems moot to me.
02:35:32 <pastorn> lispy: could you consider a temporary maintainer position? You said you didn't want it, but if you do it temporarily i could consider being a maintainer in the future
02:35:59 <lispy> Oh, I mispoke then.  I don't mind being maintainer.  I just don't want to take it by force.
02:36:08 <lispy> But, yeah that sounds nice
02:36:18 <lispy> I'd be happy to be an interim maintainer and then hand it off
02:36:19 <pastorn> maybe i should look into doing a hostile takeover of OpenGL
02:36:25 <lispy> heh
02:36:34 <pastorn> or perhaps that needs a fork, for compatability
02:37:08 <pastorn> lispy: ===> #haskell-game?
02:37:21 <lispy> Tell you what.  I'll spend an hour when I wake up tomorrow putting the repos on github (I have experience converting darcs repos), start building a to do list, and start a draft announcement
02:40:56 * hackagebot json2-hdbc 0.5.1 - Support JSON for SQL Database.  http://hackage.haskell.org/package/json2-hdbc-0.5.1 (YuriyIskra)
02:41:24 <codemastersnake> heyy just bumped into haskell through google
02:42:06 <codemastersnake> bbye
02:42:09 <codemastersnake> quit
02:42:18 <Maxdamantus> Then you better apologise, both to Google and Haskell.
02:42:26 <erus_> if im using putStr in a function does it have to be an IO function?
02:42:56 <Maxdamantus> erus_: what's an IO function?
02:43:19 <MasseR> erus_: MonadIO m => m a
02:44:06 <erus_> errrr.... i want a function like 'docommand :: String -> Bool' which will do something and return False if it should exit the program
02:44:11 <erus_> is that bad design?
02:44:22 <Maxdamantus> Yes.
02:45:02 <Maxdamantus> "docommand" sounds as if something like String -> IO Bool would be suitable.
02:45:09 <erus_> what about 'getCommandFunction :: String -> Function'
02:45:21 <Maxdamantus> What's Function?
02:45:38 <erus_> something that processes something
02:46:21 <erus_> I need a haskell book
02:46:32 <unfo-> learn you a haskell for great good.
02:46:44 <unfo-> erus_, ^
02:46:53 <Maxdamantus> Just remember that putStr is a function that returns an action desciption.
02:49:46 <Eduard_Munteanu> @where lyah
02:49:47 <lambdabot> http://www.learnyouahaskell.com/
02:51:59 <erus_> i have no idea how to design programs in a functional programming way
02:52:21 <HugoDaniel> hi
02:52:26 <jlouis> erus_: it is not much different from designing programs in general
02:52:37 <jlouis> Just throw out the wrong notion of "OOP" :)
02:52:41 <HugoDaniel> has anyone here worked with yesod ? im looking for examples or open-source web apps done with it
02:53:02 <pacak> Hugglesworth: There are some examples on their website.
02:53:14 <Maxdamantus> jlouis: what wrong notion?
02:53:32 <jlouis> Maxdamantus: I am tongue-in-cheek
02:53:57 <ziman> erus_, then you might want to take a look at Real World Haskell (beside mentioned Learn You A Haskell)
02:54:21 <jlouis> If you come to Haskell, or ML for that matter, with the idea of structuring your program as you would one in e.g., C# or Java, you will probably burn your hands
02:55:28 <pacak> Hugglesworth: But it seems, that yesod heading the wrong direction. At least in some parts - their ORM layer does not supports relation model even in those DBs which do support it. hamlet took worst parts from both haml and html. And so on.
02:56:37 <HugoDaniel> pacak: have you done anything with it ?
02:56:58 <HugoDaniel> i was looking at hamlet it does not seem that bad
02:57:34 <pacak> HugoDaniel: Did you saw the origial? HAML?
02:57:39 <HugoDaniel> no
02:58:11 <pacak> haml is less vebose and easier to type.
02:58:14 <rbarraud> jlouis: nope, you'll probably burn your head ;-)
02:58:17 <HugoDaniel> ah
02:58:20 <HugoDaniel> haml is the ruby thing
02:58:22 <HugoDaniel> ok
02:58:24 <pacak> yep
02:58:55 <HugoDaniel> well, if i could read an html file, build the dom, and specify which parts of the dom i want to replace with my html, through css selectors
02:59:02 <HugoDaniel> then i would have the perfect tool imo
02:59:11 <HugoDaniel> but such thing does not exist in haskell :(
02:59:19 <HugoDaniel> at least as far as i know
02:59:50 <Eduard_Munteanu> Mmm, OOP isn't outright wrong, it's just limited.
03:00:06 <Eduard_Munteanu> It does come about naturally in some languages.
03:00:16 <pacak> as for yesod... I created some toy application, but after i stumbled upon several ugly things - decided to go back to rails for web development. At least for now.
03:00:26 <rostayob> HugoDaniel: I use hsp, it's not bad
03:00:55 <HugoDaniel> pacak: hmm ok, i have never used yesod, im using happstack and it works fine
03:01:03 <HugoDaniel> hsp, i must look onto those
03:01:06 <zenzike> pacak: how recently was that?
03:01:06 <xaotik> hi, so I'm trying to do stuff with type classes
03:01:13 <rostayob> yeah me too, I'm using happstack + web-routes + hsp
03:01:18 <rostayob> and it's good enough
03:01:23 <pacak> zenzike: couple of months probably.
03:01:34 <xaotik> I know I can use them to associate functions with types; can I associate values that aren't functions?
03:01:57 <xaotik> something like
03:02:01 <pacak> zenzike: Actually it was right after they introduced new ugly hamlet syntax.
03:02:09 <rostayob> pacak: look into happstack, web-routes and hsp
03:02:17 <xaotik> class Thing a where number :: Integer?
03:02:21 <zenzike> pacak: ah yeah, it is ugly
03:02:39 <pacak> rostayob: I will. Thanks :)
03:02:49 <lunaris> xaotik: You need a dummy argument.
03:03:01 <lunaris> xaotik: Such as class Thing a where number :: a -> Integer
03:03:12 <rostayob> pacak: np. the problem is that for hsp and web-routes there is basically 0 documentation. look into the guestbook example
03:03:18 <lunaris> xaotik: Otherwise Haskell won't be able to tell which `number' to call.
03:03:27 <xaotik> then I would ask for "number (undefined :: mytype)" where I instantiated mytype previously?
03:03:40 <lunaris> xaotik: Exactly.
03:03:43 <rbarraud> http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html
03:03:44 <xaotik> got it, thank you!
03:03:47 <rbarraud> deja vu :)
03:04:05 <lunaris> xaotik: An example is class Storable a where sizeOf :: a -> Int (see Foreign.Storable)
03:05:22 <lunaris> xaotik: You might need ScopedTypeVariables depending on what you instantiate the type of undefined to be.
03:05:33 <lunaris> xaotik: But I imagine you'll solve that if/when you hit it.
03:06:57 <rostayob> pacak: anyway, the happstack philosophy is completely different from rails or whatever framework. if you want to get things done quickly, right now, haskell is not really a solution
03:07:33 <rostayob> but I still find it way more enjoyable to code in haskell ehe
03:08:37 <HugoDaniel> rostayob: :)
03:08:41 <HugoDaniel> im trying to solve that
03:08:46 <pacak> rostayob: I am not looking for quick solutions, but the solution itself must not be ugly.
03:09:02 <zenzike> HugoDaniel: what are you working on?
03:09:39 <rostayob> pacak: well then apart from yesod the only other is happstack + web-routes (I'm excluding snap because it has no system for handling urls...)
03:09:52 <HugoDaniel> im working on a code generation web gui
03:10:01 <HugoDaniel> but it is moving really slowly
03:10:23 <rostayob> pacak: also, happstack comes with happstack-state, which is really interesting
03:10:47 <HugoDaniel> unfortunately i dont work so much in haskell in my pay job :(
03:11:49 <rostayob> HugoDaniel: what do you mean?
03:11:55 <rostayob> (code generation gui)
03:12:23 <HugoDaniel> rostayob: w8, let me show ya
03:39:23 <nanothief> I'm getting a compiler error related to template haskell that I don't understand, can anyone explain why it happens? http://hpaste.org/45363/template_haskell_macro_causing
03:41:05 <zygoloid> nanothief: basically, the file is split into chunks between top-level splices
03:41:31 <zygoloid> each chunk has to "make sense" without reference to later chunks, so b is not visible before 'macro'
03:42:41 <nanothief> so the only way to get around this is to sort the declarations, or put all the template haskell definitions at the end
03:43:00 <nanothief> that would make sense
03:43:46 <nanothief> thanks for the explaination
03:46:49 <nanothief> is it something that could be "fixed" in the future (eg by evaluating the rest of the file before doing the template haskell splices)? I'm wondering whether it would be worth logging a bug about it, since it is surprising and annoying behaviour
03:47:55 <zygoloid> i think there already is one.
03:54:52 <zygoloid> nanothief: http://hackage.haskell.org/trac/ghc/ticket/4230 discusses a fix for this and related issues
03:56:05 <HugoDaniel> rostayob: here: http://imgur.com/a/WX1o4#SrATm
03:56:27 <HugoDaniel> (i was away because of some other problem here at work, sorry for the delay)
03:57:06 <rostayob> HugoDaniel: no problem 
03:57:23 <rostayob> HugoDaniel: so that generates form?
03:57:35 <rostayob> what's wrong with digestive-functors :P?
03:58:13 <HugoDaniel> yes, it generates html forms, it is still basic, im also working for it to create relational db's
03:58:54 <HugoDaniel> in the end i need to add the possibility of getting a zip with all the code ready to run, or hosting the form where the server is currently running
03:59:21 <rostayob> HugoDaniel: mhm... I don't really see the use of that but maybe I'm wrong
03:59:23 <nanothief> zygoloid: thanks for the link
03:59:25 <rostayob> I mean why I webguy?
04:00:16 <rostayob> *why a webguy... I don't know how that came out lol
04:00:21 <rostayob> *webgui damn
04:00:26 <rostayob> I need to sleep ehe
04:00:27 <HugoDaniel> rostayob: i want to be able to create web forms in under a minute
04:00:36 <HugoDaniel> :)
04:00:41 <rostayob> HugoDaniel: have you looked at digestive-functors?
04:00:44 <HugoDaniel> no
04:01:02 <HugoDaniel> im googling for them
04:01:08 <rostayob> well that does it in my case
04:02:15 <HugoDaniel> hmm i didn't really enjoy formlets
04:02:16 <HugoDaniel> :(
04:02:18 <rostayob> I mean I'm not sure that you actually need code generation...
04:02:25 <rostayob> so that thing generates haskell code
04:02:32 <HugoDaniel> i had myself doing html forms by hand faster than with formlets
04:03:09 <rostayob> HugoDaniel: what do you mean "by hand"?
04:03:12 <HugoDaniel> rostayob: sort of, the json package fills the necessary haskell datatype
04:03:20 <HugoDaniel> rostayob: <form id="blah" ...
04:03:33 <rostayob> HugoDaniel: yeah but the thing is form validation
04:03:41 <rostayob> you can have a function that generates the html
04:03:47 <rostayob> from the digestive-functors form
04:04:16 <rostayob> and you always use the same
04:04:41 <rostayob> the big bonus that digestive functors gives you is input validation
04:04:52 <Berengal> I broke c2hs :(
04:10:18 <HugoDaniel> oh
04:11:01 <HugoDaniel> rostayob: im doing input validation through haskell read, and in some cases through regex
04:12:02 <HugoDaniel> im going to try and replace that with the digestive functor :D
04:12:12 <rostayob> HugoDaniel: cool
04:12:39 <HugoDaniel> and use your work on the digestive functor with happstack
04:12:40 <HugoDaniel> :D
04:13:48 <rostayob> eheh I didn't really do much
04:23:55 <ion> digestive-functors looks nice.
04:26:30 <rostayob> ion: it is (:
04:31:20 * hackagebot timeplot 0.2.22 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.22 (EugeneKirpichov)
04:50:41 <Peaker> Pure/imprecise exceptions are too common and not tagged in the type.  Along with the lack of stack traces, this has been a huge drawback for me.. Debugging some vague error message in a large project :-((
04:50:41 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
04:53:58 <Peaker> xplat, you there? "if you reverse a list with a beginning and no end, you get a list with an end and no beginning. definitionally."  I am not sure that holds up. If you look at foldl directly, it is more clear that the result of foldl on *any* non-empty list will be an application of "f".  Yet foldl requires looking through the whole list to figure it out...
04:54:56 <sordina1> Hey. Fore some reason I'm getting odd behaviour for a quickcheck test: http://codepad.org/I3xWGLvt
04:55:29 <Peaker> I can use a different rule for reverse:  length (reverse xs) == length xs    so clearly reverse of an infinite list is also an infinite list.  An infinite list of bottoms is not bottom, so reverse returns the wrong result
04:57:13 <ezyang> But the reverse of the empty list is empty. 
04:57:23 * hackagebot stringsearch 0.3.5 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.5 (DanielFischer)
04:57:37 <ezyang> So you need to be at least strict on the spine. Actually, I don't think that contradicts what you said. 
04:58:55 <Twey> sordina: Does ‘Foo’ include a type variable?
05:02:39 <sordina> Twey: http://codepad.org/QEW3GPzB
05:05:12 <Twey> sordina: That one's a bit different, since in the uncommented version you're relying on QuickCheck to provide a value, which is what Arbitrary is for
05:06:21 <Peaker> ezyang, I'm referring to http://codepad.org/6foJr6jI
05:07:55 <Peaker> ezyang, someone on reddit gave another solution: http://codepad.org/eMU9Q0aW
05:08:46 <ezyang> Yeah, no, I buy that. 
05:09:24 <Berengal> I just spent 90 minutes writing an incredibly repetitive Storable instance with Kraftwerk's Autobahn somehow on loop. I feel weirdly surreal
05:12:23 <zygoloid> > let myreverse [] = []; myreverse [x] = [x]; myreverse (x:xs) = last xs:myreverse (x:init xs) in map (const ()) $ myreverse (repeat True)
05:12:24 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
05:17:56 <Veinor> zygoloid: wait, what
05:18:19 <Veinor> that's pretty neat
05:19:45 <Peaker> > let lfoldl f z [] = z ; lfoldl f z xs = f (lfoldl f z (init xs)) (last xs) ; myreverse = lfoldl (flip (:)) [] in map (const ()) $ myreverse (repeat True)
05:19:50 <lambdabot>   mueval-core: Time limit exceeded
05:20:08 <Peaker> > let lfoldl f z [] = z ; lfoldl f z xs = f (lfoldl f z (init xs)) (last xs) ; myreverse = lfoldl (flip (:)) [] in map (const ()) $ take 10 $ myreverse (repeat True)
05:20:10 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
05:20:55 <Peaker> @query lambdabot 
05:20:55 <lambdabot> Unknown command, try @list
05:21:04 <Peaker> oops :)
05:21:22 <Peaker> > let lfoldl f z [] = z ; lfoldl f z xs = f (lfoldl f z (init xs)) (last xs) ; myreverse = lfoldl (flip (:)) [] in map (const ()) $ myreverse (repeat True)
05:21:24 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
05:21:48 <Peaker> no need to change reverse - just the underlying foldl
05:29:27 <parcs> > map (const ()) (reverse (repeat True))
05:29:32 <lambdabot>   mueval-core: Time limit exceeded
05:29:40 <parcs> o, nice
05:29:51 <quantum> dirt is heavier than water?
05:32:50 <parcs> > let initlast (x:xs) = first (x:) $ initlast xs; initlast [x] = ([], x) in initlast [1..10]
05:32:51 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10*Exception: <interactive>:3:4-69: Non-exhaustive patt...
05:33:14 <parcs> would that improve performance of the lazy fold?
05:35:14 <parcs> > let initlast (x:xs:_) = first (x:) $ initlast xs; initlast [x] = ([], x) in initlast [1..10]
05:35:15 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
05:35:35 <parcs> > let initlast (x:xs@(_:_)) = first (x:) $ initlast xs; initlast [x] = ([], x) in initlast [1..10]
05:35:36 <lambdabot>   ([1,2,3,4,5,6,7,8,9],10)
05:44:02 <zenzike>  /statusbar window
05:44:04 <zenzike> oops
05:48:29 <sordina> Twey: But the weird thing is that it only complains about the uncommented version when I move ed out of the where clause.
05:48:48 <Twey> sordina: It complains about it when you give it a type
05:49:09 <Twey> sordina: Try taking the type annotation out and seeing what GHCi thinks the type ought to be
05:49:33 <sordina> kk Thanks
05:50:05 <sordina> Looks like it's not the annotation causing it.
05:50:29 <Twey> Hmn
05:57:04 <Peaker> parcs, by a constant maybe, but the complexity would still be O(N^2), for O(N) see http://codepad.org/eMU9Q0aW
06:02:34 <dafis> Has the automatic supply of username and password for hackage uploads been removed from cabal, or am I just "Doin' it Rong"?
06:06:25 <beastaugh> maybe you deleted ~/.cabal/config or something?
06:08:02 <dafis> beastaugh: no, I've never done it before, so I don't know exactly how to do it. cabal upload --help said I could add them to the config, so I just filled in the username and password lines and uncommented them, was still asked for username and pw when uploading
06:08:59 <beastaugh> you have got a Hackage account, yes?
06:09:12 <Saizan> dafis: it's broken in the latest cabal
06:09:21 <dafis> beastaugh: sure, after giveing them, the upload worked fine
06:09:24 <Saizan> s/latest/latest released/
06:09:30 <dafis> Saizan: ah, thanks
06:09:42 <dafis> Saizan: that's 0.10.2?
06:09:48 <Verge> How can I get floor(length(list)) in Haskell
06:10:00 <mauke> how does that make any sense?
06:10:03 <beastaugh> Saizan: oh, ok
06:10:03 <Berengal> Yay! I have a window! That responds to events
06:10:04 <dafis> Verge: not, length is an Int
06:10:06 <flamingspinach> what does it mean for list to have a non-integral length?
06:10:11 <Itkovian> Verge: length :: [a] -> Int
06:10:14 <Saizan> dafis: yep
06:10:22 <Itkovian> so floor . length == length
06:10:28 <beastaugh> Saizan: that's helpful to know, thanks--haven't had occasion to upload any packages since I updated cabal last
06:10:32 <frerich> flamingspinach: Maybe the list ["aaaa", "aaaa", "aaa"] has the length 2.75 :-)
06:10:39 <dafis> Saizan: but in principle, username and password are the correct fields?
06:10:40 <Saizan> floor . length should be a type error, actually
06:10:49 <Verge> Yes, I meant after multiplying it with 0.5
06:10:56 <ehamberg> i want to send simple http requests and get json back. my requests are bytestrings. can you recommand a library to use? should i unpack my bytestrings and use Network.HTTP?
06:10:58 * Berengal figures out how to cablize c2hs bindings
06:10:59 <Botje> floor . genericLength :>
06:11:08 <dafis> Verge: length xs `quot` 2
06:11:09 <Saizan> dafis: yep, should be
06:11:12 <poucet_> (`div` 2) . length
06:11:20 <dafis> Saizan: muchas gracias
06:11:30 <Verge> dafis: great
06:11:42 <poucet_> > 5 `quot` 2
06:11:42 <lambdabot>   2
06:11:49 <poucet_> > 5 `div` 2
06:11:50 <lambdabot>   2
06:12:01 <dafis> > (-5) `quot` 2
06:12:02 <lambdabot>   -2
06:12:03 <quantum> Haskell Is goot Anumbers theory
06:12:06 <mauke> @check \x y -> div x y == quot x y
06:12:07 <dafis> > (-5) `div` 2
06:12:08 <lambdabot>   -3
06:12:08 <lambdabot>   "*Exception: divide by zero
06:12:17 <mauke> @check \x y -> y /= 0 ==> (div x y == quot x y)
06:12:18 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:12:18 <lambdabot>                     (Test.QuickCh...
06:12:25 <Itkovian> Verge that would be (flip div 2) . length
06:12:36 <mauke> @check \x y -> y /= 0 || div x y == quot x y
06:12:36 <lambdabot>   "*Exception: divide by zero
06:12:36 * hackagebot hxt-relaxng 9.1.1 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.1 (UweSchmidt)
06:12:44 <mauke> @check \x y -> y == 0 || div x y == quot x y
06:12:45 <lambdabot>   "Falsifiable, after 10 tests:\n2\n-4\n"
06:12:56 <Saizan> ehamberg: Network.HTTP supports ByteString's for the body of requests
06:14:13 <ehamberg> Saizan: it does? are there examples somewhere?
06:15:24 <Itkovian> mauke: you were short-circuiting the wrong way :-)
06:20:03 <Saizan> ehamberg: see e.g. the type of simpleHTTP http://hackage.haskell.org/packages/archive/HTTP/4000.1.1/doc/html/Network-HTTP.html#v:simpleHTTP
06:20:52 <Saizan> ehamberg: it takes a Request type whose body is of type 'ty', where HStream ty and there are instances for HStream ByteString 
06:24:38 <ehamberg> Saizan: i'll have a look. thanks.
06:38:10 <platzhirsch> I missed you guys
06:50:50 <lunaris> If I have a Language.Haskell.TH.Name, is it possible (at compile time) to call type class functions for the type with that Name?
06:51:14 <lunaris> Essentially, I want: f (undefined :: $(conT name)) but obviously that's giving me a staging error.
06:51:27 <lunaris> (Since name is defined in the current module)
06:51:53 <sm> morning all. I'd like to keep my small library and executable code together in one module for now. Is it possible to build an executable from a non Main module ?
06:52:27 <opqdonut_> there is some flag like --Main-is
06:52:48 <opqdonut_> -main-is, check the ghc documentation
06:53:14 <sm> in the cabal file ? That one sets the module, but doesn't build unless it has module Main ?
06:53:34 <opqdonut_> ah, I don't know about cabal. that was a GHC option
06:54:08 <opqdonut_> you can of course set ghc options in the cabal file, but I don't know if that'll do the job
06:54:40 <sm> opqdonut_: thanks, will try that
06:58:02 <dafis> sm: check http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html
06:58:17 <dafis> a bit outdated, but should get you started
06:59:07 * sm finds the ghc magic, ghc --make Network/Agilezen.hs -main-is Network.Agilezen -o agilezen
06:59:32 <sm> dafis: thanks
06:59:47 <dafis> de nada
07:00:33 <sm> it doesn't need "module Main", just needs to export a main function
07:01:18 <sm> incidentally if anyone wants to hack on this agilezen.com client let me know
07:06:00 <sm> so in the cabal file you need both Main-is: The/Module.hs and Ghc-options: -main-is The.Module
07:12:31 <sm> why does an executable section need the build-depends: for its own library, again ? This seems to be building ok without it
07:14:26 <ControlMonad> :t init
07:14:27 <lambdabot> forall a. [a] -> [a]
07:16:19 <ControlMonad> :t hGetContents
07:16:19 <lambdabot> Not in scope: `hGetContents'
07:17:10 <ControlMonad> :m + System.IO
07:17:12 <mm_freak> sm: it doesn't
07:17:17 <ControlMonad> :t hGetContents
07:17:18 <lambdabot> Not in scope: `hGetContents'
07:17:30 <sm> alright, then I'll leave it out
07:17:43 <mm_freak> sm: my impression is that it only needs it, when you use Hs-Source-Dirs
07:17:56 <mm_freak> (or whatever it was called, something along those lines)
07:18:48 <mm_freak> it's also really a workaround, because you're not actually compiling a library and then using it in the executable, but you're just using the same modules in the library as well as in the executable
07:18:59 <mm_freak> to have it cleaner, create a separate package for the executable
07:19:37 <sm> oh, isn't it to help cabal not build the modules twice ?
07:19:55 <rostayob> tibbe: argh it seems I made it with google, no gsoc :P
07:20:37 <sm> got to go.. later
07:28:26 <Skola> In Haskell, we don't call
07:28:31 <Skola> string = abc
07:28:33 <tibbe> rostayob: oh well, congrats
07:28:35 <Skola> string = "abc"
07:28:38 <tibbe> rostayob: which office?
07:28:38 <Skola> assignment, do we?
07:29:03 <aavogt> > let abc = "abc" in let string = abc in string
07:29:04 <lambdabot>   "abc"
07:29:06 <Jafet> The string "abc" is assigned the name `string'
07:29:18 <Skola> ok
07:29:47 <Skola> thank you, I'm documenting my noob adventures and I want to get the terminology right
07:29:54 <Jafet> Now if your brain muddles "assignment" with "lol memory copy", this is a good time to rid it of such associations
07:30:09 <Skola> yeah that's why I was in doubt
07:30:15 <Skola> as to what to call it
07:30:22 <Jafet> (Unless you're in a language whose terminology defines it to be that)
07:30:47 <whald> hmm, ghc 7.0.3 complains about SpecConstr and excessive call patterns while ghc 6.12.3 had no complaints. should i worry?
07:31:08 <whald> never seen this warning before...
07:31:18 <dafis> whald: no, no problem
07:31:34 <Skola> thanks Jafet
07:32:03 <dafis> whald: you should consider passing -fspec-constr-count=6 (or some other number) to make ghc create the specialisations
07:32:04 <whald> dafis: seems to be related to inline pragmas, could be?
07:32:41 <dafis> whald: yes, INLINE can play a role
07:33:08 <dafis> but it can also occur without INLINE
07:34:02 <whald> dafis: i gave -fspec-constr-count=6 which works on some instances, but for some there is still "has two call patterns, but the limit is 0" [sic]
07:34:52 <Axman6> whald: that's not an error and can be ignored
07:35:46 <ControlMonad> -- help
07:37:58 <whald> Axman6: the problem is that it distracts me from real warnings i'd better fix
07:47:43 <kaf3ii> 'IO (Maybe (IO A))' to 'IO (Maybe A)'          can it be done?
07:48:48 <Jafet> Sure
07:48:49 <ClaudiusMaximus> :t Data.Traversable.traverse
07:48:50 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:53:22 <sipa> @let f x = do { may <- x; case may of { Nothing -> return Nothing; Just r -> r } }
07:53:23 <lambdabot>  Defined.
07:53:26 <sipa> :t f
07:53:26 <lambdabot>     Ambiguous occurrence `f'
07:53:26 <lambdabot>     It could refer to either `L.f', defined at <local>:2:0
07:53:26 <lambdabot>                           or `SimpleReflect.f', imported from SimpleReflect at State/L.hs:73:0-32
07:53:41 <sipa> @let kaf3iif x = do { may <- x; case may of { Nothing -> return Nothing; Just r -> r } }
07:53:42 <lambdabot>  Defined.
07:53:46 <sipa> :t kaf3iif
07:53:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe (m (Maybe a))) -> m (Maybe a)
07:54:00 <Saizan> :t L.f
07:54:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe (m (Maybe a))) -> m (Maybe a)
07:54:21 <kaf3ii> Saizan: thx :D
07:54:37 <sipa> @let kaf3iig x = do { may <- x; case may of { Nothing -> return Nothing; Just r -> r >>= return . Just } }
07:54:38 <lambdabot>  Defined.
07:54:42 <sipa> :t kaf3iig
07:54:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe (m a)) -> m (Maybe a)
07:55:13 <Axman6> :t let f x = do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z)}} in f
07:55:14 <lambdabot> parse error on input `in'
07:55:34 <dafis> whald: been away, to get rid of these messages, try a higher spec-constr-count, maybe 8 or 16
07:55:47 <Axman6> :t let f x = do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z);};} in f
07:55:48 <lambdabot> parse error on input `in'
07:55:52 <Axman6> -_-
07:56:10 <Axman6> @let fabc x = do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z);};}
07:56:10 <lambdabot>   Parse error: EOF
07:56:10 <Saizan> ?type (Data.Traversable.sequence =<<) `asTypeOf` kaf3iif
07:56:11 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
07:56:11 <lambdabot>       Expected type: m (Maybe (Maybe a))
07:56:11 <lambdabot>       Inferred type: m (Maybe a)
07:56:16 <ClaudiusMaximus> @pl r >>= return . Just
07:56:16 <lambdabot> Just `fmap` r
07:56:33 <Saizan> ?type (Data.Traversable.sequence =<<) `asTypeOf` kaf3iig
07:56:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe (m a)) -> m (Maybe a)
07:57:01 <dafis> Axman6: you have three {, but only two }
07:57:20 <Axman6> :t let f x = do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z)}}} in f
07:57:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (Maybe (m a)) -> m (Maybe a)
07:57:45 <Axman6> @pl f x = do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z)}}}
07:57:45 <lambdabot> (line 1, column 10):
07:57:45 <lambdabot> unexpected "{"
07:57:45 <lambdabot> expecting variable, "(", operator or end of input
07:57:50 <Axman6> weak
07:58:12 <Axman6> @. undo pl f x = do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z)}}}
07:58:12 <lambdabot>  Parse error at "mn" (column 14)
07:58:31 <Axman6> @. pl undo f x = do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z)}}}
07:58:31 <lambdabot> (line 1, column 34):
07:58:31 <lambdabot> unexpected "{"
07:58:31 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
07:58:38 <Dae_> poor lambdabot, never quite good enough
07:59:13 <ion> @. pl undo \x -> do { may <- x; case may of { Nothing -> return Nothing; Just y -> do {z <- y; return (Just z)}}}
07:59:13 <lambdabot> (line 1, column 35):
07:59:13 <lambdabot> unexpected "{"
07:59:13 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
08:00:51 <kaf3ii> works for me now, thx
08:01:22 <whald> dafis: oh, didn't think of that big values, with 64 I'm fine. thanks!
08:01:35 <ManateeLazyCat> Hi folks. :)
08:01:49 <dafis> whald: 64??? Wowah, that's huge
08:01:55 <dafis> Hi ManateeLazyCat 
08:02:07 <ManateeLazyCat> dafis: Hi :)
08:03:35 <djahandarie> :t (Data.Traversable.sequence =<<)
08:03:36 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => m (t (m a)) -> m (t a)
08:03:49 <whald> dafis: I don't feel guilty. :-) 32 still fails, 64 calms ghc down. if you care you can try yourself: http://code.google.com/p/bling-raytracer/source/checkout
08:03:49 <ion> axman6: f = (=<<) . maybe (return Nothing) (Just <$>) -- perhaps this, unless i made a mistake somewhere
08:04:01 <ManateeLazyCat> Ah lambdabot is back. :)
08:04:03 <Axman6> check the type
08:04:44 <ion> whoops
08:04:49 * hackagebot simple-atom 0.2 - Atom (or symbol) datatype for fast comparision and sorting.  http://hackage.haskell.org/package/simple-atom-0.2 (ThomasSchilling)
08:05:40 <djahandarie> Crap, just realize that Saizan beat me to that like 10 minute sago :p
08:06:12 <Axman6> ion: i wasn;t saying it was wrong, just that the type would tell you if it's correct :)
08:07:31 <byorgey> @tell lispy wow, that was fast! thanks!  I'll let you know how it goes.
08:07:31 <lambdabot> Consider it noted.
08:10:16 <ion> axman6: Ah, a simple brainfart. The . was extraneous. (=<<) (maybe (return Nothing) (Just <$>))
08:13:46 <Peaker> @type (maybe (return Nothing) (fmap Just) =<<)
08:13:47 <lambdabot> forall a (m :: * -> *). (Monad m, Functor m) => m (Maybe (m a)) -> m (Maybe a)
08:13:55 <Peaker> @type (maybe (return Nothing) (liftM Just) =<<)
08:13:55 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe (m a)) -> m (Maybe a)
08:14:24 <Peaker> @type fmap sequenceA
08:14:25 <lambdabot> Not in scope: `sequenceA'
08:14:33 <Peaker> @hoogle sequence
08:14:33 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
08:14:33 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
08:14:33 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
08:14:44 <djahandarie> Peaker, Data.Traversable.sequenceA
08:14:52 <Peaker> @type liftM Data.Traversable.sequence
08:14:53 <lambdabot> forall (t :: * -> *) (m :: * -> *) a (m1 :: * -> *). (Data.Traversable.Traversable t, Monad m, Monad m1) => m1 (t (m a)) -> m1 (m (t a))
08:15:04 <djahandarie> Peaker, =<< :p
08:15:08 <djahandarie> (Or >>=)
08:15:17 <Peaker> @type join . liftM Data.Traversable.sequence
08:15:17 <lambdabot> forall (m :: * -> *) (t :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => m (t (m a)) -> m (t a)
08:15:48 <Peaker> > join . liftM Data.Traversable.sequence $ return (Just (return 5))
08:15:49 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe a)))
08:15:49 <lambdabot>    arising from a ...
08:16:17 <Peaker> > head $ join . liftM Data.Traversable.sequence $ return (Just (return 5))
08:16:20 <lambdabot>   mueval-core: Time limit exceeded
08:16:36 <Peaker> > head $ join . liftM Data.Traversable.sequence $ return (Just (return 5))
08:16:38 <lambdabot>   Just 5
08:17:13 <Peaker> oh, heh, I just pgup'd :)
08:17:23 <kaf3ii> sweet :)
08:18:10 <ion> Wow, i missed that, too.
08:18:49 <djahandarie> #haskell seems to have some reading troubles today ;)
08:19:21 <Peaker> @type \f -> [join . liftM f, (f =<<)]
08:19:22 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [m a1 -> m a]
08:20:34 <Twey> I wish there were a way to re-order equations for a function :-\
08:21:46 <Jafet> A text editor?
08:22:22 <rostayob> is there a way in template haskell to test if a type is an instance of some class?
08:23:04 <Berengal> Twey: http://i.imgur.com/ubmN2.jpg
08:23:22 <jonkri> is there a way to somehow get which module and function that is currently executing (i'm writing a logger)
08:23:34 <erus_> is there a haskell package to simulate quantum physics?
08:25:17 <djahandarie> erus_, yes, actually
08:25:30 <djahandarie> Geared towards quantum computing though, not general physics simulations
08:26:28 <djahandarie> There is quantum-arrow, and I think there is something else but I can't find a package for it
08:27:08 <djahandarie> Hm, I guess it was never packaged. https://www.cs.indiana.edu/~sabry/papers/quantum.pdf is the paper
08:30:55 <c_wraith> rostayob: No, there isn't.  Mostly because GHC compiles module-at-a-time, so doesn't know globally if there's a particular instance in your program.
08:31:33 <rostayob> c_wraith: thanks
08:31:38 <rostayob> i'll live without that :P
08:31:59 <thoughtpolice> preflex: seen lispy
08:31:59 <preflex>  lispy was last seen on #haskell 5 hours, 54 minutes and 46 seconds ago, saying: Tell you what.  I'll spend an hour when I wake up tomorrow putting the repos on github (I have experience converting darcs repos), start building a to do list, and start a draft announcement
08:32:25 <erus_> when people make games with haskell, do they implement the game state as a big object they perform functions on or have some sort of monad for the state?
08:32:51 <mauke> isn't that the same thing?
08:33:35 <hpc> they are the same thing; i don't think anybody could deal with all that information without using typeclasses somewhere to make the work easier
08:35:54 <ToRA> rostayob: if you reify the type class name you'll get back a list of all it's (known) instances, you could do an isElem check in there probably
08:36:23 <ToRA> rostayob: but type class instance is subtle, it could depend on other type class instances (e.g. instance Show a => Show (X a)) etc.
08:39:30 <ezyang> @hoogle a -> (Maybe a) -> a 
08:39:30 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
08:39:30 <lambdabot> Prelude asTypeOf :: a -> a -> a
08:39:30 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
08:40:28 <ToRA> c_wraith: ghc builds up an environment of all seen type class instances as it's compiling modules one at a time.  as long as the instance would be visible in the module that's being spliced in, you should be ok
08:40:38 <ToRA> (visible in = defined in an imported module)
08:41:10 <rostayob> ToRA: oh ok, interesting. so it only shows the direct instances?
08:41:42 <c_wraith> ToRA: transitively.  :P.  But my point is, that's not checking to see if a type is an instance globally, so your results still might be surprising
08:42:18 <MHD0> I have this interesting idea about a combination of the Random monad and Logic monad... But i am not sure how to implement it.
08:42:26 <ToRA> now sure what you mean by "direct" instances
08:42:42 <rostayob> ToRA: well the one actually defined, and not depending on other stuff
08:42:58 <rostayob> basically the example you cited
08:43:09 <ToRA> rostayob: the query works the other way
08:43:14 <ToRA> you ask for "Show"
08:43:22 <ToRA> you'll get back ("Show a => Show (X a)")
08:43:38 <ToRA> (and a bazillion other things, probably)
08:43:54 <ToRA> you'd have to then work out if Show (X Int) is in that list
08:44:13 <rostayob> ah ok
08:44:21 <ToRA> [_assuming_ i'm reading the TH docs correctly]
08:45:09 <rostayob> ToRA: I'll just work around that... It's not something I can rely on if I understand well
08:51:54 <Berengal> I'm having some issues with cabal and it lacking a base dependency
08:52:37 <Berengal> I have a library which depends on base and compiles correctly. I also have an executable that simply depends on the library, but it won't compile because base is hidden apparantly
08:52:54 <dcoutts> Berengal: your executable also depends on base
08:52:59 <xplat> @tell Peaker you say your rule (length xs == length (reverse xs)) is different from mine, but it is the same.  length (repeat 'a') == _|_ == length (_|_) == length (reverse (repeat 'a')).
08:52:59 <lambdabot> Consider it noted.
08:53:09 <Berengal> dcoutts: Aren't dependencies transitive?
08:53:13 <dcoutts> no
08:53:32 <dcoutts> Berengal: direct deps are the packages you can import modules from
08:53:34 <monochrom> if you import Prelude, you depend on base. directly
08:53:46 <Berengal> Ah, okay
08:53:53 <Berengal> That makes a bit sense
08:53:57 <monochrom> (and it takes extra effort to not import Prelude)
08:54:00 <xplat> @tell Peaker and if you look how the fs stack up in finite results (not the definition) of foldl, the innermost application of f has the first element of the list as argument, the outermost has the last element of the list as argument.  but there is no last element of an infinite list, so there is no outermost application of f for a foldl on an infinite list.
08:54:00 <lambdabot> Consider it noted.
08:54:01 <dcoutts> and if you don't import Prelude, Haskell does it for you :-)
08:54:54 <Berengal> Yes, I noticed :)
08:55:31 <Peaker> xplat, s/length/genericLength
08:55:31 <lambdabot> Peaker: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:55:52 <Peaker> xplat, using Nat = Zero | Succ Zero         gives a non-bottom for: length (repeat 'a')
08:55:53 <Berengal> Also, making cabal build a c2hs package was surprisingly easy
08:56:19 <Eelis> Peaker: Succ Nat :)
08:56:24 <Peaker> oops
08:56:31 <Berengal> Much thanks to ezyang for his excellent blog series on the subject
08:56:59 <Peaker> xplat, just because there is no last element does not mean there is no application of "f" to the missing last element
08:57:22 <Peaker> xplat, what do you think: const "woah" (last (repeat 'a'))  ought to return? 
08:58:05 <Saizan> Peaker: surely your length is not defined with foldl if it's giving non-bottom for (repeat 'a')
08:58:37 <Peaker> Saizan, yeah, I'm talking about an alternate lazier definition of foldl
08:59:36 <Peaker> Saizan, http://codepad.org/eMU9Q0aW  naive/simple O(N^2) lazier foldl in comment, or O(N) one in code
09:00:06 <Peaker> > const "woah" (last (repeat 'a'))
09:00:07 <lambdabot>   "woah"
09:00:11 <nyingen> is there any consensus as to which 'records' package is best? I often use data-accessor but I've seen some arguments that others are better 
09:00:29 <Twey> I think fclabels is the favourite at the moment, isn't it?
09:00:31 <Peaker> @let relist (_:pat) ~(x:xs) = x:relist pat xs ; relist [] [] = []
09:00:32 <lambdabot>  Defined.
09:00:47 <Peaker> @let lfoldl f z xs = foldr (flip f) z (relist xs (reverse xs))
09:00:48 <lambdabot>  Defined.
09:01:11 <nyingen> Twey: no idea
09:01:15 <Peaker> > lfoldl (const . const $ 0) undefined (repeat undefined)
09:01:17 <lambdabot>   0
09:01:41 <nyingen> Also, the authors of Data.Accessor argued at some point that such functionality ought to be directly incorporated into the language, rather than being a library
09:01:52 <nyingen> I don't think they were arguing for their implementation in particular, just in general
09:02:06 <Berengal> Let me just see if I got this pattern correct: When a c function returns a struct, make a wrapper function in c that takes a pointer to that struct, calls the real function and copes the struct into the pointer, then on the haskell side you alloca and peek
09:04:10 <dmwit> Berengal: Sort of a bummer, but yeah, I think that's the pattern.
09:05:00 <Peaker> the FFI is really nice for simple invocations, but I had real trouble with more complicated things.. (e.g: linux's list.h)
09:05:04 <Berengal> dmwit: Meh, could be worse. It could be using a union of structs
09:05:13 <Berengal> (My fingers still hurt from typing that one out)
09:05:30 <dmwit> unions are one of the worst features of C
09:05:57 * hackagebot DocTest 0.2.0 - Test interactive Haskell examples  http://hackage.haskell.org/package/DocTest-0.2.0 (SimonHengel)
09:05:59 <hpc> what's a C union?
09:06:11 <sipa> hpc: un untagged ADT :)
09:06:16 <Veinor> an untagged Either
09:06:20 <Veinor> er, yes, that
09:06:29 <Twey> It's like an ADT, but you have to guess what you got
09:06:38 <Eelis> you don't guess, you have your own flag
09:06:47 <hpc> yuck
09:07:07 <Twey> It's a fairly common approach in C
09:07:11 <Twey> Arrays work the same way
09:07:30 <FauxFaux> I thought they were more commonly used when you wanted both types; union { int32_t decimal; uint8_t[4] bytes; } ipv4address;
09:07:38 <Eelis> Twey: the same way as unions? i've no idea what you could possibly mean by that
09:07:58 <Twey> Eelis: In that you're missing vital information that you have to either determine heuristically or else rely on the user to pass in
09:08:14 <Eelis> yes, in C, the language only provides so much. this is by design.
09:08:57 <Peaker> dmwit, unions are bad for lacking tagged-unions, but better than nothing?
09:09:10 <Berengal> The union I was working with was at least tagged
09:09:32 <Berengal> But the tags didn't match the structs
09:10:20 <Peaker> I encode the catamorphism of ADTs in C, that works better than an (enum, tag X union of structs)..
09:10:31 <hpc> :t foldr4
09:10:31 <lambdabot> Not in scope: `foldr4'
09:11:11 <Jafet> :t (\x -> foldr x x x)
09:11:12 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b -> b
09:11:12 <lambdabot>     Probable cause: `x' is applied to too few arguments
09:11:12 <lambdabot>     In the second argument of `foldr', namely `x'
09:11:38 <aristid> Peaker: how does that look like in C? do you have an exampel?
09:12:07 <Peaker> to encode Either Char Int in C, you can use:  enum Either { Left, Right }; struct Either { enum Either tag; union { char Left; int Right; } };     or you can use: struct { void (*Left)(void *arg, char); void (*Right)(void *arg, int); };
09:12:38 <Peaker> aristid, instead of returning struct Either, you can take as an argument the struct of callbacks/continuations
09:13:06 <Peaker> Then the C compiler makes sure that you only use the correct data, unlike in a union
09:13:28 <Peaker> and if you change the ADT definition (the C struct in this case) the compiler enforces users to remain safe
09:13:35 <aristid> Peaker: isn't the latter hard to use?
09:13:49 <Peaker> aristid, maybe if you are uncomfortable with function pointers in C..
09:14:04 <Eelis> if you have C++ available, you can use  boost::variant<char, int>  which is a discriminated union.
09:14:23 <aristid> Peaker: no i'm comfortable with function pointers... but functions are not first-class
09:14:31 <aristid> Eelis: yeah that's much better
09:14:44 <Peaker> aristid, I sometimes have something like:  #define EITHER_VTABLE(prefix) { prefix##Left, prefix##Right };
09:15:01 <nyingen> I'm not sure I like fclabels redefining (.)
09:15:12 <Peaker> aristid, encoding your data in the (Void *) may sometimes require sharing an extra struct with your callbacks, which is slightly annoying, if that's what you mean..
09:15:29 <Peaker> nyingen, don't they just use the redefined one from Control.Category?
09:15:37 <nyingen> oh, so they do
09:16:24 <Peaker> which generalization of (.) is better, fmap or Category.. ?
09:17:02 <Eelis> i use it for fmap. always.
09:17:08 <Peaker> fmap requires the left side to actually be a function.. Category requires both sides to be of a bigger kind
09:17:11 <nyingen> what package is that in?
09:17:17 <xplat> is there a fold for lambdabot's Mu?
09:17:19 <Peaker> nyingen, fmap?
09:17:33 <djahandarie> xplat, I don't think so.
09:17:36 <djahandarie> :t (in, out)
09:17:36 <lambdabot> parse error on input `in'
09:17:38 <nyingen> Control.Category I meant
09:17:41 <djahandarie> :t out
09:17:42 <lambdabot> forall (t :: * -> *). Mu t -> t (Mu t)
09:18:22 <djahandarie> :t cata -- it'd probably be here if it was already defined
09:18:22 <lambdabot> Not in scope: `cata'
09:18:37 <xplat> it's kind of redundant to have (.)=fmap when already <$>=fmap
09:18:57 <Eelis> . is three times as short
09:19:33 <Jafet> Boobies deserve to be fmapped
09:19:54 <xplat> . is supposed to be associative too
09:19:58 <xplat> fmap is not
09:20:09 <Eelis> "supposed to be" - says who?
09:20:13 <rwbarton> everybody
09:20:22 <Eelis> doesn't bother me
09:20:39 <Jafet> Haskell is going to have associativity?
09:21:15 <xplat> god, your mother, and haskell effin' curry say so
09:21:34 <Eelis> i also don't think i ever actually use non-associative fmaps
09:21:46 <Jafet> Better not eff curry, it could burn
09:22:11 <xplat> Jafet: that's the best part
09:22:13 <djahandarie> :t inn
09:22:13 <lambdabot> Not in scope: `inn'
09:22:16 <Peaker> class Category c => FunctorC f c where fmap :: c a b -> f a -> f b  --- more general than either Functor or Category?
09:22:24 <Eelis> xplat: god is dead, my mother is an idiot, and i don't give a damn about curry
09:22:32 <aristid> Eelis: i thought fmap is actually associative too?
09:22:38 <aristid> @free fmap
09:22:38 <lambdabot> Expected variable or '.'
09:22:40 <Eelis> aristid: tell xplat 
09:23:07 <aristid> fmap a `fmap` fmap b = fmap (a `fmap` b)
09:23:08 <Saizan> for (e ->) the associativity of (.) is exactly why fmap (f . g) = fmap f . fmap g holds
09:23:16 <xplat> well, it's kind of associative, and kind of not
09:23:39 <aristid> xplat: ?
09:24:03 <Peaker> If "f" = "c in" then  c mid out -> f mid -> f out  becomes:   c mid out -> c in mid -> c in out
09:24:10 <xplat> on the value level it's associative (if you followed the laws) but the types are weird
09:24:28 <rwbarton> it doesn't have the right type to be associative in any meaningful way
09:25:00 <rwbarton> :t \a b c -> ((a `fmap` b) `fmap` c, a `fmap` (b `fmap` c))
09:25:01 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> (f b, f b)
09:25:05 <Peaker> is there a good reason to require fmap to be specific to function mappers, rather than allow arbitrary categories?
09:25:08 <aristid> xplat: i think that the laws are followed should be assumed :)
09:25:12 <rwbarton> where did the other functor go?
09:25:22 <rwbarton> only makes sense when one of the functors is ((->) x)
09:25:24 <djahandarie> Peaker, you mean you want a more categorical functor?
09:25:32 <djahandarie> It is definitely nicer when defined that way, it just isn't.
09:25:36 <Peaker> djahandarie, I mean replacing (->) of (a->b) in fmap with some c
09:26:05 <aristid> Peaker: generalising (<<<) and fmap in one big swoop?
09:26:11 <Peaker> yeah
09:26:13 <Saizan> Peaker: then you'd want to replace the f a -> f b with some d (f a) (f b)
09:26:19 <xplat> now that one might be worth doing
09:26:58 <djahandarie> Peaker, http://hackage.haskell.org/packages/archive/categories/0.55.0/doc/html/Control-Categorical-Functor.html
09:27:27 <djahandarie> Comes with all the associated goodies :)
09:28:29 <Saizan> the question is how well it works in practice
09:30:00 * djahandarie disappears
09:31:00 <aristid> doesn't seem to have many non-(->) instances
09:31:57 <xplat> there aren't many non-(->) instances of Category either, so
09:33:05 <xplat> i think it could be a problem defining destination categories for one of these things with a nontrivial object map
09:33:10 <aristid> well Kleisli
09:33:59 <aristid> xplat: would it be possible to use categorical functors to allow Set to become a functor? *unsure*
09:34:18 <xplat> probably not
09:34:48 <Saizan> you could make instance Traversable t => Functor t (Kleisli m) (Kleisli m)
09:34:55 <xplat> Control.Category requires all haskelll types to be valid objects of the category
09:35:35 <xplat> Saizan: so you could
09:36:05 <Saizan> data OrdC a b = (Ord a, Ord b) => OrdC (a -> b), then instance Functor Set OrdC OrdC -- i think
09:37:08 <Saizan> maybe with some added precondition on that (a -> b)
09:37:08 <xplat> Saizan: is that a legal data declaratoin?
09:37:53 <Saizan> xplat: yes, it looks saner in GADT form: data OrdC :: * -> * -> * where OrdC :: (Ord a, Ord b) => (a -> b) -> OrdC a b
09:38:22 <Saizan> legal in GHC, not in h98 :)
09:38:29 <Saizan> or h10
09:38:46 <Berengal> Bah, what is this? "cabal: Can't find transitive deps for haddock"
09:39:25 <xplat> Saizan: how do you define the Category instance for OrdC then, though?
09:40:18 <dcoutts> Berengal: a cabal bug, the cabal haddock command has not yet been updated for the feature where an exe can depend on a lib in the same package
09:40:34 <Skola> What packages should I look into for  NLP tokenization?
09:40:59 <Berengal> dcoutts: Okay, so temporarily comment out the executable then
09:41:43 <Saizan> xplat: either "OrdC f . OrdC g = OrdC (f . g)" or you don't
09:42:02 <xplat> Saizan: what about id?
09:42:22 <Saizan> ok, that's a problem :)
09:44:04 <Saizan> you could have a synthetic Id i guess
09:45:57 <Saizan> (.) would still work out because Id :: OrdC a a; so you can reuse the dictionary in the other function, or return Id if they are both so
09:46:17 <Saizan> s/function/morphism/
09:54:57 * gurur sorry if this message bothers you, i am asking if there is an irc channel or platform (forum, quora like website) where i can discuss my business idea.
09:55:33 <dmwit> Is it Haskell-related?
09:55:58 <gurur> dmwit nope. sorry i just sent to wrong window. really sorry.
09:56:14 <jlouis> I'd answer if I knew of one, sorry
09:57:02 <gurur> jlouis: thank you
09:57:33 <Jafet> Y Combinator!
09:59:06 <gurur> Jafet: other than that ?
10:23:06 <sonoflilit> Hi
10:23:16 <sonoflilit> is there an exit() action?
10:24:46 <nyingen> sonoflilit: System.Exit
10:24:59 <sonoflilit> thanks
10:25:54 <nyingen> to be more specific, System.Exit is the package that contains the actions you're looking for
10:26:04 <sonoflilit> that was the pointer I needed
10:26:09 <sonoflilit> from there, I have docs :)
10:36:10 <Dooda> Hi, does somebody knows how to convert IO String into String?
10:36:34 <jmcarthur> Dooda: you don't, you convert functions taking String parameters into functions taking IO String parameters :)
10:36:44 <barshirtcliff> a <- IO String
10:37:18 <jmcarthur> Dooda: do { x <- myIOString; useXHere }
10:37:43 <jmcarthur> ^^ just syntax sugary way of doing what i said
10:38:00 <Dooda> jmcarthur: sorry, i didn't understood the command
10:38:12 <Dooda> suppose i have a function called myFunction that takes a String as parameter
10:38:13 <Dooda> but i only have a IO String type
10:38:14 <jmcarthur> Dooda: just read up on do notation
10:38:49 <jmcarthur> do { x <- myIOString; return (myFunction x) }
10:39:04 <jmcarthur> or if myFunction gives an IO action then drop then say:
10:39:05 <ion> or: myFunction =<< myIOString
10:39:07 <nejucomo> cabal install cabal-install fails on this debian system and even with --verbose I have no idea why.  It appears to fail at the linking step with ExitFailure 9.
10:39:10 <jmcarthur> do { x <- myIOString; myFunction x }
10:39:16 <Dooda> jmcarthur: ok, i'll try it
10:39:31 <barshirtcliff> realworldhaskell.com has a nice discussion of monads and do.  I recommend the IO chapter for you, Dooda.
10:39:33 <jmcarthur> s/then drop//
10:39:43 <barshirtcliff> it's freely available online.
10:39:53 <jmcarthur> i, too, recommend reading up on it
10:40:55 <barshirtcliff> ion: would you say that's more perfectly idiomatic?
10:41:38 <ion> Both are just fine, but one is pointfree.
10:42:03 <ion> @. pl undo do x <- myIOString; return (myFunction x)
10:42:03 <lambdabot> myFunction `fmap` myIOString
10:42:09 <ion> @. pl undo do x <- myIOString; myFunction x
10:42:09 <lambdabot> myFunction =<< myIOString
10:42:24 <barshirtcliff> is that technically point-free?  isn't myIOString a point?
10:42:28 <barshirtcliff> so to speak.
10:42:48 <aristid> barshirtcliff: i don't see a lambda there :)
10:42:55 <ion> Within that context, that’s as pointfree as you’ll get.
10:42:58 <monochrom> eliminate points at all cost!
10:42:59 <barshirtcliff> I see.
10:45:06 <nejucomo> I consider it a fail that cabal install cabal-install exits with ExitFailure 9 without giving me any idea of what is wrong, even with --verbose.
10:45:45 <nejucomo> The only googling hit is a transcript from this room where a user eventually gets it to work without explaining what the problem is or how they fixed it.
10:45:58 <nejucomo> Is there a cabal-specific channel?
10:46:09 <nejucomo> Aha.  There is.
10:46:47 <sonoflilit> nejucomo: anyway, ExitFailure 9 means that a step took so much RAM that your OS killed it
10:46:54 <sonoflilit> usually, for me, this step is linking
10:47:09 <monochrom> ooohhh, linker oom again
10:47:10 <nejucomo> Ah, thanks!
10:47:18 <sonoflilit> installing GNU gold, if you are on linux, might help a lot
10:47:32 <elliottt> nejucomo: did you try -v3?
10:47:33 <monochrom> gold helps a lot. I use it.
10:47:35 <sonoflilit> but I agree the error is not very clear
10:47:39 * nejucomo hunts for a cabal ticket tracker to suggest ExitFailure 9 should be accompanied by output saying: "out-of-memory".
10:47:42 <elliottt> that's what i use when cabal is acting up.
10:47:54 <nejucomo> monochrom: Thanks!
10:48:14 <sonoflilit> gold is awesome. It took my linking times from unbearable to a few seconds
10:48:28 <sonoflilit> by using orders of magnitude less RAM
10:49:21 <gwern> anyone know if community.haskell.org supports .htaccess files?
10:49:45 <dmwit> nejucomo: Even better, the error message should suggest gold. =)
10:50:26 <monochrom> gold is available to linux only
10:50:51 <monochrom> the error message should suggest "switch to linux so you can use gold"! :)
10:51:42 <dcoutts_> nejucomo: aye, the problem is our process API does not let us find out when a process terminates due to a signal
10:52:00 <dcoutts_> nejucomo: so we cannot distinguish between exit 9 and kill 9
10:52:31 <gwern> .htaccess anyone?
10:53:48 <nejucomo> dcoutts_: I see.  It could still help to say: "ExitFailure 9 - The linker may have run out of memory or may have been killed for another reason." or something like that, don't you think?
10:54:31 <sonoflilit> +1
10:54:44 <nejucomo> Whelp, time to reboot this vm with more ram configured.  ;-)
10:54:46 <gwern> it's apache, so it should have .htaccess, but none of my redirects are working, and I've tried all the prefixes I can think of...
10:55:16 * hackagebot bson-mapping 0.1.1 - Mapping between BSON and algebraic data types.  http://hackage.haskell.org/package/bson-mapping-0.1.1 (FrancescoMazzoli)
10:55:18 <monochrom> actually, "the linker suffers ExitFailure 9" or "<this longish command> suffers ExitFailure 9" does wonder
10:56:05 <monochrom> and oh, <this longish command> ought not be "cabal install --only" :)
10:57:03 <sonoflilit> aaah
10:57:04 <monochrom> actually, perhaps you don't know that it's the linker
10:57:18 <sonoflilit> I use exitSuccess but yesod just catches it like nothing happened
10:57:31 <sonoflilit> probably not on the main thread
10:57:41 <sonoflilit> how can I kill the program if I'm not on the main thread?
10:57:57 <monochrom> find the main thread's id, throwTo it
10:58:20 <xplat> > let z = In Nothing; s = In . Just; iter s z = maybe z (s . iter s z) . out; llength = foldr (const s) z; p = iter ('S':) "Z"; at = iter (.tail) head; lrtails' = iter (\ys -> let y = head ys in tail y:ys); stepS = (fmap.fmap.flip fmap) out $ maybe; lrtails xs = stepS [] (lrtails' [xs]) (llength xs); lreverse = map head . lrtails in take 5 $ lreverse [1..50000]
10:58:22 <lambdabot>   [50000,49999,49998,49997,49996]
10:58:23 <monochrom> but can be easily foiled by the main thread's code catching it saying lalalala...
10:58:24 <Berengal> I need a name...
10:58:33 <monochrom> Mozart
10:58:40 <xplat> this seems to be O(n^2) but i can't figure out why
10:59:13 <Berengal> I have a data Rect a, and functions rectContains and rectIntersection defined for Rect Int and Rect Float...
10:59:27 <Berengal> What should the class containing the two functions be called?
10:59:39 <wlangstroth> Rectory
10:59:46 <barshirtcliff> :D
11:02:01 <xplat> it seems like the spine of the list should be built by two foldrs and every element of lrtails should start out as a thunk of the tail of the next element
11:02:52 <sonoflilit> alright, I finally have some REAL profiling output by my code
11:03:03 <xplat> so when the first one is evaluated, it SHOULD evaluate all the rest at that time and they should each be O(1) when you look at them after that
11:03:07 <sonoflilit> there's hundreds of megabytes of (,)s
11:03:15 <sonoflilit> what is a good guess of the meaning?
11:03:22 <monochrom> tuples
11:04:05 <sonoflilit> yes... but why would it have so many tuples?
11:04:12 <sonoflilit> mm... I guess that requires looking at the code
11:04:14 <xplat> the meaning is that someone used too many anonymous data types and now your heap profile by type is useless :)
11:04:45 <sonoflilit> lol
11:04:56 <sonoflilit> I don't think that's the case
11:12:41 <sonoflilit> :(
11:12:53 <sonoflilit> the -hc profiler writes too short names
11:13:01 <sonoflilit> I cannot know what's really happening
11:13:05 <sonoflilit> can I change the name length?
11:13:59 <dahankzter> cabal install -j6 would be nice
11:33:08 <dahankzter> would parallell compiling work? i seem to remember reading about it somewhere but cant find anything about it
11:51:10 <PIOH> hello!
11:51:23 <sonoflilit> hi
11:51:27 <PIOH> anyone can explain me a bit about "map" function? thanks!
11:52:20 <sipa> it creates a new list
11:52:25 <monochrom> map f [a,b,c] = [f a, f b, f c]. that is all
11:52:27 <sipa> with a transformed version
11:52:33 <sipa> of all elements of another list
11:53:04 <PIOH> oh, i think i understand
11:53:10 <PIOH> thanks a lot!
11:53:20 <PIOH> i'll continue with my lessons :D
11:54:36 <Eduard_Munteanu> Could one safely introduce double negation elimination in Haskell as an axiom? I'm thinking: direct :: Not (Not a) -> a; direct = undefined; inverse :: a -> Not (Not a); inverse = undefined
11:55:58 <Saizan> that's not adding it as an axiom, that's just exploiting haskell's inconsistency
11:55:59 <quantum> Eduard_Munteanu: no
11:56:49 <Eduard_Munteanu> Um, why wouldn't it be the same thing? I'm adding it as an assumption. Wouldn't the question be "is it consistent"?
11:56:58 <monochrom> that's just another way to say it's safe
11:57:35 <monochrom> if haskell is already inconsistent, adding anything is safe
11:57:49 <Eduard_Munteanu> What if Haskell is consistent? :)
11:58:04 <monochrom> if haskell is consistent, adding anything is safe too
11:58:14 <Saizan> depends on what you mean by safe
11:58:30 <Eduard_Munteanu> Saizan: avoiding contradictions
11:58:32 <monochrom> Proof. Haskell is inconsistent. Therefore "if haskell is consistent, blah".
11:59:08 <Eduard_Munteanu> Wait, the assumption here is I'm (trying) using a consistent subset of Haskell.
11:59:12 <Saizan> if haskell avoided contradictions you couldn't use undefined
11:59:34 <Eduard_Munteanu> Erm, but surely you can write valid proofs in Haskell.
11:59:48 <Eduard_Munteanu> Not really safe, but doable.
11:59:51 <monochrom> I can write invalid proofs too.
11:59:58 <Eduard_Munteanu> Would double negation elimination increase unsafety?
12:00:03 <Eduard_Munteanu> Yeah.
12:00:07 <yrlnry> O_o
12:00:15 <Saizan> this makes no sense
12:00:29 <yrlnry> Haskell already has general recursion.  Any system with general recursion is utterly inconsistent, because it has type (p → p) → p.
12:00:34 <monochrom> indeed. treating haskell types as logic makes no sense.
12:01:04 <Saizan> but e.g. Agda's logic is supposed to be consistent if you add excluded middle
12:01:07 <monochrom> go agda or something if you want to drink the curry-howard coolaid wholesome
12:01:22 <Eduard_Munteanu> Ok, put it another way, take the underlying logic system, say intuitionistic AFAIK. Does intuitionistic logic affirm/imply the negation of double negation elimination, or is the latter independent in IL?
12:01:40 <Eduard_Munteanu> Saizan: ah, thanks. (Though I'm unsure if the logics are exactly the same.)
12:01:52 <yrlnry> Actually I read a paper by (I think) Turner about how you can do the curry-howard reasoning in Haskell an it works fine as long as you stay away from subset X.
12:01:57 <Eduard_Munteanu> monochrom: yeah, I suppose I should do that.
12:02:08 <monochrom> double negation elimination is independent in intuitionistic logic
12:02:27 <Eduard_Munteanu> I see.
12:02:37 <Eduard_Munteanu> Yeah, I should go Agda anyway.
12:03:44 <Berengal> Is there a way to get the offset of a struct member in c2hs?
12:03:50 <Saizan> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.8232 <- there's this though
12:04:06 <yrlnry> Saizan:  that's the paper I was thinking of.  Thanks!
12:05:12 <yrlnry> Eduard_Munteanu:  see saizan's reference
12:05:21 <Eduard_Munteanu> Thanks.
12:07:02 <Eelis> heh, i love how in the new "Haskell for the cloud" paper (about Erlang-style distributed computing in Haskell), the authors constantly stress that whenever their interface doesn't make some computational thing transparent, that's really a benefit "because it gives users a cost model and lets them reason about performance" (paraphrase)
12:07:07 <Eelis> and all the while, they never notice the elephant standing in the middle of the room, which is Haskell's use of transparent garbage collection, which has this exact flaw, but which we're all supposed to love regardless.
12:08:19 <Eduard_Munteanu> Heh, moral equality.
12:10:06 <Saizan> tbf, haskell programs with a normal form are valid proofs for some variant of intuitionistic logic (System F should fit) and if you postulate some direct :: Not (Not a) -> a with only "e ~> e' ----> direct e ~> direct e'" as reduction rule then you should get that the new normal forms are proofs of some version of classical logic
12:11:11 <dmwit> Berengal: I don't think so, but you can get a function that gets it or sets it.
12:11:40 <dmwit> Berengal: (Via the get and set hooks, respectively.)
12:11:50 <Eduard_Munteanu> Hm, so we can actually have classical logics embedded in such a system?
12:12:21 <Eduard_Munteanu> Though surely we can't do non-constructive proofs, can we?
12:12:31 <Saizan> mine wasn't an embedding
12:12:34 <ClaudiusMaximus> Berengal: hsc2hs has an #offset thingy, http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
12:12:45 <Saizan> it was adding new rules to the system to change it into another
12:13:07 <Berengal> dmwit: Not struct members you can't
12:13:09 <Eduard_Munteanu> Uh, yeah, I kinda used that liberally.
12:13:21 <Berengal> ClaudiusMaximus: I'm using c2hs, not hsc2hs unfortunately
12:13:53 <Saizan> though there is in fact an embedding of classical logic into intuitionistic, which is Cont Void p when p has no quantifiers
12:14:05 <ClaudiusMaximus> Berengal: oh, sorry - never used c2hs, somehow i think i assumed it was like hsc2hs but more
12:14:20 <Berengal> ClaudiusMaximus: It kind of is, but not entirely
12:14:31 <dmwit> Berengal: Really? I thought that was what {#get structName.field#} did. (Though admittedly I hadn't tried that one.)
12:15:01 <Saizan> Eduard_Munteanu: the non-constructivity in my system comes out of the fact that "direct" wouldn't really be a function
12:15:01 <Berengal> dmwit: #get and #set does {peek,poke}ByteOff
12:15:12 <dmwit> Berengal: Oh, did you mean for structs that are not Ptr in the Haskell-land, somehow?
12:15:20 <Berengal> dmwit: Yes
12:15:29 <Eduard_Munteanu> Saizan: hm, can that be translated to an existential? I'm making some connections here and I can't help wonder whether non-constructivism would amount to leaky existentials
12:15:38 <dmwit> I think c2hs really assumes you only ever have Ptr.
12:15:59 <Berengal> Ptr or Storable it seems like
12:16:16 <Berengal> I do have Storable for those structs, so a simple peekByteOff would work if I could get the offset
12:16:48 <Berengal> #get *does* get the offset, but it also fixes the type of the returned value. If it didn't, it'd work
12:17:01 <dmwit> If you want to have non-Ptr stuff, you've got to do some copying, I think. The {#pointer#} hook claims to help you with that work a bit.
12:17:05 <Berengal> (Same with #set)
12:17:33 <dmwit> Oh, dear, are you mucking about with unions?
12:17:33 * Eduard_Munteanu really has to get started in Agda!
12:17:47 <Berengal> dmwit: No, parameterised types
12:18:03 <dmwit> almost as bad
12:18:26 <Berengal> If only there was some way for me to say "Shut up and splice this string"...
12:18:32 <dmwit> But then, in C isn't that usually done with void pointers?
12:18:47 <Berengal> dmwit: In this case it's just repeated code with different types
12:18:54 <dmwit> ack!
12:19:11 <Eduard_Munteanu> @src Cont
12:19:11 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
12:19:17 <Berengal> IntRect and FloatRect in this case. I've made a data Rect a with Storate (Rect Int) and Storable (Rect Float)
12:19:35 <dmwit> Sure.
12:20:15 <Berengal> But I can't define {#pointer IntRect -> Rect Int #}
12:20:25 <dmwit> Yes, I see your pain.
12:21:22 <Berengal> There's also a 20 month old patch in the c2hs trac which hasn't been applied...
12:22:24 <Berengal> It's like there's a million good solutions out there, but all of them just barely out of reach... All I'm really left with now is hard-coding the offsets myself
12:23:09 <Eduard_Munteanu> @djinn (a -> Void) -> Void
12:23:09 <lambdabot> -- f cannot be realized.
12:23:20 <Eduard_Munteanu> Grr.
12:23:27 <Eduard_Munteanu> Though it looks obvious.
12:23:44 <mercury^> Void is a truly empty type?
12:24:00 <Eduard_Munteanu> mercury^: there's an extension that allows it IIRC
12:24:00 <dmwit> Eduard_Munteanu: Can't be done; consider instantiating a to Void.
12:24:16 <aristid> @djinn (a -> b) -> b
12:24:16 <lambdabot> -- f cannot be realized.
12:24:22 <aristid> @djinn (a -> b) -> a -> b
12:24:22 <lambdabot> f a = a
12:24:22 <dmwit> Eduard_Munteanu: That would mean the function you're asking for would have to turn "id" into a value of type "Void".
12:24:29 <aristid> @. pl djinn (a -> b) -> a -> b
12:24:29 <lambdabot> f = id
12:24:43 <aristid> dmwit: fix id :)
12:24:43 <Saizan> Eduard_Munteanu: i think you'd enjoy this http://r6.ca/blog/20060904T175400Z.html
12:25:13 <frerich_> Hm is there something like an 'Indexable' type class already which could be used to treat something like [(a,b)] and Data.Map and anything else which can reasonably do key-value lookups uniformly?
12:25:31 <Eduard_Munteanu> Hm.
12:25:45 <Eduard_Munteanu> That is strange :)
12:25:49 <frerich_> I saw that Data.Map doesn't instantiate anything like that, but maybe the type class is somewhere so that I just need to write an instantiation?
12:27:18 <dmwit> frerich_: Yes, there is!
12:27:21 <Eduard_Munteanu> Would someone know whether (a -> Void) -> Void has a name outside Haskell? I mean, as an axiom / consequence of one.
12:27:23 <dmwit> Let me see if I can re-find it.
12:27:37 * Berengal stomps off and writes the marshalling code in C
12:27:41 <NisseP> edison?, or is that old hat now
12:27:46 <dmwit> Eduard_Munteanu: Not a -> False seems like a bad thing to have in a logic.
12:28:58 <Eduard_Munteanu> Dang, the intuitionistic notions of Not are a bit more varied than I thought of.
12:29:07 <hpc> wouldn't that be (Not a -> False) => (True -> a) => a?
12:29:50 <NisseP> frerich_: http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison-Assoc.html
12:30:05 * Eduard_Munteanu usually likes   type Not a = forall b. a -> b
12:32:51 <aristid> Eduard_Munteanu: wtf?
12:32:55 <dmwit> There we are!
12:33:05 <dmwit> ?hackage keys
12:33:05 <lambdabot> http://hackage.haskell.org/package/keys
12:33:10 <dmwit> frerich_: Take a look at that.
12:33:37 <dmwit> frerich_: Data.Map even has an instance. =)
12:33:49 <NisseP> ok, that one's better than what i said.
12:33:59 <NisseP> except for the name <#$> :p
12:34:12 <Eduard_Munteanu> aristid: what's wrong?
12:34:44 <aristid> Eduard_Munteanu: what do you use that for? :P
12:34:52 <frerich_> dmwit: Excellent, that looks perfect.
12:35:34 <dmwit> The [] instance is a bit unfortunate, I guess, if you wanted to use assoc-lists.
12:35:48 <Eduard_Munteanu> aristid: well you can use it as Not very well, I like it because it connects nicely to the principle of explosion.
12:36:09 <aristid> Eduard_Munteanu: how do you use it as Not?
12:36:39 <NisseP> aristid: similar to `type False = forall a. a`
12:36:42 <NisseP> same, even.
12:37:41 <Eduard_Munteanu> aristid: theorem :: forall a b. (a, b) -> Either (Not a) (Not b)
12:37:54 <Eduard_Munteanu> Actually, I've seen it in connection to deMoivre laws first, I think.
12:38:33 * hackagebot Etage-Graph 0.1.1 - Data-flow based graph algorithms  http://hackage.haskell.org/package/Etage-Graph-0.1.1 (MitarMilutinovic)
12:38:34 <dmwit> Surely that should be Not (Either (Not a) (Not b))
12:38:35 <Eduard_Munteanu> Erm... Not (a, b)
12:38:41 <dmwit> Yeah.
12:38:42 <Eduard_Munteanu> Yeah, or that!
12:38:43 <Eduard_Munteanu> :)
12:41:50 <byorgey> also, you probably mean de Morgan.
12:41:50 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
12:42:03 <Eduard_Munteanu> Bah, I'm tired.
12:42:08 <Eduard_Munteanu> Indeed.
12:42:23 <Eduard_Munteanu> Sorry.
12:42:24 <byorgey> de Moivre's theorem is the one about powers of complex numbers in polar form
12:42:34 <byorgey> no need to apologize =)
12:42:56 <byorgey> sorry, I should have put a smiley after de Morgan =)
12:44:22 <aristid> byorgey: just add smileys to all statements :)
12:44:26 <Eduard_Munteanu> But anyway, one can read the principle of explosion straight from the type synonym, more or less.
12:44:40 <Eduard_Munteanu> Seemed insightful to me.
12:44:52 <Eelis> those De Morgan's laws have got to be the cheapest most trivial thing anybody ever got name credit for
12:45:06 <fryguybob> @check \t -> cos t :+ sin t == exp (0 :+ t)
12:45:06 <lambdabot>   "OK, passed 500 tests."
12:45:26 <Eelis> "omg, NOT (P AND Q) = (NOT P) OR (NOT Q), i'm famous now!"
12:45:34 <Eelis> ...
12:47:20 <wlangstroth> isn't there a rule stating that the laws have to be named after someone who *didn't* do the discovering?
12:47:21 <ion> eelis: Haha
12:47:51 <Maxdamantus> after or by?
12:48:00 <byorgey> both
12:48:13 <wlangstroth> :)
12:48:37 * Maxdamantus wonders who Einstein's Theory of Special Relativity should be named after.
12:48:51 * Eduard_Munteanu remembers reading an article on 'e' and Euler.
12:49:09 <Eelis> to his credit, De Morgan did this in the 19th century, and anything done ages ago is automatically cool
12:49:24 <Eduard_Munteanu> IIRC, it concluded it was a coincidence or something like that, since Euler was too modest to do such a thing.
12:49:50 <Maxdamantus> I'm sure someone else in some other part of the universe of some other "life" form must've discovered it "before" him.
12:50:31 <Eduard_Munteanu> I often wonder how the original discoverer referred to his mathematical object.
12:50:43 <Maxdamantus> "relativity"
12:50:45 <xplat> Maxdamantus: i think it's pretty likely that that's not true for any meaningful form of 'before', but whatever
12:51:37 <Eduard_Munteanu> Like, did Bessel call his functions Bessel? :P Likely not. :)
12:51:47 <Maxdamantus> xplat: why would you think that?
12:54:13 <xplat> Maxdamantus: because the universe in our past light cone gets young pretty fast outside our galaxy, for one thing
12:54:27 <Volatile> Hi. I'm having trouble upgrading cabal on my gentoo x86 machine from version 1.1.6.2 t version 1.8.0.6. Anyone wanna kick me in the right direction?
12:54:29 <mm_freak> Eduard_Munteanu: 'e' was just the next free character in the alphabet
12:54:51 <Maxdamantus> xplat: and what's the minimum amount of time required for intelligent life to exist?
12:55:08 <Eduard_Munteanu> I see.
12:55:32 <Eduard_Munteanu> Volatile: what's the problem?
12:56:17 <Maxdamantus> It was just chance that humans started some few hundred thousand years ago or whatever, rather than some few hundred million years ago.
12:56:24 <Dooda> Hi, somebody knows how to convert a String IO to String?
12:56:52 <DrSyzygy> Dooda: You mean an IO String?
12:57:00 <DrSyzygy> Dooda: And the short answer is “You shouldn't.”
12:57:04 <Maxdamantus> Dinosaurs existed a few hundred years ago; why couldn't humans have? (maybe if there weren't any dinosaurs ..)
12:57:10 <Maxdamantus> er, hundred million*
12:57:17 <DrSyzygy> Dooda: What do you want to do with the IO String? 
12:57:43 <byorgey> Dooda: if you are in a do-block, you can do something like     s <- theIOString; doSomethingWith s
12:57:49 <byorgey> where theIOString :: IO String
12:57:54 <byorgey> then s will have type String
12:57:59 <Dooda> DrSyzygy: well, i have this function i want to execute and it's parameter is a String
12:58:00 <xplat> Maxdamantus: uncertain, but if intelligent life could easily exist much earlier than us there would be a lot of candidate worlds (the space in a given age range in our past light cone grows with the square of the average age within that range) and probably at least one of them would have gotten past any Fermi filter that exists and given unmistakable signs of their existence
12:58:01 <Volatile> Eduard_Munteanu: I get "setup: ghc-6.7: unrecognised flags: --supported-languages" after it has built setup.
12:58:04 <Maxdamantus> and a few hundred million years isn't that insignificant regarding the age of the universe (dinosaurs were what? 400 million years ago? 1/10th the age)
12:58:09 <Dooda> DrSyzygy: but i want to get the parameter from a file
12:58:25 <DrSyzygy> Dooda: What byorgey said is one way to do it.
12:59:07 <Maxdamantus> xplat: how would they give unmistakable signs of their existance?
12:59:28 <rostayob> Dooda: read some docs about IO in haskell, and about monads in general
12:59:42 <xplat> Maxdamantus: shutting off stars to conserve energy is one of the likely ways
12:59:55 <Maxdamantus> xplat: and how many stars are there?
13:00:13 <ion> A variable of the type IO String doesn’t contain a string, it contains something out of which you can draw a string; in case of IO by potentially running an impure action. ‘do a <- anIOString; …’, being syntactic sugar for ‘anIOString >>= \a -> …’, is what you do to draw a string from ‘anIOString’ and assign it to ‘a’.
13:00:15 * Maxdamantus would imagine they wouldn't shut off a significantly large amount of them.
13:00:21 <DrSyzygy> Dooda: Don't /msg people randomly, it's kinda rude.
13:00:38 * hackagebot cprng-aes 0.1.0 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.1.0 (VincentHanquez)
13:01:09 <xplat> Maxdamantus: i expect if they got past the fermi filter they would probably be HERE by now, actually
13:01:10 <mm_freak> i think, byorgey has given the best suggestion to Dooda 
13:01:13 <Maxdamantus> Galaxies have thousands of stars .. no one's going to notice one star a billion light years away disappearing.
13:01:24 <gio123> sum(NXP) where P \in S, how can I write it as formula? for exampe if S contains P1 and P2 then we have NxP1 + NxP2
13:01:56 <byorgey> gio123: is S a list?
13:02:00 <Eduard_Munteanu> Volatile: hm, that's an old GHC
13:02:08 <gio123> S is a set
13:02:13 <gio123> finite or infinite
13:02:13 <Eduard_Munteanu> Volatile: you should update it, really.
13:02:47 <byorgey> gio123: you want to know how to write Haskell code to implement it?
13:02:59 <gio123> noo
13:03:07 <gio123> I want to write it as mathematical formula
13:03:10 <gio123> in a nice way
13:03:11 <gio123> :)
13:03:29 <gio123> with nice indexing ...
13:03:52 <byorgey> gio123: in LaTeX I would write  \sum_{p \in S} (n \times p)
13:03:57 <xplat> Maxdamantus: the interval between an advanced civilization entering your past light cone and them arriving at your doorstep should probably be pretty thin, a couple of thousand years at the most
13:04:15 <Volatile> Eduard_Munteanu ! oh. Yes, yes it is. So, why is that used when I have 6.12 installed. Hmm...
13:04:20 <dcoutts_> Volatile: also, it looks like you're running a development version of ghc, --supported-languages was added some time during the 6.7 dev series
13:04:42 <dcoutts_> Volatile: so cabal cannot always get it right for dev versions, depends when you took the snapshot
13:05:04 <dcoutts_> Volatile: sounds like you should check your path
13:05:04 <Maxdamantus> xplat: maybe there's a nearly certain probability that they'll kill themselves before doing it.
13:05:17 <xplat> maybe not at your actual planet, but there should be at least a few visibly obvious engineering projects in any halfway-useful-looking galaxy by then
13:05:48 <Maxdamantus> xplat: or maybe the few civilisations that didn't kill themselves were so aliane that they wouldn't disturb an apparently peaceful planet like this.
13:05:54 <rovar> is there a way to view the results of TH?
13:06:00 <Maxdamantus> Well, one with life.
13:06:08 <Volatile> dcoutts_ ! Oh, fuck me. "which ghc" returns "/usr/local/bin/ghc". Guess that solved that. Thanks. :)
13:06:30 <Maxdamantus> (intelligent life, that would go crazy and kill themselves if suddenly aware of such a civilisation)
13:07:46 <byorgey> Maxdamantus, xplat: -blah please =)
13:07:55 <Maxdamantus> I'd imagine for such a civilisation, they'd probably take into account probable intelligent life before taking a section of a galaxy.
13:07:56 <dons> all time record for #haskell, btw. 748 users
13:08:15 <mm_freak> gio123: first you may want to simplify that formula
13:08:16 <Maxdamantus> Well, not probably, but it wouldn't be so far-fetched imo
13:08:37 <Maxdamantus> (that that probability is so)
13:09:32 <mm_freak> Dooda: unless you have specific reasons for secrecy, please ask in the channel
13:11:18 <monochrom> no no no, asking in pm is more fun. especially if you pm 700 people and get 700 different answers.
13:11:38 <lispy>  /msg monochrom ask what?
13:11:38 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
13:11:40 <lispy> oops
13:11:44 <lispy> ;)
13:11:44 <monochrom> hehe
13:11:45 <lispy> ?messages
13:11:46 <lambdabot> byorgey said 5h 4m 21s ago: wow, that was fast! thanks! I'll let you know how it goes.
13:11:58 <monochrom> he who messages get messaged!
13:12:12 <lispy> yeah, that is kind of creepy
13:12:48 <lispy> so maybe I should put that version that byorgey is excited about on hackage...
13:14:40 * hackagebot uuagc 0.9.37.2 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.37.2 (ArieMiddelkoop)
13:14:59 <dmead> ?seen byorgy
13:14:59 <lambdabot> Unknown command, try @list
13:15:19 <lispy> preflex: seen byorgey
13:15:19 <preflex>  byorgey was last seen on #haskell 7 minutes and 33 seconds ago, saying: Maxdamantus, xplat: -blah please =)
13:15:23 <Berengal> Are the pointers from Data.ByteString.Internal.toForeignPtr suitable as void pointers?
13:15:38 <lispy> Berengal: no
13:15:41 * hackagebot freetype2 0.1.0 - Haskell binding for FreeType 2 library  http://hackage.haskell.org/package/freetype2-0.1.0 (JasonDagit)
13:15:49 <lispy> Berengal: You really need to convert them to Ptr
13:15:53 <lispy> Berengal: look at withForeignPtr
13:15:55 <dmead> byorgey: hac phi is on this year?
13:15:58 <Berengal> lispy: Well, obviously
13:15:59 <dmead> ?type hopen
13:16:00 <lambdabot> Not in scope: `hopen'
13:16:05 <dmead> @hoogle hopen
13:16:05 <lambdabot> No results found
13:16:13 <dmead> is hopen gone or something?
13:16:36 <lispy> Berengal: maybe I misunderstood your question.  In C if a function takes a void*, then you can give it a pointer to anything.
13:16:46 <dmwit> dmead: Hac Phi is on this year!
13:16:58 <Berengal> lispy: It also takes a length, BSI.toForeignPtr gives me that length, but it has to be the same size
13:17:02 <dmead> most good, i have things to hack on
13:17:04 <lispy> Berengal: strictly speaking you shouldn't use void** in C, but people still do that.
13:17:21 <Berengal> lispy: just plain void*
13:17:32 <Berengal> (and it should be char* in this case, but it isn't and I can't change that)
13:17:39 <lispy> Berengal: if you use toForeignPtr you also need to add in the offset when you get the Ptr
13:17:56 <Berengal> lispy: Yes yes, all taken care of. It's the size I'm worried about
13:18:10 <lispy> OH
13:18:15 <lispy> char = byte
13:18:20 <Berengal> void = ???
13:18:27 <lispy> yeah, void = ??.
13:18:50 <Berengal> The docs say "size_t size -- length in bytes"
13:18:53 <lispy> If something takes a void*, and a size, then the size is most likely in bytes
13:18:59 <Berengal> So I guess Word8 does just fine
13:19:02 <lispy> Yup
13:19:23 <lispy> in C char is at least 1 byte
13:19:23 <Eduard_Munteanu> For a size? Not likely.
13:20:04 <Eduard_Munteanu> (but not necessarily one octet ;) )
13:20:19 <Berengal> Eduard_Munteanu: The size is given in sizeof units. Those units need to match up or things will go bad
13:20:25 <lispy> Eduard_Munteanu: yeah, although I challenge you to find a modern processor that doesn't use octets.
13:20:29 <aristid> lispy: i think it's exactly 1 byte, but a byte does not have to be an octet :)
13:20:34 <Berengal> (size_t itself is probably 32 or 64 bits, depending on the system)
13:20:42 * hackagebot xml-enumerator-combinators 0.1 - Parser combinators for xml-enumerator and compatible XML parsers.  http://hackage.haskell.org/package/xml-enumerator-combinators-0.1 (AristidBreitkreuz)
13:20:42 <Eduard_Munteanu> Though I think it's one byte yeah, like aristid says
13:20:43 <aristid> sizeof(char) == 1, by defintion
13:21:19 <frerich_> I tried to write a translation function which takes a list and a 'dictionary' and maps the list to a single result (the concatenation of the translations). It works, but I somehow cannot generalize the signature as much as I tried. My code is at http://hpaste.org/45383/translate_function
13:21:25 <Berengal> aristid: That's one of the few things I know about C
13:21:28 <frerich_> Does anybody know why the signature in the comment yields that error message?
13:21:29 <ion> In most real-world environments, 0.9 < sizeof (char) < 1.1
13:21:40 <Eduard_Munteanu> Heh.
13:22:05 <lispy> did you know with sizeof, the parens are not always required?
13:22:07 <Berengal> In most real-world environment, 8 pt <= sizeof(char) <= 12 pt
13:22:28 <sipa> ion: except for very fat charachters
13:23:40 <thoughtpolice> lispy: it seems my objective c patches were merged into ghc (horray,) and i took your advice and wrote about my RC4 code a little :)
13:25:00 <lispy> thoughtpolice: I was the ticket was closed by SimonM and I cheered!
13:25:11 <aristid> lispy: which Simon M?
13:25:16 <thoughtpolice> simon marlow
13:25:20 <lispy> aristid: JaffaCake 
13:25:29 <aristid> preflex: seen jaffacake
13:25:29 <preflex>  jaffacake was last seen on #ghc 4 hours, 35 minutes and 39 seconds ago, saying: yeah
13:25:52 <aristid> lispy: just because there are lots of simons :)
13:25:53 <lispy> thoughtpolice: I also noticed your blog post on reddit :)
13:26:22 <lispy> aristid: indeed.  I tend to say spj for Simon Peyton-Jones and SimonM for Simon Marlow
13:26:38 <lispy> aristid: and sm for Simon (forgot his last name)
13:26:49 <aristid> there's also simon michaels (sm) and simon meier
13:27:02 <aristid> simon michael without s. oops.
13:27:23 <lispy> simon is a popular name with haskell ethusiasts
13:27:35 <aristid> indeed :D
13:28:07 <aristid> we're all honorary simons ;)
13:28:25 <lispy> I'm starting to form an opengl taskforce.  So far I know that pastorn and jmcarthur are interested.  I'll send an announcement out when things are closer to ready.
13:28:37 <lispy> (this is for the cleanup effort on the opengl bindings)
13:29:06 <lispy> If you're interested leave me a message via lambdabot or email me dagitj on gmaile.
13:29:23 * sm preens
13:30:37 <aristid> sm: what does "preens" mean?
13:31:53 <bos> @pl \i xs -> i + length xs
13:31:54 <lambdabot> (. length) . (+)
13:32:08 <dolio> It's like combing your hair, only you use a beak on your feathers.
13:34:41 <sm> aristid: like a peacock cleaning and fluffing it's feathers. I have a special name :)
13:35:24 <aristid> @pl \xs i -> length xs + i
13:35:24 <lambdabot> (+) . length
13:35:44 <aristid> bos: that's actually readable :)
13:36:04 <bos> aristid: not very useful with scanl, though
13:36:23 <aristid> hmm
13:36:33 <ion> :t length .: (+)
13:36:34 <lambdabot> forall a. (Num [a]) => [a] -> [a] -> Int
13:36:47 <ion> err, no
13:36:47 <aristid> ion: the dot is on the wrong side of the section :)
13:37:06 <ion> :t (.:)
13:37:06 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
13:37:14 <dolio> @type flip $ (+) . length
13:37:15 <lambdabot> forall a. Int -> [a] -> Int
13:38:03 <aristid> dolio: the flip ruins the whole brevity tho
13:38:28 <aristid> :t scanl (flip $ (+) . length)
13:38:28 <lambdabot> forall a. Int -> [[a]] -> [Int]
13:38:33 <dolio> Well, I refer to The Dude by the name El Duderino.
13:38:39 <kowey> so, I've got this Haskell record representing some kind of program state (I keep it in an IORef)
13:39:28 <kowey> and I'd like expose it to some C program (actually Common Lisp, so CL mother program using a Haskell lib)
13:39:58 <lispy> kowey: you'd better be using sbcl!
13:39:59 <kowey> how would I go about doing that? the tutorials I've seen don't seem to talk about this... I imagine I can generate some kind of pointer?
13:40:14 <lispy> kowey: I'd look at stablenames
13:41:14 <kowey> thanks, lispy!
13:41:33 <lispy> kowey: I think I meant stable ptr: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/Foreign-StablePtr.html
13:41:50 <kowey> ah yes! that sounds a lot more like what I want
13:41:56 <lispy> "A stable pointer is a reference to a Haskell expression that is guaranteed not to be affected by garbage collection, i.e., it will neither be deallocated nor will the value of the stable pointer itself change during garbage collection (ordinary references may be relocated during garbage collection). Consequently, stable pointers can be passed to foreign code, which can treat it as an opaque reference to a Haskell value."
13:42:01 <kowey> ok, so Ptr, ForeignPtr and StablePtr
13:42:11 <kowey> the latter being for handing my stuff to foreign code
13:42:25 <lispy> kowey: So, do you want to pass the application state so it can be modified in CL?
13:42:31 <Berengal> StablePtr == reverse ForeignPtr ?
13:42:33 <lispy> kowey: if so, I would take a different route.
13:42:34 <burp> http://joyridelabs.de/game/ a real game written in haskell!
13:42:49 <kowey> nah, I just want to give them some sort of handle to it
13:42:53 <kowey> I'll modify it myself
13:43:04 <kowey> they just have to call "init" and "run" basically
13:43:15 <lispy> kowey: in that case, I would marshal the bits into a C Struct.  Haskell doesn't need to know about CL.  Then I would make an FFI binding from CL to that C struct.
13:43:27 <lispy> kowey: ah
13:43:32 <lispy> kowey: so StablePtr should be perfect
13:43:44 <Berengal> burp: Release TBA. Not real yet
13:43:52 <kowey> I'll start there... seems like the minimal effort approach
13:44:25 <burp> Berengal: you can download the source and alpha binaries
13:44:29 <burp> so it's real for me
13:44:33 * Berengal didn't see that
13:44:43 <burp> http://updates.joyridelabs.de/nikki/current/linux/i386/nikki.tar.gz http://updates.joyridelabs.de/nikki/current/linux/x86_64/nikki.tar.gz  http://joyridelabs.de/game/code/
13:45:06 <burp> it even uses darcs for source code versioning :D
13:49:20 <Berengal> burp: Cute :)
13:54:14 <burp> http://code.joyridelabs.de/docs/nikki/html/nikki/nikki/
13:54:21 <burp> very nice to see some "real" game written in haskell
13:54:56 <Twey> @hoogle Monad m => m b -> (b -> m a) -> m b
13:54:57 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:54:57 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:54:57 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:55:07 <dolio> Needs more nikki in the url.
13:55:13 <Twey> That's not right
13:55:50 <Twey> Is there a standard function such that ‘f a f' = do v <- a; f' v; return v’?
13:56:31 <dolio> I don't think so.
13:56:40 <Twey> a >>= liftM2 (>>) f' return
13:56:41 <Twey> Hm
13:56:44 <Twey> It's a pattern I encounter a lot
13:56:48 <mauke> :t \a f' -> do v <- a; f' v; return v
13:56:49 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> (b -> m a) -> m b
13:56:58 <Twey> mauke: See above
13:57:01 <mauke> yeah
13:57:08 <rostayob> Twey: liftM
13:57:11 <dolio> There's almost one.
13:57:14 <Twey> :t liftM
13:57:15 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:57:21 <rostayob> ah no sorry ehe
13:57:23 <dolio> :t (<*)
13:57:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:57:25 <Twey> Aha
13:57:28 <Twey> flip liftM?
13:57:32 <mauke> @. pl undo \a f' -> do v <- a; f' v; return v
13:57:32 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
13:57:38 <olsner> :t const `asTypeOf` \a f' -> do v <- a; f' v; return v
13:57:39 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> (b -> m a) -> m b
13:57:46 <Twey> Uck, @pl
13:57:59 <Twey> :t a >>= liftM2 (>>) f' return
13:57:59 <lambdabot> Not in scope: `f''
13:58:02 <Twey> Er
13:58:14 <Twey> :t \a f' -> a >>= liftM2 (>>) f' return
13:58:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> (b -> m a) -> m b
13:58:40 <Twey> :t (>>= flip (liftM2 (>>)) return)
13:58:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (b -> b -> m a) -> b -> m b
13:58:49 <Twey> Hm, oops — broke it
14:00:03 <Twey> flip fmap (flip (liftM2 (>>)) return) . (>>=)
14:00:11 <rostayob> @pl \a f' -> a >>= \v -> liftM id (f' v)
14:00:11 <lambdabot> (>>=)
14:00:11 <Twey> But yeah
14:00:14 <rostayob> lol wait
14:00:33 <xplat> @tell Peaker http://hpaste.org/45385/linear__lazier_reverse
14:00:33 <lambdabot> Consider it noted.
14:00:58 <dmwit> liftM id === id
14:01:38 <aristid> xplat: and it works on infinite lists?
14:01:45 <aristid> xplat: if so, you get the GOLD BADGE.
14:01:59 <aristid> where's geheimdienst when you need him?
14:02:06 <xplat> aristid: it 'works' as in 'meets the spec'
14:02:25 <xplat> aristid: the one given in the paste, that is
14:03:06 <aristid> xplat: as long as foldr (\_ _ -> 1) 0 (lreverse [1..]) == 1 :)
14:03:21 <rostayob> @pl \a f -> a >>= (\v -> f v >> return v)
14:03:21 <lambdabot> (. flip (liftM2 (>>)) return) . (>>=)
14:03:40 <rostayob> Twey: it's strange that it's so ackward to do it actually
14:04:03 <xplat> rostayob: Twey: to do what?
14:04:15 <rostayob> xplat: \a f -> a >>= (\v -> f v >> return v)
14:04:19 <Twey> rostayob: Well done — you just got @pl to output what I posted five minutes ago ;)
14:04:29 <kowey> lispy: hmm! that was suspiciously easy: http://hpaste.org/45386/my_first_ffi_usage_sniff
14:04:30 <rostayob> Twey: yeah exactly.. just wanted to make sure
14:04:31 <bss03> @hoogle m a -> (a -> m b) -> m a
14:04:31 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:04:31 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:04:31 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:04:40 <kowey> now to see if I can get a simple C wrapper to talk to this
14:04:43 <rostayob> bss03: the last one is m b
14:04:44 <mauke> rostayob: I already use @pl on that
14:04:45 <Twey> rostayob: Which bit is awkward?
14:04:51 <dmwit> Twey: Huh, yeah, I've used that a few times, as well.
14:04:52 <Twey> Just the fact that it doesn't @pl very nicely?
14:04:58 <bss03> I'm not looking for >>=
14:05:01 <rostayob> Twey: yeah
14:05:07 <Twey> Lots of functions don't
14:05:15 <rostayob> @hoogle m a -> (a -> m b) -> m b
14:05:15 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:05:15 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:05:15 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:05:22 <bss03> I'm looking for something to replace do { x' <- x; y; return x' }.
14:05:24 <rostayob> oh right
14:05:26 <Twey> If they all did, I imagine we would do away with named parameters and scope altogether :þ
14:05:36 <kowey> (not pasting that for any reason, just a five year old showing his drawing)
14:05:36 <mikeg> @djinn m a -> (a -> m b) -> m a
14:05:36 <lambdabot> f a _ = a
14:05:44 <rostayob> Twey: no but that seems like something that you would do often as you said
14:05:59 <Twey> rostayob: That doesn't have much bearing on how easily it @pl's
14:06:03 <bss03> x and y are of type CharParser st a
14:06:13 <Twey> You could probably come up with some combinators to make it nicer
14:06:24 <rostayob> Twey: no no I mean I'd expect to have a function to do that
14:06:36 <Twey> Oh, right
14:06:39 <Twey> Yes, indeed
14:06:51 <dmwit> bss03: We are in the process of lamenting the fact that such a combinator doesn't exist.
14:07:04 <xplat> Twey: sort of a 'fluent bind' then
14:07:08 <Twey> I've implemented it a couple of times now, but it feels like it should be in the standard libraries somewhere
14:07:11 <dmwit> bss03: (In case you weren't following along.)
14:07:17 <bss03> Oh, really?  I came to fix my problem.
14:07:18 <bss03> :P
14:07:20 <Twey> Haha
14:07:30 <Twey> Did bss03 just stumble onto it at exactly the same time?
14:07:36 <Twey> Nice
14:07:45 <bss03> I wrote my first non-trivial Parsec stuff today.
14:08:12 <Twey> dmwit: How does one go about getting a function into Control.Monad?  :þ
14:08:17 <xplat> bss03's problem is very slightly different
14:08:23 <mauke> bss03: <*
14:08:27 <dmwit> Twey: Send a patch to libraries@, I guess.
14:08:33 <bss03> :t (<*)
14:08:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:09:12 <Twey> Yes, bss03's y doesn't refer to x'
14:09:16 <dmead> :t unsafePerformIO
14:09:16 <lambdabot> Not in scope: `unsafePerformIO'
14:09:27 <dmead> holy camel case batman
14:09:30 <bss03> mauke: Yeah, that works for me.  I was just thinking about Monad, not Applicative...
14:09:34 <dmead> @hoogle unsafeperformIO
14:09:34 <lambdabot> Foreign unsafePerformIO :: IO a -> a
14:09:34 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
14:10:05 <Twey> And what do you suggest it be called?
14:10:09 <Twey> I named it ‘driveby’ :þ
14:10:58 <bss03> :t (=>>)
14:10:58 <lambdabot> Not in scope: `=>>'
14:11:08 <bss03> I think =>> makes a good name.
14:11:22 <mauke> I think << is better
14:11:36 <bss03> '>>=' = bind, use right value; '=>>' = bind, use left value.
14:12:17 <Twey> Why <<?
14:12:23 <Berengal> @type (<*)
14:12:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:12:26 <bss03> mauke: I'd expect: << = flip >>
14:12:27 <Twey> Surely (<<) = flip (>>)
14:12:29 <frerich_> Hm is there a nicer way to write 'sortBy (\x y -> compare (snd x) (snd y))'? 
14:12:29 <Twey> Right
14:12:39 <Twey> frerich_: sortBy (comparing snd)
14:12:42 <dmwit> :t comparing
14:12:43 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:12:45 <mauke> Twey: no
14:12:59 <bss03> sortBy (on snd), I think.
14:13:00 <mauke> (<<) = (<*) but with its type restricted to monads
14:13:04 <bss03> :t on
14:13:04 <magicman> sortBy (comparing snd), sortBy (compare `on` snd)
14:13:04 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:13:12 <mauke> but apparently I'm the only one who thinks so
14:13:16 <Berengal> mauke: Breaks with the already existing =<< and <=<
14:13:17 <Twey> :t \x y -> compare (snd x) (snd y)
14:13:18 <lambdabot> forall a a1 b. (Ord b) => (a, b) -> (a1, b) -> Ordering
14:13:23 <Twey> :t comparing snd
14:13:24 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
14:13:32 <Berengal> mauke: If it weren't for those two, I'd be with you
14:13:33 <mauke> Berengal: I don't care about those
14:13:43 <Twey> Restricts the type somewhat
14:13:45 <dmwit> Twey: sortBy already makes that typing restriction, anyway.
14:13:49 <Twey> Ah, right
14:13:52 <Twey> So it's fine
14:13:56 <c_wraith> I think <* is fine, though.  If something's not an instance of Applicative, complain
14:14:09 <Twey> c_wraith: Aye
14:14:18 <frerich_> You people are too bloody fast, let me digest the last 20 lines of chat... :-}
14:14:47 <Berengal> mauke: I do care about those, because we don't need any useless details like which function performs effects in what direction
14:15:06 <Berengal> mauke: Right now, monad functions pointing left do effects in right-to-left fashion
14:15:18 <mauke> not a problem, I always perform effects left-to-right
14:15:29 <bss03> Well, (=>>) would have a different type than (<*), because second argument would be (a -> m b), not (m b).
14:18:01 <frerich_> Cool, 'comparing' seems perfect. It even gives sortBy as a use case. Only downside is that it's almost impossible to find documentation (I wanted to know what module it's in) for this function using Google. Hoogle to the rescue.
14:18:31 <xplat> flip (>>=) . flip (liftM2 (>>)) return
14:19:18 <Eelis> :t comparing
14:19:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:20:45 <KSkrzet> frerich_: I found Google to perform rather poorly with variety of programming languages when it comes to API search, which is sad
14:21:24 <frerich_> It works okayish for C/C++ for me. I just tack on 'man page' for POSIX stuff and 'function' for Windows API. But 'haskell function comparing' worked out very badly :}
14:21:26 <KSkrzet> frerich_: I don't know if you know, but you can actually install Hoogle locally and add all your installed packages to the database
14:21:27 <dmwit> Is there a variant of sortBy with the type (Ord a) => (b -> a) -> [b] -> [b]?
14:21:48 <xplat> flip (>>=) . liftM2 (<*) pure
14:22:02 <dmwit> :t \f -> map fst . sortBy (comparing snd) . map (id *** f) -- yes, I know I can write it myself
14:22:03 <lambdabot> forall b b1 b'. (Ord b) => (b' -> b) -> [(b1, b')] -> [b1]
14:22:08 <frerich_> KSkrzet: No, didn't know that, ounds useful
14:22:21 <dmwit> :t \f -> map fst . sortBy (comparing snd) . map (id &&& f) -- but, I often write bugs =P
14:22:21 <lambdabot> forall b a. (Ord b) => (a -> b) -> [a] -> [a]
14:22:27 <tromp_> http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/April2011.html should be easy to do in haskell
14:22:38 <Saizan> dmwit: someone suggested it with the name sortOn
14:23:45 <KSkrzet> frerich_: It is faster than the public service, and you have control over the packages it searches, which is useful.
14:24:19 <frerich_> KSkrzet: It sounds like something which would be really useful in combination with some editor shortcut (vim in my case)
14:24:30 <revenantphx> burp: really, haha?
14:24:37 <revenantphx> burp: i am interested now
14:25:35 <xplat> Twey: flip (>>=) . liftM2 (<*) pure
14:25:36 <frerich_> KSkrzet: Like, 'K' in vim opens the man page for the word under the cursor.
14:25:52 <Twey> :t flip (>>=) . liftM2 (<*) pure
14:25:53 <lambdabot> forall (m :: * -> *) b b1. (Monad m, Applicative m) => (b -> m b1) -> m b -> m b
14:25:56 <Twey> xplat: Cute
14:26:12 <KSkrzet> frerich_: I think there is such functionality in Emacs which I use :-) however I prefer to have docs open on another monitor 
14:26:40 <KSkrzet> frerich_: see here for how to make Hoogle databases: http://www.haskell.org/haskellwiki/Hoogle#Database_Creation
14:27:24 <xplat> Twey: better yet: (=<<) . liftM2 (<*) pure
14:27:27 <frerich_> KSkrzet: Nice, thanks for the pointer!
14:27:30 <revenantphx> and all of a sudden I remember why darcs is infeasible to use as it is....
14:27:33 <revenantphx> so…. slow....
14:27:56 <lispy> revenantphx: are you using a recent darcs with a darcs1-hashed or a darcs2 formatted repo?
14:28:02 <revenantphx> don recal
14:28:06 <revenantphx> not sure
14:28:23 <KSkrzet> dmwit: http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html#v:sortWith
14:28:34 <lispy> revenantphx: darcs --version and darcs show repoformat :)
14:28:36 <KSkrzet> dmwit: sortWith :: (Ord a) => (b -> a) -> [b] -> [b]
14:28:58 <xplat> this hoogle thing brings up a question that confuses me
14:29:01 <dmwit> KSkrzet: Of course! Why didn't I think to look in the GHC source for such a function?
14:29:04 <lispy> revenantphx: sorry, darcs show repo
14:29:04 <dmwit> =P
14:29:21 <revenantphx> darcs-2 hashed
14:29:30 <xplat> why do haskellers have to live with tool envy toward anyone, even java-ists?
14:29:39 <lispy> revenantphx: :(
14:29:43 <dmwit> KSkrzet: Also, that doesn't memoize results of the comparison function.
14:29:48 <dmwit> KSkrzet: So it's not what I want.
14:29:54 <revenantphx> anyways
14:29:56 <lispy> revenantphx: if it's a recent darcs (2.4.4 or 2.5) then it should be fast
14:30:08 <dolio> What tool envy do we have?
14:30:08 <lispy> revenantphx: but, you may be hitting a case where darcs is just still slow
14:30:16 <revenantphx> 2.5, but okay
14:30:19 <revenantphx> it doesn't matter
14:30:21 <xplat> haskell has been stable and analyzable, and there are lots of really awesome tools -- things like ghc-core, threadscope, hoogle, djinn ...
14:30:21 <revenantphx> i have patience
14:31:07 <xplat> but nobody has really brought all these tools together in a way that they can be used fluently in a single environment
14:31:31 <revenantphx> xplat: anyone smart enough to use haskell is smart enough to not really care for a giant IDE monster
14:31:39 <revenantphx> :P
14:31:41 <KSkrzet> xplat: maybe time to make Haskell Developer Live CD?
14:31:42 <xplat> leksah should be that, but it seems that it is not
14:32:00 <argiopeweb> I'm reading through "Learn you a Haskell for Great Good" just for the hell of it, and it brought up an interesting point. Why isn't length declared as Num b => [a] -> b, or at least Integral b => [a] -> b?
14:32:06 <Heffalump> xplat: I have tool envy for languages with stack traces.
14:32:14 <dmwit> :t genericLength
14:32:14 <lambdabot> forall b i. (Num i) => [b] -> i
14:32:14 <revenantphx> :t length
14:32:15 <lambdabot> forall a. [a] -> Int
14:32:22 <dafis> argiopeweb: efficiency
14:32:24 <dmwit> argiopeweb: Premature optimization during language design.
14:32:24 <revenantphx> argiopeweb: ^
14:32:35 <xplat> Heffalump: those are convenient, but it seems like first you have to have a stack :(
14:32:37 <argiopeweb> Well, that explains many things. XD
14:34:05 <Saizan> genericLength is not suitable for Int, btw
14:34:19 <dafis> Saizan: there's a rule
14:34:31 <xplat> i mean, you could have a 'supplied arguments' trace, but that could branch
14:34:46 <dafis> if you compile with -O, you should get fast genericLength for Int and Integer results
14:34:48 <aristid> Saizan: it isn't?
14:34:55 <xplat> so it would be more of a treece
14:35:03 <dafis> @src genericLength
14:35:04 <lambdabot> genericLength []    = 0
14:35:04 <lambdabot> genericLength (_:l) = 1 + genericLength l
14:35:12 <dafis> aristid: ^^
14:35:24 <aristid> dafis: that isn't the actual implementation :)
14:35:36 <KSkrzet> this is offtopic: does anyone know Linux tool for converting file *name* locales in similar way iconv does convert the file contents?
14:36:20 <Saizan> aristid: it is, except for RULES
14:36:21 <xplat> KSkrzet: um ... iconv?
14:36:38 <aristid> Saizan: if the RULES make it work for Int, then it works for Int :)
14:36:43 <KSkrzet> xplat: iconv can do that? I was pretty sure there was a separate tool for that...
14:36:46 <aristid> ("works" as in "is fast")
14:36:58 <dafis> aristid: actually, it is, there are just rules for Int and Integer
14:36:59 <ion> convmv
14:37:04 <xplat> KSkrzet: names are just text, aren't they?
14:37:14 <Saizan> aristid: it's not suitable for Double then
14:37:24 <KSkrzet> ion: ah, thank you
14:37:38 <aristid> Saizan: because of its lack of strictness?
14:37:43 <xplat> KSkrzet: oh, you wanted to convert the file names and rename the files.  that's different.
14:37:48 <bss03> for f in name; do mv "$f" "$(iconv -f foo -t bar <<< "$f")"; done
14:37:50 <Heffalump> xplat: ok, then I have stack envy
14:37:53 <Saizan> aristid: or if there isn't enough inlining to make the Int/Integer rules fire
14:37:56 <bss03> KSkrzet: ^^ ?
14:38:04 <dafis> Saizan, aristid nor for Word
14:38:05 <Saizan> aristid: because it's not tail recursive
14:38:18 <KSkrzet> bss03: well, I dont trust shell
14:38:19 <bss03> That's got bashisms, but it should be close to what you need.
14:38:40 <aristid> Saizan: well, the implementation could be tail recursive if not for potential strictness problems :)
14:38:49 <bss03> KSkrzet, ah.  Hrm, white a C function that does the same thing then.
14:38:54 <KSkrzet> bss03: especially the scripts I write :-)
14:39:27 <dafis> aristid: a tail recursive definition would be bad for lazy number types
14:39:28 <KSkrzet> bss03: actually Haskell is pretty well suited to writing such stuff in convienient way, strong typing really helps here
14:39:44 <bss03> Heck, use Haskell maybe.  I'm not sure how GHC maps FilePaths to char * though...
14:39:52 <Saizan> aristid: for Int the strictness is the same, and it's hard to discuss the strictness of a function uniformly when there's ad-hoc polymorphism involved
14:40:07 <KSkrzet> bss03: there is posix-bytestring or smth in Hackage
14:40:12 <Saizan> aristid: but yeah, there isn't one implementation that would fit all Nums
14:40:25 <bss03> It might always do a UTF-8 conversion or something.
14:41:16 <bss03> KSkrzet: Sounds like you have a good idea how to write it -- but I don't know a pre-made tool for doing the renames.
14:41:22 <aristid> Saizan: there could be a strictLength function for strict Nums :)
14:42:14 <KSkrzet> bss03: ion has said, convmv is the tool. I can write it but it won't be tested right after being written, so not really ready to use in "production"
14:43:59 <Saizan> aristid: i'd rather have that called length and have a lazyLength
14:44:39 <Saizan> aristid: to not repeat the foldl/sum/product issue
14:44:54 <aristid> Saizan: well...
14:45:10 <sm> xplat: it's because guis are still hard :(
14:46:04 <Saizan> as much i like peano naturals they aren't the most common use case by far
14:46:37 <xplat> sm: so if Reactive actually worked the first time, we'd be pointing and laughing at piddling pico clones like IDEA? :)
14:46:38 <dafis> pretty rare, I think
14:47:01 <conal> though if your GUI is just an interface to a pure value, including functions, TV is pretty darn simple.
14:47:07 <xplat> sm: or is it more abstract hardness?
14:47:10 <Saizan> they'd be cute for "lazyLength xs < 3" sort of things though
14:47:25 <sm> xplat: yeah, if any gui lib was available that let you easily build gui apps that just worked for everyone, we'd be seeing massive ide innovations like you get in smalltalk
14:47:33 <aristid> Saizan: if lazyLength would default to a lazy type :)
14:47:41 <xplat> Saizan: i just used the peano naturals today though :)
14:47:42 <conal> *and* composable, unlike most GUIs.
14:47:56 <Saizan> xplat: for that lazy foldl?:)
14:48:15 <sm> I'm talking more about deployability and cross-platform considerations. But true, haskellers' disdain for imperative gui code may be a factor
14:48:28 <xplat> Saizan: yes, it has to measure length in a lazy way
14:48:59 <sm> having said that, emacs is a popular enough platform that "bringing all these tools together in a way that they can be used fluently in a single environment" would make sense there too
14:49:18 <Saizan> xplat: did you get to a conclusion of whether it's really O(n)?
14:49:31 <xplat> haskell-mode does let you use hoogle internally, but not much else
14:49:32 <sm> like the recent scheme ide project
14:50:13 <rostayob> it seems I can't generate a pattern with template haskell, like case foo of $(whatever) -> ...
14:50:24 <rostayob> why's that?
14:50:29 <dmead> is there a way to tell ghci to close all file handles?
14:50:35 <dmead> i opened a handle in some code, and didn't close it
14:50:38 <dmead> and i'm not sure how to unlock it
14:50:47 <hpc> dmead: restart ghci
14:50:56 <dmead> tried that
14:51:05 <hpc> then..
14:51:07 <xplat> Saizan: i've decided to leave the paste for people to poke holes in, because it seems to scale worse than i expect but every time i check how many times things are evaluated with trace it's linear, and i'm not invested enough in the bragging rights to profile
14:51:12 <hpc> do something else :P
14:51:18 <hpc> (that should have fixed it)
14:51:22 <osoleve> dmead: check in /var/lock ?
14:51:34 <dafis> xplat: url of paste?
14:51:42 <xplat> http://hpaste.org/45385/linear__lazier_reverse
14:51:49 <Saizan> rostayob: you'll find that TH is incomplete in some places :)
14:52:14 <dmead> osoleve: negative
14:52:17 <rostayob> Saizan: yeah but why that? doesn't the preprocessor just execute the splices?
14:52:21 <xplat> the URI sounds a lot more certain than the actual title
14:52:53 <xplat> maybe i should have called it 'linear lazier reverse ... or is it?'
14:53:16 <dafis> xplat: yes, it's not quite trivial to place a question mark in an url, is it?
14:53:45 <osoleve> i wish i could learn haskell simply by writing stuff in it and figuring it out as i go, like i do in other languages
14:54:01 <mauke> you can
14:54:08 <dmead> osoleve: pretty sure thats what a repl is for
14:54:11 <osoleve> i'd have given up a while back if it wasn't such a damn attractive language
14:54:22 <KSkrzet> osoleve: what is holding you back then?
14:54:24 <Saizan> rostayob: it's not done at the textual level
14:54:38 <sm> xplat: http://www.nongnu.org/geiser/ is what I was thinking of (example of an integrated emacs ide project)
14:54:57 <osoleve> i don't know, i just... i want to understand most of the nooks and crannies i suppose
14:55:02 <sm> I like the quote: "Because i prefer growing and healing to poking at corpses..."
14:55:18 <sm> haskellers need a comeback for this :)
14:55:27 <rostayob> Saizan: fair enough
14:55:31 <ddarius> sm: Why?
14:56:47 <sm> well, read it in context.. static languages seem to be the "corpses"
14:57:21 <xplat> no, 'corpses' are core dumps or stack traces or profiles of code that has already run
14:57:41 <sm> more to the point, it would be cool to see a similar project for haskell, integrating and building on the existing bits xplat mentioned
14:58:41 <kowey> has anybody done this recently? http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/win32-dlls.html (making a Windows DLL of some Haskell code)
14:58:56 <xplat> (or piles of compiler errors when the code fails to compile)
15:00:28 <sm> kowey: I think jp moresmau blogged about it
15:00:38 <fryguybob> kowey: I have done it, but not terribly recently.
15:00:48 <sm> I'd find you a link if planet.haskell.org would grant me a response :/
15:01:10 <kowey> frguybob: was that with GHC 6.12 and up?
15:01:21 <fryguybob> yes
15:02:38 * sm is wrong
15:03:45 <kowey> fryguybob: thanks! glad to know it's doable in principle (I'm not on Windows, but one of my users wants to know)
15:04:45 <kowey> fryguybob: may I ask what the difference is between "building an entire Haskell application as a single DLL" and "multi-DLL Haskell programs"?
15:04:55 <kowey> sorry if that's a bit of a silly question
15:05:36 <xplat> sm: the quote mostly seems to be railing against a move from read-eval-print-alter-resume and edit-compile-run-autopsy-reedit
15:05:42 <xplat> *to
15:05:51 * ddarius ran out of Bacon Horseradish Heluva Good Sour Cream Dip.
15:06:03 <frerich_> As an exercise, I implemented a (slow, inefficienct, since list-based) Huffman encoder. I exercised various Haskell functions while doing so; it would be much appreciated if somebody with more experience could have a look at http://hpaste.org/45389/huffman_encoding_annotation and look for stupid things
15:06:18 <xplat> ddarius: in how many minutes?
15:06:21 <frerich_> I'm quite happy with how little code it takes
15:06:33 <fryguybob> kowey: I have only done the single dll thing.
15:07:12 <kowey> so I've got this package on hackage and a little 2 function wrapper around it exposing some functions via FFI
15:07:34 <kowey> that'd be me doing the single dll thing too, right?
15:07:47 <zenzike> I'm a bit confused: the documentation of ByteString seems to indicate that it uses an Int for splitAt, but ghc complains that it can't match expected type `GHC.Int.Int64` with actual type `Int`
15:07:53 <zenzike> am I missing some magic here?
15:08:04 <fryguybob> kowey: Yeah.  A dll that statically has all the haskell dependencies in it.
15:08:15 <mauke> zenzike: which ByteString are you using?
15:08:17 <kowey> oh, I can live wit that
15:08:28 <kowey> great! thanks for clarifying, fryguybob
15:08:41 <sm> zenzike: just a guess - stale .o files compiled on another architecture ?
15:08:50 <zenzike> mauke: Data.ByteString.Lazy.Char8, version 0.9.1.10
15:09:05 <dafis> zenzike: lazy ByteStrings use Int64
15:09:10 <sm> or installed cabal libs ?
15:09:12 <zenzike> dafis: ah, thanks
15:09:18 <mauke> zenzike: splitAt :: Int64 -> ByteString -> (ByteString, ByteString)
15:09:22 <sm> drat
15:09:24 <mauke> pasted from the documentation
15:10:08 <zenzike> oh dear, I must have been reading the Data.ByteString.Char8 docs :-$
15:10:24 <zenzike> thanks :-) at least that was quick to resolve!
15:11:04 <KSkrzet> does anyone know if SPECIALIZE against specific monad can increase function performance?
15:13:11 <xplat> KSkrzet: iirc attoparsec specializes some generic monadic and applicative combinators against specific (or more specific) types
15:14:30 <xplat> attoparsec's author tends not to just optimize aimlessly, so that would indicate to me that it can help
15:15:33 <KSkrzet> xplat: thanks, I'll try to see if it'll make a difference in my code then
15:16:08 <Apocalisp> OK, so Cont is defined as: newtype Cont r a = Cont { runCont :: (a -> r) -> r }
15:16:20 <Apocalisp> Is there a reason it couldn't be: newtype Cont a = Cont { runCont :: forall r. (a -> r) -> r } ?
15:16:44 <Saizan> Apocalisp: try writing callCC with that
15:16:55 <Apocalisp> alright
15:20:36 <sm> HDBC-postgresql requires a program "pgconfig" that's not packaged for ubuntu.. is that right ?
15:21:06 <hpc> sm: don't think so; i could get that package from apt just fine
15:21:20 <hpc> (hdbc-postgresql, dunno about pgconfig)
15:21:57 <Saizan> frerich_: codeFromTree could be much lazier, i think
15:22:04 <sm> did you mean apt there ? I'm doing cabal install HDBC-postgresql
15:22:21 <hpc> :t callCC
15:22:22 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:22:28 <sm> and getting "setup: The program pgconfig is required but it could not be found."
15:22:44 <aristid> @instances MonadCont
15:22:45 <lambdabot> ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
15:22:55 <hpc> @src callCC
15:22:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:23:29 <sm> oh, I need the postgresql dev package. Not sure what this "pgconfig" is
15:23:41 <hpc> postgres config, i would assume
15:23:50 <hpc> if it is necessary, it will install with postgres
15:23:51 <frerich_> Saizan: What do you mean with 'lazier'?
15:25:20 <tromp_> :t not
15:25:21 <lambdabot> Bool -> Bool
15:25:33 <Saizan> frerich_: ah, before that, codes is always passed immutated to recursive calls of go, so it's not really doing anything
15:26:21 <Saizan> frerich_: and you end up with some left-associated (++) which is bad for performance
15:26:45 <frerich_> Saizan: Yes, that part is ugly :-/
15:27:19 <sm> it's a misleading distro-specific name I suspect
15:27:58 <Saizan> frerich_: better like this http://hpaste.org/paste/45389/huffman_encoding_annotation#p45390
15:28:12 <sm> would anyone know which of these postgres -dev packages I need to build HDBC-postgresql ? I've been trying to avoid the distro haskell packages completely, but I think one of those is what I need
15:29:08 <ddarius> @src callCC Cont
15:29:08 <lambdabot> Source not found. I feel much better now.
15:29:11 <ddarius> @src Cont callCC
15:29:12 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
15:29:20 * ddarius never remembers the order for that.
15:29:21 <hpc> @src State callCC
15:29:21 <lambdabot> Source not found. You speak an infinite deal of nothing
15:29:28 <frerich_> Saizan: Err, let me grok that... I don't think I ever saw a partial application of ':' before :-}
15:29:28 <hpc> @src StateT callCC
15:29:28 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:29:31 <hpc> hmm
15:29:47 <aristid> hpc: it got a MonadCont constraint on the inner monad
15:29:49 <sm> aha.. libpq-dev, containing /usr/bin/pg_config
15:29:50 <aristid> so it's rather boring
15:30:03 <hpc> oh, boring
15:31:47 <geheimdienst> sm: i googled and this came up: http://www.alsonkemp.com/haskell/cabal-install-is-awesome/ the guy had the same error "pgconfig is missing" and seems to have solved it by doing "apt-get postgresql-server-dev-<version>" ...
15:32:24 <sm> geheimdienst: thanks. I saw that too, libpq-dev worked for me
15:32:32 <frerich_> Saizan: That's a really cool idea. So instead of having 'go' yield a list, it actually returns a function and the returned functions just prepend the values to the result list.
15:32:40 <frerich_> Saizan: I don't think I'd ever have though of that :-)
15:32:51 <sm> I think HDBC-postgresql mispells it, I'm just filing a bug report
15:32:59 <Saizan> frerich_: exactly :)
15:33:15 <hpc> sm: lol
15:33:21 <Saizan> frerich_: it's a common trick, used even in the Show class
15:33:52 <sm> you think it's funny ? I should have had to spend time hunting for this :)
15:34:02 <sm> shouldn't. 
15:35:37 <Saizan> frerich_: http://hpaste.org/paste/45389/huffman_encoding_annotation#p45391 <- another version, avoiding the currentCode accumulator, though i'm not sure if it's better
15:35:50 <tromp_> @pl \l -> ['0':l,'1':l]
15:35:50 <lambdabot> liftM2 (:) ('0' :) (return . ('1' :))
15:37:02 <geheimdienst> sm: i agree, it's pretty unfortunate that so much guesswork is needed for installing the c side of many c/haskell bindings
15:37:47 <shachaf> tromp_: sequence [('0':),('1':)]
15:38:15 <frerich_> Saizan: Hm isn't this nice trick you did with 'go' basically a foldr?
15:38:28 <frerich_> Saizan: Hm, no
15:38:45 <sm> yes indeed, I really look forward to having those be communicated consistently by hackage pages and cabal messages
15:38:49 <frerich_> Saizan: I guess the 'do two steps at once' part for 'Tree' values doesn't fit the foldr scheme.
15:39:07 <sm> a lot of hackage packages look cross-platform but really aren't
15:39:15 <frerich_> Saizan: Just this 'go(go(go(go [])))))' reminded me of foldr
15:39:16 <gio123> I need to write  N\sigma_1 + ... + N\sigma_n where \sigma_i \in S and for each i/=j sigma_i/=sigma_j and sigma_1...sigma_n are all elements of S 
15:39:19 <dmwit> :t flip map "01" . (:)
15:39:20 <lambdabot>     Couldn't match expected type `Char' against inferred type `[a]'
15:39:20 <lambdabot>       Expected type: a -> Char -> b
15:39:20 <lambdabot>       Inferred type: a -> [a] -> [a]
15:39:32 <dmwit> :t flip map "01" . flip (:)
15:39:33 <lambdabot> [Char] -> [[Char]]
15:39:34 <Saizan> frerich_: go could easily be rewritten with the corresponding fold function for Tree
15:39:38 <tromp_> >sequence [('0':),('1':)] "hi"
15:39:46 <tromp_> > sequence [('0':),('1':)] "hi"
15:39:47 <lambdabot>   ["0hi","1hi"]
15:39:58 <dmwit> > flip map "01" . flip (:) $ "hi"
15:40:00 <lambdabot>   ["0hi","1hi"]
15:40:15 <shachaf> > (sequence . map (:)) "01" "hi"
15:40:16 <lambdabot>   ["0hi","1hi"]
15:41:17 * shachaf curses his long nick.
15:41:35 <Saizan> frerich_: foldTree tree leaf (Leaf w e) = leaf w e; foldTree tree leaf (Tree l w r) = tree l w r
15:41:50 <tromp_> @pl \l -> l >>= (sequence . map (:)) "01" l
15:41:50 <lambdabot> ap (>>=) (sequence (map (:) "01"))
15:42:12 <Saizan> frerich_: foldTree tree leaf (Leaf w e) = leaf w e; foldTree tree leaf (Tree l w r) = tree (foldTree tree leaf l) w (foldTree tree leaf r) -- actually
15:42:18 <geheimdienst> sm, just double-checking: are we both talking about the package hsql-postgresql version 1.8.1? i'm looking at its source and it seems to search for pg_config, not pgconfig
15:42:21 <ion> > (:) <$> "01" <*> ["hi"]
15:42:22 <lambdabot>   ["0hi","1hi"]
15:42:25 <dmwit> tromp_: Uh... that doesn't have the type you think it has, I bet.
15:42:53 <geheimdienst> i can't find a "pgconfig" in ubuntu packages, but pg_config is there: http://packages.ubuntu.com/search?searchon=contents&keywords=pg_config&mode=exactfilename&suite=maverick&arch=any
15:43:00 <dmwit> :t \l -> l >>= (sequence . map (:)) "01" l
15:43:01 <lambdabot>     Couldn't match expected type `a -> m b'
15:43:01 <lambdabot>            against inferred type `[a1]'
15:43:01 <lambdabot>     In the first argument of `(.)', namely `sequence'
15:43:27 <sm> geheimdienst: I was installing HDBC-postgresql-2.2.3.3 .. see https://github.com/jgoerzen/hdbc/issues#issue/5
15:43:34 <shachaf> @pl \x -> x x
15:43:34 <lambdabot> join id
15:44:10 <tromp_> i'm trying to write a functoin to test if a snake sel-intersects
15:44:24 <tromp_> where a snake is a list of turns which are either +i or -i
15:45:08 <osoleve> that sounds like a genuinely interesting problem
15:46:12 <adlsaks> as in, you're writing a snake-like game 
15:46:18 <adlsaks> ?
15:46:18 <sm> woops.. killed my vps by linking a small haskell program. I hate that
15:46:21 <tromp_> @let disjoint = not . elem 0 . scanl1(+) . scanl(*)1
15:46:22 <lambdabot>  Defined.
15:46:32 <tromp_> @let left  = 0 :+ 1
15:46:33 <lambdabot>  Defined.
15:46:39 <tromp_> @let right = 0 :+ (-1)
15:46:40 <lambdabot>  Defined.
15:46:46 <ion> > (<$> "01") . flip (:) $ "hi"
15:46:46 * ddarius makes a non-intersecting space-filling curve.
15:46:48 <lambdabot>   ["0hi","1hi"]
15:46:50 <tromp_> > disjoint [left,left,left]
15:46:50 <monochrom> you have to translate "turns" into "positions"
15:46:51 <lambdabot>   Ambiguous occurrence `left'
15:46:51 <lambdabot>  It could refer to either `L.left', defined at ...
15:47:13 <esotericbyte> i am wondering if I should learn Haskell. I currently find that i am most productive using python. That is over java c or lisp. Does Haskell boost productivity, elegance both ? Are there specific things you pull it out for ? Like AI ? 
15:47:30 <tromp_> @let ext l = filter disjoint (map (:l) [left,right])
15:47:30 <lambdabot>  <local>:10:35:
15:47:31 <lambdabot>      Ambiguous occurrence `left'
15:47:31 <lambdabot>      It could refer to eithe...
15:48:05 <tromp_> @let lft  = 0 :+ 1
15:48:06 <lambdabot>  Defined.
15:48:08 <sm> esotericbyte: haskell boosts reliability and clarity of code, for one
15:48:19 <tromp_> @let ext l = filter disjoint (map (:l) [lft,right])
15:48:19 <dafis> ddarius: space-filling as in surjective, or space-filling as in positive area?
15:48:19 <lambdabot>  <local>:11:39:
15:48:19 <lambdabot>      Ambiguous occurrence `right'
15:48:19 <lambdabot>      It could refer to eith...
15:48:30 <tromp_> @let rgt = 0 :+ (-1)
15:48:30 <sm> so you might pull it out when you need to really trust something
15:48:31 <lambdabot>  Defined.
15:48:34 <tromp_> @let ext l = filter disjoint (map (:l) [lft,rgtt])
15:48:34 <ddarius> esotericbyte: Why did you learn Python?  Presumably one of or some combination of Java, C, or Lisp met your needs before Python.
15:48:35 <lambdabot>  <local>:12:39: Not in scope: `rgtt'
15:48:37 <ddarius> dafis: Both.
15:48:42 <tromp_> @let ext l = filter disjoint (map (:l) [lft,rgt])
15:48:43 <lambdabot>  Defined.
15:49:00 <tromp_> @let snakes = iterate (>>= ext) http://en.wikipedia.org/wiki/Special:Search?go=Go&search=lft
15:49:00 <lambdabot>   Parse error: =
15:49:06 <sm> esotericbyte: or when you've fixed one python runtime error too many
15:49:23 <dafis> ddarius: surjective and non-intersecting is impossible
15:49:40 <ddarius> dafis: Says you.
15:49:49 <tromp_> hmm, why parse error?
15:49:51 <dafis> ddarius: says topology
15:50:02 <esotericbyte> I want to develop a data flow based system composed of nodes which are process / thread pools serving a queue and a flow of chunks of data commonly called information packets. Nodes must run on embedded modules and the commercial viability of the system depends on keeping the cost of the modules low.
15:50:14 <ddarius> dafis: I never believed in uncountable infinities anyway.
15:50:41 <dafis> ddarius: I (or S) is compact, any continuous injective map from a compact (Hausdorff) space is a homoeomorphism
15:50:52 <hpc> ddarius: "i never believed in irrationals anyway"
15:50:59 <hpc> "i never believed in zero anyway"
15:51:03 <hpc> ;)
15:51:07 <ddarius> hpc: I believe in some of the irrationals.
15:51:17 <ddarius> Just a set of measure zero of them.
15:51:52 <esotericbyte> ddarius: Python is better than the above for 90% but not for embeded applciations and not for data flow based programing. there is a very small community but the problem is the global interprerter lock forces use of full processes a stack copy rather than threads. There is also stackless python for some instances of this problem but that comes with other issues.
15:51:53 <geheimdienst> sm: so i'm looking at the source of hdbc-postgresql, and it appears to be checking for both pgconfig and pg_config (at least if the code does what it seems)
15:51:54 <dafis> ddarius: counting measure on rationals?
15:52:36 <dmwit> esotericbyte: Haskell is good when you want to write a quick script, but get good guarantees and good speed.
15:52:52 <dmwit> esotericbyte: Haskell is good when you want lots of concurrency or parallelism.
15:52:52 <niteria> that's nice, because if you sum rationals and irrationals you get a set with measure 0
15:53:13 <niteria> which is even nicer, because [0-1] has 0 measure
15:53:20 <sm> geheimdienst: that sounds good, the problem is the error message it gave.. if it said "could not find pgconfig or pg_config", that would help
15:53:24 <dmwit> esotericbyte: Haskell is good when you want to write a one-off that doesn't crash, even the first time you run it.
15:53:36 <geheimdienst> sm: absolutely right
15:54:02 <blackdog> esotericbyte: Haskell is good if you want to go without the easy-to-use libraries common to perl/ruby/python.
15:54:17 <geheimdienst> esotericbyte: i can only tell you that i'm far from a master haskellite, but i prefer haskell to anything else because its compiler is so much more helpful. it's kinda hard to get anything to compile, but once it does, it rarely has bugs in it anymore
15:54:24 <esotericbyte> sm: Do you mean runtime errors because it's not strongly typed ?  I find that unit testing is not for python. 
15:54:26 <blackdog> (sorry, slightly narky today. shaved a lot of yaks to do something in haskell which would have been very quick to do in ruby)
15:54:27 <dmwit> esotericbyte: Haskell is also good if you want to write something math-inspired.
15:54:29 <Previous> Haskell has easy to use libraries, they're just for non-easy things. Like parsing. And category theory.
15:54:32 <geheimdienst> in python, i'd say there's no chance of getting anything right the first try. you always seem to have hours of painful testing to do
15:55:03 <ddarius> blackdog: Why didn't you use ruby?
15:55:13 <niteria> if types match it's probably what you mean ^^
15:55:16 <sm> esotericbyte: I don't understand your second sentence there, but yes. For me it was often dependency drift, apis breaking etc
15:55:26 <blackdog> ddarius: i didn't want the dependency.
15:55:32 <blackdog> ddarius: it's intended for use in haskell projects
15:55:51 <sm> haskell is not only a stronger language but has a stronger packaging system 
15:55:56 <ddarius> blackdog: Aren't you writing a ruby bridge anyway?
15:56:01 <blackdog> but at this point, i think my best bet is to do it in ruby, get the interface right, then write the libs to do it in haskell
15:56:03 <sm> strong in the "does not break" sense
15:56:10 <companion_cube> sm, i find cabal quite easy to break
15:56:18 <companion_cube> dependencies are sometimes too tight
15:56:24 <sm> oh sure, I mean.. after you get it built 
15:56:26 <blackdog> ddarius: yep. but pulling that in is a pretty big wodge of libraries too
15:57:24 <sm> I know these days I prefer tight dependencies that you have to explicitly relax, versus loose ones that mean you can't rely on your app running
15:57:37 <esotericbyte> geheimdienst: I see how not compileing.. .strong lint would be  a big plus. another plus is the that while object orientation serves a purpose it can be gratuitous where a purely functional approach could yield an elegant result.
15:57:40 <sm> in general
15:58:39 <blackdog> sm: still needs work on integrating something like cabal-dev into the main system
15:58:50 <blackdog> it's too easy to break stuff after the fact
15:58:57 <sm> you're right
15:59:30 <geheimdienst> esotericbyte: yes, the haskell compiler can be thought of as having a lint built in that is damn strong and possibly psychic
16:00:53 <sm> there are many angles to this, but overall I am just more confident that with haskell I can attain more robustness than with python or ruby
16:01:38 <Taslem> Is there a point-free way to write  (\a x -> x >> a x)  (\a x -> x >> a x)   ?
16:01:43 <esotericbyte> blackdog: i believe that Haskell is better than Erlang for my application because lib availability is better, it has a smaller runtime kernel and a larger and building community
16:02:32 <fryguybob> @pl (\a x -> x >> a x)  (\a x -> x >> a x) 
16:02:33 <lambdabot> ap (>>) (ap (>>))
16:02:37 <Previous> What is your problem? Do the difficult parts have to do with parallelism, robustness, and distribution?  Or just really complex code and algorithms.
16:02:37 <blackdog> esotericbyte: you could well be right (although we don't have OTP yet)
16:03:00 <esotericbyte> geheimdienst: i am thinking i will give it a trial run and see what it's like
16:03:10 <blackdog> i'm really just bitching about the lack of the easy libs to do stuff like scraping, RESTful interaction etc. the capabilities are all there, they're just not very polished or integrated
16:03:16 <sm> case in point, yesterday I needed a client for agilezen.com.. I saw the existing ruby one, it looked simpler to use so I squashed my haskell fanboy and tried, but it failed with some random error in a dependency. Back to haskell where this never happens.. er, wait..
16:03:32 <blackdog> and as bitching without work is masturbation, i guess it goes on the to-do list.
16:03:45 <esotericbyte> Ok so what about dataflow , queueing messages and the like in haskell can someone point me in the right direction ? 
16:03:45 <geheimdienst> esotericbyte: glad to hear it. check back here with any problems you run into. be sure to have a look at the LYAH tutorial
16:03:49 <geheimdienst> @where lyah
16:03:50 <lambdabot> http://www.learnyouahaskell.com/
16:06:28 <sm> esotericbyte: I know there's something better than this, but http://hackage.haskell.org/trac/ghc/wiki/ErlangInHaskell might be relevant
16:07:59 <Previous> sm, check the Cloud Haskell paper linked from r/haskell
16:08:12 <Previous> It's -very- promising-looking. I want the source :E
16:08:16 <ion> Indeed!
16:08:36 <ion> It speaks about sending a pong and responding to it with a ping, though. D-:
16:08:53 <Previous> Erlang still has hot code reloading and many years of production behind it, but I see this as an opportunity to get functional message passing -right-
16:10:12 <sm> nice
16:10:26 <thoughtpolice> Previous: https://github.com/jepst/CloudHaskell
16:10:31 <Previous> Yay!
16:17:02 <blackdog> ion: it's in the ReverseTime monad:)
16:19:36 <Taslem> When a call of forkIO raises an exception...  Will it stop the other threads too?
16:20:25 <hpc> Taslem: raises an uncaught exception?
16:20:27 <hpc> probably
16:20:34 <thoughtpolice> wait, forkIO raises an exception?
16:20:38 <ddarius> There's an easy way to find out.
16:20:43 <hpc> thoughtpolice: the forked thread can
16:20:46 <thoughtpolice> either way, if it's uncaught, it'll terminate everything.
16:20:51 <Taslem> Right.
16:21:35 <thoughtpolice> hpc: wait, do we mean can the spawned thread throw an exception? certainly it can, and that thread can catch it. i thought he was talking about forkIO *itself* throwing an exception, when you try to spawn a thread
16:21:54 <thoughtpolice> and that was confusing, because I was pretty sure forkIO doesn't throw an exception
16:21:56 <hpc> oh
16:22:28 <hpc> well if forkIO throws an exception, the parent thread would be the one to have to catch it
16:22:35 <hpc> which would be main, most likely
16:22:39 <thoughtpolice> right
16:22:57 <thoughtpolice> if the spawned thread throws an exception, it can catch it, not the main thread, but if it's uncaught, it'll terminate everything
16:23:05 <thoughtpolice> also, TIL when you forkIO a thread: "The newly created thread has an exception handler that discards the exceptions BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, and ThreadKilled, and passes all other exceptions to the uncaught exception handler (see setUncaughtExceptionHandler)."
16:25:02 <monochrom> what exception does forkIO throw?
16:25:24 <thoughtpolice> it doesn't, i was confused by wording
16:25:42 <Taslem> Writing servers/clients is a pain...
16:26:03 <monochrom> I mean apart from unfortunate coincidental async ones such as ThreadKilled
16:26:10 <Previous> Which is why the Cloud Haskell thing is so excitiiiing :D
16:26:17 <thoughtpolice> i was actually quite pleased how easy attoparsec + enumerator made it to write a simple client/server program with a custom protocol
16:26:28 <thoughtpolice> of course it's toy, but it was quite easy really
16:27:09 <thoughtpolice> i would really enjoy a library like this however: https://github.com/avsm/mpl
16:27:10 * ddarius has never found writing client/server programs to be difficult in any language.
16:27:35 <Previous> High-throughput ones get ugly fast.
16:27:54 <Taslem> The trouble I'm having is figuring out exactly what I'm trying to do.
16:31:07 <Taslem> For one, WinGHCi is being REALLY inconsistent, so I can't tell whether or not it's printing what it's supposed to.
16:31:34 <monochrom> would ghci be more consistent?
16:31:46 <Taslem> It is.
16:31:53 <Taslem> WinGHCI needs to be fixed...
16:32:27 <monochrom> and I suspect server programming on windows is a pain to begin with. so much bureacracy about svchost, "start server", etc.
16:35:01 * fryguybob has never understood the point of WinGHCi...
16:35:43 <osoleve> i think i broke lambdabot.
16:35:50 <osoleve> can someone explain this type signature?
16:35:53 <osoleve> @type map $ flip (:)
16:35:54 <lambdabot> forall a. [[a]] -> [a -> [a]]
16:36:17 <ion> A function that takes a list of lists of a and returns a list of functions from a to list of a
16:36:23 <monochrom> flip (:) :: [a] -> a -> [a]
16:36:46 <osoleve> ohhhhh
16:36:55 <monochrom> or rather, flip (:) :: [a] -> (a -> [a])
16:36:56 <osoleve> thanks
16:37:32 <monochrom> you can't break lambdabot so easily. but here is how:
16:37:40 <monochrom> > putStrLn "<IO ()>"
16:37:41 <lambdabot>   <IO ()>
16:37:51 <ion> hah
16:37:58 <thoughtpolice> everything turned out better than expected
16:38:34 <djahandarie> > text "<IO ()>"
16:38:34 <lambdabot>   <IO ()>
16:38:38 <djahandarie> Am I doing it right?
16:42:00 <KSkrzet> does unevaluated thunks show up on heap profile?
16:42:27 <KSkrzet> how do I profile what code is causing stack overflows?
16:43:20 <Saizan> 1) yes 2) i never remember the flags
16:43:39 <hpc> use the man, man
16:48:20 <bos> do we have any decent libraries for sparse linear algebra?
16:52:01 <hpc> bos: i know there are at least some linear algebra packages
16:52:08 <monochrom> ghc user guide section 4.1.7, look for "-xc"
16:52:11 <hpc> not sure if they are good at sparse stuff
16:52:21 <bos> hpc: yeah, they all use dense or banded vectors
16:52:22 <monochrom> if you have ghc, you have a copy of ghc user guide on your disk
17:10:20 * hackagebot Ganymede 0.0.0.4 - An Io interpreter in Haskell.  http://hackage.haskell.org/package/Ganymede-0.0.0.4 (WaltBaety)
17:10:54 <mikeg> is there a heap profile equivalent for the stack? Or other ways to manage stack memory (maybe criterion?). I was working with some parsec code that needed -K128M to run
17:11:34 <dmwit> mikeg: Sounds like something is a little lazier than you intended. Doing any arithmetic?
17:12:50 <mikeg> Nothing like that, I don't think. It's been a while but I think it was when recursively parsing a >100KB file
17:14:05 <tromp_> @let i=0:+1 in map length.iterate(>>=(\l->filter(not.elem 0.scanl1(+).scanl(*)1)(map(:l)[i,-i])))$http://en.wikipedia.org/wiki/Special:Search?go=Go&search=i
17:14:05 <lambdabot>   Parse error: in
17:14:05 <sm> has anyone got an easier dsl for hdbc ?
17:14:11 <tromp_> > let i=0:+1 in map length.iterate(>>=(\l->filter(not.elem 0.scanl1(+).scanl(*)1)(map(:l)[i,-i])))$http://en.wikipedia.org/wiki/Special:Search?go=Go&search=i
17:14:12 <lambdabot>   <no location info>: parse error on input `='
17:14:14 <sm> especially for interactive db querying
17:14:28 <monochrom> what is $http://en.wikipedia.org/wiki/Special:Search?go=Go&search=i ?
17:14:59 <dmwit> tromp_: Probably you forgot some of these: ""
17:15:08 <tromp_> it works in my ghci
17:15:13 <tromp_> i just copy and pasted
17:15:33 <dmwit> I don't believe you.
17:16:15 <monochrom> I believe you. could you upload your ghci so we could all enjoy this new feature?
17:16:32 <tromp_> load up ghci, do :m +Data.Complex and paste that
17:17:00 <dmwit> tromp_: parse error here
17:17:01 <tromp_> oops
17:17:13 <tromp_> > let i=0:+1 in map length.iterate(>>=(\l->filter(not.elem 0.scanl1(+).scanl(*)1)(map(:l)[i,-i])))$http://en.wikipedia.org/wiki/Special:Search?go=Go&search=i
17:17:13 <lambdabot>   <no location info>: parse error on input `='
17:17:22 <tromp_> what's that wikipedia doing there?
17:17:36 <dmwit> That's what we were trying to tell you. =P
17:17:43 <monochrom> <monochrom> what is $http://en.wikipedia.org/wiki/Special:Search?go=Go&search=i ?
17:17:49 <mikeg> > let i=0:+1 in 4
17:17:50 <lambdabot>   4
17:18:29 <tromp_> i have no idea why Konversation inserts that
17:18:58 <tromp_> oh, because i use http://en.wikipedia.org/wiki/Special:Search?go=Go&search=i ?!
17:19:02 <monochrom> a conspiracy with Konqueror
17:19:17 <tromp_> oh, because i use [ [i] ]
17:19:28 <tromp_> without the extra spaces, it thinks it's a url
17:19:35 <monochrom> what, it does macro expansion?!
17:19:55 <tromp_> is that Konversation's doing, or IRC's ?
17:20:04 <hpc> D:
17:20:09 <tromp_> can you type [ [i] ] without the spaces?
17:20:11 <hpc> that's konversation
17:20:12 <monochrom> irc servers certainly don't do macro expansion
17:20:19 <monochrom> [[i]]
17:20:20 <hpc> [[i]]
17:20:22 <monochrom> [ [i] ]
17:20:28 <tromp_> > let i=0:+1 in map length.iterate(>>=(\l->filter(not.elem 0.scanl1(+).scanl(*)1)(map(:l)[i,-i])))$[ [i] ]
17:20:29 <monochrom> [[i] ]
17:20:31 <lambdabot>   mueval-core: Time limit exceeded
17:20:42 <tromp_> ok, that works in ghci :)
17:20:57 <tromp_> an interesting sequence
17:21:00 <monochrom> as in terminates nicely?
17:21:14 <tromp_> no, it's infinite
17:21:35 <tromp_> but you get like a few dozen terms in reasonable time
17:21:36 <monochrom> > take 20 (let i=0:+1 in map length.iterate(>>=(\l->filter(not.elem 0.scanl1(+).scanl(*)1)(map(:l)[i,-i])))$[ [i] ])
17:21:38 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,141,226,362,580,921,1468,2344,3740,5922,9413]
17:21:39 <dmwit> That's a pretty slow implementation of fibonaccis.
17:21:49 <tromp_> but it's NOT fibonacci:)
17:22:02 <dmwit> It prints fibonacci numbers here.
17:22:06 <monochrom> it's slow
17:22:09 <tromp_> it's the solution to http://domino.research.ibm.com/Comm/wwwr_ponder.nsf/Challenges/April2011.html
17:22:10 <hpc> > let fibs = 1:1:(zipWith (+) fibs (tail fibs))
17:22:10 <lambdabot>   not an expression: `let fibs = 1:1:(zipWith (+) fibs (tail fibs))'
17:22:12 <hpc> > let fibs = 1:1:(zipWith (+) fibs (tail fibs)) in fibs
17:22:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:22:21 <tromp_> it differs after the 10th term!
17:22:41 <hpc> huh
17:22:44 <dmwit> huh
17:22:47 <dmwit> It does.
17:22:51 <monochrom> yeah, it's slow, doesn't produce enough terms in time limit, so mueval just calls it off.
17:23:00 <tromp_> it counts non-self-intersecting snakes
17:23:14 <monochrom> oh god, it's full of snakes!
17:23:49 <xplat> strange that it's the same up to 10 terms
17:23:58 <tromp_> very weird indeed
17:24:04 <xplat> what happens with snakes of length 10 that weirds it?
17:24:22 <monochrom> I know a non-prime sequence that is the same as the prime sequence up to 163
17:24:26 <tromp_> i dont understand why it matches fibonacci for smaller snakes
17:24:49 <tromp_> is it easily defined, monochrom?
17:25:07 <monochrom> easy if you know advanced abstract algebra. something about class numbers.
17:26:16 <tromp_> but not a haskell one-liner?!
17:26:52 <hpc> the set of haskell one-liners is meaninglessly large
17:28:04 <dmwit> Every program can be reduced to a single line.
17:28:21 <tromp_> hmm, the snake sequence is not in The On-Line Encyclopedia of Integer Sequences
17:31:31 <ion> SNAKES ON A #HASKELL
17:32:01 <hpc> snakes on a torus
17:32:10 <hpc> snakes on a hyperplane
17:32:20 <ion> hypersnakes?
17:32:33 <hpc> hypersnakes on a megaplane :D
17:33:23 * hackagebot swish 0.3.0.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.3.0.0 (DouglasBurke)
17:33:48 <monochrom> tromp_: here is another one: http://www.whydomath.org/Reading_Room_Material/ian_stewart/9505.html
17:34:41 <monochrom> and also a ton of fibonacci-wannabes :)
17:35:39 <ivan> > "What" !! 18446744073709551619
17:35:40 <lambdabot>   't'
17:36:41 <dmwit> > logBase 2 18446744073709551619
17:36:42 <lambdabot>   64.0
17:36:49 <dmwit> > 2^64
17:36:50 <lambdabot>   18446744073709551616
17:37:10 <ion> :t (!!)
17:37:10 <ivan> (these overflows disturb me but I will proceed learning)
17:37:11 <lambdabot> forall a. [a] -> Int -> a
17:37:29 <ion> > 18446744073709551619 :: Int
17:37:29 <lambdabot>   3
17:37:54 <ion> > 543210 :: Word8
17:37:55 <lambdabot>   234
17:39:25 <ion> That’s just how the types behave.
17:45:11 <uranther> how come I can do [2..(floor (sqrt n))] in ghci but not in ghc
17:45:46 <dmwit> uranther: Because n has a different type in ghc than in ghci.
17:46:06 <dmwit> uranther: Not because ghc is different than ghci, but because you're making unwarranted assumptions somewhere. =)
17:46:20 <dmwit> uranther: Try [2..floor (sqrt (fromIntegral n))] or so.
17:46:50 <dmwit> compare:
17:46:54 <dmwit> > length "hello"
17:46:55 <lambdabot>   5
17:46:58 <dmwit> > sqrt 5
17:46:59 <lambdabot>   2.23606797749979
17:47:03 <dmwit> > sqrt (length "hello")
17:47:03 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
17:47:04 <lambdabot>    arising from a use of...
17:47:11 <dmwit> Surprise! =)
17:47:40 <uranther> I'm not sure I get it.. but fromIntegral worked
17:47:50 <shachaf> > 5 == 5
17:47:51 <lambdabot>   True
17:48:01 <shachaf> Black magic.
17:48:04 <dmwit> uranther: Literals like 5 are polymorphic.
17:48:18 <dmwit> uranther: But computed things like (length "hello") often aren't.
17:48:43 <dmwit> uranther: It's hard to say exactly what happened without seeing exactly what you tried, of course. =)
17:48:48 <uranther> i see
17:50:02 <shachaf> > sqrt (lеngth "hello")
17:50:05 <lambdabot>   2.23606797749979
17:50:23 <dmwit> Oh, you and your pesky Unicode.
17:51:16 <dmwit> > "sqrt (lеngth" == "sqrt (length"
17:51:17 <lambdabot>   False
17:51:44 <ddarius> > show "lеngth"
17:51:45 <lambdabot>   "\"l\\1077ngth\""
17:52:07 <dmwit> > "sqrt (lеngth"
17:52:08 <lambdabot>   "sqrt (l\1077ngth"
17:52:21 <monochrom> interesting
17:53:00 <ion> :t 
17:53:01 <lambdabot> <no location info>: not an expression: `'
17:54:10 <ion> :t lеngth --whoops
17:54:11 <lambdabot> Expr
17:58:41 <dmwit> > ls --version
17:58:43 <lambdabot>   ls (GNU coreutils) 7.4
17:59:02 <geheimdienst> @src ls
17:59:02 <lambdabot> Source not found. That's something I cannot allow to happen.
17:59:07 <geheimdienst> @undef
17:59:09 <geheimdienst> > ls
17:59:10 <lambdabot>   Not in scope: `ls'
17:59:13 <dmwit> ;-)
17:59:24 <dmwit> > var "ls (GNU coreutils) 7.4"
17:59:25 <lambdabot>   ls (GNU coreutils) 7.4
17:59:29 <geheimdienst> why did the ... what
17:59:42 <geheimdienst> let --version = 42 in 1
17:59:45 <geheimdienst> > let --version = 42 in 1
17:59:46 <lambdabot>   not an expression: `let --version = 42 in 1'
17:59:55 <dmwit> It's a comment. =)
18:00:05 <geheimdienst> er
18:00:08 <geheimdienst> hm
18:00:10 <geheimdienst> lol
18:00:18 <dmwit> =D
18:00:27 <ion> What was the definition of lеngth, btw?
18:00:53 <dmwit> > let lеngth = genericLength in sqrt (lеngth "hello")
18:00:54 <lambdabot>   2.23606797749979
18:01:10 <ion> :t genericLength
18:01:11 <lambdabot> forall b i. (Num i) => [b] -> i
18:01:53 <ion> The type of lеngth was Expr. I guess i should take a look at the whatsitsname package.
18:02:36 <dmwit> > 5 :: Expr
18:02:37 <lambdabot>   5
18:02:42 <dmwit> > sqrt 5 :: Expr
18:02:43 <lambdabot>   sqrt 5
18:06:18 <azaq23> > foldr (const (+ 1)) 0 $ [1 .. 12]
18:06:19 <lambdabot>   12
18:08:59 <parcs> where can i read about the Expr data type?
18:09:27 <ddarius> @hackage simple-reflect
18:09:28 <lambdabot> http://hackage.haskell.org/package/simple-reflect
18:18:49 <parcs> > "hey" :: Expr
18:18:50 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:18:50 <lambdabot>         against inferred ...
18:19:07 <dmwit> > var "hey" :: Expr
18:19:07 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
18:19:07 <lambdabot>         against inferred ...
18:19:13 <dmwit> :t var
18:19:14 <lambdabot> forall a. String -> Sym a
18:19:17 <dmwit> Oh, right.
18:20:57 <dmwit> > reduce (sqrt 5)
18:20:58 <lambdabot>   2.23606797749979
18:21:49 <parcs> looks like there should be an IsString instance of Expr
18:22:35 <dmwit> > fromString "hey" :: Expr
18:22:36 <lambdabot>   Not in scope: `fromString'
18:22:55 <ddarius> I think the library was made before IsString.
18:22:56 <dmwit> parcs: Wouldn't help you in \bot anyway. =P
18:23:00 <Axman6> :t reduce
18:23:01 <lambdabot> Expr -> Expr
18:23:25 <Axman6> > reduce (sum [a,b,c,d,1,2,3,4])
18:23:26 <lambdabot>   0 + a + b + c + d + 1 + 2 + 3 + 4
18:23:36 <Axman6> > iterate reduce (sum [a,b,c,d,1,2,3,4])
18:23:36 <lambdabot>   [0 + a + b + c + d + 1 + 2 + 3 + 4,0 + a + b + c + d + 1 + 2 + 3 + 4,0 + a ...
18:23:48 <dmwit> > reductions (sum [a,b,c,d,1,2,3,4])
18:23:48 <Axman6> > iterate reduce (sum [1..4])
18:23:49 <lambdabot>   Not in scope: `reductions'
18:23:49 <lambdabot>   [0 + 1 + 2 + 3 + 4,1 + 2 + 3 + 4,3 + 3 + 4,6 + 4,10,10,10,10,10,10,10,10,10...
18:24:03 <dmwit> > reduction (sum [a,b,c,d,1,2,3,4])
18:24:04 <lambdabot>   Not in scope: `reduction'
18:27:10 <qbasicer> Hey guys, I have a rather stupid and newbie question, but here goes, I have a let block, and I want to print out a message so I can better understand what's going on.  I can't figure out how to do the print yet let the return type be returned correctly.  Here's the pastebin: http://hpaste.org/45396/want_to_print
18:27:57 <Lemmih> qbasicer: Add a 'do' after the 'in'.
18:28:54 <Lemmih> qbasicer: Also, you probably want: return (exec ...
18:29:43 <Lemmih> qbasicer: Actually, there are a bunch of other things wrong with the code.
18:30:06 <qbasicer> Lemmih: Damn :(
18:30:19 <qbasicer> I tried making the changes - I annotated the pastebin
18:30:31 <qbasicer> Still not what I'm looking for
18:30:32 <Lemmih> qbasicer: Adding side-effects (such as printing to the screen) to an otherwise pure function isn't all that easy in Haskell.
18:30:51 <lispy> hey Lemmih!
18:30:54 <lispy> how's it going?
18:31:33 <qbasicer> Lemmih: Ok so -  any tips to get something useful out so I can see whats going on or just keep changing stuff till it works?
18:31:49 <Lemmih> lispy: It's 3:40 am and I'm busy writting Haskell code. In other words, life couldn't be better. (:
18:32:03 <nyingen> heh, someone implemented monads in perl and then reported the syntax turned out to be "totally abominable"
18:32:23 <lispy> Lemmih: hehe.  You worked on LHC for a while, then you moved on to other stuff.  Are you still writing a Haskell compiler?
18:32:46 <azaq23> someone also implemented don't in perl
18:33:05 <uranther> what's a good way to determine if any elements of one list exist in another list
18:33:18 <adamvh> :t Stream
18:33:19 <lambdabot> Not in scope: data constructor `Stream'
18:33:23 <lispy> uranther: is efficiency a concern?
18:33:31 <uranther> i don't think so
18:33:33 <adamvh> *sigh*
18:33:37 <lispy> :t (//)
18:33:38 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:33:54 <lispy> uranther: there is a list difference function somewhere
18:34:05 <lispy> ?hoogle Eq a => [a] -> [a] -> [a]
18:34:05 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
18:34:05 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
18:34:05 <lambdabot> Data.List union :: Eq a => [a] -> [a] -> [a]
18:34:06 <parcs> :t not null .: intersect
18:34:06 <azaq23> > any (`elem` [1, 2, 3]) [10, 2, 4] -- likely inefficient
18:34:07 <lambdabot>     Couldn't match expected type `Bool'
18:34:07 <lambdabot>            against inferred type `[a] -> Bool'
18:34:07 <lambdabot>     In the first argument of `not', namely `null'
18:34:09 <lambdabot>   True
18:34:15 <lispy> uranther: oh, (\\)
18:34:26 <adamvh> unranther:  intersection
18:34:52 <Lemmih> lispy: Yeah, I am. I recently gather some decent info on the overhead costs of shadow-stacks, and a zero-overhead GC is underway in LHC.
18:35:00 <uranther> how is \\ used
18:35:01 <parcs> :t any .: zipWith elem
18:35:02 <lambdabot>     Couldn't match expected type `a -> Bool'
18:35:02 <lambdabot>            against inferred type `[Bool]'
18:35:02 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
18:35:09 <lispy> Lemmih: where is LHC hosted?
18:35:26 <adamvh> any way I can get lambdabot to bring Stream into scope?
18:35:28 <Lemmih> lispy: But I'm juggling, like, three different projects so progress is annoying slow across the board.
18:35:32 <lispy> Lemmih: LHC isn't based on JHC anymore though is it?  I heard a rumor like that
18:35:40 <lispy> Lemmih: I know how that is
18:35:45 <lispy> Lemmih: it makes for sporadic updates
18:36:31 <Lemmih> lispy: We scrapped all the JHC code a while back. It was too difficult to maintain. LHC is at lhc.seize.it or just seize.it.
18:36:42 <lispy> cool
18:36:46 <lispy> oh, is it's from scratch now?
18:37:26 <lispy> oh, do you use extcore?
18:37:33 <lispy> I mean, the extcore package on hackage
18:38:08 <Lemmih> No, that package wasn't available when I rebooted LHC.
18:38:33 <Lemmih> And I'm not too much a fan of the package as it is now.
18:39:11 <lispy> I wondered.  I'm using it for a project and I found it was really hard to get the parser working because it has 2 and one is broken
18:39:29 <lispy> I've actually been thinking of using ghc-api instead
18:39:31 <sanjoyd> :t mapM_
18:39:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
18:39:32 <Lemmih> Too bloated for my taste. Things like dead-code elimination and dependency tracking doesn't belong in a language parsing package, imo.
18:40:39 <sanjoyd> :t mapM
18:40:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:41:19 <Lemmih> lispy: I'm using the 'core' package which is very minimalistic.
18:41:53 <Lemmih> lispy: How's the good life at Galois treating you, btw?
18:42:03 <lispy> Galois is very nice
18:42:27 <lispy> I've recently refound my "open source" wings and started doing some evening/weekend hacking, which is nice
18:42:38 <jmcarthur> nice enough that there are no job openings, even
18:43:17 * Axman6 wishes there was a sequence' and mapM' that were tail recursive: mapM' f xss = go xss [] where go (x:xs) res = do {y <- f x; go xs (y:res)}; go [] res = return (reverse res)
18:43:18 <lispy> Lemmih: nice.  I may switch to that core package :)
18:43:40 <sanjoyd> Please suggest some small project someone new to Haskell can code up (to learn Haskell better).
18:44:00 <lispy> jmcarthur: I created a haskell-opengl organization on github.  I think I'll use that for the opengl repos.  Are you on github?
18:44:05 <ManateeLazyCat> Why other people use "darcs get" get my code need password?
18:44:14 <sanjoyd> I have been working on the 99 Haskell problems, but a) they are too small and b) they are really LISP problems.
18:44:31 <lispy> ManateeLazyCat: what URL did you give them?  Does it start with http?
18:44:32 <jmcarthur> lispy: i think i'm on github as geezusfreeek
18:44:38 <Axman6> "really LISP problems"?
18:44:48 <Axman6> sanjoyd: what tutorials have you read?
18:45:00 <Lemmih> ManateeLazyCat: 你好!
18:45:18 <sanjoyd> Axman6: for instance, things like "flatten a list". In haskell that is rather irritating to do, in terms of encoding the input.
18:45:20 <lispy> why is utf8 not working in xchat....I set freenode to use utf8....
18:45:30 <ManateeLazyCat> lispy: Forgot it, i share my own ssh link.
18:45:36 <ManateeLazyCat> lispy: I should share public link.
18:45:40 <lispy> ManateeLazyCat: yeah, that's what I suspected
18:45:41 <Axman6> sanjoyd: how is 'concat' irritation> =)
18:45:43 <ManateeLazyCat> Lemmih: Hello. :)
18:45:45 <jmcarthur> sanjoyd: "in terms of encoding the input"?
18:45:48 <Axman6> irritating*
18:45:51 <ManateeLazyCat> lispy: stupid me. :)
18:46:05 <jmcarthur> @src concat
18:46:05 <lambdabot> concat = foldr (++) []
18:46:06 <sanjoyd> jmcarthur: I mean I can' write [1, [1, 2], 3] etc.
18:46:33 <jmcarthur> [[1], [1,2], [3]]
18:46:36 <jmcarthur> or use a tree
18:46:37 <Lemmih> ManateeLazyCat: wǒ huì shuō yìdiǎnr Hànyǔ.
18:46:38 <Axman6> nope, because that's not well typed
18:46:43 <sanjoyd> Axman6: I've gone through "Learn you a better Haskell".
18:46:48 <sanjoyd> Axman6: plus some theory.
18:46:50 <dibblego> does this function work? http://paste.pocoo.org/show/366947/
18:47:05 <sanjoyd> jmcarthur: but that is not what the problem wants.
18:47:30 <jmcarthur> is the problem meant for haskell at all?
18:47:46 <Axman6> if someone has given you a haskell problem, they'd never want you to do that
18:47:53 <ManateeLazyCat> Lemmih: Sorry, i'm at work time, see you after work. :)
18:48:08 <Axman6> because like i said, [1, [2,3], 4] is not well typed
18:48:12 <Lemmih> ManateeLazyCat: You're the Chinese guy, right? I'm not wasting my mandarin skills on a Korean or Japanese, am I?
18:48:12 <jmcarthur> [[1], [1,2], [3]]  -- this is a perfectly fine way to write the input, IMO
18:48:21 <jmcarthur> Axman6: it's perfectly well typed if you have a num instance for lists :P
18:48:25 <Axman6> unless you have an instance for Num: Num a => Num [a]
18:48:29 <ManateeLazyCat> Lemmih: Yes, I'm Chinese.
18:48:50 <ManateeLazyCat> wǒ huì shuō yìdiǎnr Hànyǔ. mean "我会说一点汉语“
18:48:56 <sanjoyd> Axman6: right. So, to get things to work: MyList a = Element a | Sublist [MyList a]
18:49:05 <sanjoyd> Which is why it feels unnatural.
18:49:20 <sanjoyd> jmcarthur: what if the depth is 3?
18:49:40 <Axman6> then you should be using a tree
18:49:45 <Axman6> because, that is a tree
18:49:47 <Axman6> =)
18:49:49 <jmcarthur> sanjoyd: you're not ever going to have a list with dynamically varying depth like that unless you have a tree
18:50:06 <Maxdamantus> A list is a unary tree.
18:50:15 <sanjoyd> jmcarthur: yes. The question is to flatten a tree of an arbitrary depth.
18:50:18 <dibblego> @djinn (w, r -> a) => (a -> (w, (r -> b)) -> (w, (r -> b))
18:50:18 <lambdabot> Cannot parse command
18:50:22 <dibblego> @djinn (w, r -> a) -> (a -> (w, (r -> b)) -> (w, (r -> b))
18:50:22 <lambdabot> Cannot parse command
18:50:41 <jmcarthur> sanjoyd: then i wouldn't write it as a linked list
18:50:41 <sanjoyd> Either ways, that is not important. I'm fishing for some small idea for a Haskell project
18:50:51 <sanjoyd> on the completion of which I have something working.
18:50:54 <jmcarthur> irc bot
18:51:07 <sanjoyd> Since a lot of things that are easy in other languages are tough (or so I think) in Haskell and vice versa
18:51:10 <jmcarthur> that's usually one of my first projects to learn a language
18:51:12 <sanjoyd> I'm asking here.
18:51:16 <sanjoyd> jmcarthur: thanks! :)
18:51:43 <jmcarthur> there's also tetris
18:52:00 <sanjoyd> That's a huge split.
18:52:19 <lispy> sanjoyd: I saw an interesting challenge problem.  It was to write a tic tac toe api where you can't use the api incorrectly and that is statically enforced.
18:52:30 <lispy> sanjoyd: you could apply the same challeng to tetris
18:53:01 <sanjoyd> lispy: so make the types such that the only moves I can make are valid?
18:53:03 <sanjoyd> Nice.
18:53:17 <lispy> sanjoyd: http://blog.tmorris.net/understanding-practical-api-design-static-typing-and-functional-programming/
18:53:24 <jmcarthur> sanjoyd: this is a tiny split :P
18:53:28 <sanjoyd> Thanks!
18:54:03 <jmcarthur> sanjoyd: it's a huge split if you're on the other side of it!
18:54:06 <lispy> sanjoyd: project euler is another great way to learn a programming language
18:54:18 <sanjoyd> The 
18:54:24 <jmcarthur> eh, i don't like project euler for learning a language
18:54:34 <sanjoyd> "problem" with PE is that after Q 25 or so, you begin to need some very non-trivial math.
18:54:41 <jmcarthur> the problems are all just little puzzles, not engineering challenges
18:54:45 <sanjoyd> Like probability, counting etc.
18:54:46 <lispy> Maybe I should say, projec euler is a great way to learn dynamic programming :)
18:54:54 <jmcarthur> exactly!
18:55:00 <jmcarthur> "project dynamic programming"
18:56:12 <codolio> Sometimes people show you up, though.
18:56:32 <codolio> I was pleased with my dynamic programming solution to one, but someone had already submitted a great foldr solution.
18:57:59 <ManateeLazyCat> Bye all, see you guys at night. :)
18:58:55 <monochrom> wait, night is now... :)
19:00:33 <xplat> dolio: but then you come in with a zygohistomorphic prepromorphism and BAM
19:00:44 <dolio> Yeah.
19:03:26 <lispy> pastorn, jmcarthur: I added both of you to the haskell-opengl org on github and uploaded the repos
19:03:39 <lispy> Let code commence!
19:07:55 * ddarius forgot how to count years ago.
19:08:40 <dibblego> I think this makes no sense because (r ->) is not Traversable http://paste.pocoo.org/show/366947/
19:09:16 <Axman6> > 2^31
19:09:17 <lambdabot>   2147483648
19:16:19 <thoughtpolice> % wc -l rc4_cipher_128.c 205584 rc4_cipher_128.c
19:16:34 <thoughtpolice> wow, 205kLOC for a single function :>
19:17:05 <adamvh> :t Primstate
19:17:06 <lambdabot> Not in scope: data constructor `Primstate'
19:17:07 <Axman6> o.O
19:17:13 <adamvh> @source Primstate
19:17:13 <lambdabot> Primstate not available
19:17:23 <adamvh> @source PrimState
19:17:23 <lambdabot> PrimState not available
19:19:37 <Axman6> i think if i remember rightly, the Primstate stuff is a ... data family? that is defined for IO and ST
19:19:52 <Axman6> well, IO and ST s
19:22:56 <ion> thoughtpolice: Generated code?
19:22:59 <Axman6> I'm also wondering if the quot rem stuff can be made faster with a mask
19:23:06 <Axman6> whoops, wrong chan
19:23:41 <thoughtpolice> ion: yes, generated by SBV
19:24:54 <thoughtpolice> it unrolls pretty much everything, so for an rc4 implementation with a plaintext size of 64 bytes it has to unroll the keystream generation out that many times, etc
19:25:01 <thoughtpolice> but i didn't expect it to be *that* large
19:25:22 <thoughtpolice> there's probably a pathological reason or something
19:25:26 <thoughtpolice> i'll have to ask levent
19:42:04 <lispy> thoughtpolice: he thought your blog post was very cool, BTW
19:51:21 * hackagebot repa 2.0.0.3 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.0.0.3 (BenLippmeier)
19:51:23 * hackagebot repa-algorithms 2.0.0.3 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-2.0.0.3 (BenLippmeier)
19:51:28 <lispy> https://github.com/haskell-opengl
19:52:21 * hackagebot repa-bytestring 2.0.0.3 - Conversions between Repa Arrays and ByteStrings.  http://hackage.haskell.org/package/repa-bytestring-2.0.0.3 (BenLippmeier)
19:52:23 * hackagebot repa-examples 2.0.0.3 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-2.0.0.3 (BenLippmeier)
19:53:21 * hackagebot repa-io 2.0.0.3 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-2.0.0.3 (BenLippmeier)
19:56:41 <causative> it would be nice to have a programming language where you could insert a "tracer" at any point in the program - imagine it like a radioactive dye that a scientist might inject you with to trace where your blood is pumping, or a colored dye that a scientist might put in a lake to track the currents
19:57:03 <causative> so you could say "color this variable" and then later on you can see where the color went
19:57:15 <jeffz> what do you mean by variable?
19:57:17 <causative> the color being transferred to anything that reads something that was already colored
19:58:04 <causative> what do you mean "what do you mean by variable"?
19:58:27 <causative> a variable in the program, a symbol that you can assign a value to
19:58:39 <jeffz> oh, I see, threading a colour through for everything that touches some particular binding
19:59:11 <causative> yes
19:59:25 * hackagebot gloss 1.3.1.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.3.1.2 (BenLippmeier)
19:59:27 * hackagebot gloss-examples 1.3.1.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.3.1.2 (BenLippmeier)
19:59:36 <causative> and the tracer concept is very general
19:59:54 <causative> as I described it, it could be useful for understanding the program structure and debugging
20:00:12 <causative> but it could be used for other things if you don't attach a color, but an arbitrary expression
20:00:31 <causative> with rules for how the tracer "spreads" down the line
20:00:42 <lispy> causative: that sounds like algorithmic debugging
20:01:16 <causative> although not the same
20:01:21 <lispy> causative: there are some papers out there by some researcher (I think in german) about comparing program states between a good run and a bad run to find where it diverges.  And they use the notion of "tained" states to work backwards.
20:01:37 <causative> yes, the concept of using a tracer of some sort is pretty obvious
20:01:40 <lispy> You could probably take that notion of tainted state and work it into your visualization
20:01:41 <causative> I'm sure it comes up in a lot of places
20:01:53 <causative> hmm
20:02:14 <causative> anyway it does not have to just be for debugging
20:02:26 <causative> suppose you want to attach a comment to a particular value
20:02:40 <causative> or other metadata to a value
20:02:47 <causative> that you would like to have copied over as the value is copied
20:03:01 <ddarius> causative: Or 11,500 tons of radioactive water dumped into the Pacific.
20:03:03 <causative> without having to rewrite everything to accept your expanded data structure
20:04:01 <causative> that's like a "tracer" - something you attach to a value, that gets copied over when the value is moved from place to place
20:05:22 <causative> and not necessarily just copied, it could have other things done to it
20:06:01 <causative> like if A and B are numbers, each with a comment attached to them as a "tracer," then A + B could get the tracer found by appending the two comments, perhaps with a semicolon in between
20:08:51 <causative> or for example, let A and B be real numbers, with an imaginary tracer attached to them
20:09:01 <causative> hmm no that doesn't fit
20:09:44 <causative> well suppose you have an array of people that you want to sort by age, and you have a sorting function that can only sort a list of numbers
20:10:11 <causative> first you could transform the array into a list of ages, with the corresponding person attached to each age as a tracer
20:10:16 <causative> then sort the array
20:10:37 <causative> and then extract the people from their ages again
20:11:01 <causative> eliminating the need for an extra parameter to the sort function for the key
20:11:23 <causative> so the sort function can stay simple, while doing complicated things
20:11:44 <causative> that weren't originally anticipated
20:12:38 <causative> see what I'm saying?
20:14:26 * hackagebot bmp 1.1.1.2 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.1.1.2 (BenLippmeier)
20:14:30 <jeffz> simpler to just use sortBy
20:14:44 <causative> but sortBy is more complicated than sortNum
20:14:48 <causative> and this is just an example
20:15:22 <causative> other functions have parameters that could be better accomplished with tracers too...
20:15:59 <causative> like min, or max
20:16:08 <causative> or functions for adding vectors that could really just be for adding numbers
20:17:04 <MaskRay> causative: so you mean a similar concept of `taint' in Perl?
20:17:34 <jeffz> seems like every value could have a history of how that value was computed, if applied to everything
20:18:26 <causative> taint mode in perl is an example of it!
20:18:47 <MaskRay> but yours is more general
20:18:51 <causative> keeping a change history is another example
20:18:53 <causative> yes
20:20:02 <causative> the "other" way to keep a change history would be to append to the change history right in the code, every time you make a change
20:20:11 <jeffz> hmm, seem to get a bit of infinite regress if you try to figure out the history of the history
20:20:19 * jeffz boggles.
20:20:26 <causative> but that is poor separation of concerns
20:20:57 <causative> it would be better if you could specify the rules for updating the change history in one place, and then it would automatically update as the value was changed
20:22:42 <MaskRay> Useful for debugging...
20:23:38 <causative> keeping change histories are important in themselves, such as for record keeping for financial audits
20:30:50 <dmwit> causative: Perhaps you'd be interested in the Writer monad.
20:32:44 <lispy> but how do you audit the audit log?
20:32:53 <lispy> who watchs the IRS?
20:33:06 <lispy> what happens when you google "recursion"?
20:33:20 <causative> well you can check parts of the audit log against another
20:33:21 <dmwit> There's always a trusted computing base somewhere at the bottom.
20:33:23 <causative> to see if they match up
20:33:50 <causative> beside the point really
20:33:57 <dmwit> The question isn't "How can we eliminate the trusted computing base?" but "How small can we make the trusted computing base?".
20:34:34 <TomMD> Can I assume a hardware instruction "execL4"?
20:34:44 <dmwit> =)
20:34:51 <ddarius> TomMD: Yes.
20:50:12 <kevinburke> http://hpaste.org/45406/uglyindent
20:50:25 <kevinburke> that looks really ugly w/ indentation, is there a better convention?
20:56:41 <cwraith> kevinburke: use a where clause instead
20:56:43 <NisseP> you can put the first statement of a do on the next line and just indent it one step instead an irregular amount of spaces like if it's on the same line
20:56:48 <NisseP> (same with let and case)
20:57:12 <NisseP> where and case, I mean.
20:58:29 <NisseP> also, since your let doesn't use any local bindings, you can move it out to somewhere more convienient.
20:58:50 <copumpkin> @let assoc = (fst . fst) &&& ((snd . fst) &&& snd)
20:58:50 <lambdabot>  Defined.
20:58:53 <copumpkin> :t assoc
20:58:54 <lambdabot> forall a b b1. ((a, b), b1) -> (a, (b, b1))
20:59:13 <copumpkin> :t assoc . assoc
20:59:14 <lambdabot> forall a b b1 b11. (((a, b), b1), b11) -> (a, (b, (b1, b11)))
20:59:36 <copumpkin> :t second assoc . (assoc . first assoc)
20:59:36 <lambdabot> forall a b b1 d. (((d, a), b), b1) -> (d, (a, (b, b1)))
20:59:57 <ddarius> :t assoc assoc assoc assoc
20:59:58 <lambdabot>     Couldn't match expected type `((a, b), b1)'
20:59:58 <lambdabot>            against inferred type `((a1, b11), b12) -> (a1, (b11, b12))'
20:59:58 <lambdabot>     In the first argument of `assoc', namely `assoc'
21:00:25 <copumpkin> :t assoc . assoc . assoc . assoc
21:00:25 <lambdabot> forall a b b1 b2 b3 b11. (((((a, b), b1), b2), b3), b11) -> (a, (b, (b1, (b2, (b3, b11)))))
21:02:26 <copumpkin> @check let assocI = assoc :: ((Int, Int), Int) in liftM2 (==) (assocI . assocI) (second assoc . (assoc . first assoc))
21:02:27 <lambdabot>   Not in scope: `assoc'Not in scope: `assoc'Not in scope: `assoc'Not in scope...
21:02:42 <copumpkin> @check let assocI = ((fst . fst) &&& ((snd . fst) &&& snd)) :: ((Int, Int), Int) in liftM2 (==) (assocI . assocI) (second assoc . (assoc . first assoc))
21:02:42 <lambdabot>   Not in scope: `assoc'Not in scope: `assoc'Not in scope: `assoc'
21:02:53 <copumpkin> @check let assocI = ((fst . fst) &&& ((snd . fst) &&& snd)) :: ((Int, Int), Int) in liftM2 (==) (assocI . assocI) (second assocI . (assocI . first assocI))
21:02:53 <lambdabot>   Couldn't match expected type `((GHC.Types.Int, GHC.Types.Int), c)'
21:02:57 <copumpkin> gah
21:03:13 <espringe> http://hpaste.org/45410/primes
21:03:13 <espringe> Could someone shed light on why that doesn't compile?
21:03:28 <copumpkin> it'd help if you included the compiler error
21:03:40 <espringe> ok, i'll annotate it with it
21:03:44 <espringe> done
21:04:24 <copumpkin> putStrLn takes a String
21:04:28 <copumpkin> sieve doesn't return a string
21:04:40 <copumpkin> you could try map print
21:04:44 <copumpkin> however, you still have a list of IO actions
21:04:54 <copumpkin> which you want to do something with
21:05:04 <espringe> I just want it to print the result of the sieve :D
21:05:06 <copumpkin> you might find the sequence_ or mapM_ functions handy
21:05:14 <copumpkin> :t sequence_
21:05:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:05:22 <c_wraith> honestly, you could just use print with the list
21:05:29 <copumpkin> yeah, sure
21:05:33 <c_wraith> thought mapM_ also does what you want
21:05:41 <copumpkin> one puts them all on one line
21:05:46 <copumpkin> the other would put them on different lines
21:05:56 <djahandarie> copumpkin, by that you mean sequenceA_ and traverse_, right? ;)
21:06:02 <copumpkin> pff
21:06:03 <espringe> printer value = print $ sieve [2 .. value]
21:06:04 <espringe> Ok, that seems to work
21:06:09 <copumpkin> you have to put in extra effort to get those ones
21:06:53 <MaskRay> and you need to give a boundary for `sieve'
21:07:04 <MaskRay> sieve [] = []
21:08:15 <espringe> Thanks, ok it's working. Except I need each number printed on it's own line
21:08:16 <espringe> :D
21:08:23 <espringe> Without any decoration
21:08:37 <kmc> :t mapM_ print
21:08:38 <lambdabot> forall a. (Show a) => [a] -> IO ()
21:10:42 <espringe> sweet, thanks
21:10:49 <espringe> Now to benchmark this against my c version
21:12:01 <kmc> are you building with ghc with optimizations turned on?
21:12:26 <espringe> ghc --make -O3 test.h -o test
21:12:29 <espringe> Is there a faster way?
21:12:34 <espringe> It's running really really slow
21:12:44 <kmc> looks good to me
21:12:58 <c_wraith> espringe: your algorithm is pretty bad.  :)
21:13:01 <c_wraith> espringe: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
21:13:33 <c_wraith> That paper goes into a lot of detail about why that algorithm is not the sieve of eratosthenes
21:14:02 <kmc> getting Haskell code to run faster than C code is hard
21:14:12 <espringe> I might try make it more like my c++ version: http://code.google.com/p/anacrolix/source/browse/various/eric_prime.cc
21:14:19 <kmc> getting it to run 100 times faster than popular Python or Ruby interpreters is easy
21:14:24 <c_wraith> it's even harder when the haskell code is using a slower algorithm
21:14:52 <kmc> Haskell is the sort of language where you code a simple solution quickly and then optimize the parts that matter
21:15:01 <espringe> My c version is running faster for 10 million numbers, than this is for 100000
21:15:05 <espringe> but yeah, different algos
21:15:12 <kmc> try coding the slower algo in C too
21:15:29 <espringe> Well, the naive c version is *way* faster than the naive haskell version
21:15:42 <espringe> in that link: http://code.google.com/p/anacrolix/source/browse/various/eric_prime.cc
21:15:42 <espringe> "print_prime_numbers" is the naive version
21:15:47 <ddarius> kmc: Getting it to run as slow as popular Python and Ruby interpreters is hard
21:15:56 <espringe> It's about 6 times slower than when i started optimising
21:16:33 <espringe> but i'll do same algo in haskell and see what happens
21:17:32 <kmc> ddarius, but it's easy to use more memory :)
21:19:58 <copumpkin> erikc!
21:20:18 <erikc> indeed
21:20:26 <espringe> What's the nicest way of writing this in haskell: http://hpaste.org/45413/is_prime
21:20:35 <espringe> (without making a "loop" inner function)
21:21:25 <kmc> :t all
21:21:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:22:02 <flamingspinach> espringe: doesn't calling sqrt() in the test every time you go through the loop slow it down immensely?
21:22:04 <kmc> :t \v -> all ((==0) . (v `mod`)) [2..sqrt v]
21:22:04 <lambdabot> forall a. (Floating a, Integral a) => a -> Bool
21:22:11 <flamingspinach> or does the compiler optimize that away... wait, this is #haskell :P
21:22:21 <espringe> flamingspinach: That's the naive version in c
21:22:27 <espringe> I wanted to compare the naive haskell vs naive c
21:22:30 <kmc> gcc might have __attribute__((pure)) on sqrt
21:23:10 <kmc> :t \v -> null [i | i <- [2..sqrt v], v `mod` i /= 0]
21:23:11 <lambdabot> forall a. (Integral a, Floating a) => a -> Bool
21:23:25 <c_wraith> heh.  yes.  Integral a, Floating a
21:23:31 <kmc> :D
21:23:43 <kmc> perhaps floor . sqrt then ;P
21:24:27 <flamingspinach> why do you even need sqrt? Hell, you could go through [2..]
21:24:51 <c_wraith> flamingspinach: correctness is nice.  the upper bound needs to be < n
21:24:57 <flamingspinach> well, I guess that would make it take squared as long if it actually were prime
21:24:57 <kmc> there's the question of just how naive is naive
21:25:19 <flamingspinach> c_wraith: true, you'd have to make a special case for n :P that's not a good way
21:25:27 <espringe> kmc: i consider naive what i come up quickly without wikipediaing :D
21:25:36 <espringe> without putting too much thought in it
21:25:45 <espringe> sqrt(n) seemed pretty natural
21:25:57 <kmc> yeah, it's very relative and subjective though
21:26:01 <espringe> agree
21:26:15 <kmc> when i first learned to program i thought i was hot shit for thinking of that sqrt optimization ;)
21:28:06 <jmcarthur> i remember once going to great lengths to write an efficient algorithm to the first 1 bit in a word only to discover that i had basically reinvented log base 2
21:28:15 <jmcarthur> *to find the first
21:28:40 <flamingspinach> lol
21:31:22 <c_wraith> honestly, if I was trying to optimize that loop, I'd use quotRem, and the loop termination would be based on the quotient being <= the divisor or the remainder being zero.  This is, of course, assuming that the hardware actually implements quotrem directly
21:31:40 <c_wraith> err, implements quotRem efficiently
21:32:30 <liyang> Pretty much any HW div instructions will also give you the remainder somewhere, shurely?
21:33:02 <c_wraith> yes, the two are the same calculation..  But it's up to the code generator to actually implement that sanely
21:33:14 <c_wraith> or, rather, use the results sanely
21:33:40 <Berengal> Programming when the main bottleneck is not being able to type fast enough hurts like a bitch
21:36:25 <mac_wooster> I am trying to download all the xmonad configs using the haskell script on the xmonad page. I get this error:     Could not find module `Text.HTML.Download':
21:36:26 <mac_wooster> What cabal package should I install to get this package. I have done cabal install text, cabal install Download. But can't get this above. I couldn't find this in hackage for download too.
21:37:22 <dented42_> mac_wooster: you can look on hayoo
21:37:51 <Berengal> @hoogle Text.HTML.Download
21:37:51 <lambdabot> No results found
21:38:08 <dented42_> Hmmm...
21:38:23 <Berengal> http://haskell.org/hoogle/?hoogle=Text.HTML.Download
21:38:39 <Berengal> lambdabot's hoogle seems to not be as good
21:39:35 * hackagebot MemoTrie 0.4.10 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.4.10 (ConalElliott)
21:39:39 <lispy> I had an idea for a new type of preprocessor for haskell.  Use agda syntax but generate a .hs file.  Maybe the extension would be .ha.
21:40:37 <lispy> So you'd get mixfix and be able to use λ as \
21:41:48 <mac_wooster> Berengal, dented42_: Thanks. I am getting hoogle now. Thanks for the links too.
21:42:15 <lispy> and be able to use ⊥ for bottom
21:42:45 <Berengal> lispy: It'd be great, but it'd only make me miss holes even more
21:43:38 <lispy> Berengal: Well, it would still be haskell programming, so I don't think you'd need them
21:44:06 <copumpkin> I've wanted them all the time in haskell
21:44:53 <lispy> and why does my xchat on windows display lambda correctly but not bottom.  For bottom I get a square box
21:45:03 <lispy> WHY XCHAT? WHY?
21:45:28 <Berengal> If haskell got holes I'd be dancing in the streets...
21:45:41 <Berengal> It doesn't even need a compiler that understands them, just a type checker
21:45:51 <dncr> what are holes, is it like: (f 4 ? 6 ?) 5 7 === f 4 5 6 7
21:45:58 <applicative> mac_wooster: Text.HTML.Download is from Tagsoup  http://hackage.haskell.org/package/tagsoup-0.12 or maybe you figured that out
21:46:04 <Berengal> dncr: It's when you leave out part of definitions
21:46:14 <dncr> hm
21:46:18 <Berengal> dncr: For example, foo x = x + {} - 3
21:46:20 <dncr> oh and fill them in later?
21:46:26 <lispy> dncr: I think it's a mechanism to help you figure out how to complete an expresison in a type correct way.
21:46:28 <dncr> it's an editor thing?
21:46:30 <flamingspinach> lispy: maybe because xchat on windows involves gtk on windows which is a crapshoot
21:46:38 <dncr> mm
21:46:48 <dncr> that's cool
21:46:51 <Berengal> dncr: Not just an editor thing. In Agda, for example, the type checker will list all the holes with the types required
21:47:01 <lispy> flamingspinach: I think that may be the issue.  The docs say, "this is how you do it on linux (doesn't work on windows)"
21:47:21 <dncr> Berengal: nice
21:47:45 <dncr> Berengal: if there are many holes and interdependent possibilities does it just error?
21:47:53 <lispy> Berengal: So, I wonder what it would take to add holes to GHC
21:47:55 <Berengal> dncr: So your program still type-checks even though you left some things out. You'll just get a message "your program is correct, given that you provide these: <list>"
21:48:16 <Berengal> dncr: Agda does much less type inference than Haskell does. Almost everything requires a type signature
21:48:48 <Berengal> lispy: You might be able to hack them in using undefined and somehow lifting those to the top-level to get the type
21:48:59 <flamingspinach> lispy: set your font as some alias defined in pango.aliases, and then define that alias to contain enough fallback fonts to get all the characters you want
21:49:01 <flamingspinach> that seems to work
21:49:37 <Berengal> (It's something I've thought about before)
21:49:48 <monochrom> windows fixed-width fonts miss some symbols
21:50:22 <lispy> monochrom: I tried switching to arial and and I was stil missing stuff.  Is that to be expected too?
21:50:47 <dncr> it might not be that hard to use ghc stuff to parse the file and resolve types for someUndefinedAlias
21:50:59 <monochrom> arial unicode ms has the best coverage. should be fine with both ⊥ and λ
21:51:31 <lispy> oh, comic sans!
21:51:41 <lispy> sadly, still missing the symbol :(
21:51:49 <lispy> everything seem so fun and light hearted now!
21:53:10 <Berengal> I once set my font to some gothic-handwriting thing when writing Agda. I felt like Leibniz
21:53:31 <lispy> haha
21:53:46 <dncr> if you were going to play around with adding holes to ghc would you use head or stable
21:55:07 <lispy> dncr: I'd use the github version
21:55:16 <wharrrgarbl> WHARRGARBL
21:55:33 <lispy> dncr: But, I would need to understand what I'm doing a lot better before I would even start :)
21:55:49 <lispy> dncr: like implementing holes in a toy type checker first
21:56:00 <lispy> dncr: maybe start from the typing haksell in haskell paper
21:56:21 <dncr> uh huh
21:56:36 <c_wraith> wharrrgarbl: wharrrgarbl?
21:56:54 <wharrrgarbl> WHARRGARBL
21:57:05 * lispy assumes this means copumpkin lost some sort of bet :)
21:57:17 <c_wraith> I just figured this was what communication on the internet had come to
21:58:09 * lispy can't get the font thing to work out....maybe it is finally time to switch back to ssh + screen + irssi
21:58:35 <c_wraith> for the sake of education: http://www.reece-eu.net/gallery/var/albums/funny/WHARRGARBL.jpg?m=1272637473
21:58:40 <lispy> At least then I'd have like 4 extra layers to trouble shoot
21:58:57 <c_wraith> seems copumpkin spelled it wrong
21:59:08 <lispy> Is this one of those memes?
21:59:13 <c_wraith> yes
22:21:17 <mac_wooster> applicative: Actually, I do have tagsoup installed. But, I still see this error.
22:35:24 <mac_wooster> applicative, berengal: Finally, got to this after your help. 
22:35:26 <mac_wooster> cabal install tagsoup-ht
22:36:05 <mac_wooster> cabal install tagsoup-ht
22:36:06 <mac_wooster> Resolving dependencies...
22:36:06 <mac_wooster> cabal: cannot configure tagsoup-ht-0.3. It requires base ==3.*
22:36:51 <monochrom> "This package is obsolete: use tagchup instead."
22:37:04 <monochrom> base-3 is no longer in ghc 7
22:43:11 <andras> good morning everyone
22:43:47 <andras> I'm wondering if Haskell allows me to create formatted string out as easily as Ruby does -- can anyone help?
22:43:58 <andras> I mean this in Ruby: "%e,%i"%[1,2]
22:44:22 <andras> something like this is quite cumbersome with show and (++)...
22:44:27 <andras> is there a better way?
22:45:35 <lispy> andras: Text.Printf
22:45:52 <lispy> > printf "%d %s" 10 "hello"
22:45:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:45:53 <lambdabot>    `Text.Printf.PrintfType ...
22:46:01 <lispy> > printf "%d %s" 10 "hello" :: String
22:46:02 <lambdabot>   "10 hello"
22:49:50 <andras> lispy: thanks -- it would've been too obvious to just hoogle for printf, wouldn't it?
22:50:26 <shachaf> andras: For a bonus, look at how it's implemented.
22:53:02 <mac_wooster>  monochrom: thanks. should I just replace tagsoup with tagchup?
22:53:37 <andras> shachaf: I can imagine...
22:55:24 <lispy> andras: hehe
22:55:47 <tibbe> Tomorrow is the last day to apply for Google Summer of Code. We need more students!
23:03:30 <Peaker_> Haskell platform is now with ghc 7, right?
23:04:09 <Peaker_> I see that it is, but the Ubuntu package seems out of date
23:05:31 <ehamberg> ubuntu only upgrade every 6 months and it seems that 2011.2 didn't make 11.04, so you'll have to wait until 11.10.
23:06:03 <arlinius> or install it otherwise
23:06:04 <ehamberg> or simply intall ghc7 yourself. :-)
23:06:20 <arlinius> you might find a ppa for ubuntu
23:07:30 <Peaker_> Yeah, I think it would be nice for the Ubuntu link of HP to list a ppa and package name, rather than be a link to an outdated package..
23:07:46 <Peaker_> ppa's are the nicest way to be up-to-date on something like that
23:08:42 <arlinius> it might make sense to link to both... since the outdated one is still the official ubuntu package
23:10:08 <Peaker_> so what's the official ppa of HP for Ubuntu?
23:11:06 <lispy> tibbe: can mentors still sign up?
23:16:39 <Peaker_> justin bogner's ppa seems to be an official one, but has lucid and no maverick versions
23:23:13 <tibbe> lispy: I think so
23:26:28 <lispy> tibbe: looks like it :)
23:26:34 <tibbe> lispy: :)
23:26:43 <tibbe> now we just need some more students to mentor
23:26:55 <lispy> tibbe: I had a mail filter from last year marking all my gsoc mail as read (I was getting too much spam last year and too many arguments on the list).
23:27:00 * shachaf wonders whether he technically counts as a student.
23:27:16 <lispy> tibbe: So I didn't even see the invite that edwardk sent out about mentoring this year
23:28:00 <tibbe> lispy: oops
23:28:22 <lispy> yeah...I changed my filter :)
23:38:54 <dreixel> I have a machine without internet access, but I want to use cabal-install there. How can I have a local copy of Hackage? I tried using the local-repo field in the config file, but it complains that it's missing the package list.
23:44:48 <frerich> Is there a ready-made type class which can be used for uniform access to binary data types, like 'Bool' or 'data Bit = Zero | One' or something like that?
23:45:04 <frerich> I thought 'Binary' was a nice name but then I noticed that exists already (and it does something else).
23:49:20 <olsner> frerich: you mean something like this? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bits.html
23:49:55 <shachaf> frerich: What do you mean by "uniform access"?
23:50:48 <frerich> oslner: Oh, no, something much simpler. Just something like 'class C a where zero, one :: a'.
23:51:32 <frerich> shachaf: Well I have a function which yields a list of 'bits'. It can be a [Bool] but also a '[Bit]' where 'Bit' is 'data Bits = Zero
23:51:35 <frerich> | One'
23:51:42 <shachaf> Why would you want that?
23:52:11 <frerich> shachaf: I don't know, but this is a library, so my plan was to make it as flexible as possible by expressing the requirements on the type using a type class.
23:52:25 <frerich> And all I need is a type which can yield at least two distinct values.
23:53:55 <frerich> Maybe it's stupid, I don't have much experience with using type classes (let alone introducing ones). :-}
23:54:18 <olsner> that sounds exactly like Bool
23:54:41 <frerich> I just thought I could improve the library a bit by not hardcoding types but rather use type classes to express the requirements on types and then provide instances for common types.
