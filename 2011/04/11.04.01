00:19:01 <hvr> napping: each HEC has a bar for GC acitivty, and one for actual work ... what does it mean, when the GC-bar gets green?
00:20:00 <napping> The GC bar gets green? Isn't GC orange?
00:20:00 <MasseR> I'm trying to use newtype Selection = Selection (Int) deriving (Num, ..,..,.., Data, Typeable) with cmdargs. It compiles but on running it says "Exception: System.Console.CmdArgs.Implicit, unexpected flag (edit): Main.Selection"
00:20:18 <hvr> napping: most of the time, but it switches from orange to green at some points
00:20:31 <napping> Is it green above the line, and orange below?
00:20:58 <hvr> napping: is there something like pastebin where I can't post a screenshot?
00:21:00 <napping> if so, then green is time actually running
00:21:44 <MasseR> hvr: imgur
00:22:06 <napping> there are many places where you can't post a screenshot :P
00:24:20 <hvr> napping: http://www.narf.at/~hvr/threadscope.pdf
00:24:55 <hvr> napping: what's happening there in the middle?
00:26:21 <napping> I don't know what that means
00:26:35 <napping> You should post the example to the mailing list anyway
00:27:06 <napping> I'm wondering if more threads is making GC more expensive
00:28:47 <hvr> cafe ?
00:29:46 <napping> yes
01:51:26 <accel> @hoogle withArray
01:51:26 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
01:51:26 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
01:51:26 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
01:51:37 <accel> WTF does withArray do?
01:51:41 <accel> it makes no sense to me.
01:53:06 <mauke> why not?
01:53:18 <quicksilver> it temporarily converts a list into a C-style contiguous array
01:53:23 <quicksilver> for the duration of an IO action
01:53:25 <illissius> accel: presumably it takes the elements from [a], allocates an array containing them, executes the (Ptr a -> IO b) on them, then deallocates the array
01:53:30 <quicksilver> (persumably an FFI call to a C routine)
01:54:31 <Axman6> i find it interesting that the action isn't passed the number fo elements stored by default
01:55:08 * Axman6 senses accel trying to program C in Haskell again
01:55:28 <accel> no no
01:55:31 <illissius> Axman6: i'd guess the array is 0-terminated?
01:55:35 <accel> I'm reading an example of creating a texture in Haskell
01:55:38 <accel> then loading it into opengl
01:55:42 <accel> there's some C FFI black magic going on
01:55:45 <accel> mauke: it makes sense now
01:55:49 <Axman6> illissius: well, maybe it is with withArray0
01:55:50 <accel> quicksilver , illissius : thanks
01:57:04 <illissius> Axman6: that's what i thought at first, but what's the extra 'a' parameter for?
01:57:11 <illissius> eh, would be easier to just read the damn docs/source :)
01:57:24 <Axman6> which extra a parameter?
01:57:35 <illissius> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
01:57:56 <Axman6> oh, right, i guess the extra a is the 'zero' element
01:58:00 <Axman6> missed that completely
01:59:46 <quicksilver> illissius: it's not null terminated by default no
01:59:57 <quicksilver> it's for the case when you know how long the array is.
02:00:02 <quicksilver> the simple 'withArray' that is.
02:00:22 <quicksilver> I agree that withArrayLen seems more generally useful - but in practice I have always known how big the array was
02:00:29 <quicksilver> OpenGL textures, vertex buffers, etc.
02:01:56 <aleator> I played with convex functions lately, and as an idle thought tried to figure out if I could use haskell type system to enforce convexity. This is all simple for usual arithmetic, but with composition you can say things like
02:02:15 <aleator> composition of affine, nondecreasing with a convex function is a convex.
02:02:40 <aleator> So I'd need to have a set of flags (affine,convex,increasing) in my type.
02:02:58 <aleator> Has anyone hacked something like this with haskell?
02:04:28 <accel> I need a 2D mutable array. It represents a 256x256 image. I need to draw a list of lines on it.
02:04:36 <accel> what ahskell type should I use for the 2d mutable array?
02:04:49 <Axman6> what do you need to do with it?
02:04:55 <Jafet> Mutable array... like MArray?
02:04:56 <Axman6> do you need to pass it to C code?
02:05:07 <Axman6> well, MArray is just a class
02:05:16 <accel> what I need to do with it
02:05:23 <accel> is taht I start out with MArray, then I add lines to it
02:06:04 <mauke> you can't add elements to an array
02:06:12 <accel> s/add/raster/
02:06:24 <Jafet> Oh, you're the I want to draw shapes guy.
02:06:29 <Axman6> well then there's any number of mutable array types
02:06:41 <accel> is MArray 2D?
02:06:53 <Axman6> MArray is a class
02:07:05 <Jafet> If you want it to be.
02:07:15 <Axman6> there's IOArrays, IOUArrays, STArray, STUArray, storable arrays etc. etc. etc
02:07:38 <Axman6> things that use the Is class for indexing can have any dimension
02:08:00 <illissius> *Ix
02:08:00 <kstt> Speaking of low level horrors : Is there a way to replace the content of a bytestring ? I really mean *replace the data* at adress. The use-case is for a network TCP proxy, that needs to copy data from socket to socket in a loop. Allocation and GC is taking ~15% of CPU time, which is indeed acceptable, but still a total waste in this trivial memory managment use-case.
02:08:28 <Jafet> kstt: I repeat: no
02:08:33 <kstt> I'm in IO anyway
02:08:53 <Axman6> kstt: i think there's functions to get access to the underlying pointer, which you could modify, and 'freeze' back into a bytestring
02:09:12 <Jafet> I'm pretty sure those aren't in the interface
02:09:43 <Axman6> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.10/doc/html/Data-ByteString-Unsafe.html
02:10:08 <kstt> Jafet: so would you recommand to just get over this little loss ? Or dou you have an other idea ?
02:10:11 <Axman6> look at the CString stuff
02:10:19 <Jafet> Hm.
02:12:24 <kstt> maybe the ST monad, but I have no experience with it so I can say if it applies of not
02:12:34 <kstt> I can *not* 
02:12:52 <Axman6> :\
02:13:40 <Axman6> I've already shown you how to, just use unsafeUseAsCStringLen, modify the buffer, and then use unsafePackCStringLen
02:14:02 <Axman6> actually, you don
02:14:40 <Jafet> That's about equivalent to just dumping bytestring and doing everything with foreign
02:14:41 <Jafet> The bytestring IO creates new bytestrings for you whether you want them or not
02:14:41 <Jafet> You can copy the source code, of course, and make your version not do that
02:14:44 <Axman6> don't even need to use the pack function, the first function lets you modify the buffer without it being copied, so the original bytestring will have been modified.
02:14:57 <kstt> Axman6: I was trying to evaluate alternatives, but I appreciate your proposal, and will try it right now.
02:15:14 <Axman6> not sure how you work with CStrings though
02:15:27 <Axman6> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Foreign-C-String.html#t:CStringLen will tell you though
02:16:19 <kstt> thx
02:18:01 <Jafet> If this server is to be used in the real world, I would just do a foreign call to sendfile or whatever magic there is on the system.
02:18:35 <Axman6> kstt: i assume you're using strict bytestrings?
02:18:44 <kstt> I do
02:23:49 <kstt> Jafet: the use case is a real world TCP proxy. Not data in the filesystem. Only bytes from incoming connection, then some "business logic" regarding authorization and routing, then bytes sent to outgoing connection (a backend server).
02:23:51 <accel> does haskell have a builtin for: generate all puermutations of length 3 in a lazy list? i.e. [ [0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 0, 1], [2, 1, 0]] ?
02:24:04 <Botje> @hoogle permutations
02:24:04 <lambdabot> Data.List permutations :: [a] -> [[a]]
02:24:25 <Jafet> sendfile works on pretty much any file descriptors, I believe
02:24:45 <Axman6> > map (take 3) .  permutations $ [0,1,2,3]
02:24:47 <lambdabot>   [[0,1,2],[1,0,2],[2,1,0],[1,2,0],[2,0,1],[0,2,1],[3,2,1],[2,3,1],[2,1,3],[3...
02:25:15 <Axman6> > length . nub . map (take 3) .  permutations $ [0,1,2,3]
02:25:16 <lambdabot>   24
02:25:29 <Axman6> > length . map (take 3) .  permutations $ [0,1,2,3]
02:25:30 <lambdabot>   24
02:25:46 <Jafet> For this kind of problem, the real world sort of drags you away from haskell, unfortunately
02:25:52 <Axman6> interesting
02:26:00 <dafis> Axman6: what?
02:26:07 <accel> > [1..9]
02:26:08 <lambdabot>   [1,2,3,4,5,6,7,8,9]
02:26:12 <accel> > permutations [1..9]
02:26:12 <lambdabot>   [[1,2,3,4,5,6,7,8,9],[2,1,3,4,5,6,7,8,9],[3,2,1,4,5,6,7,8,9],[2,3,1,4,5,6,7...
02:26:15 <Axman6> wait, that makes sense in this case...
02:26:19 <Axman6> > length . map (take 3) .  permutations $ [0,1,2,3,4]
02:26:20 <lambdabot>   120
02:26:27 <Axman6> > length . nub . map (take 3) .  permutations $ [0,1,2,3,4]
02:26:28 <lambdabot>   60
02:27:15 <Jafet> > length . nub . map (take 3) . permutations $ [1..9]
02:27:19 <lambdabot>   mueval-core: Time limit exceeded
02:27:24 <Botje> that's a pretty fancy way to calculate C(5,3)
02:28:30 <Jafet> > length . filter ((==3).length) . map nub . sequence . replicate 3 $ [1..9]
02:28:31 <lambdabot>   504
02:28:51 <Jafet> > length . filter ((==3).length) . map nub . sequence . replicate 3 $ [1..20]
02:28:52 <lambdabot>   6840
02:29:38 <accel> whoa, mind blown
02:29:40 <Jafet> > length . filter ((==3).length) . map nub . replicateM 3 $ [1..50]
02:29:40 <accel> new use for 'it'
02:29:42 <lambdabot>   117600
02:29:46 <accel> type any expression, :set +t
02:29:47 <accel> then get it's type
02:29:50 <accel> magical
02:31:29 <Jafet> > length . map head . group . sort . filter ((==3).length) . map nub . replicateM 3 $ [1..50]
02:31:31 <lambdabot>   117600
02:31:57 <Jafet> Oh, right.
02:32:58 <accel> @src interact
02:32:58 <lambdabot> interact f = do s <- getContents; putStr (f s)
02:33:13 <accel> @t interact
02:33:13 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
02:33:20 <accel> :t interact
02:33:21 <lambdabot> (String -> String) -> IO ()
02:33:26 <accel> @src getContents
02:33:26 <lambdabot> getContents = hGetContents stdin
02:36:30 <accel> @type getContents
02:36:30 <lambdabot> IO String
02:36:38 <accel> @type interact
02:36:39 <lambdabot> (String -> String) -> IO ()
02:39:21 <accel> how do I take a file
02:39:26 <accel> and split based on spaces
02:39:28 <accel> i.e. do a word count
02:39:34 <accel> @type split
02:39:34 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
02:39:46 <accel> @type lines
02:39:47 <lambdabot> String -> [String]
02:39:51 <accel> @type words
02:39:51 <lambdabot> String -> [String]
02:42:00 <rsuniev__> @type words
02:42:00 <lambdabot> String -> [String]
02:42:13 <Axman6> > length . words $ "lorum ipsom dolar sit amet"
02:42:15 <lambdabot>   5
02:42:35 * Axman6 'f faux latin spelling is a little rusty
02:43:58 <dafis> accel: you might also be interested in the split package if working with Strings, or some ByteString splitting stuff
02:47:04 <accel> why the fuck would I ever say: (compare 2 3) == LT rather than (2 <= 3) ?
02:47:19 <Axman6> you wouldn't
02:47:51 <Axman6> althought, those two things are not the same, you mean <
02:47:52 <dafis> accel: you'd say case compare x y of { LT -> ...; EQ -> ...; GT -> ... }
02:47:58 <sipa> you'd say compare 2 3 == LT
02:48:02 <sipa> :p
02:48:36 <Axman6> -t
02:49:20 <accel> dafis: nice
03:05:36 <Jafet> > permutations [0..]
03:05:37 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
03:05:58 <shachaf> > subsequences [0..]
03:05:58 <lambdabot>   [[],[0],[1],[0,1],[2],[0,2],[1,2],[0,1,2],[3],[0,3],[1,3],[0,1,3],[2,3],[0,...
03:06:08 <shachaf> Hmm, more useful.
03:06:09 <Jafet> > take 5 <$> permutations [0..]
03:06:10 <lambdabot>   [[0,1,2,3,4],[1,0,2,3,4],[2,1,0,3,4],[1,2,0,3,4],[2,0,1,3,4],[0,2,1,3,4],[3...
03:06:24 <shachaf> Oh, I guess there's that.
03:06:45 <Boxo> @src permutations
03:06:45 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:06:53 <Jafet> Strictly speaking, there is no list of permutations of [0..].
03:07:25 <accel> fuck 
03:07:28 <accel> I just fell in love
03:07:30 <accel> with laziness
03:07:42 <shachaf> Jafet: Why not?
03:07:50 <quicksilver> Jafet: depends if you believe the axiom of choice :)
03:08:04 <quicksilver> you can, at least, start a list.
03:08:05 <Axman6> > (take 5 <$> permutation [0..]) !! 1000
03:08:05 <lambdabot>   Not in scope: `permutation'
03:08:17 <Axman6> > (take 5 <$> permutations [0..]) !! 1000
03:08:18 <lambdabot>   [2,4,1,3,6]
03:08:21 <Axman6> > (take 5 <$> permutations [0..]) !! 100000
03:08:22 <lambdabot>   [8,6,2,1,4]
03:08:26 <Axman6> > (take 5 <$> permutations [0..]) !! 1000000
03:08:27 <lambdabot>   [5,9,2,6,4]
03:08:48 <quicksilver> shachaf: because there are too many.
03:09:16 <Boxo> aha, no _list_
03:09:19 <shachaf> Ah, because a list is always countable?
03:09:36 <shachaf> OK.
03:10:42 <Axman6> > length . nub . take 1000 $  (take 5 <$> permutations [0..])
03:10:44 <lambdabot>   954
03:10:49 <Axman6> > length . nub . take 10000 $  (take 5 <$> permutations [0..])
03:10:51 <lambdabot>   4320
03:11:06 <Jafet> Nice
03:13:00 <accel> how do I make the following work:
03:13:00 <accel> lastButOne :: [a] -> a
03:13:01 <accel> lastButOne (lst ++ x : y : []) = x
03:13:01 <accel> lastButOne _ = error "too short"
03:13:28 <Axman6> ...
03:13:38 <Axman6> ++ is a function, you can't pattern match on functions
03:14:39 <Axman6> > let lastbutOne [x,_] = x; lastButOne (x:xs) = lastButOne xs; lastButOne _ = error "Too short" in lastButOne "Hello"
03:14:40 <lambdabot>   *Exception: Too short
03:14:41 <shachaf> > let foo (not -> True) = a in foo False
03:14:42 <lambdabot>   a
03:14:44 <Axman6> o.O
03:14:52 <Jafet> lastButOne = last . init
03:15:06 * Jafet points and laughs at Axman6
03:15:17 <shachaf> Of course, last . init will walk the list twice.
03:15:18 <Axman6> > let lastButOne [x,_] = x; lastButOne (x:xs) = lastButOne xs; lastButOne _ = error "Too short" in lastButOne "Hello"
03:15:18 <lambdabot>   'l'
03:15:27 <accel> Jafet++
03:15:31 <Axman6> shachaf: should fuse though
03:15:37 <Boxo> > case "abc" of [x,y,_] -> (x,y)
03:15:38 <lambdabot>   ('a','b')
03:15:53 <shachaf> Axman6: Bah, fusion. I'm trying to prematurely optimize here!
03:15:56 <Boxo> is that sugar new?
03:16:02 <Axman6> no
03:16:04 <Jafet> Premature pessimization?
03:16:18 <Axman6> you've always been able to pattern match on list literals
03:16:20 <shachaf> Boxo: What, [] for list literals? It's not.
03:16:46 * Boxo had no idea. Oh well, that's cool.
03:17:00 <shachaf> Well, new in the slightly grander scheme of things, maybe. It wasn't around in that form 50 years ago.
03:17:46 <Boxo> I even remember seeing people post erroneous code that tried to do that, and being told to use (x:xs)
03:18:17 <Axman6> [x,y] matches a list with two elements
03:18:18 <shachaf> Boxo: They were probably trying to do Prolog-style [x:xs] or something like that.
03:18:31 <Axman6> it's the same as the pattern (x:y:[])
03:18:33 <shachaf> Or just doing the "if it's a list I must use brackets somewhere" thing.
03:18:51 <Axman6> shachaf: my first year students do that all the time -_-
03:19:17 <Boxo> And I don't remember _ever_ seeing a tutorial or paper or blog post using pattern matching on list literals
03:19:27 <shachaf> Boxo: Well, they have string literals, right?
03:19:32 <shachaf> Those are list literals. :-)
03:19:38 <Boxo> heh, yes
03:19:49 <shachaf> (How does pattern-matching string literals work with OverloadedStrings, by the way?)
03:20:54 <Axman6> good question
03:21:11 <frerich> Is there a Haskell type for which values cannot be deconstructed using the same value constructor which was used to construct the value?
03:21:34 <Axman6> what? o.O
03:22:11 <frerich> Well, I read this discussion about deconstructing lists, so I wondered whether there is any type which cannot be deconstructed, assuming there is a value constructor in the first place.
03:22:11 <zenzike> frerich: do you mean exporting types but not the constructors?
03:22:29 <Axman6> you can hide constructors
03:22:52 <zenzike> frerich: yep, hide the constructors, and expose a function that can create the value
03:23:00 <Axman6> module Foo (Bar) where data Bar = Baz | Quux
03:23:26 <frerich> Yes, I know that.
03:23:47 <frerich> I meant types for which the value constructor is in scope (i.e. not hidden).
03:24:13 <shachaf> frerich: What sort of situation did you have in mind?
03:25:03 <shachaf> (Also: Watch out, #haskell, a postmodern literary critic is in our midst.)
03:26:03 <frerich> shachaf: Oh, nothing particular. It just surprised me that you would think that you could not pattern match on lists, since you can deconstruct lists. That made me wondering whether there is some strange type which you can construct, but not deconstruct. Like, '(,)' lets you construct 2-tuples, and the same can be used to deconstruct the values (as in 'let (x,y) = f'). Now I was wondering whether there is a type
03:26:03 <frerich>  which has some odd value constructor which can be used to create, but not deconstruct, values.
03:26:17 <Jafet> As long as he doesn't try any deconstructivism in here
03:26:23 <frerich> Maybe ()?
03:27:03 <shachaf> frerich: I don't think anyone was thinking that you could not pattern-match on lists -- just that you couldn't use list literal syntax.
03:27:44 <Boxo> yep
03:29:18 <shachaf> > (1,) 2
03:29:19 <lambdabot>   Illegal tuple section: use -XTupleSections
03:29:25 <shachaf> :-(
03:30:19 <accel> does deriving in "deriving (Show)"
03:30:24 <accel> pretty much require ghc lbackmagic?
03:30:29 <accel> i.e. deriving only works for ghc defined type classes, not user created type classes
03:30:40 <shachaf> accel: Well, it's Haskell, not GHC.
03:30:45 <Jafet> The haskell report defines the derivable type classes. ghc adds a few.
03:30:56 <shachaf> And it can be done automatically for some other type classes with NewtypeDeriving.
03:31:12 <frerich> shachaf: Oh, okay. But still, I'm wondering, can you always use value constructors to also deconstruct values, as in 'data T = T Int Int' but then not being able to use 'f (X 1 2) = 3'? Or is there a way to 'declare' value constructors so that they cannot be used to deconstruct?
03:31:38 <frerich> I wonder whether there is a way to declare constructors to be 'one-way' (except by using 'factory functions' and hiding the constructor in a module).
03:31:40 <Jafet> frerich: yes.
03:31:59 <Jafet> frerich: no.
03:32:15 <frerich> Ok, good, so my world is still intact :-)
03:33:28 <Jafet> Hm, even this is valid: data Wtf = Wtf (forall a. a); f :: Wtf -> a; f (Wtf a) = a
03:33:50 <Jafet> Albeit useless
03:34:22 <shachaf> Jafet: You mean Wtf -> (forall a. a)?
03:34:39 <shachaf> Er.
03:34:49 <Jafet> forall a. Wtf -> a, whatever
03:34:50 <shachaf> Ignore me, please.
03:35:07 <Jafet> (Is there a difference?)
03:35:43 <dafis> > toRational (pi :: CReal)
03:35:43 <lambdabot>   *Exception: CReal.toRational
03:35:49 <hvr> I'm wondering whether the issue in  http://www.haskell.org/pipermail/haskell-cafe/2011-April/090673.html  is a GHC bug
03:35:49 <dafis> boo
03:37:38 <shachaf> Jafet: Anyway, the only suspicious thing about that is the construction, not the deconstruction.
03:38:45 <frerich> Hm, anybody on Windows here? I just noticed I can reliably push ghci into a panic when starting ghci and then pressing Ctrl+C and <Cursor+Up> in some random order.
03:38:58 <Jafet> It's a known bug
03:39:42 <Jafet> 1) Don't Do That 2) use rxvt
03:40:09 <Saizan> hvr: what about -N11 ?
03:40:46 <hvr> Saizan: I'll try it
03:41:39 <hvr> Saizan: but looks the same... 1 thread has 100%, the remaing ones use up 70% cpu/core time each
03:42:48 <Saizan> hvr: ah, ok, i was wondering if this was the "last core slowdown" due to some spinlocks
03:43:33 <hvr> Saizan: doesn't seem so... looks the same in threadscope as well
03:45:15 <enthymeme> so, I'm working my way through the Haskell 98 tutorial, and I'm having trouble with readsTree.  Any time I try reads  "1", or readsTree "<1|2>", or (read . show) GHCi responds with "ambigulous type variable in the constraint: `Read a' arising from use of `read' at <where I invoked read>. Possible fix: add a type signature that fixes these type variables."  Any ideas?  Should I not be expecting this to work?
03:46:25 <Jafet> Well, you have to tell read what kind of thing it's suppose to read.
03:46:34 <Jafet> > read "123" :: Int
03:46:35 <lambdabot>   123
03:46:45 <Jafet> > read "123" :: String
03:46:46 <lambdabot>   "*Exception: Prelude.read: no parse
03:49:09 <pacak> > read "\"123\"" :: String
03:49:09 <lambdabot>   "123"
03:49:17 <enthymeme> hmm 
03:50:13 <zenzike> so presumably the problem is that your tree is polymorphic in its values, and you haven't told it it's a tree of Ints?
03:50:42 <enthymeme> okay
03:50:57 <enthymeme> well, now I'm getting the no parse exception.  This is an improvement.
03:51:49 <zenzike> I'm guessing you want something like: (readsTree "<1|2>" :: Tree Int)
03:52:12 <enthymeme> yes, that works
03:52:20 <enthymeme> or actually
03:52:48 <enthymeme> (readsTree "<1|2>" :: [(Tree Int, String)])
03:53:17 <zenzike> ah yes, it returns the remaining unparsed string as well
04:03:26 <Boxo> > read "123" --  error because no type
04:03:27 <lambdabot>   *Exception: Prelude.read: no parse
04:03:57 <dafis> hehe fooled by defaulting
04:05:14 <quicksilver> fooled by extended defaulting in lambdabot
04:06:39 <pacak> > length $ read "[1,2,3,4]"
04:06:40 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:06:40 <lambdabot>    `GHC.Read.Read a'
04:06:40 <lambdabot>      ar...
04:07:34 <Boxo> > length $ read "[]"
04:07:35 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:07:35 <lambdabot>    `GHC.Read.Read a'
04:07:35 <lambdabot>      ar...
04:08:05 <quicksilver> the extended default kicks in if the whole xpression has free type variables
04:08:16 <quicksilver> it doesn't stop subexpression type variables being ambiguity errors
04:11:10 <Jonno_FTW> :t []
04:11:11 <lambdabot> forall a. [a]
04:13:34 <zenzike> quicksilver: I'm confused. What's extended defaulting?
04:16:48 <quicksilver> > read "()"
04:16:48 <lambdabot>   ()
04:17:07 <Jonno_FTW> :t [[]]
04:17:08 <lambdabot> forall a. [[a]]
04:17:12 <Jonno_FTW> :t [()]
04:17:12 <lambdabot> [()]
04:17:13 <quicksilver> zenzike: that, basically. it defaults things to () if the numeric defaulting doesn't apply.
04:17:50 <zenzike> oic
04:18:50 <quicksilver> zenzike: the standard haskell response to (read "()") would be ambiguous type variable
04:20:05 <zenzike> yeah, I've got it. I didn't realise that defaulting was possible beyond numeric types
04:29:05 <quicksilver> zenzike: it's not
04:29:09 <quicksilver> zenzike: it's a GHC extension :)
04:29:17 <quicksilver> I'm not sure it's particularly useful to be honest
04:29:20 <quicksilver> but it's on in lambdabot
04:31:23 <dafis> and in ghci
04:31:48 <quicksilver> dafis: it's not on in my ghci
04:31:58 <quicksilver> at least, read "()" gives an error for me, there.
04:32:31 <dafis> you can turn it off, I suppose, but it's on by default
04:32:43 <quicksilver> depends on version perhaps?
04:32:46 <dafis> read "()" works here (7.0.2)
04:32:48 <quicksilver> I'm not aware that I configured anything.
04:33:05 <quicksilver> apparently I'm on 6.12.1
04:33:21 <quicksilver> I wonder what the motivation for having it on is. Is it actually useful for something?
04:33:34 <dafis> works in 6.12.1 here too
04:33:58 <quicksilver> then I really don't understand.
04:34:01 <dafis> quicksilver: it reduces the "ambiguous type variable ..." errors in ghci
04:34:13 <quicksilver> but only in cases where the type variable is free
04:34:24 <quicksilver> it doesnt' solve the hard ones like length $ read "[]"
04:34:30 <quicksilver> > length $ read "[]"
04:34:31 <lambdabot>   Ambiguous type variable `a' in the constraint:
04:34:31 <lambdabot>    `GHC.Read.Read a'
04:34:31 <lambdabot>      ar...
04:34:39 <quicksilver> does it solve any case that anyone would actually care about?
04:34:46 <dafis> quicksilver: yes, it reduces, it doesn't eliminate
04:34:53 <quicksilver> hmm
04:35:12 <dafis> quicksilver: whether it solves any case you'd care about, I've no idea
04:35:15 <quicksilver> interesting, [] == [] works for me.
04:35:31 <quicksilver> I don't know why that works.
04:35:45 <dafis> extended defaulting
04:36:02 <dafis> but read "()" doesn't work? Odd
04:36:07 <quicksilver> I thought defaulting only applied when the type variable was free in the result type?
04:36:35 <dafis> don't think so, lemme check the report
04:37:03 <Saizan> read "()" doesn't work here on 7.0.2
04:37:13 <vegai> 512MB + 256MB swap is not quite enough for building highlighting_kate ....
04:37:51 <Saizan> hah, it works with NoMR
04:37:52 <dafis> We say that an expression e has an ambiguous type if, in its type ∀ u. cx  ⇒  t, there is a type variable u in u that occurs in cx but not in 
04:38:18 <dafis> the a in forall a. Eq a => Bool is free
04:38:50 <quicksilver> but that is not a well-formed type.
04:39:02 <dafis> Saizan: that's probably it, I turn off MR in .ghci
04:39:02 <quicksilver> the type of ([] == []) can only be Bool
04:39:25 <quicksilver> however, to arrive at that type at all you need to select a type for the inner lists
04:39:44 <quicksilver> I thought this was an exacmple of something that extended defaulting *didn't* solve
04:39:47 <quicksilver> so, now I'm confused :)
04:40:07 <dafis> quicksilver: that's the point, it's not a well formed type due to an ambiguous type variable, so that's precisely where defaulting kicks in
04:40:52 <zenzike> ah, that's clever. so it can instantiate [] ::  [()] and resolve the Bool
04:41:15 <quicksilver> but if that works, then (show $ read "[]") should work the same way.
04:41:17 <quicksilver> surely
04:41:20 <quicksilver> and it doesn't.
04:41:21 <dafis> since Eq doesn't involve a numeric class, it's not defaulted by the report rules, but by the extended rules, a defaults to ()
04:41:40 <quicksilver> oh yes it does
04:41:58 <zenzike> > show $ read "[]"
04:41:58 <lambdabot>   "*Exception: Prelude.read: no parse
04:41:59 <quicksilver> it doesn't default to [()] it defaults to "()"
04:42:03 <dafis> Prelude> show (read "[]")
04:42:03 <dafis> "*** Exception: Prelude.read: no parse
04:42:07 <quicksilver> it works with "()"
04:42:07 <dafis> MR off
04:42:21 <quicksilver> because it's defaulting to () and [ is a 'no parse' for ()
04:42:31 <quicksilver> > show (read "()")
04:42:31 <lambdabot>   "()"
04:42:39 <quicksilver> dafis: thank you. I have learnt something.
04:42:54 <quicksilver> although I still don't quite see why this behaviour is desirable :)
04:42:58 <zenzike> hm, very nice
04:43:04 <quicksilver> but I do at least understand that it is what makes [] == [] work.
04:43:12 <dafis> quicksilver: it's not unconditionally desirable
04:44:02 <quicksilver> dafis: but is it ever desirable? Does this make ghci a better environment for working, or does it just increase confused conversations like the one we have just had? :)
04:44:07 <dafis> without it, you'd need more type signatures at the ghci prompt, but with it, you face surprising answers sometimes
04:44:17 <zenzike> > show (read "[]" :: [a])
04:44:18 <lambdabot>   Could not deduce (GHC.Read.Read a) from the context ()
04:44:18 <lambdabot>    arising from a us...
04:44:30 <zenzike> > show (read "[]" :: [()])
04:44:31 <lambdabot>   "[]"
04:45:01 <quicksilver> by naming "a" explicitly in a type sig you have turned off defaulting, I believe.
04:45:07 <dafis> quicksilver: I don't know whether it's a gain on the whole, you could ask GHC HQ why it's there/on by default in ghci
04:45:12 * quicksilver nods
04:46:09 <dafis> > []
04:46:10 <lambdabot>   []
04:46:38 <Saizan> non-qualified types are another matter
04:46:51 <dafis> quicksilver: that's one point where report defaulting leads to far more surprising behaviour (for beginners at least)
04:47:32 <quicksilver> dafis: ah, yes. that's probably a better example.
04:47:40 <quicksilver> it's a bit annoying not being able to type [] at the prompt
04:48:25 <Saizan> i guess you always end up with at least a Show constraint
04:49:25 <dafis> yes, the ghci loop calls print, so
04:49:43 <Saizan> maybe the type it defaults to should only have a Show instance
04:49:48 <dafis> (unless you type an IO action at the prompt)
04:50:29 <quicksilver> technically I think the ghci loop tries three types
04:50:38 <quicksilver> Show a => a, Show a => IO a, and plain IO a
04:51:04 <quicksilver> if it type checks as any of those three types then it does the appropriate thing
04:51:15 <dafis> quicksilver: what would it do for Show a => IO a?
04:51:26 <dafis> return?
04:51:27 <quicksilver> it executes it and then shows the result
04:51:39 <zenzike> is there a way to disable the extended-default-rules in ghci?
04:51:41 <quicksilver> try it with getLine
04:51:50 <zenzike> (or any enabled rules for that matter)
04:51:59 <quicksilver> actually IO () is a special case as well
04:52:19 <quicksilver> so I think it tries (probably in this order) IO (), Show a => IO a, IO a, Show a => a
04:53:19 <dafis> zenzike: :set -XNoExtensionYouDontWant has a good chance of working
04:53:43 <quicksilver> which you can put in your ghci
04:53:52 <quicksilver> -XNoExtendedDefaulting
04:54:00 <quicksilver> (or is it ...Defaults at the end?)
04:54:59 <dafis> methinks, DefaultRules
04:55:57 <dafis> Prelude> :set -XNoExtendedDefaultRules
04:55:57 <dafis> Prelude> read "()"
04:55:58 <dafis> <interactive>:1:1:
04:55:58 <dafis>     Ambiguous type variable `a0' in the constraint:
04:55:58 <dafis>       (Read a0) arising from a use of `read'
04:55:58 <dafis>     Probable fix: add a type signature that fixes these type variable(s)
04:56:00 <dafis>     In the expression: read "()"
04:56:02 <dafis>     In an equation for `it': it = read "()"
04:57:36 <dafis> but only with MR off, and then it doesn't work anyway
04:58:57 <andras> hello chaps and gals
05:00:28 <andras> quick question: I need to read a PNG file (probably only 16-bit greyscale, but maybe others too) and need pixel-wise access to it (2D array of Ints for example). How do I do that with the least amount of effort? Can anyone point me to the right module?
05:02:53 <jlouis> andras: array or dict
05:03:00 <jlouis> argh, wrong channel
05:03:19 <jlouis> andras: do you need access in a pure environment, in a monad or ?
05:04:00 <Eduard_Munteanu> andras: I've used Gtk2Hs' glib bindings for that, might suit you if you're using it anyway.
05:04:04 <jlouis> One (generic, O(lg n)-lookup) way is to store everything in a Data.Map (Int, Int) Pixel
05:04:23 <jlouis> Data.Map.Map
05:04:31 <Eduard_Munteanu> But yeah, you've gotta be in IO.
05:04:44 <sipa> import qualified Data.Map as Map
05:04:58 <Eduard_Munteanu> (although you can get an array of pixels from it)
05:05:16 <aristid> @src many
05:05:16 <lambdabot> Source not found. Where did you learn to type?
05:06:28 <andras> jlouis: data should be available in pure environment (I try to do IO in monads only if I can)
05:06:42 <jlouis> If you are willing to go into IO or the like, then STUArray: http://hackage.haskell.org/package/array-0.3.0.2 is an option
05:06:59 <jlouis> The ST monad is the middle-ground that avoids IO
05:07:08 <andras> Eduard_Munteanu: thanks, good idea -- I guess you mean the gdk-pixmap part or whatever it's called
05:07:59 <Eduard_Munteanu> Yes.
05:08:29 <Eduard_Munteanu> jlouis: I think he's also asking how to decode the PNG.
05:08:43 <jlouis> Eduard_Munteanu: I am not even there yet
05:08:52 <Eduard_Munteanu> Ah :)
05:08:55 <jlouis> but yeah, decoding the PNG is also a hassle
05:09:40 <jlouis> aristid: many is (at least) present in Parsec
05:09:56 <Eduard_Munteanu> @hoogle many
05:09:56 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
05:09:56 <lambdabot> Text.Parsec.Prim many :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
05:09:56 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
05:09:58 <aristid> jlouis: i meant the version from Control.Applicative.
05:10:11 <aristid> i found the source anyways :)
05:10:33 <jlouis> Eduard_Munteanu: there are also the repa and accelerate libraries to check :)
05:10:48 <jlouis> unfortunately, the module system of Haskell is weak
05:11:16 <Eduard_Munteanu> For arrays in general? I remember taking a look at REPA though.
05:11:30 <Eduard_Munteanu> Though it looks like some sort of DPH.
05:11:34 <jlouis> it is
05:11:51 <jlouis> I'd go parallel quickly these days :)
05:12:29 <frerich> hmm, is Parsec the de-facto standard when it comes to parsing data in Haskell? I'm looking for a simple way to replace some stupid "parsers" I have which take a string "1,2" and turn it into an (1,2) tuple by doing 'read $ "(" ++ s ++ ")" :: (Int, Int )'. I'd like to be handle whitespace  before/after the digits to be ignored, and to have good ways to handle invalid values (or even letters). I wonder whether I
05:12:29 <frerich>  should use Parsec for this or whether that'd be overkill.
05:13:18 <aristid> frerich: Parsec will probably make your code shorter and more readable, so I don't think it would be "overkill" :)
05:14:06 <pozic> and slower.
05:14:30 <pozic> If you want fast, fast, fast, use a different language/library/no library.
05:14:51 <pozic> If you want to have goals like maintainability, then Parsec is a fine choice.
05:15:02 <pozic> If you want both, build a compiler for Parsec.
05:15:19 <aleator> Slower than show+read?
05:15:31 <aleator> or concat+read
05:15:52 <aleator> There is also attoparsec for speed concerned.
05:16:24 <frerich> No, speed is not a concern (this is for parsing user input which in an text-mode game). So 'makes code shorter and more readable' sounds great :-)
05:16:32 <frerich> I just never did anything with Parsec.
05:17:44 <aristid> speed is rarely the most important concern.
05:19:15 <Eelis> preflex: seen taruti
05:19:15 <preflex>  taruti was last seen on #go-nuts 2 hours, 3 minutes and 24 seconds ago, saying: edsrzf: yes.
05:19:38 <taruti> Eelis: yes?
05:20:06 <Eelis> taruti: was just checking :) i do have an issue with HFuse, but the details are on my computer at home. i'll drop you a mail tonight
05:20:15 <taruti> ok
05:20:48 <Eduard_Munteanu> BTW, what's the status of DPH?
05:21:15 <Eduard_Munteanu> aristid: it has been often enough for me :/
05:21:30 <aristid> Eduard_Munteanu: what do you do? :)
05:21:56 <dafis> Eduard_Munteanu: speed comes after correctness, I'd think
05:21:59 <Eduard_Munteanu> Well, I hit performance snags in lots of situations.
05:22:14 <dafis> but it can be a very close second
05:22:27 <aristid> Eduard_Munteanu: yeah, but what do you do? :P
05:22:45 <aristid> Eduard_Munteanu: like, what kinds of programs do you write that hit these problems?
05:24:14 <Eduard_Munteanu> Stuff that's CPU-bound. Either implementing some compression algo, or writing a HXT parser to extract stuff from HTML, or writing a cellular automata simulation. I'm just enumerating a few situations where it caused me grief ;)
05:25:09 <Eduard_Munteanu> I'm sometimes disappointed when I make a really naive C implementation that's a lot faster than Haskell stuff :)
05:25:36 <dafis> Eduard_Munteanu: then don't
05:25:39 <Jafet> You then proceed to tidy it up and call it from ffi
05:26:48 <Eduard_Munteanu> It took me a couple of days to get that Huffman performing < 3x slower in Haskell than naive C code. :)
05:27:31 <quicksilver> Eduard_Munteanu: still, we wre talking about parsing
05:27:41 <quicksilver> it's fairly unusual for parsing to be a CPU bottleneck in a system
05:27:50 <Eduard_Munteanu> Jafet, dafis: well yeah, but HXT is really bad in some cases. I wanted to write it in Haskell to save time, but instead I hit performance problems.
05:27:59 <quicksilver> (although you can think of cases when it could be, like high volume network server)
05:28:23 <Eduard_Munteanu> (I didn't do a C implementation for that.)
05:29:45 <Eduard_Munteanu> Or maybe it's because I'm coming from a background where I wonder whether to stuff 'likely()' on a branch ;)
05:39:11 <Jailbat> hi, is somebody here familiar with BNFC?
05:43:14 <Eelis> taruti: managed to access my home machine after all. mind if i privmsg you?
05:43:25 <opqdonut> anyone care to guess how the performance of UArray Int Word8 and ByteArray# differ?
05:44:43 <dafis> opqdonut: if you use unsafeAt for UArray Int Word8, there should be hardly any difference
05:45:13 <taruti> Eelis: feel free to.
05:46:28 <dafis> opqdonut: but if a few% matter, ByteArray# is normally a bit faster
05:46:54 <dafis> (in my [limited] experience)
05:47:29 <opqdonut> yeah, okay
05:49:57 <zenzike> quicksilver: backtracking to our earlier discussion about default rules, did you mean that tying [] in ghci only works because of the extended defaults?
05:50:07 <zenzike> *typing
05:50:15 <quicksilver> zenzike: yes
05:50:30 <quicksilver> because [] isn't showable unless the type of the list is showable
05:50:33 <zenzike> quicksilver: strange, because I just tried :set -XNoExtededDefaultRules and it works
05:50:34 <quicksilver> :t show []
05:50:35 <lambdabot> String
05:50:45 <quicksilver> zenzike: interesting.
05:50:53 <quicksilver> zenzike: yet another thing I don't understand then :)
05:51:02 <zenzike> quicksilver: me neither :-)
05:51:23 <zenzike> quicksilver: I would've thought that it would resolve to having type forall a. [a[
05:51:31 <dafis> zenzike: I experimented a bit, and it seems you can't turn off extended defaulting rules in ghci
05:51:31 <Jafet> Default defaulting
05:51:46 <quicksilver> znutar: [] on its own is forall a . [a] which is fine
05:51:47 <zenzike> dafis: ah, but it doesn't report failure?
05:51:52 <dafis> at least, I got that impression
05:52:07 <quicksilver> zenzike: but (show []) is asking for Show a => [a]
05:52:09 <dafis> zenzike: no, it stays silent
05:52:16 <quicksilver> zenzike: and typing it at the ghci prompt is asking it to show it
05:52:17 <zenzike> dafis: ie it doesn't moan that it didn't succeed in turning it off. strange. is there a way of asking ghci which extensions are turned on?
05:53:11 <dafis> zenzike: haven't found one, check the user's guide
05:59:56 <zenzike> dafis: hm. methinks ghci is being a bit buggy here. using :set tells you which flags are enabled, and :set -fextended-default-rules doesn't list it as set
06:01:27 <zenzike> quicksilver: ah you were right after all: if you launch ghci with -fno-extended-default-rules it can't handle [] alone
06:02:20 <dafis> zenzike: but it doesn't report NoMonomorphismRestriction for me either
06:02:28 <zenzike> quicksilver: oh no, ignore me completely, I was reading the wrong message
06:02:58 <zenzike> dafis: hm. seems broked
06:42:46 <b52> is the author of learn you a haskell idling here?
06:43:12 <Saizan> preflex: seen BONUS
06:43:12 <preflex>  BONUS was last seen on #haskell 1 day, 3 hours, 46 minutes and 50 seconds ago, saying: :)
06:43:13 <Eduard_Munteanu> Yeah, BONUS.
06:44:00 <b52> ah ok, do you know what the bonus swag is you got if you order the book using the code?
06:44:15 <b52> i bought it yesterday :D
07:17:24 <mogui247> join #js
07:19:49 * hackagebot seqloc 0.2 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.2 (NicholasIngolia)
07:21:49 * hackagebot seqloc-datafiles 0.1 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.1 (NicholasIngolia)
07:46:23 <MasseR> The nice thing about haskell is that shorter code is usually simpler and more readable.
07:46:34 <MasseR> On OO languages the opposite usually holds
07:47:37 <napping> why?
07:47:45 <napping> longer variable names
07:47:47 <napping> ?
07:48:16 <MasseR> napping: Subclassing, decorator patterns, etc etc
07:48:25 <vegai> oh, 768M virtual memory actually is not enough to build highlighting_kate :-/
07:48:30 <napping> That makes programs clearer?
07:48:47 <MasseR> napping: Hmm.. Maybe not clearer, but better to manage
07:49:03 <MasseR> Lessens the coupling, increases cohesion
07:49:29 <napping> A big thing I notice is that higher syntactic overhead means functions have to be used more times before it actually shortens the code to make them explicit
07:49:47 <lhdc> hi guys, what are the main applications of haskell?
07:50:02 <napping> xmonad is a main application
07:50:21 <anincog> lhdc: Solving a problem you can think of :)
07:50:46 <tromp> ghc is the main application:)
07:51:06 <MasseR> napping: Yup that too. I just refactored my code. Higher level superclasses, which are then specialized with subclasses. My lines of codes increased, but hopefully if in the future I need to expand, it is simpler at that point
07:51:25 <napping> Some of that is just language choice, I think
07:51:41 <MasseR> napping: Php :<
07:52:04 <napping> I didn't know tha had objects
07:52:15 <MasseR> Since php 4 or 5
07:52:27 <napping> certianly Java has more syntactic overhead than necessary
07:52:30 <MasseR> It even has some functional constructs and as of 5.3 lambdas:P
07:53:10 <MasseR> On an entirely different note; how long does it usually take to get hackage credentials?
07:53:52 <lhdc> :D I don't know Haskell yet so I meant to ask about its usage
07:54:05 <MasseR> lhdc: Generic
07:54:25 <lhdc> MasseR: seems to me that it's mostly for academic environment?
07:54:27 <dafis> lhdc: whatever you want to do in Haskell
07:54:31 <MasseR> lhdc: Nope
07:54:50 <MasseR> lhdc: Web programming, Gui software, note taking applications, you name it
07:54:54 <dafis> well, it comes from an academic background
07:54:55 <lhdc> MasseR: Can you write graphical games, or server application with haskell?
07:55:22 <MasseR> lhdc: There are some graphical games (with cats!), and there are irc servers, http servers and the like
07:55:23 <napping> http://www.geocities.jp/takascience/haskell/monadius_en.html
07:55:51 <napping> server stuff works particularly nicely
07:55:54 <MasseR> lhdc: Actually, check hackage (I presume some nifty guy will give some @command which makes lambdabot give url)
07:56:05 <MasseR> @hackage
07:56:05 <lambdabot> http://hackage.haskell.org
07:56:07 <MasseR> \o/
07:56:36 <MasseR> There's a couple of thousands of projects made in haskell
07:56:59 <lhdc> MasseR: will do. thanks
07:57:02 <napping> lightweight threads whose IO is implicitly gathered with epoll, actual SMP runtime, and nice concurrency primitives like STM
07:58:23 <lhdc> napping: looks lke a fun game , the font is terrible though
07:58:57 <napping> everything jiggles around, actually
08:02:02 <Taslem> When recursively calling a function with an incrementing value, is it better to do:         f (x+1),   or  f (succ x)  ?
08:02:12 <byorgey> it doesn't matter.
08:02:21 <byorgey> whichever one you find more readable/natural.
08:02:42 <Taslem> Yeah, I guess. I was wondering if there were standards for that sort of thing. :/ 
08:03:00 <Eduard_Munteanu> 'succ' is more convenient in point-free, like    g . f . succ $ x
08:03:10 <Saizan> it could matter, since succ uses Enum while (+1) Num
08:03:15 <Saizan> ?ty succ
08:03:15 <lambdabot> forall a. (Enum a) => a -> a
08:03:56 <tromp> > succ False
08:03:57 <lambdabot>   True
08:04:23 <tromp> > map succ "succ"
08:04:24 <lambdabot>   "tvdd"
08:04:41 <tromp> > map succ "HAL"
08:04:41 <lambdabot>   "IBM"
08:05:08 <Taslem> Well, in my case, it has to be a number anyways.
08:05:28 <Taslem> Because I'm using it to access locations in lists.
08:06:13 <lhdc> which is faster x + 1 or succ x?
08:06:25 <c_wraith> should be the same, with optimizations on
08:07:05 <tromp> then it may be simpler to keep sublist rather than index
08:07:22 <tromp> and replace (+ 1) by tail
08:08:57 <napping> that may actually be significantly faster than !!
08:09:09 <Taslem> I can't, because the list is not iterated through. It has to return to pint over and over..
08:09:36 <Taslem> And if the entire list isn't stored, it would have difficulty getting back to where it needs to be.
08:10:22 <Eduard_Munteanu> Maybe you don't want a list?
08:10:33 <napping> then you can pass the whole list and a tail of the list, if you just need to repeat it
08:10:39 <napping> or perhaps even cycle it
08:10:43 <Taslem> It's a sequence of commands for an imperative-type language.
08:10:53 <Taslem> It codes for world data in a project I'm working on.
08:11:04 <napping> oh, you should definitely do something like tail then
08:11:40 <napping> or rather, define the appropriate monad
08:11:51 <Taslem> No, won't work, like I said. It includes "jumps" across the "program" that it reads, so it has to keep track of the entire program.
08:12:13 <napping> so Cont
08:12:20 <Taslem> So I'd either need a data type to store both ends (what it's seen already, and what it hasn't) or add another argument, or use what I'm doing.
08:12:48 <Taslem> Cont would be useless.
08:13:55 * hackagebot attoparsec-text 0.8.5.0 - Fast combinator parsing for texts  http://hackage.haskell.org/package/attoparsec-text-0.8.5.0 (FelipeLessa)
08:14:25 <anincog> Suppose f :: a -> b is really expensive to evaluate. Suppose also that I have a list l :: [a] wherein most elements are in fact  x :: a. I'm interested in computing  map f l  -- what techniques should I employ to avoid calculating f x over and over again?
08:15:07 <napping> Cont provides jumps, but do you really have wild jumps, or more structured control?
08:15:25 <Taslem> They're not wild.  They're a bit like "function calls" and a bit like "GOTO's".
08:15:58 <Taslem> And then it takes the result and uses it. Along with passing other arguments to the recursion whose result it uses to continue evaluating.
08:16:08 <Boxo> anincog: there's the function nub, and there's the technique called memoization
08:16:56 <napping> for math, maybe a Map from labels to instructions
08:17:17 <Taslem> It's not a programming language, it's symbolic manipulation of objects.
08:17:23 <Taslem> So there isn't any form of math.
08:17:39 <anincog> Boxo: nub won't quite do, because in reality my problem is much more complex than what I've told so far :-)   Regarding memoization, I was under the impression that that technique mostly applies to recursive functions?
08:17:40 <napping> I meant "that"
08:17:55 <anincog> Boxo: Common subproblem elimination, if that's what it's called
08:18:10 <tromp> use Data.Map , anincog
08:18:14 <Taslem> Anin? Could you explain what it is that you're using this for?
08:18:30 <Taslem> FOr instance, whether or not f :: a -> b    recurses deeply?
08:19:02 <napping> anincog: Memoization usally involves recursive functions because that's usually how you end up calling f a bunch of times with the same input. If you already have that in your input data it might be helpful anyway
08:19:11 <anincog> I'll try to elaborate a bit, give me a second
08:21:16 <anincog> Let S be a finite set. Assume that f (not the same f as before) takes a subset T of S, and produces a number based on some heavy non-recursive calculations depending on T. Now, circumstances dictate that in fact many of subsets of S that f is given overlap, and this in turn means that many of the aforementioned heavy calculations would be repeated
08:21:32 <anincog> I'm trying to make sure that these are only calculated once
08:22:25 <Taslem> You could keep a list of all of those already calculated, so you can search the list for your results.
08:22:51 <Taslem> So,    f :: [(a,b)] -> [a] -> [b]
08:23:03 <anincog> Taslem: That was my first idea aswell (except I kept a map). The problem is that I then have to pass around this "state" all the time
08:23:56 <iancal> Is it possible to make a data type that looks something like this data Tree a = Leaf a | Node (a -> a -> a) (Tree a) (Tree a) ? At the moment I've got  data Tree a = Leaf a | Node BinaryOp (Tree a) (Tree a) and then match the BinaryOp, but would like to stick functions in
08:24:11 <sipa> try ir
08:24:14 <sipa> try it
08:24:15 <anincog> Taslem: in that case, whatever calls f would need to keep explicit track of which values are already calculated, right?
08:24:33 <Taslem> Yes, it would.
08:24:38 <anincog> I guess it would work out fine, but I'm sort of left with a feeling there should be some sort of memoization-like way of doing this
08:25:00 <anincog> like creating an infinite lazy list of all possible values of f
08:25:03 <Taslem> I believe this really is memoization, it's just a bit convoluted since there's little to no recursion.
08:25:11 <napping> A lazy memo structure might not work so well with subsets
08:25:13 <anincog> yes, that's the feeling I have aswell
08:25:28 <Taslem> Are you sure Haskell doesn't already optimize for it?
08:25:56 <anincog> Taslem: yep, I tried :)
08:26:00 <napping> almost certainly not, if it's just a big expression with repeated subtrees
08:26:04 <anincog> Taslem: checked using the profiler
08:26:26 <Taslem> Well, you can still try out the way I suggested. It really isn't that difficult to write out.
08:26:31 <iancal> sipa: :O I'm a fool, I tried that yesterday but it was throwing errors I couldn't understand, I must have got something else wrong in my usage. Thanks!
08:26:36 <anincog> Taslem: I think I will... thanks :)
08:26:42 <anincog> but I agree that it feels somewhat convoluted
08:26:54 <anincog> I just can't quite put my finger on why non-recursion should make it so
08:27:39 <anincog> napping: I lied a bit again, it's not really all subsets... in practice it's really all n-tuples for a low, fixed n
08:28:09 <napping> oh, that's actualy easier to index reasonably
08:28:22 <napping> you can't explicilty prune the memo table that way, though
08:28:49 <anincog> I don't think they'll need to be pruned actually. It's highly unlikely that a certain lookup won't be needed again
08:28:56 <anincog> (if that's what you mean)
08:29:52 <napping> http://hackage.haskell.org/package/MemoTrie
08:30:35 <Taslem> Here's a simple, yet-untested implementation of the function I was talking about. http://pastebin.com/JqRmAdPE
08:31:55 <anincog> napping: I've actually already tried MemoTrie (pun not intended). The problem is, does it work in non-recursive situations?
08:32:19 <napping> sure
08:33:02 <napping> you just have to make sure that the trie a :-
08:33:09 <anincog> napping: So if f True = False, f False = True, then map (memo f) (replicate 10 True) should result in f only being called once?
08:33:15 <napping> you just have to make sure that the trie a :->: b is defined high enougn to be shared
08:33:45 <anincog> Taslem: Thanks, looking!
08:33:45 <napping> so that would fail because memo is building separate tables, but let f' = memo f in map f' l should wokr
08:34:01 <anincog> napping: Ah, d'oh!
08:34:25 <anincog> I think my understanding of functional memoization has been severely hampered by discovering that what I wrote above does not work as expected :(
08:34:32 <anincog> (it derailed me many hours ago)
08:34:40 <napping> that gives you at least some control over how big the memo tables get
08:35:24 <napping> well, I guess it's not entirely guaranteed that GHC won't move that round
08:35:46 <anincog> napping: Yay, that worked beautifully. At this point I think I have to step back and rethink everything, because it's clear that I was just confused from the beginning :)
08:35:48 <napping> I wouldn't be too surprised if -O2 hoisted the memo tabe and made your map fast
08:36:24 <anincog> napping: actually, I too assumed that O2 would fix any such problems, so when things didn't work, I naturally assumed I had completely misunderstood memoization
08:36:35 <anincog> (read: O2 didn't do it)
08:38:14 <anincog> thanks for clearing things up for me
08:46:02 * hackagebot libmpd 0.6.0 - An MPD client library.  http://hackage.haskell.org/package/libmpd-0.6.0 (JoachimFasting)
08:50:17 <rnik> Hi... how would you turn a "[(a, IO b)]" into a "IO [(a,b)]" ? 
08:50:44 <rnik> Is there a standard way to do it?
08:50:52 <rnik> Things like that.
08:51:09 <opqdonut> unzip and sequence
08:51:59 <opqdonut> :t \xs -> let (as,bs) = unzip xs in fmap (zip as) $ sequence bs
08:51:59 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => [(a, f b)] -> f [(a, b)]
08:52:02 <Saizan> mapM (\(a,b) -> fmap ((,) a) b)
08:52:10 <pumpkin> strength and sequence
08:52:23 <opqdonut> or what Saizan said
08:52:51 <dafis> pumpkin: strength?
08:53:03 <Saizan> ?type uncurry $ fmap . (,)
08:53:04 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a, f a1) -> f (a, a1)
08:53:04 <pumpkin> the thing that Saizan mapM'd
08:53:26 <McManiaC> http://n-sch.de/hdocs/mstate/Control-Concurrent-MState.html#v:runMState <- are the descriptions for runMState/evalMState/execMState clear? :S
08:53:30 <pumpkin> @let strength = uncurry $ fmap . (,)
08:53:31 <lambdabot>  Defined.
08:53:40 <pumpkin> :t Data.Traversable.traverse strength
08:53:40 <lambdabot> forall a (f :: * -> *) a1 (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => t (a, f a1) -> f (t (a, a1))
08:54:04 <applicative> why is it called strength??
08:54:22 <pumpkin> http://en.wikipedia.org/wiki/Strong_monad
08:54:30 <dafis> thx
08:55:42 <rnik> Cool.  thanks.
08:56:34 <applicative> they've thought of everything, it seems
08:57:56 <pumpkin> in haskell they're all strong
08:58:03 <pumpkin> but in other categories they might not be
08:59:27 <applicative> there's always t :: (a,m b) -> m (a,b)  
08:59:45 <applicative> @type strength
08:59:45 <pumpkin> for Functor m
08:59:45 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a, f a1) -> f (a, a1)
09:00:14 <applicative> right you only needed fmap
09:00:41 <zeus_> haha this is too much
09:01:07 <hpc> isn't that flip?
09:01:22 <hpc> :t flip
09:01:23 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:01:32 <hpc> oh, it isn't
09:02:19 <Saizan> ?ty fmap id . strength
09:02:20 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => (a, f a1) -> f (a, a1)
09:02:34 <Saizan> ?ty fmap (uncurry id) . strength
09:02:34 <lambdabot> forall b c (f :: * -> *). (Functor f) => (b -> c, f b) -> f c
09:02:54 <Saizan> ?ty fmap (uncurry (flip id)) . strength
09:02:54 <lambdabot> forall a c (f :: * -> *). (Functor f) => (a, f (a -> c)) -> f c
09:03:01 <rtharper> :t strength
09:03:01 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a, f a1) -> f (a, a1)
09:03:54 <lpsmith> http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:UTCTime
09:04:19 <lpsmith> The haddocks say there is a Show instance for UTCTime,  but where is it located?
09:04:31 <vegai> any ideas when haskell-platform will follow ghc-7.0.3?
09:04:46 <monochrom> If you import all of Data.Time, you get it.
09:04:54 <lpsmith> thanks monochrom 
09:05:10 <Saizan> Data.Time.Format iirc
09:05:22 <monochrom> if you want a more specific module, I only remember that it is in a totally unexpected one.
09:06:20 <lpsmith> importing Data.Time doesn't do it
09:06:27 <hpc> http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#v:UTCTime
09:06:58 <lpsmith> importing Data.Time.Format doesn't do it
09:07:07 <vegai> 7.0.3 came out really stealthily
09:07:19 <vegai> was that on purpose 
09:07:25 <lpsmith> haddock is driving me nuts
09:08:32 <Saizan> lpsmith: cabal unpack time and then grep?:)
09:08:55 <monochrom> instance Show UTCTime is in Data.Time.LocalTime.LocalTime is re-exported by Data.Time.LocalTime is re-exported by Data.Time
09:09:00 <lpsmith> yeah, I just started reading the source, though I haven't quite got that far
09:09:29 <monochrom> at ghci prompt, I just did :m + Data.Time and then :info UTCTime to find it.
09:09:50 <monochrom> (proving that Data.Time works)
09:09:51 <lpsmith> If I do $ ghci-7.0.3    >  import Data.Time   > show `fmap` getCurrentTime    it complains about not having a show instance
09:10:19 <monochrom> oh I'm on 6.12.3
09:11:08 <monochrom> well still works in 7.0.2
09:11:21 <dafis> not for me
09:11:37 <monochrom> more precisely Haskell Platform 2011.2.0.0
09:11:41 <lpsmith> yeah, it does work in 6.12.3
09:12:28 <lpsmith> It'd be really nice if UTCTime supported proper +infinity and -infinity
09:12:42 <hpc> why does a time type need infinites?
09:12:49 <monochrom> perhaps you have a borked build of the time package.
09:13:34 <lpsmith> monochrom, I installed ghc-7.0.3-x86_64-unknown-linux.tar.bz2 from GHC HQ
09:13:47 <applicative> Data.Time has a huge amount of preprocessing for different platforms, e.g. #if HAS_DataPico
09:13:54 <lpsmith> hpc: it makes dealing with intervals of time nicer
09:14:15 <lpsmith> and postgres supports them, among others,  necessitating ugly wrappers because I'm actually using them
09:14:45 <monochrom> the time package doesn't come with ghc at all. only either haskell platform or manual install.
09:15:15 <lpsmith> oh? hmm...
09:15:33 <Saizan> it came with ghc for me
09:15:43 <lpsmith> yeah, I think it comes with ghc
09:17:06 <monochrom> I blame it on borked doc that comes with ghc
09:17:33 <lpsmith> well, haddock destroys the info of where an instance is defined
09:17:52 <lpsmith> instead it puts all the instances it can find into the module where the datatype is defined
09:18:01 <monochrom> oh, I mean the main index.html totally not have Data.Time at all
09:20:04 <monochrom> anyway it's in Data.Time.LocalTime.LocalTime source-code wise, but it's an internal module.
09:20:12 <applicative> lpsmith, if I import Data.Time and ask :i UTCTime then ghci tells me
09:20:25 <monochrom> yeah that's what I did too
09:20:51 <lpsmith> applicative, yeah,  I know that now.  Thanks! :)
09:21:01 <applicative> oh i didn't see it come up
09:21:01 * lpsmith needs to use the info command more often
09:21:11 <monochrom> it's re-exported by Data.Time.LocalTime, this is an exposed module.
09:21:47 <monochrom> and then re-exported again by Data.Time, this is why :m +Data.Time :info UTCTime works at all
09:21:57 <applicative> instance Show UTCTime  -- Defined in time-1.2.0.3:Data.Time.LocalTime.LocalTime  
09:22:07 <lpsmith> that must have changed in the latest version of time
09:22:12 <applicative> so yes there's the secret LocalTime.- submodules
09:22:23 <monochrom> don't know why you can't get it from "import Data.Time"
09:23:04 <Saizan> yeah, the problem is "import" instead of :m +
09:23:11 <Saizan> weird.
09:23:20 <Saizan> you should open a ticket :)
09:23:22 <Saizan> ?bug
09:23:22 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:23:50 <monochrom> well I admit I've only tried 6.12.3 and 7.0.2
09:24:23 <monochrom> is ghc pulling an April's Fool on us?
09:24:30 <lpsmith> I can confirm the bug on 7.0.3
09:24:49 <lpsmith> is there supposed to be any difference between import and :m +
09:24:52 <monochrom> well then I'm glad I haven't downloaded it!
09:24:57 <lpsmith> lol
09:25:16 <lpsmith> Well, I don't have a copy of ghc-7.0.2 immediately installed to test it
09:25:27 <monochrom> import is supposed to be more flexible, i.e., import X(y)
09:26:19 <lpsmith> monochrom, do you want to write the bug report, or shall I?
09:26:27 <monochrom> I don't want to.
09:26:31 <lpsmith> ok
09:28:04 <applicative> lpsmith, i reproduced it: like you said, with :m Data.Time, no problem , but with import Data.Time it's like you say.  Strange
09:28:28 <lpsmith> applicative, which version of ghc?
09:28:49 <applicative> 7.0.3
09:28:57 <lpsmith> ahh,  yeah
09:29:09 * lpsmith is unpacking and installing 7.0.2 as we speak
09:30:05 <lpsmith> actually I suppose I should have unpacked 7.0.1 first
09:30:11 <applicative> dont tell them ... maybe we have found a way to finesse annoying instances.  
09:30:21 <lpsmith> lol
09:30:40 <lpsmith> I doubt it's true for the compiler, but let me try...
09:32:07 <lpsmith> nah,  it's a ghci-onlyism
09:41:15 * hackagebot samtools 0.1 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.1 (NicholasIngolia)
09:49:29 * applicative compiled his first *.ml file yesterday.  hello_letrec_fibonacci.ml
09:51:51 <mauke> let rec a = 0 :: b and b = 0 :: a in a = b;;
09:52:22 <Rc43> Hi, guyz.
09:52:35 <Rc43> Can i catch exception what is appeared in Maybe monad?
09:53:35 <Twey> Rc43: For some value of ‘exception’
09:53:40 <Twey> Do you mean a Nothing?
09:53:58 <applicative> mauke the interpreter says "File "hello_letrec_fibonacci.ml", line 9, characters 34-36: Error: Syntax error" 
09:54:17 <mauke> applicative: what interpreter?
09:54:24 <applicative> ocaml
09:54:37 <mauke> works here, but I didn't try a file
09:54:46 <mauke> just pasted it in
09:55:25 <benmachine> what does a = b do here?
09:55:36 <mauke> compare a and b
09:55:43 <benmachine> oh
09:55:52 <benmachine> how not at all confusing
09:56:10 <mauke> wait until you learn the difference between <> and !=
09:56:28 <Twey> Let me guess, types?
09:56:40 <mauke> no
09:56:42 * Twey remembers + vs. +.
09:57:07 <mauke> both have type 'a -> 'a -> bool
09:57:18 * Twey scratches his head.
09:57:34 <Twey> Is one of them some sort of identity comparison?
09:57:45 <mauke> yes
09:58:02 <Twey> Aha
09:58:05 <mauke> == and != are identity, = and <> are structural equality
09:58:23 <applicative> mauke, i separated the definition of a and b from let _ = (a = b) .  I don't know how to print a bool, but this is enough to make it loop
09:59:09 <mauke> thanks to strict evaluation :-)
09:59:43 <Twey> What does ML say if you write ‘let a = b = c’?
10:00:15 <mauke> Error: Unbound value b
10:00:33 <Twey> So it's interpreted as a = (b = c) then?
10:00:44 <monochrom> yes
10:02:09 <applicative> Twey, yes, but if I use mauke's definition of a and b and say let c = a = c then of course that's enough to make it loop
10:02:23 <Twey> *nod*
10:02:44 <applicative> sorry, let c = a = b  
10:03:24 <mauke> # let rec a = a == a;;
10:03:24 <mauke> Error: This kind of expression is not allowed as right-hand side of `let rec'
10:03:28 <mauke> isn't it sad
10:03:42 <Twey> Terribly
10:04:03 * applicative weeps for the poor CMU students who will be learning this.
10:04:18 <sshc> Why couldn't string-class be built on hackage?  http://hackage.haskell.org/packages/archive/string-class/0.1.5.0/logs/failure/ghc-7.0 reports "haddock: internal error: unexpected argument to declName", but it builds on my system
10:04:26 <sshc> Can anybody else try installing it?
10:04:31 <sshc> (0.5.0)
10:05:18 <osoleve> what is =<<? lambdabot just spit it out when I was @pl'ing something.
10:05:24 <jmcarthur> :t (=<<)
10:05:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:05:29 <opqdonut> it's a flipped >>=
10:05:30 <Twey> osoleve: It's >>= backwards
10:05:31 <jmcarthur> reverse of >>=
10:05:36 <monochrom> y =<< x means x >>= y
10:05:50 <opqdonut> @source (=<<)
10:05:50 <lambdabot> (=<<) not available
10:05:55 <opqdonut> hrmh
10:06:00 <mauke> @src (=<<)
10:06:00 <lambdabot> f =<< x = x >>= f
10:06:05 <opqdonut> ah
10:06:11 <Berengal> I'm not sure I understand. Could someone come up with another way of saying what =<< is?
10:06:11 <lambdabot> Berengal: You have 1 new message. '/msg lambdabot @messages' to read it.
10:06:21 <TomMD> Slightly OT: is there an equivalent of hpc for C/++?  I'm looking from something simple-stupid that produces colored HTML of my source.
10:06:24 <monochrom> left >>= (right =<< centre) is designed to confound you :)
10:07:02 <jmcarthur> Berengal: (=<<) transforms a function of type (a -> m b) to a function of type (m a -> m b), where m is a Monad.   :P
10:07:10 <monochrom> would you like an explanation in Chinese?
10:07:23 <Berengal> monochrom: http://www.vex.net/~trebla/haskell/exception.xhtml <- what was the context of this?
10:07:40 <osoleve> okay, so to understand =<<, i need to understand monads first. gotcha.
10:08:19 <Twey> osoleve: Well… it's not really a question of ‘first’
10:08:27 <Twey> >>= pretty much *is* monads.
10:08:43 <Berengal> ((>>= and return))
10:08:53 <Twey> return is not interesting
10:09:06 <Twey> It's trivial
10:09:18 <Saizan> poor return
10:09:21 * hackagebot mstate 0.2.1 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.2.1 (NilsSchweinsberg)
10:09:25 <Saizan> return++
10:09:26 <Berengal> I'd say it's pretty interesting, but it isn't exclusive to monads
10:09:33 <applicative> pure++
10:09:43 <Twey> Haha
10:09:46 <McManiaC> yay for new mstate version :))
10:09:51 <Twey> By ‘interesting’ I mean ‘non-obvious’.
10:10:03 <Saizan> that's what you'd expect from an applicative 
10:10:14 <Berengal> >>= is pretty obvious once you get it :P
10:10:43 <byorgey> osoleve: in the context of @pl, (=<<) usually means  \f g x -> f (g x) x
10:10:44 <applicative> could there be something like an >>+<< :: f a -> (a -> f b) -> f b , but no pure or return
10:10:49 <monochrom> Berengal: exceptions.
10:10:53 <osoleve> Berengal: it is? the obvious explanation for >>= to me would be += for bitwise rightshift
10:11:07 <monochrom> hahaha
10:11:29 <Berengal> osoleve: It's obvious in the way multiplication is obvious once you got it, but when you were 4 and had just grokked addition it was mighty hard
10:11:44 <osoleve> like 2 >>= 1 == 1
10:11:53 * applicative just memorized the tables and rules, it's still unfathomable
10:12:06 <osoleve> then again, i'm still making the transition to functional thinking
10:12:23 <monochrom> @quote array
10:12:23 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
10:12:30 <monochrom> @quote array.*javascript
10:12:30 <lambdabot> No quotes match. My mind is going. I can feel it.
10:12:55 <monochrom> @quote nlogax array
10:12:55 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
10:13:00 <monochrom> that's the one
10:13:25 <monochrom> there is nothing to "understand". just use, use, use.
10:13:40 <osoleve> that's... a really horrible piece of advice for me, haha
10:13:50 <osoleve> (addict in recovery :P)
10:14:11 <Berengal> Hahaha
10:14:22 * hackagebot pdfsplit 0.0.1 - split two-column PDFs, so there is one column per page  http://hackage.haskell.org/package/pdfsplit-0.0.1 (DanielWagner)
10:15:02 <applicative> I wish there was a better symbol for : join (fmap f x) than f =<< x
10:15:06 <Berengal> monochrom: Ah, right. I'm not a fan of using Either either
10:15:42 <applicative> I just read it backward, and don't get the feeling i'm using a different 'style'
10:15:46 <Twey> I used to think it was all Right, but then I moved onto better things and Left it behind.
10:15:57 <byorgey> groan
10:16:09 * Twey takes a bow.
10:16:42 <Berengal> Twey: I used to Just stuff without worrying about errors, but that often left me with Nothing to show for my efforts
10:16:49 <Berengal> do stuff*
10:17:10 <tromp> > show Nothing
10:17:11 <lambdabot>   "Nothing"
10:17:12 <Twey> Teehee.
10:17:41 <applicative> > text $ show Nothing
10:17:42 <lambdabot>   Nothing
10:17:54 <mauke> > do show Nothing
10:17:55 <lambdabot>   "Nothing"
10:17:55 <tromp> :t text
10:17:56 <lambdabot> String -> Doc
10:18:17 <Twey> > Nothing
10:18:17 <lambdabot>   Nothing
10:18:41 <Berengal> What I find lacking in exceptions is that you Cont tell where you end up when you throw one. It's much better if your error-detecting code callCC a handler directly
10:18:59 <tromp> > Just Nothing
10:19:00 <lambdabot>   Just Nothing
10:19:11 <benmachine> :t Just Right
10:19:12 <lambdabot> forall b a. Maybe (b -> Either a b)
10:19:59 <Twey> Berengal: That las t one was a bit of a stretch :þ
10:20:07 <Twey> (but kudos for trying :þ)
10:20:14 <tromp> > succ Just
10:20:14 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a)
10:20:14 <lambdabot>    arisin...
10:20:29 <Berengal> Twey: The better the pun...
10:20:33 <tromp> > succ Nothing
10:20:34 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe a))
10:20:34 <lambdabot>    arising from a use ...
10:20:39 <Twey> Berengal: Touché :þ
10:20:45 <Veinor> Berengal: argh
10:20:48 <Twey> Haha
10:21:57 <fryguybob> applicative: semigroupoids has bind without return: http://hackage.haskell.org/packages/archive/semigroupoids/1.1.2/doc/html/Data-Functor-Bind.html#t:Bind
10:27:50 <applicative> fryguybob: I see, so Map is the familiar example 
10:33:25 * hackagebot samtools-iteratee 0.1 - Iteratee interface to SamTools library  http://hackage.haskell.org/package/samtools-iteratee-0.1 (NicholasIngolia)
11:20:16 <sshc> Can anybody else build 'string-class >= 0.5.0'?  It didn't build on hackage.
11:21:43 <byorgey> haddock error, eh?
11:21:53 <byorgey> I wonder what version of haddock is used by hackage
11:35:16 <joe6> i am trying to understand why this is not giving any output. http://pastebin.com/4NgQgCJW . have tried both observe and trace in list comprehension and they seem to give out type errors.
11:35:35 <joe6> Any suggestions on how I can see what the intermediate states of the list comprehension are?
11:35:59 <joe6> something like a trace on the intermediate structures would be great.
11:36:38 <joe6> don't bother, something like this is working, trace "test" True,
11:36:57 <mikeg> can't you just desugar it into the list monad? then sprinkle with trace or unsafePerformIO as you see fit
11:39:24 * Saizan doesn't see how that would help
11:39:50 <byorgey> joe6: in general, Hood is a nice tool for viewing intermediate states of computations
11:39:54 <michaelh> hey, everyone. is it ok to ask a stupid newbie question here?
11:39:59 <opqdonut> yes
11:39:59 <byorgey> http://hackage.haskell.org/package/hood
11:40:03 <byorgey> michaelh: absolutely.
11:40:05 <Saizan> do-notation, explicit binds and list comprehensions all have almost the same structure
11:40:46 <michaelh> ok, thanks. my question is how do i pattern match for a specific item in a list? tried matchList [3] = "output", matchList ([3]) = "output"…no luck
11:41:07 <byorgey> michaelh: [3] only matches the length-1 list containing 3
11:41:28 <byorgey> if you want 3 to be at the beginning, you can write  matchList (3:_) = ...
11:41:30 <joe6> byorgey, thanks a lot.
11:41:46 <byorgey> if you want 3 to occur anywhere in the list, you can write  matchList xs | 3 `elem` xs  = ...  
11:43:31 <michaelh> I don't understand what I am doing wrong, then. I get "No instance for (Eq a)
11:43:31 <michaelh>       arising from the literal `3'" and my code is: matchLists :: [a] -> String
11:43:31 <michaelh> matchLists (3:_) = "just one"
11:43:31 <michaelh> matchLists xs = "anything else."
11:43:51 <byorgey> michaelh: that type claims that it will work for ANY type of list.
11:44:02 <byorgey> but if you are matching against 3 then it will only work for lists of numbers.
11:44:18 <byorgey> if you change the type to  matchLists :: [Int] -> String, for example, it will work
11:44:44 <byorgey> more generally you could give it the type  matchLists :: Num a => [a] -> String
11:44:47 <michaelh> Awesome! I changed it to matchLists :: (Num a) => [a] -> String
11:44:58 <byorgey> great.
11:44:59 <michaelh> Works fine. I was not thinking through this
11:45:03 <michaelh> thank you, byorgey
11:45:07 <byorgey> you're welcome.
11:58:46 <joe6> which of these is considered a better solution: http://pastebin.com/THzqdVZQ http://pastebin.com/zvs1xcET
11:59:18 <joe6> one uses list comprehensions, and the other builds a tree, flattens it and picks what it wants.
11:59:41 <joe6> the first is smaller/lesser code, whereas the second, I feel, is more comprehensible.
11:59:56 <merijn> Comprehensible > everything else
11:59:58 <joe6> i prefer the second one. but, I am still learning
12:00:11 <joe6> merijn, ok, thanks.
12:00:18 <merijn> (Mind you, I didn't really look at the code since it was to long for me to grok on a friday evening :p)
12:00:34 <frerich> I think the second one is nicer
12:01:17 <joe6> frerich, ok, thanks.
12:03:20 <joe6> is there an abstraction in the haskell library or monads to deal with these kinds of search problems? Find the optimal cost, when there are x possible moves/transitions from a begining state to an end state?
12:03:48 <joe6> could the state monad help?
12:04:07 <frerich> Isn't that basically the travelling salesman problem?
12:04:20 <joe6> something like that, yes.
12:04:42 <joe6> but, that is an np problem, isn't it.?
12:04:44 <byorgey> no, it's much simpler than TSP (if I understand it correctly).
12:04:47 <merijn> TSP is NP complete, but finding the optimal path from state X to state Y given a finite set of steps is not NP complete
12:04:57 <merijn> Which I think what he wants
12:04:58 <joe6> i am looking for something far simpler.
12:05:00 <merijn> Sounds like you just want breadth first (or better, depth-first iterative deepening)
12:05:18 <merijn> breadth first search, even
12:05:34 <joe6> yes, one of those. something similar to how prolog pattern-matches..
12:05:38 <frerich> Oh, sorry, of course. I was confused.
12:05:49 <byorgey> you want Dijkstra's algorithm.
12:05:53 <frerich> Is your state machine a DAG?
12:06:17 <joe6> not now, but i am working towards one
12:06:39 <merijn> joe6: Is the search problem like "what is the minimal number of moves from board 1 to board 2?" (i.e. like two chess boards)
12:07:17 <joe6> basically an abstraction to, build a tree of all possibilities, flatten the tree into a list of possible choices, pick a/few choices based on some criteria.
12:07:40 <byorgey> well, I guess Dijkstra's algorithm only works if the search space is small enough to explicitly enumerate it.  Otherwise, something like iterative deepening or A* search...
12:08:04 <joe6> and the tree would be: current state -> [List of next steps], where a next step = curent state + move + new State
12:08:09 <merijn> joe6: For searching trees depth-first iterative deepening is the simplest, if you want something more heuristic look at A*
12:09:42 <joe6> merijn, is there a haskell module for A*?
12:09:58 <merijn> I feel compelled to say "probably"
12:10:09 <merijn> But I wouldn't know what its called, try searching Hackage?
12:10:40 <frerich> Maybe something witty like HAsterisk
12:10:42 <Dooda> Hi, somebody here have ever worked with BNFC?
12:10:53 <Dooda> for parser development
12:12:37 <joe6> ok, thanks.
12:12:59 <joe6> Dooda, pastorn was doing something with BNFC lately.
12:13:16 <joe6> Dooda, he likes it.
12:14:28 <Dooda> joe6:  do you know if he's online?
12:15:48 <joe6> Dooda, nope, I have no idea.
12:16:54 <jmcarthur> joe6: astar
12:17:02 <jmcarthur> i think Cale made it
12:17:53 <Cale> Yeah, I made astar
12:18:08 <Cale> I didn't really test it extensively or use it in any way, but I think it has a couple users
12:18:40 <joe6> jmcarthur, thanks.
12:18:43 <Cale> I wrote it as a simple exercise to understand the algorithm better, and thought I'd release it just in case it was useful to someone.
12:19:03 <joe6> Cale, thanks will check it out.
12:19:27 <jeffwheeler> If I want to hack on Cabal (to test the patch for this: http://hackage.haskell.org/trac/hackage/ticket/656), should I just install that version of Cabal as --user (my real version is --global). Then, install head cabal-install as --user too? Will this break everything?
12:20:16 <Cale> I doubt it will break anything.
12:20:29 <jeffwheeler> Is that how cabal dev's do it?
12:20:50 <Cale> No idea.
12:23:19 <Kaidelong> Joinads look interesting
12:23:29 <Kaidelong> I assume some or other haskell feature subsumes them? Arrows perhaps?
12:25:33 <Kaidelong> or perhaps the join calculus can even be done with a monad
12:26:33 <newsham> any good category theory april fools jokes yet?
12:28:57 <enthymeme> 'Michelle Bachman: topology is immoral, homeomorhpisms teach children "it's okay to be gay."'
12:29:06 * enthymeme shrugs
12:29:09 <enthymeme> got nothin'
12:32:31 <joe6> i find nested list comprehensions confusing and less comprehensible. Is it because i am still learning or is it generally frowned upon to use a lot of list comprehensions? I understand that they can be used to thread state, just like a do statement. just curious, if anyone has any opinions?
12:32:47 <joe6> maybe, I should not be saying "nested". 
12:32:58 <joe6> I meant more than 1 level of list comprehensions.
12:33:25 <joe6> as, list comprehensions calling other procedures which are list comprehensions..
12:33:51 <Cale> hmm, I don't usually have much trouble with that, as long as each function is doing something sensible
12:34:15 <Eliel> joe6: how the called functions are named makes a difference too, as well as comments in the code.
12:34:18 <Cale> Don't think of things as list comprehensions or not, think of them in terms of what they are
12:34:50 <joe6> Cale, the last statement is pretty "zen" like.. cool..
12:35:00 <pastorn> Dooda: oi!
12:35:16 <joe6> Eliel, I agree. the surrounding comments and names make a huge difference..
12:35:22 <joe6> pastorn, hoi..
12:37:07 <pastorn> joe6: helloez
12:38:33 <jmcarthur> we should all give dons_ a ton of reddit mold today
12:38:43 <osoleve> or me!
12:38:44 <osoleve> :D
12:38:50 <jmcarthur> no, definitely dons_ 
12:38:57 <osoleve> dang, worth a shot
12:39:07 * pastorn doesn't get the mold thing
12:40:10 <jmcarthur> pastorn: if you have a mold spore you can give mold to another user. for the most part, mold means that there is an additional character that the user can't type
12:40:26 <Cale> Whaaaaaat
12:40:40 <jmcarthur> the first character removed being E, of course
12:41:16 <jmcarthur> a lot of people are working around it by using letters with accents
12:49:33 <Berengal> @hoogle a -> Maybe b -> Maybe (a, b)
12:49:34 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> e -> (a, e)) -> a -> d -> (a, d)
12:49:34 <lambdabot> Control.Monad.RWS.Lazy execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
12:49:34 <lambdabot> Control.Monad.RWS.Strict execRWST :: Monad m => RWST r w s m a -> r -> s -> m (s, w)
12:52:57 <joe6> is a tree a good representation for a state machine? or, are there better abstractions or algorithms?
12:53:19 <merijn> Finite State Machines are usually graphs
12:53:20 <joe6> i know about astar, I am looking for representations of the state machine.
12:53:32 <joe6> merijn, would that be Data.Graph?
12:53:53 <merijn> That depends entirely on your needs and the complexity of the state machine
12:54:35 <joe6> merijn, thanks, am checking out Data.Graph.. do you know of any other modules for simple dag?
12:55:01 <merijn> I personally kinda like representing DAG's as matrices, but maybe Data.Graph already does that
12:56:04 <joe6> merijn, oh, really. never thought of DAG's as matrices.. will have to google that..
12:57:41 <monochrom> I would use either graph or ("tree" but tie the knot). Depends.
12:58:22 <danharaj_> Is there a convenience function for creating a block of allocated memory where every byte is set to 0 via the FFI?
12:59:03 <monochrom> there are a few allocators that initialize to your parameter
12:59:11 <Tomsik> DAGs are not matrices, weighted graphs are
12:59:56 <Tomsik> and generally, matrices are weighted automata, distance automata for example
13:01:49 <copumpkin> Tomsik: matrices over what? :P I can have a matrix over {0,1} and then it's just a plain old graph
13:01:58 <copumpkin> but yeah, the matrix says nothing about it being "DA"
13:02:06 <copumpkin> or A, at least
13:02:11 <Tomsik> yeah
13:02:47 <dcoutts_> jeffwheeler: yes, that's how we do it
13:03:10 <jeffwheeler> dcoutts_: awesome, thanks
13:03:31 <Tomsik> I wonder if there's any easy specification of what matrices represent acyclic graphs
13:04:18 <dcoutts_> jeffwheeler: ah that ticket, good
13:04:43 <jeffwheeler> dcoutts_: I probably won't know how to solve it . . . but I can bump it ;)
13:05:04 <dcoutts_> jeffwheeler: I don't expect it's that hard, it's just nobody has done much with it
13:05:21 <jeffwheeler> dcoutts_: yeah, the patch seems intuitive, not sure why somebody said it didn't work
13:05:30 <jeffwheeler> (but I haven't tested it for myself yet)
13:05:51 <dcoutts_> jeffwheeler: I expect it's mostly a matter of using the local package db
13:06:16 <jeffwheeler> dcoutts_: hmm? The current patch just changes it to only build docs for executables. Is that bad?
13:06:27 <jeffwheeler> err, /not/ build docs for executables
13:06:27 <dcoutts_> jeffwheeler: yes
13:06:51 <dcoutts_> jeffwheeler: yes, it'd be better to do it properly, not just do a workaround
13:07:00 <jeffwheeler> dcoutts_: hmm, alright.
13:11:42 <frerich> Hmm. In a little game I wrote I have a 'Player' type class with a 'getTurn' function. This type class is instantiated by a 'LocalPlayer' type and by a 'CPUPlayer' type. Now I'd like to add a 'RemotePlayer' type which represents a player connecting via TCP/IP. However, this means that 'getTurn' suddenly cannot block anymore. I think. What's the usual way to handle this in Haskell? In imperative languages I'd pass a callback.
13:12:46 <frerich> On a side note, does it sound plausible to use a type class like one would use an abstract base class in C++ (or interface in Java/C#)?
13:12:46 <Zao> frerich: Why can't it block?
13:13:07 <Zao> frerich: It just has to block on something fancier, like a MVar set by a thread selecting or so.
13:13:14 <frerich> Zeo: Well the main game loop which calls 'getTurn' on a player should still be able to redraw or something like that.
13:13:26 <frerich> Other plays should be able to disconnect or connect.
13:13:38 <frerich> Hmm.
13:14:13 <Berengal> frerich: You could draw in a different thread
13:15:19 <frerich> Hmm. Interesting how quick you are to suggest threads. But then - maybe threads are a much easier tool in functional languages? In e.g. C++ I'd rather try to use a single thread with an event loop to avoid having to worry about synchronization issues.
13:15:24 <enthymeme> frerich: I've thought about using Haskell to prototype abstract Java types, too.
13:16:02 <Zao> frerich: You've got a rich set of magically synchronized thingies in Haskell.
13:16:08 <Zao> STM TVars, MVars, etc.
13:16:11 <Berengal> frerich: You could use continuations. The code would start looking something like cooperative threads however
13:16:34 <enthymeme> Zao: and the par operator, right?
13:16:41 <Berengal> (Incidentally, I'm experimenting with a continuation-based game engine right now)
13:16:52 <TomMD> frerich: yeah, threads in Haskell are easy and so is communication.  Also, they don't (always) mean an OS thread - they are more along the lines of "green threads".
13:17:16 <TomMD> How are you drawing right now?
13:17:24 <jmcarthur> Berengal: continuation-based in what sense?
13:17:46 <aristid> :t unfoldr2
13:17:47 <Berengal> jmcarthur: There are several loops and event-handlers, except instead of loops they're continuations
13:17:47 <lambdabot> Not in scope: `unfoldr2'
13:17:50 <aristid> :(
13:18:08 <jmcarthur> ah, so basically threads then
13:18:11 <frerich> TomMD: Heh, to be honest, I only have a text mode drawing right now (I plan to introduce a 'GameView' type class with something like a 'renderBoard :: Board -> IO ()' function or so.
13:18:13 <Berengal> Basically, yes
13:18:53 <frerich> Hm, continuation and MVar. Useful things to google for, thanks guys. :-)
13:19:19 <Berengal> frerich: Out of the two, MVars are less likely to melt your brain
13:19:25 <TomMD> frerich: That's fine - what I both expected and hoped to hear.  I'd put your state in an MVar (if it's simple enough for that) and just for a thread readMVar gameState >>= draw >>= threadDelay (freq- drawtime)
13:19:40 <frerich> Berengal: Hah, thanks for that hint.
13:19:41 <TomMD> I ment "just fork a thread"
13:19:54 * hackagebot mstate 0.2.2 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.2.2 (NilsSchweinsberg)
13:20:18 <monochrom> yes, threads are easier in a functional setting in practice, and soon you will experience why
13:20:35 <TomMD> Be sure to upload the result so we can all play.
13:20:38 <frerich> TomMD: Hmm, thanks, I'll read up on that.
13:20:39 <McManiaC> I'd use that mstate package there
13:20:40 <McManiaC> :D
13:20:49 <frerich> TomMD: It's on github already but the multiplayer doesn't work yet :-)
13:20:56 <TomMD> link?
13:21:13 <monochrom> (in principle—in the hands of very disciplined programmers—of course it doesn't matter, everything is easy)
13:21:30 <luite> frerich: by the way, you could probably use a regular data type instead of a type class, something like: data Player = Player { getName :: String, nextMove :: Game -> IO Move }
13:22:11 <frerich> Well I have two games so far (don't make fun of my, I'm only starting): http://github.com/frerich/tictactoe and http://github.com/frerich/mastermind ahem. The games are really simple but I'm trying to add all kinds of interesting features to exercise Haskell a bit.
13:23:01 <frerich> luite: Hm, good point, I could have a field which is a function, I didn't even think of that.
13:25:18 <monochrom> don't generalize until you see which direction to generalize to
13:26:45 <luite> you should probably need type classes less often than you used abstract base classes in java :)
13:27:34 <monochrom> such languages as java already commit your direction of generalization before you know it, by being class-based
13:28:15 <TomMD> monochrom: Right you are.  Now I see the violence inherent in the system.
13:28:18 <monochrom> "so easy to add another subclass" = "so hard to add another method"
13:28:46 <monochrom> of course, you could say the same about many functional languages, by being function-based
13:29:15 <monochrom> but type classes probably relieve that a bit
13:29:25 <frerich> Yes, the language influences (defines?) the way you think about problems. That's why I enjoy asking here so much because you guys usually have a fairly different approach to solving some problem than I do (with my imperative mindset) :-}
13:33:01 <monochrom> "the language doesn't carry the thought. the language is the thought." - Sapir McLuhan :)
13:34:02 <geheimdienst> the limits of my haskell are the limits of my thought --ludwig whorf
13:34:11 <monochrom> hehe
13:34:48 <Kaidelong> there are times when I feel that I can't really express what I want to in haskell
13:35:08 <monochrom> yes, haskell is just a programming language
13:35:32 <Kaidelong> I think I know how I might change the implementation of how instances are resolved to get something closer though
13:36:51 <Kaidelong> basically something like put overlapping instances on a partial ordering and do a breadth first search up from the leaves of the resulting tree
13:38:20 <enthymeme> does anybody here know what meaning (>>=) has for lists? GHC tells me that they're declared an instance of Monad.
13:38:38 <hpc> enthymeme: (>>=) = concatMap
13:38:40 <hpc> :t concatMap
13:38:41 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
13:38:44 <hpc> @src concatMap
13:38:44 <lambdabot> concatMap f = foldr ((++) . f) []
13:38:45 <Kaidelong> concatMap
13:38:47 <Taslem> The Recaptcha I was just given contained a smudge as one of the words. :/
13:39:00 <hpc> > concatMap (repeat 3) "abc"
13:39:01 <lambdabot>   Couldn't match expected type `a -> [b]' against inferred type `[t]'
13:39:07 <hpc> > concatMap (replicate 3) "abc"
13:39:08 <lambdabot>   "aaabbbccc"
13:39:08 <enthymeme> enter an arbitrary word, maybe it's the unknown
13:39:13 <Kaidelong> or "for each result the program on the left returns, concatenate results gleaned from running the program on the right with that result as the argument"
13:39:53 <Kaidelong> or "create a program that runs the program on the right on each result and concatenates the results"
13:40:04 <Taslem> Actually, I entered nothing and it let me in. :P
13:40:29 <hpc> :t join . fmap
13:40:30 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
13:40:30 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
13:40:30 <lambdabot>     In the second argument of `(.)', namely `fmap'
13:40:30 <enthymeme> yeah, it was the unknown
13:40:40 <hpc> :t \f -> join . fmap f
13:40:41 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
13:40:58 <enthymeme> that's how ReCaptcha works. You just set back their OCR project an infinitessimal amount :p
13:41:00 <ourfrank> I'm getting the "Ambiguous type variable 'a' in the contraint (ClassName a); probable fix: add a type signature" error. Is there a way to make this work without adding a type signature?
13:41:29 <hpc> ourfrank: rewrite the function in a different way?
13:41:34 <Taslem> Actually, I don't think so. I'm pretty sure I'm helping them. :P It was a smudge, not an actual word.
13:41:49 <Taslem> As in it was just a bunch of splotches of ink.
13:41:53 <ourfrank> hpc: How do you mean? Not use constraints?
13:42:47 <hpc> ourfrank: two ways to solve ambiguity: 1. add type signature to make it unambiguous; 2. somehow side-step the code that is ambiguous
13:42:58 <hpc> somehow == rewrite function
13:43:32 <ourfrank> hpc: I see. I was hoping there was some magickal language extension I could use. Thanks. :)
13:44:13 <hpc> ourfrank: say we had a typeclass Foo a where process :: a -> a
13:44:19 <benmachine> ourfrank: if you want to paste the function in question we can offer more specific advice
13:44:29 <hpc> ourfrank: and we wrote show . process . read $ someString
13:45:01 <hpc> ourfrank: how do we know which process to use? we could read an Int and add one, read an Integer and add two, or read a Maybe and turn it into Nothing
13:45:18 <hpc> ourfrank: that's not behavior you want left up to an extension
13:45:38 <ourfrank> benmachine: The function(s?) is/are too huge and I'm not even sure what part of the code is the problem.
13:45:52 <ourfrank> hpc: I see. Type annotations are definitely what I need here...
14:08:52 <danharaj> any recommendations for a library I should use for loading opengl texture data from file?
14:10:01 <pastorn> danharaj: devil supports a gazillion formats, if you can get it to work
14:10:12 * hackagebot hmk 0.9.7.3 - A make alternative based on Plan9's mk.  http://hackage.haskell.org/package/hmk-0.9.7.3 (MathieuBoespflug)
14:10:35 <roconnor> is cereal a replacement for binary?
14:11:21 <pastorn> roconnor: does it have an equivalent to Put?
14:12:13 <benmachine> roconnor: there has been some talk of merging cereal into binary
14:12:15 <roconnor> pastorn: yes
14:12:32 <benmachine> (cereal into binary rather than vice versa because binary has a lot more revdeps)
14:12:40 <roconnor> benmachine: I wanted to have a version of cereal whose decoder is partial
14:12:54 <roconnor> benmachine: I wanted to have a version of binary whose decoder is partial
14:13:04 * benmachine blinks
14:13:10 <roconnor> and that appear to be what cereal is
14:13:13 <benmachine> partial in what sense
14:13:13 <gghhh> Hi. How do I parse the recursive function cbtFromList in solution 63?  I don't get what the code means. : http://haskell.org/haskellwiki/99_questions/Solutions/63
14:13:20 <roconnor> but I've only glanced at cereal
14:14:21 <roconnor> sadly it looks like errors must be Strings rather than something else.
14:14:44 <byorgey> gghhh: heh, that is a tricky one
14:14:57 <byorgey> gghhh: are you having trouble parsing it, or understanding how it works?
14:15:23 <gghhh> byorgey: Just parsing firstly.  I get complete binary trees + the algorithms they use elsewhere on that page.
14:15:31 <roconnor> oh cereal also works only on strict bytestrings
14:15:36 <byorgey> gghhh: ok, which parts are you having trouble parsing?
14:15:49 <roconnor> I'm not sure how I feel about that
14:16:14 <gghhh> this 1st: let (t, xss) = cbt (xs:xss) in t  ---- why does xss appear in parameters + result simultaneously?
14:16:38 <byorgey> oh, that's just recursion.
14:16:47 <byorgey> we are passing cbt part of its own output!
14:16:54 <byorgey> this works because of lazy evaluation.
14:17:00 <byorgey> but it's quite mind-bending.
14:17:11 <gghhh> ha that's funny
14:17:31 <gghhh> I tried to google "local recursion" but didn't find anything about this style
14:17:40 <byorgey> yes, I've never heard that term either
14:17:53 <napping> I built threadscope with cabal-install, but the binary just says "Most RTS options are disabled. Link with -rtsopts to enable them."
14:18:58 <gghhh> I'm rereading it now since you told me that.
14:19:08 <roconnor> gghhh: it is called "data recursion" or "tying the knot"
14:20:12 <byorgey> the trick is to figure out what the input to cbt represents.  It is a list of lists, and I think the nth list represents the elements which are available to be used when building level n of the tree
14:20:19 <benmachine> gghhh: here's a wiki page on the general concept http://haskell.org/haskellwiki/Tying_the_knot
14:20:35 <byorgey> then cbt returns a tree as well as some leftover elements
14:20:42 <Eduard_Munteanu> Ah, I've done something like that for making doubly-linked list.
14:21:25 <Eduard_Munteanu> It's a bit akin to making the stars align for your particular data structure ;)
14:21:31 <gghhh> Thanks for this help!
14:21:32 <napping> Ah, someone who knows of threadscope
14:22:06 <napping> hmm, "cabal install threadscope" is again compiling, I'll see if it ends up working better
14:22:14 <gghhh> I must not have read enough of tutorials etc., unless it's new.
14:22:25 <napping> nah, still says "threadscope: Most RTS options are disabled. Link with -rtsopts to enable them."
14:22:54 <roconnor> gghhh: it is an intermediate/advanced topic
14:23:05 <monochrom> gghhh: Do you first understand the basic example of "let x = 'c':x in x" ?
14:24:36 <gghhh> monochrom: No not yet, but I get x = "cccc ..."
14:24:44 <gghhh> sorry get -> guess
14:24:58 <byorgey> exactly
14:25:05 <byorgey> > let x = 'c':x in x
14:25:06 <lambdabot>   "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
14:26:45 <jeffwheeler> > fix ('c':)
14:26:46 <lambdabot>   "cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
14:27:14 <hpc> @src fix
14:27:14 <lambdabot> fix f = let x = f x in x
14:27:20 <joe6> i built a tree using Data.Tree. Is there a depth-flatten for levels?
14:27:43 <joe6> levels list the levels at each level and flatten merges all nodes
14:28:09 <hpc> joe6: if i understand right, you want either a fold or a join
14:28:10 <hpc> :t join
14:28:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:28:13 <hpc> :t foldr
14:28:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:28:18 <joe6> I want a list of all depth-search paths.. Just curious if there was a library that can do that..
14:28:32 <napping> oh, that's a little different
14:28:48 <napping> probably easy
14:29:07 <hpc> oh
14:29:36 <joe6> hpc, in (a,(b,(d,e),c)) => [[a,b,d], [a,c]]
14:29:49 <gghhh> Is the haskell wikibook the best to read?  I read a fair amount in the past.
14:30:03 <joe6> actually, [[a,b,d],[a,b,e] ,[a,c]]
14:30:10 <jeffwheeler> gghhh: try Real World Haskell
14:30:13 <jeffwheeler> @where rwh
14:30:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:30:21 <shachaf> Does the Haskell wikibook still talk about space suits and astronauts?
14:30:33 <hpc> shachaf: i hope so :P
14:30:50 <gghhh> jeffwheeler: Thanks I will (haven't yet).
14:31:12 <shachaf> Ah, looks like it doesn't.
14:31:14 <shachaf> Good.
14:31:26 <napping> something like flatten (Node a cs) = map (a:) (flatten' cs); flatten' [] = [[]]; flatten' cs = map flatten cs
14:31:54 <int80_h> testing
14:31:56 <int80_h> hmm
14:31:56 <joe6> napping, thanks.
14:32:17 * hackagebot attoparsec 0.8.5.1 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.5.1 (BryanOSullivan)
14:32:21 <joe6> napping,  i have the code. i was thinking if there was anything in the library that can do it..
14:34:15 <napping> only returning deepest paths makes it a bit funny
14:34:37 <mekeor> sorry about disturbing you, but i just even can not define a function! I write "foobar :: Int -> Int" and ghci (and tryhaskell.org) says "not in scope: foobar". WTF??
14:34:40 <napping> if you wanted all paths it could be flatten (Node a cs) = map (a:) ([]:map flatten cs)
14:35:05 <monochrom> put "foobar :: Int -> Int" in a file. load that file.
14:35:07 <napping> mekeor: for ghci at least, it has to be in a let and all on one line
14:35:21 <napping> have to do file for things like data declarations
14:35:30 <joe6> napping, ok, thanks a lot.
14:36:01 <joe6> napping, the last code is pretty neat.. thanks.
14:36:44 <monochrom> tryhaskell.org is faithful to "repl" down to the letters. ghci too almost. there is no "d" in "repl".
14:37:13 <napping> We need to write a derpl
14:37:22 <hpc> haha
14:37:39 <monochrom> evaluate before read? that sounds psychic
14:37:49 <copumpkin> derpl!
14:38:00 <monochrom> "the answer is 6. now enter your question:"
14:38:12 <napping> must be lazy io
14:38:24 <monochrom> lazy i, eager o
14:38:31 <hpc> monochrom: what is the number of rows in a jeopardy column?
14:38:34 <hpc> :P
14:38:41 <monochrom> haha you win
14:38:44 <int80_h> could someone lay some utf-8 characters on me? I'm testing my new configuration
14:38:53 <hpc> no wait, it's only 5
14:38:58 <monochrom> ♥ int80_h
14:39:04 <jeffwheeler> hpc: columns?
14:39:22 <monochrom> include the title row to get 6 rows
14:39:23 <hpc> ah, there are 6 columns :D
14:39:46 <int80_h> monochrom: thanks :) I saw that.
14:54:53 <Athas> Is there a shorter way to express 'do f <- asks foo; f bar'?
14:54:59 <Athas> Preferably so I don't need the binding f.
14:55:26 <ddarius> @. pl undo do f <- asks foo; f bar
14:55:26 <lambdabot> ($ bar) =<< asks foo
14:55:46 <Athas> Thanks.
14:58:58 <xplat> > let lastButOne = fst . foldl' (uncurry $ const (,)) (join (,) $ error "too short") in lastButOne [0..3]
14:58:59 <lambdabot>   2
15:01:05 <otherwise> when compiling this <http://hpaste.org/45204/foo> code ghc says that there was an error in the pattern – but why? actually I'm new to Haskell and just want to write a program which solves the first projecteuler-problem (<http://projecteuler.net/index.php?section=problems&id=1>); I already implemented it in C… :(
15:01:37 <byorgey> otherwise: you need parentheses around x:xs
15:01:55 <kreed> otherwise, "(x:xs)"
15:02:23 <otherwise> ?
15:02:29 <otherwise> a
15:02:30 <otherwise> ok
15:02:44 <shachaf> Also no base case.
15:02:51 <otherwise> THANKS YOU VERY MUCH!
15:02:58 <otherwise> no base case?
15:03:13 <monochrom> divi [] = ?
15:03:37 <otherwise> [] ?
15:03:42 <otherwise> divi [] = []
15:03:49 <monochrom> but you will know soon enough when the program aborts
15:04:47 <otherwise> hmm…
15:06:09 <shachaf> Also, filter.
15:06:34 <otherwise> "Non-exhaustive patterns in function divi"………
15:07:13 <ddarius> monochrom's soothsaying abilities are unparallelled.
15:07:14 <kreed> I have some trouble with http://hackage.haskell.org/package/HDBC-mysql package. It depends on base (<4), but in GHC 7 - base 4.3.1. I download a package and change dependence in .cabal file. It works fine. But I want to build another package with dependence in HDBC-mysql and cabal check dependencies from the hackage, where is base (<4). What I should do?
15:07:23 <shachaf> otherwise: See the discussion that was just had.
15:08:03 <monochrom> if only computers were as psychic as I am
15:08:35 <Athas> Are there any gotchas I should be aware of when combining StateT and ContT?
15:08:59 <napping> besides deciding which order you want?
15:09:43 <c_wraith> The order choice is really important.  But other than that, they should work fine together.
15:10:13 <c_wraith> You just need to decide if you want the state to be stored as part of the continuation, or propogate across jumps
15:10:21 <ddarius> All monad transformers should work fine together otherwise they wouldn't be monad transformers.
15:10:41 <c_wraith> but they don't.  *cough*ListT*cough*
15:10:57 <ddarius> See the last clause of my sentence.
15:11:26 <monochrom> the Barbara ListTcough principle
15:11:49 <c_wraith> you posit an independent entity called a monad transformer, which is not the same as something implementing MonadTrans, then.
15:12:16 <ddarius> Definitely not.
15:12:21 <monochrom> well you could impose laws on MonadTrans too
15:12:27 <benmachine> a monad transformer is a thing which transforms monads
15:12:29 <ddarius> It does have laws.
15:12:43 <benmachine> ListT transforms monads I suppose, but not into monads :P
15:12:58 <c_wraith> The #1 law, which ListT violates, is that Monad m => Monad (t m)
15:13:05 <ddarius> c_wraith: Of course, in that sense MonadTrans is a MonadTrans'former for Monad's.
15:13:05 <dcoutts_> kreed: bump the local version
15:13:13 <frerich> ls
15:13:16 <Athas> c_wraith: I want the state to be part of the continuation.  That means ContT should wrap StateT, right?
15:13:16 <frerich> ergs, sorry.
15:13:33 <kreed> dcoutts, mm, how?
15:13:39 <Athas> My intuition for this is not very solid yet.
15:13:41 <benmachine> Athas: try @unmtl and see if th types match up with what you expect
15:13:42 <c_wraith> Athas: I'm not going to try to answer that for you, primarily because I get it wrong 3 times every time I try :)
15:13:50 <benmachine> @unmtl ContT r (StateT s m) a
15:13:50 <lambdabot> (a -> s -> m (r, s)) -> s -> m (r, s)
15:13:50 * frerich longs for a window manager with 'focus follows mind'
15:14:00 <benmachine> frerich: :P
15:14:02 <ddarius> Just expand the definitions and ponder for a bit.
15:14:10 * Athas ponders heavily.
15:14:18 <benmachine> @unmtl StateT s (ContT r m) a
15:14:18 <lambdabot> s -> (a -> s -> m r) -> m r
15:14:33 <monochrom> no, @unmtl is probably out of date
15:14:44 <int80_h> :t qRunIO
15:14:45 <lambdabot> Not in scope: `qRunIO'
15:14:52 <dcoutts_> kreed: change the version in the .cabal file
15:15:47 <kreed> dcoutts, In what cabal file? I install HDBC-mysql and use it. But when I try to build another package, that depend on HDBC-mysql - it fetch version from the hackage.
15:24:20 <monochrom> well, it seems @unmtl is not outdated
15:25:19 <monochrom> that is, the fact that StateT and ContT practically commute is still true of mtl-2
15:29:47 <monochrom> http://hpaste.org/45207/contt_statet_experiment
15:30:36 <michaelh> hi, can anyone please help me understand why this is the case? confused newbie here http://hpaste.org/45206/why_does_this_type_variable_no
15:31:26 <dolio> String = [Char]
15:31:30 <dolio> [b] is something else.
15:31:46 <monochrom> "hello" definitely cannot have type [b]
15:32:27 <monochrom> however, would you like a taste of unsafeCoerce? :)
15:32:41 <monochrom> "special April 1st offer"
15:33:06 <michaelh> thanks…why is that, though? would think i could say b and then let the compiler figure out what b is.
15:33:27 <monochrom> no, that is not what "[b]" means to the language
15:33:28 <michaelh> i.e. that b is a char, so [b] is a list of chars aka a string
15:33:31 <benmachine> michaelh: the type signature you gave says "this works for any b"
15:34:26 <benmachine> michaelh: it says, I can use this function to return an [Int] or a [Bool] or a [[(Char,IO [Maybe String])]]
15:35:15 <co_dh> greating guys, I have an off topic question : If you sleep later and read something exciting as mathematics, will it cause you wake up early ? 
15:35:37 <monochrom> no, it will cause me to wake up late
15:35:40 <Zao> If you know it's off topic, why aren't you in -blah?
15:36:07 <monochrom> just s/mathematics/haskell/ to make it on-topic :)
15:36:32 <co_dh> I guess people here like reading.  what I'm reading is coq, so it's not that off topic.
15:37:45 <michaelh> ah. so b is not saying, "compiler, figure this out." it's actually making it impossible (forbidding?) for the compiler to deduce that the output type is [char]
15:40:48 <efi> if i have a function like t :: Bool t = True can i set the result of the function within another function to for exmaple false with f = False or something like that?
15:41:23 <efi> "with t = False"
15:41:33 <efi> i wanted to write
15:41:44 <monochrom> cannot
15:41:50 <azaq23> michaelh: [b] does not say that there is a concrete b which "exists" and fulfills the quality of the type, just that it can be any b. So basically yes. The first thing is an existential type. In OO languages using something like generics, this notion is normally used (java P<T> is an existential type), so it is different from the haskell one.
15:41:53 <int80_h> I've decided to abandon my haskell studies for java, which I find to be more elegant, powerful and awesome in every way.
15:42:02 <int80_h> hah!
15:42:04 <int80_h> burn!
15:42:47 <monochrom> actually you should go all the way for javascript 
15:42:58 <jmcarthur> int80_h: my response to everything i read today http://i.imgur.com/sLFs8.jpg
15:43:02 <azaq23> a -> b is impossible to type, disregarding some special compiler primitive functions
15:43:05 <int80_h> well you can tell it's better because it's java+script.
15:43:17 <monochrom> precisely!
15:43:33 <michaelh> azaq23: It seems so strange to me, I guess, but I understand now. This isn't PHP anymore. :)
15:43:54 <monochrom> my recent http://www.vex.net/~trebla/haskell/exception.xhtml is made possible by javascript!
15:44:03 <int80_h> jmcarthur: that was t3h funny.
15:45:45 <hpc> monochrom: lol
15:49:02 <efi> cab anyone glimpse at my problem? the function liste gets a Int and a ordered List and has to: delete the Int if it appears in the list. if it doesnt, it has to be inserted (the order still must be correct) http://codepad.org/O7yFW22A i think it runs well excpet for line 10   
15:50:11 <monochrom> like I said, you cannot "change" t like that. there is no way to change. there is no need to change either.
15:50:27 <efi> yeah, but i dont know how i can fix it
15:51:08 <monochrom> "fix" understates it. you have to use another approach, not try to salvage this approach.
15:51:44 <monochrom> and I'm too busy to say more now
15:52:26 <efi> im here to get new inspiration .. anyway, thanks
15:53:05 <hpc> efi: look at functions as saying what something IS, not what it DOES
15:53:17 * hpc is too busy too, but that little tidbit might be enough to get you thinking
15:54:31 <benmachine> efi: make t a parameter to liste, and pass a different value in the recursive calls (if necessary)
16:03:20 <pkhuong> does stream fusion work when a stream has multiple consumers (e.g. let m = map f x in (map g m, map h m))?
16:03:32 <c_wraith> no
16:03:55 <pkhuong> thanks.
16:05:23 <c_wraith> Well, it could if it decided not to share m...  But it would be scary if GHC ever decided to not share something declared like that and got it wrong.
16:05:44 <c_wraith> or even if f is just really expensive.
16:05:47 <pkhuong> right.
16:06:09 <kyagrd> I've decided to move my hompage to patch-tag wiki making a www repository.
16:06:26 <kyagrd> There isn't any eminent dagner of closing the service right?
16:07:56 <pkhuong> Getting rewrite rules like stream/unstream to work correctly in the presence of sharing probably requires explicit support.
16:09:33 <acowley> Hm, a SO question made me try something. Is there any point to something like this at all? I can't see it: http://hpaste.org/45208/uncle_num
16:16:38 <joe6> any suggestions on how I can make this better: http://pastebin.com/GvH9eczq
16:16:56 <joe6> it is a purely learning exercise, so I am willing to try anything..
16:17:39 <joe6> efi, you are using hugs?
16:19:24 <joe6> efi, why not liste x xs = sort (some function here) .(x:) . delete x $ xs
16:20:12 <joe6> efi, or i think you can use elem and break it with a case statement.
16:20:44 * hackagebot samtools 0.1.1 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.1.1 (NicholasIngolia)
16:20:46 * hackagebot samtools-iteratee 0.1.1 - Iteratee interface to SamTools library  http://hackage.haskell.org/package/samtools-iteratee-0.1.1 (NicholasIngolia)
16:20:52 <joe6> efi, or the if statement too..
16:21:44 * hackagebot samtools-enumerator 0.1 - Enumerator interface to SamTools library  http://hackage.haskell.org/package/samtools-enumerator-0.1 (NicholasIngolia)
16:26:53 <benmachine> joe6: this is quite a lot of code to all consider at once. it's a bit strange that costOfChoice returns its argument
16:28:46 <joe6> benmachine, good suggestion. it does not need to do that.
16:29:12 <benmachine> joe6: trivial thing, treesToChoices can be pointfree
16:29:49 <benmachine> joe6: why couldn't you figure out flatten?
16:30:58 <joe6> benmachine, the flatten was doing what the treesToChoices is doing in 4 lines.
16:31:19 <joe6> benmachine, and it is definitely an improvemen, but I was getting confused with teh nested lists.
16:31:34 <joe6> benmachine, i mean [[Move]]
16:31:44 <joe6> s/improvemen/improvement/
16:32:08 <joe6> benmachine, i was trying to solve the "Escape from Zurg: logic exercise" problem
16:39:02 <rostayob> How do I get the 'DataType' of some data type, without having an actual object?
16:39:57 <benmachine> > dataTypeOf (undefined :: Maybe ())
16:39:58 <lambdabot>   DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
16:40:13 <rostayob> cool, thanks
16:40:15 <rostayob> :t undefined
16:40:16 <lambdabot> forall a. a
16:40:19 <rostayob> mh.
16:40:26 <aristid> :t dataTypeOf
16:40:26 <lambdabot> forall a. (Data a) => a -> DataType
16:40:34 <aristid> :t typeOf
16:40:34 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:40:50 <aristid> > typeOf (undefined :: Maybe ())
16:40:50 <lambdabot>   Maybe ()
16:41:18 <aristid> benmachine: what's the difference between dataTypeOf and typeOf?
16:41:34 <rostayob> aristid: well dataTypeOf includes the constructors
16:41:43 <rostayob> aristid: you need them to traverse the data types I guess
16:42:01 <benmachine> aristid: well, they have different contexts, and return different things
16:42:17 <benmachine> what's the same? :P
16:42:49 <rostayob> btw, I just the syb paper
16:42:55 <rostayob> 'Term' became 'Data', right?
16:43:07 * benmachine hasn't seen the syb paper
16:43:36 <rostayob> ok, I'm pretty sure that's what it is now
16:43:51 <rostayob> no actually no
16:45:12 * JuanDaugherty read it juan takes it
16:46:00 <napping> Have you read the multiplate paper?
16:46:41 <aristid> napping: the one with comonads and all sorts of stuff?
16:47:01 <napping> sounds right, but the important bit was the applicatives
16:48:58 <enthymeme> huh, so making my Tree class an instance of MonadPlus didn't really take...
16:49:07 <aristid> napping: i do have read it, but understood like only 20% :)
16:49:23 <aristid> napping: we could summon roconnor
16:50:22 <napping> I think I understand how you use it
16:50:48 <aristid> preflex: seen roconnor
16:50:48 <preflex>  roconnor was last seen on #haskell 2 hours, 27 minutes and 57 seconds ago, saying: gghhh: it is an intermediate/advanced topic
16:51:46 <enthymeme> if I have a type "data Tree a = Leaf a | Branch (Tree a) (Tree a)", how should I write the instance declaration for "(MonadPlus m) => MonadPlus (Tree (m a))"?
16:52:41 <enthymeme> I want mzero of the Tree type to be a leaf containing the mzero of the monadic type of the tree, so I wrote "mzero = Leaf (mzero :: m a)"
16:53:01 <napping> that doesn't seem like it will work so well
16:53:06 <napping> what should mappend do?
16:53:11 <napping> maybe require (Monoid a)?
16:53:15 <enthymeme> hmmm
16:53:19 <rostayob> enthymeme: mhm maybe you mean monoid?
16:53:19 <benmachine> enthymeme: I think just mzero = Leaf mzero will be enough, the compiler should be able to work out the rest
16:53:36 <napping> Oh, MonadPlus, never mind.
16:53:36 <benmachine> but I agree that MonadPlus is probably the wrong thing here – is Tree even a Monad?
16:53:39 <enthymeme> thanks benmachine, I'll try that 
16:53:44 <enthymeme> it's a Functor type
16:53:50 <napping> benmachine: substitution
16:53:53 <rostayob> enthymeme: that's different ehe
16:54:03 <enthymeme> I'm aware of that
16:54:14 <rostayob> well why would you make a tree a monad?
16:54:14 <enthymeme> if I'm able to define mzero and mplus though, should it matter?
16:54:15 <benmachine> napping: hm?
16:54:19 <napping> return = Leaf, Leaf x >>= f = f x; Branch l r >>= f = Branch (l >>= f) (r >>= f)
16:54:32 <benmachine> enthymeme: MonadPlus things need to be Monad, hence the name :)
16:54:49 <rostayob> napping: fair enough
16:54:52 <benmachine> enthymeme: it's because there are special MonadPlus laws that define how mzero and mplus interact with >>= and return
16:54:56 <enthymeme> rostayob: not much reason, just taking my first stab at making something an instance of a monad type  
16:55:05 <enthymeme> benmachine: aaah, right
16:55:14 <enthymeme> I just got to that point in the Gentle Introduction to Haskell
16:55:29 <rostayob> enthymeme: no I'm saying that because Functor and Monoid on a tree make a lot of sense
16:55:42 <enthymeme> cool, thanks rostayob, I'll look into those
16:55:50 <enthymeme> it's already a Functor instance, they do that in the tutorial
16:56:21 <acowley> Functor and Monoid (and Applicative) should be your bread and butter
16:56:39 <rostayob> see Functor as the generalization of map, and Monoid as the generalization of (++)
16:56:39 <enthymeme> I figured I'd have mzero of a (MonadPlus m) => Tree (m a) be the above, and the mplus add the monadic value with it's own mplus to each of the leaves
16:56:43 <rostayob> kind of...
16:56:49 <enthymeme> thus if you call it with the mzero of the type you get back the same tree
16:57:01 <enthymeme> it kinda trivially satisfies the laws there.
16:57:25 <benmachine> rostayob: I don't know that there is a good monoid for that tree, actually, what did you have in mind?
16:58:10 <benmachine> maybe Monoid a => Monoid (Tree a)
16:58:12 <rostayob> benmachine: well joining the trees I guess... now that I think about it is not that obvious
16:58:20 <enthymeme> mappend glues two trees together as a branch, mconcat replaces each leaf with the second argument? 
16:58:36 <benmachine> enthymeme: Monoids need an identity
16:58:42 <benmachine> so you can't have mappend doing that
16:58:45 <enthymeme> aaah 
16:58:53 <enthymeme> that's part of what attracted me to MonadPlus
16:59:01 <benmachine> monadplus isn't any better :P
16:59:01 <rostayob> benmachine:  you are very right yeah
16:59:08 <enthymeme> if every MonadPlus type has a zero, I can use it for that purpose.
17:00:13 <benmachine> enthymeme: oh, hang on, I just noticed – MonadPlus (Tree (m a)) isn't going to work at all
17:00:23 <benmachine> it's the wrong kind
17:00:29 <enthymeme> yep
17:00:33 <enthymeme> that's what I've been getting
17:00:38 <benmachine> MonadPlus m has mzero :: m a
17:00:52 <benmachine> so MonadPlus (Tree (m a)) has mzero :: Tree (m a) a
17:00:54 <enthymeme> *nod nod* way ahead of you there. 
17:00:58 <benmachine> fair enough :P
17:01:05 <benmachine> I think Monoid a => Monoid (Tree a) might work
17:01:33 <enthymeme> I'll keep looking into it.  Thanks a lot! I love these abstract data types.
17:01:54 <benmachine> enthymeme: an alternative is changing your tree definition
17:02:00 <benmachine> there are like a million types that make good trees
17:02:10 <benmachine> depending on whether you want to allow empty trees or not, etc.
17:04:23 <byorgey> according to the Report, is --- a valid operator name?
17:04:31 <dolio> Yes.
17:05:01 <byorgey> that's what I thought.  GHC is giving me a parse error though.  maybe something else is wrong.
17:05:15 <dolio> > let (---) = (-) in 3 --- 2
17:05:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:05:23 <benmachine> huh
17:05:27 <benmachine> cuuuurious
17:05:38 <dolio> I could have sworn I've done that before, and it worked.
17:05:42 <dolio> Maybe the parser changed.
17:05:52 <benmachine> > let a --! b = a in 3 --! 2
17:05:52 <lambdabot>   3
17:05:53 <enthymeme> is it interpreting it as a comment?
17:05:57 <benmachine> blink blink
17:06:02 <Eduard_Munteanu> I wonder if it messes up syntax highlighting, in case it's allowed.
17:06:10 <dolio> > let x --- y = x - y in 3 --- 2
17:06:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:06:16 <benmachine> > let x
17:06:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:06:22 <benmachine> it might be!
17:06:44 <dolio> > 5 --- 2
17:06:44 <lambdabot>   5
17:06:51 <Eduard_Munteanu> :t (---)
17:06:52 <benmachine> > case () of _ -> 3 --- 2 where (---) = (-)
17:06:52 <lambdabot> parse error (possibly incorrect indentation)
17:06:52 <lambdabot>   3
17:06:55 <benmachine> :>
17:07:15 <Eduard_Munteanu> Strange.
17:07:26 <benmachine> yep
17:07:30 <dolio> Is --- a special kind of comment in GHC?
17:07:44 <dolio> > let x ---- y = x - y in 5 ---- 2
17:07:45 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:07:55 <benmachine> hmmm
17:08:00 * benmachine goes to check the report
17:08:08 <benmachine> I've definitely seen ------------------------- used as a separator
17:08:13 <benmachine> so maybe it *is* a comment
17:08:28 <rostayob> yeah exactly
17:08:30 <dolio> I usually write "-- -----------"
17:08:33 <rostayob> I often put ---------- lines
17:08:37 <Eduard_Munteanu> > let ({---}) = (-) in 3 {---} 2
17:08:37 <shachaf> According to vim syntax highlighting --- is a comment.
17:08:38 <lambdabot>   Couldn't match expected type `()'
17:08:38 <lambdabot>         against inferred type `a -> a -> a'
17:08:46 <benmachine> shachaf: not authoritative :P
17:08:52 <rostayob> shachaf: vim didn't detect --> as an operator as far as I remember eheh
17:08:55 <benmachine> Eduard_Munteanu: erp
17:09:12 <Eduard_Munteanu> (but then again I'm not sure what's allowed in there)
17:09:15 <shachaf> rostayob: No, it detects operators like -->.
17:09:22 <rostayob> shachaf: oh, now it does
17:09:37 <benmachine> An ordinary comment begins with a sequence of two or more consecutive dashes (e.g. --) and extends to the following newline. The sequence of dashes must not form part of a legal lexeme. For example, “-->” or “|--” do not begin a comment, because both of these are legal lexemes; however “--foo” does start a comment. 
17:10:01 <byorgey> drat!
17:10:19 <rostayob> I remember editing the xmonad config file some time ago and getting comments after --> :P
17:10:21 <dolio> Ah well.
17:10:29 * benmachine unsure if --- is a legal lexeme
17:10:46 <Eduard_Munteanu> "two or more consecutive"
17:10:46 <dolio> It is if it's not defined as a comment.
17:10:50 <shachaf> > let (—) = (-) in 5 — 2
17:10:51 <lambdabot>   3
17:11:05 <shachaf> Will an em-dash make you feel better?
17:11:11 <Eduard_Munteanu> Heh, good one. Alas, I'm not sure if UnicodeSyntax decides to mess with it.
17:11:32 <shachaf> Does UnicodeSyntax make em-dash a comment character?
17:11:35 <benmachine> dolio: sequences of dashes are excluded from being varsym
17:11:41 <benmachine> shachaf: doubt it
17:12:04 <dolio> benmachine: I'm unhappy about that.
17:12:06 <shachaf> > let (-—-) = (-) in 5 -—- 2
17:12:07 <lambdabot>   3
17:12:14 <dolio> Haskell needs to be as hard to parse as possible.
17:12:22 <benmachine> heh
17:12:26 <systemfault> It can't be worse than C++
17:12:49 <Eduard_Munteanu> Is the latter that bad? :/
17:12:53 <benmachine> C++ is pretty bad
17:12:56 <shachaf> > let (–––) = (-) in 5 ––– 2,
17:12:57 <benmachine> so I've heard
17:12:57 <lambdabot>   <no location info>: parse error on input `,'
17:13:03 <danharaj> hmmm
17:13:05 <parcs> i've read that ruby is a pain to parse
17:13:12 <enthymeme> aww, that makes me sd
17:13:17 <enthymeme> I'm applying for a Ruby developer job.
17:13:32 <benmachine> Eduard_Munteanu: http://yosefk.com/c++fqa/web-vs-c++.html the two items on C++ grammar here are amusing
17:13:34 <Eduard_Munteanu> And they're employing you as a parser? :P
17:13:36 <shachaf> enthymeme: Of or in Ruby?
17:13:42 <danharaj> So I need a library for loading images data from file so I can make textures in opengl. It doesn't seem like there's a library for that that handles a wide variety of formats.
17:13:52 <danharaj> And the ones that do exist are of tenuous supportedness.
17:14:13 <byorgey> I guess I'll use (===) instead of (---)
17:14:46 <acowley> danharaj: stb_image is no good?
17:14:56 <acowley> stb-image even
17:15:39 <danharaj> acowley: Ideally I would have something that can automatically rescale to dimensions of powers of two.
17:16:07 <enthymeme> shachaf: a job as a ruby programmer in an ostensibly LAMP shop (maybe they're LAMRnating their business, lawl
17:16:37 <dolio> I don't think it's hard to parse for the purposes of understanding/writing it.
17:17:04 <acowley> danharaj: the two options I've used for just that in the past are to call out to image magick and OpenCV bindings
17:17:11 <acowley> the call to imagemagick isn't so bad
17:17:50 <danharaj> tell me more of these magicks
17:18:00 <acowley> just figure out the resize syntax, output to /tmp and load using stb-image
17:18:10 <dmwit> ?tell pumpkin No news on Hac Phi yet. We've nailed the dates down (check the wiki), but we're trying to figure out a few things before we open up registration.
17:18:10 <lambdabot> Consider it noted.
17:18:22 <acowley> google for imagemagick
17:18:36 <danharaj> alright.
17:19:01 <danharaj> Thanks. Anyway, it seems like this is something that should have a convenience library with less dependencies :) *writes it down on bounty list*
17:19:34 <acowley> danharaj: it's too complicated
17:19:48 <acowley> danharaj: if you want high quality on the resize, then you need to do some work
17:21:13 <napping> do you really have to resize to a power of 2?
17:21:36 <acowley> napping: On some older video cards, yes
17:21:45 <napping> I thought everything supported images of other sizes
17:22:25 <acowley> In my experience, that's one of those assumptions that breaks down when someone tries to run your code on a laptop management purchased 4 years ago
17:22:32 <danharaj> word.
17:23:23 <acowley> It's the graphics version of supporting IE6, I suppose
17:24:16 <danharaj> meh I guess I can just say "fuck it" and fill that hole in the moment someone complains.
17:24:57 <acowley> Probably. Though I recently had one project where no one told me about an issue like this on a particular laptop until demo day
17:25:23 <acowley> Be happy you don't have to support maximum texture sizes of 256x256!
17:25:25 <danharaj> That must have been a fun experience.
17:25:30 <danharaj> heh. :p
17:25:56 <acowley> It was such a classic thing where the user (an engineer himself in this case) casually mentioned how he was bending over backwards to keep the app from crashing
17:26:03 <acowley> and I was like, "You what!??!?!"
17:26:39 <danharaj> haha
17:26:45 <danharaj> oh dear.
17:27:16 <znutar> older iphones require power of 2 and square textures, iirc
17:33:37 <danharaj> hmmm... maybe I should use SDL-Image.
17:34:54 <Taslem> How can you write the function:          f x = a $ b x     in a point-free way?
17:35:09 <danharaj> @pl (\x -> a $ b x)
17:35:09 <lambdabot> a . b
17:35:44 <Taslem> Oh, duh. I can't believe that didn';t occur to me.
17:35:48 <danharaj> :)
17:36:04 <danharaj> I am the king of being oblivious.
17:36:49 <Taslem> @pl (\x -> if f x then a x else b x)
17:36:49 <lambdabot> ap (liftM2 if' f a) b
17:42:07 <Eduard_Munteanu> danharaj: many GPUs can take non power of two textures, IIRC
17:42:14 <Taslem> How does lambdabot's @pl work?
17:44:59 <hpc> Taslem: it uses rewrite rules to put free variables at the front of an expression, then eliminate them
17:45:15 <Taslem> Hm, neat.
17:45:18 <Eduard_Munteanu> eta-reduction?
17:46:06 <Eduard_Munteanu> IIRC.
17:46:51 <Taslem> How convoluted does @pl's results get?
17:47:29 <Taslem> Is it possible to define implicit conversions from one type to another?
17:47:34 <danharaj> @pl (\a b c d e f g h i j k -> k i j h g e f d b c a)
17:47:37 <lambdabot> flip (flip . ((flip . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .)
17:47:37 <lambdabot> .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip (flip . (flip .) .
17:47:37 <lambdabot>  ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((
17:47:37 <lambdabot> (((flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) .
17:47:37 <lambdabot> flip (flip . (flip .) . flip . flip id))))))
17:47:39 <lambdabot> optimization suspended, use @pl-resume to continue.
17:47:46 <Taslem> Wow. :P
17:47:57 <danharaj> flips and nipples
17:48:06 <Taslem> It calls that an "optimization?"
17:48:46 <hpc> Taslem: it doesn't call it an optimization :P
17:48:47 <Taslem> Can you define an implicit conversion from one type to another? Such that if you use one in place of another, it would convert?
17:48:53 <Taslem> "optimization suspended"
17:48:57 <Taslem> Yes, it does. :P
17:49:36 <Taslem> When compiling, will Haskell do that?
17:49:44 <Taslem> Make all functions point-free?
17:49:48 <dolio> No.
17:50:35 <hpc> @faq When compiling, will Haskell do that?
17:50:35 <lambdabot> The answer is: Yes! Haskell can do that.
17:50:40 <hpc> :P
17:50:49 <hpc> (but it doesn't)
17:50:54 <Taslem> :P
17:52:16 <Eduard_Munteanu> @pl (\a b c -> c (map b) (map a))
17:52:16 <lambdabot> flip (flip . flip id . map) . map
17:53:05 <Taslem> @pl (\x y z -> x (y z))
17:53:05 <lambdabot> (.)
17:53:07 <sordina> Hello. Is there a nice way to get cabal and cabal install installed from just ghc?
17:53:36 <jeffwheeler> sordina: bootstrap.sh in the cabal-install package
17:53:39 <gwern> sordina: nope. you're probvably best off using the cabal install bootstrap
17:53:45 <Taslem> (\x y z -> x y z)
17:53:54 <Taslem> @pl (\x y z -> x y z)
17:53:54 <lambdabot> id
17:54:06 <sordina> Thanks guys
17:55:01 <Eduard_Munteanu> @free (.)
17:55:01 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:55:32 <jeffwheeler> Eduard_Munteanu: :(
17:55:37 <danharaj> friggin opengl texture objects have like ten billion parameters
17:55:53 <Taslem> @pl (\(nam,val) vars -> (nam,val):[(x,y)|(x,y)<-vars,x/=nam])
17:55:53 <lambdabot> uncurry (ap (flip . (((.) . (:)) .) . (,)) (flip ((:) . (((x, y) | (x, y)) <-)) . return . (x /=)))
17:55:56 <Eduard_Munteanu> @free (b -> c) -> (a -> b) -> (a -> c)
17:55:56 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:56:03 * Eduard_Munteanu forgets how that works
17:56:20 <espringe> If I have a function 'f' and a 'subfunction' (as in a nested function, using let/where) -- is it possible to get this subfunction in "scope" from outside? (So I can independently test it) 
17:56:20 <hpc> you give free a function and it gives the free theorem for it
17:56:25 <espringe> I'm mainly thinking from ghci 
17:56:33 <Eduard_Munteanu> Well yeah, but it won't take it ;)
17:56:37 <Taslem> Did I just break lambdabot or something?
17:56:44 <Eduard_Munteanu> @free map
17:56:45 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
17:56:48 <danharaj> no, Eduard did. sort of.
17:56:49 <Eduard_Munteanu> Hrm.
17:57:08 <jeffwheeler> . . . what . . . is that?
17:57:14 <Taslem> What's "free" supposed to do?
17:57:23 <jeffwheeler> @src $map
17:57:23 <lambdabot> Source not found. My pet ferret can type better than you!
17:57:27 <Eduard_Munteanu> @free \f g x -> f $ g x
17:57:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:57:50 <Eduard_Munteanu> Ah so it probably works for just a few things.
17:58:10 <jeffwheeler> @pl \f g x -> f (g x)
17:58:10 <lambdabot> (.)
17:58:22 <jeffwheeler> @pl \f g x -> f $ g x
17:58:22 <lambdabot> (.)
17:58:22 <Eduard_Munteanu> Taslem: like hpc said above.
17:58:37 <Eduard_Munteanu> Inspired by Wadler's "Theorems for free".
17:59:22 <Eduard_Munteanu> Basically theorems you can derive from types and parametricity alone.
18:00:15 <danharaj> Is there any nuance to parametricity other than "Polymorphic functions are natural transformations in some category"?
18:00:43 <Eduard_Munteanu> I haven't seen the CT aspect of it yet :/
18:01:27 <tcard> If somebody is up to helping me with a basic monad question, I have the question and code here: http://hpaste.org/paste/45209/random2hs_revision_2#p45210
18:01:34 <monochrom> it just comes down to natural transformation
18:02:11 <Eduard_Munteanu> So basically 'g . h = k . f => $map g . map h = map k . $map f' boils down to some commutative square diagram? Or something like that? :)
18:02:18 <monochrom> yes
18:02:26 <Eduard_Munteanu> Mm, makes sense.
18:02:28 <enthymeme> I wonder if there's a book out there about exploring category theory through haskell
18:02:40 <Eduard_Munteanu> I wish.
18:02:51 <danharaj> It'll probably happen eventually.
18:02:59 <hpc> any haskell focused CT book would probably be very easy to get wrong
18:03:05 * Eduard_Munteanu hopes edwardk takes that task up ;)
18:03:25 <Eduard_Munteanu> hpc: I'd rather have a CT-focused Haskell book.
18:03:33 <rostayob> is there any library that provides lazy access to a database?
18:03:37 <Eduard_Munteanu> So you don't make math people cry.
18:03:37 <rostayob> with lazy queries I mean
18:03:53 <mikeg> @type replicateM -- tcard
18:03:53 <hpc> Eduard_Munteanu: me too, it just would have to be done right, so the math people can read it without crying
18:03:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:03:59 <danharaj> As someone who hangs out in a math department, a lot of math people actually like Haskell :)
18:04:08 <hpc> rostayob: yes, HDBC
18:04:33 <rostayob> hpc: thanks, I'll look into it
18:04:39 <hpc> danharaj: as a legitimately good thing, or as a good enough tool like matlab?
18:04:53 <hpc> haskell does play fast and loose with CT
18:04:53 <rostayob> hpc: does it provide some sort of mapping to algebraic data types as well?
18:04:56 <Taslem> @pl (\x -> map (\x -> if x == ',' then ' ' else x) s)
18:04:56 <lambdabot> const (map (flip if' ' ' =<< ((',') ==)) s)
18:04:58 <Eduard_Munteanu> I doubt the second applies IMHO.
18:05:10 <danharaj> hpc: A mathematical physicist I talked to the other day described it as such "Haskell is the way things should be done, if they could be done that way"
18:05:11 <tcard> mikeg: thank you!  I looked it up in hoogle and am working on it now.
18:05:13 <rostayob> I mean does it come with some sort of type safety?
18:05:18 <Taslem> map (\s -> if x == ',' then ' ' else x) s
18:05:27 <hpc> rostayob: toSql :: Convertable a Sql => a -> Sql -- or something like that
18:05:31 <hpc> and fromSql the reverse
18:05:32 <Eduard_Munteanu> There isn't enough stuff around to do Matlab-ish stuff in it comfortably.
18:05:38 <rostayob> hpc: cool, thanks
18:05:39 <Taslem> @pl (\x -> map (\x -> if x == ',' then ' ' else x) s)
18:05:39 <lambdabot> const (map (flip if' ' ' =<< ((',') ==)) s)
18:05:50 <Taslem> @pl (\s -> map (\x -> if x == ',' then ' ' else x) s)
18:05:50 <lambdabot> map (flip if' ' ' =<< ((',') ==))
18:05:52 <danharaj> Haskell needs better library support for scientific computing and I think it would become a big hit.
18:06:12 <hpc> danharaj: there's a ticket on the summer of code trac to turn haskell into a sage-like thing
18:06:23 <hpc> with libraries and perhaps an IDE
18:06:28 <monochrom> tcard: first choice: rollNDice n = replicateM n rollDice. but replicateM uses the same code as yours. second choice: rollNDice n = do { g <- newStdGen; return (take n (randomRs (1, 6))) }
18:06:38 <danharaj> hpc: that's a cool idea.
18:06:45 <danharaj> I'm glad there are Top Men working on it :D
18:06:51 <Eduard_Munteanu> (Fake) dependent types would make a nice approach, but even without those, it isn't there yet :/
18:07:01 <Eduard_Munteanu> Nice.
18:07:02 <monochrom> err, rollNDice n = do { g <- newStdGen; return (take n (randomRs (1, 6) g)) }
18:07:09 <hpc> danharaj: it's a project i could see myself spending time on
18:07:13 <Taslem> Symbolic variables would be nice. Like, values that are not assigned values and so cannot be evaluated.
18:07:26 <danharaj> hpc: As myself, if I didn't already have a list of things I really should do in Haskell.
18:07:34 <Eduard_Munteanu> Taslem: um? Say, undefined? :P
18:07:44 <Taslem> Not undefined. Ever used Mathematica?
18:07:59 <Eduard_Munteanu> Not really. I used Maxima, I think that's similar a bit.
18:08:11 <tcard> monochrom: Thanks for the feedback!  I think replicateM is more along the lines of what I was looking for, but I will investigate both methods.
18:08:52 <hpc> danharaj: i have a rather large list too, but this i wouldn't feel bad about prioritizing; my others are mostly maintenance or ridiculous ambition
18:09:10 <Eduard_Munteanu> Secondly I think someone needs to come up with numeric algos that lend themselves better to functional approaches.
18:09:11 <Taslem> Basically, I'm referring to "variables" that aren't pointers. So they have an arbitrary type, and when evaluated in expressions, do not simplify.
18:09:15 <Taslem> Such as (a + b)
18:09:19 <Taslem> It would stop there.
18:09:38 <GreaseMonkey> hmm, considering that it's april fools day, should the topic be in the (thing:(thing:(thing:(...:(thing:[]))))) form?
18:09:41 <Taslem> BUT, it would also have suport for stuff like:   (a + b) * c == a*c + b*c           ----> True
18:09:44 <danharaj> hpc: Mine is right now "Write a friggin game in Haskell already you lazy nob"
18:10:05 <GreaseMonkey> heh, nice
18:10:15 <danharaj> the second thing on the list is
18:10:21 <GreaseMonkey> i've never heard of games written in haskell but i have heard of a mod player done in haskell
18:10:34 <Taslem> I've heard of games. There's a list on the wiki somewhere.
18:10:39 <danharaj> "Hey numerical integration is cool, write a simulator for systems of rigid bodies with constraints and play around"
18:10:41 <Eduard_Munteanu> Frag.
18:10:52 <hpc> GreaseMonkey: perhaps it could be in the form Mu {unMu = (thing, Mu {unMu... (thing, *Exception: undefined
18:10:53 <danharaj> Raincat is a cute game.
18:10:53 <espringe> There's 'haskell in space' iirc
18:10:56 <espringe> an astroids game
18:10:57 <hpc> :D
18:11:08 <hpc> there's also monadius, a gradius clone
18:11:14 <danharaj> Mazes of Monad
18:11:21 <danharaj> iirc a rogue-like for unix systems.
18:11:23 <GreaseMonkey> i'm not very familiar with haskell but anything that's nasty looking gets the :D from me
18:11:27 <Eduard_Munteanu> > deriv sin $ x
18:11:28 <lambdabot>   1 * cos x
18:11:37 <aristid> :t deriv
18:11:38 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
18:11:50 <aristid> where is that from, again?
18:11:59 <danharaj> isn't there a source command?
18:12:00 <hpc> GreaseMonkey: Mu is the Y combinator at the type level
18:12:01 <Eduard_Munteanu> @hackage ad
18:12:01 <lambdabot> http://hackage.haskell.org/package/ad
18:12:02 <hpc> @src Mu
18:12:02 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
18:12:05 <Eduard_Munteanu> IIRC
18:12:17 <Eduard_Munteanu> Taslem: there are tricks like that ^^
18:12:49 <Eduard_Munteanu> > deriv (*) x y
18:12:50 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif b'
18:12:50 <lambdabot>         against inferr...
18:12:52 <Taslem> Yeah, I know. But most of it would be pretty verbose.
18:12:54 <Eduard_Munteanu> Ouch.
18:12:58 <shachaf> > 1 :: Mu Maybe
18:12:59 <lambdabot>   No instance for (GHC.Num.Num (L.Mu Data.Maybe.Maybe))
18:13:00 <lambdabot>    arising from the l...
18:13:09 <Eduard_Munteanu> Ok, that was stupid :)
18:13:40 <Eduard_Munteanu> > deriv tan $ x
18:13:40 <lambdabot>   1 * cos x * recip (cos x) + sin x * negate (1 * negate (sin x) * recip (cos...
18:13:56 <hpc> lol
18:14:19 <danharaj> I sort of wish there were a DirectX 10 binding for Haskell.
18:14:32 <danharaj> I like D3D 10+ more than OpenGL :<
18:14:52 <Eduard_Munteanu> danharaj: I hear recent OpenGL are more like it
18:14:58 <Eduard_Munteanu> *APIs
18:14:59 <shachaf> > deriv (sin^2 + cos^2) x
18:15:00 <lambdabot>   1 * cos x * sin x + sin x * (1 * cos x) + (1 * negate (sin x) * cos x + cos...
18:15:15 <Eduard_Munteanu> Like, no more messy state machine.
18:15:41 <danharaj> At least for OpenGL 3.1, it's still a pretty messy state machine.
18:15:46 <danharaj> But they got rid of a lot of cruft.
18:15:57 <acowley> danharaj: how so? most of your work is in shaders
18:16:39 <danharaj> acowley: I consider any global state to be messy ever since I drank the Haskell kool-aid.
18:16:44 <Eduard_Munteanu> There's even a D3D10/11 state tracker for Gallium in Linux, so that says something about how much cleaner D3D is nowadays.
18:17:02 <Eduard_Munteanu> Heh.
18:17:11 <acowley> danharaj: But what global state do you have? I think in teh grand scheme of things it's pretty minimal
18:17:40 <danharaj> acowley: I'm thinking mostly of just some minor things, like bunding buffer objects and textures.
18:17:45 <acowley> you need to work out how you are going to coordinate animate, draw, and input, but that's a small part of any sizable thing
18:18:41 * Eduard_Munteanu whispers FRP :P
18:19:09 <acowley> there is that, but these are usually performance sensitive areas, so having tight control over allocation has its benefits
18:19:43 <acowley> I think the big sign of that is that no one has written a really functional wrapper that has caught on
18:19:44 <danharaj> acowley: yeah, I mean it's not like it doesn't have a purpose. Graphics programming is one of those things where having fine control over memory management is important.
18:19:58 <acowley> they all have their own deficiencies
18:20:27 <danharaj> acowley: I am working on a wrapper for my own use, but the only goal I have is more type safety.
18:21:04 <acowley> I've found the little library I linked in my recent modern opengl tutorial port pretty helpful for the basics, but on some level dealing with the idiosyncracies of GLSL and what operations are fast or slow forces you to acknowledge the hardware
18:21:43 <acowley> The OpenGL library offers quite a nice degree of type safety, where do you think it's too loose?
18:21:57 <danharaj> that post's comments made me smile because the first couple of commenters completely missed the point :)
18:22:14 <danharaj> "Why is there no screenshot?"
18:22:35 <acowley> It was a very pragmatic post... I didn't make any effort to say, "Gee whiz! Graphics in Haskell!!!"
18:22:40 <acowley> which is perhaps needed
18:23:01 <acowley> I may write up something about a larger application just for the snazzy screenshots
18:23:21 <danharaj> acowley: I don't have a problem with the opengl library, but I want to write something up from opengl.raw to get acquainted with opengl a bit better.
18:23:26 <acowley> but I think that's disingenuous, as the final graphics frankly have nothing to do with Haskell
18:23:50 <BMeph> danharaj: I'd say that Java's graphics libraries belie that "fine control" argument... ;)
18:23:58 <acowley> danharaj: ah, well that's a large undertaking!
18:24:17 <Taslem> What's the best way of writing....   a (b c) (d e)     ?
18:24:24 <acowley> danharaj: do be careful with that, as both OGL and DX have shifting "recommended" API areas
18:24:37 <GuacamoleMcDange> a (b c) (d e)
18:24:39 <shachaf> Taslem: Probably a (b c) (d e). Seems clear enough.
18:24:41 <acowley> foo
18:24:44 <GuacamoleMcDange> haha
18:25:26 <danharaj> acowley: Is that so? I thought the paradigm of VBO's, Textures, Shaders was fairly settled now.
18:26:34 <acowley> danharaj: Sorry, yes, it is! I'm being a curmudgeon. Excpet that you have things like http://developer.nvidia.com/object/bindless_graphics.html
18:26:48 <acowley> It's very frustrating
18:27:11 <acowley> Then you need to consider if you have texture unit access in vertex and geometry shaders. Things like that
18:27:31 <acowley> The broad strokes are perhaps consistent, and that's why a small utility library to wrap them up makes sense
18:27:43 <acowley> but how you should put them together changes with the wind
18:29:41 <danharaj> Not needing to bind buffer objects seems very natural to me, and maybe that's why I don't like the whole "bind this, bind that, execute" paradigm.
18:30:37 <acowley> I agree. But it's the kind of detail that most of us don't want to think about.
18:30:49 <acowley> Well, *I* don't want to think about :)
18:31:24 <acowley> My point was just that I don't even know if those extensions are widely supported, yet they claim a huge perf. impact
18:31:49 <Eduard_Munteanu> I don't even know if bindable uniforms work yet :/
18:31:51 <acowley> Which makes me wary of investing much into an elaborate, bespoke abstraction layer
18:32:07 <danharaj> acowley: ah, so you expect that there might be a new api revision if such and such new extension becomes a flavor of the month at some point.
18:32:15 <danharaj> acowley: you seem to have the cynicism of years of experience :p
18:32:34 <acowley> I think the smart money is to do your best with your application, but stay somewhat faithful to what OGL, DX, and Nvidia are doing
18:32:41 <acowley> danharaj: that's my cachet
18:33:18 <acowley> I would love to see a really great Haskell graphics library, but it's an uphill battle
18:33:44 <acowley> so, in the meantime, being able to refer to the collective wisdom surrounding APIs whose sole abstraction is the GLint is valuable
18:34:34 <Taslem> Are there any graphics librariers that just make a "Canvas" type and then give you functions to manipulate it, and paint it to the screen?
18:34:51 <acowley> Taslem: Gloss is very nice
18:35:16 <Taslem> I had trouble with getting Gloos to run. :/
18:35:22 <danharaj> acowley: I am not someone who knows a thing about how graphics should work, but I think the abstraction I'm going to work over is "I have all this geometry over here. Shove it onto the GPU. Run a shader program on it."
18:35:25 <Taslem> Missing glut32 or something.
18:35:45 <acowley> Taslem: what OS?
18:35:52 <Taslem> Windows Vista.
18:36:02 <acowley> danharaj: that's what I try to do, too. 
18:37:56 <acowley> Taslem: I think you need to download and install GLUT
18:38:08 <Taslem> Yeah, I figured. Didn't spend the time to do it though.
18:38:28 <Taslem> This is the third time *today* that I've rewritten my program! :D
18:49:40 <accel> yo yo yo
18:49:45 <accel> is there a good tutorial
18:49:50 <accel> that shows how to implemnt the algorithms in CLRS
18:49:53 <accel> in haskell ?
18:49:58 <accel> CLRS = alogrithms 101
18:55:10 <Taslem> Can ghci trace function calls?
18:55:26 <danharaj_> Giving a type to all the various subsets of GLenum seems like a fool's errand.
18:58:07 <accel> isn't error :: String -> a
18:58:15 <accel> more accurately described as :: String -> IO a
18:58:19 <accel> I don't see how error is a pure function
18:58:22 <accel> it terminates execution
18:58:43 <Taslem> Which means that it can't effect further calls.
18:58:50 <danharaj> You can't observe the side effects :)
18:58:54 <Taslem> Right.
18:59:13 <Taslem> Sort of like how only printing, but not reading, is "pure." But Haskell does not know that. :P
18:59:23 <danharaj> No, that's not true.
18:59:32 <Taslem> Well, the program's course cannot be changed.
18:59:45 <Taslem> The "prints" might as well be dropped, and the program will excute the same.
18:59:59 <acowley> accel: it has *any* type you want it to have
19:00:12 <acowley> accel: that's how it type checks wherever you put it
19:00:13 <danharaj> error has that type so you can embed it anywhere you need it to be
19:00:35 <Taslem> What does it actually return, though? 
19:00:37 <acowley> Taslem: but the print might be called any number of times
19:00:50 <acowley> Taslem: undefined
19:00:53 <Taslem> So? The print can be called over and over... But no part of the program can observe it.
19:00:59 <danharaj> there is a value in every type
19:01:02 <danharaj> called bottom
19:01:06 <danharaj> or undefined if you like.
19:01:19 <acowley> Taslem: I can't read from a file that I wrote to?
19:01:19 <danharaj> :t undefined
19:01:20 <lambdabot> forall a. a
19:01:44 <Taslem> No, what I SAID was that in the context of an environment that never reads, printing/outputting is pure.
19:02:12 <Taslem> So if you restrict the domain of the functions the program has access to, output becomes pure.
19:03:41 <danharaj> Not true.
19:03:44 <danharaj> print can fail :)
19:03:44 * Axman6 thinks about error as not returning, so everything is sweet if you something like hoare logic, ie partial correctness
19:04:56 <Axman6> more importantly, print can succeed many times with the same input and then fail
19:05:49 <danharaj> as long as there's a way to distinguish print from (const ()), it's not pure. :p
19:07:10 <Axman6> const (return ())?
19:07:36 <danharaj> Well, assuming print :: String -> (), postulating it is pure.
19:07:48 <danharaj> But it isn't because you can't replace a call to it with (). It's different from const ().
19:07:54 <Axman6> :t const (return ()) `asTypeOf` print
19:07:54 <lambdabot> forall b. (Show b) => b -> IO ()
19:16:15 <danharaj> Now I know why opengl only has one type for enumerated parameter values.
19:21:02 <acowley> danharaj: why would anyone need more than one type?
19:37:19 <accel> http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html <-- the section on "Incorrectly Matching Against a Variable". I do not understand, why can't I match against "apple" if apple = "apple" ?
19:38:03 <Axman6> because apple is just a name that will be bound to whatever is passed to it. it's equivalent to the pattern match x
19:38:18 <Axman6> you can do x | x == apple if you like
19:38:41 <accel> huh?
19:38:43 <accel> why is x == apple
19:38:45 <accel> different from 
19:38:49 <accel> case f of apple -> ... ?
19:38:54 <accel> in both cases, we look up apple to get "apple"
19:39:20 <Axman6> no, in the second case, you bind the name apple to whatever value f has
19:39:54 <Axman6> case f of apple -> foo is exactly the same as case f of x -> foo, it gives the name apple/x to the value of f
19:39:58 <accel> oh shit
19:40:04 <accel> so it introduces a new binding
19:40:05 <accel> and basically
19:40:08 <accel> always returns Apple ?
19:40:09 <Axman6> yes
19:40:12 <accel> Axman6 ++
19:40:15 <Axman6> huh?
19:40:25 <Axman6> what do you mean by always returns Apple?
19:40:36 <accel> whichFruit f = case f of apple -> Apple
19:40:39 <accel> will always return Apple
19:40:42 <Axman6> yes
19:40:48 <accel> because whichFruit asdfasdf, binds apple to asdfasdf 
19:40:49 <accel> then returns Apple
19:41:06 <Axman6> if you did case f of "apple" then you'd get something different
19:43:45 <michaelh> hi, can someone please comment on this? http://hpaste.org/45211/which_version_is_better
19:44:12 <dmwit> The error message on the first one is much better.
19:44:19 <michaelh> :P
19:44:56 <dmwit> michaelh: Yours looks fine, but why bother with the third case?
19:45:01 <dmwit> i.e. the (x:y:[]) case?
19:45:44 <dmwit> michaelh: As for which is "better", I would say that the LYAH version is slightly better because it shares the computation of computing the maximum on the tail between the two uses of it.
19:45:45 <Axman6> mrplugins: yours is horribly inefficient, it traverses the list n times, giving it a complexity of O(n^2)
19:45:53 <acowley> at which point the second one just binds the shared expression
19:45:58 <dmwit> michaelh: But you can take that feature and use your if/then/else syntax if you prefer.
19:46:18 <Axman6> > foldl1 max [1,5,2,6,54,63,23,6,54,3,46,45,73,64,56]
19:46:18 <dmwit> michaelh: Guards are just a convenient way to do if/then/else, but you're free to use whichever seems right to you.
19:46:18 <lambdabot>   73
19:46:40 <dmwit> Axman6: I think it's actually exponential, not n^2.
19:46:55 <Axman6> hmm, that's possible
19:47:16 <dmwit> michaelh: But yeah, the sharing is super important.
19:47:18 <Axman6> mrplugins: try running myMaximum [1..1000000]
19:47:30 <Axman6> > foldl1 max [1..1000000]
19:47:32 <danharaj> It's interesting how you can tell what the most important part of an API is by how big certain methods are :p
19:47:32 <lambdabot>   *Exception: stack overflow
19:47:34 <dmwit> Axman6: Presumably you meant michaelh both times, and not mrplugins.
19:47:38 <Axman6> > foldl1' max [1..1000000]
19:47:39 <lambdabot>   1000000
19:47:42 <danharaj> glTexImage* are huge monsters.
19:47:45 <mrplugins> yes, I'm quite confused.
19:47:56 <Axman6> uh yes... how did i manage that
19:48:12 <acowley> danharaj: (.) talks softly, but carries a big stick :)
19:48:19 * Axman6 hates it when people enter with the name first letter as who he's talking to >_<
19:48:21 <danharaj> acowley: touche.
19:48:55 <dmwit> Axman6: Fix your IRC client to go by most recent speech, not most recent activity.
19:49:02 <Axman6> dmwit: i think you're right, i think its complexity is O(2^n)
19:49:06 <acowley> I think OpenGL names get longer the less well founded the argument types are
19:49:08 <michaelh> Do I understand this right: LYH's version traverses less because of the guards (lazy)? whereas mine must traverse twice to evaluate x:xs every time?
19:49:15 <dmwit> michaelh: No.
19:49:24 <dmwit> michaelh: LYAH's traverses less because of the where.
19:49:27 <danharaj> acowley: I have to wonder if anyone actually uses the more esoteric targets and formats for texture data, amongst other parameters for other methods.
19:49:29 <dmwit> michaelh: The guards have nothing to do with it.
19:49:52 <acowley> danharaj: Yes! But even they're more like hints as to how you want the data stored on the GPU.
19:50:06 <acowley> danharaj: Debug tools to show you the format actually used are key
19:50:29 <acowley> danharaj: For instance, if you are encoding some data in a texture, then you want to be very specific about how the bits are used
19:51:15 <danharaj> acowley: I heard from wizards that it's probably RGBA or BGRA once it gets onto the card memory.
19:52:45 <acowley> danharaj: I am certainly no wizard, but if I can get 16-bit pixel depth (or more) on some texels, then I want it. For instance, when working with depth maps.
19:53:31 <acowley> I'm off, now! Until next time...
19:54:38 <mrplugins> Can I use ghc to compile a 32bit program on a 64bit installation of Windows 7?
19:54:51 <michaelh> dmwit: I understand. the where evaluates before the rest and keeps going until it hits maximum' [x]. whereas in mine, it goes straight to the if else with the two recursive calls.
19:54:51 <dmwit> Yes, if it's the 32-bit version of GHC.
19:55:15 <dmwit> michaelh: You're getting closer, but I don't think you've understood quite yet.
19:55:37 <dmwit> michaelh: The "where" doesn't force the evaluation to go ahead.
19:56:02 <dmwit> michaelh: But, it *does* mean that each thing defined there is evaluated only once.
19:56:10 <BMeph> Can I use ghc to compile a 64bit program on a 64bit installation of Windows 7? ;p
19:56:14 <dmwit> michaelh: So, *if* the thing in the where block gets evaluated, it's then cached.
19:56:35 <dmwit> michaelh: Since you have two places where you want to use the result, it's nice to have it cached that way.
19:57:13 <int80_h> :t <-
19:57:14 <lambdabot> parse error on input `<-'
19:57:21 <int80_h> @src <-
19:57:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:57:24 <Axman6> <- isn't a function, it's syntax
19:57:28 * int80_h pouts
19:57:30 <michaelh> Oh, I didn't realize that. was thinking that in | x > maxTail = x, maxTail was getting called. but it's just reading the results of the where.
19:57:36 <mrplugins> dmwit: I installed the haskell-platform for Windows. I don't know if it's 32 bit or not. I'm having issues with the plugins package: it refuses to load a target module, failing with "Not x86 PEi386".
19:57:52 <dmwit> int80_h: do { x <- foo; bar } desugars to (foo >>= \x -> bar).
19:57:58 <int80_h> Axman6: I'm trying to get an explicit idea of what it's doing
19:58:06 <dmwit> int80_h: ...unless "x" is a pattern, then it calls fail for failing pattern matches.
19:58:08 <int80_h> dmwit: thanks! that's what I need to know
19:58:39 <int80_h> dmwit: what about ->
19:58:51 <dmwit> int80_h: Syntax for lambdas.
19:59:11 <int80_h> dmwit: oh right. You havwe it right there in your example.
19:59:13 <dmwit> "\x -> e" in Haskell is roughly equivalent to "lambda x. e" in the FP literature.
19:59:15 <Axman6> do {pat <- f; bar} -> f >>= \x -> case x of bar -> bar; _ -> fail "Pattern match failure"} roughly...
19:59:15 <mrplugins> I had to modify the plugins package (plugins-1.5.1.4) to get it to compile on Windows, escaping backslashes and pulling some unknown functions into scope. It now compiles fine, but refuses to load by yelling "Not x86 PEi386".
19:59:37 <dmwit> mrplugins: Hm.
20:00:19 <dmwit> I definitely don't know, so I'll shut up now. Hopefully somebody else does know more.
20:01:02 <mrplugins> Is the plugins package still maintained? Did anyone use it on Windows successfully?
20:01:27 <mrplugins> I notice the homepage link on hackage is broken...
20:01:44 <dmwit> You might like something like DyRE instead.
20:02:20 <dmwit> lambdabot uses plugins, but I think people generally agree now that it's not the ideal architecture in Haskell.
20:04:23 <mrplugins> Thanks for DyRE, but I'm not sure it's what I need. I need to compile target Haskell code and "pull a function" from the compiled binary, then run it. Plugins does this easily on Linux, but not so much on Windows...
20:04:47 <dmwit> There's also the GHC API, hint, etc.
20:04:57 <mrplugins> There is no real replacement yet? I've heard of Hint, but that's just an interpreter? And I would need the speed.
20:05:42 <mrplugins> I can compile using the GHC API, but I have absolutely no clue how to "pull a function" (what are the correct terms here? :)) from the compiled binary.
20:06:51 <dmwit> me neither
20:08:05 <int80_h> > sequence [ Just 'a', Just 'b']
20:08:05 <lambdabot>   Just "ab"
20:08:56 <int80_h> > sequence [putStrLn "a", putStrLn "b"]
20:08:57 <lambdabot>   <IO [()]>
20:09:21 <dmwit> > sequence_ [putStrLn "a", putStrLn "b"]
20:09:21 <lambdabot>   <IO ()>
20:09:43 <int80_h> I'm going over the hitchhiker's guide to haskell, and it claims a different result
20:09:49 <int80_h> a
20:09:50 <int80_h> b
20:09:55 <int80_h> is what it claim would happen
20:10:03 <Axman6> yes, but lambdabot can't perform IO
20:10:12 <int80_h> oooh
20:15:20 <int80_h> You have mail.
20:15:31 <int80_h> http://hpaste.org/45212/squaring_the_circle_with_ghc
20:15:44 <osoleve> that's not mine.
20:18:10 <dmwit> int80_h: ?
20:18:26 <int80_h> dmwit: My attempt at a april fools
20:18:35 <int80_h> I mean, squaring the circle? Really?
20:18:41 <int80_h> burn!
20:18:47 <Axman6> you're a day late
20:18:50 <osoleve> april fools! it was mine
20:18:53 <int80_h> Not here!
20:19:01 <osoleve> and now dmwit is guilty of mail fraud
20:20:15 <dmwit> Oh no!
20:21:14 <int80_h> I always thought he looked like the shifty type
20:22:17 <int80_h> dmwit: turn from your life of crime! It's not too late!
20:22:39 <dmwit> I repent, I repent!
20:22:51 <dmwit> Just one last visit to the Pirate Bay and I'll be clean for life, I swear.
20:22:52 <osoleve> to quote MC Frontalot, "from this life of crime there is no turning back."
20:23:08 <osoleve> but i'm pretty sure HE was quoting someone from ATHF
20:24:14 <osoleve> s/is no/could be no/
20:24:19 <osoleve> :|
20:24:21 <michaelh> whoa, mc frontalot. that was back when batjew posted on the penny arcade front page.
21:52:04 <mercurial> Hi there, I'm playing around with GADT's and -XExplicitForAll, and I've written the canonical "Statically Safe List"; I cannot seem to implement the 'tail' operation in a type-safe way. Could anyone take a look at http://https://gist.github.com/899242
21:53:27 <mercurial> I'm wondering if there I am i) misunderstanding something subtle about the parametarized types or ii) I'm getting something wrong syntactically in the use of the ghc extensions
21:54:43 <copumpkin> mercurial: dude, you just missed the boston haskell meetup!
21:54:44 <brbr> hello
21:55:01 <brbr> has anyone read this book? Introduction to Functional Programming Systems Using Haskell
21:55:42 <copumpkin> mercurial: anyway, what's the error?
21:56:30 <copumpkin> :o
21:56:38 <copumpkin> mercurial17: anyway, your problem is that b is existential in Cons
21:57:19 <copumpkin> mercurial17: but in case you missed it, I literally just got back from the boston haskell meetup :P you should come next time
21:57:51 <mercurial17> copumpkin: I would've loved to have attended, but was busy all day
21:57:56 <copumpkin> ah ok :)
21:58:00 <Peaker> You guys need to make one in Israel
21:58:03 <mercurial17> how often do they run?
21:58:13 <copumpkin> mercurial17: about once a month, if we're lucky. There's a mailing list
21:58:18 <copumpkin> Peaker: you need to make one :P
21:58:23 <copumpkin> there's not a central entity that makes meetups
21:58:23 <mercurial17> copumpkin: yep; googling for it now
21:58:29 <copumpkin> interested people get together :)
21:58:49 <Peaker> I think there are probably not more than a dozen Haskellers in Israel
21:59:00 <copumpkin> get them together!
21:59:25 <shachaf> Peaker: Really? I thought there were more just in this channel.
22:00:07 <mercurial17> copumpkin: though I think attending the meetups would be great, I feel as if I have a mountain of papers/books to read through before I start participating in the community
22:00:33 <copumpkin> oh, I think a lot of the people who attend just dabble in it
22:00:40 <copumpkin> but want to hear more about it
22:00:46 <mercurial17> copumpkin: ah, interesting
22:01:14 <mercurial17> copumpkin: I'm comfortable with Haskell 98 (written a compiler and a few utilities in it)
22:01:26 <mercurial17> but just getting started with all the development that has happened over the past few years or so
22:02:18 <mercurial17> it turns out that writing a c compiler in a new language is a great way to learn that language ;-)
22:02:21 <Peaker> Shachaf, I know of just 5 Israeli Haskellers
22:02:38 <shachaf> Peaker: Who?
22:02:52 * shachaf isn't counted because he's in the US.
22:04:16 <Peaker> Aur saraf, me, Yair chuchem, Uri barenholz, dan aloni
22:04:41 <Peaker> I know of another guy who's supposed to be one
22:05:04 <shachaf> Peaker: Hmm. My father wrote a library on Hackage, so he might count.
22:05:17 <shachaf> There's gaal (Yahas), though he's disappeared in the Google black hole.
22:05:35 <Peaker> Which package? 
22:05:46 <shachaf> There's medfly, unless you've mentioned him already. There seems to be a "noam" in here.
22:05:59 <shachaf> @hackage YamlReference
22:05:59 <lambdabot> http://hackage.haskell.org/package/YamlReference
22:06:54 <shachaf> Calling it a "library" might be a stretch -- it's more of a reference parser. But it's Haskell. :-)
22:07:15 <Peaker> Google has some Haskellers.. Maybe in Israel too
22:07:27 <shachaf> I know of the one I mentioned.
22:07:39 <shachaf> Oh, and there's yitz in this channel.
22:08:31 <Peaker> This adds up to about 10 or so
22:09:37 <shachaf> I'm pretty sure there are others who've been here, though I can't remember their names.
22:10:01 <shachaf> There's an "Ilya" and an "Alex" and a "B K" on haskell-cafe.
22:10:13 <Peaker> B K? 
22:10:18 <copumpkin> mercurial: cool
22:10:38 <copumpkin> mercurial: anyway, if you want your function to work, you'll need to rank-2 CPS it or make an existential wrapper type
22:10:48 <shachaf> Peaker: http://www.haskell.org/pipermail/haskell-cafe/2007-September/031866.html
22:11:23 <shachaf> Anyway, there probably aren't that many who are actually involved/close enough to go to a meeting.
22:11:24 <mercurial> copumpkin: many thanks, will investigate
22:11:41 <shachaf> So there isn't all that much point. :-)
22:12:39 <Peaker> Aha, maybe I should read Haskell-cafe
22:13:49 <shachaf> Or subscribe and read almost nothing, like I do.
22:16:47 <Peaker> Shachaf, where in the US are you? Any chance of returning to Israel? 
22:17:09 <shachaf> Peaker: CA currently.
22:17:30 <Peaker> Silicon Valley? 
22:17:35 <shachaf> Yes.
22:17:42 <shachaf> Do you mean visiting or to live there?
22:17:56 <Peaker> Live there..
22:19:01 <shachaf> Ah. Seems unlikely in the near future, at least.
22:19:46 <Peaker> Haskell startup over there? 
22:20:28 <shachaf> No Haskell used, alas. Though I work with several Haskell people.
22:22:46 <Peaker> Trying to use some casual Haskell at my workplace is a bit tough, cabal install doesn't work very well in practice due to over conservative version constraints, due to the PVP
22:23:58 <Peaker> I wish upper constraints were only added when they were shown to break the package, otherwise it's an even worse mess
23:17:36 <bloop> what do you call a Haskell user? a Haskeller?
23:20:20 <Jonno_FTW> @google haskellers.com
23:20:21 <lambdabot> http://www.haskellers.com/
23:20:21 <lambdabot> Title: Haskellers
