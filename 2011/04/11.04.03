00:00:03 <lispy> ben12: that's it
00:00:24 <kmc> what in particular about the syntax bsod2?
00:00:28 <bsod2> c/c++  and python/javascript/html with their related tech and api's
00:00:43 <kmc> those are two odd groupings
00:01:16 <kmc> one important thing to realize about Haskell syntax is that whitespace matters, but only optionally
00:01:17 <bsod2> c/c++ is the language group that produces binaries, while the other languages are scripting to me
00:01:17 <copumpkin> bsod2: I like the syntax because it keeps bullshit symbol noise to a minimum
00:01:26 <kmc> that is, everything has an equivalent whitespace-insensitive form
00:01:45 <kmc> bsod2, that's an implementation detail.  there exist C interpreters and Python compilers
00:02:03 <kmc> you can put one line at the top of a C program and run it like a script
00:02:04 <copumpkin> in other words, there are very few "keywords" or symbols
00:02:38 <lispy> copumpkin: Actually, whenever I want to muck about with bytes C's syntax is *really* nice.  Better than Haskell's (until you build some higher level stuff, but I haven't had much luck with that)
00:03:00 <kmc> bsod2, anyway, did you have a question about Haskell?
00:03:06 <copumpkin> how so? I muck around with bytes all the time in haskell :)
00:03:10 <lispy> Haskell synatx is very nice for being declarative though
00:03:13 <copumpkin> and in C for that matter
00:03:31 <copumpkin> you mean being able to index into buffers with very little syntax?
00:03:36 <copumpkin> and cast them to the things you need?
00:03:40 <lispy> copumpkin: well, foo `plusPtr` blah, is kind of cumbersome compared to foo[blah]
00:03:50 <bsod2> is haskell a language that allows me to understand math better.. i heard somethign about category theory being used
00:03:57 <copumpkin> yeah
00:04:06 <copumpkin> bsod2: if you choose to pursue that direction of it, sure
00:04:27 <lispy> copumpkin: I guess to really match C you also need a peek, so it becomes peek $ foo `plusPtr` blah
00:04:35 <copumpkin> but it's not a prerequisite or necessarily an end-result, if you aren't interested
00:04:35 <copumpkin> yeah
00:05:12 <kmc> you can talk about haskell using terms from category theory.  you can also talk about category theory using terms from haskell
00:05:14 <bsod2> copumpkin: i'd be in elegance, math, and such things. i really dont need yet another language to glue gtk+ calls together :)
00:05:26 <kmc> neither of these is directly related to writing practical programs
00:05:31 <ddarius> lispy: That's peek (foo `plusPtr` blah)
00:05:34 <copumpkin> bsod2: well then haskell is a decent gateway drug to all sorts of great stuff
00:05:34 <kmc> but it's cool and has some indirect connections
00:06:07 <lispy> ddarius: are you saying that ($) doesn't work there?
00:06:18 <ddarius> lispy: No, I just missed your comment.
00:06:22 <lispy> aaah
00:06:25 <bsod2> copumpkin: thanks, i'll give it a try... i guess with a google on 'haskell category theory' should help me on my way?
00:06:28 <wharzl> what does dependant typing in a language buy us?
00:06:42 <copumpkin> bsod2: sure, but I wouldn't get started on the CT until you already have a decent grasp of haskell types
00:06:54 <djahandarie> _[_] : ...; f [ b ] = peek (f `plusPtr` b)
00:06:57 <lispy> wharzl: propositions based on values instead of sets
00:06:57 <copumpkin> wharzl: arbitrarily strong static (compile-time) guarantees
00:07:02 <djahandarie> Problem solved?
00:07:06 <bsod2> copumpkin: thanks :)
00:07:38 <dobblego> wharzl: dependant typing is when your dependant (such as a child) types, do you mean dependent typing?
00:07:45 <lispy> djahandarie: how would you actually define that in Haskell though?
00:07:48 <dobblego> :)
00:08:02 <wharzl> like in agda
00:08:09 <ddarius> djahandarie: Too type-safe.  In C I can do 3[blah] as well as blah[3].
00:08:13 <copumpkin> lispy: have the thing that can be indexed be a function that takes a list, and your list is generally a singleton
00:08:31 <copumpkin> :P
00:08:44 <copumpkin> wharzl: what about it?
00:08:48 <lispy> oh, I see what he means
00:08:53 <ddarius> You could break out IntPtr though.
00:08:57 <copumpkin> lispy: yeah, that's agda syntax
00:09:04 <lispy> I thought djahandarie was suggesting to add a mixfix operator _[_] 
00:09:26 <copumpkin> oh
00:09:27 <copumpkin> he was
00:09:33 <copumpkin> I think
00:10:22 <lispy> ddarius: what is this IntPtr you speak of?  I see it in Foreign.Ptr but I don't see how it would help
00:10:43 <lispy> oh
00:10:47 <lispy> It has Int-like instances
00:12:33 <lispy> So, one question I have about the FFI...
00:12:44 <lispy> I'm leaving several structs as "opaque bytes"
00:12:56 <lispy> But, I still need some of their fields
00:13:50 <lispy> Should I expose them like this: fooStruct_field :: FooStruct -> Ptr Field, or fooStruct_Field :: FooStruct -> IO Field ?
00:14:20 <lispy> the former is closer to what I'm really doing.  So that has an appeal.  It's more primitive.  But the latter more closely matches what you tend to get with FFI bindings, I think.
00:14:31 <lispy> With the former you can get the latter with a peek.
00:14:40 <lispy> So I'm leaning towards that one
00:14:51 <ddarius> Keep it consistent within a level.   However, the former allows mutation.  Do you need mutation?
00:14:52 <copumpkin> as long as you wrap it up eventually, I don't really care
00:15:46 <lispy> ddarius: I don't think so.  Basically, I can't easily make Storable instances for these types, but at least some of their fields should be available to the Haskell side.
00:20:59 * ddarius starts considering if we should just facet everything.
00:27:05 <ddarius> "To have a unique interpretation, a program must not execute any of the 191 kinds of undefined behavior, nor depend on any of the 52 kinds of unspecified behavior, that are described in the C99 standard."
00:27:57 <lispy> hehe
00:35:20 <Boney> Hi, I got myself cnfused with monads.
00:35:34 <Boney> If I "ghci> :t return"
00:35:40 <Boney> it says that return takes one argument.
00:35:41 <lispy> :t return
00:35:42 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
00:35:56 <Boney> When I look here http://www.haskell.org/haskellwiki/State_Monad
00:36:03 <Boney> Return has two arguments.
00:36:11 <Boney> I'm confused.
00:36:20 <dobblego> Boney: it might be better to think of all functions as taking one argument
00:36:25 <Boney> I'm trying to work out how State works.
00:36:28 <mauke> Boney: where do you see return with two args?
00:36:33 <c_wraith> why is haskell.org *so* slow for me?
00:36:38 <dobblego> a -> s -> (s, a) looks like this: a -> (s -> (s, a))
00:36:39 <Boney> -- ie: (return 5) 1 -> (5,1)
00:36:39 <Boney> return :: a -> State s a
00:36:40 <Boney> return x s = (x,s)
00:36:57 <mauke> Boney: that's pseudocode
00:36:57 <Boney> dobblego: yep, I understand currying.
00:37:07 <dobblego> Boney: then (s -> (s, a)) is the same as State s a
00:37:09 <Boney> applying an argument to a ... oh,
00:37:12 <mauke> Boney: "These are usually wrapped, but shown here unwrapped for simplicity. "
00:37:14 <Boney> I think I got it, thanks for the tip.
00:37:21 <Boney> mauke: ah.
00:37:30 <mauke> maybe they should have written that as: return x = \s -> (x, s)
00:37:33 <Boney> mauke: I didn't know what they ment by 'wrapped'.
00:38:07 <mauke> argh, why is there no 'data State' on that page?
00:38:13 <mauke> or newtype
00:38:18 <mauke> @src State
00:38:18 <lambdabot> Source not found.
00:38:35 <Boney> so the state monad is a function, I think that makese sense.
00:39:01 <aavogt> ben12: I dunno, that cabal package worked about a year ago which is around when that feature was added
00:39:05 <mauke> data State s a = State{ runState :: s -> (a, s) }
00:39:21 <mauke> return x = State (\s -> (x, s))
00:39:53 <Boney> Thanks guys, that really helped :-)
00:40:00 <c_wraith> Boney:  It's the only way to make sense of how "get :: State s m a" is a constant, yet its value (in some sense) changes.  The function it encapsulates is always the same, how it behaves depends on what is passed to it.
00:40:17 <c_wraith> err.  "get :: State s a"
00:40:24 <c_wraith> half-mixed it with StateT in my head
00:40:37 <mauke> how about State s s
00:40:51 <Boney> right,
00:40:52 <c_wraith> I suppose that *is* the type of get
00:41:12 <mauke> @djinn get :: s -> (s, s)
00:41:12 <lambdabot> Cannot parse command
00:41:15 <mauke> @djinn s -> (s, s)
00:41:15 <lambdabot> f a = (a, a)
00:41:28 <mauke> @djinn a -> (s -> (a, s))
00:41:28 <lambdabot> f a b = (a, b)
00:42:10 <mauke> @djinn s -> s -> ((), s)
00:42:11 <lambdabot> f _ a = ((), a)
00:42:13 <mauke> hah
00:42:30 <ddarius> "Several safe math libraries for C that we examined themselves execute operations with undefined behavior while performing checks."
00:42:59 <lispy> ddarius: what are you reading?
00:43:49 <ddarius> "Finding And Understanding Bugs in C Compilers"
00:43:50 <c_wraith> @djinn (s -> (a, s)) -> (a -> b -> (b, s)) -> (s -> (b, s))
00:43:50 <lambdabot> -- f cannot be realized.
00:44:14 <mauke> can't create b
00:44:17 <lispy> ddarius: ah!  Yeah, I'd like to apply their fuzzing stuff to GHC if I had infinite free time
00:44:19 <c_wraith> ...  why am I so bad at this tonight?
00:44:49 <ddarius> Perhaps the type checker in your head needs a tune-up.  Did you change the oil?
00:45:03 <c_wraith> ddarius: it's clogged by the flu, actually
00:45:10 <mauke> @djinn (s -> (a, s)) -> (a -> s -> (b, s)) -> (s -> (b, s))
00:45:11 <lambdabot> f a b c =
00:45:11 <lambdabot>     case a c of
00:45:11 <lambdabot>     (d, e) -> b d e
00:45:23 <c_wraith> ...  right, yes
00:45:26 <c_wraith> *sigh*
00:45:39 <c_wraith> I was staring right at the problem, and I couldn't see it
00:46:01 <mauke> @pl \a b c -> let (d, e) = a c in b d e
00:46:01 <lambdabot> (line 1, column 15):
00:46:01 <lambdabot> unexpected "("
00:46:01 <lambdabot> expecting "()", natural, identifier or "in"
00:46:28 <mauke> @pl \a b c -> (\(d, e) -> b d e) (a c)
00:46:28 <lambdabot> flip ((.) . (`ap` snd) . (. fst))
00:46:29 <c_wraith> the @pl doesn't like your sophisticated pattern matching
00:48:58 <c_wraith> yeah, my brain is really not back yet.  I spent a lot of time tonight re-writing the same emergency patch for work 3 times because I can't quite think straight.
00:49:12 <c_wraith> fortunately, "emergency" is a relative term.
00:49:37 <c_wraith> Needed it by midday sunday, worst case.
00:49:44 <c_wraith> So I had time for a bunch of retries.
01:01:29 <Volatile> Hi guys! A perhaps noobish question: I want to have a State inside a State(T?) inside a StateT, but I can't seem to get the type right. Any suggestions? (I think I'm kinda starting to getting some kind of flu or something, so my brain is sorta sluggish right now...)
01:03:09 <Volatile> That is, I want to access the inner state from the middle state, and the middle state from the outer state.
01:03:25 <c_wraith> nested States is ugly.  But it works ok.
01:03:28 <Volatile> Two levels of states works fine, but somehow, three crashes my brain.
01:03:50 <khush> hii
01:03:54 <c_wraith> :t Control.Monad.Trans.lift get
01:03:54 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadState a m, Control.Monad.Error.MonadTrans t) => t m a
01:04:22 <c_wraith> :t Control.Monad.Trans.lift (Control.Monad.Trans.lift get)
01:04:23 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *). (MonadState a m, Control.Monad.Error.MonadTrans t, Control.Monad.Error.MonadTrans t1, Monad (t m)) => t1 (t m) a
01:05:45 <Volatile> Hm. Why would I want a monad transformer? :)
01:06:05 <c_wraith> In this case, you probably don't.
01:06:17 <c_wraith> You probably just want the state to be a structure that contains everything you care about.
01:06:40 <c_wraith> In general, though, Monad transformers make certain kinds of code easier to understand.
01:08:05 <Volatile> Right now, my ad-hoc solution is using mapState to use both the state and the values as states. It's ugly. 
01:08:05 <c_wraith> Especially when there are large amounts of domain specific logic combined
01:08:13 <Volatile> Hm
01:11:23 <Volatile> The two innermost states: I have a list of values. To add new values to the list, I sometimes need to get a new value from a counter. I think I would like the counter to be an inner state of a state that has the list as state.
01:14:40 <c_wraith> Is it too much to just create a record that stores all these things, and a set of functions for accessing that record in domain-correct ways?
01:14:57 <c_wraith> then just use modify with your functions?
01:15:49 <c_wraith> I mean, that approach can lead to significantly more rote code early-on.
01:15:56 <c_wraith> But it usually ends up being cleaner later
01:16:24 <Volatile> My mapState use looks very much like an ugly way of doing what a state monad does, with a big let instruction handling what do usually handles for states.
01:16:27 <Volatile> Hm
01:16:39 <c_wraith> because you've gone from thinking in terms of "nested states" to thinking in terms of "my operations on the data"
01:18:17 <Zero12312312> hello
01:18:30 <lispy> hi
01:19:10 <Zero12312312> im new to programming. was told haskell is good and maybe you could help me out with a few questions about the language
01:19:23 <Axman6> sure
01:19:50 <Zero12312312> is it a multiplatform style?  you create once... can put it on any system.. pc or mac or others?
01:20:16 <Axman6> you can compile it on any modern/popular platform
01:20:44 <Axman6> the binaries that are created are platform specific because they are native programs
01:20:47 <Zero12312312> whats the best intro book around for the haskell language? (i like the for dummy series.. do they have any of those)
01:20:49 <sbahra> Well, on most.
01:20:58 <Axman6> @where lyah
01:20:58 <lambdabot> http://www.learnyouahaskell.com/
01:21:04 <Axman6> Zero12312312: ^^^^^^^^^^^^^^^^^^^
01:21:41 <Volatile> c_wraith: hm. sure. I could do it like that. It just seems kinda clumsy I guess, passing along things I don't really need. The counter needs to be updated for every value I get from it or put back to it whether it is a state or not. And if I combine that with the list of things that needs the values, I will mostly be explicitly passing along at least one data structure more than I use.
01:23:51 <Zero12312312> chat window froze for a moment loading the "great good" book... can I use codeblocks for haskell? do any of you use codeblocks for the language?
01:24:15 <Axman6> what's codeblocks?
01:24:47 <JuanDaugherty> prolly regular blocks of block structured langs
01:24:49 <Zero12312312> well i just started C++ and I type my code  with code::blocks.. 
01:25:06 <Zero12312312> http://www.codeblocks.org/
01:25:07 <Axman6> Haskell is nothing like C++
01:25:16 <JuanDaugherty> even remotely
01:25:42 <Axman6> so it's an IDE. you don't need an IDE to write haskell, a simple text editor like notepad++ will do if you're on windows
01:25:51 <shachaf> JuanDaugherty: That's taking it a bit far.
01:26:34 <JuanDaugherty> shachaf, well I was trynnna think which of smalltalk, prolog, and haskell was least C/C++ like and it still came up haskell
01:26:38 <Zero12312312>  haskell examples you could share with me?
01:27:09 <shachaf> A strange set of languages to compare to.
01:27:39 <JuanDaugherty> programming langs are programming langs though and most tend to be implemented in C/C++ at least until they can be implemented in themselves
01:27:46 <dobblego> Zero12312312: to reverse a list: foldl (flip (:)) []
01:27:53 <dobblego> Zero12312312: best get started with LYAH
01:28:00 <Zero12312312> k
01:28:41 <shachaf> Come on. You have "functions" that take arguments and return values. You have similar literals and operators, and an "=" operation that can bind values, whitespace-separated syntax, similar primitive types...
01:29:13 <JuanDaugherty> what's LYAH, is it better than RWH?
01:29:38 <shachaf> Why do people say things like that? "better"?
01:29:41 <Zero12312312> the learn you a haskell
01:29:55 <JuanDaugherty> ah, thx Zero12312312 
01:30:09 * fcr was reading "Haskell: The Craft of Functional Programming"
01:30:21 <dobblego> shachaf: because they forget the objective
01:30:23 <fcr> I believe it's a good text for learning
01:30:25 <JuanDaugherty> shachaf, people seek the good and by extension the better
01:30:54 <shachaf> Do you really think all Haskell books can be ranked, and that you can just choose the best one?
01:31:33 <ddarius> JuanDaugherty: The first implementation of Haskell was HBC which was implemented in LML which was bootstrapped via assembly.  GHC has always required a Haskell compiler to be built.
01:31:48 <ddarius> shachaf: Yes.
01:32:00 <ddarius> shachaf: Of course, that notion of "ranking" may not be particularly relevant.
01:32:18 <shachaf> ddarius: I asked a compound question. :-)
01:32:20 <Boxo> Do you really think no Haskell books can be ranked, and you can never choose the better of two books? :)
01:32:45 <ddarius> shachaf: And the answer to that question is "Yes."
01:33:36 <shachaf> That you can just choose the best one? The second part of the question I'd hold to be kind of meaningless.
01:33:50 <ddarius> shachaf: "Best" = rank 1.
01:34:05 <brbr> afternoon project: http://zzzcalculator.appspot.com/
01:34:08 <shachaf> Ah. In that case, fair enough.
01:34:26 <ddarius> The latter part of your question is meaningless if the former part is answered negatively.
01:34:46 <Volatile> c_wraith: http://hpaste.org/45242/etaoin if you want to see what bothers me with my code.
01:35:52 <JuanDaugherty> *smalltalk, prolog, lisp, or haskell
01:36:05 <ddarius> The real issue is what's "best" for the reader, rather significantly depends on the reader.
01:36:07 <Maxdamantus> I find that, unless the time is way off my circadian waking up time thing, I can usually just think about approximately when I want to wake up.
01:36:11 <mjrosenb> Volatile: i'd recommend against using runState repeatedly like that.
01:36:20 <JuanDaugherty> actually I guess prolog is least like but I don't consider it general purpose
01:36:30 <c_wraith> Volatile: that's begging for some work in data structures and operations that clarify your semantic domain
01:36:52 <Maxdamantus> unless that time is <4 hours away.
01:37:30 <dobblego> Zero12312312: when you get questions, be sure to ask here
01:37:35 <shachaf> LML was bootstrapped in assembly?
01:37:37 <shachaf> Why?
01:37:41 <Maxdamantus> (or more depending how much I've slept recently)
01:37:45 <Zero12312312> okay
01:37:53 <brbr> Maxdamantus: and it works? you just wake?
01:37:54 <Zero12312312> im looking at getting the real world haskel book
01:38:03 <Maxdamantus> brbr: yeah.
01:38:08 <ddarius> "I don’t know what predominates in Cantor’s theory - philosophy or theology, but I am sure that there is no mathematics there."
01:38:33 <ddarius> shachaf: What should it have been bootstrapped in?
01:38:43 <Maxdamantus> But I think the range is only about 4 hours.
01:38:45 <dobblego> Zero12312312: different people haave success with various ways of learning, if RWH doesn't work out, you can try others
01:38:48 <JuanDaugherty> Russell, Frege?
01:38:54 <mjrosenb> ddarius: C is usually a popular choice.
01:39:00 <Maxdamantus> So usually 7-11
01:39:03 <dobblego> Zero12312312: the authors of both RWH and LYAH regularly hang out here
01:39:23 <shachaf> Zero12312312: _Programming in Haskell_ is good.
01:39:32 * mjrosenb is still not used to the abbreviation RWH
01:39:39 <ddarius> mjrosenb: Not as popular in the early 80's.
01:39:47 <espringe> dobblego: (just for reference, what the guys IRCs nicks :D)
01:40:03 <Maxdamantus> Maybe because I got used to sleeping relatively little.
01:40:13 <Volatile> mjrosenb: isn't (>>=) for State using runState like that, more or less?
01:40:16 <shachaf> ddarius: Surely augustss had *some* higher-level language available?
01:40:26 <shachaf> preflex: seen grahamhutton
01:40:27 <preflex>  grahamhutton was last seen on #haskell 155 days, 10 hours, 50 minutes and 16 seconds ago, saying: thanks!
01:40:27 <JuanDaugherty> Maxdamantus, be specific
01:40:34 <mjrosenb> Volatile: yes, but it is far more compact, and imo, much clearer.
01:40:39 <Maxdamantus> Most uni days last year I'd sleep about 5 hours, often less.
01:41:00 <Volatile> mjrosenb: which is why I try to get another state in there to help me out.
01:41:07 <JuanDaugherty> that's only an hour less than the standard in the US for work days
01:41:18 <JuanDaugherty> *defacto standard
01:41:43 <JuanDaugherty> s/defacto/whatever the right word is/
01:41:57 <Maxdamantus> de facto
01:42:02 <gehmehgeh> Two words
01:42:05 <Maxdamantus> ^
01:42:10 <Maxdamantus> of fact, presumably
01:42:11 <mjrosenb> Volatile: you should be able to replace that let ... with do a <- getVal v1; b <- getVal v2; ...
01:42:46 <JuanDaugherty> no I meant something like "informally established"
01:43:02 <gehmehgeh> http://en.wikipedia.org/wiki/De_facto
01:43:39 <gehmehgeh> "in practice but not necessarily ordained by law"
01:43:42 <Maxdamantus> fact as in .. factual
01:43:46 * Maxdamantus shrugns.
01:43:47 <gehmehgeh> as ooposed to "de jure"
01:43:50 <gehmehgeh> *opposed
01:43:54 <JuanDaugherty> Martha Stewart and other power types have famously claimed that they only get 4 as being a sucessful capitalist is so invigorating 
01:44:20 <Maxdamantus> The juried/juristiction/standard?
01:44:44 <JuanDaugherty> and people doing polyphasic only get about 2 added up
01:45:08 <gehmehgeh> the USA is a de facto English speaking country
01:45:12 <gehmehgeh> but not de jure
01:45:32 <JuanDaugherty> though some of the states are
01:45:40 <JuanDaugherty> like Florida
01:45:41 <Volatile> mjrosenb: hm. as in runState ( do ... ) state0 ? 
01:46:24 <zenzike> ls
01:46:37 <Volatile> mjrosenb: I guess so... Still seems "wrong" to use the value part of the state monad as a second state, I guess...
01:47:12 <mjrosenb> Volatile: sorry, didn't see that one of those was already a 'State foo'
01:47:55 <mjrosenb> why are you taking a state as an argument?
01:48:48 <Volatile> mjrosenb: because I use the argument of the state as a state as well. Is it superfluous?
01:49:43 <Volatile> mjrosenb: this is also part of what I want to get rid of by adding a state inside the state. :)
01:52:23 <argiopeweb> 'Evening folks. I've got an abstract datatype with 200+ constructors, many of which share the same fields but which must be distinct for compatibility with a legacy system.  That being said, I don't want to have the insane quantity of cruft incurred by code repetition if I don't need it.  I can't create "type"s with multiple arguments (obviously), and I can't see any other way to go about it other than throwing in some template hask
01:52:23 <argiopeweb> ell.  Anyone run into this issue before?
01:53:42 <mjrosenb> Volatile: ok, now i grok what your code is doing.
01:55:46 <Volatile> mjrosenb: As you can see, my two lower types are a little bit off. I would like to have the third as an inner type of the second, I think, to be able to write separate code on all separate levels.
01:57:41 <Volatile> mjrosenb: and the second I don't really grok yet. I would like to have a stateT with [threeinstr] as the state, and with an inner state of Counter, but the solution eludes me.
01:57:54 <mjrosenb> Volatile: does your first function even typecheck presently?
01:58:50 <Volatile> Nope. Typechecking is done in the StateErr "domain", so it's already done when I enter that function.
01:59:03 <Athas> Hmm.  Lazy evaluation is turning my compiler into a JITing interpreter.
01:59:16 <Athas> A shame it also defers symbol resolution. :-)
01:59:33 <Volatile> mjrosenb: I am rewriting a typechecker to do more that jut
01:59:38 <Volatile> ehm, that was not backspace
01:59:55 <mjrosenb> Volatile: err, i meant does ghc complain about *its* type
01:59:58 <Volatile> mjrosenb: I am rewriting a typechecker to do more that just typecheck, without changing any of the code.
02:00:06 <Volatile> mjrosenb: ah. :D
02:00:06 <akamaus> Hi, I need to embed several multiline string constants parameterized by a few numbers (I'm speaking about web counters actually). Can someone propose a lightweight readable solution?
02:00:20 <Volatile> mjrosenb: nope, it gladly accepts it.
02:01:02 <Volatile> mjrosenb: eventhough it's ugly. :)
02:02:50 <Jafet> Athas: force it!
02:03:46 <Athas> Well, I use a lazy symbol table (so I can write it as a single pass), so I'm not sure when or how.
02:04:28 <Athas> I love that Haskell lets me write expressions of the form 'let (x, y) = foo x in y'.  Crazy stuff.
02:05:40 <Jafet> Write a skeleton "interpreter" that doesn't actually do any computation, just runs through the program
02:05:59 <Jafet> That's your compiler pass
02:06:21 <Zero12312312> i just installed the haskell platform and i get errors when I fire it up in xp.
02:06:22 <Athas> Yes, I probably need to do that.
02:06:25 <Jafet> Or symbol-validity-checking pass, whatever you call it
02:06:31 <nlogax> akamaus: this is the only way i know to have multiline string literals: http://codepad.org/zob2jld1
02:07:17 <Zero12312312> createghciprocess failed with failed with error 0: the operation completed successfully
02:07:35 <nlogax> akamaus: other than `unlines [ "line one", "line two" ]` or something similar
02:07:41 <Jafet> I like pretty printing for html
02:07:43 <akamaus> nlogax, unfortunately there is no such thing like #{var} in Ruby..
02:07:51 <Jafet> Just to reward anyone who bothers to look at the html
02:07:57 <nlogax> akamaus: not quite, but you can use printf
02:08:41 <dobblego> Zero12312312: how are you firing it up?
02:08:42 <akamaus> I thought about a solution using quasi quoting or something
02:08:52 <Kaidelong> Athas: I can't figure out how that would work
02:09:02 <Kaidelong> looks like it would be an occurs check
02:09:11 <Kaidelong> (a,b) where b = (a,b)
02:09:13 <Zero12312312> running WinGHCi  in windows xp
02:09:19 <nlogax> akamaus: http://codepad.org/I7ENj9Kh
02:09:24 <dobblego> Zero12312312: try ghci
02:09:30 <Jafet> > let foo x = (42,x); (x,y) = foo x in y
02:09:31 <lambdabot>   42
02:09:42 <Axman6> :t let f = (a,b) where b = (a,b) in f
02:09:42 <lambdabot>     Occurs check: cannot construct the infinite type: t = (Expr, t)
02:09:43 <lambdabot>       Expected type: t
02:09:43 <lambdabot>       Inferred type: (Expr, t)
02:09:44 <Zero12312312> i get to a preclude line...
02:09:45 <Kaidelong> oh oops
02:09:47 <Jafet> The evaluation threads through the let-binding twice
02:09:49 <Kaidelong> I did not notice the foo
02:09:53 <akamaus> Ideally I just want to paste a piece of text into my source and add minimal decorations
02:09:59 <dobblego> Zero12312312: you're at the Haskell REPL and you can evaluate expressions there
02:10:43 <Jafet> akamaus: that doesn't sound like a useful ideal
02:10:49 <Zero12312312> do you use the ghci?  im used to using fancy IDE programs to type in code heheh
02:10:50 <dobblego> > 4 + 4 -- for a simple example
02:10:51 <lambdabot>   8
02:11:10 <dobblego> Zero12312312: I use ghci and a text editor, IDEs aren't really needed in haskell (though I do use one occasionally, called leksah)
02:11:14 <argiopeweb> Zero12312312: So, get your fancy IDE program to load you up a REPL. :P
02:11:29 <Jafet> akamaus: if you want to automagically do this to arbitrary text, you'll need to put it in another file and use a preprocessor or load it when the program runs
02:11:34 <Athas> Zero12312312: I've used ghci quite a bit for my recent project, and while not as nice as the REPLs of some other languages, it serves.
02:11:45 <Athas> It was really useful when debugging my parser.
02:11:57 <Zero12312312> i'll check out the leksah
02:11:58 <Kaidelong> IDE's are never needed but they are quie helpful (puts all your tools in one place, organized well)
02:11:59 <mjrosenb> Athas: what implementation has a nicer repl than ghci?
02:12:33 <Jafet> What implementation than ghci?
02:12:38 <Kaidelong> Helium supposedly has a very nice REPL but Helium is quite limited compared to Haskell's standard
02:13:11 <mjrosenb> what implementation of some other language presumably.
02:13:15 <dobblego> Zero12312312: I think you should just use a text editor, you really don't need an IDE in a decent programming environment, it's different now
02:13:44 <Kaidelong> mjorensb: Standard ML?
02:14:06 <argiopeweb> Kaidelong: Isn't this why the saints gave us Emacs?
02:14:44 <Kaidelong> argiopeweb: emacs does not tend to come in a neat pre-packaged configuration that looks and works nice, though
02:14:45 <akamaus> Jafet, I don't need automation. I'll do it manually from time to time. I just want to avoid deep rewriting of text like one which is needed then using standard strings. Also I need to embed several data pieces inside a string. And using ++ would be too cumbersome.
02:15:27 <mjrosenb> Kaidelong: well Athas said that ghci was not as nice as ther repls of other languages; and imo, ghci has the nicest repl around.
02:15:29 <Athas> mjrosenb: SBCL with SLIME.
02:15:43 <akamaus> Ideally I need some light templating library
02:15:48 <Kaidelong> mjorsenb: I'd disagree.
02:16:02 <mjrosenb> Kaidelong: sml/nj?
02:16:07 <Jafet> akamaus: you're doing something which inherently involves manually rewriting the input, but you want to "avoid deep rewriting". I can't answer such a vague question
02:16:07 <Kaidelong> I think F# has a nicer REPL, I use haskell because of other merits (mostly typeclasses)
02:16:12 <Athas> Ghci is really useful, but Lisp REPLs really are better.
02:16:12 <Kaidelong> sml/nj too yes
02:16:14 <argiopeweb> Kaidelong: Hmm, can't deny that... Probably wouldn't be too hard to distribute a version of Emacs with haskell-mode + ghc-mod + hare though.
02:16:31 <argiopeweb> Kaidelong: It's already done for SLIME on several platforms.
02:16:40 <Jafet> akamaus: and you can make that preprocessor or runtime loader a template system, sure
02:16:48 <Kaidelong> if some emacs guru could do that and provide docs I'd take a serious look at it argiopeweb
02:16:55 <ddarius> The MLs have historically had good REPLs.
02:16:59 <mjrosenb> Kaidelong: i can't argue about F#; never used it
02:17:20 <Kaidelong> mjrosenb: if you like haskell you'll like it
02:17:26 <Kaidelong> although I like haskell bettr
02:17:36 <mjrosenb> Kaidelong: however, sml/nj i have found to be rather lacking.  a decent part of that is the fault of sml, part of that is the fault of sml/nj
02:18:11 <Kaidelong> I am not sure whether I'd prefer Caml or SML if I had to use one
02:18:18 <Kaidelong> probably Caml actually
02:18:39 <Athas> I'd use SML because that's what I was taught at school.  Nostalgia!
02:18:41 <Kaidelong> objects are pretty powerful tools to have around
02:18:43 * mjrosenb uses sml just because it is the first FP language that i learned
02:18:52 <akamaus> Jafet, well, I'm speaking about replacing "peice1 XXX piece2" with something like "piece1 #{var1} piece2" and getting something like f :: String -> String
02:18:58 <Kaidelong> Athas: SML/NJ was the first programing language I learned in a formal setting
02:19:12 <Kaidelong> not Java
02:19:18 <Kaidelong> I think that was good immunization for me
02:19:31 <mjrosenb> Kaidelong: did you happen  to go to CMU?
02:19:40 <Kaidelong> oh I wish
02:20:08 <Athas> Well, we use Moscow ML as our first language, because SML/NJ needs a bit more bureaucracy in order to run code.
02:20:26 <Kaidelong> it was an accident
02:20:29 <mjrosenb> Kaidelong: ahh, i do not of any other colleges that recommend sml/nj.
02:20:30 <Kaidelong> it was supposed to be Java
02:20:38 <Kaidelong> but I got into a math class that used SML/NJ
02:20:44 <Athas> It would be interesting to use Haskell instead, but I wonder if it's too complex.
02:20:48 <Kaidelong> before I got into a computer science class that used Java
02:21:07 <Kaidelong> Actually I think Haskell might be even easier to learn than scheme
02:21:09 <argiopeweb> Kaidelong: They didn't do anything to lead into Java? C or the like?
02:21:16 <Jafet> akamaus: I'm afraid I don't know how much fuss template haskell needs to do that
02:21:34 <Kaidelong> argiopeweb: Who teaches C before Java? New Mexico?
02:21:45 <Kaidelong> I have heard about it but I think it is the exception and not the rule
02:21:57 <argiopeweb> Kaidelong: It used to be more of a rule, now it's definitely the exception.
02:21:59 <Jafet> But it surely can, once you give the template string a defined representation.
02:22:13 <argiopeweb> But still, some manner of imperative language usually precedes Java.
02:22:19 <argiopeweb> MIT does Python.
02:22:28 <Kaidelong> MIT might be setting a trend there
02:22:31 <Athas> Kaidelong: you need to explain typeclasses and lazy evaluation, though.
02:22:38 <argiopeweb> BCU just dropped OO entirely until sophomore year, and I believe it's optional at that point.
02:22:40 <Kaidelong> Athas: Do you really?
02:22:41 <akamaus> Jafet, look for example at http://www.yesodweb.com/book/templates#bs1
02:22:56 <Athas> Kaidelong: well, the Prelude uses both.
02:23:08 <argiopeweb> ERAU does Matlab prior to Java for the benefit of the Aeronautical Engineers, but they're a special case.
02:23:34 <Kaidelong> Athas: Well you can write basic programs without understanding either
02:23:41 <Kaidelong> Lazy evaluation will get in the way first
02:23:42 <argiopeweb> And I believe their CS/SE dept. is fighting to be removed from the 1st year engineering regimen because Matlab is so useless.
02:24:03 <Kaidelong> you need not explain lazy evaluation until you start running into needing strict functions, though
02:24:10 <ckid> why does min [1],[2] work when t: min is a -> a -> a and not  [a] -> [a] -> [a]? is [a] considered as a type too?
02:24:29 <Kaidelong> typeclasses are needed for understanding how to overload methods
02:24:37 <lispy> ckid: yes
02:24:38 <Kaidelong> when do you usually learn about overloading in Java or C++?
02:24:41 <lispy> :t min
02:24:41 <Jafet> akamaus: interesting, I thought you'd need to quote them
02:24:41 <lambdabot> forall a. (Ord a) => a -> a -> a
02:24:44 <Kaidelong> you could just model it after that
02:24:45 <Athas> The primary curriculum of any class using Matlab is that Matlab is terrible.
02:24:50 <argiopeweb> Kaidelong: 3 weeks in.
02:24:51 <lispy> ckid: basically, [a] has an Ord instance
02:24:59 <lispy> ?instances []
02:25:00 <lambdabot> Plugin `instances' failed with: regex failed: (ReturnCode 7,"Unmatched [ or [^")
02:25:03 <Axman6> ckid: why wouldn't [a] be a type?
02:25:09 <lispy> ?instances [a]
02:25:09 <lambdabot> Couldn't find class `[a]'. Try @instances-importing
02:25:13 <Kaidelong> also C++ operator overloading has all sorts of weird rules
02:25:14 <Jafet> @instances Ord
02:25:14 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:25:28 <Kaidelong> so it might be easier to explain haskell typeclasses
02:25:37 <Kaidelong> than all of how to overload things in C++
02:25:42 <lispy> Jafet: thanks.  That command always seems to be the inverse of how I remember it :)
02:25:48 <ckid> ok, thanks
02:26:30 <akamaus> Jafet, I don't mind :) Maybe Hamlet would do the work for me. I'm not sure thought, because my snippets would be a mix of html with embedded javascript
02:27:16 <Jafet> C++ lets you overload overloading
02:27:17 <argiopeweb> Kaidelong: Generally operator overloading doesn't get taught until you hit the advanced aspects of objects.
02:27:35 <Jafet> In the end it just becomes overload of a different sort.
02:27:53 <Kaidelong> I think Haskell should not be so hard to teach
02:27:54 <Entroacceptor> can't you overload function application in C++?
02:27:58 <Zero12312312> dobblego you there?
02:28:01 <Kaidelong> I wonder if people have tried
02:28:13 <Kaidelong> all things considered it's one of the more simple and sane languages
02:28:17 <espringe> Entroacceptor: operator() (so yes, it's very common)
02:28:24 <Entroacceptor> ...
02:28:43 <espringe> It's used extensively to create functors
02:28:53 <espringe> and lambda expressions etc.
02:29:10 <mjrosenb> espringe: at least at the last place i worked, overloading () was very strongly discouraged.
02:29:21 <Jafet> Sure, there are some introductory programming classes in haskell
02:29:24 <c_wraith> just remember that what C++ calls "a functor" is not what *anything* else in the universe calls "a functor"
02:29:34 <Jafet> I forget which people here have taught in them
02:29:48 <c_wraith> What C++ calls "a functor" is what everything else calls "a closure"
02:30:37 <espringe> mjrosenb: Not sure why? It's used everywhere, even the standard library extensively
02:30:38 <lispy> c_wraith: yeah, I recall being kind of suprised that C++ functors didn't have a map.
02:31:51 <mjrosenb> @hoogle (Monad m) => m a -> MaybeT m a
02:31:51 <lambdabot> Warning: Unknown type MaybeT
02:31:51 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
02:31:51 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
02:31:58 <monadic_kid> I had an argument with someone on stackoverflow about the abused termonology of functors in C++
02:32:01 <mjrosenb> derp.
02:32:48 <monadic_kid> Just wouldn't accept that Functor actually means something else and not the abused meaning in C++
02:32:59 <c_wraith> monadic_kid: best to avoid those arguments.  People arguing from the position of being wrong tend to prefer to stay there.
02:42:49 <Amagineer> How does one go about uninstalling a cabal package?
02:43:38 <monadic_kid> Amagineer: unregister the package with ghc-pkg and then you can delete the package from where it's installed yourself
02:43:48 <mjrosenb>     No instance for (MonadTrans MaybeT)
02:43:49 <mjrosenb> odd.
02:45:20 <Amagineer> So then, is a package installed in only one place? Or is there some way to get a listing of the files it owns?
02:46:49 <Jafet> You can list them with ghc-pkg
02:47:04 <monadic_kid> Amagineer: there is a directory for user packages like inside ~/.cabal or C:\Users\<user-name>\AppData\Roaming\cabal ghc-pkg can giving listings
02:47:56 <monadic_kid> Amagineer: if you just need to reinstall a can use can use --reinstall  with cabal install
02:51:46 <monadic_kid> the C++ committee messed up not adding Concepts to C++0x, that would have made defining some categories concepts in c++ more directly
02:55:04 <monadic_kid> they had some kind of mechanism for defining axioms which isn't possible with plain type-classes http://en.wikipedia.org/wiki/Concepts_%28C%2B%2B%29#Axioms
02:55:22 <mjrosenb> gah, i keep wanting to use >> as if it were flip liftM
03:04:14 <ckid>  I have a question regarding the amortized analysis: http://codepad.org/NxJg385U
03:06:07 <akamaus> Jafet, nlogax, looks like I've found the solution: http://www.haskell.org/haskellwiki/Bravo
03:25:53 <opqdonut> ckid: what counts as a "step" is usually pretty ill-defined when analysing implementations (instead of algorithms)
03:30:18 <ckid> um... :(
03:31:18 <ckid> do you have any idea what the author of this book in this case considers as a step?
03:32:10 <opqdonut> maybe a "step" is a call to minimum1
03:32:35 <mjrosenb> if I have a do block that is in the IO monad, is there anything that I can do that will act like fail, but won't cause the program to abort?
03:32:35 <opqdonut> that would at least match the equation
03:32:42 <opqdonut> btw, there's nothing amortized about this analysis
03:33:01 <opqdonut> mjrosenb: you'll probably want something like MaybeT IO...
03:33:54 <mjrosenb> opqdonut: ok, i tried that before, and it looks like when is not defined for it.
03:34:10 <opqdonut> mjrosenb: hmm
03:34:11 <c_wraith> when is defined for all monads
03:34:15 <c_wraith> guard is not
03:34:36 <c_wraith> but MaybeT should allow MonadPlus to work, anyway
03:34:48 <opqdonut> oh, the doc for MaybeT says: The instance MonadPlus is not provided, because it has ambiguous semantics.
03:34:57 <c_wraith> oh.  that's true
03:35:04 <c_wraith> pass through, or work on its own level
03:35:11 <opqdonut> yeah
03:35:20 <mjrosenb> huh?
03:35:30 <mjrosenb> well first, i need to get this code out of a let binding
03:37:27 <michaelh> hi, can anyone please answer my new question? http://hpaste.org/45243/why_does_f_xacc_work_but_acc
03:37:37 <michaelh> newb* question. :)
03:37:58 <mjrosenb> :t (:)
03:37:59 <lambdabot> forall a. a -> [a] -> [a]
03:38:29 <ckid> opqdonut: ok, im not into this yet.. just googled the translation for 'laufzeitanalyse' :). did i get you right when you said that analysing algorithms is defined conderning what counts as a "step", but analysing implementation isnt? i mean, this implementation is an algorithim too, isnt it? 
03:38:31 <mjrosenb> michaelh: the first argument to : is a single element that you are adding onto the head of the list, the second argument is the whole list.
03:39:24 <michaelh> mjrosenb: ah, i see. thanks for the reminder to check :t
03:39:27 <michaelh> :t (++)
03:39:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
03:39:37 <michaelh> That is what i would use for what i wanted to do.
03:40:03 <mjrosenb> michaelh: it looks like you are writing something similar to scan
03:40:06 <mjrosenb> :t scan
03:40:06 <lambdabot> Not in scope: `scan'
03:40:10 <mjrosenb> :t scanl
03:40:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
03:40:23 <mjrosenb> :t scanr
03:40:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
03:40:39 <c_wraith> > scanl (+) 0 [1..]
03:40:39 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
03:41:01 * hackagebot IrrHaskell 0.2 - Haskell FRP binding to the Irrlicht game engine.  http://hackage.haskell.org/package/IrrHaskell-0.2 (EwenCochran)
03:41:43 <michaelh> mjrosenb: c_wraith: yes, it's a LYAH exercise to implement map.
03:41:46 <c_wraith> > scanl (\x y -> x + 2 * y + 1) 0 [1..]
03:41:47 <lambdabot>   [0,3,8,15,24,35,48,63,80,99,120,143,168,195,224,255,288,323,360,399,440,483...
03:41:55 <c_wraith> whoops.  missed
03:42:00 <c_wraith> > scanl (\x y -> x + 2 * y + 1) 1 [1..]
03:42:01 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
03:42:09 <c_wraith> silly off-by-one errors :)
03:42:39 <c_wraith> > scanl (\x y -> x + 2 * y + 1) 0 [0..] -- alternatively
03:42:40 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
03:43:28 <mjrosenb> > scanl (\x y -> x + (y^3))) 0 [0..]
03:43:29 <lambdabot>   <no location info>: parse error on input `)'
03:43:34 <mjrosenb> > scanl (\x y -> x + (y^3)) 0 [0..]
03:43:34 <lambdabot>   [0,0,1,9,36,100,225,441,784,1296,2025,3025,4356,6084,8281,11025,14400,18496...
03:43:42 <mjrosenb> lambdabot: you know what i mean
03:45:30 <argiopeweb> Okay, TH question: Why does "data Dat = Dat $( [t| Int |] )" work, but "x = [t| Int |] <newline> data Dat = Dat $( x )" result in a loop exception?
03:46:38 <c_wraith> I would have expected that to get rejected as a stage error, not generate a loop exception
03:47:10 <c_wraith> top-level splices are not supposed to refer to values defined in the same module
03:48:06 <c_wraith> and I suspect it's really just failing to catch that restriction properly, before ending up in an infinite loop
03:48:15 <c_wraith> define x in a different module, and see if it works
03:49:17 <mjrosenb> c_wraith: i remember being rather confused when i saw that; why does that restriction exist?
03:49:36 <argiopeweb> c_wraith: Hmm, okay.
03:50:07 <c_wraith> mjrosenb: because it's really hard to figure out how to allow them to be in the same file without making the compiler explode.
03:50:29 <c_wraith> It was much more expedient to just add a restriction saying "different module!"
03:51:28 <c_wraith> I seem to recall type splices being newer than declaration or expression splices.  It's possible that check was never implemented for type splices
03:51:55 <argiopeweb> c_wraith: That works... No clue why.
03:52:24 <c_wraith> argiopeweb: I think it failed for the same reason the stage restriction was added, but they forgot to add a stage restriction check on type splices.
03:52:31 <c_wraith> what version of GHC is that?
03:52:43 <argiopeweb> 6.12.3
03:53:05 <c_wraith> Maybe it gives the right error message in ghc 7, there were significant TH changes
03:53:07 <argiopeweb> Haven't felt like doing a non-repo install on this machiine yet.
03:53:46 <c_wraith> If not, it deserves a bug report.  TH shouldn't crash the compiler *that* easily.  Should require unsafe*ing something, at least :)
03:54:07 <argiopeweb> c_wraith: hehe, I'll throw 7 on a different machine and give a whirl to see if I need to file a bug report.
03:54:42 <argiopeweb> c_wraith: I'm still not 100% on why it is that there has to be a stage restriction for top-level splices.
03:55:24 <c_wraith> well, obviously GHC can't handle them.  :)   I'm pretty sure it's not a theoretical requirement.  It would just complicate implementation greatly.
03:55:54 <argiopeweb> So it's more a matter of the fact that TH was added later as an extension than that the theory is broken.
03:56:09 <c_wraith> yeah
03:57:36 <argiopeweb> Got it. It seems like a bit of an arbitrary restriction that'll tend to aggravate users, but at long as they catch it in 7.0.0+ I suppose it'll do.
04:09:54 <argiopeweb> Hmm, now more problems... Is there a way to write "data Dat = Dat $( x )" and get "data Dat = Dat String Int Int" (or any set of multiple parameters)?
04:10:19 * hackagebot yesod-auth 0.3.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.3.2 (MichaelSnoyman)
04:10:59 <opqdonut> ckid: the only situation where a "step" is properly defined is when you have a concrete program for a turing machine :)
04:11:17 <opqdonut> ckid: but since mostly we are only interested in asymptotics (O(n) etc) this isn't a problem
04:11:39 <opqdonut> ckid: often you can see texts for example analysing the number of comparisons (in sorting algorithms) or assignments or something
04:14:56 <kosmikus> argiopeweb: no, but "data Dat = $( x )" should be possible
04:17:52 <ckid> opqdonut: i havent deald with turing machines yet, but i keep it in mind, thanks. analysing the number of comparisons / assignments was what weve done so far, thats why i was was a confused with what the auther did here
04:17:56 <argiopeweb> kosmikus: It's possible if x is [t| Int |], but not for sets of more than one Int that I've yet seen.  I'm playing with AppT at the moment, maybe it will work.
04:18:06 <ckid> i guess :)
04:27:35 <mjrosenb> opqdonut: frequently, good languages will have a formal stepping semantics
04:27:43 <kosmikus> argiopeweb: I think my comment was wrong. Section 7.9.1 of the GHC Users Guide says that splices can be expressions, types, or list of top-level declarations
04:29:01 <kosmikus> argiopeweb: so assuming the documentation is correct, you can only splice in the whole data declaration, but not an individual constructor, or multiple types that are arguments to the constructor
04:29:36 <opqdonut> mjrosenb: sure, but one won't see people applying those in introductory texts, unfortunately
04:30:34 <argiopeweb> kosmikus: That's pretty much what I'm seeing here as well.  The type of a data constructor includes NormalC [TypeQ], which means I can put one in there but not more than one.
04:31:11 <argiopeweb> Unless I send the whole thing as an argument to template haskell and generate it from there, which is a bit beyond my skill level.
04:33:35 <argiopeweb> Even then, I'm not sure that you can manipulate an ADT once you've got ahold of it, so what I'm trying to do is probably not going to work out.
04:38:13 <kosmikus> argiopeweb: what are you trying to do?
04:41:07 <argiopeweb> kosmikus: I have 200+ data constructors which share a one of 7 common attribute sets. I can't change it because I have to work with a legacy system. And I'd really like to reduce my code repetition as much as possible.
04:41:32 <argiopeweb> Can't do it with "type" because it only takes one type. I essentially need "type MessageType1 = Int Int String"
04:43:14 <kosmikus> argiopeweb: ok, so you want a quick way to generate lots of "data X = X Int Int String" for different Xs?
04:43:44 <kosmikus> argiopeweb: and (Int, Int, String) isn't an option for you?
04:45:28 <argiopeweb> kosmikus: I'm loathe to do it with tuples, both because it kills my ability to use record notation and because the data isn't necessarily related.
04:45:47 <Cin> http://hpaste.org/raw/45245/ghc_git â€” Shouldn't GHC now be buildable from the Github Git repo. now? What did I do wrong?
04:46:09 <argiopeweb> I could theoretically do it with an additional layer of data as well, though that's going to be beyond mildly evil to work with.
04:46:42 <argiopeweb> data X = X Y; data Y = Y Int Int String;, & etc.
04:50:43 <Eduard_Munteanu> What about... data Message a = Message Type CommonFields a   ?
04:51:11 <Eduard_Munteanu> type RandomMessage = Message (Int, String)
04:52:06 <Eduard_Munteanu> or even better... data RandomMessageData = RandomMessageData { foo :: Int, bar :: String }; type RandomMessage = Message RandomMessageData
04:52:19 <argiopeweb> That's actually a clever idea. Approach it backwards from the way I've been doing it.
04:52:19 <ClaudiusMaximus> argiopeweb: perhaps it might be possible to do something like "data Dat = $( x (foo Dat) )" instead of "data Dat = Dat $( x )"
04:52:52 <argiopeweb> Reference the base types via type... Takes care of the type safety and everything.
04:53:44 <argiopeweb> ClaudiusMaximus: Hmm, then I could generate the constructor in TH.
04:54:11 <argiopeweb> ClaudiusMaximus: That would probably work, at the cost of sacrificing some readability.
04:56:52 <kosmikus> argiopeweb: http://hpaste.org/45246/th_example  <- is that more or less what you want?
05:02:08 <Kaidelong> @ty getArgs >>= openFile ReadMode . head
05:02:08 <lambdabot> Not in scope: `getArgs'
05:02:08 <lambdabot> Not in scope: `openFile'
05:02:08 <lambdabot> Not in scope: data constructor `ReadMode'
05:03:10 <Kaidelong> @hoogle getArgs
05:03:10 <lambdabot> System.Environment getArgs :: IO [String]
05:04:42 <argiopeweb> kosmikus: Slightly different , so gen would generate normalC instead of complete data sets, but essentially identical, yes.  It doesn't address the issue where there are potentially differing strictTypes, but it could be fixed. I'm thinking that a method closer to this http://hpaste.org/45247/types would be more useful/readable/elegant in the end game though.
05:04:51 <argiopeweb> Props to Eduard_Munteanu for the idea, I might add.
05:05:36 <Kaidelong> @hoogle f (a -> b) -> a -> f b
05:05:36 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
05:05:36 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
05:05:36 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
05:08:31 <argiopeweb> Though I take that back, type still doesn't work with data constructors... I'm starting to think it's time for bed.
05:09:24 <hpc> :t \fs x -> fmap ($x) fs
05:09:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
05:10:30 <Kaidelong> :t flip (fmap . ($))
05:10:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
05:10:50 <Kaidelong> :t flip (fmap . flip ($))
05:10:50 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:10:50 <benmachine> fmap . ($) = fmap . id = fmap
05:11:10 <Kaidelong> :t flip (fmap . flip id)
05:11:10 <lambdabot> forall b (f :: * -> *) a. (Functor f) => f (a -> b) -> a -> f b
05:11:26 <hpc> @pl \fs x -> fmap ($x) fs
05:11:26 <lambdabot> flip (fmap . flip id)
05:12:18 <Kaidelong> the argument order for openFile is a bit silly
05:12:36 <hpc> :t openFile
05:12:37 <lambdabot> Not in scope: `openFile'
05:12:43 <hpc> @hoogle openFile
05:12:44 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
05:12:54 <hpc> that's not silly imo
05:13:04 <Kaidelong> flip openFile seems more generally useful than openFile though
05:13:56 <DRMacIver> Not that this is necessarily a point in its favour, but openFile's argument order is the same as basically every language ever, so if it were the other way round it would probably often trip you up.
05:14:27 <Veinor> yes, and haskell is never about doing things differently ;)
05:14:32 <Kaidelong> right but haskell bindings to C libraries often do change the argument order if currying is easier
05:14:32 * Veinor looks at 'return' and 'join'
05:14:34 <ClaudiusMaximus> @hoogle withFile
05:14:35 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
05:14:36 <hpc> even if i was new to coding, i think that order is what i would expect
05:14:50 <DRMacIver> Veinor: Hence "Not that it's necessarily a point in its favour"
05:14:59 <hpc> specify the "what" before the "how", so to speak
05:15:44 <DRMacIver> Veinor: Although return and join largely do correspond pretty well with how they behave in other languages in the area of overlap.
05:15:50 <Kaidelong> hpc: but will you generally know the "what" before the "how" though? Thinking conceptually, it would be more likely I'd say something like "this curried function will read a file" as opposed to "something will be done to file at this location"
05:16:27 <DRMacIver> Veinor: e.g. join on lists does exactly what you'd expect coming from random-other-language
05:16:28 <Kaidelong> readFile = openFile ReadMode
05:16:32 <Kaidelong> makes sense
05:16:38 <Kaidelong> or openReadOnly
05:17:06 <Twey> DRMacIver: return does not, however
05:17:27 <DRMacIver> Twey: Excepting early return, it more or less does.
05:17:53 <Twey> return in other languages: â€˜exit the function and cause the function to yield the provided valueâ€™
05:18:06 <hpc> return in haskell: 'yield provided value'
05:18:09 <Twey> Haskell return does not exit the function, and does not necessarily cause the function to yield the provided value
05:18:12 <ezyang> Which of these statements seems more "conservative": "I have no knowledge of what this variable's contents are" or "I know that this variables contents could be anything" 
05:18:18 <Twey> return in Haskell: â€˜wrap value into a monadâ€™
05:18:37 <hpc> Twey: it causes A function to yield the value; it might not be the one you gave the name to though ;)
05:18:41 <Twey> ezyang: The former
05:18:41 <netlogic> Hello, guys
05:18:54 <DRMacIver> ok, fine, I'll grant it was a tenuous claim and withdraw it :)
05:18:59 <ezyang> OK, that's what I thought too. So why does it seem confusing? 
05:19:03 <Twey> ezyang: The latter asserts that it could be anything, whereas in reality there could be a restriction on its contents that you don't know about
05:19:16 <Twey> hpc: Ha
05:19:31 <hpc> ;)
05:19:33 <Twey> hpc: But it doesn't, even: it causes that function to yield a monad-wrapped equivalent of the value.
05:19:34 <ezyang> Hmmm. 
05:19:40 <netlogic> Who is so kind and tell me how to install ghc on Cygwin?
05:19:46 <DRMacIver> But even so that's not really so relevant: "same name for completely different thing" is much less likely to cause regular tripups than "same name for same thing which behaves very slightly differently"
05:20:00 <hpc> Twey: i would say the difference between "yield" and "is" implies monadic
05:20:00 <Kaidelong> Twey: I prefer to think it as an actual return
05:20:06 <mekeor> netlogic: use linux ;)
05:20:19 <hpc> "the sum of [1,2,3,4,5] is FOO" vs "opening a file yields a Handle"
05:20:22 <ezyang> But if I need to reconcile the statements "The contents of this variable is 2" and "The contents of this variable could be anything", I really ought to conclude "The contents of this variable could be anything" 
05:20:33 <Twey> hpc: Maybe so, but *only in Haskell* :Ã¾
05:20:34 <Kaidelong> Twey: since haskell data structures are lazily evaluated it is fair to think of them as programs that return things
05:20:37 <hpc> :P
05:20:51 <ezyang> But it feels like someone might naturally argue the former, so I'm trying to think of a phrasing that makes this clearer. 
05:21:00 <Kaidelong> and in that sense you get some analogy to stuff like Prolog and Icon
05:21:50 <Twey> ezyang: I'm confused by your problem statement
05:22:11 <Saizan> ezyang: if you're given first_phrase OR second_phrase then you'd conclude second_phrease, if you where given first_phrase AND second_phrase you'd conclude first_phrase
05:22:23 <Saizan> *were
05:22:55 <Twey> If you know that the content of the variable is 2, then you know it to be 2; it couldn't be anything else
05:23:11 <Twey> Am I being obtuse here?
05:23:24 <ezyang> No, it's purely a natural language obstacle :-) 
05:23:34 <ezyang> Let's state this formally. 
05:24:29 <ezyang> We represent possible value of a variable as a set. Bottom is defined as { x | forall x. #t }, and Top is defined as the empty set. 
05:25:08 <mekeor> in which language GHC is written?
05:25:20 <Twey> mekeor: Haskell, some C, and a bit of Perl
05:25:23 <ezyang> mekeor: A bastard combination of Haskell, C and C-- 
05:25:35 <Twey> There's C-- *in* GHC?
05:25:45 <ezyang> Yeah, the RTS :-) 
05:25:52 <mekeor> C--??? not C++?????
05:25:55 <Twey> It's written directly in C--?
05:25:58 <Kaidelong> mmm, I think writing the "cat" program actually makes more sense in do notation than point free without it
05:26:02 <Twey> mekeor: Haha, no; why would anyone use C++?
05:26:22 <Eduard_Munteanu> @pl (\f x y -> f x (g y))
05:26:22 <lambdabot> flip flip g . ((.) .)
05:26:22 <ezyang> So, in natural language, I want to describe Bottom as "I don't know anything about the variable", e.g. the most conservative estimate. 
05:26:31 <Twey> ezyang: Right
05:26:44 <ezyang> I want to describe Top as "There's no possible value this variable could have, contradiction, the value of this variable could be anything" 
05:26:59 <Kaidelong> ((`withFile` ReadMode) <$> (head <$> getArgs)) >>= ($ (hGetContents >=> putStrLn))
05:27:07 <ezyang> With that last bit being the confusing turn of speech :-) 
05:27:18 <mekeor> BTW: is there a haskell-compiler/-interpreter, too, which's written in Haskell itself?
05:27:39 <nlogax> @type (>=>)
05:27:39 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:27:41 <Eduard_Munteanu> Well, GHC :)
05:27:45 <ezyang> mekeor: As in, only Haskell? 
05:28:13 <Twey> mekeor: GHC is largely Haskell.  There are just a few bits and pieces in other languages.
05:28:15 <Kaidelong> vs "do { path <- liftM head getArgs ; withFile path ReadMode (hGetContents >=> putStrLn) }"
05:28:56 <shutdown_-h_now> /wonm/win11
05:29:30 <mekeor> ezyang, Twey: thanks
05:30:16 <Twey> Kaidelong: fmap head getArgs >>= flip withFile (ReadMode $ hGetContents >=> putStrLn)
05:30:21 <ezyang> There seems to be some tangible difference between "the value of this variable could be anything" and "there is no possible value of this variable, thus anything goes" 
05:30:25 <Twey> Errr
05:31:19 <Twey> Kaidelong: fmap head getArgs >>= flip withFile ReadMode `flip` hGetContents >=> putStrLn
05:31:25 <Twey> Maybe
05:31:49 <Twey> Brackets might be required depending how the precedences go
05:31:52 <Twey> I can never remember
05:33:18 <Saizan> ezyang: the first anything is about values, the second is about propositions
05:36:58 <ezyang> yeah 
05:37:59 <Saizan> the main difference is that in the latter case you can even conclude "this variable has value 2"
05:38:42 <Eduard_Munteanu> Hrm... for types (say synonyms) can you write kind signatures and definitions on separate lines, just like with functions?
05:39:03 <Saizan> ..still, i wouldn't know how to make it clear in a single sentence
05:39:36 <ClaudiusMaximus> @src readFile
05:39:36 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
05:39:47 <Saizan> Eduard_Munteanu: i don't think so
05:39:59 <ezyang> Yeah >.> 
05:40:48 <Eduard_Munteanu> I see, thanks.
05:41:03 <ezyang> Oh, here's something even more confusing: if I have two merging execution paths, one which says a = {2}, and another that says a = {3}, once I merge them, I should conclude that a = {}, not a = {2,3} 
05:41:30 * hackagebot monad-memo 0.3.0 - Memoization monad transformer  http://hackage.haskell.org/package/monad-memo-0.3.0 (EduardSergeev)
05:41:42 <ezyang> or is it the other way around? ^_^" 
05:42:11 <ddarius> It depends on your lattice structure which depends on what you are modelling, i.e. what the sets mean.
05:42:48 <ezyang> Yeah. But I can't think of a good, natural language, way to distinguish between the lattice on the powerset and its upside-down version. 
05:42:48 <maurer_> Hey, I'm trying to build someone else's package, and got:
05:42:50 <maurer_> Couldn't match expected type `t0 -> t1' with actual type `forall (m :: * -> *). DBReadable m => a -> m b0'
05:43:02 <maurer_> Now, looking over that by hand, this looks like those types should match.
05:43:12 <maurer_> What am I missing?
05:44:08 <ezyang> maybe t0 and t1 have other constraitns? 
05:44:40 <maurer_> ezyang: Wouldn't ghc mention those in the error?
05:45:26 <maurer_> http://hpaste.org/45248/roguestarengine_build_error
05:45:30 <maurer_> Is the complete build error if it helps
05:45:51 <maurer_> (saw it in the RSS feed, wanted to try it out, monkeypatched out some randomgen incompatibilities with ghc7, ran into this)
05:46:22 <ClaudiusMaximus> ezyang: not sure what you're up to, but dataflow lattice analysis sounds vaguely reminiscent of hoopl - perhaps there's some related papers to read? (caveat: i know ~nothing about the topic)  http://hackage.haskell.org/package/hoopl
05:46:31 <rly> I get the following leksah error: http://hpaste.org/45249/leksah_error
05:46:50 <rly> while doing cabal install leksah. Is Leksah even being maintained?
05:47:31 * hackagebot encoding 0.6.4 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.6.4 (HenningGuenther)
05:47:35 <ezyang> ClaudiusMaximus: No, that's exactly the topic I'm on :-) 
05:47:43 <ezyang> maurer_: Hmm, I wonder if some strange rank2 stuff going on. 
05:48:09 <maurer_> ezyang: I'm also assuming (though this could be wrong) that since the author uploaded it in the last day, it was likely working for him under a 6.something version
05:48:24 <ezyang> Could you paste DB.hs? 
05:48:43 <ezyang> MonoLocalBinds would be the most obvious thing, but that would require rank2 stuff going on. 
05:49:15 <byorgey> rly: what version of GHC do you have?
05:49:26 <rly> byorgey: 7.0.1
05:49:38 <maurer_> ezyang: http://hpaste.org/45250/roguestarengine_srcdbhs
05:49:44 <maurer_> He does have Rank2 turned on
05:50:01 <ezyang> Try tacking NoMonoLocalBinds to the LANGUAGE pragma. 
05:50:04 <maurer_> But the error talks about it not being a function, which it seems to pretty clearly be regardless of monolocalbinds
05:50:07 <maurer_> OK
05:50:10 <byorgey> rly: ok, yes, it looks like leksah says it needs an older version of base (4.3.something comes with GHC).
05:50:14 <byorgey> rly: this surprises me.
05:50:15 <ezyang> oh, I see. 
05:50:28 <ezyang> It seems that GHC incorrectly formats rank-2 class constraints. 
05:50:32 <ezyang> I thought we fixed that... 
05:51:16 <byorgey> rly: I guess leksah has just not been updated to work with GHC 7 yet.
05:51:17 <maurer_> Identical error with NoMonoLocalBinds...
05:51:48 <byorgey> rly: I think it is being maintained, but I don't know for sure
05:52:00 <maurer_> Though they are evidently using -fglasgow-exts in their build :( would that conflict?
05:52:01 <ezyang> maurer_: Oh, ok. 
05:52:10 <rly> byorgey: the packages listed for Fedora lag > 6 months. 
05:52:21 <rly> byorgey: same for Ubuntu.
05:52:21 <ezyang> Mmm, shouldn't. 
05:52:29 <ezyang> Usually NoMonoLocalBinds fixes these types of errors... 
05:52:39 <maurer_> ezyang: Nevermind on the fglasgow, that's just one file.
05:53:00 <ezyang> anyway, I think you can get rid of the error by changing any use of $ to not use $ 
05:53:06 <maurer_> ezyang: Oh, got an idea, onesec...
05:53:48 <ezyang> Oh, "Remember that -fglasgow-exts implies -XGADTs and hence -XTypeFamilies. " 
05:54:14 <ezyang> so you'll need to override it from the command line. 
05:54:32 <Boxo> We know that True and 0 "live on the same level" because True:Bool:* and 0:Int:*. But how do we know Bool and Either live on the same level in Haskell as there's no *1 such that Bool:*:*1 and Either:*->*->*:*1 ?
05:54:32 <ezyang> OK, I've got two bugs to file. 
05:55:17 <byorgey> Boxo: well, there is implicitly a single such *1
05:55:31 <byorgey> Boxo: but it is never printed out or otherwise represented explicitly.
05:55:42 <Boxo> and a *2 as well?
05:55:54 <byorgey> Boxo: probably it is manfest in the compiler by some sort of function  checkKind :: Kind -> Bool
05:55:56 <benmachine> byorgey: what is the kind arrow then? :P
05:56:04 <t3eblinder> What is the easiest way to convert [CLong] to [Char]?
05:56:14 <byorgey> benmachine: it's just syntax.
05:56:19 <benmachine> t3eblinder: what kind of conversion do you want?
05:56:25 <byorgey> Boxo: no, there's no *2 needed
05:56:42 <ezyang> muarer_: Easiest way, probably, is to add {-# OPTIONS_GHC -XNoMonoLocalBinds #-} 
05:56:45 <quantum> what is the reason to do anything?
05:56:57 <t3eblinder> benmachine: I get an CLong list (must be text) and what to convert it into a string
05:57:04 <benmachine> ezyang: surely you mean LANGUAGE NoMonoLocalBinds
05:57:14 <maurer_> ezyang: I'll try that, though as a note, I removed all mention of fglasgow-exts and it didn't help
05:57:15 <ezyang> No, I mean OPTIONS_GHC 
05:57:24 <benmachine> ezyang: oh, why
05:57:25 <ezyang> the precedence of the flags is important. 
05:57:27 <Boxo> byorgey: yeah, there isn't, nvm that
05:57:28 <benmachine> oh
05:57:31 <maurer_> ezyang: Also, that didn't help
05:57:34 <ezyang> Ok. 
05:57:52 <maurer_> It's far to complicated to be a test case though.
05:58:03 <maurer_> e.g. there may be something subtle I'm missing, as I didn't write it
05:58:08 <rly> darcs failed:  Not a repository: http://code.haskell.org/leksah-head/leksah-server (Failed to download URL http://code.haskell.org/leksah-head/leksah-server/_darcs/inventory: HTTP response code said error)
05:58:17 <benmachine> t3eblinder: you can convert CLong to Int with fromIntegral, and Int to Char with Data.Char.chr
05:58:21 <rly> byorgey: even the darcs instructions are broken.
05:58:34 <ezyang> No, I'm referring to the formatting bug. 
05:58:56 <ezyang> the type of forall (m :: * -> *). DBReadable m => a -> m b0 is wrong 
05:59:02 <maurer_> ezyang: Let me build head first before you file that
05:59:05 <maurer_> I am not running head
05:59:28 <benmachine> doesn't building head take like half an hour >_>
05:59:42 <byorgey> rly: =(
05:59:44 <ezyang> oh wait, maybe it's ok. 
06:00:04 <Saizan> benmachine: back in the day it took a night!
06:00:10 <byorgey> rly: probably the maintainers have not gotten around to restoring it after code.h.o was compromised a couple months ago
06:00:31 <maurer_> Wait, ghc as git is real? I thought that was an april fool's joke, as the migration date was Apr 1...
06:00:38 <Eduard_Munteanu> Dang, another thing that bugs me... it seems '_' isn't allowed in types as type variables :/
06:01:02 <byorgey> rly: oh, wait, hmm, try  /leksah/leksah-server   instead of /leksah-head/
06:01:44 <ezyang> ok, there is no formatting bug. 
06:01:44 <byorgey> there's something there, although looks like it hasn't been modified since May 2010 ...
06:01:46 <ezyang> maurer_: Yes. 
06:02:11 <rly> byorgey: same result. I will not bother with it further. Clearly, whoever wrote it does not want me to use it.
06:02:26 <byorgey> rly: It seems you are right =(
06:02:38 <maurer_> benmachine: Eh, if I want to help out I should probably have HEAD installed in general.
06:03:04 <benmachine> maurer_: well, except that it is a moving target :P
06:03:35 <maurer_> benmachine: Sure, but if I run into a bug in a HEAD from a week ago, it's less likely to have been patched than if I run into a bug from the last released version
06:04:56 <dixie> rly: this works http://code.haskell.org/leksah/leksah-server
06:08:25 <domme> Eduard_Munteanu: wow, weirdest highlight i ever got
06:10:20 <Twey> domme: What was the highlight?
06:10:31 <Twey> domme: I imagine you must get some pretty interesting highlights
06:10:34 * hackagebot LibClang 0.0.2 - Haskell bindings for libclang (a C++ parsing library)  http://hackage.haskell.org/package/LibClang-0.0.2 (ChetanTaralekar)
06:11:58 <byorgey> (07:59) <Eduard_Munteanu> type RandomMessage = Message (Int, String)
06:13:06 <efie> i think i understand why (LAMBDA x.x) (LAMBDA y.y.) is (LAMBDA y.y.). but why is (LAMDA a.b) (LAMBDA a.b) is (LAMBDA a.b)? I mean, in the first term there is no a after the dot (only a b) which could be replaced so.. i hope anyone can help :)
06:13:37 <byorgey> efie: it isn't.
06:13:40 <benmachine> it's b
06:14:15 <efie> um ok
06:14:17 <byorgey> > (\a -> b) (\a -> b)
06:14:18 <lambdabot>   b
06:14:34 <byorgey> efie: who told you it was (LAMBDA a.b) ?
06:14:45 <efie> my book says it
06:14:53 <byorgey> efie: well, your book is wrong =)
06:14:59 <byorgey> efie: what book is it?
06:16:05 <efie> oh well, maybe its mewho got it wrong, the complete term is: y((LAMDA a.b)(LAMDA a.b)) but i thought the y would make no difference. the book is called haskell - intensivkurs
06:16:22 <benmachine> the y makes a difference!
06:16:26 <Jafet> Sehr intensiv
06:16:32 <efie> oh ok.. :) ?
06:16:32 <benmachine> oh wait
06:16:35 <benmachine> it might do
06:16:43 <byorgey> is the y just a free variable?
06:16:47 <benmachine> or maybe it doesn't >_>
06:16:53 <byorgey> if so that evaluates to  y b
06:17:05 <byorgey> if it is the Y combinator, that is more interesting
06:17:09 <efie> no, y isnt free
06:17:40 <benmachine> it should still be y b shouldn't it?
06:17:56 <byorgey> yes, benmachine, you're right
06:18:15 <benmachine> efie: is b free?
06:19:26 <maurer_> efie: If y is not free, what is y bound to?
06:19:51 <efie> benmachine i think so; maybe i should start the exercise from the beginning: wait a second..
06:21:30 <Boxo> it reduces to (y b) no matter what is free of course
06:22:45 <maurer_> Boxo: Sure, but if y is bound to const for example, she'd ge the answer she was looking for
06:23:43 <osoleve> hey guise, what do you call a baby eigensheep?
06:25:35 <Eduard_Munteanu> Hrm, is a type synonym flip :: (* -> * -> *) -> (* -> * -> *) -> (* -> * -> *)
06:25:40 <Eduard_Munteanu> realizable?
06:26:11 <Saizan> looks like a weird kind for flip, but i'd say no anyway
06:26:13 <efie> http://codepad.org/aC0urrqB
06:26:45 <Eduard_Munteanu> Wait, sorry! (* -> * -> *) -> (* -> * -> *)
06:27:29 <ddarius> No.
06:27:37 <Eduard_Munteanu> :(
06:27:59 <Saizan> you can write it like type Flip f a b = f b a, but then you can't talk about "Flip Foo" only about "Flip Foo X Y"
06:28:01 <ddarius> Well, you can write type Flip f x y = f y x
06:28:04 <Kaidelong> odd that you can't define "type Flipped h b c = h c b
06:28:08 <ddarius> But you can only use it fully applied.
06:28:09 <Kaidelong> oh okay
06:28:26 <Boxo> efie: unbalanced parenthesis on line 5
06:28:54 <Eduard_Munteanu> I was working on universal composition for (->) and (forall (Monad m) a b => a -> m b)
06:29:10 <Eduard_Munteanu> Lemme paste something...
06:29:54 <efie> Boxo sorry, there is one bracket at the end missing
06:30:17 <Eduard_Munteanu> http://paste.pocoo.org/show/364731/
06:30:29 <efie> and therefore in the next line too..
06:30:46 <Eduard_Munteanu> I can do it if I use newtypes, but that means I need to wrap/unwrap functions :(
06:31:37 <efie> http://codepad.org/qJqid42O thats how its in the book
06:31:38 <Eduard_Munteanu> The idea is to use (<.>) for any functions, monadic or not.
06:31:55 <Saizan> that newtype is already Kleisli
06:32:11 <Boxo> okay, so what does (LAMDA a.b) (LAMDA a.b) reducoe to, efie?
06:32:37 <maurer_> efie: Transition 6-7 is incorrect
06:33:02 <efie> i guess b ..
06:33:23 <efie> ?
06:33:26 <Boxo> yeah
06:33:26 <Eduard_Munteanu> Saizan: hrm. So I guess I could derive Monad?
06:33:34 <efie> ok =)
06:33:49 <Eduard_Munteanu> But the point is I don't want to alter function type sigs.
06:34:00 <Eduard_Munteanu> @src Kleisli
06:34:00 <lambdabot> Source not found. Take a stress pill and think things over.
06:35:14 <Saizan> Eduard_Munteanu: look at Control.Category.Category and its instances
06:35:52 <Eduard_Munteanu> Mmm fun, it was already implemented!
06:36:09 <Eduard_Munteanu> But I guess one needs to explicitly write runKleisli, right?
06:36:48 <Eduard_Munteanu> :t (.)
06:36:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:37:03 <Eduard_Munteanu> :t (Control.Category..)
06:37:03 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
06:37:42 <Eduard_Munteanu> :t (Control.Category..) return return
06:37:43 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => a -> m (m1 a)
06:38:12 <Eduard_Munteanu> Hrm.
06:38:16 <hpc> Eduard_Munteanu: that return is the same as prelude
06:38:22 <hpc> in this case at least
06:38:31 <Eduard_Munteanu> :t return
06:38:32 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:38:38 <hpc> :t Kleisli return
06:38:39 <lambdabot> forall a (m :: * -> *). (Monad m) => Kleisli m a a
06:40:03 <Eduard_Munteanu> @hoogle Kleisli
06:40:03 <lambdabot> Control.Arrow newtype Kleisli m a b
06:40:04 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
06:40:04 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
06:40:27 <hpc> :t let kr = Kleisli return in kr Control.Category.. kr
06:40:28 <lambdabot> forall (m :: * -> *) b. (Monad m) => Kleisli m b b
06:40:43 <hpc> :t return >=> return
06:40:44 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:41:49 <Eduard_Munteanu> Hm, so in any case, I'd need to sprinkle Kleisli and runKleisli around.
06:42:07 <hpc> Kleisli is also a newtype instance i think
06:42:09 <hpc> :t ala
06:42:09 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
06:42:32 <hpc> instance Newtype (Kleisli m a b) ( a -> m b)
06:42:32 <Eduard_Munteanu> Um, what is that?!
06:42:33 <Eduard_Munteanu> :)
06:42:47 <Eduard_Munteanu> Is it GeneralizedNewtypeDeriving magic?
06:42:59 <hpc> no, just a cool type class
06:43:12 <Eduard_Munteanu> @src Newtype
06:43:12 <lambdabot> Source not found. There are some things that I just don't know.
06:44:59 <Eduard_Munteanu> Dang, we couldn't we have a nice full STLC at kind level, with partial application in type synonyms :)
06:45:12 <Eduard_Munteanu> s/kind/type/
06:46:08 <niteria> how to do sth like this? map (+1, *2, ^2) [1..]
06:46:31 * Eduard_Munteanu wished for    type Monadic m = \a b --> a -> m b   :)
06:46:44 <niteria> i want to get [(2, 4, 4), (3,6,9) ...]
06:47:08 <Saizan> Eduard_Munteanu: implement an instance resolution algorithm for such instances :)
06:47:19 <Eduard_Munteanu> > zipWith ($) [+1, *2, ^2] [1..]
06:47:20 <lambdabot>   A section must be enclosed in parentheses thus: (+ 1)A section must be encl...
06:47:36 <Eduard_Munteanu> > zipWith ($) [(+1), (*2), (^2)] [1..]
06:47:37 <lambdabot>   [2,4,9]
06:48:01 <Eduard_Munteanu> Wait you wanted something else.
06:48:03 <ClaudiusMaximus> > map (\x -> (x + 1, x * 2, x ^ 2)) [1..]
06:48:03 <lambdabot>   [(2,2,1),(3,4,4),(4,6,9),(5,8,16),(6,10,25),(7,12,36),(8,14,49),(9,16,64),(...
06:48:29 <niteria> yes, but can I do it without lambda?
06:48:52 <ClaudiusMaximus> > map ((+1),(*2),(^2)) [1..]
06:48:53 <lambdabot>   Couldn't match expected type `a -> b'
06:48:53 <lambdabot>         against inferred type `(a1 ->...
06:49:11 <ClaudiusMaximus> possibly, given enough magic
06:50:09 <niteria> "+1", "*2" are record accessors in my case
06:50:45 <niteria> my problem is this: I have a list of some type that does not derive show
06:51:22 <niteria> so I'd like to map accessors over this to get list of touples/lists
06:52:27 <niteria> I guess I'll construct type and search on hoogle
06:52:30 <ClaudiusMaximus> perhaps standalone deriving might work?  the syntax is possibly "{-# LANGUAGE StandaloneDeriving #-} deriving instance Show SomeType" but i've not had to use it recently; might be GHC-only, not sure..
06:53:01 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
06:53:57 <mekeor> foldl on infinite lists?? why is that not possible?
06:54:17 <ClaudiusMaximus> > foldl f e [1..4]
06:54:17 <hpc> > foldl f [1..5] 0
06:54:18 <lambdabot>   f (f (f (f e 1) 2) 3) 4
06:54:18 <lambdabot>   No instance for (GHC.Num.Num [b])
06:54:18 <lambdabot>    arising from the literal `0' at <inter...
06:54:22 <quantum> teh end is infinitely far away
06:54:27 <Eduard_Munteanu> Saizan: hm, I guess in the case of a -> m b, the top-level thingy is (->) so it's not really possible to distinguish between that and a -> b, right?
06:54:34 <hpc> :t foldl
06:54:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:54:38 <ClaudiusMaximus> > foldl f e [1..8]
06:54:39 <lambdabot>   f (f (f (f (f (f (f (f e 1) 2) 3) 4) 5) 6) 7) 8
06:55:20 <Eduard_Munteanu> I wonder if MPTCs and some more magic can make my (<.>) behave seamlessly.
06:55:33 <Eduard_Munteanu> (ideally they'd work for arrows too)
06:58:31 <niteria> @pf (\x -> (x + 1, x * 2, x ^ 2))
06:58:32 <lambdabot> Maybe you meant: bf pl
06:58:36 <niteria> @pl (\x -> (x + 1, x * 2, x ^ 2))
06:58:36 <lambdabot> ap (liftM2 (,,) (1 +) (2 *)) (^ 2)
06:59:24 <ClaudiusMaximus> :t liftM3 (,,) (+1) (*2) (^2)
06:59:24 <lambdabot> forall a. (Num a) => a -> (a, a, a)
07:00:25 <niteria> looks like this'll do
07:00:55 <mekeor> why is haskell not able to calculate with negative exponents??
07:01:11 <quantum> haskell is tureng coimplete
07:01:26 <mekeor> x^(-n) = 1/(x^n)
07:01:30 <quantum> so dont ask what it cant compute but what cant be computed
07:01:42 <mekeor> -.-
07:01:56 <vitka> :t (^)
07:01:56 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
07:02:01 <spidermario> use **
07:02:05 <spidermario> :t (**)
07:02:06 <lambdabot> forall a. (Floating a) => a -> a -> a
07:02:12 <mekeor> a
07:02:14 <mekeor> ok
07:02:18 <spidermario> you might not want to use a Floating type, tough
07:02:24 <mekeor> thanks
07:02:50 <ClaudiusMaximus> > 4 ^^ (-4)
07:02:51 <lambdabot>   3.90625e-3
07:02:54 <spidermario> (^) enables you to use, for example, Data.Ratio
07:03:12 <spidermario> oh
07:03:18 <spidermario> (^^) looks perfect
07:03:40 <spidermario> > (4 % 1) ^^ (-4)
07:03:41 <lambdabot>   1 % 256
07:03:50 <hpc> :t (^^)
07:03:51 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
07:03:58 <mekeor> is % == modulo?
07:04:01 <spidermario> no
07:04:03 <mekeor> oO
07:04:14 <spidermario> itâ€™s for building a rational
07:04:22 <vitka> :t (^^)
07:04:23 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
07:04:28 <spidermario> :t (%)
07:04:29 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
07:05:18 <spidermario> > 4 % 5 + 3 % 10
07:05:19 <lambdabot>   11 % 10
07:05:24 <mekeor> is lambdabot a GHCI?
07:05:29 <spidermario> kind of
07:05:32 <Cale> no, but it uses GHC
07:05:33 <mekeor> cool
07:05:42 <spidermario> it can do more
07:05:56 <spidermario> @pl (\x -> x * 3)
07:05:56 <lambdabot> (3 *)
07:06:09 * vitka pets lambdabot.
07:06:18 <spidermario> @slap vitka
07:06:18 * lambdabot activates her slap-o-matic...
07:06:24 <vitka> eek
07:06:27 <mekeor> :print 1234^1234
07:06:29 <hpc> o.O it knows (*) is commutative or whatever it is?
07:06:49 <spidermario> let us test
07:06:54 <spidermario> @pl (\x -> x % 3)
07:06:54 <lambdabot> (% 3)
07:07:01 <spidermario> it seems so
07:07:13 <Zao> @pl \x -> x <$$$ 3
07:07:13 <lambdabot> (<$$$ 3)
07:07:30 <Boxo> @pl (\a b -> b + a)
07:07:30 <lambdabot> (+)
07:07:36 <Boxo> @unpl (+)
07:07:36 <lambdabot> (+)
07:07:39 <mekeor> whats "@pl"??
07:07:43 <spidermario> pointless
07:07:52 <niteria> :t filterM
07:07:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
07:08:06 <mekeor> what happens if I type ":q"
07:08:06 <mekeor> ?
07:08:22 <vitka> :q
07:08:30 <mekeor> :quit
07:08:36 <niteria> can I use lambdabot offline?
07:08:39 <vitka> :P
07:08:40 <hpc> niteria: yes
07:08:43 <benmachine> niteria: if you can get it to compile
07:08:43 <hpc> @hackage lambdabot
07:08:43 <lambdabot> http://hackage.haskell.org/package/lambdabot
07:08:49 <benmachine> I think it hasn't been updated for ghc 7
07:08:49 <mekeor> nitera: use ghci
07:09:00 <niteria> ghci doesnt have @pl
07:09:00 <mekeor> *niteria
07:09:04 <mekeor> hm
07:09:06 <mekeor> :(
07:09:10 <spidermario> pointless is a separate package
07:09:13 <benmachine> niteria: there's a package for that tool specifically
07:09:16 <spidermario> just "cabal install pointless"
07:09:20 <benmachine> pointfree
07:09:27 <spidermario> yes, sorry
07:09:33 <benmachine> http://hackage.haskell.org/package/pointfree
07:09:47 <mekeor> http://www.haskell.org/haskellwiki/Pointfree
07:09:59 <spidermario> "yaourt -S pointfree" under arch linux
07:10:30 <spidermario> "pointful" makes the reverse operation
07:12:11 <niteria> cool
07:16:01 <Boxo> haha, I just thought "Wouldn't it be cool if there was a way to bind arguments to names so you could refer to them more easily in the definitions of point-free functions"...
07:16:14 <quantum> lololo
07:16:44 <mekeor> :?
07:19:59 <hpc> Boxo: lol
07:21:37 <mekeor> does the function "null" return "true" if the list is empty?
07:21:40 <mekeor> :t null
07:21:41 <lambdabot> forall a. [a] -> Bool
07:21:57 <Boxo> Lambda: the ultimate point-free combinator
07:22:24 <mekeor> mekeor: yes
07:23:23 <niteria> how to get [a] from [IO a] ?
07:23:37 <benmachine> niteria: you don't
07:23:41 <benmachine> you can get IO [a]
07:23:52 <niteria> thats good enough
07:23:56 <benmachine> :t sequence
07:23:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:24:04 <benmachine> from Control.Monad
07:25:21 <Aune> > sequence [Just 3, Nothing, Just 5]
07:25:22 <lambdabot>   Nothing
07:25:50 <boegel> is there a library interface to Hoogle?
07:25:57 <fenfrie> whoo can say me where the error is in my module: http://hpaste.org/45251/module_error
07:26:25 <boegel> I just checked lambdabot's sources, and there a hackish plugin approach is taken instead of talking to a clean api?
07:30:45 <niteria> :t liftM3 (,,) (+1) (*2) (^2)
07:30:46 <lambdabot> forall a. (Num a) => a -> (a, a, a)
07:31:07 <niteria> :: (Num a, Monad ((->) a)) => a -> (a, a, a) sais my ghci
07:31:17 <niteria> says*
07:31:38 <niteria> I don't understand Monad((->) a) part
07:32:13 <Saizan> boegel: lambdabot calls the hoogle binary
07:32:43 <fenfrie> can nobody help me? its a small question from a haskell beginner and ghci dont give me the information
07:32:44 <Boxo> It's like (Monad []) or (Functor Maybe). It means that for all x, (a -> x) is a monad.
07:32:47 <Saizan> fenfrie: module names need to start with an uppercase letter
07:33:06 <Boxo> (Try to figure out the instance)
07:33:50 <fenfrie> Saizan: thy
07:34:35 <gio123> I have to prove termination of some rule which have form P ==> Q/\R, Q is in normal form, if I define some complexity measure cm and prove cm(R)<cm(P) can I say cm(Q/\R)<cm(P) 
07:34:56 <a930913> Should I throw myself in the deep end and just go and make an IRC bot in Haskell?
07:34:58 <Boxo> ((->) a b) is another way of writing (a -> b); ((->) a) is to (a -> b) as (Either a) is to (Either a b)
07:36:00 <hpc> a930913: that's what i did
07:36:00 <niteria> partially applied type
07:36:03 <hpc> worked out well enough
07:36:19 <hpc> there's a good page on the wiki to start off
07:36:43 <a930913> hpc: There is a socket oe?
07:41:37 <alpa> hey
07:41:52 <alpa> i have a question 
07:42:47 <benmachine> alpa: I have an answer
07:43:04 <benmachine> but it might not be to your question
07:43:13 <benmachine> I won't be able to find out until you tell us what the questino is
07:43:35 <alpa> testing something new 
07:43:57 <alpa> ok
07:44:25 <alpa> why is vn a b c   a = p*q..... 
07:44:52 <alpa> not the same such as vn 5 2 1
07:46:52 <alpa> i mean 
07:46:57 <alpa> nachricht = 254
07:47:08 <alpa> n=p*q
07:47:13 <alpa> e=((!!) (teilerfremd(m)) ezahl)
07:47:53 <alpa> vn = scglÃ¼sseln nachricht e n
07:48:53 <alpa> but it is not the same result if i work with numbers
07:49:13 <benmachine> so you're defining a function and it's not working as you expect?
07:49:32 <benmachine> can you go to hpaste.org and give the complete definition, along with some indication of what it is supposed to do?
07:49:36 <alpa> PS: schlÃ¼sseln a b c = exp2(a,b)`mod` c
07:50:34 <alpa> http://hpaste.org/45252/rsa
07:51:48 <benmachine> > 254 ^ 23
07:51:49 <lambdabot>   20472716960222217440765674361370198531781180759331569664
07:52:02 <benmachine> alpa: my guess is that you are overflowing Int
07:52:13 <benmachine> Int can only hold numbers up to (usually) 2^32 or thereabouts
07:52:21 <benmachine> try using Integer instead
07:52:31 <benmachine> it will be slower but can be as large as your computer's memory will allow
07:53:18 <Saizan> !! takes an Int
07:53:19 <alpa> ok
07:53:21 <a930913> o.O
07:53:25 <benmachine> Saizan: true :(
07:53:32 <a930913> 1gb install :s
07:53:43 * a930913 only has 500mb left.
07:54:05 <benmachine> alpa: you might want to import Data.List and use genericIndex instead of !!
07:54:36 <lutza> hello im learning haskell+parsec, how can i create a parser function with additional custom arguments?
07:55:36 <niteria> @search (a->b) -> [a] -> [(a,b)]
07:55:36 <lambdabot> Unknown command, try @list
07:55:40 <benmachine> lutza: that is a vague question. what exactly do you mean?
07:55:42 <a930913> That's worse than java isn't it?
07:55:46 <niteria> @hoogle (a->b) -> [a] -> [(a,b)]
07:55:46 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
07:55:46 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
07:55:46 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
07:56:08 <hpc> lutza: same as you would with any other monad, i suppose
07:56:26 <benmachine> niteria: map (id &&& f) is quite a good way (&&& is in Control.Arrow)
07:56:30 <hpc> :t \x y -> do z <- Just x; return (x + y)
07:56:30 <lambdabot> forall a. (Num a) => a -> a -> Maybe a
07:59:05 <Jafet> a930913: disk drives are now US$0.05 per GB.
07:59:21 <niteria> @hoogle (a-> IO b) -> [a] -> [(a,IO b)]
07:59:21 <lambdabot> No results found
07:59:26 <niteria> it's more like this
07:59:40 <benmachine> niteria: surely that's exactly the same
08:00:01 <jmcarthur> ninly!
08:00:10 <pacak> Suppose i have some haskell code and want to compile it for linux on MIPS machine. Where should i start?
08:00:36 <a930913> Jafet: Inserting money into my computer wont let it hold more.
08:00:40 <benmachine> jmcarthur: wat
08:00:50 <alpa> thx 
08:00:53 <jmcarthur> benmachine: i'm saying hi to ninly 
08:00:55 <niteria> @hoogle [(a, IO b)] -> IO [(a,b)]
08:00:55 <lambdabot> No results found
08:00:56 <benmachine> oh
08:01:00 <jmcarthur> haha
08:01:01 * benmachine fails at reading
08:01:02 <alpa> work finnaly
08:01:10 <ninly> hello!
08:01:16 <Jafet> niteria: do you know what hoogle does?
08:01:50 <Eliel> a930913: in that case, spending 300-400â‚¬ should get you a new machine with plenty of extra everything compared to what you have.
08:01:51 <niteria> finds functions
08:02:00 <benmachine> niteria: ah, that's more interesting. note that if you can go (a, IO b) -> IO (a, b) then mapM will do the rest
08:02:14 <a930913> Eliel: If you're paying..
08:02:27 <Jafet> niteria: It searches functions that people have already written in base.
08:02:47 <benmachine> @pl \(x,y) -> fmap ((,) x) y
08:02:47 <lambdabot> uncurry (fmap . (,))
08:02:56 <Jafet> (a -> m b) -> [a] -> m [(a, b)] is a rather unlikely function to exist in base
08:03:19 <Jafet> a930913: nobody here is paying... don't install it if you don't want to
08:03:27 <benmachine> Jafet: can't hurt to try though
08:03:46 <a930913> Jafet: I think I'll stick to codepad for now.
08:03:48 <niteria> it's a good way to ask a question :D
08:03:55 <Jafet> a930913: and you're chatting long distance!
08:03:55 <benmachine> niteria: :P
08:04:22 <spidermario> @hoogle (a -> m b) -> m (a -> b)
08:04:22 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
08:04:25 <benmachine> :t mapM (uncurry (fmap . (,)))
08:04:26 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => [(a1, f a)] -> f [(a1, a)]
08:04:34 <benmachine> :t mapM (uncurry (liftM . (,)))
08:04:34 <lambdabot> forall a1 (m :: * -> *) a. (Monad m) => [(a, m a1)] -> m [(a, a1)]
08:04:48 <a930913> Jafet: "chatting long distance"?
08:04:57 <Jafet> :t \f xs -> map (\x -> (x, f x)) xs
08:04:57 <lambdabot> forall a t. (a -> t) -> [a] -> [(a, t)]
08:05:03 <Jafet> @pl \f xs -> map (\x -> (x, f x)) xs
08:05:04 <lambdabot> map . ap (,)
08:06:03 <Jafet> :t \f xs -> mapM (\x -> f x >>= \r -> return (x,r)) xs
08:06:04 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m [(a, a1)]
08:06:11 <Jafet> @pl \f xs -> mapM (\x -> f x >>= \r -> return (x,r)) xs
08:06:11 <lambdabot> mapM . (`ap` ((return .) . (,))) . ((>>=) .)
08:06:24 <Jafet> Okay, that was the first bad answer
08:06:29 <niteria> looks scary
08:06:38 <benmachine> what was wrong with my version >_>
08:06:53 <niteria> I'm still groking it
08:07:19 <Jafet> benmachine: oversufficiently advanced technology
08:07:20 <benmachine> well if you want a simpler version
08:08:01 <benmachine> :t mapM (\(x,y) -> do z <- y; return (x,z))
08:08:02 <lambdabot> forall t (m :: * -> *) t1. (Monad m) => [(t, m t1)] -> m [(t, t1)]
08:09:37 <niteria> that's way more understandable
08:10:56 <niteria> thanks
08:12:09 <jmcarthur> a930913: if you don't mind using a potentially old version of ghc you could sign up for one of those free ssh accounts on a server that has ghc
08:12:24 <jmcarthur> a930913: i think devio.us has a very old version of ghc
08:12:38 <jmcarthur> there may be others with newer versions
08:13:12 <jmcarthur> wow, devio.us has ghc 6.6.1
08:13:21 <a930913> Hmm, could get someone on cluenet to install it...
08:15:22 <a930913> Anyone explain why this copypaste doesn't work (and how it should work :p )?
08:15:26 <a930913> http://codepad.org/G9QBy4Lq
08:16:00 <beastaugh> the variable n doesn't have a value
08:16:15 <boegel> Saizan: yeah, so does that mean there's no library interface to Hoogle? otherwise lambdabot would be using it, right?
08:16:25 <beastaugh> on the rhs of the list comprehension on line 10
08:17:12 <Saizan> boegel: there actually is http://hackage.haskell.org/packages/archive/hoogle/4.2.1/doc/html/Hoogle.html
08:18:08 <a930913> beastaugh: How do I assign it a value?
08:19:09 <beastaugh> n = 10 (for example)
08:19:22 <beastaugh> either at the top level or in a where clause
08:19:26 <a930913> Nothing fancy?
08:19:30 <beastaugh> nope
08:19:43 <beastaugh> what's the code meant to do?
08:20:15 <a930913> http://codepad.org/9Vq7xayO
08:21:16 <a930913> beastaugh: http://en.wikipedia.org/wiki/Eight_queens_puzzle
08:21:43 <beastaugh> the fact that your `safe' function isn't defined will also be a problem
08:21:47 <frerich> BONUS: Did you write Learn You A Haskell?
08:21:55 <BONUS> hey
08:21:55 <lambdabot> BONUS: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:21:57 <BONUS> yeah!
08:21:59 <BONUS> whoa
08:22:57 <BONUS> do you like it?
08:23:43 <a930913> beastaugh: So when the person said that these few lines of code would solve it, he was only telling half truths/lying?
08:23:53 <frerich> BONUS: Thanks a ton for it, I just read a few sections online and it's really nice. I'l about 40% through RWH (my first Haskell book) and I really enjoyed your book because it often used different wording for explaining the same principles. Your texts cleared a lot of things up for me.
08:24:03 <BONUS> cool!
08:24:33 <beastaugh> a930913: pretty much, yes
08:24:39 <beastaugh> I mean, it won't run as-is
08:25:36 <frerich> BONUS: I'd like to buy a copy, but I tend to buy all my stuff via Amazon. If you'd rather like me to ship via another site (which potentially gives more money to you ;-)), let me know. ;-)
08:25:49 <frerich> s/ship/shop/
08:26:04 <a930913> It's like a java person saying that all they need to write is findPrimeN(200000) to find the 200,000th prime when really he downloaded a library to do it for him?
08:26:28 <BONUS> frerich: whatever is more convenient for you, but if you buy through http://nostarch.com/lyah.htm and enter the promo code 3L3PH4NT, you get the ebook version for free + some secret swag
08:27:10 <BONUS> but otherwise whatever you like, the most important thing is that you're reading it hehe
08:27:34 <frerich> BONUS: Do you know when it's going to be ready for shipment? Seems it's not done yet, at least I can only preorder it everywhere.
08:27:51 <BONUS> Yeah, it ships in a week
08:27:56 <BONUS> woot
08:28:13 <frerich> Congrats :-)
08:28:24 <BONUS> hehe thanks
08:29:29 <beastaugh> a930913: I wouldn't go that far, but it's not a complete solution as given
08:29:39 <JuanDaugherty> all I want/need is ... is some secret swag
08:29:44 <beastaugh> maybe have a look at these instead
08:29:46 <beastaugh> http://en.literateprograms.org/Eight_Queens_puzzle_(Haskell)
08:29:50 <beastaugh> http://therning.org/magnus/archives/330
08:30:20 <BONUS> got some swag in the bag
08:32:03 <boegel> BONUS: y0
08:33:02 <BONUS> kehoste my main man!
08:33:05 <BONUS> what's up
08:33:11 <boegel> Saizan: hmmmk, I'll look into it
08:33:23 <boegel> BONUS: not much
08:33:37 <boegel> BONUS: I'm sitting here, waiting, 'til your book lands on my doorstep
08:33:52 <boegel> BONUS: I've sworn not to go out the door before I get it
08:34:02 <boegel> BONUS: I'm starting to get hungry though...
08:34:09 <BONUS> haha, gotta order pizza!
08:34:21 <BONUS> wouldnt it be cool if you got a free pizza with a copy of the book
08:34:23 <BONUS> that would own
08:34:25 <boegel> BONUS: ran out of food/money, it's starting to be a real pain
08:34:31 <boegel> BONUS: it would
08:34:34 <dahankzter> Whats the best way to to do parallell work in haskell? There seems to a multitude of ways what to choose?
08:34:35 <BONUS> i'll send you some care packages, no worries
08:34:39 <BONUS> i got some apples & stuff
08:34:40 <boegel> BONUS: will there be goodies that come with the book?
08:34:51 <BONUS> yeah, if you order through no starch
08:35:27 <BONUS> but if you didn't i'll send some for you and jasper and itkovian
08:35:28 <maurer_> dahankzter: That's somewhat domain specific
08:35:29 <jmcarthur> dahankzter: depends on the problem you're trying to solve
08:35:58 <maurer_> dahankzter: If you are doing some sort of problem where your goal is asynchrony, you'll want to look at forkIO and MVars/TVars
08:36:07 <boegel> BONUS: I did order through no starch
08:36:11 <BONUS> w00t
08:36:18 <jmcarthur> maurer_: that's not parallelism! :P
08:36:20 <BONUS> then you're good to go
08:36:34 <maurer_> jmcarthur: While true, we're trying to guess what he's doing
08:36:40 <boegel> BONUS: don't send stuff to jaspervdj and Itkovian though, that way I can laugh at them for not having the goodies ^^
08:37:06 <maurer_> dahankzter: If you're going for a speed boost, look into par, parMap, etc.
08:37:08 <BONUS> haha that's pretty evil, but so am i, so deal
08:37:43 <dahankzter> speed boost on large core numbers, so the par stuff is first off then, thx
08:37:54 <rostayob> I remember there was a way of showing code generated with template haskell in ghci
08:38:01 <boegel> BONUS: cool :D
08:38:03 <maurer_> dahankzter: If you're doing something for a whole lot of speed, and think it seems similar to simd stuff, http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
08:38:06 <jmcarthur> dahankzter: also look at repa, as it works pretty well now and might be suitable
08:38:12 <Saizan> rostayob: -ddump-splices
08:38:16 <rostayob> Saizan: thanks
08:38:18 <boegel> BONUS: what kind of goodies?
08:38:21 <jmcarthur> dahankzter: nested data parallelism isn't really ready for prime time yet, though
08:38:38 <BONUS> it's a secret. let's just say they might be sticky
08:40:05 <a930913> :o I just 500'd codepad.
08:40:19 <jmcarthur> BONUS: congrats on the inevitable release of the book, btw
08:40:31 <BONUS> haha thanks. gotta love inevitabilities
08:41:03 <a930913> http://codepad.org/lwG87Lbv :p
08:42:17 <jmcarthur> haha, i love the sun on lyah's web site. "Holy shit!"
08:42:25 <BONUS> :D
08:42:36 <jmcarthur> so much for the cartoons being all kid friendly and stuff :P
08:42:51 <boegel> BONUS: gum? wet girls?
08:43:00 <BONUS> haha, i don't think most grownups realize how much kids swear
08:43:07 <hpc> truckloads of maple syrup!
08:43:14 <BONUS> boegel: LYAH-brand superglue
08:43:16 <jmcarthur> i didn't swear when i was first learning programming
08:43:25 <BONUS> i was, because i first learned javascript
08:43:26 <jmcarthur> i learned that when i started with c++
08:43:37 <jmcarthur> beat you to the joke!
08:43:47 <BONUS> damn!
08:44:05 <boegel> BONUS: dude, you're getting weak
08:44:14 <boegel> BONUS: better say something really funny, quick!
08:44:25 <BONUS> ugughgh!! *gets nervous, chokes, dies*
08:44:38 <JuanDaugherty> the whole concept of swearing is backward
08:45:10 <jmcarthur> yeah, so much focus on the words and not on what you're saying
08:45:13 <boegel> BONUS: you earn more by selling through No Starch?
08:45:15 <vegai> whoa. lyah's front page might be the best thing that's going on haskell at the moment
08:45:24 <BONUS> vegai: lol
08:45:30 <vegai> I think I'll have to buy the book now :(
08:45:55 <BONUS> boegel: i think so. i'm really bad with finances :(
08:46:04 <vegai> :( because I've been buying lots of things lately
08:46:19 <hpc> it reminds me of theoatmeal.com
08:46:35 <boegel> BONUS: so, how much do you earn per book? is it like $5?
08:47:08 <BONUS> it's 10% i think, but i don't know exactly 10% of what
08:48:06 <JuanDaugherty> that's criminal, they should get 10%
08:48:08 <boegel> :)
08:48:28 <vegai> ah, rather steep shipping costs
08:48:38 <JuanDaugherty> (of the markup from the actual cost of production)
08:48:52 <boegel> BONUS: you'll be a millionaire soon!
08:49:04 <vegai> I suppose they're doing something of value if writers use them?
08:49:10 <BONUS> a thousandeer at least
08:49:54 <JuanDaugherty> you shoulda just sold a PDF that has to be signed into and sold it with paypal oder
08:50:02 <JuanDaugherty> like packt or whosits
08:50:15 <jmcarthur> people like killing trees
08:50:30 <JuanDaugherty> i forgot about them
08:50:36 <BONUS> reminder that before this it was free to read online, and is still free to read online :D
08:50:41 <BONUS> so money really isn't a big issue for me
08:50:49 <luite> BONUS: might be enough to buy a beach chair on the bahamas!
08:51:05 <paczesiowa> byorgey: could you take a look at this? I have no idea how to make it work. http://hpaste.org/45253/unbound_lib_usage
08:51:15 <BONUS> haha. it would be cool knowing that you own a beach chair on the bahamas, even if you never see/use it in person
08:54:37 <Eduard_Munteanu> Well, I guess the dead-tree form isn't any different in content from the online version, is it?
08:55:28 <BONUS> for now it is, it's been edited and improved and polished, but one of these days i'm going to update the online version to reflect the new version
08:57:24 <Botje> hmm. a BONUS.
08:57:30 <Botje> that reminds me. *orders*
08:57:55 <Eduard_Munteanu> BONUS: how does that work really, they publish open-content books? Like Creative Commons, or whatever?
08:58:22 <BONUS> yeah, they will publish CC books, as long as they have a non-commercial CC clause (which mine does)
08:58:34 <BONUS> if it didn't have that, other publishers could just print it and sell it and compete with them
08:58:41 <Eduard_Munteanu> Nice.
08:58:41 <BONUS> Botje: much obliged *tips hat*
08:58:46 <Eduard_Munteanu> Here's a BONUS...
08:58:48 <Eduard_Munteanu> BONUS++
08:58:51 <Eduard_Munteanu> :)
08:58:56 * RayNbow ordered the book last Wednesday... the discount is nice as it cancels out the int'l shipping costs :)
08:59:01 <BONUS> heheh
08:59:10 <fronrlens> Iteratees are too complex
08:59:42 <BONUS> they're sort of like beefed up coroutines
08:59:55 <fronrlens> they made my head hurt
09:00:03 * ddarius doesn't think anything is ever "beefed down."
09:00:21 <Eduard_Munteanu> Beef up, water down :P
09:00:55 <Eduard_Munteanu> @karma BONUS 
09:00:55 <lambdabot> BONUS has a karma of 9
09:00:58 <BONUS> like when you have data Coroutine i o a = Result a | o -> (i -> Coroutine i o a)
09:00:59 <vegai> BONUS: will you write an "advanced" sort of book also?
09:01:11 <BONUS> ddarius: hahah, that's a good observation
09:01:30 <BONUS> vegai: maybe in the future, but for now i'll just focus on coding and stuff like that
09:01:52 <vegai> learn you a zygohistomorphic prepromorphism for great good?
09:02:11 <Eduard_Munteanu> Heh, that'd do.
09:02:23 <BONUS> vegai: omg how did you know
09:02:36 <BONUS> Learn You a Real World Haskell for Great Good
09:02:36 * vegai grins
09:02:36 <BONUS> haha
09:03:01 <Eduard_Munteanu> Seriously, there's good stuff to be stolen from RWH and a few other places like Wikibooks.
09:03:20 <jaspervdj> BONUS: I want goodies!
09:03:41 <BONUS> jaspervdj: i'll send them to you!
09:04:03 <jaspervdj> Also you can give itkovian's and boegel's goodies to me, I'll pass them on
09:04:05 <jaspervdj> honestly
09:04:20 <BONUS> hmmm, i believe you, for some reason. deal.
09:04:22 <fronrlens> haskell
09:04:37 <BONUS> fronrlens: agreed
09:05:57 <fronrlens> I was going to say, haskell kind of wastes a lot of time. I am not sure exactly why
09:06:21 <fronrlens> Oh I know why
09:06:54 <marcot> Is there a <.> somewhere, in the sense of Control.Applicative.<$>?
09:07:03 <marcot> Something that is for ., like <$> is for $
09:07:35 <Saizan> <no
09:08:28 <fronrlens> why exactly does writing your code in CPS result in performance gains?
09:08:38 <fronrlens> most of the time
09:08:53 <spidermario> what does CPS stand for?
09:08:55 <opqdonut> marcot: fmap?
09:08:57 <spidermario> oh
09:09:01 <spidermario> continuation passing style?
09:09:04 <Saizan> yep
09:09:07 <marcot> opqdonut: fmap is identical to <$>
09:09:08 <Botje> fronrlens: at a guess i would say the compiler can agressively inline.
09:09:15 <BONUS> fronrlens: afaik less matching on constructors?
09:09:33 <opqdonut> marcot: oh, yeah, indeed
09:09:40 <fronrlens> spidermario: yes
09:09:53 <jaspervdj> fronrlens: it's less readable, so it must be faster!
09:10:02 <fronrlens> lol
09:10:18 <marcot> (<.>) f m p = f <$> m p
09:10:27 <marcot> I'd just like to avoid including this definition in my code.
09:10:29 <Eduard_Munteanu> AFAIK, it lets some optimizations take place in some cases, but it doesn't result in faster code per se.
09:11:51 <Eduard_Munteanu> I think it also forces a particular style that avoids some performance hogs.
09:12:48 <opqdonut> hogs such as?
09:13:48 <Jafet> marcot: how is <$> to $?
09:14:37 <marcot> > :t (<$>)
09:14:38 <lambdabot>   <no location info>: parse error on input `:'
09:14:58 <marcot> @type (<$>)
09:14:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:15:01 <marcot> @type ($)
09:15:01 <lambdabot> forall a b. (a -> b) -> a -> b
09:15:31 <Twey> marcot: x <.> y = (.) <$> x <*> y
09:15:32 <Twey> â€¦ I guess
09:15:53 <Twey> :t (($), (<$>))
09:15:54 <lambdabot> forall a b a1 b1 (f :: * -> *). (Functor f) => ((a -> b) -> a -> b, (a1 -> b1) -> f a1 -> f b1)
09:16:17 <Twey> :t (P.(.), \x y -> (.) <$> x <*> y)
09:16:18 <lambdabot> Not in scope: data constructor `P'
09:16:21 <Twey> :t (Prelude.(.), \x y -> (.) <$> x <*> y)
09:16:22 <lambdabot> Not in scope: data constructor `Prelude'
09:16:25 <Jafet> marcot: Functor (a->) actually has fmap = (.)
09:16:32 <Twey> >.<  Where've you hidden it now?  :Ã¾
09:16:39 <Twey> :t ((.), \x y -> (.) <$> x <*> y)
09:16:40 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *) (f2 :: * -> *). (Functor f, Functor f1, Applicative f2) => ((a -> b) -> f a -> f b, f2 (a1 -> b1) -> f2 (f1 a1) -> f2 (f1 b1))
09:16:56 <mikeg> :t Prelude..
09:16:56 <lambdabot> parse error on input `Prelude..'
09:17:55 <fronrlens> so do everyone now use Iteratees for IO ?
09:28:22 <Saizan> not everyone
09:28:45 <Saizan> they are mostly used by people working with network protocols
09:42:06 <Taslem> Does it ever make sense to have a list of functions?
09:42:12 <quantum> yes
09:42:13 <hpc> Taslem: yes
09:42:39 <hpc> > [(+),(*)] <*> [1,2] <*} [3,4]
09:42:40 <lambdabot>   <no location info>: parse error on input `}'
09:42:44 <hpc> > [(+),(*)] <*> [1,2] <*> [3,4]
09:42:45 <lambdabot>   [4,5,5,6,3,4,6,8]
09:42:47 <hpc> :P
09:43:10 <Taslem> Is it possible for a value to not be able to be put in a list?
09:43:15 <quantum> yes
09:43:25 <quantum> you cannot put a list into itself
09:43:42 <Taslem> No, I mean. Are there any types for which List a is not possible?
09:43:45 <hpc> that's an infinite types problem though, not a limiation of list
09:43:46 <paczesiowa> what about [Int#]
09:43:47 <hpc> Taslem: no
09:43:55 <hpc> unboxed don't count :P
09:43:56 <quantum> List :: * -> *
09:44:04 <quantum> if a :: * then List a :: *
09:44:07 <quantum> that's all there is to it
09:44:12 <Eelis> well, you need some Haskell extensions to have a [forall a . a], right?
09:44:21 <copumpkin> yeah
09:44:55 <Eelis> so perhaps that's the kind of thing Taslem was thinking of
09:46:25 <quantum> definitely not
09:46:29 <copumpkin> oddly enough, [forall a. a] is roughly a peano natural
09:46:51 <Eelis> quantum: i'm not sure what you're saying
09:47:25 <Taslem> Is there anywhere that's done analysis n how random StdGen is?
09:48:54 <Jafet> StdGen isn't random; it's pseudorandom
09:49:01 <Eelis> (he left)
09:49:34 <adorablepuppy> Why can't I do this? http://hpaste.org/paste/45254/thing | It says No instances for (Num [[b]], Num [b]) arising  from a use of 'doStuff'
09:50:47 <Eelis> adorablepuppy: what do you intend for the type of addOne to be?
09:51:00 <adorablepuppy> addOne should be Int
09:51:07 <Eelis> you mean Int->Int ?
09:51:14 <adorablepuppy> Yeah, that's what I mean
09:51:36 <Eelis> ok, so then    addOne x   is an Int. but then i don't get what you want    addOne x >>= bla   to do
09:51:52 <Eelis> the left operand of >>= needs to be a monadic thing
09:52:01 <Eelis> which Int is not
09:52:13 <adorablepuppy> Ah. I see.
09:52:55 <Jafet> @type (>>=)
09:52:55 <Botje> adorablepuppy: can you explain in words what doStuff should do?
09:52:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:54:12 <adorablepuppy> I posted working nonmonadic code below. Basically doStuff added 1 to x, then put it in a list with y, then added 2 to each.
09:54:15 <Eelis> adorablepuppy: generally speaking, declaring the types of things is a good idea, not in the least because it greatly improves the error messages you'll get from the compiler
09:54:42 <Eelis> in this case, if you'd declared the type for addOne, it would've probably given you an error along the lines of what i said
09:56:17 <Botje> adorablepuppy: ah.
09:57:08 <Botje> adorablepuppy: you could use let expressions to name intermediate values
09:59:03 <rostayob> is it possible to get the constructor of a data type with TH?
09:59:23 <Eelis> yes
09:59:27 <Saizan> rostayob: see reify
09:59:44 <adorablepuppy> This whole thing was supposed to test what I was trying to do with an IO (not really exaclty), but more or less I was trying to test out the concept of monads to see if I understood it well enough to even use the IO code. But it seems I should stick to do syntax for the time being.
10:00:23 <rostayob> Saizan: oh right, I even used it before but now I don't know why i was banging my head in trying to get them with the Typeable stuff... thanks
10:01:31 <adorablepuppy> I haven't developed the intuitive understanding yet. :( So I need to work on myself a bit more.
10:02:30 <Jafet> x >>= y means that y grabs the thingy from the monadic value x and produces a new monadic value
10:03:32 <adorablepuppy> I know what it means, I just can't get it to work. 
10:03:42 <hpc> :t (>>=)
10:03:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:04:05 <adorablepuppy> I'm not going to give up, I must get this IO code working.
10:04:09 <Botje> adorablepuppy: if you use do syntax you will get the same errors
10:04:42 <hpc> lists are one of the trickier monads to manipulate if you are new
10:04:53 <Botje> adorablepuppy: what you could do is sprinkle some calls to return in your code
10:05:16 <Botje> since none of your add* functions are monadic.
10:06:24 <adorablepuppy> Right that's the problem for my example code. But I'm coding up a monadic form for some IO code I have. The IO code works in do notation, but doesn't work when I use >>=. So if I post that, maybe I can find out what is really wrong.
10:06:48 <dmwit> Yes, post the do block you have and the translation to >>= that you tried. =)
10:07:20 <dmwit> By the way, the translation between do-notation and (>>=) is described well in Tackling the Awkward Squad, if you're interested.
10:08:27 <CBindahouse> can anybody tell me how to install wxWidgets on Ubuntu 10.10?
10:09:05 <sipa> download it from source, configre, compile, install
10:09:38 <CBindahouse> i'm using cabal but it keeps giving errors about not being able to install wxcore
10:09:38 <dmwit> CBindahouse: "cabal install wx" should do.
10:09:59 <dmwit> CBindahouse: Have you installed the -dev version of wxwidgets from your package manager?
10:10:42 <CBindahouse> Nope, I'll try that!
10:11:13 <spidermario> wxHaskell does not compile yet with ghc 7, does it?
10:12:18 <adorablepuppy> Right that's the problem for my example code. But I'm coding up a monadic form for some IO code I have. The IO code works in do notation, but doesn't work when I use >>=. So if I post that, maybe I can find out what is really wrong.
10:12:29 <adorablepuppy> whoops. sorry
10:14:55 <Jafet> @undo do { x <- foo; let bar = baz; return quux; }
10:14:55 <lambdabot>  Parse error at ";" (column 42)
10:15:13 <Jafet> @undo do { x <- foo; return bar; }
10:15:13 <lambdabot> foo >>= \ x -> return bar
10:15:45 <dmwit> @undo do { x <- foo; let bar = baz; return quux }
10:15:45 <lambdabot>  Parse error at "}" (column 43)
10:15:51 <dmwit> ah
10:15:57 <dmwit> @undo do { x <- foo; let { bar = baz } return quux }
10:15:57 <lambdabot>  Parse error at "retur..." (column 34)
10:16:02 <dmwit> @undo do { x <- foo; let { bar = baz }; return quux }
10:16:02 <lambdabot> foo >>= \ x -> let { bar = baz} in return quux
10:16:24 <dmwit> Looks like ?undo's parser isn't quite compliant.
10:16:32 <Jafet> Should have braced myself.
10:18:18 <CBindahouse> What's the best GUI library for haskell, does anybody know?
10:18:47 <dmwit> We have wx, gtk, and opengl; use the one you already know.
10:18:47 <conal> CBindahouse: what properties are you looking for?
10:19:12 <CBindahouse> Anything to create a simple GUI, and something that is easy enough to install and will run on Linux
10:19:44 <conal> CBindahouse: do you care about using ghci?
10:20:05 <monochrom> gtk2hs is the best gui library for haskell imo
10:20:11 <CBindahouse> conal: Well I'm using ghci to compile code at the moment
10:20:59 <CBindahouse> How do you install gtk2hs? I've had so many problems trying to...
10:21:26 <monochrom> on windows, it's a long story, but someone has documented it on some web page
10:21:38 <conal> CBindahouse: i prefer wxHaskell over gtk2hs for elegance of the interface (though still imperative). but currently the underlying wxWidgets kills ghci (any host process) the second time you open a GUI window.
10:21:39 <luite> on windows it's pretty easy nowadays
10:21:41 <dmwit> CBindahouse: "cabal install gtk" =)
10:22:04 <monochrom> on linux, "cabal install gtk2hs-buildtools" then ensure PATH has ~/.cabal/bin then "cabal install gtk2hs"
10:22:09 <conal> CBindahouse: so if ghci matters to you (it matters a lot to me), gtk2hs is probably the best you can do for now.
10:22:23 <CBindahouse> wicked, thanks a lot
10:22:24 <luite> monochrom: you only need to download a binary gtk package, extract it and add its bin dir to your %PATH
10:22:26 <monochrom> err, s/"cabal install gtk2hs"/"cabal install gtk"
10:22:32 <luite> monochrom: the rest is the same as linux
10:22:54 <dmwit> Oh, yes, I forgot gtk2hs-buildtools. Luckily, these days the error tells you what to do if you forgot that step. =)
10:22:59 <monochrom> please tell that to CBindahouse, since I don't want to know
10:23:03 <dmwit> ManateeLazyCat++
10:24:06 <dmwit> On Linux, you will still likely need the -dev version of gtk2 installed from your package manager, of course.
10:24:30 <conal> Wowâ€”foldMap composes nicely with itself.
10:24:43 <hpc> :t foldMap
10:24:44 <lambdabot> Not in scope: `foldMap'
10:24:49 <monochrom> I have a gtk2hs example program without explanation at http://www.vex.net/~trebla/haskell/gtk-interact.xhtml
10:25:34 <CBindahouse> monochrom: Thanks a lot!
10:25:35 <conal> foldMap âˆ· (Foldable f, Monoid m) â‡’ (a â†’ m) â†’ (f a â†’ m)
10:25:48 <monochrom> libgtk2.0-dev, libglade2-dev
10:26:54 <conal> the result type of foldMap matches the argument type (with different a), so it can be self-composed indefinitely. just like first, second, (.), fmap, liftA2, etc (semantic editor combinators).
10:27:31 <conal> foldMapâˆ˜foldMapâˆ˜foldMap âˆ· (Foldable f, Foldable g, Foldable h, Monoid m) â‡’ (a â†’ m) â†’ (h (g (f a)) â†’ m)
10:27:39 <ion> Oh, cool. âˆ· looks much better in my terminal than it used to ages ago. They probably added a glyph for it to something like DejaVu whereas a mismatched version was taken from something like Freefont in the past.
10:28:03 <ion> Now it looks just like two :s
10:28:20 * Eelis loves UnicodeSyntax
10:28:27 <ion> A slight difference in baseline height, though.
10:30:26 <Eelis> whenever i have to edit a Haskell source file that doesn't use UnicodeSyntax, i feel like a cave man when i have to do the ascii art to make the arrows and such
10:30:57 <conal> traverse self-composes similarly.
10:31:00 <monochrom> real cave men didn't restrict themselves to ascii art either
10:31:21 <hpc> haskell: so easy a caveman could do it
10:31:22 <Eelis> monochrom: a postmodernist caveman then
10:32:30 <monochrom> hehe
10:33:13 <ion> Itâ€™s a well-known historical fact cave men writing Haskell hated the ASCII pseudoglyphs.
10:33:17 <niteria> is there standard list of common abbreviations for 'standard' modules? like in import qualified Data.List as L
10:33:44 <monochrom> @remember ion Itâ€™s a well-known historical fact cave men writing Haskell hated the ASCII pseudoglyphs.
10:33:44 <lambdabot> Good to know.
10:34:46 <dmwit> niteria: Huh, no. You should start one.
10:35:22 <monochrom> there are "Data.Set as Set", "Data.Map as Map", and "Data.Bytestring* as BS". that is all.
10:36:15 <ion> I thought the BS import abbreviation was already established for Data.Bullshit.Lazy.
10:36:53 <monochrom> I have not seen anyone seriously doing "import qualified Data.List as whatever". just import Data.List and be done with it.
10:37:04 <Eelis> monochrom: i do it.
10:37:09 <dmwit> niteria: Well, there's lambdabot's list, anyway, with has Data.Set as S and Data.Map as M, and maybe others.
10:37:10 <niteria> that's just an example
10:37:22 <dmwit> s/with/which/
10:37:39 <niteria> I'll check it
10:37:51 <ion> With BS, the laziness isnâ€™t quite as binary as with other modules, though: http://en.wikipedia.org/wiki/File:Bristol_stool_chart.svg
10:38:36 <hpc> ion: uh...
10:41:01 <rothwell> would it have killed oleg to put previous designs in different files?
10:41:08 * rothwell mutters
10:42:28 <geekosaur> it could be argued that letting web.archive.org do it for him is the properly lazy solution :)
10:44:43 <danharaj> can anyone tell me the associativity of <$> and <*>?
10:44:59 <kmc> ghci can
10:45:00 <kmc> with :i
10:45:05 <danharaj> fair enough
10:45:19 <Botje> they're both left-associtive
10:46:11 * hackagebot cmdargs 0.6.9 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.9 (NeilMitchell)
10:46:15 <danharaj> ah so, a <$> b <*> c <*> d is ((a <$> b) <*> c) <*> d. Makes sense
10:46:18 <monochrom> ghc linking takes forever on freebsd
10:46:37 <deggis> my GPipe-Collada install fails with "Context reduction stack overflow; size = 21" any ideas on what that means? (using cabal-dev, ghc 7.0.3)
10:46:58 <monochrom> perhaps I should have just runghc'ed since this is just Setup.hs :)
10:47:17 <kmc> deggis, some type-class extensions would make the compiler potentially non-terminating
10:47:25 <kmc> GHC uses a fixed-size stack to prevent this
10:47:37 <kmc> you can increase the stack size, but it might indicate an infinite loop in the library's instances
10:49:15 <deggis> okay, hmm. there was another issue on google (with package: dimensional) that suffered from same issue with ghc703, but not with earlier
10:49:36 <kmc> perhaps they changed the default stack size
10:50:34 <deggis> that would explain it. luckily it's an alternative for me just to get older ghc for this project
10:50:36 <monochrom> then again, I nice'd it
10:50:51 <kmc> is that easier than increasing the limit?
10:51:00 <kmc> newer ghc is better in other ways
10:52:15 <deggis> ah that. actually, i don't know how to do that with cabal-dev. is it possible to pass flags for compiled libraries too?
10:52:16 <monochrom> see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/87524/ for undocumented stories about ghc stack size
10:52:53 <kmc> oh, i didn't know about cabal-dev.  looks useful
10:53:24 <monochrom> oh, "stack" size when type-checking type classes? then probably different story
10:53:32 <deggis> it is, but there's some things (flags) you can't pass as you could without it
10:54:26 <deggis> monochrom: hmm se of ghc 7.0.2 has default of 67, 7.0.3 has 21
10:55:00 <monochrom> fun. why do they keep changing the undocumented magic numbers? :)
10:57:13 * hackagebot hlint 1.8.8 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.8 (NeilMitchell)
11:04:23 <monochrom> so actually it is not freebsd or ghc freebsd version being slow. my files and ghc files are served over nfs, that is why every linker-intensive thing has to be slow
11:05:09 <kmc> any operation that involves lots of files will be slow
11:05:14 <kmc> unless those files are on a tmpfs
11:05:21 <monochrom> yeah, that's why, can't be helped
11:05:35 <kmc> hard drive latency and network latency are comparable
11:05:40 <monochrom> perhaps one day a gold linker for freebsd appears and it will help
11:06:18 <monochrom> it also doesn't help that I am so benevolent that I "nice" every build process :)
11:06:38 <kmc> haha
11:06:40 <kmc> shared server?
11:06:53 <monochrom> yes, this is a paid shell account
11:07:56 <monochrom> actually on my own laptop I nice build processes too, just To Insure Prompt Service of irc and firefox :)
11:08:45 <kmc> what OS do you use on your laptop?
11:08:50 <monochrom> linux
11:09:05 <burp> wasn't there this magic kernel patch latelyâ€¦
11:09:23 <kmc> the linux scheduler has some heuristics to discover whether a process is batch or interactive
11:09:25 <monochrom> I don't use the magic patch or any patch. I just use stock ubuntu.
11:09:49 <burp> ok, the magic patch is included in 2.6.38 I think 
11:09:53 <kmc> i don't know if they actually work
11:09:54 <monochrom> in fact going all the way back to many original unix schedulers, they all do.
11:10:10 <parcs> freebsd also uses an old-as-hell linker, which may contribute to the slowness
11:10:11 <kmc> burp, are you talking about the per-terminal process grouping?
11:10:15 <burp> kmc: yes
11:10:23 <kmc> is that in the kernel now?
11:10:27 <burp> yes
11:10:40 <kmc> i thought there was some wanking that it should be done in userspace via cgroups instead
11:12:01 <kmc> i'm excited about the VFS improvements in 2.6.38
11:12:12 <burp> no, linus has included it in 2.6.38
11:12:15 <kmc> cool
11:12:26 <burp> http://www.phoronix.com/scan.php?page=news_item&px=OTAyNw
11:12:37 * TTimo patched bfs into his 2.6.38 this am
11:12:56 <burp> hehe, I used to use bfs too
11:15:19 <jmcarthur> blog post http://creativelad.wordpress.com/2011/04/03/dctp-model/
11:17:55 <monochrom> looks interesting
11:18:00 <danharaj> I need to decide an an error-handling scheme for my opengl program. I know there's a bunch of ways to do it... any overview on the various methods? (Either, Maybe, IO errors, etc.)
11:18:31 <kmc> errors that happen during the imperative talking-to-OpenGL part?
11:18:55 <danharaj> kmc: Mostly yes, but I'd like to consider a scheme that allows me to extend that to errors in other parts of my program uniformly.
11:19:30 <kmc> you can mostly adapt between these schemes
11:19:46 <kmc> i'd probably start with Control.Exception stuff, for simplicity
11:20:09 <danharaj> kmc: ok. I have to also figure out how much error handling I want to do. All this flimsy imperative code can pretty much fail at any point with no static guarantees :p
11:20:42 <hpc> danharaj: use Maybe when all you need is "did i fail", use Either when you need to know how you failed, and use IO when you are... doing IO
11:20:42 <Layla_91> Hi all o/
11:21:06 <kmc> but you can also do Â«ErrorT MyErrorType IO xÂ»
11:22:30 <Layla_91> so.. erm.. I started learning haskell couple of weeks ago.. I was very interested in it.. but everybody I know keeps telling me I should invest my time in other languages.. :\ and they have few strong arguments that confuses me a bit :(
11:22:51 <danharaj> Layla_91: What are their arguments?
11:24:05 <Layla_91> danharaj: ok here is one I heard few days ago: it is only used in researches but not in practical life.. if it was that good it would have get famous like python and perl..
11:24:24 <kmc> it is used for some practical stuff
11:24:37 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
11:24:47 <kmc> facebook, google, finance companies, government consulting
11:24:50 <hpc> Layla_91: http://hpc.dyndns-web.com:8000/
11:24:59 <hpc> Layla_91: blog in haskell; it's about 500 lines
11:25:01 <Eduard_Munteanu> Layla_91: do you know any other languages?
11:25:15 <Layla_91> Eduard_Munteanu: I know php, perl and c++
11:25:27 <dmwit> I think the best way to counter that argument is to simply say, "It's not popular because it's not popular.".
11:25:37 <dmwit> Popularity isn't a good metric of quality.
11:25:40 <Eduard_Munteanu> I don't think Haskell is a bad idea then.
11:25:45 <kmc> "good" and "popular" are rarely correlated
11:25:55 <danharaj> Friday! It's Friday!
11:26:05 <kmc> anyway if your goal is just to make some website or whatever, it's probably not worth learning haskell just to do that
11:26:08 <danharaj> We so excited.
11:26:12 <djahandarie> danharaj, no, it's Sunday.
11:26:13 <mm_freak> since some update i have to give my cabal username and password everytime
11:26:17 * hackagebot netlines 0.4.3 - Enumerator tools for text-based network protocols  http://hackage.haskell.org/package/netlines-0.4.3 (ErtugrulSoeylemez)
11:26:17 <mm_freak> how do i solve this?
11:26:17 <djahandarie> And we are not excited.
11:26:18 <dancor> is (Either a a) more elite than (Bool, a)
11:26:25 <kmc> learn haskell if you want to learn a new way of thinking, understand programming at a more fundamental level, and become a better programmer in every language
11:26:32 <danharaj> djahandarie: You gotta have your cereal gotta have your bowl.
11:27:05 <Eduard_Munteanu> Don't tell me it's about that stupid song :)
11:27:07 <hpc> danharaj: they have different bottoms; (Bool, a) is not considered an idomatic way to fail
11:27:17 <dancor> hpc: ah
11:27:21 <danharaj> I did not ask that question :p
11:27:50 <hpc> oh lol
11:27:53 <mm_freak> Layla_91: i remember telling you that i use haskell for commercial, rapid web development as well as for high performance server software
11:28:06 <mm_freak> Layla_91: even though last time you had "93" instead of "91" =)
11:29:01 <mm_freak> Layla_91: and as others noted, haskell allows you to think in new ways even in other languages, but if you learn haskell and have the opportunity, you should use it
11:29:12 <mm_freak> it doesn't make sense to learn something great not to use it
11:29:54 <mm_freak> on hackage you may also find that i released quite a few high performance networking libraries, which i use for commercial applications and wanted to share with the community
11:30:01 <mm_freak> ok, there she goes =)
11:30:21 <mm_freak> anyway, has something changed in cabal?  my username and password in the configuration file are ignored
11:30:29 <Layla_91> sorry got disconnected :S
11:30:59 <Layla_91> I hope I did not miss a lot!
11:31:15 <hpc> 14:35 < mm_freak> Layla_91: i remember telling you that i use haskell for commercial, rapid web development as well as for high performance server software
11:31:18 <hpc> 14:35 < mm_freak> Layla_91: even though last time you had "93" instead of "91" =)
11:31:22 <mm_freak> Layla_91: http://hpaste.org/45258/log
11:32:38 <Layla_91> hpc: my actual birth year is 93 but I am as wise as a 30 year old girl B-)
11:32:56 <lispy> How do we spell calloc in Haskell?
11:33:06 <lispy> I only see realloc, alloca, and malloc variants
11:33:07 <Layla_91> hpc: ops that was for mm_freak 
11:33:24 <frerich> Hm, what does 'to lift' usually mean in Haskell lingo? I just read ' 'zipWith' takes a function of two parameters, and lifts it over a list.', and I know what zipWith does, but I never heard 'lift' in this sense (I only hear it when talking about monads).
11:33:27 <lispy> So I guess it's something that still needs to be written?
11:33:28 <sipa> lispy: what do you need calloc for?
11:33:45 <Layla_91> mm_freak: but why popularity is not important or a measure? :S
11:33:46 <mm_freak> lispy: there are array functions for allocation
11:33:54 <lispy> sipa: my freetype2 binding.  I just noticed the official api docs for freetype2 said that they assume you use calloc instead of malloc.
11:34:13 <mm_freak> Layla_91: because if that were a measure, we all had to use windows, oracle and internet explorer
11:34:30 <sipa> lispy: the only difference is that calloc guarantees the memory is initialized to zero
11:34:33 <Botje> frerich: 'lifting' is generally an operation that makes a simple function work in a more advanced context
11:34:37 <lispy> Yeah, it sounds like I need to write a MissingForeign.Alloc module
11:34:44 <Botje> frerich: eg map lifts functions a -> b to functions [a] -> [b]
11:34:46 <lispy> sipa: right, and they seem to rely on that
11:34:49 <Layla_91> mm_freak: that is great answer! :D
11:35:00 <frerich> Botje: So every higher-order function lifts some other function?
11:35:14 <dmwit> frerich: "lift" is used in math all the time, though I've never seen a precise definition of it. Generally, it means to take an operation on some small kind of structure, and mechanically turn it into something that works in a larger, more all-encompassing structure.
11:35:38 <hpc> :t lift
11:35:39 <lambdabot>     Ambiguous occurrence `lift'
11:35:39 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
11:35:39 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
11:35:48 <hpc> :t Control.Monad.Error.lift
11:35:49 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
11:35:52 <hpc> example of a lift
11:36:00 <mm_freak> one of my favorite quotes is:  "In business, there is nothing more valuable than a technical advantage your competitors don't understand."
11:36:10 <Botje> frerich: not really. a chess engine might use higher order functions to make the engine pluggable, but that doesn't mean they get lifted
11:36:26 <Layla_91> mm_freak: they also say it will make me get worse in php and other languages if I focus on haskell since it is different. is that ture?
11:36:56 <Layla_91> mm_freak: I always thought that learning more languages is better...
11:37:18 <mm_freak> Layla_91: no, it does not make you worseâ€¦  but it makes you program in new ways, which your colleagues may not understand
11:37:26 <sipa> lispy: so you can probably write a calloc very easily using Foreign.Alloc.malloc + Data.ByteString.Internal.memset
11:37:34 <mm_freak> Layla_91: i constantly find myself trying to implement haskell concepts in PHP
11:37:37 <hpc> Layla_91: it's an upside-down bell curve, if it indeed makes you worse at all
11:38:06 <hpc> you get a bit worse for a while, then suddenly you know a whole lot
11:38:11 <ion> Learning new ways to think only makes you better in any language you use. Saying itâ€™ll make you worse makes absolutely no sense whatsoever.
11:38:15 <lispy> sipa: There are cleaner ways I think using copyByte/moveBytes.  I just wanted to know if we had something already. I guess we don't so i'm starting a package 'missing-foreign'
11:38:25 <sipa> :)
11:38:26 <hpc> at least, while you are kicking old habits
11:38:40 <Layla_91> mm_freak: so when I finish colleage and find work and join a team they may do not get my code in other languages? :O
11:39:00 <hpc> ion: losing old habits will make you worse for a while, because your usual approach will be uncomfortable
11:39:19 <hpc> but that's nothing a little more learning won't fix :P
11:40:08 <mm_freak> Layla_91: if you lose control, yes, but in general in companies you have coding standards
11:40:20 <mm_freak> so your getting out of control is limited =)
11:41:03 <ion> I do find myself thinking â€œhow to make this pointlessâ€ and getting slightly frustrated when realizing immediately â€œno currying here, you canâ€™tâ€ in Ruby but i havenâ€™t found myself losing any of the old ways to do stuff if the Haskell ways donâ€™t apply.
11:41:18 <Layla_91> mm_freak: good =) well.. I am not sure I will go into IT since I am thinking of studying maths too.. but I should be ready for all options ^_^
11:42:19 * hackagebot ihttp 0.2.1 - Incremental HTTP iteratee  http://hackage.haskell.org/package/ihttp-0.2.1 (ErtugrulSoeylemez)
11:42:31 <mm_freak> Layla_91: haskell forces you to think mathematically
11:42:31 <Layla_91> mm_freak: another thing is that the learning curve is so bad for me :S Remember when I told you I will learn it in days? it is NOT WORKING! :D
11:42:33 <ceii> Layla_91, if you study maths then knowing Haskell will make you a _much_ better mathematician
11:42:36 <mm_freak> to some degree at least
11:42:47 <Layla_91> mm_freak: oh great :D
11:42:52 <mm_freak> Layla_91: yes, people told you that ;)
11:43:05 <mm_freak> you wanted to learn it in one weekend ;)
11:43:19 <Layla_91> mm_freak: now I understand why it was funny :P
11:43:20 <mm_freak> you never stop learning haskellâ€¦  it's an ongoing process, unlike in other languages
11:43:21 * hackagebot ismtp 3.0.1 - Advanced ESMTP library  http://hackage.haskell.org/package/ismtp-3.0.1 (ErtugrulSoeylemez)
11:43:48 <akahn> ion: hehe, totally, Symbol#to_proc only takes you so far ;)
11:44:06 <mm_freak> you also never stop learning math
11:44:31 <Layla_91> mm_freak: agree... mm.. It will be a great mix.. math and haskell :) I will have a lot of fun! :D
11:44:44 <lispy> sipa: actually, we have this: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/src/Foreign-Marshal-Utils.html#new
11:44:59 <lispy> pretty similar
11:45:45 <Layla_91> ok should go now.. bye =)
11:46:12 <mm_freak> bye, Layla_91 
11:46:22 <sipa> lispy: won't work for larger things, i suppose
11:46:24 <mm_freak> how do i subscribe to -general?
11:46:37 <sipa> you need to have something of the actual size of what you're allocating
11:46:41 <sipa> in the haskell side
11:47:47 <mm_freak> found it
11:48:52 <mm_freak> hmmâ€¦  i'm using gmane, so i'd rather not subscribe to the haskell MLâ€¦  or can i subscribe without receiving mails?
11:50:29 <hpc> you can get digests
11:50:42 <hpc> it's one or two emails a day
11:50:57 <byorgey> http://byorgey.wordpress.com/2011/04/03/call-for-contributions-second-edition-of-the-typeclassopedia/
11:53:22 <Ptival> subscribing to a mailing-list without receiving the mails? :D
11:54:11 <hpc> a write-only subscription ;)
11:54:21 <hpc> ask question: never get answer
11:54:29 <hpc> s/:/;/
11:55:16 <Ptival> you don't put a space before ";" in English?
11:55:43 <hpc> nope; it's just like a period, only you don't capitalize the first letter after it
11:55:44 <jmcarthur> nope
11:55:45 <Ptival> (do I really need #haskell to figure this out?)
11:55:51 <Ptival> ok
11:55:53 <hpc> it is the most feared punctuation on earth :P
11:56:00 <jmcarthur> it is?
11:56:11 <hpc> http://theoatmeal.com/comics/semicolon
11:56:34 <hpc> this should be in -blah <.<
11:59:12 <hpc> byorgey: gonna read through typeclassopedia and come up with some comments; ill email you in a few hours, if i don't distract myself with the stuff i should be doing instead
11:59:23 <byorgey> hpc: ok =)
11:59:32 <byorgey> there's plenty of time
12:00:26 <djahandarie> I think edwardk is planning on doing some typeclassopedia-type thing including his new libraries
12:00:59 <hpc> ooh, yes
12:01:13 <hpc> include the category-extras stuff :D
12:01:31 <hpc> or whatever the package names are now
12:01:46 <byorgey> indeed, I will probably help him with it
12:02:20 <djahandarie> copumpkin, what was your Agda syntax hilighter written in?
12:02:29 <copumpkin> haskell, using the agda library :)
12:02:43 <djahandarie> Is that online anywhere?
12:02:49 <copumpkin> yeah, on my github
12:02:59 <copumpkin> it's horrible and hardcoded to my path layout right now
12:03:04 <copumpkin> but you should be able to make sense of it, maybe
12:03:12 <copumpkin> assuming those parts of the agda library haven't changed
12:04:01 <djahandarie> lol
12:04:30 <djahandarie> Some people on twitter are trying to figure out if there is an Agda syntax highlighter
12:04:43 <copumpkin> it comes with one built in
12:04:48 <copumpkin> but it produces super hyperlinked html
12:04:58 <djahandarie> Doesn't it also involve typechecking the whole program?
12:05:02 <copumpkin> and you don't really have any control of it
12:05:09 <copumpkin> yeah, precise agda highlighting requires typechecking
12:05:12 <hpc> vim doesn't highlight agda syntax :(
12:05:23 <copumpkin> mine does too, but it's not hard to make it not typecheck first
12:05:30 <copumpkin> I can't remember how though
12:07:25 <copumpkin> https://github.com/pumpkin/agda-highlight
12:07:39 <copumpkin> note that I support > literate agda syntax
12:07:44 <copumpkin> (I actually preprocess it)
12:08:09 <copumpkin> https://github.com/pumpkin/agda-highlight/blob/master/Test.lagda is the source code to that page I keep linking to
12:13:07 <Zeno_> Hi all, I'm a Haskell noob looking for some help getting SDL working with Haskell. Other than installing the libSDL wrapper with Cabal, do I need to do anything to tell GHC about the library?
12:13:49 <hpc> Zeno_: don't think so; try compiling it normally and see what happens
12:14:01 <hpc> ("it" == your program)
12:14:07 <Saizan> remember to use --make when you build your program
12:15:01 <Zeno_> Thanks hpc and Saizan, I'll try that. Just to understand, if I'm setting a --make flag, do I need a makefile also?
12:15:34 <Eelis> hpc: what is the relation (if any) between you and the hpc package on Hackage?
12:15:46 <hpc> Eelis: nothing :D
12:15:51 <Eelis> hpc: ok, thank you
12:15:56 <hpc> my nick means a totally different thing
12:17:34 <Saizan> Zeno_: no
12:17:48 <Zeno_> Okay cool, thanks Saizan.
12:18:54 <wires> I sometimes get the impression that there are extentions to haskell that introduce dependent types? it this the case?
12:19:15 <opqdonut> no
12:19:27 <jmcarthur> wires: there are ways to simulate dependent types using some existing ghc extensions, to some extent
12:19:40 <wires> I mean.. looking at all those packages by edward kmett, can you do that in "standard" haskell ?
12:19:42 <jmcarthur> but there are no extensions directly providing DT
12:20:26 <wires> ok, thanks
12:20:36 <copumpkin> GADTs give you some DT-like behavior
12:20:37 <copumpkin> but not much
12:20:55 <hpc> copumpkin: it does give DT behavior! (also GA behavior :P)
12:21:03 * hpc unhelps
12:21:10 <Saizan> which packages by edwardk would need DT?
12:21:47 <opqdonut> jmcarthur: what do you mean by simulating dt?
12:22:33 <wires> Saizan: It's just a hunch, I haven't looked in details, it just seems that even expressing some things would require DT
12:23:11 <wires> I assumed he would be proving things as well, but it's all speculation... :D
12:23:17 <copumpkin> nah, he isn't
12:23:59 <wires> ok
12:25:01 <copumpkin> I plan to eventually build a lot of what he has in category-extras and prove it correct
12:28:35 <rcl> If I use GHC via FFI, my main program in C, invoking haskell code as a library - what is the licensing impact?  Is it safe for me to statically link against this
12:28:45 <rostayob> I'm trying to generate a link to a class in haddock, but 'Class' does not work
12:28:52 <rostayob> and 'Module.Class' doesn't work eithr
12:30:25 * hackagebot Etage 0.1.8 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.8 (MitarMilutinovic)
12:31:25 * hackagebot Etage-Graph 0.1 - Data-flow based graph algorithms  http://hackage.haskell.org/package/Etage-Graph-0.1 (MitarMilutinovic)
12:31:59 <tswett> Do GHC's standard libraries come with the extended Euclidean algorithm?
12:32:09 <quantum> no
12:34:38 <lispy> how do I tell cabal to build haddocks?
12:34:51 <lispy> I don't see anything relevant on 'cabal configure --help'
12:35:03 <dcoutts_> cabal haddock
12:35:18 <copumpkin> lispy: there's also a flag in config iirc
12:35:23 <copumpkin> if you always want them
12:35:45 <lispy> copumpkin: I don't see it in the config :(
12:35:47 <lispy> dcoutts_: thanks
12:36:04 <copumpkin> -- documentation: False
12:36:13 <dcoutts_> copumpkin: there's a --enable-documentation flag for install
12:36:39 <copumpkin> dcoutts_: the one I just pasted doesn't work?
12:36:39 <lispy> oh geez.  I was searching for haddock.
12:36:50 <dcoutts_> which is what the documentation: True/False item in the ~/.cabal/config is equivalent to
12:36:51 <Zeno_> Had trouble installing SDL with Cabal, here's the command-line output (from Cygwin, though XP command line pretty much the same): http://pastebin.com/TGj6YziB Any ideas what I need to change to get this working?
12:36:59 <copumpkin> dcoutts_: ah okay
12:37:23 <dcoutts_> lispy: yes, it's inconsistent, I'm trying to move from just haddock to more general docs
12:39:23 <lispy> what does this mean?
12:39:23 <lispy> Running Haddock for missing-foreign-0.1.0...
12:39:24 <lispy> cabal:
12:41:25 <lispy> hrmph. I rm -rf'd a few things and now it haddocks.  Weird
12:43:21 <monochrom> tswett: I have extended euclidean at http://www.vex.net/~trebla/haskell/calculator/Calculator.hs
12:43:47 <tswett> monochrom: neat.  Thank you.
12:44:41 <lispy> next question.  How do I put a bulleted list in the description section of a .cabal file?
12:44:54 <Saizan> "If you don't understand monads, you aren't yet ready to write a Haskell compiler." <- who would've thought?
12:44:59 <lispy> I tried putting, "* item" on a line by itself
12:45:07 <lispy> But, in the html version it wraps that to the previous line
12:45:53 <lispy> oh, you have to put a . between them
12:47:41 <dcoutts_> lispy: the . thing is a bonkers hangover from the original .cabal file syntax
12:47:46 * dcoutts_ plans to eliminate it
12:48:27 <lispy> dcoutts_: well, that's not even that weird.  What was weird was that I had to put a . between the list items.
12:48:28 * hackagebot missing-foreign 0.1.0 - Convenience functions for FFI work  http://hackage.haskell.org/package/missing-foreign-0.1.0 (JasonDagit)
12:48:50 <lispy> dcoutts_: http://hackage.haskell.org/packages/archive/missing-foreign/0.1.0/missing-foreign.cabal
12:49:41 <lispy> now that I have my stop-gap version, I need to submit patches to base I suppose
12:57:18 <dcoutts_> lispy: actually the . between lines makes sense once you realise the layering
12:57:41 <dcoutts_> lispy: the . is the escape for blank lines in the fields in a .cabal file
12:58:00 <dcoutts_> lispy: and haddock requires lines between * bullet entries
12:58:06 <lispy> oh
12:58:12 <lispy> I didn't realize haddock required that
13:07:12 <sshc> What are the advantages of using monads-tf instead of mtl?
13:10:31 * hackagebot bytestring-progress 1.0.0 - A library for tracking the consumption of a lazy ByteString  http://hackage.haskell.org/package/bytestring-progress-1.0.0 (AdamWick)
13:11:42 <sshc> Is anybody aware of a more elegant solution than lifting with "lift" for BarState when using multiple State's in one stack with different StateTypes (One is FooState, other is BarState; BarState is more innerward than FooState, so the MonadState instance applies only to FooState)?
13:12:07 <hpc> State (Foo, Bar) a?
13:13:09 <kevinburke> Hi, I'm struggling with my code - a few small parts require monads and now I feel like I have to rewirte the whole thing to use monads.
13:13:31 <kevinburke> Any time I touch the unsafe data I have to return a monad
13:14:00 <Botje> that's what they do, yah
13:14:37 <sshc> hpc: I don't know what you're trying to imply, but I have a stack that we can say looks like "StateT FooState (State BarState)"
13:15:05 <hpc> sshc: i mean instead of nesting states, use a tuple
13:15:41 <sshc> hpc: Oh, hmm.  I haven't thought of that.  That is an interesting idea.
13:16:10 <sshc> hpc: But I doubt it'd be much better than even lifting when I'm managing more than 2 states
13:17:10 <parcs> in that case you can use a custom record as a state to minimize the syntactic overhead
13:17:14 <jmcarthur> sshc: the idea is generally to make newtype wrappers for each level of abstraction anyway, so you shouldn't really end up with multiple StateTs in the same stack without having a way to access each of them uniquely
13:17:46 <jmcarthur> s/for each level of/for each/
13:18:08 <sshc> jmcarthur: What do you mean by "abstraction"?
13:18:08 <jmcarthur> and if multiple states belong in the same abstraction, you can just use one using hpc's suggestion
13:18:30 <jmcarthur> i mean modular programming, basically
13:18:50 <hpc> also, data QuuxState = Q {foo :: Foo, bar :: Bar}
13:18:59 <hpc> and State QuuxState a
13:19:08 <hpc> then you an add extra "states" trivially
13:22:17 <sshc> hpc, jmcarthur: 'FooState' and 'BarState' are sufficiently distinct (and deeply hierarchical) states that are usually modified seperately and individually in some modules, but occasionally some actions use both.  I suppose a similar example would be having a "State RandomGen" and a "State GameState", where GameState is deeply hierachical state in the same stack.
13:23:12 <sshc> hpc, jmcarthur: My point is that the States are distinct concepts
13:23:33 * hackagebot SHA 1.5.0.0 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.5.0.0 (AdamWick)
13:23:39 <hpc> sshc: one single uberstate is idiomatic for games; google "scene graph"
13:23:52 <Zao> hpc: Also, idiotic.
13:23:55 <hpc> haha
13:26:45 <sshc> hpc: Maybe one of the states is not necessarily state for a game.
13:27:16 <sshc> hpc: I'm looking for a clean means of managing multiple, distinct States.
13:30:23 <sshc> hpc: Defining and exporting a type for each unique combination of States doesn't seem clean to me.
13:33:36 <kevinburke> any advice for when the code you're writing is really ugly, but you're up against a deadline and you don't have time to learn better?
13:34:44 <sshc> hpc: Using tuples solves *that* problem, but it's not very nice to have to restructure the definition whenever additional states are added or removed, and having to access one part uniquely instead of generalizing it polymorphically can be a pain.  I mean changing State b in (a, b, c).
13:36:02 <copumpkin> kevinburke: get the shit done sooner, in future :P
13:36:27 <copumpkin> kevinburke: otherwise, shit into your text editor, get it done, then go back and figure out how to make it cleaner when you have more time (as long as that actually happens)
13:37:02 <sshc> hpc: What I think I might be looking for is changing state based on the type.  For example, "modify (f :: FooState -> FooState)" and "modify (succ :: Integer -> Integer)", where f changes the FooState state, and succ changes the Integer state (as an example; I'm aware that the Integer part contradicts what I said earlier about distinct States)
13:37:29 <sshc> hpc: And that almost works with MonadState, but only for the outermost State, even if that outermost State isn't the outermost layer of the state.
13:37:34 <sshc> layer of the stack.
13:37:47 <sshc> hpc: Am I missing something?  I notice that tends to be the case when others stop responding to me.
13:38:07 <Taslem_> Why is it that every time I go to Haskell.org my computer freezes?
13:38:26 <copumpkin> Taslem_: Ask your browser
13:38:33 <quantum> Haskell.org is not for everyone
13:41:59 <sshc> Anyway, the question still stands: I'm looking for a way to polymorphically manage multiple states.  MonadState only allows this to the extend of a single State.  If I have a stack of States that includes "FooState" and "Integer", I want to be able to have "modify (f :: FooState -> FooState)" and "modify (succ :: Integer -> Integer)" both as actions in the same monad.  The former would work,
13:42:06 <sshc> because "FooState" is the outermost state.  But the latter state, Integer, does not work, because MonadState only enables the outermost state to be changed.  Does anybody know any solutions?
13:42:18 <overscore> ask your system administrator
13:42:22 <overscore> (lol)
13:42:36 <c_wraith> There was some research done in this area, I recall.
13:42:50 <c_wraith> Something like MonadState that was type-sensitive
13:43:25 <c_wraith> But even it couldn't handle two layers that had the same state type
13:43:45 * hackagebot language-javascript 0.4.4 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.4.4 (AlanZimmerman)
13:43:47 <sshc> c_wraith: That's fine, I don't need it to
13:43:55 <sshc> c_wraith: Regardless, it's still a significant improvement
13:44:02 <sshc> c_wraith: Do you have any more information??
13:44:30 <sshc> c_wraith: Are there any implementations of a type-sensitive MonadState class?
13:44:39 <sshc> c_wraith: Who / where is the research?
13:45:17 <c_wraith> I just remember it had been mentioned in this channel once.  nothign else about it
13:45:26 <kevinburke> :s/=/<-
13:47:02 <sipa> i believe monatron has that
13:47:07 <sshc> c_wraith: Mm, that's unfortunate.  I'll try doing some searching for it myself.  After I don't find anything, I'll probably try an implementation myself.
13:47:42 <sipa> sshc: http://hackage.haskell.org/package/Monatron
13:47:49 <sipa> but it's not compatible with mtl
13:48:46 <sshc> sipa: Thanks!
13:49:03 <sshc> sipa: I was never aware of that.
13:49:18 <sshc> sipa: At first glance, it seems rather esoteric and generally unknown
13:49:45 <sshc> sipa: After I look into it, I might consider a monads-tf replacement with type-sensitive lifting
13:53:57 <sipa> sshc: we have a program that's using a few dozen monad transformers on top of eachother using it :)
13:55:40 <thoughtpolice> sshc: here's tom's paper that goes w/ monatron and 'the monad zipper' - http://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/monad_zipper_draft.pdf
13:56:08 <thoughtpolice> also, http://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/ifl2010.pdf apparently deals with it too
13:58:47 * hackagebot missing-foreign 0.1.1 - Convenience functions for FFI work  http://hackage.haskell.org/package/missing-foreign-0.1.1 (JasonDagit)
14:00:48 * hackagebot hjsmin 0.0.14 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.14 (AlanZimmerman)
14:05:11 <illissius> "once again posted to the cafe, because the Haskell mailing list rejects my mails" -- there's also a 'vanilla' haskell mailing list? :o
14:05:31 <thoughtpolice> illissius: haskell@haskell.org is only for announcements and is low traffic
14:07:55 <illissius> oh hey, i'm actually subscribed to it, just never noticed
14:09:02 <illissius> (have all the haskell related lists under the same 'haskell' label in gmail, and for some reason had been assuming everything that wasn't cvs-ghc was -cafe)
14:12:49 <tswett> So, I just watched a little lecture about monads in category theory.  I understand Haskell's well enough, but I also want to understand category theory.
14:13:34 <tswett> She gave the definition of a monad: it's a functor equipped with the natural transformations eta (Haskell's return) and mu (Haskell's join).
14:14:05 <tswett> The example of a monad that she gave was the monad for monoids, which, it turns out, is the list monad.
14:14:19 <hpc> cool
14:15:13 <tswett> The category is the category of sets (or, in Haskell, types), the functor is [], and the natural transformations eta and mu are (\x -> [x]) and concat.
14:15:16 <copumpkin> tswett: ##categorytheory is a fun place to be, by the way :)
14:15:27 <tswett> Yes, maybe I should be there.  :)
14:15:40 <copumpkin> not that it's off-topic in here
14:16:12 <tswett> Of course, my category theory knowledge has holes in it.  What does it mean that (\x -> [x]) and concat are natural transformations?
14:16:26 <copumpkin> have you seen the general definition of a natural transformation?
14:16:36 <tswett> I've seen it, but I don't remember it.  :P
14:16:48 <copumpkin> in haskell, it'd look something like type NatTrans f g = forall a. f a -> g a
14:17:16 <copumpkin> so they roughly correspond to polymorphic functions (not all of them) in haskell
14:17:19 <tswett> Actually, let me see if I can reconstruct it.
14:18:05 <copumpkin> sure
14:18:15 <tswett> A natural transformation from a functor F to a function G takes each object in F's image to an object in G's image such that applying F and then the transformation is the same as applying G?
14:18:37 <tswett> That definition matches the picture I saw.  :P
14:18:44 <tswett> Or, the picture I remember, which is probably missing some lines.
14:18:52 <lispy> copumpkin: So, should I upload my raw freetype binding as freetype2-raw and then have a separate thing on hackage for the haskell-ish interface?
14:18:54 <copumpkin> not quite
14:18:59 <lispy> copumpkin: or should I put both in the same package?
14:19:07 <copumpkin> I'd put both in same package
14:19:09 <tswett> (I think in terms of line drawings.  :P)
14:19:10 <copumpkin> unless it's getting huge
14:19:36 <copumpkin> tswett: a natural transformation takes every object in C to a morphism in D
14:19:40 <lispy> copumpkin: I don't have a sense for what the Haskell-ish version will be like, but I'm worried that it may need things like monad transformers.  and those get to be a pain.
14:19:47 <copumpkin> where C and D are the domain and codomain of the two functors
14:19:56 <lispy> also, the haskell-ish version might end up with quickcheck tests
14:20:04 <copumpkin> lispy: hmm
14:20:04 <tswett> C is the domain and D is the codomain?  Those initials don't match.  :)
14:20:12 <copumpkin> lispy: quickcheck should be a cabal flag
14:20:13 <hpc> tswett: haha
14:20:20 <copumpkin> tswett: lol, yeah, I guess not
14:20:24 <lispy> copumpkin: oh true
14:20:37 <copumpkin> lispy: or use the new cabal test!
14:20:45 <lispy> copumpkin: okay.  I'll do it as one package for now and if I later need a "raw" variant it's not too hard to just split the package a la opengl
14:20:50 <copumpkin> sure
14:21:08 <copumpkin> but having two smaller packages to begin with can't hurt either, really
14:21:29 <tswett> So a natural transformation from Id to []... those are both functors * -> *, so it takes every object in * to a morphism in *.
14:21:31 <copumpkin> so that people who prefer a low-level interface don't need to get too much baggage (doesn't really cost anything, but still puts people off)
14:21:43 <tswett> So for every type, you get a morphism in *, which is a function.
14:22:08 <copumpkin>     Î· : (X : C.Obj) â†’ D.Hom (Fâ‚€ X) (Gâ‚€ X)
14:22:22 <copumpkin> yeah
14:22:29 <copumpkin> and that's what my type synonym above is saying
14:22:36 <copumpkin> forall a. f a -> g a
14:22:48 * tswett nods.
14:23:04 <copumpkin> :t \(Identity x) -> [x]
14:23:05 <lambdabot> forall t. Identity t -> [t]
14:23:17 <tswett> Okay.  So there's some property that this function has to satisfy, right?
14:23:20 <copumpkin> yep
14:23:26 <copumpkin> in haskell you kind of get that for free
14:23:34 <tswett> The "return" function for [] can't have the type Integer -> Bool.
14:23:47 <tswett> Is it still called Bool, or are they calling it Boolean these days...
14:23:49 <tswett> @type True
14:23:50 <lambdabot> Bool
14:24:01 <copumpkin> it's Bool :)
14:24:10 <copumpkin> but the law basically says that if you fmap before or after, it should be the same
14:24:14 <tswett> You may be able to tell that I don't actually use Haskell that often.  :P
14:24:28 <copumpkin> @free x :: forall t. Identity t -> [t]
14:24:28 <lambdabot> $map f . x = x . $map_Identity f
14:25:05 <copumpkin> i.e., the natural transformation should not do anything evil
14:25:29 <tswett> Wait.  So we're given two functors F, G : C -> D, and we're speaking of a natural transformation from F to G, which is a function from... what to what, again?
14:25:51 <copumpkin> a function from F a -> G a, for all a
14:25:55 <copumpkin> :t listToMaybe
14:25:56 <lambdabot> forall a. [a] -> Maybe a
14:26:03 <copumpkin> :t maybeToList
14:26:03 <lambdabot> forall a. Maybe a -> [a]
14:26:23 <copumpkin> if I map (+1) on the list before calling that, it's equivalent to me fmap (+1) on the maybe that came out of it
14:26:28 <copumpkin> same with the reverse function
14:26:32 <copumpkin> both of those are natural transformations
14:26:33 <tswett> A function C -> (F D -> G D), to overload notation?
14:26:39 <copumpkin> yeah
14:26:44 <copumpkin> oh wait
14:26:45 <copumpkin> not D
14:26:46 <frerich> Is there a way to ensure that instances of a type class adhere certain laws (which, in my case, can also be expressed nicely in Haskell)?
14:27:13 <copumpkin> tswett: it's sort of a dependent function, which you get in a sense with forall
14:27:23 <copumpkin> (x : C) -> (F x -> G x)
14:27:55 <copumpkin> (x : *) -> ([x] -> Maybe x)
14:28:02 <tswett> Okay.  Two functors F, G : C -> D, and a natural transformation from F to G is a function (x : C) -> (F x -> G x), where that latter arrow represents morphisms, not functions.
14:28:13 <copumpkin> yeah, but in haskell those are the same thing
14:28:29 <tswett> And you're giving me a natural transformation from [] to Maybe, the function listToMaybe.
14:28:59 <xcvii> hey, i'm trying to do some low level IO with Data.Binary, and it turns out i need the number of bytes written in a Put's do block. is there a way to determine it?
14:29:03 <benmachine> copumpkin: is it interesting that there are multiple possible natural transformations maybe -> list?
14:29:17 <tswett> And the law is that fmap f (listToMaybe x) = listToMaybe (fmap f x)?
14:30:21 * tswett thinks about what a functor is made of again.
14:31:25 <Eduard_Munteanu> frerich: not really
14:31:46 <tswett> What's a functor made of, again?  :P
14:32:00 <dolio> Cotton candy.
14:32:10 <benmachine> frerich: put them in the docs and cross your fingers ^_^
14:32:19 <tswett> Okay, it's... it's essentially a homomorphism from one category to another, isn't it?
14:32:33 <dolio> Yes.
14:33:59 <tswett> So a functor C -> D maps objects in C to objects in D and arrows in C to arrows in D.  Like how [] maps Integer to [Integer] and (+1) to fmap (+1).
14:34:14 <path[l]> hmm
14:34:19 <dolio> Yes.
14:34:19 <path[l]> whats that smiley
14:34:23 <path[l]> after cross your fingers
14:35:00 <Botje> japanese-style smiley
14:35:06 <Botje> the trick is to not turn your head :)
14:35:25 <path[l]> no I mean, my irc client is changing it to a head
14:35:33 <path[l]> can you type it out space seperated please?
14:35:38 <Botje> ^ _ ^
14:35:39 <tswett> And so the law a natural transformation must satisfy is that if you apply the transformation's output arrow and then G's output arrow, you get the same thing as if you applied F's output arrow and then the transformation's output arrow?
14:36:27 <path[l]> oh is that what it was
14:36:28 <mercury^> What's the `output arrow' of a natural transformation?
14:36:42 <tswett> mercury^: the natural transformation applied to some object in C.
14:36:43 <path[l]> ^_^
14:36:44 <path[l]> ah
14:36:46 <path[l]> thanks
14:37:03 <mercury^> tswett: those are usually called `components'
14:37:12 <tswett> Makes sense.
14:37:41 <dolio> tswett: The law is 'mapping then transforming' is the same as 'transforming then mapping'.
14:37:42 <mercury^> You can look up the definition in many places. What you have said may or may not be correct, as many designators are a bit imprecise.
14:37:47 <monochrom> Taslem_: haskell.org freezes computer (just a bit actually) because it provides its own webfonts. this takes a while on windows but is pretty quick on linux, I've found
14:38:02 <Taslem_> Ah, okay, that explains something.
14:38:29 <monochrom> it also explains why absolutely everyone's haskell.org screenshot look the same :)
14:38:41 <mercury^> Is there a good reason it does that?
14:38:48 <mercury^> (are the fonts cached by most browsers?)
14:39:18 <Taslem_> It looks like it's cached by the browser for the day/session.
14:39:22 <Taslem_> But then it erases it.
14:39:24 <tswett> So, the natural transformation Id -> [].  For every object a in C (which is *), there's an associated function Id a -> [] a, such that applying the function and then mapping is the same as mapping and then applying the function.
14:39:54 <tswett> So yes, now I can clearly see how (\x -> [x]) and concat are natural transformations.  Thanks!
14:40:10 <mercury^> tswett: that they are natural transformations actually follows from their type already.
14:40:46 <mercury^> But that is not completely trivial afaik.
14:41:16 <tswett> Yes, I suppose it must.  You're just taking a container with opaque elements and doing stuff with them.  All you can do is rearrange them, which doesn't affect how mapping works.
14:42:31 <mercury^> Yep.
14:43:01 <ClaudiusMaximus> mm, maybe i should define a data type instead of using foo :: RandomGen g => R -> ((((C, R), ((C, C), I)), C), g) -> ((((C, R), ((C, C), I)), C), g)
14:48:38 <Saizan> maybe?
14:50:19 <noooomem> hey guys, http://codepad.org/Xsa0y9yk <-- what does that mean?
14:51:03 <benmachine> noooomem: in what context
14:51:08 <monochrom> it means typo
14:52:02 <noooomem> benmachine: monochrom it's in a prank message that I received
14:52:14 <benmachine> why would we know
14:53:32 <monochrom> then you have answered your question. it means a prank
14:53:37 <ourfrank> I'm reading Brent Yorgey's Typeclassopedia (http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf) and it mentions that (Either a) is an instance of Functor. However, ghci complains if I try to fmap anything over an Either value.
14:53:49 <monochrom> here is another prank. what does (<$>) mean?
14:53:52 <ourfrank> Complains saying that (Either a) is *not* an instance of Functor.
14:54:04 <aavogt> ourfrank: import Control.Monad.Instances   I think
14:54:21 <noooomem> monochrom: oh come on dude :) 
14:54:38 <monochrom> what do you mean by "come on"?
14:54:45 <ourfrank> aavogt: it worked, thanks! :)
14:55:28 <tswett> noooomem: in the context of Haskell, it doesn't seem to mean anything.
14:55:44 <hpc> ourfrank: with a name like "complains"... :P
14:55:57 <hpc> oh, didn't read the whole thing
14:56:00 <tswett> There's part of a string literal there.  You can't do anything with just one quotation mark.
14:56:50 <tswett> F$"`;" does mean something in Haskell, but it simply means "the function F applied to the string `;".  Since F begins with a capital letter, that means it's a data constructor.
14:57:44 <mm_freak> noooomem: are you trolling?  this is really not an appropriate channel
14:57:53 <noooomem> mm_freak: I'm really not
14:57:58 <benmachine> mm_freak: who answers yes to that question? :P
14:58:14 <mm_freak> benmachine: honest trolls =)
14:58:27 <benmachine> are those like honest politicians
14:58:55 * hackagebot hashed-storage 0.5.6 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.6 (PetrRockai)
15:06:00 <niteria> @hoogle Foreign.C.Types.CInt -> Int
15:06:00 <lambdabot> Parse error:
15:06:00 <lambdabot>   --count=20 "Foreign.C.Types.CInt -> Int"
15:06:00 <lambdabot>                     ^
15:07:06 <niteria> @hoogle CInt -> Int
15:07:06 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
15:07:06 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
15:07:06 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
15:07:20 <monochrom> try "fromIntegral"
15:07:43 <Dashkal> Quick sanity check to see if I'm grasping this:  const in the lambda calculus could be rendered as "\x.\y.x"?
15:07:56 <monochrom> yes
15:08:15 <niteria> ok, it works
15:08:32 <Dashkal> oh sweet.  I'm actually getting somewhere this time
15:11:43 <Dashkal> *clicks* I have GOT to stop overcomplicating these concepts.
15:14:29 <niteria> is there an easy way to return record with one field modified?
15:14:37 <Zao> niteria: Quite.
15:15:04 <ClaudiusMaximus> horrible syntax though: (\x -> x{ foo = bar (foo x) })
15:15:24 <Zao> foo { bar = 3 } -- yield foo, but with the bar field = 3
15:18:50 <niteria> cool
15:30:11 <Taslem_> *Sigh*  I have no projects to work on....
15:30:21 <Taslem_> The channel activity has dropped....
15:30:25 <benmachine> want some of mine? I have about twenty >_<
15:30:30 <benmachine> and I suck at all of them
15:30:53 <tswett> I have lots of projects, but unfortunately, none of them are Haskell.  :P
15:31:12 <copumpkin> what are they?
15:31:22 <copumpkin> I have lots too, most in haskell, but no time to work on them
15:31:31 <copumpkin> at least not in the past couple of weeks
15:31:32 <Taslem_> What are your projects?
15:31:45 <tswett> Implementing an interface between Smalltalk and Lua and making a codenomic using it.  Writing music for the piano.  Learning math.  Stuff.
15:32:07 <tswett> The time each of those will take is inversely proportional to the square of its length.
15:32:08 <copumpkin> maff
15:32:15 <copumpkin> maff is fun
15:32:24 <Eduard_Munteanu> Nice, we've got ourselves a composer.
15:32:25 <copumpkin> stuff is awesome
15:32:36 <Eduard_Munteanu> Told you we could make a band.
15:32:51 <tswett> So far, I've only written two things, and I've forgotten the left hand part of one of them.  :P
15:34:44 <ezyang> Given a lattice, I can construct a new lattice by sticking that lattice into a map. What's this construction called? 
15:37:14 <Ptival> it seems that head [a*b*c | a <- ..., b <- ..., c <- ...] is slower than product $ head [[a,b,c] | a <- ..., b <- ..., c <- ...], is that expected performance behavior?
15:37:27 <Taslem_> I can imagine how well that would turn out.  "This band, starting on an IRC Channel (2 hour explanation of what an IRC Channel is) for the programming language (3 hour explanation of what programming is) Haskell (5 hour explanation of what Haskell is)....
15:37:32 <Dashkal> I know now how to cause an infinite loop in the lambda calculus and I am amused.
15:37:44 <monochrom> stick into a map? like from lattice L and set X to lattice X->L? something like "pointwise lifting"
15:37:54 <ezyang> monochrom: Yeah. 
15:37:58 <Taslem_> Yeah. Recursion in lambda calculus is fun.
15:37:59 <ezyang> pointwise lifting... curious. 
15:38:23 <ezyang> Dashkal: typed or untyped? :-) 
15:38:28 <djahandarie> Dashkal, I hope you mean in the untyped lambdao calculus ;)
15:38:32 <ezyang> That seems obscure enough that I won't bother mentioning it. 
15:38:34 <Dashkal> Untyped :P
15:38:57 <Dashkal> I'm just amused because I can actually read the thing and understand why it reduces to itself.
15:39:05 * hackagebot bson-mapping 0.1 - Mapping between BSON and algebraic data types.  http://hackage.haskell.org/package/bson-mapping-0.1 (FrancescoMazzoli)
15:39:27 <monochrom> "pointwise lifting" is because fâŠ‘g iff (âˆ€x. f x âŠ‘ g x)  see? pointwise and lifts
15:39:31 <rostayob> ok, I just updated a package to hackage, but the haddock docs don't get generated
15:39:37 <Dashkal> But yeah, I can see why the simply typed lambda calculus cannot have that.
15:40:03 <Dashkal> Without the open type "a" you aren't getting anywhere with (\x.x x)(\x.x x)
15:40:27 <djahandarie> Pointwise extension maybe?
15:41:38 <monochrom> of course, "lift" is an all overloaded word
15:41:40 <niteria> @hoogle m [a] -> m [a] -> m [a]
15:41:40 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
15:41:40 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
15:41:40 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
15:42:04 <niteria> hmm, it won't work for IO [a], will it?
15:42:06 <Dashkal> Now if I could just grok typeclasses I might be able to make a scripting language that uses them.
15:42:07 <niteria> (++)
15:43:25 <Dashkal> (>>) ?
15:46:23 <c_wraith> niteria, what exactly do you want?
15:46:24 <Dashkal> Did I miss something or was Either e always a monad instance?
15:46:32 <c_wraith> :t liftM2 (++)
15:46:33 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
15:49:50 <niteria> :t liftM concat
15:49:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
15:50:19 <niteria> @hoogle [m [a]] -> m [a]
15:50:19 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
15:50:19 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
15:50:19 <lambdabot> Prelude concat :: [[a]] -> [a]
15:50:35 <niteria> :t liftM concat . sequence
15:50:36 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
15:51:20 <ion> dashkal: What time scale do you mean? There may or may not have been a period of Either existing but the concept of monads not in Haskell land for all i know.
15:52:55 <Dashkal> ion: I was just surprised to see a Monad (Either e) instance in the haskell docs.  Google suggests it was always there but is hiding in another module. (Error?)
15:53:08 <Watermind> why aren't  liftM and join in the Monad class, as an alternative to >>= ?
15:53:16 <Dashkal> unfortunately, the docs don't seem to point me to WHERE the instance was declared.
15:53:49 <monochrom> it may be hiding in Control.Monad.Instances
15:53:49 <copumpkin> Watermind: premature optimization
15:53:53 <dmwit> Control.Monad.Error
15:54:13 <Dashkal> monochrom: danke.  Found it in there.
15:54:39 <Watermind> copumpkin: hmm not sure what you mean...  if you mean that defining >>= directly can be more efficient I understand, but there would still be that option
15:54:39 <Dashkal> I've written that definition myself a few times so I'm glad to know what to import now.
15:54:54 <monochrom> my usual strategy is to import or :m + everything I think may have it, then :info to find who
15:55:34 <copumpkin> Watermind: for some reason people have an issue with putting an extra couple of pointers into a typeclass dictionary
15:55:45 <Watermind> copumpkin: oh... 
15:57:12 <Watermind> copumpkin: but that doesn't even affect runtime right? just compile time... and probably not that much. They didn't go to the trouble of avoiding it in Ord for instance
15:57:15 <c_wraith> copumpkin: I thought it was more a war between minimizing (for simplicity) and maximizing (for efficiency of implementations) type classes
15:57:44 <copumpkin> people definitely made the size of the dictionary argument in the most recent discussion I saw on it
15:57:58 <copumpkin> you can have default implementations of join and bind in terms of one another
15:58:06 <copumpkin> so it really isn't an issue of ease of writing
15:58:07 * hackagebot freetype2 0.0.1 - Haskell binding for FreeType 2 library  http://hackage.haskell.org/package/freetype2-0.0.1 (JasonDagit)
15:58:45 <lispy> copumpkin: I just uploaded a sort of trial release to hackage.  If you want to play with my cabalization of freetype, there you go :)
15:59:56 <copumpkin> yep, I'm in the process of cabal-install'ing it now
15:59:58 <copumpkin> !
16:00:02 <copumpkin> installed fine :)
16:00:05 <copumpkin> yay
16:00:06 <lispy> yay!
16:00:10 <lispy> what platform?
16:00:26 <lispy> copumpkin: install with -fexamples if you want the example program
16:00:46 <copumpkin> mac os
16:01:42 <lispy> oh heh.  That's where I mostly recently tested it :)
16:02:00 <lispy> I've tested it all 3 platforms, but not recently
16:02:13 <lispy> OTOH, I don't have any reason to think I've broken the build
16:04:03 <copumpkin> cool
16:09:08 * hackagebot xml-helpers 1.0.0 - Some useful helper functions for the xml library.  http://hackage.haskell.org/package/xml-helpers-1.0.0 (AdamWick)
16:33:31 <danharaj> hey, can anyone tell me where I can find signed analogues of Word8, 16, 32 etc.?
16:33:45 <dmwit> Int8, etc.
16:33:48 <benmachine> @hoogle Int8
16:33:48 <lambdabot> Data.Int data Int8
16:34:02 <danharaj> derp
16:34:11 <danharaj> My strategy was to google "haskell signed integral types"
16:34:14 <danharaj> that got me nowhere ;p
16:35:06 <benmachine> you need to know the magic word
16:35:18 <byorgey> the magic word is #haskell
16:35:27 <monochrom> or the magic int
16:35:30 <dmwit> > 1 - (96/99)^10
16:35:31 <lambdabot>   0.2648763676734427
16:35:54 <dmwit> > 1 - (98/99)^10
16:35:55 <lambdabot>   9.65402461348066e-2
16:44:03 * hackagebot rate-limit 1.1.0 - A basic library for rate-limiting IO actions.  http://hackage.haskell.org/package/rate-limit-1.1.0 (AdamWick)
16:44:10 <djahandarie> Wheee
16:44:16 * BMeph gets dizzy...
16:45:12 * hackagebot rate-limit 1.1.1 - A basic library for rate-limiting IO actions.  http://hackage.haskell.org/package/rate-limit-1.1.1 (AdamWick)
17:00:23 * hackagebot xml-types 0.3 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.3 (JohnMillikin)
17:05:41 <azaq23> @bot
17:07:55 <aristid> azaq23: lambdabot is offline :(
17:10:41 <lpsmith> glad lambdabot isn't responsible for logging this channel :-P
17:17:47 <danharaj> Can someone help me with this?
17:17:48 <danharaj> http://pastebin.com/BrUePznw
17:18:03 <azaq23> aristid: seems to have crashed around 16:58 log time, responses were delayed from there on
17:18:26 <danharaj> (I actually made a type error in my paste, but it is irrelevant to the error I get)
17:21:40 <aristid> azaq23: which time zone is that?
17:21:59 <aristid> oh, i think i know
17:22:08 <aristid> 5 minutes after -*- hackagebot rate-limit 1.1.1 - A basic library for rate-limiting IO actions.  http://hackage.haskell.org/package/rate-limit-1.1.1 (AdamWick)
17:22:52 <azaq23> aristid: I said log time, as in tunes.org log, so the standard US timezone. I'm german to it's 2 am^H^H^H too late already.
17:24:31 <aristid> azaq23: well i guess i could have opened the tunes.org logs
17:27:34 <Anpheus> Where is lambdabot
17:28:22 <aristid> Anpheus: NOT HERE!!!
17:29:36 <danharaj> ok what the hell
17:29:47 <danharaj> if I add a forall a. to the signature of the function, my error goes away. Whyyyy
17:30:41 <Anpheus> What the heck
17:38:45 <lispy> danharaj: I don't know what your error was, but forall a. does a lot of things actually depending on the extensions in scope.
17:39:04 <lispy> like ScopedTypeVariables
17:39:33 <danharaj> lispy: Alright then. I'll just go research that after I'm done with what I'm doing and just treat it as voodoo magick as of now.
17:40:04 <sshc> Is there a standard function that is equivalent to "flip ($)"; that is, it applies the function to the argument, one possible definition of which is "a :- f = f a"?
17:40:53 <benmachine> sshc: I believe there is not (it couldn't be called :- because that is a constructor name)
17:41:33 <sshc> (I meant "-:")
17:41:44 <espringe> I've got a dictionary (as in, literally a dictionary) of a word and it's definition. What's the haskell structure I should use for storing this? 
17:41:52 <sshc> Also, that's unfortunate
17:41:52 <espringe> (in c, I'd be creating a hash map)
17:42:20 <benmachine> espringe: Data.Map from the containers package is pretty good
17:44:57 <sshc> Another function I'd like to see implemented in a standard library is "maybeRead" (or "readMaybe")
17:44:57 <benmachine> and widely used
17:44:59 <espringe> benmachine: Ok that should do the trick
17:45:01 <espringe> thanks
17:45:05 <espringe> Another question. I've got an enum:
17:45:05 <espringe> data Symbol = Blah | Bleh | Foo deriving (Show, Read)
17:45:05 <espringe> using show on it works perfectly
17:45:05 <espringe> Show Blah gives "Blah"
17:45:05 <espringe> How do I make Read work
17:45:05 <espringe> so I can Read "Bleh" to give Bleh
17:45:06 <jmcarthur> sshc: f >>> g >>> h $ x
17:45:19 <jmcarthur> :t reads
17:45:46 <jmcarthur> grr
17:45:57 <benmachine> @botsnack
17:46:02 <benmachine> sigh
17:46:18 <benmachine> espringe: that should make read work, does it not?
17:49:02 <jmcarthur> reads :: Read a => String [(a, String)]
17:50:00 <jmcarthur> reads :: Read a => String -> [(a, String)]
17:50:46 <sshc> @bots
17:51:00 <espringe> benmachine: I didn't quite get what you guys were saying? What do i do?
17:51:56 <benmachine> espringe: deriving Read should make 'read' work
17:52:06 <benmachine> (although you probably want to use reads instead, where possible)
17:52:23 <espringe> benmachine: I'm already deriving Read, and AFAICT it doesn't work
17:52:37 <benmachine> espringe: how doesn't it work?
17:52:49 <benmachine> espringe: are you testing in ghci, and are you telling it what type to return?
17:53:22 <espringe> grrrrrrrrr, actually it's just that I forgot to :r in ghc
17:53:26 <espringe> :(
17:53:28 <benmachine> ah :)
17:53:36 <espringe> But ty, it works
17:53:51 <espringe> What's the advantage of "reads" over "read" ?
17:54:14 <benmachine> espringe: better handling of parse errors
17:54:19 <benmachine> espringe: that is to say, handling of parse errors
17:54:24 <pumpkin> espringe: no bottoms, gives you unparsed input
17:54:37 <pumpkin> > reads "123  omooo" :: [(Int, String)]
17:54:43 <pumpkin> fine, hrrmpf
17:54:44 <sshc> jmcarthur: I don't know why you mentioned "f >>> g >>> h $ x" or "reads :: Read a => String -> [(a, String)]".  The former still doesn't enable me to apply a function to a value by writing the value first.  And the latter... something to do with maybeRead?
17:55:00 <sshc> jmcarthur: Here's Learn You a Haskell For A Great Good's definition:
17:55:01 <sshc> readMaybe :: (Read a) => String -> Maybe a
17:55:05 <sshc> readMaybe st = case reads st of [(x,"")] -> Just x _ -> Nothing
17:55:19 <benmachine> that's a pretty ok definition
17:55:46 <pumpkin> fmap fst . listToMaybe . reads
17:55:48 <pumpkin> or something like that
17:55:49 <espringe> No error handling is fine for me, as I'm doing some "preprocessing" to convert a dictionary into a haskell source file -- which then I'll use
17:55:59 <espringe> So if there's an error, I'm just processing it wrong
17:56:03 <pumpkin> now, because listToMaybe is a natural transformation
17:56:05 <pumpkin> that's equivalent to
17:56:10 <pumpkin> listToMaybe . fmap fst . reads
17:57:54 <sshc> > fmap fst . listToMaybe . reads $ "1 extra stuff" :: Integer
17:58:38 <sshc> benmachine: One that should be in Text.Read
17:58:51 <ion> :: Maybe Integer
17:59:03 <sshc> Right
17:59:22 <benmachine> sshc: imo it should be case reads s of [(x,r)] | all isSpace r -> Just x; _ -> Nothing
18:06:50 <forrest> ok, i'm an idiot but here's my question, if I have a [String], how do I perform putStrLn on each string in the list?
18:07:02 <pumpkin> mapM_ putStrLn
18:07:17 <pumpkin> or map putStrLn to that and sequence(_) the result
18:08:01 <aristid> or write a recursive function to understand it better, at first
18:08:35 <forrest> oh, duh that's working now -- seems like i couldn't get it to work before
18:08:37 <monochrom> or call a C function to practice FFI  <duck>
18:09:10 <dolio> Just write it in malbolge.
18:09:14 <aristid> monochrom: not understanding the writing of recursive functions, but understanding how to combine IO actions...
18:09:15 <forrest> maybe i had some ghci weirdness; i keep forgetting i need to use "let" in ghci
18:15:31 <sshc> jmcarthur: Yes, it does let me compose functions in reverse order, but it still doesn't let me write the value first
18:16:16 <pumpkin> const 5 >>> (+1) $ undefined
18:16:17 <pumpkin> <_<
18:16:35 <dmwit> > let ($$) = flip ($) in 6 $$ (+1) >>> const 5
18:16:46 <dmwit> uh
18:16:55 <pumpkin> O_o
18:16:59 <dmwit> No bot. Okay.
18:17:03 <lispy> NO BOT
18:17:07 * lispy goes to investigate
18:17:10 <benmachine> dmwit: I don't think ($$) would get the fixity you wanted either
18:17:20 <dmwit> eh
18:17:35 <dmwit> Just saying there's a way to put the value first, if that's really what sshc wants.
18:17:59 <lispy> No lambdabot process, just rootkit.exe, should I be worried? ;) j/k
18:18:54 <lispy> hmm
18:19:02 <lispy> There is one lambdabot process owned by cale
18:19:15 <lispy> So, it must have crashed
18:19:32 <lispy> ?tell Cale I think you'll need to restart lambdabot.  It seems to be running but disconnected from freenode.
18:19:33 <monochrom> you scared me!
18:19:40 * lispy slaps himself
18:19:52 <forrest> If I have an IO [String] and I want to putStrLn all the Strings, is there a way to do that in one line? 
18:20:14 <monochrom> (your IO [String]) >>= mapM_ putStrLn
18:20:26 <lispy> also, forM_
18:20:33 <lispy> :t sequence_
18:20:43 * pumpkin slaps lispy 
18:20:43 <monochrom> (your IO [String]) >>= (flip forM_) putStrLn
18:20:49 <lispy> oh right.  Man, my fingers just assume lambdabot
18:20:56 <lispy> monochrom: :)
18:21:25 <monochrom> so you can flip while you flip!
18:21:30 <Axman6> flip forM_? o.O
18:21:35 <Axman6> @src forM_
18:21:36 <forrest> great, >>= is one of those things that's taking a while to sink in
18:21:36 <lispy> forM_ is really nice when you are mimicing a C style for-loop.
18:21:36 <monochrom> hehehe
18:21:41 <pumpkin> monochrom: fail
18:21:42 <pumpkin> <interactive>:1:2: Not in scope: `your'
18:21:44 <pumpkin> <interactive>:1:7: Not in scope: data constructor `IO'
18:21:49 <pumpkin> <interactive>:1:11: Not in scope: data constructor `String'
18:21:52 <pumpkin> :P
18:22:00 <monochrom> <monochrom> Not in scope: pumpkin
18:22:05 <pumpkin> :(
18:22:09 <monochrom> hehehe
18:22:10 <lispy> monochrom: you could really test your code examples first ;)
18:22:23 <pumpkin> http://i.imgur.com/HolhF.jpg
18:22:43 <monochrom> awesome creature there!
18:23:03 <copumpkin> dammit, someone took it
18:23:15 <monochrom> try hypn0toad
18:23:21 <ion> Awesome
18:23:27 <dolio> Skeptical toad is skeptical.
18:23:38 <monochrom> hahaha
18:26:33 * hackagebot unix-bytestring 0.3.4.1 - Unix/Posix-specific functions for ByteStrings.  http://hackage.haskell.org/package/unix-bytestring-0.3.4.1 (WrenThornton)
18:40:10 <sshc> dmwit: Clearly.  What I'm saying is that it's messy to write "let a -: f = f a" in every module and so forth.  It should be a standard function, probably where "$" is defined or in Data.Function.
18:40:33 <benmachine> sshc: it's not all that commonly used :)
19:13:25 <chrissbx> Hello. In monadic code, is there some way to avoid having to give names to all intermediate values calculated in the monad?
19:14:39 <chrissbx> i.e.  can  a <- f x ; b <- g y; return h a b   somehow be written as  specialreturn h (f x) (g y) or so?
19:14:40 <roconnor> chrissbx: probably
19:14:45 <roconnor> ya
19:14:55 <roconnor> chrissbx: if you import Control.Applicative you can write:
19:15:06 <roconnor> h <$> f x <*> g y
19:15:19 <shachaf> Or you can write liftM2 h (f x) (g y).
19:15:28 <shachaf> (Or liftA2 in Applicative.)
19:15:37 <chrissbx> aha, thanks, perfect.
19:15:38 <roconnor> ya. liftM2 doesn't require importing Control.Applicative
19:46:54 <litghost> beginner question, how do you define a function that takes no arguments, and then how would call said function?
19:47:26 <shachaf> litghost: No such thing.
19:47:36 <shachaf> litghost: A function that takes no arguments is called a value.
19:47:49 <shachaf> To call it, you just do whatever you want with it.
19:48:06 <litghost> okay, i wanted to create a function that takes a function and times how long it takes to extract the value
19:48:16 <litghost> how would you write such a function
19:48:27 <shachaf> That would probably an IO thing.
19:48:29 <copumpkin> what would its type be?
19:48:35 <litghost> that's my question
19:48:44 <litghost> i was trying to express it's type and couldn't
19:48:48 <copumpkin> NFData b => (a -> b) -> a -> IO (TimeInterval, b)
19:49:58 <shachaf> copumpkin: I suspect WHNF would be sufficient for what people typically want to measure.
19:50:13 <litghost> WHNF?
19:50:36 <c_wraith> Eh.  Sometimes I want to evaluate how long my permutation algorithm takes.
19:50:55 <litghost> can you explain why this requires IO at all?
19:51:12 <c_wraith> accessing the system timer is IO
19:51:18 <litghost> ah
19:51:19 <litghost> okay
19:51:22 <shachaf> c_wraith: You can always pass in (deepSeq a a).
19:51:38 <shachaf> litghost: In particular, this isn't a pure function; it can return different values for the same argument.
19:51:46 <litghost> of course
19:51:50 <litghost> that makes sense
19:52:27 * shachaf found it a bit surprising that time() doesn't make a system call, though.
19:52:45 <revenantphx> whoo
19:56:45 <Axman6> woah
19:56:54 <lispy> It's type should be; TimingMonad m => Timeable a b -> m (TimeInternal, b)
19:56:54 <lispy> and if you disagree with me, I will come to your house and make funny faces at you.
19:56:54 <lispy> litghost: Or for a serious answer, take a look at criterion.  It has this functionalitiy.
19:57:08 <shachaf> @hackage criterion
19:57:16 <shachaf> :-(
19:57:23 <litghost> i am learning, and wanted to explore what i felt was a pretty basic functionality
19:58:13 <litghost> so i am not super interested in the prebaked functions, but i'll keep it in mind
20:10:48 * hackagebot stm-chans 1.0.0 - Additional types of channels for STM.  http://hackage.haskell.org/package/stm-chans-1.0.0 (WrenThornton)
20:18:52 <lispy> what haskell function is like C's &?
20:19:05 <ddarius_> :t (.&.)
20:19:22 <lispy> I meant, foo( &bar);
20:19:28 <lispy> The address of operator
20:19:43 <jmcarthur> uh
20:19:51 <enthymeme> gb2 O'Caml, ref-lover! :p
20:20:03 <jmcarthur> objects in ghc's runtime can be moved by the gc, lispy 
20:20:12 <jmcarthur> so you can't really get an address
20:20:23 <jmcarthur> you can get a stablename, i guess
20:20:36 <jmcarthur> but that's not quite the same thing, and it's still not very reliable
20:20:48 <jmcarthur> for example, evaluating a thunk can change its "name"
20:20:50 <lispy> the solution I've been using is to allocate the Ptr to the thing and then later peek at it.
20:22:11 <copumpkin> alpounet: you should come over to ##categorytheory btw
20:22:48 <lispy> come on in, the functor is warm!
20:23:32 <copumpkin> :P
21:04:19 <White_Rabbit> How i do a palindrome with automata?
21:04:30 <White_Rabbit> in hugs98?
21:08:36 <White_Rabbit> I need to design a script to recognize a palindrome without "reverse"
21:08:54 <White_Rabbit> how i can do that using a automata?
21:09:54 <jake1> sounds like you need a push down automata
21:10:01 <White_Rabbit> hmm
21:10:05 <shachaf> White_Rabbit: What's "a automata" and why do you want to use one?
21:10:10 <shachaf> Is this homework?
21:10:45 <White_Rabbit> hahaha, yep, is my homework =/
21:11:05 <shachaf> You should probably mention that when asking questions.
21:11:19 <White_Rabbit> i dont know how i do a automata in haskell
21:12:54 * hackagebot wcwidth 0.0.2 - Native wcwidth.  http://hackage.haskell.org/package/wcwidth-0.0.2 (JasonDusek)
21:13:13 <jake1> have to go
21:15:15 <White_Rabbit> ok, thanks for helping
21:15:28 <White_Rabbit> =/
21:27:19 <kevinburke> http://hpaste.org/45262/parseerror
21:27:47 <kevinburke> can someone help me figure out why I'm getting a parse error in the code? I have case statemnets elsewhere inside do statements without any problems
21:27:52 <copumpkin> you have no do
21:27:57 <copumpkin> after the ok
21:28:12 <copumpkin> OK -> do ...
21:28:17 <kevinburke> ok thanks
21:33:09 <TomMD> "but now that I think about it, my program compiles so maybe it isn't such a big deal"  Can anyone guess the language he's programming in?  It isn't what first comes to your mind.
21:33:31 <kevinburke> copumpkin: is my code really ugly? are there ways I could refactor it quickly?
21:33:57 <BMeph> TomMD: It isn't perl? ;p
21:37:07 <Berengal> How hard is it to make bindings to a C++ library compared to pure c?
21:43:36 <gienah_> Berengal: should be the same as C apart from the additional work of wrapping the C++ code in C bindings so you can use stuff like c2hs
21:45:42 <gienah_> Berengal: Python has a tool that can create C bindings for C++ code, swig, maybe that might help
21:47:12 <Berengal> Yes, I thought maybe swig could help
21:47:59 <wagle> @hoogle Data.Binary
21:48:14 <wagle> oh noes!
21:48:29 <lispy> wagle: yeah :(
21:48:41 <shachaf> lispy: Isn't she on your server or something?
21:48:42 <lispy> wcwidth = water closet width?
21:48:47 <lispy> shachaf: aye
21:48:55 <lispy> shachaf: But, I don't run her
21:49:06 <lispy> I just keep the lights on
21:51:13 <blackdog> anyone played with halvm yet?
21:51:27 <blackdog> trying to work out what needs to be on which system... i'm a total xen newbie.
21:53:41 <TomMD> BMeph: Sorry, things came up.  It was C!
21:54:11 <TomMD> Slightly concerning when a user says that about C.
21:54:37 <TomMD> s/user/person who is supposed to be a developer type/
21:55:42 <TomMD> BMeph: And proving how tired I am, I only just realized how very tongue-in-cheek that was.   It compiles ... perl.... ahh!
21:55:52 <TomMD> bravo
21:55:56 <TomMD> BMeph++
21:56:32 <lispy> blackdog: I have :)
21:56:40 <TomMD> blackdog: You develop and compile on any system with Xenctrl (developer headers etc)
21:56:50 <TomMD> blackdog: And you run your domain on a xen system!
21:56:51 <TomMD> yay!
21:56:52 <lispy> blackdog: I've used it at work where I could bug awick when things didn't work
21:57:07 <TomMD> Like x86-64 compilation?
21:57:09 <TomMD> ;-)
21:57:21 <lispy> TomMD: You're going to write that since you need it, right?
21:57:25 <lispy> ;)
21:57:46 <lispy> updating it to work on fedora14 would be nice too.  It's fedora13 only at the moment, right?
21:57:49 <TomMD> I would if I did, I suppose.  Lucky for me its just a hobby right now, I have high paying student things to be doing.
21:57:58 <BMeph> TomMD: Yeah, I could never believe someone thinking a C program was good just because it compiles. You have to work at it to get a C program not to compile. Getting it to run... ;)
21:58:41 <TomMD> BMeph: This was after replacing enums with what "should be the integer equivalents" to get it to compile.  Hurmm.
21:59:34 <TomMD> lispy: Did I hear something about a hackathon recently?
22:00:24 <lispy> TomMD: for halvm?  I'm not sure.  For Haskell stuff?  There is hacphi.  I thought davidL was organizing a pdxhack to coincide but then he wasn't as serious as I thought
22:00:51 <davidL> :|
22:00:54 <TomMD> Ah, ok.  Wondered what was going on with a PDX.  Perhaps this summer.
22:00:59 <TomMD> hi davidL!
22:01:02 <davidL> hey Tom
22:01:10 <lispy> davidL: you're fired! j/k
22:01:24 <davidL> I'd love to *participate* in a PDX hackathon, but I don't want to be in charge :P
22:01:27 <lispy> haha, I can't fire you because you don't work for me! ;)
22:02:00 <TomMD> lispy: How much do you know of HaLVM internals.  All my time was really spent as a HaLVM user so there are holes I'd like filled given the right brain to pick.
22:02:08 <TomMD> err, place a ? in there somewhere.
22:02:08 <lispy> TomMD: Halvm should have a pdx hackathon though.  Or a presence at a haskell one.
22:02:14 <TomMD> Yes
22:02:49 <TomMD> perhaps I could trick Adam into giving an hour or two lecture if I host a hackathon?
22:02:53 <lispy> TomMD: I've probably used it less than you actually.  I've mainly interface with halvm domains from non-halvm domains.
22:03:08 <lispy> TomMD: Well, I can't vouch for adam, but it's worth a try :)
22:03:16 <TomMD> I did that once - set up linux Tun/Tap to use... domains... was fun.
22:03:30 <lispy> if I'm in town I would attend.  I'm planning a vacation (to leave the country) mid-summer-ish
22:03:56 <TomMD> lispy: Ok, I'll ping you about your dates if/when the summer comes and I'm ready to host such an event.
22:04:19 <jeffz> well, would you look at that, I finally gave into using cabal and it made several problems disappear
22:04:39 <lispy> jeffz: now you need to give in to using cabal-dev and the rest of the problems will disappear ;)
22:04:46 <davidL> TomMD: I'd help out with advertising a summer hackathon in PDX. I know a few other people interested in this as well
22:05:01 <TomMD> Is one of them named Bart?
22:05:06 <TomMD> ;-)
22:05:07 <davidL> heh
22:05:18 <lispy> It would be good for any GSoC students near portland
22:05:28 <TomMD> Do we have any around here?
22:05:36 <lispy> We don't know yet
22:05:52 <TomMD> Ok, rephrase, do we have any proposals going in from around here?
22:05:56 <shachaf> @where TomMD
22:06:01 <TomMD> I'm not in the loop really.
22:06:02 <lispy> I hope so!
22:06:16 * TomMD sits in the out-skirts of SE Portland, OR.
22:06:53 <davidL> TomMD: I am applying. I'll be living in PDX this summer.
22:06:54 <TomMD> I sit down town when/if I want a good drink or to be in a cubical.
22:07:11 <shachaf> Bah. Well, at least it's not Boston.
22:07:16 <lispy> I drink when I'm in a cubical, too.
22:07:54 <davidL> TomMD: I'm actually looking for a mentor. Are you interested in formal semantics? :)
22:07:55 <TomMD> Tom (the other Tom) tried that once... didn't go over well in our environment.  There are big drawbacks to this change of workplace I made.
22:08:38 <TomMD> davidL: I am interested but would be a poor mentor in that arena.  I suggest talking to Tom Harkee.  He's a Coq guru (but won't admit it) and has been hammering on the formal semantics road for many a year.
22:08:53 <TomMD> He's also mentored GSOC before.
22:09:15 <davidL> Does Tom Harke ever go on IRC?
22:09:23 <TomMD> Not that I know of.
22:10:03 <thoughtpolice> holy mother of research papers batman!
22:10:04 <thoughtpolice> http://research.microsoft.com/en-us/people/simonpj/
22:10:11 <lispy> TomMD: I wouldn't advertise that I'm a Coq Master (if I were one) except in written mediums :)
22:10:15 <thoughtpolice> do i count six things in march 2011?
22:10:20 * thoughtpolice is in awe
22:11:20 <c_wraith> thoughtpolice: icfp deadline :)
23:00:30 <bsod1> hi, I'm just starting to haskell with learnyouahaskell.com, what is the recommended IDE/editor for haskell? What is the best way to use vim with haskell(REPL would be great)
23:01:42 <kfish> ghci is a good repl
23:11:33 <TheColonial> bsod1: I keen ghci and vim open side by side. load ghci from the same folder as your .hs file that you're editing so that you can easily refresh changes.
23:12:03 <c_wraith> you can refresh changes by using :r, no matter what directory you're in
23:12:07 <TheColonial> bsod1: modify your file in vim. then in ghci just run      :load file.hs     (:l is shorthand)
23:12:14 <TheColonial> reload using :r as per c_wraith's suggestion
23:14:37 <bsod1> TheColonial: thanks, and which plugins should I install for vim? 
23:15:19 <TheColonial> bsod1: you don't need to install any at all to start with. VIM already recognises haskell's syntax which is enough to get you going. down the track you could look to use VIM as a full Haskell IDE, but I wouldn't bother worrying about it just yet.
23:15:39 <lars9> anyone can give an example to generate fibonacci numbers using Arrows?
23:16:01 <bsod1> TheColonial: ok, thanks, I'm starting
23:16:07 <TheColonial> bsod1: good luck :)
23:22:20 <pastorn> lars9: arr fibs
23:22:22 <pastorn> there, done
23:22:41 <lars9> :i arr
23:22:46 <pastorn> @type arr
23:22:50 <pastorn> awww
23:22:56 <lars9> :t arr
23:23:02 <lars9> bot gone
23:23:06 <pastorn> arr :: (Arrow arr) :: (a -> b) -> arr a b
23:24:57 <lars9> i wrote a fibs generator using arrows. but i have to feed in a list to get output.
23:25:21 <pastorn> ehm... what kind of arrows?
23:25:26 <pastorn> (->) ?
23:25:29 <pastorn> or something cooler?
23:25:36 <DrSyzygy> More likely the arrows package
23:25:46 <DrSyzygy> implementing the arrows generalization of monads...
23:26:00 <lars9> list to list
23:26:11 <DrSyzygy> halfway between the kleisli pragmatism of control.monad and the gorgeous abstraction of full on category theory packages.
23:26:15 <pastorn> http://hackage.haskell.org/package/arrows ?
23:26:33 <lars9> this one, sorry for long URL:  http://onthebalcony.wordpress.com/2007/02/19/my-evolution-as-a-haskell-programmer/
23:27:29 <pastorn> lars9: that seems an aweful lot like mental masturbation :)
23:29:51 <lars9> i modified that example to generate fibs, looks nice though, something like: x0 <- delay 1 -< o; x1 <- delay 1 -< x0; o <- add -< (x0, x1); returnA -< o.
23:30:50 <pastorn> delay feels like the wrong word...
23:30:51 <lars9> but because it is a arrow of list to list, so you have to feed in a list to get the result, though the input is even not evaluated.
23:30:55 <pastorn> or maybe i don't really get it
23:31:29 <lars9> delay is just another arrow, delay x = arr (x:)
23:31:37 <pastorn> yeah
23:34:55 <mathijs> Hi all, I'm a bit confused by the description of fmap in typeclassopedia. "it applies a function to each element of a container, without altering the structure of the container". I'm looking at the (tricked using some extensions) Data.Set instance of functor. If we apply (`mod` 3) to a set of [0,1,2,3,4], the set gets smaller. Is this considered "altering the structure" or is the structure more generic as in "a container that does not 
23:34:57 <mathijs> contain an element twice" ?
23:35:36 <pastorn> mathijs: it's a set, elements should only occur once
23:35:54 <pastorn> or rather; all elements in a set are unique
23:36:33 <pastorn> mathijs: your 2nd '1' might be there, but you just don't see it :)
23:36:47 <mathijs> I understand that, but I would like to know if fmap'ing a function that will lead to doubles (and thus making the set smaller) counts as "altering the structure"
23:37:06 <Boxo> Is Data.Set even a Functor?
23:37:15 <pastorn> Boxo: why wouldn't it
23:37:19 <Boxo> @data.set functor
23:37:23 <mathijs> Boxo: it isn't, but you can trick it into something like it.
23:37:44 <mauke> mathijs: I think this is exactly why Set is not a Functor
23:37:47 <Boxo> pastorn: (Data.Set a) requires (Ord a)
23:37:48 <mathijs> pastorn: so you are saying fmap'ing like this does not alter the structure of the set?
23:37:50 <pastorn> mathijs: are you using something like Data.Set.map ?
23:38:05 <Boxo> ah, meant to do this:
23:38:07 <mathijs> pastorn: so it's perfectly legal to consider a set to be a functor? (just not a haskell functor)
23:38:09 <Boxo> @google data.set functor
23:38:20 <pastorn> mathijs: i'm saying that the actual structure is up to the implementation
23:38:20 <Boxo> ... okay
23:38:29 <mauke> preflex: seen lambdabot
23:38:29 <preflex>  lambdabot was last seen on #haskell 7 hours, 2 minutes and 43 seconds ago, saying:   9.65402461348066e-2
23:38:35 <pastorn> but once you look at it might be changed 
23:38:40 <mathijs> pastorn:I was looking at this: http://www.haskell.org/pipermail/haskell-cafe/2010-July/080977.html
23:39:05 <mauke> preflex: seen Cale
23:39:05 <preflex>  Cale was last seen on #haskell 16 hours, 33 minutes and 56 seconds ago, saying: no, but it uses GHC
23:39:51 <mathijs> mauke: well some people tell me that it's not a functor because it needs Ord, but others say that's just a haskell shortcoming and it's a legal functor from the mathematical point of view.
23:39:59 <DrSyzygy> For any type a, Set a is a type. If you have a function a -> b, then you get a function Set a -> Set b and id yields id. Hence, it's a decent functor.
23:40:11 * hackagebot cryptocipher 0.2.8 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2.8 (VincentHanquez)
23:40:28 <mathijs> DrSyzygy: so even if me sets gets smaller because of fmap'ing over it, it's ok?
23:40:33 <pastorn> mathijs: but you're right, if there is some functor law (don't have my CT book here at the moment) it might be violated here
23:40:36 <DrSyzygy> It's not an unrestricted haskell Funcor just like mathijs says because the typeclass Functor does not allow for additional restrictions, so the Ord requirement is iffy.
23:40:54 <DrSyzygy> mathijs: Composing fmapped functors works, right?
23:41:03 <DrSyzygy> mathijs: And identity maps get mapped to identity maps?
23:41:11 <DrSyzygy> That's it when it comes to functor laws.
23:41:14 <mathijs> it does, it satisfies all laws (that are in typeclassopedia)
23:41:18 <Twey> fmap id = id is the only identity law, isn't it?
23:41:31 <DrSyzygy> Twey: Yup.
23:41:35 <Twey> s/identity/functor/
23:41:38 <mathijs> nope, fmap (f.g) = fmap f . fmap g
23:41:43 <mathijs> thats the second
23:41:50 <DrSyzygy> Twey: Functor laws also require composability.
23:41:54 <Twey> Oh, right, yes.
23:41:56 <DrSyzygy> lifting a composition is composing the lifts.
23:42:15 <shachaf> fmap (fmap f g) = fmap (fmap f) (fmap g)
23:42:17 <DrSyzygy> I like F(1_X) = 1_FX for the identity law. :-)
23:42:30 <mathijs> both laws are satisfied, I was just trying to get some intuition about the "does not alter the structure" description
23:42:31 <ddarius> mathijs: It's not a Haskell shortcoming.  Haskell's Functor class only describes certain functors.  The functor you'd want Data.Set is simply not one of them.
23:43:01 <DrSyzygy> mathijs: Thing is tht the structure of a set is a structure that is ignorant of multiplicities.
23:43:11 <DrSyzygy> mathijs: So when you rename your elements, some might merge.
23:43:14 <mathijs> ddarius: I understand, that's why the author of that post made a Functor' (extended functor)
23:43:30 <Boxo> But it does look like he discovered an erroneous sentence in typeclassopedia
23:43:44 <Boxo> Wait, no
23:44:06 <pastorn> wasn't there a RFC for typeclassopedia v.2?
23:44:08 <mathijs> DrSyzygy: so I should "feel" the structure does not change, because the goal of that structure is to eliminate duplicates.
23:44:15 <pastorn> maybe a note about Data.Set should be added
23:44:24 <DrSyzygy> mathijs: Something like that.
23:44:36 <mathijs> pastorn: I think something is mentioned already
23:44:40 <pastorn> right: http://byorgey.wordpress.com/2011/04/03/call-for-contributions-second-edition-of-the-typeclassopedia/
23:44:44 <ddarius> mathijs: Functor' isn't really a functor.
23:45:04 <mathijs> ddarius: I understand, but it follows the functor laws
23:45:23 <ddarius> mathijs: It doesn't even get far enough to talk about the functor laws.
23:45:56 <mathijs> ddarius: because of the constraint you mean?
23:46:16 <mathijs> anyway, sorry all... need to leave for work. we'll continue some other time :)
23:46:21 <mathijs> thanks
23:50:12 * hackagebot asn1-data 0.5.0 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.5.0 (VincentHanquez)
