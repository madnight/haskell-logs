00:05:05 <kevinburke> http://hpaste.org/45215/debugtrace_in_case_statement
00:05:36 <kevinburke> actually hang on i think i got it
00:06:44 <dmwit> trace "lol" $ Fail $ "errors lol" ++ ... ++ "idiot"
00:07:24 <kevinburke> dmwit: thanks
00:24:20 <argiopeweb> Is there any safe way to avoid/remove getPOSIXTime from the IO monad? I have a spot in my program that's relatively low in the call tree, and it seems like a real pain to make everything above it have to deal with being in the IO monad if it isn't necessary.
00:24:29 <lol> yo
00:29:08 <Guest13361> hello
00:29:37 <dmwit> argiopeweb: ...no.
00:29:56 <dmwit> Definitely not.
00:30:33 <dmwit> That is just about the most referentially opaque value I can think of.
00:30:53 <argiopeweb> dmwit: I was afraid that was the case. I may have to do a little backwards + dropping into StateT to make that clearer.  I'm assuming unsafePerformIO is unadvised.
00:31:48 <dmwit> If you're only calling it once, why not call it right at program startup and pass around the value?
00:32:09 <dmwit> If you're calling it multiple times, then unsafePerformIO is ill-advised (as it will likely be computed only once).
00:33:28 <argiopeweb>  Ah, good point on single eval.  It's definitely a multi-call deal. I have to have it around to create a unique ID with a per-second sequence number. Involves both keeping a UniqueID around with the previous time/sid and comparing it to the current time and setting the sid appropriately.
00:38:15 <argiopeweb> I honestly can't think of a good way to do it that isn't just horrendously IO based.  Hurray for Haskell applications that make heavy use of IO...
00:43:05 * roconnor remembers when he couldn't figure out how to live without goto
00:43:22 <argiopeweb> Good thing you fixed that...
00:44:52 <argiopeweb> Unrelated question: What's the current state of the haskell community in regards to IDEs vs. so-called plain-text editors (Emacs, VI(M))? I've been running fine with Emacs + Haskell mode up till now, but if I'm going to introduce this to the workplace my IDE-infatuated colleagues won't be appreciative. And, if I can gain some benefit from an IDE, I suppose I could try too. ;)
00:49:06 <ddarius> roconnor: When assembly was the only language you knew?
00:51:29 <roconnor> BASIC
00:51:55 <argiopeweb> GOSUB 70
00:52:08 <argiopeweb> Fond memories.
00:52:33 <roconnor> GOSUB makes no sense!  How do you know where you are going when you call RETURN?
00:52:42 <roconnor> GOTO is clearly superiour
00:53:13 <argiopeweb> Moreover, what happens to the call stack when you GOSUB and then GOTO before RETURN? Think of the consequences.
01:03:37 <DRMacIver> monochrom: Thanks for the link. 
01:21:16 <ceii> argiopeweb, re. IDEs: the EclipseFP plugin is supposed to be fully functional, but I don't use it, and don't know anyone who does
01:21:33 <ceii> guess the people have simply ahve an allergy to IDEs
01:21:49 <ceii> the people here*
01:22:33 <sordina>  I'm trying to install cabal in ec2. I've installed the generic linux 64bit ghc, and can compile hello world with that, but when I use bootstrap.sh to get cabal-install up and running I encounter "Setup: At least the following dependencies are missing: base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2". However, ghc-pkg tells me I have base-4.3.1.0.
01:23:03 <sordina> What could be up with that?
01:24:04 <merijn> ceii: Unix is my IDE ;)
01:25:49 <Egbert9e9> do x <- Nothing; Just 1
01:26:04 <Egbert9e9> > do x <- Nothing; Just 1
01:26:05 <lambdabot>   Nothing
01:26:10 <Egbert9e9> wth?
01:26:22 <shachaf> What do you expect?
01:26:33 <Egbert9e9> Just 1, or somesuch
01:26:41 <shachaf> Why?
01:26:45 <ddarius> You got somesuch.
01:26:47 <shachaf> @undo do x <- Nothing; Just 1
01:26:47 <lambdabot> Nothing >>= \ x -> Just 1
01:27:02 <Egbert9e9> because that's the last expression
01:27:23 <shachaf> So?
01:27:25 <ceii> the way the Monad instance for Maybe works is that if any of the steps fail (return Nothing), the whole block fails
01:27:26 <shachaf> @src (>>=) Maybe
01:27:26 <lambdabot> Source not found. Maybe you made a typo?
01:27:31 <shachaf> @src Maybe (>>=)
01:27:31 <lambdabot> (Just x) >>= k      = k x
01:27:31 <lambdabot> Nothing  >>= _      = Nothing
01:27:36 <merijn> Egbert9e9: >>= ignores anything after encountering Nothing
01:27:43 <merijn> Egbert9e9: As shachaf just showed
01:27:47 <Egbert9e9> hmmm
01:28:02 <shachaf> Egbert9e9: If you were to refer to x in that last expression, what would you expect it to be?
01:28:24 <ceii> > do x <- Nothing; Just x
01:28:25 <lambdabot>   Nothing
01:29:18 <Egbert9e9> can i say that in the typeclass of (Maybe a), (>>=) ignores later functions?
01:29:35 <shachaf> ceii: Given that that's Nothing >>= return, that behavior is even more expected. :-)
01:29:41 <Egbert9e9> ya
01:29:52 <shachaf> You could *say* it.
01:29:56 <Egbert9e9> err
01:30:06 <shachaf> > do x <- Just 1; y <- Just 2; Just (x + y)
01:30:07 <lambdabot>   Just 3
01:30:55 <Egbert9e9> ya, if the first variable of >>= is Nothing, it'll ignore the second and return Nothing
01:31:12 <Egbert9e9> inside the (Maybe a) typeclass
01:31:18 <Egbert9e9> did i say it right?
01:31:24 <shachaf> Grr, left chocolate on laptop's AC adapter.
01:31:34 <ceii> terminologically, it's in the Maybe instance of the Monad typeclass
01:31:39 <Egbert9e9> shachaf: hmmm... i love mushy chocolate
01:31:49 <Egbert9e9> ceii: oh!
01:31:57 <merijn> Egbert9e9: You might wanna check out Learn You A Haskell's monad chapter, it has a quite clear explanation of the hows and whys of the Maybe monad
01:32:07 <Egbert9e9> Maybe instance of the Monad typeclass!
01:32:10 <Egbert9e9> thanks
01:32:15 <shachaf> Also, that whole second sentence was redundant.
01:32:26 <shachaf> If the first argument is Nothing, that automatically means it's Maybe.
01:32:27 <ceii> a typeclass is a set of operations that can be implemented differently by different types, and an instance is such an implementation
01:32:44 <Egbert9e9> ah!
01:33:04 <Egbert9e9> LYAH is too long ;_;
01:33:32 <Egbert9e9> shachaf: i see
01:33:49 <Egbert9e9> ceii: ya
01:33:53 <Egbert9e9> okay, thank you guys!
01:34:02 <Egbert9e9> and gals, Maybe
01:34:11 <shachaf> Egbert9e9: It's probably shorter than asking #haskell all your questions.
01:34:33 <Egbert9e9> shachaf: talking keeps me concentrated
01:34:34 <shachaf> It's a bit silly to ask the questions here if they're already answered in a book.
01:34:46 <Egbert9e9> i'm a bad person
01:34:52 <Egbert9e9> and not very successful one
01:35:04 <merijn> Egbert9e9: I highly recommend reading LYAH anyway. It is an awesome book
01:35:15 <ceii> but it _is_ slow
01:35:25 <Egbert9e9> yeah, but there was a whole chapter talking about the many list functions
01:35:28 <ceii> at least until the last few chapters
01:35:37 <Egbert9e9> just listing all the popular ones
01:35:44 <shachaf> If a chapter is easy you can skim through it.
01:36:20 <Egbert9e9> and i've read it and i could feel my willpower draining like nuclear fuel out of fukushima's core into the open ocean
01:36:45 <ceii> you have a pretty terrible opinion of your willpower
01:36:49 <ceii> :)
01:37:00 <Egbert9e9> it's called ADD
01:37:04 <Egbert9e9> and laziness
01:37:08 <Egbert9e9> like haskell
01:37:39 <ceii> well, just skim through the whle thing once so you at least know the kind of answers you can find in there
01:37:50 <Egbert9e9> what i need to do is to write a real monad instance
01:37:52 <ceii> and you can actually read them when you have a question
01:38:09 <Egbert9e9> ceii: ah
01:38:18 <Egbert9e9> good strategy
01:40:22 <Egbert9e9> lol, the sun is using profanity
01:40:56 <Egbert9e9> anyone misses why_?
01:41:06 <Egbert9e9> or was it _why?
01:41:21 <Egbert9e9> why the lucky stiff
01:41:44 <Egbert9e9> author of The Poignant Guide to Ruby
01:41:58 <ceii> Yahovah, that's a very distant and faint memory TBH
01:42:09 <ceii> I meant "yah"
01:42:17 <ceii> how the hell did this happen? --
01:42:26 <shachaf> ceii: Tab completion.
01:42:29 <ceii> oh
01:42:32 <ceii> right
01:42:59 * shachaf notes ceii down as a blasphemer.
01:43:45 <Egbert9e9> he was a mad genius with a ton of artistic talent
01:44:00 <shachaf> _why++
01:44:28 <Egbert9e9> he had a blog i used to follow
01:44:48 <Egbert9e9> every time i went there it was like i liked stamps
01:46:43 <Egbert9e9> http://learnyousomeerlang.com/static/img/worm.png
01:46:50 <Egbert9e9> ouch
01:47:20 <ceii> wow :)
01:48:11 <Egbert9e9> in soviet russia, duck types you!
01:48:15 <Egbert9e9> http://learn-you-the-ruby.heroku.com/
01:48:50 <Egbert9e9> wait, do i see _why somewhere?
01:48:56 <Egbert9e9> http://learn-you-the-ruby.heroku.com/book/chapter/2#section-one
01:49:03 <Egbert9e9> HERE! T0 _why: I Need Ruby, Lots Of Ruby
01:50:18 <ceii> I have to admit that ruby version is a tad beyond crazy
01:50:43 <ceii> reminds me of the principia discordia
01:50:45 <Egbert9e9> IS THIS WHY?!
01:50:50 <Egbert9e9> _why
01:51:00 <Egbert9e9> is kurtis the same person?!
01:51:05 <Egbert9e9> I WANT TO BELIEVE!!
01:51:29 <Egbert9e9> the insanity fits!
01:53:02 <argiopeweb> ceii: Not too surprising. I can't stand them as a general rule. Heard anything about Leksah?
01:54:03 <ceii> argiopeweb, supposed to work too. The reason I mentioned the Eclipse plugin is because it's probably better for workplace infiltration
01:54:32 <ceii> setting up Leksah used to be an absolute nightmare, and I think it still isn't easy
01:54:48 <argiopeweb> ceii: Indeed, though there are certain among my coworkers who hate Eclipse more than I do. Thought I'd check out everything just to have options.
01:55:08 <ceii> but I'm honestly speaking out of my league there
01:55:58 <argiopeweb> ceii: I actually just installed it on Windows. It ground to a screeching halt on first run as it looked over everything in ~/.cabal, but it seems fully set up now.  Haven't tried the linux install yet.
01:56:42 <ceii> If you can get it to run Windows then I doubt it'll be hard on Linux
01:57:14 <ceii> the only package that's easier to set up on Windows is probably the win32 bindings :)
01:57:25 <argiopeweb> rofl...
01:57:34 <argiopeweb> I imagine.
01:58:10 <argiopeweb> Well, I'll play with it ans see what happens. I doubt I'll be impressed enough to give up Emacs.
01:58:16 <argiopeweb> s/ans/and/
01:58:29 <Jonno_FTW> > 0x86
01:58:29 <lambdabot>   134
02:24:47 <accel> @src ->
02:24:47 <lambdabot> Source not found. Are you on drugs?
02:24:55 <accel> does -> have any meaning outside of "case" ?
02:25:28 <yottis> \x -> x+1
02:25:32 <kevinburke> I'm trying to debug my haskell program using debug.trace
02:25:43 <kevinburke> However, I'm having trouble getting the value to show up consistently
02:26:02 <kevinburke> let's say I have myFun a b = let x = 5 in x, for example
02:26:05 <c_wraith> @kind (->)
02:26:06 <lambdabot> ?? -> ? -> *
02:26:21 <c_wraith> @src (->) (>>=)
02:26:21 <lambdabot> f >>= k = \ r -> k (f r) r
02:26:26 <kevinburke> where can I put debug.trace to show the value of a and b?
02:26:30 <accel> holy shit
02:26:37 <Egbert9e9> @src (<-)
02:26:37 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:26:38 <accel> so is -> used outside of case & \ ... -> ... ?
02:26:51 <c_wraith> accel, it's a higher-kinded type
02:26:52 <Egbert9e9> @kind (<-)
02:26:52 <ezyang> kevinburke: What's the type of myFun? 
02:26:53 <lambdabot> parse error on input `<-'
02:27:06 <Egbert9e9> ya, it's a 'keyword'
02:27:08 <accel> c_wraith: wtf does that mean?
02:27:17 <accel> c_wraith: is it a ahskell builtin
02:27:19 <accel> or somethign I can redefine?
02:27:22 <kevinburke> ezyang: in my case, C.Ctx and A.Exp
02:27:32 <kevinburke> maybe i should just paste the whole thing, hang on a sec
02:27:49 <accel> Binary vs Text file reading mode -- is the only difference \n \n\r translations?
02:27:52 <c_wraith> accel: It's built-in.  It's the only infix type operator by default.  a -> b is the same as (->) a b
02:28:29 <accel> (->) \x x + 1
02:28:34 <accel> > ((->) \x x + 1) 2
02:28:35 <lambdabot>   <no location info>: parse error on input `->'
02:28:37 <c_wraith> no, at the type level
02:28:39 <accel> why does that not work?
02:28:46 <c_wraith> because that's not a type
02:29:15 <c_wraith> > (id :: (->) String String) "foo"
02:29:15 <lambdabot>   "foo"
02:29:29 <kevinburke> ezyang: http://hpaste.org/45217/debugtrace_help
02:29:40 <ezyang> kevinburke: If the value of myFun gets used, you can just stick trace (show a) $ ... at the front of the function (assuming C.Cxt and A.Exp have Show instances) 
02:30:09 <kevinburke> so like trace (show exp1) $ myFun a b = some value (?)
02:30:25 <ezyang> put it to the rhs of = 
02:31:27 <kevinburke> Oh - thanks - when I tried it before I got a parse error, I was missing the $$ sign.
02:36:38 <accel> wtf wtf wtf
02:36:45 <accel> data a `Pair` b = a `Pair` b
02:36:47 <accel> is valid code?
02:38:46 <ezyang> Yes. 
02:38:57 <ezyang> You can also have symbols in constructors :-) 
02:39:50 <c_wraith> data a :*: b = a :*: b -- for instance
02:55:15 <accel> are last
02:55:16 <accel> and init
02:55:18 <accel> also lazy?
02:55:33 <accel> @src foldr
02:55:33 <lambdabot> foldr f z []     = z
02:55:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:55:35 <accel> @src foldl
02:55:35 <lambdabot> foldl f z []     = z
02:55:35 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:58:21 <Egbert9e9> @src (:)
02:58:21 <lambdabot> Source not found. :(
02:58:27 <Egbert9e9> @src :
02:58:27 <lambdabot> Source not found. My brain just exploded
02:59:34 <Egbert9e9> @src +
02:59:34 <lambdabot> Source not found. Sorry.
02:59:49 <Egbert9e9> lol, builtins are funny
03:00:20 <Egbert9e9> @src (+)
03:00:20 <lambdabot> Source not found. Maybe you made a typo?
03:00:22 <Egbert9e9> hmmm
03:00:29 <theorbtwo> Egbert9e9: Do you think there's a useful definition of (+) ?
03:00:47 <Egbert9e9> theorbtwo: i really don't know
03:00:55 <Egbert9e9> + could mean many things
03:01:07 <Egbert9e9> there are many +'s
03:02:27 <Egbert9e9> maybe it could show me the name of the lower level function being used?
03:03:19 <Egbert9e9> depending on the type signature i provide
03:17:04 <Jonno_FTW>  @check \n m -> rem n m == mod n m
03:17:08 <Jonno_FTW> > @check \n m -> rem n m == mod n m
03:17:09 <lambdabot>   <no location info>: parse error on input `@'
03:17:17 <Jonno_FTW> @check \n m -> rem n m == mod n m
03:17:17 <lambdabot>   "*Exception: divide by zero
03:19:37 <accel> @src id
03:19:37 <lambdabot> id x = x
03:19:40 <accel> @src id
03:19:40 <lambdabot> id x = x
03:25:16 <Mitar> is there some other way/pattern to remove this warnings when parsing options:
03:25:17 <Mitar> http://hpaste.org/45219/warning
03:26:15 <accel> @src foldr
03:26:15 <lambdabot> foldr f z []     = z
03:26:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:26:18 <accel> @type foldr
03:26:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:42:38 <namor> hiredman, does someone know of a freebsd PORT for ghc 6.12 or 7 ?
03:43:03 <namor> wah... not "hiredman" ..., but "hi"
03:50:44 <accel> @src groupBy
03:50:44 <lambdabot> groupBy _  []       =  []
03:50:44 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
03:50:44 <lambdabot>     where (ys,zs) = span (eq x) xs
04:03:14 <accel> @src (.)
04:03:14 <lambdabot> (f . g) x = f (g x)
04:03:14 <lambdabot> NB: In lambdabot,  (.) = fmap
04:08:42 * hackagebot csound-expression 0.3.2 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.3.2 (AntonKholomiov)
04:15:22 <accel> now that I understand lazines sin haskell
04:15:28 <accel> I feel like there's nothing in this world I can't understand
04:15:31 <accel> besides love
04:15:54 <sipa> tried string theory?
04:16:20 <accel> I said in this world; not the imaginations of mental patients
04:16:30 <sipa> good point
04:24:02 <andrewu> i try to learn about TH and would like to read the tutorial http://www.haskell.org/bz/th3.htm - but i get 404 'not found'; what is wrong ?
04:34:11 <Saizan> andrewu: it didn't get copied over the new server when they switched some time ago
04:34:35 <andrewu> is there a way to access the old server?
04:37:40 <Saizan> i don't know
04:38:15 <Saizan> maybe with web.archive.org ?
04:53:57 <mekeor> does any body know how to say ghc that he should not make ".hi"- and ".o"-files? I couldn't find an answer to my question in the manpage of ghc, yet…
04:54:05 <insane_> if i have a function defined like this: f x = x, the inferred type of such function would be a -> a, but the compiler has to know the exact types in order to generate the assembly code for it. Will the code for such function be generated only when such function is used somewhere else in the code and for each such usage the compiler would generate the version of function with correct types?
04:58:13 <hpc> insane_: internally, values are pointers of pointers or something like that, so for that f, you just don't do anything to the pointer
04:58:25 <andrewu> Saizan, thank you - i found it there. what can be done that the haskell wiki does not produce 404 errors (not just in this case)
04:59:06 <hpc> insane_: plus, values of a polymorphic type like that can't have their internals inspected, so this holds true for all functions similar to that one
04:59:17 <hpc> insane_: for type classes, i cannot say what happens
05:09:38 <ezyang> mekeor: The usual way is to tell GHC to stick them in an alternate output directory. 
05:09:42 <ezyang> Cabal will do this for you. 
05:11:08 <Saizan> andrewu: maybe you can ask the committee http://www.haskell.org/haskellwiki/Haskell.org_committee
05:15:30 <mekeor> ezyang, thank you.
05:36:53 <Saizan> ezyang: re: your hoopl post, the fact that Inst's field don't mention the type indexes is not enough to make type refinements irrelevant, e.g. in "foo :: Inst e o -> Entry e; data Entry e where Open :: Entry O; Closed :: Entry C" they would
05:38:54 <ezyang> sorry, your message got cut off? 
05:39:07 <Saizan> they would matter
05:39:16 <lispy> Sorry, your message was trun
05:39:51 <ezyang> Oh yes, if you join it up with another GADT like that. 
05:40:05 <Saizan> anyhow, the point is that the refinements can affect the type of the result of a case expression
05:40:47 <ezyang> Hmm, I wonder how to reword this 
05:42:05 <ManateeLazyCat> Hi all. :)
06:09:29 <argiopeweb_> Does anyone here have GHC-mod working with Emacs? I followed the instructions provided, but things just don't seem to be working.
06:09:41 <argiopeweb_> Emacs23, I should probably add.
06:10:09 <homie> it just works with comint-run here
06:13:34 <argiopeweb_> homie: I fail to see how comint-run would help with making the ghc*.el[c] files work.
06:15:16 <homie> i meant just ghci, the interpreter i think
06:15:38 <homie> i don't even have a ghc-mode.el file
06:16:22 <homie> apart from that, if you just mean ghc, that's the compiler, should run in eshell or so too
06:16:37 <homie> or with M-x compile then change the make command to ghc or so
06:20:45 <argiopeweb_> homie: There's a set of ghc-*.el scripts that provide a variety of functionality such as flymake support. It seems to have conflicts with something in my .emacs file.
06:31:08 <lispy> I'm making an FFI binding and I was hoping to only partially specify the struct on the Haskell side.
06:31:28 <lispy> But, how do I copy the bits that I don't want to make accessible in Haskell?
06:31:39 <lispy> I mean, copy in the sense of writing Storable instances
06:32:24 <lispy> Or do I pretty much have to model the whole thing on the Haskell side?
06:59:13 * hackagebot improve 0.3.2 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.3.2 (TomHawkins)
06:59:28 <ClaudiusMaximus> fsdfgs: hi!
07:02:21 <thehunter> hmm
07:02:43 <sipa> @src withState
07:02:43 <lambdabot> Source not found. :(
07:03:09 <mauke> fsdfgs: how would you pass the turing test?
07:05:08 --- mode: ChanServ set +o mauke
07:05:09 --- kick: fsdfgs was kicked by mauke (/msg me if you're not a bot)
07:05:25 --- mode: mauke set +b *!*@93-24-67.netrun.cytanet.com.cy
07:06:35 --- mode: mauke set -o mauke
07:07:27 <Twey> .com.cy?  Cool
07:13:27 <michaelh> is this book really worth tracking down on worldcat or should i get one that's in print? http://www.amazon.com/Calculus-Semantics-Studies-Foundations-Mathematics/dp/0444875085
07:21:29 <spirit> how to get user input when using leksah? i.e. foo <- getLine?
07:22:34 <byorgey> spirit: I don't understand.  Why would it be any different when using leksah?
07:23:00 <byorgey> leksah is just an IDE, it doesn't change the way Haskell programs behave
07:23:28 <mauke> oh, I thought you'd have to write enilTeg -> oof
07:23:41 <spirit> i meant from within leksah
07:23:49 <hamishmack> spirit: This might help... http://groups.google.com/group/leksah/browse_thread/thread/7d3e3bf64e56f190
07:23:50 <spirit> when running the package
07:24:24 <arlinius> nilTeg -> of
07:24:41 <mauke> hamishmack: that gives me a google.com account login window
07:24:47 <mauke> google--
07:25:33 <arlinius> odd, it shows me mail thread content
07:25:54 <spidermario> niLteg -< oof
07:26:24 <mauke> arlinius: because you're logged in?
07:26:28 <arlinius> nope
07:26:59 <arlinius> the only difference I can think of is that I'm at https://groups.google.com/group/leksah/browse_thread/thread/7d3e3bf64e56f190
07:27:11 <arlinius> due to https-anywhere
07:27:48 <spirit> http://groups.google.com/group/leksah/browse_thread/thread/7d3e3bf64e56f190?pli=1 works fine for me
07:28:25 <mauke> I wonder why google hates me
07:28:27 <spirit> thanks for the link, hamishmack
07:28:46 <hamishmack> mauke: Try this... http://www.google.co.nz/search?sourceid=chrome&ie=UTF-8&q=leksah+hamish+telnet
07:28:56 <hamishmack> mauke: It was the top link
07:29:26 <mauke> hah, works after deleting all google cookies
07:29:33 <arlinius> heh
07:29:58 <arlinius> "you were logged in once, therefore you must log in again right now!"
07:35:12 <lispy> Is it possible to define copy :: Storable a => Ptr a -> Ptr a -> IO () using Haskell98 + FFI addendum?  I needed ScopedTypeVariables to write it, but maybe there is some clever use of asTypeOf that I'm missing?
07:36:17 <Saizan> lispy: can you show the code with ScopedTypeVariables ?
07:36:19 * Twey wonders why people still care about H98.
07:37:11 <lispy> copy :: forall a. Storable a => Ptr a -> Ptr a -> IO ()
07:37:11 <lispy> ;copy dest src = copyBytes dest src (sizeOf (undefined :: a))
07:37:19 <lispy> that didn't paste so well
07:37:22 <lispy> But you get the point?
07:37:25 <ClaudiusMaximus> lispy: something like   sizeOf (undefined `asTypeOf` peek ptr)  springs to mind
07:37:53 <ClaudiusMaximus> wait, i forgot the IO
07:38:01 * ClaudiusMaximus gets more coffe...
07:38:11 <lispy> Twey: I'm trying to unsstand if the FFI authors had a good reason to leave out copy, or if it was just an oversight
07:38:19 <Twey> Aha
07:38:47 <Saizan> copy dest src = copyBytes dest src (sizeOf (type_ src)) where type_ :: Ptr a -> a; type_ = undefined
07:39:29 <Twey> Neat
07:39:34 <lispy> Saizan: did you try that?  I'm pretty sure that in H98, that 'a' in type_ is not the same as the 'a' at the top level?
07:39:46 <Saizan> lispy: that's not a problem
07:39:48 <Twey> lispy: It's applied to the Ptr a, though
07:39:49 <lispy> oh, I guess because you ]pass src
07:40:00 <lispy> that is cute
07:40:03 <Twey> Yeah
07:42:08 <lispy> So, I think I'm going to use a storable instance that just implements peek/poke via copyBytes
07:42:22 <lispy> Then when there is a field that is useful to access I'll write an accessor
07:42:40 <lispy> so I have, data FT_Library = FT_Library (ForeignPtr FT_Library)
07:43:10 <lispy> I think that will make it so I don't have to care about all the internal bookkeeping fields of the free type library (it seems to have a lot)
07:45:13 <Jafet> If you're finding freetype a pain to use from haskell, just close your eyes and be thankful you don't have to use it from C.
07:45:29 <Twey> Ha
07:46:09 <lispy> heh
07:46:40 <lispy> Jafet: I'm actually worried that if I implement all the structs in Haskell that I'll just end up reimplementing the whole library in Haskell :)
07:47:10 <lispy> and that seems silly...
07:48:32 <Saizan> do they implement Storable in the same way in gtk2hs? they also just define the haskell type as a newtype of the pointer
07:49:06 <lispy> I've never looked at the gtk2hs source.  I'm not sure I can muster the intestinal fortitude :)
07:49:53 <geheimdienst> @remember lispy I've never looked at the gtk2hs source.  I'm not sure I can muster the intestinal fortitude
07:49:53 <lambdabot> Okay.
07:56:23 <Saizan> ..why should it be bad? there are a few preprocessors involved but i found it quite clean
07:58:04 <lispy> Saizan: something about the part before the 2hs
08:05:22 --- mode: ChanServ set +o mauke
08:05:22 --- mode: mauke set -b *!*@93-24-67.netrun.cytanet.com.cy
08:05:25 <Athas> I need an array which I will update rather often.  Is it better performance-wise to use a Map?
08:05:44 <lispy> Athas: We have mutable arrays
08:05:47 <Athas> I do not think I can rely on GHC detecting that the array is not shared, and performing the update in-place.
08:05:49 <lispy> in both ST and IO
08:05:54 <Athas> lispy: this is for pure code, though.
08:06:04 <sipa> look at STUArray
08:06:12 --- mode: mauke set -o mauke
08:06:13 <Athas> ST... maybe, but I'd have to restructure my code quite a bit.  Maybe later.
08:06:26 <Saizan> Athas: Data.Sequence.Seq is also a candidate
08:06:31 <mauke> IntMap
08:07:08 <parcs> @check (==) <*> liftM2 (*) abs signum
08:07:09 <lambdabot>   "OK, passed 500 tests."
08:07:18 <Athas> Oooh, IntMap.  That looks like the ticket.
08:07:25 <Athas> With a change to ST later, perhaps.
08:12:05 <mux> woo, haskell is now legally allowed to drink!
08:12:30 <lispy> ?faq Is Haskell old enough to drink?
08:12:30 <lambdabot> The answer is: Yes! Haskell can do that.
08:12:41 <mux> Haskell turned 27 years old today
08:12:50 <mux> err 21
08:14:17 <Twey> That means it's been old enough to drink for at least five years in sane countries ;)
08:14:42 <arlinius> the question is irrelevant in sane countries
08:15:17 <Twey> Heh
08:15:26 <Twey> Sealand?
08:15:36 <lispy> Saizan: Yeah, maybe this doesn't work because some functions in the C api take structs instead of pointers to structs.
08:15:53 <lispy> Saizan: I need a way to pass them a copy of something that I don't actually store in Haskell
08:16:11 <arlinius> don't know
08:16:28 <lispy> and implementation of peek in Storable just allocates space and does a copyBytes to move the memory.
08:16:56 <lispy> er, my implementation of peek
08:17:36 <Saizan> sounds like you need some C wrappers
08:17:48 <lispy> I was wondering about that.
08:18:06 <lispy> Something that takes a Ptr and then derefs it and passes the copy?
08:18:09 * Saizan is not a FFI expert by far
08:18:18 <lispy> me either
08:18:31 <Saizan> yeah, i was thinking of something like that
08:18:37 <lispy> This is my first time using it in earnest.  In the past I just needed simple functions
08:33:31 <lispy> Saizan: I haven't tested it by running it yet, but that that trick compiles cleanly.
08:36:07 <vegai> on niin avaikeeta
08:36:14 <vegai> oopsie :)
08:40:48 <augur> vegai: which language
08:40:55 <vegai> Finnish
08:41:04 <vegai> with a typo
08:51:42 <ManateeLazyCat> Hey, all, which xml-rpc library do you use? :)
09:04:01 <ourfrank> Can Hint load precompiled modules?
09:14:51 <rovar> i am afraid I don't know much about template haskell.. but I am trying to compile a test and I get the error: Parse error: naked expression at top level
09:15:04 <rovar> anyone know how I am supposed to address this?
09:16:42 <Saizan> maybe you miss {-# LANGUAGE TemplateHaskell #-} at the top of your file?
09:17:14 <rovar> that certainly got me closer.. thanks :)
09:30:30 <Fuco> :t dist
09:30:31 <lambdabot> Not in scope: `dist'
09:40:02 <xXProSkillXx> hallo
09:40:08 <Nibble> hello, I am getting undefined references to glutMainLoop and other glut stuff when compiling this simple test app
09:40:11 <xXProSkillXx> jemand da?
09:40:17 <Nibble> xXProSkillXx: english pl0x
09:40:29 <xXProSkillXx> why?
09:40:40 <Nibble> freeglut is installed, so is haskell-glut and haskell-opengl
09:40:58 <xXProSkillXx> is anybode german here?
09:41:00 <Nibble> xXProSkillXx: because the british people traveled around the world in boats and raped ur women
09:41:06 <Nibble> xXProSkillXx: I speak a little german ... thats it
09:41:12 <Nibble> there is probably someone from austria
09:41:25 <xXProSkillXx> Nibble you are a computer bot isn?? it?
09:42:00 <Nibble> oh no, he left
09:42:11 <Nibble> and why does everyone always accuse me of being a bot :(
09:44:01 <Saizan> because trying to be funny with strangers doesn't work well.
09:44:06 <Nibble> I wasn't funny
09:44:09 <Nibble> Saizan: it is true
09:44:36 <Eelis> Nibble: have you tried passing -lglu -lglut or -lglu32 -lglut32 or variations thereof to ghc?
09:44:49 <Nibble> no
09:45:01 <Nibble> that works
09:45:04 <Nibble> why doesn't --make work
09:45:12 <Eelis> dunno. use cabal
09:45:23 <Nibble> Eelis: thanks for the help btw
09:45:43 <benmachine> --make doesn't know about all your C libraries ever
09:45:49 <benmachine> that would be quite a feat
09:46:12 <Saizan> the package description for haskell-glut could, though
09:46:38 <Nibble> yes
09:46:53 <Nibble> Isn't that the whole idea with packages? that they can add linking options?
09:46:59 <Nibble> I shouldn't have to know his logic
09:47:02 <Nibble> to use him
09:47:07 <Nibble> that only applies to women
09:47:33 --- mode: ChanServ set +o Saizan
09:47:51 <Nibble> I know ... the enter button .. sorry
09:47:53 <Saizan> refrain from such comments, please.
09:48:05 <Nibble> oh, women jokes. ok :D
09:48:15 <Eelis> jeez
09:48:17 <Saizan> both
09:48:53 <Saizan> anyhow, you might ask the GLUT maintainer about this
09:49:03 <Nibble> ok
09:52:59 --- mode: Saizan set -o Saizan
09:54:13 <michaelh> newb question: better to use filter odd [1..] or [1,3..] ?
09:54:50 <Nibble> michaelh: probably 1,3..
09:54:52 <Nibble> but
09:55:17 <fcr> (-1) is odd, so...
09:55:42 <Nibble> ghc is really clever, it probably optimizes that automagically. And provided that haskell is lazy it won't matter really
09:56:13 <gwern> wonder how enumfromTo is defined
09:56:25 <michaelh> ok, good to know. couldn't get a meaningful diff in ghci.
09:56:27 <gwern> might be a little more efficient than `od`
10:01:12 <rostayob> I can get the fields of a constructor of a Typeable with constrFields. now, is it possible to test if a function is a field, and get the function string name as well?
10:01:32 <ddarius> no.
10:02:11 <rostayob> ok. too bad.
10:02:30 <rostayob> there must be a reason for that, what is it?
10:03:30 <ddarius> The only thing you can do to a function is apply it.  Anyway, if foo is a field, is \x -> foo x also a field?
10:03:55 <rostayob> no
10:04:00 <rostayob> the thing is that
10:04:11 <rostayob> I'm doing a mapping from data type to bson (a sort of json)
10:04:29 <rostayob> I can convert the data type to a json documents, with the aid of the fields
10:05:01 <rostayob> so like Foo { bar :: String, nay :: Int } will become {bar: "whatever", nay: 3}
10:05:20 <rostayob> now what I'd like to do is to "narrow" the data type to produce a document with only certain fileds
10:05:23 <rostayob> *fields
10:05:30 <rostayob> so maybe I want only "bar"
10:06:41 <rostayob> something like foo :: Val a => [Foo -> a] -> Document
10:07:09 <rostayob> and I tought of a template haskell function, that would work, if I could get the name of a function :P
10:07:18 <metaliving> hi, when i try to compile a program with parsec i keep getting this
10:07:20 <metaliving> Could not find module `Text.ParserCombinations.Parsec'
10:07:31 <metaliving> while i can import the same module fine from ghci
10:07:43 <ddarius> No you can't.
10:08:00 <rostayob> ddarius: mh. so how can I do something like that?
10:08:08 <byorgey> ParserCombinators*
10:08:10 <rostayob> metaliving: you mean Text.ParsecCombinators.Parsec
10:08:23 <rostayob> ParserCombinators lol
10:08:40 <djahandarie> Bad name is bad.
10:08:44 <metaliving> crap, blindness
10:08:46 <metaliving> sorry about that
10:08:55 <metaliving> thanks
10:09:03 <byorgey> metaliving: no worries, it happens to all of us =)
10:09:28 <rostayob> ddarius: because I can't think of any nice solution, if I generate the conversion automatically.
10:09:36 <byorgey> whoops, .5 seconds too late
10:10:21 <ddarius> rostayob: Just take names instead of functions.
10:11:04 <rostayob> ddarius: but I don't even want to know the string name. the bson document names get generated automatically
10:11:18 <Nibble> how do I make ghci use custom lib includes
10:11:31 <Nibble> like if I were to pass -lglut to ghc, how do I make ghci do the same
10:11:55 <rostayob> Nibble: isn't it the same? usually you can give ghci the same options...
10:12:02 <Nibble> I don't know
10:12:05 <Nibble> that is why I asked
10:12:09 <ddarius> rostayob: Have your TH pair the selectors up with their names.
10:12:09 <rostayob> Nibble: well try
10:12:30 <Nibble> can it destroy my computer?
10:13:34 <rostayob> ddarius: what do you mean? 
10:14:01 <rostayob> I can do something getName :: Expr -> String, and then generate them at the beginning?
10:15:31 <rostayob> well no I can't.
10:18:37 <ddarius> You can't get 'names' out of functions, so pair the functions up with their names.  Eventually someone has to know that they are actually passing in a field and which.
10:19:34 <rostayob> ddarius: yeah but how can I do that, even in TH?
10:21:26 <rostayob> ddarius: I guess I can pair expressions to strings, but I can't "remember" it, right? I can have something like funNames :: [(Expr, String)], funNames = $(genNames Foo)
10:21:54 <Fuco> how's this function called in lambdabot? \f g x -> f x (g x)
10:22:01 <copumpkin> :t ap
10:22:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:22:06 <Fuco> ah, yea
10:22:12 <copumpkin> or <*>
10:22:15 <Fuco> it's called dist at our lectures
10:22:36 <copumpkin> it's also called the S combinator
10:22:38 <copumpkin> for functions
10:22:42 <copumpkin> ap and <*> are more general
10:22:43 <Fuco> yea
10:23:53 <Fuco> oh these supergeneral types from lambdabot are sometimes confusing me :P
10:26:26 <Fuco> shouldn't it take two functions?
10:26:27 <byorgey> lambdabot does have some things that are more generalized than normal, but that is the normal type of ap in the standard library
10:26:45 <byorgey> Fuco: in this particular case m = (e ->)
10:26:59 <byorgey> so  m (a -> b) -> m a -> m b  === (e -> a -> b) -> (e -> a) -> (e -> b)
10:27:17 <Fuco> oh
10:27:34 <Fuco> wait, what? :D so -> is instance of monad?
10:27:40 <byorgey> (->) e  is
10:27:50 <byorgey> not (->) by itself
10:28:02 <byorgey> but yes, it's neat =)
10:28:37 <byorgey> if you have never seen this before you should go work out what  return and (>>=) and join are for this monad instance
10:28:37 <Axman6> > do { x <- (+2); y <- (*4); return (x,y)} 6
10:28:38 <lambdabot>   <no location info>: parse error on input `6'
10:28:47 <Axman6> > (do { x <- (+2); y <- (*4); return (x,y)}) 6
10:28:47 <lambdabot>   (8,24)
10:29:19 <Fuco> sounds like a fun excercise
10:29:36 <Axman6> > (do { x <- (+2); y <- (*4); return (x*y)}) 6
10:29:37 <lambdabot>   192
10:34:15 <Fuco> this is just too weird :D
10:40:20 <lpsmith> So why doesn't ZonedTime have Eq and Ord instances?
10:41:02 <Axman6> is that a type with timezone information?
10:41:08 <c_wraith> I guess it's ambiguous.
10:41:40 <c_wraith> They probably want you to convert it to a LocalTime or UTCTime first, just to resolve the ambiguity in what you're comparing
10:41:45 <merijn> lpsmith: How would you order two times in different zones?
10:41:45 <Axman6> if so, there's a few different ways to implement it. is 10AM AEST = 12AM GMT? they're at the same time but at different places
10:43:26 <c_wraith> I've long-since come to the conclusion that times should always be stored as UTC internally, and only the presentation and input layers should consider time zones.
10:43:54 <benmachine> c_wraith: but you might want to output times in the same zone as they were input
10:44:13 <lpsmith> Well, I'd say that yes,   10AM AEST = 12AM GMT
10:44:16 <c_wraith> benmachine: never been something I've wanted.
10:44:38 <Fuco> I've long-since come to the conclusion that timezones should be abolished
10:44:48 <benmachine> lpsmith: but they're different :(
10:44:50 * hackagebot enummapset 0.0.1 - IntMap and IntSet with Enum keys/elements.  http://hackage.haskell.org/package/enummapset-0.0.1 (MichalTerepeta)
10:45:08 <benmachine> I would say Eq makes sense but Ord does not
10:45:28 <spirit> what license applies for cabal packages?
10:45:43 <c_wraith> Eq is still ambiguous.  Is it "exactly equal" or just "the same time"?
10:46:02 <c_wraith> spirit: depends on the package.  They all should contain information on how they're licensed
10:46:04 <lpsmith> spirit, what do you mean?   You can choose any license for your own cabal packages
10:46:32 <lpsmith> postgres says they are equal :-P
10:46:38 <c_wraith> so?
10:46:48 <c_wraith> SQL does lots of things wrong.
10:47:06 <lpsmith> postgres fixes a lot of the things that sql did wrong
10:47:10 <c_wraith> The fact is, equality is an ambiguous operation on ZonedTime
10:47:18 <c_wraith> So it's not implemented.
10:47:30 <c_wraith> Convert them to a type that's not ambiguous
10:47:40 <lpsmith> It stores all timestamps in UTC time,  and then stores a timezone per column,  I'm pretty sure
10:47:56 <c_wraith> false.  that's not at all what postgres does!
10:48:02 <spirit> has the graphviz license changed? i'm planning on using graphviz, and the eclipse public license doesn't seem to integrate very well with other open source licenses (i usually use GPL)
10:48:47 <spirit> since there are graphviz wrapper packages, i was wondering how the license change affects those
10:48:55 <c_wraith> spirit: you might find much of hackage doesn't work kindly with the gpl.  lots of folk in haskell-land don't like the gpl much.  But as always, we're not lawyers.  And even if we were, we're not your lawyer.
10:49:24 <spirit> what license do most prefer?
10:49:29 <benmachine> c_wraith: there are multiple possible implementations, but I'd argue that 'identical components' is the only sensible one
10:49:44 <c_wraith> lpsmith: in particular, I can see like 4 different things Eq could mean on ZonedTime...  3 of which would even make sense.
10:49:50 <benmachine> spirit: the BSD licence is most usual
10:49:57 <benmachine> but there are GPL things about
10:50:00 <benmachine> cf. pandoc
10:50:16 <spirit> would bsd be compatible with epl?
10:50:16 <lpsmith> well,  there are multiple concepts of identity, I agree, but why not pick one as the most sensible default and then offer others as well
10:50:28 <c_wraith> because typeclasses are global
10:50:50 <benmachine> in considering what meaning to give Eq, I would consider the functions based on it
10:50:54 <benmachine> e.g. 'delete'
10:52:14 <Nibble> what does the @ do
10:52:19 <c_wraith> lpsmith: it's general courtesy to not define an instance when there are multiple good definitions of it.  It forces people to actually think about what they want and do the right thing, instead of doing something that looks like it should work, and maybe even passes some quick tests, but isn't actually what is expected
10:52:32 <Nibble> like in this context, s@(Sumthing1 x y)
10:52:46 <benmachine> c_wraith: there are two reasonable instances of Ord (a,b)
10:52:50 <c_wraith> Nibble: it binds the name s to the entire pattern match
10:52:56 <Nibble> oh
10:53:08 <Nibble> almost like creating a data type to contain it?
10:53:11 <lpsmith> c_wraith, I'm not sure I agree with that philosophy
10:53:46 <benmachine> Nibble: nothing is created, just a new name is given to the existing thing
10:53:50 <c_wraith> Nibble: No, not at all.  It's just a name
10:54:16 <Nibble> so ....... magic?
10:54:46 <c_wraith> Is naming yourself Nibble magic?
10:54:59 <lpsmith> c_wraith, that *is* what postgres does with the timestamp with time zone type
10:55:32 <Axman6> Nibble: it's like foo s = case s of (Sumthing1 x y) -> ...
10:55:39 <c_wraith> Nibble: It's just binding an extra name in the pattern match...  To the entire thing it matches
10:55:48 <Axman6> s represents the whole Sumthing1 x y
10:56:12 <Nibble> does it represent the computation (is that the right word? I think it is?) or the value
10:56:41 <Nibble> but I understand what it does
10:56:49 <Nibble> thanks again fier das help
10:58:04 <sizzler> if you want to define a type to hold values like these [Left 1, Right [Left 1, Right [Right [Left 1]]]] how would you define it recursively
10:59:04 <Axman6> type Foo x = Either x (Foo x)
10:59:07 <Axman6> uh
10:59:11 <Axman6> type Foo x = Either x [Foo x]
10:59:11 <c_wraith> doesn't work
10:59:15 <Axman6> i think
10:59:19 <c_wraith> because type synonyms can't be recursive
10:59:23 <c_wraith> You need newtype or data
10:59:27 <Axman6> ah, guess you can't
10:59:34 <john> Hi there!
10:59:34 <Axman6> wait, you sure?
10:59:50 <c_wraith> I'm sure type synonyms can't be recursive
10:59:55 <john> Is there any Haskell library fro web programming?
11:00:02 <Axman6> I'd never run into that
11:00:02 <john> for
11:00:31 <Axman6> john: lots, snap, happstack, yesod, probably more, but those are the big ones
11:00:53 <john> Thanks, I'll google for it
11:00:54 <sizzler> I did try this one  Foo x = Either x [Foo x] first, but wasnt working.. will try data decl
11:01:16 <Axman6> sizzler: use a newtype like c_wraith said
11:01:34 <sizzler> trying
11:01:50 <Axman6> newtype Foo x = Foo (Either x [Foo x])
11:02:02 <Fuco> what is the priority of -> in type declaration?
11:02:03 <c_wraith> This sort of thing is most commonly expressed as a data type for nested lists
11:02:04 <Nibble> that looks like a tree
11:02:10 <c_wraith> it's a rose tree
11:02:10 <Fuco> would a -> b -> c be the same as a -> (b -> c)?
11:02:21 <Nibble> Fuco: y
11:02:24 <azaq23> Fuco: yes, -> is right associative
11:02:29 <Fuco> ok thanks
11:02:57 <Fuco> makes sense with the partial application and all
11:03:04 <Fuco> it takes a and produce a function (b -> c)
11:03:10 <Nibble> here is a (stupid) question, infix always have higher predecence than outfix(or what it is called again...)
11:03:27 <Axman6> prefix?
11:03:32 <Nibble> yeah
11:03:38 <Fuco> I don't think that matters
11:03:38 <Axman6> and no
11:03:58 <azaq23> Fuco: yes, one of the reasons it is important and pretty elegant
11:04:02 <Axman6> f x `g` h y is the same as g (f x) (h y)
11:04:35 <Nibble> Fuco: don't you mean currying
11:04:43 <Axman6> not f (g x h) y or... something else
11:05:23 <john> Another question. Is Haskell modern language or may be I should try to learn anything else?
11:05:31 <Nibble> john: learn C
11:05:35 <Nibble> that is nice and modern
11:05:39 <Fuco> Nibble: it might be called that, I don't know :P
11:05:52 <Axman6> john: it's 20 years old. you should definitely learn it though
11:05:53 <merijn> john: Define modern?
11:05:58 <Axman6> john: do you know any other languages?
11:06:05 <Fuco> python is 20 years old and it's considered modern
11:06:05 <Nibble> haskell's ideas are older than those in C
11:06:05 <john> Nibble: :) Functional language
11:06:15 <john> Scala, Clojure, F#
11:06:23 <Nibble> depends
11:06:27 <benmachine> Axman6: I wouldn't say the modern haskell is 20 years old
11:06:28 <Nibble> haskell if you are hardcore
11:06:29 <azaq23> Nibble: IIRC currying is when you transform a n ary function into a function producing n - 1 functions of 1 arity. currying is an example of partial application.
11:06:29 <merijn> Haskell is 21 years old, Erlang 25, Python 20 years and Ruby/Java are both approximately 15 years old :p
11:06:31 <benmachine> (because it's 21)
11:06:57 <merijn> So, modern is quite a wide notion :p
11:07:10 <Axman6> i would call haskell modern, far more than python, we've got things like super easy parallelism and concurrency, software transactional memory, one of the most advanced type systems of any language, and much more
11:07:13 <Fuco> well if you want to get a real job, scala would be better than haskell :)
11:07:18 <Nibble> modern in this context means "Was the person who designed the language drunk or not"
11:07:31 <merijn> Fuco: I would argue that then you'd be better of getting a python job
11:07:32 <Fuco> there's about 43 people in the world who care about haskell :D
11:07:34 <Nibble> if not, it is modern, if, then it is PHP
11:07:39 <Axman6> my understanding of scala is that they keep changing it and breaking things
11:07:53 <Nibble> Axman6: that applies to haskell also, far too well
11:07:57 <merijn> Or maybe Clojure, as far as Lisps go, that looks pretty cool
11:08:02 <Nibble>            
11:08:13 <Axman6> Nibble:  not really, the language doesn't change much at all
11:08:23 <Nibble> how did that happen? Axman6, I meant the implementations
11:08:44 <Axman6> it took 21 years to for us to remove n+k patterns for example
11:08:46 <Fuco> http://steve-yegge.blogspot.com/2010/12/haskell-researchers-announce-discovery.html :D
11:08:48 <merijn> john: I would recommend Haskell over F# or Scala, because those two try to be similar to Haskell, but Haskell is nicer. (And once you know haskell learning scala/F# should be easy)
11:09:13 <merijn> john: Clojure (as a Lisp) looks pretty interesting, but is radically different from the other two. I still plan on learning that eventually
11:09:41 <copumpkin> Fuco: yeah, we've never seen that before, thanks
11:09:51 <copumpkin> it's just as funny now as the first dozen times I saw it
11:09:53 <Axman6> Fuco: why link to trolls?
11:10:10 <merijn> I wouldn't say Steve Yegge is a troll
11:10:21 <Axman6> could have linked to the non-sense harrop spouts
11:10:23 <Fuco> ok ok sorry
11:10:35 <john> merijin: Thanks. I thought about it. For instance. C# more modern than Java and Java has ugly syntax.
11:10:59 <merijn> john: Haskell is to Scala/F# as C# is to Java :>
11:11:01 <Nibble> Java, my first experience: Programs use 1GiB of RAM. Slow
11:11:16 <Fuco> Nibble: 10 years ago?
11:11:19 <Nibble> nope
11:11:23 <Fuco> Java is as fast as anything these days
11:11:24 <Axman6> Nibble: you can do that in any language if you don't know what you're doing
11:11:29 <john> merijin: :) So, then I would learn Haskell
11:11:46 <merijn> john: I highly recommend Learn You A Haskell for people just starting out. (And now it has a print version to!)
11:11:46 <Nibble> Axman6: It is a lot easier with stupid garbage collectors
11:11:51 <monochrom> 10 years ago JVM already needed 1GB RAM for 1000 threads or something :)
11:11:52 <merijn> @where LYAH
11:11:52 <lambdabot> http://www.learnyouahaskell.com/
11:12:12 <newsham> except c# came after java and tried to imitate and refine it
11:12:12 <monochrom> maybe 10000 threads, I forgot.
11:12:17 <newsham> but scala and f# both came after haskell
11:12:21 <benmachine> Axman6: in fairness, when you screw up your C memory management, it won't eat a GiB of RAM, it'll just crash instead \o/
11:12:44 <merijn> newsham: Your problem from being stuck with linear concepts of time and causality :)
11:12:44 * monochrom comes after newsham! (as in, chase, haunt)
11:12:58 <Nibble> @where epicness
11:12:58 <lambdabot> I know nothing about epicness.
11:13:03 <Nibble> @where sex
11:13:03 <lambdabot> I know nothing about sex.
11:13:07 <Nibble> hehehehehehehehehehehehe
11:13:21 <Axman6> benmachine: making partial correctness easy to prove in C :P
11:13:26 <john> merijin: Thanks. I'll check this link
11:13:27 <azaq23> @girl19
11:13:27 <lambdabot> I have stolen about 50 msn and yahoo accounts
11:14:04 * Axman6 -> sleep
11:14:10 <Fuco> this discussion is getting out of hands
11:14:24 <merijn> john: If you already have programming experience it starts a bit slow, but it covers the major peculiarities of functional programming quite well and understandable :)
11:14:39 <newsham> "Space usage is an area of uncertainty for Haskell programmers. Recent comments on the Haskell mailing list include \It is di cult to understand how my program relates to memory management" and The space behaviour of Haskell programs is often very subtle". So the average user is almost totally in the dark and even the more experienced can be mystied by space usage.
11:15:27 <Axman6> dealing with space usage takes practice
11:15:30 <john> merijn: Nowdays I'm C# programmer. But I want to learn any more interesting.
11:15:39 <Nibble> Dealing with space usage is irrelevant
11:15:46 <Axman6> john: it doesn't get more interesting that haskell imo
11:15:57 <newsham> nibble: so is time usage.  if the equation is right on paper, thats all that matters! ;-)
11:16:05 <sizzler> the problem with some of the documentation is you don't get the motivation for it? Looking at this http://www.haskell.org/haskellwiki/Newtype why we have two things (newtype and data)
11:16:12 <Axman6> (there are languages like Agda and Coq, but those are less interesting to me)
11:16:22 <sizzler> I mean it is not clear when to use either
11:16:25 <john> merijn: C# is boring
11:16:40 <sizzler> or more correctly why it is that way
11:17:07 <newsham> sometimes boring is a good feature in a language
11:17:08 <Nibble> does haskell have logical or
11:17:14 <sizzler> I dont see any conceptual meaning for having newtype and data.. anybody knows the conceptual reason?
11:17:20 <newsham> > True || False
11:17:20 <lambdabot>   True
11:17:39 <Axman6> > True || undefined
11:17:40 <lambdabot>   True
11:18:01 <codolio> newtype is guaranteed to be isomorphic to the underlying type.
11:18:02 <newsham> sizzler: for one thing, newtype can automatically derive subclasses of the type its aliasing.
11:18:23 <merijn> sizzler: I want to use an Int but overwrite one of the typeclasses Int currently has without having to reimplement Int entirely. Data can't help, newtype can
11:18:26 <Saizan> sizzler: you can't get the same semantics with data
11:18:32 <newsham> newtype MyNum = MyNum { x :: Int } deriving Num
11:18:40 <Saizan> even without newtype deriving.
11:18:42 <merijn> john: Haskell will melt your brain :)
11:19:00 <spidermario> and then rebuild it stronger :)
11:19:01 <roconnor> newyype Void = Void deriving Monoid -- does this work?
11:19:05 <newsham> nah, haskell will just beat up your brain like a drill sargent, and then get it into shape :)
11:19:06 <roconnor> *newtype
11:19:14 <roconnor> er
11:19:22 <roconnor> newtype Void = Void Void deriving Monoid -- does this work?
11:19:34 <Axman6> spidermario: newtype has no runtime overhead, it's exactly the same at runtime as the type it's wrapping
11:19:38 <newsham> roconnor: i bet you could find out.
11:19:41 <Axman6> uh, sizzler 
11:19:53 <roconnor> newsham: I'd have to know what the GeneralizedNewtypeDeriving flag is
11:20:03 <sizzler> thanks all.. will take time to digest it
11:20:05 <merijn> john: It can take a while before everything clicks (functional programming didn't "stick" until my 5th attempt at learning it :p). But once it does you'll have a matrix "I am the one" moment about programming :p
11:20:50 <newsham> then you'll realize that you can play lots of golf with haskell
11:20:56 <sizzler> merijn your example looks what I expected to be in that documentation page
11:21:01 <john> merijn: What about development environment. What do you use, vim?
11:21:13 <benmachine> sizzler: p.s. I wrote most of that wiki article, iirc
11:21:23 <Saizan> sizzler: newtype N = N X; (case undefined of N _ -> ()) == () vs. data D = D X; (case undefined of D _ -> ()) == undefined
11:21:28 <newsham> john: I use vim, sometimes ghci, sometimes lambdabot
11:21:48 <newsham> john: you'll probably want to use vim when you write your first monad tutorial.
11:22:22 <michaelh> here's a vote for textmate. has a nice haskell bundle.
11:22:23 <merijn> john: I just use vim and a lot of ghci/lambdabot
11:22:25 <sizzler> benmachine, it would be great if you could add examples for motivation to that page
11:22:32 <merijn> Also, Hoogle
11:22:52 <newsham> google for ghc docs/api docs
11:22:55 <merijn> Lets you search for Haskell functions/packages by type signature
11:23:31 <benmachine> sizzler: hmm, good point
11:23:35 <newsham> also you'll want to get friendly with cabal and hackage
11:23:42 <merijn> (http://haskell.org/hoogle/ that is)
11:23:53 <newsham> and you might wanna spend some time with the orielly haskell book (which you can read online)
11:24:02 <merijn> I didn't use cabal/hackage as much as first
11:24:40 <merijn> newsham: I tend to recommend Learn You A Haskell first and then go on with oreilly's Real World Haskell. I think the basic explanations in LYAH are better and the RWH examples can get kinda hairy
11:25:05 <newsham> i think for early learning, "two dozen easy lessons" is a nice intro to haskell and functional programming
11:25:30 <Nibble> This have probably been asked several times before but, how feasible is haskell for a game engine?
11:25:38 <newsham> i looked at lyah very late, but i was never very impressed by it.  harder to judge it though because i already had a good grasp on haskell when i saw it
11:25:53 <newsham> nibble: it can be done.. might not be the obvious choice.
11:26:15 <merijn> Nibble: Depends on the type of game also
11:26:57 <Nibble> lets say something like crysis but ignoring performance
11:27:09 <Nibble> just how feasible it is to _write_ not to run
11:27:10 <Axman6> then anything's possible
11:27:15 <newsham> people have written first person shooters in haskell
11:27:22 <Nibble> newsham: I saw a few scrots
11:27:37 <Nibble> looked ok, does anyone know if he released the engine
11:28:19 <Axman6> it's all open source i believe
11:28:36 <benmachine> it's all released but I think outdated by now
11:28:49 <benmachine> don't know if anyone ever successfully converted it to new opengl
11:45:58 <Fuco> can someone explain why "curry id" has type a -> b -> (a,b) ? curry is ((a,b) -> c) -> a -> b -> c and id is a -> a... so how can I even apply id to curry?
11:46:39 <merijn> Fuco: Type a can also be type (b,c)
11:46:52 <Fuco> oh, right
11:46:54 <merijn> i.e. id works on tuples
11:47:10 <Fuco> I see, thanks :P
11:47:57 <Fuco> so if I subtitude a for (b,c) than id is (b,c) -> (b,c) which after currying is b -> c -> (b,c)
11:48:04 <Fuco> this is awesome
11:48:11 <merijn> Fuco: Correct
11:48:25 <Axman6> > curry id 1 2
11:48:26 <lambdabot>   (1,2)
11:49:04 <Jafet> @pl \x y -> (x,y)
11:49:04 <lambdabot> (,)
11:49:08 <Jafet> @pl curry id
11:49:08 <lambdabot> curry id
11:49:19 <Jafet> @pl \x y -> curry id x y
11:49:19 <lambdabot> curry id
11:49:29 <Axman6> @unpl curry id
11:49:29 <lambdabot> curry (\ a -> a)
11:49:34 <Axman6> weak
11:49:47 <ddarius> curry id is a rather important function.  If Haskell was nicer, it would be the unit of the adjunction defining exponentials (first-class functions.)
11:50:06 <ddarius> uncurry id is also important, though it's more obvious why.
11:51:30 <Fuco> :t uncurry id
11:51:31 <lambdabot> forall b c. (b -> c, b) -> c
11:51:51 <Fuco> heh, I've never seen a type declaration like that (b -> c, d)
11:52:08 <Twey> Oh, haha
11:53:49 <Twey> I was trying to figure it out in my head: uncurry requires a three-argument function, so id must be used with a type that's got an argument, so id :: (a -> b) -> a -> b, so uncurry id :: (a -> b, a) -> b
11:53:56 <Fuco> OH
11:54:02 <Fuco> it's a function and a value tuple
11:54:10 <Fuco> damnit this is tricky
11:54:13 <Twey> Should've just thought of the function-application binary id
11:58:02 <Ondra> Hi. I've got a problem - few days ago I installed successfully SourceGraph on a laptop. Today I installed it on a PC, but running it gives me a lot of errors like "SourceGraph: fd:4: hClose: resource vanished (Broken pipe)", can anybody help me please?
11:59:50 <benmachine> Ondra: I vaguely remember getting something like this, and it being a real pain to work out
12:00:01 <benmachine> Ondra: but it turned out to be that I was missing an external tool
12:00:11 <benmachine> possibly graphviz or something
12:00:35 <Ondra> Thanks, I'll check it.
12:06:04 <niteria> how to get (\a b -> compare (snd a) (snd b)) through composition?
12:06:32 <opqdonut> niteria: comparing snd
12:06:36 <opqdonut> @source comparing
12:06:36 <lambdabot> comparing not available
12:06:56 <nlogax> @pl  (\a b -> compare (snd a) (snd b)) 
12:06:56 <lambdabot> (. snd) . compare . snd
12:07:17 <Ondra> Thanks, benmachine, it was really because graphviz was missing, now it works.
12:07:24 <benmachine> :)
12:07:42 <benmachine> I meant to submit a bug report to one of the libraries telling them to improve their error messages
12:07:42 <niteria> wow
12:07:46 <benmachine> but I kinda forgot
12:08:04 <inetic_> hi, I'm trying to understand how memory gets allocated in haskell, I have a simple binary tree "tree n = Node [tree n-1, tree n-1]; tree 0 = Leaf", I would like to have it instantiated in memory all at once (for the sake of testing and profiling), can I do that?
12:08:05 <niteria> is there a list of bot's commands?
12:08:27 <ddarius> @list
12:08:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:08:49 <opqdonut> inetic_: look up DeepSeq for stuff like this
12:09:00 <opqdonut> inetic_: or Control.Parallel.Strategies
12:09:05 <benmachine> inetic_: this kind of thing is a bit tricky; haskell is a language deliberately hazy about details so that compilers can implement radical optimisations
12:09:26 <benmachine> inetic_: but in practical terms, printing out the whole tree would be an easy way to ensure it is all evaluated
12:09:39 <benmachine> (deepseq would work too)
12:10:41 <niteria> @unpl (. snd) . compare . snd
12:10:41 <lambdabot> (\ d j -> compare (snd d) (snd j))
12:10:49 <niteria> cool
12:16:39 <parcs> :t compare `on` snd
12:16:39 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
12:19:36 <Fuco> :t (curry id .)
12:19:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> (a, b))
12:20:27 <ddarius> :t fmap (curry id)
12:20:28 <Fuco> can someone un-functor it? :P
12:20:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> (a, b))
12:21:19 <niteria> what's const bottom?
12:21:36 <ourfrank> Can the Hint package be used load precompiled modules for which no source code is available?
12:21:37 <niteria> how is it different from normal bottom?
12:21:54 <Fuco> ok wait a second... fmap is (a -> b) -> f a -> f b, so this applies (curry id) to fmap
12:22:01 <Fuco> curry id is a -> b -> (a,b)
12:22:02 <dmwit> Fuco: (e -> a) -> (e -> b -> (a, b))
12:22:10 <Fuco> I almost got it!
12:22:29 <Fuco> how did you get from (const id .) to fmap (const id)
12:22:41 <dmwit> Fuco: In lambdabot, (.) = fmap.
12:22:42 <opqdonut> (.) = fmap in lambdabot
12:22:52 <opqdonut> :t (curry id Prelude..)
12:22:53 <lambdabot> forall b b1 a. (a -> b) -> a -> b1 -> (b, b1)
12:23:01 <Fuco> aha
12:23:02 <opqdonut> that's how you get the normal (.)
12:23:28 <Fuco> well that might explain some confusion I had with LB in priv. msg :P
12:23:48 <Fuco> but the result seems to be the same
12:25:55 <niteria> @source on
12:25:55 <lambdabot> on not available
12:26:34 <dmwit> Fuco: Yes, fmap generalizes (.), so it works anywhere (.) would.
12:26:43 <Fuco> (curry id .) (+1) would be curry (id . (+1)), (id . (+1)) would be just (+1)? so the whole thing should be just curry (+1) ?
12:27:05 <Fuco> :t curry (+1)
12:27:06 <lambdabot> forall a b. (Num a, Num b) => a -> b -> (a, b)
12:27:14 <Fuco> seems to work
12:27:25 <Fuco> > curry (+1) 1 2
12:27:26 <lambdabot>   (2,3)
12:29:31 <brbr> is haskell good with interrupts?
12:29:39 <copumpki_> no
12:30:19 <brbr> because the rte is heavy?
12:30:40 <Twey> Fuco: (curry id .) (+ 1) ⇒ curry id . (+ 1), not curry (id . (+ 1))
12:31:01 <Fuco> hmm
12:31:15 <Fuco> so (curry id .) is ((curry id) .)
12:31:26 <Fuco> not (curry (id .))
12:31:32 <copumpkin> that's generally true
12:31:35 <ddarius> flip (curry id)
12:31:41 <Twey> Fuco: Right
12:31:42 <ddarius> :t flip (curry id)
12:31:43 <lambdabot> forall a a1. a1 -> a -> (a, a1)
12:31:51 <Twey> Function application binds tighter than any operator
12:31:55 <ddarius> :t uncurry (flip (curry id))
12:31:56 <lambdabot> forall b a. (a, b) -> (b, a)
12:32:01 <Twey> (though not some syntax, like record syntax)
12:32:11 <ddarius> :t uncurry . flip . curry
12:32:12 <lambdabot> forall a b c. ((b, a) -> c) -> (a, b) -> c
12:33:04 <Fuco> ah these silly homeworks
12:33:22 <Fuco> friend sent me this thing and I spent some 40 minutes on it already :D
12:33:35 <Fuco> but it's fun! :)
12:34:02 <Fuco> well, more like an hour
12:34:11 <Fuco> but I'm getting close
12:44:08 <Anm> Any help appreicated on a StackOverflow question: http://tinyurl.com/3hcegs2
12:44:44 <Anm> Full file here: http://hpaste.org/45223/untitled_2858
12:47:26 <TomMD> Anm: Augusstus has it right
12:47:48 <rostayob> what does this mean: Stage error: `n' is bound at stage 2 but used at stage 1 ?
12:48:09 <TomMD> Anm: I just added the (err :: E.SomeException) on ~line 95.  Fixed the alignment for the do notation and added the first line of "> {-# LANGUAGE ScopedTypeVariables #-}"
12:48:14 <TomMD> Anm: Compiles fine
12:48:55 <Anm> like... print (err :: SomeException)?
12:49:14 * hackagebot elerea 2.2.0 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.2.0 (GergelyPatai)
12:49:17 <TomMD> Anm: No, no no.
12:49:27 <Anm> Sorry... I'm VERY new to haskell
12:49:33 <TomMD> Anm: (\(err :: E.SomeException) -> ... rest of catch handler ...)
12:49:48 <Anm> Ahh... parathensis in the lambda
12:49:54 <Anm> that is what I was missing
12:50:06 <TomMD> ;-)
12:51:26 <Anm> How common is the use of the ScopedTypeSignature?
12:51:47 <Anm> Sorry.. ScopedTypedVariables
12:51:48 <TomMD> ScopedTypeVariables are rather common
12:52:36 <TomMD> http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables
12:52:40 <TomMD> anm ^^^
12:52:51 <TomMD> It is proposed to become part of the official "Haskell" language.
12:52:56 <rostayob> also, in template haskell, how can I get the Q Exp from a Name?
12:53:12 <c_wraith> :t varE
12:53:13 <lambdabot> Not in scope: `varE'
12:53:25 <c_wraith> eh, whatever.  varE is what you want.
12:53:38 <rostayob> c_wraith: thanks
12:53:41 <c_wraith> But it's not something extracted from a name, it's something built from a name
12:53:46 <lpsmith> ScopedTypeVariables also make it possible to write types on subexpressions that were difficult/impossible to do before
12:53:59 <rostayob> c_wraith: maybe you mean VarE, the constructor
12:54:04 <c_wraith> nope
12:54:09 <c_wraith> you said Q Exp
12:54:11 <rostayob> yep
12:54:12 <c_wraith> that's varE
12:54:19 <c_wraith> VarE would just give you Exp
12:54:20 <TomMD> lpsmith: Tell me about it!  The Tagged and Proxy modules are great and all but it is complicated to get done what is easy with scoped type variables.
12:54:24 <Anm> Thanks Tom... I'll add that to my to-read list
12:54:32 <c_wraith> of course, varE = return . VarE
12:54:39 <rostayob> c_wraith: yeah that's the problem I had... I couldn't find varE lol
12:54:41 <rostayob> thanks
12:56:15 * hackagebot elerea-examples 2.2.0 - Example applications for Elerea  http://hackage.haskell.org/package/elerea-examples-2.2.0 (GergelyPatai)
12:57:38 <lpsmith> erg,  I'm growing less and less keen on the time module
12:58:22 <rovar> I have a ReaderT over a Network.Abstract.NetworkIO  and ghc is complaining about a ton of missing instances for Control.Monad.Context.Context 
12:58:36 <rovar> and other things.. is there any automated way to get rid of such things?
12:59:47 <saati> hi, could you tell me what is a good haskell book for someone who has seen fp before?
13:01:12 <rovar> learnyouahaskell 
13:01:15 * hackagebot dow 0.2.3 - Dungeons of Wor  http://hackage.haskell.org/package/dow-0.2.3 (GergelyPatai)
13:01:42 <saati> rovar: thank you
13:02:02 <Anm> saati: As a noob, I've been reading LearnYouAHaskell this week, and am very impressed with it
13:02:15 <Anm> my background was dabllings in clojure
13:05:01 <ozataman> hi all - what constructor/data-type does stg_ap_1_upd_info signify exactly?
13:15:19 <benmachine> ozataman: sounds evil. where did you find that name?
13:16:04 <ozataman> benmachine: heap profiling with -hd and -hy. I suspect it is from a list being appended to over and over during a mapM_ over a StateT computation
13:16:10 <rostayob> ok... I'm getting quite confused with templatehaskell. why's that wrong: getField n = [| \p -> u (nameBase n) =: $(varE n) p |] ?
13:16:25 <rostayob> :t nameBase
13:16:26 <lambdabot> Not in scope: `nameBase'
13:16:43 <rostayob> well nameBase :: Name -> String
13:16:50 <benmachine> ozataman: oh, I'm afraid I don't know much about that kind of stuff
13:17:05 <benmachine> rostayob: what's the error?
13:17:25 <rostayob> No instance for (Language.Haskell.TH.Syntax.Lift Name)
13:17:27 <rostayob>       arising from a use of `n'
13:17:45 <kevinburke> is there a style guide for haskell? i'm used to keeping lines under 80 chars, any tips for doing so?
13:17:51 <benmachine> lpsmith: I'm not sure if it's been proven but it's my belief that ScopedTypeVariables is never necessary, though it often makes things more convenient
13:17:57 <benmachine> (sometimes much more)
13:18:00 <ozataman> I also keep getting a stack overflow
13:18:08 <rostayob> benmachine: the problem is in nameBase n
13:18:44 <benmachine> rostayob: right. the Lift class is what TH uses to take a datatype and get a TH representation of it
13:19:00 <ozataman> kevinburke: tibbe has a good one -> https://github.com/tibbe/haskell-style-guide
13:19:07 <benmachine> rostayob: annoyingly, a lot of instances of the TH datatypes themselves are missing
13:19:11 <rostayob> benmachine: yes but there should be no Name around.
13:19:18 <rostayob> since nameBase converts it to a string
13:19:30 <benmachine> rostayob: sure there is - the [| |] syntax produces an AST of the application of nameBase to n
13:19:56 <rostayob> ohh right.
13:20:11 <benmachine> AppE (thing representing nameBase) (thing representing n)
13:20:24 <benmachine> so you need to be able to go n -> thing representing n
13:20:46 <benmachine> I've used this package to help with this sort of thing: http://hackage.haskell.org/package/th-lift
13:20:51 <benmachine> but beware of orphan instances
13:20:51 <rostayob> benmachine: so what do I do? create the structure by hand?
13:21:04 <rostayob> I mean I could ditch quasi quotes
13:21:11 <benmachine> rostayob: Lift instances are often quite simple to write
13:22:07 <rostayob> benmachine: also, I'm not sure I can do what I want to do. basically I want to have a type foo
13:22:15 <rostayob> and I want to have a function
13:22:52 <kevinburke> ozataman: thanks
13:23:09 <rostayob> that given a list of Name that refer to a function (Foo -> a) I want to convert a to a string and have a list of [ (Name, converted_a) ]
13:23:24 <rostayob> I don't know if that is clear :P
13:23:59 <benmachine> hmm, with repeated uses of reify?
13:24:16 <rostayob> i mean if I have Foo { one :: String, two :: String} I want to be able to do $(gen 'one) that gives me (\f -> ["one", one f])
13:24:53 <benmachine> rostayob: sounds reasonable
13:24:58 <rostayob> benmachine: no I don't need to use reify, i'm happy enough with nameBase
13:25:07 <rostayob> well I'm not able to do it, but I started TH like 1 hr ago
13:25:14 <rostayob> and my brain is melting I believe
13:26:17 <rostayob> benmachine:  but it's possible right, I'm not running into some logical problem here
13:26:38 <rostayob> considering that TH is in one pass
13:26:56 <benmachine> rostayob: I'm not sure if it's possible or not. sometimes TH surprises you with what isn't possible
13:27:46 <benmachine> rostayob: I'm not sure how to take a name and get the associated function
13:27:53 <benmachine> for the second element of the tuple
13:27:59 <rostayob> benmachine: ok, then I'll investigate
13:28:09 <rostayob> but I feel that something is wrong ehe
13:28:37 <benmachine> rostayob: I tried reify and it gets a Maybe Decl, but I don't know when it's Nothing/Just
13:28:55 <rostayob> benmachine: where would you need reify there?
13:30:01 <rostayob> anyway, thank's to your tip, this is the "single" version, and it works: getField n = [| \p -> (nameBase n, $(varE n) p) |]
13:37:40 <rovar> http://hpaste.org/45224/instances
13:38:05 <rovar> it seems silly for me to have  to define instances of these for the IO monad.. is there a way to auto create them?
13:38:32 <rovar> that is Control.Monad.Context
13:38:56 <torl> what's the best book,the one that goes more in-detail?
13:39:07 <rovar> detail in which area?
13:39:08 <dmwit> More in-detail than what?
13:39:33 <rovar> Real world haskell is good for practical things.. but glosses over more academic topics.. 
13:40:40 <torl> which teaches you the best habits of coding
13:41:49 <rovar> probably the newest book
13:41:53 <rovar> which would be learnyou
13:42:51 <torl> this: http://learnyouahaskell.com/?
13:43:16 <rovar> yep
13:48:03 <torl> how do i exit ghci?
13:48:31 <saati> control-d?
13:49:15 <TomMD> :q
13:49:30 <torl> that looks like vi
13:49:38 <monochrom> control-d, :quit
13:50:00 <monochrom> there are also other ways such as kill
13:51:12 <rostayob> how do I generate a unique *Name* with TH? dyn generates an Exp
13:51:14 <Jafet> raiseSignal sigKILL
13:51:22 <parcs> the easiest way to quit ghci is to make it segfault. :P
13:51:29 <rostayob> wihtout quasi quoting
13:58:39 <kevinburke> wow, -Wall and -Werror are great - catching tons of bugs, missing type signatures and things that should be seq'd so they execute
13:59:19 <dmwit> The phrase "things that should be seq'd so they execute" worries me greatly.
14:03:43 <Jafet> In Soviet Russia, execution program schedules you!
14:04:13 <mornfall> dmwit: To each his own... :)
14:04:36 <mornfall> (And, live by the sword, die by the sword probably applies, too, after a fashion.)
14:05:16 <kevinburke> dmwit: agree side effects are bad. at the moment though, need to make sure the program runs the way I hope it does, will fix the side-effecting stuff later
14:06:10 <mornfall> Sounds like a shortcut to hell. :P
14:08:13 <lpsmith> Yeah,  I've never been too pleased with -Wall
14:08:29 <lpsmith> the warnings against variable shadowing in particular annoy me greatly
14:09:36 <luite> those warnings did catch a few bugs for me :)
14:09:51 <mornfall> lpsmith: They are a mixed blessing.
14:09:57 <luite> mostly false alarm though
14:09:58 <mornfall> Variable shadowing, even with a type system, can be fatal.
14:10:12 <lpsmith> See,  a warning about variable shadowing should be when you take working code,  add a binding,  and change the meaning of already-existing identifier
14:10:30 <luite> but I still use -Wall in my flymake config
14:10:42 <lpsmith> that has to be coming from a sufficiently intellegent version control system though
14:10:53 <dmwit> kevinburke: I was afraid of that. You're using unsafePerformIO without doing the requisite proofs, aren't you?
14:10:53 <ozataman> is there a way to save core output with cabal?
14:11:03 <dmwit> kevinburke: You may not regret it now, but you will before long.
14:11:17 <lpsmith> variable shadowing is mostly harmless,  and can even be useful
14:11:23 <kevinburke> no
14:11:38 <kevinburke> um, keeping track of variable names in a map
14:11:59 <kevinburke> so the side effect is essentially, call the variable name recording method
14:12:45 <lpsmith> on the other hand,  I find a common source of not-immediately-obvious errors is writing  let x = { expression involving x } when I really didn't mean to
14:12:50 <lpsmith> and -Wall doesn't do anything about that
14:13:07 <dmwit> kevinburke: eh?
14:13:40 <Jafet> "It's okay to use unsafePerformIO for debugging"
14:16:03 <kevinburke> dmwit: one place where i used it is here. let's say i'm trying to type check everything inside a statement block - i want to record the variables  that are created inside the block, but throw them away at the end, so as i walk through the statements in the statement block i update the scope, but return the old scope at the end of the block
14:16:25 <kevinburke> that's not a great example
14:16:40 <kevinburke> and as i said, i'm trying to get it to work correctly first, then i'll fix the seq stuff
14:16:54 <lpsmith> yeah, you really don't need unsafePerformIO to do that
14:17:10 <dmwit> lpsmith: I don't think he's unsafePerformingIO
14:17:36 <dmwit> kevinburke: I'm not sure I understand, though. Is the side-effect a call to "error"?
14:17:50 <kevinburke> i'm not using unsafeperformIO
14:18:51 <dmwit> If so, I heartily suggest using Either or Maybe. =)
14:19:21 <kevinburke> Ok
14:26:16 <parcs> aside from the syntactic overhead, when should one use a plain MVar over a TMVar?
14:26:44 <parcs> why*
14:27:35 <parcs> actually, disregard that question
14:27:36 <TomMD> When you want or need to compose with other transactional variables, use a TMVar.  
14:30:18 <tolkad> How do I use monads-tf and mtl?
14:31:03 <parcs> TomMD: thanks
14:31:24 <tolkad> like say I want to use monads-tf, but I'm also using a library which uses mtl
14:31:27 <tolkad> is that possible?
14:31:47 <c_wraith> tolkad, if it can use mtl 2, then it's easy
14:31:57 <c_wraith> if not, it's fiddly.
14:31:59 <parcs> tolkad: PackageImports?
14:32:03 <c_wraith> it may work, it may not
14:32:40 <tolkad> c_wraith: isn't the problem that mtl and monads-tf use the same module names?
14:33:05 <tolkad> mtl2 seems to still share module names with monads-tf
14:33:09 <c_wraith> only if it doesn't work with mtl 2, or those names are part of the public interfaces you use
14:33:25 <c_wraith> mtl 2 just uses transformers.  like monads-tf does
14:33:38 <c_wraith> they same names are actually in the same package, if you use mtl 2
14:33:42 <c_wraith> *the same names
14:34:06 <tolkad> oh so you can use both in different dependency packages
14:34:17 <tolkad> you just can't use both in the same package
14:34:28 <c_wraith> you can with package imports, but avoid that if you can
14:37:06 <ourfrank> Does anyone know if Hint can be used to dynamically load precompiled binaries?
14:37:21 <c_wraith> ...  like installed packages?  it can do that.
14:37:47 <c_wraith> mean non-installed library/.hi file combinations?
14:37:57 <ourfrank> c_wraith: so, it needs to be an installed package? what about non-installed ones?
14:37:59 <ourfrank> yes.
14:37:59 <c_wraith> ...  that should have started with "or do you mean"
14:38:10 <kmc> ourfrank, 'plugins' can do that, i know
14:38:23 <kmc> and was recently refurbished to work with current-ish GHC
14:38:26 <c_wraith> yeah, that's what plugins is designed for.
14:38:26 <parcs> @hoogle getCurrentTime
14:38:26 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
14:38:27 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
14:38:38 <ourfrank> kmc: plugins has difficulty working on windows, I can't get it to work there correctly.
14:38:42 <kmc> there's also the comedy dlopen option
14:38:43 <kmc> oh, sad
14:39:23 <ourfrank> kmc: when you say recently refurbished, do you mean the latest version on hackage?
14:39:23 <c_wraith> eh.  windows is a second-class OS.  don't expect things to work right on it. :)
14:39:47 <ourfrank> c_wraith: I understand, but sadly compatibility with Windows is a must. :/
14:39:53 <kmc> yeah, programming on windows is a way to make things pointlessly harder
14:40:06 <Zao> c_wraith: People with that attitude do not ship software.
14:40:06 <kmc> it's less and less common these days that your code has to actually run on windows
14:40:16 <kmc> are you really writing desktop apps?
14:40:17 <c_wraith> Zao: I ship a lot of software.  to linux servers.
14:40:21 <kmc> or using Windows Server?
14:40:27 <kmc> everything else in the world is UNIX
14:40:30 <Zao> c_wraith: Most people are not you.
14:40:32 <TomMD> Zao: It just depends what you mean by "ship software".  Lots of in-house developers don't worry about Windows.
14:40:53 <kmc> servers, network infrastructure, mobile phones, mac desktops, set-top boxes, toys...
14:40:56 <ourfrank> kmc: it's a desktop app, uses gtk. currently this plugin trouble is the only problem.
14:41:25 <c_wraith> ourfrank, I saw your questions on the mailing list and SO...  Is this *really* something you need the performance of compilation with?
14:41:26 <cocon> what's a good way to explain to management that windows is rubbish? (or another os is better) 
14:41:27 <lambdabot> cocon: You have 1 new message. '/msg lambdabot @messages' to read it.
14:41:34 <Zao> Considering that Windows is one of the supported platforms of the popular Haskell toolchain, one should at least have a big honking disclaimer on libraries that you're an unportable pansy.
14:41:52 <Zao> cocon: All OSes suck.
14:41:55 <TomMD> cocon: Lack of a software repository.
14:41:56 <Zao> cocon: Just at different things.
14:42:02 <TomMD> cocon: Zao's answer is good too.
14:42:04 <ourfrank> c_wraith: sadly, yes. the plugins will be very resource intensive and run much slower when interpreted.
14:42:32 <Twey> cocon: http://linuxcommand.org/learning_the_shell.php maybe?
14:42:40 <TomMD> Zao: If Microsoft gave me a decent (free) windows box with which to test I might actually do that.
14:42:43 <ourfrank> c_wraith: I didn't post to a mailing list, however. :)
14:43:05 <c_wraith> ourfrank: hmm.  someone posted your SO post to the haskell-cafe mailing list then.  Just not you!
14:43:09 <TomMD> Zao: But testing libraries on Windows isn't something I'm willing to incur personal expense to do.
14:43:19 <Zao> TomMD: Fair enough.
14:43:22 <TomMD> (so long as it's hobby development)
14:43:31 <Zao> TomMD: Abstracting the icky platform details away is good form anyway though.
14:43:44 <Zao> And picking portable solutions where such exist.
14:44:18 <TomMD> Zao: yes - absolutely.  And I do try.  But, for an example, crypto-api shipped with a broken guess at Windows cryptAPI for getting random numbers.  It's better now, but required a user to try it and fix my FFI guess work.
14:44:19 <kjslag> Does anyone know if something like 'infix 6.5 *+' is possible?
14:44:42 <Twey> kjslag: No, sorry
14:44:48 <c_wraith> ourfrank: don stewart is very active as a developer.  Have you tried contacting him directly about your issues?
14:45:20 <TomMD> lol, poor dons.
14:45:44 <c_wraith> he listed himself as the maintainer for plugins.  He knows what that's going to result in :)
14:45:48 <TomMD> You did the initial work for your PhD... can you fix up the library for me?
14:45:54 <TomMD> yeah, yeah.  I know.
14:46:01 <ourfrank> c_wraith: I understand that, but I didn't want to bug him immediately. first checking if there's a solution out there already. I guess I'll send him an e-mail, though. :)
14:46:52 <c_wraith> this is a legit bug report. :)
14:52:34 <kmc> kjslag, no :/  you could switch to Agda, which has 100 precedence levels
14:52:44 <kmc> ;)
14:53:05 <kmc> my talk is up at http://www.ugcs.caltech.edu/~keegan/talks/high-level-ffi/talk.html
14:54:19 <aristid> kmc: 100? why not infinitely many? :)
14:54:36 <aristid> "my operator has a precedence of pi"
14:54:45 <kmc> aristid, because then there would be much wanking about which infinite ordinal to use
14:55:05 <kmc> because only ω^ω precedence levels is clearly not enough
14:55:13 <Zao> kmc: Heh, that talk fails horribly in Opera :)
14:55:36 <kmc> time to play "transfinite ordinal or asian emoticon"
14:55:52 <Jafet> There should be a relative ordering of operators
14:55:52 <Zao> http://zao.se/~zao/keeg.png
14:55:53 <kmc> Zao, yeah :/
14:56:11 <kmc> it's based on the "Simple Standards-Based Slide Show System"
14:56:21 <kmc> somehow i think it is falling short of one of those
14:56:28 <kmc> maybe my pandoc has an old version of s5
14:56:40 <kmc> it works in firefox, and is basically readable in other browsers, though not a slide show
14:56:46 <aristid> probably opera is just buggy
14:56:54 <Jafet> @remember kmc time to play "transfinite ordinal or asian emoticon"
14:56:54 <lambdabot> Good to know.
14:56:54 <kmc> also you can hit some button to switch it to being like printed notes
14:57:01 <Jafet> aristid: by definition?
14:57:09 <aristid> well it doesn't work in chrome either
14:57:14 <kmc> i thought opera was super anal about standards compliance
14:57:16 <aristid> so the opera blame game fails there :(
14:57:23 <kmc> yeah i dunno
14:57:24 <aristid> kmc: that's what their marketing says
14:57:28 <kmc> the markdown source is up there
14:57:43 <kmc> if anyone can get pandoc to output s5 html which works in those browsers, i'd much appreciate it
14:58:23 <kmc> or a way to make firefox spit out a pdf of the talk or something
14:58:31 <Jafet> They're just responsible for showing other browser devs what the acid demos are supposed to look like
14:58:31 <kmc> i don't think print-to-file would work but i actually haven't tried
14:58:47 <c_wraith> print-to-file didn't suck last time I tried it
14:59:14 <aristid> kmc: can you maybe just make a PDF?
14:59:27 <aristid> pdf is not sexy but it works
14:59:48 <kmc> i would like to
14:59:59 <kmc> i don't know an easy way, and i'm lazy
15:00:24 <Jafet> Print-to-file is easy.
15:00:24 <kmc> print-to-file in firefox does not do the right thing (just tried)
15:00:25 <kmc> i prefer to give talks from pdf actually
15:00:56 <kmc> the document is a bunch of overlapping divs with javascript to toggle visibility, or something like that
15:01:00 <Jafet> Well, that webpage does not actually make them look like slides
15:01:01 <kmc> it's not going to print properly
15:01:09 <c_wraith> oh.  I have javascript disabled.
15:01:37 <parcs> pandoc seems to ship with a markdown2pdf executable
15:01:39 <parcs> have you tried that?
15:01:44 <Jafet> Unless print-to-file parses javascript, that is
15:01:58 <kmc> Jafet, unless it synthesizes right-arrow keypresses
15:02:12 <Jafet> A silly hack might be to take the current html source from firefox and print that
15:02:21 <kmc> for each page?
15:02:31 <Jafet> Okay, very silly.
15:02:36 <kmc> parcs, i expect that would give me a plain document, not a PDFification of the HTML/CSS/Javascript-based slideshow
15:03:12 <kmc> the problem here is not to convert markdown to pdf
15:03:16 <kmc> markdown knows nothing about slideshows
15:03:34 <parcs> kmc: ah, my elinks doesn't know the difference
15:03:55 <Jafet> The slideshow clips text in my browser anyway
15:04:06 <kmc> yeah
15:04:10 <kmc> it's really not great for distribution
15:04:28 <kmc> it's nice for writing and giving the talk because it's basically literate haskell with minimal markup
15:04:38 <kmc> one of these days i'll learn beamer
15:07:59 <dmwit> beamer is pretty simple
15:08:05 <dmwit> (Although the docs make it look complicated.)
15:08:48 <tswett> dons: congratulations on your mold.
15:12:15 <copumpkin> no sporés for you?
15:13:18 <tswett> Nopë.  I ëvën postëd a mathëmatical proof to thë April Fools' pagë!  Why didn't anyonë sporë më?
15:13:53 * copumpkin sporés tswétt
15:14:12 <tswett> Oh, thank you.  Now I can rèst in pèacè.
15:14:22 <tswett> > ord 'e'
15:14:23 <lambdabot>   101
15:14:46 <tswett> Remind me, what's the inverse of ord?
15:14:55 <kmc> chr
15:14:58 <Jafet> Stop making me try to pronounce them
15:15:00 <kmc> > 1 / ord
15:15:00 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
15:15:01 <lambdabot>    arising from a use o...
15:15:12 <dmwit> fromEnum and toEnum don't require an import...
15:15:26 <tswett> dmwit: but you can't use them if you've been molded.
15:16:28 <tswett> So, I think I'v" ++ chr 101 : " found th" ++ chr 101 : " p" ++ chr 101 : "rf" ++ chr 101 : "ct way to communicat" ++ chr 101 : " without using th" ++ chr 101 : " l" ++ chr 101 : "tt" ++ chr 101 : "r " ++ chr 101 : ".  :P
15:17:09 <kmc> @let f = 'e'
15:17:10 <lambdabot>  Defined.
15:18:28 <aristid> > map (\x -> if ord x == '~' then chr 101 else x) "t~st of anoth~r m~thod"
15:18:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:18:29 <lambdabot>         against inferred type ...
15:18:47 <kmc> @pl (\x -> if ord x == '~' then chr 101 else x)
15:18:47 <lambdabot> flip if' (chr 101) =<< ('~' ==) . ord
15:18:52 <tswett> > map (\x -> if x == '~' then chr 101 else x) "t~st of anoth~r m~thod"
15:18:53 <lambdabot>   "test of another method"
15:19:04 <aristid> argh
15:19:06 <aristid> stupid me :(
15:19:40 <mauke> @undefine
15:20:31 <aristid> mauke: so it's you who killed my unfoldr2!
15:20:54 <mauke> blame kmc
15:21:38 <aristid> @let let unfoldr2 f b = f (\a new_b -> a : unfoldr f new_b) b
15:21:38 <lambdabot>   Parse error: ;
15:21:43 <aristid> @let unfoldr2 f b = f (\a new_b -> a : unfoldr f new_b) b
15:21:43 <lambdabot>  <local>:1:15:
15:21:43 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -...
15:21:49 <aristid> @let unfoldr2 f b = f (\a new_b -> a : unfoldr2 f new_b) b
15:21:50 <lambdabot>  Defined.
15:23:06 <benmachine> :t unfoldr2
15:23:06 <lambdabot> forall a t. ((a -> t -> [a]) -> t -> [a]) -> t -> [a]
15:33:54 <ourfrank> how come there haven't been any new posts in fa.haskell for a month now?
15:35:15 <kmc> what's fa.haskell?
15:35:46 <_bitbucket> What's the best way to get the low-order byte of a Word16 into a Word8?
15:36:19 <kmc> "best"?
15:36:28 <kmc> simplest? fastest? most dangerous? most style points?
15:36:47 <_bitbucket> Er, any way to do it would be helpful
15:36:53 <nominolo> fromIntegral?
15:36:57 <kmc> fromIntegral (x .&. 0xFF)
15:37:00 <kmc> see: Data.Bits
15:37:11 <_bitbucket> Alright, thanks
15:37:14 <hpc> or just fromIntegral, because of how it handles overflows
15:37:17 <hpc> i think
15:37:19 <nominolo> > fromIntegral (0x1234 :: Word16) :: Word8
15:37:19 <lambdabot>   52
15:37:33 <hpc> > 0x34
15:37:33 <lambdabot>   52
15:37:38 <hpc> huzzah!
15:38:34 <kmc> heh
15:38:35 <hpc> the "fastest" way would be the obvious register trick, but that isn't even remotely close to safe :P
15:38:37 <kmc> is that guaranteed to work?
15:39:18 <hpc> kmc: i think so
15:39:28 <hpc> @src Word8
15:39:28 <lambdabot> Source not found. :(
15:39:31 <nominolo> pretty sure that compiles down to the register trick
15:39:39 <nominolo> @hoogle Word8
15:39:39 <lambdabot> Data.Word data Word8
15:39:39 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
15:39:44 <kmc> what's "the register trick"
15:39:47 <nominolo> oh, no web links?
15:40:00 <hpc> kmc: mov val ax; mov val al;
15:40:04 <hpc> er
15:40:05 <nominolo> kmc: movzx eax, value;  mov val, al
15:40:10 <hpc> mov ax val; mov val al;
15:40:25 <hpc> or movzx, whatever that is
15:40:26 <dons> tswett: hehe
15:40:26 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
15:40:39 <nominolo> hpc: movzx -- move and zero-extend sign bit
15:40:42 <hpc> ah, zero extend
15:40:44 <hpc> nifty
15:41:03 <hpc> that seems unnecessary though
15:41:18 <nominolo> I think you can't encode mov ax, foo in x64 mode
15:41:33 <hpc> and i don't think fromIntegral can compile to the register trick
15:41:38 <hpc> :t fromIntegral
15:41:38 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:41:47 <tswett> I came in and thought, "I really should talk about Haskell in here."  But then I saw that you're talking about machine programming, so I stopped thinking that.
15:41:49 <kmc> it's not just the register trick; it has to do boxing
15:41:49 <nominolo> hpc: if inlined it could
15:41:50 <hpc> @src fromIntegral
15:41:50 <lambdabot> fromIntegral = fromInteger . toInteger
15:42:02 <hpc> nominolo: ah, perhaps
15:42:05 <kmc> tswett, surely we wouldn't run Haskell code on an actual machine ;)
15:42:28 <hpc> kmc: machine? that sounds suspiciously like a finite state automata; we don't serve their kind here
15:42:35 <kmc> i don't think register hacks are necessary, i think portable C will do this just as well
15:42:36 <tswett> Of course not.  Haskell should be executed by ribozymes only.
15:42:59 <kmc> what is a ribozyme if not a machine (or part of one)
15:43:08 <nominolo> tswett: there actually is a DNA Haskell project
15:43:14 <nominolo> not sure it's still active, though
15:43:31 <tswett> kmc: hm, good point.
15:51:03 <aristid> @hoogle unfold
15:51:03 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
15:51:03 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
15:51:03 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
15:54:30 <ourfrank> kmc: fa.haskell is a newsgroup. haskell-cafe and haskell-beginners were forwarded to it.
15:55:21 <aristid> @src unfoldr
15:55:21 <lambdabot> unfoldr f b  = case f b of
15:55:21 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
15:55:21 <lambdabot>    Nothing        -> []
15:56:37 <lispy> <sigh> Everytime I want to use cabal I run into bugs like this: http://hackage.haskell.org/trac/hackage/ticket/245
15:58:58 <geheimdienst> ugh, "opened 3 years ago" ...
15:59:00 <geheimdienst> :(
16:01:35 <gienah> milestone is _|_ which in practice I guess here means waiting for someone else to fix it and contribute the fix
16:02:56 <hortzjigshire> how to set up make video4linux in red heat haskell install connet sambafs nautilus in KDE making GIMP ??
16:03:23 <dmwit> I think you might be confused.
16:03:53 <aristid> :t unfoldrM
16:03:54 <lambdabot> Not in scope: `unfoldrM'
16:03:58 <aristid> @hoogle unfoldrM
16:03:58 <lambdabot> No results found
16:04:12 <strawman> @remember hortzjigshire how to set up make video4linux in red heat haskell install connet sambafs nautilus in KDE making GIMP ??
16:04:12 <lambdabot> It is forever etched in my memory.
16:04:13 <hortzjigshire> need making business application compile windows MAC minix QNX red heat for video4linux sambafs in KDE making GIMP !!
16:04:14 <kmc> @quote ubuntu.freebsd
16:04:15 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
16:04:29 <jmcarthur> hortzjigshire: i think a zygohistomorphic prepromorphism makes that easy. give that a shot
16:04:47 <lispy> is that someone's broken chatter bot?
16:04:49 --- mode: ChanServ set +o jmcarthur
16:04:51 <spidermario> I’ve barely understood anything from what you’ve said, hortzjigshire
16:04:52 <spidermario> sorry
16:05:04 <koninkje> @hoogle unfoldM
16:05:04 <lambdabot> No results found
16:05:21 --- mode: jmcarthur set +q *!*@gateway/web/freenode/ip.69.26.207.104
16:05:25 --- mode: jmcarthur set -o jmcarthur
16:05:26 <gienah> lispy: you might be able to use the cabal hooks to workaround it, for example, here is a workaround to a similar issue with c2hs using the cabal hooks: https://github.com/markwright/antlrc/blob/master/Setup.hs
16:05:42 <tolkad> When you use top level do-notation, does ghc actually create a seperate function for every line in the do block?
16:05:45 <kmc> the last time NIXDAEMON-COOL did turn out to have a legit question
16:05:59 <kmc> i think it's some attention-getting tactic
16:06:05 <kmc> tolkad, what do you mean by "top level"
16:06:10 <kmc> and what do you mean by "actually"
16:06:30 <jmcarthur> ghc doesn't support top level do notation, does it?
16:06:42 <kmc> not like JHC's ACIO
16:06:49 <kmc> i assume tolkad means something different
16:06:51 <lispy> Ugh.
16:06:53 <jmcarthur> ACIO is what jumps to mind, yeah
16:06:54 <tolkad> uh like in a file, not in any subexpressions, you have "someName = do …"
16:07:04 <kmc> that's no different from anywhere else
16:07:11 <gienah> lispy: more examples of custom cabal stuff: http://www.moonloop.net/haskell/docs/cbs-custom.html
16:07:13 <tolkad> as for actually, I mean as opposed to some sort of optimization
16:07:16 <lispy> gienah: Thanks.  I've had to do that for other Haskell packages.  I really hate this "feature" of cabal.
16:07:23 <tolkad> kmc: ok, disrgard that part then
16:07:28 <tolkad> disregard*
16:07:33 <kmc> tolkad, the functions thus created are subject to the usual function-inlining optimizations, which are quite aggressive
16:07:45 <jmcarthur> tolkad: ghc has an aggressive optimizer, and lines in do notation are not individual functions in any way
16:08:08 <tolkad> I thought the monad laws might be involved in some way
16:08:13 <kmc> jmcarthur, they aren't?  the right-hand argument of (>>=) is always a function
16:08:26 <kmc> to my knowledge GHC doesn't use monad laws (or any other typeclass laws) for optimization purposes
16:08:29 <kmc> it is entirely ignorant of the laws
16:08:35 <jmcarthur> kmc: sure, but... in an operational sense it's not necessarily
16:08:37 <tolkad> jmcarthur: yeah I wasn't saying each line was an individual function, I meant that each line implies a function
16:08:42 <koninkje> kmc not enturely true
16:08:56 <benmachine> kmc: sometimes there are rewrite rules
16:08:58 <koninkje> SOme of the laws have associated rewrite RULES
16:09:04 <kmc> ah, i see
16:09:08 <koninkje> e.g. for Category
16:09:13 <kmc> tolkad, you can answer your question for a specific case by looking at the Core or assembly output of GHC
16:09:35 <djahandarie> I would feel very unsafe if there was a rewrite rule regarding the Monad laws
16:09:46 <djahandarie> Because every other Monad is not a monad
16:09:47 <koninkje> why?
16:09:57 <tolkad> Another question, when an expression has free variables, barring optimization, does ghc impliment it as a function with the free variables as arguments?
16:10:10 <lispy> djahandarie: just use that Core to Core transformer where you write your rules in Coq :)
16:10:19 * koninkje doesn't think the monad laws have RULES, since it's not always obvious which direction to run them
16:10:31 <kmc> tolkad, sort of
16:10:47 <ozataman> is there a systematic way to track down stack overflows? I am about to go crazy here :-)
16:11:00 <kmc> tolkad, GHC represents most values as closures in the heap
16:11:04 <tolkad> ozataman: ghci
16:11:09 <lispy> ozataman: look for uses of foldl
16:11:11 <djahandarie> koninkje, a rewrite rule involving a typeclass as opposed to a type seems a lot less safe in general (e.g., Monad vs List)
16:11:11 <kmc> each closure has a pointer to some "entry" code, plus fields for free variables if any
16:11:12 <geheimdienst> the monad laws are stuff that is not enforced by the type system or anyone else, right? they only exist on the haddock page and that's it?
16:11:13 <ozataman> -hy -hd -hc profiling, etc. hasn't helped
16:11:48 <tolkad> ozataman: you could just use Debug.Trace and put trace statements everywhere
16:11:57 <koninkje> djahandarie: but when the meaning of the typeclass assumes the validity of certain laws, it seems fine to me.
16:11:57 <ozataman> lispy: wish it was that easy.. i've got a couple layers deep monad transformers.. I think it is happening because i am using the old value of a state field to update itself.. I've added bangs everywhere, but am still missing something I guess. 
16:12:07 <tolkad> ozataman: or you could use ghci and set breakpoints everywhere
16:12:15 <koninkje> djahandarie: e.g., the map fusion law: fmap f . fmap g = fmap (f.g)
16:12:38 <tolkad> ozataman: just do a binary search over the relevant code until you find the place the stack overflow is happening
16:12:41 <koninkje> djahandarie: if there's a Functor instance that doesn't obey that law, then it has no business being a Functor instance
16:13:07 <tolkad> ozataman: or segfault, whatever it was
16:13:13 <benmachine> koninkje: if your instance accidentally doesn't follow that law though, could be a bastard to track down the bug
16:13:22 <djahandarie> koninkje, sure, I agree with you in spirit, but since the compiler doesn't enforce these laws I feel extremely weary depending on them
16:13:30 <ozataman> tolkad: good point - let me give trace a try
16:13:36 <benmachine> koninkje: especially if it relates to subtle strictness issues (many people interpret functor/monad laws to ignore seq, for example)
16:13:38 <djahandarie> At least when you're working with a type you know what the implementation is
16:13:42 <kmc> tolkad, functions are stored this way, and so are thunks and algebraic values
16:14:01 <koninkje> benmachine: yes, people ignoring strictness properties is problematic
16:14:32 <benmachine> koninkje: sometimes practicality conflicts with pedantry
16:14:36 <kmc> tolkad, i recommend reading "implementing lazy functional languages on stock hardware" and "making a fast curry" if you want to know more about this stuff
16:14:45 <koninkje> benmachine: when?
16:15:11 <kmc> read those and "typing haskell in haskell" and you can probably write a haskell compiler
16:15:14 <benmachine> koninkje: http://hackage.haskell.org/package/strict none of these datatypes are pedantically Functors (iirc)
16:15:28 <benmachine> koninkje: but it's definitely convenient to use them as such
16:15:48 <benmachine> and in almost all situations it's fine
16:16:28 <koninkje> benmachine: That's just an argument that we should have the class be Category c => Functor c f
16:16:51 <koninkje> Since strict functors will obey fmap f . fmap g = fmap (f .! g)
16:17:14 <koninkje> Where (!->) forms a category just like (->) does
16:17:17 <djahandarie> Heh
16:17:21 <aristid> :t (.!)
16:17:22 <lambdabot> Not in scope: `.!'
16:17:34 <hpc> (.!) = (.) with some seq sprinkled in
16:17:37 <koninkje> >let (f .! g) x = f $! g x
16:17:38 <benmachine> koninkje: yeah, overcomplicating things is totally the way forward :)
16:17:42 <aristid> @src (.)
16:17:42 <lambdabot> (f . g) x = f (g x)
16:17:42 <lambdabot> NB: In lambdabot,  (.) = fmap
16:18:08 <djahandarie> benmachine, a more categorial Functor class is actually pretty nice
16:18:14 <aristid> @let (f .! g) x = f $! g $! x
16:18:15 <lambdabot>  Defined.
16:18:18 <aristid> :t (.!)
16:18:19 <lambdabot> forall b1 b a. (b1 -> b) -> (a -> b1) -> a -> b
16:18:30 <aristid> like this?
16:18:35 <koninkje> astrid, actually that's wrong
16:18:36 <jmcarthur> this one will make conal proud: http://existentialtype.wordpress.com/2011/04/02/functions-are-values/
16:18:40 <koninkje> @let (f .! g) x = f $! g x
16:18:41 <lambdabot>  <local>:2:0:
16:18:41 <lambdabot>      Warning: Pattern match(es) are overlapped
16:18:41 <lambdabot>               In...
16:18:42 <hpc> @src ($!)
16:18:42 <lambdabot> f $! x = x `seq` f x
16:18:56 <aristid> koninkje: please use tab completion to write my name correctly :)
16:19:35 <koninkje> unless you're Astro or askatasuna, tab completion doesn't like you :)
16:19:43 <benmachine> aristid: that would require getting the first two letters right :P
16:19:44 <aristid> no.
16:19:48 <aristid> benmachine: i guess.
16:19:56 <aristid> koninkje: the first two letters are a and r
16:20:02 <benmachine> heheh
16:20:07 <lispy> heh, lame.  I came up with a work around for that cabal issue, but hackage won't accept it :(
16:20:09 <koninkje> heh
16:20:30 <hpc> asteroid: you are so picky about spelling; astrid is close enough :P
16:20:49 <cafesofie> astro: what's the matter, never seen fringe?
16:20:53 <aristid> lol
16:21:05 <lispy> what is fringe?
16:21:14 <hpc> lispy: fun tv show
16:21:44 <tolkad> jmcarthur: “fn x => raise Fail”? I don't recognize any of those functions/data types
16:22:01 <tolkad> oh wait nevermind that's ML, not haskell
16:22:16 <lispy> ?src ($!)
16:22:16 <lambdabot> f $! x = x `seq` f x
16:22:39 <lispy> > return $! Just undefined :: [Maybe Int]
16:22:39 <lambdabot>   [Just *Exception: Prelude.undefined
16:22:49 <benmachine> tolkad: it's ML, if that helps
16:22:54 <lispy> I guess that doesn't prove much...
16:23:09 <lispy> > return $ Just undefined :: [Maybe Int]
16:23:09 <lambdabot>   [Just *Exception: Prelude.undefined
16:23:11 <benmachine> or erm, maybe you already knew that
16:23:17 <benmachine> but I believe fn x => is lambda syntax
16:23:27 <lispy> > Just undefined `seq` 1
16:23:28 <lambdabot>   1
16:23:31 <benmachine> then raise Fail is presumably an error throwing operation
16:23:50 <tolkad> benmachine: oh so I assume the type just just "forall a b. a -> b"
16:24:27 <tolkad> benmachine: hey the article seems to make more sense now =D
16:25:10 <heatsink> Is there a way to change the default paths that GHC searches for libraries?  Setting LD_LIBRARY_PATH seems to work, but I'd prefer to have it built-in.
16:26:08 <benmachine> jmcarthur: was the value of the expression just that expression?
16:26:22 <benmachine> you didn't actually answer the question in the post :P
16:27:07 <djahandarie> That isn't jmcarthur's blog
16:27:34 <djahandarie> It's Rober Harper's.
16:27:54 <djahandarie> Robert*
16:28:16 <rostayob> why does this happen: http://hpaste.org/45228/th ?
16:28:20 <djahandarie> It's actually really good, I'd definitely recommend reading everything on there
16:30:02 <heatsink> rostayob: You're trying to run code that hasn't been compiled yet
16:30:04 <benmachine> rostayob: you can't use a TH splice before it's defined
16:30:22 <benmachine> rostayob: you can just use normal recursion and monadic binding, I think
16:31:30 <rostayob> heatsink: oh, I guess it makes sense.
16:31:37 <rostayob> benmachine: what do you mean?
16:33:29 <heatsink> If you inline getFields', you get the splice $(case ns of (n : _)  -> [| (nameBase n, $(varE n) p |] )
16:33:49 <heatsink> I think you can move the case statement into the quotes
16:34:13 <heatsink> $( [| case ns of (n : _) -> (nameBase n, $(varE n) p |] )
16:34:17 <benmachine> I think instead of using a splice to unQ the expression, you could just use x <- exp?
16:34:20 <heatsink> Now the splice and quotes cancel out
16:34:36 <rostayob> benmachine: oh, ok, I'll try that out...
16:34:54 <rostayob> heatsink: yeah but I'd like to have a separate function..
16:36:07 <rostayob> benmachine: yep, this: http://hpaste.org/45229/th compiles. thanks.
16:37:17 <heatsink> Simplified http://hpaste.org/paste/45229/th_annotation#p45230
16:37:24 <accel> is the only difference between binary/text mode, the conversion of \n, \n\r ?
16:37:34 <hpc> accel: i think so?
16:37:40 <accel> and if so
16:37:43 <accel> is there really 3 modes?
16:37:49 <accel> binary, text-unix, text-windozes?
16:38:00 <revenantphx> the 'b' mode is only for windows
16:38:06 <revenantphx> on unix os's it doesn't do anything
16:38:30 <accel> so if I only use osx
16:38:31 <accel> and linux
16:38:36 <accel> then text/binary doesn't make any difference?
16:38:42 <revenantphx> i'd assume so
16:38:44 <revenantphx> i've never bothered with b
16:39:09 <benmachine> in haskell, binary/text mode affects if unicode decoding happens
16:39:18 <accel> benmachine: tell me more
16:39:24 <accel> so text does unicode decoding, binary is just a series of chars?
16:39:29 <accel> a series of 8 bit chars
16:39:31 <benmachine> I believe so
16:39:35 <accel> damn
16:39:39 <benmachine> why?
16:39:44 <accel> why are all of you so "I believe so" rather than "I would fucking bet my life on it"
16:39:49 <benmachine> heh
16:39:51 <accel> :-)
16:40:08 <benmachine> it doesn't come up in the work I Do!
16:40:10 <benmachine> *do
16:40:16 <benmachine> so I'm going on what I've heard
16:40:34 <aristid> :t let unfold :: (forall r. (a -> b -> r) -> b -> r) -> b -> [a]; unfold f b = f (\a new_b -> a : unfold f new_b) in unfold
16:40:35 <lambdabot>     Couldn't match expected type `[a]' against inferred type `b -> [a]'
16:40:35 <lambdabot>     In the expression: f (\ a new_b -> a : unfold f new_b)
16:40:35 <lambdabot>     In the definition of `unfold':
16:40:37 <benmachine> the real way(tm) to do IO is to read everything into bytestrings and decode them manually ofc :P
16:41:00 <rostayob> benmachine: ok I just got back and I wrote the function I wanted to write some hrs ago in 10 mins. life's weird.
16:41:10 <benmachine> rostayob: :)
16:42:40 <rostayob> benmachine: thanks for the support, again eheh
16:43:11 <benmachine> np ^_^
16:43:15 <rostayob> template haskell is kind of weird...
16:43:35 <benmachine> yes
16:43:42 <benmachine> I view it as pretty experimental
16:44:18 <rostayob> you're programming in haskell but suddently everything is weird and really hard to debug eheh
16:44:40 <benmachine> there are some proposals to overhaul it a fair bit
16:44:45 <ozataman> tolkad: interesting.. I don't get stack overflow at all when I run it in ghci.. I do get it when I compile and run
16:45:02 <benmachine> I reckon it's a neat idea but it will be a long time before it becomes part of the language proper
16:45:05 <rostayob> benmachine: yeah... it's really powerful anyway, but it's not "nice" meta-programming (list)
16:45:10 <rostayob> *(lisp)
16:46:16 <rostayob> C++ templates are the best ahah
16:47:46 <benmachine> they're turing-complete
16:48:08 <benmachine> and probably the reason why there isn't an obfuscated C++ code contest
16:48:21 <rostayob> that would be great actually
16:48:26 <benmachine> it would be too easy :P
16:48:28 <Kaidelong> what C++ code isn't obfuscated?
16:48:53 <Saizan> you mean people read C++ code?
16:49:03 <rostayob> they do
16:49:12 <Kaidelong> everyone attack copumpkin
16:49:12 <Saizan> [next 30 minutes will be filled with c++ rantings]
16:49:16 <rostayob> well haskell code is not exactly readable
16:49:26 <rostayob> i mean is TERSE
16:49:48 <Kaidelong> rostayob: It somewhat depends on the haskell in question and what the reader knows about how the symbols work
16:49:51 <Kaidelong> err, operators
16:50:09 <rostayob> Kaidelong: yeah but still, a lot happens in few lines
16:50:11 <Saizan> ..we'd need monochrom to link his one concept per line post
16:50:25 <rostayob> and all those beautiful one letter variables
16:50:34 <Kaidelong> rostayob: That can be a very good thing, particularly if people make good top level bindings
16:50:46 <Kaidelong> rostayob: The one letter variables come into play when dealing with very abstract concepts
16:50:58 <Kaidelong> what variable names would you use to implement something like <*>
16:51:04 <heatsink> rostayob: for (int i = 0; i < n; i++)
16:51:11 <benmachine> haskell is hella terse yes, and there are some bad habits wrt variable naming
16:51:11 <hpc> Kaidelong: true, false, file_not_found ;)
16:51:16 <benmachine> I used to be horrible at variable naming
16:51:18 <Kaidelong> oh and convention too
16:51:30 <Kaidelong> f, g, h are conventionally things that can be applied to
16:51:33 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/17520bdd236b3351
16:51:39 <rostayob> heatsink: that's different :P. I'm not that against one-letter variables, but stil sometimes
16:51:40 <monochrom> (gladly obliged)
16:51:41 <Kaidelong> x, y, z are conventionally variables that will be applied
16:51:46 <Saizan> thanks :)
16:51:46 <benmachine> but having one-letter names is more forgivable when you can literally see the entire scope of the name in five lines
16:51:53 <Kaidelong> p, q, r are conventionall propositions to be tested
16:52:09 <Kaidelong> actually haskell borrows a lot of its single letter conventions right out of mathematics
16:52:14 <Kaidelong> so it isn't really that hard
16:52:31 <Kaidelong> then some others
16:52:38 <ozataman> tolkad: any idea how I can get the state value when I break inside of a monadic computation?
16:52:43 <rostayob> Kaidelong: wait wait, I've seen one-letter variables for absolutely ordinary things
16:52:48 <rostayob> for everything actually
16:52:57 <rostayob> it's not like the "i" in the for loop cmon
16:53:12 <Eduard_Munteanu> ozataman: 'break'?
16:53:23 <ozataman> Eduard_Munteanu: yeah using ghci breakpoints
16:53:29 <Eduard_Munteanu> Hm.
16:53:29 <Kaidelong> rostayob: I do not use them outside of implementing abstract things with types like "(Monoid b) => (a,b) -> (a -> b) -> b"
16:53:53 <Kaidelong> or mathematical functions that work on scalars/vectors
16:53:59 <Kaidelong> or logical relations
16:54:07 <Eduard_Munteanu> Not sure if 'get' works there.
16:54:08 <rostayob> Kaidelong: well in type signatures I use them as well of course, I wasn't talking about that
16:54:30 <Kaidelong> if the variables actually have some concrete meaning, like it's a route, and there is no convention from mathematical notation
16:54:45 <hpc> in fact, in math the convention is to eschew meaningful names
16:54:48 <Kaidelong> I will go ahead and use something like "route" instead of "r" or "rho"
16:55:27 <Eelis> does ghc 7's runtime system still use signals?
16:55:27 <hpc> when you talk about "f", you are observing what happens with operators on it, but not if you talk about "functor" or "injection" or whatever
16:55:30 <rostayob> yeah exactly, me too, but I've seen a lot of good code using almost exclusively one and two letter variables
16:55:40 <benmachine> hpc: multiletter variable names in maths are basically unheard of :(
16:56:01 <benmachine> but mathematical notation is a huge pile o
16:56:22 <lpsmith> Eelis, what do you mean?  Use signals internally?   I don't think so...
16:56:26 <tolkad> ozataman: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/ghci-debugger.html#id431447
16:56:38 <lpsmith> You can install your own signal handlers though
16:56:46 <Kaidelong> anyway I guess part of the problem with haskell is that if you're doing it right little of your code has real meaning outside of particular contexts
16:56:53 <lpsmith> You can generate signals...
16:57:02 <Kaidelong> because there is such great emphasis on polymorphism
16:57:03 <benmachine> mathematics could learn a lot from haskell, notationally, I reckon
16:57:09 <benmachine> and should be more strongly typed :P
16:57:29 <Saizan> one thing is that if you're algbraically modifying your code you don't want to think about what those variables are, you just want to care about the operations used on them
16:57:36 <Eelis> lpsmith: yes, internally. i'm looking at HFuse, a package that wraps a c library. i will need to make some modifications to it, but reading its source code, it looks like everything is more complicated because it was written at a time when ghc's rts used signals which conflicted with the c library's use of them
16:57:47 <aristid> > foldr1 (-) [a,b,c]
16:57:48 <lambdabot>   a - (b - c)
16:57:48 <tolkad> ozataman: the ghci debugger is rather limited
16:57:57 <ozataman> tolkad: I saw that, but my case is a bit more complicated as I'm inside of a StateT and want to see the current state being passed in the background
16:57:58 <Eelis> lpsmith: so if ghc 7's rts no longer uses signals, HFuse could be simplified a lot
16:58:16 <rostayob> Saizan: still, I don't think it hurts to signal what is what
16:58:17 <ozataman> tolkad: yeah.. let me see if I can pull this off somehow
16:58:20 <tolkad> ozataman: you could bind it to a variable
16:58:22 <aristid> benmachine: alternating addition/subtraction sequences can easily be expressed with foldr! :)
16:58:25 <lpsmith> Eelis, do you mean "callbacks"?
16:58:30 <ozataman> tolkad: that's what I'm trying to do now :) 
16:58:32 <Eelis> lpsmith: i mean posix signals.
16:58:48 <Saizan> rostayob: it can hurt if a longwinded name distracts from the structure of the code
16:59:04 <tolkad> x <- get
16:59:12 <rostayob> Saizan: mh? I don't think I see what you mean
16:59:17 <Saizan> rostayob: anyhow, it's a matter of degree, and how large is the scope
16:59:18 <Kaidelong> Saizan: but for those combining forms you can often write them in the abstract first
16:59:23 <Eelis> lpsmith: if on the other hand ghc 7's rts /still/ uses signals, then i'm not going to bother with HFuse and will just write my program in C++
16:59:24 <Kaidelong> with those single letter variables
16:59:31 <Kaidelong> then put real values in with big names later
16:59:45 <ozataman> tolkad: hah! it worked, I can see the state!
16:59:49 <benmachine> aristid: :)
16:59:50 * geheimdienst hates objective-c names, which are all like dequeueReusableCellWithIdentifierNowPlease
16:59:52 <Kaidelong> if you can't, then you have a point, but I can't think of examples like that right now
17:00:19 <lpsmith> Eelis, yeah I can't help you there.
17:00:28 <Eelis> lpsmith: ok :) i'll ask in #ghc
17:00:33 <Saizan> the problem is spotting where they'd apply when you have the big names spreading your expressions out
17:00:42 <Kaidelong> anyway the important thing with haskell IMO is to keep as much as possible in top level scope
17:00:47 <ozataman> tolkad: really strange. I don't get any stack overflow in ghci...
17:00:53 <blackdog> anyone got a recommendation on running tests wi
17:00:53 <Kaidelong> and not write very long and complex definitions
17:00:55 <blackdog> th cabal?
17:01:05 <blackdog> not sure what the state of the art is...
17:01:18 <Saizan> @quote true.haskell.form
17:01:18 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
17:01:43 <Kaidelong> 4 lines is time to worry
17:01:46 <Kaidelong> 6 lines is time to panic
17:01:50 <geheimdienst> Eelis: what do you not like about hfuse?
17:02:12 <Kaidelong> of course there are exceptions
17:02:20 <Kaidelong> if you're using Haskell as a Perl-like scripting language for example
17:02:22 <tolkad> ozataman: well ghci is a completely different execution environment, it's interpreted instead of compiled
17:02:22 <Eelis> geheimdienst: it crashes
17:02:25 <Kaidelong> you might have an excuse for a big main
17:02:30 <lpsmith> Eelis, yeah, looking at the source of HFuse, I seriously doubt that much has changed with GHC 7
17:02:35 <Kaidelong> or other big IO bindings as subroutines
17:02:40 <tolkad> ozataman: still that's pretty weird
17:02:48 <Eelis> lpsmith: :/
17:02:54 <ozataman> tolkad: I'm guessing it has more space allocated to begin with...
17:03:08 <Kaidelong> (funny how Haskell makes a great scripting language)
17:03:20 <geheimdienst> eelis: could you give us some more details? it's been a while since i used hfuse, but i remember it worked pretty well
17:03:22 <tolkad> ozataman: well, try Debug.Trace then
17:03:33 <ozataman> tolkad: yep, switching to that now
17:03:41 <Eelis> geheimdienst: i already talked to the maintainer. he acknowledged there was a bug
17:03:48 <geheimdienst> oh i see
17:04:06 <Eelis> geheimdienst: but before i work on fixing it, i'm trying to figure out whether it's worth bothering with this at all
17:04:52 <lpsmith> well,  you might learn something... on the other hand if it's a program that needs to be working in relatively short order,  you might just want to use C++ instead
17:05:10 <Kaidelong> lpsmith: Really? Wouldn't that depend on the program?
17:05:39 <Kaidelong> one of the big reasons people picked up haskell IIRC was because they could prototype things faster in haskell than they could in C++
17:05:50 <Kaidelong> and the haskell could be rewritten in C++ later
17:05:56 <lpsmith> Kaidelong, well, this is a FUSE program,  and according to Eelis there is some kind of bad interaction between GHC's default signal handlers and FUSE
17:06:06 <Eelis> lpsmith: if the ghc rts's use of signals is the source of conflicts with fuse's use of signals, then i'd rather just use a language with a less obnoxious and presumptuous runtime :)
17:06:17 <Kaidelong> oh okay, sorry, I was still thinking in the abstract there
17:06:30 <Kaidelong> file-system-in-user-space?
17:06:33 <Kaidelong> that FUSE?
17:06:36 <Eelis> Kaidelong: yeah
17:06:37 <c_wraith> there's seriously no instance of random for Word8?  *sigh*
17:06:39 <lpsmith> yeah, that fuse
17:07:00 <aristid> what's the name for the relationship between forall r. (a -> b -> r) -> r and (a, b)?
17:07:14 <lpsmith> it sounds like something that is likely to be more appropriate for C or C++
17:07:35 <tolkad> c_wraith: there should be... http://hackage.haskell.org/trac/ghc/ticket/4379
17:07:37 <lpsmith> (assuming it's a relatively simple FUSE program)
17:07:49 <tolkad> c_wraith: it says fixed
17:07:52 <Eelis> i'd love to write it in Haskell, but only if Haskell doesn't make it needlessly hard :)
17:08:07 <strawman> aristid: I'd call it church encoding?
17:08:14 <geheimdienst> lpsmith: i think haskell is perfectly fine for fuse. i've used it successfully. however i can't speak to the topic of signals
17:08:16 <c_wraith> maybe it is in 7.x
17:08:16 <aristid> strawman: ah, thanks :)
17:08:21 <strawman> but probably the other one too
17:08:21 <strawman> since it isn't recursive
17:08:33 <aristid> strawman: i think Saizan told me already yesterday, but i forgot already
17:08:37 <Axman6> Eelis: why don't you try it and find out? the RTS has good reason for installing its own signal handlers if it needs to do things like clean up when the program is asked to terminate
17:08:40 <strawman> there's the scott encoding too
17:08:41 <tolkad> c_wraith: I have 7.x, I'll check
17:08:50 <aristid> strawman: what's that?
17:09:05 <strawman> similar thing that does different stuff on recursive things, iirc
17:09:12 <strawman> http://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding
17:09:32 <Kaidelong> Eelis: You could certainly write part of it in C and part of it in haskell, too
17:09:34 <tolkad> c_wraith: don't see the instance in 7.0.1, imported System.Random and Data.Word
17:09:40 <Eelis> Axman6: because the authors of HFuse /already/ tried it and found out that nasty workarounds were needed
17:09:49 <c_wraith> tolkad: unforunate
17:09:54 <c_wraith> err, unfortunate
17:10:03 <Eelis> Axman6: but this was years ago, so i'm trying to find out if the situation has improved :)
17:11:21 <aristid> strawman: "Scott encoded data and operations are not obviously typable in system F"
17:11:26 <aristid> strawman: so haskell cannot use them?
17:12:48 <lpsmith> I don't suppose that signalfd() can be used with GHC in a reasonable way?
17:13:12 <Eelis> hm, perhaps i should just read the ghc manual!
17:14:17 <Saizan> aristid: you can if make the recursion go through a newtype
17:14:21 <heatsink> I don't understand the church encoding.  The scott encoding looks like a translation of the datatype's "case" statement into a function.
17:14:56 <Saizan> church encoding is the fold instead
17:14:58 <Eelis> ah, the manual says the runtime system uses signals /even if/ you specify --install-signal-handlers=no
17:15:04 <Eelis> so i'll go with C++
17:15:23 <Saizan> i.e. the church encoding for lists is forall r. (a -> r -> r) -> r -> r
17:15:34 <Saizan> ?type foldr
17:15:34 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:15:59 <lpsmith> Eelis, http://lwn.net/Articles/417259/
17:16:17 <lpsmith> there's an enlightening comment by dcoutts
17:16:20 <strawman> forall a b. [a] -> (a -> b -> b) -> b -> b
17:16:24 <strawman> that may make it clearer
17:16:33 <aristid> Saizan: i wonder... if you have a church encoded type, can you generally derive "unfold" functions from it?
17:16:35 <strawman> then you can write a (forall r. (a -> r -> r) -> r -> r) -> [a] trivially
17:16:57 <Kaidelong> @ty flip (flip .) . foldr
17:16:58 <lambdabot> forall (f :: * -> *) a b a1 b1. (Functor f) => (a1 -> b1 -> b1) -> ((b1 -> [a1] -> b1) -> f (a -> b)) -> a -> f b
17:17:05 <strawman> AAAAAGHG
17:17:09 * strawman runs away screaming
17:17:10 <lpsmith> at least that gives you a clue about why GHC has the signal handlers that it does
17:17:21 <lpsmith> apparently,  basically trying to implement signalfd,  it sounds like
17:17:34 <Zao> I'm a fan of the Windows approach to signal delivery. It does it on a new unmolested thread.
17:18:01 <tolkad> Eelis: The RTS can be called from C, perhaps you could figure out some sort of workaround doing that? Sorry I don't have much of an understanding of signals.
17:18:03 <Saizan> aristid: e.g. generate unfoldr out of (forall r. (a -> r -> r) -> r -> r) ?
17:18:03 <heatsink> Hm.  I'll have to think about it.
17:18:03 <Kaidelong> @ty flip ((flip .) . foldr)
17:18:04 <lambdabot> forall a b a1. (a -> b) -> (a1 -> (a -> b) -> a -> b) -> a -> [a1] -> b
17:18:19 <Eelis> lpsmith: thanks, this is also informative: http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/runtime-control.html#rts-options-misc
17:18:23 <aristid> Saizan: well, or similar. and of course without the Maybe
17:18:35 <aristid> :t unfoldr2
17:18:36 <lambdabot> forall a t. ((a -> t -> [a]) -> t -> [a]) -> t -> [a]
17:18:44 <strawman> Maybe is crucial!
17:18:48 <blackdog> I'm trying to put together a best-practices dummy cabal project - testing baked in, benchmarking, etcetcetc. anyone know if someone's done this before?
17:19:03 <aristid> :t let unfoldr3 :: (forall r. (a -> t -> r) -> t -> r) -> t -> [a]; unfoldr3 f = let go b = f (\a new_b -> a : go new_b) b in go in unfoldr3
17:19:04 <lambdabot> forall a t. (forall r. (a -> t -> r) -> t -> r) -> t -> [a]
17:19:10 <aristid> strawman: no it's not.
17:19:13 <Eelis> oh, wait, perhaps if one combines --install-signal-handlers=0 with -V0, no signals are used
17:19:20 <strawman> aristid: something isomorphic to Maybe (a, b) is
17:19:32 <aristid> strawman: like its church encoding?
17:19:50 <strawman> sure, whatever
17:20:21 <tomberek> I am trying to make a zipper for a cyclic structure.  I can get the O(1) traversal, but can't get updates to work, I've seen a few posts hinting at it's difficulty, but no solutions.
17:20:32 <aristid> [a]: forall r. (a -> r -> r) -> r -> r
17:21:04 <Eduard_Munteanu> tomberek: what structure?
17:21:11 <aristid> Maybe (a, b): forall r. (a -> t -> r) -> t -> r
17:21:15 <Eduard_Munteanu> I don't get the O(1) traversal part.
17:21:23 <aristid> Maybe (a, b): forall r. (a -> b -> r) -> b -> r
17:21:26 <tomberek> Eduard_Munteanu: right now it's just a cyclic list
17:21:53 <aristid> Saizan: the church encodings for [a] and Maybe (a, b) look pretty similar
17:21:54 <strawman> aristid: that's r on the outside
17:22:05 <strawman> aristid: that's because [a] is just the fixed point of Maybe (a, b)
17:22:06 <tomberek> Eduard_Munteanu: and I can traverse it now in constant time per step, but I can't get updates to work.
17:22:10 <strawman> so it ties the knot on that inner bit
17:22:22 <aristid> strawman: and unfoldr uses that
17:22:34 <strawman> Maybe (a, b): forall r. (a -> b -> r) -> r -> r
17:22:38 <lpsmith> tolkad, signals are not a lot of fun.   Basically they are a procedure that is called,  asynchronously at almost any time (unless blocked) by the Operating System for a variety of reasons
17:22:42 <lpsmith> so a process can register a function pointer with the OS to handle a given signal,  and the OS will cause your process to jump to that pointer
17:22:51 <Eduard_Munteanu> Hrm, I see your point.
17:23:23 <tomberek> Eduard_Munteanu:  data DList = Int DList DList  is the structure I'm playing with now,, using loeb to tie the knot
17:23:27 <Eduard_Munteanu> Or synchronously as with SIGSEGV
17:23:54 <tolkad> lpsmith: so are they just interrupts?
17:24:02 <aristid> strawman: oh right, that was a mistake on my part. i did mean Maybe (a,b): (a -> b -> r) -> r -> r
17:24:15 <Eduard_Munteanu> tolkad: not proper interrupts, but a bit similar
17:24:17 <aristid> (plus forall r.)
17:24:30 <lpsmith> tolkad, basically yes
17:24:51 <Taslem> What does the Int returned by "next" for RandomGen mean?
17:24:52 <aristid> why do we even have ADTs? let's just use church encodings for everything! :D
17:25:17 <Taslem> Aristid: For one, the memory would go through the roof.
17:25:41 <Eduard_Munteanu> tomberek: I'm not sure that'd work with a cyclical DList
17:25:44 <aristid> aristid: it would? sure?
17:25:45 <tolkad> Taslem: it's the random number
17:25:49 <aristid> argh
17:25:54 <aristid> Taslem: it would? sure?
17:26:00 <tolkad> Taslem: the whole point of the next function is to generate a random Int
17:26:03 <aristid> i mean i don't know if it would
17:26:11 <Taslem> Uh, duh, right. 
17:26:13 <lpsmith> can you church-encode say,   let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)?
17:26:14 <tomberek> Eduard_Munteanu: and I can traverse with O(1) per step.   I see difficulties in making it work with updates, i was wondering if anyone had ideas
17:26:23 <aristid> lpsmith: that's not an ADT
17:26:31 <strawman> it's a list
17:26:38 <Taslem> All data types can be church-encoded.
17:26:44 <strawman> express it as a fold
17:26:48 <Taslem> *algebraic types
17:28:14 <Eduard_Munteanu> tomberek: even plain DLists are messy to update.
17:28:20 <Eduard_Munteanu> AFAIK you have to recreate them completely.
17:29:05 <Eduard_Munteanu> tomberek: why don't you use a zipper on a plain list?
17:29:13 <Eduard_Munteanu> Or perhaps I misunderstood you.
17:29:24 <tomberek> Eduard_Munteanu: i want it to be cyclic
17:29:29 <aristid> lpsmith: i'm not sure what the church-encoded type of zipWith would be
17:29:35 <aristid> :t zipWith
17:29:36 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:30:30 <benmachine> :t liftA2
17:30:31 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
17:30:33 <lpsmith> well, the point is to write that definition of fibs with church-encoded lists
17:30:38 <lpsmith> aristid, ^
17:31:23 <ozataman> tolkad: it seems that some of my foldMs and mapMs are being unrolled and called only once. I'm seeing some traces that I would expect to see many times only a single time.
17:31:28 <aristid> assumption: zipWith :: (a -> b -> c) -> (forall r. (a -> r -> r) -> r -> r) -> (forall r. (a -> r -> r) -> r -> r) -> (forall r. (a -> r -> r) -> r -> r)
17:31:46 <strawman> you didn't change your type variables
17:31:50 <strawman> when you copied and pasted them
17:31:59 <aristid> strawman: damn :D
17:32:08 <lpsmith> though technically,  you could simplify that to church-encoded streams
17:32:09 <strawman> aristid: now write it ;)
17:32:10 <aristid> assumption: zipWith :: (a -> b -> c) -> (forall r. (a -> r -> r) -> r -> r) -> (forall r. (b -> r -> r) -> r -> r) -> (forall r. (c -> r -> r) -> r -> r)
17:32:24 <tolkad> ozataman: Debug.Trace should prevent any optimizations that will remove them
17:32:30 <benmachine> writing zip as a foldr is a bit mind-bendy but it can be done
17:32:37 <tolkad> ozataman: it's probably laziness that's causing it not to be called
17:33:06 <tomberek> Eduard_Munteanu: zippers are straightforward for a tree-like structure where there is directionality, but with a cyclic structure it's difficult
17:33:08 <aristid> fibs cons nil = 0 `cons` (1 `cons` zipWith (+) fibs (tail fibs) cons nil)
17:33:18 <ozataman> tolkad: yeah.. it's obvious a long list of values are being generated before they are folded over...
17:33:24 <lispy> ?hoogle Char -> Int64
17:33:24 <lambdabot> Data.ByteString.Lazy.Char8 count :: Char -> ByteString -> Int64
17:33:24 <lambdabot> Data.ByteString.Lazy.Char8 elemIndex :: Char -> ByteString -> Maybe Int64
17:33:24 <lambdabot> Data.ByteString.Lazy.Char8 elemIndices :: Char -> ByteString -> [Int64]
17:33:27 <hpc> @src zip
17:33:27 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:33:27 <lambdabot> zip _      _      = []
17:33:33 <aristid> strawman: any obvious mistakes? :)
17:33:40 <lispy> ?hoogle Char -> CULong
17:33:40 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:33:40 <lambdabot> Prelude error :: [Char] -> a
17:33:40 <lambdabot> Prelude read :: Read a => String -> a
17:33:50 <lispy> :t fromEnum
17:33:51 <lambdabot> forall a. (Enum a) => a -> Int
17:33:57 <lispy> why is Enum an int...
17:34:07 <strawman> bad design
17:34:13 <hpc> hysterical raisins
17:34:25 <hpc> presumably the same line of thought that gave us
17:34:27 <hpc> :t length
17:34:27 <lambdabot> forall a. [a] -> Int
17:34:42 <lispy> never need to address more than 2^32 things, right?
17:34:50 <strawman> or 2^64
17:34:51 <tolkad> ozataman: try switching to the strict state monad?
17:35:02 <ozataman> tolkad: already have, hasn't helped :(
17:35:03 <strawman> if you have a 64-bit machine, you're a better person
17:35:11 <strawman> so you deserve larger enumerations
17:36:03 <hpc> @src length
17:36:03 <lambdabot> Source not found.
17:36:24 <hpc> hmm, i wonder... if you take the length of a list that is too long, does it error out when the Int overflows?
17:36:29 <ozataman> tolkad: it's accumulating state thunks before finally evaluating them.. not sure why it is happening. my modify function isn't evaluated until the very end
17:36:43 <monochrom> Int overflow may be silent
17:36:49 <hpc> > maxBound :: Int + 1
17:36:50 <lambdabot>   Could not deduce (GHC.Enum.Bounded
17:36:51 <lambdabot>                      ((+) GHC.Types.Int ...
17:37:00 <monochrom> more parentheses
17:37:01 <hpc> > (maxBound :: Int) + 1
17:37:01 <lambdabot>   -9223372036854775808
17:40:02 <Eduard_Munteanu> tomberek: it might work to build a zipper using Seqs.
17:40:13 <tolkad> ozataman: you could try writing your own foldM involving a seq? I'm really not sure how to fix a problem like this
17:40:16 <tomberek> Eduard_Munteanu: what do you mean?
17:40:41 <ozataman> tolkad: I've also never had it this bad before - thanks for all the help
17:41:09 <Eduard_Munteanu> tomberek: data ZipList = ZL a (Seq a) (Seq a) (Seq a)
17:41:11 <ozataman> tolkad: just upgraded to 7.03 from 7.02 to see if that'd help, but now having another issue with _ffi_call_unix64 support
17:41:29 <tomberek> Eduard_Munteanu: I'm unfamiliar with Seq
17:41:36 <Eduard_Munteanu> tomberek: and now, when you do 'right' to navigate it, you also cons to the right of the Seq.
17:41:51 <Eduard_Munteanu> It's basically a queue.
17:42:02 <Eduard_Munteanu> You have fast (though not O(1) AFAIK) access to both ends.
17:42:13 <tolkad> ozataman: ooh, sorry, that's not something I can help with at all :P
17:42:34 <ozataman> tolkad: :) there's a ticket on trac.. I guess it's a new bug with 7.03
17:42:42 <michaelh> why does foldl create type a and foldr create type b?
17:42:42 <tomberek> Eduard_Munteanu: That seems right. Is that in Data.Sequence
17:42:55 <Eduard_Munteanu> The idea would be to rebuild the original list as you navigate rightwards through it, so when you hit the end you can swap the left list with that and begin all over again.
17:42:59 <Eduard_Munteanu> Yes.
17:43:42 <Eduard_Munteanu> (erm the right list.)
17:43:48 <hpc> michaelh: the magic of "who cares what letters the inferencer picks" :P
17:44:01 <michaelh> hpc: ah, of course. :)
17:44:02 <tomberek> Eduard_Munteanu:  well, i'm not sure that would work because i'm want to extend these concepts to cyclic graphs
17:44:12 <Eduard_Munteanu> Actually you could use only two Seqs if you don't care about going leftwards.
17:44:15 <hpc> :t foldl
17:44:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:44:17 <hpc> :t foldr
17:44:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:44:27 <Eduard_Munteanu> Ah.
17:44:35 <aristid> which extension do i need for type CList a = forall a. (a -> r -> r) -> r -> r?
17:44:55 <Eduard_Munteanu> aristid: rank-2 types
17:45:00 <djahandarie> ExistentialType should work I think
17:45:10 <Eduard_Munteanu> Rank2Types, that is
17:45:20 <Eduard_Munteanu> Wait.
17:45:22 <djahandarie> ExistentialQuantification*
17:45:25 <Eduard_Munteanu> You don't need any!
17:45:38 <aristid> {-# LANGUAGE Rank2Types #-} ?
17:45:38 <djahandarie> Wait that's a type alias, not a data type. ExplicitForall should work
17:45:42 <Eduard_Munteanu> The type is wrong ;)
17:45:59 <tomberek> Eduard_Munteanu:  But Seq seems to be a great idea, I'll see what I can do with it.  Thanks
17:46:04 <aristid> Eduard_Munteanu: that too :(
17:46:26 <Eduard_Munteanu> type CList a = forall r. (a -> r -> r) -> r -> r    ?
17:46:28 <kjslag> Is there a standard class for something like the below (requires MultiParamTypeClasses)??
17:46:29 <kjslag> class     From a b  where  from :: a -> b
17:46:31 <kjslag> instance  From a a  where  from = id
17:46:32 <kjslag> instance  (Num      a) => From Integer a  where  from = fromInteger
17:46:33 <Eduard_Munteanu> If so, then {-# LANGUAGE Rank2Types #-}
17:46:34 <kjslag> instance  (Integral a) => From a Integer  where  from = toInteger
17:46:56 <djahandarie> kjslag, don't paste that much code in the channel please
17:47:04 <djahandarie> @where hpaste
17:47:04 <lambdabot> http://hpaste.org/
17:47:09 <kjslag> sorry, thanks
17:47:16 <kjslag> @where hpaste
17:47:16 <lambdabot> http://hpaste.org/
17:47:31 <strawman> kjslag: the class system can't do that the way you want it to
17:47:59 <strawman> you can do it with a crapload o' instances
17:48:03 <aristid> dang
17:48:15 <aristid> Eduard_Munteanu: looks like codepad's hugs does not support Rank2Types :D
17:48:17 <benmachine> kjslag: I think it would be ambiguous; for example Integer -> Int could either use Integer -> a with fromInteger, or a -> Int with fromEnum
17:48:20 <strawman> djahandarie: you left too early!
17:48:20 <aristid> so i got to use my own ghc
17:48:35 <Eduard_Munteanu> aristid: though I'm pretty sure it also depends _where_ you use your type synonym.
17:48:47 <Eduard_Munteanu> So it might need even impredicative types, say if you wrap it into a Maybe
17:49:02 <Eduard_Munteanu> Are you sure you don't want existentials?
17:49:06 <tomberek> Eduard_Munteanu:  What's the idea with viewl and the datatype ViewlL a? how is it different than a simple viewl:: Seq a -> a?
17:49:26 <Eduard_Munteanu> tomberek: it can handle failure
17:49:33 <tomberek> ah
17:49:51 <tomberek> I see, EmptyL
17:49:52 <Eduard_Munteanu> I mean, it lets you handle failure by pattern matching
17:49:55 <Eduard_Munteanu> Yeah.
17:50:41 <tomberek> ok, perhaps Seq can help me out, but it still seems difficult to get both O(1) traversal and updates for cyclic structures
17:50:59 <Eduard_Munteanu> I don't think Seq is O(1) though.
17:51:17 <tomberek> it says it is,, (amortized)
17:51:20 <kjslag> benmachine: Indeed, it would be ambiguous if you add many instances. although I think OverlappingInstances semi-solves the problem.
17:51:39 <Eduard_Munteanu> Hrm, it is :/
17:51:42 <aristid> Eduard_Munteanu: no, i just want Rank2Types
17:51:50 <aristid> Eduard_Munteanu: this is just some church-encoded lists :)
17:51:51 <tomberek> viewl is O(1), so is |> 
17:51:57 <kjslag> benmachine: however, I wasn't suggesting that there should be a From class, I was just wondering if there already was one.
17:52:33 <tolkad> I don't understand how anything involving a memory lookup can be O(1) in a turing complete language
17:52:51 <tomberek> in fact, Seq has tons of advantages over lists. The only drawback is that Seq is finite, but that is sometimes OK
17:53:23 <Eduard_Munteanu> tolkad: O(1) for accessing the next/previous elem
17:53:41 <djahandarie> strawman, I left too early?!
17:53:47 <strawman> from boston
17:53:56 <djahandarie> Why's that?
17:54:04 <strawman> you missed dinner!
17:55:00 <djahandarie> Well I wanted to get back at a sane time. :p Also, don't they id people wherever you guys go?
17:55:07 <strawman> no!
17:55:11 <strawman> well, for drinks
17:55:17 <strawman> but nobody forces you to have beer
17:55:20 <strawman> I had a lemonade
17:55:33 * kmc will force you to have beer
17:55:35 <strawman> mmmlemonade
17:55:37 <strawman> lol
17:55:38 <kmc> j/k j/k
17:55:42 <Eduard_Munteanu> tomberek: well, you could always coax up an ugly STRef-based cyclical structure ;)
17:55:50 <tolkad> Eduard_Munteanu: hmm, I see how that could work. Change my statement to be "arbitrary memory lookup"
17:55:52 <tomberek> eeeewww
17:55:56 <djahandarie> Maybe I'll go next time then :p
17:56:02 <strawman> djahandarie: damn right
17:56:03 <tolkad> Eduard_Munteanu: in which case I guess it may not apply
17:56:04 <tomberek> Eduard_Munteanu: gross
17:56:07 <kmc> nobody ever thinks to order lemonade but once one person does, everyone else is like "oh yeah, i forgot about lemonade! lemonade is the bomb!"
17:56:10 * hackagebot rsagl-frp 0.6.0.0 - The RogueStar Animation and Graphics Library: Functional Reactive Programming  http://hackage.haskell.org/package/rsagl-frp-0.6.0.0 (ChristopherLaneHinson)
17:56:12 <Eduard_Munteanu> :)
17:56:12 * hackagebot rsagl-math 0.6.0.0 - The RogueStar Animation and Graphics Library: Mathematics  http://hackage.haskell.org/package/rsagl-math-0.6.0.0 (ChristopherLaneHinson)
17:56:24 <strawman> nobody expects the lemonade
17:57:10 * hackagebot rsagl 0.6.0.0 - The RogueStar Animation and Graphics Library  http://hackage.haskell.org/package/rsagl-0.6.0.0 (ChristopherLaneHinson)
17:57:13 * hackagebot roguestar-engine 0.6.0.0 - Sci-fi roguelike game. Backend.  http://hackage.haskell.org/package/roguestar-engine-0.6.0.0 (ChristopherLaneHinson)
17:57:22 <tomberek> jeez, what's going on?
17:57:26 <strawman> djahandarie: I also have an inflatable mattress if you don't feel like driving back in the middle of the night
17:59:05 <lispy> Well, I've written like 500 lines of .hsc playing around with this binding and I _just_ realized that the structs I'm trying to use are all defined like, struct Foo_Rec_ { .. }; typedef Foo_Rec_ *Foo;  So that means that whenever I see Foo blah; in the C code, Foo is really a pointer isn't it?
17:59:11 * hackagebot roguestar-gl 0.6.0.0 - Sci-fi roguelike game. Client library.  http://hackage.haskell.org/package/roguestar-gl-0.6.0.0 (ChristopherLaneHinson)
17:59:13 * hackagebot roguestar-glut 0.6.0.0 - Sci-fi roguelike game. GLUT front-end.  http://hackage.haskell.org/package/roguestar-glut-0.6.0.0 (ChristopherLaneHinson)
17:59:14 <djahandarie> strawman, I might take you up on that offer. :p
17:59:15 * hackagebot roguestar 0.6.0.0 - Sci-fi roguelike game. Client application.  http://hackage.haskell.org/package/roguestar-0.6.0.0 (ChristopherLaneHinson)
17:59:36 <strawman> djahandarie: sure :)
17:59:44 <Eduard_Munteanu> lispy: yeah
17:59:58 <enthymeme> ooh roguestar :3
18:00:33 <lispy> Eduard_Munteanu: that changes things a lot....
18:00:44 <lispy> oy
18:01:12 <Eduard_Munteanu> lispy: not if you're supposed to treat those structs as opaques, though
18:01:32 <djahandarie> It's too bad I'm not as interesting to talk to as ddarius
18:01:34 <lispy> Eduard_Munteanu: how so?
18:01:55 <Eduard_Munteanu> lispy: maybe there are functions that construct and manipulate those objects, and you don't have to access members?
18:01:59 <strawman> djahandarie: seems hard to quantify that kind of statement :P
18:02:01 <lispy> Eduard_Munteanu: I mean, the C examples that use this library do access the fields of those structs directly.  Just not all of them
18:02:08 <Eduard_Munteanu> Ah.
18:02:16 <lispy> Eduard_Munteanu: well, what you said and what I said are both true
18:02:35 <tolkad> hey you guys want to see a way to get infinite memory in haskell?
18:02:45 <lispy> Eduard_Munteanu: I'm supposed to use their library to allocate/deallocate them and to manipulate some fields.
18:02:51 <Eduard_Munteanu> I see.
18:03:05 <lispy> Eduard_Munteanu: they do an OO design on top of C
18:03:07 <tolkad> take a look at this: http://codepad.org/Cc4xc32P
18:03:09 <strawman> tolkad: is this like those things where I can download a video card upgrade?
18:03:16 <tolkad> it can store any Integer in a single data type
18:03:32 <lispy> Eduard_Munteanu: so I can specify functions to use for memory allocation, but then I let them instantiate the actual object
18:03:58 <strawman> tolkad: a single datatype? :)
18:04:28 <strawman> tolkad: I expect that unX will be rather useless ;)
18:04:32 <tolkad> strawman: two datatypes
18:04:37 <wharzl> anyone know zenzike?
18:04:38 <tolkad> strawman: O and Z are newtypes
18:04:39 <lispy> tolkad: now if only type class dictionaries didn't take up space :)
18:04:52 <tolkad> lispy: shhh
18:05:01 <strawman> tolkad: yeah, I've done something similar with peano naturals :)
18:05:06 <ozataman> tolkad: ok, got it. even though I was using State.Strict, I still had to somehow force-eval the state variable after "modify". otherwise modify doesn't get executed until later
18:05:46 * lispy goes off to redesign his ffi bindings...again
18:05:53 <strawman> wharzl: name sounds familiar, but I don't know why or whence
18:05:53 <djahandarie> lispy, they don't if you specialize!
18:06:01 <tolkad> ozataman: glad you figured it out! If you used Control.Exception.eval it would be better form to find a way to do it with the "seq" function
18:06:09 <djahandarie> But I fear that won't be particularly useful in this case...
18:06:46 <ozataman> tolkad: thanks again for all the help! I ended up using a bang after the modify statement - like "!st <- get"
18:07:16 <Eduard_Munteanu> Well, data representations do take up space.
18:07:28 <tolkad> ozataman: heh, when you said "force-eval" I was afraid you meant you used unsafePerformIO . eval :P
18:07:42 <djahandarie> Pollione, the *pumpkin* matching rule seems to be slowly disintegrating
18:07:51 <Pollione> true
18:07:57 <tolkad> ozataman: oh wait it's called evaluate, remembered it wrong
18:08:08 <djahandarie> strawpumpkin
18:08:09 <tolkad> ozataman: anyway, nevermind
18:08:34 <Eduard_Munteanu> Oh!
18:09:06 <tolkad> Eduard_Munteanu: you see that I am right? it's free infinite memory!
18:09:19 <Eduard_Munteanu> No, I realized who strawman was ;P
18:09:42 <djahandarie> I saw him switch nicks so I wasn't too suprised when he knew I was in Boston yesterday
18:09:55 <tolkad> wait strawpumpkin = copumpkin?
18:10:00 <tolkad> = strawman?
18:10:18 <ozataman> tolkad: :) sorry - I'm getting a little tired here. spent hours with this thing :)
18:10:20 <tolkad> some people and their nick changing...
18:10:23 * Pollione is a secret agent!
18:10:26 <Pollione> I have many disguises
18:10:38 <tolkad> ozataman: don't know what you're apologizing for :P
18:11:25 <tolkad> ozataman: it's my fault for interpreting you too literally
18:12:32 <aristid> Warning: -XImpredicativeTypes is deprecated: impredicative polymorphism will be simplified or removed in GHC 6.14
18:12:32 <aristid> (says my GHC 6.12)
18:12:36 <ozataman> tolkad: :) anyway, thanks again
18:12:42 <aristid> did that actually happen in 7?
18:13:37 <djahandarie> aristid, no
18:13:41 <tolkad> aristid: http://groups.google.com/group/fa.haskell/browse_thread/thread/9cac5ec4e8735905
18:15:22 <aristid> hmm.
18:16:22 <tolkad> woah, just looked up what impredicative polymorphism is. that looks really useful
18:16:41 <djahandarie> It kills inference though
18:18:01 <tolkad> inference in general? inference only for the impredicative type? inference for subexpressions of the expression with the impredicative type?
18:18:48 <aristid> damn i can't figure out how to implement "tail" with my church-encoded lists</feels stupid>
18:18:52 <djahandarie> Anything involving the impredicative type in the inference, I think.
18:18:55 <tolkad> or does it kill it in a metaphysical sence
18:18:57 <tolkad> sense*
18:19:18 <tolkad> does it obliterate the very essence, the soul of type inference…
18:19:47 <dolio> aristid: tail is pretty annoying.
18:19:58 <Eduard_Munteanu> Does it? I'd think impredicatives for rank-k, k <= 2 are alright.
18:20:06 <aristid> dolio: can you give me a hint without telling me the solution? :)
18:20:06 <tolkad> aristid: http://safalra.com/science/lambda-calculus/tuples-and-lists/
18:20:12 <aristid> well, or that.
18:20:36 <dolio> aristid: Here's a vague one: you can't compute tail directly.
18:20:42 <Eduard_Munteanu> But inference is overrated ;)
18:21:56 <tolkad> yeah I already write type signatures for all top level expressions and all non-trivial let/where bound expressions
18:22:05 <dolio> If that's too vague, I can add a little.
18:23:01 <Pollione> aristid: do you have zipWith yet?
18:23:15 <aristid> Pollione: not yet
18:23:16 <Pollione> that may also not be obvious
18:23:22 <tolkad> dolio: some of these functions on church--encoded data are so mind-bogglingly inefficient, they seem useless
18:24:02 <Eduard_Munteanu> They are theoretically interesting though.
18:24:13 <tolkad> I suppose
18:24:55 <tolkad> haven't had much exposure to the theoretical side of CS yet
18:25:20 <aristid> ok, at least append is reasonably easy
18:25:55 <Eduard_Munteanu> Hrm, I think TAPL had Church-encoded lists.
18:26:03 <Eduard_Munteanu> Might come in handy if you need spoilers.
18:26:18 <ddarius> :t \n s z -> s n (n s z)
18:26:19 <lambdabot>     Occurs check: cannot construct the infinite type:
18:26:19 <lambdabot>       t = (t -> t1 -> t2) -> t2 -> t3
18:26:19 <lambdabot>     Probable cause: `s' is applied to too many arguments
18:26:43 <tolkad> Eduard_Munteanu: that page I linked him to has the basic functions: http://safalra.com/science/lambda-calculus/tuples-and-lists/
18:26:58 <ddarius> :t let f n s z -> s n (n s z) in f
18:26:59 <lambdabot> parse error on input `->'
18:27:02 <ddarius> :t let f n s z = s n (n s z) in f
18:27:03 <lambdabot>     Occurs check: cannot construct the infinite type:
18:27:03 <lambdabot>       t = (t -> t1 -> t2) -> t2 -> t3
18:27:03 <lambdabot>     Probable cause: `s' is applied to too many arguments
18:27:31 <Eduard_Munteanu> Grr, that font is horrible :)
18:27:42 <dolio> :t \n s z -> s . n s z
18:27:43 <lambdabot> forall t a b (f :: * -> *). (Functor f) => ((a -> b) -> t -> f a) -> (a -> b) -> t -> f b
18:27:52 <ddarius> dolio: Not what I want.
18:28:46 <dolio> Is it supposed to be primitive recursion?
18:28:51 <Eduard_Munteanu> What's its name? To avoid it :)
18:29:58 <ddarius> :t let f :: forall a. (forall b.(b -> b) -> b -> b) -> (((a -> a) -> a -> a) -> a -> a) -> a -> a; f n s z = s n (n s z) in f
18:29:58 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
18:29:58 <lambdabot>     When generalising the type(s) for `f'
18:29:58 <lambdabot>     In the expression:
18:30:56 <tolkad> I'm rather confused about the Curry-Howard isomorphism. Considering that types in haskell have rather large domains and most programs stick with relatively simple combinatoric types (not sure that's the right term), aren't the proofs that almost all real-world programs represent rather trivial?
18:31:07 <tolkad> oops I used the word rather twice. didn't mean to do that
18:31:43 <ddarius> :t let f :: forall a. (forall b.(b -> b) -> b -> b) -> ((forall a. (a -> a) -> a -> a) -> a -> a) -> a -> a; f n s z = s n (n s z) in f
18:31:44 <lambdabot>     Couldn't match expected type `forall a1. (a1 -> a1) -> a1 -> a1'
18:31:44 <lambdabot>            against inferred type `a -> a'
18:31:44 <lambdabot>     In the first argument of `n', namely `s'
18:32:11 <Eduard_Munteanu> tolkad: in a sense yeah.
18:32:22 <Eduard_Munteanu> Most programs are rather lengthy proofs that IO () is inhabited :)
18:32:27 <ddarius> Oh, yeah.
18:32:54 <Eduard_Munteanu> There could be interesting subproofs in there though.
18:33:03 <ddarius> :t let f :: forall a. (forall b.(b -> b) -> b -> b) -> ((forall a. ((a -> a) -> a -> a) -> a -> a) -> a -> a) -> a -> a; f n s z = s n (n s z) in f
18:33:04 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a1
18:33:04 <lambdabot>     In the first argument of `s', namely `n'
18:33:04 <lambdabot>     In the expression: s n (n s z)
18:33:22 <tolkad> Eduard_Munteanu: it would be cool if there was an FP language with dependant types, then the proofs would be nontrivial much more often
18:33:46 <tolkad> (dependant type means that each type only has one value, right?)
18:33:51 <Eduard_Munteanu> You mean a popular FP language with deptypes :)
18:33:56 <Pollione> tolkad: not at all
18:33:58 <Eduard_Munteanu> No.
18:34:13 <Eduard_Munteanu> tolkad: it means types that are parametrized by values.
18:34:33 <Eduard_Munteanu> Like type functions are parametrized by types.
18:34:51 <tolkad> so what would be the type of (+) in a deptype language?
18:34:54 <djahandarie> (Similarly, polymorphism means values that are parametrized on types.)
18:35:02 <Pollione> tolkad: Nat -> Nat -> Nat, maybe
18:35:03 <Eduard_Munteanu> tolkad: same.
18:35:11 <tolkad> but what about the value argument?
18:35:20 <Pollione> you'd define it in the same way
18:35:25 <byorgey> "it would be cool if there was an FP language with dependent types" -- Agda doesn't count?
18:35:43 <byorgey> there IS such a language, and it IS cool =)
18:35:44 <djahandarie> Agda does count imo :)
18:36:25 <byorgey> tolkad: just because you are *allowed* to have types depend on values doesn't mean you *must*.  The type of (+) does not depend on the values of its arguments.
18:36:26 <Eduard_Munteanu> A good example would be list types that encode length.
18:36:28 <megajosh2> Hey, I tried building curl-1.3.6 and it installed successfully, but I got massive linker errors when trying to compile something that uses it http://pastebin.com/r7T0Rrrr
18:36:45 <megajosh2> Anybody know what I could possibly do to solve this?
18:36:54 <lispy> byorgey: seems like Coq would count too
18:36:57 <megajosh2> I used the instructions here http://haskell.forkio.com/Home/curl-win32
18:37:01 <djahandarie> (Similarly, not every value in Haskell has a type involving a typeclass :))
18:37:13 <djahandarie> I don't think of Coq as FP, but I don't really know much either so I could be wrong
18:37:15 <byorgey> lispy: yes, it does
18:37:18 <Eduard_Munteanu> so you could have something like...
18:37:35 <Eduard_Munteanu> tail :: List a (S n) -> List a n
18:37:39 <tolkad> byorgey: would it be possible to design a language where the type of every function represented precisely what it did?
18:37:41 <lispy> Isabelle has an oddly impoverish type system compared to Haskell even
18:37:51 <ddarius> lispy: Or practically every depdendently typed system except things like Twelf.
18:37:57 <tolkad> byorgey: I guess type checking becomes impossible
18:38:07 <copumpkin> tolkad: no
18:38:28 <djahandarie> If type checking was impossible the type system would be awfully useless
18:38:29 <Eduard_Munteanu> Inference is generally impossible / incomplete.
18:38:30 <lispy> It would be weird to have the statement of a proposition include it's proof
18:38:32 <ddarius> Actually, if you have arbitrary rank intersection types, type checking follows beta reduction completely.
18:38:32 <Eduard_Munteanu> But not checking :)
18:38:36 <lispy> its*
18:38:53 <aristid> cTail :: CList a -> CList a
18:38:53 <aristid> cTail xs cons nil = fst $ xs (\a (x, y) -> (y, a `cons` y)) (nil, nil)
18:39:09 <aristid> i don't think that's cheating :P
18:39:10 <tolkad> Eduard_Munteanu: ooh that's cool. are there any languages like this?
18:39:28 <lispy> So, now that I realized these typedefs are pointers, this FFI binding is a lot easier (so far)
18:39:33 <ddarius> aristid: It is until you Church-encode pairs.
18:39:58 <byorgey> tolkad: well, Haskell can actually do that tail example Eduard_Munteanu showed =)
18:40:00 <aristid> ddarius: i only ever talked about church-encoded lists :)
18:40:14 <Eduard_Munteanu> tolkad: I've skimmed over this and it looked nice: http://strictlypositive.org/epigram-notes.ps.gz
18:40:25 <Eduard_Munteanu> Looks like a pretty nice introduction to it.
18:40:27 <dolio> aristid: That's correct.
18:40:45 <Eduard_Munteanu> tolkad: sure there are, Agda, Coq, Epigram, Ivory etc.
18:40:59 <dolio> aristid: Except, tail [] = [] there, if you care.
18:41:11 <Eduard_Munteanu> Ivory actually intends to be a Haskellish thingy just with dependent types IIRC
18:41:11 <aristid> dolio: yeah. i guess i could put an undefined there
18:41:13 <dancor> i have a build.mk with a last line of "STRIP=:".  i want to build ghc without stripping.  should i change this line?
18:41:46 <aristid> now: cTail xs cons nil = fst $ xs (\a (x, y) -> (y, a `cons` y)) (undefined, nil)
18:42:10 <djahandarie> Eduard_Munteanu, uh, you probably mean Idris, not Ivory
18:42:18 <djahandarie> Ivory is nothing like Haskell :p
18:42:42 <Eduard_Munteanu> Oh, right!
18:43:06 <dolio> Ivor is the backend to Idris.
18:43:19 <djahandarie> Haha, that does make things more confusing.
18:43:20 <byorgey> tolkad: if you're interested in learning more about this sort of thing you may want to take a look at http://www.seas.upenn.edu/~cis500/current/sf/html/index.html
18:43:22 <copumpkin> Cochony
18:44:03 <Eduard_Munteanu> Ah, the Coq tutorial on programming.
18:44:34 <djahandarie> byorgey, I really like Conor McBride's slide things for this
18:44:47 <byorgey> djahandarie: for what?
18:45:01 <djahandarie> For understanding what direction you're moving in
18:45:30 <byorgey> Conor McBride's slides are amazing.
18:46:09 <djahandarie> Probably not to useful without him talking over it though
18:46:19 <Eduard_Munteanu> I also found Conor's Epigram paper I just linked to be nicely written.
18:46:37 <BMeph> Isn't the "isempty" function on that website backwards? I.e., it should have the "false" and "true" values swapped/
18:46:39 <Eduard_Munteanu> s/to/to to/
18:46:41 <BMeph> .
18:47:21 <Eduard_Munteanu> Where?
18:49:29 <byorgey> BMeph: which website?
18:50:44 <BMeph> byorgey: [__:29] <tolkad> aristid: http://safalra.com/science/lambda-calculus/tuples-and-lists/
18:51:41 <byorgey> ah, yes, I think you're right
19:07:42 <jaredj> hello all
19:07:46 <tolkad> byorgey: thanks, bookmarked
19:08:46 <jaredj> i'm trying to make a quilt out of a qr-code. in order to do that i need to find the black and white rectangles of maximal area
19:09:50 <jaredj> does it make sense to start with a Data.Array?
19:11:00 <jaredj> :d that was a bit open ended wasn't it. well this is a little like the pentominoes problems discussed by knuth in "dancing links," but i don't know the shape of the pentominoes :(
19:13:06 <lpsmith> jaredj, Data.Array is fine for mostly-read data that changes infrequently
19:13:07 <lpsmith> The bigger the array,  the less frequently it should change.
19:13:07 <lpsmith> Because you have to copy the entire array to change something
19:13:08 <lpsmith> for data that changes frequently,  you'll need mutation or a data structure that supports more efficient updates
19:13:47 <jaredj> ok
19:20:46 <ddarius> If you change everything at once, it isn't really any more expensive than mutating (other than temporarily having two copies of the array live.)
19:21:37 <jaredj> well - upon thinking, the thing i'm really worried about is not the pixels ("modules" they say) of the qr-code, but rectangles of black and white
19:22:15 <jaredj> if i have a list of rectangles, i want to know if it covers the whole code
19:22:32 <jaredj> if it doesn't, i want to know where to start to make more rectangles
19:23:32 <jaredj> ..... since whether two rectangles interact depends on how close they are to each other, i want a quadtree, don't i
19:24:10 <jaredj> i feel like this is a question on an algorithms final but i took the class eight years ago and now i'm failing the exam ;P
19:25:29 <napping> why do you want to make larger rectangles for a quilt?
19:26:27 <jaredj> the qr code is made of pixels, right, but some areas of pixels are the same color
19:27:03 <jaredj> it's advantageous to use one piece of fabric for that, rather than sewing pixel-sized pieces together: less sewing
19:27:37 <napping> Ah, you want less sewing
19:28:00 <byorgey> oh! you are talking about making an ACTUAL PHYSICAL quilt.
19:28:08 <jaredj> YES :)
19:28:10 <byorgey> I thought 'quilt' was some sort of technical term =)
19:28:13 <jaredj> hehe
19:28:21 <copumpkin> lol
19:28:28 <jaredj> well i'm designing it, my wife is making it :)
19:29:21 <copumpkin> the quilt functor and its associated natural isomorphism with the famous free duvet functor
19:29:31 <byorgey> yes, of course
19:30:11 <jaredj> in fact i'm not even sure that regions of maximal are ensure the least sewing
19:30:33 <jaredj> it only seams that way
19:30:50 <copumpkin> ddarius got everyone giggling about cleavage last night
19:30:55 <copumpkin> when talking about fibrations
19:31:00 <ddarius> jaredj: You could write a term that calculates how much sewing would be needed and optimize that function.
19:31:13 <copumpkin> one would think that we'd be over that by now
19:31:16 <napping> why can't you just make connected regions?
19:31:16 <byorgey> jaredj: hehehe
19:32:13 <napping> you have to sew at boundaries, you don't have to sew elsewhere (if you can get large enough fabric)
19:32:19 <byorgey> everyone knows quilts have to be made out of rectanges
19:32:36 <byorgey> Law of the Quilt, Chapter 4, Section 29, subparagraph I(a)(iii)
19:32:47 <Ptival> :o
19:32:48 <jaredj> heh
19:33:34 <Ptival> even more if it's a monochrome
19:34:35 * ddarius unconsciously correctly makes distinctions between syntax and semantics.
19:34:41 <jaredj> hmm so if i split the area up using a quadtree or bsp tree, the question instantly arises of how to unite regions across partitions. that's not really attractive
19:36:53 <tolkad> jaredj: Data.Array makes a full copy whenever you write. The advantage of Data.Array over a tuple is that it that you can index it using a memory offset rather than a case-expression
19:37:21 * ddarius wonders if you could use a 2D Fourier series to quickly answer this.
19:37:21 <jaredj> can i talk about rectangles in it?
19:38:21 <ddarius> I guess a wavelet transform with the Haar function would be more appropriate.
19:38:30 <tolkad> jaredj: I think there's an Ix instance for "forall a. (Ix a, Ix b) => (a, b)". this is convenient for 2-dimensional indexing
19:38:46 <tolkad> forall a b.*
19:39:28 <tolkad> jaredj: but there may be collisions? I think it just uses a xor
19:40:27 <djahandarie> copumpkin, I swear I was trying to not laugh at that, but edwardk was dying to my right so I couldn't help it
19:40:41 <jaredj> tolkad: i've had arrays indexed by 2-tuples before
19:40:51 <copumpkin> no it doesn't use xor
19:40:58 <copumpkin> it does the usual flattening thing
19:41:10 <tolkad> copumpkin: oh, nevermind then, don't know where I got that idea
19:41:12 <jaredj> the huh?
19:41:23 <copumpkin> the y * width + x thing
19:41:26 <copumpkin> or whatever order you prefer
19:41:45 <copumpkin> you can do it at arbitrary dimensions
19:41:49 <copumpkin> repa does
19:43:38 <copumpkin> djahandarie: I JUDGE YOU
19:44:15 <jaredj> oh right
19:44:21 <djahandarie> :(
19:44:24 <jaredj> that flattening thin
19:45:50 <maurer_> Is there any way to allow an OS thread to kill itself?
19:46:26 <copumpkin> an OS thread?
19:46:32 <maurer_> created by forkOS
19:46:35 <a930913> Why should I learn haskell?
19:46:37 <copumpkin> that's not what forkOS does
19:46:42 <copumpkin> a930913: because you like learning?
19:46:53 <copumpkin> maurer_: it doesn't create a new thread
19:47:01 <a930913> copumpkin: True, but why not some other language?
19:47:13 <copumpkin> a930913: because it's completely different from most other languages
19:47:15 <maurer_> copumpkin: OK, what I'm actually trying to do is make my app clean up after itself
19:47:21 <copumpkin> maurer_: all it does is guarantee that FFI calls made from that thread come from the same OS thread
19:47:25 <a930913> copumpkin: How so?
19:47:36 <maurer_> copumpkin: I run it, and it returns me to the prompt, but there are still processes associated
19:47:59 <maurer_> copumpkin: Yeah, I'm using it for that (ptrace limitations) but it seems not everything is dead when the main app exits
19:48:02 <ddarius> a930913: You should learn other languages as well.
19:48:03 <copumpkin> a930913: laziness, a fairly clean and consistent type system that doesn't make you swear at it every few minutes, no mutation, tying your brain in knots regularly, and more possibilities for abstraction than just about anything else offers these days
19:48:30 <copumpkin> maurer_: hmm, I think you can register finalizers on ForeignPtrs if you have any
19:48:41 <a930913> How does it compare in speed to other languages?
19:48:57 <maurer_> copumpkin: How would htat help?
19:48:59 <copumpkin> GHC's implementation of haskell can be pretty fast, but like any language, you can write shit slow code in it
19:49:00 <maurer_> *that help?
19:49:23 <maurer_> copumpkin: I'm not hitting memory leak issues, it's just that there are still processes spinning after my app exits.
19:50:09 <copumpkin> hmm
19:50:26 <copumpkin> you could do a "with" idiom
19:50:41 <copumpkin> that takes an IO block, sets stuff up before it, and takes care of cleaning up after it
19:50:57 <copumpkin> otherwise, I'm not sure there's a portable way to hook onto the moment your program exits
19:51:37 <tolkad> companion_cube: oh, I know where I got the idea, I was thinking of the tuple instance for Hashable, where it makes perfect sense to xor :P it also does a shift first
19:51:40 <tolkad> whoops
19:51:44 <tolkad> meant to ping copumpkin 
19:51:47 <copumpkin> :)
19:52:32 <a930913> How does Haskell compare in speed to other languages?
19:52:38 <copumpkin> I just answered that
19:52:47 <tolkad> a930913: http://shootout.alioth.debian.org/
19:52:56 <tolkad> a930913: pretty fast actually
19:53:18 <a930913> Sorry copumpkin I didn't see it above.
19:53:28 <napping> If both are highly tuned, about 1/2 C is reasonably common
19:54:08 <tolkad> a930913: for example, http://shootout.alioth.debian.org/u32q/which-programming-languages-are-fastest.php
19:54:20 <napping> for micobenchmarks and heroic measures, at least
19:54:48 <ddarius> Much of the examples could be simplified now with little or no cost to performance.
19:55:00 <ddarius> Even more could be simplified by using the features GHC provides.
19:55:07 <maurer_> copumpkin: I'm not trying to hook the moment my program exits, I'm trying to make it so that when a trace thread hits an error condition, and it explodes, the process will go away.
19:55:32 <copumpkin> maurer_: it seems like what I described could still work
19:55:35 <copumpkin> possibly with a bracket
19:56:26 <copumpkin> @hoogle bracket
19:56:27 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:56:27 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:56:27 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:58:21 <kevinburke> this is dumb, but is there any way to get unwrapped data out of a monad? or compute any value in a monad and refer to it from outside a do block?
19:59:15 <Eduard_Munteanu> kevinburke: depends on the monad
19:59:26 <Eduard_Munteanu> There's stuff like evalState for State.
19:59:30 <Eduard_Munteanu> :t evalState
19:59:31 <lambdabot> forall s a. State s a -> s -> a
19:59:44 <Eduard_Munteanu> :t runST
19:59:45 <lambdabot> forall a. (forall s. ST s a) -> a
19:59:56 <mjrosenb> and head and last and (!) for []
20:00:09 <Eduard_Munteanu> Or in cases where the constructor is exposed, like for Maybe.
20:00:29 <mjrosenb> but for IO, you probably shouldn't do that.
20:00:59 <copumpkin> :t runST
20:01:00 <lambdabot> forall a. (forall s. ST s a) -> a
20:01:16 <Eduard_Munteanu> For IO, there's no way except unsafePerformIO and friends, but try to ignore that atm.
20:02:00 <a930913> Would certain Haskell functions such as mapping be much faster on an array processor?
20:02:13 <c_wraith> If you're tempted to use unsafe*, assume that you're wrong until you learn why it's named that.
20:02:20 <mjrosenb> what is the differeence between ST and State?
20:03:04 <byorgey> a930913: sure, and indeed, there is a neat project to create a data-parallel variant of Haskell which does exactly that
20:03:07 <Eduard_Munteanu> mjrosenb: State keeps a single state value. ST doesn't keep one, but you can make STRef in it.
20:03:08 <ddarius> a930913: Accelerate collects a bunch of functions together which fit GPU architectures well.
20:03:28 <byorgey> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
20:03:41 <ddarius> Incidentally, it's implementations, not functions, that would be faster.
20:03:41 <mjrosenb> Eduard_Munteanu: and you can use STRef's without doing IO?
20:03:42 <Eduard_Munteanu> mjrosenb: which is like allocating storage for objects and doing r/w there
20:03:47 <Eduard_Munteanu> Yes.
20:04:08 <copumpkin> @hackage accelerate
20:04:08 <lambdabot> http://hackage.haskell.org/package/accelerate
20:04:22 <mjrosenb> ahh, so STRefs are like IORefs without the IO... I'll need to keep that in mind.
20:04:26 <Eduard_Munteanu> Yep.
20:04:39 <copumpkin> ST is like IO without the IO
20:04:44 <copumpkin> and only the mutable references
20:04:52 <byorgey> mjrosenb: also, State is just a pure functional representation of state passing.  ST is implemented with actual mutation under the hoodl, but packaged in an API to make it safe
20:04:52 * mjrosenb has always stayed away from ST because i never knew what it did
20:05:04 <byorgey> ST is quite nifty.
20:05:23 <mjrosenb> byorgey: ahh. yeah, i've used State, and written my own State-like code
20:05:24 <Eduard_Munteanu> ST is better if you don't need IO.
20:05:40 <mjrosenb> also nested StateT's like 5 levels deep :(
20:05:49 <Eduard_Munteanu> Wow, why? :)
20:06:10 <ddarius> Because tuples are evil, man.
20:06:12 <copumpkin> you need 5 variables! ;)
20:06:25 <mjrosenb> copumpkin: essentially.
20:06:53 <copumpkin> mjrosenb: the usual approach is to have a record of your state
20:07:12 <ddarius> Records are just, like, labelled tuples, man.
20:07:22 <kevinburke> Eduard_Munteanu: http://hpaste.org/45235/monadwrapping
20:07:43 <mjrosenb> copumpkin: right, but the top level had its own state, that called off to helper functions that had their own state, that had helper functions....
20:07:44 <copumpkin> ddarius: like totally, dude
20:09:29 <Eduard_Munteanu> kevinburke: I'm not sure what you want to do there. A pure approach might be workable.
20:10:07 <kevinburke> freshTemp keeps a global counter that increments by 1 every time you call it, so that's why it's wrapped in IO
20:10:26 <maurer_> copumpkin: Got it, thanks.
20:11:03 <Eduard_Munteanu> kevinburke: you want something like a global variable?
20:11:23 <Eduard_Munteanu> That's not really possible, though there are workarounds.
20:11:33 <kevinburke> for the sake of argument, let's say I can't control the return type of freshTemp
20:12:06 <kevinburke> could I pull varAccess out of the do block and use it outside, somehow, without re-wrapping it in a monad?
20:12:49 <a930913> If I'm doing http://www.city.ac.uk/courses/undergraduate/computer-science next year, should I learn Haskell now, or continue learning ASM, C and C++ and learn Haskell  at uni?
20:12:59 <Eduard_Munteanu> kevinburke: nope
20:14:24 <pumpkin> a930913: I'd definitely learn haskell
20:14:24 <lambdabot> pumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
20:14:32 <pumpkin> in fact, I wish I'd been exposed to it earlier
20:14:52 <pumpkin> dmwit: thanks for the info :)
20:15:20 * a930913 doesn't want to go there :'(
20:15:32 <Eduard_Munteanu> kevinburke: you might want to take a look at this http://www.haskell.org/haskellwiki/Global_variables
20:15:54 <Eduard_Munteanu> I could also add you could use the State monad to do that.
20:17:01 <byorgey> a930913: the answer to "should I learn this now or should I wait until X" is always now. =)
20:17:32 <a930913> byorgey: But it was a learn this or that question.
20:18:06 <gienah> a930913: learning Haskell will help with learning C++
20:18:07 <byorgey> fair enough.  well, the answer to that question is also to learn Haskell now.
20:18:23 <byorgey> gienah speaks truth.  But the other way around does not hold.
20:18:45 <a930913> Are there pointers?
20:19:00 <gienah> @where lyah
20:19:00 <lambdabot> http://www.learnyouahaskell.com/
20:19:06 <Eduard_Munteanu> Mmm, I'd go with asm, C and Haskell first, each is a strong representative in their own class.
20:19:23 <Eduard_Munteanu> C++ is less, if you need higher level abstraction and stuff, you can always go Haskell.
20:19:42 <pumpkin> a930913: yeah, we have pointers if you want to do low-level stuff
20:19:48 <pumpkin> but you generally only do that when talking to c libraries
20:20:04 <napping> something like Lua or Python might be good to throw in as well
20:21:05 <a930913> napping: Python is an order of magnitude slower.
20:22:02 <napping> yeah, probably
20:22:18 <napping> but languages like that are pretty commonly used too
20:22:47 <Eduard_Munteanu> It also depends on your interests.
20:22:48 <teratorn> a930913: languages don't have speeds
20:23:06 <teratorn> also, Python is not just one implementation anymore
20:23:21 <a930913> That's due to society being of the opinion that we can throw better hardware at poor code rather than code it correctly.
20:23:29 <Eduard_Munteanu> If you're going to do stuff like Linux kernel hacking you should probably learn C first.
20:23:42 <mjrosenb> teratorn: i'd say that malbolge is 'slow'.
20:24:34 <napping> teratorn: if you want to be pedantic, 
20:25:32 <napping> I don't see why languages can't be slower than others in universal senses, like constant factors of any interpreter - and things like Rice's thereom limit the ability of compilers to fix that
20:25:32 * hackagebot JSON-Combinator 0.2.7 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.7 (TonyMorris)
20:25:38 <teratorn> napping: OK, how fast is haskell judging by the language spec?
20:26:15 <dancor> it's hard to formalize
20:26:31 <a930913> ~2.6x slower than C.
20:26:31 <teratorn> it's not hard, it's impossible
20:26:43 <teratorn> a930913: wrong
20:26:43 <dancor> well there might still be something interesting there
20:26:50 <napping> The standard I proposed is probably uncomputable
20:27:03 <teratorn> a930913: any answer is wrong, because the question is ridiculous
20:27:19 <gienah> a930913: on parallel stuff Haskell is faster: http://shootout.alioth.debian.org/u64q/performance.php?test=threadring
20:27:51 <c_wraith> the threadring is not a parallel test.  It's not even a concurrent test.  It's just a thread scheduling test.  but haskell is really good at that.
20:27:59 <teratorn> gienah: GHC, you mean?
20:28:08 <c_wraith> and yes, I mean GHC
20:28:17 <gienah> teratorn: yes
20:28:28 <dancor> teratorn: "GHC"?  how can you speak so generally?  what version?
20:28:37 <teratorn> dancor: sure
20:28:38 <dancor> and what acronym-insatnce
20:29:17 <a930913> gienah: Now that /does/ look impressive.
20:29:19 <c_wraith> But yeah.  The threadring test is just a token-passing test.  no more than one thread is ever active at once.  It's just a test of how fast control transfers between contexts, if only one is active at once.  GHC happens to be *really* good at that.
20:29:24 <napping> dancor: version? what compiler? what platform? are you sure the build process is deterministic?
20:29:48 <dancor> must report headplosion state as well
20:31:10 <gienah> a930913: the haskell parallel runtime is very fast at context switching between threads, and each thread on Haskell only takes about 200 bytes of memory, so you can have millions of Haskell threads
20:32:43 <gienah> a930913: this is a video that talks about parallel haskell: http://dl.dropbox.com/u/2275898/SPJ%20-%20Managing%20Parallelism.mp4
20:33:37 <dancor> what is more horiz-scalable than postgres but not all-memory like macid
20:41:32 <dancor> i hear postgres is crash-only which is nice
20:42:02 <dancor> i think couchdb is as well
20:42:35 <gienah> dancor: i am not sure what you mean by "postgres is crash-only"
20:43:20 <a930913_> FF died trying to play the vid :(
20:43:29 <dancor> gienah: http://en.wikipedia.org/wiki/Crash-only_software
20:43:48 <dancor> mysql is not this way in my experience
20:44:06 <gienah> a930913_: http://skillsmatter.com/podcast/scala/talk-by-haskell-expert-simon-peyton-jones/js-1434
20:45:26 <gienah> a930913_: the first link to the vid was a 150MB .mp4 file, it plays ok in mplayer
20:45:40 <ddarius> dancor: Technically the D in ACID should make all databases provide crash-only behavior.
20:46:52 <napping> it seems my package databases are confused
20:46:58 <napping> is there any way to sort that out?
20:49:00 <gienah> dancor: since it is much more difficult to ensure the correctness of a database server (especially in avoiding database corruption) if it tries to recover from error conditions, some database servers take the view that is better to have lots of assertions on internal state 
20:49:29 <gienah> dancor: and to ensure that the database server can recover the database from the transaction log when it restarts
20:50:37 <napping> http://hpaste.org/45236/cabal_errors
20:52:57 <monochrom> haskell programs are crash-only :)
20:53:02 <gienah> napping: maybe sed the filepath dependency
20:53:31 <gienah> napping: to bump it to try to avoid: package directory-1.1.0.0 requires filepath-1.1.0.4
20:53:40 <gienah> napping: package process-1.0.1.5 requires filepath-1.2.0.0
20:55:46 <napping> I guess cabal doesn't have a decent dependency resolver?
20:56:39 <tawe> I have to thank this channel :), I got 100% in my functional programming test in university :)
20:57:02 <Zao> tawe: Yay!
20:57:31 <gienah> napping: I do not know, I never use cabal. This is how we build it on gentoo: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/sci-mathematics/agda
20:57:47 <ddarius> tawe: Now that the test is passed, you can dump all this nonsense.
20:58:13 <monochrom> pass the java test, and dump the java nonsense
20:58:22 <dmwit> napping: cabal install --reinstall the packages in question?
20:59:08 <Locke1689> Hey guys, I have a kind of design-type question. I'm defining two different data types, RVal and LVal. RVal can be a value of type MemRef, as well as LVal. However, if I name them the same thing it owuld result in a conflict. Is there a clean way to avoid constructor name collision?
21:00:09 <monochrom> napping: at this stage, a clean start may be the easiest. and take this as a lession for not being promiscuous in installing multiple versions of packages
21:00:30 <dmwit> Locke1689: Something like data LVal = ...; data RVal = ... | LVal LVal -- ?
21:01:20 <mjrosenb> is there an easy way to convert a [Char] to a ByteString?
21:01:40 <dmwit> ?hackage encoding
21:01:40 <lambdabot> http://hackage.haskell.org/package/encoding
21:01:42 <monochrom> define "convert"
21:01:42 <Locke1689> dmwit: kind of. see http://hpaste.org/45237/constructors
21:01:56 <napping> mjrosenb: pack
21:02:07 <monochrom> and I am serious. "昌" should be converted to... ?
21:02:16 * pumpkin slaps napping 
21:02:26 <dmwit> Be careful with pack.
21:02:36 <pumpkin> yeah, you'll get slapped by me if you use it
21:02:39 <pumpkin> (for this)
21:02:51 <mjrosenb> :t pack
21:02:52 <lambdabot> forall o n. (Newtype n o) => o -> n
21:03:00 <napping> that's a different pack
21:03:05 <dancor> :t BSC.pack
21:03:06 <pumpkin> @hoogle pack
21:03:06 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
21:03:06 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
21:03:06 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
21:03:06 <lambdabot> String -> BSC.ByteString
21:03:28 <dmwit> Locke1689: Just give them different names. LMemory and RMemory, for example.
21:03:31 <mjrosenb> monochrom: so i have a package that expects a filepath as a bytestring, and I want to try it out by just typing stuff into ghci.
21:03:57 <pumpkin> :k FilePAth
21:03:58 <monochrom> my filepaths contain "昌".
21:03:58 <lambdabot>     Not in scope: type constructor or class `FilePAth'
21:04:00 <pumpkin> :k FilePath
21:04:01 <lambdabot> *
21:04:08 * pumpkin wonders why it doesn't just use that
21:04:08 <Locke1689> dmwit: Sure, that's the easy way. Fundamentally, it seems like they should be the same constructor though, because theyre the same reference
21:04:11 <monochrom> so you still have to answer my question.
21:04:24 * dancor saw my command, pumpkin's command, pumpkin's answer, then my answer.  lbot doesn't maintain order?
21:04:24 <Locke1689> dmwit: there's no more idiomatic way to "share" a constructor or something?
21:04:38 <mjrosenb> pumpkin: presumably it is a *very* thin layer on top of a C library
21:04:40 <dmwit> Locke1689: No. What would be the type of such a constructor?
21:04:54 <Locke1689> hmm
21:04:57 <mjrosenb> pumpkin: and well, tat was the easiest thing to do
21:05:02 <ddarius> dmwit has brought out the omnihammer.
21:05:12 <Locke1689> good point
21:05:16 <monochrom> mjrosenb: I have a feeling that you haven't read http://www.joelonsoftware.com/articles/Unicode.html
21:05:18 <pumpkin> dancor: IRC isn't ordered, and for what it's worth I saw my command first ;)
21:06:24 <napping> For converting ascii string literals, pack is fine
21:06:37 <dancor> ah
21:06:55 <monochrom> yes he/she has to explicitly say "assume ascii" if that is his/her definition of "convert"
21:06:55 <copumpkin> well, does it produce the right kind of ByteString?
21:07:03 <copumpkin> given there are a bunch of of them
21:07:11 <ddarius> Where "a bunch" = 2
21:07:16 <monochrom> this is why I began by asking "define convert"
21:07:18 <copumpkin> fine :P
21:07:29 * dmwit points out that "ASCII" is one of the encodings in the "encoding" library, and that it will additionally give you a very nice error if you fuck it up.
21:08:27 <dmwit> ...or at least, it would, if the maintainer had applied my patch. =(
21:12:19 <napping> mjrosenb: the important thing to understand is that Char is (supposed to be) a unicode code point, and ByteString is a string of bytes
21:13:11 <monochrom> you may like to know that windows use utf-16 for filepaths, so bytestring is fundamentally flawed for filepaths
21:13:33 <napping> how so?
21:13:41 <napping> utf-16 is an encoding
21:15:30 <monochrom> well then, windows file API C binding uses 16-bit "wide char" for filepaths, so "I use bytestring to talk to the C code" is flawed
21:17:45 <megajosh2> Hey, has anybody tried installing the curl package on Windows?
21:18:07 <megajosh2> I followed some instructions and got it to install, but I get a huge wall of linker errors when I try to compile anything using that package
21:18:23 <megajosh2> http://haskell.forkio.com/Home/curl-win32 from here
21:19:10 <napping> maybe it's not finding the library?
21:19:22 <megajosh2> I'm not entirely sure
21:19:29 <megajosh2> Here's what I got; one second
21:20:27 * ddarius wonders if theorymine can actually give that time bound: http://theorymine.co.uk/?go=discover
21:20:33 <megajosh2> napping: Here's what happened http://hpaste.org/45238/serious_linker_errors
21:21:08 <dmwit> ddarius: hah
21:21:40 <dmwit> megajosh2: Well, have you got an SSH library installed?
21:22:06 <megajosh2> SSH library?
21:22:08 <dmwit> Also, what is up with Windows?
21:22:10 <megajosh2> This is all for curl
21:22:28 <napping> so it is finding the curl library
21:22:39 <megajosh2> Well, when I try to install curl without any extra options with cabal, it tells me the libraries are missing
21:22:41 <napping> A lot of those errors do look like it's missing an SSL library
21:23:12 <napping> all the lines mentioning libcurl.a(ssh.o)
21:23:14 <megajosh2> Should I try copying / moving the DLLs associated with cURL to somewhere it might find them?
21:23:20 <megajosh2> If it isn't already
21:23:30 <napping> no, it's clear it's finding libcurl.a
21:23:46 <napping> lines 10 and up are about libcurl not finding things it needs
21:24:55 <dmwit> megajosh2: Did you build curl from source?
21:25:08 <megajosh2> Could that be the problem?
21:25:09 <dmwit> If so, that page you linked to seems to suggest you need to build SSL and LDAP support from source, as well.
21:25:14 <megajosh2> dmwit: Actually, no
21:25:29 <dmwit> Okay. So you grabbed the .zip file, then.
21:25:43 <megajosh2> Yeah
21:26:02 <megajosh2> It came with binaries as well as those .a libraries and some C headers and source
21:27:24 <megajosh2> Hmmm
21:27:35 <megajosh2> I just looked in build.txt
21:27:49 <megajosh2> Features: AsynchDNS GSS-Negotiate IDN Largefile NTLM SSL SSPI libz 
21:28:08 <megajosh2> I need to compile some other things in I guess
21:35:39 <sohum> @pl \(x,y) -> (f x, y)
21:35:39 <lambdabot> first f
21:36:10 <mjrosenb> monochrom: so the library is broken; i'd still like to use it.
21:36:30 <megajosh2> :t first
21:36:31 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
21:36:47 <napping> mjrosenb: what was the problem?
21:37:29 <mjrosenb> napping: taglibc wants me to specify files as a ByteString; i want to use String.
21:37:43 <napping> why do you want to use a string?
21:38:13 <monochrom> what kind of bytes does taglibc expect?
21:38:28 <mjrosenb> monochrom: haven't a clue.
21:38:39 <mjrosenb> napping: iirc, FilePath is actually a String.
21:38:44 <monochrom> well then that begs the question
21:38:47 <napping> yes, it is
21:38:51 <mjrosenb> napping: but in reality, I want to use FilePath.
21:39:28 <kmc> you can convert String to ByteString if you choose a character encoding
21:40:33 <mjrosenb> http://hackage.haskell.org/packages/archive/libtagc/0.12.0/doc/html/Audio-TagLib-TagLib.html; the docs say that the tags are UTF8 encoded, i'd guess he assumes that the files are also utf8 encoded.
21:40:50 <kmc> http://hackage.haskell.org/packages/archive/utf8-string/0.3.6/doc/html/Data-ByteString-UTF8.html
21:45:46 <napping> monochrom: so, cabal is incapable of reliably upgrading packages?
21:46:43 <monochrom> cabal is incapable of reliably resolving logical inconsistencies
21:47:21 <monochrom> oh, upgrading? you're right, cannot reliably upgrade.
21:47:35 <monochrom> in fact I posit that nothing can reliably upgrade
21:48:40 <kmc> Nix?
21:49:14 <napping> and what is logically inconsistent about compiling Agda-2.2.10?
21:49:16 <monochrom> Nix is more like override than upgrade.
21:50:34 <monochrom> compiling Agda-2.2.10 over a sane set of installed packages is logically consistent.
21:50:43 <napping> especially with license to compile and install additional packages if necessary
21:50:44 <monochrom> but your set is insane
21:50:50 <copumpkin> napping: probably something else you installed in the mean time put something in user that was also in system
21:51:04 <copumpkin> napping: look at ghc-pkg list and see if you have the exact same thing on both user and system
21:51:17 <napping> copumpkin: yes, there seems to be one of those
21:55:38 <monochrom> napping: See my http://www.vex.net/~trebla/haskell/sicp.xhtml for many ways to screw your packages.
22:01:27 <napping> ah, that's actually useful
22:02:15 <monochrom> it is very depressing that my article is useful. especially when it doesn't say how to get out of a mess; all it does is to tell you how to get into more mess.
22:03:33 <napping> wait, does GHC not allow multiple copies of the same package with different hashes?
22:03:53 <koninkje> nope. Only different versions
22:04:13 <monochrom> allows, if there are two, one in global and one in user.
22:04:26 <napping> so that's why things break so badly
22:04:28 <koninkje> This is esspecially problematic when dealling with butterfy dependencies.
22:04:56 <monochrom> if you circumvent ghc-pkg safety checks, you can sneak in more
22:04:59 <koninkje> s/butterfy/butterfly/
22:05:50 * koninkje wishes ghc-pkg/cabal used a more Nix-like system
22:06:17 <dancor> if loading a huge trie of ints from disk is too slow, is it smarter to use a c trie or to implement an int trie in haskell via like Vector
22:06:39 <pumpkin> figure out why it's slow
22:06:45 <pumpkin> then figure out what to do about it ;)
22:06:54 <dancor> you've just created more problems!
22:06:55 <kmc> that's deep man
22:06:58 <kmc> there are already int tries for haskell
22:07:09 <kmc> do you mean to invent a new structure which matches the on-disk format?
22:07:11 <dancor> data-inttrie
22:07:13 <pumpkin> loading from disk is often slow with default binary instances because they go through lists
22:07:16 <kmc> Data.IntMap is a trie
22:07:25 <kmc> you could mmap the trie on disk
22:07:28 <kmc> thus reading it lazily
22:07:32 <kmc> (and non-sequentially)
22:07:47 <dancor> kmc: ya in general a big perf problem i often hit in haskell is that i can't just map memory off disk to load a structure
22:08:00 <dancor> hm
22:08:00 <napping> only allowing one package to use a version number seems to be the root of the problem
22:08:12 <pumpkin> I wrote a vector-mmap if that helps
22:08:20 <napping> and I suppose that could be worked around by artificially adding another version component
22:08:22 <pumpkin> @hackage vector-mmap
22:08:22 <lambdabot> http://hackage.haskell.org/package/vector-mmap
22:08:27 <dancor> nice
22:08:31 <koninkje> kmc: Data.IntMap is a trie on bits, not on Ints
22:08:32 <pumpkin> I can't say I've ever really used it much though
22:08:35 <pumpkin> so it may be busted
22:08:37 <kmc> you can do that though dancor
22:08:40 <kmc> koninkje, oh, i see
22:08:47 <kmc> the keys are vectors of ints?
22:08:51 <kmc> Data.HashMap might be good enough
22:09:08 <koninkje> kmc: and not really a trie on bits, since it requires all entries to have the same number of bits (i.e. sizeOf Int)
22:09:57 <koninkje> dancor: depending on what your needs are, Data.Trie may be helpful.
22:10:03 <mjrosenb> is it a trie on bits, or groups of n bits, for some constant n?
22:10:04 <pumpkin> just a quick survey: how do y'all pronounce trie?
22:10:34 <dancor> pumpkin: "a try" bc unambig even if historically wrong
22:10:34 <koninkje> mjrosenb: it's a bitwise trie on a group of (sizeOf Int) bits.
22:10:48 <pumpkin> dancor: yeah :/ what a fucking dumb name, eh :P
22:10:52 <dancor> heh
22:11:25 <koninkje> mjrosenb: with node fusion, but without tail merging
22:11:38 * dancor makes new special type of queue called cue
22:12:00 <pumpkin> lol
22:12:16 <mjrosenb> koninkje: but it has a bunch of nodes that have at *most* two children.
22:13:38 <dancor> kmc, koninkje: i thought that in using Data.Trie i cannot mmap the structure to save it.  is that true?
22:14:01 <dancor> i thought i had to use a slower serialization because it's not a serial structure.
22:14:06 <dancor> (in memory)
22:14:17 <dancor> highly nonserial in memory
22:14:22 <djahandarie> > floor (1/0)
22:14:23 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
22:14:36 <pumpkin> djahandarie: yay
22:14:51 <pumpkin> > ceil (1/0)
22:14:52 <lambdabot>   Not in scope: `ceil'
22:14:55 <pumpkin> > ceiling (1/0)
22:14:56 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
22:15:03 <pumpkin> > length . show $ ceiling (1/0)
22:15:05 <lambdabot>   309
22:15:14 <pumpkin> > length . show $ ceiling (1/0 :: Float)
22:15:16 <lambdabot>   39
22:15:37 <dancor> i guess i'm asking to what extent haskell libraries for (highly-serial-in-memory data structures) exist, or to what extent such libraries are as good idea as i think
22:15:41 <koninkje> dancor: true, you can't mmap it
22:15:43 <djahandarie> This is actually why languages like Java have Math.floor from Double -> Double
22:15:54 <djahandarie> So they can 'handle' infinities and NaNs
22:16:02 <koninkje> dancor: I mostly mentioned it because it has node fusion which Data.IntTrie doesn't
22:16:07 <dancor> ah
22:16:48 <koninkje> dancor: what format are you trying to read from disk?
22:18:30 <napping> it seems adding a string version component could disambiguate builds
22:18:49 <dancor> koninkje: ?  i can choose that.  in haskell i usually use Data.Serialize or whatever, but then there are plenty of times when that leads to hilarious loadtimes for programs working with lots of data.  so i want something more like mmap-able.
22:19:22 <djahandarie> > (1/0) :+ (1/0)
22:19:23 <lambdabot>   Infinity :+ Infinity
22:19:28 <koninkje> Ah. I didn't know if it was data from someone else or what
22:19:28 <djahandarie> > floor $ (1/0) :+ (1/0)
22:19:29 <lambdabot>   No instance for (GHC.Real.RealFrac (Data.Complex.Complex t))
22:19:29 <lambdabot>    arising fro...
22:19:36 <dancor> :t 1/0
22:19:36 <lambdabot> forall t. (Fractional t) => t
22:19:51 <djahandarie> > conjugate $ (1/0) :+ (1/0)
22:19:52 <lambdabot>   Infinity :+ (-Infinity)
22:21:13 <napping> monochrom: it seems the problem is not rebuilding packages at all, but that rebuilding one package removes the old version
22:25:34 <djahandarie> > 1/0 :: Int
22:25:35 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
22:25:35 <lambdabot>    arising from a use o...
22:25:45 <djahandarie> > floor (1/0 :: Float)
22:25:45 <lambdabot>   340282366920938463463374607431768211456
22:27:39 <Axman6> > floor (1/0 :: Double)
22:27:40 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
22:28:05 <Axman6> > read . show $ (floor (1/0 :: Double)) :: Double
22:28:07 <lambdabot>   Infinity
22:28:14 <Axman6> :o
22:28:35 <djahandarie> > show $ (floor (1/0 :: Double)) :: Double
22:28:35 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
22:28:35 <lambdabot>         against inferred ty...
22:28:44 <djahandarie> > show $ (floor (1/0 :: Double))
22:28:45 <lambdabot>   "17976931348623159077293051907890247336179769789423065727343008115773267580...
22:28:50 <djahandarie> Heh
22:30:48 <dancor> > read ('3':replicate 38 '0') :: Float
22:30:49 <lambdabot>   3.0e38
22:30:52 <dancor> > read ('4':replicate 38 '0') :: Float
22:30:53 <lambdabot>   Infinity
22:35:18 <dancor> pumpkin: why are vector-mmap funcs "unsafe"
22:35:40 <pumpkin> dancor: because they can change behind your back
22:36:26 <dancor> pumpkin: in that the file could be changed between the time you write it and read it?
22:36:46 <pumpkin> even if you don't write to it
22:39:03 <dancor> pumpkin: sorry i'm dumb, do these functions violate refential transparency?
22:39:32 <pumpkin> no, but you get a Vector out of them
22:39:44 <pumpkin> which you can then use in pure code
22:39:50 <pumpkin> you can't assume it won't change during your pure code
22:40:03 <dancor> oh
22:41:33 <kmc> too bad MAP_DENYWRITE doesn't work on Linux
22:43:58 <kmc> you could use a filesystem which supports snapshots
22:45:28 <ddarius> "Even diamonds will be destroyed in the heat death of the universe; theorems won't be."
22:46:37 <kmc> neither will invisible pink unicorns
22:48:17 <dancor> plato is rolling in his cave
22:48:26 <dancor> also lolling/rofling
22:48:32 <kmc> smoking damn dope
23:40:01 <lispy> woot!  I finally rendered something using my freetype binding
23:40:34 <lispy> I spent the longest time fighting with a Ptr (Ptr Foo).  I mistook it for a Ptr Foo, and C didn't care.
23:42:16 <lispy> It's nice to finally have it working
23:47:42 <ben12> Is there any way to create a cabal package that builds a library and >1 executable that depends on that library, without having it recompile all the modules in the library each time?
23:48:21 <freedrull> does anyone know any good papers about dependant typing and agda
23:48:28 <aavogt> ben12: yes, with more recent versions of cabal it is possible
23:48:38 <copumpkin> freedrull: how's a book?
23:48:44 <copumpkin> @where TTFP
23:48:44 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
23:48:53 <lispy> http://hpaste.org/45239/aoeu
23:49:02 <lispy> That's what the example program I made outptus
23:49:06 <ben12> aavogt: Is there any example/documentation available for how to make that happen?
23:49:07 <lispy> You have to scroll around a bit to find the text
23:49:34 <lispy> ben12: yes, it's not obivous though
23:49:43 <freedrull> copumpkin: looks great, thanks
23:49:44 <copumpkin> lispy: you know what'd be cool, although I'm not sure if it's possible
23:49:45 <lispy> ben12: you need to require cabal >= 1.8
23:50:04 <lispy> ben12: then you mention the library as a dependency of the executables
23:50:09 <aavogt> ben12: this probably works http://code.haskell.org/~aavogt/XMonadConfigUpdater/XMonadConfigUpdater.cabal
23:50:13 <lispy> ben12: I don't think  you have to give the version #
23:50:35 <copumpkin> lispy: have you seen kmc's hdis86? it includes a full copy of the associated c library in the package, and compiles it itself without using a custom build. That makes it trivial to install for most people and means that it gets actual docs built on hackage
23:50:47 <copumpkin> then he has a flag to optionally link to a  system lib if you prefer that
23:51:13 <copumpkin> it'd be nice if I didn't have to screw with --extra-lib-dirs to build your freetype binding, is what I'm saying :D
23:51:41 <lispy> copumpkin: https://github.com/dagit/freetype2/blob/master/freetype2.cabal
23:51:51 <copumpkin> wonderful!
23:52:15 <lispy> copumpkin: I haven't add a flag to use the system libraries yet, but if you wanted to send me a patch, I would take it
23:52:23 <copumpkin> I don't even care much about that, really
23:52:26 <copumpkin> but I'm sure some people would
23:52:47 <copumpkin> do you expose just font-parsing aspects of the library as well as the rendering stuff?
23:53:19 <lispy> copumpkin: at the moment, I expose just enough to implement this program in haskell: http://freetype.sourceforge.net/freetype2/docs/tutorial/example1.c
23:53:30 <lispy> copumpkin: But, full library completeness seems like a good goal to me
23:53:31 <copumpkin> ah okay :)
23:54:24 <lispy> copumpkin: I'm still playing with the binding (trying to find a nice way to do the "raw" version at the moment).  So I haven't cleaned this up yet, but here is the haskell version of that C program: https://github.com/dagit/freetype2/blob/master/Main.hs
23:54:49 <copumpkin> cool :)
23:55:00 <copumpkin> I like the idea of having progressively more idiomatic interfaces on top of it
23:55:07 <copumpkin> did you see kmc's slides about udis86?
23:55:09 <lispy> My thoughts are: a) make a clean Raw version, b) make nicer version, possible with some reader monads to hide the OO aspects
23:55:12 <copumpkin> he gave the talk last night, and it was pretty good
23:55:16 * hackagebot JSON-Combinator 0.2.8 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.8 (TonyMorris)
23:55:18 <copumpkin> yeah!
23:56:35 <kmc> yeah, it's all about the layers :)
23:56:41 <kmc> gotta have layers
23:56:41 <lispy> I need to do some other stuff too.  I need to rebase this work onto the stable release state.  I didn't know an easy way to find that so I just started hacking
23:56:51 <copumpkin> kmc: have you achieved inception?
23:57:06 <lispy> copumpkin: to answer your question, I didn't see it.  Do you have a link?
23:57:46 * copumpkin digs and fail
23:57:49 <copumpkin> I'm sure kmc does :P
23:58:03 <lispy> The fun thing is, I can now continue my NeHe tutorial conversions as I finally have a cross platform font library.
23:58:18 <lispy> I needed this binding back in 2005!
23:58:38 <bsod2> hi
23:58:44 <lispy> hello, bsod2
23:58:59 <djahandarie> http://www.ugcs.caltech.edu/~keegan/talks/high-level-ffi/talk.html are the slides
23:59:01 <bsod2> i'm considering learning Haskell, i read very good things about it
23:59:04 <djahandarie> @ lispy 
23:59:20 <bsod2> however when i look at the syntax it looks really outlandish to me
23:59:39 <lispy> djahandarie: thanks!
23:59:48 <ben12> aavogt I'm looking at your example and it looks like exactly what I needed... but when I try it, cabal claims there was a dependency cycle through my library.  Did you have to do anything other than just >=1.8, and referring to the project in the executables/
23:59:50 <lispy> bsod2: what other languages do you know?
