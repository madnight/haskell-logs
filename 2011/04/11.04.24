00:00:06 <jmcarthur> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in drop 1000 fibs
00:00:07 <lambdabot>   [43466557686937456435688527675040625802564660517371780402481729089536555417...
00:00:11 <kmc> :O
00:00:15 <jmcarthur> happy kmc? :P
00:00:26 <kmc> happiness is a warm fib
00:00:41 <Nereid> is fibs!!1000 warm?
00:00:53 <jmcarthur> fairly
00:01:03 <jmcarthur> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 10000
00:01:04 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
00:01:06 <jmcarthur> warmer
00:01:13 <Nereid> ooo
00:01:30 <jmcarthur> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in length . show $ fibs !! 10000
00:01:32 <lambdabot>   2090
00:02:11 <sheikra> Is there a way to automatically align  "->" or "=" for a group of case expressions or definitions?
00:02:20 <jmcarthur> that sounds editor specific
00:02:30 <Nereid> > log (((sqrt 5 + 1) / 2) ^ 10000) / log 10
00:02:32 <lambdabot>   Infinity
00:02:34 <_Ray_> What is the backtick syntax doing here? http://hpaste.org/46002/mutual_recursion_in_constructo 
00:02:35 <Nereid> oops
00:02:41 <Nereid> > log (((sqrt 5 + 1) / 2)) * 10000 / log 10
00:02:43 <lambdabot>   2089.876402499787
00:02:47 <kmc> for every integer d > 1, there are either 4 or 5 fibonacci numbers with d decimal digits
00:02:50 <kmc> sez wikipedia
00:02:52 <sheikra> jmcarthur: suppose emacs's default haskell mode?
00:02:56 <Nereid> _Ray_: a `f` b = f a b
00:03:08 <jmcarthur> > log (((sqrt 5 + 1) / 2)) * 10000 / log 10 :: CReal
00:03:09 <_Ray_> oh, that's right, infix operator
00:03:09 <lambdabot>   2089.8764024997873376927208923755541682245924
00:03:09 <Nereid> so (`f` b) a = a `f` b = f a b
00:03:20 <Nereid> (`f` b) = flip f b
00:03:36 <fosskers> speaking of haskell in emacs...
00:03:41 <physicist> kmc: that's quite easy to see
00:03:43 <jmcarthur> sheikra: well, you could always select the region and then use align-regex
00:03:47 <fosskers> ive been looking around for some support, but to no avail
00:04:07 <ddarius> > logBase 2 10
00:04:08 <lambdabot>   3.3219280948873626
00:04:27 <Nereid> oh, logBase exists
00:05:07 <Nereid> > log 2.718
00:05:08 <lambdabot>   0.999896315728952
00:05:10 <Nereid> ah, good
00:05:20 <sheikra> jmcarthur: hmm... that works to some extent..
00:05:25 <ddarius> @let lg = logBase 2
00:05:26 <lambdabot>  Defined.
00:05:30 <jmcarthur> > log (exp 1) :: CReal
00:05:31 <lambdabot>   1.0
00:05:50 <sheikra> jmcarthur: but it doesn't move multi-line expressions where the second line hasn't "->" or "="
00:05:53 <Nereid> CReal is constructible reals?
00:06:02 <jmcarthur> yes
00:06:18 <kmc> > map floor $ iterate ((^2) . log) 2
00:06:19 <jmcarthur> sheikra: yeah, i don't know of a nicer way off the top of my head
00:06:19 <lambdabot>   [2,0,0,0,0,0,21,9,5,2,0,0,27,10,5,3,1,0,9,5,2,1,0,38,13,6,3,1,0,1,0,1,0,12,...
00:06:25 <sheikra> jmcarthur: after that the indentation will be wrong ;-)
00:06:29 <kmc> @oeis 2,0,0,0,0,0,21,9,5,2
00:06:30 <lambdabot>  Sequence not found.
00:06:36 <Nereid> lol
00:06:37 <jmcarthur> sheikra: not hard to clean up :P
00:07:08 <_Ray_> Hrm. Well, say I were in http://hpaste.org/46002/mutual_recursion_in_constructo . How could I make an author X, create a book for him? What expression would returns an author with a book written by exactly him?
00:07:18 <sheikra> jmcarthur: but it takes tens of seconds ...
00:07:23 <ddarius> So the fact that fib(n) + fib(n-1) < 2fib(n) already says that you will have at least 3 numbers with the same number of decimal digits.
00:07:35 <jmcarthur> so write some elisp :P
00:08:04 <sheikra> jmcarthur: I guess I have to write a parser for haskell in elisp first. that would be nightmare :P
00:08:40 <Nereid> _Ray_: createAuthor "author" ["title"] perhaps?
00:08:42 <jmcarthur> or you could use an existing haskell parser to write it in haskell then call out to the program with elisp
00:09:08 <kmc> or write an elisp backend for GHC
00:09:12 <fosskers> alright, so my script works, but is spitting out the wrong answer
00:09:18 <sheikra> lol :)
00:09:25 <Nereid> fosskers: hpaste
00:09:34 <jmcarthur> fosskers: you have a strange definition of "works"
00:09:39 <fosskers> lol i know
00:09:44 <_Ray_> Nereid: this is absolutely nuts. D:
00:09:45 <fosskers> okay okay, 'it compiles'
00:09:51 <fosskers> Nereid: what is hpaste?
00:09:57 <jmcarthur> hpaste.org
00:09:58 <Nereid> http://hpaste.org
00:10:00 <ion> /topic
00:10:06 <jmcarthur> you go there to paste stuff :D
00:10:09 <kmc> that definition is used by the majority of the software industry
00:10:19 <jmcarthur> kmc: :(
00:10:23 * jmcarthur goes to bed
00:10:53 <fosskers> http://hpaste.org/46003/project_euler_2
00:11:23 <luite> sum . filter even . getFibs $ n
00:11:49 <fosskers> turns out i was putting in the wrong input value.... >.>
00:11:58 <_Ray_> Nereid: That's sort of strange, createBooks is only being passed [a], which is a list of String... how can it possibly know about the full 'Author' object?
00:12:00 <fosskers> okay, the answer is right
00:12:16 <Nereid> _Ray_: you're not thinking lazily enough
00:12:25 <ion> The fibonacci series doesn’t start with 1 2.
00:12:29 * _Ray_ needs moar portals.
00:12:35 <fosskers> i know, but it does in the project euler question
00:12:39 <kmc> i... you beat me to it, _Ray_
00:12:56 <Nereid> lol
00:13:17 <luite> fosskers: that one is too slow, right?
00:13:28 <fosskers> no, it runs pretty quickly
00:13:34 <fosskers> even though its the shittiest way to find the fibs
00:13:57 <Nereid> you're lucky you only have to find a few of the fibonacci numbers
00:14:00 <fosskers> ran in about 15 secs
00:14:05 <luite> oh that's quite surprising :)
00:14:06 <Nereid> wow, that's slow ;(
00:14:11 <Nereid> don't you think?
00:14:15 <fosskers> yes
00:14:18 <Nereid> there's no memoization
00:14:22 <fosskers> i know
00:14:33 <sheikra> another question ... since haskell is pure. how do we usually check the equality of objects? Do we just append a unique number to each of them?
00:14:34 <fosskers> but i wouldnt even know where to start with that in haskell
00:14:34 <_Ray_> oh god
00:14:40 <_Ray_> createBook is CREATING a new author
00:14:42 <fosskers> if this were any other language id use a cache, but....
00:14:46 <Nereid> sheikra: the Eq typeclass
00:15:05 <_Ray_> it doesn't care about the author that createAuthor is building, it'll build its own, when it calls createAuthor by itself D:
00:15:15 <kmc> sheikra, there's no idea of "pointer equality", only "value equality"
00:15:18 <Nereid> _Ray_: yes, and by the magic of sharing, they're in fact the same author
00:15:39 <Nereid> _Ray_: it's like
00:15:48 <Nereid> > let a = 1:b; b = 2:a in a
00:15:50 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
00:15:50 <luite> fosskers: the standard way is the recursive definition of the fibs list in terms of itself
00:15:57 <kmc> in other words you should not care whether two things are "the same object" in memory, only whether they represent the same value
00:16:00 <_Ray_> who needs lsd when you have mutually recursive constructors :/
00:16:04 <Nereid> lol
00:16:15 <sheikra> Nereid: I mean .. I want something like "pointer equality" for example for testing the equality of type variables. Do I have to insert into each of them a unique number?
00:16:15 <kmc> me.  i do.
00:16:53 <Nereid> sheikra: how do you test type variables for anything?
00:17:01 <Nereid> sheikra: what are you trying to do?
00:17:02 <kmc> it's common that any system generating new variable names (e.g. a compiler) will pick unique numbers for them
00:17:18 <sheikra> Nereid: I'm trying to write a type checker
00:17:27 <_Ray_> kmc: http://wastedatwork.com/beer/funny-tshirt.jpg
00:17:32 <Nereid> sheikra: so you have a type for types?
00:17:46 <Nereid> sheikra: instance the Eq typeclass for them, then
00:17:52 <Nereid> (you might even be able to derive it)
00:18:01 <kmc> it should be irrelevant to your type checker whether two variables are "the same object" in the type checker's memory, or different objects representing the same type variable
00:18:10 <fosskers> Nereid: how would i go about any sort of memoization here?
00:18:19 <Nereid> fosskers: you construct the whole list at once
00:18:24 <sheikra> Nereid: then i have to put a number in there and have to use monads to generate those unique numbers?
00:18:28 <kmc> haha _Ray_, perfect
00:18:37 <Nereid> fosskers: which is exactly what 'let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs' does
00:18:46 <fosskers> and to me that was magic
00:18:50 <kmc> you don't have to use monads sheikra
00:18:53 <Nereid> fosskers: let's demagicify it
00:18:55 <kmc> you can just pass around a counter
00:19:01 <Nereid> fosskers: think about what equations you want to hold for fibs
00:19:12 <sheikra> kmc: but two variables with the same name "a" could be different variables
00:19:23 <kmc> right but why did you jump to using monads
00:19:35 <fosskers> Nereid: i not sure i know what you mean by that
00:19:39 <kmc> the State monad is just syntactic sugar for passing some arguments to some functions
00:19:50 <sheikra> kmc: yep ...
00:19:54 <Nereid> fosskers: I mean (fibs !! n) + (fibs !! (n+1)) == (fibs !! (n+2))
00:19:57 <Nereid> you always want that
00:20:00 <Nereid> right?
00:20:07 <fosskers> right right
00:20:12 <Nereid> so,
00:20:16 <kmc> sheikra, so you don't have to use the sugar if you don't want to
00:20:20 <Nereid> well, that better hold for all n
00:20:25 <Nereid> so let's collect them together in a list, with zipWith
00:20:27 <fosskers> it sure better
00:20:33 <fosskers> red light! 
00:20:39 <fosskers> gimme a sec to luook up zipWith
00:20:40 <Nereid> note: fibs !! (n+1) is the same as (tail fibs) !! n
00:20:45 <kmc> sheikra, another alternative is to pass around an infinite list of fresh variable names
00:21:08 <sheikra> kmc: but in any case I have to pass that thing all around ..
00:21:09 <tolkad> @pl do { a <- [1..10]; b <- [10..1]; return (a,b) }
00:21:09 <lambdabot> (line 1, column 4):
00:21:09 <lambdabot> unexpected "{"
00:21:09 <lambdabot> expecting variable, "(", operator or end of input
00:21:12 <kmc> yeah
00:21:20 <fosskers> Nereid: okay yeah, i get how tail would do that
00:21:31 <tolkad> @pl \a b c -> b c a
00:21:32 <lambdabot> flip flip
00:21:37 <Nereid> fosskers: so, you want (fibs !! n) + (tail fibs !! n) == (drop 2 fibs !! n)
00:21:44 <Nereid> let's collect those together
00:21:45 <tolkad> @pl id (do { a <- [1..10]; b <- [10..1]; return (a,b) })
00:21:45 <lambdabot> (line 1, column 8):
00:21:45 <lambdabot> unexpected "{"
00:21:45 <lambdabot> expecting variable, "(", operator or ")"
00:21:52 <Nereid> zipWith (+) fibs (tail fibs) == (drop 2 fibs)
00:22:03 <Nereid> now, let's see if we can make that into a workable definition of fibs
00:22:14 <Nereid> of course you know we have to specify the first 2 elements of fibs
00:22:25 <sheikra> kmc: may be state monad can save the clutter?
00:22:27 <Nereid> so, fibs = something : something : zipWith (+) fibs (tail fibs)
00:22:31 <Nereid> well, 
00:22:36 <Nereid> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
00:23:06 <Nereid> it's clear that it satisfies the equation above
00:23:29 <Nereid> (expanding (drop 2 fibs) gives you exactly that equation)
00:23:55 <fosskers> holy crap
00:23:59 <fosskers> that's very clear
00:24:10 <fosskers> and i looked up zipWith so now that isn't a mystery either
00:24:12 <Nereid> :)
00:24:23 <Nereid> to be honest, I've never thought of it this way before myself
00:24:34 <Nereid> so I learned something too :O
00:24:40 <danharaj> finally have real time 3 body problem :[
00:24:48 <fosskers> so without using let
00:24:51 <_Ray_> shit, I should be studying for a numerical methods midterm, and this stuff is just too much fun to stop. 5am and I'm going to use mutual recursion :D
00:24:53 <danharaj> I had to throw around a lot of seqs. repa apparently has problems with laziness
00:24:54 <Nereid> fosskers: it's not magical anymore, right? :D
00:24:58 <fosskers> and just making it a normal function definition
00:25:03 <Nereid> yeah
00:25:06 <Nereid> so you can literally have
00:25:07 <Nereid> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
00:25:12 <fosskers> oh
00:25:14 <Nereid> as a top-level declaration in your program
00:25:15 <KirinDave> Okay.
00:25:18 <KirinDave> Haskell is sorcery.
00:25:18 <KirinDave> http://hpaste.org/46004/mutual_recursion_in_constructo
00:25:21 <KirinDave> How the hell does that even work?
00:25:22 <fosskers> holy crap
00:25:26 <_Ray_> KirinDave: Hi :)
00:25:33 <Nereid> KirinDave: do you understand how (let a = 1:b; b = 2:a in a) works?
00:25:34 <KirinDave> _Ray_: I didn't know either.
00:25:46 <Nereid> > let a = 1:b; b = 2:a in a
00:25:46 <KirinDave> Nereid: Yes
00:25:47 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
00:25:51 <Nereid> KirinDave: it's exactly the same
00:25:52 <KirinDave> Nereid: But that's lazy evaluation.
00:25:58 <_Ray_> As is this
00:25:59 <KirinDave> So types are lazily evaluated?
00:26:04 <KirinDave> That's funny.
00:26:06 <_Ray_> createBooks calls createAuthor calls createBooks ...
00:26:06 <Nereid> what types?
00:26:17 <kmc> where did types come into this
00:26:17 <_Ray_> These aren't type constructors, they're just functions :)
00:26:26 <_Ray_> If they were types, they'd be infinite types, and thus... well, nonsensical
00:26:29 <Nereid> _Ray_: yes, exactly how a calls b calls a calls ... in my example
00:26:35 <Nereid> yeah, infinite types are no :D
00:26:44 <kmc> types aren't evaluated at all, and they don't exist at runtime
00:26:51 <KirinDave> Okay I was misreading.
00:27:35 <_Ray_> It's so much fun it should be illega. Or make you fat. Or something.
00:27:39 <_Ray_> *illegal.
00:27:44 <fosskers> Nereid: k now i just have to meditate on this
00:27:56 <KirinDave> _Ray_: So what made you choose haskell for these little projects?
00:28:54 <fosskers> so this is an infinite list, yeah? -> fibs = 1 : 2 : zipWith (+) fibs (tail fibs)
00:29:13 <tolkad> > let a = (1 + sqrt 5)/2, b = \n -> (((a ^ n) - ((1 - a) ^ n))) / (sqrt 5) in map b [0..]
00:29:14 <lambdabot>   <no location info>: parse error on input `,'
00:29:15 <_Ray_> Dabbled in it two years ago, in my first algorithms course. We weren't allowed to use first order functions or complicated type constructors, so that was boring. Later on I read Typeclassopedia and (with help from #haskell) understood Functors, Pointed and Monads. And now I'm going to study a bit of category theory in uni, so I thought I'd go back and look at the full power of Haskell.
00:29:20 <tolkad> > let a = (1 + sqrt 5)/2; b = \n -> (((a ^ n) - ((1 - a) ^ n))) / (sqrt 5) in map b [0..]
00:29:21 <lambdabot>   [0.0,1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,54.99999999999999,89.0,143.9999...
00:29:32 <tolkad> > let a = (1 + sqrt 5)/2; b = \n -> (((a ^ n) - ((1 - a) ^ n))) / (sqrt 5) in map (round . b) [0..]
00:29:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:29:41 <tolkad> there we go, fibonacci sequence
00:29:55 <KirinDave> More sorcery. :)
00:30:07 <fosskers> thats the closed form, yeah?
00:30:12 <tolkad> yeah
00:30:12 <_Ray_> (Nereid, for instance, has been giving me much info on groups and rings back at #math.)
00:30:37 <_Ray_> I should really pay the guy or something. :s
00:30:39 <ddarius> If you are working with reals rather than floats.
00:30:49 <ion> > let fib :: Integer -> CReal; fib n = (phi^^n - (1-phi)^^n) / sqrt 5 where phi = (1 + sqrt 5) / 2 in fib 100
00:30:50 <lambdabot>   354224848179261915075.0
00:30:56 <tolkad> ddarius: what you mean floats can't represent any real number?
00:31:10 <tolkad> ddarius: then why did they call them real numbers in my CS class huh?
00:31:10 <_Ray_> KirinDave: How about you?
00:31:20 <KirinDave> _Ray_: Natural progression of avarice.
00:31:27 <KirinDave> You know me, Scala is already boring.
00:31:42 <KirinDave> or rather, I feel like much more research into scala is pissing down a very deep well.
00:31:43 <_Ray_> How about Go? Or D?
00:31:45 <kmc> the devil's toboggan
00:31:45 <ion> Floats can represent some real numbers.
00:31:47 <fosskers> KirinDave: do you like giraffes? or possibly beer?
00:31:50 <ddarius> ion: Unless you are going to allow for negative n, there's no need for (^^).
00:32:06 <KirinDave> fosskers: Giraffes is a pretty epic mistranslation.
00:32:15 <KirinDave> _Ray_: Go doesn't excite me very much.
00:32:21 <KirinDave> As for D, been there done that.
00:32:40 <fosskers> KirinDave: what do you mean?
00:33:20 <KirinDave> fosskers: Sorry, people say, "Kirins huh? Aren't those like ______" where ______'s outrageousness is linearly related to the number of times I've heard that phrase.
00:34:06 <tcard> KirinDave: you ever get asked about this one? http://ja.wikipedia.org/wiki/%E9%BA%92%E9%BA%9F
00:34:20 <_Ray_> Similarly, I only understood "Monads are like a burrito", once I understood how Monads /aren't/ like a burrito.
00:34:27 <KirinDave> Ha.
00:34:31 <KirinDave> This Is Not A Burrito.
00:34:47 <ion> @quote monad
00:34:47 <lambdabot> quicksilver says: It's replaced by the farm comonad, EIEIO.
00:34:51 <fosskers> KirinDave: that makes less sense, but dont worry about it
00:35:18 <tcard> (ah, there is actually an English page: http://en.wikipedia.org/wiki/Qilin)
00:36:31 <fosskers> i was just asking originally because kirin is the common word for giraffe in japanese
00:36:51 <KirinDave> It's one of those names you pick up as a child and they stick.
00:37:04 <danharaj> I am curious as to the etymology of kirin.
00:37:05 <Nereid> argh, my ipv6 tunnel broke
00:37:22 <danharaj> I would expect it to be a loan word, but from which language is the question.
00:37:31 <Nereid> Japanese
00:37:33 <fosskers> chinese
00:37:33 <tcard> danharaj: from Chinese; see above link
00:37:41 <KirinDave> Yeah
00:37:43 <danharaj> 4:00 AM strikes again
00:37:50 <danharaj> zzz
00:37:53 <tcard> Nereid: people use katakana when rendering in Japanese, indicating that it is a loan-word
00:37:53 <fosskers> buahah its 5pm here
00:37:56 <Nereid> qilin is from chinese, kirin is from japanese
00:38:08 <danharaj> I don't think it's always a loan word.
00:38:11 <danharaj> Sometimes a neologism?
00:38:18 <fosskers> tcard: not quite. japanese words with extremely hard kanji are often rendered to katakana
00:38:26 <Nereid> sometimes katakana is used for whatever people feel like
00:38:56 <Nereid> also for some things like names of living things
00:39:10 <fosskers> like?
00:39:13 <Nereid> (which, I guess, often have extremely hard kanji so see the above)
00:39:21 <KirinDave> Anyone going to CUFP had better brush up.
00:39:31 <Nereid> like animals
00:40:14 <danharaj> My favorite japanese word is okushon, because it's a pun, and puns are as dismal as I am.
00:40:54 <KirinDave> Anyways, _Ray_, if you do blow through the assignment in 24 hours, hold off on posting it.
00:40:55 <fosskers> my favourite words are verbs that end in く
00:41:14 <_Ray_> I won't, numerical methods midterm on monday, so tomorrow will be dedicated to studying :)
00:41:18 <KirinDave> :)
00:41:23 <danharaj> fosskers: why?
00:41:31 <fosskers> danharaj: they sound badass
00:41:33 <danharaj> also I'm surprised I can still recognize hiragana from high school.
00:41:33 <KirinDave> I'm going to subtly suggest we let some of the non-regulars post first.
00:41:44 <KirinDave> It's a trivial thing to give them, but it'll make them feel badass.
00:41:45 <Nereid> fosskers: there are a lot of them
00:41:51 <_Ray_> I agree.
00:41:56 <fosskers> Nereid: oh i know
00:43:03 <fosskers> So the reason this doesn't collapse the universe: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
00:43:08 <fosskers> is due to lazy evaluation?
00:43:11 <Nereid> yes
00:43:27 <Nereid> it's the same reason "ones = 1:ones" doesn't
00:43:28 <fosskers> ive been staring at it for like 10 minutes going "whooooooaaa"
00:43:34 <Nereid> just a bit more complicated :P
00:43:50 <KirinDave> What blew my mind earlier, was reading RWH
00:43:56 <KirinDave> And seeing the chapter on optimization.
00:44:11 <danharaj> no one happens to have a GLSL shader for converting from HSL/HSV to RGB lying around do they?
00:44:15 <fosskers> im going through 'programming in haskell' now
00:44:16 <KirinDave> The idea of the compiler being smart enough to elide an unnecessary data structure entirely? Eff. 
00:44:23 <fosskers> have learn you a haskell on my computer
00:44:44 <kniu> I got this weird error message:
00:44:45 <kniu> <command line>: cannot satisfy -package-id filepath-1.2.0.0-00d22c51b3ddcad729fe344d4a06ba84: 
00:44:45 <kniu>     filepath-1.2.0.0-00d22c51b3ddcad729fe344d4a06ba84 is shadowed by package filepath-1.2.0.0-b273467b63dd15270d77af61bc610112
00:44:46 <Nereid> RWH is worth reading
00:44:55 <kniu> what does it mean?
00:45:36 <ville> Nereid: I liked it thus far, I also liked write your self a scheme thus far. That is to say I haven't finished either.
00:45:43 <fosskers> okay, i understand
00:45:53 <fosskers> saying fibs = 0 : 1 : zipWith (+) fibs (tail fibs) isn't actually executing anything
00:45:57 <fosskers> its just an agreement
00:46:06 <fosskers> like FIBS IS THIS
00:46:15 <Nereid> ville: this one's new to me
00:46:28 <fosskers> and until you poke it nothing happens (collapsing universe or otherwise)
00:46:36 <tolkad> > 1 ^ 9000 :: CReal 
00:46:37 <lambdabot>   1.0
00:46:38 <Nereid> fosskers: something like that, perhaps
00:46:42 <tolkad> > 2 ^ 9000 :: CReal 
00:46:45 <lambdabot>   186191982360244687005164694744326580621868088162016415016130975533318139234...
00:47:29 <Nereid> fosskers: let's see how we might start evaluating fibs, with that
00:47:54 <fosskers> well i solve the problem already
00:47:58 <Nereid> yeah
00:48:03 <Nereid> but it's a fun exercise
00:48:18 <Nereid> so say we know so far that fibs = 0 : 1 : something
00:48:22 <Nereid> where something is unknown
00:48:27 <tolkad> > fibs
00:48:28 <lambdabot>   Not in scope: `fibs'
00:48:31 <Nereid> well, plug that back into the definition
00:48:45 <Nereid> fibs = 0 : 1 : zipWith (+) [0,1,...] [1,...]
00:48:56 <Nereid> = 0:1:[0+1,...]
00:49:05 <Nereid> = [0,1,1,...]
00:49:07 <Nereid> and so on
00:49:19 <Nereid> you plug that back into the definition
00:49:24 <Nereid> and you get the next one, [0,1,1,2,...
00:49:58 <Nereid> where by ... I actually mean bottom
00:50:11 <Nereid> ok I didn't do that very well
00:50:19 <fosskers> lol dont worry, i understand
00:50:26 <Nereid> but the idea is like
00:50:28 <Nereid> fibs_0 = undefined
00:50:36 <Nereid> fibs_1 = 0 : 1 : zipWith (+) fibs_0 (tail fibs_0)
00:50:40 <Nereid> fibs_2 = 0 : 1 : zipWith (+) fibs_1 (tail fibs_1)
00:50:42 <Nereid> and so on
00:50:52 <fosskers> mm yeah
00:51:00 <Nereid> and the sequence fibs_n actually converges to something useful
00:51:18 <Nereid> (so here fibs_1 = 0:1:undefined, fibs_2 = 0:1:1:undefined, fibs_3 = 0:1:1:2:undefined, etc)
00:51:37 <Nereid> I guess it's worth writing it as some fixed-point recursion too
00:52:27 <Nereid> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
00:52:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:52:34 <Nereid> @src fix
00:52:34 <lambdabot> fix f = let x = f x in x
00:52:57 <_Ray_> My god. I should not be allowed to do this.     let r' = Add (Add r (Exit "north" r')) (Exit "south" r') in
00:53:09 <kmc> > fix ((0:) . scanl (+) 1)
00:53:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
00:53:18 <Nereid> yes yes
00:53:27 <tolkad> fosskers: ultimately your compiler/interpreter is going to have to turn the expression into code and execute it. You are saying "FIBS IS THIS" but relative to a particular compiler/interpreter you are implicitly writing imperitive code to calculate fibs
00:53:46 <fosskers> right
00:54:04 <Nereid> but the magic of haskell is that you don't have to care
00:54:14 <fosskers> im beginning to see that
00:54:29 <kmc> (until you care about performance...)
00:54:35 <Nereid> (as long as you're only striving for correctness, and not necessairly performance)
00:54:36 <Nereid> yeah
00:55:13 <fosskers> isnt haskell #2 in terms of speed?
00:55:38 <Nereid> it depends on the benchmark
00:55:47 <kmc> languages don't have speeds
00:55:56 <Nereid> and that
00:55:58 <kmc> implementations of languages + individual benchmark programs have speeds
00:56:26 <kmc> Haskell is a good language for writing elegant, idiomatic code which is also *pretty* fast, and then tuning the parts that matter to make them *really* fast
00:56:44 <kmc> don't expect the super simple beautiful Haskell code to be as fast as a C program you spent all day writing
00:57:07 <fosskers> right, okay
00:57:19 <Nereid> I, unfortunately, know nothing about getting speed out of haskell :(
00:57:27 <fosskers> math? lol
00:57:48 <Nereid> my interest doesn't lie there :P
00:57:51 <kmc> it's also worth noting that most popular high-level languages are used via terrible interpreters
00:58:03 <tolkad> kmc: emphasis on terrible
00:58:10 <kmc> and yet people write tons of useful code, solve real problems, and make loads of cash using them
00:58:41 <Nereid> I can't imagine how one would even begin to write a python compiler that produced fast code
00:58:57 <kmc> by compiling as the program runs
00:58:59 <kmc> i.e. tracing JIT
00:59:08 <Nereid> ah, those things
00:59:22 <kmc> tracing JIT can make sense even for heavily static languages
00:59:40 <kmc> edwardk wrote a tracing JIT that compiles x86-64 machine code to x86-64 machine code
00:59:43 <Nereid> such a thing is used in those fancy new javascript engines, no?
00:59:48 <kmc> yes
00:59:49 <Nereid> lol
00:59:57 <tolkad> also lua and Java
01:00:11 <Nereid> kmc: and how does it fare?
01:00:16 <Nereid> the x86-64 thing
01:00:17 <kmc> the idea is that you're doing all kinds of constant propagation, inlining, loop fusion, etc. at runtime
01:00:23 <kmc> using information the compiler doesn't have statically
01:00:31 <kmc> in fact you're folding things that are "almost constant", etc.
01:00:45 <Necrosporus> What is better, Haskell or J?
01:00:53 <tolkad> kmc: and the fact that some of these languages heavily rely on hash tables that can be optimized away at runtime
01:00:56 <Nereid> Necrosporus: you come to a #haskell channel and ask that? :P
01:00:56 <kmc> what is better, coffee or tea
01:01:07 <_Ray_> Hrm. I want to give a room a set of adjacent rooms, and those rooms to have a "link" back to the original one. I.e. r->south->north == r. Is this in the right direction? http://hpaste.org/46005/constructor_recursion (I don't want it spoiled, just to know if I'm even in the right track ;))
01:01:10 <Nereid> kmc: where this question is asked in #coffee
01:01:21 <kmc> Nereid, it works pretty well from what he told me, but i don't recall specific benchmarks
01:01:21 <Necrosporus> kmc, if tea is green, tee, otherwise coffee
01:01:39 <tolkad> kmc: have I said anytrhing incorrect?
01:01:42 <Nereid> kmc: it ran some things faster than the original code, though?
01:01:47 <kmc> yes
01:01:57 <Nereid> see
01:02:02 <Nereid> this is the kind of stuff that blows my mind
01:02:10 <kmc> a simple example is, you call printf from your inner loop
01:02:16 <kmc> it's dumb that printf has to re-parse your format string every time
01:02:34 <Necrosporus> Does Haskell has any advantages compared to J? What is disadvantages?
01:02:48 <Twey> Advantages: it's not J
01:02:52 <Twey> Disadvantages: it's not J
01:03:17 <Nereid> isn't J completely different?
01:03:20 <_Ray_> Is this on the right track to having room->north->south == room? http://hpaste.org/46005/constructor_recursion
01:03:21 <Twey> Utterly.
01:03:26 <kmc> Nereid, that never stops people asking which one is better
01:03:27 <Necrosporus> Both seem functional
01:03:32 <kmc> at least coffee and tea are both beverages
01:03:34 <Twey> J is not really functional
01:03:45 <Nereid> oh, if you wanted to, you could claim a lot of things are functional
01:03:47 <Nereid> like C
01:03:52 <Twey> Well, yeah, sure
01:03:57 <kmc> anyway you can record a trace through printf
01:03:58 <Twey> J is not functional by Haskell standards.  ☺
01:04:10 <kmc> and effectively specialize the function to your particular format string
01:04:11 <Nereid> (I am reminded of http://conal.net/blog/posts/the-c-language-is-purely-functional/
01:04:16 <fosskers> what do you guys write your haskell in?
01:04:20 <kmc> without any intervention needed by the library or application programmer
01:04:21 <Twey> emacs
01:04:27 <Nereid> kmc: fun times
01:04:29 <Nereid> fosskers: vim 
01:04:36 <Twey> fosskers: emacs!
01:04:39 <Nereid> fosskers: vim !
01:04:44 * Twey grapples with Nereid.
01:04:47 <fosskers> Twey: do you have the plugin for it?
01:04:47 <Nereid> D:
01:04:49 <Twey> Ruargh!
01:04:54 <Nereid> D:
01:04:54 <fosskers> i do all my coding in emacs, btw, sorry Nereid 
01:04:57 <Twey> fosskers: The haskell-mode?  Yes
01:04:58 <kmc> yeah, i'm increasingly thinking along the lines of "static analysis for correctness, dynamic analysis for performance"
01:05:16 <fosskers> where does one get the haskell-mode?
01:05:19 <fosskers> it doesn't seem builtin
01:05:24 <Twey> fosskers: Google
01:05:25 <kmc> for example, because correctness is a worst-case property and performance is an average-case property
01:05:29 <Twey> Or it comes with ergoemacs, if you're into that
01:05:34 <fosskers> i did, but that lead to dead ends
01:05:45 <tolkad> Necrosporus: here's an advantage of haskell over J, you can search for its name
01:05:46 <Necrosporus> I do my code with rlwrap cat >/dev/null
01:05:48 <kmc> this also implies that you want static analysis for hard-realtime performance -- but hard-realtime means that performance is part of correctness, anyway
01:06:04 <Nereid> Necrosporus: seems productive :O
01:06:17 <fosskers> http://projects.haskell.org/haskellmode-emacs/
01:06:17 <Twey> fosskers: First sublink of the first link for a Google for "haskell-mode emacs" gives step-by-step instructions for installation
01:06:18 <fosskers> i see nothing
01:06:27 <Twey> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Development_Version
01:06:30 <tolkad> Necrosporus: I was trying to find irrational pages criticizing J but I'm having trouble with google returning irrelevant results
01:06:44 <Nereid> *google haskell-mode*
01:06:47 <Nereid> *see haskell wiki link on top*
01:06:54 <kmc> haskell google mode
01:07:00 <Twey> Haha
01:07:03 <fosskers> guys, please
01:07:04 <Necrosporus> tolkad, try j language 
01:07:12 <ddarius> J is crazy, but for mostly superficial reasons.
01:07:31 <Twey> fosskers: Follow the link — your answer lies within.
01:07:51 <Twey> ddarius: Define ‘superficial’
01:08:18 <_Ray_> Hrm. I think I see the problem. I'm trying to define r->north = r. When I make a ->north, I also add a ->south pointing back. But the original r has no such ->south, only r->north does. I think that's what happening, but I'm not sure.
01:08:26 <ddarius> Twey: Completely insane names for standard/built-in functions.  It is, however, no problem defining sane names for them.
01:08:45 <ddarius> The parsing is also a bit insane.
01:08:47 <_Ray_> so r->north->south == r, and r->north == r, but there's no r->south. if that makes sense :s
01:08:57 <Twey> Isn't the parsing pretty simple?
01:09:03 <Twey> Seemed okay when I played with it
01:09:35 <Nereid> _Ray_: but if r->north = r, then r->south = (r->north)->south = r
01:09:37 <Necrosporus> ddarius, so, if you call it insane, can you define '-: x' doing 'x/2' on haskell?
01:09:39 <ddarius> Twey: And by "insane," I don't mean "crazy symbols" but rather things like the putStr equivalent being stuff like 1 :! 3
01:09:49 <Twey> ddarius: Yeah, I hated the magic number
01:09:50 <Twey> s
01:09:55 <Necrosporus> ddarius, !: i suppose
01:09:58 <_Ray_> Nereid, but in here, the == is... fake, it's a recursive structure. :s I'm using http://hpaste.org/46005/constructor_recursion . Does that seem reasonable?
01:10:03 <Nereid> at least, that's what you want to accomplish
01:10:16 <Twey> ddarius: Oh, and function definition being an operation on strings
01:10:18 <frank00> woops I got disconnected, I will repeat my Q
01:10:20 <_Ray_> (and using it as let r' = addExits r [("north", r')], where r is a base room.)
01:10:22 <Nereid> _Ray_: please use an enumerated type for directions
01:10:25 <Nereid> :P
01:10:26 <frank00> emh, I've just installed haxml, and would like to use haddock on it but... on which file should I call haddock?
01:10:29 <Nereid> data Direction = ...
01:10:31 <_Ray_> alright :p I thought about doing that
01:10:34 <Necrosporus> I don't like this too, but maybe it's useful when you compute function you want to use
01:10:40 <Twey> _Ray_: I would suggest doing less in the type system
01:10:42 <ddarius> Twey: It's really simple until you realize that the parsing algorithm branches on "is a monad or dyad" and that property in a run-time property.
01:10:53 <Twey> ddarius: Yeah.  :-\
01:11:21 <fosskers> is there an easy way to download all the files in a folder on a site?
01:11:24 <Twey> _Ray_: If you define your Room: data Room = Room { description :: String, exits :: [Direction] }
01:11:29 <Twey> Your code will look much nicer
01:11:40 <_Ray_> but then how would I know which Room each Direction goes to?
01:11:43 <Twey> (or even Data.Set.Set Direction)
01:11:45 <ddarius> I forget what it says about parsing expressions and assignments in expressions, but it may even be the case that the parsing of a symbol can change within an expression.
01:11:47 <Twey> Oh, right
01:11:54 <Twey> Data.Set.Set (Direction, Room)
01:11:56 <Twey> Sorry
01:12:06 <Nereid> or just [(Direction, Room)] because who cares
01:12:15 <Twey> Nereid: Well, a set would make adding easier
01:12:22 <Twey> Because you don't have to worry about adding duplicates
01:12:23 <Nereid> for some definition of "easier"
01:12:31 <_Ray_> (the room also has a lot of other things xP). The full code is here: http://hpaste.org/paste/46005/constructor_recursion_annotat#p46006
01:13:16 <Twey> Haha, that has to be the best typename in the world
01:13:23 <Nereid> Stuff
01:13:26 <Twey> You know you're in for a fun time when you see ‘data Stuff = …’
01:13:26 <_Ray_> xD
01:13:42 <Nereid> oh my what
01:13:44 <frank00> (and bw, I am on winxp)
01:13:45 <Nereid> it's 2:30am already
01:13:49 <Nereid> I should go!
01:13:52 <_Ray_> haha
01:13:54 <Nereid> bye
01:13:56 <_Ray_> 5:33am here xP
01:13:58 <_Ray_> good night
01:13:58 <Twey> Nereid: 'bye
01:14:00 <Twey> I envy you
01:14:04 <Twey> 0933 here
01:14:11 <_Ray_> I'm basically trying to get a room to remember its exits
01:14:24 <_Ray_> I think what I wrote makes some sort of sense, but It Doesn't Work (tm)
01:14:40 <Nereid> ok,
01:14:42 <_Ray_> namely, asking for the exits of the room gives me only "north"
01:14:56 <Nereid> _Ray_: how would you construct it, without this addExits function?
01:14:58 <tolkad> If haskell allowed full first-order logic in types, would type unification still be semidecidable?
01:15:05 <Nereid> just using mutually recursive definitions of rooms?
01:15:54 <Nereid> I guess that's the easy part...
01:15:57 <Nereid> at least to me
01:16:04 * _Ray_ still has to think about it xP
01:16:27 <_Ray_> let r = Add (Exit r (Add (Exit r' "south")) "north")
01:16:46 <_Ray_> well
01:16:58 <Nereid> get rid of that second r, and change r' to r
01:16:59 <_Ray_> then going to the "south" exit wouldn't have a way of going back "north"
01:17:14 <Nereid> yeah
01:17:20 <Nereid> so the Add Room Stuff isn't quite it
01:17:35 <Nereid> maybe Room = Room BaseRoom [Stuff]?
01:17:45 <_Ray_> it can't be done with the current types?
01:17:45 <Nereid> except
01:17:47 <Nereid> that sitll doesn't quite do it
01:17:52 <Nereid> still*
01:18:11 <Nereid> I haven't thought about haskell in many months
01:18:35 <_Ray_> what I thought was that I could, instead of using r' there, call my function on r', adding myself at the north of it
01:18:55 <_Ray_> (where r' is the room to which I want r to exit)
01:19:23 <_Ray_> that's what addExits tries to o
01:19:25 <_Ray_> *do
01:20:32 <Twey> _Ray_: I may have been joking about the Stuff datatype, but you really should break it up
01:20:50 <Nereid> and I really should go
01:20:52 <Nereid> bye :)
01:20:52 <Twey> A datatype that contains everything is about as much use as a datatype that contains nothing
01:20:54 <_Ray_> go Nereid :)
01:20:59 <Twey> Sleep for my part too
01:21:06 <_Ray_> alright, thanks :)
01:21:09 <Twey> Or however you say that in real English >.>
01:25:24 <nschoe> Hi all.
01:26:01 <shachaf> preflex: seen all
01:26:01 <preflex>  all was last seen on #httpd 283 days, 9 hours, 57 minutes and 45 seconds ago, saying: el contrare
01:27:01 <fosskers> cya Nereid
01:27:59 * _Ray_ has no idea how to do this xD
01:28:00 <nschoe> I'd like to send a simple email from a haskell program, I've done some research but very few. And when I could find something that was dealing with email sending, there wasn't any example or anything: I just don't get it. So could you point out to me a simple way of sending a email with haskell please?
01:31:55 <fosskers> aha! it works!
01:31:59 <fosskers> haskell in my emacs!
01:34:08 <Lemmih> nschoe: What you're asking is easier said than done.
01:35:18 <nschoe> Lemmih, okay, that's what I thought. But sorry for my ignorance, can you explain to me why it is complicated to send an email? I mean with apps such as thunderbird or so it's all transparent to me, so I really can't tell what's happening when sending an email.
01:35:28 <hvr> are typeclasses resolved at compile time by GHC, or is there some runtime overhead involved?
01:35:43 <ddarius> hvr: Yes.
01:36:02 <hvr> ddarius: ....which of the two parts does the yes apply to? :)
01:36:31 <Lemmih> nschoe: Read about mail transfer agents.
01:37:18 <ddarius> hvr: Both.
01:37:23 <hvr> :-(
01:37:27 <Cale> nschoe: It's probably easiest to interact with a program which knows how to/is already configured to send email.
01:37:48 <nschoe> Okay, those are the "MTA" I keep reading on forums. Does it mean I'll have to use smth such as 'sendmail' from linux in order to send email from within a haskell program?
01:38:05 <hvr> ddarius: any pointer to documentation/papers where I could read up on it?
01:38:12 <nschoe> Cale: like sendmail or postfix from the cmd line?
01:38:22 <Cale> yeah
01:39:04 <nschoe> Cale: okay so I should first learn how to use sendmail or postfix with my cmd line and then try to use that in haskell.
01:39:18 <Cale> http://hackage.haskell.org/packages/archive/mime-mail/0.3.0/doc/html/Network-Mail-Mime.html
01:39:31 <Cale> this seems to contain an interface to running sendmail :)
01:40:19 <nschoe> Cale, yeah I have DLed this with cabal but I totally failed trying to make it work. It uses Text which uses Array IIRC. That's pretty heavy, isn't it?
01:40:26 <Cale> no
01:40:36 <Cale> Text is an efficient representation of unicode test
01:40:38 <Cale> text*
01:41:23 <nschoe> Okay, so sorry to ask that, but do you know where I can find examples using Text, because I failed to use it so far, and am a bit stuck with all this :/
01:41:27 <Cale> (more efficient than String)
01:42:08 <Cale> The pack function from Data.Text should be all you need for this
01:42:15 <Cale> pack :: String -> Text
01:42:47 <nschoe> Cale, damn I feel terrible. I'm going to experiment a little bit with it, thanks.
01:45:58 <Cale> Oh, also, the Text type supports the IsString class, so if you add {-# LANGUAGE OverloadedStrings #-} to the top of your source file, you can use the overloaded strings extension to make "foo" into an acceptable Text value
01:46:03 <Cale> (it becomes polymorphic)
01:46:21 <Cale> which will save you from using pack a bit
01:47:02 <Cale> at least, if you have some baked-in string constants
01:50:36 <vicvicvic> I'm trying to create a type for an identification system which always uses a Year and a Serial number, but sometimes also a Page number or an Appendix number. Wondering if the best approach is to have different type constructors, or to use Maybe...
01:50:46 <vicvicvic> i.e. which one is better: http://hpaste.org/46007/value_constructors_or_maybe
01:51:55 <fosskers> @source  map
01:51:55 <lambdabot> map not available
01:52:18 <vicvicvic> (well, with parens around the maybe)
01:52:39 <navaati> hello
01:52:45 <fosskers> hi
01:55:09 <luite> vicvicvic: if it's actually an optional field, I'd use Maybe (you need more parentheses by the way), but it looks like in this case, there is more to it than that
01:55:50 <navaati> i've got a problem with overlapping instances
01:55:57 <navaati> here is the code : http://hpaste.org/46009/ovelapping
01:56:09 <luite> vicvicvic: oh sorry you already mentioned the parentheses :)
01:56:36 <vicvicvic> luite: right, i tried it in ghci right after i pasted in hpaste :p 
01:56:56 <vicvicvic> should have done that first... but what's "more to it" here? (haskell beginner)
01:57:13 <Lemmih> navaati: Have you enabled overlapping instances?
01:57:21 <Twey> vicvicvic: Maybe — that way you can use Maybe functions on it.  Also with records, though.
01:57:57 <luite> vicvicvic: oh I meant just in your application. it's not just a single type of record with an optional field, the different constructors have different meanings
01:58:12 <navaati> ghc complains about overlapping between "(HWValue v) => Parameters v" and "(Parameters v, Parameters w) => Parameters (v,w)", but i know there won't be any real overlapping, as I know that "Parameters (v,w)" will never be an instance of HWValue. How can I say that to ghc ?
01:58:12 <navaati> yes, overlappingInstances is enabled
01:59:25 <luite> vicvicvic: in the second alternative, you'd have to check which of the optional fields is Just, to see what type of SFS value it is, right? and what if both are Just something?
01:59:27 <tarrasch> Hello, I have the exact problem described here. http://osdir.com/ml/glasgow-haskell-users@haskell.org/2011-02/msg00139.html. Apperently a solution is also present, but I still don't understand what I should do to fix this issue. I'm using Ubuntu 10.10, and I've succesfully installed ghc 7.0.3.
01:59:47 <Lemmih> navaati: How about adding this instead: instance (HWValue v, HWValue w) => HWValue (v,w) where ... ?
02:00:17 <vicvicvic> luite: right right, they aren't technically mutually exclusive though; i just omitted that in the first alternative for brevity (which, i guess is another reason to go with the second)
02:00:43 <vicvicvic> + record syntax is nice
02:00:56 <_Ray_> hrm. how could I make a 'data Direction = North | South | ...' such that I can say 'read str :: Direction' and it'll convert "North" into North?
02:01:10 <ddarius> Just derive Read.
02:01:14 <vicvicvic> Twey: thanks, seems like a good idea :)
02:01:21 <tarrasch> Yea, just derive read _Ray_ 
02:01:22 <vicvicvic> and thanks luite as well 
02:01:25 <_Ray_> damn.
02:01:32 <_Ray_> far too cool. thanks :)
02:04:03 <_Ray_> Is there a built-in function that changes a String to Titlecase?
02:04:08 <_Ray_> (I see there's one for Char)
02:04:18 <luite> vicvicvic: another alternative is data SFS = SFS Year Serial SFSOpt; data SFSOpt = OptPlain 
02:04:34 <ion> Did i just see someone complementing Haskell’s record syntax? :-) (I didn’t read the context.)
02:04:43 <luite> vicvicvic: oops, pressed enter too soon, | OptPage Int | etc, you get it :)
02:04:59 <navaati> Lemmih: it won't work because Parameters has not only the purpose of abstracting over one or a pair or a triple of HWValue, it also have the role of getting new addresses in the monadic context : HWValues instances are defined by library users, Parameters instances will be defined by me, so that users won't touch any internal code when defining HWValue
02:05:07 <vicvicvic> ion: heh..
02:05:32 <vicvicvic> luite: right right that works too :) thanks for the help
02:05:52 <navaati> the error message suggest I activate IncoherentInstances, but it's a bit… frightening :/
02:06:34 <Lemmih> navaati: It's either that or reorganising your code.
02:08:12 <lgm> hello!
02:08:35 <luite> hello lgm
02:08:49 <lgm> i was wondering if anyone is familiar with Oleg Kiselyov's implementation of LogicT
02:09:13 <lgm> in particular, i'm looking at the implementation of the function ai
02:09:37 <lgm> and having trouble parsing/typing the definition of the 3rd case
02:10:38 <lgm> http://paste.pocoo.org/show/377193/
02:11:51 <lgm> http://paste.pocoo.org/show/377195/
02:12:06 <lgm> the first link is to the defn of the function
02:12:16 <lgm> and the second is to the defn of bagofN
02:13:08 <lgm> as usual... attempting to explain my problem to someone else... i see the resolution to my problem!
02:13:16 <lgm> thanks for all your help!
02:13:47 <navaati> does someone understand how the package rmonad works ?
02:15:56 <_Ray_> hrm. ok, so read "North" :: Direction will work. however, what if instead of "North", someone input "jibberjabber"? Is there a way to catch that that's not a valid Direction constructor?
02:16:44 <ion> > (reads :: ReadS Integer) <$> ["42", "foo"]
02:16:45 <lambdabot>   [[(42,"")],[]]
02:17:47 <_Ray_> hrmph. it returns a "ReadS Integer"? and what's that?
02:17:57 <ion> :t ReadS
02:17:58 <lambdabot> Not in scope: data constructor `ReadS'
02:18:05 <tarrasch> :i ReadS
02:18:22 <ion> @hoogle ReadS
02:18:22 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
02:18:23 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
02:18:23 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
02:18:48 <luite> _Ray_: there's also this: http://hackage.haskell.org/package/safe
02:19:07 <luite> _Ray_: which has a function like read that has a Maybe result
02:19:16 <_Ray_> that's pretty, thanks :)
02:21:52 <luite> keep in mind that Read/Show aren't really meant for heavy user input/output. in particular, the show output should look like haskell source code for the value
02:22:24 <luite> if you want more complex input, have a look at parsec
02:22:36 <navaati> luite : then what are the typeclasses meant for user IO ?
02:22:58 <luite> navaati: there aren't any standard typeclasses for that
02:23:20 <navaati> x]
02:23:32 <ion> Also, direction :: Parser Direction; direction = North <$ string "north" <|> East <$ string "east" <|> …
02:26:04 <HugoDaniel> hello
02:36:23 <fenfrie> how can i cut off the last char of a String?
02:36:59 <_Ray_> init
02:37:26 <_Ray_> > init "yay"
02:37:27 <lambdabot>   "ya"
02:38:39 <_Ray_> Is there a way to use less parenthesis here? putStrLn $ "Exits: " ++ (intercalate ", " (map ((map toLower) . show . fst) (getExits r)))
02:40:00 <shachaf> fenfrie: ...But if you're doing that more than a few times, something is probably wrong.
02:40:14 <ion> Split the part after ++ to a named value.
02:40:40 <ion> @pl \r -> (intercalate ", " (map ((map toLower) . show . fst) (getExits r)))
02:40:41 <lambdabot> intercalate ", " . map (map toLower . show . fst) . getExits
02:40:57 <shachaf> putStrLn $ "Exits: " ++ (intercalate ", " . map (map toLower . show . fst) . getExits) r
02:41:03 <_Ray_> niiice
02:41:18 <_Ray_> thanks :)
02:41:34 <fenfrie> when i make a system comand like "system "ls"" how can i read the output into haskell so i can work on it?
02:43:34 <jeffz> fenfrie: have you looked at System.Process?
02:43:40 <luite> fenfrie: see System.Process, the simplest is readProcess, where you get stderr and stdout as IO String
02:44:21 <fenfrie> ah nice ty
02:44:24 <jeffz> ...but note that using ls isn't the best way to enumerate directory contents, it would be more direct to use a function which returns a list of files
02:45:18 <ziman> @pl \x -> length . filter and . map (zipWith (/=) xs) . permutations $ xs
02:45:18 <lambdabot> const (length (filter and (map (zipWith (/=) xs) (permutations xs))))
02:45:42 <ziman> @pl \xs -> length . filter and . map (zipWith (/=) xs) . permutations $ xs
02:45:42 <lambdabot> ((length . filter and) .) =<< (. permutations) . map . zipWith (/=)
02:45:56 <fenfrie> jeffz yes, ls was only a stupid example
02:50:58 <_Ray_> is my coding style too ugly to exist? http://hpaste.org/46011/style
02:52:32 <ziman> I like it.
02:52:35 <jeffz> function too big.
02:54:05 <_Ray_> would you split it at "if dir == []" ?
02:54:38 <shachaf> Don't use (== []) to check if a list is empty.
02:54:53 <luite> argh I was typing that shachaf! :p
02:54:53 <cheater99> _Ray_: use more where's
02:54:55 <_Ray_> length []?
02:54:59 <luite> null xs
02:55:01 <shachaf> No! That's even worse.
02:55:02 <shachaf> Either pattern-match or use null.
02:55:07 <_Ray_> ah, ok
02:55:11 <ziman> i'd probably move the "map (map toLower . show . fst)" out to a where clause
02:55:21 <ziman> and name it
02:55:34 <jeffz> I never use if.
02:56:29 <_Ray_> hrm. where does the "where" go, if I'm in a do-statement?
02:58:39 <doserj> _Ray_: you can safe horizontal space by leaving out the "in" in let statements in do-notation
02:58:42 <cheater99> what is a fiber and how does it relate to a thread?
03:00:28 <HugoDaniel> is there any haskell package that implements this: http://tools.ietf.org/html/rfc3339  ?
03:01:21 <doserj> _Ray_: also, I would maybe write it as: case (dir,action) of ([],"exit") -> ... ; ([],_) -> ... ; ((d:_):_),_) -> ...
03:01:42 <jeffz> _Ray_: I refactored it a bit, not sure if I preserved its intent, only did it by eye.
03:01:55 <_Ray_> :)
03:02:58 <solrize> @seen applicative
03:02:58 <lambdabot> Unknown command, try @list
03:02:58 <preflex>  applicative was last seen on #haskell 14 hours, 49 minutes and 8 seconds ago, saying: Maybe I will look into the open source Scripture study world. They must have done things like this. 
03:03:33 <_Ray_> oh, nice, thanks jeffz :)
03:04:02 <solrize> @tell applicative look up "phonestheme" in wikipedia, i wonder if anyone is using those for statistical machine translation
03:04:02 <lambdabot> Consider it noted.
03:04:38 <jeffz> HugoDaniel: this mentions the rfc number. http://hackage.haskell.org/packages/archive/swish/0.3.0.0/doc/html/Swish-Utils-DateTime.html
03:06:51 <fenfrie> is it possible in haskell to make a singture like foo :: String -> String and then make some output with the do notation and in the end return some String?
03:07:16 <sipa> no
03:07:30 <shachaf> fenfrie: "do notation" has little to do with IO. It doesn't make things imperative.
03:07:46 <sipa> something of type String -> String is a function that only transforms a string into an other string
03:07:48 <doserj> > 
03:07:49 <lambdabot>   not an expression: `'
03:07:51 <sipa> it can't do anything else
03:08:48 <fenfrie> ok
03:10:12 <doserj> @type let f::String -> String ; f x = do y <- x ; return y in f
03:10:13 <lambdabot> String -> String
03:11:40 <HugoDaniel> jeffz: yeah, i googled it and also looked in it :/
03:11:59 <HugoDaniel> it does not seem hard to implement a rfc 3339 output for timestamps
03:22:55 <_Ray_> hrm. in a do-statement, how could I say "If condition, make these two print statements. Else do nothing.", then go on with the rest of my program?
03:23:19 <Botje> else return ()
03:23:27 <_Ray_> won't that terminate the rest of the program?
03:23:30 <Botje> no
03:23:31 <_Ray_> oh, no
03:23:38 <_Ray_> right, it just exits that implicit do
03:23:41 <_Ray_> ... or something
03:23:48 <Botje> not even.
03:24:05 <Botje> a do block expects "statements" of the type IO something
03:24:08 <_Ray_> it sends () to the next thing in the "pipeline" of the do?
03:24:18 <Botje> both branches of the if must be of that type, return () *is* of that type
03:24:25 <shachaf> _Ray_: Assuming anything is "receiving" it, yes.
03:24:40 <Botje> _Ray_: more idiomatic is to use when or unless, of course
03:24:41 <Botje> :t when
03:24:42 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:24:44 <Jonno_FTW> > let n = 100 in [(i,n`div`i)|i<-[1..fromIntegral(round(sqrt(n)))],n`mod`i == 0]
03:24:45 <lambdabot>   [(1,100),(2,50),(4,25),(5,20),(10,10)]
03:25:03 <shachaf> _Ray_: "return ()" is just an IO action that does nothing.
03:25:05 <Botje> @src when
03:25:06 <lambdabot> when p s = if p then s else return ()
03:25:34 <_Ray_> can s be itself a do block?
03:25:46 <shachaf> _Ray_: Any value can be a do block.
03:25:47 <Botje> of course
03:25:51 <Botje> do is just syntax
03:26:03 <shachaf> _Ray_: do notation isn't magic. It just turns into function calls using simple rules.
03:26:23 <_Ray_> hrmph. is 'else' supposed to be more indented than the 'if' it belongs to?
03:26:34 <Botje> yes
03:26:38 <Botje> on the same level as the then
03:26:44 <_Ray_> ah, I thought I had done goof'd
03:30:55 <alpounet> so, has someone actually used HaskellNet for sending emails ?
03:41:22 <igstan> p
03:42:11 <Lemmih> exactly.
03:46:15 <igstan> what (preferred) packages are there in Haskell for templating (like Django or PHP templates)?
03:48:56 <alpounet> igstan, there's HStringTemplate
03:51:54 <igstan> alpounet: thanks, I'm taking a look right now.
03:52:51 <Lemmih> igstan: There's also heist.
03:53:35 <igstan> Lemmih: I think I don't like heist because it's xhtml based.
04:00:50 <c_wraith> I thought the newest versions moved to an html5-derived parser
04:08:47 <fenfrie> how can i dfeine something in do notation e.g. do {name = "hello" ++ "test"; putStrLn name}
04:09:54 <shachaf> let
04:10:21 <shachaf> > do { let name = "hello" ++ "test"; return name } :: Maybe String
04:10:22 <lambdabot>   <no location info>: parse error on input `}'
04:11:11 <shachaf> > do { let { name = "hello" ++ "test" }; return name }
04:11:11 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
04:11:12 <lambdabot>    arising from a use ...
04:11:18 <shachaf> > do { let { name = "hello" ++ "test" }; return name } :: Maybe String
04:11:19 <lambdabot>   Just "hellotest"
04:13:27 <fenfrie> shachaf thx
04:14:09 <shachaf> fenfrie: You should read about how do notation is translated to non-do syntax.
04:15:29 <Twey> do x ⇒ x; do x; y ⇒ x >> y; do x <- y; z ⇒ y >>= \x -> z
04:18:08 <shachaf> do let x = y; z ⇒ let x = y in z
04:18:21 <shachaf> @undo do { Just x <- y; return x }
04:18:22 <lambdabot> y >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
04:26:12 <roconnor> Are there any DER libraries for Haskell: http://en.wikipedia.org/wiki/Distinguished_Encoding_Rules ?
04:34:16 <blackdog> is there a package for loading up ghci wrt a given cabal file?
04:34:40 <blackdog> ie, only what's in the .cabal file gets loaded?
04:35:51 <shachaf> blackdog: http://hackage.haskell.org/trac/hackage/ticket/382 ?
04:36:10 <shachaf> Not as far as I know.
04:37:50 <blackdog> shachaf: yeah, that's what i'm looking for. it sounds like it might be trickier than i expected.
04:41:09 <geheimdienst> shachaf: interesting ticket, thanks
04:42:09 <geheimdienst> anyone know why they discuss both a "start ghci with this *cabal file" function and a "start ghci with this module"? the first is obvious, but what does cabal have to do with the second?
04:42:18 <geheimdienst> seems to me this would be more of a ghci bug
04:44:56 <whald> hello. i'm trying to understand monad transformers but keep failing, maybe someone can explain to me what i'm missing? it's this function: http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Sampling.hs#48
04:45:43 <whald> the "else" part should try to reach "down" to the inner Rand Monad to provide a value in case the Sample is "too small"
04:46:26 <whald> but ghc tells that "rnd" is of type "Rand Float" while i want to return an "Sampled Float". this is true, but i'd like to overcome this
04:46:59 <shachaf> @ty lift
04:47:00 <lambdabot>     Ambiguous occurrence `lift'
04:47:00 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
04:47:00 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
04:47:02 <shachaf> @ty Control.Monad.Error.lift
04:47:03 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
04:47:07 <whald> oh, and the Rand monad is here: http://code.google.com/p/bling-raytracer/source/browse/src/Graphics/Bling/Random.hs
04:48:15 <whald> shachaf, with lift the error get's worse (at least for my understanding): "Couldn't match expected type `Sampled Float' with actual type `t0 m0 a0'"
04:49:35 <tarrasch> whald, my general hint in these cirumstances is not to guess that 'lift makes the error worse'. Rather try to systematically put funciton signatures on most of your variables. For pedagogical reasons, then maybe the error will reveal itself. I can't make head or tails from your code myself. :)
04:53:00 <whald> tarrasch, yes, that "makes the error worse" was a bit wild.. :-)
04:54:23 <tarrasch> whald, it's very instinctive to 'feel bad' when the compilers spits out 100 lines of error messages when 1 line is erronous :p 
05:15:50 <geheimdienst> so i read up on the implicit parameters extension. is it safeish or is use frowned upon? on a scale 1..5, how evil is it?
05:25:53 <shachaf> geheimdienst: Depends on how it's used.
05:27:53 <geheimdienst> let's say i have some environmentish stuff that i could stick into a Reader. could i use implicit parameters and not be mauled by basement cat?
05:32:21 <epsilonhalbe> hey i'm trying to install lambdabot on a debian w\ ghc-6.12.1 and fail do build Plugin.Pl.Common ? do you have hints
05:35:28 <Heffalump> geheimdienst: I like implicit parameters. Most people seem not to. I think environments are a great use for them.
05:38:34 <geheimdienst> great, i'll give it a shot then :) thanks for the opinion
05:39:00 <geheimdienst> it's often difficult to estimate how evil an extension is ... maybe we should make a wiki page of ghc extensions ranked by evilness
05:39:05 * geheimdienst thinks about this
05:40:02 <Tyr42> I would read that
05:42:57 <FrederikVds> I'd like to do a database query inside a Heist template splice, the type of the database query is IO [[DB.SqlValue]], the type of the Heist splice is (MonadIO m) => TemplateMonad m Template, how would I do this?
05:44:14 <epsilonhalbe> i now put my build output here: http://hpaste.org/46013/lambdabot__install
05:44:26 <Saizan> FrederikVds: liftIO yourquery
05:45:42 <FrederikVds> thanks!
05:45:56 <Saizan> epsilonhalbe: looks like abu gin ghc
05:46:02 <Saizan> *a bug
05:46:52 <epsilonhalbe> so should i up or downgrade ghc or - leave lambdabot be lambdabot and just wait
05:51:52 <roconnor> @hoogle Maybe a -> [a]
05:51:52 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
05:51:52 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
05:51:52 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
05:52:24 <shachaf> @ty \y -> [x | Just x <- [y]]
05:52:25 <lambdabot> forall t. Maybe t -> [t]
05:56:36 <aristid> @pl \x -> case x of Just x -> return x; _ -> mzero
05:56:36 <lambdabot> (line 1, column 24):
05:56:36 <lambdabot> unexpected ">" or "-"
05:56:36 <lambdabot> expecting variable, "(", operator or end of input
05:56:52 <aristid> :t \x -> case x of Just x -> return x; _ -> mzero
05:56:53 <lambdabot> forall t (m :: * -> *). (MonadPlus m) => Maybe t -> m t
06:04:40 <tomi__> dd
06:08:54 <carpi> Hello. Good Afternoon. Could someone please tell me why this does not work? http://pastebin.com/4Bq4367K
06:09:13 <aristid> :t mconcat . Data.Foldable.toList
06:09:13 <lambdabot> forall a (t :: * -> *). (Monoid a, Data.Foldable.Foldable t) => t a -> a
06:09:21 <aristid> :t msum . Data.Foldable.toList
06:09:22 <lambdabot> forall (m :: * -> *) a (t :: * -> *). (MonadPlus m, Data.Foldable.Foldable t) => t (m a) -> m a
06:09:27 <shachaf> carpi: Tyhe type [a] -> a means that the function should work wih a list of anything.
06:09:32 <shachaf> carpi: But it only works with numbers.
06:09:41 <aristid> :t msum . map return . Data.Foldable.toList
06:09:42 <lambdabot> forall (m :: * -> *) a (t :: * -> *). (MonadPlus m, Data.Foldable.Foldable t) => t a -> m a
06:10:30 <Lemmih> carpi: A useful trick is to let GHCi infer the type signature for you.
06:10:45 <carpi> shachaf: well yes.. it is working with a list. that is the reason i used (x:xs)
06:11:07 <carpi> Lemmih: i thought it was bettter to explicity mention the type signature
06:11:10 <shachaf> carpi: Yes, but the type signature says that it'll work with a list of *anything*. E.g. a list of characters.
06:11:52 <Axman6> :t let f [] = errpr "bad"; f (x:xs) = x + 2 in f
06:11:53 <lambdabot> Not in scope: `errpr'
06:11:54 <carpi> shachaf: exactly. and that is why i don't get it when it give me an error when i tried to add the element in the list with a constant like 2
06:12:00 <Axman6> :t let f [] = error "bad"; f (x:xs) = x + 2 in f
06:12:01 <lambdabot> forall t. (Num t) => [t] -> t
06:12:15 <Axman6> :t let f [] = error "bad"; f (x:xs) = x + 2 in f "hello"
06:12:15 <Lemmih> carpi: Not when you don't understand them (:
06:12:16 <lambdabot>     No instance for (Num Char)
06:12:16 <lambdabot>       arising from a use of `f' at <interactive>:1:44-52
06:12:16 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
06:12:21 <shachaf> carpi: Because of what I just said. You can't add 2 to a character.
06:12:25 <Axman6> : 'H' + 2
06:12:29 <Axman6> > 'H' + 2
06:12:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
06:12:30 <lambdabot>    arising from the literal `2...
06:12:46 <Lemmih> carpi: You can ask GHCi which type it inferred for the function.
06:12:49 <Axman6> can't add 2 to characters!
06:12:59 <Axman6> :t let f [] = error "bad"; f (x:xs) = x + 2 in f [(),()]
06:13:00 <lambdabot>     No instance for (Num ())
06:13:00 <lambdabot>       arising from a use of `f' at <interactive>:1:44-52
06:13:00 <lambdabot>     Possible fix: add an instance declaration for (Num ())
06:13:07 <Axman6> not unit!
06:13:07 <hpc> you could make an instance of Num for characters, yourself
06:13:08 <Axman6> nor*
06:13:44 <shachaf> Axman6: instance Num Char where ...
06:14:10 <carpi> yup. my understanding is pitiful.. :(
06:14:12 <Axman6> sure... but you certainly understand my point...
06:14:50 <Axman6> carpi: to be able to use +, you need to restrict the types that the input list can contains, specifically, it must be a list of elements which implement the Num class,. where + is defined
06:14:55 <Axman6> @instances Num
06:14:56 <lambdabot> Double, Float, Int, Integer
06:15:01 <Axman6> @src Num
06:15:01 <lambdabot> class  (Eq a, Show a) => Num a  where
06:15:01 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:15:01 <lambdabot>     negate, abs, signum     :: a -> a
06:15:01 <lambdabot>     fromInteger             :: Integer -> a
06:15:09 <Axman6> is what i actually meant to shiw...
06:15:11 <Axman6> show*
06:15:13 <Lemmih> carpi: Do you see how your function doesn't make sense if you call it with a list of characters?
06:15:29 <Kaidelong> @ty toEnum . ((+) `on` fromEnum)
06:15:30 <lambdabot>     Couldn't match expected type `Int' against inferred type `a -> Int'
06:15:30 <lambdabot>     Probable cause: `on' is applied to too few arguments
06:15:30 <lambdabot>     In the second argument of `(.)', namely `((+) `on` fromEnum)'
06:15:50 <Kaidelong> oh right
06:15:58 <carpi> Lemmih: yup. characters cannot be added with numbers..
06:16:04 <Kaidelong> @ty (toEnum .) . ((+) `on` fromEnum)
06:16:04 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a1 -> a
06:16:25 <Kaidelong> > ((toEnum .) . ((+) `on` fromEnum)) 'a' 5 :: Char
06:16:26 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
06:16:26 <lambdabot>    arising from the literal `5...
06:16:37 <Kaidelong> > ((toEnum .) . ((+) `on` fromEnum)) 'a' (5 :: Int) :: Char
06:16:38 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:16:38 <lambdabot>         against inferred type...
06:16:49 <Kaidelong> oh!
06:17:03 <tomh> is there a good video around of concurrency in haskell?
06:17:31 <Axman6> video showing what?
06:17:49 <aristid> concurrency
06:18:15 <Lemmih> carpi: Excellent. The 'Num a' part of the type signature just means that 'a' must be a thing that can be added.
06:19:01 <tomh> Axman6, just which goes into the details of how it is implemented in ghc or stuff like that
06:19:23 <tomh> just something I can do from my lazy chair :)
06:19:40 <carpi> Lemmih: thax for the clarification
06:20:52 <Axman6> tomh: there's several papers, you'd be lucky to see a video though
06:21:07 <tomh> hmm ok, too bad
06:21:41 <cheater99> hey guys, what are implicit and explicit threads?
06:23:57 <Lemmih> cheater99: Explicit threads are threads you create yourself. Implicit threads are created for you.
06:24:05 <cheater99> thanks
06:24:20 <saati> when does ghc use implicit threads?
06:24:27 <cheater99> good question
06:24:56 <Lemmih> saati: When you use 'par' for example.
06:25:26 <saati> that's kinda explicit isn't it?
06:26:10 <Lemmih> saati: It doesn't always create a new thread.
06:26:59 <cheater99> what does [:Double:] mean in the type declaration here on slide 21? http://www.scribd.com/doc/19770030/Specialising-Generators-for-HighPerformance-MonteCarlo-Simulation-in-Haskell
06:27:00 <saati> so implicit thread does not mean it automagically thinks out how to make it paralell, just you don't have to manage the threads one by one?
06:27:18 <Axman6> cheater99: it's a parallel array
06:27:26 <cheater99> what's the "difference"?
06:27:32 <gienah> tomh: http://skillsmatter.com/podcast/scala/talk-by-haskell-expert-simon-peyton-jones/js-1434
06:27:33 <lambdabot> gienah: You have 5 new messages. '/msg lambdabot @messages' to read them.
06:27:34 <Lemmih> saati: Yeah, well, the term is kinda overloaded.
06:27:58 <Axman6> Darkone: go watch a talk by SPJ about DPH
06:28:12 <tomh> gienah, thanks :D
06:28:30 <Axman6> uh, cheater99 not Darkone 
06:29:00 <Lemmih> saati: Doing concurrency without any help from the user is very hard so implicit threads commenly refers to things like 'par' nowadays.
06:29:06 <hpc> @msg BONUS how long does it usually take for lyah to ship? I haven't gotten mine yet
06:29:06 <lambdabot> Not enough privileges
06:29:12 <hpc> @tell BONUS how long does it usually take for lyah to ship? I haven't gotten mine yet
06:29:12 <lambdabot> Consider it noted.
06:29:27 <cheater99> Axman6: i can't, i'm on mobile internet
06:29:33 <cheater99> Axman6: the best i can do is slides
06:29:40 <Axman6> cheater99: well when you can, you should
06:30:13 <cheater99> do you have a link for that?
06:30:20 <cheater99> hpc: i hadn't gotten mine either.
06:31:26 <saati> lyah is learn you a haskell for great good?
06:31:42 <Axman6> yes
06:31:57 <Axman6> cheater99: i hope it's this one. http://www.youtube.com/watch?v=NWSZ4c9yqW8
06:32:18 <cheater99> thanks
06:50:21 <ezyang> I need a strict IntMap.map :-( 
06:50:52 <Athas> sjanssen: I have implemented Xresources support in X11.  Where can I send patches?
06:55:41 <djanatyn> typeclasses are interesting
06:58:10 <Athas> Indeed!  Especially with a few extensions.
06:58:40 <Athas> Standard Haskell 98 typeclasses are just the appetiser.
07:04:51 <ustunozgur> Hi, newbie here, I'm trying to implement a simple function that appends the parity of a vector to the vector. http://dpaste.org/iZUg/ Here is what I've got so far, but it doesn't compile. Can anyone help?
07:04:57 <djanatyn> > :t pi
07:04:57 <lambdabot>   <no location info>: parse error on input `:'
07:05:21 <djanatyn> wait a second. So when I multiply a number by pi, that number is transformed into a floating number?
07:05:25 <djanatyn> > 5 * pi
07:05:26 <lambdabot>   15.707963267948966
07:05:28 <ezyang> ustunozgur: don't use [x:xs] 
07:05:33 <Axman6> djanatyn: no
07:05:35 <djanatyn> > (5 :: Int) * pi
07:05:36 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
07:05:36 <lambdabot>    arising from a use of...
07:05:37 <shachaf> djanatyn: No. 5 was already a floating point number.
07:05:40 <ezyang> s/[x:xs]/xs/ 
07:05:42 <Axman6> haskell does no auto0matic conversion of any types
07:05:47 <djanatyn> Oh?
07:05:56 <ustunozgur> Also, how do I pattern match a list? Simply [xs]
07:05:57 <djanatyn> I thought numbers started out as integers by default
07:06:01 <shachaf> djanatyn: When you just type "5", it's a magic value that turns into whatever you want it to be.
07:06:03 <ezyang> No brackets. 
07:06:04 <shachaf> @ty 5
07:06:05 <lambdabot> forall t. (Num t) => t
07:06:06 <Axman6> > (5 :: Int) * pi
07:06:06 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
07:06:07 <lambdabot>    arising from a use of...
07:06:09 <ion> Number literals stand for fromInteger n where n is the equivalent Integer value.
07:06:12 <pmetzger> it will deduce that 5 has to be a float in this context.
07:06:16 <Axman6> :t 5 * pi
07:06:17 <lambdabot> forall t. (Floating t) => t
07:06:26 <Athas> ustunozgur: [x:xs] means "a list of one element, which is a nonempty list where the head is x and the tail is xs".
07:06:28 <ion> > fromInteger (5 :: Integer) * pi
07:06:29 <lambdabot>   15.707963267948966
07:06:32 <shachaf> djanatyn: Note that saying (x :: Int) isn't the same as casting x to an Int. There's no conversion going on.
07:06:37 <Athas> You want (x:xs), which means "a nonempty list where the head is x and the tail is xs".
07:06:52 <djanatyn> shachaf: I see.
07:07:09 <ion> s/Number/Integer/ that is
07:07:20 <shachaf> djanatyn: Numbers are messy and complicated. Start with nicer type classes like Eq and Show. :-)
07:07:35 <ion> Meh. Numbers are simple.
07:07:56 <koeien> I still don't have the number type hierarchy in my head
07:07:56 <shachaf> ion: I meant Haskell numbers. There are things to deal with like a messy hierarchy and defaulting.
07:08:15 <ezyang> Athas: That's not even necessary, because he never uses x and xs separately. 
07:08:38 <Athas> ezyang: oh yes, that's true.
07:09:02 <ustunozgur> ezyang: You mean spc_enc xs = xs ++ [mod sum(xs) 2]   ? That doesn't work too.
07:09:17 <djanatyn> Ah, so that's why my pattern matching didn't work.
07:09:25 <ion> mod sum xs 2?
07:09:26 <djanatyn> it literally checks from the top of your code to the bottom of your code.
07:09:34 <ustunozgur> Yes, I don't need tail or head, just the whole list.
07:09:48 <djanatyn> Learn You a Haskell is such an excellent tutorial.
07:09:50 <Athas> ustunozgur: mod (sum(xs)) 2
07:09:54 <djanatyn> You just have to listen to what they're saying. :)
07:09:55 <Axman6> you mean mod (sum xs) 2
07:10:09 <Athas> Remember the precedence rules: application binds tighter than anything else.
07:10:17 <shachaf> djanatyn: Well, not *literally*. But it doesn something equivalent.
07:10:25 <shachaf> s/n / /
07:10:51 <ezyang> ustonozgur: Well, now you have an unrelated error. 
07:11:13 <djanatyn> woah. recursive functions hurt my brain.
07:11:14 <ezyang> The trick to answering compiler warnings is knowing when you've fixed one error and uncovered another one. 
07:11:26 <ezyang> usually the list of errors gets shorter. But not always ;-) 
07:11:36 <ustunozgur> OK, bear with me. This is my first haskell code. 
07:12:04 <Axman6> i hate it when you've written something really broken and finally ghc gives you one error, and you fix it... and then there's a whole new bunch of error it just hadn't got up to
07:12:07 <keep_learning> hello all 
07:12:13 <shachaf> Axman6: Huh?
07:12:24 <shachaf> Axman6: Even if it gives several errors, you should only ever fix the top one and then rerun it.
07:12:33 <Athas> ustunozgur: no problem, we were all new once, and functional languages have peculiar syntax.
07:12:39 <Axman6> shachaf: yes... this is what i was saying
07:12:54 <Athas> Man, two trivial extensions have made my code so much nicer: ViewPatterns and TupleSections.
07:13:00 <Axman6> if the code's broken enough, you'll fix all the syntactic errors, the  it gets to the type errors etc
07:13:15 <shachaf> Axman6: Yes, well, that's good, no?
07:13:17 <keep_learning> i am writing (xs++ys) using foldr so my function is foldr (:) ys xs
07:13:21 <keep_learning> it works fine 
07:13:26 <ustunozgur> OK, got it working. Thanks!
07:13:28 <Axman6> sure, but also a little annoying at timea
07:13:28 <shachaf> Axman6: There's no point in looking at type errors until syntax errors are fixed.
07:13:29 <Axman6> s*
07:13:55 <shachaf> Compiler output past the first error is usually useless. :-)
07:14:15 <keep_learning> but when i am using how the foldr works 
07:14:19 <keep_learning> i am getting error 
07:14:20 <Axman6> sure.. i can see you don't understand what I'm saying. so let's move on =)
07:14:43 * shachaf indeed does not. OK.
07:14:50 <keep_learning> suppose i want   to combine these two list [1,2]++[3,4] 
07:15:02 <keep_learning> so according to foldr applied 
07:15:03 <djanatyn> hmm. would anyone care if I found a really small typo in LYAH?
07:15:09 <ion> http://hackage.haskell.org/trac/haskell-prime/wiki/TupleSections “rather than \a b -> ((1,a),b) as some might expect”. Who would expect *that*?
07:15:20 <Axman6> djanatyn: BONUS would
07:15:21 <shachaf> djanatyn: You could tell BONUS.
07:15:50 <keep_learning> (:) 1 ( (:) 2 ( (:) [] [3,4] ) ) 
07:15:58 <keep_learning> it should be like this 
07:16:10 <Athas> What is considered the better style: LANGUAGE pragmas in source files, or Extension field in Cabal?
07:16:11 <keep_learning> if i understand the foldr function 
07:16:21 <ion> > (:) [] [3,4]
07:16:21 <lambdabot>   No instance for (GHC.Num.Num [a])
07:16:22 <lambdabot>    arising from a use of `e_134' at <inte...
07:16:22 <djanatyn> BONUS: In chapter "Syntax in Functions", right beneath your second addVectors code, there's the text, "There we go!"
07:16:24 <shachaf> keep_learning: Where's the [] coming from?
07:16:34 <shachaf> djanatyn: Try @tell or email. :-)
07:16:34 <keep_learning> the empty list in last 
07:16:41 <keep_learning> should it not be there 
07:17:01 <djanatyn> BONUS: In that same paragraph you have the code "addVectors :: (Num a) => (a, a) -> (a, a) - > (a, a)". I don't think you want a space in that last arrow.
07:17:02 <shachaf> The [] in the original list is replaced with the second argument to foldr.
07:17:06 <keep_learning> shachaf, when the list will exhausted 
07:17:14 <Axman6> Athas: i prefer them in the source file, then you know where they're used, and they don't need to be used everywhere
07:17:15 <djanatyn> @tell Bonus In chapter "Syntax in Functions",  right beneath your second addVectors code,  there's the text, "There we go!"
07:17:15 <lambdabot> Consider it noted.
07:17:25 <djanatyn> @tell BONUS In that same paragraph you have the  code "addVectors :: (Num a) => (a, a) -> (a,  a) - > (a, a)". I don't think you want a  space in that last arrow.
07:17:25 <lambdabot> Consider it noted.
07:17:34 <djanatyn> Uh, is lambdabot case sensitive?
07:17:45 <shachaf> Probably not.
07:18:12 <djanatyn> @tell BONUS sorry for pinging you twice. I really like your book! :D
07:18:13 <lambdabot> Consider it noted.
07:18:23 <keep_learning> shachaf, u mean the the empty list will be replace by ys [ (xs ++ ys ) = foldr (:) ys xs ] 
07:18:32 <shachaf> djanatyn: ...Sorry for sending you two messages, here's another message to make up for it?
07:18:42 <koeien> can I serialize mutually recursive data structures automatically?
07:18:46 <shachaf> keep_learning: Where do these brackets keep coming from?
07:18:58 <Axman6> koeien: what do you mean?
07:19:05 <keep_learning> shachaf, i did not get u 
07:19:13 <ezyang> koeien: Mutually recursive as in circular, or something else... 
07:19:14 <Axman6> there's not really much automatic serialisation to begin with
07:19:16 <djanatyn> shachaf: I was mostly sorry for using his nick and then sending him a @tell message.
07:19:26 <koeien> Axman6: suppose that I have data X = X Y; data Y = Y X; x = X y; y = Y x
07:19:29 <ion> @tell BONUS I’d like to express my apologies on behalf of djanatyn for the flood of unnecessary messages.
07:19:29 <lambdabot> Consider it noted.
07:19:29 <djanatyn> I don't think he cares how many @tell messages he gets, but it's just a guess.
07:19:40 <djanatyn> Heh.
07:19:55 <shachaf> @tell CAXAF foo
07:19:55 <lambdabot> Consider it noted.
07:20:05 <koeien> Axman6: is there a way to serialize x? Or do I need to keep identifiers in my data structure and remember which ones I serialized?
07:20:06 <FUZxxl> Hello!
07:20:09 <djanatyn> shachaf: Do you have anything you'd like to tell BONUS?
07:20:10 <FUZxxl> @help tell
07:20:10 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
07:20:11 <caxaf> > succ 1
07:20:12 <lambdabot>   2
07:20:12 <lambdabot> caxaf: You have 1 new message. '/msg lambdabot @messages' to read it.
07:20:17 <ustunozgur> When a function matches against a list, i.e. like funcname xs = ... how does it know xs is actually a list, rather than a single item (like an atom)? It can't, right? Would I need funcName [xs] in that case?
07:20:22 <caxaf> @messages
07:20:22 <lambdabot> shachaf said 26s ago: foo
07:20:23 <Axman6> koeien: huh?
07:20:34 <Axman6> koeien: what are you using to serialise your structures?
07:20:42 <ezyang> ustunozgur: The type system! 
07:20:43 <koeien> Axman6: nothing yet, but
07:20:45 <Athas> ustunozgur: it can infert it by the way you use xs.
07:20:55 <ezyang> the type of your function states that xs is of type [a], so it must be a list, and not, say, an Int. 
07:21:03 <FUZxxl> Can somebody help me? I asked thi question on SO, but the answer are not very satisfying: http://stackoverflow.com/questions/5769726/design-of-interface-abstraction
07:21:06 <koeien> ustunozgur: that depends it on how you use it on the right. e.g. funcname xs = xs, then funcname will be of type a->a
07:21:12 <Athas> ustunozgur: You use xs as a list (pass it as operand to ++, for example), hence it has to be a list.
07:21:28 <koeien> Axman6: nothing yet, but I want to make a choice with this in mind :) otherwise I will go for Data.Binary most likely
07:21:34 <Athas> ustunozgur: it is when you use a variable in conflicting ways (eg. as both a list and a number) that you get type errors.
07:21:38 <keep_learning> shachaf, if i am adding two list [1,2] ++ [3,4] then according to foldr definition (:) 1 ( (:) 2 ( (:) [] [3,4] ) ) 
07:21:51 <ustunozgur> Hmm, I was a bit confused about the type system, since there is also type inference, and it can automagically guess the types. I guess it is for these situations.
07:21:56 <ezyang> FUZxxl: What's not satisfying about the asnwers? 
07:22:12 <keep_learning> so do you mean the inner (:) [] [3,4] is replaced by [3,4]
07:22:14 <shachaf> keep_learning: No.
07:22:16 <ezyang> ustunozgur: For simple code, GHC will be able to automatically infer your types. 
07:22:22 <FUZxxl> ezyang: It's maybe, that I don't really understand, what I want.
07:22:26 <FUZxxl> Can't get my head around it.
07:22:31 <keep_learning> shachaf, or i misunderstood something 
07:23:05 <ezyang> FUZxxl: Glancing at it, maybe you want the Prompt monad. 
07:23:07 <shachaf> @let a_list_of_3_4
07:23:07 <lambdabot>   TemplateHaskell is not enabled
07:23:14 <dmwit> ?src (++)
07:23:14 <lambdabot> []     ++ ys = ys
07:23:14 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:23:14 <lambdabot> -- OR
07:23:14 <lambdabot> xs ++ ys = foldr (:) ys xs
07:23:16 <shachaf> @let a_list_of_3_4 = var "[3,4]"
07:23:17 <lambdabot>  Defined.
07:23:23 <FUZxxl> ezyang: ?
07:23:26 <shachaf> > foldr f a_list_of_3_4 [1,2]
07:23:27 <lambdabot>   No instance for (SimpleReflect.FromExpr
07:23:27 <lambdabot>                     (Data.Number.Sy...
07:23:27 <dmwit> keep_learning: You expanded the fold incorrectly.
07:23:29 <FUZxxl> @hoogle Prompt
07:23:29 <lambdabot> System.Console.Editline.Readline getPrompt :: IO String
07:23:29 <lambdabot> System.Console.Editline setPrompt :: EditLine -> IO String -> IO ()
07:23:35 <shachaf> Grr.
07:23:36 <shachaf> @undefine
07:23:46 <dmwit> keep_learning: The actual expansion is (:) 1 ( (:) 2 ( [3, 4] ))
07:23:49 <ezyang> FUZxxl: http://blog.ezyang.com/2010/01/adventures-in-three-monads/ (see the section on the Prompt monad) 
07:24:45 <keep_learning> dmwit, so it will not be empty list 
07:25:08 <keep_learning> dmwit, thanks 
07:25:17 <FUZxxl> ezyang: What is it's purpose?
07:25:24 <keep_learning> ?src filter
07:25:24 <lambdabot> filter _ []     = []
07:25:24 <lambdabot> filter p (x:xs)
07:25:24 <lambdabot>     | p x       = x : filter p xs
07:25:24 <lambdabot>     | otherwise = filter p xs
07:25:47 <keep_learning> ?src foldr
07:25:48 <lambdabot> foldr f z []     = z
07:25:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:25:48 <ezyang> FUZxxl: It lets you write a monad that answers requests with responses, but stay abstract over how these requests are actually answered. 
07:26:07 <ezyang> So one implementation will use IO to ask the second player what the response is, whereas another might use an algorithm to implement an AI. 
07:26:17 <keep_learning> ?src foldl
07:26:17 <lambdabot> foldl f z []     = z
07:26:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:26:45 <ustunozgur> Thanks ezyang and Athas, one final question: Is there a preferred linear algebra package for Haskell? I don't want sometimes very sophisticated, mainly for matrix multiplication ala MATLAB. I have found http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Linear_algebra which of them can you recommend? I mainly use MATLAB and C for numeric computations currently.
07:27:09 <koeien> I have had good experience with hmatrix
07:27:13 <ben> Is there a list of all the #haskell-* channels on freenode?
07:27:33 <ezyang> ustunozgur: I can't give a recommendation, but I can say that you won't get an interface that is as fluent as MATLAB. MATLAB heavily overloads its operators. 
07:27:54 <ezyang> in type unsound ways, IMO :-) 
07:27:57 <koeien> ustunozgur: but I don't know how easy it is to get running. on linux it's quite easy
07:28:09 <copumpkin> matlab is horrifying
07:28:46 <Axman6> ben: any client that can list channels should be able to tell you...
07:28:55 <ezyang> Do people think my Haskell heap series is moving too slowly?  An experienced Haskeller should be able to digest the two comics I've already done in about fifteen seconds. 
07:29:37 <ben> Axman6: I assumed most channels stayed unlisted to avoid automated spam. Oh,well.
07:30:02 <FUZxxl> ezyang: It's perfect.
07:30:03 <ustunozgur> koeien: OK, I will give it a try. Thanks.
07:30:06 <Tyr42> I have read both of them, and they are good
07:30:08 <Tyr42> I like them
07:30:15 <FUZxxl> I would like to learn something about garbage collection.
07:30:25 <FUZxxl> ezyang: Reading your article...
07:30:50 <ezyang> I think I am going to talk about pointer reachability. 
07:31:03 <ezyang> Which is "about as much about the GC as you should really care about" 
07:31:19 <FUZxxl> ezyang: +1
07:31:45 <shachaf> ezyang: Giving seq as an example of a "ghost" in your first article is kind of weird.
07:32:21 <carpi> "lengthx :: Num a => [t] -> a" in that type definiiton could someone please tell me what 't' stands for?
07:32:24 <shachaf> ezyang: Given that almost every value has ghosts, and usually they're just regular dependencies rather than seq.
07:32:46 <shachaf> carpi: Probably "type". In this case it means "any type at all"; you could use any letter.
07:32:49 <koeien> carpi: it is a type variable. it can stand for any type (e.g. Integer, Bool)
07:32:52 <ezyang> shachaf: Right. But regular dependencies will end up being the least interesting thing, in the long term. 
07:33:00 <saati> what is a ghost?
07:33:08 <FUZxxl> ezyang: Please also tell, where are the packages coming from?
07:33:26 <carpi> ah okay.. so in this context 't' is anytype?
07:33:26 <ezyang> Functions! :-) 
07:33:27 <shachaf> ezyang: Oh, you posted a second article on exactly this topic.
07:33:32 <shachaf> ezyang: Never mind. :-0
07:33:33 <koeien> carpi: correct.
07:33:36 <shachaf> s/.$/)/
07:33:40 <carpi> thank you : )
07:33:49 <koeien> carpi: to calculate the length of a list, it is not important what the type of the entries is
07:34:22 <carpi> yup. i concur
07:34:46 <koeien> Haskell knows that "t" is a type variable because it starts with a lowercase letter
07:35:17 <koeien> you might have noticed that types start with uppercase, e.g. Integer, Bool
07:35:27 <FUZxxl> ezyang: So... You say, that the function "playSkat" should live in Prompt?
07:35:47 <carpi> koeien: yea.. i noticed.. i thought that had to do with the syntax of the language
07:36:05 <koeien> yes, it is not merely a convention, it is required
07:36:19 <ezyang> FUZxxl: playSkat would be whatever function runs the different monads. 
07:36:24 <shachaf> koeien: *Concrete* types start with an uppercase letter. High-strength, vacuum, cellular, rubberized, etc.
07:36:28 <FUZxxl> ezyang: I thought of Player as kind of a frontend. But I have three of them  in the program.
07:36:46 <ezyang> You'll have to clarify what you mean by frontend. 
07:36:46 <FUZxxl> ezyang: And all of them are statefull.
07:37:00 * shachaf had no idea: http://en.wikipedia.org/wiki/Types_of_concrete
07:37:25 <ezyang> Yes, you can back the prompt monad with a stateful monad. 
07:37:35 <koeien> heh.
07:38:21 <FUZxxl> ezyang: Maybe one Player / frontend sends requests over the network, the other displays it onto the prompt and the third is an AI that just calculates a strategie. All at the same time.
07:38:35 <ezyang> Sure. 
07:38:59 <FUZxxl> ezyang: I don't quite get how to archieve this using pompt.
07:39:26 <ezyang> FUZxxl: Did you read the article? 
07:40:02 <FUZxxl> Yes.
07:40:12 <ezyang> If it's too dense, I can give you an exercise that will help you see how you might abstract things out. 
07:42:37 <FUZxxl> ezyang: I understand, it is about giving a set of operations that can be done. These are functions in the prompt monad and are backed by the actual implementation.
07:42:48 <FUZxxl> ezyang: Which may be IO or something else.
07:43:00 <ezyang> OK, so maybe I misunderstand your 10:57 comment. 
07:43:19 <FUZxxl> Which one?
07:43:27 <FUZxxl> A!
07:44:05 <FUZxxl> I mean, I can image how to do this, if there was only one frontend, but not if there are three.
07:44:57 <adamvh> Any users of the graphviz package out there?
07:45:03 <ddarius> shachaf: Concrete is serious business.
07:45:11 <Axman6> i believe ivanm uses it a low
07:45:12 <adamvh> (I mean the Haskell library
07:45:30 <ezyang> You swap out different implementations by giving runPromptM different handler functions. 
07:45:48 <adamvh> )
07:46:05 <ezyang> handleNetwork, handleInteractive, handleAI 
07:46:20 <ezyang> Furthermore, the output results of these handler functions can be in whatever monad you want. 
07:46:57 <FUZxxl> ezyang: And the handling function is then defined by the player type.
07:47:30 <FUZxxl> Okay.
07:47:33 <shachaf> ddarius: And abstract is, I suppose, a joke?
07:47:45 <FUZxxl> My player type = handling function
07:47:49 <ezyang> Yep. 
07:47:55 <ezyang> And maybe some extra metadata. 
07:47:59 <FUZxxl> Okay. Got it.
07:49:25 <FUZxxl> Some of the handlers need to carry state over the whole game. (Like the AI). As the different player's actions are interleaved, how can I carry these three pieces of state? Should I carry them inside the big state used by playSkat itself?
07:49:58 <ezyang> FUZxxl: If the handler but not the game logic needs the state, put it in the handler monad. 
07:50:09 <ezyang> If the game logic needs to see the state, you'll need to use a prompt transformer. 
07:50:10 <FUZxxl> Okay.
07:50:20 <ezyang> or expose requests/responses for accessing and modifying the state. 
07:50:47 <tomh> ezyang, you run the blog at ezyang.com?~
07:52:32 <ezyang> ja 
07:52:43 <tomh> cool, great content, great design :)
07:52:49 <shachaf> ezyang: Do you run the Freenode nick ezyang?
07:52:59 <ezyang> shachaf: Of course not! >:-) 
07:53:05 <ezyang> tomh: Thanks! 
07:53:07 <shachaf> Oh.
07:53:28 <shachaf> Well, great content there too.
07:53:45 <FUZxxl> The idea was, that the gaming logic is abstracted from the different handlers. What I still don't get is, how to interleave the different handlers in this case? The players are playing their cards one by one. Afterwards, the logic decides who won the trick. Then each of them receives a notification who won the game. How to do this kind of interleaving while preserving execution order and carrying state?
07:55:02 <ezyang> Ah, that's tricky. 
07:55:14 <tomh> im doing my thesis on sort of this topic
07:55:31 <FUZxxl>  ezyang: And that's my problem.
07:55:39 <ezyang> Since the interleaving code needs to interact with both monads, it needs to be in a monad that provides the capabilities of all of the monads it manages. 
07:55:43 <ezyang> So IO is a pretty natural choice. 
07:55:49 <ezyang> Then the next question is, how do you carry state? 
07:56:53 <ezyang> Well, you could write an /incremental/ monad runner, which is something like runMonad :: State -> M a -> (a, State); oh wait, that's just runState :-) 
07:57:19 <hpc> :t runState
07:57:20 <lambdabot> forall s a. State s a -> s -> (a, s)
07:57:27 <hpc> ezyang: it's a lifted runState
07:57:31 <FUZxxl> ezyang: That's, what I was asking too. My personal idea is now, to either use a transformer stack of all three handlers and appropriate lifting or to carry the state inside the game logic and put it back when running the actions.
07:57:47 <ezyang> Or you could do something even trickier, and return a /continuation/, which should be invoked after the game logic is done. 
07:58:02 <ezyang> whereas in the previous scheme, you manually construct the continuation in the game logic. 
07:58:27 <ezyang> FUZxxl: Does the interleaver need to have access to all three handlers? 
07:58:33 <ezyang> If not, reify their state and pass it around explicitly. 
07:58:36 <FUZxxl> ezyang: Now it becomes difficult.
07:58:41 <ezyang> It's a lot nicer that way. 
07:58:52 <FUZxxl> ezyang: No. Each of the states are independent.
07:58:59 <FUZxxl> and also each of the players.
07:59:15 <ezyang> right. 
07:59:47 <ezyang> evaluate x `seq` y    ==>  y is a kind of strange equation for evaluate. 
08:00:17 <ezyang> Well, it totally makes sense, but... 
08:02:32 <FUZxxl> ezyang: Okay... then the best way is to use a data type Player, that defines all kind of handlers needed. When the logic wants to tell something to the player, it picks the player's state and executes the action of the handler with the appropriate state.
08:03:12 <ezyang> I don't think you'll get very much code reuse that way. 
08:03:53 <FUZxxl> ezyang: That's why I thought, that this is not the idiomatic solution.
08:04:49 <ezyang> I mean, you're conflating two game logics. 
08:04:54 <FUZxxl> ?
08:05:03 <ezyang> One game logic involves an interaction with a single player. 
08:05:04 <carpi> just as i can do (x:xs) to pattern match the first element and the rest of the list.. is there any way to pattern match the last element and the beginning of the list?
08:05:11 <ezyang> Another game logic involves interactive with multiple players. 
08:05:16 * hackagebot hslua 0.3.2 - A Lua language interpreter embedding in Haskell  http://hackage.haskell.org/package/hslua-0.3.2 (GracjanPolak)
08:05:19 <FUZxxl> carpi: Use last and init
08:05:24 <ezyang> Hmm, maybe you can just have multiple prompt monad layers and that'll workf ine. 
08:05:43 <Tyr42> carpi: there's no patter for it though
08:06:02 <Tyr42> carpi: as `:` is the constructor you are matching against
08:06:12 <Tyr42> carpi: *pattern
08:06:12 <carpi> FUZxxl: but im talking about pattern matching. i know you can extract the last element and beginning of a list using 'last' and 'init' but what if wanted to pattern match?
08:06:16 <ddarius> evaluate x `seq` y ==> y is the whole point of evaluate.
08:06:26 <carpi> Tyr42: so i guess its not possible
08:06:26 <FUZxxl> That's, what I also thought. But because the three layers are all of the same typeclass, it gets complicated when deciding which one to pick.
08:06:40 <Tyr42> carpi: no
08:06:45 <FUZxxl> carpi: Not possible. Use a lokal binding.
08:06:52 <FUZxxl> *local
08:07:14 <FUZxxl> :i lift
08:07:23 <FUZxxl> @show lift
08:07:24 <lambdabot> "lift"
08:07:28 <FUZxxl> @help
08:07:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:07:47 <hpc> FUZxxl: you wanted the source of lift?
08:08:06 <hpc> :t lift -- it's a typeclass function, so it is different for each type
08:08:07 <lambdabot>     Ambiguous occurrence `lift'
08:08:07 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
08:08:07 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
08:08:14 <hpc> :t Control.Monad.Error.lift
08:08:15 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
08:08:33 <FUZxxl> IIRC, lift lifts as many layers as needed, doesn't it?
08:08:41 <FUZxxl> Not shure though.
08:08:58 <hpc> it doesn't lift multiple layers
08:09:00 <Athas> carpi: you can do it if you use the ViewPatterns extension.
08:09:01 <FUZxxl> okay.
08:09:28 <Tyr42> athas: isn't that slow?
08:09:37 <ezyang> It won't work if you have two idential PromptM layers. 
08:09:47 <ezyang> In that case, I recommend making an explicit liftA and liftB function, for each player. 
08:10:37 <FUZxxl> ezyang: The types of the layers are not known at compile time, just that they are three different layers. But making three lifters sounds good.
08:10:39 <Athas> Tyr42: for this case, yes.
08:11:01 <Athas> Tyr42: but in general, view patterns have no intrinsic performance penalty.  They're just syntactic sugar.
08:11:05 <carpi> Athas: extension. You mean an external library?
08:11:17 <Athas> carpi: no, it's a compiler extension found in GHC 6.10 and above.
08:11:21 <ezyang> Hmm. I wonder if we have irrefutable view patterns. 
08:12:08 <Athas> carpi: intuitively, instead of writing your pattern on a value, you write your pattern on the result of applying a function to the value.
08:12:44 <Athas> So if you wanted to match on the last element of a list and its first elements (in reverse order), you'd do: f (reverse -> x:xs) = ...
08:13:14 <Athas> I find that it often simplifies code.
08:13:39 <carpi> hmm.. thank you for the direction. i will look into it
08:13:54 <Tyr42> is there a general form of span?
08:14:07 <FUZxxl> ezyang: Okay. I start to code this and ask you again, if there are any problems. I try to figure it out.
08:14:24 <Tyr42> that takes a function to use on the collected elements instead of just (:)
08:14:45 <ezyang> Cool. It's actually a pretty interesting application of Prompt that could probably be usefully written up as a blog post or Haskellwiki page. 
08:15:21 <FUZxxl> okay. Where is the prompt library available, if any?
08:15:38 <ezyang> @package MonadPrompt 
08:15:38 <lambdabot> http://hackage.haskell.org/package/MonadPrompt
08:16:17 <FUZxxl> uuh... Good headache... 
08:16:23 <FUZxxl> *got
08:20:49 <FUZxxl> Another question: Isn't that fundep superfluous in MonadPrompt's definition?
08:21:38 <hpc> @src span
08:21:38 <lambdabot> span _ xs@[]                     =  (xs, xs)
08:21:38 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
08:21:38 <lambdabot>                   | otherwise    =  ([],xs)
08:21:44 <hpc> :t span
08:21:45 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:21:59 <ddarius> Other than fundeps implied by other fundeps, or blatantly tautological fundeps such as a -> a, no fundep is superfluous.
08:22:29 <ddarius> Tyr42: Why don't you just use foldr on the result?
08:23:12 <djanatyn> Man, guards in haskell are awesome
08:23:36 <FUZxxl> ddarius: Did you had a llok at the definition, I mean?
08:23:37 <hpc> @src otherwise -- my favorite part of guards
08:23:37 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:23:42 <hpc> @src otherwise
08:23:42 <lambdabot> otherwise = True
08:23:43 <hpc> :D
08:23:50 <Axman6> djanatyn: really? i almost never use them
08:23:58 <djanatyn> Axman6: Well, they seem awesome.
08:24:12 <Axman6> well, compared to what other languages have, sure
08:24:30 <djanatyn> I find myself making big if else trees using C
08:24:36 <djanatyn> It's like a switch, but cooler.
08:24:41 <djanatyn> Haskell code is so small ._.
08:25:12 <hpc> guards are for situations where you have heterogenous conditions, so you can't pattern match
08:25:32 <hpc> such as | foo == "abc" = blah; | bar == 5 = fuzz'
08:25:49 <janogonzalez> Hi I'm a Haskell newbie, learning to improve my Ruby code <- ORLY? // I think that learning a purely functional language will improve my coding skills in other languages
08:26:33 <Kaide> yes
08:26:58 <Athas> Probably true.
08:27:10 <Jafet> @faq Can Haskell improve on other languages?
08:27:10 <lambdabot> The answer is: Yes! Haskell can do that.
08:27:20 <janogonzalez> I just wanted to say that Haskell syntax is awesome. In ruby I wite (1..5).map { |n| n + 1 } and in Haskell I write map (+1) [1..5]
08:27:46 <hpc> > (+1) <$> [1..5]
08:27:47 <lambdabot>   [2,3,4,5,6]
08:27:47 <shachaf> > (+1) . [1..5]
08:27:49 <lambdabot>   [2,3,4,5,6]
08:27:55 <hpc> cheater :P
08:27:55 <shachaf> (Ignore that.)
08:27:56 <shachaf> (Ignore that.)
08:27:57 <ben> (1..5).map(&1.method(:+)) :)
08:27:57 <parcs> > [2..6]
08:27:59 <lambdabot>   [2,3,4,5,6]
08:28:19 <shachaf> ben: To be fair, that wouldn't work if + wasn't commutative.
08:28:36 <shachaf> @slap parcs
08:28:36 <lambdabot> stop telling me what to do
08:28:47 <Athas> > [ x+1 | x <- [1..5] ]
08:28:48 <lambdabot>   [2,3,4,5,6]
08:28:51 <hpc> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs -- hold onto your hat, janogonzalez
08:28:52 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:28:56 <ben> I suppose :(
08:29:01 <ben> Ruby does not do points-free very well
08:29:14 <ddarius> FUZxxl: Not recently, but the point of my statement is that a fundep can never be superfluous except in some gratuitous examples.
08:29:39 <Kaidelong> > let fibs = 1 : scanl 1 fibs in fibs
08:29:40 <lambdabot>   Couldn't match expected type `[t]'
08:29:40 <lambdabot>         against inferred type `[b] -> [a]'
08:29:47 <Kaidelong> > let fibs = 1 : scanl (+) 1 fibs in fibs
08:29:48 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
08:29:49 <shachaf> How about this:
08:29:50 <shachaf> >
08:29:51 <lambdabot> [2,3,4,5,6]
08:29:54 <hpc> >
08:30:01 <hpc> > 
08:30:02 <lambdabot>   not an expression: `'
08:30:06 <djahandarie> shachaf, ... was that a unicode space? :p
08:30:08 <hpc> wait, what?
08:30:54 <Lemmih> >
08:30:55 <lambdabot> [6,5,4,3,2]
08:31:07 <geheimdienst> :D
08:31:08 <Lemmih> Like that?
08:31:20 <shachaf> Lemmih: Yes, except I cheated even more than you.
08:31:29 <djahandarie> Actually, it wasn't a unicode space... you fools forgot to add two spaces before the output
08:31:49 <shachaf> djahandarie: More like lambdabot ignored the extra space.
08:31:52 <FUZxxl> ezyang: I found another solution: I could use generalized prepohistozygomorphisms
08:33:07 <ezyang> :-P 
08:33:37 <shachaf> FUZxxl: Wait, wait, why are you overabstracting? You don't need it to be generalized.
08:34:01 <int-e> preposterousisms?
08:34:11 <Jafet> @quote generalisation
08:34:11 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
08:34:20 <djahandarie> Haha
08:34:27 <sepp2k1>  
08:34:33 <shachaf> @quote generalization
08:34:34 <lambdabot> No quotes match. :(
08:34:36 <Jafet> @quote benmachine generalisation
08:34:36 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
08:35:02 <shachaf> Ah. That is true.
08:35:30 <shachaf> Presumably it even has the same implementation, just with a better type.
08:35:33 <hpc> lambdabot is not able to list quotes, yes?
08:35:48 <FUZxxl> hpc: There is a list somewhere at haskellWiki
08:35:54 <shachaf> hpc: They're on the website somewhere.
08:36:08 <ddarius> That's a somewhat different list.
08:36:12 <shachaf> State/Quote in lambdabot's repository, or something like that.
08:36:19 <parcs> @quote
08:36:20 <lambdabot> Itkovian says: my balls are large enough, thank you very much
08:36:44 <FUZxxl> @quote
08:36:45 <lambdabot> luite says: you lifted a pure value into your gastrointestinal system, and a while later performed an impure action with it?
08:36:49 <shachaf> @quotate
08:36:49 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
08:36:54 <FUZxxl> @quote
08:36:55 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
08:37:02 <FUZxxl> @quote
08:37:03 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files in Different Directories!"
08:37:10 <FUZxxl> @quote
08:37:10 <lambdabot> EdLin says: there's ##windows, but it's more of a support group than a support channel.
08:37:26 <parcs> heh that's a good one
08:37:32 <hpc> http://code.haskell.org/lambdabot/State/quote <- this is the list?
08:37:34 <djahandarie> I think most of these come from another channel.
08:37:45 <Lemmih> ?keal
08:37:45 <lambdabot> proofs are no longer sound
08:37:49 <shachaf> hpc: Or at least a version of the least.
08:37:50 <hpc> how do i open it?
08:38:12 <hpc> it's not in any format i recognize
08:38:19 <shachaf> gunzip
08:38:30 <shachaf> file(1) would recognize it. :-)
08:38:30 <hpc> ah, cool
08:38:54 <shachaf> Before gunzipping, that is. After gunzipping it says: quote: FORTRAN program
08:39:11 <shachaf> @keal! I'd forgotten about that.
08:39:11 <lambdabot> you need a Zh function in Haskell
08:39:40 <opqdonut_> @quote
08:39:40 <lambdabot> denq says: oh! something bing in my brain :)
08:41:14 <RayNbow> > (\(snd -> (snd -> a)) -> a) $ (1,(1,2))
08:41:15 <lambdabot>   2
08:41:20 <RayNbow> > (\(snd -> snd -> a) -> a) $ (1,(1,2))
08:41:21 <lambdabot>   <no location info>: parse error on input `->'
08:42:41 <pmetzger> @quote
08:42:42 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
08:42:42 <lambdabot>  but then I look at some java code and I'm all happy again
08:43:02 * shachaf wonders whether Maybe would be nicer if it was actually like Either String.
08:43:19 <Athas> No.
08:43:29 <Athas> Then you would have to specify a reason every time there is no value.
08:43:34 <parcs> or maybe Either (Maybe String)
08:43:36 <opqdonut_> people do use Error (Either String, that is) too little IMO
08:43:38 <shachaf> You wouldn't have to.
08:43:39 <Jafet> And the reason would have to be a String.
08:43:56 <shachaf> Fair enough, Either SomeError.
08:43:56 <opqdonut_> how about Either (Maybe String) then? :)
08:44:00 <Jafet> That isn't always communicative.
08:44:05 <Athas> Why not just use Either then?
08:44:16 <shachaf> Because people still use Maybe. :-)
08:44:32 <shachaf> All the functions that use Maybe leave no trace as to where the Nothing came from.
08:44:40 <Jafet> @hoogle a -> m a -> a
08:44:40 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
08:44:41 <lambdabot> Prelude asTypeOf :: a -> a -> a
08:44:41 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
08:44:55 <Jafet> @hoogle (m a -> a) -> a -> m a -> a
08:44:56 <lambdabot> No results found
08:45:08 <shachaf> @ty fail -- We even have this wonderful function in Monad!
08:45:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
08:45:22 <Athas> I'm trying to forget.
08:45:24 <Jafet> @hoogle b -> (a -> b) -> m a -> b
08:45:25 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
08:45:25 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
08:45:25 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
08:46:36 <Dr_H> hello
08:47:03 <Jafet> There's also abusing Maybe in do notation, do Cons x <- Just expr instead of case expr of Cons x -> ...; _ -> fail
08:47:47 <Lemmih>  > reverse [1,2,3]
08:47:49 <lambdabot>   [3,2,1,0]
08:48:27 <FUZxxl> ?
08:48:31 <djahandarie> Lemmih, you should have used a zero-width space
08:48:43 <FUZxxl> @bindings
08:48:43 <lambdabot> Unknown command, try @list
08:48:44 <Lemmih> djahandarie: Yeah, couldn't find it /-:
08:48:46 <FUZxxl> @list
08:48:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:49:05 <shachaf> > reverse [1,2,3]
08:49:06 <lambdabot>   [3,2,1]
08:49:09 <FUZxxl> :show bindings
08:49:16 <FUZxxl> @show bindings
08:49:16 <lambdabot> "bindings"
08:49:19 <FUZxxl> @help show
08:49:19 <lambdabot> show <foo>. Print "<foo>"
08:49:33 <shachaf> Wow. That's a useful command.
08:49:35 <shachaf> lambdabot++
08:49:43 <FUZxxl> @nop
08:49:44 <lambdabot> Maybe you meant: do map yow
08:49:47 <FUZxxl> @do
08:49:47 <lambdabot> ()
08:49:50 <FUZxxl> @help do
08:49:50 <lambdabot> do <expr>
08:49:50 <lambdabot> Translate Monad operators to do notation.
08:50:11 <shachaf> FUZxxl: (lambdabot isn't ghci. Some commands may seem related, but it's implemented completely differently.)
08:50:46 <FUZxxl> shacaf: I know.
08:51:03 <shachaf> (Also, you can experiment with her in /msg.)
08:52:47 <Dr_H> hello
08:52:59 <Axman6> hi?
08:53:15 <FUZxxl> shachaf: Is lambdabot female?
08:53:22 <shachaf> Of course.
08:53:26 <FUZxxl> :D
08:53:28 <Axman6> @vixen are you female?
08:53:28 <lambdabot> i truely am
08:53:31 <Dr_H> can somebody help me learn the (.) operator and the point-free conversion, please?
08:53:36 <FUZxxl> @help vixen
08:53:36 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
08:53:41 <FUZxxl> @vixen
08:53:42 <lambdabot> If something takes a lot of effort to do, it probably ain't worth doing.
08:53:52 <FUZxxl> @vixen are you female?
08:53:53 <lambdabot> i truely am
08:53:57 <FUZxxl> :D
08:54:02 <FUZxxl> Dr_H
08:54:04 <Axman6> Dr_H: (.) is a function just like any other
08:54:07 <Axman6> @src (.)
08:54:07 <lambdabot> (f . g) x = f (g x)
08:54:08 <lambdabot> NB: In lambdabot,  (.) = fmap
08:54:22 <FUZxxl> Dr_H: The dot is like gluing two functions together.
08:54:37 <FUZxxl> (.) = fmap wtf?
08:54:42 <Axman6> yes
08:54:47 <shachaf> FUZxxl: Exactly.
08:54:51 <opqdonut_> FUZxxl: nevermind the fmap
08:54:51 <Axman6> (+1) . [1..5]
08:54:55 <Axman6> > (+1) . [1..5]
08:54:57 <lambdabot>   [2,3,4,5,6]
08:55:00 <Axman6> > (+1) `fmap` [1..5]
08:55:00 <Dr_H> FUZxxl: how will f((g x) y) become ((f ,) . g) x y?
08:55:01 <lambdabot>   [2,3,4,5,6]
08:55:11 <Axman6> Dr_H: it won't...
08:55:25 <Axman6> although, if you make that , a . then i think it will
08:55:29 <Dr_H> sorry, that's supposed to be a dot as well
08:55:30 <shachaf> @pl \x y -> f (g x y)
08:55:30 <lambdabot> (f .) . g
08:55:47 <djahandarie> Classic #haskell : Someone asks a question, someone else tries to answer, but then it turns into a giant discussion about how (.) = fmap in lambdabot
08:56:26 <Zao> > 42 3
08:56:27 <lambdabot>   42
08:56:32 <opqdonut_> Dr_H: f (g x y) == (f . (g x)) y == ((f .) . g) x y
08:57:02 <opqdonut_> if that's any help
08:57:18 <FUZxxl> djahandarie: +1
08:57:35 <opqdonut_> you might want to compare it to (x + sin y) == (x +) . sin
08:57:54 <opqdonut_> err, (x + sin y) == ((x +) . sin) y
08:57:54 <FUZxxl> :t (.)
08:57:55 <FUZxxl> :t fmap
08:57:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:57:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:58:04 <Dr_H> opqdonut_: thank you, so basically (f . (g)) becomes ((f .) . g) ?
08:58:19 <Axman6> no...
08:58:22 <parcs> :t [fmap, Prelude..]
08:58:22 <shachaf> Dr_H: ...No, parentheses are just for grouping.
08:58:23 <lambdabot> parse error on input `]'
08:58:36 <Axman6> (f . (g)) == (f . g)
08:58:46 <opqdonut_> Dr_H: f . g x becomes ((f .) . g) x
08:58:57 <FUZxxl> But you should be careful.
08:59:06 <parcs> :t [fmap, (Prelude..)]
08:59:08 <lambdabot> forall a b a1. [(a -> b) -> (a1 -> a) -> a1 -> b]
08:59:11 <opqdonut_> Dr_H: just like h (g x) becomes (h . g) x
08:59:16 <opqdonut_> Dr_H: it's just that now h is (f .)
08:59:25 <Dr_H> is there any difference b/w ((f .) . g) and (f . g) ?
08:59:30 <opqdonut_> yes
08:59:52 <Axman6> :t ((?f .) .?g)
08:59:53 <lambdabot> Not in scope: `.?'
09:00:03 <Axman6> :t ((?f .) . ?g)
09:00:04 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?f::a -> b, Functor f, ?g::f1 (f a), Functor f1) => f1 (f b)
09:00:11 <Axman6> bah
09:00:17 <Axman6> god damnit Cale
09:00:26 <opqdonut_> Dr_H: you are confused by the two .s
09:00:34 <Dr_H> yes, I am... :)
09:00:35 <opqdonut_> Dr_H: remember my example (x + sin y) == ((x +) . sin) y
09:00:45 <Cale> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
09:00:57 <Kaidelong> @ty ((f .) . g)
09:00:57 <Cale> (f . g) x y = f (g x) y
09:00:58 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, SimpleReflect.FromExpr (f1 (f a)), Functor f1) => f1 (f b)
09:01:00 <Axman6> this is one of the reasons I've stopped helping people in here, because trying to demonstrate things using lambdabot is far too difficult
09:01:07 <Kaidelong> > ((f .) . g)
09:01:08 <lambdabot>   No instance for (GHC.Show.Show (f (f1 b)))
09:01:08 <lambdabot>    arising from a use of `M28156...
09:01:13 <parcs> Dr_H: (f .) . g implies that g is a -> b -> c and f is c -> d
09:01:16 <Kaidelong> ah I can't show those?
09:01:39 <parcs> Dr_H: f . g implies that g is a -> b and f b -> c
09:02:05 <Kaidelong> > ((min .) . min) 5 32 6
09:02:07 <lambdabot>   5
09:02:29 <ion> > let predFloat = uncurry encodeFloat . first pred . decodeFloat in take 6 . map (id &&& (-) <*> predFloat) . iterate (1000*) $ (1 :: Float) -- I was interested of the actual amount of inaccuracy of floats at various magnitudes, so: the difference between various 32-bit floats and the closest smaller float that can be encoded, respectively
09:02:30 <lambdabot>   [(1.0,1.1920929e-7),(1000.0,6.1035156e-5),(1000000.0,6.25e-2),(1.0e9,64.0),...
09:02:36 <Kaidelong> = ((min .) (min 5)) 32 6
09:02:44 <ion> ,(1.0e12,65536.0),(1.0e15,6.7108864e7)]
09:02:52 <Kaidelong> = min (min 5 32) 6
09:03:02 <Dr_H> > pl x y z w -> f (g x y) (h z (i w))
09:03:03 <lambdabot>   <no location info>: parse error on input `->'
09:03:17 <Dr_H> @pl x y z w -> f (g x y) (h z (i w))
09:03:17 <lambdabot> (line 1, column 9):
09:03:17 <lambdabot> unexpected ">" or "-"
09:03:17 <lambdabot> expecting variable, "(", operator or end of input
09:03:30 <Kaidelong> @pl \x y z w -> f (g x y) (h z (i w))
09:03:30 <lambdabot> flip flip ((. i) . h) . (((.) . (.) . f) .) . g
09:03:37 <Twey> > ((min .) . min) 5 32 6
09:03:38 <lambdabot>   5
09:03:56 <Dr_H> Kaidelong: thank you, I forgot the backslash
09:03:58 <Jafet> That's imprecision; inaccuracy is a whole 'nother thing
09:04:11 <ion> jafet: Ah, indeed.
09:04:17 <Kaidelong> essentially the ((f .) . g) thing is just a way to take advantage of currying
09:04:26 <Twey> > ((fmap fmap fmap) min min) 5 32 6
09:04:27 <lambdabot>   5
09:04:34 <Kaidelong> to let something consume an argument before being composed
09:04:44 * shachaf wonders at Twey's parentheses.
09:04:51 <djahandarie> > minimum [5,32,6] -- thanks, but no thanks
09:04:51 <lambdabot>   5
09:04:56 <Twey> Heheh
09:04:58 <parcs> > (min .: min) 5 32 6
09:05:00 <lambdabot>   5
09:05:10 <Kaidelong> @info (.:)
09:05:10 <lambdabot> (.:)
09:05:13 <Jafet> I want a DSL to chain combinators with ascii art flowcharts
09:05:13 <Twey> (.:) = fmap fmap fmap
09:05:17 <Kaidelong> Helpful
09:05:26 <shachaf> Cale: When are you going to make lambdabot's map be fmap?
09:05:27 <ion> (.:) = (.).(.)
09:05:38 <djahandarie> Twey,  fmap . fmap  would be clearer.
09:05:40 <parcs> la
09:05:42 <Kaidelong> it isn't already?
09:05:48 <ion> :t map
09:05:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:06:01 <Twey> djahandarie: I enjoy seeing how many things can be replaced by various applications of ‘fmap’.
09:06:06 <Kaidelong> @ty map reverse getLine
09:06:07 <lambdabot>     Couldn't match expected type `[[a]]'
09:06:07 <lambdabot>            against inferred type `IO String'
09:06:07 <lambdabot>     In the second argument of `map', namely `getLine'
09:06:08 <Twey> It generally turns out to be quite a lot.
09:06:12 <Kaidelong> ah it isn't
09:06:41 <FUZxxl> @hackage base
09:06:41 <lambdabot> http://hackage.haskell.org/package/base
09:06:54 <ddarius> Twey: Imagine what you could do with arbitrary categorical functors?
09:06:58 <ddarius> s/?/./
09:07:33 <shachaf> > fmap fmаp fmaр
09:07:35 <lambdabot>   "Welcome to fmapcom. Anything is possible at fmapcom. The only limit is you...
09:07:51 <Lemmih> Is what?
09:08:09 <Dr_H> @pl \x y z  -> while (less_than x y) (multiply z (post_decrement y))
09:08:10 <lambdabot> (`ap` (flip multiply . post_decrement)) . (((.) . while) .) . less_than
09:08:15 <shachaf> Lemmih: We'll never know.
09:08:39 <Dr_H> is there any tutorial for this algorithm?
09:09:08 <Axman6> Dr_H: there shouldn't be, it seems you're trying to force imperative ideas on haskell, and this is a bad idea
09:09:19 <FUZxxl> > fmap fmаp fmaр
09:09:20 <lambdabot>   Not in scope: `fm
09:09:30 <Dr_H> sorry
09:09:35 <FUZxxl> :t а 
09:09:36 <lambdabot> <no location info>: not an expression: `'
09:09:42 <FUZxxl> :t аp
09:09:43 <lambdabot> <no location info>: not an expression: `'
09:09:45 <Kaidelong> hmm
09:09:48 <FUZxxl> :info аp
09:09:57 <FUZxxl> @info аp
09:09:58 <Kaidelong> that's pretty straightforward to write in haskell
09:09:58 <lambdabot>   p
09:09:58 <parcs> > τ
09:10:01 <lambdabot>   6.283185307179586
09:10:04 <Jafet> @type ap
09:10:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:10:08 <Jafet> :t ap
09:10:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:10:26 <Kaidelong> except, Dr_H
09:10:31 <Kaidelong> what is that supposed to return
09:11:06 <Kaidelong> I expect it is one of x, y, or z
09:11:15 <Dr_H> a sort of factorial implementation, and yes, I'm trying an approach from the imperative way
09:11:45 <Kaidelong> so you want to return z
09:11:52 <Kaidelong> does z have an initial value?
09:11:55 <Kaidelong> or any of the others
09:12:06 <Dr_H> x is 1
09:12:36 <Dr_H> I'd like to know the algorithm to condition my brain and write tacit code
09:12:39 <Kaidelong> if you want factorial you may as well just do "product . enumFromTo 1"
09:12:46 <Kaidelong> if this isn't factorial
09:12:53 <Axman6> Dr_H: trying to do things your imperative way will likely mean you need mutation, which is not what you're going to get in that sort fo haskell code
09:13:16 <Kaidelong> then well, x is 1, and you return... z?
09:13:25 <Axman6> > let factorial n = product [1..n] in factorial 1000
09:13:25 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
09:13:37 <TheZimm> oh god
09:13:42 <Kaidelong> > product . enumFromTo 1 $ 1000
09:13:44 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
09:13:49 <TheZimm> does haskell know the idea of infiniti?
09:13:49 <shachaf> Evolution of a Haskell Programmer doesn't have an imperative version of the algorithm!
09:14:01 <shachaf> TheZimm: Haskell knows nothing.
09:14:02 <shachaf> > 1/0
09:14:02 <Kaidelong> TheZimm: IEEE floating points do
09:14:03 <lambdabot>   Infinity
09:14:10 <kmc> it's missing a lot of possibilities shachaf
09:14:16 <Dr_H> Kaidelong: yes, z is an accumulator which is supposed to contain the result
09:14:21 <TheZimm> :D
09:14:28 <Axman6> Dr_H: but z can never change
09:14:32 <Rotaerk> > 0/0
09:14:32 <lambdabot>   NaN
09:14:34 <kmc> i wanted to contribute some, but i don't think it's maintained
09:14:51 <kmc> > let x = 0/0 in x == x
09:14:52 <lambdabot>   False
09:14:57 <TheZimm> is there a library/package out there for like limits?
09:15:05 <Kaidelong> Dr_H: I am sure what you did is just factorial then, anyway, but I'll translate it for you so that you can see
09:15:05 <TheZimm> limit as x approaches infinity....
09:15:10 <Rotaerk> 1/0 should also be NaN... zero infinities isn't 1
09:15:14 <djahandarie> kmc, could just move it over to the wiki
09:15:39 <Axman6> Rotaerk: not in IEEE754
09:16:08 <Dr_H> Axman6: input variables should never change, and the result should be the evaluated value of the function itself and not a mutable parameter? Is this the concept?
09:16:17 <Rotaerk> that standard is wrong then
09:16:25 <kmc> lim_{x → 0} 1/x = ∞
09:16:45 <Rotaerk> sure, the limit approaches infinity
09:16:46 <kmc> that's what they're getting at
09:17:01 <TheZimm> kmc wait wait is that in haskell?
09:17:02 <kmc> floating point is mathematically "wrong" in about two hundred ways
09:17:06 <kmc> no TheZimm
09:17:22 <TheZimm> lol true datttt
09:17:23 <Axman6> Rotaerk: it's also extremely popular and highly supported, as well as being extremely useful for most situations where 'real' numbers are needed
09:17:27 <Kaidelong> http://hpaste.org/46015/translation
09:17:30 <Kaidelong> Dev_HC
09:17:32 <Kaidelong> that's for you
09:17:38 <Rotaerk> although lim_{x -> 0} 0/x = 0
09:17:57 <Axman6> Dr_H: not that they should never change, they cannot change
09:18:00 <kmc> Rotaerk, one implicitly assumes that all the 0's are reached by limits
09:18:02 <Kaidelong> you'll define "fact 1" to get the default value 1 although really, you could just get rid of 1 atogether
09:18:05 <Axman6> you compute new values
09:18:09 <Kaidelong> x altogether*
09:18:11 <kmc> so IEEE's 0/0 is lim_{x → 0) x/x
09:18:14 <Kaidelong> and replace x with literal 1s
09:18:16 <kmc> which is undefined
09:18:43 <Jafet> Rotaerk: it's very wrong and very fast, like a biker.
09:18:46 <TheZimm> lim_{x->infinity} (1-1/x)^x = ? anybody anybody? :P
09:18:50 <Kaidelong> I wonder if you can come up with a formal system where 0/0 is a value you can work with
09:18:51 <Dr_H> Axman6: I see, thank you
09:18:59 <shachaf> kmc: Isn't lim_{x -> 0} 1/x also undefined?
09:19:22 <kmc> shachaf, you have to pick whether x approaches from positive or negative, i guess
09:19:22 <TheZimm> shachaf correct
09:19:30 <Kaidelong> shachaf: well there isn't a limit, so yeah
09:19:34 <TheZimm> its DNE
09:19:44 <Jafet> And defies any kind of algebraic categorization, and forms a disturbingly small subset of dyadic rationals...
09:19:46 <TheZimm> different right and ;eft hand behaviors
09:19:56 <TheZimm> xD
09:20:12 <Jafet> It should be associative, though. I'm not sure.
09:20:15 <TheZimm> btw, my little limit up there was in fact e
09:20:19 <kmc> but, if x approaches from positive then you are sure that eventually 1/x > k for any finite k
09:20:37 <TheZimm> yes
09:20:37 <kmc> which is the point of signed infinities in IEEE floating point
09:20:43 <doserj> TheZimm: it was 1/e, not e
09:20:48 <Dr_H> actually, I'm trying to find an abstract concept which is to aggregate imperative and declarative approach as well
09:21:02 <Kaidelong> signed infinities let you make a sigmoid work like a signum!
09:21:03 <TheZimm> doserj hm did i get the limit wrong? i thought that was e
09:21:06 <Kaidelong> which is kind of cool
09:21:53 <TheZimm> doserj no im pretty sure thats e
09:21:58 <TheZimm> oh shit
09:22:02 <TheZimm> + not - :P
09:22:03 <Axman6> Dr_H: i would suggest you try learning haskell the haskell way first, and move onto trying to emulate other ideas once you're much more familiar with the language
09:22:07 <kmc> if we're doing 1/f(x) then occasionally f might get small enough that the expression reduces to Infinity, but we'd still like it to compare greater than finite numbers
09:22:38 <Kaidelong> Axman6: what he wrote actually was pretty idiomatic haskell in disguise
09:23:03 <Axman6> well, assuming there's something recursive in there, then it could well be
09:23:06 <Kaidelong> you just have to use a goto
09:23:16 <Dr_H> Axman6: thank you, I'm on it :)
09:23:28 <Axman6> Dr_H: are you following a tutorial?
09:23:36 <TheZimm> haskell is great yourll love it, Dr_H
09:24:08 <TheZimm> one day i set out to make a package that could do integrals....
09:24:12 <TheZimm> then i gave up xD
09:24:59 <Dr_H> besides the trendy imperative languages (C, PHP and Perl) I know some Prolog and I used to learn some SML, but neither got to Haskell nor Lisp yet
09:25:01 <ezyang> moar comix! http://blog.ezyang.com/2011/04/io-evaluates-the-haskell-heap/ 
09:25:03 <Jafet> system $ "/usr/local/bin/mathematica" : args
09:25:16 <danharaj> I wouldn't call C trendy.
09:25:36 <shachaf> ezyang: You should do The C Heap next.
09:26:01 <ezyang> That wouldn't be... particularly interesting ^_^ 
09:26:03 <Dr_H> danharaj: trendy in the way that all the trendy languages' syntax (Java, C#, Perl, PHP, Bash etc.) are based on C's own
09:26:04 <shachaf> ezyang: "So, there's some memory. Ayup."
09:27:00 * ddarius wouldn't call any of those three languages "trendy."
09:27:18 <Axman6> me either
09:27:22 <shachaf> ddarius: What would you call "trendy"?
09:27:29 <Axman6> Haskell!
09:27:57 <Dr_H> sorry, I didn't mean to hurt anybody's feelings
09:28:17 <jmcarthur> are the postconditions of decodeFloat intended to also be preconditions of encodeFloat?
09:30:22 <Axman6> > 2^31-1
09:30:23 <lambdabot>   2147483647
09:31:25 <danharaj> Repa is extremely tempermental when it comes to laziness isn't it :\
09:31:41 <jmcarthur> repa is strict
09:31:51 <danharaj> Apparently not.
09:31:55 <jmcarthur> oh?
09:32:22 <Kaidelong> C# is still trendy for people coming from Java
09:32:25 <danharaj> I had to litter some code with "deepSeqArray $ force $" to make it not grind to a halt.
09:32:44 <danharaj> I'm sure it's because I'm "Doing it Wrong"
09:32:48 <jmcarthur> danharaj: force introduces sharing, not strictness
09:33:09 <kmc> C, PHP, Perl are popular but not "trendy"
09:33:13 <kmc> if anything their popularity is waning
09:33:16 <danharaj> jmcarthur: Yes, but without the DeepSeqArray, I get a runtime warning every frame.
09:33:34 <danharaj> Data.Array.Repa: Performing nested parallel computation sequentially.   You've probably called the 'force' function while another instance was  already running. This can happen if the second version was suspended due  to lazy evaluation. Use 'deepSeqArray' to ensure that each array is fully  evaluated before you 'force' the next one.
09:33:42 <kmc> trendy languages include JavaScript (i hear it has closures!!!) and probably Objective C thanks to apple
09:33:43 <jmcarthur> danharaj: ah, well that makes some sense for force to be one of the few lazy operations i guess
09:34:14 <danharaj> jmcarthur: Should I not feel bad that I have to explicitly specify sharing to make certain kinds of code not explode?
09:34:15 <shachaf> kmc: Pah, closures. jQuery is a *monad*!
09:34:23 <jmcarthur> ezyang: btw, if i understand your email on mailing list correctly, conal and i have called what you are talking about "unobservable mutation"
09:34:23 <danharaj> Because I go from real time to grinds to a halt without the forces :p
09:34:28 <jmcarthur> *on the
09:34:43 <jmcarthur> danharaj: repa is designed to work that way
09:34:45 <ion> Perl has closures, too! And syntactic sugar for closure function parameters!
09:35:12 <danharaj> jmcarthur: Ok. Good to know. There's not a programming guide, although dons has tasked me with writing a tutorial on the wiki. Collecting notes as I go.
09:35:17 <saati> can someone point me to a relatively simple program source what is doing i/o based on a global state?
09:35:34 <shachaf> saati: Why do you want such a thing?
09:36:05 <saati> i'm thinking about implementing some relatively simple multiplayer game
09:36:14 <ddarius> ...
09:36:25 <jmcarthur> doesn't mean you need global state
09:36:30 <Axman6> you don't need global state for that
09:36:38 <danharaj> Do you mean threaded state?
09:36:54 <danharaj> (as in you thread some value through a sequence of computations)
09:38:24 <Kaidelong> saati: I did one of those based on timestamped interactions forcing recalculation of the game up to the current point in time from when the other user last took their action
09:38:58 <Kaidelong> so the game state provided a function from time -> some output
09:39:06 <Kaidelong> and interactions change the game state
09:39:16 <Kaidelong> IE button_up, button_down etc
09:39:39 <Kaidelong> that might cover what you need
09:40:06 <saati> oh i dont want to write the client in haskell
09:40:10 <saati> but thanks
09:40:20 <saati> i think i understand now how it should be done
09:44:28 <cheater99> if i have a function which is a bijection in haskell, can i find f^-1?
09:46:35 <Jafet> In Haskell? Is that at all significant?
09:48:43 <danharaj> Jafet: If the language can talk about propositions, and it has the proposition that f is a bijection, then wouldn't the proof (which you'd have to supply) be able to tell it how to construct f^-1?
09:48:53 <danharaj> (assuming intuitionistic logic)
09:49:23 <Jafet> I hope that's a rhetorical question, because I have no idea
09:51:57 <danharaj> Jafet: welcome to my world.
09:52:15 <Boxo> cheater99: not automatically
09:52:40 <cheater99> what language can i do it in automatically? or alternatively what technique do i need to use?
09:52:49 <danharaj> Coq or Agda might be able to do it.
09:52:53 <danharaj> I'm not sure.
09:53:36 <Jafet> I suspect cheater is thinking about a much narrower class of (bijective) functions
09:53:37 <koeien> cheater99: it is possible
09:54:02 <Jafet> Like elementary functions
09:54:24 <koeien> data Bij a b = Bij { fun :: a -> b; inv :: b -> a }
09:54:40 <cheater99> koeien: what about without the nasty code duplication?
09:55:05 <Dr_H> I must admin: Haskell is one of the most awesome languages ever met
09:55:14 <Dr_H> that's admiT
09:55:23 <koeien> cheater99: not completely avoidable I think, you will need to do some initialization
09:55:40 <Jafet> cheater: what kinds of functions do you have in mind?
09:55:40 <koeien> as soon as you do basic functions, you can make a combinator to compose them
09:55:46 <adamvh> Dr_H: Actually, I wouldn't mind if you'd "admin" that somehow
09:55:49 <cheater99> Jafet: any sort of bijections.
09:56:05 <adamvh> Dr_H: "First Minister of Haskell" or somesuch
09:56:09 <cheater99> koeien: i think if we can have the Y combinator and tco, we can have function inverses too
09:56:16 <Jafet> That sounds too general for you to get a really useful answer...
09:56:27 <Dr_H> adamvh: what do you mean? :)
09:56:36 <danharaj> If you have a constructive proof of bijection, you should be able to extract an inverse from that proof.
09:56:44 <cheater99> Jafet: do you see a subclass where the question is clearer?
09:57:33 <adamvh> Dr_H: I find administering the awesomeness of Haskell a funny notion
09:57:46 <Jafet> Numerical functions, monotone functions... almost anything you'd write in the real world, probably
09:57:52 <Dr_H> OIC :)
09:58:04 <adamvh> Dr_H: Like, there's a lot of paperwork involved with being awesome or something
09:58:47 <applicative> adamvh, I don't compiler writing seems more gruesome than standard paper-shuffling...
09:58:47 <lambdabot> applicative: You have 1 new message. '/msg lambdabot @messages' to read it.
09:59:02 <ziman> well, as long as the function is total, the inverse is doable. :)
10:00:01 <Jafet> What if the inverse isn't
10:00:48 <ziman> it may not be; the inverse may loop indefinitely for some inputs
10:01:04 <ion> inv (*0) (42*0)
10:01:36 <ion> @djinn (a -> b) -> b -> a
10:01:37 <lambdabot> -- f cannot be realized.
10:02:13 <Dr_H> I'm doing research with an abstract language: abstract concept combining imperative and declarative, with its elements being another abstract concept combining that of class, field, value and function.
10:03:19 <KirinDave> Sounds abstract.
10:03:25 <Dr_H> yea :)
10:04:31 <cheater99> aren't all bijections total?
10:05:28 <Cale> cheater99: Typically by default all functions are total
10:05:46 <cheater99> then why wouldn't the inverse of a bijection be total?
10:05:55 <Cale> It would be total
10:06:00 <cheater99> ok
10:06:20 <cheater99> i cannot see a bijection's inverse ever bottoming out
10:06:53 <ziman> > let inv f x = filter ((==x).f) [0..] in inv (+5) 20 
10:06:54 <Cale> Oh, right, this is #haskell, I have to put on my CS hat...
10:06:57 <lambdabot>   mueval-core: Time limit exceeded
10:07:18 <cheater99> Cale: your robe and wizard hat?
10:07:19 <ziman> > let inv f x = head $ filter ((==x).f) [0..] in inv (+5) 20 
10:07:21 <lambdabot>   15
10:07:35 <Cale> cheater99: It's conceivable that there are computable bijections whose inverse is not computable.
10:07:57 <Cale> (at least, I can't think of a good reason at the moment why those shouldn't exist)
10:08:16 <cheater99> what is an example of such a bijection?
10:08:20 <djahandarie> Proof by lack of proof.
10:08:43 <cheater99> djahandarie: i'm with Cale on this one.
10:09:00 <Cale> Well, there's a difference between conceivably existing and actually existing ;)
10:09:14 <Cale> Let's see...
10:10:09 <cheater99> :)
10:11:32 * djahandarie is for some reason reminded of "Probability Theory: The Logic of Science" by E.T. Jaynes
10:12:23 <cheater99> here's a use case
10:12:49 <cheater99> i write something that parses xml to json, i want the json -> xml to happen automatically
10:13:47 <ziman> well if you restrict yourself on the functions N -> N, the inverse of a total bijection can be computed simply by trying all possibilities (and terminating in finite time), can't it?
10:14:07 <cheater99> i don't think that's anywhere near being useful
10:14:27 <nschoe> hi back. Is there a way for my emails sent via Network.Mail.Mime lib not to be considered as junk? I believe the lib uses postfix to send the emails, so should I configure postfix to relay mails to my FAI's SMTP server?
10:14:29 <cheater99> btw, the probability that such a function terminates is equal zero
10:14:31 <ziman> no doubts about that. I'm just talking about computability, not usability...
10:14:57 <Dr_H> cheater99: except if you have infinite quantum threads which do it for you in constant time
10:16:41 <aristid> djahandarie: is it a good book?
10:17:03 <adamvh> @pl \(x,y) -> (show x) ++ " [label=" ++ (show y) ++ "]"
10:17:03 <lambdabot> uncurry ((. ((" [label=" ++) . (++ "]") . show)) . (++) . show)
10:17:11 <adamvh> well screw that
10:17:24 <djahandarie> aristid, yes actually. Only good exposition of probability theory I've ever seen
10:17:27 <Cale> ziman: ah, okay, that seems sensible
10:18:34 <aristid> djahandarie: from the name, it appears to be somewhat philosophical?
10:19:03 <djahandarie> Not sure what you mean by philosophical.
10:19:11 <KirinDave> The examples of point free style on wikipedia are freaking me out.
10:19:14 <KirinDave> (f .) . g
10:19:18 <KirinDave> I do not even.
10:19:27 <djahandarie> It's down-to-earth and rigorous.
10:19:29 <Cale> KirinDave: (f .) is a section
10:19:34 <Cale> (f .) g = f . g
10:19:40 <Cale> (operator section)
10:19:42 <alpounet> (f .) . g is actually simple
10:19:46 <alpounet> @unpl (f .) . g
10:19:46 <lambdabot> (\ d i -> f (g d i))
10:20:01 <Cale> Similar to how (5 +) is the function which adds 5 to its argument
10:20:01 <KirinDave> Yeah I'm just trying to figure out the rules for reading it.
10:20:10 <KirinDave> I'm not used to the notation when combined that way. Particularly with .
10:20:10 <Cale> ((f .) . g) x y
10:20:15 <adamvh> KirinDave: Like the one I just put in
10:20:19 <adamvh> gah!
10:20:21 <Cale> = ((f .) (g x)) y
10:20:28 <Cale> = (f . g x) y
10:20:33 <Cale> = f (g x y)
10:20:41 <KirinDave> Doesn't it require knowledge of how many arguments g takes?
10:20:45 <Cale> no
10:20:49 <parcs> KirinDave: plug in one argument then simplify then repeat
10:21:00 <Cale> All functions take exactly one argument, really ;)
10:21:02 <ziman> there's a blog post discussing multiple (((.) .) .) levels somewhere, quite neat
10:21:14 <KirinDave> ziman: I'd love to see.
10:21:20 <KirinDave> Cale: I get that part
10:21:25 <shachaf> Concatenative languages don't have to go through this mess!
10:21:37 <Dr_H> KirinDave: the implementation body of g has to handle the number of arguments, not another function which is calling g
10:21:43 <Cale> I think the right way to look at it is to see (f .) as being like fmap f -- it applies f to all the results of the function that it's applied to.
10:21:49 <parcs> in this case ((f .) . g) x = f . g x … and (f . g x) y = f (g x y)
10:21:57 <Cale> So (f .) . g is the same as  fmap f . g
10:22:15 <adamvh> @pl h (x, y) = f x ++ g y
10:22:15 <lambdabot> h = uncurry ((. g) . (++) . f)
10:22:24 <adamvh> that's not so bad
10:22:40 <Dr_H> I wish I had lambdabot's brain... :D
10:22:42 <KirinDave> What's uncurry?
10:22:57 <Cale> uncurry f (x,y) = f x y
10:22:58 <azaq23> @src uncurry
10:22:59 <lambdabot> uncurry f p = f (fst p) (snd p)
10:23:04 <KirinDave> Ahh
10:23:05 <Dr_H> or lambdabot running in mine
10:23:06 <KirinDave> Neat
10:23:20 <sshc> Are there any category theory experts in here?  If you have time and are willing to help me, I have a question.  I'm reading "A Gentle Introduction to Category Theory—the calculational approach" (Maarten M. Fokkinga 1994), and I'm reading about pre-categories, which are just categories except without the unique-type requirement (f : A → B and f : A' → B'   ⇒   A = A' and B = B')
10:23:36 <Cale> sshc: okay
10:23:58 <sshc> "Quite often we shall encounter data that form a pre-category. By a simple trick, those data also determine a category: take multiple copies of the morphisms and make them distinct by incorporating a “source” and “target” into them. Formally, let A be a pre-category, and define B by: an object in B is an object in A; a morphism in B is a triple (A, f, B) with f : A →A B (that last A is
10:24:03 <sshc> sub-script); …"
10:24:19 <sshc> My question is: how can the morphism of B be a triple / three-tuple?  In that context, shouldn't the morphism of B be a function?
10:24:35 <Cale> morphisms can be anything
10:24:37 <sshc> I also have another, simple question: what does that syntax, particularly the subscripting, designate, in "f : A → <subscript>A</subscript>B"?
10:24:53 <djahandarie> sshc, note there is a ##categorytheory now
10:24:56 <Cale> The definition of a category does not say anything about what the objects and morphisms actually are
10:25:06 <adamvh> why is "uncurry" named what it is named?
10:25:25 <adamvh> I thought currying was partial application, so why is "uncurry" the reverse of that?
10:25:33 <shachaf> Currying isn't partial application.
10:25:42 <Cale> adamvh: The process of turning a function of pairs into a function that produces another function is called currying (after Haskell Curry)
10:25:43 <Dr_H> curry is a syntactic sweetener
10:25:45 <shachaf> Currying is what curry does.
10:25:47 <shachaf> @ty curry
10:25:48 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:25:59 <shachaf> uncurry does the opposite of that.
10:26:01 <adamvh> ah
10:26:04 <Cale> currying is not partial application
10:26:13 <parcs> :t uncurry ((++) <*> f <$> g)
10:26:15 <lambdabot> forall b c a. (Monoid c, Show (b -> c), Show b, SimpleReflect.FromExpr c, Show a) => (a, b) -> c
10:26:18 <Cale> partial application is the process of applying a function to some of its parameters to get another function
10:26:32 <sshc> "< Cale> The definition of a category does not say anything about what the objects and morphisms actually are" I see, thanks.  I'll still try to understand its definition.
10:26:33 <adamvh> So Haskell functions are basically all curried C functions, kinda
10:26:33 <Cale> currying is turning a function of tuples into a function which produces another function
10:26:36 <shachaf> Partial application should just be called "application", really.
10:26:50 <KirinDave> Waiit.
10:26:50 <sshc> Cale: Could you explain what the subscripting syntax designates?
10:26:54 <KirinDave> <*> and <$> in that order?
10:27:01 <KirinDave> I've only ever seen <$>
10:27:07 <KirinDave> But I guess.. if you're dealing with functions...
10:27:17 <KirinDave> If you start with a function you don't need <$>
10:27:18 <aristid> <$> is an alias for fmap
10:27:26 <KirinDave> Man, functions are a weird applicative functor instance.
10:27:30 <Cale> sshc: are some of those A's and B's in a different font?
10:27:51 <Cale> KirinDave: Not that weird :)
10:27:57 <sshc> Cale: Yes, sorry
10:27:59 <ziman> KirinDave, sorry, I seem to be unable to find it
10:28:02 <Cale> KirinDave: Are you familiar with the SK calculus?
10:28:11 <Cale> (or SKI calculus)
10:28:16 <KirinDave> Cale: I mean I know of it and can probably muddle out the combinators on a sheet of paper.
10:28:21 <Cale> okay
10:28:24 <sshc> Cale: It's hard to tell what the result of pasting to irssi is when I use a 6pt font
10:28:28 <KirinDave> Cale: I never really saw any reason to keep it in my head as a mental tool.
10:28:29 <Cale> so <*> is S and pure is K :)
10:28:50 <KirinDave> See I've heard that before but... :)
10:28:58 <sshc> Cale: It's an e-book that's freely available.  I can give you the link for the .pdf if you want
10:29:07 <Cale> sshc: That would be great
10:29:16 <sshc> http://wwwhome.cs.utwente.nl/~fokkinga/mmf92b.pdf
10:29:22 <KirinDave> Sorry, I was raised in a tradition of OO programers. My FP fundamentals are woefully inadequate.
10:29:26 <sshc> (I'm on page 11)
10:29:27 <KirinDave> I'm trying to fix that.
10:29:31 <Cale> sshc: also, I can give you Awodey's book, which is my favourite text
10:29:39 <Dr_H> KirinDave: welcome to the club :)
10:29:57 <shachaf> Cale: Which book is that?
10:29:58 <Cale> KirinDave: That's cool, I only mention it in the case that it's something you've bumped into
10:30:11 <Cale> shachaf: Awodey "Category Theory"
10:30:16 <aristid> @src (->) fmap
10:30:16 <lambdabot> fmap = (.)
10:30:18 <KirinDave> K I get, and I've even used it in everyday programming (under a different name, of course)
10:30:22 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
10:30:23 <KirinDave> S, is to me, more esoteric.
10:30:24 <aristid> @src (->) (<*>)
10:30:24 <lambdabot> (<*>) f g x = f x (g x)
10:30:27 <sshc> Cale: Thanks :)
10:30:33 <aristid> @src (->) pure
10:30:33 <lambdabot> pure = const
10:30:50 <aristid> that's all you need to know about the Applicative instance for functions.
10:30:55 <Cale> Let's actually understand the function applicative via the function monad :)
10:31:11 <aristid> Cale: yay!
10:31:16 <aristid> @src (->) (>>=)
10:31:16 <lambdabot> f >>= k = \ r -> k (f r) r
10:31:34 <Cale> The idea here is that we're supplying an extra parameter to all the functions involved, kind of like a global environment which is distributed to all the parts of the computation
10:31:44 <beastaugh> these notes on topos theory are quite good as an introduction too
10:31:45 <beastaugh> http://bristol.academia.edu/RichardPettigrew/Teaching/14380/Introductory_notes_on_topos_theory
10:31:54 <Cale> > (do x <- id; y <- reverse; z <- map toUpper) "hello"
10:31:54 <lambdabot>   <no location info>:
10:31:55 <lambdabot>      The last statement in a 'do' construct must be an ...
10:32:03 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
10:32:03 <lambdabot>   ("hello","olleh","HELLO")
10:32:05 <Cale> oops :)
10:32:12 <aristid> @src Identity (>>=)
10:32:13 <lambdabot> m >>= k  = k (runIdentity m)
10:32:38 <Cale> So, here you see that "running" each function is done by supplying the parameter which the whole computation was applied to
10:32:40 <Cale> yeah?
10:32:45 <KirinDave> Yeah
10:32:59 <KirinDave> Which I get since that gets to be strung out as a series of >>='s
10:33:38 <KirinDave> Which keep rolling the "hello" from instance to instance and builds up a closure over the previous runs
10:33:50 <Cale> now,  f <*> g   is like  do u <- f; v <- g; return (u v)
10:34:11 <KirinDave> What's return in this context?
10:34:19 <c_wraith> const
10:34:24 <geheimdienst> > (Just succ) <*> (Just 4)
10:34:25 <lambdabot>   Just 5
10:34:29 <Cale> yeah, return makes a constant function
10:34:43 <Cale> and the result of the do-block is the result of the last function in it
10:34:49 <KirinDave> Okay
10:35:04 <ion> I find it easy to figure out what <*> does for (a ->) based on the type of (<*>).
10:35:07 <ion> :t (<*>)
10:35:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:35:12 <Cale> so even the return (u v) will be supplied the parameter "hello", but it will ignore it, because it's a constant function :)
10:35:21 <ion> Substitute f with (c ->).
10:35:28 <Cale> yeah, looking at the type is also helpful
10:35:35 <ion> (c -> a -> b) -> (c -> a) -> c -> b
10:35:35 <KirinDave> yeah that's usually what I do
10:35:39 <Cale> (e -> a -> b) -> (e -> a) -> (e -> b)
10:35:47 <Cale> there are not so many functions of that type
10:35:48 <KirinDave> I have accumulated a reserve supply of :t's for ghci.
10:36:16 <Cale> Another thing worth noting for enrichment's sake
10:37:01 <Cale> The types of pure and <*> for the function instance here, if thought of as logical statements, with -> being read as "implies"
10:37:02 <KirinDave> I love riches, so enriches must be even better.
10:37:22 <Cale> are axioms for the intuitionist fragment of implicational logic
10:37:35 <azaq23> KirinDave: You might like hoogle
10:37:57 <vegai> 6g
10:37:57 <_Ray_> Definitely insane. :s
10:37:58 <Cale> If we add callCC :: ((a -> b) -> a) -> a, also known as Peirce's law, then we get classical implicational logic
10:38:11 <aristid> :t callCC
10:38:12 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
10:38:21 <KirinDave> azaq23: People who have been stockpiling :'s and t's have also bought: books on category theory, hoogle, and hugboxes.
10:38:34 <aristid> Cale: that is callCC for Identity?
10:38:39 <Cale> yeah
10:38:54 <Cale> (which doesn't exist in Haskell)
10:38:54 <aristid> i didn't know Identity was in MonadCont
10:39:02 <Cale> You need first class continuations for that
10:39:05 <aristid> @instances MonadCont
10:39:06 <lambdabot> ContT r m, ErrorT e m, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
10:39:11 <Cale> (which break referential transparency)
10:39:32 <aristid> @src Cont
10:39:32 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
10:39:39 * _Ray_ is having issues such that, since he added the west exit after adding the north exit, south(north(room)) has no 'west' exit, even though it's supposed to be == room, and room itself does have a west exit.
10:39:43 <Cale> sshc: I hate the notation of this book already ;)
10:39:58 * _Ray_ thinks he still needs portals to think in.
10:40:13 <Cale> sshc: But okay...
10:40:25 <ion> The third parameter (of type c) obviously goes to the first (c -> a -> b) and the second parameter (c -> a), and the result of the second parameter (of type a) goes to the first as well (c -> a -> b), and the return value of <*> (… -> b) is the return value of the first parameter (c -> a -> b). It doesn’t take long to come up with (f <*> g) x = f x (g x) based on that reasoning.
10:40:58 <KirinDave> _Ray_: What's your code look like so far?
10:41:11 <Cale> sshc: The subscripts are to help remind you which category the arrows and other objects are in
10:41:14 <KirinDave> _Ray_: This is why I planned to generate a hash table.
10:41:30 <_Ray_> Yeah, but I wanted to try to do it purely with recursion :)
10:41:32 <Cale> sshc: ;_A is composition in the category A
10:41:35 <aristid> Cale: if you have first-class continuations, is it like you have all code packed in ContT?
10:41:36 <KirinDave> _Ray_: Ahh, so a thing about that. 
10:41:38 <Cale> for instance
10:41:51 <Cale> aristid: sort of :)
10:42:00 <_Ray_> KirinDave: http://hpaste.org/46016/maze
10:42:02 <sshc> Cale: Ah, thanks
10:42:19 <ion> @djinn (c -> a -> b) -> (c -> a) -> c -> b
10:42:19 <lambdabot> f a b c = a c (b c)
10:42:28 <sshc> I'll stop (or pause) reading this and start reading the book you suggested 
10:42:35 <sshc> Thanks for your help :
10:42:37 <sshc> )
10:42:45 <KirinDave> _Ray_: Okay step1
10:42:46 <Cale> sshc: yeah, I was about to suggest that :)
10:42:54 <Dr_H_> sorry, I accidentally closed the window :(
10:43:04 <KirinDave> _Ray_: Record syntax for data. Go grab LYAH and check that shit. You will 1/4 your code.
10:43:35 <pmurias> if i want to have 2 (likely more in the future) pieces of state what should i store in the State monad? a tuple?
10:43:46 <KirinDave> _ray_: Also "direction" seems like it wouldn't include arbitrary directions. In the file I made sure to include an exit which was "door"
10:44:21 <_Ray_> I made Direction a type so that later we could do like "south-east" or "magic-trap-door" or something
10:44:34 <_Ray_> But yeah, the boilerplate of the Room type is disgustingly Javalike
10:44:37 <aristid> ion: i'd almost be tempted to write this f a b c = (a c) (b c)
10:45:10 <KirinDave> _Ray_: I Was going to just make a function String -> (Num, Room)
10:45:55 <aristid> Num? do you mean Integer?
10:46:05 <KirinDave> aristid: Yeah my bad.
10:46:29 <Cale> _Ray_: It's not so useful in practice, but have you ever tried the mutual-recursion-between-rooms thing?
10:46:44 <KirinDave> Cale: I think that's what he was hoping to try
10:46:54 <_Ray_> Cale: I tried to, but failed miserably. That's what the function addExits and addHiddenExits try to do.
10:46:55 <KirinDave> I actually had a question about http://hpaste.org/46004/mutual_recursion_in_constructo.
10:47:09 <KirinDave> The way I read it
10:47:19 <_Ray_> When I say miserably, I /mean/ miserably. It was at 7am and my intellectual capacity was akin to broccoli.
10:47:20 <Cale> _Ray_: ah, the problem with it is that changing the graph is hard
10:47:23 <KirinDave> It seems like it lazily computes the authors for a book, then the book for an author, and so on down.
10:47:35 * hackagebot elf 0.25 - Parser for ELF object format.  http://hackage.haskell.org/package/elf-0.25 (ErikCharlebois)
10:47:42 <_Ray_> Cale: Indeed, r has a west, but south(north(r)) doesn't, because west was added after north :(
10:48:04 <_Ray_> (And let's not even get into the messyness that is adding r as a north exit to itself!)
10:48:05 <KirinDave> Cale: Indeed. I was going to approach this problem by making the graph links symbolic by id into a hash table. 
10:48:26 <Cale> s/hash table/Map/
10:48:29 <Dr_H> much better
10:48:35 <KirinDave> Cale: If you like. 
10:48:52 <c_wraith> yeah, explicit sharing is an obvious solution to this sort of thing
10:48:57 <Cale> Don't use hash tables if you can avoid it, and never use Data.HashTable :)
10:48:58 <KirinDave> Heck, an associative array would do it.
10:49:06 <Jafet> The mailing list has two-dimensional grid zippers
10:49:39 <Jafet> It builds them in some fan-out topological order thing that's probably horribly inefficient, but I never profiled it
10:49:44 <crystal-cola> what books not about haskell are good for haskell users?
10:49:57 <KirinDave> _Ray_: On http://hpaste.org/46004/mutual_recursion_in_constructo I think it keeps recomputing the recursive parts. It doesn't share structure.
10:50:03 <Jafet> Alic... okay, that line's getting old.
10:50:22 <_Ray_> KirinDave, indeed, but it does share the structure, Nereid said.
10:50:27 <_Ray_> It's a bit odd.
10:50:39 <jmcarthur> is there a function in base that would allow me to easily show a Rational as a (possibly infinite) sequence of decimal digits including a decimal point?
10:50:43 <_Ray_> Indeed createBook 'creates a new Author' and doesn't care about the one it was passed.
10:51:37 <_Ray_> Cale: How could one change the graph in this way? Does one have to make it "all at once", so to speak? (Note the graph will be immutable after a building phase, so it's not against the rules to build it all at once.)
10:52:14 <Cale> _Ray_: yes, preferably you do it all in one let-block or at the top level, giving a name to each of the rooms, making it a constant
10:52:29 <Cale> Anything with a name will be shared
10:52:41 <_Ray_> Cale: That's what I tried to do on line 99 (main), but clearly I'm doing it wrong
10:52:46 <KirinDave> Cale: It may not be clear, but the structure of these is actually defined in a file.
10:52:55 <_Ray_> Ah, yes. That too. 
10:53:07 <Cale> You can't rely on two occurrences of f x sharing the same memory (in fact, you can rely on them being separate)
10:53:14 <KirinDave> Cale: https://gist.github.com/939387
10:53:18 <Cale> but you can rely on two occurrences of x sharing the same memory
10:53:30 <jmcarthur> you can't necessarily rely on them being separate either
10:53:37 <jmcarthur> since ghc does do *some* CSE
10:53:47 <_Ray_> KirinDave: In fact, I'd wager if you add Eq to Book and Author, the structures would compare ==.
10:53:53 <Cale> Wellll...
10:54:11 <Cale> GHC does some CSE, but you're unlikely to run into it with code that you write yourself
10:54:14 <jmcarthur> -fno-cse brings sanity back :)
10:54:20 <jmcarthur> i've run into it
10:54:30 <jmcarthur> it has bitten me twice with some unsafePerformIO stuff i was doing
10:54:35 <Cale> It only CSEs nested case expressions which scrutinize identical expressions.
10:54:37 <Cale> iirc.
10:54:41 <_Ray_> (Meaning, a book b with b->authors!!0->books!!0, of course.)
10:55:02 <jmcarthur> hmm, i don't know the rule
10:55:34 <Cale> So if you have   case e1 of pat1 -> (case e1 of pat2 -> ...); ...
10:55:38 <Cale> it'll turn that into
10:55:52 <Cale> let x = e1 in case x of pat1 -> (case x of pat2 -> ...); ...
10:56:05 <Cale> with the idea here being that e1 is some composite expression
10:56:10 <aristid> jmcarthur: if you need -fno-cse to fix your unsafePerformIO stuff, you're probably not using it in a good way :)
10:56:51 <jmcarthur> heh, no
10:56:55 <jmcarthur> this was very ugly
10:57:17 <Cale> The reason for that tiny bit of CSE is that desugaring produces nested case expressions like that
10:57:21 <jmcarthur> actually, one of the times was safe without -fno-cse, but much more efficient with it
10:57:36 <Cale> while it's extremely uncommon to write such expressions yourself
10:57:45 <crystal-cola> > let f (p,q) = let (a,p') = (10*p)`divMod`q in a : f (p',q) in (1/7,f (1,7))
10:57:46 <lambdabot>   (0.14285714285714285,[1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2,8,5,7,1,4,2...
10:57:47 <Cale> (because you can always avoid doing so)
10:58:16 <Saizan> http://hackage.haskell.org/trac/ghc/ticket/917 -- surprising CSE without unsafePerformIO
10:58:34 <jmcarthur> maybe the cse pass could be made to only trigger if the term was duplicated by the compiler in the first place
10:58:39 <jmcarthur> *expression
10:59:06 <jmcarthur> i don't know what passes do that duplication though so maybe that would be impractical
10:59:10 <Saizan> it more let floating of [0..1000000000] than cse though
10:59:37 <Cale> yeah, that's different
11:00:12 <Cale> GHC does much more aggressive let floating than CSE
11:00:53 <vanillajeff> i was wondering if anyone can point me to a good overview of how GHC does linking, especially to non-native libraries... i've been getting 'undefined symbols' errors with FTGL on macos x
11:01:30 <sshc> CSE?
11:01:39 <jmcarthur> Common Subexpression Elimination
11:01:39 <Cale> common subexpression elimination
11:02:03 <Cale> vanillajeff: Are you compiling with --make?
11:02:25 <vanillajeff> cale: yes. ghc --make -L/usr/local/lib -lftgl test.hs
11:02:39 <Cale> Okay, so it's a little more subtle than that :)
11:02:59 <Cale> (most linker errors are just caused by not having appropriate -package flags or using --make to guess them)
11:05:17 <Cale> What undefined symbols?
11:06:01 <vanillajeff> Cale: grep tells me that '/usr/local/lib/libftgl.a' contains the missing symbols, but even explicitly passing ghc the library with full path doesn't resolve it.
11:06:17 <vanillajeff> Cale: _ftglGetFontLineHeight", referenced from: _s3zh_info in libHSFTGL-1.333.a(FTGL.o) is one of many
11:07:14 <Cale> Usually if you're using a package, it's not necessary to include extra linker flags.
11:07:46 <Cale> Are you 100% certain that the package you're using was compiled against the same version of the library that's installed?
11:07:52 <crystal-cola> whats up hasabal
11:09:37 <Cale> Let me just try an example of this (I didn't know about FTGL, and it might actually be useful for my work :)
11:09:58 <vanillajeff> Cale: also, the package builds and installs fine; it's when i include it in a project (in this case, it's just the import and a main=return()). i've tried just using --make, just using -package, and it doesn't link properly. i know it links properly in linux.
11:10:27 <Cale> ah, okay
11:10:36 <Cale> hmmm
11:11:03 <Cale> and you installed it simply with  cabal install FTGL
11:11:36 <taktoa> hrmm... so my genetic algorithm still doesn't work, and I'm starting to think it's coming from the makeInitChroms function rather than runGen(')
11:11:39 <vanillajeff> cale: yep. and even downloaded and tried tweaking it before installing it, still with no such luck
11:11:40 <taktoa> paste here: http://hpaste.org/46017
11:12:40 <crystal-cola> does genetic algorithm have any theorems?
11:12:47 <crystal-cola> e.g. proof that it works
11:13:08 <taktoa> not really
11:13:15 <taktoa> I mean, I made a test function
11:13:15 <crystal-cola> thats a shame 
11:13:19 <taktoa> but it doesn't work
11:13:22 <Cale> You can prove some things about it
11:13:29 <crystal-cola> like what?
11:13:56 <Cale> Well, depending on how you've written it, you can prove simple things like that each iteration is no worse than the last ;)
11:13:58 <aleator> crystal-cola: There is some at very theoretical level. See Neubauer A theoretical analysis of..
11:14:28 <Cale> (which should be easy if you always keep the best candidates around)
11:14:38 <Jafet> There's a story about a neural network trained to detect the nationality of tanks in photographs
11:15:04 <aleator> crystal-cola: also, Rudolph, Convergence analysis of.. 
11:16:09 <taktoa> idea: I'm going to try testing just the makeInitChroms function
11:16:12 <Jafet> The researchers trained it on half the sample images, and after that it passed testing on the other half perfectly. They presented it to the military who commissioned it, and it completely didn't work
11:16:14 <aleator> But anyways, using GA is just one step above admitting failure :)
11:16:20 <taktoa> aha
11:16:27 <taktoa> it outputs an empty list
11:16:35 <taktoa> there's the problem
11:16:45 <DasIch> is there a generally accepted style guide for haskell? something like pep 8 for python?
11:17:11 <Cale> http://urchin.earth.li/~ian/style/haskell.html
11:17:16 <taktoa> well, you can follow hlint suggestions
11:17:34 <Cale> All the stuff on that page is pretty uncontroversial
11:17:55 <DasIch> Cale: thanks
11:18:36 <Cale> Oh, also, the 'then' and 'else' in an if-expression should line up if they occur on separate lines.
11:18:57 <Cale> Would be another thing that I'd throw in
11:19:04 <Cale> So it should look like:
11:19:06 <Cale> if foo
11:19:09 <Cale>    then bar
11:19:11 <Cale>    else quux
11:19:15 <Cale> or
11:19:17 <Cale> if foo then bar
11:19:21 <Cale>        else quux
11:19:25 <Cale> but not
11:19:27 <Cale> if foo then
11:19:33 <Cale>   bar
11:19:36 <Cale>   else quux
11:19:43 <Cale> or something weird like that :)
11:20:51 <Cale> Nobody will tend to care how many spaces you indent things, as long as you're reasonable about it, and you line things up properly.
11:21:02 <taktoa> so I basically need to make a function
11:21:11 <taktoa> that will generate a list of random lists
11:21:18 <taktoa> of a predetermined size
11:21:31 <Cale> but be prepared to take a lot of flak if you put tab characters in your code
11:21:39 <taktoa> is there a standard function that does that?
11:21:56 <taktoa> oh, and the random numbers are doubles
11:22:10 <Cale> well...
11:22:15 <Cale> you could use randoms/randomRs
11:22:28 <Cale> together with something to split the infinite list into chunks
11:22:43 <Cale> like  map (take n) . iterate (drop n)
11:22:52 <shachaf> So whenever I talk to this person about Curry-Howard or anything related to that, he says "Ah, all this ivory tower theory". I don't think that's all that much of an objection, myself, but what shall I say to him? Is there some practical application? :-)
11:22:59 <DasIch> Cale: no tabs and 79 columns max is something i can easily agree with coming from python :)
11:23:16 <crystal-cola> you're wasting your time talking to this ivory tower guy
11:23:30 <Cale> shachaf: If someone isn't impressed by Curry-Howard, then they're not the sort of person who will likely find it useful.
11:23:30 <crystal-cola> lots of people don't care about curry-howard
11:23:51 <crystal-cola> you can talk to a logician about it they will enjoy it
11:25:03 <Cale> If someone knows a lot about how to prove theorems, but not much about how to set about writing programs, then it'll be something useful to look at. Also vice-versa to some extent.
11:25:52 <bbrown_win4> I just install the haskell platform and trying to setup gtk.  I then went to the gio to build and install it.  Here is the error I am getting.  It is pretty strange.  https://gist.github.com/939788
11:26:53 <bbrown_win4> to my question, basically, I just need to setup cabal to install to X path
11:27:05 <shachaf> Cale: Are the types that people generally use in programming generally "interesting" as propositions? Or are the proofs that people give to theorems generally "interesting" as programs?
11:27:19 <Cale> bbrown_win4: That does seem strange, I don't know how things work on Windows...
11:27:27 <Cale> bbrown_win4: But I recommend not using the --global flag ever.
11:27:42 <Cale> Unless you have a really good reason that you need the package installations to be global
11:27:54 <taktoa> Cale: I'm a bit confused as to how to set up "map (take n) . iterate (drop n)". What is the inp?ut? What is the number of randoms in a list? What is the number of random lists in a superlist
11:27:58 <shachaf> By the way, his reaction is "Well, I am impressed all right. But I would love to see one useful consequence... Just one would do."
11:28:02 <Cale> It's nicer to keep the packages which come with GHC separate from the packages that you install yourself.
11:28:12 <crystal-cola> shachaf: what did you describe it as?
11:28:22 <bbrown_win4> Cale "Yea it is a strange error, "I dont' even know where C:\Program Files (x86)\Haskell
11:28:23 <bbrown_win4> came from
11:28:53 <shachaf> crystal-cola: What do you mean?
11:29:12 <Cale> shachaf: In the first case, usually not (mostly because our types are pretty weak from that point of view), but in the second case, sometimes.
11:29:27 <Saizan> shachaf: call/cc is pierce's law, for example
11:29:36 <Cale> taktoa: randoms and randomRs will produce an infinite list of random numbers
11:29:56 <Cale> taktoa: map (take n) . iterate (drop n) will chunk that infinite list into an infinite list of lists of length n
11:30:14 <Saizan> shachaf: of course it gets more interesting both ways with more expressive type systems
11:30:19 <crystal-cola> what did you explain it as being?
11:30:26 <taktoa> Cale: Is  map (take n) . iterate (drop n) the same as  map ((take n) . iterate (drop n))
11:30:30 <crystal-cola> (for him to say it is impressive but not see the use)
11:30:49 <Cale> shachaf: Often proofs of existence of certain real numbers will function as methods for computing them, if the proofs are set up in a sufficiently constructive way.
11:30:49 <Jafet> Or unfoldr (Just.splitAt n)
11:31:00 <Cale> taktoa: no
11:31:11 <taktoa> Cale: ok, that makes more sense then
11:31:46 <shachaf> crystal-cola: A correspondence between types-programs and propositions-proofs? Are there various different things to explain it as?
11:31:59 <Cale> shachaf: The programs which you can extract that way are typically not the most efficient ones though.
11:32:31 <Cale> shachaf: (How you carry out the proof affects the performance of the extracted algorithm)
11:33:20 <shachaf> His reaction is generally along the lines of "yes, this is neat, mathematically, but as a lowly software engineer, what can I learn from this to make my programs more correct/efficient/simple/etc.?".
11:34:41 <crystal-cola> seems a bit weird - there's no relation between logic and programs
11:34:43 <pppaul> hello
11:34:49 <osfameron> are there any good haskell screencasts?
11:34:52 <pppaul> why do you love haskell?
11:35:05 <parcs> pppaul: he is a sexy man
11:35:09 <osfameron> crystal-cola: sure there is, isn't there?
11:35:25 <pppaul> sexy men are hard not to love
11:35:52 <crystal-cola> I don't think so - the correspondence is between certain typed lambda calculi and specific types of logic
11:36:05 <Jafet> @vixen is Haskell hard or sexy?
11:36:05 <lambdabot> Ooh, functional programmers are so hot!
11:36:28 <crystal-cola> what has lambda calculus got to do with programming?
11:36:35 <pppaul> have you guys tried the tryhaskell.org lessons?
11:36:43 <Dr_H> pppaul: I fell in love only hours ago, but my reason was the ability to twist and fold out any expression to make everything single-lined
11:36:44 <crystal-cola> Very little.. you can use it to model some of the syntax problems
11:37:08 <osfameron> crystal-cola: i thought i read recently that any proof of a program was isomorphic to the program itself
11:37:35 <crystal-cola> I don't really understand that
11:37:39 <osfameron> and that therefore there were whole vistas of stuff to steal from Logic
11:37:47 <osfameron> oh, me neither
11:38:03 <cheater99> it depends on what you mean by proof
11:38:11 * osfameron is a jobbing web-dev, not an academic
11:38:18 <cheater99> a theorem in mathematics is usually defined by its proof
11:38:20 <crystal-cola> I am just saying that people are trying to push this analogy way too hard
11:38:30 <crystal-cola> it's a pretty idea but that doesn't make it true
11:38:46 <cheater99> however, the "proofs" in computer science just prove some properties of programs, they do not prove programs as theorems
11:38:46 <Jafet> Tell that to coq programmers.
11:38:53 <osfameron> crystal-cola: keats would disagree!
11:38:54 <pppaul> does the tryhaskell.org stuff cover monads?
11:38:58 <crystal-cola> current programming languages are ad-hoc hodge podge
11:39:12 <crystal-cola> if we want to connect them up to logic we have to make them much more necessary
11:39:15 <Jafet> Oh, crystal-cola is j-invariant.
11:39:19 <cheater99> Jafet: you mean Coq logicians?
11:39:20 <Jafet> @protontorpedo
11:39:20 <lambdabot> look at smalltalk. they invented oo proramming
11:39:33 <crystal-cola> what is keats?
11:39:55 <osfameron> crystal-cola: a lot of it is well-encapsulated hodge podge
11:39:59 <osfameron> crystal-cola: a poet...
11:40:17 <osfameron> "beauty is truth! truth, beauty"
11:40:43 <crystal-cola> hah that is the sort of thing a poet would think
11:40:55 <Jafet> pppaul: you don't need to know what monads are to use Haskell
11:41:41 <osfameron> crystal-cola: and many mathematicians ;-)
11:42:06 <pppaul> i've been getting into monads via clojure, but i've heard that haskell uses them heavily since it's pure functional. so i am wondering if the tutorials go over them.
11:42:43 <crystal-cola> almost all programming is very trivial if you try to interpret it as proofs
11:43:36 <taktoa> another conundrum
11:43:43 <Dr_H> pppaul: even recursion is so elegantly done with fix
11:43:52 <taktoa> my mutation code is acting up
11:43:58 <Jafet> pppaul: you may want to read LYAH.
11:44:02 <pppaul> fix?
11:44:11 <taktoa> I'm getting an "Index too high" error
11:44:14 <taktoa> from a !!
11:44:29 <taktoa> but the range on the random input to that !!
11:44:37 <taktoa> is (0, length - 1)
11:44:44 <pppaul> thanks Jafet
11:44:47 <Tomsik> crystal-cola: except when you've got programs that you can't prove that they terminate 
11:44:49 <taktoa> which makes absolutely no sense
11:44:56 <osfameron> pppaul: i'll second Jafet's lyah recommendation
11:45:22 <pppaul> i like the elephant
11:45:26 <crystal-cola> Tomsik: the termination proofs are serious mathematics, the program itself - interpreted as a proof - is triival
11:46:00 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
11:46:08 <Cale> http://www.haskell.org/haskellwiki/Monads_as_containers
11:46:27 <Tomsik> crystal-cola: I'm not sure if you can have soundness in types without proof of termination
11:46:27 <Cale> Some tutorials that I wrote
11:46:47 <Cale> Probably that first one will be more relevant to you
11:47:01 <crystal-cola> I don't know what you mean
11:47:08 <Cale> But I have both approaches because different people like to come at things from different angles
11:47:41 <Tomsik> :t let f x = f x
11:47:42 <lambdabot> <no location info>: not an expression: `let f x = f x'
11:47:46 <Tomsik> :t let f x = f x in f
11:47:47 <lambdabot> forall t t1. t -> t1
11:48:24 <crystal-cola> the problem is you are trying to interet the type of a program as some kind of mathematical statement
11:48:31 <crystal-cola> that is absurd
11:48:38 <Tomsik> that's not absurd
11:48:45 <Tomsik> that's curry-howard isomorphism
11:49:07 <Cale> If the type is sufficiently detailed, it can be a useful mathematical statement. If it's something like Integer -> Bool, then it's completely unsurprising.
11:49:30 <Cale> ("If there's an Integer, then there's a Bool" is not a particularly interesting thing)
11:49:35 <crystal-cola> I don't know why you would try to apply curry-howard to haskell.. there are no theorems about haskell
11:49:49 <Cale> But if the type actually said something about what the function did, then it could be arbitrarily interesting.
11:50:04 <Cale> crystal-cola: hm?
11:50:25 <crystal-cola> it's about specific types of lambda calculus
11:50:26 <dolio> Curry-Howard is neither limited to lambda calculi, nor 'particular' logics.
11:50:27 <Tomsik> You can prove that append function is associative and many other facts if you bother enough with the type system
11:50:35 <dolio> And lambda calculi have lots to do with programming.
11:50:44 <Cale> Well, Curry-Howard sort of trivialises if you apply it to Haskell in a direct way, since Haskell is Turing complete, and so every type has a value (nontermination)
11:50:49 <pppaul> cola is a troll?
11:50:59 <crystal-cola> you can generalize anything to triviality
11:51:22 <Cale> But if you apply it to various sublanguages of Haskell, it's fine.
11:51:32 <pppaul> i want to trivialize my dinner
11:51:41 <Cale> and as a general way of thinking while you write your programs, it can be helpful
11:51:42 <Tomsik> I'll trivialize your ass!
11:51:46 <Tomsik> As in a donkey.
11:51:50 <crystal-cola> yes that's reasonable, you can interpret various lambda calculi into haskell
11:51:51 <djahandarie> (i.e., djinn)
11:52:24 <crystal-cola> it is a mistake to think there is some kind of fundamental far-reaching philosophical implication of curry-howard though
11:52:30 <crystal-cola> as the motto suggests
11:52:50 <Dr_H> Cale: why don't astrophysicists implement the different theories in Haskell to see which can be valid?
11:53:00 <crystal-cola> the actual relations between programming and proof are extremely weak
11:53:09 <Tomsik> Well, it's not far-reaching obviously, halting problem is far-reaching
11:53:28 <djahandarie> crystal-cola, well, I suppose it depends on what you mean by philosophical. I think it's fairly far-reaching in the sense that it connects two seperate fields (logic and computer science) in a rigorous manner.
11:53:29 <Tomsik> It's more far-reaching than anyone seems to realize
11:53:50 <taktoa> well, I finally fixed up my genetic algorithm
11:53:51 <crystal-cola> djahandarie: thinking of computing science and logic as "different"? that's   :D
11:53:57 <applicative> It
11:54:00 <crystal-cola> they are like the same thing
11:54:00 <taktoa> but, for some reason, it doesn't work
11:54:11 <Cale> I dunno. Curry-Howard is pretty far-reaching, but for that reason it's also not terribly deep.
11:54:15 <taktoa> in that it doesn't come close to maximizing the fitness function
11:54:31 <taktoa> even for very large iteration numbers
11:54:33 <applicative> is surprising how robust this Curry Howard business is, I find.  I instinctively oppose it, but it keeps proving itself.... 
11:54:50 <Cale> applicative: Why oppose it?
11:54:51 <djahandarie> crystal-cola, sure, but Curry-Howard gives us a solid way to say _how_ programming and logic are the same. Rather than hand waving. :)
11:55:26 <crystal-cola> well I was saying there not the same at all - I'm not sure what relations you have in mind
11:55:41 <Tomsik> I think CH is a fun, interesting and useful, but it is just a coincidence
11:56:08 <arcatan> Curry-Howard coincidence
11:56:08 <applicative> Cale, I just mean, I would naturally oppose something like Martin-Loef's philosophy. But it contains so much strength. As old fashioned intuitionism, which seems to people a groundless phobia, had on further reflection an astounding internal integrity.  
11:56:18 <crystal-cola> why do you say it's a coincidence?
11:56:32 <crystal-cola> I think it's wwhat happens if you write out the same thing twice but call one thing smoething else
11:56:38 <crystal-cola> it's completely unsurprising that there is a "isomorphism"
11:56:46 <Tomsik> I think it's just that implication acts like functional types
11:56:56 <Tomsik> and it all follows up from there
11:57:02 <Tomsik> afk
11:57:07 <pppaul> does haskell have simple syntax like in forth / Io / lisp?
11:57:22 <crystal-cola> intuitionism is mathematics founded on algorithms, one is not surprised that the theory has connections to algorithms...
11:57:31 <dolio> The point is that it wasn't just someone writing the same thing out twice.
11:57:42 <Cale> pppaul: The syntax is technically somewhat complicated, but is pretty simple to read and write, and there's a lot of uniformity to it.
11:57:44 <dolio> It was two different people, working on two different things, writing out the same thing.
11:57:53 <dolio> And that happened for multiple pairs of people.
11:57:58 <applicative> Isn't there more to it than that, Curry only noticed it because he introduced polymorphism, no?  In a system like Church's simple types, you wouldn't notice it
11:58:12 <crystal-cola> dolio: I am using the benefit of hindsight
11:59:05 <applicative> crystal-cola, Brouwer doesn't use the word algorithm, does he, only 'construction' has that sort of position
11:59:09 <dolio> And the problems they are working on are not the same problem.
11:59:47 <crystal-cola> sure "algorithm" is a word - he probably usea  german word since he is German
11:59:57 <applicative> he was Dutch of course
12:00:21 <crystal-cola> oh sorry
12:01:56 <applicative> His amazing theory of real numbers, for example, with 'free choices' etc. explicitly opposes the natural idea of someone with computational ideas.  
12:02:54 <applicative> Even though 'you can have any sequence of digits you want, you don't need a rule of calculation', still he proves that all functions R -> R are continuous.
12:03:13 <applicative> Or so it seemed
12:03:39 <bbrown_win4_> Cale, you mentioned something about don't use cabal install --global.  What is the opposite of install global
12:03:41 <hybr1d> Skola here ? 
12:03:53 <applicative> -- user
12:04:10 <Cale> bbrown_win4_: Installing as user, which is the default
12:05:18 <sm> pppaul: atomo and liskell provide simpler syntaxes for haskell
12:05:51 <applicative> bbrown_win4: in the presence of the Haskell Platform, expecially with OS X and Windows, you should leave the global package registry to the original platform installation
12:06:15 <applicative> bbrown_win4: thats my experience, which of course carries my dimwittedness with it
12:06:40 <bbrown_win4> I recommend they install some gui library like gtk2hs or wxHaskell
12:07:44 <applicative> bbrown_win4: yes, certainly that is the plan.  Its a million times easier now than it used to be, a year ago, even six months ago, but still disaster prone.
12:07:59 <bbrown_win4> ...really, that is interesting.  :)
12:10:11 <Cale> It makes some sense I suppose for the Haskell platform to include a gui library, but personally, I don't even bother with that much as a basic install.
12:10:22 <Cale> I just get the GHC binary package, and then cabal-install
12:10:32 <Cale> and from there, it's easy enough to install anything else I need
12:10:56 <applicative> Cale, this is on some linux distribution?
12:11:00 <Cale> yeah
12:11:14 <Cale> (and I also don't bother with my distribution's Haskell packages)
12:11:14 <applicative> It's much more gruesome with Windows and OS X.
12:11:28 <applicative> in different ways, though
12:11:36 <Cale> I haven't found it any worse on OS X so far.
12:11:52 <applicative> How long have you been using OS X?
12:11:55 <luite> on windows, you have to extract a zip file and add some directory to your path, in addition to the cabal-install commands, for installing gtk2hs
12:12:42 <luite> not terribly difficult, but might be a problem for a beginner
12:12:46 <applicative> luite, it's much easier now than, e.g. two years ago, when I was first using Haskell....
12:12:48 <Cale> ummm...
12:12:49 <Cale> a few months, recently, though not so much in the last month
12:13:09 <Cale> and a few months a long while back (on GHC 6.2)
12:13:11 <luite> applicative: I know, I've spent a few days building a gtk2hs installer that worked with my ghc version
12:13:48 <applicative> Cale, yes, its pretty easy now. The binary installer is a miracle, but this is due to the connection to the Haskell Platform project.
12:13:55 <bbrown_win4> luite, I had to edit the code to get it to work
12:13:58 <Cale> I've been using Haskell since GHC 5.02, so having libraries at all seems pretty nice to me ;)
12:14:02 <Cale> There are almost too many of them now
12:14:08 <Cale> I can't hope to learn to use them all
12:14:16 <bbrown_win4> ...I haven't gotten to work, I mean...moving closer for it to work
12:14:28 <luite> bbrown_win4: gtk2hs on windows?
12:14:33 <bbrown_win4> luite, yea
12:14:48 <luite> bbrown_win4: oh what did you have to edit?
12:14:58 <bbrown_win4> GIO/Volume.chs ? I think
12:15:15 <luite> bbrown_win4: where did you get the gtk libraries from?
12:15:36 <bbrown_win4> luite, the install bundle gtk/glade
12:15:47 <taktoa> aha
12:15:50 <taktoa> I figured it out
12:15:54 <Cale> applicative: The binary GHC installer existed long before HP
12:16:01 <taktoa> my genetic algorithm was minimizing fitness
12:16:02 <Cale> applicative: I've been using it since the beginning.
12:16:03 <taktoa> not maximizing
12:16:37 <applicative> Cale, not really.  For macs, there would often be something on the ghc page, but you needed an advanced degree to keep chaos from happening on a mac
12:16:48 <Cale> hum
12:17:04 <Cale> I think I skipped a long period of time where there weren't as nice installers for Mac
12:17:12 <luite> bbrown_win4: hmm, I've been having some problems with gtk2hs on windows lately, but it did compile fine (complete bundle, binary distribution in zip file), the problems were linking related
12:17:23 <applicative> it would hook up to the wrong gcc, it would presuppose macports libs not native, or the opposite etc etc
12:17:57 <Cale> When I was using it on OS 10.3, there was a nice GUI installer made by Wolfgang Thaller which worked beautifully.
12:17:59 <applicative> it's all the fault of the insane os of course, however glitzy it may be in some eyes
12:18:08 <ezyang> Hey guys, a coproduct is just a disjoint union! Cool! 
12:18:30 <Cale> ezyang: in cases where the objects of the category are sets, that is often times the case
12:18:46 <Cale> ezyang: But for example, in the category of groups, it's a little more complicated
12:19:31 <applicative> I see, that is before my time.   I used the macports one sometimes, and the binaries public-spirited  people would put on the ghc site.  They worked but, for example, it was impossible to do the exercises in 'the haskell school of expression'
12:19:42 <ezyang> Cale: Ah yes, I imagine saying that doesn't really work if there isn't a disjoint union where you come from. 
12:19:45 * hackagebot fixed-point 0.2.0.0 - Binary fixed-point arithmetic  http://hackage.haskell.org/package/fixed-point-0.2.0.0 (JakeMcArthur)
12:20:06 <Cale> ezyang: yeah, though you can sort of go the other way
12:20:29 <Cale> ezyang: and say that the natural analogue of a disjoint union in those other cases is whatever the coproduct happens to be :)
12:21:22 <Cale> ezyang: Often it'll be a disjoint union followed by some smashing together of things so as to make various laws hold again
12:21:28 <applicative> Either a b certainly has the look of a disjoint union, Right a , Left b
12:21:34 <applicative> or vice versa'
12:22:00 <ezyang> applicative: Yep, that's the coproduct in the category Hask :-) 
12:22:16 <applicative> I suppose elsewhere it is a bit more opaque....
12:22:18 <ezyang> (though I might be abusing terminology) 
12:23:28 <jmcarthur> hackage doesn't seem to be running haddock lately
12:23:34 <dons> ezyang: i'm really enjoying your series of posts. the last one is particularly good. the metaphor is coming together. i wonder if you can do tag bits at some point, deepseq, unboxed values ...
12:24:22 <ezyang> dons: So many topics, so little time :-) 
12:24:28 <dons> yeah :}
12:24:44 <dons> tag bits are an interesting one.
12:24:45 <applicative> ezyang, yes its great, speaking from a rather un-dons-like level of comprehension...
12:24:50 <ezyang> deepseq is definitely on the block, I can think about tag bits and unboxed values (they don't fit very well with the metaphor) 
12:25:01 <dons> since the contents of the boxes are immutable, you can write what's in the box on the outside.
12:25:15 <dons> so i can just look at the box to know its constructor
12:25:37 <dons> its a complication to the model to exploit purity
12:25:49 <dons> also WHNF status is indicated in tag bits
12:25:51 <ezyang> "But why after I open the box, do I wrap it back up again?" ("So you can regift it to someone else, silly!") 
12:26:04 <ezyang> Ooh, that works quite well. I will do that! 
12:26:26 <dons> also, if you're evil : http://hackage.haskell.org/package/tag-bits 
12:26:37 <dons> "unsafeIsEvaluated :: a -> Bool"
12:26:46 <ezyang> fuuuuuu 
12:26:50 <dons> hehee
12:26:57 <dons> i didn't want to say ;)
12:27:04 <ezyang> Actually, that'll come in handy for my evil memoization experiments. 
12:27:13 <dons> this is the key intro: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging 
12:27:32 <ezyang> "More ideas for controlled mutation" sent to haskell-cafe. Didn't realize you could do it in GHC. 
12:27:50 <ezyang> dons: Yeah, I fixed a bug in GHC's pointer tagging that was making the compacting GC unhappy :-) 
12:28:00 <dons> oh good
12:28:21 <dons> ezyang: have a look at andy gill's paper on observable sharing
12:28:44 <dons> he's been thinking about tag bits, memoization and deepseq for years. 
12:28:55 <ezyang> Oh yes, that would be a good one to reread now. I know a lot more about this stuff now then when I last read it. 
12:29:14 <dons> anyway, you're doing a great job. :-)
12:29:31 <ezyang> Thanks :-) 
12:30:49 <dons> hmm. i wonder if i could modify vacuum to generate ghosts and presents,  http://stackoverflow.com/questions/3862144/do-i-need-to-understand-how-haskell-represents-data-to-be-able-to-write-good-hask/5767014#5767014 
12:30:58 <dons> instead of pointers and cons cells
12:31:24 <ezyang> hahahaha 
12:31:37 <dons> would be fun :-) ezyangbot
12:31:51 <Dr_H> how are fix recursions compiled and executed?
12:32:04 <dons> ?src fix
12:32:05 <lambdabot> fix f = let x = f x in x
12:32:06 <dons> this one?
12:32:23 <ezyang> Dr_H: Since GHC Core has support for recursive bindings, we just inline it and then let it figure out the rest. 
12:32:43 <dons> and it compiles to a loop of some form in the end
12:33:23 <Dr_H> so it will become a loop
12:33:47 <dons> yep.
12:34:02 <jmcarthur> can anybody think of a good realistic benchmark for my fixed-point library? i was thinking a simple ray tracer might be a decent one as long as it doesn't need any operations that i haven't implemented yet (the Floating class, mainly)
12:34:28 <dons> jmcarthur: numeric stuff in arrays? barnes-hut, smvm, etc?
12:34:50 <Dr_H> so if I have a fix (flip ((.) . f) . (. g)) x y, how do I know what it will become?
12:34:51 <jmcarthur> ah array stuff... i should make an Unbox instance for it
12:35:05 <jmcarthur> thanks dons, these are good ideas
12:35:11 <dons> Dr_H: oh, you didn't say you'd have lots of point-free stuff too :-)
12:35:22 <dons> ?unpl \x y -> fix (flip ((.) . f) . (. g)) x y
12:35:23 <lambdabot> \ x y -> fix (\ l c h -> f c (l (g h))) x y
12:35:52 <jmcarthur> i was thinking ray tracer because it stands to actually benefit from the characteristics of fixed-point (uniform, controllable precision)
12:36:36 <dons> e.g. main = print $ fix (1:)  ---> becomes ---> showList main' where main' = x : main'
12:37:56 <dons> ezyang: have you read the early G machine papers (or the STG machine paper?)
12:39:04 <Cale> Dr_H: That seems needlessly obfuscated :)
12:39:06 <ezyang> I've read bits of it over multiple sessions.  That's probably another one I should look at again. 
12:39:21 <taktoa> does anyone here have experience making a multilayer perceptron in Haskell (ie: a neural network)?
12:39:48 <taktoa> I checked out HNN, but the example it gives is an xor net
12:40:21 <dons> ezyang: worth a read http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/ 
12:41:36 <Dr_H> dons: so basically the unpl'd original recursion will be converted to a simple loop
12:41:59 <Tomsik> I heard fix-based implementation of factorial is the fastest one
12:43:45 <dons> Tomsik: recursive factorials all compile to the same loop in the  end, so i doubt it.
12:44:20 <scree> taktoa: are you thinking about straightforward three-layer or so perceptrons, or something fancier?
12:44:28 <taktoa> three layer, yes
12:44:30 <hpc> the fastest factorial would be the FFI implementation, where you call a C function that is actually inline assembly
12:44:34 <taktoa> and I don't need to train it
12:44:54 <taktoa> I only need a neural net model that takes weights and inputs and makes an output
12:45:07 <Dr_H> hpc: true :)
12:45:21 <scree> taktoa: in that case I can't see a performance problem with doing that with immutable arrays
12:45:41 <taktoa> can you explain how I would implement it?
12:45:53 <taktoa> I haven't used arrays
12:45:54 <dons> using mutable arrays, or hashmaps or IntMaps would make sense, if there are lots of updates.
12:46:00 <dons> e.g. mutable vectors, or IntMap
12:46:28 <sshc> Cale: THanks for the book; I've started reading it just recently
12:46:38 <sshc> Cale: Would "containers" be considered categories, analogious to * -> * in Haskell?  Are functions (a ->), categories, where objects are "sets" or the collective mass of all types with the type "b", and arrows are, ..functions?
12:47:00 <scree> taktoa: so, my guess is you want a function: nextLayer :: Array Int Double -> Array Int Double -> Array Int Double; weights inputArray ---> outputArray
12:47:21 <hpc> sshc: (->) is a category, not (a ->)
12:47:31 <scree> taktoa: actually, you could probably do this with lists
12:47:31 <Cale> ._____.
12:47:49 <hpc> sshc: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8
12:48:05 <hpc> (assumes you are already fairly comfortable with monads)
12:48:13 <Cale> The category isn't (->) or (a ->) per-se, but all Haskell types and the functions between them.
12:48:14 <scree> taktoa: hang on, ignore me a sec
12:48:14 <sshc> Yes
12:48:29 <sshc> (I have plenty of experience with monad)
12:48:29 <Cale> At least, the standard one
12:48:43 <sshc> The standard what?
12:48:53 <taktoa> scree: so something like "([Weight], [Weight]) -> [Input] -> [Output]"... I'm just not sure how to go about implementing it
12:48:58 <Cale> For any type a, we have that (a ->) is a functor from that category to itself
12:49:14 <hpc> the standard category is "instance Category (->) where id = id; (.) = (.)
12:49:15 <hpc> "
12:49:19 <Cale> sshc: The standard way of looking at Haskell as a category
12:49:23 <scree> taktoa: well on reflection "weights" is a 2-d thing
12:49:30 <hpc> it is also called Hask
12:49:35 <Cale> hpc: The Category typeclass makes me want to cry
12:49:42 <crystal-cola> why?
12:49:42 <taktoa> first->second, and second->third
12:49:45 <hpc> Cale: eh?
12:49:48 <crystal-cola> is it bad
12:49:49 <sshc> I was just about to ask about the Category typeclass:
12:50:06 <sshc> I was presuming that instances of type classes are categories
12:50:25 <scree> taktoa: so, you want to take your [[Double]] weights, your [Double] input, and for each list in weights, do the product-sum-thingy function thing on the input
12:50:25 <sshc> s/type classes/Category class/
12:50:35 <sshc> It seems I'm wrong?
12:50:46 <taktoa> scree: yeah
12:50:56 <Cale> The category typeclass is some weird internalisation of the notion of categories whose objects are the same as those of the category of Haskell types, and whose composition and identities are natural transformations of appropriate types.
12:51:12 <scree> taktoa: something like: foo weights inputs = map (\ws -> responseFunction . sum $ zipWith (*) ws inputs) weights
12:51:32 <DrSyzygy> Cale: The documentation seems to want to spout nonsense too. 
12:51:37 <hpc> Cale: it can't possibly be more general, i don't think?
12:51:41 <taktoa> scree: okay, I'll go with that and come back if I have problems
12:51:46 <Cale> It's kind of hard to formalise, but it's not the same thing as a category, it just looks kinda like it.
12:51:52 <Dr_H> omg
12:52:19 <merijn> Cale: Any chance of the fold/scan/etc diagrams you had on your site reappearing? I was trying to link someone to that, only to find out it was gone after your site crashed :\
12:52:29 <Dr_H> I just pl'd f ((g x y) (h z w)), it's gross
12:52:42 <Cale> merijn: um, I can put them back up I think...
12:52:50 <applicative> merijn arent they on wikipedia somewhere
12:53:15 <Cale> a couple are on wikipedia
12:53:23 <Cale> I lost my wiki
12:53:33 <Cale> but I still have an svg of the diagrams
12:53:46 <applicative> just folds, i see: http://en.wikipedia.org/wiki/Fold_(higher-order_function)
12:53:51 <sshc> Cale: To clarify: when there is arrow f, where f : A -> B, are A and B themselves objects?
12:53:55 <merijn> applicative: Oh, a few are I see, I hadn't looked at wikipedia. I never bothered to mirror those diagrams, which is a shame since I think they are very useful for people
12:53:57 <Cale> http://cale.yi.org/share/Folds.svg
12:54:27 <merijn> Cale: Awesome :)
12:54:42 <scree> taktoa: BTW, the reason I asked if you were doing anything more complicated is that this "pull-style" neural net stuff becomes obscenely messy if you start messing with more complicated stuff
12:54:50 <dolio> > sqrt 320
12:54:51 <lambdabot>   17.88854381999832
12:55:24 <hpc> Cale: wow, epic svg
12:55:26 <applicative> wow, don't remember seeing these.  let's see if i can figure them out.  
12:55:28 <scree> taktoa: it becomes cleaner to do "push-style", i.e. iterate over the source array as your outermost loop
12:55:31 <hpc> it takes a full minute to load
12:55:48 <scree> taktoa: and that would almost certainly end up better with mutable arrays
12:56:11 <Cale> hpc: It can. The manner in which composition is defined should be an arbitrary function on pairs of arrows of the appropriate types, but as defined by the category class, it ends up having to be natural in a particular way
12:56:45 <applicative> hpc, yeah it almost 10,000 lines....
12:57:00 <hpc> so what, (.) :: cat a b -> cat c d -> cat e f?
12:57:01 <djahandarie> Cale, ooh, now comes with mapAccum. :) Nice
12:57:13 <Cale> no
12:57:28 <Cale> well...
12:57:43 * hpc doesn't see how it can be done, and how it is natural
12:57:53 <sshc> < Cale> no — Was that a response to my question?
12:58:05 <hpc> sshc: yours was right, i think
12:58:36 <Cale> (.) :: (Category (~>)) => (b ~> c) -> (a ~> b) -> (a ~> c) -- this is fine, except that polymorphism is going to force the definition of (.) to act uniformly in a way which is independent of the choice of types a,b,c
12:58:39 <DrSyzygy> Cale: Where's the naturality that composition shouldn't have to have? I'm not sure I see what you think the right way to express it should be.
12:58:56 <DrSyzygy> (wrote this just before you did)
12:59:36 <hpc> Cale: so it should be (Category (~>) a b, Category (~>) b c, Category (~>) a c)?
12:59:45 <Cale> Which means that you can only give one mapping on arrows which has to work at every triple of types, and not a separate mapping for every triple of types.
12:59:54 <Cale> for each*
13:00:15 * DrSyzygy starts to see the issue…
13:00:16 <Cale> Of course, there's no way you could hope to do that
13:00:28 <Cale> but that's the difference between this and a mathematical category
13:00:29 <hpc> Cale: so you are complaining that it doesn't attempt the impossible? :P
13:00:37 <hpc> i see
13:00:40 <Cale> Well, also, the fact that you have no control at all over the collection of objects
13:01:09 <Cale> You could do a much more accurate representation of finite or finitely presented categories at the value level.
13:01:29 <dolio> You can conceivably do better if you can analyze the objects, but that'd be contrary to parametricity.
13:01:42 <Cale> (but enforcing that the data provided actually specify a category might take some insane type hackery)
13:01:51 <dolio> If your objects must be Haskell types, that is.
13:02:42 <Cale> I think in the presence of GADTs, it's perhaps a little closer to the mathematical definition than without
13:02:48 <Cale> But it's still kinda weird
13:02:58 <hpc> i suppose the choice was to balance nearness to the mathematical concept vs ugliness of code
13:03:12 <hpc> i really don't get GADTs
13:03:20 <hpc> the code looks like it isn't even haskell anymore
13:03:37 <Cale> GADTs look like perfectly natural Haskell to me
13:03:59 <dolio> I don't think GADTs really buy you better categories.
13:04:07 <aristid> there are constructors. you give the types of the constructors. what's un-haskelly about that?
13:04:21 <Cale> Well, you can define  Cat A B  differently for various types A and B
13:04:26 <Cale> which is a little better
13:04:38 <hpc> aristid: it's the stuff like "data Foo where type Bar = Baz" that i don't get
13:04:42 <Cale> It gives you a little more control over what the sets of arrows are
13:04:59 <aristid> hpc: i didn't know that was part of GADTs
13:05:05 <Cale> and you can restrict which types have nonempty collections of arrows between them
13:05:09 <hpc> or is that type families?
13:05:17 <Cale> which lets you kind of represent finite categories
13:05:19 <hpc> i can never tell which is which
13:05:33 <aristid> hpc: oO they are completely different
13:05:42 <hpc> i don't use either
13:05:51 <hpc> due to the aforementioned confusingness
13:05:56 <Cale> hpc: You're confusing two different extensions
13:06:01 <dolio> They're not really completely different.
13:06:07 <Cale> hpc: and ending up with something that's not valid with any of them :)
13:06:14 <dolio> Because GHC bundles equality constraints into type families.
13:06:14 <hpc> Cale: oh, yay :P
13:06:25 <dolio> And equality constraints are sufficient to implement GADTs.
13:06:28 <Cale> there's  type declarations inside classes
13:06:38 <Cale> which is associated type synonyms
13:06:43 <Cale> and associated data declarations
13:06:53 <Cale> (and a generalisation of that which is type families)
13:07:20 <Cale> and then there's GADTs which is data <stuff> where <give explicit types for constructors>
13:07:43 <hpc> i remember having GADTs explained to me earlier, now
13:08:05 <hpc> GADTs don't give any additional expressiveness, do they?
13:08:15 <Cale> They give lots of additional expressiveness
13:08:16 <hpc> it's just a sugared form of data declarations
13:08:21 <hpc> how?
13:08:26 <Cale> because you can control the types of the results of the constructors
13:08:33 <hpc> OOOOH
13:09:00 <hpc> so you can have data Foo where Baz :: Int -> Just Foo?
13:09:32 <roconnor> rumour has it you can do everything GADTs can do in H98 by abusing haskell classes.
13:09:36 <applicative> hpc, you can see the difference if you dont use the GADTs pragma, ghc accepts them if they are just rewrites of Haskell 98, otherwise not....
13:09:55 <djahandarie> roconnor, I think it was that you can do /almost/ everything with H98 and abusing classes
13:10:05 <roconnor> oh?
13:10:11 <applicative> hpc, I mean type definitions with the GADT where.... syntax
13:10:19 <djahandarie> Yeah. Hell if I remember where the problems were though
13:12:33 <alpounet> except in lambdabot's code, has anyone seen some haskell code to return the first result of a google query ?
13:12:46 <roconnor> @go google first result
13:12:46 <lambdabot> Maybe you meant: google googleit do
13:12:52 <roconnor> @google google first result
13:12:53 <lambdabot> http://www.dailyblogtips.com/first-google-search-results/
13:12:53 <lambdabot> Title: Why You Must be the First, in Google’s Search Results at Least!
13:14:00 <Cale> hpc:  data Expr a where Const :: Integer -> Expr Integer; IsZero :: Expr Integer -> Expr Bool; IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
13:14:16 <Cale> hpc: You can do stuff like that, and then write   eval :: Expr a -> a
13:14:31 <aristid> Cale: minor suggestion: Const :: a -> Expr a
13:14:38 <Cale> aristid: sure
13:18:28 <applicative> hpc, the easy to see point above ^^^ is that though Expr :: * -> *, you get e.g. an Expr Bool in a way that doesn't follow the model for everything else 
13:22:05 <hpc> Cale: whoa
13:23:39 <hpc> okay, now i see the appeal of GADTs
13:35:27 <aristid> hpc: apfelmus has a (very slow) video on it
13:57:59 <copumpkin> :t join xor
13:58:00 <lambdabot> forall a. (Bits a) => a -> a
13:58:05 <copumpkin> > join xor 5
13:58:06 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:58:06 <lambdabot>    `Data.Bits.Bits a'
13:58:06 <lambdabot>      a...
13:58:11 <copumpkin> > join xor (5 :: Int)
13:58:12 <lambdabot>   0
13:58:37 <copumpkin> @check \x -> join xor (x :: Int) == 0
13:58:38 <lambdabot>   "OK, passed 500 tests."
13:58:40 <copumpkin> yay
13:59:39 <Nereid> :t join
13:59:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:59:45 <Nereid> oh right
14:01:00 <merijn> :t xor
14:01:01 <lambdabot> forall a. (Bits a) => a -> a -> a
14:02:18 <parcs> @check (==) <*> join (.&.)
14:02:19 <lambdabot>   Ambiguous occurrence `.&.'
14:02:19 <lambdabot>  It could refer to either `Data.Bits..&.', impor...
14:05:17 <ourfrank> Can wildcards be used within the exposed-modules field in a cabal file? For instance, "exposed-modules: Items.*".
14:05:37 <ourfrank> Where Items.First, Items.Second and Items.Third exist.
14:06:35 <ourfrank> It doesn't appear to work exactly like above, so I'm hoping there's something similar. I have lots of modules and am constantly adding new ones, so updating the cabal file is a chore.
14:23:19 <dons> ourfrank: no.
14:23:26 <dons> you have to list all of them :}
14:25:02 <danharaj> dons do you know if repa has a mailing list?
14:27:57 <stepkut> is haskell-mode maintained at the moment? I know that status changes often..
14:28:32 <Dr_H> I still find Haskell awesome
14:28:49 <stepkut> I still find OOP revolting
14:29:41 <parcs> i like both :)
14:30:15 <ion> lambdabot should switch to this implementation of QuickCheck. http://www.loctite.co.uk/cps/rde/xchg/henkel_uke/hs.xsl/teroson-quickcheck-4828.htm
14:31:06 <merijn> parcs: Don't blame OOP for everybody f-ing it up :p
14:31:10 <merijn> eh
14:31:14 <merijn> s/parcs/stepkut
14:32:11 <Rotaerk> OOP can be useful; an object is just a record of functions
14:32:22 <Rotaerk> but not everything needs to be designed that way..
14:33:39 <Dr_H> stepkut: try to implement template metaprogramming with function templates instead of type templates
14:34:44 <dons> danharaj: no. it doesn't have one.
14:34:51 <dons> danharaj: we can discuss on libraries@ though
14:35:00 <dons> danharaj: i'm going to work a bit on a tutorial this afternoon
14:35:30 <danharaj> dons: ah ok. I have a few questions to throw at people who know how repa works, so now I know where to throw them :)
15:24:33 <tromp_> :t fix
15:24:33 <lambdabot> forall a. (a -> a) -> a
15:50:48 <toocool> haskell looks cool, I think I am going to learn more
15:50:55 <zmv> hahaha
15:51:03 <zmv> toocool: yeah, it does :)
15:51:18 <toocool> do you think I can earn anything from it?
15:51:30 <happy4crazy> ha, earn or learn?
15:51:38 <toocool> earn!
15:51:41 <toocool> profit
15:51:50 <toocool> money
15:51:50 <toocool> :)
15:51:57 <toocool> I am PHP programmer
15:52:20 <KirinDave> toocool: The value proposition in question affects the answer.
15:52:29 <copumpkin> you might not be able to find an actual job doing haskell, but learning it tends to indicate to potential employers that you're smart and curious and don't just do stuff for the money ;)
15:52:38 <copumpkin> which given your question, doesn't necessarily seem true, but you can use it anyway
15:52:39 <KirinDave> toocool: Haskell lets you write a very small amount of code to get a very large amount of work done.
15:52:45 <hpc> they might also think you are an academic nutjob :P
15:52:49 <hpc> part of the fun
15:52:50 <KirinDave> toocool: Moreso than nearly any other language I've played with, and I have played with a considerable number.
15:53:14 <toocool> ok 
15:53:17 <toocool> what is the fun with haskell
15:53:23 <kmc> but you have to learn a lot before Haskell is a viable alternative for getting real work done
15:53:25 <toocool> because I find PHP to be very fun
15:53:26 <KirinDave> toocool: For startups, especially startups where a lot of middleware in your datacenter (storage, updates, combination & analysis), I suspect Haskell is a big win for small teams.
15:53:28 <happy4crazy> toocool: if you haven't tried it yet, learnyouahaskell.com is a great place to start
15:53:28 <toocool> with making web pages
15:53:30 <kmc> it is very slow going
15:53:34 <toocool> web applications
15:53:56 <KirinDave> toocool: Certainly Scala has been a big win for my team, and Scala is along the spectrum towards Haskell within the java world.
15:54:01 <zmv> toocool: also, you can be smug about being able to write Haskell code ;)
15:54:22 <danharaj> Vanilla Haskell has quite a few limitations
15:54:29 <Mathnerd314> is there a strictness monad? if so, a strictness monad transformer?
15:54:30 <danharaj> GHC is the language we actually love :p
15:54:48 <hpc> Mathnerd314: i think there is, in one of the parallel libs
15:54:53 <kmc> learning Haskell will negatively affect your ability to enjoy a job writing PHP or Java
15:54:56 <toocool> can I make anything useful with haskell
15:54:58 <toocool> for example?
15:55:03 <KirinDave> toocool: But if your goal is to write code in large groups, or write code on mobile, or write code to be run on client machines as a GUI, I suspect Haskell is more trouble than its worth.
15:55:03 <danharaj> yes.
15:55:04 <kmc> toocool, yes, it is a general-purpose programming language
15:55:06 <danharaj> Of course.
15:55:07 <hpc> toocool: http://hpc.dyndns-web.com:8000/
15:55:16 <hpc> website written from scratch in haskell
15:55:22 <kmc> to first approximation you can write anything in Haskell that you would write in C, Java, Python, whatever
15:55:35 <kmc> in fact you can easily call C libraries when Haskell libraries are lacking
15:55:45 <danharaj> This last weekend I whipped up a simulation of the n-body problem with an opengl output, and I'm going to add constraints and eventually rigid bodies to it.
15:55:46 <kmc> but there's a considerable number of Haskell libs by now: http://hackage.haskell.org/packages/archive/pkg-list.html
15:56:07 <KirinDave> I'm actually surprised by how rich the haskell ecosystem has become. It's not bad.
15:56:09 <kmc> i think, though, that if you start learning Haskell with the idea that you'll make an awesome 3D game or webapp, you'll be disappointed
15:56:25 <kmc> there is a ton of stuff to get through before you get to that point
15:56:38 <zmv> I actually prefer Lisp, but Haskell sure is the sexiest infix programming language around.
15:56:45 <danharaj> kmc: Quite. You have to relearn how to be a programmer.
15:56:48 <kmc> for most people learning Haskell basically involves learning how to program from scratch
15:56:52 <KirinDave> Yeah
15:56:56 <copumpkin> lol
15:56:57 <kmc> and un-learning a bunch of stuff you used to take for granted
15:57:07 <copumpkin> epic win
15:57:26 <danharaj> also
15:57:33 <KirinDave> I just watched that data parallel haskell talk from last year.
15:57:34 <copumpkin> (he's gone)
15:57:37 <happy4crazy> haha
15:57:38 <KirinDave> It was... genuinely exciting.
15:57:41 <danharaj> Haskell code is much harder to write than other code if you don't understand the problem.
15:57:52 <danharaj> In other languages it isn't hard to stumble your way through a broken implementation :p
15:58:08 <hpc> in Haskell, if you can somehow make it compile, it probably works :P
15:58:14 <happy4crazy> i think you guys need to work on your php->haskell pitch :)
15:58:16 <danharaj> that is totally not true :p
15:58:22 <copumpkin> [07:16:22 PM] toocool (5fd05681@gateway/web/freenode/ip.95.208.86.129) left IRC. (Quit: Page closed)
15:58:30 <kmc> happy4crazy, what makes you think we're salesmen? ;)
15:58:31 <KirinDave> happy4crazy: I think he was a PHP tool.
15:58:32 <danharaj> I spent yesterday getting rid of runtime failure after runtime failure.
15:58:40 <KirinDave> happy4crazy: Even Rubyists look down on those types.
15:58:50 <happy4crazy> true
15:58:57 <zmv> haha
15:59:05 <kmc> if you want to make webapps and make money, and you don't care about the secret inner mystery of programming, by all means keep using PHP
15:59:05 <KirinDave> And rightly so.
15:59:11 <zmv> I was a Rubyist long ago.
15:59:17 <happy4crazy> i started with ruby too actually
15:59:27 <KirinDave> zmv: The real mark of being a rubyist, does Zed Shaw hate yo?
15:59:30 <happy4crazy> and am now totally seduced by haskell :)
15:59:30 <kmc> haha
15:59:31 <Kaidelong> kmc: I'm not sure about this, a lot of the OOey things I learned already had a lot to do with pure functional programming and parametric polymorphism
15:59:33 <KirinDave> If so, you are a real rubyist. ;)
15:59:37 <kmc> a lot of people take that route happy4crazy
15:59:37 <Kaidelong> you can use some foundations
15:59:50 <zmv> KirinDave: I don't think so.
15:59:52 <copumpkin> I had zenspider call me a troll
15:59:55 <copumpkin> does that count?
15:59:58 <kmc> hahaha copumpkin
15:59:59 <copumpkin> I used to quite like ruby
15:59:59 <Kaidelong> C# in particular shows heavy haskell influence
16:00:04 <Kaidelong> probably concious too
16:00:14 <kmc> Kaidelong, fair enough, but a lot of the analogies to OOP are false and misleading
16:00:18 <kmc> and lead to a lot of bad designs by beginners
16:00:21 <happy4crazy> Kaidelong: Erik Meier talks about that a lot in his channel9 series on haskell
16:00:26 <kmc> so i encourage people to err on the side of forgetting everything ;P
16:00:50 <Kaidelong> the deep relationship between pure functional programming and object oriented programming is interesting though
16:00:58 <Kaidelong> since both are solutions to the same problem
16:01:01 <kmc> which relationship is that?
16:01:02 <Kaidelong> curbing side effects
16:01:16 <kmc> most real-world OOP designs are full of unnecessary side effects, though
16:01:20 <Kaidelong> yeah
16:01:22 <zmv> "OOP spelt backwards is POO"
16:01:22 <Kaidelong> that's a sad reality
16:01:36 <kmc> Date x = new Date; x.setYear(2011); x.setMonth(4);
16:01:42 <copumpkin> lol
16:01:45 <danharaj> Functional programming isn't about curbing side effects.
16:02:02 <copumpkin> it's about ERADICATING THEM
16:02:04 <copumpkin> NO RETURN
16:02:05 <kmc> Red Hat is pushing some new JVM language
16:02:08 <kmc> Ceylon
16:02:12 <danharaj> heh copumpkin
16:02:12 <hpc> haha, yeah
16:02:14 <hpc> it's gonna suck
16:02:16 <kmc> copumpkin, continuations? ;P
16:02:17 <Kaidelong> the side effects still exist in a way
16:02:23 <copumpkin> lol
16:02:43 <kmc> anyway it's like "what if we took ideas from Python and Scala until Java was 10% less shitty, and then stopped"
16:02:45 <Kaidelong> in OO programming the side effects happen when objects message other objects they encapsulate
16:02:45 <KirinDave> happy4crazy: See, you gotta try harder
16:02:56 <kmc> but one thing they do, is make the "default" syntax for class member variables read-only
16:03:02 <kmc> and you have to explicitly declare something as mutable
16:03:07 <KirinDave> happy4crazy: Like this? http://oppugn.us/posts/1282122987.html That's almost exclusively about me, Kevin Clark, Evan Pheonix, and to some extent Cliff Moon.
16:03:33 <Kaidelong> with functional programming the side effects happen when a value of a side effecting type is run
16:03:39 <Kaidelong> err
16:03:40 <KirinDave> happy4crazy: (Somehow Tom Preston-Werner got a free pass; probably because Zed Shaw doesn't want to lose his github account)
16:03:41 <Kaidelong> pure functional
16:03:49 <Kaidelong> in the haskell sense
16:04:20 <dolio> Pure functional programs don't have side effects.
16:04:25 <Kaidelong> either way you try to have this guarantee that you have referentially transparent ways to generate a side effecting thing
16:04:28 <dolio> They just have effects.
16:04:38 <Kaidelong> constructors in OO
16:04:49 <Kaidelong> functions that return IOs in something like Haskell
16:04:52 <ion> Date x = new Date; x.setYear(2011); x.setMonth(4); x.terminalBeep();
16:05:14 <KirinDave> ion: I see setYear and I shudder.
16:05:16 <Mathnerd314> hpc: are you sure there is?
16:05:27 <KirinDave> ion: At least no one in Java does that seriously anymore. Bless JodaTime for that.
16:05:28 <roconnor> > let {i x y = (x, y,1); times f g x y = let {(fx, fy, fd) = f x y; (gx, gy, gd) = g x y} in (fx*gx, fy*gy, fx*gd + fd*gy)} in times i i x y
16:05:29 <lambdabot>   (x * x,y * y,x * 1 + 1 * y)
16:05:30 <hpc> whatam i sure of?
16:05:43 <roconnor> > let {i x y = (x, y,1); times f g x y = let {(fx, fy, fd) = f x y; (gx, gy, gd) = g x y} in (fx*gx, fy*gy, fx*gd + fd*gy)} in times (times i i) i) x y
16:05:44 <lambdabot>   <no location info>: parse error on input `)'
16:05:44 <Kaidelong> ion: So long as that is not done in static scope it is "contained" in an object instance
16:05:50 <roconnor> > let {i x y = (x, y,1); times f g x y = let {(fx, fy, fd) = f x y; (gx, gy, gd) = g x y} in (fx*gx, fy*gy, fx*gd + fd*gy)} in times (times i i) i x y
16:05:51 <lambdabot>   (x * x * x,y * y * y,x * x * 1 + (x * 1 + 1 * y) * y)
16:06:07 <kmc> what
16:06:14 <Kaidelong> and presumable you can't observe what happened in *that* instance of the object by constructing a new instance
16:06:21 <Mathnerd314> hpc: that there is a strictness monad in one of the parallel libraries
16:06:36 <hpc> Mathnerd314: i am not positive
16:06:42 <Kaidelong> you would have to have a reference that lets you observe it (in)directly
16:06:47 <hpc> but i vaguely recall there being one
16:07:02 <kmc> Control.Parallel.Strategies was reworked to use an "Eval" monad
16:07:05 <kmc> which is a strict identity monad
16:07:17 <hpc> that might be it
16:07:39 <Kaidelong> just like putStrLn "foo" being run shouldn't affect what putStrLn "bar" returns
16:07:42 <kmc> there's a paper on this
16:07:45 <kmc> "seq no more" or something
16:07:51 <kmc> data Eval a = Eval a; (Eval x) >>= f = Eval (f x)
16:08:05 <Kaidelong> err, what value putStrLn "bar" actually is
16:08:07 <kmc> it's a strict identity monad because (>>=) is strict in its first argument, i.e. it forces the Eval constructor
16:08:39 <Kaidelong> anyway it's lose but the basic idea for both is that you encapsulate state neatly so that it can't leak unpredictably throughout your program
16:09:06 <Kaidelong> stuff like global mutable variables, singleton pattern, etc, subvert this
16:09:25 <Kaidelong> similar to things like unsafePerformIO
16:09:48 <Kaidelong> it's just really conventional to use those procedural crutches in the OO world
16:09:56 <Kaidelong> unfortunately
16:10:07 <kmc> shrug
16:10:18 <dolio> I'm not sure how good this analogy is.
16:10:20 <Kaidelong> it's loose*
16:10:27 <kmc> i've learned that i can talk until i'm blue about how everyone else is programming wrong, and it doesn't change anything
16:10:38 <tomh> a Chan is a reference to a channel right? 
16:10:40 <Kaidelong> dolio: not sure it's an analogy so much as a common motivation
16:10:47 <tomh> are the write operations atomically?
16:10:49 <dolio> Either way.
16:10:51 <tomh> (and read)
16:10:56 <kmc> tomh, yes
16:10:58 <Kaidelong> OOP has a fundamentally similar motivation to pure functional programming
16:11:00 <dolio> OO still makes heavy use of side effects.
16:11:04 <tomh> ok cool
16:11:06 <Kaidelong> I think the latter does it better though
16:11:15 <kmc> in GHC, Chan is implemented using MVar
16:11:22 <Kaidelong> dolio: but ideally they are only observable if you have references to the objects that are changing
16:11:23 <dolio> Where I call functions not for the result, but for what happens because I called them.
16:11:36 <kmc> tomh, what specific sort of non-atomic behavior do you wish to avoid?
16:11:37 <dolio> That doesn't happen in a good Haskell program.
16:11:47 <dolio> When I call putStrLn, I call it for the IO () result.
16:12:01 <tomh> kmc, I just need to have a channel to communicate stuff to the mainthread
16:12:25 <dolio> IO, viewed as a language in itself, isn't great in that respect.
16:12:29 <tomh> not sure if I should take the STM TChan or the normal chan :)
16:12:40 <kmc> they're both designed for concurrent use
16:12:41 <dolio> But it's minimized.
16:12:57 <tomh> yeah, but in which scenario you should use one over the other?
16:13:08 <kmc> use TChan if you're already using STM, and you need to build single transactions that incorporate multiple channels, or a channel and a TVar, etc.
16:13:11 <Bustakheops> hi, i have just 1 question plz : what's the complexity of List.sort ? O(n) isn't?
16:13:29 <Kaidelong> nlog(n)
16:13:30 <tomh> ok
16:13:33 <kmc> Bustakheops, you can't sort a list by pairwise comparison in less than n log(n)
16:13:34 <tomh> im not using that yet
16:13:36 <Kaidelong> it is a lazy merge sort
16:13:40 <Bustakheops> ok thx :)
16:13:40 <dolio> And the way OO is evolving, the standard advice isn't, "put your side effects in an object."
16:13:43 <Kaidelong> so if you don't demand the whole list, it might take less time
16:13:54 <dolio> It's, "don't use side effects at all, unless you can't help it."
16:14:01 <kmc> tomh, if your atomic operations are single channel reads / writes, Chan is just as good (and simpler and probably faster)
16:14:13 <dolio> Which has been the 'pure functional' approach all along.
16:14:16 <Kaidelong> dolio: Yeah, but if you have to have something stateful, good practice is still to use an object
16:14:28 <tomh> kmc, at this point yes
16:14:31 <Kaidelong> IE pseudorandom number generators
16:14:33 <kmc> i'm not sure which java mill school dolio is learning this standard advice from ;)
16:14:47 * roconnor tries to figure out how to do divied differences on elliptic curves
16:14:47 <Kaidelong> kmc: Java has been slow to catch up on that
16:15:03 <Kaidelong> C#, Python, and the like, are getting to be truly multiparadigm
16:15:22 <kmc> yeah, the "paradigm" idea is old and useless
16:15:23 <Kaidelong> probably C# most dramatically
16:15:26 <dolio> kmc: Well, not necessarily the Java mill standard. It's the, "OOP has evolved in the last 20 years" apologist standard.
16:15:40 <kmc> Linux is coded with object-oriented, functional, aspect-oriented style, in C
16:15:48 <dolio> Which isn't reflected in the languages, really.
16:15:52 <kmc> also with templated generics and declarative EDSLs
16:17:26 <aristid> dolio: except maybe C#?
16:17:51 <Kaidelong> anyway I remember once mentioning in ##csharp that my teammates were upset about my "functional" use of things like C#'s equivalents of map, fold etc
16:18:00 <Kaidelong> and their reply was something like "tell them to get with the times"
16:18:10 <dolio> aristid: Maybe. I don't follow many OO languages that closely.
16:18:13 <kmc> Kaidelong, why can't you write 50 lines of visitor factory pattern like everyone else
16:18:15 <Kaidelong> and "if they don't learn functional programming they'll be irrelevant"
16:18:25 <kmc> why do you have to use all this incomprehensible academic "map" mumbo jumbo
16:18:28 <dolio> There are hybrid languages like Scala, too.
16:19:10 <Kaidelong> so that's a promising sign for us types
16:19:27 <Kaidelong> there are people in the "mainstream" who think functional programming is relevant and important
16:19:32 <DasIch> functional programming is not really doable in every language though
16:19:36 <Kaidelong> Erik Meijer might be able to take some credit for this
16:19:45 <DasIch> in python function calls are way too expensive for that
16:19:45 <kmc> is ##csharp taken to be representative of "the C# community"?
16:19:48 <kmc> or of "the mainstream"?
16:19:53 <Kaidelong> kmc: I do not know actually
16:20:01 <Kaidelong> they probably aren't most of the commercial dev people
16:20:05 <Kaidelong> but more the hobbyists
16:20:07 <Kaidelong> but OTOH
16:20:14 <Kaidelong> they will be the next generation of C# programmers
16:20:14 <dolio> kmc: I did read a C++ best practices book not long ago where one of the sections was, "use const everywhere."
16:20:30 <Kaidelong> or are it already
16:20:47 <dolio> So even some C++ folks are on to the immutability by default and whatnot.
16:20:48 <Kaidelong> and you can see similar sympathies at places like MSDN and Channel9
16:20:52 <danharaj> I'm waiting for the language that replaces Haskell.
16:20:54 <Kaidelong> dolio: I noticed
16:21:04 <dolio> Except their language doesn't take the right stance.
16:21:13 <Kaidelong> looks like C++ might see a rennaisance as a functional language to a degree
16:21:15 <kmc> danharaj, nonsense, Blub, i mean Haskell, is perfect
16:21:35 <kmc> shruggggg
16:22:01 <Philippa> Kaidelong: is this a bit like rusty nails seeing a rennaisance as sex toys for masochists?
16:22:19 <Kaidelong> I guess
16:22:21 <geheimdienst> lol, very well put
16:22:28 <Kaidelong> at the very least as far as syntax goes
16:22:32 <Kaidelong> but also other things
16:22:45 <Kaidelong> like fossils from C
16:23:41 <geheimdienst> @remember Philippa C++ seeing a renaissance as a functional language, is this a bit like rusty nails seeing a renaissance as sex toys for masochists?
16:23:41 <lambdabot> Good to know.
16:24:18 <aristid> geheimdienst: you quote-modifier!
16:24:56 <geheimdienst> well i put in kaidelong's context. posterity ain't gonna know what "this" refers to ...
16:25:22 <Philippa> it's normal to just paste both lines together though
16:25:33 <danharaj> you're normal
16:25:53 <Philippa> haven't heard anyone claim that in a while :-)
16:26:04 <dolio> Well, the 'renaissance' will be (at best) people writing better C++ by taking some cues from functional techniques, I imagine.
16:26:17 <dolio> It's too late to make C++ a 'functional language.'
16:26:21 <Kaide> well yeah
16:26:24 <danharaj> and subsequently crushed beneath several pages of template errors and cumbersome syntax.
16:26:26 <Kaide> that's all I meant actually
16:26:34 <geheimdienst> and c++ slowly getting a few functional features, like closures
16:26:47 <aristid> dolio: c++ templates are a functional (but crappy) language
16:26:57 <Kaide> but it definitely seems like there is a real and irreversible trend toward functional programming as a normal thing to do
16:27:09 <dolio> Yes, but they're a functional language for metaprogramming.
16:27:20 <aristid> dolio: yeah
16:27:23 <monochrom> it's too late to make c++ a functional language now. let's try again earlier tomorrow morning XD
16:27:38 <bockmabe> mono
16:27:41 <bockmabe> lol
16:27:58 <dolio> No one's going to approve of you installing Visual Studio on their machine to act as an interpreter for your program written in templates.
16:28:43 <aristid> dolio: especially not if it's a few million times slower and eats RAM like a polar bear eats fish
16:28:53 <dolio> Heh.
16:28:58 <danharaj> ... with bear claws?
16:34:49 <aristid> danharaj: yeah.
16:35:37 <danharaj> le sigh
16:35:49 <danharaj> I have to sit down and learn lagrangian mechanics.
16:35:56 <danharaj> And then discrete lagrangian mechanics.
16:36:05 <danharaj> And then finally add constraints to my simulation :|
16:44:20 <crystal-cola> danharaj: hwo do you do constraints?
16:44:45 <ddarius> Lagrangian mechanics is something that one should learn and will make your life simpler.
16:45:13 <crystal-cola> can you do consrtaints with it? Like a chain of particles for example?
16:48:33 <Dr_H> can lambdabot somehow return infix notation?
16:48:46 <dmwit> Which plugin?
16:48:51 <dmwit> And what do you mean by "return"?
16:49:04 <dmwit> What's a sample input/output pair?
16:50:50 <Dr_H> I mean unpl a pl'd expression and get infix notation instead of prefix
16:50:57 <Dr_H> just curious
16:51:11 <dmwit> ?unpl (+)
16:51:11 <lambdabot> (+)
16:51:49 <dmwit> Anyway, no, I don't know of any way to massage the output of ?unpl.
16:51:50 <hpc> @unpl (+) . (-)
16:51:50 <lambdabot> (\ c -> (+) ((-) c))
16:52:01 <hpc> hmm
16:52:20 <hpc> the transformation should be easy, except when subtraction is involved
16:52:23 <shachaf>  @unpl is the easy one anyway. :-)
16:54:10 <Dr_H> like to get \ x y -> x `f` y as a result instead of \ x y -> f x y
16:54:34 <ddarius> @unpl (f .) . (+)
16:54:35 <lambdabot> (\ d h -> f (d + h))
16:55:25 <dmwit> ?unpl \x y -> x + y
16:55:25 <lambdabot> \ x y -> x + y
16:55:36 <dmwit> ?unpl \x -> (x +)
16:55:37 <lambdabot> \ x a -> x + a
16:55:53 <shachaf> @unpl (+) x y
16:55:53 <lambdabot> x + y
16:56:15 <Dr_H> @unpl \x y -> (f) x y
16:56:15 <lambdabot> \ x y -> f x y
16:56:25 <danharaj> crystal-cola: You can do various things to do constraints depending on how complicated it is. Holonomic constraints are easy to do.
16:56:37 <Dr_H> no, it's not the parentheses...
16:56:44 <shachaf> Dr_H: If you want f to be infix, just make it infix yourself. That's not really what @unpl is for.
16:57:00 <parcs> Dr_H: substitute (*) for r
16:57:02 <parcs> f*
16:57:07 <shachaf> Dr_H: It's not the parentheses, it's the fact that f is a prefix function, so it uses it as such.
16:58:01 <Kaidelong> hmm, I thought abstraction elimination was efficient
16:58:14 <Kaidelong> or do you mean it's less easy than unpl in that it is harder to understand?
16:59:04 <shachaf> It's generally much more obvious what @unpl will do without thinking about it.
16:59:12 <Kaidelong> @unpl ((*) .) . (+)
16:59:12 <lambdabot> (\ d g -> (*) (d + g))
17:00:12 <shachaf> Given a sane input, that is. :-) Maybe the issue is that most @unpl-ed code is sane but only a small subset of @pl-ed code is.
17:01:44 <Dr_H> so basically (+), (++), (+++) and any other function corresponding (++++++++....+) will be unpl'd infix
17:02:00 <shachaf> Dr_H: ...And any other infix function.
17:02:23 <shachaf> @unpl (*-$$&^%) a b
17:02:23 <lambdabot> a *-$$&^% b
17:02:37 <dolio> @pl \x y z -> (x + y) * z
17:02:37 <lambdabot> ((*) .) . (+)
17:02:49 <dolio> @. unpl pl \x y z -> (x + y) * z
17:02:49 <lambdabot> (\ d g -> (*) (d + g))
17:03:46 <_Ray_> please tell me *-$$&^% is a syntax error
17:03:58 <_Ray_> I don't think that's even valid Perl. And that's saying a lot.
17:04:07 <kmc> @let (*-$$&^%) = (+) in 2 *-$$&^% 3
17:04:07 <lambdabot>   Parse error: in
17:04:11 <kmc> > let (*-$$&^%) = (+) in 2 *-$$&^% 3
17:04:12 <lambdabot>   5
17:04:15 <dolio> Why would it be a syntax error?
17:04:56 <_Ray_> hrmph. one can simply walk into mor^H^H^H^H^H^H^H redefine nonalphabetical chars?
17:04:56 <dolio> Should wNbk83Jksl8374Lakjvmejdfahkbe also be a syntax error?
17:05:15 <kmc> _Ray_, Haskell lets you define infix operators
17:05:34 <kmc> infix operators get to use most punctuation symbols, the same way prefix function names get to use most alphanumeric characters
17:06:04 <_Ray_> can an infix operator use alphanumeric stuff? or must it be wrapped in backticks?
17:07:11 <Dr_H> what does `ap` between quotes do? what does (`ap` subtract 1) mean?
17:07:29 <_Ray_> make it infix
17:07:36 <_Ray_> elem a b <=> a `elem` b
17:08:37 <Dr_H> @pl fix (\fibonacci x -> if x == 0 then 0 else if x == 1 then 1 else let x1 = x-1 in (let x2 = x-2 in ((fibonacci x1) + (fibonacci x2))))
17:08:38 <lambdabot> fix (ap (flip if' 0 . (0 ==)) . ap (flip if' 1 . (1 ==)) . (`ap` subtract 1) . (. subtract 2) . flip . (flip =<< (((.) . (+)) .)))
17:08:50 <Dr_H> what does (`ap` sutract 1) do here?
17:08:58 <Dr_H> b
17:09:00 <shachaf> @ty (`ap` subtract 1) -- This.
17:09:01 <lambdabot> forall a b. (Num a) => (a -> a -> b) -> a -> b
17:09:36 <shachaf> ap x y z = x z (y z)
17:09:53 <doserj> lol, the other parts you did understand?
17:09:57 <parcs> > (`ap` subtract 1) 5
17:09:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
17:09:58 <lambdabot>    arising from a use of `...
17:10:02 <parcs> > (`ap` subtract 1) (+) 5
17:10:03 <lambdabot>   9
17:11:38 <Dr_H> so x is subtract 1, z is 5 and y is (+)?
17:12:21 <parcs> well no
17:12:29 <parcs> `f` x is actually flip f x
17:13:16 <Dr_H> so (`ap` subtract 1) (+) is equivalent with (flip ap subtract 1) (+) ?
17:13:29 <parcs> yeah
17:13:31 <Dr_H> > (flip ap subtract 1) (+) 5
17:13:33 <lambdabot>   1
17:13:49 <Dr_H> > flip (ap subtract 1) (+) 5
17:13:51 <lambdabot>   -4
17:13:55 <Dr_H> wow
17:13:57 <shachaf> No, (flip ap (subtract 1)) (+).
17:14:08 <Dr_H> > (flip ap (subtract 1)) (+) 5
17:14:10 <lambdabot>   9
17:14:11 <shachaf> Remember that application binds (almost) tightest.
17:14:14 <Dr_H> I see, thank you
17:14:44 <Dr_H> I'm not at precedence yet in the Haskell tutorial, what binds stronger than application?
17:14:55 <zomg> Superglue
17:15:19 <shachaf> Dr_H: You'll find out when you need to find out.
17:17:35 <Dr_H> shachaf: wise answer :)
17:24:19 <_Ray_> Hrm. :t error is [Char] -> a. What is that a?
17:24:31 <copumpkin> anything you want it to be
17:24:49 <shachaf> In particular, Maybe (Either [Int] [Integer])
17:25:01 <_Ray_> I tried :t (error :: Integer) and it screwed up... should I try error :: [Char] -> Integer?
17:25:13 <_Ray_> yes
17:25:14 <_Ray_> yes I should.
17:25:30 <shachaf> Well, there's no reason to give it an explicit type signature.
17:25:31 <_Ray_> that was fun. thanks :)
17:25:36 <shachaf> Also, it's an evil function. Don't use it.
17:25:47 <_Ray_> right, I just wanted :t to stop whining :( why is it evil?
17:25:53 <copumpkin> it never returns!
17:25:57 <copumpkin> and indeed it can't
17:26:02 <_Ray_> scumbag error.
17:26:06 <copumpkin> since it has to produce a value of type a, no matter what a is
17:26:11 <copumpkin> exactly!
17:26:26 <_Ray_> if a were guaranteed to be Pointed... could it return?
17:26:30 <_Ray_> wait, no, not even then
17:26:33 <shachaf> copumpkin: Oh, you're going to make one of those comics now, aren't you.
17:26:49 <copumpkin> no no
17:27:08 <copumpkin> kinda tired
17:27:29 <shachaf> _Ray_: The whole point of it is that it doesn't return.
17:27:38 <_Ray_> in "operations that can fail", I should almost always use a Maybe, ne?
17:27:52 <hpc> _Ray_: depends on what information you need from the failure
17:27:53 <shachaf> Maybe, or Either SomeErrorType, or swomething.
17:28:00 <hpc> if failure itself is enough, use Maybe
17:28:08 <_Ray_> and have faith in the lambda, that it'll all work out if things are passed Nothing
17:28:08 <hpc> Either Foo a gives you a Foo back when you fail
17:28:40 <_Ray_> do things "tend to work out", when one retroactively switches something to return Maybe since it can now error?
17:29:28 <_Ray_> and another question. error doesn't return. but MUST it be evaluated?
17:30:07 <_Ray_> ah, no, needn't. if True then 1 else error "foo" doesn't error
17:32:33 <kmc> (error "foo") is a value which, if forced, kills the program
17:33:03 <sshc> > error "foo"
17:33:04 <lambdabot>   *Exception: foo
17:33:07 * sshc has the perfect idea
17:33:11 <sshc> > fix error
17:33:12 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
17:33:16 <kmc> hehehe
17:33:16 <_Ray_> haha
17:33:20 <kmc> i love that one
17:33:47 <kmc> _Ray_, things don't "just work" when you add a Maybe to the return type
17:33:52 <_Ray_> :(
17:33:59 <shachaf> That's very misleading. It looks like it returns the string "*Exception: ..."
17:33:59 <kmc> because all of your previously successful paths need to now wrap their result in "Just"
17:34:16 <_Ray_> ah, you're right :(
17:34:18 <kmc> > error "foo"
17:34:19 <lambdabot>   *Exception: foo
17:34:21 <kmc> > error "foo" :: String
17:34:22 <lambdabot>   "*Exception: foo
17:34:33 * _Ray_ doesn't understand seq, so is wondering why if True then "bar" else (seq error "foo") doesn't error
17:34:33 <ion> :t fix error
17:34:34 <lambdabot> [Char]
17:34:53 <kmc> (seq error "foo") is equivalent to "foo"
17:35:00 <kmc> forcing (seq a b) forces a and then b
17:35:06 <kmc> and returns the result of forcing b
17:35:23 <kmc> so you're forcing «error» and then «"foo"» and returning «"foo"»
17:35:42 <kmc> and forcing "error" itself is fine... error is a function, it's probably already in a normal form
17:35:52 <kmc> > seq print 5
17:35:53 <lambdabot>   5
17:35:53 <_Ray_> that makes so much sense it's embarassing
17:36:09 <kmc> anyway whatever you put after "else" will not matter
17:36:25 <kmc> > let x = error "foo" in if True then "bar" else x
17:36:26 <lambdabot>   "bar"
17:36:30 <kmc> > let x = error "foo" in x `seq` (if True then "bar" else x)
17:36:31 <lambdabot>   "*Exception: foo
17:36:38 <kmc> > let !x = error "foo" in if True then "bar" else x
17:36:39 <lambdabot>   "*Exception: foo
17:36:48 * shachaf still reads "!" as "not".
17:36:54 <shachaf> I wonder if that habit will ever go away.
17:37:07 <_Ray_> what is !x? 
17:37:08 <koeien> it will, i am very annoyed by this practice in C
17:37:11 <koeien> it is very easy to miss
17:37:59 <ion> I on the other hand can’t help reading \bot as ⊥.
17:38:18 * _Ray_ doesn't understand why the second one errors out. I'm forcing (if True then "bar" else x). doesn't this evaluate to "bar"?
17:38:33 <_Ray_> oh, no, x `seq`
17:38:34 <kmc> _Ray_, the second on being the first one with "seq"?
17:38:51 <kmc> _Ray_, !x is a "bang pattern", a GHC extension
17:38:55 <kmc> see the manual for details
17:38:55 <maurer_> _Ray_: ! causes x to be strict in the binding, forcing error "foo"
17:39:02 <_Ray_> x `seq` (if...) <=> seq x (if...)
17:39:15 <_Ray_> incidentally, what does 'seq' stand for?
17:39:17 <kmc> it desugars to something involving "seq", though the precise desugaring depends on the context in which you use it
17:39:21 <ion> > let !x = error "foo" in 42 --the “in …” part is not relevant here
17:39:22 <lambdabot>   *Exception: foo
17:39:50 <kmc> in this case it's «let !x = s in t» ⇒ «let x = s in seq x t»
17:40:44 <_Ray_> interesting
17:40:53 <_Ray_> gets rid of lazyness
17:41:21 <ion> I need a ! for myself
17:42:22 <ion> > (\!x -> error "foo") 42
17:42:23 <lambdabot>   <no location info>: parse error on input `->'
17:42:25 <ion> > (\ !x -> error "foo") 42
17:42:26 <lambdabot>   *Exception: foo
17:42:44 <ion> Whoops, a brainfart.
17:44:14 <mjo> Is there any good way to enforce a positive (>0) constraint on a field? Aside from hiding the constructor or erroring?
17:44:23 <ion> > (\ !x -> error "foo")
17:44:23 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
17:44:24 <lambdabot>    arising from a use of `...
17:51:15 <danharaj> Anyone with opengl experience: how should I go about doing text?
17:52:21 <kmc> i have used http://gltt.sourceforge.net/ with minimal success
17:52:23 <kmc> at least i think that's the one
18:09:02 <brbr> how widely used are monoids and functors in open source haskell?
18:09:34 <copumpkin> functors are ubiquitous
18:09:43 <copumpkin> monoids are pretty common, depending on whose haskell you're reading though
18:09:45 <kmc> lists are functors and monoids
18:10:01 <kmc> but maybe you're interested in "how often are the generic monoid / functor APIs used"
18:11:41 <brbr> interesting.  i am learning about them in LYAH, and it's not obvious to me why you would want to use them in a program
18:12:00 <brbr> maybe there's a whole world of abstraction that i am about to dive into
18:12:23 <brbr> and i've just learned that I am standing at the edge of the plank
18:12:46 <copumpkin> there is a whole world of abstraction you're about to dive into :)
18:13:29 <danharaj> map is the second most important combinator
18:13:32 <danharaj> after (.) :p
18:14:12 <danharaj> and when I say map, I mean fmap.
18:14:30 * copumpkin fmaps furiously
18:15:06 <jmcarthur> :t fmap fmap fmap
18:15:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:15:30 <danharaj> :t (. (. f))
18:15:31 <lambdabot> forall b a b1 (f :: * -> *). (SimpleReflect.FromExpr (f a), Functor f) => (f b1 -> b) -> (a -> b1) -> b
18:15:36 <jmcarthur> @let furiously f = f f f
18:15:37 <lambdabot>  <local>:5:14:
18:15:37 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -...
18:15:41 <jmcarthur> aw :(
18:15:52 <copumpkin> @let thrice f = f . f . f
18:15:53 <lambdabot>  Defined.
18:15:57 <copumpkin> I love playing with that
18:15:58 <jmcarthur> not the same
18:16:04 <copumpkin> > thrice thrice (+1) 0
18:16:06 <lambdabot>   27
18:16:11 <jmcarthur> hehe
18:16:15 <kmc> brbr, basically, we have all these APIs that generalize over many types
18:16:22 <kmc> like Functor and Monoid and Monad and Applicative
18:16:33 <kmc> you don't have to use them, you can usually accomplish what you want to do using concrete type-specific functions
18:16:44 <kmc> but sometimes you can write more general, useful code with the more generic APIs
18:16:47 <copumpkin> > thrice thrice thrice (+1) 0
18:16:49 <kmc> the same phenomenon occurs in every language
18:16:50 <lambdabot>   *Exception: stack overflow
18:16:57 <copumpkin> mmm
18:16:58 <danharaj> for me, it's a matter of laziness
18:17:00 <kmc> it's just in Haskell the generic APIs have weird names from math, and so they generate a lot of controversy
18:17:21 <danharaj> it's easier to use the general functions than it is to come up with your own specific mess.
18:17:28 <jmcarthur> as if the non-mathy names are any better
18:17:28 <danharaj> you just have to get used to thinking with portals
18:17:35 <shachaf> @ty let furiously :: (forall a b c. (b -> c) -> (a -> b) -> a -> c) -> (b -> c) -> (a -> d -> b) -> a -> d -> c; furiously f = f f f in furiously
18:17:35 <lambdabot> forall b c a d. (forall a1 b1 c1. (b1 -> c1) -> (a1 -> b1) -> a1 -> c1) -> (b -> c) -> (a -> d -> b) -> a -> d -> c
18:18:03 <jmcarthur> @ty let furiously :: (forall a b c. (b -> c) -> (a -> b) -> a -> c) -> (b -> c) -> (a -> d -> b) -> a -> d -> c; furiously f = f f f in furiously fmap
18:18:04 <lambdabot> forall b c a d. (b -> c) -> (a -> d -> b) -> a -> d -> c
18:18:38 <copumpkin> @let furiously :: (forall a b c. (b -> c) -> (a -> b) -> a -> c) -> (b -> c) -> (a -> d -> b) -> a -> d -> c; furiously f = f f f
18:18:38 <lambdabot>   TypeOperators is not enabled
18:18:45 <copumpkin> o.O
18:18:49 <jmcarthur> wha
18:18:55 <brbr> it greatly increases the landscape of the language though
18:19:01 <djahandarie> You fools, you didn't quantify d
18:19:04 <brbr> which is exciting so far
18:19:06 <danharaj> brbr: what do you mean?
18:19:14 <shachaf> djahandarie: Also not the outer a,b,c.
18:19:17 <copumpkin> @ty let furiously :: (forall a b c. (b -> c) -> (a -> b) -> a -> c) -> (b -> c) -> (a -> d -> b) -> a -> d -> c; furiously f = f f f in furiously (.) thrice
18:19:18 <lambdabot> forall b a d. (a -> d -> b -> b) -> a -> d -> b -> b
18:19:23 <copumpkin> damn right
18:19:29 <danharaj> you guys and your type gymnastics
18:19:33 <djahandarie> Oh, right.
18:19:40 <jmcarthur> @let boobs = (.).(.)
18:19:41 <lambdabot>  Defined.
18:19:55 <danharaj> :t ( . ) ( . )
18:19:56 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
18:19:56 <copumpkin> @let totalReclal = (.).(.).(.)
18:19:58 <lambdabot>  Defined.
18:20:00 <copumpkin> man, I fail
18:20:02 <jmcarthur>  @ty let furiously :: (forall a b c. (b -> c) -> (a -> b) -> a -> c) -> (b -> c) -> (a -> d -> b) -> a -> d -> c; furiously f = f f f in furiously boobs thrice
18:20:03 <copumpkin> Reclal?
18:20:16 <brbr> danharaj: Monoid, Functor, .. these APIs feel like design patterns for types and functions which feel like part of the language
18:20:30 <jmcarthur> occurs check
18:20:52 <jmcarthur> @undef
18:20:56 <copumpkin> :(
18:21:01 <ddarius> My BIH traversal code just got much simpler.
18:21:16 <danharaj> brbr: I guess you could think of them as design patterns... but they're not really part of the language. They're intrinsic to the types they're defined over themselves.
18:22:03 <danharaj> They're not defined with any special magic. You could write them yourself.
18:22:54 <brbr> danharaj: They aren't syntax, but they sure are close to Haskell as a language.
18:23:05 <kmc> what's a "design pattern" anyway?
18:23:11 <jmcarthur> in what sense are the 
18:23:17 <jmcarthur> *they "close" to haskell
18:23:17 <kmc> in common usage a "design pattern" is a standard boilerplate workaround for a language flaw
18:23:25 <danharaj> kmc: heh :p
18:23:51 <brbr> kmc: yeah which seems like haskell is trying to correct
18:24:33 <danharaj> Haskell's type system is more expressive, so it lets you say more things about your types, which makes your life easier when you work with them.
18:24:38 <brbr> jmcarthur: i have only seen these abstractions in Haskell, but i could see them being used in other languages unknown to me
18:24:57 <jmcarthur> i don't think i would describe something as a design pattern if it can be captured by the language instead of replicated every time you use it
18:25:16 <jmcarthur> *duplicated
18:25:33 <kmc> brbr, don't worry, we have our own flaws
18:25:50 <danharaj> Instead of thinking of Functor and stuff as language landscape, think of them as being extra definitions for the data structures.
18:26:11 <brbr> jmcarthur: you mean you wouldn't call something a design pattern if it could be encoded with types and type APIs ?
18:30:46 <jmcarthur> brbr: i mean i wouldn't call it a design pattern unless it necessarily violates "Don't Repeat Yourself"
18:31:32 <jmcarthur> (we have plenty in haskell, but i think most of them don't have names)
18:32:12 <brbr> if there are plenty, how do they not violate "Don't Repeat Yourself" ? :P
18:32:19 <jmcarthur> they do
18:32:54 <jmcarthur> for example, writing type class instances for newtypes is often highly repetitive, and if you do it often you will notice that you tend to do very similar things each time
18:34:50 <brbr> how does the abstraction work there?
18:35:19 <jmcarthur> huh?
18:35:34 <kmc> we have design patterns in Haskell, it's just that people work on eliminating them rather than writing books about them and getting rich
18:37:29 <brbr> if you have a type and you make it an instance of some stuff, then you newtype that type, are you forced to define instances again for the newtype ?
18:37:40 <jmcarthur> some
18:37:52 <jmcarthur> GeneralizedNewtypeDeriving eliminates a lot of that boilerplate
18:38:18 <jmcarthur> like kmc said, we try to actually eliminate such things when we can ;)
18:38:30 <brbr> do you have a reference? wiki page?
18:38:44 <brbr> which is awesome
18:38:46 <jmcarthur> unfortunately, GNtD doesn't work for all kinds of type classes
18:38:50 <kmc> GHC manual explains all extensions including GeneralizedNewtypeDeriving
18:38:58 <copumpkin> not all!
18:39:16 <copumpkin> I dare you to find RelaxedPolyRec
18:39:24 <aristid> kmc: plus, getting rich with a book on how to write boilerplate in haskell would be pretty hard
18:39:29 <jmcarthur> copumpkin: :o
18:40:11 <brbr> I take it there are mixed feelings in the community about LYAH and RWH ..?
18:40:41 <kmc> i think most of us are fans of of both books
18:41:04 <kmc> they're pretty different, i encourage people to look at both and decide which they'd rather read first
18:41:23 <jmcarthur> agreed
18:41:29 <jmcarthur> both are good
18:42:00 <jmcarthur> we're overall a surprisingly open-minded group :)
18:42:27 <ion> brbr: On what do you base that assumption?
18:43:48 <brbr> ion: writing books for money instead of eliminating "Repeat Yourself"
18:49:10 <jmcarthur> dang bugs
18:53:12 <ion> brbr: What are you talking about? :-)
18:53:38 <jmcarthur> i've decided that i suck at writing Show instances
18:58:42 * BMeph is also interested in what brbr's coded phrases "really" mean...
19:01:49 <_Ray_> ion: He means "<kmc> we have design patterns in Haskell, it's just that people work on eliminating them rather than writing books about them and getting rich"
19:02:21 <kmc> yeah apparently this was taken as some subtle jab at LYAH / RWH
19:02:53 <kmc> it was actually a not so subtle jab at Java and everyone who has written anything on the c2.com wiki
19:02:54 <zomg> Perhaps someone should write PoEHAA
19:03:02 <kmc> whatsat
19:03:14 <zomg> Patterns of Enterprise Haskell Application Architecture
19:03:16 <kmc> haha
19:03:22 <adnam> :-)
19:03:27 <zomg> google it without the Haskell part if you don't know what I'm talking about
19:03:28 <zomg> =)
19:03:40 <zomg> Disclaimer: I have PoEAA in my bookshelf :P
19:03:45 <adnam> me2
19:03:57 <adnam> it is quite good sans the title
19:04:02 <zomg> True.
19:04:04 <blackdog> i think we do still have patterns of a kind - things like deliberately encoding your constraints into the type system to make illegal states unrepresentable, that sort of thing...
19:04:17 <blackdog> probably a bit higher-level than visitor or factory:)
19:04:28 <kmc> the term "pattern" has now come to mean "anything the patterns community wants to encourage"
19:04:31 <copumpkin> that's just using the tools the language gives you :P
19:04:40 <copumpkin> (encoding your stuff into types)
19:04:48 <kmc> so i'm sure we have some of those
19:04:51 <copumpkin> I guess phantom types pre-GADTs count
19:05:03 <copumpkin> kmc: how about the simpleton pattern?
19:05:09 <blackdog> kmc: yes - the existence of 'antipatterns' is proof of that
19:05:24 <blackdog> a pattern is a pattern is a pattern - it shouldn't really be a moral judgment
19:05:32 <copumpkin> maybe oleg's symantics trick counts as a pattern
19:05:36 <copumpkin> we have patterns too though
19:05:46 <copumpkin> f (x, y : ys) = ...
19:05:57 <kmc> the Finally Tagless trick is a pattern
19:06:00 <kmc> (is that symantics?)
19:06:11 <kmc> it's a standard workaround for the flaw that Haskell doesn't have GADTs ;P
19:06:17 <copumpkin> kmc: yeah
19:06:30 <copumpkin> minus the best part of GADTs in my opinion :P
19:06:33 <kmc> "newtype Foo = Foo Foo" is a pattern
19:06:33 <copumpkin> but it isn't bad
19:06:52 <BMeph> What's a word that means "the prevention of extension"?
19:06:53 <kmc> "abstract type + smart constructor" is arguably a pattern
19:07:15 <kmc> Apple *rimshot*
19:07:21 * copumpkin slaps kmc
19:07:37 * BMeph applauds kmc's clever use of Internet memes! ;þ
19:07:48 <kmc> is that a meme now
19:08:03 <aristid> a #haskell meme possibly
19:08:11 <blackdog> BMeph: closed-world assumption? *shrug* not suer.
19:08:33 <BMeph> kmc: If by "Now," you mean "in steady use since 1989," then yes, it's a meme "now". ;þ
19:18:51 <jmcarthur> closed?
19:18:56 <taktoa> technically, it's a sting, not a rimshot
19:19:03 <taktoa> but I only know that from wikipedia
19:28:17 <kmc> taktoa, good to know
19:33:26 <ben> 2
19:33:29 <ben> err, sorry.
19:45:06 <shachaf> 20
19:45:15 * shachaf is 10 times as sorry.
21:13:21 <ivan> anyone remember that blog post from ~3 years ago that used some strange object oriented syntax where arguments and function were inverted? what did that use?
21:15:59 <ivan> I'm pretty sure it was some GHC extension that nobody uses
21:17:31 <mzero> some sort of icky thing where you hide Prelude (.) and then redefine (.) to be (flip ($))????
21:18:10 <ivan> maybe
21:19:41 <ivan> that does sound about right. thanks.
21:20:29 <mzero> of course, that still won't work like "objects" unless every OO-like class is mirrored with a TypeClass.
21:21:11 <ivan> indeed. it wasn't a real "object" system
21:26:04 <ddarius> ivan: Note that hiding and redefining (.) doesn't require any extensions.
21:27:18 <jmcarthur> is there a supported way with CPP to get the number of bits in Int and Word?
21:30:27 <mzero> are you just trying to see if it is 32 or 64 bit?
21:30:55 <mzero> > fromIntegral (maxBound :: Int32) == fromIntegral (maxBound :: Int)
21:30:56 <lambdabot>   False
21:30:57 <kmc> the best i can discover via http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/options-phases.html#c-pre-processor is an architecture test
21:31:06 <mzero> > fromIntegral (maxBound :: Int64) == fromIntegral (maxBound :: Int)
21:31:07 <lambdabot>   True
21:31:29 <mzero> there - you can do it at run time
21:31:38 <jmcarthur> i need it at compile time
21:31:43 <kmc> if you assume GHC then you know that Int and Word are machine words except on very esoteric builds of GHC
21:32:25 <kmc> hsc2hs can give you the size of C's int at compile time
21:32:45 <kmc> or more relevantly C's long
21:32:50 <kmc> which should be the same size as GHC's Int
21:32:51 <jmcarthur> that could work. i'll look a little longer for a better way and report back if i find one
21:32:58 <kmc> yeah, i'm interested to know if you do find one
21:33:19 <kmc> also if you find a way to dump all the CPP defines generated by GHC
21:33:26 <mzero> well you could write two versions of your code, and just branch on the expression above --- which should compile to a constant and hence, pick the code at compile time
21:33:52 <kmc> that's messier, and relies on a particular optimization taking place
21:34:26 <jmcarthur> mzero: no i can't. i'm defining a type differently depending on this
21:34:34 <mzero> ah
21:34:48 <jmcarthur> i could use TH using your trick maybe
21:35:41 <kmc> this sounds like another job for the Missing Haskell Pre-Processor
21:36:32 <jmcarthur> what other features has the MHPP accumulated so far?
21:36:51 <kmc> hmm
21:38:43 <kmc> i guess what i really want here is a construct like #if / #endif that takes Haskell expressions and evals them at compile time using the usual TH machinery, but treats the enclosed code as uninterpreted text
21:39:00 <jmcarthur> that would be nice
21:39:08 <kmc> so that you don't have to deal with TH's incomplete, complex, restrictive quotation mechanism
21:39:15 <kmc> or the verbose AST builders
21:39:43 <kmc> there are applications for AST-generating macros, and there are applications for simple text preprocessing, and we don't have a good approach for the latter
21:39:55 <kmc> maybe the solution is to make TH better but i think it would have to get a lot better
21:41:31 <kmc> another common case is that i've written some class and now i want to provide very similar instances for {Int,Word}{8,16,32,64}
21:41:50 <jmcarthur> well, i'm settling on #ifdef i386_HOST_ARCH for now
21:42:17 <jmcarthur> yeah i tend to just use CPP macros for that
21:42:26 <jmcarthur> unless there is something you have in mind that CPP won't work for here
21:43:02 <kmc> TH is clunky for such things
21:43:02 <kmc> the standard libraries handle a lot of that sort of thing with CPP, but it has its own problems
21:56:30 <luqui> Hello.
21:57:08 <luqui> Poll: what is an example of a (simple-ish, but not too simple) program that you think would be very difficult to factor into independent, reusable pieces?
21:59:57 <mjo> Lisp?
22:00:30 <luqui> mjo, you mean the core interp right?  obviously the standard library is very easy to factor -- it is already factored :-)
22:00:49 <mjo> Yeah, I was thinking the original from ~1960
22:01:05 <luqui> I'll have to look into that.  might be too simple, i'm not that familiar with it.
22:01:59 <kmc> what do you want this example for?
22:03:00 <luqui> for codecatalog promotion.  I'm getting complaints that "code fundamentally cannot be factored this way", so I want to write a case study showing how to on an example that people wouldn't think would be possible
22:03:19 <luqui> assuming I can.  If I actually can't, that would be very interesting and contradict my thesis.  which is also good for me. :-)
22:03:56 <kmc> what's codecatalog?
22:04:17 <mzero> luqqi - a Forth interpreter
22:04:20 <luqui> it's a site i'm launching that catalogs simple, reusable snippets of code.
22:04:32 <luqui> (interdependent)
22:05:06 <luqui> codecatalog.net to see its early, ugly childhood :-P
22:05:34 <luqui> mzero, again, don't have a good background.  could be, i'll look at that.  thx 
22:05:39 <Eduard_Munteanu> luqui: I think games have been a bit bad on the refactoring side, but not necessarily for strict technical reasons.
22:05:57 <Eduard_Munteanu> Um, factoring into multiple pieces, I mean.
22:05:59 <luqui> Eduard_Munteanu, yeah there is a social pressure.  no need to maintain after launch (ostensibly)
22:06:08 <mzero> the classic threaded implementation strikes me as one that is hard to tease apart the memory management, the execution, and the compiler -- they are all sort on top of each other
22:06:13 <luqui> but i agree, I have had trouble factoring games in the past
22:06:43 <luqui> mzero, "threaded implementation"?
22:07:09 <mjo> Anything can be factored into reusable components, but at some point, the return on investment just isn't there.
22:07:12 <mzero> not as in multiple threads, as in an interpreter technique
22:07:32 <luqui> mjo, yeah, unless somebody has already factored it for you.  that's the point of the site :-)
22:07:35 <mjo> For example, everything ever generalizes to monads. But most of the time, you just want to printf.
22:07:45 <luqui> or do you mean for usage?
22:07:56 <mjo> For usage.
22:08:03 <kmc> what does printf have to do with monads?
22:08:07 <luqui> yeah that could be.  it's a delicate balance.
22:08:42 <luqui> mzero, hmm i am not familiar with this.
22:08:43 <mjo> If you're writing a game, you want a function that e.g. draws pixels on the screen. Not a function that takes a function of type a -> b and returns a function from type (b -> c) which when applied to...
22:08:57 <mjo> kmc: stupid example
22:09:17 <luqui> right, that's about good human names for abstractions, too.
22:09:23 <monochrom> use unsafePerformIO for a better example :)
22:09:26 <kmc> but a function that draws pixels on the screen is still a reusable component
22:09:42 <kmc> type polymorphism is only one aspect of reusable code
22:09:53 <luqui> i think the point is that it was not maximally general.  
22:09:55 <mjo> Right, I was just saying that *anything* can be made reusable, if you abstract it until it's nonsense.
22:10:12 <kmc> no, that implies you've changed its character as you abstract it
22:11:20 <luqui> isn't that kind of the meaning of the abstraction
22:11:52 <luqui> go from "a function that draws a square of pixels at the player's position" to a composition of "function that draws a pixel on the screen"
22:12:02 <luqui> the function had to be generalized in the process of separating
22:12:58 <luqui> monochrom, ?
22:13:21 <mjo> You'll probably wind up with several different levels of abstraction.
22:13:32 * Zao leaks some abstractions
22:13:51 * luqui cleans them up, dumps them on codecatalog :-P
22:14:07 <mjo> A function that takes an array of integers and doubles them is reusable. So is a function that takes an array of things that respond to '*' and doubles them. Or a thing of things that responds to another thing and does that thing to them. Et cetera.
22:14:11 <luqui> i actually don't have good support for abstractions yet :-/
22:14:26 <kmc> i think most of what is said abstractly about abstractions is abstract nonsense
22:14:38 <luqui> mjo, and they could all be the same function, with their assumptions stated different ways.
22:14:41 <luqui> right?
22:14:46 <mjo> Yeah
22:15:15 <mjo> It doesn't hurt to have more than one. Hell, most people won't even know that the fully-abstract version does what they want it to do.
22:15:53 <luqui> yeah.  cf. arrow combinators.  only the intelligencia knows to replace a with (->)
22:16:04 <kmc> heh
22:16:54 <freedrull> i read the lyah chapter about monoids but i dont really understand why they are useful yet
22:17:31 <luqui> freedrull, writer monad is a nice example of why monoids are a thing.
22:17:59 <kmc> or parallel map-reduce on a tree
22:18:26 <freedrull> luoq: ah...and thats in the coming chapter :3
22:18:39 <kmc> monoid is a generic API, implemented by a lot of different types
22:19:25 <kmc> say i have a tree of Strings and i want to append them all
22:19:30 <kmc> or a tree of Ints and i want to add them all up
22:19:31 <luqui> mzero, any elucidation on the meaning of "threaded interpreter"?
22:19:41 <kmc> or a tree of functions of type (a -> a) and i want to compose them all
22:19:54 <kmc> you don't "need Monoid" to do any of these things
22:20:03 <kmc> each one is a pretty ordinary recursive function
22:20:11 <luqui> (or a tree of ints and want to multiply them all -- that works too)
22:20:37 <mzero> each "word" to execute (Forth for a function), contains a the code to execute, and a pointer to the interpreter function to call to interpret that code.... 
22:20:45 <kmc> in fact i can generalize all of these without using any type class
22:20:53 <freedrull> right you dont need monoid to do the things ive seen monoids do
22:21:03 <kmc> by writing a "fold" function for my tree
22:21:17 <mzero> so, for example, primitives point directly at their own code.   Normal Forth procedures point back to the Forth main interpreter, and the "code" is a list of Forth words..... 
22:21:23 <kmc> almost all Haskell type classes are "optional" in this way
22:21:45 <mzero> but you can write your own interpreters... and they can interpret the "code" to execute differently
22:22:15 <luqui> kmc, not almost.
22:22:24 <mzero> http://en.wikipedia.org/wiki/Threaded_code
22:22:38 <luqui> mzero, yeah just found that.  assumed it meant multithreading but apparently it doesn't.  cool thanks.
22:22:40 <kmc> writing an instance of Monoid for your type just declares that there's a single natural way to combine values
22:23:06 <kmc> so that code which needs to combine values (e.g. this tree fold) can be more concise and require less passing around of parameters
22:23:29 <freedrull> hmm i see
22:23:36 <freedrull> one time someone told me i should write Monoid instances for my types, because then i get "nice interfaces"
22:23:49 <kmc> luqui, the Haskell standard provides no way to add Ints without using Num methods, or compare them without Eq methods, etc.
22:23:58 <kmc> similarly no way to sequence IO without a Monad method
22:24:02 <luqui> i have developed a habit of writing all relevant instances of standard typeclasses.  it makes everything pretty.
22:24:17 <kmc> a Haskell implementation can provide all of these things, though
22:24:27 <kmc> iirc GHC does export non-overloaded Int arithmetic somewhere
22:24:29 <luqui> kmc, oh you were talking specifically Haskell.
22:24:48 <luqui> i meant in principle.  so we are in agreement.
22:24:51 <kmc> i said "Haskell type classes"
22:24:52 <kmc> ok
22:25:26 <kmc> GHC at least exports the primitives and constructors you need to define (+) :: Int -> Int -> Int, (>>=) :: IO a -> (a -> IO b) -> IO b, and other such goodies
22:25:34 <kmc> without using type classes at all
22:26:00 <Eduard_Munteanu> Does it? I mean, besides the unboxed stuff.
22:26:13 <kmc> that's what i meant, the unboxed stuff
22:26:38 <luqui> you need to fudge around with Int# constructors and crap.  but at least it's *possible*
22:26:43 <kmc> i mean "instance Num Int" is in library code, not some magic built-in
22:26:49 <kmc> you can take the same definition
22:28:34 <kmc> in GHC, implementing (>>=) specialized to IO requires you to muck with unsafe stuff, but there's nothing unsafe about it inherently
22:28:48 <kmc> that's why i'm annoyed by all the fuss about "the IO monad"
22:29:14 <kmc> the fact that it's a monad is pretty much irrelevant to how it works
22:30:25 <luqui> I feel the same way, except in practice I find "IO" to be insufficiently qualified for discussion
22:30:39 <kmc> how so
22:31:22 <jmcarthur> kmc: hear hear
22:31:47 <jmcarthur> "I need to learn monads so I can do IO!"   <-- ugh
22:32:03 <kmc> the more i think about it, the more i think learning Haskell sans type classes would be a good way to start
22:32:17 <jmcarthur> if only haskell exposed those operations without type classes
22:32:24 <luqui> kmc, the more I think about it, the more I think programming Haskell without typeclasses would be a good way to continue
22:32:33 <kmc> yeah, the "beginner's Prelude" could export (>>=) concretely
22:33:29 <kmc> type classes are kind of an awkward fit in Haskell, tbh
22:33:30 <luqui> not as pleasant in the small scale, but more modular in the large scale.
22:33:53 <kmc> they're useful, and it's a damn sight better than most languages have in the same department
22:33:57 <luqui> hard to say which is more important.  I do love an elegant one-liner :-)
22:34:12 <kmc> but still pretty awkward
22:34:35 <luqui> I would like to see something like Agda/Coq's implicit params done in a more predictable way.
22:35:37 <kmc> Scala and GHC Haskell have implicit params as well
22:36:40 <kmc> one difficulty replacing type classes with implicits is that you lose the one-value-per-type guarantee
22:36:41 <kmc> what if i construct two Data.Map values under different definitions of "compare", and now I want to union them?
22:36:59 <luqui> kmc, yeah need dependent types to resolve that
22:37:16 <luqui> which i would have no problem with, if we knew more about how to do them well than we do
22:37:26 <kmc> in order to tag each Map type with its comparison function?
22:37:32 <luqui> yeah
22:37:53 <luqui> encapsulation is poor man's abstraction
22:37:56 <kmc> i wonder if you also need an axiom of extensional function equality for that to work out nicely
22:38:07 <kmc> or if you just phrase the union requirement in extensional terms
22:38:15 <luqui> i don't think so.  in fact you might not even need to know that (<) = (<)
22:38:38 <luqui> import Data.Map ((<) :: Int->Int->Int) as Map
22:38:41 <luqui> or some such
22:38:45 <luqui> that was bad pseudosyntax
22:38:55 <kmc> ah, interesting
22:38:58 <luqui> actually yeah, to make that work cross-module you would need to know (<) = (<)
22:39:02 <kmc> that's more like ML functors than dependent types
22:39:12 <luqui> yeah ml functors are half way there
22:39:18 <luqui> which is further than we've got.
22:39:25 <kmc> ocaml has first-class modules now
22:39:33 <luqui> oooh yummy
22:39:59 <luqui> i really want to see a functional language where there are no encapsulation facilities
22:40:28 <kmc> there's no effective encapsulation in Python (with the CPython interpreter)
22:40:43 <kmc> you can inspect a function value's code
22:40:49 <kmc> a function can even inspect its caller's local variables
22:40:58 <luqui> kmc, one of the reasons why python is the primary codecatalog target language
22:41:37 <luqui> python has extremely good abstraction facilities as well.  you can lexically scope a "whole program" to a function
22:41:39 <luqui> this is very useful
22:41:39 <kmc> though, how strong does encapsulation need to be... i can take apart your GHC Haskell closure with vacuum
22:42:06 <jeffz> vacuum doesn't work for me :/
22:42:14 <jeffz> I should really figure out a testcase that breaks it.
22:42:17 <luqui> to me it's more about what you can express than what you can't.  there are always ways to abuse a language.
22:42:23 <kmc> a lot of things that sound like technical language properties turn out to be community norms on what sort of hax are acceptable
22:42:27 <kmc> yeah
22:42:37 <luqui> the question is whether I can take some code and pull out any piece of it i like into a substitutable component
22:42:51 <luqui> Haskell fails, ADTs do not abstract
22:43:02 <kmc> the main sense in which Haskell lacks unrestricted side effects is that you'll get yelled at in #haskell if you use unrestricted side effects
22:43:12 <luqui> :-)
22:43:22 <luqui> go culture!
22:43:23 <kmc> by ADT do you mean "algebraic data type" or "abstract data type"?
22:43:35 <luqui> algebraic.  specifically the "data" keyword.
22:43:57 <kmc> algebraic data doesn't abstract, true
22:44:10 <luqui> it could.  view patterns are helping.
22:44:35 <luqui> the problem is the intension of the names
22:44:44 <kmc> the abstraction isn't from declaring the data type, it's from not exporting the constructors
22:45:09 <kmc> view patterns make it more convenient to work with algebraic data whose constructors were not exported
22:45:14 <luqui> that is encapsulation
22:45:47 <luqui> *attempts to think of example of ADT abstraction*
22:46:08 <kevinburke> I have list A and list B and I want to return all elements of list B that aren't present in A
22:46:34 <kevinburke> possible to do it in one pass? the elements have no ordering, and deleting from the middle of a list is tricky I know
22:46:50 <kmc> okay, what do you mean differently by abstraction then
22:47:20 <luqui> foo Bar (Baz :: Bar) (Quux :: Int -> Bar) x = case x of Baz -> 0; Quux y -> y
22:47:32 <luqui> Bar, Baz, Quux are meant to be names of parameters
22:47:46 <kmc> one pass of A and one pass of B?
22:47:59 <luqui> call with: foo Maybe Nothing Just (Just 42) = 42
22:48:04 <kevinburke> B has 16 elements, a might have a lot
22:48:38 <kmc> :t \xs -> filter (`notElem` xs)
22:48:39 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
22:48:46 <kevinburke> ah
22:48:47 <luqui> kevinburke, i would collect A into a set if A has a whole lot.
22:48:48 <kmc> that will walk B for each element of A
22:49:00 <kevinburke> ok, thanks
22:49:16 <kmc> also check out Data.Set
22:50:37 <luqui> I don't know ocaml that well, but ISTR ocaml can do this with their open tagged union types.
22:51:58 <CaryBill> I would like to know if there is a haskell platform available for my Intel Mac OS X Tiger machine.
22:54:18 <luqui> CaryBill, Tiger is 2005?
22:54:29 <luqui> that might be too old to have haskell platform support, which is fairly new
22:55:18 <CaryBill> My Tiger system is 10.4.11, about 2007.
22:55:53 <luqui> first haskell platform was 2009 on ghc 6.10
22:56:11 <luqui> i am not sure; don't know much about mac support.  that's the best answer i could give.
22:56:48 <CaryBill> OK, thanks.  I've been looking for an excuse to buy a new Macbook Pro!
22:57:42 <liyang> CaryBill: considered just upgrading the OS?
23:22:07 <xale> ghci 6.10.4 crashes when trying to show negative floats. is this known? what should I do?
23:22:58 <luqui> xale, found this https://trac.macports.org/query?cc=&page=62&desc=1&order=summary&row=description
23:23:16 <luqui> er, https://trac.macports.org/ticket/24571
23:23:31 <luqui> er
23:23:35 <luqui> sorry i'm being sloppy
23:23:56 <luqui> *this* is the one https://trac.macports.org/ticket/25265
23:24:16 <luqui> no resolution though :-(
23:24:35 <kmc> does it happen on 6.12 or 7.0?
23:26:12 <Cale> xale: your name is a really easy-to-make typo of mine :)
23:26:12 <sshc> Cale: Again, thanks for suggesting "Category Theory".  This has been, by far, the most enlightening coverage of the subject I've ever read.  I, in turn, also suggest reading it to anybody else who wants to learn about the subject.
23:26:22 <Cale> sshc: great!
23:27:01 <luqui> sshc, author?
23:27:03 <xale> there does not seem to be either 6.12 or 7.0 in the ports.
23:27:03 <Cale> sshc: I totally missed the point of Yoneda's lemma until reading about it in Awodey's book.
23:27:08 <Cale> luqui: Awodey
23:27:13 <xale> there is 6.11 though, is it worth trying?
23:27:37 <xale> this ticket looks pretty old too.
23:27:42 <Cale> 6.11 wasn't even a released version
23:28:26 <Cale> (odd numbers indicate builds between releases)
23:29:11 <Cale> xale: I would just get the binary GHC
23:29:29 <Cale> xale: You're on Mac OS X?
23:29:47 <xale> yes.
23:29:50 <Cale> http://haskell.org/ghc/download_ghc_7_0_3#macosxintel
23:30:30 <Cale> That's what I normally use
23:31:00 <Cale> You could also probably get a Haskell Platform download if you want more libraries starting out.
23:31:13 <Cale> If you install this way, you'll also have to get cabal-install on your own.
23:31:18 <Cale> (but that's not so hard)
23:31:48 <Cale> http://hackage.haskell.org/platform/mac.html
23:31:59 <xale> the platform starts by asking for a root password. I don't really like that.
23:32:13 <Cale> Well, it installs globally
23:32:28 <Cale> You can install GHC itself as user, I believe.
23:32:50 <danharaj> ooh
23:32:58 <Cale> though I don't know how the .pkg file works
23:32:59 <danharaj> has anyone seen Harper's post about laziness yet?
23:33:07 <Cale> danharaj: I might have...
23:33:25 <danharaj> I think it just got posted :p
23:33:53 <Cale> I saw some article on reddit by someone who was confused about why laziness was useful.
23:34:17 <danharaj> http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/
23:34:24 <Cale> yeah, that's the one
23:34:44 <danharaj> The first thing I thought was "Haskell is non-strict, not lazy"
23:35:00 <danharaj> then I agreed with him that I do not like how Lists and Streams are conflated.
23:35:16 <danharaj> But then I didn't stopped caring
23:35:19 <danharaj> er
23:35:22 <danharaj> I did stop caring
23:35:25 <danharaj> 3 AM disease.
23:35:54 <jmcarthur> i will definitely have to read that. this laziness issue is one of the main things i have found myself disagreeing with him on
23:38:49 <Cale> "I wish to argue that laziness is important, but not for pure functional programming, but rather only in conjunction with effects."
23:39:07 <Cale> I don't agree with him there.
23:39:39 <danharaj> in what way do you disagree?
23:40:15 * hackagebot fixed-point 0.3.0.0 - Binary fixed-point arithmetic  http://hackage.haskell.org/package/fixed-point-0.3.0.0 (JakeMcArthur)
23:40:36 <Heffalump> he doesn't seem to have addresses the points in "Why Functional Porgramming Matters
23:40:46 <Cale> Laziness (or nonstrict semantics with a reasonably efficient implementation of some sort) provides tons of benefits to pure functional programming in giving us more composable programs.
23:40:51 <Cale> exactly
23:41:21 <danharaj> I don't see why laziness matters in that regard if programs don't produce bottoms.
23:41:58 <luqui> danharaj, http://apfelmus.nfshost.com/articles/quicksearch.html
23:42:05 <luqui> one of my favorite haskell articles of all time
23:42:20 <luqui> "Isnt it great that finding the k-th minimum is not only an adaption of quicksort but can readily be obtained from it by composing it with (!! k)?"
23:42:37 <Cale> Constructing and searching a game tree doesn't involve I/O, but is a good example of something whose presentation benefits a great deal from nonstrict semantics.
23:43:11 <danharaj> Question: Do the operational semantics coincide if all functions are total?
23:43:25 <luqui> nope, just the denotational ones
23:43:36 <danharaj> yes. wires crossed in my head.
23:43:47 <Cale> also, not all useful functions are total
23:43:56 <luqui> and when all operations are not total, the denotational semantics are strictly more expressive
23:44:17 <danharaj> What is an example of a non-total useful function that could not be made total.
23:44:21 <danharaj> (?)
23:44:22 <luqui> haskell is a good choice for people who like to think denotationally
23:44:34 <luqui> define "could be made total"
23:44:52 <Eduard_Munteanu> It crossed my mind too that in total languages strict vs non-strict wouldn't change semantics.
23:44:53 <luqui> repeat
23:45:05 <danharaj> f: a -> b is transformed into f: a -> Maybe b
23:45:18 <jmcarthur> wouldn't change denotational semantics
23:45:52 <danharaj> I have to revise what I mean
23:46:02 <danharaj> because total functions are one side, and productive functions are the other side.
23:46:04 <Eduard_Munteanu> I'm not sure, I simply mean you won't get infinite loops by accident.
23:46:12 <jmcarthur> sure
23:46:16 <Cale> Well, actually, let's set that aside for a moment and just think about searching a game tree. Even if a game tree is provably finite, it is often combinatorially large. It's much nicer to be able to define the whole thing separately, and then let the search algorithm decide how much is eventually needed, than it is to construct it piecemeal.
23:46:35 <Cale> It separates the problem better into two clean parts.
23:46:49 <luqui> that is a very nice example :-)
23:46:56 <Eduard_Munteanu> Sure, operationally they could be different because that's what eager vs lazy implies by definition, I suppose.
23:47:18 <jmcarthur> yeah i love how non-strict data structures allow me to effect control flow
23:47:27 <jmcarthur> *affect
23:47:47 <luqui> i love that i don't even think in terms of control flow most of the time anymore
23:48:01 <jmcarthur> well, ideally at least
23:48:25 <luqui> although that does kind of suck when i go back to strict languages.  i end up wanting to make circular programs that don't even make sense in those languages.
23:48:57 <luqui> oh, right, i have to create an empty variable and then assign it later, which means i have to put this definition inside a lambda, which means this function needs to call its argument instead, etc.
23:49:06 <luqui> haskell broke my call-by-value brain :-P
23:49:09 <danharaj> Cale: If we treat a game tree as a value of an inductive type and all of our operations on it are total, do we care how the game tree is stored in memory?
23:49:31 <danharaj> and for infinite data structures, we stick to productive functions.
23:49:36 <luqui> yeah, because even the tic tac toe game tree is 720,000 entries large
23:49:59 <luqui> and the one for chess will not fit in all the memory on earth
23:50:10 <jmcarthur> and then there's go
23:50:12 <Cale> We do care because our lives are more finite than most game trees.
23:50:23 <Eduard_Munteanu> Yeah, heh, that wouldn't fit in two universes :)
23:50:37 <Heffalump> I think the counter-argument to composability is that laziness only supports one very specific and restricted form of composability - if your communicating data structure wasn't properly designed for it, it's likely that the laziness won't work out
23:50:38 <danharaj> I meant we don't care in principle whether it is strictly evaluated or lazily because we won't be able to tell the difference between them based on the value of the program.
23:51:29 <Cale> danharaj: The time and space behaviour are incomparably different, unless I don't understand your suggestion.
23:51:32 <luqui> but we don't care in principle whether it is strictly or lazily evaluated because all programs are equivalent to some turing machine
23:51:55 <luqui> there are some principles worth moving the discussion beyond
23:52:09 <danharaj> luqui: If we allow non-productive or non-total functions, then your program can mean different things depending on its strictness.
23:52:48 <Cale> danharaj: In practice, it doesn't matter that I can still decompose my problem nicely if the decomposition results in it requiring more memory than any computer I could conceivably buy.
23:52:51 <luqui> danharaj, but the answers will be denotationally related. in particular, the stricter program will be less defined than the lazier one in the scott ordering
23:52:57 <jmcarthur> danharaj: we're mainly talking about the operational impact, not the denotational impact
23:52:58 <Eduard_Munteanu> One thing I'm also wondering about in principle is whether one can put even stricter restriction than totality. For example it doesn't make much sense to have a total function if its upper bound (timewise) is intractably large.
23:53:08 <luqui> denotational semantics only comes out in support of laziness.  this seems to be more of a practical argument.
23:53:08 <Eduard_Munteanu> *restrictions
23:53:42 <jmcarthur> danharaj: your program might *mean* the same thing either way (assuming totality), but it will have vastly different execution properties, and that affects how you will write and understand your code
23:54:00 <danharaj> jmcarthur: well what I'm saying is that a program that uses only productive and total functions can be evaluated by any strategy you feel like, so you (or the compiler) can pick and choose at will without worries.
23:54:17 <Eduard_Munteanu> And not only programming-related, but even in math I wonder if one could have several notions of provability that put desirable upper bounds on formula sizes.
23:54:19 <jmcarthur> not without worries if you actually intend to run your hardware
23:54:43 <luqui> Eduard_Munteanu, cf cut elimination
23:54:59 <Cale> danharaj: Replace "termination" with "termination in 5 minutes using 100MB", and the problem is a lot messier.
23:55:01 <danharaj> jmcarthur: worries about correctness. You will have worries either way choosing strategies regardless of the default. But if you pick and choose strategies, say in Haskell, you risk changing the meaning of your program.
23:55:11 <jmcarthur> danharaj: solveTheGameOfGo `pseq` (1+1)
23:55:36 <Eduard_Munteanu> Mmm, thanks I'll have a look at cut elimination.
23:55:55 <luqui> danharaj, by strategies you mean sprinkling seqs about?
23:56:29 <jmcarthur> i don't live forever, and neither does my computer or my program
23:56:47 <danharaj> luqui: that's the haskell way of doing things. I don't know if a language has to be that messy to enable it.
23:56:48 <luqui> a cs professor asked, "have you ever seen a program not halt?"
23:56:52 <luqui> which i find funny on multiple levels
23:57:06 <Cale> Even without considering termination, you risk turning programs which actually work to programs which are essentially garbage because while they theoretically terminate and produce correct results, are too slow or consume too much memory to do it in practical terms.
23:57:20 <Cale> and that doesn't change even with a total language
23:57:35 <luqui> danharaj, yeah... seq is messy.  it's worth noting that the meaning change only ever changes halting programs into non-halting ones -- you can't change a 1 into a 2, for example
23:57:37 <danharaj> Cale: I do that in Haskell all the time. Just yesterday I spent the entire day getting a simulation to go from unresponsive program to real-time.
23:57:52 <Cale> Right, exactly
23:58:10 <danharaj> and going back to what I originally said. It was a question.
23:58:31 <danharaj> A question of whether such changes in strategy have any semantic consequence in a program restricted to total and productive functions.
23:58:37 <jmcarthur> i agree that ideally we would be able to program without regard to execution semantics. in a total language we wouldn't care at all, and in a non-total language we would merely want non-strictness to be in the spec. the problem is that we don't have sufficiently smart compilers that we can completely avoid making a choice of evaluation strategy
23:58:58 <Cale> With totality, you know that you're not going to change the result from some terminating value to nonterminating, but the concerns about performance are still there, and make up a majority of the task in any case.
23:59:10 <jmcarthur> maybe there's even an argument that such a sufficiently smart compiler can't exist?
23:59:46 <luqui> jmcarthur, i wouldn't be surprised if finding the fastest execution strategy in general is undecidable
23:59:52 <danharaj> jmcarthur: Maybe there's a better way of specifying evaluation strategy than seq's and delay's.
