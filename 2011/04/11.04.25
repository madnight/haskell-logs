00:00:13 <luqui> but "sufficiently smart" to me just means "better than me"
00:00:18 <luqui> and i think such a thing may one day exist
00:00:45 <jmcarthur> danharaj: i mean in the compiler we still have to make a choice, even if we take it out of the hands of the programmer entirely (in which case the programmer would probably need to know what the compiler's choice is in order to program effectively)
00:01:03 <danharaj> jmcarthur: I would prefer the choice be made by the programmer in a convenient way.
00:01:06 <Eduard_Munteanu> I also wonder if total languages such as Agda can encode proofs about execution time bounds, haven't tried that.
00:01:14 <Eduard_Munteanu> And I mean in a sensible, tightly-integrated manner.
00:01:19 <luqui> danharaj, call by push-value was a proposal i heard of that claims to have a nicer spec for execution strategy
00:01:24 <luqui> i never looked into it 
00:01:25 <jmcarthur> danharaj: then it doesn't sound much like you are arguing for what i thought you were arguing for
00:01:38 <danharaj> jmcarthur: I haven't been arguing anything. I asked a simple question and it got political :p
00:01:45 <Cale> It's conceivable that type systems could be designed to do that, but I suspect using such a language would be a total pain in the ass. ;)
00:01:53 <luqui> HASKELL IS TEH BEST!!!  SHUTUP!
00:02:01 <Eduard_Munteanu> It does seem to have something about size-decreasing terms in relation to codata, but then it's a question of how fast they get smaller.
00:02:02 <Cale> Maybe with sufficient inference...
00:02:13 <Cale> Asymptotic performance types :)
00:02:16 <danharaj> A distinction between data and codata would be nice in a language.
00:02:27 <Eduard_Munteanu> Heh, yeah, such a variant of sized types.
00:02:31 <luqui> a non-broken such distinction would be nice
00:02:55 <luqui> everyone send conor mcbride lots of love and we may one day get there
00:02:59 <danharaj> Codata would have to be lazy.
00:03:06 <Eduard_Munteanu> danharaj: Agda recently eliminated explicit keywords for codata, you only get to use the flat, sharp and that sorta stuff
00:03:25 <danharaj> Eduard_Munteanu: I never got familiar with Agda because of the emacs requirement. It's a shame.
00:03:46 <Nereid> ^ that
00:03:46 <jmcarthur> it's a shame that a text editor would keep you from learning a fun language :P
00:03:47 <Nereid> :<
00:03:52 <Eduard_Munteanu> Uh, yeah, the Emacs thingy is a bit annoying, though I'm trying to get viper mode working right
00:04:03 <danharaj> Well I would like to learn emacs, but it's a lot of work for very little payoff to me.
00:04:10 <luqui> doesn't flat/sharp break uniform abstraction?  eg. code could typecheck in general, but filling in the parameters with specific values causes it to not typecheck?
00:04:12 <danharaj> I'm waiting for the Haskell analogue of emacs :p
00:04:15 <Nereid> I would learn emacs, but I already know vim :<
00:04:23 <jmcarthur> it's less work than vim in that you can still fall back to mouse and menus if you don't know how to do something
00:04:28 <Cale> I don't understand why a lot of dependently typed languages seem to require emacs or other weird environments to input. Can't someone make one which is as close to Haskell syntax as possible? :)
00:04:35 <companion_cube> same with gvim
00:04:39 <Eduard_Munteanu> I'm not sure if Vim can handle holes and such IDE-ish stuff at the present moment.
00:04:40 <jeffz> emacs doesn't take more than a few minutes to learn
00:04:40 <jmcarthur> right
00:04:47 <danharaj> The top three things I would say are nice about Haskell
00:04:53 <danharaj> 1. First class functions
00:04:56 <danharaj> 2. Syntax
00:04:58 <danharaj> 3. GHC
00:05:09 <jmcarthur> eh
00:05:13 <Cale> jeffz: Well, I don't mind emacs as a text editor... but being forced to use some special emacs mode is a bit awkward.
00:05:20 <jmcarthur> 1. purity; 2. purity; 3. purity
00:05:27 <Nereid> jmcarthur: don't forget ghc
00:05:42 <jmcarthur> ghc is not a haskell feature
00:05:47 <danharaj> Sure it is.
00:05:52 <danharaj> It's not in the spec, but what is nowadays? :p
00:05:58 <luqui> 1. purity, 2. nice type system balance, 3. culture
00:06:05 <Nereid> culture is not a haskell feature
00:06:11 <jmcarthur> bah, another thing that isn't....
00:06:11 <Eduard_Munteanu> Cale: maybe it's not syntax (after all one can easily type Unicode in vim), but rather interactive proving. Writing programs is reasonably easy to do in Vim with agda, proofs is tougher.
00:06:13 <jmcarthur> bah
00:06:14 <Nereid> (no more than ghc)
00:06:15 <Nereid> :V
00:06:52 <Cale> Eduard_Munteanu: yeah...
00:07:04 <danharaj> I was repelled by Coq not because of its tool support (it has excellent tools)
00:07:09 <danharaj> but because of the way theorems are proved.
00:07:15 <Eduard_Munteanu> Tactics?
00:07:18 <luqui> i would like proofs to be more interactive and more opaque than either agda or coq allow.  eg. once something it is proved, it is tied up in a little package and never seen again.
00:07:47 <danharaj> Eduard_Munteanu: Yeah. It feels too low level to me.
00:07:49 <luqui> i like tactics quite a bit because they are more like this.  they are more about the interactive session than the final result.
00:07:54 <jmcarthur> i want an environment that assists me with program derivation
00:07:58 <danharaj> I wish I could do proofs at the level of universal properties and natural transformations :p
00:08:08 <luqui> danharaj, have to learn to use Ltac.  Then Coq's power begins to shine through.
00:08:20 <jmcarthur> in coq i can derive something and then prove it correct, but i'd rather it assist and check my derivation itself
00:08:21 <dons> danharaj: have you seen leroy's talk on proofs and types?
00:08:23 <luqui> I thought it was too low level for a long time too
00:08:25 <Cale> I'm the opposite. I would like proofs to be a lot more readable.
00:08:33 <Eduard_Munteanu> I don't have Coq experience, but Agda is even more low-level I think. Basically all those neat stuff like 'refl' look like Coq tactics, but maybe I'm wrong.
00:08:48 <danharaj> luqui: The fatal flaw in any plans for me to learn dependently typed languages / proof assistants is the learn-to-use ratio.
00:08:55 <danharaj> dons: I have not.
00:08:57 <Locke1689> OK guys I have a bit of a weird question -- how could haskell's Data.Set possibly end up with duplicate items if all the items derive Eq and Ord?
00:09:04 <Cale> Ideally, the proofs should be comprehensible after being printed out and taken far away from a computer.
00:09:19 <luqui> danharaj, even if i never use coq for anything real, i think learning it was a valuable experience.  it changed the way i think about abstraction.
00:09:21 <jmcarthur> Locke1689: incorrect Eq/Ord instance? bug in Data.Set?
00:09:30 <dons>  http://www.comlab.ox.ac.uk/ralf.hinze/WG2.8/26/slides/xavier.pdf
00:09:41 <Cale> Locke1689: What type are the items?
00:09:43 <danharaj> dons: Is there an accompanying video?
00:09:44 <dons> on when to use proof scripts, and when to use dependant types
00:09:50 <dons> no, sadly
00:09:55 <dons> its a secret meeting
00:10:07 <Eduard_Munteanu> BTW, Coq syntax is ugly. Though arguably ATS and ML-derived stuff is even more so :)
00:10:15 <Locke1689> Cale: They are a built algebraic datatype. All deriving Eq and Ord
00:10:16 <danharaj> Cale: I think proofs based on universal constructions are very readable. For example, deriving the Integers from the Naturals is much easier to follow from the category theoretic view, at least to me.
00:10:27 <Cale> Locke1689: okay, then that shouldn't happen...
00:10:32 <danharaj> ML is gross to me.
00:10:44 <Cale> Locke1689: are there parts where Eq and Ord instances are hand-written?
00:10:54 <Nereid> the thing about universal constructions is that you have to prove they exist ;(
00:10:55 <danharaj> Haskell is the only language that suits my tempermental idiosyncratic notation.
00:11:18 <dons> heh
00:11:21 <Locke1689> Cale: No, all derived.
00:11:29 <danharaj> Nereid: But once you prove they exist you get a powerful tool.
00:11:31 <Cale> Locke1689: hum... can I see your program?
00:11:33 <Nereid> quite
00:11:43 <wagle> anyone know what happened to http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/mtl?
00:11:49 <wagle> anyone know what happened to http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/mtl ?
00:11:52 <danharaj> I can't learn math from a textbook without sitting down and rewriting it in my own notation :\
00:12:05 <danharaj> I would make a terrible textbook writer.
00:12:13 <Nereid> is your own notation standard?
00:12:40 <Locke1689> Cale: Sure. I'll hpaste it in a sec
00:12:42 <Eduard_Munteanu> I think Haskell could use some of those 'syntax' decls from Agda (though they'd be less useful not being able to open code type functions and such).
00:12:46 <danharaj> Nereid: Often not.
00:13:07 <Cale> I like the notation in most modern mathematics textbooks.
00:13:23 <Eduard_Munteanu> Heck, 'do' notation is a 'syntax' declaration in Agda, but arguably a bit less nice than in Haskell.
00:13:33 <danharaj> Cale: It depends on the field I think. But yeah, most of my problems are with textbooks from the pre-Latex era.
00:13:55 <danharaj> Anything from before 1950 especially is read with great trepidation on my part.
00:14:33 <dons> wagle: mtl?
00:14:37 <luqui> danharaj, maybe you can't learn math without sitting down and writing it down in a way that helps you understand it.  the notation may not be the thing.
00:14:50 <dons> i'm not sure what hfl is
00:15:00 <luqui> i can't learn anything by "reading" math books in the traditional sense
00:15:07 <danharaj> luqui: It is part of it. I have seen some beautifully expressed math and it just clicks.
00:15:07 <wagle> dons: not sure what it was..  some blog full of interesting monad stuff
00:15:18 <Locke1689> Cale: Actually, would you take a bitbucket link instead?
00:15:23 <Cale> sure
00:15:28 <luqui> http://abstrusegoose.com/353
00:15:30 <dons> hmm well, mpj's mtl lives  here:  https://github.com/ghc/packages-mtl  
00:15:52 <dons> i'm not aware of the blog though
00:15:55 <danharaj> That's a nice comic :p
00:15:58 <wagle> http://www.google.com/search?q=%22hfl%2Fhfl%2Fmtl%22+sourceforge
00:16:10 <Eduard_Munteanu> Heh, nice luqui.
00:16:16 <luqui> hey! now that there are more people here:  what is a simple-ish (2-3 hrs dev time) program that you think would be difficult to separate into independent, reusable components?
00:16:16 <dons> hmm
00:16:42 <danharaj> luqui: Anything involving OpenGL
00:16:43 * danharaj rimshot
00:17:00 <dons> ?last Pseudonym
00:17:00 <lambdabot> No module "Pseudonym" loaded
00:17:40 <Locke1689> Cale: https://bitbucket.org/agocke/nu-compiler
00:17:41 <dons> wagle: looks like a *long* time ago. 2002, or 2003 stuff from ajb
00:17:50 <Locke1689> The relevent data definitions are in L2Parser.hs
00:17:50 <luqui> danharaj, it's a good point though.  OpenGL is a very large library with a complicated semantics.  that could really detract from the ability to do that.
00:18:01 <danharaj> If it's possible to write a library that can statically determine the interface of a shader as a type, it would be awesome to work with that instead of ad-hoc wiring data to shaders.
00:18:04 <Locke1689> The problematic code is in L2Liveness
00:18:07 <wagle> seems i saw in in the past year or so, but dunno..
00:18:18 <dons> logict ended up here http://hackage.haskell.org/package/logict 
00:18:23 <danharaj> luqui: OpenGL is 80% Cruft, 5% Shader State, and 15% GPU DMA :p
00:18:27 <Eduard_Munteanu> Mm, that's what graphics engines usually do.
00:18:41 <dons> Cale: around?
00:18:51 <luqui> :-)
00:18:54 <danharaj> Eduard_Munteanu: I could not think of a nice way to do it on my own.
00:18:59 <Locke1689> I can give you a failing test case but uh, this bug results in infinite recursion
00:19:01 <Cale> dons: yeah
00:19:03 <danharaj> Eduard_Munteanu: In general, at least.
00:19:05 <dons> when was pseudonym last here? the old school is all over the place now
00:19:18 <dons> hardly see shapr except on twitter. sigh
00:19:21 <Cale> Locke1689: You actually get an error from Data.Set complaining about a duplicate element?
00:19:22 <Eduard_Munteanu> @seen Pseudonym
00:19:22 <lambdabot> Unknown command, try @list
00:19:22 <preflex>  Pseudonym was last seen on #haskell 5 days, 1 hour, 51 minutes and 35 seconds ago, saying: Yup.
00:19:28 <dons> yay
00:19:36 <wagle> @last Pseudonym
00:19:36 <lambdabot> No module "Pseudonym" loaded
00:19:37 <blackdog> dons: he's still lurking in scannedinavian
00:19:40 <wagle> bah
00:19:53 <dons> blackdog: sigh
00:20:00 <Cale> dons: I've just been busy between work and hobbies, but I'm actually usually around still (just not paying close attention)
00:20:08 <wagle> ?seen Pseudonym
00:20:08 <lambdabot> Unknown command, try @list
00:20:20 <shachaf> preflex: seen Pseudonym
00:20:21 <preflex>  Pseudonym was last seen on #haskell 5 days, 1 hour, 52 minutes and 34 seconds ago, saying: Yup.
00:20:33 <luqui> i'm busy as hell.  i'm being bad by hanging out here instead of doing homework.
00:20:35 <jmcarthur> shapr appears sometimes
00:21:02 <jmcarthur> i think i still see him online more than IRL
00:21:15 <Eduard_Munteanu> Mm, is Pseudonym shapr?
00:21:26 <Cale> shapr is shapr
00:21:39 <luqui> reflexivity.  Qed.
00:21:47 <Eduard_Munteanu> Heh.
00:21:47 <Locke1689> Cale: No. It's really weird. I print out the set and it contains a duplicate element.
00:21:53 <Locke1689> so i turn it into a list
00:21:55 <Locke1689> compare the two
00:22:00 <Locke1689> EQ
00:22:04 <Locke1689> I am totally confused
00:22:14 <Cale> Wow
00:22:15 <dons> ok. even Heffalump still hangs out. so we're good.
00:22:17 <jmcarthur> shapr called my wife a couple nights ago. was kind of surreal
00:22:23 <dons> aquateens, assemble!
00:22:35 <dons> jmcarthur: wow
00:22:52 <dons> jmcarthur: 10 years later, i've never met shapr in the person
00:22:59 <jmcarthur> lol
00:23:05 <danharaj> dons: I like slide 11 in this presentation. "Dependent types work great to automatically propagate invariants". I think that's where the money is at.
00:23:16 <dons> danharaj: ahaha
00:24:16 * shachaf talked to shapr on the phone once.
00:24:17 <luqui> I really like modeling with dependent types.  Coq:  Variable A : Type.  Variable F : A -> A.  blah blah blah.
00:24:43 <nib2> Hello
00:24:46 <Cale> Locke1689: so, assuming I have a clone of your repo, how do I reproduce this?
00:24:50 <Cale> (in ghci?)
00:24:54 <luqui> it's really nothing special for math, but programming languages suck at that kind of thing.
00:25:01 <Locke1689> OK this is a little tricky
00:25:09 <Cale> nib2: hello
00:25:10 <Locke1689> because the bug will produce infinite recursion
00:25:15 <luqui> hi nib2 
00:25:34 <Locke1689> I can give you a test file which causes it
00:25:39 <jmcarthur> i should really go to bed
00:25:45 <Cale> Locke1689: okay...
00:25:46 <luqui> jmcarthur, amen
00:26:34 <nib2> Sorry in advance for my english, can you help me please ? I become from C and PHP and i try despaired to find the right syntax for this : for (i = 0; i < strlen(s); i++) { if (test_the_char(s[i])) { /* do */ } else { break; /* stop */ }
00:26:43 <Eduard_Munteanu> I think Coq is a bit strange with its Prop distinction. I also wonder where it stands as far as universe polymorphism is concerned.
00:27:19 <danharaj> nib2: start at the function `map'
00:27:37 <wagle> ormap?
00:27:38 <Eduard_Munteanu> Or mapM / mapM_ if you actually mean doing IO actions.
00:27:57 <nib2> thank you , i try !
00:28:12 <Eduard_Munteanu> The 'break' stuff might be a bit trickier, but you could also use a fold.
00:28:23 <Locke1689> Cale: http://hpaste.org/46021/failcase 
00:28:25 <Eduard_Munteanu> (Or 'Maybe'.)
00:28:28 <luqui> nib2, it depends on what you do after the break...
00:28:33 <Locke1689> Download that, put it into some file
00:28:42 <luqui> i mean after the loop
00:29:16 <Nereid> mapM_ something (takeWhile test_the_char s)
00:29:24 <Nereid> or forM_ (takeWhile test_the_char s) something
00:29:26 <Locke1689> then build it and then run livenessFile in ghci with the pathname
00:29:34 <luqui> Nereid, bam!  that's the thing my brain was trying to tell me!
00:29:38 <Cale> okay
00:29:43 <Nereid> except
00:29:50 <Locke1689> youll want to break on getInOuts probably
00:29:56 <nib2> thank you very much, i go to Google !
00:29:57 <Nereid> no that isn't quite it
00:30:00 <Nereid> no that is it maybe
00:30:03 <danharaj> nib2: go to hoogle
00:30:07 <Nereid> btu you'll only get the char, not the index
00:30:11 <danharaj> http://www.haskell.org/hoogle/
00:30:19 <wagle> @hoogle mapM
00:30:20 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
00:30:20 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
00:30:20 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
00:30:27 <luqui> danharaj, my guess is that nib2 does not grasp the type system well enough yet to use hoogle
00:30:28 <Nereid> @hoogle forM_
00:30:28 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
00:30:28 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
00:30:40 <Locke1689> then just keep stepping through calls to getInOuts and eventuall prevIns and prevOuts will contain arrays of sets with duplicate items
00:30:51 <Eduard_Munteanu> MaybeT over IO could emulate 'break' easily.
00:30:52 <danharaj> luqui: Well you can use it to search for function descriptions as well.
00:30:59 <Nereid> mmm
00:31:24 <Eduard_Munteanu> ('break' == 'return Nothing')
00:31:30 <Nereid> yeah
00:31:41 <wagle> takeWhile
00:31:44 <danharaj> Let's not break out the monad transformers here :p
00:31:47 <Nereid> :P
00:32:00 <luqui> haha
00:32:02 <Eduard_Munteanu> Or ContT / callcc :P
00:32:03 <danharaj> I would split the list at wherever the predicate breaks, then process each chunk separately.
00:32:04 <wagle> mmm..  transformers
00:32:12 <Nereid> robots in disguise?
00:33:11 <danharaj> oh boy I just remembered I have a midterm on tuesday.
00:33:19 <danharaj> I'm going to have to make a big context switch tomorrow.
00:33:58 <wagle> at least you didnt remember 15 minutes after it started
00:34:06 <danharaj> I did that once.
00:34:15 <Nereid> :C
00:34:26 <Nereid> I remembered the next day once. :<
00:34:35 <danharaj> Is this a contest
00:34:39 <luqui> me too.  wasn't a midterm so much as a final.
00:34:40 <danharaj> because I will win
00:34:52 <luqui> i had to go pleading to the prof to let me take it.
00:34:58 <luqui> my finest hour.
00:35:07 <Nereid> I got lucky, I guess
00:35:29 <danharaj> I remembered a final paper two months after it was due.
00:35:35 <luqui> lol
00:35:36 <Nereid> my prof was super cool about it and just transferred that part of the grade to the final
00:35:40 <Nereid> ;(
00:35:48 <Nereid> two months
00:35:50 <Nereid> !
00:35:59 <danharaj> I completely forgot I even took that class.
00:36:02 <Cale> Locke1689: should I force the evaluation the first time those variables show up in scope?
00:36:02 <danharaj> But yes. Two months.
00:36:03 <Nereid> haha
00:36:14 <Nereid> I have nightmares like that :<
00:36:22 <Nereid> well, did
00:36:25 <Locke1689> Cale: Sure. Doesn't seem to matter
00:36:37 <Nereid> had
00:36:42 <Nereid> stupid english
00:36:55 <Cale> There seem to be some interesting Show instances here
00:37:47 <Cale> er, I'm getting False for prevIns == prevOuts
00:38:02 <Cale> How many times do I have to :continue / :step ?
00:38:26 <Locke1689> Yeah the Show instances are because this is a compiler for a specific subset of Scheme
00:38:29 <Locke1689> um
00:38:42 <Nereid> probably shouldn't be using Show for that then
00:38:58 <Nereid> unless
00:39:21 <Locke1689> Nereid: The Show is to print out the s-expression representation of the program
00:39:32 <Nereid> sure, but perhaps that should be another function
00:39:44 <Locke1689> Meh
00:39:57 <Locke1689> Let's see
00:39:59 <Cale> yeah, I'm okay with that actually
00:40:10 <Nereid> anyway
00:40:18 <Locke1689> since I knew it was gonna continue forever
00:40:24 <Cale> (as long as we're not relying on custom show instances to decide equality, shouldn't be a problem :)
00:40:27 <Locke1689> i did like 8 or so conts?
00:40:43 <Locke1689> if you watch the fromList debug prints
00:40:51 <Locke1689> keep an eye on edi
00:41:00 <Locke1689> that's the first variable I saw duplicated
00:41:30 <Locke1689> (In the longest set)
00:41:33 <Locke1689> that's like
00:41:44 <Locke1689> 6 prints down
00:42:04 <Cale> You just want me to look at whether prevIns is equal to prevOuts?
00:42:11 <Locke1689> Specifically, it reads fromList [y,eax,edx,ecx,edi,esi,edi]
00:42:13 <Locke1689> no
00:42:21 <Locke1689> prevIns will never be equal to prevOuts
00:42:24 <Cale> oh
00:42:24 <Locke1689> because of this bug
00:42:27 <Cale> okay
00:42:41 <Locke1689> You have no idea how long it took me to figure that out :-p
00:43:03 <Locke1689> In the liveness section of the compiler, when the set reaches steady state it should stop
00:43:20 <Locke1689> But because of this union bug, it seems to continue forever
00:43:53 <luqui> Data.Set?
00:43:58 <Locke1689> luqui: yes
00:44:08 <luqui> are you sure your ordering satisfies the laws?
00:44:22 <Locke1689> luqui: it uses deriving Ord, Eq
00:44:31 <luqui> oh.  well it sure ought to then :-)
00:45:07 <Locke1689> That's what I thought :-p
00:45:32 <Cale> oh, indeed, look at that...
00:45:33 <Locke1689> Cale: Sorry, I know this isn't the simplest possible failure case
00:45:58 <Cale> oh, you're using fromAscList
00:46:00 <Cale> that's unsafe
00:46:08 <Locke1689> damnit
00:46:17 <Locke1689> I knew it had to be something simple
00:46:18 <Cale> aha, and you're using it with a list that's not ascending :)
00:46:32 <Locke1689> hahah
00:46:33 <Cale> (a constant list)
00:46:42 <Locke1689> The precondition (input list is ascending) is not checked.
00:46:43 <Locke1689> yup
00:46:44 <Locke1689> wow
00:46:47 <Locke1689> totally missed that
00:46:49 <Locke1689> thank you
00:46:56 <Nereid> :>
00:47:58 <luqui> Cale++
00:48:12 <Cale> :3
00:48:13 <Locke1689> Cale is a god
00:48:18 <Locke1689> Works now
00:48:22 <Nereid> :>
00:48:55 <Locke1689> Welp, that'll teach me to use the hardest graduate course in the CS department as my testing ground for Haskell
00:49:31 <Cale> fromList is probably safer as a general policy, unless you're implementing something which involves converting back and forth from a Set and you want to guarantee linear time.
00:49:53 <Cale> (even then, premature optimisation)
00:49:55 <Locke1689> Yeah, I just figured that since it was a constant list I should use constant time
00:50:00 <Nereid> heh, there's even a proposal to rename fromAscList to unsafeFromAscList
00:50:13 <Locke1689> Nereid: not such a bad idea
00:50:24 <Cale> Since it's a constant list, it'll be constant time regardless ;)
00:50:34 <Locke1689> Cale: well, true
00:51:05 <Cale> Also, wouldn't be surprised if GHC let-lifted it and it only ever got computed once
00:51:17 <luqui> I like this tendency to mark functions which have preconditions not checked by the typechecker
00:51:30 <luqui> we *really* need a Nat type
00:51:44 <Zao> I think I've found a function that is less apparent what it does than `nub'.
00:51:45 <Cale> (sometimes it does that aggressively in annoying cases, so I usually expect it'll do it in plenty of non-annoying cases too)
00:51:48 <Zao> CL's (terpri)
00:52:00 <Cale> lol
00:52:17 <Locke1689> Personally I would really like to see some kind of memoization hinting method in the GHC, but maybe I'm just not used to Haskell enough
00:52:40 <Cale> Zao: there are even better examples if you're looking in the common lisp library
00:53:01 <luqui> Locke1689, check out data-memocombinators and MemoTrie.  it's very easy to memoize in haskell.
00:53:26 <Zao> Cale: Just skimming the wikipedia page on Common Lisp, trying to find some decent implementations I can embed into manly C++ software.
00:53:35 <Zao> Probably more suitable for -blah, this though.
00:53:39 * Cale tries to remember the name of them...
00:55:04 <Locke1689> luqui: Easy, but this post http://augustss.blogspot.com/2011/04/ugly-memoization-heres-problem-that-i.html seems to imply that it may not be as fast as it could be
00:55:27 <luqui> Locke1689, true, it's not
00:55:42 <luqui> I use memoization to bring the asymptotes of my problems down
00:55:49 <Locke1689> This may be one case where the compiler could help out a little. Especially since it's a straight performance optimization
00:55:51 <luqui> not to squeeze every last bit of performance out of my program
00:55:56 <luqui> in fact, I never really do the latter
00:55:58 <Locke1689> luqui: Fair
00:56:19 <luqui> just not my cup o tea :)
00:56:24 <Cale> nreconc is pretty good
00:56:39 <Cale> nreconc reverses the order of elements in list (as if by nreverse). It then appends (as if by nconc) the tail to that reversed list and returns the result. 
00:56:48 <luqui> woah
00:56:50 <Cale> got that?
00:56:51 <luqui> that's pretty complicated
00:57:40 <luqui> is it a helper function for implementing reverse or something?
00:57:58 <Cale> I guess it probably is
00:58:13 <Locke1689> Cale: Sounds like exactly the type of thing I should add to Racket ;)
00:58:16 <Cale> Also, try to guess what rplacd does if you haven't seen it before
00:58:33 <Cale> Big hint: there's also rplaca
00:58:45 <luqui> ah, replaces the cdr of a cons?
00:58:48 <Cale> yeah
00:59:19 <luqui> @pl \z (x,y) -> (x,z)
00:59:19 <lambdabot> (`ap` snd) . (. fst) . (const .) . flip (,)
00:59:23 <luqui> ouch
00:59:56 <shachaf> Well, that's both not in place and not for cons cells. :-)
01:00:23 <Athas> Wait, System.Environment.getArgs does not decode the arguments?
01:00:26 <luqui> potato potato
01:00:33 <Athas> How bizarre. 
01:00:35 <luqui> that idiom doesn't really work over chat
01:00:54 <luqui> Athas, what do you mean decode?
01:01:07 <Athas> luqui: UTF-8 decode (or something else depending on locale).
01:01:27 <Cale> Athas: ah, that's an interesting little oversight
01:01:28 <shachaf> luqui: It works particularly well if you spell out one of them phonetically and not the other. :-)
01:01:47 <Athas> Cale: it's not intentional, you think?
01:01:53 <Athas> Maybe they wanted to avoid locale-aware code.
01:02:20 <luqui> shachaf, that's funny, the fact that rplca could be in-place didn't even occur to me.  Lisp is a functional language, right?  :-)
01:02:30 <shachaf> Common Lisp? Not really.
01:02:33 <Cale> Athas: This is one of those cases where technically they are ByteStrings (by unix convention), but where String tends to be more convenient and the function was around from before ByteString existed.
01:02:58 <Eduard_Munteanu> @hoogle getArgs
01:02:58 <lambdabot> System.Environment getArgs :: IO [String]
01:03:00 * shachaf hasn't heard Common Lisp referred to as "functional" very often.
01:03:12 <Cale> Athas: and so what you get are Strings that only make use of the lowest 256 values of Char
01:03:24 <Eduard_Munteanu> It is, I mean it works if you want to write ugly stuff :P
01:03:35 <Athas> Yeah, it just means I have to do the UTF-8 decoding myself.  Ugh.
01:04:15 <Cale> Might be worth putting in a bug/request to the libraries folks...
01:05:16 <Cale> There ought to be versions which get the raw args as ByteStrings, and String ones which do encoding, in parallel with the new System.IO library.
01:05:29 <Athas> It's base... where do I report bugs like that?
01:05:34 <Athas> I agree, that would be an elegant solution.
01:06:12 <Cale> My gut reaction is to send mail to the libraries@haskell.org mailing list.
01:07:08 * shachaf wonders how trustworthy Cale's gut is.
01:07:18 <Cale> I'm not sure if there's any better place to submit such things
01:07:31 <Athas> Oh wait, there's a bug tracker link on the Hackage page.
01:17:06 <Athas> I fear it's rather tricky to fix it, unfortunately...
01:23:48 <Cale> Athas: It'll be a bunch of work, but much less work than was already recently done to improve the IO library
01:24:43 <Athas> Yeah, after a little peeking, it seems like the IO Unicode work can just be reused.
01:24:49 <Athas> In fact, I think I'll work on a patch.
01:24:59 <Athas> Now, where the heck is the base code...
01:26:23 <Nereid> as long as it also works correctly on non-unix too
01:28:39 <npouillard> lg 15
01:28:46 <npouillard> oops
01:28:52 <Athas> I'm just going to extract the locale encoding the same way the IO library does, then perform decoding the same way too.
01:28:56 <Athas> Should work everywhere.
01:39:39 <fenfrie> how can i make the first letter in a String uppercase?
01:40:33 <Zao> fenfrie: Find out if there's a first letter. If there is, uppercase it and hook on the rest of the string.
01:40:48 <Zao> @type Data.Char.toUpper
01:40:49 <lambdabot> Char -> Char
01:42:27 <fenfrie> how to hook on the rest?
01:42:42 <pastorn> fenfrie: pattern matching on [] or (c:cs)
01:43:06 <Zao> > let (x:xs) = "asdf" in (x, xs)
01:43:07 <lambdabot>   ('a',"sdf")
01:43:07 <fenfrie> ah, can i handle a normal String like (x:xs)?
01:43:11 <Zao> > let ] = "asdf" in (x, xs)
01:43:12 <lambdabot>   <no location info>: parse error on input `]'
01:43:14 <Zao> > let [] = "asdf" in (x, xs)
01:43:15 <lambdabot>   Not in scope: `xs'
01:43:21 <Zao> @src String
01:43:21 <lambdabot> type String = [Char]
01:43:31 <pastorn> fenfrie: it's just variable names...
01:43:31 <Zao> String is nothing but a synonym for list-of-Char.
01:43:31 <fenfrie> okay, thx
01:44:01 <pastorn> fenfrie: String = [Char]
01:44:09 <pastorn> so yes, you handle it like any other list
01:46:39 <roconnor> I kinda like how using divided differences removes the need for if statements in my code, even it it does make my code less efficent.
01:47:01 <pastorn> fenfrie: you get it to work?
01:47:10 <fenfrie> yes :)
01:47:13 <fenfrie> love haskell
01:47:39 <fenfrie> but its not easy to learn i think
01:53:10 <nib2> I have one (very) stupid question: who to make a variable that can change value (a = True ... a = False) ? i have try using "IO" but "if readIORef continue" generate error at compilation. Can you help me please ?
01:53:52 <pastorn> nib2: branch boolRef = do { b <- readIORef boolRef; if b then X else Y }
01:54:12 <pastorn> sorry
01:54:17 <pastorn> "readIORef boolRef"
01:55:09 <nib2> i try, thank you !
01:55:35 <jeffz> modifyIORef foo not
01:57:40 <nib2> i have writed this : "continue <- newIORef True" ... "writeIORef continue False" .. "if readIORef continue", this condition failed on compilation, who to use my variable "condition" into a if ? 
01:58:28 <pastorn> nib2: do { continue <- newIORef True; writeIORef continue False; cont <- readIORef continue; if cont then LOLZ else LULZ }
01:58:47 <nib2> thank you very much, i try
02:01:27 <Nereid> maybe also consider Control.Monad.IfElse.condM
02:01:56 <pastorn> Nereid: then he might as well look into syntax overloading
02:01:57 <Nereid> or uh
02:02:10 <Nereid> does fmap cond do it, too?
02:02:15 <Nereid> where
02:02:25 <nib2> yes !! thank you :D
02:02:35 <Nereid> where cond :: Bool -> a -> a -> a
02:02:44 <Nereid> so not the same as the package I referred to
02:02:53 <pastorn> http://blog.n-sch.de/2010/11/27/rebindable-if-then-else-expressions/
02:02:56 <pastorn> Nereid: ^^^
02:03:05 <Nereid> meh
02:03:32 <pastorn> @type cond
02:03:33 <lambdabot> Not in scope: `cond'
02:03:43 <Nereid> yeah it's not standard I guess
02:03:57 <pastorn> @let cond b x y = if b then x else y
02:03:57 <lambdabot>  Defined.
02:04:04 <Nereid> yeah
02:04:09 <Nereid> :t fmap cond
02:04:10 <lambdabot> forall t (f :: * -> *). (Functor f) => f Bool -> f (t -> t -> t)
02:04:10 <pastorn> @type liftM2 cond
02:04:11 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m (a2 -> a2)
02:04:15 <balor>  if "Foo {bar :: Maybe Int}"  can I construct a Foo using "Foo {bar=1}"?
02:04:16 <pastorn> @type liftM cond
02:04:17 <lambdabot> forall t (m :: * -> *). (Monad m) => m Bool -> m (t -> t -> t)
02:04:20 <Nereid> mmmhhhh
02:04:23 <Nereid> still not it
02:04:33 <Nereid> @type liftM4 cond
02:04:34 <lambdabot> forall a4 r (m :: * -> *). (Monad m) => m Bool -> m (a4 -> r) -> m (a4 -> r) -> m a4 -> m r
02:04:37 <Nereid> lol
02:04:52 <balor>  or "data Foo = Foo {bar :: Maybe Int}" for completeness
02:04:52 <Nereid> @type liftM3 cond
02:04:53 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
02:04:53 <pastorn> @type liftM3 cond
02:04:53 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
02:04:56 <Nereid> that's the one.
02:05:22 <Nereid> not very pretty syntax though
02:22:45 <pastorn> @type readIORef
02:22:46 <lambdabot> Not in scope: `readIORef'
02:23:12 <pastorn> Nereid: it could be one with applicative
02:24:39 <pastorn> Nereid: pure cond <*> readIORef boolRef <*> X <*> Y
02:50:27 <pmurias> what does the type (,) mean?
02:50:39 <shachaf> A pair.
02:50:54 <shachaf> Or a constructor that takes two arguments and then gives you a pair of those.
02:51:08 <pmurias> hm?
02:51:28 <pmurias> meant to ask about (,) a
02:51:53 <Nereid> (,) a b = (a,b)
02:55:00 <Nereid> so  (,) a  is a type constructor
02:55:08 <Nereid> you have to apply it to another type to get a type
02:55:30 <Nereid> (much like how, say, Maybe is a type constructor)
02:57:12 <Nereid> @kind (,) Int
02:57:13 <lambdabot> * -> *
02:58:20 <DasIch> Nereid: tuples are not recursive like lists so (,,) exists, too?
02:58:30 <Nereid> it should
02:58:32 <Nereid> @kind (,,)
02:58:33 <lambdabot> * -> * -> * -> *
02:58:50 <DasIch> wow, that's cool
02:58:52 <Nereid> @type (,,)
02:58:53 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
03:05:12 <pmurias> how should i generate such boilerplate code (from the data declaration on top) as in nopaste: http://paste.scsys.co.uk/99348
03:07:25 <pmurias> what should i try/read about SYB, template haskell?
03:07:50 <Lemmih> pmurias: I would just write it by hand.
03:10:09 <pmurias> Lemmih: why?
03:10:35 <pmurias> the size of Insn will grow a *lot*
03:11:48 <merijn> pmurias: as far as I can tell, you can replace all lines in "insnToGraph" with "insnToGraph n = mkMiddle n">
03:11:57 <merijn> s/>/?
03:14:07 <merijn> No point in pattern matching if you're not going to use the patterns...
03:14:27 <zenzike> is anybody else having troubles installing the checkers pacakge through "cabal install checkers"?
03:14:47 <pmurias> merijn: the pattern matching is to make it type check
03:15:02 <merijn> pmurias: How so?
03:15:28 <pmurias> mkMiddle only works for Graph Insn O O
03:15:42 <merijn> pmurias: If "insnToGraph n@(Fetch _ _)   = mkMiddle n" type checks, then so does "insnToGraph n   = mkMiddle n"
03:15:43 <pmurias> and insnToGraph has a type Graph Insn x e
03:15:50 <pmurias> merijn: not it doesn't
03:15:59 <pmurias> s/not/no
03:16:14 <Lemmih> merijn: GADTs are funny that way.
03:16:43 <merijn> Ah, I skipped over the GADT at the start, my bad >.>
03:17:23 <pmurias> np ;)
03:17:49 <pmurias> hoopl forces me to use GADTs
03:19:07 * pmurias checks how much boilerplate can uniplate avoid
03:21:00 <ezyang> Conjecture: Purity without laziness is annoying. 
03:21:28 <ezyang> pmurias: Watch'a working on? 
03:21:39 <merijn> ezyang: The Habit people would disagree with you? :>
03:22:30 <ezyang> pmurias: I'm pretty sure Hoopl gives you utility functions to do those things. 
03:22:58 <ezyang> Although your Insn type is confusing. Why do you not have any C O and O C instructions? 
03:23:06 <ezyang> merijn: I suppose :-) 
03:23:47 <ezyang> DDC would probably also disagree. 
03:23:58 <ezyang> though I'm a little confused how they manage amortization. 
03:24:21 <merijn> ezyang: On unrelated note, the illustrations with your recent explanations rule :)
03:24:33 <ezyang> Thanks! :-) 
03:28:46 <pmurias> ezyang: i'm adding Insn C O and Insn O C right now
03:28:55 <pmurias> and a whole bunch of others
03:28:56 <alpounet> ezyang, that's in reaction to Harper's post ?
03:29:19 <pmurias> and i want to find a way to avoid writing a whole bunch of boilerplate
03:29:30 <ezyang> alpounet: Yeah. 
03:29:46 <alpounet> (and, i agree, your illustrations are excellent)
03:29:59 <pmurias> ezyang: i'm writing an optimiser for https://github.com/sorear/niecza
03:30:13 <pmurias> ezyang: i liked your blog posts about hoopl btw.
03:30:42 <ezyang> pmurias: Cool! I need to finish off that series, but that's been blocking on fixing some bugs with Hoopl. 
03:30:54 <pmurias> bugs in hoopl?
03:31:07 <pmurias> anything serious?
03:31:16 <ezyang> It doesn't seem to happen in practice, but the current version of Hoopl terminates fixpoint analysis too early. 
03:31:48 <ezyang> I have a fix, but Norman Ramsey hasn't managed to give me access to the repo yet so I haven't pushed it yet. 
03:32:00 <ezyang> and then I need to fix a notable inefficiency with the fixpoint analyzer. 
03:32:11 * hackagebot floatshow 0.1.1 - Alternative faster String representations for Double and Float  http://hackage.haskell.org/package/floatshow-0.1.1 (DanielFischer)
03:33:59 <pmurias> ezyang: they seem to write the boilerplate by hand in hoopl/testing
03:34:24 <pmurias> i will do that do if i'm forced to or just generate the code with a haskell or perl script
03:35:48 <ezyang> pmurias: Ah, another important thing to note. 
03:36:01 <ezyang> Hoopl is best used on an intermediate representation of some sort. 
03:36:11 <ezyang> It's probably not a good idea to try Hoopl'ing on the actual Perl6 AST. 
03:36:30 <ezyang> So we tend not to have that much boilerplate, and it's very static boilerplate. 
03:44:09 <pmurias> ezyang: i'm using hoopl on a intermediate representation
03:44:17 <pmurias> but i's not a very small one
03:44:42 <pmurias> i didn't design it myself
03:45:22 <pmurias> ezyang: i could collapse multiple ast nodes into a single one, but that would mean sacrificing type safety and convienience
03:46:59 <ezyang> Ah, I see. 
03:47:07 <ezyang> In that case, maybe some generic programming could be justified. 
03:47:32 <ezyang> But do note that when you are writing optimizations, you have to account for /all/ possible nodes anyway, so you'll have very big analyses. 
03:47:37 <ezyang> See if you can write up some generic combinators. 
03:47:45 <ezyang> sort of like mapEE in the sample code. 
03:48:49 <pmurias> ezyang: generating generic combinators is what i'm planning to accomplish
03:51:06 <cwb> How do I fix the ambiguous type variable compiler complaint for "Control.Exception.try (print (5 `div` 0))"? RWH gives this as an example in chapter 19 without such an error..
03:51:20 <pmurias> ezyang: with the analysis aware of only a few node types each asking most of the node types for generic properties or asking doing generic operations on them
03:51:34 <cwb> Has something changed recently or am I just missing something obvious?
03:53:01 <merijn> cwb: Can you pastebin the code + entire error?
03:55:05 <pmurias> ezyang: would having a InsnOO ADatatypeForNoneInsnOO constructor to remove the GADTness for most ops make sense?
03:55:08 <Lemmih> cwb: :: IO (Either SomeException ())
03:55:09 <cwb> http://hpaste.org/46023/try_problem
03:55:23 <pmurias> ezyang: so i could use SYB and all the goodness
03:56:15 <cwb> merijn: Using GHC 7.0.3
03:57:34 <merijn> cwb: As Lemmih said, the type of try is: "try :: Exception e => IO a -> IO (Either e a)" and ghc can't determine which value to use for the e. So you will want to make an explicit type annotation telling GHC what to expect
03:57:35 <Lemmih> cwb: And the above type signature and it should work.
03:57:58 <merijn> cwb: (Normally your error handling code would allow GHC to infer which type to expect for e)
04:00:03 <cwb> Aha, and SomeException will match all exception types?
04:00:55 <merijn> cwb: Correct
04:01:07 <cwb> Cool. Thanks Lemmih and merijn
04:03:28 <merijn> cwb: "Ambiguous type variable" error means "GHC has 0 or more then 1 possible matches for this type and can't decide which to pick", the solution is usually add an annotation to unconfuse GHC
04:07:21 <cwb> merij: Thanks, I just couldn't see what part of it was ambiguous - now obvious..
04:10:37 <roconnor> @hoogle [Maybe a] -> Maybe [a]
04:10:37 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
04:10:38 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
04:10:38 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
04:13:49 <ezyang> pmurias: I'm not really sure what you mean. 
04:14:40 <pmurias> i'll nopaste the declaration
04:15:57 <pmurias> ezyang: something like that: http://paste.scsys.co.uk/99349
04:16:29 <ezyang> Oh yes, doing that for Ops is a good idea. 
04:16:41 <ezyang> C-- has a single MachOp instruction, which has many different types. 
04:17:31 <pmurias> so i don't have to deal with a GADT everywhere
04:17:44 <ezyang> Yes. 
04:19:08 <pmurias> and what's the prefered library for generating generic operations?
04:19:15 <pmurias> SYB, uniplate, something else?
04:22:11 <pmurias> will implicit Maybe for view patterns be implemented in the future?
04:22:40 <Lemmih> pmurias: There isn't really a preferred library for that. It depends on the situation.
04:23:23 <Athas> pmurias: implicit Maybe?
04:23:24 <pmurias> implicit Maybe as in http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns#ImplicitMaybe
04:23:59 <pmurias> so i can have foo (bar => x) instead of foo (bar -> Just x)
04:25:30 <Athas> That would be neat, I suppose.
04:48:02 <pmurias> ezyang: where can i find the hoopl using ghc?
04:49:19 <ezyang> Most of it's in compiler/cmm 
04:49:29 <ezyang> Check CmmNode.hs for our Insn definitions 
04:49:44 <ezyang> if you grep Dataflow you can also find our analyses and rewrites 
04:59:32 <Peaker> What library is nice for image manipulation as rectangular arrays? e.g: Something that lets me treat a JPEG as a rectangular array of pixels?  Or at least map over all pixel components?
05:03:26 <hpc> there's a library that reads bitmaps like that
05:05:45 <hpc> you could always find another to convert the jpg
05:08:13 <Peaker> hpc, but then how do you map over it with something like: (RGB -> RGB) ?
05:09:04 <roconnor> I've been meaning to write a raster library :)
05:10:52 <hpc> Peaker: hmm, the bitmap library i thought was good actually uses pointers...
05:11:07 <roconnor> a raster library using repa
05:11:26 * roconnor wants to write a parellel gaussian blur
05:13:02 <Peaker> repa has some load bitmap function
05:13:15 <Peaker> leksah "please wait while collecting info" is taking a loooong time
05:13:49 <carpi> let in haskel similar to lambda in python?
05:14:05 <Twey> Not really, no.
05:14:13 <merijn> No, lambda is similar to lambda in python
05:14:18 <Twey> Lambdas in Haskell are similar to lambdas in Python.  Sort of.
05:14:28 <merijn> Let is more like python's "def"
05:14:55 <carpi> hmm.. theres lambdas in haskel? long way to go for me.. 
05:15:09 <Twey> Haha
05:15:11 <merijn> > (\x -> x*x) 5
05:15:12 <lambdabot>   25
05:15:26 <merijn> :t (\x -> x*x)
05:15:27 <lambdabot> forall a. (Num a) => a -> a
05:15:30 <hpc> carpi: there's lambdas in python? :P
05:15:38 <merijn> carpi: That's a lambda in Haskell :)
05:15:50 <hpc> carpi: lambdas in haskell are ridiculously sense-making
05:16:02 <merijn> hpc: For now, until Guido starts being annoyed with FP in python again :p
05:16:37 <ClaudiusMaximus> repa sounds nice, maybe i should use that instead of (listArray (bounds a) . parMap rseq f . assocs $ a) in this code: https://gitorious.org/maximus/emndl/blobs/master/GridScan.hs#line55
05:16:41 <carpi> hpc: yup. albeit.. an imposter..; )
05:16:44 <carpi> i think
05:17:39 <Taejo> #python
05:17:45 <Taejo> oops
05:18:09 <merijn> carpi: Let (just like where) is really just a convenient way to define local functions/variables
05:19:42 <hpc> (('where' clauses desugar to 'let ... in'))
05:20:54 <merijn> carlocci: http://hpaste.org/46026/local_functions
05:20:57 <merijn> errr
05:21:06 <merijn> s/carlocci/carpi
05:22:48 <HugoDaniel> back
05:24:02 <carpi> merijn: thax for the clarification
05:24:59 <merijn> (Although I personally prefer where over let...in)
05:27:41 * Eliel prefers where over let...in as well.
05:30:25 * hackagebot hfusion 0.0.1 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.1 (FacundoDominguez)
05:36:07 <cwb> Could anyone recommend a beginner's tutorial to generics/SYB/typeable that explains both the problems it solves and how to use it?
05:38:13 <cwb> (I'm not sure what hides under http://www.cs.vu.nl/boilerplate/ referenced in most places since it gives a 403 error)
05:43:42 <arnihermann> cwb: the SYB papers are good starting point
05:44:13 <arnihermann> cwb: http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
05:45:49 <cwb> arnihermann: Thanks, will start with those!
05:53:52 <roconnor> why is case e of {Inl x -> Inl x ; Inr x -> Inr x} = e false in haskell?  It looks true to me.
05:55:18 <crystal-cola> in what sense it is false?
05:55:24 <crystal-cola> what equivalence relation?
05:55:33 <ezyang> Hmm. I think there's something wrong with the statement... 
05:55:59 <roconnor> crystal-cola: one side is supposed to be more or less defined than the other
05:56:02 <roconnor> but I don't see why
05:56:29 * hackagebot hfusion 0.0.2 - A library for fusing a subset of Haskell programs.  http://hackage.haskell.org/package/hfusion-0.0.2 (FacundoDominguez)
05:56:34 <ezyang> ah yes, I see why 
05:56:49 <ezyang> wait. Huh. 
05:57:03 <ezyang> You get saved by the fact that the entire case-statement itself is lazy. 
05:59:12 <ezyang> So yeah, I'm confused too now. 
05:59:23 <Bustakheops> why Data.Bits.bitSize (Data.Bits.bit 1) doesn't work ?
05:59:55 <roconnor> Bustakheops: it looks like it needs a type annotation to know what type (bit 1) should be
06:00:54 <crystal-cola> the definedness order is something like  _|_ < Inl _|_, _|_ < Inr _|_
06:01:07 <crystal-cola> if you try every possible combination of this both sides are equivalent
06:01:16 <ezyang> yeah... 
06:01:23 <roconnor> that is my conclusion
06:01:32 <Bustakheops> ok thx, i will try with a type annotation
06:01:49 <ezyang> Bustakheops: More usually, someone will do (undefined :: Word), etc. 
06:01:50 <crystal-cola> so we can conclude that they e = case e of ... ?
06:01:56 <ezyang> since bitSize only uses the type. 
06:02:09 <ezyang> crystal-cola: I suspect the canonical example is a slightly different equation. 
06:04:40 <Bustakheops> ezyang : ok but how i can do if i want to know bit representation of an int?
06:04:52 <Bustakheops> ok size
06:04:55 <Bustakheops> or size
06:04:57 <Peaker> Except for SDL image, how else can you load image files without caring for their particular format -- and gain access to their pixel data?
06:05:11 <ezyang> bitSize (undefined :: Int) 
06:06:31 <Bustakheops> thx, i didn't know this 
06:06:40 <Peaker> Hackage seems very thin on image processing libraries..
06:07:29 <jeffz> I use pngload for 24bit rgb(a) pngs.
06:07:45 <ezyang> If anything, the usual equation that fails to hold is e = (fst e, snd e) 
06:08:00 <hpc> Peaker: obviously this means you should write an all-in-one image reader! :D
06:08:36 <Peaker> Graphics.GD and SDL-image can load stuff - but then they don't give you access to pixel data
06:09:10 <roconnor> also, what stops me from writing nonnat = Succ nonnat in ML?
06:09:28 <hpc> roconnor: ML is strict, isn't it?
06:09:34 <roconnor> so
06:09:42 <roconnor> it will typecheck no?
06:09:50 <doserj> of course
06:09:51 <crystal-cola> roconnor: no
06:09:57 <crystal-cola> it's not syntactically valid
06:10:05 <crystal-cola> try  nonnat () = Succ (nonnat ())
06:10:16 <crystal-cola> let rec or something
06:10:34 <roconnor> let rec nonnat = Succ nonnat in nonnat
06:10:37 <roconnor> how about that?
06:11:32 <Peaker> hpc, what library you referred to earlier that at least gives you Ptr access to pixels?
06:11:51 <crystal-cola> roconnor: oh that does work
06:11:55 <roconnor> I don't know
06:12:05 <crystal-cola> I just tried it
06:12:12 <roconnor> oh
06:12:13 <roconnor> see
06:12:26 <roconnor> so ML's nats aren't an inductive type either, right?
06:13:01 <roconnor> well, I guess Bob is shoving looping behaviour out of the dentiotions of his types and into a side-effect
06:13:21 <roconnor> I'm not sure how well that meshes with equational reasoning
06:14:14 <crystal-cola> roconnor: this is really weird
06:15:42 <hpc> Peaker: either bitmaps or bitmap
06:15:44 <hpc> i forget which
06:16:06 <hpc> i think it was bitmap
06:16:16 <crystal-cola> I asked in #ocaml someone said "it's your own fault if you misuse it."
06:17:15 <aleator> Peaker: If you're really adventurous you could try http://yousource.it.jyu.fi/cv for basic image processing needs.
06:17:42 <pmurias> ezyang: does that code seems sane: http://paste.scsys.co.uk/99351
06:18:13 <ezyang> Looks like pretty bog standard conversion code :-) 
06:19:31 * hackagebot encoding 0.6.5 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.6.5 (HenningGuenther)
06:19:33 <ezyang> "bad = Succ (Succ undefined)
06:19:33 <ezyang> and GHC will not complain about the inner Succ being applied to undefined." Huh, sounds like a bug in GHC. 
06:21:15 <pmurias> ezyang: i had a bug with convert false instead of convert cond
06:23:36 <pmurias> ezyang: do any tools which draw the block graph as a graph exist?
06:24:10 <fenfrie> what is the best editor for haskell under windows with code autocomplete and breakpoints?
06:24:28 <ezyang> pmurias: Not that I know of, but that would be a great addition to Hoopl! 
06:24:41 <ezyang> wouldn't be too hard to dump the successors into a GraphViz file. 
06:25:06 <ezyang> in fact, it would be really, really easy. 
06:26:41 <roconnor> ezyang: step2 isn't denotationally the identity
06:26:50 <roconnor> step2 is only the identity on total values
06:27:13 <roconnor> I still don't follow what presearing / Harper are getting at WRT sums and products
06:27:19 <ezyang> roconnor: Erm, sorry, I missed the context. 
06:27:31 <roconnor> http://www.reddit.com/r/programming/comments/gwqa2/the_real_point_of_laziness/c1qwali
06:27:47 <ezyang> oh, just saw it. 
06:32:00 <merijn> roconnor: I always seem to arrive at the conclusion that he is trolling out of jealousy that Haskell is suddenly more in vogue then ML
06:32:20 <roconnor> merijn: But I agree with almost everything else he says ...
06:38:35 <nowhere_man> hey all
06:38:53 <crystal-cola> so no real functional programming languages have inductive types
06:38:55 <nowhere_man> I'm just doing the "Write Yourself a Scheme in 48 Hours" tutorial
06:39:04 <nowhere_man> and I have a question about type inferrence
06:39:36 <nowhere_man> in most of the first examples, my compiler gives me typing errors if I remove the type before a definition
06:39:51 <nowhere_man> like
06:39:53 <nowhere_man> symbol = oneOf "!#$%&|*+-/:<=>?@^_~"
06:39:54 <copumpkin> you probably have the wrong types :)
06:40:11 <nowhere_man> compiles fine with a preceding `symbol :: Parser Char`, not without
06:40:15 <copumpkin> @hoogle oneOf
06:40:15 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
06:40:15 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
06:40:15 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
06:40:30 <doserj> that's the MonomorphismRestriction
06:40:40 <copumpkin> oh I see, I read it backwards
06:40:49 <djahandarie> crystal-cola, huh?
06:41:22 <nowhere_man> doserj: thx
06:41:24 <merijn> crystal-cola: define "real functional programming languages"
06:41:48 <crystal-cola> haskell and ocaml
06:42:06 <merijn> That's a rather...limited...definition
06:42:10 <homslice> heh
06:43:13 <merijn> Pretty sure that Coq, Agda and Epigram all have inductive types. Whether you want to call those programming languages is a matter of how masochistic you are :)
06:43:21 <djahandarie> lol, 'homslice'
06:43:25 <copumpkin> total?
06:44:21 <homslice> :)
06:50:54 <shapr> Good Morning #Haskell!
06:51:00 <crystal-cola> Hi 
06:51:00 <shapr> How's code treating you peeps?
06:52:22 <stepkut> shapr: boing!
06:52:52 <ben> hello shapr 
06:53:09 <merijn> Code is treating me badly, but that might be because it is C instead of Haskell >.>
06:53:40 <djahandarie> My wifi connection is dropping me so frequently that I can't even answer that question
06:54:50 <ben> Code is treating me badly, but that might be because I have terribly neglected it and not written any haskell (or anything but a handful of lua, really) in months :(
06:55:02 <ben> /r/haskell is all that is keeping me sane
06:56:14 <djahandarie> Rob Harper keeps you sane? I thought it was the other way around
06:56:26 <merijn> I just realized #haskell and type theory have so damaged me that "sm" gets parsed as "successor of m" rather then "fetish" >.>
06:57:38 <Twey> merijn: Haha
06:57:45 <Twey> That's Sm, surely
06:58:40 <merijn> Twey: In the past few papers the s was typeset as bold but the same size as the other letters (maybe it was smallcaps?)
06:59:08 <Twey> Hrm, okay
06:59:32 <Twey> Maybe
06:59:56 <shapr> stepkut: h0p!
07:02:00 <ztirf> ztirf
07:02:23 <shapr> shapr
07:04:33 <arcatan> arcatan
07:06:25 <hpc> really? to me "sm" means sm (who is probably going to 'wtf' at all these pings)
07:06:50 <shapr> Yah, means Simon Michael at Joyful
07:07:27 <Tomsik> "sm" is a good name for a short-lived variable
07:07:34 * Twey uses v
07:07:52 <Twey> But next time I have such a thing, I will call it bdsm.
07:08:45 <merijn> hpc: Well, him joining was what triggered the original realization :p
07:11:50 <ymasory> hi all. are there any haskell-db adapters i should particularly prefer or avoid? i normally use MySQL but i'm flexible. i just want a good, functional, fast adapter to haskell
07:15:24 <djahandarie> ezyang, your site seems to have issues again
07:15:32 <djahandarie> Something about scripts.mit.edu not being available
07:15:37 <ezyang> yeah, working on it :-( 
07:15:43 <djahandarie> Okay :)
07:15:47 <ezyang> some other dude got Reddit front-paged and took all four servers down... 
07:15:53 <djahandarie> lol...
07:16:06 * ezyang is quite displeased 
07:16:28 * djahandarie thinks ezyang should just move to some external host
07:17:21 <Twey> .ie
07:18:29 <copumpkin> ezyang: wow, mit fail
07:18:36 <copumpkin> ezyang: so when are you coming back again?
07:18:44 <copumpkin> or did you graduate?
07:19:05 <cwb> I'd like to make a library defined newtype an instance of Data and Typeable -- how would I go about that? I can't see how I would write the Typeable instance..
07:20:53 <stepkut> cwb: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
07:20:58 <ClaudiusMaximus> cwb: {-# LANGUAGE DeriveDataTypeable, StandaloneDeriving #-}  might work?
07:21:38 <stepkut> cwb: send a patch to the maintainer?
07:27:22 <cwb> stepkut, ClaudiusMaximus: That works for Typeable; complains when trying the same for Data so will play with that a bit more.
07:28:08 <cwb> stepkut: Should pretty much all datatypes be instances of Typeable/Data? Is there a reason why one might not want them in libraries?
07:29:05 <stepkut> cwb: some people have argued that data-types which do not export their constructors should not be instances of Data because that allows you to fiddle the parts you aren't supposed to fiddle
07:29:37 <stepkut> cwb: but other people think that if you are fiddling the parts you shouldn't, you get what you deserve and that there are other reasons to want a Data instance
07:29:47 <hpc> evidence: the large number of incomplete instances, where some functions = undefined
07:30:59 <cwb> stepkut: I see, thanks.
07:44:30 <tomh-> mm after you do a getChar do you need to press enter or?
07:44:43 * hackagebot hoogle 4.2.2 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.2 (NeilMitchell)
07:45:33 <shapr> :t getChar
07:45:34 <lambdabot> IO Char
07:45:50 <shapr> tomh-: I think that depends on your buffering?
07:46:03 <tomh-> hmm I get weird behavior in ghci
07:47:48 <tomh-> shapr, what kind of buffering do you mean? I can't configure that right
07:48:22 <shapr> tomh-: Perhaps http://www.haskell.org/pipermail/beginners/2010-January/003286.html  ?
07:48:44 <tomh-> cool thanks
07:48:47 <Eduard_Munteanu> By default it's line-buffered I think.
07:48:57 <tomh-> ah thats explain why the enters are required
07:51:35 <tomh-> "It probably won't work on Windows, though." :(
07:54:31 <tomh-> indeed, still have to press enter in windows
07:57:29 <fryguybob> tomh-: http://hackage.haskell.org/trac/ghc/ticket/2189
07:58:41 <tomh-> yeah hmm
07:59:58 <tomh-> maybe I should just hook up openGL
08:00:02 <tomh-> thats more reliable
08:04:02 <sm> morning all
08:10:10 <byorgey> hi sm 
08:14:04 <shapr> goood morning sm!
08:14:45 <byorgey> hey shapr! coming to Hac Phi this year? =)
08:16:42 <shapr> byorgey: Unlikely, I'm trying to save cash to go to school fulltime
08:17:00 <byorgey> shapr: ah, ok.  good luck with that!
08:17:48 <byorgey> hmm, that sounds sarcastic, I meant it non-sarcastically
08:18:36 <shapr> On irc, I assume people are being sincere unless they make a big effort to imply otherwise..
08:19:08 <lpsmith> Attending HacPhi has crossed my mind.  I've grown to have an aversion to travelling though,  we will see how I feel about it later :)
08:19:14 <shapr> Too many different cultures floating around with various levels of unfamiliarity with English to assume sacrasm.
08:19:27 <lpsmith> hah
08:19:29 <crystal-cola> what do you mean shapr 
08:20:12 <dmwit> lpsmith: It's going to be totally awesome.
08:20:51 <copumpkin> lpsmith: unavert yourself to traveling!
08:20:53 <copumpkin> travel now!
08:21:02 <dmwit> I, personally, will be disappointed if you don't register. =(
08:21:13 <copumpkin> ooh guilt
08:22:03 <byorgey> shapr: that sounds like a good policy!
08:22:57 <byorgey> dmwit: how many are registered so far?
08:23:12 <dmwit> 9, including us
08:23:20 <dmwit> (I registered for you and Chris.)
08:23:25 <byorgey> sweet
08:23:31 <byorgey> at that rate we will have... um, let's see
08:23:36 <dmwit> haha
08:23:56 <byorgey> 120 or so
08:24:00 <dmwit> =P
08:24:01 <byorgey> ;)
08:24:13 <dmwit> Now do the calculation again: within the first hour, we had 7 registrations.
08:24:16 <lpsmith> oh the joy of extrapolation
08:24:17 <dmwit> =P
08:24:31 <byorgey> oh, within the first HOUR, I see!
08:25:26 <byorgey> um, 15,960?
08:25:30 <byorgey> we are going to need a bigger room
08:25:44 * shapr grins
08:27:01 <copumpkin> dmwit: and now you have 10!
08:27:07 <dmwit> YAY!
08:27:39 <dmwit> 11, actually
08:27:43 <dmwit> Hadn't checked my mail yet. =P
08:27:48 <copumpkin> zomg
08:31:22 <ezyang> Hmm. I wonder if there exists a fully worked example of all category theory notions for, say, Haskell. I guess category-extras would be it... 
08:32:12 <physicist> Is there a why to enforce some restrictions when defining a type? For example if I represent matrices as lists of lists, can I somehow force these matrices to be square
08:32:30 <physicist> 01
08:32:35 <dmwit> How about using Array instead?
08:32:45 <dmwit> You can at least enforce rectangular-ness, then.
08:33:03 <copumpkin> ezyang: of examples of all the concepts in Hask, or "functional implementations" of the structures?
08:33:10 <ezyang> wait, category-extras is obsolete. :-O what's the successor? 
08:33:17 <copumpkin> a dozen packages
08:33:19 <luite> bah 1000 euro for a return flight to PHL, I think I'm going to skip :p
08:33:20 <ezyang> oh, that's right. I mean Hask. 
08:33:29 <dmwit> As for enforcing square-ness, you can probably do it... but I doubt you would want to use the data type that resulted in anything meaninful. It would be way too painful.
08:33:45 <ezyang> For example, what's a pull-up in Hask? 
08:33:46 <byorgey> luite: yikes!
08:33:49 <copumpkin> ezyang: ah, I'll eventually get to something hask-like in agda :) I've implemented a bunch of structures but haven't written many "instances" of them for concrete categories
08:33:50 <ezyang> how about a colimit? 
08:33:56 <luite> byorgey: from amsterdam
08:33:56 <dmwit> Yow, 1000 euro seems a bit high.
08:34:02 <copumpkin> ezyang: pullback?
08:34:10 <physicist> that's not my point square matrices are just examples, is there a way to enforce such restrictions in type definitions?
08:34:23 <byorgey> ezyang: it's the dual of a push-up
08:34:31 <copumpkin> lol
08:34:33 <dmwit> physicist: There are many restrictions like that which are possible.
08:34:34 <ezyang> :-) 
08:34:39 <dmwit> physicist: There are many also that aren't possible.
08:34:50 <copumpkin> ezyang: if you're talking about pullbacks and pushouts, hask doesn't have them
08:34:57 <dmwit> physicist: If you wish all computable restrictions to be possible, perhaps you'd be interested in dependent types (e.g. Agda).
08:35:06 <physicist> examples any??
08:35:16 <ezyang> Ah... 
08:35:39 <copumpkin> ezyang: but if you have dependent types, you can implement pullbacks
08:35:52 <copumpkin> I think I actually did do that one in agda
08:36:01 <physicist> I seriously don't like to learn a new language, so a Haskell example would help
08:36:12 <crystal-cola> what
08:36:20 <dmwit> physicist: An example of what, exactly?
08:36:24 <ezyang> I think logic examples would also help. I guess for that I should look for a textbook in categorical logic... 
08:36:32 <crystal-cola> agda can't express all computable functions
08:36:36 <physicist> enforcing squareness etc
08:36:42 <ezyang> but I get kind of glassy-eyed when I start reading about filters on Heyting algebras. 
08:36:48 <crystal-cola> squareness you can hack into haskell but it's horrible
08:36:50 <roconnor> crystal-cola: depends on what you mean by express
08:36:55 <copumpkin> crystal-cola: how is that relevant?
08:37:03 <copumpkin> ezyang: https://github.com/copumpkin/categories is what I have so far
08:37:23 <crystal-cola> roconnor: oh yes you're right, it cna express all computable and even non-computable ones
08:37:59 <yrlnry> I wasted a bunch of time this weekend thinking about coexponential objects.  It turns out there's a reason why you never hear about them.
08:38:24 <dmwit> physicist: Well, step one is to do type-level numbers.
08:38:30 <lpsmith> Is there a particularly nice way to write   mapMaybe :: (a -> Maybe b) -> [a] -> [b]  = \f -> foldr (\x ys -> case f x of { Nothing -> ys ; Just b -> b : ys } []
08:38:44 <dmwit> physicist: Have you seen that done before?
08:38:46 <copumpkin> lpsmith: I'd do it with a list comp
08:38:59 <lpsmith> duh
08:38:59 <physicist> No
08:39:18 <lpsmith> Not quite as pretty as I'd like, but I agree
08:39:21 <Philippa> ezyang: re Bob Harper/strictness annotations, I think the issue Bob's not bothering to explain is that due to the Value Restriction, in ML you can only build a function of type () -> Nat that doesn't terminate, not a Nat with _|_ as its value. Of course, that means () -> x isn't isomorphic to x which is its own kind of fugliness...
08:39:26 <ezyang> copumpkin: While I'd like to say I'll take a look at it, seems pretty unlikely right now... 
08:39:29 <roconnor> @type catMaybes . map
08:39:30 <lambdabot>     Couldn't match expected type `[Maybe a]'
08:39:30 <dmwit> :t catMaybes -- lpsmith
08:39:30 <lambdabot>            against inferred type `[a1] -> [b]'
08:39:30 <lambdabot>     Probable cause: `map' is applied to too few arguments
08:39:31 <lambdabot> forall a. [Maybe a] -> [a]
08:39:37 <copumpkin> ezyang: one day it'll be more accessible :)
08:39:37 <roconnor> @type (catMaybes .) . map
08:39:38 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
08:39:43 <copumpkin> ezyang: I don't have any comments at all in it
08:39:53 <copumpkin> except for things like "wtf agda wai u no let me do this"
08:39:59 <ezyang> hahaha 
08:40:05 <dmwit> Does anybody have a link to that blog post about designing a list type with strings at prime-numbered positions and ints everywhere else?
08:40:15 <lpsmith> hmm, I don't ever remember catMaybes :)
08:40:15 <roconnor> or ya, list comprehensions work okay too
08:40:16 <ezyang> Philippa: oh that's right, ML has a value restriction. *goes and looks that up again* 
08:40:20 <dmwit> That seems like a pretty comprehensive example for physicist to look at.
08:40:20 <hpc> :t \f xs -> [x | Just x <- map f xs]
08:40:21 <lambdabot> forall a t. (a -> Maybe t) -> [a] -> [t]
08:40:38 <dmwit> And also one that shows how annoying it is to use such types, and why you often want less expressive types.
08:40:47 <dmwit> Or: how annoying it isn't to switch languages. =P
08:40:48 <copumpkin> dmwit: I think sigfpe had some examples on how to come up with odd types to express odd constraints
08:40:55 <Philippa> ezyang: basically you can't write omega = succ omega in it, you have to go via the function type
08:40:55 <copumpkin> can't remember which ones though
08:40:57 <physicist> Or what about this? I want to do modular arithmetic but want want to pass modulus as a type argument
08:41:06 <hpc> copumpkin: ooh, linky?
08:41:10 <crystal-cola> Philippa: I just wrote that today
08:41:15 <hpc> sigfpe is always fun to read
08:41:21 <dmwit> physicist: These kinds of things are exactly what dependent types were designed for.
08:41:32 <Philippa> crystal-cola: in which lang?
08:41:33 <dmwit> physicist: You can do them in Haskell, but it's much, much worse than using a language that was made for it.
08:41:35 <crystal-cola> ocaml
08:41:37 <ezyang> I thought the value restriction was to deal with the unsoundness of polymorphic references. 
08:41:48 <roconnor> Philippa: let rec nonnat = Succ nonnat in nonnat works in ocaml.  Is that just an ocamlism?
08:41:59 <Philippa> roconnor: I suspect so
08:42:07 <roconnor> oh :(
08:42:08 <Philippa> (and Bob's mostly talking SML)
08:42:10 <dmwit> physicist: back in a second
08:42:14 <copumpkin> hpc: http://blog.sigfpe.com/2010/08/constraining-types-with-regular.html
08:42:32 <physicist> dmwit: np
08:42:39 <lpsmith> I like reading sigfpe too;  it's just often it goes over my head :-P
08:42:43 <Philippa> someone pointing out to Bob that it's doable in ocaml might be a good idea, then
08:42:49 <yrlnry> That won't work for Daniel's example of having strings at prime-numbered positions, because the primes are not regular.
08:42:59 <copumpkin> I know
08:43:19 <Philippa> (personally I'd rather admit I have _|_ everywhere and retain !() -> x `iso` x, YMMV)
08:43:21 <ezyang> I need to refresh myself on the reasons why Oleg and Ken did HANSEI in ML and not Haskell. IIRC they had some pretty good reasons. 
08:43:42 <illissius> this specific example doesn't seem *that* onerous, or at least specifying the types isn't: data Z; data S n; data TList n a where { TNil :: TList Z a; TCons :: a -> TList n a -> TList (S n) a }; data TSquare n a where TSquare :: TList n (TList n a) -> TSquare n a
08:43:44 <lpsmith> I dunno; I feel like I missed something critical somewhere and I'm now suffering from having some level of intuition of what somebody's talking about but not really grokking it
08:43:49 <pmurias> what's HANSEI?
08:43:51 <illissius> using them might be :-)
08:44:03 <ezyang> http://okmij.org/ftp/kakuritu/logic-programming.html 
08:44:06 <crystal-cola> lpsmith: which?
08:44:31 <ezyang> They use continuations to embed logic programming in ML 
08:44:33 <lpsmith> crystal-cola: which what?
08:44:36 <hpc> oh hey, finally understand how regexes are transformed to FSMs
08:44:44 <crystal-cola> you had some sigfpe article you didn't get?
08:44:49 <hpc> http://3.bp.blogspot.com/_UdKHLrHa05M/TGcaDcP8oMI/AAAAAAAAAkE/RFwDCHq5oDg/s1600/automaton1.png <- this graphic is what did it for me
08:44:54 <lpsmith> crystal-cola: many of them :)
08:44:54 <ezyang> Oh, I remember one reason: domain experts don't actually want to write (+) <$> x <*> y; they want to write x + y 
08:44:58 <lpsmith> Some of them I did get
08:45:17 <roconnor> ezyang: that's not a bad argument.
08:45:32 <dmwit> Aha, here we go!
08:45:41 * roconnor doesn't see a SML package in nix :(
08:45:41 <dmwit> physicist, copumpkin: http://cdsmith.wordpress.com/2010/03/15/type-level-programming-example/
08:45:59 <ezyang> but side-effectful computations and laziness are known to be too hard for most people to understand :-/ 
08:46:03 <lpsmith> SML implementations need some TLC
08:46:20 <Philippa> ezyang: yeah, lifting + can work, but...
08:46:20 <ezyang> But I kind of suspect that we're going to end up being forced to understand it anyway. 
08:46:30 <cwb> Is there a good reason there's no Data instance for Data.CompactString (in its various variations)? I'm trying to derive one (using StandaloneDeriving as suggested here earlier), but I'm pretty lost.. Could anyone point me in the right direction?
08:46:39 <roconnor> Philippa: my main take away is to teach Agda to first year students when my times comes (or some restricted version of Agda without dependent types).
08:46:47 <lpsmith> I can't say there is an SML implementation I really really like.
08:46:51 <crystal-cola> roconnor: lambda calculus
08:46:54 <physicist> dmwit: seems painful
08:47:04 <copumpkin> roconnor: you could just avoid telling them about pi
08:47:05 <roconnor> crystal-cola: types are needed, and inductive types as well.
08:47:09 <dmwit> physicist: Definitely.
08:47:13 <ezyang> because as far as big systems go, () -> a is a pretty powerful way of introducing indirection. 
08:47:15 <roconnor> copumpkin: possibly.
08:47:19 <crystal-cola> you can put types and inductive types to lambda calculus
08:47:21 <lpsmith> SML/NJ probably comes closest.  Actually I preferred moscow ML,  but that was interpreted and is no longer maintained
08:47:30 <dmwit> physicist: Your particular example might be easier than that one, of course.
08:47:32 <roconnor> crystal-cola: you mean impredicatively?
08:47:33 <copumpkin> crystal-cola: ideally you want them to be able to tinker with it interactively, too
08:47:35 <crystal-cola> no
08:48:09 <lpsmith> Moscow's runtime was a _lot_ better than SML/NJ's.
08:48:18 <pmurias> ezyang: have you tried mixing side-effectful computations and laziness?
08:48:29 <ezyang> "Yes, it's called Lazy IO" 
08:48:41 <Jafet> Tried? I succeeded!
08:48:48 <ezyang> We also had a hilarious experience with it while I was working on Cryptol. 
08:48:57 <ezyang> Basically, purity is *really really* desirable. 
08:49:25 <ezyang> because otherwise, you may end up doing exponential work. 
08:49:34 <Twey> For that special value of hilarious that means it made you want to claw out your brain?
08:49:37 <dmwit> physicist: For your particular example, something like this might suffice: data Square aOdd a = Zero | Succ aOdd (Square (aOdd, a, a) a); type Matrix a = Square a a
08:49:38 <lpsmith> pmurias:  I've had fun making use of non-referentially-transparent uses of unsafePerformIO before
08:49:54 <lpsmith> it can be enlightening,  but definitely not recommended for "real" code
08:49:56 <ezyang> Twey: It was, uh... enlightening! 
08:50:02 <Twey> Heh.
08:50:06 <Jafet> Edutainment
08:50:07 <roconnor> crystal-cola: what's the difference between lambda calculus + types +inductive types and adga restricted to no dependent types?
08:50:09 <pmurias> ezyang: i have used lazilly generated object attributes in perl and it seemed rather usefull
08:50:14 <physicist> dwmit:I wish I could write x + y :: (mod n)
08:50:26 <merijn> Jafet: Oh, that's a familiar value of hilarious :)
08:50:33 <ezyang> pmurias: What do you do when the generated value becomes stale? 
08:50:39 <copumpkin> physicist: you can in agda, but it's pretty tricky in practice :)
08:50:52 <ezyang> I used to always add a reset method. But then you're just adding cards to the tower... 
08:50:53 <dmwit> physicist: Modular arithmetic likely requires type-level naturals, but square matrices don't (as I demonstrated above).
08:50:54 <copumpkin> having static checking of the properties you want requires proofS!
08:50:57 <ezyang> *used 
08:51:04 <roconnor> you can kinda do it in Haskell but it is even less nice.
08:51:13 <roconnor> ^^ re :: mod n
08:51:33 <dmwit> physicist: If you know the modulus statically, it's much easier, of course.
08:51:40 <roconnor> oh right
08:51:43 <dmwit> physicist: You can just do it with a newtype.
08:51:46 <roconnor> I was assuming a staticly known modulus
08:51:51 <crystal-cola> roconnor: agda is some mad ad-hoc thing
08:51:59 <lpsmith> but then sometimes you don't have a statically known modulus
08:52:00 <roconnor> crystal-cola: Coq then?
08:52:02 <copumpkin> I can do mod 2^32 easily!
08:52:02 <crystal-cola> roconnor: whereas you can write out what lambda calculus is on one page
08:52:20 <copumpkin> or mod 2^{8,16,32,64}
08:52:24 * copumpkin laughs evilly
08:52:32 <dmwit> physicist: One second, I'll give an example of mod-five arithmetic.
08:52:39 <djahandarie> http://hpaste.org/44815/more_modulo
08:52:54 <lpsmith> I have a basic number theory library that might deserve to go on Hackage;  problem is separating out the functions I wrote for my own entertainment and those of general interest,  and deciding how various corner-cases should be handled
08:53:06 <djahandarie> lpsmith, don't pull a category-extras :)
08:53:13 <dmwit> Ah, there you go, djahandarie has given the general solution, so maybe I won't bother with a statically-known modulus example. =P
08:53:14 <crystal-cola> lpsmith: I will look through it if you want
08:53:22 <hpc> heh, once again, the comments to the sigfpe article are denser than the article itself
08:53:25 <roconnor> physicist: I have a recent paste for my elliptic curve module with does computation modulo some primes.
08:53:36 <physicist> you people are really going too fast for me
08:53:51 <djahandarie> Haha
08:53:54 <djahandarie> sasuga #haskell...
08:53:58 <lpsmith> djahandarie: I'm definitely staying away from fancy types for the number theory package,  it's more about useful algorithms
08:54:21 <roconnor> lpsmith: ideally there would be no corner cases
08:54:21 <crystal-cola> roconnor: I just think if you use these mad languages like haskell or agda where everything is just thrown in there - it's extremely difficult to say anything global about  programs, terms etc in the language with any certainty
08:54:33 <djahandarie> lpsmith, right, but the category-extras curse is that there is a bunch of crap obscuring all the useful stuff :) It generalizes past crazy types
08:54:37 <crystal-cola> roconnor: whereas the whole point of having lambda calculus formulaism is to be able to make global statements like "every program terminates"
08:54:40 <roconnor> crystal-cola: ya I more or less agree.
08:54:58 <crystal-cola> roconnor: programming seems to be more about throwing together meaningless clumps of API calls these days, though
08:55:02 <djahandarie> crystal-cola, (typed) of course 
08:55:14 <hpc> crystal-cola: you can still make those statements about sub-expressions
08:55:22 <lpsmith> roconnor:  Sure, that's ideal,  but how would you handle something like   6^(-2) (mod 15) or whatever
08:55:25 <roconnor> crystal-cola: badly designed ones at that say Harper :D
08:55:27 <ezyang> I wonder if anyone has proved that the lower bound on the size of the proof of some statement is X. 
08:55:28 <hpc> also, a lot of the crazy stuff is extensions
08:55:51 <lpsmith> or for that matter,  6^0 (mod 15)
08:56:09 <roconnor> 6^0 (mod 15) = 1
08:56:10 <lpsmith> (actually that one does have a pretty clear-cut answer)
08:56:11 <djahandarie> ezyang, where X is a function of the size of the statement? Or just a constant?
08:56:16 <lpsmith> roconnor: no
08:56:29 <ezyang> either. 
08:56:33 <roconnor> 6 isn't a divisor of 15 so 6^(-2) is defined.
08:56:42 <roconnor> er
08:56:44 <roconnor> wait
08:56:44 <hpc> djahandarie: "given statement FOO, the shortest proof of FOO has length X"
08:56:48 <lpsmith> yes
08:56:49 <roconnor> > gcd 6 15
08:56:50 <crystal-cola> 6 is not coprime to 15
08:56:50 <dmwit> physicist: Ask a question that tells the first place you got lost.
08:56:50 <lambdabot>   3
08:56:53 <roconnor> :(
08:56:58 <ezyang> it's sort of like Kolmogorov complexity 
08:57:08 <crystal-cola> > find ((==6).(`mod`15).(^2)) [1..15]
08:57:10 <lambdabot>   Just 6
08:57:32 <roconnor> lambdabot: ya, I'd do the same thing that 1/0 does for the rationals
08:57:33 <yrlnry> coincidentally, I was just reading about an essay of Boolos in which he presents some simple statement that has a short proof, but the proofs in a system with no Cut rule are all extremely long.
08:57:35 <hpc> perhaps this should move to -in-depth
08:57:41 <djahandarie> @thx
08:57:41 <lambdabot> you are welcome
08:57:48 <physicist> dwmit: I am not lost really just that I have had no time to take in any thing 
08:57:55 <roconnor> lpsmith: but I"d still make 6^0 (mod 15) = 1 I think
08:58:06 <hpc> physicist: don't worry, they are just expounding abstract nonsense
08:58:08 <crystal-cola> 6^2 = 36 = 15*2+6 = 6
08:58:15 <hpc> physicist: ;)
08:58:17 <lpsmith> so basically I chose  "safeModexp :: Integer -> Integer -> Integer -> Maybe Integer" and then define "modexp :: Integer -> Integer -> Integer -> Integer"
08:58:19 <yrlnry> I bet you could come up with long-proof theorems by using some sort of kruskal kirby paris harrington thingy.
08:58:25 <lpsmith> with the latter defined in terms of the former
08:58:37 <ezyang> "kruskal kirby paris harrington thingy" O.o 
08:58:54 <yrlnry> Sorry, http://en.wikipedia.org/wiki/Paris-Harrington_theorem
08:58:58 <djahandarie> Haha
08:59:07 <physicist> hpc: and I happen to be extremely interested in abstract non-sense
08:59:35 <djahandarie> That's almost as bad as "Curry-Howard-Lambek-Demorgan"
09:00:01 <djahandarie> Or whatever ddarius added on the end of Curry-Howard-Lambek which definitely isn't usually there
09:00:03 <lpsmith> hmm... actually yeah,  I do have 6^0 == 1 (mod 15)
09:00:06 <yrlnry> Well, I wasn't trying to name a single thing, but rather a small constellation of related stuff.
09:00:14 <roconnor> lpsmith: ya.  The error thrown by recip bugs me the most because I don't know a good way of eliminating it.
09:00:43 <roconnor> lpsmith: it is one of the few errors in the Prelude that I can't imagine getting rid of.
09:00:49 <roconnor> "error"s
09:00:51 <ezyang> "Since we can't decide whether or not the least fixed point or the greatest fixed point is best, lets compromise and use the average fixed point" 
09:00:56 <yrlnry> hee
09:01:11 <lpsmith> sigh, it's been a while since I've worked on NumberTheory :)
09:01:35 <yrlnry> In an unpublished blog post I once mentioned the Cauchy-Frobenius-Redfeld-Plya-Burnside theorem.
09:01:45 <yrlnry> People usually pick one or two of those.
09:02:21 <physicist> you know I wrote a small program for computing the gcd's polynomials but that was real field
09:02:45 <scree> ezyang: can't see from the above whether anyone's answered this, but the answer is yes
09:02:52 <yrlnry> And then of course there is the HOMFLY polynomial, which is the Host-Ocneanu-Millett-Freyd-Lickorish-Yetter polynomial.
09:02:52 <physicist> I was wondering if I could extend it to Galois fields
09:03:03 <ezyang> scree: Ooh, do you have a cite? 
09:03:31 <roconnor> ezyang: in Scott's domain theory aren't the greates and least fixpoints equal?
09:03:57 <ezyang> roconnor: I don't think so? 
09:04:03 <scree> ezyang: no, i'm retracting that, sorry
09:04:10 <roconnor> :^)
09:04:20 <physicist> That was why I wanted to pass modulus as a type argument
09:04:35 <djahandarie> physicist, see the hpaste I just linked
09:04:54 <lpsmith> Actually, can't you make a reasonable argument that  6 ^ 0 = 12 ^ 0 = 6 (mod 15) 
09:04:56 <ezyang> but I'm thinking about fixpoints of functions. 
09:05:10 <djahandarie> physicist, it stores the natural on the type-level and only does the modulus when you actually observe the number
09:05:22 <roconnor> lpsmith: what's the argument?
09:05:30 <ezyang> It doesn't take too much imagination to think of a function that has multiple fixpoints, of which fix will only find the lowest one. 
09:05:39 <physicist> I have it opened now
09:05:40 <crystal-cola> lpsmith: no
09:05:48 <roconnor> ezyang: I'm thinking of fixpoints of types
09:05:54 <ezyang> yeah, that's a little dicier :-) 
09:06:00 <physicist> but it will take some time for me to digest it
09:06:14 <ezyang> I'm not really sure. Actually, I don't think we talked about recursive types at all in my denot. semantics class... 
09:06:21 <roconnor> :O
09:06:50 <lpsmith> 6 is the multiplicative identity on the residual multiplicative sub-semigroup that it's in,  once you remove the group of units
09:07:01 <djahandarie> physicist, lines 2 - 10 are just the definition of type-level natural numbers and a type class for reifying them (observering them on the value level).
09:07:14 <crystal-cola> why would you remove the units?
09:07:17 <djahandarie> The actual Modulo stuff starts at 12
09:08:10 <scree> ezyang: though I'm now confused about the question.  There will surely be *some* statements in propositional logic where you can BFS on the shortest proof
09:08:35 <physicist> you have used so many language extensions it feels kinda scary
09:08:48 <physicist> I have never actually used it
09:09:16 <lpsmith> crystal-cola: well,  what should 0^0 (mod 15) be?
09:09:28 <ezyang> scree: Sure. For example, a |- a is trivially eliminable, and you can't get any shorter than that. 
09:10:15 <ezyang> but propositional logic can't support peano numbers, right? :-) 
09:10:36 <crystal-cola> lpsmith: I would set it to 1
09:10:40 <dmwit> lpsmith: 1
09:10:44 <djahandarie> physicist, just read through the file "naturally". The extensions are there to make the code nicer
09:10:57 <ezyang> Perhaps it doesn't make too much sense to ask for a bound for a noncomputable function 
09:11:18 <hpc> > 0^0
09:11:18 <lambdabot>   1
09:11:23 <crystal-cola> that is some kind of algorithm-finitism
09:11:41 <djahandarie> physicist, I'd walk you through it, but it's proving to be impossible since my internet is dropping every 3 seconds :(
09:11:58 <lpsmith> Well,  I think you could reasonably set 0^0 to be 0 as well,  although I didn't
09:12:01 <scree> ezyang: in *any* proof language I can BFS on proofs, giving an exact lower bound on the statements I find and a lower bound on the ones I don't
09:12:16 <crystal-cola> lpsmith: well you can do anything you want
09:12:24 <physicist> djahandarie: no problem 
09:12:34 <ezyang> Hmm, that does seem to be true. :-/ 
09:12:57 <physicist> I often find things scary before I have dirtied my hands with them
09:13:05 <lpsmith> sigh,  I might be confused;  as I've said, it's been too long
09:13:21 <crystal-cola> lpsmith: what identities about exponentiation are important? are they simpler with 0^0 = 0 or 1
09:14:44 <djahandarie> You know, I'm not sure if Veinor ever actually saw that hpaste, despite the fact that I wrote it for him :p
09:15:36 <Veinor> ?
09:16:04 <djahandarie> The type-level modulo arith one
09:16:07 <Veinor> oh, that thing
09:16:08 <djahandarie> http://hpaste.org/44815/more_modulo
09:16:23 <Veinor> yeah, i did but i don't remember going, oh, that makes sense'
09:16:26 <Veinor> :D
09:16:38 <djahandarie> Oh :(
09:17:10 <Veinor> sorry, type level magic is still beyond me at this point :(
09:17:31 <djahandarie> It's not magic! :(
09:17:40 <copumpkin> roconnor: hac phi?
09:18:06 <djahandarie> Well I need to go to class. o/
09:18:09 <roconnor> where/when?
09:18:13 <roconnor> @type runReaderT
09:18:14 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
09:18:15 <cwb> If I have "newtype Wrap a = Wrap {val :: String}" how do I derive classes using standalone deriving? a is used to specify an encoding. (the type is in a library so I can't do direct deriving)
09:18:25 <copumpkin> roconnor: http://www.haskell.org/haskellwiki/Hac_%CF%86
09:18:55 <cwb> Sorry, derive instances, not classes.
09:19:05 <roconnor> I don't think I can make it to Philadelphia
09:19:09 <hpc> cwb: standalone deriving works the same way as regular deriving; if you can't do it with regular deriving, you can't do it with standalone
09:19:22 <hpc> but assuming you can do it with regular deriving
09:19:27 <cwb> hpc: I can do it with regular deriving
09:19:29 <lpsmith> yeah, I think I was just confused
09:19:37 <hpc> cwb: ah, cool
09:19:44 <Veinor> djahandarie: see you \o
09:20:05 <cwb> hpc: But I don't control the library definition so need to do it using standalone deriving in my own code.
09:20:13 <copumpkin> roconnor: @!$!%@!$
09:20:27 <hpc> so then, "deriving instance Foo Bar"
09:21:01 <cwb> hpc: I get: Derived typeable instance must be of form (Typeable1 Wrap)
09:21:15 <hpc> instead of saying "data X deriving (Foo Bar, Baz Quux)" you say "deriving instance Foo Bar X; deriving instance Baz Quux X"
09:21:18 <hpc> or something like that
09:21:21 <hpc> http://haskell.org/haskellwiki/GHC/StandAloneDeriving
09:21:33 <hpc> cwb: oh, hmm
09:21:57 <c_wraith> yeah, ghc is rather weak at deriving TypeableX instances
09:22:03 <cwb> hpc: There's something about the a in  Wrap a = .. that messes things up (but normal deriving works fine).
09:22:25 <dmwit> roconnor: Oh, darn!
09:23:01 <roconnor> board crossing between US/Can I find to be a real pain.
09:23:17 <Saizan> cwb: use "deriving instance Typeable1 Wrap", you'll get Typeable a => Typeable (Wrap a) for free
09:25:40 <cwb> Saizan: super, that works for Typeable, can I do something similar for Data?
09:26:24 <chegibari> Sorry for the dumb question of the other day: the module system that was mentioned in "Types and programming languages" is obviously the ocaml's one not the haskell's one
09:26:31 <Saizan> cwb: try "deriving instance Data a => Data (Wrap a)"
09:26:33 <chegibari> as someone suggested here
09:27:14 <chegibari> I think haskell gets from type classes what misses because of the lack of functors
09:27:37 <Saizan> cwb: mh, that doesn't make much sense..
09:27:55 <hpc> haha, standalone deriving Data
09:27:58 <Saizan> cwb: is the Wrap constructor exported?
09:28:02 * hpc is tempted to do that to IO sometime :D
09:28:16 <hpc> spooky scope-changing at a distance
09:28:50 <Saizan> a derived Data for IO won't really help, i think
09:31:00 <cwb> Saizan: Thanks, that worked. What I'm trying to do is make (CompactString UTF8) from the compact-string package an instance of Data and Typeable so I can use JSON.Generic to convert it to json..
09:31:49 <cwb> Saizan: Now I need to do something with the UTF8 encoding so will go back and look at that. However, as you can tell I don't really know what I'm doing..
09:32:13 <lpsmith> crystal-cola: ok, I'm starting to remember stuff better;   defining 0^0 = 0 (mod 15) does actually make sense.
09:32:20 <lpsmith> pari-gp doesn't do that though
09:32:26 <crystal-cola> as I said you can do anything you want
09:32:39 <crystal-cola> in what way does it make sense?
09:32:51 <ezyang> I presume 15^15 = 0 mod 15? 
09:32:51 <copumpkin> I'd do 0^0 = 1
09:33:04 <lpsmith> if you do that 0^n (mod 15) is a well defined function (mod 8)
09:33:21 <crystal-cola> 8 = totient(15)
09:33:23 <lpsmith> actually,  x^n (mod 15) is a well defined function (mod 8)
09:33:36 <Saizan> cwb: you might end up needing a custom Data instance
09:33:48 <lpsmith> hmm, you might need a square-free modulus for that though
09:33:54 <Saizan> cwb: i don't know the details of JSON.Generic
09:33:56 * hackagebot cereal 0.3.2.0 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.3.2.0 (TrevorElliott)
09:34:59 <lpsmith> crystal-cola: correct.   but if you set 0^0 = 1 (mod 15) then it's x^n no longer a well defined function of n mod 15,  you also have to take into account what x is as well
09:35:15 <lpsmith> err, n mod 8
09:36:24 <lpsmith> ezyang: you forgot to add or subtract phi(15) in the exponent,  not the modulus 15
09:36:39 <lpsmith> so that's not really an argument for 0^0 = 0
09:36:49 <lpsmith> but yes, basically
09:37:05 <lpsmith> 15^16 = 0 mod 15 :)
09:37:08 <ezyang> oh, right. 
09:37:39 <rnik> Is anybody here familiar with Arrows?  I'm reading some tutorials on them, but not getting it.  I think because i'm new to haskell, I need to translate the concepts back into an imperative and lower level language, like java.
09:38:07 <crystal-cola> lpsmith: So you want a = b (mod phi(m)) => x^a = x^b (mod m)
09:38:20 <rnik> They seem now like a complex and verbose way to compose operations.
09:38:26 <cwb> Saizan: Thanks for your help! I realise I might need to do something custom, butI just need to figure out what..
09:38:39 <lpsmith> rnik: what would you like to do specifically
09:38:42 <lpsmith> crystal-cola: correct
09:38:53 <crystal-cola> and 0^0 = 1 does not allow that?
09:39:00 <lpsmith> <=> actually
09:39:02 <lpsmith> correct
09:39:05 <crystal-cola> why not?
09:39:44 <lpsmith> 0 = 8 (mod 8)  <=/=>  0^0 = 0^8 (mod 15)
09:39:59 <crystal-cola> Then set 0^8 = 1?
09:40:19 <rnik> lpsmith: the first thing was I downloaded this Euterpea code, which uses arrows, and is not compiling... one second I'll post on hpaste...
09:40:34 <crystal-cola> I suppose the problem with doing that is 0^4 * 0^4 is not equal to 0^8
09:40:35 <ezyang> Here's a question for y'all: Is the IO monad lazy? :-) 
09:40:38 <lpsmith> but I'm sure that causes even more problems than I was trying to solve in the first place
09:40:59 <lpsmith> ezyang: that's an ambiguous question :)
09:41:05 <ezyang> That's why I'm asking it :-) 
09:41:08 <c_wraith> what makes a monad lazy?
09:41:46 <c_wraith> By one (certainly wrong) definition, it's not.  (That definition is "(>>=) is strict in its first argument")
09:41:48 <lpsmith> well,  in the sense of the "lazy state monad" versus the "strict state monad",  IO is strict
09:42:02 <c_wraith> err, non-strict
09:42:08 <ezyang> Yeah, IMO, that's the non-interesting sense. 
09:42:40 <tswett> Modular arithmetic should tell you what 0^0 is, right?  Take 7 as your modulus.  Then by Euler's theorem, n^6 === 1 for n coprime to 7.  But 0 is not coprime to 7, so, uh, it turns out that's actually not helpful at all.
09:42:43 <ezyang> the interesting sense is if I write let x = foo () :: IO a, what is the representation of x? 
09:43:09 <c_wraith> Philippa has said before that she considers IO to be lazy, by some better definition.  If she's around, she'd be good to talk to
09:43:10 <lpsmith> crystal-cola,  there are good arguments either way,  but it causes an avalanche of other consequences.
09:43:11 <crystal-cola> I am convinced that 0^0 = 0 is more sensible than 0^0 = 1 in modular arithmetic
09:43:25 <lpsmith> Pari-gp chooses the latter
09:43:42 <lpsmith> I don't have mathematica handy
09:43:57 <lpsmith> The principle of least surprise also applies a bit to corner cases like this :)
09:44:01 <ezyang> I think what most people say is, "no, you actually have to write () -> ()" 
09:45:04 <rnik> Here's some particular arrow-related code that I was trying to understand: http://hpaste.org/46028/arrows_example_code. 
09:45:36 <tswett> crystal-cola: well, if you generalize Euler's theorem to include stuff that's not coprime, you end up with 0 === 0^6 === 0^0 === 7^0 === 1.  But that's simply not right, so which congruence do you get rid of?
09:46:02 <crystal-cola> yes you really need to be in the units group for things like Eulers theorem, I think
09:46:11 <rnik> But I think I'm looking also for high level statement about why they are useful - what are they doing that normal function composition can't.
09:46:29 <c_wraith> rnik: primarily, work with non-functions.
09:46:33 <tswett> We have that 7^6 === 0, 0^6 === 0, and 7^0 === 1, I think, which suggests that 0^0 = 1.  But you probably know more about this than I do.
09:47:57 <lpsmith> tswett: that's not right,  because 7 = 0
09:48:33 <rnik> c_wraith: do you mean that by making certain pieces of data implement the various arrow type classes, the data become function-like, and composable with other arrows?
09:48:39 <copumpkin> lpsmith: he's using that
09:48:48 <c_wraith> rnik: yes
09:48:56 <tswett> lpsmith: I'm operating in the integers and using === to denote congruence modulo 7.
09:49:07 <c_wraith> rnik: well, not *with* other arrows.  There's nothing in any of the arrow typeclasses about changing the type of a
09:49:14 <lpsmith> My point is that 7^0 /= 1 :)
09:49:20 <c_wraith> rnik: but at least *like* other instances of Arrow
09:49:32 <copumpkin> lpsmith: why not?
09:49:39 <twobitsprite> is ghc7 much different from ghc6? Also, is 7 relatively stable, or should it be treated as betaware?
09:49:41 <copumpkin> 7^0 in the integers is 1
09:49:45 <copumpkin> 1 mod 7 is 1
09:49:54 <tswett> 7^0 is 1 in, like, every ring.
09:50:00 <copumpkin> sure :P
09:50:05 <lpsmith> You can generalize Euler's theorem to non-coprime numbers,  but you have to give up x^0 = 1.
09:50:07 <copumpkin> <tswett> lpsmith: I'm operating in the integers 
09:50:27 <lpsmith> tswett: that doesn't make any sense
09:50:39 * tswett shrugs.
09:50:52 <copumpkin> @let x === y = x `mod` 7 == y
09:50:53 <lambdabot>  Defined.
09:51:03 <copumpkin> > 7^0 === 1
09:51:04 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
09:51:04 <lambdabot>    arising from a use of ...
09:51:08 <copumpkin> > (7^0) === 1
09:51:09 <lambdabot>   True
09:51:44 * copumpkin shrugs
09:51:50 <copumpkin> I don't see anything wrong with what tswett was saying
09:51:58 <Saizan> (===) = (==) `on` (`mod`7) simmetricity ftw
09:52:05 <copumpkin> Saizan: fair enough :)
09:52:09 <lpsmith> but ^ here isn't a modular exp
09:52:10 <copumpkin> @undef
09:52:22 <copumpkin> lpsmith: modular exp should be the same as exp follow by mod :P
09:52:36 <copumpkin> @let (===) = (==) `on` (`mod` 7)
09:52:36 <lambdabot>  Defined.
09:52:39 <tswett> > let x === y = x `mod` 7 == y in 13 === 13
09:52:40 <lambdabot>   False
09:55:24 <lpsmith> twobitsprite: there is quite a bit of changes in GHC 7, although a beginner wouldn't really notice it.   I've switched to 7 now,  the biggest thing holding me back was library support
09:57:02 <lpsmith> twobitsprite: the biggest changes would be some of the language extensions,  the IO manager,  a new inliner,  and a new (hopefully more robust if you are doing esoteric stuff) type checker,  and an LLVM code generator
09:57:11 <twobitsprite> lpsmith: I'm not sure I'd call myself a beginner... but not an expert by any means
09:57:45 <twobitsprite> lpsmith: anyways, thanks for the overview... overall the language is the same though, right?
09:57:58 <lpsmith> lots of little changes,   Data.List.sort is a fair bit faster now, for example
09:58:02 <lpsmith> yeah
09:58:31 <twobitsprite> ok, cool... a lot languages like to do major language overhauls on major version rollovers
09:58:51 <twobitsprite> perl4->perl5, python2->python3, etc
09:59:02 <Saizan> Haskell/=GHC
09:59:06 <koeien> the implementation does not define the language
09:59:09 <lpsmith> yeah, this isn't so much a major language overhaul
09:59:24 <koeien> which is more the case with perl / python
09:59:26 <twobitsprite> Saizan: yeah, yeah. I know this... it's also not the heat, it's the humidity
10:00:11 <twobitsprite> I just didn't know if maybe there was an overhaul of haskell and ghc decided to rolleover the major revision number... is that better? :P
10:00:26 <tswett> Finnish saunas are much hotter than American saunas and yet the Finns survive in them just fine.
10:00:32 <Saizan> it's not pedantry, you've to look at the haskell98/haskell2010/haskell2011 standards if you want to tell how the language is changing, GHC will always support those
10:00:36 <dmwit> The difference being that nobody asks a highly technical question where substituting "humidity" for "heat" changes the answer to the question.
10:01:03 <twobitsprite> ugh... irc people.... anyways, thanks
10:01:19 <crystal-cola> lol
10:01:22 <vegai> tswett: indeed, http://en.wikipedia.org/wiki/World_Sauna_Championships#2010_accident
10:01:28 <Zao> While there was (I believe) a Haskell 2011 recently, it's rather unrelated to any GHC bump.
10:01:30 <crystal-cola> IRC on IRC? It's more likely than you think
10:03:52 <ulidtko> hey, how can I select from [Maybe A] list of Just A values?
10:04:09 <Zao> ulidtko: There's a whole lot of fun functions in Data.Maybe.
10:04:19 <Zao> filter isJust might do.
10:04:24 <Saizan> > catMaybes [Just 1,Nothing, Just 2]
10:04:24 <lambdabot>   [1,2]
10:04:25 <Zao> Or catMaybes.
10:04:34 <ulidtko> Zao: thank you!
10:04:49 <ulidtko> the reference to Data.Maybe is enough :)
10:04:54 <tswett> I hate it when I try to answer a question and two other people simultaneously give the answer I was about to give.  :P
10:05:32 <yrlnry> tswett: it's funny but this exact question came up here an hour ago.
10:05:36 <Saizan> so, you don't like 3.0 audio
10:07:27 <tswett> I should make an irssi script that automatically answers common questions.
10:08:03 <tensorpudding> maybe lambdabot needs factoids?
10:08:07 <cinch> hi, im thinking of ordering the book "learn you a haskell". which second book would you recommend with it?
10:08:20 <yrlnry> The Imitation of Christ.
10:08:20 <Jafet> tswett: perhaps some here already have!
10:08:36 <yrlnry> Fifth Business is also good.
10:09:48 <ksf> RFC: what would you like a /usr/bin/runhaskell to be able to do? Current plans include caching of compiled scripts, scrouging env-variables and pragmas for implementation to use
10:10:52 <ksf> ...the background is a) improving startup times for scripts and b) solving issues that using /usr/bin/env would generate.
10:11:05 <cinch> yrlnry, thanks for the tipps. fifth business or imitation, i cant decide!
10:11:33 <lpsmith> yrlnry: well, almost the same question anyway ;-)
10:12:08 <yrlnry> It was the same up to isomorphism.
10:14:49 <gwern> tensorpudding: lambdabot has factoids
10:14:54 <Athas> How can I cast a 'Ptr CChar' to a 'Ptr Word8'?
10:15:26 <ksf> what's the current state of the art on commandline parsing? parseargs?
10:15:33 <gwern> @fact Dickie
10:15:34 <lambdabot> dickie: Dickie is a gentleman and a scholar.
10:15:41 * ksf never liked getopt
10:16:15 <gwern> ksf: I think I heard good things about cmdargs
10:17:05 <ksf> yep, it seems like being tremendously over-engineered, which is a good sign.
10:18:21 <luite> Athas: castPtr, if you really just want to cast
10:19:15 <Athas> Yep, thanks.
10:19:42 <luite> I'm not sure whether a CChar is always 1 byte, it probably is
10:20:01 <Athas> sizeof(char) is defined to be 1 in C.
10:20:19 <Athas> I've never heard of an implementation where the basic unit is not the byte (although a byte is sometimes six bits...).
10:21:30 <yrlnry> "byte" is defined in C as being the size of a char.
10:27:49 <koeien> but chars might be signed or unsigned
10:28:02 <koeien> a Word8 is always unsigned
10:35:07 <roconnor> @hoogle newIORef
10:35:07 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
10:40:53 <Athas> Signedness doesn't affect the inner representation, however.
10:41:00 <roconnor> @hoogle atomicallyModify
10:41:00 <lambdabot> No results found
10:41:16 <c_wraith> @hoogle atomicModifyIORef
10:41:16 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
10:41:22 <c_wraith> that what you wanted?
10:41:26 <roconnor> yes
10:44:01 <roconnor> @type left
10:44:01 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
10:44:06 <roconnor> @type first
10:44:06 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:44:11 <Kaidelong> @seen TacticalGrace
10:44:11 <lambdabot> Unknown command, try @list
10:44:11 <preflex>  TacticalGrace was last seen on #ghc 9 days, 11 hours, 14 minutes and 30 seconds ago, saying: np
10:44:31 <Kaidelong> oh he's in here now, oops
10:48:15 <dafis> Having leksah problems. Anybody here familiar with it?
10:48:23 <pmurias> ezyang: how can i flatten a FactBase?
10:49:02 <pmurias> ezyang: that is a backward transform when processing a O C takes a FactBase and must return a node
10:50:17 <roconnor> @hoogle trace
10:50:18 <lambdabot> Debug.Trace trace :: String -> a -> a
10:50:18 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
10:50:18 <lambdabot> module Debug.Trace
10:51:12 * hackagebot cprng-aes 0.2.1 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.2.1 (VincentHanquez)
10:52:06 <dafis> preflex: seen hamishmack
10:52:06 <preflex>  hamishmack was last seen on #haskell 8 days, 3 hours, 30 minutes and 40 seconds ago, saying: CSSE: Did you do import Char instead of import Data.Char ?
10:53:41 <Kaidelong> hmm, might as well ask in here too
10:53:55 <Kaidelong> how hard would it be to port "accelerate" to Windows?
10:53:59 <Kaidelong> does anyone know?
10:54:03 <Kaidelong> the CUDA version of it
10:54:09 <shapr> What's accelerate?
10:54:20 <cheater99> decelerate^-1
10:54:55 <Kaidelong> shapr: EDSL that is supposed to let you compile down Haskell things to work with CUDA
10:55:11 <Kaidelong> or with its own virtual machine
10:55:16 <Kaidelong> but I want CUDA
10:55:18 <hepek> didn't know that accelerate doesn't work on Win32
10:55:26 <shapr> oh, interesting... is that from TacticalGrace or from the Coconut guys?
10:55:30 <Kaidelong> hepek: It has a dependency on "unix"
10:55:33 <Kaidelong> TacticalGrace
10:56:00 <ezyang> pmurias: joinOutFacts is something of a blunt tool that gets the job done in that case. 
10:56:10 <ezyang> But it's deprecated and I'm not really sure what you're supposed to use instead. 
10:59:02 <pmurias> ezyang: thanks
10:59:07 <pmurias> ezyang: joinFacts lat l (successorFacts n f)
10:59:50 <ezyang> Ah, you have an obvious label to use :-) That's not always necessarily the case. 
11:02:05 <pmurias> ezyang: i'm only quoting the deprecation comment
11:03:41 <pmurias> ezyang: does the label matter at all?
11:04:16 <ezyang> It's used for debugging. 
11:04:52 <ezyang> the deprecated function I just quoted fakes up a label to be used. 
11:05:18 <pmurias> ezyang: did you use hoopl for anything you seem to be rather familiar with it?
11:05:41 <ezyang> I'm working on GHC's new code generator, which is Hoopl's ~primary client :_) 
11:06:09 <djahandarie> You're working on GHC's new code generator? :o
11:06:12 <pmurias> ezyang: where can i see the code?
11:06:37 <luite> does it generate Cmm?
11:07:26 <ezyang> pmurias: Grab yourself a copy of the GHC source code: http://hackage.haskell.org/trac/ghc/wiki/Building/GettingTheSources 
11:07:31 <ezyang> luite: Yep! 
11:14:10 <pmurias> ezyang: how should i fabricate a sensible label?
11:14:28 <ezyang> I'm not really sure. I've been meaning to ask SPJ/NR about it. 
11:14:35 * hybr1d slaps Skola around a bit with a large trout
11:14:51 <ezyang> I kind of suspect you want the label of the basic block that the last instruction is part of, but I don't know how to get that. 
11:16:35 <pmurias> would uniqueToLbl $ intToUnique some_big_int break anything?
11:19:18 <pmurias> i'll just use the deprecated function
11:26:11 <ezyang> Yeah, just use the deprecated function. 
11:26:23 <illissius`> ezyang: to the best of your knowledge, is replacing cmm with llvm ir wholesale something that would be desirable given infinite time and manpower, or something that wouldn't actually be desirable?
11:26:59 <ezyang> Hey all, does anyone know if the Canonical Forms lemma (190) proof requires me to do induction over the subtyping rules, or can I get away without having to do that? 
11:27:28 <ezyang> illissius`: As in s/cmm/llvm/? I don't think it's possible. 
11:28:40 <ezyang> (From Pierce. It goes something like: If v is a closed value of type T1 -> T2, then v has the form \x :: S1 -> t2 
11:29:35 <ezyang> It seems I need to show that subsumption rules can't cause an integer to be a function type. 
11:29:46 <ezyang> *take on the function type 
11:30:39 <illissius> ezyang: hmm, how come? afaik it was noted that they were developed for the same purpose and that (partly as a result) they're very similar; presumably then there's some pointed differences which would nonetheless make it infeasible?
11:31:45 <ezyang> I outline some reasons here: http://stackoverflow.com/questions/815998/llvm-vs-c-how-can-llvm-fundamentally-not-be-better-for-haskell-than-c/5692461#5692461 
11:34:15 <merijn> ezyang: There is an obvious reason why llvm can be fundamentally better. There are many more people working on optimizing and maintaining llvm then there are working on c--
11:34:27 <illissius> ezyang: oh, great, thanks. odd that i have stackoverflow:#haskell in my rss feed and didn't notice this, seems like something that would've interested me. probably got lost in the noise...
11:35:00 <illissius> merijn: well, right now the pipeline is cmm -> ghc/(hoopl) optimizations -> (optionally) llvm ir -> llvm optimizations
11:35:17 <illissius> so it's not like ghc can't benefit from all the work on llvm going on
11:35:41 <ezyang> Yes. We certainly should benefit from the LLVM work, and improve LLVM so it plays better with GHC. 
11:36:05 <ezyang> But they live at different levels of low-levelness. 
11:38:26 <illissius> but i recall reading that some llvm optimizations were being less effective than hoped for, and that the diagnosis was that not enough information was being transmitted in the cmm->llvm phase. plus, having two similar but separate low-level IRs in the pipeline seemed vaguely redundant. hence, my curiosity.
11:38:36 <illissius> but ezyang's answer is satisfactory. :)
11:39:18 <ezyang> Oh yes, definitely.  But I think you would failed to have transmitted that information if we directly generated LLVM anyway. 
11:41:00 <ezyang> Now, I might be underestimating what LLVM is capable of, not having directly worked with it. 
11:41:42 <ezyang> But I suspect we'd need to add a lot of intrinsics. 
11:41:58 <ezyang> Of course, the next question is, if we added those intrinsics, could LLVM subsume C--? To that, I'm not sure :-) 
11:43:03 <Anpheus___> What's an example of an intrinsic you might think you'd have to add to LLVM?
11:43:38 <ezyang> "please lay out my stack for me" 
11:43:47 <Anpheus___> ah ok
11:44:10 <ezyang> LLVM is not designed with FPs particularly in mind, and it kind of shows. 
11:44:31 <ezyang> erm, perhaps I should clarify, /lazy/ FPs. 
11:44:44 <Anpheus___> So in some ways LLVM is too low level, but doesn't that help in other ways? i.e.: by allowing you to do certain optimizations that used to have to be done by the Evil Mangler?
11:45:06 <crystal-cola> what waould the be implication sof a haskelle?
11:46:23 <copumpkin> crystal-cola: a female one?
11:46:24 <ezyang> Sorry, I don't really know anything about the Evil Mangler :-) 
11:48:23 <illissius> Anpheus___: afaik the evil mangler still has to exist because llvm doesn't actually support doing that, though while it still mangles it has become considerably less evil (hazy on the details)
11:49:05 <illissius> i saw a bug/feature request/project idea on the trac regarding adding support for it to llvm -- can't remember if it would be just another optimization pass, or if it would need deeper changes
11:51:47 <jmcarthur> are the properties of div for some reason nicer than those of quot? does the difference between the two really matter all that much?
11:52:25 <Anpheus___> @src quot
11:52:25 <lambdabot> Source not found. You speak an infinite deal of nothing
11:52:28 <jmcarthur> (for those who don't even know the different, div truncates towards negative infinity, and quot truncates towards zero)
11:52:32 <jmcarthur> *difference
11:52:41 <crystal-cola> > (-5)`div`3
11:52:42 <lambdabot>   -2
11:52:43 <crystal-cola> > (-5)`quot`3
11:52:44 <lambdabot>   -1
11:53:06 <kmc> did the patches to make LLVM support data next to code make it upstream?
11:53:35 <crystal-cola> so if a`div`b = d then d*b + r = a
11:53:40 <kmc> iirc that was the only optimization still requiring an evil mangler with the LLVM backend
11:53:49 <crystal-cola> but if a`quot`b = d then d*b +/- r = a  (sign depending on the sign of a)
11:53:51 <crystal-cola> ?
11:53:52 <jmcarthur> crystal-cola: that property holds for divMod and quotRem
11:54:09 <jmcarthur> crystal-cola: mod and rem differ in signedness of the remainder sometimes, i think
11:54:14 <crystal-cola> > quotRem (-5) 3
11:54:15 <lambdabot>   (-1,-2)
11:54:18 <crystal-cola> > divMod (-5) 3
11:54:19 <lambdabot>   (-2,1)
11:54:25 <crystal-cola> > quotRem 5 (-3)
11:54:26 <lambdabot>   (-1,2)
11:54:30 <crystal-cola> > divMod 5 (-3)
11:54:31 <lambdabot>   (-2,-1)
11:54:53 <crystal-cola> so in divMod the remainder has the same sign as the denominator
11:55:23 <crystal-cola> but in quotRem the remainder has the same sign as the numerator
11:55:43 <jmcarthur> @check \a b -> let (q,r) = a `divMod` b in a == q*b + r
11:55:44 <lambdabot>   "*Exception: divide by zero
11:55:50 <shapr> @quote jmcarthur
11:55:50 <lambdabot> jmcarthur says: *knowing* is toxic. only by recognizing one's own ignorance can discovery begin
11:55:50 <crystal-cola> I don't know any time when someone would be using either of these functions on negative numbers
11:55:55 <jmcarthur> @check \a b -> b /= 0 ==> let (q,r) = a `divMod` b in a == q*b + r
11:55:55 <lambdabot>   No instance for (Test.QuickCheck.Testable
11:55:55 <lambdabot>                     (Test.QuickCh...
11:57:11 <crystal-cola> when would someone be dividing negative numbers?
11:57:15 <crystal-cola> That makes no sense to me
11:57:28 <crystal-cola> what possible situation?
11:57:28 <merijn> crystal-cola: Why not?
11:57:59 <jmcarthur> crystal-cola: i'm looking at my fixed-point package right now (which uses div in its implementation for fixed-point division), so i need to figure out what to do for different signed arguments to behave nicely
11:58:25 <crystal-cola> just implement whatever is simplest and document it
11:58:39 <jmcarthur> i know quot would be faster, but not which would be more nicely behaved
11:58:57 <crystal-cola> nicer for what? probably nobody will ever use it since no one divides negative numbers
11:59:08 <jmcarthur> umm
11:59:35 <Kaidelong> crystal-cola: then you can make the assumption explicit with an unsigned data type
11:59:48 <crystal-cola> yeah that is a good idea
11:59:50 <Kaidelong> > (-6) :: Word32
11:59:51 <lambdabot>   4294967290
12:00:03 <Kaidelong> although
12:00:08 <Kaidelong> for that data type
12:00:18 <Kaidelong> div and quot should be two different names for the same thing
12:00:29 <Kaidelong> unless they aren't methods
12:00:36 <Kaidelong> which would surprise me
12:00:41 <jmcarthur> :t div
12:00:42 <lambdabot> forall a. (Integral a) => a -> a -> a
12:00:51 <jmcarthur> they are
12:01:08 <jmcarthur> @src div Int
12:01:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:01:12 <jmcarthur> @src Int div
12:01:12 <lambdabot> Source not found. There are some things that I just don't know.
12:01:15 <jmcarthur> *sigh*
12:01:46 <Kaidelong> @check \a,b-> (a `div` (b :: Word32)) == (a `quot` b)
12:01:46 <lambdabot>   Parse error at ",b->" (column 3)
12:01:52 <Kaidelong> @check \a b-> (a `div` (b :: Word32)) == (a `quot` b)
12:01:52 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Word.Word32)
12:01:53 <lambdabot>    arising from...
12:02:00 <Kaidelong> ...?
12:02:14 <Kaidelong> I guess someone needs to add that instance
12:02:22 <Kaidelong> what's an unsigned type that does have such an instance?
12:02:31 <jmcarthur> crystal-cola: say i have a vector in 3d space that i want to normalize. if any of its components are negative then i'll be doing division with a negative numerator
12:02:40 <Kaidelong> @instances Test.QuickCheck.Arbitrary
12:02:41 <lambdabot> .Arbitrary (), .Arbitrary Bool, .Arbitrary Char, .Arbitrary Double, .Arbitrary Float, .Arbitrary Int, .Arbitrary Integer
12:03:12 <crystal-cola> jmcarthur: that's a(n approximation of a) field though
12:03:19 <crystal-cola> so it's not div/mod quot/rem stuff
12:03:26 <Kaidelong> @check \a b-> (fromEnum a `div` (fromEnum b :: Char)) == (fromEnum a `quot` fromEnum b)
12:03:27 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:03:32 <jmcarthur> crystal-cola: it's div/quot stuff in a fixed point library
12:03:39 <Kaidelong> @check \a b-> (fromEnum a `div` (fromEnum (b :: Char))) == (fromEnum a `quot` fromEnum b)
12:03:40 <lambdabot>   "OK, passed 500 tests."
12:03:52 <Kaidelong> @check \a b-> (fromEnum a `div` (fromEnum (b :: Char))) == (fromEnum (a :: Char) `quot` fromEnum b)
12:03:53 <lambdabot>   "OK, passed 500 tests."
12:03:56 <Kaidelong> there we go
12:04:24 <Kaidelong> Char is the same as Word16 right?
12:04:28 <jmcarthur> no
12:04:32 <crystal-cola> http://en.wikipedia.org/wiki/Division_algorithm
12:04:33 <jmcarthur> Char is just a unicode codepoint
12:04:33 <copumpkin> hell no
12:04:40 <Kaidelong> hmm
12:04:42 <copumpkin> thank god
12:04:51 <crystal-cola> you can divide integers and polynomials but not things like rationals or floats (which are an approximation of rationals)
12:04:52 <kmc> the bit-level storage of Char is totally unspecified
12:04:52 <Kaidelong> so the representation of Char can be of variable size?
12:05:00 <copumpkin> Kaidelong: in practice it's a Word32
12:05:02 <kmc> according to the standard
12:05:04 <copumpkin> but yeah, not specified
12:05:24 <copumpkin> or a native Word actually I think
12:05:30 <kmc> note that many Unicode codepoints can't be represented in 16 bits
12:05:32 <copumpkin> so possibly 64 on a 64-bit machine
12:05:55 <dafis> crystal-cola: whenever you show a Double or Float of absolute modulus between 0 and 1, you divide a negative number to find an approximation to the base-10 logarithm
12:06:16 <jmcarthur> crystal-cola: i don't see how your statement follows from that wikipedia article
12:06:35 <kmc> it's a persistent myth that Unicode is a 16-bit character set.  it's actually a set of abstractly numbered characters (more than 2^16 of them) plus a variety of different ways to represent those numbers as byte sequences
12:07:03 <copumpkin> I don't think java helps with this
12:07:08 <merijn> kmc: People who claim that should be send to re-education camps until they accept the one true encoding!
12:07:09 <dafis> > fromEnum $ maxBound :: Char
12:07:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
12:07:10 <lambdabot>         against inferred type...
12:07:16 <mauke> > ord maxBound
12:07:16 <lambdabot>   1114111
12:07:22 <kmc> didn't i just acknowledge the existence of multiple encodings? ;)
12:07:23 <dafis> > fromEnum $ (maxBound :: Char)
12:07:24 <lambdabot>   1114111
12:07:57 <Kaidelong> kmc: I'm aware of that, it just seems like UTF-16 is something of a standard
12:08:00 <merijn> kmc: That's where you're wrong, there is only one encoding. UTF-8 or death! >:x
12:08:03 <jmcarthur> crystal-cola: the rationals form a field, btw
12:08:04 <Kaidelong> so I wrongly assumed that haskell was using it too
12:08:14 <crystal-cola> yes that's what I am saying
12:08:15 <copumpkin> Kaidelong: that's an encoding for strings
12:08:15 <merijn> Kaidelong: UTF-16 is a variable size encoding
12:08:17 <Kaidelong> but unspecified makes sense
12:08:18 <kmc> Kaidelong, UTF-8, UTF-16, and UTF-32 are all something of a standard.  and by "something" i mean precisely that, standards
12:08:31 <lpsmith> case e of {Inl x -> Inl x ; Inr x -> Inr x} = e
12:08:32 <Kaidelong> kmc:
12:08:34 <kmc> in my experience it's a lot more common to encounter UTF-8 text than UTF-16
12:08:34 <mauke> Kaidelong: if you want fixed-width units, see UTF-32
12:08:36 <kmc> maybe not on Windows
12:08:38 <Kaidelong> as in a lot of implementations use it
12:08:39 <lpsmith> How is the above eta reduction?
12:08:49 <kmc> and you can't represent all Chars in UTF-16 as a single Word16
12:08:59 <Kaidelong> right, some of them are escapes
12:09:00 <jmcarthur> fields have division...
12:09:06 <merijn> mauke: Until unicode grows and UTF-32 is also made variable length....
12:09:07 <Kaidelong> so for a single Char objct
12:09:17 <mauke> merijn: might be a while, current width is 21 bits
12:09:22 <Kaidelong> you may have to have >16 bits
12:09:23 <crystal-cola> fields have multiplicative inverse
12:09:27 <Kaidelong> err I should say Char structure
12:09:38 <merijn> Kaidelong: UTF-16 using programs used to use UCS-2 (which is fixed size of 16 bits), but UTF-16 is variable size
12:09:40 <Kaidelong> that is a fair point, I was still trying to think in C terms
12:09:42 <crystal-cola> integers, polynomials (euclidean domains) have divison
12:09:58 <kmc> right.  a non-BMP character is still a single Char
12:10:17 <kmc> if your Haskell implementation uses UTF-16, it will encode that single Char as two UTF-16 surrogates and hide this fact from you
12:10:27 <crystal-cola> there is no remainder when "dividing" field elements
12:10:29 <Kaidelong> so lambdabot would need an arbitrary instance for some or other unsigned type
12:10:42 <Kaidelong> and you can't just substitute Chars in the role
12:10:48 <shapr> merijn: So, where's the "what every programmer should know about unicode." document?
12:10:49 <jmcarthur> crystal-cola: "The most important difference is that fields allow for division (though not division by zero), while a ring need not possess multiplicative inverses."  <-- from wikipedia page on fields
12:11:01 <jmcarthur> crystal-cola: you don't need a remainder to have division
12:11:09 <merijn> shapr: Somewhere on joelonsoftware, but to lazy to google it atm :p
12:11:12 <crystal-cola> you don't need to paste this stuff at me, try to understand what I am saying instead
12:11:15 <merijn> My first task after taking over the world will be to rid the world of all heathen encodings which are not UTF-8...
12:11:21 <shapr> merijn: I found it, thanks.
12:11:25 * shapr hugs boegel 
12:11:33 <shapr> boegel: Thanks for the awesome Haskell t-shirt!
12:11:35 <dafis> shapr: I think Joel Spolsky wrote an article with that title
12:11:42 <shapr> dafis: I'm re-reading that now.
12:11:45 <merijn> shapr: I usually just google "unicode joel", I think it's the first hit
12:11:49 <shapr> I wonder if there's an updated version?
12:11:52 <merijn> dafis: That's the one he was asking for :p
12:12:20 <dafis> merijn: I'm just too slow
12:15:00 <nib2> Hi everybody
12:15:23 <adnam> hi dr nib
12:15:58 <shapr> howdy nib2 
12:15:59 <nib2> With your help i have successly done my code. Can you help me please this problem : my code is "trim_withcallback ( callback_name "    Hello    " )" the problem is that callback_name is called with "    Hello    " as parameter. Who to make "callback_name" as first and "    Hello    " second parameter of "trim_withcallback" ? Google say about the dot character but i dont really understand who to work. 
12:16:11 <shapr> whoa
12:16:24 <shapr> nib2: Are you sure you have the right irc channel?
12:16:35 <shapr> nib2: That looks like an object oriented language of some sort.
12:16:40 <mauke> nib2: trim_withcallback callback_name "    Hello    "
12:16:58 <nib2> yes my problem is with Haskell language
12:17:05 <shapr>  ok, just checking.
12:17:39 <jmcarthur> so does anybody else have anything helpful to say? is div for some reason preferable to quot when you have to truncate data?
12:17:40 <nib2> i have try "trim_withcallback ( callback_name .  "    Hello    " )" but this generated other errors
12:17:42 <boegel> shapr: np :)
12:17:45 <mauke> nib2: trim_withcallback callback_name "    Hello    "
12:18:44 <nib2> okey, the problem is elsewhere
12:18:46 <nib2> thank you !
12:18:53 <dafis> jmcarthur: If you want to truncate (towards 0), quot is the way
12:19:17 <jmcarthur> i mean using it as an approximation of field division
12:19:54 <nib2> arrr
12:19:59 <crystal-cola>  I don't think you understand what I have been trying to explain 
12:20:01 <nib2> thank you very much !
12:20:54 <nib2> ghc is so intelligent whaou :)
12:21:46 <nib2> thank you and see later
12:26:34 <dafis> jmcarthur: to approximate field division for a fixed point type? That would mean rounding to k places, so quotRem or divMod, I think. Both require checking the signs - at least, I don't see how to avoid that at the moment -, so I'd go with quotRem, since divMod does a check of its own, so you'd duplicate work.
12:26:38 <DasIch> why would this cause an exception "Non-exhaustive patterns in function removeAt" http://paste.pocoo.org/show/378065/ when called with removeAt 2 "abc"?
12:27:10 <mauke> DasIch: compile with ghc -Wall
12:27:24 <mauke> (I hope that actually works)
12:27:29 <dafis> DasIch: probably because you don't decrement n in the recursive call
12:28:10 <danharaj> that's not it :)
12:28:19 <danharaj> what if I call removeAt 5 []?
12:28:29 <DasIch> dafis: that solves it
12:28:40 <dafis> DasIch: the pattern removeAt n [] is missing
12:28:48 <DasIch> oh, yeah
12:29:01 <danharaj> you also had an infinite loop caused by the lack of a decrement
12:29:09 <danharaj> which wasn't appearing because you would hit the st.
12:29:14 <danharaj> first*
12:29:40 <DasIch> thanks for the help :)
12:46:58 <shapr> anders^^: Are you Carlsson?
12:47:43 <shapr> Anyone heard of a DSL for card games?
12:48:02 <alej> i tried to write one once
12:48:12 <shapr> Must support standard 52-card and UNO decks.
12:48:29 <alej> in scheme, used a rule production system, or whatever the proper name for that is
12:49:06 <anders^^> shapr: karlsson
12:49:28 <shapr> anders^^: So you're not the guy working in Cupertino then...
12:49:47 <anders^^> no
12:49:55 <ddarius> djahandarie: Curry-Howard-deBruijn-Lambek-Lawvere
12:50:18 <crystal-cola> what's Lawvere got to do with it?
12:51:46 <ddarius> Likely the theory of doctrines.
12:51:53 <crystal-cola> thanks
12:54:12 * sm upgrades hackagebot infrastructure, expect minor outages today
12:58:09 <ezyang> Ugh. Subtyping is just /not worth the trouble/. 
12:58:31 <copumpkin> I agree
12:59:30 <byorgey> hehehe
13:00:37 <crystal-cola> what data tyep is 1/(1-ax+bx^2)
13:01:01 <ezyang> :t 1/(1-ax+bx^2) 
13:01:02 <lambdabot> Not in scope: `ax'
13:01:02 <lambdabot> Not in scope: `bx'
13:01:05 <tswett> @type \ax bx -> 1/(1 - ax + bx^2)
13:01:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:01:12 <roconnor> I find it ironic that "The Point of Laziness" missed the point of laziness, which is the ability to tie the knot. (see More Haste, Less Speed)
13:01:20 <monochrom> subtyping works best when you also have dependent typing and provide some proofs manually
13:01:22 <tswett> crystal-cola: its type is "a", where "a" is the type of ax and bx and must be a Fractional.
13:01:31 <ezyang> roconnor: Real men tie the knot by back patching! 
13:02:04 <ezyang> Actually, I'm just annoyed because I'm proving progress for a lambda calculus that has too many features as a HW assignment. 
13:03:00 <monochrom> there are many points of laziness, not one single "the" point
13:03:40 <roconnor> monochrom: maybe you are right
13:03:47 <roconnor> but still, that is a big missing point
13:03:53 <crystal-cola> I mean
13:03:59 <crystal-cola> 1/(1-x) is the list type
13:04:06 <crystal-cola> so what is 1/(1-ax+bx^2)
13:04:21 <roconnor> you can do things efficently in an immutable lazy language that just cannot (known) to be done in an immutable strict language
13:04:41 <roconnor> *is not known to be possible
13:05:52 <tswett> crystal-cola: 1/(1 - x) doesn't look like a list to me, nor the type of a list, so I'm not sure what you're saying.
13:05:59 <tswett> crystal-cola: perhaps you could explain the problem you're trying to solve?
13:06:00 <copumpkin> it is a list!
13:06:01 <ezyang> How did Haskell decide to be pure in the first place? 
13:06:09 <crystal-cola> that IS the problem I was trying to solve
13:06:10 <shapr> Because Gopher was pure?
13:06:15 <Saizan> "but we use ML, we have effects to memoize the functional encoding of codata!"
13:06:21 <shapr> ezyang: Haskell is an open source clone of Gopher, right?
13:06:34 <ezyang> "How did Gopher decide to be pure?" 
13:06:51 <shapr> ezyang: do not know
13:06:56 <roconnor> Saizan: heh.  So ML's solution to efficent immutable structures is mutation?
13:06:58 <monochrom> haskell was by a committee
13:07:00 <illissius> shapr: of miranda
13:07:06 <shapr> illissius: oh right
13:07:06 <roconnor> Saizan: I don't know how I feel about that.
13:07:08 <shapr> that one
13:07:10 <shapr> illissius: thanks
13:07:20 <illissius> duno how gopher enters into the picture exactly
13:07:25 <illissius> *dunno
13:07:26 <roconnor> ya, Haskell is more or less a free Miranda clone
13:07:26 <crystal-cola> list x = 1 + list x --> list x = 1/(1-x)
13:07:27 <Saizan> roconnor: that's something i gather from skimming that post
13:07:29 <illissius> maybe that was a pre-haskell?
13:07:32 <ezyang> I'm pretty sure purity is worth it.  Maybe laziness isn't.  But purity definitely is. 
13:07:42 <crystal-cola> ???? --> 1/(1-ax+bx^2)
13:07:56 <shapr> I certainly prefer laziness for 95% of the code I've written.
13:08:05 <roconnor> I'm not going to give up my beta-rule without a clear reason. ^_^
13:08:35 <Saizan> tswett: http://comonad.com/reader/2008/generatingfunctorology/
13:08:47 <crystal-cola> there should be a reduction rule that replaces every string with "spam"
13:08:52 <tswett> crystal-cola: I don't think I understand your notation, then.  Interpreted as a mathematical equation, "list x = 1 + list x" is unsolvable; interpreted as a Haskell equation, it will run forever unless + has an unusual definition.
13:09:08 <crystal-cola> haskell data types
13:09:18 <tswett> crystal-cola: oh, will that thing Saizan linked help me understand this?
13:09:19 <Saizan> tswett: + is to be interpreted as Either there
13:09:20 <ezyang> I have a super-awesome space leak in some code I wrote for GHC recently. It was easy to identify with heap profiling, but I got annoyed because there wasn't an obvious way to introduces the necessary strictness without modifying IntMap 
13:09:25 <roconnor> crystal-cola mean to write list x = 1 + x*list x
13:09:27 <tswett> Ookay.  Thank you.
13:09:36 <crystal-cola> thanks for the correction roconnor 
13:09:50 <ezyang> How does one write a strict map, with only a lazy map? I don't think it's possible. 
13:10:10 <roconnor> foldr seq something?
13:10:22 <illissius> (i'm not sure whether laziness-with-optional-strictness-annotations-in-types or strictness-with-optional-lazy-application (ddc) is the happier local optimum, but in any case having the former would sure be nice. seems to go hand-in-hand with having strict core...)
13:10:25 <ezyang> But that requires me to traverse the structure again, /and/ also assuems I have a fold. 
13:10:29 <monochrom> similarly you can't write foldl' based on foldl
13:10:50 <roconnor> I really don't like the idea of function abstraction changing my semantics
13:11:06 <ezyang> Well then, we've got some work to do then! 
13:11:08 <roconnor> when I abstract out a piece of code, I don't really want it to change just because I did so
13:11:16 <roconnor> otherwise I need to get into macros ....
13:11:18 * roconnor shudders
13:11:18 <ezyang> I wish I didn't have to write lazy and strict versions of all my functions manually... 
13:11:29 <roconnor> ezyang: just stick with the lazy ones ;)
13:11:44 <roconnor> if it is a problem, make things more lazy :D
13:11:45 <ezyang> roconnor: Not if I have awesome space leas :-) 
13:11:47 <crystal-cola> Maybe it's not a haskell type
13:12:02 <roconnor> ezyang: space leaks are often caused by too much strictness
13:12:05 <Saizan> roconnor: though going from "(exp,exp)" to "(\x -> (x,x)) exp" changes sharing 
13:12:09 <ezyang> Maybe I should fix GHC's strictness analyzer to not leak in this case >:-) 
13:12:16 <tswett> crystal-cola: I think any rational function can be thought of as a Haskell type as long as all of the coefficients of its Maclaurin series are non-negative.
13:12:28 <roconnor> Saizan: true, but not the dentotational semantics
13:12:34 <roconnor> Saizan: though your point is well taken
13:12:50 <crystal-cola> 1 + a*x + (a^2 - b)*x^2 + (a^3 - 2*b*a)*x^3 + (a^4 - 3*b*a^2 + b^2)*x^4 + (a^5 - 4*b*a^3 + 3*b^2*a)*x^5 + O(x^6)
13:12:52 <roconnor> ezyang: make things more lazy...
13:12:54 <ezyang> roconnor: It's sort of like the Ballmer peak, eh? 
13:12:58 <tswett> crystal-cola: so whether this is a Haskell type or not depends on the values of a and b.
13:13:02 <crystal-cola> I've computed it here
13:13:15 <copumpkin> crystal-cola: make it -bx^2 and it's not bad
13:13:26 <roconnor> crystal-cola: those negative signs don't look so good.
13:13:26 <crystal-cola> yes there is a negative that makes things difficult
13:13:44 <roconnor> unless b is negative
13:13:47 <copumpkin> if it's 1 / (1 - ax - bx^2)
13:13:51 <copumpkin> it's basically
13:14:07 <ezyang> roconnor: I... don't think that's really possible, in this circumstance. 
13:14:16 <crystal-cola> I give up trying to read this as a haskell type
13:14:36 <copumpkin> data Moo x = Oink | Foo A x (Moo x) | Bar B x x (Moo x)
13:14:58 <ezyang> roconnor: I'd love to be convinced otherwise though :-) 
13:15:00 <ddarius> Gofer (with an 'f') was a playground for constructor classes primarily.  It got folded back into Haskell 1.3 I think.
13:15:09 <ddarius> Hugs stands for "Haskell User's Gofer System"
13:15:11 <tswett> So, (Tree x) = 1 + x * (Tree x)^2, right?
13:15:22 <crystal-cola> yes that is tree
13:15:41 <ezyang> ddarius: Huh, constructor classes? 
13:16:12 <doserj> type classes for type constructors, not just for types
13:16:54 <tswett> Wolfie says that if x = 0, then Tree x = 1; elsewhere, Tree x =  (sqrt(1 - 4x) + 1)/(2x).  How lovely.
13:17:03 <crystal-cola> lol
13:17:16 <ddarius> Generating functions are fun.
13:17:18 <tswett> And that ain't no rational function.
13:17:30 <crystal-cola> I think that 1/sqrt(1 - 4x) = sum (2n C n) x^n or something
13:17:52 <tswett> It looks like this whole thing makes the Catalan numbers.  At least, that's what the blog says.
13:18:08 <yrlnry> I think I wrote a blog post about it if that will help.
13:18:33 <yrlnry> http://blog.plover.com/math/catalan-squared.html
13:18:41 <tswett> "It turns out the coefficients of our generating function are . . . the number of ways you can build a binary tree of n nodes."  I shouldn't be surprised.
13:18:59 * illissius unplugs the internet
13:19:09 <crystal-cola> great!!
13:19:26 <tswett> What's this that the post says about allowing other Species?
13:20:29 <Saizan> Species are other types that you can define by generating functions but not directly as e.g. haskell datatypes
13:20:38 * tswett nods.
13:20:57 <tswett> How long until GHC accepts arbitrary differential equations as data definitions?  :P
13:21:07 <crystal-cola> haha
13:21:40 <crystal-cola> Now I know why it's called lambda calculus
13:21:57 <Fuco> I'm using parsec's buildExpressionParser to parse simple math expressions... how can I check if there's some input left after it return?
13:22:05 <Fuco> for instance "1+2)" should return error
13:22:11 <Fuco> but it returns 3 just fine
13:22:32 <Saizan> there's "eof"
13:22:35 <shachaf> preflex: calc 1+2)
13:22:36 <preflex>  3
13:22:40 <shachaf> Looks OK to me.
13:23:01 <Fuco> well, I want all ( ) to be in pair
13:23:05 <Fuco> so it's not a valid expression
13:23:08 * hackagebot http-types 0.6.3 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.3 (AristidBreitkreuz)
13:23:15 <shachaf> preflex: calc 1+2)(
13:23:15 <preflex>  3
13:23:23 <monochrom> haha shachaf
13:23:24 <Fuco> it doesn't matter what you add
13:23:28 <Fuco> preflex: calc 1+2)(847fhn2378yn
13:23:29 <preflex>  Lexical error
13:23:32 <Fuco> oh :P
13:23:35 <Fuco> well, you know what I mean
13:23:41 <Fuco> preflex: calc 1+2)(11111
13:23:42 <preflex>  Too many operands
13:23:45 <Fuco> wtf
13:23:49 <mauke> Fuco: yourParserHere <* eof
13:23:50 <Saizan> ?hoogle eof
13:23:51 <lambdabot> Text.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
13:23:51 <lambdabot> Text.ParserCombinators.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
13:23:51 <lambdabot> Text.Read EOF :: Lexeme
13:23:57 <monochrom> but yeah, parsec has eof for that
13:24:17 <mauke> Fuco: you gave it 3 operands but only 1 operator
13:24:20 <mauke> that doesn't add up
13:24:23 <Fuco> I see
13:24:48 <Fuco> what is <* by the way?
13:25:10 <mauke> @hoogle <*
13:25:10 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
13:25:10 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:25:10 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:25:21 <monochrom> oh bother my parsec example doesn't have eof
13:25:42 <mauke> Fuco: basically, p1 <* p2 means: parse p1, then p2, but return p1's result
13:27:57 <roconnor> @src (<*)
13:27:57 <lambdabot> (<*) = liftA2 const
13:28:09 * hackagebot zampolit 0.1 - A tool for checking how much work is done on group projects.  http://hackage.haskell.org/package/zampolit-0.1 (BrianSniffen)
13:28:17 <yrlnry> @src (&&&)
13:28:18 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
13:28:27 <yrlnry> @src (***)
13:28:27 <lambdabot> f *** g = first f >>> second g
13:29:12 <yrlnry> What are the standard mathematical notations for &&& and ***?   I think maybe one is (f, g) and one is fg, but I realized this weekend that I was conflating them.
13:30:19 <pastorn> preflex: seen conal
13:30:19 <preflex>  conal was last seen on #haskell 8 days, 23 hours, 3 minutes and 15 seconds ago, saying: ian_mi: that's why languages usually have at least one non-strict building block, typically if-then-else
13:30:39 <pastorn> wait... is that last activity or last seen?
13:30:56 <pastorn> (not counting disconnecting as an "activity")
13:31:34 <copumpkin> > Left 5 == Left 5
13:31:35 <lambdabot>   True
13:31:38 <yrlnry> In particular, if AB is a product of objects A and B in a category, and we have arrows f : CA and g : CB, then there must be a unique  arrow from CAB, and what is this unique arrow called?  (f, g) or fg?
13:31:48 <copumpkin> what are the types there?
13:31:57 <copumpkin> <f , g>
13:32:00 <yrlnry> Thanks.
13:32:05 <copumpkin> I think
13:32:14 <mauke> copumpkin: Either Integer (), Bool
13:32:16 <copumpkin> also, ##categorytheory might be of interest :)
13:32:20 <yrlnry> That corresponds to (&&&).
13:32:23 <copumpkin> mauke: you sure?
13:32:39 <copumpkin> I was thinking it might be Any
13:32:46 <crystal-cola> yrlnry: I think that  is a bifunctor
13:32:53 <mauke> > def
13:32:53 <yrlnry> I thought it was (Num a)  => Either a b
13:32:53 <lambdabot>   Not in scope: `def'
13:33:08 <mauke> yrlnry: it needs a concrete a to resolve ==
13:33:09 <copumpkin> > length []
13:33:10 <lambdabot>   0
13:33:17 <yrlnry> oh, right.
13:33:21 <copumpkin> what is that list instantiated to? I'm pretty sure it's Any
13:34:02 <yrlnry> Anyway, I thought there was also a standard mathematical notation for (***), perhaps fg.
13:34:24 <copumpkin> yrlnry: xplat loves the triple star in a triangle formation character :P
13:34:28 <crystal-cola> yrlnry: if you're talking the product functor in some category you can use x
13:34:48 <[0ne]> salut all
13:35:13 <Saizan> yrlnry: the action of a functor on morphisms is often expressed with the same symbol as the one on objects
13:35:16 <[0ne]> is there anything haskell can't do? =)
13:35:19 <yrlnry> No, the operation I'm talking about is that one that is \f\g\(a,b)(f a, g b)
13:35:33 <crystal-cola> isn't that a product in some category?
13:35:49 <mauke> [0ne]: yes
13:35:52 <int80_h> http://hpaste.org/46035/resolving_an_ambiguity
13:36:01 <yrlnry> Isn't everything a product in some category?
13:36:20 <Saizan> so,  would make sense for (***) if you're using it for types
13:36:30 <copumpkin> yrlnry: prove it!
13:36:33 <mauke> @check (==)
13:36:34 <lambdabot>   "OK, passed 500 tests."
13:36:48 * copumpkin shamelessly plugs his category theory library in agda to yrlnry 
13:37:11 <yrlnry> I've been reading about it on your blog and your tweets, but I haven't been able to figure out how to run Agda.
13:37:23 <copumpkin> oh
13:37:28 <copumpkin> must just be my tweets cause I don't have a blog :)
13:37:34 <copumpkin> cabal install agda should be sufficient
13:37:36 <copumpkin> if you have emacs
13:38:10 <crystal-cola> http://en.wikipedia.org/wiki/Product_(category_theory)
13:38:12 <yrlnry> I'm running emacs and I think I have agda installed on this machine.  
13:38:17 <crystal-cola> in this article they use <f,g> for the product
13:38:23 <yrlnry> Help me do something trivial with it.
13:38:58 <copumpkin> yrlnry: we also have an #agda that might be a more suitable place for me to help you :) but you typically just make a .agda file and write "module <filename minus the .agda> where" at the top
13:39:02 <yrlnry> Well, I M-x agda2-mode and I think it loaded a bunch of fonts.  That's a start.  :)
13:39:52 <Nereid> crystal-cola: it would also make sense to write f_1 \times_Y f_2
13:39:56 <Nereid> for f_i: Y -> X_i
13:40:41 <int80_h> Hey gang, I'm getting an error concerning an ambiguity when trying to install JSONb-1.0.2, could someone look at my hpaste about the problem?
13:40:55 <parcs> @hoogle factorial
13:40:56 <lambdabot> No results found
13:41:04 <crystal-cola> Nereid: Is that the coslice category?
13:41:11 <parcs> is factorial defined anywhere?
13:41:16 <crystal-cola> no it's not
13:41:24 <mauke> you don't get an "an error concerning an ambiguity", the code doesn't compile
13:41:30 <crystal-cola> Why is the notation \times_Y used?
13:41:32 <Nereid> crystal-cola: sure it is
13:41:33 <mauke> possibly because some exports have changed
13:41:42 <Nereid> f is the product of f_i in the category of objects under Y
13:41:49 <crystal-cola> ah thanks you
13:41:50 <jberryman> @parcs: it's defined everywhere
13:41:50 <lambdabot> Unknown command, try @list
13:41:55 <copumpkin> I thought times_Z was also used for pullback
13:42:05 <parcs> jberryman: what
13:42:08 <Nereid> hmmm
13:42:09 <Nereid> wait
13:42:13 <Nereid> yeah that too
13:42:17 <Nereid> and what I said is stupid I think
13:42:31 <tswett> Hm.  Is there a non-zero formal power series whose square is zero?
13:42:39 <Nereid> crystal-cola: ok, what I said is probably wrong. :P
13:42:41 <crystal-cola> tswett: no because power series are integral domain
13:42:51 <crystal-cola> ab = 0 implies a or b = 0
13:43:09 * tswett nods.
13:43:17 <tswett> What are its units?  I would expect it to have a lot of them.
13:43:32 <Nereid> crystal-cola: only if the underlying ring is an integral domain :p
13:43:38 <crystal-cola> a + xA is invertible when a is invertible and A is a powerseries
13:43:45 <Nereid> yes
13:43:47 * tswett nods.
13:43:54 <Nereid> that's an iff
13:44:24 <tswett> That seems rather matrix-like.  I wonder if matrices and formal power series can be thought of in terms of each other at all.
13:44:38 <Nereid> how is it rather matrix-like?
13:44:50 <crystal-cola> well it is not possible if you are using finite matrices
13:44:58 <int80_h> mauke: ghc can't tell if the code is referring to Test.JSONb.Decode.number or Attoparsec.number and I'm not sure how to fix that.
13:45:10 <mauke> file a bug?
13:45:29 <int80_h> crap
13:45:50 <crystal-cola> multiplying power series gives convolution of the coefficients
13:45:52 <Zao> int80_h: Modify the source to qualify things?
13:46:09 <tswett> Well, just the fact that the set of non-units is... an ideal, perhaps, is the word I'm looking for.  Maybe whatever property it has is not special at all.
13:46:25 <int80_h> Zao: there you go! that's it right there, I think.
13:46:26 <Nereid> tswett: the set of non-units being an ideal means you have a local ring
13:46:30 <Zao> int80_h: And then file a bug report.
13:46:43 <Nereid> and power series on a field is indeed a local ring
13:47:05 <jberryman> anyone know how frequently hackage is generating documentation? It's been several days since I uploaded a package and still no docs
13:47:22 <ezyang> There was a recent problem, but I heard it was fixed. 
13:47:25 <int80_h> what's the ghc-pkg command to hide a package?
13:47:39 <Nereid> ghc-pkg hide?
13:47:47 <Nereid> =(
13:48:19 <Zao> int80_h: Also note that the current version seems to be 1.0.4
13:49:42 <int80_h> Zao: yesod, or some dependency of yesod want 1.0.2
13:49:53 <Zao> Ah.
13:50:02 <int80_h> now, I just tried hiding attoparsec, yet I still get complaints of ambiguity
13:50:31 <mauke> hiding attoparsec won't do you much good if the thing you're trying to install uses attoparsec
13:50:57 <int80_h> mauke: I was trying to determine which package it actually wants. Then I'll know how to qualify the source
13:51:20 <Zao> What you want to do is either hide `number' when importing attoparsec and use a qualified import for it, or explicitly qualify it at the call site.
13:51:21 <Saizan> hiding packages won't do anything if you're building with cabal
13:51:36 <mauke> int80_h: probably its own
13:51:46 <Zao> Your problem is in your source, with the modules in there.
13:51:56 <jberryman> ezyang: thanks. a  quick glance seems to show docs not generated for packages in the last week or so, but I'll wait and see
13:52:18 <jberryman> ezyang: btw, always enjoy the blogs :)
13:52:20 <Zao> Where by "your" I mean the jsonb- source
13:53:07 <ezyang> jberryman: :-) Thanks. 
13:54:52 <osfameron> ghci + vim finger memory keeps leading me to ":r" in my vim session (which inserts the contents of current file at insertion point).  Gah.
13:55:29 <ezyang> hehe 
13:58:22 <Nereid> :>
14:02:39 <vicvicvic> if i have a type which has a commonly (in real life) used string representation, is it considered bad form to use that representation for Show instead of the derived version? 
14:03:08 <vicvicvic> i.e. should I stick with letting Show generate Haskelly expressions and use custom functions for other string representations
14:04:10 <roconnor> vicvicvic: lots of people sue Show to produce non haskelly expressions
14:04:40 <c_wraith> including GHC, for clever uses of "deriving Show"
14:05:10 <vicvicvic> i see!
14:12:06 * osfameron is working through the Functor->Applicative->Monad stuff in BONUS's LYAH
14:12:10 <osfameron> which is very good
14:12:46 <osfameron> though I'm always surprised at how monad tutorials don't go into the nesting
14:13:04 <osfameron> (which, to me, seems almost more important than the typeclass part of it)
14:13:14 <Nereid> nesting?
14:13:29 <Nereid> oh, the typeclass hierarchy
14:13:35 <Nereid> ?
14:13:39 <osfameron> no no
14:13:40 <osfameron> 1 sec
14:13:43 <Nereid> :<
14:14:01 <osfameron> like this example: [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch) 
14:14:15 <osfameron> makes it look like >>= is just separating functions
14:14:32 <osfameron> e.g. you might think the central function was:  (\n -> ['a', 'b'])
14:14:46 <kmc> yeah... that's a property of the lambda syntax, not of (>>=), but it's very relevant in this case
14:14:57 <Nereid> well that's the same as do { n <- [1,2]; ch <- ['a','b']; return (n,ch) }
14:15:24 <osfameron> I actually think that haskell having nice syntax for monads is one of the reasons that monads in haskell are so hard to understand ;-)
14:15:26 <mauke> do { n <- [1,2]; do { ch <- ['a','b']; return (n,ch) } }
14:15:32 <Nereid> lol
14:15:43 <bos> does anyone have any good way to quickly refer to haddocks from within emacs or vim?
14:15:51 <Nereid> mauke: doesn't matter, since >=> is supposed to be associative
14:15:54 <Nereid> :>
14:16:06 <Nereid> or
14:16:10 <mauke> what is your point
14:16:17 <Nereid> I say things they don't what
14:16:20 <Nereid> never mind
14:16:21 <Nereid> bye
14:16:22 <osfameron> mmm, LYAH does talk about how you parenthesize the expressions.
14:17:17 * hackagebot happstack-ixset 6.0.1 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/happstack-ixset-6.0.1 (JeremyShaw)
14:20:59 <stepkut> someone should submit a patch to containers that adds Data.Set.toDescList
14:21:46 <jaj> hi
14:22:25 <jaj> I was wondering, to do simple IPC, is it a good idea to serialize data using "show", send it over a socket and deserialize it on the other end using "read"?
14:22:49 <jaj> for simple data structures. or might that go wrong?
14:22:52 <mauke> that works, assuming you have some framing
14:23:06 <mauke> i.e. you know where each message ends
14:23:48 <jaj> I'll just make them end with \n
14:25:56 <jaj> mauke: thanks
14:29:46 <osfameron> if applicative's <*> had been typed :: f a -> f (a->b) -> f b ...
14:29:51 <rata_> hi
14:30:06 <osfameron> ... i.e. like Monad.  then would it also have had the similar binding effect?
14:30:20 <osfameron> i.e. descending into progressive nested lambdas?
14:30:36 <copumpkin> osfameron: you mean flipped around?
14:30:48 <osfameron> copumpkin: yeah, similar to (>>=)
14:30:48 <copumpkin> :t flip (<*>)
14:30:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
14:30:55 <kmc> osfameron, this isn't a property of the operator
14:30:57 <copumpkin> no, flip shouldn't change the behavior at all
14:31:00 <kmc> it's a property of the lambda syntax
14:31:07 <osfameron> sure
14:31:10 <aristid> :t (<**>)
14:31:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
14:31:18 <kmc> it's just the fact that \x -> ... extends as far to the right as possible
14:31:18 <osfameron> aha
14:31:19 <aristid> @src (<**>)
14:31:19 <lambdabot> (<**>) = liftA2 (flip ($))
14:31:27 <kmc> i.e. until the close of a group of parens / braces which contained the whole thing
14:31:47 <osfameron> yes.  having the lambda as the last value is convenient for prettifying the monadic syntax
14:32:43 <osfameron> so, using <**> you can get similarly "pretty" nested, but applicative behaviours?
14:33:01 <osfameron> (sorry if I'm asking dumb questions!)
14:33:09 <copumpkin> flip (<*>) and <**> are different
14:33:22 <copumpkin> (in case anyone hadn't noticed)
14:33:33 <osfameron> me! me!
14:33:42 <c_wraith> yes, effect order is opposite between them
14:33:47 <osfameron> @src (<**>)
14:33:47 <lambdabot> (<**>) = liftA2 (flip ($))
14:34:02 <osfameron> oops yes, you quoted that above
14:34:05 <copumpkin> <*> is conceivably liftA2 ($)
14:34:17 <c_wraith> Just like (<*) isn't the same as as flip (*>)
14:34:25 <copumpkin> so flip (liftA2 ($)) /= liftA2 (flip ($))
14:34:32 <osfameron> ah, I haven't got to (*>) and co yet
14:34:42 <byorgey> osfameron: the interesting thing about >>= is that it *binds* names that can be used later in the computation
14:34:51 <byorgey> osfameron: this is why having the function second makes it "prettier"
14:34:56 <byorgey> but Applicative does not do this
14:35:13 <hpc> :t flip
14:35:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:35:14 <osfameron> byorgey: yes.  I was wondering if Applicative could have done that too
14:35:30 <osfameron> having noticed the deliberately different order of the parameters
14:35:46 <copumpkin> applicative's order is more convenient for other things
14:35:49 <byorgey> osfameron: arguably Applicative is much prettier with the order it has
14:36:04 <byorgey> osfameron: because it allows you to write Applicative expressions as if you were just applying functions to arguments
14:36:20 <hpc> f <$> x <*> y <*> z
14:36:27 <byorgey> > (+) <$> [1,2,3] <*> [6,10,19]
14:36:27 <lambdabot>   [7,11,20,8,12,21,9,13,22]
14:36:36 <osfameron> ok
14:37:10 <hpc> > [x + y | x <- [1,2,3], y <- [6,10,19]]
14:37:11 <lambdabot>   [7,11,20,8,12,21,9,13,22]
14:37:45 <TheZimm> thats so cool
14:37:50 <TheZimm> ^^^ why i love haskell
14:38:01 <kwantam> yes
14:38:10 <osfameron> so... I guess what I'm wondering is, is there something special about (a -> m b) as opposed to f (a -> b) that makes it sensible for functions like the former to be used in a typeclass that binds variables for later, and the latter not.
14:38:11 <byorgey> TheZimm: to which of the many cool things above are you referring? =)
14:38:14 <kwantam> applicative makes my nose bleed sometimes
14:38:20 <arnihermann> does anyone know if John MacFarlane, author of pandoc happens to hang out on #haskell?
14:38:21 <TheZimm> byorgey exactly
14:38:31 <TheZimm> my only issue is theres no blatant calculus
14:38:37 <hpc> osfameron: (a -> m b) has the argument on the outside
14:38:40 <TheZimm> but how do you teach a computer calculus? xD
14:38:56 <byorgey> TheZimm: the same way you teach a computer anything.
14:39:01 <c_wraith> @hackage ad
14:39:01 <TheZimm> :P
14:39:01 <lambdabot> http://hackage.haskell.org/package/ad
14:39:06 <hpc> f (a -> b) is a function wrapped in a thing, while (a -> m b) is a function that outputs a thing
14:39:09 <copumpkin> > let (a, b, c) = (5 + c, 2, 1 - b) in a
14:39:10 <lambdabot>   4
14:39:14 <copumpkin> that is why haskell is cool
14:39:15 <c_wraith> TheZimm: check out the ad package :)
14:39:21 <copumpkin> :t fix (ap sequence)
14:39:22 <lambdabot> forall a. [[a] -> a] -> [a]
14:39:27 <TheZimm> HOLY FUCK c_wraith omg
14:39:47 <TheZimm> whats "AD" stand for?
14:39:53 <c_wraith> automatic differentiation
14:39:53 <copumpkin> automatic differentiations
14:39:54 <copumpkin> -
14:39:55 <TheZimm> automatic differentiation
14:39:55 <copumpkin> ss
14:39:55 <TheZimm> :P
14:39:57 <copumpkin> gah
14:39:58 <TheZimm> heh
14:40:03 <TheZimm> copumpkin omg my hero
14:40:04 <TheZimm> :P
14:40:09 <copumpkin> ohai
14:40:30 <hpc> copumpkin: systems of equations ftw!
14:40:45 <osfameron> copumpkin: that's not so much destructuring bind as showing off ;-)
14:40:46 <mauke> > deriv sin x
14:40:46 <lambdabot>   1 * cos x
14:40:56 <hpc> > let (x + 5, y - 2) = (y + 3, 2*x) in y
14:40:57 <lambdabot>   <no location info>: Parse error in pattern
14:40:59 <hpc> :(
14:41:03 <mauke> > deriv (^ 2) x
14:41:04 <lambdabot>   1 * x + x * 1
14:41:04 <TheZimm> wait wait wait
14:41:10 <mauke> > deriv (^ 2) 3
14:41:11 <lambdabot>   6
14:41:31 <hpc> > deriv f
14:41:32 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
14:41:32 <lambdabot>    arising from a use of `...
14:41:37 <hpc> > deriv f x
14:41:38 <lambdabot>   No instance for (SimpleReflect.FromExpr (Data.Number.Dif.Dif b))
14:41:38 <lambdabot>    arising...
14:41:40 <hpc> :(
14:41:47 <luite> TheZimm: it doesn't give you an expression for the derivative of some function though. and the antiderivative is much more difficult of course, I don't think there's an implementation of the Risch algorithm in haskell
14:41:48 <hpc> i was hoping for f'x
14:42:02 <ion> osfameron: <* and *> simply do the respective effects of of each parameter from left to right, but have the result value of the one the arrow points to. putStrLn "before" *> readFile "foo" <* putStrLn "after" prints "before", reads the file and prints "after", resulting in the contents of the file.
14:42:22 <TheZimm> luite ya thats what i was seeing, no actual like 3x^2
14:42:25 <TheZimm> of w.e
14:42:44 <TheZimm> and yes antiderivatives, much much harder, youd need an initial condition and whatnot
14:42:44 <copumpkin> > deriv (^3) x
14:42:46 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
14:42:54 <ion> osfameron: In Parsec, char '"' *> many (notChar '"') <* char '"' is a parser that matches a "-delimited string and returns the string without the surrounding "".
14:43:01 <ion> s/returns/results in/
14:43:01 <copumpkin> looks like 3x^2 to me
14:43:21 <luite> TheZimm: nah I just meant indefinite integration
14:44:07 <kwantam> a really good symbolic math package would be incredible.
14:44:11 <Nereid> @type deriv
14:44:12 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
14:44:12 <kwantam> I'd give up on mathematica completely
14:44:28 <Nereid> what's a Dif? D:
14:44:40 <mauke> a differentiable value
14:44:54 <TheZimm> copumpkin oh jeeze, wow thats nice
14:44:56 <Nereid> I guessed that much
14:45:07 <mauke> it's got epsilons and shit
14:45:08 <osfameron> ion: so what are the *> and <* doing?
14:45:27 <TheZimm> luite ah ya ok then
14:45:33 <TheZimm> still, difficult no matter what
14:45:36 <ion> @src (<*)
14:45:36 <lambdabot> (<*) = liftA2 const
14:45:37 <ion> @src (*>)
14:45:38 <lambdabot> (*>) = liftA2 (const id)
14:45:45 <TheZimm> same base rules
14:46:01 <luite> copumpkin: ah right, good point
14:46:20 <luite> now with some simplification it would be useful, is there a package that does that?
14:46:36 <TheZimm> heh ya its weird to look at :P
14:46:41 <osfameron> ion: i.e. it's throwing away one argument or the other?
14:46:59 <ion> > (\f' g' -> f') <$> [0,1,2] <*> [3,4,5]
14:47:00 <lambdabot>   [0,0,0,1,1,1,2,2,2]
14:47:03 <ion> > (\f' g' -> g') <$> [0,1,2] <*> [3,4,5]
14:47:04 <lambdabot>   [3,4,5,3,4,5,3,4,5]
14:47:11 <ion> > [0,1,2] <* [3,4,5]
14:47:12 <lambdabot>   [0,0,0,1,1,1,2,2,2]
14:47:15 <ion> > [0,1,2] *> [3,4,5]
14:47:15 <lambdabot>   [3,4,5,3,4,5,3,4,5]
14:47:17 <ion> Does this help?
14:48:06 <TheZimm> ion heh thats a cool operator or w.e
14:48:16 <TheZimm> theres so much to haskell
14:48:24 <danharaj> That's the applicative instance corresponding to the list monad right?
14:48:32 <ion> yeah
14:48:36 <osfameron> ion: er, a little.  I'm just following that through now
14:48:36 <danharaj> and the other applicative instance corresponds to zip?
14:48:46 <danharaj> ('other' instance)
14:49:17 <ion> > (,) <$> [0,1,2] <*> [3,4,5]
14:49:17 <lambdabot>   [(0,3),(0,4),(0,5),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
14:49:51 <copumpkin> danharaj: yep
14:49:58 <ion> With <*, all that happened, but only the fsts are in the result value. With *>, all that happened, but only the snds are in it.
14:50:02 <danharaj> It is a damn shame we can't have both.
14:50:02 <TheZimm> also, thing i like about haskell, you have to actually be smart to be able to use it ;) (hence why im not very good) :P
14:50:07 <danharaj> Because the zip instance is useful too.
14:50:08 <copumpkin> danharaj: we do!
14:50:16 * TheZimm is done with his rant and goes into the shadows
14:50:17 <danharaj> copumpkin: saywhat
14:50:18 <sorabji5252> quick question if anyone wants to help...i'm just getting started in haskell, trying to set up the haskell platform on my ubuntu machine...when i try to run configure, it says i need OpenGL C library...where is this?
14:50:34 <osfameron> how is (const id) equivalent to flip const ?
14:50:37 <monochrom> if I answer, will you read?
14:50:38 <copumpkin> :t getZipList . Data.Traversable.traverse ZipList
14:50:39 <lambdabot> forall b (t :: * -> *). (Data.Traversable.Traversable t) => t [b] -> [t b]
14:50:48 <danharaj> oh, you wrap.
14:50:51 <copumpkin> :t getZipList . Data.Traversable.traverse ZipList $ [[1,2,3],[4,5,6],[7,8,9]]
14:50:52 <lambdabot> forall b. (Num b) => [[b]]
14:50:56 <copumpkin> > getZipList . Data.Traversable.traverse ZipList $ [[1,2,3],[4,5,6],[7,8,9]]
14:50:58 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
14:50:59 <ion> (,) <$> readFile "foo" <*> readFile "bar": both files are read ("foo" first, "bar" second), and the result value is (contentsOfFoo, contentsOfBar)
14:51:27 <ion> readFile "foo" <* readFile "bar": both files are read ("foo" first, "bar" second), and the result value is the contents of "foo"
14:51:32 <danharaj> sorabji5252: I don't know how ubuntu works but there should be an OpenGL package.
14:51:43 <monochrom> sorabji5252: see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml  it is now endorsed procedure as seen on the haskell platform website
14:52:05 <danharaj> ^ listen to monochrom
14:52:19 <afarmer> sorabji5252: sudo apt-get install freeglut3-dev
14:52:21 <afarmer> I believe
14:52:35 <afarmer> or what monochrom said
14:53:05 <ion> > ala ZipList foldMap [[1,2,3],[4,5,6],[7,8,9]]
14:53:06 <lambdabot>   Not in scope: `foldMap'
14:53:28 <copumpkin> ion: oh I forgot that was in lambdabot
14:53:36 <sorabji5252> thank you all!
14:53:55 <copumpkin> > ala ZipList Data.Traversable.traverse [[1,2,3],[4,5,6],[7,8,9]]
14:53:56 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
14:54:28 <kwantam> well that's an interesting way to spell matrix transpose
14:54:32 <sipa> :t ala
14:54:34 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
14:55:27 <deonjo> hello
14:55:44 <deonjo> wow try haskell is cool
14:56:07 <Nereid> >src ala
14:56:09 <Nereid> @src ala
14:56:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:56:14 <deonjo> the delete button actually works unlike try ruby
14:56:23 <monochrom> haha
14:56:24 <osfameron> ion: ok, I can follow through the definitions of (<*) and (*>) for the List instance to see why those are the results
14:56:33 <osfameron> I don't get the purpose of it though
14:56:49 <osfameron> or how it relates to the Parsec instance
14:57:11 <ion> Sequencing multiple things (e.g. IO actions or parsers) so that the result value of a specific one of them is used.
14:57:28 <c_wraith> it's common to see things like whitespace *> foo <* whitespace
14:57:49 <monochrom> do { x <- foo; spaces; return x }  is royally annoying
14:57:56 <monochrom> s/annoying/tedious/
14:58:26 <Nereid> both
14:58:32 <osfameron> ok.  my intuition on looking at the parsec code was that it was throwing away one or other side
14:58:37 <osfameron> the List code though doesn't really do that...
14:58:47 <ion> Throwing out the result value, not the effect.
14:58:53 <monochrom> and although *> is technically an Applicative thing, I have only used it for Monad things, so I just pretend it's a shorthand for some do patterns
14:59:05 <ion> Just like in the List code the other list caused the for each effect, but the result value (the number) was thrown out.
14:59:41 <osfameron> do applicatives have effects, as well as result values then?
15:00:08 <kmc> yes
15:00:23 <c_wraith> IO is an applicative
15:00:25 <kmc> in the same sense as monadic values
15:00:27 <kmc> for starters, every monad is an applicative
15:00:33 <danharaj> not every applicative is a monad.
15:00:42 <c_wraith> :t readFile
15:00:43 <lambdabot> FilePath -> IO String
15:00:53 <Nereid> what's an example of a useful applicative that's not a monad?
15:00:56 <c_wraith> :t length <$> readFile "foo"
15:00:57 <lambdabot> IO Int
15:01:03 <kmc> though it's more accurate to say that applicative values "describe" effects
15:01:08 <kmc> the same way monadic values describe effects
15:01:12 <kmc> or at least some of them do
15:01:12 <c_wraith> Nereid: Zip
15:01:16 <Nereid> mmm right.
15:01:24 <copumpkin> note that Zip on sized Vectors is both an applicative and a monad
15:01:37 <Nereid> :o?
15:01:44 <c_wraith> right.  Zip on unsized lists :)
15:02:13 <danharaj> do you guys mean fixed length lists when you say sized vectors?
15:02:50 <c_wraith> In this case, yes
15:02:59 <copumpkin> yeah
15:03:08 <c_wraith> particularly, something with the size in the type
15:06:05 <osfameron> ah, an example I understand better would be:
15:06:13 <osfameron> > Just 1 *> Just 2 <* Just 3
15:06:14 <lambdabot>   Just 2
15:06:22 <osfameron> > Nothing *> Just 2 <* Just 3
15:06:22 <lambdabot>   Nothing
15:06:52 <c_wraith> don't forget the other fun one
15:07:21 <c_wraith> > Just "angles" *> Just 2 <* Nothing
15:07:22 <lambdabot>   Nothing
15:08:32 <osfameron> yeah, presumably the whole chain has to match (in the case of Nothing)
15:08:42 <osfameron> or did you mean something else?
15:09:01 <c_wraith> Yeah, that's what I meant.
15:09:06 <ddarius> When I grow up, I want to be Gary Oldman.
15:09:16 <c_wraith> Though I did want to point out the types don't have to be the same
15:09:30 <osfameron> ah yes ;-)
15:10:20 <osfameron> which makes sense, thinking of the type of const
15:10:34 <c_wraith> ddarius: that's amazingly similar to the first line of the first song of the album I'm listening to.
15:10:53 <osfameron> c_wraith: Fever Ray?
15:11:34 <c_wraith> osfameron: not even close...  Michelle Shocked :)
15:11:57 <osfameron> hehe, worth a guess
15:12:07 <osfameron> turns out that's the 2nd song on the album anyway
15:12:54 <osfameron> but yes, "an old woman" does sound more like Gary Oldman than "a forester and run through the grass on high heels"
15:14:28 * osfameron goes to bed to read about Reader monad on kindle
15:20:57 * ddarius wonders how long he can go without sleeping.
15:38:02 <mjo> Anyone want to ruin the suspense and tell me how to run more than one test at a time in QuickCheck 2.x?
15:38:44 <danharaj> http://hpaste.org/46040/herp
15:38:46 <danharaj> halp
15:38:46 <monochrom> perhaps forkIO or par them
15:39:11 <danharaj> I have a function that returns an associated type, but GHC is making the type too general when I try to use it.
15:39:34 <mjo> I don't mean run them in parallel, I just want the equivalent of runTests in 1.x.
15:39:34 <danharaj> er, the paste has a typo
15:39:37 <Saizan> basically, fromFile can't be used
15:39:47 <danharaj> Saizan: How do I fix that?
15:40:05 <monochrom> wait, fromFile "sim.cfg" :: IO (Param System) ?
15:40:05 <Saizan> you could make Param a data family
15:40:13 <danharaj> monochrom: yeah that's the typo
15:40:28 <Saizan> or add a phantom 'a' argument to fromFile
15:40:50 <danharaj> Saizan: Hmm. I think the data family approach will be cleaner?
15:41:00 <Liskni_si> danharaj: the problem is that type families, as opposed to data families, aren't injective
15:41:32 <danharaj> Liskni_si: Ok. So right now I'm using an associated type family, where I want an associated data family, so GHC can infer a from Param a?
15:41:58 <Liskni_si> danharaj: which means that if you call fromParam on a value of type, say, String, there's no way to infer the 'a' in Param a
15:42:21 <Saizan> fromParam would be fine
15:42:21 <Liskni_si> danharaj: yes, that's it
15:42:32 <Saizan> because it can get 'a' from the result type
15:42:45 <Liskni_si> oh, right
15:43:25 <danharaj> so... how accepted are type/data families anyway? Am I being excessive by using them?
15:43:49 <Twey> Pretty accepted
15:44:18 <mauke> stuck in the closet
15:44:54 <shachaf> The black sheep of the type family.
15:46:08 <int80_h> has completely removing all haskell packages been documented anywhere, if so could you give me the url?
15:47:09 <hpc> int80_h: i think you rm -r the relevant .ghc and .cabal directories
15:48:06 <int80_h> hpc: what about the ghc package database?
15:48:43 <alpounet> doesn't ghc keep it in the .ghc/ directory ?
15:49:03 <int80_h> gotcha
15:50:45 <joe6> any good papers or articles on structural recursion? something more basic than these: http://personal.cis.strath.ac.uk/~raa/posts/2011-04-22-structural-recursion.html http://blog.ezyang.com/2010/06/well-founded-recursion-in-agda/
15:51:06 <joe6> and from a dependent types perspective, if possible..
15:52:03 <mauke> anyone familiar with Koen Claessen's "Parallel Parsing Processes" paper?
15:52:24 <mauke> it says here that "look" can be used to implement longest :: P s a -> P s a, and I just don't see how that would work
15:52:37 <danharaj> Ok I think I get it.
15:52:44 <danharaj> Is a data family just an open GADT?
15:54:57 <koninkje> Not quite
15:55:36 <koninkje> E.g., data Foo :: * -> * where A :: Foo () ; B :: Foo ()
15:55:58 <koninkje> GADTs don't have to enforce injectivity
15:56:23 <danharaj> How does your example break injectivity?
15:56:35 <danharaj> oh wait yeah derp
15:56:42 <koninkje> Given Foo () you can't say which constructor made it
15:57:00 <danharaj> So open GADT's that are injective.
15:57:39 <koninkje> possibly. What analogy are you hoping to maintain once you've made things open and non-injective?
15:57:55 <danharaj> Well none.
15:58:02 <danharaj> I just try to reduce things to things I already know.
15:58:34 <koninkje> Data families are kinda like universes, if you're familiar with those
15:58:36 <mauke> @quote e.robots
15:58:36 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
15:58:44 <danharaj> I am familiar with a particular universe.
15:58:48 <danharaj> It is a very complicated place.
15:59:14 <koninkje> er, type universes :)
15:59:35 <danharaj> nope.
15:59:37 <danharaj> not a clue.
16:00:41 <koninkje> Dependent type shenanigans
16:01:02 <koninkje> I talk a little about them on reddit, but it's probably not informative: http://www.reddit.com/r/dependent_types/comments/grzfc/what_is_the_most_intuitive_dependent_type_theory/c1pxqse
16:01:13 <danharaj> hrm...
16:01:18 <danharaj> well let's see.
16:01:27 <danharaj> a data family is an injective open map of types to types
16:01:37 <danharaj> and a GADT that is injective is a closed map of types to types.
16:01:43 <koninkje> One of the Epigram papers uses them as an example, which I found most helpful for understanding them; though I don't recall which paper/tutorial it was :(
16:02:11 <danharaj> I think I have an approximate truth.
16:02:40 <koninkje> But GADTs aren't about mapping types, they're just a generalization of ADTs
16:03:07 <joe6> does anyone know where I can find: David Turner Strong Functional Programming
16:03:44 <koninkje> type families are essentially open type-level functions whereas data families are injective open type-level functions
16:04:46 <koninkje> joe6: is that different from "Elementary Strong Functional Programming"?
16:05:09 <danharaj> koninkje: I'll just think about type/data families harder
16:05:58 <koninkje> joe6: e.g., http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.106.8766
16:06:13 <joe6> koninkje, thanks a lot.
16:07:59 <vicvicvic> trying to create a custom Read instance for a type, but I can't get it to handle symbols longer than 1 char, what's wrong with this: http://hpaste.org/46041/readsprec
16:09:04 <joe6> koninkje, are you aware of any other material that can explain structural recursion for a layman?
16:09:14 <joe6> i mean not a ph.d programmer.
16:09:30 <ddarius> A string on my classical acoustic broke by itself...
16:09:44 <danharaj> ddarius: ghosts and wizards. also how old was the string o.O
16:09:56 <ddarius> Structural recursion can be explained to children.
16:10:11 <ddarius> See HtDP for a constructive example.
16:10:35 <danharaj> Children can do a lot of impressive things.
16:10:53 <danharaj> I had a logic professor who did research in the 80's about teaching kids formal logic.
16:11:07 <danharaj> And she managed to get kids to be able to understand and prove completeness theorems about basic logics.
16:13:37 <c_wraith> kids are way smarter than school lets them be, in general
16:14:06 <ddarius> Formal logic is also way simpler than it puffs itself up to be, in general
16:14:13 <danharaj> true and true.
16:14:26 <danharaj> of course people are all different, and smarter in different ways, and want to be smarter about different things etc.
16:14:39 <danharaj> Education is a Hard Thing
16:14:47 <joe6> ddarius, what is HtDP?
16:15:04 <danharaj> joe6: I assume this: http://www.htdp.org/
16:16:55 <monochrom> recursion is difficult for control freaks only
16:17:46 <Tyr42> I very much agree that children are a lot smarter than shcools let them be
16:18:07 <koninkje> joe6: not off-hand. I just googled for what you were seeking
16:19:01 <ddarius> Tyr42: Schools are hardly the only such limiting entities.
16:19:12 <ion> vicvicvic: It might be nicer to use Parsec.
16:19:58 <vicvicvic> ion: yeah, looking into that now.. havent worked much with parsers in the past so im kinda in the dark here :)
16:20:48 <ddarius> On the other hand, kids are a lot "stupider" in certain ways than I think most people realize.
16:20:57 <Tyr42> that too
16:21:49 <Tyr42> but if I learned math at the rate the school was teaching it, I would know a tiny amount to what I know now 
16:22:06 <ddarius> Read Mark Twain instead.
16:22:12 <Tyr42> And that's not to mention programming
16:22:44 <ddarius> Most schools don't teach programming at all, so that's easy to support.
16:22:57 <Tyr42> I actually have a collection of Mark Twain's works sitting here somewhere, but it's been displaced on my to-read list by my AP Physics textbook
16:23:25 <monochrom> > reads "1878:bih_30" :: [(Int,String)]
16:23:25 <ddarius> Mark Twain deserves every bit of praise he receives.
16:23:26 <lambdabot>   [(1878,":bih_30")]
16:23:29 <Tyr42> Well, I helped a lot of people with codeing in gr10
16:23:30 <Tyr42> and
16:23:39 <Tyr42> a lot of them really don't get it
16:23:43 <Tyr42> a lot
16:23:46 <Tyr42> it was scary
16:24:13 <Tyr42> I had minimal experience before that class
16:25:13 <Frederik> Hi. I'm trying to make a simple website using happstack and heist. I don't fully get it: in a ServerPart Response, I'm calling templateServe. Is there any way to pass information from that ServerPart to my Splices?
16:26:44 * ddarius should probably implement light sources before he implements global illumination.
16:27:16 <ion> vicvicvic: An example parser http://hpaste.org/paste/46041/readsprec_annotation#p46042
16:28:20 <vicvicvic> ion: thanks!
16:29:04 <siracusa> Frederik: If you don't get an answer here, you could try in #happs, which is better for Happstack related questions.
16:32:58 <c_wraith> Frederik: It's almost automatic
16:33:18 <ion> vicvicvic: Are you familiar with the applicative operators?
16:33:55 <vicvicvic> uhm ive read the chapter in "learning you a haskell" but i wouldnt say im comfortable around them :0
16:34:35 <c_wraith> Frederik: splices in heist are of type TemplateMonad m Template
16:34:57 <c_wraith> Frederik: that m is going to be ServerPart, in your case.
16:35:24 <ion> SFS <$> parser <*> anotherParser <*> thirdParser simply returns a parser that tries to run the three parsers in sequence, and if successful, results in the result value of each applied as parameters to SFS.
16:35:31 <c_wraith> Frederik: Since TemplateMonad is an instance of MonadTrans, you can use lift to get values from ServerPart into your splice
16:36:19 <ion> parser <* anotherParser returns a parser that tries to run the two parsers from left to right, and if successful, results in the result value of the one on the left. *> results in the result value of the one on the right.
16:37:36 <vicvicvic> riight... im with you 
16:40:02 <koninkje> N.B.,  (f <$> x) is the same thing as (pure f <*> x), though the (<$>) version may be a little faster in addition to its being less verbose
16:40:22 <hpc> <$> is fmap, which is the most direct definition
16:40:37 <ion> To make optnummer handle Lopnummer as well, use <|> to parse alternatives; something like string "bih_" *> (Bihangsnummer <$> real) <|> string "blah_" *> (Lopnummer <$> real)
16:40:41 <hpc> pure and <*> are only guaranteed to be the same as <$> through applicative laws
16:41:07 <Frederik> c_wraith: with type TemplateMonad (ServerPart Response) Template, the compiler gives this error: The first argument of `TemplateMonad' should have kind `* -> *', but `ServerPart Response' has kind `*'
16:41:24 <koninkje> hpc: Yes. (Though actually, pointed functor laws are sufficient)
16:41:42 <vicvicvic> ion: i noticed you changed my Int -> Integer too  would you say that's wiser? i know the difference between them and that my values will never really be out of bounds
16:41:43 <c_wraith> Frederik: right, the type is TemplateMonad ServerPart Template.  TemplateMonad is a higher-kinded type constructor
16:42:23 <Frederik> c_wraith: But then it says: Type synonym `ServerPart' should have 1 argument, but has been given none
16:42:51 <ion> I tend to use Integers unless i specifically need a bounded one and in that case, one might want something like Int32 or Word16.
16:42:53 <c_wraith> Frederik: eww.  Now you're getting into HappStack details I don't know. :)
16:43:22 <c_wraith> Frederik: that error message means "ServerPart" is a type alias, and GHC isn't letting you use it unapplied.
16:43:46 <Kerris> "Improve EclipseFP" got into GSOC =D
16:44:03 <mightybyte> Frederik: Try "TemplateMonad (ServerPartT IO) Template"
16:44:15 <vicvicvic> i see, thanks a lot for the help everyone! seems to be a great community around this language :)
16:46:27 <tolkad> It's really elegant how the base package on hackage has compiler-specific code
16:47:00 <c_wraith> base is a package that I'd generally expect to have compiler-specific code.
16:47:29 <mauke> @quote tolkad
16:47:29 <lambdabot> tolkad says: haskell isn't even turing complete without infinite memory
16:47:31 <Frederik> mightybyte: thanks, that seems to work
16:47:34 <monochrom> IO has to be implemented compiler-specifically, I'm sorry to say
16:47:35 <mauke> @quote tolkad
16:47:35 <lambdabot> tolkad says: Haskell is a cool language, but sometimes I wish it was more type safe, like PHP
16:47:48 <hpc> @tolkad
16:47:48 <lambdabot> Unknown command, try @list
16:47:55 <hpc> can we have @tolkad?
16:48:05 <c_wraith> @xahlee
16:48:05 <lambdabot> Unknown command, try @list
16:48:11 <monochrom> I second adding @tolkad
16:48:12 <hpc> @protontorpedo
16:48:12 <lambdabot> so with 100s of users adn different daabases haskell does fine?
16:48:29 <shachaf> @vixen so with 100s of users adn different daabases haskell does fine?
16:48:30 <lambdabot> Ooh, functional programmers are so hot!
16:48:41 <shachaf> @vixen Yes, but stop changing the subject.
16:48:42 <lambdabot> stop what?
16:48:59 <hpc> @vixen you remind me of the babe
16:48:59 <lambdabot> Are we just wasting time?
16:49:12 <hpc> poo, was hoping that would work
16:49:27 <c_wraith> no way it'd work for the next line anyway :)
16:49:32 <c_wraith> @vixen the babe with the power
16:49:32 <lambdabot> f
16:49:34 <monochrom> yeah, you should say "you are the babe"
16:49:49 <c_wraith> That's...  less of a response than I'm used to from @vixen
16:50:15 <ion> ti030731 < lambdabot> tolkad says: haskell isn't even turing complete without infinite memory
16:50:18 <ion> Hahaha
16:50:33 <ion> @quote
16:50:33 <lambdabot> Heffalump says: I need to teach my girlfriend temporal logic. she seems to have problems with the "until" operator.
16:50:37 <monochrom> what is ti030731?
16:50:47 <shachaf> A timestamp?
16:50:53 <ion> Just a timestamp, yeah.
16:51:06 <hpc> @quote troll
16:51:06 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
16:51:18 <hpc> hahaha
16:51:38 <Frederik> thanks c_wraith and mightybyte, I think I get it :)
16:51:46 <ion> (With the (incidentally localized) name of the day as a workaround for the Irssi issue where one cant tell which day the log timestamps are from when using /lastlog.)
16:52:32 <mauke> timestamp_format = %d/%H:%M
16:53:04 <ion> Mine: timestamp_format = %a%H%M%S
16:55:14 <tolkad> lol I didn't actually mean what I said. what I meant was, how it has compiler specific code _for every compiler_
16:55:37 <Tyr42> @quote troll
16:55:37 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
16:59:24 * monochrom has discovered a neat trick... http://www.amazon.com/The-Secrets-Of-Java-Experts/dp/1593272839/
16:59:25 <sm> what's the recommended way to convert a string to an Ascii ? It is some kind of bytestring
17:00:00 <shachaf> If you want to convert a String to ByteString, that's pack.
17:00:15 <koninkje> monochrom: cute.
17:00:20 <monochrom> Data.ByteString[.Lazy].Char8.pack
17:00:36 <copumpkin> sm: by converting to ascii, you mean truncating characters at 255, right?
17:00:40 <sm> I can't find the right one to use. simpleHttp is confusing
17:00:42 <sm> (me)
17:00:43 <copumpkin> not sure I'd call that convert :P
17:00:54 <monochrom> oh simpleHttp is too simple
17:01:12 * sm is looking at http://hackage.haskell.org/packages/archive/http-enumerator/0.5.1/doc/html/Network-HTTP-Enumerator.html#v:simpleHttp 
17:01:33 <sm> I think it takes one kind of BS and returns another
17:01:43 <illissius> danharaj: do you grok type families?
17:01:48 <monochrom> oops, nevermind, I meant "HTTP"'s simpleHttp is too simple, I don't know about http-enumerator
17:01:52 <sm> but surely there's mkAscii round here somewhere..
17:02:02 <hpc> sm: if i wanted that kind of BS i would use perl ;)
17:02:26 <sm> yees.. it takes a strict one and returns a lazy one
17:02:31 <monochrom> eh? type Ascii = ByteString (the eager one)
17:02:37 <juhp> monochrom: heh (java)
17:02:47 <juhp> sm: or this maybe http://hackage.haskell.org/packages/archive/ascii/0.0.2.1/doc/html/Data-Ascii.html
17:02:47 <b52> good evening
17:03:02 <monochrom> it's ok to use pack for that purpose
17:03:26 <hpc> i always thought it was clever to implement lazy BS in terms of strict
17:03:52 <monochrom> simpleHttp (Data.ByteString.Char8.pack "http://www.amazon.com/The-Secrets-Of-Python-Sex-Maniacs/dp/1593272839/")
17:03:56 <sm> juhp: thanks! I hoped the simpleHttp haddock would lead me there, but instead it pointed to a dead end in http://hackage.haskell.org/packages/archive/http-types/0.6.1/doc/html/Network-HTTP-Types.html#t:Ascii
17:04:08 <hpc> has BONUS been online lately?
17:04:37 <hpc> er, -> -blah
17:04:46 <b52> :D
17:04:55 <b52> im waiting for his book!
17:05:23 <monochrom> eh? I'm pretty sure http-enumerator's Ascii is not ascii's Ascii
17:05:25 <hpc> same; i wrote the first amazon review a while back
17:05:45 <ddarius> Books move pretty slowly so you'll be waiting a while.
17:05:51 <hpc> ah, k
17:05:54 <b52> did you receive your copy yet hpc ?
17:06:09 <hpc> yeah, now that i actually look at the date, it's only been a week
17:06:35 <b52> wondering how long it takes to ship to germany .. :D
17:07:56 <derdon> b52: in Germany, you red it online :P
17:08:03 <derdon> *read
17:08:07 <b52> i did
17:08:12 <b52> up to chapter 5 or 6
17:08:18 <derdon> and then ?
17:08:19 <b52> then i switched to rwh
17:08:21 <b52> :D
17:08:21 <derdon> aha
17:08:40 <b52> but i wanna read the rest and i prefer books over lcd media ,)
17:08:53 <derdon> yeah. I understand that
17:09:59 <fmapE> in classic FRP formulations, is there an alternative for making a behavior based on external input besides unsafePerformIO/unsafeInterleaveIO?
17:10:36 <sm> juhp: ah. It led me there because it's using that Ascii, not the one from the ascii package
17:27:14 <ddarius> Nominee for Best Paper Title for 2008 is: "Calculation of the Lifetimes of Thin Stripper Targets Under Bombardment of Intense Pulsed Ions."
17:27:53 <hpc> hahaha
17:30:03 <monochrom> ion would be proud
17:31:59 <ion> Im intense but not that pulsed.
17:33:47 <ion> or was it the other way around
17:34:28 <hpc> ion: nor do you have an effect on the lifetime of thin stripper targets?
17:37:33 <ion> The jury didnt make a verdict yet.
17:41:22 <hpc> @quote webscale
17:41:23 <lambdabot> No quotes match. Maybe you made a typo?
17:41:26 <hpc> aw...
17:43:03 <ion> @quote
17:43:04 <lambdabot> jjuggle says: I was riding around town and this cop on patrol on a bike rode up next to me and said, "There's always a show off." I offered to teach him to ride and help set up a unicycle patrol
17:43:04 <lambdabot> squad, but he declined.
18:34:27 <gwern> ah, the GSOC accceptances are out
18:35:19 <gwern> pretty reasonable picks
18:35:36 <gwern> although I wonder if simplified opengl bindings or switching text to utf8 are worthwhile
18:35:44 <Kerris> I look forward to the improved EclipseFP :V
18:36:08 <gwern> yeah, wasn't that a GSOC already...
18:36:15 <kmc> utf8 could be a win or a lose depending on the text contents
18:36:40 <kmc> clearly we should have modules for {lazy, strict}  {utf8, utf16, utf32}
18:36:46 <kmc> i predict my approach will scale without bound
18:36:50 * gwern is looking at http://www.google-melange.com/gsoc/projects/list/google/gsoc2011
18:36:53 <Kerris> haha
18:37:03 <gwern> kmc: well, there are only so many encodings...
18:37:12 <gwern> so your approach is O(1)!
18:37:47 <kmc> $ iconv -l  | wc -l
18:37:47 <kmc> 1168
18:38:00 <kmc> bear in mind that it lists 4-8 of them on a single line
18:38:32 <shachaf> $ iconv -l | wc -w
18:38:34 <shachaf> 1168
18:38:54 <kmc> oh, it's doing some isatty() magic
18:38:57 <kmc> damn you iconv
18:39:16 <parcs> ugh, javascript. slow javascript
18:44:52 <parcs> not even google creates gracefully degrading web pages anymore
18:47:37 <sm> where can I see what exceptions readFile could raise ?
18:47:43 <shachaf> parcs: JavaScript is slow?
18:47:57 <parcs> shachaf: no, that particular javascript is slow
18:48:11 <geheimdienst> shachaf: i think he means the google melange page linked earlier. and it was slow for me as well
18:48:13 <shachaf> Oh, the SoC thing.
18:48:23 <shachaf> Yes, that's unreasonably slow, for whatever reason.
18:48:40 <kmc> sm, possibly the Haskell Report, i'm not sure actually
18:48:52 <kmc> readFile does lazy IO and lazy IO doesn't handle errors well
18:49:02 <kmc> the exception occurs not on execution of readFile but later on some unrelated pure evaluation
18:50:15 <sm> kmc: thanks. In ghci readFile "slkdjf" seems to give a regular Exception, not an IO Exception as I'd have guessed. Or I might be reading it wrong
18:50:15 <monochrom> wait, no exception occurs, you just get a terminated string
18:50:47 <kmc> the Control.Exception system of extensible exceptions supercedes the Haskell report's IOError mechanism
18:51:14 <sm> this is a Control.Exception.Extensible exception, right: *** Exception: slkdjf: openFile: does not exist (No such file or directory)
18:51:35 <kmc> they're all Control.Exception exceptions; the System.IO.Error API is just a compatibility wrapper for that code
18:51:45 <sm> ah right
18:51:56 <kmc> IOException is one of the many exception types
18:53:27 * sm is trying to untangle the wretched snarl that is rss2irc's error handling
18:54:11 <monochrom> readFile refers to getContents refers to hGetContents. here is what that says: "Any I/O errors encountered while a handle is semi-closed are simply discarded."
18:55:30 <sm> yes, I saw that, but..
18:55:52 <sm> well, the source is right there isn't it
18:57:56 <sm> I'll dig more in next session - thanks
18:57:57 <danharaj> So I'm trying to embed shader interfaces in Haskell so I can abstract at least some of the work on the haskell-side of things. Is there a good resource to read on type level lists? I think that's my first step.
18:58:17 <monochrom> well, the truth seems to be more interesting than the doc
18:59:20 <sm> one other question.. I seem to see exceptions being masked somehow. I'm in the IO monad, and Failure is involved somehow. Could Failure be converting exceptions to maybes ?
19:01:28 <sm> eithers, I meant
19:02:30 <sm> oh, or maybe I fixed that. We shall see
19:02:37 <sm> later all
19:11:31 <Nereid> is it sad that I am excited that I have a program that displays a window with SDL that closes when I press a key?
19:11:31 <Nereid> :(
19:11:56 <_Ray_> I was excited when I coded a recursive factorial for the first time.
19:12:02 <_Ray_> You'll be fine.
19:12:17 <Nereid> I guess it's more "yay I got the SDL bindings working on windows"
19:12:27 <Nereid> and now I don't know what to do next
19:12:39 <_Ray_> Mine was "Wait... not all recursive programs loop indefinitely and crash? omg yay :D"
19:12:48 <Nereid> :>
19:13:04 <tolkad> How hard is it to get a job doing CS-related research or scientific computing after college if you get a graduate degree?
19:13:18 <Nereid> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
19:13:18 <lambdabot>   120
19:13:19 <danharaj> Nereid: Do what I did. Physics simulation.
19:13:24 <shachaf> _Ray_: Naive recursive factorial will still overflow the stack for a large argument.
19:13:42 <Nereid> > fix (\f n -> if n == 0 then 1 else n + f (n-1)) 10000
19:13:43 <lambdabot>   50005001
19:13:53 <danharaj> > fix fix
19:13:54 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
19:13:56 <Nereid> > fix (\f n -> if n == 0 then 1 else n + f (n-1)) 10000000
19:13:57 <lambdabot>   *Exception: stack overflow
19:13:59 <danharaj> :t fix
19:14:00 <Nereid> heh
19:14:00 <lambdabot> forall a. (a -> a) -> a
19:14:00 <_Ray_> yay fixed points :)
19:14:08 <_Ray_> That was how I learned about fix, sure enough.
19:14:20 <Nereid> > foldl 0 sum [1..10000000]
19:14:21 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> a)
19:14:21 <lambdabot>    arising from a use of...
19:14:28 <Nereid> oh duh
19:14:30 <Nereid> > foldl 0 (+) [1..10000000]
19:14:31 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
19:14:31 <lambdabot>    arising from a use...
19:14:35 <_Ray_> That, and fix(1:x) = [1,1,1,1...
19:14:35 <Nereid> noooo
19:14:38 <tolkad> shachaf: \n -> product [1..n]?
19:14:39 <Nereid> I forget everything apparently
19:14:45 <shachaf> uselessFix :: forall a. (forall a. a -> a) -> a
19:14:48 <Nereid> > foldl (+) 0 [1..10000000]
19:14:49 <lambdabot>  Terminated
19:14:50 <azaq231> > foldl' (+) 0 [1 .. 10000]
19:14:52 <lambdabot>   50005000
19:15:00 <Nereid> oh right
19:15:04 <Nereid> > foldl' (+) 0 [1..10000000]
19:15:06 <lambdabot>   50000005000000
19:15:15 <tolkad> that should by * for factorial shouldn't it?
19:15:19 <Nereid> of course
19:15:25 <_Ray_> shachaf: If nave recursion will overflow, what would you suggest?
19:15:33 <Nereid> _Ray_: add more strictness
19:15:39 <Nereid> foldl' is a more strict version of foldl
19:15:41 <_Ray_> Bang patterns?
19:15:44 <_Ray_> Ah.
19:15:52 <shachaf> Nereid: Who brought foldl into this?
19:15:54 <_Ray_> Hrmph. How would that help though?
19:15:56 <tolkad> _Ray_: bang patterns are not standard haskell and not necessary
19:15:58 <Nereid> I dunno
19:16:03 <tolkad> _Ray_: you can use the seq function
19:16:21 <_Ray_> But how would that help make recursive factorial not overflow?
19:16:22 <shachaf> _Ray_: In general you have the same issue that you'd have in a strict language.
19:16:37 <tolkad> _Ray_: they enforce order of evaluation
19:16:44 <tolkad> _Ray_: in a sense
19:17:02 <_Ray_> Indeed, but does that help? In fact, let's start simpler - the problem is that n! does n recursions?
19:17:02 <robnik> Does anyone know if the >>> in this arrows tutorial: http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf is the same as in Haskell now?  I tried the code from page 2 (http://hpaste.org/46043/arrows) and I don't know what's wrong.
19:17:20 <shachaf> _Ray_: If you make it tail-recursive it should be fine, in a strict language.
19:17:21 <Nereid> I think >>> is the same
19:18:02 <shachaf> http://c2.com/cgi/wiki?TailRecursion
19:18:04 <_Ray_> So f n = f' n 1, f' n k = f' (n-1) k*n
19:18:20 <shachaf> Of course things are sometimes a bit different in Haskell.
19:18:21 <_Ray_> Indeed, I spent some time studying recursion elimination
19:18:39 <robnik> Nereid: thanks
19:18:46 <_Ray_> And I still don't intuitively grasp the Z combinator. 
19:18:54 <_Ray_> I know how to type it, but I still don't... "understand" it, if that makes any sense.
19:18:55 <Nereid> robnik: are you sure the readFile is the same?
19:19:05 <Nereid> prelude readFile has a different signature than the one on that page
19:19:13 <Nereid> unless
19:19:15 <Nereid> ohh.
19:19:17 <Nereid> I see that type thing.
19:19:19 <Nereid> nm
19:20:15 <tolkad> _Ray_: is the Z combinator the same as the Y combinator?
19:20:27 <_Ray_> Applicative order, IIRC
19:20:31 <Nereid> aha
19:20:40 <Nereid> robnik: here's the problem:
19:20:54 <Nereid> the instance used for (>>>) is different
19:21:13 <Nereid> when you try to run it, it's using the Arrow instance for (->)
19:21:20 <Nereid> not Kleisli IO
19:21:43 <robnik> Ah, okay.
19:22:27 <Nereid> so, currently Kleisli is a newtype
19:22:29 <Nereid> not a type synonym
19:22:51 <Nereid> newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
19:23:19 * _Ray_ is envious of Nereid's knowledge of algebra, haskell, and physics. In a healthy way, of course. But I'd still go all Sylar on you, if you've watched Heroes.
19:23:26 <Nereid> =(
19:23:30 <Nereid> nooo
19:23:34 <Nereid> I like my brains.
19:23:40 <_Ray_> He cuts open people's heads and steals their powers.
19:23:52 <Nereid> robnik: so I believe the fix is to replace readFile with Kleisli readFile and so on
19:23:54 <Nereid> _Ray_: yes I watched it
19:23:57 <Nereid> just the first season though
19:24:04 <_Ray_> Same.
19:24:11 <jmcarthur> my power is immunity from having my head cut open
19:24:30 <danharaj> my power is not having any powers
19:24:44 <c_wraith> your power is paradoxical
19:25:00 <danharaj> My power evaluates to bottom.
19:25:03 <_Ray_> Fine, Kirby then.
19:25:08 <Nereid> :C
19:25:10 <danharaj> But it's wrapped up in my head.
19:25:12 <danharaj> So I'm safe.
19:25:17 <danharaj> Woe to whoever evaluates my thunk.
19:25:25 <parcs> what is the best way to parse a scanf-type string into a 48-field record?
19:25:38 <danharaj> Is that a zen koan?
19:25:56 <robnik> Nereid: That did it.  Thanks.
19:26:05 <ion> > {- ray: Given the contrived function -} let foo x = if x == 0 then [0] else x:foo (x-1) in foo 5 {- (note how the body refers to the function itself) -}
19:26:07 <lambdabot>   [5,4,3,2,1,0]
19:26:18 <c_wraith> parcs: I'd demand a recount on that specification :)
19:26:38 <ion> > {- the same can be defined using fix as follows -} fix (\foo x -> if x == 0 then [0] else x:foo (x-1)) 5
19:26:38 <lambdabot>   [5,4,3,2,1,0]
19:28:29 <ion> Whenever you see fix (\f args ->  f ) (or a pointless equivalent) you can think of f args =  f 
19:28:33 <Nereid> robnik: if you wanted to stick with monads, of course, you would use >=>
19:28:42 <m3ga> anyone able to give me a prod in the right direction with this ByteString problem? : http://hpaste.org/46044/bytestring_error_messahe
19:28:46 <Nereid> which is Kleisli composition without the extra newtype business
19:28:51 <_Ray_> Yeah, that I know, ion. f(x) = x
19:29:10 <_Ray_> I just don't intuitively grasp the Z combinator :(
19:29:43 <Nereid> what is the Z combinator?
19:30:10 <c_wraith> m3ga: you're trying to pass a strict bytestring to a function that expects a lazy bytestring
19:30:25 <ion> nereid: In Haskell, fix AFAIU.
19:30:59 <m3ga> c_wraith: well i have tried using Data.ByteString.Lazy instead but that didn't help
19:31:29 <Nereid> oh, Z is eta-equivalent to Y
19:31:47 <Nereid> or something
19:32:00 <zmv> hm
19:32:17 <c_wraith> m3ga: because it lacked the isString instance for the OverloadedStrings thing?
19:33:11 <c_wraith> m3ga: also, the ByteString in the type of application there needs to stay the strict version
19:34:09 <c_wraith> m3ga: honestly, I'd look for a way to generate the response that doesn't use lazy bytestrings.  seems easier.
19:46:13 * hackagebot enumerator 0.4.10 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.10 (JohnMillikin)
19:46:26 <shachaf> _Ray_: Wait, how can you understand the Y combinator and not the Z combinator?
19:51:07 <m3ga> c_wraith: thanks, fixed it. converted the responseLBS from the Network.Wai to a strict reponseBS and it now works.
19:53:39 <robnik> Nereid: about >=>, does this look good?  http://hpaste.org/46046/arrows_again   It runs, I'm just wondering if there are improvements.
19:53:51 <Nereid> sure
19:54:24 <Nereid> except that return . f can be replaced with something to make things cleaner I guess
19:54:43 <ion> @pl return . words >=> return . filter (==w) >=> return . length
19:54:43 <lambdabot> (line 1, column 16):
19:54:43 <lambdabot> unexpected ">" or "="
19:54:43 <lambdabot> expecting variable, "(", ".", space, operator or end of input
19:54:43 <lambdabot> ambiguous use of a left associative operator
19:54:59 <parcs> @pl f *> h <* g
19:54:59 <lambdabot> f *> h <* g
19:55:41 <parcs> this would run f then g then h then g, correct?
19:55:55 <Nereid> it would from f then h then g, and keep the result of f
19:55:59 <Nereid> er, of h
19:56:16 <byorgey> return . f >=> return . g  === return (g . f)
19:56:16 <parcs> good!
19:56:38 <lostboy691> hey
19:56:58 <byorgey> hi lostboy691 
19:57:17 <lostboy691> is anyone willing to help with a java project
19:57:25 <byorgey> err, sorry, I meant  return . g . f
19:57:36 <lostboy691> can you help byorgey
19:57:36 <Nereid> lostboy691: you're in #haskell you realize
19:57:44 <lostboy691> i know but
19:58:01 <byorgey> lostboy691: probably someone is willing to help you.  But that person is probably not in this channel.
19:58:07 <danharaj> are infix operators at the type level left associative or right associative?
19:58:22 <tolkad> lostboy691: you were just in ##programming and they referred you to ##java, why don't you go there?
19:59:01 <byorgey> danharaj: you can find out in ghci with :info
19:59:10 <danharaj> byorgey: ah. how about by default?
19:59:23 <lostboy691> i am going still in programming i am heading to java now thanks
19:59:25 <danharaj> This little adventure is probably going to end with tears on my part but it must be done :p
19:59:31 <byorgey> danharaj: not sure, but I think they by default they are just infix, not infixr or infixl
19:59:37 <danharaj> ah
19:59:46 <danharaj> how do you set the associativity?
19:59:52 <danharaj> in all my haskelleting I have not done that.
20:00:03 <byorgey> infixr 6 :<:
20:00:04 <byorgey> or whatever
20:00:17 <Nereid> by default, they're left associative it seems
20:00:37 <danharaj> infixl n :&#%&(#*:
20:00:46 <danharaj> is higher n binding tighter or not as tight?
20:00:58 <ion> :i ($)
20:01:04 <ion> @info ($)
20:01:04 <lambdabot> ($)
20:01:06 <ion> meh
20:01:18 <ion> ghci says: infixr 0 $
20:01:20 <ion> there you have it.
20:01:22 <danharaj> yeah I just checked
20:01:28 <danharaj> thanks
20:01:54 <Nereid> yeah, infixr and infixl can be used to set associativity of type operators
20:02:48 <byorgey> danharaj: higher = tighter.
20:03:28 <Nereid> :r
20:03:32 <Nereid> oops, wrong window
20:03:42 <Nereid> :r anyway
20:03:48 <kmc> Ok, modules loaded: none.
20:04:02 <kmc> <no location info>: no such module: `anyway'
20:04:06 <Nereid> =(
20:04:12 <shachaf> :quit
20:05:57 <danharaj> hmm... I don't think I quite understand my problem just yet.
20:07:22 <parcs> is there more idiomatic way of parsing a string between parentheses in attoparsec than: char '(' *> takeTill (== ')') <* anyChar ?
20:07:37 <geheimdienst> danharaj: many big software projects have managed to never do that at all ...
20:07:39 <_Ray_> shachaf: Never said I grasped Y either :(
20:07:45 <shachaf> _Ray_: Oh.
20:07:47 <danharaj> geheimdienst: heh.
20:07:55 <_Ray_> I fail badly.
20:08:03 <danharaj> Haskell makes it hard to proceed when you don't understand your problem :)
20:08:09 <kevinburke> is there a way to stop ghc from name mangling in the .s files?
20:08:20 <shachaf> _Ray_: http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps
20:09:07 <parcs> never mind, going to sleep
20:11:16 * hackagebot HDBC-mysql 0.6.4.0 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.4.0 (BryanOSullivan)
20:12:20 * applicative follows Professor Harper: Haskell makes it impossible to proceed when you *do* understand your problem
20:12:50 <danharaj> heh
20:13:46 * applicative now realizes that none of the terms he defined meant anything, their 'semantics' is only really understood by Professor Harper
20:15:11 <geheimdienst> that's already one step up from the professors that don't understand the terms they're making up. it's amazing how far you can get with handwaving, bullshit, and intimidation
20:15:16 <geheimdienst> ;)
20:15:26 * applicative thinks, like the time I had that 'data Person = Person { name :: String, birth :: Int}; martha = Person "Martha Jones" 1975...
20:15:37 * applicative now realize he was defining lazy copersons
20:15:52 <shachaf> _Ray_: SPJ's _Implementation of Functional Programming Languages_ also has a good explanation of Y.
20:16:06 * applicative thought he meant Martha, but it was a lazy comartha
20:16:15 <danharaj> I wonder where Haskell would be today without SPJ
20:16:18 <danharaj> Probably nowhere. :p
20:16:19 * _Ray_ reads
20:17:33 <Nereid> where would it be today without category theory?
20:18:05 <kmc> we might have the same APIs but call them something different
20:18:38 <kmc> i'd be happy if people started talking about "continuation-based IO" instead of "monadic IO"
20:19:08 <danharaj> It's strange to imagine a world where mathematics stalled out long enough that category theory wasn't developed before modern computing.
20:19:17 <applicative> the word 'continuation' is even more obnoxious jargon than 'monad'
20:19:38 <kmc> starting to wonder if something generic and bland like F#'s "workflows" is better
20:19:43 <kmc> applicative, really?
20:20:04 <monochrom> longjmp-based IO
20:20:14 <applicative> IO based IO
20:20:27 <djahandarie> I don't CPS transform, I lift monads into the Codensity monad.
20:20:44 <kmc> if you're talking about what makes IO in Haskell special, the jargon "continuation" is at least more relevant than the jargon "monad"
20:21:04 <Nereid> danharaj: it could have happened. category theory is relatively new
20:21:18 <ddarius> Continuations don't have much to do with IO necessarily.
20:21:26 <danharaj> Nereid: It's more or less the same age as the theory of computation.
20:21:49 <monochrom> continuation is like a burrito
20:21:55 <Nereid> it's newer
20:21:58 <applicative> monochrom, exactly
20:22:00 <Nereid> lambda calculus is a '30s thing
20:22:03 <djahandarie> In fact, I'm pretty sure you can model quite a bunch of stuff with the Codensity monad.
20:22:04 <Nereid> category theory was the '50s maybe?
20:22:15 <Nereid> '40s
20:22:33 <djahandarie> Nereid, category theory rose out of hardcore math though, and I don't know how long it was until there were connections to CS.
20:22:39 <djahandarie> ddarius probably knows
20:22:42 <Kerris> danharaj: I wonder where Haskell would be today if Haskell.NET had taken off :V
20:23:00 <Kerris> also aaaaaaargh I just twisted my foot >_O
20:23:05 <ddarius> djahandarie: Certainly Scott and Strachey were aware of category theory in the 70's.
20:23:11 <applicative> Kerris, we'd have workflows!!
20:23:44 <Nereid> well, by the 70s many people were aware of category theory
20:24:31 * djahandarie tries to find a document detailing the history of CT
20:25:30 <djahandarie> Hmm, Lambek was in the late 60s
20:25:30 <ddarius> Nereid: Indeed.
20:25:33 <danharaj> SEP should have a decent article.
20:26:00 <ddarius> Though both computer science and category theory were still pretty young then.
20:26:53 <djahandarie> I feel like the two fields didn't really connect until much later than Lambek though
20:28:52 <Nereid> djahandarie: what did Lambek do?
20:29:16 <danharaj> Was one of the people to observe that the Curry-Howard isomorphism extended to categories too.
20:29:19 <djahandarie> He connected CT to logic and foundational math
20:29:30 <Nereid> mm
20:29:48 <djahandarie> Which was a fairly critical step to connecting it to CS, imo
20:29:52 <Nereid> yeah, wikipedia is totally unhelpful
20:30:45 <djahandarie> Hm, that was probably too general a statement. He connected it to deductive reasoning
20:33:05 <djahandarie> In '86 is when Lambek connected CCCs and the typed lambda calculus, but that was quite awhile after his initial work regarding CCCs and other logics around 68-72
20:33:59 <Nereid> that is pretty recent I guess
20:34:47 <djahandarie> Hmm, apparently some guy called Seely also talked about Locally CCCs and type theory in '84.
20:36:48 <djahandarie> I'm fairly surprised stuff didn't take off the moment CCCs and the STLC were connected
20:37:10 <djahandarie> It feels like not much happened for awhile until the late 90s, looking at these publication dates
20:38:24 <acfoltzer> djahandarie: CCC = cartesian or compact closed?
20:38:32 <djahandarie> Cartesian Closed
20:38:41 <acfoltzer> thanks, was having google troubles
20:38:43 <acfoltzer> :)
20:39:01 <acfoltzer> and/or doing too much quantum lately
20:39:07 <danharaj> So um. Trying to encode in types the interfaces for OpenGL shaders. So I'm thinking, a shader interface is some n-tuple of types (using my own type constructor :*:), and I need to associate to such an interface a function that takes a shader program, an n-tuple of strings and looks up the opengl locations of those types.
20:39:18 <danharaj> I don't know what I'm doing.
20:40:03 <_Ray_> shachaf: :o (lambda (mk-length) (mk-length mk-length))(...) The U combinator :D
20:40:19 * hackagebot Thrift 0.6.0 - Haskell bindings for the Apache Thrift RPC system  http://hackage.haskell.org/package/Thrift-0.6.0 (KirkPeterson)
20:40:21 * hackagebot cassandra-thrift 0.8.0 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.8.0 (KirkPeterson)
20:40:25 <jargonjustin> Is there a higher-order function that would make something like a filter with a fold simpler? I'm looking for something like `filterWith :: (a -> b -> (a, Bool)) -> a -> [b] -> [b]`. Is there something like a filter in the State monad?
20:40:56 <djahandarie> :t filterM
20:40:57 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:41:09 <kmc> also look at mapAccumL / mapAccumR
20:41:26 <jargonjustin> djahandarie, kmc: thanks!
20:41:41 <shachaf> _Ray_: U?
20:41:43 <djahandarie> I'm not sure how useful filterM would be here, actually.
20:42:13 <kmc> jargonjustin, sometimes it's useful to produce a list of (Maybe T) and then call catMaybes on it
20:42:16 <_Ray_> Otherwise known as 'fix'
20:42:19 <_Ray_> @ shachaf
20:42:48 <_Ray_> U(f) = f(f)
20:43:02 <_Ray_> ... is that really fix? No, not it isn't.
20:43:13 <tolkad> danharaj: while you're at it, if you're working on some of the hackage opengl libraries, it would be cool if there were a opengl library that kept track of known information about opengl state at the type level, ensuring more type safety for opengl operations and possibly even optimizations using rewrite rules or even a runtime compiler (operating on a data structure representing a sequence of opengl operations and spitting out a "IO ()")
20:43:37 <_Ray_> http://okmij.org/ftp/Computation/fixed-point-combinators.html#Relationship @ shachaf
20:43:51 <danharaj> tolkad: that would be severely escalating the ambition of my idea but I will keep it in mind :)
20:44:10 <danharaj> tolkad: I just want to abstract the repetitive boilerplate of getting and setting attributes and uniforms.
20:44:24 <Kerris> haha "while you're at it"
20:44:30 <tolkad> danharaj: so why don't you start by coming up with a type-level representation of floating point values
20:44:32 <shachaf> _Ray_: Oh, the mockingbird.
20:44:37 <danharaj> tolkad: eh?
20:44:43 <_Ray_> ... why is it called that?
20:45:06 <tolkad> danharaj: well you're going to want to keep track of the current color, and that is represented by floating point values
20:45:16 <shachaf> _Ray_: http://en.wikipedia.org/wiki/To_Mock_a_Mockingbird
20:45:31 <danharaj> tolkad: I don't see why.
20:45:37 <shachaf> ( http://www.angelfire.com/tx4/cus/combinator/birds.html )
20:46:10 <_Ray_> xD
20:46:11 <tolkad> danharaj: so you can keep track of all known opengl state at the type level
20:46:21 <Kerris> shachaf: I've read that book (literally out loud) at least ten times and I still don't get most of it
20:46:24 <danharaj> Oh, your thing. I don't know how I would do it :p
20:46:50 * shachaf hasn't actually read the book.
20:46:51 <djahandarie> > (runState $ filterM (\x -> state (\y -> (x==y, x*2))) [1,2,3,4]) 1 -- jargonjustin
20:46:52 <lambdabot>   ([1,2],8)
20:46:58 <danharaj> I would probably just keep track of Enabled/Disabled state.
20:47:05 <Kerris> I don't think I have the foundation for that :(
20:47:58 <shachaf> Foundation?
20:48:12 * djahandarie notes to get on adding mtl stuff to newtype
20:49:09 <Kerris> shachaf: my logic-fu is pretty rudimentary.
20:49:22 <m3ga> Network.HTTP.Types has 'type Header = (CI Ascii, Ascii)' and i'm trying to extract the two Ascii parts but even if i 'import Data.CaseInsensitive (CI)', ghc still can't find the CI constructor. clues?
20:49:38 <shachaf> Kerris: Logic is for the birds.
20:49:54 <Kerris> @_@
20:50:16 <Kerris> Granted, that book was recommended to me by a Prolog guy.
20:51:16 <Kerris>  who seemed to be in a permanent state of elevated consciousness.
20:51:36 <shachaf> I thought the point of the book was not needing very much background?
20:52:03 <djahandarie> @typ runState .: filterM . (state .) -- jargonjustin 
20:52:03 <lambdabot> forall s a. (a -> s -> (Bool, s)) -> [a] -> s -> ([a], s)
20:53:37 <Kerris> shachaf: maybe I'm just dumb :(
20:54:27 <djahandarie> would just be   underF State filterM   if I had mtl loaded into the newtype package too
20:54:29 <_Ray_> shachaf: Do people actually use those bird names often?
20:54:49 <shachaf> Kerris: If you read the book ten times and still don't get it, presumably that would mean that you kept reading after not understanding something, rather than figuring it out.
20:54:57 <shachaf> _Ray_: Not that I know of.
20:55:35 <Kerris> shachaf: that's a good point. I assume that like in many other books, the secret would be revealed in the next chapter.
20:56:23 * djahandarie runs to bed
20:57:24 <shachaf> Kerris: Mathematics books often require you to spend some time on a particular point, rather than just going on.
20:57:36 <Kerris> :'<
21:06:24 <jmcarthur> tolkad: i tried that once. it quickly escalated into a *huge* parameterized state monad and i got bored with it
21:07:11 <jmcarthur> i was only trying to keep track of what was bound and stuff like that
21:07:53 <jmcarthur> i also was using monadic regions for resource management. that also turned into a pain fairly quickly
21:17:06 <danharaj> I can't help but think of Street Fighter when I use Repa.
21:17:08 <danharaj> SHORYUUUU REPPA
21:17:20 * danharaj note to self: make hadouken library
21:18:46 * dolio makes a sheng long library.
21:22:05 <fengshaun> I'm learning haskell and I want to practice it while learning.  Does anyone have any recommendations on where I can go to find programming practices online?  Project Euler is nice, but is too math-oriented.
21:23:32 <jmcarthur> just pick a project to code. try an irc bot, a card game, something like that
21:25:05 <jornnn> howdy o/
21:25:16 <fengshaun> jmcarthur: good idea, but I have blanked out on project ideas.  Anything I think of needs more knowledge of haskell than I have.
21:25:25 <danharaj> learn while you go
21:25:32 <kmc> RWH has some good projects
21:25:49 <jornnn> so, what exactly is a dark net? xD
21:25:55 <fengshaun> kmc: RWH?
21:25:57 <jornnn> how does it achieve anonymity :O
21:26:03 <Kerris> Real World Haskell
21:26:17 <ddarius> jornnn: What does this have to do with Haskell?
21:26:22 <Kerris> http://www.realworldhaskell.org/
21:26:28 <jornnn> it could ddarius 
21:26:31 <fengshaun> Kerris: oh, that book.  Yea, I'm reading LYAH, but I could use those excercises!
21:26:34 <fengshaun> Kerris: thanks.
21:26:46 <Kerris> fengshaun: finish LYAH first
21:27:05 <fengshaun> oh, so I should finish it and then?
21:27:19 <fengshaun> I guess I could hold on!
21:27:23 <Kerris> And then try RWH. Your learning style may vary.
21:27:46 <fengshaun> thanks
21:35:25 * _Ray_ can't wait to study fixed point combinators formally.
21:35:37 <_Ray_> Well, the entire lambda calculus, really.
21:36:03 <_Ray_> Why would anyone like typed lambda calculus over untyped?
21:36:37 <Mathnerd314> _Ray_: less non-terminating programs
21:36:56 <_Ray_> How well defined is "less"?
21:38:12 <Nereid> _Ray_: so you don't have things like (\x.xx)(\x.xx)
21:38:44 <Nereid> I'm guessing
21:38:46 <_Ray_> U(U)
21:39:47 <Nereid> well I guess in general you can't have stuff like MM in type lambda calculus
21:43:37 <Nereid> typed*
22:00:02 <kmc> _Ray_, types categorize functions
22:00:10 <kmc> you can say more about your functions if you know they're well-typed
22:00:55 <_Ray_> Well, what would Haskell be in that sense? It has types, but it's still polymorphic. Could one say its functions are morphisms in Hask?
22:02:57 <kmc> one could say that
22:03:02 <kmc> i'm not sure why you are saying it, though
22:03:32 <kmc> what does it have to do with the other things?
22:03:36 <dolio> "Still polymorphic"?
22:03:55 <kmc> _Ray_, there are typed lambda calculi incorporating various sorts of polymorphism
22:04:03 <kmc> http://en.wikipedia.org/wiki/Lambda_cube
22:04:08 <kmc> the simply-typed lambda calculus has none
22:04:18 <_Ray_> dolio: I can have a function that is a -> a, without really specifying what a is.
22:04:34 <copumpkin> you still know it's a function, and that the input is the same as the output
22:04:41 <copumpkin> it's more knowledge than in an untyped system
22:04:43 <kmc> System F adds polymorphic functions
22:04:44 <_Ray_> That's what I meant by "polymorphic": I'm specifying not a single type, but a range of possible types. This seems like a middle ground between typed and untyped lambda calculus.
22:04:56 <Nereid> it's typed lambda calculus but even better
22:05:02 <kmc> it is *a* typed lambda calculus
22:05:08 <kmc> it is not the simply-typed lambda calculus
22:05:22 <kmc> Haskell's type system is pretty close to System F
22:05:34 <kmc> which is STLC + polymorphism + type constructors
22:05:49 <kmc> except Haskell has further restrictions to make type inference decidable
22:06:01 <dolio> The emphasis in my question was on the "still."
22:06:24 <kmc> and Haskell handles polymorphism implicitly, whereas System F has explicit type-abstraction and type-application syntax
22:06:24 <tolkad> don't worry about it though, just unsafeCoerce lambda calculus sexpressions to "forall a b. a -> b" if you run into any type errors when writing lambda calculus expressions
22:06:29 <tolkad> don't worry about it though, just unsafeCoerce lambda calculus subexpressions to "forall a b. a -> b" if you run into any type errors when writing lambda calculus expressions
22:06:33 <tolkad> whoops
22:07:11 <_Ray_> are there languages that map values to types?
22:07:26 <Nereid> those with dependent types, I guess
22:07:38 <kmc> _Ray_, www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
22:07:58 <_Ray_> I am scared by the speed of your response.
22:08:01 <kmc> http://www.cis.upenn.edu/~bcpierce/sf/Preface.html#lab1
22:08:46 <kmc> in Haskell values can depend on types (polymorphism) and types depend on types (type constructors) but types can't depend on values (dependent types)
22:08:56 <kmc> a more precise term for "depend on" would be "be parametrized over"
22:09:31 <_Ray_> Ah, interesting. So templating in C++, for instance, has types that depend on values.
22:09:39 <kmc> yeah
22:10:06 <kmc> but that only scratches the surface of what you can do
22:10:20 <dolio> C++ is a poor example of that.
22:10:23 <kmc> in a full-on dependently typed language, you can encode *any* property of your function in its type
22:11:07 <kmc> for this reason, most programming languages with dependent types are advertised as formal proof systems
22:11:38 <_Ray_> So for instance I could have a matrix of prime numbers, all restricted by types.
22:11:43 <Nereid> sure, but it seems useful enough for a programming language meant for programming, no?
22:12:05 <Nereid> _Ray_: you can encode preconditions for a function in its type, say
22:12:19 <_Ray_> Sort of like assertions for the type constructor and assertions for things which modify the values of the types.
22:12:23 <_Ray_> Right.
22:12:42 <Nereid> read that article though :P
22:12:45 <kmc> if you're interested in this, you should read about the Curry-Howard Isomorphism
22:12:52 <Nereid> the agda one
22:12:53 <_Ray_> Indeed, I'm reading the first pdf :)
22:13:15 <kmc> types are logical propositions, and a value of type T is a proof of the proposition T
22:13:32 <kmc> in particular, a value of type A -> B is a proof that "A implies B", because it's a way to take a proof of A and produce a proof of B
22:14:39 <Nereid> and inhabited types correspond to theorems
22:14:41 <_Ray_> That's very pretty :) A value is a proof since it proves that there exists something which satisfies the conditions, correct?
22:14:51 <_Ray_> So it can't be a contradiction.
22:14:58 <kmc> yeah
22:15:10 <kmc> the type T is the proposition "type T is inhabited"
22:15:38 <_Ray_> Inhabited meaning {v : T(v)} != 0
22:15:45 <_Ray_> ... where I'm abusing notation to the limit.
22:15:48 <Nereid> lol
22:15:52 <Nereid> a type is inhabited if it has a value.
22:15:53 <_Ray_> Where would v be, though?
22:15:56 <kmc> functions act as proofs of implication because they give you a way to prove that B is inhabited if A is inhabited
22:16:01 <_Ray_> "The set of... all values"?
22:16:11 <Nereid> how about just {v : T}
22:16:16 <Nereid> the set of all things v of type T
22:16:21 <kmc> that's just T
22:16:24 <Nereid> it is
22:16:35 <_Ray_> What are 'things'?
22:16:40 <kmc> values
22:16:41 <kmc> proosf
22:16:44 <Nereid> there are no "things"
22:16:45 <kmc> whatever :)
22:16:48 <Nereid> there are only "things of type _"
22:17:09 <Nereid> things = values
22:17:12 <kmc> when you say "data Foo = Bar | Baz" you've invented two new things of type Foo
22:17:28 <kmc> bbl
22:17:54 <_Ray_> I shouldn't be allowed near these things...
22:17:57 <Nereid> in particular, "data Null" is the type with no values
22:18:01 <Nereid> er, defines the type
22:18:14 <_Ray_> i.e. False
22:18:16 <Nereid> yes
22:18:33 <Nereid> negation of T can be encoded as (T -> Null)
22:18:44 <Nereid> if T is inhabited, there can't be any value of type T -> Null
22:18:54 <_Ray_> Hrm
22:18:59 <_Ray_> But everything implies false
22:19:07 <_Ray_> Err
22:19:09 <_Ray_> I'm an idiot.
22:19:11 <Nereid> because*
22:19:12 <_Ray_> False implies everything.
22:19:15 <Nereid> well
22:19:26 <Nereid> suppose you had a function T -> Null, where T was nonempty
22:19:33 <Nereid> what would the function send an element of T to?
22:19:39 <Nereid> it can't. so there are no such functions
22:19:50 <Nereid> conversely, if T is empty
22:19:55 <_Ray_> So why is there a function from Null to Null?
22:19:55 <Nereid> then there is a (unique) function T -> Null
22:20:04 <_Ray_> Ohh I know.
22:20:05 <Nereid> defined by
22:20:06 <Nereid> nothing
22:20:09 <Nereid> there is nothing to define
22:20:13 <_Ray_> Because I can only do it if Null is the domain.
22:20:25 <_Ray_> Which is a contrived way of saying false implies everything.
22:20:33 <Nereid> now negation and implication generate all of propositional logic
22:20:36 <Nereid> so that's that
22:20:36 <_Ray_> dsghdfskjghsdfg. So hot :(
22:20:55 <Nereid> and you can axiomatize it too
22:20:57 <_Ray_> Ah, I see, then, how this could be considered a formal language for theorem proving
22:21:06 <Nereid> sure
22:21:12 <Nereid> as for axioms of propositional logic
22:21:40 <Nereid> uh, let Not T = T -> Null
22:21:48 <Nereid> everything can be derived from the axioms
22:21:52 <Nereid> er, axiom schemes
22:22:04 <_Ray_> You could say that there are always functions which take an T into (X -> T)
22:22:11 <Nereid> (a -> b -> c) -> (a -> b) -> (a -> c)
22:22:13 <_Ray_> Which is T -> X -> T, which is true
22:22:14 <Nereid> eh?
22:22:24 <Nereid> and a -> (b  -> a)
22:22:28 <_Ray_> P => (Q => P)
22:22:28 <Nereid> and Not (Not a) -> a
22:22:54 <Nereid> which I guess means ((a -> Null) -> Null) -> a ....
22:22:55 <_Ray_> Right, I think we learned that as "SP", for some reason, as an axiomatization of propositional logic
22:23:00 <Nereid> heh
22:23:02 <shachaf> Nereid: That's not an axiom!
22:23:05 <Nereid> fine!
22:23:13 <Nereid> but if Not was atomic
22:23:22 <Nereid> or whatever you call it
22:23:33 * shachaf is supports the intuitionism police.
22:23:37 <shachaf> s/is /
22:23:42 <shachaf> "atomic"?
22:23:46 <Nereid> I'm not talking about intuitionistic logic!
22:23:50 <Nereid> just classical logic
22:23:53 <_Ray_> wtf. I should not find papers titled '"Presheaf toposes and propositional logic" by Richard Squire'
22:23:57 <dolio> Why would you talk about classical logic?
22:24:01 <_Ray_> that should be nsfw :/
22:24:03 <Nereid> as an example.
22:24:24 <Nereid> of course, we don't have classical logic.
22:24:49 * _Ray_ never actually considered what intuitionist logic is, but fears it might dig into *shiver* philosophy.
22:25:02 <dolio> Didn't this start as an explanation of how dependently typed functional languages can be used as logics?
22:25:08 <Nereid> fine
22:25:10 <dolio> Most aren't classical.
22:26:00 <shachaf> Classical logic in Haskell would be considered kind of evil, wouldn't it?
22:26:21 <dolio> I don't know how it would work.
22:26:36 <dolio> I haven't spent any time learning control effects in lazy languages.
22:26:50 <_Ray_> "Agda functions are not allowed to crash," <-- sounds pretty.
22:26:54 <Nereid> I haven't spent any time learning anything about anything, which is why I spew nonsense all the time.
22:29:37 <_Ray_> ...
22:29:40 <_Ray_> _or_ : Bool -> Bool -> Bool
22:29:40 <_Ray_> true or x = x
22:29:40 <_Ray_> false or _ = false
22:29:52 <_Ray_> I think he accidentally a boolean function :s
22:30:00 <Nereid> aha
22:30:07 <Nereid> probably meant and, not or
22:30:07 <Nereid> :P
22:30:50 <dolio> Where is that?
22:31:14 <Nereid> page 2
22:31:23 <Nereid> of the agda paper
22:32:49 <dolio> I suppose it isn't very important, since the point is the infix function with alphabetic characters.
22:33:01 <Nereid> right
22:33:05 <_Ray_> this feels like covert ops. like a computer scientist shouldn't be allowed near this much mathematics, but he crafts himself a tower to assail the castle of mathematics.
22:33:10 <_Ray_> ... and I need less weed. Or more.
22:33:57 <dolio> Computer science is all mathematics.
22:34:10 <Nereid> hmm, on page 9, in the definition of Fin
22:34:19 <Nereid> shouldn't it be fzero : {n : Nat} -> Fin zero?
22:34:28 <Nereid> or am I misunderstanding things
22:34:52 <Nereid> oh never mind
22:34:53 <Nereid> I get it
22:34:58 <dolio> No.
22:35:16 <dolio> Fin 0 has no inhabitants.
22:35:25 <Nereid> the way it's described, Fin n is the numbers smaller than n
22:35:31 <Nereid> so,
22:35:40 <_Ray_> hrm. in identity : (A : Set) -> A -> A, identity A x = x, why does identity return an (A -> A) and not an A?
22:35:47 <Nereid> fzero gives a Fin 1
22:36:01 <Nereid> and that's the unique constructor of a value of type Fin 1.
22:36:04 <Nereid> got it
22:36:35 <Nereid> er, for n = zero
22:36:36 <_Ray_> (and in any case, shouldn't it be 'identity x = x'?)
22:36:55 <Nereid> _Ray_: it takes a type, and a value of that type
22:36:58 <Nereid> and returns a value of the same type
22:37:13 <Nereid> read it as identity : Set -> A -> A, where A is the given value of Set
22:37:15 <_Ray_> Set is the set of types?
22:37:17 <Nereid> yes
22:37:40 <_Ray_> ok. that's sort of weird though, but it makes sense - it makes specialization explicit
22:37:48 <Nereid> that's how polymorphism is encoded
22:37:52 <_Ray_> meaning, id :: A would be partially applying identity A
22:38:03 <Nereid> eh
22:38:13 <_Ray_> id :: A -> A :)
22:38:18 <Nereid> well
22:38:22 <Nereid> in agda you have identity A : A -> A
22:38:40 <Nereid> in practice one would probably write it as identity : {A : Set} -> A -> A
22:38:48 <Nereid> so that the type argument is implicit
22:38:53 <Nereid> and you can just write identity x = x
22:38:57 <_Ray_> that's how the guy writes it, your first way is actual agda?
22:39:05 <_Ray_> (identity A : A -> A I mean)
22:39:17 <Nereid> probably not, I just mean that
22:39:19 <Nereid> identity A has type A -> A
22:39:24 <_Ray_> ah, yes
22:39:47 <Nereid> I've never actually used agda, mostly because it seems to make me use emacs
22:39:49 <Nereid> and I don't use emacs ;(
22:39:56 <_Ray_> neither do I :D
22:40:04 <_Ray_> though, I don't even use vi(m).
22:40:09 <Nereid> ah, I use vim.
22:40:11 <_Ray_> I wuss out and use TextMate
22:40:17 <Nereid> =/
22:40:45 <Nereid> sometimes I wish I could attach a USB keyboard to my phone.
22:41:05 <Nereid> maybe I can.
22:41:22 <_Ray_> ^-- different between average person and computer geek.
22:41:34 <Nereid> lol
22:41:35 <_Ray_> *difference
22:42:53 <Nereid> hmm, seems like my phone doesn't have USB OTG ;(
22:43:07 <Nereid> not certain
22:43:36 <dolio> I think there exist people who do some Agda without emacs. But it's a struggle by comparison.
22:44:11 <_Ray_> Why? It seems to be just text.
22:44:52 <dolio> Writing Agda in emacs is a far better experience than almost any other language out there.
22:45:12 <dolio> You can write things like 'foo x y z = ?', and type check the file.
22:45:33 <Nereid> is it possible to make such functionality work in vim?
22:45:35 <dolio> The '?' will stand in for any term, and become an area in which you can type.
22:46:03 <dolio> The system will tell you what type of term you need to fill in the hole, and what is in scope and so on.
22:46:05 <Nereid> (which, of course, is a completely different question from whether someone is willing to do so)
22:46:22 <dolio> And you can type partial expressions, with further ?s in them, to partially fill the obligation.
22:46:31 <dolio> I imagine it's possible.
22:47:02 <dolio> I suspect Agda currently has a fair amount of emacs-specific stuff in it, though, for this purpose.
22:47:12 <dolio> But I haven't looked.
22:47:54 <_Ray_> hrm, I don't understand this type.
22:47:57 <_Ray_>  (A : Set)(B : A -> Set) -> ((x : A) -> B x) -> (a : A) -> B 
22:48:08 <_Ray_> 1) shouldn't there be a -> between (A : Set) and the rest?
22:48:16 <Nereid> _Ray_: that's a syntax abbreviation
22:48:24 <_Ray_> 2) What is B x and B  a? (there last part is B a, not just B)
22:48:34 <Nereid> notice how B : A -> Set
22:48:43 <Nereid> so it takes a value of type A and returns a value of type Set (i.e. a small type)
22:48:47 <dolio> There are also commands for specifying one of the variables in 'foo x y z = ?', and having it auto-expanded into multiple lines, with constructor patterns for the relevant variable.
22:49:02 <_Ray_> right, so B is the type of functions that take an A and return a type?
22:49:05 <Nereid> yes
22:49:11 <Nereid> no
22:49:14 <Nereid> B is such a function
22:49:14 <_Ray_> :(
22:49:29 <dolio> And commands that will automatically partially fill in holes if it's "obvious" what should go in them.
22:49:30 <Nereid> so if x : A, then B x : Set
22:49:30 <_Ray_> oh, : is "is in"
22:49:51 <_Ray_> oh OK
22:51:12 <_Ray_> so it takes a type A, a function B that takes A to some type,  a function that takes a value of type A and returns a value of the same type B returns, a value of type A, and returns a value of the type that B a returns
22:51:24 <_Ray_> where B returns types, so... the bastard returns TYPES!?
22:52:01 <Nereid> which page?
22:52:13 <_Ray_> Just after 2.2
22:52:26 <Nereid> ah, apply
22:52:54 <Nereid> you left off an a at the end
22:52:57 <Nereid> ... -> B a
22:53:15 <_Ray_> yeah, "(there last part is B a, not just B)"
22:53:18 <Nereid> yeah
22:53:18 <_Ray_> I screwed up a simple ctrl+v :(
22:53:20 <Nereid> missed that
22:53:28 <Nereid> or you never said it
22:53:31 <Nereid> or I missed that
22:53:33 * hackagebot tls 0.6.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.6.1 (VincentHanquez)
22:53:42 <_Ray_> but anyway, since B returns types, doesn't apply return types then?
22:53:49 <Nereid> no
22:53:53 <Nereid> B a is a type
22:54:13 <Nereid> so in apply A B f a = f a,
22:54:14 <Nereid> A : Set
22:54:16 <Nereid> B : A -> Set
22:54:29 <Nereid> uh,
22:54:41 <Nereid> f : x -> B x, where x : A
22:54:45 <Nereid> a : A
22:54:54 <Nereid> so f a : B a
22:54:57 <Nereid> which makes sense
22:55:32 <_Ray_> So f takes values of type A, and returns B x, which is... what again?
22:55:54 <_Ray_> Oh, I'm dumb
22:55:59 <_Ray_> B is an element of A -> Set
22:56:20 <_Ray_> So B x is applying a function that takes stuff in A, and returns stuff in Set
22:56:26 <Nereid> f takes x : A to f x : B x
22:56:38 <Nereid> huh
22:56:41 <_Ray_> so B x is Set?
22:56:47 <Nereid> B x : Set, yeah
22:56:52 <Nereid> because x : A and B : A -> Set
22:57:09 <_Ray_> well, if B x is in Set, isn't B x a type? since Set is the set of types?
22:57:09 <Nereid> so f x is a type
22:57:13 <_Ray_> right
22:57:26 <_Ray_> so apply will return a type :s
22:57:30 <Nereid> no
22:57:33 <Nereid> it will return a value of that type
22:57:43 <Nereid> f a : B x
22:57:51 <Nereid> er, B a
22:57:53 <Nereid> f a : B a
22:58:06 <_Ray_> When you say 'f x is a type', you mean that evaluating f on the argument x returns an element of type Set, meaning it returns a type?
22:58:11 <Nereid> f x is not a type
22:58:13 <Nereid> my mistake
22:58:17 <_Ray_> ah, ok
22:58:18 <Nereid> if I ever said that
22:58:20 <Nereid> I did
22:58:26 <Nereid> B x is a type
22:58:28 <Nereid> f x is a value of that type
22:58:30 <mjrosenb> is this agda?
22:58:33 <Nereid> yeah
22:58:48 <Nereid> he's trying to work through http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
22:59:00 <_Ray_> (consider my IQ less than or equal to my age.)
22:59:01 <Botje> jaspervdj: congrats with the proposal!
22:59:15 * mjrosenb should learn agada at some point or other.
22:59:17 <_Ray_> ok, so B x, with B is a function from A to a type. So B x is a type :D
22:59:22 <jaspervdj> Botje: thanks :-)
22:59:23 <_Ray_> ok, yes. that made sense.
22:59:42 <Nereid> yes
22:59:58 <_Ray_> and since a is an element passed, B a is a value-dependent type
23:00:04 <Nereid> yeah
23:00:51 <_Ray_> interesting. in other languages you'd be limiting the information Apply knows about to the type of a and the type of f
23:01:05 <_Ray_> here it also can work with the value of a
23:01:21 <_Ray_> so B a could be some type for a composite, and some other type for a prime
23:01:39 <Nereid> sure
23:02:00 <Nereid> I think the rough idea is that "types are values"
23:02:21 <_Ray_> indeed. this seems pretty powerful for specifications
23:29:29 <m3ga> I getting some type errors that to me are completely incomprehensible. what do i need to learn to make these type errors understandable?
23:29:44 <Nereid> you could show us the errors
23:29:53 <Nereid> and the code that causes them, I guess
23:32:26 <vegai> m3ga: if you can split your functions into smaller ones, the errors may become clearer
23:32:31 <m3ga> Nereid: http://hpaste.org/46049/type_errors_from_hell
23:32:36 <vegai> heh
23:32:44 <m3ga> vegai: the functions are already small.
23:33:02 <m3ga> i'm trying to hook up warp with http-enumerator
23:33:04 <vegai> auch.
23:33:40 <m3ga> the poblems start when i add 'request <- mkUpstreamRequest req' to application
23:34:13 <vegai> so what are the types of req and mkUpstreamRequest?
23:34:47 <vegai> oh wait, the type error is coming from the return type
23:35:10 <vegai> but still, answer to my question might be useful
23:35:55 <Nereid> m3ga: so: mkUpstreamRequest req has type Maybe (HE.Request m) for some m
23:36:14 <m3ga> req is a Wai.Request and mkUpstreamRequest is ..... yeah
23:36:17 <vegai> ah, he's not supposed to bind (<-) then
23:36:28 <Nereid> but you're using it inside a DE.Iteratee monad
23:36:52 * vegai pipes down so as not to confuse anymore... 
23:36:58 <Nereid> er, DE.Iteratee Bytestring IO is the monad
23:37:25 <m3ga> I don't really understand 'HE.Request m'
23:37:40 <gli> hi, is anybody here?
23:37:47 <Nereid> no
23:37:50 <m3ga> m seems to be a function * -> * which is .. weird
23:37:56 <Nereid> m3ga: m is a type constructor
23:38:03 <m3ga> ahhhhh!
23:38:16 <Nereid> it's saying "m has kind * -> *"
23:38:16 <gli> I can't create an account on haskell.org
23:38:21 <Nereid> which is allowed by -XKindSignatures
23:38:23 <gli> can anybody help me?
23:38:23 <m3ga> suddenly a little light dawns
23:38:29 <kfish> :-)
23:38:36 <m3ga> kfish!
23:38:46 <gli> error in "recaptcha.js"
23:39:02 <Nereid> try a different browser?
23:39:09 <Nereid> fix your current browser?
23:39:10 <Nereid> I dunno
23:39:18 <gli> ok, I'll try
23:41:03 <gli> thanks, it really work in Safari, while fails in Chrome
23:42:41 <_Ray_> this is ridiculous
23:42:47 <_Ray_> __ : {A : Set}{B : A -> Set}{C : (x : A) -> B x -> Set} (f : {x : A}(y : B x) -> C x y)(g : (x : A) -> B x) (x : A) -> C x (g x)
23:45:33 <ion> Is the symbol really intended to be ?
23:45:53 <_Ray_> \circ, really.
23:45:57 <_Ray_> composition.
23:46:09 <ion> (The masculine ordinal indicator which many fonts render with a horizontal line below it.)
23:46:40 <_Ray_> I felt mixing TeX with Agda would just be inhumane.
23:46:43 <ion> (The counterpart to , the feminine ordinal indicator)
23:47:16 <Nereid> 
23:47:21 <Nereid> 
23:47:53 <ion> 
23:47:59 <seku> :
23:48:21 <_Ray_> _
23:48:28 <ion> Side by side:  (ordinal indicator, degree sign, ring operator)
23:50:27 <_Ray_> Who's oleg?
23:51:07 <seku> how difficult would haskell be without strong maths? I'm not a maths person at all. I understand haskell has some cool way of having data persistence, but would that make it usable as a general purpose language?
23:53:32 <Nereid> haskell is usable as a general purpose language
23:54:00 <Cale> seku: You shouldn't need to know any mathematics to use it, but using it just might make you interested in mathematics.
23:54:05 <Nereid> hehe
23:54:07 <_Ray_> (by which he means programming with categories)
23:54:15 <Nereid> categories are great
23:54:30 <_Ray_> categories are barely a thing
23:54:48 <ion> Haskell is great as a general-purpose language.
23:55:01 <Nereid> yes, that is moreover true.
23:55:37 <ion> (This message may have been slightly biased by my personal opinion.)
23:55:42 <seku> =)
23:55:57 <seku> its #haskell, but i thought that would be best be asked here
23:56:18 <_Ray_> other channels will tell you you need 2 PhDs to write Haskell
23:56:27 <Nereid> I have none :(
23:56:28 <_Ray_> we can tell you the number is closer to sqrt(5)
23:56:30 <Nereid> I guess I'm not qualified
23:56:35 <Nereid> what, that's larger than 2
23:56:56 <ion> ray: And hlint would tell you there are some redundant parentheses.
23:57:00 <_Ray_> indeed. with 2 PhDs, you still have type errors
23:57:18 <Nereid> hlint can eat poo
23:57:31 <ion> Yes, it often does.
23:57:46 <Nereid> lol
