00:04:32 <MittRomney> Mitt Romney has what it takes to turn America around!
00:04:48 <shachaf> ion: Isn't it easier to redefine || , + , > ?
00:04:49 <MittRomney> Mitt Romney saved the Salt Lake City Winter Olympics even though it was heavily indebted!
00:05:15 <MittRomney> As governor of MA, he reformed healthcare and proved universal coverage while preserving the free market system and not implementing Obama death panels!
00:05:24 <MittRomney> Mitt Romney has business and financial sense!
00:05:30 <MittRomney> Vote Mitt Romney for President in 2012!
00:05:50 <shachaf> @where ops
00:05:50 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
00:18:44 --- mode: ChanServ set +o Lemmih
00:18:51 --- mode: Lemmih set +b *!*bddc1939@*.189.220.25.57
00:18:52 --- kick: MittRomney was kicked by Lemmih (MittRomney)
00:19:07 --- mode: Lemmih set -o Lemmih
00:25:25 <wavewave> I wish we had BangBangPattern. :-)
00:28:51 <ski> > (reads :: ReadS Int) "42a"  -- jeffz,(illlogic)
00:28:52 <lambdabot>   [(42,"a")]
00:29:08 <ski> @src ReadS
00:29:09 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:29:19 <ski> bah! an
00:29:39 <ski>   type ReadS a = String -> [(a,String)]
00:36:17 <ion> There seems to be a nice parser for integers in Text.Parsec.Extra
00:38:44 <ion> And another that uses read in ParsecTools.
00:39:00 <jeffz> if there's no sign, many1 digit
00:40:51 <ion> Yeah, i gave let p :: Parser Integer; p = read <$> many1 digit in parse (p <* eof) "" "0123" as an example. Natural numbers consisting of digits only.
00:41:54 <jeffz> hm, ah yes, I seem to use read too.
00:53:20 <ion> let integer = sign <*> natural; natural :: Parser Integer; natural = read <$> many1 digit; sign = option id $ negate <$ char '-' in parse (integer <* eof) "" "-42"
00:53:37 <ion> Still missing *> ;-)
00:56:11 <dankna> http://nopaste.dk/p3173 -- can anyone think of a more natural idiom for this?
00:57:46 <ski>   buildMicrocodeInstruction = flip (foldl (.) id)
00:58:19 <dankna> ah!  thanks :D
01:00:30 <jeffz> @type (<*>) . uncurry
01:00:31 <lambdabot> forall a b a1 b1. (a1 -> b1 -> a -> b) -> ((a1, b1) -> a) -> (a1, b1) -> b
01:12:45 <ski> dankna : hm, sorry, you'll need to `flip' the `(.)' as well
01:13:06 <ski> > foldl (.) id [f,g,h] x :: Expr
01:13:08 <lambdabot>   f (g (h x))
01:13:08 <ski> > foldr (.) id [f,g,h] x :: Expr
01:13:10 <lambdabot>   f (g (h x))
01:13:12 <ski> > foldl (flip (.)) id [f,g,h] x :: Expr
01:13:14 <lambdabot>   h (g (f x))
01:13:16 <ski> > foldr (flip (.)) id [f,g,h] x :: Expr
01:13:17 <lambdabot>  Terminated
01:13:20 <ski> > foldr (flip (.)) id [f,g,h] x :: Expr
01:13:22 <lambdabot>   h (g (f x))
01:13:51 <dankna> ski: hmm yes, okay.  I didn't notice at first because my modifications can mostly be applied in any order.
01:13:57 <shachaf> > foldr (.) id (reverse [f,g,h]) x :: Expr
01:13:59 <lambdabot>   h (g (f x))
01:14:50 <ski> (indeed i was first thinking of `reverse', but then thought `foldl' instead of `foldr' would do as well .. but i forgot that the function argument to `foldl' takes its arguments in the other order)
01:15:52 <ski> cf.
01:15:57 <ski>   (* SML *)
01:16:02 <ski>   val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
01:16:02 <ski>   val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
01:16:27 <dankna> > (\ -> flip foldr (.) id reverse) x [f, g, h]
01:16:28 <lambdabot>   <no location info>: parse error on input `->'
01:16:30 <ski>   (* OCaml *)
01:16:34 <ski>   val fold_left  : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
01:16:34 <ski>   val fold_right : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
01:16:43 <shachaf> ski: There's some sense to having the argument order flipped for foldl.
01:16:58 <ski> i know .. i still often forget it, though
01:17:02 <dankna> > (flip foldr (.) id reverse) x [f, g, h]
01:17:03 <lambdabot>   Couldn't match expected type `[((a -> b) -> f a -> f b)
01:17:03 <lambdabot>                    ...
01:17:18 <ski> (and i'm not sure the reasons for are stronger than the reasons against)
01:17:24 <dankna> > (foldr (.) id . reverse) x [f, g, h]
01:17:25 <lambdabot>   Couldn't match expected type `[b -> b]'
01:17:25 <lambdabot>         against inferred type `Simp...
01:17:33 <dankna> > (foldr (.) id) x [f, g, h]
01:17:34 <lambdabot>   Couldn't match expected type `[b -> b]'
01:17:34 <lambdabot>         against inferred type `Simp...
01:18:00 <shachaf> > foldr f z [a,b,c]
01:18:01 <lambdabot>   f a (f b (f c z))
01:18:07 <shachaf> > foldl f z [a,b,c]
01:18:08 <dankna> > (foldr (flip (.)) id) x [f, g, h]
01:18:08 <lambdabot>   Couldn't match expected type `[a -> a]'
01:18:09 <lambdabot>         against inferred type `Simp...
01:18:09 <lambdabot>   f (f (f z a) b) c
01:18:22 <ski> > foldr ($) x [f,g,h] :: Expr
01:18:23 <lambdabot>   f (g (h x))
01:18:31 <shachaf> > foldl (flip f) z [a,b,c]
01:18:33 <dankna> > (foldr ($) id) x [f, g, h]
01:18:33 <lambdabot>   f c (f b (f a z))
01:18:34 <lambdabot>   Couldn't match expected type `[(a -> a) -> a -> a]'
01:18:34 <lambdabot>         against inferre...
01:18:55 <dankna> > (foldr ($)) x [f, g, h]
01:18:56 <lambdabot>   f (g (h x))
01:19:10 <dankna> > (foldr ($) . reverse) x [f, g, h]
01:19:11 <lambdabot>   Couldn't match expected type `[a]'
01:19:11 <lambdabot>         against inferred type `SimpleRef...
01:19:43 <shachaf> ski: If you want the other argument order, you can always reverse it and then foldr. :-)
01:20:05 <dankna> > (foldr ($)) x (reverse [f, g, h])
01:20:06 <lambdabot>   h (g (f x))
01:20:10 <dankna> there we go haha
01:20:19 <dankna> can't be written pointfree, but it'll do
01:20:19 <ski> the question was about which is the best API
01:20:33 <dankna> yeah, my original question was along the lines of "does anybody know a short, readable way to write this"
01:21:05 <dankna> which has been answered in spades :)
01:21:29 <ski> is there a reason you want `[f,g,h] |-> h . g . f' rather than `[f,g,h] |-> f . g . h' ?
01:21:57 <dankna> there's not a strong one, it just strikes me as more intuitive
01:22:29 <dankna> the list of functions is viewed as a bunch of usually-orthogonal operations to be performed on the base
01:22:38 <dankna> when they are in fact orthogonal, the order doesn't matter at all
01:22:54 <dankna> this is, I'm expecting, all going to be constant-folded out, so the time spent reversing the list is not important
01:24:01 <dankna> it's basically a fancy syntax for describing these microcode instructions, which are actually records with a lot of fields, and would be difficult to read or maintain if written without such a setup
01:24:53 <dankna> for example, alsoIncrementProgramCounter :: MicrocodeInstruction -> MicrocodeInstruction sets a particular field to True
01:25:45 <dankna> the naming there kinda implies that they happen in order
01:26:12 <dankna> I don't know yet whether I'll need non-orthogonal ones or not, so I want to leave that possibility open
01:29:40 <waern> yo
01:33:53 <shachaf> dankna: Surely fusion should turn that into a regular foldl anyway? :-)
01:34:26 <dankna> shachaf: probably, but I wanted it written tersely :)
02:00:48 * hackagebot ListLike 3.1.1 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-3.1.1 (JohnLato)
02:01:57 <desijays> Is it a good idea to explicitly include a function argument header for every function in a program?
02:03:06 <dankna> yes
02:04:57 <osfameron> desijays: people recommend it, as it makes you have to think about what you're writing more.  Also it helps avoid some hard-to-debug errors in compilation sometimes
02:05:39 <dankna> it makes the errors the compiler gives you more meaningful
02:05:49 * osfameron looks back at code he's been writing, and realises he only has types on about quarter of his functions. oops ;-)
02:05:59 <dankna> hehe
02:06:13 <osfameron> it's a 2-edged sword as a haskell newbie
02:06:19 <desijays> hmm.. im just starting out.. so i hope i don't make the same mistake as osfameron :P
02:06:22 <osfameron> on the one hand, you'd benefit from writing the type header
02:06:28 <osfameron> on the other, you often don't know *how* to ;-)
02:06:42 * osfameron finds that it's a good idea to write the function, ask ghci what the type is, and then copy that ;-)
02:06:56 <sipa> or initially start with leaving out the types
02:07:16 <sipa> and after the program is bit more mature (and the types change less), switch to writing them
02:08:14 <osfameron> of course, once most of the core functions have types, you can write other functions that use the core ones quite happily (as the type checker seems to have that much more information to make its type decisions on)
02:09:20 <desijays> I have a function whose function header reads "(Num a) => [a] -> a". Can i use the error statement in such a function? I would suppose you can't since the error statement returns 'a' that does not belong to typeclass "Num a"...
02:09:38 <shachaf> desijays: "a" is more general than "Num a".
02:09:45 <bmh> Are there any plans on improving System.Random.split? I noticed a comment: -- no statistical foundation for this!
02:09:47 <shachaf> desijays: But if you have something which can fail, consider returning Maybe a.
02:10:26 <osfameron> desijays: you can use "error" anywhere, as it's typed in such a way as to handle that
02:10:32 <dankna> bmh: it's a thing... we are none of us number theorists, so while we enjoy having that operation, it isn't one which we can really provide guarantees about
02:10:37 <osfameron> but yes, Maybe is possibly better
02:11:48 <desijays> osfameron: so error is exclusive in this regard compared to other functions that can be defined in a program?
02:12:04 <sipa> desijays: the type or error is:
02:12:05 <sipa> :t error
02:12:06 <shachaf> desijays: Anything with the type "a" can be used as any other type.
02:12:07 <lambdabot> forall a. [Char] -> a
02:12:22 <shachaf> That's what that means.
02:12:22 <osfameron> there's also 'undefined'
02:12:25 <sipa> so the result of error is of any type you like it to
02:12:49 <bmh> dankna: yeah, it is a great operator. Shame more attention hasn't been paid to it in the literature
02:12:53 <osfameron> so you could define your own use-anywhere functions too?
02:12:55 <shachaf> @src undefined
02:12:55 <lambdabot> undefined =  error "Prelude.undefined"
02:13:09 <dankna> bmh: yeah
02:13:12 <desijays> so are you saying in a function with header "[a] -> a" i can do an addition operation?
02:13:17 <shachaf> osfameron: Sure, yourOwn :: a; yourOwn = yourOwn
02:13:32 <shachaf> desijays: No. (Num a) is more specific than "a".
02:14:05 <bmh> dankna: I'm going to do a bit more reading and then maybe I'll e-mail Pierre L'Ecuyer. I noticed he was receptive to talking to the Scheme guys when they were discussing their RNG standard
02:14:13 <osfameron> has anyone got a few minutes to have a look at some code (and associated walkthrough blog post) for me?
02:14:21 <dankna> bmh: oh neat!
02:14:29 <osfameron> it's for a talk on a real world application of haskell, I'm hoping to give next month at a local geekup meeting
02:14:41 <desijays> shachaf: is that because '+' is a function too?
02:14:51 <desijays> does '+' have a type.. lemme check
02:14:52 <dankna> osfameron: well... how much code :)
02:14:54 <bmh> I'm by no means an expert (competent might even be a stretch), but I care a lot about the validity of simulations.
02:15:05 <shachaf> @ty (+)
02:15:06 <lambdabot> forall a. (Num a) => a -> a -> a
02:15:19 <shachaf> osfameron: Is it online somewhere? If so, just post it.
02:15:20 <osfameron> dankna: hehe, very important question, that.  it's 172 lines
02:15:23 <dankna> bmh: absolutely.  the community thanks you (I say as its duly self-appointed representative ^_^) for taking this initiative.
02:15:28 <dankna> osfameron: sure, nopaste it at me :)
02:15:31 <shachaf> If not, put it online somewhere. And then just post it.
02:15:33 <osfameron> dankna, shachaf: https://github.com/osfameron/geekup-talk-haskell/blob/master/quiz.hs 
02:15:46 <osfameron> and the walkthrough is at https://github.com/osfameron/geekup-talk-haskell/blob/master/walkthrough
02:17:06 <dankna> reading now
02:17:34 <osfameron> thanks ;-)
02:20:00 <dankna> osfameron: it looks like an appropriate amount of material and about the right complexity for a beginner
02:20:09 <dankna> as you comment, it's unfortunate that it's so tied to the console
02:20:15 <dankna> did you have specific questions?
02:20:49 <osfameron> dankna: mostly just wanting sanity check.  I don't want to give a talk and later realise I've put material on the web with howling errors, or horrible counter-examples
02:20:58 <dankna> ahh, yeah.  it checks sane :)
02:21:07 <osfameron> great, thanks!
02:21:16 <dankna> I would put type signatures on everything
02:21:31 <dankna> a convention which I made up myself and which probably nobody else uses, but hey, it doesn't hurt to mention it,
02:21:54 <dankna> is that names starting with "get" are for functions which compute a value in a monad
02:22:07 <dankna> if I feel the need for a verb at the start of the name and it's not in a monad, I use "compute"
02:22:24 <osfameron> interesting.  I almost feel like "compute" should be the monadic version ;-)
02:22:26 <dankna> so for example getMultiChoices I would have called computeMultiChoices, following that convention, and similarly getCorrect
02:22:31 <dankna> well, choose your own convention of course
02:22:41 <osfameron> (mostly because, iirc, F# uses "computation" instead of Monad)
02:22:45 <dankna> I see
02:22:56 <dankna> I feel like "computing" something is a pure, well, computation
02:23:04 <dankna> whereas "getting" it is something monad-ish
02:23:05 <osfameron> I think you're right though that my naming is all over the place
02:23:17 <dankna> yeah - but the good thing is, that's an easy fix
02:23:22 <osfameron> for example, I didn't know how to name the record type accessors
02:23:31 <dankna> ah yes, so I see
02:23:36 <dankna> I personally use the convention
02:23:58 <dankna> data FancyRecord = FancyRecord { fancyRecordAlpha :: Blah, fancyRecordBeta :: Blargh }
02:24:16 <dankna> where Alpha and Beta are the names I want to give to the fields, but I've prepended the name of the record itself onto them
02:24:18 <dankna> this is very verbose
02:24:26 <dankna> and it is surely tempting to leave the record name off
02:24:30 <dankna> but it avoids conflicts
02:24:34 <osfameron> yeah, I think that's what I'll do.  It seems klunky, but probably best
02:24:46 <dankna> the most common conflict being the word "name", which is a field that very many record types want to have
02:24:48 <osfameron> it's one of those cases where the OO convention is neater
02:24:54 <dankna> yes
02:26:02 * osfameron will probably come back in a few weeks with some questions about those TODOs (extracting the console, and persistence)
02:26:07 <dankna> no problem :)
02:33:09 <fenfrie> when i have a new data type: data foo = foo {one :: String, two :: String} and i make x = foo "a" "b" how can i access the different single strings?
02:33:43 <sipa> both foo's will need to be uppercase
02:34:06 <sipa> and you can just access them with 'one x' and 'two x'
02:35:53 <fenfrie> sipa, thx this was what i need, i know the uppercase this was a small error in this example
03:04:03 * hackagebot iteratee-compress 0.2.0.0 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.2.0.0 (MaciejPiechotka)
03:06:54 <alpounet> interesting.
03:07:04 <dankna> I agree!  What is?
03:09:26 <alpounet> dankna, iteratee-compress
03:09:32 <dankna> oh, yeah, neat
03:10:09 <alpounet> too bad i hear about it now, i would have needed it a few months back
03:10:15 * dankna nods
03:28:02 <osfameron> does the Haskell Platform not give a command-line version of hoogle?
03:28:20 <huangyi> hi, i try to build brians-brain (https://github.com/willdonnelly/brians-brain/), but found there is no `parArr` in new version of parallal library.
03:30:49 <dcoutts> osfameron: it's not included, but you can just cabal install it
03:31:42 <huangyi> Does anyone known where is `parArr` now?
03:31:56 <osfameron> dcoutts: aha, shiny.
03:35:28 <shachaf> @hoogle parArr
03:35:28 <lambdabot> Control.Parallel.Strategies parArr :: Ix b => Strategy a -> Strategy (Array b a)
03:35:56 <huangyi> It's not in parallel-3.1.0.1
03:36:19 * osfameron wonders why hoogle isn't in the Platform default distro, it's a kickass feature
03:37:20 <dcoutts> osfameron: it depends on about a dozen libraries that are not in the platform
03:37:55 <dankna> hey - weird question - does anyone here play World of Warcraft?  I need a favor which requires a measure of trust, and it occurs to me that being a channel regular is probably a sufficient condition for the trust in question :)
03:38:46 <dankna> I suspect the answer is "no, we spend our time being productive" but hey, doesn't hurt to ask
03:39:21 <huangyi> @hoogle parArr
03:39:21 <lambdabot> Control.Parallel.Strategies parArr :: Ix b => Strategy a -> Strategy (Array b a)
03:39:34 <shachaf> dankna: People in this channel? Being productive?
03:39:47 <dankna> haha
03:39:54 <dankna> well, by relative measures
03:40:31 <shachaf> I suppose there's a continuüm, yes. With World of Warcraft at one extreme.
03:42:13 <dankna> quite so.
03:42:19 <dankna> and Java probably at the other.
03:42:51 <shachaf> Java people are the most productive?
03:43:23 <Ke> !
03:48:24 <dankna> by society's measure, at least?
03:53:07 <skurt> Hello
03:53:10 <skurt> I have a problem
03:53:25 <skurt> I'm trying to edit this code
03:53:33 <skurt> http://www.mail-archive.com/haskell-cafe@haskell.org/msg62222.html
03:53:57 <skurt> to work with double numbers
03:54:06 <skurt> and to return double type
03:54:19 <skurt> can someone please help me out?
03:55:18 <skurt> because this code work with div instead of proper division
03:55:44 <skurt> "10/3" => 3
03:56:38 <FauxFaux> skurt: Do you have a specific question?
04:10:11 <qwr> s.div./. ?
04:12:08 <qwr> Integer type and natural combinator would need also to be replaced...
04:14:23 <qwr> (with Double and float)
05:18:30 <skurt> FauxFaux: I do. The question is: How to do it?
05:19:11 <skurt> I cant see, how does it word
05:19:13 <skurt> work
05:19:31 <skurt> It should work with Strings and return String as wel
05:19:32 <skurt> well
05:19:33 <skurt> but
05:19:54 <skurt> It returns Integer
05:20:10 <skurt> I don't know why and I don't know where is it defined
05:20:42 <Lemmih> Where what is defined?
05:21:03 <skurt> because something like parse (do {x<-many1 digit; return (Show x :: Int)}) should work
05:21:17 <skurt> but there is no such thing
05:21:46 <skurt> Lemmih: The type change
05:22:00 <Lemmih> skurt: I'd love to help but I don't understand your problem.
05:22:20 <Lemmih> skurt: Try to make it work on Integer first.
05:22:26 <skurt> http://www.mail-archive.com/haskell-cafe@haskell.org/msg62222.html
05:22:33 <skurt> it works on integer
05:22:36 <skurt> as it is
05:22:49 <skurt> but I want it to work with double
05:23:00 <skurt> on the input and output
05:23:07 <Lemmih> skurt: Change the type to Double, then.
05:23:21 <skurt> Lemmih: yeah...but where?
05:23:26 <Lemmih> skurt: Everywhere.
05:23:39 <skurt> Lemmih: which means?
05:23:46 <Lemmih> skurt: s/Integer/Double/g, s/(div)/(/)/g.
05:24:03 <Lemmih> skurt: If you see 'Integer', remove it and write 'Double' instead.
05:24:36 <litb> hm, haskell...
05:24:45 <skurt> Lemmih: I can understan vim substitution commands, I just cant undertand Haskell
05:24:48 <skurt> :)
05:25:28 <Lemmih> skurt: I'm not sure what's to understand.
05:26:37 <skurt> Lemmih: Yeah, me too
05:26:43 <skurt> anyway
05:26:44 <Lemmih> skurt: Like this: 'expr :: Parser Integer'. It should be 'expr :: Parser Double'.
05:26:48 <skurt> it is not enough
05:26:57 <skurt> ah
05:27:06 <Lemmih> skurt: You also need to change 'div' to '(/)'.
05:27:24 <skurt> all right
05:27:27 <Lemmih> skurt: You can also just delete the type signature for 'expr' if you feel like it.
05:27:34 <skurt> that does make two changes
05:27:36 <skurt> right?
05:27:39 <Lemmih> Right.
05:27:39 <skurt> I made them
05:27:44 <Lemmih> Then it should work.
05:28:20 <skurt> nope
05:28:30 <skurt> Ill paste what I have at the moment
05:28:34 <Lemmih> skurt: How doesn't it work?
05:28:49 <Lemmih> skurt: Does it fail to compile? Does it fail to run? Does it give you the wrong answer?
05:29:06 <skurt> :r in ghci fails
05:29:29 <Lemmih> skurt: Okay, so it fails to compile. What error message does it give you?
05:30:20 <Lemmih> skurt: It's okay to copy&paste small error messages.
05:31:20 <skurt> http://pastie.org/1825329
05:31:51 <Lemmih> skurt: It should be '(/)'.
05:32:00 <skurt> (/)
05:32:04 <skurt> or '(/)'
05:32:13 <skurt> first one, right?
05:32:14 <Lemmih> Former.
05:32:18 <Lemmih> Right.
05:32:52 <skurt> changed
05:32:57 <skurt> still doesnt work
05:32:58 <Lemmih> skurt: Like with (-), (+) and (*).
05:33:16 <Lemmih> skurt: Does it fail to compile? Does it fail to run? Does it give you the wrong answer?
05:33:36 <skurt> line 46:
05:33:37 <skurt> ,[op "*" (*) AssocLeft, op "/" (/) AssocLeft]
05:34:00 <skurt> still the same problem...which I think is 'fail to compile'
05:36:07 <skurt> What I would do is
05:36:14 <Lemmih> Ah, I see the problem.
05:36:42 <skurt> ok, I'm one big ear
05:37:10 <Lemmih> 'natural' gives you an Integer.
05:37:34 <skurt> I thought so
05:37:41 <skurt> so I added dbl
05:37:50 <skurt> but I don't know if its right
05:38:00 <Lemmih> skurt: Change 'natural' to 'P.float lexer' and you're golden.
05:38:25 <skurt> line 33: dbl = P.float lexer
05:38:40 <Lemmih> skurt: That's good, too.
05:38:46 <skurt> so it should be the same to use dbl...
05:38:46 <skurt> ok
05:39:09 <Lemmih> skurt: Note that you probably want to extend 'factor' to parse BOTH naturals and floats.
05:39:26 <skurt> Lemmih: youre clever :)
05:39:36 <Lemmih> skurt: If you replace 'natural' with 'dbl' then it'll only parse stuff like '12.42' and not '12'.
05:39:43 <skurt> ok, I'll take a look into it
05:40:36 <skurt> thats why I shouldnt CHANGE "factor = natural" to "factor = dbl"
05:40:38 <skurt> but
05:41:08 <skurt> ADD "dbl <|>"
05:41:09 <Lemmih> skurt: 'fromIntegral' can take an Integer and give you a Double.
05:41:47 <Lemmih> skurt: Haskell won't convert the Integer to a Double automatically. We have to do it ourself.
05:42:26 <Lemmih> skurt: So we need something like this: do integer <- natural; return (fromIntegral integer)
05:42:43 <vitka> > fromIntegral 3 :: Double
05:42:44 <lambdabot>   3.0
05:43:22 <skurt> vitka: I know that one
05:43:27 <hpc> that's also fromIntegral <$> natural
05:43:51 <hpc> so 'dbl <|> fmap fromIntegral natural'
05:43:57 <Lemmih> hpc: I was deliberately trying to keep things simple. (:
05:44:01 <hpc> :)
05:44:11 <skurt> Im out
05:44:18 <Lemmih> skurt: You're not quite done.
05:44:22 <skurt> If I got it right
05:44:37 <skurt> now the problem is in factor
05:44:46 <Lemmih> skurt: You also need a 'try' before the 'dbl'.
05:45:12 <Lemmih> skurt: All in all: try dbl <|> fmap fromIntegral natural.
05:45:18 <skurt> because theres returntype Double <|> returntype Integer
05:45:47 <Lemmih> skurt: No, it has to do with way parsec works.
05:45:48 <skurt> which is in my opinion imposible, because parens cant return any of that...
05:46:09 <skurt> sorry for mistakes, writing on slow connection and cant see the writing :/
05:47:11 <skurt> Lemmih: dbl <|> fmap fromIntegral natural solves the problem with NOTparsing natural nubers...which is not important at the moment
05:50:42 <skurt> well
05:52:01 <skurt> can you please try to tell me how the fix the bug which makes it impossible to compile? Ill add the code you told me right then
05:52:51 <Lemmih> skurt: factor = try dbl <|> fmap fromIntegral natural <|> parens expr
05:52:54 <skurt> I just dont see the point in adding features to the code which doesn't work
05:53:28 <Lemmih> skurt: I have no idea what features you're referring to.
05:53:48 <skurt> I really dont understand the code
05:53:48 <skurt> but
05:53:59 <skurt> I am pretty sure, that I have a bug
05:54:08 <Lemmih> skurt: Is this homework?
05:54:21 <Lemmih> The code works fine for me.
05:54:31 <skurt> kind of
05:54:41 <skurt> Lemmih: all right, Ill try
05:55:00 <Lemmih> Did I tell you change '(^)' for '(**)'?
05:55:48 <skurt> No
05:55:52 <skurt> Ill paste again
05:56:01 <skurt> the code cant be compiles
05:56:02 <Lemmih> Change '(^)' for '(**)'. (:
05:56:04 <skurt> cimpiled
05:56:40 <skurt> wowo
05:56:47 <skurt> it went through
05:56:54 <skurt> Ill =O
05:56:56 <skurt> =O
05:57:01 <skurt> Ill try it
05:57:20 <skurt> and if if works, Ill buy you chocolate :)
05:57:25 <skurt> where are you from?
05:57:26 <skurt> :-D
05:58:04 <Lemmih> You can buy me a beer next time you're in Denmark (:
05:58:55 <skurt> Really? Like four of my roommates are in Denmark at the moment :)
05:59:43 <Lemmih> Kewl. On vacation or studying?
06:00:23 <skurt> vacation
06:00:33 <skurt> just for a couple of days
06:02:48 <skurt> which city?
06:04:36 <Lemmih> Copenhagen.
06:05:11 <Lemmih> The city of cities. The rest of Denmark is too depressing for anyone to live there.
06:09:22 <skurt> Copenhagen? :)
06:09:32 <skurt> Are you football fan?
06:12:27 <Lemmih> Not overly so. I have been to the stadium a couple of times, though.
06:13:05 <skurt> Lemmih: Might be cool
06:14:32 <skurt> wel, the code works nice
06:14:39 <skurt> well
06:14:54 <skurt> still few details, but thanks anyway :)
06:17:26 <skurt> wow, I see a function called naturalOrFloat
06:17:28 <skurt> :)
06:17:42 <skurt> It probably does the same thing don't it :)
06:19:34 <physicist> Any physicist out here (except) me?
06:21:02 <Ke> no, we are all chemists
06:22:27 <physicist> so bad
06:23:32 <physicist> but still some ideas about some interesting project related to physics in Haskell for summer 
06:26:04 <Ke> dsl for solving differential equations on opencl!
06:27:16 <physicist> I don't even know about opencl, what I want is something not too advanced
06:35:38 <adamvh> physicist: yup
06:36:29 <adamvh> physicist: It's not directly related to physics, but the repa library could really use a few additions
06:36:54 <adamvh> physicist: I've been thinking about doing it myself
06:37:31 <physicist> adamvh: so what physics related stuff you have used haskell for
06:37:55 <adamvh> I wrote a 1-D neutron transport solver in Haskell to orient myself
06:38:31 <adamvh> I will probably use it for some numerical simulations about quasar radiation spectra in the near future
06:38:45 <physicist> cool
06:38:50 <adamvh> Although SciPy is making that decision a difficult one
06:39:36 <adamvh> and my professor thinks I should do it in C
06:39:36 <adamvh> heh
06:39:53 <Tomsik> Do it in APL.
06:40:01 <Tomsik> I dare you.
06:40:01 <physicist> I think you should do it in Haskell
06:40:22 <physicist> even if it involves a bit of extra work
06:40:25 <Ke> OpenCL&haskell
06:40:27 <adamvh> Oh God.  APL.
06:40:49 <adamvh> Ke: How good are the OpenCL bindings for Haskell?
06:41:24 <physicist> I think haskell code can look much more normal physics notation
06:41:24 <adamvh> I saw a presentation about Obsidian on the NVidia side, but I don't think I ever even found the source code to try it out
06:41:25 <Ke> mostly raw bindings afaik
06:42:19 <Ke> obsidian too, not sure if it is easier
06:43:00 <adamvh> physicist: It all depends on how many library functions I'm going to need.  If I'm going to be doing a lot of integration, interpolation, and root finding it's kind of irresponsible not to use a toolkit like SciPy
06:43:15 <adamvh> physicist: Although GSL via Haskell is definitely an option
06:43:44 <physicist> adamvh: can you share your code
06:44:00 <physicist> I think it would be interesting to have a look
06:44:16 <adamvh> I suppose I could put the neutron transport solver on github
06:44:31 <adamvh> I don't think it's particular idiomatic Haskell
06:44:47 <adamvh> Or all that high-performance Haskell, either
06:46:10 <adamvh> An example type signature:
06:46:11 <adamvh> http://www.westeros.org/Citadel/FAQ/Entry/1999/
06:46:14 <physicist> even then it would be nice. I am quite a starter and haven't really done anything but Project Euler on haskell
06:46:17 <adamvh> no, not that
06:46:27 <adamvh> march :: [(Double, Double, Double, Double)] -> [Double] -> ([Double], [Double], (Double -> Double -> Double -> Double)) -> Direction -> [Double] -> ([Double],[Double])
06:46:39 <adamvh> I feel like I'm not using the type system to the best of its ability here
06:47:04 <adamvh> Yeah, I'll just make sure it's in a state where it actually compiles and then throw it on github so you can look at it
06:49:16 <McManiaC> the installation of unix-compat fails with "* Missing header file: HsUnixCompat.h"
06:49:20 <McManiaC> any ideas how to install this?
06:49:35 <McManiaC> it should be included in the package afaik
06:50:52 <physicist> yup it does feel a bit scary but maybe it might be fun to wrestle with it
06:51:31 <physicist> adamvh: have you used H-matrix?
06:51:45 <adamvh> No, unfortunately
06:52:08 <adamvh> My 1-D neutron transport solver is all lists
06:52:36 <Ke> 1D is typically not a problem
06:52:52 * hackagebot epub-tools 1.0.0.0 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-1.0.0.0 (DinoMorelli)
06:53:42 <physicist> even if I-D is not a problem in physics it has many of the extremely interesting problems
06:55:05 <physicist> Today I finally managed to get a vpn to bypass my university's proxy settings and even now cabal does not seem to work
06:55:29 <physicist> first it used to complain about proxy now cabal update is timing out
06:58:00 <djanatyn> Haha, cycle is awesome :)
06:58:16 <djanatyn> I'm really starting to love Haskell more every day.
06:58:34 <sm> morning
06:59:14 <sipa> :t cycle
06:59:16 <lambdabot> forall a. [a] -> [a]
06:59:39 <djanatyn> set comprehensions are awesome too :)
06:59:54 <DRMacIver> Pity Haskell doesn't have them. :)
07:00:06 <djanatyn> oh, yeah :)
07:01:20 <djanatyn> making "if" an expression is crazy.
07:01:37 <djanatyn> I can't get over how you can generate a list to contain practically anything you want with minimal code.
07:01:41 <djanatyn> Haskell is so cool :3
07:01:55 <beastaugh> <djanatyn> making "if" an expression is crazy.
07:01:59 <beastaugh> it's quite common
07:02:07 <physicist> can someone help me with cabal update timeout erroe
07:02:08 <beastaugh> usually under the guise of a ternary operator
07:02:12 <physicist> i meant error
07:02:30 <beastaugh> cond ? opt1 : opt2
07:02:35 <djanatyn> ghci is my new favorite calculator :)
07:02:51 <physicist> djanatyn: mine too
07:03:09 <beastaugh> I use ghci to calculate my tax returns
07:03:20 <sm> beastaugh: how so ?
07:04:02 <beastaugh> sm: sorry, I'm not clear what you're asking
07:04:05 <djanatyn> I used the clisp interpreter as a calculator for a little while
07:04:23 <djanatyn> Is everything a list in Haskell?
07:04:33 <ion> no
07:04:44 <sm> I'm just interested in your process when calculating tax returns
07:05:11 <physicist> djanatyn: i like to think that everything is a function in haskell 
07:05:15 <physicist> even lists
07:05:22 <beastaugh> oh, just basic arithmetic, adding expenses up and so on
07:05:24 <ion> Not that either.
07:05:29 <beastaugh> my tax return is not terribly complicated :)
07:05:53 <beastaugh> but I spend so much time in the command line I find it's simpler than using a calculator
07:05:54 <ion> What parameter do you apply a list to?
07:06:02 <djanatyn> hmmmm...
07:06:08 <djanatyn> is there a haskell interpreter for Android?
07:06:14 <sm> ok. I write haskell financial software, so always interested in how folks do it
07:06:16 <physicist> there a functions without a parameter
07:06:33 <djanatyn> didn't think so ;)
07:06:40 <adamvh> physicist: http://hpaste.org/45972/1d_neutron_transport
07:06:45 <parcs> physicist: what is your definition of a function..?
07:06:47 <beastaugh> oh yes, hledger
07:06:54 <beastaugh> I've been thinking about using that
07:06:56 <adamvh> It doesn't, strictly speaking, work at the moment
07:06:56 <ion> In Haskell, a function is a value of type a → b.
07:07:08 <physicist> then its not
07:07:10 <physicist> agreed
07:07:14 <adamvh> but it compiles and it did *used* to work
07:07:17 <beastaugh> if my financial life becomes more complex I may give it a shot :)
07:07:28 <djanatyn> Ooh. hledger has a sexy website.
07:07:56 <physicist> I like to think function is something not stateful
07:08:02 <sm> beastaugh: yup. That's what I use for my tax calculations. Specifically I use it for adding up income and expense categories to send to my accountant who turns them into a tax return
07:08:23 <djanatyn> The screenshot page also hijacks my back keycombo in that little lightbox thingy :)
07:08:23 <sm> djahandarie: thanks for calling it sexy :)
07:08:43 <djanatyn> Oh, I see, it's just grabbing the arrow key
07:08:55 <djanatyn> alt-left is bound to back by default in FF4
07:09:21 <djanatyn> Wow. hledger looks pretty cool.
07:10:58 <sm> djanatyn: fresh off the grill! try it out!
07:11:01 <parcs> is there a functional difference between hledger and ledger?
07:11:09 <physicist> adamvh: now do one other thing send me some reference for understanding the theory behind it
07:12:04 <sm> parcs: here's the medium answer leading to a longer one: http://hledger.org/MANUAL.html#frequently-asked-questions
07:13:17 <sm> I'm still working on a short one. hledger and ledger have a different mix of features, but the basic functionality and data format is very much the same
07:28:19 <djanatyn> I think I'm going to try some of the Project Euler problems with my new Haskell knowledge.
07:31:01 <cheater99> NEW!! Haskell knowledge?
07:31:53 <djanatyn> Well, new for me :)
07:32:07 <cheater99> :)
07:32:14 <cheater99> sounds like fun
07:42:04 <djanatyn> sum [if mod x 5 == 0 || mod x 3 == 0 then x else 0 | x <- [1..1000]]
07:42:12 <djanatyn> will that find the sum of all multiples of 3 or 5 under 1000?
07:43:00 <parcs> up to 1000, yeah
07:43:07 <Zao> > [1..3]
07:43:08 <lambdabot>   [1,2,3]
07:43:37 <Zao> djanatyn: Note that your predicate would be cleaner if put in the generator part of the comprehension.
07:43:42 <parcs> > sum [ if mod x 5 == 0 || mod x 3 == 0 then x else 0 | x <- [1..1000]]
07:43:43 <lambdabot>   234168
07:44:30 <burp> > sum [ x | x <- [1..1000], (mod x 5 == 0 || mod x 3 == 0)]
07:44:31 <lambdabot>   234168
07:45:21 <Zao> > length [ if mod x 5 == 0 || mod x 3 == 0 then x else 0 | x <- [1..1000]]
07:45:22 <lambdabot>   1000
07:45:27 <Zao> > length [ x | x <- [1..1000], (mod x 5 == 0 || mod x 3 == 0)]
07:45:28 <lambdabot>   467
07:45:34 <burp> hehe
07:45:34 <Zao> Yay, efficiency :D
07:47:28 <burp> hmm
07:47:40 <vitka> I wrote a bruteforce solution to Euler 308, but it's way too slow.
07:48:21 <vitka> And I have no idea how to do it otherwise :P
07:48:34 <burp> vitka: do you want a solution?
07:48:46 <Zao> I haven't touched Eulers since I got 100 solutions.
07:48:56 <Zao> Please do not tempt me to start again :D
07:48:59 <burp> (all project euler solutions are on the haskell wiki)
07:49:24 <vitka> Nope.
07:49:28 <burp> not 308?
07:50:02 <vitka> I want to do it myself someday.
07:50:03 <burp> hm true, just up to 200
07:52:03 <dolio> > 136/68
07:52:03 <lambdabot>   2.0
07:52:18 <dolio> > 544/68
07:52:19 <lambdabot>   8.0
07:55:17 <dolio> vitka: Look for patterns of how many intermediate values there are between small primes.
07:55:43 <djanatyn> umm o_O
07:55:48 <dolio> Then extend the pattern, prove that it's correct, and compute the answer using that.
07:55:54 <djanatyn> project euler keeps telling me that my solution is incorrect :\
07:56:03 <djanatyn> I don't see how it could be incorrect, it seems to check out okay to me.
07:56:05 <zong_sharo> Lemmih: hi, i got some compilation issues with acid-state, can you please help? http://paste.pocoo.org/show/376877/
07:56:18 <djanatyn> 234168 is the result I got from running that code, and it looks like functorbot got the same result
07:56:40 <vitka> Tried to do it with iteration count, but not with distance between primes. I'll try it that way.
07:56:45 <djanatyn> Project Euler #1 asks: "Find the sum of all multiples of 3 or 5 below 1000."
07:57:00 <djanatyn> Shouldn't 234168 be the answer?
07:57:11 <vitka> No. :P
07:57:16 <dolio> djanatyn: Are you counting things twice?
07:57:18 <djanatyn> Oh. -_-
07:57:48 <burp> > last [ x | x <- [1..1000], (mod x 5 == 0 || mod x 3 == 0)]
07:57:49 <lambdabot>   1000
07:58:17 <djanatyn> Uhh, I don't think so. I used || so it should execute if either or both of the statements are true
07:58:28 <dolio> Okay.
07:58:40 <burp> djanatyn: what about "below"?
07:58:44 <dolio> Is 1000 in your list?
07:58:48 <djanatyn> oh -_-
07:58:59 <djanatyn> :D thanks
07:59:09 <djanatyn> I guess I'll have to pay more attention to the questions.
07:59:10 <burp> <parcs> up to 1000, yeah
07:59:12 <burp> :P
07:59:50 <Lemmih> zong_sharo: The released version doesn't work with ghc < 7. You can either get the darcs version, fix the error by hand or wait for the next release.
08:00:25 <zong_sharo> Lemmih: does darcs version works with ghc < 7
08:00:29 <zong_sharo> ?
08:00:42 <Lemmih> zong_sharo: Yes.
08:01:08 <zong_sharo> okay, thank you
08:01:14 <Lemmih> zong_sharo: But the darcs version requires the development version of cereal.
08:01:42 <zong_sharo> Oh
08:02:02 <Lemmih> zong_sharo: That's why I haven't released a new version of acid-state yet.
08:03:29 <Lemmih> zong_sharo: Actually, this is unacceptable. I will make a patch level release. Hold on.
08:03:53 <saati> where can i find documentation about operators? i'm currently interested in $! and google is not too useful
08:04:10 <FUZxxl> saati: Try hoogle
08:04:12 <parcs> google "google"
08:04:16 <parcs> hoogle*
08:04:17 <Lemmih> [3~ ?src $!
08:04:24 <Lemmih> ?src $!
08:04:25 <lambdabot> f $! x = x `seq` f x
08:04:36 <Lemmih> saati: Operators are just regular functions.
08:05:11 <saati> FUZxxl, parcs thanks
08:05:18 <saati> Lemmih: i know about that
08:05:48 <zong_sharo> Lemmih: well, simple worker :: Event st -> MethodContainer st worked for me, but i will appreciate official fix 
08:07:12 <saati> why is x `seq` f x preferable to seq x $ f x ?
08:07:20 * hackagebot acid-state 0.3.3 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.3.3 (DavidHimmelstrup)
08:07:24 <Tomsik> saati: inlining AFAIK
08:08:08 <monochrom> f $! x is preferable to both
08:08:37 <zong_sharo> Lemmih: thanks
08:08:57 <Lemmih> saati: Style. The end result is the same.
08:09:53 <Tomsik> @src ($!)
08:09:53 <lambdabot> f $! x = x `seq` f x
08:10:00 <Tomsik> @where ($!)
08:10:01 <lambdabot> I know nothing about ($!).
08:10:36 <Lemmih> zong_sharo: Let me know if you have any problems and/or comments.
08:14:06 * osfameron contemplates Happstack versus Yesod
08:14:53 <rostayob> osfameron: happstack!
08:15:30 * osfameron sees several others on http://www.haskell.org/haskellwiki/Web/Frameworks of course, but those are a) the ones I've heard of and/or read about on planet haskell ;-)
08:15:39 <osfameron> rostayob: you using it in anger?
08:16:27 <rostayob> osfameron: well I'm using it and I like it.
08:17:25 <rostayob> i like it more than the competition anyway
08:18:15 <osfameron> rostayob: cool.  do you use the Happstack.State stuff?
08:20:01 <osfameron> I like that happstack doesn't tie you to a templating language
08:20:21 <osfameron> because much as Blaze looks like cute, I'm damned if I'm going to use a combinator library to generate HTML
08:20:35 <rostayob> osfameron: no, I don't, for various reasons
08:21:05 <osfameron> (if I can't get frontend devs to edit my HTML templates, I rapidly become a very unhappy osfameron)
08:21:14 <rostayob> osfameron: well hsp is one of the main reason for me to use happstack
08:21:16 <Lemmih> rostayob: Might I inquire to said reasons?
08:21:59 <osfameron> rostayob: that incorporates an XML-like syntax into your haskell code?
08:22:42 <rostayob> Lemmih: it's what we were talking about the other day (mainly no efficient sorting)
08:22:50 <rostayob> osfameron: yes
08:23:36 <osfameron> rostayob: doesn't that make it harder to foist all the frontend stuff to a dedicated frontend dev?
08:24:18 <rostayob> osfameron: it definitely does, but I'm both the backend dev and frontend dev in my personal projects :P
08:24:30 <rostayob> I'd use heist if I was working with a designer
08:24:37 <osfameron> rostayob: yeah, I can see it working in some setups ;-)
08:24:47 * osfameron looks at heist
08:25:55 <osfameron> well, /me finishes looking at MACID first
08:25:59 * Lemmih is using heist+json but would really like xslt through heist.
08:26:13 <osfameron> the example linked to seems a little in depth
08:26:42 <Lemmih> osfameron: I'd love to explain it in great detail if you're interested (:
08:27:57 <rostayob> happstack-state is really nice. if I could efficiently sort things, I'd certainly use it
08:28:11 <osfameron> Lemmih: thanks :-)  I'm just in Very General Overview phase at the moment
08:28:32 <osfameron> mostly just noting that I don't think it's a very good choice of *first* example to link to, I'm sure it's a very good article
08:28:43 * osfameron adds it to instapaper
08:29:07 <Lemmih> osfameron: Btw, acid-state is the new happstack-state.
08:29:08 * osfameron wouldn't want to do everything in a memory hash anyway
08:29:38 <osfameron> Lemmih: oh?  either I'm confused or the docs on the project page need a little gardening
08:30:18 <rostayob> osfameron: acid-state is not the "official" state yet, but it will be soon
08:30:19 * osfameron would probably model long-term data in SQL, and have things like records-in-progress held in memory.  or something like that
08:30:23 * zmv senses XML bloat.
08:30:26 <osfameron> OIC
08:34:59 <osfameron> Heist looks very much like what I'm used to
08:35:07 <osfameron> i.e. it's at least what I *think* I want ;-)
08:36:33 <zmv> heist reminds me of heißt
08:36:47 <rostayob> osfameron: heist is very nice. but hsp is way more fun
08:37:00 <rostayob> and safer
08:37:22 <osfameron> rostayob: it's *far* safer if I can make a webmonkey edit HTML than if I have to do it
08:37:37 <rostayob> osfameron: yeah yeah I see that issue (:
08:37:59 <osfameron> and, even for personal projects, I know that if I have code that generates HTML, I tend to get into a terrible mess
08:38:45 <rostayob> that's true as well, you have to have self control.
08:38:46 <stepkut> I feel like in my projects almost all the content in the screen is coming out of databases and hence is 'generated'..
08:40:10 <rostayob> osfameron: in the end hsp works very nicely for me anyway. I think we're scared of html generating stuff because we don't do it in haskell generally
08:41:00 <osfameron> rostayob: and because we saw how well it worked in Perl with CGI.pm html generation...
08:42:11 <rostayob> osfameron: never tried that :P. never tried Perl actually
08:42:33 <osfameron> rostayob: my day job ;-)
08:42:45 <osfameron> dammit, happstack tutorial doesn't have a "single html file" view?
08:43:01 * osfameron has been spending most of last two days munging various documents into Kindle format ;-)
08:43:05 <osfameron> pesky new toys
08:49:32 <rostayob> osfameron: anyway, there's #happs for your happstack questions (:
08:50:11 <osfameron> ah cool, I'll pop in later, once I've actually got beyond glancing at docs ;-)
08:50:12 <osfameron> thanks
08:50:33 <stepkut> rostayob: but asking happstack questions here helps promote happstack ;)
08:52:17 <rostayob> eheh true
08:56:00 <ScurvyBraces> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html - Adding Semantics
08:56:16 <ScurvyBraces> i am a bit confused by this
09:25:30 <rostayob> @pl \q -> (>>= fromBson) <$> findOne q
09:25:30 <lambdabot> ((fromBson =<<) <$>) . findOne
09:32:07 <stepkut> bos: what are the chances of Text switching to utf8 internally ?
09:32:55 <dolio> I hear there's a summer of code project for that.
09:33:04 <copumpkin> or an app
09:33:12 <stepkut> dolio: an accepted one? 
09:33:20 <dolio> I think so.
09:34:06 <stepkut> neat. I will pretend that is going to happen and use it to reaffirm my decision to serialize Text as utf8
09:36:05 <Heffalump> acceptedness or otherwise is not yet announced
09:36:40 <stepkut> hmm. applied for at least then?
09:36:43 <Heffalump> yes
09:36:57 <Heffalump> also, the switch would be conditional on the benchmarks showing it to be worth it
09:37:23 <Heffalump> the gsoc announcement is tomorrow I believe
09:38:34 <stepkut> those sound like tricky benchmarks to write
09:38:53 <stepkut> because it is not obvious what cases are the right ones to measure
09:41:41 <cdsmithus-mobile> Indeed.  IIRC the benchmarking for pure manipulation of existing Text values had UTF-16 coming out slightly ahead.  But everyone knows that UTF-8 will win when interacting with external systems that want UTF-8.  So the question is what is the right balance of those operations to base implementation decisions on
09:48:47 <rothwell> what's Text use right now?
09:49:04 <cdsmithus-mobile> UTF16 internally, I believe
09:49:08 <rothwell> right
09:52:11 <ChongLi> is there any function like floor/ceiling/round/truncate that returns a Fractional instead of an Integral?
09:52:35 <ChongLi> i.e. floor' 1.2 == 1.0
09:53:28 <Tomsik> fromInteger . floor
09:53:33 <Tomsik> I guess
09:53:39 <ChongLi> yeah, but that is too slow
09:56:36 <Eduard_Munteanu> :t fromInteger
09:56:36 <lambdabot> forall a. (Num a) => Integer -> a
09:56:42 <Eduard_Munteanu> :t fromIntegral
09:56:43 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:57:14 <ChongLi> is there a speed difference between the two?
09:58:03 <Eduard_Munteanu> I'm not sure.
09:58:37 <Lemmih> ChongLi: No. It compiles to the same thing.
09:58:46 <ChongLi> ah
09:58:46 <Lemmih> ChongLi: Are you sure it is too slow?
09:59:09 <ChongLi> well
09:59:12 <Eduard_Munteanu> Another option would be to look at GHC.Prim stuff, I guess.
09:59:12 <ChongLi> it's not that slow
09:59:21 <ChongLi> I might have to
09:59:47 <ChongLi> currently my function allocates a large amount of intermediate junk
10:00:07 <ChongLi> when it should be able to run wholly within registers
10:00:33 <monochrom> (how do you know what is responsible for the junk?)
10:00:55 <ChongLi> the cost centers that show up in the profile
10:00:56 <Eduard_Munteanu> Yeah, you should definitely profile if you aren't.
10:00:59 <Eduard_Munteanu> Ah.
10:01:28 <ChongLi> I've been attacking them bit by bit, but I'm still a haskell newb
10:01:57 <ChongLi> so I don't have intimate knowledge of how to solve these
10:02:34 <Eduard_Munteanu> Can you paste the code and profile? Maybe something else is triggering it.
10:02:40 <ChongLi> ok
10:03:05 <jmcarthur> was just running some simple benchmarks on various Int types on a 64 bit machine. Int seems to be faster than both Int32 *and* Int64...
10:03:13 <jmcarthur> only testing + and *
10:03:40 <monochrom> I don't even trust profiling. the result can be misleading. I would look at the core.
10:03:42 <Jafet> Int produces different code compared to Int64?
10:03:46 <ChongLi> http://hpaste.org/45977/profile
10:03:58 <Eduard_Munteanu> I thought Int was an alias for C's long.
10:04:09 <Eduard_Munteanu> So it should be Int64 straight.
10:04:16 <Eduard_Munteanu> on x86-64
10:04:23 <jmcarthur> it apparently does different code, but i indeed haven't checked the core yet
10:04:50 <jmcarthur> i'm using criterion. should be somewhat reliable
10:04:50 <monochrom> or perhaps the profiling result is not misleading but very few people can actually interpret it correctly
10:05:02 <ChongLi> http://hpaste.org/45978/code
10:06:11 <Eduard_Munteanu> ChongLi: and which function are you concerned about?
10:06:20 <ChongLi> noise
10:07:02 <jmcarthur> i was mainly going to just check Int vs. Integer vs. something from Data.Fixed, but then i decided to try Int32 and Int64 just to see
10:07:21 <ChongLi> I'm not even sure the way I implemented it is any good
10:07:29 <jmcarthur> and btw, Data.Fixed is doing pretty badly on these microbenchmarks
10:07:54 <Heffalump> it may be that Int has more specialisations
10:07:59 <ChongLi> my earlier version used a ton of lets
10:08:26 <ChongLi> (and allocated like ~10GB instead of ~3GB)
10:09:15 <jmcarthur> Heffalump: maybe. perhaps i should try some more complicated arithmetic in case i'm just hitting one optimization that's being amplified by the extremely small benchmark
10:09:46 <jmcarthur> i'm only doing 10+10 and 10*10
10:09:48 <Eduard_Munteanu> Hmm, the Vector stuff might not fuse away.
10:10:35 <ChongLi> would it be faster to generate that data instead of allocating it?
10:11:13 <ChongLi> it's pregenerated random values
10:11:18 <Eduard_Munteanu> Secondly using fromList doesn't magically make it O(1) to access I think.
10:11:51 <ChongLi> hmm
10:13:15 <Eduard_Munteanu> Thirdly you should probably try -funbox-strict-fields if you supplying it already (even at -O2).
10:13:44 <ChongLi>  ghc -O2 -fvia-C -optc-O3 -fexcess-precision -optc-march=native -XBangPatterns -funbox-strict-fields
10:13:52 <ChongLi> is how I compile it
10:14:16 <jmcarthur> looking at the core everything looks about how i'd expect. it's basically just the primops
10:14:28 <jmcarthur> i guess there might be some lower level optimizations
10:15:02 <Eduard_Munteanu> ChongLi: yeah that's reasonable
10:15:40 <ChongLi> would replacing p with a primitive array make it any faster?
10:15:43 <ChongLi> Array#
10:15:43 <ChongLi> ?
10:15:54 <jmcarthur> and all them are having to go through unboxing and reboxing, so none of them are getting an advantage there
10:16:14 <Eduard_Munteanu> Not really.
10:16:22 <ChongLi> I've tried reading the core
10:16:25 <Eduard_Munteanu> According to the profile the inside Vector isn't shared I think.
10:16:28 <ChongLi> it makes my eyes blur
10:18:40 * jmcarthur checks the assembly
10:18:56 <Eduard_Munteanu> I wonder if moving the vector to the toplevel as a separate value changes anything.
10:19:08 <ChongLi> how do I do that?
10:19:30 <Eduard_Munteanu> like    myvec :: Vector ...    myvec = V.fromList [...]
10:20:22 <BobFunk> have some doubts about Iteratees and Enumerators - can see how to feed multiple enumerators into a single iteratee, but can I combine two iteratee's so they can both consume the same enumeratee?
10:20:36 <Eduard_Munteanu> You should probably use Int as the element type.
10:20:42 <BobFunk> for example - having one iteratee write chunks to a file and another print them to the screen?
10:22:48 <jmcarthur> ... the assembly is exactly the same aside from labels and constructors. maybe my OS is changing the nice level as it runs or something? i'll try reordering the benchmarks
10:23:45 <ChongLi> wow
10:23:54 <ChongLi> moving the vector to the top level helped a lot!
10:24:34 <ChongLi> http://hpaste.org/45979/profile2
10:24:42 <jmcarthur> that seems to have changed it indeed
10:25:05 <ChongLi> knocked 1.2GB of allocation right out
10:26:29 <ChongLi> so CAFs can be really good it seems
10:28:48 <jmcarthur> ah no, 10*10 :: Int64 is still significantly slower than 10*10 :: Int :\
10:28:58 <jmcarthur> now i'm confused
10:29:23 <ChongLi> anyway, I have to get to my nephew's first birthday party!
10:29:27 <Jafet> diff the core?
10:29:28 <ChongLi> thanks for the help :)
10:29:33 <jmcarthur> i'll just attribute it to something weird on my machine unless somebody else feels like replicating my efforts. the assembly is the same and everything
10:29:45 <jmcarthur> Jafet: heh, i already did that, even to the assembly level
10:30:26 <Eduard_Munteanu> @src Int
10:30:27 <lambdabot> data Int = I# Int#
10:30:32 <Eduard_Munteanu> @src Int64
10:30:32 <lambdabot> data Int64 = I64# Int64#
10:30:46 <Jafet> @src Int#
10:30:47 <lambdabot> Source not found. stty: unknown mode: doofus
10:30:47 <jmcarthur> criterion is reporting mean: 18.49568 ns, lb 16.75872 ns, ub 20.22809 ns, ci 0.950 for Int64 and mean: 10.15050 ns, lb 9.380292 ns, ub 11.38586 ns, ci 0.950 for Int
10:31:10 <Jafet> ci?
10:31:15 <jmcarthur> confidence interval
10:31:43 <jmcarthur> it's saying that it's 95% confident that the actual mean is within lb-ub
10:32:27 <Jafet> What's your test code?
10:32:54 <jmcarthur> just    bench "10*10 :: Int64"   $ whnf (*10) (10 :: Int64)     and the equivalent for Int
10:33:09 <jmcarthur> i can paste the whole thing if you want
10:33:17 <jmcarthur> *hpaste
10:34:15 * jmcarthur does it without waiting for an answer
10:34:24 <jmcarthur> http://hpaste.org/45980/very_micro_benchmark     <-- built with -O
10:35:19 <jmcarthur> i'll also paste the assembly for the Int and Int64 multiplications
10:35:53 <Eduard_Munteanu> Yeah, that'd be helpful.
10:36:15 <Jafet> Man, it took that long to install criterion
10:36:32 <Jafet> It's not on my ia32 machine.
10:37:01 <jmcarthur> refresh the original hpaste and i have two annotations on it with the assembly for Int64 and Int multiplication
10:37:32 <jmcarthur> i pulled those into vimdiff and made sure they are essentially the same aside from labels and constructors
10:39:16 <jmcarthur> i could paste the core as well, but it's not really any more enlightening
10:39:31 <jmcarthur> it's just an unbox, multiply, rebox
10:39:45 <Jafet> On a Core 2 IA32, Int is slightly slower than Int32
10:39:50 <jmcarthur> s/rebox/box result/
10:40:00 <Eduard_Munteanu> Hm, yeah it looks rather efficient asm.
10:40:09 <Jafet> mean: 11.84905 ns, lb 11.81912 ns, ub 11.88289 ns, ci 0.950; mean: 11.90267 ns, lb 11.86785 ns, ub 11.95408 ns, ci 0.950
10:40:29 <jmcarthur> Jafet: hmm... that looks statistically insignificant to me
10:40:36 <Jafet> Oh right, the ranges overlap.
10:40:55 <Jafet> Strangely, Integer is much, much faster than Int64
10:41:03 <Jafet> Must be an architectural thing
10:41:05 <jmcarthur> makes sense i think
10:41:20 <jmcarthur> it uses a native Int as its base type i think
10:41:21 <Eduard_Munteanu> Is there a darcs code browser for GHC?
10:41:32 <jmcarthur> only goes into a ByteArray# when the Int would overflow
10:41:37 <Eduard_Munteanu> I don't feel like cloning it just to look into PrelInt :)
10:42:16 <monochrom> jmcarthur: you sure Int is still 64-bit?
10:42:17 <Jafet> I guess testing the overflow flag is faster than carrying another 32 bits, even in user software
10:42:24 <jmcarthur> monochrom: checked in ghci
10:42:39 <monochrom> fun
10:43:26 <Eduard_Munteanu> Anyway if multiplication asm is the same, maybe GHC is generating inefficient code to convert from Int64 to other stuff.
10:43:48 <jmcarthur> (maxBound :: Int, maxBound :: Int64)   ==>   (9223372036854775807,9223372036854775807)
10:43:56 <saati> why isn't data Type = Constructor | ... a valid thing to say in ghci?
10:43:56 <jmcarthur> Eduard_Munteanu: hm!
10:44:09 <jmcarthur> not sure why it would be doing that at all though
10:44:35 <jmcarthur> it's just evaluating it and ignoring the result, i would think
10:45:10 <jmcarthur> saati: ghci basically emulates do notation with some enhancements
10:45:26 <Eduard_Munteanu> I'm not sure there's any single point in base libs where types for Int# and Int64# align, so most likely it does go through some nop conversions.
10:45:58 <jmcarthur> Eduard_Munteanu: i'm not sure what you mean here
10:46:24 <jmcarthur> in this code i'm not even reading the result. just forcing it
10:47:03 <Eduard_Munteanu> Ah.
10:48:00 * jmcarthur peeks at the core to look at the code surrounding these things
10:48:14 <Heffalump> Eduard_Munteanu: surely it's on github now?
10:48:23 <Jafet> I'm getting matching times here, with 6.12.3 on amd64.
10:48:31 <Eduard_Munteanu> Oh, I'll have a look.
10:49:13 <jmcarthur> nope, they aren't being treated differently
10:50:45 <jmcarthur> Jafet: between Int and Int64?
10:50:52 <Jafet> Indeed
10:51:01 <jmcarthur> huh
10:51:13 <Jafet> Int32, oddly enough, is slightly slower
10:51:29 <Jafet> Probably redundant conversions, hopefully not unaligned accesses
10:51:39 <jmcarthur> what platform?
10:52:04 <Jafet> An AMD CPU, amd64
10:52:26 <jmcarthur> i meant OS
10:52:30 <jmcarthur> sorry
10:52:55 <Jafet> debian sid
10:53:37 <jmcarthur> arch linux here
10:53:56 <Jafet> I don't see how that could make any difference, really
10:54:11 <jmcarthur> well, some OSes might nice things differently
10:54:21 <eikke> is the Functor instance for Either defined somewhere in the standard library?
10:54:34 <jmcarthur> which was a theory i had earlier until i reordered the benchmarks
10:54:38 <Jafet> That only affects absolute timings, doesn't it? Not relative ones
10:54:44 <jmcarthur> well no
10:54:47 <jmcarthur> it can affect relative too
10:54:58 <jmcarthur> since the priority can be adjusted while it's running
10:55:01 <jmcarthur> by the scheduler
10:55:21 <Jafet> Ah. Well, I suppose you ran it repeatedly and got the same timings?
10:55:36 <jmcarthur> i don't know about now, but a few years ago the linux kernel would gradually lower the priority of a process that was taking up a lot of cpu
10:55:40 <jmcarthur> yes i did
10:56:49 <jmcarthur> i'm going to just try something more complicated
10:57:29 <jmcarthur> this benchmark is so small that i might as well be studying quantum physics
10:57:50 <djahandarie> lol
10:58:03 <Jafet> It still seems a bit strange. What is your CPU architecture and GHC?
10:58:23 <jmcarthur> core2 duo, ghc 7.0.2
10:58:36 <djahandarie> What is your height? Hobbies? There's gotta be something...
10:58:42 <jmcarthur> the ghc version doesn't even matter here though since i already verified that the assembly for both benchmarks is the same
10:59:18 <jmcarthur> well actually... i guess the assembly could be *different* for yours, but i doubt it
10:59:44 <jmcarthur> it would be quite some coincidence if my identical assembly got different results and your different assembly got identical results
11:00:16 <Jafet> That reads almost like a quantum conservation theorem though
11:00:22 <jmcarthur> maybe by this time tomorrow i will have thought of whatever stupid reason is causing this
11:01:13 <jmcarthur> heck, i didn't even think about changing my cpu governor
11:01:55 <Eduard_Munteanu> Heh, djahandarie 
11:02:12 <applicative> eikke: It's in Control.Monad.Instances
11:02:24 <Jafet> @vixen do you like your computers fast?
11:02:25 <lambdabot> sure, i definitely don't hate
11:02:40 <Eduard_Munteanu> But you said core was different.
11:02:48 <Eduard_Munteanu> Anything suspicious in there?
11:02:59 <applicative> eikke: or did someone say this.  You can find out things like that with :i Functor or :info Functor inside  ghci
11:03:08 <Egbert9e9> is there a way to set types in ghci?
11:03:12 <jmcarthur> hm? no the core was the same aside from different constructors and primops
11:03:35 <jmcarthur> different in the case of Int32 due to the extra narrowing primop (which i think is a nop?)
11:03:46 <jmcarthur> might not be a nop
11:03:51 <applicative> Egbert9e9: you can't define a type inside ghci.  you can import a module with it defined
11:03:52 <Eduard_Munteanu> The asm should be different for Int32.
11:03:58 <jmcarthur> yeah i didn't even check that
11:04:17 <Egbert9e9> applicative: i see
11:04:30 <applicative> Egbert9e9: it has been discussed, I think there is no great impediment, theoretically
11:05:01 <applicative> you can define new functions and other values with let of course
11:05:09 <jmcarthur> okay, changing my cpu governor brought them closer together. not sure if they are close enough to be essentially the same though. their 95% confidence intervals still don't overlap
11:05:15 <eikke> applicative: thanks
11:05:37 <eikke> applicative: I know about :i in ghci, but that only shows instances if the module in which the instance is defined is loaded ;)
11:05:37 <Egbert9e9> applicative: but they're too.. uhm.. algebric typed
11:05:41 <jmcarthur> "mean: 9.485133 ns, lb 9.140906 ns, ub 9.955521 ns, ci 0.950" for Int64, "mean: 8.523617 ns, lb 8.515360 ns, ub 8.540278 ns, ci 0.950" for Int
11:05:51 <Eduard_Munteanu> 64->32 could be a nop I think, it's just a matter of setting a REX prefix on subsequent ops
11:05:57 <jmcarthur> yeah
11:06:05 <applicative> eikke, yeah, but doesn't the instance show up in Prelude?
11:06:13 <eikke> applicative: nope
11:06:38 <eikke> looks like the monad instance for Either requires even a non-standard package :( (category-extras)
11:06:38 <applicative> eikke: wait I have a slightly hacked .ghci that would bring it in, right. 
11:06:53 <eikke> :D
11:07:36 <jmcarthur> okay, i declare this benchmark to be crap. Int32 just beat both Int64 and Int. i will never supermicrobench again. lesson learned
11:07:50 <applicative> The monad instance is there in Control.Monad.Instances, with the Functor one, no?
11:08:05 <jmcarthur> sorry for wasting time Eduard_Munteanu, Jafet 
11:08:24 <eikke> applicative: nope, it's in Control.Monad.Either (category-extras) or Control.Monad.Trans.Error (transformers)
11:08:32 <jmcarthur> i'm still curious about *why* this is so, but i'm pretty convinced that the results are not reliable
11:08:40 <eikke> afk now
11:09:08 <Eduard_Munteanu> Mmm, maybe doing lots of stuff (longer than a few ns) in terms of primops might be more reliable.
11:09:14 <jmcarthur> yeah
11:09:19 <byorgey> there is a Monad instance for Either in Control.Monad.Instances.  It does require that silly Error constraint though.
11:09:24 <applicative> eikke, we're talking about Either e? http://www.haskell.org/ghc/docs/7.0.3/html/libraries/base-4.3.1.0/src/Control-Monad-Instances.html
11:09:28 <jmcarthur> i am going to try that next. just have to decide what to do
11:09:28 <Eduard_Munteanu> (to avoid reboxing)
11:09:40 <applicative> byorgey oh.
11:09:59 <Egbert9e9> what's a good way to get command line parameters? something standardish
11:10:20 <Saizan> byorgey: i thought it got removed with the new base
11:10:38 <jmcarthur> there is a new instance now, without the Error
11:10:47 <byorgey> oh, nice
11:10:58 <Saizan> yeah, the old Error one was in mtl
11:11:38 <applicative> byorgey, yeah I'm not seeing how it can be implied by the spare content of Control.Monad.Instances
11:11:39 <byorgey> Egbert9e9: try the cmdargs package
11:11:50 <adamvh> anyone here use Leksah?
11:12:03 <applicative> Egbert9e9: do you just mean "getArgs"?
11:12:13 <applicative> @type getArgs
11:12:14 <lambdabot> Not in scope: `getArgs'
11:13:34 <applicative> @type System.Environment.getArgs
11:13:35 <lambdabot> IO [String]
11:14:09 <applicative> Egbert9e9: ^^^ is the simple-minded approach
11:14:37 <Egbert9e9> applicative: hmm.. i mean something that will make all the pick and choose logic. i never done that, so i have hard time really knowing what i need
11:16:17 <jmcarthur> at least i was able to determine that Data.Fixed is dang slow. i could have guessed that though
11:17:21 <applicative> Egbert9e9 the cmdargs package has a whole system for setting stuff like this up, and some examples and so on.  It kind of fancy though.
11:19:32 <applicative> wow, hadn't seen the package "memscript" for memorizing scripture.  "For the test data I included four beloved Psalms (1,23,121,127.."
11:23:34 * applicative would prefer a special Haskell data type for sacred scriptures, not [String], maybe a phantom type for the specific religion
11:23:54 <byorgey> hehe
11:25:53 * applicative once made a data type for Aquinas' Summa, when learning how to write a parser.  He wrote in 'hypertext' as we see at e.g. http://newadvent.org/summa/2.htm
11:26:15 * applicative meant, he wrote in 'hypertext' in the 13th c
11:26:52 * applicative thinks the Babylonian Talmud would be more trouble
11:30:29 <Twey> applicative: Neat
11:31:36 <applicative> Speaking of translation, have the egg heads who work on translation programs ever considered something different, namely the extraction of information from already translated texts?
11:32:19 <Jafet> Google uses a huge corpus.
11:32:25 <Jafet> Perhaps they don't use it well enough.
11:32:34 <applicative> I was thinking it could be cool, if one makes [(OriginalLine, Translated)] to make inferences about what's translating what, and thus retranslate
11:32:39 <Jafet> Multilingual corpora, yes.
11:32:54 <Jafet> I hear they include UN documents, among other things
11:33:03 <applicative> or expose to the learner the translation with a suitable selection of words kept in the original.  -- the latter I would often find useful
11:33:09 <Twey> applicative: Yes, we call it ‘statistical translation’, and the most famous example is Google Translate.
11:33:31 <applicative> well, but their purpose is a translation of something completely new.
11:34:24 <applicative> but it makes sense that the mechanism for giving you the Korean for "Is there a barber shop nearby?" will use such pairs of Korean and English textss
11:34:33 <Twey> applicative: They use the same approach you outlined: a big corpus of pre-translated works is fed into it, and it makes inferences about how to translate things from that corpus, which inferences are then used to translate other things when it encounters similar phrases/patterns
11:35:09 <applicative> Twey, yes, they are using what I want, that hadn't occurred to me in thinking about this, though I knew it.  
11:35:41 <Twey> *nod*
11:35:47 <applicative> But I would like to make classical text of various types available to people who only barely know or are learning the content
11:35:49 <solrize> http://cs.oberlin.edu/~jdonalds/333/lecture30.html
11:35:57 <solrize> i remember reading about that
11:36:07 <Twey> It's a shame that GTranslate isn't open-source.  It would be interesting to study.
11:36:14 <solrize> they use the canadian parliament record for english-french corpus
11:36:33 <solrize> since all of it is in both languages
11:36:43 <applicative> solrize, cool   
11:37:02 <applicative> the other purpose would be to produce what was formerly called an 'interlinear translation'
11:37:20 <gwern> Twey: isn't gtranslate basically terabytes of data? kind of hard to open source that
11:37:27 <solrize> http://www.google.com/search?q=machine+translation+canadian+parliament+french+english
11:37:49 <Twey> gwern: Well, they could open up the engine
11:38:06 <Jafet> Their translation engine itself is probably even dumber than their pagerank algorithm
11:38:14 <Twey> applicative: ‘Formerly’?  What do they call it nowadays?
11:38:21 <Twey> I've only heard it called an interlinear.
11:38:22 <Jafet> As gwern said, google knows how to put gobs and gobs of data to work
11:38:34 <Twey> Haha, okay
11:38:49 <applicative> Twey, I just noticed they still use it for Scripture.  I was thinking more like Caesar's Gallic Wars
11:39:09 <Twey> Oh
11:39:21 <Twey> applicative: It's still called an interlinear translation, it's just not used nearly as much
11:39:35 <Twey> Because people tend to just want to read the content without having any knowledge of or interest in the language :-\
11:39:58 <Twey> We use them for language-learning materials
11:40:13 <applicative> Twey, well yes, my plan does presuppose the decline of knowledge of esp. dead languages.  
11:40:36 <Twey> I think it's a great plan.  I'd be interested in that.
11:41:32 <applicative> I thought, if you had e.g. two translations of Marx's Capital into English, or three of Genesis, or 2 of Plato's Republic or whatever
11:42:00 <lpsmith> Google's Translate is interesting in that it is mostly invertible,  which takes away something I used to use to entertain myself.   But I also find that it's not *that* good for understanding documents written in languages I don't understand.   I usually get an idea of what it is about,  but I don't at all trust details.
11:42:05 <applicative> this is actually a huge amount of information about the text itself, never mind info for an inevitably lame scheme like google translate
11:43:03 <applicative> lpsmith, yeah, the problem they are solving is clearly incredibly hard. I am thinking of harvesting the labor of serious translators to bring the reader closer to what was seriously translated
11:43:09 <applicative> not to something new
11:44:11 <lpsmith> applicative: oh no doubt.   Personally I'm doubtful machine translation will ever work particularly well.
11:44:15 <applicative> I had totally forgotten about the Scripture related programmers; they must have thought of a lot of what I'm thinking
11:44:28 <applicative> lpsmith, yes, this is exactly not machine translation. 
11:44:42 <applicative> more like machine untranslation, semi-untranslation, etc
11:44:59 <applicative> machine preferred word-translation substitution, etc
11:46:43 <applicative> if i oppose Moore and Aveling's or Fowkes' translation of "Ware" as "commodity" and prefer "merchandise", then bang comes my new copy of Capital Volume 1
11:47:07 <Twey> Neat
11:47:47 <applicative> or if I'm tired of "commodity" "value" "work", and just want the German for "Ware" "Wert" "Arbeit", I just take the German for them.
11:48:51 <applicative> so maybe the idea is, a configurable translation, but not one founded on the a general translate-whatever-you-want machinery, but on existing sound translations
11:50:06 <lpsmith> I guess I don't really see your vision :)
11:50:32 <lpsmith> As in, take 3 translations of Marx,  and use them to generate more translations of Marx?
11:50:38 <applicative> lpsmith, it only makes sense if you often deal with crucial canonical texts of massive importance
11:50:54 <Tomsik> \
11:51:11 <applicative> lpsmith, not really, I am thinking of something that might be best as a web service
11:52:01 <applicative> you configure the page or section or whatever as you look at it.  maybe you can tolerate some words of the original for example. 
11:52:24 <lpsmith> hmm
11:52:27 <applicative> as you get accustomed to them, you let them take the place of the English, or whatever you read well
11:52:42 <applicative> lpsmith, in fact I myself want this all the time.  
11:53:06 <lpsmith> Oh that's the best kind of software to think about and work on :)
11:53:39 <applicative> it is a result of half knowing several languages of importance to me.... 
11:53:39 <lpsmith> So what languages can you read other than English, and how well?
11:54:04 <applicative> i read latin greek french and german, but none very well, maybe german and french
11:54:20 <lpsmith> It might also be a good way of learning a language, especially if you are interested in some of the text in that language
11:54:51 <lpsmith> Heck,  you could even use it on say,  pre-Victorian English to English "translations"
11:54:54 <applicative> lpsmith, yes that's what I was thinking. 
11:55:20 <Twey> Or American to English translations :þ
11:55:33 <lpsmith> Reading english from a few centuries ago often takes a fair bit of work if you aren't accustomed to doing so.
11:55:44 <applicative> hah yes.  I often teach English texts from 1600 after Greek texts from 300 bc and before French and German later
11:55:53 <applicative> the English is hardest because it's not translated
11:56:02 <Twey> Hrm
11:56:51 <applicative> so, take "you" for "thou" ; "yours" for "thine" ....
11:57:09 <c_wraith> older
11:57:12 <applicative> in fact it's the punctuation that is the worst for students in a lot of this/
11:57:12 <c_wraith> say, Chaucer
11:57:27 <applicative> right, that would be wild
11:57:28 <c_wraith> Chaucer is ouch.  It's basically a different language.
11:57:36 <lpsmith> yeah,  I personally don't get tripped on "thou" or "thine"
11:58:15 <lpsmith> See,  I find the Commonwealth period of English history absolutely fascinating.   I know almost everybody says that's about as boring as you can get
11:58:28 <lpsmith> but there are a lot of technical and social movements afoot
11:58:58 <applicative> "thou" and "thine" aren't that bad.  But take Hobbes:  
11:59:00 <applicative> Hereby it is manifest, that during the time men live without a common Power to keep them all in awe, they are in that condition which is called Warre; and such a warre, as is of every man, against every man.
11:59:18 <applicative> that's not so bad, but after 10 pages the students need a drink
11:59:25 <lpsmith> lol
11:59:49 <Veinor> i really like how 'warre' is sometimes capitalized and sometimes not
12:00:06 <lpsmith> yeah, easy enough to understand approximately, but also hard to catch the details
12:00:12 <applicative>  To this warre of every man against every man, this also is consequent; that nothing can be Unjust. The notions of Right and Wrong, Justice and Injustice have there no place.
12:00:26 <applicative> Veinor, yes, it's as if it was half-German.  
12:00:47 <Veinor> i think it's because the first time it refers to a broad concept, and the second time it doesn't
12:01:07 <applicative> Things were different, Hobbes sometimes wrote his name Hobbes, sometimes Hobbs, he didn't notice the difference
12:01:48 <Twey> Heh
12:01:54 <lpsmith> You have John Wallis helping to lay the groundwork for calculus,  and doing early work into cryptography and codebreaking
12:02:35 <applicative> Right, we must help tired students reap the harvest of his algorithms from his unreadable texts!
12:03:26 <lpsmith> lol,  it's interesting from a historical perspective.   People think calculus came out of Newton and Leibniz's mind fully formed.
12:04:12 <lpsmith> When in fact the concepts of integration and differentiation were there,  and the Fundamental Theorem of Calculus was already understood
12:04:15 <osfameron> presumably it was independently invented by others too, who never became famous?
12:04:35 <osfameron> oh?  it was *widely* known previous to them?
12:04:36 <applicative> In such condition, there is no place for Industry, because the fruit thereof is uncertain, and consequently no Culture of the Earth, no Navigation, nor use of the commodities that may be imported by Sea, no commodious Building, no Instruments of moving, and removing such things as require much force, no Knowledge of the face of the Earth, no account of Time, no Arts, no Letters, no Society, and which is worst of all, cont
12:04:37 <applicative> violent death, and the life of man, solitary, poor, nasty, brutish, and short 
12:04:42 <Jafet> Well, Newton became well-known for using it to solve popular problems
12:04:47 <applicative> man, what a master Hobbes was
12:04:51 <Jafet> Popular computational problems, even
12:05:13 <lpsmith> osfameron: Newton and Leibniz's main contribution was the development of methodologies to more systematically calculuate integrals and derivatives,  as well as applications.
12:06:06 <lpsmith> They unified and systematized a body of knowledge with no obvious explanation
12:06:10 <stepkut> how do I checkout this library, http://code.galois.com/cgi-bin/gitweb?p=cereal.git;a=summary
12:06:40 <osfameron> lpsmith: yarr
12:07:04 <osfameron> (and this, boys and girls, is why patents are a bad thing)
12:07:17 <osfameron> though I know patents don't (quite rightly) apply to mathematical knowledge in any case
12:07:41 <osfameron> but the same is true of other fields too - work building on other work till an idea is ready to pop out
12:07:57 <lpsmith> unless it's a business practice,  tax strategy,  or certain kind of algorithm...
12:08:49 <lpsmith> The ability to patent tax strategies tells me that the US has jumped the shark...
12:09:01 <osfameron> heh
12:09:14 <osfameron> or even business practises
12:09:21 <osfameron> what kinds of algorithms can be patented?
12:09:30 <osfameron> oh wait, isn't spreadsheet calculation still patented?
12:09:37 <lpsmith> I dunno
12:09:38 <applicative> stepkut my copy of httpbis says  git://code.galois.com/HTTPbis.git
12:09:49 <lpsmith> RSA and LWZ,  though I don't feel too bad about those patents
12:09:52 <stepkut> applicative: yeah, I just found this page, http://code.galois.com/wiki/
12:09:55 <lpsmith> (and they are now expired)
12:10:02 <osfameron> (despite it being so bloody obvious that *I* independently invented it, an hour after reading an introductory chapter on graph dependency algorithms..)
12:10:10 <applicative> oh ok
12:10:25 <stepkut> applicative: but thanks!
12:10:27 <Jafet> osfameron: you're not prior art.
12:10:42 <osfameron> Jafet: no.  but it still shows it's a bum patent ;-)
12:12:02 <monochrom> prior art is not the only way to revoke a patent. "anyone in the same shoe must come up with this" is another way
12:12:40 <applicative> Twey, if I cook up a clearer formulation of this idea, I will get back to you.
12:12:59 <Twey> Alright
12:13:29 <Twey> It's probably well beyond my meagre talents, but it sounds like a cool idea ☺
12:14:09 <applicative> Maybe I will look into the open source Scripture study world. They must have done things like this. 
12:14:19 <osfameron> aha, it was "spreadsheet automatic natural order recalculation", granted 1983, but ruled unenforcable in 1995
12:20:57 <roconnor> what's a cool idea?
12:22:46 <Faucelme> I like the idea of the multiple interacting translations of a text.
12:23:29 <Faucelme> Perhaps you could even morph the translation into the original in real time,
12:24:07 <Faucelme> changing words at a random.
12:32:43 <zong_sharo> Lemmih: is it possible to undo events? if so, acid-state is naturally appliable as edit history storage
12:36:44 <lpsmith> osfameron: who was it granted to,  and what was the argument that ultimately overturned the patent?
12:37:53 <SyGeek> Just got to know about Haskell, seems cool enough. 
12:37:58 <ccasin> basic lazy evaluation question: if I do (liftM2 (&&) foo1 foo2), will the action foo2 get run if foo1 is false, or does liftM not always run its arguments
12:38:12 <c_wraith> ccasin: depends on the monad in question
12:38:16 <ccasin> IO, here
12:38:21 <c_wraith> then it will get run
12:38:39 <ccasin> c_wraith: interesting - why's that?
12:38:45 <mauke> @src liftM2
12:38:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:38:51 <ccasin> aha :)
12:38:52 <ccasin> thanks
12:39:07 <ccasin> so it seems it doesn't depend on the monad after all?
12:39:21 <c_wraith> it does...  There are monads where m2 won't get run unless x2 is evaluated
12:39:26 <c_wraith> like lazy identity
12:39:27 <ddarius> c_wraith: False.
12:39:32 <mauke> c_wraith: how do you define "run"?
12:39:41 <mauke> because I see a "<-" in there
12:40:08 <mauke> the only way out I see is m1 throwing an exception
12:41:22 <Tomsik> what if f x _ = x?
12:41:28 <Tomsik> I mean, that f ignores the second argument
12:41:58 <Saizan> the effects of m2 will happen regardless of that
12:43:03 <mauke> Tomsik: liftM2 const (putStr "a\n" >> return 42) (putStr "b\n" >> return (1 `div` 0))
12:43:33 <Tomsik> okay
12:44:50 <c_wraith> mauke, ddarius: http://hpaste.org/45986/lazy_identity
12:45:21 <c_wraith> (that's with mtl 2, if it turns out to matter)
12:45:58 <Saizan> lazy identity doesn't have any effects, so the fact that the ones of m2 are run is moot
12:46:49 <Saizan> it'll be the same in any monad if you replace "undefined" with "return undefined"
12:47:33 <DevHC> can we rename "return" to "inject" or something?
12:47:47 <c_wraith> don't call it inject, that'll confuse ruby people
12:47:51 <c_wraith> they'll think it's a fold
12:47:52 <DevHC> lol
12:48:04 <DevHC> ruby can wipe my ass
12:48:20 <DevHC> but
12:48:34 <DevHC> the current return confuses ALL imperative people
12:49:04 <mauke> good
12:49:09 <DevHC> D:
12:49:19 <mauke> equal rights
12:49:34 <c_wraith> can we find a name for it that will confuse everyone equally?
12:49:39 <ddarius> The current = confuses all imperative people, as does <- and class.
12:50:00 <Saizan> imperative people must learn to unlearn early
12:50:03 <mauke> c_wraith: I propose "wunt"
12:50:04 <c_wraith> how about ry'leh
12:50:06 <DevHC> how does class confuse C d00ds?
12:50:22 <DevHC> what does "wunt" mean?
12:50:30 <ddarius> I doubt there exists a C programmer that is unaware of object oriented programming.
12:50:42 <DevHC> i am not aware of OOP :>
12:50:55 <mauke> c_wraith: see?
12:50:56 <FauxFaux> Record Oriented Programming. ¬_¬
12:51:53 <Saizan> objection oriented programming
12:53:48 <DevHC> mauke: what does "wunt" mean?
12:54:01 <c_wraith> mauke: I do indeed see
12:54:17 <DevHC> does u speaks engrish?
12:54:31 <mauke> DevHC: I wasn't talking to you
12:54:54 <Kaidelong> how does <- confuse them?
12:55:02 <Kaidelong> do they expect mutation where shadowing actually happens?
12:55:03 <Heffalump> how about "result"?
12:55:16 <Kaidelong> @ddarius
12:55:17 <lambdabot> Unknown command, try @list
12:55:38 <justin__> newbie here, how would one go about setting up a timer with a callback function?
12:55:52 <DevHC> Heffalump: that would confuse haskell as well :>
12:55:58 <mauke> forkIO (threadDelay n >> wat)
12:56:42 <Heffalump> it makes it clearer that it's subject to future overriding
12:57:45 <justin__> thanks mauke
12:59:11 <DevHC> Heffalump: well it IS better than return, but i still see inject being an even better name
13:00:52 * DevHC thinks of a name which doesn't sound like "do this"
13:01:00 <Zao> DevHC: "huggle"
13:01:06 <mauke> "zen"
13:01:08 <Zao> Or "hug"
13:01:30 <Zao> "grok", in the meaning "completely absorb" :D
13:01:37 <DevHC> what do they mean and how does it relate to creating monads with 1 element?
13:01:48 <DevHC> hmm
13:02:10 <mauke> it doesn't create monads
13:02:10 <DevHC> how about
13:02:12 <DevHC> mono
13:02:22 <DevHC> :t return
13:02:23 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:02:27 <DevHC> i object
13:02:34 <mauke> the monad is m
13:02:38 <mauke> it doesn't create m
13:03:03 <DevHC> it creates values of the m monad, and taht value contains 1 element :>
13:03:05 <mauke> how about "mote"?
13:03:18 <DevHC> mote means?
13:03:42 <mauke> http://blog.plover.com/prog/haskell/monad-terminology.html
13:03:56 <Boxo> a monadic value
13:04:22 <Boxo> inject sounds too fancy and javalike to me.
13:06:09 <DevHC> lol @ http://blog.plover.com/prog/haskell/monad-terminology.html's "strictly corrrect"
13:06:55 <belgiumarthur> hey
13:07:14 <belgiumarthur> i have a question
13:09:13 <Kaidelong> you can just ask
13:11:30 <Tomsik> return/bind are enough for a monad, so is return/join, what are other pairs? Especially ones without return.
13:11:59 <ddarius> Tomsik: return and join aren't enough.
13:12:00 <Kaidelong> how about a "content"
13:12:06 <Kaidelong> as opposed to mote/mobit
13:12:14 <Tomsik> ddarius: then join/what is?
13:12:20 <Kaidelong> the same could apply for all functor-like things
13:12:24 <c_wraith> Tomsik: return/join/fmap
13:12:46 <Tomsik> hmm, but how about return-less?
13:12:50 <Kaidelong> it boils down to being an applicative functor + join
13:13:12 <Kaidelong> Tomsik: Monads all have that
13:14:02 <c_wraith> You need return.  Otherwise there's no way to get a value into the monad without having another value in that monad already
13:14:17 <Tomsik> :(
13:14:52 <Kaidelong> I don't think everything that parameterizes over a type has something in the form a -> b a, at least not a total something in that form
13:15:02 <Kaidelong> but monads do
13:15:10 <Kaidelong> endofunctor with eta and mu
13:15:20 <Kaidelong> IIRC
13:15:39 <DevHC> 1. i shit on this "mote" terminology, it sounds uhmm... dull
13:16:01 <DevHC> 2. we r to rename "return", not give a name to values that it yields
13:16:30 <Kaidelong> I like return
13:16:32 <Tomsik> Kaidelong: I think "eta" and "mu" were just join and return
13:16:33 <DevHC> :<
13:16:34 <Kaidelong> it's quite practical
13:16:42 <Kaidelong> Tomsik: Exactly
13:16:46 <Kaidelong> so monads come with return
13:16:47 <c_wraith> Kaidelong: a common example is b = (,) c.  a -> (c, a) is not a function you can implement
13:17:01 <DevHC> why is inject not more practical?
13:17:10 <Tomsik> :t \x -> (undefined, x)
13:17:11 <lambdabot> forall a t. t -> (a, t)
13:17:13 <Tomsik> :p
13:17:24 <c_wraith> tomsik, that's not total :)
13:17:30 <Kaidelong> DevHC: for one view of monads, "return" is pretty much correct
13:17:30 <mauke> DevHC: re 2: that's stupid
13:17:51 <Kaidelong> Maybe is a program that returns a value, maybe
13:18:06 <Kaidelong> Lists are programs that return zero or more values in a particular order
13:18:13 <Kaidelong> etc
13:18:29 <DevHC> Kaidelong: for a functional (tip: haskell is... functional?) view, "inject" is correcter
13:18:34 <DevHC> mauke: ORLY
13:18:45 <dolio> return isn't necessarily an injection.
13:19:01 <DevHC> lol
13:19:23 <Tomsik> just name it mu
13:19:28 <Tomsik> and make it unicode syntax
13:19:34 <dolio> mu is join
13:19:36 <Kaidelong> that would be one solution I guess
13:19:37 <Tomsik> damn
13:19:38 <Kaidelong> err
13:19:40 <Kaidelong> eta
13:19:40 <Kaidelong> yeah
13:19:45 <DevHC> xi
13:19:54 <Boxo> enter, just, it
13:19:54 <mauke> η
13:20:00 <Kaidelong> I think return is actually a good choice
13:20:18 <DevHC> it IS good
13:20:21 <Kaidelong> as it basically says that a monadic computation in fact does have a value
13:20:26 <Kaidelong> that it returns
13:20:28 <Kaidelong> when it is run
13:21:02 <DevHC> and now, on to making it BETTER(TM)
13:21:06 <Kaidelong> when you run a Maybe value you get either a Just or a Nothing
13:21:49 <DevHC> i really don't like the terminology of calling everything a computation
13:21:59 <DevHC> even though every function in haskell is ind33d a computation
13:22:05 <DrSyzygy>  A value of type Maybe can be constructed by either Just or a Nothing.
13:22:06 <Kaidelong> I don't really understand how else you could really think about lazy evaluation
13:23:19 <Tomsik> What is it if it's not a computation?
13:23:38 <Kaidelong> When wouldn't it be?
13:23:40 <DrSyzygy> Kaidelong: But then it's not limited to monadics — any value may trigger a computation.
13:23:51 <Kaidelong> DrSyzygy: Absolutely
13:23:52 <monochrom> define "computation"
13:24:05 <Kaidelong> but
13:24:10 <Cale> DevHC: Values of type m a where m is a monad are called m-computations, because you're meant to think of them as programs which are yet to be interpreted.
13:24:15 <monochrom> personally I don't think there is any difference between saying "computation" and saying "thingy"
13:24:18 <Kaidelong> what monads allow you to do, to a degree, is change the way the computations actually run
13:24:18 <Cale> (sometimes)
13:24:47 <DrSyzygy> Cale: Far from all monads make “computation/program” the best possible metaphor tho'.
13:24:49 <Kaidelong> [a] is very different from a
13:25:00 <Kaidelong> I am not sure
13:25:02 <DrSyzygy> Kaidelong: Psht. Just the free monoid. 
13:25:15 <monochrom> you could, of course, define "computation = monadic value" so you could say "monad is about computation" with a smug conscience
13:25:16 <Kaidelong> the examples people usually give me are maybes and lists
13:25:23 <Cale> DrSyzygy: It's a reasonable metaphor for all the monads usable from Haskell :)
13:25:26 <DevHC> Cale: maybe U're meant to think of them as programs which r yet to be interpreted, but not others
13:25:39 <Kaidelong> and I think both of those are better thought about as being "programs"
13:25:41 <tomh> is there a haskell xor for ints?
13:25:46 <DrSyzygy> monochrom: I see a difference. Using “computation” instead of “thingie” evokes a semantic that you might not be looking for.
13:25:47 <tomh> like the ^ operator?
13:25:56 <DrSyzygy> :t xor
13:25:57 <lambdabot> forall a. (Bits a) => a -> a -> a
13:26:01 <DevHC> Cale: we can think of everything as a program, because everything is ind33d a program, but that's boring
13:26:02 <Cale> tomh: yeah in Data.Bits
13:26:06 <Kaidelong> also scripting is a nice way to grasp pure functional programming
13:26:07 <tomh> ok cool
13:26:11 <ddarius> "I have a computation growing on my toe."
13:26:12 <Kaidelong> or functional programming in general
13:26:26 <Cale> DevHC: Not everything is a program
13:27:40 <Cale> Values of type IO String, for example, you're meant to think of as being descriptions of IO which might be performed at some point in the future (to produce a String result)
13:27:54 <Tomsik> "Computation" is far from thingy, it's an underlying Turing-complete model doing the hard work.
13:28:48 <Cale> Evaluating a value of type IO String doesn't cause that program to execute (any more than loading the source code of a program in a text editor would cause the program to run)
13:29:23 <DevHC> Cale: values of IO String, for example, u're meant to think of as being abstract world-transformations, which may be composed with other world transformations
13:29:29 <Cale> no
13:29:34 <DevHC> no nos
13:29:37 <Cale> Don't think of them like that :)
13:29:44 <DevHC> but that is not 1337 otherwise
13:30:04 <Cale> I hate the RealWorld -> (RealWorld, a) analogy for IO a
13:30:08 <DrSyzygy> DevHC: Because 1337 is something worth trying for? Instead of actual enlightenment?
13:30:11 <dolio> That model doesn't work.
13:30:20 <Cale> Because it's unrealistic in the face of concurrency
13:30:34 <dolio> You don't even need concurrency to break it.
13:30:43 <dolio> Just productive IO programs.
13:30:44 <DrSyzygy> Cale: What's your preferred metaphor for IO? Descriptions of future computation?
13:31:04 <Cale> DrSyzygy: Something more like an abstract syntax tree for an imperative language
13:31:10 <DrSyzygy> Aight.
13:31:17 <Cale> You could do a decent job using a GADT
13:31:20 <Cale> data IO a where
13:31:21 <DevHC> DrSyzygy: yes.
13:31:26 <Cale>   returnIO :: a -> IO a
13:31:34 <Cale>   bindIO :: IO a -> (a -> IO b) -> IO b
13:31:39 <monochrom> (what is your model for an imperative language? :) )
13:31:45 <Cale> er, should be capitalised there :)
13:31:49 <Cale>   ReturnIO :: a -> IO a
13:31:52 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
13:31:58 <Cale>   GetChar :: IO Char
13:31:59 <DevHC> DrSyzygy: not instead, but rather as an addition to the other, secondary background
13:32:03 <Cale>   PutChar :: Char -> IO ()
13:32:06 <Cale>   etc.
13:32:55 <Tomsik> IO is horrible because it's non-local
13:33:01 <Cale> That's a fairly reasonable higher-order abstract syntax-y way of doing it. It's possible to do a better job by putting everything in terms of continuations so as to respect the monad laws a bit better
13:33:33 <Cale> (it's possible to observe differences between IO actions which you shouldn't really be able to observe with this representation)
13:33:56 <Cale> But I think it's probably more helpful to look at it this way first.
13:34:07 <DrSyzygy> Randomly, I'm starting to wonder whether there is a nice way to approach monads as operads: just to get a new metaphor to the rampant jungle of monadic tutorials out there…
13:34:20 <Cale> :)
13:34:34 <djahandarie> Codensity IO a? :p
13:34:40 <DrSyzygy> They are pretty closely tied in the category-theoretic side of things…
13:34:43 <DevHC> the definition of a program includes the abstract steps of its description AND the environment which interprets those steps
13:34:57 <Tomsik> Geez, monads are just monads, why do you need allegories
13:35:05 <DevHC> (so ofc u can observe difference between IO actions)
13:35:24 <Cale> Tomsik: Allegories are for relations ;)
13:35:34 <Tomsik> It's just like making metaphors for what a monoid is
13:35:35 <DrSyzygy> Tomsik: Because we ALL use allegories for everything. It helps being able to articulate your own mental representation of the concept.
13:35:37 <Cale> http://en.wikipedia.org/wiki/Allegory_%28category_theory%29
13:35:44 <Tomsik> Cale: it's the other way around :p
13:36:01 <Tomsik> Just like morphisms aren't functions
13:36:05 <DrSyzygy> Tomsik: If nothing else so that you are able to compare your own understanding with that of other people, and able to compare and contrast two definitions that look different.
13:37:43 <ddarius> DrSyzygy: Then you can define your monads in terms of colored operads (aka multicategories) in terms of monads.
13:37:50 <Twey> Is there a nice way to integrate Lua into Python that allows safe sandboxing and e.g. timing out on long-running expressions?
13:38:57 <ceii__> Twey, the good old C API?
13:39:41 <Twey> ceii__: Rather not :-\  Does it even allow that?
13:40:10 <ceii__> Sandboxing is easy since you have full control over what's in scope
13:40:20 <ceii__> Timing out would require threads
13:40:30 <Twey> Yeah
13:41:03 <Twey> I guess I could maybe use this: http://programming-guides.com/python/timeout-a-function
13:41:18 <mekeor> Any ideas why "length . nub [1,2,3]" doesn't work? ("Data.List" is already imported) ("length (nub [1,2,3])" does work..., but I want to use ".") :-(
13:41:38 <dolio> Those aren't equivalent expressions.
13:41:50 <monochrom> allegories allow you to ramble in #philosophy and create websites like that of timecube
13:42:02 <Twey> Oh crap
13:42:12 <Twey> I meant to ask that in #python
13:42:13 <mekeor> dolio: ?
13:42:14 <dolio> length . nub [1,2,3] = \x -> length (nub [1,2,3] x)
13:42:15 <Twey> Sorry guys, it's late >.>
13:42:28 <mekeor> dolio: AH, thx
13:43:30 <sipa> > length . nub $ [1,2,3]
13:43:34 <lambdabot>   mueval-core: Time limit exceeded
13:43:43 <dolio> That's a toughy.
13:44:04 <dolio> O(n^2) on 3 elements is like...
13:44:13 <dolio> Hold on....
13:44:14 <sipa> > length . nub $ [1,2,3]
13:44:18 <lambdabot>   3
13:45:21 <sipa> mekeor: maybe you want this:
13:45:26 <sipa> > length $ num [1,2,3]
13:45:28 <lambdabot>   Not in scope: `num'
13:45:32 <sipa> > length $ nub [1,2,3]
13:45:33 <lambdabot>   3
13:45:44 <Tomsik> > length . num $ [1,2,3]
13:45:45 <lambdabot>   Not in scope: `num'
13:45:50 <Tomsik> > length . nub $ [1,2,3]
13:45:51 <lambdabot>   3
13:52:18 <mekeor> sipa, Tomsik: THX :)
13:52:29 <Tomsik> I didn't do no thing!
13:53:12 <mekeor> Tomsik: ?
13:53:33 <mekeor> Tomsik: please dont say, that you are a bot ;)
13:54:55 <happy4crazy> hey everyone, new to the list
13:55:05 <happy4crazy> just started a haskelly blog that people might enjoy : monastic.io/
13:55:12 <Tomsik> I'm not, at all, really.
13:55:17 <happy4crazy> first post has some fun recursion + list monad stuff, enjoy :)
13:57:46 <mekeor> sipa, Tomsik: how is this "$"-operator (or whatever) called?
13:57:56 <mekeor> → how to google it?
13:58:24 <Saizan> you hoogle it
13:58:27 <Saizan> @hoogle $
13:58:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:58:29 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
13:58:29 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
13:58:44 <mekeor> Saizan: THX
13:58:52 <Saizan> @where hoogle
13:58:52 <lambdabot> http://haskell.org/hoogle
13:59:30 <mekeor> Saizan: i didnt know, hoogle supports special-characters
14:00:08 <mekeor> (→ unfortunately google also doesnt look for special-chars, like ".",",","@"... D:)
14:00:13 <Tomsik> $ is "money" for many
14:00:53 <Twey> And Google is unable to distinguish between ‘resume’ and ‘résumé’ :-\
14:00:59 <cheater99> mekeor: i was googling for "dollar operator" yesterday
14:01:07 <cheater99> or rather "dollar operator in haskell" :)
14:01:08 <Twey> Or ‘ano’ and ‘año’
14:02:12 <Tomsik> :t fmap (/) sin cos
14:02:14 <lambdabot> forall a. (Floating a) => (a -> a) -> a -> a
14:02:25 <Tomsik> fmap (/) sin cos 3
14:02:30 <Tomsik> > fmap (/) sin cos 3
14:02:30 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:02:31 <lambdabot>    arising from a use of `...
14:02:37 <Tomsik> whoops
14:03:19 <andy____> guys is there any way to use an `or` in a context declaration?
14:03:41 <monochrom> no
14:03:57 <Tomsik> > (/) <$> sin <*> cos 3
14:03:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
14:03:58 <lambdabot>    arising from a use of `...
14:04:00 <andy____> hmm, so I would have to declare a new class instance?
14:04:28 <Tomsik> > ((/) <$> sin <*> cos) 3
14:04:28 <lambdabot>   -0.1425465430742778
14:04:32 <Tomsik> > tan 3
14:04:33 <lambdabot>   -0.1425465430742778
14:04:37 <Tomsik> har!
14:04:40 <alderz> Twey: it seems that nobody noticed what 'ano' means in Spanish
14:04:52 <Twey> alderz: Seems so
14:05:15 <Saizan> i did
14:05:22 <Twey> The way Google treats diacritics as second-class citizens irritates me
14:05:29 <Twey> It's even worse in Chrome
14:06:41 <mekeor> which is faster? "(length $ nub LIST)==(length LIST)" OR "nub LIST==LIST"?
14:07:00 <mekeor> the 2nd one, isnt it?
14:07:04 <Heffalump> length
14:07:07 <Twey> The former, probably
14:07:08 <Heffalump> i.e. the first one
14:07:12 <Twey> Length is easier than a comparison
14:07:19 <Heffalump> the second one will do Eq comparisons on the elements
14:07:29 <mekeor> so, the fst one?
14:07:35 <ddarius> It depends on LIST
14:07:40 <Twey> Yeah
14:07:49 <mekeor> ddarius: how does it depend on this?
14:07:50 <Heffalump> oh, I guess the second might have an early exit
14:08:21 * Twey . o O (… on (==) length `ap` nub …)
14:08:38 <ddarius> > nub ('a':repeat 'b') == ('a':'a':repeat 'b')
14:08:39 <lambdabot>   False
14:08:48 <mekeor> ddarius: ???!?! WTF
14:08:49 <ddarius> > nub ('a':'a':repeat 'b') == ('a':'a':repeat 'b')
14:08:50 <lambdabot>   False
14:09:25 <ddarius> > length (nub ('a':'a':repeat 'b')) == length ('a':'a':repeat 'b')
14:09:40 <lambdabot>   thread killed
14:10:14 <mekeor> btw: LIST is [a] where a in Eq
14:11:13 <mekeor> ddarius: what did you try to show?
14:11:57 <Twey> mekeor: Yeah, we figured that
14:12:08 <Twey> The question is what a is and whether the list is infinite
14:12:46 <mekeor> the list is finite. a normaly is an integer or a char
14:13:10 <ddarius> > nub ["a", repeat 'b'] == ["a", repeat 'b']
14:13:12 <lambdabot>  Terminated
14:13:24 <ddarius> > length (nub ["a", repeat 'b']) == length ["a", repeat 'b']
14:13:25 <lambdabot>   True
14:13:57 <mekeor> what does this mean?
14:13:59 <ddarius> Clearly the correct solution is unamb.
14:14:03 <Twey> mekeor: It depends on the list.
14:14:04 <Twey> Haha.
14:14:14 <mekeor> :(
14:14:26 <mekeor> ddarius: unamb?
14:14:31 <mekeor> :t unamb
14:14:31 <lambdabot> Not in scope: `unamb'
14:14:50 <c_wraith> heh.  unamb would be the best choice...  if you have multiple CPUs :)
14:14:55 <c_wraith> (and aren't using them otherwise
14:14:56 <mekeor> "unambiguous choice"
14:15:05 <Twey> mekeor: For certain arrangements of elements, nub can decide early if the result is going to be False and hence be much faster than the length, which must go through the whole list
14:15:34 <Twey> unamb will execute both and return whichever one returns first ;)
14:15:58 <mekeor> XD  cool
14:16:06 <Tomsik> With a great overhead :p
14:16:14 <mekeor> coool!
14:18:03 <mekeor> http://www.haskell.org/haskellwiki/Unamb
14:21:45 <Twey> Tomsik: *handwaves* Just an implementation detail
14:26:14 <ymasory> Why don't haskell subclasses count as subtyping or inheritance? They look to me like both
14:27:19 <ddarius> Classes aren't types.
14:27:22 <Heffalump> mainly because they're statically resolved
14:27:29 <Heffalump> unless you also use existentials
14:27:49 <monochrom> yeah, classing is not typing, subclassing is not subtyping
14:28:17 <ymasory> That makes sense
14:29:07 <ymasory> So I can only use Eq to restrict a param type. Not as the param type itself?
14:29:16 <Cale> Also, the superclass constraints don't really give you anything like inheritance. They just force you to write the corresponding superclass instances.
14:29:23 <Cale> right
14:29:29 <taktoa> Hi guys
14:29:42 <taktoa> so I'm making a genetic algorithm in Haskell
14:29:53 <taktoa> and I'm hitting a brick wall
14:29:59 <taktoa> here's a paste
14:29:59 <taktoa> http://hpaste.org/45989
14:30:15 <dobblego> ymasory: yes, this is unlike scala where Eq may be implicit or explicitly passed as an argument
14:30:17 <Cale> Classes are used to constrain type variables so that they range over only those types which support a given interface
14:30:18 <taktoa> problem is described in comment at bottom
14:30:41 <augustss> Cale: it's a little like inheritance, you can use superclass methods without specifying the superclass constraint.
14:30:45 <taktoa> problem areas seem to include Tests and runGen(')
14:30:50 <sipa> Cale: they do give you something... if i have a value of type SubClass c => c, and class SuperClass => SubClass, then i know i can apply methods from both SubClass and SuperClass on that value
14:31:00 <Cale> augustss: yeah, there is that
14:31:06 <ymasory> Thank you. But don't typeclasses like Show have a default implementation they come with? That isn't inheritance?
14:31:18 <taktoa> thanks in advance
14:31:41 <Cale> But it's not like inheritance where you don't have to implement the superclass methods.
14:31:51 <mauke> ymasory: no and no
14:32:16 <Cale> ymasory: That's just built-in automatic code generation
14:32:36 <ymasory> Ah. Ok thanks
14:32:37 <Cale> The compiler writes some code for you based on the structure of the type
14:33:05 <Cale> taktoa: There are tab characters in your code. Make sure to configure your text editor properly to convert tabs to spaces.
14:33:21 <Cale> (but that's unrelated to your problem right now)
14:34:18 <Cale> taktoa: I would recommend trying to avoid using the head function altogether.
14:34:43 <Cale> Instead, favour pattern matching which will force you to handle the case of an empty list properly.
14:35:08 <Cale> But let's look at where you used that function and try to see why it might be okay/not okay to use head in each case
14:35:18 <taktoa> well, I'm only using head to pick out the best chromosome of the list
14:35:27 <Cale> in fillInPop, you have  head sortedPop
14:35:35 <Cale> Why must sortedPop be nonempty?
14:36:09 <taktoa> good point
14:36:57 <Cale> If the pop parameter to fillInPop is the empty list, then popSize will be 0, and if neededSize is positive, then popSize < neededSize, and lessThan will be computed, which will eventually result in head sortedPop, and sortedPop will be empty because pop is
14:36:57 <taktoa> but the output _must_ be a certain size
14:37:35 <taktoa> so should I set fillInPop to output an IO Population
14:37:52 <Cale> What I/O are you thinking of doing?
14:37:58 <taktoa> and make a new population if it's empty
14:38:01 <taktoa> well random stuff
14:38:15 <taktoa> literally _random_
14:38:44 <Cale> I suppose you could do that.
14:38:55 <Cale> You could also make it take/produce a StdGen
14:40:31 <Cale> You could also define a Population to be necessarily nonempty, though that might be awkward.
14:41:57 <Cale> It might be nice to use the Control.Monad.Random library from http://hackage.haskell.org/package/MonadRandom
14:42:05 <osfameron> lpsmith: http://en.wikipedia.org/wiki/Spreadsheet gives some more details under LANPAR
14:42:21 <taktoa> hrm
14:42:25 <DevHC> i have a feeling that u should replace "round" with "round upwards"
14:42:27 <osfameron> lpsmith: I remember reading about it, way back, when I was attempting to implement a spreadsheet in... of all things... j2me
14:42:35 <taktoa> well I changed it to IO Population
14:42:40 <taktoa> made necessary changes 
14:42:57 <taktoa> and it now just shows infinite empty lists
14:43:03 <taktoa> stuck in iterate
14:43:09 <taktoa> which is odd
14:43:12 <dataangel> I have "import qualified XMonad.Layout.SimpleDecoration as SimpleDecoration" in my source file, but if I then reference "SimpleDecoration.Transformer", it complains that it's not in scope. How are you supposed to use qualified names?
14:43:24 <taktoa> because I do "iterate ... !! n"
14:43:31 <taktoa> so it shouldn't go infinitely
14:44:05 <Cale> let pop = (iterate (runGen' cfg) (makeInitChroms cfg)); apop <- pop !! fromIntegral iters
14:44:10 <Cale> what is the idea of that code?
14:44:11 <jmcarthur> defaulting as making my rewrite rules less polymorphic. is there anything i can do about that?
14:44:16 <taktoa> unless makeInitChroms is the problem
14:44:22 <jmcarthur> i can't seem to force it not to default
14:44:32 <taktoa> it's supposed to find the nth generation of chromosomes
14:44:38 <jmcarthur> *is making
14:45:16 <taktoa> Cale: that is precisely the code I currently have
14:45:26 <Cale> taktoa: I know, I copy/pasted it
14:45:30 <taktoa> since I had to do a few changes to accomodate an IO population
14:45:34 <Cale> You're making a list of IO actions
14:45:36 <taktoa> oh, ok
14:45:40 <Cale> and then running one of them
14:45:44 <taktoa> yes
14:46:06 <Cale> It may make more sense to just make the one IO action that you're interested in :)
14:46:06 <taktoa> the nth generation of chromosomes
14:46:16 <taktoa> well it has to do many generations
14:46:21 <Cale> Perhaps what you're looking for is replicateM
14:46:40 <taktoa> shouldn't it cascade down though?
14:46:46 <taktoa> ie:
14:46:55 <taktoa> iterate f n
14:47:02 <taktoa> where f is an IO function
14:47:08 <taktoa> that takes its output
14:47:22 <taktoa> and you run !! x on that
14:47:32 <taktoa> then x should be f f f f... n
14:47:35 <taktoa> err
14:47:40 <taktoa> !! x should be that
14:47:49 <taktoa> so it should cascade down
14:48:00 <taktoa> do you get what I'm saying?
14:48:07 <Cale> whoa whoa...
14:48:24 <Cale> runGen' is calling itself with  return filledIn  as the IO action...
14:48:45 <taktoa> yes
14:49:00 <taktoa> the output of runGen' is fed to runGen' again and so on
14:49:19 <taktoa> and the nth application is outputted
14:49:21 <Cale> This is horribly nonidiomatic :P
14:49:33 <Cale> okay
14:49:36 <taktoa> it's hard to do otherwise
14:49:48 <taktoa> at least I couldn't find a way to do it otherwise
14:50:06 <Cale> Let's make  runGen' :: GConfig -> Integer -> [Chromosome] -> IO [Chromosome]
14:50:31 <taktoa> had that for a while
14:50:38 <Cale> runGen' cfg 0 chrom = return chrom
14:50:53 <Cale> if there are no iterations, we just return the input chromosome
14:51:00 <taktoa> right
14:52:10 <Cale> runGen' cfg iters chrom = do chrom' <- generation cfg chrom; runGen' cfg (iters - 1) chrom'
14:53:40 <Cale> That's a bit crude (direct recursion), but it's at least idiomatic :)
14:54:45 <taktoa> I see
14:54:56 <taktoa> much cleaner
14:55:06 <taktoa> I guess I forgot to apply the SRP
14:57:59 <taktoa> well
14:58:00 <taktoa> http://hpaste.org/paste/45989/geneticalg_annotation#p45990
14:58:02 <Cale> It would also be possible to write it as a foldM:   runGen' cfg iters chrom = foldM (generation cfg) chrom [1..iters] where generation :: Chromosome -> Integer -> IO Chromosome
14:58:08 <Cale> er, oops
14:58:15 <taktoa> there's the updated genetic code
14:58:18 <Cale> need a GConfig parameter in the type of generation
14:58:24 <taktoa> and it still outputs the same error
14:58:27 <taktoa> ok
14:59:54 <Cale> What text editor are you using?
14:59:58 <taktoa> geany
15:00:37 <taktoa> oh, sorry about the tabs
15:00:52 <Cale> http://www.geany.org/manual/current/index.html#editor-indentation-preferences
15:01:05 <Cale> ^^ make that "Spaces" :)
15:01:09 <taktoa> I just change it
15:01:12 <taktoa> *changed
15:01:22 <Cale> Oh, I have to go to dinner
15:01:28 <taktoa> ok
15:01:37 <taktoa> notify me when you return
15:03:43 <gigamonkey> According to this http://www.haskell.org/haskellwiki/Newtype newtype solves the problem that types defined with data, even with a single constructor and a single field, have their own distinct bottom.
15:03:51 <gigamonkey> Are there times when you want that?
15:04:17 <gigamonkey> I.e. why not just define the meaning of data with a single constructor and field to be what newtype means now?
15:04:36 <gigamonkey> (I'm sure there's a reason; just trying to understand.)
15:05:22 <Veinor> i assume part of the reason is that then it'd be inconsistent with data with multiple constructors
15:06:20 <jmcarthur> sometimes you want to introduce a new bottom
15:06:21 <gigamonkey> Veinor: that's certainly a possible reason.
15:06:57 <gigamonkey> jmcarthur: can you give an example of how that's useful?
15:07:10 <tarrasch> I'm an Ubuntu 10.10 user, what's the simplest way to get the latest ghc 7, I don't want to be stuck with the old Ubuntu repos ghc 6.12.
15:08:57 <jmcarthur> data Thunk a = Thunk a; data Pair a b = Pair !a !b; type FstStrict a b = Pair a (Thunk b)   -- contrived, i know
15:09:00 <taktoa> compile from source
15:09:56 <tarrasch> taktoa, is there any `cabal install ghc` or similiar?
15:11:12 <taktoa> nope
15:11:17 <taktoa> not that I know of
15:11:18 <gigamonkey> jmcarthur: thanks. I'll meditate on that.
15:13:24 <Saizan> tarrasch: get the binary tarball from ghc's website
15:15:22 <Hugglesworth> does anyone have proper audoindent in vim? and how?
15:15:24 <ddarius> jmcarthur: Less contrived, data HeadStrictList a = Nil | Cons !a (HeadStrictList a); type LazyList a = HeadStrictList (Thunk a)
15:15:29 <ddarius> set ai
15:16:30 <Locke1689> In a function pattern matching, is there any way to declare manually that the pattern match has failed and Haskell should continue matching?
15:16:57 <tarrasch> Locke1689, no
15:17:08 <tarrasch> Locke1689, maybe you can use guards instead?
15:17:13 <jmcarthur> gigamonkey: ^^ check out ddarius's superior example
15:17:15 <dino-> Locke1689: Not sure if I'm following. But maybe this is similar. Sometimes I'll use a combination of pattern matching and guards.
15:17:23 <Locke1689> tarrasch: Yeah I'll do that
15:17:56 <Locke1689> seems like it could be useful to declare a value _|_ and if any function evaluates to that, then the pattern match fails
15:18:01 <tarrasch> Locke1689, you mean that even 'passing' the guards it should after that realize it failed the pattern match and continue match on the matches below?
15:18:04 <Locke1689> but yeah, guards are a decent choice
15:18:15 <Locke1689> tarrasch: Right.
15:18:32 <tarrasch> Locke1689, well, combining Nothing and mconcats you get a functionality like that
15:18:45 <Locke1689> Hmm true I didn't think of that
15:18:47 <tarrasch> Locke1689, given you return nothing when you fail
15:18:54 <Locke1689> yeah
15:19:03 <tarrasch> Nothing*
15:19:07 <Locke1689> sticking it in a Maybe monad wasn't really what I had in mind though
15:19:25 <tarrasch> Locke1689, however, how can your logic be so that you can't just use guards?
15:20:10 <Locke1689> It wasn't cant, it was just a tad obnoxious
15:20:16 <tarrasch> Locke1689, I mean, if you can express failure after the guards, you should as well be able to express in the guards
15:20:18 <Locke1689> I just found Pattern guard syntax
15:20:30 <Locke1689> which looks to be exactly what i was looking for
15:21:57 <tarrasch> Locke1689, hmm, haven't seen that ... I've always wondered if haskell2010 is something conrete I'll ever notice it's differences. And there i go ...
15:22:11 <Locke1689> :)
15:22:39 <Locke1689> Yeah I'm writing a compiler and I had to deal with some obnoxious register spilling errors
15:24:46 <tarrasch> well, far past my bedtime, nice to meet you and all Locke1689  :)
15:25:31 <Blue_> @pl (\x y z -> x . y . z)
15:25:31 <lambdabot> (. (.)) . (.) . (.)
15:25:52 <Blue_> @unpl (. (.)) . (.) . (.)
15:25:52 <lambdabot> (\ m s g j -> m (s (g j)))
15:27:12 <Blue_> @pl (\a b c d e f g h i j k l m n o p q r s t u v w x y z -> a b c d e f g h i j k l m n o p q r s t)
15:27:12 <lambdabot> ((((((((((((((((((((const . const . const . const . const . const) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .)
15:28:06 <mekeor> > null []
15:28:07 <lambdabot>   True
15:41:09 <tomh> mm is there an intToFloat function or something?
15:41:30 <mauke> fromIntegral
15:41:35 <tomh> ah that was the one
16:05:41 <mekeor> is there a shorter alternative to "`notElem`"?
16:06:14 <mauke> why?
16:06:36 <ddarius> mauke: Because people are fucking crazy.
16:07:22 <mekeor> > me == "fucking crazy"
16:07:23 <lambdabot>   Not in scope: `me'
16:07:27 <mekeor> :)
16:07:41 <Veinor> you don't exist!
16:07:46 <mekeor> xD
16:07:59 <mekeor> LOl
16:08:39 <siracusa> mekeor: There's ∉ in package base-unicode-symbols
16:08:52 <Heffalump> > let is anything at all = False in is "mekeor" "fucking" "crazy"
16:08:53 <lambdabot>   False
16:09:00 <KirinDave> Does Haskell allow for "partial functions" like Scala does?
16:09:17 <aristid> Heffalump: how anti
16:09:17 <ClaudiusMaximus> > head []
16:09:19 <lambdabot>   *Exception: Prelude.head: empty list
16:09:39 <aristid> KirinDave: how does scala do it? haskell for sure allows partial functions.
16:09:48 <KirinDave> aristid: http://www.scala-lang.org/api/current/index.html
16:09:52 <aristid> but the gaps have be to the right.
16:10:00 <KirinDave> When they're defined they get isDefinedAt filled in by the compiler.
16:10:19 <aristid> ?
16:10:41 <mauke> KirinDave: cool, a non-working web page
16:10:45 <mauke> scala--
16:10:45 <copumpkin> KirinDave: sure, but not as a primitive
16:10:47 <KirinDave> Ahh sorry
16:10:48 <KirinDave> yeah
16:10:54 <KirinDave> effing scaladoc
16:11:10 <copumpkin> partial function is just Kleisli Maybe a b ;)
16:11:17 <KirinDave> http://www.scala-lang.org/api/current/scala/PartialFunction.html
16:11:23 <aristid> oh.
16:11:26 <copumpkin> except it has some extra fancy shit to ask the function whether it can handle it or not
16:11:31 <KirinDave> copumpkin: Yes.
16:11:33 <copumpkin> rather icky
16:11:42 <KirinDave> copumpkin: You know where they're super awesome?
16:11:43 <aristid> a -> Maybe b works.
16:11:47 <copumpkin> KirinDave: nope!
16:11:55 <copumpkin> collect?
16:12:02 <KirinDave> copumpkin: Defining receive handlers for actors.
16:12:09 <copumpkin> aha
16:12:15 <copumpkin> luckily we don't do actors in these here parts
16:12:19 <copumpkin> :)
16:12:33 <KirinDave> copumpkin: Seems like I can find a few people who would disagree.
16:12:52 <aristid> KirinDave: they're not in copumpkin's "here parts", presumably.
16:12:59 <KirinDave> No true scottsman, etc. ;)
16:15:29 <copumpkin> KirinDave: damn right
16:15:44 <copumpkin> IN THESE HERE PARTS WE DO STM AND WE LOVE IT
16:15:49 <copumpkin> KIRINDAVE: DO YOU LOVE IT?
16:16:28 * ddarius doesn't much care for STM.
16:16:32 <KirinDave> copumpkin: STM is hardly a replacement for actors.
16:16:48 <companion_cube> the reverse can be true either
16:17:00 <ddarius> s/either/as well
16:17:02 <copumpkin> STM!!! MVARS!!! PAR!!! AND WE LOVE IT
16:17:04 <KirinDave> Right.
16:17:14 <KirinDave> There is no doubt that par and mvars are neat.
16:17:15 * copumpkin froths at the mouth a bit and goes to sleep
16:17:36 <KirinDave> Still, erlang's actor model is really good, easily producible in haskell, and is amenable to really nice failure strategies.
16:17:49 <monochrom> use a thread for an actor. use mvar-based channels to connect actors
16:17:53 <companion_cube> hmmm, sorry for my english
16:18:19 <Veinor> companion_cube: hahahah
16:18:26 <Veinor> ... copumpkin: see above
16:20:11 <KirinDave> monochrom: Yes, we could implement actors in haskell.
16:20:16 <KirinDave> monochrom: People have. :)
16:20:43 <KirinDave> Some types of systems benefit a lot from being turned into actor systems. I will end my rant there. :)
16:21:14 <Twey> KirinDave: STM is a fine replacement for actors
16:21:21 <Twey> Also, more efficient ;)
16:21:23 <KirinDave> Twey: I disagree strongly.
16:21:28 <KirinDave> Twey: I also disagree strongly. :)
16:21:47 <Twey> *shrug* The Shootout doesn't agree with you
16:22:13 <Twey> Haskell threads have *much* less overhead than Erlang threads.
16:22:22 <KirinDave> There's no doubt that's true.
16:22:32 <KirinDave> That's sort of besides the point.
16:22:41 <KirinDave> There is value in models as techniques, apart from implementations.
16:22:42 <ddarius> Haskell threads have nothing to do with STM.
16:22:53 <companion_cube> I think scala is going to get STM too
16:23:17 <Twey> And the only real semantic difference between Haskell threads with Chans and so on and Erlang threads is that in Haskell we pass the channel explicitly
16:23:30 <Twey> So long as it's within the same process, anyway
16:23:31 <copumpkin> Veinor: see what? :O
16:23:39 <ddarius> Twey: This is irrelevant to KirinDave's point.
16:23:44 <Veinor> see my 'hahahahahah'
16:26:56 <mekeor> can i type "import foo, bar, foobar" ??
16:27:08 <ddarius> No.
16:27:12 <mekeor> :(
16:27:29 <Veinor> i always thought that was annoying
16:27:33 <mekeor> so, i have to type:
16:27:34 <mekeor> import foo
16:27:34 <mekeor> import bar
16:27:34 <mekeor> import foobar
16:27:34 <mekeor> ?
16:27:40 <ddarius> That's illegal as well.
16:27:45 <mekeor> ??
16:27:58 <ddarius> Module names must start with upper case letters.
16:28:04 <mekeor> ohj
16:28:06 <mekeor> yes
16:28:07 <mauke> import Foo; import Bar; import Foobar
16:28:07 <ddarius> Also, you can write more than one import statement on a line.
16:28:12 <mekeor> a
16:28:13 <mekeor> k
16:28:45 <Veinor> ddarius: how? using mauke's construction?
16:28:50 <ddarius> Yes.
16:32:08 <mekeor> "mauke's construction"?
16:32:14 <Veinor> 19:47:03            <mauke> import Foo; import Bar; import Foobar
16:32:27 <mekeor> cool — C-style…!
16:32:44 <mauke> no, you can't do this in C
16:32:53 <ddarius> C doesn't have a module system.
16:33:11 <mekeor> but the semikolon is C-style……!
16:33:19 <mauke> no
16:33:22 <mekeor> ";"
16:33:22 <mauke> C uses newlines
16:33:29 <mekeor> mauke: NO!!!
16:33:32 <mauke> yes
16:33:42 <mekeor> mauke
16:33:51 <chronoslynx> C: #import <blah>
16:33:56 <mekeor> yes, yes
16:33:57 <mauke> chronoslynx: no
16:34:05 <mekeor> #include
16:34:07 <mekeor> yes
16:34:08 <mekeor> but
16:34:27 <chronoslynx> sorry, I always get import/include mixed up
16:34:29 <mauke> mekeor: did you know you could write more than one word per line on IRC?
16:34:32 <mekeor> in C you always have semicolons, i mentioned that... however, it doesnt matter..
16:34:39 <mekeor> mauke: SRY
16:35:15 <mekeor> mauke: that happens, when i panic a bit :)
16:36:17 <McManiaC> do { foo; bar; moep; } <- valid haskell ;)
16:37:01 <mekeor> McManiaC: really? COOL! — i didnt know that…
16:37:25 <McManiaC> it's not that common :P
16:37:42 <Twey> And the last semicolon is totally redundant
16:37:44 <McManiaC> GHC has a lot of source code using that ; style tho
16:37:50 <luite> it's semicommon
16:37:55 <Twey> Hah
16:38:02 <McManiaC> hehe
16:38:30 <monochrom> do { ;;; foo ;;;;; bar;;;;;; hello;;;;; }  also valid haskell
16:38:43 <ddarius> > let ;;;;;;;;;;;;;;;;;;;;;;;;;;;;; in 3
16:38:44 <lambdabot>   3
16:39:13 <McManiaC> > let in 3
16:39:13 <Twey> Heh
16:39:14 <lambdabot>   3
16:39:16 <McManiaC> :>
16:39:23 <ian_mi> > 3
16:39:24 <lambdabot>   3
16:39:31 <Twey> ian_mi wins ;)
16:39:35 <McManiaC> let ;let;let;in;in; in 3
16:39:39 <Twey> >3
16:39:47 <Twey> Aw :þ
16:39:49 <mekeor> LOL — that's cool, since i love C-syntax *g*
16:39:58 <Twey> mekeor: You strange person
16:40:03 <McManiaC> no you don't :>
16:40:04 <Twey> (or other sentient lifeform)
16:40:25 <mekeor> Twey: y?
16:40:38 <Twey> Sorry?
16:40:49 <djahandarie> > let ;let;let;in in 3
16:40:50 <lambdabot>   <no location info>: parse error on input `in'
16:41:07 <djahandarie> > let ;let;let in in 3
16:41:07 <lambdabot>   <no location info>: parse error on input `in'
16:41:10 <djahandarie> Hmm
16:41:17 <Twey> I don't think let; let is valid
16:41:19 <McManiaC> > let ;let;let;in;in; in 3
16:41:20 <lambdabot>   <no location info>: parse error on input `;'
16:41:23 <Twey> Needs a pattern
16:41:31 <Twey> Or an ‘in’
16:41:41 <McManiaC> ah right
16:41:47 <Twey> You could probably do it in a do-block
16:41:52 <Twey> > do { let; let; let; 3 }
16:41:53 <lambdabot>   <no location info>: parse error on input `}'
16:41:59 <Twey> Aw, maybe not
16:42:05 <shachaf> > let in let in let in 3
16:42:06 <lambdabot>   3
16:42:39 <ian_mi> > let 3 = 3 in 3
16:42:40 <lambdabot>   3
16:42:46 <ddarius> > do;do;do;do;3
16:42:47 <lambdabot>   3
16:43:10 <djahandarie> > let;3=let;;;;;in let;;;;;;;3=let;in 3;in 3
16:43:10 <lambdabot>   not an expression: `let;3=let;;;;;in let;;;;;;;3=let;in 3;in 3'
16:43:21 <djahandarie> Wait what? That just ran in ghci
16:43:27 <djahandarie> Ah
16:43:37 <ddarius> Congratulations on figuring out why.
16:43:37 <djahandarie> > let;3=let;;;;;in let;;;;;;;3=let;in 3;in 3 in 3
16:43:38 <lambdabot>   3
16:44:20 <danharaj> Is anyone familiar with the Repa library here?
16:44:39 <azaq23> > let 4 = 5 in let 5 = 4 in 5 + 2
16:44:40 <lambdabot>   7
16:46:03 <mekeor> > let 4 = 5 in 4+1
16:46:05 <lambdabot>   5
16:46:20 <HugoDaniel> hi
16:46:28 <shachaf> > let !4 = 5 in 4
16:46:28 <mekeor> hello 
16:46:29 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
16:51:09 <djahandarie> > let;;;;;;;іn="let";;;;;lеt=let;;;;;in let;;;;;;;lеt=let;in lеt;in lеt in іn
16:51:10 <lambdabot>   "let"
16:54:33 <shachaf> > let in let in lеt
16:54:35 <lambdabot>   in let in let in
16:54:55 <djahandarie> Hey, self-contained at least :p
16:58:41 <danharaj> Is there a way to ask ghci to tell me the actual name of a type in a type family?
17:00:38 <danharaj> dons can you point me to a person who knows how repa works @_@
17:02:57 <Necrosporus> What is round $ ?
17:03:04 <Necrosporus> Why does it use $?
17:03:08 <danharaj> :t round $
17:03:09 <lambdabot> parse error (possibly incorrect indentation)
17:03:15 <danharaj> :t (round $)
17:03:16 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:03:25 <Necrosporus> :t round $ 23
17:03:27 <lambdabot> forall b. (Integral b) => b
17:03:27 <danharaj> It is just round, but $ changes the associativity.
17:03:41 <danharaj> for example, round foo * bar
17:03:48 <danharaj> is (round foo) * bar
17:03:52 <Necrosporus> :t round
17:03:53 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:03:56 <danharaj> while round $ foo * bar
17:04:01 <danharaj> is round (foo * bar)
17:04:13 <Necrosporus> So haskel uses $ instead of ()?
17:04:30 <danharaj> you can use parentheses too, but sometimes $ is cleaner.
17:05:15 <danharaj> you can also do things like... let's say you have a list of functions funs :: [Foo -> Bar] and you want to apply all of them to a particular Foo, x.
17:05:24 <danharaj> that would be map ($ x) funs
17:06:00 <dons> danharaj: hey
17:06:09 <danharaj> dons. I like Repa but I don't know how to use it XD
17:06:11 <dons> danharaj: ben lippmeier (aka benl)
17:06:20 <dons> danharaj: have you read mjsottile's tutorial?
17:06:28 <dons> (repa badly needs a tutorial)
17:06:41 <danharaj> There's a tutorial? I found the hackage docs and the paper, but not a tutorial.
17:06:42 <dons> http://syntacticsalt.com/2011/02/13/getting-started-with-repa/ 
17:06:53 <danharaj> godsend.
17:07:14 <danharaj> See, I thought I had it figured out, but I'm getting awful, awful type errors when I try to use slices. So I don't understand slices.
17:07:20 <dons> right.
17:07:25 <dons> they're the tricky thing
17:07:47 <danharaj> I think... I dislike type families because of this. On one hand, they let you do magical things like repa. But then you get C++ Template Disease.
17:08:24 <dons> it definitely pushes haskell that way
17:09:25 <danharaj> Then again, that just might be GHC's general lack of descriptive error messages. I know when I first tried learning Haskell I was pushed away by the inscrutable (to a novice) errors. I'm getting that feeling again when trying out libraries using advanced type extensions :p
17:09:47 <copumpkin> I think repa is a little beyond what haskell's types can handle, myself
17:10:11 <danharaj> It uses template haskell too, right?
17:10:13 <HugoDaniel> hi
17:10:20 <copumpkin> not that I know of
17:10:24 <danharaj> It's a dependency.
17:10:26 <HugoDaniel> i want to write a blog article about hints and tips for ghci
17:10:46 <danharaj> HugoDaniel: a noble endeavor. ghci is easily one of the biggest selling points of Haskell.
17:10:56 <HugoDaniel> do you have any ghci time savers that i could write about ?
17:11:31 <danharaj> This is a trivial one but the fact that you can abbreviate the commands like :load, :type, :reload, etc. by their first letter is indispensable.
17:12:45 <HugoDaniel> ah yeah, cool
17:12:46 <HugoDaniel> .)
17:12:48 <HugoDaniel> :)
17:12:50 <HugoDaniel> ok
17:13:07 <sm> HugoDaniel: great idea, write a series
17:13:24 <HugoDaniel> yeah
17:13:38 <HugoDaniel> libreadline is a whole episode :) lots of little feats that i think most people dont use
17:13:41 <HugoDaniel> like ctrl+r
17:13:48 <HugoDaniel> or alt+bspc
17:13:50 <HugoDaniel> stuff like that
17:13:54 <HugoDaniel> real time savers
17:14:39 <sm> I do everything in emacs, so it's M-r and M-p here
17:15:03 <HugoDaniel> :)
17:15:04 <sm> M-r and M-backspace I mean
17:15:28 <HugoDaniel> yeah, i heard emacs also has a great libreadline support
17:15:31 <djahandarie> Whoa, Ctrl+r is cool
17:15:44 <sm> I don't see how you can have a productive interactive session without easy search and scroll through your history
17:15:59 <danharaj> oiii..... what the hell. Why do I have to write (Z :. All :. (2::Int)) instead of (Z :. All :. 2) :(
17:18:25 <Mathnerd314> because it defaults to Integer and not Int ?
17:18:32 <dons> yeah
17:18:43 <dons> and things go wrong
17:19:21 <danharaj> gross.
17:19:31 <ddarius> default(Int)
17:19:44 <danharaj> The error I got for that gem was about 10 lines long of "oh god so many instances are missing what are you doing"
17:22:25 <danharaj> still... I feel like Repa is the "Right Way of Doing Things" when it comes to numerical  data. It feels good.
17:23:23 <ddarius> Don't worry.  Another "Right Way" will come along before too long.
17:23:33 <dons> i'll make a wiki page for you, and you can add some of your notes to it.
17:24:58 <danharaj> ddarius: Is that just a general observation of human nature or do you know something about numerical haskell that I don't :p
17:26:56 <dons> http://haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial 
17:26:58 <dons> add notes as you go
17:27:49 <danharaj> seems like a good time to make a haskellwiki account :p
17:27:56 <dons> please!
17:28:04 <dons> and you can steal examples from the vector tutorial.
17:28:44 <danharaj> For now I'll add notes to the discussion page, and when I'm done with all this silly stuff I'm doing I'll put it together into a nice tutorial.
17:29:32 <dons> thanks! this will benefit a lot of people
17:29:53 <danharaj> also seems like a great time to learn how to use wiki software :p
17:35:55 <djanatyn> Can you have elseif in Haskell?
17:36:28 <jmcarthur> try guards
17:36:43 <danharaj> djanatyn: I'm not sure, but in general you don't want to work with if then else.
17:37:07 <jmcarthur> guards!
17:37:10 <danharaj> word.
17:37:30 <HugoDaniel> djanatyn: if's in haskell are treated as an expression, which is cool if you use them for short stuff
17:37:32 <danharaj> Pattern Guards are one of my favorite extensions. Because they're pragmatic, simple, and lovely when they're just right.
17:38:20 <djanatyn> HugoDaniel: Yeah, that's what I'm trying to use it for.
17:38:30 <djanatyn> Could I have...an if statement nested inside an if statement? O_o
17:38:42 <HugoDaniel> things like 1 + if x > 2 then 3 else 4
17:38:46 <HugoDaniel> they are very nice :)
17:39:05 <HugoDaniel> djanatyn: sure
17:39:08 <HugoDaniel> just remember that
17:39:30 <HugoDaniel> every if must have a "then" and an "else", there are no if's with just one then and no else
17:39:43 <HugoDaniel> and that in haskell indentation defines the statement block
17:39:44 <HugoDaniel> so
17:40:02 <HugoDaniel> just indent them properly, and you'll be fine
17:40:14 <djanatyn> I don't really understand Haskell indentation that well
17:40:24 <HugoDaniel> djanatyn: its very easy and practical
17:40:29 <djanatyn> Usually I have my if statements spread across one line
17:40:37 <HugoDaniel> ok
17:41:06 <HugoDaniel> thats nice, but usually you can split that line into multiple lines without problems
17:41:50 <danharaj> if you are nesting if then clauses, you should consider using guards
17:42:05 <danharaj> they're probably cleaner.
17:42:32 <HugoDaniel> danharaj: guards can be problematic if they are not use properly
17:42:57 <HugoDaniel> if you fail to match all patterns
17:42:57 <HugoDaniel> :/
17:44:15 <djanatyn> hmm
17:44:20 <djanatyn> what is ghci on acid?
17:44:57 <danharaj> HugoDaniel: GHC will catch any missing patterns, and the last line in a guard should be 'otherwise'
17:45:03 <dolio> It's an old setup to get a bunch of lambdabot plugins into ghci.
17:45:11 <djanatyn> oh, I see
17:48:20 <ddarius> Someone should write a Catch plugin.
17:49:22 <djanatyn> hmm, I think I'm starting to understand this.
17:50:37 <djanatyn> when you have a statement, like [ (a,b,c) | a <- (expression), b <- (expression), c <- (expression)], does that generate values in the list for when all expressions are true?
17:50:56 <djanatyn> as in...does it go through every possible list value that could be true, and come up with every single combination?
17:51:20 <dolio> What does "true" mean here?
17:51:27 <djanatyn> > length [(a,b,c) | a <- [1,2], b <- [1,2], c <- [1,2]]
17:51:28 <lambdabot>   8
17:51:38 <djanatyn> dolio: I'm not sure yet ;)
17:51:57 <djanatyn> I'm just wondering how haskell is figuring out and combining all of these values into a list
17:52:16 <ddarius> @undo [ (a,b,c) | a <- (expression), b <- (expression), c <- (expression)]
17:52:16 <lambdabot> concatMap (\ a -> concatMap (\ b -> concatMap (\ c -> [(a, b, c)]) (expression)) (expression)) (expression)
17:52:18 <Cale> djanatyn: Each of the expressions there will be a list
17:52:26 <Cale> djanatyn: It chooses elements from the lists in all possible ways
17:52:28 <djanatyn> like, does it go through all the values specified for a, keeping b and c at their default, then go through all the values for b, keeping a and c at their default?
17:52:34 <djanatyn> How does it go through that?
17:52:42 <djanatyn> > [(a,b,c) | a <- [1,2], b <- [1,2], c <- [1,2]]
17:52:43 <lambdabot>   [(1,1,1),(1,1,2),(1,2,1),(1,2,2),(2,1,1),(2,1,2),(2,2,1),(2,2,2)]
17:52:45 <ddarius> Lists don't have "defaults."
17:53:08 <djanatyn> So, can I add additional conditions to the right of the |?
17:53:15 <Cale> yes
17:53:19 <djanatyn> Wow, that's awesome. :D
17:53:28 <taktoa> Cale: I'm back
17:53:33 <Cale> > [(a,b,c) | a <- [1,2], b <- [1,2], c <- [1,2], a + b + c = 5]
17:53:34 <lambdabot>   <no location info>: parse error on input `='
17:53:37 <Cale> > [(a,b,c) | a <- [1,2], b <- [1,2], c <- [1,2], a + b + c == 5]
17:53:38 <lambdabot>   [(1,2,2),(2,1,2),(2,2,1)]
17:53:44 <djanatyn> :o
17:53:49 <djanatyn> Haskell continues to amaze me -_-
17:53:52 <Cale> (it just tries all possibilities)
17:54:01 <djanatyn> Hmm. Does it do that efficiently? :)_
17:54:04 <Cale> no
17:54:08 <Cale> It just tries them all
17:54:24 <taktoa> well, actually I've had some pretty good results efficiency wise with that
17:54:28 <Cale> > [(a,b,c) | a <- [1..20], b <- [1..20], c <- [1..20], a^2 + b^2 == c^2]
17:54:29 <djanatyn> heh heh :)
17:54:29 <lambdabot>   [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(8,15,17),(9,12,15),(12,5,13),...
17:54:53 <Cale> > [(a,b,c) | a <- [1..20], b <- [a..20], c <- [b..20], a^2 + b^2 == c^2]
17:54:54 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
17:54:58 <HugoDaniel> :)
17:55:07 <taktoa> I once made a program thtat checked every different combination of resistors and capacitors for an oscillator to get a frequency
17:55:17 <taktoa> in C# it was slow as molasses
17:55:22 <taktoa> reimplemented in Haskell
17:55:27 <taktoa> it was fast as shite
17:55:28 <Cale> Aren't there a continuum of those? :)
17:55:28 <djanatyn> I'm starting to wonder why more people don't take the time to learn Haskell. It's so...powerful.
17:55:32 <taktoa> took less than a second
17:55:34 <HugoDaniel> :)
17:55:36 <djanatyn> You can write anything with it with such small code >_>
17:55:46 <hpc> djanatyn: social and mental inertia
17:55:51 <danharaj> It's also friggin hard.
17:55:53 <HugoDaniel> taktoa: same thing happens to me when i reimplement java code in haskell :)
17:55:59 <djanatyn> At first I was just messing around with haskell and I didn't like it very much
17:56:00 <hpc> "nobody else is using it" + "i already know this" + "this is hard"
17:56:13 <djanatyn> I kept wanting to actually compile a program instead of playing in ghci because I was used to C
17:56:18 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
17:56:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:56:23 <djanatyn> I was upset because LYAH never actually wrote a program :)
17:56:26 <taktoa> that's why I urge beginners to programming to start with Haskell
17:56:40 <danharaj> In other languages even if you don't understand a problem you can still mangle your way through and produce a broken implementation, and then fix it.
17:56:46 <hpc> Cale: i've been meaning to write a lazy infinite sieve and never found time
17:56:48 <danharaj> In Haskell you have to understand the problem or you won't even get your types right.
17:56:48 <taktoa> "refactoring"
17:56:50 <djanatyn> Later on I was bored so I just started to go through the beginning, doing exactly what it said, and I learned to do things I couldn't do before :P
17:56:54 <hpc> Cale: or a good approach, for that matter....
17:57:12 <djanatyn> I went and showed a friend my solution to the first Project Euler question in Haskell
17:57:15 <Cale> I like the mutual recursion in that one
17:57:15 <djanatyn> He thought it was pretty awesome
17:57:24 <taktoa> though interestingly there are many possible implementations for a different problem in Haskell
17:57:29 <Cale> primes defined using isPrime which is defined using primes :)
17:57:32 <adamvh> danharaj: Right, using repa is quite a bit more difficult than Matlab / SciPy
17:57:37 <taktoa> for example, one could use iterate or tail recursion
17:57:45 <taktoa> to implement recursion
17:57:58 <danharaj> speaking of repa
17:58:00 <ian_mi> Cale: it's still much too slow
17:58:01 <adamvh> danharaj: perhaps if I understood repa, it would be just as quick
17:58:07 <hpc> repa?
17:58:07 <danharaj> does anyone know the nicest way to marshall a repa array of storables?
17:58:13 <Cale> ian_mi: Depends on what's fast enough :)
17:58:14 <djanatyn> Haskell seems like a good way to approach more complicated computer science concepts, from what I've seen so far.
17:58:26 <djanatyn> A lot of the stuff I did in C, I knew how to do, but I didn't totally understand it
17:58:27 <Cale> ian_mi: It's not anywhere close to optimal, but it's short :)
17:58:35 <adamvh> danharaj:  Sorry, no idea
17:58:43 <djanatyn> I'm starting to feel like I actually *understand* Haskell as I go along
17:58:45 <Cale> (and instructive :)
17:58:47 <adamvh> danharaj: What are you working on with repa, BTW?
17:58:50 <danharaj> adamvh: Fair enough. Have you read the original Repa paper?
17:58:59 <adamvh> danharaj: skimmed
17:59:08 <danharaj> adamvh: Writing a physics simulator, starting with points.
17:59:25 <danharaj> adamvh: I found that by writing out the matrix multiplication problem by hand from that paper made me go "aha!"
17:59:45 <adamvh> danharaj: I was considering attempting to implement scan and unfold, since they seem like glaring omissions
17:59:51 <danharaj> adamvh: the only difficulties I have now with repa are the type errors. Also now I have to figure out how to marshall my data to OpenGL
18:00:09 <adamvh> danharaj: So I spent quite a bit of time poking around inside the source of repa
18:00:19 <danharaj> adamvh: I'm not sure scan and unfold have obvious unambiguous definitions.
18:00:42 <adamvh> fair point
18:00:51 <danharaj> ah but I see something
18:00:53 <adamvh> But the source of repa is kind of a harrowing experience
18:01:07 <danharaj> you can take an Array of rank n, and scan to extend it to an Array of rank n+1
18:01:33 <danharaj> or wait
18:01:35 <danharaj> no I'm thinking of unfold
18:01:40 <danharaj> wires crossed :p
18:01:46 <adamvh> Well, I wanted both of them
18:02:10 <adamvh> Since solutions to differential equations are really easy to express in terms of unfolds / scans
18:02:19 <danharaj> You should contact the repa team.
18:02:55 <adamvh> I tried to file a ticket, but the trac was wonky and didn't send the verification e-mail
18:03:05 <djanatyn> hmm...
18:03:07 <adamvh> Also, I wanted to have implementations in hand
18:03:14 <adamvh> hence my source diving
18:03:25 <djanatyn> Could I make a function that returns different types, depending on the input it gets?
18:03:26 <danharaj> ah yes.
18:03:33 <danharaj> I am afraid to go code spelunking myself.
18:04:11 <adamvh> It's sort of an irritating experience because you have to drill down through like 6 modules to find the implementation of anything
18:04:40 <djanatyn> hmm, doesn't seem to work
18:04:50 <adamvh> djanatyn: Either a b
18:05:04 <danharaj> adamvh: Do you know what the semantics of (++) are? I'm not clear from the description how the append is done.
18:05:06 <djanatyn> > differentTypes x y = if (x + y) == 5 then 9000 else "nine thousand"
18:05:07 <lambdabot>   <no location info>: parse error on input `='
18:05:20 <djanatyn> > let differentTypes x y = if (x + y) == 5 then 9000 else "nine thousand"
18:05:21 <lambdabot>   not an expression: `let differentTypes x y = if (x + y) == 5 then 9000 else...
18:05:26 <djanatyn> ennh, whatever
18:05:37 <adamvh> @src Either
18:05:37 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:05:39 <danharaj> djanatyn: You need to wrap your values with the constructors of Either.
18:05:51 <danharaj> djanatyn: Eithar a b = Left a | Right b
18:05:53 <danharaj> Either*
18:06:14 <djanatyn> Is it possible to define functions in ghci, btw?
18:06:57 <adamvh> > let differentTypes x y = if (x + y) == 5 then (Left 9000) else (Right "nine thousand")
18:06:58 <lambdabot>   not an expression: `let differentTypes x y = if (x + y) == 5 then (Left 900...
18:07:05 <adamvh> durr
18:07:25 <adamvh> > let differentTypes x y = if (x + y) == 5 then (Left 9000) else (Right "nine thousand") in differentTypes 4 3
18:07:26 <lambdabot>   Right "nine thousand"
18:07:49 <djanatyn> So if you just use let, you can define a function within ghci?
18:08:11 <adamvh> djanatyn: not entirely sure
18:08:17 <adamvh> I always define functions in source files
18:09:02 <danharaj> yeah, I use source files and the :reload command.
18:09:55 <djanatyn> Oh, cool! It looks to me as if you can.
18:11:38 <adamvh> danharaj: The semantics of (++) appear to be Array (sh :. m) -> Array (sh :. n) -> Array (sh :. m + n)
18:13:47 <adamvh> danharaj: I expect it creates a delayed array with the function (\(sh :. x) -> if x < m then left :! (sh :. x) else right :! (sh :. x - m))
18:14:31 <danharaj> ah, so it appends them along the lowest index
18:14:34 <adamvh> e.g. it cocatenates along the innermost dimension, and the outer dimensions must be compatibles
18:14:38 <adamvh> right
18:15:13 <adamvh> That's how fold works as well
18:15:41 <adamvh> You have to use a transpose if you want to fold or append along any axis but the innermost one
18:15:46 <danharaj> mm.
18:15:59 <danharaj> well, backpermute in general right? Because transpose only swaps the last two indces.
18:16:08 <adamvh> Oh yeah, sorry
18:16:23 <adamvh> Apparently laziness makes this not the performance problem you would think
18:16:37 <danharaj> yeah something something magic type wizards
18:16:57 <adamvh> As in repa will figure it out if you're doing something like
18:17:14 <danharaj> blahhh I wonder if a marshall function is provided in one of the helper libraries
18:17:14 <copumpkin> preflex: seen napping
18:17:14 <preflex>  napping was last seen on #haskell 3 days, 22 hours, 59 minutes and 32 seconds ago, saying: basically, add the `finally` hClose handle, and it should be reasonably solid
18:17:32 <adamvh> a backpermute followed by a fold followed by an inverse backpermute
18:17:43 <adamvh> and be smart about it
18:18:17 <danharaj> Hopefully.
18:18:31 <danharaj> The worst performance traps would be accidentally causing allocation of extra arrays.
18:18:35 <adamvh> indeed
18:19:04 <adamvh> Like if you allocated the permuted array, allocate the folded array, and then allocate the result
18:19:35 <lispy> hi
18:19:39 <lispy> How is code?
18:19:49 <adamvh> hello yourself
18:21:53 <danharaj> ok... so I think the 'easiest' way to marshall will be to convert to an unboxed Vector, and then convert that to a storable array, and finally be in C land.
18:22:11 <adamvh> danharaj: Are you trying to use CUDA?
18:22:22 <adamvh> (or whatever the ATI version is called)
18:23:05 <djahandarie> sm, ooh, awesome, thanks!
18:23:09 <danharaj> nah, I'm doing the computations Haskell-side and then sending vertex data.
18:24:11 <adamvh> danharaj: Ah, so you're actually using the GPU for graphics!
18:24:32 <sm> djahandarie: no problem
18:24:32 <danharaj> As God intended :p
18:25:05 <adamvh> I did an n-body simulation in CUDA once.  Shit screamed
18:25:15 <adamvh> Except my GPU only supported single-floats
18:25:28 <copumpkin> failgpu
18:25:38 <danharaj> When I wrote this code using lists, things went below 20 fps on the 3-body problem :\
18:25:53 <hpc> there's no good way to implement double precision math using single precision, is there?
18:26:06 <adamvh> hpc: Definitely not on a gpu
18:26:19 <adamvh> hpc: if statements are your enemy on the gpu
18:26:54 <HugoDaniel> just do everything on the cpu :) its the future
18:28:21 <adamvh> danharaj: I take it you substituted repa for the lists?
18:29:28 <danharaj> adamvh: yes.
18:29:48 <danharaj> I also threw out a lot of datatypes and just started working with flat arrays of floats.
18:30:41 <danharaj> Which is easily interpreted as a point in configuration space
18:31:39 <danharaj> now I really really hope converting to an unboxed vector and then to a storable vector only costs me one allocation.
18:31:41 <danharaj> really really hope.
18:32:02 <copumpkin> storable is already unboxed
18:32:07 <copumpkin> isn't it?
18:32:45 <adamvh> copumpkin: he needs to make a repa array into something a gpu understands
18:33:00 <copumpkin> yeah, so why not just go straight for storable?
18:33:26 <adamvh> repa must have a storable in there somewhere, I suppose
18:33:33 <adamvh> It's just a matter of getting it to cough it up
18:33:49 <danharaj> I haven't dug into the API, but there's a "toVector" that gives me an unboxed vector.
18:33:55 <danharaj> and then I can call "convert" to get it to a storable vector.
18:34:11 <copumpkin> yeah, but I don't think that will be constant-space
18:34:13 <danharaj> I'm hoping toVector doesn't actually allocate new memory, and just forces the Repa array.
18:34:24 <copumpkin> oh, in repa it won't
18:34:31 <copumpkin> oh, I see what you mean
18:34:40 <copumpkin> I'd assume it does
18:35:07 <danharaj> I'll throw a ticket onto their tracker at some point.
18:35:15 <danharaj> Right now I just want to get some n-bodies all up in this bitch :p
18:35:27 <copumpkin> :P
18:35:58 <danharaj> I want to write a fragment shader that colors a particle based on its velocity too. So after this I'm going to have to learn a bit about color models.
18:36:07 <danharaj> just to prettify everything :p
18:36:14 <ddarius> You may want to look at accelerate.
18:36:28 <danharaj> ddarius: what is accelerate?
18:37:28 <djahandarie> @hackage accelerate
18:37:28 <lambdabot> http://hackage.haskell.org/package/accelerate
18:38:08 <danharaj> clever girl
18:38:11 <danharaj> That looks cool.
18:39:52 <aristid> hah. @hackage is a particularly clever command.
18:39:58 <aristid> @hackage danharaj
18:39:59 <lambdabot> http://hackage.haskell.org/package/danharaj
18:40:24 <Hugglesworth> does anyone have proper audoindent in vim? and how?
18:41:09 <adamvh> There's a proper autoindent in emacs (;
18:41:22 <hpc> @hackage  http://www.google.com
18:41:22 <lambdabot> http://hackage.haskell.org/package/http://www.google.com
18:41:27 <hpc> aw....
18:41:37 <hpc> @hackage z http://www.google.com
18:41:37 <lambdabot> http://hackage.haskell.org/package/z http://www.google.com
18:41:40 <hpc> yay
18:41:47 <aristid> :D
18:41:55 <Hugglesworth> adamvh: how very helpful of you
18:41:58 <Hugglesworth> :p
18:42:43 <adamvh> Hugglesworth: I made an attempt to switch to vim after a bout of emacs pinky, but it was actually autoindent that drove me back to emacs
18:42:56 <Hugglesworth> damn
18:43:20 <adamvh> that was Python though
18:43:40 <adamvh> and it was probably my problem, not vim's
18:44:15 <hpc> it might have been python's problem
18:44:25 <hpc> indentation feels really annoying in python for some reason
18:44:25 <Hugglesworth> I've installed both the haskell and haskell-indent packages, and vim still insists on the indentation going crazy
18:44:29 <danharaj> here's a note: The opengl package that comes with Haskell Platform is not the latest version :[
18:45:33 <adamvh> hpc: well it was painless in emacs
18:45:34 <adamvh> lol
18:46:21 <Hugglesworth> this seems like one of those things where I'll get sick of it and hack it in myself during a weekend coding binge
18:46:30 <adamvh> @hoogle log
18:46:30 <lambdabot> Prelude log :: Floating a => a -> a
18:46:30 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
18:46:30 <lambdabot> Network.CGI logCGI :: MonadIO m => String -> m ()
18:46:39 <danharaj> Spite and frustration are the chief driving forces of opensource development.
18:47:54 <hpc> i suppose that explains why ubuntu has so many twitter clients :P
18:50:09 <danharaj> How do you deal with a name clash between binary operators?
18:50:26 <parcs> @src Integer
18:50:27 <lambdabot> data Integer = S# Int#
18:50:27 <lambdabot>              | J# Int# ByteArray#
18:51:09 <aristid> danharaj: qualified imports?
18:51:23 <danharaj> aristid: so I could do foo Qualified.++ bar?
18:51:30 <aristid> yup
18:51:37 <danharaj> ok, that looks weird but it's ok
18:51:48 <dolio> > 5 Prelude.+ 6
18:51:49 <lambdabot>   11
18:54:33 <ddarius> > succ Prelude.. succ $ 1
18:54:34 <lambdabot>   Not in scope: `Prelude..'
19:01:24 <adamvh> @pl (\x y -> (fromInteger x) - (fromInteger y))
19:01:24 <lambdabot> (. fromInteger) . (-) . fromInteger
19:01:56 <adamvh> :t (. fromInteger)
19:01:57 <lambdabot> forall a b. (Num a) => (a -> b) -> Integer -> b
19:02:15 <Twey> adamvh: on (-) fromInteger
19:02:23 <adamvh> 2
19:02:26 <adamvh> @src on
19:02:27 <lambdabot> (*) `on` f = \x y -> f x * f y
19:02:39 <Twey> Well, roughly
19:02:46 <adamvh> thanks
19:04:16 <adamvh> hmm what package does on live in?
19:04:26 <copumpkin> Data.Function
19:06:31 <koninkje> Or more generally ((-) $:: fromInteger ~> fromInteger ~> id)
19:07:37 <koninkje> Though the `on` version is much prettier for this example
19:09:40 <parcs> @hoogle (~>)
19:09:41 <lambdabot> No results found
19:10:01 <koninkje> http://matt.immute.net/content/pointless-fun
19:10:51 <koninkje> or more generally http://community.haskell.org/~wren/wren-extras/dist/doc/html/wren-extras/Data-Function-Pointless.html
19:11:41 <koninkje> @let ($::) = flip ($)
19:11:42 <lambdabot>  <local>:2:0:
19:11:42 <lambdabot>      Multiple declarations of `L.$::'
19:11:42 <lambdabot>      Declared at: <local>...
19:11:49 <koninkje> @let f ~> g = (. f) . (g .)
19:11:51 <lambdabot>  Defined.
19:12:06 <koninkje> @let (f .! g) x = f $! g x
19:12:08 <lambdabot>  Defined.
19:12:16 <koninkje> @let f !~> g = (.! f) .! (g .)
19:12:17 <lambdabot>  Defined.
19:12:43 * koninkje wonders if there's a way to tell lambdabot the fixities
19:12:50 <djahandarie> not afaik
19:12:59 <koninkje> alas
19:14:35 <Nereid> alright, let's see if I can get this this haskell SDL library working on win32
19:14:55 <copumpkin> > let infixl 5 *; (*) x y = x + y in 5 * 7
19:14:56 <lambdabot>   12
19:17:05 <adamvh> is there an RTS flag that would limit the number of digits of precision that ghc prints?
19:19:49 <ddarius> It makes little sense for that to be an RTS flag.
19:35:23 <Rellik_> hello haskell - so it's not cool for me to pass a type constructor as a parameter to a function?
19:35:56 <adnam> Rellik_: totally cool
19:36:09 <Rellik_> ooooo ok i just need to figure out how to do it then =(
19:36:16 <adnam> what you got?
19:36:26 <adnam> a constructor is like any function
19:36:35 <copumpkin> type constructor = Int or Maybe
19:36:41 <Rellik_> so if i define data Color = Red Int
19:37:08 <Rellik_> and i want to make a function color3 that you pass in a type constructor and it makes it (like you call color3 Red and it makes Red 3)
19:37:13 <Rellik_> the signature i tried is
19:37:22 <Rellik_> color3 :: ((a -> Int) -> Color) -> Color
19:37:40 <Rellik_> (Color has other type constructors like Blue and Green that all take Ints)
19:37:59 <adnam> that's equivalent to a -> Int -> Color -> Color
19:38:03 <ddarius> You can just let Haskell infer the signature.
19:38:06 <Rellik_> ah i got the association wrong
19:38:10 <Rellik_> oh you can?
19:38:15 <Rellik_> today is my first day of haskell
19:38:15 <ddarius> adnam: No it isn't.
19:38:23 <adnam> i scrood up? :-(
19:38:32 <Rellik_> color3 :: (a -> (Int -> Color)) -> Color
19:38:38 <djahandarie> Rellik_, you were 'right' before
19:38:39 <ddarius> At any rate, the code would just be color3 constructor = constructor, i.e. color3 would just be id.
19:38:51 <Rellik_> that's the thing though
19:38:55 <danharaj> I have an ugly type error in some instances I'm writing. I need halp. :[
19:38:56 <danharaj> http://hpaste.org/45993/derpderpderp2
19:38:57 <Rellik_> i want color3 constructor = constructor 3
19:39:02 <ddarius> Also, as copumpkin alluded to, you are talking about data constructors, not type constructors.
19:39:17 <ddarius> :t let color3 constructor = constructor 3
19:39:17 <Rellik_> ah, i see
19:39:18 <lambdabot> <no location info>:
19:39:18 <lambdabot>     not an expression: `let color3 constructor = constructor 3'
19:39:20 <djahandarie> Rellik_, you just wrote it
19:39:22 <ddarius> :t let color3 constructor = constructor 3 in color3
19:39:22 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
19:39:32 <copumpkin> danharaj: you probably want scoped type variables there
19:39:45 <copumpkin> undefined :: a isn't the same a
19:39:54 <danharaj> copumpkin: where what and why?
19:40:09 <copumpkin> {-# LANGUAGE ScopedTypeVariables #-}
19:40:31 <danharaj> ok, that magically fixed it... why?
19:40:42 <copumpkin> (undefined :: a)
19:40:46 <copumpkin> that a has nothing to do with the a above
19:40:52 <copumpkin> it's just a free type variable
19:41:02 <ddarius> copumpkin: No it isn't free.
19:41:05 <copumpkin> well, not free
19:41:09 <copumpkin> but it isn't connected to anything
19:41:12 <ddarius> If it were free it would be bound to the one above.
19:41:24 <danharaj> It is counter-intuitive to me that the default behavior is for type variables to shadow themselves.
19:42:02 <ddarius> danharaj: It makes sense in a world without (explicit) quantifiers.
19:42:30 <danharaj> ddarius: Ah. So this is a historical thing.
19:42:47 <ddarius> Sort of.
19:43:07 <ddarius> Standard Haskell still does not allow explicit quantifiers.
19:44:19 <Rellik_> damn, so my color3 a = a 3 was right all along, but the type signature i explicitly provided was the probably
19:44:25 <Rellik_> thanks
19:47:27 <danharaj> ddarius: I don't think anyone programs in standard haskell anymore.
19:48:47 <parcs> @djinn (a -> b) -> b
19:48:48 <lambdabot> -- f cannot be realized.
19:50:00 <parcs> @djinn (a -> a) -> a
19:50:01 <lambdabot> -- f cannot be realized.
19:50:26 <danharaj> @djinn a -> (a -> a) -> a
19:50:26 <lambdabot> f a b = b a
19:50:36 <Nereid> huh
19:50:39 <Nereid> SDL built with no trouble. yay
19:50:45 <djahandarie> danharaj, so Haskell has succeeded in deprecating itself?
19:50:46 <copumpkin> @djinn a -> (Not (Not a))
19:50:46 <lambdabot> f a b = b a
19:51:13 <luite> parcs: perhaps you should "fix" djinn ;)
19:51:22 <parcs> heh
19:51:43 <djahandarie> Where "fix" = "introduce inconsistency into"
19:51:47 <danharaj> djahandarie: I think it's just that GHC has become the de facto Haskell.
19:52:38 <luite> djahandarie: yes that is a minor disadvantage
19:53:08 <luite> by the way, from now on I'm going to assume that djahandarie and danharaj are the same person, their nicks are too similar
19:53:12 <shachaf> A "fixed" djinn would be able to prove a lot more propositions.
19:53:19 <luite> like apples and oranges
19:53:20 <copumpkin> luite: surely you mean djahandarie and geheimdienst 
19:53:37 * shachaf welcomes luite.
19:53:48 <djahandarie> I think the only path left for me is to murder everyone else with similar nicknames to me.
19:53:52 <luite> copumpkin: you can't be serious, those nicks don't look anything like each other ;p
19:54:07 <djahandarie> Although geheimdienst technically wouldn't be taken out by that criteria
19:54:12 <copumpkin> luite: they're basically the same person
19:54:18 <shachaf> Pretty much.
19:54:24 <luite> I don't believe in persons on the interwebs anymore
19:54:39 <luite> oh wait that does contradict my earlier statement
19:54:53 <shachaf> djahandarie: What about ddarius?
19:55:28 <djahandarie> shachaf, I think he'd kill me before I could kill him
19:56:34 <ddarius> Probably.
19:56:42 <dolio> Seems pretty likely.
19:56:46 <copumpkin> Yep.
19:57:00 <djahandarie> ( ´_ゝ｀)
19:57:07 <shachaf> At last #haskell is unanimous about something.
19:57:38 <dolio> Unless you have one of those automatic shotguns that fires around corners.
19:57:58 <copumpkin> you can't really argue with those
19:58:15 <djahandarie> How exactly would you buy one of those?
19:58:16 <geheimdienst> well, oleg can
19:58:26 <shachaf> copumpkin: You can't really argue with ddarius either.
19:59:06 <geheimdienst> however ddarius does not generally fire around corners, in my experience
19:59:15 <geheimdienst> so point shotgun
20:03:10 <danharaj> I am getting extreme slow downs and memory leaks when doing a series of writeArray's to a StorableArray
20:03:18 <danharaj> could it be that the IO actions are being too lazy?
20:16:41 <rambromura> hello
20:24:53 <danharaj> argh. my kingdom for an efficient way of marshaling repa arrays :p
20:25:52 <lispy> danharaj: it could be laziness.  Are you converting any of the values or types?  Could be poorly implemented conversion functions
20:26:08 <lispy> danharaj: have you profiled or looked at the core?
20:27:28 <danharaj> lispy: I haven't profiled before. Time to learn I guess.
20:29:32 <lispy> danharaj: yeah, ghc has good profiling support.  I forget how to spell the flags, but you want to enable automatic cost centers and profiling.  Then you want to also enable profiling when you run it.  IIRC, chapter 25 of RWH describes it
20:31:01 <danharaj> lispy: gotcha. reading now.
20:34:56 <danharaj> oh boy. one of the libraries I'm using doesn't have a profiling version.
20:35:57 <djahandarie> Yeah, that's cabal's fault.
20:36:00 <luite> cabal install --reinstall -p libraryname
20:36:19 <luite> and unfortunately you'll have to do this for every dependency
20:36:20 * djahandarie is actually not sure if --reinstall is safe to use or not
20:36:25 * djahandarie pings monochrom to make sure
20:36:31 <luite> dunno, I've always used it without problems
20:36:38 <djahandarie> UNTIL EVERYTHING EXPLODES
20:36:50 <luite> well so far it hasn't so it must be safe
20:37:01 <brweber2> djahandarie: hey, that issue you helped with me the other day (some noob code) that was seg faulting... upgrading my version of ghci fixed the problem
20:37:08 <lispy> use cabal-dev
20:37:15 <djahandarie> brweber2, ah, good to hear
20:37:26 <brweber2> djahandarie: I suspect, I just had a corrupt build (can't remember if I built it or used haskell platform)
20:37:50 <lispy> djahandarie, danharaj: if you use cabal-dev it's safe to do whatever to your dependencies because they are isolated to just the thing you're building instead of global
20:38:16 <djahandarie> Ah, that's neat
20:39:58 <lispy> I highly recommend using cabal-dev for your day to day stuff
20:40:06 <lispy> It makes life a lot less painful
20:40:16 <lispy> cabal-dev ghci, for example is really nice
20:41:33 <danharaj> lispy : good to know
20:42:29 <lispy> I also recommend setting your cabal config to always install profiled versions of libraris
20:42:33 <lispy> Saves a lot of time later
20:42:44 <lispy> Takes a little extra time when you install things, but computers are pretty fast these days
20:43:06 <brweber2> so I'm reading LYAH and I just read that Integer is an example of an Enum Type Class ... so enums do not have to be finite?
20:43:42 <danharaj> brweber2: Nope.
20:43:47 <kmc> that's kind of bogus though
20:44:02 <kmc> because Enum a has fromEnum :: a -> Int
20:44:06 <kmc> and Int is a finite type
20:44:12 <kmc> > fromEnum (2**128 :: Integer)
20:44:12 <lispy> Yeah, Enum is a little broken IMO
20:44:13 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
20:44:13 <lambdabot>    arising fr...
20:44:21 <kmc> > fromEnum (2^128 :: Integer)
20:44:22 <lambdabot>   0
20:44:26 <kmc> bazinga
20:44:38 <danharaj> never understood why Float has an Enum instance.
20:44:39 <lispy> fromEnum :: Integral b => a -> b, would be a lot better but I don't know if it would cause other issues
20:44:56 <kmc> all the standard type classes are slightly broken ;)
20:45:01 <brweber2> ok, feeling a little better b/c Int made sense to me but Integer was warping my mind
20:45:17 <kmc> with regard to Enum, or in general?
20:45:19 <brweber2> makes sense when it comes to using them in ranges
20:45:36 <lispy> kmc: what other ones come to mind as broken?  Monad has some issues with fail and no Functor constraint, but that's about it right?
20:45:39 <brweber2> I'm trying to figure out how one would declare / define an enum that was infinite
20:45:47 <kmc> yeah, i think that's the practical reason for making Integer an instance of Enum
20:46:01 <djahandarie> lispy, Num is usually considered 'broken'
20:46:03 <brweber2> upper / lower bounds and transform function?
20:46:06 <kmc> brweber2, by defining 'succ' and 'pred' and not thinking too hard about 'fromEnum'
20:46:15 <brweber2> kmc :)
20:46:19 <kmc> Num has Eq and Show as superclasses; that's pretty broken
20:46:26 <lispy> djahandarie: ah right.  Num.
20:46:47 <lispy> kmc: what kinds of numbers would you not want to Eq?
20:46:59 <kmc> exact reals
20:47:19 <kmc> with a higher-order representation
20:47:25 <kmc> also, arguably, floating point
20:47:50 <kmc> equality of computable real numbers is undecidable
20:48:14 <danharaj> ok, so I have narrowed down my problem to the fact that I am reading and writing a repa array to an IORef every frame.
20:48:33 <lispy> danharaj: oh yeah, that sounds bad
20:48:34 <ddarius> Equality of most types in Haskell is undecidable.
20:48:45 <danharaj> So uhh... what's the fast way to mutate data?
20:48:46 <kmc> that too
20:48:48 <ddarius> An IORef is just a reference.
20:48:57 <kmc> writing to the IORef is not the slow part
20:49:04 <ddarius> Reading/writing to it is just reading/writing a pointer.
20:49:25 <danharaj> I guess I'll just have to grit my teeth and go reinstall all those libraries as profiling.
20:49:30 <danharaj> and figure out what's really going on.
20:49:42 <lispy> danharaj: change your cabal config to automatically do that
20:49:49 <lispy> danharaj: you'll be happy you did
20:49:53 <danharaj> lispy: how do I do that?
20:50:22 <lispy> edit ~/.cabal/config
20:50:28 <lispy> The line should be there already, just commented out
20:50:36 <danharaj> oh, convenient
20:50:38 <lispy> it's like, enable-library-profiling: true, or somethirng
20:50:57 <danharaj> will that make Cabal download both versions of the library?
20:51:03 <danharaj> or just the profiling version?
20:51:08 <danharaj> download/build
20:51:09 <kmc> it's the same source code
20:51:19 <lispy> danharaj: both
20:51:22 <kmc> just compiled with ghc -prof
20:51:45 <kmc> the thing is, code built with -prof has a different ABI from code built without
20:52:40 <danharaj> kmc: what do I have to watch out for? I mean other than mixing profiling with non-profiling code.
20:53:01 <kmc> you don't have to watch out for mixing profiling with non-profiling code, because ghc won't let you
20:53:09 <danharaj> oh ok.
20:53:28 <kmc> but this is why you need profiling builds of all libraries, even if you don't particularly care about profiling those libraries
20:53:36 <kmc> the layout of objects in the heap is different with profiling enabled
20:53:56 <lispy> danharaj: so, did you mean you're updating an IORef every frame, or you're reading the whole array and writing a new array back to the IORef?  I thought you meant the latter, which would be slow because of all the array reading/writing.
20:53:59 <danharaj> I hope the Haskell Platform comes with profiling versions for its libraries too?
20:54:27 <lispy> danharaj: A lot of the array apis (not sure about repa) come with a freeze/thaw api that lets you mutate them and then make them pure again.
20:54:36 <lispy> danharaj: yeah, it does
20:56:39 <danharaj> ok... so I uncommented the line library-profiling: True in my config file. When I go to install the library I get the error: library-profiling: True\hackage.haskell.org\00-index.tar: invalid argument
20:57:34 <lispy> danharaj: say what?
20:57:51 <danharaj> $ cabal install opengl
20:57:52 <lispy> danharaj: so, that looks like the newline is missing or something?
20:57:53 <danharaj> error: library-profiling: True\hackage.haskell.org\00-index.tar: invalid argument
20:58:42 <lispy> danharaj: yeah, that seems like you have a syntax error in your cabal config.  I've never seen that error before but it looks like the \hackage.... stuff should be on the next line
20:58:56 <danharaj> possibly. in my command line it's on the same line.
20:59:25 <danharaj> oh I see, I left the extra spaces DERP
20:59:27 <danharaj> I need coffee.
20:59:31 <lispy> heh
20:59:54 <lispy> danharaj: are you converting between GLfloat and any other type of float by any chance?
21:00:04 <danharaj> lispy: nope. I'll paste my update loop
21:00:35 <danharaj> don't mind any magic numbers you see >_>
21:04:40 <danharaj> http://hpaste.org/45995/derp3
21:04:47 <danharaj> I added annotation, hopefully enough.
21:05:18 <kmc> there's a haskell library named "derp"
21:05:27 <lispy> danharaj: oh, modifyIORef is evil, FWIW
21:05:29 <Kerris> was 'herp' taken
21:05:40 <lispy> danharaj: realToFrac is also evil
21:05:40 <djahandarie> Surprisingly there is no herp
21:05:41 <kmc> 'berp' was
21:05:47 <kmc> what's wrong with modifyIORef?
21:05:52 <danharaj> derp must be the facepalm library
21:06:00 <danharaj> it was imported when I was compiled.
21:06:02 <lispy> danharaj: so what does simulationDelta return?
21:06:08 <lispy> danharaj: what type is that?
21:06:11 <danharaj> oh, simulationDelta is a float constant
21:06:31 <lispy> what does testInteractions take?
21:06:34 <danharaj> and you just reminded me I no longer need that realToFrac :p
21:06:46 <danharaj> testInteractions is a list of functions that is currently empty.
21:07:47 <lispy> danharaj: ah.  So, remove that realToFrac.  In this case, it should be id anyway, so it won't make a difference for performance
21:07:52 <danharaj> Actually, I still need that realToFrac because the timing library uses doubles and I am using floats.
21:08:08 <lispy> danharaj: Next, there should be a way to make your modifyIORef work better, but I need to think about that for a second
21:08:11 <danharaj> It'll go away eventually as I refine this code.
21:08:25 <lispy> realToFrac can be a huge performance sink
21:08:44 <danharaj> really? even if I'm only calling it once per entire loop?
21:09:12 <danharaj> I suppose I should replace it with a primitive coercion from double to float.
21:09:42 <lispy> danharaj: I guess I'm confused.  So you're not calling this stuff in a loop?  It's only happening once per frame?
21:09:44 <kmc> lispy, what was the objection to modifyIORef?
21:10:36 <danharaj> update is called once per frame. evolve is called once every delta, which would be once per frame if I reached the goal of running at 60 fps.
21:10:57 <lispy> kmc: last I checked it was lazy in applying the function which can cause thunks to build up.
21:11:12 <lispy> kmc: may not be an issue here though
21:11:14 <kmc> that's okay, i thought we were pro-lazy ;)
21:11:20 <danharaj> lispy: I should probably get rid of that laziness
21:11:20 <lispy> kmc: if the array is demanded often
21:11:46 <danharaj> I mean, the way I'm taking powers of the evolution function and the modify must be building some stupid sized thunks.
21:11:57 <lispy> kmc: it can be a huge problem or it can be exactly what you want.  The thing that makes modifyIORef a bit evil is that you can't introduce strictness without rewriting it
21:12:33 <kmc> that's necessary if you want lock-free atomicity
21:12:40 <kmc> but not in the non-atomic case
21:13:19 <lispy> IORefs are non-atomic though, right?
21:13:30 <kmc> atomicModifyIORef is atomic
21:13:47 <huangyi> @hoogle init
21:13:48 <lambdabot> Prelude init :: [a] -> [a]
21:13:48 <lambdabot> Data.ByteString init :: ByteString -> ByteString
21:13:48 <lambdabot> Data.List init :: [a] -> [a]
21:13:50 <kmc> and it's much faster than other atomic stuff, so useful if it fits your problem
21:13:51 <lispy> that's probably a good thing considering its name :)
21:14:16 <lispy> > init []
21:14:17 <lambdabot>   *Exception: Prelude.init: empty list
21:14:27 <lispy> yay for partial functions
21:14:55 <lispy> > drop 1 []
21:14:56 <lambdabot>   []
21:15:10 <lispy> er, no init is drop last
21:15:14 <lispy> > last []
21:15:16 <lambdabot>   *Exception: Prelude.last: empty list
21:15:31 <lispy> > init [1..3]
21:15:32 <lambdabot>   [1,2]
21:15:37 * lispy never uses that function
21:18:29 <danharaj> ok so, I did something I forgot to do, and that is cap the number of simulation steps per frame, so it doesn't get into a death spiral of performance degradation.
21:18:54 <danharaj> However there is still a performance problem because it's dipping well below 60 frames per second on absolutely no work being done.
21:19:29 <danharaj> (Also I'm still losing responsiveness)
21:20:29 <lispy> danharaj: it's going to be hard to debug this remotely.  Lots of things could be going wrong, unfortunately
21:20:34 <danharaj> yes.
21:20:40 <lispy> danharaj: it could be a lack of asking the os for messages, for example
21:20:41 <danharaj> I'm going to get profiling working.
21:21:11 <danharaj> Problem: when I ask cabal to reinstall a package, it's not installing the profiling versions of its dependencies.
21:21:23 <danharaj> How do I make Cabal deep reinstall, so to speak?
21:22:10 <shachaf> rm -rf ~/.cabal; cabal install package ?
21:22:14 * shachaf hopes there is a better way.
21:23:29 <luite> danharaj: unpossible!
21:23:39 <lispy> danharaj: somone made a tool called cab to do that
21:23:58 <danharaj> heh
21:24:03 <lispy> danharaj: http://hackage.haskell.org/package/cab
21:24:25 <danharaj> lispy: for what it's worth, when I remove the call to "unsafeToVertex", the code has no performance issues whatsoever
21:25:04 <danharaj> I must be doing something stupid wrong with repa arrays.
21:25:43 <danharaj> or perhaps GHC is saying "who cares?" because I'm no longer using the read from the IORef.
21:25:52 * danharaj doh
21:26:31 <kmc> right, putting a value in an IORef does not force evaluation
21:26:39 <kmc> (nor does taking it out)
21:27:38 <danharaj> I suppose I should test that. How can I force the evaluation?
21:28:33 <kmc> :t Control.Exception.evaluate
21:28:34 <lambdabot> forall a. a -> IO a
21:35:52 <lispy> danharaj: pattern matching is the most basic way.  Then you have seq, and rnf and etc
21:39:33 <danharaj> almost have all of my dependencies reinstalled with profiling available
21:39:36 <danharaj> zzz
21:50:35 <Nereid> yay, SDL actually works!
21:50:44 <danharaj> Nereid: Congrats.
21:50:58 <danharaj> Ok, profiling works, I've narrowed down my cost center to "evolve"
21:51:06 <danharaj> I was an idiot for not understanding lazy evaluation :)
21:51:12 <danharaj> chasing allocation ghosts.
21:52:52 <danharaj> I'm going to have to say that GHC is the #1 reason to use Haskell
21:58:04 <tcard> I am having trouble linking programs that use Control.Parallel using GHC.
21:58:27 <tcard> Here is a minimal test case with details: http://hpaste.org/45996/parallel_linking_error
22:01:58 <kmc> use ghc --make
22:02:15 <kmc> although, that should be the default with GHC 7
22:04:09 <tcard> kmc: Thanks for the tip!  I am trying --make now to see if it helps.
22:05:58 <tcard> kmc: It works fine with --make; thank you very much!
22:08:37 <kmc> excellent :)
22:12:30 <Kaidelong> I love the HLint suggestion
22:13:45 <tcard> Kaidelong: Yeah, I was pearing down code to a minimal test case and forgot to remove the $ after simplifying the argument to putStr. :)
22:15:11 <danharaj> how do you attach a cost center to a library function?
22:19:13 <ddarius> You can attach a cost centre to an expression by using {-# SCC "name" #-} if I remember the syntax.  The cost centres should be added to library functions via the profiling libraries and --auto-all.
22:20:43 * ddarius brushes the rust off his C++.
22:21:09 <Nereid> C++? get out ;)
22:22:26 <danharaj> ddarius: that doesn't seem to be the case. I want to get cost information about certain operations I'm performing, but they're not being tagged by auto-all.
22:29:28 <danharaj> I hate myself.
22:29:39 <danharaj> "solved" my problem by adding "force" to a bunch of array computations.
22:29:45 <danharaj> Have *no idea* why that worked.
22:30:52 <_Ray_> Hi :) Is this the correct way to make projectors for parameters of a datatype constructor? http://hpaste.org/45997/playing_with_a_datatype
22:31:12 <_Ray_> (Maybe there's a less ugly way :))
22:32:00 <kmc> there's a pattern there you can generalize
22:32:23 <ddarius> That's a bad place to be.  You're stuck with yourself.
22:32:32 <kmc> it's also a weird data type
22:32:34 <_Ray_> Me? :(
22:32:55 <_Ray_> How's it weird? And how could I generalize it?
22:33:28 <_Ray_> Oh, getBasicProperties
22:33:32 <kmc> well, each of getId and getName does one thing for NewRoom, and otherwise calls itself recursively
22:33:33 <_Ray_> And then pick one of those :)
22:33:56 <_Ray_> getBasicProperties does the recursion, and returns a 3-tuple of Integer, String, String
22:34:04 <kmc> that works too
22:34:10 <_Ray_> getId, getName and (say) getDescription will pick the 0th, 1st, and 2nd element of the tuple
22:34:33 <kmc> maybe you'd rather work with:  data BaseRoom = Room Integer String String; data Room = Base BaseRoom | Add Stuff Room
22:34:43 <kmc> data Stuff = Exit String Integer | HiddenExit String Integer | ...
22:35:28 <_Ray_> Interesting. Why would you use that, rather than the original one?
22:35:29 <kmc> _Ray_, what I had in mind was:  get f r@(NewRoom _ _ _) = f r; get f (AddExit r _ _) = get f r; ...
22:36:01 <kmc> if you separate the idea of adding stuff from the details of what's being added
22:36:05 <kmc> then your recursion becomes simpler
22:36:14 <kmc> after all, getId and getName both ignore the stuff that's being added
22:36:26 <kmc> it's kind of bad that you have to have 3 clauses on each that ignore Add* constructors
22:36:33 <_Ray_> Ah, so all the "stuff that's being added" is the same to them
22:36:37 <kmc> and you have to add more clauses if you invent more Add* constructors
22:36:40 <kmc> *nod*
22:36:42 <_Ray_> and if I were to want to extend the capabilities of the room first, I'd have to add stuff
22:36:57 <_Ray_> s/what I mumbled/what you said/;
22:37:47 <_Ray_> is 'get' special in some way? or should I call 'get getName room', where getName (NewRoom _ x _) = x?
22:39:03 <kmc> i don't understand the question
22:39:23 <kmc> i picked the name "get" arbitrarily; you might want a different name
22:39:25 <_Ray_> If I were to implement your 'get f r@(NewRoom ... "
22:39:27 <kmc> that looks like a correct use of it
22:39:37 <_Ray_> ah, ok. but I should use it as 'get getName room'
22:39:45 <_Ray_> or, with less stupid naming, 'get nameof room'
22:39:50 <kmc> but, if you changed the datatype the way i suggested, that function would also change, and get simpler probably
22:40:24 <kmc> you can even say:  get (\(NewRoom _ x _) -> x)
22:40:43 <kmc> if you prefer
22:41:21 <_Ray_> heh, yeah. thanks :)
22:41:47 <kmc> no problem :)
22:53:38 <_Ray_> kmc: How about this, then? http://hpaste.org/paste/45997/playing_with_a_datatype_annot#p45998 . I'm thinking I also have repeated structure in getExits vs getActions. Can this be generalized as well?
22:56:55 <_Ray_> oh god I just asked ghc to show me the .c it generated. never. again. oh the horror D:
22:57:26 <Nereid> D:
22:57:40 <Zao> _Ray_: It's not supposed to be beautiful :D
22:57:52 <Zao> _Ray_: You should see the assembly source that the Evil Mangler runs on :D
22:58:30 <Nereid> isn't there a LLVM backend being worked on? or something?
22:58:32 <_Ray_> Hp[-3] = (W_)&stg_CAF_BLACKHOLE_info;
22:58:35 <_Ray_> wtf D:
22:58:45 <Nereid> [-3]
22:58:48 <Nereid> nice :D
23:00:01 <Nereid> oh, the llvm backend is already in ghc 7.0
23:00:27 <kmc> Hp is the heap pointer
23:00:28 <Zao> a[b] == *(a + b) // for the unintiated :D :D
23:00:42 <kmc> probably it has incremented the pointer in order to allocate space, and now needs to fill that space with values
23:00:53 <kmc> W_ is an integral type for machine words
23:00:56 <Zao> And of course, you'd see similar techinques in a hypothetical C++ -> C translator.
23:01:45 <kmc> stg_CAF_BLACKHOLE_info is a static object (an "info table") that describes a certain sort of object
23:02:16 <Zao> (cf. vtable, rtti info)
23:02:18 <kmc> every heap object has a pointer to an info table as its first word
23:02:49 <kmc> the info table describes how to evaluate the value, as well as how to garbage collect it, and has some metadata about the value's layout in memory
23:03:18 <_Ray_> seeing this side of haskell is like knowing about your wife's past affairs. you know they exist, but you'd rather not think about them and go along your merry way
23:03:20 <kmc> a "black hole" is a stand-in for a thunk which is already being evaluated
23:04:17 <kmc> forcing evaluation of a black hole indicates an infinite loop, so the entry code pointed to by that info table will terminate your program with the "<<loop>>" exception
23:04:23 <kmc> _Ray_, yep, Haskell is like sausages
23:04:50 <ddarius> kmc: "efficient Haskell" except that particular case was hardly anything special.
23:05:54 <kmc> popular languages don't bother with all this "compiler" nonsense
23:06:12 <kmc> just write a crap interpreter and be sure to use tons of global state so that it's impossible to add multithreading to your language efficiently
23:10:38 * ddarius considers a lock-free on-demand bounding interval hierarchy.
23:12:22 <danharaj> If anyone is around who knows repa...
23:13:38 <danharaj> I have a function that takes an index (Z :. i :. j) and returns an array of shape (Z :. 2). How can I use this to create an array of shape (Z :. m :. n :. 2)?
23:18:15 <jmcarthur> danharaj: i don't remember for sure, but i think the function called replicate might be what you want. not only am i not sure i remember correctly, my information may also be outdated
23:21:59 <danharaj> jmcarthur: replicate is now extend, but that copies an array in the direction of the slice. :)
23:22:10 * hackagebot fixed-point 0.1.0.0 - Binary fixed-point arithmetic  http://hackage.haskell.org/package/fixed-point-0.1.0.0 (JakeMcArthur)
23:22:11 * hackagebot fixed-point 0.1.0.1 - Binary fixed-point arithmetic  http://hackage.haskell.org/package/fixed-point-0.1.0.1 (JakeMcArthur)
23:22:24 <danharaj> jmcarthur: I mean, I can do this pretty easily with fromFunction, but it feels like there should be a built in function to do this.
23:22:27 * _Ray_ wonders what he's doing wrong here: http://hpaste.org/46001/playing_with_a_datatype . Do-notation screwed up=
23:22:29 <_Ray_> *?
23:22:34 <jmcarthur> thanks a lot hackage...
23:22:51 <mauke> _Ray_: broken indentation
23:23:18 <_Ray_> weird, there's only one tab for each putStrLn in my editor
23:23:31 <_Ray_> is that what you mean, mauke?
23:23:40 <mauke> _Ray_: what
23:23:49 <mauke> define "one tab"
23:23:53 <_Ray_> You mean an extra tab on line 38?
23:23:58 <_Ray_> \t
23:24:11 <mauke> there's only one tab on line 38
23:24:36 <_Ray_> so where's the indentation borked?
23:24:41 <mauke> line 38
23:24:49 <Nereid> eww, hard tabs :(
23:25:14 <Nereid> _Ray_: on line 37, you have 4 spaces as indentation
23:25:15 <_Ray_> mauke, what should it be, instead of a tab? nereid: meeeh :p
23:25:20 <Nereid> while on lines 38-40, they're tabs
23:25:21 <_Ray_> not on my code :(
23:25:31 <shachaf> _Ray_: Don't use tabs. Tabs are evil.
23:25:35 <Nereid> haskell treats \t as 8 spaces
23:25:35 <_Ray_> those 4 spaces are hpaste
23:25:41 <mauke> _Ray_: no, that's your code
23:26:01 * _Ray_ hexdumps his .hs
23:26:05 <Nereid> lines 37-40 must have identical indentation
23:26:20 <Nereid> just use a better editor? ;)
23:26:29 <Nereid> one that supports soft tabs, perhaps
23:26:46 <shachaf> Nereid: Not true. You can have either eight spaces or a tab, for instance.
23:26:47 <_Ray_> well screw me sideways
23:26:58 <Nereid> shachaf: what do you mean?
23:27:00 <_Ray_> hexdump agrees, it's 4 0x20s. textmate lies to me
23:27:12 <_Ray_> (I select the entire space as a single unit)
23:27:18 <shachaf> Nereid: do\n        putStrLn "a"\n\tputStrLn "b"
23:27:35 <Nereid> oh, that's what you were referring to.
23:27:38 <Nereid> well that's more or less what I meant
23:27:41 <shachaf> _Ray_: Just use spaces everywhere.
23:27:45 <Nereid> is that each of those lines must be indented the same amount
23:28:01 <mauke> shachaf: doesn't help much if his editor pretends all 4-space blocks are tabs
23:28:15 <shachaf> mauke: That's true.
23:28:21 <Nereid> _Ray_: http://urchin.earth.li/~ian/style/haskell.html
23:28:25 <jmcarthur> this package probably isn't worth bothering the mailing list, but i'll spam IRC with it once... ANN: fixed-point package providing reasonably fast binary fixed-point arithmetic. floating point doesn't have to be your only tool for efficient fractional values
23:28:31 <shachaf> This is probably one of those editors that uses four spaces, and then a tab, and then a tab and four spaces.
23:28:51 <Nereid> no, more likely, the tab width is set to 4 characters
23:28:54 <Nereid> so tabs and 4 spaces look the same
23:29:12 <shachaf> Nereid: Oh. But he said that he selects the four spaces as a single unit.
23:29:32 <Nereid> _Ray_: fix your editor :)
23:29:36 <_Ray_> wee, it works :) 
23:29:41 <_Ray_> replaced stuff by 4 spaces
23:29:58 <Nereid> does textmate have a feature where pressing the tab key inserts an appropriate number of spaces?
23:29:58 <shachaf> > fix textmate
23:30:00 <lambdabot>   "vim"
23:30:03 <Nereid> aha
23:30:10 <Nereid> wait, seriously
23:30:14 <shachaf> Nereid: I'm quite sure it does.
23:30:21 * Nereid blinks
23:30:21 <jmcarthur> my benchmarks aren't exhaustive or even all that reliable, but fixed-point seems to be overall slightly slower than plain floating point or integer operations, but it's much faster than Integer, Rational, and Data.Fixed
23:30:23 <shachaf> Given how standard it is to use spaces with it.
23:30:51 <_Ray_> yeah, "soft tabs" they call it
23:30:58 <Nereid> yes, please use them
23:31:23 <Nereid> vim has this feature which lets you actually see tabs and trailing whitespace
23:31:25 <jmcarthur> it could use a more rigorous optimization pass and some more operations though
23:31:30 <_Ray_> as for style, is this ugly? (concat . intersperse ", " $ map fst $ getExits r)
23:31:30 <Nereid> I use it yet I forget what it's called (:
23:31:43 <Nereid> can't you replace that first $ with . ?
23:31:48 <mauke> _Ray_: intercalate
23:32:01 <jmcarthur> :t intercalate
23:32:02 <lambdabot> forall a. [a] -> [[a]] -> [a]
23:32:05 <_Ray_> ahh
23:32:08 <Nereid> also intercalate
23:32:08 <_Ray_> nice, thanks :)
23:32:32 <_Ray_> I'm still getting the hang of . and $
23:32:40 <_Ray_> I mainly use $ to avoid writing ( and ) when I'm unsure
23:33:22 <ion> Cases of multiple $s often warrant less $s and more .s
23:33:22 <shachaf> _Ray_: Multiple $s are rarely necessary.
23:33:42 <Nereid> a $ b $ c is the same as a . b $ c, but the latter is preferred
23:34:05 <_Ray_> hrm, yeah, a . there does make sense
23:34:09 * shachaf vaguely wishes Caleskell was courageous enough to replace $.
23:34:14 <jmcarthur> i typically use ($) either at the end of a chain of (.) or to help me with intermediate stages of a refactoring
23:34:18 <shachaf> ($'s fixity, that is.)
23:34:40 <_Ray_> the map will return a [String], so intercalate ", ", which returns a function taking [String] and returning String, will work
23:35:00 <jmcarthur> ($) also makes some sense as the end of a chain of (<=<), but you could also just replace the last (<=<) with (=<<)
23:35:13 <ion> One might also consider changing ‘a $ b $ c d’ to ‘a . b . c $ d’ which may e.g. help making the function more pointless.
23:35:30 <tolkad> If haskell types were allowed to have full first order logic, would type unification be computable?
23:35:38 <danharaj> no.
23:36:02 <_Ray_> lol @ being pointless being used as a compliment xD
23:36:30 <ion> Some say “pointfree”.
23:40:15 <_Ray_> hrm. is it possible to make something like: data Foo = Bar Foo | New, f (Bar t) = t, and have f . f $ t == t? Meaning, an object that has a reference to itself?
23:40:52 <mauke> sure, why not?
23:40:54 <_Ray_> (I have a list of "rooms" which have doors to other rooms. It would be nice to be able to say goLeft . goRight r == r)
23:41:09 <luite> _Ray_: it's how you make lists or trees for example
23:41:25 <mauke> luite: not trees
23:41:27 <_Ray_> right, but I don't just mean any other object of tye type, I mean the object itself
23:41:34 <_Ray_> a list can't have itself as a member
23:41:35 <kmc> yeah, you can do that _Ray_
23:41:39 <jmcarthur> let t = f . f $ t in t
23:41:41 <mauke> _Ray_: it can, sort of
23:41:45 <kmc> > let xs = 1 : xs in xs
23:41:46 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:41:50 <kmc> ^^^^ xs is its own tail
23:42:13 <_Ray_> ... one should not be allowed near these things.
23:42:18 <jmcarthur> critically, that is represented in memory as a cyclic list with one element
23:42:30 <jmcarthur> it's just that haskell can't tell
23:42:32 <kmc> a list can't have itself as a member for type reasons
23:42:36 <jmcarthur> so it appears to be an infinite list
23:42:37 <kmc> a ≠ [a]
23:42:41 <_Ray_> right
23:43:12 <kmc> but it can have itself as a tail because the types work out
23:43:45 <_Ray_> hrm. unrelated question, how could I have several 'let's? I'm currently doing let x = y in let foo = bar in ...
23:43:46 <fosskers> hey guys
23:43:49 <jmcarthur> a list can *sort of* have itself as a member if you do some newtype magic
23:44:02 <kmc> let x = y; z = w in whatever
23:44:14 <_Ray_> nice. thanks :) (there's no deep meaning in that ; is there?)
23:44:15 <kmc> that semicolon can be replaced with a newline if the indentation works out
23:44:32 <_Ray_> I just don't want to be surprised by "IT'S A MONAD :D"
23:44:40 <_Ray_> (somehow.)
23:44:43 <fosskers> hey guy, why is this exploding on me:
23:44:43 <jmcarthur> not a monad
23:44:44 <fosskers> getFibs	n = [y | x <- [1..], y <= n] where y = fib x
23:44:47 <kmc> it's just part of the syntax of "let"
23:44:58 <kmc> be aware that the bindings are mutually-recursive though
23:45:02 <fosskers> getFibs n = [y | x <- [1..], y <= n] where y = fib x
23:45:13 <kmc> > let odds = 1 : map succ evens; evens = map succ odds in odds
23:45:14 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
23:45:55 <fosskers> the compiler is wining at me about scope issues
23:45:59 <jmcarthur> fosskers: x is not in scope in that where clause. also, i'm not sure if you intend to shadow the y you define in the where clause with the y you bind in the list comprehension
23:46:06 <kmc> > let f=map succ;o=1:f e;e=1:f o in o
23:46:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:46:17 <kmc> > let f=map succ;o=1:f e;e=f o in o
23:46:19 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
23:46:40 <jmcarthur> oh wait, the y isn't bound there anyway, nevermind
23:46:41 <fosskers> jmcarthur: the alternative is this
23:47:00 <mauke> fosskers: no, let
23:47:03 <fosskers> jmcarthur: [fib x | x <- [1..], fib x <= n]
23:47:17 <fosskers> but i was afraid that doulbe-fibbing would be silly
23:47:22 <mauke> it is
23:47:31 <jmcarthur> fosskers: [y | x <- [1..], y <- [fib x], y <= n]  -- another way
23:47:48 <mauke> there's nothing wrong with "let"; use it
23:48:00 <fosskers> im writing a script though
23:48:02 <Nereid> fosskers: it might not be what you want though, since that list will never terminate
23:48:08 <_Ray_> hrm. about the goLeft . goRight thing... could I actually define this? if I build room1 first, I have to build it without a "left" node. I can then say that room2's "right" is room1, but once I step into room1 by going right from room2, how can I go back? rememnber room1 had no "left"
23:48:23 <mauke> _Ray_: no, you have to build all rooms at once
23:48:39 <Nereid> fosskers: for example, getFibs 3 will be 0:1:1:2:3:_|_
23:48:41 <_Ray_> can a mortal do that?
23:48:48 <mauke> _Ray_: sure
23:48:50 <jmcarthur> a mortal an indeed do it
23:48:52 <jmcarthur> *can
23:48:55 <fosskers> jmcarthur: that extra list creation (<- [fib x]) seems unecessary
23:49:02 <mauke> _Ray_: did you see the evens/odds example above?
23:49:17 <jmcarthur> fosskers: now is not the time to be micro-optimizing ;)
23:49:18 <_Ray_> oh, that was for me? I thought it was about the fibs thing. *reads*
23:49:19 <mauke> fosskers: it is
23:49:25 <Nereid> fosskers: that is, if you put it into ghci,
23:49:26 <jmcarthur> but yeah, mauke is right
23:49:29 <Nereid> you will see [0,1,1,2,3,
23:49:30 <jmcarthur> let!
23:49:35 <Nereid> and it will hang
23:49:36 <fosskers> ah
23:49:43 <Nereid> er, [0,1,1,2,3
23:49:43 <fosskers> snap
23:49:49 <fosskers> actually, that's okay
23:49:50 <fosskers> thats what i want
23:49:55 <Nereid> really
23:49:56 <Nereid> ok ;)
23:49:59 <fosskers> lazy eval to the rescue
23:50:13 <_Ray_> let odds = 1 : map succ evens; evens = map succ odds in odds <-- my head explodes.
23:50:26 <_Ray_> I can parse it just fine, but a computer... shouldn't be able to D:
23:50:37 <Nereid> _Ray_: just expand it out and it'll work ;)
23:50:40 <ion> Just expand it manually as the computer would do.
23:50:44 <jmcarthur> your head only explodes because you are trying to think about what the computer does instead of what the code means ;)
23:50:45 <Nereid> fosskers: if you wanted [0,1,1,2,3] instead, use something like a takeWhile
23:51:03 <fosskers> Nereid: takeWhile eh...
23:51:25 <kmc> odds = 1 : map succ evens = 1 : map succ (map succ odds) = 1 : map succ (1 : map succ evens) = 1 : 2 : map succ (map succ evens) = ...
23:51:30 <Nereid> getFibs n = takeWhile (<= n) [fib x | x <- [1..]]
23:51:38 <tcard> takeWhile (<= n) (map fib [1..])
23:51:42 <Nereid> or, even, that
23:51:47 <fosskers> aha! this might word
23:51:48 <fosskers> work
23:51:57 <jmcarthur> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs  -- another one for you, _Ray_ ;)
23:51:57 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:52:01 <fosskers> in fact it will!
23:52:16 <Nereid> fosskers: however, it's better to construct the whole list of fibs at once
23:52:32 <Nereid> like, say, what jmcarthur just wrote
23:52:43 <_Ray_> that's parsed as 0 : 1 : (zipWith (+) fibs (tail fibs) in fibs)?
23:52:44 <jmcarthur> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<=100) fibs -- fosskers :D
23:52:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89]
23:52:58 <fosskers> what jmcarthur wrote slightly blew my mind
23:52:59 <kmc> _Ray_, no,  "in" terminates "let"
23:53:02 <_Ray_> oh, clearly not, yeah
23:53:04 <jmcarthur> _Ray_: move the right paren to the left of "in"
23:53:05 <kmc> the syntax is "let ... in ..."
23:53:25 <_Ray_> the expression comes after the "in", and a temporary substitution is given in the "let" part
23:53:25 <kmc> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
23:53:38 <jmcarthur> _Ray_: nothing temporary about let
23:53:40 <Nereid> fosskers: yet, if you expand it out, it makes sense
23:53:49 <kmc> fibs = 0 : 1 : zipWith (+) (0 : 1 : zipWith (+) fibs (tail fibs)) (tail (0 : 1 : zipWith (+) fibs (tail fibs)))
23:54:05 <fosskers> im still pretty new to haskell, and some of that wizardry is over my head
23:54:08 <jmcarthur> _Ray_: let defines sharing. it has operational meaning
23:54:11 <kmc> fibs = 0 : 1 : zipWith (+) (0 : 1 : zipWith (+) fibs (tail fibs)) (1 : zipWith (+) fibs (tail fibs))  -- apply "tail"
23:54:20 <_Ray_> sharing?
23:54:25 <kmc> fibs = 0 : 1 : 1 : zipWith (+) (1 : zipWith (+) fibs (tail fibs)) (zipWith (+) fibs (tail fibs))  -- apply "zipWith"
23:54:36 <Nereid> _Ray_: let x = something complicated in f x x
23:54:41 <Nereid> only evaluates x once
23:54:45 <jmcarthur> _Ray_: the same thing that causes that infinite list to be cyclic in memory
23:55:04 <Nereid> and that, for a more practical purpose
23:55:29 <sheikra> hey, I have a stupid question..  in the case expression, how do I express "for everything else ..." ?
23:55:36 <Nereid> sheikra: _ -> ...
23:55:39 <kmc> sheikra, the pattern _ matches anything
23:55:40 <_Ray_> otherwise
23:55:47 <jmcarthur> _Ray_: otherwise is for guards
23:55:50 <Nereid> _Ray_: no, you're thikning guards
23:55:51 <Nereid> :P
23:55:52 <ion> otherwise means True, not _
23:55:53 <_Ray_> damnit
23:56:02 * _Ray_ stays quiet.
23:56:08 <sheikra> but the compiler said "parse error on input `->'
23:56:11 <kmc> you don't have to stay quiet!
23:56:15 <Nereid> sheikra: hpaste
23:56:23 <kmc> man, you don't even know how much wrong advice i've given here
23:56:24 <kmc> it happens
23:56:30 <jmcarthur> heh, me too
23:56:32 <sheikra> okay
23:56:41 <jmcarthur> stupidly wrong, sometimes
23:56:42 <kmc> this isn't ##c, we won't flame you out of the channel for misremembering obscure details of C99 VLAs
23:56:50 <_Ray_> heh, thanks :)
23:57:20 <fosskers> alright guys im getting confused
23:57:22 <mauke> I'll do that
23:57:26 <ddarius> kmc: Of course.  We'd be worried about obscure details of Haskell 1.4.
23:57:48 * _Ray_ actually had that happen, when he asked if sizeof could be a preprocessor thing. "No, because C99 VLAs have expressions in them."
23:57:54 <Nereid> fosskers: you can do things compositionally, remember
23:58:00 <Nereid> first, generate the list of -all- fibonacci numbers
23:58:11 <kmc> yeah, sizeof a VLA is known only at runtime
23:58:12 <mauke> _Ray_: also because of the syntax
23:58:19 <sheikra> oh, damn. I found the problem...
23:58:21 <Nereid> then, only take the ones you want from tha tlist
23:58:27 <Nereid> that list*
23:58:33 <fosskers> Nereid: ive been spun around and forgotten how
23:58:36 <mauke> _Ray_: you can't do sizeof x with a macro
23:58:41 <sheikra> I tried to assign the "_" with the left hand side of "->"
23:58:42 <mauke> and the preprocessor isn't aware of types
23:58:51 <Nereid> fosskers: fibs = [fib x | x <- [1..]]
23:58:52 <sheikra> that increased the indentation...
23:58:57 <sheikra> truly stupid..
23:58:58 <Nereid> (or, more briefly, fibs = map fib [1..]
23:58:58 <fosskers> Nereid: all that zipWith business through me for a loop
23:59:08 <Nereid> and then, getFibs n = takeWhile (<= n) fibs
23:59:19 <Nereid> the nice thing about that is
23:59:26 <Nereid> well, one nice thing is
23:59:33 <Nereid> if you find a better way to generate fibs
23:59:38 <Nereid> (and there are better ways!)
23:59:45 <kmc> @quote _pizza_
23:59:45 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
23:59:53 <Nereid> then you can effect that, without changing the definition of getFibs
