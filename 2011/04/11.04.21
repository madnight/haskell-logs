00:04:12 <skurt> _n
00:29:04 <xrl> can someone help with type shenanigans in flattening a nested list? https://gist.github.com/933938
00:29:27 <xrl> I'm going off http://www.haskell.org/haskellwiki/99_questions/Solutions/7
00:33:33 <monqy> try flatten (List [Elem 1, Elem 2, Elem 3])
00:35:30 <xrl> monqy: works
00:35:45 <xrl> BUT, now how do I use it in my code?
00:35:55 <arcatan> xrl: what are you trying to do?
00:35:58 <xrl> why can't I invoke it with the literals in mind
00:36:17 <xrl> I flattening a list of lists of numbers
00:36:43 <xrl> factors :: Integral a => a -> [a]
00:37:27 <Vq> Because flatten can only flatten a possibly-nested-list of possibly-netsted-lists of numbers
00:37:27 <xrl> and I'm mapping a list of numbers with that
00:37:40 <arcatan> literal lists have type [a], whereas that flatten takes NestedList a, 
00:38:22 <xrl> so am I better off writing a special case flatten for my list of lists of numbers?
00:38:46 <arcatan> you can use concat
00:38:48 <arcatan> @type concat
00:38:49 <lambdabot> forall a. [[a]] -> [a]
00:38:50 <Vq> My description here isn't perfectly accurate, but the key is that [1,2,3] can never be nested.
00:38:52 <monqy> by list of lists of numbers, do you mean [[a]]?
00:38:57 <monqy> if so, yes use concat
00:39:03 <arcatan> > concat [[1,2,3], [4,5,6], [7,8]]
00:39:04 <lambdabot>   [1,2,3,4,5,6,7,8]
00:39:30 * xrl has been staring at this for too long
00:39:39 <xrl> at least I got some more hands-on time with the typing system ;)
00:39:42 <xrl> thanks for the tip
00:39:43 <Vq> @src concat
00:39:44 <lambdabot> concat = foldr (++) []
00:39:57 <xrl> ahh
00:40:03 <Vq> :/
00:40:16 <xrl> I really wanted to use flatten haha
00:42:29 <Vq> You can have a flatten which can flatten multiple nested lists if you implement a type-class for it, but it still has the restriction of requiring that the input has a specific depth, [1,[2]] is never valid Haskell.
00:43:08 <Jafet> Unless instance Num [a]
00:43:59 <xrl> Vq, ya, I now know that [1,[2]] is never valid... I think it is in Erlang, though!
00:44:07 <Vq> Jafet: true
00:44:20 <xrl> how's instance work?
00:44:21 <Vq> xrl: Correct, Erlang isn't statically typed
00:45:11 <Vq> xrl: instances describe how a specific type implements the features of a type-class, i recommend reading about them in a tutorial.
01:04:22 <xrl> can the typing system express that an input list must be sorted?
01:05:04 <ion> no
01:08:44 * xrl didn't think so
01:14:01 <mm_freak> xrl: yes, but only with your own list type, some type system extensions and a lot of code
01:14:18 <illissius> and also your own list element types.
01:14:27 <mm_freak> illissius: why?
01:14:50 <xrl> it sounds like the sorted list is just an alias for list but I'd make it so only a handful of functions output this alias
01:15:06 <xrl> make sure those few functions always spit out sorted lists and you're golden?
01:15:12 <illissius> mm_freak: is there any way for the type system to 'know' what the Ord instance for its elements defines, otherwise?
01:15:22 <illissius> the ordering information would also have to be present at the type level
01:15:34 <mm_freak> illissius: why?
01:15:56 <illissius> mm_freak: maybe I'm being dense, how would you do it?
01:16:15 <mm_freak> it will require one manual check
01:16:21 <mm_freak> data Sorted; data Unsorted
01:16:44 <illissius> xrl: yeah, was going to suggest that as an alternative, making a newtype and then enforcing the invariant manually in the operations you provide for it
01:17:02 <mm_freak> data List :: * -> * -> * where Nil :: List Sorted a; Cons :: a -> List s a -> List Unsorted a; SortedCons :: a -> List Sorted a -> List Sorted a
01:17:16 <mm_freak> there needs to be one smart constructor for SortedCons, which checks ordering
01:17:55 <illissius> ah, I see.
01:19:08 <illissius> I was thinking of the variant where the type system enforces 100% of it
01:22:36 <illissius> hmm, is there any reason you'd use newtype SortedList a instead of Map a Int?
01:23:50 <shachaf> illissius: Why would you use Map a Int for a sorted list?
01:27:39 <illissius> shachaf: I was thinking that 'walking' the Map would probably be not much slower than with a list, and maintaining the sortedness between operations would likely be faster (or, at the very least, it's a bunch of fiddly code which you don't have to write yourself)
01:27:56 <illissius> shachaf: the Int is to keep track of the number of duplicates
01:34:02 <shachaf> Ah, for duplicates. Otherwise you could use Data.Set.
01:34:16 <shachaf> illissius: http://hackage.haskell.org/package/multiset will do that for you, for what it's worth (it's a wrapper around Map a Int).
01:34:26 <cnonim> hi guys
01:34:28 <cnonim> how to write format for parseTime accepts any of  "%H:%M" or "%H:%M:%S"?
01:35:33 <xrl> can someone explain why this throws a parser error on the '<-'? maxOccurences lists entry = maximum [length $ filter (==entry) list, list <- lists]
01:36:40 <illissius> xrl: I think you want a | in place of the comma?
01:36:48 <xrl> ugh
01:36:51 <xrl> thanks! :)
01:36:59 <illissius> yw :)
01:38:11 <illissius> schroedinbug: ah, saw the idea on -cafe fwiw but didn't know there was already a package for it
01:39:28 <illissius> I meant shachaf, sorry.
01:42:19 <cnonim> can i write it simple?
01:42:22 <prem_> hey people
01:42:23 <cnonim> filter (\c -> (not (isSpace c)) && ('.' /= c)) "hello. wolrd. "
01:42:39 <prem_> which one should I learn erlang or haskell?
01:42:51 <vegai> prem_: both
01:43:14 <prem_> why? aren't they both concurrency oriented functional languages
01:43:17 <prem_> ?
01:43:30 <vegai> haskell isn't especially 'concurrency oriented'
01:43:31 <mux> erlang is concurrency oriented
01:43:39 <mux> haskell is general purpose, but also well suited to concurrency
01:44:13 <prem_> so why both? anything that haskell offers which erlang doesn't?
01:44:42 <mux> laziness, stronger and more powerful type system
01:44:52 <mux> but that doesn't mean it's not a good idea to learn both languages
01:44:59 * xrl concurs
01:45:12 <mm_freak> erlang supports language constructs for concurrency, which haskell does not
01:45:15 <xrl> I like erlang... I'd say it's easier to pick up than erlang
01:45:22 <mm_freak> but you don't need them in haskell
01:45:44 * vegai concurrs
01:45:53 <mux> to be perfectly fair, I suppose on should say erlang is both concurrency and availability oriented
01:45:58 <mux> s/on/one/
01:46:06 <mm_freak> vegai: except that almost everything in IO uses the concurrency system ;)
01:46:18 <prem_> yeah well I have good experience on java and Python..have been trying erlang and am quite fascinated
01:46:19 <mux> the hot patching features are not to be underestimated
01:46:38 <vegai> nor overestimated, like the erlang people sometimes do :)
01:46:44 * mux nods :)
01:46:45 <mm_freak> prem_: if you want to enter haskell, forget all of java and most of python ;)
01:47:08 <mm_freak> well, in erlang you have availability concerns
01:47:13 <mux> it's just that it's a piece of cake to implement an actors-like thin in haskell, to mimic erlang, whereas implementing the hot patching stuff in haskell is more involved, as far as I can see
01:47:23 <mm_freak> normally in haskell when that concern arises, it means the compiler is broken ;)
01:47:29 <mm_freak> (or you forgot to catch an exception)
01:47:30 <prem_> well I am cool with forgetting java, but python..:))
01:47:50 <prem_> listen you guys..I am guessing some of you have worked on both haskell and erl
01:48:11 <mm_freak> i haven't /worked/ with erlang, i just had a look at it
01:48:14 <prem_> so give me some real world cases where haskell can be a better suited language
01:48:18 <mm_freak> looked interesting, but i preferred haskell
01:48:24 <mm_freak> and that's the one i use productively
01:48:26 <prem_> than erland
01:48:31 <prem_> erlang I mean..sorry
01:48:39 <cnonim> haskell have function which type [(a -> Bool)]->(a -> Bool) ?
01:49:10 <mm_freak> prem_: web applications
01:49:11 <shachaf> cnonim: Which does what?
01:49:13 <mux> head :>
01:49:30 <mm_freak> prem_: and for me personally i'd also prefer to write servers in haskell
01:49:37 <cnonim> shachaf: like "and" only for functions
01:49:45 <mm_freak> i think, these two are right now the strongest applications for haskell
01:50:31 <prem_> mm_freak: from what i hear. yaws does the job pretty well
01:50:33 <mux> :t \x -> and . map ($x)
01:50:34 <lambdabot> forall a. a -> [a -> Bool] -> Bool
01:50:39 <mux> hm, not quite.
01:50:48 <yogsototh> Hi, could someone explain me how lazy evaluation works for this example : head' = foldr1 (\x _ -> x) . It blows my mind haskell understand he shouldn't look after the first element.
01:50:50 <cnonim> )
01:51:06 <prem_> mm_freak: and otp makes things really easy if you are writing a calable server
01:51:06 <shachaf> @pl \fs x -> and (sequence fs x)
01:51:06 <lambdabot> (and .) . sequence
01:51:09 <mux> cnonim: not entirely sure what you want here
01:51:25 <prem_> and of course it guarantees reliability
01:51:25 <mm_freak> prem_: i don't know them, but have a look at yesod and happstack
01:51:26 <shachaf> @pl \x fs -> and (map ($x) fs)
01:51:26 <lambdabot> all . flip id
01:51:34 <cnonim> mux: filter (\c -> (not (isSpace c)) && ('.' /= c)) "hello. wolrd. "
01:51:40 <mm_freak> prem_: for servers in erlang i'm missing some design patterns
01:51:46 <cnonim> i want write simple
01:51:59 <mux> you just want to apply multiple filters?
01:52:06 <cnonim> yes
01:52:10 <mm_freak> cnonim: you can leave out some of the parentheses
01:52:21 <mm_freak> otherwise it's not really possible to write this simpler
01:52:22 <prem_> mm_freak: ok mate..will surely look into haskell.sounds interesting..see you around
01:52:31 <mm_freak> have fun =)
01:52:46 <mux> :t \xs -> foldr (`filter` xs) []
01:52:47 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `[a]'
01:52:47 <lambdabot>     In the first argument of `foldr', namely `(`filter` xs)'
01:52:47 <lambdabot>     In the expression: foldr (`filter` xs) []
01:53:00 <mm_freak> yogsototh: well, do the first evaluation step
01:53:12 <mm_freak> and then consider that haskell evaluates lazily
01:53:40 <mm_freak> yogsototh: and if you still don't get it, use your search engine for "corecursion"
01:53:55 <mm_freak> i think sigfpe has a nice introduction called "data vs. codata" or something
01:54:25 <cnonim> mux: foldr it's bat solution IMHO
01:54:36 <mux> wat?
01:54:53 <yogsototh> thanks mm_freak. I completely understand why I, as human know not to look after the first element, but how the haskell find it is a bit difficult to understand.
01:55:35 <mm_freak> yogsototh: non-strict semantics
01:55:52 <mm_freak> in C when you cann f(x,y), then x and y get evaluated first
01:56:06 <mm_freak> in haskell not…  the function may well return without evaluating x and y
01:57:01 <shachaf> Ha, even SPJ abuses "lazy" to mean "non-strict".
01:57:55 <cnonim> mux: this function to filter a few times, I think it is better to function with multiple predicates
01:58:42 <cnonim> sorry for my english
02:01:32 <yogsototh> Thanks, I believe I get it now, I breaked the lazy evaluation by defining : head' = foldr1 (\x y -> x+y-y) 
02:01:42 <yogsototh> And now head' [1..] loop
02:06:02 <mm_freak> yogsototh: it depends on the strictness of your folding function
02:06:44 <mm_freak> if your function is non-strict in the second argument, then the resulting fold will be lazy
02:07:38 <mm_freak> cnonim: there is no difference between 'filter f . filter g' and 'filter (\x -> f x && g x)'
02:07:46 <mm_freak> cnonim: likely fusion will turn buth into the same code
02:07:52 <mm_freak> buth → both
02:20:21 <maxJadi> Hi, I have a confusing time to solve monadic type error when I change "do" to ">>=" function in "http://hpaste.org/45904/monad_type_error" any idea? 
02:21:30 <shachaf> @undo do { i <- getId; return $ iqSet (Just (SID i)) Nothing (Just ini) Nothing j }
02:21:30 <lambdabot> getId >>= \ i -> return $ iqSet (Just (SID i)) Nothing (Just ini) Nothing j
02:22:27 <shachaf> maxJadi: Putting (>>=) in parentheses does the opposite of what you want; also, $ is looser than almost everything, so with >>= the statement would be parsed as (getID >>= return) $ (iqSet (Just SID) Nothing (Just ini) Nothing j)
02:22:40 <shachaf> maxJadi: But see lambdabot for the correct @undoing.
02:31:52 <maxJadi> shachaf, Thank you, at first it was a little hard to get but I got the point....:)
02:33:53 <greb> hi
02:34:09 <cch> does ECMA-262 edition 3 was wholy supported in all mainstream browsers?
02:35:37 <ivan> IE6-8 has a pretty broken implementation of it
02:35:59 <cch> sorry, I mistook this as #javascript :)
02:36:00 <ivan> it takes months of JS programming before you get angry about it though
02:36:13 <jonkri> does anyone have any experience with haskelldb, yesod's persistant or some other type safe database interface and can recommend something?
02:37:30 <cch> ivan: I have been confused and angry and then frustrated
02:38:01 <merijn> jonkri: I think haskelldb is the most mature one? But afaik haskelldb, yesod's stuff and the happstack persistence layer are all fairly stable and decent
02:46:05 <jonkri> thanks merijn
02:46:36 <jonkri> i hope no one minds if i ask if one of happstack or yesod is generally preferred over the other :P
02:48:41 <Lemmih> jonkri: It's hard to find unbiased people.
02:49:42 <Lemmih> jonkri: I think acid-state (happstack) is the way to go, personally. (:
02:54:34 <jonkri> thanks Lemmih :)
03:01:53 <osfameron> is TaPL available as an eBook?
03:02:00 <zenzike> I'm interested in the functor instances found in the prelude, but I don't know where the prelude source is for this kind of thing. does anyone have a pointer?
03:02:04 <osfameron> ideally legally+cheaply
03:02:22 <osfameron> I suppose legally+not-having-to-remortgage-my-house would work too
03:03:00 <illissius> zenzike: the haddocks tend to have links to the source
03:03:08 <osfameron> (my other main option is to borrow it from local library, but tis very heavy ;-)
03:03:44 <zenzike> illissius: that's true, but I'm wondering where the functor instance for, say, the Maybe type is held, do you know?
03:04:27 <xarch> Control.Monad?
03:04:42 <illissius> zenzike: well, if you can't find it by ctrl-f in the source, i don't know offhand either
03:04:51 <shachaf> @src Maybe fmap
03:04:51 <lambdabot> fmap _ Nothing       = Nothing
03:04:51 <lambdabot> fmap f (Just a)      = Just (f a)
03:05:18 <xarch> hm no
03:05:31 <xarch> actually for Maybe it's in Data.Maybe
03:06:08 <zenzike> xarch: so the instances for prelude things are scattered around in different files?
03:06:35 <xarch> hm
03:06:45 <xarch> there's some in Control.Monad.Instances
03:06:48 <xarch> also
03:07:08 <xarch> there are*
03:09:37 <zenzike> @src (,) fmap
03:09:38 <lambdabot> fmap f (x,y) = (x, f y)
03:10:31 <ion> > fmap f (x, y)
03:10:32 <lambdabot>   Ambiguous type variable `b' in the constraints:
03:10:32 <lambdabot>    `GHC.Show.Show b'
03:10:32 <lambdabot>      a...
03:11:04 <ion> > fmap (f :: Expr -> Expr) (x, y)
03:11:05 <lambdabot>   (x,f y)
03:19:12 <dobblego> @hoogle a -> (a, a)
03:19:13 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
03:19:13 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
03:19:13 <lambdabot> Network.BufferType buf_splitAt :: BufferOp a -> Int -> a -> (a, a)
03:22:05 <dingfeng_> is there a way happstack be installed through "cabal install happstack" on windows, without msys/mingw or cygwin?
03:22:28 <vi> data ABC = ABC {right, below :: Array (Int, Int) Bool}. How to create new instance of ABC? 
03:23:06 <dcoutts> dingfeng_: it depends on whether the packages it depends on require non-standard C libs
03:24:57 <dingfeng_> specifically, i've been encountering "The package has a './configure' script. This requires a Unix comptability toolchain such as MinGW+MSYS or Cygwin; while installing the dependency "network-2.2.1.10"
03:25:55 * osfameron emails MIT press to ask if they'll release TaPL as an eBook
03:27:14 <dingfeng_> on the other hand, the installation instructions for happstack for windows doesn't mention cygwin or msys. i'm wondering whether it's considered standard to have those, or whether there's another way to install happstack on windows.
03:41:35 <vi> Strugling to understand how to create a new instance of data ABC = ABC {right, below :: Array (Int, Int) Bool}. Can someone help?
03:44:19 <shachaf> vi: ABC { right = someArray, below = someArray }
03:44:31 <shachaf> vi: Or ABC someArray someArray
03:45:36 <mm_freak> i must be very bored, but i just calculated the shortest possible code (i hope) for printing the character 'H' in brainfuck
03:45:46 <HugoDaniel> hello
03:45:59 <crystal-cola> mm_freak: how do you know it's the shortest?
03:46:12 <HugoDaniel> mm_freak: are you trying to print "Hello world" ?
03:46:16 <merijn> mm_freak: You're right, that does mean you're bored
03:46:26 <shachaf> mm_freak: What is it?
03:47:07 <mm_freak> ++++++++[->+++++++++<]>.
03:47:15 <mm_freak> the number of plusses given by this haskell code:
03:47:25 <mm_freak> > let f [] x = [[x]]; f p@(p0:ps) x = [(p0*x):ps, x:p] in minimumBy (comparing fst) . map (\ps -> (sum ps + 6*(length ps - 1), ps)) $ foldM f [] [2,2,2,3,3]
03:47:27 <lambdabot>   (23,[9,8])
03:47:38 <HugoDaniel> :)
03:47:52 <crystal-cola> Is the shortest hello world program known?
03:48:18 <FauxFaux> > "hello world"
03:48:18 <lambdabot>   "hello world"
03:48:24 <mm_freak> crystal-cola: i got the factors of 72 (ASCII 'H') and tried to find the subset, which has the smallest sum with the added overhead for each pair of []
03:49:15 <mm_freak> the factors 9*8 have the sum 17 with an additional overhead of 6 chars
03:49:27 <mm_freak> [-><]>
03:50:53 <shachaf> Things are simpler with http://samuelhughes.com/boof/
03:52:07 <FauxFaux> mm_freak: Has anyone written an optimising "compiler" (bf->bf) for brainfuck?  I'd ask google but I'm scared that it might have results. 
03:52:30 <mm_freak> FauxFaux: well, i think optimizing brainfuck isn't that interesting
03:52:40 <shachaf> FauxFaux: What kind of optimizations would you want to do?
03:52:43 <FUZxxl> @bf ++++++++[->+++++++++<]>.
03:52:43 <lambdabot>   H
03:52:57 <mm_freak> much more interesting is optimizing one of unlambda and lazy k
03:53:17 <FauxFaux> shachaf: For length.
03:53:26 <mm_freak> at least for code length, because the speed of an unlambda/lazy k program is almost not estimatable
03:53:30 <HugoDaniel> optimization: write a compressor/decompressor in brainf*ck so that your source code is smaller :)
03:54:07 <HugoDaniel> oh, and interpreter
03:54:11 <HugoDaniel> offcourse
03:54:13 <mm_freak> i'd be interested in a lambda-to-unlambda compiler
03:54:26 <mm_freak> shouldn't be too difficult to write in haskell
03:54:28 <ClaudiusMaximus> i need to finish my bf-related project this year, given the 400th anniversary...
03:54:36 <HugoDaniel> ahah
03:54:48 <HugoDaniel> 400th anniversary of brainf*ck ? its old :)
03:55:04 <HugoDaniel> does it make the oldest programming language in the world ?
03:55:34 <shachaf> mm_freak: What do you mean? Just a plain lambda-calculus-to-Unlambda compiler?
03:56:19 <ClaudiusMaximus> HugoDaniel: this irc is too short to contain the text i've already written here: http://claudiusmaximus.goto10.org/cm/2010-06-15_king_james_hyperfuck.html  (the original text was published in 1611, apparently)
03:56:28 <mm_freak> shachaf: yes
03:56:42 <mm_freak> shachaf: or lambda-to-lazy k
03:56:56 <mm_freak> because lambda-to-unlambda is not really possible
03:57:35 <shachaf> mm_freak: So a restricted @pl? :-)
03:58:05 <ClaudiusMaximus> HugoDaniel: you can play with an unfinished js/svg version here.. http://claudiusmaximus.goto10.org/g/kjhf/kjhf.svg?code=+[[^\%3E+^%3C/+]+[^/%3C+^%3E\+]+^+]
03:59:57 <HugoDaniel> ClaudiusMaximus: man, you are in risk of becoming my personal hero!
04:00:11 <erus`> reddit is down :(
04:00:24 <crystal-cola> i told you not to take the website down
04:00:55 <ClaudiusMaximus> HugoDaniel: oh, thanks :)
04:01:42 <mm_freak> shachaf: sort of =)
04:01:44 <merijn> erus`: I know, now I'll have to be productive and write code :p
04:02:13 <erus`> merijn: no you don't, it works in incognito mode if you have crome. Thank me later
04:02:51 <shachaf> mm_freak: http://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis describes the transformation rules. Do you mean anything other than that?
04:04:34 <mm_freak> shachaf: i don't know if they are the same, but the unlambda guy described the rules, too
04:04:42 <mm_freak> "abstraction elimination"
04:36:36 <tarrasch> Hello. I'm installing a cabal package, but it fails. I use Ubuntu 10.10 and this is the error I get: http://hpaste.org/45906/installing_baseunicodesymbol, any ideas?
04:40:56 <beastaugh> looks like one of the imports into Control.Arrow.Unicode is failing
04:41:19 <tarrasch> beastaugh, I suspect that since I don't have ghc 7 yet, it cant handle unicode, or something
04:41:58 <beastaugh> well, the package says base 3 and up
04:42:04 <beastaugh> so it should be ok
04:42:31 <beastaugh> http://code.haskell.org/~roelvandijk/code/base-unicode-symbols/Control/Arrow/Unicode.hs
04:43:00 <beastaugh> the line "import Control.Arrow ( (>>>), (<<<) )" clearly isn't being run
04:43:46 <tarrasch> so I have base  >= 3.0.3?
04:44:23 <tarrasch> (looking at #ifs)
04:44:44 <beastaugh> run `ghc-pkg list | grep base` to find out
04:46:30 <tarrasch> http://hpaste.org/paste/45906/installing_baseunicodesymbol#p45907
04:46:37 <tarrasch> Is it standard having 2 bases?
04:46:56 <tarrasch> anyway, both are >= 3.0.3
04:51:52 <beastaugh> definitely something odd going on
04:51:59 <beastaugh> what GHC are you running? 6.12?
04:55:52 <crystal-cola> how do I make it so you can type in ??
04:56:04 <crystal-cola> main = do s <- "readStrings" 
04:56:22 <crystal-cola> but I want to be able to delete also
04:56:39 <crystal-cola> obviously not readStrings but what?
04:56:55 <crystal-cola> in ghci 6.12.1
04:59:34 <MasseR> crystal-cola: Sorry, I don't understand from that what you want
04:59:55 <crystal-cola> ill just use readLine
05:00:11 <crystal-cola> getLine
05:00:55 <roconnor> crystal-cola: in LineBufferingMode, nothing will be read from stdin until return is pressed
05:19:34 <handonson> attoparsec doesn't have lookAhead. can I implement it with the library functions?
05:39:31 <adamvh> > f x = id
05:39:32 <lambdabot>   <no location info>: parse error on input `='
05:39:51 <adamvh> >let f x = id
05:40:07 <crystal-cola> > let f x = id in f f
05:40:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
05:40:08 <lambdabot>    arising from a use of `...
05:40:16 <tibbe> argh, when can we get a sane package dependency hierarchy so that small packages like deepseq doesn't pull in the whole world
05:40:58 <adamvh> tibbe:  Speaking of which ... I wanted to add a function to convert between Data.Graph and Data.Tree to one or another of those packages
05:41:11 <adamvh> tibbe: but it seems like maybe it would be best for me to create a third package?
05:41:18 <adamvh> So they don't depend on each other?
05:41:31 <tibbe> adamvh: yes please, if at all possible
05:42:50 <adamvh> tibbe: But the case of "I have data structure A and want to turn it into data structure B, but I don't want the implementations to depend on each other" seems like a common enough problem that we should have some kind of convention
05:43:14 <tibbe> adamvh: I don't quite follow.
05:43:26 <tibbe> there are n^2 such conversions possible
05:43:46 <adamvh> tibbe:  Well, like the case of Data.Graph and Data.Tree
05:44:02 <adamvh> these are data structures that are useful independently of one another
05:44:14 <adamvh> but you may want to travel from one to another
05:44:29 <adamvh> I can imagine various other data structures
05:44:45 <adamvh> like a Data.Vector and a Data.Set, or something like that
05:45:03 <adamvh> with the way the package system as I understand it is
05:45:36 <adamvh> you pretty much have to create a new module to convert between the two
05:45:57 <tibbe> I see
05:46:02 <adamvh> unless you want to make the packages mutually dependent
05:46:07 <tibbe> sometimes you can use a data structure to broker the conversion
05:46:24 <tibbe> e.g. treeToList and graphFromList
05:46:29 <adamvh> Right, it's not a huge stumbling block for me personally
05:46:32 <tibbe> with laziness that can be efficient
05:46:36 <tibbe> not always the case though
05:46:52 <adamvh> I just meant that it's maybe some thing we should thing about w/r/t to the package system
05:46:58 <adamvh> *think
05:47:00 <tibbe> this is how STL works, it uses iterators to broker between different algorithms and data structures
05:47:05 <tibbe> maybe
05:47:09 <tibbe> I don't know what though :)
05:48:08 <adamvh> This is something that we'd solve with preprocessor macros in C-land
05:48:51 <dmead> whats the problem?
05:48:58 <adamvh> Some notion of "optional dependency" maybe...
05:49:24 <adamvh> dmead: How do you add a function converting from (a -> b)
05:49:34 <dmead> add it to what?
05:49:41 <adamvh> dmead: to a package without creating a dependency
05:50:09 <adamvh> dmead: So like, if I add (Data.Tree -> Data.Graph) to the Data.Tree package
05:50:20 <dmead> mmhmm
05:50:23 <adamvh> dmead: Data.Tree depends on Data.Graph now
05:50:26 <dmead> right
05:50:31 <dmead> that is unavoidable i think
05:50:53 <adamvh> right, so my thought process was that a notion of "optional depencies" would be nice
05:51:15 <dmead> sounds like something that wouldn't play nice with a static type checker
05:51:19 <adamvh> like, if I'm using Data.Tree and will never need to make a Data.Graph
05:51:52 <dmead> sounds like more of an optimization?
05:52:03 <dmead> i think doing things like that would make modules really unclear
05:52:12 <adamvh> Yeah, probably.
05:52:22 <dmead> i don't think you've got your static typing hat on :P
05:53:13 <adamvh> Well, yeah, I was thinking about how much easier it is in dynamic languages
05:53:21 <adamvh> that's what sent me off down this road
05:54:20 <FUZxxl> @bf ,------------------------------------------------>,------------------------------------------------>,------------------------------------------------>[-]+++++++++>[-]+++++++++>[-]+++++++++<<<<<[>>>>>>+>>>+<<<<<<<<<-]>>>>>>>>>[<<<<<<<<<+>>>>>>>>>-]<<<<<<<<[>>>>>>+>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]<<<<<<<[>>>>>>+>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]>>[-]<<<<<<<<[>>>>>>+>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]<<<<<[>>>>+>+<<<<<-]>>>>>[<<
05:54:20 <lambdabot>  Done.
05:54:21 <FUZxxl> <<<+>>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<<<<->>>->>>>>[-]<<<<<<<<[>>>>>>+>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]<<<<<[>>>>+>+<<<<<-]>>>>>[<<<<<+>>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>][-]<<<<<<<[>>>>>+>>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]<<<<[>>>+>+<<<<-]>>>>[<<<<+>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<<<->>>->>>>[-]<<<<<<<[>>>>>+>>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]<<<<[>>>+>+<<<<-]>>>>[<<<<+>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>
05:54:22 <FUZxxl> [-]>][-]<<<<<<[>>>>+>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<<->>>->>>[-]<<<<<<[>>>>+>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>]<[-]+<[-]+<<<<<<[>>>>>>[-]<<<<<<[-]]>>>>>>[[-]+<<<<<[>>>>>[-]<<<<<[-]]>>>>>[[-]+<<<<[>>>>[-]<<<<[-]]>>>>[[-]+<<<[>>>[-]<<<[-]]>>>[[-]+<<[>>[-]<<[-]]>>[[-]+<[>[-]<[-]]>[[-]+++++++++++++++++++++++++++++++++++++++++
05:54:26 <FUZxxl> ++++++++.-...>[-]<[-]]<>[-]]<<>>[-]]<<<>>>[-]]<<<<>>>>[-],------------------------------------------------>,------------------------------------------------>,------------------------------------------------>[-]+++++++++>[-]+++++++++>[-]+++++++++<<<<<[>>>>>>+>>>+<<<<<<<<<-]>>>>>>>>>[<<<<<<<<<+>>>>>>>>>-]<<<<<<<<[>>>>>>+>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]<<<<<<<[>>>>>>+>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]>>[-]<<<<<<<<[>>>>>>+>>+<<<<<<<<-]>>>
05:54:31 <FUZxxl> >>>>>[<<<<<<<<+>>>>>>>>-]<<<<<[>>>>+>+<<<<<-]>>>>>[<<<<<+>>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<<<<->>>->>>>>[-]<<<<<<<<[>>>>>>+>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]<<<<<[>>>>+>+<<<<<-]>>>>>[<<<<<+>>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>][-]<<<<<<<[>>>>>+>>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]<<<<[>>>+>+<<<<-]>>>>[<<<<+>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<<<->>>->>>>[-]<<<<<<<[>>>>>+>>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]<<<<[>>>+
05:54:36 <FUZxxl> >+<<<<-]>>>>[<<<<+>>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>][-]<<<<<<[>>>>+>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<<->>>->>>[-]<<<<<<[>>>>+>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>]<[-]+<[-]+<<<<<<[>>>>>>[-]<<<<<<[-]]>>>>>>[[-]+<<<<<[>>>>>[-]<<<<<[-]]>>>>>[[-]+<<<<[>>>>[-]<<<<[-]]>>>>[[-]+<<<[>>>[-]<<<[-]]>>>[[-]+<<[>>[-]<<[-]]>>[[-]+<[>[
05:54:37 <adamvh> w
05:54:38 <adamvh> t
05:54:38 <adamvh> f
05:54:41 <FUZxxl> -]<[-]]>[[-]+++++++++++++++++++++++++++++++++++++++++++++++++.-...>[-]<[-]]<>[-]]<<>>[-]]<<<>>>[-]]<<<<>>>>[-]]<<<<<>>>>>[-]]<<<<<<>>>>>>>[<<<<<<<<[>>>>>>+>+<<<<<<<-]>>>>>>>[<<<<<<<+>>>>>>>-]>[-]++++++++++<<+<<<<<<+>>>>>>>>>>>[-]<<<<<[>>>+>>+<<<<<-]>>>>>[<<<<<+>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<->>->>>[-]<<<<<[>>>+>>+<<<<<-]>>>>>[<<<<<+>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>]<<<<[
05:54:42 <absentia> beep beep beep?
05:54:46 --- mode: ChanServ set +o quicksilver
05:54:46 <FUZxxl> -]+<[>[-]<[-]]>[[-]+>[<[-]>[-]]<[<<<<<<<[-]<+>>>>>>>>[-]]><[-]]<<<<<<<<[>>>>>>+>>+<<<<<<<<-]>>>>>>>>[<<<<<<<<+>>>>>>>>-]>[-]++++++++++>>>[-]<<<<<<[>>>>+>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>[<<<<<<->>>->>>[-]<<<<<<[>>>>+>>+<<<<<<-]>>>>>>[<<<<<<+>>>>>>-]<<<[>>+>+<<<-]>>>[<<<+>>>-][-]<<[>>[-]<[>[-]+<[-]]<[-]]>[-]>]<<<<[-]+<<[>>[-]<<[-]]>>[[-]+>[<[-]>[-]]<[<<<<<<<<[-]<+>>>>>>>>>[-]]><[-]]<<<<<<
05:54:48 --- kick: FUZxxl was kicked by quicksilver (FUZxxl)
05:54:50 <adamvh> blee bloo
05:54:58 <absentia>  bf?
05:55:01 <haitong> ...
05:55:08 <Itkovian> nice shot.
05:55:18 <parcs> what would be the best way of getting a process's memory usage on unix (through haskell)?
05:55:18 <quicksilver> well I could have been faster
05:55:31 <companion_cube> a spambot coded in bf, how deliciously decadent
05:55:34 <quicksilver> I thought it might have finished :)
05:56:08 <dmead> companion_cube, i'll get the chocolate sauce
05:56:26 <adamvh> So I take it lambdabot does *not* have a bf interpreter
05:56:35 <quicksilver> it does, adamvh 
05:56:42 <adamvh> Ah
05:56:50 <quicksilver> hence the @bf at the beginning of the paste
05:56:58 <adamvh> So what was FUZxxl trying to accomplish?
05:56:59 <nazgjunk> and the "done" after that first line
05:57:15 <quicksilver> I presume FUZxxl didn't realise it won't do the right thing with multiple lines though.
05:57:27 <quicksilver> really I should have simply quietted him.
05:57:50 <adamvh> I must confess that my curiosity was piqued
05:59:13 <parcs> never mind, i found i found the "proc" package :)
05:59:39 <tarrasch> beastaugh, sorry for my abscence, I use ghc version 6.12.1, standard for Ubuntu 10.10
06:03:54 <tarrasch> beastaugh, I'll file a bug report on this to the maintainer of the package
06:03:58 <ecyrb> first3 :: (a, b, c) -> a;  first3 x y z = x;   <- gives me an occurs check
06:04:34 <ecyrb> what exactly am I doing wrong?
06:04:49 <ecyrb> (yes, I'm a newbie)
06:05:21 <companion_cube> it's first3 :: a -> b -> c -> a
06:05:35 <companion_cube> or first3 (x,y,z) = x
06:05:52 <ecyrb> companion_cube: Thanks.  I'm a dolt.
06:18:17 <adamvh> > let [a,b,c]=1,2,3 in print b
06:18:17 <lambdabot>   <no location info>: parse error on input `,'
06:18:31 <adamvh> > let [a,b,c]=[1,2,3] in print b
06:18:32 <lambdabot>   <IO ()>
06:18:49 <adamvh> > let [a,b,c]=[1,2,3] in b
06:18:50 <lambdabot>   2
06:20:55 <adamvh> > let d@[a,b,c]=[1,2,3] in d
06:20:55 <lambdabot>   [1,2,3]
06:31:33 <andras> I'm having problems with serialport-0.4.0.1 on Windows -- can anyone help?
06:32:32 <andras> I tested it a while ago with 0.3.3 or so and back then at least I didn't get any error messages when opening the COM ports
06:33:06 <andras> now I "openSerial "COM1" defaultSerialSettings { commSpeed = CS57600 }" gives an error "CreateFile "COM1": permission denied"
06:35:32 * andras wonders why
07:08:47 <handonson> attoparsec doesn't have lookAhead. can I implement it with the library functions?
07:21:18 <jonkri> i have two simple types which should share some properties, see [ http://hpaste.org/45910/common_accessors ]. is there some nicer way that i can define this types, perhaps so that it's not possible to get a runtime error such as "*** Exception: No match in record selector itemSize"?
07:26:46 <roconnor> monochrom, copumpkin: qsieve is impossible to build and msieve is very slow (at least msieve without the gmp-ecm library).
07:27:00 <copumpkin> hmm, I definitely have an installed qsieve
07:27:05 <copumpkin> roconnor: want an account on my box with it?
07:27:07 <adnam> jonkri: make itemSize a regular function and not an accessor
07:27:20 <Jafet> ...why use msieve for gmp-ecm?
07:27:24 <jonkri> adnam: thanks :)
07:27:36 <Jafet> You can use gmp-ecm separately, with a lot more control.
07:27:40 <roconnor> copumpkin: how did you install qsieve?
07:27:57 <roconnor> Jafet: I don't know.  copumpkin mentioned qsieve and mseive to me
07:28:05 <copumpkin> roconnor: no idea :P I was trying to factor a small RSA modulus a while ago and needed it
07:28:09 <roconnor> Jafet: why would anyone use mseive?
07:28:16 <copumpkin> I probably just grabbed the source and compiled it
07:28:23 <adnam> jonkri: maybe there's a prettier way, i feel like i forgot how to haskell
07:28:31 * hackagebot ls-usb 0.1.0.9 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.9 (RoelVanDijk)
07:28:41 <Jafet> msieve is fairly good at actual sieving – quadratic sieve and number field sieve.
07:28:47 <roconnor> copumpkin: http://packages.debian.org/src:qsieve gives no result
07:28:58 <copumpkin> yeah, I'm usually not deterred by that :P
07:29:08 <copumpkin> http://www.thorstenreinecke.de/qsieve/
07:29:15 <Jafet> If you just want ecm, debian builds gmp-ecm.
07:29:19 <roconnor> copumpkin: I found the source
07:29:24 <kwantam> adnam, jonkri: seems to me like another way to do it is to use explicit pattern matching in functions that have to differentiate between Objects of different types
07:29:26 <roconnor> copumpkin: I claim it doesn't build on a modern gcc
07:29:36 <roconnor> copumpkin: or I am an idiot
07:29:39 <roconnor> maybe both
07:29:48 <copumpkin> hmm, maybe I don't have a particularly modern gcc on my vps
07:29:57 <copumpkin> 4.2.4
07:30:02 <kwantam> e.g., someFunction (Item oID pID iS iH) = foo
07:30:11 <kwantam> someFunction (Container oID oPID) = bar
07:30:16 <Jafet> Must be a gcc regression!!
07:30:17 <copumpkin> my qsieve was compiled with (Jul 21 2008, 19:45:59 using gcc 4.1.3 20070929 (prerelease) (Ubuntu 4.1.2-16ubuntu2))
07:30:21 <roconnor> Jafet: is msieve ever faster than gmp-ecm?  Like with numbers that a a product of two large primes?
07:30:24 <copumpkin> man, I built it a long time ago, eh :P
07:30:35 <adamvh> > fmap (1+) $ Just 5
07:30:36 <lambdabot>   Just 6
07:30:41 <roconnor> $ gcc --version
07:30:42 <roconnor> gcc (GCC) 4.5.1
07:30:49 <roconnor> copumpkin: if I use an older gcc I have to recompile gmp
07:30:54 <adamvh> > fmap (1+) $ Nothing
07:30:54 <lambdabot>   Nothing
07:30:56 <Jafet> roconnor: msieve implements QS and NFS. gmp-ecm implements ECM. msieve then uses the ECM from gmp-ecm.
07:30:58 <copumpkin> roconnor: ah :/
07:31:03 <Jafet> They're rather incomparable
07:31:06 <copumpkin> roconnor: well, you're welcome to an account on my vps if you want
07:31:09 <roconnor> :)
07:31:24 <roconnor> copumpkin: maybe I'll compile gmp-ecm
07:31:30 <Jafet> For the numbers you mentioned, QS and NFS are exponentially better than ECM.
07:31:32 <roconnor> Jafet: incompareable?  don't they both factor numbers?
07:31:41 <Jafet> Using rather different algorithms.
07:32:04 <adnam> okay i take it back jonkri, sorry, i would make Item a separate type (with itemSize and itemHash) and let Object have value that is Maybe Item
07:32:26 <roconnor> Jafet: I ran msieve and it looked to me like it was going to take hours or maybe days to solve what copumpkin did in minutes with qsieve.
07:32:32 <kwantam> adnam, that seems nice.
07:32:59 <Jafet> What did copumpkin do?
07:33:09 <roconnor> Jafet: I think copumpkin ran qsieve
07:34:09 <kwantam> however if you were going to have a large number of different object types that all had somewhat different sets of params, it would quickly become a pain to have a huge number of Maybes. At that point, the answer is arguably "don't do it this way."
07:34:17 <copumpkin> Jafet, roconnor: I also said "abracadabra" as I ran it
07:34:30 <copumpkin> I've heard that makes it linear in the number of bits
07:34:49 <Jafet> You sneaky cad
07:34:49 <kwantam> perhaps the right way in that case is to make an Object-ish typeclass and provide whatever commonality you require that way
07:35:05 <roconnor> copumpkin: are you running a supercomputer?
07:35:15 <roconnor> or a cluster of some sort?
07:35:16 <copumpkin> roconnor: I don't think so :) it's a 512MB slicehost slice
07:35:25 <copumpkin> it has hefty CPU but not much memory
07:35:28 * copumpkin finds out
07:35:47 <copumpkin> 4-core opteron
07:35:53 <copumpkin> 2ghz
07:36:03 <copumpkin> but I share that with other VPS instances
07:36:35 * roconnor has a Intel(R) Core(TM)2 Duo CPU     P8800  @ 2.66GHz
07:36:44 <copumpkin> that should be fine, I'd guess
07:36:51 <Jafet> Maybe copumpkin crafted a number that could be rapidly factored from the random seed "abracadabra"
07:36:58 <roconnor> I don't understand why msieve was taking so long
07:37:01 <fenfrie> who could help me to get this main function with tuples running http://hpaste.org/45912/tuples
07:37:06 <roconnor> oh
07:37:17 <copumpkin> keep in mind that monochrom's mysterious magic munchkin factorizer in haskell also factored those numbers in reasonable time
07:37:48 <kwantam> putStrLn $ snd (tuple getStr)
07:37:54 <shachaf> fenfrie: Your confusion has less to do with tuples than it does with IO.
07:37:56 <gente> wc
07:38:22 <Jafet> roconnor: what was the number?
07:38:24 <Saizan> it's not even about IO, just function application
07:38:24 <adnam> fenfrie: if you check the compiler error you will see that it says that the error is In the first argument of `putStrLn', namely `snd'
07:38:47 <roconnor> Jafet: 10^120 + 226 I beleive
07:38:49 * roconnor checks
07:39:20 <pithworm> so guys, i'm pretty confused by the huge selection of haskellian GUI libs
07:39:44 <adnam> fenfrie: as opposed to In the first argument of `putStrLn', namely `snd (tuple getStr)`
07:39:45 <roconnor> opps
07:39:49 <roconnor> Jafet: 10^120 + 266
07:40:00 <pithworm> i want to write a simple one text field input and one submit button gui for that wholesale.hs thing
07:40:25 <pithworm> so i can package it all into a simple exe for a friend
07:40:34 <kwantam> pithworm: it would be pretty trivial code-wise in Gtk2Hs
07:40:43 <Jafet> roconnor: that number has many small factors, did you ask msieve to try ecm?
07:40:58 <kwantam> pithworm: is there some criterion for "best solution" other than number of lines of code it'll take?
07:41:00 <roconnor> Jafet: I don't have ecm install yet
07:41:01 <pithworm> kwantam: what about all those reactive programming thingies?
07:41:12 <roconnor> Jafet: you said ecm would take expontially longer on my numbers
07:41:18 <kwantam> pithworm, not sure I know what you mean.
07:41:19 <fenfrie> adnam, ah okay i just have to make some additional ()
07:41:23 <pithworm> kwantam: i want to learn the haskellian way
07:41:26 <pithworm> kwantam: oh, wait
07:42:01 <pithworm> kwantam: http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries#High-level
07:42:18 <pithworm> kwantam: these libraries are high level
07:42:26 <Jafet> roconnor: you were talking about "numbers that a [sic] a product of two large primes", which 10^120+266 is not
07:42:36 <pithworm> like, the haskell way of GUI-ing
07:42:36 <roconnor> oh
07:42:49 <adnam> fenfrie: that will work. can be a good idea to use parens a lot if you get confused by the precedence, you can always remove unnecessary ones later
07:42:57 <kwantam> pithworm, I see. I suppose I'm not familiar with the Haskell Way of GUI-ing, then, because I've always just used Gtk2Hs directly
07:43:17 <pithworm> kwantam: do you recommend on just forgetting that for now and concentrating on just writing the gui in gtk2hs?
07:43:18 <kwantam> which is admittedly rather unHaskell :)
07:43:19 <roconnor> Jafet: sorry for the confusion.  I was trying to give an example of where msieve might be faster.
07:43:29 <roconnor> Jafet: my number is of the form p-1
07:44:01 <kwantam> pithworm, entirely depends on your goal I suppose. If the goal is to be done in 5 minutes, Gtk2Hs satisfies it. If the goal is erudition and The Haskell Way, apparently it does not :)
07:44:03 <roconnor> i wanted to know what the subgroups of F_p* looked like.
07:44:40 <pithworm> kwantam: hey, i really want to get this thing working asap. i can just learn that later.
07:45:17 <dcoutts> pithworm, kwantam: gtk2hs is no worse than readFile imho, from the pov of the "true Haskell way"
07:45:27 <roconnor> > replicateM 2 "pq"
07:45:28 <lambdabot>   ["pp","pq","qp","qq"]
07:45:42 <kwantam> pithworm, seems to me like pretty much any gtk2hs tutorial is going to get you to the point where you can make an input, a button, and a callback for same.
07:45:55 <quicksilver> dcoutts: readFile is far worse than gtk2hs as far as I know :)
07:45:57 <pithworm> dcoutts: what do you mean by that?
07:46:02 <dcoutts> quicksilver: hah
07:46:02 <roconnor> > [0..] >>= flip replicateM [3,5]
07:46:04 <lambdabot>   [[],[3],[5],[3,3],[3,5],[5,3],[5,5],[3,3,3],[3,3,5],[3,5,3],[3,5,5],[5,3,3]...
07:46:18 <pithworm> quicksilver: O_o what do you mean by THAT? i'm confused.
07:46:24 <roconnor> > [0..] >>= product . flip replicateM [3,5]
07:46:24 <lambdabot>   No instance for (GHC.Num.Num [a])
07:46:25 <lambdabot>    arising from a use of `e_1035' at <int...
07:46:29 <roconnor> > [0..] >>= (product . flip replicateM [3,5])
07:46:30 <lambdabot>   No instance for (GHC.Num.Num [a])
07:46:30 <lambdabot>    arising from a use of `e_1035' at <int...
07:46:48 <quicksilver> pithworm: readFile uses interleavedIO which delays IO and does it on demand, triggered by the (pure) functions whch consume that data.
07:46:51 <roconnor> > [0..] >>= (product `fmap` flip replicateM [3,5])
07:46:52 <lambdabot>   No instance for (GHC.Num.Num [a])
07:46:52 <lambdabot>    arising from a use of `e_1035' at <int...
07:46:54 <adamvh> > (1+) . (^2) $ 2
07:46:55 <roconnor> :/
07:46:56 <lambdabot>   5
07:46:57 <quicksilver> pithworm: that's pretty broken from a semantic perspective, although convenient.
07:46:58 <copumpkin> roconnor: anyway, if you need numbers factored just let me know :)
07:47:06 <roconnor> copumpkin: thanks.
07:47:17 <roconnor> copumpkin: how much does it cost you?
07:47:19 <pithworm> okay, so for now i'll go for gtk2hs and later convert that to w/e reactive or grapefruity thing i want
07:47:30 <Jafet> roconnor: msieve is fast at sieving, and reportedly very fast at sparse bit matrix reduction
07:47:34 <dcoutts> pithworm: I mean yes it's imperative, but it's not that bad. We have plenty of other imperative libs, like file IO. It doesn't destroy all the FP advantages. Indeed coding gtk in Haskell is far nicer than in most imperative languages.
07:47:45 <copumpkin> roconnor: 40 bucks a month, but I'm thinking of shutting it down eventually since I never use it for anything but occasional logins to run unix tools I don't have on my local machine :P
07:47:46 <dcoutts> closures are ideal for event handlers
07:47:54 <quicksilver> gtk2hs is a working usable library; reactive is a half-finished concept and even grapefruit is pretty experimental.
07:47:57 <Jafet> ...as fast as complexity theory allows it to be, that is
07:47:58 <roconnor> Jafet: but for smooth numbers, gmp-ecm is the way to go?
07:48:23 <pithworm> dcoutts: hey, haskell is one of my favorite imperative languages
07:48:34 <Jafet> msieve uses gmp-ecm as well, to detect smooth numbers
07:48:39 <kwantam> dcoutts, I agree 100% with your assessment of Gtk2Hs versus normal GTK, having just done a bunch of GTK stuff in C.
07:48:47 * copumpkin strokes the smooth number
07:49:34 <pithworm> okay, i see gtk2hs is cross-platform, enabling me to write for my friend
07:50:03 <kwantam> quicksilver: regarding readFile, it seems to me that if you can stretch your idea of Purity to include Clean's meaning (uniqueness types), and if you ensure in your readFile implementation that you preserve uniqueness, you're not _really_ breaking things any more than the entirety of the IO monad does.
07:50:04 <shachaf> copumpkin: Can you factor 6 for me?
07:50:15 <copumpkin> shachaf: just a sec, starting up my remote ssh session
07:50:20 <copumpkin> firing up qsieve
07:50:24 <pithworm> what i am aiming for is a nice egoboo so i can feel a bit less of a failure in life. :-D
07:50:36 <int-e> 6 = (1 + i) (-1 + i) * -3
07:50:36 <shachaf> copumpkin: Don't worry, I just need it by next month or so.
07:50:40 <copumpkin> = 2 (1)
07:50:40 <copumpkin> * 3 (1)
07:50:42 <copumpkin> tada!
07:50:48 <copumpkin> or int-e's solution
07:51:04 <fenfrie> how can i print in the do notation a data type like: data Tests = Test String [String] String
07:51:29 <copumpkin> :t print
07:51:30 <lambdabot> forall a. (Show a) => a -> IO ()
07:51:33 <roconnor> copumpkin: that seems expensive
07:51:39 <copumpkin> roconnor: yeah, it is
07:51:43 <shachaf> You have to derive Show for that, though.
07:51:46 <copumpkin> I also have a prgmr account that's a lot cheaper
07:51:51 <shachaf> copumpkin: Impressive.
07:51:52 <pithworm> hmm.. the haskell.org wiki page for gtk2hs links to the homepage but the homepage is borken
07:51:58 <copumpkin> shachaf: thanks
07:51:58 <roconnor> copumpkin: what is prgmr?
07:52:09 <dcoutts> pithworm: don't worry about that, it's on hackage.
07:52:23 <copumpkin> roconnor: http://prgmr.com/xen/
07:52:43 * shachaf found out recently that dedicated servers are apparently much cheaper in Germany than in the US for some reason.
07:52:49 <pithworm> i don't worry, just pointing that out. it seems to me that most of the homepages are borken and they're just switching to the wiki
07:52:55 <c1de0x> copumpkin nice
07:52:57 <kwantam> fenfrie, if you add a "deriving (Show)" clause at the end of your data declaration then you will get what you want.
07:53:00 <fenfrie> argh i always forget the ( )
07:53:01 <copumpkin> c1de0x: omg
07:53:11 * copumpkin hugs c1de0x 
07:53:16 <c1de0x> erm.
07:53:21 <shachaf> fenfrie: The parentheses aren't necessary in this case. :-)
07:53:22 <c1de0x> ok....
07:53:22 * hackagebot pez 0.0.3 - A Potentially-Excellent Zipper library  http://hackage.haskell.org/package/pez-0.0.3 (BrandonSimmons)
07:53:27 <fenfrie> it is derived from Show but i just forget the ( )
07:53:28 * copumpkin unhugs c1de0x 
07:53:30 <c1de0x> copumpkin i hope you're dressed
07:53:37 <fenfrie> now it works
07:53:59 <copumpkin> c1de0x: yep
07:54:06 <c1de0x> phew.
07:54:27 <c1de0x> so. i'm thinking of actually writing some haskell tmrw
07:54:29 <RichardBarrell> And pumpkin needs to be undressed in order to administer an unhug?
07:54:51 <copumpkin> c1de0x: holy crap! what kind?
07:54:57 <c1de0x> copumpkin you know what kind.
07:54:58 <c1de0x> ;)
07:55:01 <Saizan> United Nations Haskell User Group?
07:55:04 <copumpkin> hrrmpf okay :P
07:55:06 <Jafet> I pay about $5 for what copumpkin pays $40, on a German server
07:55:29 <quicksilver> kwantam: readFile doesn't violate referential transparency. It's just ugly. It breaks the implied IO monad promise, rather than purity.
07:55:32 <c1de0x> copumpkin i'm gonna work on a data-storage backend for our disassembler.
07:55:46 <roconnor> Jafet: $5 per month seems more than reasonable.
07:56:05 <roconnor> Jafet: that is cheaper than I pay for my shell account at theorem.ca
07:56:08 <kwantam> quicksilver, I guess what I was getting at is that the implied IO monad promise is sometimes stronger than it needs to be, as in this case.
07:56:10 <roconnor> by a little
07:56:16 <shachaf> $5/month is more than reasonable ==> reasonable is less than $5/month.
07:56:27 <copumpkin> Jafet: yeah, I'm not a fan
07:56:32 <quicksilver> kwantam: perhaps.
07:56:41 --- mode: quicksilver set -o quicksilver
07:56:59 <kwantam> but then again I am a recovering perl programmer, so it's not clear to me that I have any remaining reserves of "good judgement"
07:57:13 <Jafet> kwantam: until openFile: file handle limit exceeded
07:57:13 <c1de0x> recovering.
07:57:15 <c1de0x> heheh
07:57:23 <c1de0x> as if you can ever recover from perl.
07:57:27 <c1de0x> ;p
07:57:40 <kwantam> Jafet: merely a detail, sir! The outside world is a cruel and impure place!
07:57:49 <Jafet> (which of course, I only discovered during the production dry-run)
07:57:53 <kwantam> c1de0x: spoken like a fellow traveler
07:58:02 <kwantam> The Things I've Seen
07:58:07 <c1de0x> lol.
07:58:12 <c1de0x> i'm no perl-head.
07:58:31 <c1de0x> i've been preaching the anti-perl for years.
07:58:40 <c1de0x> dropping some perls of wisdom, yo.
07:58:48 <kwantam> be fair. perl is amazing when you need a chainsaw
07:58:49 <c1de0x> someone make me stop. please.
07:59:00 <c1de0x> kwantam perl sux. period.
07:59:04 <c1de0x> (.)
07:59:04 * shachaf hugs c1de0x.
07:59:16 <c1de0x> shachaf you israeli?
07:59:39 <shachaf> Yes, though I live in the US.
07:59:41 * dmwit hugs c1de0x
07:59:43 * shachaf unhugs.
07:59:52 <c1de0x> shachaf well, noone's perfect ;)
08:00:04 <c1de0x> seriously. what's with all the hugs?
08:00:11 <c1de0x> we should rename this channel gaskell
08:00:20 <c1de0x> :P
08:00:28 <kwantam> I just figured everyone was trying to evaluate everyone else
08:00:47 <c1de0x> kwantam is that a pugs joke?
08:00:53 <copumpkin> c1de0x does not appreciate the hugs :(
08:00:57 <Jafet> They're just trying to keep hugs alive.
08:01:00 <mm_freak> kwantam: as soon as you transform three monads in a stack for the first time, you know you have successfully recovered
08:01:07 <c1de0x> copumpkin human contact is for weenies
08:01:08 <copumpkin> c1de0x: the reason we're so huggy is http://www.haskell.org/hugs/
08:01:40 <kwantam> mm_freak thanks for the words of encouragement :)
08:02:03 <pmetzger> is any implementation other than ghc popular at the moment?
08:02:33 <Jafet> GHC isn't popular, just incumbent.
08:03:05 <shachaf> Well, to call any Haskell implementation "popular" might be stretching the word somewhat.
08:03:23 <c1de0x> it's like saying any one of us was 'popular' in high-school.
08:03:51 <c1de0x> sure, we were the most popular members of our various DnD groups, but still... not quite the intended usage of the word, right?
08:03:54 <c1de0x> :P
08:04:02 * c1de0x is feeling all whimsical like
08:04:23 <shachaf> The GHC of your D&D group, eh?
08:04:29 <pmetzger> By "popular" I mean "widely used among those who use haskell".
08:04:50 <c1de0x> pmetzger yeah. that's the same as the dnd popular ;)
08:05:02 <pmetzger> I'm new to the haskell world, it seemed like ghc was the only option so I didn't really think about other options.
08:05:15 <shachaf> c1de0x: Or as "high school popular", for that matter.
08:05:28 <c1de0x> shachaf why, weren't you the compiler of your particular dnd clan?
08:05:29 <shachaf> pmetzger: GHC is the only implementation that's practical for most things you'd want to do.
08:05:35 <adamvh> c1de0x: I have fond memories of working with Perl
08:05:49 <Jafet> What does pmetzger want to do?
08:05:50 <adamvh> c1de0x: some not so fond
08:05:56 <c1de0x> adamvh you must have some excellent drugs, or repressive mojo.
08:05:58 * pmetzger goes into convulsions remembering Perl...
08:06:07 <shachaf> Jafet: Ask questions in IRC about popularity.
08:06:24 <c1de0x> shachaf by all accounts, he is succeeding in his mission.
08:06:26 <c1de0x> +1 pmetzger 
08:06:27 <Jafet> Thank you, sir obvious.
08:06:27 <c1de0x> ;)
08:06:28 <pmetzger> Mostly I was just curious as to whether there were other fully seriously maintained implementations.
08:06:45 <shachaf> c1de0x: I'll avoid making references to assemblers and linkers and such.
08:06:46 <adamvh> c1de0x: It just made so many random Linux-ownership tasks so much less painful
08:06:47 <shachaf> (...Or not.)
08:07:16 <c1de0x> adamvh, meet bash. bash, meet a poor perlnick.
08:07:28 <c1de0x> shachaf i <3 my assembler
08:07:47 <adamvh> c1de0x: I don't think bash has a leg to stand on
08:07:54 <adamvh> as far as general language wonkiness
08:07:56 <c1de0x> adamvh it'd be pretty wierd if it did.
08:08:04 <c1de0x> ;)
08:08:13 <pmetzger> I've written a bunch of serious pay-code in Perl because it was the only reasonable choice, but I never loved it. I could never understand how you could have a language created after 1950 that didn't let you have named function parameter lists.
08:08:15 <c1de0x> i agree, bash is horrible, linguistically. 
08:08:26 <pmetzger> pardon, I meant after 1960
08:08:48 <c1de0x> but, still, i'd rather gnash my teeth on bash, then hurl over perl.
08:08:55 <kwantam> pmetzger that's what shift() is for :P
08:09:04 <shachaf> Doesn't Perl 5 allow named function parameters?
08:09:15 <pmetzger> not really.
08:09:16 <adamvh> pmetzger: anytime the project got big enough to need subroutines I just used common lisp
08:09:17 * shachaf is happy not to know.
08:09:18 <pmetzger> perl 6 you mean?
08:09:28 <kwantam> shachaf: no, but p6 does
08:09:32 <shachaf> Well, Perl 6, yes. But I thought Perl 5 had imported it at some point too.
08:09:41 <pmetzger> the irony is, the only working perl 6 implementation was written in haskell...
08:09:43 <Jafet> You mean "p6 will"
08:09:53 <adnam> if i define read' :: forall a . String -> a; read' = read, a will still be rigid, why? is it inherited from read?
08:10:06 <kwantam> p6 exists, it's just "not done yet"
08:10:16 <dmwit> adnam: read doesn't have that type
08:10:17 <Jafet> adnam: the dreaded monomorphism restriction
08:10:18 <hammer6> hello
08:10:25 <c1de0x> kwantam in the same way as alien life exists, it's just not found yet?
08:10:28 <Jafet> Oh, that first.
08:10:28 <dmwit> adnam: It has the type read' :: forall a. Read a => String -> a
08:10:29 <kwantam> perl5 has prototyping
08:10:39 <pmetzger> anyone who can look at the periodic table of perl 6 operators and not run screaming into the night has already had their soul killed by previous perl exposure.
08:10:42 <kwantam> c1de0x: well, but you can actually go and touch the alien that is perl6
08:10:48 <adnam> dmwit: sure, just forgot to type that just now :-s
08:10:49 <c1de0x> kwantam eeew.
08:10:53 <c1de0x> is that legal?
08:11:00 <dmwit> adnam: As for rigidity, I'm not sure. Hopefully somebody else can say more there.
08:11:09 <kwantam> yes, but it's strongly deprecated
08:11:16 <hammer6> anyone have cool infinite list tricks
08:11:32 <shachaf> hammer6: There's one at the end of [1..]. Go fetch it.
08:11:34 <dmwit> pmetzger: As if Haskell is short on operators.
08:11:38 <Twey> Heheh
08:11:45 <c1de0x> lol
08:11:50 <pmetzger> haskell operators are just diadic functions.
08:11:55 <pmetzger> and they're not burned into the metal.
08:12:01 <c1de0x> shachaf and i was so proud of myself for not biting on that one.
08:12:02 <dmwit> > mconcat . map First $ [0..]
08:12:03 <Twey> > fix $ zipWith (+) `ap` tail
08:12:03 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe a),
08:12:03 <lambdabot>                    GHC....
08:12:07 <lambdabot>   mueval-core: Time limit exceeded
08:12:14 <dmwit> > mconcat . map (First . Just) $ [0..]
08:12:16 <lambdabot>   First {getFirst = Just 0}
08:12:40 <hammer6> shachaf: I know that, I mean really advanced tricks that are not common
08:12:58 <shachaf> Know what?
08:13:08 <pmetzger> (not that I don't find them a bit weird. the way precedence is declared in haskell is so primitive. you can't say "this has higher precedence than X and lower than Y", you have to name a precedence level!)
08:13:11 <copumpkin> > fix((0:).scanl(+)1)
08:13:13 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:13:31 <shachaf> > fix((1:).scanl(+)1)
08:13:33 <lambdabot>  Terminated
08:13:36 <c1de0x> copumpkin that's nifty ;)
08:13:48 <shachaf> Wow, lambdabot. Preferential treatment like that?
08:13:58 <shachaf> @smack lambdabot
08:13:58 <lambdabot> Come on, let's all slap lambdabot
08:15:00 <Jafet> @vixen Really?
08:15:01 <lambdabot> i'll hafta plead the fifth on that one.
08:15:09 <tromp_> @pl \y -> f y(x+y)
08:15:09 <lambdabot> ap f (x +)
08:15:41 <shachaf> @protontorpedo!
08:15:41 <lambdabot> how deos haskell differ from ml or lisp?
08:15:50 <shachaf> @vixen how deos haskell differ from ml or lisp?
08:15:51 <lambdabot> Ooh, functional programmers are so hot!
08:15:52 <tromp_> @pl \x->x:ap f(x+)
08:15:52 <lambdabot> ap (:) (ap f . (+))
08:16:13 <pmetzger> I mean, given that there is already explicit syntax for declaring "this is an infix operator", why couldn't you say "this is an infix operator with precedence identical to/above/below this other operator" so you don't need 10 arbitrary levels...
08:16:15 <Jafet> @. vixen protontorpedo
08:16:16 <lambdabot> nevermind about that
08:16:20 <adamvh> heh http://i.imgur.com/8CGIL.jpg
08:16:33 <shachaf> Jafet: I can only imagine what he said to her. Poor thing.
08:16:57 <tromp_> @pl \f->ap(:)(ap f.(+))
08:16:57 <lambdabot> ap (:) . (. (+)) . ap
08:17:25 <tromp_> > ap(:).(.(+)).ap 0 1
08:17:26 <zygoloid> adamvh: your url has dodgy characters in it
08:17:26 <lambdabot>   No instance for (GHC.Show.Show (f (a1 -> [a1])))
08:17:26 <lambdabot>    arising from a use of `...
08:17:33 <adamvh> huh
08:17:40 <illissius> the other problem with haskell operators is that you tend to too quickly run out of sensible and non-barf-inducing names for them.
08:17:48 <adamvh> http://i.imgur.com/8CGIL.jpg
08:17:53 <copumpkin> > ap (,) (+1) 0
08:17:54 <lambdabot>   (0,1)
08:17:55 <adamvh> no idea what happened there
08:18:03 <pmetzger> that too. but I'm an old lisp head and have no trouble with prefix notation.
08:18:18 <tromp_> > let f x=x:ap f(x+)in f 0 1
08:18:18 <copumpkin> @let tee = ap (,)
08:18:19 <lambdabot>   Couldn't match expected type `[a1 -> a]'
08:18:19 <lambdabot>         against inferred type `a -...
08:18:20 <lambdabot>  Defined.
08:18:25 <adamvh> An illustration of @protontorpedo
08:18:37 <adamvh> @protontorpedo!
08:18:37 <lambdabot> why haskell over say clsip or smalltalk?
08:18:40 <pmetzger> I suppose that in a world of Unicode one could use arbitrary symbols as operators, but then entering them is a pain on normal keyboards.
08:18:46 <copumpkin> > tee (+1) . (*4) $ 5
08:18:48 <lambdabot>   (20,21)
08:18:52 <shachaf> @vixen why haskell over say clsip or smalltalk?
08:18:53 <lambdabot> Ooh, functional programmers are so hot!
08:19:01 <shachaf> Can't argue with that.
08:19:05 <c1de0x> lol
08:19:09 <RichardBarrell> It's summer here.
08:19:10 <KirinDave_> pmetzger: The Scalaz folks are big on that, and they argue your editor should be capable.
08:19:13 <RichardBarrell> I'm roasting in my skin.
08:19:34 <pmetzger> well, there is the \tex entry mode for emacs but I find it to be a pain...
08:19:40 <KirinDave_> shachaf: Paranthesis go in, selectors come out. You can't explain it.
08:19:42 <adamvh> pmetzger: APL returns!
08:19:42 <adnam> Jafet: ah, monomorphism restriction... so i want to guarantee multiple evalutations, but am i getting it right thinking the restriction prevents me from doing that?
08:19:45 <pmetzger> though that might just be that i'm old and inflexible...
08:20:01 <KirinDave_> pmetzger: Well no, they do things like if you type ,\ it gets converted.
08:20:18 <Saizan> adnam: if you add a type signature the MR doesn't apply to that binding
08:20:19 <KirinDave_> It's not a very hard sort of emacs mode to write.
08:20:27 <pmetzger> there is an emacs mode for that.
08:20:31 <pmetzger> the unicode tex entry method
08:20:40 <RichardBarrell> pmetzger: I leave a key bound to ucs-insert and then I try to memorise the interesting Unicode codepoint names.
08:20:40 <pmetzger> type \lambda and a lambda character gets entered
08:20:53 <KirinDave_> RichardBarrell: Why not macrotize it?
08:20:59 <pmetzger> or use the tex entry mode.
08:21:04 <tromp_> @hoogle ap
08:21:04 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
08:21:04 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
08:21:04 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
08:21:09 <RichardBarrell> KirinDave_: what do you mean by that?
08:21:13 <pmetzger> then you need not remember unicode codepoint names.
08:21:26 <KirinDave_> RichardBarrell: Make macros for your most used unicode characters
08:21:30 <Saizan> adnam: have you linked your code?
08:21:35 <RichardBarrell> C-- SNOWMAN C-M generates ☃ on my keyboard.
08:21:40 <behelit> haskells pattern matching seems pretty powerful. can you match binary patterns a la erlang as well? (ex <<Op:4, Len:4>> = BinData)
08:21:49 <copumpkin> behelit: no
08:21:56 <RichardBarrell> KirinDave_: because then I'd have a bunch of keybindings for SNOWMAN, BLACK HEART SUIT and so on. :)
08:22:00 <adamvh> pmetzger: what is this tex entry mode?
08:22:00 <pmetzger> but in tex entry mode you could just do \snowman or something
08:22:06 <adnam> Saizan: it's read' :: forall a . Read a => String -> a; read' = read
08:22:07 <copumpkin> behelit: you could conceivably think of doing it with a view pattern and a custom type though
08:22:08 <parcs> @hoogle c2w
08:22:08 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
08:22:09 <KirinDave_> RichardBarrell: Ha, that is probably not a great outcome. ;)
08:22:14 <c1de0x> copumpkin why not. taht would be awesome.
08:22:15 <kwantam> why don't we just plug our lisp machine keyboards back in?
08:22:15 <pmetzger> it is a mode where when you type \ followed by a string it turns it into a unicode char
08:22:16 <behelit> that's a bummer, one of my favorite applications of pattenr matching
08:22:16 <adamvh> pmetzger: sounds excellent
08:22:16 <Jafet> adnam: what do you want to be multiply-evaluated?
08:22:20 <kwantam> or APL keyboards, for that matter
08:22:22 <pmetzger> it is pretty good.
08:22:33 <Saizan> adnam: that should compile fine, what's the problem?
08:22:36 <copumpkin> c1de0x: it would be, but it just doesn't support it :)
08:22:45 <c1de0x> copumpkin go fix. kthx
08:22:52 <copumpkin> lol
08:22:55 <shachaf> @vixen go fix. kthx
08:22:55 <lambdabot> why me? :)
08:22:55 <behelit> copumpkin: and what would be the idiomatic haskell way?
08:23:00 <pmetzger> there isn't good documentation on it though.
08:23:11 <c1de0x> lol.
08:23:15 <pmetzger> one could use space cadet keyboards too, not that anyone has those any more.
08:23:16 <copumpkin> behelit: dunno :) guards maybe?
08:23:18 <adamvh> pmetzger: is, say, XeTeX smart enough to use a document that has the actual special characters in it?
08:23:21 <KirinDave_> Erlang's binary pattern matching is pretty damn badass.
08:23:23 <RichardBarrell> pmetzger: oh, that TeX input mode is -nice-. I may have to start using that.
08:23:25 <parcs> c2w is similar to ord when dealing with ascii characters right?
08:23:44 <tromp_> @pl \x->(x:).ap f(x+)
08:23:45 <lambdabot> liftM2 (.) (:) (ap f . (+))
08:23:48 <c1de0x> KirinDave_, help me convince copumpkin to extend haskell to support, kthx
08:23:51 <parcs> well, fromIntegral . ord …
08:23:51 <behelit> copumpkin: can you guard on bitlength?
08:24:00 <KirinDave_> copumpkin: It is awesome.
08:24:01 <copumpkin> behelit: you can guard on any expression
08:24:07 <copumpkin> oh I'm sure it is
08:24:14 <behelit> copumpkin: swell. that would make for a readable solution.
08:24:16 <copumpkin> but I'm not sure native support for bit-awareness belongs in the compiler
08:24:17 <KirinDave_> copumpkin: And guards are not really a good answer.
08:24:17 <pmetzger> ah, it is technically the "tex input method"
08:24:20 <c1de0x> copumpkin, so. you have your orders.
08:24:23 <c1de0x> get to it man!
08:24:24 <RichardBarrell> ∈
08:24:26 <copumpkin> lol
08:24:30 * shachaf prefers the lesser-known "text input method".
08:24:30 <adnam> Saizan, Jafet: bah, confusing myself now, sec
08:24:35 <shachaf> Used in standard editors such as ed.
08:24:38 <c1de0x> lol.
08:24:46 <copumpkin> maybe eventually
08:24:48 <KirinDave_> copumpkin: I'm not sure it's native weirdness?
08:24:54 <KirinDave_> I mean, don't put it on ints. :)
08:25:01 <RichardBarrell> I don't have a wide or tall enough keyboard for that to be feasible for all Unicode.
08:25:01 <RichardBarrell> Yes.
08:25:03 <RichardBarrell> *Yet.
08:25:12 <pmetzger> so to play with the tex input method if you're using emacs:
08:25:13 <c1de0x> copumpkin NAOw!!!AACAZSFGA
08:25:15 <copumpkin> well, it'd make the pattern matching code in teh compiler aware of the Bits typeclass
08:25:16 <c1de0x> ;)
08:25:18 <pmetzger> do m-x set-input-method
08:25:20 <pmetzger> type in TeX
08:25:21 * copumpkin kicks c1de0x 
08:25:23 <pmetzger> then try \lambda
08:25:30 <c1de0x> :D
08:25:31 <pmetzger> or whatever.
08:25:41 <pmetzger> the issue is, it is poorly documented and a bit cumbersome
08:26:00 <kwantam> just read the elisp, it's self documenting :P
08:26:01 <tromp_> @pl \f->liftM2(.)(:)(ap f.(+))
08:26:01 <lambdabot> liftM2 (.) (:) . (. (+)) . ap
08:26:02 <KirinDave_> copumpkin: Anecdote about Omlettes V. Eggs. Admonition not to ignore Erlang's venerable accomplishments. Elided joke to make us all feel good.
08:26:03 <c1de0x> ok. i'm bored. food now.
08:26:05 <RichardBarrell> Or bind a key to toggle-input-method.
08:26:14 * copumpkin slaps KirinDave_ 
08:26:27 <KirinDave_> copumpkin: Was going into stream mode. Ty.
08:26:39 <shachaf> @protontorpedo
08:26:39 <lambdabot> what is haskell?
08:26:41 <KirinDave_> copumpkin: Could you hear the tivo-fast-forward noise?
08:26:43 <shachaf> @vixen what is haskell?
08:26:43 <lambdabot> church is my favourite computer scientist.
08:26:56 <shachaf> Curry, not Church, silly thing.
08:26:57 <copumpkin> KirinDave_: yeah
08:27:01 <pmetzger> See also: http://en.wikipedia.org/wiki/Space-cadet_keyboard
08:27:10 <pmetzger> that keyboard let you type in a couple thousand symbols pretty easily
08:27:17 <pmetzger> but no one builds things like that any more.
08:27:19 <KirinDave_> That is a SERIOUS keyboard.
08:27:34 <kwantam> hyper super meta greek top ctrl shift
08:27:37 <kwantam> that is a lot of modifiers
08:27:49 <pmetzger> yup.
08:28:00 <pmetzger> but you could easily type a lambda or a beta or a forward arrow or whatever.
08:28:03 <kwantam> that's a Tom Knight special if I recall correctly
08:28:10 <pmetzger> yes, it is a Tom Knight design
08:28:35 <pmetzger> aka the "Space Cadet Keyboard", later the Symbolics keyboard.
08:28:49 <kwantam> here's another one to consider
08:28:52 <kwantam> http://www-lipn.univ-paris13.fr/~saiu/apl-keyboard/apl-keyboard-2.jpg
08:28:53 <c1de0x> "and objected to this design on the grounds that such a keyboard can require three or four hands[1] to operate." - wackypedia quote of the day
08:29:08 <pmetzger> but these days, everyone uses commodity hardware so it would be hard to use that sort of thing, because who's laptop has a replaceable keyboard?
08:29:09 <behelit> how do you wrap long lists? http://dpaste.com/534391/ <- i tried but get indentation error when compiling
08:29:27 <KirinDave_> behelit: Damn that is some CODE right there. :)
08:29:32 <Twey> « Other users, however, thought that so many bucky bits was overkill, and objected to this design on the grounds that such a keyboard can require three or four hands[1] to operate. » — hahaha
08:29:41 <shachaf> behelit: Are you sure that's not the extra comma?
08:30:07 <behelit> shachaf: good catch, it's not though (just tried)
08:30:28 <behelit> KirinDave_: yeah.. trying to learn :P
08:30:40 <pmetzger> so for now something like the TeX input method in emacs is the only reasonable solution, except it is a pain too.
08:30:43 <c1de0x> behelit i don't know what you're doing, but you're doing it wrong.
08:30:44 <c1de0x> ;)
08:30:46 <shachaf> Try not wrapping it first to find the errors.
08:30:57 <shachaf> And take c1de0x's advice here.
08:31:07 <pmetzger> you can also use the C-x 8 thing in a mode where you type in the unicode char name, complete with tab completion, but that is even more cumbersome than the TeX input method
08:31:14 <c1de0x> zomg. first time anyone's ever said taht.
08:31:21 <behelit> c1de0x: haha. i'm trying to do something like let [a, b, c] = [1, 2, 3] .. ie unpack an array into variables
08:31:27 <shachaf> @vixen Should I listen to c1de0x?
08:31:27 <lambdabot> let me answer that later, okay?
08:31:46 <c1de0x> behelit yah. definitely wrong.
08:31:46 <shachaf> behelit: First, that's not an array.
08:31:53 <c1de0x> its a list!
08:31:55 <behelit> list? :)
08:31:56 <c1de0x> +1 ?
08:32:05 <c1de0x> also, why?
08:32:11 <shachaf> behelit: Second, if you have that many, something is definitely wrong.
08:32:20 <shachaf> Why what?
08:32:21 <behelit> shachaf: it's from a text file.
08:32:29 <c1de0x> shachaf just a general why.
08:32:29 <adnam> Saizan, Jafet, so the problem would arise if i did something like (\g a b -> (g a, g b)) read' x y. since I only have one reference to read'
08:32:31 <zygoloid> > let [a, b, c] = [1, 2, 3] in a + b + c
08:32:32 <kwantam> shouldn't that be (n:_:kj:kc:p:f:c:asdf) = foo
08:32:32 <lambdabot>   6
08:32:33 <c1de0x> also, why unpack to vars?
08:32:38 <shachaf> behelit: Even so. Find another way to describe that pattern.
08:33:09 <c1de0x> what shachaf said.
08:33:14 <kwantam> also, can't you just match all of those last "_" to one variable?
08:33:14 <pmetzger> a:b:c:...
08:33:15 <shachaf> c1de0x: You and your llamas.
08:33:24 <c1de0x> i have no llamas.
08:33:24 <kwantam> as in
08:33:25 <kwantam> _
08:33:25 <Saizan> adnam: ah, sure, lambda bound variables have monomorphic types by default
08:33:29 <behelit> c1de0x: do make it easier to read. i'd eventually put a name on every value.
08:33:30 <c1de0x> i promise!
08:33:48 <c1de0x> behelit there is no way that will ever be 'easier to read'
08:34:13 <shachaf> Also, it's fragile, because it'll crash if the regexp doesn't match exactly.
08:34:18 <c1de0x> yup.
08:34:25 <Saizan> > (\(g : forall a. Read a => String -> a) -> (g "()", g "1") read :: ((),Int) -- adnam 
08:34:25 <lambdabot>   <no location info>: parse error on input `=>'
08:34:28 <c1de0x> in this case though, the regexp is just ';'
08:34:32 <c1de0x> which is totally fail.
08:34:36 <behelit> shachaf: have anything to point me in the right direction? other options would be to zip with a list containing the names of the values .. or just extract the values i need and add the names of the values in their position as a comment
08:34:37 <Saizan> > (\(g :: forall a. Read a => String -> a) -> (g "()", g "1") read :: ((),Int) -- adnam 
08:34:38 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:34:53 <Saizan> > (\(g :: forall a. Read a => String -> a) -> (g "()", g "1")) read :: ((),Int) 
08:34:54 <lambdabot>   ((),1)
08:35:00 <Saizan> adnam: there ^^^
08:35:08 <adnam> :-) thanks
08:35:13 <kwantam> is the final regex really ";" ?
08:35:24 <adnam> oooh now i see where i messed up
08:35:29 <behelit> kwantam: it's a string with values separated by semicolons
08:35:44 <kwantam> point is, why use a regex to split it
08:35:55 <c1de0x> yeah. that seems a bit borked.
08:35:57 <kwantam> you have to compile the thing and traverse the string at least once
08:36:01 <behelit> kwantam: couldn't find anything else without installing a package
08:36:02 <pmetzger> oooh, they fixed the docs partially. if you do m-x describe-input-method on the TeX input method it now documents it
08:36:02 <kwantam> so just traverse the string
08:36:08 <pmetzger> though one would really like a printed table...
08:36:33 <c1de0x> isn't there a find which gives you everything before a certain character?
08:36:35 <c1de0x> or value?
08:36:42 <c1de0x> i seem to remember that there is.
08:36:54 <c1de0x> you could just call that a bunch of times to extract the fields you need.
08:37:00 <kwantam> this whole thing is doable in a pair of folds
08:37:07 <kwantam> I suppose that's true of... a lot of things
08:37:13 <c1de0x> lol.
08:37:15 <pmetzger> (well, a printed table grouped by type of character. knowning \foo gives you something isn't that useful if you can't remember what you wanted to type to get a particular char.)
08:37:20 <KirinDave_> behelit: Maybe you want to do something where you apply !! many times?
08:37:31 <behelit> KirinDave_: i'll read up on !!, sec
08:37:35 <KirinDave_> behelit: That way you could talk about your pattern in terms of the list's indicies before you pattern match
08:37:46 <shachaf> Wait, no, (!!) is evil!
08:37:52 <KirinDave_> behelit: So you could extract the terms, then name them.
08:37:53 <c1de0x> maybe we should ask behelit  what he actually wants to do. as opposed to what he's trying to write
08:37:57 * shachaf was away for a bit, but that can't be good.
08:38:05 <KirinDave_> schlicht: More evil than that epic pattern?
08:38:09 <KirinDave_> doh
08:38:21 <KirinDave_> shachaf: More evil than that epic pattern?
08:38:30 <behelit> c1de0x: i have a csv-file. i extract a line and want to print some of the values to the console.
08:38:31 <kwantam> behelit, is it true that you are trying to split a string at ";" and separate the various components into a list?
08:38:40 <behelit> kwantam: aye
08:38:54 <c1de0x> well. csv is usually separated by commas not semi-colons
08:38:57 <shachaf> Your commas are a bit smudged.
08:39:02 <kwantam> implementation zero: iterate over list, creating list of lists
08:39:06 <c1de0x> hehe.
08:39:13 <shachaf> @protontorpedo
08:39:13 <kwantam> non-idiomatic, but will get the job done in one pass
08:39:13 <lambdabot> so how do you use haskell tools to build large programs?
08:39:23 <shachaf> @vixen so how do you use haskell tools to build large programs?
08:39:23 <lambdabot> church is my favourite computer scientist.
08:39:26 <kwantam> then figure out how to turn it into a mind-bending fold
08:39:27 <shachaf> Bah.
08:39:31 <behelit> c1de0x: well, sometimes semicolons, sometimes tabs.. depends on whether there need be commans in the values or not :)
08:39:33 <kwantam> and come back here and show it off :)
08:39:40 <KirinDave_> behelit: I just feel like, if you've got a list of lines where a line is pre-split
08:39:48 <KirinDave_> behelit: And you wanted to pull the csv fields
08:39:49 <c1de0x> behelit: no. CSV is always commas.
08:39:54 <c1de0x> it's in the name, duh.
08:39:55 <c1de0x> ;
08:39:55 <c1de0x> )
08:40:11 <KirinDave_> behelit: Something like flip (!!) <$> [.. indicies you care about ..] <*> lines 
08:40:25 <KirinDave_> behelit: Might be a good way to warm it up. As pointed out though, it requires an exception guard.
08:40:25 <shachaf> What you have is SSV. S stands for either "semicolon" or "supercomma".
08:40:43 <c1de0x> supercoma? really.
08:40:49 <c1de0x> this conversation is putting me into a supercoma
08:41:12 * shachaf hasn't slept for ~20 hours.
08:41:21 <c1de0x> shame. poor boy
08:41:27 <KirinDave_> shachaf: You, the one the sandmand is hunting, respond!
08:41:45 <shachaf> @yarr!
08:41:45 <lambdabot> Yarrr!
08:42:15 <shachaf> @Yarrr!
08:42:15 <lambdabot> Unknown command, try @list
08:42:19 <c1de0x> @list
08:42:19 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:42:26 <HugoDaniel> how can i abort my function from executing after a certain time threshold has been reached ?
08:42:34 <parcs> is there any way to generalize an instance declaration to N-tuples?
08:42:41 <c1de0x> @dice
08:42:41 <lambdabot> unexpected end of input: expecting number
08:42:47 <c1de0x> @dice 20
08:42:47 <lambdabot> 20 => 20
08:42:50 <c1de0x> @dice 20
08:42:50 <lambdabot> 20 => 20
08:42:55 <c1de0x> @dice 21
08:42:56 <lambdabot> 21 => 21
08:42:59 <c1de0x> i don't get it.
08:43:04 <c1de0x> @help dice
08:43:05 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
08:43:05 <alpounet> @help dice
08:43:05 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
08:43:10 <shachaf> @dice 1d5
08:43:11 <lambdabot> 1d5 => 4
08:43:21 <shachaf> @dice 1d3
08:43:22 <lambdabot> 1d3 => 3
08:43:22 <c1de0x> @dice 1d20+4
08:43:22 <lambdabot> 1d20+4 => 15
08:43:25 <shachaf> The famous d3.
08:43:31 <behelit> KirinDave_: ok, i'll try to digest that. is there no "easy" way to just split a string and get the values? :)
08:43:34 <c1de0x> ok. so i failed my inteligence check ;)
08:43:48 <KirinDave_> behelit: Haha like I am a haskell programmer.
08:44:01 <alpounet> behelit, there are tons of them
08:44:07 <alpounet> there's the 'split' package for example
08:44:21 <behelit> alpounet: is it part of the standard library?
08:44:26 <kwantam> behelit, there is
08:44:26 <shachaf> @hackage split
08:44:26 <alpounet> nope
08:44:26 <lambdabot> http://hackage.haskell.org/package/split
08:44:30 <KirinDave_> behelit: Just saying that since you're dealing with a huge volume of fields in a single list, it's probably more economical to talk about the index you want from the list rather than the entire list as a pattern
08:44:30 <kwantam> look in data.list
08:45:13 <behelit> KirinDave_: i can live with that
08:45:32 <shachaf> There's unfoldr.
08:45:38 <KirinDave_> The only problem with that bullshit applicative I put is that it flattens your lines. You'd have to repartition them.
08:45:42 <shachaf> @ty unfoldr -- Haskell is Web 2.0 nowadays.
08:45:43 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:45:56 <KirinDave_> But, you know, I am not a haskell programmer so...
08:46:48 * shachaf imagines KirinDave_ writing the nuclear missile controller in Haskell. "Well, sure, they accidentally launched, but I'm not a Haskell programmer, so, you know..."
08:47:16 <shachaf> Shouldn't have used unsafeLaunchMissiles.
08:47:21 <KirinDave_> shachaf: When I'm on company time writing said missile controller, I will express more confidence in the product I produce. Promise. ;)
08:47:43 <KirinDave_> shachaf: Ironically, I've helped to write that kind of software. We did it in C++. So fear for your life.
08:47:52 <c1de0x> heh. missile controllers are fun to reverse.
08:48:00 <KirinDave_> It was about commercial satellite launches, not missiles.
08:48:19 <c1de0x> satellite code is fun to reverse. too.
08:48:24 <KirinDave_> Bah
08:48:27 <KirinDave_> Outdated hardware
08:48:34 <c1de0x> yeah. but creative code.
08:48:48 <KirinDave_> I dunno. I want to write a compiler and go home.
08:48:49 <c1de0x> 'extra-terrestrial thinking' ;)
08:48:54 <KirinDave_> Oooh.
08:48:55 <KirinDave_> Well said.
08:48:58 <c1de0x> lol
08:49:10 <c1de0x> yeah. well, i want to write a decompiler, and i'm already at home.
08:49:12 <c1de0x> so there.
08:49:17 <KirinDave_> dang
08:49:26 <shachaf> KirinDave_: Hmm you're in San Francisco. Did you go to the bahaskell meeting yesterday?
08:49:39 <KirinDave_> shachaf: No. I have this thing called a crazy fucking startup job.
08:49:44 <KirinDave_> shachaf: And we're in mid push
08:49:55 <c1de0x> i'm on vacation. and i'm bored.
08:49:57 <KirinDave_> so I'm sorta either working, fucking around on irc waiting for my brain to re-crystalize, or sleeping.
08:50:11 <KirinDave_> Actually, let me apply a correction
08:50:15 <KirinDave_> In a moment I am going to be running my dog.
08:50:25 <c1de0x> how do you run your dog?
08:50:30 <KirinDave_> I own a greyhound.
08:50:31 <shachaf> unsafePerformIO
08:50:33 <c1de0x> mine is overclocked.
08:50:40 <KirinDave_> The only way you walk a greyhound is to run him a bit.
08:50:40 <kwantam> runQ dog
08:50:40 <c1de0x> shachaf eeew
08:50:45 <KirinDave_> 3m of work, 20 hours of sleep
08:50:59 <KirinDave_> "A rad life: retrospective of a retired greyhound."
08:51:26 * c1de0x <- Cougar Town
08:51:35 <pmetzger> I just want to be done writing a compiler. :(
08:51:55 <c1de0x> pmetzger what are you compiling?
08:52:29 <pmetzger> language I'm buildinig for a systems project. current theory is haskell based front end, llvm back end.
08:52:36 <pmetzger> seemed like the fastest path to a prototype
08:52:44 <c1de0x> heh.
08:52:50 <c1de0x> i've done some llvm work.
08:52:55 <c1de0x> front, back, middle
08:52:57 <c1de0x> all the ends.
08:53:06 <c1de0x> but i mostly break shit.
08:53:10 <c1de0x> building is for weenies ;)
08:53:18 <pmetzger> sadly most of my shit is already broken.
08:53:24 <pmetzger> or I'd ask for help with that.
08:53:49 <zygoloid> c1de0x: turns out there's lots of us llvm hackers here in #haskell :)
08:54:01 <c1de0x> heh.
08:54:03 <c1de0x> holy shit.
08:54:12 <c1de0x> i think i just blew out the speakers in my mbp.
08:54:38 <c1de0x> nm. vlc fail.
08:55:23 * hackagebot ihttp 0.2.2 - Incremental HTTP iteratee  http://hackage.haskell.org/package/ihttp-0.2.2 (ErtugrulSoeylemez)
08:55:32 <pmetzger> I'm still not completely comfortable hacking in haskell but it seems a lot better for hacking on a compiler than the alternatives available.
08:55:44 <c1de0x> makes sense.
08:55:58 <c1de0x> that's why we're writing our disassembler/decompiler in haskell.
08:56:06 <c1de0x> if we ever get our act together and actually do it.
08:56:13 <pmetzger> decompiler for what language?
08:56:15 <shachaf> c1de0x: For iPhones?
08:56:26 <c1de0x> pmetzger language? i don't understand.
08:56:28 <c1de0x> for binary.
08:56:44 <kwantam> for what processor?
08:56:50 <pmetzger> yes, but you generate what? C? if it is a decompiler, there is presumably an original source language you're trying to resurrect.
08:57:01 <c1de0x> shachaf well. we plan to build a 'universal' interactive disassembler
08:57:02 <pmetzger> decompilers traditionally are reverse engineering tools.
08:57:04 <RichardBarrell> Decompiling to what language? Only to opcodes, or something higher level?
08:57:13 <pmetzger> to opcodes is a disassembler.
08:57:20 <pmetzger> that's a perfectly solvable problem.
08:57:21 <c1de0x> first, and then build it up to a decompiler.
08:57:36 <c1de0x> decompilation can only ever really be to a psuedocode form.
08:57:46 <kwantam> I wrote a disassembler for z80 modem firmware once. You know what a bitch it is to disassemble variable-length instructions when you don't know all the execution entry points?
08:58:01 <pmetzger> well, not really, people have built full on functioning decompilers for a few languages
08:58:07 <pmetzger> the resulting code is not the original of course.
08:58:11 <pmetzger> and is often quite unreadable.
08:58:15 <c1de0x> pmetzger what langauges?
08:58:24 <kwantam> C presumably
08:58:31 <pmetzger> there are a couple that were done for Java, at least a few for C though they're not public.
08:58:37 <pmetzger> people tend to use them as in-house tools.
08:58:41 <c1de0x> java is not the same at all.
08:58:51 <kwantam> http://savannah.nongnu.org/projects/uncc/
08:58:54 <pmetzger> that may have changed though, there may be a public one of rC or two.
08:59:01 <pmetzger> er, for C...
08:59:04 <c1de0x> real compilation (to machine specific binary) is extremely lossy
08:59:08 <c1de0x> java
08:59:19 <c1de0x> 's bytecode is very close to the original source.
08:59:42 <pmetzger> compilation from C to object is indeed very lossy, but you can produce an equivalent source file, just not the ORIGINAL source file.
08:59:54 <c1de0x> pmetzger it's far from trivial.
08:59:56 <pmetzger> which is admittedly a feature that makes it less useful.
09:00:02 <pmetzger> oh, ery far from trivial.
09:00:03 <c1de0x> especially if you are 'targetting' multiple machines.
09:00:10 <pmetzger> decompilation is very hard. but it is possible.
09:00:30 <pmetzger> at least if the original source didn't throw in lots of asm statements.
09:00:30 <zygoloid> pmetzger: it depends what you mean by 'equivalent', really :)
09:00:31 <c1de0x> pmetzger, actually, i'm not at all certain that that has been proven.
09:00:40 <pmetzger> well, given that they exist... :)
09:00:48 <pmetzger> zygoloid: that's true.
09:00:49 <kwantam> it also depends strongly on what compilation techniques were used in the first place
09:01:00 <c1de0x> in fact, i'm fairly true that 'perfect decompilation' is not computationally possible.
09:01:07 <pmetzger> what is "perfect"?
09:01:12 <zygoloid> it is trivial to decompile machine code to functionally equivalent source code. just produce an interpreter and the original machine code.
09:01:19 <pmetzger> producing a source file that will generate a new object that behaves the same way, sure.
09:01:34 <zygoloid> it is not computable to decompile machine code to source code which a given compiler would turn into the same machine code, in the general case
09:01:39 <pmetzger> producing one that is actually useful to the reverse engineer I will admit is not tractable.
09:01:45 <adamvh> @src iterate
09:01:45 <lambdabot> iterate f x =  x : iterate f (f x)
09:01:46 <pmetzger> or rather, one that is ALWAYS useful...
09:01:46 <c1de0x> pmetzger 'perfect' is output code which is as easy to read as the original source.
09:01:57 <kwantam> that's quite a goal
09:02:05 <pmetzger> that is certainly not possible in the general case.
09:02:06 <c1de0x> kwantam yup ;)
09:02:13 <c1de0x> pmetzger double yup.
09:02:14 <pmetzger> but it isn't always absolutely necessary.
09:02:14 <kwantam> even "perfect" === compile(decompile(obj)) == obj is tough
09:02:28 <pmetzger> oh, that is never necessary to the reverse engineer.
09:02:40 <pmetzger> so long as the new obj is more or less functionally equivalent it is good enough.
09:02:44 <zygoloid> kwantam: depending on the compiler, that's often not even computable :)
09:02:49 <c1de0x> pmetzger being a professional reverse engineer, i beg to differ.
09:02:51 <kwantam> zygoloid, precisely
09:03:04 <zygoloid> 'tough' seems like an understatement :)
09:03:06 <c1de0x> kwantam yup. like i said. not easy ;)
09:03:26 <pmetzger> what's the issue there? I can see why the lack of readability is a big problem, but why would you need to re-generate exactly the original object?
09:03:28 <zygoloid> c1de0x: you're a professional reverse engineer? cool, where do you work?
09:03:32 <adamvh> There are pretty good decompilers for .net
09:03:38 * monochrom silently ponders on the semantics of bringing together the subjective "easy to read" and the mathematical "computationally possible"
09:03:51 <c1de0x> all that being said, with intimate knowledge of compiler internals and many many years of manual reversing experience, you can build a system of heuristics which is 'good enough' in most cases.
09:03:57 <kwantam> pmetzger, I was only speculating about a goal for "perfect decompilation" that could be stated objectively
09:04:02 <c1de0x> adamvh see ^^ comments about java.
09:04:02 <kwantam> because "beautiful code" is pretty subjective
09:04:08 <c1de0x> .net bytecode is a high-level language.
09:04:10 <pmetzger> kwantam: agreed.
09:04:29 <pmetzger> well, you could state it objectively, as "re-generate the original source file" :)
09:04:32 <c1de0x> zygoloid yeah. i'm a pro. and no.
09:04:33 <pmetzger> but that's clearly not possible.
09:04:34 <kwantam> c1de0x, do you have the advantage in your case of knowing what the compiler is that produced the object of your affections?
09:04:41 <c1de0x> kwantam nope.
09:04:57 <kwantam> though you could presumably put in some heuristics to detect such a thing
09:05:08 <c1de0x> in most cases, reversers like us just get some binary blobs. in the best case, it's an object file (ELF, PE, MACHO, ...)
09:05:10 <adamvh> pmetzger: sans comments of course
09:05:12 * shachaf just had an idea for a monad tutorial.
09:05:15 <shachaf> Must resist...
09:05:16 <c1de0x> in the less best case, it's really fail.
09:05:33 <c1de0x> kwantam detecting specific compilers is almost impossible.
09:05:36 <pmetzger> adamvh: if you can regenerate the original comments you've really got it made. :)
09:05:39 <kwantam> not if you get an ELF blob
09:06:01 <c1de0x> pmetzger yeah. that's the ultimate goal ;)
09:06:04 <anincog> I'm using mutable vectors (as in Data.Vector.Mutable) for the first time, and I started experiencing some type errors I didn't understand. Shouldn't the following work just fine? It's from the manual, after all: create (do { v <- new 2; write v 0 'a'; write v 1 'b' })
09:06:06 <c1de0x> quantum reversing.
09:06:08 <c1de0x> ;)
09:06:28 <anincog> shouldn't that simply create a Data.Vector.Vector Char of length 2, having values 'a' and 'b'?
09:06:28 <pmetzger> c1de0x: well, the laws of physics are time reversable....
09:06:40 <c1de0x> pmetzger yup yup.
09:06:51 <companion_cube> shachaf, "monads are like cheeseburgers" ? "monads are fried chicken" ? "monads are bacon and ham" ?
09:06:53 <kwantam> c1de0x, it seems to me that quantum reversing would involve producing an entanglement that would result in your hard drive containing the original source code
09:07:04 <c1de0x> kwantam you got it in one.
09:07:11 <kwantam> pmetzger,  other than entropy
09:07:11 <c1de0x> are you looking for work ? ;P
09:07:18 <pmetzger> anyway, as I understood it, there were two goals that people had for decompilation: 1) reading the code, 2) sometimes changing the code a wee bit and producing a new object.
09:07:21 <anincog> ghci tells me that the argument to create has type ST s (), but I don't see why
09:07:27 <pmetzger> neither would seem to require regenerating the original object precisely.
09:07:31 <pmetzger> what does require that?
09:07:31 <c1de0x> pmetzger 1 is my only goal.
09:07:36 <c1de0x> i don't care about 2.
09:07:40 <shachaf> companion_cube: Well, it would be more "monads are like Cont".
09:07:41 <kwantam> c1de0x, if I had that technology I might try for teleportation or stock market cheating before decompiling, myself
09:07:49 <pmetzger> you seemed to indicate that regenerating the original object was sometimes a goal.
09:07:58 <c1de0x> kwantam damn you kapitalizts
09:08:19 <companion_cube> aren't you taking something harder than monads to explain them ? :D
09:08:20 <kwantam> financial decompilation: make money, buy original source code
09:08:26 <c1de0x> pmetzger no. my goal is to have decompiled code which is orders of magnitude easier to read than the disassembly.
09:08:53 <c1de0x> especially for things like compiled c++
09:08:59 <kwantam> if your disassembler were good enough, you might try fixing uber spaghetti code by compiling it and then decompiling it
09:09:02 <c1de0x> (and other object oriented languages)
09:09:05 <pmetzger> so for that you don't need compile(decompile(obj)) == obj
09:09:11 <adamvh> kwantam: entropy is an emergent phenomenon, not a law of physics
09:09:16 <c1de0x> pmetzger i never said i did.
09:09:22 <pmetzger> I misunderstood then.
09:09:28 <c1de0x> pmetzger.
09:09:31 <c1de0x> possible.
09:09:36 <kwantam> adamvh: thermodynamics diasgrees
09:09:37 <pmetzger> I got the impression you were implying that, but clearly I was not reading you right.
09:09:55 <c1de0x> no. i just want extremely readable code.
09:10:03 <c1de0x> but we're very very far from all that.
09:10:06 <pmetzger> so anyway, producing some sort of equivalent code is clearly possible. readable I will violently agree is fucking difficult.
09:10:18 <c1de0x> at the moment we're still working on the initial disassembler.
09:10:34 <pmetzger> disassembly of x86 is especially fun. for some value of fun. :(
09:10:43 <pmetzger> but can't gnu objdump help?
09:10:45 <kwantam> uggggh
09:10:56 <kwantam> disassembling x86
09:10:58 <c1de0x> pmetzger seeing as readability is the ultimate (primary!) goal, fucking difficult is right.
09:10:59 <kwantam> horrific
09:11:00 <azaq23> entropy exists because all other physical laws work together so that is does exist, so it is an emergent phenomen, not?
09:11:11 <c1de0x> no, we're doing all disassembly 'in house'
09:11:14 <pmetzger> entropy is sort of an emergent phenomenon, yes.
09:11:17 <c1de0x> and we're disassembling to a microcode
09:11:20 <zygoloid> c1de0x: i've been working on a very similar project. i have an llvm-based disassembler and basic procedure searching, but not much more
09:11:31 <adamvh> kwantam: thermodynamics is also an emergent phenomenon
09:11:42 <c1de0x> which we can then transform using optimizations to reduce the code before attempting decompilation.
09:11:44 <kwantam> adamvh: from that point of view, physics is an emergent phenomenon
09:11:44 <pmetzger> thermodynamics is cool.
09:11:54 <c1de0x> zygoloid yeah? that's nifty.
09:11:56 <pmetzger> no, there are certain base laws.
09:11:57 <monochrom> thermodynamics is hot
09:12:00 <pmetzger> (of physics.)
09:12:00 <kwantam> but by such a definition, if entropy is not "in" physics, it is at least equivalently emergent
09:12:09 <c1de0x> initially we thought of building on top of llvm.
09:12:23 <adamvh> kwantam: No, entropy is derived from an ensemble of particles following the laws of physics
09:12:26 <c1de0x> but in the end we decided to build our own IL.
09:12:35 <pmetzger> adamvh: I'd buy that statement.
09:12:48 <kwantam> adamvh: and one of those laws _specifically_ regards entropy
09:12:51 <zygoloid> the disassembler isn't quite up to it; it's missing quite a few opcodes. (in any case it doesn't currently have accurate insn semantics)
09:13:01 <kwantam> "2nd law of thermodynamics" is in the set "the laws of physics"
09:13:11 <c1de0x> yeah. i wrote a mips decoder in about half a day, @zygoloid 
09:13:20 <adamvh> kwantam: No, it doesn't - an ensemble of classical particles in a box will exhibit thermodynamic properties
09:13:23 <pmetzger> at the bottom, we don't know. an approximation to that for purposes of dealing with normal everyday matter and photons is QED. you won't find 
09:13:23 <c1de0x> and i think we have an arm one as well.
09:13:33 <pmetzger> er you won't find "entropy" in that description.
09:13:36 <anincog> Hmm, when I think about it, I don't at all understand how the example for the "create" function in Data.Vector works (http://hackage.haskell.org/packages/archive/vector/0.6.0.1/doc/html/Data-Vector.html). Isn't the type of the argument passed to create in the example simply ST ()? Could someone enlighten me?
09:13:38 <adamvh> kwantam: conservation of energy and momentum are axioms
09:13:47 <c1de0x> we definitely have 8051
09:13:49 <kwantam> adamvh: thermal energy is axiomatic
09:14:09 <c1de0x> but the project stalled due to an unprecedented 0verflow of fail.
09:14:09 <adamvh> kwantam: No, it's not.  Thermal energy is the average kinetic energy of an ensemble of particles
09:14:16 <pmetzger> thermal energy isn't "axiomatic".
09:14:22 <pmetzger> I'm with adamvh on this.
09:14:37 <pmetzger> you can't distinguish, at the particle level, thermal energy from kinetic energy from whatever.
09:14:47 <pmetzger> you only call it thermal energy when you look at a big ensemble.
09:15:07 <c1de0x> there is no such thing as thermal energy.
09:15:08 <kwantam> no, my point is, the behavior that results is a fundamental part of the behavior
09:15:16 <c1de0x> there is energy which has thermal effects
09:15:16 <pmetzger> heck, you can't distinguish a phonon transporting "heat" from one transporting "sound" unless you look at a very big ensemble
09:15:50 <kwantam> if you are using "classical particles in a box" you cannot simply leave it out and get the expected behavior
09:16:01 <c1de0x> zygoloid if you wanna hax on it, we'll eventually open it up to the public. once we get a base working system.
09:16:01 <pmetzger> there are no classical particles.
09:16:04 <pmetzger> not in our universe.
09:16:06 <kwantam> I agree
09:16:09 <c1de0x> pm me if you ever wanna play.
09:16:42 <kwantam> and yet adamvh's claim was that such particles would exhibit thermodynamic properties, which is specious unless you actually throw in other aspects of thermodynamics
09:16:51 <shachaf> c1de0x: What is this disassembler for?
09:16:54 <adamvh> kwantam: If you know the initial conditions of every single particle in a system, and calculate its time evolution, without reference to the "laws of thermodynamics", it will follow the laws of thermodynamics on average.
09:17:03 <c1de0x> shachaf what is a hammer for?
09:17:04 <pmetzger> adamvh has it again.
09:17:12 <c1de0x> shachaf to disassemble things.
09:17:21 <jmcarthur> anincog: yeah that example looks suspect to me, too
09:17:25 <c1de0x> so that we can grok the code, and break the systems.
09:17:28 <pmetzger> thermo comes in when you want to discuss statistical ensembles without respect to the conditions of the individual particles.
09:17:28 <c1de0x> ;)
09:17:33 <shachaf> c1de0x: Which code?
09:17:38 <shachaf> Apple's?
09:17:42 <c1de0x> shachaf oh. lots of stuff.
09:17:43 <pmetzger> which is most of the time. but at the lowest level, you look at the rules, you don't see thermo
09:17:44 <jmcarthur> anincog: i think it needs a return v at the end
09:17:46 <anincog> jmcarthur: Could to hear it's not just me then :)
09:17:51 <anincog> jmcarthur: Ah, right, of course
09:17:54 <c1de0x> i work on stuff professionally and for fun.
09:17:54 <kwantam> adamvh, I do not dispute that claim
09:18:09 <c1de0x> some of our 'antics' are public knowledge.
09:18:10 <anincog> jmcarthur: should I email the Vector maintainer about it, you think?
09:18:12 <pmetzger> anyway, the reason this is important is this: no one undertands the arrow of time.
09:18:12 <c1de0x> others are not.
09:18:29 <pmetzger> the low level rules are time reversable, but in our universe it is an observed fact that entropy increases with time.
09:18:40 <kwantam> but entropy is just a statement of the tendency of such systems to probabilistically favor "random" rather than "ordered" states, with respect to the original state
09:18:42 <jmcarthur> anincog: first check to make sure we are right by testing it, but yes, i think the maintainer would want to know
09:18:42 <pmetzger> but there is no obvious reason this needs to be the case if you look at the rules at the bottom.
09:18:56 <c1de0x> pmetzger the amount of bullshit in this conversation certainly seems to be increasing with time ;)
09:19:05 <pmetzger> it has to. entropy goes up! :)
09:19:09 <c1de0x> lol
09:19:11 <kwantam> I don't see how you can call that property non-fundamental
09:19:23 <anincog> jmcarthur: Everything works as expected with return v at then end of the do block, and it makes perfect sense too :)
09:19:26 <c1de0x> shachaf and yes. some apple code ;)
09:19:38 <adamvh> kwantam: It's a fundamental property of statistics, and not of physics
09:19:48 <pmetzger> Again, I'm with Adam on that.
09:20:00 <kwantam> OK, if you insist on making such a distinction then I guess it's no skin off my hide
09:20:03 <azaq23> I don't know exactly where, but IIRC there are physical laws which are not time reversible, so they can only reasonable work in the direction of time as it is. I thing the schroedinger equation was involved.
09:20:13 <azaq23> nothing classical though
09:20:23 <pmetzger> there are no time-irreversable rules in the quantum world.
09:20:32 <pmetzger> that's a big mystery, but really, there are none.
09:20:35 <kwantam> therein lies the arrow of time dilemma
09:20:45 <adamvh> My statistical mechanics class discussed all of this at incredible length :p
09:20:56 <adamvh> back in the day
09:20:59 <pmetzger> all the fields known are conservative fields, all the interactions are perfectly time reversible at the microscale.
09:21:13 <kwantam> ditto. it's been a long time
09:21:23 <pmetzger> less long for me but long enough. :(
09:21:24 <chrishas> hi,is it possible to use filter with mod? like this filter (n `mod`) [2..n/2]?
09:21:25 <jmcarthur> what brought this discussion of physics up?
09:21:34 <kwantam> but it's really useful to fall back on stat mech for analyzing circuit noise
09:21:35 <adamvh> It was in the context of reverse engineering
09:21:49 <pmetzger> It was a really weird conversation starter really.
09:21:51 <crystal-cola> I think radioactive decay is dependent on time
09:21:59 <c1de0x> adamvh it was a very odd tangent.
09:22:05 <adamvh> indeed
09:22:06 <crystal-cola> but that's irrelevant to most physical phenomenon that we deal with
09:22:13 <monochrom> there is something funny with "therein lies the arrow of time dilemma ... it's been a long time"
09:22:15 <pmetzger> crystal-cola: every radioactive decay is time reversable in theory.
09:22:24 <crystal-cola> pmetzger: yikes, that's news to me
09:22:32 <crystal-cola> Why did Feynman say it was???
09:22:36 <parcs> chrishas: not solely. filter takes a function that returns a Bool; mod returns an Int
09:22:40 <pmetzger> yup.
09:22:48 <pmetzger> every beta decay could happen backwards, etc.
09:23:00 <crystal-cola> ah that makes sense
09:23:07 <parcs> you can do something like this, though: filter (\x -> n `mod` x == 0) [2..n/2]
09:23:13 <pmetzger> bbl.
09:23:14 <adamvh> pmetzger: you'd just need a neutrino, a nucleus, and a lepton in the right place at the right time
09:23:42 <adamvh> heh
09:23:43 <pmetzger> adamvh: and although that's low probability, you couldn't tell if the film was played backwards that it wasn't a valid interaction...
09:23:47 <pmetzger> bbl.
09:24:43 <adamvh> damn, euler 328 is kicking my ass
09:26:36 <azaq23> According to wiki, "Modern physics is not quite time-reversible; instead it exhibits a broader symmetry, CPT symmetry." http://en.wikipedia.org/wiki/Time_reversibility http://en.wikipedia.org/wiki/CPT_symmetry
09:27:03 <c1de0x> zomg azaq23  that's just some grade-A mental masturbation.
09:28:49 <crystal-cola> It's funny how the "fundamental notion of algorithm" Turing machine isn't reversible
09:28:58 <azaq23> c1de0x May I not announce that I discovered that a claim I made minutes before is wrong and why or what do you mean?
09:29:09 <crystal-cola> just shows how much we anthropomorphise everything
09:29:22 <c1de0x> azaq23 no. i meant all that CPT_symmetry stuff. not what you said ;_
09:30:57 <applicative> adamvh: wow youre doing things in the Euler 300s.  This one does look tough
09:31:28 <anincog> jmcarthur: I have another question regarding the same mutable vector example. The example (with return v at the end) works fine, but I don't understand why one of the two pieces of code here typechecks, while the other doesn't: http://hpaste.org/45914/confusion_regarding_the_st_mon
09:31:42 <anincog> jmcarthur: Would you mind taking a look?
09:33:42 <tromp_> what's hard about euler 328?
09:33:55 <adamvh> tromp_ efficiency
09:34:11 <crystal-cola> does the obvious dynamic program not work?
09:34:14 <adamvh> I've come up with a few different algorithms that work
09:34:20 <adamvh> crystal-cola: it's far too slow
09:34:32 <adamvh> The problem is that you can memoize the bottom half
09:34:32 <crystal-cola> oh well that's me giving up then
09:34:40 <adamvh> but not the top half
09:35:48 <adamvh> applicative: I did the first ten and then decided I would attempt them in descending order of difficulty until I got bored
09:36:00 <adamvh> heh
09:36:35 <applicative> adamvh: that sounds sensible.  I gave up after 20 or so, it was when I was first studying Haskell. Not too bad for adjusting to the syntax etc.
09:37:56 <applicative> crystal-cola: what is the 'obvious dynamic program', in outline?
09:38:03 <c_wraith> Yeah, the first few problems are ok for learning the very basics.  But beyond that it's a pretty bad way to learn a language, since it really focuses on math knowledge rather than programming skill.
09:38:28 <crystal-cola> applicative: you are supposed to sum a function from 1 to 100000 or something.. So just compute C(10000) in a way that also computes C(every number below that)
09:38:54 <c_wraith> applicative: if you ever get the answer "lower", you can apply the answer for n-1 then, meaning the dynamic programming structure is really obvious
09:39:18 <djahandarie> I'm terrible at Project Euler
09:40:23 <c_wraith> The trick is to figure out how you can apply dynamic programming if the answer is "higher", as well.
09:40:32 <c_wraith> If you can figure that out, it's trivial
09:40:51 <tromp_> the problem is how to avoid cubic time
09:40:57 <applicative> lower and higher are sort of dual, hm
09:41:45 <behelit> ok, so my program is "working". what fundemental concepts have i missed? :) http://dpaste.com/534416/
09:42:00 <tromp_> there's a cubic number of choices how the split [low,high] in 2
09:42:02 <alpounet> well, (<) = flip (>)
09:42:15 <tromp_> the->to
09:42:20 <behelit> (and i'll replace the splitRegex with split once i figure out how to install external packages and so)
09:42:36 <alpounet> behelit, with "cabal"
09:42:44 <alpounet> @where cabal
09:42:44 <lambdabot> http://www.haskell.org/cabal
09:42:45 <c_wraith> behelit: the lambda in line 11 can be replaced with a section
09:43:08 <behelit> c_wraith: ok, what are those? :)
09:43:23 <c_wraith> (\line -> needle `isPrefixOf` line) is the same as (needle `isPrefixOf`)
09:43:37 <behelit> alpounet: thanks. think i have that installed already :)
09:43:44 <applicative> behelit: surely you don't need "return ()"
09:43:46 <c_wraith> sections are syntax for partially applying either argument of a binary operator
09:43:55 <Twey> c_wraith: Is the same as ‘isPrefixOf needle’
09:44:01 <alpounet> behelit, then just do "cabal update && cabal install split"
09:44:03 <parcs> behelit: install hlint! :)
09:44:07 <applicative> behelit: handleResults is already IO ()
09:44:10 * Twey dislikes brackets.
09:44:22 <c_wraith> Twey: oh, hah.  yes, in that case.  I'm so used to the second argument
09:44:26 <adamvh> c_wraith: yeah, I was trying to think of Cost(m,n) in terms of Cost(n) but not really getting anywhere
09:44:30 <Twey> Heh
09:44:46 <applicative> hlint just says replace x !! 0 with head x, which is not sensible in behelit 's definition
09:44:54 <adamvh> the trouble is that if you shift all of the nodes by a constant factor, the tree might need rebalancing
09:45:20 <c_wraith> behelit: \x -> x + 1 is the same as (+ 1).  \x -> 3.8 / x is the same as (3.8 /)  Those are section syntax.
09:45:46 <behelit> c_wraith: i think i grok it. nice.
09:45:59 <Twey> > map (* 2) [1 .. 5]
09:46:00 <lambdabot>   [2,4,6,8,10]
09:46:03 <adamvh> I believe I have an O(n) way to from the optimal search strategy for n to the optimal search strategy for n + 1
09:46:20 <c_wraith> behelit: and syntactically, any function in backticks, to make it infix, is the same as an infix operator, so you can use it with section syntax
09:46:34 <Twey> > map ($ 5) [(2 *), (1 +), (`div` 3)]
09:46:34 <adamvh> Unfortunately, that still leaves me with O(200,000^2)
09:46:35 <lambdabot>   [10,6,1]
09:46:44 <stepkut> behelit: you can use a mapM, http://dpaste.com/534417/
09:46:49 <Twey> adamvh: Hey, it's just a constant factor
09:46:51 <c_wraith> behelit: and yes, applicative was right that the "return ()" on line 13 isn't necessary
09:46:52 <shachaf> adamvh: Fortunately O(200,000^2) = O(1). :-)
09:46:59 <Twey> Hehe
09:47:21 <KirinDave_> behelit: Did you find a better solution to your pattern matching problem?
09:47:43 <behelit> KirinDave_: I just used indices 
09:47:45 <behelit> :)
09:47:45 <c_wraith> 200,000^2 isn't too big to brute force.  It's less than 4 billion!
09:48:00 <KirinDave_> behelit: I am curious what the code ended up looking like?
09:48:06 <adamvh> c_wraith: it's running right now, heh
09:48:10 <behelit> KirinDave_: http://dpaste.com/534416/
09:48:18 <adamvh> At this point I just want access to the forum so I can see the actual solution
09:48:38 <KirinDave_> behelit: I thought you had more than 2 fields?
09:48:48 <behelit> well, http://dpaste.com/534420/ now
09:49:08 <c_wraith> behelit: this isn't an error at all, but I would avoid shadowing names from the prelude, meaning you probably shouldn't name the value on line 16 "tail"
09:49:14 <behelit> KirinDave_: I'll add more as I need them. Then, when I grok Haskell I'll do something pretty :)
09:49:27 <shachaf> c_wraith: Either that or make Haskell a LISP_2!
09:49:34 <tromp_> you can optimize 328 using the fact that the cost for e.g. [201,301] is the cost of [200,300] +  max # guesses for the latter
09:49:42 <behelit> c_wraith: ah, I'm mostly interested in idioms and best practices. So great catch.
09:50:15 <tromp_> so you compute cost + #guesses for each subrange
09:50:19 <behelit> KirinDave_: I figured that I should move on, try to learn the easy things first and then I'll revisit the problem.
09:50:26 <KirinDave_> behelit: Indeed.
09:50:31 <adamvh> tromp_: except the tree might need rebalancing
09:50:47 <zygoloid> behelit: some basic tidyups: http://dpaste.com/534422/
09:51:11 <KirinDave_> Ugh
09:51:22 <KirinDave_> You guys gotta get on the gist train
09:52:18 <behelit> zygoloid: what is the . after mapM_?
09:52:33 <adamvh> KirinDave_: the gist train?
09:52:37 <zygoloid> behelit: function composition
09:52:45 <KirinDave_> gist.github is just... really good.
09:52:56 <zygoloid> behelit: it's more idiomatic (but equivalent) to write  f . g $ x, rather than f $ g $ x
09:53:01 <behelit> zygoloid: so, it's sort of like $?
09:53:07 <KirinDave_> behelit: Sooorrttaaaa
09:53:19 <shachaf> In a concatenative language, yes! :-)
09:53:33 <zygoloid> well, f . g $ x is (f . g) $ x, whereas f $ g $ x is f $ (g $ x)
09:53:41 <behelit> haha, i thought i'd pick haskell up in an afternoon :)
09:53:49 <adamvh> f $ g however is a type error
09:53:58 <shachaf> Sometimes.
09:54:06 <adamvh> right I should have clarified
09:54:17 <KirinDave_> behelit: It's not so bad.
09:54:35 <adamvh> $ is really just an open parenthesis with an implied closing parenthesis at the end of the line
09:54:41 <KirinDave_> behelit: You get a feel for . and $ very quickly. $ is for pointing out arguments, . is for making chains of functions.
09:54:45 <applicative> behelit: here's my cretinous tidying http://hpaste.org/45917/regexy_annotation
09:55:17 <KirinDave_> applicative: So monadic! *gush*
09:55:31 <KirinDave_> Ha @ HLint
09:56:02 <applicative> KirinDave_: yes, main doesn't need monadism
09:56:40 <shachaf> HLint should warn "that's a mapM_".
09:58:07 <behelit> applicative: wow. ok, that answered some of the questions i sort of had (mainly why i could not call unwords on the args directly)
09:58:17 <behelit> applicative: or, raised new questions related to old questions really :)
09:58:37 <c1de0x> behelit getArgs is in the IO monad.
09:58:55 <c1de0x> so you need to fmap unwords
09:59:19 <KirinDave_> behelit: functors are easy to understand and super useful.
09:59:27 <PeakerWork> @type getArgs
09:59:28 <lambdabot> Not in scope: `getArgs'
09:59:36 <behelit> c1de0x: i see. so is the rule that you can apply a function to a monad if it's preceeded by fmap?
09:59:41 <PeakerWork> @type System.Environment.getArgs
09:59:42 <lambdabot> IO [String]
09:59:42 <jmcarthur> anincog: oh sorry i wasn't looking at irc. has your question been answered already?
09:59:46 <shachaf> @let getArgs = return ["blah", "blam"]
09:59:47 <lambdabot>  Defined.
09:59:53 <KirinDave_> @type fmap
09:59:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:59:55 <c1de0x> behelit oh man.
10:00:03 <adamvh> hmm ghci is not responding to keyboard interrupts
10:00:11 <shachaf> @quote monochrom IO.String
10:00:11 <lambdabot> monochrom says: How do I extract the IO out of IO String?
10:00:18 <shachaf> Why don't we ever get questions like that? :-(
10:00:24 <c1de0x> shachaf lol.
10:00:31 <PeakerWork> behelit: you can lift a function into the monad wrapper and apply it "inside"
10:00:45 <c1de0x> behelit have you tried reading LearnYouAHaskell?
10:00:45 <PeakerWork> behelit: "fmap" lifts functions into Functors (including Monads)
10:00:56 <KirinDave_> behelit: May I recommend you check out the learn-you-a-haskell segment on functors.
10:01:05 <KirinDave_> behelit: A lot of things are functors. 
10:01:06 <c1de0x> KirinDave_ first!
10:01:07 <c1de0x> ;)
10:01:12 <behelit> c1de0x: I figured I'd just start hacking away.. but I can see you have a point.
10:01:14 <KirinDave_> c1de0x: Oh yeah?
10:01:33 <behelit> c1de0x: it's good to have a little context before i start though (at the expense of your time; sorry)
10:01:36 <c1de0x> behelit yeah. some stuff is a little harder to grok without understanding the fundementals.
10:01:40 <KirinDave_> behelit: http://itunes.apple.com/us/app/cockpit/id404844653?mt=12
10:01:43 <c1de0x> behelit i'm not complaining.
10:01:44 <applicative> behelit: silly, more 'applicative' version for what it's worth, http://hpaste.org/45918/regexy_annotation_annotatio  <$> is fmap
10:01:53 <jmcarthur> anincog: i think you might need to give bar an explicit type signature. higher rank types lose some inference
10:02:23 <mm_freak> i'm not sure i understand the stuff about not generalizing let bindings in GHC 7
10:02:25 <c1de0x> KirinDave_ ?
10:02:37 <behelit> applicative: that is great. gives me a lot of context when looking up stuff like where and fmap
10:02:58 <c1de0x> behelit i really really recommend reading that tutorial before you go any further.
10:03:11 <behelit> c1de0x: i will. promise!
10:03:17 <mm_freak> does that mean that when i leave away local type signatures, i don't need ScopedTypeVariables anymore?
10:03:20 <KirinDave_> applicative: Originally he had more fields per line, so I offered flip (!!) <$> [...indicies...] <*> pure line
10:03:21 <adamvh> How smart is ghci about discarding temporaries?
10:03:24 <KirinDave_> err, pure bits
10:03:28 <mm_freak> (not as its main effect, but as a side effect)
10:03:40 <behelit> so are you guys using haskell in every day programming or just for fun and education? :)
10:03:43 <KirinDave_> applicative: I dunno if that is pure wankery tho.
10:03:56 <KirinDave_> behelit: I intend to use it at my job after this big push. 
10:04:02 <applicative> but fmap is simple enough here, behelit, the second argument is an IO thing that returns something of type A;  the first  is a function from those somethings to something else A -> B; it just lets you put them together, and return the associated B thing whatever it si
10:04:03 <KirinDave_> behelit: Scala kinda pisses me off sometimes.
10:04:26 <KirinDave_> behelit: And I got sorta shut out of clojure
10:04:29 <adamvh> behelit: fun and education, although playing with the idea of letting it into the "work" realm
10:04:38 <jmcarthur> behelit: i'm using haskell to make a game that i hope to make money from some day
10:04:41 <adamvh> KirinDave_: shut out?
10:04:44 <PeakerWork> Haskell may be a big language, but it still has a minimalistic feel IMO. Scala has a monsterous feel :-)
10:04:52 <PeakerWork> which makes it harder for me to check it out..
10:04:53 <KirinDave_> adamvh: It turns out I learned scala faster than everyone else learned clojure.
10:05:00 <KirinDave_> adamvh: So subsequent work will be in scala.
10:05:12 <c1de0x> well. i'm still a haskell noob.
10:05:19 <KirinDave_> PeakerWork: Scala's new collections are hawt, as will the new parallel stuff be. But it's... very broad and very deep
10:05:27 <adamvh> KirinDave_: except you intend to replace Scala with Haskell?
10:05:33 <KirinDave_> adamvh: In some contexts.
10:05:35 <KirinDave_> Not all
10:05:35 <adamvh> KirinDave_: or just supplement
10:05:39 <adamvh> Ah.
10:05:48 <adamvh> What's the application, if you don't mind me asking?
10:05:56 <behelit> jmcarthur: and why haskell over anything else for your game? (i'm not questioning your choice)
10:05:57 <KirinDave_> adamvh: I'm lead engineer for BankSimple.
10:06:00 <adamvh> Ah
10:06:20 <adamvh> Is ghci smart enough not to build a temporary in
10:06:23 <poindontcare> KirinDave_: is that some thing the twitter guys have started?
10:06:28 <KirinDave_> adamvh: You can see why we will keep scala around. Banking integration is tied up in java libraries. 
10:06:35 <shachaf> KirinDave_: Do you play NetHack?
10:06:37 <adamvh> sum $ map f $ iterate g
10:06:38 <KirinDave_> poindontcare: Uhh... well
10:06:42 <KirinDave_> shachaf: I have been known to.
10:06:55 <shachaf> I once got an email from a BankSimple person about NetHack.
10:07:06 <c1de0x> whatis NetHack?
10:07:07 <KirinDave_> poindontcare: Alex Payne is one of the founders. He's sort of a twitter guy.
10:07:10 <KirinDave_> shachaf: Who?
10:07:13 <KirinDave_> Might be me.
10:07:17 <jmcarthur> behelit: interestingly, because haskell makes state management easier than other languages do
10:07:29 <shachaf> KirinDave_: No, Josh.
10:07:34 <jmcarthur> behelit: i'm also a big fan of being able to write the code i want to write instead of the code C wants me to write
10:07:35 <poindontcare> KirinDave_: ah thought so 
10:07:39 <copumpkin> omg BankSimple talk in #haskell
10:07:40 <behelit> jmcarthur: compared to erlang as well?
10:07:46 <copumpkin> BankSimple should be ported to haskell
10:08:18 <djahandarie> All I know about BankSimple is that they have a cool website
10:08:18 <c1de0x> !whatis BankSimple
10:08:30 <jmcarthur> i'm not sure i see how erlang makes state management easy at all, aside from encapsulating it into processes
10:08:33 <shachaf> @where google
10:08:33 <lambdabot> I know nothing about google.
10:08:37 <KirinDave_> My co worker advises me to point out we have not yet done, nor committed to, any such haskell work on the product in question.
10:08:41 <shachaf> @where+ google http://www.google.com/
10:08:41 <lambdabot> Done.
10:08:46 <KirinDave_> So legally if you tweet we're using haskell I can totally sue you.
10:08:54 <copumpkin> lol
10:09:07 * copumpkin reluctantly deletes the tweet he was writing
10:09:19 <PeakerWork> KirinDave_: Scala has no pure sublanguage, right?
10:09:21 <copumpkin> then again, getting sued by companies is kind of fun!
10:09:24 <poindontcare> it would be so awesome if they used haskell
10:09:26 <KirinDave_> PeakerWork: Nope.
10:09:28 <adamvh> jmcarthur: what do you do for graphics?
10:09:34 <c1de0x> copumpkin we should know, rihgt ;)
10:09:37 <c1de0x> :P
10:09:38 <PeakerWork> KirinDave_: so how would it have cool parallel stuff? :-)
10:09:47 <KirinDave_> PeakerWork: Now now.
10:09:53 * copumpkin wonders if PeakerWork and c1de0x are geographically close
10:10:05 <c1de0x> copumpkin ?!?
10:10:06 <jmcarthur> adamvh: i'm reluctantly using a (still imperative) wrapper over OpenGLRaw
10:10:14 <shachaf> copumpkin: How close is close?
10:10:17 <PeakerWork> copumpkin: why?
10:10:23 <copumpkin> I dunno, lots of israelis in the room right now :)
10:10:32 <copumpkin> seems like ripe haskell user group material
10:10:47 <djahandarie> I think I know someone else who works at BankSimple
10:10:47 <jmcarthur> adamvh: i'd rather use a pure functional graphics library, but all my attempts to write one have met with frustration at the immensity of purifying opengl
10:10:48 <shachaf> HUG!
10:10:50 <djahandarie> Ian Collins, maybe
10:11:05 <adamvh> jmcarthur: Are you in 3D?
10:11:30 <jmcarthur> adamvh: (and i pretty much have to use opengl because i'm doing some effects direly needing gpu acceleration)
10:11:42 <jmcarthur> adamvh: it's kind of a "2.5D" thing
10:11:53 <PeakerWork> copumpkin: Is he Israeli?
10:12:02 <copumpkin> PeakerWork: shachaf is!
10:12:17 <djahandarie> shachaf lives in California though.
10:12:17 <shachaf> copumpkin: c1de0x isn't?
10:12:26 <shachaf> djahandarie lives in Germany.
10:12:30 <copumpkin> lol
10:12:34 <copumpkin> geheimdienst?
10:12:42 <djahandarie> shachaf, I think you mean gehmeimdienst
10:12:59 <shachaf> Whatever.
10:13:14 <copumpkin> pyrony: oh wow, klout.com!
10:13:39 <sm> KirinDave_: excellent, I'm one of those waiting for BankSimple news. "now live with haskell client lib" would be fine :)
10:14:47 <jmcarthur> adamvh, behelit: feel free to join #haskell-game if either of you are interested in making games in haskell
10:14:50 <copumpkin> shachaf: I hear he's in moss-
10:14:53 * copumpkin gurgles and dies
10:15:04 <jmcarthur> it's still a slow channel, but we have a decent number of people and the occasional conversation
10:15:06 <behelit> can you make cabal install packages for a specific project rather than your system?
10:15:07 <KirinDave_> sm: We will definitely NOT be prioritizing that particular client lib. Sorry bro. :)
10:15:17 <jmcarthur> behelit: try cabal-dev :)
10:15:22 * applicative thinks: pyrony?
10:15:24 <KirinDave_> sm: Something, "Now live with a Factor client lib. All 8 people who get it will be so stoked!"
10:15:28 <dcoutts> behelit: what do you mean exactly?
10:15:52 <dcoutts> behelit: you can install into a specific prefix and use a specific package db, if that's what you mean.
10:15:59 <behelit> dcoutts: like, if one project needs packageX v1 and another project needs packageX v2, can they coexist?
10:16:32 <jmcarthur> behelit: they can coexist
10:16:43 <dcoutts> behelit: you can install multiple versions of the same package, but you can't in a single package db have two instances of the same package built against different versions of their dependencies.
10:16:51 <sm> KirinDave_: well if you make it possible for us to write it, that will still rock
10:16:59 <KirinDave_> sm: We want to. 
10:17:08 <KirinDave_> sm: We may not be api-ready right at launch, tho.
10:17:13 <pmetzger> just documented the TeX input method for Emacs on the haskell wiki: http://haskell.org/haskellwiki/Unicode-symbols#Emacs
10:17:15 <dcoutts> behelit: and as I mentioned, you can use private package dbs.
10:17:35 <pmetzger> I was not entirely surprised it wasn't there, few people seem to know about it.
10:17:46 <sm> lots to do I bet
10:18:01 <KirinDave_> sm: Working at a financial entity that is also a startup is a weird experience. Same with the Square folks. Lawyers gotta go over everything you do or want to do with a fine toothed come.
10:18:02 <pmetzger> Well, maybe, but it isn't even documented on the emacs wiki itself.
10:18:06 <KirinDave_> s/come/comb/
10:18:07 <pmetzger> and it isn't in the emacs manual.
10:18:14 <KirinDave_> sm: There is that, too.
10:18:38 <pmetzger> oh, maybe I mistook who sm was replying to. <insert embarrassment.>
10:18:41 <tswett> @pl \f -> 0 : 1 : zipWith (+) f (tail f)
10:18:41 <lambdabot> (0 :) . (1 :) . ap (zipWith (+)) tail
10:18:54 <KirinDave_> sm: The final product is huge. We probably won't be there when we open our doors, as is standard for startups.
10:20:20 <sm> KirinDave_: I assume that means: won't have api access rolled out, not.. won't be part of the company
10:20:29 <behelit> dcoutts: so how would one go about this? say i cloned a project from github, i assume there is some kind of file that dictates what packages are needed? and then i'd run cabal-install with some switch? then i'd instruct ghc to use some other path to link other modules?
10:20:34 * sm isn't sure what's standard for startups these days
10:20:53 <KirinDave_> sm: Correct.
10:21:08 <KirinDave_> sm: I am not sure how anyone could hope to build a mobile-friendly startup that does not have some sort of API.
10:21:32 <KirinDave_> sm: You could try and hinder people's access to the API, but ultimately that's a fruitless effort best left to the wicked imagination of lawyers.
10:21:35 <adnam> behelit: the cabal file contains deps, just run cabal install in that dir
10:22:10 <dcoutts> behelit: right, the .cabal file specifies the dependencies. You can say where the files go with --prefix (and other similar ./configure style flags if you need more control) and --package-db
10:22:35 <dcoutts> behelit: then when building other things against that, either with cabal or with ghc directly then you have to specify that package-db
10:23:08 <dcoutts> behelit: but it's only worth doing this if you're sure it'd clash with something else in your normal per-user package db
10:23:28 <dcoutts> behelit: you can use cabal install --dry-run and compare it with ghc-pkg list to see
10:23:37 <behelit> great!
10:23:41 <behelit> then i'm happy :)
10:25:24 <adamvh> what's a good way to get timings in ghci?
10:25:43 <shachaf> :set +s?
10:25:53 <sm> oh, neat
10:26:13 <aristid> but ghci tends to interpret, not compile
10:26:35 <adamvh> Well, I compiled my module
10:26:44 <adamvh> I assume that if I compile it -O2 with ghc
10:27:04 <adamvh> and then :load it with ghci
10:27:11 <adamvh> I've got the optimized version
10:27:25 <jmcarthur> make sure you load Foo, not Foo.hs
10:27:32 <dons> adamvh: if you care about the performance numbers, compiling and using profiling is more sensible than ghci 
10:28:07 <adamvh> dons: I really just wanted to get a rough idea of the asymptotic performance of my algorithm
10:28:16 <dons> oh, +s is fine then
10:28:40 <adamvh> except I'm getting large negative numbers for the timing...
10:28:55 <adamvh> that seems odd
10:29:09 <dons> hmm
10:31:33 <sm> I should know this.. what's the most concise way to convert [a,b,c..] to [b-a,c-b,...] ? I'm in ghci and don't want to write a clunky function
10:32:16 <copumpkin> shachaf: MONADS MONADS MONADS
10:32:19 <adamvh> zipWith (-) (tail xs) xs?
10:32:27 <shachaf> @stab copumpkin
10:32:27 * lambdabot decomposes copumpkin into several parts using the Banach-Tarski theorem and reassembles them to get two copies of copumpkin!
10:32:31 <tswett> @quote aztec
10:32:31 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
10:32:34 <shachaf> Oh no.
10:32:34 <aristid> :t zipWith (-) =<< tail
10:32:35 <lambdabot> forall a. (Num a) => [a] -> [a]
10:32:36 <tswett> sm: use that.  :P
10:32:54 <sm> perfect, thank you
10:34:13 <adamvh> Hmm, :set +s seems irretrievably borked on 64-bit OS X
10:34:20 <adamvh> I guess it really is experimental
10:34:37 <adamvh> really I should just say borked
10:34:39 <applicative> adamvh, yes whats up with the large negative numbers for :set +s
10:34:51 <adamvh> applicative: do you have the same problem?
10:34:54 <applicative> yes
10:35:25 <adamvh> I suppose we should file a bug...
10:35:26 <applicative> just since i put in the new 64 bit platform thing on os x  It hadn't occurred to me that was the problem
10:35:44 <BrianHV> there have been a few times where I've found myself passing around a (state, result) tuple. that seems to be the sort of thing for which I'd want to use the state monad, but the wrinkle is that I compute a (state, result) tuple, then wait for input and do it again
10:35:45 <applicative> adamvh, sounds like it
10:36:13 <BrianHV> is there a good way of feeding input into a state monad? or should I be using something else like iteratees?
10:36:26 <applicative> adamvh, my experience is that usually my 'bugs' are my own idiocy ... but this must be  a bug
10:36:52 <adamvh> applicative: since we both are experiencing the problem independently, I would say it is at least a usability bug
10:37:10 <shachaf> BrianHV:: "feeding input into"? Do you mean runState?
10:38:08 <applicative> dons, :set +s looks like this for us:  http://hpaste.org/45920/set_s
10:38:34 <BrianHV> shachaf: that only takes a state, right? I suppose I could make the input part of the state...
10:38:37 <applicative> maybe its telling me when the ghci first ever calculated 1+1
10:38:43 <shachaf> BrianHV: What are you trying to do?
10:38:51 <pmetzger> OS X support seems shaky in general. :(
10:39:00 <shachaf> BrianHV: The "state monad" is just a function :: s -> (a,s).
10:39:14 <applicative> pmetzger it's a miracle compared to 1 year ago
10:39:33 <pmetzger> I've barely been using the platform seriously for two weeks, so I have no basis for comparison. :)
10:39:44 <BrianHV> shachaf: I guess I'm looking for something more like (a, s) -> (b, s)  (though in my case, a == b)
10:40:38 <shachaf> BrianHV: At this point I'm not sure at all what you want. :-)
10:40:39 <BrianHV> shachaf: I'm writing a midi thing. when I get midi input, I pass it and the current state to a function that returns midi events and a new state
10:40:50 <KirinDave_> BrianHV: A bit of code might help. :)
10:40:57 <applicative> pmetzger, before the platform, the recieved way of installing ghc was via macports, it would self-build, it was amazing.
10:41:16 <KirinDave_> Ugh. Macports
10:41:19 <KirinDave_> Bane of my existence.
10:41:21 <dons> applicative: huh
10:41:26 <dons> i'm on 64 bit linux, looks like (0.03 secs, 14249024 bytes)
10:41:28 <adamvh> KirinDave_: +1
10:41:31 <dons> applicative: i'd report a bug
10:41:44 <adamvh> applicative and I are on Mac OS X 64
10:41:46 <pmetzger> macports has a very hard problem to solve. i'm pretty happy it exists.
10:41:53 <applicative> dons, yes, we're plotting one.  sorry to waken you.
10:41:56 <KirinDave_> pmetzger: You've seen homebrew, yes?
10:42:04 <applicative> i thought you were still around
10:42:05 <dons> ?bug
10:42:05 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:42:06 <dons> ^^
10:42:06 <pmetzger> no. don't know what it is...
10:42:24 <KirinDave_> pmetzger: You might want to google "osx homebrew" and then become very much happier.
10:43:07 <pmetzger> does it have as many packages supported?
10:43:19 <KirinDave_> a good number
10:43:19 <pmetzger> thing is, there is lots of obscure crap I use from macports...
10:43:31 <pmetzger> if I really wanted to go to another platform I'd probably use pkgsrc
10:43:39 <KirinDave_> The secret super-sauce of homebrew
10:43:46 <KirinDave_> is that it's _extremely easy_ to define new packages
10:44:06 <pmetzger> it is easy to define new packages to macports too, you just need a few lines of tcl in a file...
10:44:14 <thoughtpolice> homebrew is the package manager I've wanted forever on OS X
10:44:15 <pmetzger> but I may be biased.
10:44:50 <pmetzger> (I used pkgsrc day to day until a couple of years ago, and it is genetically related to mac ports)
10:45:46 <KirinDave_> pmetzger: Well homebrew is as easy as macports but without the ancient and widely deprecated tcl dep, in terms of defining packages.
10:45:47 <KirinDave_> :D
10:46:20 <pmetzger> tcl is ancient crap at this point, that's true. it doesn't bother me much, though. I deal with much uglier stuff on a regular basis.
10:46:20 <BrianHV> http://hpaste.org/45921/weird_state_loop
10:46:21 <lispy> "as easy as macports" makes me want to avoid homebrew.  It sounds terrible when described that way.
10:46:31 <BrianHV> that's basically what I'm trying to clean up
10:46:54 <KirinDave_> lispy: I was being diplomatic.
10:47:02 <pmetzger> and he succeeded too.
10:47:07 <BrianHV> and btw, if there's an hpaste administrator here, "preview" clears the state of the "Expire in an hour" checkbox
10:47:23 <KirinDave_> lispy: In reality I think homebrew is a much better system than macpors, but there is no sense drilling that in here. 
10:48:20 <adamvh> applicative: I'm about to write up a ticket  - we shouldn't submit dupes, so let me know if you've already submitted one
10:48:29 <kwantam> gentlemen: with regard to a previous conversation about fancy unicode operators: there is actually a keyboard manufacturer still making buckling spring APL keyboards
10:48:45 <kwantam> in particular, Unicomp
10:48:58 <pmetzger> KirinDave_: my usual policy on these things is when someone tells me something is cool, I pay attention for a while, and if that thing grows and survives then I adopt it. :)
10:49:10 <pmetzger> I've been too burned by new things that died in the cradle.
10:49:16 <KirinDave_> pmetzger: Homebrew is not new.
10:49:22 <pmetzger> It is to me. :)
10:49:36 <KirinDave_> https://github.com/mxcl/homebrew
10:49:40 <pmetzger> but I'm now paying attention to it.
10:49:41 <KirinDave_> Pretty active dev cycle too :)
10:49:49 <dankna> it's also easy to define new packages with stow and /usr/local, heh
10:50:15 <KirinDave_> Yeah you can make packages just for yourself or your organization and distribute via git pulls, which is a neat trick.
10:50:26 <dankna> what really needs doing
10:50:37 <pmetzger> kwantam: you mean you want a keyboard with apl labels on it?
10:50:43 <dankna> is a project to convert common Unix libraries to .framework bundles
10:50:46 <dankna> I'm looking at Gtk.... heh
10:51:00 <pmetzger> kwantam: because those are easy enough to find. all keyboards are pretty much identical inside these days.
10:51:00 <dankna> I spent ALL DAY compiling it earlier this week ><
10:51:49 <sgronblo> Hey feeling a bit stupid here. Trying to use ceiling on the result of div, but apparently i need to turn my Fractional into a RealFrac somehow.
10:51:51 <pmetzger> kwantam: if you google for "apl keyboard labels" or "apl keyboard stickers" you'll find them.
10:52:20 <applicative> adamvh, I submitted this http://hackage.haskell.org/trac/ghc/ticket/5148
10:52:41 <dankna> :t fromFractional
10:52:42 <lambdabot> Not in scope: `fromFractional'
10:52:52 <applicative> the choice for architecture was a little wierd
10:53:18 <monochrom> @type realToFrac
10:53:19 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
10:53:38 <applicative> adamvh: I assume you can revise it, or I can remove it if you already put one up.
10:54:01 <applicative> adamvh: I haven't used the bug tracker for a while.
10:54:07 <adamvh> No, I didn't put one up.  I figured since you didn't respond you were in the middle of it
10:54:23 <kwantam> pmetzger: yes, but this also happens to be a nice IBM-style buckling spring keyboard, and it's got the APL symbols inscribed on the keycaps instead of stuck on there with something that'll presumably come off more easily (stickers or the like)
10:54:46 <dankna> you mean silkscreened, not inscribed
10:54:53 <kwantam> indeed, couldn't recall the proper word
10:55:14 <pmetzger> several manufacturers will sell you replacement keycaps for standard keyboards, and I think Unicomp will do custom jobs. not cheap of course.
10:55:23 <dankna> if you care deeply enough you can do it yourself with the appropriate type of paint and a stencil made out of freezer paper
10:55:37 <kwantam> yeah, or I can pay Unicomp $110 for a brand new IBM-style clicky keyboard with APL caps
10:55:42 <dankna> yeah, no, I see that
10:55:44 <pmetzger> I'm sure that this must be a FAQ among the APLers though, you might try asking them. Though I suppose things like A+ and J have decimated their ranks.
10:55:45 <dankna> if you like clickiness
10:55:46 <kwantam> I daresay I couldn't do it in the equivalent amount of time
10:56:02 <pmetzger> Unicomp makes nice things.
10:56:27 <joe6> i asked this in #agda and did not get a response. Just wanted to check if anyone knows of good introductory material to understand "theorem proving"
10:56:55 <sgronblo> Uh I'm not sure if those bot commands were some sort of implicit answer to my question already
10:56:55 <kwantam> of course then I'd need to come up with some vi bindings that would let me enter the corresponding symbols, but I'd guess it's already been done by someone else
10:56:59 <crystal-cola> what's "theorem proving"?
10:57:12 <dons> joe6: hmm. good question
10:57:17 <pmetzger> joe6: Benjamin Pierce's class at Penn (CIS 500) has its materials online
10:57:25 <pmetzger> joe6: that has a lot of intro material for Coq
10:57:32 <dons> yeah, i'd look at classes. e.g. Pierce or Klein
10:57:52 <kwantam> sgronblo: realToFrac should do the conversion you want
11:00:11 <pmetzger> joe6: another good source, believe it or not, is reading Goedel, Escher, Bach, which has a good lay explanation of formal logic and formal systems.
11:00:40 <sgronblo> kwantam: thanks
11:00:42 <ClaudiusMaximus> > ceiling (15134124 % 12341251 :: Rational) :: Integer
11:00:42 <lambdabot>   2
11:01:26 <monochrom> I read one of the early papers on automated theorem proving. you know, those that say "inspired by Herbrand's theorem, we iterate over this infinite set and hope we hit something..."
11:01:58 <pmetzger> to understand automated you must first understand non-automated. :)
11:02:03 <ClaudiusMaximus> > ceiling (fromIntegral 3 / fromIntegral 4 :: Double) :: Integer -- less precise, which may be acceptable depending on circumstances
11:02:04 <lambdabot>   1
11:02:45 <sgronblo> > realToFrac $ ceiling $ 100 / 80
11:02:46 <lambdabot>   2.0
11:03:10 <sgronblo> oh looked like an integer in ghci
11:03:16 <monochrom> blissfully, most automatic theorem provers' tutorials contain a bit of both
11:03:33 <joe6> pmetzger, ok, thanks
11:03:55 <eternalmatt> would anyone like to solve a homework problem i have :) ?
11:03:57 <pmetzger> I think the term used for things like Coq and Isabelle and what have you these days is "proof assistant" to distinguish them from the attempts to build things that operate entirely on their own.
11:04:24 <copumpkin> here, just take my NONELEMENTARY time-complexity algorithm for proving statements in real-closed fields
11:04:53 <dankna> eternalmatt, the correct question is "would anyone feel like solving a homework problem and sharing the answer with me"
11:05:01 <dankna> without that second part, you could wind up being rather frustrated
11:05:13 <monochrom> I wonder how you would interpret the names "automatic editor" and "automatic debugger" :)
11:05:20 <copumpkin> monochrom: oi oi oi
11:05:23 <pmetzger> copumpkin: my fave are functions that grow faster than any computable function. :)
11:05:35 <dankna> an automatic editor = something that writes my code for me
11:05:36 <eternalmatt> would anyone enjoy the opportunity to solve a classic problem and share the outcome with me :) ?
11:05:39 <copumpkin> pmetzger: pff, it'd be silly to work with those! mine, on the other hand
11:05:49 <monochrom> haskell has the lazy beaver
11:05:56 <joe6> what is the use of "theorem proving"? I have been told that once I learn that, my view of programming will change. Does anyone have any experiences to share in this regard?
11:05:59 <crystal-cola> what is the problem?
11:06:07 <crystal-cola> joe6: what is "theorem proving"?
11:06:08 <monochrom> @faq can haskell solve the lazy beaver problem?
11:06:08 <lambdabot> The answer is: Yes! Haskell can do that.
11:06:10 <copumpkin> monochrom: pretty please!! could you maybe possibly consider putting the source to your factoring code up anywhere?
11:06:17 <pmetzger> joe6: you would have to be more specific about what you're asking.
11:06:45 <pmetzger> joe6: much more specific.
11:06:46 <monochrom> I think mine is the slowest of all...
11:06:48 <copumpkin> joe6: proving _is_ programming (and _is_ is a symmetric relation), if you look at it in the right way
11:06:59 <joe6> pmetzger, i am learning agda. and, i did not understand "propositions" and how the equal operator is a proposition.
11:07:27 <eternalmatt> A successful businessman opened a retirement account by depositing a certain amount of money (some dollars, no cents) just before the end of a year. He made another deposit (again, some dollars, no cents) one year later. From that time, towards the end of each year he deposited some amount of money. His deposits followed a pattern: From the third year onwards, the amount of each deposit was equal to the total of two previous depo
11:07:35 <joe6> pmetzger, to understand that, I was told to read the "agda tutorial", but I got lost in the last chapter on "theorem proving" in that tutorial.
11:07:47 <eternalmatt> "What is his initial desposit?"
11:07:48 * monochrom knows of two program-proof correspondences. curry-howard is just one, and not the most interesting
11:08:02 <pmetzger> joe6: do you understand what dependent types are, or the Curry-Howard isomorphism?
11:08:03 <dankna> your long message was cut off at the point "total of two previous deposits", eternalmatt
11:08:10 <pmetzger> joe6: that is, do those words mean anything to you?
11:08:16 <shachaf> monochrom: Which is the more interesting?
11:08:18 <joe6> pmetzger, there were too many mathematical symbols there and I was clueless of most of the terminology there.
11:08:30 <monochrom> theodore norvell has another one
11:08:42 <pmetzger> joe6: then you're probably not in a position to attack agda I think. I'd start simpler...
11:08:49 <eternalmatt> dankna, total of two previous deposits (from two previous years). His 20th deposit was 1,000,000.
11:09:07 <monochrom> http://www.engr.mun.ca/~theo/Publications/proofgramming.pdf
11:09:11 <eternalmatt> So in this problem, all numbers are Integral
11:09:14 <dankna> hm
11:09:20 <dankna> yeah, interesting problem actually
11:09:20 <monochrom> and it doesn't shy away from classical logic like curry-howard does
11:09:31 <eternalmatt> i'm having trouble with it, myself
11:09:49 <joe6> pmetzger, i like agda's type system. i find it more intuitive. But, I am not able to understand the "propositions" stuff, though.
11:09:51 <eternalmatt> Others in my class want to do a brute force via imperitive langs
11:10:10 <pmetzger> monochrom: I suspect he's not going to be able to read that.
11:10:14 <dankna> I'm not convinced it needs a program to solve it
11:10:20 <dankna> it might be possible to arrive at a solution analytically
11:10:25 <monochrom> no, it is for a specific query
11:10:28 <eternalmatt> Yes, most likely
11:10:57 <eternalmatt> A student showed his solution, but it involved finding a close value, then guessing repeatedly 10 times. Not very elegant IMHO
11:10:59 <pmetzger> monochrom: gah,I got confused by the interacting conversation threads again...
11:11:19 <joe6> monochrom, that is an interesting article. Thanks
11:11:24 <pmetzger> compound interest formulas are most easily solved with differential equations.
11:11:37 <pmetzger> but those lead to continuous, not discrete, solutions.
11:12:05 <pmetzger> this requires solving a recurrence relation.
11:13:00 <pmetzger> which is not too bad, but I think I'd be unfair to your professor if I did it for you. that said, you'll find a lot of good material on recurrence relations and their solutions in CLSR or other algorithms textbooks.
11:13:17 <dankna> I have a trivial solution that I think shows a flaw in the problem description
11:13:20 <dankna> one sec, I'm nopasting it
11:13:32 <eternalmatt> I'm interested in solutions
11:13:36 <dankna> http://nopaste.dk/p3162
11:13:45 <eternalmatt> I wrote something but I can't test it. I'm away from main machine
11:13:45 <pmetzger> http://www.amazon.com/Introduction-Algorithms-Third-Thomas-Cormen/dp/0262033844/
11:13:47 <dankna> this can't be allowed, can it?
11:13:57 <dankna> but I don't see a constraint in what you wrote that disallows it
11:14:00 <eternalmatt> lmao
11:14:12 <eternalmatt> that's brilliant
11:14:15 <dankna> thanks haha
11:14:28 <eternalmatt> To be honest, that should work.
11:14:52 <eternalmatt> Do you want to know the values my prof gave?
11:14:53 <joe6> pmetzger, "then you're probably not in a position to attack agda I think. I'd start simpler..." -- like what? any suggestions, please?
11:15:05 <pmetzger> what is your background, and what is your goal?
11:15:06 <dankna> sure, that way I won't feel compelled to spend further time on it :)
11:15:15 <monochrom> joe6: I think we need to know what you already know
11:15:26 <eternalmatt> f 1 = 154 and f 2 = 144
11:15:30 <djahandarie> pmetzger, btw, joe6 has been doing Agda for a bit now and does understand dependent-typing imo
11:15:46 <crystal-cola> why does he keep using scare quotes then
11:15:55 <dankna> to strike fear in the hearts of his enemies
11:16:00 <dankna> that's why they're called "scare" quotes
11:16:01 <djahandarie> The jump from programming in Agda to proving in Agda is not a particularly easy one imo
11:16:04 <crystal-cola> and refuses to clarify what he means :/
11:16:20 <eternalmatt> dankna, actually yours doesn't fit the problem
11:16:31 <eternalmatt> only the first 3 values make sense
11:16:55 <dankna> eternalmatt, I see a wording issue in the problem - it says "two previous deposits" which I took to mean "ANY two previous deposits"
11:16:59 <pmetzger> eternalmatt: you can save minutes spent in the library reading about recurrence relations and their solution with hours of guesswork. That reminds me of an ancient saw among chemists....
11:17:03 <ksf> omg
11:17:06 <ksf>         g (Return (f -> x), c) = undefined
11:17:07 <dankna> rather than "the two immediately previous deposits"
11:17:09 <pmetzger> which is that you can save hours in the library with months in the lab.
11:17:10 <ksf> that syntax-checks.
11:17:13 <ksf> I never knew.
11:17:35 <djahandarie> ksf, view patterns?
11:17:41 <ksf> yep.
11:17:50 <ksf> too bad I still need to case match on x
11:18:08 * monochrom wonders why self has almost never asked for introductory reading material
11:18:09 <ksf> or would ghc share the call to f between two patterns?
11:18:14 <eternalmatt> In my solution, I say something like banker n = banker (n-1) + banker (n-2) but I don't know how to word the base cases banker 1 = x, banker 2 = y
11:18:30 <pmetzger> thus your desire to learn about recurrence relations. :)
11:18:38 <eternalmatt> T.T
11:18:49 <sgronblo> haskell doesn't have python-style r'string' literals right?
11:18:55 <dankna> yeah, I mean, the serious answer is get thee to a library, go!
11:19:02 <dankna> sgronblo, correct - does not have
11:19:04 <eternalmatt> lol
11:19:35 <pmetzger> http://en.wikipedia.org/wiki/Recurrence_relation
11:19:46 <sgronblo> dankna: thats a real shame
11:19:54 <applicative> what are r'string literals
11:20:12 <eternalmatt> whataremyeyesreading.jpg
11:20:18 <pmetzger> that is far more complicated than you want to read though.
11:20:19 <sgronblo> applicative: string literals where you dont have to double all your backslashes
11:20:39 <pmetzger> you would much rather start with a simple introduction including simple solution methods
11:20:40 <applicative> sgronblo: ah, no.  
11:20:47 <dankna> I'm dubious that that saves much work in the kinds of situations I run into
11:20:50 <sgronblo> so all your patterns look like shit
11:21:28 <applicative> the machinery can detect when \ is merely escaping and when it's real?
11:21:35 <dankna> I most commonly have leaning toothpick syndrome when dealing with JavaScript embedded in HTML embedded in Haskell (arguably I'm doing something wrong)
11:22:14 <joe6> djahandarie, "The jump from programming in Agda to proving in Agda is not a particularly easy one imo" -- this is exactly where I am
11:22:16 <dankna> which wouldn't really be addressed by any obvious different quoting rules, since the client languages each get a shot at applying their own constraints
11:22:19 <eternalmatt> curious, do you have a solution, pmetzger?
11:22:20 <sgronblo> that sounds like youre doing it wrong yeah
11:22:25 <crystal-cola> why would you prove things in Agda?
11:22:31 <crystal-cola> that's silly
11:22:44 <crystal-cola> use a serious type theory like Coq if you want to prove theorems
11:23:03 <sgronblo> btw, how do i find out what packages i have installed in my haskell platform?
11:23:12 <dankna> Haskell Platform is a certain fixed set of package
11:23:13 <dankna> s
11:23:16 <monochrom> you should use an abstract syntax tree for javascript, an abstract syntax tree for html, and then ask them to be rendered to text
11:23:16 <parcs> ghc-pkg list
11:23:19 <dankna> ghc-pkg list will tell you about them
11:23:20 <joe6> crystal-cola, I like the types of agda. They seem to be more intuitive.
11:23:51 <dankna> monochrom: well, that has efficiency considerations
11:23:56 <sgronblo> oh thanks
11:23:59 <philed> You've got a tactic system and various other proof tools in Coq if you want to do formalisation.
11:24:09 <crystal-cola> and Coq has actually got a theory
11:24:17 <crystal-cola> whereas Agda has no theory and consistenly proves False
11:24:27 <philed> crystal-cola: Oh, didn't know that!
11:24:35 <copumpkin> it's not nearly as bad as crystal-cola makes it out to b
11:24:39 <copumpkin> but it does happen every so often
11:24:46 <crystal-cola> It's much worse than I make out
11:24:52 <philed> But the type system is unsound?
11:24:57 <crystal-cola> they want it to be sound
11:25:01 <crystal-cola> but who knows?
11:25:10 <crystal-cola> Nobody even understands the language constructs in Agda
11:25:11 <copumpkin> the "de bruijn criterion"
11:25:15 <crystal-cola> let alone their interaction
11:25:20 <sgronblo> so regex-posix is the only "application level" regex library bundled with haskell platform?
11:25:23 <copumpkin> it's fun to play with
11:25:27 <djahandarie> philed, Agda's type system is suppose to be sound. It usually is, sometimes HEAD gets broken.
11:25:34 <crystal-cola> yeah it's some weird research toy that everyone loves because it looks like haskell
11:25:37 <copumpkin> and in practice you don't end up proving false most of the time
11:25:43 <crystal-cola> popularity for superficial reasons
11:25:45 <crystal-cola> as usual
11:25:49 <djahandarie> crystal-cola, I think you're underselling it.
11:25:51 <copumpkin> crystal-cola: I'm glad you have it all figured out :)
11:26:12 <monochrom> finally, someone who understands popularity
11:26:14 <crystal-cola> why say that? I know you don't take my opinion with any seriousness
11:26:47 <applicative> sgronblo: i have regex base regex posix and regex compat in the platform part of my machine.
11:27:06 <philed> I did a little course recently given by Connor, and he seemed to regard it mostly as a programming language for expressing strong types, but even then, seemed quite keen on the idea that you shouldn't try to prove anything *too* strong about your program, because it can be a nightmare.
11:27:43 <crystal-cola> philed: Although, I think Conor has a vision where you don't need to spend hours writing difficult proofs
11:27:45 <copumpkin> @djinn (a -> b) -> (Not b -> Not a)
11:27:45 <lambdabot> f a b c = b (a c)
11:28:02 <crystal-cola> philed: that you can get a massive amount of correctness by construction, etc.
11:28:12 <crystal-cola> philed: But that's an art form which we have not perfected
11:28:16 <copumpkin> I really hope he's right
11:28:21 <copumpkin> but it's definitely not really there yet
11:28:21 <philed> Yeah, he made a point about getting your representations right.
11:28:33 <Veinor> @pl f a b c = b (a c)
11:28:34 <lambdabot> f = flip (.)
11:28:38 <crystal-cola> in the mean time we can use theories that let us write difficult proofs easily
11:28:44 <sgronblo> applicative: but isnt regex base just for creating a regex implementation and regex compat for backwards compatibility with older ghcs?
11:28:47 <applicative> sgronblo: yes, all three are in the Platform
11:28:51 <hpc> @src Not
11:28:52 <lambdabot> Source not found. My mind is going. I can feel it.
11:29:00 <copumpkin> @let modusTollens = flip (.)
11:29:01 <lambdabot>  Defined.
11:29:05 <hpc> copumpkin: Not a = Void -> a?
11:29:11 <hpc> or a -> Void?
11:29:11 <copumpkin> > (+1) `modusTollens` (*5) $ 5
11:29:13 <lambdabot>   30
11:29:17 <copumpkin> hpc: a -> Void
11:29:21 <hpc> groovy
11:29:28 <philed> @src void
11:29:29 <lambdabot> Source not found. Are you on drugs?
11:29:29 <copumpkin> void :: Void -> a
11:29:45 <sgronblo> applicative: but the posix one is the one you would actually use for matching and such?
11:30:19 <hpc> void = const undefined?
11:30:43 <joe6> crystal-cola, but, the type system in agda is very simple and easier to understand. do not have to bother with all the type system hacks of haskell.
11:30:50 <crystal-cola> joe6: no it's not
11:30:51 <applicative> sgronblo: yes. but there are several others around of course. 
11:31:34 <crystal-cola> it's not even a fixed thing, it changes all the time
11:31:40 <applicative> sgronblo, above i was just worrying there was some defect in your installation.  
11:31:49 <jmcarthur> oh terrible. a new language continues to innovate
11:32:01 <applicative> is agda being trolled; is nothing sacred
11:32:07 <crystal-cola> jmcarthur: that kind of sarcastic remark is completely unnecessary
11:32:18 <jmcarthur> crystal-cola: so is bullshit
11:32:32 <crystal-cola> ok? Well everything I said is a fact, deal with it
11:32:35 <pmetzger> gentlemen, you can't fight in here, this is the war room.
11:32:51 <pmetzger> (my fave quote from Dr. Strangelove.)
11:32:59 <sgronblo> applicative: that't what I tried to refer to by "application level" package. I guess it was a bit unclear.
11:33:09 <jmcarthur> crystal-cola: so prove False in agda
11:33:15 <crystal-cola> jmcarthur: google it
11:33:21 <jmcarthur> it's old
11:33:26 <jmcarthur> i know what you are referring to
11:33:31 <jmcarthur> i'm asking if you, all knowing one, can do it
11:33:35 <crystal-cola> uh you only know one instance of it happening?
11:33:41 <copumpkin> there are a few 
11:33:43 <applicative> sgronblo: yes, i wasn't reading carefully enough; I took it for a different kind of question
11:33:47 <copumpkin> but all known ones have been fixed
11:33:48 <crystal-cola> This is stupid
11:33:51 <sgronblo> applicative: also when you're on a train out on some bloody field where you have a very slow mobile broadband connection you have to make do with what's in haskell platform. also i haven't had time to figure out how to install haskell packages yet.
11:33:56 <jmcarthur> it is as copumpkin says
11:33:56 <crystal-cola> I'm putting you on ignore jmcarthur, I don't need your insults
11:34:01 <jmcarthur> lol
11:34:09 <crystal-cola> I never claimed to be "all knowing one", if I said something false you could have the decency to disagree with me
11:34:17 <applicative> sgronblo  cabal install regex-pcre
11:34:21 <jmcarthur> you declared that everything you said is fact
11:34:25 <jmcarthur> that's a bold statement
11:34:32 * applicative thinks or is it prce
11:34:42 <copumpkin> the last inconsistency I recall was a proof that all functions are injective
11:34:47 <copumpkin> and that was over a year ago now
11:34:48 <crystal-cola> you said I was speaking bullshit: Fuck you
11:34:55 <jmcarthur> you can prove me wrong
11:35:03 <copumpkin> calm down
11:35:59 <applicative> it seems strange to object on these grounds crystal-cola, doesn't it.  no one thinks agda is as developed and advanced as coq do they
11:36:06 <joe6> crystal-cola, why do you hate agda so much? I like the fact that the constructors can be mixed between the type-level and the value level
11:36:15 <crystal-cola> joe6: I think agda is great
11:36:20 <ksf> there's idris, too.
11:36:31 <copumpkin> and epigram 2, vaporware of the century!
11:36:32 <copumpkin> :D
11:36:33 <ksf> afaiu agda wasn't ever meant to be used by non-phd's.
11:36:33 <applicative> what is the source of this un-#haskell like animosity?
11:36:36 * copumpkin can't wait until it condenses
11:36:38 <jmcarthur> i agree that agda occasionally is broken, but the image you are casting of it being a wasteland of theoretically intractible crap requires some stronger evidence
11:36:45 <copumpkin> ksf: It's actually pretty simple to use :P
11:36:50 * applicative 's analogy has been anticipated
11:37:04 <copumpkin> ksf: I also really hate the "you have to have a Ph.D. to use X" mentality
11:37:04 * monochrom thought LaTeX 3 was the vapourware of the century
11:37:06 <BrianHV> am I missing a State function like  alterState f = do { state <- get; put f state } ?
11:37:16 <ksf> copumpkin, well, it's a description.
11:37:25 <djahandarie> ksf, just like you need a Ph.D to program in Haskell? ;)
11:37:26 <ksf> I know that I don't have the proof skills to satisfy agda
11:37:27 <BrianHV> (er... put (f state) )
11:37:49 <copumpkin> ksf: dude, I have no background in math and don't have a Ph.D., and I program in agda all the time :P
11:38:16 <sgronblo> hmm, do i need libpcre3 or libpcre3-dev?
11:38:18 <parcs> BrianHV: modify ?
11:38:28 <applicative> crystal cola, I reject Martin Lof ism, his first version was inconsistent.  Of course he keeps working on it, but face it, it's just baling wire and string
11:38:35 <monochrom> perhaps you deserve a PhD :)
11:38:41 <joe6> ksf, that is my problem too. I am not able to understand the proof-programming portion of agda. will coq help? learn the basics of proofs in coq and translate that knowledge to agda
11:38:43 <ksf> and as I consider myself to be in the upper quartile when it comes to theory knowing down-to-earch programmers, that doesn't particularily recommends agda for, say, things other people use php for.
11:38:47 <applicative> similarly, modern logic is a crock, Frege invented it, and what happened?
11:39:00 <crystal-cola> applicative: Why are you complaining about people being un-haskell then taking the piss out of me the next moment?
11:39:05 <jmcarthur> crystal-cola: i'm sorry for my animosity. i'm not having an awesome week and i'm allowing it to affect my mood. i'll just stop looking at irc for a while
11:39:07 <crystal-cola> applicative: Instead, why not be nice to me?
11:39:17 <BrianHV> parcs: looks like the winner. thanks!
11:39:18 <crystal-cola> jmcarthur: well how about this instead
11:39:20 <applicative> my view was that you were being mean, maybe wrongly
11:39:28 <copumpkin> ksf: oh, sure, that's different from needing a Ph.D. to use it though :) I think any curious programmer who's interested in haskell could handle agda without much more difficulty (except the lack of as many tutorials for it)
11:39:31 <crystal-cola> jmcarthur: If you disagree with something I say, do so vigorously.
11:39:42 <crystal-cola> jmcarthur: I don't want to be mocked and told not to say things, but I am happy to be wrong and learn from my mistakes
11:39:52 <applicative> crystal-cola: I take it back.
11:39:55 <ksf> ---> approach negative comments by asking for details (kind of like Socratic questioning), rather than challenging the competence of the writer (ad hominem).
11:40:01 <copumpkin> monochrom: hah, I quit that :P
11:40:13 <jmcarthur> ksf: that was my error
11:40:23 <ksf> that's a quote from http://www.haskell.org/haskellwiki/IRC_channel
11:40:29 <copumpkin> YOUR MOM
11:40:32 <ksf> never thought I'd actually have to paste it here.
11:40:38 <copumpkin> ad matrem attacks
11:40:38 <applicative> its one of our rules.
11:41:01 <crystal-cola> jmcarthur: and the problem is certainly me and not you, since I am not some pushover that just accepts all mainstream views. For that reason anywhere I go I cause massive angry arguments. It sucks.
11:41:13 <jmcarthur> crystal-cola: i was saying in an overly aggressive way that the burden of proof is on you for those claims. it would certainly be tougher for me to demonstrate agda's correctness here
11:41:32 <joe6> copumpkin, how did you learn the "theorem proving" portion of agda?
11:41:36 <crystal-cola> jmcarthur: There is no point pretending agda is correct, IIR is not understood
11:41:42 <ksf> wtf this is irc, people. you're supposed to flame, not overcome your differences.
11:41:44 <joe6> copumpkin, i have no math background too
11:41:49 <pmetzger> In general, hot arguments are not cool. I have a marvelous proof of this which is sadly too large to fit in the margin of this book.
11:41:52 <crystal-cola> jmcarthur: We have no correctness proof for it, it's research material
11:42:11 <copumpkin> joe6: from the most basic possible statements! learn about the curry-howard correspondence and play with @djinn a lot :)
11:42:22 <jmcarthur> crystal-cola: statements like that are the kind you need to support. it's true that it's not understood, but you were going pretty beyond that
11:42:25 <copumpkin> joe6: I played with very simple things that I could define on the natural numbers, mostly
11:42:26 <applicative> crystal-cola, but the puzzle is why would you expect agda to be correct, it undergoes violent change all the time.  im using the new --without-k flag
11:42:36 <crystal-cola> jmcarthur: it is well stronger (in the proof theoretic sense) than any of the current theories whose consistency is known
11:42:39 <jmcarthur> crystal-cola: Coq has been used to prove false, too
11:42:46 <monochrom> pmetzger: I'll write that proof with you. firstly, why the bloody hell do you think it's true?!!!  XD
11:42:50 <crystal-cola> jmcarthur: I know
11:43:04 <applicative> take co-induction, please
11:43:32 * ksf suggests moving the discussion over to -in-depth
11:43:37 <ksf> you're scaring the newbies.
11:43:39 <pmetzger> joe6: Coq teaches one a lot about the curry-howard isomorphism, but I don't know if that is the royal road to learning it.
11:43:44 <ksf> doesn't anyone think of the newbies?
11:43:58 <djahandarie> ksf, I eat noobs
11:43:58 <hpc> oh, the huge manatee
11:44:31 <monochrom> Coq learning material is a nice place to learn the intuitionistic logic that you will use for most dependent-type things
11:44:36 * applicative was thinking Coq v. Agda is better than, e.g. cranky category theory disputes
11:44:57 <pmetzger> I don't really know Agda beyond glancing at it.
11:45:04 <copumpkin> most of the CT talk has moved to ##categorytheory 
11:45:12 <djahandarie> The primary method of proving things in Coq is tactics though, which don't exist in Agda
11:45:24 <copumpkin> we have reflection
11:45:28 <copumpkin> but unfortunately nobody's ever used that
11:45:28 * applicative is a complete aesthete.  the problem with coq is like the problem with sml.
11:45:37 <pmetzger> I find Coq's UI a bit unpleasant.
11:45:41 <joe6> agda needs more tutorials..
11:45:44 <monochrom> but the learning material doesn't bring in tactics too early, or not too automatic tactics
11:45:51 <crystal-cola> applicative: yes superficial reasons are whey everyone (counter-productively) recommends beginners learn agda
11:45:54 <pmetzger> lots of little things. like, for example, if a tactic fails, it would be nice if it showed you how far it got before it died
11:46:01 <pmetzger> but it isn't really set up to do that. :(
11:46:06 <joe6> monochrom, any coq tutorials that you would recommend?
11:46:12 <djahandarie> copumpkin, tactics and reflection aren't equivalent though, are they?
11:46:13 <monochrom> the official one
11:46:15 <jmcarthur> i personally don't think the point of agda is to write proofs anyway. it's just to have a very expressive type system
11:46:15 <crystal-cola> They end up programming with "Vectors" and then leaving it to do some real programming (in haskell)
11:46:23 <applicative> crystal-cola: I certainly wouldn't recommend that to beginners
11:46:29 <pmetzger> Benjamin Pierce's CIS500 notes are a good way to learn Coq, or at least are the way I learned it.
11:46:44 <pmetzger> I can't say if they're the best way.
11:46:46 <crystal-cola> jmcarthur: and also for research into pragmatics/etc of dependent programming language design
11:46:51 <jmcarthur> yes
11:46:54 <applicative> jmcarthur: this is the part I dont get about this Agda v Coq, which is better, they aren't the same at all
11:47:07 <crystal-cola> if you're not into programming language design I would not recommend looking at agda
11:47:13 <ksf> @tell dons  just to add a single straw to the workload on your back: the #haskell statistics haven't been updated since 2009 or such
11:47:13 <lambdabot> Consider it noted.
11:47:33 <applicative> crystal-cola: what is the thing that you would be interested in that would lead you to look at coq
11:47:46 <crystal-cola> if you want to learn how to program with dependent types
11:47:53 <crystal-cola> or give formal correctness of programs
11:48:13 <ksf> idris has tactics
11:48:15 <applicative> I am only interested in the former.  Why is agda bad for that?
11:48:17 <djahandarie> Hmm, I'd say the first bullet is nicer in Agda. It's 'natural' feeling extension to Haskell
11:48:24 <djahandarie> It's a*
11:48:28 <ksf> it also suffers the cancer of the semicolon, but otherwise seems just right
11:48:34 <ksf> needs more love and manpower.
11:48:35 <djahandarie> Idris is more natural but less complete
11:48:46 <applicative> semicolons destroy thought!
11:49:19 <ksf> I don't consider any language that requires tons of type annotations a "natural extension" of haskell
11:49:22 <applicative> " fun x => " destroys cognition!
11:49:46 <pmetzger> thinking destroys cognition! and vice versa! or so I think.
11:49:50 <ksf> the very point about haskell is that it makes static typing painless, so people actually use it.
11:49:56 <applicative> but the haskeller uses type annotations and reads them. 
11:50:45 * ksf hits _T once in a while to get annotations...
11:50:49 <djahandarie> ksf, hmm, I really believe that Agda is, syntactically speaking, far more similar to Haskell than you think
11:51:02 <ksf> it has a different feel to it, though.
11:51:11 <ksf> java is quite close to C, syntactically, too.
11:51:19 <copumpkin> agda doesn't require type annotations most of the time
11:51:28 <copumpkin> in fact, you can't annotate arbitrary expressions
11:51:47 <ksf> another big issue is that it seems to require emacs
11:51:53 <crystal-cola> that's not an issue
11:51:57 <crystal-cola> since you can just learn to use emacs
11:51:58 <crystal-cola> problem solved
11:51:59 <copumpkin> I don't like emacs, but it's more than fine to use occasionally
11:52:00 <joe6> agda seems to be getting the most attention, compared with idris, etc..
11:52:01 <applicative> ksf, god that is so annoying
11:52:05 <Twey> Heheh
11:52:08 <Zao> crystal-cola: I'm pinky-incompatible with Emacs.
11:52:10 <copumpkin> it really isn't that bad :P
11:52:18 <crystal-cola> Zao: me too, so I don't use the pinky
11:52:20 <Twey> Zao: Remap stuff
11:52:20 <pmetzger> everything requires emacs in the end. for example, I've found for years that I couldn't oxygenate my tissues without emacs.
11:52:26 <copumpkin> the main problem emacs gives agda is the knee-jerk reactions people have against it
11:52:28 <applicative> no, emacs is torture but i got used to C-c C-l etc :)
11:52:30 <ksf> copumpkin is a double-agent.
11:52:39 <Twey> http://www.ergoemacs.com/
11:52:47 <Zao> Twey: Making myself incompatible with any advice out there? Sounds awesome.
11:52:54 <crystal-cola> I mean get real, if you're smart enough to learn to use a programming language... you can learn to use a text editor
11:52:56 <djahandarie> joe6, the Idris tutorial is quite nice. The knowledge transfers to Agda also. But it doesn't go much into the proving stuff as usual
11:52:57 <joe6> emacs usage is not that bad, when using agda.
11:53:08 <crystal-cola> it's just you need to leave your "comfort zone" for a bit 
11:53:16 <copumpkin> I agree
11:53:17 <Zao> crystal-cola: The problem is that any hacker of sufficient awesomeness is deeply entrenched in his Editor of Choice.
11:53:19 <ksf> crystal-cola, I know my vim, thank you. and I don't want to learn another language *and* another editor at the same time.
11:53:21 <Twey> Zao: Err, if you can't figure out how to press M-a when someone says M-x, you have bigger problems :þ
11:53:32 <Zao> "for a bit" would be "months and months of unproductivity"
11:53:41 <crystal-cola> Zao: yeah I guess that part of human nature is hard to get past
11:53:41 <applicative> emacs is not a text editor in the contemporary sense. Its something much stranger.
11:53:41 <copumpkin> ksf: where "learn another editor" means typing into a text box and seeing text appear?
11:53:42 <joe6> djahandarie, i think i understand the type aspect of agda. but, am having trouble understanding the "proving" aspect and the propositions, etc.
11:54:01 <pmetzger> I'm with Will Rodgers. I never meta x I didn't like.
11:54:05 <Zao> crystal-cola: Agda needs to come with a new type of lifeform.
11:54:11 <ksf> copumpkin, I'm one of those vim users who doesn't touch the arrow keys
11:54:28 <ksf> using any editor is an exercise in slowness.
11:54:32 <djahandarie> joe6, http://blog.ezyang.com/2010/06/well-founded-recursion-in-agda/ here is *an* article using Agda for proving stuff. I'm not sure if it's going to connect all the dots, but maybe it will connect some. :)
11:54:34 <Twey> pmetzger: :-D
11:54:46 <ksf> *any other
11:54:46 <joe6> i write my agda program using vim, and have auto-read mode set in emacs. so, it automatically reads any changed agda program.
11:54:49 <applicative> I can't use meta on my mac without withdrawing from the keys.  It's nonsense
11:55:06 <ksf> I tried to use yi, but it doesn't even support half of the vim stuff I use
11:55:07 <pmetzger> withdrawing from the keys?
11:55:08 <Twey> That's an issue with your Mac, not with emacs
11:55:16 <joe6> so, the emacs component of agda should not be a bottleneck.
11:55:25 <Twey> More helpfully, you can remap alt to be meta
11:55:28 <pmetzger> I use Emacs 23 on a mac. I have command as my meta.
11:55:35 <Twey> Or command, if that's your thing
11:55:38 <pmetzger> you can use alt/option as meta instead but I am too used to command.
11:55:41 <applicative> i use alt as meta. 
11:55:48 <Twey> Ooh, pretty site
11:55:49 <applicative> command as meta is hopeless for other reasons
11:55:50 <pmetzger> using alt is more mac-y
11:56:09 <pmetzger> if you use command you give up things like command-c, but I don't need them.
11:56:09 <ksf> I have an european keyboard with capslock reserved for xmonad and esc mapped to ~
11:56:22 <joe6> djahandarie, thanks, am checking out that article.
11:56:40 <ksf> (and ~ where the right part of us-keyboards' left shift is)
11:57:05 <ksf> I get cranky when I have to leave the alphanumeric area.
11:57:08 <pmetzger> it is very important, if you're using emacs on a mac, to use a recent emacs 23 build of Emacs.app -- I've seen people trying to run the emacs that comes with the mac, and it isn't pretty.
11:57:56 <applicative> pmetzger: That's what i have, I use the gui for agda's sake.  But i consider it a kind of mental illness, i confess
11:58:01 <djahandarie> ezyang, the slides he links to are also nice
11:58:03 <djahandarie> Uh
11:58:05 <djahandarie> Whoops
11:58:12 <djahandarie> joe6, the slides he links to are also nice :p
11:58:31 <pmetzger> emacs vs vi is mostly about what one learned first. I learned emacs so long ago it is probably not possible for me to rewire my brain any longer.
11:58:55 <pmetzger> there isn't that much of an objective difference, though emacs is much more programmable for many purposes. that can be a good or a bad thing.
11:59:03 <applicative> pmetzger: consider the catastrophic ugliness of the gui emacs.  it's unbelievable. really.   
11:59:13 <pmetzger> so it is ugly?
11:59:27 <monochrom> select/poll vs threads is also merely what one learned first
11:59:32 <pmetzger> it works. I get my work done faster than the kids trying to edit code in TextEdit or TextMate.
11:59:49 <pmetzger> monochrom: no, there is a real difference between how event driven vs. threaded servers scale.
11:59:56 <pmetzger> huge difference, actually.
12:00:07 <jmcarthur> we went from agda vs. coq to emacs vs. vim...
12:00:24 <pmetzger> in a language like C that is. if you're using lightweight threads in some language with call/cc it makes no real difference.
12:00:30 <blackdog> pmetzger: depends whether you're talking OS threads or nice lightweight threads...
12:00:32 <hpc> jmcarthur: now we just need to transition to kirk vs. picard to complete the nerdy trinity
12:00:33 <joe6> djahandarie, thanks, will check them out too.
12:00:34 <blackdog> damn, beat me to it
12:00:34 <crystal-cola> jmcarthur: is that a natural transformation?
12:00:49 <jmcarthur> heh
12:00:50 <djahandarie> Agda vs. Coq is the holy war of #haskell, compared to emacs vs. vi everywhere else ;)
12:01:10 <monochrom> alright, let's take a language in which there is no real difference
12:01:16 <Twey> pmetzger: I learnt vi first.  I still prefer emacs.
12:01:22 <hpc> the answer is obviously coq because the name is easier to make jokes with
12:01:24 <monochrom> then select/poll vs threads is merely what one learned first
12:01:26 <jmcarthur> hmm, i thought i said i was going to stop looking at irc. i would be more productive doing that anyway
12:01:30 * jmcarthur does it
12:02:13 <pmetzger> http://www.io.com/~dierdorf/vi-emacs2.jpg
12:03:12 <pmetzger> monochrom: even there it depends on whether you have a good event library handy. I think some problems are more naturally stated in events and others in threads.
12:03:35 <pmetzger> I agree that it is less important then, but there are better and worse paradigms for particular problem sets
12:04:30 <pmetzger> In C or C++ though, using libevent vs. threads is the difference between handling 30,000 concurrent users and 30. it isn't even close.
12:04:44 <pmetzger> which is yet another reason those languages have serious issues. :(
12:04:46 <monochrom> I try to think so too, but then how to judge "naturally"? I still suspect "natural for the person" not "natural for the task", which again points to what the person learned first.
12:05:01 <applicative> pmetzger, it looks like this, on startup  http://imgur.com/8qPUY
12:05:12 <Zao> pmetzger: Creating non-green threads for small work is retarded on any platform.
12:05:31 <pmetzger> monochrom: I disagree. if the communication channel is rarely lossy, threads are more natural. if it is quite lossy, events are more natural. I don't think that is entirely a question of what you learned first.
12:05:32 <monochrom> however you could introduce a more objective measure such as code length
12:05:34 <Zao> You do want libevent/asio/etc. for small work units.
12:05:42 <BrianHV> if I'm in a StateT a IO b, and I have a function of type b -> State a [b], how do I evaluate the latter function in order to get at the [b]? I have the vague sense that I have to lift the function into the transformer somehow.
12:05:43 <pmetzger> and I can think of other examples, but I don't want to argue, this is not that important. :)
12:06:51 <hpc> :t runState -- BrianHV
12:06:51 <lambdabot> forall s a. State s a -> s -> (a, s)
12:06:59 <applicative> pmetzger, that people use something this ugly is really disturbing.  
12:07:13 <hpc> if we assume f :: b -> State a [b]
12:07:24 <pmetzger> applicative: eh, you can make the startup screen look any way you like.
12:07:35 <hpc> fst (runState (f originalB) originalState)
12:07:36 <applicative> pmetzger: of course.  check out the logo
12:07:39 <pmetzger> applicative: that's mostly that gross because of RMS.
12:07:54 <monochrom> oh, the emacs startup screen? XD
12:07:56 <applicative> pmetzger, don't worry, it keeps goig.
12:07:59 <applicative> going.
12:08:06 <BrianHV> hpc: so... I'll need to do something like  do { state <- get; runState f state } ?  I figured there'd be a way to "implicitly" pass the state through
12:08:21 <applicative> the start up screen is admittedly especially vomit making
12:08:25 * monochrom thought applicative is agreeing the C and libevent is ugly though fast
12:08:38 <tensorpudding> what's ugly about it?
12:08:38 <applicative> it shows the complete indifference of the users to anything real
12:08:46 <tensorpudding> is it the figurative gnu in the logo?
12:09:05 <pmetzger> there is no real way to argue that Emacs isn't a totally 1970s-centric editor. OTOH, vi is very similar. arbitrary keystrokes just aren't what the kids are into these days.
12:09:08 <tensorpudding> or the background color
12:09:16 <applicative> tensorpudding: yeah 
12:09:27 <hpc> BrianHV: i am assuming you want (b -> State a [b]) -> [b])
12:09:28 <tensorpudding> the logo is a bit wrecky
12:09:32 <applicative> pmetzger: they are both a menace
12:09:36 <kwantam> libevent is ugly from the point of view that organizing your code around events is horrific in anything but example chat servers
12:09:41 <pmetzger> applicative: it could be worse. you could have to watch RMS sucking on his hair on video during startup.
12:10:02 <applicative> i wouldn't care about that.
12:10:03 <kwantam> pmetzger, or doing soulja boy
12:10:05 <kwantam> :)
12:10:10 * monochrom wonders why libevent is so fast
12:10:15 <BrianHV> hpc: yeah
12:10:25 <kwantam> libevent is fast because epoll et al are fast
12:10:27 <KirinDave_> monochrom: Events go in, binary digits come out. Nobody can explain it.
12:10:36 <beastaugh> pmetzger: my problem with those kinds of editors is just that I don't want to have to sit there for a week learning all the damn commands before I'm even half as productive as I am with a more normal editor
12:10:39 <tensorpudding> emacs looks infinitely nicer now that they support xft
12:10:46 <hpc> KirinDave_: never a miscommunication
12:10:51 <tensorpudding> does no one remember the pre-23 days anymore?
12:11:05 <KirinDave_> Of course, get a 64-bit machine with a modern linux, and threading is pretty dang phenomenal now. I had a big only hissyfit about this earlier.
12:11:06 <monochrom> I rememer the 19 days
12:11:11 <kwantam> beastaugh, that's true of programming languages too, but generally a person is willing to put in the time to learn such thing.
12:11:12 <kwantam> s.
12:11:13 <KirinDave_> You hardly need libevent.
12:11:14 <ksf> xft?
12:11:14 <pmetzger> if you want to read about why libevent is so fast, I suggest reading all of Niels Provos papers on various unix multiplexing paradigms.
12:11:15 <monochrom> cursor keys did not work
12:11:24 <tensorpudding> x freetype
12:11:30 <KirinDave_> It's easy to have 500,000 threads, so long as most of them are blocking or idle.
12:11:33 <tensorpudding> the thing that makes fonts look bearable
12:11:37 <ksf> my terminal supports all kinds of font goodies, so my vim does, too. on top of that, there's gvim.
12:11:38 <pmetzger> beastaugh: I'm much faster on emacs than anyone using a GUI editor ever can be. probably the same for a good vi user.
12:11:56 <beastaugh> kwantam: that's a good point--why am I willing to learn Haskell but find the Emacs learning curve offputting?
12:12:02 <applicative> pmetzger: writing programs quickly is wrong.
12:12:03 <kwantam> KirinDave_, nptl is pretty awesome that way
12:12:13 <KirinDave_> Yeah. And under-appreciated.
12:12:13 <blackdog> KirinDave_: the post on HN about NIO and minecraft servers?
12:12:13 <kwantam> beastaugh, because you are of sound judgement and would prefer vi, presumably
12:12:14 <applicative> pmetzger: whatever speeds you up makes you stupid.
12:12:15 <kwantam> :P
12:12:20 <tensorpudding> emacs is not modern
12:12:21 <KirinDave_> blackdog: Yeap
12:12:22 <beastaugh> pmetzger: I'm completely willing to buy that claim, it's just the short-term productivity loss that has always put me off
12:12:28 <maurer_> pmetzger: While you may be faster, consider what you're doing if your text editor input rate is your limiting factor...
12:12:29 <hpc> beastaugh: also because haskell makes sense after you learn it
12:12:33 <tensorpudding> nor does it teach you much which is useful
12:12:47 <pmetzger> maurer_: ever try writing documentation? does doing it slowly make it better?
12:12:49 <KirinDave_> tensorpudding: But hey! Lexical scope in trunk. In 2011.
12:12:53 <ksf> otoh there's yi, which is an abbreviation for "eighty megabytes and continuous typechecking"
12:13:02 <pmetzger> beastaugh: some things are worth a little learning curve climb.
12:13:04 <blackdog> KirinDave_: these arguments looks so odd from the outside - as if inversion of control was rocket science, so the only way out is to write explicitly evented code
12:13:09 <applicative> the cult of speed in connection with emacs -- and all the people with damaged cartilage -- is the fundamental error
12:13:11 <maurer_> pmetzger: Documentation is a task which is not much helped by a good editor, as it is not structured data...
12:13:15 <tensorpudding> i've never written any elisp code which depended on lexical scope
12:13:18 <pmetzger> elisp is an abomination, it is true.
12:13:31 <pmetzger> against both god and man. on the other hand, it functions.
12:13:32 <KirinDave_> blackdog: It's weird because telling someone to write a server in raw NIO in 2011 is sorta like telling them to go fuck themselves.
12:13:32 <ksf> vimscript, too.
12:13:36 <ksf> but for other reasons.
12:13:38 <applicative> elisp, another proof of a sickness at the heart of it
12:13:39 <KirinDave_> 10 years ago we were doing better.
12:13:42 <tensorpudding> the standard style of writing it, it doesn't matter
12:13:46 <ksf> it's a perl-like adomination.
12:13:56 <crystal-cola> yeah elisp is one of the worst things ever
12:14:06 <kwantam> I wonder wtf rms was thinking, honestly
12:14:11 <Twey> *shrugs* Beats vimscript
12:14:13 <kwantam> because he was brought up on MIT scheme, which is a thing of beauty
12:14:16 <tensorpudding> is elisp really that bad?
12:14:19 <Twey> kwantam: Yeah :-\
12:14:22 <pmetzger> no, it is not scheme.
12:14:24 <Twey> tensorpudding: It's pretty bad
12:14:24 <tensorpudding> it performs its function
12:14:34 <pmetzger> in fact, he did elisp like it is because he didn't know about scheme
12:14:34 <Twey> It's kind of like… PHP
12:14:38 <KirinDave_> blackdog: I mean, that sort of paradigm is at the heart of things like iteratees, right?
12:14:38 <tensorpudding> i've used it, and i wasn't hating it that much
12:14:39 <Twey> With Lisp syntax
12:14:41 <pmetzger> if he had, he would have used lexical and not dynamic scope
12:14:43 <Twey> No, bad comparison
12:14:45 <Twey> BASIC maybe
12:15:09 <BrianHV> well, I got something to compile with StateT... too bad I don't have the hardware to test it on with me...
12:15:13 <Twey> kwantam: Umm, I don't think Scheme existed when RMS was growing up.
12:15:18 <blackdog> KirinDave_: yeah. i was thinking more of the rewrite of the GHC IO manager, though
12:15:22 <pmetzger> indeed it didn't.
12:15:23 <Twey> Wasn't that in the Days of the Many Lisps?
12:15:27 <KirinDave_> blackdog: Not familiar.
12:15:38 <ksf> KirinDave_, the paradigm at the heart of iteratees is oleg.
12:15:42 <KirinDave_> blackdog: But basically this idea that we all must write evented servers for performance is just silly.
12:15:51 <pmetzger> elisp was created in the early 1980s, when scheme was something he would have heard of but never have seen.
12:15:53 <kwantam> "brought up" in the sense of "working in the AI lab" but I suppose it was newish at the time
12:15:55 <hpc> ksf: oleg is a paradigm now? that explains...
12:15:58 <hpc> actually a lot
12:16:00 <KirinDave_> ksf: Did not parse, please restate.
12:16:09 <kwantam> scheme came about in 1975 and his office was basically down the hall from Steele and Sussman
12:16:16 <pmetzger> kwantam: yes.
12:16:29 <KirinDave_> Wasn't scheme a research tool at the time?
12:16:31 <pmetzger> kwantam: but he didn't really know what they'd done. remember he spent all his time keeping up with Symbolics.
12:16:36 <kwantam> yeah, for implementation in the metal
12:16:36 <blackdog> KirinDave_: some of johan tibbe and bryan o'sullivan's work - you can write code using lightweight haskell threads, and it's transformed into an event loop under the covers
12:16:41 <kwantam> pmetzger, good point
12:16:48 <ksf> KirinDave_,  http://c2.com/cgi/wiki?OlegKiselyov
12:16:48 <pmetzger> kwantam: he was trying to import every feature from Genera into the open source Lisp Machine OS
12:17:04 <blackdog> KirinDave_: ruby's my day job, so it's just as weird for me to see rails programmers getting all gushy over node.js
12:17:06 <ksf> he's the chuck norris of CS.
12:17:12 <KirinDave_> blackdog: Same.
12:17:15 <KirinDave_> blackdog: It's baffling.
12:17:17 <pmetzger> then he gave up and sent out that email around thanksgiving 1983 or 1984, I can't remember which
12:17:21 <kwantam> scheme evolved out of the dialect that Tom Knight was implementing in hardware IIRC
12:17:24 <monochrom> @quote oleg
12:17:24 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
12:17:30 <monochrom> @quote oleg
12:17:30 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
12:17:36 <pmetzger> scheme evolved out of planner.
12:17:41 <monochrom> hrm, not those
12:17:42 <Twey> Haha
12:17:46 <monochrom> @oleg
12:17:47 <lambdabot>  Defined.
12:17:49 <pmetzger> the dialect in hardware turned into Lisp Machine Lisp
12:17:56 <pmetzger> it was maclisp based, not scheme based.
12:17:56 <monochrom> nevermind
12:18:00 <KirinDave_> blackdog: As someone who's done a lot of erlang, it makes me mad as well
12:18:03 <pmetzger> there was a scheme chip designed around 1980.
12:18:26 <kwantam> "Design of LISP-based Processors, or SCHEME: A Dielectric LISP, or Finite Memories Considered Harmful, or LAMBDA: The Ultimate Opcode" by Steele and Sussman, AIM-514, 1979
12:18:27 <pmetzger> perhaps a bit later. it was someone's thesis.
12:18:34 <kwantam> Tom Knight
12:18:42 <pmetzger> that wasn't tom knight
12:18:42 <kwantam> the aforementioned designer of the Space Cadet keyboard
12:18:46 <pmetzger> that was steele and sussman.
12:18:48 <kwantam> his master's thesis was a lisp chip
12:18:50 <pmetzger> knight was working on CADR
12:18:58 <blackdog> KirinDave_: it's the new shiny. there are some good-ish reasons to write javascript on the server as well, i guess - you can move logic between client and server more easily
12:19:00 <pmetzger> oh? I thought CADR was all he was involved with.
12:19:08 <pmetzger> shows you what I remember.
12:19:16 <KirinDave_> blackdog: How often do people actually want to do that?
12:19:18 <kwantam> actually, no, you're right
12:19:20 <kwantam> CONS and CADR
12:19:29 <ksf> KirinDave_, each time you want to validate some input.
12:19:34 <pmetzger> thought that was what I remembered.
12:19:38 <KirinDave_> ksf: I disagree.
12:19:38 <blackdog> KirinDave_: but getting to manually convert your code to CPS?
12:19:46 <pmetzger> I didn't actually see an actual lisp machine until maybe 1986...
12:19:47 <KirinDave_> blackdog: Such luxury!
12:19:54 <kwantam> hey look, erudition appears http://not.meko.dk/MIT-LISP-MACHINE-tk-sm-79.pdf
12:19:57 <ksf> you do it client- side for usability, and server-side for security
12:19:59 <KirinDave_> ksf: We spent years breaking free from the RMI pre-shared-code model.
12:20:19 <KirinDave_> ksf: Going back there for marginal benefits that we could achieve in other, more robust ways is just not a good idea to me.
12:20:21 <dylukes> I wan't to try to write a low level language (C like) with continuations as a language feature.
12:20:27 <kwantam> I love that Marvin Minsky supervised a thesis on designing a lisp processor
12:20:35 <ksf> well, yes.
12:20:39 <dylukes> I'm not sure how well that will end up, if someone has any good paper's I'd love to see them.
12:20:42 <KirinDave_> ksf: JSON-RPC, for all its flaws, represents a huge step forward in real-world usability and deployability compared to say... CORBA.
12:20:44 <ksf> I'd also rather compile haskell down to javascript.
12:20:53 <kwantam> dylukes, just write it in C
12:20:58 <kwantam> you can pass continuations around as function pointers
12:20:58 <pmetzger> Minsky is sort of a renaissance man.
12:21:00 <kwantam> BE A MAN
12:21:06 <KirinDave_> Ha
12:21:07 <dylukes> kwantam: stack
12:21:15 <KirinDave_> setlongjmp
12:21:16 <dylukes> kwantam: I need to go stackless.
12:21:16 <blackdog> KirinDave_: it's useful for templates, validation, that sort of thing
12:21:17 <KirinDave_> BE A BIGGER MAN
12:21:20 <dylukes> KirinDave_: Nope, 
12:21:21 <kwantam> dylukes: trampoline baby
12:21:22 <ksf> dylukes, try the original io, that out of "advanced programming language design"
12:21:22 <dylukes> ucontext
12:21:27 <pmetzger> kirindave_: first you mention rmi, then corba. you trying to make me die of a stroke?
12:21:32 <monochrom> be an overweight man
12:21:34 <ksf> there's one or two interpreters for it, one in ml, one in haskell
12:21:35 <dylukes> ksf: what?
12:21:36 <KirinDave_> pmetzger: I have been to the battlefield, man.
12:21:38 <blackdog> but you see things like mustache in rubyland anyway which let you share them.
12:21:39 <ksf> the ml one is called amalthea
12:21:43 <KirinDave_> pmetzger: I do not want to go back.
12:21:48 <dylukes> Ah, amalthea!
12:21:52 <KirinDave_> blackdog: I just think that's of marginal benefit compared to the cost.
12:21:53 <hpc> how is longjmp implemented? i understand processors have a fairly small limit on jump lengths
12:21:55 <dylukes> The name of my favorite pizza restaurant.
12:21:57 <pmetzger> stackless C would be so bizarre.
12:22:02 <pmetzger> longjmp is really simple.
12:22:03 <dylukes> It's right outside Kymi.
12:22:08 <dylukes> pmetzger: but it won't work haha
12:22:13 <ksf> http://hackage.haskell.org/package/Ganymede-0.0.0.5
12:22:15 <pmetzger> setjmp just saves the processor state including program counter.
12:22:15 <ksf> there it is.
12:22:16 <dylukes> pmetzger: when you longjmp you invalidate the stack
12:22:20 <beastaugh> isn't the reason Rails programmers are into Node that it lets them write performant code in a dynamic language they're already familiar with?
12:22:21 <pmetzger> longjmp just reloads.
12:22:21 <dylukes> you can't longjmp back
12:22:30 <kwantam> hpc, on most processors longjmp is implemented the way it is because the program counter can't be loaded in one instruction
12:22:35 <pmetzger> you can't longjmp to something that has exited.
12:22:38 <dylukes> pmetzger: way too restricted. setjmp corrupts the stack.
12:22:47 <KirinDave_> beastaugh: Well there is a big pile of fail in the ruby community's court that leads people to Node.
12:22:50 <dylukes> the *context family of functions is how it'd be done.
12:23:01 <KirinDave_> beastaugh: But they get benefits in speed at the cost of a positively tortured model for actual servers.
12:23:03 <dylukes> Anyways, I want to write a C-like language, in which every function is a coroutine.
12:23:05 <hpc> pmetzger: oh, that's kind of cool
12:23:11 <dylukes> Just for kicks :)
12:23:11 <pmetzger> I was mentioning two different things. saying "Stackless C would be so bizarre" was distinct from my mention of setjmp/longjmp
12:23:17 <blackdog> KirinDave_: they're so tired of people kicking sand in their faces for being a slow language:)
12:23:23 <kwantam> but you were not asking about the same kind of longjmp I was answering about
12:23:23 <dylukes> pmetzger: stack less C is basically what I want to try to write haha
12:23:26 <KirinDave_> Which is fair.
12:23:37 <kwantam> whoops! :)
12:23:38 <pmetzger> one would need a garbage collected C to do stackless C.
12:23:51 <kwantam> or a sufficiently spaghetti-like set of macros
12:23:53 <dylukes> pmetzger: Simple garbage collection maybe.
12:23:55 <pmetzger> because keeping track of continuations for explicit destruction would drive a man mad.
12:23:59 <hpc> or a manual stack
12:24:06 <kwantam> pmetzger: remember, the mantra of this new language is now BE A MAN
12:24:17 <kwantam> in fact the language is called AMAN
12:24:20 <pmetzger> I'm officially a mouse.
12:24:22 <beastaugh> KirinDave_: sure, but people are already used to having to "manually convert their code to CPS" if they write JS anyway
12:24:33 <kwantam> fortunately, nature does garbage collection for mice
12:24:38 <kwantam> whereas men have to do it themselves
12:24:43 <hpc> kwantam: the syntax is comprised entirely of lines from Mulan?
12:24:49 <kwantam> oh god
12:24:54 <kwantam> what would make you say such a thing
12:24:58 <kwantam> that is simply cruel
12:24:58 <hpc> :D
12:25:01 <KirinDave_> beastaugh: Right. So why go there?
12:25:07 <monochrom> "be a bigger man" http://www.thelamest.com/wp-content/uploads/2010/05/fat-man-at-computer.jpg
12:25:10 <kwantam> perhaps you'll implement the first compiler for it in malbolge
12:25:15 <KirinDave_> beastaugh: The answer: because most of them don't know better at all. :\
12:25:21 <pmetzger> no, simply cruel is listening to RMS sing this: http://en.wikipedia.org/wiki/Free_Software_Song
12:25:39 <pmetzger> click on "why cooperation with rms is impossible, part 3"
12:25:43 <KirinDave_> beastaugh: And it's not even clear to me that node's v8 engine is all that performant in high-load environments. 
12:25:43 <c1de0x> pmetzger i once wrote a llvm transform to essentially compile a c program into 'stackless' c
12:25:52 <dylukes> c1de0x: I'd love to see that heh.
12:26:06 <beastaugh> KirinDave_: I suppose what I'm getting at is that people don't see writing code in that way as a cost
12:26:07 <c1de0x> yeah. i can only show you the product ;)
12:26:12 <KirinDave_> beastaugh: Nearly every benchmark you can find is either google's intended usecases, or someone on a macbook with ab on the same machine as the framework with -n defaulting to 1.
12:26:16 <kwantam> hey speaking of node and people not knowing any better
12:26:19 <beastaugh> KirinDave_: and the facts never get in the way of a good story
12:26:30 <KirinDave_> beastaugh: Right, but that's the problem. They seriously do not realize how terribly bad it is.
12:26:48 <KirinDave_> beastaugh: And the arguments for 1-thread-evented are themselves being invalided by modern OS threading implementations.
12:26:55 <kwantam> I think I might "need" to extend Warp or something Warp-like with Socket.IO support
12:27:12 <kwantam> is anyone aware of such a project already going on that my google-fu has missed?
12:27:13 <KirinDave_> Node.js's popularity is basically an artifact of a lot of python and ruby programers hearing "evented is fast" echoing through the empty halls.
12:28:03 <beastaugh> as usual, a sweeping unqualified statement turns out to be wrong :)
12:28:05 <kwantam> it's perplexing to me that Pythonistas, who are so proud of their beautiful code, can look at Node spaghetti and not be unsettled.
12:28:24 <KirinDave_> kwantam: They are a confusing bunch.
12:28:27 <hpc> kwantam: beautiful spaghetti
12:28:38 <KirinDave_> kwantam: I meet many of them who say, "Javascript is fine so long as you avoid the lambdas."
12:28:47 <hpc> js has lambdas?
12:28:52 <blackdog> KirinDave_: there is the language familiarity issue. I'm working in an iphone dev shop, and we're looking at writing some stuff that might need to be high load on the server side. I could pretty easily do it in yesod, but the other programmers are likely to baulk.
12:28:57 <KirinDave_> I usually have to bite my clenched fist to shake myself out of the blood-boiling rage.
12:28:58 <hpc> oh duh, nvm
12:29:05 <KirinDave_> blackdog: Fire them.
12:29:11 <KirinDave_> :D
12:29:24 <tjgillies> is a named anonymous function considered a lambda?
12:29:25 <KirinDave_> blackdog: I'm tired tho of programmers who seem to think learning new things is not part of their job.
12:29:27 <beastaugh> blackdog: so, what, you'll end up writing it in Java?
12:29:36 <tjgillies> like foo = function() { console.log('bar') }
12:29:43 <BrianHV> is there a way to clean up the syntax on this function?  it seems superfluous to create an inner function just to use guards.  http://hpaste.org/45923/verbose_guard_syntax
12:29:44 <KirinDave_> blackdog: At least there is Scala+Akka now. 
12:29:46 <kwantam> I think "avoid the lambdas" really means "avoid the anonymous functions"
12:29:54 <hpc> tjgillies: "function() {...}" is the lambda
12:30:01 <KirinDave_> kwantam: Correct.
12:30:06 <beastaugh> blackdog: (where it takes five times as long, is probably slower, and will be just as bad for people to maintain)
12:30:08 <KirinDave_> But yeah, functions in js can be anonymous.
12:30:09 <blackdog> beastaugh: would hope to avoid it.
12:30:09 <KirinDave_> So...
12:30:09 <hpc> tjgillies: in the same way that "id = \x -> x" has a lambda
12:30:21 <tjgillies> hpc: gotcha, thnx
12:30:23 <thoughtpolice> i too do not understand the obsession people have with this node.js thing. apparently people are really freaking out about how awesome it is to write your code in CPS manually
12:30:24 <blackdog> will probably prototype in yesod at least.
12:30:39 <thoughtpolice> i mean, i think i understand what node *does*, i just don't understand why it's good at it or whatever.
12:30:49 <KirinDave_> It just has a good interpreter
12:30:55 <KirinDave_> And it's very good for UX code.
12:31:13 <KirinDave_> Evented systems are GOOD there because the event model lends itself to explicit CPS.
12:31:14 <hpc> thoughtpolice: because in the group of people that use node.js, CPS is a new thing?
12:31:18 <tjgillies> thoughtpolice: its a simple language, which makes it accessible. just looking at haskell makes me feel like i need a PhD
12:31:24 <Zao> thoughtpolice: Even more awesome is that you're limited to around 1GB of heap, as it uses int everywhere for sizes, and isn't 64-bit safe.
12:31:26 <KirinDave_> tjgillies: There is that. 
12:31:34 <thoughtpolice> Zao: :/
12:31:38 <beastaugh> tjgillies: I don't actually agree with that
12:31:40 <hpc> tjgillies: i don't even have a bachelors :P
12:31:41 <thoughtpolice> hpc: fair enough
12:31:42 <KirinDave_> tjgillies: But it's not like Clojure or ZGroovy are that inaccessible. 
12:31:49 <beastaugh> tjgillies: it's a *familiar* language
12:31:54 <thoughtpolice> tjgillies: also a fair point!
12:32:01 <monochrom> just 40 years ago, functional programmers found it freaking awesome to write CPS by hand, too
12:32:08 <kwantam> haha
12:32:11 <hpc> monochrom: "just"?
12:32:16 <tjgillies> lol
12:32:16 <beastaugh> tjgillies: but the semantics of JavaScript are at least as confusing as those of Haskell
12:32:20 <c_wraith> Strange.  I find haskell much easier to read than javascript. :)
12:32:26 <KirinDave_> monochrom: So it's like the bellbottom pants of programming?
12:32:33 <thoughtpolice> monochrom: does that make those people hipsters? writing CPS code manually before it was cool, and all
12:32:41 <tjgillies> this channel is biased though ;)
12:32:53 <hpc> thoughtpolice: if that's what being a hipster is, everyone here is a hipster
12:32:55 <kwantam> thoughtpolice, it's a little something called evented programming, you've probably never heard of it.
12:33:03 <hpc> or potential future-hipster
12:33:04 <kwantam> no big deal, I was there when it got started
12:33:11 <kwantam> back before it got all mainstream
12:33:14 * kwantam tosses hair
12:33:19 <tjgillies> lol
12:33:20 <thoughtpolice> SCUSE ME BRO, IMMA GO CLOUD COMPUTE SOMEWHERE ELSE THEN
12:33:32 <c_wraith> tjgillies: not necessarily.  It's much easier to read serial code than event-driven code, and js tends to be event-driven.  haskell hides the event system behind the scenes, and presents a serial interface.
12:33:35 <monochrom> just 10 years ago, a group of java programmers also found inversion of control freaking awesome
12:33:38 <kwantam> naw don't be a hater here have a Miller High Life
12:33:56 <tjgillies> haskell is event driven?
12:34:02 <kwantam> forkIO
12:34:03 <kwantam> yes
12:34:05 <c_wraith> tjgillies: well, haskell IO is
12:34:07 <thoughtpolice> tjgillies: GHC actually uses event-based IO under the hood
12:34:09 <kwantam> behind the scenes
12:34:16 <pmetzger> speaking of clouds, AWS went down today
12:34:21 <thoughtpolice> and everything is 'magically' serial from the perspective of the programmer. it's a pretty nice model :)
12:34:28 <tjgillies> pmetzger: http://ec2disabled.com/
12:34:40 <Zao> pmetzger: I blame Notch.
12:34:48 <hpc> thoughtpolice: it really is
12:34:55 <kwantam> I suppose from the point of view of a client-side JS programmer, Node.js is actually exactly the same paradigm they're used to on the client side
12:35:03 <hpc> i enjoy writing IO-heavy stuff more in haskell than in any other language
12:35:05 <monochrom> centuries ago, mathematicians found the pigeon-hole principle freaking awesome. now see Dijkstra's http://www.cs.utexas.edu/users/EWD/transcriptions/EWD10xx/EWD1094.html
12:35:05 <Twey> blackdog: Do it in Yesod on your own time, then unveil it to the boss. }:-)
12:35:15 <beastaugh> kwantam: that was pretty much my point earlier, yes
12:35:24 <kwantam> yeah, beastaugh, I'm slow ;)
12:35:33 <hpc> monochrom: that's not fair; it really is kind of awesome
12:35:46 <hpc> it makes a fair bit of discrete math really easy
12:35:47 <thoughtpolice> hpc: ISTR some paper discussing this, a built-in compiler transformation that can take synchronous, serial code and transform it into asynchronous, event driven code in the background. i believe the paper made the claim it was a clearly superior approach to others
12:36:01 <blackdog> Twey: long list of projects to finish before working for the boss in my spare time becomes an attractive prospect:)
12:36:09 <thoughtpolice> somewhere on LtU
12:36:11 <thoughtpolice> maybe i can still find it
12:36:14 <kwantam> thoughtpolice, there's an Odersky paper that might fit that bill
12:36:21 <monochrom> generally, if you show people a method to do things so they feel they are geniuses, they will find that the method is freaking awesome. this includes unnecessarily difficult methods, yes
12:36:30 <thoughtpolice> kwantam: name? i may recognize it if i see it
12:36:37 <kwantam> Trying to remember it
12:36:41 <kwantam> I was sure it was in my browser cache
12:36:43 <beastaugh> kwantam: I think a large part of the new Node constituency is made up of frontend programmers who have been told for years that they're not real programmers, and that JavaScript is not a proper language
12:36:47 <tjgillies> hrm interesting been reading 'learn you a haskell' and was thinking IO *wasn't* haskell's strong suit, i'll have to look into it more
12:36:47 <proq> evented programming is worth bragging about? O_o
12:37:02 <beastaugh> kwantam: and so Node is their big chance to show people they can program too
12:37:15 <hpc> tjgillies: it really isn't, but that doesn't mean it sucks at it
12:37:16 <kwantam> proq, "I had to think really hard to do this, therefore it must have been good work"
12:37:41 <Twey> Wow, Dijkstra writes ‘rôle’
12:37:43 <kwantam> beastaugh, I hope that they don't have such an inferiority complex that they'd take on flagellation and compilation as penance
12:37:45 <hpc> it just doesn't fall under convenient theoretical...stuff
12:37:48 <Twey> *bookmarks*
12:37:52 <monochrom> no, hpc, "minimum <= arithmetic mean <= maximum" is the freaking awesome one, and easier. see the Dijkstra article. see also my file:///home/trebla/public_html/homework/pigeonhole.html
12:37:52 * hpc forgets the word he is looking for
12:38:16 <hpc> monochrom: oh, yay
12:38:32 <monochrom> oops, http://www.vex.net/~trebla/homework/pigeonhole.html
12:38:35 * hpc forgets how much common sense is formalized as powerful theorems
12:38:37 <Twey> monochrom: Wow, that's a cool file!  ;)
12:38:38 <Twey> Heh.
12:38:39 <beastaugh> kwantam: indeed, let's hope not!
12:39:15 <beastaugh> kwantam: but when Node was making the rounds of JS user groups, quite early on, the audience (as you'd expect, primarily frontend programmers) were very excited
12:39:40 <beastaugh> so while I'm exaggerating a bit, I think there's at least a kernel of truth there
12:40:14 <tjgillies> is haskell a good web dev language, or is it better for more math processing stuff?
12:40:25 <blackdog> tjgillies: it's a good language for hard problems
12:40:37 <Cale> tjgillies: It's general purpose, people are using it for both of those things
12:40:42 <hpc> tjgillies: there are some AWESOME web dev libraries
12:40:49 <blackdog> there's some work on web dev frameworks, but they're not as mature as rails, say
12:40:50 <kwantam> tjgillies, I have been doing a lot of research lately on the web dev libraries, and they are excellent
12:41:04 <Twey> Which ones do you guys consider particularly excellent?
12:41:15 <blackdog> they're probably better quality :) but all the little bits around the sides you get with rails are missing
12:41:35 <hpc> blackdog: i would rather have an awesome burger than awesome fries
12:41:43 <kwantam> in my opinion, Yesod is a very nice framework
12:41:54 <thoughtpolice> yesod seems to be progressing at a frightening pace, honestly
12:41:59 <c1de0x> Yesod is a foundation
12:42:00 <c1de0x> :)
12:42:04 <kwantam> indeed
12:42:12 <thoughtpolice> snoyman is doing a great job leading it as a project, and he's already using it in real stuff
12:42:15 <c1de0x> what? more hebrew speakers?!?!
12:42:16 <c1de0x> :)
12:42:17 <Cale> Yesod looks cool, but it uses so much TH that it seems bizarre and confusing to me.
12:42:17 * BrianHV is still curious what happened to the yesod docs site
12:42:30 <kwantam> c1de0x, just about >< that much
12:42:32 <geekosaur> yepyep :)
12:42:38 <c1de0x> lol
12:42:38 <thoughtpolice> Cale: michael gets this complaint all the time. it seems to be, by far, the biggest complaint with yesod there is
12:42:40 <aristid> Cale: only in his special languages, tho.
12:42:42 <blackdog> hpc: sure. just prepping tjgillies for a slightly bumpy ride.
12:42:44 <kwantam> but template haskell is amazing
12:42:52 <aristid> it doesn't use it for normal stuff
12:42:55 <kwantam> I'll just come out and say it
12:42:59 <kwantam> I love template haskell
12:43:02 <kwantam> my name is kwantam
12:43:06 * kwantam cries
12:43:07 <thoughtpolice> hah
12:43:09 <aristid> and having a special language for routing does not seem like a big problem to me
12:43:17 <hpc> tjgillies: haskell cgi has a very different style from typical cgi
12:43:24 <blackdog> hpc: and a lot of it is just the availability of services. with heroku, i can get a site online in five minutes. all the burrs are just polished away.
12:43:27 <c1de0x> template haskell sounds uber difficult to grok.
12:43:33 <aristid> c1de0x: not at all.
12:43:33 <thoughtpolice> yeah, routing and hamlet templates seem to be about 90% of the TH-based code you'd look at for yesod
12:43:39 <aristid> it is not complex.
12:43:45 <thoughtpolice> even then, in reality, you normally put hamlet templates into their separate files
12:43:46 <kwantam> at its base, if you can understand the AST of an expression, you can work with template haskell
12:43:51 <thoughtpolice> so it seems to mostly just be the routing issue
12:43:54 <c1de0x> linky?
12:43:54 <thoughtpolice> oh! and persistent
12:44:03 <aristid> thoughtpolice: persistent has a QQ too?
12:44:12 <aristid> well i'm not sure if i would use persistent either way
12:44:20 <aristid> and you don't have to
12:44:29 <Cale> The special languages needed more formal documentation last time I looked at it.
12:44:32 <thoughtpolice> aristid: http://www.yesodweb.com/book/persistent#codegen
12:44:38 <Cale> He's apparently writing a book about Yesod, which should help
12:44:49 <thoughtpolice> aristid: oh yeah, persistent is totally optional
12:44:50 <aristid> Cale: lack of documentation is generally a big problem in the haskell world :/
12:45:02 <thoughtpolice> i believe michael said he doesn't even use it in like, half of the projects he has deployed with yesod
12:45:45 <kwantam> the biggest issue I have right now with Yesod is that WAI seems not at all built to handle extension to websockets, which I want
12:45:57 <aristid> from what i've seen, yesod is the nicest web framework in the haskell world so far
12:46:16 * hackagebot unboxed-containers 0.0.2.1 - Self-optimizing unboxed sets using view patterns and data families  http://hackage.haskell.org/package/unboxed-containers-0.0.2.1 (EdwardKmett)
12:46:23 <beastaugh> blackdog: clearly what the world needs is Heroku for Haskell web projects
12:46:49 <kwantam> jericho.com : a base for your Yesod. No trumpets allowed.
12:46:59 <blackdog> beastaugh: that would be awesome:) i'd launch it myself if i thought i'd get users...
12:47:15 <thoughtpolice> kwantam: websockets were also disabled recently in a large majority of browsers, yes? (just curios, i remember that hampering my curiosity to play with them)
12:47:21 <kwantam> yes
12:47:24 <kwantam> basically everything but Chrome
12:47:46 <beastaugh> someone (sorry, can't remember who) actually suggested this a few weeks ago on #snapframework
12:47:53 <kwantam> really what I want to do is implement a Socket.IO-compatible server
12:47:53 <c1de0x> http://www.haskell.org/bz/th3.htm 404 :(
12:48:08 <kwantam> c1de0x, archive.org still has it
12:48:29 <kwantam> I had to pull it up the other day
12:48:37 <kwantam> was hacking on this http://hpaste.org/45893/
12:48:41 <c1de0x> someone should fix it
12:48:58 <c1de0x> why?
12:49:02 <cheater99> what does it mean that a set is unboxed?
12:49:04 <kwantam> for fun
12:49:05 <c1de0x> why on earth would a person do that?
12:49:12 <tjgillies> kwantam: yeah thats a good cause, so far the only good socket.io servers are nodejs
12:49:13 <kwantam> funner than fun
12:49:41 <cheater99> beastaugh: what is heroku?
12:49:43 <kwantam> tjgillies, nope, gevent and tornado both handle it, as do some alpha and beta quality servers in Java and others
12:49:59 <tjgillies> kwantam: oh, nice
12:50:20 <kwantam> tjgillies, at the moment I'm working with gevent because tornado has the same manual continuation passing style that I dislike in Node
12:50:28 <beastaugh> cheater99: it's a hosting service for Ruby web applications
12:50:33 <beastaugh> http://www.heroku.com/
12:50:40 <tjgillies> kwantam: whats an example of non-manual cps?
12:50:49 <thoughtpolice> kwantam: http://hackage.haskell.org/packages/archive/websockets/0.3.0.0/doc/html/Network-WebSockets.html
12:50:50 <cheater99> beastaugh: ok.
12:50:54 <thoughtpolice> in case you havent seen it
12:50:56 <tjgillies> beastaugh: have you seen dotcloud?
12:50:58 <cheater99> beastaugh: yeah, it would be fun
12:51:19 <tjgillies> its like heroku but for php/node/java etc
12:51:39 <beastaugh> tjgillies: no, I haven't
12:51:44 <kwantam> tjgillies, I guess "manual callback insertion style" is what I prefer, but certainly a compiler can transform code to continuation passing style
12:51:46 <beastaugh> tjgillies: http://matt.might.net/articles/cps-conversion/ (on CPS conversion)
12:51:49 <cheater99> beastaugh: heh  heroku.com is broken
12:52:02 <beastaugh> cheater99: that's the AWS outage I presume
12:52:09 <cheater99> the aws outage?
12:52:14 <cheater99> there's some huge aws outage?
12:52:17 <beastaugh> yeah
12:52:40 <beastaugh> http://status.aws.amazon.com/?a
12:52:41 <kwantam> the other big advantage of Python is that I can still write stuff in Haskell and dynamically link it in
12:52:46 <kwantam> ditto C or whateer
12:52:47 <tjgillies> cheater99: http://ec2disabled.com/
12:52:48 <kwantam> whatever, tht is
12:52:49 <thoughtpolice> http://status.aws.amazon.com/
12:52:54 <thoughtpolice> north virginia seems to be hosed atm
12:53:43 <kwantam> it seems like very few people like to do it, but making dynamically loadable modules in other languages and gluing them together in Python is pretty nice.
12:54:10 <kwantam> and, at least for the moment, Node very much doesn't like doing that
12:54:18 <kwantam> (at least, it's _really_ poorly documented)
12:55:02 <kwantam> actually, no, I take that back: it's impossible to do dynamic loading; you have to compile add-ons into node to use them.
12:55:21 <beastaugh> kwantam: yes, the add-ons are painful to use
12:55:35 <beastaugh> they've been appallingly documented since the start
12:56:34 <beastaugh> looking at the docs, it doesn't seem as though that has improved since last year
12:56:52 <kwantam> iirc the docs basically say "look at how we implemented the postgres add-on, and gfy"
12:57:54 <beastaugh> pretty much
13:02:53 <beastaugh> anyone have any views on the best place to start in terms of writing an interpreter for the typed lambda calculus? e.g. books that might sketch implementations
13:03:22 <beastaugh> just for very simple languages, like the system T in Proofs and Types
13:04:00 <dschoepe> beastaugh: Types and Programming Languages has implementations in ML for various languages
13:04:10 <djahandarie> Are you okay with higher order abstract syntax (HOAS)?
13:04:14 <dschoepe> e.g. System F, simply typed lambda calculus etc
13:05:15 <cheater99> beastaugh: do you know how django's app system works?
13:05:20 <pmetzger> TAPL is certainly a good place to go.
13:05:22 <beastaugh> djahandarie: I only have a surface familiarity, but if it's necessary to learn it that won't be a problem
13:05:30 <cheater99> beastaugh: i think it would be interesting to sort of fuse these two ideas together
13:05:35 <beastaugh> dschoepe: thanks, I'll check those out
13:05:49 <beastaugh> I actually have a copy of TAPL, just haven't had time to get too far into it yet :)
13:06:30 <beastaugh> cheater99: nope, no idea, I don't know anything about Django
13:06:39 <cheater99> beastaugh: let's talk in #snapframework
13:06:57 <kwantam> perhaps I'll observe as well
13:09:45 <djahandarie> beastaugh, well. With HOAS you are 'barely' writing an interpreter
13:19:34 <jmcarthur> HOAS doesn't necessarily mean you are just newtyping haskell expressions
13:20:04 <djahandarie> True. I was specifically talking about that use of it.
13:25:16 <beastaugh> djahandarie: I'll have a look at HOAS, thanks
13:26:03 <djahandarie> beastaugh, it usually ends up being nicer in dependently-typed languages though
13:26:45 <beastaugh> so I should be writing it in Agda?
13:27:22 <djahandarie> If you are open to that possibility, I think it would be fun. I was actually writing a tutorial for doing this exact thing, but my motivation to do so has disappeared! :p
13:27:50 <djahandarie> If you want the start of a tutorial which doesn't really go into the Agda... http://althack.org/stlc.html
13:28:17 <beastaugh> thanks
13:28:37 <beastaugh> I'm running a reading group on type theory, so I thought it might be nice to actually write implementations for some of these systems
13:31:20 <ksf> you could do it in idris, allthewhile giving it the manpower and love it needs
13:31:42 <ksf> nothing deeply theoretical afaiu
13:32:18 <ksf> unlike agda, you can use proof tactics in idris.
13:34:31 * hackagebot base-unicode-symbols 0.2.1.5 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.1.5 (RoelVanDijk)
13:44:00 <BrianHV> if I'm in a StateT, is there a better way of evaluating a State function than this?  do {             originalState <- get; let (convertedEvs, newState) = runState (mapM converter evs) originalState; put newState
13:44:58 <ksf> that looks suspiciously like >>=
13:45:01 <c_wraith> Not really.  You could write a combinator that would handle most of the details, though.
13:45:05 <c_wraith> ksf, m is different
13:45:35 <ksf> well, but the state is the same
13:45:38 <BrianHV> interesting. I figured that would be a fairly common situation...
13:45:43 <ksf> so both can arguably be rolled into one
13:45:47 <c_wraith> It's really not that common.
13:46:12 <BrianHV> so now I feel like I'm doing something wrong. :)
13:46:17 <c_wraith> it just doesn't fit the type signature for >>=
13:47:25 <BrianHV> in my mind, it's just like calling a pure function from impure code... except in this case, I'm calling pure state code from IO-infused state code
13:47:40 <monochrom> change the type signature of converter to be very general. then you just need mapM converter evs
13:48:13 <BrianHV> intriguing proposal
13:48:24 <c_wraith> that'll work so long as you're using mtl2 or transformers, where State is StateT Identity
13:48:43 <c_wraith> in mtl1, State and StateT were entirely different types.
13:49:13 <monochrom> no, not relying on relation or lack-of-relation between State and StateT
13:49:28 <monochrom> well, apart from them both being MonadState Something
13:50:13 <monochrom> converter :: (MonadState Something m) => IDon'tKnow -> m WhateverIt'sCalled
13:51:46 <monochrom> actually it's "convertedEvs <- mapM converter evs" if you care about that
13:52:29 <mm_freak> BrianHV: i think, this is quite easy to do, if you don't use the monadic combinators, but write the state functions directly
13:54:13 <mm_freak> State $ return (mapM converter evs)  -- something like that, but i haven't tested the code
13:54:23 <mm_freak> s/State/StateT/
13:54:38 <mm_freak> uhm, no
13:54:47 <mm_freak> StateT $ return . mapM converter evs
13:54:48 <mm_freak> rather this
13:56:12 <mm_freak> BrianHV: or, well, monochrom's proposal, which i have read only now =)
13:57:15 <BrianHV> I like monochrom's idea in principle... can't get it to compile, but I'm sure that's my fault
13:57:36 <c_wraith> It needs the FlexibleContexts extension
13:57:58 <c_wraith> Though it would tell you if that was the problem
13:58:12 <mm_freak> BrianHV: you can start with writing converter as StateT
13:58:16 <mm_freak> instead of MonadState
13:58:35 <mm_freak> nowadays there is little reason to write State computations
14:00:03 <monochrom> actually since converter does not suffer from the mononomnomnom restriction, giving it absolutely no type signature already generalizes it
14:00:03 <BrianHV> this won't compile:
14:00:05 <BrianHV> asdf :: (MonadState a ms) => (Int -> ms [Int]) -> StateT a IO ()
14:00:05 <BrianHV> asdf converter = do { convertedEvs <- mapM converter [1..5]; return () }
14:01:06 <c_wraith> oh.
14:01:29 <c_wraith> that's keeping the same type error you had before.
14:02:01 <c_wraith> Oh, no it's not
14:02:11 <mm_freak> BrianHV: (MonadState a m, MonadIO m) => (Int -> m [Int]) -> m ()
14:02:43 <mm_freak> BrianHV: but that type signature doesn't make a lot of sense to me
14:02:50 <mm_freak> is 'converter' actually using the state?
14:03:02 <BrianHV> yes
14:03:07 <mm_freak> how?
14:03:09 <mm_freak> modify id?
14:03:22 <mm_freak> because that's the only possibility with that type signature =)
14:03:53 <monochrom> I think you should paste more completely
14:04:07 <monochrom> I am also not convinced that converter should be (Int -> ms [Int]) as opposed to (Int -> ms Int)
14:04:08 <BrianHV> well.  Int was a placeholder.
14:04:36 <BrianHV> what you recommended compiles. applying it to the real code now.
14:07:42 * monochrom should just give up answering help questions
14:08:38 <ddarius> Probably.
14:08:42 <BrianHV> monochrom: you've been very helpful.
14:08:49 <monochrom> it's an impossible dilemma. (asker needs help) iff (asker underestimates how much context to consider and therefore disclose)
14:09:19 <mm_freak> monochrom: don't worry
14:09:21 <gwern> > 214 - 65
14:09:22 <lambdabot>   149
14:09:27 <mm_freak> it compiles, and it's haskell
14:09:46 <mm_freak> it follows naturally that the code works now
14:10:27 <gwern> mm_freak: it's a valid logical proof, yes, but is it a proof of the theorem you want? :)
14:11:12 <ddarius> gwern: Programmers care about the particular proofs.
14:11:23 <ddarius> pi :: Double; pi = 3.0
14:12:10 <BrianHV> here's my current hangup. I believe this includes everything relevant, and is the actual code: http://hpaste.org/45924/monadstate_error
14:12:55 <monochrom> what is line 78?
14:13:23 <BrianHV> monochrom: the midiInteract type signature
14:14:34 <mm_freak> gwern: sure
14:14:38 <mm_freak> Dynamic -> Dynamic
14:17:47 <eternalmatt> take 3 [pi..]
14:17:54 <eternalmatt> :(
14:19:12 <dons> > take 3 [pi .. ]
14:19:13 <lambdabot>   [3.141592653589793,4.141592653589793,5.141592653589793]
14:19:13 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
14:19:30 <eternalmatt> take 4 [pi .. ]
14:19:34 <eternalmatt> oh
14:19:41 <eternalmatt> > take 3 [pi..]
14:19:42 <lambdabot>   [3.141592653589793,4.141592653589793,5.141592653589793]
14:19:44 <dons> ?
14:19:55 <eternalmatt> just testing the bot. I'm new here.
14:19:58 <dons> welcome!
14:20:04 <eternalmatt> ty
14:20:13 <eternalmatt> I'm on chrome os so I have no way to test scripts
14:20:16 <dons> we use "bird style" literate programming in the channel. so code must be prefixed with '> '
14:20:25 <ion> tryhaskell.org
14:20:25 <dons> use http://tryhaskell.org/ perhaps?
14:20:35 <djahandarie> eternalmatt, you can use tryhaskell as just mentioned, or /q lambdabot
14:20:44 <eternalmatt> thanksah
14:20:49 <eternalmatt> thanks all!
14:20:56 <djahandarie> /msg lambdabot > take 3 [pi ..]
14:21:01 <shachaf> \begin{code} 0 \end{code}
14:21:04 <shachaf> Bah.
14:21:13 <monochrom> BrianHV: here you have two choices
14:21:18 <djahandarie> shachaf, hey, no LaTeX allowed.
14:21:21 <monochrom> first choice: (Show a) => a -> (PMEvent -> StateT a IO [PMEvent]) -> IO ()
14:21:25 <ion> shachaf: 0
14:21:26 <aristid> eternalmatt: can't you boot linux on the chrome os device?
14:21:36 <monochrom> second choice: turn on RankNTypes and (Show a) => a -> (forall m. (MonadState a m) => PMEvent -> m [PMEvent]) -> IO ()
14:22:10 <eternalmatt> aristid: that is possible, but I haven't tried it yet
14:22:15 <BrianHV> I like the second better.  trying.
14:22:43 <eternalmatt> When I get a break, I'll put ubuntu on here
14:23:01 <ion> I was under the impression ChromeOS *is* based on Linux.
14:23:16 <monochrom> the second choice is the most specialized (the least generalized)
14:23:21 <shachaf> ion: So is Android. That doesn't mean it runs GHC.
14:23:42 <tromp_> everything i type in http://tryhaskell.org/  gives Terminated!
14:23:44 <BrianHV> it is?
14:23:53 <hpc> tromp_: are you giving it IO stuff?
14:23:57 <BrianHV> I mean, I guess that's ok... I don't want my converter to be in IO
14:24:03 <tromp_> no, just numbers
14:24:05 <monochrom> yes. general means return type more general and/or parameter type more special
14:24:10 <hpc> oh
14:24:14 <hpc> um
14:24:17 <monochrom> contravariant thing, if you have heard of that
14:24:21 <tromp_> oh, now it works?!
14:24:24 <hpc> refresh
14:24:25 <hpc> oh
14:24:33 <BrianHV> monochrom: heard of it. haven't gained an intuition for it yet.
14:24:39 <hpc> yeah, temporary server outage i think
14:25:30 <eternalmatt> ChromeOS is running on extremely stripped version of linux. gcc compiler and grep isn't even on here
14:25:56 <dylukes> eternalmatt: I tried getting gcc onto my friends chrome book
14:26:04 <dylukes> no success
14:26:06 <eternalmatt> lol
14:26:08 <Zao> eternalmatt: Well, most end-user GNU/Linux deployments do not have a compiler.
14:26:10 <Zao> (madness)
14:26:25 <luite> what cpu those the chrome book have?
14:26:29 <dylukes> Best virus ever: Infects all computers world wide,
14:26:31 <eternalmatt> intel Atom
14:26:40 <dylukes> then simultaneously deletes *every* piece of compiler software
14:26:41 <eternalmatt> thankfully, i can still ssh 
14:26:42 <dylukes> at once.
14:26:44 <dylukes> (and all assemblers)
14:27:57 <kwantam> fortunately, I printed out the GHC7 source code
14:28:03 <kwantam> I'll just type it all in by hand
14:28:05 <kwantam> :P
14:28:09 <gwern> dylukes: so? just copy stuff over from all the RO media like CDs
14:28:13 <monochrom> BrianHV: I have two candidates. c1 :: PMEvent -> StateT S IO [PMEvent]. c2 :: MonadState S m => PMEvent -> m [PMEvent]. first choice accepts both c1 and c2. second choice accepts c2 only
14:28:50 <FrederikVds> Hi! What would you guys recommend to set up a web site written using Haskell?
14:28:53 <dylukes> gwern: that'd need to be deleted too.
14:29:00 <dylukes> FrederikVds: Theres Happstack and Snap
14:29:03 <gwern> FrederikVds: a static one? hakyll
14:29:08 <dylukes> gwern: or that ^
14:29:21 <FrederikVds> ok thanks :D
14:29:29 <aristid> eternalmatt: another thing you could do... ssh on a server with linux. i think chromeos DOES have ssh
14:29:37 <kwantam> FrederikVds, there is also yesod
14:29:44 <dylukes> hakyll is super simple
14:29:45 <kwantam> happstack, snap, and yesod are the three primary choices
14:29:48 <dylukes> and for static sites
14:29:51 <aristid> eternalmatt: oh, you mentioned as much yourself. did not see that :)
14:29:56 <dylukes> if you want stuff with dynamic stuff and templates, it won't do :P
14:29:58 <eternalmatt> lol, yes
14:30:09 <eternalmatt> I can ssh onto my school's servers but they no has haskell
14:30:11 <kwantam> oh yes true true
14:30:22 <BrianHV> monochrom: oh. I apparently misread the first choice then.
14:30:31 <gwern> dylukes: hakyll uses templates; and you can get dynamic stuff through JS; eg. comments on gwern.net are served dynamicly by Disqus
14:30:37 <dylukes> ah I guess that works
14:36:42 <BrianHV> monochrom: bingo. compiles, runs, works corerctly. thanks so much!
14:40:37 <eternalmatt> anyone want to play the 'whats wrong with my code' game? http://nopaste.dk/p3167
14:40:56 <Zao> Insufficient cats.
14:40:59 <c1de0x> what's the prize?
14:41:01 <monochrom> is it supposed to be wrong?
14:41:21 <eternalmatt> lambdabot doesn't like it
14:41:23 <c1de0x> is it supposed to be n--2?
14:41:42 <monochrom> oh, move the definition of "banker" out. even just out of your [].
14:41:56 <eternalmatt> but i need to use x and y with banker
14:42:04 <monochrom> initial = head [ x | x <- [1..], y <- [x..], banker 20 == 1000000 ] where banker 1 = x ...
14:42:20 <eternalmatt> x won't be in scope
14:42:22 <c1de0x> monochrom will that work?
14:42:27 <monochrom> make "banker" receive more parameters
14:42:36 <eternalmatt> hmmmmm
14:42:55 <monochrom> there is an alternative to satisfy your desire, but it is ulgy visually
14:43:03 <eternalmatt> i'm listening
14:44:26 <monochrom> initial = head [ x | x <- [1..], y <- [x..], let banker = \k -> case k of { 1 -> x; 2->y; n-> banker (n-1) + banker (n-2) }, banker 20 == 1000000 ]
14:44:47 <eternalmatt> http://nopaste.dk/p3168
14:45:18 <monochrom> banker n x y = banker (n-1) x y + banker (n-2) x y
14:45:58 <monochrom> there is an alternative but it requires one more level of "where"
14:45:58 <eternalmatt> right
14:46:48 <eternalmatt> i like pretty code without { } ;
14:46:49 * hackagebot uglymemo 0.1.0.0 - A simple (but internally ugly) memoization function.  http://hackage.haskell.org/package/uglymemo-0.1.0.0 (LennartAugustsson)
14:47:25 <Cale> Your code has tab characters in it
14:47:28 <dons> heh
14:47:40 <Cale> Make sure to configure your text editor to convert tabs to spaces
14:47:52 <eternalmatt> what's wrong with \t
14:47:59 <monochrom> convert each tab to 3.14159 spaces
14:48:07 <FrederikVds> I'm doing "cabal install happstack" and AVG is spamming me with virus warnings, why is that?
14:48:19 <dons> hmm
14:48:22 <dons> on windows?
14:48:26 <FrederikVds> yes
14:48:29 <monochrom> because AVG has false positives
14:48:29 <dcoutts> hmm odd
14:48:47 <Cale> eternalmatt: Different editors interpret it using different tabstops, but the Haskell compiler will treat it as aligning to the next multiple of 8 spaces
14:48:50 <FrederikVds> i guess they're false positives, but still it's odd
14:48:55 <dcoutts> perhaps someone finally wrote a Haskell virus, and AVG now detects the ghc RTS as a virus :-)
14:48:55 <dons> note  this:  http://www.mail-archive.com/haskell-cafe@haskell.org/msg88313.html
14:48:59 <monochrom> or because AVG stands for automatic virus generator :)
14:49:32 * dcoutts worked for an AV company for a while and was always tempted to write a sample Haskell virus and send it to the guys in the lab to see what they'd make of it
14:49:39 <Cale> eternalmatt: and vertical alignment matters, so the exact number of spaces is important
14:49:56 <dons> FrederikVds: which version of happstack are you using? the latest?
14:50:04 <dons> FrederikVds: we're looking into it for you.
14:50:13 <eternalmatt> i see
14:50:39 <FrederikVds> 6.0.3
14:50:51 <Cale> eternalmatt: There are a fair number of people who think that \t should be considered a lexical error (including me!)
14:51:05 <Cale> I think \v is at least :P
14:51:40 <dons> FrederikVds: 6.0.0 you mean?
14:52:02 <dons> that's the latest on hackage. http://hackage.haskell.org/package/happstack 
14:52:25 <monochrom> FrederikVds has a quantum entanglement with a future version :)
14:52:52 <dons> AVG appears not to flag 6.0.0 anyway
14:53:09 <FrederikVds> yes sorry, it's happstack-server that is 6.0.3
14:53:43 <dons> and the warnings come when you are compiling? or when it is downloaded?
14:54:38 <FrederikVds> when compiling i think
14:54:56 <FrederikVds> filename is 5596.exe
14:55:03 <dons> hmm
14:55:03 <FrederikVds> in AppData\Local\Temp
14:56:36 <SyntaxNinja> FrederikVds: upload the file here and send us the resultant URL: http://www.virustotal.com
14:56:50 <FrederikVds> 5596.exe?
14:56:59 <SyntaxNinja> FrederikVds, dons: none of the virus scanners find anything in the tarball: http://www.virustotal.com/file-scan/report.html?id=ed09ef6bd41901904bfbade491840e9317e8e53a929b9c65100d587156f594cd-1303423545
14:57:02 <SyntaxNinja> FrederikVds: yes, please :)
14:57:08 <dons> ok.
14:57:21 <SyntaxNinja> FrederikVds: virustotal will run a bunch of scanners on it to see if it's malicious. it's probably a false alarm.
14:58:05 <Zao> Virus scanners love to flag things that look packed or keygen-like.
14:59:01 <luite> does haskell code look keygen-like?
14:59:09 <luite> I mean executables 
15:00:20 <FrederikVds> i can't copy it for some reason
15:00:27 <dons> hmm
15:00:48 <ddarius> The brother of a friend of mine made a game called 5596 a long time ago.
15:01:10 <SyntaxNinja> FrederikVds: can you create an encrypted zip file, password "infected" and upload that?
15:02:06 <FrederikVds> of 5596.exe? No cause it's saying access denied when trying to copy/open it
15:02:50 <FrederikVds> is avg blocking access?
15:03:04 <FrederikVds> i killed the process though
15:04:00 <SyntaxNinja> FrederikVds: no idea. Windows and virus scanners are very mysterious to me. Can you change the permissions / properties? Is it zero size or anything like that?
15:04:02 <FrederikVds> oh wait it still has a service running
15:07:24 <FrederikVds> ok managed to kill AVG
15:08:59 <FrederikVds> http://www.virustotal.com/file-scan/report.html?id=bad704f41e3022948cddc5cbcdc5009593468152a6739650419414002f7c759d-1303424722
15:09:26 <gigamonkey> Is there any style guidance on whether or not the name of a data type with only one constructor should or should not be the same as that one constructor?
15:09:55 <gigamonkey> e.g. "data ColumnSequence = Columns (Sequence Column)"  vs "data Columns = Columns (Sequence Column)"
15:12:01 <dons> SyntaxNinja: ^^
15:12:24 <SyntaxNinja> FrederikVds: thanks! The big guys aren't flagging it (Symantec, McAfee, Microsoft) and just based on the name I think it's a huristic analysis
15:12:43 <SyntaxNinja> so most likely a false alarm, but disturbing that so many are flagging it. 
15:12:50 <FrederikVds> indeed
15:13:33 <luite> I've switched to Microsoft because it has fewer false positives (and is free)
15:13:43 <dons> if you cabal install again, does the same file get generated during the build?
15:13:50 <dons> or was it an unlucky tmp name?
15:14:15 <SyntaxNinja> FrederikVds: don't do anything to destroy the file, though.
15:15:00 <SyntaxNinja> FrederikVds: I'd like you to email me the file if you would. preferrably encrypted in a zip file with password "infected"
15:15:09 <FrederikVds> another 4digits.exe file gets generated and also flagged
15:18:21 <gigamonkey> Anyone on my style question above? Or pointers to style guides that discuss such things?
15:19:13 <monochrom> "data X = X blahblah" is popular, yes.
15:19:27 <monochrom> however, I don't do it to newbies.
15:20:27 <monochrom> monochrom's rule #1 for teaching material: bijection between names and concepts
15:20:40 <monochrom> (rule #0: from concrete to abstract)
15:20:52 <gigamonkey> monochrom: so which do you give the 'good' name?
15:21:04 <gigamonkey> I'm guessing the type.
15:21:48 <monochrom> oh, it's easy. data Lollipop = Lollipop'ctor Int Bool Char
15:22:09 <monochrom> however, I only do that to newbies.
15:22:49 <monochrom> I have no problem with "data Lollipop = Lollipop Sun Moon Star" in production code
15:22:59 <ddarius> rule #ω: bijection between concepts and N
15:23:07 <monochrom> hahaha
15:23:33 <SyntaxNinja> FrederikVds: yeah, same results for that one. I bet these are generated haskell files, though. Could you send them to simon marlow to see if they're normal?
15:26:32 <Tomsik> _computable_ bijection
15:27:11 <SyntaxNinja> FrederikVds: or I can do so.
15:27:42 <FrederikVds> could you do so? i never e-mailed anyone with a wikipedia page, it's a bit awkward
15:28:15 <SyntaxNinja> FrederikVds: will do heh
15:28:54 <SyntaxNinja> FrederikVds: does this happen when you cabal install anything else?
15:29:05 <SyntaxNinja> or is anyone else around w/ windows that can verify these files get generated?
15:30:26 <FrederikVds> well i've killed avg now so i'll have to try to run it again to see :p
15:32:03 <siracusa> SyntaxNinja: A file 6556.exe in the temp directory gets generated for me when installing happstack-server-6.0.3
15:33:30 <SyntaxNinja> siracusa: thanks!
15:34:23 <gigamonkey> What's the terminology for what a constructor constructs? A 'value'? 'instance'?
15:34:44 <c_wraith> value
15:34:45 <monochrom> value
15:34:56 <gigamonkey> Thanks.
15:35:55 <siracusa> I've uploaded the file, this is the result: http://www.virustotal.com/file-scan/report.html?id=dedfebc7b9730fd0633fa90a370b6251224f8d5007eb5bfe8434e70f07343939-1303426290
15:36:21 <SyntaxNinja> siracusa: perfect. Thanks!
15:36:52 <monochrom> interesting, perhaps they all just freak out at "<number>.exe"
15:38:07 <luite> does virustotal give fewer "hits" if you rename the executable?
15:39:17 <FrederikVds> only seems to happen with happstack by the way
15:39:43 <DevHC> quick, how do i compile on a .hs file on a 64-bit linux machine to run on a 32-bit linux machine?
15:39:59 <DevHC> "ghc ampc.hs -fvia-C --make -optc -m32" fails miserably D:
15:40:14 <FrederikVds> Diff made a file 6936.exe that does not get detected
15:41:15 <FrederikVds> http://www.virustotal.com/file-scan/report.html?id=98e6b838d2dd9350328ad4bd8b102cd58c4113e4c48f08ec7a7e00aabc536c46-1303426350
15:41:32 <FrederikVds> (made by Diff-0.1.2)
15:42:40 <parcs> DevHC: you can't: you need a 32-bit version of ghc to compile a 32-bit binary
15:42:46 <DevHC> D:
15:42:49 <DevHC> haskell sux.
15:43:40 <luite> someone's already working on making it easier for ghc to target multiple architectures
15:43:50 <luite> I forgot how it was though :)
15:44:01 <SyntaxNinja> FrederikVds: send me that guy too :)
15:45:25 <DevHC> ok, how do i compile a .hs file on a 32-bit freebsd system to run on a 32-bit linux system?
15:45:43 <c_wraith> ghc doesn't support cross-compiling...  so...  vmware?
15:45:50 <DevHC> D:
15:45:52 <DevHC> haskell sux.
15:46:27 <FrederikVds> SyntaxNinja: ok i did
15:46:35 <DevHC> hello? anyone? feed the troll plz, i'm hungry.
15:47:02 <blackdog> DevHC: might work with jhc? it produces C, so you'd assume you could cross-compile from that.
15:47:13 <blackdog> speculating
15:47:19 <ddarius> You should be able to.
15:47:32 <Necrosporus> http://paste.org.ru/?auyise
15:47:55 <mzero> anyone know where our SoC proposals stand?
15:48:21 <Heffalump> mzero: results should be announced by Google on Monday
15:48:24 <Necrosporus> Is this program to solve 1st eulerproject problem correct?
15:48:42 <mzero> don't we need to matchup mentors and students?
15:48:47 <mzero> did that get done?
15:48:48 <DevHC> oh no, this'll be a headache :/
15:49:28 <siracusa> Necrosporus: What language is this, J?
15:49:51 <Necrosporus> yep
15:49:59 <FrederikVds> SyntaxNinja: renamed the file, it's still being detected: http://www.virustotal.com/file-scan/report.html?id=bad704f41e3022948cddc5cbcdc5009593468152a6739650419414002f7c759d-1303427157
15:50:00 <Heffalump> mzero: yes, it did get done. Are you signed up as a mentor?
15:50:07 <mzero> I am
15:50:14 <mzero> but I don't think I'm associated with the Haskell group somehow
15:50:18 <Heffalump> you should have seen the email traffic about that, then. Oh, I see.
15:50:22 <Necrosporus> I'm sorry if it's offtopic here, but I don't know any other channels which is more appropriate
15:50:23 <mzero> (was last year)
15:51:12 <FrederikVds> (the file from happstack, not Diff)
15:52:03 <mzero> Heffalump - should I do something about that - or is it now moot? or can you use me?
15:52:41 <SyntaxNinja> FrederikVds: thanks. the files look very similar to me.
15:53:43 <siracusa> stepkut: Be honest, did you add a Trojan to Happstack? :-P
15:56:48 <FrederikVds> i have to go now, e-mail me if you need more information
15:56:54 <FrederikVds> bye!
15:57:01 <Heffalump> mzero: probably best to contact Edward Kmett and Johan Tibell
15:58:00 <Heffalump> though I think it is now moot
16:14:45 <monochrom> using paid computing power of amazon ec2 to compile your haskell program is a viable solution. the first year is free. after that, we're talking about $0.02 per hour of wall-clock time.
16:15:22 <luite> how fast are those things?
16:15:44 <monochrom> the cheapest ones are 1GHz. there are faster ones at slightly higher price
16:16:05 <monochrom> in fact, probably 1GHz but dual core
16:16:35 <monochrom> but probably you could impeach that "those are virtual machines, dual core means dual fake core"
16:17:16 <monochrom> well, the important thing is whether you can run two threads and each thread completes like it's on 1GHz. I haven't tried.
16:17:24 <pmetzger> the price might drop after today's incident. :)
16:17:27 <pmetzger> demand may fall.
16:18:08 <monochrom> yes, in fact, there is a "bid for unused resource" scheme too, which can be the cheapest, but it varies on luck and time
16:18:08 <luite> hmm, I'd want something that's faster than my laptop (2.0 GHz Core 2 Duo) for compiling... but those are probably not free
16:18:50 <monochrom> if your compilation is parallelized, you can opt for 1GHz but many many cores
16:19:17 <monochrom> but do dig more about their pricing to see.
16:19:18 <luite> hmm, I guess most haskell compilations aren't? or are they?
16:19:36 <monochrom> you're right, ghc isn't parallelized
16:20:00 <monochrom> but how many hours do you need to compile things? and it's like $0.02 per hour
16:20:23 <monochrom> unless you mean you have some hard deadlines to meet. your boss wants it "5 minutes ago"
16:21:43 <monochrom> <boss> I want you to reconfigure my xmonad desktop and I want it done in 5 milliseconds!
16:22:37 <mee> is it 0.02$ per *cpu*-hour or clock-hour of usage?
16:23:16 <acowley> clock hour
16:24:01 <monochrom> yeah, from boot up to shut down
16:24:10 <acowley> which always frustrates me because then I am inclined to shut down a machine I'm not using which necessitates a subsequent setup delay the next time around
16:24:30 <acowley> the last time I used EC2, the RAM on the low end machines was also a bit limiting
16:24:44 <monochrom> oh, that's true, 512MB merely
16:24:53 <luite> don't ac2 things support suspend?
16:25:16 <monochrom> the expectation is it's ubuntu server so it's ok for low-profile people and businesses.
16:25:35 <monochrom> I don't know
16:25:45 <acowley> it would be awesome if you could use EC2 by the CPU hour with it being just an SSH away
16:26:24 <acowley> luite: there are other delays in there, too. You request an instance, then it gets assigned, then it "boots up"
16:27:17 <monochrom> oh neato, perhaps I should buy EC2 computing resource, then re-sell to you people as ssh accounts. I charge you for either login wall-clock time or cpu-busy time. I could make some money that way
16:28:04 * monochrom goes ask John Nash for how to set a good price!
16:29:06 <acowley> well, the isolation of an EC2 instance is a nice thing, too. 
16:29:11 <mee> renice for 0.05 $/(level*hour) ;)
16:29:34 <mee> err, unit fail
16:30:01 <monochrom> oh, the tricky part of this pricing is that I charge you for cpu-hour but I pay by wall-hour
16:30:32 <monochrom> so I have to kind of predict how many customers I get, and then average it
16:32:03 <acowley> so you are going to have to do exactly what Amazon already does
16:32:09 <ion> monochrom: Has the CIA informed him about the good price via secret messages in newspapers?
16:32:28 <monochrom> haha
16:32:38 <monochrom> @trap ion
16:32:38 <lambdabot> Maybe you meant: map slap
16:32:43 <monochrom> yuck
16:32:48 <monochrom> @smack ion
16:32:49 <lambdabot> I won't; I want to go get some cookies instead.
16:32:52 <monochrom> haha
16:33:13 <siracusa> @botsnack
16:33:13 <lambdabot> :)
16:33:14 <monochrom> hey! it's cool to trap an ion!
16:33:14 <nyingen> @map
16:33:14 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
16:33:50 <acowley> that is not a very useful URL :/
16:34:16 <nyingen> @fortune
16:34:16 <lambdabot> Couldn't find fortune file
16:34:52 <blackdog> monochrom: you do get the first micro instance for free
16:34:57 <blackdog> infinite profit1
16:35:12 <monochrom> just for 1 year
16:35:42 <blackdog> 1 year per credit card
16:35:56 <monochrom> unless I remove my moral block against creating a new account every year
16:36:32 <blackdog> economics is amoral, right?
16:36:43 <monochrom> actually even with the moral block, it's pretty risk-free because I can use the 1st year to see how many users I get
16:36:48 <blackdog> but yeah, the morality is a bit sketchy:)
16:37:19 <blackdog> was funny - at the ruby group, we had a bunch of heroku/salesforce droids come and buy us beer & talk about the wonderful new things you can do with heroku
16:37:33 <blackdog> and the next talk was about how to avoid paying heroku for background processes:)
16:40:09 <rostayob> @pl \p -> votePost p up user
16:40:09 <lambdabot> flip (flip votePost up) user
16:42:46 <ion> It might be fun to have syntactic sugar such as votePost # up user which means exactly that.
17:10:49 <stepkut> siracusa: part of the plan for world domination fast..
17:11:00 <djanatyn> Man, Haskell is awesome.
17:11:10 <djanatyn> I'm reading "Learn You a Haskell" and "Real World Haskell"
17:11:12 <dmwit> djanatyn: Glad you agree!
17:11:21 <djanatyn> It's taken me a week or so to kind of wrap my mind around functional programming
17:11:36 <dmwit> Wow! Only a week?
17:11:45 <djanatyn> Heh :)
17:11:51 <djanatyn> Well, a week of studying
17:11:58 <djanatyn> I've been looking at Haskell on and off for about a month now
17:12:05 <djanatyn> And I don't really understand it at all, but it's kind of clicked
17:12:14 <djanatyn> You don't have to change the value of variables all the time :D
17:13:06 <lispy> djanatyn: right.  So, we tend to not call them variables
17:13:24 <lispy> (although, most people would know what you mean)
17:13:51 <Saizan> we call them variables as is done in algebra/calculus/..
17:14:40 <djanatyn> One of my friends (chris done) is pretty addicted to Haskell.
17:14:49 <siracusa> stepkut: :-D
17:14:53 <djanatyn> He converted me, in a way.
17:15:20 <shachaf> djanatyn: Is that one of the people in -- the other channel?
17:15:32 <djanatyn> ...#jbopre?
17:15:34 <djanatyn> Indeed.
17:15:41 <djanatyn> Apparently he's pretty active in the Haskell scene.
17:15:50 <djanatyn> He wrote tryhaskell.org
17:16:02 <djanatyn> Or .com, not sure.
17:16:19 <shachaf> Who?
17:16:37 <Rotaerk> I want a new good haskell book to be written
17:16:43 <hpc> Rotaerk: you mean lyah?
17:16:46 <djanatyn> Chris Done - Cin
17:16:49 <Rotaerk> LYAH seems pretty basic
17:16:59 <Rotaerk> and RWH is way too... dilluted with examples
17:17:11 <hpc> Rotaerk: then... compile some research papers ;)
17:17:12 * shachaf associates name with nick.
17:17:14 <shachaf> Weird.
17:17:14 <Rotaerk> I mean, the examples are too noisy
17:17:42 <DevHC> Rotaerk: i direct u to  "T3H H4SK3LL TUT0R14L"
17:17:48 <Rotaerk> :P
17:18:03 <dmwit> shachaf: He sometimes goes by "chrisdone" in here, too.
17:18:27 <shachaf> I've seen that.
17:18:30 <lispy> djanatyn: yeah, that name is familiar so I would say he's active
17:18:31 <djanatyn> dmwit: I heard that he has several nicks across different networks and channels
17:18:41 <Saizan> oh, he's Cin now?
17:18:49 <lispy> djanatyn: I'm terrible with names, so typically if I know someone's name here then they are probably pretty active :)
17:18:55 <djanatyn> Oh, and he also runs hpaste.org
17:19:13 * lispy leaves
17:19:32 <djanatyn> Saizan: He's Cin in the channel I visit :)
17:19:52 <djanatyn> I've used xmonad on and off for about a year, mostly with the default setup
17:20:05 <djanatyn> Eventually I got sick of it and decided to configure it, and got a little Haskell thrown in my face.
17:23:21 <jmcarthur> felt good, didn't it? ;)
17:24:56 <Saizan> ..it's getting kinky
17:25:27 <shachaf> Should be added to @slap.
17:25:32 <dmwit> Everybody should sign up for Hac Phi!
17:25:53 <dmwit> And /join #haskell-hacphi
17:26:06 <jmcarthur> thinking about it. might "only" be 7 hours away around the time that is happens
17:26:07 <shachaf> djanatyn: Are you going?
17:26:10 <dmwit> djanatyn: Especially you. Come hang out with the people you're talking to!
17:26:13 <jmcarthur> *it
17:26:44 <djanatyn> Oh, I'll come.
17:26:48 <dmwit> jmcarthur: You definitely should. Food + smart people + intelligent conversation + Haskell talks = you should be there!
17:26:50 <dylukes> hahahaha
17:26:54 <djanatyn> I was just listening to the Portal 2 end theme.
17:26:56 <dylukes> I challenge anyone to do better here
17:26:56 <dylukes> http://boards.4chan.org/g/res/17101495
17:26:58 <djanatyn> Wow. What an incredible experience.
17:27:00 <dylukes> (I'm the one using ruby)
17:27:42 <shachaf> dylukes: Did you use to have another nick?
17:27:46 <dylukes> ?
17:27:51 * shachaf wonders whether to go to Hac Phi.
17:28:06 <dmwit> shachaf: Lots of famous people will be there.
17:28:13 <dmwit> All your wildest dreams will come true!
17:28:14 <jmcarthur> famous people? :P
17:28:29 <shachaf> dmwit: More than there were at BayHac?
17:28:49 <dmwit> Well, based on previous years, I expect 30-35 people.
17:28:55 <dmwit> But you could bump that up to 31-36 people!
17:29:03 <maurer_> :( I am normally locate in PA, but during HacPhi I will be on the opposite coast.
17:29:09 <monochrom> jack the ripper, john the chainsaw massacer, tweeny the head cutter
17:29:13 <dmwit> jmcarthur: ...well, Haskell-famous. =)
17:31:38 <dmwit> > let step s = init s ++ [tail s]; go s = take (length s) (iterate step s) in unlines . map (("|" ++) . (++ "|")) . go $ "por"
17:31:40 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:32:14 <dmwit> > let step s = init s ++ [tail s]; go s = take (length s) (iterate step s) in go "por"
17:32:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
17:33:16 <luite> add -XInfiniteTypes ;)
17:33:25 <mjo> Quick question: I'd like to do simple algebra with functions. Someone else must have already done this, no? For example, (f+g)(x) = f(x) + g(x).
17:33:42 <shachaf> > ((*3) + (^2)) 5
17:33:43 <lambdabot>   40
17:34:12 <mjo> Whaaaaaaaaaaaaaaaat?
17:34:14 <dmwit> > let step s = init s ++ [head s]; go s = take (length s) (iterate step s) in unlines . map (("|" ++) . (++ "|")) . go $ "por"
17:34:19 <lambdabot>   mueval-core: Time limit exceeded
17:34:39 <dmwit> > let step s = init s ++ [head s]; go s = take (length s) (iterate step s) in go "por"
17:34:41 <lambdabot>   ["por","pop","pop"]
17:34:47 <dmwit> argh
17:34:52 <dmwit> > let step s = tail s ++ [head s]; go s = take (length s) (iterate step s) in go "por"
17:34:54 <lambdabot>   ["por","orp","rpo"]
17:34:55 <mjo> Where's the magic? If I define f(x) = 2*x and g(x) = 3*x, f+g throws an error.
17:35:07 <dmwit> mjo: The magic is in an instance of Num for functions.
17:35:27 <dmwit> > let step s = tail s ++ [head s]; go s = take (length s) (iterate step s) in unlines . map (("|" ++) . (++ "|")) . go $ "por"
17:35:29 <lambdabot>   "|por|\n|orp|\n|rpo|\n"
17:35:39 <mjo> Should I just define one myself? Or has it already been done somewhere?
17:35:42 <fryguybob> @hackage vector-space
17:35:42 <lambdabot> http://hackage.haskell.org/package/vector-space
17:35:47 <Draconx|Laptop> annoyingly, to make a Num instance for functions you need to also make Eq and Show instances for functions...
17:36:02 <dmwit> > length "let step s = tail s ++ [head s]; go s = take (length s) (iterate step s) in unlines . map ((\"|\" ++) . (++ \"|\")) . go $ \"por\""
17:36:04 <lambdabot>   124
17:36:06 <mjo> show f = "please stop" =)
17:36:30 <dmwit> dylukes: 124 characters before minimization. Not bad, eh?
17:36:31 <monochrom> I am not sure you must absolutely make "f+g" make sense
17:36:47 <dylukes> nice :D
17:36:49 <dylukes> post it
17:36:51 <dylukes> then reduce it more
17:37:28 <monochrom> you could easily define your own operator "($+$) f g x = f x + g x" then you can write "f $+$ g"
17:38:28 <monochrom> afterall, this is haskell, not c++, you are not limited to 20 pre-named operators
17:38:40 <conal> or use the function-as-number module from applicative-numbers
17:38:40 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
17:39:05 <conal> and then just say f + g
17:39:36 <conal> xplat: ping
17:39:41 <monochrom> it is seldom necessary. it opens a can of worms
17:40:24 <monochrom> it is as questionable as unsafePerformIO
17:40:50 <mjo> Argh, applicative-numbers looks like exactly what I need, but there's no Gentoo package. I'll file a bug and just define my own Num instance in the meantime.
17:41:44 <ion> Simply use cabal to install what you need under $HOME.
17:42:52 <monochrom> once you do cabal install --user (default), there is no safe going back. http://www.vex.net/~trebla/haskell/sicp.xhtml
17:42:53 <mjo> I can actually write my own ebuild for it in about 30 seconds, which is what I should do if I'm nice.
17:42:56 <conal> mjo: there's a systematic way to give numeric class instances for all applicative functors. e.g., sin = fmap sin, (*) = liftA2 (*), etc. 
17:43:41 <conal> mjo: spelled out in the paper "beautiful differentiation" (http://conal.net/papers/beautiful-differentiation/)
17:44:13 <conal> mjo: more examples plus general justification in http://conal.net/papers/type-class-morphisms/
17:44:15 <mjo> conal: I tried to read that when you wrote it, and it was way over my head =)
17:45:04 <conal> mjo: oh, okay. well, play with the special case of functions, and maybe a few other applicative functors, and you'll get the idea. ask me if you have any questions about any of this stuff.
17:46:05 <mjo> I'm sure I can do it with functions, and I feel like I've probably done it before. It just felt like I was reinventing the wheel. I'll probably wind up packaging and using applicative-numbers.
17:46:18 * conal is making OMG-fantastic chocolate-and-peanut-butter-chip cookies, with with added molasses.
17:46:36 <conal> mjo: great!
17:52:02 <conal> @tell xplat i just saw your query from 4 days ago asking about a (denotational) semantics of iteratees. i did come up with some ideas last august (in tokyo). i'd hoped to find some active interest among users and developers of iteratee-like libs (e.g., for reasoning about correctness), but i saw none, so i dropped it. meanwhile, i avoid iteratees like the plague.
17:52:03 <lambdabot> Consider it noted.
17:53:43 <applicative> like the plague?  I hadn't thought it was that dim a view you'd taken...
17:55:02 <applicative> conal, have you seen the most recent (a few months ago) formulation of them?  It is a little more lucid if maybe not denotationally acceptable...
17:55:25 <applicative> conal, I mean, oleg's newest types for iteratee/enumerator, etc
17:56:44 <conal> applicative: no, i haven't seen a recent reformulation. still presented as mechanism with no given semantics?
17:57:02 <DevHC> conal: have u got to conclusively test the performance of that push-pull frp thing?
17:57:09 <jmcarthur> conal: i'm curious about what you came up with. was it mentioned in that mailing list thread?
17:57:51 <applicative> no explicit semantics, it's basically the same file, but I wondered if some of the complaints that came up on your thread influenced it.
17:57:52 <jmcarthur> i don't remember much from that thread
17:59:40 <conal> jmcarthur: i don't remember. i might have at least hinted at it. i wanted to see whether there was interest even in the question of what they mean (independently of implementation). possibly i didn't say much, so as to avoid influencing other people's ideas.
18:00:07 <conal> DevHC: no. i've done no profiling, stats, etc.
18:01:36 <applicative> conal, of course everyone was interested!
18:02:32 <applicative> conal, I'm not sure the new formulation spoke to anything the old thread, looking back over it. 
18:02:34 <conal> applicative: do you really think so?
18:02:46 <conal> applicative: (i mean about interest)
18:04:06 <jmcarthur> most of the models i remember from that thread just looked like different possible implementations and didn't really explain much to me
18:04:50 <applicative> conal, was your worry that you'd be a kill-joy in the iteratee-enthusiasm party?
18:05:35 <applicative> most of us are still trying to get to the bottom of them, so how could it be anything but good.
18:07:50 <conal> applicative: i figured that unless i saw active interest, there wouldn't be much receptivity when a denotative (Landin's term for genuinely functional) examination revealed significant problems and suggested substantive rethinking & reworking.
18:09:19 <applicative> I see, so the thought was that it would tend just to be destructive, since who knows how to do the rethinking and reworking
18:09:53 <conal> applicative: mostly that it'd be fruitless and no fun for me.
18:10:35 <jmcarthur> :(
18:10:42 <conal> if people decide that lack of semantics is a problem, then i'll probably be interested in helping with the exploration.
18:11:31 <jmcarthur> i would think that there would be a lot of interest in discovering a simple semantics for iteratees, of all things
18:11:52 <jmcarthur> many people agree that its usual presentation is not so simple, at least
18:13:53 <conal> i use semantics as a tool for (re)designing programming interfaces, not just reasoning about existing one. the clarity gained usually suggests improvements. often drastic changes.
18:14:15 <jmcarthur> some people might not be open to that, but many are i'm sure
18:14:58 <jmcarthur> i certainly am. i'd rather narrow in on something beautiful but yet unknown than narrow in on something known but not beautiful
18:16:22 <conal> jmcarthur: i love hearing that sentiment! :)
18:17:05 <applicative> conall, for what it's worth, the 'pure' non monadic version of the new formulation could be expressed thus:
18:17:07 <applicative> data PreIt b a  =  Either (Maybe String -> (b, Maybe String)) a ; newtype Iteratee a = It (PreIt (Iteratee a) a)
18:17:48 <applicative> it's the fixed point of a transformed state 'monad'
18:18:27 <conal> neat. 
18:18:45 <conal> time for me to go. we can continue later.
18:19:05 <applicative> I feel like i can never quite get to the bottom, but it seemed promising, this new version.  Bye
18:19:30 <jmcarthur> IMO, the current semantics is too focused on sequential consumption
18:19:54 <conal> applicative: yeah. that kind of pattern gets my attention. a promising sign.
18:20:08 <conal> applicative: .. sign that there's more than just hacking going on.
18:20:13 <jmcarthur> i think a nicer semantics would also allow for parallel consumption
18:20:22 <conal> jmcarthur: !! 
18:24:32 <rnik> I'm wondering how Haskell values are implemented behind the scenes... for polymorphic functions to work I guess everything must fit in 32 (or 64) bits?  So... are all values implemented as pointers, with maybe Ints jammed in the pointer value with the low bit set?
18:25:20 <rnik> I'm assuming it's not like C++ where polymorphism (ie, templates) results in multiple machine code versions of one function.
18:25:26 <hpc> rnik: evaluated values are implemented as a pointer to something; unevaluated values are implemented as a pointer to the function that evaluates the head
18:25:29 <Axman6> rnik: i believe it's more compicated than that.
18:25:43 <hpc> rnik: (gross simplification, and probably not accurate even)
18:26:00 <Cale> rnik: Every value is a code pointer
18:26:10 <Axman6> unless it's got unpacked elements..
18:26:12 <jmcarthur> rnik: it's usually not like C++ templates, but specialization can happen too
18:26:13 <RichardO> GHC is able to unbox alot of values
18:27:33 <Cale> rnik: When you evaluate a value for the first time, the code is run to evaluate the value, and it updates the pointer to point at a shorter piece of code which will return the value immediately next time
18:28:48 <rnik> Cale: why not just the value itself? 
18:29:11 <Cale> In addition to this, in more recent GHCs, there is a pointer tagging optimisation. Code pointers are word-aligned, and so the less significant bits in them are ordinarily useless. The optimisation stores information about whether the value has been evaluated and in the case of types with few constructors, which constructor it is.
18:29:13 <rnik> Thanks, everyone, for the answers.
18:29:17 <jmcarthur> because everything pointing to it expected code
18:29:20 <hpc> rnik: easier to just blithely run a trivial function
18:29:26 <Cale> Because of laziness, you have values which are still expressions
18:29:29 <hpc> rnik: instead of saying "oh, is this a value?"
18:29:37 <hpc> also that
18:29:44 <Cale> Lazy evaluation is meant to evaluate expressions outermost first
18:30:05 <RichardO> You can view everything as starting out as an unevaluated value, which is a pointer to a function. Evaluated values are a pointer to a value, but GHC strictness analysis can unbox these values.
18:31:57 <Cale> so when you have f (g x), in a strict evaluator, you evaluate x first, and then plug the result into the body of g, and then plug the result into the body of f
18:32:00 <Cale> which is innermost first
18:32:13 <Cale> In lazy evaluation, you plug g x into the body of f, essentially
18:32:42 <Cale> With the optimisation that if f's parameter occurs more than once in the body of f, then g x will only be computed once and shared between the copies
18:33:28 <Cale> (but it won't be computed immediately in any case, until f needs to inspect the value of it)
18:35:54 <applicative> rnik: It's quite old but Peyton Jones' book is worth a look http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/  -- and other things from around then
18:36:48 <Cale> http://research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz
18:37:17 <applicative> yes, like that one ^^^
18:39:01 <Cale> That is probably the best tutorial if you really want to understand how to implement this sort of language on ordinary hardware, though it's a little out of date with how GHC actually does things.
18:39:16 <Cale> The spineless and tagless parts are sort of no longer true.
18:39:43 <ddarius> STG is hardly the only way of doing things nor necessarily the best.
18:40:00 <Cale> I didn't mean to suggest that it was
18:40:38 <ion> > let foo′ = 42 in foo′ -- Can the actual prime character be used like the ASCII approximation?
18:40:39 <lambdabot>   <no location info>: parse error on input `='
18:43:04 <applicative> > let (??) = (+) in 1 ?? 1
18:43:05 <lambdabot>   2
18:44:08 * hackagebot normaldistribution 1.1.0.1 - Minimum fuss normally distributed random values.  http://hackage.haskell.org/package/normaldistribution-1.1.0.1 (BjornBuckwalter)
18:44:10 <applicative> hm, i got question marks not prime marks.  In ghci the prime marks go with operators 
18:45:47 <monochrom> which prime mark? do you know the unicode codepoint? ie U+2222 or something
18:46:12 <applicative> ask ion
18:46:35 <siracusa> > let x′ y = x + y in 1′ 1
18:46:36 <lambdabot>   2
18:47:13 <monochrom> that character is not legal in a haskell var name
18:47:36 <ion> U+2032 PRIME
18:47:58 <babusri> I had installed WxGeneric successfully earlier with an older haskell platform. I wanted to use the latest ghc and so I uninstalled haskell platform and packages and installed latest haskell platform (windows). It has base-4.3.1.0. When I install WxGeneric I get error "cabal: cannot configure WxGeneric-0.6.1. It requires base >=4.1.0 && <4.3.0". Is my only option to revert back to an older haskell platform? Also, is i
18:47:58 <babusri> t possible to verify that all the packages you need will be available before you upgrade haskell platform? Also, can we have 2 haskell platform versions installed?
18:48:20 <dylukes> I claim code gold victory
18:48:22 <dylukes> code golf*
18:48:51 <dylukes> progression of my code:
18:48:51 <dylukes> https://gist.github.com/935880
18:49:06 <rnik> oh how I wish they had tought haskell or scheme in college and not java.
18:49:52 <monochrom> I have 4 versions of haskell platform installed. play with --prefix and PATH
18:49:58 <applicative> ion, ghci is accepting U+2032 in the formation of operators so its with *&$# etc not abcd. but  the ascii ' is a letter for Haskell...
18:50:07 <ion> yeah
18:50:31 <monochrom> but I built them all myself from source, not binary installer
18:50:39 <shachaf> applicative: Well, semi-letter.
18:50:54 <monochrom> well, I suppose you can choose target directories for binary installer just as well
18:51:04 <Necrosporus> (-$:&$:&<:)^:(1&<) — how to make it memorize values (it's J)?
18:51:08 <applicative> shachaf, what are the constraints on it? I cant remember the rules
18:51:36 <shachaf> applicative: Can't be at the beginning of a name, for instance (because that's used for characters).
18:51:41 <Axman6> Necrosporus: if it's J, why are you asking here?
18:51:57 <applicative> right, indeed the obvious restriction. 
18:51:59 <babusri> monochrom, On windows it is a pain to build from source.
18:52:50 * applicative briefly forgot that we use ' to quote things.
18:53:10 <Necrosporus> Axman6, because I don't know, where is the J channel
18:53:13 <monochrom> I heard it's ok to use the windows installer and still have multiple versions. old version not replaced. just play with PATH then
18:53:29 <Axman6> Necrosporus: no idea, but J has nothing to do with Haskell...
18:53:36 <Axman6> apart from being a programming language
18:53:46 <monochrom> you can always use #haskell-blah and #not-math
18:53:55 <Necrosporus> It's functional
18:54:01 <ddarius> Necrosporus: The fact that you can't find or there does not exist a J channel doesn't make it on topic here.  There are off-topic channels associated to #haskell.
18:54:28 <ddarius> Necrosporus: J is about as "functional" as Scheme (arguably) and Scheme is still off-topic here.
18:54:36 <ion> Can i replace onions in a cake recipe with soy milk? I’m asking here because i don’t know where the cooking channel is.
18:54:53 <monochrom> the cooking channel is at ##java
18:54:59 <ion> Ah, thanks!
18:55:12 <djahandarie> data CakeIngredient = Onions | SoyMilk
18:55:17 <monochrom> but cake recipes are in ##c
18:55:26 <monochrom> because cake begins with c
18:55:28 <shachaf> > (quote (blah blah blah))
18:55:30 <lambdabot>   (BLAH BLAH BLAH)
18:55:35 <siracusa> Necrosporus: ##jsoftware
18:55:37 <Necrosporus> Ok, how to calculate a(n) if a(1)=1 and a(n+1)=n+1-a(a(n)) ?
18:55:54 <monochrom> by calculating carefully
18:56:00 <Necrosporus> siracusa, empty
18:56:16 <adamvh> does lambdabot do lisp?
18:56:23 <Necrosporus> How to calculate it on haskell with shortest possible?
18:56:30 <djahandarie> adamvh, not as far as I know
18:56:32 <Necrosporus> code
18:56:41 <adamvh> < (quote (blah blah blah))
18:56:49 <Axman6> Necrosporus: that's also not haskell
18:56:50 <adamvh> > (quote a)
18:56:51 <lambdabot>   Not in scope: `quote'
18:56:56 <ddarius> There are already a bunch of Haskell Project Euler solutions online if you just want to see an answer.
18:56:57 <monochrom> single #
18:57:06 <adamvh> (quote (blah blah blah))
18:57:10 <djahandarie> Necrosporus, you can use a higher-order memoization function from a memorization library, and that would be pretty short
18:57:18 <Necrosporus> Axman6, it's math definition of a(n) function
18:57:48 <Necrosporus> siracusa, however #jsoftware with only one # works, thank you.
18:58:28 <siracusa> Oh, meant that, sorry
18:58:37 <Necrosporus> ddarius, it's not from euler, is it?
18:59:12 <applicative> @type  let (-$:&$:&<:) = (*) ; (^:) = fmap ; (&< ) = (:) in (-$:&$:&<:)^:(1&<) 
18:59:13 <lambdabot> forall t. (Num [t], Num t) => [t] -> [t] -> [t]
18:59:25 <applicative> this isn't J it's haskell ^^^
18:59:43 <ddarius> Necrosporus: I figured it was since that's what you first asked about.
19:01:05 <Necrosporus> However, a(n) seems an interesting sequence
19:02:33 <ion> > (string-length (cons 'o' "hai"))
19:02:35 <lambdabot>   4
19:02:36 <ion> Lisp, you say?
19:03:31 <applicative> @type string-length
19:03:32 <lambdabot> Not in scope: `string'
19:04:03 <adamvh> > (map #'1+ (list 1 2 3))
19:04:04 <lambdabot>   <no location info>:
19:04:04 <lambdabot>      lexical error in string/character literal at chara...
19:04:18 <shachaf> Can't make #' work in lambdabot. :-(
19:04:44 <adamvh> >(map (lambda (x) (+ x 1)) (list 1 2 3))
19:05:00 <adamvh> > (map (lambda (x) (+ x 1)) (list 1 2 3))
19:05:01 <lambdabot>   Not in scope: `lambda'Not in scope: `list'
19:05:40 <adamvh> Well I don't think it's common lisp...
19:05:42 <copumpkin> how would you suggest writing custom binders like that in haskell? seems kind of unlikely
19:06:11 <ddarius> > let a = 1:map (\n -> succ n - (a !! (a !! n))) [0..] in a
19:06:15 <lambdabot>   mueval-core: Time limit exceeded
19:06:29 <ddarius> > let a = 1:map (\n -> succ n - (a !! (a !! n))) [0..] in take 5 a
19:06:32 <lambdabot>   mueval-core: Time limit exceeded
19:06:42 <monochrom> does it terminate?
19:06:46 <ddarius> I doubt it.
19:07:21 <ddarius> copumpkin: I believe newer versions of TH allow unadorned splices.
19:08:15 <ddarius> copumpkin: Alternatively, you could do the kind of things that some people do in C++ to fake lambdas.
19:08:26 <shachaf> adamvh: Right, Common Lisp would be mapcar.
19:08:44 <adamvh> nah, CL's got regular old map
19:09:08 <adamvh> > (cons 'a '(b c ))
19:09:09 <lambdabot>   <no location info>:
19:09:09 <lambdabot>      lexical error in string/character literal at chara...
19:09:50 <ion> I don’t think lambdabot will learn to interpret Lisp just by feeding it a lot of it.
19:10:05 <adamvh> I was confused because you seemed to have done so
19:10:08 <Axman6> you never know
19:10:12 <adamvh> I will cease my experiments
19:10:13 <ddarius> ion: Perhaps we should make a feature where lambdabot can learn a programming language by examples.
19:10:31 <adamvh> I thought perhaps it knew a subset, and I was trying to figure out which subset
19:10:47 <ddarius> adamvh: It knows the subset that also parses as Haskell.
19:10:56 <applicative> obviously lambdabot should make an evalLisp function available
19:11:00 <ion> The @let string = 8, @let cons = (:) subset.
19:11:47 <adamvh> ah, I appear to be the butt of a joke
19:11:50 <adamvh> ):
19:12:23 <ion> applicative: evalLiskell?
19:12:41 <ddarius> Incidentally, #' would just be id in Haskell.
19:13:08 <Axman6> > evalLisp (cons ())
19:13:08 <lambdabot>   Not in scope: `cons'
19:13:19 <Axman6> > evalLisp (map id)
19:13:21 <lambdabot>   Please no :(
19:14:05 <applicative> ion, hm, i was just thinking of one of the scheme interpreter libraries or whatever
19:14:23 <applicative> haha
19:14:42 <danharaj> Hey, what would you guys call a function f :: Float -> Float -> (Int, Float) that gave you the number of times the first float goes into the second, and the remainder?
19:14:47 <applicative> > evalLisp (map id)
19:14:49 <lambdabot>   Please no :(
19:15:03 <ddarius> > properFraction 3 pi
19:15:04 <lambdabot>   Couldn't match expected type `a -> t'
19:15:04 <lambdabot>         against inferred type `(b, t1)'
19:15:04 <Axman6> danharaj: fmod?
19:15:16 <Axman6> i think that's roughly what it's called in C
19:15:42 <applicative> @type mod
19:15:42 <lambdabot> forall a. (Integral a) => a -> a -> a
19:15:54 <applicative> @type divRem
19:15:55 <lambdabot> Not in scope: `divRem'
19:16:15 <ion> divMod, quotRem
19:16:50 <ddarius> > properFraction (pi/3)
19:16:51 <lambdabot>   (1,4.719755119659763e-2)
19:17:03 <applicative> right
19:17:04 <danharaj> yes, I could implement it that way
19:17:13 <applicative> @type divMod
19:17:14 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
19:17:25 <danharaj> hopefully properFraction uses a fast primitive like Axman said :p
19:17:42 <applicative> I call it "floatRem"
19:20:04 <ion> I think Prelude should also contain fracResidue as an alias to divMod/quotRem.
19:20:42 <luite> to which one?
19:21:13 <ion> Ah, they aren’t actually the same. :-) Hadn’t bothered to read the docs before.
19:21:32 <luite> sorry for spoiling your joke ;p
19:21:36 <ddarius> ion: You thought Haskell just randomly decided to give the same function two names?
19:21:56 <ion> You and your so-called facts.
19:22:09 <danharaj> Hey, sometimes Haskell gave the right name to the wrong function.
19:22:10 <ion> ddarius: pure, return
19:22:21 <ddarius> ion: Have different types.
19:22:34 <danharaj> they're only the same if your applicative and monad instances are compatible.
19:22:38 <danharaj> they don't have to be compatible.
19:22:50 <ion> They really ought to be. :-)
19:23:04 <danharaj> The language cares not for your political beliefs.
19:24:05 <ddarius> pure can exist while return doesn't.  And if your point is that Applicative should be a superclass of Monad and thus there should only be pure, that decision wasn't made randomly.  It wasn't made at all.
19:28:14 <NemesisD> anyone know of any exemplary haskell libraries dealing with web APIs, preferably REST? i was looking for my first haskell library project to implement the Netflix API, but i'm a bit shaky on the design aspecs
19:29:11 <danharaj> I am really bad with finding basic functions. f ::  (a -> a) -> Int -> (a -> a) such that f g n is the n-times composition of g?
19:29:29 <danharaj> Maybe I shouldn't assume these things are already defined for me.
19:29:47 <luite> @type iterate
19:29:47 <lambdabot> forall a. (a -> a) -> a -> [a]
19:30:41 <ddarius> danharaj: It's not predefined.
19:30:42 <luite> try to see what it does, you should be able to build it with iterate
19:31:24 <ddarius> luite: It's \g n x -> iterate g x !! n except that you wouldn't want to use that definition for a couple of reasons.
19:31:28 <danharaj> ddarius: good to know. totally should be a partially applied fold over naturals though :p
19:31:54 <ddarius> It is also appEndo . mconcat . map Endo . replicate n g
19:32:15 <applicative> Nemesis, is something like this too simple? http://hackage.haskell.org/packages/archive/GoogleChart/0.2/doc/html/Graphics-Google-Chart.html
19:32:21 <ddarius> Well, the last (.) should be a ($)
19:33:07 <danharaj> Since I'm using this in conjunction with an IORef, I would rather just use modifyIORef with the iterated composition
19:34:02 <applicative> NemesisD: or maybe I was thinking of http://hackage.haskell.org/package/hs-gchart
19:35:05 * ddarius finds monoid actions pretty.
19:35:42 <jmcarthur> ddarius: "monoid actions"?
19:35:50 <ion> Endo `ala` foldMap $ replicate n g
19:36:05 <jmcarthur> ah that stuff
19:36:36 <danharaj> I'm always curious why there isn't a built-in Naturals type.
19:36:46 <danharaj> I guess no one cares.
19:36:48 <handonson> danharaj: also, (foldr1 (.) .) . flip replicate
19:36:48 <ddarius> danharaj: No good reason.  No good reason at all.
19:36:56 <NemesisD> applicative: i'll check it out. it may be since it's just dealing with parameterizing haskell types and getting urls
19:37:13 <jmcarthur> i care
19:37:35 <handonson> i mean, { (foldr1 (.) .) . flip replicate } for  f ::  (a -> a) -> Int -> (a -> a) such that f g n is the n-times composition of g
19:37:39 <jmcarthur> ala kind of reminds me of the stuff in http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Generator.html
19:37:41 <NemesisD> right now i'm using a twitter library i found as a template, it's closer to that, mapping to a bunch of rest actions on netflix, authentication, parsing/generating xml
19:38:17 <ddarius> jmcarthur: ala was not what I meant by "monoid actions" (if that is not clear)
19:38:35 <jmcarthur> ddarius: ah, then i am still curious
19:39:30 <djahandarie> Why the smokes has documentation still not been created for my latest package upload?
19:39:57 <danharaj> I dislike how "Float" is not used in the type constructor namespace, so a library *cough OpenGL* can actually use it without clashes.
19:40:01 <djahandarie> I thought it ran at midnight, but perhaps not. 
19:40:04 <danharaj> It's slightly disconcerting
19:40:51 <jmcarthur> reduceWith appEndo $ replicate n g  -- ion  :)
19:42:07 <djahandarie> jmcarthur, so that is to say, (`ala` foldMap) reminds you of the stuff in that module
19:42:09 <ion> Neat :-)
19:42:58 <jmcarthur> and other modules from the same package, i should say
19:43:26 <jmcarthur> can't say i've seen many examples using ala aside from foldMap, so maybe i'm missing some generality
19:43:55 <djahandarie> :t ala ZipList traverse
19:43:56 <lambdabot> Not in scope: `traverse'
19:44:00 <djahandarie> :t ala ZipList Data.Traversable.traverse
19:44:01 <lambdabot> forall a (t :: * -> *). (Data.Traversable.Traversable t) => t [a] -> [t a]
19:44:08 <djahandarie> transpose ^^
19:44:28 <jmcarthur> ion: another one using Data.Monoid.Combinators:     replicate n g    and that's it
19:44:33 <cdsmithus-mobile> djahandarie: There's some kind of issue right now.  Last I looked, haddock updates for hackage hadn't run since Saturday
19:44:45 <jmcarthur> oh i guess you have to say Endo somewhere, actually
19:44:53 <djahandarie> cdsmithus-mobile, poo :(
19:44:55 <jmcarthur> replicate n (Endo g)
19:45:01 <ddarius> Documentation is for the weak and foolhardy anyway.
19:45:30 <cdsmithus-mobile> There's still ghci's :t and :info.  That's enough documentation, right?
19:46:48 <djahandarie> jmcarthur, ala and the Newtype typeclass is nothing particularly interesting to be honest. It's for removing boilerplate. You still need newtypes and instances on those newtypes to use ala to do interesting thing
19:46:59 <jmcarthur> yeah
19:47:34 <djahandarie> I think that https://gist.github.com/873548 is a nice usage of it by sjoerd
19:50:46 <NemesisD> looks like sigbjorn finne has several libraries in this area
19:58:18 <mafs> I know I've seen a few around, anyone recommend a particular twitter api implementation in haskell?
20:01:48 <dented42> I'm playing with the list monad, I am trying to create a function returns the total number of possible hands in a card deck. Sort of like a cartesian product, but it drawing a card removes it from the deck. I have written something that seems to make sense to me, but always returns an empty list and I can't figure out why. What am I doing wrong?    http://hpaste.org/45928/list_monad__cards
20:03:24 <jmcarthur> dented42: consider what happens when you do this:     do x <- [1]; y <- []; return (x + y)
20:05:09 <dented42> jmcarthur: it would call error, because y doesn't actually bind to anything... oh, so does that mean that the list monads implementation of error returns an empty list?
20:05:28 <dented42> jmcarthur: in that case, I would want the base case to be [[]] instead of []
20:05:34 <monochrom> > do { y<-[]; return "success" }
20:05:35 <lambdabot>   []
20:05:36 <jmcarthur> it's not an error at all
20:05:38 <luite> it doesn't call error
20:06:09 <jmcarthur> dented42: there would be no value to bind to y, so the result of the whole expression is going to be []
20:06:26 <dented42> jmcarthur: err, not error, I mean fail
20:06:30 <jmcarthur> but i think you got the gist
20:06:35 <monochrom> > do { y<-mzero; return "success" } :: [String]
20:06:36 <lambdabot>   []
20:06:48 <jmcarthur> it's not fail either
20:06:59 <jmcarthur> there is no failing pattern there
20:07:01 <geekosaur> do you understand monoids?  this is just monoid activity in a monad; you're getting mempty
20:07:06 <jmcarthur> it's just the semantics of list
20:07:46 <jmcarthur> dented42: if you think about what >>= for lists is (concatMap), you might get a better idea of what's happening
20:07:59 <dented42> geekosaur: oh, ok.
20:08:06 <jmcarthur> > concatMap (\x -> [x+1, x+2, x+3]) []
20:08:07 <lambdabot>   []
20:08:19 <dented42> jmcarthur: ah, that makes sense. I see what's going on.
20:08:24 <jmcarthur> > concatMap (\x -> []) [1,2,3]
20:08:25 <lambdabot>   []
20:10:16 <dented42> jmcarthur, geekosaur: thanks!
20:17:23 <aristid> > [1,2,3] >> mzero
20:17:24 <lambdabot>   []
20:40:57 <ddarius> geekosaur: (>>) and return is also a monoid for monads.
21:50:55 <omie> Hi ! Need some help
21:51:33 <omie> I am trying to read from a text file [twitter feed] and then do some processing
21:52:19 <omie> on each line in input file its like [number|name|tweet]
21:52:49 <omie> there are some duplicate records where number part is same. I wish to remove those records
21:53:07 <Zao> Parse each line, stick them in a Map or something?
21:53:09 <omie> I have got to read file line by line, split it at '|'
21:53:37 <dmwit> omie: What have you tried?
21:53:58 <omie> thing I am not getting is how to store this each line so that I can search through them for duplicates
21:54:37 <shachaf> omie: How do you have them now? A list?
21:54:41 <dmwit> What have you got so far?
21:54:42 <omie> dmwit: I've been trying for quite a few hours now, tried different ways with lists without getting what I want.
21:54:55 <dmwit> ?hpaste
21:54:55 <lambdabot> Haskell pastebin: http://hpaste.org/
21:55:09 <omie> what I have now is number of functions while trying 2-3 different logics. wait I'll paste
21:56:19 <omie> http://hpaste.org/45930/pune
21:56:40 <mzero> okay
21:56:46 <mzero> first you want to learn the function    lines
21:56:48 <mzero> :t lines
21:56:49 <lambdabot> String -> [String]
21:57:01 <omie> this is my first try with haskell and I am thinking bit like how I would do it In C. I just want to get to know syntax etc
21:57:29 <mzero> well, you can't really attack it like C
21:57:31 <omie> first try as in first meaningful program.
21:57:54 <dmwit> omie: Why not define a data type representing a single line?
21:58:00 <mzero> for example, the bulk of your code is probably equivalent to this
21:58:15 <omie> I tried with datatype ones
21:58:23 <gnut> hi all
21:58:23 <dmwit> omie: Something like "data Twitter = Twitter { id :: Integer, nick :: String, contents :: String }"?
21:58:27 <shachaf> omie: Which introduction to Haskell are you reading?
21:58:28 <omie> but I didnt get few things
21:58:38 <mzero>  group $ sort $ map (break (=='|')) $ lines
21:58:40 <omie> I've got a book in hands, RWH
21:58:51 <gnut> how does one go about making shared libraries that other haskell code can link to?
21:59:02 <gnut> using runghc and cabal
21:59:16 <omie> shachaf: RWH
21:59:20 <dmwit> omie: Cool, definitely let us know any specific questions you have about how to use a data type. What things didn't you get?
21:59:51 <shachaf> In general things in the (GHC) Haskell world tend to be statically linked.
22:00:09 <gnut> I've written code before, and used "runghc Setup.lhs install" to register the package and was able to import in when making static executables. But this time, I want to make dynamic executables, but I can't seem to be able to get runghc to make dynamic executables that other code can link to.
22:00:26 <omie> dmwit: I made a data type similar to you said. but How can I do something like : read Line > init datatype object > append to list. later access each datatype object and access its elements ?
22:00:46 <shachaf> solidsnack presented something about dynamic linking yesterday, apparently.
22:00:48 <shachaf> https://github.com/solidsnack/hso
22:01:07 <gnut> I've tried ghc-options: -dynamic, but it doesn't make a .dyn_hi file
22:01:18 <gnut> only .hi files
22:01:26 <mzero> er    readFile "pInput.txt" >>= writeFile "pOutput.txt" . unlines . process  . lines
22:02:01 <mzero> omnie --- so that basically reads the whole file, splits it into lines, processes it, puts the lines back together and writes it
22:02:11 <omie> I had 2 things in mind. Either make it like LinkedList in C or have a hashtable with Number>otherDeatails. so if Number exists in Hashtable, dont add new record at that key
22:02:22 <dmwit> ?let splitAll p [] = []; splitAll p xs = case break p xs of (x, rest) -> x : splitAll p rest
22:02:22 <lambdabot>  Defined.
22:02:30 <mzero> then you can focus on writing process :: [String] -> [String]
22:02:32 <dmwit> > splitAll (=='|') "a|b|c"
22:02:34 <lambdabot>   ["a","","","","","","","","","","","","","","","","","","","","","","","","...
22:02:44 <omie> mzero: I need to use some sort of data structure because later I also need to sort data
22:02:46 <dmwit> > break (=='|') "a|b|c"
22:02:47 <lambdabot>   ("a","|b|c")
22:02:55 <dmwit> ?undefine
22:03:05 <mzero> that's okay - you can do that in process
22:03:11 <dmwit> ?let splitAll p [] = []; splitAll p xs = case break p xs of (x, rest) -> x : splitAll p (drop 1 rest)
22:03:12 <lambdabot>  Defined.
22:03:18 <mzero> but all that file handling (and gunk in IO) can be gotten out of the way first
22:03:22 <dmwit> > splitAll (=='|') "a|b|c"
22:03:24 <lambdabot>   ["a","b","c"]
22:03:32 <gnut> shachaf: thanks. I'll take a look at that link. I know the dynamic linking stuff is pretty new. I've been exploring it. Maybe what I'm asking for is not possible, but I'd like to see if it is.
22:03:33 <dmwit> omie: How about something like this?
22:03:57 <omie> well, I am trying this program http://punetech.com/apply/ [I've done it before in C/c# etc but just want to do it haskell]
22:03:58 <dmwit> > case splitAll (=='|') "a|b|c" of [id, nick, contents] -> (read id, nick, contents) :: (Integer, String, String)
22:04:00 <lambdabot>   (*Exception: Prelude.read: no parse
22:04:14 <dmwit> > case splitAll (=='|') "111|dmwit|I love Haskell!" of [id, nick, contents] -> (read id, nick, contents) :: (Integer, String, String)
22:04:16 <lambdabot>   (111,"dmwit","I love Haskell!")
22:04:28 <dmwit> omie: But instead of a tuple, use your data. =)
22:05:56 <gnut> shachaf: I looked at solidsnack's link, and I understand what he was able to do to make a shared library. I've done that before. I guess what I'm asking is, how do you do it so that it exports modules that you can later import in other code.
22:07:38 <dmwit> omie: After the parsing, all the processing should be fairly simple.
22:08:55 <omie> dmwit: yeah, its really simple. thats why trying this as my first Haskell adventure :-D
22:09:16 <dmwit> You're well on your way.
22:09:22 <omie> but i hate this when it happens :-S Got to go, some urgent work :-( I'll get back to this in few hours, will try more and ask here if I still have doubts.
22:09:27 <dmwit> Good.
22:09:34 <dmwit> There's lots yet to learn for you. =)
22:10:14 <omie> cya all, have a good day/night. and thanks :)
22:17:08 * hackagebot safecopy 0.5 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.5 (DavidHimmelstrup)
22:26:46 <xrl> I'm reading in a number (ascii-encoded) from a file and the number is separated by new lines... how do I filter out the new lines and convert that String IO to a plain ole String?
22:27:20 <xrl> all the stuff about reading from files I'm seeing talks about applying transformations and using putStrLn'
22:28:21 <Rotaerk> xrl, to have separation you need to have more than one thing
22:28:31 <Rotaerk> if you've got ... a number, what's it separated from?
22:29:23 <xrl> the characters are like this: "12345\n67890\n12345"
22:29:39 <xrl> I want "12345678912345"
22:30:25 <danharaj> I don't like the Vec package for low dimensional linear algebra. The errors I get when I make a type mistake remind me of C++ template errors.
22:30:26 <Rotaerk> seems like an odd format for a single number
22:30:33 <danharaj> Anyone have experience with an alternative?
22:30:51 <mzero> xrl: filter (/='\n')
22:30:52 <ski> > filter (/= '\n') "12345\n67890\n12345"
22:30:53 <lambdabot>   "123456789012345"
22:30:56 <Zao> > let s = "12345\n67890\n12345" in filter isDigit s
22:30:57 <lambdabot>   "123456789012345"
22:31:20 <dons> danharaj: hah
22:31:21 <mzero> xrl: is that really what you are ultimately after? Or did you really want a list of numbers?
22:31:34 <ski> > lines "12345\n67890\n12345"
22:31:35 <lambdabot>   ["12345","67890","12345"]
22:31:35 <dons> > words "12345\n67890\n12345" 
22:31:36 <lambdabot>   ["12345","67890","12345"]
22:31:48 <Zao> I'm guessing that the use case is: "I've copied a big number from a terminal and got newlines all over it, lol"
22:31:52 <Zao> (I've had that)
22:31:53 <xrl> ahh, words is handy too, then I can concat
22:32:30 <mzero> xrl: if you really want all the characters together without the newlines, filter will be more direct than concat . words
22:32:57 <mzero> but it sort of matters what stance you need/want to take to other random whitespace in the file
22:33:00 <mzero> er, string
22:33:04 <xrl> so I'm reading in the contents using 'let contents = readFile "prob7.txt"'
22:33:08 <danharaj> I guess I'll try Vect now.
22:33:12 <danharaj> I love library roulette :[
22:33:27 <xrl> and now I'm having type issues... do I need to use something like withFile?
22:33:27 <ski> xrl : you want `contents <- readFile "prob7.txt"'
22:33:36 <xrl> ah
22:34:01 <Zao> In your line, contents is an IO action representing the task of reading the contents of the file.
22:34:28 <ski> xrl : with `let contents = readFile ...', `contents' will have type `IO String'; but with `contents <- readFile ...', `contents' will have type `String'
22:34:28 <Zao> It won't actually do it until you use it in a context where it's performed, yielding the result.
22:34:32 <xrl> so I could use my version of contents, say, "realContents <- contents"?
22:34:37 <ski> yes
22:34:42 <xrl> nifty
22:34:44 <Zao> Ignoring the bad names, yes :D
22:35:01 <xrl> I revel in 'em
22:35:02 <Rotaerk> reallyRealContents
22:35:25 <ski> the `let' just gives a name to the action of reading a file into a string, it doesn't perform that action
22:35:31 <mzero> noReallyThisOneIsTheRealContents
22:38:48 <xrl> so I'm trying all these things out here's the problem: https://gist.github.com/936132
22:39:40 <xrl> I thought the "<-" did the action and got me a string?
22:39:41 <Zao> What's the type of applyToFile?
22:39:51 <shachaf> "contents" might be called something like "getContents".
22:40:09 <Zao> Or rather, what does show expect to be called with?
22:40:57 <Zao> @type putStrLn $ show $ ?x
22:40:58 <lambdabot> forall a. (Show a, ?x::a) => IO ()
22:41:15 <xrl> how can I easily put that applyToFile definition in a ghci session?
22:41:39 <Zao> show expects something Show-able. IO t  values, aren't.
22:42:01 <ski>   let applyToFile filename = do {contents <- readFile filename; removeNewLines contents}
22:42:03 <shachaf> do { notation <- can; be typed in one line; like this }
22:42:36 <xrl> but removeNewLines returns a string and it's the last thing called in the do... so applyToFile returns a string
22:42:45 * xrl runs off to put the def into ghci
22:42:46 <ski> no
22:43:03 <ski> `do {contents <- readFile filename; ...}' must have type `IO Something'
22:43:35 <ski> and thus the last line in that must have type `IO Something', so putting `removeNewLines contents' (a `String') is a type error
22:44:46 <ski> you can replace `removeNewLines contents' with `return (removeNewLines contents)' (which has type `IO String'), and the type error in `applyToFile' disappears
22:45:56 <xrl> why do I need to explicitly call return?
22:46:09 <ski> because `removeNewLines contents' is a `String'
22:46:25 <ddarius> xrl: There are no implicit calls to return.
22:46:31 <ski> the last command in that `IO'-`do'-block must have type `IO Something', for some type `Something'
22:46:33 <Zao> @type return
22:46:35 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:46:48 <Zao> return takes a value and gives it a fluffy monadic wrapper.
22:47:22 <xrl> so when I write "removeNewLines = filter (/= '\n') " isn't that implicitly... returning something?
22:47:24 <ski> if you want that `IO'-action to yield that `String' as result, you can use `return' to convert the result to a final `IO'-action which you can put in there
22:47:55 <xrl> return is for IO stuff.
22:47:57 <Zao> xrl: You should make a difference between "return" the function and "return" as in returning.
22:48:19 <xrl> Zao: ok, I'll noodle on that
22:48:31 <Zao> All expressions evaluate to something.
22:48:39 <Zao> Whether it's a regular value, a monadic value, or something fancier.
22:49:14 <Zao> You need return to lift a  t  into a  m t  
22:49:19 <Zao> For example, IO t.
22:49:20 <ski> there is a difference between an expression (e.g. of type `String', or `IO Int' or ...) evaluating to a value, and an action (here `IO'-action), of type `IO String' say, yielding a `String' whenever performed/executed
22:50:11 <Zao> @type (return 3) :: Maybe Int
22:50:12 <lambdabot> Maybe Int
22:50:26 <ddarius> xrl: return is just a normal function.  There is absolutely nothing special about it.
22:51:12 <xrl> ddarius: ah, that helps too... I thought it was more akin to imperative languages where the stack is popped
22:51:30 <Zao> It unfortunately shares a name with the return keyword of silly languages.
22:51:44 * xrl rolls eyes
22:51:45 <xrl> ;)
22:52:04 <Zao> > fromJust $ do { return 42; return 3 }
22:52:05 <lambdabot>   3
22:52:26 <ski> `return' just converts any value into an `m'-action (for any monad `m') that, when executed, does nothing, and then yields back the original value
22:52:33 <xrl> has return 42 'done' anything?
22:52:39 <ski> nothing
22:52:40 <nanothief> I wish return was renamed to wrap, as it doesn't have the annotations return has from other languages
22:52:45 <ski> i.e. saying
22:52:47 <ski>   do ...
22:52:52 <ski>      x <- return 42
22:52:55 <ski>     foo x
22:52:58 <ski> is the same as
22:52:59 <ski>   do ...
22:53:00 <Zao> nanothief: I use pure, just to annoy people when used outside of its context.
22:53:02 <ski>   foo 42
22:53:14 <danharaj> I prefer unit
22:53:43 <Zao> xrl: It has done something, it just didn't have any side effects.
22:54:02 <ski> (s/side effects/effects/)
22:54:58 <Zao> It desugars to (return 42) >> (return 3)
22:55:00 <xrl> it was just a bystander in the work being done by the function?
22:55:20 <Zao> That is, evaluate the LHS, discard the result, result in the RHS.
22:55:36 <Zao> I'll leave the explanation of desugaring to someone who likes to :D
22:55:38 <xrl> so a compiler would probably optimize it out, right?
22:55:50 <ski> @undo do { return 42; return 3 }
22:55:50 <lambdabot> return 42 >> return 3
22:56:09 <ski> @pl return 42 >> return 3
22:56:09 <lambdabot> return 3
22:56:32 * xrl is happy to get a string out of all this ;)
22:56:39 <Zao> The nice thing about sequencing is that you have control over the order things are performed.
22:56:59 <ski> `return 42 >> return 3' is the same as `return 42 >>= \_ -> return 3' (by definition of `>>'), which is the same as `(\_ -> return 3) 42' (by a monadic law)', which is the same as `return 3'
22:57:32 <ski> xrl : anyway, wrap `removeNewLines contents' in `return'
22:57:44 <ski> then you need to sort out another type error in `main', as well
22:58:02 <xrl> yup, I'm poking at that one
22:58:27 <ski> (also, why are you trying to use `show' at all ?)
22:58:45 <xrl> I already took it out but still it complains about the IO type
22:59:01 <xrl> Couldn't match expected type `[Char]' with actual type `IO [Char]'
22:59:07 <ski> yes
22:59:27 <ski> `applyToFile "prob7.txt"' has type `IO String'
22:59:37 <ski> (`[Char]' is the same as `String')
22:59:44 <xrl> yup
22:59:56 <ski> but `putStrLn' expects a `String' as input
23:00:02 <ski> not an `IO String'
23:00:11 <ski> (this is assuming you've removed `show')
23:00:41 <xrl> so I need to evaluate applyToFile "prob7.txt" to make it actually read the file
23:00:51 <ski> s/evaluate/execute/
23:00:59 <ski> (or "perform", if you prefer)
23:01:05 <ski> but yes
23:01:07 <xrl> ya, that one... all I want to do is pop it open and get rid of the IO :)
23:01:17 <ski> yeah .. so try another `do'-block ?
23:02:20 <xrl> so I'm a little lost on how to use do blocks... should I have main = do?
23:02:29 <ski> that would work
23:02:30 <xrl> (which doesn't work)
23:02:41 <ski>   main = do
23:02:41 <xrl> is this indentation sensitive?
23:02:44 <ski>     .. code here..
23:02:46 <ski> yes
23:02:54 <xrl> 2 spaces?
23:03:14 <ski> as many as you like, but at least one, and the same amount on each command inside the `do'-block
23:03:30 <ski> you can also do
23:03:33 <ski>   main = do ...
23:03:36 <ski>             ...
23:03:36 * xrl won't be writing PEGs to read haskell
23:04:12 <danharaj> hmm, how can I get the rawest representation of a tuple of monomorphic values possible from GHC?
23:04:39 <danharaj> Like, all the values are stored in a contiguous array.
23:06:38 <xrl> I updated my gist: https://gist.github.com/936132 ... are we on the same page? the main = do block isn't executing
23:08:14 <ski> `applyToFile "prob7.txt"' still is an `IO String', while `putStrLn' wants a `String'
23:08:53 <ski> try something like `longString <- applyToFile "prob7.txt"' as a separate command to perform that action first
23:09:30 <xrl> I need to use '<-' to actually perform the action? so why am I putting this in a do block?
23:09:55 <ski> (just saying `do <a single expression>' is the same as `<a single expression>' as you noticed -- to make `do' actually "do" something, you need at least two commands in there)
23:10:18 <ski> because `<-' (for this purpose) can only be used inside  `do'-block
23:10:38 <xrl> oh jeez... and do blocks don't use "where" ;)
23:10:57 <xrl> shazzam! it works!
23:11:03 <xrl> ski: my hero
23:12:18 <ski> btw, note that
23:12:27 <ski>   main = do
23:12:33 <ski>      longString <- applyToFile "prob7.txt"
23:12:33 <xrl> so there's a way to 'curry' do blocks? only evaluate some of the actions inside of them?
23:12:36 <ski>      putStrLn longString
23:12:38 <ski> is the same as
23:13:12 <ski>   main = applyToFile "prob7.txt" >>= \longString ->
23:13:14 <ski>          putStrLn longString
23:13:19 <ski> which is the same as
23:13:27 <ski>   main = applyToFile "prob7.txt" >>= putStrLn
23:13:27 <ski> which is the same as
23:13:29 <xrl> ahh, that's the sequencing thing Zao was talking about
23:13:36 <ski>   main = putStrLn =<< applyToFile "prob7.txt"
23:13:52 <xrl> so if you use =<< it implies a do block...
23:14:01 <ski> (which is closer to what you originally had written)
23:14:03 <ski> `=<<' is just a function
23:14:30 <ski> `do'-blocks desugar to `(>>=)' (and `(=<<)' is just `flip (>>=)')
23:14:45 <xrl> ahhh
23:14:55 <ski> @undo do {longString <- applyToFile "prob7.txt"; putStrLn longString}
23:14:55 <lambdabot> applyToFile "prob7.txt" >>= \ longString -> putStrLn longString
23:15:02 * ski smacks lambdabot
23:15:06 <ski> ok
23:15:11 <ski> @. pl undo do {longString <- applyToFile "prob7.txt"; putStrLn longString}
23:15:11 <lambdabot> putStrLn =<< applyToFile "prob7.txt"
23:15:44 <ski> you should use whichever of these forms you consider more readable
23:17:59 <ski> in the former, you need to invent a new variable name, so it's more wordy, but sometimes that helps readability
23:18:01 <ski> the latter is more concise
23:18:01 <ski> btw, i'm not sure what you mean by "'curry' do blocks"
23:18:45 <xrl> I could only force the execution of some IO actions then leave the others to be done later
23:19:25 <xrl> I like the "main = putStrLn =<< applyToFile "prob7.txt""... nice for one liners
23:19:29 <ski> do you have an example ?
23:20:53 <xrl> any example would be convuluted... but say you read a file and opened a socket. then you evaluate that later to write to the socket. uhhh.
23:21:06 <Zao> xrl: Return a tuple of the result and an IO action?
23:21:14 <xrl> ya, I guess so
23:21:31 <Zao> (result, continuation) <- do'it
23:21:44 <ski>   foo :: FilePath -> Something -> IO (Result,IO OtherResult)
23:22:41 <xrl> I will have to conceptualize the do block a little better... I wasn't expecting a tuple so much as a plain-jane IO
23:23:07 <ski> (that would give an `IO'-action that reads from a file and opens a socket, and yields a `Result' and a new `IO'-action that you can run later to let it do something more (like write to the socket))
23:23:09 <xrl> thanks for the help everyone
23:23:37 <ski> `do'-blocks are just sugar for `(>>=)' (and `(>>)')
23:23:41 <xrl> ski: I think that makes more sense than my plan
23:23:46 <ski>   (>>=) :: IO a -> (a -> IO b) -> IO b
23:23:52 <ski>   (>>) :: IO a -> IO b -> IO b
23:24:16 <ski>   action0 >> action1  =  action0 >>= \_ -> action1
23:24:34 <xrl> ahhh, so you have to escape the _
23:24:49 <ski> no
23:24:57 <xrl> haha
23:25:17 <ski> `\x -> ..x..' is the function that given any input (call it `x'), will compute `..x..' as result
23:25:44 <ski> here we used `_' instead of `x', because we don't care about that input (which is the result yielded by `action0')
23:26:03 <xrl> oh jeez, what a weird name for a function
23:26:06 <ski> you've seen "anonymous functions" before, right ?
23:26:10 <xrl> yup
23:26:19 <ski> > let square x = map square [0,1,2,3]
23:26:20 <lambdabot>   not an expression: `let square x = map square [0,1,2,3]'
23:26:33 <ski> > re x = x * x  in  map square [0,1,2,3]  -- er
23:26:33 <lambdabot>   <no location info>: parse error on input `='
23:26:43 <ski> > let square x = x * x  in  map square [0,1,2,3]  -- *sigh*
23:26:43 <lambdabot>   [0,1,4,9]
23:26:54 <ski> > map (\x -> x * x) [0,1,2,3]
23:26:55 <lambdabot>   [0,1,4,9]
23:27:12 <ski> so `\x -> x * x' is a value, which is a function
23:27:24 <xrl> ahh, that's why I could never get something like "(a b = a+b) 3 4" to work
23:27:40 <ski> `square x = x * x' just names the function value. you could say `square = \x -> x * x' instead
23:27:55 <ski> > (\a -> \b -> a + b) 3 4
23:27:56 <lambdabot>   7
23:27:57 <ski> > (\a b -> a + b) 3 4
23:27:58 <lambdabot>   7
23:27:58 <xrl> and now I have an arrow that goes another direction
23:28:50 <ski> so, going back, `>>=' wants a function as right argument
23:28:50 <ski> so `action0 >>= \_ -> action1' is `(>>=) action0 (\_ -> action1)'
23:29:02 <cnonim> hello
23:29:22 <ski> xrl : you mean in the `do'-block ?
23:29:30 <ski> hello there, cnonim
23:29:48 <cnonim> how i can convert Monad m => [m a] -> m [a] ?
23:29:49 <xrl> when you define the anonymous function you have the arrow going a different than in the do block
23:29:56 <ski> cnonim : `sequence'
23:30:00 <ski> @type sequence
23:30:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:30:10 <cnonim> thx
23:30:30 <ski> cnonim : also note that `sequence (map foo xs)' is the same as `mapM foo xs'
23:30:52 <ski> xrl : yeah .. consider those two arrows unrelated
23:30:57 <cnonim> ok )
23:31:03 <xrl> ski: will do ;)
23:31:13 <xrl> I'm copy pasting this chatlog for future reference...
23:31:37 <cnonim> mmmm, Monad m => (m a, m b) -> m (a, b) ?
23:31:38 <ski> (often, but not always, when people have `[m a]' but wanted `m [a]', they used `map' before, and so really wanted to use `mapM')
23:31:42 <ski> (or `forM')
23:31:56 <ski> @type uncurry (liftM2 (,))
23:31:56 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
23:32:07 <ski> @type liftM2 (,)
23:32:08 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
23:32:08 <xrl> ski: thanks for the help... I must be going now
23:32:12 <ski> ok
23:32:17 <ski> cnonim : ^
23:32:46 <cnonim> ) cool
23:32:49 <ski> @type map
23:32:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:32:51 <ski> @type mapM
23:32:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:32:54 <ski> @type forM
23:32:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
23:33:03 <cnonim> thx
23:33:48 <ski> (also there's `mapM_'/`forM_' if you want to perform something on every element on a list, but don't want a list of results back)
23:33:53 <ski> @type mapM_
23:33:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
23:33:56 <ski> @type forM_
23:33:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
23:34:02 <ski> @type sequence
23:34:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:34:03 <ski> @type sequence_
23:34:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
23:36:38 <cnonim> may be, Monad m => [a] -> m [a] ?
23:36:58 <ski> `return' would fit
23:37:25 <cnonim> exactly )))))
23:37:51 <ski> `\_ -> return []' would also fit
23:38:13 <ski> (and `return . reverse', &c.)
