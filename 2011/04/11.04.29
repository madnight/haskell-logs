00:48:10 <gio123> ezyang: hi
00:48:27 * hackagebot mysql-simple 0.1.0.0 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.1.0.0 (BryanOSullivan)
00:51:44 <gio123> doe anyone knows HINDLEY book on lambda calculs?
00:56:27 <Kerris> I feel like I'm not quite grokking the syntax
00:56:29 <Kerris> map (let x = (if x == 0 then True else False)) [0, 1]
00:56:55 <c_wraith> yep, that's not getting the syntax.
00:57:04 <c_wraith> when used as an expression, let requires an in
00:57:10 <c_wraith> Oh.
00:57:15 <c_wraith> I think you actually want a lambda there
00:57:40 <c_wraith> > map (\x -> if x == 0 then True else False) [0, 1]
00:57:40 <lambdabot>   [True,False]
00:57:50 <c_wraith> However, that's doing about 4x as much work as you need to
00:58:10 <Kerris> what's the simple way?
00:58:16 <Kerris> I assume it's "simple" vs "terse"
00:58:17 <c_wraith>   if blah then True else False -> blah
00:58:37 <c_wraith> > map (\x -> x == 0) [0, 1]
00:58:38 <lambdabot>   [True,False]
00:58:56 <Kerris> mind == blown
00:59:00 <c_wraith> and you can go further, but that introduces some new syntax
00:59:16 <koeien> > map (== 0) [0, 1]
00:59:16 <lambdabot>   [True,False]
00:59:23 <c_wraith> if you're ever returning True or False from the branches of an if, you're going out of your way to make things hard for yourself :)
00:59:28 <Kerris> welp, I guess I need to shake off the OCaml head::tail pattern matching way of thinking
01:00:04 <Kerris> ahahaha map (== 0) [0, 1], that's beautiful
01:00:12 <c_wraith> and yes, koeien pointed out an additional bit of syntax...  operator sections.
01:00:16 <gio123> doe anyone knows HINDLEY book on lambda calculs?
01:00:18 <c_wraith> They partially apply an operator
01:00:24 <koeien> > map (+ 60) [0,2,3]
01:00:25 <lambdabot>   [60,62,63]
01:00:31 <c_wraith> In a way that's pretty obvious, once you see them :)
01:01:09 <koeien> but pattern matching is also heavily used in Haskell. If you're used to OCaml that'll help for sure
01:01:09 <c_wraith> > map (/ 5) [1..10]
01:01:10 <lambdabot>   [0.2,0.4,0.6,0.8,1.0,1.2,1.4,1.6,1.8,2.0]
01:01:26 <c_wraith> > map (5 /) [1..10]
01:01:27 <lambdabot>   [5.0,2.5,1.6666666666666667,1.25,1.0,0.8333333333333334,0.7142857142857143,...
01:01:49 <ion> > map (5 /) [1..10] :: [Rational]
01:01:50 <lambdabot>   [5 % 1,5 % 2,5 % 3,5 % 4,1 % 1,5 % 6,5 % 7,5 % 8,5 % 9,1 % 2]
01:02:22 <Kerris> holy moly
01:02:30 <Kerris> this is beautiful stuff
01:03:27 <ion> Even though head:tail pattern matching is used a lot in Haskell, the first parameter to map doesn’t know about anything else than a single item of the list at a time.
01:03:48 <ion> map itself can be implemented in terms of such pattern matching:
01:03:49 <ion> @src map
01:03:49 <lambdabot> map _ []     = []
01:03:49 <lambdabot> map f (x:xs) = f x : map f xs
01:04:41 <Kerris> that's something familiar
01:05:19 <c_wraith> yes, it should look almost the same as an implementation of map in any of the MLs.  Only some syntax differences.
01:05:35 <c_wraith> But, there are some differences in behavior...
01:05:48 <c_wraith> > map (*2) [1..]
01:05:49 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
01:05:53 <ion> To make the sections sugar explicit, (* b) where * is any operator stands for \a -> a * b, and (a *) stands for \b -> a * b
01:06:01 <c_wraith> It actually does something useful when given an infinite list :)
01:06:11 <shachaf> Kerris: It's not as if you'd use "let" in OCaml.
01:06:26 <shachaf> "List.map (fun x -> x == 0) [0;1]" is pretty much the same thing. :-)
01:09:41 <Kerris> Yeah, I need to familiarise myself with the syntax
01:10:55 <c_wraith> one of the things that threw me at first was that value definitions can be recursive, the same as functions.
01:11:01 <c_wraith> > let ones = 1 : ones in ones
01:11:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:11:55 <c_wraith> > let nats = 0 : map (+1) nats in nats
01:11:56 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:12:57 <ion> struct list { int head; struct list tail; }; … struct list ones; ones.head = 1; ones.tail = ones; list_foreach (ones, print_int);
01:13:57 <c_wraith> ion: that requires mutation to manage.  Though with C++ it wouldn't, thanks to the "this" keyword.
01:15:19 <ion> I just meant that linked lists referring to self aren’t really that special. Nothing would prevent C from supporting this: struct list ones = { 1, ones };
01:15:21 <c_wraith> ion: but in either of those case, the value isn't in scope for reference by its own name during its own initialization
01:16:08 <c_wraith> true, nothing would prevent that...  But it's not done in most langauges.
01:17:12 <c_wraith> also, the second example is *much* harder to do, as it's not creating a circular list.
01:17:14 <ion> Whoops, { int head; struct list *tail; }, and ones.tail = &ones. And list_foreach (&ones, …) :-)
01:17:28 <c_wraith> yeah, I was willing to ignore those, since your point was clear :)
01:17:39 <ion> Damn Haskell, makes one forget thinking about pointers. ;-)
01:18:25 <c_wraith> not true!  I had to do lots of stuff with Ptr a when I was playing with native bindings and bytestrings (via the low-level interface)! :)
01:18:30 <ion> heh
01:26:31 <koeien> i even allocated and freed memory in Haskell :)
01:28:40 <c_wraith> Well.  I allocated memory in Haskell.  Then I made it a ForeignPtr and set a finalizer on it to free it :)
01:29:01 <c_wraith> ..  Though I just noticed there's one function to do that in a single pass, that claims to be highly optimized in ghc
01:29:06 <c_wraith> so I should be using that, instead
01:42:59 <Remi_> Hello everybody
01:50:32 <Remi_> If someone have spare time, I'm Rémi, 18 years old, french student, learning haskell, and looking for some help through skype. I'll give my adress to anyone who propose me some help. I can speak english flently, but I'm not a native speaker. Thanks!
01:50:37 <Remi_> Nothing Ventured Nothing Gained, so... :)
01:50:48 <Remi_> Better to ask anyway!
01:51:06 <Remi_> fluently*
01:51:34 * hackagebot nano-cryptr 0.1.1.1 - A threadsafe binding to glibc's crypt_r function  http://hackage.haskell.org/package/nano-cryptr-0.1.1.1 (CarlHowells)
02:00:33 <koeien> Remi_: you might want to check for a local Haskell User Group. (Although the one in the Netherlands uses English as main language...)
02:00:46 <koeien> I suspect that in France that's not the case, if there is one there.
02:01:08 <Remi_> yes, in france, they must be 7 on the chan
02:01:16 <Remi_> and almost noone is responding :)
02:02:07 <pastorn> Remi_: hello
02:02:17 <Remi_> hello
02:02:34 <pastorn> skype is pretty annoying... use IRC
02:02:52 <Remi_> hm, becasue I were thinking of scrren broadcasting
02:03:04 <Remi_> to be more efficient in explaining my problems
02:03:20 <pastorn> Remi_: paste it
02:03:24 <pastorn> http://hpaste.org
02:03:29 <Remi_> ok, thanks
02:03:34 <Remi_> that's what I'll do
02:03:47 <pastorn> paste your code, any error and a small comment about what you want it to do
02:03:55 <Remi_> ok
02:04:06 <roconnor> > [product [9-i+1 .. 9] `div` product [1..i] | i <- [0..9]]
02:04:07 <lambdabot>   [1,9,36,84,126,126,84,36,9,1]
02:04:17 <roconnor> > [product [9-i+1 .. 9] `div` product [1..i] `mod` 9| i <- [0..9]]
02:04:18 <lambdabot>   [1,0,0,3,0,0,3,0,0,1]
02:04:30 <roconnor> > [product [9-i+1 .. 9] `div` product [1..i] `mod` 3 | i <- [0..9]]
02:04:31 <lambdabot>   [1,0,0,0,0,0,0,0,0,1]
02:04:32 <MasseR> Is there some documentation/reference/literature about good quickcheck properties?
02:04:47 <roconnor> > [product [8-i+1 .. 8] `div` product [1..i] `mod` 2 | i <- [0..8]]
02:04:48 <lambdabot>   [1,0,0,0,0,0,0,0,1]
02:06:18 <pastorn> MasseR: there's a paper, check the latest "haskell weekly news", it was linked there
02:06:30 <MasseR> Oh wow, just as I'd need it :P
02:06:52 <pastorn> apparently it's good, at least that's what was written in HWN
02:07:26 <MasseR> 179?
02:07:39 <pastorn> MasseR: check reddit :)
02:09:04 <pastorn> wait... maybe it wasn't hwn...
02:09:28 <MasseR> Good, I was already thinking I'm blind 'cause couldn't find it
02:10:22 <pastorn> it said something about the paper being the best one from 2000
02:11:10 <MasseR> Do you remember the title? For googling
02:11:54 <gio123> doe anyone knows HINDLEY book on lambda calculs?
02:14:49 <pastorn> MasseR: i'm pretty sure it's the 2000 paper: http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
02:15:16 <pastorn> but of course the chalmers faculty still hasn't gotten around to fix all those 404s
02:15:21 <MasseR> Grr
02:15:37 <MasseR> Well now I have the name, and can try to find it from somewhere else
02:17:06 <pastorn> and that page is probably quite useful too
02:17:16 <pastorn> Remi_: how's it going?
02:17:24 <MasseR> http://portal.acm.org/citation.cfm?doid=351240.351266 buy :/
02:17:36 * hackagebot primes 0.2.1.0 - Efficient, purely functional generation of prime numbers  http://hackage.haskell.org/package/primes-0.2.1.0 (SebastianFischer)
02:17:48 <Remi_> almost fine
02:17:54 <Remi_> when copypasting things
02:17:57 <pastorn> MasseR: MasseR i googled the entire title and found a pdf
02:17:59 <Remi_> I suddenly understood something
02:18:07 <pastorn> so no paste?
02:18:09 <Remi_> and I'm reading some docs right now :)
02:18:13 <Remi_> maybe soon
02:18:29 <Remi_> when I'll understand that I still don't understand
02:18:55 <pastorn> Remi_: i can suggest opening a private session with lambdabot
02:19:16 <Remi_> ok, thanks!!
02:19:19 <Remi_> for the advice
02:19:24 <pastorn> she has a command @src which i found extremely helpful when first learning haskell
02:19:28 <pastorn> @src length
02:19:28 <lambdabot> Source not found.
02:19:31 <pastorn> hehe
02:19:38 <pastorn> @src Data.List.length
02:19:39 <lambdabot> Source not found.
02:19:43 <pastorn> @src map
02:19:43 <lambdabot> map _ []     = []
02:19:43 <lambdabot> map f (x:xs) = f x : map f xs
02:20:31 <pastorn> Remi_: well, at least when i used @src i used it a lot, so the private session is to avoid spamming the channel :)
02:20:45 <Remi_> ok
02:21:08 <Remi_> can you tell me exactly what to do to create a private session with lambdabit?
02:21:13 <Remi_> bot*
02:21:16 <Botje> /query lambdabot
02:21:26 <Botje> that should open a new tab or window
02:21:29 <MasseR> Ha I think I found it! And uploaded to n900. Thanks
02:21:55 <Remi_> ok
02:22:13 <Kerris> How do I h:t? :( http://hpaste.org/46156/member0
02:22:56 <pastorn> Kerris: with parenthenseses? "(h:t)"?
02:24:23 <shachaf> Kerris: Remember, function application or things that look like function application have the tightest precedence. So f h:t is parsed as (f h):(t).
02:24:27 <Kerris> pastorn: I don't think I'm matching correctly for the tail
02:24:45 <shachaf> Kerris: You're pattern-matching correctly, you're just not handling the empty list case.
02:24:55 <Kerris> shachaf: yeah
02:25:06 <shachaf> Well, OK, you're not pattern-matching correctly. :-)
02:25:36 <Kerris> should I just put inset an "if length < 0 then false else let …"
02:25:43 <shachaf> You want to use either case of h:t -> ...; [] ->, or f [] = ...; f (h:t) = ...
02:25:54 <shachaf> Kerris: length is evil. Also, it's never less than zero.
02:26:15 <Kerris> I felt that using length wasn't very elegant
02:26:42 <shachaf> It's not just inelegant, it's wrong (that is, behaves differently).
02:26:49 <Kerris> o_O
02:26:56 <shachaf> evilLength
02:27:09 * shachaf hasn't slept in a while so he might be exaggerating.
02:37:06 <povman> Is there any way of breaking a running haskell program in a debugger?
02:37:39 <Kerris> thanks shachaf
02:38:29 <Kerris> http://hpaste.org/paste/46156/member0_annotation#p46157 seems to have done it
02:39:40 <shachaf> Kerris: Right. A shorthand is member0 [] = False; member0 (h:t) = ...
02:40:12 <shachaf> Also, h:t is usually called x:xs.
02:40:26 <shachaf> Also, you can name the function member'0' .
02:40:36 <ceii> eww
02:40:38 <ion> (I wouldn’t.)
02:40:52 <shachaf> The "eww" part is about writing a function that tests for '0' in the first place.
02:42:01 <shachaf> (member0 sounds like it tests for a Num of some sort.)
02:42:32 <Kerris> haha, I'm just teaching myself from "Discrete Mathematics Using a Computer"
02:42:42 <dmwit> ...or is the first in a longish sequence of membership functions.
02:42:51 <ion> kerris:
02:42:53 <ion> @where lyah
02:42:53 <lambdabot> http://www.learnyouahaskell.com/
02:43:00 <shachaf> Right, that too.
02:43:17 <augur> lyah lyah cthulhu fhtagn
02:43:31 <Kerris> ion: I know of LYAH. My discrete maths is next to non-existent so I thought I'd give this a go
02:44:50 <shachaf> Kerris: What's "this"?
02:45:04 <Kerris> "Discrete Mathematics Using a Computer"
02:45:14 <shachaf> I think ion's point was that the sorts of questions you're asking have been answered many times, including in that book.
02:45:32 <shachaf> So it's somewhat inefficient to ask a channel about it. :-)
02:46:29 <Kerris> I see, thanks.
02:46:33 * shachaf shouldn't speak for ion.
02:48:01 <Kerris> well, I'll shelve this book until I go through LYAH
02:49:31 <ion> It might be better to learn Haskell from a book dedicated to learning Haskell and discrete mathematics from a book dedicated to discrete mathematics instead of learning both Haskell and discrete mathematics from a book dedicated to discrete mathematics.
02:55:46 <Kerris> ion: would you have any recommendations on a discrete maths book?
02:56:09 <ion> I’m afraid i don’t.
02:59:36 <alderz> Kerris: http://stackoverflow.com/questions/817329/recommend-book-for-discrete-math
03:01:41 <Kerris> thanks alderz, that Rosen book looks pretty promising
03:32:41 <rostayob> @pl \s -> voteSubmission s up user
03:32:42 <lambdabot> flip (flip voteSubmission up) user
03:34:28 <pastorn> ion: sense - you make none ;)
04:28:08 <no_signal> hello all - is there a torrent for the mac haskell platform?
04:40:16 <da-x> > succ '\1114110'
04:40:17 <lambdabot>   '\1114111'
04:40:23 <da-x> > succ '\1114111'
04:40:23 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
04:40:31 <da-x> intriguing..
04:40:48 <daxxxx> hello
04:40:54 <daxxxx> nice to try haskell
04:40:58 <ion> > succ maxBound
04:40:58 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
04:41:01 <Kerris> no_signal: ntot as far as I know
04:41:05 <ion> > succ maxBound :: Integer
04:41:06 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
04:41:06 <lambdabot>    arising from...
04:41:08 <daxxxx> and i'm a bit curious about installing haskell on ubuntu lucid
04:41:22 <ion> > succ maxBound :: Int16
04:41:23 <lambdabot>   *Exception: Enum.succ{Int16}: tried to take `succ' of maxBound
04:41:27 <no_signal> ta Kerris
04:41:31 <daxxxx> is there any repository/ppa of it?
04:41:37 <no_signal> too late now anyway, almost finished
04:42:38 <da-x> > maxBound :: Char
04:42:38 <lambdabot>   '\1114111'
04:42:50 <da-x> that's the one. I wonder how that number in particular
04:43:10 <Kerris> daxxxx: it should be included in the default repos, but I don't know how up to date it'll be
04:43:42 <da-x> huh, http://primes.utm.edu/curios/page.php/1114111.html
04:44:36 <daxxxx> <Kerris> thanks, i'll give apt-get a try first. hope it already in the latest version :)
04:48:13 <ion> > (+1) maxBound :: Int16
04:48:14 <lambdabot>   -32768
04:50:11 <da-x> > succ 1.3
04:50:12 <lambdabot>   2.3
04:50:52 <da-x> I wouldn't have expected Float to be enumerable..
04:56:06 <da-x> > quot 3 (-2)
04:56:07 <lambdabot>   -1
04:56:11 <da-x> > div 3 (-2)
04:56:11 <lambdabot>   -2
04:56:38 <da-x> a subtle difference..
04:59:03 <maus> hi all, is there a way to make ghc derive NFData instances for my datatypes?
05:09:05 <crystal-cola> "a type theorist should not think of HITs as a weird or radical thing that the homotopy theorists dreamed up"
05:09:21 <crystal-cola> im not convinced...
05:15:45 <crystal-cola> Is there an IRC for homotopy type theory?
05:17:20 <blueonyx> hi, i'm using the CouchDB package which uses the Network.HTTP module and gives me the error: user error (internal error: server error: PUT http://foo.bar/baz...) how to fix/debug?
05:17:33 <blueonyx> but the request doesnt hit the webserver
05:27:27 <jim__> Hi, I'm having trouble with some Haskell syntax. http://hpaste.org/46159/generate_balanced_tree_from_li
05:27:30 <crystal-cola> http://creativelad.wordpress.com/2011/04/28/euclidean-division/ awesome
05:27:52 <crystal-cola> jim__: you can't modify things
05:28:11 <crystal-cola> jim__: if you want to call generateTree with myList and count+1 then do that :)
05:28:34 <jim__> ok, that's not my big problem... but I'll put that in now
05:28:47 <jim__> Leaf (myList!!count) is a valid Tree
05:28:48 <crystal-cola> jmcarthur++
05:28:52 <Lemmih> jim__: count++ looks weird.
05:29:02 <jim__> but, how do I do a Node?
05:29:30 <jim__> Node Node( something) Leaf (something)????
05:29:36 <jim__> very tired and confused noob here
05:29:53 <Lemmih> jim__: Node (Leaf 'a') (Leaf 'b') is a valid tree.
05:30:51 <jim__> ok, but what about if I need another Node because my Tree is larger.  eg Node (Node 'a') (Leaf 'b')????
05:30:56 <jim__> is that correct?
05:31:30 <Lemmih> jim__: No, Node takes two arguments. You could have: Node (Node (Leaf 'a') (Leaf 'b')) (Leaf 'c')
05:31:58 <jim__> ahhh ok..  I think I see where I'm going wrong.  Thanks :D
05:42:32 <wjt> i find myself jumping through hoops to turn a list of options returned by System.Console.GetOpt.getOpt. I like the general idea of the record-transformation-function approach documented at the end of <http://www.haskell.org/ghc/docs/7.0.3/html/libraries/base-4.3.1.0/System-Console-GetOpt.html> (I hadn't thought of returning a list of functions and composing them all); is there a library that does the boilerplate code there for me?
05:44:56 <wjt> cmdargs scares me a little
05:45:29 <navaati> hello
05:45:45 <navaati> are there users of leksah here ?
05:45:54 <navaati> (I know there are :-°)
05:46:10 <Kerris> navaati: are you wondering why the metadata indexing takes so long? :V
05:47:08 <navaati> no, i'm wondering if I can mv my .leksah-0.8 into a .leksah-0.10 without brokage
05:53:39 <ezyang> seems kind of dangerous.
05:54:38 <ion> Something like this might be neat for option parsing: data Options = Options { verbose :: Bool, name :: Maybe String, inputs :: [String] }; options :: OptParse Options; options = Options <$> verbose <*> name <*> inputs; verbose = optional False (bool ['v'] ["verbose"]) <?> "Be verbose"; name = optional Nothing (Just <$> string ['n'] ["name"]) <?> "The name"; inputs = many nonOption <?> "Inputs"
05:55:46 <jim__> I've updated my code. I'm pretty sure it's working, but get... cannot find "show" error: http://hpaste.org/paste/46159/show_error#p46161
05:56:00 <jim__> I think I know what it means, but how can I fix it?
05:56:15 <jim__> It doesn't know how to print a Tree I'm guessing.
05:56:28 <ezyang> add deriving (Show)
05:56:32 <ezyang> to the tree definition.
05:57:02 <jim__> ahhhh... thankyou :D
05:58:44 <jim__> I'll have to ask my lecturer if it's ok to have deriving (Show) on the end.
05:58:48 <jim__> of the definition
05:59:08 <jim__> Thanks again for your help.  Nice and friendly in #haskell
05:59:32 <gio123> ezyang: hi
06:00:41 <ezyang> jim__: I don't see why not.
06:04:44 <gio123> ezyang: I just have a simple question and that is alll, coul you come for 3 minute in blah
06:04:45 <gio123> ?
06:10:31 <crystal-cola> Does anyone here any idea about homotopy type theory
06:13:00 <tlevine> I couldn't figure out how to get the query string for a CGI script in Haskell. I'm currently using getInput to get the query string from stdin from a bash script. How do I do this in Haskell without the bash?
06:13:11 <tlevine> Here's the shell script http://hpaste.org/46162/getting_the_query_string_in_a
06:14:42 <ondra[sej]> tlevine> perhaps you're looking for System.getEnv
06:38:39 <FUZxxl> How can I install the documentation to a package into the docs at $PREFIX/share/doc/ghc/html/libraries?
06:38:43 <shintaku> i hate to sound like a broken record, but i never visit this channel and don't know the answer.  what's the most visited website written with a haskell web framework?
06:39:03 <FUZxxl> Is there a way to let cabal do this automagically?
06:39:56 <dcoutts> FUZxxl: no but it can generate a separate index covering all installed packages
06:40:50 <FUZxxl> dcoutts: After doing a plain haskell platform install all the documentation for all installed packages is installed at that place.
06:41:14 <FUZxxl> But if I install other packages by hand afterwards, their documentation is not listed there.
06:41:25 <dcoutts> FUZxxl: but I don't think you want cabal overwriting that
06:41:58 <FUZxxl> dcoutts: Ah, I see.
06:41:59 <dcoutts> FUZxxl: there's the doc-index-file item in the ~/.cabal/config
06:42:04 <FUZxxl> That is the index you talked about?
06:42:23 <dcoutts> that specifies a location where it can maintain an index of all installed packages
06:42:25 * hackagebot convertible 1.0.10.0 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-1.0.10.0 (JohnGoerzen)
06:42:41 <ukl> dear #haskell, I'm about to update my ghc and platform installation. My installed ghc is from the FreeBSD binary distribution, 7.0.2. Should I just "make install" the 7.0.3 binary distribution or is this the pathway to chaos?
06:42:55 <ukl> (analogous question for platform, btw)
06:43:33 <dcoutts> FUZxxl: so you could specify that to be the same location, but you'd need write permission and you'd have to accept it overwriting files installed by the HP, which is usually a bad plan
06:44:29 <FUZxxl> I installed ghc into my home tree. So the docdir is something like /home/fuzxxl/share/doc/
06:44:39 <FUZxxl> Permissions aren't a problem.
06:45:39 <dcoutts> FUZxxl: ok, go for it
06:45:52 <FUZxxl> dcoutts: What's the entry in cabals config-file?
06:45:59 <dcoutts> doc-index-file
06:47:41 <FUZxxl> So I add   doc-index-file: $data-dir/doc/ghc/html/libraries/index.html
06:47:53 <FUZxxl> into the section install-dirs global
06:48:20 <FUZxxl> Is this correct?
06:50:21 <Saizan> ukl: the directories are versioned as are most binaries, so it should mostly just work
06:51:05 <ukl> Saizan: thanks.  removing the old installation is a matter of seek and destroy, right?
06:51:13 <Saizan> ukl: you could ./configure --prefix=some/specific/prefix to be extra safe
06:51:26 * hackagebot HDBC 2.2.7.0 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.2.7.0 (JohnGoerzen)
06:52:34 <Saizan> ukl: yeah
06:52:48 <MasseR> Is .ghci always read from $HOME/.ghci or is it read like ie. .git (recursively go down directory path until .ghci is found)
06:52:51 <ukl> thanks for your help :)
06:53:17 <FUZxxl> MasseR: AFAIK always from there.
06:53:50 <Saizan> MasseR: i think it reads the one in the CWD if there's one
06:55:44 <MasseR> Saizan: Ok thanks
07:01:54 <da-x> is monoid has something related to an algebric group?
07:04:04 <da-x> okay, figured out it's called a semigroup.
07:04:30 <hpc> da-x: you might also like to see what a ring is :D
07:04:44 <FUZxxl> Hi again! When I tried to install gtksourceview2, I got this strange error: http://paste.ubuntuusers.de/400130/
07:05:44 <Saizan> FUZxxl: you've to install the C gtksourceview2 with your package manager or by hand
07:05:52 <FUZxxl> okay.
07:06:09 <Saizan> FUZxxl: the -dev version, if it's splitted
07:07:27 <FUZxxl> works like a charm. Thank you!
07:22:36 * hackagebot reactive-banana 0.2.0.3 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.2.0.3 (HeinrichApfelmus)
07:24:36 * hackagebot reactive-banana-wx 0.2.0.3 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.2.0.3 (HeinrichApfelmus)
07:39:33 <Optimo> copumpkin ;)
07:39:46 <copumpkin> ohai Optimo
07:39:47 <Optimo> god of pumpkins
07:40:02 <copumpkin> what brings you to these here parts?
07:40:11 <Optimo> I like to be where teh action is
07:40:17 <copumpkin> :)
07:40:21 <Optimo> and following this log is like a pschosis
07:40:43 <Optimo> I've yet to work with Haskell, however ;p
07:41:09 <copumpkin> :)
07:41:13 <Optimo> just the shear population here is intimidating
07:41:24 <copumpkin> lots of people like it or want to learn it!
07:41:34 <da-x> is there an IDE or some kind of an interactive environment where I can 'hover' or mark parts of a complex expression and to see the types of the sub-expression I marked?
07:41:56 <Zao> da-x: haskell-mode for vim supposedly has something along those lines.
07:42:19 <da-x> Zao: I'll look for an equivalent in emacs
07:42:19 <Optimo> copumpkin: for example, I idle'd in cappuccinno for 18 months before using it
07:42:22 <Zao> da-x: Phyx-'s mythical Visual Haskell extension for VS2010 can do it too, I belive, although there's no builds for that.
07:42:58 <copumpkin> Optimo: sounds good :P
07:43:01 <da-x> I'm trying to parse what I see in ' http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf ', the part where you have "sequence (c : cs) = return (:) ‘ap‘ c ‘ap‘ sequence cs" is quite hard for my mind to parse
07:43:03 <copumpkin> so in 18 months you can start hax0ring
07:43:31 <crystal-cola> da-x: you're supposed to think of it in a different way
07:48:38 <Botje> da-x: it's ((return (:)) `ap` c) `ap` sequence cs
07:48:58 <tromp_> :t join
07:48:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:49:17 <Botje> :t (return (:)) `ap` 5
07:49:17 <lambdabot> forall a (m :: * -> *). (Monad m, Num (m a)) => m ([a] -> [a])
07:51:39 <copumpkin> dons: congratulations!
07:52:11 <hpc> da-x: ap = (<*>) and "return f <*>" = "f <$>"
07:52:17 <shapr> dons: congrats!
07:52:26 <hpc> so you have sequence (c:cs) = (:) <$> c <*> sequence cs
07:52:34 <hpc> da-x: if that helps
07:53:05 <hpc> @src sequence
07:53:05 <lambdabot> sequence []     = return []
07:53:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:53:05 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:53:22 <da-x> still can't get my mind to wrap around it
07:55:20 <hpc> :t sequence
07:55:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:56:18 <hpc> da-x: so let's use the do-notation version of sequence
07:56:25 <hpc> da-x: the type we want for sequence is above
07:56:35 <da-x> hpc: I rewrote it as: sequencex (c : cs) = ap (ap (return (:)) c) (sequencex cs), now it starts to make more sense to me
07:56:49 <hpc> da-x: ah, cool
07:57:26 <da-x> I'm still not used to reading expressions with operator-style function usage
07:57:46 <hpc> da-x: yeah, i really don't like backtick notation either
08:00:34 <RSchulzB> They need to exist for interoperability with libraries that use defined names that are legal in Java but reserved in Scala.
08:00:42 <RSchulzB> Most people really don't like to use them.
08:01:08 <Optimo> in russia, backtick suck you
08:01:10 <RSchulzB> Oops!
08:01:12 <RSchulzB> Wrong tab!!
08:01:25 <copumpkin> oh my, an RSchulzB in #haskell
08:01:29 <RSchulzB> (And now I'm outed as a Scala guy...)
08:02:05 <copumpkin> RSchulzB: a fate worse than death!
08:02:15 <RSchulzB> I suspect I'll never live it down.
08:02:46 <ion> We’re supportive. Being here is the first step to recovery.
08:03:02 <RSchulzB> I've also heard FP folks have a good sense of humor...
08:03:18 <RSchulzB> Bein of above-average intelligence, and all...
08:03:40 <Kerris> haha, you're clearly an FP guy
08:03:47 <Kerris> ;)
08:03:57 <RSchulzB> You mean 'cause I can't spell?
08:04:03 <shapr> RSchulzB: From what I've seen, #haskell people are also aware Haskell is not the best proglang that will ever exist, thus we promote tolerance :-)
08:04:31 <RSchulzB> Aww… I was looking for more of a scorched-Earth kind of community.
08:04:34 <navaati> i don't think recovery is possible : once purity is lost, is it really possible regain it ? :-°
08:04:56 <hpc> navaati: it's easy! unsafePerformExorcism
08:05:19 <RSchulzB> I've heard purity can grow back if you don't do impure things for a long enough time. … Like virginity...
08:05:30 <Kerris> ahahaha
08:12:35 <sm_> morning!
08:12:49 <shapr> howdy sm_!
08:17:52 <dons> cheers guys
08:18:13 <copumpkin> we'll have to ship you up to boston regularly :D
08:19:14 <dons> hehe
08:21:08 <alpounet> congrats dons
08:36:59 <fenfrie> i can make system calls with system.cmd like nm,ls or something, but how can i read these results i get in the command line window?
08:38:32 <reacocard> fenfrie: i think you want system.process instead of system.cmd
09:15:14 <pmetzger> unimportant question of the day: officially, are constants actually nulladic functions?
09:15:46 <pmetzger> I see the thing on the left side of an = always called a function in documentation.
09:15:56 <djahandarie> No.
09:16:14 <djahandarie> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
09:16:51 <djahandarie> Except conal's blog doesn't seem to be loading for me
09:16:57 <sipa> everything is a value, including functions
09:17:04 <sipa> not everything is a function though
09:17:57 <copumpkin> pmetzger: the question is what would that even mean?
09:18:05 <copumpkin> and/or what would calling them nullary functions give us?
09:18:26 <pmetzger> I have no idea. I keep reading things that say stuff like "local functions are defined within a function using let" and such.
09:18:36 <pmetzger> while I would have more naturally thought of these as local bindings.
09:18:36 <mauke> well, they are
09:18:47 <pmetzger> with functions and constants both being things assigned names
09:18:50 <copumpkin> the simplest answer to "what is a function?" is "a value of the type (->) applied to two arguments"
09:19:09 <mauke> pmetzger: yes, that's a much better way to think of it
09:19:17 <mauke> except for the "functions and constants" part
09:19:19 * djahandarie uses "a value with (->) as the top-level constructor"
09:19:35 <pmetzger> so I don't get why so many documents speak of let or top level = or what have you as defining "functions" when they seem to just bind values (which may be functions) to names
09:19:47 <sipa> in C-speak, many people think a function can only be defined using a top-level definition, hence causing confusion between the term function and definition
09:19:52 <copumpkin> pmetzger: they're doing it wrong?
09:20:07 <djahandarie> pmetzger, because they aren't being fully general.
09:20:30 <mauke> djahandarie: I disagree
09:20:38 <sipa> but in Haskell, a function can be very clearly defined as a value of type (a -> b), and eg. (+5) is a function
09:20:49 <mauke> or do I?
09:21:22 <mauke> 'foo x = ...' is syntactic sugar for 'foo = \x -> ...' so in that sense '=' is responsible for creating a function
09:22:06 <djahandarie> foo = id   is still "binding a function", even though we aren't using the syntactic sugar
09:22:13 <pmetzger> so my original understanding was not in error, and things like top level definitions are binding values to names (with some values being functions) and this is just a case of confusing or incorrect documents.
09:22:14 * hackagebot happstack-helpers 0.54 - Convenience functions for Happstack.  http://hackage.haskell.org/package/happstack-helpers-0.54 (ThomasHartman)
09:22:21 <djahandarie> pmetzger, yes.
09:22:24 <pmetzger> cool.
09:22:29 <mauke> djahandarie: yeah, but it doesn't define a new function
09:22:50 <mauke> if we adopt the "functions are values" point of view
09:23:11 <mauke> up next: defining "define"
09:23:15 <djahandarie> What about foo = (+2). (+1)
09:23:28 <pmetzger> mauke: but functions clearly are first class values, so that's not an issue.
09:23:42 <djahandarie> I guess the composition would still introduce the lambdas
09:23:53 <mauke> djahandarie: (+2) . (+1) is a function, but '=' doesn't care
09:24:33 <pmetzger> now, next not-very-important question: are data constructors that take parameters functions?
09:24:41 <djahandarie> pmetzger, yes
09:24:54 <djahandarie> See: GADT notation for making this even clearer
09:25:04 <pmetzger> "GADT notation"?
09:25:11 <pmetzger> I'll google
09:25:11 <djahandarie> Generalized ADT
09:25:24 <djahandarie> A different way of writing data types, basically.
09:25:33 <mauke> data Maybe :: * -> * where Nothing :: Maybe a; Just :: a -> Maybe a
09:26:18 <pmetzger> and type constructors are not functions as such.
09:26:30 <djahandarie> Type constructors are functions on the type level.
09:26:37 <djahandarie> Just very limited functions
09:26:43 <mauke> some of them are :-)
09:26:53 <djahandarie> Some of them?
09:26:54 <pmetzger> but given that Haskell does not permit full on dependent types they're not fully general functions.
09:27:15 <mauke> djahandarie: Int
09:27:29 <djahandarie> mauke, that's not a type constructor, afaik
09:27:33 <djahandarie> It's just a type
09:27:36 <mauke> I say it is
09:27:40 <djahandarie> Hmm
09:27:45 <mauke> I also call Nothing a data constructor
09:27:51 <djahandarie> Okay
09:27:55 <djahandarie> Then I agree :)
09:28:19 <pmetzger> reading up on GADT notation, this is an implemented haskell extension?
09:28:21 <copumpkin> yeah, I'd call Int a type constructor too
09:28:25 <sipa> Int isn't a data constructor
09:28:25 <copumpkin> pmetzger: yes, I use it all the time
09:28:34 <copumpkin> {-# LANGUAGE GADTs #-}
09:28:35 <sipa> "Int" doesn't even (necessarily) exist at the value level
09:28:41 <mauke> data Sipa = Int  -- it is now
09:28:41 <djahandarie> sipa, you have misread.
09:28:43 <copumpkin> or -XGADTs if you prefer command-line parameters
09:28:45 <pmetzger> so I need to set a ghc flag for it to appear?
09:28:51 <Saizan> "type constructor"'s meaning got a weird spin with "constructor classes" meaning classes with higher-kinded parameters
09:29:01 <pmetzger> will it be in haskell' or whatever?
09:29:03 <sipa> djahandarie: ow, indeed :)
09:29:04 <shamster> does ghci (or haskell?) have a 'print-expression' output a la lisp/scheme to print unevaluated expressions?
09:29:14 <copumpkin> pmetzger: I sure hope so
09:29:31 <mauke> shamster: huh?
09:29:33 <crystal-cola> shamster: no
09:29:43 <pmetzger> other than making the types of the constructors more explicit, does it let you express something you couldn't express before?
09:29:51 <mauke> if you want to print unevaluated expressions, use cat instead of ghci
09:30:05 <djahandarie> pmetzger, you can get some pretty general functions on the type level without dependent types
09:30:17 <Saizan> someone has to submit proposals and follow them through to get things in haskell201x
09:30:20 <pmetzger> djahandarie: so it does allow more expressiveness.
09:30:23 <copumpkin> Saizan: pff
09:30:24 <shamster> mauke: I suppose I need an audience familiar with the lisp/scheme repl AND haskell
09:30:31 <copumpkin> Saizan: do you think proposing GADTs would pass?
09:30:47 <djahandarie> pmetzger, what is 'it'?
09:31:07 <pmetzger> djahandarie: GADT notation.
09:31:13 <Saizan> copumpkin: no idea :)
09:31:13 <thartman> I am trying to upgrade a package (happstack helpers) that is used locally by another happstack app. Before uploading to hackage I would like to confirm that the package works for compiling my other package. I have lots of problems with this because of "butterfly effect" in cabal I think
09:31:13 <thartman> When I do ghc-pkg info HAppSHelpers it tells me local version is 0.55 (which I haven't uploaded to hackage yet)
09:31:13 <thartman> but when I do cabal install for other app, with dependency on >=0.55, it says that version isn't available.
09:31:13 <thartman> Even though ghc-pkg says it is available.
09:31:13 <thartman> If I do cabal upload 0.55 version, now it's available
09:31:14 <thartman> So it's like it's looking online for a package before looking locally
09:31:14 <thartman> which means I have to spam hackage to move development forward
09:31:26 <mauke> holy flood
09:31:58 <djahandarie> pmetzger, it does, but not in respect that it gives you more powerful type functions. It only gives you more powerful types for your value-level functions
09:32:07 <djahandarie> You need to be able to lift data types into the type/kind layer if you want more powerful type-level functions
09:32:10 <djahandarie> Which is not possible yet
09:32:16 <djahandarie> (Without a preprocessor)
09:32:35 <pmetzger> djahandarie: can you point me at an example of more powerful types you can express with the GADT notation for the value level?
09:33:05 <pmetzger> It isn't a priori obvious to me how that is, but that's because I'm not used to thinking about this problem domain anyway.
09:33:07 <sm> yay thartman, hi
09:33:44 <djahandarie> pmetzger, 'safeList' is a nice one
09:33:55 <pmetzger> I presume I should hoogle for that.
09:34:02 <djahandarie> Yeah
09:34:13 <sm> cabal install --dry -v3 may help you figure out why it's rejecting your built package..
09:34:27 <pmetzger> no hoogle hits. I'll expand to google. :)
09:34:37 <djahandarie> Yeah, I don't think it's in a library
09:35:08 <djahandarie> data Empty; data NonEmpty; data SafeList a b where Nil :: SafeList a Empty; Cons :: a -> SafeList a b -> SafeList a NonEmpty;    is the definition, but that doesn't tell you much without reading the explaination :p
09:35:38 <ricree> I have a small program using WX.  It links and runs fine with ghc, but trying to run it in ghci I get "Loading package wxcore-0.12.1.6 ... can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)"  Any idea why that might be?
09:35:55 <sm> thartman: you could also wipe your installed packages (or find a fresh machine) and start again with a fresh slate
09:36:34 <sm> thartman: or use cabal-dev, which adds some complexity but should help
09:40:30 <pmetzger> djahandarie: is this a reasonable document for the explanation? http://en.wikibooks.org/wiki/Haskell/GADT
09:40:51 <poincare101> is there a mapreduce implementation on haskell? Since haskell is a functional language and mapreduce uses the functional pardigm, I think it would be quite a good chance.
09:40:53 <pmetzger> the bottom discusses safeList.
09:42:45 <djahandarie> pmetzger, yeah
09:50:17 <thartman> sm: thanks, dry run did help
09:50:21 * hackagebot mysql-simple 0.1.0.1 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.1.0.1 (BryanOSullivan)
09:50:24 <thartman> it's still a mess thbough
09:59:33 <djahandarie> bos++
10:00:26 * hackagebot heist-aeson 0.4 - Use JSON directly from Heist templates.  http://hackage.haskell.org/package/heist-aeson-0.4 (DavidHimmelstrup)
10:02:39 <poincare101>  is there a mapreduce implementation on haskell? Since haskell is a functional language and mapreduce uses the functional pardigm, I think it would be quite a good chance.
10:03:43 <djahandarie> You mean distributed computing?
10:04:31 <navaati> poincare101: there it map :: (a->b) -> ([a]->[b]) and there is foldl :: (a -> b -> a) -> a -> [b] -> a : here is your mapreduce :)
10:04:34 <djahandarie> I think someone wrote a thesis on it...
10:04:56 <djahandarie> navaati, that is not the "MapReduce" if he means Google's product
10:05:59 <djahandarie> poincare101, see "Holumbus" and Stefan Schmidt's thesis if you're really interested in doing MapReduce-style distributed computing in Haskell
10:06:03 <poincare101> navaati: that's not distributed
10:06:12 <poincare101> navaati: I need something like hadoop
10:06:15 <navaati> it maps, then it reduces :D
10:06:52 <navaati> doesn't the thing data parallel haskell enable this aswell ?
10:07:13 <djahandarie> DPH is for parallelism on a single machine, not distributed computing over a network.
10:08:18 <navaati> ah
10:08:54 <djahandarie> poincare101, it's possible Holumbus is too complicated if you're just starting out with Haskell though. Not sure of your level.
10:12:51 <leavengood> I'm hitting bug #5004 on Arch Linux trying to install snap with cabal
10:13:12 <leavengood> Does anyone have an unstripped libHSghc-7.0.2.a I could use?
10:13:38 <leavengood> The gist of the bug is that library being stripped causes the panic.
10:13:47 <mightybyte> leavengood: Try enabling the testing repo in your pacman.conf
10:13:58 <mightybyte> Then update ghc
10:14:05 <leavengood> alrighty
10:14:20 <mightybyte> ghc-7.0.2-2 fixes the bug
10:14:26 <djahandarie> monochrom, what was that crazy Java file you had that did pattern matching with exceptions?
10:14:51 <djahandarie> Aha, found it
10:15:05 <mightybyte> leavengood: You may want to be careful though.  I think the testing repo has Gnome 3, which you may not want to upgrade to.
10:15:35 <leavengood> mightybyte: thanks...I'll probably just install GHC then turn off the testing repo
10:15:44 <leavengood> I'm running xmonad anyhow :)
10:16:06 <KirinDave> So.
10:16:11 <KirinDave> http://www.silvertreksystems.com/checklist.html
10:16:22 <KirinDave> This is how you learn to program, in case you were interested.
10:16:26 * KirinDave drops the mic and walks off
10:16:33 <mightybyte> leavengood: If you have any snap-specific questions, we're usually pretty responsive in the #snapframework channel.
10:17:13 <leavengood> cool...I'm a Rails guy but want to really learn Haskell (tried a few times before) and Snap seems like a good way
10:17:17 <djahandarie> KirinDave, obviously missing 'Haskell' on that list ;)
10:17:46 <KirinDave> djahandarie: And good sense.
10:18:32 <djahandarie> I suppose. That list sounds like it'd be really popular with most of the hip web developers these days though
10:19:30 <leavengood> hehe
10:20:08 <leavengood> I've been wanting to try to turn my veterinarian fiance into a Rails person, that list should be perfect :)
10:20:16 <KirinDave> Oof
10:21:05 <Saizan> is that list serious?
10:21:08 <Jafet> I think that joke was overdone.
10:21:46 <djahandarie> Saizan, yes
10:22:30 <Jafet> Are you sure?
10:22:51 <djahandarie> Considerably.
10:24:31 <Jafet> I would have genuine admiration for anyone who would complete all the things on that list
10:28:36 <hpc> i think 100 PE problems is a bit much
10:28:43 <copumpkin> yeah
10:28:55 <hpc> you can't get very far into it without bumping into number theory
10:28:57 <KirinDave> Yes.
10:29:05 <copumpkin> I think I'm at 97 or so
10:29:16 <copumpkin> and it was getting rather repetitive
10:29:34 <hpc> i did 20 before realizing that the problems are not really much fun
10:29:45 <KirinDave> Yeah
10:29:47 <KirinDave> They're... boring
10:29:55 <hpc> it didn't help that i was using python at the time
10:30:09 <KirinDave> That's double boring and also patronizing. :)
10:34:20 <djahandarie> Pretty sure I stopped at like 7 on PE
10:36:53 <ricree> so I'm trying to profile a program, and I keep getting errors about how the library can't be found.  Is there a better way to deal with this than manually reinstalling everything?
10:42:38 <dons> ricree: no, you must install everything you need with profiling on
10:42:59 <dons> you can do this by default, by putting -p in your .cabal config file (profiling=True) or something
10:43:21 <c_wraith> It *would* be really nice if you could tell cabal to just reinstall everything with profiling libs
10:44:02 <owst> c_wraith: +1 for that.
10:44:47 <djahandarie> Save a list of your packages, delete your .cabal and .ghc, turn on cabal profiling flag, and cabal install all your packages
10:45:18 <Saizan> deleting .cabal will only make you spend time redownloading the sources
10:45:24 <xplat> i stopped doing project euler before i started, just by helping other people with them
10:46:04 <xplat> it was basically because i realized the problems were of the form 'easy number theory problem, but for a large number so you have to optimize it'
10:46:05 <djahandarie> Saizan, oh? I thought it was required if you wanted to safely rebuild all your packages
10:46:33 <Saizan> djahandarie: nah, deleting .ghc is enough for that
10:47:01 <Saizan> if ghc-pkg doesn't know a package exists then it doesn't
10:47:53 <xplat> i don't mind doing impractical problems, or optimizing practical ones, but optimizing the impractical is a little ...
10:49:09 <joe6> is agda making things more complicated than it needs to be? is there a simpler language for programming with dependent types, that does not make type handling such a pita?
10:49:40 <joe6> anything more than a simple type checking gets complicated with proofs and all that.
10:50:05 <Jafet> Where do you want the proofs to come from then
10:50:50 <joe6> something that alsomething with a better termination checker, I believe..
10:51:01 <copumpkin> and a pony :)
10:51:17 <djahandarie> joe6, Coq takes a totally different approach
10:51:32 <djahandarie> I don't know Coq well enough to pitch it though
10:51:39 <joe6> Jafet, good point..
10:51:40 <joe6> copumpkin, starte off on the exercises , btw..
10:52:08 <joe6> s/starte/started/
10:52:13 <copumpkin> cool :)
10:52:28 <copumpkin> there are several others you can build easily off that basic question
10:52:34 <copumpkin> I mentioned more later yesterday evening
10:53:54 <joe6> copumpkin, ok, copied out yesterdays' conversation to a file, to work out of
10:55:42 <joe6> copumpkin, is agda ever a good fit for the kind of programming I am doing? If I learn the proofs portion, will I be able to agda for more general purpose stuff?
10:55:53 <copumpkin> sure, but it isn't easy
10:55:56 <copumpkin> it's like a giant puzzle
10:55:59 <copumpkin> some parts are tedious
10:56:04 <joe6> Am I finding agda hard to use because of my lack of knowledge of proofs?
10:56:10 <copumpkin> but you can't just go ahead and write programs as if you're writing haskell
10:56:22 <copumpkin> you're expecting to be able to specify more in your types at no cost
10:56:41 <joe6> yes, that is what I am trying to do.
10:56:54 <copumpkin> the more invariants you put in your types, the harder it gets to make values of those types
10:57:02 <joe6> expect a better typesystem and be able to write programs as in haskell
10:57:05 <copumpkin> there are tricks to make it less painful, but it's always slightly more painful
10:57:16 <copumpkin> joe6: you never get anything for free :)
10:57:41 <joe6> copumpkin, I am finding it a lot more painful.
10:57:41 <monochrom> you get free software for free
10:57:50 <djahandarie> joe6, one of the major ideas of Haskell is to make writing things at compile-time a more delicate process in order to prevent errors at runtime
10:57:50 <joe6> than slightly.
10:57:54 <hpc> you get theorems for free
10:58:00 <djahandarie> joe6, Agda certainly extends that idea.
10:58:17 <monochrom> oh, agda requires you to be more logical, yes
10:58:18 <copumpkin> joe6: with lots of knowledge, it's slightly more painful
10:58:30 <djahandarie> joe6, there are approaches to building programs 'from the ground up' where the various restrictions in Haskell and Agda don't feel like restrictions any more
10:58:31 <copumpkin> if you have no knowledge of how values "prove" types, then when you write complex types
10:58:32 <jmcarthur> it's supposed to be more painful
10:58:36 <copumpkin> you don't know how to construct values of those types
10:58:57 <jmcarthur> (not as much more painful as it actually is in practice, though)
10:59:49 <joe6> but the catch is that there are no good tutorials or material to start off on the "proofs" path.
11:00:02 <copumpkin> there are, but they aren't necessarily "easy"
11:00:07 <djahandarie> joe6, i.e., if you build things up from smaller pieces, they naturally fall into place rather than starting from the top and trying to dance your way into the right spot
11:00:23 <djahandarie> I think the learning material for Agda is definitely not there yet
11:00:28 <copumpkin> when you have a few hundred users total, there are fewer people who are willing to go write "agda, step by step from 0" blog posts and the like
11:00:40 <copumpkin> you can't expect it to be easy
11:00:46 <copumpkin> it is rewarding, once you get it
11:00:52 <copumpkin> but no spoon-feeding :P
11:01:02 <hpc> "learn you a coq for great good"
11:01:11 <copumpkin> kamatsu is actually working on learn you an agda
11:01:13 <hpc> unfortunate name for what would probably be the best tutorial ever
11:01:16 <copumpkin> but I don't think it's ready yet
11:01:27 <djahandarie> Yeah, it's not closelast I checked
11:01:31 <djahandarie> close last*
11:01:36 <joe6> nowhere close yet.
11:02:16 <copumpkin> joe6: how about joe6: it's generally nicer to not ask people specifically and just ask the channel. if I have time and am paying attention to the channel
11:02:17 <djahandarie> joe6, if you're open to video tutorials, I heard Conor's are really good and I definitely believe that
11:02:18 <copumpkin> whoops
11:02:26 <copumpkin> not what I meant to paste :)
11:02:26 <copumpkin> http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html
11:02:49 <copumpkin> learn how C-H works in haskell
11:02:53 <copumpkin> prove some basic things in haskell
11:03:04 <copumpkin> and then take a huge breath of fresh air when you move the same stuff to agda
11:03:07 <copumpkin> and it'll be a lot easier
11:03:38 <Jafet> hpc: click here to see some Real World Coq!
11:03:40 <djahandarie> You know, I think it's easier to understand that mailing list post after learning Agda, not before :p
11:03:41 <copumpkin> joe6: that email was my gateway drug
11:03:52 <copumpkin> djahandarie: I dunno, I started there
11:04:13 <djahandarie> Main issue is that he pulls caseNat out of nowhere
11:05:27 <hpc> Jafet: :D
11:06:16 <monochrom> caseNat is an induction principle. every Nat instance must behave like Z and S.
11:07:59 <monochrom> in fact, must not behave more than Z and S
11:08:30 <joe6> will learning coq help with the learning curve?
11:08:32 <joe6> coq seems to have a lot more tutorial tha agda does
11:08:49 <monochrom> yes of course
11:09:04 <djahandarie> joe6, "learn Coq to understand Agda" is wrong. "Learn Coq to understand dependently-typed languages" is right.
11:09:33 <hpc> djahandarie: good thing he said "learning curve" :P
11:09:36 <djahandarie> joe6, since Agda is dependently-typed, it will help, but that shouldn't be your goal because each step won't be towards that goal and that can be frustrating.
11:09:49 <djahandarie> hpc, I'm just talking about focus.
11:13:50 <joe6> if I learn "dependently-typed languages", will I understand the whole deal with proofs in agda?
11:14:12 <crystal-cola> better to learn coq if you want to undersatnd proofs
11:14:32 <djahandarie> joe6, learning Coq to learn Agda will be frustrating. That's all I'm saying.
11:14:36 <djahandarie> Learn Coq to learn Coq.
11:14:50 <djahandarie> Get some help with Agda as a side benefit.
11:15:15 <joe6> my problem is understanding and using proofs. with all the unicode and mathematical notations, it begins to feel like some alien language
11:15:25 <djahandarie> I hate unicode. :p
11:15:47 <crystal-cola> well
11:15:52 <djahandarie> (I recommend to just not use it if it is getting in the way.)
11:15:54 <crystal-cola> if it felt familiar you wouldn't be learning anything
11:15:56 <dcoutts> djahandarie: but unicode loves you!
11:15:57 <joe6> coq, here I come..
11:16:10 <djahandarie> dcoutts, :(
11:16:11 <copumpkin> there's a #coq too
11:16:33 <monochrom> unicode ♥ djahandarie
11:16:34 <crystal-cola> joe6: I started to write out that Zurg thing in Coq but I got bored and stoppeb because I needed a data structure that I don't have
11:16:58 <copumpkin> m♥n♥chr♥m
11:17:11 <pmetzger> djahandarie: why do you hate unicode?
11:17:15 <mauke> I � Unicode
11:17:19 <crystal-cola> haha
11:17:20 * fryguybob hands djahandarie a unicode snowman ☃.
11:17:40 <djahandarie> pmetzger, I'd elaborate but I need to go to class and these "unicode in programming languages" tend to get long
11:17:42 <joe6> crystal-cola, I am looking to solve problems like that with agda (t. Do you think agda is a wrong choice, assuming I learn agda
11:18:01 <pmetzger> "I ♠ My Pet"
11:18:02 <copumpkin> crystal-cola isn't a fan of agda, I gather :)
11:18:18 <joe6> crystal-cola seems to dabble with it
11:18:24 <crystal-cola> Coq has a logic programming language built into it
11:18:27 <monochrom> choose one: "the function in which the independent variable is divided by one more than twice the independent variable" vs "x/(2x+1)". this is the justification for using symbols
11:18:40 <crystal-cola> You can automatically solve the problem as soon as you've written out the problem description
11:18:56 <monochrom> personally and frankly, I have no patience reading "blah blah divided blah blah twice whatever"
11:19:07 <joe6> crystal-cola , you are way out there.
11:19:18 <monochrom> nor the cobolish "multiply x by y into z"
11:19:21 <crystal-cola> what do you mean exactly?
11:20:12 <joe6> crystal-cola, anything specific I ask of you, your replies get very vague.
11:20:15 <pmetzger> I think that one shouldn't go crazy with symbols (you can make stuff unreadable hash) but judicious use of them seems to make math papers more readable.
11:20:34 <pmetzger> and thus I suspect (but don't have enough experience to prove) that they'd improve readability in programs if you didn't go nuts with them.
11:20:50 <joe6> crystal-cola, no offense meant.
11:21:07 <monochrom> perhaps some revisionist historian may suggest that beloved Gracehopper was a troll in inventing a programming language that doesn't even use + and *
11:22:53 <crystal-cola> pmetzger: please explain what you meant by "seems mostly like a troll of sorts." in PM
11:22:54 <pmetzger> we accept + and * so why not → ? it seems silly to restrict ourselves to the symbols that happened, by historical accident, to be in ASCII.
11:22:59 <monochrom> pmetzger I disagree. natural language in math papers is proven to be worse
11:23:09 <ManateeLazyCat> HI all.
11:23:16 <ManateeLazyCat> monochrom: How are you? :)
11:23:21 <pmetzger> monochrom: I don't think I said differently.
11:23:31 <ManateeLazyCat> monochrom: Long time no see. :)
11:23:58 <crystal-cola> pmetzger: why are you ignoring me
11:24:05 <pmetzger> monochrom: I said *judicious* use.
11:24:39 <crystal-cola> Can someonee please tell pmetzger that he sent me a PM (presumably by accident)
11:25:50 <crystal-cola> pmetzger: I'll tell you what, fuck you
11:25:55 <crystal-cola> stop PMing me
11:26:23 <pmetzger> The only PM I sent you was not to be hysterical about the previous PM. If that angers you, then my apologies.
11:26:42 <crystal-cola> how about you explain what you meant instead of insulting me
11:26:57 <pmetzger> I just thought you sent a comment that seemed trolly and I didn't want to say that in public. If you want to fight in public, well, I don't.
11:27:04 <pmetzger> and that's that.
11:27:14 <crystal-cola> I don't want cryptic passive aggressive remarks from you then told to ignore them when I ask you what you're on about
11:28:25 <crystal-cola> I don't really care what you think I seem, If I said something false you should correct me
11:29:38 <crystal-cola> and please PM me only if you have something with content to say..
11:29:55 <Lemmih> That's enough, guys.
11:31:31 <crystal-cola> Lemmih: I didn't want to "fight in public" but he refused to respond to me in PM...
11:32:17 <mauke> :-[
11:33:04 <crystal-cola> I wonder what I said that was so bad in the first place
11:33:14 <monochrom> I suggest not fighting ever
11:33:21 <crystal-cola> did I say something wrong?
11:33:52 <crystal-cola> I was talking to joe about this "Zurg" logic programming problem in a different channel so maybe there was a misunderstanding
11:34:40 --- mode: ChanServ set +o dcoutts
11:34:51 * dcoutts suggests people calm down
11:35:01 <crystal-cola> dcoutts: I suggest you go away
11:35:21 <crystal-cola> Everyone is perfectly calm, you are acting like the british police at a protest
11:35:23 <mauke> dcoutts: that upsets me
11:36:02 --- mode: ChanServ set -o dcoutts
11:36:24 <dcoutts> crystal-cola: I hope not, I just don't like to see people telling each other to f-off in here
11:36:44 <crystal-cola> me neither ...
11:37:02 <crystal-cola> nice of you to bring it up again btw
11:37:10 <gwern> ah, another productive use of my vast haskell archives on the libraries mailing list
11:37:47 <mauke> crystal-cola: you asked for it
11:38:16 <gwern> http://www.haskell.org/pipermail/libraries/2011-April/016288.html
11:40:25 <monochrom> gwern: it's fun how half of them are haddock examples :)
11:40:35 <gwern> monochrom: funny... or tragic?
11:40:48 * gwern personally thinks I need some better tool than grep
11:40:58 <monochrom> funny to me at someone's tragedy expense!
11:54:14 <applicative> dcoutts, are lines 31-2 valid cabalese http://hpaste.org/46168/zenocabal namely, ghc-options:  -with-rtsopts="-N"
11:54:51 <djanatyn_> How do I do a ghc-pkg recache?
11:54:55 <dcoutts> applicative: yes I think so
11:55:33 <dcoutts> applicative: but it'll probably pass "\"-N\"" as the flag value
11:55:44 <dcoutts> applicative: so you probably want -with-rtsopts=-N
11:55:50 <applicative> dcoutts: I see.  Last night I built it with someone, and it produced an executable that complained ...
11:55:55 <dcoutts> or: "-with-rtsopts=-N"
11:56:04 <applicative> Hm, I see.
11:56:05 <dcoutts> whole tokens can be quoted
11:56:15 <dcoutts> e.g. for paths with spaces
11:57:06 <dcoutts> (and such strings use Haskell syntax, including escaping rules)
11:58:24 <applicative> hm, if I use quotes around all I get zeno: Most RTS options are disabled. Link with -rtsopts to enable them.
11:58:29 <gwern> huh. I have 103092 .hs files
11:58:38 <gwern> that's a lot
12:01:22 <dcoutts> applicative: yes, you need to do that
12:01:49 <dcoutts> applicative: -with-rtsopts does not imply -rtsopts :-)
12:03:39 <nifr> I have a low-level question :(
12:03:55 <monochrom> it is a bug. and fixed in HEAD. http://hackage.haskell.org/trac/ghc/ticket/5114
12:04:21 <nifr> I'm on a new MBP 10.6.7, just install the newest Haskell Platform, and I am only seeing allocation tracked in my +RTS -p profiling output
12:04:28 <nifr> I compiled with     ghc -osuf po -prof -auto-all -rtsopts --make Main.hs -o Main
12:04:45 <applicative> dcoutts, ah, yes I just figured this out.  I added -rtsopts to the main ghc-opts line, then killed the quotes entirely on the other
12:04:45 <nifr> Any ideas? Am I missing something? Thanks.
12:05:18 <dcoutts> applicative: sounds right
12:06:14 <nifr> by "only allocation", I mean all of the timing information is filled with 0.0s
12:14:03 * applicative sends off profound .cabal patch
12:26:12 <copumpkin> weird to see voevodsky, awodey, and andrej bauer on github
12:26:26 <copumpkin> but I guess they're all on there for the same reason
12:26:34 <arcatan> voevodsky, awodey and andrej bauer walk into a bar...
12:27:20 <crystal-cola> they order a cup of coffee and the barman gives them each a donut
12:27:35 <copumpkin> lol
12:31:58 <tomwys_> How to write something like: data ParsedExpression = CmpOp ParsedExpression (Ord a => a -> a -> Bool) ParsedExpression, now I have "llegal polymorphic or qualified type:" error.
12:33:04 <copumpkin> you need to introduce that a somewhere
12:33:08 <Eduard_Munteanu> tomwys_: 'a' is not quantified there.
12:33:15 <copumpkin> is it forall a. CmpOp ParsedExpression (Ord a => a -> a -> Bool)
12:33:19 <copumpkin> or CmpOp ParsedExpression (forall a. Ord a => a -> a -> Bool)
12:33:24 <Eduard_Munteanu> You need it on the left hand side, or a forall on the rhs.
12:33:44 <copumpkin> chances are you want it on the LHS
12:34:47 <Eduard_Munteanu> Mind   data ... a = ...    is different from data ... = forall a . ...   which is again different from   data ... = Constructor (forall a. ...)
12:35:59 <smop> Jumpie: bots?
12:36:31 <Eduard_Munteanu> In the first case (the most likely) you can't place restrictions on a, you have to do it in functions operating on it.
12:37:28 <Eduard_Munteanu> I still wonder why Haskell hasn't got class constraints for datatypes.
12:37:59 * hackagebot bytestring-mmap 0.2.2 - mmap support for strict ByteStrings  http://hackage.haskell.org/package/bytestring-mmap-0.2.2 (DonaldStewart)
12:38:35 <Tomsik> Why is the Kleisli so ugly
12:38:45 <Tomsik> it's so ugly that it's useless
12:39:03 <Eduard_Munteanu> @src Kleisli
12:39:03 <lambdabot> Source not found. stty: unknown mode: doofus
12:39:14 <Eduard_Munteanu> :t Kleisli
12:39:15 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
12:39:20 <Eduard_Munteanu> Mm, why?
12:41:01 <Tomsik> You have to wrap "Kleisli" constructor around everything
12:41:13 <aristid> Tomsik: you can use <=< instead
12:41:17 <Tomsik> It'd be nice to be able to use (.) instead of (>=>)
12:41:19 <Tomsik> but nooo
12:41:23 <Tomsik> :((
12:41:29 <copumpkin> Tomsik: you can
12:41:35 <aristid> copumpkin: ?
12:41:36 <copumpkin> just import Control.Category and hide the (.) in prelude
12:41:50 <copumpkin> it's <=<
12:41:51 <aristid> copumpkin: that DOES require wrapping stuff in Kleisli
12:41:52 <copumpkin> or <<<
12:41:56 <aristid> which he complained about
12:42:00 <copumpkin> [04:03:23 PM] <Tomsik> It'd be nice to be able to use (.) instead of (>=>)
12:42:02 <copumpkin> is what I was responding to
12:42:06 <aristid> (<=<) requires no wrapping
12:42:12 <Tomsik> copumpkin: still requires a wrap
12:42:15 <copumpkin> sure
12:42:17 <aristid> so i think he should use that.
12:42:36 <aristid> there aren't all that many useful arrow combinators anyways
12:42:40 <Tomsik> I guess I'm just the odd one who doesn't like the monadic syntax at all
12:45:14 <Eduard_Munteanu> Yeah, Kleisli can fit in place of Category stuff
12:45:22 <Eduard_Munteanu> :t (>>>)
12:45:23 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
12:45:36 <Eduard_Munteanu> :t (<<<)
12:45:37 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
12:46:02 <aristid> Tomsik: which Arrow functions, other than (.), do you want to use?
12:46:38 <cjay> is there a way to preserve polymorphism when pattern-matching?
12:46:40 <Tomsik> None! None at all!
12:46:52 <Tomsik> It's just that .. um.. I ...
12:47:03 <aristid> Tomsik: so what's wrong with (<=<)?
12:47:09 <copumpkin> cjay: rank-2 types
12:47:57 <Tomsik> Not that much, it's more about (.)
12:48:37 <aristid> Tomsik: hmm. i wonder if maybe with type classes, you could overload (.) that way. probably not, it would overlap in nasty ways
12:49:28 <cjay> copumpkin: they are enabled but it doesn't work. maybe it's because of the do-notation? I use a list of operators in the list monad and want op to stay polymorphic for types from Fractional: op <- [(+), (-), (*), (/)]
12:49:41 <copumpkin> cjay: you need to annotate it such that it is
12:49:45 <copumpkin> oh, that's different
12:49:48 <Tomsik> That'd require a 4-param typeclass I guess
12:49:52 <copumpkin> that needs impredicative types
12:50:05 <cjay> I tried ScopedTypeVariables but that didn't help
12:50:42 <aristid> :t [(+), (-), (*), (/)]
12:50:43 <lambdabot> forall a. (Fractional a) => [a -> a -> a]
12:51:05 <cads> hey, you guys think it would be possible to create something like this http://www.khanacademy.org/exercisedashboard , but with exercises that generate descriptions of problems for students to solve with haskell?
12:51:06 <aristid> copumpkin: why does that need impredicative types?
12:51:24 <copumpkin> aristid: if he wants to maintain the polymorphic operations inside the list
12:51:27 <aristid> cads: i think apfelmus works on a khan academy like thingie
12:51:44 <aristid> copumpkin: ?
12:51:46 <cads> It could be things that give template codes with highlighted sections, and the problem might be for example 'correct fix the type error'
12:51:57 <copumpkin> aristid: and want op to stay polymorphic for types from Fractional: op <- [(+), (-), (*), (/)]
12:52:02 <aristid> copumpkin: they all have the same type
12:52:05 <copumpkin> that means he wants op :: Fractional a => a -> a -> a
12:52:19 <cads> or tasks like 'complete this labeled tree type'
12:52:49 <cjay> without the polymorphism, the defaulting rules restrict op to Double
12:52:58 <copumpkin> oh well
12:53:01 <copumpkin> that can be avoided
12:53:12 <cads> so, engaging specific parts of haskell thinking/knowledge, while also reflecting the kinds of task a coder actually has to do
12:53:15 <aristid> :t (>>=) [(+), (*), (/), (-)]
12:53:16 <lambdabot> forall a b. (Fractional a) => ((a -> a -> a) -> [b]) -> [b]
12:53:32 <cads> aristid: I'll see if I can find out more
12:53:46 <copumpkin> aristid: you see how that's different?
12:53:50 <aristid> copumpkin: no
12:54:00 <copumpkin> forall a b. (Fractional a) => ((a -> a -> a) -> [b]) -> [b]
12:54:13 <copumpkin> forall b. (forall a. (Fractional a) => (a -> a -> a) -> [b]) -> [b]
12:54:15 <aristid> the forall is outside the -> b?
12:54:46 <aristid> copumpkin: but is that a problem as long as he can expose the polymorphism?
12:55:05 <copumpkin> if he just wants it to not default to Double, then it's easy to do
12:55:19 <copumpkin> if he wants to use op on multiple different Floating operands
12:55:23 <copumpkin> then he needs impredicativity
12:55:58 <cads> aristid: http://apfelmus.nfshost.com/blog/2010/06/01-gadts-video.html
12:56:01 <copumpkin> so something like op <- [(+), (-), (*), (/)]; let moo = (5 :: Double) `op` 6; baa = (5 :: Float) `op` 7
12:56:17 <aristid> cads: yeah.
12:56:24 <aristid> cads: he improved his software since then :)
12:56:39 <cads> aristid: I just did a little seach term algebra :)
12:56:45 <Eduard_Munteanu> What's  op <- [(+), (-), (*), (/)]   supposed to do?
12:57:21 <aristid> cads: i could have given you the link to his blog :)
12:57:35 <aristid> sadly i don't think he comes here
12:58:30 <TheZimm> >op <- [(+), (-), (*), (/)]
12:58:38 <TheZimm> lambdabot come on
12:58:40 <TheZimm> > op <- [(+), (-), (*), (/)]
12:58:41 <lambdabot>   not an expression: `op <- [(+), (-), (*), (/)]'
12:58:47 <TheZimm> cads nothing
12:58:56 <copumpkin> > do { op <- [(+), (-), (*), (/)]; return (5 `op` 6) }
12:58:57 <lambdabot>   [11.0,-1.0,30.0,0.8333333333333334]
12:59:16 <copumpkin> > do { op <- [(+), (-), (*), (/)]; x <- [1..3]; y <- [6..9]; return $ x `op` y }
12:59:16 <TheZimm> copumpkin meh your face for being smart xD
12:59:17 <lambdabot>   [7.0,8.0,9.0,10.0,8.0,9.0,10.0,11.0,9.0,10.0,11.0,12.0,-5.0,-6.0,-7.0,-8.0,...
12:59:26 <pmetzger> you can use an array as a function?
12:59:36 <copumpkin> I'm not
12:59:39 <c_wraith> No.  values from the array
12:59:44 <c_wraith> note the <- in there
12:59:48 <TheZimm> copumpkin i beg to differ
12:59:50 <Eduard_Munteanu> Yeah, that's the list monad there.
12:59:51 <pmetzger> yes, but I'm still confused.
12:59:58 <copumpkin> pmetzger: zomg monadz
13:00:12 <kleinucopia> I'm trying to deserialize some JSON into Haskell data types, but the JSON I fetch doesn't always provide the fields in my type. I don't want to call fail if Text.JSON's lookup gives me a Nothing, but I also don't want to wrap every field in my type in a Maybe. What should I do?
13:00:16 <pmetzger> I should read about the list monad I suppose.
13:00:24 <c_wraith> > do { a <- [1..5] ; b <- [6,7] ; return (a, b) }
13:00:25 <lambdabot>   [(1,6),(1,7),(2,6),(2,7),(3,6),(3,7),(4,6),(4,7),(5,6),(5,7)]
13:00:26 <Eduard_Munteanu> > [1, 1, 1] >>= const [1, 2]
13:00:27 <lambdabot>   [1,2,1,2,1,2]
13:00:32 <pmetzger> so much stuff to absorb. I feel like an overdamp sponge.
13:00:49 <Eduard_Munteanu> @src [] >>=
13:00:49 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:00:56 * copumpkin squeezes pmetzger 
13:01:09 <Eduard_Munteanu> Meh, can't remember how to invoke lambdabot for that.
13:01:10 <KirinDave> pmetzger: Don't feel bad. Learning Haskell and ML is like relearning how to program.
13:01:16 <TheZimm> lol
13:01:24 <copumpkin> then take it a step further by moving into agdaland
13:01:34 <pmetzger> trust me, that would not be a good idea right now. I'll spew out loads of half-digested combinators.
13:01:35 <Eduard_Munteanu> Heh.
13:01:41 <pmetzger> (re: squeezing)
13:02:02 <aristid> @src [] (>>=)
13:02:03 <lambdabot> xs >>= f     = concatMap f xs
13:02:06 <aristid> Eduard_Munteanu: :P
13:02:16 <__o1iver> Hey. I am starting Haskell and wondering how one implements an application while loop. I want to duplicate tail and I obviously need some loop that will infinitely check if a file has been changed...
13:02:28 <kleinucopia> aristid: you need to wrap ops in parens for :t in ghci, too. Do you know why that is?
13:02:28 <aristid> :t forever
13:02:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:02:37 <pmetzger> __o1iver:  you use tail recursion instead of loops...
13:02:45 <cjay> hmm I have enabled ImpredicativeTypes and I'm using a scoped type variables, but still no luck
13:02:45 <copumpkin> or forever
13:02:46 <aristid> kleinucopia: because only then is it recognized as a vlue
13:02:58 <aristid> kleinucopia: without parens, it's always just an operator
13:02:59 <__o1iver> pmetzger: so infinite tail recursion?
13:03:04 <kleinucopia> aristid: gotcha
13:03:09 <copumpkin> cjay: you're probably doing something else wrong then :) can you show us some code?
13:03:14 <__o1iver> pmetzger: actually that makes sense
13:03:23 <__o1iver> still have to wrap my head around this stuff
13:03:23 <pmetzger> __o1iver: tail recursion is really a goto.
13:03:33 <copumpkin> omg goto
13:03:37 * copumpkin slaps pmetzger 
13:03:39 <aristid> for a forever-loop, use forever.
13:03:40 <__o1iver> haha
13:03:45 <aristid> :t forever
13:03:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:03:48 <__o1iver> aristid: ok will have a look at that
13:03:55 <pmetzger> copumpkin: hey, look, it is true. "lambda the ultimate" and all that.
13:03:56 <Eduard_Munteanu> > forever (putStrLn "Hi")
13:03:58 <lambdabot>   Ambiguous type variable `b' in the constraint:
13:03:58 <lambdabot>    `Data.Typeable.Typeable b...
13:04:16 <aristid> > forever []
13:04:17 <lambdabot>   []
13:04:19 <copumpkin> pmetzger: but everyone knows goto is evil!!!11!1!1 *froth*
13:04:21 <aristid> > forever [1]
13:04:22 <lambdabot>   *Exception: stack overflow
13:04:26 <KirinDave> Ha.
13:04:30 <__o1iver> haha
13:04:32 <TheZimm> :P
13:04:38 <Eduard_Munteanu> > forever (putStrLn "Hi") >> return ()
13:04:39 <lambdabot>   <IO ()>
13:04:45 <pmetzger> copumpkin: tail recursion was a seriously cool invention. :)
13:05:00 <pmetzger> copumpkin: it pisses me off a lot that C implementations aren't properly tail recursive.
13:05:04 <Eduard_Munteanu> But lambdabot doesn't let you do IO stuff.
13:05:17 <aristid> pmetzger: in haskell, tail recursion isn't all that relevant AFAIK
13:05:22 <copumpkin> Eduard_Munteanu: you don't even need to >> return ()
13:05:32 <copumpkin> > forever (putStrLn "Hi") :: IO ()
13:05:33 <lambdabot>   <IO ()>
13:05:35 <Eduard_Munteanu> Yeah it was just an easy fix to get the types
13:05:47 <Eduard_Munteanu> It's not executed anyway :)
13:05:55 <pmetzger> aristid: well, given that one typically wraps everything in other things, but if you're doing something forever, ultimately under the covers it is tail recursion...
13:06:19 <KirinDave> pmetzger: Don't be so sure. :)
13:06:21 <aristid> @src forever
13:06:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:06:25 <Eduard_Munteanu> pmetzger: what do you mean by not "properly tail recursive"?
13:06:27 <pmetzger> KirinDave: counterexample?
13:06:39 <aristid> pmetzger: forever f = f >> forever f
13:06:41 <pmetzger> Eduard_Munteanu: gcc will sometimes turn tail calls into jumps, but not always.
13:06:45 <aristid> ok that's the naive implementation
13:06:50 <Eduard_Munteanu> Ah tail calls?
13:06:51 <aristid> but it's not tail recursive :)
13:07:19 <pmetzger> :t forever
13:07:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:07:35 <mauke> @src forever
13:07:35 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:07:37 <Eduard_Munteanu> In compilers like GCC, tail recursion optimization merely transforms recursivity into loops.
13:07:40 <aristid> i think forever f = let g = f >> g in g might be better
13:07:42 * mauke twitches
13:07:46 <Eduard_Munteanu> It won't play tricks with the stack.
13:07:46 <pmetzger> Eduard_Munteanu: into jumps.
13:07:48 <aristid> :t let forever f = let g = f >> g in g in forever
13:07:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:07:52 <TheZimm> Eduard_Munteanu you can turn that off tho
13:07:54 <mauke> :t fix . (>>)
13:07:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:07:56 <TheZimm> just sayin :P
13:08:00 <pmetzger> Eduard_Munteanu: actually, it will play games with mutual tail recursion.
13:08:09 <aristid> mauke: hmm :)
13:08:09 <twobitsprite> someone mind explaining the difference between "liftM (Number . read) $ many1 digit" and "many1 digit >>= return (number . read)"?
13:08:12 <aristid> :t fix . (<<)
13:08:13 <lambdabot> Not in scope: `<<'
13:08:17 <aristid> gngn
13:08:19 <pmetzger> Eduard_Munteanu: but only in particular circumstances and it isn't guaranteed.
13:08:21 <Eduard_Munteanu> Yes, but only by doing inlining and such AFAIK.
13:08:28 <Tomsik> > let alone = fix undefined in forever alone
13:08:28 <napping> twobitsprite: there shouldn't be any
13:08:29 <lambdabot>   No instance for (GHC.Show.Show (m b))
13:08:29 <lambdabot>    arising from a use of `M1214881273...
13:08:37 <Tomsik> :t let alone = fix undefined in forever alone
13:08:38 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
13:08:38 <mauke> twobitsprite: none, except for Number/number
13:08:40 <TheZimm> Eduard_Munteanu no theres flags you can put on compiling
13:08:45 <Eduard_Munteanu> I think the main reason is full tail calls mess up debugging.
13:08:53 <pmetzger> Eduard_Munteanu: anyway, it would be nicer if it did, in fact, always turn tail calls into jumps. would make things like building threaded interpreters much simpler.
13:08:54 <twobitsprite> napping: ok, cool... was just checking (I think I've finally grokked monads! :P)
13:08:58 <copumpkin> fuck debugging
13:09:02 <copumpkin> don't write buggy code
13:09:05 <twobitsprite> mauke: ohh, yeah, typo :P
13:09:05 <TheZimm> lolol
13:09:08 <aristid> copumpkin: in c?
13:09:15 <copumpkin> in anything
13:09:24 <Eduard_Munteanu> Yeah, but if you want stuff like efficient CPS, C won't do.
13:09:29 <pmetzger> copumpkin: clearly if one first proves the program correct and then compiles it...
13:09:31 <Eduard_Munteanu> You can use setjmp() stuff though.
13:09:43 <pmetzger> Eduard_Munteanu: no, setjmp creates madness.
13:09:50 <mauke> delicious madness
13:09:54 <pmetzger> Eduard_Munteanu: and the path of Charlie on the MTA is doubly mad.
13:10:11 <pmetzger> er, pardon, Cheney on the MTA
13:10:13 <kleinucopia> apropos setjmp, a university professor tried to tell me that it wasn't in the C standard libs once.
13:10:17 <mauke> sigaltstack, anyone?
13:10:19 <kleinucopia> I LOL'd.
13:10:32 <pmetzger> kleinucopia: it has been in the C libraries since before version 7.
13:10:33 <cjay> copumpkin: http://hpaste.org/46169/forced_polymorphism
13:10:33 <Eduard_Munteanu> I'm not sure it is C99 though
13:10:40 <mauke> Eduard_Munteanu: it is
13:10:46 <kleinucopia> pmetzger: his reaction was "how can that be done!?!"
13:10:47 <Eduard_Munteanu> Oh, nice.
13:11:00 <pmetzger> kleinucopia: really?
13:11:02 <copumpkin> cjay: well, what are you trying to do with op after that?
13:11:07 <mauke> I don't think C99 removed any library functions
13:11:28 <kleinucopia> pmetzger: yep. He cried when we dragged out a dusty copy of C99 spec.
13:11:31 <copumpkin> cjay: if you want that to work as you wrote it
13:11:40 <pmetzger> setjmp/longjmp is kind of needed in C -- hard to survive without it, but you have to be damn careful with it.
13:11:42 <copumpkin> cjay: testOps :: [forall a. Fractional a => a -> a -> a]
13:11:55 <copumpkin> that's what impredicative polymorphism enables
13:12:03 <mauke> pmetzger: you must be writing weird code
13:12:15 <kleinucopia> pmetzger: one company I worked at used setjmp/longjmp and SIGALARM to implement multithreading on embedded printer software.
13:12:18 <cjay> copumpkin: I use op as an argument for testBinOp :: Interval i => (forall n. Fractional n => n -> n -> n) -> i -> i -> Bool
13:12:26 <kleinucopia> it was ugly but... epic
13:12:29 <copumpkin> cjay: ah okay
13:12:33 <copumpkin> then yeah, do what I said
13:12:34 <cjay> copumpkin: testBinOp applies op to intervals and the base type of the intervals
13:12:39 <pmetzger> mauke: nah, but for something like an interpreter, it is impractical to break out of a deep stack location otherwise in error conditions.
13:12:40 <cjay> different types
13:12:58 <Eduard_Munteanu> Yeah, userspace threads are one of the main applications of setjmp() stuff.
13:13:13 <pmetzger> you can't safely implement userspace threads with setjmp
13:13:19 <pmetzger> sadly.
13:13:23 <pmetzger> but there are calls you can use.
13:13:52 <kleinucopia> pmetzger: I was surprised, but it *usually* worked just fine.
13:13:54 <pmetzger> setcontext is a lot closer to what you want.
13:14:04 <pmetzger> setjmp doesn't have quite the right semantics.
13:14:06 <cjay> copumpkin: thanks for the help. would it be possible with only the type signature for op, omitting the one for testOps?
13:14:13 <copumpkin> cjay: yeah
13:14:23 <copumpkin> it should, anyway
13:14:26 <kleinucopia> luckily, that code was phased out for "real" threading... it was a holdover from the days before POSIX was something embedded code could count on
13:14:32 <copumpkin> not sure how well impredicative polymorphism works
13:14:33 <Eduard_Munteanu> Though setcontext() and friends aren't really portable.
13:14:37 <copumpkin> I don't think many people use it
13:14:57 <pmetzger> Eduard_Munteanu: they are in POSIX.
13:15:07 <pmetzger> Eduard_Munteanu: though not 100% of systems have them, true.
13:15:14 <kleinucopia> Eduard_Munteanu: exactly why they used setjmp -- the code could only count on std libs and a few Unix system libs.
13:15:16 <Eduard_Munteanu> pmetzger: I mean across arches. One can't really play with the stack in portable ways.
13:15:18 <__o1iver> pmetzger: so next question... how do I sleep in an IO monad? I am trying threadDelay
13:15:22 <__o1iver> :t threadDelay
13:15:23 <lambdabot> Not in scope: `threadDelay'
13:15:36 <mauke> __o1iver: "an IO monad"? is there more than one?
13:15:36 <pmetzger> __o1iver: I'm a newb. someone else will have to answer that. :)
13:15:37 <__o1iver> :t Control.Concurrent.threadDelay
13:15:38 <lambdabot> Int -> IO ()
13:15:50 <cjay> copumpkin: well it doesn't work with only the type signature I used for op, maybe I got the scoping wrong
13:16:00 <copumpkin> cjay: oh, maybe not then :)
13:16:07 <copumpkin> does it work with the full type sig though?
13:16:07 <__o1iver> mauke: well I have only seen it for IO until now so I guess so
13:16:11 <Eduard_Munteanu> copumpkin: as far as Philippa explained to me, impredicativity is quite crucial
13:16:16 <Eduard_Munteanu> Even for stuff like ST.
13:16:21 <mauke> __o1iver: huh?
13:16:27 <kleinucopia> is there some way I could construct a "default" value for different types? I basically want something like undefined, but without the whole "undefined" bit.
13:16:45 <mauke> kleinucopia: you can use a typeclass for that
13:16:46 <__o1iver> mauke: dw... not very clear...
13:16:50 <copumpkin> Eduard_Munteanu: the hack for ST applies even when Impredicative polymorphism is turned off, even
13:16:57 <__o1iver> but how do I sleep in a monad?
13:17:04 <copumpkin> __o1iver: you only sleep in IO
13:17:07 <mauke> __o1iver: you don't
13:17:13 <napping> threadDelay should be fine for IO
13:17:16 <cjay> copumpkin: it works with [forall a. Fractional a => a -> a -> a] for testOps, and I can omit the signature of op
13:17:23 <__o1iver> copumpkin: ok so how do I sleep in IO?
13:17:24 <copumpkin> dool
13:17:29 <copumpkin> @hoogle threadDelay
13:17:29 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
13:17:34 <mauke> __o1iver: threadDelay
13:18:24 <__o1iver> mauke: thats what I just tried but I seem to be doing something wrong: http://hpaste.org/46170/sleep
13:18:46 <napping> oh, you just didn't wait long enough
13:18:51 <mauke> __o1iver: works fine here
13:19:11 <napping> it's in microseconds
13:19:12 <__o1iver> mauke: are you on windows?
13:19:15 <mauke> no
13:19:23 <napping> I'm sure it slept for 10ms just like it was supposed to
13:19:25 <__o1iver> napping: well even with 100000 its immediat
13:19:32 <__o1iver> *immediate
13:19:43 <mauke> __o1iver: 0.1 seconds isn't very long
13:19:46 <__o1iver> napping: ok it was too short
13:19:47 <napping> that's 1/10th of a second
13:19:49 <__o1iver> ok
13:19:53 <__o1iver> my bad
13:19:54 <__o1iver> cheers
13:20:02 <napping> I think some functions are even in picoseconds
13:20:37 <Eduard_Munteanu> That'd be excessive, methinks. Even timespec stuff is ns-resolution.
13:21:13 <Eduard_Munteanu> Picoseconds is on the order of propagation delays for individual gates, IIRC :)
13:21:21 <napping> DiffTime
13:24:58 <mauke> :t mempty
13:24:59 <lambdabot> forall a. (Monoid a) => a
13:25:08 <mauke> hmm
13:25:10 <mauke> :t mzero
13:25:11 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
13:26:21 <aristid> mauke: i always confuse mconcat and msum
13:27:48 <copumpkin> if its name is painfully long to type for what it does, it's probably for Monoid
13:28:13 <aristid> copumpkin: useful guideline.
13:28:22 * acowley mappends copumpkin to his mempty
13:28:26 <aristid> mempty is only slightly longer than mzero tho
13:28:35 <aristid> > map length ["mempty","mzero"]
13:28:35 <lambdabot>   [6,5]
13:29:45 <acowley> mappend is great fun though. You might start with some code using lists [a] and (++) then think you're clever to generalize it and end up with double-length types and programs.
13:30:16 <mauke> nah, I just redefine (++)
13:30:25 <copumpkin> :t (++)
13:30:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:30:34 <c_wraith> :t (<>)
13:30:35 <lambdabot> Doc -> Doc -> Doc
13:30:53 <c_wraith> wasn't that supposed to be added to base at some point as an alias for mappend?
13:31:30 <acowley> byorgey always agitates for it
13:31:36 <acowley> but I don't think it's been added yet
13:32:05 <c_wraith> > text "foo" ++ text "bar"
13:32:06 <lambdabot>   No instance for (Data.Monoid.Monoid Text.PrettyPrint.HughesPJ.Doc)
13:32:06 <lambdabot>    arisi...
13:32:13 <Eduard_Munteanu> Maybe a Prelude-v2 makes sense, much like a Boost for Haskell.
13:32:16 <c_wraith> really?  no monoid instance for that?
13:32:28 <acowley> surprising
13:32:52 <acowley> isn't there a builder, though?
13:33:20 <c_wraith> Eduard_Munteanu: it's already been done.  a couple times.
13:33:21 <Eduard_Munteanu> Unfortunately Haskell got successful before getting an awesome stdlib :P
13:33:51 <Eduard_Munteanu> I haven't seen much stuff using alternate preludes though.
13:34:57 <acowley> Oh! I know what it was. I was working on haxr and replaced some of the pretty stuff because the XML output formatting was causing problems, but I replaced it with a builder and was able to keep the <> syntax.
13:39:04 <acowley> did anyone else read this link from alpheccar's twitter feed? http://golem.ph.utexas.edu/category/2011/04/higher_categories_for_concurre.html
13:41:36 <triyo> Is there any REST client library available for Haskell? i see nothing in hackage db.
13:42:31 <rostayob> I've got an application that works well for some time, and then goes to 100% CPU at some point. I can't relate the change to anything, what would be a good way to profile it to see what's wrong?
13:42:40 <c_wraith> That's an odd question...  Given that REST is essentially "HTTP the way we designed it, ignoring all the problems with that."
13:43:34 <acowley> rostayob: normal profiling for time and space as described in RWH isn't providing any clues?
13:44:08 <kleinucopia> triyo: you could use the implementation of, e.g. Web.Twitter's restCall as an example.
13:44:34 <rostayob> acowley: I didn't really try anything, because the problem shows up after a long time (like more than 30 mins usually, so I guess the data would be quite confusing
13:44:52 <triyo> kleinucopia: thanks. I'll have a look at restCall.
13:45:17 <acowley> rostayob: that is awkward, but a memory profile often looks totally wonky when a program goes totally wonky
13:45:33 <acowley> rostayob: specifically, seeing the type or origin of whatevers soaking up memory
13:45:58 <rostayob> acowley: nothing is soaking up memory really, it just goes 100% CPU
13:45:59 <acowley> rostayob: if it's not memory, then you could look at a time profile after running for 5 min., then another after running for 30 min.
13:46:13 <rostayob> acowley: ok, I'll take a look. thanks.
13:46:20 <gcollins> Who runs stenobot2011 ?
13:46:30 <gcollins> Because it's buggy.
13:46:47 <mauke> gcollins: how?
13:46:49 <gcollins> Example: »
13:46:53 <gcollins> Magic :)
13:47:02 <mauke> how do you make it quit?
13:47:16 <gcollins> It's not decoding unicode properly is my guess.
13:47:48 <mauke> �
13:47:51 <mauke> neat
13:48:13 <copumpkin> that's what she said
13:48:22 <gcollins> maybe not so neat, if someone's relying on it to log stuff
13:48:30 <copumpkin> that's what she said
13:48:50 <acowley> was that a call-forward? Impressive.
13:48:56 <gcollins> who replaced copumpkin with that double entendre irc bot
13:49:19 --- mode: ChanServ set +o mauke
13:49:20 --- kick: stenobot2011 was kicked by mauke (test)
13:49:55 <geheimdienst> is double entendre anything like coentendre?
13:50:08 <hpc> bi-entendre
13:50:10 <acowley> it's a bientendre
13:50:10 --- mode: mauke set -o mauke
13:50:13 <gcollins> that's...what she said?
13:50:44 <acowley> coentendre is when the intended meaning is much sexier than you imagined
13:51:22 <mauke> aaa
13:53:13 * hackagebot heist 0.5.2 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.5.2 (DougBeardsley)
14:09:25 --- mode: ChanServ set +o copumpkin
14:10:36 --- mode: copumpkin set +b *!~stenobot2@173.247.10.20
14:10:44 --- mode: copumpkin set -o copumpkin
14:14:38 <hoknamahn> hey guys, i'm trying to install ghc-7.0.3 for gentoo but emerge says "No binary .tbz2 package available yet for your arch"
14:14:43 <Mkman> Hey!
14:14:54 <hoknamahn> any ideas?
14:16:33 <frerich_> Hi, is there a good idiom for recursively applying a function n times? For instance, 'tailNth 3 "Foobar"' should yield "tail $ tail $ tail "Foobar"". I have a few of such cases and I always write the recursion by hand. I wonder whether there is a nice trick to simplify this.
14:17:17 <frerich_> Another example is a function 'eagerDropWhile p l = tail $ dropWhile p l' which basically works like dropWhile except that the first element which matches the predicate is dropped as well.
14:17:46 <frerich_> So 'eagerDropWhile (/= ' ') "Alpha Beta Gamma"' yields 'Beta Gamma'.
14:17:52 <ddarius> drop 1 not tail
14:17:52 <navaati> @hoogle (a -> a) -> Int -> a -> a
14:17:53 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
14:17:53 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
14:17:53 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
14:18:12 <frerich_> Now I'd like to recursively call eagerDropWhile to drop everything up to the 4th space.
14:18:35 <ddarius> There is no finite version of iterate or until, but it is easily written.
14:18:40 <acowley> :t \n f -> head . drop n . iterate f
14:18:41 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:18:50 <ddarius> That said, tailNth is a fairly disgusting function.
14:18:50 <navaati> @hoogle (a -> a) -> a -> [a]
14:18:50 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
14:18:51 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
14:18:51 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
14:19:13 <frerich_> ddarius: It was just an example, I don't actually have such a function :-)
14:19:29 <c_wraith> dropWhile is already strict in its input up until and including the first element that satisfies the predicate
14:20:25 <navaati> :t \n f x -> (interate f) !! n
14:20:27 <lambdabot> Not in scope: `interate'
14:20:29 <c_wraith> Well, I guess the strictness within the elements depends on the predicate.  But it's strict in the spine of the input list until the predicate returns True
14:20:31 <navaati> :t \n f x -> (iterate f) !! n
14:20:32 <lambdabot>     Couldn't match expected type `[a]'
14:20:33 <lambdabot>            against inferred type `a1 -> [a1]'
14:20:33 <lambdabot>     In the first argument of `(!!)', namely `(iterate f)'
14:20:42 <navaati> :t (!!)
14:20:43 <lambdabot> forall a. [a] -> Int -> a
14:20:46 <acowley> navaati: what's wrong with what I wrote?
14:20:50 <ddarius> navaati: Semantically correct (once you figure out the parameters) but not operationally optimal.
14:21:04 <mauke> :t \n f x -> iterate f x !! n
14:21:05 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:21:05 <gcollins> \f n -> foldl (.) id $ replicate n f
14:21:07 <navaati> acowley: nothing
14:21:17 <gcollins> that's how i would do it
14:21:30 <ddarius> gcollins: That would be a bad way as well.  Don't foldl (.).
14:21:38 <navaati> gcollins: pretty complicated…
14:21:42 <ddarius> And more generally, don't foldl anything.
14:21:46 <gcollins> yes
14:22:01 <navaati> oh, foldr is the right one to use ?
14:22:08 <gcollins> or foldl'
14:23:10 <ddarius> In this case foldr is the right one to use in this case because (.) is non-strict in its second argument.
14:23:32 <ddarius> It is, in fact, non-strict in both arguments.
14:25:05 <guerrill4> where can i get help with happy? is there a mailing list or irc channel somewhere?
14:29:53 <ddarius> The modern (mis)usage of "hopefully" is interesting linguistically insofar as it corresponds (roughly) to a kind of control operator.
14:30:36 <geheimdienst> ddarius: how do you mean?
14:31:31 <ddarius> "It will hopefully rain." <=> "I hope that it will rain."  So "hopefully" pulls its context out and repackages it.
14:34:22 <ddarius> @let control f = Cont $ \k -> runCont (f (\a -> Cont (const (k a)))) id
14:34:23 <lambdabot>  <local>:4:12: Not in scope: data constructor `Cont'
14:34:24 <lambdabot>  
14:34:24 <lambdabot>  <local>:4:43: Not in ...
14:34:59 <Saizan> it's cont now
14:35:15 <ddarius> @let control f = cont $ \k -> runCont (f (\a -> cont (const (k a)))) id
14:35:16 <lambdabot>  Defined.
14:35:30 <ddarius> > do control (\k -> k 3); return 4
14:35:31 <lambdabot>   No instance for (GHC.Show.Show
14:35:31 <lambdabot>                     (Control.Monad.Trans.Con...
14:35:38 <ddarius> > runCont (do control (\k -> k 3); return 4) id
14:35:40 <lambdabot>   4
14:35:50 <ddarius> > runCont (do control (\k -> return 3); return 4) id
14:35:52 <lambdabot>   3
14:36:40 <crystal-cola> hopefully ill return 3 or 4?
14:37:32 <crystal-cola> what is ";" linguistically?
14:38:38 <ddarius> Bah, I'll need composable continuations.
14:39:23 <Phyx-> So guys, I have a question, In the binary package the functions in Data.Binary.Get say for instance "Skip ahead n bytes. Fails if fewer than n bytes are available" but failure is never defined... does failing means an exception?
14:39:36 <Twey> mzero, surely
14:39:56 <c_wraith> crystal-cola: look it up in CGEL (Cambridge Grammar of the English Language).  If you want a definitive answer.
14:40:05 <ddarius> @instances-importing Data.Binary MonadPlus
14:40:05 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:40:11 <ddarius> No mzero.
14:40:32 <crystal-cola> c_wraith: no I meant the haskell code ";"
14:40:42 <Phyx-> hhmm
14:41:13 <ddarius> At any rate, I hope this paper I've found is the paper I've been hoping would be written.
14:41:16 <Phyx-> there's only a Monad, Functor, MonadFix and Applicative instance
14:41:17 <Twey> Ew, no
14:41:20 <Twey> It calls fail
14:41:57 <Twey> And fail returns a Get wrapping an ‘error’
14:42:05 <Twey> This is not the Right Way
14:42:37 <Phyx-> heheh
14:43:00 <Saizan> ddarius: title?
14:43:17 <Phyx-> right, so to test if something failed, I need to evaluate the result and see if it was an error
14:43:35 <Twey> Phyx-: Using the ‘catch’ in Control.Exception, yeah
14:43:41 <Twey> :-\
14:44:01 <ddarius> Saizan: A 2009 paper: "A Bayesian Monte Carlo Approach to Global Illumination"
14:44:30 <Phyx-> cool, thanks Twey, I forgot about the fail function in Monad
14:44:41 <Twey> Phyx-: This is the way it should be
14:44:44 <guerrill4> so, for anyone that knows happy.. the problem is that i'm trying to use a rather restricted version of switch/case parsing in the following grammer.. http://hpaste.org/46172 but it fails to parse at the SECOND instance of the "case" keyword in the following.. http://hpaste.org/46173/ Anyone know why it would fail in the second but not the first case?
14:44:47 <Twey> Just pretend it's not there
14:44:50 <Phyx-> hahaah
14:45:40 <guerrill4> the error is simpply, certa: user error (../examples/Certa/BooleanLogic.certa:16: Parse error at token 'case')
14:45:45 <tomh> hmm is there a method to clear the ouput on cmd?
14:46:00 <ddarius> Bayes-Hermite Quadrature was what I was looking for (or presumably going to invent.)
14:46:06 <c_wraith> tomh: programmatically, or just in the terminal?
14:46:14 <tomh> programmatically
14:46:16 <c_wraith> err, at the prompt, I mean
14:46:30 <c_wraith> Hmm.  Probably, using some windows console lib.  They scare me, though
14:46:52 <tomh> basically I want to update my stdout input without creating newlines
14:47:03 <c_wraith> you can send \r s
14:47:11 <c_wraith> that probably works in cmd :)
14:47:17 <ddarius> Looks like I'm still left to invent it though.
14:47:21 <tomh> what exactly does that do?
14:47:25 <ddarius> Sorry, reinvent it.
14:47:29 <c_wraith> goes back to the start of the current line
14:47:42 <tomh> what if i need to go back multiple lines? :>
14:47:49 <c_wraith> oh, then it's useless
14:47:54 <tomh> ok
14:51:26 <gwern> > 40*2*4
14:51:27 <lambdabot>   320
14:51:31 <NihilistDandy> How is the C FFI? Mostly painless?
14:51:46 <ddarius> NihilistDandy: Many consider it one of the nicests FFIs available.
14:52:45 <NihilistDandy> ddarius: That's wonderful news. I'm looking into writing a crypto lib (or application or something) and leave most of the resource intensive calculation to C
14:54:08 <NihilistDandy> Also, is there anything in the way of a Python or Smalltalk FFI, or could I add that to my prospective projects?
14:56:16 <NihilistDandy> Oh, found MissingPy
14:56:51 <NihilistDandy> Might have to roll my own for Smalltalk, though. I'm not a fan of Squeak
14:59:48 <tomh> does getChanContents block?
15:00:54 <aristid> tomh: it's probably interleaved/lazy. in other words, evil :)
15:00:59 <c_wraith> getChanContents is probably not what you want
15:01:02 <c_wraith> yes, it's interleaved
15:01:14 <tomh> so what do I want :D
15:01:26 <tomh> readChan till its empty?
15:01:53 <aristid> tomh: readChan blocks when it's empty
15:01:59 <tomh> bah
15:02:14 <c_wraith> as far as I know, all methods of reading from a chan block when the chan is empty
15:02:27 <aristid> tomh: maybe you can use isEmptyChan. but make sure not to introduce a race condition
15:02:49 <c_wraith> isEmptyChan will block if any other thread is blocking in readChan
15:03:12 <tomh> I have one thread reading, and multiple threads writing
15:03:22 <tomh> so only the reading thread can empty the channel
15:03:27 <tomh> so that should be save right
15:03:28 <Phyx-> *sigh* there's no MonadIO instance....
15:03:35 <aristid> Phyx-: for?
15:03:41 <Phyx-> aristid: Get
15:03:51 <aristid> Phyx-: why would there be?
15:04:07 <Phyx-> aristid: how do you catch the error then?
15:04:24 <aristid> Phyx-: error?
15:04:30 <Saizan> Phyx-: if you need to catch errors you don't want to use Get
15:04:49 <Phyx-> Saizan: but Get wrappers errors on faiilure
15:04:51 <Saizan> Phyx-: iirc cereal has some support for error handling
15:05:12 <aristid> ErrorT + Get?
15:05:19 <Saizan> Phyx-: yeah, Get is meant for when you assume your data is wellformed
15:05:38 <Saizan> ErrorT wouldn't help
15:06:35 <aristid> sounds like a MAJOR design flaw of Get
15:06:46 <Phyx-> my data is wellformed, but the format i'm reading in doesn't print out the number of elements, every entry is variable sized. So I wanted to consume untill i can't anymore and move on to the next
15:07:27 <Saizan> do some preemptive checks rather than "try .. catch"
15:07:51 <aristid> or don't use Get
15:08:30 <gwern> > 400 / 3000
15:08:31 <lambdabot>   0.13333333333333333
15:09:04 <Phyx-> is there any other package for reading in binary data?
15:09:16 <aristid> cereal was mentioned earlier
15:09:22 <Phyx-> ah right
15:09:26 <ddarius> There's also attoparsec.
15:09:56 <aristid> does cereal allow parsing single bits?
15:09:57 <Phyx-> ah, that would work
15:10:55 <Phyx-> well, no, cereal seems to have the exact same interface as binary
15:10:58 <aristid> hmm, there must be a something for BIT parsing :)
15:11:12 <aristid> Phyx-: it also seems to have MonadPlus?
15:11:28 <Phyx-> ah, I missed that one
15:11:32 <Phyx-> and Alternative
15:11:34 <aristid> many foo
15:11:38 <Phyx-> yeah,
15:11:42 <aristid> isn't that precisely what you want?
15:11:48 <Phyx-> yup
15:11:51 <aristid> :t many
15:11:52 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
15:11:59 <Phyx-> I was actually trying to define it for Binary just now
15:12:01 <aristid> woohoo
15:12:36 <Phyx-> thanks aristid, ddarius
15:12:45 <aristid> :t let try f = Just <$> f <|> Nothing
15:12:46 <lambdabot> <no location info>:
15:12:46 <lambdabot>     not an expression: `let try f = Just <$> f <|> Nothing'
15:12:49 <aristid> :t let try f = Just <$> f <|> Nothing in try
15:12:50 <lambdabot> forall a. Maybe a -> Maybe (Maybe a)
15:12:59 <aristid> :t let try f = fmap Just f <|> Nothing in try
15:12:59 <lambdabot> forall a. Maybe a -> Maybe (Maybe a)
15:13:07 <aristid> :t let try f = fmap Just f <|> return Nothing in try
15:13:08 <lambdabot> forall (f :: * -> *) a. (Monad f, Alternative f) => f a -> f (Maybe a)
15:13:23 <aristid> :t let try f = fmap Just f <|> pure Nothing in try
15:13:24 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
15:13:41 <aristid> \o/ Alternative suffices to implement a simple form of try
15:14:40 <aristid> but try :: Get a -> Either String a should be possible for cereal
15:14:53 <aristid> try :: Get a -> Get (Either String a)
15:15:18 <Phyx-> yeah, should be
15:15:32 * hackagebot csv-enumerator 0.8 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.8 (OzgunAtaman)
15:15:35 <tomh> I wish there was a nice version of getChanContents~
15:15:46 <aristid> tomh: huh? what does "nice" mean?
15:15:49 <Phyx-> or try :: Exception e => Get a -> Get (Either e a)
15:15:53 <aristid> that it should be an iteratee? :P
15:16:05 <tomh> something that returns all current items it can get
15:16:11 <tomh> but doesn't block
15:16:14 <aristid> Phyx-: no, cereal uses String for error handling
15:16:34 <Phyx-> ah
15:16:42 <aristid> tomh: i think you can implement that IF you know that you are the only consumer
15:16:57 <pmetzger> can I define an infix data constructor? (I know there are preexisting ones like : of course.)
15:17:00 <aristid> tomh: if you don't know that, you might have to go deeper
15:17:00 <tomh> I am the only consumer
15:17:09 <aristid> well then it should be easy
15:17:18 <aristid> just use isEmptyChan + readChan in a loop
15:17:21 <Saizan> pmetzger: yes, they have to start with :
15:17:22 <djahandarie> pmetzger, they follow the same rules as all other functions.
15:17:26 <tomh> yeah but recursion with IO types in a loop is a pain :p
15:17:39 <pmetzger> Saizan: so the only spelling rule is the :?
15:17:47 <tomh> or are here some nice monad tricks available for that?
15:17:49 <djahandarie> Saizan, they do? Data constructors?
15:17:53 <pmetzger> I should start reading the standard document.
15:17:58 <Saizan> pmetzger: yep, : is consudered uppercase for symbols
15:18:11 <Saizan> djahandarie: infix ones do
15:18:11 <djahandarie> Oh, right
15:18:39 <tomh> sup teralaser
15:18:54 <pmetzger> so any combination of valid infix characters provided the first is a :? or can I do :foo as well?
15:18:57 <teralaser> It's not me , it is the other teralaser !
15:18:58 <pmetzger> I'm guessing the former.
15:19:13 <tomh> teralaser: yeah I mean't the other teralaser ofcourse!
15:19:16 <aristid> tomh: there's the monad-loops package
15:19:25 <aristid> tomh: but honestly, the recursion for that isn't difficult either.
15:19:32 <tomh> its just a pain
15:21:20 <aristid> tomh: \c -> untilM (isEmptyChan c) (readChan c)
15:21:46 <tomh> mm thats cool that saved me 5 lines of code :)
15:21:55 <tomh> I dont really know any monad methods
15:23:15 <aristid> f c = isEmptyChan c >>= \empty -> if empty then return [] else liftM2 (:) (readChan c) (f c)
15:23:16 <tomh> :t untilM
15:23:17 <lambdabot> Not in scope: `untilM'
15:23:19 <aristid> recursive version
15:23:24 <aristid> tomh: it's in monad-loops
15:23:40 <tomh> ok
15:23:58 <Phyx-> sweet it works
15:24:06 <tomh> yeah the code you pasted is similar to what I had
15:24:17 <pmetzger> I learned Coq like a year and a half ago. To this day, I don't entirely understand how it handles parsing of mixfix operators and such. I suppose in this respect Haskell's rules are a lot more comprehensible.
15:24:45 <aristid> tomh: i think untilM is the wrong function. you need to use whileM
15:24:45 <pmetzger> (don't entirely understand in a "what will this definition do in practice" way, never mind how it is implemented internally.)
15:24:58 <tomh> I just use the recursive function
15:25:00 <aristid> tomh: it seems like untilM checks the condition only AFTER the body
15:25:03 <tomh> then I dont need more dependencies
15:25:28 <aristid> monad-loops is pretty cool tho
15:26:36 <tomh> yeah but I want to avoid having more dependencies than code
15:26:38 <aristid> hmm. with let whileNotM c m = whileM (not <$> c) m, this would be a bit nicer.
15:26:44 <aristid> tomh: why?
15:26:45 <danharaj> I feel like a noob copy and pasting a hundred lines of code
15:26:53 <danharaj> but such is the nature of the C-bindings beast.
15:27:14 <tomh> I'm not always convinced of the quality of dependencies on hackage
15:27:34 <tomh> sometimes they rely on a lot of dependencies too
15:27:49 <tomh> which in turn require some obscure C lib which doesn't compile on windows etc
15:28:00 <aristid> monad-loops is the most innocent beast ever.
15:28:22 <aristid> it ONLY depends on base.
15:28:23 <tomh> sure :), but still I prefer without going with dependencies ;p
15:28:44 <aristid> don't blame haskell for your ugly code, then :P
15:29:35 <tomh> you are right, I'll just blame you :)
15:34:06 <aristid> tomh: if you have 3 similar loops, please reconsider using monad-loops :)
15:36:07 <Saizan> @hackage monad-loops
15:36:08 <lambdabot> http://hackage.haskell.org/package/monad-loops
15:36:23 <tomh> aristid: I only have one hopefully :)
15:37:30 <aristid> tomh: admittedly, for only one loop, using recursion might be more sensible
15:38:58 <tomh> I guess monad loops is doing recursion under the hood too
15:42:18 <aristid> of course
15:42:31 <aristid> but something like whileM crops up again and again
15:44:01 <aristid> which other languages allow you to write "while" as a function (not even a macro!)? :D
15:44:20 <ddarius> aristid: Most.
15:44:37 <tomh> I can even write while as a function in php
15:45:11 <aristid> oh well.
15:46:18 <aristid> something like this? function jswhile(c, b) { while (c()) { b(); } }
15:46:51 <tomh> yeah
15:47:09 <aristid> that's not really the same tho
15:47:29 <tomh> well you could write a recursive while loop
15:47:30 <aristid> you need to clumsily pack everything in functions first
15:47:37 <aristid> to use it
15:48:00 <tomh> well yeah.. but in haskell too
15:48:03 <aristid> IO Bool is _not_ a function
15:48:18 <tomh> well c could be a condition
15:48:27 <aristid> ?
15:48:51 <tomh> jswhile(c,b) {while(c){b();}}
15:49:22 <tomh> as long as there is state and b is enclosing c ;p
15:49:43 <aristid> so it IS technically possible in other languages, but doing it as a function is still something you would not do in other languages
15:49:49 <aristid> the inconvenience would be crippling
15:50:28 <tomh> but whats the difference with haskell?
15:50:50 <hpc> aristid: foo() and foo :: IO a are the same thing, in some respect
15:50:52 <aristid> in terms of power, there is probably no real difference to lisp macros
15:50:57 <hpc> foo() is an action, not so much a function
15:51:19 <mekeor> aristid, tomh: you talk for nearly half an hour now :) – cool
15:51:39 <hpc> so you need to clumsily pack your condition into an action, which you would do in haskell too
15:51:42 <tomh> mekeor: whats special about that
15:51:53 <aristid> hpc: every actions are already actions in haskell.
15:51:56 <aristid> hpc: no clumsy packing.
15:52:30 <hpc> aristid: heh, i was about to say "it isn't clumsy in haskell" :P
15:52:56 <mekeor> tomh: its not quotidien
15:52:58 <hpc> but saying "it isn't a function" is sort of missing the point
15:53:09 <tomh> quotidien?
15:53:21 <scree> everyday
15:53:25 <mekeor> err, yes
15:53:26 <aristid> hpc: well, you do need to pack your statement list in a function() {}
15:53:29 <tomh> oh ok
15:53:36 <tomh> plenty people talk here
15:53:59 <aristid> hpc: "statement lists" are first-class in haskell. is what what you think i should have said?
15:54:10 <hpc> aristid: perhaps
15:54:20 <hpc> aristid: im not sure what i would have said, actually
15:54:47 <mekeor> anyway, its just cool. i love haskell, functional programming*  and this IRC-channel! :)
15:54:47 <mekeor> (* although i am still a noob)
15:55:00 <tomh> dont worry im a noob too :)
15:55:15 <aristid> hpc: i think that the most reasonable model for javascript functions is (a, b, ...) -> IO value. i.e. uncurried functions in the IO Kleisli
15:55:52 <hpc> aristid: yeah
15:55:58 <hpc> with actions being () -> IO val
15:56:06 <mauke> I have no context but I think it's (JSValue, [JSValue]) -> IO JSValue
15:56:15 * mauke runs off again
15:56:25 <hpc> mauke: what's the fst for?
15:56:33 <mauke> 'this'
15:56:38 <hpc> mauke: ah
15:56:40 <aristid> hpc: well no. statements would be actions. if you need to pack them in a function with no arguments, that's still packing them in a function () -> IO a
15:57:02 <hpc> aristid: i mean, a first-class action
15:57:15 <aristid> hpc: there are no first-class actions in javascript :)
15:57:28 <hpc> aristid: i know :P
15:57:45 <hpc> to get the effect of actions, the nearest analogue is () -> IO val
15:57:47 <aristid> nor in lisp, i think. not 100% sure right now about that
15:57:49 <dolio> ddarius: You up for something later?
15:58:01 <hpc> because it's the only way to get the IO to run twice
15:58:46 <hpc> i should probably log this conversation, for when i start thinking about my javascript monad again
15:58:48 <aristid> hpc: so what i was trying to do all the time is praising IO
15:58:58 <aristid> for making actions first-class, finally
15:59:02 <hpc> aristid: :D
15:59:34 <aristid> maybe all the talk about how side-effects are evil and need to be quarantined is misplaced
15:59:40 <ddarius> dolio: Sure.
15:59:42 <hpc> moral of the story: separating IO from pure code does way more than separate the side-effects
15:59:46 <aristid> hpc: after all we allow effects to be _first-class_ :)
15:59:54 <hpc> yeah
15:59:58 <aristid> not just business class
16:00:01 <aristid> or coach :D
16:00:04 <hpc> hehe
16:00:10 <dolio> ddarius: All right. Dan's at the gym, so we'll probably contact you later for details.
16:01:04 <hpc> aristid: every time i see lisp functions with a type () -> Something, i cringe
16:01:21 <aristid> hpc: :)
16:01:26 <hpc> it is thankfully quite rare
16:01:28 <mauke> good thing lisp doesn't have types :-)
16:01:33 <aristid> hpc: how is it in ML?
16:01:48 <hpc> dunno, never seen any ML code
16:01:53 <aristid> hmm
16:01:54 <hpc> i only see lisp through friends
16:02:14 <mauke> ml : unit -> something
16:02:14 <mekeor> ML==MathML?? or HTML??
16:02:21 <mauke> mekeor: no
16:02:22 <Twey> MetaLanguage
16:02:30 <mekeor> ah
16:02:30 <hpc> MathML is a derivative of ML, iirc
16:02:35 <Twey> >.> No
16:02:42 <aristid> mauke: is unit -> something necessary for effects?
16:02:46 <Twey> MathML is an XML-based mathematical markup language
16:02:54 <aristid> mauke: or can you get effects without a function?
16:02:58 <mauke> aristid: whu?
16:03:10 <mauke> a function is the opposite of effects
16:03:13 <mekeor> ML == http://en.wikipedia.org/wiki/ML_%28programming_language%29
16:03:14 <mauke> it delays execution
16:03:14 <mekeor> ?
16:03:19 <Twey> Yes
16:03:21 <mekeor> ok
16:03:28 <aristid> mauke: i mean something like putStrLn "Hello, world!"
16:03:47 <mauke> putStrLn : string -> unit
16:03:56 <Twey> It's just impure
16:03:57 <hpc> man, it's interesting to look at older functional languages and see how they vary from haskell
16:03:59 <aristid> mauke: don't ignore the argument, man
16:04:24 <aristid> mauke: x = putStrLn "Hello, world!"
16:04:25 <aristid> mauke: how to encode x in ML?
16:04:25 <rata_> hi
16:04:25 <hpc> it's like when java coders see cobol, only awesome instead of a nightmare
16:04:25 <alpounet> ocaml is quite interesting to learn
16:04:25 <alpounet> much less to use
16:04:25 <hpc> :P
16:04:26 <mauke> aristid: yeah, you'd wrap that in a function
16:04:46 <rata_> (newbie question) why is there no foldr'?
16:04:52 <Twey> x : () -> () ?
16:05:02 <mauke> Twey: yes
16:05:04 <Twey> rata_: Because you can't evaluate a list backwards
16:05:05 <hpc> rata_: good question
16:05:34 <rata_> so foldr is always strict?
16:05:55 <Twey> rata_: No, it is always lazy
16:06:03 <Twey> … well
16:06:10 <Twey> ‘Strict’ and ‘lazy’ get a bit confusing here
16:06:22 <hpc> you have to talk about HOW it is strict
16:06:28 <rata_> then does foldr suffer from the same performance problems as foldl?
16:06:47 <hpc> rata_: foldl evaluates from the tail to the head
16:07:11 <hpc> rata_: because the list might not be fully evaluated, skipping right to the end can cause a huge thunk to form
16:07:33 <hpc> rata_: foldr evaluates from the head to the tail, which incidentally also lets it work on infinite lists
16:07:57 <hpc> rata_: foldl' evalates the list before it does the "squishing"
16:08:16 <hpc> so it goes one item at a time, and the thunks are many, but small
16:08:46 <hpc> (i am probably wrong in quite a few places)
16:09:11 <scree> hpc: the list being evaluated or unevaluated has nothing to do with problems with foldl
16:09:11 <rata_> hpc: but what about performance? I was told to use foldl' over foldl for performance reasons? should I worry about using foldr?
16:09:53 <scree> rata_: there are times when foldr is absolutely fine, and times when it will give you stack overflows on large lists
16:10:12 <c_wraith> rata_: you generally use foldr when the use of the result might not consume the whole list
16:10:26 <scree> rata_: e.g. foldr (+) 0 [1..1000000] is bad
16:10:30 <c_wraith> rata_: like, you would implement map with foldr, not foldl, because of that.
16:10:35 <scree> > foldr (+) 0 [1..1000000]
16:10:37 <lambdabot>   *Exception: stack overflow
16:10:49 <scree> > foldl (+) 0 [1..1000000]
16:10:50 <lambdabot>   *Exception: stack overflow
16:10:54 <scree> > foldl' (+) 0 [1..1000000]
16:10:55 <lambdabot>   500000500000
16:11:15 <danharaj> You shouldn't worry about performance until it actually becomes an issue.
16:11:21 <danharaj> GHC comes with excellent tools for profiling.
16:11:27 <danharaj> (See Real World Haskell Chapter 25)
16:13:06 <scree> there must be a good explanation of foldl / foldr / foldl' somewhere
16:13:19 <ddarius> You shouldn't write blatantly poor performing code either.
16:13:28 <aristid> ddarius: why not?
16:13:51 <ddarius> aristid: Because fixing bugs later is harder than fixing them earlier even for performance bugs.
16:14:17 <scree> rata_: have you read http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
16:14:46 <danharaj> ddarius: When do you think someone new to Haskell should sit down and wrap their head around how the evaluation strategy works? Because 'blatant' is relative to how well you understand how GHC/your compiler does things.
16:15:12 <alpounet> now we can just point people to ezyang's blog
16:15:17 <ddarius> danharaj: Immediately.
16:15:40 <scree> danharaj: right, when you consider it is a valid question, but saying "ignore it, the profiler will tell you" doesn't help
16:15:49 <ddarius> One of the whole points of Haskell is that it has a different evaluation strategy from almost every other language.
16:16:00 <scree> danharaj: even when the profiler tells you your performance is rubbish, you still need to understand why
16:16:10 <danharaj> scree: You can cross that bridge when you come to it.
16:16:17 <aristid> ddarius: you don't need to learn about seq right at the beginning, tho
16:16:37 <ddarius> aristid: You need to learn pretty damn soon though.
16:17:00 <alpounet> i'd say when writing your first actual program in haskell
16:17:12 <danharaj> I honestly think someone new to haskell has too much food on their plate if they try to learn simultaneously everything that is different about haskell.
16:17:16 <danharaj> Unless they are completely fresh, then it's easier :p
16:18:11 <aristid> ddarius: why?
16:18:33 <ddarius> danharaj: If you already know a typical language, then it's even more important to understand the evaluation strategy because otherwise your "natural instincts" will produce horrible code.
16:18:42 <ddarius> aristid: Because the problems come up pretty damn soon too.
16:18:56 <scree> danharaj: it depends.  If you have someone who has seen another functional language, this is the most important thing that's different about haskell
16:19:14 <alpounet> aristid, because when you try to write your first actually useful and "serious" piece of code in Haskell, you'll encounter some problems if you don't know the evaluation strategy
16:19:27 <hpc> ddarius: the way i learned haskell's evaluation order was "write what things are, not what they do; evaluation takes care of itself"
16:19:35 <danharaj> ddarius: When I tried learning Haskell, trying to learn everything from the start pretty much killed me. When I just started writing code and learning things as I came across the problems they solved, I actually started learning.
16:19:38 <hpc> ddarius: it worked well enough until i was ready to get into how it really worked
16:19:39 <aristid> alpounet: can't you pretend that all functions are lazy?
16:19:43 <scree> danharaj: though I agree you want people writing code that compiles before you teach them to write code that runs in time
16:20:10 <alpounet> aristid, yeah sure but then you run into IO's mess
16:20:11 <ddarius> aristid: No, but most new-comers pretend that all functions are eager at least with regards to performance.
16:20:21 <alpounet> and you have very poor performances
16:20:50 <danharaj> I think the best time to learn about performance is the first time it bites you in the ass. That tends to be pretty fast anyway. I don't think you should worry about it until you come across it though.
16:21:12 <aristid> alpounet: well i haven't really ever cared about the performance of any haskell program i've written
16:21:29 <hpc> i haven't ever encountered performance issues
16:21:32 <aristid> but mind you i'm not doing this for long
16:21:42 <aristid> most of the time i play in ghci
16:21:48 <danharaj> I have, but they were particular to Repa and not caused by evaluation strategy per se.
16:21:49 <pmetzger> I have a friend who uses Haskell in trading systems. He spends a lot of time worrying about space leaks and such.
16:21:50 <hpc> my worst performance problem was an unbuffered log file handle on my irc bot
16:21:57 <alpounet> aristid, well, i have, i've been writing several math or AI related code
16:22:08 <alpounet> several times*
16:22:10 <scree> I do think there's a difference between the "performance issues" we keep referencing and "error: stack overflow"
16:22:11 <pmetzger> I'm glad I don't care very much for what I'm doing right now.
16:22:24 <hpc> solution was to make the file point to /dev/null, since i didn't really want logs anyway
16:22:58 <ddarius> scree: Yes, I agree that there are different levels of awareness.  I don't think everyone needs to learn about unboxing, say, the first day, but then that isn't integral to the language.
16:23:34 <ddarius> Anyway, understanding the evaluation strategy isn't just a performance issue.
16:25:05 <scree> ddarius: so, I guess I'm saying I'm fine with most pedagogical arguments about the order of teaching things; I do object to the "who cares" approach
16:26:32 <ddarius> scree: I agree, though I would say a sound pedagogical argument about the order of teaching things would have evaluation strategy pretty early anyway, and actually, some of the typical "poor performance" examples are good exercises in understanding the evaluation strategy.
16:27:07 <scree> ddarius: agreed
16:27:35 <scree> I think we lost the guy who asked the question
16:27:44 <danharaj> my bad >_>
16:28:29 <alpounet> as usual scree heh
16:30:43 <danharaj> Just need to wrap up samplers and I'll be done with my interface for now :[
16:31:08 <pastorn> danharaj: are you having a repo somewhere where i could steal your codez?
16:31:18 <danharaj> pastorn: I'll try to set one up this weekend.
16:40:08 <rata_> is there a built-in function like "f g a b = g b a"?
16:40:18 <shachaf> @pl f g a b = g b a
16:40:18 <lambdabot> f = flip
16:40:43 <rata_> oh nice =)
16:40:46 <rata_> thanks shachaf
16:41:14 * lambdabot bows.
16:41:18 <djahandarie> @thx
16:41:18 <lambdabot> you are welcome
16:41:20 <Nereid> @djinn (a -> b -> c) -> (b -> a -> c)
16:41:21 <lambdabot> f a b c = a c b
16:41:23 <Nereid> :>
16:41:54 <shachaf> @. pl djinn (a -> b -> c) -> b -> a -> c
16:41:54 <rata_> I'm using foldr over foldl just because of the order of in which arguments are passed to the function
16:41:55 <lambdabot> f = flip
16:42:11 <rata_> but I could use flip to use foldl'
16:42:22 <shachaf> Or you could just use a lambda.
16:46:55 <rata_> shachaf: but that'd be more verbose
16:48:07 <rata_> how can I make this fn polymorphic? frequencies = foldr (addToEntry 1) (Map.empty :: Map.Map String Integer)
16:48:11 <shachaf> rata_: Using foldr instead of foldl is just doing a different thing, though.
16:48:49 * hackagebot mysql-simple 0.2.0.0 - A mid-level MySQL client library.  http://hackage.haskell.org/package/mysql-simple-0.2.0.0 (BryanOSullivan)
16:49:09 <shachaf> @ty foldr (?addToEntry 1) (M.empty :: M.Map String Integer)
16:49:10 <lambdabot> forall a t. (?addToEntry::t -> a -> M.Map String Integer -> M.Map String Integer, Num t) => [a] -> M.Map String Integer
16:49:13 <Saizan> using foldr to insert things in a Map begs for stack overflow
16:49:14 <shachaf> Polymorphic in what?
16:49:21 <rata_> nevermind... just taking away the type declaration makes it polymorphic
16:49:39 <rata_> I tried that before, but didn't work... don't know why it works now
16:49:42 <rata_> but it works =)
16:49:49 * hackagebot mysql 0.1.0.1 - A low-level MySQL client library.  http://hackage.haskell.org/package/mysql-0.1.0.1 (BryanOSullivan)
16:50:01 <Eduard_Munteanu> It begs the question of what type you want for it.
16:50:16 <c_wraith> rata_: that should really be a foldl'
16:50:29 <rata_> c_wraith: why?
16:50:50 <rata_> shachaf: in this case it'd be the same, wouldn't it?
16:51:05 <c_wraith> because the core of what you're doing is updating an accumulator with each element from a list.  for that pattern, foldl' is correct
16:52:03 <Eduard_Munteanu> It also doesn't help that ops on numeric types are strict.
16:52:18 <micahjohnston> @help
16:52:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:52:26 <micahjohnston> @list
16:52:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:56:48 <Dashkal> callCC is terrifying.  Very cool, but terrifying.  I had no idea the imperative function return could be defined that way.
16:58:33 <rata_> c_wraith: thank you for the tip... I didn't know about that
16:59:28 <dolio> > runCont (callCC (\return -> return 5 ; return 6 ; return 7)) id
16:59:29 <lambdabot>   <no location info>: parse error on input `;'
16:59:38 <dolio> > runCont (callCC (\return -> do return 5 ; return 6 ; return 7)) id
16:59:39 <lambdabot>   5
17:00:02 <shachaf> \return--
17:00:28 <dolio> ?karma \return
17:00:28 <lambdabot> \return has a karma of -1
17:00:36 <c_wraith> One of these days, I *really* should wrap my head around ContT
17:00:40 <shachaf> No point in gratuitous evil like that.
17:00:43 <Twey> It's not very scary
17:00:48 <Twey> It's just sugar around CPS
17:01:00 <Dashkal> I'm learning CPS now.  So new concept to me.
17:01:10 <c_wraith> It's not scary, it's just very circular, and I've never bothered learning the particular circle it uses
17:01:12 <Twey> CPS is not very scary either :þ
17:01:16 <Twey> Aye
17:01:56 <Dashkal> I was using "Terrifying" because I've just spent all this effort learning that I don't need the imperative return.  Now I know how to get it back.
17:02:52 <dolio> callCC is a bad operation anyway.
17:03:01 <dolio> It doesn't give you the possibility of just discarding the continuation.
17:03:25 <Twey> How would you implement that?
17:03:32 <dolio> Implement what?
17:03:47 <Twey> A callCC that gives the option of just discarding the continuation
17:04:58 <dolio> @type let control f = Cont (\k -> runCont (f (\x -> Cont (\_ -> k x))) id)
17:04:59 <lambdabot> <no location info>:
17:04:59 <lambdabot>     not an expression: `let control f = Cont (\k -> runCont (f (\x -> Cont (\_ -> k x))) id)'
17:05:24 <pumpkin> dolio, ddarius: omnomnom?
17:06:04 <dolio> Cont apparently isn't in scope.
17:06:17 <shachaf> dolio: It's called cont nowadays.
17:06:23 <shachaf> Since it uses ContT.
17:06:31 <aristid> :t cont
17:06:32 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
17:06:32 <dolio> Oh right.
17:06:51 <aristid> :t runCont
17:06:52 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
17:07:03 <dolio> @type let control f = cont (\k -> runCont (f (\x -> cont (\_ -> k x))) id) in control
17:07:04 <lambdabot> forall a a1 a2. ((a -> Cont a1 a2) -> Cont a1 a1) -> Cont a1 a
17:09:45 <dolio> @djinn ((a -> Cont r Void) -> Cont r Void) -> Cont r a
17:09:45 <lambdabot> f a b = a (\ c _ -> b c) void
17:09:49 <dolio> That's another choice.
17:11:25 <dolio> That second one sort of ensures that you call the continuation.
17:12:03 <dolio> But it's your decision.
17:12:59 <shachaf> @djinn Void -> a -> a
17:12:59 <lambdabot> f = void
17:13:16 <shachaf> @djinn a -> Void -> a
17:13:17 <lambdabot> f _ a = void a
17:13:29 <shachaf> Sure is enthusiastic about using Void when it has one.
17:13:31 <copumpkin> @djinn Void -> Not (Not a) -> a
17:13:31 <lambdabot> f = void
17:13:38 <copumpkin> shachaf: I would be too
17:13:39 <hpc> @src void
17:13:39 <lambdabot> Source not found. Where did you learn to type?
17:13:41 <hpc> :t void
17:13:41 <lambdabot> Not in scope: `void'
17:13:50 <copumpkin> void :: Void -> a
17:14:01 <hpc> void = const undefined?
17:14:12 <dolio> void is the empty function.
17:14:18 <shachaf> data Void -- Keep out of reach of pumpkins.
17:14:40 <dolio> djinn only produces total functions.
17:14:47 <monochrom> void's type is not exactly expressible in haskell98. but there is an extension for that
17:14:48 <hpc> and type Not a = Void -> a?
17:15:00 <dolio> a -> Void
17:15:01 <copumpkin> a -> Void
17:15:03 <hpc> ah
17:15:06 <monochrom> otoh coq etc can do its type
17:15:58 <dolio> copumpkin: I'm going to head over. You wait to see if ddarius answers.
17:16:04 <copumpkin> dolio: sounds good
17:17:10 <ddarius> copumpkin: Where?
17:17:37 <copumpkin> ddarius: you have anywhere in mind? I'm kind of idea-less :P
17:17:44 <copumpkin> kind of want to try something new
17:17:59 <monochrom> in constructive logic, Void (the type, the statement) stands for a statement that has no proof. if you drink the "statement = set of its proofs" koolaid, then Void is the empty set
17:18:25 <monochrom> therefore you have a function with domain Void and co-domain whatever you like
17:19:22 <monochrom> and so it reads like a way to prove the tautology "false implies whatever"
17:20:31 <ddarius> monochrom: A statement is either true or false, why would you want to know why it is so?  Isn't it enough to that it is?
17:21:36 <monochrom> sometimes I want to know for curiosity. some other times I do not want to know
17:22:45 <monochrom> but I do the above explanation in honour of what Russell says
17:23:30 <monochrom> that as an intelligent being I am fully capable of entertaining an idea I disdain
17:23:57 <ddarius> copumpkin: http://www.theblueroom.net  Maybe.  It's in my list but I've never been there.
17:25:51 <copumpkin> ddarius: looks good, meet at kendall then?
17:27:35 <ezyang> I need a priority queue for GHC. Do any of the bootstrap libraries have one?
17:27:52 <aristid> ezyang: what does "bootstrap" mean?
17:28:08 <aristid> ooh i know now
17:28:22 <aristid> ezyang: which libraries are bootstrap though?
17:30:10 <Saizan> ezyang: the new IO manager uses a priority queue iirc
17:30:32 <ezyang> I believe they're all the ones here: http://www.haskell.org/ghc/docs/7.0.3/html/libraries/
17:30:40 <ezyang> Saizan: Ah, interesting.
17:31:31 <ddarius> copumpkin: Easier for me to just meet there and no harder for you.
17:31:32 <ezyang> wait, but isn't that all in RTS...
17:31:51 <copumpkin> ddarius: sure, but that place is at kendall square isn't it?
17:33:17 <copumpkin> oh I see
17:33:22 <copumpkin> kendall stop isn't near kendall square
17:33:28 <copumpkin> sure, let's meet there then
17:34:20 <ddarius> I estimate that it will take about 45 minutes for me to walk there.
17:34:20 <shapr> copumpkin: I want to show up too :-(
17:35:25 <copumpkin> okay, sounds good
17:37:47 <ddarius> shapr: I estimate it's about a 45 day walk from Alabama to Boston.
17:38:13 <aristid> that'd be healthy
17:38:21 <ezyang> Aha! Priority Search Queue in events!
17:38:25 <Saizan> now you just need a device that converts days in munites
17:38:27 <ddarius> aristid: Probably not.
17:38:43 <Saizan> *into minutes
17:38:46 <aristid> ddarius: he'd probably better do pause for eating and sleeping.
17:39:02 * hackagebot TBC 0.0.2 - Testing By Convention  http://hackage.haskell.org/package/TBC-0.0.2 (PeterGammie)
17:39:16 <ddarius> aristid: That was including time to sleep and eat.
17:40:03 <aristid> ddarius: why wouldn't it be healthy then? compared to sitting all day?
17:41:02 <aristid> ezyang: the bootstrapped GHC only supports a small subset of haskell, and that's all that's used in all these libraries?
17:41:07 <ddarius> aristid: Walking that distance in that time will destroy your feet and you will lose a ton of weight, and there are also other hazards.
17:41:26 <ezyang> erm not quite.
17:41:32 <aristid> ddarius: hm, you assumed a rather high walking speed?
17:41:48 <ezyang> More like, when we build the stage2 compiler it needs a bunch of libraries to function properly, those are the bootstrap ones.
17:41:51 <ddarius> aristid: No.  That's about a 3 mile per hour walking speed for 10 hours of walking a day.
17:42:38 <aristid> i think i couldn't keep that speed for 10 hours
17:42:45 <ddarius> aristid: Sure you can.
17:43:03 <Saizan> ?google 3 miles in km
17:43:04 <lambdabot> 4.828032 kilometers
17:43:04 <lambdabot> http://www.factmonster.com/ipka/A0001713.html
17:43:04 <lambdabot> Title: Conversion of Miles to Kilometers and Kilometers to Miles — FactMonster.com
17:43:13 <ddarius> A brisk walk would be five miles per hour.  A casual walk is about three.  A military march is about three.
17:43:18 <ddarius> I was doing that encumbered.
17:43:20 <aristid> Saizan: i did that calculation too, before answering :)
17:47:31 <aristid> ddarius: hmm i just calculated that the last time i walked for more than 10 minutes, and encumbered, i had an average speed of 4.9 km/h. which is about 3 miles per hour.
17:48:19 <gwern> you could do 3 miles per hour for 10 hours, but for most people it'd give them blisters and they'll regret it the next day
17:48:32 * gwern learned this in the boy scouts
17:48:45 <ddarius> Useful life lessons.
17:49:19 <gwern> especially if you plan to cheap out on transportation and walk places in cities
17:49:35 <aristid> historically people walked a lot
17:49:44 <aristid> i wonder at which pace and for how many hours per day
17:50:36 <gwern> aristid: some of the rates are crazy. in _Discovery of France_, the author mentions that some groups of peasants occasoinally walk 50 or 60 miles a day
17:50:42 <aristid> how many hours per day to military people march if they're on extended marches?
17:50:54 <aristid> -to+do
17:50:56 <gwern> aristid: I particularly liked the northern french shepherds who ran around at 20 mph on stilts
17:51:49 <gwern> aristid: their stilts had a third leg so when they were with the flocks, they leaned back and just sat and watched
17:52:00 <aristid> gwern: so they were much more capable of enduring extended walking? (not the stilt people, the other ones)
17:52:44 <gwern> aristid: oh yes. the numbers are ridiculous. if there weren't so many numbers from so many periods.... we're really crappy physically compared to our ancestors
17:52:53 <gwern> even with better nutrition and medicine
17:53:06 <aristid> gwern: even those among us who are well-trained?
17:54:00 <gwern> aristid: mm... there are the pima indians, iirc. random old men come out and place highly in ultramarathons
17:54:07 <gwern> or whatever kind of marathons they were
17:55:05 <aristid> so there's a large genetic component to the recent "crappy shape" phenomenon?
17:55:39 <Saizan> i don't think there's much genetic difference between us and medieval peasants
17:56:29 <aristid> Saizan: that's why i'm asking.
17:56:44 <aristid> the environment _has_ changed drastically over a short time
17:57:35 <gwern> aristid: I don't think the genetics have changed an awful lot either; but the environment certainly has
17:57:38 <Saizan> iirc there isn't even much genetic diversity left in humans
17:57:57 <danharaj> There's plenty.
17:58:12 <gwern> Saizan: without a metric, how can you say 'much' or 'little'?
17:58:36 <aristid> gwern: but wouldn't that imply that well-trained people could achieve the same kinds of metrics?
17:58:44 <Saizan> gwern: never thought it'd be hard to get a metric for this
17:58:49 <gwern> Saizan: there's much interesting variation. the ashkenazi genetics; the sherpa mountain adaptations; neoteny and lactose tolerance
17:59:21 <gwern> Saizan: is there more variation in humans than, say, dogs? probably not. but do we care? sounds like asking 'are there more genes in humans or rice?'
17:59:37 <aristid> rice wins! rice is the better species.
18:00:07 <Saizan> http://en.wikipedia.org/wiki/Ultramarathon#IAAF_World_Records <- it seems trained people can do quite well
18:02:18 <aristid> Saizan: damn that's awfully fast
18:02:38 <gwern> Saizan: and the marathon monks of tendai are an interesting example. I don't know of any more challenging set of runs, and living buddhas are awful rare since wwii - in part due to the fatalities
18:02:45 <gwern> sry, mt hiei
18:03:09 * gwern notes for the record that tendai is the sect, and mt hiei their base
18:05:02 <gwern> Saizan: so arguably at least a part of it is that we moderns *won't* do the same feats, not that we couldn't
18:07:09 * hackagebot hDFA 0.0.1 - A simple library for representing and minimising DFAs.  http://hackage.haskell.org/package/hDFA-0.0.1 (PeterGammie)
18:07:43 <aristid> gwern: and that moderns *don't have to* do them.
18:08:00 <gwern> aristid: well, the monks don't have to do them either. there are many ways to enlightenment
18:08:07 <gwern> always have been
18:08:21 <aristid> gwern: the shepherds probably had some real benefits from running fast
18:08:55 <gwern> aristid: sure. the stilts also made it easier since they were elevated above the tall grasses. so it was a very useful tradition for them
18:09:15 <aristid> how high were these stilts?
18:09:51 <gwern> hmm.. pretty tall stilts. not sure. less than 20 feet, higher than 5 feet :)
18:11:16 <danharaj> blah
18:12:34 <aristid> i like my international units
18:12:38 <aristid> which are not feet
18:12:41 <aristid> :P
18:12:42 <gwern> aristid: unfortunately no pirate ebooks seem to be available
18:12:54 <gwern> aristid: feet are international! why, the average person has ~1.9 feet
18:13:17 <HugoDaniel> im doing a opengl window creator in haskell
18:13:28 <aristid> gwern: i like how 1 yard is almost 1 meter
18:13:29 <HugoDaniel> im probably going to upload this to haskell now
18:13:37 <HugoDaniel> s/haskell/hackage
18:13:55 <aristid> most people are about two yards high
18:14:00 <aristid> :D
18:14:19 <aristid> well, men. and average. and...
18:17:52 <rostayob> is there a way of using just a subset of pandoc markdown?
18:18:32 <gwern> rostayob: sure. just write in that subset
18:18:32 <Saizan> just do?
18:18:46 <rostayob> no I mean, of enforcing a subset
18:19:07 <rostayob> as in that it won't parse certain things (e.g. HTML blocks)
18:19:26 <kmc> pandoc parses html blocks?
18:19:30 <gwern> hm... I don't think the config allows you to disable various extensions like that. some, but not all
18:19:41 <rostayob> kmc: http://johnmacfarlane.net/pandoc/README.html#raw-html
18:19:55 <shachaf> aristid: I like how 1 meter is almost 1000 centimeters.
18:20:04 <rostayob> because I want to use it in a reddit-like application
18:20:15 <gwern> most of the options in a Pandoc Config record are about output
18:20:15 <kmc> "The raw HTML is passed through unchanged in HTML, S5, Slidy, EPUB, Markdown, and Textile output, and suppressed in other formats."
18:20:16 <rostayob> and I don't want people to insert HTML or images or stuff like that
18:20:20 <kmc> sounds like it's not parsing it in either case
18:20:21 <gwern> rostayob: does the --strict not help?
18:20:37 <shachaf> I don't think Pandoc is meant for that.
18:20:38 <kmc> you can probably patch it to do that suppression thing always
18:20:41 <aristid> shachaf: come on. 1 Yard = 0.9144 Meter. that's really pretty close
18:20:43 <kmc> i don't know if there's a switch for it
18:20:48 <danharaj> Ok... I need to start haddocking and cabalizing this library I'm working on.
18:20:54 <rostayob> gwern: the strict would help but I want to keep some extensions.
18:20:56 <danharaj> What are two nice guides to those?
18:21:16 <rostayob> shachaf: well, for example they use it for gitit
18:21:27 <aristid> shachaf: or was the factor 10 error in your sentence not intended? :P
18:21:28 <rostayob> the best thing would be to have bindings for that: https://github.com/tanoku/upskirt
18:21:32 <shachaf> Isn't gitit a one-person thing?
18:21:44 <rostayob> shachaf: to be honest, I don't know :P
18:21:52 <shachaf> aristid: Er. I meant 100 or millimeters, take your pick.
18:22:51 <gwern> shachaf: gitit is one person, except for the plugins
18:23:21 <aristid> shachaf: hehe ok then
18:23:23 <rostayob> so is there a markdown parser safe for use in a situation like that? I'm really tempted in writing bindings for upskirt, it seems the only one
18:23:52 <kmc> that's easier than patching pandoc?
18:24:13 <rostayob> kmc: I don't know, but pandoc does way more things that what I need
18:24:16 <gwern> rostayob: you could try filtering the AST
18:24:50 <rostayob> gwern: you mean parsing 'Pandoc' after it has been generated?
18:25:05 <gwern> sure
18:25:13 <kmc> not parsing
18:25:23 <rostayob> yeah right, just filtering
18:25:23 <kmc> Pandoc is a Haskell library
18:25:28 <rostayob> mh. that's a nice idea
18:25:30 <kmc> you can transform the data types it uses natively
18:26:10 <kmc> http://hackage.haskell.org/packages/archive/pandoc-types/1.8/doc/html/Text-Pandoc-Definition.html#t:Block
18:26:19 <gwern> you don't like image links? well, define a filter that eats Link x, checks for image extension, and drops it
18:26:28 <kmc> just guessing here that you want to remove "RawBlock" and "RawInline" elements
18:26:44 <gwern> or actually image links have different syntax, so I guess you don't check Link but whatever constructor images are
18:26:52 <rostayob> yes I was reading that, I might just sanitize the input when the user inputs it
18:27:06 <rostayob> instead if filtering and dropping each time I display it
18:27:21 <gwern> rostayob: you mean parse into Pandoc, filter, and save that?
18:27:35 <gwern> er, parse, filter, unparse back into markdown
18:27:49 <rostayob> gwern: I would never save the 'Pandoc', I store the plain text into a database and i parse it when I need to display it
18:28:07 <gwern> rostayob: well, not sure your users will like that
18:28:13 <rostayob> gwern: well without the unparsing stuff, I could simply say "you can't do that"
18:28:18 <rostayob> when a user tries to put HTML
18:28:44 <gwern> rostayob: yeah, I think I'd go with that. you define your parse and define a check 'filtered pandoc == pandoc'
18:29:22 <gwern> rostayob: I mention unparsing as a problem because you can't roundtrip markdown with pandoc. when you serialize/unparse the Pandoc out to Markdown, the Markdown may look quite different from the original
18:29:29 <rostayob> or simply checkPandoc :: Pandoc -> [PandocError], and then null (checkPandoc input)
18:29:48 <rostayob> where I define PandocError
18:30:36 <rostayob> yeah that could work, the only downside is that for some stuff is just better not to parse it
18:30:50 <rostayob> for example the syntax for images is like "![la lune](lalune.jpg "Voyage to the moon")"
18:31:01 <rostayob> the ! indicates an image
18:31:14 <rostayob> so now if someone puts a ! before a link, he'd get an error
18:31:31 <rostayob> I could convert images to simple links, boh
18:32:21 <gwern> rostayob: see http://groups.google.com/group/pandoc-discuss/browse_thread/thread/f678a63224cdbb71/b05cfab8ab26ef45 about why markdown roundtrip doesn't preserve the formatting
18:32:50 <gwern> rostayob: if I were a user I'd be annoyed at my comments being rewritten even if it generated identical HTML. so your check and reject approach is probably better
18:32:56 <rostayob> still, it would be nice to have
18:32:58 <rostayob> Upskirt has been extensively security audited, and includes protection against all possible DOS attacks (stack overflows, out of memory situations, malformed Markdown syntax...) and against client attacks through malicious embedded HTML.
18:33:00 <rostayob> We've worked very hard to make Upskirt never crash or run out of memory under any input. Upskirt renders all the Markdown content in GitHub and so far hasn't crashed a single time.
18:33:14 * hackagebot husk-scheme 2.4 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-2.4 (JustinEthier)
18:33:23 <rostayob> I mean upskirt basically does exactly what I want, and it does it well
18:33:24 <gwern> rostayob: presumably upskirt has a testsuite. run it against pandoc
18:33:40 <rostayob> gwern: right, why didn't I think of that :D ?
18:34:21 <gwern> rostayob: if you want examples of filtering and processing the Pandoc AST, look at the gitit plugins
18:35:12 <rostayob> actually, it just seems to have the standard markdown tests, no stress tests
18:35:29 <gwern> ...then how on earth do they know they're not reintroducing vulnerabilities?
18:35:44 <gwern> hell, even lambdabot/mueval at least records evil expressions in a shell script
18:35:48 <rostayob> don't ask me
18:36:05 <rostayob> but if it works for github. maybe it doesn't mean much ehe
18:36:25 <rostayob> that's the thing i did btw, it's an hacker news clone: http://mazzo.li:8000/
18:36:48 <rostayob> but right now I have no control over what's posted lol
18:36:57 <rostayob> i still have to code the administration
18:36:59 <rostayob> and other things
18:38:34 <rostayob> happstack is cool, especially acid-state
18:39:33 <gwern> (yeah, but I distrust it in a long-term sense)
18:39:49 <rostayob> gwern: what do you mean?
18:40:05 <gwern> rostayob: as in, I'm not convinced it'll still be compilable in, say, 5 or 6 years
18:40:13 <gwern> or that gitit will still work, to be more specific
18:40:38 <rostayob> you mean that it'll be discontinued?
18:41:38 <rostayob> it's still quite active right now anyway
18:41:43 <gwern> something like that
18:41:56 <gwern> gitit isn't very active now; not sure about happstack
18:42:05 <rostayob> oh, I don't know about gitit
18:42:33 <rostayob> but coding in happstack is quite fun
18:42:47 <rostayob> the only thing is that there's some fragmentation between the libraries
18:43:16 <rostayob> like if you use happstack + hsp + web-routes + digestive-functors + acid-state etc etc
18:43:48 <rostayob> anyway, I better take that down and sleep now, thanks for your help
18:48:59 * gwern stares confusedly at the freebsd man page for tar. 'This is Unix. I (don't) know this!'
18:55:51 <hpc> gwern: on ubuntu, the top of my man page says BSD
18:55:58 * hpc has a confuse
18:56:37 <gwern> hpc: yes, that is confusing; but I know this system is freebsd because the tar man page is so different
18:56:39 <gwern> oh well, doesn't matter. the usual switches work
19:15:42 <gwern> wow. `find` has such wretched syntax
19:16:16 <gwern> 'find . -type d \( -name _darcs \) -prune -o -print' <-- oh, that makes perfect sense to find everything in ./ except things under _darcs ಠ_ಠ
19:17:41 <Jafet> Remember to use -print0 if your filenames contain newlines.
19:18:15 <drhodes> you mean spaces?
19:18:44 <nyingen> filenames containing newlines...scary
19:18:51 <gwern> Jafet: ...I can't say it's ever occurred to me to name my files using newlines
19:18:52 <Draconx|Laptop> drhodes, spaces are no problem.
19:18:59 <HugoDaniel> k
19:19:08 <HugoDaniel> just finished uploading my first hackage package
19:19:08 <HugoDaniel> :P
19:19:19 * hackagebot GLHUI 1.0.0 - Open OpenGL context windows in X11 with libX11  http://hackage.haskell.org/package/GLHUI-1.0.0 (HugoGomes)
19:19:22 <Jafet> Of course, only (some) GNU programs will take null-separated filenames, so you have to do every subsequent thing with wretched xargs syntax.
19:32:02 <ManateeLazyCat> Dear code.haskell.org administrator, can you help me fix ssh push problem, server don't know me know, i can't push any patch now, i have send mail to support@community.haskell.org , but onone help me. :(
19:59:13 <sm> same here
20:02:40 <ManateeLazyCat> @tell dons Can you fix curl package for GHC-7.0.3, i can't compile curl package under GHC-7.0.3 with error : ".size expression for curlzm1zi3zi6_NetworkziCurlziCode_CurlSSLIssuerError_static_entry does not evaluate to a constant"
20:02:40 <lambdabot> Consider it noted.
20:06:44 <luite> ManateeLazyCat: yep same problem here
20:07:02 <ManateeLazyCat> luite: Hope dons will fix it soon. :)
20:11:05 <ManateeLazyCat> Move all my repository to patch-tag.com, don't use code.haskell.org anymore.
20:11:28 <applicative> I did 'cabal install curl' without incident...
20:11:36 <luite> ManateeLazyCat: I believe there was a problem with the server and user accounts were lost
20:13:14 <luite> applicative: which platform? I'm on ubuntu 11.04 x64 with ghc 7.0.3
20:13:19 <ManateeLazyCat> luite: Yes, i still can't push any patch to code.haskell.org and noone help me.
20:13:38 <applicative> ManateeLazyCat: I wonder if you can compile the curl package if you strike the -fvia-C option
20:13:47 <xAndromeda> does anybody have updated instructions on how to install leksah?  the one one at http://rizwanbulbul.blogspot.com/2010/06/installing-leksah-gtk-gtk2hs-and-glade.html no longer works
20:14:04 <luite> ManateeLazyCat: dons recently got a new job so he might be busy for a while
20:14:07 <applicative> luite, os x, it has some problem with -fvia-C, so the cabal file is over ruled ... and it compiles
20:14:20 <applicative> new job?
20:14:24 <ManateeLazyCat> applicative: No, i can't
20:14:49 <luite> xAndromeda: what doesn't work?
20:15:01 <luite> xAndromeda: looks like most of these should still be correct
20:15:09 <ManateeLazyCat> xAndromeda: Please make sure ~/.cabal/bin in your PATH variable
20:15:32 <ManateeLazyCat> xAndromeda: And gtk2hs-buildtools must install before gtk2hs and leksah
20:15:41 <xAndromeda> luite, the last step There is no available version of ghc that satisfies >=7.0 && <7.2
20:15:42 <luite> xAndromeda: I personally wouldn't use --global
20:15:54 <ManateeLazyCat> applicative: I consider remove curl library from my dependent
20:16:35 <applicative> ManateeLazyCat for this reason?
20:16:48 <ManateeLazyCat> applicative: yes.
20:17:04 <xAndromeda> @_@
20:17:09 <xAndromeda> confused
20:17:28 <hamishmack> xAndromeda: http://code.google.com/p/leksah/issues/detail?id=215
20:17:52 <applicative> haha, xAndromeda your advisor is here.
20:20:57 <luite> I've recently installed leksah without problems (was slighly surprised that it worked and even started without crashing) :)
20:21:32 <ManateeLazyCat> hope darcs push faster (2225 patches ... push)
20:21:52 <luite> hehe switch to git, it's what all the cool kids use ;)
20:22:24 <ManateeLazyCat> lut
20:22:24 <ManateeLazyCat>  
20:22:47 <ManateeLazyCat> All haskell repositories at patch-tag.com, i'm too lazy, and don't want to switch.
20:23:12 <ManateeLazyCat> I'm afraid darcs will dead someday since ghc team has switch to git.
20:24:26 <ManateeLazyCat> It's sad that haven't so much time write haskell code.
20:24:49 <gwern> ManateeLazyCat: fortunately there are multiple darcs->git other vcs bridges, and another one starting this GSOC
20:25:42 <ManateeLazyCat> gwern: yes, bridge, but so many people switch to git, i perhaps will do that someday.
20:25:58 <gwern> and until you do, you can use darcs without fear of being trapped
20:26:51 <ManateeLazyCat> gwern: Infact, darcs is enough for me, but darcs host is not good enough
20:27:03 <hamishmack> xAndromeda: did that help?  I suspect installing haddock 2.8.1 will help cabal resolve the dependancies.
20:27:16 <ManateeLazyCat> patch-tag.com is best one, but patch-tag.com looks down now.
20:27:24 <ManateeLazyCat> I mean web down
20:27:52 <xAndromeda> hamishmack, no i still have no clue what's going on lol
20:28:07 <ManateeLazyCat> I plan move all gtk2hs repository to patch-tag.com since i can't push any patch to code.haskell.org
20:28:17 <hamishmack> xAndromeda: try cabal install haddock-2.8.1 --global
20:29:04 <xAndromeda> hamishmack,  i get cabal: /usr/local/share/doc/xhtml-3000.2.0.1: permission denied
20:29:05 <xAndromeda> cabal: /home/andro/.cabal/logs/build.log: permission denied
20:30:10 <hamishmack> xAndromeda: Those instructions are a bit annoying as they use --global.
20:30:35 <hamishmack> xAndromeda: it would be better if they did not
20:31:08 <xAndromeda> hamishmack, O.o
20:31:32 <hamishmack> xAndromeda: have you already installed sutff using sudo and --global as per the instructions in the blog?
20:32:04 <xAndromeda> hamishmack, i think so
20:32:42 <hamishmack> xAndromeda: then you will need to "sudo cabal install haddock-2.8.1 --global"
20:33:02 <hamishmack> Then "sudo cabal install leksah"
20:34:19 <xAndromeda> kk trying
20:34:50 <hamishmack> xAndromeda: If it still fails try "sudo cabal install gtksourceview2-0.12.2 --global"
20:35:07 <leavengood> Having a problem installing parsec
20:35:09 <leavengood> http://hpaste.org/46179/error_installing_parsec
20:35:18 <hamishmack> xAndromeda: and "sudo cabal install leksah --constraint 'glib>=0.12' --global"
20:37:14 <applicative> leavengood, what does "ghc-pkg list" say about mtl
20:38:29 <leavengood> applicative: it is there
20:38:32 <applicative> or what does "ghc-pkg check" say?  It seems it wants an mtl that has disappeared, perhaps by being overwritten, though other things need it.
20:38:38 <leavengood> it said the cache was out of date, so I fixed that
20:39:05 <leavengood> seems to be working after the cache fic
20:39:07 <leavengood> fix
20:39:31 <leavengood> thanks, that helped :)
20:39:39 <leavengood> hopefully I can finally get snap installed
20:39:55 * applicative never realized you got such excellent info from cabal -v
20:41:19 <xAndromeda> hamishmack, noep not working :(
20:41:35 <hamishmack> What error are you getting?
20:43:43 <xAndromeda> cairo-0.12.0 failed during the configure step. The exception was:
20:43:43 <xAndromeda> ExitFailure 1
20:43:43 <xAndromeda> gio-0.12.0 depends on glib-0.12.0 which failed to install.
20:43:43 <xAndromeda> glib-0.12.0 failed during the configure step. The exception was:
20:43:43 <xAndromeda> ExitFailure 1
20:43:43 <xAndromeda> gtk-0.12.0 depends on glib-0.12.0 which failed to install.
20:43:45 <xAndromeda> gtksourceview2-0.12.2 depends on glib-0.12.0 which failed to install.
20:43:47 <xAndromeda> leksah-0.10.0.4 depends on glib-0.12.0 which failed to install.
20:43:49 <xAndromeda> leksah-server-0.10.0.4 depends on glib-0.12.0 which failed to install.
20:43:53 <xAndromeda> ltk-0.10.0.4 depends on glib-0.12.0 which failed to install.
20:43:55 <xAndromeda> pango-0.12.0 depends on glib-0.12.0 which failed to install.
20:46:27 <applicative> Is right version of glib (the C library) present?
20:47:15 <applicative> the .cabal file says pkgconfig-depends: glib-2.0, gobject-2.0
20:48:40 <hamishmack> xAndromeda: What do you get if you run "sudo cabal install glib --global"?
20:51:40 <xAndromeda> Cannot find gtk2hsC2hs
20:51:40 <xAndromeda> Please install `gtk2hs-buildtools` first and check that the install directory is in your PATH (e.g. HOME/.cabal/bin).
20:51:40 <xAndromeda> cabal: Error: some packages failed to install:
20:51:40 <xAndromeda> glib-0.12.0 failed during the configure step. The exception was:
20:51:40 <xAndromeda> ExitFailure 1
20:53:12 <hamishmack> xAndromeda: Did you do this step from the blog "sudo cabal install gtk2hs-buildtools --global"?
20:54:25 <xAndromeda> hamishmack,  yes
20:55:16 <hamishmack> xAndromeda: What does "which gtk2hsC2hs" give you?
20:56:09 <xAndromeda> /usr/local/bin/gtk2hsC2hs
20:58:14 <hamishmack> xAndromeda: That is strange
20:58:46 <mauke> so I've got this idea for a parsing combinator library
20:59:02 <mauke> (Monoid e, Stream s c) => Parser s e a
20:59:03 <applicative> what is your plan, mauke
20:59:05 <hamishmack> xAndromeda: What about "sudo which gtk2hsC2hs"?
20:59:21 <mauke> s is a stream of characters, e is the error monoid, a is the result type
20:59:30 <applicative> and c?
20:59:36 <mauke> character type
20:59:39 <xAndromeda> hamishmack,  same thing... /usr/local/bin/gtk2hsC2hs
21:00:16 <mauke> instance Stream [a] a
21:00:33 <hamishmack> xAndromeda: pkg-config --modversion glib-2.0
21:00:59 <mauke> parse :: Parser s e a -> s -> Result s e a
21:01:14 <mauke> data Result s e a = Failure e s | Success [a]
21:01:57 <mauke> the idea is that parse failure gives you an error value e and the current stream position
21:02:20 <mauke> all parsers use mempty for failure by default
21:02:58 <mauke> but I want a combinator Parser s e a -> e -> Parser s e a that overrides the error value
21:03:15 <mauke> at first I wanted to call it <?>
21:03:57 <mauke> but I really want to be able to write whatever <?> "name of the parser", i.e. use it with strings
21:04:25 <mauke> and that's usage specific, i.e. you need a different <?> depending on what monoid you use
21:04:52 <xAndromeda> hamishmack, 2.28.6
21:05:01 <mauke> so ... what do I call my error annotation primitive?
21:06:43 <applicative> <@!&#!> "your parser failed"
21:06:50 <luite> hehe
21:08:12 <luite> there should be more appropriate unicode characters
21:08:22 <xAndromeda> hamishmack, i have to go for a few hours, thank your for the help :)
21:08:54 <mauke> it doesn't have to be an operator
21:09:01 <mauke> maybe 'annot'?
21:09:25 <hamishmack> xAndromeda: No worries. I am a bit baffled by this one.  It seems like it should work.
21:10:50 <applicative> ... `msg` "your parser failed"
21:12:59 <mauke> but it's not necessarily a message
21:13:09 <mauke> I'm naming the general monoidy thing here
21:13:36 <mauke> and it's probably going to be a Set in my next test
21:26:00 <mauke> Rank2Types, MultiParamTypeClasses, FunctionalDependencies, FlexibleInstances, UndecidableInstances, DeriveDataTypeable
21:26:11 <mauke> haskell is hard!
21:37:32 <Kaidelong> mauke, most of those didn't seem hard to me
21:38:13 <mauke> yeah, but I needed all of them just for a few parsing combinators
21:38:36 <napping> why all the typeclass stuff?
21:38:55 <Kaidelong> what did you need DeriveDataTypeable for?
21:39:19 <mauke> napping: class Stream s c | s -> c
21:39:43 <mauke> Kaidelong: data Result s e a = Failure e s | Success [a]  deriving (Eq, Ord, Read, Show, Data, Typeable)
21:40:45 <napping> UndecidableInstances sounds bad
21:40:52 <mauke> instance (Stream s c) => Stream (Counted s) c
21:41:03 <mauke> this is undecidable
21:41:06 <napping> RankNTypes, MultiParamTypeClasses, and FlexibleInstances should be standard
21:41:36 <dolio> Undecidable instances is almost as bad as undecidable programs.
21:42:13 <napping> for Haskell2011, maybe
21:42:15 <mauke> nah, it just means the compiler can't prove your types terminate
21:43:01 <napping> how is that undecidable?
21:43:17 <napping> it seems to pretty clearly be syntatically decreasing on c
21:43:21 <napping> s, rather
21:43:35 <mauke> (the Coverage Condition fails for one of the functional dependencies;
21:44:27 <napping> oh, you have a functional dependency as well
21:44:42 <mauke> s -> c
22:00:03 <napping> that case seems to fall under the modified condition http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies
22:00:19 <napping> so it's probably safe
22:00:57 <mauke> it's not exported, so I don't worry too much
22:01:33 <kmc> imo it's not worth worrying about whether your instances are "decidable"
22:02:26 <kmc> the worst outcome is a build failure
22:05:47 <Kaidelong> well as dolio said
22:06:09 <Kaidelong> they're almost as bad as undecidable programs
22:06:17 <Kaidelong> so yeah, not much to worry about
22:06:52 <Kaidelong> also as far as I know GHC's type checker just terminates with an error
22:07:10 <Kaidelong> if it takes too long
22:07:21 <Kaidelong> type inferrer?
22:07:23 <Kaidelong> type engine?
22:07:36 <dolio> Who said undecidable programs aren't much to worry about?
22:08:06 <Kaidelong> I suppose if you actually have one, it's a problem
22:08:11 <crystal-cola> me
22:10:57 <Kaidelong> in the "oh no, you can write undecidable programs in haskell" sense
22:11:34 <Kaidelong> it seems a bit odd to insist that type inference should always be decidable
22:11:59 <Kaidelong> or whatever you call it when something satisfies an instance
22:12:31 <dolio> Type inference being decidable means it works.
22:12:37 <napping> It's not at all clear how you could allow it to be undecidable, but guarantee that clients never get weird problems
22:12:50 <dolio> And you don't have to put in a bunch of annotations all over the place.
22:14:42 <napping> that's not quite the same problem
22:15:13 <napping> It can still be hard to tell where you need annotations, even if it's decidable to check whether you have enough to type the program
22:16:05 <ddarius> The difference is (assuming a reasonably sane type system) those places don't start to become arbitrary.
22:16:50 <dolio> Actually, type inference being decidable doesn't necessarily mean it works.
22:16:54 <dolio> It means it could possibly work.
22:18:15 <crystal-cola> but it's okay if type inference is undecidale
22:18:22 <crystal-cola> what you really need is type checking
22:18:25 <dolio> I don't believe that it's impossible to infer, for f : (A, A => B), the type of x in f(5, x => x), whereas it's possible for f(5)(x => x), the curried version.
22:18:32 <crystal-cola> inference is just a really nice thing
22:19:08 <dolio> Or that it's impossible regardless if you switch the order of the arguments.
22:19:28 <dolio> And yet, that's the state of affairs.
22:19:35 <Kaidelong> inference does not have to work all the time to be useful
22:20:11 <Kaidelong> although if you allow it not to terminate the compiler should probably have a hard limit build in for how long it will search before failing
22:20:47 <ddarius> Kaidelong: That leads to arbitrariness.
22:21:11 <napping> a time limit is especially bad
22:21:16 <napping> build fails if box is loaded
22:22:21 <kmc> fwiw GHC uses not a time limit but a bound on the size of the context-reduction stack
22:22:24 <kmc> which should at least be deterministic
22:22:45 <napping> dolio: what's that example?
22:23:29 <dolio> Oh, I guess I forgot to mention. It's Scala.
22:23:35 <napping> Ah.
22:23:49 <napping> :t let f (x,g) = g x in f (5, \x -> x)
22:23:49 <lambdabot> forall t. (Num t) => t
22:23:57 <dolio> Many functor and applicative functions are backwards in Scala, too.
22:24:05 <Kaidelong> doesn't have to be a time limit
22:24:09 <dolio> Because it can infer types if the arguments are in one direction, but not the other.
22:24:12 <Kaidelong> oh
22:24:16 <Kaidelong> I see kmc already mentioned
22:24:37 <ddarius> "To summarize the objections, classical Monte Carlo bases its estimate on irrelevant information and throws away relevant information."
22:25:12 <ddarius> kmc: It's deterministic, but it means my program works then you use it in your program and it stops working.
22:25:38 <napping> where is that quote from?
22:25:39 <kmc> yeah well, that's not exactly an uncommon outcome for software otherwise
22:25:54 <kmc> and the solution is very straightforward -- i increase the max stack size, as ghc suggests
22:26:18 <ddarius> kmc: Now code that into cabal-install.
22:26:26 <napping> dolio: I don't know of many partial type inference algorithms with a nice specification of what annotation are required/sufficient
22:26:32 <kmc> i really don't think this is a big deal
22:26:50 <napping> MLF is a great counterexample - it has a simple policy
22:27:41 <Eduard_Munteanu> Yeah, I too think undecidable typechecking might not be so bad.
22:27:54 <dolio> HMF and HML also have nice properties in that regard.
22:27:58 <napping> I think decidable programs might not be so bad
22:28:26 <ddarius> napping: "Bayesian Monte Carlo"
22:29:36 <napping> sounds interesting. Reminds me it's been a while since I played with MCMC
22:29:40 <Eduard_Munteanu> Termination checking is already pretty much undecidable in Agda in presence of codata, isn't it?
22:30:16 <crystal-cola> I don't think so
22:30:17 <dolio> No.
22:30:37 <crystal-cola> the "termination" check is actually just checking if it obviously terminates
22:30:44 <napping> codata shouldn't be any harder than data
22:31:01 <Eduard_Munteanu> Well recent Agda releases do have an option to increase term checker steps.
22:31:09 * Eduard_Munteanu idly wonders why would that be.
22:31:16 <napping> That's a different sort of thing entirely
22:31:37 <napping> It
22:31:51 <copumpkin> it lets it see things like f (suc (suc n)) = f (suc n) iirc
22:31:52 <napping> It's a question of how much information it tracks, not a "run for a few more steps" flag like GHC
22:32:00 <copumpkin> or through function definitions, maybe?
22:32:03 <copumpkin> I can't remember
22:32:22 <napping> well, I guess that's not entirely different from the depth allowed on the context stack
22:32:33 <Eduard_Munteanu> So does that mean that it might give false negatives, i.e. a program is marked as non-terminating when it actually is?
22:32:39 <copumpkin> oh definitely
22:32:40 <dolio> Agda has a set of decidable criteria for whether it accepts a program as terminating.
22:32:45 <copumpkin> you have to
22:32:51 <Eduard_Munteanu> Isn't this what undecidable means anyway? :)
22:32:56 <dolio> It is not a set of criteria that identifies all possible terminating programs.
22:33:43 <napping> Eduard_Munteanu: you could also have a test with no false negatives, which doesn't always terminate
22:34:09 <napping> tests which sometimes incorrect claim a program terminates are right out, of course
22:34:39 <Eduard_Munteanu> Or that but arguably a time limit will be set, and the only sensible interpretation is "it doesn't terminate".
22:37:16 <danharaj> Fucking physics. How do they work?
22:38:08 <crystal-cola> which one??
22:38:22 <Eduard_Munteanu> Actually I'm a bit at loss how exactly undecidability is defined.
22:38:52 <Eduard_Munteanu> Obviously the halting problem is decidable given infinite time.
22:39:02 <danharaj> A problem is undecidable if the halting problem is reducible to it.
22:39:31 <Eduard_Munteanu> Well, not a definition, that'd be an 'iff' construction.
22:39:45 <danharaj> there are problems stronger than the halting problem.
22:40:18 <crystal-cola> what would one be?
22:40:35 <danharaj> The halting machine for turing machines with an oracle that answers the halting problem for regular turing machines :p
22:40:39 <crystal-cola> :/
22:40:40 <crystal-cola> lol
22:40:40 <danharaj> halting problem*
22:41:04 <ddarius> copumpkin: The word was "neoteny" which isn't as interesting as I recalled.
22:41:12 <Eduard_Munteanu> I'm asking because in a sense even Haskell compiling is undecidable, given arbitrary program sizes and time limits.
22:41:22 <Eduard_Munteanu> (or C compiling, whatever)
22:41:25 <kmc> which sense is that?
22:41:43 <kmc> i don't think "time limits" enters into the usual definition of decidability
22:41:56 <danharaj> Compilation of a haskell98 program is decidable.
22:42:06 <danharaj> Although it can take enormous time on some very pathological inputs.
22:42:51 <Eduard_Munteanu> Oh, right...
22:42:54 <Eduard_Munteanu> "Given a description of a program and a finite input, decide whether the program finishes running or will run forever."
22:42:57 <Eduard_Munteanu> That was my oversite.
22:43:02 <Eduard_Munteanu> *oversight
22:43:09 <kmc> Eduard_Munteanu, a set L is decidable iff there exists a Turing machine which, for any input x, halts in finite time with a YES / NO answer corresponding to whether x is in L
22:43:54 <danharaj> Are there any undecidable sets that can't be used to solve the halting problem?
22:44:08 <danharaj> Or is the halting problem the easiest undecidable problem?
22:44:37 <crystal-cola> good question - that feels like something one should knw
22:44:46 <crystal-cola> I am sure the answer is yes but no clue how to prove it
22:45:31 <kmc> i'm pretty sure most undecidable sets are useless as an oracle
22:45:57 <kmc> every infinite bit-string corresponds to a subset of the natural numbers
22:46:05 <kmc> with probability 1 that subset is undecidable
22:47:12 <kmc> if i pick a random infinite bit-string, i've created an undecidable language, yet i've given you no information about turing machines
22:47:23 <kmc> really no independent information at all
22:47:30 <kmc> i'm not sure how to formalize this argument, though
22:47:46 <Eduard_Munteanu> So anyway, I think my question should be: setting Agda's term checker number of steps to infinity, does always halt?
22:48:19 <crystal-cola> it doesn't run the programs to see if they terminate or not
22:48:33 <kmc> if so, that would imply that the time limit is merely a convenience to the programmer, yes?
22:48:40 <kmc> because it would eventually halt anyway
22:48:46 <kmc> it seems odd to impose a time limit in such circumstances
22:49:00 <kmc> it's not like ghc says "it looks like your program is taking more than 30 sec to compile, i will kill it"
22:49:11 <kmc> ghc knows it will finish eventually
22:49:16 <danharaj> well
22:49:27 <kmc> (actually it doesn't always finish, even in H98 mode, because of known bugs)
22:49:30 <Eduard_Munteanu> Well, excepting some exponential algos or such
22:49:30 <danharaj> ghc knows it will finish eventually unless you tell it to do something extra :p
22:49:41 <danharaj> An exponential running time is still finite.
22:49:54 <kmc> don't mix together computability and time complexity
22:49:56 <Eduard_Munteanu> Though not for all practical purposes TM :)
22:50:49 <Eduard_Munteanu> So who cares if it finishes in O(1) with a constant equal to the universe's lifespan, I mean.
22:50:53 <kmc> if you're talking about real machines then it doesn't have to be exponential
22:50:54 <kmc> yeah
22:51:05 <kmc> i'm not sure what you're arguing then
22:51:16 <kmc> theoretical or practical?
22:51:21 <danharaj> The programs that make GHC choke are very artificial.
22:51:29 <danharaj> No one will ever write one accidentally :p
22:51:51 <Eduard_Munteanu> I'm arguing maybe the limit makes sense even if the termination algo is decidable.
22:52:10 <danharaj> maybe. I don't care either way.
22:52:11 <danharaj> kmc might?
22:52:13 <danharaj> I have green tea.
22:52:21 <kmc> an algorithm isn't "decidable" or "undecidable"
22:52:25 <Eduard_Munteanu> I'm making St John's wort tea!
22:52:51 <kmc> i don't get the point of a time limit at all, honestly
22:52:57 <kmc> if the compile is taking too long, the user will kill it
22:53:11 <danharaj> well it would be nice to have some diagnostics on why it's taking so long.
22:53:34 <kmc> danharaj, i think it's quite natural to want to encode naive set theory in Haskell
22:53:44 <kmc> and obviously you'd want to compile russell's paradox ;)
22:53:57 <kmc> and it's surprising that this causes an infinite loop in the inliner at compile time, rather than an infinite loop at runtime
22:54:43 <kmc> maybe a more convincing example would be a term that doesn't diverge at runtime but does make the inliner diverge
22:54:46 <kmc> i don't have such an example, however
22:55:12 <danharaj> I was thinking more of pathological type checking time.
22:55:16 <danharaj> But that works too.
22:55:45 <kmc> i'm talking about infinite loops, not exponential finite time
22:56:48 <Eduard_Munteanu> So hm, where would you have your infinite loops, runtime or compile time?
22:57:28 <Eduard_Munteanu> Type theory-oriented programmers would be inclined to say it's easier/better if problems arise at compile time. Would that extend to infinite loops?
22:57:30 <danharaj> Well with type families you can get infinite type check time :p
22:58:34 <kmc> the GHC bug i refer to can be triggered by H98 code
22:58:54 <danharaj> impressive
23:00:08 <napping> Eduard_Munteanu: the termination check would never finish if the limit was infinite
23:00:18 <kmc> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/bugs.html#bugs-ghc
23:01:27 <Eduard_Munteanu> In a sense it might be better to catch those at compile time if they're triggered by things such as race conditions.
23:02:55 <Eduard_Munteanu> I suppose 'not' isn't crucial there, is it?
23:04:11 <Eduard_Munteanu> > let data U = MkU (U -> Bool); russel u@(MkU p) = not $ p u; russel (MkU russel) :: Bool
23:04:12 <lambdabot>   <no location info>: parse error on input `data'
23:04:44 <Eduard_Munteanu> @let data U = MkU (U -> Bool)
23:04:44 <lambdabot>  Invalid declaration
23:04:49 <Eduard_Munteanu> Bah, nevermind.
23:06:12 <kmc> russell's un-paradox
23:06:19 <kmc> the set of all sets that contain themselves
23:07:03 <crystal-cola> that set is empty in normal set theory
23:07:10 <danharaj> oh god
23:07:10 <crystal-cola> you need something like quines non-well founded sets
23:07:16 <danharaj> haddock vomits all over my code
23:07:44 <danharaj> because it doesn't support associated types in instances o.O
23:07:48 <Eduard_Munteanu> You don't mean naive set theory, I suppose.
23:08:08 <danharaj> that 'set' is not a set in axiomatic set theory.
23:08:24 <kmc> yeah, i was talking about naive set theory
23:08:30 <kmc> the type U is the type of naive sets
23:08:39 <kmc> U for universe
23:09:15 <Eduard_Munteanu> Where U -> Bool stands for the membership / comprehension?
23:09:26 <kmc> yes
23:09:54 <kmc> a set is defined by its membership predicate, which is a function on sets
23:09:59 <kmc> hence the recursive type
23:11:00 <Eduard_Munteanu> I suppose a newtype does too.
23:11:07 <Eduard_Munteanu> (and still triggers the issue)
23:11:57 <kmc> guess so
23:40:53 <povman> @run fix (\f l -> if null l then [[]] else f (tail l) >>= \ending -> (head l) >>= \letter -> [letter:ending]) ["asdf", "ghjk"]
23:40:54 <lambdabot>   ["ag","sg","dg","fg","ah","sh","dh","fh","aj","sj","dj","fj","ak","sk","dk"...
23:41:21 <povman> Is there a less iffy way of writing that?
23:42:28 <Eduard_Munteanu> Sure, without fix :)
23:43:00 <povman> i mean without the if
23:43:01 <povman> :)
23:43:23 <povman> it seems something that shouldn't need the conditional
23:43:24 <Eduard_Munteanu> You can pattern-match on the input list.
23:43:41 <Eduard_Munteanu> and you have a special case for l = []
23:43:53 <danharaj> > [ [x,y] |  y <- "ghjk", x <- "asdf"]
23:43:54 <lambdabot>   ["ag","sg","dg","fg","ah","sh","dh","fh","aj","sj","dj","fj","ak","sk","dk"...
23:44:18 <Eduard_Munteanu> Heh, or that, I didn't look through what it was actually doing :)
23:44:32 <povman> > fix (\f l -> if null l then [[]] else f (tail l) >>= \ending -> (head l) >>= \letter -> [letter:ending]) ["asdf", "ghjk", "ffjhjhjf", "foo"]
23:44:33 <lambdabot>   ["agff","sgff","dgff","fgff","ahff","shff","dhff","fhff","ajff","sjff","djf...
23:44:41 <povman> danharaj: unfortunately :)
23:45:15 <Necrosporus> Does haskell support lambda P omega calculus?
23:46:09 <ion> > (\a b -> [b,a]) <$> "ghjk" <*> "asdf"
23:46:10 <lambdabot>   ["ag","sg","dg","fg","ah","sh","dh","fh","aj","sj","dj","fj","ak","sk","dk"...
23:46:13 <Axman6> if you can program it it supports it
23:46:34 <ion> > flip (,) <$> "ghjk" <*> "asdf"
23:46:36 <lambdabot>   [('a','g'),('s','g'),('d','g'),('f','g'),('a','h'),('s','h'),('d','h'),('f'...
23:47:11 <danharaj> hmmmmmm
23:47:14 <danharaj> It's 3 AM
23:47:19 <fosskers> > maximum [1..]
23:47:27 <lambdabot>   *Exception: mueval-core: signal: 15
23:47:29 <Eduard_Munteanu> @pl \t -> fix (\f l -> if null l then [[]] else f (tail l) >>= \ending -> (head l) >>= \letter -> [letter:ending]) t
23:47:34 <lambdabot> fix (ap (flip if' [[]] . null) . (`ap` ((. flip (flip . ((:) .) . flip (:)) []) . (>>=) . head)) . ((>>=) .) . (. tail))
23:47:45 <Eduard_Munteanu> OMG.
23:48:05 <ian_mi> ahhh
23:49:07 <povman> Eduard_Munteanu: unfortunately @pl doesn't deal well with if
23:49:51 <ciphergoth> Very new to Haskell here - I'm looking for a module with string handling functions like "startswith", but I'm obviously looking in the wrong place, can anyone direct me?
23:50:13 <Eduard_Munteanu> @hoogle isPrefixOf
23:50:13 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
23:50:13 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
23:50:13 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
23:50:15 <ciphergoth> or would "startswith" be over all Lists of Eq-able strings
23:50:17 <ciphergoth> aha
23:50:34 <Eduard_Munteanu> @hoogle stripPrefix
23:50:34 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
23:50:34 <danharaj> Data.List is a good place to start for such things.
23:50:51 <ciphergoth> Eduard_Munteanu: thank you! What would have been the right way for me to find that for myself do you think?
23:51:30 <Eduard_Munteanu> Erm, besides asking, maybe looking around in List-related modules, since strings are lists.
23:52:06 <danharaj> also hoogle
23:52:08 <ciphergoth> thanks. oh I like that "stripPrefix" returns a Maybe [a] - means I can just try to strip each prefix in turn 'till I get the one I need
23:52:09 <danharaj> hoogle is your friend
23:52:31 <Eduard_Munteanu> Yeah you can also do stuff like...
23:52:37 <Eduard_Munteanu> @hoogle [a] -> [a] -> Maybe [a]
23:52:38 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
23:52:38 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
23:52:38 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
23:53:20 <povman> ciphergoth: try (filter (isPrefixOf [1,2,3,4]) [[2,3],[1,2], [1]])
23:53:23 <povman> >(filter (isPrefixOf [1,2,3,4]) [[2,3],[1,2], [1]])
23:53:23 <Eduard_Munteanu> So if you know / guess the types involved, hoogle can help.
23:53:31 <povman> > (filter (isPrefixOf [1,2,3,4]) [[2,3],[1,2], [1]])
23:53:32 <lambdabot>   []
23:53:36 <povman> hm
23:53:43 <povman> oh
23:53:52 <povman> > (filter (`isPrefixOf` [1,2,3,4]) [[2,3],[1,2], [1]])
23:53:53 <lambdabot>   <no location info>: lexical error at character '\GS'
23:54:13 <povman> more like failbot
23:54:31 <ciphergoth> what modules does lambdabot import?
23:54:53 <Eduard_Munteanu> > (filter (`isPrefixOf` [1,2,3,4]) [[2,3],[1,2], [1]])
23:54:54 <shachaf> The good ones.
23:54:54 <lambdabot>   [[1,2],[1]]
23:55:06 <povman> Eduard_Munteanu: it hates me
23:55:18 <Eduard_Munteanu> It reads   (filter (`isPref]]]ixOf` [1,2,3,4]) [[2,3],[1,2], [1]])   here
23:55:24 <povman> oh.
23:55:31 <shachaf> Eduard_Munteanu: Those aren't ]s, they're s.
23:55:37 <danharaj> some irc clients have pretend invisible characters
23:55:42 <Eduard_Munteanu> Heh.
23:55:43 <danharaj> I didn't see those, for example
23:56:12 <Eduard_Munteanu> I see them, but ] highlighted with white background.
23:56:17 <ciphergoth> What are the backticks doing there? Thought they were for infixing but that's not happening here
23:56:31 <Eduard_Munteanu> ciphergoth: it is
23:56:39 <ciphergoth> but they seem to be reversing the order of arguments for isPrefixOf
23:56:41 <Eduard_Munteanu> But it's partial application with infix.
23:57:04 <Eduard_Munteanu> Yeah, in this case, it is doing that.
23:57:16 <Eduard_Munteanu> Like flip filter $ [1,2,3,4]
23:57:54 <ciphergoth> right. OK I'm totally not seeing why backticks work like flip here
23:58:15 <danharaj> it's acting as a section
23:58:19 <danharaj> like (+5)
23:58:31 <Eduard_Munteanu> vs 5+
23:58:38 <ciphergoth> ah!
23:58:46 <danharaj> well vs (+) 5
23:59:03 <shachaf> @pl (+5)
23:59:03 <lambdabot> (5 +)
23:59:09 <ciphergoth> just tried an experiment with (-) to see if that was it, but of course that character is special cased for unary -
23:59:16 <danharaj> yes
23:59:24 <danharaj> one of those nitpicky things that are kinda sorta gross
23:59:31 <danharaj> but also kinda sorta convenient
23:59:34 <ciphergoth> sure
23:59:35 <shachaf> s/kinda sorta //
23:59:45 <danharaj> and mostly sorta who cares
23:59:57 <ciphergoth> but (5/) 2 and (/2) 5 both do what I'd expect, so I get it now. Thanks1
