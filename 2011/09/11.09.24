00:01:55 <mysticc> any body using yi here
00:19:30 <cwl> @type State
00:19:31 <lambdabot> Not in scope: data constructor `State'
00:19:35 <cwl> @info State
00:19:35 <lambdabot> State
00:19:46 <cwl> @src State
00:19:46 <lambdabot> Source not found. Sorry.
00:21:46 <cheater> is it good practice to call haskell scripts that get executed with runhaskell myscript.hs ? is .hs the right extension here?
00:23:06 <kmc> yeah
00:23:19 <cheater> ok
00:23:31 <cheater> i am surprised, runhaskell is a script
00:23:41 <cheater> well a link to a script
00:23:53 <kmc> you can even start the file with "#!/usr/bin/env runhaskell"
00:24:02 <kmc> dunno if that's valid Haskell but GHC accepts it anyway
00:24:04 <cheater> i know
00:24:21 <cheater> normally the interpreter named in a shebang cannot be a shebang file itself
00:24:35 <cheater> at least that's the spec i've read
00:24:44 <kmc> interesting
00:24:45 <mauke> yeah, that's why #!/proc/self/exe doesn't work
00:24:56 <kmc> my runhaskell is a #!/bin/sh file
00:25:01 <cheater> or is it
00:25:06 <kmc> actually, two of them??
00:25:09 <kmc> it has two lines like that
00:25:09 <cheater> try ls -la $(which runhaskell)
00:25:27 <kmc> lrwxrwxrwx 1 root root 28 Sep  3 13:23 /usr/bin/runhaskell -> /etc/alternatives/runhaskell
00:25:28 <cheater> it's probably a link to runghc
00:25:32 <cheater> see
00:25:34 <kmc> "lol debian"
00:25:36 <cheater> and follow that up
00:25:40 <cheater> that goes to runghc i bet
00:25:44 <kmc> yeah
00:26:11 <cheater> so i am assuming the link is what allows it to execute
00:26:19 <kmc> odd
00:26:27 <kmc> sounds like hax
00:27:02 <mauke> seems unlikely
00:27:05 <cheater> no it's not
00:27:15 <cheater> because doing #!/usr/local/bin/runghc works
00:36:46 <FredOverflow> @pl \a b -> a ++ x:b
00:36:46 <lambdabot> (. (x :)) . (++)
00:37:02 <FredOverflow> @pl \b a -> a ++ x:b
00:37:02 <lambdabot> flip (++) . (x :)
00:58:43 <cheater> what is the right parlance for haskell "variables"? identifiers?
00:59:15 <cheater> (since nothing is variable in haskell, can only be masked)
00:59:52 <kmc> they're variables
00:59:54 <kmc> as in maths
00:59:57 <kmc> variables are names for values
01:00:06 <cheater> ok
01:00:06 <kmc> in other programming languages, variables are names for mutable cells which hold values
01:01:56 <Bishoy> hey there i'm new to haskell, but can anybody tell me well haskell make me able to develop a chatterbot... or even a complete virtual world?
01:02:26 <flinstone> hi all
01:02:28 <dankna> no.  if you're able to do that, you're able to do it with or without Haskell; it won't magically make you a better programmer.
01:02:49 <cheater> @protontorpedo
01:02:49 <lambdabot> paul graham said static typing is a problem for macros building
01:02:54 <cheater> @protontorpedo
01:02:55 <lambdabot> smalltalk is oo
01:03:37 <flinstone> Anybody here used monodrioid?
01:03:53 <kmc> @faq well haskell make me able to develop a chatterbot... or even a complete virtual world?
01:03:53 <lambdabot> The answer is: Yes! Haskell can do that.
01:04:49 <Bishoy> thanks lambdabot thats wht is was asking about
01:05:37 <Bishoy> but is it fast enough as i don't like to write a million line of code to do that?
01:06:48 <Ptival> well, it would probably take less lines than most imperative languages, but if you know nothing you'll first have to go through the learning phase and the trial&error phase :)
01:08:24 <Bishoy> :)
01:09:54 <Bishoy> well thx guys for the cooperation
01:13:32 <cheater> ok, so
01:14:07 <cheater> labels in my scope (i.e. the fact "foo" is defined) come either from let/case or from an argument named foo, yes?
01:14:47 <mauke> or global definitions
01:15:07 <cheater> how do you make global definitions?
01:15:11 <mauke> foo = 42
01:15:17 <cheater> i tried that and got an error
01:15:17 <mauke> main = putStrLn "hello world"
01:15:19 <cheater> i think
01:15:29 <cheater> how do you know what the content of my blog post is
01:15:46 <mauke> magic, ladies and gentlemen
01:15:51 <cheater> ▸       main = putStrLn "Hello, World!"
01:16:30 <cheater> ok right, it works.
01:16:38 <cheater> i just had a type error.
01:17:22 <cheater> are there any other things like let/case?
01:17:28 <mauke> 'where'
01:17:34 <cheater> right, i know that one
01:17:36 <cheater> is that it?
01:17:58 * mauke ponders
01:18:07 <mauke> \ introduces bindings
01:18:14 <mauke> so does <- because it's sugar for \
01:18:19 <cheater> dunno anything about that
01:18:32 <cheater> how does this work?
01:18:49 <mauke> > (\x -> x + 3) 2
01:18:50 <lambdabot>   5
01:19:29 <mauke> > (do { x <- ask; return (x + 3) }) 2
01:19:30 <lambdabot>   5
01:19:51 <cheater> oh \ as in lambda
01:19:56 <cheater> but that's still an argument right?
01:20:01 <cheater> basically
01:20:20 <etpace> :ty (do { x <- ask; return (x + 3) })
01:20:20 <mauke> yes
01:20:23 <cheater> is there a basic difference between bindings and arguments to functions?
01:20:26 <mauke> etpace: :t
01:20:30 <etpace> :t (do { x <- ask; return (x + 3) })
01:20:32 <lambdabot> forall (m :: * -> *) r. (MonadReader r m, Num r) => m r
01:20:45 <mauke> cheater: let bindings can be polymorphic
01:20:53 <etpace> function application is an instance of monad reader?
01:21:03 <mauke> etpace: (e ->) is
01:21:44 <etpace> cool
01:22:17 <mauke> > let f x = x + 1 in  (f (length "x"), f (sqrt 2))
01:22:17 <lambdabot>   (2,2.414213562373095)
01:22:38 <mauke> > (\f -> (f (length "x"), f (sqrt 2))) (\x -> x + 1)
01:22:39 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
01:22:39 <lambdabot>    arising from a use of...
01:30:11 <cheater> ok so
01:30:54 <cheater> inside my main I want to read an int, compare it to another (globally defined) one, and print "less" or "more" or "equal". how do I do this?
01:31:37 <elliott_> you might to read a tutorial.
01:32:39 <cheater> nobody asked you specifically a question, if you want to troll me here i will ask the channel operators to remove you. this is not the first time i have asked you to stop bothering me.
01:32:58 <mauke> main = readLn >>= \n -> putStrLn (case compare n foo of LT -> "less"; EQ -> "equal"; GT -> "greater")
01:33:04 <cheater> mauke: cool
01:33:05 <elliott_> sorry, I won't try answering your questions
01:33:13 <mauke> cheater: stop being an asshole
01:33:30 <cheater> mauke: if only you knew
01:33:32 <kmc> #HASKELL MOST FRIENDLIEST CHANNEL IN ALL OF FREENODE
01:33:48 <DevHC> LIES
01:34:06 <elliott_> It's OK, cheater is well-known to start acting a bit oddly whenever I jump in. I shouldn't have said anything.
01:34:08 <elliott_> I'll go back to my code.
01:34:40 <cheater> there's a difference between "acting oddly" and "culling your attempt at trolling me again"
01:34:51 <mauke> cheater: the suggestion was valid
01:34:54 * zeiris munches on popcorn.
01:34:56 <cheater> it was useless
01:34:57 <elliott_> mauke: sorry about this.
01:35:00 <cheater> i know i can read a tutorial
01:35:05 <mauke> cheater: but?
01:35:06 <cheater> it was obviously never meant to help me
01:35:07 <ivanm> zeiris: got any more?
01:35:10 <Phantom_Hoover> "But it's too much effort to!"
01:35:13 <dalaing_> I saw no trolling there
01:35:36 <mauke> cheater: disagree
01:35:38 <zeiris> Sorry ivanm, this could be a long one. I've got to hoard!
01:35:40 <cheater> dalaing_: elliott has been trolling me for, oh i think you can describe it as years now
01:35:46 <ivanm> zeiris: awwwww
01:35:59 <dalaing_> it read like an attempt to help to me
01:36:49 <cheater> dalaing_: someone who calls you an idiot and other, less pleasant swearwords, constantly, for years, suddenly wants to help you? in the least helpful way possible? i think not.
01:37:15 <mauke> cheater: what you think is irrelevant; what matters is what I see
01:37:32 <elliott_> oh my god stop playing the victim, this is ridiculous. I'll never direct a single message at you again since it causes this ridiculousness, just stop making a fool of yourself.
01:37:59 <cheater> if that promise were only true
01:38:08 <zeiris> I'm curious what #haskell-class trolling consists of. Do you need to write a paper ridiculing the victim's research? Or disprove/find a major bug in their code, and post it publically on the mailing list?
01:38:20 <dalaing_> cheater: the advice you got seemed like it was probably the most helpful possible
01:38:38 <cheater> dalaing_: no, it was not helpful at all, everyone knows they can read tutorials
01:38:41 <etpace> soap opera
01:38:53 <cheater> i came here to ask because i wanted to speak with someone directly, not read a tutorial.
01:38:58 <zeiris> I've got a question: I think I figured out enough about monads, and applicative functors, to do all kinds of useful awesome stuff with. What's "next"?
01:39:03 <dalaing_> cheater: in that most moderate length tutorials would answer your specific question and the whole class of questions at that scale / scope
01:39:08 <DevHC> cheater: u should ask how to code ignore functionality in haskell :}
01:39:28 <mauke> cheater: your sense of entitlement is annoying
01:39:30 <zeiris> I tried looking at arrows and FRP before, but it turned out to be a bit of a dead end. Should I learn iteratees? What other major "techniques" are there?
01:39:37 <dalaing_> zeiris: you're where I was a week or two ago :)
01:39:45 <cheater> mauke: i never said i am entitled to anything.
01:39:51 <mauke> cheater: you act like it
01:40:24 <cheater> mauke: and what did i act out being entitle to?
01:40:28 <cheater> *entitled
01:40:40 <zeiris> My Haskell-fu graph had gigantic jumps at the points where I learned to write custom monads, and use applicative functors. I'm looking for other such tricks.
01:40:55 <dalaing_> zeiris: although that means I probably can't give huge amounts of advice, although I can dump the list of stuff I'm coming up to speed with or are on my list of stuff to check out
01:40:57 <mauke> cheater: I can't parse that question
01:41:17 <cheater> mauke: you say i display an act of entitlement; entitlement to what?
01:41:27 <mauke> cheater: personal handholding/tutoring
01:41:44 <zeiris> dalaing_: the best idea I've got now is playing more with GADTs and writing fancier interpreters/simple compilers with them. Or trying to dive into iteratees/the recent influx of web frameworks.
01:42:37 <cheater> i never said i was entitled to that. had anyone else said what elliott said, i would have asked for a direct answer. asking precludes entitlement. hwoever, since elliott has a history of extreme negativity towards me, the answer was what it was.
01:42:50 <dalaing_> zeiris: nice - I'm currently writing a mildly complicated IRC bot, will follow up with a rogue like - just doing general stuff so I can try to get my practical fu to catch up with my theoretical half fu
01:43:16 <mauke> cheater: and in what case would you have read a tutorial?
01:44:30 <dalaing_> zeiris: I played with monad transformers last week, and added lenses into the mix (which was pretty nice, but perhaps not a "big" context when you look at how I'm using it), going to play with zippers when I get onto the roguelike, will try to find an excuse to use comonads
01:44:34 <cheater> if no one agreed to do this i would have gone out and found some stuff, however i cannot browse www that easily, so it would have taken a considerable amount of time. the wait here would have to be nearly as long as the wait i have to do when loading several pages.
01:44:41 <ivanm> dammit, I want to rollback a patch in darcs but I can't work out which other patches depend upon it :s
01:44:56 <kmc> zeiris, there's a lot of directions you can take... GADTs, type families, fancy type classes, generics (SYB, Multiplate, etc.), Template Haskell / quasiquotes
01:45:20 * dalaing_ takes notes
01:45:28 <zeiris> comonads disappointed me when I tried to find a useful/interesting instance. Asides from that one post by sigfpe about 1D cellular automata, which I haven't seen generalized to more dimensions.
01:45:29 <kmc> zeiris, what about concurrent programming and STM? have you done a lot of that?
01:45:33 <cheater> going back to your question of entitlement, if there's any entitlement to be had, i hope i am entitled to be able to protect myself from people who are, in my and other people's eyes, out to bring me down.
01:45:52 <cheater> i think that's enough said about that, i don't want to give this any more attention than no attention at all which it deserves
01:46:07 <mauke> http://learnyouahaskell.com/chapters
01:46:08 <zeiris> kmc: not at all, but that's the kind of problem I'd probably use Erlang for anyway.
01:46:23 <kmc> okay
01:46:29 <kmc> well i think it's worth learning how it works in Haskell too
01:46:30 <zeiris> Generics and type families sound interesting though.
01:46:46 <cheater> mauke: i tried downloading those, my firefox transfer window says the download speed is "-47 bps"
01:46:47 <kmc> if you're not doing distributed systems or high reliability with live patching, Haskell may well beat Erlang on other factors
01:47:00 <zeiris> What are "fancy classes"?
01:47:01 <mauke> cheater: what kind of internet connection are you on?
01:47:14 <kmc> zeiris, STM is fabulous; if you haven't used it in another language (like Clojure?) you should really learn how it works in Haskell
01:47:20 <cheater> mauke: it does 8 KB/s in high wind
01:47:35 <cheater> (this is right now)
01:47:42 <mauke> oh wow
01:47:43 <zeiris> Any traditional toy problems STM is good for solving?
01:47:44 <kmc> good concurrent imperative programming is one of my favorite Haskell features
01:47:57 <kmc> (GHC Haskell, anyway)
01:48:01 <kmc> zeiris, just check out the last chapter of RWH
01:49:19 <zeiris> Excellent.
01:49:57 <kmc> zeiris, then there's all the "pure parallelism" stuff
01:50:12 <kmc> parallel computation on many cores without messing around with threads
01:50:25 <zeiris> Like the parallelism combinator stuff? Or was it evaluation strategies?
01:50:31 <kmc> yeah, that stuff
01:50:45 <zeiris> Man, I really need some kind of project to apply all this stuff to.
01:50:56 <elliott_> Evalastratigombinator.
01:50:59 <zeiris> Are there any Haskell libraries for working with Android phones?
01:51:07 <ivanm> zeiris: no
01:51:14 <ivanm> but there is work on porting GHC to arm
01:51:25 <mauke> cheater: the first four chapters are 115 kb (html only), so downloading them should take between 15s and a few minutes
01:51:31 <kmc> i already hackishly ported GHC 6.12 to work as a cross compiler to ARM Android
01:51:34 <kmc> iPwn is sitting on the code
01:51:36 <mauke> (doesn't seem that bad)
01:51:39 <cheater> mauke: yeah, i'm doing that
01:51:51 <mauke> but still, can't you get a better connection?
01:52:09 <cheater> still, i gave lyah a try a few times and still i couldn't immediately figure out how to do the reading etc
01:52:14 <mauke> heck, seems like carrier pigeons + flash drives would be faster
01:52:15 <cheater> mauke: no
01:52:21 <cheater> yes, they would.
01:52:53 <cheater> until i can get something better assume i am stranded in alpha centauri, you are my only lifeline, there is no world for me other than irc
01:52:56 <zeiris> I had a crazy (time investment wise) idea once of writing an Erlang+Haskell multiplayer game. Erlang handling server-side connections and distribution of work, Haskell running the client + running world simulations server-side. With each Erlang node running a couple of Haskell world nodes.
01:53:05 <zeiris> Doing that for a simple game could be fun.
01:53:17 <kmc> yes
01:53:18 <cheater> i would like to build a house with a red hamme
01:53:20 <cheater> r
01:53:24 <cheater> it must be better than green hammers
01:53:52 <saati> can i make something declared with type an instance of a typeclass?
01:54:07 <kmc> saati, no, "type" just creates a synonym
01:54:18 <kmc> you can use the synonym in instance declarations with a particular GHC extension
01:54:26 <kmc> but you're not creating an instance for the synonym, but for whatever it expands to
01:54:31 <kmc> zeiris, i'd put concurrency and parallelism at the top of the list of what to learn next to increase your haskell fu
01:54:50 <kmc> even if you're very happy with how Erlang handles these, I think it's worth learning the quite different way Haskell handles them
01:55:21 <kmc> then i'd look at generics... probably at least SYB and Uniplate / Multiplate
01:55:34 <kmc> very satisfying to collapse 20 lines of code to 1
01:55:42 <kmc> (also there's new generics support baked into GHC 7.2)
01:56:09 <zeiris> So, concurrency: STM + parallelism strategies or whatever that library was called.
01:56:21 <zeiris> And generics... Template Haskell = Lisp-ish macros?
01:56:28 <kmc> parallelism isn't concurrency, it's... parallelism
01:56:47 <kmc> and there's more to concurrency than STM
01:57:06 <zeiris> Is the distinction between concurrency and parallelism just operational? One actually runs in parallel, the other just -might- do so?
01:57:16 <kmc> the actual thread creation isn't part of STM, and there are ways for threads to interact and communicate other than STM
01:57:30 <saati> okay thanks
01:57:37 <elliott_> zeiris: http://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/ http://www.haskell.org/haskellwiki/Parallelism_vs._Concurrency
01:57:37 <kmc> zeiris, my take on it is http://haskell.org/haskellwiki/FAQ#What.27s_the_difference_between_concurrency_and_parallelism.3F
01:57:39 <elliott_> you might find these helpful
01:57:42 <elliott_> or that :)
01:58:14 <kmc> zeiris, the important thing is that parallel evaluation in GHC Haskell does not require concurrent semantics
01:58:22 <kmc> it does not require changing the semantics of your code at all
01:58:27 <kmc> (par x y) is semantically equivalent to y
01:59:25 <cheater> is there something like readLn which interprets every input as a string?
01:59:34 <mauke> cheater: getLine
01:59:45 <mauke> and it's the other way around; readLn is built on top of getLine
01:59:55 <cheater> yeah i am guessing it is
02:00:01 <kmc> @src readLn
02:00:02 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
02:00:13 <elliott_> Gross "x <- y; return x" there.
02:00:19 <kmc> yeah
02:00:22 <elliott_> Gross do notation in general there, really
02:00:22 <kmc> :t getLine >>= readIO
02:00:24 <lambdabot> forall b. (Read b) => IO b
02:00:55 <kmc> whoever added it to @src may have decided this was easier for beginners to read
02:00:56 <kmc> *shrug*
02:01:30 <zeiris> kmc: which specific kind of semantics? (par x y) does end up behaving differently, probably executing faster or slower depending on cache accesses and whatnot.
02:01:37 <cheater> kmc: yeah it's a bit more like C and stuff.
02:01:53 <ion> I’m sure said beginners could just ask and get help here if @src readLn used >>=, perhaps gaining even more insight.
02:02:39 <kmc> zeiris, replacing (par x y) with y won't cause a function to return a different value
02:02:41 <elliott_> ion: That insight might be more than they can handle if they can't even read lines in a simple IO program yet :-)
02:02:42 <cheater> @src >>=
02:02:42 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:02:49 <cheater> @src (>>=)
02:02:49 <lambdabot> Source not found. Are you on drugs?
02:02:52 <elliott_> But it should definitely at least be "do l <- getLine; readIO l".
02:02:52 <mauke> cheater: it's a method
02:03:00 <cheater> what is a method?
02:03:01 <mauke> cheater: the implementation depends on the type
02:03:31 <mauke> cheater: hmm, you should probably learn about typeclasses first
02:03:35 <cheater> can >>= be "desugared" in some way?
02:03:39 <kmc> zeiris, the semantics i mean are the semantics of Haskell terms evaluating to (weak head) normal form
02:03:39 <cheater> i know typeclasses
02:03:46 <elliott_> a typeclass is composed of a signature, and methods; they offer overloading.
02:03:46 <mauke> cheater: but for the purposes of getting started we can just assume you want IO's >>=
02:03:49 <elliott_> (>>=) is a method of Monad.
02:03:49 <cheater> eg Show, Num, etc
02:04:05 <mauke> cheater: show is a method in Show, (+) is a method in Num, etc
02:04:05 <cheater> mauke: i do
02:04:06 <zeiris> kmc: so Haskell semantics ignore parallelism, and do not change if parallelism is introduced. They are not concurrent, whereas something like the actor model is concurrent and adds a ton of details about message ordering and delivery.
02:04:24 <mauke> cheater: then (>>=) is "primitive"
02:04:31 <kmc> zeiris, right
02:04:39 <cheater> ok. what does IO's >>= do?
02:04:46 <kmc> the semantics of evaluation of Haskell function application and pattern matching are not concurrent
02:04:57 <kmc> the semantics of execution of Haskell IO actions *are* concurrent
02:04:59 <elliott_> returns a program whose action is to: {run the program on the left, and feed its result to the function on the right}
02:05:01 <mauke> cheater: 'm >>= f' takes an action m and a callback f, and returns a new action
02:05:15 <kmc> cheater, did you read http://www.haskell.org/haskellwiki/Introduction_to_IO ?
02:05:22 <cheater> no, let me wget that
02:05:26 <mauke> cheater: that new action will (when executed) run m, then call f on the result of m, then execute the result of f
02:05:39 <cheater> mauke: ah, so the thing on the right is a callback. ok.
02:05:41 <mauke> cheater: also, http://mauke.dyndns.org/stuff/haskell/how-to-io.html
02:05:57 <elliott_> callback is slightly inaccurate, since it's typical imperative sequencing, in general.
02:06:00 <elliott_> there's no threading or anything involved.
02:06:02 <kmc> zeiris, forcing (par x y) will always produce the same result as forcing y... but it might produce that result faster or slower
02:06:02 <zeiris> Switching gears a bit: generics, does the syb package involve Template Haskell/Lisp-like macros?
02:06:13 <kmc> zeiris, no, these are separate concepts
02:06:19 <zeiris> Sweet.
02:06:27 <kmc> for SYB i would just read the SYB papers
02:06:28 <kmc> at least the first one
02:06:34 <kmc> and then poke around the haddock docs
02:06:39 <etpace> :t readIO
02:06:40 <lambdabot> forall a. (Read a) => String -> IO a
02:06:42 <mauke> SYB is just normal typeclasses (and maybe higher rank types), no?
02:06:50 <kmc> and unsafeCoerce under the hood
02:07:06 <mauke> well, Typeable, yeah
02:07:17 <Saizan> and lots of boilerplate
02:07:19 <kmc> zeiris, to use SYB you implement two type classes (Typeable, Data) for your data type, and now you can use various generic traversal / query / modification operations
02:07:25 <elliott_> Saizan: no, that's scrapped :)
02:07:31 <zeiris> Those can be auto-derived, right?
02:07:32 <kmc> the details of writing a Typeable or Data instance are ugly, but GHC can derive them automatically
02:07:34 <kmc> yes
02:07:45 <zeiris> Well, if you're using GHC. <3 GHC
02:07:47 <mauke> (they're actually not that ugly)
02:07:51 <zeiris> I really really like GHC view patterns.
02:07:57 <mauke> depends on how complicated your type is
02:07:58 <kmc> writing your own Typeable instance is unsafe
02:08:00 <zeiris> So much so I'm going to try to steal it in (Lisp Flavored) Erlang.
02:08:13 <elliott_> yeah Data instances aren't that bad
02:08:18 <elliott_> it's mostly just a fold plus some boilerplate
02:09:34 <kmc> SYB is kind of complicated and overwrought
02:09:42 <kmc> but it's useful
02:09:54 <kmc> Typeable is also useful on its own, as is Data.Dynamic
02:10:07 <elliott_> Does syb have advantages over unplate? Just curious if it's hysterical raisins or something more.
02:10:10 <elliott_> uniplate
02:10:15 <elliott_> I've only used SYB.
02:10:18 <mauke> yes, uniplate is much more limited
02:10:26 <elliott_> ah
02:10:35 <mauke> (also faster)
02:10:46 <elliott_> :)
02:20:58 <cheater> to perform two actions after another i use >>, right?
02:21:28 <dalaing_> cheater: yes
02:21:36 <cheater> perfect
02:21:39 <cheater> thank you!
02:23:12 <cheater> can i call the action in IO a program?
02:23:19 <cheater> ie what is on the left of >>=?
02:23:24 <elliott_> Yes.
02:23:59 <mauke> do people actually do that?
02:24:17 <ceii> I do but it's not conventional
02:25:01 <elliott_> mauke: Well, "main" is a program, no?
02:25:14 <elliott_> I think "program" is mostly a useful way to explain IO actions to beginners. It's a pretty intuitive model.
02:25:18 <elliott_> And IO is modelling an imperative program after all.
02:25:19 <cheater> ceii: hmm
02:25:21 <elliott_> "action" is nicer though.
02:25:33 <mauke> to me a "program" is an entire executable
02:25:56 <cheater> mauke: who said that getLine >>=
02:26:02 <cheater> mauke: who said that getLine >>= putStrLn is not a program?
02:26:03 <elliott_> mauke: so a python script without +x isn't a program? :P
02:26:19 <cheater> mauke: also, a single executable can contain multiple programs
02:26:19 <ceii> mauke: I see IO actions as programs in an embedded imperative DSL
02:26:31 <mauke> yeah, it gets fuzzy at the edges
02:26:46 <cheater> mauke: and each program can contain sub-programs which are programs in their own right
02:27:19 <cheater> so why doesn't main = getLine >> return putStrLn      print at all?
02:27:34 <mauke> cheater: why would it?
02:27:45 <mauke> you've got two actions, 'getLine' and 'return putStrLn'
02:27:54 <cheater> i don't know, i thought >>= was like >> return
02:28:00 <mauke> the effect of 'getLine' is to read a line, the effect of 'return putStrLn' is nothing
02:28:01 <elliott_> no, a >> b is like a >>= const b
02:28:08 <elliott_> const b is \_ -> b
02:28:16 <cheater> mauke: can you express >>= in terms of >>?
02:28:17 <elliott_> (a >> return b) just does a, then returns b, discarding a's result
02:28:22 <mauke> cheater: no, the other way around
02:28:25 <elliott_> so (>>=) is strictly more powerful than (>>)
02:28:29 <cheater> mauke: hm
02:28:52 <kmc> cheater, you've accidentally written a main of type IO (String -> IO ())
02:28:59 <mauke> cheater: >>= lets you provide a function to be called when action 1 is done. this function can then dynamically construct action 2
02:29:01 <kmc> if you put a type signature "main :: IO ()" it will catch this
02:29:06 <mauke> cheater: >> takes two "static" actions
02:29:07 <kmc> :t return putStrLn
02:29:08 <lambdabot> forall (m :: * -> *). (Monad m) => m (String -> IO ())
02:29:09 <cheater> kmc: mhm
02:31:05 <elliott_> lot of klines this hour
02:33:21 <Taejo> hello #haskell. I want to write a bot for a game. The game uses http (with cookies) -- but all the responses and requests are pretty small so there shouldn't be any need for iteratees etc. What library should I use?
02:34:33 <ivanm> Taejo: network? *shrug*
02:34:52 <ivanm> I think the use of iteratees, etc. is more for controlling when you have the responses rather than to handle a large load
02:35:36 <Taejo> ivanm: in that case the reason I don't need iteratees because the when is always now
02:36:07 <ivanm> Taejo: more in the sense of lazy I/O not always providing input in a timely manner
02:36:17 <ivanm> IIUC, if you use strict I/O then it shouldn't be a problem
02:38:30 <kmc> i would just use http://hackage.haskell.org/package/HTTP Taejo
02:38:56 <Taejo> kmc: thanks, I'll look at that
02:38:57 <kmc> if you need asynchronous IO, use threads
02:40:47 * hackagebot qrcode 0.1.1 - QR Code library in pure Haskell  http://hackage.haskell.org/package/qrcode-0.1.1 (ChrisYuen)
02:41:07 <hpaste> kmc pasted “async HTTP (for Taejo)” at http://hpaste.org/51726
02:42:01 <Taejo> cool, thanks... I'll probably only need async if I have the bot playing multiple games
02:45:21 <kmc> well if you have to make a bunch of HTTP requests, it's nice to do them in parallel
02:46:41 <kmc> i wonder if i should add a name for:  \f xs -> mapM (spawn . f) xs >>= sequence  ::  (a -> IO b) -> [a] -> IO [b]
02:46:49 <kmc> it's kind of "parMapIO"
02:47:34 <elliott_> That sounds useful, in that it's basically "run a bunch of workers for these tasks and collect the results". I don't know if some overhead or details would interfere with using it like that, though.
02:48:16 <kmc> elliott_, one problem i ran into is, maybe each action starts by reading a 1MB file, and you have 3,000 of these
02:48:27 <kmc> if they all start at once you use too much memory
02:48:34 <kmc> that's why i added the "pool" function to spawn
02:48:42 <kmc> it keeps with the theme of the library (no explicit thread values)
02:48:55 <kmc> but it lets you wrap IO actions such that no more that n of them are executing at once
02:49:05 <elliott_> kmc: It feels like you'd want to sequentially load all the files (or pool them like that), and /then/ spawn the workers.
02:49:10 <kmc> wrote about it here: http://mainisusuallyafunction.blogspot.com/2010/09/clogparse-parsing-haskell-irc-logs.html
02:49:15 <elliott_> No need to stop the workers being as concurrent as possible.
02:49:25 <kmc> but if you can't hold all the files in memory at once
02:49:33 <kmc> i mean, virtual memory is supposed to save you here
02:49:50 <elliott_> yeah
02:49:53 <kmc> but that only works if you actually mmap them, and use packed data formats on the Haskell side
02:50:12 <kmc> otherwise you're reading files from disk, blowing them up by a large factor into Haskell heap objects, and writing the back to swap
02:50:24 <kmc> that's no good
02:50:49 * hackagebot Paraiso 0.1.0.1 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.1.0.1 (TakayukiMuranushi)
02:51:22 <kmc> if the issue is concurrent CPU usage rather than concurrent memory usage, I leave that to GHC's and the OS's scheduler
02:52:27 <kmc> it might be a problem if you have 1,000,000 work items, but not for 10,000
03:04:48 <lysgaard> If a package does not build on hackage, will haddock still be generated?
03:05:28 <kmc> no :(
03:06:01 <kmc> this ruins a lot of FFI bindings, Win32 packages, etc
03:06:09 <kmc> actually i don't know how they get the docs for Win32
03:09:12 <cheater> hmm
03:09:25 <cheater> what do you call the line that goes through the middle of a line segment?
03:09:33 <kmc> bisector?
03:09:37 <kmc> perpendicular bisector?
03:10:19 <lysgaard> kmc: Darn, I've got a package that I've written doc for, but because it has dependencies outside haddock nothing shows =/
03:10:50 <elliott_> lysgaard: You can upload haddock docs elsewhere and provide a link in the package description.
03:11:00 <elliott_> That only works if you have somewhere to put them, though
03:11:22 <kmc> oh, really
03:11:49 <kmc> er, a link that Hackage knows about?
03:11:53 <kmc> or just a link people can click
03:11:53 <elliott_> Well, no.
03:11:59 <elliott_> But you can make it bold and all. :p
03:12:02 <elliott_> Or set it as the website field.
03:12:05 <kmc> ah i see
03:12:11 <kmc> how do you make stuff bold? ;P
03:12:11 <elliott_> It'd be nice if hackage could show the module list and link to an external site.
03:12:24 <Jafet> If it's not clickable, who will follow it!
03:12:25 <elliott_> kmc: dunno, I don't know much haddock syntax :P
03:12:31 <elliott_> <elliott_> It'd be nice if hackage could show the module list and link to an external site.
03:12:32 <elliott_> as in, for each module
03:12:38 <elliott_> so it'd just be like using the normal docs
03:13:26 <rostayob> apart from pattern matching, seq and !, what forces evaluation in haskell?
03:13:28 <lysgaard> elliott_: Thats o good feature request, but wouldn't it be possible to generate haddock even though it does not build, that would solve the problem at it's roots.
03:13:42 <elliott_> I think haddock has to be able to follow imports.
03:13:46 <elliott_> Maybe I am wrong.
03:13:51 <elliott_> But it gives type errors and the like, so...
03:14:09 <elliott_> rostayob: the execution of main could depend on a value
03:14:14 <elliott_> you can think of that as the RTS pattern-matching on it
03:14:20 <elliott_> rostayob: ! is just sugar for seq, so no need to worry about that
03:14:30 <lysgaard> elliott_: Ah, so it's not possible to build haddock if you're missing a module.
03:14:35 <Jafet> Evaluation forces more evaluation
03:14:36 <elliott_> rostayob: and that's pretty much it
03:14:38 <elliott_> apart from pseq, of course
03:14:43 <elliott_> rostayob: oh, applying a function
03:14:45 <elliott_> forces the function
03:14:48 <Jafet> Until it finishes evaluating, then it stops.
03:14:52 <elliott_> would be quite a trick if it didn't have to :)
03:14:58 <elliott_> lysgaard: I think so.
03:15:04 <kmc> yeah, forcing an application forces the function
03:15:05 <elliott_> lysgaard: Otherwise it would be a really weird limitation of Hackage.
03:15:11 <kmc> forcing a constructor forces any strict data fields it may have
03:15:17 <kmc> executing an IO action forces it
03:15:33 <elliott_> did I accidentally just produce an answer to that DanBurton stack overflow question? :-P
03:15:44 <rostayob> elliott_: what do you mean with "applying a function forces the function"?
03:15:52 <elliott_> rostayob: if (f x) is forced
03:15:53 <elliott_> f has to be forced
03:15:56 <elliott_> consider (undefined ())
03:15:57 <rostayob> kmc: right, that's a good point
03:16:04 <elliott_> obviously undefined has to be forced
03:16:07 <elliott_> because it has to know what to apply to :)
03:16:16 <kmc> > (undefined ()) `seq` ()
03:16:17 <lambdabot>   *Exception: Prelude.undefined
03:16:20 <rostayob> kmc: (the strict data constructor, but that's what I meant with !)
03:16:29 <kmc> rostayob, ah.  i thought you meant the BangPatterns GHC extension
03:16:42 <rostayob> I meant both I gues
03:16:43 <rostayob> s
03:16:49 <elliott_> That's just sugar for seq in the constructor :P
03:16:51 <rostayob> I mean they both denote strictness
03:17:00 <kmc> i guess so elliott_
03:17:05 <rostayob> so !x -> seq x x?
03:17:08 <elliott_> No.
03:17:09 <kmc> no
03:17:10 <elliott_> seq x x === x.
03:17:12 <kmc> (seq x x) is useless
03:17:21 <elliott_> !x only makes sense within some larger evaluation context.
03:17:32 <elliott_> But yeah, it's basically pattern matching and seq, and ! in a constructor declaration is like doing
03:17:35 <elliott_> data Foo = Foo Int Int
03:17:38 <elliott_> mkFoo :: Int -> Int -> Foo
03:17:40 <kmc> «let !x = a in b» ⇒ «let x = a in x `seq` b»
03:17:41 <c_wraith> seq x x causes x to be evaluated when x is evaluated, obviously. :)
03:17:45 <elliott_> mkInt a b = a `seq` b `seq` Foo a b
03:17:48 <kmc> it's different if you nest ! inside a pattern
03:17:51 <elliott_> s/mkInt/mkFoo/
03:17:53 <kmc> read the GHC manual for more info
03:17:55 <elliott_> and wherever you see (Foo a b) do (mkFoo a b) instead
03:18:03 <elliott_> well, as a value. oh bother, this is much less simple than it sounded in my head
03:18:16 <kmc> as it happens you can write that mkInt as mkInt !a !b = Foo a b
03:18:38 <orobaduk> hmm
03:18:40 <elliott_> kmc: but that's non-standard! :P
03:18:48 <elliott_> I felt like simplifying it to the seqs was simpler, anyway
03:18:59 <orobaduk> i am a boy
03:19:09 <erus`> kmc do you sleep?
03:19:13 <elliott_> I kind of like to think of seq as a function that knows about a constructor of any data type you can think of, and tries to pattern match against it
03:19:24 <elliott_> and just results in its second argument no matter what happens
03:19:33 <erus`> i think there are 2 guys using the kmc nick who take shifts
03:19:33 <elliott_> that's kind of inaccurate for functions though :P
03:19:38 <elliott_> and empty data types.
03:19:51 <rostayob> why is it that seq x x is equivalent to x?
03:19:58 <elliott_> rostayob: (seq a b) means:
03:20:03 <orobaduk> python is better than haskell?
03:20:09 <ski> elliott_ : why for empty data types ?
03:20:13 <elliott_> when you force (seq a b), force a and b, and result in b
03:20:14 <rostayob> > let x = Maybe undefined in x
03:20:15 <lambdabot>   Not in scope: data constructor `Maybe'
03:20:17 <elliott_> so
03:20:20 <elliott_> (seq x x) ===
03:20:22 <rostayob> > let x = Just undefined in x
03:20:24 <lambdabot>   Just *Exception: Prelude.undefined
03:20:25 <elliott_> when you force (seq x x), force x and x, and result in x
03:20:31 <elliott_> that's equivalent to forcing x and resulting in x
03:20:39 <elliott_> because you can only force it once, after that there's no difference
03:20:39 <kmc> rostayob, there's no absolute "force this" function... only "if you force x, also force y"
03:20:43 <elliott_> and (seq a b) does _not_ do anything on its own
03:20:50 <elliott_> it only has _any_ effect when the (seq a b) /itself/ is forced
03:21:00 <kmc> if you force (seq x x) then you force x and also x
03:21:16 <elliott_> I think I am repeating kmc :)
03:21:20 <kmc> or i'm repeating you
03:21:28 <kmc> erus`, i do sleep...
03:21:32 <kmc> you can grep the logs if you don't believe me
03:21:47 <elliott_> I don't sleep. Maybe I can get that critical advantage over kmc.
03:22:21 <kmc> why don't you sleep elliott_?
03:22:57 <elliott_> It would distract from my valuable #haskell time!
03:23:06 <elliott_> People NEED me to confuse them.
03:23:56 <ski> > let x -: y = x ++ " - i think i am repeating : " ++ y; elliott_ = "elliott_" -: kmc; kmc = "kmc" -: elliott_ in elliott_
03:23:58 <lambdabot>   "elliott_ - i think i am repeating : kmc - i think i am repeating : elliott...
03:24:15 <elliott_> Precisely.
03:25:04 <rostayob> elliott_, kmc: wait, I'm not sure I understand. Let's visualize seq as pattern matching the first argument and then returning the second one
03:25:20 <elliott_> Oh no, my metaphor is going to be put into practice :-)
03:25:26 <elliott_> But I think it works fine.
03:25:35 <elliott_> If you have constructors Foo :: Int -> T and Bar :: String -> T
03:25:38 <elliott_> then seq could look like
03:25:43 <elliott_> seq (Foo _) a = a
03:25:45 <elliott_> seq (Bar _) a = a
03:25:53 <elliott_> (Obviously the Bar pattern could just be _.)
03:25:56 <kmc> rostayob, ok
03:25:56 * hackagebot linda 0.1.2 - LINear Discriminant Analysis  http://hackage.haskell.org/package/linda-0.1.2 (LennartSchmitt)
03:26:01 <elliott_> The point is that it has to force its left argument to try and match on it.
03:26:09 <elliott_> But this only happens when the "seq" application itself is forced.
03:26:19 <elliott_> Since otherwise the return value of seq is never looked at or wanted.
03:26:22 * ski . o O ( <http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/basic.html#Eval-class> )
03:26:45 <elliott_> "Functions as well as all other built-in types are in Eval."
03:26:56 <rostayob> elliott_: oh ok, and that's why seq x x == x, because when you'd observe that value it'd have the same effect anyway
03:26:57 <elliott_> Why would you add the overhead of all the contexts and then remove the advantage they give you?
03:27:04 <elliott_> rostayob: Right :)
03:27:11 <kmc> well be careful about what == means
03:27:15 <kmc> seq () x = x  also
03:27:19 <kmc> but that's not the point elliott_ is making
03:27:54 <kmc> the spec for seq is «seq ⊥ x = ⊥;  seq y x = x»
03:27:57 <rostayob> well in terms of evaluation it wouldn't make a different, both in lazyness/strictness and in the semantics
03:28:00 <elliott_> Should we tell rostayob that seq doesn't actually guarantee its first argument is evaluated before its second argument and you need pseq for that, or would that be too confusing? :-)
03:28:01 * ski cheers for kmc
03:28:01 <rostayob> *a difference
03:28:02 <kmc> and «seq x x = x» satisfies both equations
03:30:12 <rostayob> kmc: so in the end, the things that force evaluation in haskell are 1) pattern matching 2) function application (evaluation on the function) 3) seq/! 4) Strict data constructors applied to something
03:30:33 <elliott_> the latter is not really true
03:30:36 <kmc> rostayob, applying a strict constructor doesn't force its field
03:30:42 <elliott_> the evaluation of the strict fields only happens when the constructor is forced
03:30:42 <kmc> forcing an application of a strict constructor forces the field
03:30:53 <elliott_> it basically adds "seq"s to the "code" that makes up the constructor
03:30:57 <rostayob> right
03:31:11 <kmc> all of the control you get over strictness is of the form "if you force x, also force y"
03:31:17 <kmc> there's no way to say "force this absolutely"
03:31:22 <kmc> it's not clear what that means even
03:31:38 <rostayob> yeah it's a bit vague
03:31:47 <ski> (then there's primitives like `(+) :: Int -> Int -> Int' and `(>>=) :: IO a -> (a -> IO b) -> IO b' ..)
03:32:03 <elliott_> ski: You can implement Int in pure Haskell with the same strictness.
03:32:03 <kmc> the prime mover is that the runtime system will force 'main' in order to "pattern-match" on what kind of IO is to be performed
03:32:06 <kmc> at least conceptually
03:32:12 <elliott_> IO too.
03:32:19 <elliott_> (Except the IO won't actually do anything.)
03:32:20 <rostayob> ski: well >>= isn't strict itself, is it?
03:32:42 <kmc> > let x :: IO (); x = undefined in (x >> x) `seq` ()
03:32:43 <lambdabot>   ()
03:32:44 <ski> it's strict in the first argument, i think
03:32:51 <ski> hm
03:33:03 <elliott_> the actions it produces do strict evaluation
03:33:06 <kmc> i wonder if the Report even specifies these properties
03:33:08 <elliott_> but it, itself, is not strict
03:33:09 <rostayob> yeah exactly
03:33:11 <ski> ah, right
03:33:11 <ski> ty
03:33:53 <cheater> can i do multiline inputs in ghci?
03:34:12 <elliott_> with a sufficiently recent ghci:
03:34:13 <elliott_> :{
03:34:13 <elliott_> ...
03:34:14 <elliott_> :}
03:34:24 <kmc> :3
03:34:31 <elliott_> they're nice smilies.
03:34:45 <rostayob> and you can even define data types ehe
03:34:49 <elliott_> it's a shame everything starting with : is reserved for data constructors and paren-type things are out
03:34:51 <rostayob> is that out yet?
03:34:53 <elliott_> we could have such nice operators
03:35:00 <elliott_> rostayob: with a REALLY recent GHC :P (i.e. git)
03:35:10 <elliott_> or is ghc still on darcs, I don't recall
03:35:16 <kmc> it moved to git
03:35:18 <rostayob> elliott_: git
03:35:20 <elliott_> right
03:36:00 <rostayob> I'm on a netbook with no tilde symbol to be found anywhere
03:36:07 <rostayob> can't lazy pattern match :(
03:36:15 <elliott_> ~
03:36:15 <rostayob> or go home
03:36:16 <elliott_> you're welcome
03:36:26 <elliott_> here's some more in case you need it a lot: ~~~~
03:36:27 <kmc> :O
03:36:27 <rostayob> wow thank you
03:36:32 <kmc> what kind of machine has no tilde
03:36:38 <Botje> rostayob: what keyboard layout is that?
03:36:47 <kmc> need trigraphs
03:36:52 <elliott_> i think eee pc has no ~
03:36:59 <cheater> rostayob: you can do "cd" on a line of its own to return to the home dir.
03:37:03 <rostayob> Botje, kmc: it's a netbook with an usa layout, but without the button left to the one
03:37:08 <elliott_> that isn't a lazy pattern match.
03:37:09 <elliott_> that's cd.
03:37:11 <kmc> my eee pc 900 has ~
03:37:14 <rostayob> cheater: yeah but if I want to edit something
03:37:18 <Botje> weird :)
03:37:19 <kmc> it's to the right of Esc, the very top left key
03:37:25 <rostayob> also, it's got arab characters
03:37:26 <cheater> rostayob: use caps as esc, and use esc as ~
03:37:28 <cheater> solved
03:37:29 <rostayob> kmc: oh god you're right.
03:37:34 <cheater> you should be using caps as esc anyways
03:37:35 <rostayob> i'm an idiot.
03:37:38 <elliott_> rostayob: I demand my ~s back.
03:37:43 <rostayob> ~~~~~~~~~~
03:37:45 <elliott_> I gave them to you thinking you were poor.
03:37:46 <elliott_> Thanks.
03:37:49 <elliott_> With interest, no less.
03:37:53 <rostayob> no problem
03:38:00 <elliott_> Usury in practice.
03:38:11 <ski> kmc : C64 has no tilde
03:38:25 <rostayob> the italian keyboard has no tilde iirc
03:38:29 <elliott_> ski: if you get ghc working on that I'll worship you
03:38:46 <rostayob> haskell: solving all types of 1st world problems
03:38:52 <rostayob> well, #haskell
03:40:44 <dankna> Haskell on the 6502 would be "interesting"
03:40:59 <dankna> 16-bit address space but 8-bit data bus
03:41:07 <dankna> makes it really slow to do pointer indirections
03:41:11 <erus`> its ironic that americans have such a hatred for immigrants
03:41:19 <dankna> considering that we are immigrants.  yes.
03:41:41 <Saizan> alt gr+ì works as ~ :)
03:41:42 <mokus> @faq Can Haskell make those "neutrino" hooligans slow down before they hurt somebody?
03:41:43 <lambdabot> The answer is: Yes! Haskell can do that.
03:41:52 <rostayob> Saizan: on the italian keyboard? good to know
03:41:54 * ski has playing a little with a C compiler (a subset of course) on the C64, which uses a charset replacing some other characters with the ones in "\^_{|}~"
03:41:55 <kmc> erus`, have you considered joining #haskell-blah? since most of what you say is not on topic here?
03:42:15 <Saizan> rostayob: yeah, on linux at least
03:42:35 <elliott_> mokus: They'll slow down before they even accelerated.
03:42:49 <rostayob> Saizan: oh right, you're italian, i remember now :)
03:42:50 <mokus> as long as Haskell is the cause, I'm ok with that ;)
03:42:56 <dankna> yes, that's the bizarre thing about the neutrino news
03:43:05 <dankna> not just that it shouldn't be possible - but what does it even MEAN?
03:43:33 <Masxmasx> the function 'take' seems to have a maximum somewhere between 4 and 5 figures, does anyone know what it exactly is?
03:44:16 <kmc> ?
03:44:21 <mokus> dankna: maybe it means the speed of light in the vacuum is lower than it would be in a lower energy vacuum maybe?  and the neutrinos can get closer to that speed because they interact so little?
03:44:23 <moeSeth> 1+1 = ?
03:44:29 <kmc> what do you mean Masxmasx?
03:44:30 <erus`> kmc i don't think that is true
03:44:32 <kmc> > 1+1
03:44:33 <lambdabot>   2
03:44:43 <moeSeth> no  1+1 = 2-1
03:44:48 <moeSeth> #fail
03:44:50 <dankna> mokus: in that case, what does it mean for the vacuum to have energy?
03:44:54 <Masxmasx> kmc: take 9999999 [1..] does not work
03:45:00 <Masxmasx> the amount it needs to take is too high apparantly
03:45:08 <kmc> > take 9999999 [1..]
03:45:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:45:13 <Masxmasx> I want to know the maximum size I can take
03:45:15 <ski> > let 1 + 1 = 2 - 1 in True
03:45:16 <lambdabot>   True
03:45:17 <dankna> but that's probably the simplest possible type of explanation, yes.  "the speed of light still exists, it's still an absolute limit, it's just not what we thought"
03:45:19 <kmc> it works for me Masxmasx
03:45:20 <mokus> dankna: presumably it means that the space we call "empty" is in a local minimum that isn't a global minimum
03:45:21 <kmc> in ghci as well
03:45:22 <mux> > maxBound :: Int
03:45:23 <lambdabot>   9223372036854775807
03:45:26 <elliott_> Masxmasx: try maxBound :: Int
03:45:28 <mux> :t genericTake
03:45:29 <dankna> but I should point out that we can measure the speed of light through measuring time dilation
03:45:29 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
03:45:32 <elliott_> to find out what your Haskell implementation supports in terms of Int
03:45:36 <dankna> not just through measuring how long it takes light to travel
03:45:40 <kmc> > log 9999999 / log 2
03:45:41 <lambdabot>   23.253496519942026
03:45:49 <Masxmasx> hm seems to work that way indeed
03:45:52 <mux> that would be a very small Int
03:45:59 <kmc> Report guarantees 2^29-1
03:46:02 <moeSeth> 22/7
03:46:12 <Botje> Masxmasx: why do you say it does not work?
03:46:19 <Botje> what are you trying to do that's failing?
03:46:52 <Masxmasx> Botje: I'm trying to do something with a certain sequence, and my function keeps failing whenever quickCheck enters a number > 10000
03:46:57 <dankna> anyway, gotta head afk now.  it'll be decades before the physicists figure this all out, we have no Einsteins alive today I fear
03:47:08 <dankna> (if it's even a valid measurement, but.)
03:47:27 <cfricke> Howdy. Could anyone tell me, why Bool values are part of the Ord typeclass? I am just curious as I don't see a reason for it other than using functions that require the type to be part of it.
03:47:55 <mokus> dankna: even if we do, there are so many barriers to entry in modern physics I fear they would be deterred and choose a field with less bizarre math
03:47:59 <Masxmasx> Botje: goes wrong with another function that uses !! instead of take too
03:48:18 <kmc> cfricke, the type class exists so that you can use stuff that requires the instance? i'm confused, that sounds like all type classes to me
03:48:24 <kmc> bleh
03:48:25 <Masxmasx> maybe a stackoverflow of some sort? but wouldn't it error instead of give False?
03:48:37 <kmc> what i mean is, what answer would you want other than "using functions that require the type to be part of it"
03:48:44 <kmc> isn't that why Int is an instance of Ord as well?
03:48:56 <cheater> how do you get the first and second element of a pair?
03:49:01 <Taejo> BrowserAction, y u no instance MonadIO?
03:49:02 <kmc> cheater, pattern-matching
03:49:09 <kmc> > case (2,3) of (x,y) -> x
03:49:10 <cheater> without pattern matching?
03:49:10 <lambdabot>   2
03:49:13 <kmc> :t fst
03:49:14 <lambdabot> forall a b. (a, b) -> a
03:49:14 <kmc> :t snd
03:49:15 <lambdabot> forall a b. (a, b) -> b
03:49:18 <cheater> hmmmmm
03:49:32 <cheater> i thought about fst but couldn't come up with the name for snd
03:49:46 <kmc> hint: it's not car and cdr ;)
03:49:50 <cfricke> kmc: Well, for Int it makes sense, as I know 1 is indeed smaller than 2. I guess it never made much sense to me to value True > False.
03:50:24 <kmc> cfricke, the definition of (<) for the integers is no less arbitrary than the definition for bools
03:50:29 <hpc> > compare (compare True False) EQ
03:50:29 <lambdabot>   GT
03:50:52 <kmc> it's more useful perhaps
03:50:54 <Botje> Masxmasx: "goes wrong" is vague. you mean it crashes?
03:51:05 <Masxmasx> no, I mean it returns False instead of True :x
03:51:07 <Botje> if it just returns False where you expected true maybe you are running into some kind of overflow.
03:51:11 <kmc> eh, that's philosophy anyway
03:51:15 <Botje> can you show code?
03:51:29 <cheater> cfricke: you can define < for integers in many ways, for example x < y <=> x divides y
03:51:33 <Masxmasx> I'd rather not, as it's for an assignment, I don't want my professors to think I'm cheating, Botje
03:51:38 <cheater> in that case, 0 is the minimal element
03:51:45 <kmc> cfricke, suppose you want to use Bools as keys in Data.Map... then you need an Ord instance, even if you don't care much which one
03:51:56 <cheater> or is it the maximal element?
03:52:01 <cheater> maximal, yes.
03:52:05 <Saizan> cheater: Ord is for total orders though
03:52:22 <cheater> Saizan: there are other total orders on integers too!
03:52:41 <hpc> (the most obvious one is (>))
03:53:26 <cheater> isn't == a total order too?
03:53:29 <cgroza> Does anyone know what the ||| does?
03:53:44 <kmc> cgroza, whatever the libraries which you have imported define it to do
03:53:45 <cgroza> @type  (|||)
03:53:46 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
03:53:47 <kmc> @hoogle (|||)
03:53:49 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
03:54:04 <cfricke> Heh, thanks for the input.
03:54:05 <kmc> perhaps it's merely (b -> d) -> (c -> d) -> (Either b c) -> d
03:54:06 <Masxmasx> Botje: so a False when True is expected could happen when there is an overflow?
03:54:10 <kmc> @djinn (b -> d) -> (c -> d) -> (Either b c) -> d
03:54:11 <lambdabot> f a b c =
03:54:11 <lambdabot>     case c of
03:54:11 <lambdabot>     Left d -> a d
03:54:11 <lambdabot>     Right e -> b e
03:54:29 <Botje> Masxmasx: judging from the little information you gave, that's all i can think of.
03:54:44 <Masxmasx> okay, sorry I can't give more info
03:54:45 <Saizan> cheater: (==) isn't, because e.g. it's symmetric
03:55:02 <cheater> hm
03:55:17 <Botje> 999999 * 999999 does not fit in an Int, for example.
03:55:19 <cheater> hey, does anyone have a \in symbol handy?
03:55:29 <Masxmasx> but what would it do when you force it to anyway, Botje?
03:55:38 <kmc> ∈
03:55:39 <ski> cheater : `(==)' is only a partial order, two elements are comparable iff you can check them to be the same
03:55:43 <cheater> kmc: small though
03:55:46 <Botje> > ( 999999 * 999999 ):: Int
03:55:47 <lambdabot>   999998000001
03:55:50 <ski> (or a preorder if you're evil, i suppose)
03:55:52 <Botje> > ( 999999 * 999999 ):: Integer
03:55:53 <lambdabot>   999998000001
03:55:53 <cheater> i cannot use your big one
03:56:00 <Botje> oh, duh. lambdabot has 64bit ints.
03:56:08 <kmc> ε€
03:56:11 <kmc> neither of these is correct ;P
03:56:14 <cheater> kmc: nope
03:56:17 <Masxmasx> ah, returns something weird
03:56:22 <Botje> Prelude> (999999 * 999999, 999999 * 999999) :: (Int, Integer)
03:56:22 <Botje> (-729379967,999998000001)
03:56:24 <Masxmasx> excellent, that'd explain it :)
03:56:32 <Botje> Masxmasx: so I *guess* you are running into something similar.
03:56:37 <Masxmasx> yeah could well be.
03:56:39 <cheater> uh, why doesn't linux have something like windows' character map? that is so useful sometimes
03:56:54 <Masxmasx> there is no max size on lists in 32bits, Botje?
03:56:55 <kmc> i'm sure there's some gnome or kde app that does it cheater
03:56:56 <ski> @type [either,(|||)]
03:56:57 <lambdabot> forall a c b. [(a -> c) -> (b -> c) -> Either a b -> c]
03:57:08 <kmc> Masxmasx, no; lists are linked lists
03:57:09 <Botje> Masxmasx: there is no maximum size on lists except for your ram, no.
03:57:09 <cheater> kmc: yeah, i should research.
03:57:37 <Botje> Masxmasx: however, length :: [a] -> Int, so if your list is > 2**31, the result is wrong.
03:57:47 <Botje> cheater: accessories->character map in gnome
03:57:52 <Masxmasx> hmyeah, thanks
03:57:59 <cheater> ah yes
03:58:00 <leod> in that case use genericLength?
03:58:01 <hpc> if your list is that long, you won't be seeing a computed length for a couple of minutes though
03:58:07 <Botje> cheater: or you remember the unicode codepoint and do ctrl-v u 2665
03:58:10 <cheater> i have found it to be gnome-character-map independently
03:58:14 <cheater> thank you Botje
03:58:17 <cheater> Botje: ughhh!
03:58:19 <Botje> ctrl-shift-u even
03:58:19 <cheater> :)
03:59:12 <cheater> i know people whose monitor is covered with sticky notes like that :)
04:00:34 <siracusa> Say one of my modules uses threadDelay, for which the docs say it works only with GHC. If I want to release that module on hackage, should I take care that the package can only be compiled with GHC, like with a special Cabal option or so? Or is this nothing to worry about at all?
04:00:58 <Botje> I only know 2665 by heart :)
04:01:00 <hpc> the definition of threadDelay will be #ifdef'd
04:01:03 <Botje> ♥ # heart
04:01:26 <kmc> siracusa, common practice is not to worry
04:01:45 <siracusa> okay :-)
04:02:08 <kmc> not many people use implementations other than GHC... but we're making it more and more painful every day
04:02:54 <siracusa> So would that result in a "threadDelay undefined" on other implementations or just in a zero delay?
04:05:43 <mauke> siracusa: it won't compile
04:06:27 <siracusa> That's fine
04:11:39 <kmc> there's a few stupidities like that
04:11:52 <kmc> on non-GHC System.Timeout will never timeout
04:16:52 <JiXiY> Hello. I'm currently trying to employ more point-free style. I am wondering how (and if at all) to write this in point-free style: (\x -> filter (/= x) y) where y is a regular variable outside of the lambda function. any ideas? is it possible at all?
04:17:09 <mauke> @pl (\x -> filter (/= x) y)
04:17:09 <lambdabot> flip filter y . (/=)
04:17:20 <JiXiY> uh, thanks :)
04:17:57 <ski>   (`filter` y) . (/=)  -- is an alternative
04:18:47 <JiXiY> mh, I guess I prefer the first variant; thanks though.
04:19:13 <Jafet> > length. ["(\x->filter(/=x)y)", "(`filter`y).(/=)", "flip filter y.(/=)"]
04:19:14 <lambdabot>   <no location info>:
04:19:14 <lambdabot>      lexical error in string/character literal at chara...
04:19:22 <Jafet> > length. ["(\\x->filter(/=x)y)", "(`filter`y).(/=)", "flip filter y.(/=)"]
04:19:23 <lambdabot>   [18,16,18]
04:19:26 <JiXiY> @pl (\y -> zip y $ map (flip filter y . (/=)) y)
04:19:27 <lambdabot> ap zip (map =<< (. (/=)) . flip filter)
04:19:36 <JiXiY> ew ;)
04:26:22 <cheater> > let rising x = [x] ++ rising x+1 in rising 1
04:26:23 <lambdabot>   No instance for (GHC.Num.Num [t])
04:26:23 <lambdabot>    arising from a use of `e_111' at <inte...
04:26:28 <cheater> why does this not work?
04:26:39 <JiXiY> Is there also a commandline version of @pl akin to pointful ?
04:26:40 <ski> @type \y -> (map . graph) ((`filter` y) . (/=)) y
04:26:41 <lambdabot> forall a. (Eq a) => [a] -> [(a, [a])]
04:26:48 <rostayob> cheater: what's the type of x?
04:26:49 <cgroza> I am browsing the Xmonad source code, and I found "!" in a "data" declaration. Something like this: data S a b = N !(b a)
04:26:53 <cgroza> What does it mean?
04:26:54 <cheater> in my case, 2
04:27:04 <cheater> has a type of, what, int?
04:27:07 <rostayob> 2? 2 is not a type :P
04:27:12 <ski> cgroza : it means the `N' constructor is strict
04:27:16 <cheater> i think int.
04:27:22 <mauke> cheater: precedence
04:27:30 <cheater> mauke: oh?
04:27:35 <leod> > let rising x = [x] ++ rising (x+1) in rising 1
04:27:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:27:44 <cgroza> ski: what do you mean by strict?
04:27:49 <cheater> right
04:27:53 <cheater> i was just gonna try that
04:27:55 <cheater> thanks
04:28:01 <rostayob> cheater: oh i misread, I'm tired today :(
04:28:09 <ski> cgroza : that when `N foo' is forced, `foo' is always forced
04:28:11 <rostayob> and lambdabot messages are really bad
04:28:24 <cgroza> ski: so not lazy?
04:28:57 <dmwit> > let rising x = [x..] in rising 1 -- leod
04:28:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:29:04 <dmwit> or
04:29:10 <ski> cgroza : in this case, if you do `case N foo of N x -> ..x..', `x' is also forced, regardless of whether you use it or not (this distinguishes it from `nertype S a b = N (b a)', where `N' is also strict, but not quite the same)
04:29:13 <dmwit> > let rising = enumFrom in rising 1
04:29:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:29:20 <leod> yeah, I was just correcting cheater's code :)
04:29:22 <ski> cgroza : *nod*
04:29:29 <dmwit> Oh, I missed it.
04:29:32 <dmwit> ah, yes
04:30:15 <cheater> dmwit: what does enumFrom do?
04:30:24 <cheater> oh right ok
04:30:25 <JiXiY> enumerate starting at x ?
04:30:25 <hpc> > enumFrom 1
04:30:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
04:30:27 <mauke> "^ that"
04:30:28 <dmwit> cheater: What does rising do?
04:30:42 <mauke> > enumFrom 'T'
04:30:42 <cheater> right, i wanted to define rising specifically;w
04:30:43 <lambdabot>   "TUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\1...
04:30:46 <cheater> right, i wanted to define rising specifically
04:31:01 <mauke> > enumFrom ()
04:31:02 <lambdabot>   [()]
04:31:32 <dmwit> > enumFrom (1 :+ 0)
04:31:33 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Complex.Complex t))
04:31:33 <lambdabot>    arising from a ...
04:31:47 <dmwit> Aha! A case where "rising" will work, but "enumFrom" won't!
04:31:59 <dmwit> (Also, why isn't Complex an instance of Enum?
04:32:00 <dmwit> )
04:32:10 <ski> > enumFrom (0 % 1)
04:32:10 <lambdabot>   [0 % 1,1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1,7 % 1,8 % 1,9 % 1,10 % 1,11 % 1,...
04:32:31 * ski rejoices
04:32:35 <hpc> dmwit: which direction to you enumerate in?
04:32:48 <leod> i'm confused, how do you fully enumerate a Complex Float?
04:32:51 <hpc> @src Complex
04:32:51 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
04:32:52 <mauke> enumerate in all the directions
04:32:58 <dmwit> hpc: Like the other instances, if you don't specify a step, it picks an arbitrary one -- say 1 :+ 0.
04:33:06 <hpc> heh, or even how you enumerate the individual components
04:33:15 <dmwit> leod: Enum doesn't claim to be a full enumeration.
04:33:19 <leod> oh, ok
04:33:23 <mauke> hpc: the answer to that is: terrible!
04:34:47 <cheater> hmm
04:35:16 <cheater> i cannot construct naturals as a nested set of sets, right?
04:35:38 <cheater>     Occurs check: cannot construct the infinite type: t1 = (t0, t1)
04:35:40 <cheater> :(
04:35:41 <mauke> you probably can if you're sufficiently crazy
04:35:49 <cheater> how?
04:36:09 <mauke> what exactly did you try?
04:36:10 <cheater> (asked he, not knowing those were his last words)
04:36:11 <benmachine> newtype NatSet a = NS (Set (NatSet a)) -- or something
04:36:23 <ski> > iterate (In . Just) (In Nothing)  -- hmm
04:36:25 <lambdabot>   [In Nothing,In (Just (In Nothing)),In (Just (In (Just (In Nothing)))),In (J...
04:36:29 <cheater> i tried something (not even yet ironed out) such as naturals z = (z, naturals z)
04:36:44 <benmachine> yeah that won't work
04:36:49 <cheater> hm
04:36:53 <mauke> needs more 'data' wrappers
04:37:00 <cheater> ?
04:38:15 <ski> cheater : with `forall z. naturals z ~= (z, naturals z)', `naturals' is a type of streams
04:38:27 <cheater> hm
04:38:44 <mauke> data Naturals z = Cons z (Naturals z)
04:39:54 <ddarius> :k Mu ((,) Int)
04:39:55 <lambdabot> *
04:47:58 <cheater> so why exactly does this not work? main = main >> (getLine >>= putStrLn)
04:48:12 <mauke> how does it fail?
04:48:35 <cheater> talks about stacks and stuff
04:48:47 <hpc> cheater: what's the first thing main does?
04:48:51 <cheater> GHC stack-space overflow: current limit is 536870912 bytes.
04:49:01 <mauke> cheater: and what did you expect it to do?
04:49:20 <cheater> i expected it to work just like having main at the end
04:49:42 <mauke> order matters
04:50:04 <mauke> especially with >> because that's why it exists
04:50:59 <cheater> mhm
04:51:11 <ClaudiusMaximus> @src forever
04:51:12 <cheater> right, true
04:51:12 <lambdabot> Source not found. Where did you learn to type?
04:51:19 <cheater> but why doesn't this work? let shout2 = shout2 ++ "A" in shout2
04:51:27 <cheater> order here shouldn't really matter right?
04:51:34 <hpc> cheater: what's the first character in shout2?
04:51:40 <ddarius> (++) is quite definitely non-commutative.
04:51:52 <cheater> hpc: no idea..
04:52:22 <hpc> your definition is saying that the head of shout2 is the head of shout2
04:52:35 <mauke> @src (++)
04:52:35 <lambdabot> []     ++ ys = ys
04:52:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:52:36 <lambdabot> -- OR
04:52:36 <lambdabot> xs ++ ys = foldr (:) ys xs
04:52:55 <mauke> the first thing (++) does is pattern match on its first argument
04:53:07 <mauke> immediate recursion
04:53:49 <Taejo> why does cabal-install say json-0.5 needs syb >=0.3.3, but it's not listed at http://hackage.haskell.org/package/json-0.5 ?
04:54:11 <ddarius> Taejo: Presumably one of its dependencies needs that
04:54:55 <ClaudiusMaximus> i think it's more likely to be the flags/tests that hackage doesn't understand (yet?) http://hackage.haskell.org/packages/archive/json/0.5/json.cabal
04:55:26 <Taejo> ClaudiusMaximus: ahhh, thank you
04:55:44 <cheater> is there a specific name for this?
04:55:50 <cheater> "recursing in the head"?
04:56:04 <Taejo> ClaudiusMaximus: how do I disable a flag?
04:56:11 <ClaudiusMaximus> -f-flagname i think
04:56:15 <cheater> "head recursion"?
04:56:21 <hpc> cheater: i think the only name it really has is structural recursion
04:56:31 <cheater> no i mean the error
04:56:32 <Taejo> ClaudiusMaximus: thamls
04:56:39 <cheater> when you recurse in the first element indefinitely
04:56:44 <dmwit> cheater: Yes, it has a name: infinite loop.
04:56:53 <ski> cheater : maybe "left-recursion" ?
04:57:00 <hpc> also "bottom"
04:57:06 <cheater> dmwit: i am asking for a name for this specific infinite loop.
04:57:07 <mauke> the opposite is guarded recursion
04:57:16 <mauke> cheater: aren't all infinite loops of this form?
04:57:17 <cheater> hpc: bottom is the effect
04:57:22 <ski> <http://en.wikipedia.org/wiki/Left_recursion>
04:57:25 * dmwit was not aware that different infinite loops had different names
04:57:33 <dmwit> Why would you bother naming them?
04:57:36 <cheater> mauke:no, main = stuff >> main is an infinite loop too
04:57:42 <dmwit> cheater: No, it's not.
04:57:44 <cheater> dmwit: i bet someone has
04:57:48 <cheater> dmwit: why is it not?
04:57:55 <dmwit> Because it's immediately productive.
04:58:00 <mauke> ok, right
04:58:00 <cheater> so?
04:58:02 <dmwit> It does all of the stuff first.
04:58:04 <cheater> it still keeps looping
04:58:04 <ddarius> dmwit: Depends on stuff.
04:58:12 <dmwit> Yes, it depends on stuff.
04:58:14 <dmwit> That's true.
04:58:16 <cheater> assume "stuff" is simple
04:58:20 <dmwit> It may or may not be an infinite loop.
04:58:23 <hpc> (stuff = main -- :D
04:58:24 <hpc> )
04:58:29 <cheater> main = (getLine >>= putStrLn) >> main
04:58:39 <dmwit> That's not a loop.
04:58:41 <dmwit> It blocks for input.
04:58:46 <mauke> cheater: yeah, I'm not aware of a specific name for that pattern
04:58:46 <cheater> so?
04:58:56 <cheater> the fact that a loop blocks does not mean it's not a loop
04:58:58 <mauke> something like direct recursion?
04:59:15 <cheater> while true; do echo "a"; done              definitely a loop
04:59:25 * dmwit doesn't consider it so
04:59:34 * dmwit shrugs
05:00:07 <cheater> mauke: i call main = stuff >> main and main = main >> stuff loops; i am asking for a name of the latter one.
05:00:22 <mauke> <mauke> cheater: yeah, I'm not aware of a specific name for that pattern
05:00:24 <dmwit> I suppose you could distinguish "productive" from "non-productive" loops, if you wanted to call that a loop.
05:00:27 <mauke> <mauke> something like direct recursion?
05:00:44 <hpc> cheater: it's just bottom; if it doesn't have a defined value, why even bother classifying it?
05:00:54 <hpc> perhaps you could say it is a "non-terminating bottom"
05:00:55 <leod> is main >> stuff tail recursive btw?
05:01:02 <leod> stuff >> main*
05:01:18 <cheater> i believe that would be the definition of tail call recursion, no?
05:01:43 <mauke> cheater: depends on your point of view
05:01:50 <leod> yes I'm just unsure because of what (>>) could be doing here
05:01:58 <mauke> 'main' is not a call there, and the last thing in main is actually a call to (>>)
05:02:03 <leod> yeah
05:02:08 <ski> @type let (=>>) :: w a -> (w a -> b) -> w b; (=>>) = undefined; in \f -> let main = main =>> f in main  -- hmm ..
05:02:09 <lambdabot> forall (w :: * -> *) b. (w b -> b) -> w b
05:02:40 <QtPlatypus> @pl (\f x y -> compare (f x) (f y))
05:02:41 <lambdabot> flip =<< (((.) . compare) .)
05:03:07 <ski> @type \f x y -> compare (f x) (f y)
05:03:08 <hpc> haha, i just realized why 'w' is for comonad
05:03:09 <lambdabot> forall t a. (Ord a) => (t -> a) -> t -> t -> Ordering
05:03:15 <ski> @type comparing
05:03:17 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
05:03:27 <hpc> :t compare `on` f
05:03:28 <lambdabot>     Ambiguous type variable `b' in the constraints:
05:03:28 <lambdabot>       `Ord b' arising from a use of `compare' at <interactive>:1:0-6
05:03:28 <lambdabot>       `SimpleReflect.FromExpr b'
05:03:32 <hpc> :t \f -> compare `on` f
05:03:33 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
05:05:09 <QtPlatypus> ski: Ah thanks exactly what I was looking for.
05:05:44 <elliott_> ski: IO comonad? sounds... not very IOish
05:06:32 <hpc> elliott_: sure it is; just run a comonadic action backwards through time to get our working program :D
05:07:04 <ski> elliott_ : i wasn't really thinking about `IO' or `OI' here ..
05:07:28 <elliott_> OI would be, like, it's really hard to do pure computations but the world, you can change that just fine.
05:08:06 * ski . o O ( `unsafePeekComputation :: a -> Computation a' )
05:08:24 <elliott_> :D
05:08:49 <elliott_> WARNING: unsafePeekComputation is NOT GUARANTEED to produce side-effects! use it only if you can prove that computing its argument will change the world somehow!
05:09:10 <ski> (where you might be able to observe in `Computation a' whether the corresponding `a' has been computed yet or not -- i'm not sure)
05:10:51 <cheater> ((putStr "> ") >> getLine) >>= putStrLn
05:11:14 <elliott_> putStr "> " >> (getLine >>= putStrLn) is better in general, avoids building up tons of thunks.
05:11:15 <ski> you'll probably want a `hFlush stdout' in there
05:11:16 <cheater> what am i doing wrong? i want to first do putStr, then get a line, then putStrLn what i got from getLine
05:11:21 <elliott_> ski: that too
05:11:49 <mauke> cheater: looks ok to me
05:12:44 <cheater> mauke: try it.. what it does is it gets a line, and then on a new line echoes "> your_input"
05:12:59 <elliott_> GHC doesn't flush output to stdout when you read to stdin unlike most languages.
05:13:06 <mauke> cheater: yes, just like any other language ever
05:13:07 <elliott_> (since this behaviour is inconsistent)
05:13:09 <ski> cheater : that's be the missing `hFlush stdout', then
05:13:18 <mauke> ok, C++ actually does something about that I believe
05:13:23 <cheater> ski: oh, interesting.
05:13:29 <elliott_> mauke: Python too.
05:13:32 <elliott_> and every scripting language ever
05:14:20 <cheater> ski: hmm, hFlush and stdout are not in scope
05:14:34 <ski> @type System.IO.hSetBuffering System.IO.stdout System.IO.NoBuffering  -- alternatively doing this before
05:14:35 <lambdabot> IO ()
05:14:38 <elliott_> hFlush and stdout are in System.IO.
05:14:39 <ski> @index hFlush
05:14:40 <lambdabot> System.IO
05:14:45 <elliott_> ski: that's probably worse than hFlush imo
05:14:57 <hpc> don't unbuffer stdout unless you know what you are doing
05:15:07 <cheater> hpc: why?
05:15:26 <cheater> hpc: could it.. explode?
05:15:31 <mauke> makes for terrible performance
05:15:36 <hpc> that
05:15:38 <cheater> perfect, i want it
05:15:56 <cheater> if it's faster than java, it's fast enough for me
05:16:00 <hpc> it has to write characters one at a time, which is a lot of overhead from system calls higher up
05:16:18 <cheater> let's not get too caught up on a hello world.
05:17:28 <elliott_> hFlush is simpler than hSetBuffering imo
05:17:51 <elliott_> hFlush stdout when you need it vs. the longer, more forceful bludgeoning of hSetBuffering stdout NoBuffering
05:18:36 <ski> `error =<< getContents' with `NoBuffering' on `stdin' is fun
05:18:48 <elliott_> haha
05:18:48 <mauke> ski: heh. interactive exception?
05:18:54 <elliott_> the power of haskell
05:19:17 <elliott_> ski: turn echo off too, finally exceptions can do "cat"
05:19:23 <elliott_> or hmm I guess it's actually cat >/dev/null
05:19:25 <elliott_> since it doesn't repeat
05:23:51 * ski wonders about computable surreals
05:23:54 <deech`> Hi all, I was just at the Strange Loop conference where there was a lot of (well-deserved) love for Clojure which they think take the best parts of Haskell (purity, some laziness) and leave out the "bloated Stalinesque type system". Besides making guarantees about code, how can I better articulate why the type-system might be a good thing?
05:24:17 <elliott_> bloated Stalinesque type system? Sounds like they've made up their preconceptions already.
05:24:22 <cheater> the assignments in do are just syntax for let, right?
05:24:42 <elliott_> The "let ... = ..." assignments in a do block are sugar for let (almost), but "... <- ..." assignments are not.
05:25:12 <mauke> deech`: the type system isn't for you to hit your head on, but to stand on and reach new heights
05:25:48 <deech`> elliott_: The perception is that Haskell ties your hands. And this from people like Gerald Jay Sussman and Rich Hickey who implied that the type system was "incidental complexity"
05:25:55 <ski> @undo do x <- foo; bar x; y <- baz x; let {z = f x y}; _ <- quux x y z; barf
05:25:56 <lambdabot> foo >>= \ x -> bar x >> baz x >>= \ y -> let { z = f x y} in quux x y z >>= \ _ -> barf
05:26:05 <ski> cheater ^
05:26:07 <hpc> deech`: the type system isn't a list of things you can't do, it's a list of things you can tell the compiler /so it knows what cannot happen/
05:26:12 <cheater> ski: ahh
05:26:24 <elliott_> I have a data-type with many constructors, all records. A lot of the fields in these records have the same names as others, but unfortunately, I cannot simply rely on normal field-in-multiple-constructors behaviour, since some of them have different types (the same semantic value represented at different integral sizes, and the like; this is unfortunate, but it's modelling a protocol beyond my control). I've been ad-hocly tweaking the field names that
05:26:25 <elliott_> clash, but I'm tempted to just prefix every field name with the constructor. Some of the constructor names are a bit long (twenty letters or so), so this would increase verbosity by quite a large amount, but I don't use the accessors _that_ often, and it seems like it's a better solution than ad-hoc renaming when conflicts arise. Does anyone have a better suggestion?
05:26:38 <cheater> @undo iteration = do x <- getLine; putStrLn x
05:26:38 <lambdabot> iteration = getLine >>= \ x -> putStrLn x
05:26:42 <ski> @undo do x0:x1 <- getArgs; foo x0 x1
05:26:42 <lambdabot> getArgs >>= \ a -> case a of { x0 : x1 -> foo x0 x1; _ -> fail ""}
05:26:45 <hpc> so GHC can make more assumptions based on the type of a thing than Clojure can make off of a (define)
05:26:45 <ski> cheater : also ^
05:26:58 <cheater> ski: amazing, thanks
05:27:08 <elliott_> ski: fail ""? not quite accurate :-)
05:27:17 <deech`> hpc: Yes, this is a great point.
05:27:30 <ion> @undo do let (x0:x1) = foo; x1
05:27:31 <lambdabot>  Parse error at end of input
05:27:34 <hpc> deech`: for example, if you say "let x = 5 :: Int", GHC can assume that x will never ever change, and it can always be inlined, all the time forever
05:27:45 <ion> @undo do { let (x0:x1) = foo }; x1
05:27:46 <lambdabot>  Parse error at "};" (column 24)
05:27:47 <mauke> hpc: that's unrelated to the type system
05:27:51 <cheater> @unpl iteration = getLine >>= putStrLn
05:27:51 <lambdabot> iteration = getLine >>= putStrLn
05:27:51 * ski thinks `fail' ought to satisfy `forall s0,s1. fail s0 = fail s1' anyway ..
05:27:56 <cheater> @pl iteration = getLine >>= putStrLn
05:27:56 <lambdabot> iteration = putStrLn =<< getLine
05:27:56 <deech`> hpc: Isnt' that more to do with purity?
05:28:01 <elliott_> ski: So just "fail :: m a"? :p
05:28:02 <cheater> lol?
05:28:09 <elliott_> ?src (=<<)
05:28:09 <lambdabot> f =<< x = x >>= f
05:28:37 <elliott_> (=<<) is more consistent with ($), but (>>=) reads in a nicer pipeline style for much imperative code.
05:28:41 <ski> @undo do let { (x0:x1) = foo }; x1
05:28:42 <lambdabot> let { (x0 : x1) = foo} in x1
05:28:43 <mauke> deech`: I think it's important to note that you can't take a valid haskell program, remove the types, and still run it on an "untyped haskell" interpreter or something
05:28:51 <mauke> deech`: the types actually carry meaning
05:29:03 <elliott_> mauke: If we trashed typeclasses... :p
05:29:54 <deech`> mauke: Is this because of a dictionary that gets passed around that selects the right version of an overloaded function?
05:30:06 <mauke> dictionaries are implementation details
05:30:12 <mauke> but yeah, typeclasses
05:30:48 <ski> elliott_ : well, allowing one to recover the `String' in `IO', like with imprecise exceptions, would be ok, i suppose
05:31:14 <deech`> I did a little bit of Lisp before and for the life of me I can't figure out how they debug their macros. It seems *so* error-prone.
05:31:25 <elliott_> ski: So basically you want fail = throwIO :-)
05:31:43 <ski> deech` : Racket nowadays has a macro stepper ..
05:31:48 <ddarius> deech`: Just write a macro-writing macro to add debugging annotations to a macro
05:32:14 <ski> elliott_ : well, `const Nothing',`const []' is ok for `Maybe',`[]' :)
05:32:20 <drbean> m97km97k
05:32:34 <ddarius> drbean: Damn straight.
05:32:39 <cheater> uhhhhh
05:32:42 <elliott_> drbean: Are you sure?
05:32:45 <cheater> why does unicode call lambda "lamda"?
05:32:45 <elliott_> I think 999mkmkmkmkmk.
05:33:07 <deech`> ski: Cool, didn't know that.
05:33:08 <ddarius> cheater: Why do you call lamda "lambda"?
05:33:13 <elliott_> Typos in Unicode data files cannot be corrected; the names and the like are immutable. There are a few typos hanging around.
05:33:22 <dropdrive> Are there "vectors of length N" in Haskell where, say, adding two vectors of different lengths (elementwise) is a compile-time error?
05:33:27 <cheater> ddarius: because that is chosen by linguists.
05:33:34 <ddarius> cheater: Hah.
05:33:35 <elliott_> dropdrive: Yes. Various implementations of that.
05:34:03 <deech`> ddarius: Yikes!
05:34:12 <dropdrive> elliott_: Thanks (names?) -- do you know if any of them extend to multidimensional arrays?
05:34:32 <mauke> cheater: so is lamda
05:35:58 <elliott_> dropdrive: I looked into them a while back, with https://github.com/tobbebex/GPipe/issues/2 being the result; although I didn't look much at arbitrary-size fixed ones, the Vec in question is one of them. I think Conal's vector-space package does it. copumpkin's vector-static too but it's not maintained.
05:36:12 <elliott_> I think one of them extends to multiple dimensionals. It might have been vetor.
05:36:13 <elliott_> vector.
05:36:18 <cheater> mauke: apparently lamda is what the greeks call it.
05:36:19 <elliott_> (vector-static builds on top of the vector library, which is nice.)
05:36:33 <dropdrive> elliott_: Thanks!  will look
05:37:00 <elliott_> dropdrive: There are some issues to the approach, basically caused by the fact that Haskell isn't dependently-typed :-) It might work for you though.
05:37:08 <dino-> @seen Lemmih
05:37:08 <preflex>  Lemmih was last seen on #haskell 15 days, 2 hours, 7 minutes and 4 seconds ago, saying: Jafet: What does 'mapM_' have to do with it?
05:37:08 <lambdabot> Unknown command, try @list
05:37:13 <elliott_> dropdrive: How big are the arrays in question?
05:37:34 <dropdrive> elliott_: Offhand, do you know if there is a runtime penalty dependent on the size of the array?
05:37:54 <dropdrive> elliott_: They are likely to be many millions of, say, doubles
05:38:19 <dropdrive> elliott_: Wait, are you not Conal.  Huh.
05:38:24 <elliott_> No, I'm not :)
05:38:35 <elliott_> dropdrive: Well... with vector-static, hmatrix-static: hopefully little to no overhead. But things like Vec effectively reduce to a linked list at runtime, so, yeah.
05:38:37 <ion> Impostor!
05:38:39 <elliott_> dropdrive: Have you seen repa?
05:38:51 <elliott_> It does not statically check lengths but it does statically check shapes/dimensions.
05:39:01 <elliott_> And it's very focused on performance, memory usage, automatic parallelism, etc.
05:39:26 <elliott_> ion: It's not my fault he stole my name.
05:39:36 <dropdrive> elliott_: Okay, thanks.  I wonder what happens when you add two incompatibly sized repa arrays?
05:39:49 <elliott_> dropdrive: Depends how you define "add".
05:40:03 <elliott_> It doesn't come with a Num instance (it shouldn't; arrays aren't Nums.)
05:40:20 <dropdrive> elliott_: Elementwise addition.
05:40:23 <elliott_> http://hackage.haskell.org/package/repa-algorithms might interest you for doing operations on huge numbers of doubles.
05:40:27 <elliott_> dropdrive: Right. Well, it depends how you build that.
05:40:37 <elliott_> zipWith :: (Shape sh, Elt a, Elt b, Elt c) => (a -> b -> c) -> Array sh a -> Array sh b -> Array sh cSource
05:40:37 <elliott_> Combine two arrays, element-wise, with a binary operator. If the extent of the two array arguments differ, then the resulting array's extent is their intersection.
05:40:50 <elliott_> So it'd chop off the extra elements, I would think.
05:40:55 <elliott_> Assuming you used zipWith (+).
05:41:04 <dropdrive> Looks like it, doesn't it.  Thanks!
05:41:06 <elliott_> (That "Source" was an accidental copy-paste.)
05:41:28 <elliott_> dropdrive: I agree it'd be nice to have something statically length-checked on top of repa, but one major problem is that when you get millions of elements, that ends up being a HUGE unary numeral at the type level.
05:41:29 <ddarius> You could of course easily add in a check to make sure the arrays have matching dimensions first.
05:41:35 <elliott_> ddarius: Naturally.
05:41:49 <ddarius> elliott_: There's no reason numbers need to be represented in unary at the type level.
05:41:59 <elliott_> dropdrive: The TypeNats extension will change that.
05:42:13 <elliott_> So hopefully we'll see something built on top of repa or whatever soon with no runtime overhead and good compile-time performance.
05:42:16 <elliott_> But it's not here yet.
05:43:14 <deech`> Is there some way to generate Haddock docs for packages that have already been installed?
05:43:30 <ddarius> Run haddock on them...
05:43:35 <dropdrive> elliott_: That is something to look forward to!
05:43:59 <deech`> ddarius: I meant some way to run Haddock on all of them :)
05:44:08 <elliott_> Somehow everything I want to do is always a few GHC versions away :P
05:44:28 <ddarius> elliott_: You can make non-unary representations of numerals today in pretty much any version of GHC.
05:45:58 <elliott_> ddarius: Yes, but they're awkward to use IME.
05:46:28 <elliott_> The unary numbers seem to get you stronger results that the binary versions won't admit somehow.
05:46:30 <elliott_> I could just be doing it wrong.
05:46:54 <ddarius> You get a different "natural" notion of recursion.
05:47:42 * ski ponders naturals defined as functions with finite support from naturals to bits
05:49:59 <ddarius> Infinitary sum of the appropriate 2 element group.
05:51:37 <deech`> Apparently haddock isn't compatible with ghc 7.2.1, has anyone had problems with just editing the .cabal file and installing?
05:52:02 <ski> (the definition should be recursive, of course)
05:52:09 <elliott_> really? that would surprise me, people use 7.2.1 after all
05:52:43 <deech`> I get a "cannot configure ... requires base ==4.3.* and ghc >=7.0
05:52:46 <deech`> && <7.2
05:52:50 <elliott_> ah
05:52:58 <elliott_> maybe try hackage from darcs or whatever?
05:53:00 <elliott_> erm
05:53:01 <elliott_> haddock
05:53:20 <dmwit> Yes, I don't think haddock has been updated yet.
05:53:22 <deech`> elliott_: yeah, that's my next step.
06:09:34 <nooodl> hmm, i have two data declarations, like, "data AExp = ... | Appl AExp AExp" and "data BExp = ... | Appl BExp BExp"
06:09:49 <nooodl> this gives an error. apparently i can't use "Appl" for both of those
06:11:37 <ClaudiusMaximus> you could put them in different modules, or perhaps parameterize the type like data Exp a = ... | Appl (Exp a) (Exp a)
06:12:19 <ddarius> nooodl: What would the type of Appl be if both declarations were allowed?
06:12:55 <nooodl> yeah, it makes sense, i'm just looking for a good way around it without having to rename one of them
06:13:02 <nooodl> putting them in different modules is what i'll do. thanks :)
06:13:13 <nooodl> i can do that in one file, right?
06:13:19 <ddarius> No.
06:13:32 <avartanian> There's got to be a "common interface" for AExp and BExp, no?
06:13:41 <avartanian> Wouldn't GADTs help here?
06:15:57 <avartanian> Oh, I read the problem wrong. Hence my comment was inane. I retract.
06:15:58 <nooodl> they're pretty different kinds of expressions. Appl is the only thing they really have in common
06:16:04 <Cale> nooodl: The usual solution is just to name them differently
06:16:18 <nooodl> Cale, maybe AAppl and BAppl?
06:16:21 <Cale> yeah
06:16:43 <Cale> You can make a typeclass for things with application if you'd like a common notation.
06:16:58 <Cale> It's probably more convenient to have an infix notation for application in general anyway :)
06:17:01 <Eduard_Munteanu> Or maybe type-directed resolution, but that's probably not ready yet.
06:17:27 <Cale> Oh, that thing.
06:17:28 <ddarius> Type classes are type directed resolution.
06:17:45 <Cale> yeah, that's what I was thinking
06:17:50 <ddarius> "How to make less ad-hoc polymorphism more ad-hoc"
06:17:51 <avartanian> I wonder about the situation in which you'd want a type constructor (Appl) to either return an AExp or a BExp depending on the value of its parameters.
06:17:56 <Cale> But there's also: http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
06:18:06 <ddarius> Cale: I'm aware of it.
06:18:30 <Cale> avartanian: You could use a typeclass
06:18:41 <Cale> avartanian: (though it doesn't work in the direction of pattern matching)
06:19:19 <Cale> class Apply e where appl :: e -> e -> e
06:19:57 <Cale> instance Apply (AExpr t) where appl = AAppl
06:20:00 <Cale> etc.
06:20:41 <nooodl> what i'm doing is, i'm converting lambda expressions (Term Char | Appl LExp LExp | Abst Char LExp) to combinator ones (S | K | I | Appl CExp CExp)
06:20:43 <elliott_> Aww, type-directed name resolution wouldn't even solve my record field naming issue. I thought it might for a second :)
06:22:35 <Eduard_Munteanu> nooodl: why not give some proper types to S, K and I?
06:23:05 <Eduard_Munteanu> and do away with application
06:23:11 <nooodl> Eduard_Munteanu, would that change a lot?
06:24:17 <elliott_> Eduard_Munteanu: that would stop you typing anything not well-typed in haskell.
06:24:19 <ddarius> Eduard_Munteanu: That wouldn't work.
06:24:20 <elliott_> like, say, SKI :P
06:24:34 <ddarius> elliott_: I don't think that's what he was suggesting.
06:24:49 <ddarius> But maybe it was.
06:24:56 <elliott_> Well, if you do away with application...
06:24:58 <elliott_> How else would you do it?
06:25:08 <elliott_> I guess you could do
06:25:11 <ddarius> elliott_: data CExp = S CExp CExp CExp | ...
06:25:14 <elliott_> data SKI = S SKI SKI SKI | K ... right.
06:25:17 <elliott_> But that stops partial application, of course.
06:25:20 <Eduard_Munteanu> I suggested writing expressions like  S (K (...
06:25:24 <ddarius> elliott_: Exactly.
06:25:34 <hpc> wouldn't it be S SKI SKI?
06:25:42 <elliott_> Unless you define data CExp = CExp (CExp -> CExp)... :-)
06:25:43 <hpc> oh, wait nvm
06:25:47 <hpc> K is const
06:25:48 <ddarius> Eduard_Munteanu: The question is what types were you expecting for S.
06:26:52 <Eduard_Munteanu> ddarius: S CExp CExp CExp
06:27:25 <Eduard_Munteanu> Well, if you want to be sure they're well formed, there's that GADT approach for SKI, IIRC.
06:27:54 <nooodl> i want to be able to have partial applications still be full objects
06:27:55 <elliott_> The GADT approach almost certainly involves restricting the expressions to those valid in Haskell.
06:27:57 <elliott_> As in no SKI.
06:27:58 <ddarius> Eduard_Munteanu: The problem is you want terms like S (SK) etc.
06:28:00 <Eduard_Munteanu> http://haskell.org/haskellwiki/GADT
06:28:17 <elliott_> nooodl: I think you should just have LAppl and CAppl.
06:28:28 <elliott_> You don't have enough common ground in your ASTs to want to do anything else, really.
06:28:31 <Eduard_Munteanu> ddarius: oh, hrm.
06:28:42 <ddarius> You could make an applicative structure type.
06:28:57 <ddarius> Lambda terms and combinators both form applicative structures.
06:29:45 <Eduard_Munteanu> Maybe    data SKI = S CExp CExp CExp | K CExp CExp | I CExp | Hole   ?
06:29:55 <elliott_> Eduard_Munteanu: Gross.
06:29:59 <Eduard_Munteanu> :)
06:30:00 <elliott_> Especially since
06:30:05 <elliott_> S Hole (I ...) Hole
06:30:08 <elliott_> is nonsense.
06:30:30 <Eduard_Munteanu> Yeah, I think I hinted you can't constrain it properly.
06:30:44 <elliott_> You probably can; you can construct "lists of N or fewer elements".
06:30:47 <elliott_> But ugh.
06:31:00 <elliott_> data SKI = S (Maybe (CExp, Maybe (CExp, Maybe CExp))) | ...
06:31:04 <Eduard_Munteanu> Or dependent types ;)
06:31:25 <ddarius> data SKI = S0 | S1 SKI | S2 SKI SKI | ...
06:31:49 <ddarius> I'm sure that won't be painful at all.
06:33:56 <nooodl> this is more difficult than i expected it to be
06:34:06 <elliott_> nooodl: No, we are all overcomplicating it.
06:34:14 <elliott_> nooodl: Just have two separate data types and rename the constructor.
06:34:21 <Eduard_Munteanu> You could just use a different name, yeah ;)
06:34:26 <nooodl> haha ok
06:35:10 <ddarius> Or you could abstract out the applicative structure aspect.
06:35:50 <elliott_> Would that help for something this dirt simple?
06:35:58 <ddarius> I'm sure there are also results that apply to arbitrary applicative structures, and certainly there are operations, like "multiple argument" application that would be shared.
06:36:00 <ddarius> elliott_: Probably not.
06:36:20 <nooodl> hmm. i wonder if there's a way to turn functions into LExp objects. like (\x -> \y -> x) into Abst 0 (Abst 1 (Term 0))
06:36:25 <nooodl> there probably isn't
06:36:49 <elliott_> nooodl: There is.
06:36:51 <elliott_> Well.
06:36:51 <ddarius> I think I could do it.
06:36:56 <elliott_> Yeah.
06:37:02 <elliott_> It's kind of gross, but you can do it just fine.
06:37:20 <ddarius> Alternatively, you could just use TH.
06:37:49 <avartanian> off-topic question, does anyone know how all the scala folks got that little scala icon on the corner of their twitter pics? is there an app for that? and, if so, shouldn't haskellers have one too?
06:37:53 <nooodl> elliott_, how'd that work?
06:38:21 <elliott_> nooodl: I'm working on a little sample now.
06:38:23 <elliott_> It's not pretty though.
06:38:30 <elliott_> It's metaprogramming hacks :P
06:38:35 <nooodl> heh :)
06:52:04 <morphles> I can't have two data types with fields that have same name? Well from error message it seems that way.
06:52:19 <Cale> morphles: that's right
06:52:42 <Cale> morphles: Because the field names are also names of functions that are being defined to extract those fields.
06:53:26 <morphles> Hm, right. Thats kinda unfortunate :)
06:53:31 * ski . o O ( hum .. `data T :: * -> * where S :: T (a -> b) -> (T a -> T b); K :: T a -> T b -> T a; I :: T a -> T a; Abs :: (T a -> T b) -> T (a -> b)',`abs2 = Abs . (Abs .)',`(abs2 . S) ((abs2 . S) (abs2 K)) :: T (((a -> b) -> a) -> ((a -> b) -> a))' )
06:53:45 <Cale> At least, in the same scope you can't. If you put them in separate modules, you can use qualified imports, but the usual solution is just to add a small tag to the field names.
06:54:19 <cheater> i have a program with a list, i would like to add stuff to this list, how would i best do that? http://pastebin.com/WtQ6x4jw
06:54:21 <mauke> The paste WtQ6x4jw has been copied to http://hpaste.org/51729
06:54:49 <dmwit> cheater: If your function depends on a list, it must take a list as an argument.
06:55:02 <dmwit> cheater: Then it's easy to call that function with a longer list than before. Just do it.
06:55:16 <dmwit> > "Daniel" : ["Don", "Simon", "Eduard"]
06:55:18 <lambdabot>   ["Daniel","Don","Simon","Eduard"]
06:55:41 <cheater> hmm
06:56:00 <cheater> how would i return a string from iteration to main?
06:56:30 <cheater> oh, i think i know
06:56:34 <ski> (oh, it should be `S :: T (a -> b -> c) -> (T (a -> b) -> T (a -> c))' i suppose .. or would `S :: T (a -> b -> c) -> (T (a -> b) -> (T a -> T c))' be more fun ?)
06:56:37 <Botje> you could make iteration call itself at the end
06:56:50 <dmwit> cheater: Okay, give it a shot and let us know how it works out/if you have any more questions. =)
06:56:57 <cheater> alright will try
06:57:12 <cheater> Botje: yeah, but i went away from doing that.
06:57:14 <cheater> :)
06:57:15 <dmwit> If it doesn't work out, we can certainly give you some hints.
06:57:20 <hpaste> elliott pasted “partial LC DSl” at http://hpaste.org/51730
06:57:21 <cheater> ok :)
06:57:22 <dmwit> You can do it without making iteration call itself.
06:57:26 <elliott_> nooodl: that's a start
06:57:26 <dmwit> If you want.
06:57:40 <cheater> yeah i think i know how
06:57:55 <elliott_> unfortunately you have to explicitly specify that type signature, though I think that can be solved too
06:57:56 <cheater> i need to use do notation for main though, right?
06:58:02 <cheater> instead of >>
06:58:06 <dmwit> No, you never *need* to use do-notation.
06:58:17 <dmwit> Though if you find it more convenient, by all means, use it.
06:58:20 <elliott_> nooodl: oh... you don't need TypeFamilies in that LANGUAGE
06:58:26 <cheater> what would i use then ?
06:58:32 <dmwit> cheater: For what?
06:58:48 <dmwit> do-notation is not magic: it desugars to plain old function calls.
06:59:37 <cheater> i was thinking something like main list = do name <- iteration list; main name:list
06:59:39 <dmwit> Looks like RWH has a nice section on this, if you care: http://book.realworldhaskell.org/read/monads.html#monads.do
06:59:58 <dmwit> do { x <- m; y } === m >>= \x -> m
07:00:00 <dmwit> err
07:00:03 <dmwit> m >>= \x -> y
07:00:13 <elliott_> I'm sure whatever ddarius said he could come up with is nicer than that mess :)
07:00:22 <dmwit> More precisely, do { x <- m; y } === m >>= \x -> do y
07:00:24 <elliott_> but, oh well, proves you can convert functions to LC asts. kinda.
07:00:30 <nooodl> elliott_, wow
07:00:44 <elliott_> what you really want is defaulting for the Gen class so you can avoid all those pesky signatures.
07:01:17 <ddarius> elliott_: It's roughly the same, except that I use level order deBruijn indexes which simplifies things.
07:01:44 <elliott_> ddarius: It does? I originally hacked mine up assuming I'd use them, but then it turned out not to.
07:01:46 <elliott_> So I didn't bother to fix it.
07:02:09 <elliott_> ddarius: Does yours require the type annotations?
07:08:59 <Kaidelong> I need a library for kleene trivalent logic, does someone know of one? I wouldn't be hard to write it myself.
07:09:42 <Kaidelong> I think one of the big problems is that Eq expects a bool result but for kleene values Eq gives you another kleene
07:09:59 <Kaidelong> since Unknown <-> Unknown is Unknown
07:10:32 <elliott_> seems like you just need to define another operation.
07:10:34 * ski . o O ( Aymara trivalent logic )
07:10:38 <Kaidelong> but having an eq instance would be nice
07:10:46 <elliott_> it doesn't obey the Eq laws, you can't.
07:10:53 <elliott_> (nobody mention float...)
07:11:14 <elliott_> but at least float's (==) always returns booleans :P
07:11:18 <ski> (i.e. <http://aymara.org/biblio/html/igr/igr3.html>)
07:11:49 <Kaidelong> yeah okay, how should I implement Eq? Make two newtypes for it?
07:12:02 <elliott_> don't
07:12:08 <elliott_> just have
07:12:11 <elliott_> (==^) :: Tri -> Tri -> Tri
07:12:13 <elliott_> or whatever
07:12:30 <elliott_> :t let a <--> b = "test" in 0 <--> 0
07:12:31 <lambdabot> parse error (possibly incorrect indentation)
07:12:33 <elliott_> aw
07:12:38 <elliott_> I was hoping you could use <--> as the operator
07:12:39 <Kaidelong> I guess I won't be using these values as keys in my implementation
07:12:57 <Kaidelong> err, the implementation of the thing I'm going to do that needs kleenes
07:13:13 <Kaidelong> hmm
07:13:14 <elliott_> Kaidelong: you can provide a silly Eq implementation and Ord as long as x == x, compare x x == EQ, compare x y is not inconsistent with compare y x, etc.
07:13:19 <Kaidelong> perhaps I should just do deriving Eq
07:13:25 <elliott_> just document in the instance that it's meant to be used for things like Sets and Maps
07:13:29 <Kaidelong> for libraries that work with Eqs
07:13:31 <Kaidelong> and then yeah
07:13:31 <elliott_> (you can add documentation to instances with haddock, so do it separately)
07:13:35 <elliott_> (not deriving)
07:13:36 <Kaidelong> document that the actual Eq is something else
07:13:47 <elliott_> it's a shame really, those notions should be separate :)
07:14:02 <Kaidelong> I was thinking to use newtypes for things like (==) means you know the two are equal, (==) means you don't know the two are not equal
07:14:18 <Kaidelong> well I guess I can do that too
07:14:20 <elliott_> yeah, those should probably just be separate functions
07:14:24 <elliott_> rather than newtypes with Eq instances
07:14:28 <Kaidelong> and I can do that too
07:14:32 <elliott_> if someone really wants they can wrap it in a newtype themselves and write the Eq instance
07:14:35 <elliott_> but I doubt that will come up much
07:14:41 <elliott_> it sounds like a path to confusion to me
07:14:44 <Kaidelong> well I'm thinking so that you can pass a function that wants (Eq n) =>
07:14:57 <Kaidelong> the (==) it's supposed to use
07:15:07 <elliott_> yeah, but it takes like two seconds to define your own newtype locally if you really need that :P
07:15:09 <Kaidelong> hmm I wonder if a syntax for anonymous instances would be a god idea
07:15:12 <elliott_> I wouldn't add it until you run into it in practice.
07:15:20 <Kaidelong> Agda allows something in that vein doesn't it?
07:15:26 <Kaidelong> good even
07:16:11 <Kaidelong> well you could do it in haskell if you part with typeclasses and just make the stuff explicit parameters
07:17:11 <elliott_> Instances could do with being more first-class.
07:17:20 <Cale> cheater: another little point, you should indent if/then/else like:
07:17:22 <Cale> if foo
07:17:24 <Cale>    then bar
07:17:27 <Cale>    else quux
07:17:38 <Cale> (the 'then' and 'else' should line up)
07:17:59 <hpc> (it follows the normal indentation rules, where "if x then y else z" is considered to be one line)
07:18:13 <cheater> Cale: why?
07:18:15 <Cale> cheater: In previous versions of ghc, the way you aligned it would be a parse error, because the 'else' is on a separate line of the do-block.
07:18:28 <cheater> Cale: in what versions?
07:18:31 <elliott_> Cale: More important than that is that it is more conventional.
07:18:47 <Cale> There's a silly rule in Haskell 2010 which allows semicolons in the middle of an if-then-else construct, but it's ugly
07:19:14 * ddarius agrees with Cale.
07:19:29 <cheater> Cale: how old are those versions?
07:19:53 <Cale> The golden rule of indentation in Haskell: if something is a part of something else, it should start in a deeper column on the page, and if two things are siblings, they should line up.
07:19:58 <cheater> are we talking about ghc 6 at all?
07:20:14 <Cale> I believe it'll fail in GHC 6.12.x
07:20:23 <cheater> ok
07:20:33 <Cale> But yeah, more importantly, the 'then' and 'else' are both part of the 'if'
07:20:34 <cheater> when was ghc 6.12 released?
07:20:40 <Cale> So they should start in a deeper column
07:20:50 <Cale> and they are conceptually siblings
07:20:55 <Cale> so they should line up with each other
07:20:56 * hackagebot cabal-dev 0.9 - Manage sandboxed Haskell build environments  http://hackage.haskell.org/package/cabal-dev-0.9 (JoshHoyt)
07:20:57 * ddarius usually has 'then' on the same line as 'if'
07:21:18 <Cale> If you put the 'then' on the same line as the 'if', then the 'else' should still line up with it
07:21:28 <cheater> does haskell have elseif?
07:21:31 <ddarius> And then I simply indent 'else' two characters, or I line it up with 'then' depending on how I feel.
07:21:31 <Cale> no
07:21:36 <cheater> nothing like it?
07:21:41 <ddarius> Neither does C.
07:21:48 <edwardk> cheater: sure, you just put a space between the else and the if ;)
07:21:49 <ddarius> (or Java or C# or ...)
07:21:56 <cheater> ok
07:22:05 <ddarius> elseif is ridiculous.
07:22:11 <cheater> why?
07:22:12 <mauke> yeah, should be elsif
07:22:18 <cheater> no elif
07:22:26 <Cale> You can write  if foo then bar else if foo' then quux else fred
07:22:27 <mauke> elif? that's not even a word
07:22:27 <edwardk> cheater: what does it win you?
07:22:39 <mauke> edwardk: non-increasing indentation
07:23:01 <Cale> But once you start nesting ifs, you should really consider using guards
07:23:01 <edwardk> mauke use case () of _ | … -> …. ; … -> ….; and you can have as many as you want
07:23:03 <Cale> You can use case
07:23:07 <cheater> that if i do:
07:23:10 <Cale> like edwardk wrote :)
07:23:11 <cheater> if x
07:23:12 <cheater> then
07:23:15 <cheater>    bla bla
07:23:17 <cheater> else
07:23:19 <cheater>    bla bla
07:23:40 <edwardk> but you can drop an else if y and continue the pattern in there
07:23:42 <Cale> case () of
07:23:47 <Cale>  _ | x -> ...
07:23:57 <Cale>    | y -> ...
07:24:00 <Cale> etc.
07:24:13 <cheater> can i have if, then, and else in the same column?
07:24:17 * ddarius rarely uses if-then-else or case anyway.
07:24:21 <Cale> cheater: I tend not to do that
07:24:28 <cheater> why?
07:24:47 <Cale> cheater: You *can*, but inside a do-block it'll again be invalid in Haskell 98
07:24:59 <cheater> ok
07:25:00 <ddarius> My style follows what it would look like in languages with C-style syntax, except that there aren't braces.
07:25:01 <edwardk> cheater: yes and no. technically haskell 98 says you can't if its in a do block etc. there is an extension for NonDecreasingIndentation which allows the then to be on the same column as the do block it is in because some people find it unnatural
07:25:06 <Cale> Because the 'then' and 'else' are on separate lines of the do block
07:25:15 <Cale> instead of being a continuation of the same line
07:25:15 <ddarius> edwardk: Haskell 2010 includes that extension.
07:25:52 <edwardk> sadly it _DOESN'T_ enable this same optimization for text inside ( )'s  [ ]'s or { }'s which I've always found silly
07:25:53 <Cale> Personally, I think the NonDecreasingIndentation thing is ridiculous and should never have been included in H2010
07:26:21 <edwardk> i like it for parens braces and brackets
07:26:22 <Cale> Also, I think tab characters should be completely disallowed from Haskell source.
07:26:39 <Cale> (Maybe not even in comments)
07:26:49 <Kaidelong> and I immediately find use for "deriving Eq"
07:26:54 <Kaidelong> (writing quickcheck tests)
07:26:56 <cheater> ok so i indent "then/else" once and then indent the body of the then and else again?
07:27:01 <edwardk> lets you use c style braces with the { one on the same line an the closing one all the way outdented, no 'floaty braces' like you have to use in haskell today
07:27:18 <Cale> cheater: Usually the thing inside the 'then' and 'else' is part of that line...
07:27:25 <edwardk> cheater: or just keep the same indentation from there
07:27:27 <Cale> if known name
07:27:34 <Cale>    then putStrLn ...
07:27:38 <Cale>    else putStrLn ...
07:27:42 <cheater> aha
07:27:57 <ddarius> http://hpaste.org/51732
07:28:10 <c_wraith> You know, none of this would be an issue if "if" wasn't syntax. :)
07:28:10 <Cale> ddarius: I don't like that...
07:28:15 <mauke> putStrLn $ if known name
07:28:19 <mauke>   then ...
07:28:22 <mauke>   else ...
07:28:48 <ddarius> c_wraith: Instead we'd have different issues.
07:29:27 <cheater> ok, how do i return a value from a do block now?
07:29:51 <hpaste> Cale annotated “C v. Haskell” with “Other options” at http://hpaste.org/51732#a51733
07:30:14 <hpaste> ddarius annotated “C v. Haskell” with “C v. Haskell (annotation)” at http://hpaste.org/51732#a51734
07:30:14 <cheater> iteration = do x <- getLine; doStuff;                 loop = do iteration; loop
07:30:22 <Cale> cheater: The result of a do-block is the result of its last line.
07:30:29 <mauke> loop = forever iteration
07:30:38 <cheater> i want to do something like:         loop = do x <- iteration; loop
07:30:45 <hpaste> edwardk annotated “C v. Haskell” with “C v. Haskell (annotation)” at http://hpaste.org/51732#a51735
07:30:50 <ddarius> Cale: I think you adequately demonstrate why I prefer my version.
07:30:56 <Cale> ddarius: ?
07:31:12 <ddarius> Cale: Though I do use a style like that for smaller things.
07:31:38 <mauke> cheater: that is literally valid code
07:31:39 <Cale> I like my versions :)
07:31:45 <edwardk> I tend to write things using a combinator rather than case when I need the multiple |'s but otherwise that is my preferred form
07:31:46 <Cale> Everything lines up tidily
07:31:46 <Kaidelong> is there a library somewhere with common tests for functions?
07:31:59 <Cale> It's more important that it all lines up than what the indentation level is
07:32:05 <Kaidelong> like so that I can write propKleeneAndAssociative = associative (<&&?>)
07:32:10 <edwardk> the main issue i have with that is that the condition often changes so you have brittle layout
07:32:24 <edwardk> Kaidelong: i think conal has one
07:32:24 <ddarius> Cale: All the sub-blocks in my example line up.
07:32:42 <Cale> True.
07:33:11 <Cale> ddarius: I guess I'm thinking of 'if' almost as if it were a layout keyword
07:33:21 <ddarius> Cale: Why?
07:33:25 <cheater> how do i make "x" the result of the last line? (my "iteration" is more complex)
07:33:46 <ddarius> And if it was, you'd have to line up with the beginning of (p x).
07:33:53 <Cale> So the then and else "statements" inside it are required to be aligned. I know that it's not really the case, but it's a self-imposed rule :)
07:34:15 <Cale> Oh, I suppose that's true.
07:34:20 <Cale> I often do that as well.
07:34:24 <ddarius> Cale: I can't see why you'd take that position and also not like NonDecreasingIndentation.
07:34:46 <Cale> NonDecreasingIndentation makes the rule for indentation more lax.
07:34:56 <Cale> I'm imposing extra conditions on what's valid :)
07:35:07 <cheater> <- NonDecreasingConfusion
07:35:20 <Cale> cheater: hehe
07:35:38 <Cale> cheater: Okay, well, do you have some condition now on whether or not you loop?
07:35:39 <cheater> so what about that last line? i assign x long before the last line
07:35:53 <cheater> Cale: not yet, but that's not the important bit
07:36:10 <hpaste> “Eduard - Gabriel Munteanu” pasted “λ and SKI in Agda” at http://hpaste.org/51736
07:36:14 <Cale> (also, you're not assigning to x, the variable x is just the name for the result of that action)
07:36:27 <Eduard_Munteanu> I guess you need typelevel nats to do that in Haskell ^
07:36:28 <cheater> yeah, but it's easier to say "assigning to"
07:36:33 <Cale> cheater: Well, it is important, because as it stands, your loop will never finish, and the IO action never returns a result.
07:36:46 <Cale> Just making sure you know :)
07:36:49 <cheater> Cale: i'm fine with that
07:36:54 <Cale> Well, you can write:
07:36:55 <ddarius> At any rate, the point of my layout is that if you rub out the braces of the C and the 'then', 'do' of the Haskell, you get -exactly- the same layout.
07:37:07 <Cale> loop = do x <- iteration; loop; return x
07:37:14 <Cale> but the "return x" is dead code
07:37:14 <cheater> wait
07:37:27 <cheater> that's the wrong place
07:37:33 <cheater> i want *iteration* to give out x
07:37:38 <Cale> ?
07:37:43 <Cale> I don't understand.
07:37:50 <cheater> you guys said to do that i need to make x the last result of iteration
07:37:58 <mauke> wat
07:38:07 <cheater> however my iteration looks like this: iteration = do x <- stuff; do_something
07:38:13 <Cale> Okay, let's take a couple steps back because I don't understand what you're trying to do.
07:38:23 <Cale> What program are you trying to write? :)
07:38:31 <cheater> and my loop looks like: loop = do iteration; loop
07:38:47 <cheater> and i need the value of iteration's x inside loop's do block
07:39:24 <cheater> just read the last 3 lines Cale :-) this is the simplest explanation i think
07:39:36 <Eduard_Munteanu> I should look if I can do what nooodl wanted using reflection, might be a neat exercise.
07:40:33 <Cale> cheater: Well, this is all very general...
07:40:43 <elliott_> Eduard_Munteanu: I did it with some typeclasses, if we're thinking about the same thing. It was suboptimal though.
07:40:47 <Cale> cheater: You're trying to write a program that builds up a list of names?
07:40:50 <elliott_> Don't think ddarius ever did tell me whether his needed the signatures though :P
07:40:54 <cheater> yeah Cale
07:41:04 <Cale> okay
07:41:07 <Cale> so ...
07:41:32 <Cale> Instead of just being
07:41:38 <Cale> loop = do stuff; loop
07:41:41 <Cale> you'll have:
07:41:43 <Eduard_Munteanu> elliott_: hm, using peano stuff?
07:41:52 <Cale> loop names = do stuff; loop (f names)
07:41:56 <Eduard_Munteanu> (erm, fake dependent types)
07:42:04 <Cale> (very abstractly still)
07:42:16 <elliott_> Eduard_Munteanu: http://hpaste.org/51730
07:42:20 <cheater> Cale: yeah i know
07:42:23 <Cale> But the idea being that you can apply the loop to a different list of names to continue with.
07:42:25 <elliott_> It's rather incomplete, but it's a skeleton.
07:42:36 <Cale> This loop still doesn't ever terminate though
07:42:37 <cheater> Cale: however, the input is received inside stuff
07:42:43 <Cale> mhm
07:42:57 <cheater> Cale: i need that input to be returned from stuff to loop.
07:42:59 <Cale> loop names = do input <- stuff; loop (f names input)
07:43:11 <cheater> and how do i emit input from stuff?
07:43:16 <Cale> To be completely concrete...
07:43:32 <ben> Sounds like you need an iteratee 8)
07:43:34 <Cale> loop xs = do print xs; x <- getLine; loop (x:xs)
07:43:37 <Cale> ^^ try that
07:43:37 <Eduard_Munteanu> elliott_: ouch yeah... this stuff looks a bit painful to do in Haskell :)
07:43:52 <cheater> Cale: no, i want to stay with the old structure
07:43:57 <cheater> Cale: i know this would work.
07:44:06 <cheater> but now i want to return a value from stuff.
07:44:16 <Cale> ghci> loop []
07:44:16 <Cale> []
07:44:16 <Cale> Hello
07:44:16 <Cale> ["Hello"]
07:44:16 <Cale> World
07:44:17 <Cale> ["World","Hello"]
07:44:35 <cheater> Cale: i know that this works
07:44:38 <Cale> okay...
07:44:41 <cheater> Cale: but i want something else to work
07:44:55 <Cale> Okay, what is it that you want the program to do in English?
07:45:03 <cheater> what i wanted to find out is how to return a value from inside of stuff
07:45:13 <cheater> never mind what the program should be doing
07:45:21 <Eduard_Munteanu> cheater: return as in break a loop?
07:45:25 <cheater> the purpose of the program is that i learn how to return values from stuff.
07:45:26 <Cale> I don't understand
07:45:34 <cheater> no, as  in:
07:45:37 <Cale> What do you mean "return a value"?
07:45:39 <cheater> i have two functions:
07:45:44 <Cale> If the loop keeps running, it can't return a value.
07:45:45 <cheater> loop = do stuff; loop
07:46:00 <mauke> <Cale> cheater: The result of a do-block is the result of its last line.
07:46:10 <mauke> that's how
07:46:11 <cheater> stuff = do x <- getLine; do_other_stuff;
07:46:32 <cheater> now i want to get the value of x inside loop:
07:46:47 <cheater> loop = do x <- stuff; something_else x; loop
07:47:00 <Cale> loop xs = do print xs; x <- getLine; if x == "end" then return xs else loop (x:xs)
07:47:24 <cheater> mauke: i have read that and then i have asked how to make the result of the last line of "stuff" the value of "x" which it gets in the first line
07:47:31 <Cale> x scopes over the remainder of the do-block and can be used anywhere there
07:47:41 <mauke> cheater: that makes no sense
07:47:46 <cheater> Cale: that is not useful to me because i need to stay with the structure that consists of "loop" and "stuff"
07:47:58 <cheater> let me pastebin the code that i have now
07:48:04 <mauke> cheater: no time travel
07:48:05 <Cale> cheater: ... yeah, that's probably a good idea
07:48:13 <Cale> I don't understand what you mean to do.
07:48:37 <Eduard_Munteanu> cheater: do you have an example from other languages, say C?
07:48:45 <elliott_> Does ghc open /dev/tty or something? 2>&1 >log still spews -ddump-splices output to my terminal.
07:48:54 <Cale> Or imperative pseudocode would be fine :)
07:49:03 <mauke> elliott_: >log 2>&1
07:49:11 <elliott_> mauke: oh, duh
07:49:20 <elliott_> so inelegant :{
07:49:49 <Cale> elliott_: It makes sense in a bizarre way if you know how the shell does things from right to left
07:50:01 <Cale> But I always get bitten by that as well
07:50:24 <elliott_> This is what happens when you let C programmers design interfaces. (OK, the Bourne shell was practically written in PasCal, what with those weird BEGIN/END macro things, but.)
07:50:55 <cheater> Eduard_Munteanu: function loop(A){ stuff(); loop(A) }      function stuff() {x = getline(); do_other_stuff() }                       i want to do function loop(A) { y = stuff(); loop(A) }
07:51:08 <cheater> Eduard_Munteanu: i need to know how to do this.
07:51:56 <Cale> cheater: stuff will return the result of whatever the last action in it is.
07:52:01 <elliott_> loop xs = stuff >> loop xs
07:52:15 <Cale> 'return' is a function which takes a value and gives an action which does nothing except to return that value
07:52:17 <elliott_> Which is equivalent to loop = const (forever stuff)...
07:52:18 <Eduard_Munteanu> Yeah, you're ignoring 'y' there.
07:52:25 <elliott_> Oh, I see, "y = stuff()".
07:52:41 <Eduard_Munteanu> elliott_: I mean he's ignoring 'y' anyway
07:52:43 <elliott_> Right.
07:52:55 <cheater> Cale: *HOW* ??!?!?!? do i make the last line's result x?
07:53:07 <cheater> ok, return
07:53:10 <Cale> function stuff() {x = getline(); do_other_stuff(); return x }
07:53:13 <Cale> yeah?
07:53:17 <elliott_> stuff = do x <- getline; do_other_stuff; return x
07:53:20 <cheater> however, i tried return x, and it didn't work
07:53:23 <Cale> hum
07:53:28 <cheater> let me try again.
07:53:31 <Cale> Well, let's see your actual code...
07:53:39 <mauke> and your actual error
07:53:39 <Cale> You were going to hpaste it?
07:54:08 <cheater> ah yes! it worked now
07:54:13 <Cale> okay :)
07:54:18 <cheater> i wonder why it didn't work before? that was literally the first thing i did!
07:54:22 <cheater> and also the second thing i did
07:54:26 <cheater> wow this is crazy
07:54:31 <cheater> thanks a lot for leading me onto that
07:54:32 <Cale> You had to know why it would work first.
07:54:37 <Cale> :)
07:54:54 <cheater> i remember having read that return is just an identity function
07:55:03 <Cale> It's not quite
07:55:08 <cheater> and i tried to apply that
07:55:18 <cheater> well, something-like an identity function
07:55:23 <mauke> not really
07:55:23 <Cale> (Well, it's an identity in a weird category)
07:55:39 <Cale> It takes a value, and makes from it an action that does nothing except return that value.
07:56:16 <Eduard_Munteanu> For real monads, return is subject to an identity law.
07:56:17 * ddarius does not find Kleisli categories weird.
07:56:35 <merijn> Cale: "...for all sane definitions of return" </disclaimer> ;)
07:56:37 <Cale> ddarius: They're probably weird to normal people ;)
07:56:47 <Eduard_Munteanu> (However, Haskell doesn't check that)
07:56:54 <Cale> So you can also use it to construct a no-op action in the case that you want to do nothing.
07:57:00 <cheater> ohhhh, i see why it doesn't work
07:57:03 <Cale> return ()  tends to be good for that
07:57:20 <merijn> Eduard_Munteanu: I've been informed that haskell monads aren't proper monads anyway. I was told they're more like comonads
07:57:22 <Cale> return () in the middle of a do-block won't have any effect.
07:57:35 <Cale> merijn: Whaaaaat.
07:57:38 <elliott_> merijn: wat
07:57:39 <Cale> merijn: That's a lit
07:57:40 <Cale> lie*
07:58:34 <cheater> http://pastebin.com/CbFbwWeA
07:58:35 <mauke> The paste CbFbwWeA has been copied to http://hpaste.org/51737
07:58:57 <dmwit> cheater: more parens
07:58:58 <Cale> cheater: That parses as  (loop new_name):friends
07:59:03 <dmwit> loop (new_name:friends)
07:59:05 <cheater> oh
07:59:12 <merijn> Cale: Someone in here told me the category theory comonads were like haskell monads and vice versa...
07:59:15 <Cale> Because function application binds more strongly than any infix operator
07:59:24 <cheater> man this is annoying!
07:59:26 <cheater> ok
07:59:27 <cheater> :)
07:59:28 <Cale> merijn: Whoever said that has no idea what they're talking about
08:00:07 <Cale> cheater: It's important to remember that return is not special syntax
08:00:54 <Cale> cheater: It's just a function like any other function, so you have to parenthesise its argument if it's a compound thing.
08:01:49 <cheater> :)
08:01:50 <ddarius> Cale: So now I'm weird too?
08:01:57 <cheater> perfect explanation, Cale!
08:02:03 <zachk> cheater here http://pastebin.com/arUBanjL
08:02:05 <mauke> The paste arUBanjL has been copied to http://hpaste.org/51738
08:02:07 <zachk> you still have a problem though
08:02:08 <Eduard_Munteanu> merijn: they're strong monads, if that's what you heard.
08:02:32 <cheater> zachk: yeah, just parentheses :)
08:02:33 <zachk> you have no way to get the list out of the loop
08:02:37 <merijn> Eduard_Munteanu: I'm not discounting the possibility that I heard an idiot talking :)
08:02:57 <zachk> that is syntaxual , this is a problem of logic and flow
08:03:18 <elliott_> Syntaxual is a nice word.
08:03:29 * zachk thanks ewe 
08:03:31 <ddarius> merijn: Modulo some technicalities, and only if the monad laws hold, Haskell monads are categorical monads.
08:03:50 <merijn> zachk: I don't see where/why you would need to get the list out of the loop in this example?
08:04:04 <ddarius> merijn: Haskell monads don't capture the general idea of categorical monads, they are a specialization in many ways, but neither do Haskell functions capture the general idea of functions.
08:04:17 <zachk> why put data into a program if you cant get data out of it
08:04:28 <zachk> furthermore there is no termination conidtion to the loop
08:04:32 <zachk> condition
08:04:43 <merijn> zachk: That is only an issue if you insist on your program terminating...
08:04:44 <ddarius> (And actually, Haskell functions are -not- even specializations of functions if interpreted naively.)
08:04:46 <Cale> zachk: Well, the loop might run forever, performing both input and output.
08:04:50 <elliott_> merijn: If you don't, then why pass the list at all
08:04:52 <elliott_> You can just use forever
08:05:03 <merijn> elliott_: He is using the list to simulate state
08:05:05 <zachk> cheater: what do you want to do with the list of names?
08:05:10 <elliott_> merijn: hmm, oh
08:05:15 <elliott_> awkward
08:05:20 <Cale> It's just the standard thing...
08:05:21 <Eduard_Munteanu> ddarius: because they can be "partial" via undefined?
08:05:22 <merijn> elliottt: New names get added at the list and thus are "known" on the next iteration
08:05:24 <ddarius> No one seems to be saying that Haskell functions aren't functions though.
08:05:35 <ddarius> Eduard_Munteanu: That they can be partial via anything.
08:05:46 <Eduard_Munteanu> Yeah, any bottomness.
08:05:49 <Cale> The way in which the program continues depends on the list, so it's a parameter to the function that constructs that action.
08:05:53 <elliott_> merijn: I'm a different elliott, only one t :)
08:05:58 <cheater> zachk: just append it. so far, I have got everything figured out.
08:06:04 <merijn> elliott_: Curse tab-completion >.>
08:06:09 <Cale> That's an independent things from whether or not the program terminates.
08:06:12 <Cale> thing*
08:06:15 <elliott_> merijn: Try ordering it by last-spoke.
08:06:30 <merijn> elliott_: My IRC client is not that fancy
08:06:44 <elliott_> merijn: Oh jeez, why??
08:07:11 <merijn> elliott_: Using Opera's builtin IRC client because I can't be arsed to find a good cross-platform one when this one suffices
08:07:32 <elliott_> My condolences.
08:07:40 <Cale> X-Chat is good
08:08:00 <merijn> I don't even have a "/ignore" so I've learned to become "zen" and suppress my flame/anger instincts in the brain instead of client ;)
08:08:12 <Eduard_Munteanu> BTW, do you guys use proportional fonts for IRC?
08:08:16 <Cale> nope
08:08:30 * hpc => droid sans mono
08:08:37 <merijn> Eduard_Munteanu: Nope, I think I'm using Helvetica or something
08:08:46 <sm> edwardk: those recent parser blog posts are pretty cool - thanks
08:08:49 <Eduard_Munteanu> I see. I thought that might be an advantage to using a GUI client
08:09:00 * Eduard_Munteanu uses irssi and DejaVu Sans Mono anyway
08:09:05 <edwardk> sm: =)
08:09:11 <merijn> Eduard_Munteanu: Wait, I meant yes. I'm an idiot >.>
08:09:30 <edwardk> i'm trying to get gll parsing packaged up nice enough to put up as well
08:09:33 <Eduard_Munteanu> Right, Helvetica is proportional.
08:09:40 <sm> very clear, even if the higher-order details go a bit beyond me right now
08:09:45 <merijn> Eduard_Munteanu: Also means I have nice unicode support
08:09:55 <Eduard_Munteanu> merijn: how so?
08:10:11 <Eduard_Munteanu> Well, I guess monospaced fonts aren't usually good at unicode.
08:10:34 <Eduard_Munteanu> (and some glyphs may look odd)
08:10:46 <ddarius> merijn: So the client has helped you grow as a person.
08:10:50 <Taejo> Haskell's HTTP library sends multiple Cookie: headers but Django doesn't accept them :(
08:10:50 <merijn> Eduard_Munteanu: Well, I don't think there are many fonts with more unicode glyphs then helvetica (with all the typography designers wanking over it)
08:10:55 <elliott_> Eduard_Munteanu: i do
08:11:06 <Cale> 日本語で書く
08:11:33 <ddarius> edwardk: I like how the reference to the GLL paper is a reference to a 262 page proceedings.
08:11:36 <merijn> ddarius: Yes, it's working too. I've become much better at "letting go" of my tendency to correct stupidity ;)
08:11:49 <Eduard_Munteanu> I wonder if there's any way to make the terminal / irssi use proportional fonts properly.
08:11:49 <Cale> Eduard_Munteanu: You get different spacing, but it's locally-monospaced :)
08:11:51 <edwardk> ddarius: hah
08:12:05 <edwardk> i think there is a smaller file version of it around as well, but i lost it
08:12:08 <ddarius> edwardk: There are some other interesting papers in the proceedings though.
08:12:13 <Cale> I think gnome-terminal does it okay
08:12:22 <Cale> But I don't know whether it interacts nicely with irssi or not
08:12:37 <ddarius> merijn: I can /ignore people, but I never have.  My view is if I get to the point where I think /ignoring someone is the best thing to do, I'll probably just leave.
08:12:46 <Eduard_Munteanu> Ah, rxvt-unicode. Last time I tried to use proportional fonts, I got weird spacing.
08:12:53 <ddarius> merijn: Admittedly, I've always been quite good at ignoring things.  Ask my mother.
08:12:58 <Taejo> Cale: your Japanese shows up fine in irssi with gnome-term
08:13:03 <Cale> Taejo: cool
08:13:10 <Taejo> ISTR having problems with right-to-left, though
08:13:18 <Cale> Yeah, that's likely
08:13:21 <Eduard_Munteanu> I can read that too.
08:13:22 <ddarius> My choice of a bold font makes complicated kanji difficult to read.
08:13:26 <Eduard_Munteanu> (erm, see it)
08:14:10 <merijn> ddarius: Get mad! (╯°□°）╯︵ ┻━┻
08:14:21 <Taejo> أحب هاسكل
08:14:41 <merijn> Taejo: What's that? Looks like Arabic?
08:14:44 <Cale> It takes a little doing, but you can set up fontconfig to prefer certain fonts for kanji
08:14:48 <Taejo> merijn: yeah
08:15:04 <Eduard_Munteanu> merijn: what's that?
08:15:05 <Taejo> I think gnome-terminal is rendering it backwards though
08:15:39 <Cale> I have mine set up to use MS Gothic, which has nicely bitmapped kanji at small sizes that I find a lot more readable than the antialiased-to-shit versions available in some other fonts.
08:15:49 <merijn> Eduard_Munteanu: It's supposed to be a guy flipping over a table in anger
08:15:54 * Eduard_Munteanu should try Helvetica in Agda.
08:16:07 <Eduard_Munteanu> Ah. I've seen that around before.
08:16:22 <merijn> Eduard_Munteanu: Probably because you procrastinate on reddit? :p
08:16:48 <ddarius> merijn: Cale uses it a lot.
08:17:01 <Cale> fsvo a lot
08:17:06 <Eduard_Munteanu> Heh, no, I don't visit reddit often, I've seen it in here I think.
08:17:15 <ddarius> And edwardk also used it in a paste a while back.
08:17:40 <Cale> If you play/watch a lot of SC2, you'll probably have seen it. :P
08:17:41 <merijn> Eduard_Munteanu: I don't anymore, I've had to blacklist it in /etc/hosts to get any work on my master thesis done :>
08:17:48 <Eduard_Munteanu> Heh.
08:17:53 * ddarius has never seen SC2.
08:18:09 <ddarius> No, I take that back.
08:18:10 <edwardk> this one? http://hpaste.org/51474
08:18:14 <Taejo> does anyone else find that when GHC suggests "Possible fix: add an instance declaration for ...", that that's usually *not* the right solution?
08:18:15 <Cale> It's a really entertaining game to watch.
08:18:15 <ddarius> I have briefly seen it.
08:18:23 <ddarius> edwardk: Yes.
08:18:33 <ddarius> Taejo: That's well known.
08:18:38 <merijn> SC2 is pretty amusing to watch, I barely play at the moment, but I love watching professional games casted by day[9] and Tastosis
08:18:40 <Eduard_Munteanu> Damn, Emacs gives me really large vertical spacing on some characters.
08:18:42 <Cale> edwardk: rofl
08:18:57 <Taejo> ddarius: shouldn't the suggestion be removed, then?
08:19:29 <edwardk> I still to find a role for zoidberg in that play. (\/)(o,,o)(\/)
08:19:38 <ddarius> Taejo: Then all of us would have to learn to translate a new error message.
08:19:57 <ddarius> edwardk: Does that require TupleSections?
08:20:00 <edwardk> yeah
08:20:28 <elliott_> hmm, where are tuple sections used?
08:20:28 <merijn> Need a new Haskell infix operator?
08:20:29 <merijn> Why not (\/)(;,,,;)(\/)
08:20:36 <edwardk> (o,,o)
08:20:44 <edwardk> its a triple with the middle one missing
08:20:47 <elliott_> oh
08:20:47 <Eduard_Munteanu> ʘ_ʘ = id   -- heh, reads like "as himself"
08:20:49 <elliott_> not in http://hpaste.org/51474 though
08:20:50 <elliott_> right
08:20:55 <ddarius> merijn: That doesn't look anything like Zoiberg.
08:20:57 <ddarius> +d
08:21:13 <edwardk> merijn: because i can't use the ;'s
08:21:36 <cheater> hey guys, why is this broken?
08:21:37 <cheater> http://pastebin.com/hwt4qZN8
08:21:38 <mauke> The paste hwt4qZN8 has been copied to http://hpaste.org/51739
08:21:48 <merijn> ddarius: I have one more comma then the one I originally saw, which makes it a bit to wide I see, but other then that I see a resemblence
08:21:52 <cheater> i realise i should be using Just, but i want to use an example like this to illustrate something
08:21:56 <elliott_> then/else clauses must have a do inside
08:22:00 <edwardk> i had to subtitute 彡  into  (╯°□°)╯ 彡 ┻━┻  as well because ︵ isn't a letter or operator
08:22:02 <elliott_> you cannot just use do notation from inside without a do block
08:22:14 <elliott_> then the second problem is that they must end with an expression which "the_output <- ..." is not
08:22:31 <elliott_> but the_output can be removed entirely
08:22:38 <elliott_> edwardk: heh
08:22:43 <elliott_> edwardk: I like 彡 more
08:22:48 <merijn> Yeah, unicode is pretty great: ☃
08:23:28 <edwardk> it started when i suggested that copumpkin use ಠ_ಠ as the operator for his unafe thunk inspection operator
08:23:28 <ddarius> merijn: The eyes are too small.
08:23:54 <Eduard_Munteanu> cheater: you can't bind the_output like that
08:24:06 <elliott_> unsafe thunk inspection... that would be useful
08:24:16 <Eduard_Munteanu> cheater: you can use the_output <- if known name friends [...]
08:24:27 <cheater> Eduard_Munteanu: aha, how do i make the do block return different values?
08:24:27 <cheater> hmm
08:24:46 <elliott_> Eduard_Munteanu: but the_output is totally unnecessary
08:24:53 <elliott_> just remove the return line and "the_output <-" in both branches
08:24:59 <Eduard_Munteanu> Sure.
08:25:17 <hpaste> elliott annotated “root” with “root (annotation) fixed” at http://hpaste.org/51739#a51740
08:25:23 <Eduard_Munteanu> I wonder what it'd take to bind names inside expressions like that in Haskell.
08:25:29 <elliott_> That might have other problems, but it doesn't have the problem in question.
08:25:44 <Eduard_Munteanu> It reminds of the goto monad discussion
08:25:46 <cheater> Eduard_Munteanu: so: the_output <- if ,,, then putStrLn ...; ""; else putStrLn ...; name         ?
08:26:35 <Eduard_Munteanu> cheater: you have to use return
08:26:53 <Eduard_Munteanu> Or do like elliott_ says and skip "the_output" altogether
08:26:53 <Cale> cheater: The values you put inside 'then' and 'else' still have to be single values
08:27:06 <alpounet> putStrLn "foo" >> return name
08:27:11 <Cale> So you may have to use 'do' to compose a complete action if you want to do more than one thing
08:27:13 <elliott_> the_output seems completely pointless here; even if you transform it before returning you can do that as a "where"-clause mapping function.
08:27:31 <elliott_> So there's no reason to keep it at all, the end-the-function-on-the-condition solution is much better.
08:30:01 <ski> Eduard_Munteanu : Erlang allows such bindings
08:31:44 <ski> (and of course it got it from Prolog)
08:32:36 <Eduard_Munteanu> The only thing close in Haskell is using STRefs I guess.
08:34:05 <ddarius> Eduard_Munteanu: It would be quite easy in Haskell to make write-once variables or logic variables.
08:35:39 <ddarius> There are three stages in a variable's life: declaration, binding, and evaluation.
08:35:48 <ddarius> Haskell combines the first two.
08:36:20 <ddarius> Separating the first two is usually a key step in making a concurrent system, as in the blue calculus.
08:36:52 <Eduard_Munteanu> Presumably you could avoid separating them as well.
08:37:13 <linduxed> can someone explain to me what flip does?
08:37:35 <linduxed> "takes two arguments and reverses the order of them"
08:37:44 <Eduard_Munteanu> The compiler would have to check the binding is reachable from all possible path, and possibly give it a more complex type (in case you bind stuff from different types).
08:37:54 <linduxed> so why doesn't one just write them flipped?
08:37:55 <rwbarton> flip takes a function and reverses the order of its (first) two arguments
08:37:56 <Eduard_Munteanu> :t flip
08:37:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:38:09 <Eduard_Munteanu> :t Prelude.flip
08:38:10 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:38:22 <linduxed> rwbarton: yeah, i've read that, but it doesn't really... say much to me
08:38:33 <linduxed> could you give me an example of use?
08:38:48 <rwbarton> > flip (++) "abc" "xyz"
08:38:50 <lambdabot>   "xyzabc"
08:38:59 <Eduard_Munteanu> > let (\) = flip (/) in 2 \ 6
08:39:00 <lambdabot>   <no location info>: parse error on input `)'
08:39:14 <Cale> > sortBy (comparing length) (words "here is a bunch of words")
08:39:15 <lambdabot>   ["a","is","of","here","bunch","words"]
08:39:19 <Eduard_Munteanu> Bah. :)
08:39:21 <Cale> > sortBy (flip (comparing length)) (words "here is a bunch of words")
08:39:23 <lambdabot>   ["bunch","words","here","is","of","a"]
08:40:18 <Cale> > comparing length "here" "bunch"
08:40:19 <lambdabot>   LT
08:40:25 <Cale> > comparing length "bunch" "here"
08:40:26 <lambdabot>   GT
08:40:35 <linduxed> hmmm i think i get it now
08:40:35 <Cale> > flip (comparing length) "here" "bunch"
08:40:37 <linduxed> thx
08:40:37 <lambdabot>   GT
08:43:57 <applicative> linduxed, if you are actually writing down the arguments, there is indeed no reason to use flip.
08:44:06 <ski> Eduard_Munteanu : you should read CTM
08:44:27 * ddarius agrees with ski.
08:45:23 <Eduard_Munteanu> ski: CTM?
08:45:27 <ski> @where CTM
08:45:27 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
08:45:36 <Eduard_Munteanu> Ah, thanks.
08:45:57 <linduxed> applicative: haha, you know it's kinda funny
08:46:23 <linduxed> applicative: i've been off to code java for a month now, had to be away from haskell due to school
08:46:38 <linduxed> applicative: so i forgot the concept of currying completely
08:46:39 <Eduard_Munteanu> It's not available for free, no?
08:47:04 <linduxed> applicative: that's what it's called right? using a function with a fraction of its arguments?
08:47:16 <linduxed> like "take 1"
08:47:24 <linduxed> and alling it takeOne
08:47:28 <linduxed> *calling
08:47:59 <ddarius> linduxed: Currying is what curry does.
08:47:59 <applicative> that's currying, right, the concept is a little unclear of course
08:48:04 <Kaidelong> so should I implement a new Kleene data type
08:48:13 <Kaidelong> or have it as a newtype over Maybe Bool
08:48:40 <applicative> right, like ddarius says, the function 'curry' takes a function from pairs and makes it a two place function, crudely put
08:48:40 <ddarius> Eduard_Munteanu: A draft form was provided for a while.
08:48:46 <applicative> @type curry
08:48:47 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
08:48:52 <elliott_> Kaidelong: Shouldn't matter much if you don't expose the constructor.
08:49:12 <Kaidelong> I guess I could just expose the values
08:49:41 <Kaidelong> kTrue, kFalse, etc
08:49:46 <Kaidelong> kUnknown
08:50:12 <applicative> linduxed, but I was thinking the point of flip shows up with 'point free' combinations of expressions, where you precisely arent 'writing out the arguments'
08:50:34 <franny> I imagine it would be hard to search for documentation on the "curry" function by Googling "haskell curry." :)
08:50:42 <cheater> hey guys, how do i do the same using Maybe instead of empty strings? http://pastebin.com/dVMAH0Wk
08:50:44 <mauke> The paste dVMAH0Wk has been copied to http://hpaste.org/51741
08:51:03 <Kaidelong> naaah I'm going to be exposing the constructors anyway
08:51:06 <Kaidelong> I mean
08:51:10 <Kaidelong> you would just be able to go
08:51:21 <Kaidelong> read "Kleene (Just True)"
08:51:59 <cheater> i think i can do return Nothing and return Just name
08:52:10 <cheater> however, how do i check if my value is Nothing?
08:52:18 <cheater> if value == Nothing ?
08:52:44 <Kaidelong> @hoogle Maybe a -> Bool
08:52:45 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
08:52:45 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
08:52:45 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
08:52:51 <Eduard_Munteanu> :t maybe
08:52:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:53:02 <Kaidelong> @ty isNothing
08:53:03 <lambdabot> forall a. Maybe a -> Bool
08:53:08 <Kaidelong> @ty (==Nothing)
08:53:09 <lambdabot> forall a. (Eq a) => Maybe a -> Bool
08:53:16 <mreh> quicksilver: I'm just heap profiling to plug a space leak, also looking at your code, you had some problems with keyboard and mouse input leaking, couldn't you explain a little what was going on there?
08:53:17 <rwbarton> case value of Nothing -> ...; Just new_friend -> ...
08:56:12 <cheater> @src isNothing
08:56:12 <lambdabot> isNothing Nothing = True
08:56:12 <lambdabot> isNothing _       = False
08:57:10 <cheater> where do i find isNothing?
08:57:21 <glguy> Data.Maybe in nowhere else
08:57:22 <parcs> Data.Maybe
08:57:26 <glguy> if*
08:57:29 <cheater> thanks
08:57:58 <sshc> How can a cabal package be marked as deprecated, like monads-fd?
08:59:00 <parcs> by asking the
08:59:06 <cheater> ok, what am i doing wrong? http://pastebin.com/vMvzhTtA
08:59:08 <parcs> maintainer of hackage, i think.
08:59:20 <cheater> i am getting an error at the line with the cons
08:59:37 <parcs> dude pastebin sucks
08:59:41 <cheater> just by the very end
08:59:47 <ski> @index isNothing
08:59:47 <lambdabot> Data.Maybe
08:59:49 <ski> cheater ^
08:59:50 <parcs> i have to fill out a captcha just to look at your paste
09:00:00 <cheater> ski: yeah found that out now :)
09:00:05 <cheater> parcs: oh, sorry..
09:00:21 <ski> just pointing out the `index' command often helps ..
09:00:26 <cheater> i think it only does that for just one visitor
09:00:37 <rwbarton> it happened to me too
09:00:41 <parcs> that's retarded either way
09:00:41 <cheater> ski: yeah, i remembered there was something, but forgot what it was :)
09:00:49 <rwbarton> anyways you don't want isNothing, because you need the value in the Just case
09:00:55 * ski . o O ( `matches :: (forall a. Eq a => Eq (f a)) => (forall a. f a) -> (exists a. f a) -> Bool' )
09:00:58 <rwbarton> use 'case' or possibly 'maybe'
09:02:06 <ski> (or plain pattern-matching in multiple equations)
09:02:20 <monochrom> actually, in this case, we already have the value
09:03:42 <monochrom> oh, I see, it's "iteration" that returns a Maybe
09:03:53 <sshc> How can a maintainer of a package mark it as deprecated, like monad-fd?
09:04:21 <parcs> he can't. he ask to ask the maintainer of hackage to do so
09:04:26 <parcs> has*
09:06:11 <sshc> Ah.
09:06:24 <sshc> (I misread your first answer; thanks.)
09:10:37 <sshc> I've just started reading http://www.haskell.org/haskellwiki/Enumerator_and_iteratee .  It looks like iteratee can't give the enumerator any intermediate results
09:11:40 <sshc> So, if I'm, for example, traversing a 2-dimensional grid, and the enumerator needs to have some result from the iteratee to know which adjacent position it should go to next, then…
09:12:00 <sshc> I don't think I could use iteratee as it currently is?
09:12:55 <hpaste> applicative annotated “root” with “root (annotation)” at http://hpaste.org/51741#a51743
09:13:19 <applicative> ^^^ cheater, like this?
09:13:28 <cheater> just noticed.. looking
09:13:33 <cheater> sorry it takes a few secs to load
09:13:37 <cheater> my internet is slow
09:14:10 <cheater> ok, sounds cool
09:15:13 <cheater> @hoogle Maybe a -> Just a
09:15:13 <lambdabot> Did you mean: Maybe a -> Maybe a /count=20
09:15:13 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
09:15:13 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
09:15:52 <parcs> sshc: don't think so
09:16:18 <sshc> parcs: Mm.  ARe you aware of an alternative I could use?
09:16:28 <nooodl> is this a decent place to ask questions about SKI combinators/lambda calculus, that aren't really haskell-related? :/
09:16:50 <sshc> Perhaps I could propose a patch
09:17:21 <ski> nooodl : probably ..
09:17:39 <monochrom> yes it's a decent place. just make clear your code is not haskell
09:18:52 <nooodl> well, i've got a function, λx.λy.x, which i know transforms to just "K" using combinators
09:19:45 <nooodl> i'm writing a program that converts lambda expressions to combinators using Schonfinkel's mappings (see http://c2.com/cgi/wiki?EssAndKayCombinators)
09:20:28 <nooodl> the only one i can fit this function into is "\x.c = (K c)", which makes it (K λy.x). that doesn't make sense
09:20:59 <nooodl> wait. i just realized how i have to do it. *punches self*
09:21:27 * ski smiles
09:21:42 <nooodl> i just have to evaluate λy.x first...
09:22:05 <sshc> Can the IO action given to withFiles safely close the handle itself?
09:22:07 <tsousa> is haskell a good language to start contribuiting to opensource?
09:22:12 <nooodl> and then λx.(K x) = x by rule four :)
09:22:24 <monochrom> heh yeah
09:22:34 <nooodl> (errm, K, not x)
09:22:49 <parcs> sshc: yah
09:23:00 <sshc> (Callinsg hClose on an already closed handle is a no-op, right?)
09:23:04 <sal23> I am grepping for Prelude Monad class definition in ghc 7.2.1 libraries source code but don't see any. Where should I be looking? I am grepping under /libraries
09:23:05 <monochrom> yes
09:23:08 <parcs> iteratees are an alternative to lazy io. why do you want to use iteratees to traverse a 2d grid?
09:23:21 <parcs> sshc: i think that's an exception
09:23:49 <ski> nooodl : after you've made it, try to make it single-pass
09:24:04 <hpc> sal23: you might have luck trying "locate Prelude"
09:24:07 <hpc> in a terminal
09:24:22 <monochrom> "Performing hClose on a handle that has already been closed has no effect; doing so is not an error." from GHC's System.IO doc
09:24:33 <nooodl> ski, no recursion? yikes
09:24:57 <sshc> parcs: I have a lot of different folds, and all the different combinations and repeated code is pretty messy.  I'm only starting to learn about iteratees, but I think they could help me factor out common patterns and make the code much more elegant.  But I need the
09:25:23 <monochrom> also from Haskell 2010 Report
09:25:29 <ski> nooodl : well, recursion of course, but only traverse expression once (as opposed to : first translate children, then (in some cases) traverse the translated children)
09:25:42 <sshc> parcs: I have a lot of different folds, and all the different combinations and repeated code is pretty messy.  I'm only starting to learn about iteratees, but I think they could help me factor out common patterns and make the code much more elegant.  But I need the iteratees to give intermediary values to the user of the iteratee (some of them)
09:25:49 <monochrom> this is Haskell not Java, afterall
09:26:00 <monochrom> but no one reads the doc or me
09:26:06 * ski used folds for the recursion, but explicit recursion should also work
09:26:22 <parcs> anyway not even iteratees can reliably close a handle for you
09:26:31 <ddarius> And yet monochrom keeps speaking.
09:26:34 <sshc> monochrom: Ah, I see.  Thanks.
09:26:41 <ddarius> (or I guess I should say "writing.")
09:26:43 <sshc> monochrom: I read it but somehow missed that part
09:27:03 <sshc> parcs: Nono, those questions about handles were completely unrelated (and much less important; I was only curious)
09:28:12 <monochrom> Java's draconian requirement of close-only-once is extremely frustrating
09:28:40 <sshc> That's really nice (about hClose)
09:28:54 <nooodl> woah. is (S(KS)K) equal to (λfx.f(fx))
09:28:55 <c_wraith> clearly, you just need to wrap all closeable objects in a wrapper that ignores subsequent calls to close
09:28:56 <sshc> parcs: The current mess of accumulating folds is pretty messy
09:29:09 <sal23> hpc: None of Prelude.hs have Monad class declaration. Looking for source that has Monad class and function signatures like here: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad
09:29:10 <sshc> parcs: It desparately needs abstraction and factoring
09:29:38 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad
09:29:40 <cheater> cool, so today i have covered IO and Maybe
09:29:41 <hpc> sal23: ^
09:29:46 <cheater> and recursion
09:29:51 <cheater> and basic monadic operators
09:30:17 <nooodl> arr, it isn't.
09:30:22 <hpc> oh, the lhstex-to-html formatting on that link i just posted is broken
09:30:23 <sal23> hpc: got it. thanks for help
09:30:24 <hpc> (
09:30:28 <hpc> (http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad)
09:30:33 <cheater> and i wrote notes that are 32K
09:30:34 <sshc> Iteratees being able to give intermediary values would solve this problem, I think.  I suppose I should learn about them first.
09:30:37 * sshc reads the documentation
09:30:42 <cheater> now i need to do something like uh..
09:30:50 <cheater> read from and write to a file
09:31:01 <hpc> :t readFile
09:31:02 <lambdabot> FilePath -> IO String
09:31:04 <hpc> :t writeFile
09:31:05 <lambdabot> FilePath -> String -> IO ()
09:31:13 <cheater> nice
09:31:20 <cheater> is FilePath just a string?
09:31:25 <cgroza> cheater: yes
09:31:29 <cheater> nice
09:31:33 <cheater> that's splendid
09:31:36 <cheater> thanks guys
09:32:22 <hpc> cheater: also http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#g:2, is a more controllable way to play with files
09:32:33 <hpc> (and other stuff like network handles)
09:32:34 <ski> @type (ap (const ap) const) `asTypeOf` \f -> \x -> f (f x)
09:32:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
09:32:35 <lambdabot>     Probable cause: `x' is applied to too few arguments
09:32:35 <lambdabot>     In the first argument of `f', namely `x'
09:32:59 <ion> edwardk: There seem to be spurious spaces within some operators in the code at <http://comonad.com/reader/2011/a-parsec-full-of-rats/>. Also, s/\<juse\>/just/
09:33:15 <ion> edwardk: Very nice article.
09:33:18 <hpc> :t ap (const ap) const
09:33:18 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a) -> b1 -> b
09:33:23 <cheater> i just need something simple
09:33:31 <hpc> :t \f -> f . f
09:33:32 <lambdabot> forall b. (b -> b) -> b -> b
09:33:36 <edwardk> yeah i can't fix the spaces. its done by my blog software. you can find the original code linked. and ill fix that typo
09:35:34 <hpc> holy dependencies, batman! trifecta is kind of huge
09:35:49 <edwardk> yeah
09:35:54 <cheater> hpc: what were you refering to specifically in that link? that just links to the page not a specific function
09:36:01 <edwardk> its growing larger too
09:36:06 <hpc> cheater: that whole section
09:36:17 <cheater> ok :)
09:37:18 <hpc> by "that section", i apparently mean "from there to the bottom of the page"
09:37:36 <hpc> go with the readFile/writeFile stuff first, then learn your way around handles
09:37:36 <cgroza> ocaml
09:39:10 <applicative> trifecta isn't a parsing library, it's a parsing 'framework'...
09:39:42 <edwardk> the main goal with trifecta is to give you all the usual crap you usually build on top of or around your parsers
09:39:56 <Amagineer> How do I get a list of all globally cabal-installed packages?
09:40:11 <applicative> well, ghc-pkg list
09:40:25 <applicative> Amagineer: but that won't tell you which cabal installed
09:41:32 <ddarius> edwardk: By that do you mean the crap people usually don't build at all?
09:41:51 <applicative> Amagineer: if you do 'ghc-pkg list' the first group of things is registered globally in the file mentioned.  If you are using the Haskell Platform they should probably all be the platform libraries
09:41:59 <edwardk> well some of it ;)
09:43:32 <applicative> edwardk you say you will put iteratees in too later
09:43:57 <applicative> but edwardk which library, Iteratee, Enumerator or IterIO, or ...
09:44:13 <monochrom> all of them!
09:44:14 <sshc> Mm.  Perhaps I can use edwardk's reducers library instead of iteratees
09:44:48 <dolio> Trifecxta has its own iteratees.
09:44:48 <edwardk> well, i currently plan to just build something like parsec or attoparsec which doesn't care about iteratees and can just use one as the underlying text supply
09:45:02 <edwardk> and trifecta supplies its own style of iteratees at present, called It.
09:45:10 <edwardk> which do something subtly different
09:45:24 <edwardk> those are what i use for incremental parsing at present
09:45:29 <dolio> Yeah. They're actually not just a reimplementation for the nth time, for a change.
09:45:40 <applicative> ah, i see, in the post you were leaving it to the reader as an exercise
09:45:43 <cheater> hpc: nice, so i would just do withFile and then inside somewhere I would do hPutStrLn ?
09:45:46 <edwardk> yeah
09:45:57 <hpc> :t withFile
09:45:57 <lambdabot> Not in scope: `withFile'
09:46:01 <edwardk> the post was just an introduction to the fact that packrat parsing doesnt' have to be rocket science
09:46:01 <ddarius> dolio: They're an incompatible reimplementation for the nth time.
09:46:09 <hpc> yeah, pretty much
09:46:11 <edwardk> and can mix in with traditional parsing combinator approaches
09:46:16 <ddarius> edwardk: Who thought it was?
09:46:36 <edwardk> ddarius: well, you get things like frisby which explicitly don't have a monad
09:46:39 <ddarius> At any rate, parsers are no where near hypergolic enough.
09:46:40 <edwardk> and offline tools like pappy
09:46:54 <edwardk> which make them seem harder than they are
09:47:00 <ddarius> There were monadic parser combinators provided as a library by Ford.
09:47:06 <cheater> niiiice
09:47:10 <applicative> edwardk, not having known anything about it, so far it is seeming a little like rocket science.
09:47:22 <cheater> ok, let's wind this up a bit
09:47:34 <monochrom> cheater: withFile "output.txt" WriteMode (\h -> hPutStrLn h "hello")
09:47:39 <cheater> i want to get the lines of a Handle, each line on a separate string.
09:47:42 <ddarius> The Mercury paper, in my opinion, does a better job of making it not seem like rocket science.
09:48:03 <cheater> monochrom: yep!
09:48:07 <edwardk> hah i just saw the Parse monad on Ford's site. funny how i never tripped over it before
09:48:15 <applicative> or rather, it is presupposed that the reader knows what packrat parser are.
09:48:55 <applicative> the Mercury paper?
09:49:09 <dolio> ddarius: None of the other implementations are 'compatible.'
09:49:51 <ddarius> Packrat parsers, recursive descent + memoization.
09:50:21 <dolio> That's why there's all kinds of 'foo-iteratee' vs. 'foo-enumerator' packages.
09:50:27 <applicative> i see it
09:50:32 <dolio> And then iterIO which bakes all those in.
09:50:46 <applicative> foo-iterio foo-trifecta
09:51:56 <edwardk> yeah
09:52:02 <applicative> I expect my iteratee library to have build in compression combinators and to get webpages for me!
09:52:42 <ddarius> Only suckers get web pages themselves.
09:53:14 <edwardk> my main problem with the iteratee libraries is that half of them omit the cps transform which is needed to make them not suck in the presence of left associated binds and the other half muck themselves up trying to thread some crazy monad through
09:53:19 <dolio> At least Ed has the excuse that the existing iteratee libraries don't actually do what he wants.
09:53:26 <edwardk> rather than letting an external monad _drive_ the iteratee
09:53:37 <dolio> Instead of just putting the same thing in different modules with different names.
09:53:39 <edwardk> and the iteratees i use in trifecta are very different than traditional iteratees
09:53:43 <sshc> edwardk: I have a two-dimensional grid / array of elements of a specific typeclass.  Currently, I have a large, messy combinations of different folds that fold in different directions, different ways, with different ways of reducing / folding and when to stop.  Iteratees seems insufficient for this, because they can't give callers any intermediary values, so, if I'm traversing this 2-D grid,
09:53:49 <sshc> folding values / creating an accumulator as I go, I might need indemediary values from the iteratee to know which adjacent cell I should go to next.  So, if I *didn't* have this requirement (using intermediary results from the iteratee), would "iteratee" be good for this?  Also, with that requirement, could I use "reducers" to this end?  Are you aware of any library that abstracts this pattern of
09:53:55 <sshc> folding?  In any case, I always need to be ablo to stop "folding" at some point and return an accumulator immediately.
09:54:26 <ddarius> The history of iteratees is making a simple idea complex.
09:54:34 <edwardk> sshc: amusingly my It type works for that
09:54:45 <hpc> ddarius: haha
09:54:59 <xvilka> hi! i want try to port GHC on some non-POSIX system. Do I really need OpenGL for building?
09:55:10 <monochrom> no
09:55:19 <hpc> xvilka: are you looking at the platform?
09:55:27 <xvilka> hpc: yes
09:55:36 <sshc> edwardk: Great!  Where is this?
09:55:41 <hpc> the platform is GHC plus a crapton of libs
09:55:52 * applicative has broken completely with *traditional* iteratees
09:55:56 <ddarius> The Haskell community is horrible at naming things, and I'm not talking about monads (which weren't named by the Haskell community anyway.)
09:56:18 <hpc> xvilka: the information you need is somewhere here, i think: http://haskell.org/ghc/
09:56:25 <cheater> who was the name "monad" made by then ddarius
09:56:42 <applicative> xvilka, what system are you going to bring the Glorious GHC to?
09:56:44 <edwardk> sshc: its buried in trifecta
09:57:13 <xvilka> applicative: KolibriOS: written purely on ASM :)
09:57:24 <xvilka> hpc: thx
09:57:25 <Cale> ddarius: What do you mean? :)
09:57:33 <applicative> wow, good luck!
09:58:11 <applicative> cheater, 'monad' is due to Mac Lane, who else would have been so wacky
09:58:53 <applicative> 'standard construction' and 'triple' etc weren't greek enough for him.
09:59:03 <cheater> aha
09:59:03 <xvilka> applicative: thx. will try this crazy task :)
09:59:09 <cheater> who is Mac Lane?
09:59:09 <dolio> Those are both pretty terrible names.
09:59:16 <BMeph> @remember  ddarius The history of iteratees is making a simple idea complex.
09:59:16 <lambdabot> Okay.
09:59:19 <hpc> i like 'monad'
09:59:21 <edwardk> It r a is about asking questions about input that grows monotonically. newtype It r a = Pure a | It a (r -> It r a) -- gives you whether or not the iteratee might change its answer given more input, and in either case access to the result if the input were to stop changing now
09:59:21 <cheater> and yes they are :|
09:59:28 <hpc> it's just cryptic enough to terrify newbies for no good reason :P
09:59:30 <merijn> xvilka: Also, there's a #ghc channel devoted to hacking GHC, they can probably help you with the details of GHC and the runtime system
09:59:46 <applicative> @google saunders mac lane
09:59:47 <lambdabot> http://en.wikipedia.org/wiki/Saunders_Mac_Lane
09:59:47 <lambdabot> Title: Saunders Mac Lane - Wikipedia, the free encyclopedia
10:00:08 <cheater> does he hang out here
10:00:12 <Cale> cheater: Mac Lane is an algebraic topologist responsible for many of the fundamental definitions in category theory.
10:00:12 <edwardk> applicative: actually the name was coined by JP May
10:00:28 <applicative> he was aping mac lane
10:00:33 <Cale> actually, I should say "was", he died in 2005.
10:00:45 <edwardk> applicative: he disliked the name triples, and wanted to call something an 'operad', so he talked maclane into changing the name to monad
10:00:46 <dolio> You might as well just call them "algebras" although I guess that's more overloaded.
10:00:51 <ddarius> Mac Lane is usually considered one of the creators of category theory.
10:01:11 <Cale> Yeah, along with Eilenberg
10:01:28 <cheater> that is pretty cool to know
10:01:32 <edwardk> applicative: http://www.math.uchicago.edu/~may/PAPERS/mayi.pdf
10:01:39 <applicative> no account that doesnt go by way of Mac Lane is credible,
10:01:43 <cheater> hmm, ok, so
10:01:48 <cheater> i know how to get a line from a file
10:01:53 <edwardk> The name “operad” is a
10:01:53 <edwardk> word that I coined myself, spending a week thinking about nothing else. Besides
10:01:53 <edwardk> having a nice ring to it, the name is meant to bring to mind both operations and
10:01:53 <edwardk> monads. Incidentally, I persuaded MacLane to discard the term “triple” in favor of
10:01:53 <edwardk> “monad” in his book “Categories for the working mathematician” [17]
10:01:54 <edwardk> 1
10:01:54 <cheater> and i know how to check EOF
10:02:03 <cheater> how do i put those lines in a list?
10:02:14 <sshc> edwardk: That's great!  Have you considered isolating it in a separate library?
10:02:24 <applicative> that doesn't entail that the word is due to may
10:02:27 <sshc> Of course, then there would be the problem of having two standards for iteratees
10:02:34 <hpc> cheater: you can use recursion
10:02:47 <ddarius> At least he doesn't talk about "colored operads."
10:02:53 <applicative> it could mean, "Don't worry, Saunders M., go for it!"
10:02:59 <merijn> edwardk: Pssh, as if mathematicians work :p
10:03:08 <edwardk> *shrug* mac lane is dead, and he is closer to the situation than either of us, so in the absence of a direct claim to the contrary I see no need to doubt his word
10:03:09 * merijn runs and hides
10:03:10 <hpc> linesOfFile h = do line <- hGetLine h; lines <- linesOfFile h; return (line:lines)
10:03:14 <hpc> cheater: ^ or something like it
10:03:15 <cheater> hpc: hm yeah
10:03:24 <hpc> probably need an hIsEOF in there
10:03:38 <xvilka> merijn: thx
10:03:39 <applicative> Saunders said to me "Am I going crazy, I feel like calling them monads.... I guess I should stick to triples"
10:03:53 <sshc> edwardk: ALso, wouldn't it be better to add a third paramater for intermediary values and replace the "a" after the It constructor with that paramater?
10:03:55 <applicative> I said to him, "No Saunders, go for it."
10:04:03 <dolio> Why are you inventing hypothetical scenarios for this?
10:04:06 <edwardk> sshc: i'm not currenly looking to break up trifecta. the main problem is that doing so makes my life harder and annoys people when i spam hackage
10:04:19 <edwardk> sshc: no, because there is no way to compute it generally
10:04:21 <cheater> if i do it like this, and call linesOfFile h, then will the next line after linesOfFile h have the handle h rewound to where it wa before i called linesOfFile?
10:04:30 * applicative will ask sawodey
10:04:31 <cheater> or will the handle still be at EOF?
10:04:39 <sshc> Mm, I could probably use a pair.
10:04:43 <edwardk> what you want is an extra value. use a WriterT of it or something
10:04:53 <Cale> cheater: Another way is just to apply the lines function to the contents of the file
10:04:57 <hpc> cheater: the handle will still be looking all the way at the end of the file
10:05:09 <edwardk> applicative: i merely present the evidence that i have.
10:05:09 <sshc> edwardk: What's the standar iteratee libraary?
10:05:19 <cheater> Cale: hmm how?
10:05:19 <edwardk> sshc: no idea
10:05:19 <Cale> > lines "hello\nthere\nworld"
10:05:19 <cheater> lines
10:05:19 <lambdabot>   ["hello","there","world"]
10:05:19 <cheater> let me try that
10:05:21 <hpc> what Cale said works too; lines <$> hGetContents h
10:05:25 <edwardk> sshc: in my humble opinion they all suck
10:05:30 <hpc>  :: IO [String]
10:05:39 <edwardk> but for different reasons
10:05:42 <Cale> Yeah, or  fmap lines (readFile foo)
10:05:45 <Cale> things like that :)
10:05:54 <ddarius> Don't listen to edwardk.  He has no humble opinions.
10:05:59 <edwardk> hahahah
10:06:09 <applicative> edwardk, i accept it of course; my claim should have been more complicated, about the role of Mac Lanes book in spreading the expression, which the May remark supports
10:06:11 <merijn> It's true though
10:06:14 <dolio> Maybe it means that May came up with "monad" and then kidnapped MacLane and held him in a CIA-style brain washing camp for a week until he had broken his will.
10:06:15 <edwardk> the opinions themselves are humbe. the person who holds them however, is not.
10:06:28 <monochrom> I listen to edwardk precisely because he has no humble opinions!
10:06:37 <edwardk> hah
10:06:40 <merijn> I read the iteratee paper and I was all like "will, this sounds easy and makes sense" then I looked at the libraries and I didn't understand a single one of them >.>
10:06:52 <edwardk> merijn: and therein lies the problem
10:06:58 <merijn> s/will/well
10:07:20 <hpc> i thought "oh, i can learn iteratees, then enumerators"
10:07:23 <edwardk> i don't really see the point of monadic iteratees
10:07:30 <sshc> merijn: "iteratee" and "enumerator"?
10:07:32 * applicative is in fact waiting for a truly lucid iteratee library before he plumps for the new messiah
10:07:32 <hpc> then saw that both were dependent on each other in silly ways
10:07:38 <Cale> A nice thing about mathematics is that often the real history doesn't matter. It can always be revised into the most concise history we can figure out.
10:07:38 <merijn> sshc: Yeah
10:07:42 <edwardk> the whole point of them was to separate them from the driver, then that goes and shoves it right back inside!
10:07:51 <applicative> mutually recursive plagiarism?
10:07:52 <ddarius> Cale: ...
10:07:55 <merijn> Damn, that probably means I'll have to implement my own if I want a good iteratee library...
10:08:25 <merijn> Cale:  That goes for all history :>
10:08:31 <sshc> edwardk: Which libraries *do* support that? (where "that" is intermediary values)
10:08:55 <sshc> edwardk: Do you know whether I can do that with iteratee or enumerator?
10:09:13 <edwardk> sshc: well, the 'intermediate values can always be obtained by just feeding the iteratee an empty input and reading back the response, then continuing on with the iteratee you had before you fed it nothing
10:09:15 <applicative> in seeking the origin of an expression or idea we are usually seeking the origin of its meme-character, which will always have causes that can be called the 'true origin'
10:09:41 <edwardk> so you don't need to really do anything special to support reading out the intermediate state as you run an iteratee
10:10:27 <edwardk> enumerator is one of the versions of iteratees that didn't get the memo about cps transformation
10:11:10 <edwardk> the It type I use in trifecta also doesn't cps transform, but I have a justification
10:11:11 <dolio> Only iteratee got the memo.
10:11:12 * ddarius doesn't see why Stop 'n Shop needs to put little price stickers on everything.
10:11:19 <dylukes> CPS transformation?
10:11:20 <nooodl> ski, i think this does it in one pass. (beware, not haskell!) http://paste.pocoo.org/show/481751/
10:11:41 <edwardk> and that is that i only use inside of a small cps'd loops in parser so i don't have badly assoiated binds to deal with
10:12:00 <applicative> merijn, just make sure you are up-to-date with whatever Oleg's latest 'implementation' is before plumping for whatever one came before it
10:12:03 <edwardk> dylukes: if you don't cps yout iteratee implementation then using left associated >>='s becomes excessively expensive
10:12:06 <nooodl> the great thing is i did it like this from the start
10:12:13 <dylukes> I see
10:12:23 <sshc> edwardk: Do you mean giving a Next iteratee a value that the iteratee always specially handles to return Done?
10:12:28 <sshc> edwardk: Why don't you like iteratee?
10:12:29 <edwardk> dylukes: It r in trifecta doesn't cps transform, but the parser monad does
10:12:30 <ddarius> Why are people "plumping?"
10:12:51 <applicative> plumping? going for?
10:13:32 <edwardk> sshc: no. i mean just take your result iteratee, call it m. feed m an empty input getting n, and get the current answer from n, then to continue with more input by feeding it to _m_ not n.
10:13:43 <sshc> edwardk: I suppose that could work, but it might be sort of inelegeant since it's not intrinsically guaranteed by its structure (it'd have to fail / error if the iteratee should return Done but returns antoher iteratee)
10:14:26 <ski> ddarius : .. which Mercury paper were you thinking of ?
10:14:43 <edwardk> feeding it the empty input forces it to give you the current answer it would give if there is no more input
10:15:26 <edwardk> alternately you can make your own version that bolts an extra sofar value on the Cont constructor but you then need to make up monadi actions to update it, etc.
10:15:34 <ddarius> ski: http://www.mercury.csse.unimelb.edu.au/information/papers/packrat.pdf
10:15:43 <edwardk> i liked that paper
10:16:29 <edwardk> i ony started playing with packrat in parsec because i was looking at bolting packrat into trifecta for offline parsing
10:16:40 <edwardk> and i wanted some nice way to talk about memoized parsing rules
10:17:07 <edwardk> and i also wanted to play with packrat style memoization because i'm working on gll using a similar memoization strategy
10:18:40 <sshc> edwardk: What is the empty input?  An input that always forces an iteratee to return Done?  According to the definition of Iteratee in http://www.haskell.org/haskellwiki/Enumerator_and_iteratee , it seems that there isn't a guaranteed to be such an empty input (although then there would never be a way to return Done, so that'd be somewhat useless; but *getting* an "empty input" is difficult)
10:18:57 <Amagineer> What's the proper/accepted way to install a package with cabal-install globally? Does it involve running cabal update as root? or is there a way to use my package list?
10:19:27 <applicative> cabal install --global
10:19:35 <applicative> but dont do it
10:19:37 <edwardk> sshc: this is one of my many complaints about the current iteratee design
10:20:06 <sshc> edwardk: Um, what exactly is?
10:20:09 <Amagineer> So then what should I do when I have a need for haskell libraries system-wide?
10:20:36 <edwardk> sshc: data Iter i a = Done a i | Cont (i -> Iter i a) is subtly wrong. oleg's iteratees had the ivariant that once you fed them EOF they had to stop returning Cont's but the data type doesn't enforce thi
10:20:41 <edwardk> er doesn't enforces this
10:21:18 <edwardk> so one way to ensure it is to add the 'a and i' parameters to Cont basically unpacking a copy of what the output _would_ be if no more input was present
10:21:29 <edwardk> but you don't want to include them both directly, coz if you do you may be too strict
10:21:32 <edwardk> so instead you want
10:21:44 <edwardk> data Iter i a = Done a i | Cont (a, i) (i - Iter i a)
10:21:53 <edwardk> er i ->
10:22:04 <edwardk> i just elide the output 'i'
10:22:29 <edwardk> and of course the usual approach bolts in some slightly redundant error handling machinery
10:23:01 <edwardk> eliding the output i is problematic for most iteratees because then how would you know where to resume the next one
10:23:24 <edwardk> in my approach, the input increases monotonically and the index into it is managed by something else
10:23:45 <edwardk> which is what i want when i'm letting something like parsec sit in the drivers seat, tracking my current cursor position as its input state
10:24:00 <applicative> Amagineer, I suspect you should make another package register up there, but I don't have the experience making an additional one in the global part.
10:24:16 <edwardk> this comes at the expense that the driver of It has to hold onto the entire input and keep resubmitting it
10:24:29 <edwardk> but this is both a blessing and a curse
10:24:45 <edwardk> since the bytestring based iteratee libraries waste a lot of time concatenating bytestring inputs
10:25:01 <edwardk> and because i hold onto it all i have to fingertree it
10:25:13 <applicative> Amagineer, other people must.  I mostly want to point out that there is an unpleasant possibility, e.g. of overwriting Haskell Platform packages, which makes a real hash of the ghc installation
10:25:51 <dankna> actually you can overwrite Haskell Platform packages no problem, it's the "base" packages that are used by GHC itself that cause trouble
10:25:56 * hackagebot pugs-compat 0.0.6.20110925 - Portable Haskell/POSIX layer for Pugs  http://hackage.haskell.org/package/pugs-compat-0.0.6.20110925 (AudreyTang)
10:26:04 <dankna> the ones that have hashes instead of version numbers in ghc-pkg list
10:26:30 <applicative> Amagineer: It is likely you are less prone to torching ghc installations than I am
10:26:38 <Amagineer> I mostly just want Xmonad or at least its dependencies installed globally
10:27:05 <applicative> danka, right, yes I was running it all together
10:27:10 <dankna> right
10:27:14 <dankna> sp dankna
10:28:31 <applicative> Amagineer: funny, I was just having that problem, I wanted an xmonad user and an 'applicative moron' user.  so I will wait for your solution
10:28:39 <Amagineer> I think I'll just resort to using pacman (I'm on archlinux) for global packages and only use cabal for the local stuff
10:30:42 <applicative> dankna, I wonder if I wasn't right to run them together a bit, everything in the platform-not-base that involves a binding to C libraries will probably not work if you over write it
10:30:56 <dankna> well, no, I don't see that
10:30:58 * hackagebot pugs-DrIFT 2.2.3.20110925 - DrIFT with pugs-specific rules.  http://hackage.haskell.org/package/pugs-DrIFT-2.2.3.20110925 (AudreyTang)
10:31:00 * hackagebot MetaObject 0.0.6.20110925 - A meta-object system for Haskell based on Perl 6  http://hackage.haskell.org/package/MetaObject-0.0.6.20110925 (AudreyTang)
10:31:02 * hackagebot HsParrot 0.0.2.20110925 - Haskell integration with Parrot virtual machine  http://hackage.haskell.org/package/HsParrot-0.0.2.20110925 (AudreyTang)
10:31:02 <dankna> pretty sure it will work in that situation
10:31:34 * ddarius will take this as Audrey is better.
10:31:37 <applicative> sorry, I meant to say, on Windows and OS X, where this torture is laboriously managed by our friends on the Haskell Platform Committee for Human Betterment
10:32:13 * applicative is still waiting for a leader like Audrey Tang
10:33:40 <ddarius> applicative: Read TAPL.
10:33:42 <edwardk> good to see audrey putting out code again
10:33:53 <edwardk> ddarius: hahahaha
10:34:14 <applicative> ddarius, does TAPL have to do with A Tang?
10:34:35 <ddarius> applicative: I will leave it as an exercise for you to figure that out.
10:35:01 * applicative meditates, suspecting it will be too hard
10:35:31 <bfig_> what do the {someFunction:: someSignature} means after a newtype declaration?
10:35:59 <bfig_> i'm trying to understand mT's and i'm stuck there
10:36:01 <rwbarton> it's not "after", it's the primary part of the declaration
10:36:08 <Cale> bfig_: It's record syntax, it defines a name for the field
10:36:14 <rwbarton> newtype X = X { fieldName :: Maybe Int }
10:36:16 <Cale> which auto-defines an extractor function
10:36:38 <Cale> So with the declaration rwbarton gave, you'll have:
10:36:44 <Cale> fieldName :: X -> Maybe Int
10:36:49 <applicative> not so hard to figure out i see. but where is the new messiah i am waiting for with A Mad Project I Can Believe In
10:36:50 <bfig_> so you can use a bind to use the type and extract it?
10:37:12 <Cale> It's analogous to something like:
10:37:24 <Cale> data Person = P { name :: String, age :: Integer }
10:37:33 <Cale> Where you then get:
10:37:38 <Cale> name :: Person -> String
10:37:43 <bfig_> and i can use  name >>= println ?
10:37:45 <Cale> age :: Person -> Integer
10:37:47 <cheater> :t hSeek
10:37:48 <lambdabot> Not in scope: `hSeek'
10:37:52 <bfig_> (inside the monad?)
10:37:53 <Cale> It's not an IO action, so no
10:37:58 <cheater> @ty hSeek
10:37:59 <lambdabot> Not in scope: `hSeek'
10:38:05 <Cale> Has nothing to do with IO or monads.
10:38:06 <cheater> hrm
10:38:15 <cheater> @src hSeek
10:38:15 <lambdabot> Source not found. I feel much better now.
10:38:20 <cheater> this is stupid :(
10:38:20 <ddarius> applicative: Probably fasting and getting thinner, whereas you seem to want him or her to be plumper.
10:38:38 <ddarius> @hoogle hSeek
10:38:38 <bfig_> where can i read about this declaration type?
10:38:38 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
10:38:47 <cheater> so guys, if I want to rewind my handle to the beginning, i do hSeek seekmode 0, yes?
10:39:07 <ddarius> @hoogle SeekMode
10:39:07 <lambdabot> System.IO data SeekMode
10:39:16 <ddarius> Thanks Hoogle.
10:39:37 <ski> @index hSeek
10:39:37 <lambdabot> System.IO
10:39:39 <ski> @tupe System.IO.hSeek
10:39:40 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Device.SeekMode -> Integer -> IO ()
10:39:55 <cheater> oh riiiiiight, seekmode sets that
10:40:03 <cheater> ok
10:40:18 <cheater> ski: @tupe? is that like @type?
10:40:29 <cheater> @type System.IO.hSeek
10:40:30 <lambdabot> GHC.IO.Handle.Types.Handle -> GHC.IO.Device.SeekMode -> Integer -> IO ()
10:40:46 <cheater> haha, funny!
10:40:53 <ski> yeah, only pronounced a bit differently
10:41:04 <ski> @botslap
10:41:04 <lambdabot> Unknown command, try @list
10:41:11 <ski> bah!
10:41:25 <ski> hm
10:41:26 <ski> @botsmack
10:41:27 <lambdabot> :)
10:41:41 <bfig_> Cale, where can i read about the declaration type?
10:41:44 <edwardk> @botsnack
10:41:44 <lambdabot> :)
10:43:40 <bfig_> @buttsnack
10:43:40 <lambdabot> :)
10:44:12 <jmcarthur> @buttsmack
10:44:12 <lambdabot> Unknown command, try @list
10:44:32 <bfig_> does that mean somebody programmed to respond to buttsnack? >_>
10:44:35 <bfig_> or jjust @snack
10:44:41 <bfig_> @abcdsnack
10:44:41 <lambdabot> Unknown command, try @list
10:44:46 <jmcarthur> i think it's just a little word distance algorithm
10:44:48 <bfig_> L_O_L
10:45:04 <jmcarthur> @bitsnack
10:45:05 <lambdabot> :)
10:45:10 <bfig_> @bomb
10:45:11 <lambdabot> Unknown command, try @list
10:45:13 <jmcarthur> @botsn0ck
10:45:13 <lambdabot> :)
10:45:20 <bfig_> @botsleek
10:45:20 <lambdabot> Unknown command, try @list
10:45:33 <applicative> @batsnack
10:45:33 <bfig_> i wonder what it's measuring against
10:45:33 <lambdabot> :)
10:45:35 <jmcarthur> @notsnot
10:45:36 <lambdabot> Unknown command, try @list
10:45:39 <jmcarthur> *botsnot
10:45:46 <jmcarthur> lol like lambdabot will see that
10:45:50 <jmcarthur> @botsnot
10:45:50 <lambdabot> Unknown command, try @list
10:46:01 <Cale> bfig_: It measures edit distance from known commands, I think
10:46:02 <jmcarthur> i guess it's two or fewer letters in distance or something
10:46:11 <jmcarthur> s/letters/edits/
10:46:13 <Cale> and if there's one with small enough edit distance, it auto-correct
10:46:14 <Cale> s
10:46:53 <applicative> @beetsnack -- very wholesome
10:46:53 <lambdabot> :)
10:47:55 <Cale> @bitsack
10:47:55 <lambdabot> :)
10:48:05 <applicative> @nonsnack
10:48:05 <lambdabot> :)
10:50:05 <ddarius> It will "correct" things with a Levenshtein distance of two or less.
10:50:52 <monochrom> @shape monochrom
10:50:53 * lambdabot hits monochrom with a hammer, so they breaks into a thousand pieces
10:50:56 * hackagebot Pugs 6.2.13.20110925 - A Perl 6 Implementation  http://hackage.haskell.org/package/Pugs-6.2.13.20110925 (AudreyTang)
10:52:19 <Cale> @get-shape monochrom
10:52:20 <lambdabot> shapr!!
10:52:22 <FredOverflow> Is there a two-argument version of fmap? That is, a Functor equivalent of liftA2 resp. liftM2? Hoogle "Functor f => (a -> b -> c) -> (f a -> f b -> f c)" only turns up those two.
10:52:42 <Cale> FredOverflow: impossible
10:53:05 <Cale> FredOverflow: If there is one, the functor is an Applicative.
10:53:11 <edwardk> FredOverflow: how would it work?
10:53:16 <Cale> (for any given functor)
10:53:24 <Cale> Er, well...
10:53:31 <Cale> If there's that and pure/return
10:53:44 <edwardk> cale: otherwise it is just an instance of Data.Functor.Apply ;)
10:53:53 <edwardk> (well, subject to some laws)
10:54:14 <FredOverflow> Damn, I just confused Functors with functions again :/
10:55:52 <applicative> FredOverflow: your hoogle query wasn't confused
10:57:07 <applicative> FredOverflow: but you wouldn't be able to define something of that type that was -- valid for all Functors -- using just fmap, which is all there is to Functor
10:58:33 <lbh> if i first install 'ghc' then install 'haskell-platform' can i remove 'ghc'?
10:58:53 <lbh> that is, does 'ghc' come with the haskell platform already?
10:59:19 <lbh> i know ghc is required to build the haskell platform.
10:59:54 <hpc> GHC comes with it
11:00:02 <applicative> lbh, it would with any rational package manager, and the Windows and OS X installers have both the libraries and the executables
11:01:40 * ddarius will not mention the fact that lbh has provided far too little information for his/her question to be properly answered.
11:01:42 <lbh> thanks. i am using a slackbuild (slackware package) to install ghc and then i'm building the haskell platform from source using it.
11:01:50 <applicative> lbh, so if you call ghc or ghci there is reason to think that it is the new ones installed with the platform that will come
11:01:58 <lbh> ddarius there you go
11:03:27 <applicative> lbh, it's okay, some of us are willing to make deductions from things as they appear.
11:03:47 <ddarius> s/deductions/guesses
11:03:59 <applicative> lbh, our method is to ask further questions.
11:04:13 * ddarius did not see any further questions asked.
11:04:20 <lbh> applicative i will try removing the slackware ghc package
11:04:32 <lbh> and see if it affects the haskell platform installation
11:04:36 <applicative> lbh, but why it sounds like its your ghc
11:04:37 <lbh> i hope slackware's package manager is sane
11:04:59 <lbh> well i thought haskell platform comes with ghc already
11:05:12 <ddarius> At any rate, I'd expect a 'haskell-platform' package in most package managers would simply be a package that depends on the 'ghc' package, so it would not make sense to remove 'ghc' after installing 'haskell-platform'.
11:05:24 <lbh> that was what i am concerned about
11:05:34 <applicative> lbh don't the rules fall to the ground with slackware.
11:05:42 <lbh> yeah
11:05:58 <applicative> where did you get the 'haskell platform' materials you are compiling yourself?
11:06:11 <FredOverflow> applicative: Ah, because I need <*> for liftA2, but Functor only has <$>?
11:06:13 <lbh> from http://hackage.haskell.org/platform/linux.html
11:06:45 <lbh> haskell-platform-2011.2.0.1.tar.gz
11:06:52 <lbh> requires ghc to build it
11:06:53 <Cale> FredOverflow: yeah, pretty much
11:06:58 <lbh> so i got ghc from slackbuilds.org
11:07:16 <applicative> FredOverflow: right, though further things could be said
11:07:20 <Cale> FredOverflow: and if you had liftA2, you could write (<*>) = liftA2 id
11:08:12 <applicative> lbh, yes, not that the tarball linked there is just the libraries not the ghc. also, I think, the cabal executable and things like that
11:09:10 <applicative> so I think if you compile those things you are putting yourself in the position of someone who asked his package manager for 'haskell-platform'
11:09:37 <lbh> aahh
11:10:13 <lbh> thanks. us slackfriends don't have a package manager unfortunately
11:10:28 <lbh> i can't wait to start programming in haskell
11:10:53 <applicative> if everything is compiling, then you've done it by hand. note the instructions on installing by hand linked a little further down the page, from monochrom's website
11:11:20 <monochrom> thank you for choosing monochrom!
11:11:23 <tensorpudding> running slackware, aka doing it the hard way
11:11:29 <Cale> lbh: Do what I do on Ubuntu, download the GHC generic linux binary
11:11:38 <Cale> lbh: and then download cabal-install
11:11:46 <siracusa> Given a ThreadId value, is there a way to check if the corresponding thread is still alive?
11:11:48 <Cale> http://haskell.org/ghc/download_ghc_7_0_4#x86linux
11:12:01 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz
11:12:20 <lbh> monochrom's website is good
11:12:30 <Cale> there's a bootstrap.sh script you can run inside the cabal-install tarball to get it running
11:12:39 <KptnKrill> \q
11:12:44 <lbh> cabal-install is like apt-get?
11:12:52 <Cale> lbh: For Haskell packages, yeah
11:12:59 <lbh> nice!
11:13:12 <Cale> It's like cpan/ctan/etc.
11:13:27 <Cale> http://hackage.haskell.org/package/ -- list of packages
11:13:30 <monochrom> not like apt-get. no uninstall. no auto-install of c libs
11:13:51 <lbh> i'll try your suggestion Cale
11:13:57 <monochrom> cabal-install is a builder and a dependency chaser (confined to hackage)
11:14:36 <Jeanne-Kamikaze> why slackware when you have arch
11:14:56 <jmcarthur> yay distro wars
11:16:01 <lbh> they are trying to convert me
11:16:10 <lbh> oh noes
11:16:46 <ddarius> Anything is possible with monochrom.
11:17:13 <Jeanne-Kamikaze> the last time I checked, a dist upgrade on slackware required me to download a burn a cd, ala 400 BC style
11:17:41 <monochrom> Oleg writing an expression that Oleg can't type-check is possible with monochrom!
11:18:01 <monochrom> @quote oleg type-check
11:18:02 <lambdabot> No quotes match. :(
11:18:23 * applicative 's distro is better than yours 
11:18:36 <monochrom> @quote oleg.*type-check
11:18:37 <lambdabot> Jafet says: Can oleg create a term so complicated that even he could not type-check it?
11:18:40 <monochrom> hehe
11:19:08 <Jeanne-Kamikaze> as a side topic, what is your personal opinion on agda vs coq ?
11:19:44 <Jeanne-Kamikaze> I'm just curious about this proof assistant thing, and I was wondering which would be easier knowing some basic haskell
11:20:52 <applicative> the first question is incendiary.  the second question is easy, Agda
11:22:37 * ddarius doesn't think incendiary is incendiary enough.
11:22:50 <jacobian> I don't think it's all that incendiary
11:23:03 <jacobian> I think it's worth discussing advantages/disadvantages of the two
11:23:06 <Cale> Yeah, the Agda code I've seen looks much saner than the Coq code I've seen. Coq seems to have a ridiculous notation for lambda terms...
11:23:28 <jacobian> syntactically coq is pretty ugly
11:23:35 <Cale> (Probably because nobody was thinking of them as lambda terms when it was designed)
11:23:36 <jacobian> But it has a number of significant advantages
11:23:37 <applicative> fun z => ... ?
11:24:02 <jacobian> specifically, the ability to mix tactics and coding in coq is a lot more sophisticated.
11:24:03 <dolio> Coq is better if you want to write imperative proof scripts.
11:24:18 <ddarius> dolio: Who doesn't want to write imperative proof scripts?
11:24:29 <dolio> Me.
11:24:44 <Jeanne-Kamikaze> what about epigram ?
11:24:44 <dolio> They're useful if you're proving fancy mathematics, though.
11:24:47 * applicative would rather die than write an imperative proof script
11:24:47 <jacobian> I'm pretty convinced that can't be ok
11:24:57 <jacobian> I've written tactics that I would never code by hand
11:25:31 <copumpkin> these days, people write agda tactics too
11:25:37 <copumpkin> with great pain
11:25:40 <jacobian> the ability to write code that generates code to fill a type is useful
11:26:09 <copumpkin> but nothing about automating proofs says it has to be imperative
11:26:30 <jacobian> maybe coq doesn't do it the right way, but I think it's still currently a better way than exists in agda for some problems
11:27:02 <applicative> in coq, the ancillary representation you get as you go along of the available hypotheses etc, is incredibly helpful
11:27:15 <dolio> Anyhow, Agda is better as a dependently typed programming language, from what I can tell.
11:27:35 <dolio> Which, considering that was its goal, is probably not surprising.
11:27:39 <leod> can you actually use Agda to create programs or is it all proofs?
11:28:03 <dolio> Agda is a programming language.
11:28:22 <applicative> but the whole unrelenting orientation of everything to 'proof' is mind numbing. If I wanted to prove something, I would use pencil and paper.
11:28:28 <leod> interesting
11:28:29 <linduxed> seriously, my nick colouring script is not liking the name ve
11:28:46 <elliott_> leod: People have even written web frameworks in agda :P
11:28:49 <linduxed> so many hits :-P
11:29:08 <leod> elliott_: and they are proven to be correct web frameworks? :>
11:29:10 <dolio> If I wanted to compute something, I'd use pencil and paper.
11:29:27 <Cale> applicative: Not the fun thing, I'm referring to how proofs are composed with intro/apply, (if I'm recalling the names of things correctly)
11:29:33 <ddarius> dolio actually IRCs on paper.
11:30:15 <applicative> Cale, but those arent the actual 'code' exactly, but the commands you issue.
11:30:34 <applicative> Cale, or thats what I was understanding
11:30:35 <leod> is there an introduction to Agda for people who know almost nothing about dependent types?
11:32:00 <applicative> leod, there is a standard tutorial. there were some video lectures by C. McBride that were very helpful until de Bruijn indices came up....
11:32:12 <leod> okay
11:32:47 <cheater> wow this tutorial is 40 k
11:32:48 <cheater> nice
11:33:09 <applicative> leod there is also #agda of course
11:33:16 <leod> right
11:37:05 <applicative> leod, heres the videos, not bad http://www.youtube.com/view_play_list?p=44F162A8B8CB7C87  did you see the links on the wiki to tutorialish stuff http://wiki.portal.chalmers.se/agda/agda.php?n=Main.Documentation
11:37:30 <leod> applicative: thanks, will check it out
11:38:07 <applicative> there are also somewhere the .agda files he is working with, including exercises
11:38:41 <Jeanne-Kamikaze> ok thanks for the feedback
11:38:48 * ski inevitebly comes to think of "Syntax-rules Primer for the Merely Eccentric" and "An Advanced Syntax-Rules Primer for the Mildly Insane"
11:40:51 <geheimdienst> "Learn You a Haskell for the Thorougly Bananas"
11:41:06 <applicative> here's the link to the darcs source for the course materials http://personal.cis.strath.ac.uk/~conor/pub/dtp/
11:41:40 <Jeanne-Kamikaze> learn you a haskell is great man
11:42:16 <ski> preflex: xseen BONUS
11:42:16 <preflex>  BONUS was last seen on freenode/#haskell 147 days, 14 minutes and 22 seconds ago, saying: yeah i think that's better as well
11:42:29 <geheimdienst> "Burrito Primer for the Very Nuts"
11:45:59 <merijn> leod: I was going to write an intro on dependent types, but now that I understand them enough to write it, I no longer understand which part I didn't get >.>
11:46:16 <leod> heh :D
11:46:18 <elliott_> Where does cabal-install put its stock license files?
11:47:36 <merijn> leod: Seriously, I have no clue why I didn't get them. It took me like 5 months, so obviously its not like they're that intuitive, but now I literally don't know how to explain them because everything seems mostly obvious...
11:48:00 <leod> well, I'll see how it goes for me
11:48:04 <leod> hope it doesn't take 5 months though :p
11:48:20 <ddarius> Look at the lambda cube.
11:48:40 <geheimdienst> elliott_: not sure what you mean by "stock", but they seem to be alongside the haddocks on my system, e.g. ~/.cabal/share/doc/parsec-3.1.0/LICENSE
11:49:12 <tgeeky> geheimdienst: cabal-install will place the license of choice in your new repo
11:49:17 <tgeeky> geheimdienst: I think he's talking about that
11:49:19 <elliott_> geheimdienst: The ones "cabal init" creates.
11:49:20 <elliott_> Yeah.
11:49:27 <elliott_> I guess it's in some /share/ directory.
11:49:28 <tgeeky> elliott_: byorgey did that code, I think
11:49:33 <geheimdienst> oh i see
11:49:34 <tgeeky> elliott_: it's probably hardcoded in some script or file?
11:49:36 <merijn> leod: I can highly recommend the lambda cube paper "Introduction to Generalized Type Systems" by Barendregt
11:49:50 <leod> merijn: I'll check it out, thanks
11:49:54 <elliott_> tgeeky: probably
11:52:30 <tgeeky> http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/src/Distribution-License.html <-- there is where cabal has the list
11:52:34 <geheimdienst> elliott_: found 'em, they're in the cabal-install source in /Distribution/Client/Init/Licenses.hs
11:52:41 <elliott_> good timing :-)
11:52:44 <elliott_> thanks
12:16:22 <cheater> http://cheater.posterous.com/first-haskell-script
12:16:46 <parcs> cheater: why
12:16:48 <cheater> comments? :)
12:17:06 <cheater> parcs: because i was learning and needed to write it down?
12:17:19 <cheater> parcs: why not?
12:17:37 <copumpkin> wait, what? http://snapplr.com/9bex
12:18:26 <geheimdienst> copumpkin: i was right now choking on exactly that
12:18:49 <cheater> :)
12:19:09 <cheater> yeah, i'll correct this
12:19:30 <mreh> ping
12:19:40 <cheater> got any other things to point out?
12:20:23 <cheater> copumpkin :)
12:20:58 <geheimdienst> cheater: in the 1-2-3 list, there seem to be some things meant to be code with don't show in the white monospace font
12:21:16 <cheater> weird, i thought i fixed that
12:21:19 <parcs> is # treated as a comment delimiter when a file is invoked through runhaskell or something?
12:21:48 <cheater> no idea.
12:22:02 <geheimdienst> cheater: just reloaded, seems to be still there for me
12:22:02 <cheater> but it works.
12:22:07 <cheater> geheimdienst: yeah
12:22:18 <cheater> i'll try fixing that
12:22:24 <parcs> oh that's python
12:24:00 <geheimdienst> parcs: i think it's a special case. ghc is okay with the the first line being a shebang
12:24:04 <cheater> there is some of that here and there
12:24:28 <cheater> geheimdienst: i think so yes
12:26:01 <randig_troja> Is there any command that will supress warnings from ghci? I get annoying (and useless) warnings like these: http://pastebin.com/qVzv3zdC
12:26:03 <mauke> The paste qVzv3zdC has been copied to http://hpaste.org/51748
12:26:49 <merijn> randig_troja: Weird, must be something you did because I've never seen those...
12:27:01 <elliott_> randig_troja: Do you have -Wall in your ~/.ghci?
12:27:04 <elliott_> Or something along those lines?
12:27:05 <merijn> And I never tweaked anything in ghci
12:27:23 <randig_troja> I've installed the eclipsefp plugin gor eclipse.
12:27:51 <randig_troja> regular ghcisessions work fine, but in the eclipse console i get those default-type-warnings.
12:27:51 <cheater> that might have done it?
12:28:49 <cheater> any other problems you've spotted geheimdienst?
12:28:56 <rwbarton> probably eclipse runs 'ghci -Wall'
12:29:32 <geheimdienst> randig_troja: when i do ":set -Wall" in ghci, i get similar warnings for "1+2". so i guess you just need to say ":unset -Wall" in your problematic session
12:29:47 <rwbarton> ":set -Wnot" seems to turn it off...
12:30:01 <elliott_> ghci -Wall? eurgh
12:30:38 <randig_troja> :set -Wnot  worked! Thanks a lot! :)
12:32:20 <geheimdienst> cheater: looks good to me :) you might want to mention "main = forever blah" at some point, since i hear it's moar idiomatic than "main = blah >> main"
12:32:55 <geheimdienst> ... if you like. i guess it's not really important
12:32:59 <cheater> geheimdienst: that gets removed later for something else
12:33:17 <cheater> though tbh i don't want to confuse people with too much
12:33:29 <geheimdienst> sure, good thinking
12:33:38 <cheater> how would you fix this bit at the beginning with let x = 3?
12:34:58 <elliott_> It needs "do" after "in".
12:35:16 <geheimdienst> remove one of the indented "putStrLn x" lines
12:35:18 <elliott_> But putStrLn on a number is invalid anyway; "print" is more appropriate inside the let block.
12:35:26 <elliott_> geheimdienst: Or that, yeah, but it still won't type
12:35:36 <elliott_> Well, unless you do instance Num String :P
12:35:47 <geheimdienst> elliott_: oh right, of course. yeah, make that "print" everywhere
12:35:57 * hackagebot qudb 0.0.0 - Quite Useless DB  http://hackage.haskell.org/package/qudb-0.0.0 (JanStepien)
12:36:06 <elliott_> Promising package name
12:36:10 <mreh> :D
12:36:11 <elliott_> Or, well, summary
12:36:16 <geheimdienst> good salesmanship
12:36:27 <elliott_> Look out for my new library, "useless-rubbish"
12:36:35 <mreh> version 0.0.0
12:36:46 <elliott_> No, version -1.
12:36:47 <elliott_> It was demoted.
12:37:14 <merijn> version NaN :)
12:37:17 <cheater> geheimdienst: ah ok, yeah i looked over it again and it made no sense
12:37:46 <mreh> version _|_
12:38:25 <mreh> that's probably more like what the source is
12:38:43 <elliott_> version *** Exception: divide by zero
12:38:51 <elliott_> then a blank page
12:39:14 <mreh> quicksilver: ping
12:39:21 <cheater> mreh: version^C
12:41:59 <geheimdienst> cheater: maybe rename "known name" to "isKnown name", cause it's clearer what's the function name that way (and to make it consistent with isPhilippa etc.)
12:43:27 <cheater> aha
12:43:39 <cheater> anything else catch your attention?
12:44:00 <geheimdienst> i'd suggest that you add a line break after the main "=" in a function definition ... 'isPhilippa name =\n    "Philippa" == name'. i think a newbie might be confused as to how to mentally separate that line
12:44:15 <geheimdienst> (or you could use parens, but that might clutter it up)
12:44:50 <mreh> @vixen show me a funny picture
12:44:50 <lambdabot> The second point is that coming out--coming back and saying that black Americans aren't as good as black Africans--most of them , basically, are just out of the trees.  Now, let's face it, they are.
12:45:03 <mreh> what the hell
12:45:15 <cheater> mreh: Cale has replaced vixen with nixon :((((
12:45:27 <mreh> haha
12:45:44 <monochrom> actually, just deleting vixen, therefore auto-correction maps it to nixon
12:45:48 <cheater> geheimdienst: interesting, definitely a cool idea
12:45:48 <monochrom> @nixos
12:45:49 <lambdabot> Voters quickly forget what a man says.
12:46:15 <cheater> monochrom: even worse
12:47:19 <monochrom> yeah, we have found that nixon isn't very friendly either :)
12:49:00 <Phantom_Hoover> Wait, they got rid of vixen?
12:49:09 <Phantom_Hoover> I have to tell CakeProphet!
12:49:12 <cheater> *
12:49:27 <cheater> yes, this is a loss to us all
12:49:27 <Phantom_Hoover> &
12:49:33 <cheater> that was a typo
12:52:43 <Cale> People found @vixen offensive and requested that I remove it. Personally, I think @nixon is far more offensive. :)
12:52:59 <cheater> i find it offensive that @vixen is removed
12:53:06 <merijn> Cale: I find people who find things offensive offensive
12:53:14 <mreh> who are these people>
12:53:15 <geheimdienst> @run "omg wtf"
12:53:16 <lambdabot>   "omg wtf"
12:53:26 <geheimdienst> cale: i find @run offensive, plz 2 remov it, thx
12:53:29 <Cale> I seem to recall byorgey
12:53:34 <Cale> and some others
12:53:37 <Cale> I forget
12:55:00 <merijn> I wonder if bitch would be more or less offensive than vixen :>
12:55:28 <mreh> i think it's because the inference is that she is a woman
12:55:57 <cheater> yeah
12:56:11 <cheater> obviously byorgey is singled out on this
12:56:19 <cheater> the others were a hallucination
12:56:38 <merijn> Software is remarkably similar to women. Every once in a while they blow up in my face about something I supposedly did wrong but I can never figure out what :>
12:56:48 <cheater> lol?
12:57:05 <geheimdienst> i think the correct thing to do is when byorgey comes in here, we should all talk to him like vixen does
12:57:08 <Saizan> there's #-blah if you must
12:57:16 <mreh> eep
12:57:25 * merijn hides
12:57:37 --- mode: Saizan set -o Saizan
12:58:00 <elliott_> Huh, Saizan removed operator status without actually getting it here.
12:58:24 <Phantom_Hoover> Cale, wait, who thought @vixen was offensive/
12:58:29 <Saizan> yeah, i don't remember opping myself either
12:58:31 <Phantom_Hoover> And... how?
12:59:06 <nooodl> what was @vixen
12:59:18 <mreh> a chatbot
12:59:22 <copumpkin> -blah
12:59:33 <monochrom> Saizan: <joke>Remember some more days ago I reminded you to deop and so you deopped? Apparently, freenode's STM monad decided to roll back to that state...</joke>
12:59:57 <merijn> nooodl: Generic chat bot with "seductive" messages, but it seems -blah time
13:01:49 <Saizan> monochrom: does that mean i've to go through my finals again!?
13:02:11 <mreh> you've yet to be born
13:02:12 <monochrom> don't worry, it's just freenode's TVar
13:02:25 <cheater> nooodl: @vixen was a cyber-personality. murdered, without reason, in the bloom of her life.
13:02:39 <monochrom> unless your exams are administered by those freenode TVars too! hahahahaha
13:02:53 <cheater> geheimdienst: ok i fixed the list :)
13:03:03 <cheater> and the let :)
13:11:03 <geheimdienst> cheater: about the function isSomeone, i found that part a little roundabout because the end result seems to be "known name = any (== name) known_friends", which is what we already had to begin with. maybe to explain pointsfree, you could leave alone the friend names and instead use an obviously different example (like the 1/tan thing)
13:11:22 <geheimdienst> there's 2 other things that are folded into the isSomeone explanation, which i think makes it a little hard to follow:
13:11:41 <geheimdienst> 1. about infix, maybe you could just say "with backticks, you can make any function infix. these are the same: elem 5 [1..10] and 5 `elem` [1..10]. and as the reverse, with parens you can make any infix function normal: the following are the same (10 / 3) , ((/) 10 3).
13:11:47 <geheimdienst> 2. sections -- maybe you could just say "if you take (10 / 3) and leave out one of the numbers like this f = (   / 3) or g = (10 /  ), you have a function that takes one number and puts it in the blank spot, so "f 5" will be 5/3 and "g 9" is 10/9"
13:12:46 <cheater> geheimdienst: i wanted to explain fully why == can be used like this; this does not come from pointfree, it comes from the fact that == is infix
13:16:08 <si14> hi all. just wandering: RWH in .mobi, anyone? :)
13:16:31 <cheater> what
13:16:41 <si14> *wondering
13:16:46 <si14> *Real Word Haskell
13:16:54 <cheater> what
13:17:05 <monochrom> what is ".mobi"?
13:17:07 <si14> tags: piracy, ebooks, haskell, kindle
13:17:13 <geheimdienst> cheater: fair enough, i guess ... but be aware, directly before "OK, let's go back to our program", you change ((==) name) to (== name). this could be confusing, because it flips the argument order (name is the 1st arg in "((==) name)", but 2nd arg in "(== name)")
13:17:32 <si14> monochrom: amazon kindle's format.
13:17:42 <monochrom> then I don't know
13:18:10 <osfameron> si14: you can buy it from o'reilly's online shop
13:18:14 <cheater> geheimdienst: that's something newbies don't know.
13:18:25 <osfameron> if you already have a paper copy, you can get the .mobi for $5 (I've done that)
13:18:45 <monochrom> neato
13:18:46 <si14> and yeah, another question: is there any "standard solution" to the problem of transferring state of entire system to a newer version of code? some sort of erlang's hot code upgrade
13:19:04 <cheater> erlang
13:19:15 <si14> osfameron: >tags: piracy :) I know, just wandering if someone is kind enough to share.
13:19:25 <osfameron> si14: otherwise, RWH is free online, so you can scrape it (legally) into HTML, and convert that into .mobi with Calibre.  But that's not as pretty
13:19:38 <si14> osfameron: yeah.
13:19:41 <geheimdienst> cheater: yeah, newbies might think that in ((==) name) the parens are redundant and you can always write it as (== name). which works for (==), but for (/) you're in trouble
13:19:43 <osfameron> si14: the authors of RWH a) like their publisher, and b) are in this channel
13:19:58 <cheater> geheimdienst: they'll find out then!
13:20:12 <cheater> geheimdienst: they don't need to know yet :)
13:20:30 <si14> osfameron: then it's not that good from me to ask such things. sorry.
13:20:30 <cheater> geheimdienst: but that is very well spotted indeed
13:20:39 <cheater> i didn't think anyone would read this that closely at all
13:20:55 <si14> cheater: well, I'm interested if there is solutions to that problem in Haskell.
13:21:16 <osfameron> si14: it's at http://book.realworldhaskell.org/read/ for free, under a CC-BY-NC 3.0 license
13:21:21 <cheater> s14 no idea sorry.
13:21:27 <cheater> si14:
13:21:32 <si14> cheater: ok. thanks.
13:21:35 <geheimdienst> and one final thing :) you might want to show that if-then-else also does what ?: does in other languages. you could do something like: putStrLn $ if ... then "Hello" else "Pleased to meetya"
13:22:06 <si14> osfameron: I know. just wandering about pretty version.
13:22:10 <geheimdienst> so that's my 9000 cents. other than that: good job dude :) thanks for taking the time to write it up
13:22:19 <cheater> thanks :)
13:22:30 <osfameron> si14: make one ;-)
13:22:59 <cheater> what did you think of the radio tech references?
13:23:23 <cheater> and the constructive/declarative idea
13:23:24 <si14> osfameron: that way I'll make a bigger threat to O'Reilly's revenues than just getting someone's copy :)
13:24:16 <cheater> si14: watch out, you might be talking about the Big Brother
13:24:33 <osfameron> I guess.  But if they released it under CC, then it's (I think) a legal way to do it.  (And may drive revenue to them when people like it and want a paper copy).  That said, this probably belongs on -blah at this point, sorry.
13:25:31 <si14> osfameron: ok.
13:30:25 <si14> finally, bought it on O'Reilly.
13:36:24 <smop_> just realized there was winghci
13:38:20 <cheater> now you can read my tutorial :)
14:08:13 <smop_> where is it
14:12:37 <geheimdienst> in the Control.Exception haddock, i read "catchJust (\e -> if isDoesNotExistErrorType (ioeGetErrorType e) then Just () else Nothing)". this seems a little weird to me because 1. why not use the function isDoesNotExistError and skip the Type stuff
14:12:45 <geheimdienst> and 2. why didn't they make catchJust take a function (IOException -> Bool), which would have avoided giving back a bogus Maybe
14:12:47 <geheimdienst> ref:  http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v:catchJust
14:15:22 <monochrom> in general the exception has parameters
14:16:59 <kmc> ugh more FUNNAY PICTUR links on /r/haskell
14:17:17 <ddarius> kmc: I highly recommend you stop looking at the internet.
14:18:02 <kmc> :(
14:18:10 <kmc> maybe i can use IRC over not-The-Internet
14:18:11 <cheater> except for my new blog post
14:18:22 <cheater> you should look at that
14:18:35 <cheater> in fact, it should be the only thing you ever look at
14:19:08 <ddarius> NTIRC?
14:21:10 <hpc> ddarius: it got renamed to IRLRC, and then people got lazy and just called it "conversation"
14:22:12 <Twey> Is there any way to use the GtkHtml widget in Gtk2Hs?
14:22:44 <dcoutts> Twey: there's a binding to the gtk webkit
14:23:21 <Twey> That'll do
14:23:24 <Twey> Where is it?
14:23:46 <Twey> Ooh
14:23:50 <Twey> http://hackage.haskell.org/package/webkit — this?
14:23:59 <Twey> I didn't think Webkit was tied to GTK
14:27:40 <hpc> webkit and gtk talk to each other to keep the buttons and stuff consistent between browser and native programs
14:38:10 <monochrom> @src &&
14:38:10 <lambdabot> True  && x = x
14:38:10 <lambdabot> False && _ = False
14:38:25 <monochrom> @src ||
14:38:25 <lambdabot> True  || _ =  True
14:38:25 <lambdabot> False || x =  x
14:46:08 <c4th0d3r4y> hi guys!
14:46:40 <c4th0d3r4y> i just started learning haskell
14:46:52 <dylukes> :)
14:46:53 <c4th0d3r4y> do you recommend any doc/book for beginners?
14:46:56 <dylukes> LYAH
14:46:58 <dylukes> @where LYAH
14:46:59 <lambdabot> http://www.learnyouahaskell.com/
14:49:22 <c4th0d3r4y> lambdabot: thanks, lambdabot! i'm already playing with this book, =) it's fun!
14:50:01 <c4th0d3r4y> lambdabot: so, you think it's a good starting point?
14:51:06 <kmc> @vixen do you think LYAH is a good starting point?
14:51:07 <lambdabot> A man who has never lost himself in a cause bigger than himself has missed one of life's mountaintop experiences. Only in losing himself does he find himself. Only then does he discover all the
14:51:07 <lambdabot> latent strengths he never knew he had and which otherwise would have remained dormant.
14:51:40 <geheimdienst> kmc, vixen has be usurped by nixon
14:51:44 <kmc> indeed
14:51:49 <kmc> that's a good response though
14:52:17 <geheimdienst> s/be/been/
14:52:38 <cheater> do you think it's good vixen was removed
14:52:41 <c4th0d3r4y> lambdabot: thanks
14:52:50 <byorgey> c4th0d3r4y: lambdabot is a robot
14:52:57 <kmc> @botsnack
14:52:58 <lambdabot> :)
14:53:21 <c4th0d3r4y> byorgey: i can't talk with bots?
14:53:45 <c4th0d3r4y> byorgey: nobody told me that, ;P
14:53:55 <byorgey> c4th0d3r4y: oh, sure, talk all you want =)
14:54:03 <byorgey> just making sure you were aware =)
14:54:22 <byorgey> > map pred "Ij!d5ui1e4s5z\""
14:54:23 <lambdabot>   "Hi c4th0d3r4y!"
14:54:46 <geheimdienst> c4th0d3r4y: preflex and kmc are also bots. we're not sure about byorgey yet
14:55:15 <byorgey> unrecognized command
14:55:23 <c4th0d3r4y> so, if you're a bot, lambdabot, I think that you have just passed in my turing test, for a while =P
14:58:58 <c4th0d3r4y> do you have any list of successful projects (open source) in haskell?
14:59:23 <DanBurton> @wiki open source
14:59:23 <lambdabot> http://www.haskell.org/haskellwiki/open_source
14:59:46 <c4th0d3r4y> DanBurton: thanks
14:59:50 <DanBurton> hm thought there would be something
14:59:56 <DanBurton> the page doesn't exist
14:59:59 <siracusa> @where Hackage
14:59:59 <lambdabot> http://hackage.haskell.org/package/
15:00:18 <geheimdienst> c4th0d3r4y: darcs and xmonad come to mind
15:00:26 <siracusa> ^ a lot of open source projects, not all successfull :-P
15:00:37 <c4th0d3r4y> siracusa: hehe
15:00:40 <kmc> pandoc is a better example than darcs
15:00:41 <c4th0d3r4y> geheimdienst: thanks
15:00:47 <kmc> c4th0d3r4y, pandoc and xmonad are at the top of my list
15:00:52 <DanBurton> @where hackage
15:00:53 <lambdabot> http://hackage.haskell.org/package/
15:01:14 <kmc> c4th0d3r4y, but for whatever reason, Haskell is more popular for internal tools at various companies than for open-source desktop software
15:01:15 <DanBurton> hackage is full of open-source packages
15:01:25 <kmc> not much end-user software though
15:01:35 <kmc> c4th0d3r4y, http://www.haskell.org/haskellwiki/Haskell_in_industry
15:01:40 <kmc> some of this has been open-sourced, though
15:01:53 <kmc> 'atom' is a good example
15:02:29 <c4th0d3r4y> thank you all, i'm new in this haskell world
15:10:41 <dylukes>  Could not find module `Data.Binary'
15:10:42 <dylukes>     It is a member of the hidden package `binary-0.5.0.2'.
15:10:45 <dylukes> odd, I know its installed.
15:11:00 <rostayob> dylukes: maybe it's not in the cabal file?
15:11:09 <dylukes> I'm just compiling a single file with ghci.
15:11:17 <dylukes> well, not even compiling, y'know.
15:11:43 <rostayob> dylukes: what does ghc-pkg list say?
15:11:57 <dylukes>    binary-0.5.0.2
15:12:02 <dylukes>  /usr/local/Cellar/ghc/7.2.1/lib/ghc-7.2.1/package.conf.d
15:12:03 <dylukes>    binary-0.5.0.2
15:12:06 <dylukes> its definitely installed...
15:12:06 <rostayob> not parenthesized?
15:12:20 <dylukes> its blue
15:12:23 <dylukes> which means parenthetized
15:12:35 <rostayob> yes, it's hidden
15:12:42 <dylukes> meaning?
15:12:57 <rostayob> meaning that it's hidden, use -package binary
15:13:07 <rostayob> http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html
15:13:21 <dylukes> What about in ghci?
15:13:23 <rostayob> ghci -package binary should work
15:13:46 <dylukes> no I mean, if GHC is already launched
15:13:49 <dylukes> (i.e, through emacs)
15:13:51 <rostayob> I'm not sure why you have it hidden, did you install it with cabal?
15:14:26 <dylukes> That's my global package db.
15:14:27 <dylukes> :\
15:14:36 <dylukes> It may have been installed by something.
15:14:42 <rostayob> dylukes: try to install it with cabal, maybe it comes with the platform/ghc or something like that
15:14:46 <rostayob> cabal install binary
15:14:52 <dylukes> yeah, I'll --reinstall it.
15:15:16 <dylukes> well now I have a user copy
15:15:17 <dylukes> should work
15:15:28 <rostayob> oh, you can also do
15:15:32 <rostayob> ghc-pkg expose binary
15:15:37 <rostayob> which should fix it
15:15:44 <rostayob> (unhide it)
15:15:47 <dylukes> mm oh well
15:15:48 <dylukes> oh ffs
15:15:52 <dylukes> now it can't find Remote
15:15:57 <dylukes> it was just fine...
15:16:16 <dylukes> and that one's not even hidden :<
15:16:17 <dylukes> cripes.
15:17:14 <rostayob> dylukes: Remote?
15:17:22 <dylukes> Cloud Haskell.
15:17:52 <rostayob> oh. "can't find" meaning "complains it's hidden"?
15:17:58 <dylukes> okay, ghc --make -v reveals its being a wee bit derpy
15:17:59 <dylukes> cloudtest.hs:5:8:
15:17:59 <dylukes>     Could not find module `Remote'
15:18:01 <dylukes>     Locations searched:
15:18:02 <dylukes>       Remote.hs
15:18:02 <dylukes>       Remote.lhs
15:18:31 <dylukes> aww crap
15:18:34 <dylukes> thats why
15:18:42 <dylukes> a few packages depend on the hidden binary
15:18:45 <rostayob> is that supposed to be a package or a single module :P?
15:18:45 <dylukes> and now my user one is shadowing it
15:18:48 <dylukes> I'll remove and expose it.
15:18:55 <dylukes> It's a package.
15:18:56 <dylukes> It's top level.
15:19:04 <dylukes> (as well as a module)
15:19:08 <rostayob> is that related to the cloud haskell paper?
15:19:10 <dylukes> yep
15:19:12 <dylukes> same thing.
15:19:54 <rostayob> oh right
15:19:59 <rostayob> i'm going to read it some day ehe
15:20:05 <rostayob> strange that binary is hidden anyway
15:20:14 <dylukes> I unhit it.
15:20:44 <dylukes> also annoying
15:20:55 <dylukes> ghci isn't picking up my LANGUAGE pragma's DeriveDataTypeable
15:21:16 <dylukes> it could be because I spelled it LANGAUGE
15:21:18 <rostayob> so it complains that it can't derive Data and Typeable?
15:21:19 <dylukes> distinct possibility hm
15:21:22 <rostayob> yeah that could be.
15:21:33 <rostayob> you can set language extensions with :set XWhatever
15:21:37 <rostayob> (while in ghci)
15:21:47 <dylukes> On second blush, it just isn't picking up the pragma
15:21:51 <dylukes> but yeah, thats what I've been doing
15:22:01 <dylukes> because it isn't seeing the LANGUAGE pragma itself apparently.
15:22:32 <rostayob> so you have {-
15:22:43 <dylukes> a got it
15:22:44 <dylukes> nmd
15:22:55 <rostayob> coolio
15:23:53 <dylukes> @hoogle genericGet
15:23:53 <lambdabot> No results found
15:24:18 <dylukes> oh that's convenient
15:24:31 <rostayob> dylukes: is the package on hackage?
15:24:37 <dylukes> No, its part of remote
15:24:39 <dylukes> (CloudHaskell)
15:24:46 <rostayob> well then I doubt hoogle can be aware of it
15:25:00 <rostayob> (if genericGet is part of it)
15:25:10 <rostayob> try the index of the haddock documentation
15:25:13 <rostayob> i like those indexes.
15:25:28 <dylukes> so, what are Data.Typeable and Data.Data?
15:25:31 <dylukes> (and yeah, I did :P)
15:26:36 <rostayob> dylukes: they give you information about the type of something and there are various convenient functions
15:26:53 <rostayob> @hoogle typeRef
15:26:54 <lambdabot> No results found
15:26:59 <rostayob> @hoogle typeOf
15:27:00 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
15:27:00 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
15:27:00 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
15:27:07 <rostayob> @hoogle cast
15:27:08 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
15:27:08 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
15:27:08 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
15:28:26 <rostayob> dylukes: that was typeable
15:28:32 <dylukes> mmk I found it before
15:28:40 <dylukes> trying to figure out why its not allowing standalone deriving here...
15:28:46 <dylukes> "The data constructors of `ProcessId' are not all in scope"
15:28:50 <rostayob> data is Typeable a => Data a and is to do generic programming, so to traverse data structures generically
15:28:51 <dylukes> :<
15:29:50 <dylukes> I can't derive Data since ProcessId isn't an instance, so I tried
15:29:52 <dylukes> deriving instance Data ProcessId
15:30:11 <dylukes> but apparently I can't because they're not all in scope... I've imported everything relevant though :\
15:30:51 <dylukes> it's just data ProcessId = ProcessId !NodeId !LocalProcessId deriving (Typeable,Eq,Ord)
15:30:52 <dylukes> :\
15:31:11 <dylukes> and it derives Typeable so Data should be just fine...
15:32:46 <rostayob> dylukes: yeah it should
15:32:57 <rostayob> if it's an instance of Typeable, it's got Data too :P
15:33:27 <dylukes> yeah, but its not seeing that is it.
15:34:20 <rostayob> dylukes: what's the error message?
15:36:29 <dylukes> http://cl.ly/APvD
15:38:20 <dylukes> whats funny is, its perfectly capable of deriving the Typeable...
15:45:18 <ddarius> dylukes: You don't need to actually know anything about a type to write a Typeable instance.
15:45:37 <dylukes> ddarius: Could you explain?
15:46:52 <dolio> All it requires is typeOf :: T -> TypeRep.
15:46:57 <dolio> Just give back any type rep you want.
15:48:28 <ddarius> Being an instance of Typeable also doesn't imply that something is an instance of Data.
15:50:45 <ddarius> none of my modifier keys work.
15:52:06 * BMeph thought it was the other way around, that being an instance of Data made it (potentially) an instance of Typeable. It's been a while since using them, though.
15:54:50 <Clint> what's the best way to translate an iterator loop with c2hs?
16:07:25 <hpaste> ajabad pasted “SDL + joystick woes” at http://hpaste.org/51756
16:08:16 <ajabad> pasted an sdl problem i'm having. any insights?
16:08:48 <Cale> ajabad: hmmm...
16:09:40 <Cale> I don't have a joystick to test with .___.
16:10:53 <incluye> > [1..]
16:10:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:12:17 <Cale> ajabad: Well, I'm not sure it makes a difference, but in ghci, buffering is turned off, at least for stdin and stdout.
16:12:42 <ajabad> Cale: hmmm... it's a pretty massive stream of text, though...
16:13:54 <cgroza> why this code does not work? Code : http://pastebin.com/5ySFM9tC
16:13:56 <mauke> The paste 5ySFM9tC has been copied to http://hpaste.org/51757
16:14:16 <KirinDave> cgroza: Easy
16:14:27 <KirinDave> cgroza: Haskell is telling you that you are wrong about your type definition
16:14:43 <KirinDave> Remove the :: decl, and it will work
16:15:04 <KirinDave> cgroza: Look carefully at the error message, it's pretty clear what the problem is.
16:15:16 <cgroza> KirinDave: I removed the :: Handle. Same error.
16:15:31 <cgroza> KirinDave: I actually put that there in a try to fix the error.
16:15:35 <bfig_> > repeat $ print "1"
16:15:36 <lambdabot>   [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<I...
16:15:45 <Cale> ajabad: Well, I have no idea why stdin/stdout buffering would make a difference here at all, it's just one difference between how I/O works in compiled programs and ghci.
16:15:55 <bfig_> mm what the hell does that mean :p
16:16:05 <Cale> bfig_: It's an infinite list of IO actions
16:16:09 <bfig_> lift repeat $print "1"
16:16:19 <bfig_> > lift repeat $print "1"
16:16:20 <lambdabot>   Ambiguous occurrence `lift'
16:16:20 <lambdabot>  It could refer to either `Control.Monad.Trans....
16:16:31 <bfig_> > fmap repeat $ print "1"
16:16:32 <lambdabot>   <IO [()]>
16:16:41 <bfig_> :|
16:16:50 <bfig_> > print "1"
16:16:51 <lambdabot>   <IO ()>
16:16:58 <bfig_> ahh ok, it doesn't print it in the bot
16:17:08 <Cale> lambdabot doesn't execute IO actions
16:17:20 <Cale> But it can evaluate them.
16:17:34 <bfig_> evaluate the type?
16:17:43 <c_wraith> > undefined `seq` print ()
16:17:44 <lambdabot>   <IO ()>
16:17:48 <cgroza> anyone?
16:17:56 <c_wraith> that doesn't look particularly like it was evaluated
16:18:19 <KirinDave> cgroza: Your types are all messed up all over that code
16:18:21 <Cale> cgroza: I'll look
16:18:22 <bfig_> > undefined `seq` undefined
16:18:23 <lambdabot>   *Exception: Prelude.undefined
16:18:24 <KirinDave> cgroza: For one, your return type is wrong.
16:18:39 <KirinDave> cgroza: For two, I dunno how unlines is supposed to work on a String
16:18:51 <Cale> cgroza: openFile filePath ReadMode isn't a Handle
16:18:52 <KirinDave> cgroza: For three, you didn't call return.
16:18:57 <Cale> :t openFile
16:18:58 <lambdabot> Not in scope: `openFile'
16:18:58 <c_wraith> > undefined `seq` "foo"
16:19:00 <lambdabot>   "*Exception: Prelude.undefined
16:19:02 <Cale> :t System.IOopenFile
16:19:03 <lambdabot>     Not in scope: data constructor `System.IOopenFile'
16:19:05 <Cale> :t System.IO.openFile
16:19:06 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> IO GHC.IO.Handle.Types.Handle
16:19:19 <Cale> It's FilePath -> IOMode -> IO Handle
16:19:28 <bfig_> > (undefined, 1) `seq` "something"
16:19:29 <lambdabot>   "something"
16:19:31 <Cale> which means that openFile filePath ReadMode :: IO Handle
16:19:40 <cgroza> Cale: so <- should extract the Handle from the IO.
16:19:43 <Cale> but you say in your code that it should have type Handle
16:19:49 <Cale> and that's what it's complaining about
16:20:00 <Cale> inH should have type Handle
16:20:03 <dylukes> http://cl.ly/AP1g
16:20:08 <dylukes> Could someone help me out here :\?
16:20:12 <cgroza> Cale: ignore the :: Handle part. I removed it and I get the same thing.
16:20:14 <Cale> because it's the result of that IO action
16:20:26 <KirinDave> cgroza: http://pastebin.com/hHFiukxG
16:20:27 <Cale> The exact same thing?
16:20:28 <mauke> The paste hHFiukxG has been copied to http://hpaste.org/51758
16:20:31 <KirinDave> cgroza: Is probably what you were trying to write
16:20:48 <KirinDave> cgroza: unlines removes lines, it is [String] -> String.
16:20:49 <cgroza> It says it cant match IO Handle To [t0].
16:21:44 <Cale> cgroza: In which bit of code? :)
16:21:53 <KirinDave> cgroza: The biggest error you had was your original return type was [String], not IO [String].
16:22:08 <cgroza> Ohhh, I get it now.
16:22:10 <Cale> cgroza: (there are lots of things wrong that I could point out, but I'll help you decipher what the compiler is actually telling you)
16:22:23 <cgroza> >>= wraps my string back to IO after its done.
16:22:38 <Cale> Um...
16:22:41 <dylukes> ah nmd
16:22:46 <cgroza> a sec
16:23:08 <cgroza> fixed it. Thanks.
16:23:09 <KirinDave> cgroza: You're never "out" of IO.
16:23:22 <cgroza> KirinDave: I ignored that part. lol
16:23:37 <Cale> "wraps" is a bit funny
16:23:59 <EvanR> burrito mode
16:24:01 <Cale> do-notation combines a bunch of IO actions together into a bigger IO action
16:24:22 <EvanR> think of it like sequencing several burritos in a row
16:24:23 <Cale> So a do block with a bunch of IO actions in it will always itself be an IO action.
16:24:28 <Cale> .___.
16:24:32 <Cale> stop
16:24:37 <EvanR> lol
16:24:43 <Cale> no burritos
16:25:02 <KirinDave> Cale: The technical term is "burriter"
16:27:42 <cgroza> So once I get a string via IO, I have to keep it in a IO while I need the string?
16:27:55 <KirinDave> You can never get it "out" of IO
16:27:57 <Cale> cgroza: ... *kinda*
16:28:16 <Cale> But you can pass it to a pure function and use the result of that pure function to do some output, say.
16:28:54 <Cale> like in:
16:29:07 <Cale> main = do x <- getLine; putStrLn (reverse x)
16:29:30 <cgroza> Cale: thanks
16:29:31 <Cale> reverse is a pure function String -> String
16:42:26 <shachaf> cgroza: There's really no such thing as a String that's "in" IO.
16:42:32 <shachaf> If you're referring to values, anyway.
16:45:53 <wavewave> constraint kind is exciting
16:52:05 <dylukes> https://gist.github.com/1240068
16:52:11 <dylukes> here I made a good cloud haskell example
16:54:38 <wavewave> dylukes: what's cloud haskell?
16:54:52 <dylukes> Erlang-style/MPI-style Haskell.
16:54:59 <dylukes> i'e, asynchronous actor/message model.
16:55:51 <wavewave> in your code, ProcessM is a monad supporting it?
16:56:05 <dylukes> yep.
16:56:08 <dylukes> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
16:56:23 <wavewave> oh thanks.
16:57:53 <wavewave> this can be done over network, of course?
16:58:01 <dylukes> Yep.
16:58:03 <dylukes> Notice the output.
16:58:12 <dylukes> in my gist
16:58:35 <wavewave> is it already implemented as a public library?
16:59:24 <wavewave> Remote library seems to do something  behind
16:59:40 <sal23> any good paper or blog post which explains why <*> is defined that way for applicative functions? Copy-paste from LYAH: http://hpaste.org/51761
17:01:03 <luqui> sal23, one reason is the types
17:01:10 <luqui> come up with another implementation that typechecks
17:01:59 <shachaf> sal23: It's the only way that makes any sense.
17:02:11 <shachaf> As luqui said, try to make it work any other way.
17:02:22 <sal23> well, I am thinking in terms of types but came up with this: (r -> (a->b)) -> (r ->a) -> (r -> b)
17:02:36 <luqui> sal23, yes, exactly
17:02:39 <ajabad> Cale: what's even more strange about that SGL app i pasted earlier... if i put that paste in a file and run it in ghci... fails.  literally type it into ghci... works
17:02:40 <shachaf> sal23: That's the type.
17:02:46 <shachaf> sal23: Now implement any function that has that type.
17:02:48 <dylukes> wavewave: yep
17:02:52 <dylukes> jepstein has it on his github
17:02:52 <shachaf> There's only one such function*.
17:03:02 <wavewave> dylukes: found it just now
17:03:05 <luqui> @djinn (r -> (a -> b)) -> (r -> a) -> (r -> b)
17:03:05 <lambdabot> f a b c = a c (b c)
17:03:12 <wavewave> https://github.com/jepst/CloudHaskell
17:03:23 <killerswan> so, can cabal-dev be used to build a package with enabled executable profiling?
17:04:55 <wavewave> dylukes: this is really interesting to me.. thanks for the info.
17:05:32 <sal23> luqui: what is type of x in \x? I thought it was (r -> a), but g is (r ->), so g x = (r -> r -> a). Is that right?
17:07:15 * wavewave is happy to have a luxury to use a cluster using cloud haskell. 
17:09:52 <wavewave> sal23: x must be of type r
17:13:31 <wavewave> sal23: f  :: r -> a -> b ,  g :: r -> a
17:13:50 <wavewave> sal23: f <*> g :: r -> b
17:14:11 <wavewave> sal23: so  x :: r and then
17:14:29 <wavewave> sal23: f x :: a -> b
17:14:35 <sal23> wavewave: aha, that is what I was missing
17:14:36 <wavewave> sal23: g x :: a
17:14:44 <wavewave> sal23: f x (g x) :: b
17:14:54 <wavewave> so \x -> f x (g x) :: r -> b
17:15:02 <wavewave> sal23: does it make sense?
17:15:26 <sal23> wavewave: yes, makes sense after I saw f <*> g type signature
17:17:38 <wavewave> so in Applicative ( r -> )  implementation, role of <*> is to make argument of type r be omitted in all of its arguments f and g
17:19:01 <wavewave> (f <*> g) x = (f x ) (g x)
17:19:18 <wavewave> (f <*> g <*> h) x = (f x ) (g x) (h x)
17:19:25 <wavewave> like this.
17:23:44 <wavewave> sal23: for reference, read Applicative programming with effects by C. McBride and R. Paterson
17:25:37 <sal23> wavewave: thanks. yes, I know about it and hope to get to it after I play with applicatives some more
17:29:25 <wavewave> sal23: probably, you may also know 'typeclassopedia', Brent Yorgey's The Monad Reader article.
17:29:40 <sal23> yep
17:30:07 <eduardo> is there a way to do an equivalent to (x:xs) to take the last element of a list?
17:30:53 <wavewave> eduardo: not by a simple pattern matching.
17:31:14 <wavewave> since list is defined asymmetrically in a sense.
17:32:34 <gienah> eduardo: you could use pattern matching if it was a Data.Sequence
17:32:44 <sal23> wavewave: typoclassepedia doesn't discuss applicative in the context of functions except to mention that the values are accumulated
17:33:21 <sal23> now, trying to understand how the values get accumulated in this example: (\x y -> [x,y]) <$> (+3) <*> (*3) $ 5
17:33:40 <wavewave> sal23: yes, it is discussing it more generically.
17:34:35 <eduardo> I'll give it a try
17:36:03 <gienah> case viewR xs of
17:36:10 <gienah> xs' >: x -> ... do something
17:36:31 <wavewave> sal23: remember f <$> g <*> h = pure f <*> g <*> h
17:37:08 <wavewave> (pure f) x = f
17:37:21 <gienah> oops s/>:/:>/
17:42:07 <wavewave> sal23: I think that it is probably too much yet, but the article by Petr Pudlak in Monad Reader 17 was also very good for understanding this more deeply.
17:42:24 <wavewave> title was "The Reader Monad and Abstraction Elimination"
17:43:03 <wavewave> it explains (r -> ) as Reader monad and Applicative, and relate it to SK combinators and related issue.
17:44:34 <wavewave> sal23: it's somewhat advanced, so just note that.
17:44:52 <sal23> yep, thanks
18:04:03 <kmc> stupid template haskell staging restrictions
18:04:47 <kmc> quasiquoters aren't first-class... i can't say:  let qq = f x in [qq|  ...  |]
18:04:56 <kmc> which means i can't make my quasiquoter configurable the way i want
18:05:12 <kmc> the user would have to put the configuration in a separate module
18:07:53 <shachaf> do { x <- getLine; let qq = f x in [qq | ... |]; ... }
18:09:14 <kmc> right, that's one reason it isn't allowed
18:09:23 <kmc> another would be «let x = [x| x |]»
18:09:33 <kmc> but i still think there's some less onerous stage restriction you could place
18:09:58 <shachaf> That seems likely.
18:10:10 <shachaf> Or you could just embed GHC in every executable. :-)
18:10:13 <kmc> yep
18:10:32 <kmc> we need the combination of Template Haskell, GHC API, and a super awesome tracing JIT
18:10:37 <kmc> i call it Super Mutant Template Haskell
18:10:51 <wavewave> Meta haskell
18:11:52 <wavewave> MutatEd TemplAte Haskell
18:12:05 <copumpkin> kmc: clearly you need the modal types thing
18:12:52 <kmc> whatsat
18:15:08 <copumpkin> some work some guy was doing in coq for ghc
18:15:21 <copumpkin> well, haskell code extracted from coq proofs
18:15:21 <shachaf> Super Overpowered Mutant Extra-Template Haskell Including Nightly GHC
18:15:26 <shachaf> Or something like that.
18:16:45 <kmc> oh yes
18:16:53 <cads> evening all
18:16:58 <kmc> there was a thing for writing ghc compiler passes in coq
18:17:15 <copumpkin> that thing, yes
18:17:28 <copumpkin> well, he did modal types in it
18:20:21 <ddarius> copumpkin: Wasn't that thing completely crazy?
18:21:02 <copumpkin> I never really looked too closely, but I got the impression it was about separating phases in a TH-sort of way, but without doing it at compile time
18:25:52 <cgroza> Hello everyone. I made a program that removes duplicate lines both in Haskell and Ocaml. I have noticed that the Ocaml one performs better that the Haskell one by arround 0.100 on a file containing 10 000 duplicate lines. Is the Ocaml string faster than the Haskell ByteString?
18:27:11 <shachaf> There isn't really a correct answer you could give to that question.
18:27:21 <shachaf> They're different things, especially the lazy ByteString.
18:27:51 <cgroza> shachaf: would be using the Lazy one make my program faster?
18:28:03 <shachaf> I have no idea.
18:28:23 <cgroza> I was using a String before and the haskell program was 0.400 ms behind.
18:28:27 <shachaf> You could @paste your code and see if someone sees something clearly different between the two.
18:28:39 <timemage> cgroza, you're probably going to get better results by just posting your code and asknig how to optimize it.
18:28:40 * shachaf would also try for a more significant difference than 0.1 seconds.
18:29:02 <cgroza> timemage: ok.
18:29:25 <HugoDaniel> i remember there was a haskell array datatype that was made specially to draw x,y coordinates
18:29:29 <HugoDaniel> i cant remember the name :(
18:29:35 <HugoDaniel> anyone knows of such thing ?
18:29:41 <hpaste> cgroza pasted “bytestring” at http://hpaste.org/51765
18:30:20 <cgroza> The code : http://hpaste.org/51765 .
18:31:26 <shachaf> You should perhaps also @paste your OCaml program and something to generate your test input. :-)
18:31:36 <cgroza> sure
18:31:40 <timemage> was thinking the same thing.
18:31:52 <shachaf> Your "unique" functions could probably be much more efficient, for one.
18:32:05 <timemage> usually people sort before removing duplicates.
18:32:19 <cgroza> shachaf: in what way?
18:32:44 <copumpkin> cgroza: that unique function is O(n^2) isn't it?
18:32:45 <hpaste> cgroza pasted “ocaml” at http://hpaste.org/51766
18:32:50 <shachaf> cgroza: It has to search potentially every line for every line.
18:33:14 <cgroza> shachaf: is there another way to do it?
18:33:24 <MichaelBurge> I'm interested in writing a simple web game in Haskell. Are there good resources for this?
18:33:54 <Nisstyre> MichaelBurge: #snapframework has stuff for writing web apps
18:34:02 <cgroza> shachaf: still, I use the same algorithm in both.
18:34:09 <parcs> cgroza: http://paste.pocoo.org/show/481960/
18:34:23 <MichaelBurge> Nisstyre: That looks like it'll work - thanks
18:34:44 <timemage> cgroza, yeah. although since it's a big optimization in both cases you should probably do it in both places and compare performance again.
18:34:44 <parcs> cgroza: benchmark that instead
18:35:06 <cgroza> parcs: sure.
18:35:06 <shachaf> cgroza: You're reading the file a line at a time in Haskell, and all at once in OCaml.
18:35:14 <shachaf> That's a pretty big difference, I'd assume.
18:35:30 <parcs> cgroza: actually change mapM to mapM_
18:35:37 <cgroza> parcs: ok
18:36:00 <copumpkin> also, how are you compiling your haskell?
18:36:14 <cgroza> copumpkin: ghc
18:36:17 <copumpkin> I mean
18:36:18 <shachaf> You have to use -O\infty to get good performance from GHC. It's a hidden option.
18:36:20 <copumpkin> are you passing -O2?
18:36:28 <cgroza> copumpkin: no
18:36:29 <shachaf> But -O2/-O3 also improves things.
18:36:32 <copumpkin> if not, you're not getting optimized
18:36:36 <copumpkin> well then
18:36:45 <cgroza> copumpkin: let me try
18:36:57 <copumpkin> but also try parcs's version
18:37:02 <copumpkin> also with -O2 :)
18:37:19 <copumpkin> he reads the whole file at once like you do in the ocaml one
18:37:41 <shachaf> And also with a smarter nub function. :-) Though I guess that would make the benchmark a different thing.
18:37:42 <wavewave> interesting to see the result. ;-)
18:37:56 <copumpkin> yeah, you'd have to change the nub in both to be meaningful
18:38:02 <copumpkin> because that completely changes your asymptotics
18:38:25 <shachaf> Haskell's nub is implemented differently from yours, though, I thikn.
18:38:29 <shachaf> @src nub
18:38:30 <lambdabot> nub = nubBy (==)
18:38:32 <shachaf> @src nubBy
18:38:33 <lambdabot> nubBy eq []             =  []
18:38:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:38:36 <wavewave> is print in haskell implemented efficiently by the way?
18:38:39 <HugoDaniel> the haskell programs in the shootout seem slow
18:38:56 <copumpkin> wavewave: what counts as efficient for a function that sends thing to stdout?
18:39:19 <shachaf> copumpkin: Doesn't write() it a byte at a time like putStrLn does by default (I think). :-)
18:39:43 <mauke> shachaf: putStrLn doesn't
18:39:50 <shachaf> Oh.
18:39:52 <parcs> yeah maybe he should use BS.hPutStrLn . show
18:39:54 <mauke> but it has no choice if you set stdout to NoBuffering
18:39:54 <shachaf> Well, something does.
18:40:04 <mauke> and that's why you don't use NoBuffering
18:40:17 <shachaf> Hmm.
18:40:49 <wavewave> mauke: show is needed?
18:40:58 <parcs> cgroza: try this too :P http://paste.pocoo.org/show/481963/
18:41:02 <mauke> wavewave: that is a question?
18:41:09 <shachaf> I've seen it in a program that I didn't *think* used NoBuffering. Though I'm not sure.
18:41:23 <shachaf> mauke: English grammar is weird?
18:41:25 <mauke> .oO( strace or it didn't happen )
18:41:26 <wavewave> mauke: oh I am sorry, I was asking parcs
18:41:29 <cgroza> with -O2-3, it is still 30-40 ms behind.
18:41:40 <shachaf> parcs: Any reason for using Char8?
18:41:42 <mauke> ok, can we stop talking about -O3? it doesn't exist
18:41:45 <rwbarton> "it"=?
18:41:47 <copumpkin> cgroza: that doesn't tell us anything
18:41:54 <shachaf> -O4
18:41:54 <parcs> shachaf: nope
18:42:02 <copumpkin> -O11
18:42:05 <parcs> bad habit i guess
18:42:15 <shachaf> Data.ByteString.Char8 is racist, as kmc would be happy to inform you.
18:42:25 <copumpkin> cgroza: is that parcs's version or yours?
18:42:34 <copumpkin> cgroza: try parcs's most recent one
18:42:34 <rwbarton> you need it for BS.lines
18:42:36 <parcs> cgroza: try the latest version
18:42:44 <mauke> > (1 and 2 and 1, 2, 3, 4)
18:42:45 <lambdabot>   (1,2,3,4)
18:43:01 <copumpkin> o.O
18:43:05 <parcs> rwbarton: nice, my intuition was correct :P
18:43:09 <copumpkin> :)
18:43:09 <shachaf> cgroza: 30-40 ms? I'd increase the size of your test file a bit.
18:43:12 <cgroza> parcs: the other one you gave me does not compile. BS does not have a lines function.
18:43:22 <rwbarton> but not for BS.hGetLine, oddly
18:43:33 <copumpkin> cgroza: .Char8 should
18:43:36 <shachaf> instance Num [Bool]
18:43:36 <cgroza> shachaf: ok. I will append 10 000 more to it.
18:43:39 <parcs> worksforme
18:43:53 <shachaf> > (1, and 2, and 1, 2, 3, 4)
18:43:55 <lambdabot>   No instance for (GHC.Num.Num [GHC.Bool.Bool])
18:43:55 <lambdabot>    arising from the literal `...
18:43:55 <wavewave> shachaf , cgroza : yes.. that's true.. 30 -40 ms is really small time for profiling.
18:44:12 <rwbarton> also, is this 30-40 ms out of 50 ms, or 30-40 ms out of ten minutes
18:44:22 <copumpkin> that's what I meant by it not telling us anything :)
18:44:24 <rwbarton> rather useless information without knowing that
18:44:25 <lcfrs> hi, is there a haskell-art channel somewhere?
18:44:26 <rwbarton> yes
18:45:03 <shachaf> copumpkin: Oh. Makes sense.
18:45:05 <cgroza> wavewave: shachaf just added 30 k of lines. The ocaml one took .300 advance.
18:45:17 * shachaf will get out of the way and allow the racism.
18:45:54 <wavewave> cgroza: out of how much time?
18:46:48 <cgroza> wavewave: ocaml around 500
18:46:57 <cgroza> haskell around 800
18:46:58 <shachaf> 500 seconds?
18:47:02 <cgroza> ms
18:47:09 <cgroza> ohhh wait.
18:47:20 <shachaf> ...Increase your test file size.
18:47:27 <cgroza> the ocaml one does not print its output, it stack overflows...
18:47:30 <copumpkin> lol
18:47:31 <cgroza> so I guess haskell wins...
18:47:33 <parcs> oooooo
18:47:33 <copumpkin> also, use criterion
18:47:35 <parcs> haskell++
18:47:35 <wavewave> lol
18:47:43 <copumpkin> cgroza: no, haskell doesn't win :P you just need to write a better ocaml program
18:47:50 <parcs> haskell--
18:47:50 <cgroza> copumpkin: :D
18:47:53 <copumpkin> it might win, but it's unfair if you're not tail-recursing in ocaml
18:48:11 <copumpkin> but criterion is the way to benchmark haskell
18:48:19 <cgroza> ok. I am going to put an accumulator in ocaml.
18:48:22 <copumpkin> takes almost no work and gives you meaningful results from benchmarks
18:48:23 <rwbarton> I was wondering about that remove_duplicate_lines function...
18:48:26 <shachaf> copumpkin: To be fair, you'd want to use the same tool to benchmark both programs.
18:48:39 <copumpkin> shachaf: tool == time?
18:49:00 <wavewave> copumpkin: I never used criterion yet. is it easy to use?
18:49:03 <shachaf> ?
18:49:04 <copumpkin> very
18:49:19 <shachaf> I meant that if you use criterion to benchmark the Haskell program, you'd want to use it to benchmark the OCaml program too
18:49:30 <shachaf> But you can't, presumably.
18:49:50 <wavewave> copumpkin : where can I find a good tutorial for it?
18:49:52 <cgroza> I really havo no clue how to make that ocaml tail recursive
18:49:55 <copumpkin> not sure
18:50:04 <wavewave> bitbucket homepage does not have usage tutorial.
18:50:44 <wavewave> hmm. probably haddock document has it.
18:51:25 * wavewave is going to try criterion as Criterion.Main shows. 
18:51:31 <rwbarton> cgroza, the easy thing to do would be to just print the lines in remove_duplicate_lines rather than returning a list
18:51:49 <cgroza> rwbarton: thanks
18:52:15 <shachaf> Alternatively, you could simulate laziness in OCaml to make the comparison fairer. :-)
18:52:24 <shachaf> (Where by "fairer" I mean "less fair".)
18:52:41 <mzero> any horror-stories / happy-stories from using GHC 7.2 (or later) running on Mac OS X 7 (Lion) and Xcode 4.1?
18:52:59 <shachaf> mzero: I've heard almost exclusively horror-stories.
18:53:02 <shachaf> But they're all second-hand.
18:53:22 <eduardo> is there a function similar to scanl1 that can output the real values (accumulated) instead of the middle values?
18:54:00 <eduardo> in this code: takeWhile (<= 10) $ scanl1 (+) [1..100]
18:54:01 <parcs> mzero: in general 7.2 fails to compile a bunch of hackage packages due to dependency issues
18:54:13 <dylukes> > takeWhile (<= 10) $ scanl1 (+) [1..100]
18:54:14 <lambdabot>   [1,3,6,10]
18:54:27 <dylukes> > takeWhile (<= 50) $ scanl1 (+) [1..100]
18:54:28 <lambdabot>   [1,3,6,10,15,21,28,36,45]
18:54:29 <eduardo> it doesn't output like: [1,2,3,4]
18:54:37 <wavewave> foldl1?
18:54:39 <eduardo> just the middle ones
18:54:45 * edwardk waves hello.
18:54:51 <dylukes> edwardk: hiya
18:54:54 <shachaf> eduardo: If you want [1,2,3,4], why use scanl?
18:54:55 <wavewave> hello!
18:55:03 <eduardo> wavewave, foldl1 just return 1 value, isn't it?
18:55:05 <copumpkin> > scanl1 (+) [1,3..]
18:55:06 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
18:55:21 <wavewave> eduardo: I didn't understand your question well.
18:55:38 <mzero> I don't either, - what are the "middle values"?
18:56:04 * hackagebot peggy 0.1.2 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.1.2 (HideyukiTanaka)
18:56:16 <cgroza> parcs: your version is 0.600 faster than mine.
18:56:19 <rwbarton> it seems he wants to compute the longest prefix of [1..100] whose sum is at most 10
18:56:25 <cgroza> how did you do it?
18:56:33 <wavewave> cgroza: lol
18:56:36 <mzero> do you mean, eduardo, you want the values take to produce that stream, but you want the test to be on the scanl1 result?
18:56:38 <mzero> something like
18:56:50 <wavewave> cgroza : use nub?
18:57:16 <eduardo> wavewave, probably I didn't explain it well in the first place. I'm trying to extract the elements on a list that fulfill the condition. In the example above I would like to take the elements 'until' having 10 (by addition).
18:57:20 <Jafet> eduardo: okay, "real value" is a really terrible way to talk about the original values
18:57:32 <Jafet> People start thinking about fake values, or complex values
18:57:42 <eduardo> Jafet, my bad
18:57:46 <wavewave> zip it and filter it
18:58:12 <Jafet> > map fst . takeWhile ((<=10).snd) . ap zip (scanl1 (+)) $ [1..100]
18:58:12 <shachaf> Or just filter on ((<=10) . f)
18:58:14 <lambdabot>   [1,2,3,4]
18:58:19 <shachaf> Oh, wait, never mind.
18:58:20 <mzero> > map first $ zip [1..] $ takeWhile (<=50) $ scanl1 (+) [1..]
18:58:21 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
18:58:21 <lambdabot>    arising from a use of `Control...
18:58:55 <mzero> > map fst $ zip [1..] $ takeWhile (<=50) $ scanl1 (+) [1..]
18:58:56 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:59:28 <eduardo> :O
18:59:37 <eduardo> far more complex than I thought
18:59:42 <wavewave> so lovely fast haskell people.
19:00:12 <eduardo> mzero, impressive
19:00:16 <mzero> Jafet's solution is notable for being point-free... but I probably wouldn't use ap in that way
19:00:30 <Jafet> ap zip f is a common phrase.
19:00:49 <mzero> once one reaches a certain level!  :-)   not sure I'm there yet
19:00:56 <eduardo> Jafet, thanks
19:01:11 <eduardo> I'm not used to point-free notation yet
19:01:13 <mzero> :t ap zip
19:01:14 <lambdabot> forall a b. ([a] -> [b]) -> [a] -> [(a, b)]
19:01:54 <Jafet> Confound your enemies by replacing ap with <*> (but not in lambdabot)
19:02:03 <Jafet> Well, you can confound them more in lambdabot
19:02:27 <mzero> beware the lambdabot, my boy
19:02:43 <mzero> the arrows that scratch, the applicatives that bite
19:02:45 <shachaf> lambdabot: The ultimate confoundment tool
19:03:46 <mzero> beware the comonad, and the curious Prelude-ite
19:04:45 <copumpkin> :t scanl
19:04:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
19:05:35 <copumpkin> @src scanl1
19:05:35 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
19:05:36 <lambdabot> scanl1 _ []     =  []
19:05:40 <copumpkin> Cale: I think that's wrong
19:05:46 <copumpkin> oh, I guess not
19:06:11 <Cale> > scanl1 undefined []
19:06:11 <lambdabot>   []
19:06:26 <Cale> > scanl1 f [1,2,3]
19:06:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:06:27 <lambdabot>    `SimpleReflect.FromExpr ...
19:06:33 <Cale> > scanl1 f [1,2,3] :: [Expr]
19:06:34 <lambdabot>   [1,f 1 2,f (f 1 2) 3]
19:06:43 <Cale> > scanl f 1 [2,3] :: [Expr]
19:06:44 <lambdabot>   [1,f 1 2,f (f 1 2) 3]
19:07:02 <mzero> can one find out what modules are loaded into Lambdabot?
19:07:15 <mzero> I know it's got some hyper-Prelude like thing, right?
19:07:18 <mzero> :t .
19:07:18 <DanBurton> @wiki lambdabot
19:07:18 <lambdabot> http://www.haskell.org/haskellwiki/lambdabot
19:07:18 <lambdabot> parse error on input `.'
19:07:19 <Cale> mzero: If by 'one' you mean 'Cale' then yes.
19:07:24 <mzero> :t (.)
19:07:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:07:26 <shachaf> mzero: You can look for a copy of L.hs.
19:07:32 <shachaf> mzero: It's not guaranteed to be correct.
19:07:32 <mzero> see!
19:07:33 <eduardo> Jafet, in 'ap zip', 'ap' is from Control.Monad, right?
19:07:56 <eduardo> if that's so, why using monads in that example?
19:08:04 <shachaf> Either that or Ntrol.Comonad.
19:08:13 <wavewave> (r -> ) is  a monad.
19:08:28 <shachaf> (r ->) is a lot like a box.
19:08:30 <Jafet> shachaf is ntrolling
19:08:50 <hpaste> Cale pasted “Pristine.hs” at http://hpaste.org/51768
19:09:01 <wavewave> function applied to an argument already
19:10:12 <Cale> mzero: ^^
19:10:25 * BMeph wonders if shachaf is co-remote ntrolling...
19:10:33 <mzero> thank you
19:10:45 * mzero off to compose silly poem now
19:10:49 <shachaf> GHC Core motentroll?
19:11:20 <shachaf> Cale: Why is Rec a record and not Mu?
19:11:47 <Cale> shachaf: No good reason
19:11:55 <Cale> I think mainly because the Show instance for Mu matters.
19:11:57 <shachaf> Cale: Is there any good reason you can't @let data types, by the way?
19:12:34 <Cale> shachaf: hmm...
19:16:08 <Jafet> eduardo: you may want to work out why ap on the function monad is equivalent to K, (\f g x -> f x (g x)).
19:16:19 <Jafet> @pl (\f g x -> f x (g x))
19:16:19 <lambdabot> ap
19:16:37 <shachaf> Jafet: Because that's how it's defined?
19:16:41 <shachaf> Oh, ap, not <*>.
19:16:47 <DanBurton> cuz lambdabot says so
19:16:56 <shachaf> @unpl ap
19:16:56 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
19:17:05 <DanBurton> @src ap
19:17:05 <lambdabot> ap = liftM2 id
19:17:05 <shachaf> @@ @pl @unpl ap
19:17:06 <lambdabot>  (. ((. (return .)) . (>>=))) . (>>=)
19:17:22 <shachaf> @@ @pl @unpl @pl @unpl @pl @unpl @pl @unpl @pl @unpl ap
19:17:23 <lambdabot>  (. ((. (return .)) . (>>=))) . (>>=)
19:17:23 <shachaf> Aw.
19:17:28 <wavewave> Jafet: equivalent to S, you mean?
19:17:54 <DanBurton> looks like lisp
19:17:58 <Maxdamantus> @@ @unpl @pl \a b c -> c b a
19:17:58 <lambdabot>  (\ b c f -> f c b)
19:18:17 <incluye> @pl (\b c f -> f c b)
19:18:18 <lambdabot> flip (flip . flip id)
19:18:35 <Maxdamantus> @pl \a b c d e f g -> g f e d c b a
19:18:36 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
19:18:41 <incluye> jesus
19:18:48 <timemage> heh
19:18:49 <wavewave> pl means pointless?
19:18:59 <incluye> yes
19:19:14 <eduardo> wouldn't be the same as using liftMn in that case?
19:19:15 <Maxdamantus> A pun on "point-free"
19:20:14 <incluye> @pl (\f a b c -> (\_ -> f a b c))
19:20:15 <lambdabot> (((const .) .) .)
19:21:09 <wavewave> btw, other language channels have bot like lambdabot?
19:21:14 <MichaelBurge> Under what restrictions can a Haskell function be made into pointfree form?
19:21:16 <DanBurton> @unpl (.) . (.)
19:21:16 <lambdabot> (\ i b c f -> i (b c f))
19:21:16 <incluye> most do
19:21:29 <incluye> but they're not as advanced as lambdabot usually
19:21:31 <Maxdamantus> @@ @unpl @pl \a b c d e f g h i j k l m n o p -> p o n m l k j i h g f e d c b a
19:21:34 <incluye> because they don't need to be :3
19:21:34 <lambdabot>  Parse error at end of input
19:21:40 <eduardo> > ((.)$(.))
19:21:41 <lambdabot>   Overlapping instances for GHC.Show.Show
19:21:41 <lambdabot>                              (f (a ...
19:21:44 <Jafet> MichaelBurge: when you have combinators for everything that the function does
19:21:52 <incluye> @unpl ((.)$(.))
19:21:53 <lambdabot> (\ b c e f -> b c (e f))
19:21:56 <eduardo> ah
19:21:57 <Jafet> @pl (\a b c -> (a,b,c))
19:21:57 <lambdabot> (,,)
19:22:05 <wavewave> incluye: I guess so.. it is very hard to be an one-liner in other language.
19:22:06 <Jafet> @pl (\(a,b,c) -> c)
19:22:07 <lambdabot> (line 1, column 7):
19:22:07 <lambdabot> unexpected ","
19:22:07 <lambdabot> expecting letter or digit, operator or ")"
19:22:07 <lambdabot> ambiguous use of a non associative operator
19:22:09 <shachaf> @ty (.) (.) (.) (.) (.) (.) (.) (.) const
19:22:10 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a (f2 :: * -> *) b. (Functor f, Functor f1, Functor f2) => f (f1 (f2 a)) -> f (f1 (f2 (b -> a)))
19:22:38 <mauke> MichaelBurge: I think when it doesn't do any pattern matching
19:23:28 <eduardo> @pl ((.).(.))
19:23:28 <lambdabot> (.) . (.)
19:23:55 <eduardo> @unpl ((.).(.))
19:23:56 <lambdabot> (\ i b c f -> i (b c f))
19:23:56 <DanBurton> @unpl (. (. (. f)))
19:23:56 <lambdabot> (\ c g -> c (\ j -> g (\ m -> j (f m))))
19:23:57 <incluye> @pl \a b c -> (c,b,a)
19:23:57 <lambdabot> flip (flip . flip (,,))
19:24:30 <jmcarthur> @pl \op a b c -> (a `op` b) `op` c
19:24:30 <lambdabot> (.) =<< (.)
19:24:40 <DanBurton> @unpl flip . flip
19:24:40 <lambdabot> (\ i b c -> i b c)
19:24:55 <DanBurton> doh
19:25:16 <shachaf> @ty (.) >=> (.)
19:25:17 <lambdabot> forall a b. (a -> b) -> (a -> a) -> a -> b
19:25:17 <wavewave> DanBurton : Z2 symmetry.
19:25:19 <DanBurton> @unpl flip (flip . flip f)
19:25:20 <lambdabot> (\ b c g -> f g c b)
19:25:26 <jmcarthur> :t (.) =<< (.)
19:25:27 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> f (f a)
19:25:46 <incluye> @unpl (.) >>= (.) =<< (.)
19:25:46 <lambdabot> ((\ a b c -> a (b c)) >>= ((\ g h i -> g (h i)) >>= \ d e f -> d (e f)))
19:25:55 <jmcarthur> :t (Prelude..) =<< (Prelude..)
19:25:56 <lambdabot> forall a a1. (a -> a1 -> a) -> a -> a1 -> a1 -> a
19:26:16 <MichaelBurge> @pl f a b c | a > 2 && b > 2 && c > 2 = if a*a + b*b == c*c then True else False
19:26:17 <lambdabot> (line 1, column 35):
19:26:17 <lambdabot> unexpected "="
19:26:17 <lambdabot> expecting variable, "(", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`", "&&", "***", "&&&", "<|>" or end of input
19:26:22 <DanBurton> TIL judicious use of flip and . is all you need to reorder the arguments of a function
19:26:44 <MichaelBurge> @pl f a b c = if a > 2 && b > 2 && c > 2 then if (a*a + b*b == c*c) then True else False else False
19:26:46 <lambdabot> f = flip flip False . (flip .) . ap (ap . (liftM2 if' .) . (. ((. (> 2)) . (&&) . (> 2))) . (.) . (&&) . (> 2)) (flip flip False . (flip .) . flip flip True . ((flip . (if' .)) .) . flip flip (join (
19:26:46 <lambdabot> *)) . (((.) . (==)) .) . (. join (*)) . (+) . join (*))
19:27:11 <MichaelBurge> Is there a way to say, "Getting this into pointfree form is equivalent to Fermat's Last theorem", or similarly silly things? :P
19:27:21 <wavewave> @src if'
19:27:21 <lambdabot> Source not found.
19:27:31 <DanBurton> :t if'
19:27:32 <lambdabot> Not in scope: `if''
19:27:45 <jmcarthur> @let if' p a b = if p then a else b
19:27:46 <lambdabot>  Defined.
19:27:50 <ddarius> @pl ap id id $ ap id id
19:27:50 <JoeyA> > (map green_glass_doors . words) "green glass doors"
19:27:51 <lambdabot>   Not in scope: `green_glass_doors'
19:27:53 <lambdabot> ap id id $ ap id id
19:27:53 <lambdabot> optimization suspended, use @pl-resume to continue.
19:27:56 <shachaf> MichaelBurge: Converting lambda calculus to SK form is trivial.
19:28:20 <DanBurton> ddarius: that was already written pointfree
19:28:25 <incluye> How does @pl work, anyway?
19:28:34 <shachaf> Magic.
19:28:39 <MichaelBurge> incluye: Trivially, it seems
19:28:49 <shachaf> MichaelBurge: No, @pl is less trivial.
19:28:51 <incluye> Seems weird.
19:28:54 <shachaf> Particularly if it was better.
19:29:05 <ddarius> DanBurton: You need to read everything lambdabot says.
19:29:09 <MichaelBurge> "sk form" being the s and k functions in unlambda?
19:29:22 <shachaf> ddarius would probably say that @pl is an optimizing compiler, and a bad one.
19:29:36 <ddarius> compiler -to combinators-
19:29:46 <shachaf> Right.
19:30:45 <mauke> MichaelBurge: yes
19:30:49 <mauke> s = ap, k = const
19:32:02 <DanBurton> @let (s,k) = (ap, const)
19:32:03 <lambdabot>  <local>:7:9:
19:32:03 <lambdabot>      Ambiguous type variable `m' in the constraint:
19:32:03 <lambdabot>        `Mon...
19:32:23 <DanBurton> @let s = ap
19:32:24 <lambdabot>  Defined.
19:32:27 <DanBurton> @let k = const
19:32:28 <lambdabot>  Defined.
19:32:36 <DanBurton> @let i = id
19:32:37 <lambdabot>  Defined.
19:32:42 <mauke> @undefine
19:32:50 * wavewave wonders if point-free style is useful in computer algebra system. 
19:33:01 <Jafet> > s
19:33:02 <lambdabot>   s
19:33:24 <DanBurton> undefined xP
19:34:24 <Axman6> :t s k k
19:34:25 <lambdabot>     Couldn't match expected type `Expr -> Expr -> t'
19:34:25 <lambdabot>            against inferred type `Expr'
19:34:25 <lambdabot>     In the expression: s k k
19:34:30 <Axman6> you suck -_-
19:34:37 <Axman6> @let ss = ap
19:34:38 <lambdabot>  Defined.
19:34:42 <Axman6> @let kk = const
19:34:43 <lambdabot>  Defined.
19:34:48 <Axman6> @let ii - id
19:34:48 <lambdabot>   TemplateHaskell is not enabled
19:34:50 <Axman6> @let ii = id
19:34:51 <lambdabot>  Defined.
19:34:58 <Axman6> :t ss kk kk
19:34:59 <lambdabot> forall b. b -> b
19:35:05 <wavewave> good.
19:35:22 <wavewave> what happend in :t s k k ??
19:35:26 <DanBurton> now write y
19:35:27 <wavewave> :t s k k
19:35:28 <lambdabot>     Couldn't match expected type `Expr -> Expr -> t'
19:35:28 <lambdabot>            against inferred type `Expr'
19:35:28 <lambdabot>     In the expression: s k k
19:36:27 <DanBurton> wavewave: mauke undefined it
19:36:35 <mauke> DanBurton: that's not what happened there
19:36:43 <mauke> wavewave: s isn't a function
19:37:08 <wavewave> :t s
19:37:09 <lambdabot> Expr
19:37:16 <DanBurton> > s
19:37:17 <lambdabot>   s
19:37:17 <wavewave> :t ss
19:37:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:37:51 <wavewave> @let s = ap
19:37:52 <lambdabot>  Defined.
19:37:57 <wavewave> :t s
19:37:57 <mauke> @undefine
19:37:58 <lambdabot> Expr
19:38:08 <wavewave> huk
19:38:22 <mauke> ok, could you please stop trying to break lambdabot?
19:38:48 <DanBurton> mauke: what's wrong with @let s = ap ?
19:38:56 <mauke> DanBurton: there already is an s
19:39:41 <DanBurton> mauke: so the lowercase letters a through z are already defined as expressions?
19:39:46 <mauke> yes
19:40:05 * wavewave is going to install lambdabot and play with it tonight.
19:40:17 <mauke> @let (+)@(-)@(==)@(/=)@(.)@map@filter@fmap@foldr@foldl@foldr1@foldl1@foldl' = 1
19:40:18 <lambdabot>  .L.hs:87:6:
19:40:18 <lambdabot>      Ambiguous occurrence `fmap'
19:40:18 <lambdabot>      It could refer to either `...
19:40:39 <mauke> @let (+)@(-)@(==)@(/=)@(.)@map@filter@foldr@foldl@foldr1@foldl1@foldl' = 1
19:40:39 <lambdabot>  <local>:1:18:
19:40:39 <lambdabot>      Multiple declarations of `L..'
19:40:40 <lambdabot>      Declared at: .L.hs:87...
19:40:44 <ddarius> f is not an expression
19:40:44 <mauke> aww
19:40:46 <ddarius> :t f
19:40:47 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:40:51 <mauke> > f :: Expr
19:40:52 <lambdabot>   f
19:40:55 <ddarius> :t s
19:40:56 <lambdabot> Expr
19:41:01 <ddarius> > s s
19:41:02 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr -> t'
19:41:03 <lambdabot>         against infe...
19:41:03 <ddarius> > f f
19:41:04 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:41:04 <lambdabot>    `GHC.Show.Show a'
19:41:04 <lambdabot>      a...
19:41:05 <mauke> > [f, s, f]
19:41:06 <lambdabot>   [f,s,f]
19:41:17 <ddarius> > f f :: Expr
19:41:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:41:18 <lambdabot>    `GHC.Show.Show a'
19:41:18 <lambdabot>      a...
19:41:31 <wavewave> so this lambdabot must be the same as that on hackage.
19:42:28 <DanBurton> @let yCombinator = let (s, k) = (ap, const) in s s k (s (k (s s (s (s s k)))) k)
19:42:29 <lambdabot>  <local>:1:44:
19:42:29 <lambdabot>      Occurs check: cannot construct the infinite type:
19:42:29 <lambdabot>        ...
19:44:20 <shachaf> DanBurton: You can't express Y in Haskell like that.
19:44:46 <DanBurton> shachaf: what's wrong with it?
19:44:52 <shachaf> It don't type check.
19:45:08 <shachaf> Y is a bit of an evil function.
19:45:10 <DanBurton> then how is it correct?
19:45:16 <shachaf> It's not correct!
19:45:20 <DanBurton> o_O
19:45:27 <mauke> DanBurton: lambda calculus has no type system
19:45:34 <wavewave> it exists only in untyped lambda calculus
19:45:36 <shachaf> > let correct = "terminating" in correct
19:45:37 <lambdabot>   "terminating"
19:45:40 <mauke> or rather, all values have the same type, which is recursive
19:45:53 <mauke> haskell doesn't allow recursive types
19:45:56 <DanBurton> ah
19:46:02 <shachaf> mauke: Sure it does.
19:46:17 <mauke> only using 'data' wrappers
19:46:23 <shachaf> Right.
19:46:28 <ddarius> Haskell doesn't allow equirecursive types.
19:46:28 <wavewave> using rankNtype?
19:46:33 <shachaf> And you can express Y if you're willing to allow type-level recursion.
19:46:41 <mauke> f :: a@(a -> a)
19:46:44 <DanBurton> :t fix
19:46:45 <lambdabot> forall a. (a -> a) -> a
19:46:57 <shachaf> I wonder if equirecursive types are a huge mess.
19:47:34 <DanBurton> is lambdabot going to do data decls now that ghci does them?
19:47:50 <shachaf> Maybe, but if so it won't be related.
19:47:58 <shachaf> lambdabot isn't ghci and doesn't use ghci.
19:48:07 <copumpkin> dcoutts_: is there some way to ask cabal init not to fill the .cabal file with comments that I've almost learned by heart? :)
19:48:22 <DanBurton> i figured they might fall back on the same libraries
19:48:37 <copumpkin> dcoutts_: oh, nevermind, --no-comments!
19:48:52 <shachaf> copumpkin: :%g/^\s\*--/d
19:49:04 <shachaf> Wait, no %.
19:49:34 <mauke> redundant but ok
19:49:46 <mauke> but the \* is wrong
19:49:50 <shachaf> mauke: Right.
19:49:56 * shachaf will never get the hang of vim's weird regexps.
19:52:21 <JoeyA> Is anyone else having trouble building bytestring-0.9.2.0 ?
19:52:34 <JoeyA> I'm getting cabal: bytestring.cabal:70: The 'type' field is required for test suites. ...
19:52:39 <parcs> shachaf: just remember to escape all control characters
19:52:49 <shachaf> parcs: ?
19:52:50 <JoeyA> And the type field is there...
19:53:59 <parcs> shachaf: never mind :P
19:56:18 <parcs> _some_ control characters, like [ and ] must be escaped in order to be recognized as control characters
19:57:13 <parcs> wait i think that only applies in syntax files
19:57:45 <geheimdienst> shachaf: just check out the table in the section ":help magic", it clears up the vim regexes nicely
19:57:58 * shachaf would rather be eternally confused.
19:58:36 <monochrom>  :help hogwarts
19:58:57 <geheimdienst> (that was not a joke, by the way, it's really called magic)
20:00:34 <jmcarthur> copumpkin: i just always use  cabal init -m
20:06:04 * hackagebot rex 0.2 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.2 (MichaelSloan)
20:20:13 <MichaelBurge> Ubuntu's "haskell-platform" package comes with 6.12.3, and I need 7.03 or later to compile the latest platform. What's the easiest way to update my Haskell on Ubuntu?
20:21:31 <tensorpudding> well
20:21:37 <tensorpudding> 7 will be in 11.10
20:21:42 <tensorpudding> so you can wait a month
20:22:04 <MichaelBurge> Is the package ready now in some testing repository somewhere?
20:22:27 <tensorpudding> otherwise you might find a PPA somewhere
20:22:44 <tensorpudding> or just grab the source package from oneiric and build it on natty
20:22:58 <tensorpudding> the deps are probably compatible
20:23:01 <monochrom> my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml is the easiest way IMO
20:23:46 <shachaf> monochrom: Whence "trebla"?
20:24:23 <monochrom> reverse "albert"
20:24:28 <shachaf> Ah.
20:26:22 <JoeyA> I'm sure I asked this just a few days ago, so sorry if I sound like a broken parrot: what is the best editor for writing Haskell (on Linux)?
20:26:38 <JoeyA> Of vim and emacs, which is generally better for Haskell.
20:26:46 <smop_> i would say vim
20:26:51 <smop_> but i use sublime text
20:26:51 <JoeyA> why so?
20:26:59 <parcs> i would say emacs because haskell-mode
20:26:59 <dolio> Emacs is probably better.
20:27:05 <monochrom> I use emacs. I don't know why.
20:27:08 <dolio> Unless you simply like vim better.
20:27:17 <dolio> Emacs has significantly more tool support, though.
20:27:18 <parcs> and this: http://hackage.haskell.org/package/ghc-mod
20:27:20 <geheimdienst> JoeyA: use the one you're most comfortable with
20:27:20 <JoeyA> I know vim better.
20:27:22 <monochrom> I also don't actually know what is best.
20:27:25 <shachaf> JoeyA: That's a ridiculous question, pretty much.
20:27:28 <MichaelBurge> I used Kate when starting out, and use Emacs now
20:27:35 <shachaf> We don't have anything close to a total ordering on editors.
20:27:38 <monochrom> but do upload your brain for a free analysis!
20:27:41 <JoeyA> I've been using Kate.
20:27:52 <shachaf> When you ask "what's the best X", there's almost always no answer to that question.
20:27:55 <geheimdienst> JoeyA: if you know vim better, then vim it is, unless there's some big obstacle
20:28:00 <JoeyA> I have a love-hate relationship with Kate's automatic indentation for Haskell, and I can't turn it off.
20:28:17 <JoeyA> but I find it to be a slight net improvement in productivity
20:28:18 <monochrom> if you write your own editor, it's the best
20:28:24 <dolio> I haven't used kate in a while.
20:28:28 <dolio> Vim has okay indenting.
20:28:31 <shachaf> monochrom++
20:28:33 <dolio> Emacs has pretty good indenting.
20:28:38 <shachaf> Some people don't use autoindent at all.
20:28:41 <JoeyA> Last time I tried to learn emacs, I read a tutorial telling me how to use qwerty keys instead of arrow keys.
20:28:46 <JoeyA> (to navigate)
20:28:46 <bfig_> what do you like more, emacs or vim?
20:28:54 <shachaf> JoeyA: Right, arrow keys are evil.
20:29:00 <monochrom> I use arrow keys in emacs exclusively
20:29:08 <shachaf> (Emacs keys are also evil, but oh well.)
20:29:13 <JoeyA> even to select characters?
20:29:17 <shachaf> monochrom: How do you enter text using arrow keys?
20:29:28 <monochrom> in fact, it's in vi when I use the hjkl keys!
20:29:52 <monochrom> enter text?! I speak to the computer
20:30:23 <JoeyA> I'm switching back to qwerty from dvorak anyway, so qwerty navigation should at least be palatable now.
20:30:32 <monochrom> in fact, I have abandoned vim for nano
20:30:33 <dolio> I use Vim these days, though.
20:30:39 <dolio> Everyone at work uses it.
20:30:48 <dolio> And I kind of like the editing in Vim better than emacs.
20:30:49 <shachaf> Even for Agda?
20:30:52 <dolio> The modes and stuff.
20:30:57 <dolio> No, for Agda it's emacs.
20:30:58 <shachaf> dolio: Vim doesn't have modes!
20:31:04 * hackagebot ParserFunction 0.0.4 - Utilities for parsing and evaluating string-expressions.  http://hackage.haskell.org/package/ParserFunction-0.0.4 (EnzoHaussecker)
20:31:10 <JoeyA> What's a good setup for Haskell indentation in vim?
20:31:11 <shachaf> It has commands, including an Esc-terminated insert command.
20:31:15 <dolio> Agda you're forced into it.
20:31:56 <bfig> what do you like more, emacs or vim?
20:32:00 <ddarius> shachaf: "Press i followed by the text you want to insert to insert text.  Terminate this with Esc or Ctrl-C."
20:32:37 <shachaf> ddarius: Right. It's a command.
20:32:50 <shachaf> E.g. you can press 3iabc<Esc> to enter abcabcabc
20:33:21 <geheimdienst> more usefully, you can do 72i-<Esc>
20:33:32 <shachaf> You mean 80i-
20:33:58 <geheimdienst> 999999i- # my line is longer than your line
20:34:21 <shachaf> Inserting 80 dashes is easy in irssi
20:34:53 <shachaf> -----<C-w><C-y><C-y><C-w><C-y><C-y><C-w><C-y><C-y><C-w><C-y><C-y>
20:34:56 <monochrom> you can pretend every modal UI to be modeless by that mind trick. you are not new to this though. the denotational semantics people have long figured out this trick for turning stateful programming languages into purely functional semantic functions
20:35:36 <shachaf> monochrom: The issue isn't that you pretend it, it's that it's a better way to think about vi.
20:35:58 <geheimdienst> shachaf: i just tried to understand that as vim commands. it didn't work so good.
20:36:11 <dolio> What happens when I do 3iab  and then click somewhere else on the screen, and type c<Esc>?
20:36:37 <shachaf> dolio: The argument is ignored.
20:36:38 <Axman6> shachaf: :o i had no idea
20:36:46 <monochrom> keyboard junkies say you aren't supposed to click, ever
20:36:48 <shachaf> That's because clicking or moving around "in insert mode" is evil.
20:37:17 <shachaf> You can click, just not in the middle of an insert command. :-)
20:37:20 <shachaf> Axman6: About what?
20:37:36 <Axman6> that you could paste stuff in irssi. i assume those are emacs bindings?
20:37:41 <geheimdienst> Axman6: c-y does something vaguely useful in shells too
20:37:44 <monochrom> anyway, I insist that it's pretense
20:38:20 <shachaf> irssi gets slow once you get a few MB in the paste/input buffer.
20:39:04 <shachaf> That's true. Real Programmers have a mouse in one hand and a keyboard under the other.
20:39:05 <dolio> What happens when I 3<Ctrl-v>?
20:39:18 <monochrom> wait, C-y and C-w are supposed to be emacism...
20:39:28 <dolio> Or 3v
20:39:31 <dolio> Or 3V
20:39:52 <dolio> Or is visual mode also evil?
20:39:54 <shachaf> Hmm, I'm not sure what v does with its argument.
20:39:59 <geheimdienst> dolio: uh, C-v triggers block highlight mode?
20:40:05 <dolio> Yes.
20:40:16 <dolio> The answer is, 3v causes a bell.
20:40:37 <shachaf> dolio: It also selects some text.
20:40:51 <dolio> No.
20:40:57 <shachaf> Mine does.
20:41:23 <geheimdienst> i find the bell reasonable. what would "highlight three times" even mean ...
20:41:44 <shachaf> In particular, <num>v selects 5*num columns to the right of the cursor.
20:42:21 <geheimdienst> shachaf: i suspect your bindings are weird
20:42:34 <shachaf> Maybe, but :map isn't showing anything for v.
20:43:55 <cads> Guys, is it straightforward to explain how to recover a mathematical monad triple from the return and bind functions of a haskell monad?
20:43:57 <shachaf> Hmm.
20:44:14 <shachaf> dolio: If you select some text and do something to it, and *then* run v with an argument, it selects n*the length of that text.
20:44:17 <shachaf> Apparently.
20:45:02 <monochrom> yes cads, there are formulas for that
20:45:21 <shachaf> «If Visual mode is not active and the "v", "V" or CTRL-V is preceded with a count, the size of the previously highlighted area is used for a start.>>
20:45:25 <monochrom> and I misread as "guys, is it straightforward to recover from learning monads"
20:45:27 <shachaf> s/..$/»/
20:45:33 <geheimdienst> shachaf: yeah, now i can reproduce what you're saying
20:45:43 <companion_cube> @where lyah
20:45:43 <lambdabot> http://www.learnyouahaskell.com/
20:45:53 <monochrom> @src join
20:45:54 <lambdabot> join x =  x >>= id
20:45:59 <monochrom> that's one formula
20:46:18 <monochrom> @src liftM
20:46:19 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:46:40 <monochrom> that's the formula for fmap if you desugar the do-notation
20:46:50 <monochrom> and you retain return, that's all
20:47:58 <shachaf> You can never escape having learned monads.
20:48:18 <shachaf> If you learn two monads, though, you can go back to only knowing one.
20:48:32 <monochrom> hahahahaha
20:48:56 <mzero> "I see monads.... everywhere."
20:49:24 <monochrom> @remember shachaf You can never escape having learned monads. If you learn two monads, though, you can go back to only knowing one.
20:49:25 <lambdabot> It is forever etched in my memory.
20:49:39 <shachaf> :-(
20:50:00 <monochrom> it's subtle! but once you get it, it's hilarious!
20:50:20 <monochrom> perfect match!
20:50:41 <dolio> shachaf: That's kind of arbitrary behavior.
20:50:51 <shachaf> dolio: The v thing?
20:51:00 <dolio> To make that useful I'd have to actually remember the size of the last thing I selected.
20:51:15 <geheimdienst> dolio: don't use it if you don't like it ...
20:51:18 <shachaf> Almost all of vim is kind of arbitrary behavior.
20:51:23 <dolio> I don't use it.
20:51:29 * shachaf likes how K takes an argument for which man section to look in.
20:51:36 <shachaf> Even though that's ridiculous.
20:51:46 <dolio> I'm curious of who could use it.
20:51:53 * monochrom contemplates @remember shachaf Almost all of vim is kind of arbitrary behavior. :)
20:52:29 <dolio> Yeah, one thing that tripped me up for a while (re)learning vim at work...
20:52:53 <cads> monochrom, which is the functor, and which are the natural tranforms? Forgive me, I'm really rusty in haskell.
20:52:56 <dolio> In one of the visual modes, you can't s to delete and start inserting.
20:53:03 <dolio> You have to S.
20:53:08 <dolio> But only in one of them.
20:53:13 <shachaf> dolio: Which one?
20:53:18 * shachaf can't reproduce in the three that he knows.
20:53:25 <dolio> I think line select.
20:53:39 <dolio> But then I went to Ed's machine, and S didn't work at all.
20:53:42 * shachaf can't reproduce.
20:53:43 <dolio> I had to press c instead.
20:53:49 <shachaf> c is the right one anyway.
20:54:01 <monochrom> The monad type itself is already the functor type. fmap is the functor function. join is the "m (m a) -> m a" guy
20:54:04 * shachaf is annoyed at how c treats w or e differently from d.
20:54:09 * ddarius doesn't use S.
20:54:20 <ddarius> It does?
20:54:20 <geheimdienst> the visual modes have different commands from normal mode anyway. you also need I and A instead of i and a, etc.
20:54:28 <shachaf> Also how Y is not like D or C and the rest of them.
20:54:55 <cads> monochrom: oh neat
20:54:59 <monochrom> join, fmap, return are all required to be natural transformations
20:55:06 <shachaf> ddarius: "[cursor]abc    def"; dw will delete the spaces, cw won't.
20:55:51 * ddarius considers whether he agrees with this behavior or not.
20:56:09 <ddarius> I think it doesn't really matter to me.
20:56:18 <dolio> shachaf: Yeah, it's not behaving the same here, either. Maybe it's windows vim.
20:56:19 <geheimdienst> shachaf: now that you mention it, that's true. but i never was annoyed, or even noticed
20:56:23 * shachaf vaguely wants to write an editor.
20:56:25 <dolio> Except, only on my machine.
20:56:39 <shachaf> Except there's probably a better use of my time.
20:56:45 <shachaf> Like complaining in #haskell.
20:58:07 <geheimdienst> btw, vim users, you have all tried out "set relativenumber", right? it's been added not too long ago
20:58:17 <geheimdienst> (i never went back)
20:58:22 <dolio> What's it do?
20:58:33 <shachaf> Oh, neat.
20:58:47 <dolio> Oh.
20:58:56 <dolio> Why would I want this?
20:59:02 <geheimdienst> dolio: in the line number column, show 0 for the current line ... er yeah
20:59:08 <shachaf> Arguments to line commands.
20:59:15 <geheimdienst> stuff like "18dd" of course!
20:59:49 <mzero> oh - that's fun
21:00:04 <shachaf> There's always d138gg or something like that.
21:00:45 <mzero> would be most nice for >> and << commands
21:00:56 <shachaf> mzero: There's always V.
21:01:08 * ddarius does tend to use V in those situations.
21:01:14 <mzero> visual mode?!?!?!
21:01:34 <mzero> :-)
21:02:18 <shachaf> V also lets you do V5>
21:02:22 <shachaf> Which you can't do with 5>>
21:02:28 <ddarius> This wouldn't help me anyway as I don't have and wouldn't want line numbers.
21:03:04 <geheimdienst> for << i'd rather use block movements (<i{ or some such). and i still think relativenumber is cooler. it's easier to glance at the number column than to enter visual mode and move around
21:03:53 <geheimdienst> shachaf: yeah, but you can use . to repeat, like 4<<....
21:04:07 <dolio> Are there commands that would make the numbers above you useful?
21:04:37 <ddarius> k ...
21:04:40 <shachaf> geheimdienst: >>5. does >>5>> :-(
21:05:03 <ddarius> (or t on my keyboard and Ed's.)
21:05:34 <geheimdienst> shachaf: yeah, . is not repeatable afaik
21:05:54 * ddarius usually uses . rather than counts.
21:05:55 <geheimdienst> what are "numbers above you" and what is k? move up?
21:06:04 * hackagebot peggy 0.1.3 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.1.3 (HideyukiTanaka)
21:06:39 * ddarius also uses dj with . a lot.
21:07:21 <shachaf> dj ~ 2dd ?
21:07:25 <dolio> geheimdienst: With relativenumber enabled, all the lines above you also have positive numbers.
21:07:42 <dolio> Can I delete the n lines above me, as well?
21:07:49 <shachaf> d2k
21:07:49 <dolio> I don't know much vim.
21:07:58 <geheimdienst> oh i see :) yeah, k is something you can use. or what shachaf said
21:08:48 <hpaste> acabad annotated “SDL + joystick woes” with “SDL + joystick woes (annotation)” at http://hpaste.org/51756#a51769
21:09:11 <geheimdienst> ... or <3k or whatever
21:10:42 <ddarius> Having to do @@ rather than just . annoys me.
21:11:08 <shachaf> ddarius: You want grouping of commands so you can . them?
21:11:25 <geheimdienst> is that the macro-repeat thing? i think i've practically never used it
21:11:42 <parcs> my macro is usually named q
21:11:49 <parcs> macros*
21:11:50 <shachaf> Mine, also.
21:11:54 <shachaf> I also tend to :map Q @q
21:12:30 <ddarius> Oddly, I always go in alphabetical order.
21:12:45 <geheimdienst> yeah, but isn't @x for "interpret what's in buffer x as vim commands and run 'em" ... i thought @@ was "repeat the last @x execution"
21:12:49 <zzo38> Do you know of barrier monads? I invented barrier monads but it might be similar to things other people have also invented before. You need two extra types, called the front type and the back type, to make up a barrier monad. These types can be any types (of kind *).
21:12:59 <ddarius> geheimdienst: Yes.
21:13:10 <cads> monochrom: I'm actually having a hard time wrapping my mind around how it works, still. I know a monad in a category C as a triple (T, η, μ), where T : C->C is an endofunctor of C, and for each object A in C, η has components η_A : A -> T(A) , and μ has μ_A : T(T(A)) -> T(A)).
21:13:17 <shachaf> ddarius: Oh, I see, you want . to do an @ command.
21:13:24 <shachaf> Makes sense.
21:13:26 <cads> monochrom:  The only monad I actually know is the powerset monad, where η takes elements into singletons, and μ takes a family of sets into its union.
21:13:42 <ddarius> cads: You don't know the identity monad?
21:13:47 <cads> monochrom:  I think I get that join is μ and return is η. Now, Fmap is the arrow mapping part of T, while the monadic type itself notates the object mapping part of T?
21:14:02 <cads> ddarius: hah, I think I do now
21:14:16 <zzo38> You have the normal monad operations (unit, map, join, bind, and Kleisli composition), but you also have these operations (in addition to your own operations for your use): convert, rebind, yield, approach, continue, collect, perform, and operate.
21:14:24 <monochrom> fmap is the arrow mapping part of T, yes
21:14:36 <zzo38> I know a few things about category theory, but I don't know it perfectly.
21:14:44 <monochrom> the rest is also right
21:15:21 <cads> hah
21:15:58 <ddarius> geheimdienst: Now make yourself a lambda calculus interpreter in vim macros.
21:16:36 <geheimdienst> gnawing off my arm would be equally entertaining
21:16:52 <zzo38> I believe (return .) and (<=<) can also form a monad, since I have figured out unit/join/fmap from these?
21:17:24 <copumpkin> zzo38: they form a category
21:17:42 <copumpkin> the two extra type parameters you mention sound a bit like indexed monads
21:17:59 <copumpkin> but without type signatures for all your extra operations, I can't really tell much from just the names
21:18:15 <zzo38> copumpkin: Yes I know, use (return .) for a morphism into the Kleisli category, and (<=<) for composition.
21:18:24 <copumpkin> just return
21:18:45 <zzo38> return . id = return
21:19:04 <cads> thanks monochrom!
21:19:15 <cads> I think I'll understand monads, yet :)
21:19:18 <copumpkin> :t (return .)
21:19:19 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
21:19:24 <copumpkin> :t (return Prelude..)
21:19:25 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
21:19:39 <copumpkin> that's an injection from Hask in the m's Kleisli category
21:20:04 <copumpkin> *into
21:20:59 <zzo38> I can put type of my extra operations if you want it:   convert :: (f -> f') -> (b' -> b) -> Barrier f b t -> Barrier f' b' t;   rebind :: (f -> Barrier f' b b) -> Barrier f b t -> Barrier f' b t;   yield :: f -> Barrier f b b;   approach :: Barrier f b t -> Maybe f;   continue :: Barrier f b t -> b -> Barrier f b t;   collect :: Barrier f () t -> [f];
21:21:04 <cads> I think I need to understand Hask better before I can really understand monads in haskell.
21:21:14 <zzo38> perform :: (f -> s -> (b, s)) -> (String -> s -> o) -> (t -> s -> o) -> s -> Barrier f b t -> o;   operate :: Monad m => (f -> m b) -> Barrier f b t -> m t;
21:21:31 <ddarius> cads: Good luck.
21:21:39 <copumpkin> wait, if barrier monads are like monads, aren't they a typeclass?
21:22:18 <zzo38> copumpkin: No, they are monads! You just need two extra types, the front type and the back type: instance Monad (Barrier f b) ...
21:22:27 <copumpkin> oh, I see
21:22:30 <copumpkin> so it's another monad instance
21:22:37 <copumpkin> it's not a fancier monad class
21:22:56 <copumpkin> have you checked you satisfy the laws?
21:23:17 <copumpkin> the sheriff of categoria will arrest you if you don't
21:23:23 <KirinDave> New game
21:23:24 <KirinDave> https://github.com/imikimi/monotable/tree/master/lib/monotable
21:23:33 <ddarius> Presumably you have data Barrier f b a = ... somewhere.
21:23:44 <KirinDave> you have 45 lines of haskell to meet or exceed the functionality of this code. God.
21:23:55 <KirinDave> (import statements and type decls are excluded)
21:24:06 <zzo38> copumpkin: Yes, I have thought of that. And in fact, it works as far as I can tell; I know the laws work in the cases I have proved it on. I believe work all cases.
21:24:14 <zzo38> ddarius: Yes I do have that.
21:24:35 <copumpkin> KirinDave: I don't want to figure out everything it does in a dozen files :P
21:24:52 <KirinDave> copumpkin: I am just giving you the rules.
21:25:18 <ddarius> Ruby?  Fuck that shit.
21:25:25 <KirinDave> copumpkin: While also making fun of my former comrades.
21:25:25 <copumpkin> why does someone want to write a database in ruby, anyway?
21:25:29 <copumpkin> KirinDave: aha :)
21:25:47 <KirinDave> copumpkin: Because from the right angle, everything can be projected into a shape bearing resembles to a nail.
21:25:57 <copumpkin> ah, fair enough
21:26:01 <KirinDave> And they have this treasured hammer, you see.
21:26:08 <copumpkin> see, I'm pretty sure that even when I was a ruby nut, I wouldn't have wanted to write a database in ruby
21:26:28 <KirinDave> You would if you think ruby cannot have memory leaks due to closures and scope.
21:27:11 <zzo38> I have written databases in C, in Forth, even in QBASIC.
21:27:47 <cads> wait this isn't some kind of database ORM tool or what have you? This is an actual database?
21:27:58 <monochrom> in Soviet Russia, you have current-continuation-calls-procedure (CCCP)
21:28:09 <shachaf> monochrom++
21:28:26 <mike-burns> They wrote a DB in Ruby because they wanted to play around with writing a DB and also wanted to try writing it in Ruby.
21:28:34 <mike-burns> This seems simple and obvious.
21:29:29 <cads> I'd say if it has promise they'd start overhauling key points with C code
21:31:06 <mike-burns> It doesn't have a README, and the gemspec doesn't have a summary or description. It's probably some guy's hobby code.
21:46:57 <mysticc> @hoogle <$>
21:46:57 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
22:02:07 <mysticc> :t ((.)$(.))
22:02:08 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
22:02:20 <mysticc> :t ((.).(.))
22:02:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:03:34 <mysticc> :t ((.)<$>(.))
22:03:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:16:04 * hackagebot peggy 0.2.0 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.2.0 (HideyukiTanaka)
22:20:48 <dolio> peggy, alex...
22:21:06 <dolio> I should make something parsing or lexing related, and call it steve.
22:23:24 <edwardk> =)
22:23:51 <edwardk> there is luthor if i ever get around to finishing it
22:35:08 <sebz> is there a slick way to write something like replicateM 3 (do {x <- [1,2,3,4]; guard (odd x); return x})?
22:36:32 <ddarius> filter odd [1,2,3,4]
22:39:06 <copumpkin> > replicateM 3 (filter odd [1,2,3,4])
22:39:07 <lambdabot>   [[1,1,1],[1,1,3],[1,3,1],[1,3,3],[3,1,1],[3,1,3],[3,3,1],[3,3,3]]
22:39:24 <copumpkin> > do {x <- [1,2,3,4]; guard (odd x); return x}
22:39:25 <lambdabot>   [1,3]
22:39:31 <shachaf> @let select = flip filter
22:39:32 <sebz> er yeah sorry bad question
22:39:32 <lambdabot>  Defined.
22:39:47 <shachaf> > [1,2,3,4] `select` (\x -> (x `odd`))
22:39:49 <lambdabot>   [1,3]
22:40:52 <eyu100> @type select
22:40:54 <lambdabot> forall a. [a] -> (a -> Bool) -> [a]
22:41:27 <eyu100> why "x `odd`"?
22:41:27 <copumpkin> > [1..4] `select` the odd ones
22:41:29 <lambdabot>   [1,3]
22:41:30 <eyu100> strange infix notation
22:42:08 <shachaf> copumpkin: I think "the" is already taken by GHC.Exts.
22:42:14 <eyu100> > [1..] `select` (<5)
22:42:15 <shachaf> To be kind of a ridiculous function, I might add.
22:42:16 <edwardk> > [ x | x <- [1,2,3,4], odd x ]
22:42:18 <lambdabot>   mueval-core: Time limit exceeded
22:42:18 <lambdabot>   [1,3]
22:42:28 <copumpkin> shachaf: what is it?
22:42:52 <shachaf> > theλ> the [1,1,1]
22:42:52 <shachaf> 1
22:42:52 <shachaf> λ> the [1,1,2]
22:42:52 <shachaf> *** Exception: GHC.Exts.the: non-identical elements
22:42:54 <lambdabot>   Not in scope: `the
22:42:56 <shachaf> Er.
22:43:01 <shachaf> Anyway, that.
22:43:15 <copumpkin> wtf
22:43:26 <edwardk> > [1,2,3,4] `select` odd
22:43:28 <lambdabot>   [1,3]
22:43:30 <shachaf> It's used for comprehensive comprehensions.
22:44:55 <sebz> stupid question, I think what I'm really trying to do is something that would expand to: do {x1 <- m; guard (f [x1]); x2 <- m; guard (f [x1, x2]); x3 <- m; guard (f [x1,x2,x3]); return [x1,x2,x3]}
22:46:11 <sebz> the context is that I'm trying to generate paths of some length on a square grid that don't intersect themselves, but I don't want to generate all possible paths and then filter at the end
22:48:40 <sebz> m = [1,2,3,4], say
22:49:40 <sebz> is that possible?
22:51:14 <zenzike> thanks to whoever added my project to community.h.o!
22:51:44 <ddarius> > tails "abc"
22:51:45 <lambdabot>   ["abc","bc","c",""]
22:51:55 <ddarius> > inits "abc"
22:51:56 <lambdabot>   ["","a","ab","abc"]
22:52:17 <cwl> how do you browse haskell code
22:52:24 <MichaelBurge> Legislators should be required to vote on laws written in Haskell. Any time someone wonders, "Is this constitutional?", you can tell them to run "ghc" on Law.hs and check to see if it compiles. If it does, it's legit.
22:52:36 <cwl> I used to use vim+tags+cscope to jump in the code
22:52:47 <cwl> for C language
22:52:58 <cwl> any tools like that for haskell
22:53:14 <MichaelBurge> I use emacs and keep my modules fairly small
22:53:18 <cwl> to go to defination,where it is called,etc.
22:53:43 <MichaelBurge> But maybe my projects are too small for it to be that much of an issue :P
22:58:20 <mreh> quicksilver: pong
23:00:02 <Cale> MichaelBurge: Simon Peyton Jones automatically becomes the most powerful man in the world.
23:05:12 <sebz> ddarius: I don't understand the hint
23:05:47 <ddarius> Cale: We could do worse.
23:09:05 <shachaf> unsafeCoerce corrupts absolutely.
23:10:58 <copumpkin> id :: a -> a; id = unsafeCoerce
23:11:25 <shachaf> @quote ddarius isJust
23:11:26 <lambdabot> ddarius says: isJust . unsafeCoerce
23:11:57 <shachaf> Is that supposed to be an =?
23:12:04 <wavewave> cwl: hoogle?
23:12:06 <shachaf> Well, I guess it works in both directions.
23:12:19 <cwl> wavewave: what?
23:13:01 <wavewave> cwl: you would like to look at hoogle for such a tool.
23:13:04 <copumpkin> lispy: you awake?
23:13:09 <wavewave> like cscope.
23:13:26 <wavewave> not quite same though.
23:13:34 <cwl> wavewave: hoogle isn't like cscope
23:13:47 <cwl> I want to jump in source code
23:14:01 <cwl> not in browser
23:14:36 <freeasjesus> what's the haskell off-topic channel's name?
23:15:50 <wavewave> cwl: I do not know. I would like to have it, too.
23:16:39 <wavewave> I am just using emacs+hoogle+haddock combination.
23:31:07 <skatez> hello everyone
23:31:32 <skatez> i was wondering if anyone feels like answering a haskell newbie's question?
23:31:50 <applicative> skatez: but what is it?
23:31:50 <shachaf> Only if you ask it.
23:31:55 <MichaelBurge> don't ask to ask, just ask
23:31:58 <wavewave> hi, just go ahead please
23:31:59 <shachaf> @faq Can Haskell read your mind?
23:31:59 <lambdabot> The answer is: Yes! Haskell can do that.
23:32:04 <skatez> lol
23:32:05 <skatez> okay
23:32:11 <applicative> no, skatez first ask, whether you can ask to ask
23:32:18 <applicative> the answer will be no
23:32:22 <skatez> i am reading http://learnyouahaskell.com
23:32:32 <applicative> skatez: excellent plan
23:32:41 <shachaf> applicative: No need to be mean.
23:32:45 <skatez> he reimplements elem' like this
23:32:47 <skatez>     elem' :: (Eq a) => a -> [a] -> Bool
23:32:47 <skatez>     elem' a [] = False
23:32:47 <skatez>     elem' a (x:xs)
23:32:47 <skatez>         | a == x    = True
23:32:47 <skatez>         | otherwise = a `elem'` xs
23:33:10 <shachaf> skatez: (Also, please don't paste more than a couple of lines into this channel. Use hpaste or link to something instead.)
23:33:21 <skatez> sorry
23:33:25 <applicative> shachaf: skatez sorry, I was just being silly
23:33:35 <skatez> it's cool applicative
23:33:49 <skatez> okay.. hpaste
23:33:51 <wavewave> you can use hpaste.org
23:33:55 <skatez> let me figure that out first
23:34:15 <hpaste> applicative pasted “elem” at http://hpaste.org/51770
23:34:45 <shachaf> This channel is a little too eager right now.
23:34:48 <shachaf> It's against the Haskell spirit.
23:34:50 <hpaste> skate pasted “my elem” at http://hpaste.org/51771
23:35:04 <skatez> i did it like that
23:35:22 <skatez> is that any less efficient?
23:35:52 <shachaf> skatez: Not in any significant way.
23:36:00 <shachaf> skatez: It's not going to evaluate the whole list or anything like that.
23:36:06 <MichaelBurge> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
23:36:18 <MichaelBurge> You can profile it to see if it's any faster or slower
23:36:21 <shachaf> In fact it's very similar to the actual implementation of elem.
23:36:30 <skatez> okay
23:36:32 <shachaf> MichaelBurge: I don't think that's very helpful advice at this stage. :-)
23:37:01 <skatez> thanks for your help
23:37:01 <azaq23> :t any
23:37:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:37:04 <shachaf> It's also not very easy to profile.
23:37:27 <shachaf> E.g. you'd have to worry about fusion to get a realistic idea of actual performance.
23:39:12 <mgsloan> hello! Does anyone know of any parsers for GHC's error messages?
23:39:16 <copumpkin> any :: Decide P -> Decide (Any P)
23:39:21 <mgsloan> it's a rather hard thing to search for
23:39:55 <shachaf> mgsloan: I somehow doubt such a thing exists.
23:40:15 <shachaf> Maybe the ghc-api gives them in a non-String form?
23:40:18 <mgsloan> I've been writing one using my rex package, but I think I'm suffering from NIH syndrome and should probably use parsec
23:40:36 <shachaf> trifecta!
23:40:50 <edwardk> ?
23:40:59 <edwardk> ah
23:41:51 <applicative> skatez the definition is a typical right fold, elem x xs = foldr (\ y b -> if y == x then True else b) True xs  or so it was seeming to me
23:41:56 <mgsloan> I'm pretty sure that GHC does not yield error messages in an a very computer friendly form
23:42:04 <applicative> skatez,  I mean your definition
23:42:15 <mgsloan> I've been using the GHC code as reference, as would be logical
23:42:43 <shachaf> @ghc
23:42:44 <lambdabot> ghc says: Can't reify a non-Haskell-98 data constructor
23:42:45 <skatez> applicative: thank you, but i dont actually understand what you are saying
23:43:01 <wavewave> @version
23:43:01 <lambdabot> lambdabot 4.2.2.1
23:43:01 <lambdabot> darcs get http://code.haskell.org/lambdabot
23:43:04 <cheater> hey guys
23:43:15 <shachaf> mgsloan: They might accept a patch for it if you were to go through the whole GHC source tree and change the message format.
23:43:18 <cheater> what is the name of the operator >>=?
23:43:23 <wavewave> bind
23:43:32 <shachaf> applicative: That @paste *is* skatez's version.
23:43:33 <skatez> applicative: i have literally only got up to the first few chapters of this book and that is my only exposure to haskell and functional programming
23:43:39 <applicative> skatez, 'foldr' is just a fancy way of abstracting out the form of that kind of definition.  It helps me to think about the 'is it more efficient' question because
23:43:45 <mgsloan> schachaf - I was considering that, but it'd delay my project and I'm probably not the best person for the job
23:44:03 <shachaf> mgsloan: You should make a proposal on the GHC Trac or something, though.
23:44:09 <applicative> skatez, there is familiar lore about the plusses and minuses of different 'folds'.
23:44:13 <shachaf> This is the sort of thing Haskell people like, I presume. :-)
23:44:20 <mgsloan> ooh, my second Trac report, all in one day!
23:44:42 <skatez> applicative: thank you... it is all very interesting
23:44:57 <skatez> applicative: i love this kinda thinking
23:45:11 <applicative> shachaf: right I thought it was his definition; skatez posed the question of its efficiency etc.
23:45:25 <shachaf> applicative: There is no data type but [] and foldr is its catamorphism.
23:45:32 <mgsloan> I'll try to write my ADTs with putting them into GHC in mind
23:45:35 <skatez> i am at the beginning of a month long holiday from work, so i thought i'd do something useful (and fun) and learn haskell
23:45:38 <shachaf> mgsloan++
23:45:58 <shachaf> skatez: Excellent plan, as applicative said. :-)
23:46:00 <mgsloan> but fraid I can't spare the time to do the whole overhaul
23:46:25 * shachaf finds parsers to be a sad thing, on the whole.
23:47:00 <cheater> what is the name of >>?
23:47:13 <mgsloan> aye, there seems to be something wrong there.  Maybe it should just be mixfix operators all the way down
23:47:16 <shachaf> I usually call it ">>".
23:47:25 <wavewave> cheater: I doubt it has a name...  bind_ ?
23:47:32 <cheater> thanks wavewave
23:47:34 <applicative> cheater "and then"
23:47:40 <mgsloan> forgetful bind
23:47:54 <shachaf> Not-bind
23:48:06 <mgsloan> blinder
23:48:12 <applicative> cheater, "and -- however that may be -- then"
23:48:35 <mgsloan> hmm not quite
23:48:53 <applicative> cheater ">>=" means, "and with the result, do ..."
23:48:56 <wavewave> whatever ... next
23:48:57 <MichaelBurge> Activist bind - puts lots of effort into what he does, but nobody remembers
23:49:41 <shachaf> It doesn't, you know, actually bind.
23:50:22 <applicative> well, doesnt it bind the way const x is a function?
23:50:41 <shachaf> Not really?
23:50:49 <wavewave> yeah. can't I think it binds effect?
23:51:00 <shachaf> ">>=" binds a value to a name.
23:51:02 <shachaf> ">>" doesn't.
23:51:11 <mgsloan> well only lambdas bind to a name
23:51:25 <mgsloan> (or pattern matches, ya ya ya)
23:51:29 <shachaf> Well, OK. <- does.
23:51:36 <shachaf> It passes it to a function, anyway.
23:51:43 <shachaf> That's the etymology of the name at any rate.
23:51:48 <applicative> @src (>>)
23:51:48 <lambdabot> m >> k      = m >>= \_ -> k
23:52:17 <shachaf> @pl foo m k = m>>=\_->k
23:52:17 <lambdabot> foo = (. const) . (>>=)
23:52:22 <applicative> @src const
23:52:22 <lambdabot> const x _ = x
