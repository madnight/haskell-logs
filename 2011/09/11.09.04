00:00:16 <ddarius> Both should be fine.  There is also a mailing list geared to beginners.
00:01:25 <Jafet> rotemy: not really, they have a fictional currency you can exploit
00:07:48 <Jackhftang> sorry, I don't understand why this would be a more efficient replacement for zero and one. Could you explain more?
00:09:07 <ddarius> Jackhftang: Think about an answer to Jafet's question, it should be clear.  If you have an answer, please share it.
00:09:31 <Jafet> This conversation smells of cave.
00:09:39 <shachaf> one = zero / zero
00:09:44 <shachaf> Science says so, I think.
00:09:53 <Jafet> shachaf: (/) is not in Num!
00:10:10 <shachaf> Oh, right.
00:11:25 <Jafet> > (\x -> sin x / sin x) pi -- L'Hopital's rule
00:11:26 <lambdabot>   1.0
00:15:34 <engla> Jafet: did you mean  sin x / x ?
00:16:23 <Jafet> That would give the trick away, wouldn't it
00:17:30 <confab> sin x / sin x sounds reasonable to me
00:17:35 <ddarius> engla: sin pi / pi is zero.
00:17:55 <Jafet> > sin pi / pi
00:17:56 <lambdabot>   3.8981718325193755e-17
00:17:56 <shachaf> Not in Haskell!
00:18:03 <shachaf> Well, not with Double.
00:18:17 <ddarius> Not in IEEE754.  Haskell does not specify that Double is IEEE754.
00:18:46 <Jafet> IEEE754 doesn't have sin
00:18:50 <confab> not in mathematics either
00:18:58 <Jafet> Er sorry, it doesn't have sine
00:19:07 <Jafet> Sins, it has many.
00:19:14 <shachaf> IEEE754 *is* sin.
00:26:40 <engla> I didn't see why l'hopital was needed for  a / a
00:27:03 <Jafet> a -> 0
00:27:29 <engla> ok I guess
00:27:43 <engla> sin x / x is worse anyway, my bad, l'hopital there would be circular
00:29:28 <efie> where can i see the implementation of runState?
00:29:33 <ddarius> @src runState
00:29:33 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
00:29:36 <ddarius> @src State
00:29:37 <lambdabot> Source not found. :(
00:29:54 <ddarius> data State s a = State { runState :: s -> (a, s) } -- more or less
00:29:57 <Jafet> @type runState
00:29:58 <lambdabot> forall s a. State s a -> s -> (a, s)
00:30:04 <Jafet> @unmtl State
00:30:05 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
00:30:12 <ddarius> I guess that should have been a newtype.
00:30:12 <Jafet> @unmtl State s a
00:30:13 <lambdabot> s -> (a, s)
00:30:23 <shachaf> efie: There's only one reasonable possible implementation given the data declaration and the type. :-)
00:30:31 <Jafet> @djinn (s -> (a, s)) > s -> (a, s)
00:30:32 <lambdabot> Cannot parse command
00:30:37 <Jafet> @djinn (s -> (a, s)) -> s -> (a, s)
00:30:37 <lambdabot> f a = a
00:30:48 * shachaf wishes unmtl was smarter.
00:30:53 <ddarius> efie: Anyway, all the Haddock documentation on Hackage has links to source code (and of course you could just download the source as well.)
00:30:54 <Jafet> Wait, that wasn't right
00:30:55 <shachaf> @unmtl Identity a
00:30:56 <lambdabot> a
00:31:00 <shachaf> @unmtl Int -> Identity a
00:31:01 <lambdabot> Int -> Identity a
00:31:13 <Jafet> Or efie could read the part of LYAH that describes State
00:32:03 * shachaf generally finds .hs files more useful than Haddock documentation.
00:32:15 <shachaf> Harder to navigate, sadly.
00:32:53 <Jafet> Stop using pico
00:33:29 * shachaf upgraded to nano ages ago.
00:33:58 <shachaf> I could probably set something up in vim to do everything that Haddock does, but it wouldn't be trivial, I think.
00:33:58 <efie> ddarius: ok, thanks
00:33:58 <ddarius> Perhaps you should upgrade to micro.
00:34:05 <efie> jafet: i did, but in the state-paragraph runState was used without any explanation
00:34:58 <efie> (or maybe it self-explanatory and i did not get it)
00:35:10 <shachaf> efie: newtype State s a = State { runState :: s -> (a,s) } defines runState.
00:35:12 <Jafet> nano is comparable to pico in the same way that stormtroopers are comparable to Jango Fett.
00:35:21 <shachaf> All it does is extract the funciton from the newtype.
00:36:24 <rotemy> Regarding newbie code: I am parsing a list of entries out of a text file. Each line is a whitespace-delimited list of numbers. I want to construct 'Record' objects (data Record = Record x y z) out of those lines, where not all lines are parseable. What I have so far is read_maybe (which uses Text.Read.reads to return a Maybe Int), and then my parse_record looks something like:
00:36:26 <shachaf> data Foo a = MkFoo { getFoo :: a }; getFoo (MkFoo x) === x
00:36:36 <shachaf> Er, that *would* be true if I'd used newtype instead of data.
00:37:01 <rotemy> parse_record s = let parts = take 3 $ map read_maybe $ splitWs s in
00:37:13 <rotemy>              case parts of
00:37:20 <shachaf> rotemy: Please don't paste in the channel.
00:37:25 <rotemy> oops
00:37:29 <rotemy> shchaf: gist?
00:37:38 <shachaf> @paste
00:37:39 <lambdabot> Haskell pastebin: http://hpaste.org/
00:37:44 <shachaf> Or that, sure.
00:37:55 <rotemy> ok, sorry
00:40:05 <efie> shachaf: i though runstate is of type State s a -> s -> (a, s), and not only  s -> (a, s); do you mean by function the s?
00:41:30 <shachaf> efie: I don't think I'm parsing your sentence, but when you have newtype Foo = Foo { a :: b }, that makes a function a of type Foo -> b
00:42:08 <rotemy> Ok, sorry for the paste litter from earlier. Anyways what I have for now is this: http://hpaste.org/50954. I thought there must be a better way, because having more than three fields will require tedious editing of the pattern matching logic...
00:42:47 <shachaf> @ty catMaybes
00:42:48 <lambdabot> forall a. [Maybe a] -> [a]
00:43:00 <ddarius> Also, words?
00:43:26 <shachaf> But you'll still have to write some function to convert [x,y,z] to (x,y,z) or (Record x y z) or whatever you have. Those are pretty different types.
00:44:05 <ddarius> > words "foo bar    baz"
00:44:06 <lambdabot>   ["foo","bar","baz"]
00:45:34 <rotemy> shachaf: yes, but maybe I can avoid the list altogether? assuming I know the structure of the file?
00:46:01 <rotemy> shachaf: I mean, if I had 20 fields instead of 10, there would be much repeating going on...
00:46:08 <rotemy> instead of 3, that is
00:46:21 <shachaf> Are the fields all of different types?
00:46:23 <rotemy> I want to write down the meanings of the fields only once
00:46:28 <rotemy> they're all Ints
00:46:37 <rotemy> but they have different meanings, of course
00:46:43 <rotemy> it's a table of sorts
00:47:00 <rotemy> In python I would do something like: Record(*map(int, line.split()))
00:48:19 <c_wraith> Since access appears to be positional only, why do you have a Record type?
00:48:20 <shachaf> I wonder if you could write a Haskell function like that.
00:48:38 <shachaf> foo f [a,b,c,d] = f a b c d
00:48:49 <c_wraith> sure, but it's partial as hell :)
00:48:53 <shachaf> Of course.
00:49:22 <rotemy> c_wraith: because after parsing (which is done locally) it would make a hell of a lot more sense to access fields by their names
00:49:41 <shachaf> c_wraith: I mean for any list length, of course, not only 4.
00:50:17 <c_wraith> shachaf: hmm.  it probably can be done kind of like printf.
00:50:30 <c_wraith> shachaf: but that's a mess I don't want to think about tonight :)
00:50:31 <shachaf> Yes, printf is actually very similar.
00:51:24 <c_wraith> I like how the way printf works is basically "screw you, type system!"
00:51:52 <shachaf> augustss++
00:51:55 <shachaf> Death to type systems.
00:52:39 <rotemy> so basically what I wrote is as good as it gets?
00:53:11 <c_wraith> well, as far as I know, you have to choose between type safety and convenience
00:53:20 <shachaf> rotemy: Well, if you're translating each position to a name, you'll probably have to provide a position->name translation table of *some* sort.
00:54:32 <rotemy> shachaf: so it sounds like anything shorter would involve some type of reflection or somethign. So as far as I'm concerned it's as good as it gets given the constraints
00:55:04 <rotemy> ok, thanks a lot you guys!
03:23:18 <CindyLinz> is there a Maybe version of head ?
03:23:38 <CindyLinz> that's   maybeHead :: [a] -> Maybe a
03:23:47 <shachaf> listToMaybe will do that.
03:23:51 <CindyLinz> wow.
03:23:57 <adimit> @hoogle [a] -> Maybe a
03:23:57 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
03:23:57 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:23:57 <lambdabot> Prelude head :: [a] -> a
03:23:58 <CindyLinz> shachaf: thanks ^^
03:24:13 <shachaf> It's an awkward name, and partial functions are generally an evil sort of thing.
03:24:37 <adimit> I find it weird that Prelude has so many of them. It's a convenience thing, I guess.
03:25:00 <CindyLinz> sure.. it's might be a trade-off between convenience and safty @@"
03:26:45 <CindyLinz> one more question.. :p  is there a consistent way to convert any partial function to a Maybe function?
03:26:59 <adimit> CindyLinz: catch.
03:27:02 <shachaf> Nope.
03:27:29 <shachaf> @karma- haltingproblem
03:27:29 <lambdabot> haltingproblem's karma lowered to -1.
03:27:30 <CindyLinz> it MUST be involved in IO monad?
03:27:37 <shachaf> CindyLinz: Even with IO you can't do it.
03:27:37 <adimit> you can try catching exceptions, but you won't really always know why the partial function failed (depending on how it's coded.)
03:27:54 <shachaf> adimit: You won't even know that it's partial. It's impossible.
03:28:02 <CindyLinz> I forget the halting case...
03:28:10 <adimit> shachaf: yeah, you're right.
03:28:17 <shachaf> You can catch uses of undefined and error, but not partial functions in general.
03:28:29 <shachaf> @hackage spoon
03:28:29 <lambdabot> http://hackage.haskell.org/package/spoon
03:28:41 <CindyLinz> shachaf: true..
03:28:55 <shachaf> CindyLinz: Catching undefined is evil, though.
03:28:56 <adimit> shachaf: can we tach pattern match failures in case of non-exhaustive patterns? I forget…
03:29:04 <shachaf> adimit: Maybe. That's evil too.
03:29:10 <adimit> I think catching error is also evil.
03:29:16 <adimit> It's more of a pragmatic point.
03:29:38 <adimit> (writing too many research-only projects will do *horrible* things to your coding habits.)
03:29:55 <shachaf> Just use Maybe.
03:33:26 <adimit> is there a good beginner-friendly tutorial on Iteratees out there?
03:33:46 <adimit> (and I don't think Oleg's notes are particularly beginner-friendly…)
03:42:57 <krawczyk> Has anybody experience with Haskell and SDL?
03:44:50 <krawczyk> @:type map
03:44:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:46:44 <ddarius> @google iteratee tutorial
03:46:45 <lambdabot> http://www.haskell.org/haskellwiki/Iteratee
03:46:45 <lambdabot> Title: Iteratee - HaskellWiki
03:47:57 <adimit> ddarius: "You do not have permission to do that… The action you have requested is limited to users in the group user."
03:48:16 <adimit> seems there is some trouble with the .Haskell wiki
03:48:49 <shachaf> adimit: Works for me.
03:49:06 <adimit> shachaf: you're probably logged into the haskell wiki.
03:49:11 <shachaf> Nope.
03:49:25 <shachaf> Oh, are you trying to edit it or something?
03:49:35 <adimit> no, trying to click on the link "tutorial"
03:49:47 <adimit> http://www.haskell.org/haskellwiki/index.php?title=Iteratee/Tutorial
03:49:56 <adimit> ah, I see, the page is empty. Now that I modified the address.
03:49:58 <krawczyk> When I click on "http://www.haskell.org/haskellwiki/index.php?title=Iteratee/Tutorial&action=edit" I get the error.
03:50:14 <krawczyk> It is the same on "Example".
03:50:24 <adimit> If you just click the link "tutorial" you get the edit page, because the page doesn't exist.
03:50:43 <geheimdienst> i guess we should remove those 2 links. there's not much point to having links that lead nowhere
03:50:49 * krawczyk says oh...
03:50:52 <adimit> So yeah, that's why I asked, I guess. Though I actually wanted to write one myself.
03:51:27 <adimit> (i.e. I was asking because maybe someone had done the job already. It's non-trivial.)
03:51:56 <shachaf> geheimdienst: Instead of removing the links, you should write a tutorial.
03:52:28 <adimit> writing a good tutorial is no way an easy task.
03:52:31 <geheimdienst> in principle, good idea, but i have never used iteratees ...
03:52:35 <shachaf> An iteratee is like a river full of liquid helium.
03:52:54 <geheimdienst> shachaf: could you relate that to burritos?
03:53:18 <shachaf> geheimdienst: Well, it's a burrito transformer, obviously.
03:56:08 <ddarius> @google yesod iteratee tutorial
03:56:09 <lambdabot> http://www.yesodweb.com/blog/2010/09/enumerators-tutorial-part-1
03:56:09 <lambdabot> Title: Yesod :: Enumerators Tutorial Part 1: Iteratee
03:58:08 <adimit> ddarius: yes, but that's for the enumerator library, not jlato's iteratee library. They differ in API.
03:58:27 <adimit> (though thanks, I had forgotten about yesod's tutorial.)
03:59:43 <adimit> I also didn't like the yesod tutorial because, as everything iteratee, it seems to make you build an iteratee instead of letting you use one. I found one can use them perfectly without being able to build them.
04:00:11 <adimit> (just like monads, actually.)
04:03:30 <jmcarthur> krawczyk: i have used SDL with haskell, but don't really have the time to answer questions at this moment. you might be interested in trying #haskell-game, by the way
04:03:57 <krawczyk> jmcarthur: Thank you! I will try that!
04:13:15 <jmcarthur> krawczyk: actually, i'm going to be back and forth for a while, but i could try answering some questions if you still have any. i just might be slow to answer sometimes
04:15:47 <Laugarhraun> Hi! I have trouble installing System.Random: I did cabal install random
04:16:00 <Laugarhraun> The error is: The package requires Cabal library version -any && >=1.6 but no
04:16:03 <Laugarhraun> suitable version is installed.
04:16:11 <Laugarhraun> However: cabal --version
04:16:11 <Laugarhraun> cabal-install version 0.10.2
04:16:12 <Laugarhraun> using version 1.10.1.0 of the Cabal library
04:16:55 <Laugarhraun> So it believe it should be ok... But it seems like the comparison (1.10 > 1.6) fails. What am I doing wrong please?
04:18:29 <jmcarthur> Laugarhraun: this sounds more like a #haskell question
04:18:38 <hpc> jmcarthur: good thing he's already here
04:18:41 <shachaf> jmcarthur: That's why it's in this channel. :-)
04:18:43 <jmcarthur> oh weeops
04:18:49 <jmcarthur> thought i was in #haskell-game
04:18:53 <Laugarhraun> :)
04:19:05 <Laugarhraun> so, any idea?
04:19:05 <jmcarthur> sorry Laugarhraun
04:19:30 <dave1231> if anyone has any good iteratee tutorials that cover the chaining of enumeratees, there's a guy who's been asking about that in here for the last week or so
04:19:34 <benmachine> Laugarhraun: my impression is that it's not the comparison that's failing but something else strange is going on, and you're getting an unhelpful error message
04:19:43 <dave1231> I think he's having bad luck on the timezone front
04:20:01 <benmachine> Laugarhraun: maybe try running with -v3
04:21:23 <adimit> dave1231: well, I'm writing one, but I'm a bit covered in work right now. I'll try to have a readable version some time next week.
04:21:23 <Tinned_Tuna> I've reintroduced a memory leak into my program by added error handling... Super!
04:21:29 * Tinned_Tuna headdesk
04:21:42 <Tinned_Tuna> well, it's not technically a leak, it's just massive memory consumption
04:22:10 <dave1231> adimit: nice - I'll let him now that there's something Coming Soon
04:23:32 <hpaste> Laugarhraun pasted “random installation fails” at http://hpaste.org/50955
04:23:38 <dave1231> I hadn't head of iteratees until the plea for help appeared in the channel, makes me wonder what other big ideas I'm still not up / haven't come across as a Haskell newb
04:24:01 <Laugarhraun> could you please take a quick look at this paste? It is what the CL returned
04:24:12 <dave1231> typclassopedia was pretty mind opening, but I get the sense it's the first step on a long path
04:24:19 <dave1231> or possibly on a treadmill
04:24:52 <hpc> dave1231: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
04:25:04 <hpc> dave1231: that's probably your next (impossible at this point?) step
04:25:16 <dave1231> it's already kind of on my radar
04:25:28 <hpc> also zippers and categories
04:26:02 <dave1231> zippers I kind of understand, I'm interested in knowing more about finger trees
04:26:13 <dave1231> I probably need to reread the typeclassopedia on categories and arrows
04:26:27 <dave1231> I _think_ I get arrows but I worry that there's something I'm missing
04:26:31 <benmachine> dave1231: haskell is full of big ideas, don't feel obliged to learn them all :)
04:26:37 <dave1231> and then I need to use all of this in anger :
04:26:41 <dave1231> :) rather
04:26:59 <hpc> dave1231: arrows are ridonculous
04:27:12 <hpc> don't worry about not getting them yet
04:27:23 <hpc> the syntax is nasty and you really need to understand categories first
04:28:47 <benmachine> I don't really "get" arrows, and I certainly don't understand the notation
04:28:53 <benmachine> this doesn't really bother me :P
04:28:59 <dave1231> I guess I'll cross the various bridges when I get to them - the current plan is the finish of the "write a scheme in 48 hours" tutorial, then start on a roguelike, then probably stick my hand up to do some doc and testing work for something(s) on hackage to try to immerse myself in real Haskell
04:29:55 <dave1231> then I just need to find a project that'll give me an excuse to play with concurrency... :)
04:30:01 <adimit> Iteratees should be more widely used. In fact, I think lazy IO should be thrown overboard, and replaced with iteratees.
04:30:08 <hpc> that's a good plan, i think
04:30:20 <hpc> i haven't done any hackaging yet, sadly
04:30:24 <ddarius> Lazy IO should be thrown overboard regardless.
04:30:29 <hpc> despite my probably being more than qualified at this point
04:30:30 * hackagebot Lucu 0.7.0.3 - HTTP Daemonic Library  http://hackage.haskell.org/package/Lucu-0.7.0.3 (MasatakeDaimon)
04:30:43 <adimit> but I think that the spotty documentation and the "arcaneness" of a rather new technology have hindered adoption.
04:31:09 <adimit> ddarius: I doubt anybody would disagree with that point :-) Lazy IO is harmful.
04:32:14 <koeien37> what's the big deal with lazy IO? exceptions can be thrown at random moments, and resources might be closed too late? anything else?
04:32:26 <merijn> koeien37: Resource leaks mostly
04:33:06 <adimit> koeien37: yes, resources leak a lot. Plus, it gives the impression of being pure, while it has plenty of side-effects.
04:33:10 <merijn> lazy IO is like floats, it seems very easy and intuitive at first, but its applicability turns out to be limited due to pitfalls you don't understand until its too late
04:33:14 <adimit> which is just plain old deceit.
04:33:54 <dave1231> oh god floats
04:33:59 * dave1231 shivers
04:34:06 <hpc> by lazy IO, do we mean getContents, or return . unsafePerformIO?
04:34:40 <merijn> getContents
04:34:53 <merijn> With unsafePerformIO you *know* all bets are off
04:35:12 <koeien37> well, lazy IO is just unsafeInterleaveIO, isn't it?
04:35:14 <hpc> i like getContents, but it's definitely an RTFM kind of function
04:35:41 <joachi> how much haskell should you know until you work through Real World Haskell?
04:35:51 <adimit> hpc: you will like it as long as you're handling trivial file sizes/amounts of data, and/or don't care about performance.
04:36:04 <merijn> joachi: I prefer to use RWH as a collection of tutorials whenever I need to branch into a new topic
04:36:08 <hpc> joachi: rwh is something you go through a chapter at a time, whenever you want to learn something
04:36:24 <hpc> like, "i need a database; read chapter 12345" or whatever
04:36:27 <adimit> joachi: I think RWH is designed for beginners, so you can start there. Or you could consider LYAH.
04:36:28 <merijn> joachi: Theoretically you can start without any haskell knowledge, but finishing Learn You a Haskell first probably helps
04:36:40 <hpc> LYAH is a much more coherent tutorial
04:36:51 <koeien37> RWH doesn't assume Haskell knowledge, but it goes quite quickly through the basics AFAIR
04:36:55 <dave1231> LYAH was excellent - although some exercises would have really helped to lock in some of the goodness
04:37:04 <joachi> i'm almost through with LYAH and i like it a lot, but sadly there's no exercises
04:37:19 <hpc> dave1231: i think LYAH assumes you want to learn enough to mess around with it yourself
04:37:32 <hpc> i don't like exercises cluttering up a page full of information
04:37:45 <hpc> it's part of what i dislike about the wikibook
04:38:05 <hpc> that and every single page being a stub that needs cleanup...
04:38:31 <adimit> joachi: if you're through with LYAH, you might want to try to think of something to code up. Just some software project. Reimplementations are a good idea for first-timers.
04:38:44 <hpc> joachi: an irc bot is a good one
04:38:48 <dave1231> hpc: indeed, but I found it hard to pick a mini-project to try stuff out with based on LYAH - even a "Try this: " section at the end of every couple of chapters, even without much detail, would have been nice
04:39:05 <adimit> then if you get stuck with say, monad transformers or database access, go to RWH and read the respective chapters.
04:39:14 <hpc> joachi: the RPN exercise/example thingy expands really nicely into a bot module
04:39:32 <joachi> that sounds wonderful.
04:40:16 <dave1231> I found RWH a bit strange in terms of the flow of ideas and the motivation for what they were doing
04:40:34 <hpc> there's a good page on the haskell wiki on making an irc bot, that leaves just enough out for you to still have to think
04:40:45 <merijn> dave1231: Well it mostly reads like a collection of independent tutorials
04:41:04 <koeien37> I think the purpose of RWH is to show multiple applications of Haskell
04:41:09 <dave1231> merijn: agreed - it's been very helpful for particular domains
04:41:33 <merijn> On unrelated note, what happened to hpaste it only support haskell and ruby now? :<
04:42:44 <dave1231> that reminds me - I was thinking about making an IRC bot to moderate online games of The Resistance...
04:42:45 <hpc> merijn: there was a big rewrite a while back, and the other languages might not have survived it
04:42:58 <dave1231> I think I have another project for the list
04:43:34 <merijn> hpc: That makes me sad, now I need to find a decent pastebin for everything else :\
04:43:51 <azaq23> merijin: paste.pocoo.org
04:44:08 <benmachine> there are languages other than haskell?!?
04:44:21 <koeien37> benmachine: yes, Agda ;)
04:44:28 <merijn> azaq23: I hate paste.pocoo, stupid fancy JS stuff
04:44:55 <hpc> whois seems to indicate that you can email bos@serpentine.com about hpaste stuff
04:45:05 <hpc> Admin Name:Bryan O'Sullivan
04:45:06 <benmachine> :>
04:45:23 <merijn> koeien37: And if you prefer doing practical programming Epigram, ofc :>
04:45:24 <benmachine> I think chrisdone is the hpaste person
04:45:33 <ddarius> Yes.
04:45:36 <benmachine> https://github.com/chrisdone/amelie
04:46:36 <azaq23> merijin: Well, it's got a textfield, something to choose the languages from, an OK button and some checkboxes. The highlighting is decent, it's easy to use and reasonably fast. It's not overpolluted
04:46:36 <azaq23> with JS or anything. I don't see the point of that criticism.
04:48:45 <merijn> azaq23: I don't have any rational reasoning. I just dislike it from some completely irrational intuition :)
04:49:36 <Laugarhraun> Well, when I want to install directory, random or bytestring, it fails... With different error messages. Could you please have a quick look and help me? http://fpaste.org/WSXw/ thanks!
04:50:03 <benmachine> Laugarhraun: don't install directory or bytestring, is my advice
04:51:02 <benmachine> those come with GHC
04:51:11 <Laugarhraun> benmachine:  why? I'm currently learning haskell through http://www.learnyouahaskell.com and it is used...
04:51:12 <Laugarhraun> oh
04:51:18 <benmachine> bad things happen if you install packages that come with GHC
04:51:24 <benmachine> have a look at ghc-pkg list
04:51:30 <benmachine> and just in case, run ghc-pkg check
04:51:39 <benmachine> (also, where are you getting these from?)
04:52:03 <Laugarhraun> I have installed ghc through yum (rpm)
04:52:26 <azaq23> merijn: Well, be assured that some well known people in the python community (especially the german subset) are behind pocoo, and they are quite level-headed people, they won't go overboard, trying
04:52:26 <azaq23> to stuff more and more JS into it because "that's just how we do things in WEB2.0 times, right?!111"
04:52:27 <Laugarhraun> And I did not have any of those, so I installed cabal
04:52:49 <Laugarhraun> during its installation, the dependencies included ghc-directory, ghc-random etc.
04:53:07 <Laugarhraun> But I still did not have any access to it after the operation!
04:53:28 <Laugarhraun> "ghc-pkg check" finishes in a few seconds without any message
04:54:42 <Laugarhraun> any clue anyone?
04:55:28 <benmachine> Laugarhraun: what does ghc-pkg list tell you
04:55:39 <benmachine> is random and bytestring in it?
04:55:41 <benmachine> *are
04:56:35 <Laugarhraun> nope... I only have base ghc-prim integer-gmp rts, filepath old-locale unix
04:56:55 <Laugarhraun> and the last 3 got installed as dependencies for directory
04:57:14 <benmachine> very odd.
04:57:24 <benmachine> to me it sounds like something strange happened with your package manager
04:57:30 <Laugarhraun> argh
04:57:34 <benmachine> it seems to think it installed things but hasn't?
04:57:53 <benmachine> maybe it installed them but didn't register them
04:58:00 <benmachine> were there error messages during the installation?
04:58:04 <Laugarhraun> very probable...
04:58:10 <sbrg> You could try reinstalling ghc, removing it completely first, and then installing the haskell platform with cabal and then use cabal to install packages
04:58:29 <Laugarhraun> Errors during the installation through the system package manager? Noone.
04:58:40 <benmachine> sbrg: by installing the haskell platform with cabal do you mean (installing the haskell platform) with cabal or installing (the haskell platform with cabal)
04:58:47 <Laugarhraun> sbahra:  it is what I did....
04:59:00 <sbrg> benmachine: the latter
04:59:04 <Laugarhraun> I installed ghc and then cabal and then tried to get those missing modules
04:59:15 <Laugarhraun> ah ok!
04:59:36 <benmachine> which version of ghc is this btw
04:59:40 <benmachine> on an offchance
04:59:54 <Laugarhraun> benmachine:  7.0.2
04:59:59 <benmachine> oh right
05:00:11 <benmachine> not some super-old version from before bytestring existed; good to know :P
05:00:51 <hpaste> benmachine pasted “ghc-pkg-7.0.2 list” at http://hpaste.org/50956
05:01:08 <benmachine> Laugarhraun: those ^ are the packages that came with my installation of ghc 7.0.2
05:01:19 <benmachine> something funny's going on if you don't have them
05:01:22 <Laugarhraun> ok
05:01:32 <sbrg> Laugarhraun: You installed ghc from your distro's repo and then installed cabal on top of that?
05:01:36 <Laugarhraun> lots more tha I!
05:01:37 <benmachine> (I installed from source, but my impression is that all of those are essential)
05:01:39 <Laugarhraun> sbrg:  exactly
05:01:47 <sbrg> In theory, I don't think that should be a problem, since you can update cabal(with cabal) and all that
05:01:52 <benmachine> yes
05:01:56 <benmachine> it should be fine
05:02:05 <sbrg> but in reality, i have had little luck using anything but the haskell platform
05:02:17 <sbrg> And whatever you do, don't use anything but cabal to install packages
05:02:53 <benmachine> Laugarhraun: so, maybe you should uninstall your GHC stuff now and try these instead http://hackage.haskell.org/platform/linux.html
05:02:57 <benmachine> unless that's what you already tried
05:03:18 <Laugarhraun> Nope, did not do it yet, I was just looking at this page
05:03:28 <saati> how do i create an empty IO action?
05:03:36 <sbrg> saati: return () ?
05:03:46 <sbrg> :t return () :: IO ()
05:03:47 <lambdabot> IO ()
05:03:48 <Laugarhraun> so, installing haskell-platform instead of ghc
05:03:55 <saati> seems reasonable :) thank you
05:03:59 <Laugarhraun> thanks
05:04:37 <koeien37> I'd just install the GHC binary from haskell.org/ghc
05:04:54 <koeien37> but if it's the same version it shouldn't matter
05:05:11 <sbrg> I got the ghc binary and compiled from source myself
05:05:25 <koeien37> yup, this is what I did as well
05:05:25 <sbrg> in order to use the newest version possible, since ubuntu comes with some ancient version last time I checked
05:05:46 <koeien37> i use debian stable, so maybe even more ancient :)
05:05:52 <sbrg> haha, probably
05:44:38 <mbuf> In [0, "b", ""], how can I remove the double quotes, if it exists?
05:45:21 <benmachine> mbuf: huh? can you provide a bit more context?
05:45:33 <benmachine> [0, "b", ""] looks like a list but with more than one type in it, which is not allowed
05:46:11 <leod> filter (/= "")?
05:46:40 <mbuf> benmachine: that is read from a .csv file, for example
05:46:58 <monochrom> you should get ["0", "b", ""] instead
05:47:00 <benmachine> mbuf: so you read a CSV file into a list of strings?
05:47:11 <benmachine> and you want to drop all the empty entries?
05:47:29 <mbuf> benmachine: want to remove the " if it is present in the data
05:47:43 <monochrom> you want [0, b, ,] ?
05:48:08 <benmachine> mbuf: a string containing " looks like "\""
05:48:09 <merijn> monochrom: He wants to filter the char " from the strings in the list I think?
05:48:40 <mbuf> benmachine: monochrom http://hpaste.org/50957
05:49:37 <mbuf> merijn: yes, that is correct
05:50:40 <merijn> > map (filter (/='"') ["0", "b", "test\"test"]
05:50:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:50:50 <merijn> > map (filter (/='"')) ["0", "b", "test\"test"]
05:50:51 <lambdabot>   ["0","b","testtest"]
05:50:56 <benmachine> mbuf: it looks to me like you already remove the double quotes from the beginning and end of each entry
05:51:30 <benmachine> filter (/= '"') will remove any double quotes contained in the entry
05:51:46 <merijn> oh, true
05:52:04 <merijn> ben: Wait, that's what he wanted
05:52:26 <merijn> <mbuf> benmachine: want to remove the " if it is present in the data
05:52:27 <benmachine> merijn: yeah, and it's what you said, just clarifying :)
05:52:35 <mbuf> benmachine: checking
05:53:49 <Laugarhraun> installing the whole 'haskell-platform' resolved my problems! Thanks
05:53:50 <mbuf> benmachine: so if the input is a number, 0 then it doesn't take it as a string?
05:54:04 <benmachine> mbuf: huh?
05:54:21 <mbuf> benmachine:  SqlError {seState = "", seNativeError = -1, seErrorMsg = "In HDBC execute, received [SqlString \"0\"
05:55:02 <benmachine> mbuf: ah, so the problem is that you're inserting a string
05:55:11 <benmachine> probably nothing to do with double quotes
05:55:37 <benmachine> ok so
05:56:02 <benmachine> your process function takes a list of strings
05:56:09 <benmachine> but that's kind of a lie because it wants exactly three strings
05:56:12 <benmachine> right?
05:56:14 <mbuf> benmachine: SqlError {seState = "", seNativeError = -1, seErrorMsg = "In HDBC execute, received [SqlString \"0\",SqlString \"\",SqlString \"\",SqlString \"\"] but expected 3 args."}
05:56:16 <gwern> @quote string
05:56:17 <lambdabot> conal says: The C ADT is implemented simply as String (or char *, for you type theorists, using a notation from Kleene)
05:56:38 <hpc> haha
05:56:48 <mbuf> benmachine: ahh! I had to remove the trailing input and also the last semicolon
05:56:55 <benmachine> aha, okay
05:57:22 <benmachine> I'd advise doing something like process [s1,s2,s3] = do
05:57:27 <benmachine> <stuff>
05:57:34 <benmachine> process _ = error "oh no, wrong number of things!"
05:57:57 <benmachine> then it's more clear what you expect
05:58:05 <monochrom> why is it not simply process s1 s2 s3 = do <stuff>
05:58:16 <mbuf> benmachine: thanks for your help
05:58:17 <benmachine> monochrom: well, it depends what you want process to do
05:58:40 <benmachine> mbuf: btw, there *are* libraries for parsing CSV
05:58:42 <benmachine> pretty sure
05:59:00 <benmachine> see http://hackage.haskell.org/package/csv for e.g.
05:59:05 <mbuf> benmachine: I just followed RWH
05:59:10 <benmachine> oh right
05:59:14 <benmachine> continue then :)
05:59:47 <mbuf> benmachine: will check csv too; thanks again!
06:28:39 <Laugarhraun> Hi! I wanted to compare performances between ByteStrings and Strings, so I made it copy a set of data from /dev/urandom
06:28:48 <Laugarhraun> problem: Strings cannot handle this kind of data
06:29:02 <Laugarhraun> So is there any workaround or is my idea just plain stupid? :)
06:29:17 <Laugarhraun> (and then, how can I generate big sets of text?)
06:30:54 <monochrom> String can handle it. I/O routines can't, when used wrong. use openBinaryFile, don't use openFile
06:31:17 <Laugarhraun> ok! Thank you
06:31:30 <monochrom> (I mean don't use openFile for this, i.e., knowingly non-text data)
06:31:36 <Laugarhraun> (since I'm just starting haskell, I lack knowledge of existing functions)
06:31:41 <jmcarthur> Laugarhraun: i think this demonstrates an area where you would almost certainly want ByteString and not String, though :)
06:31:59 <Laugarhraun> jmcarthur:  that's the point! I want to measure the difference
06:32:15 <jmcarthur> i mean apart from speed
06:32:26 <jmcarthur> binary data just doesn't make much sense to manipulate as Strings
06:32:32 <Laugarhraun> of course :)
06:36:37 <mbuf> benmachine: I didn't want the first line in the input .csv file, so I had to remove it manually; secondly I had to remove the trailing ; in each line in the input before processing the .csv file
06:37:12 <mbuf> benmachine: I was able to read the .csv file and write to sqlite3; the Text.CSV module uses ',' by default and not semicolon so it might not suit this input
06:39:00 <Laugarhraun> for 165MiB, 0.539s with ByteString and 6.961s with String :o
06:42:44 <hpc> which bytestring? strict or lazy?
06:43:17 <adimit> Laugarhraun: that's to be expected. I've seen several orders of magnitude in *string manipulation* and *string parsing* between BS and [Char]
06:44:17 <adimit> the String type is really just a joke people put in because it looks so nice. Never use it for anything but the simplest things (like getArgs and whatnot.)
06:44:21 <joe6> is it bad to use -XUndecidableInstances?
06:44:43 <mm_freak> hpc: strict bytestrings are generally faster…  but sometimes lazy BSs are more convenient
06:45:11 <hpc> joe6: it's safe at runtime, but you can get non-terminating compilation i think
06:45:11 <adimit> mm_freak: that very much depends on your space behaviour. lazy can be a lot faster than strict depending on what you do with.
06:45:19 <mm_freak> adimit: String does have a practical use case
06:45:32 <mm_freak> lazy bytestrings in their laziest form consume more memory than String
06:45:51 <adimit> that's a special case though.
06:46:17 <mm_freak> adimit: lazy bytestrings cannot be faster than strict, because lazy bytestrings are just a list of strings
06:46:18 <adimit> but I'm not very happy about using lazy bytestrings either, for exactly that reason that they gobble up more space than necessary.
06:46:37 <mm_freak> there is always a strict BS algorithm, which does the same as the lazy BS algorithm, but is faster
06:46:38 <adimit> mm_freak: it can be faster to process a lazy bytestring than a strict one. (sorry, rephrased.)
06:46:46 <adimit> assuming infinite memory.
06:47:06 <adimit> also assuming just a single thread and/or immidate read/write.
06:47:33 <adimit> *immediate
06:48:00 <mm_freak> again:  lazy BS is defined in terms of a list of strict BS, so they are inherently more complex than strict BS and hence can only be faster, if your strict BS variant is not optimal
06:49:02 <adimit> that's obvious.
06:50:36 <mm_freak> then don't question it =)
06:50:41 <adimit> and not my point :-) *processing* a stream of input lazily (i.e. in chunks) *can* be rather more efficient than slurping it in and *then* processing it.
06:50:57 <mm_freak> there is no difference
06:51:07 <adimit> if you assume infinite memory. Which you cannot.
06:51:16 <mm_freak> processing a lazy bytestring is no different from processing a stream of strict bytestrings
06:51:26 <mm_freak> see how iteratees on bytestrings work
06:51:35 <adimit> a lazy bytestring *is* a stream of strict bytestrings.
06:52:07 <mm_freak> yes, bound to a specific data structure and dependent on fusion to produce efficient code, while iteratees are kind of pre-fused
06:52:30 <adimit> no argument here, I use iteratees over strict bytestrings exclusively for all my io.
06:52:59 <adimit> but iteratees are a bit unweildy for people who aren't used to them.
06:53:05 <mm_freak> yes, and then your code will run faster than using lazy bytestring IO, no matter how efficiently and fusion-friendly you write your code
06:53:33 <mm_freak> at least with the iteratee package, which doesn't use intermediate data structures
06:53:38 <adimit> indeed. But if all somebody knows is bytestrings and readFile, lazy bytestrings are better.
06:53:46 <adimit> (or they should go learn iteratees.)
06:54:33 <mm_freak> easier, but less efficient…  they will get better performance by writing an explicit hGet/hPut loop with strict bytestrings
06:55:13 <jmcarthur> iteratees has some overhead too
06:55:16 <jmcarthur> *have
06:55:25 <adimit> mm_freak: that can be *messy* because you basically need to implement an iteratee.
06:55:27 <mm_freak> the difference is small, but noticable…  for example i found that writing an algorithm with explicit recursion and accumulators is generally faster than folding lists
06:56:30 <mm_freak> jmcarthur: about the same overhead as folding a lazy list and likely less with the iteratee package, because that one uses CPS
06:56:35 <adimit> i.e. you get a chunk, but you can't parse it because you need more, you need to read another chunk, etc. That can be tricky to code up. I'd prefer to just go and use an iteratee right away.
06:57:25 <mm_freak> adimit: no arguing here…  i totally agree about that
06:57:56 <adimit> so the result of the argument: everybody should be using jlato's and oleg's iteratee package, eh? Utopia…
06:57:59 <dylukes> adimit: That's why there are enumerators/enuemratees along with iteratees though.
06:58:14 <dylukes> The idea is that you have defined code to "pull" more data when you need it.
06:58:36 <mm_freak> my point is that i have tried for practical purposes about all known ways to process incoming data and the fastest method is explicit coding, but it's also the worst method (error-prone, difficult to code)…  after that come iteratees
06:58:38 <adimit> dylukes: absolutely. That's why writing your own hGet/hPut loop is *so* damn hard to get right.
06:59:00 <dylukes> Er, my bad, I mixed up one thing.
06:59:08 <adimit> mm_freak: well, I use haskell because I like shiny abstractions that are still efficient.
06:59:11 <dylukes> The idea with iteratees is rather to have a push based model.
06:59:18 <dylukes> You want to enumerator "in charge"
06:59:19 <mm_freak> adimit: iteratees are not optimal…  this time i'm not talking about performance, but convenience
06:59:30 <mm_freak> for example there is no channel from the iteratee to the enumerator
06:59:41 <dylukes> mm_freak: What do you mean
06:59:43 <mm_freak> i'd like to give the monad-coroutine package a try some time
06:59:57 <mm_freak> dylukes: the iteratee cannot communicate with the enumerator
06:59:57 <adimit> true that. And the API docs are… special.
07:00:12 <dylukes> That's the role of enumeratees.
07:00:13 <adimit> hadn't heard about monad-coroutine.
07:00:19 <dylukes> As pipes between consumers/producers.
07:00:24 <dylukes> (iteratees/enumerators)
07:00:50 <mm_freak> dylukes: they are not general enough…  what if i explicitly want the iteratee to be able to send messages to the enumerator?
07:00:56 <adimit> nah, I think mm_freak means communication that goes beyond EOF/Error/Yield
07:01:05 <dylukes> adimit: mm yeah
07:01:23 <dylukes> mm_freak: If they're acting as independent entities which communicate,
07:01:23 <adimit> mm_freak: do you have a use case for that?
07:01:26 <dylukes> I would consider the actor model.
07:01:54 <mm_freak> i will consider monad-coroutine
07:01:58 <dylukes> It shouldn't be excessively difficult to put the enumerator and iteratee on separate threads,
07:02:04 <dylukes> then use a Chan to communicate upwards.
07:02:12 <yitz> oh, monad-coroutine does look interesting. from your description i thought it forces you into using iteratees, but fortunately, it doesn't.
07:02:28 <mm_freak> yitz: iteratees are a special kind of coroutines
07:02:34 <mm_freak> monad-coroutine gives you the general kind
07:02:39 <yitz> mm_freak: yeah, an especially messy kind
07:02:57 <adimit> dylukes: well, that is easily implementable in the current iteratee package (using IO or MonadIO as the iteratee/enumerator's monad)
07:03:08 <dylukes> There you go.
07:03:09 <mm_freak> not necessarily messy…  they are good for simple stream processing
07:03:15 <yitz> i avoid iteratees whenever possible.
07:03:15 <dylukes> I'm imagining his use case,
07:03:20 <mm_freak> but for more complicated stuff they quickly reach their limits
07:03:28 <dylukes> but I can't really...
07:03:30 <adimit> yitz: why? I like them a lot. Is there a better option?
07:03:35 <mm_freak> also i found out painfully that Iteratee a m is not a monad
07:03:40 <dylukes> if HOW you read/chunk input depends on what you actually parse...
07:03:40 <yitz> yes lazy io
07:03:45 <yitz> or strict io
07:03:53 <adimit> yitz: no, lazy IO is the spawn of the devil. I hate it.
07:04:02 <yitz> or, if all else fails, you're forced into something ugly like iteratees.
07:04:21 <mm_freak> adimit: iteratees don't compose well
07:04:26 <adimit> strict IO only works when you a) have something that fits into memory, b) have something that you actually have, and that doesn't trickle in.
07:04:30 <yitz> adimit: lazy IO definitely has problems and limitations. but it's far better than iteratees.
07:04:31 <mm_freak> i tend to avoid them, too, nowadays
07:04:38 <dylukes> mm_freak: Iteratee s m b is the monadic form
07:04:42 <dylukes> you need the Stream type in there.
07:04:57 <mm_freak> dylukes: they still aren't monads, because they break the monad laws
07:05:05 <mm_freak> the associativity law to be exact
07:05:21 <dylukes> I think I see what you mean...
07:05:22 <dylukes> example?
07:05:26 <adimit> yitz: it depends on your application I guess. I work with files in the gigabyte range, and there lazy *and* strict IO are totally unacceptable.
07:05:38 <mm_freak> in general iteratees don't fulfill the (a >=> b) >=> c = a >=> (b >=> c) law
07:06:02 <mm_freak> an example is when your iteratee yields more than it got
07:06:17 <mm_freak> Yield x rest, if rest has more data than the iteratee consumed
07:06:17 <yitz> adimit: i'm working a huge enterprise project at work. we're processing gigabytes of data. lazy io works just dandy.
07:06:46 <mm_freak> in other words, 'putting back' data breaks the law
07:06:56 <adimit> yitz: well, then I'm happy for you. It never did for me. I got frequent space leaks no matter how I twisted it.
07:07:17 <joe6> hpc, thanks.
07:07:18 <mm_freak> i found that out the painful way, because the iteratee type does not enforce that you never do this
07:08:05 <mm_freak> the ultimate abstraction for stream data processing is not there yet
07:08:05 <adimit> also, iteratees can work in the IO monad, so in theory, they can do all kinds of fancy side-effect laden stuff which would break the monad laws.
07:08:20 <mm_freak> adimit: those don't break the monad laws
07:08:53 <hpc> IO follows the monad laws, as it were
07:08:58 <dylukes> mm_freak: Sounds like a job for dependent types and length observed byte strings. :3
07:08:58 <yitz> adimit: you can't use lazy io naively - like any other currently usable haskell io system, it involves operation semantics. it's not complicated though. as easy to avoid space leaks as any other system, certainly including iteratees.
07:09:24 <mm_freak> dylukes: i think uniqueness types would solve that better
07:09:30 <jmcarthur> the only thing we know about IO is that is obeys the monad laws ;)
07:09:33 <jmcarthur> *it
07:09:38 <dylukes> mm_freak: No, you don't care about uniqueness, just quantity.
07:09:41 <yitz> jmcarthur: nope, not that either
07:09:46 <adimit> … well then I got mixed up, methinks.
07:09:58 <mm_freak> dylukes: anyway, we don't have either of them in haskell, so let's not start dreaming =)
07:10:05 <jmcarthur> yitz: kind of by definition, no?
07:10:06 <yitz> jmcarthur: in the presents of seq, the monad laws are violated too.
07:10:09 <dylukes> mm_freak: I suggest a grand migration to Agda + HSFFI
07:10:13 <mm_freak> processing streams is a very practical problem, which should have a practical solution
07:10:18 <jmcarthur> wha-?
07:10:28 <mm_freak> agda is quite impractical for real world development
07:10:41 <mm_freak> i think haskell makes the best tradeoff
07:10:43 <dylukes> https://github.com/larrytheliquid/Lemmachine
07:10:48 <dylukes> Something is being written :0
07:11:05 <yitz> mm_freak: people use agda in real world development to prove properties about their haskell programs.
07:11:08 <mm_freak> dylukes: yes, but it's still impractical, and you need to actually cheat to get real world stuff
07:11:14 <mm_freak> by interfacing with haskell
07:11:23 <dylukes> Right, but I don't think of that as cheating.
07:11:28 <jmcarthur> yitz: i'm not sure i see how the presence of seq causes IO to violate the monad laws
07:11:29 <yitz> mm_freak: i don't think they try to run agda programs in production though.
07:11:41 <mm_freak> yitz: yes, but they don't write their actual programs in agda
07:11:41 <adimit> well, I wrote an IRC client in Prolog once — doesn't mean network programming in Prolog is practical.
07:11:42 <dylukes> Rather, it's like the unsafe { } scope in C#, or modula's unsafe
07:11:48 <mm_freak> yitz: exactly
07:12:06 <mm_freak> dylukes: i do, because by interfacing to haskell's IO stuff, they break totality
07:12:15 <dylukes> mm_freak: That's true :\
07:12:22 <hpc> adimit: prolog has network libs?
07:12:34 <mm_freak> hpc: prolog has a lot of libs
07:12:36 <adimit> hpc: don't ask. But yeah, with swi, you actually can do that.
07:13:02 <mm_freak> i guess a few people do real world development with prolog
07:13:03 <adimit> It's such a messy business though. And then string processing in Prolog. The stuff of nightmares, I tell you.
07:13:17 <adimit> mm_freak: most of  them work in NLP (like I do.)
07:13:29 <mm_freak> main problem with prolog is that you have to give /everything/ a name
07:13:37 <arpunk> hello all. I've been trying to update all my cabal packages but I havent found any way around it. So far I've been using cab to list outdated packages and install them again with cabal. Is there a better way to do it?
07:13:39 <adimit> I think Haskell can do everything prolog is good at and do it better.
07:14:30 <dcoutts> arpunk: there's the somewhat experimental: cabal install world [--dry-run]
07:14:37 <mm_freak> arpunk: honestly when updating i just rename my .cabal and .ghc, do cabal update, update my configuration file and then install all packages from the world file
07:14:48 <adimit> mm_freak: there's more. It's slooow, it's hellish to debug, IO is awful (because there is no abstraction,) you can't write any non-trivial prolog program w/o it being automorphic…
07:15:55 <mm_freak> adimit: yeah, even though the idea of prolog is quite elegant, but there is little language support for more practical things, which quickly get beyond proving predicates
07:16:15 <arpunk> dcoutts: thanks a lot, im going to try that
07:16:26 <arpunk> mm_freak: you install them manually?
07:16:27 <adimit> arpunk: global updates have been taken out of cabal because of conceptual problems and frequent bugs. You can still update specific programs. You might also consider cabal-dev.
07:16:34 <arpunk> one by one, that is
07:17:09 <adimit> mm_freak: I did a sever thousand line project in Prolog, it was really awful. Prolog is cool and all, but it has no good abstraction over IO, which makes everything awful.
07:17:18 <dcoutts> adimit: btw, "cabal upgrade" has been replaced by "cabal install world"
07:17:18 <mm_freak> arpunk: yes, because cabal never deletes old stuff, and the more versions you have of a single package, the more complicated will the inter-package dependencies get
07:17:30 <adimit> dcoutts: oh, that's new to me. cute.
07:18:28 <mm_freak> adimit: i prefer haskell…  it seems to be stronger than prolog even for the things prolog was designed to solve elegantly
07:18:29 <arpunk> mm_freak: so it is recommended to just start with a clean environment and reinstall using the world file and 'cabal install X'?
07:18:50 <mm_freak> arpunk: give cabal install world a shot, i don't know how well it works
07:18:59 <adimit> mm_freak: I can tell from experience: it is. Now I just need NLP-ers to catch on to that. van Eijck and Unger did a good first step.
07:19:10 <mm_freak> if it doesn't work well, starting out clean is always a good option, if you have the time
07:19:34 <yitz> jmcarthur: found it. sorry it took a while: http://haskell.org/pipermail/haskell-cafe/2007-January/021536.html
07:21:14 <arpunk> mm_freak: i did cabal install world and i got this:
07:21:20 <arpunk> Resolving dependencies...
07:21:21 <arpunk> cabal: dependencies conflict: ghc-7.0.3 requires array ==0.3.0.2 however
07:21:23 <arpunk> array-0.3.0.2 was excluded because ghc-7.0.3 requires array ==0.3.0.3
07:21:33 <mm_freak> =)
07:21:50 <dcoutts> heh, that's not good
07:23:00 <arpunk> so i better backup my world file, delete .ghc and .cabal, and reinstall my packages, correct?
07:23:19 <mm_freak> that's the cleanest solution
07:23:22 <dcoutts> arpunk: no need to rm ~/.cabal, the packages db is in ~/.ghc
07:24:48 <mm_freak> i would remove .cabal, too, because otherwise you may have stray files from past installations
07:24:57 <mm_freak> don't remove it, though, just rename it
07:25:04 <dcoutts> mm_freak: that's not a problem except for disk space
07:25:37 <mm_freak> dcoutts: outdated binaries still in the $PATH?  i think that's a problem =)
07:26:00 <jmcarthur> yitz: i'm with Lennart on this one. the problem is seq, not IO
07:26:01 <dcoutts> the binaries don't cause any problems, the problem is with the libs
07:26:13 <dcoutts> if you really want to rm things, rm ~/.cabal/lib ~/.ghc
07:26:48 <jmcarthur> yitz: the Seq class proposal is typically formulated in a way that seq is not defined for any type which you can not write the implementation in Haskell
07:27:02 <mm_freak> i'd rather delete everything except ~/.cabal/packages and ~/.cabal/config
07:27:10 <jmcarthur> (using strict pattern matching)
07:27:16 <mm_freak> (or as said not delete, but rename)
07:27:18 <dcoutts> mm_freak: and ~/.cabal/world and ~/.cabal/logs
07:27:43 <mm_freak> dcoutts: actually you will want to remove the world file, unless you really always reinstall everything
07:27:54 <arpunk> alright, I'm installing the packages. I'm new to haskell and so far I've been amazed, thank you all and I'll let you guys know if I run into any issue
07:28:24 <dcoutts> mm_freak: if you don't want to reinstall everything, you can just not use cabal install world :-)
07:28:48 <mm_freak> dcoutts: but the world file will still be there collecting package names
07:28:55 <arpunk> I ended up removing the dir and reinstalling the world file packages
07:29:08 <dcoutts> mm_freak: I don't see the problem
07:29:12 <mm_freak> arpunk: should work =)
07:30:02 <mm_freak> dcoutts: IMO the world file should reflect your /current/ needs, not what you ever needed throughout your life…  after all it's not a log file
07:30:37 <dcoutts> mm_freak: right, but the point here is that arpunk wants to get back his current packages
07:31:03 <dcoutts> mm_freak: the world file will work better once we have uninstall
07:31:21 <dcoutts> since then it'll automatically remove things which you no longer want
07:36:06 <adimit> If I want to define a functor instance over (a,a) then I'll need my own Tuple type, right?
07:36:12 <kmc> yes
07:36:18 <adimit> poop.
07:36:19 <kmc> newtype Pair a = P (a, a)
07:36:21 <kmc> data Pair a = P a a
07:36:29 <kmc> they're basically equivalent
07:36:32 <lpsmith> Oh the mystery deepens.   I've noticed a space problem with Melissa O'Neill's sieve,  and I spent a little bit of time investigating it this morning again.
07:37:01 <adimit> kmc: yeah, I know. I just thought I could mess the type-voodoo into submission.
07:37:28 <adimit> this also means that I'll need to export the Tuple type in order to allow pattern matching, whichis kinda annoying.
07:37:36 <lpsmith> Now,  if I compile  import Math.Sieve.ONeill;   main = length (takeWhile (<(10^8)) primes)
07:38:14 <hpc> main :: Int?
07:38:33 <adimit> it's C all over again!
07:38:38 <lpsmith> GHC-6.12.3 will use over two gigabytes of space (which kills the process because of my ulimit),  whereas ghc-7.0.3 finishes fine with a smallish maximal residency
07:38:43 <lpsmith> However
07:39:31 <lpsmith> If you type the same expression into ghci,  the situation is reversed:  ghc-6.12.3 finishes with minimal residency whereas ghc-7.0.3 hits my ulimit of 2 gigabytes.
07:39:33 <mm_freak> adimit: haskell has a powerful type system compared to most languages, but there are things, which it simply can't do right now…  if you were able to write a functor instance for (a, a) right away, you could also write a functor instance for:  type Identity a = a
07:39:38 <zachk> !!
07:40:07 <joe6> is there an import statemnt which will allow all the functions in that module to be called without qualification, except for one which needs tobe qualified?
07:40:24 <mm_freak> joe6: use two import statements
07:40:25 <hpc> import qualified Foo (foo) as Foo;
07:40:28 <hpc> import Foo
07:40:31 <adimit> mm_freak: I was pretty sure it didn't make much sense to do that, but I had to ask, because I'm not familiar enough with Haskell's type system.
07:40:32 <hpc> s/;//
07:40:39 <joe6> import qualified Mod(x), then y and z can be called as is, whereas x needs to be called Mod.x
07:40:40 <adimit> (or type theory in general)
07:40:42 <joe6> hpc, thanks.
07:41:03 <mm_freak> hpc: i think that doesn't solve joe6's problem
07:41:05 <hpc> er, import Foo (therest)
07:41:13 <lpsmith> now, I'm pretty sure the issue is that the stream of primes is not getting garbage collected for some reason
07:41:20 <mm_freak> import Foo hiding (toBeQualified)
07:41:24 <mm_freak> import qualified Foo
07:41:27 <hpc> oh right, hiding
07:43:02 <mm_freak> adimit: problem here is that to do that you essentially have to be able to write type functions
07:43:18 <mm_freak> there may be a weaker solution to your problem, though
07:43:30 <mm_freak> but whatever it is, it's not implemented in GHC =)
07:43:56 <lpsmith> Hmm, at least that suggests that the problem might not be with Melissa's code.
07:44:01 <adimit> mm_freak: one of these days I'll jump into some type calculus, just for the heck of it.
07:44:20 <joe6> mm_freak, thanks.
07:44:57 <joe6> adimit, have you checked out "type level insanity" -- monad reader issue 8
07:45:10 <adimit> joe6: no, but I'll be sure to do that, thanks.
07:45:34 <joe6> adimit: it is pretty interesting and I felt it was very informative too.
07:45:52 <hpc> what exactly is a calculus?
07:46:00 <hpc> does it have a specific definition like algebra?
07:46:06 <mm_freak> it seems like people taste a strike of power never tasted before and then become thirsty for more and more…  i myself found to be doing that
07:48:02 <mm_freak> on the other hand i wonder what's the difficulty of supporting instances for partially applied type synonyms
07:48:49 <Moratio> [xmonad] hi, is it possible to start an application in tabbed layout, so that it don't gets the focus and runs in the "background" (acc. tabbed, not as process)
07:48:51 <hpc> type RPair b a = (a, b)
07:48:57 <hpc> instance Functor RPair b where ...
07:49:06 <hpc> instance Functor (,) a where ...
07:49:10 <mm_freak> hpc: that's possible without RPair
07:49:20 <kmc> you can't write an instance for a partially-applied type synonym
07:49:22 <adimit> Moratio: there's an #xmonad on freenode.
07:49:27 <mm_freak> oh, wait, no it's not
07:49:40 <adimit> Moratio: and you need a managehook. Though I'm not exactly sure how to do it.
07:49:53 <hpc> mm_freak: you would need a newtype RPair to pull it off
07:49:53 <mm_freak> hpc: well yes, that gives you overlapping instances, a problem, which is already present
07:50:13 <mm_freak> i rather sense an implementation difficulty somewhere
07:50:16 <rwbarton> it's not an issue of implementation, but of the concept not really making sense
07:51:50 <mm_freak> rwbarton: where does it fail?
07:52:03 <rwbarton> e.g. consider return :: a -> m a, if 'm a' doesn't have to be the application of a type constructor, but can be the application of a type synonym, how can you ever infer what m is from any use of return
07:52:51 <mm_freak> rwbarton: what's the problem of looking at the instances in scope?
07:53:50 <adimit> how "good" are the GHC extensions Derive{Foldable,Traversable,Functor}? Any pitfalls I have to be watching out for? I couldn't find anything on the net.
07:54:12 <mm_freak> adimit: for newtype or for data?
07:54:26 <adimit> mm_freak: both, really. But newtype would be enough for now.
07:54:30 <hpc> mm_freak: newtype is covered by generalized newtype deriving
07:54:43 <mm_freak> adimit: for newtype they are equivalent to GeneralizedNewtypeDeriving
07:55:06 <benmachine> rwbarton: type Foo a = Integer is a valid type synonym
07:55:18 <benmachine> wait, you already knew that
07:55:23 <benmachine> I forget who I was going to say that to
07:55:30 <benmachine> but yeah, instance Monad Foo would be decidedly hairy
07:55:42 <hpc> mm_freak: ^
07:55:42 <rwbarton> or worse, type Foo a = IO (), or whatever
07:56:17 <adimit> and how "good" are they on data?
07:56:21 <mm_freak> such an instance would be isomorphic to the unit monad, i guess
07:57:01 <mm_freak> so it's as bad as newtype Foo a = Foo Integer
07:57:02 <rwbarton> perhaps the argument is that this is no worse than OverlappingInstances are already
07:57:09 <rwbarton> no, it's totally different
07:57:18 <hpc> benmachine: no, wait; type Foo a = Integer already breaks the concept without the Monad constraint
07:57:26 <hpc> ie, m a vs Monad m => m a
07:57:38 <benmachine> hpc: do not follow
07:57:40 <mm_freak> but i can see where you're getting at
07:58:02 <benmachine> we're talking about why you can't have instances of partially-applied type synonyms, right?
07:58:03 <mm_freak> partially applied type synonym instances are much easier to be abused and can lead to overlapping instances much more quickly
07:58:17 <mm_freak> but my question is, why you /can't/ have them
07:58:27 <benmachine> mm_freak: partially applied type synonyms aren't types, really
07:58:29 <rwbarton> IMO you can't even have overlapping instances, so :P
07:58:30 <hpc> benmachine: someone argued that it breaks the idea of m being a type constructor
07:58:33 <benmachine> type synonyms are more like macros than functions
07:58:41 <adimit> hpc, mm_freak: btw, trying to do newtype Bracket a = Bracket (a,a) deriving (Foldable,Traversable) and ghc says: Can't make a derived instance of `Foldable Bracket' (even with cunning newtype deriving)
07:58:43 <benmachine> hpc: right, yeah
07:58:45 <adimit> at least ghc is funny.
07:58:45 <benmachine> I suppose so
07:58:54 <hpc> benmachine: just demonstrating that what it breaks is already a part of ghc
07:59:07 <benmachine> adimit: have you got DeriveThingy turned on?
07:59:14 <hpc> suppose foo :: m a
07:59:20 <hpc> then m = Foo
07:59:29 <benmachine> DeriveFoldable
07:59:49 <mm_freak> benmachine: problem is that :k is lying to me
07:59:52 <adimit> benmachine: nope, I wanted to see if GeneralizedNewtypeDeriving would cover my uses for newtype.
07:59:57 <mm_freak> when i define:  type X = Maybe
08:00:06 <mm_freak> then :k X tells me:  X :: * -> *
08:00:25 <benmachine> adimit: oh right, it won't because your wrapped type isn't something applied to the relevant type variable
08:00:44 <rwbarton> why is that a lie?
08:00:45 <benmachine> mm_freak: huh?
08:00:53 <benmachine> oh right
08:00:54 <benmachine> yes
08:00:59 <adimit> benmachine: ah, interesting.
08:01:19 <mm_freak> because technically any * -> * can be an instance of Functor
08:01:22 <benmachine> adimit: I think so anyway, I'm hazy on the details, but NewtypeDeriving is only supposed to be able to handle simple liftings
08:01:26 <rwbarton> no
08:01:35 <benmachine> mm_freak: what makes you think that?
08:01:37 <mm_freak> unless it's a type synonym
08:01:39 <rwbarton> this is just like the distinction between data constructors and arbitrary values
08:01:53 <mm_freak> benmachine: class Functor (f :: * -> *)
08:01:55 <adimit> benmachine: well, (a,a) looked simple, but I guess I know why it isn't 'simple'
08:02:27 <benmachine> adimit: what would the foldable instance be? the thing would have to work out that it should mappend the things
08:02:34 <benmachine> (I seem to be saying thing a lot today)
08:03:49 <adimit> benmachine: yeah (a,b) = a `mappend` b, I guess. It's a little sucky, I don't actually *want* Foldable, just Traversable for generalised mapM
08:03:51 <kmc> mm_freak, but sometimes the only fmap you can give is fmap _ _ = undefined
08:03:55 <kmc> or something similarly useless
08:04:08 <benmachine> adimit: DeriveFoldable, then? :)
08:04:22 <mm_freak> kmc: let's go away from Functor
08:04:24 <adimit> benmachine: that's what I ended up doing :-)
08:04:30 <mm_freak> class SomeClass (t :: * -> *)
08:04:51 <mm_freak> if i can't define an instance for a partially applied type synonym, then it should have a different kind
08:05:02 <rwbarton> this isn't even a type class issue really
08:05:19 <benmachine> mm_freak: you may have a point
08:05:21 <mm_freak> yes, i'm just using a type class to show the problem i sense
08:05:23 <kmc> type synonyms aren't first-class type expressions
08:05:27 <kmc> they're like macros
08:05:31 <benmachine> kmc is correct
08:05:42 <benmachine> one could argue that :k is pretending they are type constructors
08:05:45 <kmc> macro application is not the same as function application
08:05:45 <benmachine> and that's not true
08:05:47 <rwbarton> > let { my_id :: f a -> f a; my_id x = x } in my_id 'a'
08:05:48 <lambdabot>   Couldn't match expected type `f a'
08:05:48 <lambdabot>         against inferred type `GHC.Types...
08:06:07 <kmc> yeah
08:06:10 <benmachine> interesting note: in haskell2010, type synonyms aren't allowed in instance declarations *at all*
08:06:25 <joe6> how do I convert from CUShort to Word16? they both seem to have the same size and the same instances.
08:06:26 <rwbarton> mm_freak: you will have to do something about that, before you can ask about type classes for partially applied type synonyms
08:06:38 <mm_freak> kmc: i guess my point is that :k should not tell me that it's a real type constructor
08:06:49 <joe6> fromIntegral.
08:06:55 * benmachine wonders if partially applied type families or data families are any different
08:06:55 <joe6> seems to work.
08:07:32 <benmachine> joe6: fromIntegral is usually a good bet, yes - CUShort isn't necessarily 16 bits though, I think
08:07:40 <benmachine> it's "the size of an unsigned short" whatever that is
08:07:47 <kmc> mm_freak, yeah, agreed
08:08:11 <mm_freak> rwbarton: oh, that's new to me
08:08:20 <mm_freak> i wonder why the pattern match doesn't work
08:08:51 <benmachine> mm_freak: the pattern match?
08:09:07 <mm_freak> oh wait
08:09:09 <mm_freak> misread the code
08:09:12 <mm_freak> ok, forget it =)
08:09:28 <rwbarton> it's a type error because 'f a' means "the application of a type constructor to a type"
08:09:39 <rwbarton> which Char is not, even though it's also (Const Char) Int, for instance
08:09:40 <benmachine> right
08:09:45 <rwbarton> where type Const a b = a
08:10:02 <hpc> oh, Const a is a partially applied MACRO
08:10:04 <mm_freak> rwbarton: i see, that's a good point
08:10:04 <benmachine> type constructors are injective, and this is sort of important
08:10:05 <hpc> not a type constructor
08:10:26 <rwbarton> if you relax this condition on what 'f a' means I think you find that basically all type inference becomes impossible
08:10:36 <benmachine> (if you are not familiar with the term, if T is a tycon then T x = T y means that x = y)
08:10:46 <benmachine> (this is not true of type synonyms)
08:11:36 <mm_freak> benmachine: huh?
08:11:39 <rwbarton> all type inference for types which are polymorphic in types of kinds other than * I mean
08:11:55 <mm_freak> benmachine: in general or only when unifying?
08:12:14 <mm_freak> oh, got it
08:12:54 <rwbarton> really what matters is injectivity of (f, a) |-> f a
08:13:13 <benmachine> rwbarton: so if f a = g b then f = g and a = b?
08:13:14 <justin-kp> if I have a cabal build for a project, is there an easy way to load a ghci instance with all my modules available?
08:13:18 <rwbarton> right
08:13:22 <benmachine> yeah
08:13:46 <mm_freak> justin-kp: have a module, which loads all other modules
08:13:55 <mm_freak> load that one into GHCi
08:14:22 <benmachine> you can also use a .ghci file to load everything yourself
08:14:39 <justin-kp> okay cool
08:14:43 <justin-kp> i will try that
08:15:02 <benmachine> it's a bit more painful when you have modules that are autogenerated or whatever
08:19:00 <kqr> is there any way to curry (length xs < 4) into an expression that takes xs as one argument? (i'm new to haskell so excuse me if i use the wrong word)
08:19:15 <kqr> (without using lambda, that is)
08:19:19 <kmc> @pl \xs -> length xs < 4
08:19:19 <lambdabot> (< 4) . length
08:20:01 <kmc> > map ((<4) . length) (words "into an expression that takes xs as one argument")
08:20:01 <lambdabot>   [False,True,False,False,False,True,True,True,False]
08:20:40 <kqr> wow
08:21:48 <kqr> i shouldv'e seen that
08:21:49 <kqr> thanks anyways
08:22:18 <rwbarton> btw if the list is potentially wrong, it's more efficient to write null . drop 3
08:22:45 <kqr> potentially wrong?
08:22:48 <rwbarton> er
08:22:52 <rwbarton> potentially long, sorry :)
08:22:57 <kqr> haha, oh right
08:22:59 <rwbarton> no idea where that came from
08:23:05 <kqr> clever
08:23:12 <dylukes> I think template haskell removes the need for any "generated" modules (other than itself)
08:23:22 <dylukes> anything that generates haskell can be quasi quoted instead.
08:23:52 <kmc> meh, you can talk about necessity, or you can talk about the best way to solve a problem
08:23:53 <kqr> i tried learning haskell a couple of years ago or so, but got stuck on the monads. today i'm a little more hell-bent, because stuff like that is amazing
08:24:21 <kmc> kqr, don't get too hung up on monads.  they're not a big deal; they're not like the main Haskell thing, as you might have been led to believe
08:24:30 <hpc> kqr: go through lyah
08:24:51 <kqr> no, the problem seems to be that i can't use them unless i understand them
08:24:55 <kmc> "Monad" is just an API that's implemented by a lot of different types, which don't necessarily have much in common
08:25:05 <MichaelBurge> Monads are just a way of lifting ordinary function composition to something that means something different
08:25:10 <kqr> and IO is kind of important sometimes
08:25:21 <kmc> kqr, yeah, but you can do IO without understanding the M-word at all
08:25:27 <kqr> (and sockets and files and so)
08:25:29 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
08:25:37 <kmc> IO is a bad example of a monad
08:25:37 <kqr> kmc, i wasn't able to earlier
08:25:40 <MichaelBurge> and IO is a special case
08:25:45 <kmc> it's an unusual monad
08:25:49 <kqr> i do have difficulties remembering stuff i don't understand
08:26:19 <kqr> although the type system seems to be a huge part of haskell
08:26:20 <kqr> is it?
08:26:24 <kmc> yes
08:26:25 <MichaelBurge> yes
08:26:31 <kqr> how can that be
08:26:38 <kmc> ?
08:26:39 <dylukes> My suggestion with monads for an newbie is simple
08:26:40 <kqr> i don't know any other language where the types are like half of what's going on
08:26:46 <dylukes> 1) fuck the monad laws, you don't need them to USE monads
08:26:55 <dylukes> 2) discount IO as a monad, appreciate it as a unique construct (it is)
08:26:57 <dylukes> 3) Read LYAH
08:27:05 <hpc> mostly 3
08:27:10 <kmc> kqr, that's because most languages either a) have awful type systems or b) give up on the idea entirely
08:27:27 <kqr> dylukes, yeah, i'm reading lyah right now, and i've just got to IO
08:27:41 <dylukes> kqr: Don't try to reason with IO in terms of monads.
08:27:44 <copumpkin> @remember gosu Type parameters are covariant. This is not sound, and that does not matter.
08:27:45 <lambdabot> Done.
08:27:47 <kmc> kqr, basically there is a huge body of research since at least 1970 on how to make type systems that don't suck, and actually help you program
08:28:00 <kmc> kqr, and that research is entirely ignored by most programming languages
08:28:01 <dylukes> kmc: "Type Classes: Exploring the Design Space" kind of reveals a lot of warts though.
08:28:12 <dylukes> kmc: I have to wonder if there's a more elegant solution that's all encompassing.
08:28:14 <kqr> dylukes, alright, i'll keep that in mind
08:28:22 <kqr> dylukes, does sockets or files count as IO?
08:28:28 <dylukes> Yes.
08:28:33 <copumpkin> using them does
08:28:34 <kqr> kmc, interesting
08:28:41 <dylukes> kqr: I think the Maybe monad is the easiest to approach.
08:28:41 <copumpkin> the sockets or files themselves aren't IO :P
08:28:50 <dylukes> copumpkin: No, but using them is.
08:28:54 <kqr> dylukes, i've just seen it represented as a type, yet, and not as a monad
08:28:56 <copumpkin> I just said that
08:29:12 <dylukes> kqr: Right, a monad is just a "classification" a type can be given,
08:29:16 <dylukes> if it satisfies some properties.
08:29:18 <kmc> kqr, basically type systems have an effort-to-benefit ratio.  the benefit is catching bugs, and the effort is writing down types, or having to think about types when you wouldn't otherwise
08:29:28 <dylukes> i.e, "if you do X, Y, and Z, you're a monad and you get some syntactic sugar"
08:29:39 <kqr> kmc, but the types in haskell are good for documentation and planning functions as well?
08:29:42 <kmc> kqr, Haskell's type system is very good at catching bugs, and the effort is very low
08:29:44 <dylukes> kqr: Anything that interacts with the real world is IO.
08:30:01 <kqr> dylukes, hm, okay
08:30:02 <kmc> because you have type inference, and because of powerful polymorphism for free
08:30:04 <dylukes> kqr: Yes, for instance, anything that has the type ... -> IO something
08:30:08 <kmc> kqr, yeah, they're good for that too
08:30:10 <dylukes> you know is an IO action.
08:30:15 <kmc> dylukes, that's false
08:30:23 <nomeata> Hi. Does ghc define some preprocessor variable to detect whether ghci (and hence TH and annotations) is supported?
08:30:30 <dylukes> kmc: ...I'm tryng to generalize for simplicity' ssake.
08:30:31 <dylukes> ^^;
08:30:38 <kmc> don't lie to beginners
08:30:47 <kmc> you're misusing terminology in a way that will cause problems
08:30:53 <skchrko> kqr, read 'Learn You a Haskell', for sure. It is a great introduction (and is available online!). And it eliminates many misconceptions about monads-and-all-that-stuff
08:30:56 <dylukes> Okay, sorry, that's not my intent.
08:30:59 <kmc> a value of type (IO T) is itself an IO action
08:31:03 <kmc> functions can return IO actions
08:31:10 <kmc> this isn't special; it's just like returning any other value
08:31:18 <dylukes> ah, I mixed up "is an" and "returns an"
08:31:22 <dylukes> er, results in
08:31:27 <dylukes> sorry ^^
08:31:45 <kqr> skchrko, yeah, i'm doing that, thanks
08:33:54 <kmc> i'm actually downplaying the type system in my "Why learn Haskell?" talk, though
08:34:13 <kqr> why?
08:34:14 <copumpkin> heresy!
08:34:27 <kqr> do you give the talk regularly or is it a one time thing, like an assignment?
08:34:30 <dylukes> I think the attractive feature of Haskell is not type safety, but abstraction.
08:34:32 <copumpkin> most people get knee-jerk reactions about types :P
08:34:34 <dylukes> That's my usual thoughts on the matter.
08:34:36 <kmc> i think it's hard to convince someone in one or two slides that types will actually help you catch bugs
08:34:50 <kmc> it's not even that i'm expecting wrong knee-jerk reactions
08:34:51 <Gagis> good point there
08:35:04 <kmc> just that "if your code compiles, it will probably work" is an extraordinary claim that requires extraordinary evidence
08:35:06 <Gagis> many people have learned to fear types
08:35:12 <dylukes> kmc: On an amusing side note, just explaining length-observed lists seems to have made my high school CS teacher really enthusiastic about dependent typing
08:35:29 <kqr> compare the types to dimensional analysis?
08:35:39 <kmc> kqr, i'm doing one as part of http://cluedumps.mit.edu
08:35:57 <ezyang> It shouldn't be too hard to convince people that types catch the stupid typo bugs.
08:35:58 <Gagis> kqr ooh, clever comparison
08:36:19 <dylukes> ezyang: and the more complex ones when you're working in a complex system.
08:36:31 <kmc> they help a *lot* with refactoring, too
08:36:39 <dylukes> kmc: I was about to say.
08:36:49 <dylukes> That's the one thing I really really really like in Haskell.
08:36:53 <dylukes> The purity aspect also helps with that.
08:36:54 <kmc> you can approach refactoring in such a way that you know your code won't typecheck until you've touched all the bits you need to
08:36:57 <kmc> dylukes, the only one? ;P
08:37:04 <dylukes> kmc: no haha sorry
08:37:05 <dylukes> expression
08:38:54 <kmc> anyway i have enough other examples of why learning Haskell is worthwhile
08:39:17 <kmc> which actually fit on a slide and are self-evidently cool
08:39:28 <kmc> i'll probably post the slides for comments sometime soon
08:39:53 <parcs> doesn't the type system introduce other, more obscure bugs though? like what kmc once exemplified, (>>) vs liftM2 (>>)
08:40:17 <copumpkin> not sure how you'd say that introduces bugs
08:40:22 <kmc> polymorphism does
08:40:22 <copumpkin> it may allow them
08:40:29 <kmc> especially ad-hoc polymorphism i.e. type classes
08:40:36 <Gagis> would be nice to read. we just entered a haskell course here and some extra motivation never hurts
08:40:49 <parcs> well that's an important part of the type system
08:41:23 <kmc> i'm not expecting to actually teach anyone Haskell in one hour, so I'm free to leave off topics which are boring or difficult to explain, even if they're important
08:41:38 <kmc> i'm becoming more and more convinced that one should rigidly separate evangelism from teaching
08:41:54 <kmc> it's annoying when your textbook stops every 3 paragraphs to reassure you that no Haskell really is cool and please don't give up yet
08:42:20 <brisingr> keep it concise, keep it mind-bending
08:42:30 <Gagis> right you are. its annoying in pretty muvh every other topic too
08:42:42 <brisingr> the audience loves mind-bending even though you may lose some of them
08:42:56 <kmc> i have the privilege of talking to a very intelligent audience, too
08:44:00 <brisingr> lucky you
08:44:10 <Gagis> modern science textbooks tend to do that a lot too. very much "oh hey this can be applied to popular culture aspect A" and very little mind bending and depth in the core subject
08:44:11 <brisingr> I still dream of the day I can advertise haskell to mathematicians
08:44:18 <kmc> yeah Gagis
08:44:49 <kmc> brisingr, in my experience mathematicians don't see the big deal, if they haven't programmed much
08:45:07 <kmc> it's just obviously how a programming language should work
08:45:15 <Gagis> brisingr haskell advertises itself to mathematicians pretty autonomously. i got into it because the syntax reminds me a lot of math lectures :P
08:45:33 <brisingr> kmc: exactly, but few do
08:45:41 <rpglover64> Hi all; I would like some help understanding Iteratees, specifically from the Enumerator package.
08:45:49 <brisingr> the day C++ has monads will be the day I'll run naked in the street
08:46:01 <kmc> brisingr, define "has monads".  it has the requisite form of polymorphism
08:46:07 <cheater> kmc: what is obviously how a programming language should work?
08:46:11 <cheater> haskell?
08:46:27 <brisingr> "has monads" in the way that it will never do
08:46:37 <kmc> Monad is just a type class, anyway.  you can define the same interface in C++, although it'll be a "Concept" in documentation and not a language feature
08:46:58 <brisingr> yeah, as a language feature
08:46:59 <Gagis> haskell is very intuitive to what a mathematician would think on how programming should work
08:47:26 <parcs> Gagis: really?
08:47:32 <osaunders> Hi there, Is there a more general way to do «updateAbc f rec = rec { abc = f (abc x) }»?
08:47:52 <osaunders> an extension perhaps?
08:47:59 <kmc> osaunders, http://hackage.haskell.org/package/fclabels
08:48:06 <brisingr> I've noticed that programming in general is avoided by mathematicians, but I digress
08:48:14 <kmc> with good reason
08:48:16 <rpglover64> I'm trying to start simple and tripping up; I have a text literal with newlines, and I would like to split it on the newlines using iteratees.
08:49:23 <osaunders> kmc: So you can’t do this with GHC without an additional library?
08:49:26 <Gagis> well true, its usually us phycisists who combine programming and mathematics in perverted and twisted ways
08:49:44 <brisingr> if there's something I've learned from my talk is keep it unique, and no more than 10 minutes on syntax
08:49:55 <tech2> Gagis: no, no, that's economists you're thinking about :)
08:50:04 <Gagis> :P
08:50:05 <brisingr> the data Trool = Yeah | Nope | Dunno tripped them up
08:50:36 <osaunders> Another question: I understand existentially quantified types now but what are they generally used for?
08:50:49 <wjlroe> Anybody have any pointers about how to run a bunch of system commands and chain them (without branching case statements for the ExitCode returned for each one)? System.Cmd.system is what I'm using
08:50:50 <kmc> extensible variants
08:50:59 <kmc> osaunders, e.g. Control.Exception
08:51:09 <osaunders> kmc:
08:51:18 <kmc> the other thing they're generally used for is making unnecessarily complicated typeclass designs
08:51:21 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
08:51:23 <cheater> kmc: answer pls
08:51:27 <kmc> fuck you cheater
08:51:44 <osaunders> lol
08:53:00 <kmc> osaunders, you can also use existentials to implement abstract data types or OOP-style objects
08:53:06 <kmc> but there are often simpler ways
08:53:10 <cheater> that wasn't very nice
08:53:56 <osaunders> kmc: If you wouldn’t mind, explain to me what you mean by OOP-style objects as if I had no idea what that was.
08:54:17 <kmc> i mean objects as found in a traditional object-oriented programming language
08:54:59 <kmc> though OOP advocates take credit for the much older idea of abstract data types
08:55:04 <krawczyk> objects as collections of data and methods?
08:55:20 <kmc> and also for pretty much every good software engineering practice
08:55:28 <kmc> yeah krawczyk
08:55:41 <cheater> what about structured programming
08:55:46 <cheater> where is your OOP without it
08:55:59 <cheater> you are totally skipping the structured programming advocates
08:56:11 <cheater> makes sense if someone grew up with java though
08:56:48 <osaunders> kmc: Ah OK, that actually helped
08:57:01 <osaunders> Do you every do that?
08:57:05 <osaunders> *ever
08:57:10 <kmc> ever do what?
08:57:10 <osaunders> OOP-style, I mean
08:57:14 <kmc> ah
08:57:16 <kmc> on occasion
08:57:35 <osaunders> What situations benefit from it?
08:57:43 <cheater> exceptions
08:58:06 * osaunders goes to read Control.Exceptions now
08:58:14 <kmc> meh, Control.Exception is not really very OOP
08:58:22 <kmc> it's just like a subtype hierarchy
08:58:26 <kmc> OOP did not invent subtyping, either
08:58:45 <kmc> OOP is a marketing term from the 1990's and one should be suspicious of attaching every good thing ever to it
08:58:54 <kmc> perhaps FP is the analogous term of the 2010's
08:59:20 <hpaste> kmc pasted “generic container interfaces with existentials (for osaunders)” at http://hpaste.org/50959
08:59:27 <benmachine> kmc: I think the fit-in-a-few-slides argument I'd give for a type system is basically the haskellwiki article on phantom types
08:59:35 <benmachine> I think they're awesomecool
08:59:37 <hpc> kmc: except that FP is way older than OOP and coopted only recently to be "everything good"
08:59:43 <kmc> right
08:59:54 <kmc> thanks for the suggestion benmachine
09:00:03 <benmachine> http://haskell.org/haskellwiki/Phantom_type
09:00:09 <Phyx-> lol, Ninja Warrior is entertaining
09:00:13 <Phyx-> whoops, wrong channel
09:00:20 <kmc> derp
09:00:29 <hpc> benmachine: related to phantom types, you can also try and squeeze in GADTs
09:00:36 <kmc> that's not Haskell though ;P
09:00:36 <hpc> or kmc
09:00:37 <benmachine> heh
09:00:41 <hpc> ;)
09:00:51 <benmachine> yeah phantom types are super-simple, is part of the appeal
09:01:28 <osaunders> hpc: I don’t think it means “everything good” yet. Only to people like us. Mostly it means “that confusing stuff” to most people
09:01:35 <osaunders> kmc: Ah this is cool
09:01:49 <kmc> yeah.  most of the 2010's has not happened yet
09:02:38 <kmc> certainly #haskell has a tendency to define "functional language" as "any language which is exactly like Haskell in every respect"
09:02:49 <kmc> when really, Haskell is an unusual functional language
09:03:16 <benmachine> functional language to me means "can return functions and pass functions as arguments"
09:03:24 * osaunders saves kmc’s hpaste
09:03:28 <benmachine> return and create as well
09:03:28 <kmc> yeah, which is a very low bar met by pretty much every language
09:03:32 <benmachine> well
09:03:34 <benmachine> conveniently
09:03:35 <kmc> it's only seen as exotic because it's missing from Java, basically
09:03:41 <kmc> and it's not even totally missing there
09:03:47 <benmachine> requiring conveniently rules out C and Java and probably C++
09:03:52 <kmc> anonymous inner class objects are basically closures, just with hideously verbose syntax
09:04:01 <benmachine> which are only a few languages but quite a large section of the totality of everything
09:04:06 <kmc> yes
09:04:16 <kmc> but Perl and Python and Ruby and Javascript programmers have no problem with FP
09:04:17 <benmachine> when measured by, like, biomass
09:04:23 <benmachine> sure
09:04:32 <kmc> Python has, like, an official party dogma against FP, but they use it all over anyway
09:04:36 <benmachine> heh
09:04:43 <iago> I though "first-order functional languages" exist
09:04:49 <kmc> just have to change the names of all the concepts and fuck up the syntax a little bit
09:04:50 <cheater> yeah python is a functional language
09:04:52 <kmc> so nobody will catch on
09:04:57 <benmachine> :P
09:05:14 <cheater> the word you are looking for is "declarative"
09:05:24 <cheater> as opposed to "constructive" which python is
09:05:33 <geheimdienst> kmc, naming is important
09:05:46 <geheimdienst> so is syntax (see: java anonymous classes etc.)
09:06:43 <kmc> agreed
09:06:53 <osaunders> Reading http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ is interesting
09:07:01 <osaunders> When I first started in Haskell I used lots of classes
09:07:03 <kmc> i think it validates the usefulness of FP that people are willing to endure such extreme pain to do FP in Java and C++
09:07:04 <osaunders> Now I try to avoid them
09:07:05 <kmc> look at Boost
09:07:10 <skchrko> osaunders, 'OOP-style object' may be seen an existential type unpacked at the latest possible moment
09:07:19 <hpc> boost isn't really FP in C++
09:07:22 <hpc> it's FP in CPP
09:07:30 <hpc> ;)
09:07:34 <kmc> not that much of boost is CPP-based
09:07:35 <benmachine> osaunders: classes are totally overrated :)
09:07:43 <osaunders> benmachine: Yeah I think so
09:07:45 <kmc> i mean Boost is a collection of hundreds of barely related libraries
09:08:01 <osaunders> I think classes are just a sugar for very very general things like Eq and Ord and stuff
09:08:02 <kmc> but many of them are on the them of "reimplement trivial Haskell features in 10000 lines of C++"
09:08:15 <kmc> yay osaunders is coming over to my ideological view :)
09:08:37 <osaunders> benmachine: Maybe I’m underselling them a bit too much there but they aren’t a powerful new form of abstraction or anything, which is what I thought at first
09:09:03 <hpc> osaunders: they make a nice way of giving names to guarantees that can't really be statically proven
09:09:07 <hpc> like the monad laws
09:09:26 <kmc> i think of type classes as a) a scheme for implicit function parameters, b) a way to register globally the allowed arguments at those implicit parameters
09:09:32 <kmc> (b) gives you some nice coherence guarantees
09:09:54 <benmachine> mm
09:09:55 <osaunders> hpc: Yes. Hopefully in the future we will be able to prove those things statically
09:09:59 <benmachine> you get some uniformity
09:10:23 <benmachine> which is... sometimes what you want :P
09:11:04 <hpc> i think people confuse classes as a way to get polymorphic data structures, when they are really a way to get polymorphic functions
09:13:00 <osaunders> hpc: Half the time you can get the polymorphism you need by constructing a type that can hold any of the things you need
09:13:24 <osaunders> data Token = TokInt Int | TokChar Char etc.
09:13:35 <kmc> yep
09:13:46 <kmc> classes look fancy and sound like familiar OOP stuff, so they get overused
09:13:59 <kmc> functions and data are so simple that they're easy to overlook
09:14:00 <osaunders> It‘s only if that type is going to have to handle SO MANY THINGS that you need a type class :)
09:14:13 <kmc> also, Java teaches you that every new behavior needs a new type
09:14:15 <hpc> thankfully i haven't had to deal with polymorphism difficulties in a while, so i don't think about this much :D
09:14:17 <kmc> which just ain't so in Haskell
09:14:54 <osaunders> Anyway, pretty much my policy is just to do whatever I can with dumb types and functions I find that takes me pretty damn far
09:15:17 <hpc> osaunders: same here, occasionally with a monad to put the pieces together
09:15:23 <osaunders> Yeah
09:15:28 * osaunders need food now
09:25:20 * JuanDaugherty has renewed respect for the java culture from recent work
09:25:43 <KirinDave> They're not all insane
09:26:07 <JuanDaugherty> who?
09:26:17 <KirinDave> Java culture denizens.
09:26:24 <KirinDave> Stuff tends to Work over there, even if it often takes 10x more work than it should to accomplish. ;)
09:26:37 <kmc> yep, that's exactly the point
09:26:38 <JuanDaugherty> Kirin: as opposed to haskellers?
09:26:49 <kmc> that's why industry loves Java
09:26:56 <kmc> because that 10x factor is a predictable known quantity
09:27:22 <jpcooper> hello
09:27:22 <osaunders> You couldn’t actually say stuff tends to work for Ruby, Perl, or PHP
09:27:32 <KirinDave> JuanDaugherty: There are lots of things haskellers all implement in parallel. Because haskell is like lisp is that small things can be really easy to write.
09:27:52 <KirinDave> osaunders: As a member of a ruby shop, i will keep my mouth closed here. Mostly because I need to listen for pager duty. :)
09:28:10 <KirinDave> JuanDaugherty: But sometimes things are deceptive. Like a logging framework.
09:28:36 <KirinDave> JuanDaugherty: Logging in such a way as to efficiently make complete messages get written to disk without unnecessarily exhausting memory?
09:28:40 <KirinDave> Not always easy.
09:28:49 <JuanDaugherty> well java is pretty much the dominant enterprise platform these days
09:28:57 <KirinDave> Of course, some people will tell you that logging is just WriterT, and that's not _wrong_.
09:29:03 <KirinDave> It's just there is a lot more to it than that.
09:29:17 <jpcooper> let's say I have an action of type IO (Maybe a), and I want to repeat this action, getting every value of type a in a list until the first Nothing value arises. I have been doing this with: fmap (map fromJust . takeWhile isJust) . sequence . repeat. For some reason my programme is hanging. Could it have anything to do with laziness or should I look somewhere else?
09:29:50 <KirinDave> jpcooper: Generally iterating inside a monad uses things like mapM or forM.
09:30:20 <KirinDave> Also, note that IO a's tend to get computed once. :)
09:30:27 <jpcooper> oh and I did fmap (take 10) on the value returned, and I know that the previous thing should give more than 10 values
09:30:41 <jpcooper> even with sequence . repeat?
09:30:48 <JuanDaugherty> but throughout computing I find a kind of pervasive punk aspect, the result of the presence of people whose training is superficial and who will be driven out of programming in a few years but the nature of the biz
09:31:05 <KirinDave> You'd probably have to paste the code in hpaste or gist before we could help you with your specific problem.
09:31:16 <jpcooper> yes I'll do it
09:31:18 <JuanDaugherty> haskell culture is an interesting twist on that
09:31:24 <KirinDave> Probably someone else can help you more. TBH the rules for when to use IO (IO a) and IO a still sort of confuse me.
09:31:55 <JuanDaugherty> *by the nature
09:32:08 <KirinDave> JuanDaugherty: There is also a culture of radical simplicity as a response to difficulty. This isn't always a good thing, it tends to lead to overly conservative shops, which can't benefit from new work
09:32:09 <jpcooper> actually instead of IO (Maybe a) could I just check for fail?
09:32:12 <KirinDave> I suppose you don't see that in haskell.
09:32:23 <KirinDave> jpcooper: IO (Maybe a) is a good type.
09:32:26 <jpcooper> okay
09:32:36 <KirinDave> Either is often better, but...
09:33:18 <hpaste> jpcooper pasted “Monadic Mischief” at http://hpaste.org/50960
09:33:52 <JuanDaugherty> KirinDave, yes in fact it's a major and dominant thread in agile, ruby, etc. Not a bad thing when done right, but often as not just a cover for various social maladies
09:36:07 <jpcooper> KirinDave: any ideas?
09:42:04 <roconnor> jpcooper: sequence . repeat will run your action forever
09:42:29 <jpcooper> roconnor: why is it not lazy?
09:42:38 <hpc> usually you would want sequence_ . repeat just to make it m ()
09:42:48 <roconnor> @type sequence . repeat
09:42:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
09:42:55 <jpcooper> yes that makes total sense
09:43:08 <roconnor> hpc: even sequence_ . repeat won't work.
09:43:20 <jpcooper> I suppose it needs the end of the list before it can construct anything
09:43:26 <roconnor> jpcooper: exactly
09:43:34 <roconnor> jpcooper: BTW, it would work for some monads
09:43:36 <roconnor> but not IO.
09:43:42 <hpc> there's also fix (action >>)
09:43:59 <roconnor> jpcooper: I don't know of any good combinator way of doing what you want off the top of my head
09:44:16 <roconnor> jpcooper: so I would just write it by do notation
09:45:07 <jpcooper> yeah I think I'll do that
09:45:20 <roconnor> foo act = act >>= test where { test Nothing = return []; test (Just a) = (a:) <$> foo act }
09:45:25 <parcs> @src forever
09:45:25 <lambdabot> Source not found. My mind is going. I can feel it.
09:45:56 <roconnor> preferably with a better name than "test"
09:46:53 <parcs> why is void in Control.Monad?
09:48:08 <kmc> :t void
09:48:08 <lambdabot> Not in scope: `void'
09:48:16 <roconnor> parcs: probably same reason fix is in Control.Monad.Fix :^)
09:48:20 <monochrom> I don't have void in my Control.Monad
09:48:21 <kmc> is it fmap (const ()) ?
09:48:49 <monochrom> fix has been moved to Data.Function for two GHC minor versions already
09:48:49 <parcs> yah
09:48:59 <kmc> it's for use in do syntax
09:49:05 <kmc> with the new "unused result" warning
09:49:45 * roconnor presums void :: Void -> a
09:49:57 <roconnor> @free void :: Void -> a
09:49:57 <lambdabot> f . void = void
09:50:13 <tarrasch> Hello, I'm wondering about IORefs and concurrency. What happens if a thread reads and another writes at the same time? Is there any defined behavior? Can the program crash, or can data be left unwritten?
09:50:16 <parcs> yeah but it's pretty useful in applicative parsers, as a synomym for (() <$)
09:50:40 <kmc> tarrasch, if you need something thread-safe, use MVar (or atomicModifyIORef)
09:50:41 <jpcooper> thanks roconnor
09:50:51 <kmc> tarrasch, it's a good question and i believe the answer is that it is safe
09:50:58 <kmc> but i've not seen a definitive statement on that
09:51:11 <roconnor> tarrasch: you may be interested in atomicModifyIORef
09:51:53 <tarrasch> I saw atomicModifyIORef, what do they mean by multiple IORefs being problematic?
09:52:07 <monochrom> up to now the read and the write will happen in one order or another, but don't count on it
09:52:11 <kmc> just that there's no way to atomicModifyTwoIORefs
09:52:29 <tarrasch> ah ok
09:52:39 <kmc> have you looked at STM also?
09:52:58 <tarrasch> kmc, Yes, but I'm looking for the minimal, since my usecase is very simple
09:53:14 <kmc> ok
09:53:32 <roconnor> tarrasch: atomicModifyIORef is both fast and easy and works well for very simple cases.
09:53:40 <monochrom> atomiModifyIORef (and readIORef if you just read) is minimal
09:54:01 <duairc> Heh, speaking of modifying IORefs, can anybody explain to me why this code seems to have a space leak? https://gist.github.com/bc5ffe386ad40bea2b1a
09:54:18 <monochrom> then next level up is MVar, then next level up is Chan, then next level up is STM
09:54:27 * roconnor wouldn't be surprsied if in GHC modifyIORef is implemented as atomicModifyIORef.
09:54:30 <kmc> i would say Chan is simpler than MVar
09:54:33 <kmc> certainly for some tasks
09:54:46 <kmc> it happens that GHC implements Chan with MVar
09:54:51 <kmc> this is kind of opaque though
09:55:12 <roconnor> I also found out about the existance of GHC.Event a few days ago.
09:55:37 <tarrasch> Basically I've a yesod site, and I want to return web-scraped values in a response. But I can't web-scrape for each client request. So I cache the value in a IORef and have a seperate thread rescraping the web at regular intervals. Is my use-case understandable?
09:55:58 <roconnor> tarrasch: I think os
09:56:00 <roconnor> *so
09:56:00 <kmc> roconnor, what's it do?
09:56:32 <roconnor> kmc: I've only glanced at it but it seems to implement a single threaded event loop for you.
09:58:36 <monochrom> duairc: I am too lazy to test my hypothesis: do you mind replacing go's definition by "go n = n `pseq` (n+1)"? pseq is from GHC.Conc
09:58:47 <duairc> monochrom: Sure.
09:58:49 <KirinDave> Man tho sis weird.
09:58:54 <KirinDave> Oh lion.
09:59:03 <KirinDave> My attoparsec parse results are returning
09:59:11 <KirinDave> But ghci hangs when I try and examine any one field.
09:59:27 <copumpkin> KirinDave: maybe you tied some knots in it
09:59:43 <KirinDave> copumpkin: It's weird that it would find the end-of-line newlines then
10:00:00 <koeien37> KirinDave: lazy evaluation.. most likely
10:00:02 <KirinDave> copumpkin: It's not coming back as a Partial, which is what I would expect if my parser wasn't terminating.
10:00:32 <koeien37> the parser might terminate, but yield a value that is _|_ (or has some fields which are _|_)
10:00:48 <duairc> monochrom: That doesn't seem to work unfortunately.
10:00:48 <KirinDave> koeien37: Shouldn't it error out then as opposed to hang?
10:01:21 <koeien37> KirinDave: not necessarily. you can parse something and return (undefined, undefined) for example.
10:01:27 <monochrom> duairc: oh, I see now, pseq won't make a difference. modifyIORef just doesn't force "go current_value" at all. same phenomenon as foldl
10:01:58 <duairc> Ah, that makes sense.
10:02:17 <kmc> shouldn't 'sort' be named 'sorted'?
10:02:32 <kmc> the name is kind of undermining my point about declarative programming
10:02:43 <duairc> "sort" is two characters shorter
10:02:47 <KirinDave> koeien37: It's not exactly a complex string to parse: https://gist.github.com/04655b68d92bd531f722
10:03:18 <koeien37> KirinDave: I'll have a look
10:04:14 <KirinDave> koeien37: Should be familiar
10:07:20 <duairc> monochrom: I'm a bit lost as to what to do about it.
10:08:51 <KirinDave> koeien37: Any ideas?
10:09:54 <monochrom> I'm thinking using atomicModifyIORef for this, not just because of threading, but also because it has a nicer interface --- it returns a value that I can exploit
10:10:22 <Saizan> or you could implement modifyIORef' which seqs the thing
10:10:57 <duairc> monochrom: Yeah, I was using atomicModifyIORef initially, it turned into modifyIORef when I was just trying different things to see if they would tell me anything about what was going on.
10:11:23 <duairc> It also happens with atomicModifyIORef.
10:11:47 <monochrom> do { v <- atomicModify counter (\n -> let v = n+1 in (v, v)); v `seq` return () }
10:12:37 <monochrom> leak the value outside so you can manually force it
10:12:55 <monochrom> of course, strictly (pun!) speaking, pseq is even more reliable
10:13:02 <duairc> :D
10:13:06 <duairc> What is pseq?
10:13:19 <c_wraith> duairc: you can read and force the IORef's contents *after* modifying it.
10:13:20 <kmc> forcing (pseq x y) forces x and then forces y
10:13:28 <kmc> forcing (seq x y) forces x and y in some order before returning
10:13:53 <c_wraith> duairc: there's *nothing* you can do inside of modifyIORef (or the atomic version) to force the result before it returns
10:13:54 <monochrom> pseq is seq with better guarantee of evaluation order. seq just encourages the order but doesn't really promise. I know a corner case where seq doesn't do the order you want
10:14:24 <kmc> seq has a denotational guarantee but no operational guarantee
10:14:39 <kmc> «seq ⊥ y = ⊥; seq x y = y»
10:14:54 <kmc> the only operational guarantee you get is the minimum necessary to implement that rule
10:15:36 <monochrom> in practice, you don't run into my corner case :)
10:17:05 <monochrom> modifIORef's source code turns out to be not magical at all, so you can certainly copy and adapt it, too
10:17:52 <monochrom> however, under threading, you will move to atomicModifyIORef anyway
10:19:35 <duairc> Yeah, I've been using atomicModifyIORef anyway. What I posted was just a minimal example.
10:33:13 <kmc> what is your corner case monochrom?
10:33:33 <kmc> my assumption was that seq vs. pseq weirdness would be due to GHC optimizations that move the strictness far away
10:34:34 <monochrom> oh, it's http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ again :)
10:35:39 <monochrom> which probably confirms your guess, but it's pretty sensitive to the data type involved, e.g., a two-case data type doesn't have this problem, Int doesn't have this problem, etc
10:35:40 <Eduard_Munteanu> Does replicate even fuse with foldl'?
10:36:08 <kmc> i don't think it would
10:36:39 <Eduard_Munteanu> It's a shame basic stuff like that doesn't.
10:38:49 <kmc> hmm, actually, i don't know
10:38:56 <kmc> left fold can't be a nice lazy producer
10:39:00 <kmc> but it could be a nice lazy consumer?
10:39:39 <Eduard_Munteanu> I'm pretty sure stream-fusion has some foldl' variant that fuses.
10:40:05 <parcs> does fusion actually happen within ghc?
10:40:17 <parcs> i thought that's what the stream-fusion package does
10:40:21 <Eduard_Munteanu> parcs: yeah, through rewrite rules
10:40:51 <Eduard_Munteanu> You annotate your functions with rewrite rules, and GHC applies them.
10:41:11 <justin-kp> is there a way of converting a JSValue to something other than a String? i want to produce a ByteString or a Builder
10:41:12 <Eduard_Munteanu> So you can say   map f . map g = map (f . g)
10:43:19 <jpcooper> roconnor: I think doing take 10 <$> foo act still needs a Nothing to be found before take can begin
10:43:41 <Eduard_Munteanu> Anyway, IIRC, Prelude is pretty bad if you write stuff like foldl' (+) 0 [1..10000000]
10:44:42 <roconnor> jpcooper: I didn't see that before
10:45:01 <roconnor> you want to loop a maximum of 10 times?
10:45:01 <Eduard_Munteanu> Tho' I think producer is the problem.
10:45:47 <jpcooper> roconnor: I would like an infinite list and to take 10 from it without the infinite list's being fully computed
10:46:29 <roconnor> jpcooper: If there were no Nothings to worry about then you can do replicateM 10 act.
10:46:31 <justin-kp> json package looks pretty much useless as it uses String everywhere
10:46:37 <jpcooper> actually I don't know why I haven't used replicateM
10:46:51 <jpcooper> oh yeah that's why, because of Nothings
10:46:58 <roconnor> jpcooper: but now I'm unclear how this 10 tims and Nothings interact
10:47:06 <roconnor> jpcooper: maybe you can spell it out for me again.
10:48:07 <jpcooper> I have an IO (Maybe a) action and I would like IO [a] where [a] is of size min(m, n) where m is a given integer and n is the number of successive IO (Just a) values from application of the action
10:49:10 <kmc> jpcooper, well, it sounds like you should fmap some function of type (Maybe a) -> [a]
10:49:27 <jpcooper> how do you mean?
10:49:39 <kmc> fmap :: (a -> b) -> IO a -> IO b
10:50:02 <jpcooper> yes I know the type of fmap
10:50:12 <kmc> oh, i misread
10:50:21 <kmc> how many times do you want to apply the action?
10:50:35 <jpcooper> min(m,n)
10:51:01 <roconnor> jpcooper: I'd do foo (replicate 10 act) where foo [] = return []; foo (act:acts) = act >>= test where test Nothing = return []; test (Just a) = (a:) <$> foo acts
10:51:09 <kmc> but you don't know n ahead of time
10:51:24 <kmc> you want to keep executing the action until you get Nothing, or reach m tries?
10:51:42 <jpcooper> exactly
10:51:58 * byorgey likes roconnor's solution
10:52:08 <kmc> i would probably just write the direct recursion for that, but let me look at what roconnor wrote :)
10:52:08 <jpcooper> well actually I think I would like a lazy list of all Just values until a Nothing
10:52:17 <roconnor> jpcooper: there are fun things you could do with exceptions / ErrorT but nothing seems quite compelling in my mind yet.
10:52:44 <jpcooper> to take even the head of roconnor's solution, it seems that the whole list needs to be computed
10:52:51 <roconnor> jpcooper: oh, if you want a "lazy" list you need to do something similar to itrees
10:52:57 <roconnor> iterees
10:53:02 <roconnor> it is actually very common
10:53:29 <tgeeky> I've come to learn that anything (iteratees) endorsed by Oleg is a really good thing
10:53:38 <roconnor> the type you want is data IOList a = NilIOL | ConsIOL a (IO I(OLIst a)) or something like that.
10:53:45 <jpcooper> is that what Channels use?
10:53:56 <roconnor> jpcooper: this interleaving of IO and Cons cells is very common
10:54:00 <roconnor> though I've never used it myself.
10:54:06 <kmc> Oleg has great ideas but we should not worship his API design decisions
10:54:16 <roconnor> maybe there is a package out there that implements this data type.
10:54:21 <kmc> that is a cool data type
10:54:29 <tgeeky> kmc: worship is a strong word :O
10:54:33 <jpcooper> I never thought this would be so complex
10:54:35 <rwbarton> there's a ListT on hackage somewhere that has this kind of thing
10:54:43 <roconnor> jpcooper: it isn't really complex
10:54:43 <jpcooper> could someone explain why the whole list needs to be computed?
10:54:44 <roconnor> ya
10:54:47 <kmc> tgeeky, not for some of how people talk about Oleg ;P
10:54:55 <roconnor> it is bassically a proper ListT of IO
10:55:10 <roconnor> (as opposed to the broken ListT in the original MTL)
10:55:37 <tgeeky> kmc: hehe. perhaps. I think one can admire his ingenuity and innovation. I don't think anyone should ever push API decisions, because they are always the result of tradeoffs.
10:55:50 <tgeeky> So they are only good in the sense that you desire the same tradeoffs
10:55:55 <roconnor> jpcooper: the problem is that if the any of the IO actions throws an exception, then entire result of sequence must be aborted
10:56:10 <kmc> yeah
10:56:22 <kmc> when i look at the existing iteratee APIs, they do not make me feel happy inside
10:56:24 <jpcooper> roconnor: okay, so would it be lazy, say in some other monad?
10:56:30 <kmc> maybe i should just suck it up and learn one
10:56:35 <roconnor> jpcooper: potentially
10:57:20 <rwbarton> (such as the identity monad)
10:57:45 <roconnor> jpcooper: but in most monads it wouldn't be
10:57:52 <tgeeky> kmc: I'm working through a paper right now that's setting up a relationship between the (model theory) Class of Heridetary sets, induction on them, recursion from them, and a fundamental "iterative structure" that they have
10:57:52 <jpcooper> roconnor: why is that?
10:57:55 <tgeeky> kmc: interesting stuff for sure
10:57:57 <roconnor> jpcooper: for example it wouldn't be lazy in the Maybe monad
10:57:58 <kmc> woah
10:58:16 <jpcooper> this has destroyed my assumed understanding of laziness
10:58:27 <roconnor> jpcooper: because in the maybe monad, again if some action returns Nothing the whole sequence returns Nothing
10:59:02 <justin-kp> aha! found: http://hackage.haskell.org/packages/archive/json-builder/0.2.2/doc/html/Data-Json-Builder.html for writing json to Builder, instead of String, which is nice
10:59:06 <tarrasch> A second question about IORefs, is writeIORef atomic? I ask because there is no atomicWriteIORef but there is atomicModifyIORef. Maybe atomicWrite is not implemented as it's so easy to do with atomicModify?
10:59:06 <jpcooper> I think I understand. For the first fmap to be applied, the next one needs to be and soo n
10:59:12 <roconnor> jpcooper: this is a problem for some monadic parsers which must parse the whole input to check for errors before returning the parse.
10:59:21 <tgeeky> byorgey: re: the comments the other day of about recursion and induction
10:59:30 <roconnor> jpcooper: sequence_ is often lazier
10:59:40 <Eduard_Munteanu> It makes me wonder to what extent can stream-fusion's Data.List.Stream can be a drop-in replacement for Prelude's list stuff.
10:59:48 <kmc> tarrasch, i think writeIORef is atomic on any GHC platform.  i don't know if this is officially guaranteed
10:59:54 <kmc> it's just writing a pointer
10:59:56 <tgeeky> byorgey: Is there a (general) sense in which laziness is the building of computational structures, and strict evaluation is the consumption of them?
11:00:37 <Eduard_Munteanu> (with generalized monad comprehensions, maybe Data.List.Stream comprehensions work too? :/)
11:00:40 <kmc> i don't know if GHC runs on any platform with non-atomic pointer writes, or indeed what such a platform looks like
11:00:44 <monochrom> writeIORef and readIORef are atomic so far. but don't count on it
11:00:57 <roconnor> jpcooper: that's why this interleaving of IO and Cons is so useful in this IOList type I gave.
11:01:02 <byorgey> tgeeky: I don't think so, not really
11:01:04 <monochrom> s/are/are each/  # nitpicking!
11:01:06 <tgeeky> Eduard_Munteanu: the feature of monad comprehensions is extremely exciting
11:01:13 <tgeeky> byorgey: ok. *scratches off*
11:01:35 <byorgey> tgeeky: if you want to talk about building up and consuming structures you probably want to think more along the lines of unfolds/folds
11:01:48 <Eduard_Munteanu> You need atomic ops to implement concurrency primitives, such as locks.
11:02:23 <monochrom> otoh maybe you can count on the mainstream relying on shared variables so entrenchedly that you won't see non-atomic word-size writes in your lifetime
11:02:23 <byorgey> unless there's some way in which lazy/strict evaluation strategies correspond to greatest/least fixed points that I don't know about (which is quite possible)
11:02:39 <kmc> if i ever write an IRCd, it will have normal ops, and then atomic ops, who get more power
11:02:49 <tgeeky> byorgey: yeah, I was thinking in that context, just wondering if laziness/strictness in that context
11:02:55 <tgeeky> is special
11:03:44 <monochrom> otoh Leslie Lamport knows all sorts of concurrent or parallel or distributed or whatever algorithms that do not even require atomic writes. they are lock-free too iirc.
11:03:47 <jpcooper> okay I'll have a look at this ListT
11:04:34 <Eduard_Munteanu> Yeah, probably exactly because they're lock-free.
11:04:53 <jpcooper> roconnor: I've found http://www.haskell.org/haskellwiki/ListT_done_right , which looks like what you were mentioning
11:05:16 <monochrom> kmc: will there be nuclear ops too? and nucular ops as Bush puts it? :)
11:05:43 <Eduard_Munteanu> ops of mass distraction.
11:06:55 <monochrom> game menu: 1. tic-tac-toe  2. chess  3. global thermonuclear ops
11:07:09 <brisingr> meta-ops will be able to physically disable computers
11:07:44 <Eduard_Munteanu> Like CMPXHCF16B? :)
11:08:05 <brisingr> wait, what?
11:08:07 <brisingr> :)
11:08:27 <Eduard_Munteanu> Compare and Halt & Catch Fire.
11:08:42 <monochrom> haha Eduard_Munteanu++
11:08:47 <brisingr> oh
11:09:35 <roconnor> jpcooper: ya, and then you can write mTake and mTakeUntil
11:09:46 <roconnor> jpcooper: or find a library with all this already implemented
11:12:51 <kmc> is that just lock cmpxchg8b ;)
11:13:52 <brisingr> :)
11:14:03 <Eduard_Munteanu> There's a 16B too.
11:14:19 <kmc> but i don't think the Pentium supported it
11:14:23 <Eduard_Munteanu> But yeah, the lock prefix is warranted.
11:14:36 <kmc> i was making a joke about the Pentium F00F bug
11:14:44 <Eduard_Munteanu> Oh :)
11:15:58 <kmc> i thought the lock prefix was invalid there but that's apparently not true
11:16:17 * Eduard_Munteanu looks
11:17:11 <kmc> the invalidness of the F00F instruction is that the destination operand is a register, not a memory qword
11:17:11 <kmc> i guess
11:17:43 <tgeeky> anyone remember the name of the haskell package that runs/tests REPL exampels in haskell source files?
11:18:00 <kmc> the workarounds for that bug are interesting
11:18:11 <Eduard_Munteanu> The LOCK prefix can only be used with forms of the following instructions that write a memory operand: ADC, ADD, AND, BTC, BTR, BTS, CMPXCHG, CMPXCHG8B, CMPXCHG16B, DEC, INC, NEG, NOT, OR, SBB, SUB, XADD, XCHG, and XOR.
11:18:34 <Eduard_Munteanu> (according to AMD's specs)
11:21:11 * Eduard_Munteanu wonders if he can coerce evince not to insert line breaks when copying text.
11:21:29 <brisingr> Eduard_Munteanu: use unsafeCoerce
11:21:35 <Eduard_Munteanu> Heh.
11:25:42 <byorgey> tgeeky: doctest
11:27:12 <tgeeky> gracias
11:35:43 <nolrai23> Yo
11:36:01 <nolrai23> Any one here?
11:36:37 <tarrasch> nolrai23, Ofcourse, it's #haskell! :)
11:36:38 <Tomsik> Perhaps
11:36:49 <nolrai23> :P :)
11:37:40 <brisingr> man it really is quiet in here
11:38:36 <Tomsik> Everyone's writing their blog posts after all
11:39:00 <justin-kp> is there a Read typeclass that goes from ByteString instead of String?
11:40:01 <hpc> converting to string is out of the question?
11:40:19 <justin-kp> hpc: I'd rather not
11:40:26 <justin-kp> the data is originally a BS
11:40:45 <rtharper> justin-kp: do you need a full-blown typeclass? i.e. ar eyou reading a lot of different kinds of data?
11:41:24 <justin-kp> rtharper: I mean, not necessarily, but it would be convenient
11:42:04 <rtharper> hm
11:42:14 <rtharper> might just have to roll your own
11:42:22 <kmc> i think there are such libs on hackage
11:42:31 <kmc> does attoparsec have them?
11:43:28 <Tomsik> typeclass?
11:43:41 <Tomsik> I sense something bad going on
11:43:47 <Tomsik> What would be the parameter?
11:44:12 <Tomsik> (->) ByteString is a concrete type, isn't it?
11:44:30 <kmc> Read is a type class
11:45:12 <Tomsik> Oops, Read, not Reader
11:46:37 <Tomsik> justin-kp: do you want something that behaves like a String or binary data?
11:46:59 <Tomsik> there's the Bin thing
11:47:09 <justin-kp> the Bin thing?
11:47:58 <Tomsik> :k Bin
11:48:00 <lambdabot> * -> *
11:48:05 <Tomsik> :t Bin
11:48:06 <lambdabot> Not in scope: data constructor `Bin'
11:48:08 <Tomsik> err
11:49:12 <justin-kp> i just want to read from a String, but not represented as a list of characters
11:50:44 <kmc> type String = [Char]
11:50:45 <kmc> sorry
11:51:02 <kmc> did you look at attoparsec?
11:51:30 <justin-kp> kmc: i am looking now...
11:51:50 <justin-kp> kmc: it doesn't look like it has such parsers built in but i guess i could roll my own
11:51:58 <kmc> and http://hackage.haskell.org/package/bytestring-nums
11:52:44 <justin-kp> kmc: actually, aha - it does http://hackage.haskell.org/packages/archive/attoparsec/0.9.1.2/doc/html/Data-Attoparsec-Char8.html
11:53:05 <kmc> cool
11:53:17 <kmc> treating ByteStrings as strings of characters is wrong
11:53:23 <kmc> but it might be the right kind of wrong to solve this problem
11:54:14 <justin-kp> kmc: cool thanks
11:54:28 <rtharper> true, bytestrings don't really promise to contain...characters
11:54:43 <kmc> they contain... bytes ;)
11:54:44 <justin-kp> unless you are sure you are getting ascii
11:54:57 <kmc> even then it's wrong in principle
11:55:04 <kmc> a character and a byte are still different ideas
11:55:29 <kmc> in Haskell types are about correctness and program structure, not machine representation
11:55:46 <kmc> so the fact that all ASCII characters can be represented using only one byte is still not a reason to conflate the ideas
11:55:57 <roconnor> kmc++
11:56:01 <rtharper> should there be an AsciiString, then? =p
11:56:20 <kmc> well also there's the fact that many ByteStrings are not valid ASCII
11:56:31 <justin-kp> i would be fine with something that newtyped ByteString
11:56:37 <kmc> yeah
11:56:38 <roconnor> rtharper: ISOLATIN1Sring
11:56:43 <roconnor> *String
11:56:49 <justin-kp> and the Read class would take one of these wrapped ByteString objects
11:57:02 * rtharper groans.
11:57:07 <rtharper> Must we have another string representation
11:57:12 <kmc> we need UTF-7 !!
11:57:29 <roconnor> rtharper: one for each character encoding
11:57:41 <kmc> or UTF-5, the international standard for sending characters of the UCS over Baudot teletypes
11:57:57 <justin-kp> i have to run - kmc, thank you for the help
11:58:00 <rtharper> roconnor: but but...abstraction
11:58:08 <roconnor> rtharper: not mutually exclusive
11:58:17 <roconnor> rtharper: we can use type classes or modules
11:58:18 <rtharper> roconnor: would you prefer a Data.Text8, Data.Text16, and a Data.Text32
11:58:18 <rtharper> ?
11:58:37 <copumpkin> or parametrize it by them
11:58:38 <roconnor> rtharper: those aren't character encodings :)
11:58:53 <rtharper> roconnor: no, but Data.Text choose a character encoding
11:58:59 <earthy> kmc: actually, UTF-7 sucks.
11:59:07 <kmc> no kidding
11:59:20 <koeien> we could have a Data.Text that in a smart constructor chooses encoding
11:59:20 <rtharper> roconnor: would you prefer that there is one Text per character encoding?
11:59:27 <roconnor> rtharper: as long as Data.Text doesn't expose their choice I'm happy
11:59:33 <rtharper> roconnor: bless you
11:59:34 <copumpkin> koeien: or make it a data family
11:59:38 <roconnor> rtharper: because then I can plop in a new module
11:59:58 <roconnor> rtharper: Parnas says that modules should have a secret
12:00:06 <koeien> something like  pack Utf8 "Hello world!"
12:00:45 <kmc> koeien, i'd rather it choose encoding fully transparently
12:00:51 <kmc> maybe with a lower-level interface that accepts hints
12:01:06 <koeien> yes, of course you want a sane default (like utf16 or utf8)
12:01:37 <koeien> there is the issue that concatenating differently encoded texts might be expensive
12:01:48 <kmc> yeah
12:01:56 <kmc> that's a reason to stick with a list-of-chunks representation
12:01:59 <kmc> and only traverse on output
12:02:10 <kmc> of course many tiny chunks is still a problem
12:08:38 <roconnor> I wonder if I should make my own fork of PSQueue to guarentee it is non-empty.
12:09:56 <kniu> somewhere I learned that Haskell's typeclasses are implemented by passing an extra dictionary parameter to functions.
12:10:25 <kniu> Is there a "cheaper" way to implement typclasses that avoids the extra parameter?
12:11:03 <koeien> kniu: i don't see how. any suggestions? :)
12:11:30 <koeien> you could use specialization in some cases, but that might blow up code size and might not be more efficient
12:13:35 <Floip> god afternoon
12:13:44 <Floip> good*
12:14:55 <b_jonas> what's the off-topic channel for this one?
12:15:06 <koeien> #haskell-blah
12:15:38 <tarrasch> kniu, koeien, does that mean that `myPlus x y = x + y` is faster if given a monomorph signature rather than the `Num a` version?
12:15:50 <koeien> most likely, yes.
12:16:09 <Tomsik> Is this a big overhead anyway?
12:16:27 <b_jonas> ah thanks
12:16:32 <tarrasch> koeien, I find that quite mind-blowing, I thought haskell-compilers always did all the type-class resolving during compiletime
12:16:36 <b_jonas> should be in the topic
12:16:38 <kniu> tarrasch, yes
12:16:39 <Tomsik> It's easy to imagine that "passing" could be just one pointer flying around
12:16:41 <kniu> in fact;
12:16:49 <koeien> b_jonas: it used to be..
12:17:06 <rwbarton> Tomsik: it is certainly quite large compared to the cost of an 'add' instruction
12:17:21 <kmc> you can't always resolve type classes during compile time
12:17:24 <koeien> tarrasch: the compiler cannot know all available instances of a type class.
12:17:30 <kmc> when i compile Data.List, which Ord do I use for 'sort'?
12:17:44 <kmc> you can do it with whole-program compilation, which is sort of what JHC does
12:17:54 <koeien> yup
12:17:59 <kmc> it still passes evidence sometimes though
12:18:13 <tarrasch> koeien, No, but for each use of the funciton `myPlus` it creates a version of `myPlus`
12:18:16 <koeien> but, then you might increase executable size i think
12:18:16 <kmc> because you still want to compile a polymorphic function once, rather than specializing
12:18:26 <kmc> yeah
12:18:33 <kniu> http://stackoverflow.com/questions/5707250/optimizing-numerical-array-performance-in-haskell
12:18:34 <koeien> so for myPlus it might be worth it, but for myVeryLongFunction it might not
12:18:35 <tarrasch> kmc, has this something to do with you must be able to have .o=object files?
12:18:35 <kmc> executable size doesn't matter much on disk. but once it gets to the icache...
12:18:59 <kmc> yeah, separate compilation is one reason not to specialize all polymorphic functions to concrete types
12:19:01 <kmc> but not the only reason
12:19:06 <KirinDave> I'm having trouble writing an attoparsec parser using many.
12:19:08 <KirinDave> https://gist.github.com/04655b68d92bd531f722
12:19:27 <kniu> dons says: "Specialize to a concrete floating point type, instead of polymorphic floating point functions"
12:19:27 <KirinDave> How _should_ I write the "params" rule on line 26-30?
12:20:34 <rwbarton> specializing to a concrete type can be the first optimization which allows later ones like unboxing and storing loop variables in registers
12:20:47 <rwbarton> in total, that's a huge speed-up
12:21:07 <koeien> KirinDave: see the documentation for take<Till, it says "this cannot be used with many"
12:21:16 <KirinDave> Ahh
12:21:24 <kniu> to that, augustss responds: "If it's necessary to manually specialize the code to Double then the compiler is broken. An advantage of Haskell is to be able to write generic code, so let's make sure than works."
12:21:30 <KirinDave> What's the right way to write that then?
12:21:48 <koeien> KirinDave: let me see
12:21:52 <kniu> which is one of the reasons I asked the question in the first place
12:21:58 <kniu> surely there's a "better" way?
12:22:15 <KirinDave> koeien: Ty
12:23:07 <koeien> KirinDave: takeWhile (not <$> inClass " \n\r ")
12:23:13 <koeien> err, takeWhile1
12:23:13 <KirinDave> Ahh
12:23:18 <KirinDave> Ahh
12:23:22 <KirinDave> the while1 causes the fail
12:23:30 <KirinDave> which can kick many out of its wall rubbing.
12:23:34 <KirinDave> Thanks!
12:26:30 <tarrasch> I feel kinda disappointed about this passing dictionary for type-class thingie. Polymorphic code => slow code? :(
12:26:53 <kmc> not always
12:26:56 <kmc> but yeah, there's no free lunch
12:27:06 <kmc> did you see GHC's SPECIALIZE pragma?
12:27:10 <antoinem> is it possible to create an executable with a module that is not Main ?
12:27:41 <tarrasch> kmc, Nope, I guess that solves it partially?
12:27:48 <kmc> yeah
12:27:54 <tarrasch> Anyway, I'm very glad to have heard about this :)
12:28:23 <koeien> antoinem: i think there is a main-is option for ghc
12:30:04 <Tomsik> antoinem: there's an option to tell GHC which function is the "main"
12:30:20 <Tomsik> -main-is I think
12:30:24 <KirinDave> antoinem: Use cabal to build.
12:30:42 <KirinDave> antoinem: Its default build file puts nearly all the useful options in a file you can edit
12:31:33 <antoinem> thanks for the hints
12:32:16 <tromp> @pl \c -> a c || b c
12:32:17 <lambdabot> liftM2 (||) a b
12:33:39 <kniu> :t liftM2
12:33:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:35:43 <kniu> hm
12:36:34 <kniu> does GHC do optimizations after linking?
12:38:32 <kmc> no
12:38:40 <kmc> but it can do cross-module optimization
12:38:46 <kmc> using Core code present in the .hi files
12:40:38 <kniu> What about GCC's or LLVM's link-time optimizations?
12:42:09 <kmc> what about them?
12:42:22 <kmc> it might invoke LLVM's lto; I don't know anything about that
12:42:35 <kmc> gcc's wouldn't be involved unless you're using -fvia-C
12:42:37 <kmc> which is deprecated
12:42:43 <zygoloid> i guess there's a subtle question here about what ghc itself does
12:42:55 <kmc> and in GHC 7.2 it's disabled by default and performance will be terrible if you turn it on
12:42:59 <kniu> well, if it's just passing a pointer around and the LTO sees that the same entry is being returned every time, maybe it'll just inline it
12:44:52 <Eduard_Munteanu> kmc: terrible meaning GHC 7.2's NCG/LLVM backend got a lot better?
12:44:54 <kmc> gcc's LTO depends on gcc intermediate code in the .o files
12:45:08 <kmc> kind of like the Core in GHC's .hi files
12:45:14 <kmc> Eduard_Munteanu, no, meaning they removed the Evil Mangler
12:45:20 <kmc> so the only -fvia-C left is unregisterized
12:45:22 <Eduard_Munteanu> Oh, right, I forgot about that.
12:52:33 <amindfv> anyone know about Willamette as a CS school?
12:52:55 <amindfv> I'm finishing undergrad, and it looks like I could do a CS degree, with all haskell classes
12:52:58 <BrianHV> I'm getting an error from the RSA package when I try to install yesod. any idea how I can fix it? http://hpaste.org/50962
12:52:58 <amindfv> (nearly)
12:53:23 <confab> amindfv, at williamette?
12:53:57 <amindfv> confab: yes. It's a small school and there's a professor who does a lot of haskell courses
12:54:16 <amindfv> it's the professor who wrote the "evolution of a haskell programmer" page
12:54:54 <confab> 11 credits for degree?
12:55:24 <stulli> BrianHV: You can remove the instance declaration in RSA.hs and install it locally
12:55:35 <amindfv> confab: 11 credits?
12:55:50 <confab> http://www.willamette.edu/cla/cs/requirements/index.html
12:55:58 <amindfv> oh damn yeah
12:56:13 <amindfv> ok, so I guess it's really just a liberal arts school
12:56:39 <confab> wait, they do their credits odd
12:56:40 <BrianHV> stulli: sounds reasonable. I'll give that a shot.
12:56:54 <confab> each class is a credit
12:57:24 <amindfv> confab: yeah, each course is 1 or .5 credits...
13:00:33 <confab> that's not terrible then
13:01:32 <amindfv> I guess it doesn't have much of a reputation, good or bad?
13:02:09 <amindfv> I mean, obviously it's not Ivy League but it's very appealing that I could basically not touch any other programming languages for school
13:02:46 <confab> eh, i'm not the right one to answer that question
13:02:56 <danharaj> You want to touch many languages.
13:02:57 <confab> i'm a bit jaded on the whole education thing
13:03:00 <danharaj> in places they hate.
13:05:39 <amindfv> danharaj: I've used a lot of languages. That's why I'm excited about not using them :)
13:09:29 <kmc> way to pigeonhole yourself
13:11:25 <tromp> > 166/18
13:11:26 <lambdabot>   9.222222222222221
13:11:42 <amindfv> kmc: it is pigeonholing, but really, pure functional languages are what I'd like to be studying.
13:12:27 <amindfv> there are a lot of very good schools, where I'd spend most of my time working in Java or similar, which isn't what I want to be getting into student debt for
13:12:36 <kmc> hmm, undergrad or graduate?
13:13:46 <kmc> imo, as an undergrad you want to learn a little of everything, whereas grad students are expected to specialize
13:15:20 <amindfv> kmc: undergrad, but I've spent a lot of time with various langauges
13:15:27 <kmc> oh?
13:16:00 <kmc> how are you so sure pure FP is the only thing you care about?
13:16:38 <kmc> i studied graphics and systems as well as languages/compilers in undergrad
13:16:43 <kmc> it was all worthwhile
13:17:04 <amindfv> kmc: not the only thing I care about, but it's the thing I want to focus on
13:17:23 <kmc> well "basically not touch any other programming languages" sounds like more than a focus
13:17:32 <kmc> unless you mean that you'll do graphics and systems programming in Haskell
13:17:48 <kmc> i actually used Haskell for the intro graphics course; I wouldn't call it "pure FP" though
13:17:53 <amindfv> kmc: :) ok "not touch" is extreme
13:18:06 <kmc> which languages have you used, and what have you done with them?
13:18:46 <amindfv> well, I program PHP for a living
13:19:05 <amindfv> I've done data structures and algorythms in C/C++
13:19:06 <kmc> Java and PHP are strawman arguments
13:19:18 <kmc> C/C++ is not a language
13:19:32 <amindfv> they are two
13:19:37 <kmc> two vastly different languages
13:19:42 <kmc> have you written an OS kernel in C?
13:19:58 <kmc> or a runtime system for a Haskell compiler?
13:20:15 <amindfv> used Ruby, Perl, Python a lot for mid-level development
13:20:19 <amindfv> no, neither
13:20:29 <kmc> then maybe don't write off C just yet
13:21:08 <kmc> what about Lisp? Scheme? Clojure? Scala? Erlang? F#? OCaml? SML? Coq? Agda?
13:21:43 <amindfv> Lisp and Scheme, I've spent a lot of on-and-off time with
13:21:57 <amindfv> Erlang I got pretty far in but never built a large app with
13:22:31 <stulli> you missed Smalltalk
13:22:37 <amindfv> I'd be happy to learn OCaml, SML, Coq, Agda in addition to/replacements for Haskell, if needed
13:23:08 <amindfv> they're up the same alley, the way I classify things
13:23:15 <amindfv> never used Smalltalk
13:23:30 <kmc> and how much Haskell do you know?
13:23:50 <kmc> what are your biggest complaints about Haskell? what would you change?
13:27:27 <amindfv> kmc: I'd say early-intermediate with haskell
13:28:16 <kmc> what's that mean?
13:28:27 <kmc> (you should feel free to ignore my interrogation if you like; I'm just curious)
13:29:29 <amindfv> I don't have any things I know that I'd change about Haskell. I have complaints, like the difficulty of reasoning about performance, but I'm told I'll be able to learn my way out of that box
13:30:53 <kmc> ah
13:31:34 <amindfv> early-intermediate is, partway with CT, solid on all foundations, ...
13:31:44 <kmc> in my opinion (and this IS just my opinion), if you don't already have a laundry list of complaints about Haskell, then you haven't learned enough to know it's the only language you ever want to use
13:32:00 <amindfv> definitely not the only one I ever want to use
13:32:09 <kmc> the difficulty of reasoning about performance is high on my list of complaints
13:32:21 <kmc> even though i'm reasonably good at it by now
13:32:25 <b_jonas> only one you ever want to use… ha ha ha ha ha
13:32:30 <amindfv> but I'm pretty sure it's what I want to focus on now
13:32:32 <kmc> ok
13:32:48 <b_jonas> I always hate the language I'm currently using
13:32:55 <amindfv> how *would* beginner-intermediate-expert be rated?
13:33:07 <kmc> a lot of people focus on Java and want to use Java for everything, because they've not seen anything better
13:33:16 <amindfv> as a bar graph, what would be the x-values?
13:33:25 <kmc> i have no idea what that means
13:33:34 <kmc> CT = category theory?
13:33:38 <amindfv> b_jonas: I use haskell for everything except work, and really I couldn't be happier with it
13:33:50 <amindfv> kmc: Category Theory
13:34:04 <kmc> category theory is pretty much irrelevant to whether you know haskell
13:34:21 <b_jonas> amindfv: I see
13:34:36 <b_jonas> amindfv: have you been doing that for at least a year?
13:34:39 <kmc> what's the most complicated project you've completed in Haskell?
13:35:40 <amindfv> I mean, what would the areas of expertise be classified as?
13:35:52 <amindfv> (ooh thats not very clear, let me see if I can say it better)
13:36:16 <kmc> i'm not sure it decomposes so cleanly
13:36:26 <erus`> is zygo 2 syllables ?
13:36:29 <kmc> yes
13:36:32 <amindfv> b_jonas: 2 years of serious study, less than a year before that
13:37:00 <erus`> Zygohistomorphic prepromorphisms is too long for a haiku :(
13:38:24 <erus`> also is if then else syntactic sugar for something else?
13:38:35 <ddarius> No.
13:38:44 <ddarius> Well, yes, case.
13:38:49 <kmc> you can translate it to "case"
13:38:54 <kmc> i'm not sure if that's how the Report defines it
13:38:56 <kmc> you could look that up
13:39:01 <dolio> Probably is.
13:39:02 <ddarius> I'm pretty sure it is.
13:39:18 <ddarius> I'm pretty sure the "core" Haskell in the Report doesn't have if at all.
13:39:25 <dolio> Considering it translates let to case.
13:39:40 <kmc> that's kind of an odd decision
13:39:45 <kmc> compared to the way STG is usually presented
13:40:49 <b_jonas> "STG"?
13:40:55 <b_jonas> is that the abstract machine thing?
13:41:34 <kmc> the Spineless Tagless G-machine is an abstract machine which describes how compilers like GHC work
13:41:49 <b_jonas> oh, okay
13:41:57 <b_jonas> I think I heared that phrase
13:42:03 <b_jonas> but that abbreviation for that is strange
13:42:14 <kmc> it's common if you're talking about GHC
13:42:31 <b_jonas> and yes, the H2010 standard translates if-else to case
13:42:32 <erus`> if you cant write a compiler for your language in less than 1000 C loc, then your language is too complex
13:42:46 <kmc> erus`, too complex for?
13:43:02 <erus`> to complex to evolve into something like skynet
13:43:19 <geheimdienst> kmc, too complex for writing a sub-1000-loc-c compiler. please try to pay a little attention
13:43:25 <ddarius> What if you are just bad at C?
13:43:34 <amindfv> kmc: I wouldn't say category theory is irrelevant, at least monads, functors, arrows, etc.
13:43:46 <kmc> erus`, you add a lot of noise to this channel
13:43:46 <tromp> i can write an interpreter for my language in one line
13:44:06 <ddarius> You can be an excellent Haskeller and know no category theory, and you can be an excellent categorist and be hopelessly bad at Haskell.
13:44:06 <erus`> in c?
13:44:14 <b_jonas> (loop (print (eval (read))))
13:44:23 <kmc> amindfv, does knowing the CT definition of functors help you use Haskell's Functor class, which doesn't even model the same concept?
13:44:29 <tromp> no, in binary lambda calculus:(
13:44:44 <b_jonas> "binary"?
13:44:47 <tromp> which doesnt have built-in eval
13:44:53 <erus`> tromp: you invented a new language?
13:44:54 <kmc> does knowing that a monad is a monoid object in the category of endofunctors actually help you write Haskell code?
13:44:56 <deech> Hi all, I've read a couple of times that one of the bad things about Template Haskell was that it allowed IO at compile time. Why is this a bad thing?
13:44:57 <tromp> http://en.wikipedia.org/wiki/Binary_lambda_calculus
13:45:24 <ddarius> kmc: I don't know why you keep saying that.  Haskell's Functor are very close to an instance of the concept of Functor and differs in ways that are mostly pedantic.
13:45:30 <dolio> You can be a learned categorist and whine that Haskell people are 'using category theory' wrongly without actually understanding how they use it at all.
13:45:56 <amindfv> kmc: reading Basic Category Theory for Computer Scientists definitely helped me in understanding all the haskell categories I know
13:46:03 <erus`> turing tarpit
13:46:03 <kmc> which categories are those?
13:46:10 <tromp> It has a program for generating all primes that's shorter than Haskell's nubBy(((>1).).gcd)[2..]
13:46:28 <tromp> even though the language has no number type:(
13:47:15 <erus`> i like lambda alc but those numbers made out of \x y -> y
13:47:24 <erus`> it makes me sad
13:47:27 <b_jonas> I'm a mathematician who sometimes abuses category theory language even when I don't really understand category theory
13:48:02 <ddarius> kmc: Your statement is like saying "Does knowing arithmetic help you use Integers?"
13:48:21 <kmc> or it's like saying "does knowing group theory help you multiply integers"
13:48:28 <kmc> but i don't really care
13:48:54 <ddarius> kmc: The answer to -that- question is "yes."
13:49:53 <ddarius> Which is not to say you can't multiply integers without group theory, just like you can use Functor without knowing about categorical functors.
13:50:03 <kmc> yeah
13:50:18 <kmc> i'm just really suspicious of seeing "learn CT" as one of the steps on the road to becoming a good Haskell programmer
13:50:23 <Eduard_Munteanu> Shameless spam: there's a ##categorytheory channel :)
13:50:41 <kmc> i think there's generally an inverse correlation between how much Haskell someone knows and how much they think category theory is relevant to Haskell
13:50:43 <geheimdienst> what are some things from group theory that help you with multiplying integers?
13:50:51 <ddarius> kmc: I agree, but that doesn't mean that the categorical concepts in Haskell are wrong.
13:51:06 <kmc> well Functor is not a class for all functors
13:51:06 <amindfv> kmc: how would you phrase it? For example, what are you learning when reading the Typeclassopedia?
13:51:09 <kmc> it's a class for some functors
13:51:18 <kmc> amindfv, you're learning about some Haskell type classes and how they relate
13:51:29 <ddarius> kmc: Yes.  Integers are not all integers, just some, plus something that isn't an integer at all.
13:51:41 <kmc> yeah
13:52:11 <amindfv> kmc: ok
13:52:17 <ddarius> And Int is definitely something which "doesn't even model the same concept" as integers, and yet understanding integers helps.
13:52:41 <ddarius> geheimdienst: Look up the number theoretic transform and also roots of unity and the group of units.
13:53:27 <b_jonas> meh, ints are better than integers; and the basic arithmetic operators are not the four they teach you in school but eight: add, sub, adc, sbb, and, or, xor, cmp
13:53:58 <kmc> heh
13:54:08 <ddarius> And in fact, ring theory for integers mod non-primes is useful for working with Ints, though again, you can be quite competent without ti.
13:54:24 <ddarius> b_jonas: nand
13:54:42 <kmc> and, or, xor come from an implicit bijection between Z_(2^32) and (Z_2)^32
13:56:30 <Eduard_Munteanu> Really? Interesting way to look at it.
13:56:55 <kmc> 'and' is multiplication and 'xor' is addition on the finite field of 2 elements
13:57:08 <ddarius> Eduard_Munteanu: You should look up the theory of checksums.
13:57:23 <b_jonas> which doesn't mean they're the only operations you need, it's just that they're the most common ones. there are also rarely used extra ones like various multiplications, divisions, shifts, sideways add, find first set, find last set, byteswap, etc
13:57:23 <kmc> if you take a 32-way direct product of copies of that field, you get bitwise operations on 32-bit ints
13:57:30 <kmc> popcnt!
13:57:31 <Eduard_Munteanu> I went through a bit of that some time ago.
13:57:31 <amindfv> kmc: do you know any good online resources for basic kernel development?
13:57:44 <kmc> amindfv, i really enjoyed the labs from http://pdos.csail.mit.edu/6.828/2010/
13:57:49 <geheimdienst> ddarius: i don't see how any of these things would help if someone was looking to learn what multiplication is
13:57:55 <b_jonas> kmc: popcnt is what I called sideways add
13:58:01 <b_jonas> so yes
13:58:03 <kmc> hehe
13:58:09 <ddarius> geheimdienst: Who said anything about learning what multiplication was?
13:58:28 <Eduard_Munteanu> Actually, that's more like Z_n[x], no?
14:00:05 <b_jonas> I guess I should be using the name "popcnt" or "popcount" too: it both makes more sense and is now more spread
14:00:05 <Eduard_Munteanu> amindfv: Linux kernel or general theory and stuff like that?
14:00:14 <k0ral> is there a builtin function :: [a] -> [(Int, a)] such that function [a, b, c, d, ...] = [(0, a), (1, b), (2, c), (3, d), ...] ?
14:00:25 <mauke> zip [0 ..]
14:00:42 <k0ral> mauke: oh yeah, didn't think about this way
14:00:53 * ddarius dislikes that so many people say "builtin function."
14:00:54 <amindfv> Eduard_Munteanu, basic theory: writing a toy one
14:01:01 <Eduard_Munteanu> b_jonas: I think POPCNT usually refers to a CPU instruction
14:01:02 <k0ral> s/builtin//
14:02:28 <amindfv> I thought it was s/builtin/built-in/
14:02:54 <geheimdienst> ddarius: so group theory (in particular number-theoretic transforms) won't help with learning what multiplication is, but will help with multiplying integers?
14:03:52 <k0ral> amindfv: I never know
14:04:13 <Eduard_Munteanu> amindfv: you might want to start looking at the basics of x86 protected mode and such stuff.
14:04:16 <amindfv> s/never/always/ :)
14:04:24 <b_jonas> is that like "e-mail" with the pointless hyphen?
14:04:34 <ddarius> geheimdienst: It may do the former as well, but the latter is what I stated.  The way most people are taught multiplication is completely satisfactory.  If you want to know what "multiplication" -itself-, then that is -exactly- what group theory studies.
14:04:49 <amindfv> Eduard_Munteanu: ok, thanks. Do you know of any good resource?
14:05:36 <Eduard_Munteanu> Not really, maybe the osdev wiki. But Google might find useful stuff. Also, looking at existing, say Linux, code might be helpful.
14:05:51 <Eduard_Munteanu> http://wiki.osdev.org/Main_Page
14:06:22 <ddarius> I'm not sure looking at Linux code would be a particularly efficient method of learning for at least the early parts.
14:06:49 <geheimdienst> ddarius: fair enough
14:07:18 <kmc> only learn x86 protected mode if you're writing an OS for x86 or like learning about weird shit
14:07:26 <b_jonas> what multiplication is? it's just an abstract model of how you're charged for weighed goods in a shop. abstract, because it assumes they don't cheat you.
14:08:10 <ddarius> kmc: There is some benefit to building an OS on hardware you actually have/has handy widely used decent emulators, but, yeah, x86 booting is filled with crud.
14:08:11 <amindfv> Eduard_Munteanu: thanks!
14:08:28 <Eduard_Munteanu> Yeah, older Linux kernel might be better.
14:08:43 <Eduard_Munteanu> Since they removed direct floppy booting since 2.6-ish
14:08:50 <Eduard_Munteanu> *kernels
14:09:14 <b_jonas> so? you can still look at the boot loader source code too.
14:09:28 <kmc> yes, there are benefits to writing an x86 OS
14:09:31 <ddarius> geheimdienst: Advanced forms of multiplication use Fourier transform-like algorithms, which uses the roots of unity which is the group of units for the complex numbers.  Doing the Fourier transform over a finite field is the number theoretic transform and uses the group of units for that finite field.
14:09:35 <kmc> you should learn x86 protected mode if you're writing an OS for x86
14:09:47 <kmc> amindfv, going to re-iterate my suggestion of 6.828, link above
14:10:01 <kmc> it has (for example) a simple, nicely commented bootloader
14:10:06 <amindfv> kmc: thanks, I'm checking it out
14:10:13 <Eduard_Munteanu> http://lxr.linux.no/#linux-old+v2.4.12/arch/i386/boot/bootsect.S
14:10:16 <Eduard_Munteanu> For example.
14:10:19 <kmc> and generally explains all the x86 init cruft
14:10:27 <kmc> without it getting in your way too much
14:10:40 <ddarius> Most of the aspects of OS design have nothing to do with bootloading.  And many have little to do with hardware.
14:10:46 <kmc> the bits you're actually expected to write are more fundamental things, like controlling the paging unit and handling syscalls
14:11:16 <kmc> also the OS kernel in the labs (JOS) is far more interesting than Linux
14:11:22 <kmc> which is basically a 1970's monolithic UNIX kernel
14:11:38 <Eduard_Munteanu> Of course, you can ditch some of that and use a bootloader or even take L4 and build something on it.
14:11:40 * ddarius will mention Xok here.  Dawson Engler's PhD thesis is awesome.
14:12:06 <Eduard_Munteanu> It depends on what you're interested in.
14:14:24 <ddarius> Wikipedia editors need to learn what "astronomically" means.
14:14:53 <b_jonas> nah, nobody can _really_ understand that
14:14:59 <geheimdienst> it comes from the latin astra ("star") and the greek nom ("nom")
14:15:11 <geheimdienst> i should enlighten them
14:15:31 <ddarius> Put these two statements together: "In practice the SchnhageStrassen algorithm starts to outperform older methods such as Karatsuba and ToomCook multiplication for numbers beyond 2^2^15 to 2^2^17 (10,000 to 40,000 decimal digits)."  and "The SchnhageStrassen algorithm was the asymptotically fastest multiplication method known from 1971 until 2007, when a new method, Frer's algorithm, was announced with l
14:15:31 <ddarius> ower asymptotic complexity; however, Frer's algorithm currently only achieves an advantage for astronomically large values and is not used in practice."
14:16:06 <b_jonas> oh, they use astronomical for a too _large_ value? that's a change
14:16:32 <ddarius> Yes. 2^2^15 is already -way- beyond astronomical.
14:16:44 <Eduard_Munteanu> Yeah.
14:17:03 <b_jonas> yep. astronomical goes up to between 2**100 and 2**900 depending on your definitions
14:17:16 <Eduard_Munteanu> 2^100 is already too large IIRC
14:17:23 <ddarius> Eduard_Munteanu: No.
14:17:33 <b_jonas> 2**100 is definitely in
14:17:38 <Eduard_Munteanu> or maybe 10 ^ 100, I don't remember
14:17:48 <b_jonas> that's different
14:17:57 <ddarius> That's borderline, yes.
14:18:03 <b_jonas> exactly
14:19:43 <b_jonas> Eduard_Munteanu: the easy way to remember is, if you fold a piece of paper to half a hundred times, it has thickness reacing to the farthest quasars we can see with telescopes, or equivalently, to the age of universe times light speed, give or take a few
14:19:43 <Eduard_Munteanu> Exponentials are scary.
14:20:11 <Eduard_Munteanu> Interesting.
14:20:41 <b_jonas> but 10**100 is more like 2**330
14:22:30 <Eduard_Munteanu> geheimdienst: something that noms stars? :P
14:22:40 <ddarius> The easy way to remember it, is any number you could possibly need for physical measurement (with physics as we know it today) can be written down with less than 1000 digits.
14:23:59 <b_jonas> Eduard_Munteanu: a purple long-haired star-eating monster? run!
14:24:19 <sbrg> It's not hair
14:24:23 <ddarius> If you want the hypervolume of all of spacetime in terms of Planck lengths and times, you'll get a few hundred digits.
14:24:24 <sbrg> it's spaghetti.
14:24:44 <Eduard_Munteanu> Yeah, stuff we can measure usually stays between 10^-30 -ish and 10 to the power of something less than 100 I guess.
14:25:29 <b_jonas> ddarius: but is planck length really the least meaningful space unit? physicists could never convince me of that
14:25:29 <knoc> Why is there a hash-tag in some Bit/Byte related stuff in haskell code like: fromInteger i          = W8# (narrow8Word# (integerToWord i))
14:25:58 <ben> It's a convention to signify crazy lowlevel stuff.
14:26:05 <monochrom> hash-tags stand for GHC internals
14:26:13 <b_jonas> (I'm not debating the 1000 digits thing)
14:26:16 <Eduard_Munteanu> Maybe not, but qunatum effects are hella significant at Planck scales.
14:26:30 <Eduard_Munteanu> *quantum
14:26:50 <knoc> what does a hash-tag do?
14:27:03 <ben> nothing
14:27:11 <Tomsik> There's an argument against quantum computing related to that no-more-than-1000-digits-needed one
14:27:13 <Eduard_Munteanu> knoc: you might want to look at unboxed types
14:27:19 <monochrom> just a naming convention
14:27:35 <Eduard_Munteanu> and primops
14:28:06 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html and maybe on the wiki for a general explanation
14:28:07 <ddarius> b_jonas: The argument is that at that point the uncertainty principle would the momentum uncertainty to ridiculous levels, but I personally don't believe in the uncertainty principle at the ontological level.
14:28:08 <ion> “Astronomical” depends on the unit. “I just drove 0.5 lengths of the universe.”
14:28:30 <monochrom> with an ion engine, too! XD
14:28:44 <b_jonas> ion: have you aged much?
14:28:58 <Eduard_Munteanu> No, we did in the meanwhile
14:29:02 <ddarius> ion: Yes, but it is still a unit that is representable with a few hundred digits measured in the smallest unreasonable unit we have.
14:29:04 <knoc> Eduard_Munteanu: That is exactly what I was looking for :] thx
14:29:39 <b_jonas> Eduard_Munteanu: maybe. I don't feel aged.
14:29:58 <ddarius> b_jonas is young and spritely.
14:31:15 <b_jonas> spritely? is that when I look pixely and 4 bit deep of color?
14:31:23 <b_jonas> s/pixely/pixelled/
14:31:25 <ion> Bobs are much better.
14:32:19 <b_jonas> ion: http://stickman.qntm.org/comics.php?n=282
14:34:45 <ddarius> b_jonas: Sounds like a fun past-time.
14:39:38 <dainanaki> Has anyone had experience with c2hs getting sizeof wrong on 64 bit systems?
14:40:06 <kmc> sizeof what?
14:40:22 <dainanaki> pick a struct, any struct.
14:40:34 <kmc> @let astronomical = (> 9000)
14:40:35 <lambdabot>  Defined.
14:40:49 <kmc> hmm.  perhaps your C library was compiled with weird settings?
14:40:58 <kmc> did you figure out where specifically the offsets are wrong?
14:40:58 <dainanaki> ah, I see.
14:41:27 <shachaf> > astronomical (9000 + sin pi)
14:41:29 <lambdabot>   False
14:41:36 <dainanaki> It's that c2hs was built when I was using a 32-bit ghc, now I'm using the 64 bit version.
14:41:45 <shachaf> You win this time, IEEE754.
14:42:05 <rwbarton> "lucky guess"
14:42:19 <kmc> IEEE ain't nothing to fuck with
14:42:28 <ion> @let astronomical' = undefined
14:42:28 <lambdabot>  Defined.
14:43:36 <mm_freak> @let quiteLarge = (> 0)
14:43:36 <lambdabot>  Defined.
14:43:43 <mm_freak> > quiteLarge (sin pi)
14:43:44 <lambdabot>   True
14:43:53 <dainanaki> > quiteLarge 0.0000001
14:43:55 <lambdabot>   True
14:43:57 <mm_freak> welcome to the wonderful world of rounding errors
14:44:25 <rwbarton> though in this case it's some sort of rounding un-error
14:44:57 <shachaf> > quiteLarge ø
14:44:58 <lambdabot>   True
14:45:06 <kmc> > ø
14:45:07 <lambdabot>   1.2246467991473532e-16
14:45:17 <kmc> @let ε = ø
14:45:17 <lambdabot>  Defined.
14:45:46 <mm_freak> > ε < 0
14:45:47 <lambdabot>   False
14:45:55 <mm_freak> lambdabot has no sense of humor
14:47:13 <shachaf> @let δ = ε/2
14:47:14 <lambdabot>  Defined.
14:49:17 <parcs> is that the smallest positive value that a Double can hold?
14:49:26 <MatrixFrog> > δ
14:49:27 <lambdabot>   6.123233995736766e-17
14:49:34 <MatrixFrog> > δ/2
14:49:35 <lambdabot>   3.061616997868383e-17
14:49:38 <MatrixFrog> apparently not
14:49:42 <MatrixFrog> > δ/16
14:49:43 <lambdabot>   3.827021247335479e-18
14:50:01 <parcs> what is the smallest positive value?
14:50:13 <shachaf> > 5.0e-324
14:50:13 <lambdabot>   5.0e-324
14:50:28 <rwbarton> 10 bits of exponent I think?
14:50:28 <geheimdienst> > 5.0e-325
14:50:29 <lambdabot>   0.0
14:50:42 <ben> > 4.9e-324
14:50:43 <lambdabot>   5.0e-324
14:50:46 <rwbarton> so 2^(-1024) at a minimum (maximum?)
14:50:53 * shachaf unsafeCoerce (1::Word64) :: Double
14:51:04 <MatrixFrog> > unsafeCoerce (1::Word64) :: Double
14:51:04 <lambdabot>   Not in scope: `unsafeCoerce'
14:51:08 <MatrixFrog> oh ok
14:51:23 <ben> @hoogle unsafeCoerce
14:51:23 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:51:24 * ddarius recommends treating IEEE754 floating point like a large algebra with insane rules.
14:51:30 <parcs> > > recip (5.0e-324)
14:51:31 <lambdabot>   <no location info>: parse error on input `>'
14:51:32 <luite> MatrixFrog: yeah that gives the same answer
14:51:39 <parcs> > recip (5.0e-324)
14:51:40 <lambdabot>   Infinity
14:51:48 <luite> i tried with Int on my 64 bit system
14:51:49 <rwbarton> > 2^^(-1024)
14:51:50 <lambdabot>   0.0
14:51:52 <rwbarton> > 2^^(-1023)
14:51:53 <lambdabot>   1.1125369292536007e-308
14:51:53 <ClaudiusMaximus> > last . takeWhile (> 0) . iterate (/ 2) $ (1 :: Double)
14:51:54 <ddarius> Putting unsafeCoerce in lambdabot would be a bit reckless.
14:51:55 <lambdabot>   5.0e-324
14:52:04 <rwbarton> then there are unnormalized values
14:52:09 <rwbarton> > 2^^(-(1023+52))
14:52:10 <lambdabot>   0.0
14:52:15 <rwbarton> > 2^^(-(1023+51))
14:52:16 <lambdabot>   0.0
14:52:21 <ClaudiusMaximus> > isDenormalized . last . takeWhile (> 0) . iterate (/ 2) $ (1 :: Double)
14:52:21 <rwbarton> hmm, well it's somewhere around there
14:52:22 <lambdabot>   True
14:53:00 <ddarius> > decodeFloat $ last . takeWhile (> 0) . iterate (/ 2) $ (1 :: Double)
14:53:01 <lambdabot>   (4503599627370496,-1126)
14:53:08 <ClaudiusMaximus> > last . takeWhile (not . isDenormalized) . iterate (/ 2) $ (1 :: Double)
14:53:10 <lambdabot>   2.2250738585072014e-308
14:54:07 <parcs> > 1024 * 2 `logBase` 10
14:54:08 <lambdabot>   3401.6543691646593
14:54:42 <parcs> > 1024 * (2 `logBase` 10)
14:54:42 <lambdabot>   3401.6543691646593
14:55:02 <parcs> damn it
14:55:08 <ddarius> Try dividing.
14:55:09 <shachaf> > logBase 10 1000
14:55:10 <lambdabot>   2.9999999999999996
14:55:12 <parcs> always get those parameters mixed up
14:55:26 <parcs> > 1024 * (10 `logBase` 2)
14:55:26 <lambdabot>   308.2547155599167
14:55:43 <ddarius> parcs: Maybe you should stop using logBase infix?
14:55:55 <parcs> maybe
14:56:09 <parcs> anyway i was calculalating the number of digits in 2^1024
14:56:25 <ddarius> > 1024 / (logBase 2 10)
14:56:26 <lambdabot>   308.2547155599167
14:56:35 <shachaf> > length . show $ 2^1024
14:56:37 <lambdabot>   309
15:01:38 <joe6> anyone kind enough to give me some feedback, please? BitField.hs: http://codepad.org/xIUfzcEC CGlobal.hs: http://codepad.org/uuPLGg8b, usage: http://codepad.org/ijsUba1g
15:04:08 <kmc> is there a timetable for the GHC feature of threads doing minor GCs independently of each other?
15:04:11 <kmc> is it expected for 7.4?
15:05:01 <MatrixFrog> joe6, i'm probably not the person to ask anyway. but what kind of feedbad are you looking for?
15:05:06 <MatrixFrog> just sort of general code review?
15:05:37 <joe6> MatrixFrog: Any thoughts on how you would have done it.. Just about anything that pops up in your mind.
15:06:41 <Cale> Why not take my advice and use Data.StateVar?
15:06:43 <ddarius> I would have used a lot less parentheses.
15:06:46 <kmc> also, more generally, what are the impressive / important features of the GHC RTS?
15:06:59 <kmc> i have preemptive lightweight threading, IO manager, parallel generational GC
15:07:11 <MatrixFrog> joe6 if you know about hlint it can probably tell you where to get rid of parens
15:07:18 <b_jonas> kmc: lightweight threading and the gc definitely
15:07:22 <ddarius> kmc: Profiling?
15:07:30 <kmc> mm
15:07:31 <joe6> ok, will check out hlint.
15:07:37 <kmc> sparks too, i guess
15:07:40 <ddarius> And other such things like threadscope.
15:07:45 <geheimdienst> MatrixFrog: joe6: you can also just paste it in hpaste.org, it automatically runs hlint on your code
15:07:45 <b_jonas> kmc: ah yes, that too
15:07:50 <MatrixFrog> ooo cool
15:08:04 <b_jonas> kmc: and all that working together with parallelism and haskell's type system
15:08:11 <b_jonas> it's definitely impressive
15:08:19 <kmc> as a side note, i'm really glad I decided to introduce Parsec before IO
15:08:20 <ddarius> By the time you get to the RTS, the type system is gone.
15:08:27 <kmc> because parsers are a nice self-motivating example of an EDSL
15:08:34 <kmc> and then you can say IO is just another EDSL
15:08:36 <joe6> ddarius, yes that was an option. but, somehow this seemed better as I can have different return types
15:08:40 <ddarius> Though information from types is used in e.g. data type representation.
15:08:51 <ddarius> joe6: Pay more attention.
15:08:53 <geheimdienst> kmc: nice approach
15:09:00 <kmc> StablePtr is kind of a cool RTS feature, but I'm not sure it can fit into this talk
15:09:22 <ddarius> kmc: In that vein, there are also weak pointers and a few other GC hooks.
15:09:33 <kmc> yeah
15:09:39 <kmc> what else besides ForeignPtr and Weak?
15:09:39 <ddarius> And in -that- vein, the interoperability with C despite very different run-times is notable.
15:09:44 <kmc> yeah
15:10:02 <ddarius> Asynchronous exceptions.
15:10:13 <ddarius> STM
15:10:35 <joe6> ddarius, "Though information from types is used in e.g. data type representation." -- why do you say that?
15:10:35 <ddarius> And presumably there is RTS stuff for DPH.
15:10:36 <kmc> yeah, i have a few slides on STM
15:10:39 <ian__> hPrint is prepending a " to my strings, while hPrintf works as expected
15:10:41 <kmc> ooh, DPH
15:10:42 <b_jonas> ddarius: but if the type system is gone, how can the GC follow references?
15:10:49 <kmc> i should talk about that, since it's becoming, like, a real thing
15:10:53 <b_jonas> doesn't at least some of the type system have to remain?
15:10:59 <ddarius> b_jonas: The same way GCs follow references in untyped languages.
15:11:16 <kmc> well "untyped" languages are dynamically typed, and already carry around run-time type information
15:11:17 <b_jonas> ddarius: in untyped languages, everything is tagged
15:11:24 <kmc> b_jonas, each heap object has a tag saying which of its fields are pointers
15:11:36 <ddarius> joe6: GHC tags small sum data types which it can only do unambiguously because different types can't be mixed with each other.
15:11:36 <kmc> there's a STG type system which is totally different from the Haskell type system
15:11:45 <b_jonas> kmc: the haskell runtime works like that? really?
15:11:46 <b_jonas> strange
15:11:53 <kmc> the GHC runtime, you mean?
15:11:54 <monochrom> in ghc-generated code, you may get tags standing for value constructors. not for types
15:11:59 <b_jonas> yes, the GHC runtime
15:12:00 <b_jonas> sorry
15:12:02 <kmc> its types are:  pointer to Haskell heap, pointer elsewhere, unboxed Int, unboxed Float, unboxed Double, nothing at all (i.e. State#)
15:12:05 <monochrom> @quote isJust
15:12:05 <lambdabot> ddarius says: isJust . unsafeCoerce
15:12:08 <kmc> maybe one or two i forgot
15:12:17 <monochrom> is an illustration
15:12:31 <kmc> b_jonas, a heap object is a pointer to an "info table", plus zero or more data fields
15:12:39 <kmc> which are constructor data, or thunk/closure free vars
15:12:47 <monochrom> i.e., "Just" and "True" happen to get the same tag
15:12:49 <kmc> the info table has layout information for the garbage collector
15:12:59 <kmc> in fact it might just have a "GC me" function pointer
15:13:09 <kmc> anyway the info tables are static
15:13:20 <b_jonas> I see
15:13:28 <ddarius> Roughly speaking, the only thing the GC needs to know are which fields are pointers which is rather different information than the source level types.
15:13:41 <ddarius> And may actually differ between things of the same source level types.
15:13:49 <kmc> the info table *also* contains the "evaluate me" function pointer
15:13:59 <kmc> which is so important that there's an optimization here
15:14:16 <kmc> which is that GHC actually points directly at the "evaluate me" function, and then puts the info table right before it in memory
15:14:39 <ddarius> monochrom: Even before GHC switched to pointer tagging, that worked.
15:14:43 <kmc> that's the "tables next to code" optimization
15:15:01 <b_jonas> well, if _every_ heap object really has such a tag then I can understand how it works
15:15:10 <b_jonas> I just thought most heap objects didn't have such a tag
15:15:16 <b_jonas> that it's only needed for a few
15:15:28 <b_jonas> and for the rest the gc figures out the type from what points there
15:15:43 <ddarius> The tag isn't used for execution.  It's just meta-data for the GC and profiler and other such things.
15:15:55 <ddarius> The GC doesn't care what the type is at all.
15:16:02 <b_jonas> sure
15:16:03 <Tinned_Tuna> Holy crap guys! Tomorrow I get library access back! Time to find out about the STG ^.^
15:16:03 <kmc> right, they aren't Haskell type tags
15:16:09 <b_jonas> of course
15:16:22 <b_jonas> that wouldn't work anyway because there can be an infinite types in the same runtime
15:16:23 <ddarius> Tinned_Tuna: You can download a lot of text about the STG.
15:16:28 <kmc> you kind of need info table pointers
15:16:33 <kmc> or at least pointers to entry code
15:16:35 <b_jonas> but now you're confusing me
15:16:41 <b_jonas> yes, that
15:16:52 <ddarius> kmc: Those are the values themselves essentially.
15:17:02 <kmc> right, but the exist in addition to free variables
15:17:05 <kmc> they exist*
15:17:05 <Tinned_Tuna> ddarius: I prefer paper format for long reading
15:17:10 <ddarius> Tinned_Tuna: Printer.
15:17:19 <b_jonas> ddarius says the tag is only used for GC and similar, whereas kmc says they also point to the code (as in the static code)
15:17:25 <kmc> if you're 'map' and I hand you an arbitrary thunk, which came out of some arbitrary function in my code, you need a way to force that thunk to evaluate and return to you a (:) or []
15:17:35 <ddarius> b_jonas: The tag is the other stuff in the info table.
15:17:37 <Tinned_Tuna> expensive? I can't really abuse the dept. like that, especially when all I have to do is wait a little for library access
15:17:40 <kmc> b_jonas, the information on which fields are pointers vs. not is only used for GC and similar
15:17:52 <ddarius> b_jonas: The entry code is the value itself represented as a Scott-encoded data type essentially.
15:17:56 <kmc> b_jonas, that's one of several things stored in the info table
15:18:06 <b_jonas> I see
15:18:08 <kmc> the info table also points to the "evaluate me" code
15:18:17 <kmc> which is used for evaluation ;)
15:18:25 <ddarius> Tinned_Tuna: A ream of paper isn't too bad.  I'm not sure how many reams of paper a typical ink cartridge goes through.
15:18:31 <b_jonas> so if it's not the "tag", what do you call the pointer to the info table that's at the beginning of most heap objects?
15:18:36 <kmc> info pointer
15:18:45 <Tinned_Tuna> ddarius: the printers in the dept. are huge laser printers
15:18:48 <kmc> "tag" can also mean something else -- pointer tagging
15:18:55 <ddarius> Tinned_Tuna: I was talking about you buying a printer.
15:19:01 <kmc> or it can mean the numerical index of which constructor was used to construct an algebraic data
15:19:03 <kmc> value
15:19:03 <Tinned_Tuna> ddarius: I don't have enough space :-(
15:19:19 <ddarius> Tinned_Tuna: I guess that is consistent with your nick.
15:19:23 <monochrom> put your printer in the fridge when not in use :)
15:19:40 <Tinned_Tuna> monochrom: haha, good thinking, now, what's for dinner, black toner or some paper?
15:19:44 <b_jonas> what also amazes me about the runtime system is that with all the indirect jumps how doesn't the cpu prediction mechanism get very angry at it?
15:19:59 <kmc> well that is a source of performance issues, yes
15:20:02 * ddarius has his printer in a closet with his wireless router, cable modem, tool box, and saws.
15:20:09 <kmc> b_jonas, pointer tagging is designed to mitigate that
15:20:22 <b_jonas> I mean, it's sort of forced to follow all the indirect jumps because of the specs, but it can still get angry and hurt you even while following the specs.
15:20:33 <kmc> by which you mean, run slowly?
15:20:41 <b_jonas> yes
15:20:55 <kmc> yeah
15:21:12 <kmc> it's not like indirect jumps are uncommon though
15:21:12 <b_jonas> but then the compiler also has a hard work to optimize some of this away so the runtime is less burdened
15:21:15 <kmc> CPU manufacturers do optimize for them
15:21:22 <monochrom> you can also exploit Pauli's exclusion principle, i.e., you cannot be in bed and on toilet at the same time. put the printer on bed or on toilet, whichever you are not using :)
15:21:25 <ddarius> kmc: These are often hard to predict jumps.
15:21:40 <ddarius> But yes, OOP also has a lot of hard to predict indirect jumps.
15:21:45 <kmc> pointer tagging:  all heap objects are allocated on 4-byte (resp 8-byte) alignment on 32-bit (resp 64-bit) systems.  so we have the low 2 (resp. 3) bits of a pointer to play with
15:22:09 <kmc> in GHC, a pointer to a value which is known to be evaluated (i.e. known to be not a thunk) will be tagged thus
15:22:12 <b_jonas> kmc: sure, many runtime does that, with varying amount of success. some even try with the high bits.
15:22:13 <kmc> with the index of its constructor
15:22:21 <b_jonas> it also depends on the cpu how much it helps.
15:22:34 <kmc> this means you don't need to load the entry code or the info table or anything like that
15:22:38 <b_jonas> what? only on a 32-bit boundary?
15:22:49 <ddarius> b_jonas: Many runtimes that do this are for dynamically typed languages that can only code the type whereas GHC is coding the constructor.
15:23:01 <b_jonas> aren't they usually at least 16-byte aligned even on 32-bit systems?
15:23:04 <kmc> no
15:23:14 <Eduard_Munteanu> I wonder how much of the prediction cruft is aimed at making generic executables run better.
15:23:15 <kmc> GHC's allocator puts them on word alignment only
15:23:41 <kmc> b_jonas, anyway, if I get a pointer to a Maybe value, and note that the low bits are 2, then I know it's Just and can extract the field directly
15:23:45 <Eduard_Munteanu> Say, when your executables aren't optimized for a specific arch
15:23:51 <kmc> if the low bits are 0, it might be a thunk, and I have to jump to the entry code
15:24:01 <Tinned_Tuna> monochrom: ahh, good idea :-p
15:24:09 <b_jonas> kmc: I see
15:24:14 <ion> > let ε = encodeFloat 1 ((fst . floatRange) ε - floatDigits ε) in (ε :: Float, ε :: Double)
15:24:15 <lambdabot>   (1.0e-45,5.0e-324)
15:24:28 <Tinned_Tuna> monochrom: I now have to factor that into where my housemates might be at the same time :-p
15:24:49 <monochrom> oh, a housemate complicates that
15:24:56 <Eduard_Munteanu> (which is pretty common, say for proprietary Windows software)
15:25:20 <monochrom> but the idea is that in the limit you become a Neutron_Star_Tuna XD
15:25:27 <b_jonas> kmc: but does that really help? I mean, if you're loading the pointer from the same object later, does it help much to not have to load the constructor first?
15:25:27 <ion> > let ε = fix (encodeFloat 1 . liftA2 (-) (fst . floatRange) floatDigits) in (ε :: Float, ε :: Double)
15:25:28 <lambdabot>   (1.0e-45,5.0e-324)
15:25:37 <PreciousMetals> hello! I am trying to do something silly and having some trouble finding which .a file contains the _hs_init symbol
15:25:40 <ddarius> monochrom: Until even that limit is exceeded.
15:25:41 <PreciousMetals> does anywhere know where that i?
15:26:00 <b_jonas> I guess it does
15:26:06 <b_jonas> because you have a conditional first
15:26:10 <b_jonas> so it can help
15:26:22 <ddarius> b_jonas: You also get i-cache consistency.
15:26:40 <b_jonas> ddarius: I don't know what that is
15:27:22 <Eduard_Munteanu> Aren't i-caches silly small these days too?
15:27:37 <b_jonas> do you mean instruction cache?
15:27:42 <Eduard_Munteanu> Yes.
15:27:50 <b_jonas> as in, cache of decoded instructions
15:28:12 <b_jonas> yes, I think they're small too because cpus can decode anything in no time anyway
15:28:16 <Eduard_Munteanu> Cache of instructions.
15:28:28 <ddarius> b_jonas: Instructions are fetched from memory too.
15:28:50 <b_jonas> okay, anyway, it's getting late
15:29:01 <kmc> AFAIK even on modern x86 chips there's only one decode unit which can do the full range of fucked-up x86 instructions
15:29:07 <kmc> and then a number of decode units for the common case
15:29:07 <ddarius> jmp x = mov ip, x
15:29:14 <kmc> i know the P4 had a cache of decoded instructions
15:29:19 <kmc> but i don't know if more modern processors do
15:29:23 <kmc> the P4 was an evolutionary dead-end
15:29:34 <kmc> but it's soooooooo fast for straight-line integer code!
15:30:52 <b_jonas> nobody uses the full range of fucked-up x86 instructions for performance anyway. the only people who run them are those searching for cpu-level security holes, like the famous f00f bug or the coma bug.
15:31:12 <Eduard_Munteanu> So I guess there's quite some room for enlarging instructions / control words if it proves useful for compilers to handle scheduling.
15:31:21 * kmc notes that swapgs is in the syscall fast path on modern x64 OSes
15:31:22 <ion> Subject: ENLARGE YOUR INSTRUCTION
15:31:42 <kmc> Eduard_Munteanu, see: VLIW and Itanium
15:31:56 <kmc> the Itanium was a commercial failure, but I don't know if its design is to blaim
15:31:58 <ddarius> Eduard_Munteanu: See the Crusoe and other VLIW.
15:31:58 <kmc> blame* gah
15:32:15 <kmc> however it's true that compilers know a lot less, being as they run at compile time
15:32:21 <Eduard_Munteanu> Well, I'm a bit interesting in going full-blown NISC, or at least investigating that aspect.
15:32:22 <ddarius> kmc: I don't know.  It sounds like the opportunities were awesome for optimization, but that it would be a nightmare to make a good compiler for.
15:32:34 <kmc> basically i think it makes sense to put off program analysis to the very last nanosecond
15:32:36 <Eduard_Munteanu> *interested
15:32:38 <kmc> even at a significant cost to complexity
15:32:49 <kmc> because you just can't know that much ahead of time
15:33:06 <kmc> ddarius, yeah.  part of the failure of Itanium is that none of the *free* compilers could take advantage
15:33:13 <Eduard_Munteanu> kmc: well there's that, but there's also the question of whether you do it in hardware or software
15:33:15 <kmc> though Intel does give free licenses for their compilers
15:33:33 <Eduard_Munteanu> As in, JIT or better / more complex hardware circuitry?
15:33:41 <kmc> yeah
15:33:53 <kmc> hmm, a tracing JIT which produces scheduled VLIW code
15:33:56 <b_jonas> kmc: do they? I think they don't
15:33:57 <kmc> that's a very interesting idea Eduard_Munteanu
15:34:00 <MHD> I need some weird ideas for languages to learn in order to expand my own knowledge of programming languages.
15:34:03 <kmc> b_jonas, for non-commercial use
15:34:26 <b_jonas> kmc: okay, that's different
15:34:40 <Eduard_Munteanu> Remove decoder, use die area for caches :)
15:35:01 <ddarius> MHD: J, Smalltalk, Prolog, lambdaProlog, Icon, Curry, Self, some others that I'm not thinking of right off hand.
15:35:02 <Eduard_Munteanu> (and even full software control over caching)
15:35:05 <kmc> you still need a decoder for the instruction set that's running the JIT
15:35:06 <kmc> MHD, Haskell, Prolog, Mercury, Coq, Agda, Brainfuck
15:35:12 <kmc> but it can be very simple
15:35:21 <kmc> these days you can fit a MIPS or PowerPC core on the side of anything
15:35:35 <kmc> some FPGAs come with a PowerPC just thrown in
15:35:38 <Eduard_Munteanu> kmc: why? you can have an AOT produce the JIT's code at the first run
15:35:52 <ion> mhd: Erlang
15:35:55 <kmc> yeah
15:35:57 <ddarius> ion: Good one.
15:36:07 <ddarius> E is probably also good to look at in that vein.
15:36:11 <kmc> oh, does anyone know what I should read for learning Erlang?  if I'm already pretty comfortable with functional programming and pattern-matching?
15:36:15 <ddarius> C++.
15:36:20 <kmc> haha, yes
15:36:23 <kmc> learn C++
15:36:27 <ddarius> kmc: Armstrong's thesis.
15:36:29 <ion> kmc: http://learnyousomeerlang.com/
15:36:31 <ddarius> kmc: There is no language like C++.
15:36:36 <kmc> indeed
15:36:42 <Eduard_Munteanu> Agda is definitely a good choice IMHO
15:37:01 <benmachine> kmc: I had the same problem, I went and asked #erlang and they didn't suggest anything much
15:37:02 <kmc> ion, i started reading LYSE... that's where the second part of my question came from
15:37:04 * ddarius was recommending learning all of these suggestions to at least some extent.
15:37:07 <kmc> benmachine, omg me too
15:37:16 <kmc> i can probably skim all the hand-holding through the scary world of FP
15:37:17 <benmachine> I was going to write a haskell → erlang conversion course but I never did :P
15:37:28 <benmachine> I turned down the job that wanted me to learn erlang anyway >_>
15:37:28 <kmc> benmachine, do you know Erlang well enough to do it?
15:37:31 <kmc> heh
15:37:35 <ddarius> My impression is that the main thing to learn with respect to Erlang is OTP.
15:37:37 <kmc> it sounds like a fun project
15:37:40 <ion> kmc: Skip over the parts you already know. It has more advanced stuff later.
15:37:44 <ddarius> And some of the design patterns.
15:37:59 <ski> MHD : also learn continuations
15:38:04 <benmachine> kmc: I basically skimread lyse so I probably know about as much as you
15:38:09 <ddarius> Ah yes, Scheme.
15:38:10 <ion> ddarius: It’s also good to know the plumbing on which OTP works.
15:38:11 <MHD> ski: I know continuations allready
15:38:11 <kmc> heh
15:38:21 <kmc> that's supposed to be phrased "woah, i know continuations"
15:38:21 <ion> ddarius: Even though you should use OTP for actual production code.
15:38:22 <ddarius> Oh, and assembly.
15:38:34 <benmachine> kmc: "show me"?
15:38:38 <ski> MHD : and hygienic macros .. probably also Forth or Factor
15:38:46 <ion> You think that’s air you’re breathing?
15:38:46 <ddarius> ion: I'm not saying you should just know how to use OTP, hence the design patterns part.
15:38:57 <MHD> ski: Oh, yeah, stack-based, thanks
15:39:04 <ddarius> And/or postscript and joy.
15:39:16 <MHD> Probably some brush up on some LISPs
15:39:32 <ion> And graphics programming in dc(1).
15:39:33 <MHD> I know postscript
15:39:37 <benmachine> oh god dc
15:39:50 <ddarius> Postscript is a cute language.
15:39:51 <benmachine> I programmed in dc onc
15:39:52 <benmachine> once
15:39:55 <benmachine> it was um
15:40:00 <ion> [lolssdsl0lqx]sx[1+lddd*lld*-ls+dsdrll2**lo+dsld*rd*+4<kd15>q]sq[q]9ksk[d77/3*2-ss47lxx-P1+d78>0]s00[d23/.5-3*so0l0xr10P1+d24>u]dsux
15:40:02 <benmachine> 10asn[lpnlnnlp/dvsrltx]ss[dlp%0=s]st[ltxlp2+splrlp!>l]sldvsr2spltx3spllx[p]spd1!=pc
15:40:09 <b_jonas> yeah, like that
15:40:18 <benmachine> mine prime factorises
15:40:22 <ddarius> You guys talk to your mother's with those mouths?
15:40:23 <b_jonas> and that doesn't even look obfuscated
15:40:23 <benmachine> what does yours do?
15:40:28 * hackagebot Ansi2Html 0.1 - Convert ANSI Terminal Sequences to nice HTML markup  http://hackage.haskell.org/package/Ansi2Html-0.1 (JensStimpfle)
15:40:40 <MHD> Maybe learn some Zen-HTML
15:40:41 <ddarius> -'
15:40:54 <ion> benmachine: Try it for fun. It doesn’t take any input.
15:41:09 <MHD> Valix-language is also pretty good
15:41:15 <ski> MHD : there's a language called Io based solely on continuations described a little in one of the chapters in Raphael Finkel's "Advanced Programming Language Design" at <http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/> (haven't checked link, may be broken) -- that might be interesting to take a look at
15:41:22 * ddarius doesn't have dc installed.
15:41:34 <ski> (istr there was an implementation of that called Amalthea somewhere)
15:41:37 <ion> http://johan.kiviniemi.name/stuff/dc/mandel.output
15:41:49 <MHD> ski: Isn't Io also some OO Lua-like thing?
15:41:55 <b_jonas> the obfuscated ones use Z to get the length of strings that are also used as commands so that you can't just modify those strings when you decode them
15:41:56 <ski> not that Io
15:42:02 <benmachine> ion: <3
15:42:13 <b_jonas> I thought Io was something smalltalk-like
15:42:19 <ddarius> I think there are at least three languages named Io.
15:42:26 <MHD> oh gog
15:42:26 <b_jonas> gee
15:42:30 <kmc> what about the Haskell EDSL!
15:42:43 <MHD> it's like Google Go and GO! but worse!
15:43:25 <ion> Or like C and C++!
15:43:47 <b_jonas> there's another GO?
15:43:48 <shachaf> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019199.html
15:43:49 <b_jonas> which one?
15:44:12 <b_jonas> the ones that are confusing me is both prolog and perl code using the .pl extension as standard
15:44:34 <kmc> so anyone know about independent per-core minor GC?
15:44:39 <kmc> when it might be available in GHC?
15:45:23 <ion> Nope, but Erlang has an interesting approach to GC: the GC for each process (read: very lightweight thread) is completely independent.
15:45:29 <kmc> yes
15:45:41 <kmc> that's because Erlang doesn't have shared mutable data, right?
15:45:48 <ion> yeah
15:46:06 <b_jonas> kmc: mutable from the user's viewpoint or mutable in implementation level?
15:46:47 <b_jonas> I mean, haskell's immutable values can still change their low-level pointers from the GC's view
15:47:02 <kmc> the former
15:47:12 <kmc> in implementation, lazy evaluation is all about mutation ;)
15:47:20 <ski> ok Amalthea was at <http://web.archive.org/web/20081118165414/http://www.guldheden.com/~sandin/amalthea.html>
15:47:23 <ski> MHD ^
15:49:25 <fryguybob> kmc: this? http://community.haskell.org/~simonmar/papers/local-gc.pdf
15:50:20 <kmc> threadscope isn't in Platform, right?
15:50:47 <fryguybob> kmc: No it is built on gtk2hs right?
15:50:51 <kmc> yeah
15:50:55 <kmc> fryguybob, that's probably the right paper
15:51:02 <kmc> does it say when this feature might be in mainline GHC?
15:51:28 <fryguybob> I don't think so.
15:54:09 <MHD> Hey, anybody looked at Modelica?
15:56:53 <ion> mhd: Looks interesting.
15:59:14 <ddarius> Here's a little puzzle:  Assume you have a call-by-name (NOT call-by-need) language with assignment.  What is the semantics of assignment in this language?
15:59:25 <zzo38> What should I call it if I make up the new kind of Haskell preprocessor program?
15:59:37 <ddarius> zzo38: rm
15:59:55 <kmc> ankohppp
16:00:19 <monochrom> what kmc says :)
16:01:47 <ion> what-kmc-says
16:02:30 <kfish> i agree with ion
16:02:33 <MHD> is using "Yet Another" in naming things still funny?
16:03:23 <kfish> only if you can make a pun, and it's recursive
16:04:04 <owst> Brain fart: can anyone give me another hint for the #2 exercise before the functors section in http://en.wikibooks.org/wiki/Haskell/Category_theory I'm failing to see it at the moment!
16:05:27 * JoeyA idles in channel #2 to see who else clicks on the link
16:05:48 <ion> I clicked the text.
16:06:30 <kmc> owst, what are the possible choices for f  . g?
16:08:16 <owst> kmc: What do you mean by choices? Do you mean id_a or h . g ?
16:08:45 <kmc> well it has to be one of the arrows in the diagram
16:08:50 <kmc> and the only one with the right type signature is id_a
16:10:05 <owst> Ok, so f . g is equivalent to id_a, still not getting anything :)
16:10:10 <kmc> by this argument,  f . g = h . g = id_A
16:10:17 <kmc> and maybe that means f = h
16:10:21 <kmc> but i'm not sure how to prove it
16:10:34 <kmc> i mean the hint says to use associativity
16:10:54 <ski> @where Io
16:10:54 <lambdabot> Raphael Finkel's language with continuations as fundamental structure, described in chapter 2 of his book `APLD', implementation `Amalthea'
16:11:55 * ski wonders whether that could be phrased better
16:18:44 <monochrom> oh dons long time no see
16:19:13 <monochrom> or to paraphrase someone: omg it's a dons!
16:19:18 <dons> hey guys
16:21:50 <Axman6> :O it's dons
16:23:19 <Axman6> dons: how's the new job?
16:23:38 <dons> great. had a good time in singapore, and wrote a ton of code -- now in use. so that's good.
16:23:55 <dons> but i'm back home now, so hopefully with an irc connection for a while.
16:24:02 <zzo38> Please tell me a proper name of the program.
16:24:23 <leod> program
16:25:37 <Axman6> zzo38: what program?
16:25:54 <Axman6> dons: did you meet up with any other haskellers in singapore?
16:27:02 <shachaf> dons!
16:27:06 <shachaf> @hug dons
16:27:06 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:27:14 <shachaf> Eh. That works.
16:27:18 <Eduard_Munteanu> Wha? Heh.
16:27:23 <Axman6> ha!
16:27:28 <Axman6> best hug ever!
16:27:37 <shachaf> newticket?type=hug
16:28:52 <copumpkin> oh wow, dons is back!
16:28:59 <copumpkin> yay
16:30:12 <zzo38> Axman6: I mean, program I can make up new kind of preprocessor of Haskell.
16:30:23 <Axman6> hpp++
16:30:32 <Axman6> because i think we already have hpp
16:30:34 <zzo38> Including some things which other people say is insane and they dislike it
16:30:39 <ddarius> kfish: I hunt down and shoot people who make recursive acronyms that are puns.
16:33:00 <kmc> zzo38, name it yhjulwwiefzojcbxybbruweejw
16:33:05 <kmc> or protontorpedo
16:33:20 <kmc> @yhjulwwiefzojcbxybbruweejw
16:33:20 <lambdabot> Just 'J'
16:33:23 <kmc> @yhjulwwiefzojcbxybbruweejw
16:33:23 <lambdabot> Just 'J'
16:33:52 <Axman6> zzo38: what don't people like?
16:34:10 <ddarius> Axman6: The insane parts.
16:34:40 <ion> Haskell-m4
16:34:45 <Axman6> does it allow randomness?
16:34:50 <ddarius> ion: More insane.
16:34:55 <ski> Haskellp4
16:35:06 <Axman6> because, that'd be pretty sweet, you oculd easily implement java2k then
16:35:11 <zzo38> Axman6: Yes, the insane parts. Or at least, apparently called insane, whether or not it is.
16:35:14 <ion> <?php print("module Foo where");
16:35:51 <zzo38> Some people do not like the more-notation I describe, and also dislikes 'pataprogramming, etc
16:36:59 <ski> zzo38 : could elaborate on what those is/do ?
16:37:04 <dons> Axman6: yeah, met up at the SingFP group.
16:37:17 <Axman6> id you meet any of the Tsuru guys?
16:37:19 <Axman6> did*
16:37:32 <zzo38> ski: See my Haskell wiki user page:  http://www.haskell.org/haskellwiki/User:Zzo38
16:37:39 <kfish> hey dons, Axman6
16:37:44 <Axman6> o/ kfish
16:38:34 <zzo38> I think it is good idea but some people doesn't. However I did not type everything of my idea in there, and some of the ideas I have there is not the kind of thing done by preprocessor
16:39:37 <zzo38> Do you think the more-notation seem good to you? Or insane? Or both? Or neither? Or everything else instead?
16:40:58 <Axman6> it seems to allow first class patterns? or something?
16:41:45 <ddarius> Axman6: No.  It's much more "syntactic" than that
16:41:46 <Axman6> ... does it allow you to extend data types? because if it does, it is pretty insane
16:42:30 <Jafet> "subtextual"
16:43:05 <Axman6> yeah, i have no idea what's going on, and it looks confusing, without much benefit :\
16:44:11 <JoeyA> I think it's to allow you to break a big expression into lines.
16:44:39 <zzo38> Yes, the more-notation allows you to extend data types and various other things
16:44:42 <JoeyA> My opinion: it's arguably useful to some people, but I don't think it's what the doctor ordered.
16:44:50 <JoeyA> oh
16:44:54 <JoeyA> thought it was simply syntactic
16:44:59 <JoeyA> or is it?
16:45:23 <zzo38> Well, read it more carefully including the parts about duplication and Template Haskell
16:45:32 <ddarius> JoeyA: It's slightly "smarter" than purely textual replacement, but still mostly syntactic.
16:46:36 <drdo> What do you collectively call terms, types, kinds, etc?
16:46:49 <ddarius> zzo38 hasn't specified any intermodule relationships, so within a single module it allows you to "extend" data types in the trivial sense that you can spread the data declaration over multiple parts of the file.
16:46:59 <zzo38> ddarius: Or, use include files.
16:47:00 <JoeyA> What are terms?  I know what types and kinds are.
16:47:03 <ddarius> drdo: "Sorts" may be the closest thing.
16:47:08 <ski> zzo38 : your `more' appears to be a potpourri of various things, it seems like they want to be macros
16:47:12 <zzo38> Possibly, have a way to include file with partially private namespace
16:47:38 <drdo> JoeyA: terms are the things that have types
16:48:16 <JoeyA> Aren't those called "values"?  Or is "term" a slightly more precise term in some cases?
16:48:28 <zzo38> Of course it would also help if you can export more-notations but to do that, requires that GHC understands it and that you can have partially compiled modules so that it is closed when the module is finish
16:48:36 <ddarius> JoeyA: "Value" is semantic, "term" is usually more syntactic.
16:49:09 <ion> “yeah, i have no idea what's going on, and it looks confusing, without much benefit” – what newbies think of monads. ;-)
16:49:09 <ski> drdo : you could maybe call them "phrases"
16:49:37 <ski> (if you want to include patterns and declarations as well, i.e.)
16:50:08 <drdo> ski: I'm not talking about haskell at all
16:50:10 <ddarius> Being able to export more declarations would require much more theory and support to not be completely destructive.
16:50:19 <ski> drdo : me neither :)
16:50:41 <zzo38> ddarius: Yes; that is one of the reasons why I specified that it must be local to a module (although you can have include files).
16:51:05 <drdo> ski: Oh yes, i see what you mean, in fact i don't want to include those things :)
16:51:14 <osaunders> Is using >>= on functions considered good style? I’ve learned to understand it but I can’t imagine it makes pleasant reading for anyone.
16:51:26 * ski thinks zzo38 should go learn macros (preferably hygienic ones), e.g. in Scheme
16:51:47 <drdo> osaunders: Whatever is clearer is good style
16:51:51 <ski> drdo : so do you want a name for the syntactic phrases or for the semantic concepts ?
16:51:53 <zzo38> One of my other ideas is to be able to make a "private include" command in the preprocessor, as well as the normal "public include" as well.
16:51:56 <kmc> osaunders, i think it's pretty rare... more common to use liftM2 etc.
16:51:56 <ddarius> ski: He explicitly doesn't want (completely) hygienic macros.
16:53:06 <ski> ddarius : oh right, the constructor abbreviations wouldn't be hygienic
16:53:24 * ski thinks zzo38 should go learn hygienic macros anyway, just for good measure
16:53:31 <ddarius> ski: I agree.
16:53:39 <ddarius> ski: The first example is not hygienic.
16:53:58 <osaunders> kmc: I’m trying to figure out what liftM2 would do for functions
16:54:07 <zzo38> Yes; I should probably learn hygienic Scheme macros anyways, even though that is not completely what I am trying to make.
16:54:10 <ski> (also possibly learn one of the systems where you can selectively introduce non-hygienic things in an otherwise hygienic system, and everything would play nice)
16:54:18 <kmc> liftM2 h f g = \x -> h (f x) (g x)
16:54:26 <kmc> @pl  \x -> h (f x) (g x)
16:54:26 <lambdabot> liftM2 h f g
16:54:29 <ddarius> At any rate, including a "more" declaration in a file could potentially make it so that you no longer know what almost anything in the file means anymore.
16:54:46 <ion> osaunders: http://heh.fi/haskell/functors/#function-instance
16:55:23 <ski> ddarius : hm, the first example looks hygienic to me ..
16:55:53 <osaunders> kmc: ion: thank you both
16:56:08 <ion> :t liftA2 `asAppliedTo` (undefined :: a -> b -> c)
16:56:08 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:56:13 <ion> err
16:56:15 <zzo38> ddarius: Well, yes, such thing is possible. But I prefer to add stuff that can sometimes be useful instead of remain sanity at all costs.
16:56:18 <ddarius> ski: It rebinds x even though you can't tell at all from the usage.
16:56:36 <ddarius> zzo38: You have yet to demonstrate that it can sometimes be useful.
16:56:56 <ion> :t liftA2 `asTypeIn` \liftA2 -> liftA2 undefined (undefined :: a -> b)
16:56:56 <lambdabot> forall a b c a1. (a -> b -> c) -> (a1 -> a) -> (a1 -> b) -> a1 -> c
16:56:57 <drdo> ion: Something i don't understand, why isn't pure part of the Functor class instead of Applicative?
16:57:00 <JuanDaugherty> *remain sane/retain sanity
16:57:19 <ski> ddarius : well, the macro argument must be in the intersection of patterns of expressions, obviously
16:57:31 <ski> s/of expressions/and expressions/
16:57:43 <zzo38> ski: Well, the first example shows something explained previously; names are still bound where they appear in the file instead of where things are moved.
16:57:46 <shachaf> drdo: Because some types don't have pure. Functor with pure is called "Pointed".
16:57:51 <ion> drdo: One could say it belongs in the Pointed class that is between Functor and Applicative. (Others say Applicative is just fine for it.)
16:58:02 <Jafet> > liftA2 (+) f g x :: Expr
16:58:02 <lambdabot>   f x + g x
16:58:40 <ddarius> ski: There is no argument and its the entire line of do notation.  It expands to "return $ Main.x a >>= \x ->"  I.e. it is only part of an expression.
16:59:37 <drdo> I guess i'm having trouble seeing how Functor in haskell relates to the usual functor from CT
16:59:42 <zzo38> ddarius: In that case, yes.
16:59:49 <ddarius> zzo38: Also, that a more declaration could destroy the meaning of almost everything in a file was an extreme case.  Most of the time it will only destroy the meaning of most everything in the file or most everything that follows it.
16:59:51 <zzo38> But it will not always be the case.
17:00:14 <osaunders> CT?
17:00:18 <zzo38> ddarius: I know that; I am OK with that.
17:00:21 <drdo> category theory
17:00:26 <osaunders> Oh
17:00:42 <ski> ddarius : if you could have macro applications in `let*'-clauses, then the first example is similar to `(define-syntax doing (syntax-rules () ((doing a) (a (return (x a))))))'
17:00:48 <shachaf> drdo: It's an endofunctor in the category of Haskell types.
17:01:18 <zzo38> I like to make insane programming if it is good to me rather than requiring only sane programming to make good thing; it might be good making combination of both way, and also of all other way, whichever is making.
17:01:26 <osaunders> drdo: I’ve heard that the relationship between Haskell and CT is less obvious than expected
17:01:28 <ddarius> zzo38: My point is that its not "sometimes useful but sometimes insane," but that its always insane but sometimes it's completely insane.
17:02:05 <osaunders> drdo: I heard that from a category theorist with little experience of Haskell (opposite of me)
17:02:10 <zzo38> ddarius: I never said it was *not* insane. (But I never said it was *always* insane either; to me it is not important whether or not it is insane in this case)
17:02:52 <zzo38> Therefore, I can make up preprocessor in case you prefer Insane Haskell instead of Haskell.
17:03:21 <ddarius> zzo38: I'm not saying anything about what you've said.  I saying what I said.
17:03:34 <zzo38> OK.
17:04:24 <ddarius> ski: My feeling is that this is more like making a Lisp macro that expands to "(foo bar baz".
17:04:53 <osaunders> ion: I have a whole load of the same music as you
17:04:57 <ski> zzo38 : please, first learn macros to see how some aspects of what you want can be made non-insane
17:05:04 <ddarius> Or more relatedly, to "(foo bar (lambda (x)"
17:05:15 <shachaf> ddarius: That would be a wonderful extension.
17:05:20 <ski> (and by macros i mean macros as in the Lisps, preferably hygienic as in Scheme)
17:05:37 <zzo38> OK I try to learn macros too. But just macro by itself is not quite like it. Is there Wikipedia article to learn?
17:05:49 <ion> Moving punctuation that doesn’t semantically belong to a quote inside it due to a kluge made to work around a technological issue in ancient printing presses is always insane.
17:05:52 <zzo38> OK, yes, I found article about "Hygienic macro"
17:06:00 <ski> ddarius : well, a statement in a `do'-expression is a well-defined syntactic phrase -- that it's a derived form is irrelevant imo
17:06:37 <zzo38> I don't care if it is insane; perhaps I want to write the program in Insane-Haskell (or it can be called differently in case there is already program called that or for different reason than that)
17:06:49 <ddarius> ski: I agree, but a) I'm not sure it's quite limited to that (in fact, it isn't) and b) it still is what it feels like.
17:07:39 <ddarius> What I find odd though, is why iszzo38 is interested in Haskell?  It seems the antithesis of what he wants.
17:08:22 <zzo38> Haskell is good programming language, so is CWEB, LLVM, and all that stuff, is useful for different purposes!!
17:08:39 <ski> (btw, this is one area in which i find current macro systems (to the extent i understand them) lacking : we want ways to declare macros for new kinds of syntactic phrases which are introduced by other new syntax/macros -- e.g. foof-loop introduces a concept of "loop clause", which you can write macros for by relying on internal details of how the macro expands -- it shouldn't have to be like that)
17:08:43 <zzo38> (In fact LLVM is better designed than C, I think. But that is not relevant to Haskell)
17:08:48 <ddarius> Haskell is a good programming language because it places a large emphasis on sanity.
17:09:05 <copumpkin> zzo38: I think you're encountering resistance because you simultaneously appear to be inexperienced in haskell yet want to "improve it", without really proving to us that you really understand it to begin with
17:09:17 <ddarius> ski: Isn't this what things like macro-let are for?
17:09:18 <copumpkin> not that you need to
17:09:40 <ski> ddarius : *nod* i was only talking about the first example the last part above
17:09:59 <zzo38> I have written two programs in Haskell. Maybe I did some wrong thing because I did not write much program though. But that isn't the point.
17:10:05 <ski> ddarius : no, afaiu, that's just for having locally scoped macros ?
17:10:23 <zzo38> (I wrote the Constantinople compiler, and a program that makes Huffman tree/encode/decode.)
17:10:30 <ddarius> ski: Maybe that was the wrong thing, but CL seems to have a lot of features for passing information between macros.
17:10:36 <ski> (the basic problem is that macro-expansion is call-by-name)
17:10:59 <ddarius> copumpkin: There's also the fact that zzo38 has no examples of where this more declaration is an improvement, and doesn't really know where he'd use it himself except maybe it might be useful in some Magic the Gathering like system he maybe might develop at some point.
17:11:09 <copumpkin> :)
17:11:13 <ski> (and untyped, by which i mean they don't keep track of which kind of syntactic phrases they map between)
17:11:16 <zzo38> Hygienic macro is in fact very useful thing. However there might be some cases where you do not want it, but in general hygienic macro is good idea, I think.
17:11:35 <ski> (s/keep track/statically kepp track/, at least)
17:11:36 * copumpkin scrubs thrice daily with anti-bacterial soap
17:11:41 <copumpkin> very hygienic!
17:11:52 <copumpkin> also, I help create supergerms!
17:11:52 <copumpkin> yay
17:11:55 <ddarius> copumpkin: Destroying your body's natural defenses.
17:11:57 <ion> ♪ THRICE
17:12:03 <Axman6> :D
17:12:04 <copumpkin> ddarius: I don't actually do that :P
17:12:09 <copumpkin> but the supergerms bit is important
17:12:11 <Axman6> ion: excellent choice
17:12:16 * ddarius can attest to copumpkin's filthiness.
17:12:29 <copumpkin> people can smell me three blocks away
17:12:42 <copumpkin> and that's how it should be
17:12:49 <zzo38> Well, it isn't only for Magic: the Gathering. Some other programs I have seen, they write things many time in a common way in different place because you have to put all constructors in here, and then duplicate it again over there but giving parameters in this way or that, etc. If you have more-notation with Template Haskell then you can do it differently.
17:12:59 <MHD> Let S = 00, K = 11, ( = 01, ) = 10..
17:13:17 <MHD> then things get trippy
17:13:29 <joe6> anyone knows how to write a bindings-dsl macro to this: http://codepad.org/97TrQVzZ
17:13:40 <kmc> are the statistics on Haddock uploads, total # packages, etc. available anywhere on an ongoing basis?
17:13:44 <kmc> i know dons had a blog post a while back
17:13:48 <kmc> (welcome back dons, by the way :)
17:13:49 <joe6> there does not seem in their help docs about defining an unnamed struct
17:15:11 <kmc> also interested in license stats
17:15:23 <zzo38> What should I call it? Should I call it Insane-Haskell? Although, it would still be incomplete due to it being preprocessor instead of part of the compiler, but I can do for now at least
17:16:02 <ddarius> Call it BugInjector.
17:16:39 <copumpkin> lol
17:16:43 <ddarius> Except now I think I want to make a tool with that name.
17:16:54 <ion> PHP
17:17:01 <JoeyA> Hey, watch it.  Remember what happened when someone tried to write a Perl preprocessor for website coding?
17:17:18 <JoeyA> Bah, I'm too slow.
17:17:57 <kmc> hahaha
17:17:58 <zzo38> JoeyA: What is that? What relevance and what happen?
17:18:00 <kmc> those who do not study PHP are doomed to reinvent it?
17:18:10 <kmc> those who do study PHP are doomed to alcoholism
17:18:16 <ddarius> kmc: No.  Those who do not study language design are doomed to do it poorly.
17:18:18 <JoeyA> Those who do not learn from history are doomed to study it.
17:18:39 <copumpkin> I think it would take great skill to reimplement PHP as poorly as the original
17:18:49 <copumpkin> and a concerted effort
17:18:58 <ddarius> copumpkin: I'm sure there is some plucky kid out there working on it.
17:19:05 <zzo38> PHP is badly designed I agree. But I have written the FurryScript interpreter in PHP, anyways.
17:19:20 <kmc> yiff
17:20:06 <JoeyA> But, but, PHP can do monads!  http://codegolf.stackexchange.com/questions/1960/list-comprehension-in-php/1964#1964
17:20:09 <_habnabit> Php /wasn't/ designed.
17:20:34 <_habnabit> Saying that it was is giving Rasmus too much credi.
17:20:35 <_habnabit> T
17:21:08 <kmc> at least he's honest about the fact that he has no business designing a programming language
17:21:15 <kmc> unlike most of the crackpots out there
17:22:05 <kmc> PL is like anything else: the crackpots ignore established research; that research is clearly flawed and invalid, because it did not include $crackpot's singular genius
17:22:07 <ski> zzo38 : btw, please note that several of the hygienic macro systems (`syntax-case',explicit renaming,syntactic closure (maybe i'm missing some ?)) allow you to selectively avoid hygiene
17:22:11 <ddarius> You really have to do call_user_func ?
17:22:46 <JoeyA> ddarius: Yup.
17:22:59 <zzo38> ski: Yes, selectively avoid hygiene is sometimes useful too, I suppose. But hygienic macro is good to. Hygienic macro is one thing I also plan to add in my preprocessor program.
17:23:08 <ddarius> At least CL calls it just funcall.
17:23:16 <JoeyA> In PHP, named functions are in the global scope by default, even when they're nested.
17:23:34 <ddarius> JoeyA: That's completely expected.
17:23:45 <Jafet> I once wrote a php script with nested create_function(), a function which creates a function from a string of php code.
17:24:01 <JoeyA> As of version 5.3, PHP supports lambdas.  However, you have to explicitly name the free variables, and use call_user_func to call them.
17:24:20 <Jafet> So yes, php sure can do higher-order functions
17:24:32 <incluye> and they're elegant too!
17:24:39 <zzo38> I agree there is a lot of bad thing in PHP. create_function() is not so good either. When I do, I instead use class methods, so that the object can have its parameters and do that
17:24:41 <Jafet> If you're a tcl programmer
17:24:50 <ski> zzo38 : well, your `Doing a = a <- return $ x a' example seemed to want to be a (hygienic) macro
17:25:24 <JoeyA> As far as I know, PHP does not support basic function call syntax for variables that are functions.  Maybe I'm wrong.
17:26:06 <zzo38> ski: Although, you might put the more-declarations in various places that are not next to each other, including before and after the more-notation, and you can specify ordering in some cases. And this applies to all its uses rather than only in do-blocks.
17:26:11 <Jafet> The variable has to be a string containing the name of the function
17:26:50 <zzo38> JoeyA: I think you might be correct. However, you can make variables that are created functions by using object methods; a value can contain an object and the name of one of its methods which is then called.
17:27:42 <ion> I’m surprised PHP has the functions call_user_func($f, $array) and call_user_func($f, $arg, …) instead of, say, user_func_call_array($array, $f) and call_user_func($f, $arg, …)
17:28:16 <zzo38> When I must use dyamically created function in PHP, I always do it with objects instead of using create_function.
17:28:23 <ion> Whoops. The first one was supposed to have _array in the end.
17:28:45 <ddarius> I'm surprised PHP.
17:30:23 <zzo38> I agree PHP is not very good. However I have used it when working for someone, I made the program to do reports for timesheets.
17:30:49 <zzo38> FurryScript is a very domain specific programming language, partially described at http://esolangs.org/wiki/User:Zzo38/FurryScript
17:30:52 * Axman6 suggests that the discussion has become off topic
17:31:21 <zzo38> Axman6: I agree.
17:33:20 <JoeyA> > fixIO forever
17:33:20 <lambdabot>   Not in scope: `fixIO'
17:34:29 * ski ponders implementing kind inference
17:34:47 <Axman6> :r forever . (forkIO :: IO () -> IO ThreadId)
17:34:51 <Axman6> :t forever . (forkIO :: IO () -> IO ThreadId)
17:34:51 <lambdabot> Not in scope: `forkIO'
17:34:52 <lambdabot>     Not in scope: type constructor or class `ThreadId'
17:35:08 <Axman6> :t forever . (undefined :: IO () -> IO a)
17:35:09 <lambdabot> forall b. IO () -> IO b
17:35:25 <Axman6> :t fix $forever . (undefined :: IO () -> IO a)
17:35:26 <lambdabot> IO ()
17:36:41 <parcs> JoeyA: you're wrong :P
17:36:48 <ski> @type mfix . (Control.Concurrent.forkIO .)
17:36:48 <lambdabot> (GHC.Conc.ThreadId -> IO ()) -> IO GHC.Conc.ThreadId
17:36:58 <zzo38> I also had other ideas about Haskell, including this:  http://www.haskell.org/haskellwiki/User:Zzo38/Proposal_for_additional_kinds
17:37:30 <parcs> zzo38: why would you use create_function instead of a closure?
17:38:26 <zzo38> parcs: create_function in PHP is bad and I never use it.
17:38:36 <ski> zzo38 : what would be the kind of `MonadReader' ?
17:39:15 <zzo38> Describe what MonadReader is; I don't know what it is.
17:41:16 <zzo38> Can you please describe MonadReader or tell me how to find its documentation?
17:41:30 <ski>   class Monad m => MonadReader r m | m -> r
17:41:33 <ski>     where
17:41:39 <ski>     ask :: m r
17:41:43 <mauke> zzo38: have you tried google?
17:41:43 <ski>     local :: (r -> r) -> (m a -> m a)
17:41:47 <ion> @where hoogle
17:41:47 <lambdabot> http://haskell.org/hoogle
17:42:15 <applicative> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Reader-Class.html
17:42:31 <ski> mote that `MonadReader' is a class which has two type parameters
17:43:48 <zzo38> O, I didn't know that! OK thanks.
17:43:55 * ski is opposed to `$       -- Means make up a kind from a Template Haskell code'
17:45:13 <zzo38> So, "r" is of kind "*" and "m" is of kind "* -> *" is that correct? And an instance declaration requires specifying both?
17:45:25 <rwbarton> "the kind of classes of types of kind x"
17:45:32 <rwbarton> what have we done to the English language
17:45:48 <ski> zzo38 : yes
17:46:10 <ion> “what have we done to the English language”
17:46:14 <ion> What have we done to the English language?
17:46:52 <ski> `* -> (* -> *) -> instance' might be a way to write the kind of this class -- though i think the FD should probably be included in the kind as well (?)
17:47:18 <ddarius> @google site:haskell.org Fact kind
17:47:19 <zzo38> ski: Then I suppose what I describe is insufficient; it should be corrected. Perhaps put comma inside of the [,,,,] but maybe that is not best way because you should use -> for parameters
17:47:20 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/KindFact
17:47:20 <lambdabot> Title: KindFact – GHC
17:47:57 <JoeyA> http://thesaurus.com/browse/type
17:48:05 <zzo38> ski: Yes you do make some sense, but then how do you do the equivalence of:  * -> [*]
17:48:11 <JoeyA> We still have plenty of words left.
17:48:16 <ddarius> http://thesaurus.com/browse/JoeyA
17:48:22 <JoeyA> The type of a kind could be a "blazon", I suppose.
17:48:49 <zzo38> I specified using symbols for all the kind like the other kind are
17:49:05 <zzo38> And what is the FD?
17:49:07 <ski> zzo38 : i'm not sure what you mean by `* -> [*]'
17:49:18 <JoeyA> Then there's kingdom/phylum/class/order/family/genus/species
17:49:28 <ddarius> @where pts
17:49:28 <lambdabot> I know nothing about pts.
17:49:34 <ski> "FD" means "Functional Dependency", it's the `m -> r' in the case of `MonadReader'
17:49:35 <ddarius> What good are you lambdabot?
17:49:45 <JoeyA> We've already burned through class and family, of course.
17:50:25 <zzo38> It means, like "type X a" requires a parameter to make a type, you would have a class that takes a type as a parameter to make up a class applying to concrete types.
17:50:31 <JuanDaugherty> kindom
17:50:58 <ski> zzo38 : how is that different from a MPTC (Multi-Parameter Type Class) ?
17:51:29 <ski> ddarius : you should tell her about it
17:51:51 <ddarius> ski: I've considered it.
17:52:05 <ski> .. and decided against it ?
17:52:45 <ddarius> ski: You should note that zzo38's page has no examples of how, what, or why these would be used.  Things like this are useful hence already being suggested and in some cases implemented, but this doesn't tell us what zzo38 thinks they should be used for or why he thinks they are useful.
17:52:48 <zzo38> ski: I suppose perhaps it is not different. I must have made a mistake.
17:53:05 <zzo38> But then how do you do [[*]] which is a class of classes of concrete types?
17:53:24 <mauke> class of classes? what?
17:53:45 <ion> affectionate, amiable, benevolent, charitable, compassionate, considerate, courteous, friendly, gentle, gracious, humane, lenient, loving, symphatetic, understanding
17:54:05 <ddarius> http://thesaurus.com/browse/ion
17:54:22 <zzo38> I suppose the [x] notation is not so good because of the other stuff you have described; you do have better idea.
17:55:04 <ddarius> zzo38: You may want to consider spending some time at all looking at what else has been done/proposed.
17:55:06 <zzo38> So the kind of Monad class would be (* -> *) -> &
17:55:19 <ski> zzo38 : `(* -> instance) -> instance' ?
17:56:01 <zzo38> ski: Yes, like that; I realized it too soon after I asked.
17:56:36 <ddarius> Type classes are just type level predicates.  So a type class is just a type function into the type level Bool.
17:56:39 <ski> zzo38 : to make you more dangerous, you should go look up <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.2> (including paper talking about that) (NB : the kind of `Rec' is `row -> *')
17:56:51 <ddarius> This is exactly how the KindFact proposal characterizes them.
17:57:58 <zzo38> Although if you call it & then kind of Eq class is  * -> &
17:58:54 <ski> mauke : come on, surely you've always wanted to write `class RestrictedFunctor c f where cfmap :: (c a,c b) => (a -> b) -> (f a -> f b)' ?!
18:00:53 <rwbarton> Hmm, this is a good way to explain how I think of the open nature of type classes--that they are "semipredicates" or type-level functions to {_|_, True}
18:02:08 * ski finds <http://hackage.haskell.org/trac/ghc/wiki/KindFact>
18:02:23 <ddarius> ski: That would be want I linked above.
18:03:52 * ski saw no link mentioned, only the name
18:04:16 <zzo38> OK I looked, it does describe some things similar to mine. I will make a "See also" section that links to that article. However I used symbols for all of the kinds, so & instead of "Fact" or "instance", + for natural numbers, etc
18:04:27 <ddarius> [21:32] <ddarius> @google site:haskell.org Fact kind
18:04:28 <ddarius> [21:32] <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/KindFact
18:04:28 <ddarius> [21:32] <lambdabot> Title: KindFact  GHC
18:04:30 <ski> (on second thought, maybe `constraint' would be better than `Fact' or `instance')
18:04:54 <ddarius> ski: There's a whole section on what to call Fact.
18:04:55 <zzo38> I prefer & instead of any of thse
18:05:04 <ddarius> zzo38: The name is hardly a crucial factor.
18:05:54 <zzo38> It isn't really crucial factor; but still, I like to use the symbols to specify kinds since that is how the other kinds do.
18:06:02 <ski> ddarius : ok, i missed that
18:06:27 <ddarius> :k 1
18:06:28 <lambdabot> *
18:07:17 <zzo38> :k 42
18:07:18 <lambdabot> Only unit numeric type pattern is valid
18:07:44 <ddarius> zzo38: The natural thing to do is to treat the type level just like a cut-down version of the term level and similarly for the kind level, so sticking to symbols is short-sighted.
18:09:47 <zzo38> ddarius: Are you sure?
18:11:03 <zzo38> I fixed my Proposal of kinds and there is the description of natural number kind, it suggest one way to define types using natural numbers is to define in case of zero, and then define it for a successor.
18:11:04 <ski> zzo38 : note that Trex uses `row' for the kind of rows
18:11:32 <ddarius> zzo38: Look at Ωmega
18:11:44 <zzo38> ski: I know; I don't like that, lowercase names should be used for variables
18:11:53 <ddarius> zzo38: Why don't you provide an example of using your system and what kind of problems it solves?
18:11:53 <ion> ddarius: Omegamega?
18:12:04 <ddarius> ion: I didn't make the name.
18:14:29 <zzo38> For example, be able to define type in terms of zero and successor, if y is the successor of n (although this might not be its syntax I just give example of pseudocodes), then:  data X 0 x = Xz x; data X y x = Xs (X n x) (X n x);
18:15:46 <rwbarton> You can already do basically this with data families, there just isn't the sort of kind-checking that you'd like.
18:16:05 <ski> (huh -- why not use something like `(Succ n)' or `(S n)' or `(n + 1)' instead of `y' ?)
18:16:33 <zzo38> ski: Well, yes; Of course you would not literally type what I typed in my example!
18:17:17 <ion> Well, of course!
18:17:18 * ski wonders what the point of zzo38 was, if it wasn't to be taken as a (preliminary) example of what to type, literally
18:17:31 <ski> s/zzo38/zzo38's example/
18:17:44 <ski> clearly i need to go to sleep
18:18:04 * mauke wonders why ski even bothers with zzo38 
18:18:36 <zzo38> ski: What I tried to explain using the example, is how you can define types in terms of zero and successor; it is not meant to be the actual syntax.
18:19:59 <ski> mauke : well, to make him/her realize at least some problems with those proposals ?
18:20:08 <zzo38> I also think the Monad class ought to be defined differently than it currently is; and allowing default superclass definitions in the class declaration as well as definition of members of the superclasses in the instance declarations.
18:20:17 <mauke> ski: I am skeptical of zzo38's ability to realize things
18:20:26 <zzo38> That is, "join" should be a member of the Monad class instead of separate.
18:20:28 <ddarius> ski: The problems are the good things.
18:21:17 <ski> (any improvement is better than nothing)
18:21:23 <ski> anyway, i should go to sleep
18:21:27 * ski wanders off to misty magic land
18:22:02 <zzo38> Do you think "join" should be a member of Monad class, and that superclass definition should be able to work in those ways? If you do that, then you can define a monad in terms of return/bind or unit/join/fmap and either way it works.
18:23:02 <zzo38> That is:  a >>= f = join $ fmap f a; m >> k = m >>= \_ -> k; join = (>>= id); fmap f m = m >>= return . f;  (You still have to define return)
18:23:23 <coppro> zzo38: yes
18:24:08 <bfig> hey. i'm reading a thing about monads and haskell, i want to see if i interpreted this correctly: join === \x-> (x>>=) ?
18:24:52 <mauke> bfig: no, that returns a function
18:24:56 <mauke> :t \x-> (x>>=)
18:24:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:25:12 <mauke> well, it's equivalent to (>>=)
18:25:21 <bfig> lol, true
18:25:27 <Cale> join x = x >>= id
18:25:38 <Cale> So  join = \x -> x >>= id
18:25:59 <bfig> but where does that id lie?
18:26:03 <coppro> Cale: that does not count as point-free
18:26:19 <bfig>  join :: M a -> a, so that is id :: a-> a ?
18:26:31 <ski> @type id `asTypeIn` \id -> \x -> x >>= id
18:26:31 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m b
18:26:36 <Cale> join :: M (M a) -> M a
18:26:57 <Cale> So x there has type M (M a)
18:27:04 <Cale> and id :: M a -> M a
18:27:06 <bfig> you say that because the thing inside must also have id right?
18:27:22 <Cale> hmm
18:27:38 <Cale> I'm not sure how to interpret your reason there :)
18:27:55 <bfig> isn't id something bound to a monad?
18:28:01 <mauke> no
18:28:09 <zzo38> id is the identity morphism
18:28:25 <zzo38> Meaning, any output is same as the input of the id function
18:28:28 <mauke> bfig: id is the function that returns its arg unchanged
18:28:45 <Cale> id x = x  -- this is the definition of id
18:29:15 <zzo38> Yes it is good
18:29:19 <bfig> but then that argument make sense when for example x is.. ahh yo uneed to define return
18:30:05 <bfig> (to use >>=)
18:30:10 <Cale> ?
18:30:32 <bfig> from defining fmap, join, return to return, >>=
18:30:39 <mauke> <zzo38> Not only Adobe, but PDF is dumb. DVI is better format of printing. Let's using TeXnicard.
18:30:42 <Cale> ah
18:30:43 <bfig> why you need a monad to make sense out of each side
18:30:45 <mauke> AGHARGH
18:30:54 <zzo38> You need to define either return and (>>=) or return and fmap and join, although the current Monad class does not work if you define return and fmap and join so you need to define return and (>>=) instead
18:30:55 <Cale> um
18:31:16 <bfig> yes, just playing around with the categorical perspective :)
18:31:18 <JuanDaugherty> *start/use
18:31:36 <zzo38> I think it ought to be made so that you can define in terms of unit/fmap/join or return/bind and either way it will work.
18:32:01 <bfig> you can recover one from the other, so why wouldn't it?
18:32:10 <zzo38> Because the Monad class is not defined that way.
18:32:23 <zzo38> But it ought to be defined that way.
18:32:24 <bfig> i know, but why would it bother you when it involves so little coidng
18:33:03 <bfig> can't you override >>= in a typeclass and do that ? :p
18:33:23 <JuanDaugherty> coidng was on purpose wasn't it?
18:33:37 <zzo38> Well, the way the Haskell libraries are made is currently incompatible with that, I think.
18:33:44 <Cale> bfig: It's just annoying because it was possible for them to allow you to define things either way, and they didn't do it.
18:33:54 <zzo38> Cale: Yes, that is what I mean!
18:33:56 <bfig> JuanDaugherty, i don't know enough CT to make a joke like that
18:34:19 <Cale> Some monads are easier to define in terms of return and >>= while others are easier to define in terms of fmap, return and join
18:34:30 <JuanDaugherty> CT has little or nothing to do with coding
18:34:41 <bfig> what about coiding?
18:34:48 <bfig> nevermind... >_>
18:35:10 <zzo38> Cale: Yes; not only easier but also more sensible
18:35:10 <JuanDaugherty> yeah mehbe co id ng
18:35:27 * JuanDaugherty conks out.
18:39:29 <zzo38> Should the next version of Haskell be changed to allow you to define monads in either way?
18:40:06 <coppro> No
18:40:21 <zzo38> Why?
18:40:47 <coppro> Compatibility
18:41:18 <ddarius> coppro: I don't think anything would break making that change.
18:42:26 <shachaf> It would be a nice change to make.
18:43:23 <zzo38> I still kept    fail = error;   in my proposal for compatibility, though.
18:45:07 <Boney> @src mapM
18:45:08 <lambdabot> mapM f as = sequence (map f as)
18:45:18 <Boney> @src sequence
18:45:19 <lambdabot> sequence []     = return []
18:45:19 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:45:19 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
18:45:56 <Boney> @src map
18:45:57 <lambdabot> map _ []     = []
18:45:57 <lambdabot> map f (x:xs) = f x : map f xs
18:46:49 <Cale> I think we want to make all those changes at once, just as soon as we get the context synonym and/or new kind system stuff stabilised.
18:47:41 <Cale> Once we can abstract over contexts, it'll make sense to rework that stuff to take advantage, I think.
18:48:41 <shachaf> Context synonym?
18:48:52 <shachaf> Hmm.
18:50:30 * hackagebot ghc-events 0.3.0.1 - Library and tool for parsing .eventlog files from GHC  http://hackage.haskell.org/package/ghc-events-0.3.0.1 (DuncanCoutts)
18:50:32 * hackagebot threadscope 0.2.0 - A graphical tool for profiling parallel Haskell programs.  http://hackage.haskell.org/package/threadscope-0.2.0 (DuncanCoutts)
18:52:26 <dcoutts> @yarr!
18:52:26 <lambdabot> Ahoy mateys
18:52:31 <Boney> Oh, a new ghc-events.
18:52:38 <dcoutts> and threadscope
18:52:57 <dcoutts> Boney: it doesn't have any of your new stuff in yet, that's for the next release
18:53:12 <Boney> dcoutts: yep, thought so.
18:53:36 <Boney> dcoutts: simon's got me testing the performance of the new parser.
18:53:53 <Boney> atm it overflows the stack.
18:53:54 <dcoutts> Boney: I finally caught up with those emails, so I saw that, sounds good
18:53:56 <dcoutts> :-)
18:54:24 <dcoutts> Boney: sounds like something's too strict
18:54:24 <Boney> I'm not enjoying debugging lazy programs.
18:54:25 <ion> zzo38: While the functor class structure is being fixed, Monad should depend on Applicative and return should be removed from Monad. Perhaps move pure from Applicative to Pointed, perhaps not. One should indeed be able to define a monad by either one of (>>=) and join.
18:54:38 <Boney> dcoutts: or not strict enough.
18:54:39 <ion> zzo38: Also, fail should be moved to MonadFail.
18:54:50 <copumpkin> ion: and not take a string
18:55:00 <dcoutts> Boney: more likely too strict in this case
18:55:07 <Boney> dcoutts: the more I'm having to deal with this the more I'm conviced that strict-by-default and explicit lazyness is the right way to go.
18:55:17 <copumpkin> ion: also, associated context for monad, functor, and applicative :P
18:55:32 <dcoutts> Boney: for the most part it's a matter of familiarity
18:55:33 <copumpkin> then I'd finally be happy with that chain of classes
18:55:43 <shachaf> copumpkin: When you say "not take a string", do you mean mzero?
18:55:51 <copumpkin> yeah, basically
18:55:58 <ion> copumpkin: What’s associated context?
18:56:02 <shachaf> The only good thing about fail is its name.
18:56:08 <ddarius> > return True :: Either String Bool
18:56:10 <lambdabot>   Overlapping instances for GHC.Base.Monad
18:56:10 <lambdabot>                              (Data...
18:56:11 <copumpkin> ion: like an associated type, but for contexts
18:56:11 <ddarius> Bah.
18:56:21 <Boney> dcoutts: I think that lazyness just makes debugging harder, and debugging is already dificcult enough.
18:56:24 <copumpkin> ion: a function from types to contexts
18:56:32 <ddarius> Boney: Stop writing bugs.
18:56:48 <Boney> the other day I wanted to get a stack dump. but doing so in a lazy language is difficult (which view of the stack do I want?)
18:56:50 <dcoutts> Boney: mercury is not lazy right?
18:56:54 <ddarius> Boney: Also if Buddha and Hat were maintained, perhaps the picture would look different, though that has more to do with purity.
18:57:00 <Boney> yes. Mercury is strict.
18:57:19 <shachaf> > pure True :: Either String Bool
18:57:20 <lambdabot>   Right True
18:57:27 <ddarius> shachaf: That doesn't help me.
18:57:59 <Boney> ddarius: I should catck up with Bernie and talk with him about this.
18:58:21 <ddarius> I think Hat would be more generally useful, though Buddha would certainly kill some problems.
18:58:28 <dcoutts> Boney: my guess then is it's just familiarity, things that you'd do in a strict language, like making everything tail recursive, you would not do in a lazy language
18:58:45 <Boney> More recently bernie was talking about stack traces.
18:58:50 <ddarius> Buddha would be a great tool for learning and debugging certain forms of code.
18:59:21 <ion> copumpkin: What would be an example of a useful associated context for a Functor/Applicative/Monad instance?
18:59:41 <copumpkin> type instance FunctorCtx Set a = Ord a
18:59:45 <Boney> dcoutts: True, many of the things Simon identified in my code are just because I'm used to strictness.
19:00:10 <ion> copumpkin: Ah, that would be useful indeed.
19:01:12 <Boney> dcoutts: VICTORY!
19:01:15 <ddarius> I wonder if you could redo Hat as a TH macro.
19:01:21 <Boney> I made mapM strict and it fixes ghc-events.
19:01:32 <ddarius> "Victories don't mean a thing, if they don't last."
19:01:46 <dcoutts> Boney: made it strict? how so
19:02:12 <Boney> -- Accumulator version of mapM so that we can have tail recursion.
19:02:13 <Boney> mapMAccum :: Monad m => (a -> m b) -> [b] -> [a] -> m [b]
19:02:13 <Boney> mapMAccum _ acc [] = return $ reverse acc
19:02:13 <Boney> mapMAccum f acc (x:xs) = do y <- f x (mapMAccum f $! (y:acc)) xs
19:02:30 <ddarius> That $! doesn't do anything ...
19:02:41 <Boney> Not that it is tail recursive and it is strict in its accumulator.
19:02:54 <dcoutts> oh I see, it's all in a Either String monad
19:03:03 <Boney> then I misunderstand bang patterns. but I want that cons to not build up a huge thunk.
19:03:14 <ddarius> Boney: Bang patterns are something else.
19:03:40 <dcoutts> Boney: y:acc is fully reduced already
19:03:44 <ddarius> f $! x forces x to weak head normal form before evaluating f x, but ((:) y acc) is already in weak head normal form.
19:04:00 <Boney> ddarius: hrm, Maybe I misunderstood what I was reading or was reading the wrong thing (or something that had errors)
19:04:39 <ddarius> Your types seem wrong, are you missing a semicolon?
19:04:39 <Boney> ddarius: ah, I thought that y:acc would build a thunk.
19:05:14 <Boney> ddarius: there's a newline that didn't come trhough in the paste.
19:05:35 <Boney> I'll remove the bang pattern.
19:05:43 <ddarius> Again, bang patterns are something else.
19:05:45 <dcoutts> Boney: I might have a go at making it all fully lazy, so we can do incremental event parsing
19:06:33 <dcoutts> Boney: unfortunately doing error checking and using Either Err Ok makes it too strict, can't then do it incrementally
19:06:48 <Boney> dcoutts: I think that for incremental-ish passing you want big memory mapped arrays and a different file formt.
19:06:51 <Boney> format.
19:06:58 <dcoutts> combining robust error checking with reading events incrementally is fun
19:07:00 <Boney> B+ Trees :-)
19:07:13 <dcoutts> Boney: there's certainly tools that want to process streams of events
19:07:24 <dcoutts> as well as things like threadscope which want random access
19:07:34 <Boney> yep.
19:07:37 <dcoutts> in particular, online tools
19:07:47 <Boney> Please revisit design if you want to do this.
19:07:52 <dcoutts> so incremental parsing will be required for those applications
19:07:53 <monochrom> the behaviour of mapMAccum depends on the monad, of course. in the case of IO, it will build a huge list before finishing.
19:08:12 <dcoutts> Boney: yeah, I hope to, when I find the time :-(
19:08:14 <ddarius> monochrom: Why would it build up a huge list?
19:08:20 <Boney> and check with me about the file format (not for Mercury's sake but I've got some things to say about file format design)
19:08:40 <ddarius> monochrom: Or do you mean it won't return the result until it completes?
19:08:40 <dcoutts> Boney: you happy now with the format?
19:09:01 <monochrom> it won't return the result until it completes
19:09:01 <Boney> dcoutts: Only in that it's a comprimise.
19:09:32 <dcoutts> Boney: because of backwards compat you mean?
19:09:35 <ddarius> monochrom: Yes, similarly for the Either String monad as dcoutts mentioned.  Of course, the reverse destroys that possibility anyway.
19:09:37 <Boney> The header section that we currently have is the cause for all our other problems.
19:10:02 <Boney> I think that if we had a simple header saying "this is ghc-6.12's event log" and then selecting parsers based on that would have been simpler.
19:10:32 <dcoutts> I still don't like that idea :-)
19:10:55 <Boney> dcoutts: basically, trying to make it both backwards and forwards compatible in the way we did ment that we had many problems in in some cases there is no backwards and forwards compatibility.
19:11:22 <liyang> Halp. How do I get argv[0]?
19:11:42 <ddarius> :t getArgs
19:11:43 <lambdabot> Not in scope: `getArgs'
19:11:48 <ddarius> @hoogle getArgs
19:11:48 <lambdabot> System.Environment getArgs :: IO [String]
19:11:49 <dcoutts> getProgName :: IO String
19:12:19 <Boney> dcoutts: Because of the re-numbering of events I have very little backwards compatibility with Mercury.
19:12:21 <liyang> resolution set to /wontfix/ http://hackage.haskell.org/trac/ghc/ticket/3199
19:12:38 <dcoutts> liyang: System.Environment.getProgName
19:12:49 <dcoutts> liyang: it does provide access to argv[0]
19:12:56 <liyang> Not the full path.
19:13:00 <mauke> dcoutts: no, it doesn't
19:13:01 <Boney> ghc has more backwards compatibility but not much. for instance I don't think your spark code works with old spark events (GHC did once have a create spark event)
19:13:17 <dcoutts> liyang: argv[0] is not the full path either
19:13:24 <dcoutts> (iirc)
19:13:35 <mauke> dcoutts: yes, which makes getProgName even worse
19:13:40 <mauke> it has no business mangling argv[0]
19:13:43 <dcoutts> what?
19:13:50 <mauke> liyang: GHC.Environment.getFullArgs
19:14:19 <Boney> dcoutts: hrm, I wonder if you can use the blocks in the log file to seek over whole blocks.
19:14:35 <dcoutts> Boney: could make an index of the blocks
19:14:38 <Boney> so that you could quickly scan the file to build a time -> block (and position in file) map.
19:14:47 <Boney> then use that to incrmentaly load the file.
19:14:54 <liyang> mauke: humm. Fair enough. I did see an interesting workaround in http://hackage.haskell.org/trac/ghc/ticket/3200 involving readSymbolicLink "/proc/self/exe" though.
19:14:57 <Boney> yeah!
19:14:59 <ddarius> liyang: The wontfix is simply saying, "put it elsewhere."
19:15:17 <mauke> liyang: that's different from argv[0], though
19:15:29 <Boney> you might need to include messages within the event stream that say "at this point in time the following threads exist and they are in these states" also wrt sparks.
19:15:44 <mauke> also, guess who reported both of those bugs
19:16:20 <ddarius> mauke: Mr. Guest
19:16:40 <zzo38> Yes fail should be moved to MonadFail but the reason to kept it in is for compatibility. But it might be possible moving return and allowing directly superclass definitions
19:16:41 <dcoutts> mauke: I've no idea what you're talking about re mangling argv[0]
19:17:12 <dcoutts> mauke: getProgName just gets the argv[0], the only mangling is to hide any +RTS -RTS options
19:17:17 <mauke> dcoutts: removing everything up to the last '/'
19:17:24 <mauke> dcoutts: wrong
19:18:17 <liyang> unpackProgName in http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-Environment.html#getProgName
19:18:32 <zzo38> Maybe you can write your own main function in C if you want to change the way of how it does with +RTS option and other things
19:18:38 <dcoutts> oh yes, you're right it takes the basename
19:18:49 <liyang> I'm not quite sure how that improves portability…
19:18:54 <mauke> it doesn't
19:19:13 <copumpkin> omg it's a liyang
19:19:25 <zzo38> Or, in LLVM, I suppose.
19:20:33 <dcoutts> liyang: ok, so you can make a lib submission to change the behaviour of getProgName
19:21:05 <dcoutts> which these days is quite straightforward, it's basically just sending a patch to the maintainer
19:21:10 <dcoutts> and explaining the rationale
19:21:34 <ddarius> Who's the maintainer of base?
19:21:45 <liyang> from what I understand, argv[0] always refers to a valid (either absolute or relative) file. Stripping off any paths makes it things more difficult than necessary…
19:21:48 <liyang> dcoutts: will do.
19:21:52 <mauke> don't forget to get agreement on what the best functionality is, though
19:22:02 <mauke> liyang: no, argv[0] is an arbitrary string, like the rest of argv
19:22:23 <dcoutts> liyang: it doesn't necessarily refer to a valid file
19:22:30 <dcoutts> on unix it doesn't
19:23:22 <liyang> No? Ugh. Am I confusing argv[0] with $0 in bash?
19:23:29 <dcoutts> there's two ways it can lie, one is if the caller passes nonsense for argv[0] and the other is if the program binary is deleted, or the directory is changed
19:23:34 <dcoutts> two/three
19:23:57 <dcoutts> windows has a way to get the full program path
19:23:59 <mauke> liyang: look at how programs are started
19:24:15 <dcoutts> because it prevents you from deleting the binaries of running executables (which is really annoying)
19:24:22 <liyang> of course. I knew that.
19:24:23 <mauke> execve takes three arguments: a filename, an array of strings (argv), and an array of strings (envp)
19:24:30 <ddarius> dcoutts: Agreed.
19:24:45 <copumpkin> by convention, argv[0] contains the program name
19:24:48 <dcoutts> liyang: so perhaps you're really after something else, a function to (try to) get the program executable
19:24:49 <copumpkin> but it could also contain unicorns
19:25:05 <ddarius> copumpkin: I don't think unicorns are strings.
19:25:19 <copumpkin> a base64-encoded picture of unicorns, then
19:25:22 <dcoutts> which would be reliable on windows and best effort on unix, e.g. using the /proc/self/exe trick
19:25:31 <ddarius> > pony
19:25:31 <lambdabot>   Not in scope: `pony'
19:25:59 <liyang> I'm just after an easy way to get the path of the executable so I can work out the appropriate resource directory. ¬_¬
19:26:23 <dcoutts> liyang: btw, you can also use cabal to find data files at runtime
19:26:25 <mauke> in normal cases that will be argv[0], yes
19:27:05 * liyang is fine with it just working in the normal case. It's not critical, just an inconvenience right now.
19:27:29 <dcoutts> liyang: see the Paths_pkgname.hs file that Cabal generates for you, there's getDataDir and getDataFileName
19:27:41 <shachaf> dcoutts: It can also lie if you've modified it yourself. :-)
19:28:05 * shachaf ran into some strange issues with a process that used strtok to parse its command line arguments showing up in ps.
19:28:13 <liyang> dcoutts: I know that. :) This isn't Cabalised though.
19:28:28 * ddarius <3 C string libraries.
19:28:49 <dainanaki> I finally figured out my issues that I was having last night with c2hs.
19:29:06 <dainanaki> The c2hs version I was using was i386 and ghc was x86_64
19:29:08 <dainanaki> :(
19:29:10 <liyang> Programs that modify argv to show their status?
19:29:49 <Jafet> "Hi; I'm currently parsing the command line"
19:29:50 <shachaf> liyang: I mean that it modified its argv so I got unexpected entries in the output of ps.
19:29:58 <shachaf> That would be pretty neat, though.
19:30:11 <shachaf> If top updated frequently enough, you could do animations and what not.
19:30:13 <ddarius> shachaf: That would be pretty annoying.
19:30:14 <ion> > pony
19:30:15 <lambdabot>   ["One 18.25 ounce package chocolate pony mix.","One can prepared coconut pe...
19:30:23 <liyang> shachaf: I mean, I definitely remember there were a couple of programs that did exactly that back in the day.
19:30:28 <shachaf> ddarius: That's what I meant by the word "neat".
19:31:35 <liyang> In fact, looking at my ps ax, nginx seems to do that.
19:34:39 <Cale> pony = cake?
19:34:42 * ddarius considers the problem of recording a conversation between two people that are separated by a noticable propagation delay such that the end result sounds natural.
19:34:56 <ddarius> pony = s/cake/pony/ cake
19:35:06 <ddarius> er switch those.
19:36:23 <ion> > (cake !! 11, horse !! 11)
19:36:24 <lambdabot>   Not in scope: `horse'
19:36:26 <ion> > (cake !! 11, pony !! 11)
19:36:27 <lambdabot>   ("Fish shaped solid waste.","Horse shaped solid waste.")
19:36:44 <mauke> > map head pony
19:36:45 <lambdabot>   "OOTFOTOTDHHHHHPHCOAUFANTOATTOOTOOTASCIICAT"
19:38:37 <ddarius> TOOTOOTASCIIPON
19:38:49 <acfoltzer> d'oh. got myself all psyched up to upload my first package to hackage, and then realized one needs an account that's not the haskell community account in order to actually do it
19:40:07 <ddarius> > length (filter (uncurry (/=) $ zip cake pony))
19:40:08 <lambdabot>   Couldn't match expected type `(a, a)'
19:40:08 <lambdabot>         against inferred type `[([GHC...
19:40:19 <ddarius> > length (filter (uncurry (/=)) $ zip cake pony)
19:40:21 <lambdabot>   7
19:40:58 <ddarius> > map (text *** text) $ filter (uncurry (/=)) $ zip cake pony
19:41:00 <lambdabot>   [(One 18.25 ounce package chocolate cake mix.,One 18.25 ounce package choco...
19:41:27 <ddarius> Sehr kurz.
19:41:54 <leod> huch, warum so deutsch?
19:42:10 <ddarius> Warum nicht?
19:42:26 <ion> Ich habe Sauerkraut in meinen Lederhosen.
19:42:31 <leod> weil der kanal recht englisch ist :P
19:43:48 <Jafet> Gittet ihr und Slotermeyer
19:45:06 <leod> yes, that's perfectly valid german
19:48:14 <shachaf> #haskell.de
19:49:22 <Eduard_Munteanu> #haskell.en
19:49:31 <Eduard_Munteanu> :P
19:50:35 * Eduard_Munteanu ponders a distinction... #haskell.en_US and #haskell.en_GB
19:51:01 <ion> #haskell.<the ISO 639-1 code for Klingon>
19:51:48 <nyingen> any package particularly recommended for unboxed, mutable arrays? I just need simple linear arrays with fetch/store, not matrices or anything
19:51:55 <Jafet> Klingon Haskell only has parameters, not arguments.
19:52:05 <nyingen> there seem to be a couple of different libs on hackage
19:52:24 <Jafet> @index MArray
19:52:24 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
19:52:25 <synonymous> vector!
19:54:31 <nyingen> synonymous: hm, looks nice
19:55:22 <nyingen> though I'm not sure what to make of "adaptive unboxed vectors based on type families"
19:55:32 <nyingen> I'm not familiar with type families
19:55:38 <rwbarton> I haven't figured out yet when I'm supposed to use vector over boring old STUArray.
19:56:02 <copumpkin> rwbarton: always
19:56:24 * nyingen eyes vector-mmap
19:56:29 <rwbarton> copumpkin: I might trust that answer if it weren't coming from you :P
19:56:34 <rwbarton> is that serious?
19:56:35 <copumpkin> nyingen: what about it?
19:56:45 <nyingen> looks like a great package.
19:57:24 <copumpkin> rwbarton: standard haskell arrays are ugly and have almost no helper functions on them, and also have a horrible and weird set of typeclasses attached to them. vector is much cleaner :P
19:57:33 <copumpkin> nyingen: I haven't actually tested it much at all (I think I wrote it though)
19:57:40 <nyingen> haha, you think
19:57:41 <copumpkin> for some values of write
19:57:49 <copumpkin> I did mmap something
19:57:53 <copumpkin> :P
19:58:54 <rwbarton> Suppose I am doing fairly random read/write access to an array--maybe I'm implementing the sieve of Eratosthenes; is that still a good use case for vector? A lot of the vector stuff seemed to be focused on fusion
19:59:03 <nyingen> so do I need to research type families prior to using vector, or can I fake my way through by looking at the examples and stuff?
19:59:35 <KirinDave> It is so great to have a working haskell distribution again
19:59:41 <copumpkin> nyingen: you don't need to know anything about them, really
20:00:01 <KirinDave> It's easy to forget how much I enjoy working with haskell, even if I am still slow with it.
20:00:08 <copumpkin> rwbarton: I still think the mvector interface has a more sane API than the mutable arrays do
20:00:09 <nyingen> KirinDave: yeah, it can be hard getting a lazy language to do some work for once
20:00:15 <copumpkin> you won't get fusion for it, but meh :)
20:00:20 <acfoltzer> nyingen: the families stuff is more if you want to implement your own specialized representation for the unboxed vectors
20:00:33 <KirinDave> nyingen: Well it's more my ongoing problem with OSX Lion.
20:00:34 <rwbarton> Hmm, ok, I will take a look at some point then.
20:00:44 <nyingen> acfoltzer: so if I just want unboxed arrays of Word16, it's not an issue?
20:00:50 <acfoltzer> nyingen: as a client storing Ints and such, it's a very straightforward interface
20:00:59 <Eduard_Munteanu> Don't forget REPA though.
20:01:00 <copumpkin> nyingen: you can pretend it's a list
20:01:03 <acfoltzer> nyingen: exactly, no special family syntax or anything. Just V.Vector Word16
20:01:07 <nyingen> cool
20:01:10 <acfoltzer> or however you import it
20:01:12 <nyingen> sounds like what I want
20:01:19 <copumpkin> if you're just storing primitive types, use unboxed vectors
20:01:22 <copumpkin> unless you want laziness
20:01:40 <nyingen> ok
20:14:18 <mmos1127> I'm trying to use named field accessors in a pattern and getting a parse error. Is it something like --- fnName Con {fieldName = variable} = <definition>
20:15:06 <rwbarton> that looks right to me
20:15:30 <mmos1127> man I wonder what I'm doing .. I should copy the code into hpastebin
20:16:47 <Cale> mmos1127: Try putting parens around the whole argument.
20:16:49 <Eduard_Munteanu> You need parens around the Con and fields, just like with normal datatypes
20:17:10 <shachaf> Eduard_Munteanu: No you don't.
20:17:22 <mmos1127> I tried parentheses
20:17:27 <mmos1127> here it is: http://hpaste.org/50965
20:17:34 <shachaf> @ty let foo StateT { runStateT = f } = f in foo
20:17:35 <lambdabot> forall t (t1 :: * -> *) t2. StateT t t1 t2 -> t -> t1 (t2, t)
20:17:54 <shachaf> mmos1127: I don't think you want the "ED." there.
20:18:18 <mmos1127> I imported that symbol qualified...
20:18:25 <copumpkin> accessors are unqualified there, I think
20:18:33 <Eduard_Munteanu> Hm.
20:18:42 <rwbarton> You want ED.NoteAnnotation then, I suppose
20:18:53 <ion> computeBeginType (ED.prevConn -> prevConn) = …  -- One could also use ViewPatterns.
20:18:54 <rwbarton> ...maybe?
20:19:28 <ion> Hard to say because he didn’t paste the error message. (Or perhaps i just missed it.)
20:19:33 <rwbarton> I suppose I could write f x = x { field = 1 } and it would need to know which 'field' to use, without anything to go on
20:19:40 <rwbarton> so perhaps the field must be qualified
20:20:05 <Eduard_Munteanu> I think the export list contains just constructors, no?
20:20:19 <mmos1127> okay I switched to importing everything unqualified, new version on hpaste, and I'm still getting a parse error
20:20:37 <Eduard_Munteanu> mmos1127: what error?
20:20:40 <rwbarton> can you paste the error also?
20:21:12 <mmos1127> oh error is just "parse error in pattern"
20:21:21 <shachaf> On which line?
20:21:38 <mmos1127> okay I feel silly .. actually what happened was when I fixed it, I was getting the same error on another line in the file and didn't pay attention to the line number
20:21:56 <ion> Also, don’t use error like that. Return a Maybe or Either.
20:22:11 <shachaf> You can get rid of the case if you want to, by the way, and just say foo T { x = A } = ...; foo T { x = B } = ...
20:22:34 <shachaf> And similarly with the booleans, instead of using if.
20:22:37 <shachaf> And what ion said.
20:22:48 <mmos1127> ion: I am short on time so using error is a virtue.. it doesn't cause any harm to my usage (workflow) with this program.. thanks for the other tips I will study this
20:22:52 <Eduard_Munteanu> Strange how you don't need the parens though.
20:23:10 <shachaf> Eduard_Munteanu: {} is stickier than application.
20:23:36 <ion> I like to use parentheses in there anyway, i find it more readable.
20:23:54 <Eduard_Munteanu> Presumably you can parse   foo x:xs a  without parens anyway.
20:24:04 <ion> nope
20:24:17 <Eduard_Munteanu> Erm, my bad.
20:25:07 <ion> (:) is a data constructor, the record syntax is special.
20:25:40 <joe6> i notice that bindings-dsl is generating an offset of 2 for a CUChar (sizeOf = 1). I would expect that the offset would be 1. is that expected?
20:25:44 <ddarius> f x { r = a } means f (x { r = a })
20:25:57 <ddarius> joe6: What's the alignment?
20:26:01 <Eduard_Munteanu> How about   foo Foo a b c Bar d e f   ?
20:26:15 <ddarius> That parses as written.
20:26:24 <joe6> ddarius, alignment = 1 too
20:26:25 <ddarius> What about foo True a b c False d e f?
20:26:37 <joe6> alignment (undefined :: CChar) = 1
20:26:43 <copumpkin> joe6: even on the C side?
20:26:48 <copumpkin> most C compilers don't pack things that tightly
20:26:53 <Eduard_Munteanu> ddarius: you know foo has two arguments, and Foo and Bar are constructors
20:26:56 <copumpkin> unless you ask them to
20:27:05 <ddarius> foo has one argument.
20:27:08 <dmoctezuma> does anyone know if there is a way to avoid putting: "\\time..." (note the double \\ in order to avoid confusion wit '\t') ?
20:27:26 <joe6> copumpkin: I have mostly packed  data structures.
20:27:48 <dmoctezuma> probably putting something before the string? (i.e.: somechar"\time")
20:27:59 <ddarius> dmoctezuma: No.
20:28:10 <Eduard_Munteanu> Well, yeah, but my point was Foo already binds to its arguments (fields) quite tight
20:28:26 <ddarius> Eduard_Munteanu: Foo is just a function.
20:28:27 <ion> Not tighter than function application.
20:28:40 <ddarius> dmoctezuma: You could make a TH quasiquoter, and in fact I think someone already has done that, but that would be overkill.
20:29:25 <Eduard_Munteanu> Oh wait, yeah, it's the same thing as when calling the function, duh.
20:29:44 <ddarius> Pattern syntax completely mirrors expression syntax.
20:31:18 <dmoctezuma> ddarius, I was expecting something like the C# approach: @"string with \ here"
20:31:29 <ddarius> dmoctezuma: Why?
20:32:06 <dmoctezuma> just to avoid having a lot of double \ (\\) characters, ddarius
20:32:56 <Eduard_Munteanu> That wouldn't work for '"', say.
20:33:16 <Eduard_Munteanu> I mean, it wouldn't be really universal.
20:33:17 <ddarius> dmoctezuma: Yes, I understand that it is useful, but as far as I know most languages don't have a feature like that.  C# is the only language I've noticed it in, though I'm certain it's in a few others.
20:33:21 <ion> I could see PHP supporting @"string with " here"
20:33:34 <mauke> Perl solved that one right
20:33:38 <ddarius> ion: You should look at postscript's string syntax.
20:33:49 <Eduard_Munteanu> mauke: how?
20:34:09 <ion> ddarius: Enclosed in parentheses?
20:34:16 <mauke> Eduard_Munteanu: quoting meta-operators
20:34:17 <ddarius> ion: Look deeper.
20:34:22 <mauke> Eduard_Munteanu: i.e. you can specify the delimiter to use
20:34:39 <Eduard_Munteanu> Hm, interesting.
20:34:51 <ddarius> safoobara
20:35:12 <shachaf> bash's single-quote syntax is sort of reasonable.
20:35:29 <rwbarton> python has this too, r'abc\def' = 'abc\\def'
20:36:57 * Eduard_Munteanu wonders about using one-line strings for that
20:37:13 <Eduard_Munteanu> i.e. having them extend from the delimiter to the end of the line
20:37:33 <ddarius> > "Eduard\                                                             \Munteanu"
20:37:34 <lambdabot>   "EduardMunteanu"
20:37:43 <incluye> o_O
20:38:02 <ddarius> > "E\&\&\&M"
20:38:03 <lambdabot>   "EM"
20:38:31 <rwbarton> \& is my favorite string escape
20:38:44 <ddarius> \& is my favorite character escape
20:39:02 <shachaf> > '\&'
20:39:04 <lambdabot>   <no location info>:
20:39:04 <lambdabot>      lexical error in string/character literal at chara...
20:39:15 <incluye> > '\\'
20:39:15 <lambdabot>   '\\'
20:39:20 <incluye> > :t '\\'
20:39:20 <lambdabot>   <no location info>: parse error on input `:'
20:39:29 <shachaf> Looks more like a string escape.
20:39:38 <ddarius> > '' isn't a character
20:39:39 <lambdabot>   <no location info>:
20:39:39 <lambdabot>      lexical error in string/character literal at chara...
20:39:59 * ddarius likes how isn't is a valid Haskell identifier.
20:40:15 <ddarius> > '\&a'
20:40:15 <copumpkin> > let (isn't, is) = (false, true) in isn't
20:40:16 <lambdabot>   <no location info>:
20:40:16 <lambdabot>      lexical error in string/character literal at chara...
20:40:16 <lambdabot>   Not in scope: `false'Not in scope: `true'
20:40:27 <copumpkin> > let (isn't, is) = (False, True) in isn't
20:40:28 <lambdabot>   False
20:40:40 <ddarius> But yes, \& isn't a character escape because it would never be necessary.
20:40:47 <incluye> ah, ' in identifiers
20:41:00 <copumpkin> > let in the dog
20:41:00 <incluye> > let shouldn't've = "double contraction" in shouldn't've
20:41:01 <lambdabot>   "double contraction"
20:41:02 <lambdabot>   "woof"
20:41:38 <Eduard_Munteanu> Heh.
20:41:48 * ddarius still wants nullary type classes.
20:42:02 <incluye> > let in the dog
20:42:02 <lambdabot>   Not in scope: `the'Not in scope: `dog'
20:42:04 <incluye> oh
20:42:06 <drbean> > let in the dog
20:42:06 <lambdabot>   Not in scope: `the'Not in scope: `dog'
20:42:11 <incluye> ...madness
20:42:15 <copumpkin> ddarius: I thought you could write them
20:42:33 <ddarius> You can't unless something has changed.
20:43:03 <ion> > ((((42 `show`) `length`) `succ`) `show`)
20:43:03 <lambdabot>   "3"
20:43:09 <shachaf> ddarius: Why do you want them?
20:43:14 <Eduard_Munteanu> ddarius: is there any reasonable usecase?
20:43:19 <Axman6> ion: ow :(
20:43:46 <Axman6> @hoogle (&)
20:43:46 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
20:43:46 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
20:43:46 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
20:43:55 <rwbarton> Nullary type classes could be useful, for instance, if your primality-testing function depends on the Riemann hypothesis
20:44:03 <copumpkin> ion: ooh, concatenative!
20:44:23 <Axman6> > let (&) = flip ($) in 42&show&succ&show
20:44:24 <lambdabot>   No instance for (GHC.Enum.Enum GHC.Base.String)
20:44:24 <lambdabot>    arising from a use of `G...
20:44:33 <Axman6> > let (&) = flip ($) in 42&show&length&succ&show
20:44:34 <lambdabot>   "3"
20:44:42 <Eduard_Munteanu> Would you even need a class context for such a function?
20:44:46 <Axman6> > let (&) = flip ($) in 42 & show & length & succ & show
20:44:47 <lambdabot>   "3"
20:44:52 <rwbarton> Then you can document that in the type, isPrime :: RiemannHypothesis => Integer -> Bool
20:45:09 <Axman6> > let (.) = flip ($) in 42.show.length.succ.show
20:45:10 <rwbarton> and only inhabitants of universes in which the Riemann hypothesis holds will use your function ;)
20:45:10 <lambdabot>   "3"
20:45:14 <ddarius> The best part about them would be that you could still have functional dependencies on them!
20:45:14 <ddarius> Wait, I may have found another use for them.
20:45:44 <Eduard_Munteanu> rwbarton: how is that different from isPrime :: {- RiemannHypothesis -} Integer -> Bool   ?
20:46:07 <ddarius> Eduard_Munteanu: Because you would only be able to use isPrime if there was an instance of the RiemannHypothesis.
20:46:23 <shachaf> Eduard_Munteanu: In the same way that foo :: Int -> Char is different from {- foo :: Int -> Char -}?
20:46:32 <rwbarton> Continuing in this not entirely serious vein, it shifts the location of a proof obligation to the occurrence of "instance RiemannHypothesis"
20:47:01 <rwbarton> In this case, the laws for the RiemannHypothesis instance being that the Riemann hypothesis holds
20:47:18 <Eduard_Munteanu> Yeah, but it's pretty much trivial since it doesn't isolate proofs using Riemann's hypothesis in any way.
20:47:18 <ddarius> However, I've now considered adding class constraints on to nullary classes.
20:47:27 <rwbarton> much like one should not write a Monoid instance without checking the laws
20:47:52 <ddarius> class Unsafe;  unsafePerformIO :: Unsafe => IO a -> a
20:48:03 <rwbarton> Huh.
20:48:09 <Axman6> o.O
20:48:33 <ion> > ($42) $ show>>>length>>>succ>>>show
20:48:34 <lambdabot>   "3"
20:49:15 * Eduard_Munteanu would figure   isPrime :: Integer -> RiemannHypothesis Bool  was "safer"
20:49:25 <rwbarton> Eduard_Munteanu: It's true that the programmer of isPrime needs to verify by hand that their function in fact tests for primality under the assumption of the Riemann hypothesis.  But once they have done so, they can document this fact to the world formally.
20:49:32 * shachaf wants nullary classes now.
20:49:39 <ddarius> class (Num String) => PHP;  foo :: PHP => a -> IO b
20:49:49 <Eduard_Munteanu> Heh.
20:49:50 <shachaf> Eduard_Munteanu: Why not isPrime :: RiemannHypothesis -> Integer -> Bool?
20:50:16 <dmoctezuma> thanks anyway ddarius
20:50:24 <Eduard_Munteanu> shachaf: assuming RiemannHypothesis was a reader-like monad, that's exactly what it is :)
20:50:35 <ion> class (Bool ~ String ~ Num ~ []) => PHP;
20:50:44 <shachaf> Eduard_Munteanu: Right, except that the second case is more obviously something that can be converted to type classes. :-)
20:50:44 <ddarius> class C | ->
20:50:52 <shachaf> Given that all you care about is whether the type is inhabited.
20:51:07 <shachaf> ddarius: What would that mean?
20:51:22 <ddarius> It would mean: class C
20:51:31 <Axman6> hmm, would it be possible to build a C interpreter in haskell?
20:51:31 <ddarius> class C a | -> is legal syntax now.
20:51:37 <Axman6> s/possible/easy i guess
20:51:42 <ddarius> Axman6: Yes.
20:51:45 <Eduard_Munteanu> Axman6: an EDSL?
20:52:00 <Axman6> no, like you give it C source dode, and run it
20:52:08 <ddarius> I was considering attempting to write a C compiler in a single day since we have Language.C and the LLVM bindings.
20:52:09 <Axman6> without translation to machine code
20:52:23 <Axman6> ddarius: that would be quite fun =)
20:52:25 <KirinDave> Hmm
20:53:27 <rwbarton> ddarius: I'm reminded somehow of perl's "taint mode" as well.
20:53:29 <Axman6> i have a feeling that 90% of the code would be pretty easy, but... the other 90% would not
20:53:31 <KirinDave> I'm having trouble trying to figure out how to take my own monad stack and mix it with an iterate using Data.Enumerator
20:54:18 <KirinDave> I guess I just run the enumerator $ attoparsec-parser-iteratee >>= my_own_monadic_function when I'm already inside my monad context, right?
20:54:29 <ddarius> Axman6: Only write 100% of the code rather than 180%.
20:54:37 <shachaf> Axman6: A compiler is just an optimization of an interpreter anyway. :-)
20:54:37 <Axman6> heh
20:54:40 <ion> I love the expression “taint mode”.
20:54:59 <rwbarton> I actually don't remember whether that's the real name
20:55:15 <ddarius> Axman6: You can probably get a compiler/interpreter that will run most reasonable C code very quickly.
20:55:26 <shachaf> "This C code is *most* reasonable."
20:55:47 <Eduard_Munteanu> Can you have class contexts like    (Foo Int) => ... ?
20:55:52 <ddarius> Getting it to actually be a conforming implementation of C will be much harder.  And getting it to run most actual C, reasonable or not, is even harder.
20:56:01 <shachaf> Eduard_Munteanu: With FlexibleContexts.
20:56:01 <ddarius> Eduard_Munteanu: With suitable extensions, yes.
20:56:34 <ddarius> Using equality constraints you could get further effects.
20:56:59 <Eduard_Munteanu> Hm, actually, that might make a nice usecase for nullary typeclasses, if checking was deferred until a function used them... like   class (Foo Int) => Bar where
20:57:01 <rwbarton> In that case one could conventionally write class Unsafe t; unsafePerformIO :: Unsafe () => IO a -> a
20:57:53 <shachaf> Of course one *could* do that.
20:58:47 <ddarius> rwbarton: Better.  data IO; class Unsafe t; unsafePerformIO :: Unsafe IO => IO a -> a; unsafeCoerce :: Unsafe Coerce => a -> b
20:59:12 <Eduard_Munteanu> Uh...
20:59:26 <shachaf> Can one write unsafePerformIO :: Unsafe t => IO a -> a?
20:59:33 <shachaf> I guess not.
20:59:47 <Eduard_Munteanu> I'm unsure how instance resolution would work.
20:59:49 <ddarius> shachaf: You can, it will just always be ambiguous.
21:02:05 <shachaf> Even if you had "instance Unsafe t".
21:02:05 <ddarius> It might work then.
21:02:05 <shachaf> It doesn't seem to.
21:02:05 <ddarius> It might also work if you had class Unsafe t | -> t
21:02:05 <ion> unsafePerformIO :: IO a → Unsafe a
21:02:05 <Eduard_Munteanu> ^^
21:02:05 * ddarius now considers adding associated types to nullary classes.
21:02:05 <shachaf> ddarius: STill doesn't seem to.
21:02:05 <shachaf> «At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'»
21:02:05 <ddarius> shachaf: So more power to nullary classes.
21:02:05 <shachaf> Yep.
21:02:18 <shachaf> OK, what's the motivation for associated types?
21:02:23 <Eduard_Munteanu> unsafeButPrettyUselessPerformIO :: IO a -> Unsafe a
21:02:36 <ddarius> type Unsafe a = a
21:03:15 * Eduard_Munteanu might rename that to justAsUnsafePerformIO
21:04:03 <Eduard_Munteanu> We're seriously lacking a suitable discussion topic :)
21:04:23 <ddarius> I guess there's no particular reason to use associated types with nullary classes other than the normal reasons you'd use associated types.
21:05:21 <ddarius> Eduard_Munteanu: What's another arbitrary restriction that Haskell (+ extensions) has that could be trivially generalized and what are the consequences of doing so?  Preferably entertaining examples.
21:05:23 <shachaf> What would be the advantage over a regular type synonym?
21:05:44 <ddarius> shachaf: It would only need to be defined if the instance is declared and would be whatever that instance declares.
21:05:59 <ddarius> class C where type T; f :: T -> T
21:06:05 <shachaf> I suppose.
21:07:27 <Eduard_Munteanu> Monad comprehensions would've been close on the list, but it's old news already.
21:08:05 <Eduard_Munteanu> Not really arbitrary... but mixfix would be nice.
21:08:08 <rwbarton> You could use this as an odd (and not very good) way to parameterize a module on some types and values.
21:08:31 <ddarius> Eduard_Munteanu: That's not an arbitrary restriction and providing it would not be completely trivial.
21:09:42 <rwbarton> does Haskell allow empty case expressions?
21:09:46 <Eduard_Munteanu> BTW, do class contexts on datatype declarations work? (I think they used to...)
21:09:54 <rwbarton> That's probably not very entertaining
21:10:06 <ddarius> rwbarton: No and this is related to the lack of empty data declarations, but it should do both.
21:10:23 <ddarius> Eduard_Munteanu: Yes, but they are about to be removed.
21:10:25 <Eduard_Munteanu> Empty data decls work with an extension, though.
21:10:28 <Eduard_Munteanu> Ah.
21:11:36 <shachaf> Empty case expressions could still be valid without empty data declarations.
21:11:42 <rwbarton> :t 3 :: () => Int
21:11:43 <lambdabot> Int
21:11:48 <ddarius> shachaf: Yes, but the ideas go hand in hand.
21:12:00 <rwbarton> :t 3 :: () => (() => Int)
21:12:01 <lambdabot> Int
21:12:04 <ddarius> That said, allowing empty cases may make some typos produce legal code.
21:12:08 <shachaf> Yes. And I suppose that only with empty data declarations could they work without warnings.
21:12:24 <rwbarton> or with GADTs perhaps
21:12:46 <ddarius> GHC will probably never be smart enough to do proper coverage checking for GADTs.
21:12:49 <rwbarton> which is a larger change anyways
21:13:16 <ddarius> And anyway, undefined would refute it still.
21:14:01 <Eduard_Munteanu> How about... fixities that bind tighter than function application?
21:14:12 <ddarius> Like record update?
21:14:24 <ddarius> Eduard_Munteanu: That would be evil anyway.
21:14:29 <Eduard_Munteanu> :)
21:14:30 <rwbarton> > 3 {}
21:14:31 <lambdabot>   <no location info>: Empty record update
21:14:42 <ddarius> rwbarton: Yes, that can be handy.
21:14:51 <ddarius> Well the pattern form.
21:15:00 <shachaf> But the update form is forbidden?
21:15:03 <rwbarton> Ah
21:15:04 <Eduard_Munteanu> Not especially like record update, but stuff you could declare for arbitrary ops
21:15:10 <ddarius> > Just {}
21:15:11 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
21:15:17 <shachaf> > (Just 5) {}
21:15:18 <lambdabot>   <no location info>: Empty record update
21:15:34 <rwbarton> seems like an arbitrary restriction!
21:15:38 <ddarius> It doesn't like updating types with no fields.
21:15:39 <shachaf> Aha!
21:15:55 <ddarius> > Nothing {}
21:15:56 <lambdabot>   Nothing
21:15:58 <ddarius> ..
21:16:18 <rwbarton> er... oh.
21:16:26 <Eduard_Munteanu> So Haskell rejects valid programs !!111
21:16:30 <shachaf> @ty let foo :: State Int Int; foo = get in foo {}
21:16:31 <lambdabot> Empty record update
21:16:42 <rwbarton> Can it not tell whether {} is record update or a list of fields?
21:17:06 <ddarius> rwbarton: What do you mean?
21:17:14 <shachaf> ddarius: What's less valid about updating Just than about updating Nothing?
21:17:24 <ddarius> shachaf: Nothing.
21:17:29 <ddarius> Updating Nothing worked.
21:17:35 <shachaf> Bu updating Just didn't.
21:17:35 <rwbarton> Nothing {} isn't an update is it?
21:17:38 <shachaf> Why?
21:17:39 <ddarius> shachaf: Yes it did.
21:17:52 <rwbarton> It's like Just {} which is Just undefined
21:17:54 <ddarius> rwbarton: Yeah, it's a construction.
21:18:08 <ddarius> > let n = Nothing in n {}
21:18:08 <lambdabot>   <no location info>: Empty record update
21:18:12 <shachaf> > (Nothing) {}
21:18:13 <lambdabot>   <no location info>: Empty record update
21:18:18 <ddarius> That's great
21:18:22 <shachaf> Oh, so updating Nothing doesn't work.
21:18:34 <ddarius> Yeah, so what I said earlier was right.
21:18:37 <parcs> why are empty record updates forbidden?
21:18:42 <rwbarton> What I meant was, perhaps allowing empty record updates would make {} ambiguous as to whether it is a record update or a construction. But I don't think that makes sense
21:18:59 <ddarius> > Just {} {}
21:18:59 <lambdabot>   <no location info>: Empty record update
21:19:21 <rwbarton> and indeed apparently it is purely syntactic depending on whether the preceding thing is a constructor or some other kind of expression
21:19:21 <Eduard_Munteanu> Oh, one other that crossed my mind... but it's wrong because we have bottoms... empty function definitions a-la Agda. E.g. f ()
21:19:23 <shachaf> That's an inconsistency between matching and application, kind of.
21:19:53 <ddarius> n {} should be identity in my opinion.
21:19:59 <ddarius> i.e. n
21:20:06 <shachaf> Yes.
21:20:15 <rwbarton> Then what about Just {}?
21:20:18 <shachaf> Well, maybe not if n is a function?
21:20:21 <rwbarton> not the same as (Just) {}?
21:20:31 <shachaf> Nope.
21:20:35 <rwbarton> I mean, already they are not the same
21:20:43 <rwbarton> but at least one is a syntax error
21:20:49 <shachaf> Neither is a syntax error.
21:21:02 <shachaf> Well, it depends on whether you consider "empty record update" a syntax error.
21:21:03 <rwbarton> Currently (Just) {} is
21:21:09 <shachaf> I guess it is.
21:21:15 <rwbarton> it's not a type error anyways
21:21:16 <ddarius> > Just {} 3
21:21:17 <lambdabot>   Couldn't match expected type `t1 -> t'
21:21:17 <lambdabot>         against inferred type `Data....
21:21:43 <shachaf> The way update/construction syntax is overloaded is kind of ugly, actually.
21:22:12 <Eduard_Munteanu> > Nothing {} {}
21:22:13 <lambdabot>   <no location info>: Empty record update
21:23:53 <parcs> :t ?x {}
21:23:54 <lambdabot> Empty record update
21:24:16 <Eduard_Munteanu> I also wonder what it takes to have functors as functions.
21:24:22 <ddarius> > (,) {}
21:24:23 <lambdabot>   (*Exception: <interactive>:3:0-5: Missing field in record construction
21:24:35 <rwbarton> there's at least one other situation where seemingly innocuous parentheses change the meaning of a program... let (a) = foo is not generalized
21:24:39 <ddarius> Functors aren't functions.
21:24:47 <Eduard_Munteanu> f :: * -> *; f _ = Int
21:25:36 <Eduard_Munteanu> Erm, that's what I mean.
21:25:39 <rwbarton> > {}
21:25:40 <lambdabot>   <no location info>: parse error on input `{'
21:25:44 <ddarius> Eduard_Munteanu: That's just type level functions.
21:26:00 <parcs> > ((,)) {}
21:26:01 <lambdabot>   <no location info>: Empty record update
21:26:04 <Eduard_Munteanu> Yep. And you can't really write that in Haskell, can you?
21:26:09 <incluye> > ((,))
21:26:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> (a, b))
21:26:09 <lambdabot>    arising from ...
21:26:50 <ddarius> Eduard_Munteanu: No.  It could be added, though it would have to be somewhat constrained or else you'd get undecidable type checking, and how exactly it would interact with type classes let alone the various extensions is not clear.
21:27:09 <ddarius> @google "higher order pattern unification"
21:27:10 <lambdabot> http://www-users.cs.umn.edu/~gopalan/talks/hopu.pdf
21:27:11 <lambdabot> Title: Practical Higher-Order Pattern Unification with On-the-Fly Raising
21:27:18 <Eduard_Munteanu> Sure, you probably can't pattern-match on values of *.
21:27:31 <Eduard_Munteanu> (at least you can't pattern-match on Agda's Set)
21:27:35 <ddarius> Eduard_Munteanu: That's not the problem.
21:27:51 <ddarius> And it's possible that that could be allowed.
21:28:23 <shachaf> Hmm, the Haskell report actually specifies that record updates must be non-empty.
21:28:27 <ddarius> Eduard_Munteanu: The problem is when you need to unify f Int with g Bool.
21:29:04 <ddarius> And f and/or g are unbound.
21:29:59 <ddarius> (Yeah, and the general case is not just undecidable but non-deterministic which would be very problematic.)
21:29:59 <Eduard_Munteanu> And won't they unify assuming f _ = Int?
21:30:23 <ddarius> Eduard_Munteanu: That's not the most general unifier.
21:30:28 <Eduard_Munteanu> You just compute f Int and g Bool.
21:30:36 <ddarius> f and g are unbound.
21:30:53 <ddarius> This unification has to compute the (type) functions f and g.
21:30:54 <Eduard_Munteanu> Oh, hrm.
21:31:21 <ddarius> This is what higher order unification does, but it is undecidable and non-deterministic.  Higher order pattern unification is a subset that is decidable and deterministic.
21:31:47 * shachaf imagines some future Haskell implementation first compiling all the types in a program to efficient machine code in order to do the type checking, then using the result to compile the actual program.
21:32:01 <ddarius> shachaf: That probably won't be too far away.
21:32:30 <Eduard_Munteanu> I initially thought this would be simple, since the sorts hierarchy is quite limited in Haskell.
21:36:14 <Eduard_Munteanu> An interesting thing I've seen the other day was using record update syntax, which changed types, but threw away the intermediate value. It would result in ambiguity in the presence of class contexts.
21:36:24 <Eduard_Munteanu> I think rwbarton was around.
21:37:28 <rwbarton> right, there was nothing constraining the pre-update type to be the same as the post-update type
21:38:00 <Eduard_Munteanu> Indeed, though I'd still expect that program to be valid. :/
21:38:00 <ddarius> For classes, if you allow something like: instance Category hom => Category (\b a -> hom a b) where ... it's not clear if this should conflict with the hom instance since two applications would return you to the original, admittedly you'd need undecidable instances to even state this example.
21:38:27 <Eduard_Munteanu> (since it threw away the pre-update value completely)
21:38:31 <ddarius> The "dual" problem with sum types and case is really annoying.
21:39:46 <ddarius> We need a variant update syntax.
21:40:13 <ddarius> But it wouldn't be reasonable unless it unsafeCoerced.
21:41:13 <Eduard_Munteanu> Can't you do it with type synonyms instances already?
21:41:30 <Eduard_Munteanu> (that's a bit broken too, though)
21:42:45 <ddarius> I guess what we need is automatically generated fmap like functions for each covariant type variable (and might as well as contrafmap like functions for the contravariant ones.)
21:42:55 <Eduard_Munteanu> type Contravariant hom a b = hom b a; instance Category hom => Category (Contravariant hom) I mean
21:43:00 <rwbarton> ddarius: If you wrote  class UnsafeIO a | -> a ; unsafePerformIO :: UnsafeIO Yes => IO a -> a, then a library could mark which exported functions use unsafe operations with the UnsafeIO Yes context, and an application could verify that the library is not lying (by definining its own UnsafeIO Yes instance) by defining an instance UnsafeIO No
21:43:15 <ddarius> Eduard_Munteanu: Unless they did something evil recently, that is illegal.
21:44:00 <ddarius> rwbarton: That's not bad.
21:44:02 <rwbarton> Or, the application could define instance UnsafeIO Yes to use the unsafe functions
21:45:32 <rwbarton> (And if you don't like type families, this gives you an application for associated types of nullary classes)
21:45:56 <rwbarton> using an equality context in place of UnsafeIO Yes
21:46:56 <ddarius> As in: data Yes; data No; class UnsafeIO where type UnsafeIOAllowed;  instance UnsafeIO where type UnsafeIOAllowed = No;
21:47:16 <rwbarton> right
21:47:29 <ddarius> And unsafePerformIO :: (UnsafeIOAllowed ~ Yes) => ...
21:48:23 <rwbarton> Though now I'm a bit confused... suppose module A imports modules B and C, which each have an instance declaration C t; is there any circumstance under which ghc will accept this?
21:48:47 <rwbarton> does it try to check whether the instances are the same?
21:48:49 <ddarius> C T or C t
21:48:49 <ddarius> ?
21:48:53 <rwbarton> Let's say C T
21:48:55 <ddarius> No it doesn't.
21:49:05 <ddarius> Unless they got them from some other module D.
21:49:10 <rwbarton> But if B and C both import... hmm I see.
21:49:48 <rwbarton> In that case there might be some less arcane way to achieve the same result
22:12:13 <KirinDave> Have you ever gotten a complex piece of code to compile
22:12:23 <KirinDave> and been almost afraid to test it because you don't want to know if it doesn't work? ;)
22:13:08 <KirinDave> https://github.com/KirinDave/Fanboy/blob/master/Fanboy/Runloop.hs
22:13:15 <KirinDave> I'll be so bummed if this doesn't work.
22:15:15 <Jafet> Uh, how could it compile and not work?
22:15:21 <Jafet> That sounds unusual.
22:15:40 <KirinDave> Jafet: Happens all the time.
22:15:53 <KirinDave> Jafet: For example, I had one just earlier
22:16:17 <KirinDave> Jafet: Where I foolishly combined the 'many' parser combinator with the 'takeTill' parser combinator. Infinite loop.
22:23:12 <ttvd> hi, i have a weird question, i have two functions F and G, both take a single argument.. how do i apply efficiently F and G in a sequence in haskell?
22:23:16 <ttvd> n times
22:23:22 <ttvd> i can't wrap my head around this
22:23:39 <copumpkin> can you give an example of what you mean?
22:23:51 <ttvd> like f.g.f.g.f.g.f.g 0
22:23:51 <ttvd> etc
22:24:01 <adnam> iterate (f.g) ?
22:24:16 <ttvd> ohh damnit
22:24:17 <ttvd> thanks
22:25:38 <Jafet> (fromInteger n) (f.g)
22:26:07 <aspect> :t fromInteger
22:26:08 <lambdabot> forall a. (Num a) => Integer -> a
22:26:26 <ttvd> ya
22:27:03 * aspect doesn't understand the typeclass
22:27:39 <turtlesalltheway> whats the future of programming
22:28:49 <copumpkin> turtlesalltheway: APL
22:29:34 <turtlesalltheway> is haskell dead though
22:29:49 <copumpkin> totally
22:29:52 <Jafet> No, it's just resting.
22:30:24 <c_wraith> the future of programming is bugs, and resisting innovation.  Haskell prevents neither of those.
22:32:38 <ddarius> c_wraith: I thought that that was the past... and the present?
22:33:13 <c_wraith> ddarius: and the future
22:33:28 <Jafet> What about beyond the future?
22:33:55 <turtlesalltheway> could haskell represent the end of new programming languages
22:33:59 <c_wraith> No.
22:34:04 <c_wraith> Haskell's not an end point.
22:34:12 <c_wraith> There's plenty more to be done.
22:34:14 <ddarius> Could Haskell represent the coend of new programming languages?
22:34:28 <c_wraith> yes
22:34:30 <c_wraith> :)
22:34:40 <c_wraith> Jafet: aren't all points beyond the future also the future?
22:34:58 <Jafet> What about the points beyond all points in the future?
22:35:05 <ddarius> The grocery store tricked me.
22:35:24 <c_wraith> Jafet: I'm too constructivist to believe in them
22:35:31 <ddarius> Same here.
22:35:50 <Jafet> Be coconstructivist instead
22:36:03 <ddarius> Disbelieve in finite sets.
22:36:18 <ddarius> Actually, I was considering something very vaguely like this recently.
22:36:18 <johnfn> can someone remind me how to get the name of the object that you've deconstructed in a function argument list? i can't figure out how to google for it :/
22:36:35 <ddarius> as patterns
22:36:52 <ddarius> > f xs@(x:y) = (xs, x, y)
22:36:53 <lambdabot>   <no location info>: parse error on input `='
22:37:02 <ddarius> > let f xs@(x:y) = (xs, x, y) in f "abc"
22:37:03 <lambdabot>   ("abc",'a',"bc")
22:37:21 <turtlesalltheway> could programming ever progress?
22:37:39 <ddarius> I think Zeno proved that it could not 2000 years ago.
22:37:43 <johnfn> ah, @! thanks ddarius :)
22:38:04 <c_wraith> turtlesalltheway: we're essentially in the wild west of programming...  Hard to predict if some order will ever come of it.
22:38:42 <ddarius> "Try to set a faster pace.  Try to build a master race.  One that will make a contribution to tomorrow."
22:39:13 <aspect> ddarius: keen observation, given that programmers can only ever divide by two .. not to mention floating point
22:40:24 <Jafet> > any (1==) $ iterate (/2) 0.5
22:40:28 <lambdabot>   mueval-core: Time limit exceeded
22:40:36 <Jafet> > any (1==) $ scanl (+) 0 $ iterate (/2) 0.5
22:40:37 <lambdabot>   True
22:40:41 <turtlesalltheway> why cant ever program be written?
22:42:22 <ddarius> aspect: Yes, I believe Diogenes' retort was, "I believe that is NaN."
22:43:08 <ddarius> It would be tricky to do math with only infinite sets.
22:43:23 <aspect> diogenes was an honest fool.  It's epsilon all the way down
22:43:56 <turtlesalltheway> math does not exist
22:44:02 <kmc> the end of history
22:44:10 <minsa> I am reading thishttp://www.iceteks.com/articles.php/haskell/3 and have some questions.
22:44:41 <minsa> the example program is looping the main and collecting the name in a list.
22:44:54 <minsa> else do greet name
22:44:55 <minsa>                     nextRun <- main
22:44:58 <minsa>                     return $ name : nextRun
22:45:35 <minsa> the author said "We can't directly use main since it returns an IO tainted list." Instead we first extract that list.
22:45:52 <minsa> bye doing "return $ name : nextRun.
22:46:02 <ddarius> minsa: Read a different introduction.
22:46:03 <minsa> my question is what does $ do and how does it help ?
22:46:30 <shachaf> "IO tainted list"?
22:46:43 <minsa> yap, straight from the text.
22:46:56 <shachaf> As ddarius says, read a different introduction.
22:47:04 <Jafet> Unhygienic burrito kitchens
22:47:14 <shachaf> "IO a" isn't "an IO tainted a".
22:47:17 <minsa> I mean without going into any of the Monad, can you tel me a little bit about $ in that last line ?
22:47:34 <aspect> $ helps by saving you typing () and making the syntax look a little more like perl.  An equivalent expression would be (return (name:nextRun))
22:47:55 <minsa> what if I don't use ( ) ?
22:48:09 * aspect borderline-troll: what is it with haskell and fucky operators anyway?
22:48:10 <turtlesalltheway> can all philosophical insights be developed into a programmign language?
22:48:21 <ddarius> fucky = funky?
22:48:33 <aspect> (return name:nextRun) parses as ((return name):nextRun)
22:48:37 <Jafet> @quote Jafet succ
22:48:37 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
22:48:40 <ddarius> turtlesalltheway: Have you looked at philospophy?
22:49:02 <turtlesalltheway> philosophy is worthless
22:49:05 <aspect> ddarius: approaching-perl-like
22:49:08 <ddarius> Jafet: Your mother would be proud.
22:49:26 <fabjan> not even all computations can be programs, right?
22:49:27 <ddarius> aspect: Perl has sigils and its operators are built in.
22:49:57 <ddarius> fabjan: I'd be rather wary of a definition of "computation" that could not be realized as a program.
22:50:07 <fabjan> all right, bad choice of words :P
22:50:36 <fabjan> if it's not computable maybe you shouldn't call it computation
22:51:32 <minsa> ddarius: is that tutorial not good by reputation or you just decided after my question.
22:52:19 <turtlesalltheway> if haskell is so great why cant it improve itself
22:52:20 <ddarius> minsa: I've never heard of it or its author and it is saying stupid stuff.
22:52:31 <ddarius> @faq Can Haskell improve itself?
22:52:31 <lambdabot> The answer is: Yes! Haskell can do that.
22:52:53 <kmc> @remember turtlesalltheway if haskell is so great why cant it improve itself
22:52:53 <lambdabot> Done.
22:52:58 <minsa> ddarius: thnx.
22:53:00 <kmc> kids, don't do drugs.  stay in school
22:53:17 <ddarius> kids, don't do school.  Oh, and don't do drugs either.
22:54:19 <kmc> go to school so you can have easier access to drugs
22:54:23 <aspect> ddarius: my point, I guess, is that my early experience of Haskell has been made more difficult than I hoped due to the abundance of unfamiliar and non-obvious operators ($, !!) whose precedence rules generally defy my intuition.  I'll include unary negation in there too
22:54:36 <turtlesalltheway> why has programming failed to explain thinking?
22:55:02 <c_wraith> unary negation is the only hard thing
22:56:21 <ddarius> aspect: My experience is that there is usually an "obviously" correct parsing of expressions even if you don't know the fixities as long as you know applications binds tighter than any infix operator.
22:57:08 <ddarius> aspect: It seems clear that user defined infix operators are more beneficial than not.  If they make it a bit more difficult while learning, I do not care.
22:57:34 <turtlesalltheway> isnt haskell a pure indulgence, with no practical value
22:57:44 <kmc> KirinDave, i've had that feeling re: testing.... the thing about Haskell types catching stupid typo bugs is that any remaining bugs will be tricky logic errors
22:57:45 * ddarius should go find the very first Haskell program he saw.
22:57:54 <KirinDave> kmc: Indeed
22:57:59 <KirinDave> Right now I am debugging my parser
22:58:09 <KirinDave> And also discovered I didn't really understand the IRC protocol
22:58:17 <kmc> haha
22:58:19 <ddarius> kmc: Tricky typo bugs can often take hours to figure out.
22:58:19 <KirinDave> But!
22:58:29 <kmc> what, you didn't handle case-insensitive nick comparison properly?
22:58:32 <KirinDave> My iteratees are working great.
22:58:32 <ddarius> Er stupid typo bugs.
22:58:37 <KirinDave> kmc: No no, this is just clean message parsing
22:58:44 <KirinDave> Jesus it's a messy protocol.
22:58:50 <kmc> ddarius, true that.  i once spent 2 weeks of on-and-off debugging of what ended up being x' vs x
22:58:57 <KirinDave> Like, colons are important but only when bracketed by whitespace
22:58:58 <aspect> I guess I just need to become accustomed to it.  Generally I find reading code fairly obvious (mostly due to well-named functions), but when writing I remain confused.  Your tip on application > * will probably be useful though
22:59:08 <kmc> since then i've developed a distaste for primed variables
22:59:10 <KirinDave> and not every server seems to agree on exactly this, as I can log into one server but not another.
22:59:16 <kmc> in fact i wish Haskell had non-recursive let for this reason
22:59:29 <kmc> in ocaml it's common to say «let x = f x» as a simple shadowing
22:59:31 <KirinDave> Debug.Trace is a merciful thing.
22:59:36 <ddarius> aspect: When writing you can just use superfluous parentheses, though I will deride your code if they are super superfluous like (f x) + (g y).
22:59:37 <dankna> yes - I dislike primed variables for the same reason
22:59:39 <KirinDave> I don't care if I am impure
22:59:43 <KirinDave> I DO NOT CARE
22:59:49 <kmc> and the primed variable has the same type as the original, of course
22:59:53 <dankna> of course
22:59:54 <ddarius> kmc: Shadowing warnings are helpful.
23:00:07 <kmc> ddarius, yeah.  i've learned to always always always use -Wall
23:00:14 <kmc> alias ghc='ghc -Wall'
23:00:14 <shachaf> let x' = f x in let x = g x' in let x' = h x in i x'
23:00:27 <ddarius> kmc: But yeah, I've decided to never try to do that "I'll pretend Haskell has mutation by repeatedly shadowing a variable" because it always ends in tears.
23:00:50 <kmc> i usually go for x2 or new_x
23:00:55 <ddarius> shachaf: You can abuse do and I think there's another way as well.
23:00:57 <Jafet> aspect: init ((foldr (.) id (map ((.) (++) ((.) (flip (++) " ") reverse)) ["uoY", "referp", "eht", "?evitanretla"])) "")
23:00:59 <shachaf> x_prime
23:01:04 <shachaf> ddarius: Implicit variables!
23:01:06 <kmc> but you can usually get around needing it at all
23:01:08 <ddarius> x_prime_prime_prime
23:01:10 <aspect> ddarius: I come from Scheme so I end up doing superfluous parentheses a lot :-).  It seems un-idiomatic though ...
23:01:23 <aspect> Jafet: heh.  See my first four words above :-)
23:01:25 <shachaf> @where evolution
23:01:26 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
23:01:43 <yitz> a utility that would list all expressions in a program containing both + and - might save hours of debugging time.
23:02:29 <ddarius> shachaf: Even better, monochrom's style:  x'prime'prime'prime
23:04:00 <yitz> i like variable names like "isn't". i don't use them though, it confuses some editors and such.
23:04:25 <kmc> hehe
23:04:40 <kmc> let don't = const (return ())
23:05:29 <yitz> let don't = const $ error "OK, I didn't."
23:05:54 <opqdonut> :)
23:06:19 <danr> ^^
23:09:27 <dankna> haha
23:10:29 <Jafet> Example usage: don't $ do ...
23:10:53 * shachaf wishes $ wasn't required before do.
23:11:27 <ddarius> shachaf: What about \?
23:11:41 <shachaf> ddarius: That too.
23:11:47 <shachaf> What ambiguity does it cause?
23:12:02 <ddarius> I'm pretty sure it doesn't cause an ambiguity.
23:12:06 * shachaf also vaguely wishes that \ only supported one argument at a time, and didn't require an arrow.
23:12:11 <shachaf> Though I'm not sure about that.
23:12:17 <shachaf> Arrows are really ugly, though.
23:12:44 <ddarius> shachaf: You should see lambdaProlog's syntax.  It's readable at first, until you see the syntax described, then it's very confusing, until it clicks, then it is cute.
23:12:57 <ddarius> shachaf: Just don't use lambda.  That's what I do.
23:13:02 <Jafet> Just make "case of" introduce lambdas
23:13:31 <shachaf> That might lead to an overuse of @.
23:13:42 <shachaf> Though I guess that's no worse than what you get with function definitions.
23:13:53 <Jafet> Then make "\" expand to "case of".
23:14:25 <shachaf> Jafet: Brilliant!
23:14:36 * shachaf doesn't think \x\y\z ... is so bad, though.
23:14:55 <ddarius> We should just have blanks that we can use and leave it up to some arbitrary rules to try to guess our intent.
23:15:39 <shachaf> \more arglist
23:16:27 <mauke> \Foo bar baz qux
23:16:46 <shachaf> mauke: Yes, it's a bit annoying that that requires parentheses right now.
23:16:59 <dankna> blah
23:17:02 * ddarius doesn't find that annoying.
23:17:04 <dankna> I want reentrant locks on MVars
23:17:08 <dankna> like
23:17:13 <dankna> if the same thread already holds the lock
23:17:19 <dankna> oh well, hm
23:17:22 <mauke> wait, what lock?
23:17:34 <ddarius> That's what I was thinking.
23:17:39 <dankna> well, I had a brain freeze trying to explain what I meant
23:17:45 <dankna> maybe an example
23:17:45 <shachaf> ddarius: Fine, just the arrow is annoying.
23:17:56 <dankna> I have a record of mvars, right
23:17:59 <ddarius> shachaf: I find both the arrow and the backslash annoying.
23:18:08 * shachaf is unsuccessful in finding simple examples of lambdaProlog's syntax.
23:18:09 <turtlesalltheway> isnt haskell a pure indulgence, with no practical value??
23:18:20 <dankna> and I have some functions which "acquire a mutex" by taking some of these mvars (I avoid deadlock by always acquiring them in the same order)
23:18:21 <mauke> turtlesalltheway: did you have a point somewhere?
23:18:22 <shachaf> ddarius: What syntax would you prefer?
23:18:24 <shachaf> turtlesalltheway: Absolutely.
23:18:52 <dankna> and I would like to be able to call my utility functions from my higher-level functions
23:18:59 <dankna> but I can't because both want to take and hold the same mvar
23:19:12 <dankna> perhaps I can build a higher-level abstraction on top of mvars, if I can figure out how it should behave
23:19:23 <mauke> dankna: or on top of STM
23:19:27 <mauke> which is usually easier
23:19:28 <dankna> mm
23:19:30 <dankna> point.
23:19:37 <dankna> but then I'd have to learn STM :)
23:19:54 <ddarius> shachaf: C#'s is nice but I don't think would work well in Haskell.  It actually conflicts with Intellisense (as does C#'s notation for polymorphic methods,) though I prefer the conflict to the alternative.
23:20:13 <mauke> dankna: that should be trivial
23:20:19 * shachaf hasn't used C#.
23:20:20 <dankna> oh?
23:20:23 <mauke> dankna: do you know IORefs?
23:20:26 <dankna> yes
23:20:28 <shachaf> (args) => body?
23:20:48 <mauke> dankna: ok, TVars are like IORefs
23:20:58 <KirinDave> bingo. http://fayr.am/9ttA
23:21:03 <luite> only you wrap evertthing in atomically :)
23:21:12 <KirinDave> I am feeling like I actually sorta maybe kinda understand Data.Enumerator now
23:21:13 <dankna> hmmm
23:21:14 <dankna> okay.
23:21:20 <dankna> what are the performance concerns I have to be careful of?
23:21:26 <mauke> dankna: runSTM is called 'atomically'
23:21:29 <dankna> and which module does this all live in?
23:21:50 <mauke> http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Monad-STM.html
23:21:58 <shachaf> ddarius: A potentially-nice lambda syntax for C-ish-syntaxed languages is "(args){body}".
23:22:32 <mauke> shachaf: sucks, tail nesting, etc
23:22:48 <synonymous> why can't I have constraints on more than one type variable in a data constructor? like so:
23:22:48 <synonymous> data Foo = (Num a, Num b) => Foo a b
23:22:48 <synonymous> Not in scope: type variable `b'…
23:22:50 <KirinDave> dankna: Are they selling you on STM?
23:22:50 <shachaf> Tail nesting?
23:22:55 <dankna> the ObjC lambda syntax is pretty nice
23:23:03 <dankna> KirinDave, they might be!  I can't tell yet.  why?
23:23:29 <KirinDave> dankna: Don't nest structures and its not slow at all
23:23:43 <dankna> KirinDave: hmm.
23:23:51 <mauke> nested how?
23:24:01 <mauke> like a TVar storing a list of TVars or something?
23:24:06 <dankna> anyway the ObjC syntax is
23:24:07 <KirinDave> mauke: Say, TVars inside Maps
23:24:10 <dankna> ^(args){body}
23:24:15 <KirinDave> mauke: That are also transactional
23:24:23 <dankna> it kinda sucks trying to find a consistent indentation policy for it
23:24:26 <dankna> but oh well
23:24:31 <KirinDave> mauke: Contention along that route, in my tests, shatters performance. Like a hammer to the groin.
23:24:42 <dankna> what a vivid simile
23:24:55 <ddarius> shachaf: Yes, re C#'s syntax, except the parentheses can be excluded if you have only one argument.
23:25:05 <ddarius> So, id is x => x
23:25:28 <shachaf> Hmm. Not that bad, I suppose.
23:25:35 * shachaf has developed anti-arrow sentiments.
23:25:37 <mauke> shachaf: I call it tail nesting when you have a construct X nested within a construct Y and X is the last child of Y
23:25:53 <shachaf> mauke: And then you would need "}}}"?
23:26:00 <mauke> yes
23:26:08 <mauke> and then my lisp allergy kicks in
23:26:30 <shachaf> That happens in Haskell when you use parenthesyntax.
23:26:42 <shachaf> I guess you can usually avoid it, though.
23:26:51 <mauke> haskell has no syntactic terminator in \
23:27:02 <mauke> and $ lets you avoid it for simple expressions
23:27:16 <shachaf> Like runST.
23:27:22 <mauke> dohoho
23:27:22 * ddarius prefers "tail nesting" to "head nesting".
23:28:23 <mauke> f $ \x -> g $ \y -> x y
23:28:39 <mauke> f(function (x) { return g(function (y) { return x(y); }); });
23:29:15 <mauke> f sub { my ($x) = @_; g sub { my ($y) = @_; $x->($y) } };
23:30:06 <shachaf> f((x) { g((y) { x(y) }) })
23:30:08 <mauke> (f (lambda (x) (g (lambda (y) (funcall x y)))))
23:30:12 <shachaf> I guess that's somewhat bad.
23:31:03 <mauke> in my opinion perl syntax gets the second place if you ignore the 'my (...) = @_' parameter bullshit
23:31:14 <flux> let f x = g (fun y -> x y) (* the ocaml version for reference *)
23:31:22 <mauke> flux: fail
23:31:38 <mauke> f (fun x -> g (fun y -> x y))
23:31:56 <flux> right. I somehow picked it the wrong way :)
23:32:22 <shachaf> f $ \x g $ \y x y
23:32:36 <mauke> f \x g \y x y
23:32:56 <shachaf> f\x g\y x y
23:33:41 <mauke> (f #$ lambda (x) #$ g #$ lambda (y) #$ funcall x y)
23:33:44 <kmc> f (x => g (y => x y))
23:33:52 <turtlesalltheway> haskell doesnt explain anything
23:33:52 <turtlesalltheway> its like walking on a disappearing bridge
23:34:11 <shachaf> turtlesalltheway: Made of burriots.
23:34:13 <mauke> turtlesalltheway: did you have a point somewhere?
23:34:17 <shachaf> Er, burritos.
23:34:17 <flux> but I really dislike the lisp 'funcall' :/
23:34:21 <shachaf> It disappears because you're eating it.
23:34:26 <kmc> turtlesalltheway, you know what lives under bridges?
23:34:38 <mauke> bridges all the way down
23:34:51 <flux> and in general the values versus functions thing
23:35:09 <shachaf> kmc: cheater?
23:35:24 <turtlesalltheway> it's just a glorified calcualting machine
23:36:06 <mauke> turing award right there
23:36:10 <kmc> Haskell is just another inferior way to write Post's tag-rewriting systems
23:37:36 <kmc> turtlesalltheway, so, what are you hoping to get out of this interaction?
23:37:47 <turtlesalltheway> HIV/Aids
23:37:49 <mauke> closure?
23:37:55 <mauke> a mere continuation?
23:38:30 <Jafet> I think it is hammer time.
23:38:38 * kmc stops, in preparation
23:40:48 <cheater> shachaf, no u
23:42:07 <xrl> I'm having a hard time coming up with a simple solution for transforming a list in to a rolling accumulation of its values
23:42:14 <ddarius> shachaf: The aspects that I'm referring to re lambdaProlog are the lambdas.  An example would be a formula like: eval (lam X \ F X) (clo Z \ V Z) <= pi Y \ eval (F Y) (V Y).
23:42:22 <xrl> [0,1,3,5] -> [0,1,4,9]
23:42:32 <ddarius> (I'm not sure if that formula is sane.)
23:42:33 <xrl> I've used mapAccumL but I think that's overkill?
23:42:49 <Jafet> > scanl (+) 0 [0,1,3,5]
23:42:49 <lambdabot>   [0,0,1,4,9]
23:42:51 <ddarius> > scanl1 (+) [0,1,3,5]
23:42:52 <lambdabot>   [0,1,4,9]
23:43:17 <Guest70128> scanl (+) 1 [1,2,3,4,5]
23:43:35 <Guest70128> > scanl (+) 1 [1,2,3,4,5]
23:43:35 <lambdabot>   [1,2,4,7,11,16]
23:44:23 <xrl> oh :)
23:44:29 * ddarius will need to build lambdaProlog.
23:44:31 <frerich> That's the first time I see a case where one of the scan* functions is useful. I never got what they are good for. :-}
23:44:40 * hackagebot digest-pure 0.0.1 - Pure hash functions for bytestrings  http://hackage.haskell.org/package/digest-pure-0.0.1 (DanielDeKok)
23:44:47 <xrl> ya, I saw it in the Data.List documentation
23:44:47 <ddarius> frerich: They're rather useful.
23:44:56 <xrl> but looking at the examples I thought "what does that do?"
23:44:57 <kmc> they're for transforming a list in to a rolling accumulation of its values ;)
23:45:09 <xrl> haha, I guess so
23:45:13 <frerich> ;-)
23:45:18 <kmc> @src scanl
23:45:18 <lambdabot> scanl f q ls = q : case ls of
23:45:18 <lambdabot>     []   -> []
23:45:18 <lambdabot>     x:xs -> scanl f (f q x) xs
23:45:27 <ddarius> scans are like folds that output the intermediate values.
23:45:41 <kmc> @where folds
23:45:41 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
23:45:49 <kmc> four oh four :/
23:46:01 <xrl> @src scanl1
23:46:01 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
23:46:01 <lambdabot> scanl1 _ []     =  []
23:46:03 <kmc> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
23:46:09 <Jafet> > scanl f z [a,b,c] :: Expr
23:46:09 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:46:10 <lambdabot>         against inferred ...
23:46:12 <c_wraith> > scanl (+) 0 $ repeat 1
23:46:13 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:46:23 <shachaf> > scanl f z [a,b,c,d,e]
23:46:24 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d,f (f (f (f (...
23:46:26 <kmc> @where+ folds http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
23:46:27 <lambdabot> It is forever etched in my memory.
23:47:20 <turtlesalltheway> why are haskell programmers so angry?
23:47:43 <frerich> My troll bells are going off!
23:47:53 <kmc> turtlesalltheway, you're the least effective troll in some time
23:48:04 <shachaf> Can someone get rid of turtlesalltheway?
23:48:07 <flux> I guess you need to start somewhere.
23:48:10 <kmc> @where ops
23:48:10 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
23:48:13 <shachaf> My #haskell-message notifier keeps going off.
23:48:14 --- mode: ChanServ set +o mauke
23:48:14 --- mode: mauke set +q $a:frendshipismagic
23:48:19 <kmc> thanks
23:48:37 <Jafet> > pony !! 13
23:48:37 <lambdabot>   Not in scope: `pony'
23:48:41 <copumpkin> mauke is faster than a speeding train
23:48:54 <ddarius> copumpkin: Trains are pretty slow.
23:49:03 <ddarius> Though much faster than walking.
23:49:04 --- mode: mauke set -o mauke
23:49:08 <copumpkin> bullet?
23:49:15 <frerich> ddarius: I'm sure they are useful. It's just that they are so generic that I always thought "Why would anybody want to do this?", so they never occurred to me as possible solutions when I was facing some problem. I think your "scans are like folds outputting the intermediate values" is a really nice mental bridge.
23:49:39 <xrl> that scanl1 hint has removed 8 lines of src code ;)
23:49:44 <copumpkin> or how about a railgun-launched projectile
23:49:47 <copumpkin> those get pretty fast
23:49:53 <kmc> > iterate ((1:) . (scanl (+) 0)) []
23:49:54 <lambdabot>   [[],[1,0],[1,0,1,1],[1,0,1,1,2,3],[1,0,1,1,2,3,5,8],[1,0,1,1,2,3,5,8,13,21]...
23:50:05 <ddarius> ETOOMANYPARENS
23:50:07 <copumpkin> "20 km/s has been achieved with small projectiles explosively injected into the railgun"
23:50:17 <copumpkin> not too shabby
23:50:34 <kmc> light gas guns are nice too
23:50:35 <flux> still a bit less than the speed of light.
23:50:39 <ddarius> copumpkin: How fast were they going before the railgun accelerated them?  Also, how many Gs did they experience?
23:50:58 <kmc> the airforce has one that does 7 km/s
23:50:59 <copumpkin> flux: yeah, but I think that's about as fast as most human-made things get, short of particle accelerators
23:51:16 <flux> copumpkin, how about space rockets?
23:51:23 <flux> granted they don't move in atmosphere
23:52:16 <kmc> > iterate ((1:) . scanl (+) 0 . reverse) []
23:52:18 <lambdabot>   [[],[1,0],[1,0,0,1],[1,0,1,1,1,2],[1,0,2,3,4,5,5,6],[1,0,6,11,16,20,23,25,2...
23:52:24 <copumpkin> lol, http://en.wikipedia.org/wiki/File:Railgun_usnavy_2008.jpg
23:52:28 <flux> copumpkin, but yes, pretty fast :)
23:52:30 <copumpkin> ddarius: trying to find a citation on that claim
23:52:33 <kmc> > iterate ((0:) . scanl (+) 1 . reverse) []
23:52:34 <lambdabot>   [[],[0,1],[0,1,2,2],[0,1,3,5,6,6],[0,1,7,13,18,21,22,22],[0,1,23,45,66,84,9...
23:52:42 <kmc> @. oeis run iterate ((0:) . scanl (+) 1 . reverse) [] !! 20
23:52:43 <lambdabot>  Sequence not found.
23:52:51 <danr> copumpkin: doesn't look like a quake 3 railgun... :(
23:52:59 <kmc> > iterate ((0:) . scanl (+) 1 . reverse) [] !! 20
23:53:00 <lambdabot>   [0,1,564955305463544182,1129910610927088363,1694865916390632543,22586484312...
23:53:05 <kmc> > iterate ((0:) . scanl (+) 1 . reverse) [] !! 10
23:53:06 <lambdabot>   [0,1,388871,777741,1166610,1550875,1925933,2287182,2630126,2950480,3244274,...
23:53:55 <copumpkin> danr: the quake 2 one was way better
23:54:59 <frerich> copumpkin: You could get the quake 2 style by setting cg_railstyle to  1
23:55:04 <ddarius> Real gun > complexly filtered light
23:55:29 <ddarius> People need to go back to CRTs.
23:56:25 <ddarius> Though OLEDs will also suffice.
23:56:42 <danr> frerich: really? wow!
23:57:05 <erus`> wow whT?
23:58:10 <frerich> danr: I think so, yes. It might also be cg_oldrail, I forgot. There's a variable for that, in any case.
23:58:54 <copumpkin> wow, max bolingbroke being awesome as usual
