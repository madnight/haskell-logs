00:08:26 <joe6> @hoogle system
00:08:26 <lambdabot> No results found
00:25:53 <mreh> quicksilver: I think i've uncovered a bug in switcherFold
00:26:10 <mreh> i've not looked into it yet, but you can see my code
00:26:17 <yitz> joe6: System.Cmd.system :: String -> IO ExitCode
00:29:32 <mreh> http://hpaste.org/51648 it's taking keyboard input and modelling the velocity of an object as if up and down arrow were the thrusters/brakes
00:36:54 <BobFunk> keep running into a cabal problem with "cannot satisfy -package Cabal-1.10.1.0: "
00:36:58 <BobFunk> am I the only one?
00:40:38 <cwl> haskell-mode of emacs, C-c C-t RET, the result doesnt come out
00:41:08 <mreh> @tell quicksilver http://hpaste.org/51648 Take a look at this, it might be a bug in switcherFold, manifests in the top level switcher which seems to not fold back in the last sample from the behaviour at the time of the switcher event
00:41:08 <lambdabot> Consider it noted.
00:47:15 * hackagebot alex-meta 0.2.0.2 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.2.0.2 (JonasDuregard)
00:52:50 <erus`> @hoogle (a -> m b) -> m a -> m b
00:52:50 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:52:50 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:52:50 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
00:54:07 <erus`> yey i have lazy lists working my my interpreter :D
00:54:29 <erus`> and first class functions, currying, pattern matching
00:55:00 <erus`> and all in less than 200 LOC
00:55:35 <b_jonas> erus`: lazyness in the haskell way, or just lazy lists?
00:56:00 <erus`> i had to re Implement Thunks because some functions can perform IO
00:56:11 <erus`> so everything is wrapped in IO (pretty much)
00:56:34 <erus`> b_jonas: yeah haskell style lazyness
00:57:02 <b_jonas> erus`: nice
00:57:41 <b_jonas> erus`: can you show it to us?
00:57:54 <b_jonas> or maybe I should be asking this on -blah?
00:58:07 <erus`> it doesnt pass source files yet
00:58:18 <erus`> i just set up the intermediate syntax tree in code
00:59:52 <b_jonas> I've never implemented a lazy interpreter
01:00:14 <b_jonas> maybe I should try one day
01:00:15 <hpaste> erus` pasted “syntax tree” at http://hpaste.org/51650
01:00:22 <b_jonas> thanks
01:01:14 <hpaste> erus` pasted “interpreter” at http://hpaste.org/51651
01:02:15 * hackagebot happy-meta 0.2.0.3 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2.0.3 (JonasDuregard)
01:02:17 * hackagebot BNFC-meta 0.2.2 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.2.2 (JonasDuregard)
01:03:20 <b_jonas> hmm, I can't read that abstract syntax tree...
01:03:33 <erus`> il paste that too
01:03:54 <hpaste> erus` pasted “ast” at http://hpaste.org/51652
01:04:43 <b_jonas> no, I mean I can't parse it in my head
01:04:59 <erus`> what part are you stuck on?
01:05:03 <b_jonas> that is, from reading your example syntax tree, I don't see what the meaning of your primitives are
01:05:24 <b_jonas> maybe those declarations will help
01:05:55 <erus`> b_jonas: my lists are tuples like (a, (b, (c, ())))
01:05:57 <ddarius> This is unpleasantly not compositional, also it implements call-by-name and not call-by-need.
01:06:12 <erus`> everything is a number or a tuple
01:06:24 <b_jonas> erus`: okay so far
01:07:25 <b_jonas> I guess I should try to translate my pure functional simple prime sieve to it
01:07:41 <b_jonas> because it's simple and doesn't use anything fancy
01:07:59 <b_jonas> or maybe I'll just wait till you make a parser...
01:08:04 <erus`> yeah i would
01:08:21 <b_jonas> I have its source here: http://www.math.bme.hu/~ambrus/pu/olvashato/t1.olv
01:08:35 <b_jonas> there's a translator to prolog and to standard ml
01:09:14 <b_jonas> hmm...
01:09:33 <b_jonas> I don't get it, why don't I have the translated sources on the webpage
01:10:27 <ddarius> I don't think there's any way for 'putc' to be called except as the top-level expression.
01:11:40 <ddarius> I guess writing the equivalent of matchFst () a = a; matchFst (putc x) e would work.
01:11:57 <erus`> ddarius: putc is an imure function
01:12:06 <erus`> the parser wont let you call it from a pure function
01:12:13 <erus`> so it will be fairly strict
01:13:14 <ddarius> I'm assuming that isn't implemented
01:14:11 <ddarius> I'm also wondering how you'd deal with higher-order functions.
01:16:16 <b_jonas> this is strange...
01:17:11 <b_jonas> so does Value encode a value by name?
01:17:30 <b_jonas> and Expression is a value evaluated to top level?
01:17:43 <b_jonas> no, that can't work...
01:17:52 <b_jonas> because Tuple has [Expression] as arguments
01:18:02 <b_jonas> but Expression has an Application constructor
01:18:09 <b_jonas> now I don't get what all these are supposed to represent
01:22:16 * hackagebot nlp-scores 0.1.0 - Scoring functions commonly used for evaluation in NLP and IR  http://hackage.haskell.org/package/nlp-scores-0.1.0 (GrzegorzChrupala)
01:22:27 <obiwahn> > (\a -> (\b->a+b)) 4 5
01:22:28 <lambdabot>   9
01:23:21 <mauke> > (\a -> (\b -> (+) a b)) 4 5
01:23:22 <lambdabot>   9
01:23:33 <mauke> > (\a -> ((+) a)) 4 5
01:23:33 <lambdabot>   9
01:23:39 <mauke> > (+) 4 5
01:23:40 <lambdabot>   9
01:23:57 <mauke> età!
01:25:16 <ddarius> > 9
01:25:17 <lambdabot>   9
01:25:24 <ddarius> delta!
01:26:00 <mauke> that looks more like beta to me
01:26:46 <ddarius> Beta would require there to be a lambda abstraction, and at any rate you can't add numbers with beta reduction.
01:27:08 <mauke> I can't?
01:27:13 <mauke> damn
01:27:19 <erus`> b_jonas: you can ignore Value because i think i will make Constant and FunctionGroup constructors of Binding
01:27:48 <erus`> every 'value' in source is an expression
01:29:02 <b_jonas> okay
01:29:41 <erus`> ddarius: higher order functions can be passes as Partially applied functions or just an indirection to a binding
01:30:06 <ddarius> erus`: I was referring to your notion of "impure functions."
01:30:32 <erus`> well the interpreter doesn't care about the difference
01:30:53 <erus`> the parser will make sure impure functions are called in the right order
01:31:05 <erus`> using seq or whatever
01:31:11 <ddarius> I was not saying how are you going to implement them, how are you going to guarantee "impure functions" are only called in other "impure functions."
01:31:52 <erus`> because binding have an explicit purity in the real syntax tree. Not in the intermediate representation
01:32:34 <erus`> impure functions are prefixed with 'impure'
01:32:48 <ddarius> And now I'm back to bringing up higher order functions.
01:32:58 <b_jonas> gee, my translator doesn't even parse that prime lister now
01:33:44 <erus`> ah i see
01:34:33 <erus`> well i can sort that out with the type system in the parser i think
01:35:23 <b_jonas> and the error message from the translator doesn't even make sense....
01:35:49 <b_jonas> I think this translator is f'ed up
01:36:21 <Maxdamantus> Int -> Int =| Int
01:36:30 <ddarius> erus`: You could handle it with a type system.  Putting such a thing in the parser seems a bit insane.
01:37:48 <b_jonas> ah, better now
01:37:56 <erus`> thanks for breaking my language ddarius
01:38:02 <erus`> is your mother proud of you?
01:38:35 <b_jonas> I got an ml translation too. apparently I wrote the ml translator later, and didn't test it well.
01:41:04 <b_jonas> here it is: http://hpaste.org/51653
01:46:24 <b_jonas> hmm, this primes example doesn't even need a let statement or algebraic pattern matching
01:46:46 <b_jonas> erus`: tell me when you have "if" conditionals and basic arithmetic working and then I'll try to translate this code
01:47:08 <erus`> b_jonas: you can make if with pattern matching and equals
01:47:16 <erus`> i need to go back to drawing board now though
01:47:27 <erus`> because you can pass impure functions to pure functions
01:47:32 <erus`> and this is bad
01:48:57 <b_jonas> erus`: this doesn't need impure functions at all
01:49:11 <b_jonas> it just has a function that returns the list
01:54:50 <erus`> oh man
01:57:08 <erus`> i guess i do need purity in the IR code
01:57:19 <erus`> only for bindings
01:57:31 <erus`> and then purity for values in the interpreter
01:57:36 <erus`> solved
02:05:28 <b_jonas> erus`: tell me if you have the pure part all working (I don't need the impure, nor a parser), then I'll try to translate the simple prime lister then the complicated prime parser
02:05:37 <b_jonas> s/prime parser/prime finder/
02:05:50 <b_jonas> though they might not fare well with call by name
02:06:12 <b_jonas> I wonder if I should try to translate them to my simple lisp interpreter
02:06:14 <erus`> call by name?
02:07:15 <erus`> ah i see
02:07:16 <b_jonas> erus`: by "call by name" I mean that if a function uses its parameter n times then the interpreter will reevaluate the expression passed as argument n times
02:08:00 <erus`> errr i will cache results of pure functions but that is a little while away
02:08:35 <b_jonas> well, I think the simple prime lister should work this way too, at least for small values
02:08:43 <b_jonas> so it could work for testing the interpreter
02:09:35 <erus`> gimme a few days i should have a rudimentary parser up
02:09:46 <b_jonas> but I don't need a parser
02:09:53 <b_jonas> I already have a parser for this code
02:10:00 <b_jonas> I just need to make it write anything I want
02:10:12 <b_jonas> so I can make it write haskell source for whatever syntax tree representation you are using
02:10:12 <erus`> oh
02:10:23 <erus`> go for it then
02:10:28 <erus`> i will be back in about an hour
02:10:31 <erus`> walking to work
02:10:34 <erus`> bb
02:14:31 <rostayob> https://github.com/ghc/ghc/commit/3db757241ce7fb99c096c30481aefa86bb9855a1
02:22:17 <jpcooper> while editing a .lhs file in emacs with haskell-mode, how do I toggle a region between text and code?
02:29:35 <^angel^> هشششششششششششششششششش_تع_تع_
02:31:38 <^angel^> People want execution the President ^_^
02:32:15 <^angel^> [13:27:51] <^angel^> People want execution the President ^_^ «---
02:32:41 <mauke> ^angel^: hello. do you want to talk about Haskell?
02:33:02 <^angel^> What haskell
02:33:07 <^angel^> ^_^
02:33:20 <mauke> er, how did you find this channel?
02:33:41 <^angel^> From google
02:33:41 <^angel^> France
02:33:41 <^angel^> Italia
02:33:41 <^angel^> Sverige
02:33:41 <^angel^> United Kingdom
02:33:41 <^angel^> iPhone
02:33:41 <^angel^> Nintendo
02:33:42 <^angel^> Ubuntu
02:33:42 <^angel^> Top programming chat
02:33:43 <^angel^> rooms by users
02:33:43 <^angel^> 1. #haskell
02:33:44 <^angel^> 767 users
02:33:44 <^angel^> 2. #hitz.tv
02:33:45 <^angel^> 535 users
02:33:50 <hnsz> oh dear
02:33:50 <mauke> argh
02:33:55 <mauke> stop pasting into the channel
02:34:06 <^angel^> You how ask
02:34:07 <quicksilver> well if you want to talk about programming in haskell, stick around
02:34:08 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
02:34:20 <quicksilver> otherwise, perhaps, choose an alternate chat room :)
02:34:44 <quicksilver> @messages
02:34:45 <lambdabot> mreh said 1h 53m 40s ago: http://hpaste.org/51648 Take a look at this, it might be a bug in switcherFold, manifests in the top level switcher which seems to not fold back in the last sample from the
02:34:45 <lambdabot> behaviour at the time of the switcher event
02:35:58 <^angel^> Bey
02:35:59 <applicative> jcooper, C-c C-> adds bird tracks, I don't know how you delit though
02:36:06 <^angel^> !-
02:36:19 <quicksilver> @tell mreh you expect me to make sense of something with unsafePerformIOs layered inside Events? I'm surprised you know what time even means any more.
02:36:19 <lambdabot> Consider it noted.
02:37:23 <applicative> jpcooper, rather
02:38:33 <quicksilver> applicative: delete with rectangle commands maybe? C-x r k
02:40:14 <hpaste> “Mukesh Tiwari” pasted “Quick Check Tesing” at http://hpaste.org/51654
02:40:17 <b_jonas> I thought you just selected the block and filter it through sed 's/^> //'
02:40:42 <b_jonas> filter region is the only command you need in an editor
02:40:49 <mauke> did you mean :s/^> /
02:41:04 <hpaste> “Mukesh Tiwari” annotated “Quick Check Tesing” with “Quick Check Tesing (annotation)” at http://hpaste.org/51654#a51655
02:41:05 <b_jonas> mauke: they asked about emacs, but yes
02:41:20 <mauke> you can probably run vim in an emacs buffer?
02:41:27 <b_jonas> mauke: lol
02:41:35 <keep_learning> hello all
02:41:39 <b_jonas> I don't know, I don't even have emacs installed
02:42:03 <b_jonas> I mean, seriously, I even have some kde and gnome apps on this machine, but so far I didn't need to install emacs
02:42:05 <keep_learning> I am trying to generate data using sized but getting compiler error .
02:42:15 <mauke> C-x C-c vim RET is the only emacs command I know
02:42:17 <quicksilver> b_jonas: yes, that works too, but rectangle commands can do things which are quite hard to do in sed.
02:42:31 <b_jonas> quicksilver: true
02:43:03 <applicative> quicksilver: It's C-x r k is just killing text, hm
02:43:32 <quicksilver> applicative: it can kill a rectangular region such as the "> " rectangle
02:43:34 <quicksilver> I thought that's what you wanted
02:44:51 <applicative> quicksilver, no jpcooper asked about moving from literate to unliterate and back. So I mentioned C-c C-> which adds bird tracks (in my incompetent setup)
02:45:26 <applicative> oh i get it, I called removing bird tracks "delit" ing
02:45:54 <quicksilver> is removing bird tracks something different from deleteing the left-most two columns?
02:46:09 <applicative> somewhere, that's the word ghc uses for stripping literacy from the file
02:49:23 <hpaste> “Mukesh Tiwari” annotated “Quick Check Tesing” with “Quick Check Tesing (annotation)” at http://hpaste.org/51654#a51656
02:50:13 <hpaste> “Mukesh Tiwari” annotated “Quick Check Tesing” with “Quick Check Tesing (annotation) (annotation)” at http://hpaste.org/51654#a51657
02:50:52 <keep_learning> I missed the data constructor but now i am getting new error
02:53:12 <applicative> keep_learning: what is sized?
02:53:54 <keep_learning> applicative:  sized is function from QuickCheck module
02:54:09 <keep_learning> applicative: but this is my first time with quickcheck
02:54:21 <applicative> I see your paste now
03:02:11 <keep_learning> applicative: any idea . I am not getting this error
03:03:31 <mreh> yo
03:03:31 <lambdabot> mreh: You have 1 new message. '/msg lambdabot @messages' to read it.
03:04:28 <quicksilver> keep_learning: the third parameter to your Index constructor
03:04:32 <quicksilver> keep_learning: it is an IntMap of Indexes.
03:04:50 <quicksilver> keep_learning: "arbIndex" just generates an Index, not an IntMap of Indexes
03:05:32 <rostayob> Monoid instances for Bool with mappend = and and mempty = False or mappend = or and mempty = True are both valid right?
03:05:56 <applicative> keep_learning: Index :: Float -> [Int] -> IntMap Index -> Index but in liftM3 Index arbitrary arbitrary ... you are putting an Gen Index thing in the last position not a Gen (IntMap Index)
03:05:57 <applicative> oh, like quicksilver said
03:05:57 <quicksilver> rostayob: yes.
03:06:00 <mreh> quicksilver: did you see the one with the ticker in unsafePerformIO?
03:06:13 <rostayob> quicksilver: ok, so I guess they're not defined already because of the ambiguity
03:06:20 <b_jonas> rostayob: yep, in fact you can have such instances for any Bounded Ord
03:06:29 <quicksilver> mreh: I saw one paste from you. I couldn't work out what you were trying to do with the unsafePerformIOs
03:06:44 <mreh> quicksilver: don't worry about, it probably didn't know what I was doing
03:07:17 <keep_learning> quicksilver: should i write liftM3 Index arbitrary arbitrary (  liftM IntMap.fromList ( arbIndex ( div n 2 ) ) )
03:07:19 <b_jonas> rostayob: except, I think you mean mconcat = and, or mconcat = or
03:07:27 <mreh> quicksilver: I was being lazy
03:07:38 <rostayob> b_jonas: well I meant mappend = (&&) and mappend = (||)
03:07:47 <quicksilver> mreh: perhaps, but you were also shifting around the times that things happen
03:07:48 <rostayob> but yeah and in haskell :: [Bool] -> Bool
03:08:01 <quicksilver> mreh: parts of Reactive stuff may be evaluated at surprising times
03:08:16 <quicksilver> unsafePerformIO seems like a bad plan
03:08:27 <mreh> quicksilver: are we talking about Events or just values?
03:08:44 <applicative> keep_learning: so I think you want to keep that line as it is, but rewrite the first two lines so that they return Gen (IntMap Index) ??
03:09:43 <applicative> keep_learning: no I take that back, I see why you mentioned sized
03:09:55 <knoc> I made this algebraic data type: data Foo = Fi | Fa | Fu deriving (Show, Enum, Eq, Ord)
03:10:32 <knoc> is there some way, with pred and succ, to go through all value constructors of that type without raising *** Exception: pred{Priority}: tried to take `pred' of first tag in enumeration
03:10:37 <rostayob> b_jonas: yeah but if we define for Ord a, Bounded a, why isn't Bool instantiated?
03:10:49 <rostayob> since Ord a and Bounded a are in a similar situation anyway
03:10:57 <b_jonas> rostayob: huh?
03:11:17 <rostayob> mempty = minBound, mappend = max and mempty = maxBound, mappend = min
03:11:53 <rostayob> oh, those aren't defined either. ok
03:12:52 <b_jonas> also, those two monoids for bool are implemented as wrappers in the ghc library Data.Monoid
03:13:02 <quicksilver> knoc: no, you need Bounded too for that.
03:13:09 <quicksilver> knoc: Enum doesn't know about bounds.
03:13:30 <applicative> knoc, pred and succ wont work, try e.g. pred False and pred True
03:13:30 <b_jonas> though the general wrappers for (Bounded a, Ord a) => a isn't in that library, I think you could write it
03:13:41 <rostayob> b_jonas: oh right, Any and All. cool
03:13:45 <knoc> uh, thats right ;)
03:13:49 <rostayob> yeah you could have Max and Min or something like that
03:13:50 <quicksilver> > [minBound .. maxBound] :: [Bool]
03:13:52 <lambdabot>   [False,True]
03:13:58 <quicksilver> > [minBound .. maxBound] :: [Word8]
03:13:59 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
03:14:01 <quicksilver> etc.
03:14:16 <knoc> quicksilver: yeah, thats exactly what I thought of
03:14:22 <keep_learning> applicative: liftM3 Index arbitrary arbitrary ( liftM IntMap.fromList $ arbIndex $ div n 2 ) is also not working
03:14:22 <knoc> cool thing ;)
03:14:26 <applicative> but predd Fi = Fu; pred x = pred x and likewise for succc Fu = Fi ; succc x = succ, so to say
03:14:47 <applicative> div n 2 isn't a list, keep_learning
03:15:56 <quicksilver> keep_learning: because fromList expects a List.
03:16:00 <quicksilver> keep_learning: not an Index
03:16:21 <applicative> wait that's not the thing to say, keep_learning sorry.
03:16:42 <b_jonas> a what?
03:16:47 <b_jonas> @hoogle Index
03:16:47 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
03:16:48 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
03:16:48 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
03:17:16 <quicksilver> b_jonas: see his paste.
03:17:19 <quicksilver> b_jonas: it's his type.
03:17:27 <b_jonas> oh
03:18:28 <erus`> are all the talks at ICFP going to be recorded?
03:19:03 <b_jonas> erus`: I doubt
03:19:40 <erus`> :(
03:20:10 <quicksilver> lots of the 2010 ones were
03:20:10 <quicksilver> http://vimeo.com/album/1468571
03:21:10 <hpaste> applicative annotated “Quick Check Tesing” with “Quick Check Tesing (annotation) (annotation) (annotation)” at http://hpaste.org/51654#a51658
03:21:24 <applicative> keep_learning: does this seem right ^^^ ?
03:23:45 <applicative> no it's wrong, keep_learning, it compiles though. I'm having a little trouble focussing )
03:23:58 <rostayob> yesterday I asked on #scala about typeclasses and we ended up talking about haskell anyway, and a guy was saying that a lot of haskell standard type classes were flawed; specifically he complained about the fact that there is only Monoid but no semigroup, and that applicative functors aren't necessarely pointed
03:24:12 <keep_learning> applicative: yes , it compiled
03:24:57 <hpc> rostayob: both good points, but there is a semigroup class in a package somewhere on hackage
03:25:07 <quicksilver> except they're not really very good points
03:25:21 <applicative> keep_learning: but it defeats the purpose, no? we are trying to get arbIndex to cover all three cases of Index in the right proportions, no,
03:25:25 <quicksilver> when was the last time you heard a programmer writing a real haskell program say "If only we had a Semigroup class"
03:25:29 <quicksilver> ?
03:25:38 <simon> I've got type Foo = State Bar, and I'm unsure how to express a constructor for Foo.
03:25:46 <rostayob> quicksilver: yes, that was my objection as well, but having SemiGroup m => Monoid m would do no harm
03:26:09 <quicksilver> rostayob: it would do a minor piece of harm, it would make writing instances harder
03:26:10 <rostayob> I was just curious if it is considered a "problem" here
03:26:11 <int-e> quicksilver: From people like edwardk? :)
03:26:15 <keep_learning> applicative: yes i think because its not using the third parameter if i understood it correctly
03:26:38 <quicksilver> int-e: well I was halfway through typing - btu deleted it to replay to rostayob - that I'm very grateful for all edwardk's work on his class hiearchies
03:26:41 <simon> ah, never mind.
03:26:47 <quicksilver> and it's great that they're gaing some traction
03:26:51 <rostayob> quicksilver: why "harder"? it'd be the same but there would be two instances instead
03:27:07 <quicksilver> but the absence of a standard Semigroup class is not one of the top 10 problems in using haskell as a programming language.
03:27:15 <quicksilver> rostayob: more lines to type. That's all.
03:27:21 * hackagebot HCodecs 0.2.1 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.2.1 (GeorgeGiorgidze)
03:27:23 * hackagebot HROOT 0.6.2 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.2 (IanWooKim)
03:27:25 <rostayob> quicksilver: specifically, 1 line more :P
03:27:41 <quicksilver> rostayob: yes. It's not a big problem. But it does explode a bit if you refine your typeclasses in every possible way.
03:28:15 <b_jonas> rostayob: it does become harder if you define mconcat instead of defining (mempty, mappend)
03:28:21 <int-e> quicksilver: I got your point :), and I actually agree. And if this process leads to ghc implementing class aliases at some point in the future, many people will profit.
03:28:25 <rostayob> yeah I agree, the fact that monad isn't Applicative m => Monad m or that you can't instantiate Monad or whatever for classes with constraint on the contained type is more annoying
03:28:53 <int-e> quicksilver: (and default instances for superclasses, I guess.)
03:29:20 <b_jonas> int-e: "class aliases"?
03:29:51 <b_jonas> int-e: don't we already have defaults that work only for a more restricted type, as an extension in ghc
03:30:11 <rostayob> anyway it was funny going to #scala and being told that, with a link to this http://code.google.com/p/scalaz/
03:31:28 <b_jonas> the problem with numeric towers is that I have no idea what a good numeric "tower" would have to look like. I was thinking a lot of it, but I can't figure out a good way. (tower in a broad sense. it could have a different shape.)
03:31:37 <rostayob> I thought that category theorist were confined to haskell :P
03:32:54 <b_jonas> I'm not a category theorist. And I don't think you could define such an instance for me either.
03:33:17 <int-e> b_jonas: do we? I admit that I don't know every ghc extension. class aliases were a proposal to combine, say, Num and Show into a single alias so that type signatures do not explode when the granularity of type classes is refined.
03:33:39 <b_jonas> int-e: let me look it up
03:33:43 <keep_learning> applicative: i am out of idead to make third argument IntMap Index . Could you just give me hint  how to solve this ?
03:33:45 <b_jonas> also, I should really install a new ghc these days
03:34:47 <b_jonas> int-e: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/type-class-extensions.html#class-default-signatures
03:34:58 <b_jonas> int-e: provided I understand that correctly
03:40:28 <int-e> b_jonas: Interesting. But I wonder if you could also do that in the other direction -- providing that implementation of 'enum' together with the Generics class rather than with Enum. (So you can define a new type class, note that it's derived from Enum (so you make Enum a superclass), but also note that Enum can actually be implemented in terms of the methods that you require. (As is the case with Functor and Monad)
03:45:52 <magicman> It would be nice to allow superclass method definitions as part of an instance declaration. Not sure how that would work out type-technically.
03:45:59 <keep_learning> any one ? how to solve my problem . i am  out of ideas :(
03:56:39 <mreh> quicksilver: I don't mean to be a pain, but I've got strange problems coming out of my ears with this reactive stuff :S
03:56:55 <mreh> I appreciate what you've done though, it's great
03:58:24 <quicksilver> you're not a pain but I can't promise to solve all your problems :)
03:59:19 <mreh> quicksilver: who else is interested in what you've done?
03:59:48 <mreh> I don't want to burden you with all my questions
04:00:18 <quicksilver> there is a reactive mailing list
04:00:25 <quicksilver> nobody talks on it but you could break the trend :)
04:01:48 <frerich> Oh I know such people. In three years somebody will google and find your lonely posting in the archives, thinking "Wow. That guy must've been desperate alright!"
04:03:44 <matthiasgorgens1> @djinn (Monad m) => (m a, m b) -> m (a,b)
04:03:44 <lambdabot> -- f cannot be realized.
04:04:40 <hpc> djinn doesn't monad
04:04:57 <quicksilver> hpc: except for bizarre special cases.
04:05:07 <quicksilver> @djinn Monad m => a -> m a
04:05:08 <lambdabot> f = return
04:05:10 <Botje> :t uncurry (liftM2 (,))
04:05:12 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
04:07:37 <mreh> i've got this keyboard sink sending events supposedly when the user presses keys, but I'm seeing thousands of events per second
04:08:17 <Botje> your user is a millipede?
04:08:20 <mreh> i'm mapping a trace over the events themselves
04:08:31 <mreh> the use is me :)
04:08:40 <mreh> i am not
04:08:51 <mreh> bah, this is beyond my knowledge for now
04:14:38 <DevHC^> preflex: zdec zomg
04:16:10 <metatagg> where should i go if i wonder about haskell-mode for emacs?
04:17:42 <hpaste> applicative annotated “Quick Check Tesing” with “Quick Check Tesing (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/51654#a51662
04:18:58 <b_jonas> I should add a let builtin (or something similar) to my mini lisp interpreter because it's hard to use like this
04:19:25 <b_jonas> then I can implement lists directly in its language and translate the prime lister or something
04:19:32 <applicative> keep_learning: sorry, I vanished.  It's simpler than it seemed, you just use the arbitrary instance for IntMap Index, which you already had
04:20:26 <applicative> keep_learning, I'm not sure it's correct though, you'd have to think about it, or experiment....
04:21:17 <keep_learning> applicative: ok , i am not sure if i got you
04:21:38 <keep_learning> applicative: but i am trying till now
04:21:53 <applicative> did you see the paste?  the fateful line is just liftM3 Index arbitrary arbitrary arbitrary
04:22:08 <keep_learning> applicative: yes
04:22:12 <applicative> that is the same as with the other ones
04:23:13 <applicative> and intuitively what was wanted.
04:24:08 <keep_learning> applicative: you mean some thing like  frequency [ ( 1, liftM IndexEmpty arbitrary ) , ( 1 ,  liftM2 IndexLeaf arbitrary arbitrary ) , ( 1 , liftM3 Index arbitrary arbitrary arbitrary    ) ]
04:24:27 <b_jonas> hmm, or maybe I can't implement lists all in the language because I want them to print in some useful way
04:24:59 <keep_learning> applicative: oh , you already pasted
04:25:07 <keep_learning> applicative: i tried this one
04:25:19 <keep_learning> but getting the same infinite list
04:25:33 <applicative> does it give the wrong results?
04:26:41 <keep_learning> no it does not give wrong result
04:27:02 <keep_learning> applicative: but  i think its generating the same infinte data
04:27:25 <applicative> wait so the instance Arbitrary (IntMap a) is wrong ?
04:28:17 <keep_learning> applicative: i am not sure because its the first time , i am using quickcheck to debug the code
04:28:53 <b_jonas> gee, this interpreter is horrible
04:28:55 <b_jonas> did I really write this?
04:29:42 <keep_learning> applicative: i think its not diving the Index into two smaller halfs
04:29:59 <hpaste> applicative annotated “Quick Check Tesing” with “Quick Check Tesing (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/51654#a51663
04:30:26 <keep_learning> I saw similar approach in the paper A lighthweight tool for  random testing for Haskell programmers
04:31:38 <applicative> grr, I see, this is annoying
04:31:38 <keep_learning> applicative: where defined data type was data (Tree a ) = Leaf a | Branch ( Tree a ) ( Tree a )
04:32:21 <applicative> did you notice the (commented) Arbitary Instance in Data.IntMap?
04:32:52 <keep_learning> applicative: in the paper , Instance Arbitrary a => Arbitrary ( Tree a ) where arbitrary = sized arbTree
04:33:12 <kizzx2> what's the most convenient way to use base-4.4.0.0 for now? should i build from source?
04:33:31 <keep_learning> applicative: and now they defined arbTree 0 = LiftM Leaf arbitrary
04:34:47 <applicative> kizzx2, i'm using one of the dubious binaries for ghc-7.2.whatever, it comes with base-4.4 and many other libraries.
04:35:07 <kizzx2> applicative: where did you get that?
04:35:14 <keep_learning> applicative: arbTree n = frequency [ ( 1 , liftM Leaf arbitrary ) , ( 4 , liftM2 Branch ( arbTree $ div n 2 ) ( arbTree $ div n 2 ) ) ]
04:35:15 <applicative> get what?
04:35:15 <kizzx2> (i'm on Arch Linux)
04:35:36 <kizzx2> ghc7.2.whatever
04:35:47 <kizzx2> it seems my distro only has GHC 7.0.3
04:35:58 <hpc> kizzx2: from the haskell website
04:36:02 <keep_learning> applicative: now my problem is i am not able to divide the arbIndex n into smaller parts
04:36:24 <keep_learning> applicative: hope you are not getting angry on me for this many annoying questions
04:36:31 <kizzx2> hpc: ok, short and to the point :P
04:38:41 <hpc> http://www.haskell.org/ghc/download_ghc_7_2_1.shtml
04:38:44 <applicative> kizzx2: I'm using a macbook; someone kindly builds binaries http://www.haskell.org/ghc/download_ghc_7_2_1
04:38:56 <applicative> like hpc said
04:39:52 <b_jonas> the problem with my interpreter is that it represents functions as functions
04:39:55 <b_jonas> so it's hard to debug
04:40:35 <b_jonas> they should be represented as either (tag to a built) or (pair of code and environment)
04:41:01 <keep_learning> applicative: any idea ?
04:41:21 <b_jonas> maybe I should change that later
04:41:27 <b_jonas> but first I'm changing other stuff
04:44:51 <keep_learning> applicative: sorry , i saw your paste now
04:46:29 <applicative> oh i see, I thought you were criticizing.  I assume it makes the mistake you meant, liftM3 Index arbitrary arbitrary arbitrary doesn't work properly?
04:47:21 * hackagebot monadfibre 0.1.2.1 - Monadic functions which provide Choice and Parallelism.  http://hackage.haskell.org/package/monadfibre-0.1.2.1 (AnupamJain)
04:49:09 <cwl> @src quotRem
04:49:09 <lambdabot> Source not found. It can only be attributed to human error.
04:49:17 <cwl> @src (quotRem)
04:49:17 <lambdabot> Source not found. You type like i drive.
04:51:11 <keep_learning> applicative: its not working.  Its again generating infinte data set . Is it possible to break arbIndex n in the terms of lower n .
04:52:59 <keep_learning> applicative: a lightweight tool for random testing of haskell programs . http://www.google.com/url?sa=t&source=web&cd=1&sqi=2&ved=0CCcQFjAA&url=http%3A%2F%2Fwww.eecs.northwestern.edu%2F~robby%2Fcourses%2F395-495-2009-fall%2Fquick.pdf&ei=4y57TpaXAaOYiAef_K0G&usg=AFQjCNEE1zkp36dRTdmaQWvS1nUQVo3Ffg&sig2=ldqmvfdy5-Op2ZwQ-vofQg
04:58:49 <cwl> did you tried emacs haskell-mode, C-c C-i blocked
04:59:04 <cwl> I have to C-g and get no result
05:01:43 <BobFunk> is there any good library around for getting metadata from common filetypes? (width/heigtht of images, duration of audio, etc) ?
05:05:21 <hpc> BobFunk: there's libraries for each individual one; there's a hell of a lot of image and audio formats
05:05:38 <hpc> don't think there's one in haskell that can deal with them all
05:07:01 <saml> how would you implement dispatching based on regex and String?
05:07:34 <saml> if Strnig matches regex, you call some function. but there are many regex. would you iterate through the list of regexes?
05:07:50 <chrisdone> anyone got a function for encoding strings to be passed to a program in a shell?
05:07:51 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
05:08:02 <saml> can you compile a list of regexes to state machine with multiple terminal states?
05:10:12 <quicksilver> you can, yes.
05:10:43 <saml> what's algorithm?
05:12:13 <quicksilver> you probably want to annotate nodes by which alternatives could possibly have lead to that node
05:12:19 <quicksilver> I'm not sure, I've never thought about it before.
05:31:43 <BlankVerse> how to get the name of a function ?
05:32:22 <BlankVerse> i have a function say getFuncName which takes a function as arguments and returns the function name instead of the function value
05:32:52 <Axman6> that can;t be done in haskell
05:32:54 <Axman6> can't*
05:33:06 <BlankVerse> Axman6: y?
05:33:26 <hpc> BlankVerse: is this for debugging or something? those sorts of questions are usually answered with "adjust your design"
05:33:35 <Axman6> because haskell has no introspection. also it's not exactly something many people need (if any at all)
05:34:03 <BlankVerse> hpc: not for debugging ... i want to write to a file with the name of the function called ...
05:34:35 <saml> BlankVerse, maybe you need template haskell
05:34:36 <Saizan> are there languages which will give you the name of an arbitrary function parameter? and do they just conjure something up for lambdas?
05:34:37 <hpc> BlankVerse: i recommend something like:
05:34:38 <BlankVerse> i have a list of functions and i want to write the result of every function to its own file
05:34:39 <hpc> foo x y = ...
05:34:44 <hpc>   where name = "foo"
05:34:57 <hpc> or something
05:34:58 <Axman6> you would use a list of pairs: type FuncList = [(Int -> String, String)]
05:35:09 <hpc> or that
05:35:23 <Axman6> BlankVerse: then you'
05:35:39 <Axman6> you'll have to write the names of the functions as strings with the functions
05:36:02 <BlankVerse> Axman6: thats not DRY !!!
05:36:39 <Baughn> "Ambiguous module name: Prelude" <- Well, maybe I should switch back from the git version, just for now.
05:36:45 <Axman6> BlankVerse: how would you so this in C? or C++? (without the use of the C preprosessor)
05:37:11 <mux> __func__
05:37:17 <mux> (that's C99)
05:37:31 <quicksilver> mux: it's a C preprocessor feature though, isn't it?
05:37:40 <Axman6> yeah
05:37:42 <ClaudiusMaximus> you can use CPP in Haskell too
05:37:42 <quicksilver> It's a preprocessor feature mandated by C99.
05:37:45 <mux> quicksilver: I don't think the standard requires it to be a CPP feature
05:37:51 <quicksilver> mux: perhaps not.
05:38:06 <mux> I didn't check but it would make sense; you only want something called __func__ that will yield a string after all
05:38:09 <Axman6> ClaudiusMaximus: not to get the name of a function, and you can't produce strings using # when using Haskell
05:39:15 <ClaudiusMaximus> ah.
05:39:54 <mux> quicksilver: I just read on extract from the C99 standard and as far as I can see, it only talks about a "predefined identifier" and doesn't necessarily tie it to the preprocessor
05:40:00 <quicksilver> mux: *nod*
05:40:50 <quicksilver> It doesn't really violate DRY it just appears to, because the symbol for a function is arbitrary and a string name is concrete
05:40:54 <Axman6> BlankVerse: if there was such a function that could take any arbitrary function and give you its name, what would its type be? and what would it do if you have it (\x y -> x + y)?
05:41:12 <quicksilver> renaming functions isn't supposed to change program semantic.
05:41:14 <quicksilver> s.
05:41:31 <BlankVerse> Axman6: got it
05:42:03 <Axman6> gave*
05:43:19 <ClaudiusMaximus> i'd probably end up using  zipWith f [func1, func2, func3] $ words "func1 func2 func3"  and hope any edits don't make the lists out of sync, because writing lists of tuples though better is somewhat verbose,,,
05:44:43 <Axman6> funcs = [\n\t(f1, "f1"),\n\t(f2, "f2")\n\t...]
05:44:44 <EvanR-work> ClaudiusMaximus: note that we, at least in normal systems, spend a vast minority of the time initially writing the code
05:44:53 <EvanR-work> and most of it fixing the broken code
05:44:58 <EvanR-work> repeatedly
05:45:06 <EvanR-work> so if its more verbose but more reliable do that
05:46:25 <joe6> @hoogle preprocessSources
05:46:25 <lambdabot> No results found
05:46:34 <Saizan> also, you can define a ==> b = (a,b) or something like that
05:47:27 <ClaudiusMaximus> EvanR-work: my coding style is "write once" because by the time i get around to actually maintaining something i've thought of 3 more designs that make much more sense and restructure the whole thing :(
05:47:49 <EvanR-work> yeah, in haskell
05:47:57 <EvanR-work> but that doesnt fly in php land ;)
05:48:00 <quicksilver> I can't imagine why anyone would prefer to write [func1, func2,func3] $ words "func1 func2 func3" rather than [("func1",func1),("func2",func2),("func3",func3)]
05:48:03 <EvanR-work> rewriting everything is too painful
05:48:21 <joe6> does anyone where I can find this preprocessSources, distribution.simple.preprocess does not seem to cut it.
05:48:35 <mreh> nothing is more dangerous than an existing and half working code base
05:48:40 <Axman6> quicksilver: less finger gymnastics, but that's a small price to pay in the long run
05:49:24 <hpc> quicksilver: for one, it doesn't typecheck
05:49:26 <EvanR-work> Axman6: in order to edit it later, seems like way more brain gymnastics
05:49:33 <hpc> i assume you wanted to zip the two
05:49:38 <quicksilver> hpc: it does typecheck in context
05:49:46 <quicksilver> hpc: substrings are not subexpressions in haskell :)
05:50:00 <metatagg> when i try to find-file a .hs file in emacs, i get an error 'Wrong type argument: stringp, nil'. how do i get rid of it?
05:50:08 <quicksilver> hpc: there was a zipWith f in ClaudiusMaximus's original comment that I was replying to.
05:50:50 <hpc> ah nvm then
05:52:36 <joe6> http://codepad.org/kcyegj6F, URxvt*scrollTtyOutput:      false
05:52:36 <joe6> URxvt*scrollWithBuffer:     true
05:52:36 <joe6> URxvt*scrollTtyKeypress:    true
05:52:44 <joe6> sorry, about that paste
05:52:47 <joe6> a mistake
05:52:55 <EvanR-work> eww urxvt
05:53:46 <Nimatek> urxvt is a pretty neat terminal.
05:53:59 <EvanR-work> xterm baby
05:55:04 <Nimatek> Except that it is slow and has limited functionality.
05:56:02 <rostayob> Xfce's terminal
05:56:05 <rostayob> or roxterm
05:56:24 <rostayob> I don't get why people don't like VTE based terminals
05:57:47 <Eidel> How can i concatenate two IO-functions? Need to do this: sequence_ [ printRow(k) ++ putStr "\n" |k <- row]
05:59:37 <chra> Eidel: s/++/>>/ ?
05:59:50 <Axman6> liftM2 (++) (printRow k) (putStr "\n")
05:59:58 <Axman6> or something
06:00:02 <Cale> errr
06:00:04 <Cale> wat
06:00:05 <Axman6> depends what you're actually trying to do
06:00:33 <ClaudiusMaximus> @undo do { a ; b }
06:00:34 <lambdabot> a >> b
06:00:37 <Cale> putStr "\n" :: IO (), so he must just want to execute it after
06:00:52 <Cale> do printRow k; putStr "\n"
06:01:09 <Axman6> or just printRow k >> putStrLn ""
06:01:11 <Axman6> >_>
06:01:22 <Cale> Yeah
06:01:31 <Eidel> Cool.
06:02:21 <Eidel> Worked like a charm. :) Did not know that >> worked in haskell
06:02:22 * hackagebot SableCC2Hs 0.0.0.1 - Generate a parser (in Haskell) with the SableCC parser generator.  http://hackage.haskell.org/package/SableCC2Hs-0.0.0.1 (MarcFontaine)
06:03:23 <Axman6> Eidel: it has nothing at all to do with >> in C++, don't get confused
06:03:44 <Cale> Eidel: yeah, x >> y is the same thing as x >>= const y and also the same thing as do x; y
06:03:46 <Eidel> Axman6: No, but bash
06:03:56 <Cale> Oh, it's also not the same as in bash :)
06:04:05 <Eidel> O_o
06:04:07 <Cale> :t (>>)
06:04:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:04:08 <Axman6> >> for IO in C++ is an abomination, >> in haskell is just sequencing two monad actions where you don't care about the result of the first action
06:04:14 <ClaudiusMaximus> :t ( (>), (>>), (>>>) )
06:04:15 <lambdabot> forall a (m :: * -> *) a1 b (cat :: * -> * -> *) a2 b1 c. (Ord a, Monad m, Control.Category.Category cat) => (a -> a -> Bool, m a1 -> m b -> m b, cat a2 b1 -> cat b1 c -> cat a2 c)
06:04:21 <Axman6> it has nothing to do with Bash either
06:04:23 <Cale> ClaudiusMaximus: rofl
06:04:38 <hpc> Eidel: action1 >> action2 = "do action1, then action2, and return the result of action2"
06:05:05 <hpc> Eidel: but don't take that to be the complete story; it's a gross oversimplification and you need to learn more :P
06:05:10 <Axman6> Eidel: what are you using to learn Haskell?
06:05:29 <Eidel> hpc: So if i did have like a String as return value, the first string would be thrown away?
06:05:40 <Axman6> yes
06:05:44 <dmwit> :t [liftM2 (>), (>>), (>>>)]
06:05:45 <lambdabot> forall (cat :: * -> * -> *). (Monad (cat Bool), Control.Category.Category cat) => [cat Bool Bool -> cat Bool Bool -> cat Bool Bool]
06:05:48 <Eidel> Axman6: http://learnyouahaskell.com/input-and-output and a college course
06:06:06 <Axman6> ok
06:06:42 <Axman6> well, >> is not an IO thing. it's definition is a >> b = m >>= \_ ->
06:06:58 <dmwit> wut
06:07:16 <Cale> Eidel: There's also >>= which is like >> except that instead of throwing away the result of the first action, it passes that result to a function that it gets on its right
06:07:19 <dmwit> >> is an IO thing, and also a thing for many other type constructors. Its definition is a >> b = a >>= \_ -> b
06:07:19 <Axman6> Eidel: we can help you more if we know what the type of printRow is
06:07:38 <Cale> and gets the second action to run by applying that function to it
06:07:55 <Eidel> Axman6: printRow returnes IO (). But i dont need any more help
06:07:55 <dmwit> s/is/is often/
06:08:02 <Cale> For example... getLine >>= putStrLn  will get a line of text and print it out again
06:08:08 <Axman6> dmwit: my distinction was that it's not at all related to >> in bash
06:08:09 * frerich wishes he could remember who on this channel compared monadic values with Runnables in Java, that was the single most enlightening shift of point of view I had on this topic.
06:08:33 <Cale> frerich: Well, perhaps IO values
06:08:53 <Axman6> fritschy: sounds like an odd analogy
06:09:15 <Eidel> Is it a bad solution to use an IO function inside another IO function?
06:09:25 <Cale> (Anyone else find it mildly annoying when people say "monadic" when they mean "IO"? :)
06:09:36 <imphasing|home> I've got a suspicion that IEnumerable is a monad in C#.. or at least the pattern
06:09:44 <Cale> Eidel: no, IO actions are intended to be composable
06:09:52 <imphasing|home> Seems like standardized function composition, if I'm not misunderstanding monads again
06:10:03 <Cale> Eidel: You will generally build your program up from lots of small ones.
06:10:27 <Cale> imphasing|home: If that's the LINQ thing, you're probably right.
06:10:39 <frerich> Cale: I actually didn't think of IO but anything which can be executed and chained together
06:10:40 <Eidel> Cale: yes seems like im on the right path then..
06:11:09 <Cale> frerich: Well, perhaps... though do lists really fit into that picture in Java? :)
06:11:10 <imphasing|home> Cale: Yeah, linq. It's basically composable "lists" with lots of standard functions for organizing the data processing pipeline
06:11:19 <frerich> Cale: ("executed" in the Haskell sense, contrasting "evaluated")
06:11:39 <frerich> Cale: A Java list is a Runnable? I didn't know that.
06:11:51 <Cale> frerich: Lists form a monad.
06:12:10 <dmwit> I think Cale's point is that Runnable is not a good analog to Monad because lists are not Runnable, but lists do form a Monad.
06:12:17 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
06:12:18 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
06:12:32 <dibblego> IEnumerable supports SelectMany which is akin to Haskell's (>>=)
06:12:42 <dibblego> Java's Runnable is just like IO () and is not a monad
06:12:52 <Cale> There are a bunch of Haskellers working on Microsoft's programming languages now :)
06:12:59 <Cale> Notably Erik Meijer
06:13:21 <Cale> (whose name is also on the Haskell report iirc)
06:14:07 <simon> that's great. maybe eventually that wealth of information will propagate out of microsoft. ;-)
06:15:41 <Cale> Well, not to mention that Simon Peyton Jones and Simon Marlow are both at Microsoft Research now :)
06:16:29 <imphasing|home> MS research is pretty awesome :)
06:16:45 <imphasing|home> F#'s looking cooler and cooler these days
06:16:52 <Peaker> Cale: Oh, I had a very low opinion of C#, then I read some of Erik's explanations about C#'s new features, and I thought: "Woah, a knowledgeable dude is working on C#".. Now that explains everything...
06:17:08 <Peaker> (C# seems to have been designed by ignorants in its beginning though)
06:17:23 <imphasing|home> C# was designed to be the Java that Java never was
06:17:25 <dibblego> C# only had to be one step ahead of Java
06:17:47 <imphasing|home> Luckily, it's like 4 steps ahead. Real generics, lambdas, etc
06:18:10 <imphasing|home> It's slightly less noun-oriented than java at least
06:22:22 * hackagebot HandlerSocketClient 0.0.3 - Haskell implementation of a HandlerSocket client (API).  http://hackage.haskell.org/package/HandlerSocketClient-0.0.3 (XingboWu)
06:26:23 <kizzx2> how do you do something like this in TH?
06:26:23 <kizzx2> makeInt :: String -> Q [Dec]
06:26:23 <kizzx2> makeInt name = [d| type $(name) = Int |]        --- syntax error, hopefully conveys what i mean
06:27:28 <Axman6> so you want to be able to have makeInt "Foo" -> type Foo = Int?
06:27:34 <kizzx2> yeah
06:27:40 * Axman6 wishes he knew...
06:28:05 <kizzx2> i have makeInt label = return [TySynD (mkName label) [] (ConT (mkName "Int"))] but wondering if i could use the QQ notation
06:30:07 <simon> kizzx2, I'm not sure what Q is, but assuming it's a datatype you have defined, isn't there a constructor for integers within this datatype?
06:30:18 <rostayob> simon: he means quasi quoting
06:30:24 <rostayob> ah, Q
06:30:30 <rostayob> Q is TH monad
06:30:34 <imphasing|home> oh god haskell has quasiquoting? :O
06:30:39 <imphasing|home> Like in Scheme?
06:30:42 <buntfalke> Hi
06:30:52 <BlankVerse> function to convert integer to string?
06:31:07 <buntfalke> Positive import selection: What's the use of this "The list may be empty, in which case nothing except the instances is imported."?
06:31:12 <imphasing|home> Doesn't Show let you do that, BlankVerse?
06:31:12 <rostayob> imphasing|home: I don't about scheme, but in haskell quasi quoting is this: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/template-haskell.html
06:31:16 <nlogax> > show 1
06:31:17 <lambdabot>   "1"
06:31:55 <imphasing|home> rostayob: Interesting.. is this a haskell or a GHC feature?
06:31:59 <rostayob> imphasing|home: GHC
06:32:17 <kizzx2> buntfalke: suppose a module has `instance Show Foo`. if you don't want construct Foo, but only show it
06:32:23 <Axman6> buntfalke: so you can do import Data.Maybe () and get any instances that are declared for Maybe in that module that isn't exported by the Prelude
06:33:45 <buntfalke> kizzx2: Thanks!
06:34:12 <rostayob> kizzx2: why is that QQ piece invalid anyway? I'm pretty sure I wrote something like that
06:34:44 <rostayob> well it should be $(mkName label) probably
06:34:54 <rostayob> in the QQ
06:35:03 <buntfalke> Axman6: Sure, I just wondered about some use case though... :-)
06:35:05 <rostayob> but it should work
06:35:06 <kizzx2> rostayob: 12 col 26 error|  Malformed head of type or class declaration: $(mkName label)
06:35:13 <imphasing|home> Is there a numerical type that already has Num, Ord and Enum? Or do I have to constrain like (Num a, Ord a, Enum a) ?
06:35:19 <imphasing|home> I thought Num would be an Ord and Enum
06:35:22 <imphasing|home> But I guess not :(
06:35:43 <matthiasgorgens1> @djinn (Monad m, Monad n) => (m (n a), m (n b)) -> m (n (a,b))
06:35:43 <lambdabot> -- f cannot be realized.
06:35:51 <rostayob> kizzx2: mhm. I'm not sure why.
06:35:52 <imphasing|home> This is the function: thirdPowers n = sum $ takeWhile (<n) $ map (^3) [0..]
06:35:55 <Axman6> @src Num
06:35:56 <lambdabot> class  (Eq a, Show a) => Num a  where
06:35:56 <lambdabot>     (+), (-), (*)           :: a -> a -> a
06:35:56 <lambdabot>     negate, abs, signum     :: a -> a
06:35:56 <lambdabot>     fromInteger             :: Integer -> a
06:36:13 <Axman6> numbers don't necessarilly need Enum do they?
06:36:21 <imphasing|home> For the infinite list, I need enum though
06:36:26 <Cale> imphasing|home: Num already has enough spurious superclass constraints thanks ;)
06:36:26 <imphasing|home> I guess?
06:36:41 <Cale> (Eq and Show are totally excessive)
06:36:46 <imphasing|home> That function doesn't work as just thirdPowers :: (Num a) => a -> a though :/
06:37:00 <imphasing|home> I need the Ord and Enum to compare and use the infinite list it seems?
06:37:14 <kizzx2> rostayob: the thing you wrote was [e| ... |] (or simply [| ... |]), as in          `cnst n x = [| \_ -> $(cnst (n-1) x) |]`?
06:37:17 <Cale> You need Ord for < and you need Enum for the [0..]
06:37:18 <Peaker> Num is such a horrible class
06:37:24 <kizzx2> rostayob: the $() thing does work expectedly in that case
06:37:29 <Cale> Num isn't *that* horrible.
06:37:38 <Peaker> IMO it makes no sense that signum and abs are   (a -> a)
06:37:48 <Cale> It just needs to drop those two constraints, and signum and abs need to be split into another class
06:37:52 <imphasing|home> Cale: So the right type signature is thirdPowers :: (Num a, Ord a, Enum a) => a -> a like I had it?
06:37:52 <rostayob> kizzx2: so the problem is only when trying to generate top level declarations?
06:38:02 <Peaker> Cale: and abs needs a different type
06:38:09 <Peaker> Cale: probably a different class
06:38:22 <Cale> imphasing|home: Yeah, I guess.
06:38:29 <kizzx2> rostayob: yeah... and GHC doc says "A splice is written $x, where x is an identifier, or $(...), where the "..." is an arbitrary expression. "
06:38:30 <Cale> Peaker: well... maybe.
06:38:42 <Axman6> someone suggested a while ago that classes should only have single functions in them. seems to solve a lot of these problems (though, you then get large constraints on functions)
06:38:46 <kizzx2> rostayob: so i guess it's intentionally rejecting $(mkName label)
06:38:54 <Peaker> abs on a Complex a  should yield an a     and not another Complex a
06:39:04 <rostayob> kizzx2: what do you mean "intentionally rejecting"?
06:39:11 <Axman6> > abs (1 :+ 1)
06:39:12 <lambdabot>   1.4142135623730951 :+ 0.0
06:39:22 <kizzx2> rostayob: well i mean that's probably doucmented :P
06:39:26 <Peaker> Axman6: Constraint kinds seem like they're half/third-way towards class aliases in this sense..
06:39:29 <Cale> > signum (5 :+ 5)
06:39:30 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
06:39:35 <Cale> ^^ that makes sense
06:39:45 <rostayob> kizzx2: ah, I don't see how "mkName label" is a bad expression
06:39:47 <Peaker> Axman6: maybe you could have a Num-like constraint type that unifies a bunch of different constraints
06:39:49 <hpc> Cale: the unit vector in the direction of (5, 5) :D
06:39:58 <kizzx2> :t mkName "Yeah"
06:39:59 <lambdabot> Not in scope: `mkName'
06:40:02 <matthiasgorgens1> @djinn Monad m => (m a, m b) -> m (a,b)
06:40:03 <lambdabot> -- f cannot be realized.
06:40:10 <kizzx2> :t Language.Haskell.TH.mkName "Yeah"
06:40:11 <lambdabot> Language.Haskell.TH.Syntax.Name
06:40:17 <rostayob> kizzx2: maybe it has to be an Exp? I don't know :P
06:40:17 <imphasing|home> Whoa new syntax for me: \l@(x:xs) -> (x,length l) .. I'm guessing this is pattern matching in a lambda? l would be bound to the whole list, then x:xs to the head and tail?
06:40:21 <Peaker> Cale: so:   signum x = x / abs x   ?
06:40:22 <hpc> i wish Complex CReal didn't have ridiculous crash conditions, so i can use it for my IRC bot's calculator
06:40:27 <Cale> Peaker: yeah.
06:40:27 <rostayob> kizzx2: maybe it has to be in Q? try newNAme
06:40:29 <kizzx2> rostayob: yeah that's what i was thinking
06:40:40 <Peaker> (with special-case of 0 of course)
06:40:43 <Cale> Or: signum x * abs x = x
06:40:55 <Cale> To only use things available in Num :)
06:40:56 <kizzx2> rostayob: same thing
06:40:57 <Axman6> Peaker: yeah. and have a more clear heirarchy. so maybe you'd have class Add a where (+) :: a -> a -> a, Mul a ... then class (Add a, Mul a, Div a) => Num a or somesuch
06:41:11 <Peaker> Axman6: did you read the blog post about the new constraint kinds?
06:41:12 <kizzx2> i guess the error message "Malformed ..." suggests the [d| ... |] notation does not recognize $() at all
06:41:23 <Axman6> Peaker: no, i have no idea what they are =)
06:41:33 <Peaker> Axman6: a new ghc extension now allows:  type Num a = (Add a, Mul a, Div a)
06:41:40 <Axman6> ooo, nice
06:41:44 <Peaker> Axman6: and you get: Num :: Constraint
06:41:57 <rostayob> kizzx2: I don't know, there must be some problem with that, and it's bee a while since I've used TH
06:42:14 <Peaker> (a new kind called 'Constraint' for types, in addition to all the *-based kinds)
06:42:15 <Axman6> is that a type or a kind? or...?
06:42:19 <Axman6> ok
06:42:22 * hackagebot HsOpenSSL 0.10.1.1 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.1.1 (MasatakeDaimon)
06:42:34 <Cale> It makes sense to have a class for types of numbers with an internal signum function.
06:42:37 <dmwit> imphasing|home: Yes, exactly.
06:42:40 <Axman6> Peaker: it's not Num :: * -> Constraint?
06:42:41 <Cale> (and put abs in that class)
06:42:49 <imphasing|home> Awesome, thanks :)
06:42:59 <Peaker> Axman6: Yeah, you're right, I think :)
06:42:59 <dmwit> class Add a b c where add :: a -> b -> c
06:43:02 <dmwit> lollerskates
06:43:09 <Peaker> Axman6: given I've never used it, I'm not exactly sure
06:43:09 <Axman6> excellent, that makes more sense
06:43:17 <kizzx2> rostayob: where did you learn about it when you last used it?
06:43:30 <kizzx2> rostayob: resources on the net are mostly outdated and many are stuck in the rudimentary Printf example elvel
06:43:32 <Cale> But yeah, that's different from normed vector spaces, etc.
06:43:38 <Cale> :t magnitude
06:43:39 <lambdabot>     Ambiguous occurrence `magnitude'
06:43:39 <lambdabot>     It could refer to either `Data.Complex.magnitude', imported from Data.Complex
06:43:39 <lambdabot>                           or `Data.VectorSpace.magnitude', imported from Data.VectorSpace
06:43:41 <Peaker> Axman6: that seems to mean all Constraint kinds are always at least *->Constraint, and I don't seem to recall if that was the case.. need to go back to that blog
06:43:45 <Cale> :t Data.Complex.magnitude
06:43:46 <lambdabot> forall a. (RealFloat a) => Complex a -> a
06:43:59 <rostayob> kizzx2: the original paper describing it and the haddock documentation for reference
06:44:21 <Axman6> dmwit: would you need to have fundeps or something then making sure you didn't have multiple add definitions for the same types or something?
06:44:24 <rostayob> kizzx2: there are a number of notions to be aware of when generating splices, so it's likely that i'm missing something now
06:44:40 <Axman6> hmm, you can't add fundeps to an instance delcaration can you
06:44:58 <dmwit> Axman6: Yeah, you'd probably rather want class Add a b where type Result a b; add :: a -> b -> Result a b
06:45:47 <Axman6> so, class Add a b c where add :: a -> b -> c; instance Add Int Int Int | a -> b,b -> a, a -> c, c -> a add = (+)
06:45:52 <Axman6> or something...
06:45:57 <Axman6> obviously that makes no sensew
06:46:00 <Axman6> -w
06:46:19 <dmwit> No, if you really want fundeps, I think the right thing would be class Add a b c | a b -> c
06:46:19 <Axman6> dmwit: hmm, how would you use that? for say Int, and for Complex?
06:46:27 <Axman6> yeah
06:46:32 <dmwit> Axman6: The associated types one?
06:46:38 <Axman6> yeah
06:46:48 <hpc> Peaker: using the report, they would all be :: x -> Constraint, where x :: Sort
06:47:00 <dmwit> Axman6: Like this: instance Add Int Int where type Result Int Int = Int; add (I# a) (I# b) = I# (primAddInt# a b)
06:47:13 <Axman6> ah, that would work
06:47:43 <Axman6> then... instance Add Char Int where Result Char Int = Char add = ... >_>
06:47:46 <Axman6> :P
06:47:53 <dmwit> >_<
06:47:57 <Axman6> XD
06:49:23 <kizzx2> rostayob: is the "original paper" somethign like "Why it's nice to be quoted?"
06:49:25 <dmwit> instance Add a b => Add (Complex a) (Complex b) where type Result (Complex a) (Complex b) = Complex (Result a b)
06:49:42 <Axman6> that works
06:49:48 <Axman6> that is kinda cool...
06:49:59 <Cale> I think it's good to be able to assume that the arguments to and result of (+) all have the same type.
06:50:01 <qubodup> hello
06:50:03 * Axman6 wonders is that is what Haskell++ would look like
06:50:07 <Cale> qubodup: hello
06:50:11 <dmwit> Cale: Yeah, it was mostly a tongue-in-cheek suggestion. =)
06:50:11 <qubodup> can I make ghc tell me what it optimizes an how?
06:50:27 <Axman6> Cale: in the case of add yeah, but in the case of abs maybe not
06:50:30 <kizzx2> qubodup: -ddump-simpl?
06:50:34 <Cale> qubodup: You can get it to print out the generated intermediate code with --ddump-simpl
06:50:37 <dmwit> qubodup: You might be interested in the -ddump flags. More info in the manual.
06:50:43 <Cale> and there's another flag for stats on what rules were fired
06:50:47 <Axman6> qubodup: look at the ghc-core tool on hackage too
06:50:56 <Peaker> hpc: what's the type of Sorts? :)
06:51:04 <Peaker> Value :: Type :: Kind :: Sort :: ?
06:51:18 <Cale> er, -ddump-simpl, and -ddump-simpl-stats
06:51:18 <rostayob> kizzx2: http://haskell.org/wikiupload/c/ca/Meta-haskell.ps
06:51:20 <Axman6> it gives you a dump of all rules that fires, the core after optimisation and the assembly produced
06:51:40 <Peaker> It could have been a good idea to call "Kinds"   Type1's   so then you could have Type2's, etc..
06:51:42 <dmwit> Peaker: Luckily, we still only have one sort.
06:51:46 <rostayob> kizzx2: note that the current implementation differs in a lot of details from the one described in that paper
06:51:47 <Cale> Yeah, ghc-core just uses those flags to GHC, and colourises the output
06:51:48 <dmwit> Peaker: So we don't need to classify sorts (yet).
06:52:17 <Peaker> dmwit: we have 4 levels though, 4 is pretty arbitrary
06:52:58 <dmwit> Yes it is.
06:53:08 <dmwit> No more arbitrary than two, though.
06:54:29 <Peaker> dmwit: slightly more arbitrary :)
06:55:25 <Peaker> dmwit: I guess two is some local optimum/sweet-spot for simplicity/bang-for-buck.. and 3 perhaps a different local optimum.. 4 is stretching it (given that Haskell rarely needs the Sort level?)
06:55:50 <dmwit> I really don't know what that sentence means.
06:56:29 <rostayob> kizzx2: I don't think there is a solution, see http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
06:56:40 <rostayob> kizzx2: under "Too strongly typed"
06:57:15 <dmwit> You just think two is less arbitrary because you've seen more systems that have two levels than you have systems that have four. But a good computer scientist counts in trinary: 0, 1, many.
06:57:31 <rostayob> kizzx2: basically the problem is that you can generate invalid declarations, but I would expect that to be legal anyway and then fail when trying to type check the generated splice
06:57:50 <rostayob> "All this is quite annoying. Several users have said "I'm just using a quotation as a convenient way to build a syntax tree. Please don't even try to typecheck it; just wait until it is finally spliced into a top-level splice"."
06:57:52 <Cale> 4 is a pretty magical number too though :3
06:57:58 <dmwit> (And I'd wager that most of the two-level systems you've seen are actually three-leveled, in the same sense Haskell is four-leveled and not three-leveled: there are well-formed and not-well-formed types.)
06:58:03 <rostayob> kizzx2: so yeah right now you're stuck with the manual declaration.
06:58:04 <Cale> All the small numbers have special things about them
06:58:19 <Cale> (not that it really makes sense here)
06:58:33 <Cale> I think it's reasonable for now though.
06:58:35 <EvanR-work> large numbers dont?
06:58:36 <rs46> There exists a cabal --prefix=/foo/bar install pkg ... why does there not exist a cabal --prefix=/foo/bar update  ?
06:59:11 <dmwit> rs46: Because cabal update doesn't install any packages?
06:59:14 <Cale> EvanR-work: Most large numbers end up being pretty unspecial, in that we stop knowing interesting things about them.
06:59:22 <rs46> I want 2 separate cabal directories: .cabal32 .cabal64
06:59:26 <rs46> when I run
06:59:30 <Cale> also, they start to become unrepresentable eventually :)
06:59:46 <rs46> cabal --prefix=/foo/bar install pkg ...
06:59:57 <EvanR-work> Cale: so we dont know the interesting things about them ;)
07:00:11 <rs46> does it look at the package database in $HOME/.cabal
07:00:11 <rs46> ?
07:00:12 <dolio> What are the levels in question? Value, type, kind?
07:00:20 <dmwit> rs46: I really don't think --prefix changes which .cabal directory it looks in.
07:00:22 <Cale> Yeah, but also the interesting things are less interesting, generally.
07:00:27 <dmwit> rs46: Yes, I think so.
07:00:33 <rs46> Oh
07:00:36 <rs46> ok thanks
07:00:37 <dmwit> rs46: Or rather, no.
07:00:56 <EvanR-work> Cale: why, because theres a smaller number with the same property?
07:00:59 <dmwit> rs46: It looks at the cache of the package repository in $HOME/.cabal.
07:01:05 <dmwit> rs46: But there's no package database in $HOME/.cabal.
07:01:23 <dmwit> (The package  database is somewhere in $HOME/.ghc or wherever the compiler you're using puts it.)
07:01:25 <EvanR-work> Cale: i suggest all numbers are interesting: http://en.wikipedia.org/wiki/Interesting_number_paradox ;)
07:01:39 <rs46> aah right,
07:01:49 <rs46> let me see if I can get this working, thanks dmwit
07:02:12 <dmwit> (And notice that the package itself and the package database need not be colocated.)
07:02:26 <dmwit> (So there really are a lot of moving parts involved.)
07:02:33 <Cale> EvanR-work: Well, it's not in an absolute yes/no sense that they're interesting or not
07:03:31 <Cale> EvanR-work: It's the proportion of useful properties of each length that the numbers appear in.
07:05:08 <Cale> Smaller numbers are more likely to come up in minimal examples of easily described things
07:05:24 <Cale> Probably some information-theoretic reason for ti
07:05:26 <Cale> it*
07:06:15 <EvanR-work> in what sense are 'too big' numbers not representable?
07:07:22 <dmwit> ?google complexity theory philosophical implications
07:07:23 <lambdabot> http://en.wikipedia.org/wiki/Emergence
07:07:23 <lambdabot> Title: Emergence - Wikipedia, the free encyclopedia
07:07:35 <dmwit> http://www.scottaaronson.com/blog/?p=103 was what I was thinking of
07:07:41 <dmwit> EvanR-work: You may find that cute. =P
07:08:48 <EvanR-work> lol
07:09:07 <Cale> EvanR-work: Eventually they're large enough that even if we marshalled all the matter in the observable universe into storage media, we wouldn't be able to encode a property that they satisfy.
07:09:19 <Cale> Er, uniquely, rather
07:09:28 <EvanR-work> uhm. thats fairly offensive
07:10:09 <EvanR-work> maybe i asked for it by not explicitly saying that the mathematics idea im talking about is not related in some way to physics
07:11:05 <Cale> Well, almost all natural numbers are too large to be described in that sense
07:11:16 <Cale> It's not a fundamental mathematical thing of course
07:11:32 <dmwit> It can be made mathematical.
07:11:36 <Cale> But it puts limitations on what we can find out.
07:11:44 <EvanR-work> theres 'definable numbers' but i dont know if its meaningful
07:11:54 <Cale> Well, all natural numbers are definable
07:11:57 <dmwit> For almost all n, the program which outputs n has Kolmogorov complexity greater than m.
07:12:02 <Cale> Most real numbers aren't definable though.
07:12:22 <Cale> In the sense that there's no property which they satisfy uniquely.
07:12:24 <EvanR-work> ok so naturals are safe from that tyranny ;)
07:13:00 <Cale> (there are only countably many properties)
07:13:33 <EvanR-work> well reals and uncountable are fairly mystic ;)
07:13:39 <JoeyA> "Bangkok can be seen as an example of spontaneous order"  lol
07:16:31 <Cale> EvanR-work: Well, it's good to allow in some extra things which we can't describe directly in this case, because it makes the second order properties of the reals so much nicer.
07:17:17 <poucet> Cale: Maybe real numbers are not proper pure math, but simply a tool for physics which tries to model the real world instead of sticking the absolute and pure
07:17:47 <EvanR-work> seems proper
07:18:10 <poucet> EvanR-work: real numbers or my statement?
07:18:31 <EvanR-work> if youre ok with infinite countable, then allowing an infinite sequence of digits seems necessary
07:18:53 <EvanR-work> the possible instances of which isnt countable
07:19:06 <poucet> EvanR-work: I am not sure I agree. Simply because you can implement that doesn't mean it's porper pure math.  See the difference between type systems and the actual code
07:19:27 <EvanR-work> what makes it improper
07:19:46 <poucet> And even if you were to allow an infinite sequence of numbers, why should we attach to it the semantics of how a real number is interpreted.
07:19:47 <Cale> poucet: That seems silly to me :P
07:20:04 <Cale> poucet: Real numbers are not physically realistic in a lot of ways
07:20:09 <poucet> Namely that 3.3 means 3 + 3*10^-1
07:20:15 <poucet> Cale: Good point :)
07:20:24 <Cale> But they're perfectly valid formally definable things
07:20:37 <Cale> as a set :)
07:20:41 <poucet> Cale: I thought you just said that most of them are not definable
07:20:42 <EvanR-work> i hope Cale doesnt attempt to use empirical science to deny real numbers ;)
07:20:57 <Cale> Most of the members of that set are not individually definable
07:21:01 <Cale> But the set itself it
07:21:02 <Cale> is*
07:21:17 <poucet> Cale: Even then, newtonian mechanics is not reality.  But it is still beneath the purity of the abstract math
07:21:47 <EvanR-work> QM people dont have a clue whats going on
07:21:54 <EvanR-work> dont let them fool you
07:21:56 <Cale> EvanR-work: Of course the same empirical stuff I said applies to real numbers too. Most of them (even most of the definable real numbers) still have definitions which are too long for us to write down.
07:22:02 <poucet> EvanR-work: I almost mentioned QM before, but refrained
07:22:15 <Cale> But that's not a problem.
07:22:22 * hackagebot linda 0.1 - LINear Discriminant Analysis  http://hackage.haskell.org/package/linda-0.1 (LennartSchmitt)
07:22:34 <EvanR-work> Cale: writing them down or not doesnt have any bearing on this
07:22:54 <Cale> On what?
07:22:56 <poucet> Cale: Maybe real numbers that are not definable by a finite formula don't really exist
07:23:03 <EvanR-work> whether reals are realistic
07:23:27 <poucet> EvanR-work: The world is integral, everything is measured in planck lengths :)
07:23:38 <EvanR-work> that attitude is so infuriating
07:23:43 <EvanR-work> i hate pop QM
07:23:52 <Cale> poucet: What do you mean by "don't really exist"?
07:24:07 <EvanR-work> yeah, since when do numbers exist or not
07:24:20 <poucet> Cale: You assume the existence of real numbers that are not definable in finite formula.  How do you know they even exist.  That the set of Real numbers even contains
07:24:23 <poucet> those
07:24:30 <Cale> poucet: Of course if we can't write down a formula uniquely describing a real number, we can't write down a formula which says that it doesn't exist.
07:24:39 <Cale> So I can't see how that makes any sense mathematically.
07:24:45 <leod> they exist by definition
07:24:59 <poucet> Cale: How can you know they are part of the real set then if you don't know what they are
07:25:01 <EvanR-work> by fiat ;)
07:25:17 <Cale> poucet: That's what we're assuming of them.
07:25:25 <poucet> So it's like God, we just assume
07:25:36 <Cale> poucet: Everything in mathematics is the same way
07:25:47 <Cale> Mathematics isn't a science, it's not empirical.
07:25:49 <poucet> Cale: Afaict, most of mathematics is defined throuh axioms
07:25:55 <imphasing> axioms ARE god in math
07:25:56 <Cale> Yes, exactly.
07:26:05 <Cale> The natural numbers are the same way.
07:26:09 <poucet> But if we can't formulate a real number with finite formula, how can we do that with finite axioms
07:26:11 <Cale> Don't be fooled.
07:26:16 <poucet> And if we can not, do they really exist in that system?
07:26:31 <EvanR-work> this is finitist dogma
07:26:33 <tac-tics> I prefer working with axiom-less systems where you must assume your axioms in the premise of everything you say
07:26:34 <keep_learning> benmachine: hi
07:26:38 <poucet> I guess I'm coming from the (forgot the term) angle
07:26:46 <poucet> intuitionistic?
07:27:20 <Cale> Well, okay. Are you okay with there being a set of natural numbers?
07:27:26 <poucet> Yes
07:27:34 <Cale> Are you okay with every set having a powerset?
07:27:35 <poucet> And I can define them all
07:27:38 <EvanR-work> infinite sequence of digits makes more sense than additioanlly requiring some sort of algorithm for producing the digits, or some logical statement about them
07:27:50 <EvanR-work> and excluding the rest
07:27:50 <Cale> (maybe no?)
07:27:51 <poucet> Cale: Constructively. yes
07:27:59 <Cale> poucet: Constructively?
07:28:02 <imphasing> Infinite infinites, real numbers are derived from natural numbers like natural numbers are derived from nothing?
07:28:09 <poucet> Cale: Constructive logic, yes, powerset should exist
07:28:19 <Cale> poucet: If you admit that the natural numbers have a powerset, then you've already lost :)
07:28:27 <Cale> Because they're isomorphic to the reals as a set.
07:28:42 <Cale> (sets of naturals)
07:28:47 <poucet> You're missing the point
07:28:53 <EvanR-work> imphasing: nothing doesnt exist! trollface
07:29:04 <Cale> am I? :)
07:29:14 <imphasing> derived from the axioms we assume to exist then :P
07:29:14 <Cale> Most sets of natural numbers aren't definable
07:29:15 <poucet> How do you know that numbers that can not be defined in finite formula are in the set isomorphic to the poewrset of naturals
07:29:30 <tac-tics> EvanR-work: Yo dawg, I heard you like infinities...
07:29:47 <imphasing> cardinality is so cool
07:29:53 <Cale> There are uncountably many sets of natural numbers, but only countably many descriptions of sets of natural numbers.
07:29:57 <EvanR-work> ordnality ;)
07:30:25 <imphasing> I was talking about naturals vs reals, both inifnite but one "more infinite" than the other..
07:30:28 <imphasing> Just seems awesome :)
07:30:53 <dolio> How do you know that they're more infinite?
07:31:03 <Cale> It seems perfectly okay to me that we can reason about some things collectively even if we can't talk about them all individually.
07:31:06 <tac-tics> imphasing: Cardinality is OK I guess.
07:31:11 <Cale> dolio: Diagonal argument.
07:31:16 <dolio> Cale: Wrong.
07:31:16 <tac-tics> imphasing: At the end of the day, they're both kinda "just infinite"
07:31:17 <simon> poidh!
07:31:23 <imphasing> dolio: There's more reals than naturals
07:31:24 <EvanR-work> attaching some significance to infinite mappings
07:31:27 <imphasing> In a sense
07:31:29 <Cale> What?
07:31:37 <dolio> Downward Lowenheim-Skolem.
07:32:10 <poucet> Cale: there's uncountably mainy sets of natural numbers?
07:32:11 <EvanR-work> might need to check the meaningfulness of infinite mappings
07:32:11 <Cale> dolio: That just means there's a countable model.
07:32:17 <poucet> Cale: not in constructive logic, right?
07:32:17 <tac-tics> There's also more ways to spell Dijkstra than there are to spell Haskell, but I never found it particularly interesting :)
07:32:23 <imphasing> There's an infinite number of reals between every natural number, with an infinite number of naturals.. set of reals seems "bigger" in that sense
07:32:54 <Cale> poucet: Suppose you give me an enumeration of all the sets of natural numbers as a function N -> P(N)
07:32:54 <EvanR-work> imphasing: well that doesnt differentiate the reals from the rationals
07:33:04 <EvanR-work> and theres countable rationals
07:33:47 <imphasing> rationals are just a combinations of natural numbers though
07:33:51 <imphasing> Same cardinality as naturals
07:34:01 <EvanR-work> yes but theres an infinite number between each natural, but its not more infinite
07:34:03 <dolio> Cale: It means that the common interpretation of the diagonal argument as proving the reals are "bigger" is a leap, even in classical mathematics.
07:34:29 <imphasing> EvanR-work: That's why I said "in a sense", cardinality exists for a reason :)
07:34:33 <imphasing> It comes in handy
07:34:34 <EvanR-work> imphasing: same thing as an infinite 2d grid, it might seem like theres more grid points than naturals but no
07:34:43 <Cale> poucet: I can construct a set of natural numbers which isn't in your list. Say this function is f: N -> P(N). Then I pick S = {n in N: n not in f(n)}. This set is different from every set in the image of f.
07:34:58 <EvanR-work> imphasing: ordinals numbers have more interesting structure ;)
07:34:58 <imphasing> EvanR-work: That's the same as the set of rationals though, it's derived from naturals, so it would be the same cardinality
07:35:05 <Cale> In particular, it differs from the nth set in that if the f(n) contains n, then it doesn't, and vice versa.
07:35:14 <imphasing> EvanR-work: I haven't really gotten into learning about those yet :)
07:35:17 <EvanR-work> imphasing: its not actually, because (4,2) and (2,1) would be the same rational ;)
07:35:17 <Cale> poucet: Right?
07:35:19 <poucet> Cale: and aren't real numbers isomorphic to infinite sequences of a finite list of digits
07:35:27 <poucet> Cale: So by definition, constructively countable
07:35:28 <tac-tics> Infinity was always too many for me to keep track of.
07:35:33 <tac-tics> I prefer finite, but enormous
07:35:45 <Cale> poucet: Infinite sequences of a finite set aren't countable unless the finite set has 1 element.
07:35:46 <poucet> Cale: Nore sure,
07:36:20 <Cale> poucet: ?
07:36:20 <EvanR-work> what are you guys meaning by isomorphic in this context?
07:36:28 <EvanR-work> field isomorphism?
07:36:38 <Cale> EvanR-work: in bijection with
07:36:39 <EvanR-work> or is there some more general notion
07:36:41 <EvanR-work> oh ok
07:37:06 <poucet> Cale: I'll hvae to think about this more :)
07:37:10 <poucet> I'm a bit out of it today
07:37:17 <EvanR-work> A is bijective to B ;)
07:37:31 <dolio> poucet: The diagonal argument is constructively valid.
07:37:48 <dolio> So there is no constructive isomorphism between the naturals and the constructive reals.
07:38:04 <Cale> dolio: Having a countable model is unsurprising, and tells us nothing internally.
07:38:30 <dolio> Cale: It means you don't know that you're not always talking about countable sets.
07:38:45 <Cale> Depends on what you mean by "countable sets"
07:38:50 <dolio> Meta-countable.
07:39:56 <dolio> Cale: Same situation as people saying that the constructive/computable reals are countable.
07:40:02 <dolio> They're not computably countable.
07:40:05 <Cale> Well, you see, when you form that countable model, you're putting a relation on that countable set (the interpretation of the element-of relation) which *doesn't* correspond with the real element-of relation.
07:40:13 <Cale> (in the outer system)
07:40:14 <poucet> dolio: Ok
07:40:15 <Cale> Yes?
07:40:32 <poucet> dolio: I thought that made intuitively sense, but I don't have enough background
07:40:53 <Cale> and there's no countable model of ZF for which the element-of relation corresponds to the outer element-of relation, obviously
07:42:01 <Cale> You can find a first order model of the ZF or ZFC axioms with only countably many sets, but not a second order model.
07:42:55 <Cale> dolio: The computable reals are countable in ZF
07:43:14 <Cale> dolio: Is what "everyone" means by that :)
07:43:18 <EvanR-work> second order stuff usually sounds pretty signifiantly different from first order, what happens when you go third order ;)
07:43:26 <dolio> And they're computably uncountable.
07:43:54 <EvanR-work> maybe were not ready as a species for that
07:43:55 <Cale> Yeah, but that's a whole other thing :)
07:44:22 <Cale> The meaning of computable countability and ordinary countability is completely different.
07:44:58 <dolio> Yeah. It's what functions you admit.
07:45:04 <Cale> Computable countability is way way way more restrictive.
07:46:20 <Cale> hah, again, there's as many bijections N -> N as there are real numbers, but only countably many of them are computable :)
07:46:20 <poucet> Cale: but more interesting :)
07:46:21 <dolio> The ZF-reals are ZF-uncountable.
07:46:41 <dolio> The computable reals are computably uncountable.
07:46:47 <dolio> The constructive reals are constructively uncountable.
07:46:50 <poucet> dolio: I do not get the last
07:47:07 <poucet> why are constructive reals not countable?
07:47:19 <ClaudiusMaximus> > fromEnum (1.5 :: Double)
07:47:20 <lambdabot>   1
07:47:23 * hackagebot permute 1.0 - Generalised permutation parser combinator  http://hackage.haskell.org/package/permute-1.0 (TroelsHenriksen)
07:47:25 * hackagebot data-inttrie 0.0.5 - A lazy, infinite trie of integers.  http://hackage.haskell.org/package/data-inttrie-0.0.5 (ThomasDuBuisson)
07:47:27 * hackagebot data-memocombinators 0.4.2 - Combinators for building memo tables.  http://hackage.haskell.org/package/data-memocombinators-0.4.2 (ThomasDuBuisson)
07:47:29 <dolio> People always take the first one as being some external truth about there being "more" of something in some real sense.
07:48:06 <Cale> poucet: They're countable, but not constructively countable
07:48:07 <cheater> the first what?
07:48:28 <ClaudiusMaximus> > fromEnum (1e42 :: Double)
07:48:29 <lambdabot>   0
07:48:30 <dolio> Instead of the alternate view that the ZF function spaces are deficient to establish the isomorphism, which they accept for all the others.
07:48:35 <monochrom> "the first one" refers to "The ZF-reals are ZF-uncountable."
07:48:35 <Cale> Let's all use ZFC terminology, since it's pretty standard, and all the concepts we want embed nicely in it ;)
07:48:53 <cheater> ok
07:49:22 <tac-tics> ZFC? What is this #math?
07:49:23 <tac-tics> :P
07:49:39 <ClaudiusMaximus> > [1.5 .. 1e42]
07:49:40 <lambdabot>   [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5,12.5,13.5,14.5,15.5,16.5,17....
07:49:45 <Cale> The real reason most mathematicians use ZFC is not because they necessarily agree 100% with all of its axioms, but because it's a good enough system to share ideas in.
07:50:12 <EvanR-work> ClaudiusMaximus: lol
07:50:16 <tac-tics> Cale:  I was always curious. Why are there no implementations of pure ZFC as programming langauges?
07:50:17 <Cale> Like, I don't really know what to think about the axiom schema of replacement. I don't think I've ever invoked it directly...
07:50:24 <tac-tics> (or are there and I just never heard of them)
07:50:26 <Cale> tac-tics: There are
07:50:48 <simon> ClaudiusMaximus, hehe.
07:50:52 <dolio> It's like Java.
07:50:58 <Cale> Or at least, I'm pretty sure people have done that in most popular theorem provers.
07:50:58 * zachk doesnt think you can run all of zfc on a current computer 
07:51:13 <tac-tics> Cale: Can you give me an example of one :D Or did you use a non-constructive proof?
07:51:22 <tac-tics> Cale: ah, I gotcha
07:51:23 <monochrom> haha
07:51:37 <Cale> http://coq.inria.fr/V8.2pl1/contribs/ZFC.html
07:51:59 <Cale> googling <name of theorem prover> ZFC seems to work
07:52:01 <EvanR-work> lol non constructive proof
07:52:10 <EvanR-work> also "highly non constructive"
07:52:37 <tac-tics> I wonder if there's a Coq implementation of the Princip. Math.
07:53:00 <Cale> Mathematics could probably get by with V = L
07:53:12 <Cale> but that's a different sort of constructability than people usually talk about here :)
07:53:24 <poucet> dolio: how come constructive reals are non countable?
07:53:50 <Cale> poucet: Only inside a system where everything is computable
07:54:36 <Cale> poucet: because the bijection between N and computable reals isn't computable
07:55:52 <dolio> poucet: Diagonal argument is constructively valid.
07:56:15 <dolio> They're ZF-countable if you define them as a subset of the reals in ZF.
07:56:22 <dolio> Well, presumably.
07:56:34 <poucet> So if the diagonal argument is constructively valid, how is that not a computation to enumerate the
07:56:39 <poucet> them
07:57:09 <Cale> poucet: It only shows that any enumeration is incomplete
07:57:11 <dolio> The diagonal argument takes an enumeration N -> R and gives you an R that isn't enumerated.
07:57:15 <monochrom> the diagonal argument says there is no enumeration, rather than says there is some enumeration
07:57:40 <roconnor> I don't think Schröder-Bernstein Theorem is constructive
07:58:32 <poucet> for x, y in diagonal enumeration of N^2: do str(x) + "." + reverse(str(y))
07:58:51 <monochrom> that is unrelated
07:59:09 <poucet> But that is a constructive algorithm for reals
07:59:14 <Cale> poucet: what?
07:59:32 <Cale> That doesn't even get you all the rational numbers
08:00:23 <poucet> Good point
08:03:33 <EvanR-work> which rationals doesnt it get
08:03:42 <monochrom> 1/3
08:03:45 <Blkt> good evening everyone
08:04:11 <EvanR-work> i guess 1/3 is one of those it gets to after infinity ;)
08:05:09 <poucet> EvanR-work: "after" infinity :)
08:05:17 <EvanR-work> yeah, very useful concept
08:05:19 <Cale> It depends on what base we're using
08:05:58 <Cale> For base b, it gives rationals of the form n / b^k
08:06:02 <poucet> EvanR-work: "I'll get back to you on that, ... after infinity"
08:07:23 <poucet> Anyways, enough OT from my side.
08:07:32 <EvanR-work> theres several naive attempts at enumerating the rationals i can think of which get stuck at a premature infinity
08:07:46 <EvanR-work> rather than finding another way just wait it out
08:12:23 * hackagebot NumInstances 1.0 - Instances of numeric classes for functions and tuples  http://hackage.haskell.org/package/NumInstances-1.0 (ConalElliott)
08:12:25 * hackagebot vector-space 0.7.7 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.7.7 (ConalElliott)
08:12:27 * hackagebot vector-space 0.7.8 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.7.8 (ConalElliott)
08:12:46 <Cale> EvanR-work: It's common to show that the rationals are countable by invoking the Cantor-Schroeder-Bernstein theorem that cardinals are totally ordered (which requires the axiom of choice). That way, you only have to find an injection in each direction.
08:13:51 <Cale> An injection N -> Q is obvious, and an injection Q -> N can be obtained by encoding (-1)^k p/q (where p,q are positive) as 2^k 3^p 5^q
08:13:52 <EvanR-work> Cale: wikipedia says "An important feature of this theorem is that it does not rely on the axiom of choice."
08:14:01 <Cale> Er, oh, right
08:14:27 <EvanR-work> maybe the theorem doesnt but the implication for cardinals does
08:14:45 <Cale> There's another part to it before you get equivalence to the axiom of choice
08:14:52 <Cale> (you need cardinals to be comparable)
08:17:09 <Cale> "Cardinals are totally ordered" is equivalent to AC, and CSB is just that the relation is antisymmetric.
08:17:54 <EvanR-work> logical equivalence is a wonderful thing
08:20:27 <copumpkin> EvanR-work: damn right
08:21:23 <EvanR-work> the vast superfluous literature reduced to a handful of logical equivalence classes ;)
08:28:38 <DukeDave> Any cabal hackers around? Specifically anyone who know about building C++ with it?
08:29:44 <DukeDave> I'll just ask: It's used in wxHaskell to build some library code, but every time I issue a cabal build it re-builds all the C++ code, even if none of it has changed, is there some way to just let gcc decide what to rebuild?
08:39:35 <zolidznake> hello people!
08:39:36 <zolidznake> :P
08:41:12 <leod> hello, guy
08:41:21 <zolidznake> hi leod
08:41:27 <zolidznake> i am new to haskell
08:41:35 <zolidznake> where can i start ? :D
08:41:47 <hpc> @where lyah
08:41:47 <opqdonut> @where lyah
08:41:47 <lambdabot> http://www.learnyouahaskell.com/
08:41:47 <lambdabot> http://www.learnyouahaskell.com/
08:41:51 <hpc> lol
08:41:52 <opqdonut> @quote stereo
08:41:53 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
08:41:57 <opqdonut> nice
08:42:00 <leod> yeah, LYAH is a good start
08:42:19 <opqdonut> then
08:42:22 <opqdonut> @quote rwh
08:42:22 <lambdabot> pfpl says: practical foundations of programming languages  http://www.cs.cmu.edu/~rwh/plbook/book.pdf
08:42:28 <opqdonut> I mean,
08:42:30 <opqdonut> @where rwh
08:42:31 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:42:42 <hpc> @where wikibook
08:42:43 <lambdabot> http://en.wikibooks.org/wiki/Haskell
08:42:46 <monochrom> you can play at tryhaskell.org
08:42:56 <hpc> or in ghci
08:43:10 <armlesshobo> is there a way to reduce the size of the compiled executable
08:43:11 <hpc> and if you get stuck...
08:43:12 <armlesshobo> ?
08:43:16 <hpc> @where hpaste
08:43:17 <lambdabot> http://hpaste.org/
08:43:23 <Axman6> araujo: strip it
08:43:28 <Axman6> uh, armlesshobo
08:43:32 <Axman6> sorry araujo, heh
08:43:45 <hpc> there's a SO post that says how
08:44:29 <kizzx2> armlesshobo: i remember the gist of the SO post is to 1) strip and 2) use dynamic linked RTS
08:44:58 <hpc> the runtime isnt that huge, iirc
08:45:16 <hpc> and you dont get the standalone-ness
08:45:37 <armlesshobo> kizzx2: i'm checking it out now :)
08:46:07 <kizzx2> hpc: i guess size is rather subjective.... a stripped "Hello World" is 667KB here
08:47:23 * hackagebot peparser 0.2 - A parser for PE object files.  http://hackage.haskell.org/package/peparser-0.2 (IanGraves)
08:47:33 <monochrom> dynamic linking is not so easy to use
08:48:02 <armlesshobo> kizzx2: wow...i shed about 650k off of the executable by compiling it as suggested on SO lol
08:48:11 <armlesshobo> compiling and stripping it
08:49:35 <hpc> i lose 2MB on each binary for my website
08:49:44 <kizzx2> armlesshobo: just curious, what kind of scenario are you in that you care about the size?
08:49:55 <hpc> makes backups waaaaay faster
08:50:48 <armlesshobo> kizzx2: I'm not in any scenario, I'm just curious
08:51:04 <kizzx2> ook :)
08:51:31 <armlesshobo> kizzx2: i'm very enthusiastic about haskell, having really started learning it a week or two ago. :)
08:52:23 <armlesshobo> kizzx2: and I was just examining the size of the executable of a haskell program and a C equivalent
08:52:56 <kizzx2> heh, it'd be really wonderful if they can be comparable
08:53:06 <kizzx2> the C runtime is a bare one
08:53:20 <hpc> C has a runtime?
08:53:23 <kizzx2> the haskell runtime has a full blown GC + lazy + threads + all
08:53:38 <monochrom> the GHC runtime has a thread scheduler and a garbage collector. go figure
08:54:48 <hpc> wtf is in the C runtime? it cant be anything important
08:55:05 <Axman6> dynamic linker?
08:55:07 <monochrom> the optimizer does intensive inlining to add more code to your code
08:55:21 <hpc> Axman6: ah
08:55:38 <Axman6> i'd count that as part of the runtime anyway
08:55:54 <kizzx2> Axman6: i think dynamic linking is done by the OS, at least in Windows which i dissected thoroughly
08:56:10 <Axman6> it doesn't have to have a runtime (for say a kernel), but within an OS it has things like that
08:56:18 <kizzx2> well C++ sure has a runtime
08:56:27 <Axman6> kizzx2: yes, the runtime for C is the OS it runs under, which provides things like dynamic linking
08:56:29 <kizzx2> i guess C might have a small something that needs to be bootstrapped
08:56:42 <leod> the C runtime maybe has a small function that calls the user-defined main
08:56:45 <kizzx2> in any case i guess it's fair to regard libc as some sort of "runtime" (or overhead) since all C programs use them
08:57:08 <kizzx2> *all* :P
08:57:16 <kizzx2> well you know what i mean
08:58:12 <monochrom> the typical C runtime contains part of the stdio stuff
08:58:34 <kizzx2> and i think the C runtime may need to allocate static variables, depending on where the compiler decides to put them
08:59:39 <kizzx2> yeah, and translating the return code of "main" back to OS speech or something
09:07:04 <trinithis> Why does (1) take linear time, whereas (2) does not?
09:07:06 <trinithis> > let ns = [1..] in fst $ head $ dropWhile (\(n, _) -> n /= 10000) $ zip ns ns
09:07:07 <lambdabot>   10000
09:07:18 <trinithis> > let ns = [1..] in fst $ head $ dropWhile (\(n, _) -> n /= 10000) $ zip ns (Data.List.inits ns)
09:07:22 <lambdabot>   mueval-core: Time limit exceeded
09:07:57 <quicksilver>  inits isn't linear
09:08:02 <quicksilver> inits is quadratic
09:08:08 <trinithis> But haskell has non-strict semantics
09:08:10 <trinithis> I dont use it
09:08:22 <quicksilver> zip uses it
09:08:40 <rwbarton> it doesn't know that ns and thus inits ns is infinite
09:08:45 <quicksilver> zip has to check whether the list is empty or not
09:08:53 <quicksilver> so it forces a certain amount of evaluation
09:09:09 <rwbarton> @src inits
09:09:10 <lambdabot> inits []     =  [[]]
09:09:10 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
09:09:14 <quicksilver> it won't evaluate the actual numbers in the list, but still enough to push the behaviour to quadratic
09:09:26 <trinithis> ok
09:10:16 <quicksilver> you could construct a version of zip which was completely lazy in its right parameter (and produced _|_ if the right lift was shorter than the left)
09:10:30 <quicksilver> but it would be worse for the normal case when you do want the information on the right, I think.
09:10:43 <trinithis> Constant time worse?
09:10:52 <quicksilver> I'm not sure.
09:11:20 <trinithis> What about a zip-like function whose args must both be infinite?
09:11:21 <rwbarton> it seems that it would normally be a lot worse space-wise
09:12:08 <rwbarton> since rather than consuming both lists in parallel, you're consuming the first list while building up a huge thunk that tells you what element to extract from the second list
09:12:35 <quicksilver> rwbarton: yes, but the "second list thunks" could refer to each other.
09:12:47 <quicksilver> rwbarton: so they could at least share most of the hugeness
09:12:55 <quicksilver> but I can't say I've thought it through in detail.
09:13:43 <trinithis> I'll try out a lazier zip and see if it works for my application.
09:14:05 <quicksilver> zip [] _ = []; zip (x:xs) yys = let (y:ys) = yys in (x,y) : zip xs ys
09:14:17 <quicksilver> because lets bind lazily.
09:16:26 <b_jonas> quicksilver: couldn't you just write that as just this?  zip [] _ = []; zip (x:xs) ~(y:ys) = (x,y) : zip xs ys;
09:16:35 <danr> quicksilver: I guess that could be a nice example of ~-patterns
09:16:39 <danr> b_jonas: exactly :)
09:17:07 <trinithis> I'll test the code out. Thanks
09:17:18 <b_jonas> by the way, is it true that Haskell is usually more convenient for list-like stuff like this than a strict language because you need less reverses to get tail recursioin?
09:17:49 <DevHC^> ????????????????????????????????
09:18:22 <kirindave> b_jonas: yes and no.
09:18:41 <kirindave> b_jonas: Haskell makes a lot of that stuff much easier to express
09:18:51 <kirindave> b_jonas: but there isn't a free lunch. :)
09:18:59 <b_jonas> yep
09:19:37 <b_jonas> also, once you use enough high-level list manipulator functions, most of the reverses get well hidden so you don't gain much
09:20:29 <trinithis> Btw, why do you need the let or ~ pattern for the lazier zip? Wouldn't it work without the ~ pattern if all inputs are infinite?
09:21:03 <trinithis> s/need/want ?
09:21:43 <Axman6> b_jonas: your question sounds quite confused...
09:21:58 <c_wraith> how much lazier can zip get?  I can only see one way to make zip lazier, and it involves unamb.
09:22:16 <trinithis> ok
09:22:17 <DevHC^> @src unamb
09:22:18 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:23:01 <b_jonas> trinithis: with the tilde, you get (zip f [1] undefined) ==> [undefined]. without the tilde match, you get (zip f [1] undefined) ==> undefined. thus, the version with the tilde is lazier in the second argument.
09:23:17 <c_wraith> b_jonas: isn't that zipWith?
09:23:27 <b_jonas> c_wraith: ah yes, you're right
09:23:32 <b_jonas> remove the f-s then
09:23:42 <rwbarton> also the first one would be [f 1 undefined] or [(1, undefined)]
09:23:51 <b_jonas> rwbarton: true
09:23:52 <simon> I've made some neat Haskell code that typechecks. I can't seem to execute the code because it doesn't Show and therefore never strictly evaluates.
09:24:49 <rwbarton> trinithis: when the inputs happen to be infinite, the ~ pattern essentially changes the order of evaluation
09:25:02 <c_wraith> simon: put it on hpaste.org and give us the link, and we'll take a look
09:25:05 <rwbarton> which is what you were concerned about, originally
09:25:23 <rwbarton> or, perhaps whether something is ever evaluated at all, in your case
09:25:50 <trinithis> Cool, the code works as I wanted
09:26:50 <simon> c_wraith, http://pastebin.com/FHVE4Fki
09:26:52 <mauke> The paste FHVE4Fki has been copied to http://hpaste.org/51672
09:27:06 <simon> c_wraith, sorry, old version.
09:27:31 <b_jonas> simon: can you briefly tell us what it does? apart from not doing anything, that is.
09:28:20 <b_jonas> mauke++ for running a pastebin mover. I've been missing it since buubot has gone.
09:28:53 <simon> b_jonas, it recursively interprets its own state until a boolean is False. but it seems that `interp' is lazily hanging there.
09:29:03 <b_jonas> simon: so where's the new version?
09:29:30 <b_jonas> or is the one you pasted the new version?
09:31:00 <simon> I'll boil it down to the part that I'm wondering about.
09:45:21 <Louis11> Can anyone tell me what the <- is in this example: http://www.cs.arizona.edu/~collberg/Teaching/372/2005/Html/Html-13/img18.gif
09:45:53 <Louis11> I'm assuming it's something like "Let x = these numbers" and the last portion states something to the affect of "where x^2 + y^2 = z^2" ?
09:46:20 <Cale> simon: in interpInst you bind state <- get, but then never refer to it again
09:46:59 <Cale> Louis11: x <- someList  means that x is chosen as an element of someList in all possible ways
09:47:16 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
09:47:17 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
09:48:12 <int-e> Louis11: yes, you can read that code as "triads n is the list of tuples (x,y,z), picking x from [1..n], then y from [1..n], then z from [1..n] such that x^2 + y^2 == z^2."
09:48:13 <scott__> discovered paraconsistent logic today. wow!
09:48:28 <armlesshobo> >  [(x,y) | x <- [1,2,3,4], y <- ['a'..'d']]
09:48:29 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),(2,'b'),(2,'c'),(2,'d'),(3,'a'),(3...
09:48:52 <int-e> Louis11: where "then" is to be interpreted as Cale described it - you do the latter part for each possible choice for the former part.
09:49:59 <accel> what is a good example of a haskell DSL that poops out C or asm code?
09:50:18 <kirindave> accel: There is one for Arduino
09:50:35 <Louis11> so could I just do something like: xyz ++ triads n where x = [1..n] and y = [1..n] ?
09:50:40 <kirindave> accel: http://hackage.haskell.org/package/atom
09:51:09 <kirindave> accel: Source is here: https://github.com/tomahawkins/atom
09:51:18 <simon> Cale, that's true. that is a line remnant from before I made up the push/pop/etc. combinators.
09:51:30 <accel> kirindave: holy shit, constant memory use; I want to see how their memory system works
09:51:39 <trinithis> In the following code, does myInits have the same complexity as inits? http://hpaste.org/51673
09:52:07 <trinithis> If so, then I can use a strict zip
09:52:59 <simon> Cale, so the state is touched when I run push, pop, etc.
09:53:18 <int-e> trinithis: not quite -- consider "map head (inits [1..])" which is linear time, but quadratic with your implementation
09:53:37 <Louis11> so whats that format called? the [(x,y,z), x <- . . . ] ?
09:53:44 <Louis11> I'd like to look it up if possible
09:53:46 <trinithis> ah
09:53:53 <ion> List comprehension
09:53:54 <accel> kirindave: man, this is kinda ugly: https://github.com/tomahawkins/atom/blob/master/Language/Atom/Example.hs
09:54:02 <Axman6> Louis11: it looks like a broken list comprehension
09:54:18 <kirindave> accel: Ever coded for arduino?
09:54:37 <kirindave> accel: I think what Atom is waiting for is someone who understands template haskell and a good project workflow to step in
09:54:38 <Cale> accel: The code which is written in atom itself isn't so bad :)
09:54:44 <int-e> trinithis: uhm. I am wrong.
09:54:44 <kirindave> Indeed.
09:54:58 <accel> kirindave: never coded for arduino
09:54:59 <Cale> The pre/post code is a bit ugly to have to do
09:55:02 <kirindave> What Atom needs more is a project specification and rules for how to get c files into its build
09:55:03 <accel> Cale: example?
09:55:15 <Cale> accel: I just mean 'example'
09:55:52 <kirindave> But I've gotten code written in atom running on my arduino
09:55:58 <kirindave> It is really cool to see it work
09:56:13 <kirindave> For some operations the atom code is a handful of lines and it's literally dozens in C
09:56:18 <accel> Cale: ah, you mean example :: Atom()
09:56:22 <accel> yeah; that doesn't look as hideous
09:56:38 <accel> what I feel like what I really really want
09:56:44 <Axman6> accel: atom has been used for some projects with NASA researching control systems and monitoring
09:56:58 <accel> is a C macro system that is both typesafe & turing complete, say haskell
09:57:08 <accel> Axman6: has any of that code ever left the earth's orbit?
09:57:14 <Axman6> no
09:57:14 <Cale> It's also been used to construct real-time code for hybrid-hydraulic automobiles :)
09:57:16 <accel> Axman6: or is it just some nasa engineer's hoby project?
09:57:20 <Axman6> most code for NASA never does
09:57:25 <trinithis> @int-e: Are you saying that it is constant time with myInits? I don't see why it would be though.
09:57:25 <lambdabot> Unknown command, try @list
09:57:35 <accel> Cale: how do you know what?
09:57:38 <accel> s/what/what
09:57:39 <accel> s/what/that/
09:57:42 <Axman6> NASA are a research organisation, most of what they do never goes into space.
09:57:48 <Axman6> because, that shit's expensive
09:57:49 <Cale> accel: The guy who wrote it gave a talk
09:57:59 <accel> Axman6: then it doesn't really sound all that impressive that nasa uses it
09:58:18 <Axman6> what they use it for is impressive, and it's an very important area
09:58:28 <Cale> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56
09:58:38 <Axman6> i'd love to see atom be able to produce Ada code. that would be very cool
09:58:43 <trinithis> int-e: nvm, I was reading linear as constant and quadratic as linear
09:59:01 <Axman6> but I think the way they do things now involves making a static struct with the state for the function
10:00:14 <int-e> trinithis: so no, I don't see a reason why your version should have less performance. I like revInits, I usually define it as revInits = scanl (flip (:)) []
10:00:34 <trinithis> cool
10:00:46 <int-e> s/less/worse/
10:02:06 <accel> hmm
10:02:24 * hackagebot HROOT 0.6.3 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.3 (IanWooKim)
10:14:22 <Ptival> is there a function that does "aabbccdd" -> ["a", "a", "b", "b", "c", "c", "d", "d"]?
10:14:32 <Ptival> > map (:[]) "aabbccdd"
10:14:33 <lambdabot>   ["a","a","b","b","c","c","d","d"]
10:14:38 <rwbarton> yes
10:14:50 <Ptival> > groupWith (\_ _ -> False) "aabbccdd"
10:14:52 <lambdabot>   Not in scope: `groupWith'
10:15:39 <Ptival> rwbarton: what is its name? :)
10:15:45 <rwbarton> map (:[])
10:15:48 <Ptival> er
10:15:51 <Axman6> > map return "aabbccdd"
10:15:52 <Ptival> mkay
10:15:53 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
10:15:53 <lambdabot>    arising from a use of...
10:15:59 <Axman6> > map return "aabbccdd" :: [String]
10:16:00 <lambdabot>   ["a","a","b","b","c","c","d","d"]
10:16:03 <rwbarton> it's map applied to something, it's not going to have another name :)
10:16:03 <ion> Someone should draw a robot that looks like (:[])
10:16:03 <Ptival> sure
10:16:23 <tac-tics> @let robot = (:[])
10:16:24 <lambdabot>  Defined.
10:16:25 <tac-tics> @type robot
10:16:26 <lambdabot> forall a. a -> [a]
10:16:28 <Cale> A robot monkey
10:16:35 <armlesshobo> is there a way to force a min/max lenght of a list?
10:16:38 <armlesshobo> length*
10:16:41 <armlesshobo> win 2
10:17:01 <Axman6> armlesshobo: not unless you make a new list type
10:17:12 <rwbarton> probably not but what do you mean by "force"
10:17:24 <Axman6> or wrap lists in your own type which maintains your invariants
10:17:48 <rwbarton> > take 3 "hello" -- forcing a list to have maximum length of 3?
10:17:49 <lambdabot>   "hel"
10:18:02 <armlesshobo> not force, but specify the type that it only has a specific number of items in a list
10:18:31 <rwbarton> right, then that is what Axman6 was answering
10:18:32 <Axman6> data LenList a = LL Int [a]; newLL :: Int -> LenList a; newLL i = LL i []
10:18:39 <Cale> armlesshobo: That's not possible with the standard list type. It's possible in the GHC type system (with extensions), but awkward to do.
10:18:53 <Axman6> armlesshobo: not with types, at least not in standard haskell
10:19:09 <Cale> You need type-level numbers
10:19:20 <DukeDave> Boo: loch-0.2 failed during the building phase
10:19:24 <edon> hi, do you know any other reduced ordered binary decision diagram implementation in haskell besides obdd package in hackage?
10:19:26 <Cale> and so you end up building up arithmetic at the type level using type families, for instance
10:19:32 <tac-tics> > [1..9]
10:19:33 <lambdabot>   [1,2,3,4,5,6,7,8,9]
10:19:34 <DukeDave> From hackage :'(
10:20:07 <b_jonas> Cale: not if you just want simple things like lists with at least one element or lists with at least two elements etc
10:20:16 <rwbarton> edon: there are some bindings to BDD libraries here: https://github.com/peteg/hBDD
10:20:23 <armlesshobo> Cale, Axman6: I see, thank you :)
10:20:33 <rwbarton> I haven't gotten around to trying them out yet though
10:21:34 <dolio> BDD is a second-generation, outside-in, pull-based, multiple-stakeholder, multiple-scale, high-automation, agile methodology. It describes a cycle of interactions with well-defined outputs, resulting in the delivery of working, tested software that matters.
10:22:13 <Axman6> dolio: i hope you copied and pasted that
10:22:28 <Cale> armlesshobo: In the not-so-distant future, it'll be more convenient.
10:22:30 <dolio> What do you mean? That's just how I talk.
10:23:01 <b_jonas> does that involve zygohistomorphic prepromorphisms?
10:23:20 <b_jonas> no wait, what you said is marketing talk, whereas zygothingy is engineer talk.
10:23:20 <elliott> It's acceptable to mix Network.listenOn and Network.Socket.accept, right?
10:23:35 <elliott> As in, Network.listenOn to create it and then Network.Socket.accept to get the client sockets.
10:24:03 <DukeDave> Has anyone here used loch-th?
10:24:08 <Cale> elliott: I believe that's the usual pattern of usage.
10:24:14 <Cale> errr
10:24:19 <elliott> Cale: Network.accept exists.
10:24:28 <elliott> But I don't want it because it returns Handles. :p
10:24:33 <Cale> Yeah, I missed the qualified name there
10:24:39 <Cale> Why don't you want a Handle?
10:25:01 <elliott> I'm using iterIO; a handle just means some extra useless overhead and potential buffering/encoding behaviour I don't want to think about.
10:27:46 <pmk-goog> is mmap() really missing from the standard libraries in the Haskell Package?  need it, can't seem to find it, and am scared of the FFI.
10:28:24 <Axman6> there is at least one package on hackage
10:28:31 <Cale> elliott: IterIO doesn't work with handles?
10:28:33 <Axman6> @google haskell mmap
10:28:35 <lambdabot> http://hackage.haskell.org/packages/archive/bytestring-mmap/0.2.0/doc/html/System-IO-Posix-MMap-Lazy.html
10:28:35 <lambdabot> Title: System.IO.Posix.MMap.Lazy
10:29:07 <elliott> Cale: Sure it does.
10:29:32 <elliott> Cale: But handles don't offer any benefit and could potentially give me one or two very minor headaches down the line, so I'd like to avoid the overhead and just do Sockets directly.
10:29:35 <Cale> It's a more general thing isn't it?
10:29:38 <Cale> Really?
10:29:38 <elliott> It's no pain at all, as long as you're "allowed" to mix the two APIs.
10:29:54 <elliott> Really what?
10:30:05 <elliott> http://hackage.haskell.org/packages/archive/iterIO/0.2/doc/html/Data-IterIO-ListLike.html#g:5 has both iterHandle and iterStream.
10:30:24 <Axman6> elliott: unless you're doing something very strange, i'd start out using Handles, and fix the problem with Fd's later if needed
10:30:29 <Cale> Handles do a lot of stuff over file descriptors to make sure that concurrency works properly and so on.
10:30:41 <elliott> Hmm, fair enough. Don't Sockets, too?
10:30:49 <elliott> They at least have an MVar in there. :
10:30:49 <elliott> :p
10:30:50 <Axman6> or sockets
10:32:28 <Axman6> is there a reason that Typeable isn't automatically derived for all types?
10:32:44 <Cale> elliott: Well, hmm...
10:32:47 <elliott> Axman6: hysterical raisins?
10:32:58 <Axman6> probably
10:33:16 <elliott> Cale: I would be quite surprised if sockets didn't do the concurrency stuff too, since they're a "blessed" "portable" part of the network API.
10:33:18 <elliott> Fds certainly.
10:35:09 * Axman6 wishes at least one of the iteratee packages would use better names... something like Producer, Consumer and Transformer
10:36:09 <elliott> iterIO's naming is at least consistent. :)
10:36:20 <buntfalke> How do these two types compare regarding performance? "data String' = Str'{toString::String}" and "newtype String'' = Str''[Char]"? The newtype is faster because it has on level of indirection less?
10:36:31 <Axman6> yeah I remember being impressed by iterIO when it came out
10:36:43 <buntfalke> Why would someone use a data if the constructor is unary anyway?
10:37:02 <elliott> buntfalke: The newtype is probably what you want. You can include the field name too. But [Char] is identical to String.
10:37:09 <Axman6> buntfalke: i wouldn't. possibly out of habit
10:37:12 <elliott> Literally synonymous, there is no point replacing String with [Char], they are identical in every way.
10:37:23 <elliott> buntfalke: They might use "data" to introduce laziness.
10:37:26 <buntfalke> Axman6: "wouldnt" what?
10:37:34 <elliott> For instance () has the values _|_ and (), but data X = X () has the values _|_, X _|_, and X ().
10:37:39 <elliott> That introduces one additional level of laziness.
10:37:44 <Axman6> newtype String'' = Str'' {toString :: String} works fine
10:38:01 <buntfalke> Oh, wow
10:38:20 <buntfalke> So. How does that differ?
10:38:29 <buntfalke> newtype with toString, and data with toString?
10:38:38 <elliott> Axman6's given type is identical to your newtype.
10:38:43 <Axman6> the new type is guarantees to have the same representation at runtime as String
10:38:47 <elliott> The toString is just a cosmetic field name.
10:38:55 <elliott> It affects the runtime representation not one bit.
10:39:09 <mamalujo> buntfalke: in that case, how come haskell didn't mimick miranda on this one and just treat unary data as newtype. keyword less.
10:39:15 <buntfalke> elliott: Is that true for data, too?
10:39:19 <cbarrett> hi.
10:39:32 <buntfalke> elliott: "doesnt affect runtime"?
10:39:44 <elliott> buntfalke: The field name doesn't affect the runtime representation.
10:39:46 <buntfalke> mamalujo: I am not familiar with miranda
10:40:03 <Axman6> buntfalke: data will cause an extra level of indirection, like you said earlier
10:40:14 <buntfalke> So how do these two differ? "newtype String'' = Str'' {toString :: String}" and "data String' = Str'{toString::String}"?
10:40:17 <elliott> mamalujo: Because that would make one-constructor one-argument data types behave inconsistently to normal data types, thanks to laziness.
10:40:23 <buntfalke> Axman6: Ah, I see
10:40:25 <buntfalke> Thanks
10:40:47 <Axman6> and there may indeed be times when you want to have the ability to have undefined :: X, X undefined :: X and X () :: X
10:40:57 <buntfalke> Axman6: So is this a valid rule of thumb: If the constructor would be unary anyway, use newtype.
10:41:16 <elliott> buntfalke: Unless you're exploiting laziness, yes.
10:41:19 <Axman6> sure, unless you need different strictness behaviour
10:41:24 <buntfalke> Thanks
10:41:58 <Axman6> newtype Void = Void Void is twice as fast as data Void = Void Void :P
10:42:36 <buntfalke> Why doesnt the compile optimize any unary data constructor to equal a newtype? (mamalujo: is that what you meant?) because of the stricness/laziness issue?
10:42:52 <Axman6> yes, it would change the semantics of programs
10:42:55 <Axman6> and that's bad
10:42:56 <Cale> The meaning is actually different
10:42:57 <buntfalke> I see
10:43:03 <Cale> data Void = Void Void has one value
10:43:13 <Cale> Which looks like  Void (Void (Void (...)))
10:43:16 <copumpkin> newtype
10:43:27 <Cale> newtype Void = Void Void has no defined values
10:43:48 <mamalujo> at least less syntax then. Say something like "data ~String' = String' {toString::String}" for a newtype, instead of a keyword
10:44:08 <c_wraith> In fact, if you create an Identity monad, unless you use annotations in the >>= definition, using newtype or data is the difference between making it strict or lazy
10:44:11 <threlliott> mamalujo: a keyword is less heavyweight syntax than that
10:44:15 <threlliott> especially such an unlikely word as "newtype"
10:44:21 * Axman6 likes to imagine that newtype Void = Void Void is compiled to something like XXXX: jmp XXXX
10:44:53 <Axman6> mamalujo: you've just added new syntax
10:44:56 <mamalujo> threlliott: I meant, just using the tilde in front of the type name part as different
10:44:59 <b_jonas> agreed, a keyword is better, especially the way the token ~ is now three-way overloaded
10:44:59 <copumpkin> > case undefined of In x -> 5
10:45:00 <lambdabot>   5
10:45:29 <b_jonas> it means lazy pattern, type equality constraint, and an operator too
10:45:36 <b_jonas> or is it not an operator?
10:45:40 <mamalujo> yeah, that's true
10:45:42 <b_jonas> maybe just two way
10:45:52 <Axman6> hmm, is foo: goto foo; valid C?
10:46:00 <b_jonas> Axman6: yes
10:46:13 <threlliott> b_jonas: I think it is an operator, but I think GHC might also not support that
10:46:14 <threlliott> > 9 ~ 0
10:46:15 <lambdabot>   Pattern syntax in expression context: ~0
10:46:22 <trinithis> Haskell should introduce goto.
10:46:24 <buntfalke> Data is lazy, and newtype is not? Cause data just matches to see if the constructor fits, and newtype has non thus evaluates the first level of actual values?
10:46:49 <threlliott> trinithis: You can build it on top of recursive do notation.
10:46:57 <threlliott> Or even just plain do notation, really, with Cont.
10:47:01 <Cale> pattern matches against newtype constructors are irrefutable
10:47:09 <Cale> and don't cause any evaluation to occur
10:47:16 <b_jonas> threlliott: no, it's not a valid operatoer according to http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
10:47:17 <threlliott> buntfalke: newtype causes no kind of evaluation; they are completely erased at runtime.
10:47:19 <b_jonas> threlliott: I was wrong
10:47:22 <threlliott> It is like you used the enclosed type directly.
10:47:24 <b_jonas> it's just two-way overloaded then
10:47:24 <threlliott> b_jonas: oh, huh
10:47:29 <threlliott> I think it maybe used to be
10:47:40 <b_jonas> threlliott: aren't you thinking of !
10:47:44 <threlliott> b_jonas: possibly
10:47:53 <b_jonas> threlliott: that _is_ a valid operator still
10:48:03 <threlliott> they should outlaw one or both :P
10:48:07 <threlliott> err
10:48:09 <threlliott> both or neither
10:48:15 <b_jonas> threlliott: nah, it's historic
10:48:20 <b_jonas> threlliott: ~ is old, ! is newer
10:48:44 <buntfalke> Cale, threlliott: Thanks
10:48:45 <trinithis> How well does Haskell function as an imperative language where you (quite) liberally use (IO/ST) and (IO/ST)Refs? Has anyone made an entire application like that before?
10:48:50 <threlliott> b_jonas: those raisins are hysterical :(
10:48:51 <b_jonas> also ? for that type magic is new so ? is still an operator
10:48:58 <threlliott> trinithis: yes, every newbie coming from an imperative language has :)
10:49:02 <antgeth> what's a "non-exhaustive pattern in function"?
10:49:15 <threlliott> trinithis: You get first-class imperative actions and can do higher-order operations over those, which is incredibly valuable.
10:49:18 <trinithis> I mean a serious program by a serious (?) haskeller
10:49:27 <hpc> antgeth: suppose you had a function like this:
10:49:27 <b_jonas> antgeth: it's like when you say head (x : _) = x
10:49:29 <threlliott> There's that infamous quote about Haskell being <whoever>'s favourite imperative language.
10:49:34 <hpc> swap (x, y) = (y, x)
10:49:40 <Axman6> trinithis: i think it would be extremely difficult
10:49:47 <threlliott> trinithis: Well, why? There are very few programs with absolutely no areas where you can apply functional programming.
10:49:59 <trinithis> Morbid curiosity
10:50:06 <mamalujo> its a bit verbose too
10:50:08 <hpc> antgeth: you can rewrite it as swap ~(x, y) = (y, x)
10:50:25 <hpc> ~pat means not to evaluate the argument for that pattern, and just assume it matches
10:50:25 <b_jonas> hpc: can you now?
10:50:43 <b_jonas> right
10:50:43 <hpc> if it turns out later that it doesn't, you get that error
10:50:47 <Axman6> antgeth: when you haven't matched a pattern that got passed to your function. if you had foo True = ... and somewhere in your code foo False was called, then that would be an unmatched pattern
10:51:04 <hpc> antgeth: if you do something like let (y, x) = (a, b) in ...
10:51:13 <antgeth> you'll have to forgive me, i'm pretty naïve at this
10:51:14 <antgeth> hang on
10:51:20 <hpc> antgeth: that pattern is the same as let ~(y, x) = (a, b)
10:51:22 <hpc> hence the error
10:51:46 <antgeth> http://hpaste.org/51676
10:51:52 <Axman6> trinithis: also, take a look at some of the shootout code, some of it is almost all pointer arithmetic etc
10:52:00 <antgeth> this is to output the number of times a given integer appears in a list
10:52:17 <antgeth> and it's giving me that non-exhaustive error
10:52:19 <threlliott> Cale: So do Sockets have the same concurrency magicke or am I better off sticking with Handles?
10:52:19 <monochrom> "[l]" is wrong notation
10:52:23 <hpc> antgeth: oh wow, i seriously misread your error message
10:52:24 * hackagebot hieraclus 0.1 - Automated clustering of arbitrary elements in Haskell  http://hackage.haskell.org/package/hieraclus-0.1 (PhilippPribbernow)
10:52:26 * hackagebot hieraclus 0.1.1 - Automated clustering of arbitrary elements in Haskell  http://hackage.haskell.org/package/hieraclus-0.1.1 (PhilippPribbernow)
10:52:31 <hpc> ignore me
10:52:32 <threlliott> I guess handles are the safe choice but it still feels icky if they're unnecessary.
10:52:49 <Axman6> antgeth: you probably want countC n l, not [l], which says you want to match a list with a single element, which you're calling l
10:52:57 <trinithis> And no one wants to feel icky!
10:53:00 <monochrom> I am also not sure why you need two cases.
10:53:09 <monochrom> anyway, I'll go ahead fix it
10:53:29 <DukeDave> Would anyone like to make this line prettier?
10:53:29 <DukeDave>             let propStr = show `fmap` ((\mp -> length `fmap` pGPropertyGetLabel mp) `Traversable.mapM` maybeProp )
10:53:46 <hpaste> monochrom annotated “counting” with “counting (annotation)” at http://hpaste.org/51676#a51677
10:53:48 <Axman6> less infix
10:53:48 <DukeDave> Specifically the "(\mp -> length `fmap` pGPropertyGetLabel mp)" is a pattern I don't like :|
10:53:49 <monochrom> there
10:53:49 <threlliott> DukeDave: Import Traversable as something nicer than Traversable.
10:53:59 <threlliott> DukeDave: Have you considered applicative notation?
10:54:02 <monochrom> though you will never read it
10:54:10 <antgeth> ohhhhhhhhhhhhhhh, right
10:54:11 <antgeth> thanks
10:54:18 <threlliott> DukeDave: (\mp -> length <$> pGPropertyGetLabel mp) or (fmap length . pGPropertyGetLabel), I guess the latter is actually nicer.
10:54:24 <DukeDave> threlliott: I shall Google "applicative notation" presently
10:54:31 <threlliott> It's just Control.Applicative.
10:54:45 <threlliott> let propStr = show <$> (fmap length . pGPropertyGetLabel `T.mapM` maybeProp)
10:54:46 <b_jonas> monochrom: heh
10:54:49 <threlliott> You might be able to elide those parens, actually.
10:54:54 <Cale> threlliott: They appear to have less magic, certainly, though to be honest, I'm a little hazy on the details. I'd just use the Handle interface and not worry about it unless it became a problem.
10:55:04 <Axman6> > (,,) <$> [1,2,3] <*> [4,5,6] <*> [7,8,9]
10:55:05 <lambdabot>   [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(2...
10:55:07 <threlliott> DukeDave: let propStr = show <$> T.mapM (fmap length . pGPropertyGetLabel) maybeProp
10:55:15 <threlliott> Cale: Right.
10:55:29 <trinithis> You just have to limbo!
10:56:06 <b_jonas> Axman6: don't you want a few ZipList in that?
10:56:19 <Axman6> no?
10:56:27 <DukeDave> For some reason Applicative always scares me
10:56:28 <Axman6> did exactly what i wanted...
10:56:37 <DukeDave> I don't know why
10:56:39 <Cale> > (,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9]
10:56:40 <lambdabot>   No instance for (GHC.Show.Show
10:56:41 <lambdabot>                     (Control.Applicative.Zip...
10:56:48 <Cale> > fromZipList ((,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9])
10:56:49 <lambdabot>   Not in scope: `fromZipList'
10:56:54 <b_jonas> getZipList
10:56:57 <Cale> oh, right
10:56:59 <Axman6> DukeDave: it's really nice once you get used to it. i was the same, irrational fear
10:57:00 <Cale> > getZipList ((,,) <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9])
10:57:00 <trinithis> DukeDave: http://en.wikipedia.org/wiki/Phobia
10:57:01 <lambdabot>   [(1,4,7),(2,5,8),(3,6,9)]
10:57:14 <cbarrett> DukeDave: give the Typeclassopedia (another) read, and do Brent's exercises. They help a lot.
10:57:24 * hackagebot linda 0.1.1 - LINear Discriminant Analysis  http://hackage.haskell.org/package/linda-0.1.1 (LennartSchmitt)
10:57:33 <Axman6> cbarrett: how's the XPC stuff going?
10:57:38 <trinithis> s/brent/keigel/
10:58:01 <mamalujo> DukeDave: isn't it the same thing as `fmap` anyway
10:58:05 <cbarrett> trinithis: hm?
10:58:11 <trinithis> kegel*
10:58:25 <cbarrett> Wasn't the Typeclassopedia written by Brent Yorgey?
10:58:29 <cbarrett> Axman6: Well! Fixed those crashes.
10:58:35 <Axman6> excellent
10:58:38 <cbarrett> In kind of an unexpected (to me) way.
10:58:47 <trinithis> Kegal exercices : http://en.wikipedia.org/wiki/Kegel_exercise
10:58:55 <cbarrett> Ah.
10:58:58 <Eduard_Munteanu> Heh.
10:58:59 <cbarrett> A joke :P
10:59:09 <cbarrett> made the fromXPC function in the IO monad, and made xpc_int64_get_value in the IO monad as well.
10:59:22 <cbarrett> Honestly not sure why that last one fixed things.
10:59:50 <cbarrett> It was an odd crash too, only showed up in largish heaps (100s of MB)
11:00:02 <Axman6> well, the non-IO version would be expecting it can be run ant any time with the same argument and get the same result right?
11:00:13 <elliottcable> Axman6 › ಠ_ಠ
11:00:19 <cbarrett> and it should (as long as the pointer is valid)
11:00:26 <elliottcable> elliottt › not only are you getting me hilighted, you’re now *getting me hilighted by my friends* ddisapprove 
11:00:32 <elliottcable> :D
11:00:39 <Axman6> what did i do now?
11:00:45 <elliottcable> Axman6 › lol, not you
11:00:55 <elliottcable> Axman6 › just saw you in my hilights, and was all “Axman!”
11:00:59 <Axman6> you lookofdisapproval'd me!
11:01:02 <elliottcable> then I saw it was in #haskell, and was all “awww.”
11:01:03 <Axman6> heh
11:01:09 <elliottcable> Axman → aww.
11:01:18 <cbarrett> I suppose that's another argument for restricting functions to ForeignPtr.
11:01:22 <cbarrett> *shrug*
11:01:40 <cbarrett> What's more urgent right now is fixing up the gross runtime type checking. Those guards do not have long to live.
11:01:54 <Axman6> cbarrett: well, if you have to retain and release XPC objects, it's almost guaranteed to be what you want
11:02:07 <cbarrett> yeah.
11:02:21 <Axman6> how are you going to avoid that?
11:02:24 * hackagebot hieraclus 0.1.1.1 - Automated clustering of arbitrary elements in Haskell  http://hackage.haskell.org/package/hieraclus-0.1.1.1 (PhilippPribbernow)
11:02:44 <cbarrett> I don't. The withXPC function uses ForeignPtr internally.
11:03:02 <Axman6> i mean the runtime type checking
11:03:07 <cbarrett> oh, I'm not
11:03:11 <cbarrett> just going to make it less gross.
11:03:16 <cbarrett> use an ADT.
11:03:20 <Axman6> ah
11:03:31 <Axman6> yeah, i was thinking that would make more sense
11:04:07 <Axman6> so... XPC = XInt Int | XHash (Map String XPC) etc?
11:04:16 <cbarrett> Oh, no.
11:04:19 <cbarrett> For the types.
11:04:24 <Axman6> eh?
11:04:55 <cbarrett> xpc_get_type.
11:04:57 <Axman6> hmm, why not represent the whole type as an ADT?
11:05:05 <cbarrett> Because that's a pain to actually use.
11:05:08 <cbarrett> Tried it.
11:05:14 <Axman6> hmm, ok
11:06:17 <Axman6> ok, sleep time for me.
11:06:22 <cbarrett> g'night.
11:07:24 * hackagebot hieraclus 0.1.1.2 - Automated clustering of arbitrary elements in Haskell  http://hackage.haskell.org/package/hieraclus-0.1.1.2 (PhilippPribbernow)
11:07:59 <DukeDave> Thanks threlliott, cbarrett
11:08:10 <cbarrett> DukeDave: nw :)
11:08:32 <threlliott> DukeDave: np
11:27:06 <mdwright_laptop> I'm getting a "ghc-7.0.4 requires filepath ==1.2.0.0 however filepath-1.2.0.0 was excluded because ghc-7.0.4 requires filepath ==1.1.0.4" error when trying to install Snap via Cabal (OSX 10.6, haskell-platform installed via homebrew).
11:27:24 * hackagebot dingo-core 0.0.3.1 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.0.3.1 (BardurArantsson)
11:27:26 * hackagebot dingo-widgets 0.0.3.1 - Dingo Widgets  http://hackage.haskell.org/package/dingo-widgets-0.0.3.1 (BardurArantsson)
11:27:57 <mdwright_laptop> Is this a GHC problem? Cabal? Snap? an issue with my install?
11:30:09 <DukeDave> So, I'm getting back some dodgy Strings from a library and when I try to print them I get fun exceptions like: "Prelude.chr: bad argument: 7496002"
11:30:48 <DukeDave> Is there anyway I can show the String's char's byte values, without first going through chr?
11:31:01 <DukeDave> I tried show . map ord, but it still dies :|
11:31:19 <DukeDave> Interestingly if I length the string it is the right length
11:32:11 <hpc> :t show . map ord
11:32:12 <lambdabot> [Char] -> String
11:32:22 <hpc> > show . map ord $ "this is an ascii string"
11:32:24 <lambdabot>   "[116,104,105,115,32,105,115,32,97,110,32,97,115,99,105,105,32,115,116,114,...
11:32:53 <hpc> > show . map ord $ fix ('a':)
11:32:54 <lambdabot>   "[97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,97,9...
11:33:03 <hpc> strange, that should work
11:33:11 <DukeDave> hpc: I think the problem is that the 'Char's themselves have erroneous values in them..
11:33:41 <DukeDave> Like "7496002", which I'm fairly sure isn't in the ascii table :)
11:33:48 <dainanaki> are bytestrings unboxable?
11:33:52 <hpc> > show . map ord $ "i∞∅Ω∀ℵ∃∈⊂⊕ℂ×ℕ∩≤≥←→↔"
11:33:54 <lambdabot>   "[105,8734,8709,8486,8704,8501,8707,8712,8834,8853,8450,215,8469,8745,8804,...
11:34:14 <hpc> > chr 7496002
11:34:15 <lambdabot>   *Exception: Prelude.chr: bad argument: 7496002
11:34:24 <hpc> '\7496002'
11:34:29 <hpc> > '\7496002'
11:34:30 <lambdabot>   <no location info>:
11:34:30 <lambdabot>      lexical error in string/character literal at chara...
11:34:34 <hpc> > maxBound :: Char
11:34:35 <lambdabot>   '\1114111'
11:34:41 <chrisdone> can GHC or some linking program warn about missing haddock docs?
11:34:47 <hpc> yeah, dunno how you ended up with data like that
11:35:04 <DukeDave> hpc: It's coming from FFI :)
11:35:09 <chrisdone> i have a large codebase i want to be fully documented, such a tool would speed the process up considerably
11:35:31 <rwbarton> then your FFI code is probably what's wrong
11:35:33 <chrisdone> s/linking/linting
11:35:48 <DukeDave> I'm working on wxHaskell, and the wxWidgets people changed their string handling in the latest dev build, hilarity ensues..
11:36:18 <DukeDave> rwbarton: I would say it is most certainly wrong :)
11:36:31 <DukeDave> I was just sad that show . map ord didn't work
11:36:44 <rwbarton> how did it not work
11:36:46 <DukeDave> Or that it still calls chr some how
11:36:55 <rwbarton> same error?
11:37:44 <DukeDave> Yeah, I get  "Prelude.chr: bad argument: 7496002" even when I'm only trying to show . map ord the string
11:38:05 <rwbarton> weird
11:38:08 <rwbarton> Prelude Unsafe.Coerce> [unsafeCoerce 7496002 :: Char]
11:38:09 <rwbarton> "\7496002"
11:38:10 <chrisdone> hehe, my emacs extension to prompt for adding LANGUAGE extensions is awesome
11:38:12 <DukeDave> I had *hoped* to use loch-th to find exactly where that Prelude.chr error is coming from
11:39:17 <DukeDave> But when I prefix the offending code with 'checkIO' the error disappears, it seems to just stop the evaluation :|
11:39:33 <rwbarton> it sounds like the error might not be where you think it is at all
11:39:43 <DukeDave> rwbarton: I concur
11:40:31 <DukeDave>  Prelude Unsafe.Coerce> show $ map Char.ord $ [unsafeCoerce 7496002 :: Char]
11:40:44 <DukeDave> > show $ map Char.ord $ [Unsafe.unsafeCoerce 7496002 :: Char]
11:40:45 <lambdabot>   Not in scope: `Char.ord'Not in scope: `Unsafe.unsafeCoerce'
11:41:26 <rwbarton> oh, if the FFI code is using chr to create the String (and how else would it do it?) then that error is probably coming from the FFI code
11:41:44 <rwbarton> as soon as you force the evaluation of a character in your string
11:44:11 <DukeDave> rwbarton: This is the point where we first get a Haskell style String:
11:44:11 <DukeDave> withManagedStringResult :: IO (Ptr (TWxString a)) -> IO String
11:44:11 <DukeDave> http://hackage.haskell.org/packages/archive/wxcore/latest/doc/html/src/Graphics-UI-WXCore-WxcTypes.html
11:45:00 <rwbarton> -- FIXME: I am blithely changing these over
11:45:05 <rwbarton> Confidence-inspiring.
11:45:47 <DukeDave> Isn't it :)
11:45:56 <DukeDave> I *wish* I could step through this
11:46:05 <DukeDave> But I have yet to coerce gdb into such magic
11:47:10 <rwbarton> do you know how large wchar_t is on your platform?
11:52:50 <DukeDave> rwbarton: Uh, sizeof(wchar_t) = 4
11:54:38 <rwbarton> > printf "%04x" 7496002
11:54:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:54:40 <lambdabot>    `Text.Printf.PrintfType ...
11:54:44 <rwbarton> > printf "%04x" 7496002 :: String
11:54:45 <lambdabot>   "726142"
11:55:11 <rwbarton> > map chr [0x42,0x61,0x72]
11:55:12 <lambdabot>   "Bar"
11:55:53 <cbarrett> Amusing how the error messages from lambdabot just trail off.
11:55:54 <rwbarton> looks like wxString_GetString is writing a sequence of bytes, maybe it's intended to be UTF-8?
11:58:01 <ourfrank> Do installed packages contain source code?
11:58:28 <Saizan> nope
11:58:38 <DukeDave> ourfrank: No, but if you're installing with cabal you can use "unpack" to get the source
12:00:36 <ourfrank> Thanks. Why can ghci then use installed packages, but cannot use regular compiled code without sources available? Related SO question: http://is.gd/Wq0tTJ
12:01:28 <DukeDave> rwbarton: Ha, "The most serious backwards-incompatible change is related to the change of return type of wxString::c_str() method: it returns a special proxy object instead of a simple char* or wchar_t* now." (http://docs.wxwidgets.org/2.9/overview_changes_since28.html)
12:01:33 <ourfrank> Is there perhaps additional information within an installed package that is not there when modules are simply compiled?
12:02:02 <rwbarton> ...
12:02:13 <Saizan> ourfrank: it needs the .hi files
12:02:44 <rwbarton> well, in that case it looks like you can adjust the definition of http://docs.wxwidgets.org/2.9/overview_changes_since28.html in cpp/extra.cpp to use wc_str()
12:02:46 <ourfrank> Saizan: So, ghci can work with access to just an .o and .hi file?
12:03:10 <rwbarton> oops, definition of wxString_GetString
12:03:39 <ourfrank> Saizan: I understand .hi files are essential, but even with them I cannot make ghci actually access the compiled module's top-level definitions.
12:03:51 <ddarius> ourfrank: Were they exported?
12:03:59 <ourfrank> ddarius: Yes.
12:04:19 <DukeDave> rwbarton: I'll let you know when it's compiled :)
12:04:21 <Saizan> ourfrank: i don't know if there's an UI for loading from a .o and .hi directly, but that's what it does for installed packages
12:05:01 <ourfrank> Saizan: Thanks. If that's true, then it's as I had feared. :)
12:05:08 <ddarius> It will always load a .o in preference to interpreting from source unless you use *, and that was added only fairly recently.
12:05:21 <quicksilver> Saizan, ourfrank : btu the special mode for accessing top-level definitions which are not exported is only for interpreted code
12:05:40 <quicksilver> you can force it to interpret by putting a * next to the module name (if the .hs file exists)
12:05:46 <Saizan> ddarius: yeah, but that's still with the source present
12:05:49 <ddarius> Also, if you are working with a package you need to tell GHCi to use that package.
12:13:55 <tigger_> Hi. Could someone explain why this throws flexible instances error: (instance Show (a->b->c) where show a = "Hi")
12:14:25 <tigger_> I haven't defined (instance Show (a->b) where show a = "Hello") either
12:14:46 <ClaudiusMaximus> the second -> is not a type variable (if i'm guessing the right error message)
12:15:07 <dylukes> you should tell us the specific error
12:15:18 <tigger_> yes
12:15:43 <hpaste> temp pasted “flex instances” at http://hpaste.org/51680
12:15:56 <tigger_> http://hpaste.org/51680
12:16:29 <Saizan> read the error, it doesn't talk about conflicts with other instances
12:16:45 <rwbarton> writing the type of the instance in prefix form:   instance Show ((->) a ((->) b c))
12:18:34 <parcs> what is the justification behind that restriction?
12:18:42 <dmwit> Ease of implementation.
12:18:43 <ddarius> There is none really.
12:19:57 <tigger_> @saizan , sorry about that, yes, just wasn't sure what the issue was. I'll think this over
12:19:58 <lambdabot> Unknown command, try @list
12:20:21 <tigger_> saizan, sorry about that, yes, just wasn't sure what the issue was. I'll think this over
12:20:29 <ion> echo… echo… echo… echo
12:20:56 <dmwit> @echo echo echo
12:20:56 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "dmwit!~dmwit@pool-98-111-177-159.phlapa.east.verizon.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo
12:20:57 <lambdabot> echo echo"]} rest:"echo echo"
12:21:16 <ion> @@ @echo @echo @echo
12:21:17 <lambdabot>  echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "ion!ion@heh.fi", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@@ @echo @echo @echo"]} rest:"echo; msg:
12:21:17 <lambdabot> IrcMessage {msgServer = \"freenode\", msgLBName = \"lambdabot\", msgPrefix = \"ion!ion@heh.fi\", msgCommand = \"PRIVMSG\", msgParams = [\"#haskell\",\":@@ @echo @echo @echo\"]} rest:\"echo; msg:
12:21:17 <lambdabot> IrcMessage {msgServer = \\\"freenode\\\", msgLBName = \\\"lambdabot\\\", msgPrefix = \\\"ion!ion@heh.fi\\\", msgCommand = \\\"PRIVMSG\\\", msgParams = [\\\"#haskell\\\",\\\":@@ @echo @echo @echo\\\"]
12:21:17 <lambdabot> } rest:\\\"\\\"\""
12:21:21 <dmwit> ack
12:22:05 <armlesshobo> > [(x,y) | x <- [1..100], y <- [1..100]]
12:22:06 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
12:22:08 <armlesshobo> noice
12:23:13 <armlesshobo> > putStrLn "@@ @echo @echo @echo"
12:23:15 <lambdabot>   <IO ()>
12:23:54 <armlesshobo> :t putStrLn
12:23:55 <lambdabot> String -> IO ()
12:24:13 <armlesshobo> ahhh...
12:24:46 <dino-> @seen Lemmih
12:24:46 <preflex>  Lemmih was last seen on #haskell 13 days, 8 hours, 53 minutes and 26 seconds ago, saying: Jafet: What does 'mapM_' have to do with it?
12:24:46 <lambdabot> Unknown command, try @list
12:25:11 <cbarrett> indeed
12:28:52 <dmwit> > let diag xs ys = [(xs !! j, ys !! (i-j)) | i <- [0..], j <- [0..i]] in diag [1..] [1..]
12:28:54 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3...
12:30:45 <ddarius> dmwit: Do you text your mother with those fingers?
12:31:10 <dmwit> > let diag xs ys = do len <- [1..]; zip (take len xs) (reverse (take len ys)) in diag [1..] [1..]
12:31:11 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,4),(2,3),(3,2),(4,1),(1,5),(2,4),(3...
12:31:12 <heatsink> Is there an OS-independent way to hOpen "/dev/null" ?
12:31:18 <Saizan> tigger_: the issue is that (a -> b -> c) doesn't fit the rather arbitrary restriction that haskell2010 has on instance heads, so you need to turn that restriction off by using the extension
12:31:29 <dmwit> > let diag xs ys = do len <- [1..]; zip (take len xs) (reverse (take len ys)) in diag [1..5] [1..3]
12:31:30 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(3,1),(1,3),(2,2),(3,1),(1,3),(2,2),(3,1),(1...
12:31:42 <dmwit> nice
12:32:25 <dmwit> Oh, wait, that's not nice at all.
12:33:02 <dmwit> heatsink: Don't think so.
12:34:39 <heatsink> ok.
12:36:02 <dmwit> > let diag xs ys = do len <- [1..]; zip (take len xs) (reverse (take len ys)) in map (\(a,(b,c)) -> a * 100 + b * 10 + c) (diag [1..] (diag [1..] [1..]))
12:36:03 <lambdabot>   [111,112,211,121,212,311,113,221,312,411,122,213,321,412,511,131,222,313,42...
12:37:11 <cbarrett> dmwit: heatsink: is there even windows equiv of /dev/null?
12:37:18 <ddarius> Yes.
12:37:31 <dsouza> cbarrett: NUL i think
12:37:47 <cbarrett> ah
12:38:13 <cbarrett> (never written any windows-specific code before, was curious)
12:38:41 <heatsink> cbarrett, I don't know, but it's certainly possible to make a Handle that discards its input like /dev/null.
12:39:09 <dmwit> heatsink: I guess you can dispatch on which operating system you're in, then.
12:39:19 <dmwit> System.Info.os
12:39:27 <heatsink> That's a string, right?
12:39:33 <heatsink> :t System.Info.os
12:39:34 <lambdabot> String
12:39:40 <cbarrett> heh
12:39:53 <heatsink> A very extensible sum type.
12:40:15 <opqdonut> :)
12:40:23 <dino-> > System.Info.os
12:40:24 <lambdabot>   Not in scope: `System.Info.os'
12:40:52 <dmwit> Probably saner is to use a channel or so instead of a handle, and have the other end decide whether to actually write it to the handle or not.
12:41:00 <glguy> Does Haddock work with GHC 7.2?
12:41:09 <b_jonas> it could be a Bool, True meaning a real os
12:42:47 <heatsink> By channel, you mean from Control.Concurrent.Chan?
12:44:42 <hpaste> poet pasted “floating point?” at http://hpaste.org/51681
12:44:51 <poet> is this a floating point error?
12:45:23 <ddarius> Yes and no, mostly no.
12:45:38 <ddarius> The semantics for enumFromTo for floating point types is bizarre.
12:47:47 <keep_learning> if i need to concate two list then which on  i should prefer considering the efficiency .  first ++ second or foldr (:) second first
12:47:50 <rwbarton> > last [1.0,1.1..2]
12:47:51 <lambdabot>   2.000000000000001
12:47:54 <keep_learning> or both are same
12:48:31 <rwbarton> if the second was faster, then the first would surely just be redefined to be the second
12:48:35 <rwbarton> therefore, use the first
12:48:42 <poet> ddarius: I'm not sure what you mean
12:49:42 <cbarrett> rwbarton: indeed they appear the same in the prelude
12:49:42 <cbarrett> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#%2B%2B
12:50:32 <cbarrett> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#foldr
12:52:16 <rwbarton> poet: 0.1 is not exactly representable as a floating-point number--you might refer to this as a floating point error.
12:52:39 <poet> rwbarton: right, ok
12:52:54 <rwbarton> But [1.0,1.1..2] is defined so that it still has the expected length (unlike  takeWhile (< 2) [1.0,1.1..])
12:53:03 <rwbarton> > last $ takeWhile (< 2) [1.0,1.1..]
12:53:04 <lambdabot>   1.9000000000000008
12:53:10 <rwbarton> > last $ takeWhile (<= 2) [1.0,1.1..]
12:53:11 <lambdabot>   1.9000000000000008
12:53:31 <poet> rwbarton: ha, that's a great example
12:53:36 <rwbarton> Often people act surprised when they learn that [a,b..c] is not the same as takeWhile (<=c) [a,b..]
12:55:04 <rwbarton> Usually because they have written something odd like [1.0, 1.35 .. 2] and expect to get a particular result for some reason
12:56:28 <poet> very messy haha
12:57:14 <keep_learning> :t [ 1 , 2..10]
12:57:16 <lambdabot> forall t. (Num t, Enum t) => [t]
12:57:36 <chrisdone> where are the hot haskell jobs these days? haskellers.com lists nought
12:57:43 <chrisdone> i suppose there is Well Typed
12:57:50 <keep_learning>  [ 1 , 2..10] == takeWhile ( <=10) [ 1 , 2 ..]
12:58:22 <keep_learning> :t  [ 1 , 2..10] == takeWhile ( <=10) [ 1 , 2 ..]
12:58:23 <lambdabot> Bool
13:03:05 <DukeDave> rwbarton: Yep, that was the problem!
13:03:21 <ddarius> rwbarton: People would like the invariant that all the elements in [a,b..c] are less than or equal to c.
13:03:43 <ddarius> The "expected number of elements" seems far more vague and arbitrary than that simple axiom.
13:04:24 <buntfalke> What is the downside of using Data.Sequence? It's description only mentions benefits...
13:04:42 <kmc> buntfalke, doesn't give you $50
13:04:53 <ddarius> Worse, it doesn't give $1,000,000.
13:04:55 <dmwit> buntfalke: It has less convenient built-in syntax than lists.
13:05:05 <kmc> it's also less lazy than lists
13:05:08 <buntfalke> Overhead for small lists, slower than Lists for anything Lists are effecient at?
13:05:13 <kmc> and the implementation is a lot harder to understand, if for some reason that matters to you
13:05:28 <buntfalke> Srsly guys :-)
13:05:28 <ddarius> buntfalke should give what he is comparing it against.
13:05:33 <dmwit> And you (probably) can't have infinite sequences.
13:05:40 <buntfalke> ddarius: Comparing to lists
13:05:53 <buntfalke> dmwit: Oh, true!
13:06:08 <ddarius> If you treat Sequence like a list, it will probably be slower in every way.
13:06:25 <kmc> that is, if you're using lists right in the first place
13:06:56 * ddarius just closes his eyes and assumes everyone uses the appropriate data structure for the job within reason.
13:11:33 <monochrom> when you open your eyes again, the real world is still out there, full of people who use bubble sort over arrays, followed up linear search...
13:11:45 <monochrom> s/followed up/followed by/
13:12:29 <chrisdone> who's using bubble sort over arrays?
13:12:52 <dino-> buntfalke: Some terrific reading on this in RWH, Chapter 13: Data Structures
13:13:29 <cbarrett> wrt performance, a strategy that has worked well for me (haven't applied it to haskell yet) is to make sure that any potentially problematic code is written in such a way that it will show up in a profiler if slow.
13:13:56 <cbarrett> often times it ends up not being a problem --- computers are fast -- but when things have cropped up its been obvious.
13:14:00 <cbarrett> it's*
13:14:39 <ddarius> Make sure potentially slow code is written to execute -very- slowly so that it is easier to debug the performance problem.
13:15:01 * ddarius uses permutation sort.
13:15:04 <buntfalke> dino-: Thanks!
13:15:43 * chrisdone prefers sleep sort
13:16:08 <chrisdone> the time performance is reliable
13:18:20 <dino-> buntfalke: Specifically towards the end of that chapter. Goes through performance of (++), writing and using a difference list instead, and then introduces Data.Sequence.
13:23:52 <erus`> i wish /r/haskell had more submissions a day
13:24:19 <kmc> i wish it had fewer
13:24:25 <kmc> specifically fewer "LOL FUNNAY PICTUR"
13:24:42 <kmc> reddit is leaking into /r/haskell
13:24:55 <erus`> there has been 1 LOLFUNNYPIC post in the last age
13:37:16 <dmwit> "cabal: Can't find transitive deps for haddock"
13:37:24 <dmwit> Error message from "cabal haddock".
13:37:33 <dmwit> cabal configure succeeded just fine
13:38:29 <dmwit> Oh, maybe the fix just isn't released yet, I found a Trac bug for it.
13:42:28 * hackagebot hit 0.1.0 - Git operations  http://hackage.haskell.org/package/hit-0.1.0 (VincentHanquez)
13:45:02 <dmwit> dibblego: I've just uploaded an early prototype of an edit-lens library. You told me you wanted to hear when that happened so... =)
13:45:19 <dmwit> dibblego: No documentation yet, but coming Real Soon Now.
13:45:46 <dibblego> dmwit: awesome mate,and I'll have a chance to look today too, thanks!
13:45:58 <dmwit> Also planned are template-haskell things for deriving lenses from data declarations (as other lens libraries have), and a container reshaping lens that I actually haven't fully understood yet. =P
13:46:33 <dmwit> http://hackage.haskell.org/package/edit-lenses
13:47:28 * hackagebot edit-lenses 0.1 - Symmetric, stateful edit lenses  http://hackage.haskell.org/package/edit-lenses-0.1 (DanielWagner)
13:52:28 * hackagebot edit-lenses 0.1.1 - Symmetric, stateful edit lenses  http://hackage.haskell.org/package/edit-lenses-0.1.1 (DanielWagner)
13:55:26 <rwbarton> ddarius: My position is that if people write "sum $ map (^2) [1.0,1.1..2]", then 25.850000000000016 is a much better answer than 21.850000000000012.
13:56:03 <rwbarton> If people write "sum $ map (^2) [1.0,1.35..2]", then they don't know what they want so it doesn't matter what answer is produced (in fact an error would be better than any answer at all).
13:56:59 <gbluma> Anyone happen to know any good resources on the GHC linker? I've been curious about it but haven't found much.
13:57:22 <shachaf> glguy: "the GHC linker"?
13:57:29 <shachaf> s/glguy/gbluma/
13:57:50 <shachaf> Doesn't it just use the regular linker?
13:59:10 <basvandijk> Prepare to get swamped by hackagebot...
13:59:15 <gbluma> Could be, that would explain a few things.
13:59:56 <tromp> how to see the source for Float's enumFromTo?
13:59:58 <Saizan> ghci uses dlopen
14:00:35 * byorgey erects sandbags full of powdered lambda
14:00:51 <ddarius> rwbarton: And if people write plot $ map (\x -> (x, f x)) [lo, lo+step, hi], they clearly wanted 2.0000000008?
14:01:32 <ddarius> Really the problem is that Floating doesn't make a lot of sense as an instance of Enum.
14:02:17 <rwbarton> Well, that I agree with naturally
14:02:20 <tromp> but it's nice to be able to say [1..10]::[Float]
14:02:28 * hackagebot regions 0.10 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.10 (BasVanDijk)
14:02:30 * hackagebot regions-monadstf 0.3.1.6 - Monads-tf instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadstf-0.3.1.6 (BasVanDijk)
14:02:32 * hackagebot regions-mtl 0.3.1.6 - mtl instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-mtl-0.3.1.6 (BasVanDijk)
14:02:34 * hackagebot regional-pointers 0.6.0.1 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.6.0.1 (BasVanDijk)
14:02:36 * hackagebot safer-file-handles 0.10.0.1 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.10.0.1 (BasVanDijk)
14:02:37 <rwbarton> personally I'd make [a,b..c] valid only when a, b and c are numeric literals and c actually is in the sequence [a,b..]
14:02:45 <ddarius> > [1..] :: Float
14:02:46 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
14:02:46 <lambdabot>         against inferred typ...
14:02:52 <rwbarton> if you want take (<= c) [a,b..], write take (<= c) [a,b..]
14:02:52 <ddarius> > [1..] :: [Float]
14:02:54 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
14:04:21 <ddarius> rwbarton: I would write a short way of achieving your desired interpretation is, but I don't even know what it is.
14:04:24 <dmwit> > dropWhile (\m -> m /= m + 1) [2^n | n <- [1..]] :: [Float]
14:04:25 <lambdabot>   [1.6777216e7,3.3554432e7,6.7108864e7,1.3421773e8,2.6843546e8,5.3687092e8,1....
14:04:42 <tromp> but better no Enum instance than a bizarre one, I would agree
14:07:38 * hackagebot safer-file-handles-bytestring 0.3 - Extends safer-file-handles with ByteString operations  http://hackage.haskell.org/package/safer-file-handles-bytestring-0.3 (BasVanDijk)
14:07:40 * hackagebot safer-file-handles-text 0.2.0.1 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.2.0.1 (BasVanDijk)
14:07:47 * hackagebot usb-safe 0.13 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.13 (BasVanDijk)
14:07:57 <Louis11> Could someone explain foldr to me. From what I gather, it applies a function to some datatype? I tried running foldr (+) [1,2,3] in ghci, however I get an error in my expression?
14:08:32 <shachaf> Louis11: You need an empty-list case with foldr.
14:08:36 <shachaf> > foldr (+) 0 [1,2,3]
14:08:37 <tromp> > foldr (+) 0 [1,2,3]
14:08:37 <lambdabot>   6
14:08:38 <lambdabot>   6
14:08:43 <shachaf> Louis11: This is what foldr does:
14:08:50 <shachaf> > foldr f z [a,b,c,d]
14:08:51 <lambdabot>   f a (f b (f c (f d z)))
14:09:19 <Louis11> alright, so how can I test this out in my interpreter? Do I need to include anything?
14:09:26 <Louis11> I can't seem to get foldr working in my script :/
14:09:30 <shachaf> Nope.
14:09:36 <shachaf> Louis11: Just remember the 0 for foldr (+). :-)
14:09:58 <Louis11> multiply n  = foldr (*) n
14:09:58 <ddarius> In my opinion, the most damning thing is: [1,3..4] :: [Integer] v. [1,3..4] :: [Double].
14:10:10 <shachaf> Louis11: (For the particular case of summing a list, you almost always want foldl.)
14:10:11 <Louis11> that doesn't work? Or am I missing the syntax?
14:10:22 <shachaf> Louis11: Same thing. You're not missing the syntax, you're missing an argument. :-)
14:10:28 <ddarius> foldl'
14:10:53 <shachaf> Louis11: foldr will replace every (:) in the list with your function, and the [] at the end of the list with your other argument.
14:10:59 <Louis11> why is foldl preferred here?
14:11:03 <shachaf> > foldr (*) 1 []
14:11:04 <lambdabot>   1
14:11:10 <Louis11> ahhh
14:11:10 <engla> Louis11: you can test foldr/foldl right away in ghci
14:11:13 <shachaf> @google foldr vs foldl haskellwiki
14:11:14 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
14:11:15 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
14:11:53 <Louis11> fold (+) [1,2,3,4,5] that's what was on the haskell website, confused me - didn't know there was another argument required
14:12:04 <Louis11> assummed fold was just a demo of foldl/foldr
14:12:07 <Louis11> got it now :) thanks
14:12:13 <shachaf> Louis11: Where on the website?
14:12:17 <armlesshobo> one needs ghc 7.* or something for LLVM, I bet
14:12:30 <shachaf> Louis11: "fold" isn't a standard function, so they probably meant a specific definition that was provided next to that example.
14:12:33 <Louis11> http://www.haskell.org/haskellwiki/Fold
14:12:45 <Louis11> shachaf: Yea in retrospect that makes more sense
14:12:54 <shachaf> Oh, I see.
14:13:14 <engla> ghc won't compile my 250K source file :-( I just want to output (convert to  picture) a large Data.Map that I have as printed (show) output.
14:13:52 <engla> anyone know how I can get it to compile?
14:14:56 <ddarius> Use a different compiler.
14:15:45 <ddarius> However, another idea would be to read the Map in at runtime from a file.
14:16:13 * shachaf generates a 1.1M .hs file and attempts to compile it.
14:20:47 <shachaf> No success.
14:20:53 <engla> it seems the problem was that 226K was all on one line.
14:21:06 <engla> adding linebreaks made it compile. Without optimization,
14:22:58 <engla> maybe I spoke to soon
14:34:42 <engla> finally, success. splitting the list in multiple lists (400 items apiece) seems to have worked. Also peaked at 530MB resident ram
14:34:47 <engla> so it went ok.
14:42:55 <trinithis> Lambdabot for president!
14:43:38 <Eduard_Munteanu> lambdabot *was* president :)
14:43:45 <Eduard_Munteanu> @nixon
14:43:46 <lambdabot> If you think the United States has stood still, who built the largest shopping center in the world?
14:47:50 <Louis11> What's the : in haskell? For instance in something like then x : merge xs (y:ys)
14:48:03 <cbarrett> CREELB has less of a ring to it ;)
14:48:29 <cbarrett> Louis11: it's the constructor for a list.
14:48:38 <cbarrett> If you're familiar w/ lisp it's like cons
14:48:49 <cbarrett> type should be instructive.
14:48:54 <Eduard_Munteanu> > 1 : [2,3]
14:48:54 <cbarrett> :t (:)
14:48:55 <lambdabot>   [1,2,3]
14:48:56 <lambdabot> forall a. a -> [a] -> [a]
14:48:59 <Louis11> been a while since I did lisp. I take it it's putting x followed by the rest of the list?
14:49:00 <Louis11> ah yea
14:49:43 <cbarrett> so [1,2,3] is really just sugar for 1 : 2 : 3 : []
14:49:52 <cbarrett> > [1,2,3] == 1 : 2 : 3 : []
14:49:53 <lambdabot>   True
14:50:10 <cbarrett> :info (:)
14:50:29 <inetic_> hi, can I have localy defined types in haskell (no particular use, just curious)
14:50:39 <cbarrett> locally defined?
14:51:07 <rwbarton> like within a where clause or something?
14:51:12 <rwbarton> no
14:51:31 <Eduard_Munteanu> Hm.
14:51:49 <Eduard_Munteanu> This might qualify for ddarius' challenge to find arbitrary limitations :)
14:52:00 <rwbarton> I think there may be a proposed extension for it, but I haven't heard of it being implemented anywhere
14:53:18 <cbarrett> only reason to want that is to have the type hidden when it's out of scope, I think. Seems like it should be subsumed into modules etc.
14:53:23 <cbarrett> (and related to the whole records thing)
14:54:09 <rwbarton> Importing a module within a where clause is also potentially useful
14:54:11 <Eduard_Munteanu> First-class modules would be nice.
14:54:36 <shachaf> rwbarton: Of course, that would import all of the module's instances globally. :-)
14:54:45 <cbarrett> hah
14:55:48 <cbarrett> I think Python's module system is a pretty good example of how you can turn something similar to Haskell's module system into hairy mess ;)
14:55:52 <cbarrett> (I like Python)
14:56:45 * Eduard_Munteanu would like some of Agda's stuff on that in Haskell.
14:56:49 <cbarrett> (i recall hearing that the version control system bazaar spent several hundred ms in module loading when it began interpreting.)
14:57:06 <kirindave> cbarrett: It is okay to not like Python.
14:57:12 <cbarrett> hah
14:57:13 <rwbarton> python's module system is one part of the language that I never attempted to learn about or understand, and I'm pretty happy with that decision
14:57:20 <cbarrett> no, really, I do like it.
14:57:26 <kirindave> cbarrett: You don't have to go all Al Franken and say, "I love ____, but here is how I am going to ream ____."
14:57:26 <cbarrett> It's quite nice for a lot of things
14:57:33 <kirindave> I hate it.
14:57:35 <kirindave> Personally.
14:57:41 <cbarrett> but its module system is not one of its strong aspects.
14:57:50 <kirindave> but then, I am a Man With Contrarian Opinions™.
14:57:53 <cbarrett> heheh
14:58:41 <cbarrett> are you the same kirindave as @kirindave on twitter, btw?
14:58:45 <kirindave> Yes.
14:58:48 <kirindave> That jerk.
14:58:51 <cbarrett> cool :)
14:59:09 <cbarrett> hah
14:59:10 <shachaf> kirindave: Are you the same kirindave as kirindave in #startups?
14:59:17 <kirindave> shachaf: Haa.
14:59:20 <kirindave> shachaf: For juggalos now.
14:59:44 <cbarrett> oh dear, #startups?
15:00:10 <shachaf> cbarrett: Don't do it!
15:00:27 <cbarrett> heheh
15:01:11 <kirindave> I am sorta there because my colloquy script keeps logging me into it
15:01:20 <kirindave> When I log in to irc via linux I am not there
15:06:10 <DanBurton> Hey all
15:06:54 <DanBurton> My SO question on strictness points now has a 200 rep bounty http://stackoverflow.com/questions/7490768/what-are-haskells-strictness-points
15:07:00 <DanBurton> just so yall know
15:07:30 <kirindave> DanBurton: You forgot unsafePerformIO in that list. :)
15:07:41 <kirindave> It Who Shall Not Be Named.
15:07:45 <DanBurton> lol
15:07:56 <kirindave> Also Debug.Trace?
15:08:01 <DanBurton> that's actually a good point; I'll edit the question real quick
15:08:43 <cbarrett> foldl' is relatively commonly used and strictly evaluates its arguments.
15:08:54 <cbarrett> er, well, the list argument anyway
15:09:06 <DanBurton> true, but it's directly defined with seq
15:09:24 <cbarrett> yeah, but it can be easy to forget (especially for newish haskellers)
15:09:27 <yitz> DanBurton: how about TH
15:10:28 <Gustavo> Hi
15:10:40 <shachaf> Greetings, Gustavo.
15:10:56 <DanBurton> TH is a whole other beast
15:10:58 <Gustavo> whats up?
15:11:09 <DanBurton> I'd consider it outside of the scope of the question
15:11:20 <yitz> DanBurton: it execute *before* main :)
15:11:31 <yitz> s/execute/executes/
15:11:43 <DanBurton> well yes, but TH is not Haskell, it's TH
15:11:57 <yitz> DanBurton: what does the H stand for?
15:12:00 <DanBurton> you can run any preprocessor you like to produce Haskell code
15:12:15 <DanBurton> yitz: Template HolyCrapAwesomesauce
15:12:21 <yitz> hehe
15:12:28 <byorgey> Gustavo: TryingHaskell?
15:12:39 <Gustavo> yeah
15:12:54 <byorgey> Gustavo: cool, let us know if you have any questions
15:13:01 <Gustavo> ok :D
15:13:01 <yitz> Template HasAhemCoughCough
15:13:02 <shachaf> Gustavo: You'll want to be careful. Haskell is a gateway language.
15:13:03 <Gustavo> thansk
15:13:24 <Gustavo> whats a gateway language?
15:13:47 <DanBurton> shachaf: gateway language?
15:13:58 <cbarrett> byorgey: thank you for Typeclassopedia. Wonderful document. Keep coming back to the exercises.
15:14:06 <QtPlatypus> Gustavo: Its a joke.  It means learning Haskell will start you learning outher FP langauges.
15:14:07 <shachaf> Never mind.
15:14:15 <Gustavo> Hahahah
15:14:27 <byorgey> cbarrett: thanks, glad you like it!
15:14:39 <DanBurton> @wiki typeclassopedia
15:14:40 <lambdabot> http://www.haskell.org/haskellwiki/typeclassopedia
15:14:46 <Gustavo> Im Brazilian, Its hard to get these jokes
15:14:48 <byorgey> cbarrett: I keep threatening to put out a second edition... hopefully I will actually get it done one of these days
15:14:56 <cbarrett> byorgey: I would love that.
15:15:11 <shachaf> byorgey: Was there ever an HTML version of it?
15:15:25 <yitz> DanBurton: TH is not just "any preprocessor you run to produce Haskell code". it allows you to run Haskell code itself at compile time, and makes available some types and functions that only make sense in that context.
15:15:36 <byorgey> shachaf: not unless someone converted it that I'm not aware of
15:15:52 <byorgey> shachaf: however I plan to make the 2nd edition available as HTML as well as PDF
15:16:00 <shachaf> 2nd edition!
15:16:12 <byorgey> hopefully with per-paragraph commenting, like the RWH drafts
15:16:35 <shachaf> Hmm, it's 52 pages long.
15:16:49 <yitz> byorgey: and hopefully not hard-wired inside some larger document.
15:17:01 <byorgey> yitz: indeed =)
15:17:02 <shachaf> yitz: http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
15:17:38 <DanBurton> yitz: fair enough; I'd still put it outside the realm of my question on Haskell's strictness points, though an exposition of TH would certainly be interesting as well
15:17:51 <cbarrett> byorgey: neat!
15:18:38 <yitz> DanBurton: your SO post makes us really scrape the bottom of the barrel for ways that Haskell code actually runs :)
15:22:43 <DanBurton> yitz: I'm not trying to focus on how it runs, so much as how the semantics / language definition say it is supposed to run
15:23:36 <DanBurton> laziness is a way cool feature of Haskell, but I don't think we spend enough effort explaining exactly how it works in Haskell, which causes people to complain that reasoning about Haskell code is difficult
15:23:59 <DanBurton> hence the SO question + bounty
15:24:10 <yitz> shachaf: oh, ok, thanks. i didn't notice that http://community.haskell.org/~yitz/typeclassopedia.pdf got disabled when we moved to the new server. i just re-enabled it.
15:25:28 <yitz> DanBurton: a very worthwhile endeavor, appreciated
15:25:48 <yitz> DanBurton: (and yes, i upvoted you)
15:26:02 <shachaf> Laziness isn't a feature of Haskell, it's a feature of Haskell implementations. :-)
15:26:05 * shachaf is part of the problem.
15:27:48 <sanjoyd> From what I understand -> Haskell is non-strict; Haskell implementations are lazy.
15:28:01 <ski> cbarrett : local type definitions could also have free type variables, like `data Foo b = Mk a b' where `a' is bound in this scope (e.g. by a polymorphic operation)
15:28:39 <cbarrett> ski: good point
15:29:30 <byorgey> sanjoyd: correct.
15:29:31 <ski> (and that's where i felt the lack of local type definitions)
15:30:18 <sanjoyd> Any GHC hackers here?
15:30:26 <byorgey> Haskell doesn't have a formally specified semantics (which is understandable, but IMO a real shame).
15:30:46 <ski> sanjoyd : tried #ghc ?
15:30:58 <sanjoyd> ski: thanks!
15:31:24 <sanjoyd> byorgey: but the spec does say that it compiles to System F?
15:31:56 <byorgey> sanjoyd: I don't think so
15:32:31 <cbarrett> I'm reading the 3rd SYB paper (Scrap Your Boilerplate with Class). In section 2.2, it talks about extQ not specializing the function for constructors.
15:32:45 <patrickthomson> byorgey: Out of curiosity, why do you support a formally-specified semantics for Haskell?
15:32:45 <cbarrett> but I'm not seeing where later in the paper they show how to do that
15:33:03 <cbarrett> can anyone point me to the right part (or an example of this elsewhere?)
15:33:31 <byorgey> patrickthomson: mostly because I think the very process of trying to create one would be extremely enlightening.
15:33:47 <byorgey> I am also a fan of formal specification in general.
15:34:04 <heatsink> Would you want to include IO in the specification?
15:34:20 <byorgey> I would especially want to include IO!
15:34:21 <sanjoyd> byorgey: you're right: "Although the kernel is not formally specified, it is essentially a slightly sugared variant of the lambda calculus with a straightforward denotational semantics."
15:35:47 <heatsink> Then it's not gonna be a modified System F semantics, I think.
15:36:00 <heatsink> Dunno what it would be.
15:36:07 <Louis11> No instance for (Ord a) arising from a use of `<=' . . . What's this saying?
15:36:25 <sanjoyd> Louis11: you're comparing the uncomparable?
15:36:43 <shachaf> Or the unknown-to-be-comparable.
15:37:00 <Cale> > sin <= cos
15:37:01 <lambdabot>   *Exception: (==): No overloading for function
15:37:02 <Louis11> hm, this function worked with integers? Now I'm trying to merge two lists
15:37:03 <shachaf> Louis11: You can't (<=) any values of any type; e.g. it doesn't work for functions.
15:37:18 <Cale> heh, right
15:37:19 <shachaf> Cale: Ha, caught up in your own folly!
15:37:37 <byorgey> Louis11: if you paste your code on hpaste.org we can take a look
15:37:58 <Cale> > putStr "hello" <= putStrLn "hello"
15:37:58 <yitz> > (^2) <= (^3)
15:37:59 <lambdabot>   No instance for (GHC.Classes.Ord (GHC.Types.IO ()))
15:37:59 <lambdabot>    arising from a use o...
15:37:59 <lambdabot>   *Exception: (==): No overloading for function
15:38:36 <Louis11> byorgey: http://hpaste.org/51682
15:38:42 <shachaf> > x^2 <= x^3
15:38:44 <lambdabot>   True
15:38:56 <shachaf> Louis11: Well, the type is wrong.
15:39:02 <byorgey> Louis11: right, the type of your merge function declares that merge will work on *any* type of list
15:39:03 <sanjoyd> lambdabot does algebra?
15:39:05 <ski> Louis11 : you should add `Ord a => ' after the `::'
15:39:08 <shachaf> Louis11: It doesn't work for any lists, only lists that can be compared.
15:39:20 <byorgey> Louis11: but it only works on lists whose elements support a notion of ordering.
15:39:21 <Louis11> ski: What does Ord imply exactly?
15:39:24 <Louis11> Order?
15:39:25 <shachaf> Louis11: If you took the type declaration out and then did ":t" in ghci, it would tell you what the type is.
15:39:27 <ski> yes
15:39:27 <byorgey> right
15:39:28 <shachaf> Louis11: Comparable.
15:39:29 <shachaf> @src Ord
15:39:29 <lambdabot> class  (Eq a) => Ord a  where
15:39:29 <lambdabot>     compare      :: a -> a -> Ordering
15:39:29 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
15:39:29 <lambdabot>     max, min         :: a -> a -> a
15:39:42 <shachaf> How can you sort a list of things that can't be compared? :-)
15:40:06 <cbarrett> infinite loop bogosort
15:40:12 <ski> Louis11 : `merge :: [a] -> [a] -> [a]' means that `merge' will work on any two lists with elements of *any* type `a', and return a list with elements of same type
15:40:12 <cbarrett> (lazily of course)
15:40:41 <Louis11> alright awesome, didn't know I needed to specify that in this instance
15:40:42 <ski> Louis11 : `merge :: Ord a => [a] -> [a] -> [a]' otoh means that `merge' will work on any two lists with elements of any type `a' in type class `Ord' (meaning : for any comparable type), and return a list with elements of same type
15:40:54 <sanjoyd> Louis11: welcome to the strongly typed world. :)
15:40:55 <Louis11> no wonder it worked when I had [Int] -> [Int] -> [Int]. I assume Int implies Ord?
15:41:08 <QtPlatypus> shachaf: There are some places where you can sort things where there isn't a total order but never the less there are local orders.
15:41:13 <shachaf> Louis11: Well, Int is an instance of Ord.
15:41:15 <ski> Louis11 : `Int' is already known to be a member of the type class `Ord', yes
15:41:18 <Louis11> sanjoyd: haha yea, it's been a while. I coded Haskell a few years back, briefly. Trying to remember/learn it again
15:41:32 <ski> @instances Ord
15:41:32 <shachaf> QtPlatypus: True. I guess there's no type class for partial orderings.
15:41:32 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:42:11 <sanjoyd> Ordering isn't always transitive?
15:42:25 <sanjoyd> As in, how do you sort a poset?
15:42:43 <ski> Louis11 : btw, if you had omitted the type signature, it would have been (correctly) inferred, and you could have asked your interactor for the type by `:t merge'
15:42:48 <sanjoyd> s/Ordering/The kind of ordering sorting needs/
15:42:50 <byorgey> sanjoyd: you can't.  the Ord type class is for total orders, not posets.
15:42:51 <shachaf> sanjoyd: Partial orderings are still transitive, aren't they?
15:43:02 <ski> sanjoyd : a preorder has reflexivity and transitivity
15:43:05 <sanjoyd> shachaf: yes.
15:43:08 <sanjoyd> My bad.
15:43:12 <ski> sanjoyd : a partial order adds anti-symmetry to that
15:43:21 <shachaf> If all the elements of a set happen to be comparable, you can still sort it, presumably.
15:43:27 <tgeeky> shachaf: there are at least 2 different classes for Posets on github
15:43:46 <byorgey> the problem with a poset with respect to sorting is that some pairs of elements might not be comparable.
15:44:12 <Louis11> anyone have any idea what this is implying? "Implement a merge sort that is parametrized with the comparison function"
15:44:24 <byorgey> I guess you could still write a sort method that would guarantee to put elements in *some* order compatible with a poset.
15:44:26 <Louis11> as a side note, this is one of the most active IRC channels for a programming language I've ever seen
15:44:36 <tgeeky> Louis11: implement a merge sort where you can swap the "compareTo" function with an alternate
15:44:47 <shachaf> byorgey: (a -> a -> Ordering) -> [a] -> [a]?
15:44:51 <pikhq> Aren't ##c and ##c++ more active?
15:44:54 <sanjoyd> byorgey: reverse topological sort the poset graph?
15:44:54 <cbarrett> what tgeekysaid
15:45:08 <byorgey> shachaf, sanjoyd: right
15:45:25 <ski> (see e.g. <http://ncatlab.org/nlab/show/total+order> and <http://ncatlab.org/nlab/show/linear+order> for those)
15:45:52 <byorgey> Louis11: instead of just using (<=) to compare elements, it should take a function as an extra argument which specifies how to compare two elements.
15:45:57 <shachaf> byorgey: Oh, I thought you were the one asking.
15:45:58 <QtPlatypus> sanjoyd: Knuth has an algorithm for that.
15:46:09 <sanjoyd> Knuth has an algorithm for everything.
15:46:17 <QtPlatypus> byorgey: You mean like sortBy
15:46:26 <byorgey> QtPlatypus: yes.
15:47:06 <Louis11> byorgey: mergeSortP :: (a -> a -> Bool) -> [a] -> [a] that's what I'm given. How do I pass a function in exactly?
15:47:37 <cbarrett> the first bit, in parens.
15:47:41 <sanjoyd> Louis11: the first argument is a function.
15:47:49 <Jafet> @type sortBy
15:47:50 <ski> e.g. `mergeSortP (<=) [4,2,8,5,7,1]'
15:47:50 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
15:47:58 <byorgey> Louis11: don't you need an extra [a] ?
15:48:02 <azaq23> @type (<=)
15:48:03 <lambdabot> forall a. (Ord a) => a -> a -> Bool
15:48:11 <byorgey> Louis11: oh, mergeSort, sorry
15:48:11 <QtPlatypus> Louis11: The same way you pass any value in.  Functions are first class.
15:48:12 <shachaf> byorgey: That's mergeSortP, not mergeP. :-)
15:48:16 <Jafet> Ordering is annoying sometimes, it seems redundant
15:48:18 <ski> byorgey : for the `mergeP', presumably
15:48:18 <DanBurton> > x
15:48:18 <byorgey> yeah =)
15:48:19 <lambdabot>   x
15:48:29 <DanBurton> @type x
15:48:29 <QtPlatypus> Jafet: In what way?
15:48:30 <lambdabot> Expr
15:48:42 <byorgey> @where Expr
15:48:43 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
15:48:46 <byorgey> DanBurton: ^^^
15:48:48 <DanBurton> I'm still boggled that lambdabot knows x^2 <= x^3
15:48:56 <byorgey> DanBurton: it doesn't really =)
15:49:02 <DanBurton> then why does it say it is
15:49:06 <DanBurton> > x^2 <= x&3
15:49:07 <Louis11> hm, so why am I passing in a Bool here?
15:49:07 <lambdabot>   Not in scope: `&'
15:49:09 <DanBurton> > x^2 <= x^3
15:49:10 <lambdabot>   True
15:49:16 <Louis11> how's that relevant?
15:49:19 <Jafet> Ordering is flat, so you have to compare the elements totally even if all you need to know is whether the pair is LT or not.
15:49:19 <byorgey> > (x - 2) <= (x - 3)
15:49:20 <ski> re `Ordering', <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> is fun
15:49:20 <lambdabot>   True
15:49:34 <byorgey> DanBurton: it's just comparing the expressions syntactically
15:49:53 <byorgey> DanBurton: as you can see above, it thinks (x - 2) <= (x - 3)
15:49:56 <QtPlatypus> > x^3 <= x^2
15:49:56 <lambdabot>   False
15:50:10 <DanBurton> byorgey: how is Ord defined on expressions?
15:50:24 <parcs> > e^x < x^e
15:50:29 <lambdabot>   mueval-core: Time limit exceeded
15:50:31 <azaq23> > (4 ** 2 <= 4 ** 3, 0.5 ** 2 <= 0.5 ** 3)
15:50:35 <lambdabot>   (True,False)
15:50:37 <DanBurton> o_O
15:50:45 <parcs> lambdabot doesn't know her limits
15:50:45 <byorgey> DanBurton: I don't know exactly, but for expressions that are identical except for one component, I assume it just compares that component.
15:50:53 <byorgey> DanBurton: so  x^2 <= x^3  because  2 <= 3
15:51:10 <copumpkin> > x^2
15:51:13 <lambdabot>   x * x
15:51:16 <Jafet> deriving (Ord)
15:51:21 <byorgey> Louis11: I don't understand your question.  What do you mean, why are you passing in a Bool?
15:51:24 <copumpkin> > x^3 < x^4
15:51:26 <lambdabot>   False
15:51:30 <copumpkin> > x^3 <= x^4
15:51:31 <lambdabot>   False
15:51:34 <parcs> > x^10000 < x^100001
15:51:35 <copumpkin> > x^3 > x^4
15:51:36 <lambdabot>   False
15:51:36 <lambdabot>   True
15:51:38 <DanBurton> > x*x*x <= x*x
15:51:39 <lambdabot>   False
15:51:41 <byorgey> oh, haha, it's worse than I thought
15:51:43 <Louis11> mergeSortP :: (a -> a -> Bool) -> [a] -> [a] there's a Bool in there?
15:51:46 <copumpkin> I think it always returns false
15:51:46 <DanBurton> > x*x <= x*x*x
15:51:48 <lambdabot>   True
15:51:48 <ocharles> hrm, very new to enumerators and stuff, but I'm looking at parsing a xml document that's stored online, and I thought I could do that by composing the http-enumerator with the xml-enumerator. However, wouldn't that mean that the http-enumerator should provide an actual Enumerator? I can only find functions with Iteratee in the types, but no Enumerator
15:51:52 <copumpkin> oh I guess not
15:51:59 <shachaf> > x < y
15:52:00 <lambdabot>   True
15:52:07 <shachaf> > x^2 < y
15:52:08 <lambdabot>   True
15:52:09 <byorgey> Louis11: the first argument to mergeSortP is a function. that function takes two values of type a and returns a Bool.
15:52:10 <sanjoyd> Hey!  Nice stateless random function.
15:52:14 <DanBurton> we should extend lambdabot to do algebra and calculus
15:52:16 <shachaf> Is it lexicographical or something?
15:52:34 <sanjoyd> > a < b
15:52:35 <lambdabot>   True
15:52:40 <sanjoyd> > b < a
15:52:41 <lambdabot>   False
15:52:50 <DanBurton> > a < A
15:52:52 <lambdabot>   Not in scope: data constructor `A'
15:53:01 <byorgey> > deriv sin x
15:53:02 <lambdabot>   1 * cos x
15:53:06 <sanjoyd> @type a
15:53:07 <byorgey> DanBurton: ^^^  =)
15:53:07 <DanBurton> o_O
15:53:08 <lambdabot> Expr
15:53:09 <Louis11> byorgey: But why would it ever return a bool? Maybe like x > y == True?
15:53:16 <DanBurton> @type deriv
15:53:17 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
15:53:17 <sanjoyd> @src a
15:53:17 <lambdabot> Source not found. You untyped fool!
15:53:33 <azaq23> alphabetical Ord implementation of variables, if true then lulz
15:53:33 <ocharles> Also, I see that xml-enumerator's only iteratee takes Data.XML.Types.Event objects... so that doesn't seem much good either
15:53:35 <byorgey> Louis11: presumbly it returns True if the first argument is (say) less than or equal to the second, and False otherwise
15:53:35 <DanBurton> @src deriv
15:53:36 <shachaf> > sin x < x
15:53:36 <lambdabot> Source not found. You type like i drive.
15:53:37 <lambdabot>   True
15:53:42 <byorgey> Louis11: it is the same as the type of (<=)
15:53:46 <byorgey> @type (<=)
15:53:47 <lambdabot> forall a. (Ord a) => a -> a -> Bool
15:54:18 <Jafet> That is, the type of (<=) on any given instance of Ord
15:54:36 <Louis11> Byorgey: Alright, I think I got it. Thanks a ton, you've been very helpful :)
15:54:36 <DanBurton> @src Expression.compare
15:54:37 <lambdabot> Source not found. You untyped fool!
15:54:44 <byorgey> Louis11: great, you're welcome =)
15:56:00 <byorgey> > deriv (sqrt . cos . (^2)) x
15:56:05 <lambdabot>   mueval-core: Time limit exceeded
15:56:26 <DanBurton> > integrate x
15:56:28 <lambdabot>   Not in scope: `integrate'
15:56:54 <DanBurton> oh lambdabot; so much fun to play with
15:57:17 <byorgey> > int cos x
15:57:18 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:57:18 <lambdabot>         against inferred type ...
15:57:27 <byorgey> @type int
15:57:28 <lambdabot> Int -> Doc
15:57:33 <byorgey> heh, ok
15:57:41 * shachaf would be surprised if lambdabot did integration.
15:58:06 <Jafet> Well, Cale is in #math
15:58:12 <DanBurton> > integ x
15:58:13 <lambdabot>   Not in scope: `integ'
15:58:26 <shachaf> Well, if it did it the same way "deriv" works, anyway.
15:58:30 <byorgey> > reduction (1+2+3)
15:58:32 <lambdabot>   Not in scope: `reduction'
15:58:45 <azaq23> DanBurton: the package regarding the deriv function is here http://hackage.haskell.org/packages/archive/numbers/2009.8.9/doc/html/Data-Number-Dif.html
15:59:55 <DanBurton> azaq23: ooh cool
16:02:45 <DanBurton> ok, obligatory copy-paste from the hwn
16:02:51 <DanBurton> let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
16:02:58 <DanBurton> @let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
16:02:59 <lambdabot>   Parse error: in
16:03:03 <DanBurton> aw
16:03:22 <Eduard_Munteanu> > let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
16:03:25 <lambdabot>   ["emacs and nano suck, learn vim","vim and nano suck, learn emacs","vim and...
16:03:54 <DanBurton> :)
16:05:30 <shachaf> let es = ["vim", "vim", "vim"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
16:05:35 <shachaf> > let es = ["vim", "vim", "vim"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
16:05:37 <lambdabot>   ["vim and vim suck, learn vim","vim and vim suck, learn vim","vim and vim s...
16:05:42 <ocharles> uhhh, are there any docs for expat-enumerator?
16:05:55 <ocharles> https://john-millikin.com/software/enumerator-expat/ and http://hackage.haskell.org/package/expat-enumerator is an extremely sorry state of affairs if that's it...
16:06:09 <cbarrett> ocharles: "just read the paper!" ;)
16:07:05 <DanBurton> > let es = ["Haskell", "ML", "Lisp"] in map (\e -> intercalate " and " (delete e es) ++ " are hard, learn " ++ e) es
16:07:07 <lambdabot>   ["ML and Lisp are hard, learn Haskell","Haskell and Lisp are hard, learn ML...
16:07:12 <msieradzki> is there some way to tell cabal to compile C-Sources ending with .cpp with g++?
16:07:30 <shachaf> > let es = ["Haskell", "ML", "Lisp"] in map (\e -> intercalate " and " (delete e es) ++ " are hard, let's go shopping!") es
16:07:32 <lambdabot>   ["ML and Lisp are hard, let's go shopping!","Haskell and Lisp are hard, let...
16:07:38 <DanBurton> lol
16:07:43 <ocharles> sigh, can we also maybe reduce the spam here?
16:07:54 <DanBurton> sorry ocharles
16:08:20 <DanBurton> does lambdabot do hayoo?
16:08:25 <DanBurton> @hayoo expat-enumerator
16:08:25 <lambdabot> Unknown command, try @list
16:08:26 <shachaf> No.
16:08:29 <kmc> you can private-message lambdabot
16:08:57 <byorgey> msieradzki: I'm pretty sure I've heard someone ask that before and the answer is "yes".  But I don't know what it is. =)
16:09:32 <ocharles> cbarrett: well I kinda get enumerators and stuff, but I don't get why all the xml stuff seems to be enumerators - shouldn't they be iteratees that take a byte string or something?
16:09:59 <ocharles> hrm, they are enumeratees in libxml actually, so I'm wrong there :)
16:10:30 <cbarrett> ocharles: I was just making a joke
16:10:44 <cbarrett> many packages have 0 documentation other than haddock and a link to a paper.
16:11:14 <DanBurton> cbarrett: try the user guide? http://www.haskell.org/cabal/users-guide/
16:11:29 <ocharles> sadly I'm too used to snap's fantastic documentation
16:11:36 <cbarrett> DanBurton: I'm good, it was a continuation of a conversation up above.
16:11:39 <cbarrett> thanks for being helpful tho :)
16:11:40 <shachaf> Snap's documentation wasn't very fantastic when I tried to use it.
16:11:50 <msieradzki> actually it seems to be calling gcc -x c++ which should be same as g++, I think so at least
16:12:00 <DanBurton> oops i meant msieradzki
16:12:01 <ocharles> shachaf: i find it more extensive than http://hackage.haskell.org/packages/archive/libxml-enumerator/0.5/doc/html/Text-XML-LibXML-Enumerator.html :)
16:12:09 <cbarrett> (ocharles asked about documentation, I told him to "just read the paper ;)")
16:12:29 <Jafet> msieradzki: No, probably not
16:12:36 * hackagebot couchdb-enumerator 0.3.1 - Couch DB client library using http-enumerator and aeson  http://hackage.haskell.org/package/couchdb-enumerator-0.3.1 (JohnLenz)
16:12:44 <Jafet> I don't know if the difference matters here, though
16:13:22 <Jafet> cbarrett: "it was hard to write..."
16:17:26 <msieradzki> it said somewhere that virtual classes in C++ which only have inline virtuals generate vtable symbol in .o where used so I was wondering if cabal->gcc call was messing something up
16:25:06 <DanBurton> @wiki lambdabot
16:25:07 <lambdabot> http://www.haskell.org/haskellwiki/lambdabot
16:26:26 <Jafet> @wiki aoeuidh
16:26:27 <lambdabot> http://www.haskell.org/haskellwiki/aoeuidh
16:43:01 <DanBurton> someone say something >.>
16:43:16 <HugoDaniel> :)
16:43:49 <DanBurton> @src fix
16:43:49 <lambdabot> fix f = let x = f x in x
16:44:03 <HugoDaniel> :D
16:45:18 <slack1256> fix fix fix. when laziness at work
16:48:48 <madhadron> The Python, it burns!
16:49:30 <mike-burns> I what?
16:51:28 <madhadron> <shrugs> Just me sounding off about the nuisances of programming in a language with inconsistent copy semantics, broken scoping rules, and basically no static assertion about anything.
16:52:02 <kmc> try #python
16:52:05 <dolio> That's what the unit tests are for, bro.
16:52:15 <dolio> And the behavior driven development.
16:52:47 <Jafet> Python is merely constrictive.
16:52:51 <madhadron> dolio, Yeah, that's assuming you're not stuck writing inside SCons as if it were a language and calling external programs that may take an hour to run.
16:53:12 <dolio> You don't sound very agile.
16:53:25 <madhadron> Anyway, sorry, was just trying to put some noise in the channel for DanBurton.
16:53:34 <madhadron> dolio, Nope.
16:53:45 <madhadron> I can't even run a debugger on anything in this mess.
16:53:53 * madhadron did not choose the tools on this project.
16:54:06 <dmwit> Call Haskell from scons.
16:54:09 <dmwit> DO EEEET
16:54:27 <madhadron> dmwit, Well, it is calling OCaml in several places...
16:54:42 <dmwit> CAALL AGDA FROM OCAML AND USE THE HASKELL FFI
16:55:16 <dmwit> Then plumb in some assembly using a weird calling convention so the inner loop goes 0.0001% faster.
16:55:19 <madhadron> I know I'm screwed.  That almost sounded like a sensible idea for a moment.
16:55:25 <dmwit> I'm sure you can work PHP in somehow.
16:59:15 <mike-burns> Or write small, unit tested methods in a library and call them from inside SCons?
16:59:23 * mike-burns goes back to what he was doing.
17:01:01 <dmwit> What is this, robust software design practices?
17:01:08 <dmwit> We don't like your kind here...
17:04:22 <madhadron> mike-burns: God, I wish...
17:04:47 <madhadron> I've actually done that for a large amount of stuff
17:04:59 <madhadron> But then there's that last layer of getting stuff bound into SCons
17:05:16 <madhadron> which is basically it's own language that happens to resemble Python
17:05:17 <madhadron> but with all elegance and ease of use removed
17:06:41 <mike-burns> Ah. Well, yeah, you're stuck there.
17:10:58 <heatsink> It's so hard to get a stack trace for errors
17:11:05 <heatsink> error "This is an error" is a CAF
17:11:29 <mike-burns> Rumor has it that they're working on that.
17:11:45 <Jafet> Pretty sure ghc can do stack traces; see the manual
17:11:46 <heatsink> That's good news
17:11:54 <Jafet> It needs to do that to get call graphs
17:12:10 <Jafet> There's also some option to use it for debugging
17:12:55 <heatsink> I'm using +RTS -xc
17:15:00 <Jafet> Probably some way to prevent it become a CAF, too
17:15:22 <Jafet> Perhaps myError _ = error -- and don't inline it
17:15:49 <Jafet> But frankly, all this doesn't sound like the best way to debug anything
17:16:18 <mike-burns> Depends on the context.
17:19:04 <dmwit> Huh, all this time I thought scons was just a library for Python.
17:19:11 <edwardk> hrmm ghc 7.2 default definitions are pretty nifty
17:19:25 <dmwit> What's a default definition?
17:19:28 <copumpkin> are they documented?
17:19:38 <edwardk> http://www.haskell.org/haskellwiki/Generics (bottom)
17:20:18 <Peaker> dmwit: it's a python implementation of a build system, isn't it?
17:20:31 <dreixel> they are in the user's manual too
17:20:35 <edwardk> class Functor f where fmap :: (a -> b) -> f a -> f b; default fmap :: Applicative f => (a -> b) -> f a -> f b; fmap f ma = pure f <*> ma
17:20:43 <dreixel> I'm happy people are finding uses other than for generic programming
17:20:59 <edwardk> you can only pick one thing to get your default definition, but it is fairly interesting
17:21:11 <dmwit> Peaker: What's got me confused is madhadron's comment that scons is its own language that resembles Python.
17:21:15 <edwardk> in my case i have a lot of classes that usually just lift but occasionally do something more interesting
17:21:16 <dmwit> I thought it really was Python.
17:21:26 <edwardk> i'm thinking about using them in trifecta for all the classes that look like
17:21:32 <edwardk> foo = lift foo; bar = lift . bar; etc
17:21:49 <ben> dmwit: How about "DSL embedded into python"?
17:22:00 <Peaker> dmwit: ah.. does scons assume the dependency tree is static (i.e: The Build actions are Applicative, and not Monad)?
17:22:14 <dmwit> Peaker: Heck if I know.
17:22:22 <edwardk> wow. gll is pretty easy with laziness
17:22:59 <cbarrett> what's the difference between the above linked generics (apparently built in to GHC 7.2) and the SYB generics?
17:23:00 <edwardk> and i can mix it with monadic parsing
17:23:17 <edwardk> cbarrett: you get a lot more information about constructor names, etc.
17:23:17 <Peaker> dmwit: most build systems make that mistake :(
17:23:50 <cbarrett> edwardk: go on, if you don't mind?
17:23:57 <dreixel> cbarrett: they're rather different. the new generic mechanism is "more typed"
17:24:05 <dreixel> the generic representation is as the type level
17:24:11 <cbarrett> ah. Interesting.
17:24:14 <dreixel> so it avoids the need for runtime cast, which syb does all the time
17:24:20 <cbarrett> right right.
17:24:22 <cbarrett> that's interesting.
17:24:52 <edwardk> well, that saves me the trouble of a response ;)
17:26:12 <cbarrett> I'm in the process of writing Haskell bindings for XPC (a new IPC lib from Apple). Generics seem useful.
17:27:39 <cbarrett> Right now the Haskell types that can be marshaled are all instances of a typeclass.
17:28:00 <cbarrett> Didn't end up playing nice w/ QuickCheck & Arbitrary though, so I defined an ADT in my tests and instantiated Arbitrary for that.
17:28:10 <cbarrett> Ended up with a bunch of boilerplate cod :(
17:28:12 <cbarrett> *code
17:28:24 <hpaste> “Louis L.” pasted “MergeSortP” at http://hpaste.org/51684
17:28:54 <Louis11> Trying to get MergeSortP working (passing in a function). However, I'm not sure if my code is anywhere close to correct
17:29:16 <Louis11> I believe it should work, however i get: Couldn't match expected type `[a]' with actual type `[a0] -> [a0]'
17:29:16 <Louis11>     In the return type of a call of `mergeP'
17:29:48 <dreixel> cbarrett: in principle, even a generic instance for Arbitrary can be given
17:30:11 <Louis11> nvm I think I see it, missed the function call
17:31:37 <Louis11> Ok that fixed one error, now I get Couldn't match expected type `[a]' with actual type `[a0] -> [a0]' on In the expression: mergeP f (mergeSortP as) (mergeSortP bs)
17:31:56 <cbarrett> dreixel: Interesting. I wondered about that since they implemented generic Shrink in SYB with class.
17:32:14 <cbarrett> (Of course, NOT having the ADT in the first place would also be nice, heh)
17:38:41 <ivanm> it seems that using enumerator is slower than lazy I/O :/
17:39:12 <Jafet> But Lazy I/O Is Wrong
17:39:16 <ivanm> all I want to do is map a serialisation function over a list of values and write them to disk whilst counting how many values there are!
17:39:59 <Jafet> Wait, writing with lazy I/O?
17:40:09 <ivanm> yup
17:40:42 <ivanm> all I'm doing is taking in parameters via the arguments to the program, using a (pure) function to generate a list of values, then writing them out to disk whilst counting how many values there are
17:41:24 <Jafet> CPS usually worksforme
17:41:25 <Louis11> applied to three arguments but its type `(a0 -> a0 -> Bool) -> [a0] -> [a0]' has only two. I can't seem to figure this error out. My definition has (a -> a -> Bool) -> [a] -> [a]. Wouldn't this imply two arguments? I don't see how mergeSortP reverences three arguments?
17:41:52 <ivanm> Jafet: to do what?
17:41:56 <hpaste> Louis11 pasted “MergeSortP2” at http://hpaste.org/51685
17:42:47 <Jafet> go (x:xs) acc = write x >> go xs (acc+1)
17:43:11 <ivanm> Jafet: yeah, I've done that
17:43:29 <Jafet> So you call that lazy I/O?
17:43:49 <ivanm> well, by "write" you're referring to appending to a file or something?
17:43:50 <ivanm> if so, yes
17:43:55 <ivanm> how is that CPS though?
17:44:07 <ivanm> Louis11: is that the error from ghc[i] ?
17:44:12 <ivanm> if so, what line number?
17:44:17 <Jafet> Heh, how is that lazy I/O?
17:44:19 <dolio> Lazy I/O only really refers to the I part.
17:44:38 <ivanm> Jafet: well, what do _you_ refer to as Lazy I/O ?
17:45:09 <Jafet> The presence of unsafeInterleave is a reliable indicator
17:45:13 <ivanm> dolio: oh, so lazy I/O isn't bad if you're only doing output?
17:45:30 <dolio> If you're only doing output, you're not doing lazy I/O.
17:45:51 <ivanm> Jafet: I thought that oleg's examples of iteratees weren't using unsafeInterleaveIO for lazy I/O
17:45:54 <ivanm> dolio: *nod*
17:45:56 <ivanm> OK then
17:46:31 <ivanm> but it does mean I'm kind of wasting the whole point of using binary since I'm creating lots of little bytestrings rather than one bytestring
17:46:53 <dolio> Lazy I/O refers to the kind of "give me the contents of this file" that, behind the scenes, only reads when it's actually required to produce stuff for you to look at.
17:46:54 <ivanm> because if I try to do the counting within the Put monad it blows up the memory :s
17:47:03 <Jafet> I thought it was cheap to create ByteStrings from other ByteStrings.
17:47:19 <copumpkin> depends how
17:48:00 <ivanm> Jafet: well, I've ended up basically applying a (a -> ByteString) function over the list, then doing the writing and counting as a loop in IO
17:48:10 <dolio> Output has no comparable situation. It's a sink that you can just dump to.
17:48:11 <ivanm> so I'm not combining the ByteStrings
17:48:33 <ivanm> if I try and do so beforehand, then I end up with memory problems
17:48:35 <ivanm> dolio: *nod*
17:49:39 <Jafet> Unless you take other programs into account
17:49:54 <Jafet> Or if you do silly things like open a pipe to yourself
17:49:59 <ivanm> heh
17:50:32 <heatsink> http://en.wikipedia.org/wiki/Delay_line_memory
17:50:40 <Jafet> You could do it by Chunk, instead of by byte?
17:50:46 <Jafet> Oh, nevermind.
17:55:06 <Louis11> ivanm: Sorry, hadn't checked IRC in a sec. I figured it out. I was passing in too many lists by accident
17:55:11 <Louis11> code is working :)
17:55:12 <ivanm> heh
17:55:20 <Louis11> such a dumb error on my part lol
17:55:43 <Louis11> insertionSort = foldr insert []
17:55:49 <ivanm> dolio: so if I wanted to do the inverse (reading in a list of serialisations) then I should think about using iteratees?
17:55:53 <Louis11> Does foldr provide the Ord a somehow?
17:56:07 <Louis11> of Ord a => [a] -> [a]
17:56:10 <ivanm> Louis11: no
17:56:10 <Jafet> @type foldr
17:56:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:56:12 <Jafet> @type insert
17:56:13 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
17:56:22 <Jafet> @type [] -- for good measure
17:56:24 <lambdabot> forall a. [a]
17:56:46 <dolio> ivanm: Maybe. I'm not a huge iteratee fan. But depending on your requirements, they may be the right thing.
17:56:54 <ivanm> what do you prefer?
17:56:58 <Louis11> so if I wanted to use foldr to find the max of a list, how would I make it satisfy Ord a => [a] -> a?
17:57:04 <Louis11> anything I do gives me a type error
17:57:14 <ivanm> Louis11: ummmm.... that depends on your fold function
17:57:17 <ivanm> not on the foldr
17:57:23 <Louis11> tried foldr max 0
17:57:31 <Jafet> @type foldr max 0
17:57:32 <lambdabot> forall a. (Ord a, Num a) => [a] -> a
17:57:33 <dolio> If what you're doing is simple enough, I think lazy input is fine. If not, iteratees are probably the best thing out there.
17:57:41 <ivanm> *nod*
17:57:43 <Jafet> There you go, Ord constraint.
17:57:45 <Louis11> foldr max 0 [] it looks like
17:57:52 <Louis11> tried that in ghci and it worked
17:57:57 <ivanm> Louis11: why do you want the [] ?
17:58:08 <oldwzd> is it possible to make xmobar transparent? (background color of it only)
17:58:37 <Louis11> ivanm: Not really sure . . .
17:58:44 <Louis11> hm
17:58:48 <ivanm> oldwzd: don't think so
17:59:01 <ivanm> oldwzd: but you may get more responses in #xmonad
17:59:24 <Louis11> ivanm: Althought foldr max 0 [1,2,3] worked in ghci, that doesn't work in my function
17:59:29 <oldwzd> yah, asked but ppl tend to be more awake here xD
17:59:32 <Jafet> A better question is why you think that foldr max 0 gives the maximum of any list.
17:59:44 <Jafet> Would it produce the maximum of a list of strings?
18:00:00 <ivanm> Jafet: well, any list of non-negative numbers (if you allow maximum [] = 0)
18:00:02 <ivanm> but yeah
18:00:03 <Louis11> Jafet: I'm not sure, can you compare string by alpha order?
18:00:03 <Jafet> What is the maximum of an empty list?
18:00:11 <ivanm> @src maximumBy
18:00:12 <lambdabot> Source not found. I feel much better now.
18:00:13 <incluye> 3
18:00:16 <ivanm> @src maximum
18:00:16 <lambdabot> maximum [] = undefined
18:00:16 <lambdabot> maximum xs = foldl1 max xs
18:00:31 <ivanm> yeah, foldl is probably better
18:00:37 <Louis11> ivanm: I tried something similar earlier
18:00:40 <Jafet> Look, when you see forall a. (Ord a), it really means forall a. (Ord a). Not forall number types that contain 0.
18:01:01 <Louis11> Jafet: gotcha
18:01:18 <Jafet> Besides that, is the maximum of an empty list 0? Is the maximum of a list of negative numbers 0?
18:01:36 <dolio> > maximum []
18:01:37 <lambdabot>   *Exception: Prelude.maximum: empty list
18:01:44 <Louis11> Jafet: Definitely not, I just presumed that max would compare to 0 or something
18:01:49 <Louis11> not sure exactly what I was thinking
18:01:50 <incluye> > maximumBy []
18:01:51 <lambdabot>   Couldn't match expected type `a -> a -> GHC.Ordering.Ordering'
18:01:52 <lambdabot>         agai...
18:01:54 <incluye> hm
18:02:07 <ivanm> > maximumBy const []
18:02:08 <lambdabot>   *Exception: List.maximumBy: empty list
18:02:23 <Jafet> Heh
18:02:36 <Louis11> huh, foldl1, interesting
18:04:23 <ivanm> Louis11: note that you generally only use foldr when you want the laziness or to keep the ordering of the original list
18:04:36 <ivanm> since you need to traverse the entire list, a left-fold is better
18:05:23 <Louis11> alright cool, I was a bit confused as to why one was preferential to the other
18:05:24 <Peaker> ivanm: I don't think that's the criterion for when foldl is better..
18:05:59 <ivanm> Peaker: well, in general isn't a left-fold over a list better than a right-fold memory-wise?
18:06:43 <Peaker> ivanm: I am not sure.. what of   foldr (++) []  ?  Even if you always use the entire list, a foldr is preferable
18:06:52 <ivanm> true
18:07:03 <ivanm> but in that case you want to keep the original list ordering
18:07:04 <Peaker> it depends on whether the operation is strict, mostly, I think
18:07:17 <ivanm> didn't I mention laziness? ;)
18:07:37 <dolio> > foldl (++) [] [[1,2,3],[4,5,6],[7,8,9]]
18:07:39 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:07:50 <Peaker> it also depends on whether the operation is more/less efficient when used left or right associatively (and (++) is more efficient right-associatively)
18:08:15 <ivanm> dolio: duh, right
18:08:27 <Jafet> > length $ foldl1 (++) $ return <$> [0..99999]
18:08:31 <lambdabot>   mueval-core: Time limit exceeded
18:08:33 <Jafet> > length $ foldr1 (++) $ return <$> [0..99999]
18:08:35 <lambdabot>   100000
18:09:57 <slack1256> @where functional pearls
18:09:58 <lambdabot> I know nothing about functional.
18:10:05 <slack1256> @where pearls
18:10:05 <lambdabot> I know nothing about pearls.
18:10:10 <ivanm> @google haskell functional pearls
18:10:12 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
18:10:12 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
18:10:17 <ivanm> slack1256: ^^
18:10:37 <slack1256> yes, read the soduko solver, for a nice tutorial or how to use foldr and foldl
18:10:56 <Jafet> http://foldr.com http://foldl.com
18:11:06 <Jafet> Darn
18:11:10 <ivanm> I don't recall bird's sudoku solver covering foldr vs foldl
18:11:17 <ivanm> though admittedly I haven't read it in depth for a while
18:11:38 <slack1256> maybe i recall wrongly
18:11:52 <slack1256> yes sorry, it was the cartesian multiplication one!
18:12:16 <Jafet> subsequences has an interesting use of foldr
18:12:19 <Jafet> @src subsequences
18:12:19 <lambdabot> Source not found. Sorry.
18:12:37 <Jafet> Working it out is a nice puzzle
18:13:04 <slack1256> i need to learn how to use laziness to my advantage.
18:13:13 <slack1256> instead of "oh. that"
18:13:23 <slack1256> and functional pearls seems to be the place to go
18:15:28 <kmc> @hoogle (MonadPlus m) => Bool -> m a -> m a
18:15:29 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
18:15:29 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
18:15:29 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
18:15:47 <kmc> :t \b x -> guard b >> return x
18:15:48 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
18:16:28 <ivanm> preflex: seen chrisdone
18:16:28 <preflex>  chrisdone was last seen on #haskell 5 hours and 29 seconds ago, saying: the time performance is reliable
18:16:50 <ivanm> @tell chrisdone when running cabal-install via haskell-emacs, I tend to get a fair number of errors like: error in process filter: Format string ends in middle of format specifier
18:16:51 <lambdabot> Consider it noted.
18:18:31 <kmc> @pl \b x -> guard b >> return x
18:18:32 <lambdabot> (. return) . (>>) . guard
18:19:28 <Louis11> So can I not do like if (c >= a) and (c < b) then . . . else . . . ?
18:20:03 <Louis11> It works when I have just (c >= a) but when I try and do "and (c < b)" it gives me an error about being applied to too many arg
18:20:20 <ski> Louis11 : `if c >= a && c < b then ... else ...' ?
18:20:30 <ski> @type (&&)
18:20:31 <lambdabot> Bool -> Bool -> Bool
18:20:32 <ski> @type and
18:20:33 <lambdabot> [Bool] -> Bool
18:20:48 <Louis11> ah thanks
18:21:06 <hpaste> ocharles pasted “http request never terminates” at http://hpaste.org/51686
18:21:24 <ocharles> Hey, can anyone work out why http://hpaste.org/51686#line61 seems to just block?
18:21:32 <Jafet> Even if and was (&&), you'd have to use it as `and`.
18:21:54 <ocharles> if I load the file into ghci, simpleHttp "http://google.com" is fine, but when I run 'main' it just freezes at "Got Man"
18:22:02 <ocharles> (http://hpaste.org/51686#line69)
18:22:23 <ocharles> I've tried index `mapM_` events, and that too only gets as far as trying to call index on one event
18:22:28 <ocharles> I don't really get what's up :/
18:22:38 <ocharles> (and yes, the code is a mess :>)
18:22:58 <JoeyA> let xs = foldl' (\a x -> a . (x:)) id [1..10000000 in xs []
18:23:02 <JoeyA> Why doesn't that stack overflow?
18:23:17 <JoeyA> (I deliberately inserted a syntax error to prevent someone from accidentally OOM-killing themselves)
18:23:56 <JoeyA> After all the compositions, won't there be a huge spine to traverse or something to get to the first item?
18:25:33 <Jafet> My ghci always runs with ulimit
18:26:37 <Jafet> Doesn't ghc allocate call frames on the heap?
18:26:54 <JoeyA> If it does, why are stack overflows possible?
18:27:10 <c_wraith> stack overflows come from expression evaluation, not function calls
18:28:04 <simon> I have: let x = read $ liftIO getLine -- and I get Couldn't match expected type `Char' against inferred type `[Char]'  Expected type: IO Char  Inferred type: IO String
18:28:16 <Jafet> > let xs = foldl' (\a x -> a . (x+)) id [1..10^6] in xs 0
18:28:17 <simon> why does it expect Char and not [Char], I wonder.
18:28:20 <lambdabot>   *Exception: stack overflow
18:28:31 <kmc> why would you be able to read an IO String, i wonder
18:28:39 <kmc> that's the clearer type error to me
18:28:46 <kmc> are you sure it's not read <$> liftIO getLine?
18:28:48 <Jafet> JoeyA: as you can see, [Integer] is non-strict, Integer isn't
18:29:12 <Jafet> The stack is required because you can't have a part-Integer lying around
18:30:26 <JoeyA> Jafet: After the compositions in my example, I want to know how it gets the first item without using stack to unbury the first item.
18:30:48 <JoeyA> (err, the first operation in the composition chain)
18:30:55 <Jafet> (1:) . f [] = 1 : f [] = 1 : something
18:31:01 <Jafet> (1:) . f $ [], that is
18:31:09 <Jafet> By definition of (.)
18:32:22 <JoeyA> This is what the fold produces: (1:) . (2:) . (3:) . (4:) . ... (1000000:) . id
18:32:52 <JoeyA> Since it's a left fold, I would expect it to be constructed like this:
18:33:04 <JoeyA> (1:) . (2:)
18:33:09 <JoeyA> ((1:) . (2:)) . (3:)
18:33:14 <JoeyA> (((1:) . (2:)) . (3:)) . (4:)
18:33:15 <JoeyA> etc
18:33:56 <JoeyA> I'm trying to figure out why evaluating ((((1:) . (2:)) . (3:)) . (4:)) [] works in constant stack space, apparently.
18:34:40 <swarles> what does <|> do?
18:34:48 <JoeyA> @hoogle Alternative
18:34:48 <lambdabot> Control.Applicative class Applicative f => Alternative f
18:34:49 <lambdabot> Language.Haskell.ParseMonad alternative :: Lex a v -> Lex a (Lex a v)
18:34:55 <JoeyA> swarles: In what context?
18:34:59 <Jafet> Oh, in that case you should get a stack overflow when it's large enough
18:35:02 <ski> @type (<|>)
18:35:03 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
18:35:13 <JoeyA> Jafet: But I don't.
18:35:28 <hpaste> swarley pasted “What does <|> do?” at http://hpaste.org/51687
18:35:32 <ski> swarles : it's like `mplus', but for `Applicative', instead of for `Monad'
18:35:59 <JoeyA> In Parsec, if the first parser fails, it tries the second parser.
18:36:07 <swarles> Oh, ok
18:36:11 <swarles> That makes sense
18:36:13 <JoeyA> swarles: But wait, there's more
18:36:14 <ski> swarles : ok, in the parser case, it constructs a compound parser that will try both of the argument parsers, when parsing
18:36:34 <JoeyA> In Parsec, if the first parser fails after consuming input, it won't recover.  See 'try'.
18:36:48 <swarles> o.o
18:37:06 <JoeyA> For example, string "foo" <|> string "for" will fail if the input is "for"
18:37:14 <azaq23> (<|>) in parsec is not the (<|>) from Control.Applicative, it just has the same name
18:37:23 <kmc> but you can use either
18:37:24 <Louis11> So what's the best way to see if a string only contains certain characters? For example,  if we only allow a, b, c then "abc" would be valid but "abcd" would not
18:37:24 <Jafet> > let xs = foldl' (\a x -> a . (x:)) id [1..10^6] in length (xs [])
18:37:27 <lambdabot>   1000000
18:37:32 * ski idly wonders whether swarles is working though "Write Yourself a Scheme in 48 Hours"
18:37:40 <Jafet> > let xs = foldl' (\a x -> a . (x:)) id [1..10^7] in length (xs [])
18:37:43 <swarles> I am haha
18:37:45 <lambdabot>   mueval-core: Time limit exceeded
18:37:47 <JoeyA> You'll need to say (try $ string "foo") <|> string "for"
18:37:53 <JoeyA> (in that case)
18:38:19 <JoeyA> When I found out about this facet of Parsec, I was distraught.
18:38:23 <swarles> Im planning on taking more than 48 hours to do this >_>
18:38:28 <JoeyA> I thought Parsec was a parser generator.
18:38:37 <simon> kmc, I'm not sure I understand <$> or pure just yet. if I want to read an Int from stdin, must it be an IO Int?
18:39:02 <kmc> an IO Int is not an Int
18:39:03 <swarles> Its rather difficult to grasp all of what haskell has to offer, coming from ruby its all greek to me x_x
18:39:07 <kmc> nor is it anything like an Int
18:39:14 <kmc> so the answer is "no", but i think that's not what you're really asking
18:39:24 <ski> > all (`elem` "abcd") "abc"  -- Louis11
18:39:25 <kmc> did you read http://www.haskell.org/haskellwiki/Introduction_to_IO
18:39:25 <lambdabot>   True
18:39:27 <simon> kmc, no, I suppose what I want is an Int from an IO String that looks like an Int.
18:39:32 <simon> kmc, I'll go do that.
18:39:35 <JoeyA> I prefer to think of Parsec as writing a recursive descent parser, just with a nicer language.
18:39:46 <kmc> an IO String looks like an imperative program as a first-class value.  it does not look like a String or an Int
18:40:01 <kmc> running that program more than once can produce different strings each time
18:40:18 <ski> JoeyA : yeah, `(<|>)' and `try' in Parsec are irksome
18:40:22 <ash__> anyone know any decent math libraries for interacting with really large numbers?
18:40:33 <c_wraith> what kinds of numbers?
18:40:38 <ash__> > log (foldr1 (*) [1..1000])
18:40:39 <c_wraith> and what kinds of interactions?
18:40:40 <lambdabot>   Infinity
18:40:47 <ash__> log?
18:40:54 <ash__> with really big integers?
18:41:05 <c_wraith> log's codomain isn't integers...
18:41:17 <cbarrett> ski: irksome how?
18:41:22 <c_wraith> you're actually running that on doubles
18:41:24 <Jafet> Nor its domain
18:41:27 <Jafet> @type log
18:41:28 <lambdabot> forall a. (Floating a) => a -> a
18:41:31 <ash__> ya, sorry my bad
18:42:01 <ski> cbarrett : that you have to use `try' to get true nondeterminism
18:42:10 <simon> kmc, I'm writing this state machine and trying to make read/write support. so it seems supporting read forces me to change the types everywhere those input values might end up. I see the sense in that, although it seems tedious,.
18:42:23 <kmc> you don't have to simon
18:42:29 <kmc> well, hmm
18:42:31 <kmc> i guess you do
18:42:42 <kmc> a fuzzy way to put it is that impure code can call pure code but not vice versa
18:42:45 <simon> right now I've got Ints everywhere.
18:42:57 <kmc> that doesn't really describe what's going on, though
18:43:21 <kmc> Haskell functions are always pure; some of them return "IO actions" which describe how IO *could be* performed
18:43:28 <kmc> but applying the function never does IO, no matter what the type says
18:43:49 <cbarrett> ski: nondeterminism? isn't try just lookahead?
18:44:32 <Jafet> No, try is backtracking.
18:44:42 <c_wraith> simon: I think you're making this too hard.  everything except the operation to get input and apply the state transition for that input can be pure.  That means everything that manipulates the state machine in every way *except* for getting the input can be pure.
18:44:45 <Jafet> Parsec is LL(1) by default.
18:46:07 <byorgey> simon: I agree with c_wraith.  The only things that should need to involve IO are the function for actually doing the reading, and an outer "driver" which runs the state machine.
18:46:32 <byorgey> most of the code for doing stuff with the state machine should not need to mention IO.
18:47:08 <simon> byorgey, I'm willing to assume that I'm simply structuring this in the wrong way.
18:47:23 <byorgey> @type let f x = x + 2 in readLn >>= print . f
18:47:24 <lambdabot> IO ()
18:47:30 <simon> c_wraith, so I'm trying to fill out the blanks in: let (x :: Int) = ... $ liftIO getLine -- and this can't be achieved, right?
18:47:52 <c_wraith> that's correct
18:47:56 <byorgey> simon: in my example above, notice that an input value "ended up" as an input to the function f, but f is pure
18:48:19 <byorgey> f does not need to know that its input value happened to come from the external world.
18:48:21 <ivanm> dammit, why is it (relatively speaking) computationally expensive to count how many elements are being written to disk rather than just writing them all to disk? :s
18:48:43 <simon> byorgey, oh!
18:48:46 <jmcarthur> because writing them to disk doesn't require much computation :P
18:48:56 <ivanm> jmcarthur: yeah
18:49:12 <c_wraith> heck, these days you can write to disk without even passing the data through the CPU.  That's handy :)
18:49:24 <Louis11> best way to get the first char in a string? I tried (head str) but that returns a [char]
18:49:27 <ivanm> jmcarthur: I think it's more that the writing is more efficient with one large lazy bytestring than lots of little writes for each small bytestring :s
18:49:41 <c_wraith> ah.  well that's also true
18:49:41 <simon> Louis11, then it's not a string, is it.
18:49:41 <JoeyA> > head "Hello"
18:49:42 * ski . o O ( `print . f =<< readLn' )
18:49:43 <lambdabot>   'H'
18:49:43 <ivanm> Louis11: if that's the case, then str isn't a string
18:49:47 <byorgey> > head "Louis11"
18:49:48 <lambdabot>   'L'
18:49:54 <JoeyA> > head ""
18:49:55 <lambdabot>   *Exception: Prelude.head: empty list
18:50:04 <ivanm> > listToMaybe ""
18:50:05 <lambdabot>   Nothing
18:50:06 <c_wraith> > head ["foo", "bar"]
18:50:07 <lambdabot>   "foo"
18:50:14 <ivanm> > listToMaybe "this is not a string"
18:50:15 <lambdabot>   Just 't'
18:50:39 <JoeyA> Is it possible to add an {-# INLINE #-} annotation to a class method, or will the method's definition need to be implemented separately?
18:50:48 <stribor> where is prefule file in ghci instalation
18:50:54 <monochrom> "foldl (\a x -> a . (x:)) id [1..blah] []" does not use a lot of stack. allow me to use f to stand for (\a x -> a . (x:)). here is the state after all the foldl's are gone: f (f (f (f id 1) 2) 3) 4 id []
18:51:49 <ivanm> stribor: why do you want to know?
18:52:09 <ski> .. hm, lazy output could perhaps be something where the program is only executed further when the consumer process at the other end demands more data
18:52:10 <monochrom> expanding the outer most f: ((f (f (f id 1) 2) 3) . (4 :)) id []
18:52:11 <stribor> ivanm: just curious....wanted to see function
18:52:13 <byorgey> stribor: if you mean Prelude, you can read its documentation here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html
18:52:21 <ivanm> stribor: you're better off seeing the documentation
18:52:21 <byorgey> stribor: there is also a link to see the source on that page
18:52:35 <ivanm> stribor: because the actual file would be a binary one, rather than textual
18:52:46 <stribor> ivanm: oh ok...thank you
18:52:55 <ivanm> but yeah, use the link byorgey gave you
18:53:11 <ski> @source Prelude
18:53:11 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
18:53:25 <monochrom> yikes, there are typos
18:53:35 <ivanm> monochrom: in the Prelude? :o
18:53:42 <ivanm> ski: I doubt that's correct any more though :/
18:53:54 <monochrom> the state after all foldl's are gone: f (f (f (f id 1) 2) 3) 4 []
18:54:19 <monochrom> expanding the outermost f: ((f (f (f id 1) 2) 3) . (4 :)) []
18:54:44 <monochrom> doing the . : f (f (f id 1) 2) 3 ((4:) [])
18:56:04 <JoeyA> @src (.)
18:56:04 <JoeyA> @source (.)
18:56:05 <lambdabot> (f . g) x = f (g x)
18:56:05 <lambdabot> NB: In lambdabot,  (.) = fmap
18:56:05 <lambdabot> (.) not available
18:57:27 <monochrom> anyway, every several steps, the expression takes on the form "f (big thing but shrinking) number (growing thing)" again. these several steps take a few (but constant) stack units to expand f, do the . , free the stack, and then it's the same deal all over again. so stack doesn't grow
18:58:38 <Louis11> are there any good tutorials on working with Strings? I'm trying to make sure a char only appears once, and check placement of Chars in the String (i.e. 'a' must appear after 'b')
18:58:39 <monochrom> after all f's are gone, you have (1:) ((2:) ((3:) ... which doesn't need much stack either if you're just printing it
18:59:09 <monochrom> i.e., it's of the form (number:) (big but shrinking thing) every several steps
18:59:43 <monochrom> (doesn't take a lot of stack to turn into number : big but shrinking thing, ready for printing one item)
18:59:50 <Jafet> Louis11: String is [Char]
19:00:08 <Jafet> That should be all you need
19:00:49 <Louis11> Jafet: But I don't really get how to count occurrences, or figure out char positions and what not
19:02:07 <Jafet> countOccurencesOf c [] = ...; countOccurencesOf c (x:xs) = ...
19:02:30 <Jafet> Or use Data.List
19:02:37 <byorgey> > length . filter (=='a') $ "abracadabra"
19:02:41 <lambdabot>   mueval-core: Time limit exceeded
19:02:46 <byorgey> > length . filter (=='a') $ "abracadabra"
19:02:49 <Jafet> Or that
19:02:49 <lambdabot>   5
19:03:27 <byorgey> Louis11: I suggest reading through the Data.List documentation to see what tools exist for working with lists
19:03:34 <byorgey> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html
19:04:03 <JoeyA> monochrom: Thanks, I think I get it now.
19:04:14 <byorgey> > findIndex 'b' "abracadabra"
19:04:15 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:04:16 <lambdabot>         against inferred ...
19:04:17 <Jafet> If he's at a total loss when working with lists, he shouldn't be doing that yet
19:04:24 <byorgey> > findIndex (=='b') "abracadabra"
19:04:25 <lambdabot>   Just 1
19:04:29 <Jafet> > elemIndices 'b' "abracadabra"
19:04:30 <lambdabot>   [1,8]
19:04:49 <byorgey> oh nice, I didn't even know about elemIndices =)
19:05:34 <Jafet> I suggest reading through the Data.List documentation to ...
19:06:07 <Louis11> doing that now, thanks guys
19:06:21 <dalaing> there's a summary of Data.List in LYAH as well, if that's your style
19:06:42 <copumpkin> @hoogle elemIndices
19:06:43 <lambdabot> Data.ByteString elemIndices :: Word8 -> ByteString -> [Int]
19:06:44 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
19:06:44 <lambdabot> Data.ByteString.Char8 elemIndices :: Char -> ByteString -> [Int]
19:07:11 * JoeyA will have to get around to improving the Uncyclopedia article for Haskell.
19:07:53 <Jafet> monochrom: why does it heap overflow then, allocating frames for fs?
19:08:39 <monochrom> no, growing chain of (3:) ((4:) ((5:) ((6:) ((7:) (...
19:09:07 <Jafet> But if you fold it, then those get reduced lazily
19:09:12 <monochrom> otoh some other thunk is shrinking so they should balance out
19:09:20 <ivanm> @hoogle (Monoid b) => (a -> b) -> [a] -> b
19:09:21 <lambdabot> Data.Traversable foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
19:09:21 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:09:21 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
19:09:34 <Jafet> Assume we're starting from [a..b]
19:09:42 <ivanm> is foldMap f = mconcat . map f ?
19:09:43 <monochrom> otoh foldl builds a big thing first
19:10:03 <Jafet> foldl' as well, because seq (f.g) is (f.g)
19:12:49 <Jafet> @type (mconcat .) . map
19:12:50 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
19:13:41 <Jafet> Needs toList before that
19:14:35 <ivanm> well, I meant for lists
19:15:28 <Jafet> Oh, what's the harm in an extra id
19:16:02 <ivanm> I just wanted something to replace (mconcat .) . map
19:16:13 <DukeDave> Hmm, so it looks like I'm about to marshal this object into Haskell: http://docs.wxwidgets.org/2.9.2/classwx_any.html
19:16:23 <DukeDave> "The wxAny class represents a container for any type.   Its value can be changed at run time, possibly to a different type of value."
19:16:37 <ivanm> yay :s
19:16:50 <DukeDave> So this is going to be interesting :|
19:17:01 <Jafet> Be thankful it isn't Prim.Any
19:17:53 <Jafet> Wait, I thought you were talking about wxHaskell
19:18:28 <DukeDave> Jafet: Indeed I am
19:18:44 <DukeDave> And I'm not quite sure how I'm going to approach this
19:19:21 <Jafet> When in doubt, add more pointers
19:19:41 <DukeDave> The fun version would be to have an enum of type which my wxAny can support, and pass that through so we can return the right type
19:20:53 <Jafet> I believe they actually came up with that back in the day when C++ compilers were crap and couldn't be used for advanced polymorphism
19:21:16 <Jafet> So you basically have C-in-C-with-classes
19:22:05 * DukeDave looks blankly 
19:27:25 <DukeDave> Ooh, class Typeable
19:29:11 <Jafet> Are you religious? This is no better time to start.
19:47:23 <JoeyA> Woot, Haddock doesn't get smart with me when I try to do @&lt;@
19:47:56 <JoeyA> (try sending HTML entity strings in an email some time)
19:54:56 <ivanm> JoeyA: why are you using HTML literals in your markup?
19:55:12 <ivanm> if you want un-escaped <, escape it: \<
19:55:51 <monochrom> actually, haddock honours &#60;
19:56:02 <JoeyA> ivanm: I want it to actually say "&lt;", not "<"
19:56:11 <ivanm> oh, fair enough :p
19:56:27 <monochrom> &amp;lt;
19:56:32 <JoeyA> Apparently, people are hard-wired HTML parsers, too :D
19:56:38 <ivanm> monochrom: yeah
19:57:10 <DukeDave> Boo, why isn't CString Typeable :'(
19:57:49 <monochrom> because it's some Ptr thingy. is Ptr thingy Typeable?
19:58:24 <JoeyA> It's not behind the green glass doors.
19:58:59 <JoeyA> I'm tempted to make an Acme.GreenGlassDoors module.
19:59:06 <DukeDave> monochrom: Ptr is Typeable1
19:59:08 <JoeyA> class GreenGlassDoors a where ...
19:59:19 <JoeyA> instance GreenGlassDoors Bool
19:59:32 * DukeDave may be losing the plot
19:59:58 <ivanm> JoeyA: the purpose of which is... ?
20:00:43 <JoeyA> ivanm: Hence Acme :P
20:00:48 <monochrom> type CString = Ptr CChar.  Ptr CChar is typeable. as Ptr CChar.
20:00:58 <tgeeky> this is science, it doesn't need to have a purpose!
20:00:59 <ivanm> JoeyA: I meant GreenGlassDoors
20:01:08 <ivanm> what is that meant to be referencing?
20:01:16 <JoeyA> It's a word game.
20:01:23 <ivanm> oh
20:01:25 <JoeyA> Some words are behind the "green glass doors", others aren't.
20:01:37 <JoeyA> Apples and cherries are behind the green glass doors.
20:01:55 <JoeyA> Bananas and pears are not.
20:02:08 <tgeeky> what happens if you take the red pill?
20:02:17 <monochrom> behind the green glass doors are green little people
20:02:25 <JoeyA> Pills are behind the green glass doors, but not red ones.
20:03:09 <JoeyA> Bool is the only Prelude type behind the green glass doors, as far as I can tell.
20:03:36 <monochrom> take the True pill or the False pill?
20:04:09 <JoeyA> classes are behind the green glass doors, but types aren't :(
20:04:22 <JoeyA> But don't worry, Haskell is behind the green glass doors, but Java is not!
20:04:54 <monochrom> use associated type families to get your types to be half-behind
20:05:12 <JoeyA> lol
20:05:57 <ivanm> preflex: seen sw17ch
20:05:57 <preflex>  sw17ch was last seen on #haskell 119 days, 5 hours, 55 minutes and 38 seconds ago, saying: fmap gorgonzola prosciutto
20:07:23 <DukeDave> JoeyA: Yuck, those games always used to make me rage when I was a kid
20:07:38 <slack1256> lazyIO isn't very reliable, right?
20:07:39 <DukeDave> I guess that isn't a bad variant
20:07:49 <JoeyA> > greenGlassDoors "associated type families"
20:07:50 <lambdabot>   Not in scope: `greenGlassDoors'
20:08:02 <JoeyA> > green_glass_doors "associated type families"
20:08:04 <lambdabot>   True
20:08:10 <slack1256> but when using lazy bytestrings for reading a file, do i have to read the whole file to memory in IO and them make it a lazy bytestring?
20:08:19 <byorgey> > green_glass_doors x
20:08:20 <lambdabot>   Couldn't match expected type `GHC.Base.String'
20:08:20 <lambdabot>         against inferred typ...
20:08:56 <edwardk> https://github.com/ekmett/trifecta/blob/master/wip/Rat.hs is a pretty simple bastard child of packrat/parsec i've been playing with
20:09:01 <byorgey> > map green_glass_doors . map (:[]) $ ['a'..'z']
20:09:03 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
20:09:10 <copumpkin> packsec
20:09:13 <copumpkin> parserat
20:09:19 <byorgey> > or $ map green_glass_doors . map (:[]) $ ['a'..'z']
20:09:20 <lambdabot>   False
20:09:30 <cbarrett> :info green_glass_doors
20:09:33 <JoeyA> > map green_glass_doors (sequence "abc")
20:09:34 <cbarrett> (will that work?)
20:09:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:09:42 <lambdabot>         against inferred ty...
20:09:42 <edwardk> i've just been going with 'rat' since it doesn't tend to pack as much as packrat ;)
20:09:48 <JoeyA> > map green_glass_doors (replicate 3 $ sequence "abc")
20:09:49 <lambdabot>   Couldn't match expected type `m a'
20:09:50 <lambdabot>         against inferred type `GHC.Types...
20:10:16 <edwardk> but basically i can use the monad for context-sensitivity and use the packrat rules for the insensitive parts that are worth memoizing
20:10:18 <byorgey> > map green_glass_doors (inits "abcdefg")
20:10:20 <lambdabot>   [False,False,False,False,False,False,False,False]
20:10:23 <cbarrett> what is green_glass_doors?
20:10:31 <JoeyA> I defined it by whispering to lambdabot.
20:10:34 <byorgey> cbarrett: that's what we're trying to figure out =)
20:10:37 <cbarrett> ahhhhhh
20:10:43 <cbarrett> carry on :)
20:10:48 <JoeyA> > map green_glass_doors (sequence $ replicate 3 ("abc" :: String))
20:10:50 <lambdabot>   [True,True,True,False,True,False,False,False,True,True,False,False,True,Tru...
20:11:04 <edwardk> main thing i was focused on was getting parsec-like backtracking, so it only backtracks on unconsumed input, etc.
20:11:39 <byorgey> > sequence $ replicate 3 "abc"
20:11:41 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
20:11:53 <edwardk> and punting packrat like backtracking to a separate p </> q = try p <|> q -- parser
20:12:14 <edwardk> which is useful for even parsec parsers
20:12:24 <byorgey> aha, I get it =)
20:12:34 <JoeyA> byorgey: (sequence . replicate n) is combinations for free.
20:12:46 <byorgey> > green_glass_doors "bookkeeper"
20:12:48 <lambdabot>   True
20:13:32 <ivanm> is there any equivalent of mapKeys for IntMaps?
20:13:44 <ivanm> or more specifically, mapKeysMonotonic
20:13:54 <edwardk> not really
20:14:02 <ski> edwardk :)
20:14:03 <kmc> > all green_glass_doors (words "green glass doors")
20:14:03 <ivanm> damn
20:14:05 <lambdabot>   True
20:14:07 <edwardk> in Set that can avoid restructuring at all
20:14:12 <edwardk> in IntSet it isn't as useful
20:14:14 <JoeyA> ;-)
20:14:23 <edwardk> you can win a little, but not asymptotically
20:14:28 <ivanm> I was thinking of switching from a normal Map to a wrapper around IntMap, but I need to be able to do that before a union
20:14:36 <ivanm> edwardk: what do you mean?
20:14:49 <edwardk> ivanm: intset is a patricia trie
20:14:55 <ivanm> yes
20:15:00 <ivanm> but what do you mean win a little?
20:16:07 <edwardk> you might be able to avoid some subset of the crit-bit tests
20:16:14 <ivanm> *nod*
20:16:24 <edwardk> but you don't change the asymptotics of just doing the naive insert
20:16:47 <ivanm> edwardk: how about fromAscList . map (first f) . toAscList ?
20:16:57 <ivanm> would that be reasonable?
20:17:07 <ivanm> what I'm doing is: a graph is represented as a Map
20:17:28 <edwardk> fromDistinctAscList if you can do it
20:17:58 <ivanm> to merge two graphs together, I first shift the keys in the second Map so there won't be any collisions, and then do a Map union
20:18:00 <edwardk> but both are O(n)
20:18:28 <edwardk> *nods*
20:18:37 <ivanm> well, mapKeysMonotonic on a normal Map would be O(n), wouldn't it?
20:18:45 <edwardk> do you need in-order traversal?
20:19:22 * DukeDave cries
20:19:33 <ivanm> edwardk: in what sense?
20:19:40 <DukeDave> Types and FFI and I try so hard and it's not fair
20:19:44 <edwardk> i mean could a hash map do?
20:19:57 <ivanm> well, I'll be wanting to do some traversal stuff later
20:20:10 * edwardk pats dukedave on the head and goes to say its all right and that it'll get better, but then realizes it probably won't.
20:20:13 <ivanm> the code is at: http://code.haskell.org/~ivanm/planar-graph/
20:20:28 <ivanm> I've even got ascii-art diagrams in my haddock! :p
20:20:45 <edwardk> well, re: traversal what i mean is does it matter if you get them out in order?
20:20:56 <DukeDave> edwardk: Thanks, I needed that..
20:21:05 <ivanm> edwardk: for merging, not really
20:21:16 <ivanm> as long as there's a (Node -> Node) function that's available
20:21:44 <edwardk> DukeDave: any time i can help, just ask. i may not actually help, but i'll be sure to note your suffering.
20:21:45 <ivanm> but I do need to be able to re-order later on (to check for isomorphisms: do a BFS re-ordering, and then serialise and compare)
20:21:56 <edwardk> ivanm: hrmm
20:21:59 <ivanm> @remember edwardk any time i can help, just ask. i may not actually help, but i'll be sure to note your suffering.
20:21:59 <lambdabot> Done.
20:23:05 <edwardk> now to finish my magic trick of polymorphic a packrat parser into a gll parser
20:23:10 <edwardk> er polymorphing
20:23:14 <DukeDave> edwardk: Ha, thanks
20:23:29 <JoeyA> In Haddock, is it possible to refer to make a link to a definition in another module without importing it?
20:23:45 <ivanm> JoeyA: no, unfortunately :(
20:23:51 <DukeDave> edwardk: I'm trying to marshal a type which is defined thus: " The wxAny class represents a container for any type.   Its value can be changed at run time, possibly to a different type of value".
20:24:07 <kmc> that's not a definition, that's a fuzzy description in English ;)
20:24:10 <edwardk> ivanm: Foo.Bar.Baz.quux doesn't work?
20:24:18 <ivanm> not last I checked
20:24:23 <ivanm> it has to be in scope or something
20:24:32 <edwardk> fun
20:24:44 <edwardk> that might explain some of the random haddock problems i've had
20:25:04 <edwardk> i have a lot fewer now since i stopped bothering trying to document ;)
20:25:08 <ivanm> edwardk: wait, you use haddock? :o
20:25:09 <ivanm> :p
20:25:39 <ivanm> @remember edwardk i have a lot fewer [haddock problems] now since i stopped bothering trying to document ;)
20:25:40 <lambdabot> Nice!
20:26:43 <edwardk> hrmm
20:26:46 <edwardk> @quote edwardk
20:26:46 <lambdabot> edwardk says: Haskell 98 is the Windows 98 of standards ;)
20:27:40 <Jafet> ...and the real standard is actually GHC 7?
20:27:52 <ivanm> @quote edwardk
20:27:52 <dolio> What is the Windows ME of standards?
20:27:53 <lambdabot> edwardk says: i love it when my arguments are irrefutable ;)
20:27:58 <ivanm> @quote edwardk
20:27:59 <lambdabot> edwardk says: heh, i'm amused the ParsecT that Antoine Latter put together is in the form of a right kan extension ;)
20:28:11 * ivanm notes that edwardk doesn't like to capitalise `i'
20:28:17 <edwardk> i don't.
20:28:32 <edwardk> you may have noticed i generally elide capitalization on irc.
20:28:37 <Jafet> He dots those i's, though.
20:28:50 <ivanm> Jafet: he even crosses his t's!
20:29:10 <edwardk> i take the extra effort to dot my i's and cross my t's. you should be grateful. i'm not going to capitalize for you too! sheesh
20:29:37 <geheimdienst> "amused that ParsecT is a right kan extension" ... yeah, damn funny, i'm loling all the way to the dictionary
20:29:44 <ivanm> is the change from deepseq-1.1 to 1.2 that the instances were shifted over to containers?
20:29:45 <Jafet> Yeah, who needs proper docu, I mean capitalization
20:29:55 <ivanm> Jafet: heh
20:30:56 <edwardk> ι've decιded that sιnce my efforts go unapprecιated. that ι shall no longer dot my ι's.
20:31:15 <geheimdienst> that seems to be a lot of iotas in there
20:31:36 <edwardk> yeah ιota dot them
20:31:58 <pikhq> There's also just ı.
20:32:07 <ivanm> looking at this change, isn't that doing the check for 7.0.3 rather than 7.3 ? https://github.com/ghc/packages-deepseq/commit/5333bc3ee8e8e085871ff233d0ed4440c2ae0168
20:32:16 <edwardk> pikhq: good point
20:32:34 * hackagebot dingo-core 0.0.3.2 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.0.3.2 (BardurArantsson)
20:32:37 <geheimdienst> edwardk: no, it has no point. that's the point
20:32:55 <Jafet> ı ıs point-free.
20:33:03 <Jafet> I mean poınt-free
20:33:26 <edwardk> @let ı = flip
20:33:28 <lambdabot>  Defined.
20:33:34 <ivanm> *groan*
20:33:36 * pikhq belɨeves ɨn doṫṫɨng ṫs and crossɨng ɨs
20:34:00 <ivanm> if Caleskell wasn't bad enough, we're now getting edwardskell!
20:34:09 <monochrom> hahaha
20:34:38 <edwardk> pikhq: watch out. that way lies madness http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
20:34:53 <ski> > (intercalate "-" . (modHead . modHead) (chr . (10 +) . ord) . reverse . splitS '-') "crit-bit"
20:34:54 <lambdabot>   "lit-crit"
20:35:42 <monochrom> regex for xhtml?! why do the people imagine a vain thing!
20:36:39 <pikhq> edwardk: :D
20:36:59 <pikhq> monochrom: People like to think that HTML is easy and simple, and that XHTML is simpler still.
20:37:10 <pikhq> That way lies madness.
20:37:28 <pikhq> There does not exist a complete HTML 4 implementation, near as I can tell.
20:38:14 <pikhq> <p>This is not a syntax error, this is purely valid (even if nobody parses it correctly):</>
20:38:36 <pikhq> Nor is this: <a href="foo"/Seriously, this is valid/
20:38:57 <bfig> does html allow for custom tags to be used by the scripting languages?
20:39:09 <pikhq> No.
20:40:07 <edwardk> M͕̤̯̘̆̒̌̋y̭̭̭̲͇͒ͥͪ̎̾̓͌͞ͅ
20:40:17 <edwardk> hrmm that didn't work as well as i'd hoped
20:40:31 <pikhq> Broke my terminal a bit, at least.
20:40:39 <edwardk> My brain exploded
20:40:51 <edwardk> My
20:40:52 <pikhq> (the line with whatever you did is blank after half of the timestamp)
20:41:02 <edwardk> that might have worked better
20:43:00 <dalaing> if edwardk's brain has exploded I think I should leave the channel...
20:43:32 <dalaing> there be dragons
20:43:48 <edwardk> of course there are dragons. i'm working on parsers silly
20:43:49 <monochrom> it is not a supernova. there is nothing to escape from.
20:45:59 <DukeDave> My brain is melted, can some one express this:
20:45:59 <DukeDave> findFirstItemWhichReturnsTrueThenApplyFunctionAndReturnItElseIfNoItemWhichReturnsTrueThenReturnDefaultItem :: [a] -> (a -> Bool) -> (a -> b) -> b -> b
20:46:45 <DukeDave> Something with find, and fromMaybe?
20:46:51 <DukeDave> Is that the easiest way..
20:47:39 <edwardk> foo xs p f d = maybe d f $ find p xs
20:48:01 <edwardk> :t maybe
20:48:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:48:35 <edwardk> i'd recommend a slightly shorder combinator name though, since it seems to be longer than the definition ;)
20:48:42 <edwardk> er shorter
20:48:52 <DukeDave> edwardk: Will that work?
20:49:03 <edwardk> yes
20:49:07 <DukeDave> Don't you need to fmap f onto the the Maybe from find?
20:49:14 <edwardk> the maybe deals with that
20:49:32 <edwardk> it applies f in the Just case
20:49:33 <DukeDave> Oh how cute!
20:49:34 <monochrom> call it creditDefaultSwap
20:50:00 <monochrom> fmap is unwanted for this
20:50:34 <DukeDave> monochrom: Erm, well, whatever the applicative version of fmap is :P
20:50:49 <DukeDave> Oh, it is fmap
20:51:06 <monochrom> fmap will get you stuck with Maybe b rather than b
20:51:28 <edwardk> then he'd have to use the fromMaybe combinator or whatever it was he was thinking of originally
20:51:30 <DukeDave> Yeah, I didn't know about maybe, only fromMaybe
20:51:37 <DukeDave> Bingo!
20:52:08 <DukeDave> Every time I think I'm being smart, there's already a function for it :|
20:52:08 <monochrom> that is the road to a system so complicated that it has no obvious errors
20:52:25 <edwardk> DukeDave: that is the best part of haskell
20:52:31 <edwardk> golfing things down to zero code
21:23:38 <wavewave> hi.
21:24:50 <wavewave> what's the command for load package in ghci?
21:25:42 <wavewave> should I load only module by module?
21:26:14 <monochrom> yes
21:28:53 <wavewave> I usually use just ghc compiler not interpreter. If you want to use interpreter as your main development tool, how do you use it?
21:29:11 <wavewave> If you have fairly large project.
21:29:53 <wavewave> cabal file has all necessary dependency. but in ghci, how can I manage dependency?
21:31:20 <ivanm> wavewave: just load up the module
21:31:38 <ivanm> as long as you don't have an issue with conflicting module names in multiple installed packages, there won't be a problem
21:31:44 <ivanm> alternatively, use the ghci feature of cabal-dev
21:32:16 <wavewave> now I have module conflict among monads-tf and mtl
21:32:41 <wavewave> How can I restrict it to mtl within ghci?
21:32:57 <ivanm> ghc-pkg hide monads-tf
21:33:02 <wavewave> should I reload ghci?
21:33:05 <ivanm> yeah
21:33:14 <wavewave> I see..
21:33:25 <wavewave> ivanm: thanks ;-)
21:33:31 <ivanm> np
21:38:31 <wavewave> does ghci 7.0.3 support multiline input?
21:38:56 <ivanm> wavewave: yes: use :{ ... :}
21:39:07 <ivanm> but AFAIK not many people use multiline input
21:39:18 <wavewave> ivanm: oh good. thx
21:39:20 <ivanm> wavewave: note also that you can't define data types, etc. in ghci
21:39:33 <ivanm> (though I think someone has just merged support for that into HEAD IIRC)
21:39:46 <kmc> any chance of a function from System.Process.Internals becoming public if i ask nicely?  or should i just copypasta?
21:40:09 <ivanm> kmc: probably depends upon the function
21:40:25 <kmc> is 'process' one of the libs you can't upgrade without upgrading GHC?
21:40:34 <ivanm> I think it might be
21:40:45 <ivanm> if it ships with GHC and it isn't Cabal, then yeah
21:40:51 <ivanm> but I can't recall if it ships with GHC or not
21:40:57 <shachaf> It is cabal.
21:41:01 <shachaf> It's in ghc/libraries, though.
21:41:10 <shachaf> Er, you meant actually *is* Cabal. Never mind.
21:41:19 <ivanm> shachaf: heh
21:41:22 <kmc> it does ship with ghc, yeah
21:41:48 <kmc> the function i want is System.Process.Internals.translate
21:41:51 <ivanm> kmc: in which case, copy-pasta for now, submit exposing it to libraries@ if you think it's worth it
21:41:53 <wavewave> anyone knows when the next haskell platform comes?
21:41:54 <kmc> which is a simple String -> String deal
21:41:58 <ivanm> wavewave: later this year
21:42:06 <ivanm> I think they're waiting for 7.4 to come out first
21:42:07 <wavewave> with ghc 7.2?
21:42:11 <ivanm> wavewave: no
21:42:13 <wavewave> oh.
21:42:16 <ivanm> 7.2.1 is a technology preview release
21:42:21 <ivanm> and isn't meant to be used by end users
21:42:35 <shachaf> ivanm: Isn't that what the odd-versioned releases are for?
21:42:37 <ivanm> (i.e. if you just want to run xmonad, then you shouldn't use 7.2.1)
21:42:44 <ivanm> shachaf: no, they're for development
21:42:46 <wavewave> hmm... is it originally planned?
21:42:47 <kmc> "Haskell has end users?" ;)
21:42:49 <ivanm> i.e. snapshots
21:42:53 <kmc> there are no odd versioned releases per se
21:43:04 <ivanm> kmc: didn't you see the reddit post about SFLC wanting to use gitit, etc.?
21:43:06 <kmc> 7.3.20110923 is not exactly a "release"
21:43:07 <kmc> yep
21:43:15 <wavewave> it looks like a quantum gap 7.0 to 7.4
21:43:18 <ivanm> as in yes you did, or yes you didn't? :p
21:43:28 <ivanm> @wn quantum
21:43:30 <lambdabot> *** "quantum" wn "WordNet (r) 2.0"
21:43:30 <lambdabot> quantum
21:43:30 <lambdabot>      n 1: a discrete amount of something that is analogous to the
21:43:30 <lambdabot>           quantum in quantum theory
21:43:30 <lambdabot>      2: (physics) the smallest discrete quantity of some physical
21:43:32 <lambdabot> [3 @more lines]
21:43:42 <ivanm> wavewave: so you're saying it's a really small gap? :p
21:43:51 <ivanm> @more
21:43:52 <lambdabot>         property that a system can possess (according to quantum
21:43:52 <lambdabot>         theory)
21:43:52 <lambdabot>      [also: {quanta} (pl)]
21:44:00 <wavewave> in  a unit of h
21:44:08 <shachaf> ivanm: I think he's saying it's atomic.
21:44:14 <ivanm> heh
21:44:43 <wavewave> hmm. some kind of discrete jump. that's usual saying in physics.
21:45:08 <ivanm> well, when most people say "quantum leap" they mean that it's a really big difference
21:45:16 <kmc> ugh
21:45:26 <akosch> hm, I'm using hdbc-odbc on windows: really just one query / printing the results... why is my executable 7MB in size? (I've compiled with "ghc -O2 --make")
21:45:28 <wavewave> in cs, everything is discrete. so it does not mean anything. ;)
21:45:53 <ivanm> OK, it looks like using IntMap (well, actually the enummapset package which is a newtype wrapper around IntMap and IntSet) doesn't improve the performance of my code
21:45:57 <kmc> when most people say "quantum leap" they mean the TV series starring Scott Bakula as Dr. Sam Beckett, a physicist from the (then future) year of 1997, who becomes lost in time following a time travel experiment, temporarily taking the places of other people to "put right what once went wrong"
21:45:58 <ivanm> if anything, it slows it down :/
21:46:00 <akosch> can I find out somehow?
21:46:14 <ivanm> akosch: because GHC does static linking by default
21:46:27 <ivanm> so every single library that your application uses gets copied in there
21:47:02 <ivanm> akosch: you can use dynamic linking to bring that file size down, but then you have to worry about copying dlls around
21:47:12 <ivanm> whereas as it stands, you can copy that .exe and run it anywhere
21:47:15 <akosch> ivanm: yeah, but I'm just using hdbc-odbc: aren't the parts I use from it enough?
21:47:49 <ivanm> akosch: I'm not sure if it's smart enough to strip out unneeded functions
21:47:57 <ivanm> but does it really matter? is 7MB really that huge?
21:48:17 <ivanm> note that any additional functionality you add in won't change the file size that much (unless you add more libraries in)
21:48:35 <ivanm> akosch: a fair amount of the file size is also the RTS; I think that's about 3MB
21:48:39 <ivanm> IIRC
21:49:32 <akosch> ivanm: so if I compile main = print "Hello World!" the size of the file will be 3MB+?
21:49:44 <ivanm> something like that, yeah
21:49:55 <ivanm> though you probably want putStrLn, not print :p
21:50:27 <wavewave> akosch: there is an option to make your executable use shared library.
21:50:49 <wavewave> its' just a matter of default.
21:51:14 <akosch> wavewave: I know, I just thought ghc would be smart enough to strip unneeded parts
21:51:17 <ivanm> wavewave: right, I said that above; that means then that you can't copy an .exe and take it to another computer without the .dlls as well
21:51:29 <wavewave> and I like current default.
21:51:55 <wavewave> using shared library sounds more smart but in fact it's not in many cases.
21:52:58 <wavewave> default must be targetted to beginners and wider applicability.
21:53:25 <akosch> yeah, 7MB isn't that big nowadays (except on embedded systems) and it's great how you don't have to worry about dependencies when running it on another system, but does it really need to be this big using static linking?
21:53:50 <wavewave> that's probably because of RTS.
21:54:15 <pikhq> akosch: Even C programs would be pretty bad if static linked, especially considering the level of bloat in glibc.
21:54:16 <wavewave> hmm ivanm already mentioned that.
21:54:31 <pikhq> I think a static, glibc-linked "Hello, world!" hits a meg.
21:54:36 <ivanm> that 3MB figure was from a few years back and on *nix, so it could be different
21:54:40 <akosch> pikhq: _if_ you use glibc ;)
21:54:52 <pikhq> akosch: Well, yeah, if you use a sane libc it's something like 8k.
21:54:57 <ivanm> akosch: on linux, glibc is the only library you _have_ to dynamically link against
21:55:01 <wavewave> haskell RTS must be big.
21:55:02 <ivanm> IIRC
21:55:05 <ivanm> I know there's one...
21:55:30 <pikhq> ivanm: Well, technically you can static-link against glibc, but it'll break if you look at it wrong.
21:55:36 <ivanm> pikhq: heh
21:55:41 <pikhq> glibc dlopens parts of itself for certain functions.
21:55:44 <ivanm> I thought there was one library you couldn't statically link against
21:55:47 <ivanm> or is that only if you're sane?
21:55:49 <ivanm> ahhh
21:57:09 <kmc> it seems the System.Process functions don't perform any character encoding before passing commands to the shell
21:57:12 <akosch> well it's still much better than cx_freeze and it's companions (turns a one-liner into 50 megs)
21:57:33 <kmc> meaning their types are wrong; they interpret the String argument as bytes and so should take ByteString or [Word8] instead
21:57:43 <kmc> anyone have more knowledge about this issue?
22:02:20 <hpaste> kmc pasted “System.Process types are wrong” at http://hpaste.org/51692
22:02:29 <kmc> you know I used to say that Haskell was one of the few languages which handles Unicode properly...
22:02:41 * wavewave found that he already implemented what he was about to code..
22:03:03 <wavewave> these days, I am googling my code..
22:03:52 <kmc> note that "echo ☃" works fine in my terminal
22:03:56 <kmc> (UTF-8 locale)
22:05:08 <copumpkin> bug report!
22:05:30 <copumpkin> although wait
22:05:31 <copumpkin> you're on GHC 7.0.4
22:05:31 <JoeyA> I like being able to download my own software "from the Internet".
22:05:31 <copumpkin> didn't all the big unicode changes happen more recently?
22:05:35 <copumpkin> or was that 7
22:05:42 <kmc> i thought 6.12 ;P
22:05:53 <wavewave> JoeyA: yay
22:06:09 <kmc> oh, it actually does work on 7.2
22:06:10 <kmc> nice
22:06:11 <JoeyA> Rather than from /mnt/win/Documents and Settings/Owner/Desktop/junk/TIGCC projects/fallup/fallup-0.2.zip
22:06:41 <wavewave> what source code repository do you use?
22:06:49 <kmc> i think there's an exploitable security hole here
22:06:51 <kmc> in pre-7.2
22:06:52 <JoeyA> I swear by git these days.
22:07:04 <wavewave> github?
22:07:05 <shachaf> kmc: 7.2.1 is a technology preview release, though!
22:07:20 <shachaf> kmc: Exploitable how?
22:07:25 <kmc> maybe i should not be so loud about it
22:07:30 <kmc> responsible disclosure and all
22:07:46 <JoeyA> wavewave: Yes, but I like having packages on Hackage and CCAN (Comprehensive C Archive Network, ccan.ozlabs.org)
22:08:07 * shachaf is just nefa^H^H^H^Hcurious.
22:08:32 <JoeyA> I don't have a whole lot of useful software up there, but it feels good when I get to use it.
22:09:07 <wavewave> I hope that haskell hackage db has more social features.
22:09:34 <JoeyA> I haven't gotten into github much, though.
22:09:48 <wavewave> lik annocpan.org
22:09:49 <JoeyA> There are advantages to language-specific repositories though.
22:10:27 <JoeyA> Namely, the ability to set standards of quality that packages ought to satisfy.
22:10:44 <wavewave> if we can annotate or comment on haddock document for hackages, it will help us very much.
22:11:06 <wavewave> JoeyA: I agree.
22:11:15 <JoeyA> That would be cool.  However, I'd like to point out that I find the [3 comments] links on Real World Haskell extremely distracting.
22:11:54 <wavewave> so we can separate two . official and anno.
22:12:32 <wavewave> hm.. this doesn't look very complicated .
22:12:35 * hackagebot peggy 0.1.1 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.1.1 (HideyukiTanaka)
22:13:33 <wavewave> with already-made yesod or snap or happstack framework..
22:15:08 <wavewave> does anyone know what's the status of hackage2?
22:17:24 <kmc> it's the Duke Nukem Forever of the 2010's
22:17:34 * hackagebot floatshow 0.2.1 - Alternative faster String representations for Double and Float,  String representations for more general numeric types.  http://hackage.haskell.org/package/floatshow-0.2.1 (DanielFischer)
22:18:42 <mgsloan> http://hpaste.org/51693
22:20:29 <mgsloan> err meant to paste to #GHC, doh
22:37:45 <akosch> is hdbc thread-safe or does it depend on the backend?
22:38:41 <akosch> I mean, can I execute queries in parallel on the same connection?
23:01:12 <TNA-MichaelK> Hey, wow, this is an amazing language, I just recently started trying to use it for solving Project Euler problems.  1 line of code FTW!
23:01:47 <shachaf> @quote kmc fibonacci
23:01:47 <lambdabot> No quotes match. Sorry.
23:01:56 <dalaing> hehe
23:02:39 <kmc> do you mean
23:02:41 <kmc> @quote _pizza_
23:02:42 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
23:02:57 <dalaing> TNA-MichaelK: it seems to stay amazing for a while
23:03:36 <shachaf> kmc: No, I meant the quote about writing weblog posts about what a great language Haskell is and then about how terrible it is.
23:03:40 <shachaf> Or something along those lines.
23:03:42 <hpaste> djahandarie pasted “wtf” at http://hpaste.org/51694
23:03:59 <djahandarie> Can anyone explain to me why I'm getting that error? I don't really understand.
23:04:01 <dalaing> not saying it runs out of amazing, just that I keep finding it amazing for different reasons as I learn more about it
23:04:01 <TNA-MichaelK> dalaing: That's good news, I haven't gotten around to doing normal things yet, but, it's quite interesting how to phrase problems.  It's really close to math...
23:04:26 <djahandarie> Any ideas copumpkin?
23:04:58 <TNA-MichaelK> lamdabot: hah, nice quote, lol
23:06:00 <kmc> the usual progression is "omg fibonacci in one line" to "wtf, this is too hard, how does anyone write a real program in this language" to "hmm, it's not a perfect tool but it's pretty good for a wide variety of tasks"
23:06:12 <kmc> this can take months to years
23:06:12 <TNA-MichaelK> dalaing: It seems like it'd be useful for anything because it is based off of the structure of mathematics (as far as I can tell) and as far as I've studied, mathematics can create anything.
23:06:26 <djahandarie> And then to "HMM I WONDER HOW I CAN BEND GHC TO DO THIS"
23:06:36 <djahandarie> Well, only some people do that :P
23:06:37 <kmc> TNA-MichaelK, almost any programming language can create anything
23:06:48 <dalaing> it's just a matter of where the pain points are :)
23:06:55 <TNA-MichaelK> kmc: yes, but some create if more naturally
23:06:58 <kmc> yeah
23:07:12 <ddarius> @faq Can Haskell make anything via the principle of explosion?
23:07:12 <lambdabot> The answer is: Yes! Haskell can do that.
23:07:21 <dalaing> kmc: I'm somewhere between steps 2 and 3
23:07:26 <shachaf> @quote haskell.*math
23:07:26 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
23:07:26 <lambdabot> like learn $ zip math haskell.
23:07:34 <kmc> nice
23:07:47 <dalaing> it might be making me more optimistic than realistic though
23:08:04 <shachaf> @quote kmc haskell.*math
23:08:05 <lambdabot> kmc says: programming is inherently mathematical.  furthermore, the connection between haskell and maths is overblown by people who don't understand the language
23:08:22 <shachaf> Hmm, there's more than one.
23:08:28 <shachaf> Anyway, enough @quotes.
23:08:33 <kmc> yeah, it's not clear to me the extent to which beginner's enthusiasm is a necessary motivator vs. a setup for becoming disillusioned
23:09:14 <kmc> programmers are always looking for the magic bullet that will make writing software easy and pain-free
23:09:19 <edwardk> i was fortunate that i came into haskell with pretty low expectations
23:09:20 <shachaf> djahandarie: That's a bit weird.
23:09:21 <kmc> Haskell isn't that
23:09:27 <kmc> because that magic bullet does not exist
23:09:32 <shachaf> djahandarie: It works fine without the { x :: }.
23:09:36 <djahandarie> shachaf, right.
23:09:50 <edwardk> and fortunately it wildly exceeded them
23:10:04 <dalaing> I spent the last week or two refactoring my side project as I found ways to apply all the concepts I've been gathering - refactored to use state monad, refactored to use state monad transformer, realised that my output type was a monoid I was gathering, refactored to use writer in the transformer stack, added data-lens-fd to the mix
23:10:07 <dalaing> it's been a wild ride
23:10:22 <ddarius> edwardk: "This can't be -that- much better than Javascript" ?
23:10:24 <TNA-MichaelK> there isn't any such thing... I've tried doing calculus of variations in C and it's just like gnawing my foot off.  I suspect after learning enough haskell for that type of task the math will be the center of my programming and no the language
23:10:40 <ddarius> I doubt it.
23:10:46 <kmc> wow dalaing
23:10:49 <djahandarie> 3am is clearly the wrong time to ask a question, why the hell is it so active in here?
23:10:53 <dalaing> I figure I just need to use zippers and finger trees and comonads in anger and start gathering concepts again
23:11:00 <shachaf> djahandarie: It's only midnight!
23:11:10 <luqui>  dalaing all you need to reach enlightenment is to transcend your need for the state monad
23:11:12 <TNA-MichaelK> dja: programmers go to bed late, also there are 700 people
23:11:15 <ddarius> @localtime mauke
23:11:16 <lambdabot> Local time for mauke is an illusion
23:11:44 <TNA-MichaelK> @localtime ddarius
23:11:45 <lambdabot> Local time for ddarius is Fri Sep 23 03:10:21
23:11:46 <dalaing> I think I'm slowly transitioning from beginner to beginner-intermediate
23:11:59 <shachaf> ddarius: There are no time zones but North America.
23:12:29 <edwardk> ddarius: exactly. i was thinking it might make a cute language to implement another javascript compiler in
23:12:45 <luqui> wouldn't it be easier if everybody just aligned their schedules to MST?
23:12:47 * djahandarie goes to bed and will figure this out tomorrow. THIS: http://hpaste.org/51694 out tomorrow.
23:13:00 <luqui> yeah europe would be awake in the dark all the time, so what?
23:13:03 * djahandarie continues plugging the link until someone explains to him why this is happening :(
23:13:04 <shachaf> edwardk: Are you in the business of implementing JavaScript compilers?
23:13:14 <ddarius> shachaf: Only in Javascript.
23:13:14 <TNA-MichaelK> dja: thanks for the link
23:13:36 <shachaf> JavaScript is the best language to write JavaScript interpreters in.
23:13:45 <shachaf> And a compiler is nothing but an optimization on an interpreter.
23:13:52 <edwardk> shachaf: i had one for a while that i was using to test trampolining javascript so i could run arbitrarily long computations in the browser
23:14:00 <ddarius> luqui: Think what would happen if everyone started their computers at the same time each morning.
23:14:03 <edwardk> it worked pretty well
23:14:23 <shachaf> edwardk: Arbitrarily long?
23:14:57 <edwardk> if you loop for ~ a million instructions in javascript you get the 'this window is not responding' message. this means that if you want to do serious computation, you eventually run into this limit
23:15:04 <luqui> djahandarie, that is wacky.
23:15:06 <edwardk> so i cps'd it
23:15:28 <shachaf> edwardk: Oh, that.
23:15:35 <edwardk> and then i could window.setTimeout with the continuation (effectively, it was through a heap though)
23:15:38 <shachaf> edwardk: JavaScript programmers are happy to write everything in CPS anyway, sadly.
23:15:57 <edwardk> well, the problem is sometimes you really do need to munge your way through a few million records =)
23:16:07 <TNA-MichaelK> what's CPS?
23:16:11 <ddarius> in javascript...
23:16:15 <edwardk> sure =)
23:16:16 <luqui> TNA-MichaelK, continuation passing style
23:16:24 <edwardk> continuation passing style
23:16:32 * shachaf wrote some JS in the browser and ran into the long-computation thing.
23:16:48 <shachaf> Also the browser doesn't update until you yield control to it.
23:16:55 <ddarius> TNA-MichaelK: The proof transformation that the Kolmogorov embedding of classical logic into intuitionistic logic represents.
23:17:20 <luqui> ddarius, very helpful
23:17:23 <edwardk> replace function foo(a,b) { return(a + b); }   with function foo(a,b, RETURN) { RETURN(a + b); }
23:18:13 <edwardk> shachaf: exactly, so i set up two things, one is a chicken scheme-style trampoline to deal with the fact that javascript lacks tail-recursion and has a fixed stack limit
23:18:28 <edwardk> that let me throw an exception with the current computation every time i approached the stack limit
23:18:35 <edwardk> and i'd catch it in a trampoline to resume execution
23:18:43 <shachaf> Neat.
23:18:51 <shachaf> Is that compiler published anywhere?
23:18:52 <luqui> that's gross :-)
23:18:54 <ddarius> luqui: I should have stuck to "This meaningless term means this other meaningless term."
23:18:55 <edwardk> rather than trampolining every instruction that let me amortize the trampoline over several hundred frames
23:19:05 <TNA-MichaelK> ddarius: Thanks, new terms ; )
23:19:36 <luqui> ddarius, was counting on google
23:19:59 <edwardk> second, once you're throwing and catching a computation, there is no reason why you need to resume _THAT_ computation. you can put it in a queue and use the stack explosion as the natural thread quantum
23:20:06 <ddarius> luqui: Clearly CPS means Chicago Public Schools.
23:20:08 <edwardk> and then you have in-browser multi-threading
23:20:31 <TNA-MichaelK> and that = win
23:20:50 <TNA-MichaelK> except for WebGL which is just broken
23:21:05 <edwardk> http://comonad.com/js/cps/Thread.js appears to be an old work in progress copy of the threading code
23:21:17 <ddarius> while(1) {}
23:21:18 <edwardk> (before it gets minimized and atomized, etc.)
23:21:36 <dalaing> Kolmogorov did some interesting stuff
23:21:50 <ddarius> Kolmogorov did a lot of interesting stuff.
23:21:50 <edwardk> http://comonad.com/js/lang/Parser.js looks like an old copy of the parser
23:22:01 <dalaing> indeed
23:22:06 <ddarius> Where are the new copies of these things?
23:22:32 <edwardk> not sure. it was many machines ago and before i was religious about using git for everything ;)
23:23:45 <shachaf> Apparently you used to do a lot of JavaScript.
23:24:04 <wavewave> btw, darcs is way behand git?
23:24:07 <edwardk> anyways the parser is a pretty boring pair of recursive descent parsers sandwiched around an operator precedence parser
23:24:13 <edwardk> shachaf: for a few months i did
23:24:19 <wavewave> s/behand/behind
23:24:36 <luqui> wavewave, define behind
23:25:03 <wavewave> I am just curious how haskellers think of darcs.
23:25:06 <edwardk> it is almost all obsolete in this era of jQuery, etc anyways ;)
23:25:17 <wavewave> I love darcs.
23:25:23 <TNA-MichaelK> darcs?
23:25:27 <edwardk> wavewave: i like darcs. i even prefer using it for single developer projects
23:25:32 <edwardk> but in practice, i don't have any of those any more
23:25:33 <tensorpudding> darcs is a distributed version control
23:25:35 <shachaf> edwardk: Why does that make it obsolete?
23:25:42 <tensorpudding> it's like git, but more indie
23:25:46 <wavewave> I found darcs bridge is extremely useful.
23:25:52 <TNA-MichaelK> git as in github, right?
23:25:53 <edwardk> i throw everything up on github and i have a much better story for dealing with patches from other users that way
23:25:55 <edwardk> it just works
23:25:58 <shachaf> Last time I wrote JavaScript the lack of coroutines/continuations/threads/something was as painful as ever.
23:26:05 <coppro> "git as in github" what
23:26:25 <TNA-MichaelK> I'm very new to the entire field, forgive my ignorance
23:26:31 <TNA-MichaelK> I don't know of git either
23:26:35 <wavewave> I love github interface.. that was conflict in loving github and darcs.
23:26:47 <kmc> github is a hosting service for git repositories
23:26:57 <edwardk> shachaf: mostly because the pain points i was addressing have been addressed in other ways. google gears, etc.
23:27:01 <kmc> i don't think "git as in github" is an unreasonable phrase
23:27:06 <wavewave> now I found darcs bridge solution. now I can use both darcs and git at the same time.
23:27:08 <earthy> darcsden not useful enough?
23:27:32 <TNA-MichaelK> kmc: Thank you for clarifying and the reassurance.
23:27:38 <wavewave> I am not sure whether darcsden and patch-tag are actively maintained.
23:28:00 <TNA-MichaelK> git = http://git-scm.com/ ,or something else?
23:28:02 <edwardk> patch-tag ate over a dozen repositories on me.
23:28:07 <edwardk> that is what drove me to darcs
23:28:18 <edwardk> because a good number of them i didn't even have on a local machine at the time =(
23:28:23 <kmc> that's the one TNA-MichaelK
23:28:27 <edwardk> er s/darcs/git/
23:28:34 <earthy> edwardk: understood. :)
23:29:18 <ddarius> Little does edwardk know that github is just biding its time.
23:29:23 <wavewave> edwardk: is darcs still unstable like that? I have many darcs repository and it is worrisome.
23:29:35 <edwardk> i wrote haskell using darcs for years. in that time i received maybe 3-4 patches. i switched to git, and within the first six months i received maybe 40 patches
23:29:42 <ddarius> wavewave: patch-tag /= darcs
23:29:53 <edwardk> so there is something going on from an exposure standpoint that i like ;)
23:29:58 <wavewave> ah.. that's patch-tag problem.
23:30:28 <ddarius> edwardk: There's also the community scaling and your own recognition and what you're working on.
23:30:50 <wavewave> yeah.. that's rather difficult to separate. ;-)
23:31:34 <edwardk> true
23:31:41 <edwardk> i'm not saying there aren't other factors
23:33:14 <wavewave> I am now thinking transforming haddock documents to more useful things
23:34:31 <wavewave> simply adding some user-defined javascript to the generated haddock can make haddock much more useful.
23:39:45 <edwardk> ddarius: ah i found what i did with it. i licensed it to some company called "Aptana" and forgot about it. Dug up the emails =)
23:40:56 * ddarius should start doing what Ed did and make crazy crap and sell it to people.
23:41:29 <edwardk> it seems to work for me
23:42:08 <shachaf> edwardk: Licensed what?
23:42:32 <edwardk> the parser, recompiler, atomizer, script minimizer, bwt-based javascript packer, etc.
23:44:19 <shachaf> Oh.
23:45:26 <edwardk> btw- there are a pair of functions that were once defined by Ken Perlin: http://comonad.com/js/math/Perlin.js     but I haven't been able to find any references to them on the web in years. Does anyone know what publication they came from?
23:45:57 <edwardk> I know how to use them, and love them to death, but I seem to have lost the origin
23:50:48 <edwardk> ddarius: btw- i figured out a nice way to mix gll and parsec style parsing. it even lets me have left recursion in the grammar as long as the recursion goes through a memoized non-terminal
23:53:05 <shachaf> edwardk: "Hypertexture"?
23:53:20 <edwardk> shachaf: what about it?
23:53:39 <edwardk> oh
23:53:41 <edwardk> the paper?
23:54:20 <shachaf> edwardk: A citation in http://dept-info.labri.fr/~schlick/DOC/gem2.ps.gz , I assume.
23:54:33 <edwardk> thats it!
23:54:35 <edwardk> thank you!
23:55:10 * shachaf now to figure out what these functions actually do.
23:55:17 <edwardk> i knew it was in something he wrote on perlin noise, etc.
23:56:11 <edwardk> oh thats easy. bias bows the curve up or down, gamma is a symmetrical bias giving you an s shape
23:56:16 <edwardk> er gain
