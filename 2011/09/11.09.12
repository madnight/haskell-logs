00:04:23 <kmc> when i need to think about small amounts of time, i usually multiply by the speed of light
00:04:59 <kmc> so a safe ffi call takes 4 meters vs. an unsafe call at about 42 meters
00:05:23 <samg_> Is it possible to get a crash report from ghc segfaulting during a compile?
00:06:07 <kmc> meanwhile Criterion estimates my clock resolution at about 2 miles
00:06:35 <cmccann> if you used more sensible units to begin with, the "speed of light" would be a dimensionless value "1", as it should be
00:07:02 <Veinor> haha
00:08:09 <ddarius> @google diameter of earth in lightseconds
00:08:11 <lambdabot> 0.0425501031 light seconds
00:08:11 <lambdabot> http://en.wikipedia.org/wiki/Light-second
00:08:11 <lambdabot> Title: Light-second - Wikipedia, the free encyclopedia
00:08:37 <ivanm> @google light second in earth diameters
00:08:40 <lambdabot> http://www.hartrao.ac.za/other/howfar/howfar.html
00:08:40 <lambdabot> Title: How far ? How big ? How many ?
00:08:45 <ivanm> awwww :(
00:08:46 <azaq23> But then light's going to get all self important and think it's at the center of the universe
00:09:48 <kmc> CPU clock cycle is about 10 cm, meanwhile seek time on a good hard drive is about the distance from New York City to Utah
00:10:54 <cmccann> CPU clock cycle is a few attoparsecs, then?
00:10:55 <kmc> or from Lisbon to the far edge of Poland
00:12:05 <kmc> put it another way, if you can add two numbers in 1 second, then reading from hard drive is like waiting 14 months for the next number to add
00:13:00 <kmc> indeed, 1 attoparsec ‚âà 0.1 ns
00:15:06 <kmc> 1 smoot ‚âà 5.7 ns
00:19:37 <erus`> how many hogs heads is that?
00:20:35 <kmc> just flew in from flatterland erus`?
00:21:19 <kmc> a cubic smoot is about 21 hogsheads
00:21:44 <applicative> @google 1 hogshead in cubic light seconds
00:21:45 <lambdabot> 8.8509843 ◊ 10
00:21:45 <lambdabot> http://en.wikipedia.org/wiki/Conversion_of_units
00:21:45 <lambdabot> Title: Conversion of units - Wikipedia, the free encyclopedia
00:22:52 <kmc> google recognizes volume units of "keg" and "shot" but to my dismay does not recognize "bonghit"
00:23:00 <kmc> probably because it's less standardized
00:23:13 <applicative> bonghit a psychometric unit?
00:23:24 <applicative> is  it, i mean?
00:23:49 <kmc> heh
00:24:56 * cmccann considers specifying thermodynamic entropy in units of "libraries of congress"
00:30:42 <augur> http://www.reddit.com/r/technology/comments/kbzgt/its_a_suckers_game_its_a_game_suckers_play_if_you/
00:30:43 <augur> i dont even
00:30:46 <ClaudiusMaximus> woop, got the clustering thing worked out nicely, took about 15mins to run but still less painful than sorting images by hand... main = mapM_ (putStrLn . name . head) . kmeansGen hist 32 =<< mapM load =<< getArgs  -- where load reads a ppmhist output
00:32:59 <kmc> nice
00:33:04 <koeien> nice main function, yes :)
00:33:35 <kmc> which k-means library (if any) did you use ClaudiusMaximus?
00:34:03 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/kmeans/0.1.2/doc/html/Data-KMeans.html -- i couldn't find the others
00:34:36 <kmc> i thought there were others, but maybe not
00:35:11 <ClaudiusMaximus> there's a fair amount of stuff related to clustering on hayoo, but it seemed bioinformatics related (or graphviz...)
00:35:32 <kmc> it still forces you to use a euclidean metric
00:35:37 <kmc> that's annoying
00:37:01 <kmc> what if i want to cluster reddit comments by their edit distance
00:38:15 <kmc> i guess the set on which the metric is defined should also be a vector space
00:38:31 <kmc> because you need to average the samples in order to update each cluster point
00:39:36 * ClaudiusMaximus 's thought was losing termination guarantees
00:40:18 <kmc> can you guarantee that it terminates when the points are in euclidean space?
00:40:31 <ClaudiusMaximus> i don't know!
00:43:00 <kmc> "An upper bound of O(k^n) can be trivially established since it can be shown that no clustering occurs twice during the course of the algorithm."
00:43:28 <erus`> its too early in the morning to be reading stuff like that
00:43:36 <erus`> see you guys at lunchtime
00:45:45 <kmc> there is a complicated construction to get patterns of points in R¬≤ which require 2^Œ©(n) steps
00:46:19 <kmc> Vattani., A. (2011). "k-means requires exponentially many iterations even in the plane"
00:49:04 <zzo38> I made up program of type-level natural numbers, which can also make this code (the result is 7):   valcon (undefined :: Add $(3) $(4))
00:49:38 <zzo38> http://sprunge.us/PKiW
00:50:32 <zzo38> This program is public domain you can send it or whatever you want to
00:52:45 <zzo38> Any other idea of this program?
00:53:00 <kmc> why don't you use the whitespace-sensitive syntax of Haskell?
00:54:23 <zzo38> kmc: I prefer nonlayout mode. But anyone can make modification it is public domain
00:55:15 <kmc> any particular reason you prefer non-layout?
00:56:27 <zzo38> Yes; at least I actually find it clearer, although indentation helps too.
00:56:44 <kmc> oh, i don't think that's a reason
00:56:49 <zzo38> I believe there are other Haskell programmers who also like non-layout
00:56:56 <kmc> saying you prefer it and saying you think it's clearer seem like roughly the same statement
00:56:58 <zzo38> kmc: That is OK, you do not have to believe me.
00:57:14 <kmc> i was asking what specifically about it is clearer
00:57:25 <kmc> there are others, yes
00:58:16 <applicative> surely if you write semicolons all day its clear enough?
00:58:28 <zzo38> It makes it clear where something ends, and where exactly the blocks are.
00:58:43 <kmc> anyway, i don't think this is a very good use case for literate programming
00:58:47 <applicative> I resist it because it makes my definitions seem like a list of imperatives
00:58:54 <kmc> most of the comments are redundant
00:59:03 <kmc> they're just saying things which are obvious in the code anyway
00:59:05 <mux> at least for single line statements such as "data Zero", I find the ; characters quite redundant and visually heavy
00:59:10 <kmc> all the LaTeX noise doesn't help either
00:59:12 <zzo38> kmc: That is OK too; you can do without literate programming if you prefer not to
00:59:19 <zzo38> And it is Plain TeX, not LaTeX.
00:59:30 <kmc> zzo38, you asked for comments; I'm giving them
00:59:39 <kmc> you don't need to tell me after each comment that it's just my opinion
00:59:41 <kmc> we both know that
00:59:47 <zzo38> OK
01:00:08 <zzo38> But you should still know that it is using Plain TeX rather than LaTeX.
01:00:21 <kmc> duly noted
01:01:07 <zzo38> I try to explain the purpose of everything more clearly and separate them into chapters.
01:01:18 <kmc> as for the actual trick, it's cute, but it's a pretty egregious abuse of notation
01:01:32 <kmc> as evidenced by the fact that you can't actually implement most of the desired type class methods
01:01:37 <erus`> Json in haskell
01:01:39 <erus`> wtf
01:01:53 <kmc> Haskell 98's standard type-class hierarchy is a bit messed up in this regard
01:01:54 <erus`> it shouldnt be this hard to read a fixed object
01:01:55 <zzo38> kmc: I know. I tried to explain in the text about that.
01:02:11 <zzo38> But I agree with you about that
01:02:24 <kmc> erus`, what library are you using?
01:02:36 <kmc> there are too many ;P
01:02:41 <erus`> Text.Json
01:02:48 <erus`> cabal install json
01:02:50 <kmc> which package name?
01:02:51 <kmc> ah
01:02:53 <zzo38> But there is a lot of abuse of notation in mathematics anyways
01:03:03 <kmc> i've had good luck with JSONb and i guess aeson is the new hotness
01:03:21 <mux> zzo38: you might be interested in checking out this package: http://hackage.haskell.org/package/type-level-natural-number
01:03:32 <kmc> zzo38, yes, but Haskell is not mathematics.  when you're giving instructions to a computer you have to be precise or pay for it dearly
01:04:44 <kmc> erus`, i also wrote this library to make using JSONb a little easier: http://hackage.haskell.org/package/jspath
01:05:54 <erus`> goodness me
01:06:04 <zzo38> mux: OK, I looked at that. Next version I might be able to add some of that stuff too, but not necessarily. My program is a different kind of way to use type-level natural numbers.
01:06:12 <zzo38> Thanks for telling me anyways, though.
01:06:32 <mux> zzo38: also, type-level natural numbers are supposed to make their way into GHC relatively soon, if I remember correctly
01:07:17 <zzo38> mux: OK, but I could still do everything I think would be needed with type-level natural numbers in the current version anyways, including addition, subtraction, multiplication, etc
01:07:44 <kmc> zzo38, yes, it's been done many times
01:07:51 <mux> zzo38: yes but once you start writing more complicated algorithm, you'll see that you'll have to define several addition/subtraction operations to match the way your functions recurse
01:08:28 <zzo38> mux: O, I didn't know that. Thank you for telling me
01:09:19 <mux> zzo38: http://code.mumux.org/automata/src/120d63e6991e/Data/Automaton/Class.hs look at the various addition/subtraction type families I needed to have there :-)
01:09:56 <mux> but maybe there is a way around that now that GHC has superclass equalities
01:10:55 <mux> zzo38: woops, wrong link
01:11:29 <mux> zzo38: http://code.mumux.org/stuff/src/068959a8d9d7/Vector.hs
01:11:31 <hvr> @seen bos
01:11:31 <lambdabot> Unknown command, try @list
01:11:31 <preflex>  bos was last seen on #ghc 3 days, 10 hours, 55 minutes and 58 seconds ago, saying: Igloo: i did, bit swamped but will get to it
01:12:08 <mux> so, I wonder if I'll be able to write stuff such as: type instance m :+: n = n :+: m
01:12:44 <mux> zzo38: see my comment for the :!: type family.
01:12:51 <ddarius> mux: I very much doubt it.
01:12:54 <magicman> That looks like an infinite loop waiting to happen.
01:13:03 <mux> ddarius: yeah, not that I think about it some more, I don't see how superclass equalities would help me with that
01:13:38 <ddarius> magicman: It looks like an infinite loop already happening.
01:13:53 <mux> it'd be an infinite loop in the compiler, but fortunately, he catches it :-P
01:14:16 <kmc> instance (C a b) => C b a
01:14:16 <zzo38> O, now I can see why you needed to have multiple addition
01:14:19 <zzo38> Yes I did see that comment
01:14:25 <mux> zzo38: annoying, isn't it?
01:14:47 <mux> that's why i'd be happy when GHC gains type-level natural numbers as an extension; maybe for 7.4.1
01:14:47 <zzo38> Yes
01:15:22 <zzo38> Does GHC type-level natural numbers can be done in terms of successor and zero?
01:16:02 <mux> zzo38: http://hackage.haskell.org/trac/ghc/ticket/4385
01:17:21 * ddarius doesn't see why we should add type-level naturals and not type level regular data types.
01:18:16 <zzo38> If you do that though, I would call its kind + instead of Nat (but that is really just my preference)
01:19:49 <obiwahn> is there something like docstrings for haskell and waht is a good stlye for in file documentation
01:20:19 <wjt> is there a generally-accepted right way to invoke 'make', 'make install', 'make clean' from the appropriate points of a cabalized build (as well as building Haskell code as normal)? I'm overriding the build, copy and clean hooks, but copy isn't invoked for `cabal install` afaict
01:20:20 <obiwahn> is there more than -- {- -}?
01:20:39 <koeien> obiwahn: yes, see haddoc
01:20:41 <koeien> haddock
01:20:53 <kizzx2> obiwahn: i think you can look at hackage and see how yoru favorite library does lt
01:20:54 <kmc> haddock uses markup embedded in ordinary Haskell comments (either style)
01:21:05 <obiwahn> nice
01:21:08 <kmc> all the docs you see on hackage are generated using haddock
01:21:15 <kizzx2> for example, ByteString http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#t:ByteString      you can click on the Source button, you see that if you write your comments that way, it will be generated in the page you see in hackage
01:21:20 <kmc> it can generate docs for your code and hyperlink it with the libraries you use
01:21:24 <kmc> cabal can do this for you
01:22:09 <kmc> and generate that colorized html source too
01:22:09 <Yrogirg> Hello! How can get macros for Haskell? I mean just handy text substitutions.
01:22:21 <kizzx2> Yrogirg: template haskell
01:22:23 <kmc> Yrogirg, {-# LANGUAGE CPP #-}
01:22:29 <kmc> then you can use the C preprocessor
01:22:38 <kmc> template haskell is really far too cumbersome for handy text substitutions
01:22:44 <kizzx2> kmc: you're right :P
01:22:56 <ddarius> substitute = sustitutee?
01:23:13 <kmc> we need something for simple text preprocessing which is not CPP
01:23:45 <ddarius> kmc: Feel free to use m4 as your preprocessor.
01:24:31 <kmc> yep, you can use any external program
01:25:27 <ddarius> I, personally, see very little value in basic text substitutions.  The only thing I've ever wanted CPP for in Haskell is conditional compilation.
01:25:29 * hackagebot transformers-base 0.2 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.2 (MikhailVorozhtsov)
01:26:33 <kmc> ah, i often have boilerplate instances or the like, which are easy text substitutions but messy as TH splices (because everything is)
01:26:37 <kmc> maybe the solution is to improve TH
01:26:49 <ddarius> kmc: That is the solution.
01:27:06 <ddarius> Luckily, it sounds like they are going to make some improvements.
01:27:28 <kizzx2> ddarius: what kind of improvements?
01:28:22 <zzo38> Note I have added stuff to proposal of more-notation probably some of the kind of things has been asked for me to write in there
01:28:36 <ddarius> zzo38: Have you added a motivating example?
01:29:59 <zzo38> ddarius: Yes, sort of. I think it is better job now. It actually explain example of way to use in a real program, giving specific examples, which might be motivated.
01:30:15 <zzo38> That is, I added section 5 for that purpose.
01:30:45 <ddarius> zzo38: If you're not sure if you examples are motivating, then they aren't.
01:30:57 <kmc> a text preprocessor is a self-contained program which outputs standard Haskell code
01:31:08 <kmc> this makes it easy to understand what it's doing
01:31:17 <kmc> whereas the implementation of TH is wired deeply into GHC
01:31:21 <zzo38> http://www.haskell.org/haskellwiki/User:Zzo38/Proposal_for_more-notation#Purpose_to_use_more-notation
01:31:28 <kmc> and it can do fancy things with that
01:31:36 <kmc> and it's hard to even tell if it is doing such things
01:32:23 <zzo38> It is incomplete but I still wrote some things
01:32:43 <zzo38> Actually I fixed some mistakes on the other sections too, but I added section 5 and 6
01:34:52 <zzo38> Did I make any more mistake?
01:37:26 <ddarius> kmc: I can implement any analysis or transformation, or even implement an entirely different programming language as a "text preprocessor."  It is less restricted than TH and if it needs the information TH has, must do a whole lot more work.
01:38:10 <erus`> LLVM native client is the way forward
01:38:11 <kmc> ddarius, I don't mean arbitrary text preprocessors; I mean a fixed hypothetical sane text preprocessor
01:38:28 <kmc> and yes it would be inappropriate to use it for things that need the information TH has
01:38:34 <kmc> but we already have TH for those things
01:38:41 <erus`> javascript simple stuff and native client for apps
01:38:48 <kmc> erus`, is this about Haskell?
01:38:56 <erus`> hopefully
01:39:13 <erus`> i want haskell in the browser
01:39:28 <kmc> you can already use the javascript backend of uhc
01:39:35 <osfameron> uhc?
01:39:37 <kmc> anyway, what will you use it for?
01:39:44 <osfameron> I thought yhc(?) had a javascript backend
01:39:56 <osfameron> it'd be nice to have one for ghc of course
01:39:57 <kmc> it may
01:40:11 <kmc> there is also https://github.com/sviperll/ghcjs
01:40:25 <erus`> ghcjs doesnt work for me on firefox7
01:40:27 <ddarius> YHC did.
01:40:38 <kmc> upgrade to firefox 9000
01:40:57 <erus`> it will be out in a few months
01:41:21 <Ke> will it have security
01:41:33 <erus`> no just a few ui changes
01:41:56 <Ke> yup, they'll copy all the flaws in chrome ui
02:00:15 <obiwahn> is IO a monad?
02:00:34 <koeien> yes.
02:05:03 <rtharper_> what are the differences between parsec and attoparsec, besides the latter being faster
02:05:29 <hpaste> obi pasted ‚ÄúIO Monad?!‚Äù at http://hpaste.org/51265
02:05:39 <koeien> parsec has better error reporting in case of parse failure afaik
02:06:12 <koeien> hpaste: yes, this holds for any monad
02:06:24 <koeien> however, you shadow x.
02:06:45 <rtharper_> koeien: so one would generally use parsec unless speed performance is an issue?
02:07:17 <koeien> rtharper_: I would say so. I thought attoparsec was specifically developed for performance
02:07:32 <rtharper_> koeien: that was my impression, too, thanks
02:07:40 <obiwahn> so ist it more a haskell haskell monad instead of a real-monad?
02:07:44 <rtharper> oops, sorry =p
02:07:50 <koeien> rtharper: i don't know if that matters for anyone though =)
02:07:56 <koeien> rtharper: nice user name btw :)
02:08:07 <koeien> rtharper: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parsing-library-1/ -- whoops, wrong paste
02:08:26 <koeien> obiwahn: i do not get your point. shadowing also works in the Maybe monad like this
02:08:46 <obiwahn> if i do not use the x in the last action the law holds
02:08:57 <kizzx2> rtharper: i think the key difference is attoparsec uses strict BS and parsec uses vanilla String
02:09:12 <rtharper> kizzx2: okay
02:09:49 <epsilonhalbe> hey - i have a problem with modules - I want to put submodules in seperate folders but other modules importing them - don't find them - what do i have to put in the line:
02:09:49 <epsilonhalbe>  directory Project
02:09:49 <epsilonhalbe>      dir Project/Foo: module Bar where ‚Ä¶
02:09:49 <epsilonhalbe>      dir Project/Foo: import Bar
02:09:49 <epsilonhalbe>      dir Project/Baz: import Bar
02:10:19 <jpcooper> hello
02:10:48 <Veinor> @undo do {x <- return False; y <- print x; print x}
02:10:48 <lambdabot> return False >>= \ x -> print x >>= \ y -> print x
02:11:09 <Veinor> @undo do {y <- do {x <- return False; print x}; print x}
02:11:09 <lambdabot> return False >>= \ x -> print x >>= \ y -> print x
02:12:40 <kizzx2> rtharper: and my personal experiences with attoparsec is, despite it claiming to be able to deal with binary file, it's mostly restricted to text (ok, flame on)
02:12:57 <kizzx2> because if you use it to parse binary it will accumulate large chunks of memory
02:13:05 <rtharper> kizzx2: I'm just parsing ASCII strings, nothing too complicated, even, just complicated enough I don't want to do it by hand =p
02:13:09 <jpcooper> I have a process, called f, which takes a stream of objects and yields a processed form of those objects. Sometimes it does not process all of the objects which it reads. It returns both the processed objects and the objects which it has read, but not yet processed. I would like, in the next invocation of f, for it to receive first the objects which it has not processed, and if it asks for more, for it to take objects from the stream only once th
02:13:19 <Veinor> obiwahn: your second example doesn't compile
02:18:50 <obiwahn> Veinor: let x = True in do { y <- do { x <- return False; putStr (show x)}; putStr (show x)}
02:19:10 <koeien> the difference is the scope of x
02:19:13 <obiwahn> koeien: am i showing something lese then associativity
02:19:30 <koeien> obiwahn: yes, the scope of x is different in both cases.
02:19:30 <obiwahn> i see that x is shadowed:)
02:20:12 <obiwahn> is there a way to rewrite it so that i do not shadow?
02:20:28 <koeien> use another variable name is the obvious solution
02:24:53 <sohum> @pl \w -> r (fst $ s w) (snd $ s w)
02:24:53 <lambdabot> ap (r . fst . s) (snd . s)
02:25:28 <sohum> @pl \w -> let (a,b) = s w in r a b
02:25:28 <lambdabot> (line 1, column 11):
02:25:28 <lambdabot> unexpected "("
02:25:28 <lambdabot> expecting "()", natural, identifier or "in"
02:25:37 * frerich thinks @pl is an evil tool. If you cannot think of the pointless version of some expression yourself, you probably shouldn't be using it because it's complicated.
02:26:00 <sohum> I think @pl is _useful_, in that it gives me hints as to where to look
02:26:29 <koeien> uncurry r . s
02:26:36 <sohum> I rarely use what comes out of it as is, unless I've been exceptionally stupid and forgotten something obvious
02:26:53 <sohum> koeien: yea, I was wonderign why it wasn't showing that
02:26:56 <Veinor> sometimes @pl shows me an alias for something
02:27:06 <Veinor> @pl \m xs -> sequence $ map m xs
02:27:06 <lambdabot> (sequence .) . map
02:27:14 <Veinor> bah
02:27:36 <Veinor> that should be mapM :P
02:28:32 <sohum> yea...
02:29:04 <Veinor> either way i only use the output of @pl if it's something simple
02:30:39 <sohum> mmm.
02:31:20 <koeien> sohum: in your example it'd have to do common subexpression elimination
02:31:38 <sohum> koeien: hence why I was trying to do that for it :p
02:31:51 <sohum> @pl \w -> let k = s w in r (fst k) (snd k)
02:31:51 <lambdabot> uncurry r . fix . const . s
02:32:07 <sohum> ..fix . const?
02:32:10 <sohum> :t fix . const
02:32:10 <lambdabot> forall a. a -> a
02:32:11 <koeien> :t fix . const
02:32:12 <lambdabot> forall a. a -> a
02:32:19 <koeien> > fix . const $ ()
02:32:20 <lambdabot>   ()
02:32:26 <koeien> ^ which function would that be?
02:32:36 <sohum> that is _cute_
02:32:54 <sohum> silly @pl :p
02:33:05 <koeien> it's quite smart
02:35:32 * hackagebot data-timeout 0.1.1 - 64-bit timeouts of nanosecond precision  http://hackage.haskell.org/package/data-timeout-0.1.1 (MikhailVorozhtsov)
03:00:37 * hackagebot epic 0.1.13 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.1.13 (EdwinBrady)
03:05:12 <hpaste> obi pasted ‚ÄúIO Monad - still confused‚Äù at http://hpaste.org/51266
03:06:40 <obiwahn> koeien: line 6 shoud be r
03:06:49 <obiwahn> no
03:06:53 <obiwahn> lol:(
03:08:07 <Botje> obiwahn: the associativity laws only say that the different ways of putting in parenthesis should not affect the evaluation
03:08:17 <Botje> variables don't really enter the equation
03:08:56 <Botje> the fact that you had to create your own binding for x to prevent it from erroring says enough
03:08:57 <koeien> obiwahn: that law does not hold if x is free in r
03:09:32 <obiwahn> 11:59 < obiwahn> if i do not use the x in the last action the law holds
03:09:33 <obiwahn> 11:59 < obiwahn> if i do not use the x in the last action the law holds
03:09:53 <obiwahn> oh sorry
03:10:18 <obiwahn> so that is waht i was saying in a more casual way - i think we mean the same
03:11:13 <koeien> yes
03:11:55 <koeien> try not to shadow variables
03:12:06 <koeien> afaik ghc can warn you if you do that
03:12:09 <adimit> I'm looking for a function like any/all, but it'll take a list of *properties*, not items. So [a->Bool] -> a -> Bool, tells me whether a satisfies all specified properties. Is there a library that provides these?
03:12:27 <adimit> (not that I can't implement that myself, it's just that I don't like to rewrite stuff that's already there.0
03:13:01 <mauke> :t \x -> all ($ x)
03:13:02 <lambdabot> forall a. a -> [a -> Bool] -> Bool
03:13:26 <adimit> mauke: ‚Ä¶ I have much to learn yet. Thanks. That's‚Ä¶ elegant.
03:13:54 <Jafet> @pl \x -> (($ x)`all`)
03:13:54 <lambdabot> all . flip id
03:14:26 <adimit> quit confusing me!
03:14:28 <adimit> :-D
03:14:46 * sohum eyes
03:14:58 <sohum> why does zip <*> tail do exactly what I want?
03:15:02 <sohum> :t zip <*> tail
03:15:02 <lambdabot> forall b. [b] -> [(b, b)]
03:15:12 <sohum> > zip <*> tail $ [1,2,3,4,5]
03:15:15 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
03:15:20 <Botje> @quote zip`ap`tail
03:15:20 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
03:15:30 <adimit> lol
03:15:37 * hackagebot transformers-abort 0.2 - A better error monad transformer  http://hackage.haskell.org/package/transformers-abort-0.2 (MikhailVorozhtsov)
03:15:39 <int-e> adimit: This is #haskell. Our day isn't complete before we have tied knots into somebody's brain. :)
03:15:46 <Jafet> :t (<*>) `asTypeOf` ap
03:15:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f, Monad f) => f (a -> b) -> f a -> f b
03:15:59 <adimit> int-e: I should know that by now. Thanks for reminding me.
03:16:00 <mauke> :t (and .) . map
03:16:01 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:16:21 <mauke> :t (and .) . flip map
03:16:22 <lambdabot> forall a. [a] -> (a -> Bool) -> Bool
03:17:35 <sohum> I can see how the signatures fit together, I think I'm just not understanding (->) a as a functor
03:17:57 <obiwahn> koeien: it is still kind of suprising because i assume that the law would state that vars must not be free
03:18:00 <mauke> sohum: fmap for functions can be derived from the type signature
03:18:23 <mauke> :t (and .) . sequence
03:18:24 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
03:18:50 <mauke> > ((and .) . sequence) [even, odd, (> 3)] 42
03:18:51 <int-e> sohum: (r ->) is a functor: (r -> a) composed with (a -> b) gives (r -> b) and if you compse with the identity function, fmap id f = f . id = f, i.e., fmap id = id.
03:18:54 <lambdabot>   mueval-core: Time limit exceeded
03:18:58 <obiwahn> koeien: not shadowing vars and using do notation helps to avoid unwanted behavoir:)
03:19:00 <mauke> > ((and .) . sequence) [even, odd, (> 3)] 42
03:19:02 <lambdabot>   False
03:20:37 * hackagebot monad-abort-fd 0.2 - A better error monad transformer  http://hackage.haskell.org/package/monad-abort-fd-0.2 (MikhailVorozhtsov)
03:20:58 <sohum> > (,) <*> (+1) $ 7
03:20:58 <lambdabot>   (7,8)
03:21:45 <sohum> int-e: right, but I don't understand what "applying a function from a -> a onto a function from a -> a -> a" means
03:22:52 <Botje> sohum: ap :: (r -> a -> b) -> (r -> a) -> (r -> b)
03:23:00 <Botje> r is your original list here
03:23:21 <Botje> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
03:23:21 <lambdabot> f a b c = a c (b c)
03:23:29 <Botje> and that's how it's implemented :)
03:23:31 <Botje> lambdabot: botsnack
03:24:15 <sohum> oooh. so it means "use this to remove the dependency on the second argument"
03:24:22 <sohum> right, that makes sense!
03:39:14 <osaunders> What‚Äôs the type of tree that has an empty tree data constructor?
03:40:16 <Cale> Something like  data Tree = Tip | Branch a (Tree a) (Tree a) ?
03:40:17 <Cale> er
03:40:22 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a) ?
03:41:14 <quicksilver> well if you have data Tree a = Tip a | Branch [Tree a]
03:41:24 <quicksilver> then you get Branch [] as "empty"
03:41:29 <quicksilver> not quite sure what osaunders is after.
03:41:34 <osaunders> OK
03:41:51 <quicksilver> there are lots of fiddly variations on trees
03:41:58 <mm_freak_> does arrow notation optimize returnA away?
03:41:59 <osaunders> I‚Äôd like to be able to remove things from a tree in a monadic bind
03:42:24 <mm_freak_> (as far as it can)
03:42:49 <osaunders> :t (Node 'c' [] >>=)
03:42:50 <lambdabot> forall b. (Char -> Tree b) -> Tree b
03:43:06 <osaunders> ^ I can‚Äôt give an empty case from the function
03:43:33 <osaunders> So the tree can only really get better from doing tree >>= f
03:43:41 <osaunders> *bigger
03:44:06 <osaunders> It doen‚Äôt have to be a bind incidentally I just want to be able to remove things from a tree really
03:44:42 <quicksilver> I don't know what the best way to remove items from a tree monadically is.
03:44:49 <quicksilver> it's something I remember thinking about once :)
03:45:08 <osaunders> Trees are really lame sometimes
03:46:12 <companion_cube> tree is traversable, right?
03:46:28 <quicksilver> yes, but traversable specifically doesn't let you modify the shape
03:46:39 <quicksilver> one possibility is to use a monadic kind of tree
03:46:47 <quicksilver> and 'traverse' it with a function a -> Tree a
03:46:54 <quicksilver> well, a -> m (Tree a)
03:47:01 <adimit> what about a zipper monad?
03:47:03 <quicksilver> then you end up with a tree of trees Tree (Tree a)
03:47:13 <quicksilver> and you collapse it
03:47:22 <quicksilver> adimit: I know what a zipper is. What's a zipper monad?
03:47:30 <adimit> http://www.haskell.org/haskellwiki/Zipper_monad
03:47:44 <adimit> I'm honestly not very familiar with zippers/zipper monads in general.
03:48:02 <quicksilver> well that's just a way of using zippers, it looks like
03:48:07 <adimit> more of a "have you also considered, maybe it'll be what you're looking for."
03:48:11 <quicksilver> the thing is zippers are about starting somewhere and then moving around
03:48:24 <quicksilver> they do let you edit in place but that doesn't sound exactly like what osaunders wanted
03:48:27 <quicksilver> maybe, though :)
03:48:28 <adimit> yeah, but this seems to allow for mutation.
03:49:52 <leino> Is there some tutorial out there about how to make your own monad transformers?
03:50:02 <adimit> leino: RWH.
03:50:24 <adimit> there's a nice chapter about monad transformers.
03:50:28 <leino> real world haskell, I guess
03:50:38 <adimit> http://book.realworldhaskell.org/read/monad-transformers.html
03:50:44 <adimit> chapter 18 to be precise.
03:51:11 <adimit> I found it well explained and easy to follow.
03:51:16 <leino> thanks, I'll check it
03:51:32 <osaunders> quicksilver: adimit: I think I‚Äôd like to know what the type-class-free code for what I want to do is first, and then look for type classes that can help after
04:20:37 * hackagebot cairo 0.12.1 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.1 (DuncanCoutts)
04:20:39 * hackagebot gio 0.12.1 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.12.1 (DuncanCoutts)
04:20:41 * hackagebot glib 0.12.1 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.1 (DuncanCoutts)
04:20:43 * hackagebot gtk 0.12.1 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.1 (DuncanCoutts)
04:20:45 * hackagebot pango 0.12.1 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.12.1 (DuncanCoutts)
04:21:50 <dcoutts> hackagebot: is that all? that's only 5 / 15
04:24:26 <engla> what to do about redundancy in haskell? Use mfix or fixST?
04:24:28 <engla> etc
04:24:37 <hpc> :t mfix
04:24:38 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
04:24:41 <hpc> :t fixST
04:24:42 <lambdabot> forall a s. (a -> ST s a) -> ST s a
04:25:47 * hackagebot gtk2hs-buildtools 0.12.1 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.1 (DuncanCoutts)
04:25:49 * hackagebot gconf 0.12.1 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.12.1 (DuncanCoutts)
04:25:50 <engla> mfix I guess
04:25:51 * hackagebot glade 0.12.1 - Binding to the glade library.  http://hackage.haskell.org/package/glade-0.12.1 (DuncanCoutts)
04:25:53 * hackagebot gstreamer 0.12.1 - Binding to the GStreamer open source multimedia framework.  http://hackage.haskell.org/package/gstreamer-0.12.1 (DuncanCoutts)
04:25:55 * hackagebot gtkglext 0.12.1 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/gtkglext-0.12.1 (DuncanCoutts)
04:26:23 <Jafet> dcoutts: MTUs.
04:26:31 <dcoutts> ah I see, only 5 in one go
04:26:41 <bfig> hello... if i want to use ByteString and fold that together with a list, what should i use? there is no ZipWith that takes a ByteStream and other type of list
04:26:50 <bfig> ByteString i mean, not ByteStream
04:27:01 <Jafet> :t BS.unpack
04:27:01 <lambdabot> BSC.ByteString -> [Word8]
04:27:15 <bfig> so i should unpack, zip, then pack again?
04:27:29 <bfig> i mean, zip, do whatever i need to do, then pack the resulting array?
04:28:15 <bfig> i was wondering if there was a way to remain inside the ByteString world, maybe by adding simple state. where should i look in that case?
04:28:23 <Botje> bfig: depends. what are you doing?
04:28:48 <Jafet> Apparently not.
04:28:54 <bfig> Botje, read from a file, apply a byte independent transformation, reverse the result and save in another file
04:29:49 <Botje> you could use mapAccumL or R
04:30:12 <Jafet> Why are you averse to unpacking?
04:30:46 <bfig> i was just wondering, i want to make it as efficient as possible :p
04:30:57 * hackagebot gtksourceview2 0.12.3 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.12.3 (DuncanCoutts)
04:30:59 <Jafet> How would you write it more efficiently?
04:31:00 * hackagebot soegtk 0.12.1 - GUI functions as used in the book "The Haskell School of Expression".  http://hackage.haskell.org/package/soegtk-0.12.1 (DuncanCoutts)
04:31:01 * hackagebot svgcairo 0.12.1 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.12.1 (DuncanCoutts)
04:31:03 * hackagebot vte 0.12.1 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.12.1 (DuncanCoutts)
04:31:05 * hackagebot webkit 0.12.3 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.3 (DuncanCoutts)
04:31:09 <bfig> Jafet, what do you mean?
04:31:26 <Jafet> If you don't want to use unpack, what code would you write instead?
04:31:36 <ivanm> dcoutts: you involved back with gtk2hs?
04:31:42 <ivanm> or just quick bug-fixes?
04:31:44 <bfig> i don't know, that's why i'm asking... it is close enough to a list :)
04:31:52 <dcoutts> ivan: not really, just helping them do a release. I need it for ThreadScope
04:32:01 <ivanm> heh, fair enough
04:32:19 <Jafet> So you're comparing the performance of something you haven't measured to the performance of something you don't know how to write
04:32:30 <bfig> that is a very good point
04:32:36 <Jafet> There, I put it in perspective for you
04:32:45 * bfig goes back to the drawing board
04:34:06 <Jafet> To access ByteString internals, use ByteString.Internal.
04:36:28 <ivanm> and be prepared to have your code break at some future point since there are no API guarantees about the Internal modules
04:36:52 <Jafet> Well, I was going to mention that he might have to become dons or dcoutts to measurably beat unpacking anyways
04:37:05 <quicksilver> that is not the only option
04:37:10 <quicksilver> changing his name to Simon might word
04:37:11 <quicksilver> work
04:37:14 <ivanm> heh
04:37:54 <ivanm> at the very least bos or tibbe (as they could probably do so based upon their other stuff, even if they aren't as familiar with ByteString itself)
04:38:34 * tibbe appears
04:38:38 <tibbe> what's up?
04:39:17 <bfig> just handing a good ol' reality check
04:39:22 <dcoutts> tibbe: they're taking your name in vain
04:39:32 <tibbe> ah
04:39:51 <ivanm> to be fair, we took dcoutts' name in vain first...
04:41:05 <dcoutts> bfig: the simplest thing to do is to write a directly recursive variant of zip that uses head/tail on both lists and bytestring
04:41:12 <dcoutts> bfig: and that'll also be fast
04:42:04 <bfig> dcoutts, ok, gonna try that :)
04:42:25 <dcoutts> erm, head/tail/null
04:53:09 <bfig> Botje, mapAcummL seems to do *exactly* what i want :D
04:53:20 <Botje> yay
04:55:37 * hackagebot snap-core 0.5.4 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.4 (GregoryCollins)
04:55:39 * hackagebot snap-server 0.5.4 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.4 (GregoryCollins)
04:55:41 * hackagebot snap 0.5.4 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.4 (GregoryCollins)
04:56:57 <HugoDaniel> cool, new snap version
04:56:58 <HugoDaniel> :)
05:00:34 <hpaste> ‚ÄúMukesh Tiwari‚Äù pasted ‚ÄúMonad transformer‚Äù at http://hpaste.org/51268
05:01:46 <hpaste> ‚ÄúMukesh Tiwari‚Äù annotated ‚ÄúMonad transformer‚Äù with ‚ÄúMonad transformer (annotation)‚Äù at http://hpaste.org/51268#a51269
05:05:33 <hpaste> ‚ÄúMukesh Tiwari‚Äù pasted ‚ÄúMonad transformer‚Äù at http://hpaste.org/51270
05:06:02 <hpaste> ‚ÄúMukesh Tiwari‚Äù annotated ‚ÄúMonad transformer‚Äù with ‚ÄúMonad transformer (annotation)‚Äù at http://hpaste.org/51270#a51271
05:06:23 <born2code> hello all
05:06:45 <born2code> I am trying to learn Monad transformer and coded this http://hpaste.org/51270
05:06:54 <born2code> but getting compiler error
05:07:15 <born2code> could some one please tell me why this code is getting compiler error
05:07:41 <hvr> is there something like a monadic 'second' arrow-function in the base libs? i.e. something like      secondM :: Monad m => (b -> m c)-> (a,b) -> m (a,c)
05:07:43 <mauke> born2code: because the arguments to compare must have the same type
05:07:51 <bfig> Botje, less than a line of code :D
05:08:01 <mux> and because he sets g to an IO action instead of using <-
05:08:42 <born2code> mauke: i think both g and n are of same type
05:08:50 <mauke> born2code: the compiler disagrees
05:09:00 <mauke> born2code: the error says g :: t IO a, n :: Integer
05:09:00 <mux> yeah, and he tends to be annoyingly right at this :)
05:09:02 <born2code> mauke: ohhhh , i think i got you
05:09:21 <ClaudiusMaximus> woohoo, found the timeleak in my code.  now for brainhurts trying to figure out how to solve it...
05:09:32 <born2code> mauke:  i have explicitly mention Integer
05:09:38 <born2code> mauke: let me try this
05:10:20 <mux> born2code: long story short: replace "let g = ..." by "g <- ..."
05:11:56 <born2code> mux: thank you
05:12:35 <ClaudiusMaximus> so i have   lo, hi :: Rational   and   xp :: Int   and want to find   lo', hi' :: Integer   such that  lo' % 2^xp <= lo && hi <= hi' % 2^xp   with the bounds as tight as possible - now that i've written this context i think i can solve it :)
05:14:05 <mauke> floor (lo * 2^xp)
05:14:18 <ClaudiusMaximus> xactly
05:14:33 <ClaudiusMaximus> just didn't see it without having written down the real question :)
05:15:28 <bfig> to use things like toLower, isDigit, isAlpha, etc, in Word8 i need to do w2c?
05:15:52 <bfig> ie, c2w.dowhatever.w2c ?
05:16:08 * ClaudiusMaximus wonders if (2::Rational)^xp is going to be noticably slower than (bit xp % 1)
05:16:11 <bfig> or is there another way?
05:16:28 <mauke> bfig: but Word8 isn't characters
05:16:51 <bfig> isn't Char a wrapped Word8?
05:16:55 <mauke> what? no!
05:17:08 <Jafet> @where unicode
05:17:08 <lambdabot> I know nothing about unicode.
05:17:15 <Jafet> Of course you don't.
05:17:40 <bfig> let's assume i just need to parse a utf-8 file
05:17:43 <Jafet> @where+ unicode http://www.joelonsoftware.com/articles/Unicode.html
05:17:43 <lambdabot> Nice!
05:17:56 <Jafet> bfig: Data.Text.Encoding.decodeutf8
05:18:01 <mauke> bfig: IO should do that for you
05:18:09 <mauke> or rather, Handle
05:18:27 <Jafet> Except on windows?
05:18:37 <bfig> i'm using bytestring, and i have a function that works with Word8's, and i have to filter by some char-bound rules like isAlpha, isUpper, etd
05:18:43 <bfig> etc*
05:19:20 <mauke> you should decode to Chars first
05:19:36 <maloi> if i have something like datatype User = User { name :: String, password :: String, email :: String } and I want to make them easily sortable after all fields should i make a map for every field like type UserMap = Map.Map String User for the name?
05:19:37 <mauke> > toUpper '\255'
05:19:38 <lambdabot>   '\376'
05:19:58 <knoc> > toUpper '\10000'
05:19:59 <lambdabot>   '\10000'
05:20:43 <hpaste> obi pasted ‚Äúhow to get type right?‚Äù at http://hpaste.org/51272
05:22:17 <mauke> obiwahn: remove the type signature, ask the compiler
05:24:50 <int-e> obcode: perhaps you want  data Term a = Con a | Div (Term a) (Term a) | Sqrt (Term a)
05:25:08 <obiwahn> ok :) how should i rewrite data to use anything special
05:25:36 <obiwahn> like it should not be Float and or Num but it should belog to 2 different Classes
05:25:59 <mauke> huh?
05:26:21 <parcs_> > let ?xs = [1..] in (`execState` []) $ (`runContT` return) $ callCC $ \(($()) -> break) -> forM_ ?xs $ \x -> callCC $ \(($()) -> continue) -> do
05:26:21 <parcs_> when (odd x) continue; modify (++[x]); when (x == 20) break
05:26:22 <lambdabot>   <no location info>: Empty 'do' construct
05:26:25 <obiwahn> oh stupid:)
05:26:47 <parcs_> anyway, that works as expected. man that's awesome
05:27:22 <obiwahn> i was thingking about the (Show a, Ord a) =>  .... but i guess i have to make sure that the type i give to the monad derives the stuff i want to use
05:28:19 <obiwahn> can i put it like that or am i telling nonsense - i am not so sure:(
05:32:47 <osaunders> So, if anyone is still interested in how you remove things from a tree, here it is: https://gist.github.com/1211233
05:33:04 <bfig> Jafet, excellent page
05:33:48 <bfig> still, i'm only interested in alphanumeric and number characters which should be universally <128
05:34:01 <bfig> (Everything else is supposed to be removed)
05:34:07 <koeien> so that's ASCII.
05:34:35 <mauke> > isAlpha '\229'
05:34:35 <lambdabot>   True
05:34:40 <Jafet> Oh that's great then, use Char8.
05:34:43 * Jafet runs away
05:37:24 <bfig> mmm i just found that mapAccumR is not exactly what i need... what i really need is something like mapAccumRJoin :p
05:38:23 <bfig> (ie, a signature like this: mapAccumRJoin::(Int->Word8->(Int,[Word8])->ByteString->ByteString
05:39:21 <Jafet> Dude, you forgot to close your parentheses... twice
05:40:16 <bfig> lol... *  mapAccumRJoin::(Int->Word8->(Int,[Word8]))->ByteString->ByteString
05:40:35 <int-e> Jafet: ))) (There, that should restore the balance. *ducks*
05:43:06 <dmwit> int-e: Haha, joke's on you! You actually finally closed a parenthesis left open from TEN YEARS AGO!!
05:43:14 <Jafet> int-e: it will take more than one of you to restore balance to the sins of ages past
05:43:59 <bfig> ))))
05:44:15 <Saizan> ]
05:44:17 <bfig> now there is a real problem... i have closed more parenthesis than i've ever opened
05:44:49 <meteficha> =/
05:44:50 <bfig> but there is no way of opening something which has already been closed... paradoxically
05:44:57 <dmwit> bfig: I find it hard to believe you've only ever struck the ( key three times in your entire life...
05:45:00 <flux> there could be a variant of lisp where ] would mean 'double the number of preceding close parns', so you could easily close tons of parens with )]]]
05:45:25 <dmwit> flux: The more sane variant has ] closing all open parens.
05:45:30 <dmwit> (And there is such a one.)
05:45:30 <int-e> bfig: Seems to work fine in real life. For most doors, for example.
05:45:32 <bfig> fix (\f -> ']':f)
05:45:45 <int-e> bfig: repeat '}'
05:46:04 <flux> dmwit, meh, you could do that with an empty line
05:46:07 <dmwit> > cycle ')'
05:46:08 <lambdabot>   Couldn't match expected type `[a]'
05:46:08 <lambdabot>         against inferred type `GHC.Types...
05:46:12 <dmwit> whoops
05:46:16 <dmwit> > repeat ')'
05:46:17 <lambdabot>   "))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))...
05:46:21 <bfig> cycle "}"
05:46:21 <dmwit> I always get those mixed up.
05:46:24 * int-e waits for the inevitable unicode brackets.
05:46:26 <bfig> >cycle "}"
05:46:35 <bfig> > cycle "}"
05:46:36 <lambdabot>   "}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}...
05:47:22 <int-e> > map pred $ cycle "sproe!boe!"
05:47:23 <lambdabot>   "roqnd and roqnd and roqnd and roqnd and roqnd and roqnd and roqnd and roqn...
05:47:34 <ivanm> int-e: close! :p
05:48:32 <int-e> yeah. next time, will use ghci.
05:48:36 <Jafet> @@ @vixen (@run cycle ":-) ")
05:48:37 <lambdabot>  have you ever scubadived?
05:49:04 <ivanm> @@ @vixen @protontorpedo
05:49:04 <lambdabot>  who's to say?
05:54:05 <dmwit> > foldl f z [x,y]
05:54:05 <lambdabot>   f (f z x) y
05:54:33 <dmwit> > (x `f` y) `f` z
05:54:33 <lambdabot>   Ambiguous type variable `t' in the constraints:
05:54:33 <lambdabot>    `GHC.Show.Show t'
05:54:33 <lambdabot>      a...
05:54:41 <dmwit> > (x `f` y) `f` z :: Expr
05:54:42 <lambdabot>   Ambiguous type variable `t' in the constraints:
05:54:42 <lambdabot>    `GHC.Show.Show t'
05:54:42 <lambdabot>      a...
05:54:49 <dmwit> :t x
05:54:50 <lambdabot> Expr
05:54:53 <dmwit> help?
05:55:33 <hpaste> maloi pasted ‚Äúrefactor me please‚Äù at http://hpaste.org/51273
05:55:37 * hackagebot persistent-mongoDB 0.6.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.6.1 (GregWeber)
05:56:30 <Botje> maloi: just pass the function along?
05:56:38 <frerich> maloi: Can't you just change 'sortUser' to 'sortUserBy f = sortBy (compare `on` f)' ?
05:56:46 <Botje> name, pwd and email are perfectly valid User -> String functions
05:57:06 <dmwit> Also, comparing f = compare `on` f
06:00:57 <maloi> thanks i had problems with the type signature of sortUser but ghci helped me out :)
06:01:56 <hpaste> ‚ÄúMukesh Tiwari‚Äù pasted ‚ÄúMonad transformer‚Äù at http://hpaste.org/51274
06:02:46 <hpaste> ‚ÄúMukesh Tiwari‚Äù annotated ‚ÄúMonad transformer‚Äù with ‚ÄúMonad transformer (annotation)‚Äù at http://hpaste.org/51274#a51275
06:03:42 <born2code> I am trying recursion using Monad transformer but getting compiler error .
06:04:07 <born2code> could some one please tell me why this code is giving compiler error http://hpaste.org/51274
06:04:54 <Botje> born2code: you probably mean liftIO $ putStrLn ...
06:05:32 <Botje> born2code: hmm, maybe not.
06:05:50 <Botje> born2code: but you *should* lift your recursive evalStateT
06:06:56 <born2code> Botje: i did not get you.
06:07:11 <Botje> born2code: recurFun is StateT ... IO a, right?
06:07:25 <Botje> born2code: so evalStateT (recurFun ...) ... is IO a
06:07:41 <hpaste> maloi annotated ‚Äúrefactor me please‚Äù with ‚Äúrefactor me please (annotation) Better now?‚Äù at http://hpaste.org/51273#a51277
06:07:41 <Botje> but you are trying to evaluate that in a StateT ... IO a monad
06:07:45 <Botje> so you should do liftIO
06:08:15 <Botje> sortUser = sortBy . comparing
06:08:33 <maloi> ok point free, right?
06:08:53 <Botje> i would keep it like you have it though, it's easier to see at a glance.
06:09:13 <maloi> ok thank you all
06:10:29 <born2code> Botje: thank you
06:11:23 <maloi> when i want to search a user by all fields, what's a good way to do so?
06:15:08 <Milo_> Does anybody know a elegant way to get the location (e.g. FilePath) out of a Handle? Am I blind to the API doc?
06:18:12 <maloi> i think a handle does not know anything about the location
06:19:38 <mauke> Milo_: why do you need that?
06:20:01 <Milo_> It does. It is givin in the output of   hShow   . field named loc. hoped that there would be a simpler way than to parse it
06:21:22 <Milo_> I might need to reuse a handle if a given filepath is already opened in WriteMode
06:22:01 <meteficha> Milo_: Map FilePath Handle?
06:23:32 <Milo_> yea, maybe. didn't wan't to introduce yet another wrap.
06:23:40 <Milo_> -'
06:27:00 <parcs_> is HList the only library that provides hetergenous lists?
06:28:03 <shachaf> That depends on what you mean by "hetergenous lists".
06:28:12 <maloi> Milo_: hShow is not portable, right?
06:28:30 <scooty-puff> is it possible to have ghc generate _stub.{c,h} files, and do nothing else?
06:28:39 <parcs_> shachaf: heterogenous
06:29:16 <shachaf> parcs_: It still depends on what you mean by it. :-)
06:30:47 <adimit> ‚Ä¶ ok, I feel stupid. Given f :: a -> b -> c and g :: c -> d, how can I form h :: a -> b -> d besides h = curry $ g . uncurry f ?
06:31:13 <koeien> (f.).g -- maybe?
06:31:21 <mauke> \x y -> f (g x y)
06:31:25 <mux> @pl \f g x y -> g (f x y)
06:31:26 <lambdabot> flip ((.) . (.))
06:32:01 <mux> @pl \x y -> g (f x y)
06:32:01 <lambdabot> (g .) . f
06:32:02 <roconnor> @pl \f g x y -> f (g x y)
06:32:02 <lambdabot> (.) . (.)
06:32:21 <adimit> ok, thanks. I think it's (g.).f, though, but thanks!
06:32:22 <mux> roconnor: it's the other way around
06:32:30 <koeien> adimit: yes it is
06:32:33 <roconnor> @pl \g f x y -> g (f x y)
06:32:33 <lambdabot> (.) . (.)
06:32:41 <roconnor> :)
06:32:47 <roconnor> but ya (g.).f is the way to go
06:32:58 <adimit> composing functional composition is where my brain just stops working.
06:33:14 <roconnor> I've seen that pattern so much that my brain now instantly recoginizes it
06:33:27 <adimit> I needed it for "not any" ‚Ä¶
06:33:30 <roconnor> so much so that I now consider it usable in code.
06:33:31 <parcs_> shachaf: i guess what i really want is a type-level list and constraints/operations on this list
06:33:41 <adimit> ‚Ä¶ felt so silly not being able to do it.
06:34:04 <shachaf> parcs_: As in a list of values of different types all of which are in a particular type class?
06:34:37 <parcs_> no :P
06:34:51 <shachaf> Oh, type-level list.
06:35:28 <parcs_> HList seems messy
06:35:57 <shachaf> parcs_: I think people sometimes just define Cons and Nil themselves.
06:37:40 <parcs_> i guess that's my best bet
06:38:54 <adimit> :t (.)(.) -- I can't believe it‚Ä¶
06:38:55 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
06:41:55 <parcs_> :t (.)(.)(.) -- the triple boob operator is more useful
06:41:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:07:15 <scrappy_doo> Good morning, Haskell brainiacs
07:10:37 * hackagebot gf 3.2.9 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.2.9 (ThomasHallgren)
07:13:35 <scrappy_doo> I'm having a problem with exceptions in GHCI.  My program is supposed to come out of a call to Control.Concurrent.threadDelay when I type <CTRL>-C, but sometimes it doesn't respond.
07:14:33 <Olathe> scrappy_doo: I don't know much about GHC, but I know programs it generates frequently don't respond to Ctrl-C when they get really into something.
07:15:40 <scrappy_doo> Olathe is there a reason for that?
07:16:40 <Olathe> I assume it screws up in making a signal handler when it generates C or assembler, but I don't know.
07:17:26 <scrappy_doo> So I should rewrite my code in PHP?
07:17:44 <Olathe> Well, that's one solution :)
07:20:13 <Olathe> If you'd be OK with the time and effort, please file a bug report before you switch, though.
07:20:42 <scrappy_doo> Where?
07:22:24 <scrappy_doo> trying http://hackage.haskell.org/trac/ghc/wiki/ReportABug
07:22:39 <Olathe> Let me check.
07:23:02 <Olathe> Yeah, that's it :)
07:23:14 <EvanR-work> well you can install sig handler manually
07:23:27 <EvanR-work> which is what i did to cause ctrl C to do orderly shutdown
07:23:31 <Olathe> EvanR-work: Ahh, how?
07:23:37 <EvanR-work> System.POSIX
07:23:53 <EvanR-work> System.Posix
07:24:06 <Eduard_Munteanu> http://stackoverflow.com/questions/2349233/catching-control-c-exception-in-ghc-haskell
07:24:31 <Eduard_Munteanu> There's a bug report too, might be related: http://hackage.haskell.org/trac/ghc/ticket/2301
07:25:52 <sbrg> hmm. Given a list of integers, how would I transform it easily into a list that is basically 'the sum of elements up to the current element' so to speak. so [1,2,3,4] = [1, 3, 5, 9]. Can't scanl or some nifty fold do this?
07:26:59 <Olathe> > scanl (+) 0 [1..10]
07:26:59 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
07:27:06 <sbrg> thought so
07:27:13 <sbrg> I don't quite grok those well enough
07:27:17 <sbrg> thanks, Olathe
07:27:21 <Olathe> You're welcome.
07:28:49 <Olathe> > scanl1 (+) [1..10]
07:28:50 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
07:29:33 <byorgey> > scanl f z [a,b,c,d]   -- sbrg, this is what scanl does
07:29:33 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
07:29:52 <byorgey> hmm, maybe that's a little hard to read
07:30:31 <EvanR-work> lol
07:30:31 <Olathe> > scanl (+) z [a, b, c, d]
07:30:32 <lambdabot>   [z,z + a,z + a + b,z + a + b + c,z + a + b + c + d]
07:30:32 <byorgey> scanl (#) z [a,b,c] ==  [z, z # a, z # a # b, z # a # b # c]
07:30:44 <byorgey> ah, thanks Olathe =)
07:30:51 <Olathe> No problem :)
07:30:58 <sbrg> ooh, lambdabot can do that? Wicked.
07:31:36 <byorgey> sbrg: it's a bit magical but yes, quite useful for illustrating scans and folds and such
07:31:43 <byorgey> > foldr f z [a,b,c]
07:31:44 <lambdabot>   f a (f b (f c z))
07:31:59 <tgeeky> :t a
07:32:00 <lambdabot> Expr
07:32:02 <tgeeky> :t b
07:32:03 <lambdabot> Expr
07:32:05 <tgeeky> there's the magic :o
07:32:10 <byorgey> pay no attention to the man behind the curtain!
07:32:16 <Eduard_Munteanu> > deriv sin x
07:32:17 <lambdabot>   1 * cos x
07:32:19 <Cale> Only a little bit magical. It's implemented with plain old typeclasses.
07:32:32 <sbrg> wut @ deriv
07:32:36 <sbrg> >:t deriv
07:32:38 <sbrg> eh
07:32:40 <sbrg> :t deriv
07:32:41 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
07:32:43 <byorgey> sufficiently advanced Haskell is indistinguishable from magic
07:32:44 <EvanR-work> >:E
07:32:54 <Eduard_Munteanu> Heh.
07:33:26 <sbrg> > deriv e^x
07:33:26 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
07:33:26 <lambdabot>                        ...
07:33:43 <EvanR-work> is Expr like... uses unbound variables as polymorphic standins for single variable expression or ...
07:33:44 <sbrg> eh, guess I should be using something else for e as a constant?
07:33:54 <byorgey> > deriv (exp x)
07:33:54 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
07:33:54 <lambdabot>                        ...
07:33:57 <EvanR-work> > x
07:33:58 <lambdabot>   x
07:34:09 <byorgey> > deriv exp
07:34:10 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:34:10 <lambdabot>    arising from a use of `...
07:34:13 <EvanR-work> > let x = 5 in y + x
07:34:13 <lambdabot>   y + 5
07:34:20 <byorgey> > deriv exp x  -- aha
07:34:20 <lambdabot>   1 * exp x
07:34:26 <sbrg> Does it reduce expressions as well?
07:34:31 <sbrg> can it*
07:34:41 <EvanR-work> > let x = 5 in y + y + x
07:34:41 <lambdabot>   y + y + 5
07:34:58 <byorgey> sbrg: well, of course it can evaluate things, but it doesn't do symbolic reduction
07:35:21 <sbrg> ah
07:35:24 <byorgey> > deriv (exp . exp) x
07:35:25 <lambdabot>   1 * exp x * exp (exp x)
07:35:32 <tarrasch> Hello, a question about naming conventions: I remember seeing that the accesors/destructors for record syntax usually start with "_" or something. Have anyone ever seen it or know anything else on the subject?
07:36:15 <byorgey> tarrasch: that's if you're using a system to automatically generate some lenses/functional references for a record
07:36:32 <byorgey> tarrasch: most such tools by convention look for field names starting with _
07:36:47 <tarrasch> The problem is that i get alot of ghc-warnings since when I pattern-match like `(MyRecord a b c)` I get 3 warnings saying that I already have the destructors 'a', 'b', and 'c' in scope
07:37:08 <tarrasch> byorgey, oh ok, so that's where it comes from
07:37:40 <ClaudiusMaximus> maybe you want record wildcards or named field puns or whatever the extension is
07:37:58 <byorgey> tarrasch: if you turn on some extension you can write  (MyRecord {..})  I think
07:38:19 <byorgey> RecordWildCards
07:38:26 <ClaudiusMaximus> i don't like it, makes it impossible for me to read code i'm not familiar with
07:39:02 <byorgey> personally, I just wouldn't name record fields a, b, and c
07:40:10 <byorgey> and when I do use record field names I don't pattern match on the record positionally
07:41:09 <tarrasch> https://github.com/Tarrasch/DtekPortalen/blob/master/CalendarFeed.hs#L50-56 is the use case, the accesors have suitable names, but they are also suite in the pattern matchings
07:41:25 <tarrasch> (so they are not labeled abc) :p
07:41:35 <byorgey> heh, ok =)
07:42:35 <tarrasch> is it considered bad to patternmatch on records positionally?
07:43:17 <byorgey> oh, I see, you are not pattern matching, you are constructing one
07:43:29 <copumpkin> tarrasch: god kills a kitten every time you do it
07:43:54 <EvanR-work> _ _ _ _ _ _ 5 _ _  ;)
07:44:22 <byorgey> well, it's not THAT bad, but it just calls into question why you gave the fields names in the first place if you're not going to use them.
07:44:46 <tarrasch> byorgey, oh, right
07:44:53 <tarrasch> byorgey, I'm pattern matching here https://github.com/Tarrasch/DtekPortalen/blob/master/StandardLayout.hs#L37
07:45:13 <tarrasch> but constructing and pattern matching both have the same problem with shadowing
07:45:16 <byorgey> tarrasch: I'd say either give those local variables different names, or just ignore the warning.
07:46:04 <tarrasch> byorgey, yea, I guess it's just simplest renaming them. There is no obvious thing to do. And I heard god kills a kitten for every warning you ignore :p
07:46:15 <EvanR-work> er.. what is 'the problem' with shadowing
07:46:23 <byorgey> tarrasch: ok, so in the pattern matching case, I would prefer writing  niceShowEvent event =  .... title event ... startTime event ... etc.
07:46:33 <EvanR-work> it makes code more locally understandable
07:46:45 <tarrasch> byorgey, hmm. that's a good idea
07:46:45 <byorgey> it's a bit longer but more robust in case you decide to reorder or add fields
07:46:56 <copumpkin> record wildcards and puns is where it's at
07:47:12 <copumpkin> especially if you shadow your wildcards and pun with the shadows
07:47:24 <copumpkin> then it just feels like you're mutating variables!!
07:47:44 <tarrasch> EvanR-work, are you sugggesting shadowing is "ok"?
07:49:03 <parcs_> fortunately RecordWildCards doesn't trigger shadowing warnings
07:49:07 <byorgey> well, God only kills an ugly kitten when you ignore a shadowing warning.
07:49:25 <EvanR-work> tarrasch: lexical scope is one of the greatest achievments of 1960s computer language
07:49:39 <EvanR-work> acheivements
07:49:54 <EvanR-work> god dammit
07:50:00 <EvanR-work> spelling is stupid
07:50:08 <tarrasch> Also I hope they implement the OO inspired syntax with `event.startTime` rather than the weird `startTime event`
07:50:17 <franny> Not BASIC? ;)
07:50:21 <tarrasch> EvanR-work, hehe, you're right about that :)
07:50:28 <EvanR-work> tarrasch: thats monumentally stupid
07:50:42 <EvanR-work> . notation cant be composed
07:50:52 <parcs_> tarrasch: just append to your accessor 'Of'
07:50:58 <byorgey> tarrasch: so event.startTime is field access but event . startTime is function composition?
07:51:05 <byorgey> ugh =)
07:51:08 <tarrasch> EvanR-work, I think some serious people are seriously discussing it
07:51:13 <EvanR-work> tarrasch: that sucks
07:51:17 <EvanR-work> have fun in hell
07:51:20 <Eduard_Munteanu> > let (.) = flip ($) in event . startTime
07:51:20 <lambdabot>   Not in scope: `event'Not in scope: `startTime'
07:51:22 <parcs_> haha
07:51:27 <tarrasch> byorgey, Yes, that means the whitespacing around the . will alter it's meaning
07:51:47 <byorgey> I know we already have that for qualified module names, but that was a mistake too.
07:52:17 <byorgey> tarrasch: I seriously doubt serious people are seriously discussing it.
07:52:30 <tgeeky> byorgey: surely, you can't be serious
07:52:38 <EvanR-work> tarrasch: the notation for javascript is a common popular example of how this goes horribly wrong
07:52:57 <byorgey> well, I take it back.  serious people may be seriously discussing it, but that has little bearing on whether it will actually get implemented
07:53:01 <EvanR-work> it basically eliminates 90% of the expressivity of the notation
07:53:49 <EvanR-work> oop is a cancer
07:53:53 <tgeeky> byorgey: I was hoping for "I am serious, and don't call me Shirley!"
07:54:21 <parcs_> > let (.) = flip ($) in (Node 5 []).rootLabel
07:54:22 <lambdabot>   5
07:54:23 <byorgey> tgeeky: oh! sorry, I missed it =)
07:54:42 <valberg> hi - anyone know how to get haskell-platform working on debian unstable?
07:55:10 <byorgey> valberg: what goes wrong?
07:55:37 <tarrasch> EvanR-work, byorgey, Maybe I misunderstood it's meaning, but I think here is worth reading about it http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
07:55:40 <mah_b> How can I resolve this linker error: undefined reference to 'containerszm0zi4zi0zi0_DataziIntMap_lookup_closure' ?
07:56:02 <copumpkin> ghc --make
07:56:06 <copumpkin> assuming it's an old ghc
07:56:11 <EvanR-work> tarrasch: thats something else
07:56:32 <valberg> byorgey: aptitute says the following http://hpaste.org/51280
07:56:36 <tarrasch> EvanR-work, oh ok, I should perhaps read it more carefully then.
07:56:39 * Eduard_Munteanu expects p (->) x = readIORef p >>= return Prelude.. (. x)
07:56:47 <bayesian> Automatic Haskell programming
07:56:54 <EvanR-work> tarrasch: but it does talk about as aspect of oop systems which is also stupid
07:57:02 <EvanR-work> that is, using 'classes' as namespaces
07:57:09 <Eduard_Munteanu> s/(->)/->/
07:57:21 <byorgey> tarrasch: yes, I know about that proposal, and I am quite certain it will never be implemented, for both theoretical and practical reasons
07:57:32 <EvanR-work> or classes as objects, if the contents are mutable, bizarre
07:57:48 <byorgey> tarrasch: the practical reason being that it would require interleaving the name resolution and typechecking phases, which in GHC are currently separate
07:58:12 <mah_b> cocopumpkin: How can I change the 'main' function --make uses?
07:58:31 <copumpkin> --main-is or something like that
07:58:33 <copumpkin> can't remember
07:58:36 <copumpkin> that changes the module main is in
07:58:37 <EvanR-work> its still not what tarrasch was originally talking about. which is myFoo.f rather than f myFoo or Foo.f myFoo
07:58:37 <byorgey> mah_b: -main-is Module.function
07:58:51 <byorgey> only *one* hyphen before -main-is, for some strange reason
07:58:54 <bayesian> artificial implementation
07:59:18 <copumpkin> I hate the lack of conventions around -- options and - options
07:59:25 <copumpkin> across all unixy tools
07:59:31 <tarrasch> EvanR-work, oh ok. I misunderstood it, but check out ' get :: S -> Int;  get s = s.x + s.y', isn't that precisely what I said? or am I missing something fundamental EvanR-work ?
07:59:51 <EvanR-work> youre right
07:59:51 <copumpkin> . isn't an accessor
08:00:04 <Eduard_Munteanu> It could be :P
08:00:14 <EvanR-work> but now . means three different, or more, things
08:00:41 <EvanR-work> that would suck, and i fall back to javascriptism is stupid
08:01:56 <merijn> TDNR is awesome, except I'm not sure about the dot operator for it (the same goes for pretty much everyone, I guess)
08:02:18 <merijn> Changing (.) would break obscene amounts of existing code and keeping it would make the dot really confusing
08:02:37 <tgeeky> merijn: people have done it
08:02:44 <tgeeky> merijn: plus, it would only change it for the code you write
08:02:51 <tgeeky> so if nobody else reads your code, nobody would be confused
08:02:51 <tarrasch> merijn, if it's an optional extension, that wouldn't break existing code, or?
08:03:04 <valberg> byorgey: any idea on how I get those packages missing? http://hpaste.org/51280
08:03:46 <merijn> tarrasch: I guess, but that'd mean sacrificing nice looking function composition
08:04:29 <tarrasch> merijn, no, I meant that you don't att the {-# Langauge TDNR #-} on old source files, just new files, so old code won't change
08:04:49 <EvanR-work> im still trying to figure out why it would be desirable
08:05:00 <merijn> tarrasch: Yes, but you couldn't use (.) in new source code then
08:05:02 <tarrasch> and you don't loose function composition as  'f . g' would be different from 'f.g'
08:05:17 <bayesian> disgusting
08:05:17 <tarrasch> if I'm not mistaken, that's what they suggested
08:05:30 <tarrasch> EvanR-work, read the motivation?
08:05:33 <merijn> tarrasch: Which makes the . really confusing
08:05:49 <merijn> EvanR-work: Well, less sucky record syntax is pretty damn desirable
08:06:18 <tarrasch> merijn, yea, but I think it's worth it. How hard can it be to disginguish the two dots?
08:06:36 <merijn> tarrasch: Three, it can also be qualified imports
08:06:51 <tgeeky> just use the unicode circle (o) thing as func. composition
08:06:55 <tgeeky> and use (.) for whatever you want
08:07:13 <tarrasch> We've all seen how imba the Java IDEs become when you write 'myclass.' and it expands out the class methods. It's the same reason I think the extension is suggested
08:07:20 <ben> What do we use ‚óè for?
08:07:25 <merijn> tgeeky: Unicode will of course solve all our problems (lambda for lambda's!)
08:07:36 <merijn> Now all we need to do is find a non-sucky input method for unicode...
08:07:38 <engla> Œªx.x
08:07:42 <tgeeky> merijn: or you could actually use (o) <-- the letter o
08:07:45 <tgeeky> for function composition
08:07:52 <tgeeky> oh wait, you can't
08:08:03 <eikke> tgeeky: `o`
08:08:05 <Eduard_Munteanu> f ‚àò g
08:08:12 <EvanR-work> merijn: ive never been swayed by the rally against record syntax
08:08:24 <merijn> EvanR-work: Why not?
08:08:30 <tarrasch> EvanR-work, you like record syntax?
08:08:32 <EvanR-work> its just never struck me as bad
08:08:37 <bayesian> lambda calculus has never been observed in nature
08:08:49 <bayesian> despite the lies of functionalists
08:08:54 <merijn> EvanR-work: You cannot have two datatypes with the same record field, that's a pretty damn limiting restriction
08:08:55 <EvanR-work> i suppose i dont tend to use giant hierarchies of data
08:09:20 <quicksilver> merijn: I don't really understand that objection as stated
08:09:25 <quicksilver> you can't have two functions with the same name
08:09:35 <EvanR-work> merijn: is this a theoretical gripe of yours, or did it actually harm a project you were working on
08:09:36 <quicksilver> you can't have two types with the same name
08:09:36 <ben> I've not been bothered much by the whole record syntax thing but looking at some frege samples, it's kinda nice to write java field accesses down that directly :V
08:09:45 <quicksilver> how is the field thing different?
08:09:46 <merijn> quicksilver: If function resolution is based on type then they two functions wouldn't collide, no?
08:09:55 <merijn> s/they/the
08:09:59 <EvanR-work> this isnt c++
08:10:02 <quicksilver> that doesn't answer my objection
08:10:07 <EvanR-work> you cant have two things with the same name differentiated by type
08:10:15 <quicksilver> TDNR is a vile idea, but that's not my point anyway
08:10:33 <quicksilver> I was just seeking clarification on "You cannot have two datatypes with the same record field, that's a pretty damn limiting restriction"
08:10:38 <ben> EvanR-work: Isn't that what type classes are all about? <:)
08:10:43 <quicksilver> you're not alone in saying that, but I don't understand it.
08:10:43 <EvanR-work> no
08:10:55 <quicksilver> ben: in a sense, yes, but type classes are the elegant solution
08:11:07 <quicksilver> TDNR is like typeclasses re-invented badly.
08:11:19 <tarrasch> why is it that I always ask a simple question and it ends with a big discussion in this channel? :p
08:12:38 <Saizan> it's a vibrant community
08:12:48 <merijn> quicksilver: If I have Files and some other resource which have certain permissions associated with them, why do I need to come up with contrived names for the permissions field in their datatype to avoid collision? You statically know which datatype you have...
08:12:57 <quicksilver> and this is a contentious issue without an obvious right answer
08:12:57 <merijn> quicksilver: There's a bazillion similar examples
08:13:23 <Saizan> we have a module system to disambiguate names
08:13:38 <quicksilver> merijn: if I have two different functions which both set the permissions for something (different things, presumably) why can't I call them both 'setPermission' ?
08:14:04 <quicksilver> merijn: if I have two different datatypes which both model permissions (in different contexts, I suppose) why can't I call both datatypes data Permission = ?
08:14:11 <ben> I don't feel like prefixing all sorts of things with B. and L. and S. and M. is a solution to be proud of really
08:14:49 <EvanR-work> ben: i find thats not even necessary since you should not be doing tons of shit in one module anyway
08:14:55 <quicksilver> merijn: ...I don't understand what it is about the field case which is somehow a more egregious problem than the analogous problem for function names or type names.
08:15:38 * hackagebot Glob 0.6 - Globbing library  http://hackage.haskell.org/package/Glob-0.6 (MattiNiemenmaa)
08:15:40 <ben> EvanR-work: It's a thing  see sometimes when looking at library sources in hoogle or whatever, I dunno
08:15:41 <EvanR-work> if you are using A. B. C. and D.commonFieldName in one module, seems like something went wrong
08:15:48 <merijn> quicksilver: I don't like those other issues either :p The difference is that data and function declarations have no other scope then their containing module so there is no unambiguous way to discern them currently
08:15:55 <EvanR-work> ben: yeah, some people have bad style
08:15:59 <ben> Well, call it length instead of commonFieldName to get on quicksilver's track
08:16:13 <quicksilver> yes, length is a good example, ben
08:16:25 <merijn> However, record declarations provide an unambiguous scope for the names, the datatype they're associated with
08:16:35 <quicksilver> namespace management is an issue for sure, but I don't understand why people seem to think it's a *worse* problem for records.
08:17:06 <quicksilver> merijn: data declarations provide an unambigous scope for constructors but we still can't share constructor names.
08:17:15 <EvanR-work> hey guys we need namespaces, also we need 12 ways to do it
08:17:27 <merijn> quicksilver: Also bloody annoying
08:17:35 <quicksilver> merijn: to you, perhaps, but not to me :)
08:17:37 <Saizan> maybe we should just make datatype definitions generate a module too :)
08:17:55 <bfig> maybe we should just program in python
08:17:55 <quicksilver> Saizan: local or "more lightweight" modules would be nice.
08:17:56 <EvanR-work> merijn: so is it just a hypothetical gripe or actually messes up one of your real projects?
08:17:58 <quicksilver> so would local types.
08:18:40 <quicksilver> merijn: the thing we gain from all this is that most terms, on their own, have a well-defined type, they mean something, and they can be passed around as first-class values.
08:18:43 <merijn> EvanR-work: I've run into it multiple times. It's not anything capable of messing up projects, but it annoys the crap outta me and the work around looks ugly
08:18:48 <quicksilver> e.g "Just" is a term, it has a unique type
08:18:58 <quicksilver> similarly "maybe" is a term, it has a unique type
08:19:09 <quicksilver> and so does "myRecordSelector"
08:19:11 <tarrasch> Saizan, yes, it's a vibrant community, and I love it. Though it feels like these discussions can take quite some time, and some people are seen here regularly aswell
08:19:18 <tac-tics> EvanR-work: Any sufficiently large annoyance is indistinguishable from a show stopper
08:19:23 <merijn> "unreasonable gripes" is my middle name
08:19:38 <EvanR-work> tarrasch: are you getting impatient?
08:19:57 <Saizan> tarrasch: did you get your original problem sorted out?
08:20:01 <quicksilver> I think the *real* problem with haskell records is not the nonsense about namespaces at all
08:20:08 <quicksilver> but it's the fact that record update isn't first class.
08:20:13 <tarrasch> Saizan, yea, but I managed to to start a discussion afterwards :)
08:20:16 <quicksilver> the solution to that is to perfect fclabels.
08:20:35 <merijn> tarrasch: As long as questions get answered I don't see the problem? :p
08:20:55 <EvanR-work> i havent had a problem with update either, but first class would be nice
08:21:19 <tarrasch> merijn, on the contrary, I love these discussions! And it makes it worthwhile being here all the time, it's only that I find it to tempting to discuss here and then I realize it's midnight :p
08:21:37 * Saizan wants a coherent unification/relationship of modules records and typeclasses
08:21:55 <EvanR-work> radical
08:22:18 <quicksilver> Saizan: That sounds like a means rather than an end. I don't think I want that, for its own sake, but I can just about conceive that it might take you somewhere interesting.
08:22:35 <quicksilver> Saizan: are you are of a concrete proposal which shows some promising advantages from that approach?
08:23:00 <tac-tics> Sensible namespacing would be pretty cool in Haskell
08:23:07 <Saizan> for example, out of instance Foo a => Foo [a] i should be able to get a FooDict a -> FooDict [a] function
08:23:13 <tarrasch> For me these interesting discussions are a sort of healthy procrastination from my must-do work :)
08:23:24 <tarrasch> well not healthy, but educative
08:23:44 <tac-tics> tarrasch: who the heck is afforded the luxury of "must do" work in a language like Haskell?
08:23:47 <merijn> I think I spend like 3-4 hours of my 8 "working hours" working >.>
08:23:54 <tac-tics> Isn't Haskell programming predominantly "like to do" work?
08:24:27 <tgeeky> tac-tics: there is no generalization like that in Haskell anymore
08:25:15 <quicksilver> Saizan: automatic generation of implicit FooDict a type from a class Foo a?
08:25:29 <quicksilver> that's quite a new direction
08:25:34 <quicksilver> makes haskell feel much more self-aware
08:25:38 <tarrasch> tac-tics, nah, it's other academic studies, I'm just a student now :p
08:25:57 <Saizan> quicksilver: usually a good thing, no?:)
08:27:58 <quicksilver> Saizan: dunno really. I'm certainly not opposed to the idea.
08:28:38 <quicksilver> Saizan: but if you open the door to implicit generation of types, should you also generated BarCons for each type Bar, and isBaz :: Bar -> Bool for each constructor of Bar, and ...
08:28:53 <quicksilver> (presumably you'd do all this lazily so you didn't waste time on stuff which wasn't used)
08:29:11 <Saizan> SPJ has a paper on doing ML-like modules by exploiting records with higher rank fields and open scope existentials for abstract types
08:29:41 <merijn> Saizan: Doesn't this start going in the Epigram "automatic program derivation" direction?
08:31:02 <quicksilver> Saizan: you mean the rather old paper?
08:31:37 <quicksilver> if it's that one, then I read it, and it sounded interesting, but I thought it was telling that nobody ever implemented it.
08:31:39 <Saizan> quicksilver: that's easily done with TH now though, extracting functions between records out of instance declarations not so much
08:31:49 <Saizan> quicksilver: yep, i think so
08:32:47 <Saizan> merijn: i guess so
08:33:14 <Saizan> maybe i should ask on the list what happened to that proposal
08:33:21 <merijn> (I'm all in favor of that anyway, I'm much to lazy to actually program stuff myself)
08:35:58 <tac-tics> merijn: I hear you. Why write a useful program when you can prove it's possible to write a useful program?
08:36:54 <tgeeky> tac-tics: if your idea of 'useful' is 'safe', then why indeed
08:37:13 <Eelis> tac-tics: in a suitable logic, proving that it's possible and doing it are the same anyway ;)
08:40:18 <efie> is there a search engine such as hoogle for Graphics.UI.Gtk?
08:40:42 <Saizan> try hayoo
08:41:12 <efie> thanks
08:41:53 <parcs_> is it possible to implement a type-equality type family?
08:42:31 <Saizan> parcs_: seen (~) ?
08:43:18 <Saizan> ah, i guess you want a comparison that returns true or false rather than a constraint?
08:43:36 <parcs_> yeah, (~) but as a type function
08:44:10 <parcs_> returning the data types True or False
08:44:44 <parcs_> i can only provide the True case, it seems
08:44:54 <parcs_> type instance a :==: a = True
08:45:12 <Saizan> i think that's possible only with fundeps+OverlappingInstances atm, unless you want to supply an injection between any types you might want to compare and some encoding of the naturals
08:45:38 * hackagebot gtk-traymanager 0.1.2 - A wrapper around the eggtraymanager library for Linux system trays  http://hackage.haskell.org/package/gtk-traymanager-0.1.2 (TristanRavitch)
08:45:53 <Saizan> the last discussion the haskell-prime mailing list is about this
08:46:06 <byorgey> efie: hoogle should work for searching Graphics.UI.Gtk, what problem are you having?
08:46:13 <parcs_> nice, do you have a link?
08:46:54 <quicksilver> overlappinginstances is failure :)
08:46:59 <efie> byorgey: if i search for exmaple onEntryActivate nothing is found
08:47:18 <byorgey> efie: oh, try searching for onEntryActivate +gtk
08:47:33 <efie> ah.. :)
08:48:03 <byorgey> hoogle does not search in all packages by default, but if you want to search in a particular package you can add +package
08:48:18 <efie> ok
08:48:24 <Saizan> parcs_: it started earlier but this seems the most relevant post http://www.haskell.org/pipermail/haskell-prime/2011-June/003423.html
08:48:49 <Saizan> quicksilver: it works if you can pretend the class is closed :)
08:49:32 <parcs_> thanks
08:50:23 <parcs_> wait if i implement it as a class constraint then i can't use it in type families, can i?
08:50:38 * hackagebot taffybar 0.1.3 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.1.3 (TristanRavitch)
08:50:44 <Saizan> parcs_: no
08:50:51 <efie> byorgey: i want a function which simulates that enter was hit .. any idea what i have to enter in hoogle to find something?(if something like this exists)
08:51:23 <efie> setEntryActivate..?
08:53:15 <vz> hey, does anyone know if there is a phidget library for haskell?
08:53:47 <bfig> i just ran 'cabal install gtk' and it bombed
08:54:10 <vz> or any alternative way of accessing phidgets with haskell is also fine
08:54:12 <bfig> the reason stated is setup: The program gtk2hsC2hs version >=0.13.5 is required but the version
08:54:12 <bfig> found at /home/bfig/.cabal/bin/gtk2hsC2hs is version 0.13.4
08:54:55 <Eduard_Munteanu> roconnor: hi. Does your one proof theorem require an extensionality axiom? I'm trying to prove it in Agda.
08:55:26 <efie> bfig: have you tried http://projects.haskell.org/gtk2hs/ ? the two links worked for me; i had the same problem
08:56:10 <hamishmack> bfig: cabal update && cabal install gtk2hs-buildtools
08:56:24 <Saizan> Eduard_Munteanu: which theorem?
08:56:31 <hamishmack> bfig: Then make sure ~/.cabal/bin is in your PATH
08:56:31 <bfig> hamishmack, i did those two, i'm trying efie's suggestion now
08:56:35 <Eduard_Munteanu> Saizan: http://r6research.livejournal.com/21747.html
08:57:14 <bfig> echo path: /home/bfig/.cabal/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
08:58:06 <hamishmack> bfig: What does gtk2hsC2hs --version give?
08:58:07 <Eduard_Munteanu> I'm unsure if I need to postulate Agda's Extensionality from Relation.Binary.PropositionalEquality.
08:58:19 <Saizan> yeah, you need to
08:58:45 <bfig> C->Haskell Compiler, version 0.13.5 (gtk2hs branch) "Bin IO", 13 Nov 2004
08:58:52 <Saizan> you need the dependent version, even
08:59:16 <bfig> hamishmack, weird :p
08:59:16 <Saizan> (i don't recall fi the one in R.B.PE is dependent or not)
08:59:30 <Eduard_Munteanu> I see. He also mentions "I add an extensionality axiom because Coq doesn't have an extensional equality", but I wasn't sure if that was somehow embedded in his proof already
08:59:49 <bfig> maybe it has to do with a double install of cabal? this might have happened for some reason i can't remember
08:59:54 <Eduard_Munteanu> Thanks, /me tries Extensionality
09:00:38 * hackagebot cabal2nix 1.15 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.15 (PeterSimons)
09:04:34 <bfig> how much time should it take to 'preprocess library gtk-0.12.1...?
09:05:06 <hamishmack> bfig: a long long time
09:05:24 <bfig> in the hours?
09:05:38 * hackagebot bson 0.1.6 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1.6 (TonyHannan)
09:05:45 <efie> maybe 1/10
09:05:47 <bfig> i wouldn't mind it in particular but i gotta leave very soon
09:06:24 <bayesian> http://www.youtube.com/watch?v=3Waxf9KZWpM this i what the kids are listening to today?
09:10:58 <bayesian> The series focuses on a girl who lives a double life as an average teenage school girl named Miley Stewart (played by Miley Cyrus) by day and a famous haskell hacker named Simon Peyton Jones by night, concealing her real identity from the public, other than her close friends and family.
09:13:55 <sbrg> bayesian: I'd pay good money to see that
09:14:01 <bayesian> :D
09:14:26 <merijn> That sounds pretty funny
09:14:39 <merijn> Especially after having seen SPJ present :p
09:15:15 <merijn> I must also admit that I find Hannah Montana funnier than appropriate for my demographic >.>
09:15:40 <sbrg> merijn: I once saw Hannah Montana
09:16:02 <sbrg> but then I decided my time would be better spent doing anything else, like say, stabbing myself in the eyes
09:16:11 <merijn> Actually, I find all cheesy Disney stuff funnier than appropriate for my demographic >.>
09:16:38 <bayesian> Hannah Montana f
09:17:25 <ahihi2> is there a difference in function between WriterT State and StateT Writer?
09:18:06 <roconnor> ahihi2: they are isomorphic
09:18:25 <ahihi2> I suspected that :) thanks
09:18:36 <b_jonas> are they now?
09:18:39 <roconnor> ahihi2: ReaderT, WriterT and StateT all commute.
09:18:42 <b_jonas> um
09:19:34 <b_jonas> possible.
09:19:55 <tarrasch> roconnor, StateT commute? WriterT commute?
09:20:33 <roconnor> if you layer two StateT's the other one will shadown the inner one wrt to the MonadState class methods.
09:20:54 <nopla> hmm...how many monads does it take to change a light bulb...
09:21:04 <tarrasch> roconnor, oh, so it StateT commute is not the same as saying State commute?
09:21:17 <roconnor> tarrasch: StateT and Writer T commute
09:21:42 <roconnor> meaning StateT s (WriterT w m) is iso to WriterT w (StateT s m)
09:22:03 <roconnor> and similarly for any distinct pairs drawn from StateT, ReaderT and WriterT
09:22:04 <tarrasch> aha ok
09:22:11 <tarrasch> that kind of commute
09:24:51 * bfig found gtk has finally stopped...
09:25:05 <bfig> success!
09:25:30 <bfig> efie, good call on the link, thanks :)
09:25:43 <efie> bfig :)
09:25:54 <efie> bfig: if you know how to install glade let me know..
09:26:27 <bfig> efie, luckily for me it was just sudo apt-get install glade
09:26:35 <efie> ah ok
09:26:39 <bfig> as always ymmv >_>
09:38:17 <xivix> I'm seriously considering learning Haskell, but I'm not sure where to start.
09:38:31 <sbrg> @where lyah
09:38:31 <lambdabot> http://www.learnyouahaskell.com/
09:38:37 <sbrg> @where rwh
09:38:37 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:38:44 <xivix> I'm torn between LYAH and the Scheme tutorial
09:38:57 <Somix> do lyah
09:39:20 <adimit> another strong voice for lyah.
09:39:25 <nyingen> lyah ftw
09:39:26 <SamB_XP> @get-shapr
09:39:26 <lambdabot> shapr!!
09:39:36 <adimit> Are you talking about the write yourself a scheme in 48 hours?
09:39:37 <SamB_XP> oh, wrong channelk
09:39:45 <xivix> admit: yes
09:39:59 <xivix> anyone read that?
09:40:00 <adimit> xivix: then really do go for lyah.
09:40:27 <adimit> I've read it, and it was out of date (last time I checked) as well as kinda‚Ä¶ well, kinda not all that pedagogical.
09:40:47 <nyingen> xivix: I found the scheme tutorial kind of useful the first time I was implementing a scripting language in haskell
09:40:48 <tac-tics> xivix: If you're learning haskell, keep in mind that there's Haskell '98, the old ass, bare bones standard
09:41:04 <tac-tics> xivix: and GHC, which has thousands of extensions, useful and not so much
09:41:06 <xivix> Oh, really?
09:41:25 <xivix> okay, then i'll go with LYAH
09:41:25 <tac-tics> GHC is the GCC os Haskell. Everyone uses it.
09:41:38 <xivix> Yeah, I've noticed, it's pretty ubiquitous.
09:42:00 <xivix> Well, it's pretty unanimous.
09:42:05 <xivix> I'm off to learn me a haskell.
09:42:06 <sbrg> LYAH
09:42:07 <SamB_XP> I think thousands is somewhat hyperbolic
09:42:39 <xivix> Thanks for the advice, y'all
09:42:53 <tac-tics> SamB_XP: It's kinda overwhelming for a beginner, IMO
09:43:05 <SamB_XP> yes
09:43:14 <SamB_XP> but I think it's more like tens
09:43:24 <adimit> xivix: also, do read Real World Haskell once you're done with LYAH and want some more in-depth coverage on some of the things
09:43:43 <xivix> okay, so LYAH is more of an overview?
09:43:51 <tac-tics> The point was that the extensions are just that. GADTs are useful, but not necessary for writing your own useful programs
09:43:55 <xivix> Sort of like the poignant guide to ruby?
09:43:55 <ClaudiusMaximus> 71 by my count (ghc --supported-languages | wc -l  `div` 2 for the No variations)
09:43:57 <sbrg> not as such, but rwh is a book while LYAh is a tutorial
09:44:06 <sbrg> and LYAH isn't complete the last time I checked(the last parts aren't)
09:44:19 <sbrg> but LYAH is excellent and it provides some working examples that are really cool
09:44:24 <byorgey> LYAH is also a book now.
09:44:26 <tac-tics> Same for second order types or multi-parameter type classes
09:44:31 <sbrg> byorgey: ah
09:44:35 <sbrg> i stand corrected
09:45:19 * roconnor thinks sbrg adn byorgey are both right
09:45:30 <SamB_XP> sbrg: pics or it didn't happen!
09:46:03 <byorgey> bah, I spilled burrito down my shirt
09:46:19 <SamB_XP> what are the monadic implications?
09:46:20 * sbrg is attempting to DCC SEND penis.jpg. Do you accepted? y/n
09:46:44 <tac-tics> @type penis . jpg
09:46:45 <lambdabot> Not in scope: `penis'
09:46:45 <lambdabot> Not in scope: `jpg'
09:46:54 <byorgey> SamB_XP: that's what I get for trying to unsafePerformBurrito
09:46:56 <xivix> Wow, RWH is an o'reilly book and also free?
09:47:03 <sbrg> xivix: aye
09:47:21 <SamB_XP> the book doesn't have the peanuts gallery, though
09:47:24 <xivix> that's pretty awesome, actually
09:48:02 <b7> how should i get ghc 7 going in ubunty natty?
09:48:09 <byorgey> I think the free version also doesn't have a lot of the corrections + updates that went into the book
09:48:13 <byorgey> but yes, it is awesome =)
09:48:25 <sbrg> yeah, strangely enough they were pretty bad at correcting the online version :/
09:48:30 <adimit> well, but then the free version has comments.
09:48:46 <nyingen> no binding to ENet on hackage...
09:48:48 <sbrg> in fact, there are output excerpts that look like they were automated completely or run by the guy who edited the book
09:48:50 <nyingen> guess I'll have to write one
09:49:01 <sbrg> "not in scope foo" etc
09:52:01 <mah_b> How can I debug such unhelpful messages like '*** Exception: Prelude.tail: empty list'? Is there a stacktrace somewhere (ghci)?
09:52:16 <tac-tics> mah_b: You really can't >__<
09:52:31 <sbrg> mah_b: if you're using vim: /tail, n, n, n
09:52:33 <tac-tics> mah_b: Even a stacktrace would be unhelpful because of Tail Recursion
09:52:35 <sbrg> find tail
09:52:37 <sbrg> etc
09:52:49 <tac-tics> TCO* rather
09:52:54 <b7> that's why to use pattern matching rather than tail.
09:53:01 <sbrg> ^
09:55:34 <byorgey> why oh why does the Prelude include head and tail.  such a bad idea.
09:55:46 <b7> made sense years ago, i'm sure.
09:55:54 <byorgey> I doubt it.
09:55:58 <b7> head and tail have to be some of the oldest functions in the prelude.
09:56:03 <tac-tics> byorgey: because Haskell is infatuated with fix
09:56:12 <shachaf> byorgey: To make LISPers feel at home?
09:56:44 <byorgey> heh, I was not actually looking for answers =)
09:56:51 <tac-tics> byorgey: You want to take integer division out of the prelude too :P
09:57:04 <koeien> why? no div/mod make total sense
09:57:19 <koeien> you cannot really pattern match like with lists
09:57:21 <byorgey> > 5 `div` 0
09:57:22 <lambdabot>   *Exception: divide by zero
09:57:23 <tac-tics> koeien: erk, floating point division rather :P
09:57:42 <tac-tics> erk, distracted right now.
09:58:20 <tac-tics> > 5 `div` fix id (head [])
09:58:23 <lambdabot>   mueval-core: Time limit exceeded
09:58:27 <byorgey> you're right, we have to find a balance somewhere, it's not feasible to restrict the Prelude to only total functions.  I guess I just think the balance should be in a different place =)
09:59:02 * SamB_XP thinks it might be nicer if division by zero just returned something nonsensical
09:59:04 <tac-tics> I say we need to extend the type system with exception types
09:59:07 <byorgey> tac-tics: fix has nothing to do with head and tail.
09:59:15 <koeien> SamB_XP: like _|_ ? :)
09:59:32 <sbrg> byorgey: i can't make head nor tail of fix
09:59:35 <tac-tics> byorgey: I wanted the most undefined expression I could come up with in 6 words
09:59:37 <sbrg> hurrhurr
09:59:51 <bfig> :t und
09:59:52 <lambdabot> Not in scope: `und'
09:59:55 <byorgey> sbrg: =)
09:59:58 <bfig> :t undefined
09:59:58 <lambdabot> forall a. a
10:00:07 <tac-tics> :t error undefined
10:00:07 <lambdabot> forall a. a
10:00:15 <tac-tics> :t undefined undefined
10:00:15 <lambdabot> forall t. t
10:00:16 <bfig> it should say forall a. a-> Kaboom
10:00:34 <xivix> RWH has such a well-written "Why Learn Haskell?" section
10:13:06 <monochrom> head and tail are there because lisp has them
10:13:41 <bfig> how would you compare lisp and haskell's expressive power?
10:14:02 <monochrom> haskell is more convenient with pattern matching
10:15:32 <bayesian> define expressive power
10:16:10 <bfig> capacity to express complex computations and datatypes easily
10:16:12 <SamB_XP> Common Lisp is too much for my ADD, what with it's lack of type checking and it's confusing array of data structures...
10:16:49 <Eduard_Munteanu> Hm, interesting, looks like only isImpl and isForall require extensionality.
10:16:57 <bfig> ie, c expressive power < haskell expressive power
10:17:20 <merijn> bfig: Depends on how you define expressive power
10:17:32 <SamB_XP> I'm not sure if CL's expressive power is less than Haskell's or not
10:17:34 <bfig> another possible measure may be compared length of generated code
10:17:45 <SamB_XP> it may be simply unequal?
10:17:58 <merijn> Because I'm pretty sure C allows you to express some low level details which Haskell and Lisp do not
10:18:07 <monochrom> lisp has better macros
10:18:22 <SamB_XP> monochrom: I'm not sure I agree
10:18:26 <SamB_XP> they are different
10:18:36 <merijn> SamB_XP: Haskell has no macro's
10:18:46 <monochrom> yeah, hehe
10:18:49 <merijn> Now arguably we don't need them as badly and when you do there is Template Haskell
10:19:16 <SamB_XP> yeah, I was figuring we were using TH for the purpose of this discussion :-)
10:19:18 <merijn> As laziness covers a lot of cases where you want macros
10:19:26 <bfig> merijn, with that definition you might as well have stopped developing languages at assembly level
10:19:38 <monochrom> TH is quite a bit more verbose than lisp macros
10:19:45 <SamB_XP> what's the name of the paper that defines the expressive power of langauges?
10:19:58 <SamB_XP> or the URL, even ;-)
10:20:02 <merijn> bfig: No, because the things they are good at expressing is different
10:20:05 <SamB_XP> @where expressive power
10:20:05 <lambdabot> I know nothing about expressive.
10:20:10 <SamB_XP> @where expressive-power
10:20:10 <lambdabot> I know nothing about expressive-power.
10:20:40 <SamB_XP> monochrom: admittedly so
10:20:47 <merijn> bfig: Comparing C and Haskell's expressive power depends on what you're doing, because they both have different strong points
10:20:50 <SamB_XP> I'm not sure if expressive power is all that I demand
10:21:02 <byorgey> SamB_XP: http://scholar.google.com/scholar?cluster=7827729247830749586&hl=en&as_sdt=0,39  ?
10:21:18 <SamB_XP> merijn: if you want to handle low-level details, "expressive power" isn't going to help you with that
10:21:19 <merijn> C is better at expressing low level details and Haskell is better at expressing abstraction
10:23:32 <bfig> merijn, rocks are very good at expressing rocks, if that's what you mean
10:24:15 <bfig> and in general i would tend to agree.. except when you want to express 'all rocks' kind of statements, then just rocks are not good enough
10:24:19 <merijn> bfig: From a strict theoretical point of view C, Lisp and Haskell are all equally expressive. The only INTERESTING question is which things are easier to express and which things are harder
10:24:39 <bfig> turing completeness is a retarded way to compare programming languages...
10:24:52 <merijn> Because making one thing easier to express seems to involve making other things harder to express (it seems so far, anyway)
10:24:59 <merijn> bfig: That was my entire point
10:25:29 <merijn> And if we're not talking absolute expressiveness the only thing to discuss is the trade-offs made in how easy certain things are to express
10:25:44 <bfig> well, i am thinking from a pure usability perspective
10:25:56 <bfig> will i get more work done with haskell or with C?
10:25:58 <merijn> So the question/statement that Lisp/Haskell have more or less expressive power then C is nonsensical
10:26:03 <merijn> bfig: Depends on your work?
10:26:16 <merijn> I've done some kernel coding, Haskell would be a major slow down there...
10:26:23 <bfig> of course i won't use haskell for for kernel programming...
10:26:25 <sbrg> bfig: are you going to be writing code for embedded systems?
10:26:35 <sbrg> if so, you can safely assume haskell won't be the best choice
10:26:54 <bfig> sbrg, not really, assume the only critical resource is time
10:26:56 <merijn> bfig: For the average user application abstraction is more important than control, in which case Haskell wins
10:26:58 <bfig> programmer time
10:27:14 <merijn> sbrg: Only until Habit gets finished ;)
10:27:19 <scooty-puff> when using cabal to install a package, i get: /usr/bin/ld: cannot find -lHSpretty-1.0.1.0-ghc6.10.4, among others
10:27:30 <adimit> bfig: if you're talking programmer time, LANGUAGES have next to no measurable practical impact on it.
10:27:36 <scooty-puff> this is just after install two new version of ghc, 6.10.4 and 7.2.1
10:27:48 <adimit> if you're talking programmer time, what you *should* be comparing are ECOSYSTEMS.
10:27:59 <merijn> Also very true
10:28:00 <bfig> adimit, are you saying that a programmer is equally productive in C++ than in haskell?
10:28:03 <adimit> libraries, community, commercial/oss support, programming environment.
10:28:20 <merijn> bfig: Probably, because whatever you want to write probably already exists in C++ ;)
10:28:20 <adimit> bfig: I'm saying you're chasing a red herring.
10:28:26 <SamB_XP> merijn: expressive power isn't about merely *what* can be expressed
10:28:45 <merijn> SamB_XP: Did you conveniently gloss over everything I wrote the past 5 minutes?
10:28:49 <adimit> he's not even talking expressive power. he's talking programmer time. That's like a whole different ballpark.
10:28:56 <adimit> it's even no ballpark at all.
10:29:13 <bfig> well, there is the implicit assumption that both notions are related
10:29:26 <cfa> evening all
10:29:39 <SamB_XP> merijn: did you read the paper that defined the term?
10:29:47 <adimit> if I want to write an NLP system, I'll go Java. I hate Java, but it's the best choice. Why? Libraries. If I had to implement a tagger, a tokenizer and a parser on my own in Haskell or C* I'd be screwed in the arse.
10:29:50 <adimit> Java has those libraries.
10:29:52 <scooty-puff> anyone able to use haskell to build plugins to other languages?  all blog posts/docks i've seen so far don't really help
10:29:55 <adimit> So I go Java.
10:30:28 <adimit> expressiveness or language design doesn't even remotely play any role.
10:30:35 <SamB_XP> adimit: why don't you go Scala or something?
10:30:44 <merijn> SamB_XP: Maybe, maybe not? I was just pointing out that there is no linear better/worse scale for expresiveness, hence more/less expressive is a nonsensical question
10:30:52 <merijn> Clojure would probably a lot nicer
10:30:59 <cfa> anyone here using vim? i have a quick configuration question
10:31:01 <SamB_XP> certainly it's not strictly ordered
10:31:04 <adimit> If I'm interested in programmer time and efficiency, I go the route of least resistance. In programming that means the route of least code written.
10:31:35 <mauke> cfa: then why don't you ask it?
10:31:35 <adimit> I could go clojure or scala, sure. Haven't tried those yet, but it's surely possible.
10:31:59 <cfa> more specifically: i'm looking for a decent indent script for haskell; the one i found (linked to on the wiki @ http://www.haskell.org/haskellwiki/Libraries_and_tools/Program_development#Vim) is very basic and temperamental
10:32:24 <cfa> and since i know there are a lot of folks who use vim with haskell, i'm guessing i'm missing something obvious here. (haskell-mode doesn't seem to provide indent either)
10:32:38 <adimit> cfa: there isn't one. I was writing one, but it's on ice for the moment. Fact of the matter, it's not easy, because vimL sucks.
10:33:09 <cfa> okay
10:33:18 <mauke> doesn't vim have scheme support?
10:33:24 <cfa> so is thre a workaround or do you just explicitly indent everything?
10:33:25 <adimit> I'm using vim for haskell exclusively, but the support is really spotty. Even the syntax hilighting is horrible.
10:33:33 <adimit> cfa: indent manually.
10:33:48 <cfa> for what it's worth, the mydrop example from this chapter: http://book.realworldhaskell.org/read/types-and-functions.html is a nice example of something that's difficult to get formatted correctly
10:33:58 <mauke> I indent manually and I don't see what's missing
10:34:04 <mauke> what would an indent script do?
10:34:13 <cfa> automatically indent on return
10:34:16 <cfa> outdent where appropriate
10:34:21 <adimit> mauke: indent after do, where, case, etc.
10:34:32 <mauke> adimit: ok, that sounds fairly simple
10:34:42 <KirinDave> Every time I feel like I am about to understand comonads
10:34:44 <mauke> cfa: but I don't want every line indent more than its predecessor
10:34:47 <adimit> if I have to write a list over multiple lines, indent to the opening bracket.
10:34:48 <adimit> etc.
10:34:49 <KirinDave> I see a duplicate i
10:34:59 <KirinDave> err, duplicate implementation and realize I do not
10:35:02 <cfa> cfa: 'where appropriate' should apply to the first of my statements too
10:35:09 <cfa> oops, mauke:
10:35:14 <mauke> cfa: define "appropriate"
10:35:22 <cfa> after do, case, where, etc.
10:35:40 <adimit> mauke: it's simple, yes, but you have to do it entirely regex based, without any decent support for nesting structures, etc.
10:36:12 <SamB_XP> basically, language A has >= the expressive power of langauge B if A can express all of B's constructs using only local transformations
10:36:23 <adimit> it's just a PITA, even though trivial. That's what makes for the worst kind of open-source problems.
10:36:25 <cfa> emacs seems to have pretty good support for this, incidentally
10:36:52 <mauke> (worse regexes than vim, though)
10:37:05 <SamB_XP> so, it's basically about which features are sugar, and which aren't
10:37:19 <merijn> SamB_XP: Hence my point that C and Haskell can't be compared sensibly about expressive power as that doesn't hold in either direction.
10:37:20 <adimit> mauke: what do you mean? (sorry, me no understand.)
10:37:36 <merijn> cfa: I often wish Vim was more like emacs :\
10:37:49 <adimit> I often wish Yi was ripe for prime time.
10:38:05 <SamB_XP> what constructs does C have that can't be expressed so in Haskell?
10:38:29 <scooty-puff> anyone here have any luck loading haskell as a shared object (dlopen) from something that does not include (statically) anything haskell related, or even know about haskell?
10:38:48 <merijn> SamB_XP: Control over memory location, bit/byte representation of data
10:39:03 <merijn> SamB_XP: Pointers, mutable state
10:39:06 <SamB_XP> merijn: what do you mean?
10:39:12 <SamB_XP> C doesn't give you those things
10:39:35 <SamB_XP> the control over memory location and bit/byte representation, I mean
10:39:57 <merijn> SamB_XP: I guess you're right about bit representation
10:40:11 <merijn> C sure as hell gives you control over memory location
10:40:22 <cfa> merijn: heh. i spent a couple of hours today trying to remember my keychords while comparing indent support
10:40:54 <merijn> cfa: I just can't accept emacs lack of proper command mode (please don't start about the joke that is viper mode)
10:41:07 <SamB_XP> merijn: well, okay, in the sense that you can do all kinds of things with an allocated block of memory
10:41:36 <SamB_XP> (with appropriate alignment)
10:41:39 <tac-tics> merijn: what do you need commands for? Use a monad instead ;D
10:42:18 <merijn> SamB_XP: Also, don't make the mistake that C only runs under an OS (which many people seem to do), bare metal you control the location directly in C
10:42:31 <cfa> merijn: i won't (i actually tried viper again today, and vimpulse to get region selection, in an effort to feel less uncomfortable)
10:42:40 <cfa> didn't work
10:42:49 <SamB_XP> merijn: that's not standard C ;-)
10:42:59 <merijn> SamB_XP: Eh, yes it is
10:43:32 <mauke> merijn: how do you control memory locations?
10:43:56 <SamB_XP> the C standard doesn't say how that stuff works; it's left implementation defined, unspecified, even undefined!
10:44:21 <SamB_XP> some of it isn't even *mentioned*
10:44:47 <cheater> something isn't mentioned by the c spec?
10:44:51 <cheater> omgwtfbbq
10:44:55 <tac-tics> @djinn a -> Bool
10:44:55 <lambdabot> f _ = False
10:45:00 <rs464> hi, I'm having an issue compiling the haskell platform from source. Is 64 bit Linux supported for compiling the platform?
10:45:02 <SamB_XP> anyway, the stuff that the C standard *does* specify is also doable with Haskell's FFI
10:45:03 <rs464> The config.log states: 'configure:3932: gcc -o conftest -g -O2  -L/usr/X11R6/lib -L/usr/local/lib conftest.c -lopengl32  -lz  >&5 /usr/bin/ld: cannot find -lopengl32'
10:45:04 <rs464> ?
10:45:34 <SamB_XP> and I think you'll find that this can be done with only local transformations
10:45:46 <merijn> SamB_XP: By that logic haskell is still not more expressive then C since C can just do the reverse and call into Haskell via FFI
10:45:46 <c_wraith> @tell tibbe You can relax the deepseq constraint on unordered-containers.  1.2.0.1 will work.
10:45:46 <lambdabot> Consider it noted.
10:45:57 <mauke> adimit: I mean vim's regexes are more powerful than emacs's
10:46:04 <SamB_XP> merijn: I didn't mean that Haskell would actually be calling into C
10:46:24 <SamB_XP> just using Ptr and the C* types and such
10:46:35 <adimit> mauke: yes, they are, but they're also kind of difficult to use.
10:46:49 <SamB_XP> maybe not even the C* types
10:47:07 <SamB_XP> mauke: what regexes does vim use?
10:47:10 <adimit> I'll trade them for some more expressive partial tree parsing a la yi.
10:47:14 * merijn is not convinced this only requires local transformations
10:47:18 <mauke> SamB_XP: vim regexes
10:47:19 <adimit> SamB_XP: All the insanity of perl, plus more.
10:47:32 <mauke> no, vim is not a superset of perl
10:47:45 <SamB_XP> is there a reference for them somewhere?
10:47:57 <adimit> fire up vim and type :he regex
10:48:04 <SamB_XP> hmm
10:48:12 <mauke> why :he when :h is 50% shorter?
10:48:17 <adimit> mauke: that's what I said :-) vim has more stuff than perl even.
10:48:31 <adimit> mauke: actually, :h is 33% percent shorter.
10:48:38 <mauke> no, vim is not a superset of perl
10:48:45 <adimit> I thought it was, no?
10:48:49 <mauke> no
10:48:55 <adimit> ‚Ä¶ well. i stand corrected.
10:49:10 <adimit> it can match stuff like cursor position in a regex though.
10:49:31 <mauke> yeah, but that's simple stuff
10:49:42 <mauke> as far as I know vim has only one big feature missing in perl
10:50:07 <SamB_XP> what's that?
10:50:26 <mauke> variable-width look-behind
10:51:30 <Lemon> @hoogle sequenceA
10:51:30 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:51:30 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
10:51:36 <Lemon> @hoogle sequenceM
10:51:36 <lambdabot> No results found
10:52:13 <Lemon> @hoogle (Traversable t, Monad m) => t (m a) -> m (t a)
10:52:14 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
10:52:14 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:52:14 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:52:24 <Lemon> gah
10:57:49 <SnarkRube>  >>
10:58:04 <tac-tics> :t (.)(.)
10:58:04 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
10:58:20 <scooty-puff> is it possible to trick cabal into generating a .so for us in as a plugin dlopen'ed by somethign written in c?
10:58:46 <scooty-puff> my Makefile is pretty bad right now, and doesn't actually produce a usable .so - undefined reference errors
10:59:19 <scooty-puff> also, is it possible to have ghc produce the _stub.{c,h} files for FFI without attempting to compile?
11:00:33 <dcoutts> scooty-puff: you can build Haskell libs as shared libs, then for your plugin you can make a module that exports the C interface and depends on your Haskell lib and build that as a shared lib
11:01:36 <scooty-puff> does cabal require --enable-shared to do so?
11:01:45 <dcoutts> doing the last bit not as a Haskell library package gives you flexibility in how you generate the .so, otherwise the requirements are there to fit what's needed for Haskell/ghc packages
11:01:51 <scooty-puff> guess depends on my .cabal/config
11:02:04 <dcoutts> scooty-puff: right, configure with --enable-shared
11:02:09 <scooty-puff> k
11:02:16 <dcoutts> scooty-puff: all the libs all the way down have to be built that way
11:02:22 <scooty-puff> k
11:02:36 <dcoutts> so your plugin will depend on all the other Haskell .so files
11:02:49 <SamB_XP> all the turtles all the way down... got it!
11:02:50 <dcoutts> you can control the rpath etc if you need
11:03:07 <scooty-puff> do i need to do anything with the rpath?
11:03:39 <romildo> I am looking for user documentation for lambdabot. I have found just the entry in the haskellwiki, which is too short. Where can I found more documentation on how to use lambdabot?
11:03:40 <scooty-puff> right now, have a c file that calls hs_init, hs_exit and hs_add_root
11:03:49 <SamB_XP> @list
11:03:49 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:03:49 <scooty-puff> a few hs modules
11:03:54 <dcoutts> scooty-puff: depends where you want to put all the other .so files
11:04:18 <scooty-puff> is it possible to statically link the haskell libraries i depend on into the .so?
11:04:21 <SamB_XP> romildo: you can look there for a list of commands; @help on a given command should give you usage info of some kind
11:05:05 <dcoutts> scooty-puff: in principle yes, in practice it's not easy
11:05:07 <scooty-puff> btw, the plugin interface is this: void parser(const struct parser_param *); - the .so will be loaded and that method called
11:05:16 <scooty-puff> dcoutts: yeah, i've had a lot of trouble so far
11:05:18 <dcoutts> scooty-puff: you'd need to build them all as static libs but with -fPIC
11:05:25 <romildo> SamB_XP, is there any document describing the commands?
11:05:40 <dcoutts> scooty-puff: including the rts and other core libs
11:05:43 <scooty-puff> what about what i'm depending on in base?
11:05:45 <scooty-puff> right
11:05:45 <scooty-puff> k
11:05:57 <ddarius> SamB_XP: Most language are incomparable to other languages in expressive power.  To the extent we fudge though, CL is definitely massively more expressive than Haskell, though not because of macros.  Most languages are distinctly more expressive than Haskell due to mutation.
11:06:41 <scooty-puff> so, about what you said earlier - i assume i build with ghc -shared (-dynamic | -static) -o libfoo.so -fPIC *.hs *.c
11:06:43 <scooty-puff> or some form
11:06:59 <shachaf> ddarius: Why is CL massively more expressive than Haskell?
11:07:19 <scooty-puff> *ghc --make ...
11:07:33 <dcoutts> scooty-puff: -shared to link results as a shared lib, -dynamic to link dynamically against other libs
11:07:34 <SamB_XP> ddarius: even with Foreign.* ?
11:07:50 <scooty-puff> k
11:07:52 <SamB_XP> and yeah, I know most languages are incomparable
11:07:57 <dcoutts> scooty-puff: if you did have all your other packages built as static libs with -fPIC you could indeed say -shared -static
11:08:45 <ddarius> SamB_XP: If by Foreign.* you mean unsafePerformIO, then yes, Haskell will get a big boost in expressiveness, and is then probably more expressive than C.
11:09:00 <obiwahn> data Nat = Zero | Succ Nat
11:09:08 <scooty-puff> is -fPIC passwed as -ghc-options or cc-options?
11:09:19 <ddarius> shachaf: Mutation and the exception facilities.  But even more dramatically, the MOP.
11:09:31 <obiwahn> D_Nat = {Zero}_bot `csum` {{Succ}x{D_Nat}}_bot  -> how do i prove that a smallest solution exists? it is not in my notes:(
11:09:42 <dcoutts> scooty-puff: it's a ghc option
11:10:09 <ddarius> obiwahn: You say "Tarski's fixed point theorem proves that there is a smallest solution."
11:10:19 <dcoutts> scooty-puff: note that you don't put that into .cabal files though
11:10:28 <scooty-puff> o?
11:10:29 <SamB_XP> yeah, exception-like facilities would definitely be where I would expect CL to beat Haskell
11:10:30 <ben> Does Haskell's IO come with something like select() or poll() for handles?
11:10:39 <dcoutts> scooty-puff: that's what --enable-shared is for in cabal
11:10:42 <scooty-puff> ok
11:10:42 <SamB_XP> ben: GHC does that
11:10:54 <SamB_XP> you use threads
11:11:00 <mauke> ben: no
11:11:01 <SamB_XP> MVars are kinda cool
11:11:09 <dcoutts> scooty-puff: it can build any .cabal package as a shared lib, so don't mess it up by adding -fPIC or anything in the .cabal file :-)
11:11:13 <scooty-puff> i have the ghc source - where would i need to include -fPIC?
11:11:23 <scooty-puff> for rts and core
11:11:25 <ben> Hm, I just want a loop that blocks on either of two inputs and tells me whichever is ready first
11:11:33 <ben> I'm not sure I can figure out how to squeeze that into threads
11:11:37 <monochrom> ddarius: sorry, what is the MOP?
11:11:47 <SamB_XP> ben: why do you need to know which is ready first?
11:11:48 <ddarius> monochrom: The Meta Object Protocol.
11:11:57 <dcoutts> scooty-puff: oh you mean you do want to build the static libs with -fPIC, it'd be in the mk/build.mk, see the ghc wiki for details
11:12:17 <scooty-puff> k
11:12:18 <ben> SamB_XP: Well, so I can read off it. And if it tells me that I'm done I'd just exit my loop.
11:12:37 <SamB_XP> so, you don't really care which is first, just that you don't wait excessively long?
11:12:38 <dcoutts> scooty-puff: and then for all the packages you build with cabal you could try building with --ghc-options=-fPIC and not using --enable-shared
11:12:58 <scooty-puff> k, thanks!
11:13:17 <ben> SamB_XP: Well, so I can cleanly exit my looping and clean up before terminating the process, I guess
11:13:17 <dcoutts> scooty-puff: but after rebuilding ghc using -fPIC check that you can make a "hello world" plugin first. I'll be interested to hear if you can make it work out ok.
11:13:45 <mauke> ben: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hWaitForInput
11:13:55 * SamB_XP might be using more pedanticism than is indicated
11:14:16 <SamB_XP> (or however that word goes)
11:14:16 <SamB_XP> pedantry?
11:14:46 <obiwahn> ddarius: i have a tarski kleene for function fixpoints is it the same for domains?
11:14:48 <dcoutts> scooty-puff: summary: -fPIC for all code that will end up in a shared lib *eventually*; -dynamic to link against dependent libs dynamically (e.g. rts, base etc);  -shared to link a .so shared lib (rather than linking an executable)
11:15:00 <obiwahn> so the one for functions a weaker version?
11:15:44 <SamB_XP> @hoogle MVar
11:15:44 <lambdabot> module Control.Concurrent.MVar
11:15:44 <lambdabot> Control.Concurrent.MVar data MVar a
11:15:44 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
11:16:18 <SamB_XP> @doc Control.Concurrent.MVar
11:16:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
11:16:23 <scooty-puff> dcoutts: compiling 7.0.4 with -fPIC, will post any results shortly - thank you for all the help - a lot of this had been failing for unknown reasons for a while..
11:16:51 <dcoutts> scooty-puff: it can be quite confusing stuff at first.
11:17:23 * monochrom thinks it's futile to disuade people from demanding select/poll. you invariably need to know their specification to suggest how to structure it for multi-threading. they invariably hide their specifications.
11:17:43 <SamB_XP> monochrom: not quite invariably
11:18:04 <monochrom> well, have you had any luck in the recent case?
11:18:16 <ddarius> monochrom: Part of the problem is a "select-like" mechanism makes sense even for multi-threaded programs, but GHC completely lacks it (except maybe you can do it with STMp)
11:18:23 <ddarius> s/STMp/STM./
11:20:05 <SamB_XP> there should be something like select for MVars
11:20:35 <ptek> Hi. Does anyone of You guys use scion with emacs? I somehow can not make it work...
11:20:36 <ben> I actually went and did @hoogle Chan a -> Chan b -> Chan (Either a b) before asking here, but that did not seem to help
11:21:12 <mauke> ben: that seems trivial with threads
11:21:27 <SamB_XP> @hoogle (a -> b) -> Chan a -> Chan b
11:21:27 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:21:27 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
11:21:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
11:21:29 <ddarius> SamB_XP: There should actually be more than something like select for everything you can block on.
11:21:44 <SamB_XP> ddarius: I guess that'd be good too
11:21:52 <SamB_XP> certainly more powerful
11:22:01 <ddarius> SamB_XP: Check out Reppy's thesis if you haven't already.
11:22:10 <mauke> that reminds me
11:22:24 <mauke> ddarius: I read http://doc.cat-v.org/bell_labs/concurrent_window_system/ but I thought the author must be crazy or stupid
11:22:36 <ddarius> mauke: The author is Rob Pike.
11:22:39 <ben> Maybe I am unreasonably afraid of randomly spawning and killing threads
11:22:52 <mauke> ddarius: yes?
11:22:55 <ddarius> ben: If you are afraid at all, you are unreasonably afraid.
11:23:16 <mauke> ben: as long as you don't spawn more than a few ten thousand threads, no problem
11:23:31 <ddarius> mauke: He's usually considered at least not an idiot.  I don't know about not crazy.
11:23:41 <SamB_XP> @where+ expressive-power http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.4656
11:23:41 <lambdabot> Done.
11:23:46 <ben> I mean I'm used to carefully setting them up so I can tell them when they're no longer needed so I can shut them down without asynchronously terminating them
11:23:55 <ben> because the boost.thread documentation at least presented that as a fairly bad idea
11:24:25 <ddarius> It is usually a bad idea to kill threads with asynchronous exceptions from other threads.
11:24:26 <SamB_XP> ben: GHC's threads are actually garbage collected ;-)
11:24:47 <dcoutts> but they're also GC roots
11:24:55 <SamB_XP> not that I'm suggesting you should depend on this
11:25:15 <SamB_XP> (yet)
11:25:20 <mauke> ddarius: he keeps talking about how great his system is, but I don't see why
11:25:34 <scooty-puff> is there a performance penalty for using -fPIC?
11:25:56 <SamB_XP> Rob Pike... do I know that name in connection with Bell Labs?
11:25:57 <dcoutts> scooty-puff: on x86 32, yes, on 64 not much
11:26:01 <ben> Cripes, I'm bad at this whole software engineering thing.
11:26:22 <ddarius> mauke: Note that that paper was written in the late 80s I think.  The ideas in it got applied to several projects in the Plan 9 direction.
11:26:38 <mauke> yeah, that doesn't exactly make me want to use plan 9
11:26:51 <SamB_XP> plan9 is cool
11:27:04 <mauke> in his system, if there's one small mistake anywhere, the whole system hangs
11:27:10 <mauke> including all programs and the window manager
11:27:25 <mauke> and apparently you have to recompile the window manager to open a new window
11:27:25 <ben> I thought plan9 was cool because it's C dialect had struct literals <:)
11:27:33 <ben> "its"
11:27:34 <ddarius> mauke: You can easily insert shims to avoid this.
11:27:43 <ddarius> I don't know where you get that last idea.
11:27:58 <mauke> ddarius: with those shims, do I get an event queue back?
11:28:34 <ddarius> mauke: You get essentially asynchronous channels with whatever policy you want.  You don't end up with an event queue, though you could get that effect too if you wanted.
11:28:51 <mauke> "The window system's main lack is that it must be restarted to link in new clients"
11:29:14 <SamB_XP> I didn't quite get the hang of the UI, but it seemed like a really cool system who's main problem is that worse is better
11:29:32 <SamB_XP> (which is why everyone is still using *nix and Windows)
11:29:52 <mauke> ddarius: what's the difference? I thought these communication channels were event queues
11:30:02 <ddarius> mauke: The system described there is not a proposal for an actual implementation.
11:30:09 <wunki> is there something like "lein" in Clojure or "virtualenv" in Python for Haskell?
11:30:30 <SamB_XP> anyway, rest assured that Plan 9 does not have that problem
11:30:34 <ddarius> mauke: I quite certain rio and 8 1/2 didn't require relinking to open new windows.
11:30:53 <scooty-puff> this is something like the fourth time this has come up, and my usual response is to delete .cabal and .ghc, but: Cabal-1.10.2.0-1c81df95f298107ffd3cf36534dc1d30 is unusable due to missing or recursive dependencies:
11:30:59 <SamB_XP> yeah, you could open a new window from an rc script...
11:31:05 <scooty-puff> it lists pretty-1.0.1.2-...
11:31:24 <scooty-puff> is there a better way out of this situation?
11:31:50 <ddarius> mauke: But yeah, I was going to correct to say that you don't get "event loop" programming.  You do get mini-event-queues.  All the channels are single element event queues.  You can choose whatever policy you want for each queue though, dynamically if you want.  You also don't have to demultiplex every event in the system from one uber-queue.
11:32:10 <mauke> ddarius: how is that not a disadvantage?
11:32:41 <monochrom> you only need to delete .ghc in the worst case, and even then you only need to delete one subdirectory under .ghc
11:32:42 <ddarius> mauke: How is it an advantage to have to put every event into a single queue with a fixed policy and a fixed set of event types?
11:33:00 * SamB_XP wonders if mauke secretly hails from win16
11:33:42 <ddarius> mauke: The advantage is that I can write mouse handling code that only worries about mouse handling and I can easily combine it with keyboard handling code that only worries about keyboard handling, and I can switch out different handlers however I like.
11:34:17 <SamB_XP> these netsplit are ridiculouskly uninformative
11:34:22 <mauke> ddarius: I don't know what "policy" means, and the advantage of a single queue is event ordering
11:34:23 <SamB_XP> *netsplits
11:35:01 <mauke> ddarius: "fixed set of event types" is still better than "fixed set of single-type queues"
11:35:16 <ddarius> mauke: It's not a fixed set of queues.
11:35:24 <mauke> it is in the paper
11:35:24 <ddarius> Necessarily.
11:35:31 <SamB_XP> mauke: the paper is paper
11:35:37 <scooty-puff> dcoutts: i added GhcLibHcOpts=-O2 -XGenerics -fPIC to mk/build.mk, hopefully this is correct
11:36:07 <mauke> every time he adds a new type of event, he has to extend Env with a new chan
11:36:12 <ddarius> Also, something that you can do with the channels is adapt them to higher level events, which is how you can manage ordering.
11:37:06 <mauke> if you have event filtering code that's only interested in key events, you can still insert that in a single event queue
11:37:29 <mauke> actually, I have no idea how mouse events are even supposed to work in that scheme
11:37:33 <ddarius> That's filtering not building a higher level event.  I can't insert my DoubleClick event into the event queue.
11:37:44 <mauke> ddarius: why not?
11:38:00 <ddarius> mauke: Because the event queue only knows has a Click type.
11:38:14 <mauke> ddarius: ok, and how is that different with M: chan of Mouse; ?
11:39:09 * SamB_XP tries to find the proper rio manpage...
11:40:11 <ddarius> I can wrap that and present a higher level interface.
11:40:27 <mauke> you can do the same with a "normal" event queue
11:40:49 <mauke> filter :: Queue Event -> Queue EventPlus
11:41:27 <ddarius> And if I want to also present a higher level interface for the keyboard events?
11:42:07 <mauke> same
11:42:29 <ddarius> mauke: Yeah, but I want to use both of them together, but they were written by different people without knowledge of each other.
11:42:40 <mauke> ddarius: unlikely
11:43:11 <mauke> ddarius: here's a more common scenario: how do I detect shift-click with two separate channels?
11:43:40 <ddarius> mauke: You make a process that takes both channels and waits on both.
11:44:07 <mauke> according to the paper I can't do that
11:44:35 <mauke> it's all synchronous and waiting on a channel blocks
11:44:48 <ddarius> mauke: Yes, and select blocks on two channels.
11:44:54 <ddarius> Or arbitrarily many.
11:45:04 <ddarius> Also, going from synchronous to asynchronous is just forking a thread.
11:45:06 <mauke> that was never mentioned
11:45:20 <ddarius> asyncRead = forkIO . syncRead
11:45:36 <ddarius> (Well send would make more sense, but reads can be done as well.)
11:45:38 <mauke> ddarius: that causes ordering issues
11:46:33 <ddarius> mauke: Read "Squeak: A Language for Communicating with Mice"
11:46:48 <ddarius> That describes the language that Pike is casting the window system in.
11:47:09 <mauke> hmm, given select I could probably recover the single queue of events
11:47:53 <ddarius> Definitely read the paper I mentioned.  I had thought the CWS covered the basics of the system used, but apparently it does not, and without that background I can see why it is confusing.
11:47:54 <mauke> and going the other way is trivial
11:48:28 <SamB_XP> anyway, plan9's actual window system API is documented at http://plan9.bell-labs.com/magic/man2html/4/rio
11:48:32 <ddarius> I may have mentioned that there were other papers relevant to CWS or I may have only thought about mentioning it.
11:49:10 <ddarius> mauke: Actually not that paper, it has a successor that's much more sane looking.
11:49:12 <ddarius> Hold on a sec.
11:49:13 <mauke> ddarius: IMO the paper is too much "OMG this is so great guys!!!" and not enough "this is how it's different from other stuff, and these are the advantages of the approach"
11:49:43 <wyfrn> could somebody please post an implemntation of a wrapper function from signature FilePath -> IO Bool to IO (FilePath -> Bool)
11:50:00 <mauke> wyfrn: looks impossible
11:50:05 <SamB_XP> though probably it would look better in the typeset version
11:50:13 <monochrom> can't be done unless you accept the trivial
11:50:24 <ddarius> mauke: s/Squeak/NewSqueak/
11:50:29 <ddarius> In the earlier paper title.
11:51:11 <monochrom> @type putStrLn
11:51:11 <lambdabot> String -> IO ()
11:51:19 <romildo> I am trying to using GOA (GHCi on Acid) as described on the GHCi page in the haskell wiki (http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid). I followed the instructions at http://www.haskell.org/haskellwiki/GHC/GHCi#How_to_install. But When ghci starts, it gives me the error: *** Exception: /home/romildo/.ghci: openFile: does not exist (No such file or directory). Any clues?
11:51:21 <ddarius> Grr, even that's not the one I want.  I remember having issues finding the particular one.  But that one covers the language.
11:55:55 <SamB_XP> @google NewSqueak
11:55:56 <lambdabot> http://en.wikipedia.org/wiki/Newsqueak
11:55:56 <lambdabot> Title: Newsqueak - Wikipedia, the free encyclopedia
12:01:46 <ddarius> mauke: Perhaps I was thinking the information in his recent Google talk was also in a single paper somewhere.  I could have sworn that there was a paper that had actual NewSqueak code, but also a section that was like a cut-down version of CWS, but I may just be thinking of the talk.
12:02:44 <ddarius> If you are interested in the talk it is here: video.google.com/videoplay?docid=810232012617965344 A Google Tech Talk about an hour long.
12:04:38 * mauke puts it in his tab queue
12:04:52 <mauke> (http:// would have been nice to make it clickable :-)
12:05:02 <mauke> ddarius: thanks for your pointers, btw
12:05:58 <ddarius> mauke: Well Google decided to be annoying as fuck a bit back so when I right-click and copy link location it gives me a gigantic link.
12:05:59 * hackagebot usb 1.0 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.0 (BasVanDijk)
12:06:01 * hackagebot usb-iteratee 0.4 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-iteratee-0.4 (BasVanDijk)
12:10:59 * hackagebot bindings-libusb 1.4.4 - Low level bindings to libusb.  http://hackage.haskell.org/package/bindings-libusb-1.4.4 (BasVanDijk)
12:15:23 <ptek> romildo: which operating system are You on?
12:15:36 <ddarius> mauke: Incidentally, it's primarily chapter 4 of Reppy's thesis, "Higher order concurrency," that I was referring you (and others) to earlier.  Most of the other chapters are either hand-holding or details.
12:16:17 <romildo> ptek, it is gentoo linux, using packages from the haskell overlay.
12:17:35 <ptek> romildo: than thats strange - I thought You are using windows first‚Ä¶ but did You check if /home/romildo/.ghci exists and has the correct rights?
12:19:43 <mkscrg> Library installation problem: trying to install aeson and http-enumerator. I can install one or the other, but installing the second one makes the first one invisible to ghc
12:20:49 <romildo> ptek, I do not have ~/.ghci. The ghci manuals says that ghci looks for ./.ghci, <appdata>/ghc/ghci.conf, ~/ghc/ghci.conf and ~/.ghci, so I thought that instead of using ~/.ghci, I could use ~/.ghc/ghci.conf instead of ~/.ghci.
12:20:52 <ben> is there a "the enumerator package for dummies" thing yet
12:21:04 <parcs_> iterIO or something
12:22:20 <ptek> romildo: I see
12:24:10 <mauke> ddarius: I've just finished the explanation of "become" in the video
12:24:37 <mauke> my reaction: wtf, this is exactly "return"
12:24:42 <ddarius> I don't actually understand what distinction he's trying to make between become and return.
12:24:45 <ddarius> mauke: I agree.
12:25:22 <valberg> is it just me or is there something wrong with haskell-platform dependencies in debian unstable?
12:25:36 <valberg> i get this http://hpaste.org/51280
12:25:43 <mauke> this just reinforces my general sense of "this guy has no idea what he's talking about" :-(
12:26:28 <kamaji> How would I implement a lookup table defined at compile time?
12:26:36 <kamaji> In C i'd just initialize a big array of all the values
12:26:50 <kamaji> I'm guessing pattern matching is O(n)
12:27:17 <c_wraith> it has to match the entire pattern.
12:27:27 <c_wraith> that is,  of course, O(size of the pattern) in the success case
12:27:54 <kamaji> right
12:28:01 <kamaji> so should I generate a switch/case ?
12:28:11 <mkscrg> anybody have experience with disappearing modules? i.e. install a new library that makes a previously installed library disappear?
12:28:11 <mauke> you could use an array
12:28:16 <romildo> ptek, after creating ~/.ghci, it worked. thanks.
12:28:30 <kamaji> mauke: but I have to create the array from a list at startup which is kinda.... meh
12:28:31 <ddarius> mauke: There could be some distinction if he has something that can reveal process identity, but I'm pretty sure he doesn't cover it in that talk, so it may just be a case where he's making a distinction about something that isn't relevant to the material he's presenting.g
12:29:22 <mauke> ddarius: you could equivalently specify that return+call must be a tail call
12:29:57 <kamaji> ah, so case is also O(n)
12:30:35 <kamaji> So is an array the only option?
12:31:04 <ptek> romildo: np
12:31:09 <copumpkin> pattern matching isn't O(n)
12:31:19 <ddarius> mauke: That's not necessarily the same, but yes, that may well be all that he's getting at.
12:31:22 <ddarius> mauke: Pike is definitely not the "academic theorist" type.
12:31:29 <kamaji> copumpkin: it's not O(1) is it?
12:31:33 <mauke> ddarius: how is it different?
12:31:41 <copumpkin> kamaji: one level deep, it probably is
12:31:54 <copumpkin> well
12:31:56 <benmachine> it could be implemented as a jump thingy couldn't it
12:31:56 <kamaji> "probably" hehe
12:31:58 <copumpkin> it depends what kind of pattern you want
12:32:00 <mauke> ddarius: (I grepped the newsqueak pdf for 'become'; no obvious special powers)
12:32:07 <benmachine> computed thingy
12:32:08 <kamaji> copumpkin: I'm just thinking a dense set of numbers
12:32:11 * benmachine helpful
12:32:24 <kamaji> e.g. | x == 0 = foo
12:32:30 <kamaji> | x == 1 = bar
12:32:30 <kamaji> etc.
12:32:32 <copumpkin> well, that would definitely be O(n)
12:32:35 <copumpkin> because it isn't a pattern
12:32:37 <copumpkin> it's a guard
12:32:43 <benmachine> numbers are slightly awkward because they involve typeclasses, but presumably they could be specialised
12:32:45 <copumpkin> the question is whether a numeric pattern behaves like that
12:32:50 <ddarius> mauke: Because process identity doesn't need to be tied to stack frames, but yeah, as I said earlier, I don't really know what distinction he is trying to make.
12:33:06 <copumpkin> kamaji: if they're multiple constructors from an ADT, it'll be O(1)
12:33:11 <copumpkin> so if you have an enum or something
12:33:12 <ddarius> copumpkin: I'm pretty sure the Report says it translates to that.
12:33:20 <kamaji> ok you lost me
12:33:23 <kamaji> ADT?
12:33:23 <mauke> ddarius: but processes are created by 'begin', not normal function calls, aren't they?
12:33:26 <copumpkin> ddarius: even for monomorphic number types?
12:33:33 <ddarius> mauke: Yes.
12:33:59 <copumpkin> I'd have assumed GHC would do something smarter for fixed number types
12:34:03 <copumpkin> but maybe not
12:34:10 <ddarius> copumpkin: The Report doesn't make any such distinction.  But just because the Report says it translates to that, doesn't mean you have to implement it the same way you'd naively implement that.
12:34:19 <copumpkin> yeah
12:35:06 <ddarius> copumpkin: Other than building a shallow if-tree, there isn't too much smarter things it could do.  Vectorizing seems like it would be not worth the implementation complexity it most of the time.
12:35:57 <copumpkin> fair enough
12:35:58 <kamaji> So there's definitely no guarantee that it would translate to a constant time function?
12:36:24 <ddarius> kamaji: Correct.  That said, there's no guarantee of any asymptotic complexities anywhere in the Report for anything.
12:37:02 <kamaji> Ok, I guess it's better to take the hit at the beginning then, because at least I know
12:37:10 <kamaji> (that it works)
12:37:12 <mauke> (I'm pretty sure the C standard doesn't guarantee O(1) access to arrays either)
12:37:50 <kamaji> well, I guess with C you know what's actually going on, i.e. a pointer addition and a memory access
12:38:20 <ion> But do you know what‚Äôs going on with the memory access? :-)
12:38:26 <ddarius> kamaji: No you don't.  Well you know that, but you don't know what "pointer addition" and "pointer dereference" entail.
12:38:40 <kamaji> aww, that's just mean :P
12:38:58 <copumpkin> lots of voodoo goes on when you dereference a pointer!
12:39:10 <ddarius> It's not always trivial though I'd be surprised if there existed a not-intentionally-malicious implementation that wasn't constant time.
12:39:37 <ion> Well, whether the data is kept in the cache may be the most important performance issue for some algorithms for instance.
12:40:06 <ousado> swap!
12:40:15 * earthy mumbles HAT Trie
12:40:27 * earthy mumbles cache-oblivious data structures
12:41:20 <kamaji> well this has all got much more complicated than I expected
12:41:22 <kamaji> typical computers.
12:41:49 <kamaji> but to rephrase: should I expect that doing a case/pattern match/guard thing will translate to something like a C array access?
12:49:11 <ddarius> Yay cache-oblivious data structures!
12:49:25 <Camembert> mauke seems c C does guarantee enough, case good engineering,  little more verbose.
12:49:45 <mauke> Camembert: what
12:49:52 <ddarius> Too bad they tend to be fairly particular about representation in ways that are awkward, difficult to control ways in a pure, lazy, garbage collected language.
12:51:12 <Camembert> mauke,  (I'm pretty sure the C standard doesn't guarantee O(1) access to arrays either)
12:51:40 <mauke> yes?
12:52:26 <ciaranm> your hardware doesn't provide O(1) access to arrays either except if the arrays are small
12:52:36 <ddarius> ciaranm: The arrays are always small.
12:52:48 <ddarius> (By small I mean bounded by a constant.)
12:52:59 <kmc> is there any way to reify the GHC profiling cost-center stack from Haskell code?
12:53:11 <romildo> In order to colorize the ghci prompt, I followed the instructions at http://blog.havenisms.com/colorizing-the-ghci-prompt, but it does not work. ghci seems to freezes the first time it is going to display the prompt. This is on gentoo linux with ghc-7.2.1. Any clues?
12:53:32 <ddarius> kmc: There may or may not be some recent hacks, possibly on hackage, that allow that.  I am pretty sure the only way is through hacks.
12:53:43 <kmc> which hacks would those be?
12:55:51 <ddarius> kamaji: A guard is just like writing an if.  Pattern matches can be arbitrarily complicated (and of course you need to force the thunk first which could require arbitrary amounts of computation.)  You can expect that accessing the fields of a constructor is constant time, and doing a case analysis on the variants is constant time.
12:57:11 <ddarius> kmc: I'm not even sure that I'm not imagining things.
12:58:21 <ciaranm> ddarius: are you surrounded by unicorns and / or naked girls? that's usually a sign your imagination is running wild
12:59:49 <zeiris> Where's the source for Hackage hosted?
13:00:15 <Nisstyre> zeiris: I'm going to have to guess either Hackage or GitHub
13:01:13 <zeiris> Looking at the categorized weaknesses from the state of the haskell survey writeup, it looks like a useful thing to have a hack at.
13:01:32 <copumpkin> there's a much better version pending
13:01:43 <copumpkin> but for some reason it isn't going live
13:01:53 <zeiris> Adding stats on how often the library is fetched, and high level documentation metrics (percentage of functions described, lines of examples...)
13:01:55 <copumpkin> I really don't know what the deal is with it :) you could try talking to Gracenotes or dcoutts if you want to work on it
13:02:18 <zeiris> I'd love to, but want to look at the code to see if I can.
13:02:20 <erus`> who are the google guys in here?
13:03:35 <osfameron> is there a haskell git-backed blog baker?
13:03:37 <ddarius> kmc: It looks like you can get relevant information from the header.
13:03:43 <osfameron> I can find gitit, which seems to only do wiki
13:03:59 <kmc> which header?
13:04:55 <Clint> osfameron: you should merge gitit with hakyll
13:05:39 <osfameron> Clint: I think that might be getting ahead of myself a bit ;-)
13:05:50 * osfameron checks hakyll out
13:06:18 <Clint> osfameron: take your time
13:07:53 <ddarius> kmc: The info table essentially.
13:07:59 <kmc> ok
13:08:10 <kmc> so is vacuum the place to look for libraries that might help with this?
13:08:22 <ddarius> kmc: That would be a place to start.
13:09:13 <dsouza> osfameron: well, you may use hakyll to generate the static files and publish it to github, which in turn will use jekyll to render them.
13:10:40 <osfameron> dsouza: hmm?
13:10:53 <dsouza> osfameron: https://github.com/mojombo/jekyll/wiki
13:11:03 <kmc> the context here is that i'm trying to log every function call's arguments and results
13:11:10 <kmc> in order to implement declarative debugging a la buddha
13:11:19 <osfameron> dsouza: oh, as in to gh-pages ?
13:11:19 <kmc> buddha uses a messy global program transformation
13:11:35 <adimit> apropos gitit, is there any good hosting solution for something like gitit?
13:11:37 <ddarius> One of the relevant GHC source files is http://darcs.haskell.org/cgi-bin/gitweb.cgi?p=ghc.git;a=blob;f=includes/rts/storage/InfoTables.h;h=4b0c40bbce5ddf31d35e3fc4a71cf3e7e6449556;hb=HEAD
13:11:41 <kmc> i'm trying to do a somewhat more local transformation that uses more side effects
13:11:41 <ddarius> kmc: So did Hat and Hood.
13:11:44 * osfameron was going to push the compiled files to his own webserver
13:11:57 <osfameron> though storing it on github seems like quite a good idea too
13:12:04 <kmc> this i think should suffice to get a list of function call events
13:12:07 <ddarius> (Do what Buddha did, that is.)
13:12:10 <kmc> but i'd rather have the tree structure
13:12:21 * osfameron cabal install's hakyll
13:12:26 <dsouza> yes, but jekyll gives you more control. I just suggested github as you asked for a git backend, and github is fairly popular.
13:13:02 <ddarius> That was the wrong file, though it is no doubt relevant too.
13:13:02 <kmc> hmm, I guess Hood is still an active project?
13:13:09 <ddarius> http://darcs.haskell.org/cgi-bin/gitweb.cgi?p=ghc.git;a=blob;f=includes/rts/storage/Closures.h;h=5f4f03541f088545160836d58e4ee8ac20e04c53;hb=HEAD
13:13:10 <merijn> Hell, I use github and I don't even use git :>
13:14:08 * dsouza finds emacs org-mode + github great as a blogging platform
13:14:21 <JoeyA> Has anyone implemented an array version of ByteString.useAsCString?  Namely, a way to pass a [ByteString] to a C function that takes an array of strings: char **
13:14:21 <osfameron> dsouza: are you suggesting jekyll instead of hakyll?
13:14:32 <adimit> dsouza: what do you do about a commenting system though?
13:14:34 <kmc> hood wants me to annotate my code with "observe"?
13:14:40 <JoeyA> (before I duplicate work)
13:14:46 <kmc> yeah i see
13:14:55 <osfameron> adimit: a lot of people seem to use disqus
13:14:57 <kmc> it doesn't do any rewriting for you
13:15:23 <dsouza> adimit: disqus might work
13:15:26 <ddarius> Well, I guess Hood itself is just a fancy Debug.trace.  I think there's a tool in terms of Hood that did do more global transformations.
13:15:37 <dsouza> adimit: http://disqus.com/
13:15:56 <adimit> osfameron, dsouza, Ok, I'll check it out, thanks. I'm looking for a sane way to start a new blog :-\
13:16:21 <hpc> disqus is not the place to start, if that is your goal ;)
13:16:29 * ddarius agrees with hpc.
13:16:38 <ddarius> If your goal is to get punched in the face though...
13:16:43 <hpc> for one, it doesn't work in my browser at all, ever
13:16:48 <adimit> yeah, to be for established sites.
13:16:51 <adimit> *sigh*.
13:16:55 <osfameron> thanks cabal: "The exception was: ExitFailure 1"
13:17:00 <dsouza> hpc: right, but it is certainly an option :-)
13:17:07 <osfameron> I love "There was an error, lol" messages
13:17:23 <ddarius> osfameron: You should use old Prolog systems.m
13:17:32 <adimit> false.
13:17:38 <ddarius> adimit: No.
13:17:43 <adimit> true.
13:17:54 <osfameron> aha, it can't install regex-pcre because I haven't got pcre on my system
13:18:18 <osfameron> wheee, brew install pcre actually does something
13:18:25 * osfameron hates installing software
13:18:28 <dsouza> osfameron: not really. you don't need jekyll if you use haskyll. publishing files to github will work [the thing they will use jekyll anyway, but it works with plain html files too]
13:18:28 <ddarius> osfameron: Add -v to your default cabal flags.
13:18:41 <adimit> ah, the lovely prolog days. tabbing through a stack trace for half an hour‚Ä¶
13:18:42 <ddarius> osfameron: The question is whether it does the right thing.
13:18:48 <osfameron> I can tell I'm going to need the next 2 hours installing shit, when really I wanted to be blogging ;-)
13:18:59 <osfameron> ddarius: -v?  and how?
13:19:33 <ddarius> Yes, because you can't write down text in an editor for a blog, only in a web-based form.
13:19:40 <kmc> a stack trace? that sounds nice...
13:20:00 <copumpkin> kmc: what kind of voodoo are you up to now?
13:20:22 <kmc> i'm trying to log every function call's arguments and results, in order to implement declarative debugging a la buddha
13:20:22 <Saizan> -v doesn't help, you simply have to look for the error in the log
13:20:23 <adimit> kmc: you have no idea what you're talking about‚Ä¶ prolog stack traces are‚Ä¶ labyrinths. literally.
13:20:41 <Saizan> s/log/scrollback/
13:20:41 <copumpkin> kmc: oh!
13:20:42 <ddarius> osfameron: cabal install --help
13:20:44 <osfameron> whee, cabal doesn't like the pcre that I just tried to install
13:21:02 <copumpkin> kmc: you could probably catch that stuff with the dtrace hooks TacticalGrace stuck in a while ago :)
13:21:04 <ddarius> osfameron: I'm pretty sure there's a way to specify default options for cabal in some config file.
13:21:13 <kmc> heh
13:21:15 <copumpkin> kmc: but I guess you don't want to rely on dtrace and/or modify GHC
13:21:22 <hpc> osfameron: you might consider attoparsec or something, instead of pcre?
13:21:41 <osfameron> hpc: I just did   cabal install hakyll... it seems to want pcre
13:21:46 <hpc> oh
13:22:04 <kmc> copumpkin, it's easy enough to do with side effects... (f x y) becomes (let log = unsafeMakeLogger () in log (Result (f (log (Arg 0 x)) (log (Arg 1 y)))))
13:22:05 <kmc> or so
13:22:18 <kmc> but then i don't get the tree of function calls, just a list of them
13:22:20 <copumpkin> but you don't want people to have to modify their code?
13:22:21 <copumpkin> ah
13:22:31 <kmc> well i was planning to do some automated code rewriting
13:22:46 <kmc> buddha has a messy global transformation; i'm looking for something a bit simpler and local
13:23:05 <kmc> their transformation doesn't handle currying or guards very well, for example :/
13:23:33 * ddarius finds kmc's use of "their" odd.
13:23:39 <kmc> (or maybe it does and it just wasn't implemented as of bernie pope's honors thesis)
13:24:45 <ddarius> Where can I buy drum sticks on this side of the Charles and Mystic?
13:25:00 <osfameron> aha! http://jaspervdj.be/hakyll/tutorial.html#regex-pcre-dependency-on-mac-os
13:25:47 <Peaker> nice.. #haskell is close in size to #python again :)  793 vs. 854
13:26:11 <scooty-puff> dcoutts: the GHC compile finally finished and i gave it a shot, got: stg_ap_ppp_fast' can not be used when making a shared object; recompile with -fPIC
13:26:24 <ddarius> From this we conclude that Haskell is almost as confusing as Python.
13:26:25 <scooty-puff> not sure where i could have missed it
13:28:41 <hpc> ddarius: can't tell if in response to Peaker, or scooty-puff :P
13:29:33 <osfameron> ok, ghc hakyll.hs is giving: File name does not match module name: Saw: `Main`; Expected: `Hakyll`
13:29:42 <osfameron> but from ghci, :m +Hakyll does work ok
13:30:10 <osfameron> I don't know how to get ghci? to tell me where the Hakyll.hs that it's failing to include is
13:30:30 <hpc> osfameron: try running locate Hakyll.hs?
13:30:36 <osfameron> oh ffs.  of course, it's another osx thing
13:30:41 <hpc> or that
13:30:52 <osfameron> hpc: never mind, sorted... (also, my locate doesn't seem to do anything useful...)
13:30:55 <osfameron> osx-- # useless platform
13:31:15 <copumpkin> mdfind
13:31:18 <hpc> osfameron: think you can solve the locate thing with updatedb
13:31:21 <copumpkin> locate on steroids
13:31:24 <copumpkin> fuck locate
13:31:29 <sm_> what's the ghc option to dump haskell source to the console during compilation, so you can see the result of TH ?
13:32:20 <osfameron> ok.  now it's complaining that 'list' isn't in scope.  I wonder if that's a genuine error in the example code this time?
13:36:16 <koeien> sm_ -ddump-simpl
13:36:37 <applicative> osfameron, do you get the error if you do "ghc foo/hakyll.hs" from outside the directory ("foo") containing hakyll.hs   A similar problem arises with xmonad.hs
13:37:43 <osfameron> applicative: yeah, same error (for brochure/site.hs)
13:37:58 <osfameron> whereas for simpleblog/site.hs, it whines about pcre (different error this time)
13:38:02 * osfameron gives up for the day
13:38:14 <sm_> koeien: thanks! Looks like that's mentioned only in http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html , must remember to start there
13:38:23 <osfameron> this faffing was the reason I originally went for the consumer blog Wordpress
13:38:38 <osfameron> (which has now itself broken... yay for software!)
13:38:58 <applicative> hakyll is turning into a giant empire of dependences.  I still haven't updated my minute site since I cant face learning all the new bells and whistles
13:40:35 <osfameron> I wouldn't mind deps if I was on a system that handled them, like a debuntu...
13:41:57 <Veinor> hmm
13:42:02 <Veinor> whoops, wrong channel
13:42:54 <sm_> koeien: -ddump-splices is the one I was looking for
13:51:12 <hpc> hehe: "and they have
13:51:13 <hpc> to play a rousing game of `count the lifts' in order to use"
13:51:32 <hpc> ...PDF, y u no wrap text?
13:51:51 <joe6> i can use this to get a list of random Int's (randomRs (1,10) (mkStdGen 0) :: [Int]). How hard is it to change it to get a list of [(Int,Int)]?
13:52:07 <joe6> I can do zip. take 100 and then drop . take.
13:52:27 <joe6> but, am curious if it is easier to create an instance Random (Int,Int)
13:52:41 <hpc> joe6: probably the latter, i think
13:53:00 <Veinor> there isn't a Random a, Random b => Random (a,b)?
13:53:04 <hpc> be careful of overlapping instances, if you want more instances later
13:53:20 <Veinor> huh, there isn't. weird.
13:53:56 <dolio> Yeah, I've felt that absence before.
13:54:07 <ion> > let r = state . randomR; pair = (,) <$> r (1,10) <*> r (1,10) in evalState (replicateM 100 pair) (mkStdGen 0)
13:54:09 <lambdabot>   [(6,6),(6,1),(3,10),(4,4),(4,9),(6,3),(5,3),(7,8),(3,4),(8,5),(5,9),(3,8),(...
13:55:41 <Rotsor> Is it a bad idea to try to define Data instance for (a -> b) type? I need to display a data structure in a TreeView for debugging, but I have some functions there, stopping GHC from deriving the instances automatically.
13:55:49 <joe6> ion, it will take me a while to understand it. thanks.
13:57:08 <Veinor> > let rand = randomRs (1,10) in take 3 $ zipWith (,) (rand $ mkStdGen 0) (rand $ mkStdGen 1)
13:57:09 <lambdabot>   [(6,8),(6,9),(6,8)]
13:57:20 <Saizan> Rotsor: import Data.Generics.Instances
13:57:52 <Rotsor> Saizan: oh... I'll try that, thanks! :)
13:58:00 <Saizan> Rotsor: it's a pretty crippled instance for implementation reasons but it might work for your purpouse
13:58:50 <joe6> veinor, thanks. that was simpler
13:59:02 <Rotsor> Saizan: I don't need to analyze the functions, I'd like to just skip them, so basically any instance will do.
13:59:04 <Veinor> in fact
13:59:22 <Veinor> > let rand = randomRs (1,10) . mkStdGen in take 3 $ zipWith (,) (rand 0) (rand 1)
13:59:23 <lambdabot>   [(6,8),(6,9),(6,8)]
13:59:42 <Saizan> Rotsor: unless it errors out :D
13:59:42 <joe6> ok, thanks.
14:00:28 <Rotsor> Saizan, indeed, that was a problem with the instance I was trying to make :)
14:01:16 <Saizan> Rotsor: anyhow to answer your original question, it's evil to define such an instance in a library, unless it's confined in its own module, in a program it's fine, assuming it can be implemented..
14:02:34 <Rotsor> Saizan, is it evil just because it's an orphan instance, or are there deeper reasons (Data typeclass-related)?
14:03:36 <Veinor> hmm
14:03:41 <Veinor> okay, design philosophy question
14:03:52 <adimit> orphan instances in libraries aren't very nice.
14:03:57 <Veinor> i'm writing a markov chain-based text generator, but there's no reason it only has to work with text
14:04:15 <Veinor> the sensible module name is Data.Markov, but that's used by markov-chain
14:04:30 <Saizan> Rotsor: because you can't make a legitimate instance of Data (a -> b) and others might differ on wanting to have a crippled instance at all or on the details
14:04:31 <adimit> Veinor: Text.Generator.Markov or something?
14:04:49 <Veinor> adimit: but it's not just used for text
14:05:28 <adimit> Veinor: well, Data.Generator.Markov
14:05:36 <Veinor> makes sense
14:05:37 <adimit> dunno.
14:05:44 <Veinor> i just didn't want to use the same package name
14:06:04 <adimit> it's hard chosing these names. I'm doing text corpora utilities, and I also don't know where to put 'em. Just put 'em anywhere.
14:06:09 * hackagebot np-extras 0.2.0.4 - NumericPrelude extras  http://hackage.haskell.org/package/np-extras-0.2.0.4 (BrentYorgey)
14:06:11 * hackagebot species 0.3.2.1 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.2.1 (BrentYorgey)
14:09:02 <Rotsor> Can one check in TH if a type is an instance of a given class? It would be nice to be able to derive Show instances for anything, skipping things that can't be shown.
14:09:17 <tgeeky> wohoo!
14:09:39 <Cale> Rotsor: try :info TypeName
14:09:46 <Cale> or :info ClassName
14:10:13 <Cale> Rotsor: both of those will show instances that are in scope
14:10:28 <Cale> er
14:10:31 <Cale> oh, in TH, sorry
14:11:23 <Cale> I don't know of a way to do that in TH
14:12:08 <Cale> Oh look: isClassInstance :: Name -> [Type] -> Q Bool
14:12:36 <Cale> Rotsor: So the answer is yes :)
14:12:40 <Veinor> also, relatedly
14:12:43 <Rotsor> Oh, that seems useful! :)
14:13:22 <Cale> classInstances :: Name -> [Type] -> Q [Name]
14:13:23 <Veinor> i'm going to be creating a type that's isomorphic to Maybe (in the sense that it looks like data CorpusChar = Corpus Char | EOF
14:13:28 <Veinor> should i just use Maybe?
14:14:07 <Cale> Veinor: Quite possibly. It depends on whether you're planning to extend it and how you intend it to be used.
14:14:27 <Cale> But there are definite advantages to using Maybe in terms of library support
14:14:36 <Veinor> well, it's basically going to be an internal type for this module
14:14:37 <mauke> ddarius: are you still here?
14:14:57 <Veinor> EOF represents the end of a training sample for the generator, Corpus Char represents actual data
14:17:11 <Veinor> the end user wouldn't ever need to use it
14:17:58 <Cale> I'd probably just use Maybe myself, unless I expected that there'd be other cases in the future.
14:18:19 <Veinor> makes sense
14:28:21 <mauke> fucking hell, rob pike doesn't know c
14:28:37 <Guest21124> i dont know c
14:29:08 <Eduard_Munteanu> You're not Rob Pike :P
14:30:01 <shachaf> mauke: He doesn't?
14:30:07 <mauke> apparently not
14:30:28 <Ptival> the fact that, for instance, Eq is in Data.Eq, is GHC-specific? (the Online Report seems only to mention it in Prelude)
14:30:30 <shachaf> Apparent from where?
14:30:42 <shachaf> Ptival: Yes.
14:30:58 <shachaf> In fact, it's in GHC.Classes.
14:31:11 <Ptival> shachaf: ok, thanks
14:31:21 <mauke> shachaf: „Äåb=2 sets b to 2 and yields 2 as its value. This allows chains of assignments: a=b=2; is a statement that assigns 2 to b and then to a. (C handles this differently; it assigns 2 to b and then b to a.)„Äç
14:32:15 <Eduard_Munteanu> Well, that's a bit nitpicking... if you reduce 2 first then it's the same thing, no?
14:32:38 <Eduard_Munteanu> So in a = b = f(), f doesn't evaluate twice.
14:32:55 <mauke> then what did he mean by "C handles this differently"?
14:33:08 <Jafet> c=*(p=&n);
14:33:14 <Eduard_Munteanu> Hm, my bad, I thought that was your reply to his statement.
14:33:30 <Guest21124> it doesn't give the direct value of 2, it gives the value of b which is 2. correct?
14:35:25 <Eduard_Munteanu> Actually what happens is b = f() is an rvalue, no?
14:35:52 <Eduard_Munteanu> And a chain of assignments is right-associative, or something like that.
14:36:08 <shachaf> Eduard_Munteanu: I think mauke is saying that that line is saying that it assigns the old value of b to a.
14:36:21 <Eduard_Munteanu> Just like in   if ((a = f()) > 2) ...
14:36:33 <Guest21124> oh, so the opposite of what i said
14:36:35 <Eduard_Munteanu> Oh...
14:37:21 <Eduard_Munteanu> That's definitely not the case in real-life C. :)
14:38:12 <boris``> mauke: what other language is he talking about?
14:38:14 <Guest21124> What C is being talked about here?
14:38:20 <boris``> he's at least right regarding C
14:38:26 <osfameron> @pl (\p -> `mod` p)
14:38:26 <lambdabot> (line 1, column 8):
14:38:26 <lambdabot> unexpected "`"
14:38:26 <lambdabot> expecting lambda abstraction or expression
14:38:36 <mauke> boris``: newsqueak
14:38:48 <osfameron> @pl (\p -> (`mod` p))
14:38:48 <lambdabot> flip mod
14:39:13 <boris``> never heard of it
14:39:26 <shachaf> boris``: He's saying that C handles it differently.
14:40:32 <boris``> shachaf: well, it does. in C, the value of an assignment expression is the value of the LHS after the assignment
14:40:34 <shachaf> Parentheses are disgustingly overloaded in too many languages.
14:40:49 <Guest21124> lol true that
14:41:00 <Eduard_Munteanu> shachaf: what are you referring to?
14:41:03 <shachaf> boris``: Right, which is exactly what the first sentence is describing.
14:41:27 <shachaf> Eduard_Munteanu: The different meanings of "(" and ")" in almost every language.
14:41:35 <boris``> no, the first sentence says that in that other language, a = b = 2 assigns 2 to both a and b
14:41:52 <boris``> or, "to b, then to a", if that has any special meaning in that language
14:41:53 <Guest21124> that is the general consensus
14:41:55 <mauke> boris``: what's the difference?
14:42:05 <shachaf> It says that "b=2" sets b to 2 and yields 2 as its value.
14:42:16 <shachaf> Which is exactly what it does in C.
14:42:17 <mauke> boris``: also, your definition of "first" is weird
14:42:18 <Guest21124> no major difference, just how the language behaves
14:42:54 <mauke> ok, I hate rob pike now
14:42:55 <boris``> it only matters if the value stored does not match the RHS value, eg. exceptional arithmetic conditions or strange volatile objects
14:42:57 * cmccann creates a language where balanced parentheses are an ad-hoc polymorphic function written outfix, just to annoy shachaf
14:43:50 <shachaf> mauke: What did he do?
14:43:59 <Guest21124> Your vocabulary is astounding
14:44:12 <mauke> shachaf: create newsqueak
14:44:24 <mauke> he also wrote two papers on it and gave a google talk
14:44:38 <boris``> for example, if b is an identifier that refers to a register that always reads 0, then a = b = 2; in C should result in 2 being written to b, and a getting 0
14:44:50 <shachaf> What's wrong with Newsqueak?
14:44:50 <Eduard_Munteanu> Cardelli worked with Pike on Squeak?
14:44:54 <Eduard_Munteanu> Interesting.
14:45:03 <mauke> shachaf: hard to tell, the papers don't say
14:45:09 <mauke> which is part of my point
14:45:25 <mauke> e.g. what does 'x<- = <-x;' do?
14:45:41 <mauke> according to the language reference the semantics are "I dunno lol"
14:45:52 <Eduard_Munteanu> (Cardelli seems to have a bit of reputation, I mean)
14:46:05 <shachaf> mauke: Pretty popular semantics.
14:47:14 * shachaf wonders whether "semantics" is singular or plural.
14:47:18 <mauke> the language distinguishes between „Äåchar„Äç and „Äåint„Äç. a literal constant like „Äå42„Äç has type int, while a constant like „Äå'x'„Äç has type ... int
14:47:45 <shachaf> What has type char?
14:48:04 <mauke> "x"[0], presumably
14:48:12 <mauke> and variables declared as 'char'
14:48:38 <Eduard_Munteanu> Isn't this confusing integer *promotion* with other things?
14:48:48 <Eduard_Munteanu> Wait, this isn't about c.
14:49:14 <mauke> characters constants have type int in C as well
14:49:47 <hpc> does C have a typeof macro/command thing?
14:49:54 <mauke> no
14:50:06 <Eduard_Munteanu> There are non-standard typeof() implementations.
14:50:28 <Eduard_Munteanu> e.g. GCC has typeof()
14:50:36 <shachaf> GCC has it all.
14:50:38 * cmccann always got the impression that C only grudgingly admitted that there are types other than "a pile of bits"
14:51:21 <adrake> shachaf: whoa, when did GCC gain laziness, useful static typing, lambdas, and pattern matching? O_o
14:51:24 <Eduard_Munteanu> mauke: ah so in char c = '3' it's implicitly converted to a char?
14:51:27 <c_wraith> cmccann: you mean the smallest advance over BCPL possible?
14:51:30 <mauke> Eduard_Munteanu: yes
14:51:56 <cmccann> c_wraith, this is probably where I should dig up that Hoare quote about ALGOL, but I'm too lazy
14:51:58 <shachaf> adrake: It's an undocumented extension.
14:52:06 <shachaf> adrake: You win programming if you can figure out the syntax.
14:52:13 <penryu> C distinguishes char from int, but only in terms of the size of the data type; char is 1 byte, while int is implementation-dependent.
14:52:16 <adrake> shachaf: :D
14:52:24 <mauke> early C versions had Haskell's scoping problem with struct fields
14:52:45 <shachaf> penryu: Isn't char also implementation-dependent?
14:52:47 <mauke> that is, field names were global and you could access any field in any struct
14:52:53 <Eduard_Munteanu> Yeah, there's only an ordering constraint on the sizes of types.
14:53:04 <mauke> shachaf: no, but byte is
14:53:11 <Eduard_Munteanu> CHAR_BITS
14:53:15 <mauke> CHAR_BIT
14:53:20 <shachaf> CHAR_BI
14:53:26 <Eduard_Munteanu> :P
14:53:37 <penryu> shachaf: if the char were to change size, pointer arithmetic the world over would collapse into chaos.
14:53:39 <rwbarton> this version of the C99 standard I am looking at has every occurrence of the fi ligature replaced by √•
14:53:54 <mauke> nice
14:54:01 <rwbarton> and it's a PDF file
14:54:04 <ousado> adrake: what makes you think those are things GCC isn't able to emit code for?
14:54:15 <Eduard_Munteanu> So "file" reads "√•le"? :)
14:54:33 <Jafet> "ALGOL is a language so far ahead of its time that it was not only an improvement on its predecessors but also on nearly all its successors"
14:54:39 <kmc> ironic since C is the #1 force for keeping broken legacy character encodings around
14:54:49 <dmwit> rwbarton: Sounds like a font problem.
14:55:25 <cmccann> Jafet, yes that was the one, thank you :]
14:55:32 <rwbarton> I'll try evince rather than chrome's built-in reader
14:55:44 <rwbarton> link is http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf
14:56:16 <rwbarton> interesting, it works in evince
14:56:31 <dmwit> chrome--
14:57:39 <luite> works fine here in safari, preview and skim
14:58:20 <mauke> have some standards: http://www.mediafire.com/?qcm768fdf3yc6nx
14:58:37 <luite> even in chrome
14:59:43 <Jafet> http://www.amazon.com/dp/B000006PVI
15:03:47 <ryb> Hey guys. I'm trying to call Python code from multiple Haskell threads with MissingPy. The code I'm about to post in hpaste does nothing. Help?
15:03:52 <hpaste> ryb pasted ‚ÄúMissingPy + forkIO‚Äù at http://hpaste.org/51281
15:06:06 <Saizan> ryb: does it terminate?
15:06:18 <ryb> Saizan: no
15:10:33 <mauke> I've written a newsqueak-style channel in haskell
15:10:35 <mauke> yay!
15:10:56 <shachaf> mauke: newSqueakStyleChannel = undefined?
15:11:14 * hackagebot hledger-lib 0.15.2 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.15.2 (SimonMichael)
15:11:16 * hackagebot hledger 0.15.2 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.15.2 (SimonMichael)
15:11:38 <mauke> no, newtype NSchan a = NSchan (MVar (MVar a))
15:12:05 <ousado> no type-level programming in haskell?
15:12:18 <mauke> not today, little one
15:12:30 <Peaker> ousado: there is type-level programming, but it's a bit obscure (type-class hackery)
15:13:08 <ousado> oh
15:13:28 <shachaf> "hackery" is a word that means it's obscure.
15:13:43 <Saizan> type families make it fairly less obscure
15:13:48 <dainanaki> and unwieldy
15:13:48 <tac-tics> hackery = GHC, Not haskell
15:13:48 <tac-tics> :P
15:13:55 <dainanaki> truer words...
15:13:58 <ousado> and I thought haskell was all about types..
15:14:07 <Jafet> No, Haskell is all about monads.
15:14:10 <cmccann> type families just make it slightly less perverse
15:14:22 <cmccann> it's still pretty obscure if you're doing anything nontrivial
15:14:35 <ousado> ok.. I don't want another C++
15:14:47 <shachaf> Monads are a lot like Haskell.
15:14:56 <cmccann> C++'s template metaprogramming is a very different sort of beast
15:15:09 <Peaker> ousado: Haskell is a lot about types, you don't need to do a lot of type-level programming to reap a lot of benefits
15:15:34 <dainanaki> Haskell > C++ * 1000
15:15:45 <mauke> preflex: karma C++
15:15:45 <preflex>  C++: -60
15:15:47 <tac-tics> Haskell's errors are almost as obscure as C++
15:16:01 <copumpkin> tac-tics: not at all
15:16:04 <dainanaki> not really
15:16:11 <Peaker> Sometimes they are worse. Usually they are better
15:16:15 <copumpkin> they're pretty good, I think
15:16:18 <copumpkin> most of the time
15:16:21 <Jafet> tac-tics: http://hpaste.org/51091
15:16:24 <copumpkin> also, GHC's errors ;)
15:16:25 <copumpkin> not haskell's
15:16:30 <c_wraith> I've never had one missing semicolon result in several hundred lines of error messages in Haskell.  Maybe I'm just not using programs with big enough types. :)
15:16:42 <HugoDaniel> Haskell: deprecating your favourite computer programming language way before you were born!
15:16:43 <ousado> does agda produce efficient code?
15:16:45 <luite> well if you liberally use quasiquoting and template haskell you can get errors that rival C++'s
15:16:52 <shachaf> c_wraith: Oh, you can end up with hundreds-of-line error messages with GHC.
15:16:59 <shachaf> Even infinite error messages.
15:17:00 <Peaker> copumpkin: as extensions are being added, and people are tuning their code to ghc, it is more and more true that Haskell is nothing but ghc...
15:17:10 <c_wraith> shachaf: I rarely get error messages more than about 20 lines long. :P
15:17:19 <Jafet> You can devise error messages as long as -fcontext-stack
15:17:26 <Jafet> http://hpaste.org/51082
15:17:27 <mux> the worse I had was "panic: the impossible happened!"
15:17:31 <mux> or something like that :-)
15:17:34 <Peaker> ousado: in theory, Agda can product more efficient code.. I think it compiles to Haskell, though, and I don't know if it ends up efficient in practice
15:17:37 <c_wraith> mux: that's a compiler bug. :)
15:17:43 <mux> I know :-P
15:17:46 <Jafet> Actually, GHC should fix that one above.
15:17:50 <copumpkin> Peaker: it doesn't
15:18:23 <c_wraith> I've also got the famed "My head exploded" error message, when dealing with existentials.
15:18:25 <Jafet> People run agda code? I thought they just got it to compile and then called it a day.
15:18:32 * cmccann has gotten the "impossible happened" message from ill-formed TH splices
15:18:34 <copumpkin> yeah, I don't run it
15:18:37 <shachaf> Jafet: That's called running.
15:19:00 <Jafet> Well, you don't compile it to run it there. (Right?)
15:19:09 <shachaf> Jafet: Agda actually compiles its types to efficient machine code and runs that in order to check them.
15:19:09 <Jafet> Type system compilation, go go
15:19:12 <shachaf> It's too slow otherwise.
15:19:24 <copumpkin> shachaf: ?
15:19:25 <Peaker> I don't think I've seen use of existentials that wasn't superfluous or just-for-performance's sake
15:19:27 <copumpkin> no it doesn't
15:19:41 <shachaf> copumpkin: Hmph.
15:19:46 <copumpkin> I wish that were true :P
15:19:53 <rwbarton> it's just too slow
15:19:55 <Saizan> yeah, that'd be nice
15:20:01 <shachaf> Parallel type-checking would be nice. Does it do that?
15:20:02 <copumpkin> I want agda on the GPU
15:20:08 <copumpkin> so I could use my GPU monster for it
15:20:11 <Peaker> Agda compilation times are that bad?
15:20:16 <cmccann> c_wraith, anyway, I know of at least two ways to get absurdly long error messages out of GHC, and one doesn't need any extensions at all
15:20:18 <copumpkin> unfortunately I don't think it's well suited :)
15:20:27 <copumpkin> Peaker: one of my libraries takes half an hour to typecheck
15:20:53 <ousado> O_O
15:21:13 <Jafet> Heh, I thought g++ compile times were bad.
15:21:14 * hackagebot hledger-web 0.15.3 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.15.3 (SimonMichael)
15:21:36 <Saizan> but that's CT
15:21:37 <Jafet> How much memory does agda use for that, pumpkin?
15:21:50 <Peaker> copumpkin: terrible... maybe someone ought to provide a crypto-signed type-checking cache for Agda somewhere on the web?
15:22:21 <dainanaki> I've got bindings to the Obj-C runtime that are nearly done, anyone have any ideas for a sample program?
15:22:24 <c_wraith> Peaker: proof-carrying code is designed for that sort of thing.
15:22:27 <Saizan> i.e. if you don't use that many records it tends to be saner
15:22:30 <Peaker> copumpkin: one of the selling points of advanced types is detecting errors earlier when they are cheap -- but 30 minutes for a library compile makes it sound expensive...
15:22:42 <copumpkin> Peaker: most of the stuff I write isn't like that
15:22:55 <copumpkin> it's not fast, but it isn't nearly that bad
15:22:55 <c_wraith> Peaker: the basic idea is that the code contains within it a proof that the code is type-correct.  The proof can be checked rapidly, in comparison to deriving it.
15:22:59 <copumpkin> a few seconds often
15:23:19 <Peaker> c_wraith: I didn't know Agda derived proofs.. I thought the types in there were the proof, so Agda was already PCC?
15:23:38 <c_wraith> Peaker: its type system *is* a theorem prover.
15:23:38 <Peaker> the values specified that implement the types, more accurately
15:23:57 <c_wraith> Peaker: in any case, as far as I know, agda doesn't generate PCC.
15:24:03 <Jafet> Type inference is theorem proving
15:24:03 <Peaker> c_wraith: Something like djinn is a theorem prover, if you write the type and value yourself, then you have a theorem checker, not prover
15:24:27 <Saizan> "theorem prover" is kind of overloaded
15:24:29 <Peaker> Jafet: Type inference is detecting which propositions were proven, isn't it? (the other way around)
15:24:58 <Saizan> but they tend to use "proof assistant" for something like agda
15:25:14 <Peaker> Saizan: not part of compile time, though, right?
15:25:26 <mux> tac-tics: see? after a few discussions like that in #haskell, GHC errors seem terribly mundane.
15:25:27 <Saizan> Peaker: what isn't?
15:25:29 <Eduard_Munteanu> I don't think Agda compares to PCC
15:25:53 <cmccann> yes, type inference is basically saying "here's a proof, ok, now tell me what I just proved"
15:25:55 <Eduard_Munteanu> Besides, you never know if your types could be "safer", or stricter.
15:26:20 * Eduard_Munteanu would like value inference... here's a specification, now tell me an implementation
15:26:22 <Peaker> Saizan: the proof assistant doesn't have related compilation time costs, I presume?
15:26:38 <Jafet> Eduard: quickspec!!
15:26:53 <Jafet> Did quickspec crawl into chalmers basement and die?
15:26:53 <Saizan> Peaker: "proof assistant" is a name for what agda as a whole does
15:27:03 <cmccann> Eduard_Munteanu, like djinn? :P
15:27:06 <Saizan> Peaker: so i don't get your question
15:27:20 <Eduard_Munteanu> cmccann: yes, except at a larger scale.
15:27:30 <Jafet> @where quickspec
15:27:30 <lambdabot> I know nothing about quickspec.
15:27:30 <Peaker> Saizan: I thought it was some interactive tool you use sometimes
15:27:35 <Eduard_Munteanu> Say, you're only free to pick constants when things aren't unique.
15:28:19 <Eduard_Munteanu> I wonder if that forces you into refining your types well enough.
15:28:47 <cmccann> Eduard_Munteanu, there's always the context-filling interactive approach. leave a placeholder, let it infer the necessary type from context, and suggest things based on what's in scope that might help
15:29:41 <Saizan> Peaker: no, i wasn't referring to some part of it, though to be complete there is a agda2-auto command in the emacs mode which does proof search and which doesn't get called when typechecking
15:29:42 <Eduard_Munteanu> cmccann: yup. But the point is maybe we should forbid the programmer to write certain logic, relying on parametricity as much as possible
15:30:07 <dennis_> Hello Haskell folks. I asked this question on r/haskell and was called a troll, but I'm genuinely curious: when does it make sense to use Haskell for parallel computing vs C / Java / Python?
15:30:26 <mauke> dennis_: when you want to use threads
15:30:48 <kmc> dennis_, because Haskell lets you add parallelism annotations, which don't require explicit thread management and can't change semantics
15:30:57 <Peaker> dennis_: Parallel computing in Python virtually never makes sense, I think... If Python gives you a factor of 100 slowdown, you're going to need a lot of work to gain it back with parallelism
15:30:58 <Eduard_Munteanu> And perhaps when you don't care about micromanaging locking.
15:31:05 <Jafet> You don't need to use threads to use parallelism
15:31:09 <kmc> also because CPython's thread implementation is /terrible/ and pthreads in C are horribly cumbersome
15:31:09 <cmccann> of course if we're talking serious hardcore parallelism, that usually has specialized approaches
15:31:19 <Peaker> dennis_: and you're only going to be able to use processes, not threads, or distributed machines..
15:31:23 <Jafet> Can cpython do parallel computing yet?
15:31:27 <Eduard_Munteanu> cmccann: have you heard about anything like that?
15:31:36 <sohum> @hoogle [Bool] -> Bool
15:31:36 <lambdabot> Prelude and :: [Bool] -> Bool
15:31:36 <lambdabot> Prelude or :: [Bool] -> Bool
15:31:36 <lambdabot> Data.List and :: [Bool] -> Bool
15:31:40 <Peaker> Jafet: it always could, but not via threads.. (via processes)
15:31:40 * sohum doy
15:32:17 <kmc> dennis_, it's important to distinguish concurrency (nondeterministic semantics of IO execution) from parallelism (deterministic computation on multiple cores).  GHC Haskell is good at both, but you use quite different tools for each
15:32:21 <dennis_> @Peaker: I agree, I've never had a reason to use Python when performance was my concern
15:32:21 <lambdabot> Unknown command, try @list
15:32:23 <Peaker> kmc: It's quite simple to write a user-level thread thingie on top of pthreads, I'd say that it's the shared mutable state thread model that makes things hard in C, not the threads themselves
15:32:24 <Eduard_Munteanu> cmccann: the reason I'm asking is because I find myself asking whether some type could be stricter or safer in some sense. Maybe this would force programmers to encode lots of information into types?
15:32:49 <cmccann> Eduard_Munteanu, I'm not that thoroughly familiar with the current state of the art to answer that reliably, sorry
15:32:57 <Jafet> dennis: have you learned haskell?
15:32:58 <Peaker> kmc: writing a user-thread context-switcher is about a pageful of inline assembly :)
15:33:03 <dennis_> Jafet: yes
15:33:19 <dennis_> I find Haskell much easier to use than C, but I don't think that is the average case
15:33:19 <Jafet> Enough to know how to use threads, or Control.Parallel?
15:33:23 <kmc> Peaker, i would not call a page of inline assembly "quite simple" but it's been done for you anyway
15:33:33 <kmc> dennis_, i think it's the average case for people who have learned enough Haskell
15:33:39 <kmc> simply because C is a very low-level language
15:33:46 * cmccann thinks concurrency is a much clearly benefit in Haskell than parallelism is
15:33:47 <Peaker> kmc: Well, it's basically copying a bunch of registers into a memory struct and back, and then returning..
15:33:53 <kmc> it's too cumbersome for most things that aren't an OS kernel
15:33:55 <dennis_> Jafet: Yes, although I haven't used either yet. I'm asking b/c I want to know whether it's worth learning
15:33:57 <dennis_> kmc: afgreed
15:34:17 <kmc> but the Haskell learning curve is such that many people know only a tiny bit of Haskell
15:34:20 <Jafet> dennis: the ghc approach to concurrency and parallelism is worth learning, even if you don't ever use it.
15:34:29 <dennis_> My question is, how likely is it that Haskell will be used for parallelism in the future
15:34:36 <dennis_> as opposed to C or Java
15:34:41 <Jafet> Now that is a troll question
15:34:41 <kmc> it is used for parallelism in the present
15:34:44 <cwl> how to practise haskell more, while exercise in RHW is too little
15:34:51 <dainanaki> It would be nice to have a Haskell competency matrix.
15:34:54 <Peaker> "OS kernel" is quite a bit more narrow than what C fits for... when you want realtime/tight-resource-control, C is nice
15:35:05 <Jafet> dainanaki: we already do
15:35:07 <Jafet> @where evolution
15:35:07 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
15:35:14 <cmccann> Eduard_Munteanu, that said I do expect there's already stuff out there along the lines you're interested in, I just don't know how to help you find it
15:35:20 <dainanaki> Jafet, hardy har.
15:35:28 <Eduard_Munteanu> I see, thanks.
15:35:30 <kmc> dennis_, if the question is just "Will Haskell ever be as popular as Java" then I think the answer is no
15:35:46 <Peaker> kmc: I'm pleased with C for the systems code I write -- where I want to control resource use tightly
15:35:49 <Eduard_Munteanu> Well, it was just a wild idea, I'm not even sure it could work.
15:35:51 <kmc> but whatever replaces the replacement for the replacement for Java 30 years hence might look kind of like Haskell
15:35:53 <Peaker> (not quite a kernel, though)
15:36:05 <Saizan> Eduard_Munteanu: type and value inference are basically the same thing for a dep. typed language, in fact you can put _ anywhere in agda and if it's constrained enough it'll get filled
15:36:07 <dennis_> kmc: where have you seen parallel haskell being used?
15:36:09 <Peaker> kmc: wow, you're optimistic about progress velocity :)
15:36:21 <Eduard_Munteanu> Hm, yeah, good point.
15:36:22 <Jafet> kmc: be careful with your statements, we might already be seeing a replacement for C#
15:36:41 <Eduard_Munteanu> Wait, I could actually try to program with _ a bit.
15:37:01 <Peaker> Agda program: _ _ _ 1 _ _ _ 2
15:37:07 * cmccann predicts that 30 years from now, after many advances in the state of the art for high-performance computing, numerically-intensive computing will be done in FORTRAN
15:37:09 <Saizan> don't expect too much though :)
15:37:11 <Jafet> I bet that's how copumpkin gets half hour compile times
15:37:13 <dennis_> Jafet: I agree, I started learning haskell to be a better programmer in general
15:37:20 <Eduard_Munteanu> Peaker: and a 10-lines long type :)
15:37:21 <dennis_> But of course I'm curious about it's future
15:37:22 <Saizan> but we can almost surely do better than current Agda
15:37:43 <kmc> dennis_, Microsoft is funding a project to push the use of parallel haskell in industry
15:38:01 <Eduard_Munteanu> kmc: do you mean DPH itself?
15:38:08 <kmc> no, I didn't say DPH
15:38:18 <kmc> http://www.haskell.org/haskellwiki/Parallel_GHC_Project
15:38:25 <Eduard_Munteanu> Oh.
15:38:59 <kmc> dennis_, I don't think Haskell will ever be super popular
15:39:01 <Eduard_Munteanu> Woot... Haskell iproute
15:39:21 <kmc> but that doesn't mean you shouldn't learn it and use it when appropriate
15:39:48 <ousado> pfft haskell is super popular
15:40:05 <ousado> if you don't compare it to michael jackson
15:40:05 <dennis_> kmc: neat, I will look into that. And yes, I converted a couple of pet programs over to haskell this weekend to speed them up, so it is useful from time to time
15:40:13 * tgeeky thinks the people who invent the "super popular" languages of the future, will have designed things based on something learned in Haskell
15:40:17 <kmc> in fact, using good tools which are obscure is a good way to get a competitive advantage over people who are doing the same thing everyone else is doing
15:40:30 <kmc> indeed
15:40:34 <Jafet> Insert paulgraham.com link here
15:40:35 <tgeeky> iff, haskell isn't already "super popular"
15:41:05 <tgeeky> the bottom line is, the hardcore Haskellers are interested in learning about the nature of computation, and computation isn't a fad
15:41:22 <kmc> C#'s LINQ and F#'s "computation expressions" or "workflows" or whatever already look a lot like monads minus the scary name
15:41:31 <dennis_> Sounds like the answer is: Haskell is appropriate for parallelism, it probably won't catch on but it has tons of interesting ideas that are worth learning and using
15:41:39 <kmc> yep
15:41:50 <cmccann> kmc, it's a bit more than "look like", as you probably know :P
15:42:01 <tgeeky> dennis_: pretty close, I'd add - unlike many languages, there are several competing 'good approaches' in Haskell
15:42:02 <kmc> dennis_, it depends what you mean by "catch on", though
15:42:36 <kmc> Haskell's popularity has been rapidly increasing over the past 5 or so years
15:42:41 <kmc> and the tools have improved dramatically
15:42:47 <kmc> i expect that trend to continue for a long while
15:43:07 <cmccann> Haskell is now one of the most popular obscure languages that almost nobody uses
15:43:11 <tgeeky> it wouldn't surprise me if there is some sort of "killer app" or so, that makes haskell un-jump the un-shark
15:43:23 <hpc> cmccann: it's that esolang everybody talks about?
15:43:29 <hpc> cmccann: like ruby a few years ago ;)
15:43:29 <kmc> tgeeky, i don't think so
15:43:41 <dennis_> kmc: I really hope so, but FP as a whole has been unpopular for so long. Haskell is still one of the least used languages today.
15:43:42 <kmc> Rails did it for Ruby but Ruby is fundamentally a rehash of Perl, Python, etc.
15:43:49 <dennis_> I would love to see that change though
15:43:53 <kmc> it's not "one of the least used"
15:43:58 <tgeeky> kmc: I don't see that as an argument or counter-argument
15:44:02 <kmc> 99% of languages invented are a 1-person toy project
15:44:06 <tgeeky> kmc: we won't know what the killer app will be
15:44:07 <Jafet> Piet is one of the least used languages today
15:44:13 <kmc> Haskell is the least-used language in the set of languages which are as popular or more popular than Haskell
15:44:19 * cmccann thought Ruby was a rehash of Perl and Smalltalk mostly
15:44:23 <ousado> the question is what is taught at universities
15:44:28 <Jafet> Another is unlambda. (brainfuck is somewhat popular.)
15:44:32 <kmc> dennis_, anyway, why do you care so much about popularity?
15:44:38 <tgeeky> kmc: i'm trying to see if that sentence can make sense
15:44:47 <tgeeky> kmc: oh, ok, yes
15:44:52 <cmccann> Jafet, unlambda is lame because it's strict and impure
15:44:54 <tgeeky> kmc: what does github say?
15:45:02 <Jafet> cmccann: like ML?
15:45:10 <kmc> i don't know
15:45:21 <tgeeky> kmc: Haskell is #15 of 60
15:45:21 <dennis_> kmc: because I was having this exact argument with a friend who prefers C. And I want ammunition for the next time I defend Haskell
15:45:27 <kmc> sigh
15:45:44 <kmc> they're not even for the same things
15:45:46 <cmccann> anyone who prefers C as a general purpose language these days is probably hopeless
15:45:57 <kmc> it's like arguing which is better, a food processor or a screwdriver
15:46:08 <Iceland_jack> kmc: the screwdriver, surely
15:46:10 <tgeeky> JavaScript -> Ruby -> Python -> Shell -> C -> PHP -> Java -> Perl -> C++ -> Objective C -> (4 more) -> Haskell
15:46:10 <hpc> cmccann: it can be done, but you have to be pretty much a wizard
15:46:18 <tgeeky> kmc: lol, I love that
15:46:26 <Jafet> kmc: no, which is more popular!
15:46:26 <kmc> and yeah my experience is that the people who use C for everything are driven by immature machismo
15:46:33 <dennis_> His argument was, if you are writing a parallel program, you want speed. And Haskell is slower than C, so you're losing speed. So why use Haskell
15:46:45 <tgeeky> dennis_: that's a terrible argument
15:46:47 <cmccann> dennis_, that is one of the stupidest arguments I've ever heard
15:46:49 <kmc> "i'm so hardcore that i can do simple string manipulations in only 100 lines with only 3 exploitable security holes"
15:46:56 <Jafet> Okay, dennis is indeed trolling.
15:46:58 <tgeeky> dennis_: if you're writing a parallel program, you want to know it works, first
15:47:00 <cmccann> I think the proper counterargument to an argument that dumb is to smack them upside the head
15:47:02 <kmc> trolling by proxy
15:47:11 <kmc> "my friend said Haskell is super lame, is that true?"
15:47:21 <danharaj> Does proxy trolling have an RFC document?
15:47:26 <kmc> "help me refute my imaginary friend's trolling"
15:47:31 <tgeeky> dennis_: Rule #19. Don't argue with idiots. They'll bring you down to their level, and beat you with experience.
15:47:38 <kmc> anyway i said i would try to cut back on #haskell wankfests about how Haskell is great and everyone else sucks for not using it
15:47:42 <kmc> so, enjoy
15:47:50 <dennis_> Haha. Sorry for the trolling by proxy
15:47:52 <Jafet> tgeeky: follow it yourself!
15:47:58 <HugoDaniel> :D
15:48:06 <tgeeky> Jafet: I'm not arguing :)
15:48:15 <tgeeky> Jafet: and I'm an idiot, anyhow. Compared to many of you.
15:48:16 <HugoDaniel> haskell is great and everyone else sucks for not using it! specially the guys doing client-side web programming
15:48:25 <tgeeky> I'm a theoretical physicist, so that's a kind of idiot
15:48:52 <hpc> HugoDaniel: i read an interesting proposal about switching browsers from js to scheme
15:48:57 <Somix> Haskel appropriate for parallelism? How did that happen?
15:49:16 <Jafet> Javascheme
15:50:27 <Jafet> hpc: that'll never catch on now that mozilla is switching them to python
15:50:49 <ousado> Jafet: what?
15:50:52 * cmccann wants client-side Agda
15:50:57 <Jafet> Besides, all those parens, they eat up web traffic
15:51:02 <hpc> Jafet: im still waiting for Java++, with support for pass-by-spooky-action, and compile-time segfaulting
15:51:04 <Jafet> More than our xml, of course
15:51:08 <Eduard_Munteanu> Cloud... web-scale Agda.
15:51:44 <hpc> Jafet: yeah, the whitespace uses fewer pixels, and will be more efficient
15:51:48 <cmccann> leveraging the power of distributed computing so you can use supercomputing clusters and compile copumpkin's code in less than five days
15:52:36 <Jafet> cmccann: that still leaves the problem of kmett's agda code
15:52:44 <hpc> Jafet: or worse, oleg's code
15:53:15 <danharaj> Compiling the former is assumed to be NP-hard, compiling the latter is known to be EXPTIME complete.
15:53:23 * cmccann figures that in agda oleg would start doing some sort of crazy term-level programming, that actually computes normal everyday values
15:53:28 <Jafet> Can oleg create a term so complicated that even he could not type-check it?
15:54:07 <parcs_> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
15:54:22 <lambdabot> thread killed
15:54:30 <danharaj> :t fmap fmap
15:54:31 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
15:54:34 <danharaj> :t fmap fmap fmap
15:54:34 <hpc> @remember Jafet Can oleg create a term so complicated that even he could not type-check it?
15:54:34 <lambdabot> Done.
15:54:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:54:35 <Saizan> cmccann: oleg considers GADTs esoteric.
15:54:53 <danharaj> :t fmap fmap fmap fmap
15:54:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
15:55:13 * cmccann prefers "ghastly hodgepodge" as a description for complicated GHC extensions
15:55:35 <hpc> GADTs aren't so bad
15:55:57 <hpc> it's just constructors with slightly less polymorphism than they otherwise would have
15:56:03 <parcs_> they're just regular old ADTs, but generalized
15:56:05 <cmccann> GADTs are as bad as you want them to be
15:56:37 <hpc> it doesn't even affect the complexity of compilation
15:56:39 <Saizan> it was kind of mind blowing seeing him do all those contortions in the finally tagless style and conclude that this was a much less spooky way than with those magic gadts
15:57:00 <tomberek> is it possible to have a functor/monad/comonad/etc, but still be able to specialize the data structure for certain types? I keep running into the problem of being unable to specify: "When the elements are in Ix, use this. Or: For Int,Bool, and Char, use this, but for all other cases, use this."
15:57:12 <Saizan> "but you're using the magic typeclasses!" or something like this
15:57:18 <hpc> tomberek: sounds like a type family
15:57:23 <joe6> what am I doing wrong here: http://codepad.org/WVhpdeH0 , error: http://codepad.org/j5uwfuWl
15:57:24 <tomberek> yeah
15:57:31 <joe6> TestUsbUtility.hs:58:4: parse error on input `where'
15:57:53 <joe6> the indent seems good.
15:57:59 <tomberek> hpc: I still end up running into an Ord a creeping around, which I can't specify if I want to declare a Functor
15:58:01 <joe6> what else could I be missing?
15:58:02 <cmccann> you can use GADT syntax for the same data definitions you'd use otherwise, so it's hard to say they're inherently troublesome
15:58:16 <Saizan> hpc: type checking case expressions on gadts is quite harder, in fact they require a signature
15:58:16 <tomberek> hpc: i might be doing it wrong
15:58:19 <cmccann> but as a vehicle from oleg-style type hackery, they're not my favorite approach
15:58:24 <joe6> gotit.
15:58:28 <joe6> do not bother
15:58:31 <joe6> missing a =
15:58:31 <hpc> Saizan: oh, really?
15:58:34 <parcs_> tomberek, ghc HEAD can do that
15:58:53 <Saizan> cmccann: of course we meant the actually indexed ones
15:58:55 <tomberek> parcs_ : I beg your pardon?
15:59:15 <hpc> Saizan: can you give a short example of what you mean? i can't see where the complication is
15:59:34 <parcs_> tomberek, the development branch of ghc can alleviate your problem with constraints and associated types
15:59:56 <cmccann> Saizan, I'm just saying that it's not a binary proposition, GADTs are more esoteric the more esoteric things you do with them
15:59:58 <tomberek> is this some new feature? I know type families are the canonical way to specialize data structures, but i can't get them to work with Functor (I think RMonad is a work-around to a similar issue)
16:00:12 <parcs_> you're not doing anything wrong, it's just not possible in any release of ghc
16:00:32 <Saizan> cmccann: yeah, but that's true of the finally tagless encoding too
16:00:35 <cmccann> aren't they compiler pragmas to specialize instances?
16:00:48 <tomberek> parcs_: so I've been struggling to do something impossible, grrrrrr
16:00:52 <parcs_> tomberek, http://blog.omega-prime.co.uk/?p=127
16:01:10 * cmccann wants constraint kinds now :[ :[ :[
16:01:24 <cmccann> I tried to build a GHC snapshot the other day and it segfaulted during the build :T
16:01:51 <Peaker> dennis_: If you're using Haskell, you're not losing much speed over C, and you're gaining a lot of parallelism, which is far easier in Haskell than in C
16:02:11 * cmccann still thinks concurrency is a better argument for Haskell
16:02:12 <danharaj> GHC makes it not impossible to compile to something that looks like GCC generated assembly.
16:02:14 <Saizan> hpc: normal ADTs don't bring in scope new type equality assumptions when you pattern match on them
16:02:20 <Peaker> dennis_: so "if you're using C, you're losing on parallelism, so you're losing speed"
16:02:51 <cmccann> since concurrency is pretty simple to use in Haskell, whereas concurrency in C, based on empirical observation, is impossible statistically speaking
16:02:56 <Peaker> cmccann: Constraint Kinds sound like a very nice convenience feature, but what do you plan to do with them?
16:03:17 <dennis_> Peaker: I agree with that. Plus Haskell code is far less buggy, kind of a no-brainer really. But it's tough to convince someone who knows only C
16:03:18 <cmccann> Peaker, I don't know yet, but probably a lot of things
16:03:19 <Peaker> cmccann: concurrency in C using cooperative event-based code is not easy, but it's definitely possible
16:03:20 <tomberek> parcs_ " We can use this to solve the well-known problem where lists can be an instance of the Monad type class, but sets cannot. "   Gar, this was my problem!!!
16:03:33 <Peaker> dennis_: Have you heard the "Blub" argument?
16:03:35 <Saizan> hpc: so e.g. data IsBool a where ItIs :: IsBool Bool; foo ItIs = True; can be typed both as foo :: IsBool a -> Bool and as foo :: IsBool a -> a
16:03:37 <dennis_> No
16:03:53 <Peaker> dennis_: http://www.paulgraham.com/avg.html
16:04:06 <monochrom> don't try to convince someone who knows only C
16:04:29 <Peaker> dennis_: you can start reading at "Programmers get very attached.."
16:04:30 <danharaj> When all you know is C everything looks like a seg fault.
16:04:31 <Peaker> monochrom: why not?
16:04:47 <monochrom> too little knowledge to understand any alternative
16:04:49 <cmccann> danharaj, except for the things that look like a buffer overrun exploit
16:05:03 <Peaker> monochrom: convincing may transmit knowledge :)
16:05:04 <danharaj> cmccann: Who said c programmers could spot those? ;)
16:05:21 <hpc> Saizan: oh, i see
16:05:22 <cmccann> danharaj, well, I assume they can see the code on their screen, QED
16:05:43 <monochrom> well, there is also the meta consideration of "why is he/she in such a sad state of knowing only C?"
16:05:46 <danharaj> Seeing and seeing.
16:06:10 <danharaj> monochrom: Maybe they were like "I'm gonna learn a higher level language!" and then tried to learn Java.
16:06:24 <monochrom> if he/she is young, fine, just bad luck, still educatable
16:06:26 <dennis_> Peaker: yes, that is well written. And exactly, it doesn't hurt to do a little Haskell evangelizing
16:06:39 <hpc> danharaj: my only response to people who call java higher level is "oh, how cute"
16:06:57 <monochrom> but beyond a certain age, you have to wonder if it is really because he/she chooses to not know
16:07:05 <dennis_> It's annoying to be called a troll in the Haskell room when I'm trying to spread it though
16:07:12 <Peaker> dennis_: that article is actually Lisp evangelism... Its author confuses the ability to implement any language feature with *having* any language feature, so his Lisp argument is not very strong. But his Blub argument is a nice way to explain the viewpoints
16:07:16 <cmccann> hpc, or calling java "statically typed"
16:07:41 <danharaj> dennis_: No one likes proving people wrong.
16:07:43 <dennis_> Agreed
16:07:48 <hpc> cmccann: it is, but it's weak static, which is akin to not having types at all
16:07:58 <monochrom> someone who knows both C and Java is more open to Haskell than someone who knows only C
16:08:02 <hpc> better than strong dynamic though, where you get type errors, but don't know where they are
16:08:15 <Peaker> dennis_: I think he also misses the notion that it is possible to implement new language features by editing compilers -- he just considers that impractical, I guess.  Though macros are truly impractical for many features found in competing languages to Lisp
16:08:33 <monochrom> I like proving people wrong. including: I like people proving me wrong.
16:08:39 <dennis_> danharaj: most programmers I know seem to like it :)
16:08:55 <Peaker> monochrom: Maybe programming wasn't the focus of their life? Maybe they had bad experience with an alternate programming language, and can be fixed?
16:09:02 <danharaj> Only the ones who are insecure in their opinions ;p
16:09:28 * cmccann wonders how long he should leave the /r/haskell banner as it is
16:09:28 <ian_mi> I like proving people wrong, unless it happens often.
16:09:29 <Eduard_Munteanu> monochrom: hey, I didn't know Java before... actually, I was kinda looking for a higher-level language.
16:10:00 <tomberek> parcs_ : wait, it looks interesting, but you'd still have pretty much the same solution as RMonad, it's cleaner, but unless I'm missing something, it's still not much different.   Is there some reason it's impossible to tell the compiler something like: "Hey, when the elements are Int use this data type, otherwise: if elements are in Ord, use this data type,  otherwise, forall other a, use this default"
16:10:49 <Peaker> tomberek: with overlapping instances, you can sort-of do some of that?
16:11:14 <cmccann> tomberek, if you're just after optimization tweaks, have you looked at GHC's pragmas?
16:11:36 <tomberek> i was going to read more about SPECIALIZE soon, thought I'd ask first
16:12:06 <cmccann> tomberek, I'm not sure if that helps or not, just wondering
16:12:11 <tomberek> Peaker: Yeah, I've played with overlapping, i'll look again
16:12:23 <cmccann> ugh, overlapping instances are Evil
16:12:47 <Peaker> I dislike, too
16:12:51 <danharaj> incoherent instances are evil.
16:12:58 <tomberek> it just seems like this comes up often, where i'd like a general interface, but specialize it for certain types
16:13:02 <aavogt> type classes must be evil
16:13:11 <Peaker> tomberek: type families?
16:13:21 <joe6> @hoogle Word16 -> Word8
16:13:21 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
16:13:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:13:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:13:44 <Peaker> tomberek: I think there's some associative type-family-based containers package that's supposed to map Map Int   to IntMap, or such?
16:13:46 <cmccann> danharaj, no, overlapping isntances are evil. incoherent instances are the writhing, burbling noneuclidean horror from the outer darkness
16:13:57 <Peaker> what are incoherent instances?
16:14:01 <tomberek> Peaker: yeah, i'm familiar, but I run into overlapping data instance declarations
16:14:10 <cmccann> Peaker, like overlapping, except you tell GHC to just pick one if it can't decide
16:14:19 <cmccann> which one it picks depends on things
16:15:08 <aavogt> that's not convincing because at the same level of handwaving, H98 instance selection itself is exactly the same
16:15:15 <tomberek> Peaker: I think the compiler can't really accept overlapping type families because they are 'open'
16:16:11 <Saizan> yeah, defaulting is pretty bad too
16:16:24 <monochrom> Peaker, I am not playing a blame game of whether it is right or wrong to be uninterested in Haskell (or anything). I am considering whether it's worthwhile to try to convince a given person. It may feel very good to say "he/she doesn't focus on programming, that explains why he/she knows only C, it is not his/her fault". but that is no defense. precisely because he/she doesn't focus on programming, he/she is uninterested in g
16:16:24 <monochrom> etting convinced or even just hearing about another language. trying to convince would be a waste of time.
16:16:44 <cmccann> defaulting is a dirty hack that's annoyingly useful
16:16:53 <cmccann> it's pretty obnoxious trying to do things without having it
16:17:14 <Peaker> monochrom: if they are engaging in conversation, then maybe they are open to convincing?
16:17:22 <cmccann> it would be nice to have a more structured approach to what defaulting does :T
16:17:37 <tomberek> I would have thought this would be a common issue, where people would want to specialize their data structure / algorithm. Perhaps unboxed versions for some, Ord version, etc.
16:18:13 <Saizan> anyhow, it seems the problem is that c++ templates has twisted the expectations of a large population of programmers, that will always feel dissatisfied with typeclasses
16:18:17 <cmccann> tomberek, the prefered approach is to do the simple obvious thing and let the compiler take care of it behind you
16:18:22 <Peaker> monochrom: I've got friends who've resisted for a while, and eventually succumbed to learning Haskell and loving it :)
16:18:34 <Saizan> mostly because type classes and type families are meant to retain some sanity
16:18:53 <Peaker> Saizan: What kind of dissatisfaction? templates-on-values?
16:19:16 <monochrom> I don't see a consistency between "programming is not focus" and "engage in programming conversations". perhaps it is not a case of "programming is not a focus" afterall.
16:19:29 <Eduard_Munteanu> If you want to play compile-time tricks, you can use TH>
16:19:29 <cmccann> tomberek, and when there's a concrete case where you really need to tweak things to get better results, you either specialize directly to a monomorphic version, or use compiler pragmas to point GHC in the right direction
16:19:35 <Peaker> Saizan: I don't think TC's+TF's are Templates - power + sanity,  I think they are Templates - power + other-kinds-of-power + sanity
16:19:50 <tomberek> cmccann: True, but sometimes it doesn't. I was hoping there was a way to 'nudge' the compiler in the direction I want to.
16:20:26 <Saizan> Peaker: the kind of opportunistic specialization tomberek is talking about for example "if Int use this instance, if Ord use this other else a third, and also let me define more special cases later"
16:20:32 <cmccann> tomberek, if it's just a matter of hints in the direction of something that a sufficiently smart compiler could hypothetically figure out on its own, that's what pragmas are for
16:20:54 <Saizan> Peaker: i've not said they were
16:20:56 * cmccann doesn't think C++ templates really compare directly to much of anything
16:21:10 <Peaker> Saizan: well, it's possible for concrete types as in Templates, but maybe not for differing constrained types
16:22:03 <Guest33272> dcoutts, i had been trying to build ghc with -fPIC set earlier today
16:22:13 <Guest33272> (apparently left scooty-puff logged in at work)
16:22:16 <cmccann> tomberek, just keep in mind that sometimes the reason the compiler doesn't optimize something for you is that it's not actually a valid optimization :]
16:22:17 <Peaker> cmccann: I think unspecialized templates compare directly to universal quantification (with implicit superclass TC constraints due to non-instantiation of unused methods).. With specialization, they are somewhat like type families
16:22:42 <Guest33272> and now getting other symbols undefed - "stg_ap_2_upd_info" undefined symbol
16:24:32 <Guest33272> i'm assuming the runtime wasn't build with -fPIC - don't sound like haskell method names
16:24:47 <dcoutts> those will be things in the rts
16:25:20 <tomberek> sorry, internet sucks over here
16:25:29 <dcoutts> Guest33272: how/where did you set -fPIC in the ghc mk/build.mk ?
16:25:33 <Guest33272> currently in the mk/build.mk, +='ing SRC_CC_OPTS, SRC_HC_OPTS, GhcHcOpts, GhcLibHcOpts, and GhcRtsCcOpts with -fPIC
16:25:57 <Guest33272> that was post configure though
16:26:01 <Guest33272> pre make
16:26:05 <dcoutts> that's ok
16:26:12 <Guest33272> k
16:27:38 * cmccann wonders why he's getting a segfault trying to build GHC :[
16:27:44 <dcoutts> Guest33272: hmm, I'm not sure where to go from there. I think best thing is to email the ghc devel mailing list
16:28:05 <dcoutts> You only need it on GhcLibHcOpts and GhcRtsCcOpts I think, but In theory -fPIC should be benign in the other locations
16:28:22 <Guest33272> k
16:28:44 <Guest33272> i'll post here any results (though probably take a couple of days)
16:28:51 <terry> anyone know of a quick fix for all the link warnings I'm getting on OS X Lion?
16:29:18 <dcoutts> Guest33272: so while enquiring about that, the next best thing is to try the approach were you end up with one plugin.so that depends on .so libs of all the other Haskell package (rts, base, etc)
16:29:55 <tomberek> cmccann: my particular situation:  I'm using STRef, but I found an STURef (from ArrayRef, fixed some of it to compile on current ghc) and it seems to work much better than STRef, but whenever I use STURef, i have a (Unboxed a) constraint that floats around, preventing a Functor instance.
16:30:55 <Guest33272> that being via --enable-shared or setting shared = True in .cabal/config - last time i tried this, my test harness (which actually gives error messages, compared to the framework its for..)
16:31:12 <Guest33272> gave undefined symbol errors - i'll try it again now to see if was some other mistake
16:31:49 <dcoutts> Guest33272: you need to link your plugin.so against the ghc rts, this doesn't happen automatically
16:31:56 <Guest33272> ok
16:32:01 <cmccann> tomberek, yeah, I'm not sure what the best approach there would be :T
16:32:05 <Guest33272> just -lHSrts, right?
16:32:39 <dcoutts> Guest33272: see this rather old blog post for example http://www.well-typed.com/blog/30
16:32:43 <Guest33272> k
16:33:00 <dcoutts> Guest33272: it's also covered in the ghc user guide
16:33:00 <tomberek> cmccann: what i was thinking was just to have a data type with two constructors, and then have any functor usage always default to creating the 'unspecial' version, this isn't ideal because I'd like to to be able to create the special one when possible
16:35:58 <tomberek> .
16:42:26 <cmccann> tomberek, yeah, I got nothing, sorry. :T
16:43:53 <tomberek> cmccann: ok, at least I can stop thinking that I must be missing something simple, it sounds like this sort of thing is a well-known issue
16:43:58 <tomberek> thanks though
16:44:35 <tomberek> i'll look into the constraint kinds, looks cool
16:44:56 <cmccann> speaking of which
16:45:04 <terry> tomberek: I've only seen one line of your problem description, but have you looked at type families and data families?
16:45:23 <cmccann> anyone have any idea how to figure out why I'm getting segfaults trying to build a GHC snapshot? :[
16:45:42 <kmc> gdb any use?
16:45:46 <cmccann> it's just falling over, consistently at the same file, and I can't figure out what might be the issue at all
16:46:12 <tomberek> terry: affirm!
16:46:51 <Guest33272> dcoutts, using that guide (let me check what i've done, but just incase its an easy answer), i get: /usr/lib/ghc-7.0.2/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc7.0.2.so: undefined symbol: cosh
16:46:54 <cmccann> kmc, honestly I'm not even sure how to try that. it's been ages since I've done anything not utterly trivial with gdb :T
16:47:24 <Guest33272> this is the command in the Makefile: $(HSC) $(HSCFLAGS) --make -no-hs-main -dynamic -shared -fPIC -o $@ $(HSMAIN) $(CSRCS) -lHSrts -optl-Wl,-rpath,/usr/lib/ghc-7.0.2/
16:47:40 <cmccann> especially since if I understand the process correctly it's an intermediate ghc build that's segfaulting on me
16:48:27 <dcoutts> Guest33272: take a look at ghc-pkg describe rts, you'll probably find it's linking to a number of other static libs besides HSrts, probably including libm
16:48:48 <Guest33272> ok
16:48:50 <Eduard_Munteanu> cmccann: try to gdb --args the exact command that fails?
16:49:23 <cmccann> Eduard_Munteanu, ok
16:49:55 <Eduard_Munteanu> Though to be fair, it might not have debugging symbols.
16:50:47 <cmccann> dealing with segfaults from anything in Haskell is not something I really know how to cope with, heh
16:50:50 <tomberek> cmccann, terry: for a simpler example. Take a look at the adaptive-containers package. Can Data.Adaptive.List be made into a Functor? If it could, I would have though Don would have put that in there already.
16:52:04 <Guest33272> SUCCESS!
16:52:09 <Guest33272> dcoutts, thank you so much
16:52:20 <tomberek> so a 'data family' solution does allow adaptive data types, but they won't be Functors or Monads.
16:52:20 <Guest33272> ended up adding: -lm -lrt -ldl -lffi
16:52:41 <tomberek> congrats Guest33272
16:53:42 <dcoutts> Guest33272: great
16:56:29 <dainanaki> how can a get a FunPtr of a native Haskell function to pass into C-land?
16:57:21 <kmc> foreign import "wrapper"
16:57:49 <monochrom> wait, import? not export?
16:58:03 <mauke> @where ffi
16:58:03 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:58:03 <kmc> see e.g. slide 10 of http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
16:58:04 <kmc> yes
16:58:11 <kmc> both "wrapper" and "dynamic" are import
16:58:13 <kmc> dynamic goes the other way
16:59:00 <kmc> it's nice that Haskell functions are first-class even in C, where functions normally aren't
16:59:14 <kmc> that is, you can close over arbitrary free variables and get a single function pointer representing that closure
16:59:17 <copumpkin> monochrom: it's pretty awesome
16:59:25 <copumpkin> I feel that all that stuff should live in a typeclass thugh
16:59:31 <copumpkin> and not in some language construct
16:59:37 <dainanaki> me too
16:59:49 <dainanaki> but I'll take what I can get.
16:59:52 <copumpkin> it wouldn't be hard to put it into one
16:59:56 <Peaker> kmc: Yeah, I wondered how the GLUT bindings worked (given that they don't pass any (void*)...) and found out about that
16:59:57 <copumpkin> but I really can't be bothered
17:01:05 <dainanaki> being able to call ObjC without any new language constructs is looking more and more doable.
17:01:33 <dainanaki> even making ObjC objects composed of haskell functions as their methods :)
17:01:34 <cmccann> Eduard_Munteanu, well, I ran it in gdb
17:01:35 <kmc> sweet
17:01:45 <cmccann> Eduard_Munteanu, the stack trace I got was: #0  0x08056c73 in main ()
17:02:06 <copumpkin> dainanaki: yeah, it definitely is
17:02:14 <copumpkin> dainanaki: it's just not pleasant right now
17:02:22 <dainanaki> Yes, well I'm fixing that currently.
17:02:28 <copumpkin> oh?
17:02:29 <kmc> dainanaki, you have to manage memory on those FunPtrs yourself, though
17:02:35 <kmc> also it won't work on iOS ;P
17:02:45 <kmc> or other authoritarian platforms
17:02:48 <dainanaki> Right. Well, I'd be happy to have Cocoa apps in Haskell anyways.
17:02:49 * copumpkin coughs
17:03:34 <dainanaki> copumpkin: I've got an almost complete binding to the Obj-C runtime and some preliminary code generators for AppKit.
17:03:48 <copumpkin> fun :) I experimented with various approaches to objc a while ago
17:03:54 <Eduard_Munteanu> cmccann: hrm, not very informative, but it looks like an RTS issue?
17:04:03 <Eduard_Munteanu> Uh, nevermind.
17:04:08 <Eduard_Munteanu> You probably can't distinguish.
17:04:25 <cmccann> Eduard_Munteanu, I really have no idea :[ I'm trying to figure out if there's any way to get useful info from gdb
17:04:48 <dainanaki> The only issue is that Lion took out some useful metadata out of their BridgeSupport tools that would have helped to make more accurate initial bindings. :(
17:04:57 <copumpkin> like what?
17:05:04 <copumpkin> why do you need BridgeSupport?
17:05:20 <Eduard_Munteanu> cmccann: is that a binary GHC or an intermediate? You could recompile with debugging info in the latter case.
17:07:35 <cmccann> Eduard_Munteanu, inplace/lib/ghc-stage1
17:07:46 <cmccann> so I guess recompile with debugging info is the way to go
17:08:02 <dainanaki> copumpkin: BridgeSupport used to give full type information for methods and their parameters, (i.e. more than just that a parameter is an object, it would give info like that it was an NSObject for example), but the newer BridgeSupport tools only give rudimentary object type info.
17:08:34 <copumpkin> dainanaki: the objc metadata still contains all that inf
17:08:35 <copumpkin> info
17:08:47 <dankna> wait
17:08:49 <dankna> what's the context here
17:08:55 <dankna> BridgeSupport does have more info than the metadata
17:08:59 <dankna> in particular it has info for the C types
17:09:06 <dankna> fortunately, my direct-cocoa project scrapes BridgeSupport
17:09:19 <dainanaki> dankna, you have a cocoa project too?
17:09:21 <dankna> it doesn't yet scrape the metadata because I still need the actual bridge to do that
17:09:22 <dankna> yes.
17:09:27 <dankna> one sec, let me make sure it's somewhere public
17:09:31 <dainanaki> heh, let our powers combine!
17:09:32 <copumpkin> oh I've never even used bridgesupport
17:09:38 <dankna> I AM CAPTAIN PLANET
17:09:43 <copumpkin> I just mean the shit they encode into the actual class structure
17:10:01 <dainanaki> yes, but it doesn't give object types, only c types.
17:10:13 <dankna> yeah.  so you need both.
17:10:42 <copumpkin> I've seen lots of juicy object types in it
17:10:51 <copumpkin> most of the iphone tweak community relies on that stuff almost exclusively
17:10:54 <dankna> http://dankna.com/software/darcs/direct-cocoa/
17:10:59 <copumpkin> class-dump(-z) etc.
17:11:20 <dankna> I'm a little preoccupied right now, but feel free to talk to me here, use lambdabot's @tell feature to leave me messages, or email or gchat me at dankna@gmail.com to collaborate on this
17:11:54 <dainanaki> sure. I'll take a look at yours and see where we've got overlap and whatnot.
17:11:59 <dankna> yeah, please :)
17:17:58 <dainanaki> can darcs be built with  7.2.1?
17:49:32 <c_wraith> I think I'm writing lisp in haskell.  This would probably be easier if I knew lisp.
17:49:39 <shevy> man this channel is crowded
17:49:55 <c_wraith> most people don't talk. :)
17:50:01 <shevy> :(
17:50:16 <dainanaki> enough people do.
17:50:19 <tomberek> they watch and listen, ready to pounce
17:50:24 <c_wraith> Well.  That still leaves room for a good number of regularly active people.
17:50:29 <dainanaki> we just don't say things that don't deserve saying in the first place :)
17:50:56 <cmccann> c_wraith, just use more parentheses, I think that's the important bit
17:51:53 <c_wraith> I'm actually writing code that simultaneously deals with execution at compile-time (Template Haskell), run-time execution, and compilation at run-time (GHC API via Hint).
17:52:42 <c_wraith> The rules at each stage are different.  One bit of code is going to have to be polymorphic at compile-time and monomorphic during run-time compilation.  Fortunately, that's actually the way the type system works. :)
17:52:58 <cmccann> c_wraith, haha nice
17:53:07 <dainanaki> at least you aren't going upstream.
17:53:15 <Peaker> what does it mean for something to be "polymorphic at runtime"?
17:53:29 <dainanaki> it means it's probably written in ruby.
17:53:37 <Jafet> Data.Dynamic
17:53:38 <c_wraith> Peaker: I actually said "at run-time compilation".  :P
17:53:57 <Peaker> Existential types give you "runtime polymorphism" then, I guess
17:54:16 <c_wraith> This won't involve an existential type.  Just a monomorphic, but unknown, type.
17:55:20 <c_wraith> ...  Which is only possible via Typeable
17:55:31 <c_wraith> So it's disturbingly close to Data.Dynamic, actually
18:04:39 <kmc> does anyone have a worked example of using the 'speculation' library? edwardk?
18:05:02 <edwardk> i probably have something around here
18:05:07 <edwardk> what are you looking for?
18:05:18 <kmc> just something slightly non-trivial
18:05:27 <Peaker> c_wraith: I'd say any existential type is "runtime polymorphism"
18:05:29 <kmc> i understand the basics of how to use the library, but i'm looking for a compelling use case
18:05:33 <edwardk> i did some huffman decoding tests and i had some code in luthor for doing parallel lexing
18:05:39 <kmc> cool
18:05:47 <Peaker> c_wraith: or do you want the unsafeCoerce/cast part of the functionality?
18:06:00 <kmc> luthor? don't see it on hackage / google
18:06:12 <edwardk> i never hackaged it coz i never finished it
18:06:14 <c_wraith> Peaker: well, hint (and the ghc api in general) uses the unsafeCoerce stuff.
18:06:19 <edwardk> luthor is a lex clone
18:06:23 <kmc> hahaha
18:06:26 <kmc> nice naming
18:06:28 <c_wraith> Peaker: hint uses Typeable to manage it, to some extent
18:06:41 <Eduard_Munteanu> lex / flex, the lexer?
18:06:52 <edwardk> philippa popped up with the name
18:06:58 <edwardk> yeah
18:07:07 <edwardk> basically its alex as a quasiquoter more or less
18:08:11 <c_wraith> heh.  fmap ($ foo)
18:08:27 <c_wraith> I think I'll just use monadic binding.  Easier to read. :)
18:08:56 <kmc> where do you speculate in Huffman decoding? you guess the boundaries between symbols?
18:09:07 <parcs_> @src flip
18:09:07 <lambdabot> flip f x y = f y x
18:09:41 <parcs_> :t let flip f x = fmap ($ x) f in flip
18:09:42 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:10:42 <edwardk> speculate on the alignment of the tree basically. its also pretty easy to prove that the guess should always be the root of the tree
18:12:10 <Eduard_Munteanu> edwardk: do you have it online somewhere?
18:12:14 <Eduard_Munteanu> The Huffman decoder.
18:12:48 <edwardk> speculating lexing is pretty easy as well, you can view a lexer (or huffman decoding) as a markov process transitioning from lexer state to lexer state, then speculate on the highest probability state to be in given a limited amount of look-behind
18:12:59 <edwardk> it was only 30-40 lines of stuff
18:15:05 <edwardk> Eduard_Munteanu: if you look at the microsoft research paper where they introduced the speculation approach i used you can find c# code for doing speculative huffman decoding
18:15:38 <cmccann> Eduard_Munteanu, so, I got rid of the segfault after recompiling with debugging symbols in the stage1 compiler
18:16:35 <Eduard_Munteanu> cmccann: hm, that bug is playing hard to get... did you also disable optimizations?
18:17:20 <cmccann> Eduard_Munteanu, yeah, I also switched it to the "quick" build since I was impatient
18:17:21 <Eduard_Munteanu> cmccann: anyway, you should probably report the issue (maybe #ghc?).
18:17:26 <cmccann> but it worked so I'm tempted to just leave it be
18:17:32 <cmccann> this is just for playing around with anyhow
18:17:53 * Eduard_Munteanu doesn't know much about GHC itself.
18:18:29 <c_wraith> I *really* wish GHC could derive Typeable for type with kind (* -> *) -> * -> *
18:18:47 <c_wraith> so annoying writing the same instance over and over.
18:19:02 <c_wraith> especially since the code for doing so is going to break in the future.
18:19:17 <kmc> it's more than annoying; writing your own instances for Typeable is unsafe
18:19:17 <c_wraith> So then it'll be copy & paste macro'd cpp code!
18:19:39 <c_wraith> well, I'm doing it as well as possible, with NOINLINE pragmas.
18:19:52 <c_wraith> on the plus side, the change to typeable will make it pure.
18:20:04 <c_wraith> on the minus side...  CPP for compatibility with both versions.  lovely
18:20:13 <Peaker> There's the kind polymorphism thing that's supposed to remove the need for TypeableN?
18:20:13 <cmccann> Eduard_Munteanu, I don't know, this is so far from any sort of actual release version and there could be something weird about my system, not sure if it's even a big deal
18:20:19 <Peaker> (and not there yet)
18:20:22 <Samy> @seen edwardk
18:20:22 <lambdabot> Unknown command, try @list
18:20:22 <preflex>  edwardk was last seen on #haskell 5 minutes and 17 seconds ago, saying: Eduard_Munteanu: if you look at the microsoft research paper where they introduced the speculation approach i used you can find c# code for doing speculative huffman decoding
18:20:30 <cmccann> and bugs that disappear when you build in debug mode aren't something I want to deal with :T
18:23:31 <Eduard_Munteanu> Aye, they're mean.
18:24:02 <Eduard_Munteanu> (and somewhat common in C land)
18:24:35 <kmc> ooh, i bet i could speculate x86 disassembly :D
18:24:49 <cmccann> basically I can't provide much useful information about the segfault, I have no idea how to track down the bug myself, and it's not in any way something that causes me problems
18:24:52 <kmc> /perfect/
18:25:08 <cmccann> not a very useful bug report at that point :P
18:25:50 <copumpkin> kmc?
18:26:01 <Guest33272> i am trying to cabalize a project from earlier
18:26:08 <kmc> copumpkin?
18:26:14 * Eduard_Munteanu thinks about speculating on Bitcoins :P
18:26:16 <copumpkin> speculate x86 disassebly?
18:26:20 <Guest33272> earlier, i was building a shared library to be called from c code
18:26:40 <kmc> copumpkin, yeah, using edwardk's 'speculation' package
18:26:48 <copumpkin> hm
18:26:50 <kmc> just like the lexing example; you make some guess about where instruction boundaries are
18:26:58 <copumpkin> I see
18:27:02 <kmc> perhaps you guess that any non-zero byte after a zero byte starts a new instruction
18:27:05 <kmc> (yay little endian)
18:27:14 <kmc> that should be a good guess
18:27:22 <Guest33272> the ghc --make ... version works, the cabal version does not, complains about: undefined symbol `__stginit_gtagsjszm0zi1_Gtags_ - the package name is gtagsjs, its version is 0.1, and it contains a Gtags module
18:27:24 <edwardk> yeah, go back 30-60 bytes, and walk forward looking for likely instruction boundaries.
18:27:29 <Eduard_Munteanu> cmccann: it might be easier to reproduce if you don't disable optimizations
18:28:02 <kmc> i will be really happy if this works out; it'd be an example of taking someone else's hard work on a C library, importing it to Haskell, and then making it run in parallel safely
18:28:12 <edwardk> *nods*
18:29:00 <kmc> edwardk, so you'd just split the input arbitrarily, and then look for instruction boundaries?
18:29:18 <sam5> I have a question about coding something in haskell
18:29:23 <edwardk> thats one way
18:29:33 <sam5> I want to find the smallest power of two greater than an inputer number N
18:29:35 <Eduard_Munteanu> I don't think you can always find the boundaries.
18:29:40 <sam5> I defined it as
18:29:48 <sam5> getR n = head [x | x <- (iterate (*2) 1), x > n]
18:30:08 <sam5> which works but I want to find out what power of two this actually is
18:30:10 <kmc> looks all right sam5
18:30:11 <Eduard_Munteanu> But I guess you can afford to waste some CPU power as long as its threaded.
18:30:22 <Eduard_Munteanu> *potentially waste
18:30:23 <Peaker> sam5: nitpick: you can avoid the () around the iterate call.
18:30:37 <sam5> is there a way to get 'i' in 2^i ??
18:30:44 <kmc> head [x | x <- [1..], 2^x > n]
18:30:44 <Peaker> sam5: you can zip the iterate with [0..]
18:30:53 <kmc> i'd use 'find' instead of head + list comprehension, though
18:31:00 <Peaker> that's nicer, but potentially less efficient
18:31:00 <edwardk> http://research.microsoft.com/pubs/118795/pldi026-vaswani.pdf look at the code in figure 4.
18:31:14 <incluye> or, you know, log2(x)
18:31:21 <Peaker> @hoogle log2
18:31:21 <lambdabot> No results found
18:31:26 <incluye> or log(x)/log(2)
18:31:26 <sam5> I realize that I can do log... but it seems inefficient
18:31:28 <kmc> > let getR n = find ((> n) . (2^)) [0..] in gitR 59
18:31:29 <lambdabot>   Not in scope: `gitR'
18:31:29 <incluye> if you want to get fancy
18:31:29 <Axman6> > logBase 2 7
18:31:29 <lambdabot>   2.807354922057604
18:31:33 <kmc> > let getR n = find ((> n) . (2^)) [0..] in getR 59
18:31:34 <lambdabot>   Just 6
18:31:41 <kmc> sam5, inefficient? did you profile it?
18:31:43 <Peaker> I avoid floating stuff when possible
18:32:06 <Peaker> Floating point is a dark corner of computing
18:32:19 <kmc> yeah, that's a *good* reason to avoid Haskell's 'log'
18:32:25 <kmc> of course somebody could write a good integer log
18:32:32 <kmc> i bet it's buried in some package on hackage
18:32:43 <kmc> it could even use the FPU hardware when it's guaranteed to give a precise answer
18:32:52 <sam5> so what does find do?
18:32:55 <kmc> @src find
18:32:55 <lambdabot> find p          = listToMaybe . filter p
18:33:06 <sam5> is there no other way than using log to find i in 2^i?
18:33:15 <kmc> sam5, i showed you above...
18:33:30 <kmc> > let getR n = find ((> n) . (2^)) [0..] in getR 67
18:33:32 <lambdabot>   Just 7
18:33:51 <kmc> ¬´find p xs¬ª will return the first element of xs which satisfies p, wrapped in "Just", or return Nothing if there is no such element
18:33:57 <kmc> > find (> 19) [0..]
18:33:57 <lambdabot>   Just 20
18:34:02 <kmc> > find (< 0) [1..100]
18:34:02 <copumpkin> I doubt that would ever return Nothing
18:34:02 <lambdabot>   Nothing
18:34:06 <copumpkin> :O
18:34:14 <copumpkin> :)
18:34:28 <tgeeky> hey, agda has this: open import Data.Nat.Show renaming (show to showNat)
18:34:32 <tgeeky> haskell does not, correct?
18:34:39 <kmc> yeah :/
18:34:46 <tgeeky> awh :(
18:35:02 <Eduard_Munteanu> How about a bitwise ops approach?
18:35:22 <Eduard_Munteanu> Those should be faster than exponentiation/multiplication.
18:35:35 <kmc> yeah, for machine integers you can pick your favorite algorithm from Hacker's Delight and implement that
18:36:09 <kmc> anyway i don't know the context here, of whether sam5 is looking for simplicity or performance
18:36:19 <kmc> without profiling results i'd hesitate to do anything fancy
18:36:26 <Veinor> yet another style question
18:36:36 <Eduard_Munteanu> Yeah, especially if it's a small part in a bigger program.
18:36:36 <kmc> for machine integers, even the naive search is checking 64 numbers only...
18:36:44 <Veinor> i'm writing a function that does some stuff with randomness, and so as a result it has a RandomGen g => g parameter
18:36:52 <sam5> hm... but if you use find you still only get one of the answer
18:36:59 <sam5> for instance if n = 7
18:37:02 <Veinor> i also have a variation that uses getStdRandom and so uses the IO monad
18:37:06 <Veinor> should i call them foo and fooIO?
18:37:11 <sam5> i want to find i=3 and r=8
18:37:18 <kmc> Veinor, seems all right to me
18:37:23 <sam5> is there a way to get all of two at the same time?
18:37:55 <Eduard_Munteanu> That looks a bit like Hungarian notation, but I guess it's ok given the context.
18:38:27 <kmc> > let getR n = listToMaybe [ (i, v) | i <- [0..], let v = 2^i, v > n ] in getR 67
18:38:28 <lambdabot>   Just (7,128)
18:38:31 <kmc> sam5, ^^^
18:38:41 <Veinor> i've got... three versions, i guess
18:38:54 <kmc> it's probably okay to use 'head' instead of 'listToMaybe' because you know there is an answer
18:38:54 <sam5> oh right!! i was forgeting tuples
18:38:57 <Veinor> one for IO, one for System.Random, and one for Control.Monad.Random
18:38:57 <kmc> but it's best to avoid in general
18:39:20 <sam5> thanks kmc and everyone!
18:39:35 <Veinor> oh right, markovM
18:39:45 <Eduard_Munteanu> tgeeky: you can do a qualified import and write an alias
18:40:22 <tgeeky> Eduard_Munteanu: but that doesn't take the original one out of scope, right?
18:40:46 <kmc> > let getR n = find ((> n) . snd) (iterate (succ *** (*2)) (0,1)) in getR 67
18:40:48 <lambdabot>   Just (7,128)
18:41:39 <Eduard_Munteanu> tgeeky: I'm not sure I understand... what I'm suggesting is...
18:42:08 <Eduard_Munteanu> import Foo hiding (foo)
18:42:18 <Eduard_Munteanu> import qualified Foo as F
18:42:20 <Eduard_Munteanu> bar = foo
18:42:27 <Eduard_Munteanu> erm... bar = F.foo
18:42:35 <kmc> edwardk left :/
18:42:44 <kmc> i was going to ask him where "30-60 bytes" came from
18:42:46 <tgeeky> Eduard_Munteanu: ok, I did forget about hiding.
18:43:00 <tgeeky> Eduard_Munteanu: but still, you have F.* in scope, but I guess that can be fine
18:43:00 <kmc> #define fooF F.foo -- ;)
18:43:18 <tgeeky> I'm talking about doing this for virtually everything in the prelude
18:43:35 <Eduard_Munteanu> Hm, that sounds tricky.
18:43:38 <tgeeky> so it might be unweildy to do it this way, but as long as it's possible
18:43:50 <Eduard_Munteanu> How about looking for an alternate Prelude then?
18:43:57 <tgeeky> Eduard_Munteanu: I'm writing one :O
18:44:01 <Eduard_Munteanu> Ah :)
18:44:24 <tgeeky> for reasons that are somewhat arbitrary, I'm disallowing classes that start with the letter A :O (so Applicative, Alternative)
18:44:39 <Eduard_Munteanu> In that case you can use NoImplicitPrelude and import it qualified.
18:44:48 <tgeeky> yeah, I forgot about hiding.
18:45:04 <tgeeky> This will cause huge import lists, but that's fine - I will write something in partial isomorphisms to compactify it
18:45:44 <cmccann> avoiding 'a'? awfully awkward...
18:46:27 <Eduard_Munteanu> kmc: I suppose the larger the lookbehind, the more chances are you can pick instructions that tell you about the boundaries. Like all-zeroed memory, nops etc.
18:46:29 <tgeeky> cmccann: actually, avoiding everything except [d-r] excluding o
18:46:40 <kmc> yeah
18:46:47 <cmccann> tgeeky, I'm curious what the motivation for this is
18:47:26 <tgeeky> cmccann: something I'm calling "letterate programming" - defining an initial string as an alphabet, expanding that (using wordlists) to a dictionary, and considering all of those words special
18:47:36 <kmc> actually i think the biggest x86 instruction is 17 bytes or so
18:47:41 <augur> koninkje_away!
18:48:02 <kmc> biggest valid
18:48:17 <kmc> but there are some syntactically valid instructions which can't be executed that are longer
18:48:26 <Veinor> hm, i just realized
18:48:27 <kmc> but they should be so rare to encounter that we can ignore them for the purpose of speculation :)
18:48:28 <Eduard_Munteanu> "An instruction can be between one and 15 bytes in length."
18:48:37 <kmc> http://coding.derkeiler.com/Archive/Assembler/comp.lang.asm.x86/2005-01/0069.html says 15 or 13
18:48:38 <kmc> *shrug*
18:48:41 <Eduard_Munteanu> (just looked in the AMD64 specs)
18:48:45 <kmc> http://www.cs.umd.edu/~meesh/cmsc411/website/projects/blunck/x86.html says 17
18:48:46 <kmc> ah
18:49:09 <cmccann> tgeeky, somehow I'm more confused every time you explain further :P
18:49:17 <Veinor> is there some way to have anybody who imports my module automatically get the MonadRandom instance for IO?
18:49:20 <tgeeky> cmccann: I've never explained this before
18:49:27 <kmc> move 32-bit immediate to memory indexed by base plus scaled index plus 32-bit offset
18:49:32 <kmc> put that in RISC's pipe and smoke it...
18:49:39 <Veinor> because otherwise they'll have to manually import Control.Monad.Random.Class or whatever
18:49:56 <tgeeky> cmccann: the goal is to statically generate every possible ~ N character parse of a file
18:50:15 <tgeeky> cmccann: for a fixed size N
18:51:01 <cmccann> tgeeky, I'm still confused about what the purpose of this is :T
18:51:07 <Eduard_Munteanu> kmc: hm, there's no 17 on that page
18:51:13 <tgeeky> cmccann: purpose? I didn't say there was a purpose :O
18:51:21 <kmc> it's spelled out, Eduard_Munteanu
18:51:25 <Eduard_Munteanu> Oh, heh.
18:51:28 <Eduard_Munteanu> seventeen
18:51:29 <cmccann> tgeeky, ok that works then :D
18:51:46 <Eduard_Munteanu> For emphasis, I guess.
18:51:50 <tgeeky> cmccann: it's an experiment. To see if it is congitively helpful to know, in advance, every possible parse for purposes of autocompletion
18:52:11 <kmc> so i wonder if i'm supposed to recursively speculatively divide the whole thing
18:52:14 <kmc> or only to a fixed depth
18:52:41 <Eduard_Munteanu> That sounds like a question DPH people are asking.
18:53:03 <kmc> btw has anyone here played with DPH in GHC 7.2?
18:53:11 <kmc> i hear it's become more working or something
18:53:14 <kmc> but i haven't heard much about it
18:53:15 <tgeeky> kmc: not yet, that's a few down on my list
18:53:25 <tgeeky> kmc: a good place to start probably is simonmar's paper
18:53:51 * cmccann is waiting for DPH to upgrade from the standard parallel postulate to the hyperbolic version
18:54:24 <Eduard_Munteanu> There are some videos (not sure how uptodate) on youtube of SPJ explaining DPH.
18:55:40 <cmccann> tgeeky, it's an interesting idea at least, I'll give you that :P have fun with your restricted alphabet prelude.
18:55:42 <tgeeky> kmc: actually, it appears the paper was updated... today
18:55:49 <kmc> haha nice
18:56:02 <tgeeky> http://community.haskell.org/~simonmar/par-tutorial.pdf
18:56:35 <tgeeky> cmccann: well, it's not restricted in that it's not possible to use things outside of the initial alphabet
18:57:16 <tgeeky> cmccann: it's that I desire to rename things to get them inside a very small dictionary (say, 1/100th of a large scrabble dictionary)
18:57:35 <cmccann> hm, ok
18:58:06 <tgeeky> cmccann: and I also want to exclude glyphs that are arbitrary (categorical examples which use a,b,c as variables), as well as those which are confusing when you take into account using unicode, etc (o, 0, (unicode circle))
18:58:53 <tgeeky> cmccann: that kind of thing is already common, though it's font designers who tackle it
19:00:01 <cmccann> tgeeky, well, let me know how it works out, I'm curious now :]
19:00:04 <tgeeky> cmccann: the end result really (this is sneaky) is to allow rep-letters for using unicode,blackboard bold letters, etc
19:00:28 <tgeeky> cmccann: so 'd' is the letter d, 'dd' might be partial derivative, 'ddd' might be some other greek letter D or whatever
19:00:51 <tgeeky> cmccann: I'll be sure to blog-post it here and on reddit, so you'll see it
19:01:17 <tgeeky> cmccann: i've written the easy 3 of 7 introductory blog posts
19:01:32 <tgeeky> cmccann: but am publishing all of them at once. <end channel spam>
19:01:37 <cmccann> heh, ok
19:02:35 <tgeeky> kmc: I think it's the +RTS -s output that's new in 7.2
19:02:54 <tgeeky> kmc: though it looked different in the first paper, so I'm curious to see what actually made it in.
19:04:20 <Guest33272> anyone often encounter: /usr/bin/ld: dist/build/Gtagsjs.dyn_o: relocation R_386_GOTOFF against undefined symbol `__stginit_gtagsjszm0zi1_Gtags_' can not be used when making a shared object
19:04:39 <copumpkin> GOTOFF
19:04:42 <copumpkin> that's a good relocation
19:04:43 <Guest33272> this is doing nothing special - the cabal is really simple, the configure is just "cabal configure"
19:04:51 * copumpkin applies GOTOFF to everything
19:05:09 * tgeeky is not sure of GOTO FF or GOT OFF
19:05:31 <copumpkin> probably GOT OFF(SET)
19:05:37 <kmc> GOT offset
19:05:38 <kmc> yeah
19:05:46 <Eduard_Munteanu> Global something table offset I guess.
19:05:49 <copumpkin> still, a good name
19:06:02 <copumpkin> global offset table :P
19:06:12 <copumpkin> an offset into such a thing
19:06:14 <kmc> my second google hit for "global offset table" is "How to hijack the Global Offset Table with pointers for root shells"
19:06:24 <copumpkin> yeehaw
19:06:28 <cmccann> sounds fun
19:06:45 <kmc> http://www.iecc.com/linker/linker10.html talks about the GOT and PLT
19:07:41 <kmc> cmccann, yeah, if you have a controlled memory write, the GOT and PLT are attractive targets
19:07:49 <Guest33272> how do you know which module is the root module for hs_add_root?
19:08:01 <kmc> maybe there are no useful static variables, and you can't guess the stack or function pointers in the heap
19:08:09 <kmc> and you can't write to .text because of W^X or something
19:08:23 <Guest33272> right now the root function is __stginit_Gtagsjs(void);, but it seems to think it should be something else (i guess?)
19:08:29 <monochrom> when in doubt, hs_add_root every module
19:08:33 <Guest33272> k
19:08:44 <Guest33272> really?
19:09:24 <Guest33272> (the error is during linking, so i would thinking adding fewer would give it a more likely chance of passing the link step, though possiblye failing at runtime)
19:10:16 <Guest33272> and i tried commenting out the hs_add_root call the the associated __stginit prototype declaration
19:11:05 <stribor> > "Hello Stribor"
19:11:06 <lambdabot>   "Hello Stribor"
19:11:16 <monochrom> normally, you hs_add_root module X if you use something from X in your C code, and that's sufficient
19:11:27 <Eduard_Munteanu> @vixen Say hi to stribor
19:11:27 <lambdabot> how're you?
19:11:43 <Guest33272> k
19:11:46 <stribor> > I am wonderfull...:)
19:11:46 <lambdabot>   <no location info>: parse error on input `)'
19:12:08 <monochrom> if X depends on Y, hs_add_module and friends will figure it out since you already hs_add_root X
19:12:35 <tgeeky> cmccann: btw, I wouldn't have thought any of this 'letterate' BS is of even possible (no less of any value to anyone), but I realized several parts of how to implement it are in Richard Bird's functional pearl book
19:14:28 * cmccann hasn't actually read that... :T
19:14:56 <tgeeky> probably the best book about haskell I've read
19:15:03 <tgeeky> so best of 4 :O
19:16:02 * cmccann doesn't tend to read many books, at least not in a coherent way
19:16:37 <monochrom> s/hs_add_module/hs_add_root/
19:19:30 <Guest33272> o i give up.. just nuked .ghc and .cabal, reinstall all dependents, and still get /usr/bin/ld: dist/build/Gtagsjs.dyn_o: relocation R_386_GOTOFF against undefined symbol `__stginit_gtagsjszm0zi1_Gtags_' can not be used when making a shared object
19:19:58 <Guest33272> the cabal file contains just enough, built with cabal clean && cabal configure && cabal build
19:20:01 <Guest33272> and no luck
19:20:01 <tgeeky> Guest33272: turn off shared objects?
19:20:24 <monochrom> "the road to mixing static linking and dynamic linking is torturous, there is no going back, etc etc"
19:20:40 <Guest33272> blah
19:20:41 <monochrom> "if you see .cabal, kill .cabal. if you see .ghc, kill .ghc"
19:20:41 <Guest33272> that did it
19:21:01 <tgeeky> Guest33272: what did it?
19:21:01 <Guest33272> went out of my way to preserve .cabal/config..
19:21:12 <Guest33272> disabling shared objects - now lets see if it can build the real thing
19:21:14 <monochrom> (of course, if you see buddha, kill buddha too. same for SPJ)
19:21:32 <monochrom> but actually you don't need to kill .cabal
19:21:42 <cmccann> monochrom, does a fixed point have buddha nature?
19:22:08 <tgeeky> hm. random guess = sound advice. who knows
19:22:24 <Guest33272> o heh, so i forgot the whole point - to produce a shared object via cabal instead of a Makefile
19:24:10 <monochrom> only ‚ä• has buddha nature
19:24:49 <cmccann> bah, ruin my pun
19:25:33 <monochrom> ‚ä• is a fixed point. the only fixed point that has buddha nature
19:26:07 <monochrom> infinite lists are fixed points too but too good for buddha!
19:26:18 <cmccann> okay I'll accept that :P
19:27:27 * cmccann was thinking in terms of recursive types and didn't make the connection to ‚ä• immediately :\
19:27:27 <dolio> ‚ä• Definitely has the right shape.
19:28:01 * tgeeky thinks in all seriousness, buddah would approve of functional programming
19:28:17 <monochrom> in that case, Void is the only fixed point data type that has buddha nature
19:28:48 <cmccann> yes, it is difficult to express the buddha nature in Haskell
19:29:07 <monochrom> newtype Void = V Void
19:30:14 <copumpkin> newtype Newtype = Newtype Newtype
19:30:26 <MatrixFrog> yes marklar
19:30:50 <ion> < ion> In fact, both human society and Haskell prefer similar behavior wrt. bottoms. Don‚Äôt expose them and usually don‚Äôt touch them.
19:30:51 <MatrixFrog> you guys are reminding me of http://www.canonical.org/~kragen/tao-of-programming.html
19:31:08 <MatrixFrog> someone should make the Tao of Functional Programming
19:31:18 <monochrom> on the next April 1, I should write an Oleg parody of the form "we show that Void can be expressed in Haskell 98, no extensions, totally safe, here are test cases..."
19:31:19 * tgeeky nominates MatrixFrog
19:31:38 <MatrixFrog> i'm re-reading the one i just linked. i'll let you know if i come up with something
19:31:39 <dolio> Oleg doesn't write test cases.
19:31:55 <tgeeky> Oleg tests right cases.
19:33:20 <MatrixFrog> i'm thinking this SO question http://stackoverflow.com/questions/6904169/managing-the-io-monad could make a good koan, if that's the right word
19:34:04 <MatrixFrog> "and the student said to the master, the type is `String -> Bool`. and the master said unto the student, you cannot escape the IO monad"
19:35:08 <stribor> i have function myFunction->String->String->String.....since this function takes 2 paramethars does that mean i cant use it in map function
19:35:33 <gwern> 'a novice once asked Ummon, when will the IO String return to purity? Ummon replied, when the mirror is unbroken, when the fallen leaf returns to the branch'
19:35:43 <stribor> should be myFunction::String->String->String
19:35:51 <gwern> stribor: sounds like a fold
19:36:01 <kmc> stribor, you can map it and get a list of (String -> String) functions... or you can apply one or the other argument ahead of time
19:36:06 <kmc> what are you trying to do?
19:36:36 <gwern> kmc: might want a zip
19:36:45 <stribor> i have another function that takes myOtherFunction::String->[String]->[String]
19:36:49 <kmc> stribor, formally, you can work out that the types fit by knowing that (String -> String -> String) is shorthand for (String -> (String -> String)), and then noticing that this type is an instance of (a -> b)
19:36:52 <shachaf> "I assure you, I want exister to return a Bool, not a IO Bool."
19:36:58 <shachaf> I like that assurance.
19:37:08 <gwern> shachaf: aren't you reassured?
19:37:13 <kmc> myOtherFunction x = map (myFunction x)  -- maybe this, stribor?
19:37:22 * cmccann has been more tempted to write an introduction to functional programming in a vaguely "alice in wonderland" style
19:37:38 <MatrixFrog> that would be pretty great
19:37:39 <stribor> id like to concatinate first element of the list and first argument and keep doing that until it reaches certain lenght....then at that point i would add to list
19:38:10 <gwern> cmccann: 'but I don't want to program among mad people!'
19:38:38 <cmccann> seeing as how lewis carroll was a mathematician and logician there's certainly enough commonality to work the style around to fir
19:38:43 <cmccann> fit, rather
19:40:34 <minsa> reading "learn you a haskell". Have a question on "zipWith' (flip' div) [2,2..] [10,8,6,4,2]" . I know that it is currying. So first iteration will look like    (flip' div 2 10) ? flip' is defined as flip' f y x = f x y .
19:40:43 <kmc> yep
19:41:06 * gwern doesn't like flip. just write out the damn lambda.
19:41:23 <kmc> functions in Haskell only have one argument; that really means flip' = \f -> (\y -> (\x -> f x y))
19:41:36 <shachaf> "\f\y\x f x y"
19:41:39 <kmc> if you write (flip' div) that reduces to (\y -> (\x -> div x y))
19:41:50 <kmc> and it should be clear how that zips
19:41:52 <MatrixFrog> is there a lambdabot function for that? to write everything in pure lambda form?
19:41:59 <kmc> @unpl flip div
19:41:59 <lambdabot> (\ b c -> div c b)
19:42:03 <MatrixFrog> <3
19:42:11 <shachaf> Well, that won't do "everything".
19:42:14 <MatrixFrog> @unpl const const
19:42:14 <lambdabot> (\ _ b _ -> b)
19:42:14 <shachaf> Not in the way @pl does.
19:42:17 <kmc> @unpl (f .) . g
19:42:17 <lambdabot> (\ d i -> f (g d i))
19:42:24 <kmc> odd choice of variable names
19:42:28 <MatrixFrog> excellent
19:42:30 <ion> fgsfds
19:43:35 <cmccann> @vixen why'd you choose those variable names?
19:43:37 <lambdabot> why anything?
19:43:41 <shachaf> @@ (@unpl const) (@unpl const const) (@unpl const const const) (@unpl const const const const) (@unpl const const const const const)
19:43:41 <lambdabot>  (\ a _ -> a) (\ _ b _ -> b) (\ b _ -> b) (\ _ d _ -> d) (\ d _ -> d)
19:44:24 <stribor> >map (++) "jerry" ["george","elaine"]
19:44:30 <minsa> what happened now ?
19:44:33 <minsa> everything ?
19:44:41 <MatrixFrog> > map (++) "jerry" ["george","elaine"]
19:44:41 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]] -> t'
19:44:41 <lambdabot>         against infe...
19:44:41 <stribor> > map (++) "jerry" ["george","elaine"]
19:44:42 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]] -> t'
19:44:42 <lambdabot>         against infe...
19:44:54 <stribor> why am i getting error here?
19:45:07 <MatrixFrog> @t map
19:45:07 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:45:13 <MatrixFrog> :t map
19:45:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:45:19 <kmc> hmm, the thing about parallel x86 disassembly is that even when i guess the instruction boundaries wrong, it will usually self-synchronize after a few bad instructions
19:45:38 <kmc> so i think instead of speculating, i should just disassemble overlapping chunks in parallel, and then glue them together properly
19:45:44 <MatrixFrog> so map takes a function (a -> b) and then a list of a's
19:45:58 <MatrixFrog> stribor: i'm not sure what you're doing but maybe you want zip? or zipWith?
19:46:01 <Olathe> What's the lambdabot thingy that makes up an instance of a function given the type?
19:46:12 <kmc> > map ("jerry" ++) ["george", "elaine"]
19:46:13 <lambdabot>   ["jerrygeorge","jerryelaine"]
19:46:14 <copumpkin> kmc: udis86 is threadsafe?
19:46:16 <kmc> Olathe, @djinn
19:46:18 <kmc> copumpkin, yep!
19:46:21 <copumpkin> nice
19:46:33 * copumpkin scowls at libopcodes
19:46:33 <kmc> it stores all its state in a struct, for which you control the allocation
19:46:37 <Olathe> Thanks :)
19:46:51 <stribor> kmc:how would i control length of ["jerrygeorge","jerryelaine"] before i put it inside this list?
19:46:57 <kmc> it's a great API design for C
19:47:04 <kmc> by contrast i hear libopcodes is the worst
19:47:12 <Olathe> @djinn ((b -> a) -> c) -> a -> c
19:47:12 <lambdabot> f a b = a (\ _ -> b)
19:47:21 <MatrixFrog> i assume everyone knows but it's Haskell's birthday today
19:47:27 <MatrixFrog> the person, not the language
19:47:33 <ion> stribor: What do you mean by controlling the length? Put it inside what list?
19:47:36 <MatrixFrog> his eleventy-first birthday in fact, as someone said on reddit
19:47:45 <MatrixFrog> (or yesterday depending where you are)
19:47:45 <minsa> kmc, when you define flip' as flip' = \f -> (\y -> (\x -> f x y)),    it doesn't matter whether \y or \x is data or function, right ?
19:47:54 <kmc> yes, functions are data (sort of)
19:47:56 <kmc> they're values, anyway
19:48:07 <MatrixFrog> :t flip'
19:48:07 <lambdabot> Not in scope: `flip''
19:48:12 <minsa> ok, but does syntax dictate the parantheses ?
19:48:14 <MatrixFrog> oh nevermind then
19:48:15 <stribor> well before we put jerrygeorge inside that list ....could we say put it inside the list if its < 10 charactes for example
19:48:17 <copumpkin> kmc: yep :(
19:48:24 <kmc> minsa, no, the body of a lambda extends as far to the right as possible
19:48:33 <ion> stribor: filter ((<10) . length)
19:48:43 <kmc> so you could write \f -> \y -> \x -> f x y
19:48:50 <kmc> but you could also write \f y x -> f x y
19:49:01 <kmc> as shorthand
19:49:24 <minsa> so shachaf wrote flip' as    "\f\y\x f x y"  and it's perfectly fine. You just put parantheses for my benefit ?
19:49:30 <kmc> you do need the ->
19:49:35 <kmc> :t \f\y\x f x y
19:49:36 <lambdabot> parse error on input `\'
19:49:40 <kmc> :t \f->\y->\x f x y
19:49:40 <lambdabot> parse error on input `->\'
19:49:46 <kmc> :t \f-> \y-> \x -> f x y
19:49:47 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
19:49:58 <minsa> ok. thnx.
19:50:03 <kmc> "currying" refers to a convention for representing multi-argument functions in a language like Haskell which lacks them
19:50:07 <kmc> it's not a language feature per se
19:50:20 <kmc> but Haskell syntax strongly encourages you to use the curried convention
19:50:41 <stribor> ion: what does (<10).length) mean...i mean i can see what it does but why did you write it that way
19:50:45 <kmc> because ¬´f x y = x + y¬ª looks nicer than ¬´f (x,y) = x + y¬ª
19:50:58 <kmc> the functions 'curry' and 'uncurry' convert between the two conventions
19:51:20 <MatrixFrog> stribor: (< 10) is a function that is equivalent to \x -> x<10
19:51:26 <MatrixFrog> . is function composition
19:51:27 <MatrixFrog> :t .
19:51:28 <lambdabot> parse error on input `.'
19:51:29 <ion> stribor: Wasn‚Äôt this explained to you just yesterday?
19:51:31 <MatrixFrog> :t (.)
19:51:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:51:45 <stribor> ion: yes but just having trouble with it
19:51:48 <MatrixFrog> ion: sometimes it takes a little while for explanations to sink in :)
19:51:59 <stribor> MatrixFrog: :)
19:52:21 <stribor> ion: i am hurt now:)
19:52:23 <ion> @src (.)
19:52:23 <lambdabot> (f . g) x = f (g x)
19:52:23 <lambdabot> NB: In lambdabot,  (.) = fmap
19:52:32 <shachaf> minsa: No, that's not actual syntax.
19:52:36 <ion> @unpl (<10)
19:52:36 <lambdabot> (\ a -> a < 10)
19:52:55 <ion> stribor: Substitute (\a -> a<10) for f and length for g and see what comes out.
19:53:00 <MatrixFrog> so you can think of ((< 10).length) as a function that takes in a list, then gets the length of that list, then compares that length to 10 and returns a Bool
19:53:09 <MatrixFrog> :t ((< 10).length)
19:53:09 <lambdabot> forall a. [a] -> Bool
19:53:24 <shachaf> kmc: curry and uncurry only works for two-argument functions, though.
19:53:29 * shachaf imagines a language where the convention was to pass arguments two at a time.
19:53:43 <kmc> heh
19:54:09 <Olathe> @type curry
19:54:09 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:54:22 <Olathe> @type uncurry
19:54:22 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:54:27 <kmc> > map ((< 10).length) (words "a bc defghi jklmnopqrsty abc d")
19:54:28 <lambdabot>   [True,True,True,False,True,True]
19:54:31 <Olathe> @type uncurry zipWith4
19:54:32 <lambdabot> forall a b c d e. (a -> b -> c -> d -> e, [a]) -> [b] -> [c] -> [d] -> [e]
19:54:55 <ion> stribor: Did you do that? What did you get as a result?
19:55:12 <stribor> ion: give me sec
19:55:18 <MatrixFrog> > filter ((< 10).length) (words "a bc defghi jklmnopqrsty abc d")
19:55:20 <lambdabot>   ["a","bc","defghi","abc","d"]
19:55:36 <stribor> [True,True,True,False,True,True]
19:55:45 <stribor> >[True,True,True,False,True,True]
19:55:47 <Olathe> I'm jklmnopqrsty. I'm going to go get a drink.
19:56:10 <stribor> > map ((< 10).length) (words "a bc defghi jklmnopqrsty abc d")
19:56:11 <lambdabot>   [True,True,True,False,True,True]
19:56:44 <Olathe> > foldr ((< 10).length) (words "a bc defghi jklmnopqrsty abc d")
19:56:44 <lambdabot>   Couldn't match expected type `b -> b'
19:56:44 <lambdabot>         against inferred type `GHC.Bo...
19:57:18 <stribor> ion:  ok your map function (words "......) -> returns list of works lets call it a
19:57:35 <stribor> map ((<10).length) a
19:57:57 <stribor> i dont get <10 .length
19:58:04 <Olathe> > foldr ((:).(< 10).length) [] (words "a bc defghi jklmnopqrsty abc d")
19:58:06 <lambdabot>   [True,True,True,False,True,True]
19:58:06 <ion> stribor: That‚Äôs not what i‚Äôm talking about. Please see my two lambdabot queries and my message to you at :43:33 ‚Ä¶ :44:05.
19:58:14 <Olathe> Take that, map!
19:58:15 <azaq23> stribor: (< 10) is shorthand notation for \x -> x < 10
19:58:24 <Olathe> @unpl (< 10)
19:58:24 <lambdabot> (\ a -> a < 10)
19:58:28 <MatrixFrog> stribor: focus on the (<10) function first
19:58:32 <MatrixFrog> > (< 10) 11
19:58:33 <lambdabot>   False
19:58:37 <MatrixFrog> > (< 10) 4
19:58:38 <lambdabot>   True
19:58:47 <stribor> is that prefix function?
19:58:50 <MatrixFrog> similarly:
19:58:52 <MatrixFrog> (+ 10) 4
19:58:56 <MatrixFrog> > (+ 10) 4
19:58:57 <lambdabot>   14
19:59:06 <MatrixFrog> > (+10) 17
19:59:07 <lambdabot>   27
19:59:32 <Olathe> > (+1) eleventy
19:59:34 <lambdabot>   111
19:59:42 <MatrixFrog> i think of it as an infix function with its first argument "missing" in a sense
19:59:43 <stribor> (<10) 11 is same as 10 < 11
19:59:51 <stribor> isnt it
19:59:51 <MatrixFrog> 11<10
19:59:54 <MatrixFrog> but you have the right idea
20:00:01 <MatrixFrog> you could also define (10 <)
20:00:13 <Olathe> (10<) 11 is the same as 10 < 11
20:00:18 <Olathe> > (10<) 11
20:00:19 <lambdabot>   True
20:00:45 <stribor> ok so he is applying function length to what?
20:00:56 <ion> stribor: Please see my two lambdabot queries and my message to you at :43:33 ‚Ä¶ :44:05.
20:01:00 <MatrixFrog> if you just write ((<10).length) then it's not applied to anything
20:01:03 <MatrixFrog> yet
20:01:10 <MatrixFrog> > ((<10).length)
20:01:10 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Bool.Bool)
20:01:10 <lambdabot>    arising f...
20:01:15 <stribor> ion: how do i get at 43:33
20:01:16 <azaq23> @unpl (< 10) . length
20:01:16 <lambdabot> (\ d -> (length d) < 10)
20:01:19 <MatrixFrog> it's just a function
20:01:23 <ion> stribor: By scrolling up.
20:01:27 <MatrixFrog> but then if i go like this:
20:01:31 <MatrixFrog> ((<10).length) []
20:01:35 <MatrixFrog> > ((<10).length) []
20:01:37 <lambdabot>   True
20:01:44 <MatrixFrog> then i've applied that function to []
20:02:03 <stribor> > ((<10).length) [1,2,3,3,4,5]
20:02:05 <lambdabot>   True
20:02:16 <stribor> > ((<10).length) [1,2,3,3,4,5,6,7,8,9,9,9]
20:02:17 <MatrixFrog> ((<10).length) []
20:02:17 <lambdabot>   False
20:02:17 <MatrixFrog> (<10) (length [])
20:02:17 <MatrixFrog> (<10) 0
20:02:17 <MatrixFrog> 0<10
20:02:17 <MatrixFrog> True
20:03:07 <stribor> iall my lines sstart at 23
20:03:37 <ion> @unpl (<10)
20:03:37 <lambdabot> (\ a -> a < 10)
20:03:39 <ion> @src (.)
20:03:39 <lambdabot> (f . g) x = f (g x)
20:03:39 <lambdabot> NB: In lambdabot,  (.) = fmap
20:03:41 <ion> < ion> stribor: Substitute (\a -> a<10) for f and length for g and see what comes out.
20:03:56 <ion> What do you get as a result?
20:04:00 <MatrixFrog> does lambdabot have the "normal" definition of (.) somewhere?
20:04:04 <ion> Just above.
20:04:13 <Eduard_Munteanu> :t (Prelude..)
20:04:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:04:22 <MatrixFrog> :)
20:04:58 <stribor> ion:  i dont know what you mean....i am just confused even more with substituting f and g
20:05:23 <MatrixFrog> you have (f . g), where f is "(< 10)" and g is "length"
20:05:29 <MatrixFrog> does that make sense?
20:05:32 <stribor> yes'
20:05:40 <MatrixFrog> so then you can just substitute, like math
20:05:49 <MatrixFrog> if you have x+y, where x is 3 and y is 4, that's just 3+4
20:05:53 <MatrixFrog> so same thing here
20:06:14 <MatrixFrog> but you know from the definition that (f . g) x = f (g x)
20:06:33 <MatrixFrog> (type "/msg lambdabot @src (.)" to get the definition again"
20:06:37 <MatrixFrog> )
20:07:00 <stribor> so you get (<10) (length myList)
20:07:08 <ion> Indeed.
20:07:11 * MatrixFrog stribor +1
20:07:18 <ion> And (<10) is syntactic sugar for (\a -> a < 10).
20:07:37 <stribor> nice
20:07:45 <stribor> thanks ion  and MatrixFrog
20:08:33 <ion> So given (\a -> a < 10) (length myList) you can just substitute the ‚Äòa‚Äô in (a < 10) with length myList.
20:08:58 <ion> Just like (\x -> x * 2) 4 = 4 * 2
20:09:50 <stribor> ion: thanks for explaining this:)
20:09:58 <stribor> MatrixFrog: you too :)
20:10:02 <MatrixFrog> no problem
20:17:31 <minsa> @unpl (f .) . g
20:17:31 <lambdabot> (\ d i -> f (g d i))
20:17:36 <minsa> what does that mean ?
20:18:18 <MatrixFrog> well, if you let h = (f .) . g
20:18:28 <minsa> what is (f .) ?
20:18:34 <ion> @unpl (f .)
20:18:34 <lambdabot> (\ a d -> f (a d))
20:18:34 <MatrixFrog> then: h x = (f . ) (g x)
20:18:59 <MatrixFrog> just like (<10) is the function that, when you apply it to x, gives you (x<10)
20:19:11 <MatrixFrog> (f.) is the function that, when you apply it to x, gives you (f.x)
20:19:16 <dolio> Or (-10).
20:19:18 <dolio> Oh wait.
20:19:27 <MatrixFrog> so in this case, x would have to be a function
20:20:14 <copumpkin> > (+1) . [1..10]
20:20:15 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
20:20:43 <MatrixFrog> copumpkin, aren't you using (.) as fmap there? not as the composition operator?
20:20:46 <minsa> so (+1) is like (f.) ?
20:21:05 <MatrixFrog> yeah, somewhat
20:21:10 <MatrixFrog> or (1+) if you prefer
20:21:25 <copumpkin> :)
20:21:46 <minsa> but with  . , whatever it applies has to be a function because it is function application ?
20:21:55 <Olathe> O-o
20:22:19 <Olathe> > (*5) . [1..10]
20:22:21 <lambdabot>   [5,10,15,20,25,30,35,40,45,50]
20:22:23 <ion> Does anyone actually ever use lambdabot‚Äôs (.) = fmap for other than evil?
20:22:23 <aspect> :t fmap
20:22:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:22:26 <Olathe> That's unpossible!
20:22:29 <MatrixFrog> right, (f.g) means "the function f, composed with the function g"
20:22:42 <MatrixFrog> minsa: people keep using the . in a different way :( confusing
20:22:54 <Jafet> ion is a reactionary
20:23:07 <glguy_> Lambdabot has a custom (.) defined to help confuse the new Haskell programmers
20:23:21 <Jafet> :t (++)
20:23:21 <lambdabot> forall m. (Monoid m) => m -> m -> m
20:23:24 <Jafet> :t flip
20:23:25 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:23:32 <MatrixFrog> ugh
20:23:32 <Olathe> Yay! Confusion!
20:23:57 <Olathe> > map (+1) (Just 5)
20:23:58 <ion> :t concat
20:23:58 <lambdabot>   Couldn't match expected type `[a]'
20:23:58 <lambdabot>         against inferred type `Data.Mayb...
20:23:58 <lambdabot> forall a. [[a]] -> [a]
20:24:01 <Olathe> Bah.
20:24:08 <Olathe> It has confusing things but not useful things.
20:24:16 <tgeeky> well, on the other hand, confusion is really an opportunity for learning in disguise
20:24:23 <Olathe> Lies.
20:24:42 <MatrixFrog> it's also an opportunity to turn people away and perpetuate the idea that haskell is just too hard'
20:25:15 <Jafet> @vixen are you hard?
20:25:17 <minsa> from another tutorial, "colorize = zip.repeat"     it is the shorthand for "colorize c  p = zip (repeat c) p".
20:25:17 <lambdabot> yes, i am
20:25:29 <tgeeky> ... hmm. that's slightly disturbing.
20:25:48 <tgeeky> minsa: isn't that wonderful
20:25:58 <Jafet> vixen has a hidden secret.
20:26:04 <MatrixFrog> minsa, i think that's right...
20:26:10 <tgeeky> Jafet: well, not anymore, thanks to you. pervert!
20:26:16 <Jafet> minsa: barring monomorphism
20:26:16 <glguy_> ?unpl (zip . repeat)
20:26:16 <lambdabot> (\ c -> zip (repeat c))
20:26:16 <minsa> yes it is and I am trying to understand it in the context of (f .).g
20:26:34 <tgeeky> and boom
20:26:37 <tgeeky> there's your opportunity for learning
20:26:38 <Jafet> @type (?f .) . ?g
20:26:38 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?f::a -> b, Functor f, ?g::f1 (f a), Functor f1) => f1 (f b)
20:26:55 <Jafet> @type (?f Prelude..) Prelude.. ?g
20:26:55 <ion> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%28%28f+.%29+.+g%29+x+y
20:26:55 <lambdabot> forall b c a a1. (?g::a1 -> a -> b, ?f::b -> c) => a1 -> a -> c
20:27:28 <Jafet> @unpl (f.).g
20:27:28 <lambdabot> (\ d i -> f (g d i))
20:27:35 <Jafet> Pretty straightforward.
20:27:39 <tgeeky> Jafet: ok, what the hell was that 2nd to last one?
20:27:53 <Jafet> @unpl ((f.).).g
20:27:53 <lambdabot> (\ e j m -> f (g e j m))
20:27:55 <Jafet> etc.
20:27:58 <MatrixFrog> Jafet, if minsa thought it was straightforward, they wouldn't be here asking about it. you're not being particularly helpful
20:28:16 <ion> @tell benmachine It would be nice if each step http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi displayed the definition of the function applied in the step in a column to the right.
20:28:16 <lambdabot> Consider it noted.
20:28:23 <Jafet> Oh yeah, I'm totally not helping minsa here.
20:28:37 <MatrixFrog> so what are you doing? just bragging about how smart you are?
20:28:40 <Jafet> Guess what, this isn't a helping channel
20:28:53 <MatrixFrog> yes
20:28:54 <MatrixFrog> it is
20:28:55 <tgeeky> MatrixFrog: c'mon, that's not necessary
20:29:00 <minsa> hm.. that's like "zipWith' (zipWith *) [[1,2,3], [3,4,5]] [4,5,6], [6,7,9]]
20:29:04 <zzing> What is the name of that editor somebody made that was like emacs/vim in concept but was written in haskell? I am potentially looking for a nano replacement... for my fortran work :P
20:29:08 <tgeeky> MatrixFrog: he could be talking to someone else (or to nobody)
20:29:16 <MatrixFrog> sorry, i just feel like minsa is asking for help and being drowned out
20:29:17 <glguy_> zzing: Yi?
20:29:30 <MatrixFrog> and i'm trying to be as helpful as people have been to me
20:29:35 <Jafet> Is yi usable? (not compared to nano)
20:29:45 <ion> I like the concept of an editor that‚Äôs like emacs/vi.
20:29:51 <Olathe> > zipWith fingers
20:29:51 <lambdabot>   Not in scope: `fingers'
20:30:02 <Olathe> > aimAt fingers
20:30:03 <lambdabot>   Not in scope: `aimAt'Not in scope: `fingers'
20:30:07 <Jafet> ion: it would be written in C/C++
20:30:17 <zzing> glguy_: it might be yi. it looks like it is dead...
20:30:35 <zzing> I am just afraid of emacs, and not sure about vim :P
20:31:36 <glguy_> zzing: if you are going to do any significant amount of programming you'll want to break down and learn one of them
20:32:20 <zzing> I have been using xcode for a bit. Even using 'espresso' (basic html editor on mac that happens to be suitable for project management).
20:32:25 <Jafet> minsa: zipWith (zipWith (*))
20:32:32 <zzing> I will break down and download some emacs I guess
20:32:42 <Olathe> @type zipWith (zipWith (*))
20:32:42 <lambdabot> forall a. (Num a) => [[a]] -> [[a]] -> [[a]]
20:40:12 <ion> > let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
20:40:13 <lambdabot>   ["emacs and nano suck, learn vim","vim and nano suck, learn emacs","vim and...
20:41:25 <Jafet> @remember ion let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
20:41:26 <lambdabot> I will never forget.
20:44:01 <Jafet> @poll-result editor
20:44:01 <lambdabot> Poll results for editor (Open): switches-on-front-of-computer=0, EDLIN=2, emacs=2, vim=2
20:44:12 <Jafet> Guys, this is why lambdabot has space leaks.
20:44:13 <Olathe> Zero?
20:44:14 <tgeeky> lambdabot: that was yesterday.
20:44:17 <Olathe> ZERO?!
20:44:28 <Jafet> @poll-remove editor
20:44:28 <lambdabot> Poll should be closed before you can remove it.
20:44:34 <Jafet> @poll-close editor
20:44:34 <lambdabot> Poll "editor" closed.
20:44:36 <Jafet> @poll-remove editor
20:44:36 <lambdabot> poll "editor" removed.
20:44:39 <Olathe> How did EDLIN get 2 but switches got zero?
20:44:46 <Jafet> I voted twice.
20:44:50 <Olathe> Oh.
20:45:38 <ion> Why wasn‚Äôt ed there‚ÄΩ
20:45:47 <Jafet> ion: ?
20:46:14 <kmc> @poll-result food
20:46:14 <lambdabot> Poll results for food (Open): quesadilla=1, meatball-sub=0
20:46:31 <Olathe> @vote quesadilla
20:46:31 <lambdabot> usage: @vote <poll> <choice>
20:46:36 <Olathe> @vote food quesadilla
20:46:36 <lambdabot> voted on "quesadilla"
20:46:46 <Olathe> @vote food meatball-sub
20:46:46 <lambdabot> voted on "meatball-sub"
20:46:48 <Jafet> @poll-list
20:46:48 <lambdabot> ["\"blah\"","Should_I_install_Diablo_2_again?","food","logoVotingMethod","naming","remove@src","threeway"]
20:47:03 <kmc> @poll-add best-programming-language
20:47:03 <lambdabot> Added new poll: "best-programming-language"
20:47:08 <Olathe> @poll-result Should_I_install_Diablo_2_again?
20:47:08 <lambdabot> Poll results for Should_I_install_Diablo_2_again? (Open): No=0, Yes=1
20:47:10 <kmc> @choice-add best-programming-language Haskell
20:47:10 <lambdabot> New candidate "Haskell", added to poll "best-programming-language".
20:47:21 <kmc> @choice-add best-programming-language anything-else
20:47:21 <lambdabot> New candidate "anything-else", added to poll "best-programming-language".
20:47:27 <ion> http://www.gnu.org/fun/jokes/ed.msg
20:47:28 <kmc> let's see how this one pans out
20:47:30 <Jafet> @choice-add best-programming-language Agda
20:47:30 <lambdabot> New candidate "Agda", added to poll "best-programming-language".
20:47:44 <Jafet> @choice-add best-programming-language Coq
20:47:44 <lambdabot> New candidate "Coq", added to poll "best-programming-language".
20:47:58 <ion> @choice-add best-programming-language PHP
20:47:58 <lambdabot> New candidate "PHP", added to poll "best-programming-language".
20:47:59 <tgeeky> Jafet: can one setup the poll in private, and just announce it?
20:48:05 <ion> @vote best-programming-language PHP
20:48:05 <lambdabot> voted on "PHP"
20:48:15 <MatrixFrog> probably you can /msg lambdabot the setups?
20:48:35 <lpsmith> heh, criterion takes 1.3 of RAM to compile
20:49:03 <kmc> 1.3 rams
20:49:17 <kmc> however much RAM you have, it takes 1.3 times that
20:49:21 <Olathe> I accidentally the 1.3.
20:49:23 <lpsmith> hahaha.
20:49:31 <Jafet> 0.7 ewes
20:49:32 <lpsmith> Yeah, 1.3 GB
20:49:37 <kmc> heh
20:49:43 <kmc> criterion itself, or criterion + deps?
20:49:54 <kmc> it has a lot of transitive deps
20:49:55 <lpsmith> criterion itself,  using GHC 7.0.3
20:49:58 <minsa> @unpl (++ x) y
20:49:59 <lambdabot> (y ++ x)
20:50:03 <ion> three megabytes of hot RAM
20:50:10 <minsa> @unpl (x ++) y
20:50:10 <lambdabot> (x ++ y)
20:50:32 <ion> > (+ x) y
20:50:33 <lambdabot>   y + x
20:50:43 <lpsmith> I found this out because I'd adjusted my ulimit down because the latest firefox has been bad for me,  with severe CPU and memory leaks
20:51:16 <Jafet> @pl flip (*)
20:51:16 <lambdabot> (*)
20:51:18 <lpsmith> I'd had a 2 GB soft ulimit -v,  then 1 GB, and I've temporarily bumped it back up to 2.
20:51:22 <minsa> ion, that's like (\y -> y + x)
20:51:27 <minsa> ?
20:52:08 <Jafet> No, it's (\y -> y + x) y!
20:52:09 <minsa> and for (x+) y, it will be (\y -> x + y) . that's the only way I can imagine right now.
20:52:25 <ion> ‚Äú(+ x) y‚Äù ‚Üí ‚Äú(\foo -> foo + x) y‚Äù ‚Üí ‚Äúy + x‚Äù
20:52:44 <minsa> ok.
20:53:17 <Olathe> (\y -> (\z -> z) y + (\x -> (\x -> x) x) x) y
20:53:20 <Jafet> Does UnicodeSyntax enable those quotes?
20:53:28 <Olathe> @pl (\y -> (\z -> z) y + (\x -> (\x -> x) x) x) y
20:53:28 <lambdabot> y + x
20:53:37 <ion> I don‚Äôt think so.
20:53:37 <Jafet> @quote best view pattern
20:53:37 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
20:53:47 <Jafet> @quote best.view
20:53:47 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
20:53:49 <minsa> @source foldr
20:53:49 <lambdabot> foldr not available
20:53:55 <minsa> @unpl foldr
20:53:55 <lambdabot> foldr
20:54:02 <ion> @src foldr
20:54:02 <lambdabot> foldr f z []     = z
20:54:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:54:04 <minsa> @src foldr
20:54:04 <lambdabot> foldr f z []     = z
20:54:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:54:22 <Olathe> > let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x
20:54:23 <lambdabot>   0
20:54:27 <Olathe> O-o
20:55:19 <copumpkin> view patterns
20:55:45 <c_wraith> come to think of it...  I'd love if the "Loading package..." messages from ghci/TH never, ever were shown.
20:55:46 <Jafet> > let ((\x -> case x of ((\x -> x) -> x) -> x) -> x) = 0 in x
20:55:47 <lambdabot>   0
20:56:17 <kmc> lpsmith, luckily there's been another 10 major versions of Firefox since breakfast
20:56:25 <kmc> i'm sure one of them fixes your bug *cough*
20:57:35 <minsa> sum1 xs = foldr (\acc x -> acc + x) 0 xs     and   sum2 xs = foldl (\x acc -> acc + x) 0 xs ? so far so good ?
20:58:04 <minsa> my question is why does the parameter position in the lambda matters for acc in foldr and foldl ?
20:58:07 <MatrixFrog> (\acc x -> acc +x)
20:58:14 <MatrixFrog> couldn't you just write that as (+)
20:58:28 <ion> @check let sum1 xs = foldr (\acc x -> acc + x) 0 xs in \xs -> sum1 xs == sum xs
20:58:29 <lambdabot>   "OK, passed 500 tests."
20:58:30 <MatrixFrog> in this case, it doesn't matter much because + is commutative
20:58:49 <MatrixFrog> imagine if you had a list of lists though, and your function was ++
20:58:59 <MatrixFrog> a ++ b is definitely not the same as b ++ a, in general
20:59:00 <minsa> yes, ++ is better.
20:59:09 <minsa> so ?
20:59:27 <minsa> or if I want to reverse a list using    :   ?
20:59:30 <Olathe> > foldl (++) "!" ["zomg", "hi"]
20:59:30 <MatrixFrog> did that answer your question? kinda sorta?
20:59:32 <lambdabot>   "!zomghi"
20:59:41 <Olathe> > foldr (flip (++)) "!" ["zomg", "hi"]
20:59:43 <lambdabot>   "!hizomg"
20:59:52 <Olathe> That's what happens when you reverse the streams!
20:59:56 <Olathe> Or something.
21:00:22 <Olathe> You want it as it is to give the proper results there.
21:00:46 <minsa>   > foldr (++) "!" ["zomg", "hi"]
21:00:52 <Olathe> > foldr (++) "" ["zomg", "hi"] == foldl (++) "" ["zomg", "hi"]
21:00:53 <lambdabot>   True
21:01:05 <Olathe> If one were reversed in argument order:
21:01:14 <Olathe> > foldr (++) "" ["zomg", "hi"] == foldl (flip (++)) "" ["zomg", "hi"]
21:01:15 <lambdabot>   False
21:01:27 <Olathe> > foldr (flip (++)) "" ["zomg", "hi"] == foldl (++) "" ["zomg", "hi"]
21:01:29 <lambdabot>   False
21:01:40 <Olathe> As you can see, dogs living with cats and so on.
21:01:56 <lpsmith> kmc: yeah,  firefox is turning into the old mozilla I abhorred
21:02:30 <ion> > [[foldr (+) z [a,b,c], foldr (flip (+)) z [a,b,c], foldl (+) z [a,b,c], foldl (flip (+)) z [a,b,c]]
21:02:30 <lpsmith> at least it does work a lot better than the old mozilla.  Sort of.  At least it doesn't crash as often or completely choke on rendering web pages
21:02:31 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:02:37 * MatrixFrog cannot escape the firefox complaints
21:03:23 <ion> > [foldr (+) z [a,b,c], foldr (flip (+)) z [a,b,c], foldl (+) z [a,b,c], foldl (flip (+)) z [a,b,c]]
21:03:24 <kmc> lpsmith, it's the circle of life
21:03:24 <lambdabot>   [a + (b + (c + z)),z + c + b + a,z + a + b + c,c + (b + (a + z))]
21:03:42 <kmc> recall their original name / logo
21:04:20 <lpsmith> The communist logo?
21:05:25 <kmc> i meant "firebird" aka a phoenix rising from the ashes
21:05:30 <kmc> i must have missed the communism
21:09:09 <dolio> When I save up a little more money, I'm going to buy myself a vintage Pontiac Firefox.
21:09:20 <minsa> MatrixFrog, Olathe, ion, kmc, Jafet, I need to study the log and take note. Even though I haven't understood all of it, it is slowing seeping in.
21:13:35 <MatrixFrog> :)
21:42:37 <dthurn> Are there any options for hosting low-traffic Haskell web applications for free a la Google App Engine?
21:51:22 <AtnNn> dthurn: http://www.yesodweb.com/blog/2011/07/haskell-on-heroku
21:54:06 <dthurn> AtnNn: Interesting. It looks like it involves building your own binary locally and deploying it to Heroku. Tricky, but worth investigating. Thanks.
22:01:34 <c_wraith> dthurn: basically, it takes advantage of the fact that Heroku now supports anything, so long as it's packaged to *look* like a rails app. :)
22:01:48 <cheater> eugh
22:01:57 <cheater> why does it have to look like a rails app?
22:03:15 <Jafet> Why not!
22:44:48 <kmc> @hoogle [a] -> ([a],a]
22:44:48 <lambdabot> Parse error:
22:44:48 <lambdabot>   --count=20 "[a] -> ([a],a]"
22:44:48 <lambdabot>                           ^
22:44:51 <kmc> @hoogle [a] -> ([a],a)
22:44:51 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
22:45:41 <kmc> i'm looking for, er, unsnoc? something to do 'init' and 'last' at once, without two reversals
22:46:10 <kmc> i mean it's kind of going to suck either way
22:46:37 <Jafet> unsnoc [x] = ([],x); unsnoc (x:xs) = first (x:) $ unsnoc xs
22:46:40 <Jafet> Here, I found it!
22:48:30 <kmc> thanks :)
22:48:55 <shachaf> @hoogle [a] -> Maybe ([a],a)
22:48:55 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
22:49:04 <shachaf> Hah, I was hoping for a view pattern.
22:49:45 <kmc> that has the important (to me) property of laziness
22:50:08 <Jafet> unsnoc [] = fail (undefined); unsnoc [x] = return ([], x); unsnoc (x:xs) = first (x:) <$> unsnoc xs
22:50:48 <copumpkin> fail undefined is very useful
22:50:54 <copumpkin> > error undefined
22:50:55 <lambdabot>   *Exception: *Exception: Prelude.undefined
22:50:59 <Jafet> I thought it was self-documenting
22:51:27 <copumpkin> :)
22:51:32 <copumpkin> fail "fuck you, that's why"
22:52:13 <ddarius> > let map f (x:xs) = f x : map f xs; map f [] = fix fail in map succ [1..10]
22:52:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
22:52:14 <lambdabot>    arising from the literal `1...
22:52:22 <ddarius> Indeed.
22:53:39 <Jafet> You should fix error.
23:09:10 <KirinDave> So‚Ä¶ http://stmts.net/2011/09/10/disenthrall/
23:09:22 <KirinDave> But let's not learn functional programming.
23:09:55 <Jafet> I only know dysfunctional programming
23:10:12 <KirinDave> Jafet: You're a Node programmer?
23:11:25 <Jafet> Node.js? That's functional stuff that gets used everywhere.
23:11:37 <Jafet> I can't deal with that.
23:11:55 <KirinDave> Ha
23:11:57 <KirinDave> Functional?
23:12:09 <KirinDave> Look upon his works, ye mighty, and despair: http://streamjs.org/
23:12:51 <KirinDave> Look upon the implementation, but first harden your heart. https://github.com/dionyziz/stream.js/blob/master/stream.js
23:16:53 <Jafet> I still like fsck https://github.com/thorncp/fsck#readme
23:17:13 <copumpkin> "Every language has a tag cloud of characteristics"
23:17:50 <copumpkin> "stream.js is a tiny stand-alone Javascript library that unlocks a new data structure for you: streams."
23:17:50 <Jafet> Web 2.0 finally enters english?
23:17:51 <KirinDave> Jafet: Truly "lolrubby"
23:18:13 <KirinDave> copumpkin: The implementation of reduce is the worst implementation you can offer.
23:18:15 <copumpkin> "Unlike arrays, streams are a magical data structure. "
23:18:18 <KirinDave> It is literally the worst.
23:18:28 <danr> copumpkin: o_O Where are you quoting from?
23:18:40 <copumpkin> KirinDave's wonderful links
23:19:36 <KirinDave> I bring you the most agonizing links on the internet.
23:19:49 <copumpkin> thank you, KirinDave
23:19:55 <copumpkin> now I can mock them at work tomorrow
23:19:59 <copumpkin> dolio: mark my words
23:20:00 <danr> oh I saw it
23:21:34 <ion> What‚Äôs everyone‚Äôs favorite command line arguments parser?
23:21:44 <copumpkin> KirinDave: if you get over the mysticism, it's kind of cute
23:21:56 <KirinDave> copumpkin: What, node.js?
23:21:59 <copumpkin> KirinDave: a lot of people have genuinely never heard of this
23:22:01 <copumpkin> the streams.js
23:22:03 <KirinDave> copumpkin: Ah
23:22:03 <copumpkin> intro page
23:22:05 <KirinDave> Yeah
23:22:11 <danr> ion: cmdargs is pretty nice
23:22:16 <KirinDave> Well, I am considering fixing some of his basic mistakes
23:22:28 <ion> danr: Thanks
23:22:31 <KirinDave> And he needs a stream that can be populated via a callback.
23:22:31 <copumpkin> :)
23:22:40 <copumpkin> oh yeah
23:22:59 <copumpkin> I like having both unfold and tabulate
23:23:21 <dolio> Just as efficient as arrays, eh?
23:23:41 <KirinDave> dolio: Not magic, Illusions.
23:23:49 <KirinDave> copumpkin: And also what the heck is walk?
23:23:52 <dolio> Come on!
23:23:54 <copumpkin> dolio: I don't think the word "efficiency" appears anywhere in javascript material
23:24:07 <KirinDave> copumpkin: You have a hash table, what more could you want?
23:24:31 <dolio> Oh, sorry. They "work fast" like arrays.
23:24:59 <copumpkin> KirinDave: it looks a bit like scala's foreach, but returns the input stream?
23:25:02 <copumpkin> I think
23:25:31 <copumpkin> so it's really just a map that ignores the return value of the function
23:26:01 <copumpkin> oh actually it doesn't return anything
23:26:05 <copumpkin> cause force() throws it away
23:26:10 <copumpkin> so it's basically foreach
23:26:14 <KirinDave> Yeah
23:26:18 <KirinDave> Why not use reduce?
23:26:29 <copumpkin> beats me :)
23:26:54 <copumpkin>         if ( typeof n != 'undefined' ) {
23:26:57 <copumpkin> mmhmm
23:26:59 <KirinDave> Don't worry about it.
23:27:58 <dolio> Are the streams actually lazy?
23:28:01 <dolio> Or call-by-name?
23:28:29 <copumpkin> todo: memoize here
23:28:35 <copumpkin> line 28
23:28:37 <copumpkin> so no
23:29:35 <copumpkin> ah well, I applaud people experimenting with "unconventional" (for their cultural context) ideas like this. I wish they'd jump in and take it further, but I guess it's better than nothing, right? :P
23:29:58 <copumpkin> maybe in five or ten years most people will have heard of folds, streams, and maps
23:30:16 <copumpkin> and will be more curious about other ideas from those crazy FP guys
23:30:19 * copumpkin shrugs
23:30:44 <copumpkin> anyway, I was supposed to be asleep ages ago!
23:31:05 <raichoo> copumpkin: good night :P
23:31:13 <copumpkin> ciao :)
23:49:30 <Veinor> if my module imports module A, and A has an instance for a typeclass for IO, does anybody who gets my module also get that instance?
23:50:39 <Liskni_si> yes, all instanced from all imported modules and their imported modules and their ... are imported
23:50:43 <Liskni_si> *instances
23:51:16 <Veinor> so what happens if i import two modules that have conflicting instances?
23:52:22 <Liskni_si> you get an error, I hope :-)
23:54:01 <Jafet> There should be scoping for instances, but that would break many programmers
23:55:08 <Veinor> scoping for instances seems like it might break in interesting ways if you import a function that requires an instance, but not the instance
