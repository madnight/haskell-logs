00:00:54 <wavewave> often translating some imperative algorithm to real functional way is very hard..
00:02:10 <boegel> anyone know why "runhaskell Setup.hs configure" would fail to find the transformers package, while it is isntalled with cabal (see http://hpaste.org/51825)
00:02:58 <wavewave> cabal install transformers --reinstall
00:03:25 <mux> for a second there I thought this was an optimus prime joke
00:03:30 <wavewave> you have some dependency broken , I guess.
00:11:27 <boegel> wavewave: tried reinstalling (and it worked), but made no difference
00:12:12 <boegel> wavewave: could it have do to with system cabal lib and user cabal lib?
00:12:19 <boegel> I think I've been using both
00:13:56 <whoopsbob> Hi all, I'm trying to profile some code, but the profiler is telling me that 99% of the time is being spent in main. Is there a way to get a more useful profile?
00:17:51 <kmc> whoopsbob, did you build with -auto-all -caf-all?
00:18:18 <kmc> i'd use a full command line like:   ghc -O2 -fforce-recomp -rtsopts -prof -auto-all -caf-all foo.hs
00:18:39 <whoopsbob> kmc: yes, i am using pretty much exactly that
00:18:45 <kmc> or if you're building with cabal there's some other flag
00:18:45 <kmc> ah
00:18:56 <kmc> then you might have to add your own cost-center annotations on subexpressions of "main"
00:19:39 <whoopsbob> kmc: I have no idea what that means. I assume "cost-center" is something i can google?
00:20:03 <alpounet> yes
00:20:28 <alpounet> whoopsbob, http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html#cost-centres
00:22:29 <whoopsbob> alpounet: ok thanks, a quick glance makes me think that this will solve my problem
00:23:07 <whoopsbob> but is this common? am i likely doing something "wrong" that makes this neccessary?
00:23:37 <whoopsbob> my main just reads some input, some does some processing on it, then outputs
00:26:29 <alpounet> whoopsbob, it depends on how it does it
00:26:43 <alpounet> you need more precise information regarding where most of the time is actually spent
00:27:26 <alpounet> really it is "common" yes
00:27:42 <mreh> whoopsbob: read the GHC user guide locally if you installed the documentation, or online
00:27:52 <mreh> it tells you in some depth about profiling
00:27:59 <alpounet> when you first write your program, you can't anticipate everything and make the performance optimal right from the start
00:28:36 <whoopsbob> alpounet: that's why i'm profiling :)
00:28:50 <alpounet> just read the profiling page and try to apply what you read to spot the bottlenecks
00:29:01 <whoopsbob> ok
00:29:04 <alpounet> anyway, i'm off
00:29:05 <alpounet> good luck
00:29:09 <whoopsbob> thanks
00:32:26 <wavewave> boegel: first try  ghc-pkg list transformers
00:33:58 <wavewave> boegel: probably, GA needs some package that need transformers but GA also needs another package that prohibits transformers.
00:34:28 <boegel> wavewave: $ ghc-pkg list transformers
00:34:28 <boegel> /usr/lib64/ghc-6.12.1/package.conf.d
00:34:28 <boegel> /home/kehoste/.ghc/x86_64-linux-6.12.1/package.conf.d
00:34:28 <boegel>    transformers-0.2.2.0
00:34:29 <wavewave> boegel: often that is related to mtl library
00:34:57 <boegel> wavewave: I haven't changed the package dependencies, and GA built fine before (see http://hackage.haskell.org/package/GA)
00:35:10 <boegel> wavewave: "cabal configure" works fine
00:35:27 <boegel> wavewave: "cabal haddock" complains about not finding transformers, but that's not so bad I guess
00:35:42 <boegel> wavewave: I'm only testing the release before I upload it to hackage
00:36:11 <boegel> wavewave: or maybe there's jsut no haddock for transformers, then the cabal variant is working fine
00:36:35 <wavewave> hmm
00:38:58 <wavewave> so cabal configure shows the same error as runhaskell Setup.lhs configure?
00:39:16 <wavewave> I am confused.
00:39:46 <wavewave> boegel: or you mean it works with cabal configure, but runhaskell Setup.lhs configure doesn't work?
00:40:59 <wavewave> probably latter. It seems that I misunderstood your original question.
00:43:15 <wavewave> boegel: i am not sure, but my guess is that runhaskell Setup.lhs xx does not refer to your .cabal/config .
00:46:04 <wavewave> probably, global and user difference is a correct guess.
00:51:50 <sanjoyd> Suggestions on nice elegant ways to write a lexer?
00:52:49 <merijn> sanjoyd: Just a lexer? If you're going to be parsing why not use parsec or something to do both?
00:53:29 <sanjoyd> Parsec smells good.
00:53:32 * sanjoyd tries.
00:59:22 <boegel> wavewave: I'm guessing that's it, yes
01:13:44 <ben_> hi folks, has anyone tried any haskell gtk apps with the new broadway (html5) backend?
01:15:19 <mreh> why can't I annotate a tuple type definition with bang patterns?
01:16:26 <shachaf> mreh: What do you mean?
01:20:50 <mreh> shachaf, type Baz = (!Int, !Bool)
01:21:03 <shachaf> mreh: Because that's not how the type is defined.
01:21:08 <shachaf> A tuple isn't magic, other than the syntax.
01:21:11 <shachaf> This is equivalent to
01:21:13 <mreh> right
01:21:17 <shachaf> data Pair a b = MkPair a b
01:21:32 <shachaf> type Baz = Pair !Int !Bool
01:21:35 <shachaf> You can't do that.
01:21:59 <mreh> are there strict tuple types?
01:22:05 <mreh> well, i can make them
01:22:07 <shachaf> Not built-in, as far as I know.
01:22:11 <ddarius> pair !a !b = (,) a b
01:22:24 <ddarius> There is a package of some strict types.
01:22:25 <mreh> that's not a type :)
01:22:31 <mreh> cool, thanks
01:22:50 <ddarius> mreh: Yes, but that's all adding bangs does, it makes the constructor seq its arguments.
01:23:32 <mreh> i understand :)
01:23:34 * hackagebot JYU-Utils 0.1.1.2 - Some utility functions for JYU projects  http://hackage.haskell.org/package/JYU-Utils-0.1.1.2 (VilleTirronen)
01:23:34 <Zira> The GHC compiler one downloads from the website (haskell.org) is for Haskell 98? The downloads section does not really mention Haskell 98.
01:24:17 <shachaf> Zira: It compiles Haskell 98. It also supports many extensions.
01:24:26 <shachaf> ddarius: Yes, but if you want to guarantee that a pair you get as an argument was made with a strict constructor, that's not sufficient.
01:24:27 <ddarius> It's actually a C compiler.
01:24:30 <ddarius> Try it.
01:24:38 <ddarius> shachaf: I agree.
01:24:40 <engla> Zira: get http://hackage.haskell.org/platform/
01:25:01 <shachaf> C is one of those extensions.
01:26:23 <mreh> i understand :)
01:26:28 <shachaf> Zira: What you really want is a Haskell 1.4 compiler.
01:26:40 <mreh> sorry, i'm switching windows and pressing up a lot
01:26:42 <shachaf> That's the holy grail. Sadly no modern Haskell compiler implements 1.4.
01:26:50 <Zira> shacaf: Is the one linked to above one of those?
01:27:08 <shachaf> Zira: Sorry, that was a joke. GHC is the compiler you want for almost all practical purposes.
01:27:18 <Zira> I see.
01:27:23 <merijn> Zira: You want to download the Haskell Platform instead of GHC if you're new, since that comes with a lot of useful libraries
01:27:39 <shachaf> And also what merijn says.
01:27:57 <engla> Zira: why do you want to use haskell 98 (it's an older version of the language)
01:28:06 <Zira> I think I downloaded the platform, but it installed GHCi.
01:28:15 <Zira> Oh. The tutorial mentions Haskell 98.
01:28:15 <merijn> And GHC can compile Haskell 98 just like any (useful) C compiler can compile C89. Like a C compiler you might need to specify an option to enforce this
01:28:27 <shachaf> Zira: It installs ghci as well as a bunch of libraries and such.
01:28:30 <Zira> Or, well, user guide.
01:28:46 <merijn> Zira: Haskell 98 is the old standard, GHC supports many newer extensions as well.
01:28:47 <shachaf> Zira: Haskell 2010 is newer than Haskell 98, but the differences aren't significant for tutorial purposes.
01:28:59 <shachaf> (In fact, it's newer by 1912 years!)
01:29:18 <luqui> lol
01:29:21 <merijn> Zira: Which guide are you reading?
01:29:24 <shachaf> Zira: Which tutorial are you using?
01:29:46 <Zira> I started with http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/users_guide/index.html  but decided to continue with http://learnyouahaskell.com/introduction#about-this-tutorial   (along with Try Haskell)
01:30:15 <merijn> Zira: Ah good, Learn You a Haskell is much better then the GHC user guide :p
01:30:35 <shachaf> The GHC user's guide is probably not optimal for learning Haskell. :-)
01:30:35 <luqui> Haskell 98 was designed by Jesus's long lost son, simon peyton-curry christ
01:30:50 <shachaf> (Optimal would be reading the GHC source, of course.)
01:31:26 <engla> shachaf: which is in haskell..
01:31:44 <shachaf> engla: Right. You learn twice as quickly.
01:32:08 <engla> shachaf: you'll learn lazily. suddenly all the thunks will evaluate to knowledge
01:32:54 <engla> but a stack overflow is more likely
01:32:56 <luqui> there is no guarantee one of them won't diverge
01:33:17 <luqui> use stackoverflow in the case of a stack overflow
01:34:50 <shachaf> @quote is.coming.from
01:34:50 <lambdabot> copumpkin says: <kmc> do you have a theory where the stack overflow is coming from? <copumpkin> joel spolsky
01:35:53 <Zira> Is Haskell similar to Python in how compiling works?
01:36:05 <merijn> Zira: No
01:36:05 <ddarius> Python is usually not compiled.
01:36:11 <shachaf> Zira: Those are both languages.
01:36:13 <engla> Zira: but GHCi is awesome
01:36:25 <shachaf> Zira: Implementations are interpreters/compilers, but languages aren't.
01:36:39 <merijn> Zira: Python gets compiled to bytecode which is then run inside an interpreter. Haskell is compiled to machine code which gets run natively (like C/C++)
01:36:55 <merijn> By which I mean CPython and GHC haskell, obviously
01:36:56 <shachaf> Haskell is typically compiled, but that doesn't imply much about how you use it.
01:37:39 <ddarius> GHCi compiles to bytecode and executes it, though it can also load machine code and execute it.
01:37:41 <shachaf> Compilation is just an optimization of interpretation, anyway.
01:37:41 <merijn> Before I get manhandled by a bunch of pedants...
01:38:00 <shachaf> There are a number of compilers for Python, and at least one interpreter for Haskell.
01:40:12 <ddarius> Compilation is something totally different from interpretation.
01:40:59 <merijn> I would like to point out that semantic correctness might not always be the most helpful answer to someone's question :>
01:41:01 <engla> Zira: it's similar to python in that you have a REPL that you can experiment with. And test your code piecewise
01:41:15 <engla> (test as in try out)
01:41:39 <ddarius> merijn: The difference is theoretical and practical.
01:41:48 <Zira> I rarely use(d) that part of Python, I mostly put things in files and rand them from prompt.
01:42:01 <Zira> ran*
01:43:05 <Zira> Hence the question about compiling, as that would be a problematic approach if compiling takes some effort.
01:43:39 <shachaf> Zira: How much effort could it possibly take?
01:43:58 <luqui>  merijn, "which way the bathroom!!!??"   "which way _is_ the bathroom?"
01:44:02 <shachaf> Anyway, you can just run Haskell programs by running the Haskell program runhaskell.
01:44:15 <merijn> Zira: There is an interpreter runhaskell which lets you use haskell is a scripting language, there is an interactive interpreter like python's interpreter and then there's the option to compile to an executable
01:44:23 <luqui> Haskell : Python :: runhaskell : python
01:44:34 <luqui> sortof
01:46:17 <engla> so the haskell platform already gives you three options there. you have it all
01:50:18 <engla> Zira: btw, there is also this book http://book.realworldhaskell.org/
01:50:37 <shachaf> Yes, but what Zira is reading right now is probably better.
01:50:40 <Zira> Ooh.
01:51:14 <shachaf> (For learning Haskell, that is.)
01:51:29 <engla> shachaf: yeah, but it's good to have alternatives
01:52:07 <Zira> Integers are not considered True?
01:52:26 <Zira> (For instance 5 && True)
01:52:41 <ziman> no, there's only one truth type called Bool
01:53:24 <ziman> unlike most languages where non-zero/nil/null of any type is interpreted as a true value
01:55:39 <Axman6> "Integers are not considered True?" good god no
01:55:45 <mreh> it's a shame that type profiling only looks at the first constructor
01:56:31 <mreh> if only I could introduce annotations into my datatypes that would appear on profiling output
01:58:16 <mreh> but I can't exactly annotate IO :(
01:59:14 <shachaf> engla: Is it?
02:01:34 <engla> I think so
02:01:41 <Zira> I should go, anyways. Thanks for help/advice.
02:04:20 <osfameron> is there a Truthy typeclass that does the unixish coercion of, e.g. 1 -> True, 0 -> False, or "" -> False, "String" -> True etc. ?
02:05:27 <shachaf> osfameron: I hope not.
02:06:16 <osfameron> shachaf: oh?  it'd potentially be useful for haskell in shell scripts.  Anyway, just a curiosity.
02:06:22 <PatrickRobotham> osfameron: Even if there were, you still couldn't do "1 && True".
02:06:30 <osfameron> sure
02:06:35 <osfameron> unless you redefined && ;-)
02:07:03 <PatrickRobotham> (Boolean a, Boolean b) -> Bool ?
02:07:11 <PatrickRobotham> Sorry, let me amend that
02:07:22 <PatrickRobotham> (Boolean a, Boolean b) => a -> b -> Bool
02:07:49 <PatrickRobotham> Is that what you're looking for osfameron?
02:08:12 <PatrickRobotham> (Here Boolean means "Supports unixish conversion")
02:08:12 <osfameron> heh, I guess
02:08:13 <kmc> that's unixish osfameron?
02:08:17 <osfameron> as I say, just a curiosity
02:08:45 <osfameron> kmc: well, I had been going to say "perlish" but it's widespread in unixy languages, so I changed the phrase
02:08:51 <PatrickRobotham> osfameron: Well, I kind of agree with shachaf that such an idea is a godless abomination.
02:08:52 <engla> why not define instance Num Bool
02:09:02 <PatrickRobotham> engla: Num Boolean
02:09:05 <PatrickRobotham> engla: Bool is a type.
02:09:10 <osfameron> PatrickRobotham: yes, but *fun* godless abomination ;-)
02:09:12 <PatrickRobotham> Type's can't be instances of types.
02:09:17 <engla> well that's what I meant
02:09:19 <PatrickRobotham> osfameron: I never said I was against it :P
02:09:48 * PatrickRobotham wouldn't want it as part of the standard library though
02:09:56 <osfameron> I think a boolValue function in a typeclass wouldn't be a bad thing
02:10:02 <osfameron> fucking with && and so probably would ;-)
02:10:36 <PatrickRobotham> class BoolCoercable a where boolValue :: a -> Bool
02:11:11 <engla> This is what you need :-)  instance Num Bool where fromInteger 0 = False fromInteger _ = True
02:11:16 <engla> (add linebreaks)
02:11:22 <platzhirsch> Hey fellows, after 2 years abstinence of Haskell, I got myself a copy of Real World Haskell, diving back into functional programming :)
02:11:38 <osfameron> platzhirsch: yay!
02:11:59 <kmc> a lot of things have changed in 2 years
02:12:07 <platzhirsch> yay!
02:12:07 <ziman> platzhirsch, welcome back ;)
02:15:26 <Chaze> platzhirsch: i'm pondering whether i should get "programming in haskell" or "real world haskell".. why did you pick the latter?
02:16:04 <platzhirsch> Chaze: Because I had already experience with Haskell, but I would like start writing applications with a meaning to the outside world
02:17:00 <merijn> Chaze: I would say it depends on your experience
02:17:19 <kmc> PIH is not free online, is it?
02:17:20 <kmc> RWH is
02:17:33 <merijn> Chaze: Real World Haskell reads more like a collection of tutorials for various frameworks/libraries then a haskell teaching book
02:17:34 <kmc> so if you're only going to buy one...
02:17:36 <Chaze> well, if its about "real world" stuff like reading from files or formatting output, no thanks
02:17:52 <merijn> I don't know Programming in Haskell
02:18:06 <kmc> http://book.realworldhaskell.org/read/ topics list
02:18:08 <shachaf> Programming in Haskell is good.
02:18:16 <shachaf> It's not available online, though.
02:18:22 <kmc> i knew haskell before i read RWH, but I appreciated a lot of the topics chapters
02:18:38 <tijn_> I want to do a list comprehension , but for every size I have to make another function, for example: makeAlphabet3       =   [ [a,b,c] | a ← s, b ← s, c ← s] ]
02:18:38 <tijn_>                         where s = ['a'..'z'] ⊕ "_"
02:18:45 <kmc> "The foreign function interface", "Basic concurrent and parallel programming", "Profiling and tuning for performance", "Software transactional memory"
02:18:56 <tijn_> what would be a nice way?
02:18:58 <shachaf> tijn_: You can't use where, but you can use let.
02:19:00 <kmc> that's the sense of "real world"
02:19:11 <shachaf> [blah | a <- s, let s = ..., blah, blah]
02:19:19 <shachaf> I don't know if that's actually nice, though.
02:19:32 <Chaze> so if i don't need an introduction from zero, i should go for RWH then..
02:19:42 <kmc> shrug
02:19:45 <kmc> like i said, it's free online
02:19:50 <kmc> you can browse it and make up your mind
02:20:01 <tijn_> but for a sequence of 4 letters I have to do: makeAlphabet4       =   [ [a,b,c,d] | a ← s, b ← s, c ← s, d <- s] ]
02:20:01 <tijn_>                         where s = ['a'..'z'] ⊕ "_"
02:20:16 <kmc> there are different schools of thought on how to teach Haskell
02:20:24 <tijn_> I would like to make: makeAlphabet n     =  ...
02:21:09 <kmc> also different schools of thought on how to convince people to learn Haskell
02:21:25 <kmc> one is to wave your hands and preach about the ineffable beauty of functional programming and try to induce a sort of religious conversion experience... then convince them that Haskell is the best language given that worldview
02:21:28 <Chaze> oh nice, i didn't know there was a free online version!
02:21:31 <kmc> the second part is easy but the fist part is rather hard
02:21:39 <Chaze> (how the hell are they going to sell ebook then?)
02:21:58 <kmc> the other approach is to show concrete examples of doing things in Haskell that you'd naturally want to do in other languages
02:22:13 <kmc> RWH tends toward the latter
02:22:47 <shachaf> Sometimes you don't know that you'd want to do things that you'd want to do. :-)
02:22:59 <kmc> parsing
02:23:02 <kmc> ...
02:23:06 <kmc> ok
02:23:20 <shachaf> And that was after my simplification pass!
02:24:42 <Chaze> that online version is nice! all the code snippets even have a comment feature
02:25:04 <kmc> also all the text paragraphs
02:25:18 <platzhirsch> I really appreciate the comments, since to some book receptions there seem some flaws or missing parts in the codes
02:26:29 <kmc> > replicateM 5 "abc"  -- tijn_
02:26:30 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaba","aaabb","aaabc","aaaca","aaacb","aaacc","a...
02:27:06 <shachaf> > replicateM_ 5 "abc"
02:27:07 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
02:32:03 <Oxfaded> is it possible to have a data definition accross two files. I have some generated boiler plate as well as some hand writen types that should idealy be part of the same data definition but need to be in separate files
02:32:21 <quicksilver> no, Oxfaded
02:32:21 <lambdabot> quicksilver: You have 1 new message. '/msg lambdabot @messages' to read it.
02:49:10 <mreh> quicksilver: this is odd, every writeMyChan in my keyboardMouse callback is taking longer and longer, and every mappend with that event stream takes longer and longer as times goes on
02:49:19 <quicksilver> ah hmm
02:49:30 <quicksilver> I do remember worrying if there might be a problem with mappends
02:50:00 <mreh> it's coming from snapshotR
02:50:09 <quicksilver> it builds larger and larger thunks of mempty `mappend` mempty `mappend` mempty or something
02:51:00 <tijn_> \msg kmc   tnhx kmc, how did you find that? or did you just know about it?
02:51:12 <mreh> i don't suppose you saw it with your explicit looping, i'm using a snapsot instead
02:52:02 <kmc> tijn_, knew about it
02:52:03 <mreh> it sounds about right, because they grow linearly
02:52:40 <KitB> Is there a canonical matrix library
02:52:42 <KitB> ?
02:53:09 <mreh> KitB: hmatrix is kind of good
02:53:24 <mreh> it's a wrapper around some C matrix libs
02:54:04 <KitB> I'm going to want to be implementing some basic matrix algorithms as practice for my ADS class pretty soon
02:54:19 <KitB> (Strassen next week for instance)
02:54:57 <mreh> quicksilver: oh, i think it's the catmaybes trying to join all those mempties
02:55:21 <mreh> all those Nothings coming from a snapshotWithR
02:55:29 <mreh> at regular intervals from a ticker
02:55:59 <mreh> Nothing signifies a non changing Reactive value so it simply uses the last one
02:56:40 <KitB> So I don't need anything prebuilt for me
02:56:50 <KitB> Would I be better off using BLAS or HMatrix?
02:56:54 <KitB> (Or something else?)
02:57:39 <mreh> hmatrix uses BLAS
02:57:57 <KitB> I'm aware
02:57:57 <mreh> it's a haskell wrapper
02:58:20 <mreh> it depends what you need, if i'm doing simple 2d graphics I just use 2 and three tuples
02:58:35 <KitB> I'll be implementing classical matrix algorithms
02:58:49 <mreh> KitB is it for fun?
02:59:06 <KitB> For a class
02:59:13 <KitB> Though it's not mandated that we do it
02:59:22 <KitB> It's recommended that we implement the algorithms we encounter
02:59:28 <KitB> and I'd like to do it in Haskell
02:59:50 <mreh> well just do it with your own datatypes for vectors and a matrices
03:00:08 <mreh> if you only want to understand the algorithms
03:00:46 <KitB> I'd also like to have relatively good performance
03:00:54 <KitB> I suppose I could implement them from scratch
03:01:12 <KitB> I was just looking for a Matrix data type and possibly example implementations in Haskell
03:01:33 <KitB> In case I had any trouble converting from an imperative style (not that I expect to)
03:01:43 <mreh> some people use Maps for sparse matrices
03:06:40 <mreh> quicksilver: so these mempties are not being evaluated, would that be the correct inference?
03:06:50 <mreh> mappend mempties
03:07:08 <KitB> thanks mreh
03:07:20 <KitB> I'll probably make my own data types and see if I can work with them
03:07:33 <mreh> KitB, get it working before you worry about efficiency
03:08:01 <KitB> mreh: I was taught exactly that by Phil Wadler
03:11:30 <Phyx-> hmm, question, if you open a .hs file in mkDepends mode using the GHC API, does that generate an object file?
03:12:43 <quicksilver> mreh: it's not that they're not being evaluated, it's that they keep taking up space (and time to compute)
03:12:54 <quicksilver> mreh: I could be wrong, because I don't remember the details very well
03:13:18 <quicksilver> mreh: yes, you could be right (just read your last message) - the catMaybes skipping all the Nothings takes time
03:13:30 <quicksilver> until it can 'clip' down hmm
03:13:40 <quicksilver> @messages
03:13:41 <lambdabot> Saizan said 10h 39m 22s ago: this fix trick (by ion) solves the ScopedTypeVariables debate, i think :) https://gist.github.com/1188115
03:13:51 <mreh> quicksilver: what causes the clipping?
03:13:55 <mreh>  later event?
03:14:14 <quicksilver> should do yes
03:15:23 <mreh> quicksilver: i'll write some simple test cases, it appears that it should be clipping here, from what I understand
03:16:54 <mreh> mappend for Event has no special case for mempty
03:17:03 <mreh> it just creates an event with NoFuture
03:17:24 <mreh> it maps a function over noFuture, which produces Never
03:18:32 <mreh> just an observation
03:18:54 * quicksilver nods
03:19:16 <quicksilver> NoFuture is ok because it's special
03:19:33 <quicksilver> but events which never occur for a more complex reason than NoFuture
03:19:42 <quicksilver> can be problematic, as far as I can remember.
03:21:27 <mreh> i keep confusing my intuitive notion of events with Reactives
03:22:37 <quicksilver> well they are the same really
03:23:10 <quicksilver> the only difference is that (1) a reactive's value is understood to 'continue past' the event, rather than being instaneous
03:23:22 <quicksilver> (2) a reactive has a value 'at the beginning' before anythign has occurred
03:23:56 <mreh> i meant, Reactive's notion of Events :)
03:24:08 <mreh> a series of labeled values
03:24:47 <quicksilver> mreh: yes. I know you did.
03:24:56 <quicksilver> the type 'Reactive a' and 'Event a' are almost the same thing.
03:25:05 <quicksilver> the two differences above being the differences.
03:25:14 <quicksilver> oh, I see
03:25:19 <quicksilver> I did misparse you :)
03:25:30 <quicksilver> what is your own notion of event, that is different?
03:28:15 <mreh> quicksilver: a value paired with its occurance
03:28:21 <mreh> anyway, not important
03:37:53 <erus`> has anyone heard of a language that only allows data exchange through channels? ie. functions can not return values, only channels
03:40:30 <hpaste> aleator pasted “cabal sdist wtf” at http://hpaste.org/51829
03:40:42 <aleator> Anyone seen the above?
03:41:01 <aleator> I'm really curious on what is going on there.
03:41:38 <Phyx-> hm, does ghc require -fPIC when compiling with -shared?
03:43:23 <buntfalke> Hi
03:43:40 <mreh> hello
03:44:28 <buntfalke> Module C imports Module B, which imports Module A, so in C, module A is not accessible, unless a) it is explicitly imported in C as well, or b) it is explicitly added to the exports of module B.
03:44:31 <buntfalke> Correct?
03:44:50 <mreh> buntfalke: sounds right
03:44:52 <buntfalke> Is there a 3rd way to get A to C?
03:44:53 <hpc> yes
03:45:06 <mreh> i don't know of one
03:45:07 <hpc> buntfalke: write a GHC extension :P
03:45:21 <mreh> copy and paste the code into C
03:45:53 <buntfalke> Yeah, right. I read this as a "No" :-)
03:45:54 <buntfalke> Thanks!
03:47:51 <hpc> buntfalke: one common practice is to write module Where.Your.Code.Is.Imports
03:47:59 <hpc> with all your common imports in there
03:48:18 <hpc> then every file imports BlahBlah.Imports and you're set
03:48:47 <hpc> (until you need something like parsec or Map, which clash with Prelude)
03:49:48 <buntfalke> Yes, I just wanted to test myself and be sure I got things right. Tomorrow is examination day and I'm rather nervous about it all...
03:52:08 <d34df00d> Oh, so sad there is no Control.Arrow.first for (a, b, c).
03:54:01 <hpc> d34df00d: in general, tuples beyond size 2 aren't supported by anything
04:07:21 <hpaste> boegel annotated “transformers fail” with “transformers fail (annotation)” at http://hpaste.org/51825#a51830
04:17:41 <Phyx-> weird..
04:17:43 <Phyx-> <?xml version="1.0" encoding="UTF-8"?>
04:17:43 <Phyx-> <string xmlns="http://zhox.com/">qUqP5cyxm6YcTAhz05Hph5gvu9M=</string>
04:17:46 <Phyx-> oops
04:18:20 <Entroacceptor> indeed weird
04:18:29 <Phyx-> [phyx@vmware Utils]$ sudo ghc-pkg expose ghc
04:18:29 <Phyx-> ghc-pkg: cannot find package ghc
04:18:38 <Phyx-> was supposed to paste that
04:18:39 <Phyx-> lol
04:20:46 <Phyx-> anyone know why i get that?
04:20:49 <Zr40> I've got Haskell code that assumes 64 bit Ints. Now, when I compile in Windows, Int appears to be 32 bit. Can I force ghc to use 64 bit Ints?
04:21:40 <roelvandijk> Zr40: Why not use Data.Int.Int64?
04:23:09 <Zr40> roelvandijk: !! only accepts Int
04:23:51 <Phyx-> does -shared imply -dynamic
04:24:19 <leod> Zr40: there's genericIndex
04:24:25 <roelvandijk> Zr40: How about genericIndex :: Integral a => [b] -> a -> b
04:24:50 <engla> you can override !! with genericIndex, but I don't know how practical that is
04:25:05 * Phyx- taps the mic
04:25:07 <Phyx-> is this thing on
04:28:39 <Zr40> roelvandijk, leod: thanks, didn't know about genericIndex
04:32:37 <leod> hmm, I wonder why genericIndex requires Integral instead of just Num
04:34:28 <Phyx-> leod: what would index 1.5 do?
04:34:46 <engla> leod: toInteger is in Integral
04:35:05 <aavogt> @ty fromIntegral . (`asTypeOf` (undefined :: Integer)) . genericIndex
04:35:06 <lambdabot>     Couldn't match expected type `Integer'
04:35:06 <lambdabot>            against inferred type `a -> b'
04:35:07 <lambdabot>     Probable cause: `genericIndex' is applied to too few arguments
04:35:23 <aavogt> oops, I understood genericIndex as genericLength
04:35:30 <leod> hmm, as far as I can see genericIndex uses only (>), (-) and pattern matches on 0
04:36:27 <Oxfaded> noob question - im inside the put monad and I want to 'map' put across all elements of a list. map isn't the right word there. is there another function to do what i want?
04:36:30 <leod> so it would probably never terminate on index 1.5, huh
04:36:51 <leod> oh, it checks for negative indices. right
04:37:14 <Ptival> @type mapM
04:37:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:37:32 <Ptival> @type forM
04:37:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:37:37 <Oxfaded> the return type should be a putM
04:37:48 <Oxfaded> putM ()
04:37:54 <Oxfaded> not a putM ([a])
04:37:56 <Ptival> @type mapM_
04:37:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:38:15 <Oxfaded> ok that looks like it
04:38:17 <Oxfaded> thanks
04:48:51 <deech`> Is qthaskell still maintained? I see a release from last year, but no link to a repository of any kind from the project page (https://developer.berlios.de/project/showfiles.php?group_id=10072).
05:15:58 <engla> I'm baffled that the haskell sources for base modules are so easy to read. You know, C doesn't even have easy-to-read header files
05:17:44 <dankna> indeed
05:18:08 <Ke> there is mostly no reason to make things difficult
05:18:38 <deech`> engla: Yeah, sometimes I feel that Haskell is read-only.
05:18:41 <geheimdienst> ke: ... except in the haddocks ... 8-)
05:26:10 <Luam> can someone help me what to choose Yesod or Snap for web development and mb is there who use both?
05:27:04 <dmwit> Luam: Good question!
05:27:29 <dmwit> So good, it's been asked (and answered) already.
05:27:32 <dmwit> http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks
05:27:42 <dmwit> That's from googling "yesod snap".
05:28:05 <dmwit> There are many other such discussions returned, too. Enjoy. =)
05:28:53 <McManiaC> uhhhhm, how do I get the number of seconds from a difftime as float/double? it has all those instances, but I'm kind of lost which one to use atm :) http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Clock.html#t:DiffTime
05:29:38 <Luam> ;)
05:32:34 <McManiaC> or why do I get     No instance for (RealFrac DiffTime)
05:32:41 <McManiaC> even if that instance is listed there?
05:32:43 <McManiaC> hmm
05:32:54 <geheimdienst> maybe you don't have it imported?
05:33:15 <McManiaC> I have Data.Time imported
05:35:05 <engla> McManiaC: it's NominalDiffTime
05:35:34 <geheimdienst> McManiaC: this suggests "floor $ toRational", but it feels a little weird http://www.haskell.org/pipermail/haskell-cafe/2009-June/062544.html
05:36:01 <noob> hi everybody
05:37:28 * geheimdienst is every time stumped how to do simple things with Data.Time
05:37:55 <McManiaC> geheimdienst: how would you turn a Rational to a Float?
05:38:21 <quicksilver> realToFrac will convert a DiffTime directly to a Float
05:38:24 <quicksilver> or a Double
05:38:41 <quicksilver> realToFrac is the all-purpose fractional number convertor
05:38:42 <McManiaC> quicksilver: thanks a lot :)
05:38:52 <quicksilver> @quote realToFrac
05:38:53 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
05:39:03 <quicksilver> lambdabot: scoundrel.
05:40:29 <Luam> dmwit: i didnt find something that will help to choose and see examples of all this frameworks :|
05:45:42 <erus`> whats the easiest way to test ray sphere intersection
05:48:56 <dmwit> erus`: Compute the distance between the ray and the sphere center and compare that distance to the sphere's radius.
05:49:34 <dmwit> Lots of articles online explaining how to compute the distance between a point and a line/ray/segment.
06:04:37 <ohrores> Can anyone help me with my own IO implementation ???
06:05:33 <hpc> ohrores: you're writing your own IO type?
06:05:39 <ohrores> Yes
06:05:46 <hpc> not even chuck norris could help you ;)
06:05:51 <ohrores> I have rewritten it
06:06:20 <ohrores> i have not rewritten the whole libary
06:07:12 <ohrores> ...
06:14:37 <erus`> forgot how to calculate vector length for a minute there.... its been too long since i did this stuff :(
06:17:28 <erus`> dmwit: now i know that the ray and sphere intersect
06:17:39 <erus`> i guess i have to use some trig to work out where?
06:21:53 <ClaudiusMaximus> erus`: sphere is |point - center|^2 = radius^2, ray is point = distance * direction + origin ; so you get to solve a quadratic equation for the distance(s) along the ray
06:22:27 <erus`> i have written this in C before
06:22:33 <erus`> i should dig up the code
06:24:18 <Phyx-> anyone here ever build a shared lib using ghc on linux? is fPIC needed?/
06:24:38 <dankna> you know
06:24:39 <dankna> I have
06:24:40 <dankna> but I don't recall
06:26:06 <Phyx-> when i use -share it doesn't work because it tells me syb wasn't build with -fPIC
06:26:27 <Phyx-> i saw somewhere -optl '-shared' instead
06:26:38 <Phyx-> but that doesn't seem to produce anything
06:27:12 <dankna> hm
06:27:13 <dankna> curious
06:27:24 <dankna> well
06:27:29 <dankna> hm
06:27:53 <Phyx-> now i'm grabbing ghc from source to recompile with --enable-shared
06:28:06 <Phyx-> wonder why the default binaries are not compiled using that
06:29:27 <buntfalke> How to write the equivalent of "int main() {return 0}"? I would need to create an empty IO() action X so I can write "module Main where main = X", how do I do this?
06:30:22 <Phyx-> return ()
06:30:23 <koala_man> buntfalke: return ()
06:30:31 <ClaudiusMaximus> @hoogle exitSuccess
06:30:32 <lambdabot> System.Exit exitSuccess :: IO a
06:30:32 <lambdabot> System.Exit ExitSuccess :: ExitCode
06:30:42 <buntfalke> Ooooooh!
06:30:49 <buntfalke> Thanks!
06:31:05 <buntfalke> Of course...that's what return does, after all...
06:31:28 <Axman6> return is not the same as return in other languages, don't be fooled
06:32:06 <xivix> i'm still new, but return encapsulates a pure value in a monad, is that right?
06:32:13 <mux> yup
06:32:17 <Axman6> all return does is takes some a, and lifts it into some monadic context m: return :: Monad m => a -> m a
06:32:50 <xivix> Thanks again Axman6 for your explanation yesterday
06:32:53 <buntfalke> Axman6: yesye, I know. It makes the "simplest possible monad" of the monad type needed with the value you give it inside
06:33:00 <Axman6> > return () :: Maybe ()
06:33:01 <xivix> i understand lazy evaluation way better now
06:33:01 <lambdabot>   Just ()
06:33:12 <buntfalke> so I get an IO monad with carries a single Unit () member
06:33:18 <Axman6> xivix: good to hear :)
06:33:19 <buntfalke> and that does -- nothing! :-)
06:33:22 <dmwit> The resulting mote need not necessarily have the value you gave it inside.
06:33:33 <Axman6> buntfalke: a monad isn't a 'physical' thing
06:33:57 <Axman6> you don't 'get a monad' by using return or >>=, you're using a monad by using those functions
06:34:00 <buntfalke> Well, I monad is a type constructor with some value you give it, plus some extra information used internally
06:34:11 <dmwit> No.
06:34:15 <dmwit> That intuition is incorrect.
06:34:29 <Axman6> whose?
06:34:34 <dmwit> buntfalke's
06:35:00 <buntfalke> Like "data Debug a = D(a,String)" and "double i = D(i, "double was called!")" and "return a = (a,"")" and so forth for instance
06:35:11 <buntfalke> dmwit: Elaborate, please.
06:35:21 <dmwit> Here's a perfectly good Monad: data Empty a = Empty; return a = Empty; Empty >>= f = Empty
06:35:36 <buntfalke> Ah. Well, true. It need not really store it.
06:35:41 <hpaste> Tiago pasted “recursive functions” at http://hpaste.org/51833
06:35:49 <mux> dmwit: but is that valid haskell 98?
06:35:55 <dmwit> Yes.
06:36:08 <tsousa> http://hpaste.org/51833 in this recursive functions in the third line why do we need the x in the end of the line?
06:36:12 <Axman6> why wouldn't it be?
06:36:33 <buntfalke> Well, what it boils down to is the algebraic structure, but the Debug example is a nice one imho, because it is easy to imagine.
06:36:39 <quicksilver> buntfalke: also your terminology is wrong - not jsut to be pedantic, but it aids communication to get it right :)
06:36:43 <mux> the 'not using the type variable 'a' bit in the definition of the Empty datatype' looked suspicious to me.
06:36:49 <Axman6> tsousa: because replicate' takes two arguments: the number of times you wish to replicate, and what you wish to replicate
06:36:53 <buntfalke> quicksilver: Where, correct it plz
06:36:56 <dmwit> mux: perfectly cromulent
06:37:04 <quicksilver> buntfalke: (i,"double is called!") isn't "a monad"
06:37:08 <quicksilver> buntfalke: it's a value
06:37:14 <quicksilver> buntfalke: Debug is the monad.
06:37:17 <dmwit> mux: Even list does it: data [] a = [] {- here -} | a : [] a
06:37:25 <quicksilver> "a monad" always refers to the type, not the specific value.
06:37:38 <buntfalke> quicksilver: Alright, the data type Debug is, if it is an implemented "instance Monad Debug where"
06:37:43 <quicksilver> yes.
06:37:50 <mux> dmwit: no, it's using 'a', just not in all cases; it's not quite the same
06:37:58 <quicksilver> individual values are sometimes called 'actions' or 'monadic values'
06:38:05 <Axman6> well, that makes it a Monad, but it could always be a monad =)
06:38:09 <dmwit> "mote" has been proposed, and I like that, too.
06:38:10 <engla> tsousa: replicate' (n-1) x  has the type [a], without the x it has a function type
06:38:28 <quicksilver> dmwit: the really surprising thing about Empty is the fact that 'return' doesn't use its parameter. And yes, I do know that it works out OK anyway :)
06:38:30 <Axman6> dmwit: to mean what?
06:38:39 <buntfalke> quicksilver: Though, I would also talk of a "data BinTree" as 'a tree' and I would talk of "Node(root, childL, childR)" as 'a tree' even though the latter is a specific one, and actually a value
06:38:56 <dmwit> Axman6: A value whose type happens to be the application of a Monad to some other type.
06:38:58 <quicksilver> buntfalke: BinTree is 'a tree type'. a Node is 'a tree'
06:39:01 <buntfalke> quicksilver: Ah, right. There's the "action" pronounciation for these. troo.
06:39:02 <tsousa> engla, sorry didnt understand
06:39:17 <buntfalke> true*
06:39:17 <quicksilver> buntfalke: anyhow, my intention is not to argue with you just explain. The phrase "a monad" is never used for  single value :)
06:39:25 <Axman6> dmwit: right. i don't see the need for language to confuse people with
06:39:35 <Axman6> tsousa: did what I say make sense?
06:39:42 <buntfalke> quicksilver: You're correction is valued, don't worry :-)
06:40:27 <dmwit> mux: Regardless, it's perfectly cromulent.
06:40:34 <dmwit> =)
06:40:46 <tsousa> Axman6, the monad stuff? i dont know i am just reading the chapter about Recursivity on LYAH to learn it
06:40:54 <mux> dmwit: yeah, I'm not trying to argue it isn't; I was merely explaining what looked surprising to me :-)
06:41:00 <Axman6> "tsousa: because replicate' takes two arguments: the number of times you wish to replicate, and what you wish to replicate"
06:41:21 <tsousa> so x:x1:x2:x3 right?
06:41:28 <Axman6> eh?
06:41:57 <tsousa> ok i
06:41:59 <tsousa> thanks
06:42:52 <Axman6> replicate 3 True works like this: replicate 3 True -> True : replicate (3-1) True -> True : True : replicate (2-1) True -> True : True : True : replicate (1-1) True -> True : True : True : []
06:43:40 <Axman6> hmm, that's clearer on multiple lines
06:45:07 <benmachine> mux: see Data.Fixed for an example of such a type in the standard libraries
06:45:25 <benmachine> newtype Fixed a = Data.Fixed.MkFixed Integer
06:45:35 <benmachine> (according to ghci's :info)
06:46:07 <benmachine> Axman6: it's also weird how you're doing that subtraction
06:46:32 <Axman6> well, i was skipping a step, the actual evaluation of n
06:47:30 <rwbarton> Has anyone implemented something like Quora's LiveNode in a Haskell web framework?
06:49:03 <benmachine> Axman6: sure, but it's weird to go from 3-1 to 2-1, it looks like you're editing the first argument of the subtraction directly
06:49:11 <rwbarton> (http://www.quora.com/Shreyes-Seshasai/Tech-Talk-Webnode2-and-LiveNode tl/dr: web pages are built from components that track which database entries they depend on, then when those are modified the server automatically rerenders and sends the updated version)
06:50:59 <rwbarton> It sounds like a pretty natural fit for the Haskell pure functions/Applicative/DSL approach
06:52:17 <Axman6> rwbarton: get to it then =)
06:52:37 <rwbarton> Yes, well. :)
06:56:19 <hpaste> Tiago pasted “recursive functions” at http://hpaste.org/51834
06:56:38 <tsousa> another question. how is xs moving forward? http://hpaste.org/51834
06:57:53 <xivix> each time the function recurses, the list's head is taken out as x, and the tail is bound to xs
06:58:07 <tac-tics> tsousa: Haskell's style calls for a space between a and []
06:58:16 <tac-tics> just fyi
06:58:26 <mysticc> It is weird but suppose I have applied some function f1:: a->m a and f2 :: a-> m a .. on a list [a] by map ... Is there any way to print this list like [f1 a,f1 a ,f2 a ......] ??
06:58:36 <tac-tics> also, why do you call it elem' in some places?
06:58:38 <tac-tics> and elem in others?
06:58:48 <tac-tics> this one shouldn't require a helper function
06:58:56 <armlesshobo> mysticc: you could use tuples
06:58:58 <xivix> i'm guessing it was taken from LYAH
06:58:59 <Axman6> tsousa: there's a lot wrong with that code
06:58:59 <tsousa> tac-tics, this examples is in lyah book
06:59:06 <xivix> he defined elem' there
06:59:18 <Axman6> | otherwise a `elem` xs show be | otherwise = a `elem'` xs
06:59:24 <mysticc> armlesshobo: can you explain ??
06:59:45 <tsousa> Axman6, yes i copied it wrong
07:00:11 <tsousa> but my big issue is the logical of the program i am not understanding how xs in moving forward
07:00:21 <xivix> i explained it above
07:00:35 <mysticc> armlesshobo: I was debugging my program which maps a monadic function over a list ... no I dont know how to check if it is correct because I cant print it ..
07:00:40 <xivix> each time the function is called recursively, there is one less element in xs
07:00:48 <xivix> it's been taken out and bound to x
07:01:10 <erus`> i dont see why brackets are needed around tuples
07:01:36 <tsousa> xivix, and what is cutting of the elements?
07:01:38 <quicksilver> erus`: ambiguity with list notation, mainly.
07:01:48 <xivix> it's the pattern (x:xs)
07:01:58 <Axman6> tsousa: the (x:xs) names the head of the list x, and the tail of the list xs
07:02:01 <xivix> it takes the first element (the head) of a list and binds it to x
07:02:09 <xivix> and what Axman6 said
07:02:14 <Axman6> > let (x:xs) = [1,2,3] in x
07:02:15 <lambdabot>   1
07:02:17 <Axman6> > let (x:xs) = [1,2,3] in xs
07:02:18 <lambdabot>   [2,3]
07:02:28 <tsousa> yes
07:02:28 <tsousa> that i can understand
07:02:35 <xivix> so each time the function is called, xs is one smaller
07:02:45 <armlesshobo> mysticc: ahh, I wasn't sure what you're doing. I'm still new to this, but I thought that you wanted to output a list
07:02:45 <Axman6> so you see how xs is smaller than [1,2,3]?
07:02:47 <tsousa> so in the next step the list in xs ?
07:03:05 <mysticc> Any one can help ??
07:03:09 <mysticc> armlesshobo: I was debugging my program which maps a monadic function over a list ... no I dont know how to check if it is correct because I cant print it ..
07:03:11 <Axman6> elem 4 [1,2,3]
07:03:17 <mysticc> It is weird but suppose I have applied some function f1:: a->m a and f2 :: a-> m a .. on a list [a] by map ... Is there any way to print this list like [f1 a,f1 a ,f2 a ......] ??
07:03:18 <benmachine> mysticc: the information of what functions were used to create the list isn't kept in the list, so you can't print it out exactly
07:03:19 <Axman6> hmm
07:03:31 <tsousa> Axman6, i think i got it
07:03:31 <Axman6> that is harder to evaluate over irc >_<
07:03:33 <tsousa> thanks
07:03:35 <mysticc> benmachine: So what should
07:03:38 <mysticc> I do
07:04:03 <benmachine> mysticc: do some different debugging :) what function is it?
07:05:35 <mysticc> benmachine: My program has become very complex ... it uses state monads and all .... I generally map the the functions and then fold and then supply the initial state .. but I am not able to get why it is giving wrong result ...
07:07:04 <PatrickRobotham> foucist: I'm running Linux Mint
07:26:01 <DanBurton> @undefine
07:50:56 <mizu_no_oto> How common of an idiom is it to use foldl with the seed being some sort of data structure?
07:51:25 <mizu_no_oto> something like "foldl (flip Set.insert) Set.empty [1..10]" for a trivial example that doesn't really do anything
07:51:52 <mizu_no_oto> Or is there a better way to do something like that?
07:52:02 <quicksilver> that seems quite common mizu_no_oto
07:59:58 <Botje> mizu_no_oto: there's Set.fromList :)
08:19:18 <mizu_no_oto> Botje:  in that case, yeah.  It was just a simple example of the sort of thing, though
08:21:26 <bfig> how can i add a readerlike function to a typeclass/newtype ?
08:21:35 <bfig> (or data)
08:23:52 <quicksilver> deriving Read, maybe, bfig ?
08:23:55 <quicksilver> not sure what you mean.
08:24:08 <bfig> deriving Read?
08:24:19 <bfig> i mean like ask >>=
08:25:27 <bfig> mmm sounds like state and reader and their transformers are enough for whichever crazy thing i want to do
08:25:29 <ion> Make it an instance of MonadReader, i guess.
08:26:58 <armlesshobo> mysticc: i don't know if your question was answered earlier, but you could just return a list of values after the function is applied
08:27:24 <armlesshobo> mysticc: and refer to the list of values returned to make sure you get the expected results
08:39:18 <tsousa> i am solving problem 8 on euler. how can i check if a bunch of number if there is any five consecutive digits ? in haskell offcourse
08:39:55 <tac-tics> tsousa: in decimal? Convert it to a string first
08:40:05 <tac-tics> > show 1000001
08:40:06 <lambdabot>   "1000001"
08:40:17 <tac-tics> a string in haskell is just a list of chars
08:40:25 <tsousa> like 1234827362813648326 i need to check if any on those number has 5 consecutive numbers
08:40:36 <tac-tics> ah
08:40:41 <tac-tics> still, convert to a string first
08:40:52 <tac-tics> then you can do a search on the string
08:41:28 <Silvah> tsousa: this doesn't sound like problem 8 on Project Euler.
08:41:43 <Silvah> It's "Find the greatest product of five consecutive digits in the 1000-digit number."
08:42:15 <tsousa> oh my bad
08:42:35 <benmachine> yeah, for this problem, in 1847362738, 18473 are consecutive, and 73627 are consecutive
08:42:46 <Cale> > map (take 5) . tails . show $ 1234827362813648326
08:42:48 <lambdabot>   ["12348","23482","34827","48273","82736","27362","73628","36281","62813","2...
08:43:39 <Cale> > map (map digitToInt . take 5) . tails . show $ 1234827362813648326
08:43:41 <lambdabot>   [[1,2,3,4,8],[2,3,4,8,2],[3,4,8,2,7],[4,8,2,7,3],[8,2,7,3,6],[2,7,3,6,2],[7...
08:43:47 <Cale> > map (product . map digitToInt . take 5) . tails . show $ 1234827362813648326
08:43:49 <lambdabot>   [192,384,1344,1344,2016,504,2016,288,288,288,576,576,1728,1152,1152,288,36,...
08:44:36 <Silvah> Cale: you almost solved the problem for him/her.
08:44:43 <Cale> I guess we really should be doing...
08:45:12 <Cale> > map (product . map digitToInt) . (zipWith const <*> drop 5) . map (take 5) . tails . show $ 1234827362813648326
08:45:14 <lambdabot>   [192,384,1344,1344,2016,504,2016,288,288,288,576,576,1728,1152,1152]
08:45:33 <Cale> > map (product . map digitToInt) . (zipWith const <*> drop 5) . map (take 5) . tails . show $ 123482736281364809999
08:45:35 <lambdabot>   [192,384,1344,1344,2016,504,2016,288,288,288,576,576,0,0,0,0,0]
08:45:43 <Cale> > map (product . map digitToInt) . map (take 5) . tails . show $ 123482736281364809999
08:45:45 <lambdabot>   [192,384,1344,1344,2016,504,2016,288,288,288,576,576,0,0,0,0,0,6561,729,81,...
08:45:59 <Cale> ^^ don't want those spurious products of fewer digits
08:46:13 <Phyx-> hmm i have "shared: True" and "flags: -fPIC" set in my Cabal config file, but for some reason ghc is still saying my libs are not compiled with fPIC
08:46:20 <Phyx-> anyone got a clue?
08:46:56 <Cale> There are also more clever things we could do
08:47:07 <Cale> Like splitting the number into segments separated by 0's
08:47:47 <mreh> why could my profiling be saying it ran for 5 seconds? it ran for four times that.
08:48:22 <Cale> mreh: Maybe foreign code took most of the time.
08:48:24 <Phyx-> how do you pass extra flags to ghc to cabal-install? does it get propagated to the dependencies?
08:49:12 <Cale> Phyx-: I've never tried getting that to work...
08:50:15 <Phyx-> Seems no one has.. any documentation i found on the wiki seems outdated, configure doesn't even recognize the flags
08:50:47 <Cale> configure?
08:51:20 <Phyx-> my original problem was that the libs that come with ghc weren't compiled with it either
08:51:28 <Cale> -fPIC is a flag just for GHC. I guess you could put it in the ghc-options: field in the .cabal file.
08:51:36 <Cale> Ah, yeah
08:51:44 <Phyx-> found a wiki that said compile with --enable-shared  would pass the flag along
08:51:50 <Phyx-> but that's no longer recognized
08:51:50 <mreh> Cale, there's no ffi
08:51:59 <Phyx-> so i added it to the build,mk
08:52:07 <Phyx-> fine, that seems to have worked
08:52:16 <Cale> --enable-shared seems to be an option to cabal install
08:52:22 <Cale> at least, it is on my system
08:52:30 <Cale> cabal install --help  lists it
08:52:47 <Phyx-> http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport?redirectedfrom=DynamicLinking
08:52:54 <Phyx-> according to that it should be a flag to configure too
08:53:14 <Phyx-> i assume --enable-shared is the same as setting "shared: True" in the Cabal config
08:53:52 <dankna> it's an option to cabal configure, which means cabal install also accepts it
08:54:10 <dankna> and yes, same I believe
08:55:06 <knoc> hello, importing Control.Monad.State gives me this error:
08:55:07 <knoc> Ambiguous module name `Control.Monad.State':
08:55:13 <Phyx-> so i have shared to True
08:55:14 <knoc>  it was found in multiple packages: mtl-2.0.1.0 monads-tf-0.1.0.0
08:55:20 <Phyx-> and i set flags to -fPIC
08:55:26 <Phyx-> deleetd everything
08:55:28 <Phyx-> rebuild all libs
08:55:31 <Phyx-> and still got
08:55:34 <Phyx-> /usr/bin/ld: /home/phyx/.cabal/lib/syb-0.3.3/ghc-7.0.3/libHSsyb-0.3.3.a(Generics.o): relocation R_X86_64_32S against `.data' can not be used when making a shared object; recompile with -fPIC
08:56:01 <knoc> must I select which package I want to use?
08:56:30 <Phyx-> knoc: yeah, or hide one
08:56:55 <Phyx-> i beleive GHC allows you to specify the package aswell in import, but that's ghc specific
08:57:50 <knoc> Phyx-: ok I'll try that.
09:00:35 <mreh> how can profiling tell me a CC allocated almost nothing, but still have almost the same amount allocated in a heap profile than the most hungry CC i can see?
09:03:55 <mreh> garbage collection that's how
09:08:46 <Silvah> Are there any good trie implementations in Haskell?
09:08:59 <platzhirsch> What was the haskell smalltalk channel?
09:09:49 <mreh> platzhirsch: haskell-blah
09:10:19 <mreh> MemoTries
09:10:24 <mreh> Silvah ^
09:12:36 <Silvah> mreh: you mean MemoTrie? That's what I found on Hackage.
09:20:53 <afo0l> hey guys, any hint on how to resolve this: http://hpaste.org/48653 ?
09:21:18 <tac-tics> afo0l: if it were me
09:21:21 <tac-tics> I'd abandon all hope
09:22:44 <afo0l> i don't understand why it's trying to configure mueval after all, it's already installed
09:23:17 <Cale> Is mueval listed as a dependency of lambdabot?
09:23:29 <Cale> It doesn't really have to be, since it's only a binary package.
09:24:00 <Cale> (lambdabot won't be able to run mueval, so evaluation will be broken if mueval isn't installed, but it'll run without it)
09:24:05 <afo0l> Cale: i removed mueval from the lambdabot.cabal file
09:24:13 <afo0l> now it seems to compile :)
09:24:15 <Cale> cool
10:16:14 <afo0l> hey, anyone happen to use archlinux' ghc and got a hint for me? i get an unknown symbol error in hoogle from hackage when trying to build lambdabot
10:16:37 <afo0l> during linking
10:17:30 <dmwit> Maybe put your error on hpaste.org.
10:18:21 <afo0l> it's a one liner: unknown symbol `hooglezm4zi2zi7_Pathszuhoogle_version1_closure'
10:18:42 <afo0l> followed by unable to load package
10:24:07 * hackagebot GA 1.0 - Genetic algorithm library  http://hackage.haskell.org/package/GA-1.0 (KennethHoste)
10:25:16 <Phyx-> hmm I need to fully purge my Haskell install. What's the best way to do it?
10:28:38 * Phyx- wishes ghc had a panic button
10:29:29 <mpiechotka> Phyx-: Which system?
10:30:06 <Phyx-> mpiechotka: linux, Fedora
10:30:39 <boegel> "* hackagebot GA 1.0 - Genetic algorithm library  http://hackage.haskell.org/package/GA-1.0 (KennethHoste)
10:30:39 <boegel> "
10:30:44 <boegel> w00! \o/
10:31:15 <Phyx-> i assume removing .ghc and .cabal is a great start
10:31:27 <mpiechotka> Phyx-: yum remove + rm -rfv ~/.ghc ~/.cabal && does not work (don't copy & pa ste something given on IRC with rm) does not work?
10:33:16 <Phyx-> well, i didn't install it using yum
10:33:27 <Phyx-> the repo only had 7.0.2
10:33:43 <Phyx-> which is exactly the version i don't support
10:33:58 <mpiechotka> Phyx-: make uninstall doesn't work?
10:34:22 * mpiechotka used to create packages in such situation back when he used binary distros
10:34:25 <Phyx-> doesn't have a rule for that
10:34:41 <Phyx-> but i think this should do
10:34:49 <Phyx-> i needed to remove any and all libs
10:35:23 <Spockz> kosmikus: https://gist.github.com/5670d1a15ad0c95e42a2 is there a way to temporarily disable lhs2tex for that frame?
10:35:43 <mpiechotka> Phyx-: According to gentoo package ghc 7.2 have files in following directories (it may differ on your system/version of ghc)
10:37:20 <Phyx-> mpiechotka: following?
10:37:28 <Phyx-> you forgot a paste :P
10:38:05 <mpiechotka> Phyx-: /usr/share/doc/ghc-7.2.1/ /usr/lib64/ghc-7.2.1/ /usr/lib64/debug/usr/lib64/ghc-7.2.1 /usr/bin/{ghci,ghc-7.2.1,hsc2hs,ghc-pkg-7.2.1,ghc-pkg,runghc,runhaskell,ghc-7.2.1,ghc,hp2ps,hpc}
10:38:24 <mpiechotka> Phyx-: Not so much forgot as hadn't had time to paste
10:38:41 <Phyx-> ah ok :)
10:38:49 <mpiechotka> Oh - and /usr/share/man/man1/ghc.1
10:39:07 <Phyx-> mpiechotka: thanks :) removing those now
10:44:07 * hackagebot dpkg 0.0.0 - libdpkg bindings  http://hackage.haskell.org/package/dpkg-0.0.0 (ClintAdams)
10:52:32 <McManiaC> @pl \a b -> foo (f a) (f b)
10:52:33 <lambdabot> (. f) . foo . f
10:53:58 <Phyx-> hi McManiaC
10:54:08 * hackagebot BiobaseXNA 0.5.3.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.3.0 (ChristianHoener)
10:55:45 <trinithis> @pl \a b -> join foo f a b
10:55:45 <lambdabot> foo f f
10:56:33 <trinithis> oh
10:58:47 <nooodl> are haskell functions memoized by default?
11:00:04 <Younder> nooodl, no, they are not
11:00:30 <nooodl> ah. any easy way to make them memoized?
11:01:00 <Younder> http://www.haskell.org/haskellwiki/Memoization
11:01:21 <joe9> hello
11:01:36 <Phyx-> hi
11:02:21 <nooodl> hey, the memoized_fib example on there is great
11:03:03 <pmetzger> afternoon.
11:03:46 <Younder> I have had great success with tries so I recommend that. Just a solid functional data structure.
11:04:09 <Cale> nooodl: Data.MemoCombinators is really nice
11:04:12 <Phyx-> gaaaaaahh
11:04:18 * Phyx- repeatedly bonks head on table
11:04:21 <pmetzger> sorry to pop in only to ask a question, but has anyone been having trouble with ghc on Mac OS X Lion? It spews vast amounts of ld: warning messages
11:04:28 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.2/doc/html/src/Data-MemoCombinators.html
11:04:36 <engla> stupid trick of the day: redefine (+) in ghci. then come back later and try to do some quick calculations
11:04:45 <Cale> engla: lol
11:04:55 <DukeDave> Whynothappy:     Unacceptable result type in foreign declaration: IO String
11:05:16 <DukeDave> (I have a similar foreign with IO Int below..)
11:05:37 <Cale> DukeDave: Yeah, String isn't a foreign type.
11:05:48 <kmc> maybe you want IO CString
11:05:51 <Phyx-> DukeDave: try CString or CWString instead
11:05:54 <Cale> DukeDave: You'll have to use CString along with some marshalling.
11:05:57 <kmc> type CString = Ptr CChar
11:06:08 <dankna> pmetzger: I don't have a problem with it, but I built my own, I haven't tried the premade binaries
11:06:40 <Younder> The default string functions are functional and slow as molasses.
11:06:44 <kmc> see http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Foreign-C-String.html
11:07:41 <pmetzger> dankna: well, they just seem to be warnings, how do I rebuild ghc easily? (I'm normally just a user of the haskell platform package.)
11:07:42 <Younder> CWString is a monadic version which performs much better.
11:08:01 <dankna> pmetzger: it's not particularly easy, I don't recommend going that route.  what version of ghc are you using?
11:08:03 <DukeDave> Cale: Hmm, okay, thanks
11:08:12 <pmetzger> also, dankna, what version of Xcode do you have? I have 4.1
11:08:22 <pmetzger> it says it is 7.0.3
11:08:27 <pmetzger> (ghc --version)
11:08:39 <Phyx-> ok, now i get a new error
11:08:44 <dankna> also 4.1
11:09:49 <Younder> You would think Haskell would have learn't the lisp lesson. Lisp tried a linked list verson back in the 1960's. It also failed miserably in performance. That was one of the major motivators for array's
11:10:19 <pmetzger> Younder: lisp has both arrays and lists of conses.
11:10:20 <kmc> er, Haskell has arrays
11:10:23 <kmc> lots of different ones
11:10:27 <pmetzger> Younder: and arrays existed before Lisp...
11:10:33 <kmc> and for text there's Data.Text
11:10:34 <dankna> it's okay, inasmuch as we have bytestring as well
11:10:36 <Younder> pmetzger, so it has and it uses arrays for strings
11:10:44 <tac-tics> pmetzger: arrays where *all* that existed before lisp
11:10:59 <Phyx-> isn't this error message asking me to do exactly what i'm already doing? http://pastebin.com/yAjLfgPw
11:11:00 <mauke> The paste yAjLfgPw has been copied to http://hpaste.org/51836
11:11:35 <pmetzger> dankna: any ideas? I literally get thousands of errors like this: ld: warning: text reloc in _cZh_str to _stg_ap_pppppp_info every time I compile anything
11:12:20 <dankna> Phyx-: the only thing I can think of is that it must mean the library it's trying to find the symbol in needs to be recompiled, rather than the one you're trying to build?
11:12:20 <Younder> pmetzger, I am not suggesting lisp invented arrays. I am saying that that random access to sequential memory is required in string handling. In Haskell that means monads
11:12:32 <kmc> Younder, no it doesn't
11:12:41 <kmc> do you know about Data.Text?
11:12:45 <Younder> kmc? elaborate
11:12:50 <kmc> and Data.ByteString
11:13:04 <dankna> pmetzger, haven't seen that one before, curious.
11:13:15 <kmc> Younder, Text provides a pure interface to immutable strings stored as contiguous arrays
11:13:29 <Phyx-> dankna: i've recompiled the compile and every lib, unless cabal install forgot to pass along the flag to the dependencies
11:13:42 <frx> hello
11:13:55 <dankna> Phyx-: hmm, ugh then
11:13:55 <Younder> kmc, immutable is, however a problem, yes
11:13:58 <kmc> Younder, though Data.Text is not random-access, because it uses a UTF-16 encoding
11:14:06 <Phyx-> dankna: been trying all day :(
11:14:52 <kmc> Data.ByteString is a pure interface to immutable byte arrays and does have O(1) indexing and slicing
11:14:53 <hpaste> frx pasted “range” at http://hpaste.org/51837
11:15:01 <frx> I am trying to write range function. range 0 10 should be the same as [0..10]. having some trouble with it: both versions
11:15:18 <frx> s/://
11:15:29 <dankna> it's a pure interface, but it does use unsafePerformIO I believe
11:15:35 <kmc> sure
11:15:45 <zygoloid> frx: you can't pattern match like this: range start start = ...
11:15:45 <frx> both fail to compile, i probably should have included compiling errors but perhaps they are obvious
11:16:06 <Phyx-> @unz
11:16:06 <lambdabot> Maybe you meant: run undo unpf unpl url wn
11:16:11 <zygoloid> frx: use this:  range start end | start == end = ...
11:16:14 <Phyx-> @decode
11:16:14 <lambdabot> Unknown command, try @list
11:16:18 <Younder> kmc: in what way does that the caracter is 16 bit's in length pohibit random access. It is the fact that Data.Text stores strings a a linked list that is the problem
11:16:18 <frx> zygoloid yeah I got that. so no other syntax to pattern match equal first and second argument
11:16:27 <Phyx-> @hoogle raiseIO
11:16:27 <lambdabot> No results found
11:16:38 <kmc> Younder, "Data.Text stores strings a a linked list"  ←  that's factually incorrect
11:16:38 <frx> didn't I do just that in the second attempt?
11:16:45 <zygoloid> frx: nothing standard.you can use view patterns but no-one does
11:16:46 <kmc> so is "caracter is 16 bit's in length"
11:16:59 <zygoloid> frx: the second one, you need a guard after each |.
11:17:01 <pmetzger> btw, why is it that the haskell platform has an older than current ghc?
11:17:09 <dankna> because there are difficulties building it
11:17:09 <kmc> Younder, the space of Unicode code points is *larger* than 16 bits.  not all characters can be represented with a single 16-bit UTF-16 scalar
11:17:10 <zygoloid> frx: | otherwise = [start] ++ ...
11:17:12 <kmc> that is why
11:17:22 <dankna> the person who does that was in here the other day asking for help with a different issue
11:17:22 <Phyx-> is there a function called raiseIO?
11:17:25 <Younder> kmc: oops
11:17:38 <Younder> http://hackage.haskell.org/package/text
11:17:57 <kmc> that's the one
11:18:20 <zygoloid> frx: range begin end = [begin..end] -- ;)
11:18:32 <frx> yes :)
11:18:43 <frx> but not as fun
11:20:16 <frx> it is still whining aboutsomething, can't decypher the error message
11:20:30 <silvio_> hello, can anyone tell me what the type of "id" is in this case with XImpredicativeTypes "fmap id (Just undefined :: Maybe (forall x.x))"? I'd say "(id :: (forall x.x)->(forall x.x))" but that gives a compiling error and if i don't give a type it compiles fine
11:20:35 <Younder> kmc: there ae 4 16 bit panes in unicode. The pain is that most of the mathematical symbols are in 4 which is not part of the standard set.
11:20:59 <Younder> r 18 bits
11:21:06 <pmetzger> not most, just some.
11:21:19 <tac-tics> silvio_: (forall x.x) -> (forall x. x) causes troubles
11:21:22 <hpaste> frx annotated “range” with “range (annotation)” at http://hpaste.org/51837#a51839
11:21:31 <pmetzger> but one does effectively need three bytes for representing unpacked unicode characters, yes.
11:21:35 <tac-tics> silvio_: apply anything to it, and you're left with forall x. x, the type of bottom
11:21:40 <pmetzger> most people don't bother and just use 32 bits...
11:21:40 <tac-tics> @type undefined
11:21:41 <lambdabot> forall a. a
11:21:51 <silvio_> thats what i found out i'm trying to fix a library which doesn't compile in ghc7 anymore
11:22:09 <pmetzger> and it is not 4 16 bit planes, it is much more
11:22:17 <pmetzger> it will not fit in 18 bits
11:22:55 <Younder> pmetzger, I was last time I read the standard
11:22:55 <kmc> well the tradeoff between 24-bit and 32-bit characters wrt. performance is going to be complicated
11:23:06 <pmetzger> younder: have a look now then.
11:23:12 <kmc> most architectures are much happier to work with multiples of 4 bytes
11:23:14 <zygoloid> > log 1114111 / log 2
11:23:15 <lambdabot>   20.087461546321563
11:23:23 <zygoloid> will not fit in 20 bits
11:23:27 <silvio_> no i mean in the real problem its of course not (forall x.x) but (forall x.Something x)
11:23:33 <kmc> but if cache and memory bandwidth are your bottleneck
11:23:37 <pmetzger> maximum code point is 0x10ffff
11:23:46 <kmc> then maybe it's worth it
11:24:12 <pmetzger> you need 21 bits (currently)
11:24:28 <pmetzger> I don't think they're absolutely forbidden from exceeding that, I haven't read the docs in a while.
11:24:32 <zygoloid> iiuc it's 21 bits forever now
11:24:40 <pmetzger> ah, so they nailed that?
11:24:40 <kmc> the maximum codepoint is 0x10ffff but there are large gaps
11:25:32 <pmetzger> I believe planes 3-somethingintheteens are unassigned currently yes.
11:25:46 <pmetzger> ah, wikipedia says 3 to 13
11:27:18 <pmetzger> ah, found instructions on installing ghc 7.2 systems for OS X Lion: https://gist.github.com/1169332
11:27:21 <zygoloid> there's 2048 codepoints which they're never going to assign, to ensure that utf-16 is complete
11:27:25 <pmetzger> is that reasonably reliable information?
11:27:50 <pmetzger> (about ghc, not about unicode, I know that bit is true. :) )
11:28:06 <FUZxxl> Is there a good library for matrices?
11:28:33 <osfameron> FUZxxl: ai-class?
11:28:46 <osfameron> (lots of people seem to be asking that at the moment ;-)
11:28:52 <osfameron> FUZxxl: hmatrix is the one people seem to mention
11:28:59 <dankna> pmetzger, let me look at it
11:29:03 <gwern> :t (:)
11:29:04 <lambdabot> forall a. a -> [a] -> [a]
11:29:45 <tac-tics> @type undefined : undefined
11:29:46 <lambdabot> forall a. [a]
11:29:47 <dankna> yes that looks pretty good.  when it gets to the bootstrap.sh for the cabal library, I personally never use that, I install those packages by hand, because I usually am using a bleeding-edge compiler that requires some modifications to them to make them build
11:29:47 <Younder> FUZxxl, hs-linear-algebra
11:30:54 <pmetzger> dankna: thanks much!
11:31:09 <dankna> np
11:31:27 <Younder> Personally I prefer Mathematica for matrix intensive things.
11:32:09 <Younder> The support for sparse matrixs helps.
11:33:30 <FUZxxl> osfameron: I want to solve some systems of linear equations. Matrices are a good choice.
11:35:37 <frx> do you guys always use those third party array strings or you use built in linked list strings by default, and array strings when you need better performance?
11:35:52 <dankna> frx: the latter
11:42:52 <kmc> frx, the latter
11:43:16 <frx> sounds ogod
11:43:21 <frx> good
11:43:25 <kmc> except sometimes the API or integrated libraries for the fancier type are better
11:43:49 <frx> i kind of like that i can use same functions for string as for list
11:43:55 <frx> map etc
11:44:01 <dmwit> yep
11:44:03 <dmwit> is good
11:44:11 <dmwit> But sometimes wrong, in a surprising way.
11:44:27 <frx> have an example?
11:44:33 <kmc> most libraries which manipulate binary data will have a ByteString API
11:44:36 <dmwit> map toUpper -- WRONG, zero on the final
11:44:45 <kmc> and ByteString IO is more convenient than [Word8] IO
11:44:57 <kmc> oh yeah dmwit?
11:45:26 <dmwit> Yeah. In some languages, a single lower-case character gets mapped to *two* characters when upper-cased.
11:45:39 <kmc> right
11:46:00 <kmc> then toUpper should not have type Char -> Char
11:46:11 <kmc> docs say "Convert a letter to the corresponding upper-case letter, if any. Any other character is returned unchanged."
11:46:21 <dmwit> Yep.
11:46:26 <dankna> well
11:46:30 <dankna> we need a new locale library
11:46:31 <dmwit> Pretty sure the toUpper API is specified by the Unicode spec.
11:46:38 <dankna> which handles this stuff
11:46:39 <kmc> so i guess it will leave those characters unchanged
11:46:59 <zygoloid> also it maps i to I which i think might upset some turkish people
11:47:03 <dankna> there's no one canonical case mapping, it depends on language, as you're saying
11:47:12 <kmc> *nod*
11:47:45 <kmc> turkish uses the vanilla latin codepoint for dotted i?
11:47:54 <zygoloid> i think so
11:47:59 <kmc> awkward
11:48:23 <zygoloid> i could be wrong about that, but istr reading some blog posts about coping with it
11:49:35 <kmc> here's a question:  did anyone here take an undergraduate course which addressed correct text handling in any depth?
11:49:44 <dankna> not I, but I'm not the one to ask
11:50:01 <dankna> if you are going to say "perhaps academia needs to focus more on this basic but important issue", I agree
11:50:12 <dankna> but academia ignores the bottom line until the flood has reached the rafters ><
11:50:16 <dankna> it's what they do ><
11:50:22 <kmc> "academia" implies research, I'm just talking about basic education for working programmers
11:50:29 <dankna> well, that's fair
11:50:53 <dankna> that's what I meant too, I just lumped them together
11:50:54 <kmc> i'd not be surprised if this is one thing that the programming "trade schools" do better than the fancy-pants big name CS programs
11:51:00 <dankna> me either
11:52:45 <Saizan> can't we just punt it until all the complicated languages disappear?
11:52:50 <hpaste> frx pasted “range” at http://hpaste.org/51843
11:53:18 <frx> is my range function really called just 10 times? it seems so because I can increase number and i don't see any delays
11:53:19 <kmc> frx, check out the hpaste warning (you can click it to get more info)
11:53:22 <frx> how is that possible?
11:53:29 <kmc> frx, lazy evaluation
11:53:38 <kmc> > take 10 $ [1..]
11:53:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:53:48 <kmc> (er, unnecessary $ for me)
11:53:52 <dmwit> frx: Yes, it really is called just 10 times.
11:54:31 * zygoloid thinks its tragic that the 'best' introduction to unicode he knows of (spolsky's) claims that UCS-2 == UTF-16
11:54:47 <dmwit> > let unboundedRange n = n : unboundedRange (n+1) in take 10 (unBoundedRange 30) -- frx, note no termination condition!
11:54:48 <lambdabot>   Not in scope: `unBoundedRange'
11:54:48 <kmc> frx, in Haskell, evaluating (f x) does not necessarily evaluate x.  the code for f gets to decide how much of x is evaluated and when
11:54:58 <dmwit> > let unboundedRange n = n : unboundedRange (n+1) in take 10 (unboundedRange 30) -- frx, note no termination condition!
11:54:58 <lambdabot>   [30,31,32,33,34,35,36,37,38,39]
11:55:25 <kmc> it's kind of like the "short circuiting" of boolean operators && and || in C etc.
11:55:33 <kmc> except that those are special cases in those languages, while in Haskell all functions work this way
11:55:33 <frx> kmc i see. i thought compiler did some magic with take 10 $ [1..], didn't expect it to work with my functions
11:56:54 <kmc> frx, this is one of the most interesting / deep / important differences between Haskell and most languages
11:57:04 <kmc> in fact it's the reason Haskell exists
11:57:36 <kmc> and the rationale for other decisions (like being precise about side effects) even though those decisions turn out to have value on their own
11:57:43 <ion> > let unboundedRange n = n : unboundedRange (n+1) in unboundedRange 0
11:57:44 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:57:50 <kmc> i don't know of a canonical document to explain lazy eval... i found http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation just now
11:58:25 <frx> thanks i'll read it
11:58:34 <kmc> http://www.vex.net/~trebla/haskell/lazy.xhtml
11:58:52 <ion> Someone also linked this which i haven’t read yet: http://www.vex.net/~trebla/haskell/lazy.xhtml (but i know http://www.vex.net/~trebla/haskell/fix.xhtml to be excellent).
11:59:02 <kmc> yeah, monochrom wrote that recently
11:59:11 <kmc> or published recently anyway :)
11:59:23 <monochrom> hehe
11:59:33 <kmc> hmm, Cale, you might know... what's the best introduction to lazy evaluation?
11:59:35 <pmetzger> hrm. the ghc 7.2.1 downloads seem to be covered in warnings indicating I shouldn't actually try running it unless I know what I'm doing. and yet if i try the haskell platform on this mac it dies the true death.
11:59:37 <pmetzger> sigh.
11:59:46 <kmc> is there a good detailed writeup of the abstract graph-reduction semantics?
11:59:52 <kmc> (that might be monochrom's article, but I haven't read it yet)
12:00:03 <monochrom> mine is already the best, and in a few weeks I will make it even better (as in more complete)
12:00:59 <dylukes> pmetzger: 7.0.4 does not wok on Lion.
12:01:06 <monochrom> mine is abstract graph reduction. you will see boxes and arrows
12:01:07 <dylukes> pmetzger: its not compatible with the linker.
12:01:15 <kmc> i like the boxes and arrows :)
12:01:21 <dylukes> monochrom: did you generate them with diagrams?
12:01:38 <monochrom> I generate them with a little home-brew program
12:01:40 <pmetzger> dylukes: does 7.2.x work with it? (7.0.3 works poorly on Lion too.)
12:01:45 <dylukes> 7.2.1 works.
12:01:56 <pmetzger> I guess I'll just boostrap cabal from 7.2.1 then...
12:02:04 <dylukes> you'll have to bootstrap cabal-install, yes
12:02:16 <dylukes> but, the hardcoded dependencies in the .sh file were wrong last time I checked
12:02:20 <pmetzger> should I remove my old haskell platform completely?
12:02:22 <dylukes> so you'll need to edit them.
12:02:32 <dylukes> dunno, I clean installed.
12:02:33 <pmetzger> I saw this on what to do for that: https://gist.github.com/1169332
12:02:43 <dylukes> mm yeah
12:04:03 <Blkt> good evening everyone
12:04:08 <dankna> if you know what you're doing (maybe not this time, but next time), you can save yourself a little work by keeping just your old "cabal" binary
12:04:21 <dankna> the catch is that you have to be very careful to not let it stick stale versions of anything else around
12:04:37 <pmetzger> I think I'd rather clean out everything.
12:04:40 <dankna> yeah
12:04:49 <pmetzger> other than a sudo /Library/Frameworks/GHC.framework/Tools/Uninstaller what else do I need to nuke it all?
12:05:37 <dankna> if you installed from the Haskell Platform, there's also I believe a separate /Library/Frameworks/Haskell Platform.framework
12:05:43 <dankna> which you can simply delete
12:05:49 <dankna> I might be wrong about that?
12:05:54 <pmetzger> but that doesn't remove things like /usr/bin/cabal clearly
12:05:58 <pmetzger> so there has to be something else...
12:06:08 <dankna> those are symlinks
12:06:19 <dankna> the uninstaller is supposed to remove them
12:06:27 <pmetzger> which uninstaller? :)
12:06:35 <dankna> oh, hm, yeah, your Cabal came with Haskell Platform, didn't it
12:06:43 <pmetzger> yup.
12:06:48 <dankna> well, the one time I had HP installed, I just deleted those symlinks by hand
12:07:03 <dankna> (ls -l | grep "-> /Library/Frameworks/GHC.framework")
12:07:14 <dankna> (to get the list, then retype it to avoid errors)
12:08:08 <pmetzger> I removed the symlinks by hand. okay. I guess I'm clean now.
12:08:39 <dankna> okay
12:08:41 <pmetzger> oh, and maybe I should nuke my ~/.cabal?
12:08:45 <pmetzger> or should I leave that?
12:08:50 <pmetzger> I worry it may have left fun things...
12:08:58 <dankna> I personally would leave the ~/.cabal/config
12:09:02 <dankna> as that has stuff in it
12:09:09 <dankna> you can safely delete anything else in there I believe
12:09:26 <edwardk> dylukes: is that something they broken between 7.0.3 and 7.0.4 ?
12:09:30 <edwardk> er broke
12:09:36 <dylukes> Broken on 7.0.3 too.
12:09:44 <alpounet> where are we at with type level naturals ?
12:09:45 <edwardk> i'm on lion
12:09:52 <edwardk> and 7.0.3
12:09:53 <dylukes> does ghc --make work/
12:09:54 <dylukes> ?
12:10:03 <dylukes> ghci and interpreter will work.
12:10:05 <dylukes> but compiling breaks.
12:10:06 <Phyx-> well, I just broke my ghc..
12:10:12 <Younder> no, use cabal
12:10:21 <pmetzger> hrm. wonder if I should remove my ~/Library/Haskell/
12:10:27 <pmetzger> so many bits...
12:10:30 <edwardk> i have a rather large bin full of haskell executables i've built here
12:10:36 <dylukes> hm, odd :P
12:10:42 <dylukes> it didn't work for me
12:10:58 <aug_triad> Hello there! Which parameter should I use, when compiling on a mac for unix 64 bit as target? Can I still use my cabal file for compiling my package?
12:11:01 <edwardk> you have xcode and all that?
12:11:29 <edwardk> and if you upgraded the machine, did you upgrade xcode after you did?
12:12:13 <edwardk> i seem to recall having some problems immediately after i installed lion, but re-installing xcode fixed everything
12:14:16 <dylukes> yeah, it has to do with Xcode version
12:14:25 <dylukes> do you have Xcode 4 or 3?
12:14:30 <dylukes> either way, 7.2.1 works great.
12:14:36 <dylukes> aug_triad: yep
12:14:46 <edwardk> 4.1
12:14:57 <edwardk> build 4b110
12:15:23 <edwardk> you?
12:15:38 <aug_triad> dylukes: Thanks, but how…? Google doesn't give me any help :)
12:15:46 <dylukes> just... use cabal install?
12:15:52 <dylukes> it will build to whatever you have ghc built as
12:15:58 <dylukes> pmetzger: one thing
12:16:03 <dylukes> make sure to use the --64bit flag :P
12:16:04 <aug_triad> But I'm compiling on a mac
12:16:10 <dylukes> aug_triad: and?
12:16:13 <dylukes> just use cabal install.
12:16:15 <aug_triad> Target should be unix
12:16:16 <pmetzger> dylukes: you mean when I'm invoking cabal?
12:16:25 <edwardk> aug_triad: you can't cross compile
12:16:49 <aug_triad> Oh… Shit. Then I will find me a Linux machiine. Thanks!
12:17:06 <edwardk> aug_triad: no problem. sorry it wasn't the answer you wanted =)
12:17:56 <ClaudiusMaximus> aug_triad: maybe run a virtual machine with same setup as your target host?
12:18:30 <aug_triad> Yeah, I will maybe try that
12:19:03 <tsousa> why this code isnt solving the problem 9 on euler? code http://dpaste.com/622166/ Problemhttp://projecteuler.net/problem=9
12:19:09 <pmetzger> okay, everything cleared out and I'm downloading this package now: http://www.haskell.org/ghc/download_ghc_7_2_1#macosx_x86_64
12:19:21 <pmetzger> and I'll bootstrap cabal with that (hopefully)
12:19:56 <dankna> okay, good
12:20:04 <edwardk> so what is the official word on when 7.4.1 is coming out?
12:21:15 <roconnor> edwardk: hi edward
12:21:30 <edwardk> yo
12:21:33 <edwardk> long time no talk
12:21:52 <roconnor> What's your opinion on this fancy "new" differential parsing?
12:22:04 <edwardk> derivative parsing?
12:22:21 <edwardk> given that i tried it and rejected it as two orders of magnitude two slow a couple of years back? not impressed
12:22:45 <roconnor> parsing by takingBrzozowski derivatives of grammars
12:22:48 <edwardk> yeah
12:23:02 <edwardk> that was exactly what my 'parsimony' library did as its first parser
12:23:20 <pmetzger> okay, the glorious glasgow haskell compiler v7.2.1 installed. now for cabaliciousness.
12:23:42 <edwardk> roconnor: you can do better by going bottom up though
12:24:31 <roconnor> I didn't realize this differential parsing was top down
12:25:51 <roconnor> I got the impression that is was convienent because you don't have to worry about left/right recursive grammars and parsing often takes less than 1% of your processing time anyways so who cares if it is slow.
12:25:54 <edwardk> my bottom up CYK'ish parser out-performed my top-down derivative parser by like 50%
12:26:08 <edwardk> well, gll has a much better story for that imho
12:26:26 <edwardk> and retains O(n) for LL(1)
12:26:32 <roconnor> gll has no left/right recursion problems?
12:26:35 <edwardk> none
12:26:42 <edwardk> hidden left recursion is supported
12:26:55 <roconnor> that's good
12:27:00 <edwardk> hence why i'm trying to get somce nice combinators for it together
12:27:01 <dylukes> What does trifecta do :0?
12:27:06 <dylukes> just plain old LL?
12:27:15 <dmwit> ?tell tsousa Looks like you're missing a few "<-"s! Also, once you fix that, you're binding 'c' twice and 'a' not at all. And once you fix that, you're drawing from an infinite list, so 'b' and one of 'a' or 'c' will never get to their second possible choice.
12:27:16 <lambdabot> Consider it noted.
12:27:17 <dylukes> with magic ropes no one understands :<?
12:27:19 <roconnor> as long as I can write any grammer I want I'll be happy
12:27:39 <edwardk> dylukes: trifecta does (optionally memoized) recursive descent
12:28:06 <edwardk> which is on the LL side of the spectrum but without the asymptotic guarantees because the monads keep you from forming follow sets
12:28:08 <roconnor> though I'm interested in Phillipa's story about guarded recursivive regular expressions.
12:28:23 <edwardk> roconnor: the VPL/dyck language stuff is useful
12:28:53 <edwardk> though i found references to the general idea by eelco visser way back in 93
12:29:17 <McManiaC> cabal: Can't find transitive deps for haddock
12:29:18 <pmetzger> hrm. I think I'm just going to rebuild 7.2.1 using xcode 4.1 "just in case"....
12:29:21 <McManiaC> what am I missing?
12:29:27 <dmwit> Are any of the language classes covered by these parsers small enough that intersection/equivalence are computable?
12:29:41 <edwardk> and in many ways terry parr's stuff for doing LL(*) also overlaps with it
12:30:00 <edwardk> dmwit: there are boolean grammars, those admit intersection
12:30:08 <edwardk> dmwit: but not equivalence checking
12:30:26 <edwardk> dmwit: and pegs also admit intersection, but go even farther from decidable equivalence
12:31:13 <dmwit> Cool, thanks for the pointers.
12:31:27 <edwardk> i've been trying to adapt the techniques for GLR-based boolean parsing to GLL
12:32:07 <pmetzger> btw, everyone knows about Pager's work on good algorithms for generating LR parsers yes?
12:32:22 <hpaste> “haddock fail” pasted “McManiaC” at http://hpaste.org/51848
12:32:31 <pmetzger> weirdly the algorithm is not widely implemented -- like Menhir or and hyacc are the only places to find it I think
12:32:42 <McManiaC> http://hpaste.org/51848 any ideas why haddock fails?
12:32:45 <edwardk> yeah
12:32:50 <edwardk> HYacc
12:33:10 <gwern> preflex: seen chrisdone
12:33:10 <preflex>  chrisdone was last seen on #haskell 4 days, 23 hours, 20 minutes and 41 seconds ago, saying: the time performance is reliable
12:33:18 <dmwit> McManiaC: GHC >=7.2?
12:33:24 <edwardk> i'd rather go all the way to context-free though if i have to increase from LALR
12:33:28 <McManiaC> 7.0.3 dmwit
12:33:47 <dmwit> huh
12:33:58 <edwardk> though i suppose if you just want to reduce conflicts and retain determinism pager's is a good approach
12:34:01 <McManiaC> should I upgrade? :>
12:34:17 <dmwit> Nope. Haddock explicitly does not support GHC 7.2 or later.
12:34:20 <dmwit> (yet)
12:34:37 <McManiaC> ok
12:34:59 <McManiaC> well, I dont have 7.2 or later
12:35:00 <McManiaC> hmm
12:35:30 <dmwit> oh
12:35:50 <dmwit> Trying to build a package that has an executable and a library, and the executable depends on the library?
12:36:34 <dmwit> McManiaC: ?
12:36:55 <moows> hi, what is the most natural, transparent and safe* way for have something like: list :: (Class o) => [o]? (and safe, in the meaning that you only apply methods defined by Class over the elements of list)
12:36:57 <McManiaC> thaaat might be it
12:37:00 <McManiaC> let me check
12:37:13 <moows> *you can only
12:37:24 <dmwit> McManiaC: If so, supposedly this is fixed in bleeding-edge cabal (not yet released).
12:37:38 <McManiaC> jup builds without the executable, thanks
12:38:00 <dmwit> moows: data IsAFoo = forall a. Foo a => IsAFoo a; [IsAFoo]
12:38:27 <moows> oh, thanks
12:38:48 <dmwit> It's also common to write an instance Foo IsAFoo.
12:58:00 <dmwit> Typing "cabal install" inside cabal's source directory is so... meta.
12:58:21 <dankna> indeed
13:05:37 <pmetzger> okay, trying to bootstrap cabal for the third time now...
13:06:03 <d34df00d> And now, back to that L-M optimization stuff.
13:07:13 <KirinDave> pmetzger: 7.2.1 time?
13:07:17 <pmetzger> yes.
13:07:30 <pmetzger> but now I have a functioning haskell again on my mac!
13:07:31 <pmetzger> hooray!
13:07:37 <KirinDave> pmetzger: Yeah… i have been there
13:07:44 <KirinDave> but then you'll find nothing can be cabal-installed
13:07:55 <pmetzger> oh? :(
13:07:56 <KirinDave> For every package, you need to cabal unpack, fix base, then cabal install
13:08:01 <KirinDave> And it _still_ doesn't work all the time for me.
13:08:07 <pmetzger> whaaaaaa!
13:08:15 <KirinDave> I can't get arrows to install to save my life
13:08:19 <KirinDave> It's convinced Stream is not installed
13:08:34 <pmetzger> should I just shoot myself now and avoid the end of quarter rush?
13:08:52 <KirinDave> I dunno
13:09:03 <KirinDave> 7.2.1 still has the linker error flood.
13:09:12 <Saizan> i think many packages got updated to work with 7.2.1 by now?
13:09:12 <pmetzger> it does?
13:09:14 <KirinDave> So remember to get -optl -w in every cabal file you run.
13:09:14 <KirinDave> Yes.
13:09:20 <KirinDave> Saizan: Some are, it is true
13:09:30 <pmetzger> that was the whole reason I moved to 7.2.1 -- to avoid it.
13:09:32 <KirinDave> pmetzger: It sure does for me.
13:09:35 <dmwit> KirinDave: Don't forget to bump version numbers when you update their dependencies!
13:09:41 <KirinDave> dmwit: Hu
13:09:46 <KirinDave> Maybe that could fix it .
13:10:04 <dmwit> Forget it once, and cabal will barf all over you next time you build something that depends on that package.
13:10:07 <KirinDave> pmetzger: But unlike 7.0.*, in 7.2.1 the linker errors are just warnings
13:10:23 <pmetzger> kirindave: I just rebuilt 7.2.1 from scratch, bootstrapped cabal...
13:10:34 <pmetzger> and I just built a simple program with ghc, no warning flood
13:10:40 <pmetzger> and I definitely had the warning flood before
13:10:46 <KirinDave> Well I definitely still have it
13:10:48 <KirinDave> Lion?
13:10:53 <pmetzger> maybe the fact that I built 7.2.1 from source using xcode 4.1?
13:11:00 <KirinDave> Huh, I dunno.
13:11:03 <pmetzger> (I'm under lion.)
13:11:12 <KirinDave> I want to know what you did right that I did wrong.
13:11:21 <pmetzger> well, I'll tell you what I did.
13:11:28 <KirinDave> pmetzger: Did you follow the gist or use my s3 link for installing cabal?
13:11:31 <pmetzger> 1) Wiped every trace of the haskell platform off the machine. every trace.
13:11:43 <pmetzger> even my ~/.cabal and ~/.ghc stuff.
13:12:04 <pmetzger> 2) downloaded 7.2.1 for the mac (sources), make install
13:12:06 <KirinDave> My version on s3 misses a patch for using local deps. It breaks cabal-dev
13:12:17 <KirinDave> Don't you need a copy of ghc to build it?
13:12:19 <pmetzger> 3) did the cabal bootstrap thing from https://gist.github.com/1169332
13:12:37 <pmetzger> KirinDave: well, reading the instructions in https://gist.github.com/1169332, apparently not...
13:12:48 <KirinDave> I had to have 7.0 around
13:12:48 <pmetzger> er https://gist.github.com/1169332 , ....
13:12:56 <KirinDave> I musta followed a different path
13:13:01 <pmetzger> I totally blew away every trace of 7.0
13:13:05 <pmetzger> I was very thorough
13:13:19 <KirinDave> Deleted the records of the deletion, even!
13:13:48 <pmetzger> :)
13:14:06 <Saizan> pmetzger: that tarball are prebuilt binaries
13:14:22 <pmetzger> well, then I didn't build it from scratch. :)
13:14:24 <KirinDave> Ah
13:14:31 <KirinDave> See I did it from scratch scratch
13:14:35 <KirinDave> With ghc7 as a backup
13:14:37 <pmetzger> but it seemed to be compiling something...
13:14:38 <KirinDave> mayeb that's my problem
13:15:20 <dankna> what you did was a prebuilt binary, yes
13:15:26 <dankna> it wasn't compiling anything, just finding stuff :)
13:16:16 <pmetzger> hrm. I wonder if I shouldn't have used the .pkg file then.
13:16:23 <pmetzger> but anyway it is working now and wasn't before
13:16:31 <pmetzger> which is much better than thnigs were...
13:16:38 <Saizan> working++
13:16:58 <EvanR-work> more software systems should adopt that principle
13:17:46 <Saizan> the one of working?
13:19:43 <pmetzger> Maybe I should just abandon all this stuff and write all my code in unadorned System F. or even the untyped lambda calculus. Go back to basics, you know, before all this "operating system" stuff corrupted everything.
13:20:21 <Blkt> good night everyone
13:21:25 <pmetzger> later.
13:47:41 <xivix> hey there
13:48:04 <xivix> so i'm on the IO chapter of LYAH, and my program's not behaving how he described it
13:48:43 <ddarius> The universe is probably broken.  Try rebooting it.
13:48:59 <xivix> thanks for the tip!
13:49:21 <xivix> seriously, though, it's performing IO statements apparently out of order
13:50:28 <hpaste> xivix pasted “not executing in order” at http://hpaste.org/51850
13:50:34 <Saizan> i bet it's just I/O buffering
13:50:47 <Saizan> i win.
13:50:55 <xivix> Saizan: that's what i thought
13:51:17 <xivix> but how do you make it do everything in order?
13:51:44 <Saizan> you just need to flush, with "hFlush stdout"
13:51:54 <Saizan> after the first putStr
13:51:56 <xivix> okay
13:52:13 <Saizan> import System.IO
13:53:10 <xivix> that did the trick
13:53:21 <xivix> did it not buffer like that when LYAH was written?
13:53:39 <EvanR-work> uhm, you executed IO actions in a certain order and they came out in another order? o_O
13:53:44 <Saizan> maybe they tested it in ghci which sets NoBuffering
13:54:01 <Saizan> EvanR-work: no, they were performed in the right order
13:54:03 <quackquack> What is the difference between a fat arrow (`=>`) and `->` in a type signature?
13:54:15 <xivix> fat arrow is class constraints
13:54:28 <Saizan> EvanR-work: the I/O layer somewhere decided to defer the writing though
13:54:29 <xivix> everything after the fat arrow is the types of the arguments and return value
13:54:53 <ion> :t length
13:54:54 <lambdabot> forall a. [a] -> Int
13:54:56 <xivix> can you compile with nobuffering?
13:54:56 <ion> :t genericLength
13:54:57 <lambdabot> forall b i. (Num i) => [b] -> i
13:55:23 <ion> length returns an Int, genericLength returns a value of a type of the caller’s choosing that’s an instance of Num.
13:55:27 <Saizan> xivix: you can use "hSetBuffering stdout NoBuffering" to set it in your program
13:55:48 <xivix> Saizan: great, thanks
13:56:09 <ion> You should prefer flushing to no buffering, though.
13:56:50 <xivix> obviously
13:57:13 <xivix> I'm sure no buffering kills performance when you write a lot of stuff
13:57:25 <xivix> print* a lot of stuff
13:57:27 <xivix> derp
14:00:10 <EvanR-work> Saizan: i see, so like print foo, launchMissiles, print bar
14:00:16 <EvanR-work> launched missiles, then printed foo bar
14:00:38 <xivix> EvanR-work: exactly
14:00:54 <xivix> my program was launching missiles before i wanted it to
14:00:56 <xivix> :P
14:01:24 <ion> Well, depending on your definition of printing. The usual definition implies buffering.
14:03:57 <xivix> ion: so it buffers more than one IO action by default, but will separate them if nobuffering is set?
14:04:21 <xivix> meaning, it doesn't print characters individually
14:07:40 <ion> xivix: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO-Handle-Text.html#hPutStr%27
14:09:14 <d34df00d> Combining Numeric.FAD and Numeric.GSL.Fitting is a mess.
14:09:39 <d34df00d> The former expects its Dual type (thus I asked here lots of stupid questions last night), the latter works only with Doubles.
14:10:04 <d34df00d> Is it sane to make a typeclass, say, Doublable and call 'toDouble' on values from the rest of the program when feeding them to GSL.Fitting?
14:10:30 <d34df00d> I don't want to scatter all this toDouble/fromDouble special cases in different places in my program.
14:10:37 <ion> :t realToFrac
14:10:38 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
14:11:30 <d34df00d> ion: yep, but I need also the reverse.
14:11:46 <d34df00d> ion: convert from that type back to Dual one.
14:12:14 <d34df00d> FAD provides "lift" function for that, but I guess it does't make sense to lift already Dual number.
14:12:25 <d34df00d> (in case I choose to work globally with Duals, not with Doubles)
14:13:56 <d34df00d> (and it makes, actually, from the maths point of view, as I could understand, but not in my context)
14:14:59 <dthurn> In general in Haskell, do folks usually import each function they use by name, or just import the whole module containing the functions they want?
14:15:07 <dthurn> Or is there an ongoing holy war around the issue?
14:15:12 * d34df00d does the latter.
14:15:24 <d34df00d> Importing things qualified, should they conflict with Prelude or other modules.
14:16:30 <dthurn> Would you say that's the standard?
14:16:58 <tibbe> dthurn: I suggest by-name or qualified, unless the function is defined in the same package, then you can choose
14:17:22 <tibbe> dthurn: if you follow this rule your package will be more robust to changes in other packages (see the package version policy)
14:19:23 <EvanR-work> dthurn: whats the point, you can do different things in different modules
14:19:27 <EvanR-work> why enforce a 'standard'
14:19:41 <EvanR-work> homogeneity for homogeneity's sake
14:22:44 <silvio> hello, can s.b. tell me why this doesn't compile anymore "fmap (id :: (forall x.x) -> x) (Just undefined :: Maybe (forall x.x))"
14:22:53 <silvio> it used to work in 6.12
14:23:24 <Cale> silvio: Impredicative types are no longer really supported.
14:23:45 <Cale> But also, I don't think that type makes sense for id...
14:23:58 <silvio> it worked in 6.12
14:24:06 <Cale> :t id :: (forall x. x) -> x
14:24:06 <lambdabot> forall x. (forall x1. x1) -> x
14:24:08 <shachaf> Cale: It makes sense when you id undefined, doesn't it?
14:24:09 * dsouza googling for impredicative types ...
14:24:14 <shachaf> (forall a. a) -> (forall b. b)
14:24:27 <Cale> ah, yeah, you can lift the forall out
14:24:46 <silvio> yes
14:24:54 <Cale> silvio: But yeah, impredicativity isn't supported by GHC anymore.
14:25:10 <silvio> it still runs if you don't specify the type of id
14:25:18 <Cale> So you can't apply type constructors other than -> to polytypes
14:25:19 <silvio> thats very funny
14:25:45 <Cale> Or at least... you're not supposed to be able to really. There's some remnant of it left in there, which might be working.
14:26:30 <silvio> what does that mean apply type constructors other than -> to polytypes
14:26:35 <silvio> what are polytypes
14:26:55 <Cale> Polymorphic types -- ones with forall at the top of them.
14:27:02 <Cale> Maybe (forall ...)
14:27:20 <shachaf> Why did they change that?
14:27:35 <Cale> Because it was hard to support and nobody used it.
14:30:38 <silvio> ok i thinks i get it. and i can see why some one would thinks it's complicated. But ExistentialQuantification and RankNTypes are still there right?
14:32:56 <ddarius> Cale: People used impredicative types.
14:33:41 <paper_cc> well, people used polymorphic local bindings as well =/
14:33:43 <silvio> yes forinstance in the library grapefruit that i'm trying to compile with ghc7
14:34:05 <ddarius> paper_cc: Extremely rarely and you still can.
14:34:12 * hackagebot happstack-util 6.0.2 - Web framework  http://hackage.haskell.org/package/happstack-util-6.0.2 (JeremyShaw)
14:35:26 <ddarius> At any rate, I'm not saying that impredicative types should have been fully implemented; just that people not using them wasn't one of the reasons they weren't.
14:36:51 <silvio> i'm not really a type expert so. Do you think i can use ExestentialQuantification to hide the impredicative types behind it somehow?
14:37:23 <paper_cc> ddarius: what SPJ says makes me think that the current type system doesn't quite work for local bindings without type signatures (even if it turns out that it actually works every time you use it)
14:38:04 <paper_cc> Hm. Is it true that iteratees and FRP-style streams are actually codata (modelled as partial data)? The "OSes are coprograms" idea feels strikingly similar to FRP "signal processors" to me, and deconstructing streams is just the way you think about iteratees.
14:38:16 * paper_cc is cowrapping his head around codata
14:38:38 <ddarius> I would say they are better modelled by codata types, yes.
14:38:38 <tromp> @src interact
14:38:39 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:39:12 * hackagebot crypto-api 0.7 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.7 (ThomasDuBuisson)
14:43:29 <paper_cc> ddarius: It's that they feel like codata (it's not at all obvious that something "real" can actually "feel" like /this/ after you have read the definition). One of the -café discussions contains strange examples that feel absolutely reasonable after you realize that they are actually merging event streams
14:44:12 * hackagebot crypto-api-tests 0.1 - A test framework and KATs for cryptographic operations.  http://hackage.haskell.org/package/crypto-api-tests-0.1 (ThomasDuBuisson)
14:47:14 <Sawyer> Hi, how to rewrite this foldr using foldl : compress :: (Eq a) => [a] -> [a]
14:47:20 <Sawyer> compress x = foldr (\a b -> if a == (head b) then b else a:b) [last x] x
14:50:37 <jmcarthur> Sawyer: what is the idea here? to remove contiguous duplicates, but not all?
14:50:59 <tac-tics> @type uniq
14:51:00 <lambdabot> Not in scope: `uniq'
14:51:06 <tac-tics> @type unique
14:51:07 <lambdabot> Not in scope: `unique'
14:51:11 <tac-tics> damn lambdabot
14:51:15 <jmcarthur> tac-tics: you are looking for nub, i bet, but it doesn't do this exactly
14:51:21 <tac-tics> hehe
14:51:26 <tac-tics> I feel like a nub now
14:51:27 <tac-tics> @type nub
14:51:28 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:51:50 <jmcarthur> > nub [1,2,3,3,2,5,3,5,7,4,3]
14:51:51 <lambdabot>   [1,2,3,5,7,4]
14:52:00 <tac-tics> @src nub
14:52:00 <lambdabot> nub = nubBy (==)
14:52:01 <jmcarthur> > (map head . group) [1,2,3,3,2,5,3,5,7,4,3]
14:52:03 <lambdabot>   [1,2,3,2,5,3,5,7,4,3]
14:52:07 <tac-tics> smartass lamdabot
14:52:10 <tac-tics> @src nubBy
14:52:10 <lambdabot> nubBy eq []             =  []
14:52:10 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:52:43 <Sawyer> first time using this irc, this confused me, what's lambdabot?
14:52:44 <jmcarthur> the nice thing about nub is that it's pretty lazy and requires only Eq, not Ord
14:53:07 <jmcarthur> Sawyer: lambdabot is a bot. she does many things, many of which are useful for teaching
14:53:43 <tac-tics> Sawyer: He's a haskell interpreter, among many other things
14:53:47 <tac-tics> > 1 + 1
14:53:48 <lambdabot>   2
14:53:48 <Sawyer> oh, got it, so what you mean is that , in this case, shouldn't be rewrite using foldl right?
14:53:50 <tac-tics> @type 1 + 1
14:53:51 <lambdabot> forall t. (Num t) => t
14:54:04 <d34df00d> Oh, finally.
14:54:08 <d34df00d> varredTreeJac t (cNames, vNames) consts vars = (map . map) realToFrac $ jacobian (\cts -> [evalTree (zip cNames cts ++ zip vNames (map (lift . realToFrac) vars)) (morphTreeConsts lift t)]) (map realToFrac consts)
14:54:09 <jmcarthur> Sawyer: was my guess about what you intend correct?
14:54:16 <djahandarie> Sawyer, no one has really answered your question, jmcarthur just asked for clarification.
14:54:43 <d34df00d> Numeric.GSL.Fitting's restriction to work only with Doubles seems a bit, well, restricting.
14:54:57 <Sawyer> my intent was try to learn foldl and foldr, I thought they're transformerable.
14:55:09 <jmcarthur> Sawyer: i suspect that a foldr might be nicer for this overall, since the result is a list and it might be nice for it to be possible to generate it lazily. that said, i don't think your code is optimal
14:55:25 <jmcarthur> Sawyer: they aren't always interchangeable, although you can define foldl in terms of foldr
14:55:59 <jmcarthur> Sawyer: for the record, my version of your function would be:    compress = map head . group
14:56:10 <Sawyer> Oh, got it, thanks for your helpul replies
14:56:43 <jmcarthur> Sawyer: feel free to hang around even if you don't have anything to say. lots of interesting conversation goes on here
14:57:03 <jmcarthur> Sawyer: "lurking" is common on irc
14:57:12 <tac-tics> @type group
14:57:13 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
14:57:16 <kmc> yeah, most of the ~750 people here do not talk regularly
14:57:32 <Sawyer> yeah, DEF!  great place. thanks jmcarthur!
14:57:43 <jmcarthur> welcome :)
14:59:44 <jmcarthur> hm...
14:59:47 <jmcarthur> > group []
14:59:48 <lambdabot>   []
14:59:57 <jmcarthur> alright, my code is safe i guess
15:00:10 <jmcarthur> > map head . group
15:00:11 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
15:00:11 <lambdabot>    arising from a use ...
15:00:14 <jmcarthur> bah
15:00:40 <jmcarthur> > map head . group $ []
15:00:42 <lambdabot>   []
15:00:44 <tac-tics> @src group
15:00:44 <lambdabot> group = groupBy (==)
15:00:51 <tac-tics> damnit, lambdabot
15:01:00 <jmcarthur> but that's the definition!
15:01:19 <jmcarthur> @src groupBy
15:01:19 <lambdabot> groupBy _  []       =  []
15:01:19 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
15:01:19 <lambdabot>     where (ys,zs) = span (eq x) xs
15:01:29 <jmcarthur> @src span
15:01:29 <lambdabot> span _ xs@[]                     =  (xs, xs)
15:01:29 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
15:01:29 <lambdabot>                   | otherwise    =  ([],xs)
15:04:30 <geheimdienst> maybe we should make a "recursive src" thingy. i'd surely use it when i have to follow other people's undocumented serpentine code ...
15:11:21 <Saizan> hasktags?
15:14:08 <BrianHV> are the haskell header files (e.g. HsFFI.h) supposed to be installed with the haskell platform?
15:14:34 <BrianHV> cause I can't find them
15:15:11 <doserj> they should be part of the ghc install
15:16:06 <BrianHV> where should they be?
15:16:15 <kmc> BrianHV, compile your C code with ghc, and it will find it
15:16:23 <BrianHV> aaah...
15:16:31 <kmc> (or better yet, with cabal)
15:16:33 <kmc> mine is in /usr/lib/ghc/include/HsFFI.h
15:17:54 * BrianHV is fighting a losing battle with the llvm backend
15:18:51 <BrianHV> is it unreasonably optimistic to expect C llvm code to talk to haskell llvm code at this point?
15:19:26 <kmc> the Haskell FFI is supposed to work with the GHC LLVM backend, if that's what you're asking
15:19:35 <BrianHV> hm
15:19:37 <kmc> it does not care if the C code was compiled via LLVM or some other way
15:19:43 <kmc> as long as it obeys your platform's C ABI
15:19:58 <kmc> (really, as long as it conforms to the C ABI of whatever C compiler was hanging around when GHC was built)
15:20:06 <napping> If you want to link in bitcode compiled from C, I'm not sure how well that is expected to work
15:20:27 <kmc> what are you trying to do BrianHV?
15:20:40 <BrianHV> yeah... my ultimate goal is to get haskell llvm code to compile to javascript via emscripten...
15:20:56 <BrianHV> it sort of works, but the calling convention is odd, so I wanted to see how a C compiler would handle it
15:21:11 <kmc> ah
15:22:35 <BrianHV> really, the thing I don't understand is why my Int32 -> Int32 function doesn't appear by name or signature in the llvm code. the closest thing to it is a _info function that has four parameters and no return value.
15:22:58 <kmc> a Haskell Int32 -> Int32 function?
15:23:08 <BrianHV> yeah.  doubleMe n = n + n
15:23:12 <kmc> Haskell functions are not C functions
15:23:27 <kmc> the way Haskell code calls other Haskell code is totally different from how C code calls C code
15:23:30 <BrianHV> but something has to be expoerted that C can link with, right?
15:23:47 <kmc> for starters, that Int32 is a heap-allocated object, which could be unevaluated code
15:23:57 <kmc> BrianHV, yeah, that's what "foreign export" is for
15:24:03 <BrianHV> I'm using foreign export
15:24:06 <kmc> oh
15:24:10 <kmc> can you hpaste your code?
15:24:39 <hpaste> BrianHV pasted “Doubler” at http://hpaste.org/51852
15:24:58 <BrianHV> if Int32 isn't what I think it is, that would explain a little...
15:25:01 <BrianHV> but not everything
15:25:49 <napping> you should end up with something like int doubleMe(int)
15:26:12 <kmc> BrianHV, well, there's some automatic marshalling going on when you use a Haskell type in a "foreign" declaration
15:26:17 <BrianHV> napping: that's what I would expect. a stub .h is generated with such a function, but I don't see anything like that in the llvm
15:26:29 <napping> In general, that is - I haven't tried to generate llvm IR with the llvm backend
15:27:18 <kmc> BrianHV, there's also a stub .c
15:27:37 <BrianHV> oh?
15:27:57 <kmc> that defines the actual "doubleMe" C function
15:28:05 <BrianHV> that would be useful...
15:29:54 <BrianHV> I'm getting a .o, but no .c
15:30:01 <BrianHV> this is with ghc -fllvm
15:30:16 <BrianHV> but same with -fllvm
15:30:19 <BrianHV> s/with/without/
15:31:09 <kmc> for me "ghc -fllvm -fforce-recomp -c Doubler.hs" produces both Doubler_stub.c and Doubler_stub.o
15:31:14 <kmc> it should suffice to link in that .o file, anyway
15:31:19 <kmc> i'm using GHC 7.0
15:31:53 <BrianHV> except the .o isn't llvm. that's really what I need at some point.
15:32:06 <BrianHV> let me try those flags
15:32:46 <BrianHV> still no .c. I'm on ghc 7.2.1 on mac
15:33:31 <kmc> what if you add -keep-tmp-files
15:34:14 <BrianHV> nope
15:34:37 <kmc> ah
15:35:21 <hpaste> kmc pasted “Doubler_stub.c (for BrianHV)” at http://hpaste.org/51853
15:35:27 <kmc> that's what mine produces
15:36:10 <kmc> i have to run now, sorry
15:36:15 <BrianHV> np. thanks for the help.
15:36:19 <kmc> maybe someone else here (or in #ghc) would know why you aren't getting _stub.c files
15:53:57 <DukeDave> Hey there, would anyone like to help me debug something in gdb? :|
15:54:03 <DukeDave> I'm having FFI fail
15:55:33 <napping> in gdb?
15:55:38 <napping> :(
15:56:25 <napping> well, I think I used gdb to debug the C side of an FFI problem once upon a time
15:57:23 <DukeDave> I've managed to add a breakpoint in the C++ function I'm calling through FFI
15:57:37 <DukeDave> And it's been hit: Breakpoint 1, 0x0855d946 in wxAny_IsString ()
15:58:41 <DukeDave> But now I'm a little lost..
16:00:10 <napping> just don't look down the stack, and you can probably pretend everything is okay
16:00:17 <DukeDave> Scope for wxAny_IsString contains no locals or arguments.
16:00:26 <napping> hmm, it really was quite a long time ago - probably before the smp runtime
16:00:28 <DukeDave> ^ makes me unhappy
16:00:49 <napping> Sounds like you might not have debugging information for your function
16:00:56 <Cale> Well, the GHC evaluator is, from gdb's perspective, completely insane.
16:02:29 <dmwit> ?remember Cale the GHC evaluator is, from gdb's perspective, completely insane.
16:02:29 <lambdabot> It is forever etched in my memory.
16:03:04 <DukeDave> Woe
16:03:10 * DukeDave is a little out of his depth 
16:03:39 <napping> as long as you have reached a breakpoint in C++ code, you should be able to debug that at usual
16:04:02 <DukeDave> napping: That's what I'd hoped
16:04:04 <napping> I dont know WX or wxHaskell, so it might be difficult to get a debug build if you need one, but that's the general idea
16:04:42 <napping> treat it just like you reached the call in any ordinary program (perhaps one using a crazy stack-switching tricks)
16:05:04 * BrianHV is somewhat familiar with wxWidgets, if that helps at all
16:05:49 <napping> Ah, someone who can offer more than generalities
16:05:51 <DukeDave> BrianHV: I'm going to make you regret saying that :)
16:06:29 <BrianHV> :)
16:06:46 * DukeDave starts working on an example
16:07:41 <BrianHV> I've used wxPython and plain old wxWidgets more than wxHaskell. many of the same concepts apply, but if you're hitting a haskell specific issue I may not be able to help much
16:14:24 <hpaste> DukeDave pasted “FFI problem with wxHaskell” at http://hpaste.org/51854
16:15:28 <DukeDave> Witness the horror.
16:18:08 <DukeDave> It's just such a silly problem :(
16:18:14 <DukeDave> No me gusta :(
16:20:30 <d34df00d> Hm, ghci segfaults if my app uses fitting from GSL.
16:22:13 <BrianHV> DukeDave: I don't see anything obvious... if you change one of those functions to return a constant false, does it print false from haskell?
16:22:26 <DukeDave> BrianHV: It sure does :(
16:24:52 <BrianHV> hm. I find that as puzzling as you do.
16:25:10 * DukeDave is just seeing if he can get "TEST" back out again
16:25:59 <dmwit> ooo, I like puzzles
16:26:03 <dmwit> What code are we looking at?
16:26:51 <geheimdienst> dmwit: http://hpaste.org/51854
16:29:19 <DukeDave> dmwit: I'm trying to wrap a class called wxAny for wxHaskell
16:29:28 <DukeDave> http://docs.wxwidgets.org/2.9.2/classwx_any.html
16:29:37 <afo0l> i get this error: http://hpaste.org/50569 can anyone help me figure what's wrong?
16:30:23 <dmwit> DukeDave: Well, to be completely parallel to the Haskell, the C++ ought to call wxAny_IsInt and wxAny_IsString... =P
16:30:43 <dmwit> DukeDave: Where's withStringPtr coming from, by the way?
16:30:59 <DukeDave> dmwit: That's part of wxHaskell
16:31:04 * DukeDave finds link to code
16:31:38 <dmwit> afo0l: Looks like maybe you're using incompatible versions of haddock and alex?
16:32:03 <dmwit> DukeDave: Oh, that's fine, I can look at the docs myself.
16:32:47 <afo0l> dmwit: ok, thanks for the hint
16:34:43 <dmwit> DukeDave: By the way, why do you do the "foo = new wxAny(); foo = GetValue()" thing? Why bother with making a new wxAny?
16:35:00 <DukeDave> dmwit: I was trying to better mimic the way wxHaskell
16:35:03 <DukeDave> *does it
16:35:30 <dmwit> Wow, really? Why does wxHaskell do that?
16:35:34 <dmwit> Not that it should change anything.
16:35:38 <DukeDave> dmwit: Not sure..
16:35:39 <dmwit> It's just a slow memory leak, is all.
16:36:17 * DukeDave *hopes and assumes* that wxHaskell does *clever things* with new
16:36:30 <DukeDave> (i.e. has it's own allocator)
16:36:34 <DukeDave> *its
16:38:44 <DukeDave> I found (whilst wrapping other methods) that if I (for example) just "return pointer-to-string" then I get a segfault, but if I do:
16:38:44 <DukeDave> "wxString *result = new wxString(); *result = pointer-to-string; return result;" it works..
16:39:06 <DukeDave> That is, in a method which I the import foreign
16:40:08 <dmwit> That's kind of scary. C++ made some really bad choices along the way somehow.
16:40:24 <BrianHV> wait. how were you returning pointer-to-string, exactly?
16:40:49 <DukeDave> dmwit: Tell me about it.
16:41:26 <DukeDave> BrianHV: I use that pattern now, because if I don't it's instant segfault
16:41:57 <dmwit> That must have been a hell of a debugging session. =P
16:41:59 <BrianHV> you shouldn't need to create wxStrings on the heap, btw
16:42:04 * DukeDave is not familiar enough with FFI to attempt to understand why that pattern *seems* necessary 
16:42:25 <DukeDave> BrianHV: I certainly should not :(
16:42:26 <BrianHV> in fact, it's possible doing so would screw up the refcounting, which is why you'd see that behavior
16:42:52 <BrianHV> or are you saying the opposite is happening?
16:43:49 <BrianHV> actually, maybe wxString isn't refcounted...
16:43:51 <DukeDave> BrianHV: Probably the opposite to what you're thinking, perversely it only works if I new on the heap and return a reference to that
16:44:46 <DukeDave> BrianHV: Well I wondered that, but there's so much existing code (i.e. that has been in wxHaskell for a while) which looks leaky, that I can't believe it's gone un-noticed..
16:45:15 <BrianHV> things derived from wxObject are refcounted. things derived from wxWindow get destroyed when the objects that own them get destroyed.
16:45:43 <BrianHV> there are nuances to that, but that's the basic idea
16:45:45 <DukeDave> BrianHV: Good :)
16:46:19 <BrianHV> but there's no way a function like wxString foo() { return wxString("Hello, world"); } should lead to a seg
16:46:21 <DukeDave> In other news, I just tried to get the string back out, and I get back an empty string
16:47:50 <hpaste> DukeDave pasted “Wrapping methods in wxHaskell” at http://hpaste.org/51855
16:48:05 <DukeDave> BrianHV: That's the usual pattern ^
16:48:15 <BrianHV> why return a wxString* instead of a wxString?
16:48:20 <DukeDave> So I assume the 'self' arg gets cleaned up
16:48:32 <DukeDave> BrianHV: Good question!
16:48:45 <DukeDave> I was just 'following the pattern'
16:49:09 <DukeDave> I couldn't find a single other method in wxHaskell which didn't return a pointer
16:49:29 <BrianHV> I'd make that EWXWEXPORT(wxString, wxPGProperty_GetLabel)(wxPGProperty* self) { return self->GetLabel(); }
16:50:04 <BrianHV> I don't know "the pattern," but knowing wx there shouldn't be a reason to use a wxString*
16:50:41 <DukeDave> BrianHV: I can only guess that it's something to do with things being cleaned up prematurely
16:50:50 <DukeDave> But I don't know
16:51:00 <DukeDave> I just find it suspicious that it isn't used anywhere else
16:51:30 <DukeDave> Brb.
16:51:31 <BrianHV> most things are derived from wxWindow and expect to be on the heap. wxString is... different.
16:52:39 <dmwit> Passing pointers is probably more to do with interacting with Haskell's FFI than any C++ thing.
16:54:02 <BrianHV> hm... I found a wxString method in treectrl.cpp and it does indeed follow your pattern
16:56:01 <BrianHV> ditto textctrl. it seems I'm wrong.
16:59:52 <Peaker> What's a nice way to FFI-wrap a large ugly C struct?
17:00:14 <BrianHV> apparently it's FFI day in #haskell. :)
17:01:08 <Peaker> I am trying to do some performance testing on an SSD with Python -- and I'm CPU-bound because of Python :-(
17:01:14 <newsham> where are the docs for cabal-install's config file?
17:01:15 <Peaker> Gonna try to rewrite it in Haskell, but I need bindings
17:01:29 <Peaker> Python can't actually maximize the read capacity of the SSD...
17:01:49 <Peaker> (I'm at 1/5th of the potential... sigh)
17:02:01 <ousado> Peaker: did you try pypy?
17:02:15 <Peaker> ousado: it's an embedded platform -- it's not easy to throw new installs on there
17:02:21 <ousado> ah ok
17:02:44 <dmwit> Peaker: Use c2hs or one of the other binding generators.
17:03:08 <geheimdienst> newsham: in here http://www.haskell.org/cabal/users-guide/
17:03:23 <dmwit> Peaker: In short: you create a new circular Ptr type, and the generators peek at just the right offsets to get the fields you're interested in.
17:03:55 <Axman6> circular Ptr type?
17:04:00 <newsham> geh: i dont see it
17:04:36 <dmwit> Axman6: e.g. newtype BigStruct = BigStruct (Ptr BigStruct)
17:04:43 <newsham> geh: that doesnt seem to document cabal-install.
17:04:48 <Axman6> o.O
17:04:55 <Peaker> dmwit: why Circular?
17:05:04 <Peaker> oh
17:05:20 <dmwit> Peaker: The type system helps prevent a few errors that way. That's all.
17:05:28 <Axman6> why not newtype BigStruct = Bigstruct (Prr ())?
17:05:41 <Peaker> is it better than:  data BigStruct ; newtype BigStructPtr = BigStructPtr (Ptr BigStruct) ?
17:05:52 <geheimdienst> newsham: oh sorry :-/ somehow i misread you as wanting docs for .cabal files. don't know about the config file, unfortunately (it sure has weird syntax)
17:05:56 <dmwit> You can do either of those things, if you like.
17:06:24 <Peaker> how is it customary to allocate stuff for the C side?
17:06:44 <Peaker> e.g: get a valid Ptr BigStruct for its size?
17:07:10 <dmwit> malloc (sizeOf (undefined :: BigStruct))
17:07:48 <newsham> do you know how to specify a global install vs. a local one?
17:07:53 <newsham> in cfg or on cmd line
17:08:13 <dmwit> newsham: one sec
17:08:26 <dmwit> newsham: user-install: False
17:08:30 <dmwit> newsham: in the config
17:08:51 <newsham> ty
17:08:56 <geheimdienst> newsham: on the command line it's --global vs. --user
17:09:01 <dmwit> Peaker: I liked. It's actually just malloc :: IO BigStruct
17:09:09 <dmwit> s/liked/lied/
17:09:13 <Peaker> dmwit: I lie
17:09:18 <dmwit> =)
17:09:20 <Peaker> dmwit: s/lie/like :-)
17:09:53 <newsham> ty.
17:10:00 <newsham> now why cant --help or web page just say that :(
17:10:16 <dmwit> Peaker: The FFI addendum is actually pretty readable if you want a bit more detail.
17:10:24 <dmwit> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
17:10:43 <dmwit> newsham: My ~/.cabal/config has all the possible options and their defaults commented out. Doesn't yours?
17:10:46 <benmachine> newsham: if you move your current config file out of the way and then do cabal update, it'll generate one for you, which (if you're lucky) will have a bunch of options in it, some commented
17:11:07 <newsham> ahh.
17:11:35 <newsham> so just no docs for people who used to use older versions
17:12:17 <Peaker> dmwit: thanks
17:23:21 <djanatyn> I wrote a blog post about a noob's perspective on haskell: http://djanatyn.github.com/2011/09/27/haskell-fun.html
17:23:25 <djanatyn> (hint, I'm the noob)
17:23:32 <djanatyn> Haskell is pretty awesome. :D
17:23:41 <napping> just don't write a monad tutorial ;)
17:24:41 <napping> well, actually I haven't seen a good curmudgeonly one with commutativity diagrams
17:24:54 <djanatyn> also, I messed up
17:25:02 <djanatyn> forgot to put parentheses around the last example
17:25:14 <djanatyn> it's kind of my initial thoughts after finally taking the time to seriously sit down with real world haskell
17:25:18 <napping> which?
17:25:28 <djanatyn> I've been procrastinating learning Haskell for a couple months now.
17:26:17 <napping> ah, if you want it to parse like that
17:26:20 <dolio> I should write a blog post about a noob's perspective on Haskell.
17:26:26 <dolio> Since I was a noob like 7 years ago.
17:26:30 <djanatyn> Heh.
17:26:42 <djanatyn> I was looking at one exercise, and had a lot more fun that I expected with it
17:26:46 <dolio> I think it'd really resonate with people.
17:26:50 <djanatyn> It said, "write a function that takes the secondToLast value of a list"
17:26:53 <napping> back in my day we read the Gentle Introductio and liked it!
17:26:58 <djanatyn> initially, my knee-jerk reaction was
17:27:29 <djanatyn> nextToLast xs = xs !! (length xs) - 1
17:27:48 <dmwit> - 2 -- ;-)
17:27:54 <djanatyn> which is my non-functional programming instincts telling me to just write array[n - 1]
17:27:58 <djanatyn> umm...oh, yeah. :D
17:28:11 <djanatyn> So then I started thinking, how can I do this functionally?
17:28:16 <djanatyn> And I came up with this jumble:
17:28:21 <napping> that's not such a good idea with Int, but if you have lazy numbers
17:28:28 <Eduard_Munteanu> napping: yeah, I don't think it's that bad at all.
17:28:51 <napping> well, if your length is strict and you don't want to force the list
17:29:11 <dmwit> It's bad because it forces the entire list into memory.
17:29:15 <dmwit> Because you traverse it twice.
17:29:40 <djanatyn> nextToLast xs = tail $ take 2 $ reverse xs
17:29:45 <djanatyn> Which is kinda weird. :)
17:30:05 <dmwit> I'd prefer drop 1 to tail there.
17:30:16 <dmwit> It's a bit nicer to lists that aren't long enough.
17:30:50 <napping> how about snd (zip xs (init xs))
17:31:06 <dmwit> napping: type error?
17:31:09 <djanatyn> But I wanted to get *really* functional, so I got recursive:
17:31:43 <dmwit> napping: Perhaps you meant last . init
17:31:47 <napping> yeah, that's better
17:32:15 <shachaf> I think the answer is usually not to write that function. :-)
17:32:19 <dmwit> last . init actually probably fuses. So that's pretty darn good.
17:32:20 <napping> reverse is still stricter than you want
17:32:31 <dmwit> yes
17:32:36 <dmwit> also yes to shachaf
17:32:55 <napping> yeah - a decent exercise for figuring out laziness better, but something you should avoid neededing
17:33:01 <Axman6> > let lastButOne xs = f (error "List to short") xs where f x [_] = x; f _ (x:xs) = f x xs in lastButOne [1..10]
17:33:02 <lambdabot>   9
17:33:06 <Axman6> > let lastButOne xs = f (error "List to short") xs where f x [_] = x; f _ (x:xs) = f x xs in lastButOne [1]
17:33:07 <napping> or use an array or Sequence or something
17:33:07 <lambdabot>   *Exception: List to short
17:33:13 <Axman6> too* -_-
17:33:19 <shachaf> They're shorting lists now?
17:33:22 <djanatyn> nextToLast xs = if length xs == 2 then head xs else nextToLast $ tail xs
17:33:29 <shachaf> copumpkin ought to know about that.
17:33:30 <djanatyn> So that was the most functional solution I came up with.
17:33:37 <dmwit> Axman6: Too complicated.
17:33:39 <Axman6> shachaf: cycle produces shorted lists no? :P
17:33:44 <djanatyn> I've never had so fun thinking of ways to approach a problem on the bus without a computer :D
17:33:49 <shachaf> djanatyn: No, not that!
17:33:58 <shachaf> djanatyn: "length" traverses the entire list on each iteration.
17:33:58 <djanatyn> shachaf: Well, it's obviously really inefficient.
17:34:08 <Cale> > head . map head . dropWhile (not . null . drop 2) . tails $ [1..10]
17:34:10 <lambdabot>   9
17:34:12 <djanatyn> Yeah. It was more of a fun experiment than a serious question.
17:34:15 <dmwit> > let lbo [x,y] = x; lbo (x:ys@(_:_)) = lbo ys; lbo _ = error "too short" in lbo [1..10]
17:34:16 <lambdabot>   9
17:34:19 <Axman6> dmwit: that's horribly inefficient :P
17:34:37 <Axman6> uh, djanatyn
17:34:40 <dmwit> Axman6: lbo there is the same idea, but without an auxiliary function.
17:34:49 <Axman6> yeah
17:34:55 <Cale> Note: my code there has a bug of sorts, see if you can figure out what it is :)
17:35:34 <dmwit> > head . map head . dropWhile (not . null . drop 2) . tails $ [1]
17:35:35 <lambdabot>   1
17:35:49 <Cale> indeed
17:36:08 <djanatyn> which solution would be the most efficient?
17:36:13 <Cale> It fails to fail in that case
17:36:14 <djanatyn> (!!) ?
17:36:19 <shachaf> No.
17:36:20 <dmwit> djanatyn: no
17:36:28 <dmwit> djanatyn: Anything that calls length is automatically disqualified.
17:36:32 <shachaf> The most efficient solution is probably not to do it in the first place, or not to use a list.
17:36:38 <shachaf> dmwit: genericLength is different, though. :-)
17:36:39 <djanatyn> Heh.
17:37:02 <Cale> > head [x | [x,y] <- tails [1..10]]
17:37:03 <lambdabot>   9
17:37:10 <dmwit> > last . init $ [1..10]
17:37:11 <lambdabot>   9
17:37:23 <dmwit> As long as we're allowing partiality. =)
17:37:39 <dmwit> Cale: Oh, that's very cute.
17:37:50 <dmwit> Especially since it Does the Right Thing if you leave off head.
17:37:52 <Cale> last . init also has the two-traversals problem though, if we're considering that a problem
17:37:57 <shachaf> I think Cale wins.
17:37:57 <dmwit> > [x | [x, y] <- tails [1..10]]
17:37:58 <lambdabot>   [9]
17:38:06 <dmwit> Cale: It probably fuses.
17:38:13 <shachaf> last . init fuses?
17:38:19 <Axman6> i'd hope so
17:38:19 <dmwit> No?
17:38:20 <Cale> hmmm...
17:38:26 <dmwit> I don't see why it shouldn't.
17:38:33 <Jafet> Fuse into what?
17:38:36 <Axman6> it would if you use the stream fusion package anyway...
17:38:37 <Cale> Quite possibly
17:38:42 <Jafet> Well, it still uses constant space.
17:38:56 <dmwit> Jafet: That's good enough for me. =)
17:39:05 <djanatyn> Anyway, haskell is awesome.
17:39:10 <dmwit> > [x | [x, y] <- tails [1]]
17:39:12 <lambdabot>   []
17:39:19 <djanatyn> I've been looking for a compiled language that I like, and haskell seems to be it.
17:39:53 <djanatyn> Nobody seems to have Python or perl on their computer, and bundling an interpreter with your application can be a pain sometimes. But, haskell creates native executables :D
17:39:57 <Jafet> Find a language you would like better, and write a compiler for it?
17:40:05 <djanatyn> And I don't have to learn C++ :D
17:40:23 <djanatyn> I'm taking a class in Java, and I really don't like it.
17:40:36 <djanatyn> C++ would be...a very dark time
17:40:50 <djanatyn> But Haskell is so much fun to write and learn about, and I'm really enjoying reading Real World Haskell.
17:40:58 <Jafet> You still have to distribute the RTS and all libraries you use.
17:41:08 <Cale> Cool! Make sure to stick around and ask questions often :)
17:41:24 <djanatyn> I tried reading it before, but back then I didn't really understand the importance of data structures and I skipped over the chapter showing you how to define new types -_-
17:41:24 <Jafet> @quote C\+\+
17:41:25 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
17:41:26 <mauke> Jafet: since when?
17:41:46 <Jafet> mauke: since you want your program to run
17:41:53 <Cale> djanatyn: Yeah, types are pretty central to how programs are written in Haskell.
17:41:53 <mauke> then you're wrong
17:42:09 <mauke> Jafet: when I copied a haskell executable to another machine, all I had to do was install libgmp
17:42:19 <Cale> djanatyn: Often the first thing one does when writing a program is try to get the types right and then fill in the code around that.
17:42:20 <djanatyn> So, I wrote https://github.com/djanatyn/htd/blob/master/main.hs and pretty much stopped learning because I was bored and very ignorant. :)
17:42:21 <shachaf> mauke: Distribute statically linked into the executable, I think Jafet means.
17:42:40 <djanatyn> So, recently I've been searching for a new language to learn, and I spent some time looking at the LambdaHack source code.
17:42:45 <shachaf> mauke: djanatyn's objection to Python/Perl was "bundling an interpreter with your application".
17:42:47 <djanatyn> It's besautiful.
17:43:01 <mauke> shachaf: yes, because it's painful
17:43:10 <shachaf> Painful?
17:43:13 <Axman6> Jafet: heh, i love that quote, because I remember seeing a talk from some of the LLVM guys working on the C++0x spec, and they said the idea was influenced pretty heavily on haskell's type classes
17:43:14 <djanatyn> Very painful. Especially when you don't have a Windows machine. ^_^
17:43:14 <shachaf> @google rubyscript2exe
17:43:16 <lambdabot> http://www.erikveen.dds.nl/rubyscript2exe/
17:43:22 <mauke> shachaf: ghc always bundles the RTS and stuff in your executable so it's no extra effort
17:43:24 <shachaf> I understood that it was pretty painless.
17:43:49 <djanatyn> I wrote a game in python with pygame for a 48 hour game-making competition, ludum dare
17:44:06 <djanatyn> when I finished, I was really happy with it, but got so frustrated with trying to distribute a windows binary on wine that I just gave up
17:44:35 <djanatyn> eventually, some really nice guy just posted a link to a windows executable he made in the commnets, so I lucked out
17:44:56 <shachaf> The solution is clearly Java.
17:45:03 <Cale> lol
17:45:22 <djanatyn> shachaf: *twitch*
17:45:37 <shachaf> Cale: What's the situation like as far as writing games in Haskell?
17:45:37 <Axman6> djanatyn: are you open to suggestions to improve that file you pasted? =)
17:45:42 * shachaf assumes Cale is an expert.
17:47:15 <Axman6> djanatyn: why did you not just use readFile and putStrLn for listItems?
17:48:06 <djanatyn> Axman6: I dunno.
17:48:13 <Cale> shachaf: Well, we've done a lot of in house building of tools to do it, but it can be done. Probably if your target was a desktop machine and not an iPhone, you'd go to a lot less trouble.
17:48:22 <djanatyn> I just kinda founed some functions that worked, and hacked it together
17:48:40 <Axman6> also, usage would be more elegant imo if you used putStrLn . unlines $ ["htd...]
17:48:53 <shachaf> Cale: Are general-purpose "Haskell for writing iPhone apps" tools ever going to be released?
17:48:58 <djanatyn> shachaf: I'm actually pretty interested in using Haskell for game development
17:49:09 <Cale> shachaf: Yes, they should be in the next GHC, iiuc.
17:49:13 <djanatyn> It looks like there are some pretty cool libraries out there, and SDL bindings, at the least
17:49:21 <d34df00d> Interestingly, the greater the number is after -N, the slower is the program.
17:49:29 <shachaf> Cale: Even for desktop machines, I assume you'd have a fair amount of overhead with infrastructure and such compared to what you'd need to do with other languages.
17:49:32 <shachaf> But I might be wrong.
17:49:43 <d34df00d> Though I have 4 "honest" cores and 8 of them counting HT.
17:49:46 <Axman6> djanatyn: the slower is your program. that is certainly not generally true
17:49:49 <Cale> shachaf: Yes, probably, if only because you can't buy a game engine off the shelf.
17:50:13 <d34df00d> Running with -S shows that most sparts are pruned :(
17:50:20 <d34df00d> s/spart/spark/
17:50:22 <shachaf> Well, if you're buying a game engine you presumably don't care about the language anyway. :-)
17:50:27 <d34df00d> And GC time grows considerably.
17:50:29 <Cale> If you were planning on writing a game engine anyway, then it's probably not much more work, and quite possibly a good deal less, since it's in Haskell.
17:50:37 <Axman6> d34df00d: ur doin it rong then =) care to share the code?
17:51:12 <d34df00d> Axman6: sure, https://github.com/0xd34df00d/gennl/tree/master/hs
17:51:19 <d34df00d> Particularly, Genetic.hs there.
17:52:04 <Axman6> d34df00d: where's the parallelism being used?
17:52:07 <d34df00d> Particularly, line 128.
17:52:19 <d34df00d> Axman6: I'm playing around locally, replacing map with parMap.
17:52:25 <d34df00d> Or parListChunk, or such.
17:52:57 <d34df00d> And in line 106 as well, the same.
17:53:29 <d34df00d> Though I use C libraries, so maybe the compiler/runtime refuses to parallelise this stuff.
17:54:06 <d34df00d> Also, Numeric.GSL.Fitting is so damn slow that makes me wonder if hand-written Levenberg-Marquardt would be faster.
17:54:15 <Axman6> in 106, try using let !opt = map ...
17:54:31 <Eduard_Munteanu> d34df00d: it won't but if the C libs are not thread-safe, it'll misbehave
17:54:43 <Axman6> class (Eq a, Show a, Formattable a, Ord (ComputeRes a), RealFloat (ComputeRes a), Formattable (ComputeRes a)) => GAble a where
17:54:48 <Axman6> jesus, heh :P
17:55:15 <shachaf> You can drop Eq if you have Ord.
17:55:18 <shachaf> Oh, never mind.
17:56:08 * Jafet forks it and calls it GAbel
17:56:44 <d34df00d> Axman6: yeah :)
17:56:49 <Cale> Gergely Patai (incidentally one of the guys working with us), is apparently going to work on integrating GPipe and the LambdaCube 3D engine as a personal project.
17:57:18 <Axman6> d34df00d: anyway, you need to force those sparks to be created before demanding their results to get any parallelism
17:58:44 <Cale> GPipe looks like a rather nice alternative to OpenGL.
17:58:48 <d34df00d> alpounet: and how would I do that?
17:58:55 <d34df00d> Axman6: sorry, that was for you ^^^
17:59:15 <d34df00d> Axman6: also, bang pattern helped a bit there, now 180% CPU instead of 130%.
17:59:17 <Axman6> try doing what i said above, using let !opt = parMap ...
17:59:22 <Axman6> good =)
18:00:34 <Axman6> i'm pretty sure that forcing the result of parMap to WHNF will force all the sparks to be created (maybe not converted, but they will get added to the queue and run if they can be)
18:01:21 <Axman6> d34df00d: try doing the same thing with assessPpl, by let binding the result of parMap
18:02:35 <d34df00d> Axman6: I'm also a bit confused by growing GC time.
18:02:46 <d34df00d> 3-4% for -N1, 26% for -N2, etc.
18:03:25 <Axman6> yeah, not sure about that
18:03:55 <Saizan> maybe you want one of the chunked versions of parMap
18:03:59 <Cale> Is your program running faster but producing the same amount of garbage?
18:04:21 <Cale> The GC will take proportionally more of the running time of the program as that happens.
18:04:36 <d34df00d> Cale: nope, it's even slower.
18:04:42 <d34df00d> Approx. linearly slower.
18:04:51 <Cale> hmm
18:05:05 <d34df00d> Saizan: played around with that, creating about the same number of chunks as I have cores.
18:05:17 <Cale> Perhaps ThreadScope could help work out what's going on
18:05:17 <d34df00d> (and setting -N to something like that)
18:05:35 <d34df00d> Hm, I thought it's Win only.
18:05:39 <d34df00d> Thanks, gonna emerge now.
18:05:46 <Cale> http://www.haskell.org/haskellwiki/ThreadScope
18:05:57 <Cale> cabal install threadscope
18:06:06 <Axman6> isn't the number passed to the chunking parmap the chunk size?
18:06:22 <Cale> yes
18:06:30 <Cale> You should set it to something large
18:06:31 <Axman6> d34df00d: it's written using gtk2hs
18:06:56 <d34df00d> Ah, sure.
18:08:46 <Axman6> i believe parMapChunk 1 ~= parMap
18:08:59 <d34df00d> Also, what's quite strange for me.
18:09:09 <Cale> withStrategy (parListChunk 10000) . map f
18:09:19 <Cale> oh, is there parMapChunk?
18:09:23 <d34df00d> A lot of time (70%) is eaten by my gaModel function.
18:09:45 <d34df00d> And it's its own time according to .prof file.
18:09:49 <Cale> My Control.Parallel.Strategies doesn't have parMapChunk
18:10:17 <Axman6> d34df00d: you know that bang patterns on things like lists only forces them to WHNF right? (so, whether it's [] or (_:_))
18:10:28 <Cale> oh, realToFrac :)
18:10:33 <d34df00d> Though it only calls compute, which does all the dirty job of walking the tree, substituting the variables and such.
18:10:51 <Cale> Which instance of realToFrac is that?
18:10:55 <d34df00d> Axman6: yep. So I do rdeepseq strategy, shouldn't it aid a bit?
18:11:02 <d34df00d> Cale: Double <-> Dual tag Double
18:11:32 <Axman6> ah, i remember you talking about this yesterday
18:11:46 <d34df00d> Yeah.
18:13:08 <Cale> You should often rdeepseq things which you're running in parallel
18:13:19 <Axman6> d34df00d: when you use GAble a, what is the a usually?
18:13:25 <Cale> Particularly if they're not atomic things
18:13:26 <d34df00d> Axman6: ExprTree Double
18:13:51 <Axman6> i wonder whether a specialize pragma might help... probably not
18:13:55 <Axman6> but maybe worth trying
18:14:22 <d34df00d> Oh, I saw wonderful things done with those rewrite rules (you mean them, right?), like symbolic differentiation and such.
18:14:27 <Axman6> {-# SPECIALIZE gaModel :: (ExprTree Double, [String], [String]) -> [Double] -> [Double] -> [Double] #-}
18:14:52 <Axman6> not a rewrite rule, it makes a specialised version of that function for use when using that type
18:15:07 <Axman6> try pasting that after the definition of gaModel
18:15:22 <Axman6> also, might be worth looking into the specializable pragma
18:18:39 <d34df00d> Axman6: ok, rerunning with that pragma.
18:19:20 <d34df00d> Cale: well, evalTree is quite cheap itself, I guess, so it only makes sense to run a bunch of them in parallel, each thread running a set of evals on the whole testset.
18:19:22 <Eduard_Munteanu> d34df00d: can you also paste the profile?
18:19:46 <Eduard_Munteanu> Also +RTS -s
18:20:00 <d34df00d> Eduard_Munteanu: yep, just a moment, it takes quite a bit of time :)
18:21:20 <d34df00d> Oh, here it is: http://paste.pocoo.org/show/483622/
18:23:12 <d34df00d> And for -s: http://paste.pocoo.org/show/483623/
18:23:45 * Axman6 -> food
18:23:53 <dstcruz> So, I have a function that parses a webpage into "sections", and I have a function that returns a list of urls that can be parsed by the previous function. Would it be possible for me to write an iterIO enumerator to get these webpages?
18:24:07 <Eduard_Munteanu> Hm, -s looks good, but gaModel still allocs a lot I guess.
18:24:11 <d34df00d> Axman6: ? :)
18:24:22 <dstcruz> ok, ok… loaded question. Maybe it would not be possible for *me* to write such thing...
18:24:24 <Axman6> it's lunch time for me
18:24:29 <d34df00d> Ah.
18:24:38 <d34df00d> It's just me decrypted as dead food.
18:24:44 <d34df00d> So I'm reacting strangely to that :)
18:25:17 <d34df00d> Eduard_Munteanu: yep, I guess it's called quite often from the L-M implementation, so even if it doesn't allocate a lot at once, it does that often enough.
18:28:04 <d34df00d> And why does gaModel take anything at all? It just zips a couple of lists and calls realToFrac a couple of times.
18:30:46 <dmwit> yay, I get to blame this on GHC instead of my code
18:32:08 <Eduard_Munteanu> Strictness can also bite you there.
18:32:28 <Eduard_Munteanu> What's with those lists, anyway?
18:32:43 <Eduard_Munteanu> I'd try to make gaModel simpler and maybe inline it.
18:33:05 <Eduard_Munteanu> (does it get called a lot of times?)
18:33:43 <d34df00d> Eduard_Munteanu: it gets called a huge number of times, I'd say.
18:34:01 <d34df00d> And how one could make it simplier?
18:34:35 <Eduard_Munteanu> d34df00d: for starters, what's with those lists of strings?
18:34:48 <d34df00d> Eduard_Munteanu: hm, what do you mean?
18:35:05 <Eduard_Munteanu> gaModel :: (GAble a) => (a, [String], [String]) -> [Double] -> [Double] -> [Double]
18:35:15 <joe9> my .cabal file: http://codepad.org/tf3arMSj, I do not know why, but cabal is not able interpret the content as new lines: http://codepad.org/MP30YH7w
18:35:19 <joe9> any thoughts, please?
18:35:20 <d34df00d> Ah, yeah.
18:35:27 <d34df00d> The first one is the list of names of the variables.
18:35:39 <d34df00d> The other — the list of names of, well, other variables.
18:35:48 <joe9> cat of the cabal file: http://codepad.org/Z3VpY9wp
18:36:06 <d34df00d> They then get replaced by their actual values in compute (which is evalTree for the actual 'a' currently used).
18:36:20 <joe9> got it, sorry, stupid mistake
18:36:23 <joe9> please ignore
18:37:01 <Eduard_Munteanu> d34df00d: can you use some other kind of key? Maybe like Int?
18:38:13 <d34df00d> Eduard_Munteanu: hm, I guess yes, I could.
18:38:42 <Eduard_Munteanu> d34df00d: then you can have a separate mapping between the Int keys and actual strings
18:38:59 <Eduard_Munteanu> In case you want to do those lookups somewhere else.
18:39:43 <d34df00d> Well, I guess I could live without it at all.
18:40:02 <d34df00d> And maybe only lookuping them when outputting the formulas to the user.
18:42:44 <Eduard_Munteanu> d34df00d: yeah, that should be faster than looking up by strings. You can use, say, an IntMap.
18:43:39 <Eduard_Munteanu> And then you might be able to inline gaModel.
18:44:38 <Eduard_Munteanu> d34df00d: btw, what optimization flag do you use?
18:45:08 <d34df00d> Well, I'd hardly be able to inline it, since I need to pass it to a third-party function.
18:45:16 <d34df00d> Eduard_Munteanu: just -O2, should I use anything else?
18:46:43 <joe9> i notice that the bindings-dsl #ccall macro is not adding the header file name: foreign import ccall "testing_c" c'testing_c
18:46:52 <Eduard_Munteanu> Nah, that's ok. (Mind there might be cases when -O2 can be worse, but I don't think this is neccesarily the case here)
18:47:01 <joe9> it generates the ccall as above instead of as: foreign import ccall "test2.h testing_c" c'testing_c
18:47:43 <joe9> and, when the dynamic library has the same name as any function in the standard library, it is calling the standard library function instead of the dynamic library function.
18:48:09 <joe9> has anyone noticed such behaviour?
18:48:29 <joe9> will adding the header filename to the foreign import ccall .. help?
18:48:35 <joe9> or, is it of no use?
18:50:26 <d34df00d> Oh, 7 a.m., gotta sleep.
18:50:36 <Eduard_Munteanu> Heh.
18:50:52 <d34df00d> Thanks guys! But I think I'd ask some more stupid questions today :)
18:56:29 <siracusa> Is there a way to bind a local variable in ``case x of { Foo y | isSomeY -> ... ; ... }'' so that ``isSomeY = ... y ...''?
18:57:10 <shachaf> siracusa: Not really, but you can always define a function of y.
18:57:24 <Eduard_Munteanu> Maybe view patterns.
18:57:46 <siracusa> Yeah, but I wanted to avoid re-computations of values
18:57:51 <MarkDBlackwell> Isn't there a  way to use 'let' for that?
18:58:00 <Eduard_Munteanu> They might work in case expressions. The idea is you can write stuff like    f (isJust -> True) = ...
18:58:32 <shachaf> Recomputations of values?
18:58:37 <shachaf> siracusa: You should really provide more context.
18:59:22 <Jafet> Remember that you can use any function in a view pattern.
18:59:27 <Jafet> @quote best.view.pattern
18:59:28 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
18:59:29 <siracusa> Let me prepare a short paste ...
19:01:45 <monochrom> siracusa: case x of { Foo y | z -> ... z ... where z = y*y*y>0 ; Bar x -> ... ; _ -> error "no match" }  the point is you can have a "where"
19:02:00 <monochrom> also your wording is strange and I am only 80% sure I understand it
19:02:32 <siracusa> Hhm, that was what I tried, gave me a parse error.
19:02:45 <monochrom> you need to indent it very trickily
19:03:12 <monochrom> and I need more {}s to disambiguate it, too
19:03:16 <siracusa> Ok, I'll try again trickily :-)
19:03:23 <monochrom> case x of { Foo y | z -> ... z ... where {z = y*y*y>0} ; Bar x -> ... ; _ -> error "no match" }
19:03:50 <shachaf> Oh, you can have where on ->?
19:04:23 <monochrom> > case Just 3 of { Just x | square > 0 -> show square where { square = x*x }; _ -> "bye" }
19:04:24 <lambdabot>   "9"
19:05:16 <monochrom> you can have "where" on every pattern matching thingie. "f x = y where y = x" is merely a special case.
19:07:22 <monochrom> > let { f x | square > 0 = "+ve" | square < 0 = "-ve" | otherwise = "0" where square = x*x } in f 1
19:07:23 <lambdabot>   "+ve"
19:08:49 <siracusa> Oh wait, my problem is even more complicated, I need case x of { Foo | ... where ... | ... ; Bar }. That's not possible, is it?
19:09:17 <shachaf> It's possible assuming you mean Bar -> ...
19:09:26 <siracusa> Erm, yes
19:09:33 <monochrom> all guards share the same "where", so put it after the last guard
19:09:59 <siracusa> But I need to access variables bound  by Foo
19:10:55 <monochrom> > case Just 3 of { Just x | square<0 -> square | cube>0 -> cube where { square = x*x; cube = x*x*x } ; _ -> undefined }
19:10:56 <lambdabot>   27
19:11:27 <monochrom> all my examples use variables bound by Foo
19:12:06 <siracusa> Ah, thanks!
19:14:43 <monochrom> in fact...
19:14:58 <monochrom> > case Just 3 of { Just x | square<0 -> cube | cube>0 -> square where { square = x*x; cube = x*x*x } ; _ -> undefined }
19:14:59 <lambdabot>   9
19:15:09 <monochrom> to show the complete flexibility
19:24:15 * hackagebot DRBG 0.2.3 - Deterministic random bit generator (aka RNG, PRNG) based HMACs, Hashes, and Ciphers.  http://hackage.haskell.org/package/DRBG-0.2.3 (ThomasDuBuisson)
19:32:47 <blackdog> how do i tell cabal to include a .a file in a build?
19:54:40 <kfish> https://docs.google.com/spreadsheet/viewform?formkey=dGRDd0t3LU5qSUJNSU90dW5YdW91ckE6MQ
19:54:40 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
19:55:02 <copumpkin> :O
19:55:34 <kfish> heh
19:55:39 <kfish> copumpkin, what was that about?
19:55:43 <copumpkin> ?
19:56:01 <DanBurton> do what lambdabot says and it will give you a message
19:56:35 <kfish> i got the message, it was that copupmpkin shook his fist at me :)
19:56:39 <copumpkin> kfish: oh!
19:57:14 <copumpkin> kfish: you started the circle-sharing madness in the haskell community
19:57:34 <shachaf> kfish: That was you?
19:57:54 * shachaf shakes fish at kfist.
19:58:23 <DanBurton> I want hackage to use torrenting. That would be cool.
19:59:12 <kfish> ah yes, that was me
19:59:19 <kfish> sorry everyone :)
19:59:22 <kfish> madness indeed
19:59:55 <kfish> DanBurton, that's not a bad idea at all
20:00:09 <kfish> what would be required, just generating torrent files for each package and running a server?
20:01:48 <Eduard_Munteanu> Package and version maybe?
20:02:34 <kfish> right, i guess i meant for each tarball
20:02:34 <adrake_> is there really that much to gain from torrenting hackage packages? are there that many big files?
20:03:00 * Eduard_Munteanu somewhat wishes Hackage hosted git repos
20:03:06 <adrake_> I guess it would lower hackage's network load a lot, but it seems like it'd slow down the download process a /lot/
20:03:13 <Eduard_Munteanu> And for each version you just use a tag :)
20:03:17 <kfish> lots of small ones ... but maybe mirrors could be seeded with a tar containing all current file versions, or something like that
20:03:32 <kfish> Eduard_Munteanu, i would like more git too :)
20:03:36 <Eduard_Munteanu> Yeah, a monthly tar might do.
20:04:08 <shachaf> Do you mean bittorrent for people downloading individual packages or for synchronizing between the mirrors?
20:04:19 <Eduard_Munteanu> Not sure.
20:04:34 <Eduard_Munteanu> Well, if it had Git then other githosts could mirror it.
20:05:04 <kfish> so a git repo for each package, containing ... the tarballs, the generated documentation etc?
20:05:10 <Eduard_Munteanu> It's pretty easy to set up mirrors on e.g. repo.or.cz, though it has to be for individual repos
20:05:31 <kfish> the current hackage-server implementation is using happstack with acid-state, and all the package files are already hash objects
20:05:40 <Eduard_Munteanu> No, just the source
20:06:16 <kfish> oh, the unpacked source? would that really be more useful than the original source repo?
20:06:18 <Eduard_Munteanu> On many git web interaces you can just ask for a tarball corresponding to a commit/tag
20:06:24 <kfish> ah i see
20:07:30 * Eduard_Munteanu wonders if that might also solve part of the Hackage auth problem
20:07:48 <kfish> well it would certainly be interesting to have one big git object cache containing every file in every version of every package, and then particular versions are just tags to trees in that ;-)
20:08:05 <kfish> (like the way github is set up, so all the COPYING files etc. just exist once)
20:10:19 <zzo38> How do you make comma categories in Haskell?
20:12:14 <zzo38> Do you know how to make comma categories in Haskell?
20:15:03 <Cale> zzo38: ummm
20:15:18 <Cale> zzo38: You don't do it directly.
20:16:28 <Cale> zzo38: You could maybe use comma categories to explain your intention of a piece of code, but since they place equational constraints on the allowed arrows, you wouldn't be able to guarantee that statically.
20:18:15 <Cale> There's also a typing concern if you wanted these things to be instances of Category.
20:19:10 <Cale> (in that the objects of our category would be Haskell functions, and there's no way to lift those to the type level as of yet)
20:23:23 <zzo38> OK.
20:24:13 <Cale> I have a feeling that you could get a more interesting answer in a dependently typed language.
20:24:25 <Eduard_Munteanu> Well, you can't strictly define monads either in that sense.
20:24:33 <Cale> Eduard_Munteanu: sure
20:24:36 <Eduard_Munteanu> For that you might want to try a dependently typed language.
20:24:56 <Eduard_Munteanu> Oh, you already said that :)
20:25:49 <Cale> It's just... there's even less of the structure available here. We can't make anything which really approximates the structure of a comma category, even ignoring the constraints.
20:26:30 <Eduard_Munteanu> https://github.com/copumpkin/categories/blob/master/Categories/Comma.agda
20:26:56 <Cale> because if the objects of the comma category are supposed to be types, they have to be types which depend on functions, which are values --> dependently typed :)
20:28:00 <Eduard_Munteanu> Yeah. Category isn't much of a category either, or other stuff like that in Haskell.
20:29:57 <zzo38> That is why, it should be made, some commands in Haskell allowing the use of any categories, even uncomputable; you would have to write the computation yourself, so that they can be used, probably at compile-time.
20:30:43 <Eduard_Munteanu> zzo38: Haskell won't be a full-fledged DT language anytime soon.
20:31:19 <Eduard_Munteanu> It doesn't even have type-level nats yet.
20:31:56 <Cale> zzo38: which comma category are you interested in, in particular?
20:32:02 <Eduard_Munteanu> zzo38: in any case, if you want something similar to Haskell that can do that, have a look at Agda.
20:32:06 <zzo38> Eduard_Munteanu: What does "full-fledged DT language" means?
20:32:37 <Cale> DT = dependently typed = has types that depend on values rather than just on types
20:32:40 <zzo38> Cale: None particularly, I was just interest to know if there is any way to make comma category
20:32:43 <Eduard_Munteanu> zzo38: something more like a theorem prover based on dependent types theory.
20:33:39 <Eduard_Munteanu> Basically your types aren't much different from values.
20:35:11 <Eduard_Munteanu> zzo38: have a look at the link I posted above
20:38:20 <zzo38> Haskell does have type families. You could have some way for defining special kind of functions that convert values of a type to types of a kind (and possibly kind templates and classes as well). Maybe Template Haskell can be used?
20:38:33 <zzo38> I have once written an implementation of type level natural numbers in Haskell.
20:39:14 * hackagebot hlint 1.8.16 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.16 (NeilMitchell)
20:39:28 <zzo38> Eduard_Munteanu: OK I look. It looks like not ASCII
20:39:55 <Eduard_Munteanu> Yeah, they tend to use lots of unicode in Agda.
20:40:48 <blackdog> could anyone suggest a strategy for using HAskell on windows and not going insane? I need to wrap some C++ libraries in order to call them from my Yesod app, but I can't seem to link in the .lib without having a million missing DLLs, at least when i do it from the haskell side.
20:44:39 <nyingen> what is #def for in hsc2hs?
20:45:10 <btutt> blackdog: linking the import .libs or a static lib?
20:45:12 <nyingen> I tried to use it to define a C helper function in a binding I'm writing, but ran into a linking problem
20:49:22 <blackdog> btutt: i built a lib that should have wrapped my c++ deps, but when i tried "ghc --make mycoolapp.hs myuglywindowsstuff.lib", i get a bunch of errors, mostly about not finding GDIplus stuff
20:50:56 <nyingen> is it possible to inline a (C) helper function in a hsc2hs file? The hsc2hs docs imply that it is, but I'm not sure how to get it to work
20:52:22 <zzo38> Is "Barrier a c >>= f = Barrier a $ c >=> f" a proper monad?
20:54:02 <btutt> blackdog: if myuglywindowsstuff.lib is a static lib, then you'll probably need to include the import lib for GDI plus goo.
20:55:03 <DanBurton> @where monad laws
20:55:03 <lambdabot> I know nothing about monad.
20:55:12 <DanBurton> -.-
20:55:28 <DanBurton> @google monad laws haskell
20:55:29 <lambdabot> http://www.haskell.org/haskellwiki/Monad_Laws
20:55:29 <lambdabot> Title: Monad laws - HaskellWiki
20:56:07 <DanBurton> @where+ monadlaws http://www.haskell.org/haskellwiki/Monad_Laws
20:56:07 <lambdabot> I will remember.
20:56:14 <zzo38> I know about monad laws. But I asked you too just in case I made the mistake.
20:56:25 <btutt> (which appears to be Gdiplus.lib)
20:57:08 <DanBurton> zzo38: how is your return defined?
20:57:36 <zzo38> return = Unit; Unit x >>= f = f x;
20:58:18 <btutt> just as a FYI, GDI plus isn't being maintained any longer. (esp. the typeopgraphy stuff) :(
21:02:19 <mcsquiggedy> So, I've spent the past half hour fighting with GHC on a number typing issue, and I was wondering if anyone might be willing to lend a hand.
21:02:58 <shachaf> mcsquiggedy: Very likely, if you explain the issue. :-)
21:03:40 <mcsquiggedy> Okay. I've got two ints, a and b. What I want is ((2 * a) + b) / 3, rounded up.
21:03:56 <mcsquiggedy> Umm.... I should probably paste the GHCI session?
21:04:29 <hpaste> mcsquiggedy pasted “numerical typing... bluh” at http://hpaste.org/51858
21:05:04 <mcsquiggedy> Ideally, I would be calling ceiling on the result, for the round-up.
21:05:44 <mcsquiggedy> But the Google gods have not condescended to enlighten me with regards to the RealFrac typeclass either.
21:05:46 <shachaf> mcsquiggedy: The issue is that the types of a and b are, I'm guessing, Integer, but the types of the literals 21 and 3 are more polymorphic.
21:06:39 <mcsquiggedy> That sounds like a likely cause, yes. I've been wading through the swamp of numerical types for some time now
21:06:45 <shachaf> mcsquiggedy: You can convert the result of ((2*a)+b) to a more polymorphic type using fromIntegral.
21:06:48 <mcsquiggedy> and I have yet to find an appropriate fix.
21:06:49 <zzo38> Is "return = Unit; Unit x >>= f = f x;" correct? I think so; I think it is the properly by the monad law. Is the other one correct?
21:06:49 <mcsquiggedy> okay
21:06:59 <shachaf> mcsquiggedy: Alternatively, you can use integer division directly, which is probably a better idea than floating-point division.
21:07:27 <shachaf> @src Identity (>>=)
21:07:27 <lambdabot> m >>= k  = k (runIdentity m)
21:07:29 <shachaf> @src Identity return
21:07:29 <lambdabot> return a = Identity a
21:07:41 <shachaf> zzo38: Unit already exists in the standard library, with that definition.
21:07:45 <mcsquiggedy> shachaf: that would be with div, yes?
21:08:11 <shachaf> mcsquiggedy: Yes, or divMod if you also want the remainder (for e.g. rounding properly).
21:08:58 <mcsquiggedy> In this case, "properly" means "up"; what's the default behaviour?
21:09:29 <shachaf> zzo38: Oh, I thought you just had one constructor. I have no idea whether your implementation satisfies the monad laws, in that case.
21:09:34 <shachaf> mcsquiggedy: Try it out and see. :-)
21:10:43 <shachaf> zzo38: I have no idea what your type is like, and giving bits of the implementation at a time isn't likely to help. :-)
21:11:11 <shachaf> Just go through the monad laws and prove each one, I guess.
21:11:46 <shachaf> zzo38: Is there a reason you're talking to me in another channel?
21:11:53 <mcsquiggedy> shachaf: would I be correct in supposing that a case statement would be necessary to interpret the result of the divMod?
21:12:05 <zzo38> No.
21:12:24 <zzo38> I was on two channel at once and send message both channel by mistake
21:12:41 <zzo38> data Barrier f b t = Unit t | Barrier f (b -> Barrier f b t) ;
21:12:43 <shachaf> mcsquiggedy: Probably not?
21:13:02 <shachaf> let (x,y) = 22 `divMod` 3 in ...
21:13:36 <Axman6> > divMod 3498 28
21:13:37 <lambdabot>   (124,26)
21:13:51 <Axman6> > fst $ divMod 3498 28
21:13:51 <Axman6> > snd $ divMod 3498 28
21:13:52 <lambdabot>   124
21:13:53 <lambdabot>   26
21:14:47 <mcsquiggedy> shachaf: This is a bit tangential, but I don't see how that gets me out of needing conditional logic.
21:14:48 <shachaf> @let fstAndSnd t = (fst t, snd t) -- Tada!
21:14:49 <lambdabot>  Defined.
21:15:28 <mcsquiggedy> shachaf: which would not, y'know, be the end of the world, but still a disconcerting amount of work, so I was wondering if there's an alternative that I'm missing.
21:15:32 <shachaf> mcsquiggedy: Oh, well, sure, you'll need case or something equivalent to it (e.g. if) somewhere.
21:15:44 <zygoloid> @@ @pl @djinn @type fstAndSnd
21:15:45 <shachaf> mcsquiggedy: What's a disconcerting amount of work?
21:15:45 <lambdabot>  f = id
21:15:53 <shachaf> zygoloid: Spoilsport.
21:16:02 <shachaf> zygoloid: They're not even equivalent.
21:16:17 <shachaf> fstAndSnd _|_ = (_|_,_|_)
21:16:18 <zygoloid> shachaf: it looks like they're not, but they secretly are!
21:16:30 <zygoloid> djinn said so
21:16:32 <zygoloid> :)
21:16:53 <shachaf> djinn is a stupidhead.
21:16:57 <zzo38> What is that "fstAndSnd" for anyways?
21:17:00 <shachaf> It can't even do Rank-N types.
21:18:03 <shachaf> > fstAndSnd undefined `seq` ()
21:18:05 <lambdabot>   ()
21:18:05 <shachaf> > id undefined `seq` ()
21:18:06 <lambdabot>   *Exception: Prelude.undefined
21:18:15 <DanBurton> @let tupleFlip (x,y) = (y,x)
21:18:16 <lambdabot>  Defined.
21:18:41 <zzo38> I try to do thing I read Godel,Escher,Bach, and figure out which theorem of propositional calculus are in Haskell, it seem to me, one of the example theorems <P?<Q?<P&Q>>> that one corresponds to (,) in Haskell, and deduction theorem corresponds to do-notation. Is that correct?
21:19:08 <mcsquiggedy> shachaf: disconcerting is more than three lines for "integer divide, round up". But the code works now, at least. Thanks for your help.
21:19:49 <shachaf> zzo38: I have no idea what the deduction theorem is.
21:19:53 <DanBurton> @@ @pl @djinn (a,b) -> (b,a)
21:19:53 <lambdabot>  f = uncurry (flip (,))
21:20:02 <mcsquiggedy> zzo38: give me a page reference?
21:20:43 <zzo38> Unfortuately I not have book with me right now.
21:20:51 <mcsquiggedy> Oh, wait, it has an index.
21:20:51 <zzo38> But, deduction theorem is also called fantasy rule in that book.
21:21:09 <shachaf> zzo38: No, that's not do-notation.
21:21:36 <shachaf> mcsquiggedy: Well, just make a function "integerDivideMyWay x y = d + (if m == 0 then 0 else 1) where (d,m) = x `divMod` y" or something like that.
21:21:45 <shachaf> You only need to write it once. :-)
21:22:11 <zzo38> shachaf: Are you sure? It seem to me it is, at least in the (e ->) monad.
21:22:13 <kmc> zzo38, deduction theorem corresponds to lambda, doesn't it?
21:22:15 <zzo38> But maybe I am wrong.
21:22:31 <Rotaerk> "fantasy rule" is just an implication
21:22:34 <kmc> if you can write y :: S using x :: T then you have a proof (\x -> y) of proposition (T -> S)
21:22:34 <zzo38> Or, at least, it correspond to fantasy rule? I don't know.
21:22:37 <shachaf> What kmc said, I think.
21:22:39 <Rotaerk> give a, derive b
21:22:41 <Rotaerk> given *
21:22:57 <kmc> it's also known as "implication elimination" i think
21:23:14 <kmc> or is it introduction?
21:23:29 <shachaf> Elimination.
21:23:31 <ulfdoz> So, mal schaffen gehen.
21:23:36 <ulfdoz> ewin, sorry
21:23:41 <mcsquiggedy> shachaf: er.... thanks.
21:23:51 <shachaf> Wait, maybe not.
21:24:08 <shachaf> Introduction, I guess.
21:24:16 * hackagebot criterion 0.5.1.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.1.0 (BryanOSullivan)
21:24:28 <monochrom> "intro" or "elim" is based on the conclusion. the conclusion has one more "->" --- intro
21:24:39 <kmc> ok
21:25:21 <kmc> Γ, x:S ⊢ y:T  ⇒  Γ ⊢ (λ(x:S). y) : (S → T)
21:25:51 <kmc> or just  Γ, S ⊢ T  ⇒  Γ ⊢ S → T
21:26:10 <kmc> so which rule (if any) is →-elim?  application?
21:26:15 <monochrom> yes
21:26:45 <monochrom> the premise has a ->, the conclusion loses it. elim
21:27:03 <kmc> Γ ⊢ S→T  &  Γ ⊢ S  ⇒  Γ ⊢ T
21:27:45 <companion_cube> isn't it also called "cut" ?
21:27:55 <monochrom> cut is different
21:28:57 <companion_cube> A, B |- C  &  D |- A  --> B, D |- C ?
21:29:24 <dobblego> is there a combinator to know which parser succeeded  when using Parsec.<|>?
21:31:16 <monochrom> something like that
21:31:41 <companion_cube> but it's basically the same thing
21:31:45 <zygoloid> dobblego: sounds really easy to build yourself
21:32:09 <dobblego> it does sound easy, but I expect I'm doing something wrong
21:32:12 <companion_cube> because the left sequent is rewritable to A |- B -> C
21:32:21 <zygoloid> \a b -> fmap (False,) a <|> fmap (True,) b
21:33:02 <monochrom> depends on how much you keep |- and -> separate, really
21:33:57 <companion_cube> like, it may be different in intuitionist logic ?
21:33:58 <zygoloid> dobblego: i would think usually if you need to know which half succeeded, you should move the 'thing which needs to know' into the arms of the <|>
21:34:58 <dobblego> yeah I'm thinking that too -- I'm just being a sissy
21:35:46 <monochrom> well, "|- A" is a syntactically correct thing, "-> A" is not even syntactically correct, so you already have a distinction, however artificial it is
21:36:20 <ezyang> It's actually pretty important when you introduce modalities.
21:37:45 <companion_cube> ok, ok :)
21:40:13 <monochrom> I know the attraction of " 'A|-B' and 'A->B' say the same thing". certainly works well for classical and intuitionistic predicate logics. 1st year logic courses are an exercise in "define |- and -> differently, only to prove them equivalent"
21:41:27 <kmc> you can't prove that A⊢B and A→B say the same thing, because that's a statement of philosophy not mathematics
21:41:27 <monochrom> but if you care about separating the meta level from the target logic level, then you have to keep them separate. or if you deal with some other logics, then you have to keep them separate until proven same.
21:42:41 <ezyang> For example, |- []A implies |- A, but |- []A -> A is not true.
21:42:42 <companion_cube> indeed
21:43:30 <monochrom> in fact, 1st year logic courses are an exercise in "define |- |= -> to be all different, spend 90% of the course to emphasize that, then the last 10% proving them equivalent"  It is certainly a bit frustrating to beginners.
21:44:26 <companion_cube> |= is not really equivalent, right? It's only if all models M |= F that F is a theorem?
21:44:49 <blackdog> so, if i have a list of object files that i want cabal to treat is if I've just bunged them on the ghc --make command line - where would i list them?
21:44:57 <PatrickRobotham> |= isn't equivalent to |- in second order logic.
21:49:42 <blandw> If I have something like "type Strl = [String]", how can I concatenate two Strl's?
21:50:06 <dobblego> (++)
21:50:08 <blackdog> blandw: ++
21:50:14 <shachaf> mappend
21:50:21 <dobblego> saw that coming
21:50:30 <shachaf> @pl \x y -> concat [x,y]
21:50:31 <lambdabot> (join .) . (. return) . (:)
21:50:59 <DanBurton> blandw: since it is only a type synonym for a list, you can use list functions as usual
21:51:24 <DanBurton> @@ @pl @src (++)
21:51:25 <lambdabot>  (line 1, column 1):
21:51:25 <lambdabot> unexpected end of input
21:51:25 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:51:36 <DanBurton> aw
21:51:49 <DanBurton> @src (++)
21:51:49 <lambdabot> []     ++ ys = ys
21:51:49 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:51:49 <lambdabot> -- OR
21:51:49 <lambdabot> xs ++ ys = foldr (:) ys xs
21:52:18 <DanBurton> @pl xs ++ ys = foldr (:) ys xs
21:52:19 <lambdabot> (line 1, column 10):
21:52:19 <lambdabot> unexpected "="
21:52:19 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
21:52:20 <shachaf> @ty (++)
21:52:21 <lambdabot> forall m. (Monoid m) => m -> m -> m
21:52:37 <DanBurton> @pl let xs ++ ys = foldr (:) ys xs in (++)
21:52:37 <lambdabot> (line 1, column 8):
21:52:37 <lambdabot> unexpected "+"
21:52:37 <lambdabot> expecting pattern or "="
21:52:52 <DanBurton> lambdabot doesn't like me today
21:53:33 <shachaf> Just use another name.
21:53:37 <shachaf> Alternatively, don't use @pl.
21:53:44 <DanBurton> but I like @pl
21:53:49 <DanBurton> it makes me feel fancy
21:53:53 <shachaf> You can @pl that easily enough in your head. :-)
21:54:08 <DanBurton> yeah i queried lambdabot and finally got it. then I was like "well duh"
21:54:23 <DanBurton> @pl \xs ys -> foldr (:) ys xs
21:54:23 <lambdabot> flip (foldr (:))
21:56:07 <DanBurton> @unpl (foo .) . (. bar) . baz
21:56:07 <lambdabot> (\ e k -> foo (baz e (bar k)))
21:57:51 <DanBurton> @unpl (.bar) . baz
21:57:52 <lambdabot> (\ d g -> baz d (bar g))
21:59:14 <DanBurton> @unpl (foo . ) . baz
21:59:14 <lambdabot> (\ d g -> foo (baz d g))
21:59:52 <DanBurton> @type foo .* baz
21:59:53 <lambdabot> Not in scope: `foo'
21:59:53 <lambdabot> Not in scope: `.*'
21:59:53 <lambdabot> Not in scope: `baz'
22:00:21 * DanBurton is having a great ol' chat with lambdabot ........................
22:04:18 * hackagebot fingertree-psqueue 0.3 - Implementation of priority search queues as finger trees.  http://hackage.haskell.org/package/fingertree-psqueue-0.3 (CaleGibbard)
22:06:48 <knuck_> Is there a prelude function to make [x,y,z] into [[x,y],[x,z],[y,z]] ?
22:08:07 <mauke> > tails [x,y,z]
22:08:08 <lambdabot>   [[x,y,z],[y,z],[z],[]]
22:09:36 <knuck_> I take it tails is the closest?
22:09:54 <mauke> > [ [h, ht] | h : t <- tails [x,y,z], ht <- t ]
22:09:55 <lambdabot>   [[x,y],[x,z],[y,z]]
22:10:28 <shachaf> mauke++
22:10:31 <moriramar> impressive...
22:10:56 <donri> although it's in Data.List
22:12:35 <mauke> > [ [h, ht] | h : t <- tails [w,x,y,z], ht <- t ]
22:12:36 <lambdabot>   [[w,x],[w,y],[w,z],[x,y],[x,z],[y,z]]
22:57:21 <blackdog> i have a chunk of windows c code that seems to work fine in isolation. when i link it into my yesod app, it segfaults. any ideas what might be wrong?
22:58:07 <kmc> how does the C code get called?
22:58:45 <blackdog> in a haskell thread. it gets a certain distance through, then fail when i call a library function
22:59:09 <blackdog> am wondering whether it could be a windows threading thing.
22:59:11 <kmc> are you using a C main or a Haskell main
22:59:15 <blackdog> Haskell main
22:59:24 <kmc> is the C library supposed to be thread-safe?
22:59:28 <kmc> are you using the GHC threaded RTS?
22:59:38 <kmc> are your foreign calls marked "unsafe"
22:59:40 <blackdog> i am using the threaded RTS.
22:59:46 <blackdog> they're not marked at all
23:00:38 <kmc> then they're not 'unsafe'
23:00:57 <quicksilver> one possible option is that the windows library isn't threadsafe
23:01:00 <blackdog> i tried it without the threaded RTS as well, but it still crashes.
23:01:20 <blackdog> actually, there's a difference in the crash - without -threaded, it segfaults, with -threaded, it exits quietly with 127 status
23:01:37 <kmc> heh
23:01:44 <kmc> can you track down the segfault with  adebugger?
23:02:06 <blackdog> i'm downloading gdb no
23:02:08 <blackdog> *now
23:02:22 <shachaf> Why is the threaded RTS not the default?
23:02:34 <blackdog> just wondering if there are any traps for young players i ought to be aware of - i don't work on windows very often
23:04:10 <blackdog> quicksilver: so if i don't use the threaded RTS, any idea what the windows process model is? forkIO will just make me some haskell threads, all multiplexed onto one windows process?
23:04:33 <btutt> shachaf: *stabs in dark*: back compat
23:06:02 <quicksilver> blackdog: yes.
23:06:25 <quicksilver> blackdog: if the crash still occurs on the non-threaded RTS then it's not an un-threadsafe library problem
23:06:55 <blackdog> right. well, guess once gdb finishes trundling over the wires i'll dig in
23:06:58 <quicksilver> perhaps the windows library needs some kind of state that wasn't initialised.
23:07:14 <blackdog> and i might think twice before taking on windows work in future:/
23:07:15 <btutt> blackdog: non-threaded RTS multiplexes multiple haskell theads onto 1 Windows thread (not process)
23:07:29 <blackdog> it's dying in the state initialisation call
23:07:52 <blackdog> btutt: right, they don't really have the idea of processes, do they? no fork?
23:08:50 <btutt> they have processes but no fork() and OS threads are heavier weight than in Unix. NT user space threads have matching kernel space threads.
23:12:19 <btutt> Amuzingly enough, Win7 64bit and 2k8 r2 x64 bit can provide user mode thread scheduling among user mode threads.
23:28:39 <kel_>  Is there a way to convert scanl so that Function [1,2,3]  works the same way as "scanl (+) 0 [...] ?
23:28:58 <kel_> *convert/modify
23:29:28 <mauke> huh?
23:29:59 <kmc> > let function = scanl (+) 0 in function [1,2,3]
23:30:00 <lambdabot>   [0,1,3,6]
23:30:40 <blackdog> kmc: so, i'm ending up in "findPrinter", which is my C function, but at the bottom of the stack is s2Dau_info, which would be a haskell thing, right?
23:30:53 <blackdog> (innermost, i mean)
23:30:57 <kmc> yeah
23:31:28 <blackdog> so that means i'm calling back into haskell?
23:32:16 <kmc> it just means the Haskell code called C code, right?
23:33:28 <blackdog> uh. does it? i have newContext, which calls findPrinter (all in the C), but the next call is s2Dau_info
23:34:05 <kmc> maybe i have the meaning of "bottom" backwards
23:49:35 <blackdog> so i'm a bit confused - my program isn't compiled with the threaded runtime, yet when i run it under GDB, it announces four new threads
23:49:48 <blackdog> forkIO is just a haskell thread, right?
23:50:05 <opqdonut> forkIO is a "system" thread
23:50:23 <opqdonut> no, wait
23:50:27 <quicksilver> forkIO is a haskell thread.
23:50:45 <opqdonut> yeah it's a lightweight thread
23:50:48 <quicksilver> the other threads you're seeing blackdog are an IO manager and some windows OS gubbins
23:50:52 <quicksilver> I believe.
23:54:08 <blackdog> quicksilver: ok. so all of my printer stuff should be being called on a single thread on the C side, but i'm accessing sqlite from multiple haskell threads, and possibly multiple real threads?
23:55:50 <quicksilver> blackdog: if you're not using the threaded runtime, then everything haskell will come in fmor a single thread
23:55:54 <quicksilver> "the main thread"
23:56:02 <quicksilver> the other threads are for housekeeping tasks and should be invisible
23:56:32 <quicksilver> if you *are* using the threaded runtime, then you typically have as many threads as you specify in the -Nx flag *plus* extra threads for FFI calls
23:56:34 <btutt> yep, other threads are for Win32 gooberness 'cause select sucks on windows
23:57:18 <blackdog> ok. i'm not using the threaded runtime
23:57:29 <blackdog> so if i can ignore that, i'm happy
23:57:49 * hackagebot peggy 0.2.0.1 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.2.0.1 (HideyukiTanaka)
23:59:01 <btutt> (select in fact only works on sockets in windows)
23:59:06 <blackdog> still not quite sure where this awful bloody segfault is coming from though
