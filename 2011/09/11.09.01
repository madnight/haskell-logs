00:40:02 <Axman6> :t modifyMVar
00:40:03 <lambdabot> Not in scope: `modifyMVar'
00:40:09 <Axman6> @hoogle modifyMVar
00:40:09 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
00:40:09 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
00:50:04 <Eidel> Can anyone recommend a book for Java/OO-programmers who wants to learn Haskell?
00:50:24 <Axman6> @where lyah
00:50:24 <lambdabot> http://www.learnyouahaskell.com/
00:50:42 <Axman6> and forget everything you know about OO/Java as you go :)
00:50:53 <Saizan> at first, at least
00:51:39 <Eidel> Axman6: but i though OO was good :(
00:51:45 <Eidel> lambdabot: thanks
00:52:28 <Axman6> it's good in that it's easy to think about things in that way, but actually using it is not so great
00:53:01 <Eidel> I am very experienced with java, and i'm struggeling a bit with haskell now :P
00:53:10 <Saizan> OOP has its places even within haskell, but it won't look the way you expect it to, and trying to map haskell concepts back to OO or viceversa will hinder your learning
00:53:16 <Eidel> Need to change my way of thinking
00:53:31 <Axman6> Eidel: it's really worth it though
00:53:54 <quicksilver> the main thing is not to assume that because a word sounds similar the concept must be similar
00:53:58 <bscarlet> Eidel: I found Real World Haskell useful too.
00:54:02 <bscarlet> @where rwh
00:54:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:54:05 <ehamberg> Eidel: many of use came from OOP – things may seem strange at first, but it *is* worth it. :)
00:54:12 <quicksilver> typeclass is a false friend, and so is functor (relative to the way other languages use those words)
00:54:25 <ehamberg> and don't think Java/OO when you read “class” in Haskell ;)
00:54:31 <Eidel> :D
00:54:39 <Eidel> lambdabot: thx
00:54:51 <Axman6> lambdabot is a bot btw ;)
00:55:01 <Eidel> aha, doh XD
00:55:18 <Eidel> Do you guys use haskell in the industry or just in academic?
00:55:26 <bscarlet> industry
00:55:27 <Axman6> i've used it for both
00:55:35 <lambdabot> but i'm not offended
00:55:44 <Axman6> heh
00:55:55 * Axman6 -> training
00:56:06 <lambdabot> Eidel: yw
00:56:11 <Eidel> Ok. I havent seen much of haskell in the industry
00:56:30 <Eidel> though ive seen erlang alot
00:56:40 <Axman6> there's no such thing as 'the industry', there's lots of them
00:57:13 <Axman6> erlang needs a type system (even joe armstrong agrees!)
00:57:36 <trez> would be great!
01:00:07 <Eidel> This course is gonna be cake now :)
01:02:15 <shachaf> You're eating cake?
01:03:42 <Eidel> Eating up this lab.
01:09:45 <jrockway> :t (($) $)
01:09:46 <lambdabot> forall a b. (a -> b) -> a -> b
01:14:45 <jrockway> is there any particular reason why Data.Set is not a Functor?
01:14:49 <jrockway> it has a map operation, after all
01:14:53 <shachaf> jrockway: Ord constraint.
01:15:07 <jrockway> aha, makes sense
01:15:18 <bscarlet> sad, sad sense.
01:15:25 <shachaf> Indeed.
01:15:48 <quicksilver> there is a whole industry dedicated to the production of blog posts on the subject of how Data.Set can be made into a Functor
01:16:13 <quicksilver> some people expect it to eventually outpace the previously popular industry of monad tutorial writing.
01:17:01 <shachaf> quicksilver: My money's on the monad tutorials.
01:17:30 <shachaf> A sufficiently-elaborate discussion of restricted functors or what have you will almost always turn into an explanation of restricted monads.
01:17:54 <shachaf> And from there it's not very far to a general explanation.
01:18:33 <bscarlet> But if we could make Set a monad, we could use it in the monad tutorials...
01:27:40 * hackagebot BiobaseTrainingData 0.1.2.0 - RNA folding training data  http://hackage.haskell.org/package/BiobaseTrainingData-0.1.2.0 (ChristianHoener)
01:34:31 <kuribas> Wouldn't it be cool to have a nonlinear video editor written in haskell?
01:35:43 <elliott> sure, you wanna do it?
01:39:26 <elliott> I'm using cabal-dev. My program uses Template Haskell, so if I just try and do --ghc-options="-prof -auto-all -rtsopts", I get the "Dynamic linking required, but this is a non-standard build (eg. prof)." error, and I don't seem to be able to coerce cabal-dev into rebuilding this way. So instead, I tried --enable-executable-profiling --ghc-options="-auto-all -rtsopts" -- but this doesn't seem to compile a profiling version at all, and the resulting
01:39:26 <elliott>  executable does not take RTS options!
01:39:33 <elliott> Does anyone know what could be wrong?
01:47:38 <kuribas> elliott: I am thinking about it :)
01:48:00 <elliott> kuribas: sounds good :)
02:42:40 * hackagebot xhtml 3000.2.0.4 - An XHTML combinator library  http://hackage.haskell.org/package/xhtml-3000.2.0.4 (ChrisDornan)
02:59:24 <Rmx> I use Overloaded string, and want to concat 2 strings, but I run into type problems
02:59:25 <Rmx>     setHeader "Content-Disposition" ("attachment; filename=" ++ "name.plop")
02:59:30 <Rmx> this doesn't complile
02:59:34 <Rmx> what do I do wrong?
03:00:24 <quicksilver> well ++ only works for real strings
03:00:35 <quicksilver> if you want that to be a non-String overloaded string you can't use ++
03:00:39 <quicksilver> you could try `mappend`
03:00:41 <Eduard_Munteanu> @hoogle mappend
03:00:41 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
03:00:50 <Rmx> thanks!
03:53:52 <Rmx> someone know a lib to execute command in cmd from Haskell program
03:53:57 <Rmx> I'm under windows 7
03:54:05 <Rmx> and would like to be able to write things like
03:54:07 <Lemmih> Rmx: See System.Process.
03:54:21 <Rmx> execute "cd /plop"
03:54:25 <Rmx> for example
03:54:26 <Rmx> ok
03:54:30 <Rmx> I take a look now
03:54:32 <Rmx> thanks:)
03:55:22 <justin-kp> is there a function that splices a value between every value in a list
03:55:37 <osfameron> intercalate?
03:55:51 <justin-kp> @type intercalate
03:55:51 <lambdabot> forall a. [a] -> [[a]] -> [a]
03:56:35 <justin-kp> lambdabot: intercalate ", " ["a","b","c"]
03:56:40 <byorgey> > intercalate "! " ["hello", "there", "world"]
03:56:40 <lambdabot>   "hello! there! world"
03:57:03 <byorgey> you may also want intersperse
03:57:15 <byorgey> > intersperse "! " ["hello", "there", "world"]
03:57:15 <lambdabot>   ["hello","! ","there","! ","world"]
03:57:26 <byorgey> the difference is that intercalate does a final 'concat'
03:57:48 <justin-kp> is there something analogous for bytestrings
03:57:48 <byorgey> @type intersperse
03:57:49 <lambdabot> forall a. a -> [a] -> [a]
03:58:13 <Eduard_Munteanu> @hoogle intersperse
03:58:13 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
03:58:14 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
03:58:14 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
03:58:32 <justin-kp> perfect
04:19:50 <kevin07> What are Haskell and Java's main differences? I am having trouble spotting them other than syntax, evaluation and staticly typed stuff.
04:20:27 <kevin07> (From a Java point of view... I'm a Java fella)
04:21:53 <frerich> http://www.haskell.org/haskellwiki/Category:Idioms is a very nice resource!
04:21:57 <hpc> kevin07: java is massively OO, and haskell isn't, for one
04:22:32 <hpc> a more visible example might be
04:22:40 <hpc> try writing "map" in java
04:22:51 <hpc> > map succ [1..5]
04:22:52 <lambdabot>   [2,3,4,5,6]
04:22:55 <Botje> kevin07: referential transparency, first-class functions and closures
04:22:59 <kevin07> hpc: go on
04:23:11 <hpc> :t map
04:23:12 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:23:27 <hpc> map takes a function and a list, then applies that function to every element of the list
04:23:51 <hpc> try passing a function as a parameter to another function ;)
04:24:06 <hpc> i don't actually know how to do it, i just remember that it's five lines of boilerplate plus an import
04:24:16 <kevin07> hpc: for (int i : yourArray) S.o.println(i);
04:24:37 <zygoloid> kevin07: your question is hard to answer, since most things are different
04:25:04 <kevin07> zygoloid: maybe I should put it: what makes Haskell better than Java?
04:25:07 <kevin07> I mean, Java is everywhere!
04:25:11 <kevin07> Where is Haskell?
04:25:19 <hpc> kevin07: you technically wrote mapM_ println
04:25:24 <kevin07> (and no I'm not inciting hate upon Haskell. I'm just curious)
04:25:32 <hpc> kevin07: you have to be able to pass any function you want to it, and get a list of actions back
04:25:35 <kevin07> (playing devil advocation)
04:25:38 <zygoloid> kevin07: you're asking two very different questions there
04:26:00 <balta2ar> what makes a hammer better than a knife? those are just different tools
04:26:09 <kevin07> hpc: anything you can do in one language, you can do in another in some way... it's both turing complete
04:26:10 <zygoloid> the first ('better than') question is unanswerable because it's subjective
04:26:28 <geheimdienst> iirc, it's something like: "map(new Runnable() { public void run() { ... }});" except you have certain limitations then. the run() method can only access variables that are declared final, etc.
04:26:49 <Saizan> for is not a function, it's a language construct, also for doesn't take much resembling a function, it rather works as a binder itself
04:26:53 <kevin07> balta2ar: hammer would (probably) be better against armour, while knife is better against average person (non-amoured). Stupid analogy
04:27:01 <zygoloid> kevin07: as for 'where is haskell?', see this: http://www.haskell.org/haskellwiki/Haskell_in_industry
04:27:29 <Saizan> anyhow, turing tarpit arguments are viscous
04:27:37 <kevin07> Saizan: for() is a function, but that's a whole different ball-game. I've had this debate many times
04:27:39 <hpc> Saizan: nice pun
04:28:22 <balta2ar> kevin07: same to haskell & java. some problems are better to solve with haskell, others with java
04:28:28 <zygoloid> kevin07: ok, if for() is a function, write another function which behaves the same but iterates over the list in reverse :p
04:28:43 <geheimdienst> kevin07: for me the main difference is that in haskell, it's kinda hard to get something to compile, but once it does, it rarely has bugs anymore. in java, you have much more possibility for runtime errors (NullPointerException for example). the haskell compiler is just damn helpful, i feel
04:29:00 <zygoloid> (that is, you should be able to replace 'for' with 'reverse_for' in the above code and get that effect)
04:29:23 <kevin07> zygoloid: for (int i = INIT_VAL; i > UP_BOUND; i--)
04:29:33 <zygoloid> kevin07: that does not achieve the stated goal
04:29:55 <kevin07> zygoloid: you could recursively call for()
04:30:10 <Saizan> write a function that abstracts that code away, rather than having to repeat it every time you need something like that.
04:30:34 <kevin07> Saizan: it's called a method
04:30:40 <Saizan> it's easy to do in any language with proper support for first-class functions
04:30:45 <Saizan> it's not easy in java.
04:31:03 <kevin07> Saizan: okay, can you explain why java doesn't have functions?
04:31:18 <delamonpansie> hi
04:31:44 <Saizan> java has functions, what it doesn't have is functions which take other functions as parameters, or which return functions
04:31:47 <kevin07> delamonpansie: hey, mate
04:32:02 <Saizan> you've to go through what OOPers call "functors" to achieve that
04:32:04 <kevin07> Saizan: you could do that with an ADT
04:32:09 <Saizan> i.e. objects with a call method
04:32:15 <kevin07> Saizan: yeah
04:32:25 <kevin07> Saizan: what's wrong with this?
04:32:26 <delamonpansie> I'm strugling with haskel-cairo. why is "sequence_ $ replicate 5000 (relLineTo 0.1 0.1)" allocating like crazy?
04:32:45 <hpc> @src sequence_
04:32:45 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
04:32:59 <frerich> kevin07: I think one important difference is taht in Java, your functions may have side effects at any point. In Haskell, functions have no side effects during evaluation (they are "pure") and you explicitely have to mark impure functions (that is, things which may have side effects) as such. Also, you cannot call impure functions from pure ones (but the other way around is fine).
04:33:20 <hpc> delamonpansie: is it just allocating, or is it consuming lots of memory?
04:33:22 <frerich> kevin07: By trying to express as much of your code in pure functions, reasoning about your code is much easier (and things like threading becomes quite straightforward, too)
04:33:37 <hpc> haskell programs that allocate a lot aren't going slow, they are going fast
04:33:44 <Saizan> kevin07: it's harder to do and requires a lot of boilerplate, which means too much effort to really write code in proper functional style
04:33:57 <kevin07> Saizan: boilerplate?
04:34:00 <frerich> kevin07: This property of functions "behaviour only depends on given arugments, and same arguments will yield same result" is called "referential transparency" and it's very convenient.
04:34:10 <delamonpansie> hpc: allocating, acording profile - 100%
04:34:45 <delamonpansie> hpc: here full source https://gist.github.com/1186053
04:34:46 <kevin07> Just out of curiosity, you guys do realise that OO languages, such as Java, are the main ones in this world, right?
04:35:02 <hpc> kevin07: not really
04:35:05 <zygoloid> kevin07: for reference, in haskell: mapM_ println someList -- print forwards. reverseMapM_ println someList where reverseMapM_ f = mapM_ f . reverse -- print backwards.
04:35:25 <hpc> kevin07: most websites are written in php, most embedded code is C
04:35:26 <delamonpansie> hpc: C counterpart is faster about 10 times...
04:35:45 <kevin07> hpc: yeah, but C can be extended to be OO
04:35:45 <hpc> and a lot of theoretical research is done in functional languages
04:35:57 <Saizan> kevin07: yes, i've to create a new class where to place the code for the function i want to pass as argument, then create an object out of it which i can finally use as an argument
04:35:59 <Entroacceptor> you can write OO in Haskell, too
04:36:00 <kevin07> hpc: theoretical research....
04:36:10 <Entroacceptor> kevin07: why did you start trolling?
04:36:18 <sbrg> what Entroacceptor said
04:36:40 <kevin07> Entroacceptor: I'm not trolling. As I said earlier i'm playing devil's advocate in an attempt to learn more about this
04:36:41 <geheimdienst> kevin07: i feel java in a subtle way encourages copy-paste programming. often you have two functions that differ maybe only in 1-2 lines, but if you try to merge it into one common function, it's difficult or ugly. in haskell, it's easy to pull out nearly anything into a parameter
04:36:46 <sbrg> kevin07: Yep, theoretical research.. you know, the kind that advances computer science and programming languages
04:36:54 <kevin07> I feel people express their opinions and reasons better when challenged with an argument
04:37:09 <sbrg> kevin07: Then present an argument and a case
04:37:18 <sbrg> e.g. what are you arguing for and what is your argument?
04:37:33 <kevin07> sbrg: in a sec, I need to do a wee and I'll think of one relating to the current topic
04:37:49 <kevin07> afk
04:38:00 <sbrg> not sure if to feed troll
04:38:16 <sbrg> or whether to alt tab and do something else
04:38:29 <hpc> i think he just has no idea why devil's advocate is a bad way to start a discussion
04:38:31 <geheimdienst> sbrg: i don't feel he's trolling much. he's playing devil's advocate and trying to poke holes in the things presented as haskell's advantages ...
04:38:52 <Saizan> i'd rather we stop, really, even if with "good intentions" using that technique to gain informations should be discouraged rather than enabled
04:39:06 <sbrg> Perhaps.. But stuff like "you do reaelize that OO languages like java are the main in the world, right?"
04:39:13 <sbrg> is .. meh
04:39:16 <kevin07> alright I don't need to do one anymore. Okay argument is as follows: OO languages, such as Java are used everywhere (as said by Sun among others), what makes Haskell better? What are it's advatages? Specifically on Java
04:39:34 <zygoloid> kevin07: firstly, that statement is sorta false and sorta meaningless
04:39:43 <kevin07> zygoloid: quote the part
04:40:00 <hpc> "are used everywhere (as said by Sun among others)"
04:40:02 <kevin07> I'll ellaborate. I have lots of trouble articulating what I am thinking
04:40:43 <sbrg> kevin07: Obviously, comparing two languages is stupid. And even more so when they are languages of completely different paradigms. Second; well, what makes haskell a great language? Purity, separation of side-effects from pure code, the rich 'standard library'(I know guys, ghc stuff isn't haskell98) and this awesome community
04:40:44 <kevin07> hpc: http://news.cnet.com/Sun-spreads-the-Java-everywhere-message/2100-1001_3-227144.html
04:40:45 <zygoloid> if by "OO languages" you mean "languages in which OO is possible", then Haskell is such a language. if you mean "languages in which OO is enforced", then it's false. Java is the /only/ popular language which forces OO
04:40:46 <kevin07> 1 example
04:41:10 <sbrg> C has no standard library for threading or network programming. Haskell has both. C++ has neither as well, though I believe they are in the newly confirmed standard
04:41:21 <kevin07> zygoloid: smalltalk?
04:41:25 <zygoloid> sbrg: still no networking
04:41:28 <XniX23> could someone help me understand the solution called "Simple solution" -> http://www.haskell.org/haskellwiki/99_questions/Solutions/9  im kinda lost not knowing how to think in this example
04:41:33 <sbrg> zygoloid: They didn't put asio in C++?
04:41:40 <balta2ar> kevin07: why dont you read this first: http://www.haskell.org/haskellwiki/Why_Haskell_matters
04:42:14 <zygoloid> kevin07: smalltalk is not even in the to 50 most popular languages, according to TIOBE.
04:42:26 <zygoloid> sbrg: deferred to TR2
04:42:40 <kevin07> zygoloid: It was in the 90s
04:42:52 <sbrg> Hehe. I can't help but feel picturing a braveheartish scene. "GATHER THE MEN, SOMEONE IS ATTACKING HASKELL". I mean this in a good way, though. :) I'm a zealot myself
04:43:19 <chrisdone> 'ello ello
04:43:28 <zygoloid> kevin07: MC Hammer was popular in the 90s
04:43:30 <chrisdone> https://github.com/vincenthz/hs-tls
04:43:32 <chrisdone> officially awesome
04:43:32 <quuuux> zygoloid: how are we defining OO? Does Python count as purely OO?
04:43:38 <sbrg> zygoloid: touche
04:43:42 <kevin07> zygoloid: I like one of his songs. Irrelevent
04:44:03 <chrisdone> sure is haskell-blah in here
04:44:40 <sbrg> chrisdone: Gather your weapons. Haskell is being attacked.
04:44:43 <kevin07> Anyway, I think arguments over. I need to get back to English homework or I'll have an English support teacher following me around all next term :(
04:44:49 <sbrg> well, no. But kevin07 is asking what makes haskell good
04:44:50 <kevin07> Thanks for the conversation guys
04:44:57 <elliott> that was a conversation?
04:45:02 <kevin07> I'll sure to be back and prepare better arguments
04:45:03 <hpaste> hpc pasted “fixed 99.9” at http://hpaste.org/50840
04:45:09 <hpc> XniX23: ^
04:45:12 <elliott> kevin07: please don't devil's avocado next time
04:45:16 <elliott> it's disruptive
04:45:26 <kevin07> elliott: advocado is a fruit, but whatever
04:45:29 <hpc> XniX23: i just renamed some expressions so you can better see what it does
04:45:32 <elliott> kevin07: REALLY???
04:45:33 <kevin07> kevin07: and I'm trying to learn about it!
04:45:44 <XniX23> hpc: thank you, ill have a look
04:46:02 <hpc> XniX23: imagine it starting from the end of the list instead of the front
04:46:04 <kevin07> elliott: the bullying wasn't called for :\
04:46:16 <elliott> kevin07: what bullying?
04:46:17 <kevin07> Everyone starts somewhere mate, even if they seem stupid
04:46:30 <hpc> and pack tells you how to stack more elements onto the groups list
04:46:31 <zygoloid> kevin07: please start with a more constructive attitude :)
04:46:39 <sbrg> time to go to the doctor for him to tell me my shoulder is fine and I should stop lifting 'such heavy weights'. yay.
04:46:42 <elliott> no but seriously, what bullying
04:46:44 <chrisdone> @seen vincenz
04:46:44 <preflex>  vincenz was last seen on #haskell 2 years, 165 days, 15 hours, 24 minutes and 19 seconds ago, saying: Alright, thanks.
04:46:45 <sbrg> eh, wrong channel
04:46:45 <lambdabot> Unknown command, try @list
04:46:45 <kevin07> elliott: I let you know that an avocado was a fruit and you attacked me with sarcasm
04:46:51 <chrisdone> hm
04:46:55 <chrisdone> does he go by another nick?
04:47:06 <chrisdone> lambdabot: seen vincenz
04:47:26 <Saizan> lambdabot has been blind for a while now
04:47:30 <elliott> kevin07: attacked? you pedantically corrected an obviously intentional silliness, I don't think a small dose of sarcasm is unjustified
04:47:54 <chrisdone> guys, please
04:48:07 <kevin07> elliott: Alright, fair enough. I accept your apology. Next time we'll get down to business discussing Haskell.
04:51:01 <Boney> If I have a medium sized haskell program that gives Stack Overflow.
04:51:16 <Boney> how do I find out what part of the program is using the most stack space.
04:51:37 <quicksilver> preflex: seen cpoucet
04:51:38 <preflex>  cpoucet was last seen on #haskell 3 years, 109 days, 18 hours, 49 minutes and 44 seconds ago, saying: edwardk: the new post ?
04:51:41 <Boney> (I would normally want to see a stack trace and look for something that's recursive or mutually recursive)
04:52:04 <quicksilver> haskell stack overflows are triggered by reducing very deep thunks
04:52:11 <quicksilver> not by very deep recursion per se
04:52:21 <quicksilver> (although, admittedly, deep thunks are normally produced by recursion)
04:52:27 <Boney> that was worring me.
04:52:38 <hpc> @quote oasis
04:52:38 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
04:52:50 <Boney> How do I find which of my thunks is deep?
04:52:51 <quicksilver> > foldl1 (+) [1..10^9]
04:53:07 <lambdabot>   thread killed
04:53:22 <hpc> Boney: use trace to feel your way around the program, then add strictness annotations and see if the overflow fixes itself
04:53:23 <quicksilver> hmm. that's a stack overflow in theory although possibly the optimiser gets it right.
04:53:34 <hpc> Boney: alternatively, profile it :P
04:53:36 <Boney> You don't have a debugging tool?
04:54:03 <zygoloid> Boney: haskell is weak in that area, sadly. you may be able to get something out of ghci's debugger, but it's not awesome
04:54:09 <Boney> When java/python crashes it gives me a big ugly stack dump (I realize lazyness complicates this but this is what I really want, it'll point me straight at the problem)
04:54:14 <robbe-> > foldl1' (+) [1..10^9]
04:54:19 <lambdabot>   mueval-core: Time limit exceeded
04:54:24 <robbe-> :(
04:54:32 <elliott> you can get a stack trace sometimes Boney
04:54:37 <elliott> compile with profiling and +RTS -xc
04:54:42 <Boney> okay.
04:54:42 <elliott> it's not very pretty, though
04:54:48 <Boney> It'll do.
04:54:53 <elliott> Boney: your best option for a debugging tool would be decomposing the application and testing parts in ghci
04:54:57 <Saizan> JaffaCake recently said he figured out how to do stack traces, but i bet it's not implemented yet :)
04:55:02 <Boney> I hate systems that make me grope in the dark and use "intuition"
04:55:13 <elliott> Boney: if you've written the archetypical perfectly-structured Haskell application, then it's really easy to test any component
04:55:24 <elliott> but, that depends on whether you have :)
04:55:30 <quicksilver> Boney: it is a real weak point in our toolchain, yes
04:55:32 <Boney> I know that Bernie Pope was working on something like this (but moreso for debugging).
04:55:36 <XniX23> hpc: im not sure i imagine what "groups" are in this case :\
04:55:50 <quicksilver> although it bites me less often than I would have imagined, since I right programs differently in haskell
04:55:56 <quicksilver> with functions separately testable in ghci
04:55:58 <chrisdone> Simon Marlow is working on stacktraces at the moment
04:55:58 <Boney> elliott: even if I had, I'm not the only author :-)
04:56:04 <Saizan> Boney: http://www.haskell.org/haskellwiki/Stack_overflow <- it helps to know how a stack overflow works in haskell
04:56:05 <hpc> XniX23: imagine the list "abbaab"
04:56:07 <quicksilver> so if I have a stack overflow I know where it is
04:56:15 <hpc> XniX23: "abbaab" ["b"]
04:56:18 <elliott> Boney: Well, first systematically eliminate all other authors...
04:56:19 <hpc> XniX23: "abbaa" ["bb"]
04:56:21 <frerich> quicksilver: Mmh, in Haskell, you "right programs". A freudian slip?
04:56:26 <hpc> XniX23: "abba" ["a","bb"]
04:56:29 <hpc> etc
04:56:38 <Saizan> Boney: then you can see that you've to look for strict non-tail recursion or accumulator-lazy tail-recursion :)
04:56:46 <elliott> I never right programs, I always wrong them :/
04:57:01 <quicksilver> frerich: no, a insight into a flaw in the language centres of my brain ;)
04:57:11 <chrisdone> i've never needed a strack trace in haskell. i am a lucky, lucky boy
04:57:12 <hpc> XniX23: basically, compare the current character to the current group; if they don't match, we are starting a new group
04:57:20 <hpc> XniX23: otherwise keep adding to the current group
04:57:27 <Boney> Thanks guys.
04:58:11 <elliott> chrisdone: I needed my first one earlier today, to figure out where a fromInteger was being erroneously called (it was stubbed out to just error)
04:58:16 <hpc> chrisdone: i came close to needing one while tracking down an unclosed db statement
04:58:22 <elliott> then I learned how to get one and now I am passing my knowledge on :-)
04:58:24 <elliott> it didn't help though
04:58:38 <elliott> (it was being called inside the default implementation for negate, which wasn't in the trace at all. oops.)
04:59:46 <luite> aoparently stack overflows contain lots of <nowiki>
04:59:57 <delamonpansie> I'm trying to write small program which make use of cairo. the problem is that haskell-cairo is very slow: several orders of magnitude slower than plain C. here the source https://gist.github.com/1186053 . Is it possible to speed up haskell variant?
05:00:04 <chrisdone> luite: did you try ghcjs?
05:00:34 <elliott> delamonpansie: btw, your sequence_ (replicate ...) is replicateM_
05:00:40 <luite> chrisdone: not yet
05:00:44 <elliott> i doubt that will help your performance much, but oh well, try it?
05:01:55 <chrisdone> i typically get weird behaviour far more than i get exceptions
05:02:05 <delamonpansie> elliott: a bit faster. but still two order of magnitude slower
05:02:17 <dcoutts> delamonpansie: and you're presumably compiling with -O etc
05:02:41 <delamonpansie> dcoutts: -O --make
05:02:51 <chrisdone> @src replicateM_
05:02:52 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
05:03:04 <chrisdone> i doubt replicateM_ is much faster than sequence_ (replicate ...)
05:03:08 <chrisdone> in core they are probably the same
05:03:26 <delamonpansie> well, it's probably measurment err
05:03:30 <rostayob> chrisdone: btw, does ghcjs work with ghc 7?
05:03:42 <chrisdone> rostayob: yeah; that's the one the author tests with
05:04:15 <rostayob> chrisdone: mhm, I'm trying building the test but it doesn't work
05:04:22 <Younder> The autor being Petre Jones?
05:04:23 <chrisdone> what's the error?
05:04:31 <rostayob> chrisdone: just a second
05:04:49 <chrisdone> no, Victor Nazarov
05:05:01 <chrisdone> (i mean the current author)
05:05:37 <joe6> i need some data structure advice. I have a number of bitfields that I am importing from C as functions.
05:05:37 <lambdabot> joe6: You have 1 new message. '/msg lambdabot @messages' to read it.
05:05:54 <joe6> I know that it is recommended to have bits represented as bool.
05:06:08 <joe6> i have a range of bitfields with sizes from 1 to 8
05:06:11 <chrisdone> bbl, meeting
05:06:24 <joe6> and I am thinking of representing them as tuples of bool.
05:07:00 <joe6> but, that would mean that each function would have a different type signature and that would be confusing to interface with.
05:07:25 <rostayob> joe6: that's what I did: http://hackage.haskell.org/packages/archive/sundown/0.1.2/doc/html/src/Text-Sundown-Flag.html
05:07:26 <joe6> I could do a Word8, but then I would need some mechanism to capture overflow's.
05:08:11 <rostayob> you could easily add other functionalities I guess...
05:08:24 <shlevy> If I have a file with contents like https://gist.github.com/1186099 , how can I tell Parsec to parse it in such a way so that head StringList1 gives me "Hello" instead of 2?
05:08:53 <joe6> rostayob: cool, that is something along the lines of what I am looking for.
05:09:12 <rostayob> joe6: but yeah there is no overflow checking
05:09:31 <rostayob> if you go over 32, it's your fault :P
05:10:32 <joe6> rostayob: not exactly 32 that I am concerned about. I am thinking more in terms of "if the bitfield size is 2 and it is assigned 7"
05:10:56 <rostayob> joe6: well your problem is more complicated since you want to have bit fields of different sizes
05:11:32 <rostayob> but the problem is the same
05:12:26 <joe6> ok, thanks. i get the idea though. Thanks for sharing your stuff. I will use that as the backbone of what I am doing.
05:14:04 <rostayob> you could have something like "class BitField a where; bitFieldSize :: Int; addBitUnsafe :: a -> Int -> Bool -> a" and then have a addBit :: BitField a => a -> Int -> Bool -> Maybe a that checks
05:14:19 <rostayob> joe6: with bitFieldSize and addBitUnsafe
05:14:42 <hpc> joe6: you could also theoretically go with the way CPUs do it
05:14:57 <joe6> rostayob: that is smart, thanks. What do CPUs do?
05:14:58 <hpc> addBit :: BitField a => a -> Int -> Bool -> (Flags, a)
05:15:32 <hpc> where snd = the unsafe result, and Flags = stuff like overflow, underflow, etc
05:15:39 <Younder> chrisdone, waiting for email conformation will take hours
05:15:51 <joe6> hpc, thanks.
05:15:56 <chrisdone> Younder: what
05:16:23 <hpaste> rostayob pasted “ghcjs” at http://hpaste.org/50841
05:16:31 <rostayob> chrisdone: this is what happens
05:16:39 <Younder> chrisdone, oh, i'm registering at Haskellers
05:17:06 <chrisdone> Younder: why are you telling me?
05:17:07 <rostayob> joe6: but dealing with C bit fields will always be marginalli awkward :)
05:18:43 <chrisdone> rostayob: did you download the source of ghc?
05:19:11 <joe6> rostayob: thanks, will post what I use, when I have it.
05:19:30 <chrisdone> i followed the manual steps and built the base packages to .js files first, then ghcjs Test.hs
05:19:51 <chrisdone> i think BuildTest is trying to do it without the source and failing
05:19:59 <chrisdone> this is documented somewhere in a ticket, iirc
05:20:41 <chrisdone> i don't see it. anyway, i'd try the manual steps with ghc source
05:22:50 <joe6> btw, I would be using get and put to read/write values to the C location(variable) holding the bitfields.
05:23:09 <joe6> Is it a good idea to think about leveraging the Data.Binary class to this?
05:23:32 <joe6> as the Binary class also has the get and put functions.
05:23:51 <elliott> joe6: you want the Storable class
05:23:51 <elliott> in Foreign
05:23:56 <joe6> elliott, ok, thanks.
05:24:48 <JoeyA> The documentation in Foreign.Marshal.Alloc says: "If any of the allocation functions fails, a value of nullPtr is produced."
05:25:18 <JoeyA> However, invoking mallocBytes 1000000000 a couple times in GHCi throws an exception, rather than producing a nullPtr.
05:25:23 <XniX23> hpc: thank you, i finaly understand, kinda requires "high level - abstract" thinking ;o
05:27:57 <hpc> JoeyA: try it in a compiled program; ghci does odd things at times
05:30:46 <JoeyA> hpc: Also throws an exception.
05:31:17 <rostayob> chrisdone: here I am again, sorry
05:32:45 <hpaste> “Joey Adams” pasted “malloc actions throw an exception rather than returning nullPtr” at http://hpaste.org/50842
05:32:49 <rostayob> I think this might be the problem: "For now we only support 32-bit GHC for building base libraries. We emulate 32-bit integers in Javascript and we need base libraries to be build in 32-bit environment. You can build libraries on 32-bit system and use compiled Javascript on 64-bit system."
05:33:07 <rostayob> I'll try the manual steps anyway
05:33:13 <rostayob> *might be a problem
05:33:23 <JoeyA> hpc: Does the same in a compiled program.
05:34:15 <hpc> rostayob knows more than i do :P
05:34:53 <rostayob> hpc: no, what I said had nothing to do with the malloc problem! it was for chrisdone ehehe
05:35:02 <int-e> JoeyA: hmm. I prefer an exception, but the FFI specification says the function should return a null Pointer. So apparently this is an implementation bug. :/
05:35:13 <JoeyA> :(  I'd rather it throw an exception, so I'm glad it does.
05:35:29 <hpc> oh nvm lol
05:35:30 <JoeyA> I'm sure many libraries depend on this "bug"
05:36:21 <rostayob> JoeyA: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Foreign-Marshal-Alloc.html#failWhenNULL , this is used by mallocBytes
05:36:35 <rostayob> so yeah it doesn't follow the specification i guess
05:37:19 <rostayob> it's funny because it'd be simpler to return the nullPtr, after all all c libs follow that convention
05:37:46 <rostayob> so they definitely "want" to throw an exception
05:37:51 <int-e> JoeyA: see also http://hackage.haskell.org/trac/ghc/ticket/5071
05:38:23 <rostayob> "Have you seen any code that actually checks for nullPtr? I haven't. I think we made a mistake in the standard here."
05:38:40 <JoeyA> rostayob: Not really.  Having to handle the null case every time you allocate a library object gets tiresome.
05:38:56 <rostayob> JoeyA: yes that's what simonmar is saying
05:39:09 <rostayob> but in C, that's the standard
05:39:14 <rostayob> (that's all I was saying)
05:40:32 <int-e> And Haskell is not C.
05:41:19 <rostayob> int-e: the point I was trying to make is that they definitely want malloc to behave that way
05:42:44 <JoeyA> safeCons :: a -> [a] -> Maybe [a]; safeCons x xs = unsafePerformIO $ catch (Just <$> evaluate (x:xs)) (\_ -> return Nothing)
05:42:57 <luite> doesn't cabal-dev support flags?
05:43:54 <JoeyA> safeMap :: (a -> b) -> [a] -> Maybe[b]; ...
05:43:58 <JoeyA> Haskell is not C.
05:43:59 <rostayob> JoeyA: I don't get it. is your goal just a strict cons?
05:44:13 <rostayob> JoeyA: I'm saying the opposite ehe
05:44:17 <JoeyA> My goal is to point out that manual error handling is tiresome and error-prone in a language with exceptions.
05:44:43 <int-e> rostayob: I know. But I agree with Simon Marlow on that one - the behaviour as specified is not very sane.
05:44:43 <rostayob> JoeyA: all I was trying to say is that it's not a bug. They're knowingly diverging from the standard=
05:44:51 <JoeyA> ah, okay
05:45:04 <rostayob> int-e: yeah I agree
05:45:45 * JoeyA wonders if he should make an Acme module for "safe" list operations.
05:46:10 <JoeyA> I don't know enough best practices in Haskell to make it truly educational, though.
05:46:12 <rostayob> JoeyA: you're not the first one.
05:46:30 <JoeyA> (educational by counterexample, that is)
05:46:32 <rostayob> I heard loads of times about ideas regarding a safe prelude
05:47:04 <int-e> (I mean not checking for NULL is a big problem even in C programs where programmers are trained to always check for such exceptional return codes. Not all Haskell FFI users are very good C programmers.)
05:47:08 <JoeyA> rostayob: More specifically, a module that does a whole bunch of unsafe things to create the illusion of safety, not an actual attempt at safety.
05:48:02 <rostayob> int-e: you'd be surprised how many C programmers don't check what malloc returns every time!
05:48:11 <rostayob> or maybe you wouldn't :P
05:48:22 <JoeyA> On major platforms, you can let the MMU do that!
05:48:58 <int-e> And everybody knows that users LOVE core dumps :)
05:49:24 <JoeyA> Then they shouldn't be trying to list a directory with 300000000 files!
05:49:31 <rostayob> ehe
05:49:31 <JoeyA> ;-)
05:49:46 <int-e> Ok. I agree, they should not.
05:50:16 <rostayob> I think that almost all OSs will burn doing stuff in a directory with 300M files lol
05:52:14 <int-e> phew, depends on the file system. 'ls' will burn though, since it sorts the file names by default. :)
05:53:03 <rostayob> int-e: what I was saying is that even if the fs can handle it, the software that interfaces with the fs will most likely be useless
05:53:50 <rostayob> I actually remember a guy writing a blog post doing something with a directory similar to that, and it was hard
05:54:17 <rostayob> http://www.olark.com/spw/2011/08/you-can-list-a-directory-with-8-million-files-but-not-with-ls/ . and this is 8M
05:55:32 <JoeyA> See, this is why it's important to check malloc.
05:55:52 <JoeyA> It, err, makes a program crash in a slightly different way.
05:59:09 <JoeyA> Foreign.C.String.newCString doesn't handle Unicode, does it.
05:59:33 <hpaste> abhinav pasted “Find count of occurrences of ac*b in a string composed of {a b c}” at http://hpaste.org/50845
06:01:05 <warpy> suggestions on improving that paste?
06:01:39 <rostayob> JoeyA: no, it doesn't
06:01:40 <ClaudiusMaximus> JoeyA: not yet; though it might eventually use current locale (according to the docs at http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-String.html#g:2 )
06:01:51 <rostayob> JoeyA: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Foreign-C-String.html#castCharToCChar
06:03:39 <hpaste> abhinav annotated “Find count of occurrences of ac*b in a string composed of {a b c}” with “Find count of occurrences of ac*b in a string composed of {a b c} (annotation)” at http://hpaste.org/50845#a50846
06:03:56 <int-e> > let a [] n = n; a ('a':xs) n = b xs n; a (_:xs) n = a xs n; b [] n = n; b ('c':xs) n = b xs n; b ('b':xs) n = a xs $! n+1; b xs n = a xs n in a "abacbaaabbbaaccaadccb" 0
06:03:57 <lambdabot>   3
06:03:57 <rostayob> JoeyA: what you could to is to go through a bytestring, iirc there is a way to get an UTF-8 bytestring from a string
06:04:49 <rostayob> (with UTF-8 bytestring I simply mean that you break chars in separate Word8 when they're longer than a byte)
06:05:07 <Eduard_Munteanu> :t pack
06:05:07 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
06:05:09 <lambdabot> forall o n. (Newtype n o) => o -> n
06:05:20 <Eduard_Munteanu> @hoogle pack
06:05:20 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
06:05:20 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
06:05:20 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
06:05:42 <rostayob> http://hackage.haskell.org/packages/archive/utf8-string/0.3/doc/html/Data-ByteString-UTF8.html voila`
06:05:46 <rostayob> fromString
06:07:27 <JoeyA> Why can't that be used for newCString?  Compatibility with other planets?
06:07:49 <rostayob> JoeyA: ? you mean why doesn't it work like that by default?
06:07:57 <JoeyA> I guess
06:08:04 <rostayob> because showing UTF-8 in a *char is not exactly nice
06:09:41 <rostayob> JoeyA: splitting UTF-8 characters across different C chars
06:11:28 <rostayob> truncating characters is probably the best default behaviour
06:12:30 <EvanR-work> any 'default' behavior is going to be stupid, because its two totally different data structures. unless you clearly say what youre doing, its wtf
06:12:51 <EvanR-work> 'default' behavior for converting between two totally different data structures is the realm of php
06:12:59 <JoeyA> I shouldn't complain.  At least it's not UTF-16.  Otherwise, people wouldn't complain, and more applications wouldn't support codepoints above U+FFFF.
06:13:31 <rostayob> EvanR-work: still, we do have a function String -> CString
06:13:39 <EvanR-work> which is called?
06:13:55 <rostayob> EvanR-work: newCString?
06:13:56 <Axman6> @hoogle CString
06:13:56 <lambdabot> Foreign.C.String type CString = Ptr CChar
06:13:56 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
06:13:56 <lambdabot> Foreign.C.String newCString :: String -> IO CString
06:13:59 <hpc> EvanR-work: unsafeCoerce :P
06:14:05 <Axman6> no!
06:14:06 <rostayob> ok, ok, IO CString.
06:14:06 <EvanR-work> lol
06:14:09 <Axman6> bad hpc
06:14:10 <rostayob> eheh
06:15:15 <EvanR-work> yeah newCStringThatManglesCharactersAbove255 would be nice
06:15:32 <sbrg> If I were a super villain, I would break into the folding@home project, issue an update that runs a haskell program that repeatedly runs unsafeCoerce and unsafePerformIO, and the result would be a blackhole that would swallow our galaxy
06:15:37 <sbrg> amirite?
06:15:42 <rostayob> EvanR-work: we even have loads of partial functions in Prelude! and .Char8 in bytestring aaaahhhhh
06:16:06 <hpc> sbrg: you would make them run unsafeLaunchMissiles, then hold the world ransom for one million dollars :D
06:16:24 <sbrg> hpc: There is a safeLaunchMissiles?
06:17:08 <quicksilver> when the FFI was designed the *vast* majority of C code and libraries out there was still using char * for either ASCII chars or some particular 8-bit encoding (like 8859-*)
06:17:13 <EvanR-work> unwisePerformIO
06:17:40 <quicksilver> so the assumption to make String -> IO CString operate by taking the lower 8 bits was reasonable in that context
06:17:41 <JoeyA> quicksilver: And if they didn't care about case conversion, breaking up strings into characters, etc., then they also supported UTF-8.
06:18:15 <EvanR-work> but wait, what about 9bit char
06:18:23 <JoeyA> blasphemy!
06:18:57 <kizzx2> @pl add k v = modify $ Data.Map.insertWith (+) k v
06:18:57 <lambdabot> add = (modify .) . Data.Map.insertWith (+)
06:19:10 <kizzx2> ^ is that the best we can get if i want to pointless it?
06:19:40 <hpc> kizzx2: add = modify .: insertWith
06:19:45 <hpc> (.:) = fmap fmap fmap
06:20:15 <JoeyA> foreign import ccall unsafe "stdlib.h &free" finalizerFree :: FinalizerPtr a
06:20:19 <JoeyA> What does the & mean?
06:20:28 <hpc> kizzx2: it will look odd though
06:20:42 <Axman6> kizzx2: the answer to 'do i want point free' is almost always no
06:20:42 <hpc> JoeyA: address of?
06:20:42 <Axman6> don't do it
06:21:05 <Axman6> unless it's very obvious, pointfree style is something that, imo, should be avoided
06:21:09 <chrisdone> just because it's free doesn't mean you should take it!
06:21:16 <kizzx2> hpc: that's true, i think it's more odd than what @pl gave me
06:21:22 <EvanR-work> chrisdone: tragedy of the commons
06:21:40 <kizzx2> Axman6: ahh OK :)
06:21:47 <kizzx2> i guess it depends on what kind of tools we have on hand
06:21:49 <hpc> kizzx2: i use (.:) on my website to fmap "two levels deep" but only rarely
06:22:00 <hpc> and only when the metaphor is "functors as containers"
06:22:03 <joe6> any critique of this, please? http://codepad.org/ZlFiIeXC
06:22:07 <rostayob> @pl \f g (a,b) -> (f a, g b)
06:22:07 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
06:22:12 <rostayob> clearly better
06:22:14 <joe6> rostayob: this is what I ended up with: http://codepad.org/ZlFiIeXC
06:22:19 <JoeyA> hpc: That's what it means in C.  I wonder if FFI has a different definition.
06:22:22 <joe6> any suggestions, please?
06:22:41 <kizzx2> for example add3 = (3+) instead of add 3 x = 3 + x is rather clear..... so i guess if we had a standard clean way for compose functions with 2 arguments and it became widespread use, it could be clear too :P
06:22:52 <luite> are there plans to add the parallel cabal patches to cabal-dev?
06:22:54 <EvanR-work> rostayob: that is awesome
06:23:04 <Axman6> joe6: apart from '(Storable a) => (Bits a) =>' not making any sense...
06:23:07 <luite> or is that not necessary?
06:23:16 <Axman6> should be (Storable a, Bits a) =>
06:23:24 <joe6> Axman6: oh, thanks.
06:23:27 <Axman6> does the code there even work?
06:23:40 <joe6> I have not tried it, yet. it compiles.
06:23:50 <joe6> Axman6: I tried searching around for the syntax
06:23:55 <joe6> Axman6, thanks.
06:23:58 <kizzx2> hpc: regarding (.:), i think Haskell has a 2012 problem -- running out of operators
06:24:05 <Axman6> also, foo == True === foo
06:24:37 <Axman6> how come your cases for flag == True and flag == False are the same?>
06:24:38 <joe6> updated http://codepad.org/z8QaF1H9
06:24:57 <EvanR-work> ><>> fish operator
06:24:57 <joe6> Axman6: that is a mistabe
06:25:02 <joe6> s/mistabe/mistake.
06:25:03 <rostayob> joe6: do you need to fiddle with IO?
06:25:12 <chrisdone> rostayob:
06:25:13 <chrisdone> :t (***) :: (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
06:25:14 <lambdabot> forall t t2 t1 t3. (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
06:25:22 <joe6> updated: http://codepad.org/kTX1Ewu2
06:25:22 <chrisdone>  @pl doesn't know enough functions
06:25:33 <rostayob> chrisdone: apparently (:
06:25:52 <Axman6> :t (id ***)
06:25:52 <lambdabot> forall b b' c'. (b' -> c') -> (b, b') -> (b, c')
06:26:04 <Axman6> :t (show ***)
06:26:04 <lambdabot> forall b b' c'. (Show b) => (b' -> c') -> (b, b') -> (String, c')
06:26:09 <joe6> rostayob: I need to set the values in C and the peek and poke are IO functions.
06:26:23 <Axman6> :t ((undefined :: a -> b) ***)
06:26:24 <lambdabot> forall b c b' c'. (b' -> c') -> (b, b') -> (c, c')
06:26:54 <rostayob> joe6: yeah but I'd personally separate that functionality from setting pointers
06:27:50 <rostayob> also, symbolValue n >>= \x -> return $ f x should be liftM f
06:27:52 <joe6> rostayob: that is a good idea. but, I do not have an instance where I have these values floating around without setting the underlying variable.
06:27:54 <rostayob> or use do notation
06:28:02 <joe6> or, I could make it return functions?
06:28:09 <hpaste> duairc pasted “Simple RankNTypes program fails” at http://hpaste.org/50847
06:28:12 <hpc> rostayob: and liftM should be fmap
06:28:25 <joe6> updated with Axman6  comments: http://codepad.org/dQtMQoea
06:28:28 <rostayob> hpc: why?
06:28:30 <duairc> Could somebody explain to me why the program I just hpaste'd fails?
06:28:51 <hpc> rostayob: more people are used to seeing fmap than liftM, even if they are the same
06:29:04 <rostayob> hpc: they're not the same, a monad is not automatically a functor
06:29:20 <EvanR-work> ive been using liftM when using do notation
06:29:22 <hpc> rostayob: only if the author fails at instances
06:30:07 <rostayob> hpc: still, if you have Monad m => in the type sig, you can use liftM without adding Functor m :P
06:30:28 <rostayob> so when using monads I use liftM usually. but that's a concrete type so I guess fmap is nicer
06:30:56 <EvanR-work> the disadvantage of lifeM is its name
06:30:59 <EvanR-work> liftM
06:31:06 <EvanR-work> not as descriptive as fmap
06:31:19 <hpc> on a related note, can we please finally have class Applicative m => Monad m?
06:31:22 <elliott> (<$>) represent
06:31:30 <sbrg> ^
06:31:36 <hpc> elliott: word
06:31:37 <rostayob> well it's quite descriptive, you're lifting that function inside the monad
06:31:49 <EvanR-work> elliott == conal ?
06:31:53 <elliott> i agree that liftM just as descriptive as fmap though
06:31:55 <elliott> EvanR-work: nope
06:31:57 <EvanR-work> oh
06:32:05 <elliott> should start saying yes to that
06:32:12 <sbrg> i thought so as well EvanR-work
06:32:31 <elliott> don't let me dissuade you of your assumptions
06:33:19 <Axman6> EvanR-work: conal = conal elliot :P
06:33:28 <EvanR-work> 1 = elliot
06:33:54 <Axman6> aye
06:33:57 <elliott> Axman6: t
06:34:38 <elliott> us quadruple-letter elliotts need to start an organisation to stamp out misspellings
06:34:39 <Axman6> damnit HP, you're smart enough to know not to run your website on IIS >_<
06:34:50 <EvanR-work> eelliioott
06:34:52 <hpc> Axman6: no they aren't
06:35:00 <sbrg> conal is elliott
06:35:07 <hpc> Axman6: they sold their entire hardware division, so all bets are off on their ability to think straight
06:35:12 <sbrg> the more I look at the name the stranger i think it is
06:35:13 <sbrg> elliott
06:35:16 <sbrg> no offense, obviously
06:35:17 <EvanR-work> hpc: what about printers?
06:35:22 <sbrg> i need unicode and shit to spell mine
06:35:32 <Axman6> hpc: eh? they've sold nothing, and they only thinking of spinning off their PC group
06:35:36 <joe6> using liftM instead of return: http://codepad.org/xAHVAEng , source: http://codepad.org/K5DrTJQp
06:35:37 <elliott> hpc: haha, I was just about to say something about their new business strategy being to do as many stupid things as they could before the year's up :)
06:35:59 <moriramar> Excuse me, can't (ex :: [Maybe a]) get (Just 1) and (Just 'a') at the same time as its elements?
06:35:59 <joe6> using liftM gives me an error, when I use it instead of return.
06:36:11 <Axman6> moriramar: no
06:36:15 <elliott> liftM and return have different types
06:36:16 <Axman6> that's not well typed
06:36:19 <sbrg> :t return
06:36:20 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
06:36:21 <sbrg> :t liftM
06:36:22 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:36:27 <Axman6> :t [Just 1, Just 'a']
06:36:28 <lambdabot>     No instance for (Num Char)
06:36:29 <lambdabot>       arising from the literal `1' at <interactive>:1:6
06:36:29 <lambdabot>     Possible fix: add an instance declaration for (Num Char)
06:36:34 <hpc> joe6: \x -> return (f x) = fmap f
06:36:37 <Axman6> :t [Just 1, Just 'a', Just String]
06:36:37 <lambdabot> Not in scope: data constructor `String'
06:36:41 <hpc> return (f x) /= fmap f
06:36:46 <Axman6> :t [Just 1, Just 'a', Just "String"] -- >_>
06:36:47 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
06:36:47 <lambdabot>       Expected type: Maybe Char
06:36:47 <lambdabot>       Inferred type: Maybe [Char]
06:37:03 <rostayob> hpc: having Applicative m => Monad m would invalidate all the monad tutorials online!
06:37:07 <elliott> *BitField Foreign.Storable Foreign.Ptr Data.Bits Control.Monad> :t (\x -> return (flip setBit 1) x)
06:37:08 <Axman6> morirama: all elements in a list have to have the same type
06:37:12 <elliott> joe6: that's wrong
06:37:15 <moriramar> Axman6: Thank you. So I have to make it like JSON example in RWH Chapter 5?
06:37:15 <EvanR-work> rostayob: really, great!
06:37:16 <elliott> joe6: how do you think that parses?
06:37:22 <rostayob> EvanR-work: ehe
06:37:26 <elliott> joe6: (return (flip setBit 1)) x
06:37:32 <Axman6> moriramar: if you need that sort of functionality, then yes
06:37:32 <elliott> joe6: you can't apply (return foo) to anything, it's a monadic action
06:37:44 <moriramar> Axman6: Thanks a lot!
06:37:53 <Axman6> no worries
06:37:56 <azaq23> moriramar: You're thinking of an existential type - [Maybe a] does not mean that there exists some a per Maybe so that the list has an element of type Maybe a at a specific position
06:38:18 <zygoloid> > let foo = 42 in return foo "hello" -- you can apply return foo to anything if you import Control.Monad.Instances ;)
06:38:19 <lambdabot>   42
06:38:28 <elliott> zygoloid: not helpful :P
06:38:37 <elliott> that is what happened in :t though:
06:38:37 <elliott> (\x -> return (flip setBit 1) x)
06:38:37 <elliott>   :: (Bits c, Monad ((->) t)) => t -> c -> c
06:38:37 <moriramar> azaq23: Thanks.
06:38:52 <joe6> i am confused now, I will stick with >>= (\x -> return $ f x)
06:39:02 <elliott> joe6: that's >>= liftM f
06:39:09 <joe6> where f =  (flip setBit   pos)
06:39:18 <elliott> >>= liftM (flip setBit   pos)
06:39:20 <elliott> should work just fine
06:39:30 <joe6> elliott: i do not think so, it is giving me an error, when I do that.
06:39:37 <zygoloid> it's just liftM f, not >>= liftM f
06:39:47 <elliott> zygoloid: err, right
06:39:54 <elliott> joe6: ok, instead of:
06:39:59 <elliott> joe6: m >>= (\x -> return (f x))
06:40:01 <elliott> joe6: just write:
06:40:07 <elliott> joe6: f <$> m
06:40:13 <elliott> (import Control.Applicative to get that operator)
06:40:18 <elliott> tada :)
06:40:24 <joe6> elliott, thanks. will try that.
06:40:27 <EvanR-work> foo >>= \x ->..... why use do notation
06:40:31 <EvanR-work> why not use
06:41:04 <joe6> EvanR-work: it was a few functions and I did not want to add more symbols in there.
06:41:38 <EvanR-work> if youre having trouble writing it, maybe its going to be hard to read it ;)
06:42:24 <moriramar> EvanR-work: Is do-notation greatly encouraged?
06:42:34 <EvanR-work> no
06:42:47 <moriramar> EvanR-work: then discouraged?
06:42:49 <EvanR-work> no
06:42:50 <rostayob> moriramar: if a function is clearer to you in do notation, write it in do notation
06:43:05 <joe6> EvanR-work: i did not have trouble writing it. I have trouble changing it to liftM or <$> or fmap.
06:43:06 <zygoloid> writing things in the clearest fashion is greatly encouraged
06:43:16 <joe6> EvanR-work: i understand what you say, though.
06:43:20 <moriramar> rostayob, zygoloid, EvanR-work: Thanks.
06:43:28 <delamonpansie> dcoutts: well, i do unrolled it: ask >>= \cairo -> liftIO $ replicateM_ 50000 (I.relLineTo cairo 0.01 0.01), but it still same slow
06:44:28 <zygoloid> joe6: in order to read other peoples' code, you should become familiar with applicative notation and simple semantic editor combinators
06:44:37 <joe6> rostayob: what do you think of removing the IO and returning functions? I could then use this class in pure functions, too? http://codepad.org/YzvYU5TR
06:44:50 <joe6> zygoloid: ok, thanks. will do.
06:44:58 <azaq23> moriramar: I don't have a good resource which explains this well, likely other people here have though, but basically you'll just have to put explicit forall's before each type signature and think
06:44:58 <azaq23> about it for a while, respecting the fact that the body of each forall is just "interpreted" after the forall "comes into effect", and you should be able to understand haskell type signatures pretty
06:44:59 <azaq23> well - [Maybe t] can be read as forall t. [Maybe t], so for every possible t, there is a type [Maybe t] - it's not [forall t. Maybe t] or anything like that.
06:45:13 <duairc> Assuming that IO operation doesn't block, could mask_ be considered an atomically of sorts?
06:46:04 <Axman6> no, it doesn't stop a thread from being preempted, meaning that the internal state could be observed externally
06:46:09 <moriramar> azaq23: Ahhh, that's much clearer. Thank you. btw, is there anything like [forall t. Maybe t]?
06:46:12 <azaq23> moriramar: Also, lists are inductive datatypes as basically defined as data List t = Cons t (List t) | Nil - think of the forall direct after the data keyword and you should get why lists are as they
06:46:13 <azaq23> are
06:46:25 <Axman6> (assuming mask_ is what i think it is...)
06:46:30 <rostayob> joe6: you could also return something like [Word8], to represent the bitField
06:47:01 <delamonpansie> dcoutts looking in oprfile reveals it spends most time doing allocations. any thoughts?
06:47:01 <Axman6> @hoogle mask_
06:47:02 <lambdabot> No results found
06:47:03 <joe6> rostayob: but, the problem is that some could be bytes or long or long long.
06:47:06 <Axman6> @hoogle mask
06:47:06 <lambdabot> No results found
06:47:23 <rostayob> joe6: yeah exactly, you can have whatever length you want with [Word8]
06:47:32 <duairc> Axman6: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#g:11
06:47:52 <joe6> rostayob: makes sense.
06:48:11 <EvanR-work> moriramar: these existential types
06:48:14 <EvanR-work> theres
06:48:24 <duairc> Wait, no, I'm nuts, they're not the same thing at all.
06:48:33 <dcoutts> delamonpansie: so I've just run your example and they both take about the same time, about 0.06s for the Haskell and about 0.04s for the C
06:48:39 <rostayob> joe6: also, I don't get what you're doing if the index is greater than the bitfield
06:48:42 <duairc> But I think I can get away with in the specific program I'm writing.
06:49:00 <dcoutts> delamonpansie: doing allocations? you mean malloc or what?
06:49:06 <joe6> rostayob: just returning the value stored at that symbol.
06:49:23 <Axman6> duairc: if you have something like  do { let f = modifyIORef (+1); f ref; f ref; f ref; } another thread could see the state of the IORef when it's only had a single increment, which means it's not atomic
06:49:28 <azaq23> moriramar: In  a way - I think (but am unsure!) that [forall t. Maybe t], if it could be typed, would directly correspond to a type in which any Maybe value could be put in - but with existential
06:49:29 <azaq23> types, you can do it better: http://www.haskell.org/haskellwiki/Existential_type - with them, you basically define a type like this: data T = forall t. ... (<- see the position of the forall
06:49:29 <azaq23> keyword), and then you can do xs :: [T], and construct specific T's
06:50:01 <rostayob> joe6: no, you're doing it the other way around, bitFieldSize n > pos = symbolValue n, while in that case you should writer
06:50:07 <azaq23> moriramar: In GHC Haskell (so haskell 98 with all the fancy extensions), you can do pretty extensive things with an explicit forall keyword though
06:50:21 <delamonpansie> dcoutts which version of ghc  you are running?
06:50:32 <EvanR-work> moriramar: you probably dont want a list of 'any type'
06:50:46 <joe6> rostayob: yes, you are correct. Thanks.
06:51:07 <joe6> rostayob: http://codepad.org/Wd3AF4w9
06:51:11 <moriramar> azaq23, EvanR-work: Well, just for curious. :) Thanks again.
06:51:14 <rostayob> joe6: also, what you're doing makes it impossible to see if the action has succeded or not
06:51:50 <rostayob> joe6: I think it should be >=
06:51:52 <joe6> rostayob: yes, you are correct. will change to an error.
06:52:46 <rostayob> for example with a uint shifting by 32 would "overflow"
06:53:12 <rostayob> (assuming that you're starting from 0 of course)
06:54:05 <joe6> rostayob: thanks, http://codepad.org/qmwJSlrt
06:54:58 <joe6> rostayob: http://codepad.org/nVIchACO
06:55:40 <joe6> rostayob: thanks a lot for your help. I will try to use it, and then depending on how it works, will change it to [Word8] or function
07:00:56 <JoeyA> Are pack/unpack slower than using folds directly?  Or should fusion make the difference insignificant?
07:01:05 <JoeyA> (Data.ByteString)
07:02:02 <JoeyA> Specifically, I'm writing a string escaping function, where escapes are bigger than the octets they represent.
07:08:20 <EvanR-work> JoeyA: writing a string escaping algorithm sounds boring and unnecessary
07:08:29 <EvanR-work> already exists
07:08:58 <benmachine> JoeyA: I think common wisdom says you should avoid pack and unpack where possible
07:16:33 <rostayob> joe6: no problem, sorry if I didn't answer, I realized I had to meet someone
07:17:08 <joe6> rostayob: ok, thanks.
07:31:49 <joe6> not sure what I am doing wrong here: source : http://codepad.org/8FO5wHYz , error: http://codepad.org/r7iK6psi
07:32:01 <joe6> can anyone please help?
07:33:48 <dolio> @type show . read
07:33:48 <lambdabot> String -> String
07:34:04 <joe6> error: http://codepad.org/4zJCfbic
07:34:31 <dolio> Normally show . read would be an error.
07:34:31 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
07:34:34 <joe6> source :  http://codepad.org/8FO5wHYz error: http://codepad.org/4zJCfbic
07:34:42 <dolio> Because what type it should go through is ambiguous.
07:35:09 <dolio> You have set up a similar situation.
07:35:14 <joe6> dolio, which type? I added a type signature and all that.
07:35:19 <joe6> but, they do not seem to help
07:35:26 <dolio> You added a signature with a variable.
07:35:36 <dolio> What concrete type is it supposed to choose for that variable?
07:36:05 <Eduard_Munteanu> You might need scoped type variables.
07:36:28 <quicksilver> you never need scoped type variables but they certainly make life easier sometimes.
07:36:30 <joe6> dolio, which variable?
07:36:53 <Eduard_Munteanu> Yeah, that's fair.
07:37:11 <dolio> a1
07:37:49 <joe6> dolio, i added that type signature as the ghci was complaining about it.
07:38:06 <roconnor> quicksilver: really, there is a theorem stating you never nead scoped type variables?
07:38:12 <roconnor> *need
07:38:21 <joe6>  = (zipWithM_ (addBit n) [0..] flags) >> return 1
07:38:21 <copumpkin> *knead
07:38:27 <joe6> is what I had when I started off.
07:38:41 <quicksilver> roconnor: I believe I could write such a proof, yes.
07:38:41 <copumpkin> hmm, I think you might need scope type variables
07:38:48 <joe6> error with that code: http://codepad.org/ibzXZEnz
07:38:48 <roconnor> interesting
07:38:50 <quicksilver> roconnor: using tricks like asTypeOf
07:38:54 <roconnor> ya
07:39:15 <roconnor> certainly I've always been able to hack around things using asTypeOf and undefineds
07:39:16 <copumpkin> quicksilver: what if you don't have a value representing the type you want? because you need to return it?
07:39:21 <quicksilver> suppose your top signature is forall a . P(a) and you wish to refer later to 'a'
07:39:50 <quicksilver> you first write the auxiliary: getTheAOutOfTheP :: P(a) -> a; getTheAOutOfTheP = undefined
07:39:53 <joe6> = (zipWithM_ (addBit n) [0..] flags) >> return 1 --(valueOf n)
07:40:17 <quicksilver> and then where you were going to write "foo :: a" you write "foo `asTypeOf` getTheAOutOfTheP (topSignature)
07:40:26 <Eduard_Munteanu> Hm, neat.
07:40:27 <roconnor> quicksilver: for the record, this requires a to occur in P(a)
07:40:34 <joe6>  = (zipWithM_ (addBit n) [0..] flags) >> return 1 : error : http://codepad.org/t13L4icN
07:40:35 <quicksilver> roconnor: yes.
07:40:42 <quicksilver> scoped type variables also requires a to occur somewhere
07:40:49 <joe6> = (zipWithM_ ((addBit n) :: (Storable a1, Bits a1) => Int -> Bool -> IO a1) ([0..] :: [Int]) flags) >> return 1 : error: http://codepad.org/02BJZ4JZ
07:41:08 <roconnor> quicksilver: scoped type variables would bring a into scope in forall a. String.
07:41:14 <roconnor> I presume
07:41:24 <quicksilver> hmm, maybe you're right.
07:41:30 <byorgey> but if a never occurs in the type of anything then you have little need to annotate something with the type a.
07:41:37 <roconnor> quicksilver: not that I have (yet) a compelling use case for this
07:41:40 <quicksilver> but I don't think you can do much interesting with that.
07:41:53 <quicksilver> clearly my proof has a second case
07:42:07 <quicksilver> (in which a does not occur in P), which is left as an easy exercise for the reader
07:42:14 <roconnor> *lol*
07:42:22 <dolio> joe6: What type is a1 supposed to be?
07:42:24 <Saizan> i'm not convinced by getTheAOutOfTheP (topSignature)
07:42:53 <quicksilver> Saizan: topSignature is really theNameOfTheTermWhichHasTopSignature
07:42:55 <joe6> dolio, something that is Storable and has a Bits instance
07:43:01 <dolio> Which one?
07:43:04 <dolio> GHC has to pick one.
07:43:06 <quicksilver> hopefully that abuse of noation was clear :)
07:43:07 <copumpkin> is there a unificationey trick to detect (at the type level, refining to concrete types), if you have two things, whether one, the other, or both were involved in the unfiication?
07:43:35 <joe6> dolio, Storable, I guess.
07:43:44 <dolio> Storable isn't a type.
07:44:11 <joe6> i probably need a typeOf there?
07:44:11 <dolio> What type is it supposed to pick?
07:44:18 <dolio> No.
07:44:29 <joe6> dolio, it could be any of the types such as CUInt
07:44:29 <Saizan> quicksilver: yeah, the problem is that i'm not convinced you always have one, i needed to abuse MR to get it in some cases, and that wouldn't work without a typeclass context
07:44:32 <joe6> or CULong
07:44:47 <joe6> or any of the types in Foreign.C.Types.
07:45:02 <roconnor> quicksilver: unless theNameOfTheTermWhichHasTopSignature is a polymorphic term that happens to unify with the top signature, but will produce a new free type variable in getTheAOutOfTheP (due to the *lack* of the monomorphism restriction).
07:45:09 <dolio> Which one?
07:45:22 <quicksilver> roconnor, Saizan: oh...
07:45:23 <copumpkin> so say I have two terms, termA and termB. I want to be able to distinguish, via concrete types at the type level, termA `asTypeOf` termB, termA, and termB.
07:45:37 <dolio> GHC isn't going to pick one of those unless you give it a reason to do so.
07:45:39 <joe6> dolio, It could be anything
07:45:48 <copumpkin> joe6: why does it need to pick?
07:46:02 <dolio> If I write "show . read" which type should it pick to read and then show?
07:46:10 <Eduard_Munteanu> The caller could pick.
07:46:33 <Eduard_Munteanu> But even then it might not fix all variables.
07:46:33 <roconnor> wow, Saizan and I said almost the same thing.
07:46:40 <joe6> dolio, should I write an instance of addBits for CInt, CULong, CUInt, and so on.
07:46:48 <dolio> The caller can't pick, because the type of show . read is String -> String.
07:47:07 <Eduard_Munteanu> Oh, right.
07:47:07 <dolio> joe6: No, you should provide a signature that isn't ambiguous.
07:47:11 <copumpkin> that's why you need (Show a, Read a) => a -> String -> String
07:47:16 <copumpkin> where the a gets ignored
07:47:31 <kmc> (Show a, Read a) => Tagged s String -> String
07:47:36 <kmc> s/s/a/
07:47:50 <joe6> copumpkin: isn't that in agda, with implicit type variables?
07:48:22 <kmc> you can do that in any language with explicit polymorphism
07:48:31 <kmc> even C++
07:48:40 <joe6> dolio, I am sorry I do not understand what you are trying to convey.
07:49:08 <joe6> dolio, I see that there is something that you are trying to tell.
07:49:17 <joe6> dolio, but I am not able to comprehend it.
07:49:29 <joe6> dolio, any url/tutorial that might go into this deeper?
07:50:16 <bmars> Is it appropriate to describe ([a] -> b) as a "function space"?
07:50:40 <byorgey> bmars: sure
07:51:33 <copumpkin> bmars: it sounds more pretentious though
07:51:36 <dolio> joe6: Do you understand the show/read example?
07:52:06 <joe6> dolio, i understand the show . read, but I do not understand what you are trying to convey through it.
07:52:27 <dolio> joe6: Okay. The type of read is (Read a) => String -> a.
07:52:35 <dolio> The type of show is (Show a) => a -> String.
07:52:45 <dolio> Plug them together and you get String -> String.
07:53:11 <dolio> However, it needs to pick an a in the middle, so it knows what Show and Read instances to use.
07:53:29 <dolio> But, it's an ambiguous choice.
07:53:42 <dolio> It could pick anything, but every choice gives you a different function.
07:53:47 <quicksilver> (show.read is an inconvenient example, in a way, because the expected result of show.read is id whichever instance you use, so it might seem like it doesn't matter which instance you use. However, in general for such ambiguous choices it may lead to completely different results)
07:54:05 <copumpkin> quicksilver: only if you have correct instances
07:54:09 <quicksilver> of course
07:54:09 <dolio> It's definitely not id.
07:54:13 <copumpkin> Gen, for example
07:54:16 <copumpkin> iirc
07:54:22 <quicksilver> my point is just about the intuition of it as an example
07:54:24 <Eduard_Munteanu> Strings don't work well.
07:54:27 <joe6> dolio, i understand your thoughtprocess, please continue.
07:54:29 <quicksilver> I can give plenty of examples where it isn't id :)
07:54:48 <quicksilver> but the *intuition* makes it id, which makes it misleading as an ambiguity.
07:54:51 <dolio> joe6: So, to disambiguate, you have to write something like: "show . (read :: String -> Int)"
07:55:07 <dolio> That picks Int for the ambiguous variable.
07:55:53 <dolio> joe6: You have a similar situation. You're using addBit, which returns an IO a1 where a has some instances, but then you're throwing away the results with the >> return 1.
07:56:14 <dolio> So it doesn't know what to pick, and you need to make a choice, not just write a variable.
07:56:15 <joe6> dolio, I think I understand what you said. Thanks a lot.
07:56:23 <Eduard_Munteanu> I wonder, can you see show and read as an adjunction somehow, or is it too far fetched?
07:56:53 <dolio> Eduard_Munteanu: It's probably close, at least.
07:58:02 <Eduard_Munteanu> It looks a bit like a small part in the sets-monoids one, though.
07:58:54 <quicksilver> they are normally an identity on a subset
07:58:59 <quicksilver> and _|_ on the rest
07:59:09 <quicksilver> which is a particular boring kind of adjunction, I'd say
07:59:22 <dolio> They're non-identity, non-bottom on lots of values.
07:59:23 <copumpkin> oh, quicksilver got his V back
07:59:37 <copumpkin> > read "2.000000000000000000000" :: Double
07:59:38 <lambdabot>   2.0
07:59:38 <dolio> > show . (read :: String -> Int) $ "     12345     "
07:59:42 <lambdabot>   mueval-core: Time limit exceeded
07:59:45 <dolio> > show . (read :: String -> Int) $ "     12345     "
07:59:45 <quicksilver> ok, yes
07:59:47 <lambdabot>   "12345"
07:59:52 <copumpkin> > read "000000002" :: Int
07:59:54 <lambdabot>   2
07:59:57 <quicksilver> they're a kind of canonicaliser, where defined
08:00:11 <quicksilver> that is an adjunction certainly, if you devise the right category
08:00:26 * copumpkin devises the right category
08:00:30 <quicksilver> but the category isn't Hask, since they are functions not functors
08:00:35 <int-e> > read "a" :: Int
08:00:35 <lambdabot>   *Exception: Prelude.read: no parse
08:00:37 <dolio> > read "00010"
08:00:38 <lambdabot>   *Exception: Prelude.read: no parse
08:00:43 <dolio> > read "00010" :: Int
08:00:44 <lambdabot>   10
08:00:59 <int-e> > read "()" -- I think.
08:01:00 <lambdabot>   ()
08:01:18 <copumpkin> I don't know who thought a default for Read was a good idea
08:01:24 <dolio> Yeah, lambdabot's aggressive defaulting makes show . read not even an error.
08:03:53 <joe6> dolio, but how do you know that (show . read) :: String -> Int, when writing a generic function?
08:04:14 <joe6> Shouldn't that be deduced at the time of writing an instance?
08:05:24 <joe6> if I have to write (show . read) :: String -> Int, then I am making it a very specific usage for just Int? Do I have to write instances for each such type (Int, Integer,...)?
08:06:14 <dolio> Instance of what?
08:07:18 <dfjkldfajkl> huh, show will output a string
08:07:55 <joe6> dolio, in my case, I am just defining a BitField class and I want the a to be deduced based on the instance of what byte/word/long that I am defining the bitfield for.
08:12:52 * hackagebot BiobaseTrainingData 0.1.2.2 - RNA folding training data  http://hackage.haskell.org/package/BiobaseTrainingData-0.1.2.2 (ChristianHoener)
08:16:23 <quicksilver> joe6: then you want ScopedTypeVariables indeed
08:16:30 <quicksilver> or a trick of the kind I was describing
08:16:35 <joe6> {-# LANGUAGE ScopedTypeVariables #-}
08:16:45 <joe6> quicksilver: should I just add that?
08:16:50 <joe6> or, is there more to it?
08:16:57 <quicksilver> there is more to it :)
08:17:05 <ben> scopedtypevariables besttypevariables
08:17:07 <quicksilver> joe6: can you give me the paste again?
08:17:14 <Eduard_Munteanu> Look it up in the manual.
08:17:25 <joe6> quicksilver: this is what I have http://codepad.org/btNdGGuZ, error: http://codepad.org/3yRQlcg8
08:17:38 <joe6> uri: http://www.haskell.org/haskellwiki/Scoped_type_variables
08:17:43 <joe6> i am reading up this url
08:17:47 <joe6> is that good enough?
08:18:22 <quicksilver> that's the right URL certainly
08:18:29 <quicksilver> you need to annotate addBits
08:18:31 <quicksilver> something like
08:18:51 <quicksilver> hmm
08:18:57 <quicksilver> I'm not sure what you're doing well enough to help ;)
08:19:05 <quicksilver> is 'a' the same type as 'bitField' ?
08:19:33 <quicksilver> no, it's presumably the type you're returning
08:19:44 <joe6> quicksilver: a is something from Foreign.C.Types
08:19:55 <quicksilver> you want the 'a' used in addBit
08:20:03 <quicksilver> to match the 'a' in the sig for addBits
08:20:14 <quicksilver> which is exactly what scopedtypevariables are fore
08:20:25 <quicksilver> add "forall a" to the sig for addBits
08:20:25 <joe6> quicksilver: yes, it reads the value of a(which is a C global variable)
08:20:32 <joe6> modifies it, and then writes it back again.
08:20:41 <quicksilver> and annotate 'addBit n' as 'addBit n :: Int -> Bool -> IO a'
08:20:42 <quicksilver> I believe.
08:20:52 <joe6> ok, thanks. will try that.
08:21:37 <elliott> Will fromIntegral become a nop at runtime for casting a smaller IntN type to a larger one?
08:21:48 <elliott> Specifically, Int32 to Int on a sixty-four bit system
08:22:16 <duairc> I have some code doing something like forever $ do { x <- takeMVar mvar; when (not x) doSomethingSpecial; putMVar mvar x}. In its current form it will use 100% CPU. Is there any way I can make the takeMVar block until another thread puts something in the MVar, and block if the value in the MVar was put there by itself
08:22:52 * hackagebot RNAwolf 0.3.1.0 - RNA folding with non-canonical basepairs and base-triplets.  http://hackage.haskell.org/package/RNAwolf-0.3.1.0 (ChristianHoener)
08:22:53 * hackagebot yesod-core 0.9.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.1.1 (GregWeber)
08:22:56 * hackagebot yesod 0.9.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.1.1 (GregWeber)
08:22:56 <duairc> Obviously there's no direct way of doing that, but what could I do to achieve the same effect?
08:23:18 <int-e> elliott: I think so. At least for the corresponding unboxed value; the type constructor is different and that's reflected in the boxed value.
08:23:40 <Eduard_Munteanu> duairc: maybe you want a Chan?
08:23:40 <elliott> int-e: Right, but AFAIK the runtime representation should be the same, so there's no need for an unbox/rebox.
08:23:51 <elliott> int-e: If it does unbox and rebox, then I'll switch to my own unsafeCoerce implementation :-)
08:23:52 <int-e> elliott: it isn't. they have different info pointers.
08:23:56 <elliott> Oh.
08:23:59 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
08:24:01 <elliott> Annoying
08:24:41 <kmc> duairc, it sounds more like you want two MVars
08:24:52 <kmc> i think you can accomplish what you said directly with STM
08:25:11 <kmc> but i bet you can also build it out of IO-concurrency primitives
08:25:19 <kmc> what's the larger goal here?
08:26:00 <quicksilver> int-e: really? I thought I remember being told you could unsafeCoerce from [] to Nothing
08:26:02 <joe6> would agda have the same problems with scopedTypeVariables?
08:26:10 <duairc> kmc: I basically want to "monitor" the value of an MVar, and kill a thread if the value "False" is written to that mvar.
08:26:54 <kmc> why not kill it using a Chan instead?
08:27:15 <copumpkin> or Mu Chan
08:27:23 <copumpkin> :k Mu Chan
08:27:24 <lambdabot> Not in scope: type constructor or class `Chan'
08:27:37 * Eduard_Munteanu has seen this before but doesn't know if it's serious :)
08:27:39 <copumpkin> sounds like something kmc would like
08:27:45 <copumpkin> ;)
08:27:54 <int-e> quicksilver: You probably can and most things will work ... but 'vacuum' will distinguish between [] and Nothing.
08:28:02 <quicksilver> int-e: *nod*
08:28:12 <kmc> seen which Eduard_Munteanu?
08:28:25 <Eduard_Munteanu> joe6: note in Agda you can bring types "variables" into scope since they're just (implicit) parameters.
08:28:27 <duairc> kmc: I'm not how a Chan would help here.
08:28:36 <quicksilver> int-e: testing in ghci it works for [] <-> Nothing, and also for (17::Int32) <-> (17::Int)
08:28:44 <kmc> duairc, well, does the MVar have other meaning already?
08:28:47 <joe6> Eduard_Munteanu: yes.
08:28:59 <dolio> You can do it. But it isn't recommended.
08:29:04 <kmc> if you just want a thread to wait on some "die" message, then have it wait on a Chan
08:29:04 <quicksilver> int-e: what is the info pointer used for? in what circumstances would it matter if it was wrong?
08:29:17 <kmc> duairc, can you step back one more level and tell us what you're really trying to do?
08:29:27 <Eduard_Munteanu> joe6: but Agda is already a bit quirky wrt to local definitions
08:29:56 <joe6> when I moved the valueOf to the where clause, I do not get any errors.
08:30:14 <joe6> like this: http://codepad.org/lAQvm7M1
08:30:17 <Eduard_Munteanu> Erm, maybe I misremember.
08:30:20 <copumpkin> joe6: no it wouldn't
08:31:17 <dainanaki> Is it possible with c2hs to calculate the size of a member of a struct?
08:31:36 <dainanaki> (not the struct itself)
08:31:52 <RenJuan> on the c side it is
08:32:10 <RenJuan> (if it's a c struct)
08:33:01 <RenJuan> who is the "I" of section 7.4.3 of the ghc user's guide?
08:33:26 <Eduard_Munteanu> I, LAMBDABOT :P
08:33:48 <dainanaki> ok, then can c2hs tell what the size of a pointer is on a given platform?
08:33:50 <copumpkin> RenJuan: run a blame on the repo?
08:34:44 <Eduard_Munteanu> Though git-blame could mix things up if somebody shuffled the content around.
08:34:53 <quicksilver> RenJuan: almost certainly SPJ, he's the most likely to write in the first person.
08:34:57 <Eduard_Munteanu> (in the sense you don't get the real author0
08:35:12 <RenJuan> copumpkin, OK, just was wondering if it was implicitly SPJ or what
08:35:35 <harlekin> @pl (\a -> (f a) || (g a))
08:35:36 <lambdabot> liftM2 (||) f g
08:35:55 <yitz> duairc: just saw your original question. you are using the same MVar to send a message in both directions. do you really want a race condition for who picks up the message?
08:36:01 <RenJuan> those were my two options, crunk/blame or SPJ
08:36:33 <Eduard_Munteanu> Crunk?
08:36:41 <RenJuan> (obviously not distinct)
08:36:55 <yitz> duairc: if not - then, not to take away from the Chan idea, you can do it with two MVars, one for each direction.
08:37:18 <kmc> i think we should find out what problem duairc wants to solve
08:37:20 <yitz> duairc: (except watch out for starvation etc.)
08:37:23 <RenJuan> Crunk. Crunk Ass. Crunk von Mugglestein.
08:39:54 <joe6> i want a class to wrap the peek and poke of a C global Variable? better yet, have a value, which when I set with a "value = 0", updates the C global variable and the local variable with 0.
08:40:04 <joe6> is that a good idea?
08:40:24 <quicksilver> haskell doesn't have variables which you set like "value = 0"
08:40:41 <quicksilver> "value = 0" names a value it doesn't set a variable.
08:41:05 <quicksilver> you could have a get/set interface to a C global in IO which is what the OpenGL binding does, effectively.
08:41:13 <quicksilver> someOpenGLVar $= 0
08:41:21 <joe6> quicksilver, make sense. should i instead use Data.Binary get and put values from the
08:41:40 <joe6> quicksilver, the openGL seems like a good idea. will check it out.
08:42:15 <RenJuan> *approach
08:43:35 <hpc> there's also IORef, if you don't want to suck OpenGL into your program
08:43:45 <quicksilver> you can't bind IORef to a C global.
08:44:08 <quicksilver> and I wasn't suggesting OpenGL actually needs to be in the program, just using it as an example for an FFI API to global variables.
08:44:35 <quicksilver> although you certainly could use the StateVar typeclass which got split out of OpenGL
08:44:39 <quicksilver> http://hackage.haskell.org/package/StateVar-1.0.0.0
08:44:46 <quicksilver> (which defines the $= symbol and a few others)
08:45:07 <joe6> thanks, am reading up on the opengl bindings.
08:45:08 <adimit> If I want to print a constantly updating status to stdout, w/o creating a new line for each update, is using the putStr "\rMESSAGE" paradigm my only method?
08:45:14 <joe6> will readup on stateVar.
08:45:18 <shlevy> What's the difference between using a type class and defining instances vs replacing each class function with a type and writing conversion functions in the place of instances?
08:45:25 <duairc> kmc: I have a thread X which is itself forking threads. Eventually, a point will be reached after which I want X to stop forking threads. This point can only be determined by one of X's subthreads though.
08:45:29 <duairc> kmc: So there is an MVar to which a subthread of X writes False when it decides it wants X to stop forking. There may also be a point where a subthread of X is unsure whether or not it should tell X to stop forking, but provisionally it pauses X's forking by taking from the MVar.
08:45:34 <duairc> kmc: If it decides that X is okay to keep forking, it will write True back to the MVar.
08:46:18 <quicksilver> adimit: fundamentally, yes, although you can consider using a library which gives you access to termcap features like cursor positioning.
08:46:51 <adimit> quicksilver: termcap, I see. Thanks, I'll look into it. The \r method unfortunately generates sooo much cursor flickering.
08:46:54 <quicksilver> shlevy: that the type-inference engine can choose the right instance automatically (for typeclasses?)
08:47:20 <quicksilver> adimit: well don't update too often then :) although certainly a good terminal library will have a way to hide the cursor.
08:47:20 <adimit> I mean, it *looks* Matrix-ey, but it isn't exactly easy to read.
08:47:48 <kmc> duairc, interesting
08:48:03 <adimit> quicksilver: yeah, I only updated often in my test case, my actual use case will see much less updates. Still, it's annoying. I'll see if there's anything on Hackage.
08:48:06 <edwardk> adimit: you can use the terminfo package pretty easily. there are also ncurses bindings for haskell
08:48:08 <quicksilver> adimit: examples : http://hackage.haskell.org/package/hscurses-1.4.0.0 http://hackage.haskell.org/package/vty
08:48:58 <yitz> duairc: better to send an explicit "pause" message than to simulate that by using the same MVar with two different semantics, no?
08:49:24 <kmc> yeah, one solution is a channel that carries messages Pause | Continue | Die
08:49:37 <edwardk> what you are looking for is the terminfo call for "tput civis" to hide the cursor, whatever that translates to under the haskell binding
08:49:42 <edwardk> them tput cnorm to go back
08:49:57 <kmc> duairc, i'm confused, though, why your original MVar solution isn't adequate.  if thread X has other work to do, it's not actually a problem that it keeps checking this var, is it?
08:50:20 <kmc> duairc, put another way:  what's the point of blocking-waiting on a "die" message, then dying, rather  than just dying immediately
08:50:45 <adimit> edwardk: nice, thank you!
08:51:14 <adimit> I don't want to go the full ncurses route, That would be overkill, since I really just want a status line.
08:51:28 <adimit> (the process can take days to finish, so I would at least like to know if it's doing anything :-P)
08:51:35 <erus`> > "I now have " ++ show (1440*900 + 1920*1080) ++ " pixels screen space :D"
08:51:36 <lambdabot>   "I now have 3369600 pixels screen space :D"
08:51:36 <shlevy> quicksilver: Ah, ok. And you don't have to manually call the conversion function every time :)
08:51:59 <erus`> > sqrt3369600
08:52:00 <lambdabot>   Not in scope: `sqrt3369600'
08:52:01 <erus`> > sqrt 3369600
08:52:02 <lambdabot>   1835.6470248934024
08:52:10 <duairc> kmc: To be honest I can't remember why it wasn't adequate. This code is quite hairy in places and I'm struggling to get my head around it. I'll come back to it with your and yitz's suggestions in mind and see if I can remember what was wrong (or else realise that nothing was wrong and that I was just being very silly).
08:52:17 <kmc> cool :)
08:52:25 <joe6> quicksilver: the stateVar is exactly what I need. good suggestion, Thanks.
08:52:37 <edwardk> tiGetOutput1 "civis" using http://hackage.haskell.org/packages/archive/terminfo/0.3.2.2/doc/html/System-Console-Terminfo-Base.html#v:tiGetOutput1
08:52:42 <shlevy> How do I tell cabal that my application depends on a non-Haskell package?
08:52:46 <edwardk> should do it
08:53:05 <dcoutts> shlevy: C lib? or some executable used at runtime?
08:53:19 <shlevy> dcoutts: In this case executable used at runtime, but both
08:53:20 <edwardk> and you can just setupTerm to get the terminal type and run the capability in IO
08:54:01 <dcoutts> shlevy: there's no way to specify that unfotunately
08:54:07 <dcoutts> shlevy: only build tools
08:54:18 <shlevy> dcoutts: Darn :(
08:54:41 <edwardk> looks like vty has a binding to civis/cnorm as well
08:55:47 <adimit> edwardk: shiny, that should help me, thanks :-)
08:59:07 <byorgey> orbits :: Integral a => (a -> a) -> a -> [[a]]  -- cycles f n  returns a list of all the orbits of f in Z_n.  For example, orbits (+2) 5 == [[0,2,4,1,3]], orbits (+2) 6 == [[0,2,4], [1,3,5]]
08:59:15 <byorgey> who can write the shortest implementation? ready, go!
09:00:01 <byorgey> oops, that should say 'orbits f n' not 'cycles f n' of course
09:01:11 <Tomsik> It's not place for your homework! :p
09:01:14 <byorgey> to clarify: the order of the output list does not matter.  the order of each orbit matters, but only up to rotation
09:01:19 <byorgey> this isn't homework =)
09:01:22 <byorgey> just fun
09:01:25 <Tomsik> I'm kidding
09:01:31 <byorgey> hehe
09:02:10 <edwardk> well, to be fair, this is the sort of work that byorgey does at home
09:02:52 <byorgey> true, I am currently sitting at home, working on diagrams
09:03:10 <byorgey> this is going to go into the code for generating star polygons
09:03:17 <byorgey> I have an implementation but it's long and ugly.
09:03:34 <yitz> byorgey: if functions had a Show instance, it would be: orbits f n = text $ concat ["@ask byorgey what are the orbits of '", show f, "' in Z_", show n, "?"]
09:03:43 <byorgey> hahaha
09:03:58 <Tomsik> Well, I can't think of a nice implementation other than using an ST array for storing which numbers were not hit yet
09:05:31 <byorgey> good idea
09:06:47 <dainanaki> I'm having trouble in c2hs getting a Ptr Foo as the return value of a function. It says there's no 'in' marshaller for the result, even though I'm wanting it to be the output. What am I doing wrong?
09:07:18 <dainanaki> Here's the line that's giving me trouble: {#fun unsafe git_repository_database as database {id `RepositoryPtr'} -> id `ObjectDBPtr' #}
09:08:31 <roconnor> byorgey: "orbits" are not always circular
09:08:36 <roconnor> byorgey: they are hairy balls
09:09:02 <roconnor> byorgey: or are you asking for only the ball parts of the "orbits"
09:10:30 <byorgey> oh, right
09:10:44 <byorgey> roconnor wins by a technicality!
09:10:52 <roconnor> w00t
09:11:09 <byorgey> I guess I intended for the function f to be a permutation on Z_n.  But there's no way to enforce that.
09:11:30 <roconnor> byorgey:  there are ways ... not very nice ways
09:11:50 <roconnor> I guess you'd have to make it not a function
09:12:06 <byorgey> yeah, and it's not really worth doing that
09:12:20 <hpaste> Accidus pasted “Overlapping Patterns” at http://hpaste.org/50852
09:12:25 <Accidus> I've defined f = 1, but when I pattern match on an integer symbol, GHC complains about overlapping pattern matches. See pastebin for the actual code.
09:13:04 <byorgey> OK, well, let's see if we can compute *only* the cyclic pieces of the orbits
09:13:18 <adimit> how can I make *sure* a function will execute, even if the user hits an interrupt? (in my case, I want to re-show the cursor even if the program dies half-way through.)
09:13:35 <elliott> adimit: you can't. they could pull the plug
09:13:55 <byorgey> Accidus: you can't pattern match on defined things like that
09:14:04 <adimit> elliott: ok, *reasonably* sure. Like, if you catch an interrupt, then at least run this before you croak.
09:14:17 <byorgey> Accidus: the pattern  f ->  just matches anything and gives it the name f (shadowing the previous definition of f)
09:14:17 <monochrom> at most you could catch and ignore the user interrupt. look for UserInterrupt in Control.Exception
09:14:23 <roconnor> byorgey: do I get to use my star-semiring code?
09:14:24 <Tomsik> If it's a permutation and you are sure then implementation can just ommit that
09:14:26 <Accidus> Of course. Silly me.
09:14:32 <adimit> I don't want to ignore the user interrupt.
09:14:35 <Accidus> But I do want to define 'constants'
09:14:39 <adimit> :-\
09:14:53 <Tomsik> i.e. just look for a cycle, not do what basically would be an union-find
09:15:00 <monochrom> still, look for nterrupt in Control.Exception
09:15:02 <Accidus> Or rather, what happens if I want to define constants (I probably can find a different solution)
09:15:04 <byorgey> Accidus: you can say  case symbol of x | x == f  ->  ...
09:15:23 <Accidus> Ah, that's true. More kludgy than I hoped for.
09:15:28 <byorgey> roconnor: well, do *I* get to use it? =)
09:15:32 <Accidus> Cheers
09:15:49 <roconnor> byorgey: sure it is on my blog.
09:16:05 <byorgey> Tomsik: well, the function may be coming from an (untrusted) user so I'd rather do something sensible in that case
09:16:26 <byorgey> roconnor: ok, sure =)
09:16:58 <yitz> byorgey: watch out, you have just agreed to let roconnor use regular expressions
09:17:05 <siracusa> Is GHC using haskeline?
09:17:14 <yitz> byorgey: and finite state machines
09:17:25 <dainanaki> So nobody knows how to return a ptr using c2hs?
09:17:40 <dainanaki> I'm surprised something so simple is not built in somehow.
09:19:06 <byorgey> yitz: hehe, I haven't agreed to paste whatever he comes up with straightaway into diagrams, I am just curious to see how he would do it =)
09:19:13 <Tomsik> then my implementation is cabal install union-find, I guess
09:19:47 <dcoutts> siracusa: I think so
09:20:06 <byorgey> Tomsik: union-find is not quite enough, because I care about the order of the elements, not just the equivalence classes
09:20:22 <siracusa> I'm asking because haskeline autocompletes path names under Windows to foo\\bar\\baz, while in GHC it's the correct foo\bar\baz
09:20:25 <Tomsik> Well, what order would you set on the 'hairs'?
09:21:00 <dcoutts> dainanaki: that should be trivial, what's the problem?
09:21:24 <byorgey> Tomsik: Essentially, I want some sort of representation of the graph of f.
09:21:37 <yitz> siracusa: ghc uses haskeline for ghci
09:21:52 <dainanaki> dcoutts: Here's the line that's causing trouble: {#fun unsafe git_repository_database as database {id `RepositoryPtr'} -> `ObjectDBPtr' #}
09:22:09 <siracusa> yitz: Yeah, I meant GHCi not GHC
09:22:15 <Tomsik> basically then you want to get the graph of category where objects are 0..(n-1) and morphisms are defined by the function!
09:22:36 <byorgey> Tomsik: yes, exactly.  But I want it broken up into pieces which have no branching.
09:22:39 <dainanaki> dcoutts: It says there's no default marshaller for ObjectDBPtr
09:22:48 <byorgey> so that I can draw it using a collection of paths/cycles.
09:22:50 <dcoutts> dainanaki: then specify one, it's probably just 'id'
09:23:05 <dainanaki> dcoutts: I tried that.
09:23:05 <adimit> monochrom: bracket from Control.Exception did it. thanks.
09:23:13 <yitz> siracusa: so if ghci does the right thing, it means they have coaxed haskeline into doing the right thing. or just hacked its output :)
09:23:21 <Tomsik> What do you mean by "no branching"?
09:23:31 <dcoutts> dainanaki: and?
09:23:36 <Tomsik> As in take the cycle only or?
09:23:39 <roconnor> > let orbits f n = let {foo i = let (h:t) = reverse (take n (iterate ((`mod` n) . f) i)) in reverse (h:takeWhile (/=h) t); bar l = let k = length l in sort (take k (map (take k) (tails (cycle l))))} in map head (nub (map (bar . foo) [0..(n-1)])) in map (orbits (+2)) [5,6]
09:23:41 <lambdabot>   [[[0,2,4,1,3]],[[0,2,4],[1,3,5]]]
09:23:47 <byorgey> Tomsik: I just mean if I have  1 -> 2 <- 3  then I want it in two pieces,  1 -> 2  and 3 -> 2
09:23:54 <Tomsik> ah
09:23:57 <dainanaki> dcoutts: It says there malformed result marshalling: there may not be an in marshaller for the result.
09:24:03 <siracusa> yitz: So you're proposing to look at the GHCi code?
09:24:14 <roconnor> byorgey: this code only works for permutations
09:24:32 <yitz> siracusa: heheh you could do that.
09:24:42 <byorgey> roconnor: nice =)
09:24:48 <dcoutts> dainanaki: can you post the code
09:24:57 <byorgey> roconnor: what does it do on non-permutations?
09:25:06 <roconnor> oh wait
09:25:06 <yitz> siracusa: are you sure haskeline is getting it wrong? the string "foo\bar" looks like "foo\\bar" when you show it
09:25:15 <roconnor> it might work on non-permutations too
09:25:19 <roconnor> actually I think it will
09:25:22 <roconnor> yay
09:25:53 <roconnor> > let orbits f n = let {foo i = let (h:t) = reverse (take n (iterate ((`mod` n) . f) i)) in reverse (h:takeWhile (/=h) t); bar l = let k = length l in sort (take k (map (take k) (tails (cycle l))))} in map head (nub (map (bar . foo) [0..(n-1)])) in orbits (^2) 5
09:25:55 <lambdabot>   [[0],[1]]
09:26:04 <roconnor> hmm
09:26:24 <roconnor> I guess that could be right
09:26:32 <yitz> > show $ "foo" ++ toEnum 92 : "bar"
09:26:33 <lambdabot>   "\"foo\\\\bar\""
09:26:34 <siracusa> yitz: I think so, I'm just running "runInputT defaultSettings" for which the docs say the default completion is for path names.
09:26:37 <byorgey> yes, it is
09:26:47 <Tomsik> byorgey: can't you get expotential number of results then?
09:26:50 <byorgey> 2 -> 4 -> 1  and 3 -> 4
09:27:00 <yitz> > "foo" ++ toEnum 92 : "bar"
09:27:02 <lambdabot>   "foo\\bar"
09:27:13 <byorgey> Tomsik: what do you mean?
09:27:33 <Tomsik> imagine a binary tree with arrows directed towards the root
09:27:43 <hpaste> dainanaki pasted “c2hs woes” at http://hpaste.org/50853
09:27:54 <dainanaki> dcoutts: there's the relevant bits.
09:28:13 <byorgey> Tomsik: no, I'm imagining each edge only showing up once in the output
09:28:32 <Tomsik> but what about a cycle with many hairs then?
09:28:41 <dcoutts> dainanaki: out marshalers go after the type name
09:28:55 <dcoutts> dainanaki: that is:   -> `ObjectDBPtr' id #}
09:29:11 <dainanaki> gah, I feel dumb now.
09:29:16 <dainanaki> thanks, dcoutts.
09:29:20 <byorgey> Tomsik: what about it? you generate a cycle, and a bunch of hairs
09:29:36 <dcoutts> dainanaki: that error message I guess says that, but I didn't realise it either just by reading it
09:29:53 <roconnor> Tomsik: the number of hairs must be less than n
09:30:46 <dcoutts> :q
09:30:50 <dcoutts> oops :-)
09:31:07 <Tomsik> Okay
09:31:42 <byorgey> since there is exactly one edge going out of every node
09:32:43 <byorgey> thanks for taking up my challenge and clarifying my thinking in the process, I'd better go get some lunch now =)
09:36:42 <luite> what you're doing is exactly a disjoint union, right?
09:37:16 <luite> apply the function to each element, take union of sets before and after
09:37:46 <byorgey> luite: I don't understand
09:39:50 <luite> byorgey: maybe I've read it wrong. but say you have [1,2,3,4], where you initially have 4 sets with 1 element, {{1},{2},{3},{4}}, now if f 1 == 3, you can unify the sets with 1 and 3
09:40:59 <byorgey> luite: I care about the order though, not just equivalence classes
09:41:08 <byorgey> I care about the difference between f 1 == 3  and f 3 == 1
09:41:35 <luite> oh right, then this may end up being worse, I'll think about it :)
09:41:59 <heatsink> I want to make a few hundred global variables that are initialized by reading from a file.  My program is an interpreter and the variables are the interpreter's built-in functions.
09:42:20 <heatsink> I've been using a global MVar containing a data structure with a few hundred fields.
09:42:32 <heatsink> However, GHC is very slow when compiling data structures with a few hundred fields.
09:42:35 * byorgey boggles
09:42:53 <heatsink> Is there another way I can try?
09:43:54 <rostayob> a data type with "a few hundred fields"?
09:44:16 <heatsink> yes.  I have some TH code to take a list of strings, and make a data declaration.
09:44:25 <kmc> that seems odd, i'd expect an interpreter's default environment to be like Map Identifier Value
09:44:27 <rostayob> heatsink: you are probably doing something wrong
09:44:37 <rostayob> yeah, what kmc said
09:45:01 <rostayob> also, TH is at compile time, where do you get the list of string from?
09:45:02 <heatsink> kmc, yes, I have a map from name to value.  However, there are also hardcoded references to variables.
09:45:49 <heatsink> For example, when checking if some interpreter data is an int, I want to be able to get the data structure for "int" from a global variable instead of a map lookup.
09:46:04 <heatsink> (Functions and types are in the same namespace.)
09:46:21 <rostayob> heatsink: why?
09:46:22 <heatsink> rostayob, it's in a hs file
09:46:29 <elliott> Does anyone know of a good solution to the problem encountered when having a single Foo.Types module (to avoid rampant circular dependencies) -- in that you cannot hide any constructors outside of the module that actually implements the API on the types, for obvious reasons?
09:46:37 <rostayob> why do you want it to be in a global variable?
09:46:49 <rostayob> that seems a really convoluted way of doing a simple thing
09:47:01 <rostayob> and it's also abusing the notion of data type :P
09:48:07 <Tomsik> What you want is an Array of some datatype I guess
09:49:11 <heatsink> Hmm, I could use an array
09:49:32 <heatsink> Then use TH to define global constants the_int = 1; the_float = 2; ...
09:49:41 <heatsink> representing positions in the array
09:49:49 <rostayob> heatsink: but... why?
09:50:00 <heatsink> rostayob, what's the alternative?
09:50:05 <rostayob> how do you use those global variables anyway? you don't have them until you compile
09:50:12 <rostayob> a Map with the default values?
09:52:13 <heatsink> rostayob, the code that the interpreter reads in uses the Map.
09:52:34 <heatsink> There is also code in the interpreter itself that dispatches based on types or function names.
09:52:53 * hackagebot sundown 0.2 - Binding to upskirt  http://hackage.haskell.org/package/sundown-0.2 (FrancescoMazzoli)
09:52:55 <heatsink> (Some hard-coded rewrite rules dispatch based on function name, for example)
09:54:10 <rostayob> heatsink: I don't get what you are trying to do, sorry. But how you are doing it is wrong :P
09:54:14 <heatsink> For dispatching based on type, it makes sense to have a global variable referring to the type instead of a String (or other identifier).
09:54:25 <heatsink> It's easy for Strings to fall out of sync when the set of built-ins is changed.
09:54:36 <rostayob> I mean generating a data type with hundreds of members with TH is just wrong
09:55:03 <heatsink> I can achieve the same tying with an array, as Tomsik described
09:55:04 <rostayob> for Strings to fall out of sync? I don't follow you
09:56:14 <rostayob> you are generating this variables from a string list anyway
09:56:32 <heatsink> Right
09:56:35 <zhulikas> <stdout>: commitBuffer: invalid argument (character is not in the code page)
09:56:42 <zhulikas> how this can be fixed?
09:56:49 <zygoloid> elliott: have a Foo.Types.Internal module, and don't export it from your cabal package. have a separate Foo.<whatever> module which imports that and only exports the bits you want exported.
09:57:06 <elliott> zygoloid: It's not about cabal-external exports; it's about internal encapsulation.
09:57:07 <heatsink> Sounds like a locale or encoding issue, zhulikas.  What program produced that?
09:57:08 <zhulikas> I guess problem is with encoding
09:57:22 <zhulikas> heatsink, I am following this tutorial: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
09:57:35 <zhulikas> and my IRC network uses non-latin letters
09:57:43 <zhulikas> how can I set encoding?
09:58:40 <heatsink> rostayob, for symbols that the interpreter recognizes, there is a name hard-coded in the program, and a name in the Map of built-in names.  If a name is changed or added in one place, it should be changed in the other also.
09:58:41 <zygoloid> elliott: suppose you have types A and B. internally, have a Foo.Types.Internal.A which imports Foo.Types.Internal and exports only A(..). then make sure you only import Foo.Types.Internal in those modules.
09:58:48 <elliott> zygoloid: ah
09:59:01 <zygoloid> likewise for B. now import Foo.Types.Internal.A into Foo.Types.A, and ...
09:59:02 <heatsink> rostayob, that's the purpose of the current TH setup.
09:59:09 <elliott> zygoloid: yeah, that could work... wouldcause quite a proliferation of modules though
09:59:17 <zhulikas> I believe it's hSetEncoding
09:59:27 <zygoloid> yeah. i don't know a better way which provides the guarantees you want, though. :(
09:59:37 <zygoloid> possibly break the cycle with .hs-boot instead? :(
09:59:49 <elliott> Unfortunately my cycles are too complex for hs-boots (cyclic types)
10:00:02 <elliott> zygoloid: I was thinking I could use every type only in terms of a typeclass :-P
10:00:07 <heatsink> You can sometimes fix that by making one of the types in the cycle parametric
10:00:08 <elliott> I'll probably just try and avoid the constructors, though
10:00:16 <zygoloid> do you still need to list all constructors in .hs-boot? that's lame
10:00:55 <zygoloid> though the number of .hs-boot files you'll need will be similar to the number of extra modules you'd need the other way :)
10:01:23 <rostayob> heatsink: yes but I don't get why you need the symbols as global variables.
10:02:49 <heatsink> rostayob, because some parts of the interpreter dispatch based on symbols.
10:03:09 <heatsink> if x == builtinName the_int then foo else if x == builtinName the_float then bar else baz
10:03:46 <zhulikas> can anyone help me on this one? hSetEncoding h utf8 doesn't solve it
10:04:14 <heatsink> Sorry, I don't know how to work with character encodings
10:06:45 <rostayob> heatsink: can't you define the built ins manually? if x == builtInInt then foo else if x == builtInFloat ... why do you need to put them in a data structure?
10:07:00 <rostayob> heatsink: and also, you won't be able to reference that data structure if you are generating it with TH
10:07:20 <zachk> fclabels perhaps...
10:12:29 <heatsink> rostayob, I could define them manually.  I'm trying to go with the most error-proof solution.
10:12:37 <heatsink> This way, for example, I can't accidentally type builtinInt = lookupName "float"
10:13:24 <heatsink> I can reference the data structure.  It just has to be generated in a different module because of TH's stage restriction.
10:15:25 <rostayob> heatsink: no I'm saying to remove the list of strings in the first place
10:15:38 <rostayob> and just having global variables for the identifiers
10:16:26 <rostayob> if you really have to use TH, I'd create different variables anyway instead of a big ass data type
10:16:54 <rostayob> but imho the best way is the simple way, simply having a lot of :: String that you define
10:17:16 <heatsink> There's a global Map from name to value.  To make that map, I have to put all those strings somewhere.
10:18:03 <luite> is there something like "cabal-dev runghc", similar to "cabal-dev ghci", but non-interactive, something that just runs the main function?
10:18:28 <rostayob> heatsink: ok I see your situation now, you need both the Map and the global variables
10:18:32 <heatsink> yes
10:18:45 <rostayob> well you don't but you want the global variables just to avoid typing the string manually, right?
10:18:55 <heatsink> right.
10:19:09 <heatsink> If I misspell a global variable, that's checked at compile time :)
10:19:27 <heatsink> Unless I'm writing Python :)
10:19:34 <rostayob> what I'd do is a data type to represent all the identifiers, like data Identifier = Float | Int | Blah | Foo, and then a function Identifier -> String
10:19:43 <kmc> pyflakes will catch that :)
10:19:44 <rostayob> and if anything, generate that with TH
10:20:12 <rostayob> so you can do lookup (toString Float) builtins
10:20:36 <rostayob> even better
10:20:38 <rostayob> you can derive enum
10:20:48 <rostayob> and put it in an array, or whatever
10:21:20 <rostayob> but honestly, I'd do things manually. do you really have hundreds of identifiers?
10:21:42 <heatsink> Well, I'd like to stick with my current data type for identifiers.  They're a product type with ID, name, and some occasionally useful fields.
10:22:32 <rostayob> heatsink: I'd avoid doing what you're doing anyway. If you really want type safety, I'd find a way to get the string names for identifiers in a type safe way (see above)
10:22:45 <rostayob> well it's not exactly type safety, but safety :P
10:22:56 <parcs> luite: echo main | cabal-dev ghci ?
10:22:58 <Saizan> typo safety
10:23:04 <rostayob> Saizan: brilliant
10:23:14 <heatsink> There are hundreds of built-in symbols.
10:23:26 <rostayob> heatsink: then generate the indexer with TH
10:23:52 <rostayob> anyway I'm really tired and I might be saying really stupid things! so it's better if you wait for someone else :P
10:24:01 <Saizan> are we sure that GHC deals with large sums better than large products?
10:24:01 <heatsink> I could probably change the design to avoid some of the hard-coded lookup tables I have, but I think that's too mcuh work atm.
10:24:59 <luite> parcs: yeah actually that doesn't work in this situation, I want to run a separate .hs file that is not in the .cabal, but it should use the package config from cabal-dev
10:25:00 <heatsink> What do you mean by the "indexer"?
10:25:17 <rostayob> heatsink: a data type that gets you the string name of an identifier
10:25:38 <heatsink> ok
10:26:24 <rostayob> so if you have identifiers "float" "foo" "bar" youd have data Identifier = Float | Foo | Bar and a function Identifier -> String, and you can lookup on the map with that data type
10:26:25 <heatsink> Yeah, I see what you mean now
10:27:11 <rostayob> heatsink: cool :)
10:27:21 <heatsink> I can go with that.  I better test GHC's handling of large enum types first.
10:27:40 <rostayob> heatsink: it's pretty good, they're basically numbers iirc
10:28:24 <heatsink> OK then
10:28:30 <heatsink> Thanks rostayob
10:28:38 <rostayob> heatsink: check I'm not 100% sure
10:28:42 <rostayob> np
10:29:26 <rostayob> going home now!
10:30:40 <Rc43> Hi, guys.
10:30:52 <Rc43> Question is irrelevant, but may be you will help.
10:30:54 <byorgey> 1hi Rc43
10:31:01 <Rc43> http://en.wikipedia.org/wiki/Exponential_hierarchy
10:31:13 <Rc43> Why there is 22^n^k, but not 2^k?
10:31:17 <Rc43> *2^n^k
10:31:33 <Rc43> *2^n
10:31:48 <johnfn> noob haskell question. i want to map a list of file names to their contents. but the only way to get contents is via readFile and <-, and i can't figure out how to map <- over a list. any tips?
10:32:09 <heatsink> johnfn, mapM
10:32:18 <byorgey> Rc43: 2^n is just 2^n^k for k == 1
10:32:22 <monochrom> 2^n is a special case of 2^(n^1) is a special case of 2^(n^k)
10:32:34 <int-e> Rc43: 2^k is constant in that context.
10:32:46 <monochrom> 2^k is a typo
10:32:49 <Botje> johnfn: <- is just syntax
10:32:52 <heatsink> If you make a function (FilePath -> IO Contents), then you can use 'mapM' with that function to process a list.
10:32:53 <Rc43> int-e, it was mistake
10:33:22 <Rc43> byorgey, monochrom, i mean why we need union of all for k <- N, but not just 2^n?
10:33:37 <monochrom> what is meant by "map <- over a list"? please give your concrete real task
10:34:14 <byorgey> Rc43: because the difference between 2^n and 2^n^k for any constant k is not considered significant
10:34:21 <johnfn> monochrom: er, the first part of my sentence was the real task (map file names to their contents)
10:34:59 <monochrom> y <- mapM readFile ["/dev/null", "nul:", "/dev/zero"]
10:35:05 <Rc43> byorgey, why U 2^n^k but not just 2^n?
10:35:19 <monochrom> then y will be a list of strings. 1st string is content of /dev/null, etc
10:35:38 <Rc43> byorgrey, i know it is larger, but why 2^n is bad definition?
10:35:55 <johnfn> great, thanks
10:36:00 <byorgey> Rc43: You mean why don't we have something like  EXPTIME0 = DTIME(2^n), EXPTIME1 = U DTIME(2^n^k), etc?
10:36:10 <Rc43> byorgey, yes
10:36:57 <Rc43> DTIME(2^n) becomes something more simple like np (just suppose)
10:36:59 <byorgey> Rc43: because then the difference between EXPTIME0 and EXPTIME1 is much smaller than the difference between EXPTIME(j) and EXPTIME(j+1) for any other j
10:36:59 <Rc43> &
10:37:00 <Rc43> ?
10:37:47 <byorgey> Rc43: basically, if 2^n were tractable, then so would be  2^n^k for finite k
10:37:54 <monochrom> DTIME(2^n) is uninteresting. too narrow. no one would care enough
10:38:42 <byorgey> right, so we might as well just study U DTIME(2^n^k)
10:39:26 <monochrom> all questions of "why choose this definition" have that answer
10:39:39 <Rc43> Can you give example of EXPTIME<?>. I know number of all boolean n-arg functions is 2^2^n, but something more?
10:40:19 <monochrom> unification is exptime iirc
10:40:33 <zygoloid> addition is in EXPTIME :)
10:41:05 <Rc43> zygoloid, lolwut?
10:41:58 <zygoloid> Rc43: P is a subclass of EXPTIME
10:43:10 <Rc43> zygoloid, ha, ok. And we know that elementary functions are in union of exptime, and (+) is elementary, so we can suppose that (+) in exptime.
10:43:11 <Rc43> Lol, right?
10:43:20 <Rc43> I mean, I am right?
10:44:08 <luite> maybe you mean EXPTIME-complete?
10:45:02 <zygoloid> Rc43: yeah, pretty much. (+) itself isn't a decision problem, so can't be in EXPTIME itself, but sorta-equivalent decision problems are in EXPTIME.
10:45:18 <Tomsik> DTIME(2^n) is strictly less than DTIME(3^n)
10:45:52 <Tomsik> EXPTIME = sum DTIME(c^n) ranging over c from 1 to +infty
10:47:13 <Rc43> zygoloid, i didn't understand it complettely, but it begins to clear up.
10:47:15 <jpcooper> hello
10:47:16 <Rc43> thanks, guys
10:48:27 <jpcooper> I am creating an empty MVar in ghci with var <- newEmptyMVar. I am then passing this var to a function which takes ByteString MVars. When I do this I am getting a type conflict because the var is of type MVar Any. Is there any way to get around this?
10:48:53 <c_wraith> jpcooper: assign it a type signature
10:49:09 <c_wraith> jpcooper: var <- newEmptyMVar :: IO (MVar ByteString)
10:49:29 <c_wraith> jpcooper: that will prevent ghci's defaulting rules from turning it into Any
10:50:10 <Rc43> Also, I am right in that MT is "prepared" thing for single purpose and universal MT is a "2-arg function" which becomes usual MT after partial applying with MT code?
10:50:23 <jpcooper> thanks c_wraith
10:50:30 <monochrom> yes
10:50:37 <zygoloid> Rc43: is MT some corruption of Turing Machine here?
10:51:01 <Rc43> zygoloid, yes
10:51:02 <monochrom> MT is not corruption. TM is.
10:51:14 <monochrom> TM is corruption of Machina Turingus
10:51:32 <monochrom> err maybe Machinus Turinga
10:51:35 <Rc43> ok, i haven't know
10:52:04 <zygoloid> monochrom: why would a device named after an Englishman have a name like that?
10:52:24 <monochrom> dunno. it even has russian names and chinese names. go figure
10:52:51 <zygoloid> (in what sense is that the official name?)
10:53:01 <monochrom> no official name
10:53:23 <edwardk> preflex: xseen dylukes
10:53:23 <preflex>  dylukes was last seen on freenode/#haskell 17 hours, 10 minutes and 20 seconds ago, saying: derp
10:53:44 <zygoloid> monochrom: then in what sense is TM the corruption and MT not?
10:54:11 <monochrom> in the sense that Rc43's IP looks russian not english
10:54:17 <zygoloid> (genuinely curious here; i've never heard of this before)
10:56:03 <dainanaki> I'm doing a little bit of API design right now, and I'm debating the merits of using String vs Text as the string type of choice. Arguments for/against each?
10:56:32 <adimit> is there a library function somewhere that'd let me convert seconds (in Int) to d/h/m/s?
10:56:42 <adimit> I'm too lazy to write that myself right now ^^
10:56:55 <zygoloid> monochrom: i prefer Rc43's answer to my question :)
10:57:22 <monochrom> I just hate english-centricity
10:59:09 <Rc43> monochrom, if you are still interested in russian TM is Machina (Mashina?) Turinga. (I think `sh` is correct sound.)
10:59:30 <Rc43> zygoloid, and you
10:59:40 <monochrom> nice, at least it's -a throughout
10:59:45 <Rc43> didn't see, sorry :)
11:00:11 <Younder> I am having problems logging in to haskellers.com?
11:00:21 <monochrom> you are?
11:00:30 <byorgey> adimit: you can do it with the time library, but it probably won't be a simple function call
11:00:58 <zygoloid> monochrom: you hate english-centricity... in the middle of an english sentence?
11:00:59 <Younder> getAddrInfo  does not exist
11:01:01 <Ptival> @hoogle Bool -> a -> a -> a
11:01:02 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
11:01:02 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
11:01:02 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
11:01:06 <adimit> byorgey: I've scavenged the docs, but couldn't find an *obvious* solution, maybe there's a hidden one.
11:01:26 <adimit> byorgey: though I think missingh has just what i need.
11:01:42 <Ptival> isn't there a functional if that I can liftA3?
11:02:07 <byorgey> adimit: there definitely isn't an obvious solution.  The time library is notoriously difficult to navigate.
11:02:42 <monochrom> "haskellers.com has address 50.16.170.145" from where I am
11:02:45 <dainanaki> I hate humanity's implementation of time.
11:03:05 <Ptival> @type liftA3 (\c i e -> if c then i else e)
11:03:07 <lambdabot> forall c (f :: * -> *). (Applicative f) => f Bool -> f c -> f c -> f c
11:03:25 <Younder> monochrom, I just registered today. I've I have never been there before
11:04:03 <monochrom> alright. I have just seen the web page in a web browser. I haven't registered or logged in
11:04:04 <sm> we need hoogle to plug functions together to give you the types you want
11:04:33 <byorgey> Ptival: no, sadly
11:04:37 <Younder> monochrom, I HAVE registered
11:05:04 <adimit> byorgey: Yeah, difficult to navigate kinda hits the nail on the head. Or maybe I'm just silly.
11:05:43 <byorgey> adimit: it is objectively difficult to navigate.  So far I have no evidence one way or the other as to your silliness.
11:05:46 <sm> adimit: there's no nice overview doc for time, you have to study all the haddocks till you have a rough mental map
11:06:03 <Younder> monochrom, unfortunately my e-mail provider has a anti-spamming policy that means I have to wait 3 hour before replying to a email
11:06:07 <adimit> byorgey: oh, I'm very silly.
11:06:42 <int-e> Younder: ouch
11:06:46 <adimit> sm: thanks, though I'll pass on that. MissingH seems to have what I need, I'll try to limit my exposure to time (heh, if it were that easy.)
11:06:56 <Younder> monochrom, and I think that messed up the registration
11:07:34 <monochrom> if haskellers.com can't wait 3 hours for your reply
11:07:56 <monochrom> (most websites don't mind waiting days or weeks, no?)
11:09:07 <Younder> monochrom, I'm just sayin I got a internal server error 'getAddrInfo: does not exist (Name or service not known)'
11:09:38 <Younder> monochrom, I mean sure I run a firewall
11:10:48 <sm> adimit: cool. When you need it, it'll do the job
11:11:56 <sm> fwiw, it looked like you convert seconds to UTCTime with posixSecondsToUTCTime , then maybe formatTime that
11:13:57 <Rc43> Post's machine is simplified Turing's machine? Without states, with numbers <- {0,1}, infinite field and with brainfuck-like code, right?
11:14:10 <sm> there's also old-time
11:15:23 <adimit> sm: well, I need to use DiffTime and NominalDiffTime … Also, missingH's functions are a bit tricky, because they seem to still rely on the System.Time datatypes, which are incompatible with the Data.Time ones. *sigh*
11:15:58 <adimit> so I'm still on the hunt, and I think your idea might work, if I can find a format function that accepts DiffTime/NominalDiffTime
11:16:30 <Younder> adimit, I use the Unix OS commands
11:16:43 <adimit> Younder: haha, well, that's one way.
11:17:39 <Younder> adimit, well one way is all you need
11:17:49 <adimit> it would make me very unhappy having to work around haskell's time API with unix OS commands.
11:18:08 <adimit> It's a way that sacrifices platform independence. Which I might need in the future :-\
11:19:02 <c_wraith> Hmm.  I hadn't considered displaying time diffs.  Yes, that is a hole in the current time package.
11:19:07 <Younder> adimit, agreed, you need a HAL (Hardware Abstraction Layour)
11:19:16 <c_wraith> It's probably worth sending an email to the libraries mailing list about that.
11:19:33 <Younder> adimit, but then you should have one anyhow
11:20:06 <roconnor> timeToTimeOfDay :: DiffTime -> TimeOfDay works for time less than 24 hours
11:20:47 <c_wraith> But honestly, formatting diffs should be different from formatting times.
11:20:57 <c_wraith> You don't want to say "January", you want to say "one month"
11:21:34 <Younder> roconnor, but most importantly TimeOfDay doesn't work in this case
11:21:49 <adimit> c_wraith: indeed. Or just consider the simple example of "this program will finish in 2d7h24m" or somesuch. That's all I want.
11:22:21 <adimit> What I *have* is a NominalDiffTime. but it seems to be difficult to render it that way :-\
11:22:25 <c_wraith> adimit: I agree, you have a totally legit use case that isn't covered by the existing lib.
11:22:46 <adimit> roconnor: yeah, but that's not exactly what I want, given that my program might well take days to finish.
11:22:57 <EvanR-work> c_wraith: is there an alternative time lib
11:23:01 <Younder> adimit, actually that would work
11:23:04 <EvanR-work> one with saner theoretical basis ;)
11:23:29 <c_wraith> EvanR-work: time is actually one of the best-designed time libraries I've used.  it's *really* hard to get right.  This is just something it doesn't cover.
11:23:37 <c_wraith> EvanR-work: the problem is that measuring time is not sane
11:23:53 <EvanR-work> c_wraith: it is, but not in our society ;)
11:23:54 <c_wraith> EvanR-work: no library can be cleaner than the real-world model, which has *tons* of problems
11:24:01 <Younder> EvanR-work, yes there is
11:24:26 <EvanR-work> c_wraith: what real world model, and what problems
11:24:33 <roconnor> adimit: you shouldn't be using NominalDiffTime for that sort of thing.  DiffTime is appropriate
11:24:46 <Younder> EvanR-work, Calendrical calculations
11:24:52 <EvanR-work> how is that 'real world'
11:25:05 <c_wraith> EvanR-work: How many seconds are there in between now and 18:35 march 5th, 2048?
11:25:22 <c_wraith> EvanR-work: You cannot answer that question correctly right now.
11:25:32 <c_wraith> EvanR-work: there's simply insufficient data, due to leap seconds
11:25:34 <EvanR-work> ok so real world means, our stupid ass artificial system
11:25:43 <EvanR-work> i.e. not real ;)
11:25:45 <adimit> roconnor: interesting. I'm currently getting UTC times with getCurrentTime. The only way I've seen to make a time difference between two UTCTimes was diffUTCTime, which spits out NominalDiffTime. But maybe there's another way?
11:26:10 <c_wraith> EvanR-work: it's real.  it even has a physical basis.
11:26:24 <c_wraith> EvanR-work: this planet we're on is not imaginary
11:26:41 <roconnor> adimit: I don't understand how you computed what UTCTime your program will end.
11:26:43 <roconnor> adimit: hmm
11:26:46 <Younder> EvanR-work, I'ts ab obb with source code written by Nachum Dershowittz and Edward M. Reingold
11:26:56 <EvanR-work> ab obb
11:27:05 <Younder> EvanR-work, a book
11:27:27 <EvanR-work> c_wraith: im quitting the discussion about whats real
11:28:24 <adimit> roconnor: well, the way it works is: I have n input chunks (known beforehand.) startTime and currentTime are obvious, and then I have chunksAlreadyProcessed. currentTime `diffUTCTime` startTime / chunksAlreadyProcessed * numberOfTotalChunks.
11:28:35 <c_wraith> EvanR-work: I agree it's not sane, though. :)
11:28:45 <Younder> EvanR-work, So am I, sorry for them typoes
11:29:01 <EvanR-work> c_wraith: the planet is a stupid basis
11:29:13 <adimit> roconnor: that gives me an ETA in NominalDiffTime
11:29:15 <roconnor> adimit: unfortunately the difference between start time and current time won't tell you how many seconds have passed due to the existance of leap seconds.
11:29:39 <c_wraith> fortunately, leap seconds only ever occur on december 31st
11:29:44 <monochrom> you can omit leap seconds for an ETA that spans days
11:29:45 <Younder> EvanR-work, Oh F*** all use GMT
11:29:48 <roconnor> c_wraith: that isn't true
11:29:55 <c_wraith> (in theory they could happen other days, but they never have)
11:29:56 <EvanR-work> GMT, i.e. UTC+0 is not much better
11:30:02 <roconnor> c_wraith: they also can occur in June or July
11:30:04 <adimit> maybe I should go for POSIX times then. But then *everything* is NominalDiffTime.
11:30:18 <adimit> in any case, if my ETA is one second off, I won't cry.
11:30:42 <monochrom> I don't think it's healthy to be anal about leap seconds for every bloody application
11:30:44 <c_wraith> Heck, whoever wrote the file copy dialog for windows didn't care if he was off by 10 hours. :)
11:31:00 <c_wraith> (on a 3 minute operation)
11:31:02 <Younder> EvanR-work, If you are so obsessed about tim at least consider my book
11:31:14 <EvanR-work> Younder: your book?
11:31:15 <Younder> time
11:31:29 <Younder> EvanR-work, Calendrical calculations
11:31:53 <EvanR-work> im really not interested in the calendar, ive had enough of it
11:31:58 <EvanR-work> its even worse in chinese
11:32:12 <Younder> EvanR-work, THAT it is
11:33:08 <roconnor> adimit: if you want to ignore leap second (realToFrac) presumably will convert a NominalDiffTime to a DiffTime.
11:33:39 <adimit> ok, so here's a goodie: how exactly do I get an Integer amount of seconds out of a NominalDiffTime (can be rounded?) The only way I can see now is: fromEnum nomDiffTime `div` 10^12, which… I don't like.
11:34:07 <roconnor> adimit: try round
11:34:15 <Younder> roconnor, I think you have illustrated what a bitch time really is
11:34:25 <adimit> roconnor: thank you
11:34:36 <adimit> that does the trick nicely.
11:34:50 <roconnor> adimit: I got it recently added :D
11:35:11 <roconnor> oh wait
11:35:13 <monochrom> @type round
11:35:13 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:35:23 <roconnor> it was DiffTime that I got made into RealFrac recently
11:35:29 <monochrom> NominalDiffTime is a RealFrac, so round applies
11:35:48 <monochrom> @type realToFrac
11:35:49 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
11:36:19 <monochrom> both DiffTime and NominalDiffTime are both Real and Fractional, so realToFrac applies
11:36:42 <adimit> well, ok, this looks wonderful. I'm getting exactly what I want :-) thanks!
11:37:07 <monochrom> (DiffTime is not a RealFrac by mistake. bug discovered in #haskell. fixed in a very recent version)
11:37:16 <roconnor> adimit: anyhow, I'd be inclided to use divmod on your DiffTime (which you got from NominalDiffTime using realToFrac) to divide and mod the time by 1 day.  then convert the mod part into a TimeOfDay and extract your hours minutes and seconds.
11:38:28 <monochrom> > toEnum 0 :: DiffTime
11:38:29 <lambdabot>   Not in scope: type constructor or class `DiffTime'
11:38:37 <monochrom> > toEnum 0 :: Data.Time.DiffTime
11:38:37 <lambdabot>   Not in scope: type constructor or class `Data.Time.DiffTime'
11:38:49 <adimit> roconnor: missingh seems to have exactly that kind of function: renderSecs :: Integer -> String. Very pragmatic. That'll give me a string that looks exactly like I wanted it.
11:38:56 <tac-tics> > 1 + 1 + 1
11:38:57 <lambdabot>   3
11:39:01 <tac-tics> > sum [1..]
11:39:17 <lambdabot>   thread killed
11:39:24 <tac-tics> Where's your god now lambdabot??
11:39:54 <hpc> @vixen where is your god now?
11:39:54 <lambdabot> Jesus H. Christ...
11:39:59 <tac-tics> lol
11:40:09 <roconnor> adimit: if you want to be less lame, you convert your UTCTimes into AbsoluteTime using utcToTAITime and then use diffAbsoluteTime to get a proper DiffTime and proceed with divmod.
11:41:06 <adimit> roconnor: also valid, I guess. But I'm fine being lame for now.
11:41:21 <roconnor> are there any system calls for getting the system's LeapSecondTable?
11:41:36 <monochrom> no
11:41:40 <roconnor> stupid posix
11:41:46 <EvanR-work> roconnor: how is that less lame and why would you not do it
11:42:11 <roconnor> EvanR-work: the problem is that utcToTAITime requires a LeapSecondTable from somewhere.
11:42:30 <EvanR-work> so needs to be hardcoded into the source
11:42:41 <EvanR-work> but it would only help for absolutes times in the past
11:42:49 <EvanR-work> and adimit's program is for the future
11:42:52 <sm> maybe all the time haddocks should be gathered into the top-level module
11:43:06 <roconnor> or you could get it from IO at the same time you are getting the currentTime
11:43:25 <EvanR-work> so his program cant possibly work (100%) unless he had an event handler for 'funny astronomers decided we needed a leap second'
11:43:48 <EvanR-work> far out
11:43:50 <roconnor> EvanR-work: no, he is extrapolating from the past: start time - current time.
11:43:59 <hpc> didn't they decide that leap seconds happened every 400 years or so?
11:44:02 <roconnor> EvanR-work: In principle the system could know the existance of a leap second in that interval.
11:44:08 <adimit> "Running for 1m15s; did 10 chunks; (0%) ETA: 1d23h" — I don't care about leap seconds :-D
11:44:23 <EvanR-work> roconnor: oh, i guess i dont understand the 'will end in X seconds'
11:44:35 <Eduard_Munteanu> Can't we just set the epoch time to the big bang (or possibly a known, measurable event) and count Cs average half-lives since then? :)
11:44:50 <roconnor> adimit: at least you are using UTC and not LocalTime.
11:44:59 <EvanR-work> C12 has a half life of infinity
11:45:04 <roconnor> adimit: kudos for that
11:45:12 <Eduard_Munteanu> EvanR-work: caesium
11:45:18 <EvanR-work> oh
11:45:31 <EvanR-work> i read that as C's ;)
11:45:31 <roconnor> Eduard_Munteanu: when I write my OS, the system clock will be set to TAITime.
11:45:33 <adimit> roconnor: lol, it would work with localTime just as well, since I'm interested in differences. As long as localTime isn't skewy, it makes no matter :-P
11:46:00 <EvanR-work> skwewy
11:46:01 <Eduard_Munteanu> TAI?
11:46:06 <roconnor> adimit: often localTime regularly runs backwards for about an hour.
11:46:13 <EvanR-work> Eduard_Munteanu: absolute atomic time
11:46:19 <adimit> roconnor: well, that'd suck :-P
11:46:25 <Eduard_Munteanu> Ah :)
11:46:46 <adimit> anyway, I planted the program on the server. Enough work for today, time to go play!
11:46:48 <EvanR-work> Eduard_Munteanu: works for any times after 1950something ;)
11:46:57 <adimit> thanks for the help everybody!
11:47:05 <roconnor> adimit: when your start time occurs after your current time due to a switch in DST, then you would get screwy predictions :P
11:47:20 <roconnor> adimit: anyhow, using UTC avoids that problem
11:47:39 <adimit> it does indeed. so I'm happy now.
11:48:23 <maurer_> I mean, if you're just doing time intervals, you could just use the tsc instead of the realtime clock
11:48:31 <maurer_> That thing ticks pretty steady :P
11:48:33 <MHD> I read a joke once that a Computer Scientist/Programmer/Hacker would rather reconfigure the universe than use time libraries.
11:48:45 <roconnor> though on rare occasions when current time is less than 1 second after start time and occurs during a leap second, you will also get negative predictions causing a casacding failure that will stop all pacemakers in the world and stuff off all nuclear safety sytems.
11:48:55 <roconnor> *shut off
11:49:26 <hpc> MHD: joke?
11:49:30 <EvanR-work> MHD: where as mortals happily use javascripts 'Date class' and get a paycheck. (for broken code) ;)
11:49:49 <monochrom> this is why pacemakers don't use wifi to find out the latest leap second table
11:50:22 <MHD> hpc: You're right. It was a fact stated in an amusing way.
11:51:42 <kmc> if you're doing time intervals you should use POSIX's CLOCK_MONOTONIC
11:51:53 <kmc> there's several problems with using the x86 tsc, although sometimes it's the right choice
11:52:03 <kmc> http://hackage.haskell.org/packages/archive/clock/0.2.0.0/doc/html/System-Posix-Clock.html
11:52:26 <Rc43> Guys, i can't find the article about mass problems (e.g. in wiki). Is it called such in english?
11:53:00 <EvanR-work> mass library, needs an IO action to produce a standard kilogram
11:53:07 <roconnor> kmc: that doesn't seem so bad
11:54:26 <maurer_> EvanR-work: Why? What is it using IO for?
11:54:33 <EvanR-work> the mass
11:54:40 <roconnor> kmc: how big is an int according to POSIX?
11:54:54 <kmc> probably "at least 4 bytes".  don't actually know
11:55:01 <EvanR-work> mass is inherently referentially opaque
11:55:25 <roconnor> kmc: rolls over in 136 years?
11:55:30 <kmc> yeah
11:55:35 <roconnor> not so monotone
11:55:45 <kmc> ;P
11:55:57 <roconnor> kmc: what is your uptime?
11:56:11 <kmc>  15:38:57 up 2 days,  4:45,  5 users,  load average: 0.00, 0.00, 0.00
11:56:38 <kmc> the Linux kernel's internal 'jiffies' counter is initialized not to 0 but to MAXINT - 5 minutes
11:56:44 <kmc> so that overflow problems are easier to spot :D
11:58:08 * roconnor googles "how do I reset the system's MONOTONIC clock?"
11:58:39 <roconnor> jiffies counter?
11:59:19 <roconnor> Rc43: what mass problem? or rather, which mass problem?
11:59:23 <kmc> yeah.  the variable is named 'jiffies' and it measures time in units also called 'jiffies'
11:59:46 <Eduard_Munteanu> Basically, time interrupts.
11:59:53 <roconnor> kmc: are the overflow problems easier to spot because the clock always overflows 5 minutes after booting?
11:59:58 <kmc> yes
12:00:09 <roconnor> ... interesting solution
12:00:15 <digitteknohippie> oh cool, just like real jiffies, like in physics... surely not counting such tiny increments of time for real though...?
12:00:19 <roconnor> I know how most developers will work around it though ...
12:00:20 <kmc> so if you ever encounter a Linux machine that always crashes after exactly 5 minutes, that's why
12:00:29 <kmc> digitteknohippie, what do the physicists use it to measure?
12:01:13 <Rc43> roconnor, I have already found some info in ru-wiki. It is problems, which are should be solved `commonly` for different parameters and a lot of them are undeciable, as I understood.
12:01:16 <digitteknohippie> iirc, a jiffie is the length of time it takes for light to travel... er... a really short distance.  i dont recall if it's something like an inch, or smaller, like a femtometer.
12:01:21 <Eduard_Munteanu> I'm not sure how they're handled with nohz, they're probably not equally spaced at all.
12:01:35 <kmc> light travels about a foot in a nanosecond
12:01:47 <MHD> Couldn't one just define the kilogramme from the planc mass?
12:01:50 <kmc> Eduard_Munteanu, I think jiffies remain a regular unit, but become more arbitrary
12:01:59 <kmc> i.e. not tied to actual interrupts
12:02:10 <roconnor> ``The value of the CLOCK_MONOTONIC clock cannot be set via clock_settime(). This function shall fail if it is invoked with a clock_id argument of CLOCK_MONOTONIC.''
12:02:13 <roconnor> *sigh
12:02:36 <Eduard_Munteanu> Well, it's still monotonic, and it's not like they make for good timestamps, so I guess it's alright.
12:03:02 <kmc> if you have CONFIG_HZ=1000 (preferred setting for desktops) then wraparound happens after about 50 days
12:03:04 <digitteknohippie> The earliest technical usage for jiffy was defined by Gilbert Newton Lewis (1875–1946). He proposed a unit of time called the "jiffy" which was equal to the time it takes light to travel one centimetre (approximately 33.3564 picoseconds).[2] It has since been redefined for different measurements depending on the field of study.  } says wikipedia. :)
12:03:23 <kmc> if you start at 0
12:03:35 <kmc> which is short enough to actually cause problems, but long enough that you'll never debug them ever
12:04:02 <Eduard_Munteanu> kmc: ah so they're, say, updated each time the scheduler kicks in, but using some other timing source (RTC, HPET maybe?)?
12:04:27 <kmc> i'm not sure honestly
12:04:32 <kmc> don't know much about NOHZ
12:05:09 <Eduard_Munteanu> I'm still a bit puzzled it took kernel people so long to get something like that working.
12:05:11 <kmc> the kernel does pick a favorite time source (RTC, HPET, TSC, PIC, APIC) and use that for lots of things, including sub-jiffies measurements
12:05:50 <Eduard_Munteanu> Yeah, I know it determines that during bootup.
12:06:16 <Eduard_Munteanu> since TSCs could be unsynchronized, APICs dead during sleep modes etc.
12:08:45 <roconnor> presumablly a jiffie isn't a fixed time period?
12:08:54 <roconnor> (in Linux)
12:09:09 <DukeDave> Here's one for you: I'm just messing around with Debug.Trace, and I decided to use it within a do block in the IO monad, so I wrote this:
12:09:09 <DukeDave>        _      <- return $ trace "TEST" 1
12:09:09 <DukeDave>        print (trace "FOO" "DONE")
12:09:30 <Younder> 	
12:09:30 <Younder> Networks, Crowds, and Markets: Reasoning About a Highly Connected World by David Easley (Hardcover)
12:09:31 <roconnor> DukeDave: I doubt trace "TEST" will ever be called
12:09:40 <Eduard_Munteanu> roconnor: not sure, especially with nohz. But you're more likely to rely on its monotonicity than its precision so it might not be much of a problem.
12:09:41 <DukeDave> roconnor: Laziness?
12:09:43 <roconnor> DukeDave: try () <-
12:09:48 <dmwit> DukeDave: yep
12:09:59 <roconnor> Eduard_Munteanu: that's what I figure
12:10:08 <Eduard_Munteanu> The timer interrupt itself isn't really great either.
12:10:24 <dmwit> DukeDave: Or try _ <- trace "TEST" (return 1)
12:10:36 <roconnor> also good
12:10:45 <roconnor> in fact, I'd say even better
12:11:09 <DukeDave> dmwit: Aha, that's what I was getting at
12:11:33 * DukeDave was thinking "it can't just lazily decide not to 'evaluate' a monadic computation
12:11:54 <DukeDave> But the 1 was outside the monad, wasn't it :|
12:12:00 <dmwit> yuppers
12:12:10 <DukeDave> Nifty
12:12:53 <roconnor> DukeDave: understanding how laziness interacts with monadic computation (especially IO, though not specifically), will level up your Haskell badge.
12:13:24 <dmwit> next up: lazy State monad
12:13:34 <roconnor> DukeDave: i.e. these are very good questions to be thinking about.
12:15:13 <MHD> Isn't a "StateMonad s a" a "WriterMonad s a" if "Monoid s"?
12:15:44 <roconnor> nope
12:15:55 <DukeDave> Mm, I still have that smug, warm feeling when something makes sense in Haskell, a feeling which I never felt after, for example: spending an hour debugging some C++ only to discover someone's sneaky const_cast  :|
12:17:07 <roconnor> MHD: even worse, WriterMonad is intrinsically lazier than a StateMonad with a WriterMonad interface.
12:19:48 <MHD> And can't you do a "ReaderMonad s a" with a "Statemonad s a"?
12:20:57 <heatsink> You can.  I think that "local" loses its tail-call property, because you have to explicitly reset the state.
12:21:05 <roconnor> you can implement ReaderMonad with StateMonad yes.
12:21:20 <roconnor> I'm not sure what the laziness implications are
12:21:30 <roconnor> probably again not good.
12:21:30 <NemesisD> hi all. i was told for pushing JSON data to stdout i should use a builder. is the idea to do something like toByteStringIO ByteString.putStrLn myBuilder ?
12:31:32 <heatsink> > runWriter mempty
12:31:36 <lambdabot>   No instance for (Data.Monoid.Monoid
12:31:36 <lambdabot>                     (Control.Monad.Tran...
12:31:57 <heatsink> > runWriter (tell [])
12:31:58 <lambdabot>   ((),[])
12:32:17 <heatsink> :t runWriter (tell [])
12:32:20 <lambdabot> forall a. ((), [a])
12:32:27 <heatsink> There seem to be some extra defaulting rules going on...
12:32:42 <roconnor> heatsink: ya you got ((),[()]) during execution
12:33:07 <roconnor> > runWriter (tell mempty)
12:33:08 <lambdabot>   ((),())
12:33:24 <roconnor> () is a monoid
12:33:32 <roconnor> so the () defaulting worked
12:35:32 <parcs> > runWriter (fovever $ tell " ")
12:35:33 <lambdabot>   Not in scope: `fovever'
12:35:38 <parcs> > runWriter (forever $ tell " ")
12:35:42 <lambdabot>  Terminated
12:35:49 <copumpkin> yay, another proof of false in agda
12:35:54 <copumpkin> anyone keeping a count?
12:36:16 <roconnor> > head $  execWriter (forever $ tell " ")
12:36:17 <lambdabot>   ' '
12:36:24 <roconnor> copumpkin: where?
12:36:26 <copumpkin> http://code.google.com/p/agda/issues/detail?id=444
12:36:39 <copumpkin> roconnor: you should move from coq to agda. This new feature makes all your proofs a lot easier
12:36:48 <copumpkin> just think of all the things you could prove with it
12:37:02 <kmc> anyone here have ops in #haskell-blah?
12:37:09 <copumpkin> yeah
12:37:12 <roconnor> copumpkin: last time I saw a proof of False in coq the bastards removed the feature.
12:37:18 <parcs> > Control.Monad.Writer.Lazy.runWriter (forever $ tell " ")
12:37:19 <lambdabot>   Not in scope: `Control.Monad.Writer.Lazy.runWriter'
12:38:04 <roconnor> copumpkin: pfft, postulates
12:38:46 <roconnor> parcs: runWriter will always fail with that code no matter how lazy you try to make it.
12:38:50 <roconnor> parcs: you want execWriter
12:39:51 <roconnor> copumpkin: did you see http://r6.ca/blog/20061211T203500Z.html back in the day?
12:39:56 <parcs> roconnor: in ghci the lazy writer prints "(" then hangs and the strict hangs right away
12:40:08 <copumpkin> roconnor: oh, no
12:40:10 <roconnor> parcs: yep
12:40:15 <copumpkin> I hadn't even heard of haskell back in those days :P
12:40:17 <elliott> copumpkin: _another_ Agda proof of _|_?
12:40:18 <copumpkin> let alone coq or agda
12:40:23 <elliott> they get one like every month
12:40:24 <copumpkin> elliott: it does require a postulate, though
12:40:38 <elliott> ok, that's slightly better :P
12:40:43 <elliott> if it's just irrelevance though...
12:41:33 <roconnor> copumpkin: I like how these contraditions all could plausibly be found simply by enumerating all valid agda/coq scripts
12:46:23 <roconnor> ugh, I just became a member of the ACM
12:46:27 * roconnor feels dirty
12:46:50 <DrTeggy> Been there, feeling well.
12:47:06 <roconnor> oh good
12:47:31 <DrTeggy> Now add a few SIG memberships to the package.
12:47:39 <roconnor> are they free?
12:47:54 * hackagebot vector-space 0.7.6 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.7.6 (ConalElliott)
12:48:07 * DrTeggy is member of SIGMOD and SIGPLAN, to express his love for databases and PLs
12:48:13 <DrTeggy> :-)
12:48:16 <conal> byorgey: this new vector-space version has your 'project' function. thanks!
12:48:23 <DrTeggy> roconnor: No
12:48:31 <roconnor> I'll pass then
12:48:34 <DrTeggy> Approx $20/year
12:49:16 <coppro> roconnor: I feel sorry for you
12:49:17 <roconnor> this code of ethics now requires me to honor copyrights and patents
12:49:37 <DrTeggy> Issue patents, even ;-)
12:50:09 * roconnor wonders what the consequences of violating the code of ethics is.
12:50:21 <DrTeggy> []
12:50:37 <roconnor> won't they boot me out of the ACM?
12:50:54 <DrTeggy> I haven't heard of a single case.
12:51:46 <roconnor> I also have to promote the honoring of copyrights and patents
12:51:54 <DrTeggy> Why did you join in the first place?
12:52:03 <roconnor> to save on ICFP registration fees
12:52:42 <DrTeggy> Valid reason. See you in Tokyo then.
12:52:45 <roconnor> I figure I only have to live up to these ethics for 3 weeks and then I can forget out them.
12:52:48 <roconnor> :)
12:53:23 <roconnor> hey everyone, copyrights are totally awesome and patents in no way stiffles inovation in software!
12:53:58 <roconnor> that should cover ethical principle 4.1 for the time being.
12:54:42 <ion> Copyrights aren’t totally awesome, they expire too soon. Fortunately, our friendly lobbyists have had great success fixing that problem.
12:55:06 <roconnor> ion: you must be a member of the ACM too.
12:55:17 <EvanR-work> roconnor: remember, if called to jury on an IP case, know your rights of jury nullification
12:55:28 <MHD> What kinds of Patents and Copyrights can you apply to algorithms?
12:55:30 <roconnor> EvanR-work: does that work in Canada?
12:55:33 <EvanR-work> probably
12:55:36 <roconnor> ok
12:55:43 <EvanR-work> better look it up anyway
12:56:16 <MHD> And what if one makes original research and derives the same algorithm as has been patented?
12:56:18 <roconnor> MHD: patents maybe apply to algorithms, but copyrights only apply to the text of a description / implementation of an algorithm
12:56:43 <roconnor> MHD: as long as you are not aware of the patent you will not be fined triple damanges.
12:56:55 <roconnor> MHD: and only be fined damages.
12:57:24 <MHD> But if one can document original research and the algo is only used internally in a product?
12:57:56 <roconnor> MHD: still a violation
12:58:07 <MHD> Gog, I hate this stupid planet.
12:58:08 <roconnor> assuming the patent is valid
12:58:17 <roconnor> which is far from certain.
12:58:54 <roconnor> MHD: my ACM ethics require me to tell you that you should honor patents.
12:59:02 <Eduard_Munteanu> It also means you can wait around for the patented technology to become common-use, then sue everybody.
12:59:16 <adrake> roconnor: assuming the patent is valid /or/ you can't muster the incredible amount of money required for a legal defense against a patent suit
12:59:33 <MHD> roconnor: I have just had a distressing conversation/rant about discrimination in #haskell-blah
12:59:41 <ion> If the legal costs in fighting bankrupt you, the validity of the patent is not that relevant.
13:00:46 <copumpkin> roconnor: I got rid of the postulate
13:01:01 <roconnor> copumpkin: and still false?
13:01:06 <copumpkin> of course :)
13:01:17 <copumpkin> I would accept nothing less from my favorite proof assistant
13:01:17 <copumpkin> http://code.google.com/p/agda/issues/detail?id=444
13:01:49 <roconnor> that is pretty horrible
13:01:54 <copumpkin> :P
13:01:56 <Eduard_Munteanu> copumpkin: but that's the most useful theorem. It can prove lots of stuff.
13:01:58 <EvanR-work> roconnor: you have to be found guilty of copyright infringement before you get fined, most of the time though the victim settles out of court (avoiding the possibility of jury nullification)
13:02:05 <copumpkin> Eduard_Munteanu: well, with this theorem
13:02:08 <copumpkin> I can prove everything!
13:02:12 <Eduard_Munteanu> Yup.
13:02:19 <copumpkin> I love it
13:02:44 <mokus> yup, and if you don't like false being true, you can use it to prove not-false too!
13:03:20 <Eduard_Munteanu> It took awhile for Agda to reach Falso's level.
13:03:55 <mokus> it still doesn't have the same level of recognition though, all falso's promoters were dead before agda was even invented
13:03:55 <roconnor> oh wait, after reading more carefully I only need to promote honoring of copyrights and patents to other ACM members.
13:03:55 <Eduard_Munteanu> (context: http://estatis.coders.fm/falso/ )
13:05:07 <rwbarton> I wonder what the purpose of that could be? aren't they subject to the same code?
13:05:46 <roconnor> rwbarton: I guess some lax ACM members need to be whipped into shape.
13:09:39 <DrTeggy> hehe
13:10:05 <roconnor> lax monoidal ACM-functors
13:12:55 <roconnor> copumpkin: this is a proof-irrelevence issue?
13:12:58 * roconnor looks again
13:13:11 <copumpkin> roconnor: yeah, the termination checker doesn't notice non-terminating irrelevant things
13:13:24 <copumpkin> because the irrelevance throws the information (that you're calling yourself) away
13:13:37 <roconnor> copumpkin: why does relevant typecheck?
13:14:02 <copumpkin> that was a design decision, apparently :)
13:14:17 <roconnor> copumpkin: is () the unit value?
13:14:26 <copumpkin> no, () is an absurd pattern match
13:14:28 <elliott> () is agda's weird magic for not having to pattern match
13:14:35 <roconnor> oh okay
13:14:38 <elliott> you implement void : forall a, () -> a
13:14:40 <elliott> with void ()
13:14:41 <elliott> i think
13:14:51 <elliott> erm
13:14:54 <elliott> s/()/_|_/
13:14:58 <roconnor> and the . means irrevent argument?
13:15:16 <elliott> dunno, my agda knowledge expires before then
13:15:26 <copumpkin> roconnor: yeah
13:17:10 <roconnor> copumpkin: but bad = bad doesn't work?
13:17:29 <copumpkin> roconnor: then it can see that it doesn't terminate and marks it as such
13:17:54 <elliott> copumpkin: agda's termination checker makes me think of like
13:18:06 <elliott> a half-broken "type-checker" implemented as an optional compiler pass onto assembly
13:18:07 <elliott> or something
13:18:07 <roconnor> copumpkin: weird
13:18:18 <elliott> before anyone remembered what a type system was
13:18:46 <roconnor> I kinda feel like whoever implemented proof-irrelevence in Agda should have known about this.
13:20:59 <roconnor> copumpkin: oh, typechecking is divorced from termination checking?
13:21:06 <copumpkin> yeah
13:21:09 <roconnor> copumpkin: can you make Agda's typechecker go into loops easily?
13:21:31 <copumpkin> if you take a non-terminating function and stick it into a type, yeah
13:21:37 <roconnor> interesting
13:21:41 <copumpkin> but the non-terminating function will have been marked as such beforehand
13:21:43 <mokus> or you can just make a type that depends on graham's number
13:21:47 <copumpkin> so you're knowingly shooting yourself in the foot
13:21:50 <copumpkin> mokus: lol, or that
13:21:51 <mokus> it technically terminates, but only technically
13:21:54 <roconnor> copumpkin: termination checking happens before type checking?
13:22:21 <copumpkin> roconnor: afterwards, I think. But presumably you wrote the non-terminating function that went into a type beforehand
13:22:24 <copumpkin> and it'd be pink
13:22:24 <copumpkin> :P
13:22:35 <roconnor> oh
13:23:34 <roconnor> this is all very bad
13:23:44 <copumpkin> lol
13:23:53 <copumpkin> I like that they're divorced
13:24:12 <copumpkin> as long as it actually works
13:24:19 <roconnor> I'm surprised it works as well as it does
13:26:04 <roconnor> copumpkin: .bad : .⊥    ;  bad = bad -- does this work?
13:26:12 <copumpkin> it typechecks but is pink
13:26:18 <copumpkin> that's the one you asked me for before
13:26:25 <copumpkin> pink means "not obviously terminating"
13:26:30 <roconnor> I added a dot in front of .⊥
13:26:42 <copumpkin> oh, return values can't be irrelevant
13:26:53 <copumpkin> or rather
13:27:00 <copumpkin> that's indicated by the dot in front of the name
13:27:11 <roconnor> I see
13:27:24 <mokus> copumpkin: Graham's number :) - https://github.com/mokus0/junkbox/blob/master/Agda/ack.agda
13:27:33 <copumpkin> mokus: ack :P
13:28:04 <copumpkin> a unary graham's number
13:28:05 <copumpkin> the best
13:28:32 <copumpkin> write some proofs about it :)
13:28:49 <mokus> nah, it's "optimized" - it has '*' in the first level of the up arrow notation
13:29:09 <copumpkin> well, * is still unary :P
13:29:18 <copumpkin> you're going to have lots of sucs :)
13:29:29 <mokus> i thought it used Integer internally
13:29:48 <mokus> it's able to handle exponentiation fine with some pretty big exponents
13:30:35 <byorgey> " "g 0" is already incomprehensibly large."
13:30:42 <byorgey> "g 0  = 4"
13:30:46 <mokus> i did write some proofs about the up-arrow notation in another file, haven't commited them yet though because they're kinda half baked
13:30:47 <byorgey> hehe
13:30:55 <mokus> lol, for very large values of 4
13:30:59 <byorgey> one, two, three, OMG
13:31:05 <mokus> guess i missed that when i changed the base case
13:31:39 <mokus> funny, because i didn't miss the other occurrence of "g 0" on the same line
13:32:40 <byorgey> hehe
13:32:47 <luite> is there a preprocessor thing that can be used to find out whether the operating system is windows?
13:33:06 <mokus> i wonder how difficult it would be to transcribe graham's proof where he actually used that number into agda
13:33:07 <c_wraith> sort of.  you can check for being compiled with mingw
13:33:21 <c_wraith> since only windows compiles ghc code with mingw
13:33:41 <copumpkin> mokus: it would probably take g 65 lines of agda
13:33:49 <luite> #ifdef MINGW ?
13:33:59 <c_wraith> I don't remember the exact symbol name
13:34:13 <EvanR-work> #ifdef WIN32
13:34:18 <EvanR-work> \o/
13:34:21 <copumpkin> mokus: the statement would, that is. You could prove it in one line with the new feature in that ticket :)
13:34:26 <luite> EvanR-work: that works?
13:34:34 * byorgey has a (g 65)-byte hard drive lying here you could use
13:34:36 <EvanR-work> -DWIN32
13:34:50 <copumpkin> byorgey: each line is longer than one byte, sadly
13:34:51 <mokus> copumpkin: yea, but that wouldn't be a transcription of his proof
13:35:04 <copumpkin> it's a simplification
13:35:11 <byorgey> copumpkin: oh, too bad.  I'd let you use my (g 66)-byte drive but it's full
13:35:14 <copumpkin> maybe we could win graham over to our strongly typed ways
13:35:25 <luite> yeah but I have other preprocessor options in my .cabal
13:35:29 <mokus> copumpkin: we could use your theorem to prove a tighter upper bound too!
13:35:33 <copumpkin> byorgey: damn
13:35:39 <copumpkin> mokus: oh, good idea
13:35:43 <copumpkin> like 6
13:36:12 <mokus> lol, yup - along with 6 > 13, since 13 (i believe) is a known lower bound
13:36:56 <copumpkin> lol
13:38:18 <acowley> does anyone have a cabal setup that invokes a C++ compiler?
13:40:48 <mokus> acowley: i haven't checked to see whether it builds on recent versions of everything, and it's for some pretty obscure C++ software, but I have one
13:40:55 <mokus> I just list the cpp files under c-sources
13:40:58 <mokus> https://github.com/mokus0/hla-rti13/blob/master/hla-rti13.cabal
13:42:38 <roconnor> wow
13:43:19 <acowley> mokus: so you just added the stdc++ library and didn't specify g++ or anything else?
13:43:25 <roconnor> developers seem to be focues on passing unit tests rather than making errors impossible.
13:43:34 <roconnor> *focused
13:43:43 <mokus> acowley: nope, didn't have to do anything too fancy
13:43:51 <copumpkin> roconnor: ?
13:44:16 <acowley> roconnor: the quantification of proof coverage is less believable than "99/99 tests passed!"
13:44:20 <roconnor> which is better (a) making a bunch of unit tests to make sure you never call an API improperly, or (b) redesigning the API so it can never be called imporperly.
13:44:27 <mokus> acowley: i'm not sure whether it's cabal, ghc, or gcc that figures out what I wanted, but something does
13:44:28 <EvanR-work> 'lol, thats why you unit test'
13:44:58 <acowley> mokus: then I shall try that! Google pointed me at this, which is frightening and outdated (a poor combination): http://stackoverflow.com/questions/2528887/c-compiler-selection-in-cabal-package
13:45:02 <EvanR-work> roconnor: too bad b isnt possible most popular systems
13:45:15 <roconnor> EvanR-work: even in Java it is possible.
13:45:17 * benmachine redesigns his AI to not include any entry points
13:45:20 <benmachine> er
13:45:22 <benmachine> API
13:45:26 <EvanR-work> roconnor: oh?
13:45:44 <mokus> acowley: I haven't tried it lately but I hear the same works for Objective-C sources too now, so someone appears to be putting effort into making this sort of thing easier
13:45:47 <roconnor> EvanR-work: didn't what's his name write about this on his blog this year?
13:45:53 <acowley> your AI is a narcissist
13:46:04 <EvanR-work> screw whats his name
13:46:06 <EvanR-work> and java
13:46:39 <erus`> i like ai
13:46:45 <erus`> my favorite is strong ai
13:47:06 <erus`> one day will will have strong ai for NPCs in oblivion
13:47:13 <erus`> or fallout3
13:47:19 <EvanR-work> youre being offensive
13:47:30 <Cale> Japanese people love AI.
13:47:36 <Cale> (sorry)
13:47:55 <erus`> i take no offense Cale
13:47:55 <monochrom> haskell people love intelligently designed API
13:48:21 <erus`> i like an API that has evolved over time into a masterpiece
13:48:31 <EvanR-work> or a trainwreck
13:48:36 <acowley> well I'll be a functional monkey
13:48:39 <Cale> I'm not sure how many people just got that pun, but I found it amusing, which is the main thing. ;)
13:48:40 <acowley> mokus: it worked!
13:48:46 <mokus> acowley: cool :)
13:48:48 <acowley> mokus: thanks so much for pulling be back from the cliff
13:49:03 <roconnor> EvanR-work: http://blog.tmorris.net/understanding-practical-api-design-static-typing-and-functional-programming/
13:49:15 <mokus> acowley: no problem, the real thanks go to whover made that work in the first place though
13:50:56 <monochrom> probably can't-be-used-wrong APIs for certain tasks must invovle inversion of control, which most programmers are uncomfortable with
13:51:20 <acowley> mokus: All credit to the marketer (you)! The engineers shall remain nameless!
13:51:26 <roconnor> monochrom: Care to expand on that comment?
13:51:31 <roconnor> sounds interesting
13:52:40 <EvanR-work> roconnor: good blog
13:52:46 <FredOverflow> @pl \x -> (f x, g x)
13:52:46 <lambdabot> liftM2 (,) f g
13:53:04 <roconnor> I forget tony's handle on #haskell
13:53:15 <monochrom> ah, like in Foreign.Marshal.Alloc, alloca is harder to use wrong than malloc+free
13:53:50 <monochrom> but alloca makes you submit a callback
13:53:53 <roconnor> EvanR-work: the tricky bit about C++ is that you can always produce garbage data by dereferencing an uninitialized pointer.
13:53:58 <ousado> it's dibble dabble dobblego
13:54:14 <kmc> no, callbacks are cool now
13:54:23 <FredOverflow> @type liftM2
13:54:24 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:54:24 <kmc> guys, did you hear that Javascript has closures???
13:54:35 <EvanR-work> roconnor: even in C i avoid pointers as data types used for the values of the api
13:54:36 <FredOverflow> JavaScript has always  had closures.
13:54:45 <leod> that's the joke?
13:54:56 * roconnor never understood what a closure means in a language with mutable variables.
13:55:11 <monochrom> callbacks are cool now and callbacks are still a fairly elite thing
13:55:17 <EvanR-work> roconnor: a procedure with a mutable environment ;)
13:55:28 <roconnor> EvanR-work: every data type you define will define a pointer to it data type.
13:55:39 <kmc> Haskell lets you close over reference cells as well...
13:55:42 <EvanR-work> roconnor: but i dont accept pointers
13:55:47 <EvanR-work> or return them
13:55:59 <kmc> the joke is that Reddit only discovered, like, last year that Javascript has closures, and got very excited about this 1930's technology
13:56:13 <roconnor> kmc: so that is how I should think about closures in other langauges?
13:56:31 <kmc> roconnor, i guess
13:56:31 <FredOverflow> Closures cover up much of JavaScript's ugliness.
13:56:42 <EvanR-work> not really
13:56:47 <kmc> closures are a useful primitive for implementing many other features
13:56:51 <edwardk> like spackle
13:56:52 <kmc> "lambda the ultimate"
13:56:59 <erus`> i think llvm machine code should be the default scripting language for browsers
13:57:05 <maurer_> Any reason why we don't seem to have something of the sort
13:57:11 <maurer_> bitCast :: (Bits a, Bits b) => a -> b
13:57:19 <maurer_> It seems super usefu
13:57:22 <maurer_> *useful
13:57:34 <monochrom> I think because we already have fromIntegral for the same thing in practice
13:57:52 <edwardk> erus`: there is nacl and the llvm bindings for that
13:58:14 <maurer_> edwardk: Hm? What's this about NaCl?
13:58:26 <maurer_> (just rejoined, and interested b/c I worked on the NaCl project last summer)
13:58:27 <roconnor> EvanR-work: sure, but in C/C++ can write { endgame *i;  PrintEndGameResult(i*) } and then I call up tech support and complain my programm is crashing using your library.
13:58:37 <roconnor> EvanR-work: I can't do this is Java.
13:58:50 <roconnor> well
13:58:50 <edwardk> maurer_: erus was saying he thought llvm should be the default browser scripting language
13:58:51 <roconnor> hmm
13:58:58 <roconnor> maybe if I start deserializing classes
13:59:02 <kmc> the other joke is that writing your async IO code in explicit callback style is hip and webscale, but people haven't caught onto the idea that this is something a high-level language should do for you
13:59:03 <maurer_> edwardk: I mean, that's the idea behind PNaCl
13:59:08 <edwardk> sure
13:59:17 <maurer_> edwardk: lli/llc are too slow atm though :(
13:59:20 <roconnor> Perhaps Tony has exagerated his Java safeness claims
14:00:09 <EvanR-work> roconnor: it says right here in the post that you cant stop people from doing X Y and Z in java, but oh well
14:00:19 <EvanR-work> null is a valid 'value' for... like everything in java
14:00:21 <erus`> edwardk: if firefox or chrome shipped it as standard the rest would soon follow
14:00:30 <erus`> and then haskell in the browser :D
14:00:37 <EvanR-work> not to mention 'reflection' facilities
14:00:46 <FredOverflow> I really like the fact that Haskell does not suffer from the "everything can be null" problem.
14:00:47 <roconnor> does he?
14:01:02 <EvanR-work> Unfortunately, in some environments, there’s not much I can do about enforcing that except impose a de facto rule where you assume non-existence of these possibilities (Just don’t do that!).
14:01:06 <maurer_> FredOverflow: Instead, we suffer from everything can be bottom
14:01:07 <roconnor> ah I see
14:01:11 <maurer_> (this is why we need -XSafe )
14:01:13 <EvanR-work> (which is what i do in javascript and php)
14:01:26 <roconnor> oh he even mentions Java reflection
14:01:28 <FredOverflow> maurer_: Is bottom an error or non-termination?
14:01:34 <maurer_> FredOverflow: error
14:01:36 <roconnor> oh good
14:02:53 <EvanR-work> roconnor: its (perhaps not) surprisingly difficult to get most js / php people to *not* use or do things that the system *can* do, especially when theyre stupid useless and harmful
14:03:20 <EvanR-work> what not to do
14:03:54 <Eduard_Munteanu> Hm? Some bottoms can very well be instances of non-termination.
14:03:54 <roconnor> js and php people do stupid useless things?
14:04:06 <Eduard_Munteanu> Well, at least that's how they're talked about in literature.
14:04:19 <roconnor> FredOverflow: bottoms are supposed to be equivalent to non-termination.
14:04:25 <ousado> EvanR-work: php?
14:04:27 <EvanR-work> roconnor: well if you arent familiar with it... we shouldnt even bring it up
14:04:40 <ousado> EvanR-work: I mean, for js there's an excuse
14:04:47 <roconnor> I didn't think it would be so bad
14:04:48 <EvanR-work> ousado: uhm, why
14:04:56 <erus`> thats it i'm making a plugin for firefox which executes haskell scripts in safe mod
14:05:01 <erus`> with access to the dom
14:05:21 <erus`> <script language="haskell">
14:05:35 <EvanR-work> script language=" is a joke
14:05:38 <kmc> i would *not* trust SafeHaskell just yet
14:05:42 <EvanR-work> might as well just be <javascript>
14:06:09 <erus`> IE has Jscript and VBscript
14:06:24 <erus`> Jscript has sockets and all sorts
14:06:33 <EvanR-work> thats frightening
14:06:39 <Eduard_Munteanu> It might find its place in a stack made up out of SafeHaskell + SELinux + cgroup + ulimit + virtualization + ... :)
14:06:50 <EvanR-work> roconnor: im interested in how to do this tic tac toe api where the type system stops you from doing what he describes
14:07:03 <ousado> EvanR-work: to use it, today, or at least to compile to it, there's an excuse, but not so for php
14:07:28 <roconnor> EvanR-work: he links to it: http://dl.dropbox.com/u/7810909/TicTacToe/javadoc/index.html
14:07:31 <erus`> EvanR-work: have different types for EmptyBoard FinishedBoard NotCompleteBoard
14:07:36 <erus`> etc
14:08:23 <EvanR-work> roconnor: i guess i can figure out the haskell by reading this
14:09:30 <roconnor> EvanR-work: he does hoops like: strictFold(X player1Wins, X player2Wins, X draw) to get around the fact that these languages echew sum types.
14:09:41 <erus`> actually im not sure how to wrap the DOM in haskell because it has inheritance
14:10:00 <roconnor> I swear that at least 50% of programming errors are due to the absence of proper sum types in C/C++/Java.
14:10:06 <EvanR-work> right
14:10:09 <EvanR-work> i fake it in js
14:11:21 <EvanR-work> roconnor: a sum type isnt enough to represent boards
14:11:24 <rostayob> roconnor: you mean + being overloaded in all sorts of way?
14:11:35 <roconnor> rostayob: nope
14:11:38 <rostayob> or you mean no monoid?
14:12:03 <rostayob> oh, no foldable
14:12:05 <roconnor> rostayob: I mean (tagged) disjoint union types.
14:12:32 <rostayob> roconnor: disjoint union type = ?
14:12:51 <roconnor> rostayob: Either is a protopical disjoint union type constructor in Haskell.
14:12:54 <monochrom> disjoint union type = data Hello = This | That | Moreover
14:13:05 <EvanR-work> roconnor: i cant tell what classes are namespaces and what are types
14:13:07 <rostayob> (I'm asking since "at least 50% of bugs are caused by this" is a big statement)
14:13:09 <rostayob> roconnor: ah.
14:13:45 <roconnor> rostayob: C has union types, but no enforcing of proper access
14:13:54 <rostayob> roconnor: yeah I was going to mention C unions
14:13:59 * Eduard_Munteanu wonders why "disjoint"
14:14:10 <rostayob> mah, I think that your percentage is a little bit too made up :P
14:14:11 <EvanR-work> mutually exclusive possibilities
14:14:13 <FredOverflow> What exactly is "Applicative f => f a"? Is it a function from a, to a or both? What would be an example of such an "f a"?
14:14:14 <roconnor> people are constantly inventing special values for data to pretend they are disjoin unions.
14:14:20 <EvanR-work> it cant be Nothing and Just 4 at the same time
14:14:38 <Eduard_Munteanu> Ah, yeah, but isn't that implied by it being a union/sum type?
14:14:45 <byorgey> FredOverflow: it is a value of type (f a), where a can be any type and f is required to be an instance of the Applicative class
14:15:02 <Eduard_Munteanu> Even a tagged one.
14:15:08 <roconnor> FredOverflow: some intepretations will consider that a function from an applicative functor f to f a
14:15:08 <byorgey> FredOverflow: a specific example would be something like  [1,2,3].  Here  a = Int  and f = []
14:15:29 <roconnor> FredOverflow: it is a polymorphic value that is polymorphic over all applicative functors.
14:15:55 <roconnor> FredOverflow: unless you are taking that bit of code out of context
14:15:56 <monochrom> "pure ()" is a value of type "Applicative f => f ()". it could become Just () or [()] or ... depending on which f you choose
14:16:10 <roconnor> @type pure ()
14:16:11 <lambdabot> forall (f :: * -> *). (Applicative f) => f ()
14:16:18 <byorgey> yeah, I don't think you could actually construct a value of type  Applicative f => f a
14:16:23 <byorgey> without using undefined
14:16:28 <Eduard_Munteanu> BTW, do you know any resource that gives a CT treatment of applicative functors?
14:16:31 <roconnor> rostayob: ya, it is a bit made up
14:16:35 <Eduard_Munteanu> s/of/for/
14:16:39 <byorgey> Eduard_Munteanu: the original paper on Applicative does so
14:16:49 <byorgey> Eduard_Munteanu: google for "Applicative Programming with Effects"
14:16:51 <Eduard_Munteanu> Ah, I'll look it up, thanks.
14:17:06 <JoeyA> Has anyone used phantom types to distinguish between compilation passes?
14:17:31 <JoeyA> e.g. data One; data Two; data Three; secondPass :: Pass One -> Pass Two
14:17:38 <FredOverflow> byorgey: Ah, so `f` is just a type constructor?
14:17:53 <monochrom> pascal sum type has a tag, but you can ignore the tag and just assume
14:18:01 <rostayob> roconnor: I'd tend to say that a lot of bugs are swept away by a good typing system, and haskel data types are part of that I guess
14:18:08 <JoeyA> as opposed to redefining the entire AST each time, or risking an invalid AST state from one pass to the next.
14:18:24 <roconnor> rostayob: :)
14:18:29 <byorgey> FredOverflow: yes
14:18:37 <FredOverflow> byorgey: I'm trying to understand liftA2, and the type signature baffles me.
14:18:40 <FredOverflow> @type liftA2
14:18:41 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:18:41 <roconnor> rostayob: they certainly help in making narrow APIs
14:19:08 <byorgey> FredOverflow: liftA2 takes a two-argument function of type (a -> b -> c), and turns it into a function (f a -> f b -> f c).
14:19:09 <EvanR-work> roconnor: well im lost with this java crap
14:19:12 <rostayob> roconnor: you can kind of emulate ADT with inheritance
14:19:15 <FredOverflow> byorgey: I don't understand what to pass as second and third arguments.
14:19:19 <roconnor> EvanR-work: ya
14:19:25 <byorgey> FredOverflow: furthermore, this works for any type constructor f, as long as there is an Applicative instance for f
14:19:47 <roconnor> EvanR-work: I fear his client will dismiss his software package even though it has such nice invarients.
14:19:56 <FredOverflow> byorgey: Ah, it becomes more obvious to me with additional parenthesis.
14:20:09 <kmc> Haskell-style data types would work in a dynamically typed language too, and nobody would have to learn the supposedly very hard rules of static typing
14:20:10 <byorgey> FredOverflow: here's an example:
14:20:10 <kmc> but for some reason this is very rare
14:20:10 <monochrom> http://www.vex.net/~trebla/humour/Nightmare.java emulates ADT with inheritance! and more!
14:20:10 <EvanR-work> roconnor: im returning to haskell now. and i hope im not permanently scarred by my experience with tony
14:20:19 <byorgey> > liftA2 (*) [2,3,4] [10,100,1000]
14:20:19 <lambdabot>   [20,200,2000,30,300,3000,40,400,4000]
14:20:26 <byorgey> in this case f = [], the list type constructor
14:20:29 <kmc> Python programmers love pattern-matching to unpack nested tuples but they don't ask for anything more
14:20:45 <byorgey> it multiplies elements from the two lists pairwise in all possible ways
14:20:56 <EvanR-work> kmc: js has pattern matching now! not really
14:21:09 <byorgey> > liftA2 (*) (Just 3) (Just 4)
14:21:09 <lambdabot>   Just 12
14:21:10 <EvanR-work> it can unpack nested arrays
14:21:15 <byorgey> > liftA2 (*) Nothing (Just 4)
14:21:16 <lambdabot>   Nothing
14:21:19 <EvanR-work> if it happens to be in that format
14:21:24 <FredOverflow> byorgey: I guess I have to understand the list monad to really understand why it computes the pairwise combinations?
14:21:33 <kmc> $(hot new mainstream language) has $(40-year-old FP feature) now!  not really
14:21:36 <byorgey> FredOverflow: well, the Applicative instance for lists
14:21:42 <EvanR-work> kmc: lol
14:21:44 <EvanR-work> yes
14:21:44 <acowley``> Suppose I have a polymorphic function f that calls another polymorphic function g, and I add a SPECIALIZE pragma on f. Will GHC also generate a suitably specialized version of g automatically?
14:21:48 <byorgey> FredOverflow: but it is closely related to the list monad
14:22:03 <kmc> though i wonder if C++1x will ever become "mainstream"
14:22:11 <kmc> the number of people who care about C++ is dwindling, and with good reason
14:22:24 <byorgey> FredOverflow: did you see liftA2 used in some particular place?
14:22:24 <FredOverflow> byorgey: What do I have to say to lambdabot to see the list instance for Applicative?
14:22:31 <Somix> hey guys ... so I've been reading up on monads, and one interpretation of List is that of non-deterministic computation. This seems strange though - in this context I don't see why we would care about exact order of results, as suggested by ordered list. Wouldn't some kind of Set be more appropriate?
14:22:33 <EvanR-work> hopefully it has something to do with the degree to which i flame c++ on an hourly basis
14:22:34 <byorgey> @src Applicative []
14:22:34 <lambdabot> Source not found.
14:22:39 <byorgey> @src [] Applicative
14:22:39 <lambdabot> Source not found. My brain just exploded
14:22:48 <byorgey> FredOverflow: heh, I don't know =)
14:22:52 <monochrom> probably not on lambdabot at all
14:22:56 <kmc> Somix, yeah, but (for a variety of technical reasons) it's hard to implement Monad for Set in Haskell
14:22:57 <acowley> Somix: Sets are problematic due to the need for an Ord constraint
14:23:18 <byorgey> FredOverflow: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Applicative.html#Applicative
14:23:18 <monochrom> lambdabot's @src answers are hand-written and quite old
14:23:24 <EvanR-work> would Eq constraint be better?
14:23:27 <kmc> Somix, btw, http://hackage.haskell.org/package/control-monad-omega and http://hackage.haskell.org/package/logict are arguably better monads for nondet.
14:23:32 <byorgey> FredOverflow: you may also be interested in reading the Typeclassopedia
14:23:33 <Eduard_Munteanu> Ord is faster I think.
14:23:35 <byorgey> @where typeclassopedia
14:23:36 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
14:23:38 <FredOverflow> @src Functor
14:23:38 <lambdabot> class  Functor f  where
14:23:38 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:23:39 <kmc> what's nice is that you can use MonadPlus as a generic interface to all of them
14:23:43 <EvanR-work> Eduard_Munteanu: yes
14:23:47 <EvanR-work> but i mean for the purposes of monad
14:24:12 <Eduard_Munteanu> Yeah, I think so.
14:24:21 <kmc> Somix, also, sometimes you do care about the order in which elements come out of a list computation
14:24:32 <kmc> nondeterminism is only one interpretation for the list monad
14:24:49 <EvanR-work> funny 'the' list monad ;)
14:24:52 <kmc> note that there's a simple 1:1 translation between list comprehensions and "list monad" code using "do"
14:26:42 * roconnor thinks of Applicative as a way to get all higher numbered lifts in one go.
14:26:43 <erus`> which one is the real life?
14:26:56 <monochrom> this one
14:27:36 <roconnor> BTW, every value of Applicative f => f a is of the form pure f <*> x <*> y <*> ... <*> z
14:27:37 <EvanR-work> > fmap even [1,2,3,4]
14:27:38 <lambdabot>   [False,True,False,True]
14:27:56 <roconnor> (assuming the applicative functor laws are followed)
14:27:56 <EvanR-work> > [1,2,3,4] >>= even
14:27:57 <lambdabot>   Couldn't match expected type `[b]'
14:27:57 <lambdabot>         against inferred type `GHC.Bool....
14:28:14 <copumpkin> roconnor: mokus made the bug even shorter :)
14:28:16 <roconnor> (and assuming fast and loose reasoning)
14:28:23 <monochrom> w00t, canonical form? haven't seen one in a while :)
14:28:25 <Eduard_Munteanu> > [1,2,3,4] >>= return . even
14:28:25 <roconnor> copumpkin: link
14:28:28 <lambdabot>   mueval-core: Time limit exceeded
14:28:40 <copumpkin> roconnor: http://code.google.com/p/agda/issues/detail?id=444#c6
14:28:49 <Eduard_Munteanu> Ah.
14:29:02 <roconnor> copumpkin: oh good
14:29:04 <monochrom> hahaha false-golfing
14:29:09 <roconnor> I felt something like that had to be possible
14:29:23 <copumpkin> yay, false is true
14:29:26 <copumpkin> now I can have nice things
14:29:43 <roconnor> I'm glad the the record system wasn't needed
14:29:53 <monochrom> I don't know agda. what does that code mean?
14:30:10 <roconnor> clearly someone implementing proof-irrelevence wasn't compentent enough to do so.
14:30:45 <mokus> it means, essentially, "because false, false", where the first false is irrelevant - meaning that it gets erased at compile time - but the second is "real"
14:31:19 <roconnor> copumpkin: now the code is almost the same as the Coq code that used to prove false.
14:31:22 <mokus> the "relevant" function establishes that an irrelevant falsity is still a contradiction
14:31:24 <copumpkin> sweet
14:31:44 <acowley``> What does the dot prefix on the type mean?
14:31:49 <EvanR-work> so the [] Monad instance does not agree with the fmap instances
14:31:49 <copumpkin> irrelevant
14:31:55 <copumpkin> it's the key ingredient here
14:32:06 <acowley> I see
14:32:15 <EvanR-work> Functor
14:32:15 <copumpkin> normally you can prove false
14:32:17 * acowley goes back to Prop
14:32:26 <copumpkin> but it'll mark it as non-terminating for you
14:32:35 <copumpkin> false : bottom
14:32:36 <copumpkin> false = false
14:32:54 <copumpkin> but if you send it through the evil relevant function, it stops being able to see the non-termination
14:33:05 <acowley> I assume it checks somewhat carefully that your manual irrelevance annotations are correct?
14:33:21 <copumpkin> it checks that irrelevant things don't leak
14:33:41 <monochrom> what does the line "relevant ()" say?
14:33:46 <copumpkin> the issue is that it discards irrelevant things immediately, and then runs the termination checker, and then the termination checker doesn't see that false called itself (because it was discarded)
14:33:53 <copumpkin> monochrom: that's an absurd pattern match
14:33:54 <acowley> monochrom: impossible pattern
14:33:59 <JoeyA> "<JoeyA> Has anyone used phantom types to distinguish between compilation passes?"  For example: http://hpaste.org/50857
14:34:11 <mokus> 'relevant ()' says there is no pattern that can match the first argument
14:34:30 <copumpkin> you could also think of it as a way to write the empty function
14:42:14 <siracusa> I'm trying to build a cabal package and are getting "Not in scope: `programDefaultArgs'" on "cabal configure". Is that a function only available in newer Cabal versions?
14:43:45 <dcoutts> siracusa: yes, previously there was just programArgs, now that's split into pre and post args
14:44:04 <dcoutts> siracusa: as in: run prog (pre ++ args ++ post)
14:44:29 <siracusa> And is there a way to work-around?
14:45:20 <dcoutts> siracusa: do you really need to specify these args?
14:45:44 <siracusa> No idea, it's from a git repo
14:46:39 <dcoutts> e.g. can you just use the Program abstraction rather than using ConfiguredProgram
14:47:05 <dcoutts> it's not normal to construct a ConfiguredProgram directly
14:48:21 <siracusa> It's used in a pattern match to extract the arguments
14:48:35 <dcoutts> siracusa: are you just trying to get it to build yourself or are you trying to make it portable?
14:49:00 <siracusa> I'm just trying to build it to modify the cod afterwards
14:49:03 <siracusa> *code
14:50:01 <dcoutts> then since it sounds like you're using an older Cabal lib, probably 1.8, you'd have to change it to programArgs
14:50:15 <dcoutts> siracusa: or you could build this thing using Cabal-1.10
14:51:51 <siracusa> dcoutts: So there's no problem installing two Cabal versions in parallel?
14:52:57 <dcoutts> siracusa: not usually
14:53:21 <RenJuan> whaaa?
14:53:39 <RenJuan> in the same account?
14:54:16 <dcoutts> RenJuan: talking about having multiple versions of packages installed?
14:54:42 <RenJuan> no duplicate install (rather than upgrade) of cabal
14:55:09 <dcoutts> RenJuan: oh I was referring to the Cabal library, not the cabal command line tool
14:55:50 <RenJuan> ah. I still see it as one bolus of function at this point.
14:58:00 <RenJuan> which I suddenly realize probably bears more sponsitility for the haskell pkg SNAFU than i've heretofore assigned to it
15:03:31 <acowley> I have what is most likely a stupid question. I want to write instance (Num (Foo a)) => Bar (T a) where
15:03:39 <acowley> where Foo a is an associated type
15:03:52 <acowley> but this needs UndecidableInstances
15:04:12 <acowley> is there a way around this?
15:04:59 <kmc> no
15:05:05 <kmc> UndecidableInstances is fine though
15:05:27 <edwardk> erus': sadly firefox rejected the idea outright
15:05:40 <acowley> What are the downsides to UndecidableInstances?
15:05:49 <kmc> your compiler might go into an infinite loop
15:05:52 <kmc> except it won't
15:05:57 <kmc> GHC won't anyway
15:06:05 <kmc> because it has a fixed stack depth for context resolution
15:06:28 <kmc> it's a safe extension; it doesn't actually screw with the type system or runtime behavior
15:06:57 <benmachine> kmc: is it possible to loop without increasing the stack depth?
15:07:03 <kmc> no
15:07:15 <benmachine> I mean, I know the inliner can loop, but only in obscure examples that no-one can be bothered to fix
15:07:22 <acowley> Okay, thanks. I suppose I'd be in trouble if I had multiple associated types Foo a
15:07:29 <kmc> languages like C++ and Lisp allow unrestricted compile-time computation; so does Template Haskell
15:07:43 <acowley> Hm. Actually I'm not sure why that would be a problem
15:07:54 <kmc> in those contexts nobody is too surprised that sometimes you can crash the compiler or put it into an infinite loop
15:12:10 <hpaste> commanace pasted “connecting to udisks signal” at http://hpaste.org/50858
15:12:38 <commanace> hi, is anyone familiar with the dbus-core package? I was trying to connect to a signal raised by the udisks service as shown in the link above
15:13:20 <commanace> result is: no output. however i did verify that the signal gets raised with dbus-monitor
15:14:07 <commanace> thus i think the mistake has to be somewhere in my code. unfortunately, the documentation for dbus-core is not exactly dense :)
15:14:32 <Olathe> What is codata?
15:14:45 <Olathe> Google is really not helping on this.
15:15:03 <c_wraith> codata is data that doesn't necessarily have a base case.
15:15:24 <c_wraith> an example is the common Stream type:  data Stream a = Cons a (Stream a)
15:15:36 <c_wraith> nevermind that Haskell still uses the data keyword for codata :)
15:16:33 <Olathe> Ahh, OK. Thanks.
15:16:36 <kmc> to my (poor) understanding, the difference only matters if you want to prove termination.  because the usual criteria for termination of functions operating on data differs from the criteria for functions operating on codata
15:17:16 <kmc> terminating data recursion looks like «f (C x) = f x»; productive codata recursion looks like «f x = C (f x)»
15:17:29 <c_wraith> technically, it's corecursion over codata. :)
15:17:31 <c_wraith> but yes
15:17:56 <kmc> heh, ok
15:19:46 <copumpkin> it does seem kind of redundant
15:19:50 <copumpkin> since you can't recurse over codata
15:20:03 <copumpkin> or corecurse over data
15:20:06 <copumpkin> I can write take : Nat -> Stream -> List
15:20:15 <copumpkin> but that's just recursion over the data in the nat
15:20:16 <copumpkin> rather than corecursion over the stream
15:26:49 <hpaste> int80_h pasted “please give example of a full  MVar” at http://hpaste.org/50859
15:29:26 <parcs> int80_h: full means that is has a value inside of it
15:29:32 <jmcarthur> int80_h: a full MVar is just an MVar with something in it
15:29:52 <jmcarthur> int80_h: so if you have an empty MVar and then use putMVar on it, now you have a full MVar
15:30:20 <jmcarthur> int80_h: it becomes empty again when you use takeMVar
15:30:36 <acowley`> vector-space really is a fantastic package
15:30:40 <jmcarthur> acowley: indeed
15:30:56 <int80_h> ah, gotcha
15:31:05 <djahandarie> I recall it having too complicated of a Vec implementation for my purposes though
15:31:06 <acowley> I use it so much, and love the fact that using it makes my code better
15:31:11 <kmc> i'm thinking of doing a blog post series highlighting one package from Hackage per day
15:31:21 <kmc> with just a quick writeup on what it's good for and why i like it
15:31:26 <acowley> it's usually too complicated, but almost always in a good way!
15:31:29 <jmcarthur> i find myself using AffineSpace a lot
15:31:33 <int80_h> okay I think my use case may be convoluted due to not understanding how best to use MVars. I will post my use case and ask for feedback
15:31:38 <kmc> do you think this would be valuable? how should i go about it?
15:31:48 <jmcarthur> kmc: quite valuable
15:31:55 <acowley> jmcarthur: for what kind of thing?
15:31:56 <djahandarie> kmc, valuable, but sounds like a lot of work
15:31:59 <jmcarthur> i think others have proposed doing similar things and failed to follow through
15:32:02 <kmc> heh
15:32:14 <c_wraith> Are AffineSpaces the ones that have an operation like "difference :: a -> a -> b"?
15:32:15 <acowley> kmc: one per day is too fast
15:32:23 <acowley> kmc: make it at most 2 or 3 times a week
15:32:25 <int80_h> one per week maybe
15:32:29 <jmcarthur> acowley: anything to do with time or space, which i do a lot
15:32:30 <acowley> yeah, I'd go weekly
15:32:33 <kmc> too fast for the author, or for readers?
15:32:34 <benmachine> c_wraith: I heard that an affine space is a vector space where you forget where zero is
15:32:42 <jmcarthur> weekly, yes
15:32:45 <int80_h> for the author
15:32:51 <aavogt> maybe just as useful would be to contribute better descriptions/examples to their .cabal files
15:32:52 <c_wraith> kmc: readers, mostly.  though you'd appreciate it being slower, too
15:32:59 <kmc> yeah
15:33:00 <acowley> djahandarie: do you remember what trouble you had with vector-space?
15:33:13 <kmc> i want these to be pretty short articles though
15:33:36 <int80_h> better to write something with some depth than truncated because you have to get on to the next one
15:33:39 <jmcarthur> benmachine: that is a reasonable intuition
15:33:41 <acowley> kmc: too fast for the reader, plus you might end up missing a day here and there if you try to do it every day. Web comics have shown how important regularity is
15:34:07 <int80_h> or, do a month's worth ahead of time, then release one per day
15:34:08 <djahandarie> acowley, the trouble was that I didn't want vector spaces :p
15:34:16 <int80_h> giving you a lead for the next batch
15:34:22 <kmc> have they?
15:34:22 <kmc> yeah, i would build up a buffer for sure
15:34:40 <acowley> djahandarie: you should always want vector spaces
15:34:41 <kmc> i thought RSS was supposed to decrease the importance of keeping a regular schedule
15:34:42 <kmc> i'm not sure irregular comics actually get less readership, all else equal
15:35:34 <djahandarie> acowley, why? Fields are evil :)
15:36:47 <acowley> djahandarie: Fair enough. I don't believe in division.
15:37:35 <djahandarie> My problem with fields is that they are categorically ugly. It's much nicer working with things like RMod and such
15:38:12 <acowley> what's RMod? Rationals modulo?
15:39:19 <djahandarie> Nope, category of R-modules
15:40:11 <djahandarie> RMod == Ab(CRing / R)
15:40:11 <acowley> oh, so it's basically a vector space! :P
15:41:35 <copumpkin> moar generul
15:41:41 <copumpkin> den vectur speces
15:41:58 <copumpkin> hu needz feeldz
15:42:23 <rwbarton> post to lolcategories
15:42:51 <shmooooo> hello, I am trying to make a circular linked list: data USL a = USLNode a (USL a) | USLEmpty; my function to generate this circular list from a regular list is uslFromList xs = foldr USLNode h xs where {h = foldr USLNode h xs;}. I'm wondering if this is properly circular, or if chasing the next element would use up more and more memory.
15:42:51 <rwbarton> djahandarie: what is that last statement saying? it looks familiar
15:42:56 <copumpkin> @quote moarphisms
15:42:56 <lambdabot> tensorpudding says: lolcategory demands moarphisms
15:43:26 <djahandarie> rwbarton, Ab(CRing / R) in plain English is "the category of abelian group objects in the overcategory of CRing over R"
15:43:45 <djahandarie> ...maybe not plain English. :)
15:43:45 <benmachine> shmooooo: I'm confused; isn't your type exactly the same as the list type?
15:43:54 <Eduard_Munteanu> Heh.
15:43:55 <rwbarton> is this using the R+M construction
15:44:05 <acowley> djahandarie: you might as well have ended with "... what's the problem?"
15:44:14 <benmachine> shmooooo: (to answer your question, I *think* your list is genuinely circular... but if you e.g. map a function over it it won't be anymore)
15:44:15 <rwbarton> actually, I still don't see how that is true
15:44:19 <djahandarie> Not sure what the R+M construction
15:44:22 <djahandarie> is
15:44:34 <djahandarie> R \in CRing btw
15:44:45 <acowley> isn't slice category more common terminology?
15:44:47 <rwbarton> an R-module doesn't come with a map to R, so I'm not sure what the identification between an R-module and anything in CRing/R is
15:45:05 <shmooooo> benmachine: thank you
15:45:09 <rwbarton> overcategory is easier to remember which way it goes :)
15:45:21 <ion> shmooooo: uslFromList xs = h where { h = foldr … h xs } i guess. Or uslFromList xs = fix (\h -> foldr … h xs)
15:45:57 <benmachine> oh, yeah, ion has a point
15:47:08 <djahandarie> rwbarton, I'm not sure I see the problem
15:47:36 <rwbarton> okay, let's take an example, say R = Q (the rationals)
15:47:53 <rwbarton> which abelian group object in CRing / Q corresponds to the 0 module?
15:49:06 <rwbarton> (a related question is, what product are you using on CRing / Q)
15:50:26 <djahandarie> The tensor product of commutative rings, I imagine
15:50:48 <djahandarie> Let me think about that question though, haven't actually tried working out that definition before...
15:53:37 <djahandarie> I imagine the same problem arises even when you're just doing CRing/R to get the category R-CAlg of commutative associative algebras over R
15:53:41 <rwbarton> I think you may want R/CRing... that's sort of a better category anyways
15:53:52 <rwbarton> right R/CRing is exactly R-CAlg
15:54:19 <djahandarie> I've definitely seen a proof of what I said earlier, let me try to look for it
15:55:06 <rwbarton> to an R-module you can associate the R-algebra R (+) M (direct sum) where the product of two things in the M factor is 0
15:55:38 <monk__> is there a library which basically implements all the prelude IO actions but with their type as MonadIO m => m a instead of IO a ?
15:56:15 <monk__> I suppose it would be a complete pain in the butt to hide that much of prelude.
15:56:28 <chomp> so i'm just learning haskell and i'm kind of stumped trying to construct an elegant binary string parser (e.g., "100101" -> 37)
15:57:19 <rwbarton> djahandarie, and I'm sure there is some way you can reconstruct RMod from R-CAlg by taking something like the category of commutative monoid objects w.r.t. some product, I just don't remember the details
15:57:42 <monochrom> can you first write a binary list parser e.g. [1,0,0,1,0,1] -> 37?
15:57:57 <djahandarie> rwbarton, that is exactly what we're trying to do here, no?
15:57:59 <chomp> if i could this would be easy :)
15:58:04 <rwbarton> yes
15:58:15 <djahandarie> Trying to figure out the details and failing
15:58:27 <djahandarie> rwbarton, http://ncatlab.org/nlab/show/module see 'In terms of stabilized overcategories'
15:58:34 <monochrom> use an auxiliary parameter for state
15:58:42 <rwbarton> right, the stabilization was in the statement I remembered
15:59:00 <rwbarton> hrm
15:59:01 <ion> > > foldl' (\acc x -> acc*2 + digitToInt x) 0 "100101"
15:59:01 <lambdabot>   <no location info>: parse error on input `>'
15:59:02 <ion> > foldl' (\acc x -> acc*2 + digitToInt x) 0 "100101"
15:59:03 <lambdabot>   37
15:59:04 <tgeeky> chomp: if I give you an "Arbitrary" binary string, what can you do to each element, one by one, to turn that string into an equation which produces 37
15:59:14 <rwbarton> oh interesting
15:59:17 <djahandarie> rwbarton, I actually don't really understand this proof, maybe you do
15:59:18 <tgeeky> chomp: they gave you the answer
15:59:32 <chomp> ion, doh... that's it
15:59:33 <copumpkin> > iterate (*2) 1
15:59:34 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:59:38 <tgeeky> chomp: but the 1 or 0 represnt raising something to a power of 2
16:00:01 <copumpkin> > sum $ zipWith (*) (reverse [1,0,0,1,0,1]) (iterate (*2) 1)
16:00:02 <lambdabot>   37
16:00:03 <tgeeky> chomp: and there's the generator for that :o
16:00:29 <copumpkin> @let listy d = sum $ zipWith (*) (reverse d) (iterate (*2) 1)
16:00:31 <lambdabot>  Defined.
16:00:33 <hpaste> int80_h pasted “use case for an MVar” at http://hpaste.org/50860
16:00:34 <tgeeky> chomp: and there is the expression which uses the generator (and reverse the list, so the smallest power is first)
16:00:36 <copumpkin> > listy [1,1,1,1,1,1]
16:00:36 <jonkri> anyone got a "getFileStatus: does not exist (No such file or directory)" error in eclipsefp? it says "<< {"id":15,"method":"background-typecheck-file","params":{"file":"/home/jonkri/Workspace/pontarius-xmpp/Source/Network/XMPP.hs"}} >> {"id":15,"error":{"message":": getFileStatus: does not exist (No such file or directory)","name":"CommandFailed"},"version":"0.1"}" but the mentioned file exists
16:00:38 <lambdabot>   63
16:01:06 <tgeeky> and there's a function that should be a 'maximum' bound for a particular string length
16:01:11 <chomp> tgeeky, yeah i can take it from there.  thanks. my single oversight was that i can simply accumulate sum*2 + nextdigit
16:01:18 <tgeeky> chomp: oh yeah
16:01:25 <tgeeky> hehe :)
16:01:31 <copumpkin> chomp: or just do it my way, and don't bother accumulating explicitly
16:01:37 <tgeeky> yes
16:01:58 <chomp> ah zipWith
16:02:00 <chomp> that's handy.
16:02:06 <copumpkin> the reverse is kind of ugly though, I admit
16:02:25 <tgeeky> no, it just reflects endianness, right?
16:02:30 <copumpkin> bit order
16:03:15 <tgeeky> copumpkin: same function, base 3? 6?
16:03:26 <rwbarton> djahandarie, I'm not sure there is any particularly good high level way to understand this proof without going through and checking all the details (some of which seem to be left out)
16:03:32 <ion> Change the *2. In both my and copumkin’s code.
16:03:42 <djahandarie> Mmm
16:03:45 <ion> Change it to *base and add base as a parameter.
16:03:49 <tgeeky> ion: and then, base (-3)
16:04:06 <tgeeky> that's different, no?
16:05:03 <tgeeky> @let listyB d = sum $ zipWith (*) (reverse d) (iterate (negate . times 2) 1)
16:05:03 <lambdabot>  <local>:4:60: Not in scope: `times'
16:05:11 <chomp> well i really only need binary, octal, hex and dec.  for the latter three we have readOct readHex and read
16:06:14 <ion> Not that it makes sense, but both work identically:
16:06:15 <ion> > let f base = foldl' (\acc x -> acc*base + x) 0; f' base xs = sum $ zipWith (*) (reverse xs) (iterate (*base) 1) in (f (-3) [2,1,0,-1], f' (-3) [2,1,0,-1])
16:06:16 <lambdabot>   (-46,-46)
16:07:06 <Jafet> What about complex bases
16:07:11 <tgeeky> no :o
16:07:20 <tgeeky> i mean, not for me :O
16:07:44 <ion> > let f base = foldl' (\acc x -> acc*base + x) 0 . map digitToInt in f 16 "b00b5"
16:07:45 <lambdabot>   721077
16:07:47 <Jafet> CSurreal
16:07:53 <djahandarie> rwbarton, by the way, you should join ##categorytheory if you don't know about it
16:08:27 <rwbarton> djahandarie: well anyways the important part of the proof is the construction M -> R (+) M from RMod to Ab(CRing/R), and the second sentence of the proof shows more or less how you can reverse it
16:08:59 <tgeeky> > iterate (*(negate 3)) 1)
16:08:59 <lambdabot>   <no location info>: parse error on input `)'
16:09:04 <rwbarton> using the unit morphism, which I hadn't considered... and showing that the map to R on the M factor is always 0
16:09:09 <tgeeky> > iterate (*3) 1)
16:09:10 <lambdabot>   <no location info>: parse error on input `)'
16:09:18 <tgeeky> whoops
16:09:19 <tgeeky> wrong chat
16:09:34 <chomp> what's the difference between foldl and foldl'
16:09:47 <chomp> it's awfully hard to search for fold' :(
16:09:53 <tgeeky> chomp: foldl' ignores the part of the result
16:09:53 <chomp> foldl' rather
16:09:53 <ion> @src foldl'
16:09:53 <lambdabot> foldl' f a []     = a
16:09:53 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:09:59 <ion> @src foldl
16:09:59 <lambdabot> foldl f z []     = z
16:09:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:09:59 <tgeeky> I think?
16:10:12 <Jafet> chomp: your haskell library manual?
16:10:15 <ion> http://www.haskell.org/hoogle/?hoogle=foldl%27
16:10:15 <Jafet> @index foldl'
16:10:16 <lambdabot> Data.List
16:10:47 <chomp> "a strict version of foldl" o_O
16:11:43 <Jafet> It will whip your bottoms
16:12:15 <ion> Evaluating the fold for the given list item forces the application of your function instead of growing a huge thunk.
16:13:23 <tgeeky> so would a proficient haskeller be expected to know NBG set theory?
16:13:38 <tgeeky> or ZF, for that matter
16:14:07 <chomp> ah i see, the wiki explains it in further detail.  thanks ion
16:14:13 <Jafet> A proficient haskeller would be expected to forget ZF
16:14:53 <tgeeky> Jafet: and NBG?
16:15:00 <tgeeky> I have read http://metu.edu.tr/~dpierce/Mathematics/Numbers/
16:15:01 <monochrom> yeah, forget ZF and learn ZFC!
16:15:26 <tgeeky> and wonder if the concepts in there (he doesn't explicitly discuss NBG, but I think he implicitly does)
16:15:35 <ion> chomp: This should demonstrate how foldl behaves. Alas, stepeval doesn’t seem to support seq or foldl'. http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldl+%28%5Cacc+x+-%3E+acc*10+%2B+x%29+0+%5B4%2C3%2C2%2C1%2C0%5D
16:15:44 <tgeeky> are translatable into Haskell, (and if they have been so translated)
16:15:54 <tgeeky> I presume they are translatable.
16:16:10 <chomp> yep, that makes sense
16:16:35 <ion> I.e. it generates the thunk for ((((0 * 10 + 4) * 10 + 3) * 10 + 2) * 10 + 1) * 10 + 0 before evaluating that.
16:19:10 <kmc> tgeeky, i don't think axiomatic set theory is that relevant to Haskell
16:19:16 <kmc> (why NBG, by the way?)
16:19:33 * kmc is a fan of NF, on aesthetic grounds, but hasn't totally absorbed how it relates to ZFC etc
16:19:36 <Phyx-> hi, does anyone know if this is QuickCheck 2.0 or 1.0? http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html
16:19:47 <rwbarton> tgeeky, I would say that a proficient mathematician is not expected to be able to list the axioms of ZFC/NBG/whatever, and also that haskellers would tend to be on the "structural" side of the "structural vs. material set theory" question
16:20:02 <rwbarton> (http://ncatlab.org/nlab/show/set+theory#axiomatic_set_theory_10)
16:20:08 <kmc> i have the axioms of ZFC on a laminated card in my wallet
16:20:12 <kmc> just in case
16:20:42 <djahandarie> I thought you would have tattooed them
16:20:46 <tgeeky> rwbarton: kmc: if you'd humor me and read the 6-page "why I wrote this paper" note (that's the middle link), he explains why he constructs what he constructs (I think he uses some techniques that are used in NBG)
16:20:49 <djahandarie> You can always lose your wallet
16:21:25 <Jafet> djahandarie: what if ZFC is found to be inconsistent
16:21:36 <djahandarie> IMPOSSIBLE!
16:21:46 <benmachine> kmc: <3
16:22:03 <benmachine> I want to do that now
16:22:12 <benmachine> ...do you have to write quite small? >_>
16:22:22 <Jafet> Just don't use any words
16:22:42 <tgeeky> But he seems to be using tricks that are "universal" in some sense -- as he constructs something that has the properties of: Axiom of Infinity, Axiom of Foundation, -- but without invoking those axmioms directly.
16:23:35 <tgeeky> kind of strange.
16:23:52 <int80_h> http://hpaste.org/50860
16:24:10 <ion> phyx: It’s for *some* older version. It’s at least missing ‘shrink’ in Arbitrary.
16:24:29 <tgeeky> it reminds me of the idea of fold/unfold and fold fusion and the "universal" priciple
16:24:58 <Phyx-> ion: hmm ok, I'm having trouble finding some up to date documentation. Guess i'll just look at the examples in the package
16:25:01 <Phyx-> thanks
16:25:14 <ion> phyx: I’ve been quite happy with QuickCheck’s haddock documentation.
16:25:52 <Phyx-> ion: That's the one thing i hadn't looked at. thanks again!
16:25:53 <ion> phyx: As a reference, though, not a tutorial.
16:26:11 <Phyx-> well, I already know quickcheck, just haven't used it in ~a year
16:31:47 <sm> dcoutts: in june, with an older cabal-install, I did "remove all Setup.hs, cabal no longer needs them and helps haddock". But latest cabal seems to need them again :/ Or is it hackage ?
16:32:28 <dcoutts> sm: the cabal tool does not require a Setup.hs to function
16:32:42 <dcoutts> sm: hackage has always required a Setup.hs in the uploaded tarball
16:33:06 <sm> ok, I see, thanks
16:33:09 <dcoutts> cabal sdist will automatically put a Setup.hs in the tarball
16:33:12 <sm> back they go
16:33:27 <sm> uh.. cabal upload too ?
16:33:42 <dcoutts> no, cabal upload does not modify the tarball
16:34:03 <dcoutts> cabal sdist is one convenient way to make tarballs to upload, but you can do it other ways too
16:34:19 <sm> I see. I always just to cabal check, cabal upload
16:34:22 <sm> do
16:34:30 <sm> so I'll put them back
16:34:45 <dcoutts> how do you generate the tarball?
16:35:30 <Igloo> Does/should cabal check complain about lack of Setup.hs?
16:36:19 <dcoutts> Igloo: it does check, yes
16:36:41 <Igloo> OK, cool
16:37:26 <sm> dcoutts: I don't, I just cabal upload
16:37:52 <sm> ohh, sorry of course I do
16:39:25 <sm> cabal check complains when there's no Setup.hs in the project dir, even though sdist has added one to the tarball
16:39:35 <dcoutts> right
16:39:55 <dcoutts> it wouldn't be unreasonable to mention in the cabal check output that this is ok if you're using cabal sdist
16:40:46 <acowley> can I have type kinds today? I think every piece of code I write these days wants them
16:44:54 <int80_h> > data ServerModel = SSLVPN
16:44:54 <int80_h> >                  | SPAM
16:44:54 <int80_h> >                  | WEBFILTER
16:44:54 <int80_h> >                  | CUDATEL
16:44:54 <int80_h> >                  | BALANCER
16:44:55 <lambdabot>   <no location info>: parse error on input `|'
16:44:55 <lambdabot>   <no location info>: parse error on input `data'
16:44:55 <lambdabot>   <no location info>: parse error on input `|'
16:44:55 <lambdabot>   <no location info>: parse error on input `|'
16:44:55 <lambdabot>   <no location info>: parse error on input `|'
16:44:56 <int80_h> >                     deriving Show
16:44:57 <lambdabot>   <no location info>: parse error on input `deriving'
16:44:59 <int80_h> > type Cookie = String
16:44:59 <lambdabot>   <no location info>: parse error on input `type'
16:45:01 <int80_h> > data ProcessState = PS { processing :: ServerModel -> FilePath -> IO ()
16:45:02 <lambdabot>   <no location info>: parse error on input `data'
16:45:04 <int80_h> >                        , jobs :: Int
16:45:04 <lambdabot>   <no location info>: parse error on input `,'
16:45:06 <int80_h> >                        }
16:45:07 <lambdabot>   <no location info>: parse error on input `}'
16:45:09 <int80_h> >
16:45:11 <int80_h> > data ProcessConfig = PC { model :: ServerModel
16:45:12 <lambdabot>   <no location info>: parse error on input `data'
16:45:14 <int80_h> >                         , ipAddress :: String
16:45:15 <lambdabot>   <no location info>: parse error on input `,'
16:45:16 <int80_h> >                         , rootDirectory :: FilePath
16:45:17 <lambdabot>   <no location info>: parse error on input `,'
16:45:18 <ddarius> Some kick int80_h .
16:45:19 <int80_h> >                         , cookie :: Cookie
16:45:19 <lambdabot>   <no location info>: parse error on input `,'
16:45:22 <int80_h> >                         } deriving Show
16:45:22 <lambdabot>   <no location info>: parse error on input `}'
16:45:22 --- mode: ChanServ set +o copumpkin
16:45:24 <int80_h> esh...sorry
16:45:27 <int80_h> not doing it at this point
16:45:35 --- mode: copumpkin set -o copumpkin
16:46:05 <Jafet> If you're writing a unix daemon, it's probably fine to write it like other unix daemons
16:46:11 <Jafet> But only if.
16:47:11 <rwbarton> tgeeky: it seems to me that the main point of that paper is to examine the axioms required for the existence of free algebras in a set theory
16:47:28 <rwbarton> tgeeky: but in haskell, we effectively take the existence of free algebras as an axiom itself
16:47:50 <rwbarton> we certainly don't construct them out of "sets" which are equipped with a global membership predicate
16:48:14 <rwbarton> that's why I say that this "material set theory" is not very relevant to haskell
16:48:25 <copumpkin> some might even say it's immaterial
16:49:07 <rwbarton> copumpkin, sounds like pointless topology :)
16:51:12 <copumpkin> :)
16:55:45 <copumpkin> edwardk: so what was the parser approach you were using?
16:56:03 <copumpkin> you said you had the user write out explicitly which parts were what?
16:56:04 <edwardk> oh regarding the partial evaluation stuff?
16:57:02 <copumpkin> the stuff I said about wanting to distinguish parsers that seek, and ones that are "Grounded" (for lack of a better word)
16:57:11 <copumpkin> (do you have a better word?)
16:57:24 <edwardk> well what i was playing with beyond the stuff we got to on the board was tracking an odd little applicative with something like data R a = Known a | Spec a | Spark | Ap -- which tracked if the output of the parser was known, or likely to be a given value, or if it was expensive enough to just spark the next step or should just be applied
16:57:24 <copumpkin> seek is also not really what I mean
16:57:36 <copumpkin> oh, yeah
16:57:37 <tgeeky> hm. ok
16:57:46 <copumpkin> I'm not talking as much about how to implement it but how to present it to the user
16:58:13 <copumpkin> I don't actually have any parsers yet, just = undefineds :P
16:58:32 <edwardk> then evaluating the next step in the parser using that info, with (Known a) f _ = f a; with (Spec g) f a = spec g f a; with Spark f a = a `par` f a; with Ap f a = f a
16:58:55 <edwardk> that way <$ reset that info to Known
16:59:07 <copumpkin> yeah
16:59:19 <edwardk> and the others were effectively progressive weakenings
16:59:59 <edwardk> but by tracking that as part of the Static constructor i could split the behavior up. similarly you could track a couple of bools that said whether or not you used seek or used the location
17:00:05 <edwardk> (or appropriate constructors)
17:00:23 <edwardk> but all at the value level
17:01:36 <edwardk> that'd get rid of the need for complicated overlapping instances and scary types
17:01:44 <tgeeky> rwbarton: one thing: isn't discovering the free algebras in class theory (instead of 'a' set theory) a different kind of thing?
17:02:22 <tgeeky> class theory seems to be 'the set of all (sets of ..)' that is well defined
17:02:25 <tgeeky> or something like that.
17:03:47 <tgeeky> anyway I'll try to model (the model) in haskell and see how it goes
17:03:53 <tgeeky> can't hurt
17:04:27 <copumpkin> edwardk: well my point is that I want to stop people from using them in places it makes no sense to use them
17:04:47 <edwardk> fair nuff
17:04:49 <copumpkin> if I have a binary plist parser that seeks, it makes no sense to try to run it on a network stream
17:05:03 <copumpkin> well
17:05:15 <copumpkin> it does, but you need to prefetch some meaningful chunk first :)
17:05:18 <edwardk> well, you could always just give those separate types and make instances for things, lifting between them as needed
17:05:43 <edwardk> RandomAccessParser vs. StreamParser
17:05:44 <copumpkin> yeah, I was doing that at some point too
17:05:46 <edwardk> or some such
17:05:55 <edwardk> then you can get a chunk and run the RandomAccessParser on it
17:06:06 <Jafet> class ForwardStream s; class ForwardStream s => RandomAccessStream s;
17:06:12 <edwardk> i've been debating about something like that in trifecta
17:06:13 <Jafet> It should be automatic if you do it that way
17:06:36 <edwardk> well, he also wants to be able to track if the parser doesn't need the current notion of location
17:06:41 <edwardk> so its a bit uglier
17:06:43 <hpaste> copumpkin pasted “ideal” at http://hpaste.org/50861
17:06:53 <copumpkin> those are the parsers I want to be able to write
17:07:12 <edwardk> then make three types, and two classes and split the instances up between them ;)
17:07:12 <Jafet> The parser's type would go (FooStream s) => Parser s ...
17:07:33 <Jafet> I think you can get FooStream inferred
17:07:42 <copumpkin> that's what I was doing before, but that approach has issues too
17:07:45 <copumpkin> let me try again :)
17:07:57 * hackagebot hledger-lib 0.15 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.15 (SimonMichael)
17:07:59 * hackagebot hledger 0.15 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.15 (SimonMichael)
17:08:01 * hackagebot hledger-web 0.15 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.15 (SimonMichael)
17:08:03 * hackagebot hledger-vty 0.15 - A curses-style console interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-vty-0.15 (SimonMichael)
17:08:05 * hackagebot hledger-chart 0.15 - A pie chart image generator for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-chart-0.15 (SimonMichael)
17:08:24 <edwardk> at :: Grounded a -> Location -> RandomAccess a
17:08:30 <edwardk> or some such
17:08:48 <copumpkin> yeah, that's what I actually had in my other file
17:08:49 <Jafet> I'm just copying the C++ iterator hierarchy, mind you
17:09:55 * copumpkin thinks harder
17:10:00 <edwardk> or maybe at :: Parser p => Grounded p a -> Location -> p a
17:10:11 <edwardk> using a class associated type for Grounded
17:10:13 <edwardk> er
17:10:24 <edwardk> at :: RandomAccess p => Grounded p a -> Location -> p a
17:11:28 <edwardk> class (RandomAccess (Grounded p), HasLocation (Grounded p), Monad p, ...) => RandomAccess p where type Grounded p :: * -> *
17:13:23 <copumpkin> hmm!
17:13:26 * copumpkin plays with it some more
17:14:01 <edwardk> and then the int, etc. parsers require HasLocation
17:14:42 <edwardk> probably needs 7.2
17:17:33 <acowley> I want to write Monoid a => Monoid (T a) where a is monoidal at the type level
17:17:54 <acowley> that's not quite right syntax
17:17:55 <kmc> how does GHC know if a .lhs file is Bird-style or LaTeX-style?
17:18:37 <Jafet> Brute force
17:19:00 <Jafet> s/$/?/
17:20:07 <edwardk> does it care until it finds the first \begin{code}  or > ?
17:20:14 <acowley> instance Monoid K => Monoid (T (a::K)) where
17:20:31 <BMeph> Is there a package/module that uses tau for its trig functions? ;)
17:20:52 <accel> this is off topic, but I'm awesome. Is there a standard math/LaTeX symbol for the haskell ":" and "++" operators? [++ looks ugly in math mode, while ":" has weird spacing issues"]
17:21:02 <edwardk> hrmm, i should add a 'literate' comment style to trifecta.
17:21:03 <edwardk> =)
17:21:42 <benmachine> BMeph: how would that even work?
17:21:50 <shachaf> I thought > and {code} could both work in the same file.
17:22:11 <Jafet> Mmm, a bird in latex
17:22:21 <shachaf> But apparently something strange is going on. If you use >, {code} is still respected, but causes a syntax error or something of the sort.
17:22:23 <edwardk> BMeph: the trig functions themselves don't change
17:22:37 <benmachine> right
17:22:59 <benmachine> they're either period tau or period 2pi
17:23:05 <benmachine> but are the same function either way
17:23:13 <edwardk> #include <math.h>\n#define TAU M_PI_2
17:23:15 <edwardk> done ;)
17:23:24 <edwardk> #define M_TAU M_PI_2 if you really want to
17:23:25 <edwardk> ;)
17:23:32 <Jafet> accel: \colon and \Join
17:23:43 <edwardk> er two PI
17:24:00 <edwardk> guess they don't have 2*PI in there
17:24:55 <shachaf> #define TAU PI PI
17:25:39 <Jafet> > pi pi
17:25:40 <lambdabot>   3.141592653589793
17:25:44 <edwardk> not sure if that'll get the least significant bit right
17:26:10 <edwardk> er (PI+PI) that is
17:26:13 <shachaf> I recommend calling 2*pi "lambda".
17:26:15 <acowley> I'm inspecting some code and the function TestForConvergence has a dozen commented out lines followed by "return true;"
17:26:22 <edwardk> shachaf: ?
17:26:23 <copumpkin> shachaf: it's already called tau
17:26:33 <shachaf> Lambda's less ambiguous.
17:26:45 <edwardk> shachaf: that is what folks call tau, so it looks like pi but needs half as many legs ;)
17:26:46 <dolio> How about we just write it as a dot.
17:27:03 <Jafet> acowley: because -ffast-math didn't quite cut it.
17:27:04 <accel> Jafet: thanks
17:27:11 <acowley> Jafet: it's cuda
17:27:19 <edwardk> ooh, we could bikeshed this one all day
17:27:27 <Jafet> Ah, then no justification is needed.
17:27:31 <dolio> ... . ...
17:27:34 <shachaf> @let lambda=pi/2
17:27:35 <dolio> Perfectly clear.
17:27:35 <lambdabot>  Defined.
17:27:41 <shachaf> @let tau=pi*2
17:27:42 <lambdabot>  Defined.
17:27:50 <Jafet> You optimize graphics code by commenting out lines until your scene changes
17:28:29 <acowley> It's actually computer vision code, but the point stands.
17:28:35 * edwardk shrugs. personally i find there aren't enough greek letters to go sacrificing a couple of the most useful to trivialities like that
17:28:52 * shachaf thinks using Greek letters for mathematics was a bad idea.
17:29:06 <Jafet> Greek fortran'
17:29:10 * shachaf doesn't speak Greek, though.
17:29:10 <edwardk> its damn handy at a whiteboard
17:29:11 * acowley α β γ
17:30:00 <ion> bmeph: http://www.thepimanifesto.com/
17:30:09 <acowley> I think it's great; writing out multi-character identifiers is for those who don't have various forms of RSI/Carpal Tunnel
17:30:29 <shachaf> Why not use Hebrew letters or something?
17:30:35 <shachaf> They only ever use א.
17:30:48 <Jafet> Just use chinese
17:30:51 <acowley> isn't that a place of honor enough?
17:30:54 <edwardk> shachaf: because, a classic education tended to cover greek and latin
17:31:46 <acowley> Jafet: some people do, but it sometimes ends up worse because they use a whole word or phrase which carries some baggage. That can be useful at times, and at other times belies the desired abstraction
17:31:48 <shachaf> They should just use English for everything.
17:31:49 <edwardk> and the roman alphabet was comparatively boring ;)
17:32:02 <shachaf> The language of Shakespeare and Milton and the Bible.
17:33:00 <acowley> I just hit an undocumented function that takes 25 in this same code base
17:33:03 <acowley> 25 arguments
17:33:35 <edwardk> ghc? =)
17:33:49 <acowley> edwardk: do they really do that sort of thing?
17:34:04 <edwardk> yes
17:34:17 <mauke> I need to check whether a file descriptor is readable/writeable. suggestions?
17:34:26 <acowley> I really like how easy it is to add haddock, and records aren't *that* bad if you need to pass a bunch of parameters
17:34:47 <acowley> mauke: exception handling?
17:34:53 <mauke> acowley: what?
17:35:02 <acowley> mauke: I mean just try and see if anyone yells
17:35:12 <mauke> acowley: no one will yell
17:35:25 <mauke> and I don't want to read/write
17:35:30 <mauke> I just need to know if it will block
17:38:09 <acowley> It would be nice if POSIX read(0) would set errno in such a case, but I don't think it does
17:38:27 <Jafet> > let 案 = 42; 答 数 = fst $ head $ readInt 13 isDigit (read.(:[])) (show 数) in 6 * 9 == 答 案
17:38:30 <lambdabot>   True
17:38:43 <edwardk> or if you could use select or poll and have them just never set the read/write bit when it isn't writeable
17:38:58 <mauke> edwardk: foreign import select?
17:39:11 <edwardk> mauke: not sure how sound that is in the presence of the RTS
17:39:41 <mauke> I'm basically trying to write the equivalent of select(2) anyway
17:40:30 <edwardk> you may want to talk to bos or tibbe about all the crazy work they put in to making the RTS just do the right thing with regards to lots of open file handles, etc.
17:40:40 <edwardk> and see what the recommended way to hook into that is
17:41:01 <mauke> preflex: seen bos
17:41:01 <preflex>  bos was last seen on #haskell 3 days, 4 hours, 50 minutes and 55 seconds ago, saying: yep
17:41:03 <mauke> preflex: seen tibbe
17:41:03 <preflex>  tibbe was last seen on #ghc 10 hours, 14 minutes and 7 seconds ago, saying: prevents slow strangulation \
17:42:27 <edwardk> hrmm
17:42:56 <edwardk> ok. try using fcntl with the command F_GETFL to get the status flags
17:43:22 <mauke> how does that tell me if reading will block?
17:43:29 <edwardk> that will tell you if the FD is _open_ for reading or writing
17:43:34 <edwardk> but not if it'll block
17:43:57 <mauke> I don't care about the open mode
17:43:58 <edwardk> which is what i thought you were asking at first
17:44:02 <edwardk> ah
17:44:14 <edwardk> then just hand it off to c and do 0 second select on it ;)
17:44:26 <mauke> terrible :-(
17:44:30 <edwardk> and toss back the read/write/execute bits
17:44:34 <applicative> shachaf http://en.wikipedia.org/w/index.php?title=File%3AEuclid-Elements.pdf&page=44
17:45:05 <edwardk> that is what select is for
17:45:18 <mauke> edwardk: yes, but not in Haskell
17:45:28 <mauke> the RTS is supposed to make this easier, not harder :-[
17:45:42 <shachaf> The RTS makes things easier if you do things its way.
17:45:50 <shachaf> applicative: People translate the *words* into English; why not the letters?
17:46:29 <mauke> shachaf: then what is the way here?
17:47:03 <shachaf> I have no idea.
17:47:17 <shachaf> "its way" means you do the things that it wants you to do. :-)
17:47:41 * shachaf has always been slightly suspicious of it.
17:48:54 <mauke> ok, new plan
17:49:02 <mauke> INFINITE THREAD WORKS
17:49:08 <edwardk> mauke: to spawn 10,000 lightweight threads and just pretend you're writing in java, blocking as needed
17:49:16 <edwardk> what do you want to do so differently if you would block anyways?
17:49:37 <mauke> edwardk: drop the fd from the result set
17:50:07 <mauke> at this point in the code I'm doing filterM threadCouldRead fds
17:51:05 <edwardk> mauke: another approach is to just dedicate a thread to communicating on each FD and just let it block
17:51:21 <edwardk> ghc is very good about waking those things only when they are needed and they aren't OS threads
17:51:27 <mauke> I know
17:51:35 <mauke> requires some rethinking
17:51:50 <edwardk> heck: http://hpaste.org/7217
17:51:54 <edwardk> ;)
17:52:07 <mauke> that looks a lot like my code
17:52:11 <mauke> where did you get that?
17:52:18 <edwardk> google
17:52:20 <mauke> hahaha
17:53:11 <mauke> edwardk: the problem in this case is that it will threadDelay 0, then kill all threads
17:53:17 <Peaker> mauke: implementing select on top of the RTS is implementing low-level primitives on top of high-level ones.. which is not always pretty :)
17:53:17 <edwardk> sure
17:53:28 <edwardk> i didn't really look at that code too closely
17:53:42 <edwardk> but i would highly recommend flipping the logic around to the 'ghc way'
17:53:42 <mauke> I did, given that I wrote it :-)
17:53:47 <acowley> edwardk: I want monoidal type tags on a monoid. Is this doable?
17:53:48 <edwardk> hah
17:54:02 <edwardk> 'monoidal type tags'?
17:54:23 <Cale> What's a type tag?
17:55:06 <mauke> what I'm writing is a "select loop"
17:55:12 <mauke> or an event loop, really
17:55:13 <ddarius> acowley: That should be quite doable.
17:55:40 <mauke> something that watches file descriptors and timers and tells me when they're ready
17:56:23 <edwardk> mauke: just put someone to watching each in turn and then have them scribble to MVars
17:56:24 <mauke> essential properties: must not do any reading/writing itself; all (result) event processing must happen on a single thread
17:56:46 <edwardk> why the single thread?
17:57:01 <mauke> reliability
17:57:19 <mauke> well, robustness
17:57:45 <edwardk> it seems like all this infrastructure is doing the exact opposite of introducing robustness and reliability ;)
17:57:49 <mauke> preflex currently has like a dozen threads, and stopping/restarting them feels much too brittle
17:58:14 <mauke> then why does preflex just hang in some situations?
17:58:46 <edwardk> i can't speak to the internals of preflex, as i have never looked at the internals of preflex, but i would guess, bugs =P
17:58:55 <acowley> edwardk: I mean phantom types that compose. I really want something like a function type (a -> b) at the type level that's just along for the ride with another type
17:58:58 <mauke> I've "fixed" on particular case by replacing 'liftIO . throwIO' by 'throw', but that's not enough
17:59:08 <mauke> *one
17:59:28 <mauke> edwardk: I want reliable restarting
17:59:42 <mauke> i.e. something like xmonad, where it can re-exec itself on the fly
17:59:49 <ion> For an example of reliability and robustness with a more or less arbitrary amount of threads, look at Erlang/OTP. :-)
17:59:54 <copumpkin> edwardk: no bugs in preflex
17:59:58 <copumpkin> preflex: 6st 4
17:59:58 <preflex>  4th
18:00:00 <copumpkin> preflex: 6st 3
18:00:00 <preflex>  3th
18:00:02 <ion> As well as robust runtime code upgrades.
18:00:05 <edwardk> copumpkin: ah that is reassuring
18:00:06 <copumpkin> preflex: 6st 1 2 3 4 5 6 7 8
18:00:07 <preflex>  1st 2rd 3th 4th 5th 6st 7rd 8th
18:00:18 <edwardk> hahahaha
18:00:44 <mauke> edwardk: that means threads must not have side effects
18:00:49 <mauke> otherwise I can't just kill them
18:00:53 <ddarius> mauke: I would think you would be able to just have all a way of having all threads join and produce a quiescent state, and then restart, and then restart them all.
18:01:23 <mauke> ddarius: how do I do that if a thread is currently blocked in read from a fd?
18:01:25 <edwardk> or you could give everyone an MVar or an IORef that they are required to check every so often like any other reasonable multithreaded app
18:01:49 <mauke> it can't check an MVar if it's blocked on IO
18:02:28 <edwardk> http://www.haskell.org/ghc/docs/7.0.2/html/libraries/base-4.3.1.0/GHC-Conc-IO.html threadWaitRead
18:02:31 <edwardk> threadWaitWrite
18:02:37 <edwardk> does that give you what you want?
18:02:51 <mauke> no
18:03:07 <mauke> at least not with the current code, but I'm going to write it
18:03:12 <mauke> argh. *rewrite
18:03:21 <Peaker> mauke: you could send a blocked-on-io thread an async exception?
18:03:43 <mauke> Peaker: what if the thread has just finished reading and is now carrying precious data?
18:04:20 <Peaker> mauke: you can use threadWaitRead, then block async exceptions and read it
18:04:26 <copumpkin> so how fucked is impredicativity in 7.2.1?
18:04:35 <copumpkin> howfuckedisimpredicativity.com
18:05:05 <mauke> Peaker: (in that case I wouldn't even need threadWaitRead)
18:05:17 <mauke> Peaker: that gets really complex really fast
18:05:22 <c_wraith> copumpkin: did it change from 7.0?
18:05:24 <mauke> writing async exception safe code is hard
18:05:30 <copumpkin> c_wraith: no clue
18:06:01 <mauke> Peaker: and now every thread has state that needs to be preserved and restored across a restart
18:06:22 <Peaker> If async exceptions were explicit Left's somehow, rather than IO exceptions (i.e: more explicit), I guess it would be just as easy to get it right as with using explicit state machines (forcing you to consider every case)
18:06:49 <Peaker> mauke: well, each thread can modular-ly handle restart, can't it? (I'm not really aware of what you're doing exactly)
18:06:57 <mauke> Peaker: how?
18:08:19 <Peaker> mauke: have an async exception that tells it to restart, and then have some sort of bracket combinator that takes a finalizer that only runs in the restart-case? can you describe what you're doing in more detail?
18:08:30 <mauke> lol wut
18:08:38 <kmc> i wonder what it would be like to program in Haskell with full, explicit polymorphism
18:08:51 <Peaker> mauke: what happens in a restart?
18:09:00 <mauke> Peaker: the program re-execs itself
18:09:28 <Peaker> mauke: and what do the threads need to preserve?
18:09:48 <Peaker> mauke: what's the purpose of the re-execution?
18:10:06 <mauke> Peaker: code updates
18:10:25 <mauke> what they need to preserve depends on what they're doing
18:10:44 <mauke> my current plan is to design things so that "nothing" needs to be preserved
18:10:56 <mauke> well, that's not true
18:11:13 <mauke> but to have a single chunk of import data in the main loop
18:11:17 <mauke> *important
18:12:03 <mauke> if you do I/O in other threads, suddenly you have to deal with not-yet-written and just-read bytes
18:12:16 <ion> mauke: I sincerely recommend looking at Erlang for ideas since that’s a well-solved problem in Erlang land. Also, jlouis has implemented some of that (not hot code updates, though) in Haskell, then there’s Cloud Haskell etc. http://learnyousomeerlang.com/
18:12:21 <Peaker> mauke: if you did the I/O in the main thread, why would you not have that problem?
18:13:08 <mauke> Peaker: because then I only need to look at my immediate surroundings to gather the state that needs to be preserved
18:13:27 <mauke> hmm
18:13:43 <Peaker> mauke: What are "immediate surroundings"? Can you give an example?
18:14:00 <mauke> that is, I don't need an extra communication protocol where I can ask each thread "what are you working on, what's your data, which fd?"
18:14:12 <Cale> Peaker: as opposed to requesting data from other threads for things that need to be serialised.
18:14:20 <Cale> right
18:14:43 <Peaker> well, if there's a registry that's passed as an argument to these threads, then they can put a mutable up-to-date what's-to-serialize thingie
18:14:50 <Peaker> (in the registry)
18:15:18 <RenJuan> Jafet, what IM/setup do you use to input the Hanzi?
18:15:28 <Peaker> then, a couple of combinators to perform operations with proper updating of the registry -- and maybe these threads won't look horrible
18:16:01 <mauke> Peaker: still requires async exception safe code in the threads
18:17:03 <Peaker> mauke: don't bracket/block/custom-combinators make this reasonable?
18:17:11 <mauke> no
18:17:24 <Jafet> RenJuan: google translate
18:17:40 <mauke> async exception safe Haskell code is about as bad as exception safe code in C++
18:17:57 <mauke> just thinking about it makes reading/writing code 10x as hard
18:18:27 <Peaker> you could block "by default" and unblock at certain points where you think it's ok -- then it's almost isomorphic to the select approach..?
18:18:31 <mauke> (also, 'block' is now deprecated)
18:19:32 <RenJuan> Jafet, ah
18:19:48 <RenJuan> so not a IM at all
18:20:11 <mauke> Peaker: I'm going to try a strictly single-threaded approach
18:20:20 <kmc> http://www.youtube.com/watch?v=uKfKtXYLG78  ←  erlang
18:20:32 <Peaker> mauke: a single-threaded approach will basically be CPS, right?
18:20:49 <mauke> Peaker: I hope that will simplify some things. if it doesn't work out, I'll try the shared-session-data thing
18:20:54 <Peaker> And if you do-sugar that CPS, you get back an IO thread :-)
18:21:04 <mauke> CPS? why?
18:21:40 <Peaker> mauke: because surely you'd register callbacks to call when a timer pops up or an fd becomes ready?
18:21:49 <Peaker> (or would you hard-code select loops that know what each fd is?)
18:21:50 <mauke> no
18:21:58 <mauke> well, yes
18:22:30 <Peaker> and you mean to do that on the select call that controls all fds/timers in a one-and-only thread?
18:22:49 <mauke> yes
18:22:54 <Peaker> it sounds like the code becomes very unmodular that way, can't really divide it into useful components
18:23:35 <mauke> I suspect this is a fundamental limitation
18:23:45 <mauke> file descriptors and signals are a global resource
18:23:55 <Peaker> why hard-code handling of an fd, if you can register a callback and allow putting the logic to handle that fd around the fd's creation/use?
18:24:02 <mauke> no, there are callbacks
18:24:35 <Peaker> then it is CPS?
18:24:44 <mauke> why is that CPS?
18:24:48 <mauke> they return
18:24:52 <Peaker> callback-based programming is basically CPS
18:24:58 <mauke> I disagree
18:25:09 <Peaker> It's Cont (IO ())
18:25:16 <Jafet> Callback-passing style
18:25:27 <Peaker> Callbacks are continuations..
18:25:27 <mauke> if it was CPS, nothing would return
18:25:50 <Jafet> They're not continuations; they're coroutines at best
18:26:29 <ddarius> Callback-based programming isn't CPS, but CPS is a way of managing it to recover a sequential flow when that is desired.
18:26:54 <ddarius> Used systematically, you get essentially (semi-)cooperative concurrency.
18:27:57 <Peaker> Assuming you have something like:  startAsyncFoo :: (a -> IO ()) -> IO ()    then you can say it is:  startAsyncFoo :: Cont (IO ()) a   and compose this using ordinary composition of Cont
18:28:07 <Jafet> Well, they're not really concurrent, since they block on each other
18:28:17 <Jafet> Or perhaps not, in this case
18:28:57 <Peaker> The types of callback-based functions is basically a variant of Cont -- and the way you compose them is the way you compose Cont, so why is callback-based programming not CPS?
18:29:16 <copumpkin> :t (>>=)
18:29:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:29:25 <copumpkin> m a -> Cont (m b) a
18:29:43 <mauke> Peaker: I don't have functions, my callbacks are IO ()
18:29:45 <ddarius> Peaker: The way you -sequentially- compose them is how you compose Cont.
18:30:16 <copumpkin> (>>=) :: forall b. NatTrans m (Cont (m b))
18:30:36 <Peaker> mauke: so that would be  Cont (IO ()) ()
18:30:59 <dolio> NatTrans m (ContT b m)
18:31:17 <Peaker> ddarius: Ok, now I understand what you said above :)
18:32:14 <jmcarthur> this is basically how we do asynchronous IO at jane street
18:32:25 <copumpkin> omg trade seekritz
18:32:34 <Peaker> ddarius: so my logic from before still works. If you use callbacks, you might as well transform their syntax to "do blocks" for sequential, and combinators (ala forkIO) for concurrent, and you get back IO threads
18:33:03 <mauke> Peaker: I don't get it
18:33:49 <ddarius> Peaker: All you are saying is that: you should use threads rather than events, which I agree with.  However, this still doesn't make events threads, which is all I was responding to.
18:34:22 <ddarius> Also, you don't get back forkIO threads, you get back something much more coarse and controllable.
18:34:25 <Peaker> mauke: What about this use of Cont (IO ()) for startAsyncFoo:  do { x <- startAsyncFoo ; y <- someOtherThing ; ... }  <-- clear why it's sequentially doing the async things?
18:35:07 <mauke> no
18:35:13 <mauke> what is startAsyncFoo?
18:35:34 <Peaker> startAsyncFoo :: Cont (IO ()) a
18:35:40 <Peaker> @unmtl Cont (IO ()) a
18:35:40 <lambdabot> (a -> IO ()) -> IO ()
18:36:18 <mauke> and what does it do?
18:36:36 <ddarius> mauke: It's your callback.
18:36:48 <Peaker> starts some async operation "foo" and when it's done, it calls the given callback and hands it the result "a"
18:36:58 <ddarius> readFileAsync :: (ByteString -> IO ()) -> IO ()
18:37:09 <ddarius> Or rather the thing that registers the callback.
18:37:09 <mauke> oh, a result
18:37:17 <mauke> why would I need a result?
18:37:28 <Peaker> mauke: well, async operations may have results (e.g: an async read?)
18:37:46 <Peaker> mauke: if it doesn't have a result, use () as usual
18:37:59 <mauke> how about I just use IO () as usual
18:38:05 <mauke> what does Cont buy me?
18:38:28 <Peaker> mauke: you can chain a bunch of async operations one after another, sequentially, very easily
18:38:30 <jmcarthur> i am not convince that, in haskell at least, this interface is really any different from forkIO. think about what the run function for this monad must do
18:38:42 <Peaker> (and they can see the results of previous async operations, if they have results)
18:38:43 <mauke> Peaker: when do I need that?
18:38:52 <jmcarthur> technically it doesn't have to be an actual thread, but it might as well be
18:38:53 <ddarius> jmcarthur: All it must do is apply what's given to it to return.
18:39:02 <Peaker> mauke: if you do blocking things asynchronously, one after another? (e.g: read from one place, write what you read to another place)
18:39:17 <mauke> Peaker: won't happen
18:39:34 <Peaker> mauke: what async stuff are you doing?
18:39:43 <ddarius> jmcarthur: If you have an event-based interface, this produces a thread-based one, albeit a different one from forkIO.  If you are creating the interface, you might possibly still want to do this, though using forkIO may also be the right approach.
18:39:46 <jmcarthur> ddarius: sure, but to meet your expectation that it gives you asynchronous IO it's probably going to either fork a thread or handle some select/epoll stuff itself, no?
18:39:48 <mauke> Peaker: none, as far as I can tell
18:40:15 <jmcarthur> it's a little different from forkIO in that it's a different monad from IO
18:40:35 <dolio> What's with this xhtml package not building? Can't import Prelude because base isn't trusted?
18:40:35 <ddarius> jmcarthur: The select/epoll stuff would be the "event-based interface that you have."
18:40:39 <jmcarthur> right
18:40:53 <dolio> Is SafeHaskell being turned on aggressively in 7.2 or something?
18:41:02 <mauke> which is basically the opposite direction
18:41:09 <mauke> I have forkIO and I want select
18:41:11 <jmcarthur> i just mean that the interface this provides is not very different from threads
18:41:25 <ddarius> jmcarthur: Interface what provides?
18:41:42 <jmcarthur> this monad that Peaker is talking about
18:41:56 <ddarius> jmcarthur: It's just the Cont monad.
18:43:18 <jmcarthur> everything is just the Cont monad
18:43:38 <Peaker> Does it make sense to add "fork-like" combinators to ContT to facilitate concurrent in addition to sequential composition of ContT actions?
18:43:48 <ddarius> Peaker: Of course it does.
18:44:11 <ddarius> At least in this context.  If you mean we should add some general Fork class, then that may make less sense.
18:44:58 <Peaker> ddarius: well, I mean in the general sense, for ContT, though I am not sure it makes sense in the general case  (Given two values like  (a -> m r) -> m r    can we compose them non-sequentially in an interesting way?
18:49:50 <dolio> Oh I see, it's in the file.
18:49:55 <dolio> {-# LANGUAGE Safe #-}
18:50:00 <dolio> Cripples the entire package.
18:50:22 <dolio> Excellent.
18:50:42 <roconnor> you cannot import the Prelude with Safe?
18:50:51 <dolio> Not as far as I can tell.
18:50:54 <dolio> base is not trusted.
18:50:58 <jmcarthur> i'm not sure i understand how this cripples it
18:51:07 <jmcarthur> oh it just doesn't build
18:51:16 <jmcarthur> so why was it uploaded this way? ...
18:51:22 <dolio> It's impossible to build, unless the package uses NoImplicitPrelude.
18:52:12 <dolio> Or: why isn't base safe?
18:52:21 <dolio> I mean, it isn't, I guess.
18:52:28 <dolio> Since unsafePerformIO is in there.
18:52:34 <dolio> But, Prelude?
18:52:48 <dolio> What good is the extension?
18:53:31 <Peaker> dolio: What guarantees should "Safe" code give?
18:53:49 <Peaker> If the guarantee is "no ambient authority" -- then maybe even having "readFile" is unsafe already
18:53:54 <tgeeky> that all includes say their safe, right?
18:54:03 <tgeeky> I think this is something each developer choses at this point
18:54:16 <tgeeky> yes?
18:54:20 <Peaker> if the guarantee is merely "Can't subvert the type system", then you just need to exclude FFI and some very few things
18:54:38 <dolio> I think it's more like the latter.
18:54:57 <dolio> It isn't about reading files.
18:55:01 <ddarius> Well it's sociological, but the sociological intent is more like the latter.
18:55:10 <tgeeky> which latter
18:55:19 * tgeeky returned mid conversation
18:55:21 <dolio> "Can't subvert the type system."
18:55:30 <tgeeky> does RankNTypes count against taht?
18:55:37 <dolio> No.
18:55:37 <kmc> you can import any module from base if it was also compiled with -XSafe
18:55:45 <kmc> afaik
18:55:50 <kmc> what's wrong with RankNTypes?
18:55:59 <tgeeky> nothing wrong
18:56:06 <bobzhang> hi, is there any posts showing how to use RankNTypes to encode datatypes?
18:56:12 <kmc> you can also pass "-trust base" to GHC
18:56:21 <kmc> basically SafeHaskell is pretty complicated
18:56:52 <tgeeky> bobzhang: I don't know if there are posts, but I get the feeling that's what roconnor's paper is about
18:57:16 <roconnor> I don't use it to "encode" data types
18:57:17 <dolio> bobzhang: Read Proofs and Types.
18:57:18 <ddarius> You only need rank 2 types to encode all regular data types.
18:57:28 <bobzhang> tgeeky: yeap, I feels that data is not really needed
18:58:01 <bobzhang> I have read TAPL, I wanna read some concrete examples in Haskell to confirm my idea
18:58:45 <tgeeky> 22:40 < bobzhang> tgeeky: yeap, I *feels that data is not really needed* <-- clarify?
18:59:03 <tgeeky> roconnor: you could use your thing to enumerate data types, right?
18:59:07 <dolio> You don't need data. You just need more dubious features. :)
18:59:10 <bobzhang> tgeeky:  I mean the data keyword is not necessary
18:59:18 <tgeeky> bobzhang: oh, hm.
18:59:29 <kmc> very few things are necessary in an absolute sense
18:59:41 <kmc> you have to talk about "necessary given goals X"
18:59:49 <roconnor> tgeeky: nope
19:00:13 <roconnor> tgeeky: Multiplate is used to do generic traversals (and folds) of mutually recursive data types
19:00:24 <roconnor> even abstract data types
19:02:46 <kmc> SafeHaskell definitely is not aimed at eliminating ambient authority, in its present form
19:02:51 <tgeeky> roconnor: did you see the noise above about "Numbers"?
19:03:02 <kmc> though you could use it for that by being extra conservative about which modules to trust
19:03:21 <tgeeky> (the paper (~ 30p), and meta-notes (~ 6p) from: http://metu.edu.tr/~dpierce/Mathematics/Numbers/)
19:03:34 <kmc> it's definitely about forbidding memory-unsafe operations and functions with side effects
19:04:00 <tgeeky> but it's a social expectation to use it in that manner?
19:04:11 <kmc> also guaranteeing that abstract data types stay abstract
19:04:28 <kmc> http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell see "Safe Language Overview"
19:05:47 <Peaker> "This is a proposal for a Haskell extension through which people can safely execute untrusted Haskell code, much the way web browsers currently run untrusted Java and JavaScript" <-- if you still allow ambient authority, doesn't it defeat the purpose?
19:06:07 <Peaker> Javascript in the browser doesn't have ambient authority to access the standard file API
19:06:14 <Peaker> (I hope :-) )
19:06:34 <tgeeky> so, write a program without ambient authority to access the standard file api
19:07:14 <kmc> the goal of the Safe dialect of Haskell is to make it possible to control what a program does by controlling what modules you let it import
19:07:27 <mauke> how thread safe are IORefs?
19:07:32 <kmc> as i understand it
19:07:37 <dolio> mauke: Not.
19:07:48 <mauke> dolio: how thread unsafe are IORefs?
19:07:50 <kmc> can you cause segfaults with concurrent access of IORefS?
19:08:07 <tgeeky> Peaker: Think about the use case of someone like chrisdone or luite (who want to put a "do anything in haskell" up where "tryhaskell is" now -- but one that would handle fetching and compiling from cabal
19:08:27 <tgeeky> Peaker: theose people might want to flag every library that has a .Unsafe module
19:08:38 <tgeeky> Peaker: or a variety of other things as being unsafe
19:08:43 <tgeeky> and then allow anything else
19:09:03 <Peaker> mauke: there's atomicallyModifyIORef
19:09:18 <mauke> doesn't really answer my question
19:09:35 <tgeeky> then (as long as -XTrustyworthy is secured), they can host a webapp that brings in arbitrary cabal packages to scope
19:09:45 <jmcarthur> i've been under the impression that IORef are pretty thread safe, but i have evidence to back that up
19:09:47 <Peaker> mauke: other accesses to IORefs are probably going to be word-atomic (won't get part-word updates) but otherwise no atomicity guarantees
19:09:52 <Peaker> mauke: (at least on x86)
19:10:01 <mauke> define "word-atomic"
19:10:21 <Peaker> you either see a whole-word written, or the whole-word is pre-write value, not something in between
19:10:27 <jmcarthur> you can safely write a pointer into an IORef, is the speculation
19:10:29 <mauke> define "whole-ord"
19:10:31 <mauke> *word
19:10:46 <tgeeky> word-aligned maybe?
19:10:56 <jmcarthur> on 64 bit machines, word = 8 bytes
19:11:01 <jmcarthur> on 32 bit machines, word = 4 bytes
19:11:11 <Peaker> mauke: well, the word here is the immutable-value-reference -- you're not going to see a corrupt reference in IORefs under any circumstance, I guess is what I'm saying :)
19:11:12 <mauke> jmcarthur: ok, and what does that have to do with Haskell?
19:11:35 <mauke> "probably"
19:11:39 <mauke> doesn't help much
19:11:52 <tgeeky> under any circumstance seems strong to me?
19:12:03 <kmc> the only things ever written to IORefs are pointers, if you're talking at the GHC implementation level
19:12:21 <dolio> kmc: So, what you're saying is: -XSafe is a good thing to sprinkle in your modules, and not test whether it actually works.
19:12:34 <kmc> dolio, hmm, I don't think I said that, but I'd have to scroll back to make sure
19:12:39 <jmcarthur> mauke: my point is that if the update is indeed word-atomic (i don't see any reason it wouldn't be), then it should be thread safe in general
19:12:40 <dolio> :)
19:12:45 <mauke> looks like the consensus is "I don't know"
19:13:08 <mauke> I'm going to implement all reads/writes in terms of atomicModifyIORef
19:13:14 <jmcarthur> if IORef was unboxed that wouldn't be the case
19:13:21 <Peaker> mauke: someone asks: "would this cause any trouble other than occasional missed updates or reads of wrong data?"  Simon Marlow replies: "It shouldn't, no."
19:13:36 <mauke> Peaker: reference?
19:13:41 <kmc> right, concurrent access to a Vector.Unboxed Word64 on a 32-bit machine could go very wrong
19:14:54 <copumpkin> kmc: Unboxed.Mutable?
19:15:11 <kmc> sure
19:15:12 <Peaker> http://www.haskell.org/pipermail/haskell-cafe/2008-February/039608.html
19:15:13 <kmc> that one
19:15:19 <mauke> Peaker: thanks
19:18:05 <mauke> ah, crap
19:20:16 <roconnor> tgeeky: what's your question about ZF?
19:21:26 <tgeeky> roconnor: I don't care that much about ZF. I'll hpaste a question or two with references in.
19:22:37 <mauke> now I know what bothers me about threaded IO: threads aren't guaranteed to run
19:23:09 <mauke> and I'm beginning to suspect IO is impossible in Haskell
19:24:23 <roconnor> mauke: are threads guarenteed to be run in other langauges?
19:24:32 <mauke> the problem with "spawn threads ahead of time, let results accumulate in IORef/MVar/etc" is that they don't get reset when the status of the underlying fd changes
19:24:46 <mauke> roconnor: no, but I wouldn't use threads in any other language
19:24:51 <roconnor> :)
19:25:14 <roconnor> mauke: if I spawn a thread with fork and then wait on a semephore, won't the thread run?
19:25:27 <mauke> roconnor: what?
19:25:45 <mauke> ECONTEXT
19:25:46 <roconnor> I guess I don't understand why you think threads won't run
19:26:02 <mauke> asshole scheduler is out to get me
19:26:07 <roconnor> right
19:26:30 <roconnor> but you main forks a thread, and then blocks, the evil scheduler will have no choice but to run the other thread.
19:26:45 <mauke> true
19:27:12 <mauke> doesn't help with timers, though
19:27:30 <mauke> an evil scheduler could keep waking up my timer threads and completely ignore I/O
19:27:53 <roconnor> what are your timer threads?
19:27:59 * hackagebot maccatcher 2.1.3 - Obtain the host MAC address on *NIX and Windows.  http://hackage.haskell.org/package/maccatcher-2.1.3 (JasonDusek)
19:28:21 <ddarius> Most schedulers provide fairness.
19:28:31 <mauke> er, something that runs in intervals
19:28:35 <mauke> like threadDelay or something
19:29:29 <roconnor> threadDelay just gives a minimum time to sleep, not a maximum, right?
19:29:43 <mauke> right
19:29:52 <mauke> ddarius: what is fairness in schedulers?
19:30:01 <roconnor> is there a yeild command?
19:30:16 <tgeeky> roconnor: I think it would be more appropriate to make a (first) blog post to ask this question, rather than hpaste it. I'll try to get your attention sometime tomorrow, if you're around.
19:30:17 <ddarius> mauke: Every ready thread will eventually be run.
19:30:21 <roconnor> I suppose with enough use of yield and one of ddarius's fair schedules you could guarentee something gets run
19:30:50 <tgeeky> roconnor: I think this author is trying to make an argument (in model theory) (about class theory) which is supposedly about indcutive sets (of sets .. (of sets ..)))
19:31:01 <mauke> ddarius: where "eventually" = after an hour?
19:31:13 <ddarius> mauke: Yes, fairness does not me no starvation.
19:31:15 <tgeeky> which are constrcuted using (evidently) mutual recursion
19:31:19 <ddarius> s/me/mean/
19:31:19 <roconnor> maybe yeild = threadDelay 0
19:31:35 <tgeeky> and then tested by induction for "class" properties
19:31:45 <mauke> roconnor: but this is a small problem
19:32:04 <mauke> the big problem is what I'm going to do with fd's whose state changes under me
19:32:10 <hpaste> siracusa pasted “ugly loop function” at http://hpaste.org/50862
19:32:22 <monochrom> @hoogle yield
19:32:22 <lambdabot> Control.Concurrent yield :: IO ()
19:32:24 <siracusa> ^ Is there a common pattern how to rewrite such a function so that all the "loop"s can be moved to a single one after the case?
19:32:27 <roconnor> mauke: how is that thread specific?
19:32:47 <mauke> roconnor: without threads I'd just use select
19:33:13 <roconnor> I guess I don't know what it means for a fd to change state under you
19:34:14 <jmcarthur> mauke: how does select solve a problem that threads don't?
19:34:18 <mauke> roconnor: assume I register two callbacks, one to fire after some delay, the other when a certain fd becomes readable
19:34:36 <mauke> then I start my event loop
19:34:52 <zzo38> I looked in the haskell-src-exts files. The ParseSyntax.hs file (as well as many of the other files) do something, stuff added needs to be added in multiple places manually. For example, PExp needs to also define ann, amap, fmap, etc. But most of that is just the same way. It might seem (to me, at least) a better way using TH-splices generating more-declarations.
19:35:05 <roconnor> mauke: you get a read lock when the fd is available and you wake up?
19:35:18 <zzo38> It is same thing with the list of valid extensions, and etc
19:35:23 <mauke> roconnor: what?
19:35:39 <roconnor> mauke: nevermind, go on
19:35:59 <mauke> roconnor: ok, so that's the external interface. how am I going to implement it?
19:36:01 <roconnor> mauke: it may soon become apparent that I don't know how files work in UNIX/POSIX.
19:36:34 <jmcarthur> mauke: one thread to block on the fd, another to block on a call to threadDelay. or am i answering the wrong question?
19:36:58 <roconnor> mauke: um, you implement it exactly how you said?
19:37:16 <mauke> roconnor: I described an interface, not code
19:37:31 <solidsnack> What select() does is return a list of readable (or writable) descriptors -- or errors out, if too much time has passed.
19:37:49 <mauke> jmcarthur: what does the fd thread do when it gets woken up?
19:37:51 <solidsnack> roconnor: There's no lock management.
19:38:02 <mauke> jmcarthur: I'm thinking ... threadWaitRead fd; whatNow?
19:38:03 <jmcarthur> mauke: whatever your callback does
19:38:14 <NemesisD> hi all. trying to write the terminating iteratee in an enumerator pipeline. i'm trying to write it in terms of an enumeratee and then flatten it with joinI to an iteratee becase it seems simpler
19:38:16 <jmcarthur> the remainder of the thread is your callback
19:38:17 <mauke> jmcarthur: bzzt, wrong. I don't want my callbacks running conncurrently
19:38:24 <mauke> *concurrently
19:38:30 <mauke> all callbacks should run on the same thread
19:38:53 <jmcarthur> then write a message to an MVar, and the callback thread blocks on that
19:39:21 <roconnor> mauke: do {registerCallBack (threadDelay n >> foo); registerCallBack (blockingRead fd >>= bar)}
19:39:39 <mauke> roconnor: no blocking reads
19:39:48 <roconnor> huh?
19:39:55 <mauke> roconnor: especially not on different threads
19:40:06 <jmcarthur> why?
19:40:24 <mauke> jmcarthur: ok, what if the callback thread is currently busy and when it finally comes to processing the fd, someone else has already interacted with it?
19:40:42 <mauke> so it's no longer readable
19:40:47 <monochrom> f cba cbb = do { n <- newEmptyMVar; forkIO (threadDelay 10 >> putMVar n cba); forkIO (threadWaitRead fd >> putMVar n cbb); takeMVar n >>= join; takeMVar n >>= join }
19:41:05 <jmcarthur> mauke: i think i need to know the big picture here...
19:41:16 <roconnor> mauke: doesn't your BlockingFileRead give you a reader lock?
19:41:16 <hpaste> NemesisD pasted “terminating iteratee” at http://hpaste.org/50863
19:41:26 <NemesisD> relevant paste. hoping you guys oculd help me figure this one out
19:41:29 <mauke> roconnor: I don't understand what that means
19:41:31 <jmcarthur> because every time we propose something you bring up something else that throws a monkey wrench in it
19:41:41 <jmcarthur> which is new information
19:41:56 <mauke> yeah, but you're very helpful anyway :-)
19:42:15 <mauke> sorry if this is frustrating for you
19:42:28 <roconnor> mauke: well, in my mind files have reader/writer locks associated with them.  A reader lock means only other threads with reader locks can access the file in read-only mode, and if a thread gets a writer lock all other threads are blocked from reading or writing.
19:42:51 <ddarius> mauke: I recommend that you read Reppy's thesis on CML and also (much shorter) Pike's "Concurrent Window System."  What you want is a (higher level) select mechanism, which is a perfectly natural control structure in program structured using threads.  That select would need to be integrated with fd's, etc.  You could implement that select in the pseudo-threaded manner Peaker was talking about on top of the provided eve
19:42:51 <ddarius> nt-based interfaces.
19:42:56 <mauke> roconnor: I'm not even interacting with files ... ?
19:43:00 <monochrom> to be honest, if some other thread (even some other process) is messing with that file, and there is no OS support for locking that file, you're hosed
19:43:05 <roconnor> but solidsnack said there is no lock management ... maybe this is what he/she meant.
19:43:06 <jmcarthur> roconnor: i don't think it works that way
19:43:12 <NemesisD> flattening an enumeratee is conceptually so much simpler to me in this concept
19:43:30 <roconnor> jmcarthur: am I misremembering my concurrency courses?
19:44:02 <jmcarthur> you might not be. file descriptors are weird
19:44:15 <ddarius> Incidentally, GHC does do this integration with its threads, but it doesn't provide a select-like mechanism.
19:44:21 <roconnor> well the course wan't about UNIX/POSIX
19:44:28 <monochrom> you may as well say you can't do atomic transactions on mysql and ghc doesn't help you
19:44:29 <mauke> my current idea is: notifications sent by threads, non-blocking I/O everywhere
19:44:39 <roconnor> I just presumed that UNIX/POSIX puts some sort of sane interface onto file descriptors
19:44:57 <jmcarthur> mauke: so what are you after? an event interface instead of a thread interface?
19:45:03 <mauke> jmcarthur: ah, yes.
19:45:12 <jmcarthur> may i ask why?
19:45:22 <mauke> see above for some context
19:45:39 <mauke> I want tightly controlled interaction with the outside world
19:46:17 <mauke> that means no concurrent I/O because then my left hand no longer knows what the right is doing
19:46:19 <solidsnack> roconnor: In UNIX/POSIX, file locks are advisory; other programs must agree to participate by calling flock and seeing if they get a lock.
19:46:28 <mauke> ddarius: do you have a link?
19:46:36 <ddarius> @google Reppy thesis
19:46:38 <lambdabot> http://people.cs.uchicago.edu/~jhr/papers/1992/phd-thesis.ps.gz
19:46:42 <mauke> well, that was easy
19:46:48 <ddarius> @google Rob Pike "Concurrent Window System"
19:46:50 <lambdabot> http://doc.cat-v.org/bell_labs/concurrent_window_system/
19:46:50 <lambdabot> Title: A Concurrent Window System
19:47:28 <roconnor> mauke: are you worried about another process taking away read access to the file descriptor (is that possible) or another thread?
19:47:35 <ddarius> There's another paper related to that Pike paper that is also fairly short and readable and more generically concurrency rather than focusing on window management.
19:47:53 <jmcarthur> mauke: so if i'm to attempt a summary of what you *really* want, it's the ability to do async IO without also having thread premption?
19:48:08 <mauke> roconnor: both, actually. and it's not "taking away read access", it's simply reading
19:48:15 <jmcarthur> brb
19:48:32 <mauke> jmcarthur: could be
19:48:39 <roconnor> mauke: if one thread reads then another thread loses the ability to read that data?
19:49:19 <_Ray_> Hi. Inside a 'where' clause, can I give type signatures for functions that are declared in it? Something like foo x = f (x+1) where f :: Int -> Bool\nf x = ...
19:49:26 <mauke> yes, if two threads read from the same source, only one of them will get the data
19:49:30 <roconnor> _Ray_: yep
19:49:58 <dolio> Why would two threads have the same file descriptor?
19:49:59 <mauke> well, one of them may get the first chunk, then the other the next chunk
19:50:07 <_Ray_> roconnor, thanks :)
19:50:15 <roconnor> mauke: same if another process reads the fd?
19:50:18 <mauke> roconnor: yes
19:50:33 <roconnor> mauke: so even if your program is single threaded there is nothing you can do to stop this?
19:50:40 <mauke> yes
19:50:43 <solidsnack> roconnor: Well, another UNIX process is probably not reading the same FD.
19:51:02 <roconnor> mauke: so this isn't really a threading issue
19:51:20 <roconnor> solidsnack: can you guarentee that?
19:51:20 <mauke> roconnor: right, which is what lead me to the idea described above
19:51:33 <solidsnack> roconnor: You have to pass the FD to the other process if you want it to see it.
19:51:36 <mauke> well, I mentioned it briefly in one sentence
19:51:50 <mauke> solidsnack: all I have to do is spawn another program and it can see my fd's
19:51:50 <solidsnack> roconnor: Don't pass out your file descriptors and you can be sure.
19:52:08 <solidsnack> Oh, true, with exec, yeah.
19:52:14 <solidsnack> Or fork.
19:52:29 <tgeeky> you could pass something else around (other than file descriptors)
19:52:43 <tgeeky> s/pass around/share/
19:52:44 <solidsnack> However, an independent process can not just stumble in to your file descriptors.
19:52:49 <mauke> perl is pretty nice here in that it defaults to FD_CLOEXEC
19:53:08 <roconnor> mauke: does forking/spawning let them see file descriptors that you create after said fork/spawn?
19:53:39 <ddarius> Yay eta expansion ...
19:53:52 <mauke> roconnor: no
19:54:13 <mauke> roconnor: fork() creates a copy of a process; after that they're independent
19:54:36 <roconnor> mauke: so if you don't call fork or span a process you are fine.
19:54:37 <mauke> fd's are shared because they're userspace handles for kernel objects
19:55:03 <mauke> roconnor: I will call fork
19:55:39 <roconnor> mauke: okay but you control what happens after fork, you can make sure that the forked program immediately forgets about your file descriptors
19:56:05 <mauke> I don't like that
19:56:11 <roconnor> what's not to like?
19:56:17 <mauke> it's monolithic
19:56:41 <mauke> I have to write the whole program making sure every part respects the same invariants
19:56:42 <roconnor> how is it monolithic?
19:56:52 <roconnor> mauke: that is what the type system is for
19:56:54 <roconnor> :)
19:56:56 <solidsnack> mauke: Well, how are you forking?
19:57:04 <mauke> that means I can't pull out the event loop into a separate library or whatever
19:57:17 <roconnor> you wrap up the call to fork in special code that handles the forgetting
19:57:25 <roconnor> and never use fork anywhere else
19:57:25 <mauke> well, unless I add a note to the docs: "warning, doesn't work right if you do X, Y or Z"
19:57:28 <mauke> which sucks
19:57:39 <roconnor> make your own forkless copy of IO
19:57:51 <roconnor> only accept that pseudoIO monad
19:57:57 <mauke> roconnor: so this hypthetical library wouldn't be usable with anything else, ever
19:58:27 <roconnor> mauke: not with people who want to pass in unsantized IO.
19:58:43 <roconnor> mauke: it is called having a safe API
19:59:26 <roconnor> if IO is too broad of a data type to accept you have no choice really
19:59:30 <roconnor> and IO is pretty damn broad
19:59:40 <mauke> how would that even work?
19:59:55 <mauke> I'd have to provide a runPseudoIO and then I'm back to IO
20:00:03 <roconnor> you make a newtype wrapper for IO
20:00:16 <roconnor> and add all the safe IO commands
20:00:28 <roconnor> mauke: no you wouldn't have to provide runPseudoIO
20:00:35 <mauke> why not?
20:00:38 <roconnor> you would only use runPseudoIO yourself.
20:00:44 <mauke> what
20:00:54 <mauke> how does that prevent anyone else from calling fork?
20:01:35 <roconnor> because you don't provide no fork :: runPseduoIO () -> runPseudoIO ()
20:01:47 <mauke> and?
20:01:47 <roconnor> oh wait I seee
20:01:57 <mauke> main :: IO ()
20:01:59 <mauke> you lose
20:02:03 <roconnor> ahhh
20:02:07 <ddarius> mauke: You can provide main.
20:02:13 <roconnor> right
20:02:16 <mauke> ddarius: in a library. right.
20:02:22 <roconnor> you'd have to make a "framework" I guess
20:02:26 <mauke> and by "right" I mean "that's fucking crazy, no way"
20:02:57 <ddarius> mauke: My impression is that you were primarily interested in making an application, not a library.
20:03:02 <monochrom> huh? I thought the whole point of needing someone to write programs is needing someone to make sure that invariants are preserved by every part of the program. otherwise you could just use a monkey
20:03:12 <ddarius> And SDL does exactly this, as well as many other libraries.
20:03:26 <mauke> ddarius: yes, but I still want its parts to be as independent and robust as possible
20:03:46 <solidsnack> Maybe this can help: http://stackoverflow.com/questions/1643304/how-to-set-close-on-exec-by-default
20:03:47 <mauke> ddarius: so what you're saying is I can't use SDL together with many other libraries
20:04:18 <solidsnack> There are a lot of ways to get FD_CLOEXEC set.
20:04:24 <drdo> Is there a de facto standard library for monad transformers?
20:04:43 <ddarius> mauke: Actually you can, but it does take more effort.  At any rate, at no point did I say that this was a good idea.  It's just a way to get the guarantees that roconnor's solution would provide.
20:05:02 <mauke> I don't think it's a solution at all
20:05:23 <roconnor> mauke: you are sunk no matter what if you are getting the user to hand you a file descriptor.
20:05:30 <mauke> roconnor: nope
20:05:36 <roconnor> oh?
20:06:10 <mauke> the trick is silently dropping spurious wakeups
20:06:30 <mauke> which probably every callback will have to do itself
20:06:43 <roconnor> how does that help?
20:06:55 <roconnor> the user can read from the fd whenever she wants
20:07:12 <ddarius> mauke: This aspect is the aspect that seems closest to what I'm referring to in Pike's and Reppy's papers.
20:07:41 <mauke> ddarius: oh, right. I still have too many tabs open
20:07:51 <mauke> roconnor: what's the problem with that?
20:08:05 <roconnor> mauke: she might read at the same time you are reading
20:08:21 <mauke> roconnor: what's the problem with that?
20:08:37 <roconnor> mauke: I don't know you are the one who didn't want to lose data when reading.
20:09:05 <mauke> no, I didn't want to lose data when restarting
20:09:24 <roconnor> what does restarting mean?
20:09:29 <mauke> exec()
20:09:34 <roconnor> between the time you wake up and when you start reading?
20:10:08 <mauke> roconnor: no, the problem with that was freezing the program
20:10:16 <ddarius> To abstract and simplify, imagine that you have two MVars, m and n.  Let's say you want to do act1 when m is filled and act2 when n is filled, but only one of those should ever happen even if both m and n get filled.  GHC provides no mechanism to do this.
20:11:00 <sero> Does anybody know if there's a haskell bot out there at all with weather capabilities, or maybe a plugin for an existing bot?
20:12:10 <roconnor> ddarius: can't you make a third semephore that you raise when either m or n happens and which wakes up a third thread that looks to see if m and/or n is filled and act approrpriately?
20:12:22 <parcs> @google weather 07026
20:12:23 <hpaste> “_Ray_” pasted “Overlapping pattern?” at http://hpaste.org/50864
20:12:24 <lambdabot> http://www.weather.com/weather/tenday/Garfield+NJ+07026
20:12:25 <lambdabot> Title: 10 Day Weather Forecast for Garfield - weather.com
20:12:45 <_Ray_> Indeed I did, lambdabot. I'm wondering why ghc is saying there are overlapping patterns there?
20:12:52 <_Ray_> (p should be a bound variable...)
20:12:53 <mauke> _Ray_: p and otherwise are both wildcard patterns
20:13:06 <mauke> _Ray_: no, you can't have variables in patterns
20:13:07 <sero> parcs, I'd given that a shot myself, hoping it'd just output even basic weather data, but it just gives a link instead.
20:13:10 <_Ray_> Ooooh.
20:13:39 <roconnor> mauke: sorry, I guess I just don't understand. :(
20:13:54 <roconnor> too much UNIX for me.
20:14:14 <xil> hello. I have 2 questions. First is about file io. Is there a way to write to a file without going through the IO monad? Writing, after all, is a deterministic process isn't it?
20:14:28 <mauke> xil: no and no
20:14:32 <ddarius> What mauke said.
20:15:17 <parcs> sero: do you just want convenient access to the weather forecast?
20:15:19 <ash_> so… I have a question, say I want to map a list of 1 thing into a list of another thing, like data MyType = A | B | C "abc" into [A, B, C]
20:16:02 <xil> haha. Okay. I'll take what I get then. Second question is about runInteractiveProcess. I use it to spawn an instance of ffmpeg which I pipe data to at an undetermined and irregular rate. Interesting thing is that when the terminal doesn't have focus ffmpeg just doesn't seem to work, i.e., the frames I send get dropped. Anyone know anything about that?
20:16:07 <roconnor> > map char ['A','B','C']
20:16:08 <lambdabot>   [A,B,C]
20:16:20 <jmcarthur> :t char
20:16:21 <lambdabot> Char -> Doc
20:16:24 <jmcarthur> oh that
20:16:27 <roconnor> wtf?
20:16:27 <mzero> ash_: I don't understand. You have a type that can be one of three things, and you want a list of all possible values?
20:16:27 <jmcarthur> cheating
20:16:35 <Jafet> char = text . singleton
20:16:35 <roconnor> > map ord ['A','B','C']
20:16:36 <lambdabot>   [65,66,67]
20:16:53 <sero> parcs, pretty much, yeah, I run lambdabot and another haskell bot in a channel I'm in, and a commonly used feature is using the bots to get weather data (I used to run supybot in there). It'd be nice to have such a thing on the haskell bot(s) there now.
20:16:55 <ash_> mzero: well, its a string from a parser and the symbols represent things
20:17:01 <mzero> AH
20:17:09 <mauke> ash_: what is the question?
20:17:12 <mzero> so you need a function that maps Char -> MyType
20:17:14 <mzero> then just map
20:17:21 <ash_> ya, i realize that now
20:17:28 <ash_> sometime asking the question helps me realize the answer
20:17:29 * roconnor often thinks ddarius must think he is an idiot.
20:17:52 <mzero> indeed - framing the question is often the quickest path to the answer
20:18:13 <ddarius> roconnor: If you had a semaphore that was raised when "either m or n" happened, you'd already have a solution to the problem.
20:19:25 <ddarius> roconnor: At any rate, that wouldn't work because m or n or both may be emptied before you "check" them.
20:22:17 <roconnor> \mv1 mv2 -> do {nv <- newEmptyMVar; forkIO (do {x <- takeMVar; putMVar nv (Left x)}); forkIO (do {y <- takeMVar; putMVar nv (Right y)}); return nv}
20:22:35 * roconnor has never written concurrent code in Haskell before
20:23:35 <int80_h> is it insane to want to put MVars inside a data record?
20:23:42 <ddarius> int80_h: Not at all.
20:23:46 <c_wraith> No, that's normal
20:23:50 <int80_h> whew, because that's what I need
20:23:52 <c_wraith> Even nesting MVars is normal
20:24:21 <_Ray_> If en_rango :: Posicion -> Bool, why is this wrong? generar :: Posicion -> (Posicion -> Posicion) -> [Posicion], generar = (takeWhile en_rango) . (flip iterate)
20:24:40 <_Ray_> I want to repeatedly apply a given function, until en_rango of the result isn't true anymore.
20:24:52 <int80_h> oh like MVar PC where PC is a data record with MVars in it?
20:24:59 <c_wraith> int80_h: yep
20:25:01 <ddarius> roconnor: That leaves a thread that will empty the losing MVar.
20:25:05 <mauke> roconnor: if both mv1 and mv2 are full, your code will empty them both
20:25:40 <roconnor> oh
20:25:55 <kmc> :t mfix (fmap In . newMVar)
20:25:56 <lambdabot> Not in scope: `newMVar'
20:26:20 <mzero> _Ray_:   you need   ((takeWhile en_rango) .) . (flip iterate)
20:26:46 <_Ray_> Hrmph.
20:26:56 <mzero> a . b will have b take one arg, then apply a to the result
20:27:03 <mzero> you want b to take two args, then apply a
20:27:04 <copumpkin> kmc and his funky fixpoints
20:27:15 <lispy> :t In
20:27:16 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
20:27:28 <parcs> @src Mu
20:27:29 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
20:27:29 <jmcarthur> not always, but sometimes, if you start nesting MVars you might actually want to consider switching to STM
20:27:32 <_Ray_> So in the general case where b takes n args, I should do .) .) .) ..... .) n times, mzero?
20:28:08 <roconnor> \mv1 mv2 -> do {nv <- newEmptyMVar; forkIO (do {x <- takeMVar mv1; b <- tryPutMVar nv (Left x); unless b (putMVar mv1 x)}); forkIO (do {y <- takeMVar mv2; b <- tryPutMVar nv (Right y); unless b (putMVar mv2 y)}); return nv}
20:28:20 <lispy> _Ray_: pointfree notation looks hideous when used that way, IMO
20:28:22 <mzero> :t  ((+ 7).). (*)
20:28:23 <lambdabot> forall a. (Num a) => a -> a -> a
20:28:34 <roconnor> mauke: see if I take it then I put it back and no one is the wiser!
20:28:42 <_Ray_> ah
20:28:48 <roconnor> mauke: wait this isn't quite good enough
20:28:49 <mzero> _Ray_ - I don't know -- beyond two, I don't try to use point-free style
20:28:50 <carlo_au> is there any way to avoid all the indentation in this code snippet? (alloca'ing a bunch of C pointers)    https://gist.github.com/1187895
20:28:55 <int80_h> could someone paste a simple record with MVars and populate it? I need to see what that looks like.
20:28:57 <_Ray_> yeah, that makes sense
20:29:03 <xil> does anyone know if I should be asking in my OS channel about my problem? It appears as if the instance of ffmpeg that I spawn with runInteractiveProcess just stops working when the terminal loses focus, even though the rest of the program keeps working
20:29:16 <jmcarthur> carlo_au: those don't all have to be do blocks
20:29:21 <jmcarthur> i will annotate
20:29:30 <jmcarthur> *fork
20:29:38 <ddarius> roconnor: Taking out and putting back just creates a race condition.
20:29:45 <carlo_au> jmcarthur: cool, thanks
20:29:55 <lispy> xil: hmmm
20:30:02 <roconnor> ddarius: oh right, I could get premempted
20:30:03 <lispy> xil: I think I know what causes that
20:30:41 <lispy> xil: is it possible that ffmpeg uses thread local storage?
20:31:04 <jmcarthur> carlo_au: https://gist.github.com/1187906
20:31:10 <lispy> xil: oh, wait, runInteractiveProcess uses fork()...so, n/m what I'm thinking about
20:32:28 <xil> lispy: I separately fork a small function that monitors the output pipe I get from runInteractiveProcess, to let me know if something is up with ffmpeg
20:33:32 <jmcarthur> carlo_au: in fact, i daresay this looks a lot like something ContT would look nice for, if you end up writing a lot of code like this
20:33:52 <jmcarthur> but really only for prettiness, i guess
20:34:26 <carlo_au> jmcarthur: ah, thanks
20:34:31 <lispy> xil: I was thinking of this othre issue that can come up in threaded Haskell programs that use GUIs, but it's related to thread local storage and so on second thought, I know nothing about your problem.  Sorry!
20:34:59 <carlo_au> jmcarthur: so your version works because the $ thing can be used more than once
20:35:15 <carlo_au> jmcarthur: and these are just functions being chained together
20:35:20 <xil> lispy: are you sure it doesn't apply to mine? I use GUIs and threading
20:35:29 <jmcarthur> carlo_au: ($) is just a normal operator
20:35:56 <jmcarthur> carlo_au: and it's actually functions being nested (having the same structure as your do notation version)
20:35:59 <lispy> xil: hmm...well, runInteractiveProcess forks a new process.  So I wouldn't expect the problem to be there, but let me dig up the email threads about what I know
20:36:08 <carlo_au> jmcarthur: I was under the impression that it was some fancy syntactic sugar thing
20:36:29 <jmcarthur> carlo_au: (you can ignore my ContT remark. i didn't realize you were still in the early stages here)
20:36:43 <NemesisD> anyone know how to compose enumeratees properly?
20:37:00 <jmcarthur> carlo_au: nope, it's literally defined like this:     f $ x = f x
20:37:05 <roconnor> ddarius: this is tough
20:37:20 <dalaing> it' just function application with really low precedence
20:37:25 <jmcarthur> carlo_au: and it has a fixity declaration to make it parse a little differently from normal function application
20:37:38 <carlo_au> jmcarthur: right
20:37:49 <lispy> xil: This thread contains pretty much everything I know about the subject: http://www.haskell.org/pipermail/haskell-cafe/2011-July/093722.html
20:37:51 <jmcarthur> it's right associative and binds very loosely
20:38:02 <carlo_au> jmcarthur: i just need to wrap about 10 of these sorts of functions (NetCDF library) so I can do a small prototype
20:38:10 <jmcarthur> the fixity declaration is something you are allowed to do with any operator you define though. no magic :)
20:38:30 <carlo_au> jmcarthur: ah
20:39:36 <carlo_au> jmcarthur: that code isn't compiling: hnetcdf.hs:48:2: parse error (possibly incorrect indentation)
20:39:49 <carlo_au> where line 48 is the second alloca
20:40:53 <jmcarthur> oh sorry
20:40:55 <jmcarthur> remove the first do
20:41:06 <jmcarthur> the only do you need is the last one
20:41:43 <xil> lispy: thanks
20:41:53 <carlo_au> jmcarthur: ah, that works
20:42:25 <roconnor> mauke: boy STM is looking nice now.
20:42:55 <joe6> source: http://codepad.org/c4uoeWrw, error: http://codepad.org/NZf7Q4Ve
20:43:08 <joe6> i am getting the dreaded ambiguous variable error
20:43:35 <mauke> joe6: where?
20:43:40 <joe6> is there any way that I can use the typeOf of a variable to deduce the type signature?
20:44:20 <jmcarthur> carlo_au: for a preview of some of the awesomeness that is ContT, see what i added below: https://gist.github.com/1187906   (warning, untested)
20:44:29 <lispy> xil: good luck, I'm off to bed
20:44:40 <hpaste> int80_h pasted “MVars in a data record” at http://hpaste.org/50865
20:44:44 <joe6> or, is there anything else I can do to fix such errors?
20:44:46 <xil> lispy: good night
20:45:03 <joe6> other, than having to add a type signature explicitly? I use a type variable, now.
20:45:05 <mauke> joe6: the error your pasted has nothing to do with ambiguity
20:45:17 <mauke> *you
20:45:27 <joe6> oh, sorry
20:45:31 <joe6> mauke, sorry.
20:45:36 <joe6> mauke, wrong message.
20:46:43 <NemesisD> anyone? enumeratees seem like they should be very easy to compose
20:46:51 <Cale> int80_h: As in, testState has empty MVars in it, and you have values of type ServerModel -> FilePath -> IO (), Int, and Bool which you want to fill them with?
20:47:36 <int80_h> Cale: yes
20:48:13 <int80_h> Cale: I tried a few different things but got parse errors. Out of ideas.
20:48:21 <carlo_au> jmcarthur: that compiles :)   very nice, thanks
20:48:33 <joe6> source: http://codepad.org/h6g1sng7 , error: http://codepad.org/iKNKZSAa
20:48:52 <ddarius> roconnor: I believe it is provably impossible.  The issue is to get multiple uncooperative entities to agree on something.  A solution for n does not provide a solution for n+1.
20:49:09 <dalaing> I was (and mostly still am) completely ignorant of iteratees/enumeratees/etc at the start of the week - now I find myself getting kind of invested in whether or not NemesisD gets an answer
20:49:21 <joe6> any suggestions that can help me out with the ambiguous type variable  message?
20:49:29 <Cale> fillState p j l (PS pv jv lv) = do putMVar pv p; putMVar jv j; putMVar lv l
20:49:44 <Cale> (of course, you can use record syntax too)
20:49:45 <ddarius> roconnor: For example, synchronous channels are more "powerful" than asynchronous channels, since that allows two people to agree about when something happened.  You can -encode- synchronous channels with asynchronous ones, but that requires global cooperation.
20:49:53 <mauke> joe6: well, what type is it supposed to be?
20:50:29 <joe6> it is a "Ptr a", and a can be any of the Foreign.C.Types (such as CUInt or CInt) or such that.
20:50:30 <roconnor> mauke: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/GHC-Event.html -- is this what you were talking about for IOCallbacks ?
20:50:40 <joe6> but, I will not know that until I start writing the instance.
20:50:53 <mauke> joe6: how is ghc supposed to know?
20:51:06 <joe6> or, should I make the typeclass have 2 variables, one for the type?
20:51:19 <joe6> and fill it in while writing the instance?
20:51:58 <joe6> i don't think that is possible, though.
20:52:06 <int80_h> Cale: That notation looks straightforward. I tried using record notation and got parse errors.
20:52:59 <joe6> typeclass with inductivy types (just thinking aloud here..)
20:53:06 <joe6> s/vy/ve/
20:53:10 <ddarius> What do you call cubing foodstuff into cubes smaller than the cubes produced by dicing?
20:54:06 <Cale> int80_h: What did you try?
20:54:37 <int80_h> Cale: attempt one ...
20:54:42 <int80_h> Cale: let testState = PS { processing = undefined, putMVar jobCount = 1, lock = undefined }
20:54:46 <Jafet> ddarius: skillful
20:54:50 <int80_h> Cale: attempt two ...
20:55:05 <int80_h> Cale: let testState = PS { processing = undefined, putMVar jobCount 1, lock = undefined }
20:55:25 <Cale> int80_h: putMVar makes an IO action, which is the wrong type to be a field of the record
20:55:37 <Cale> because the record isn't supposed to contain IO actions, it's supposed to contain MVars
20:55:50 <ddarius> The syntax is all wrong anyway.
20:56:08 <Cale> (that is also true)
20:56:35 <int80_h> Cale: yeah I was taking a stab in the dark. This is new territory.
21:09:18 <copumpkin> joe6: what error does it give you?
21:10:37 <joe6> copumpkin: http://codepad.org/rMxnE6iK
21:10:48 <joe6> copumpkin: source: http://codepad.org/O7y5q06E
21:11:24 <copumpkin> oh, the error is in value, not valueOf?
21:11:39 <joe6> yes, I could not get both to work.
21:11:45 <copumpkin> the comment made it look like valueOf was broken :P
21:11:48 <joe6> commented out valueOf
21:12:09 <int80_h> Cale: I created a fooState :: ProcessState by doing this "let fooState = PS {processing = undefined, jobCount = undefined, lock = undefined}. When I tried to do this (in ghci) "example <- fillState undefined 5 True fooState" I got this error "*** Exception: Prelude.undefined"
21:12:14 <copumpkin> oh, this is the thing dolio was talking about earlier
21:12:27 <copumpkin> joe6: you have given it no way to determine what format to load
21:12:31 <joe6> yes.
21:12:33 <int80_h> Cale: what did I do wrong?
21:13:28 <Cale> int80_h: I assumed you had empty MVars in the record rather than just having undefined fields
21:13:48 <Cale> You can't ever use the value undefined for anything or you get an error like that.
21:13:52 <int80_h> Cale: oh how do I put in empty MVars?
21:14:07 <Cale> newEmptyMVar :: IO (MVar a)
21:14:14 <copumpkin> joe6: you can give it a dummy parameter that you don't use, and just gets used to determine what instance to use
21:14:17 <Cale> There's also newMVar :: a -> IO (MVar a)
21:14:27 <int80_h> Cale: in context of a ProcessState
21:14:30 <joe6> copumpkin: that is smart.
21:14:32 <Cale> You should look at the Haddock documentation for Control.Concurrent.MVar
21:14:51 <joe6> copumpkin: that was the kind of suggestion I was looking for. a workaround.
21:15:01 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/Control-Concurrent-MVar.html
21:15:23 <copumpkin> joe6: or your class provides a size type, and that should be all you need for that value method
21:15:30 <int80_h> Cale: I understand how to use that when I am dealing with simple types like an Int, but not a data record.
21:15:37 <copumpkin> joe6: you just probably need to peek bytes individually that way
21:15:44 <copumpkin> or some fixed-size chunk
21:15:56 <Cale> int80_h: There's nothing special about records. You construct them with the data constructor, and you deconstruct them with pattern matching.
21:18:38 <joe6> copumpkin, can you please give more details on this, "or your class provides a size type, and that should be all you need for that value method"
21:18:56 <copumpkin> class BitField bitField where
21:18:56 <copumpkin>    sizeOf         :: bitField -> Int
21:19:03 <copumpkin> all you need for a list of Bool is that sizeOf?
21:19:59 <copumpkin> this class seems kind of confused though
21:20:06 <joe6> i need this too "cSymbol        :: (Storable a, Bits a) => bitField -> Ptr a
21:20:19 <joe6> copumpkin: this is my interface to access C bitfields
21:20:32 <joe6> I have a bunch of C global variables, that have bitfields.
21:20:37 <joe6> Which I set/clear
21:21:06 <joe6> and I am using this class to set/read/clear/write the bitfield in that C global variable (C symbol)
21:21:30 <joe6> copumpkin: cSymbol gives me the corresponding pointer to C global variable.
21:21:58 <joe6> and valueOf reads the corresponding C global Variable value.
21:22:11 <joe6> and sizeOf is the size of the bitFields in that structure.
21:22:19 <copumpkin> what are valid instances of this class?
21:22:48 <joe6> sample C definition: http://codepad.org/gEreimHe
21:23:09 <joe6> EPHSHK or EPSTALL are all valid instances of this class.
21:23:20 <joe6> copumpkin: does that make sense?
21:23:35 <copumpkin> not really
21:24:21 <copumpkin> oh, I guess
21:25:06 <joe6> copumpkin: in the test.h file, I have the U1EP0 defined. and there is a structure called U1EP0BITS. U1EP0BITS = U1EP0.
21:25:15 <copumpkin> ok
21:25:31 <joe6> when I set the U1EP0.EPHSHK to 1, U1EP0 will be 1 too.
21:25:33 <copumpkin> anyway, my point is that
21:25:40 <joe6> as they both have the same memory location.
21:26:02 <joe6> i want to define bitfield instances to each of such bitfields such as EPHSHK..
21:26:14 <copumpkin> (peek $ (cSymbol n :: Ptr a))
21:26:17 <copumpkin> what do you want that a to be?
21:26:21 <copumpkin> there is no a
21:26:41 <joe6> cSymbol EPHSHK = p'U1EP0
21:27:03 <joe6> p'U1EP0 :: Ptr CUInt
21:27:22 <copumpkin> that's not what    cSymbol        :: (Storable a, Bits a) => bitField -> Ptr a says, then
21:27:22 <_Ray_> What's the syntax for "pattern match this variable's type constructor Foo x, but also bind the entire Foo x to a variable bar"?
21:27:25 <copumpkin> that says forall a
21:27:26 <_Ray_> bar@(Foo x)?
21:27:37 <RayNbow`TU> _Ray_: yup
21:27:41 <copumpkin> joe6: you probably want an associated type then
21:27:46 <_Ray_> Thanks :)
21:27:57 <copumpkin> class BitField bitField where type Thingy bitField :: *
21:28:04 <n0den1te> _Ray_: that's called an "as pattern"
21:28:10 <NemesisD> any of you guys well versed in the art of the enumerator?
21:28:16 <copumpkin> cSymbol        :: bitField -> Ptr Thingy
21:28:16 <_Ray_> Ah, thanks. Was a bit hard to google :)
21:28:25 <copumpkin> cSymbol        :: bitField -> Ptr (Thingy bitField)
21:28:44 <joe6> copumpkin: let me read up on associated type.
21:29:08 <joe6> copumpkin: just want to make sure, does what I mentioned make sense to you?
21:29:24 <RayNbow`TU> every time I see "hard to Google", I have to think of PHP's design rationale...
21:30:29 <copumpkin> joe6: more or less :)
21:30:29 <copumpkin> http://codepad.org/xsdhcLy7
21:31:12 <_Ray_> Hrm, is it wrong to define a function in two lines, each line with a different number of arguments? As so: func Nothing = const False, func (Just a) t = a < t.
21:31:30 <RayNbow`TU> that's an error, yes
21:31:37 <_Ray_> Is there a rationale behind that?
21:31:53 <copumpkin> _Ray_: simplicity in implementation, I think
21:31:56 <joe6> copumpkin: thanks for the modification. I am reading up on associated type. will bother if I have more questions vis-a-vis your recommendation.
21:32:13 <copumpkin> I might be asleep soon :)
21:32:16 <_Ray_> Ah, OK.
21:32:22 <n0den1te> _Ray_: I think you'd understand better if I said that a function is simply a mapping from one type to another. Nothing more, nothing less.
21:32:49 <joe6> copumpkin: will catch you whenever you are available, then. Thanks.
21:33:14 <joe6> copumpkin: i want to understand the rationale (instead of just copying your code)
21:33:24 <_Ray_> well yes, but there's a lot of syntax magic going on when one says "func (Just a) t", I'm somehow mapping "two values", even though the real thing is mapping (Just a) to a function that takes t and blah blah.
21:33:34 <copumpkin> joe6: when you wrote  cSymbol        :: (Storable a, Bits a) => bitField -> Ptr a in your class
21:33:51 <copumpkin> that means for ALL types a that are instances of Storable, Bits, a function from bitField to Ptr a
21:33:57 <_Ray_> in that sense, func :: Maybe a -> a -> Bool is the same as func :: Maybe a -> (a -> Bool)
21:34:08 <copumpkin> joe6: so I could pick a massive structure and ask for it from your bitfield when I called cSymbol
21:34:13 <n0den1te> _Ray_: Exactly.
21:34:23 <copumpkin> joe6: more logical is that you have a specific Storable type attached to your bitField
21:34:26 <copumpkin> because it has a size
21:34:52 <joe6> yes, that is a good thing to do.
21:35:00 <joe6> similar to inductive types, i guess.
21:35:06 <_Ray_> so it seems it'd make sense to define func once as something that takes two parameters (Maybe a and a, in the usual func (Just x) t syntax) and once as something that takes a Maybe a and returns an a -> Bool
21:35:58 <copumpkin> joe6: similar to existentials, in a way
21:36:13 <n0den1te> _Ray_: what do you say about: somefunc = foldl (\x _ -> x + 1) 0 ?
21:36:24 <joe6> ok, thanks a lot.
21:36:28 <_Ray_> I say that's fine
21:36:59 <_Ray_> and that it should be the same as somefunc f = foldl (\x -> x+1) 0 f
21:37:10 <n0den1te> _Ray_: Well, I meant that every function that can take more than one parameter is actually chained from several partially applied functions.
21:37:34 <_Ray_> right, and that usually is transparent, except here, when one wants to use both of these aspects of a function to define it, as opposed to sticking to just one
21:37:37 <n0den1te> _Ray_: that's a partially applied function (computes the length of a list using foldl)
21:38:02 <n0den1te> @type foldl (\x _ -> x + 1) 0
21:38:03 <lambdabot> forall a b. (Num a) => [b] -> a
21:38:08 <_Ray_> indeed
21:38:30 <newsham> ?pl \x _ -> x + 1
21:38:31 <lambdabot> const . (1 +)
21:39:32 <n0den1te> _Ray_: so it doesn't make any case for function overloading except that you can only have two different functions that does different tasks.
21:39:51 * _Ray_ couldn't parse that :(
21:40:15 <n0den1te> _Ray_: hmm?
21:40:24 <_Ray_> I didn't understand your previous sentence
21:41:45 <n0den1te> _Ray_: Well, if you find a need to overload functions with variable number of args, make them separate functions or do a bit more reflection on your design. ;)
21:43:01 <_Ray_> it was just for brevity, that's all
21:43:15 <_Ray_> could've used func Nothing _ = False, decided func Nothing = const False
21:43:27 <_Ray_> didn't like (not-)binding parameters that I wasn't going to use
21:44:07 <n0den1te> better.
21:44:15 <int80_h> :q
21:45:15 <_Ray_> yeah, but it turned out I can't :p
21:53:43 <n0den1te> _Ray_: heh. Why not?
21:53:58 <_Ray_> because I had already defined func (Just x) t = t < x
21:54:09 <_Ray_> and when I tried func Nothing = const False, ghci complained
21:54:14 <_Ray_> this is the error I was talking about :)
21:54:21 <n0den1te> _Ray_: ok, why not define it like this.... func (Just x) = (<) x
21:54:34 <_Ray_> I sure can, but I found it a bit uglier
21:54:56 <n0den1te> _Ray_: ding ding.. partially applied functions.
21:54:59 <drbean> _Ray_: No, it's cool.
21:55:52 <n0den1te> _Ray_: (<) is in prefix form
21:55:56 <_Ray_> yeah
21:56:05 <_Ray_> I know it works and why, I just found it aesthetically ugly :)
21:56:46 <n0den1te> well, to each their own I guess. :)
22:08:32 <quicksilver> _Ray_: it's been suggested before as an enhancement (to lift the restriction on the the numbers of syntactic parameters being the same
22:20:26 <n0den1te> quicksilver: haven't seen anything like that. Do you know what came of it?
22:21:10 <mauke> is rob pike kinda stupid?
22:21:15 <n0den1te> quicksilver: or any links ?
22:22:14 <quicksilver> n0den1te: nothing came of it; nobody cared enough to do it
22:24:01 <quicksilver> n0den1te: some of the problems are in this thread - http://www.haskell.org/pipermail/haskell-cafe/2008-January/038103.html
22:26:47 <hpaste> “_Ray_” pasted “Tree fold” at http://hpaste.org/50867
22:27:06 <_Ray_> Does that make sense for a (rose-)tree fold?
22:30:55 <Cale> The type should be  (a -> [c] -> c) -> Tree a -> c
22:31:30 <Cale> (for the most natural fold)
22:32:02 <_Ray_> How does that deal with leaves?
22:32:13 <_Ray_> Oh, a -> [c].
22:36:18 <_Ray_> Cale: treefold f (Node t xs) = f t (map (treefold f) xs)?
22:39:52 <dmwit> _Ray_: In general, fold :: Functor f => (f a -> a) -> (Fix f -> a); fold body (Fix f) = body (fmap (fold body) f)
22:40:16 * _Ray_ has only a passing knowledge of the type-based fixpoint
22:40:20 <ion> @src Fix
22:40:20 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:40:36 <dmwit> newtype Fix f = Fix (f (Fix f))
22:40:39 <_Ray_> data Fix f = Fix (f (Fix f))
22:40:43 <_Ray_> that :p
22:40:47 <dmwit> newtype, to avoid extra undefined's
22:40:51 <ion> Ah, a synonym for Mu?
22:40:58 <dmwit> Sure, Mu if you prefer.
22:41:25 <ion> I don’t have a preference, i’ve just happened to encounter that by the name of Mu before.
22:42:33 <copumpkin> Fix saves you from having to decide whether to call it Mu or Nu
22:42:52 <ddarius> LFP GFP
22:43:13 <dmwit> newtype BothFixedPoints f = ...
22:54:35 <mauke> ahhh. do you know how good it feels not having to think about integer (or floating) overflows?
22:55:11 <shachaf> mauke: 4.8?
22:55:23 <mauke> MORE
22:55:29 <shachaf> 6.2?!
22:55:49 <mauke> still annoying that I have to implement threadDelay myself
22:56:08 <shachaf> Why do you have to do that?
22:56:10 <shachaf> Oh, for Integer.
22:56:20 <shachaf> There's a module on Hackage for Integer threadDelay.
22:56:30 <mauke> is it good?
22:57:39 <mauke> answer: no
22:57:54 <shachaf> Why not?
22:58:54 <mauke> the module works by calling threadDelay in a loop. "There is no guarantee that the thread will be rescheduled promptly when the delay has expired".
22:59:06 <mauke> the module doesn't compensate for this, so errors accumulate
22:59:29 <shachaf> Ah.
22:59:35 <shachaf> Are your delays long enough that it matters?
22:59:48 <mauke> no idea, but why bother thinking about it?
23:00:03 <mauke> also I don't like the use of /= instead of <
23:00:11 <mauke> also, pretentious UnicodeSymbols everywhere
23:00:49 <shachaf> http://hackage.haskell.org/packages/archive/unbounded-delays/0.1.0.2/doc/html/src/Control-Concurrent-Thread-Delay.html doesn't have them.
23:01:19 <mauke> delay ∷ Integer → IO ()
23:01:29 <shachaf> Oh, yes.
23:01:44 <mauke> and the α type variables in the Timeout docs
23:02:05 <Eduard_Munteanu> Why bother about Integer delays?
23:02:23 <mauke> because Int is only like 22 minutes
23:02:31 <mauke> I can exceed that easily
23:02:42 <Eduard_Munteanu> Hm, but then why bother about scheduling latency? :)
23:02:56 <mauke> because scheduling latency is unbounded
23:04:00 <shachaf> I guess on a 32-bit machine it matters.
23:06:21 <Eduard_Munteanu> Oh, I see, you're worried each partial sleep could be significantly longer than the prescribed amount of time.
23:06:38 <Eduard_Munteanu> *significant in the sense it adds up.
23:06:45 <shachaf> mauke: How does your threadDelay work?
23:06:56 <mauke> it doesn't yet :-)
23:07:02 <mauke> give me a minute to finish it
23:08:23 <Eduard_Munteanu> You probably want to use something like signals to wake up your thread/process if you care about long sleeps.
23:08:52 <Eduard_Munteanu> Something like what cron does, since I suppose those timescales are more likely to be problematic.
23:09:58 <mauke> why signals?
23:10:55 <Eduard_Munteanu> Not necessarily that, but I mean you could have a separate thingy periodically checking the time instead of just looping around threadSleep
23:12:00 <Eduard_Munteanu> Dunno, I'm thinking in C terms.
23:12:03 <mauke> what's the difference?
23:13:59 <Eduard_Munteanu> You can check the time spent sleeping against the system clock with "arbitrary" accuracy.
23:14:03 <n0den1te> seq bites my a*se. :/
23:14:07 <mauke> shachaf: http://hpaste.org/50877 - completely untested
23:15:47 <Eduard_Munteanu> Oh hm, you're right, you don't need any separate thingy :)
23:16:21 <ion> Floating overflows? Like, the Double larger than (2-2^^(-52)) * 2^(2^10-1)?
23:16:59 <mauke> > (2-2^^(-52)) * 2^(2^10-1)
23:17:00 <lambdabot>   1.7976931348623157e308
23:17:09 <Eduard_Munteanu> In the sense they're bounded, yeah.
23:17:09 <mauke> > (2-2^^(-52)) * 2^(2^10-1) :: Float
23:17:10 <lambdabot>   Infinity
23:17:40 <ion> > (2-2^^(-23)) * 2^(2^7-1) :: Float
23:17:41 <lambdabot>   3.4028235e38
23:18:38 <mauke> I'm scaling things around by 1e6
23:18:57 <mauke> because NominalDiffTime is in seconds, but threadDelay thinks in microseconds
23:19:09 <mauke> no problem! NominalDiffTime is backed by an Integer
23:20:00 <mauke> (sadly this is undocumented but that's what the source is for)
23:21:27 <mauke> current mood: http://www.youtube.com/watch?v=JbVE-R1_Izo
23:23:20 <mauke> 「let florp = 」 replaced by 「fix $ \loop -> 」
23:56:52 * hackagebot HaskellForMaths 0.3.4 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.3.4 (DavidAmos)
