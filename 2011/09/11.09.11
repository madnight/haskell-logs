00:00:12 <shachaf> copumpkin: Better way: Use Python.
00:26:16 <copumpkin> alright, I think my binding to libdl is basically done
00:41:19 <mmos1127> say I have a Rational (i.e. Ratio Integer) and want to take "floor" or "ceiling" of it but without converting to floats, resulting in an Integer. how should I do this? break out the numerator/denominator and do integer arithmetic on it?
00:52:08 <Olathe> > floor (3%5 :: Rational)
00:52:09 <lambdabot>   0
00:52:16 <Olathe> > ceiling (3%5 :: Rational)
00:52:16 <lambdabot>   1
00:52:36 <Olathe> @type floor
00:52:37 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
00:53:32 * Olathe knocks on lambdabot.
00:54:00 <kaol> > (3%5 :: Rational)
00:54:00 <lambdabot>   3 % 5
00:58:09 <kaol> But that involves converting it to a float first. Best roll your own if you want to avoid it.
00:58:56 <kaol> floor and ceiling are in RealFrac
00:59:54 <shachaf> That's kind of odd.
01:00:01 <shachaf> Well, you can use properFraction.
01:12:56 <_mmi_> Hi, I want to convert a text to uppercase german letters and digits only. This means "München ist im 'Sommer 2011' & Winter 2011 schön." should get "MÜNCHENISTIMSOMMER2011WINTER2011SCHÖN". How can I archive this? (filter isAlphaNumeric . map toUpper) will print out strange characters.
01:14:06 <engla> _mmi_: it should work fine, use putStrLn to output
01:16:17 <_mmi_> engla: Right, in the console it works, however, the input comes from a file encoded in UTF-8. How can I get that work?
01:19:14 <dave1231> does the text package help with that sort of thing?
01:19:59 <dave1231> I'm pretty newb-ish, so I'm not sure
01:20:23 <engla> I thought utf-8 would work by default
01:20:37 <engla> maybe that's incidental, I use a utf-8 locale
01:25:26 <Gagis> well doesnt every OS use utf-8 locales by default nowadays
01:28:00 <_mmi_> With hSetEncoding utf8 it works.
01:29:17 <Gagis> so even haskell doesn't use it by default? Goddamnit. Operating systems have moved to the standard since 80's but compilers still use random crap by default resulting in conflicting applications. -_-
01:32:29 <engla> Gagis: apparently haskell uses the locale encoding by default
01:32:39 <engla> which is the right thing to do
01:32:57 <engla> applications should specify the encoding they want to use anyway
01:33:45 <Gagis> ah, alright.
01:41:19 * hackagebot trifecta 0.42 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.42 (EdwardKmett)
01:53:38 <herself> hello o/
01:59:33 <Shigi> Hi.
02:00:19 <shachaf> @ahoy Shigi
02:00:19 <lambdabot> "Shigi"
02:07:26 <hpaste> kizzx2 pasted “Data.Enumerator leak?” at http://hpaste.org/51226
02:07:50 <kizzx2> hey guys, can anyone spot any probelm with this ? http://hpaste.org/51226
02:08:31 <kizzx2> i'm using Data.Enumerator and the 4 line program above is mysteriously building up 1GB of RAM to read a 1GB file (i thought the list could be GC'ed?)
02:09:14 <maltem> Doesn't EL.consume basically defeat the point of using enumerators?
02:09:34 <kizzx2> i thought the list's head could be GC'ed as long as nobody is using it
02:09:34 <kizzx2> ?
02:10:22 <maltem> The list produced by EL.consume will be in memory as a whole I think
02:10:29 <kizzx2> o
02:10:36 <kizzx2> is there a way to achieve a Lazy consume?
02:10:47 <kizzx2> i thought that's the whole point of EL.consume :P
02:10:52 <kizzx2> to make a lazy list
02:11:05 <maltem> you'd rather want to avoid lists, and do an iteratee fold
02:11:18 <maltem> Possibly involving EL.fold or EL.foldM
02:15:05 <kizzx2> argh
02:15:37 <kizzx2> i thought getting a lazy list out of the Enumerator eco-system would make it an authentic Lazy IO improvement
02:15:48 <kizzx2> s/out of/out from/
02:16:40 <maltem> no, it is an improvement over Lazy IO by not providing any Lazy IO, at the cost of a more involved API
02:17:16 <kizzx2> i think it makes sense
02:17:18 <yitz> a *much much* more involved API
02:17:26 <kizzx2> since the file must be closed after the enumerator has finished running
02:17:37 <yitz> that virally infects your entire program, even the pure parts
02:17:51 <kizzx2> yitz: i guess the same applies for Lazy IO
02:17:55 <kizzx2> it's just that you don't notice it
02:17:57 <Jafet> Like prions?
02:18:01 <kizzx2> and error can lurk out in pure codes
02:18:03 <kizzx2> behind your back
02:18:30 <yitz> kizzx2: no that's the whole point, lazy io just passes the processing into pure code, where you write with natural haskell techniques.
02:18:52 <yitz> kizzx2: at the io level you have to understand the semantics of the lazy io and make sure you are using it correctly.
02:19:22 <yitz> kizzx2: in cases where that works - which is most cases in practice - you're then fine in nice idiomatic haskell code
02:19:28 <kizzx2> yitz: so that's also a burden on the programmer — he needs to use it correctly or IO error can occur in pure code?
02:19:36 <maltem> But in cases where this does not work, you're stuck
02:19:54 <kizzx2> i guess Enumerator just makes it more type safe and annotate IO code noisily
02:19:55 <maltem> kizzx2, that's right
02:19:57 <yitz> kizzx2: whereas with enumerator you are basically forced to abandon haskell and write scheme-style CPS spaghetti code in haskell syntax
02:20:01 <kizzx2> and instrusively
02:20:26 <yitz> maltem: right. which is very rare. but when it happens, you need an alternative.
02:20:40 <kizzx2> and the alternative might me?
02:20:48 <kizzx2> s/me/be
02:21:07 <yitz> maltem: first choice for me in that case is one of the strict io frameworks, where you can still often salvage some idiomatic haskell.
02:21:09 <maltem> kizzx2, it's not really about type-safe but rather about control over IO resources
02:21:27 <kizzx2> yeah that's true
02:21:29 <yitz> maltem: but where even that becomes messy, enumerator is the right choice. and that does happen, yes.
02:21:58 <edwardk> and worse because the enumerator iteratee implementation isn't CPS'd you'd better completely right associate your code into tail call form =(
02:22:06 <yitz> kizzx2: the alternative is usually lazy io, which works great most of the time.
02:22:11 <maltem> sounds like good advice. I do find iteratee code to be hard to get right
02:22:35 <kizzx2> i guess i was have been reading too much "Lazy IO considered harmful" stuffs lately
02:23:00 <maltem> Not necessarily too much, it *is* harmful :)
02:23:10 <yitz> maltem: the catch, of course, is that although lazy io looks deceptively straighforward, you can get into trouble if you don't understand the gotchas.
02:23:19 <Jafet> Haskell just needs a library for you to take filesystem snapshots
02:23:35 <maltem> One scenario is "many files", btw
02:24:06 <yitz> maltem: mmm, not always. that raises red flags, but it's still often possible. depends on what you want to do.
02:24:42 <kizzx2> so i guess the point for Enumerator is that you actually can't get a lazy list out of the eco system, and you know exactly the file is closed after run_
02:24:50 <yitz> maltem: part of the problem also is that because iteratees became all the rage, we are still missing some sorely need lazy io combinators.
02:25:33 <yitz> kizzx2: right. another way to do that is to read the file strictly. of course, then you get the whole thing in memory at once.
02:27:07 <swenedo> Hi
02:27:14 <yitz> as soon as i finally get this huge project at work done (for which i am using lazy io btw), working on some lazy io combinators is on my pet project to do list
02:28:13 <yitz> maltem: in the meantime, you have to be willing to get your hands a little dirty and write some low-level combinators yourself using unsafeInterleaveIO.
02:28:26 <yitz> when you need them
02:28:33 <yitz> hi swenedo
02:28:40 <b_jonas> lazy IO combinators?
02:29:25 <swenedo> I'm just trying some Haskell .. just started a functional programming course at uni.. :)
02:29:42 <maltem> yitz, what combinators would that be?
02:30:35 <yitz> b_jonas maltem: well, when you want to process multiple files, or split one file and process parts of it by different pure functions, etc. that kind of thing.
02:30:53 <yitz> ensure files get fully read and closed in certain situations.
02:31:09 <b_jonas> hmm
02:31:32 <yitz> in short, the kinds of situations where you start to have trouble in lazy io but it still could work out nicely if the right combinators would spring to your hand.
02:31:56 <yitz> here's an example of one i did get around to publishing:
02:32:01 <yitz> @hackage attosplit
02:32:01 <lambdabot> http://hackage.haskell.org/package/attosplit
02:32:40 <yitz> doesn't actually do io, but it's the kind of thing you need
02:33:04 <yitz> and yes, it does need unsafeInterleaveIO behind the scenes.
02:34:27 <maltem> well that does look a little scary :)
02:35:37 <yitz> maltem: dunno. works fine for me. in a live enterprise-scale project, processing enterprise-scale data.
02:35:41 <maltem> I don't spot the unsafeInterleaveIO though
02:37:14 <yitz> maltem: oh, look at that. you're right, i didn't need to use it directly here. :)
02:37:32 <yitz> maltem: i did need to dig into the lazy bytestring internals though, which is pretty much the same thing.
02:38:00 <maltem> ah, the Chunk things
02:38:10 <ski> swenedo : you're welcome. any questions yet ?
02:39:11 * maltem prepares for breakfast at 12:30
02:39:30 <ski> hm, good idea
03:26:25 * hackagebot trifecta 0.43 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.43 (EdwardKmett)
03:26:45 <edwardk> added Layout and Language monads
03:26:58 <edwardk> so you should be able to parse haskell style layout pretty easily now
03:27:19 <shachaf> edwardk: How about parsing YAML?
03:27:59 <edwardk> i haven't really thought about yaml since starting trifecta, hrmm
03:28:10 <edwardk> should work
03:28:23 <edwardk> might make a nice example
03:28:27 <shachaf> edwardk: Do you know http://hackage.haskell.org/cgi-bin/hackage-scripts/package/YamlReference ?
03:28:32 <edwardk> yeah
03:28:44 <edwardk> but it is crash happy on bad input iirc, so i couldn't use it
03:29:03 <edwardk> and it doesn't expose enough of its internals =/
03:29:04 <shachaf> Use it for what?
03:29:14 <portnov> hi all.
03:29:21 <edwardk> i was parsing yaml for a config file at one point
03:29:28 <shachaf> It's meant to be a reference parser, not something for actual use, I think.
03:29:42 <edwardk> yeah, just kinda frustrating to have it there and have it be useless ;)
03:29:43 <yitz> hi portnov
03:29:45 <shachaf> In particular, its source code is almost identical to the spec.
03:30:18 <portnov> Q: are there any ways to compile plugins package using GHC 7.2 ?
03:34:07 <shachaf> edwardk: I happen to know that the author has vague plans to improve it at one point, given sufficient time and such.
03:34:42 <shachaf> There were some issues with performance and space leaks, I think, among other things.
03:35:22 <edwardk> i should have my old parsec parser for it lying around. it'd make a nice trifecta test case / example
03:35:55 <shachaf> I think one of his main issues with Parsec was that it wasn't streaming.
03:37:59 <edwardk> well i don't have those problems in trifecta
03:38:29 <edwardk> and my parsec parser was built on parsec3 over an iteratee base monad, so no problem there either, done right
03:39:59 <atomie> I create a simple module "TestModule.hs" which exports a "testval = 2". I then compile it with "ghc --make" and delete the *.hs file. I then do a "ghci TestModule.o", which succeeds, but the module doesn't seem to be loaded and I cannot access "testval". Why not?
03:45:04 <b_jonas> atomie: so you don't get an error about loading the module?
03:45:20 <b_jonas> atomie: did you at least keep the .hi file?
03:46:25 <jeetu> Hi all. Is there exists some coding conventions for haskell (just as pep8 is for python) and any coding convention checker (like pylint or pep8.py for python)
03:46:25 <atomie> b_jonas: I kept the *.hi file, yes. I get a simple "Loading object (static) TestModule.o ... done" and "final link ... done", and am then shown the ghci prompt with only Prelude in scope.
03:53:59 <Cale> jeetu: http://urchin.earth.li/~ian/style/haskell.html ?
03:54:31 <Cale> jeetu: All the stuff there is pretty uncontroversial.
03:55:20 <Cale> I would add to it that when using if/then/else, any time that the 'then' and 'else' are on separate lines, they should line up with each other, and they should start in a deeper column than the 'if'
03:56:24 <ski> also when `if' and `then' is on the same line ?
04:06:14 <jeetu> That is good.
04:07:34 <jeetu> But it would be better to have a convention scheme on the haskell site. It will aid in readability and may be compulsary for haskell libraries etc.
04:07:44 <jeetu> And an automatic checker will be great
04:08:15 <jeetu> may be someone on haskell mailing list can forward it to the main moderators
04:09:11 <yitz> jeetu: it's very difficult to get all programmers in any language to abandon their own personal style
04:09:46 <yitz> jeetu: even in python, where you have a BDFL, pep8 isn't universally followed.
04:11:47 <jeetu> yitz: Ya, I agree with that
04:12:05 <yitz> kind of like herding cats
04:12:37 <jeetu> yitz: But atleast it provides with a guide so that sooner or later, most of the libraries will start adhering it.
04:13:08 <jeetu> yitz: A automatic checker helps a lot (and our code starts looking more readable)
04:13:43 <jeetu> I have myself used pylint and i appreciates in (in python)
04:14:16 <jeetu> Also someday may be some intelligent programmer can write convertor to make the code follow guideline (written in haskell ofcourse)
04:14:34 <yitz> jeetu: haskell is deep and expressive. so there are many points for which there are several distinct styles. their adherents tend to be passionate, and will never change just because someone published a style guide.
04:16:18 <jeetu> may be not today. But may be somebody can give it a try ( I am a newcomer to haskell so I dont feel like proposing it directly in the mailing list as I dont know haskell thorouhly yet)
04:16:23 <aspect> as a haskell beginner, I'm glad to have that link to give me a default convention to use when I can't immediately decide on one myself.
04:16:34 <yitz> jeetu: it could be very useful for beginners to have a style guide with things most people agree on.
04:17:40 <yitz> aspect: yes. even for things people don't agree on, the style guide can give at least one approach, or a few simple choices.
04:18:15 <obiwahn> type Graph a = [(a,a)]
04:18:17 <jeetu> yitz: are you on mailing list of haskell?
04:18:24 <obiwahn> instance Show a => Show (Graph a) where show (x:xs) = "Edge: " ++ show a ++ "->" ++ show b ++ "\n" ++ show xs where (a,b) = x
04:18:41 <yitz> jeetu: yes. that list is hardly used anymore though.
04:18:46 <obiwahn> what is wrong with that?
04:18:57 <jeetu> yitz: why ?
04:19:23 <yitz> jeetu: mostly haskell cafe is used for general topics. but that has so much traffic now that it's universally read anymore either.
04:20:04 <jeetu> yitz: So if we want to propose this idea, then which is the best place?
04:20:10 <yitz> jeetu: haskell was always intended only for important announcements, and perhaps a few replies to them. not discussions.
04:20:54 <yitz> jeetu: because of that, people started using haskell cafe for announcements. so not much is left of the haskell list anymore.
04:21:18 <yitz> jeetu: haskell cafe definitely
04:21:55 <yitz> jeetu: once you have an actual style guide to announce, you can also do so on the haskell list
04:22:27 <yitz> jeetu: or you can announce on haskell a grant that will pay people to work on the style guide, or something like that :)
04:23:56 <jeetu> yitz: May be someday I will announce some style guide (or a grant) after learning a bit more haskell. :)
04:25:04 <hpaste> kizzx2 pasted “Attoparsec.Lazy memory usage” at http://hpaste.org/51228
04:25:39 <kizzx2> ^ is there something obviously wrong for the above usage of attoparsec.lazy?
04:25:50 <kizzx2> it takes 45 MB to read a 21MB text file
04:25:55 <yitz> jeetu: there are 38 pages about style here: http://www.haskell.org/haskellwiki/Category:Style
04:26:02 <kizzx2> and the -hy profile is very strange http://imgpaste.com/8aWL.png
04:26:10 <yitz> jeetu: some of them are outdated, some are opinionated...
04:26:30 <koeien> kizzx2: the many might be the problem
04:26:40 <jeetu> yitz: And they adds to the confusion
04:27:13 <jeetu> yitz: I hope that someday they will be unified
04:27:20 <yitz> jeetu: here is a more recent style guide, by tibbe: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
04:27:27 <yitz> jeetu: that's a pretty good one.
04:27:29 <koeien> kizzx2: but you'd think it gets collected :)
04:27:44 <kizzx2> koeien: so what's the alternative?
04:28:03 <koeien> kizzx2: ah no, you get [True,True,...] at the end, right?
04:28:07 <kizzx2> ideally i was thinking of getting a lazy list that gets "faulted" and GC'ed as i traverse it later with mapM_
04:28:11 <kizzx2> koeien:  yeah
04:28:31 <koeien> kizzx2: attoparsec needs to put the whole result into memory, in case the parsing fails.
04:28:54 <kizzx2> koeien: argh, that confirmed my suspicion
04:29:05 <kizzx2> what's cleanest/most idiomatic way to achieve this?
04:29:11 <Cale> jeetu: One thing you'll notice is that Haskell programmers tend not to care about exactly how much stuff is indented by, but they *do* care that everything lines up right.
04:29:20 <kizzx2> let's say, extract all "digits" as a lazy list that can be forced and GC'ed
04:29:58 <koeien> filter isDigit :)
04:29:59 <Cale> jeetu: (because it has a tendency to matter, but even when it doesn't actually matter in the sense of making the meaning of the code different, it helps readability to have things line up into tables)
04:30:30 <kizzx2> koeien: arch, well i guess that example got too simplied, let's say exract a list of strings of exactly 3 digits in succession in teh file, as a lazy list?
04:30:51 <kizzx2> so ["395", "100"]
04:31:02 <kizzx2> (no filter length plz, i'm kind of looking for an attoparsec way)
04:31:04 <yitz> Cale: they *do* care about no tabs, too.
04:31:11 <Cale> Yes! :)
04:31:15 <koeien> kizzx2: instead of lazy IO, which is evil, you could use iteratees/enumerators.
04:31:27 <Cale> Tab characters are evil and must be eradicated
04:31:32 <kizzx2> i asked exactly about enumeratees a couple of hours ago here
04:31:32 <yitz> koeien: which is even more evil!
04:31:36 <kizzx2> you can see yitz
04:31:37 <kizzx2> o
04:31:39 <kizzx2> hi yitz :)
04:31:41 <koeien> yitz: why :)
04:31:41 <yitz> haha
04:31:46 <Cale> jeetu: and I haven't checked recently, but I know that at least some of the tutorials for Haskell have the golden rule of indentation: anything which is part of something else should start in a deeper column, and things which are on the same level should line up.
04:31:46 <kizzx2> ok in short
04:32:04 <kizzx2> enumeratee exactly does the opposite of what i want, it seems the point of enumeratee is more about determinsitics file handle
04:32:13 <yitz> koeien: it forces your entire program to be non-idiomatic haskell, and quite messy
04:32:18 <kizzx2> and i tried the same experiment it seems like enumerators must read everything before closing
04:32:23 <kizzx2> or you must put your whole program in CPS
04:32:53 <yitz> koeien: but it does relieve you of thinking for a moment about whether you are misusing lazy io.
04:33:04 <koeien> yitz: most certainly.
04:33:06 <koeien> :
04:33:21 <hpaste> obi pasted “instance declaration for `Show (” at http://hpaste.org/51229
04:33:23 <kizzx2> yitz: so what do you recommend for archieving "pipe this file through the parser, and get a lazy list of the survivors" ?
04:33:31 <Cale> Yeah, iteratee/enumeratee seem to fail really hard when it comes to being abstract, which at least lazy IO manages to do (even if it does a little evil to accomplish it)
04:33:45 * applicative is doing a little lazy io now just to be contrary
04:34:01 <yitz> kizzx2: the problem there is not lazy io.
04:34:01 <kizzx2> s/file/binary file/
04:34:19 <kizzx2> yeah i think the problem here is attoparsec?
04:34:24 <kizzx2> which must accumulate the result
04:34:36 <obiwahn> what is wrong with my show?
04:34:48 <yitz> kizzx2: attoparsec itself is a continuation-style library. it is designed to be used by reading fairly small chunks of input at a time and parsing them separately.
04:35:02 <koeien> obiwahn: yes, you cannot declare an instance of a type. You can enable TypeSynonymInstances. this allows you to do it, but you sometimes might get confusing results (not a big problem for Show)
04:35:07 <yitz> kizzx2: it is very fast in that usage.
04:35:20 <koeien> obiwahn: but {-# LANGUAGE TypeSynonymInstances #-} at the top of your code
04:35:20 <kizzx2> yitz: so what do you recommend for "pipe this 100MB file through the parser and get a lazy list of products"?
04:35:39 <kizzx2> or something similar to that effect?
04:35:53 <obiwahn> ok if it was not a type but a data type declaration it should work?
04:36:00 <yitz> kizzx2: the lazy version of attoparsec just relieves you of doing your own bookkeeping when the source of your input is lazy, but it's still meant to be used a small chunk at a time.
04:36:01 <koeien> obiwahn: yes
04:36:23 <koeien> > show ("hello world" :: [Char])
04:36:23 <yitz> kizzx2: what delimits the products in the input?
04:36:24 <lambdabot>   "\"hello world\""
04:37:03 <kizzx2> yitz: well, let's say a magic sequence "HELLOWORLD502" will follow 502 bytes of message
04:37:15 <kizzx2> so we scan for hello world, take a number and then read from there
04:37:20 <kizzx2> there will be junk in between
04:37:28 <kizzx2> which need to be skipped
04:38:31 <kizzx2> the output should be [String] which are the messages
04:39:11 <yitz> kizzx2: i would probably just use Text or ByteString functions for that.
04:39:23 <yitz> kizzx2: oh, String? Why not Text?
04:39:45 <kizzx2> yitz: umm sorry i was again over simplifying
04:39:53 <kizzx2> let's say 502 is in little endian bytes
04:40:03 <kizzx2> then then there are a couple of binary data after the magic sequence
04:40:29 <kizzx2> i only knew Data.Binary but i was thinking if there are better, more modern tools for the job
04:40:32 <obiwahn> koeien: now i am trying to replace the normal show for lists with my own version and it will not work
04:40:36 <yitz> kizzx2: i would break up the input into chunks beginning with 'H', then drop them until i get one that starts with the magic string.
04:40:53 <applicative> obiwahn, you want a different show Instance, for starters, so it should be "newtype (Graph a) = Graph [(a,a)]`  There are some other problems here though...
04:41:25 * hackagebot trifecta 0.44 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.44 (EdwardKmett)
04:41:33 <yitz> kizzx2: right, and let's say the magic string isn't so simple, something that varies and really does need to be parsed.
04:42:19 <applicative> obiwahn, if you have a Graph (x:xs) then x is of the form (a,b), it's a pair not a list.  So the use of 'head' for example doesn't fit
04:42:42 <obiwahn> i have replaced it with fst and snd
04:43:02 <kizzx2> yitz: well let's be more concrete, i'm parsing PDF files
04:43:10 <yitz> kizzx2: so again, i would use atto for parsing the chunks which actually have non-trivial syntax, and regular bytestring functions for doing the heavy lifting of just plowing through big piles of stuff we are just throwing away.
04:43:15 <kizzx2> a quick primer: PDF file is a big container of "objects" and a dictionary at the end
04:43:23 <yitz> kizzx2: me too, at work :)
04:43:36 <edwardk> i think ddarius has a fair bit of haskell code for parsing pdfs
04:43:37 <kizzx2> yitz: o cool :)
04:44:16 <kizzx2> well let's take PDF for example
04:44:17 <obiwahn> applicative: newtype is a keyword?
04:44:17 <yitz> kizzx2: though i am actually using xpdf pdftops and then parsing the postscript instead, that's easier for my particular application
04:44:26 <edwardk> obiwahn: yes
04:44:36 <kizzx2> we know PDF are like "obj ID REF ……. end obj" but there's nothing preventing the word "obj" from appearing inside content streams
04:45:04 <yitz> kizzx2: ok so the problem with that is that its not linear. things can point back and forth, and into deeply nested objects.
04:45:15 <yitz> kizzx2: which is why i like postscript better :)
04:45:31 <applicative> obiwahn, yes, you have to have an annoying wrapper, so it's be "newtype Graph a = Graph [(a,a)]" (you can choose anything on the right there)
04:45:48 <kizzx2> yitz: me too, i have really learned to hate  the PDF spec writers
04:46:09 <synonymous> sorry to interrupt gentlemen..is there a function in the standard library that collects list items at positions specified in another list? Also known as backpermute in some libraries
04:46:28 <kizzx2> synonymous: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=backpermute
04:46:30 <applicative> obiwahn, you can use newtype instead of data where there is just one constructor and one field on the right hand side; the compiler is then to promise to 'erase' it.
04:46:31 <yitz> kizzx2: yes. i hate some of the pdf driver writers even more. some of them intentionally obfuscate their pdfs in those ways.
04:46:54 <kizzx2> synonymous: oop,s seems to be Vector specific :P
04:47:09 <ClaudiusMaximus> :t ixmap
04:47:10 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
04:47:20 <yitz> synonymous: in order, or random order?
04:47:28 <synonymous> random
04:47:43 <synonymous> either, actually
04:47:44 <yitz> synonymous: so you'll probably be using a Map.
04:47:48 <applicative> obiwahn: it's basically the same as a "data (Graph a) = Graph [(a,a))" would be. You could also use that.
04:47:55 <yitz> synonymous: or a Sequence.
04:48:16 <synonymous> i'm not after performance, just prototyping..
04:48:27 <yitz> synonymous: ok let's just use lists then.
04:48:57 <obiwahn> how must the show look like then?  show Graph (x:xs) =  doesnot work
04:49:08 <applicative> obiwahn, but where, as in this case, you are make a new type just to write new class instances, newtype is the way to go. You can also use record syntax, by the way, and for what it's worth
04:49:54 <yitz> > let backpermute = map . (!!) in backpermute "Hello, this is a string." [0,2..10]
04:49:55 <lambdabot>   "Hlo hs"
04:50:39 <applicative> obiwahn: so maybe something like newtype (Graph a) = Graph {edges :: [(a,a)]} then you get the 'accessor function' right away
04:50:51 <yitz> synonymous: of course no bounds checking there or anything. there are similar simple functions for Map, Sequence, and (as ClaudiusMaximus pointed out) arrays.
04:52:13 <koeien> obiwahn: show (Graph (x:xs)) = ...
04:52:29 <synonymous> yitz: nah, no need for any bounds checking and such, cheers for the suggestions everyone
04:55:39 <yitz> kizzx2: anyway, for postscript, i start by breaking the input into lines
04:56:00 <hpaste> applicative annotated “instance declaration for `Show (” with “instance declaration for `Show ( (annotation)” at http://hpaste.org/51229#a51230
04:56:04 <yitz> kizzx2: then, i use choice with a big list of attoparsec parsers.
04:56:40 <yitz> kizzx2: it works great, parses huge pdfs in complex ways with no noticeable delay
04:56:43 <applicative> obiwahn: ^^^ This is I think a fairly standard way of writing it. I can't tell if show is done like you wanted.
04:56:48 <jeetu> Cale: yitz: thanks
04:57:17 <yitz> kizzx2: if you just want the text you might even be able to use pdftotext and forget about the postscript.
04:57:32 <kizzx2> yitz: huh!? did you just wrote that code in that several seconds?
04:57:43 <yitz> which code?
04:57:49 <kizzx2> "it works great..."
04:57:53 <kizzx2> so did you just roll something new and tested it?
04:58:00 <yitz> kizzx2: i've been working on it for months
04:58:08 <kizzx2> o alright :P
04:58:25 <kizzx2> well i'm just updating my knowledge of Haskell's parsing scene and trying to get famililar with new technoloies
04:58:48 <yitz> kizzx2: i need to detect all kinds of layout stuff, too. it's actually quite complicated. but parsing the postscript is a breeze :)
04:58:49 <kizzx2> PDF seems to be one of the formats i am most familiar with :P
04:59:00 <yitz> kizzx2: my condolences
04:59:19 <yitz> kizzx2: about pdf i mean :)
04:59:58 <kizzx2> yitz: wow, detecting layout issues in PDF (which have PS lke commands) sounds like a compiler optimization problem
05:00:08 <kizzx2> detecting "bad code" and rewritting it
05:00:51 <yitz> kizzx2: it's hard, but fun :) nah, more geometric reasoning. the layout commands are machine-generated so they're pretty regular.
05:02:07 <yitz> kizzx2: probably binary or cereal would work better for parsing pdfs directly though
05:03:25 <kizzx2> what's the main difference between binary and cereal? (haven't looked at cereal before)
05:03:53 <Jafet> Cereal has more sugar?
05:03:56 <kizzx2> the interface looks so similar
05:03:59 <yitz> i think nowadays binary is always strict, and cereal is lazy. some other differences.
05:04:05 <yitz> Jafet: haha
05:04:09 <koeien> lazy/strict
05:04:20 <yitz> Jafet: we don't buy those kinds of cereal
05:04:40 <koeien> cereal has some different helper functions afair
05:04:48 <kizzx2> from cereal Hackage page: "Similar to binary in performance, but uses a strict ByteString instead of a lazy ByteString, thus restricting it to operating on finite inputs."
05:04:58 <kizzx2> so seems like binary is lazy?
05:05:23 <koeien> yes
05:05:41 <yitz> ah binary is lazy and cereal is strict? ok.
05:06:11 <kizzx2> is that really teh only difference?
05:06:20 <kizzx2> they should have named Data.Binary.Lazy rather than giving a new name
05:06:31 <kizzx2> or Data.Binary.Strict, rather
05:06:46 <kizzx2> wait, there is a package called "binary-strict"
05:15:38 <hpaste> obi pasted “unfolding” at http://hpaste.org/51231
05:16:21 <obiwahn> damn
05:16:46 <hpaste> obi pasted “unfolding” at http://hpaste.org/51232
05:19:08 <obiwahn> works:)
05:28:27 <sohum> @pl \a -> (fst a, (+ (snd a))
05:28:27 <lambdabot> (line 1, column 13):
05:28:27 <lambdabot> unexpected ","
05:28:27 <lambdabot> expecting variable, "(", operator or ")"
05:28:37 <sohum> @pl \a -> (fst a, (+ (snd a)))
05:28:37 <lambdabot> liftM2 (,) fst ((+) . snd)
05:33:02 <Grahack> account
05:33:09 <Grahack> oops, sorry
05:35:17 <hpaste> stribor pasted “function” at http://hpaste.org/51233
05:35:17 <sohum> \pl a x -> (a *** a) x
05:35:23 <sohum> @pl a x -> (a *** a) x
05:35:23 <lambdabot> (line 1, column 5):
05:35:23 <lambdabot> unexpected ">" or "-"
05:35:23 <lambdabot> expecting variable, "(", operator or end of input
05:35:29 <sohum> @pl \a x -> (a *** a) x
05:35:29 <lambdabot> join (***)
05:35:34 <sohum> right
05:35:42 <sohum> (sorry, my brain's not working right)
05:37:01 <stribor> can anyone give me some suggestions on how to implement this function http://hpaste.org/51233
05:42:16 <sohum> :t chunk
05:42:16 <lambdabot> Not in scope: `chunk'
05:44:14 <sohum> stribor: look at splitAt and (++)
05:45:16 <stribor> sohum: is there way to look up function when you need to.like now i have to write this function but dont have clue what functions are avaiable to use
05:45:49 <koeien> hoogle or #haskell
05:46:07 <sohum> stribor: one I find useful is haskell.org/hoogle
05:46:18 <sohum> also available as @hoogle here
05:46:36 <stribor> sohum: yeah but how do you search for "term"
05:46:42 <osfameron> hoogle is incredible
05:46:54 <hpc> @hoogle term
05:46:54 <lambdabot> module Test.HUnit.Terminal
05:46:55 <lambdabot> Test.HUnit.Terminal terminalAppearance :: String -> String
05:46:55 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
05:46:59 <sohum> why do you want to search for "term"?
05:47:00 <Sturmeh> @hoogle zip
05:47:00 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
05:47:00 <lambdabot> Data.ByteString zip :: ByteString -> ByteString -> [(Word8, Word8)]
05:47:00 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
05:47:04 <Sturmeh> :P
05:47:20 <hpc> @hoogle ard
05:47:20 <lambdabot> Language.Haskell.ParseMonad discard :: Int -> Lex r ()
05:47:20 <lambdabot> Language.Haskell.TH data Guard
05:47:20 <lambdabot> Language.Haskell.TH.Syntax data Guard
05:47:26 <hpc> huh, came up with results
05:47:38 <Sturmeh> i think he wants the reverse of a function lookup
05:47:38 <stribor> i know but how would you search for zip function if you doidnt know zip function exist..
05:47:43 <ClaudiusMaximus> @hoogle [Either l r] -> ([l], [r])
05:47:43 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
05:47:47 <Sturmeh> stribor http://learnyouahaskell.com/chapters
05:47:48 <Sturmeh> read that
05:47:48 <Sturmeh> :D
05:47:56 <hpc> stribor: search by type
05:48:04 <sohum> frinstance:
05:48:05 <hpc> @hoogle [a] -> [b] -> [(a, b)]
05:48:05 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
05:48:05 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
05:48:05 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
05:48:12 <sohum> @hoogle [a -> b] -> a -> [b]
05:48:12 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
05:48:12 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
05:48:12 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
05:48:18 <koeien> @hoogle [a] -> [a] -> [(a,a)]
05:48:18 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
05:48:18 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
05:48:18 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
05:48:22 <koeien> -- ^ it's quite smart
05:48:31 <osfameron> search by type found us 'transpose' the other day. really nice
05:48:53 <hpc> @hoogle ((a -> m b) -> a -> m b) -> m b
05:48:53 <lambdabot> No results found
05:49:06 <sohum> huh.
05:49:20 <Sturmeh> @hoogle transpose
05:49:20 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
05:49:20 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
05:49:20 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
05:49:27 <sohum> > [(+1), (*4), (-20)] <*> 3
05:49:27 <lambdabot>   No instance for (GHC.Num.Num [a])
05:49:27 <lambdabot>    arising from a use of `e_114203' at <i...
05:49:48 <stribor> sohum: in my resulting list i am limited on the size of each string in the list
05:49:50 <sohum> I guess lists aren't applicative :p
05:49:52 <obiwahn> @src or
05:49:52 <lambdabot> or    =  foldr (||) False
05:50:01 <koeien> sohum: sure they are, they should be
05:50:06 <koeien> sohum: they are monads even
05:50:09 <hpc> > [(+1), (*4), (-20)] <*> [3, 4, 5]
05:50:10 <lambdabot>   [4,5,6,12,16,20,-20,-20,-20]
05:50:23 <hpc> > [(+1), (*4), subtract 20] <*> [3, 4, 5]
05:50:23 <lambdabot>   [4,5,6,12,16,20,-17,-16,-15]
05:50:24 <sohum> oh, doy
05:51:00 <sohum> > [(+), (*), (-)] <*> [3] <*> [5]
05:51:01 <lambdabot>   [8,15,-2]
05:51:01 <hpc> it interprets (-20) as a number, then interprets the number as a function because of vector-space instances
05:51:08 <hpc> and decides that it means const (-20)
05:51:20 <sohum> cute
05:51:31 <sohum> stribor: hence splitAt :p
05:51:41 <hpc> > flip [(+), (*), (-)] 3 <*> [5]
05:51:42 <lambdabot>   [8,15,-2]
05:51:51 <stribor> sohum: tx
05:51:53 <jpcooper> hello
05:51:55 <hpc> > flip . flip [(+), (*), (-)] 3 $ 5
05:51:56 <lambdabot>   Couldn't match expected type `a -> a2 -> f (a1 -> b)'
05:51:56 <lambdabot>         against infer...
05:52:08 <jpcooper> how do I convert a DiffTime (of http://www.haskell.org/ghc/docs/latest/html/libraries/time-1.2.0.5/Data-Time-Clock.html#t:DiffTime) value to a Float?
05:52:16 <hpc> > flip (flip [(+), (*), (-)] 3) 5
05:52:17 <lambdabot>   [8,15,-2]
05:52:19 <hpc> :D
05:52:24 <sohum> wait, what
05:52:32 <sohum> :t flip
05:52:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:52:47 <hpc> flip f x = fmap ($ x) f
05:52:52 <hpc> in caleskell
05:52:59 <sohum> right
05:53:22 <zachk> whats caleskell again?
05:53:24 <sohum> :t fmap [(+), (*), (-)] 4
05:53:25 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
05:53:25 <lambdabot>     In the first argument of `fmap', namely `[(+), (*), (-)]'
05:53:25 <lambdabot>     In the expression: fmap [(+), (*), (-)] 4
05:53:40 <koeien> zachk: caleskell is what Cale considers appropriate in the Prelude :)
05:53:47 <hpc> sohum:
05:53:47 <koeien> \bot has it
05:53:50 <sohum> :t fmap ($ x) [(+), (*), (-)]
05:53:51 <lambdabot> [Expr -> Expr]
05:53:53 <zachk> ahhh
05:53:54 <hpc> flip [f, g, h] x
05:54:04 <hpc> fmap ($ x) [f, g, h]
05:54:04 <sohum> :t fmap ($ 4) ($ 3) [(+), (*), (-)]
05:54:05 <lambdabot>     Couldn't match expected type `[a -> a -> a]'
05:54:05 <lambdabot>            against inferred type `a2 -> a1 -> b'
05:54:05 <lambdabot>     In the expression: fmap ($ 4) ($ 3) [(+), (*), (-)]
05:54:14 <sohum> :t fmap fmap ($ 4) ($ 3) [(+), (*), (-)]
05:54:15 <hpc> [($ x) f, ($ x) g, ($ x) h]
05:54:15 <lambdabot> forall b. (Num b) => [b]
05:54:21 <hpc> [f x, g x, h x]
05:54:31 <sohum> that is _cute_
05:54:34 <ClaudiusMaximus> jpcooper: i'm guessing realToFrac would do the trick, looking at the list of instances
05:54:35 <sohum> ugly, but cute :p
05:55:02 <hpc> sohum: it's defined that way so it == Prelude.flip
05:55:12 * sohum nod
05:55:42 <sohum> @pl \a b -> fmap ($ b) a
05:55:42 <lambdabot> flip (fmap . flip id)
05:56:18 <sohum> > fmap fmap ($ 4) ($ 3) [(+), (*), (-)]
05:56:18 <lambdabot>   [4,4,4]
05:56:23 <hpc> :t fix $ \flip -> flip (fmap . flip id)
05:56:23 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
05:56:23 <lambdabot>     Probable cause: `flip' is applied to too many arguments
05:56:23 <lambdabot>     In the expression: flip (fmap . flip id)
05:56:28 <hpc> hehe
05:56:32 * sohum headdesk
05:56:54 <hpc> > fmap fmap fmap ($ 4) ($ 3) [(+), (*)]
05:56:55 <lambdabot>   Couldn't match expected type `a1 -> f (a -> b)'
05:56:55 <lambdabot>         against inferred ty...
05:57:04 <hpc> > fmap ($ 4) fmap ($ 3) [(+), (*)]
05:57:04 <lambdabot>   4
05:57:11 <hpc> well then
05:57:36 <jpcooper> ClaudiusMaximus: that did the trick. Thanks
06:00:04 <qnikst> hello, can smbd help me to find out how to use quickcheck to validate simple BinarySearchTree library
06:07:19 <hpaste> obi pasted “..,klar” at http://hpaste.org/51235
06:10:24 <qnikst> my problem is in generating a set of BinaryTrees by inserting elements..
06:13:25 <applicative> qnikst: is the problem writing a suitable Arbitrary instance?
06:16:00 <hakoja> hi, is there anyone who knows how I can go about deriving an instance of IArray UArray? In particular, I need to make the instance: (IArray UArray Word128), where Word128 can be found in the Data.LargeWord module
06:18:40 <hpc> do you want to derive it, or write the instance yourself?
06:19:37 <hakoja> well if I could derive it that would be great :) but I'm also ok with writing it myself
06:22:20 <hpc> you can base your instance on http://hackage.haskell.org/packages/archive/array/latest/doc/html/src/Data-Array-Base.html#line-890
06:23:26 <hpc> someone else will know if an extension exists for deriving it yourself
06:23:41 <hpc> s/yourself/automatically/
06:24:33 <hakoja> so you meen to use the bounds function defined for Word64 and modify it to work for the Word128 instance?
06:24:44 <hakoja> mean*
06:26:06 <hpc> uh, maybe?
06:26:26 <hpc> i actually didn't look at the code in-depth, i just figured it would be a good starting point
06:27:07 <hakoja> yeah, thx, but you know that the Data constructor for IArray's are not exported right?
06:27:34 <hakoja> so I can't pattern match on that
06:28:13 <hakoja> but I can use the instance as already defined on Wod64 I think
06:30:02 <hakoja> i,.e. I use the bounds function (from Word64) on the low part and the high part of Word128
06:31:07 <hakoja> and take the first value in the tuple to be the first value from the bounds function on lower Word64, and the second value in the tuple to be the second value from the bounds function on Word64
06:31:12 <hakoja> would this work?
06:31:34 <hakoja> sorry for the poorly formulated sentance above :)
06:31:38 <hpc> heh
06:31:59 <hpc> i think so
06:36:43 * hackagebot yesod 0.9.2.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.2.1 (GregWeber)
06:38:00 <hakoja> hmm, I think was confusing what I wanted to achieve
06:38:35 <dmwit> Oh, wow, I never thought of (Eq a, Show a) => as being a tuple of constraints.
06:38:54 <hakoja> I still don't know how I can make Word128 a valid element type to put in a UArray
06:39:48 <yitz> dmwit: it's an unordered tuple :(
06:43:06 <hpc> @pl spin (x:xs) n = n : spin xs (n + x)
06:43:06 <lambdabot> spin = fix ((`ap` tail) . (. head) . ((ap (:) .) .) . (. (+)) . flip . ((.) .))
06:43:38 <hpc> well that doesn't help
06:44:33 <hpc> oh wait, i get it now
06:45:10 <sbrg> at some point I'll write an haskell application and use @pl on every function possible
06:45:16 <sbrg> even though it looks like that
06:45:18 <aavogt> > scanl (+) n [a,b,c,d] :: [Expr]
06:45:19 <lambdabot>   [n,n + a,n + a + b,n + a + b + c,n + a + b + c + d]
06:45:35 <hpc> wheel = the distances between subsequent "spokes"
06:45:52 <hpc> and spin wheel n = the positions of those spokes, counting from n
06:46:21 <aavogt> sbrg: how about a preprocessor for doing that :p
06:46:43 <sbrg> aavogt: maybe I'll just write the code and then write some more code to apply lambdabot's @pl to it
06:46:43 <hpc> and then that's used as a limit on which numbers need to be evaluated by the prime sieve
06:47:12 <hpc> that explains why it's just a constant factor improvement
06:48:05 <hpc> i wonder what speedup would be gotten by an infinite wheel, or if the wheel eats up all the time saved in building bigger and bigger wheels
06:52:53 <monochrom> a wheel is like {1,3,5,7,9,11,13,15,17,19...} right? and then a better wheel is {1, 3, 7, 9, 11, 13, 17, 19 ...} right? if you keep improving, in the limit the final wheel is exactly the primes, right?
06:54:12 <monochrom> so in the limit, you put a wheel in a wheel so you can find primes while you find primes
06:58:53 <stribor> is there function similiar as "sum" that i can use to concat every string in my list
06:59:08 <hakoja> (++)
06:59:15 <mauke> concat
06:59:19 <shachaf> mconcat
06:59:23 <mauke> join
06:59:33 <monochrom> foldr (++) []
07:00:07 <mauke> intercalate ""
07:00:18 <shachaf> mauke: I don't think you're allowed to go twice.
07:00:22 <stribor> concat looks like candidate
07:01:48 <hakoja> anyone know how you're supposed to implement the bounds function if you want to make a new instance of IArray?
07:02:08 <mauke> .oO( correctly? )
07:02:24 <hakoja> ?
07:07:55 <Phyx-> @type moduleNameSlashes
07:07:55 <lambdabot> Not in scope: `moduleNameSlashes'
07:09:22 <roconnor_> @type bounds
07:09:23 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
07:11:49 <___ma_rtin_____> what's the difference between this: Map.toList . Map.insert 9 2 $ Map.singleton 4 3
07:11:59 <___ma_rtin_____> and this:  Map.toList $ Map.insert 9 2 $ Map.singleton 4 3
07:12:10 <___ma_rtin_____> is one more efficient?
07:12:21 <sbrg> ___ma_rtin_____: no
07:12:51 <___ma_rtin_____> thanks
07:13:26 <engla_> ___ma_rtin_____: one is like   (a . b) c    and one is like  a (b c)
07:14:06 <sbrg> ___ma_rtin_____: the difference is purely semantic.. foo . bar . baz $ n = apply the composed function foo . bar . baz to n
07:14:20 <sbrg> foo $ bar $ baz $ n apply foo to bar to baz to n
07:14:23 <applicative> ___ma_rtin_____: where (a . g) is defined thus: (a . b) c = a (b c)
07:14:58 <___ma_rtin_____> so are they necessarily equivalent?
07:15:04 <___ma_rtin_____> will they have the same value, i mean?
07:15:10 <___ma_rtin_____> in this case, they do
07:15:10 <Saizan> yep
07:15:26 <___ma_rtin_____> ok.  thanks a lot
07:16:02 <sbrg> what an annoying nick to tab complete :(
07:16:19 <Saizan> (f . g) = \x -> f (g x); f $ x = f x; so f . g $ x = f (g x) = f $ g $ x
07:21:01 <aavogt> in hugs is one more efficient?
07:21:33 <aavogt> (or when interpreted by ghci for that matter)
07:23:00 <Saizan> never tested, but i doubt it can be noticeable
07:30:59 <koeien> shouldn't ($) be left associative?
07:33:33 <parcs_> koeien: then why is it right-associative?
07:33:56 <applicative> koeien, people sometimes argue that, though I don't know what's stopping them from introducing a left associative operator as well
07:34:25 <applicative> the arguments seemed convincing to me until I tried it :)
07:36:14 <incluye> > (+5) . (*2) $ 4
07:36:15 <lambdabot>   13
07:36:21 <incluye> > (+5) $ (*2) . 4
07:36:21 <lambdabot>   No instance for (GHC.Num.Num (f a))
07:36:21 <lambdabot>    arising from a use of `e_1524' at <i...
07:36:28 <incluye> ah
07:38:02 <aavogt> applicative: there's a shortage of ascii symbols
07:39:25 <ion> > (+5) . (*2) . 4 $ 2
07:39:27 <lambdabot>   13
07:39:34 <Phyx-> does anyone know how ghc-path discovers the path to the libdir?
07:39:51 <Phyx-> GHC.Path is a problem for me since it's a compile time constant
07:39:54 <monochrom> hard-coding
07:40:30 <Phyx-> errr
07:40:33 <Phyx-> i meant ghc-pkg
07:40:37 <Saizan> Phyx-: ghc --info has a "LibDir" field
07:40:53 <monochrom> hard-coding in a shell script too
07:41:39 <monochrom> /usr/local/bin/ghc is a shell script. /usr/local/bin/ghc-pkg is a shell script too
07:41:50 <Phyx-> guess i'll have to resolve it on first run of the app
07:44:48 <applicative> well i'm defeated trying to build the 'ConstraintKinds' ghc.  I should be more patient.
07:46:05 <parcs_> try an earlier commit
07:46:41 <applicative> parcs_ yeah I just have to figure it out, I was hoping I'd get lucky...
07:46:42 * hackagebot factory 0.1.0.2 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.1.0.2 (AlistairWard)
07:46:54 <kosmikus> applicative: seems to work for me
07:50:06 <Phyx-> monochrom: yeah, but assuming they're both on your path, i can query one of them
07:50:15 <Phyx-> Saizan: forgot about that flag, thanks
07:51:08 <parcs_> maybe ($) should be left-associative. you can always replace mulitple right-associative ($)s with (.)s and a single ($)
07:51:39 <parcs_> is there a discussion that outlines the pros and cons of both?
07:52:11 <monochrom> Cale can reproduce that discussion
07:52:21 <Phyx-> monochrom: something's still not clear though.. when installing from a binary like the windows installer.. how does the compiler know *where* things are. Or from a binary distrubution where you only do make install. Does the installer update a state/file somewhere?
07:52:27 <applicative> kosmikus, something about the new SAFE extension; Data.List cannot be safely imported...
07:52:43 <monochrom> presumably a channel log and a mailing list archive also has those discussions, but I'm too lazy to find
07:53:17 <monochrom> the installer writes the paths into the shell scripts
07:54:03 <Phyx-> hmm ok
07:54:36 <kosmikus> applicative: I actually built from the latest snapshot, not from git
07:55:19 <kosmikus> applicative: http://haskell.org/ghc/dist/current/dist/ghc-7.3.20110910-src.tar.bz2
07:56:10 <applicative> kosmikus, I see, but I think mr. batterseapower mentioned ghc-7.4?
07:56:12 <kosmikus> applicative: it's fun. so many things are suddenly working. equality superclass constraints, associated type defaults, class synonyms, ...
07:56:49 <parcs_> applicative: odd-numbered versions are development versions, even-numbered release versions
07:57:09 <applicative> so i need 7.5?
07:57:17 <applicative> :)
07:57:20 <parcs_> :P
07:58:30 <kosmikus> I wasn't aware that there's already a 7.4 branch. is there?
07:58:44 <kosmikus> I think HEAD is still 7.3
07:59:06 <parcs_> kosmikus: there's also this: https://github.com/ghc/ghc/commit/c27df60d69ad54a69723510c57e238f31a59c532
07:59:46 <applicative> kosmikus,  things seem to be happening much faster lately.  is it a change in the way ghc is developed?
07:59:50 <sbrg> https://github.com/ghc/ghc/commit/c27df60d69ad54a69723510c57e238f31a59c532
07:59:53 <sbrg> uh, sorry
08:00:38 <Phyx-> applicative: it's the chrome way, release often and break packages/plugins often
08:01:15 * monochrom is a cathedral guy
08:01:55 <kosmikus> parcs_: nice
08:02:11 <kosmikus> applicative: how so? I don't perceive any change ...
08:02:16 <applicative> yes, I guess that's a consequence of the Haskell platform?  It's what declares 'stable' not a new version number?
08:03:32 <applicative> kosmikus, I could be wrong, I also had the impression that there are more people involved, but maybe I just am able to perceive more
08:04:05 <kosmikus> applicative: I think that's a trend, yes (more people involved). But it's hardly new for this particular release.
08:04:44 <kosmikus> Also, GHC being stable isn't the same as saying that all libraries work and are tested and adapted to potential changes. That's the main reason the platform exists.
08:06:43 * hackagebot yesod-goodies 0.0.5 - A collection of various small helpers useful in any yesod application.  http://hackage.haskell.org/package/yesod-goodies-0.0.5 (PatrickBrisbin)
08:06:45 * hackagebot yesod-comments 0.5.0 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.5.0 (PatrickBrisbin)
08:07:54 <applicative> kosmikus, right the second point I think I grasp
08:12:08 <stribor> is there any rules that you can write function
08:12:19 <monochrom> every GHC version x.(even number).z is stable
08:12:28 <stribor> for example when do you write function as pattern matching and when using guards for example
08:13:15 <Eduard_Munteanu> stribor: well, you use guards when you can't pattern-match.
08:13:17 <applicative> monochrom, ghc reject mutable version numbers!
08:13:32 <stribor> when can you not pattern match?
08:13:41 <Eduard_Munteanu> stribor: for example you can't pattern-match on some integer being less than another.
08:14:04 <parcs_> yeah you can :P
08:14:45 <Eduard_Munteanu> Well, that depends on what your input is.
08:14:46 <aavogt> > let f ((<1) -> True) = 'a'; f _ = 'b' in map f [-2 .. 2]
08:14:47 <lambdabot>   "aaabb"
08:15:04 <Eduard_Munteanu> Pfft, view patterns.
08:15:12 <monochrom> I use pattern-matching when I need it. I use guard when I need it. is it so hard to decide what you need?
08:15:18 <stribor> then when do you use list comprehension?
08:15:49 <monochrom> it's almost like "when do you take the train and when do you take the plane"
08:16:04 <aavogt> you can pattern match in guards
08:16:08 <parcs_> what can view patterns do that pattern guards can't? (other than confuse the hell out of the reader?)
08:17:03 <ion> Reduce the possibility of a mistake because the temporary value isn’t bound to a name.
08:17:04 <Eduard_Munteanu> Guards can check an arbitrary condition depending on multiple parameters.
08:17:22 <Eduard_Munteanu> At least more naturally.
08:17:49 <stribor> Eduard_Munteanu: reason i ask all this is because sometimes i am confused on how to write function
08:18:09 <ion> Write it in the way that feels natural to you.
08:18:37 <monochrom> it is case-by-case. you tell us a specific function to be written, we tell you how to do it
08:18:50 <Eduard_Munteanu> Aye ^
08:19:15 <monochrom> there is still no algorithm for "how do I write programs" so there is not going to be a general answer soon
08:20:06 <stribor> cool..thank you
08:20:19 <Eduard_Munteanu> Well, there could be general guidelines, like "don't use guards for everything when pattern-matching is simpler".
08:20:20 <ion> how is proggram formed? how code get compiled?
08:20:57 <stribor> Eduard_Munteanu: yeahs thats true biut when you new you just want to write way you know best at the time
08:21:15 <Eduard_Munteanu> stribor: any particular function you're thinking about?
08:22:14 <sm> morning all. What's the succinct monadic way of turning ["a","b"] and ["c","d"] into ["ac","bc","ad","bd"] ?
08:22:19 <monochrom> guard and pattern-matching are almost mutually exclusive. I do not even understand why there is a confusing choice, 99% of the time
08:22:32 <hpaste> stribor pasted “function” at http://hpaste.org/51237
08:22:48 <Eduard_Munteanu> > zipWith (++) ["a","b"] ["c","d"]
08:22:49 <lambdabot>   ["ac","bd"]
08:22:58 <stribor> http://hpaste.org/51237
08:23:05 <sm> Eduard_Munteanu: thanks!
08:23:17 <ion> > (++) <$> ["a","b"] <*> ["c","d"]
08:23:18 <lambdabot>   ["ac","ad","bc","bd"]
08:23:19 <koeien> :t liftM2 (++)
08:23:20 <lambdabot> forall a1 (m :: * -> *). (Monoid a1, Monad m) => m a1 -> m a1 -> m a1
08:23:27 <stribor> what if i wanted to say that if list is empty return [] as well
08:23:35 <sm> ion, thx
08:24:02 <monochrom> use pattern matching for empty list
08:24:24 <ion> > flip (++) <$> ["c","d"] <*> ["a","b"]
08:24:25 <lambdabot>   ["ac","bc","ad","bd"]
08:24:28 <monochrom> > concat []
08:24:29 <lambdabot>   []
08:24:40 <monochrom> concat already does it for you actually
08:24:48 <Eduard_Munteanu> Oops, I misread.
08:24:57 <hpaste> stribor pasted “function” at http://hpaste.org/51238
08:25:15 <stribor> what if you have definition like this  http://hpaste.org/51238
08:25:15 <Eduard_Munteanu> What ion said, then.
08:25:23 * sm nods
08:25:39 <sm> I thought there might be some l1 >>= l2 way
08:25:51 <koeien> sm: sure there is
08:25:53 <monochrom> why is 51238 the same as 51237?
08:26:02 <aavogt> parcs_: view patterns lead to less nesting compared to guards (which in turn lead to less nesting than using case)
08:26:15 <stribor> i added another parametar to definition in 51238
08:26:16 <ion> > ["c","d"] >>= \b -> ["a","b"] >>= \a -> return (a ++ b)
08:26:17 <lambdabot>   ["ac","bc","ad","bd"]
08:26:22 <koeien> > ["a","b"] >>= (\x -> ["c","d"]] >>= (\y -> return (x++y))
08:26:22 <lambdabot>   <no location info>: parse error on input `]'
08:26:27 <koeien> > ["a","b"] >>= (\x -> ["c","d"] >>= (\y -> return (x++y))
08:26:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:26:38 <koeien> > ["a","b"] >>= (\x -> ["c","d"] >>= (\y -> return (x++y)))
08:26:39 <lambdabot>   ["ac","ad","bc","bd"]
08:26:45 <monochrom> what do you want the function to do?
08:27:14 <ion> sm: No need to use monads when functor and/or applicative is enough.
08:27:42 <sm> indeed, just curious if my intuition was off. I was asked if https://gist.github.com/1209187 can be written more succinctly
08:27:43 <stribor> first i want to concatinate all elements of list with inout string.....then i want output to be list containing strings split at 5 of contatinated string
08:27:46 <koeien> @src liftM2
08:27:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:28:13 <stribor> i am trying to figure out myself how to do it.......so if you give me some direction rather than write it for me
08:28:24 <sm> I knew it could but my haskell fu only came up with [a++b | b <- _letters, a <- _mods]
08:28:24 <ion> sm: First of all, drop the _ prefixes. They usually mean “unused value”.
08:29:00 <ion> liftA2 (++) mods letters
08:29:02 <sm> really ? by convention, or does ghc do something special ?
08:29:15 <koeien> sm: convention.
08:29:24 <koeien> just an underscore by itself is special
08:29:32 <stribor> so if you have myFunction "abcd" ["defthy","vbnmm"] out put will be ["abcdd","efthy","vbnmm"]
08:30:37 <Cale> _what's _with _the _strange _initial _underscores?
08:30:58 <aavogt> > let f (Just a) (Just ((a+) -> b)) = b; f _ _ = 0 in zipWith f [Just 2, Nothing] (cycle (Just 1))
08:30:59 <ion> {-# LANGUAGE MagicUnderscores #-}
08:30:59 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe t]'
08:30:59 <lambdabot>         against inferre...
08:31:18 <aavogt> > let f (Just a) (Just ((a+) -> b)) = b; f _ _ = 0 in zipWith f [Just 2, Nothing] (repeat(Just 1))
08:31:18 <lambdabot>   [3,0]
08:31:59 <aavogt> parcs_: ^^ to do that with guards you need to come up with more variable names
08:32:26 <ion> @hoogle splitEvery
08:32:26 <lambdabot> No results found
08:32:27 <aavogt> at least if you want to put a constant on the right hand side
08:32:52 <ion> stribor: http://hackage.haskell.org/packages/archive/split/0.1.4.1/doc/html/Data-List-Split.html#v:splitEvery
08:32:54 <Cale> > map concat . sequence $ [["M-"], ["","S-"], ["w","e","r"]]
08:32:55 <lambdabot>   ["M-w","M-e","M-r","M-S-w","M-S-e","M-S-r"]
08:33:15 <Cale> wrong order...
08:33:26 <Cale> but order apparently doesn't matter
08:33:31 <stribor> ion: sweet
08:33:47 <stribor> ion: so when you new to haskell like me how would i even find this function
08:34:01 <sm> Cale, probably not in the real app, but it's a little extra hazard on the golf course :)
08:34:12 <ion> stribor: I just hoogled by “split”, found the split package and found splitEvery in it.
08:34:14 <aavogt> sm: you never get warnings about a _foo variable being unused
08:34:15 <Cale> sm: I think it's pretty.
08:34:24 <sm> aavogt: ah, good to know!
08:34:25 <Cale> sm: I'd use sequence like that in a real program
08:34:31 <ion> sm: Me, too.
08:34:37 <stribor> ion: cool....thank you
08:34:54 <ion> @where hoogle
08:34:54 <lambdabot> http://haskell.org/hoogle
08:34:57 <ion> stribor: ↑
08:35:14 <Cale> stribor: I always forget that hoogle exists and search through http://hackage.haskell.org/packages/archive/pkg-list.html
08:35:21 <Cale> for something which looks relevant
08:35:37 <Cale> (there's a search box there too)
08:35:48 <ion> Both are useful.
08:35:53 <Cale> But yeah, hoogle is good when it knows about your package
08:37:06 <Cale> sm: actually s/I'd use/I have used/
08:38:22 <stribor>  import Data.List.Split gives error?
08:38:43 <Cale> stribor: You have to install that package
08:38:48 <Cale> cabal install split
08:39:13 <stribor> can you install from ghci prompt
08:39:17 <Cale> no
08:39:34 <Cale> Well...
08:39:50 <dcoutts> wouldn't help, ghci will not reload its package db
08:39:52 <stribor> so if i would give you my code to run it on your machine you would have top install that module as well
08:40:00 <Cale> you can :m + System.Cmd
08:40:06 <Cale> and then  system "cabal install split"
08:40:22 <Cale> but yeah, then you still have to restart ghci :P
08:40:37 <Cale> stribor: yes
08:40:42 <dcoutts> Cale: it's simpler than that, :! will run a shell command
08:40:51 <Cale> oh, right
08:40:53 <dcoutts> :! cd ../
08:40:58 <dcoutts> for example
08:42:15 <stribor> well that didnt work...ill just install it from linux command line i guess
08:42:19 <ski> (well, to change the current directory of GHCi, you'd need to do `:cd ../')
08:44:00 <ion> > unfoldr (\xs -> splitAt 5 xs <$ listToMaybe xs) ['a'..'z']
08:44:00 <lambdabot>   ["abcde","fghij","klmno","pqrst","uvwxy","z"]
08:44:35 <sbrg> :t listToMaybe
08:44:36 <lambdabot> forall a. [a] -> Maybe a
08:44:41 <Cale> > map (take 5) . takeWhile (not . null) . iterate (drop 5) $ ['a'..'z']
08:44:42 <lambdabot>   ["abcde","fghij","klmno","pqrst","uvwxy","z"]
08:44:42 <sbrg> :t (<$)
08:44:43 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:45:15 <Cale> stribor: ^^ you could also use one of those
08:45:56 <sbrg> > listToMaybe "foo"
08:45:56 <lambdabot>   Just 'f'
08:46:01 <sbrg> huh
08:46:06 <sbrg> I don't get the purpose of that function
08:46:35 <ziman> well, it's like safeHead
08:46:40 <sbrg> oh
08:46:43 * hackagebot HiggsSet 0.1 - A multi-index set with advanced query capabilites  http://hackage.haskell.org/package/HiggsSet-0.1 (LarsPetersen)
08:46:44 <sbrg> true that
08:46:48 <sbrg> > listToMaybe []
08:46:49 <lambdabot>   Nothing
08:46:54 <dmwit> I don't get the purpose of it either.
08:47:02 <dmwit> And I already knew it was like safeHead.
08:47:09 <sbrg> well, now that he poitned out it's basically safeHead it makes sense
08:47:16 <ziman> but the name is weird.
08:47:21 <sbrg> yes
08:47:22 <Cale> It's useful when you're thinking of lists as nondeterministic computations
08:47:32 <dmwit> I still don't understand the appeal of using Maybe when [] will do.
08:47:34 <Cale> and you just want a greedy solution or nothing
08:47:54 <sbrg> dmwit: Well, I guess we can say that you shouldn't be using head on a list that can be empty ever anyway
08:48:01 <stribor> can you installl cabal like apt-get install cabal?
08:48:04 <sbrg> you should be doing pattern matching of some sorts or something like that
08:48:18 <ion> Yeah. It converts a list of alternative results to a Maybe, picking one of the results for Just. I think nothing specifies it’s the first result, but that’s the implementation that makes the most sense.
08:48:20 <sbrg> stribor: Sure, depending on your distro and its repo, but why not just get the haskell platform?
08:48:31 <Cale> dmwit: You can't always extend a function of a Maybe parameter to a function of a list parameter which doesn't ignore the rest of the list.
08:48:44 <stribor> well i dont know how to get it from ghci prompt
08:48:51 <dmwit> Cale: For example?
08:48:54 <sbrg> stribor: what do you mean?
08:49:25 <stribor> i am trying to install Data.List. module thats all
08:49:34 <koeien> import Data.List
08:49:38 <sbrg> yeah.. that should've come with ghc
08:49:39 <stribor> because when i try to use one of the function from that module it says module not there
08:49:44 <ion> That is, listToMaybe being equivalent to safeHead is just coincidental.
08:49:49 <dmwit> Cale: Or rather, why would I be bothered that some list function I wrote happens to ignore most of the list?
08:50:18 <Cale> dmwit: Well, it's unnatural to let people supply an arbitrary list if you're always going to ignore most of it
08:50:49 <BMeph> ion: Is it? Doesn't is have to work that way?
08:50:52 <dmwit> It's unnatural to restrict people to only supplying 0 or 1 items.
08:51:03 <Cale> Not always
08:51:39 <stribor> i also defined my code as module.....should import Data.List come above line module MyModule where
08:51:47 <koeien> stribor: no, just after
08:53:02 * dmwit shrugs
08:53:09 <dmwit> I haven't really seen a convincing use of listToMaybe.
08:53:12 <byorgey> dmwit: by that argument, why not use a binary tree with data at the nodes? that subsumes both Maybe (empty/single node) and list (just the left spine of a tree)
08:53:19 <monochrom> I always make people upload their whole brains for a free analysis
08:53:37 <dmwit> byorgey: Because the pattern match is more annoying to write.
08:53:38 <Cale> Hey, if you're using a binary tree, why not use a rose tree?
08:53:41 <dmwit> With Maybe/[] the opposite is true.
08:53:51 <dmwit> (x:_) is less annoying than (Just x).
08:54:19 <stribor> i am trying to use this function from Data.List splitEvery   but it saysd not in the scope?
08:54:19 <byorgey> I am not sure what annoyingness metric you are using.
08:54:36 <dmwit> Let's say keystrokes.
08:54:38 <dmwit> why not
08:54:40 <Cale> dmwit: It's nice to have the type system enforce invariants like "there are never 2 or more items here"
08:54:55 <byorgey> stribor: splitEvery is in Data.List.Split, not Data.List
08:54:56 <monochrom> splitEvery is not in Data.List
08:54:57 <Cale> and thereby save yourself from having to handle those cases
08:55:05 <dmwit> Cale: When?
08:55:09 <Cale> (and your clients from having to worry about them)
08:55:27 <Cale> In essentially every case where it's true.
08:55:37 <monochrom> you are better off writing your own splitEvery for now
08:55:39 <Cale> (that there won't be more than 2 items ever)
08:55:44 <Cale> er, more than 1
08:55:50 <dmwit> Cale: I'm looking for an example where it starts out not true, and becomes true (which is what listToMaybe encodes).
08:56:11 <stribor> byorgey: i wrote "import "Data.List" no error ...when i do "import Data.List.Split" could not find module
08:56:15 <ion> Hmm, i guess listToMaybe not returning the first item would cause very bad behavior with e.g. an infinite input to some filter. I guess it does need to return the first value.
08:56:26 <byorgey> stribor: did you run 'cabal install split'?
08:56:41 <byorgey> stribor: and then restart ghci?
08:57:06 * monochrom wonders how many more libraries do you have to install before you can start writing your first line of code
08:57:08 <stribor> i run "cabal install split" from ghci command line i get not in scope
08:57:11 <dmwit> Cale: (I'm not arguing against the Maybe type. I'm arguing against converting to the Maybe type when you've already got a perfectly good [] type.)
08:57:17 <sbrg> stribor: cabal is a program
08:57:23 <sbrg> it has nothing to do with ghci
08:57:26 <sbrg> it is not a command in ghci
08:57:37 <byorgey> stribor: you cannot run 'cabal install split' from ghci.  exit ghci, then run cabal install split, then run ghci again
08:57:41 <sbrg> (unless you run it using the :! 'command' but you'll still have to restart ghci for it to take effect afaik)
08:57:54 <Cale> There are 44 occurrences of listToMaybe in our game :P
08:58:01 <stribor> how to i install cabal from shell command line then?
08:58:13 <byorgey> stribor: how did you install ghc?
08:58:19 <stribor> apt-get
08:58:34 <dmwit> apt-cache search cabal-install
08:58:36 <monochrom> in fact, how many more libraries do you have to install before you can start learning haskell?
08:58:53 <byorgey> stribor: apt-get install haskell-platform
08:58:54 <arpunk> monochrom: only the haskell-platform?
08:59:02 <dmwit> Cale: =)
08:59:06 <davean> dmwit: also, consider the Maybe monad?
08:59:12 <Cale> dmwit: One common idiom in our code is using  justMapE listToMaybe
08:59:20 <monochrom> arpunk, look at byorgey suggesting to add "split"
08:59:32 <Cale> dmwit: Which is an arrow which turns an event of lists into a plain event.
08:59:34 <dmwit> davean: The [] monad is a perfectly good substitute for the Maybe monad.
08:59:38 <Cale> (with the head of the list, if any)
08:59:46 <stribor> haskell platform are libraries?
08:59:48 <monochrom> makes me wonder what else will be suggested
08:59:49 <jsternberg> I've got a question about withFile. Whenever I try to use withFile, I never end up being able to read the file. I always do something similar to "withFile (\handle -> hGetContents handle)" and returning the string
08:59:51 <arpunk> oh, looking
08:59:59 <jsternberg> but then this closes the file and yields an empty string
09:00:09 <koeien> jsternberg: hGetContents is lazy
09:00:10 <Cale> That is, it has type  (ArrowEvent (~>)) => Event (~>) [a] ~> Event (~>) a
09:00:10 <byorgey> stribor: it's a collection of common libraries and tools that help with Haskell development
09:00:16 <byorgey> stribor: it includes the 'cabal' tool
09:00:23 <byorgey> and other stuff you will probably want
09:00:23 <stribor> byorgey: ok ill try ti now
09:00:29 <davean> dmwit: sometimes, and not if you are already in a maybe monad
09:00:33 <koeien> jsternberg: you need to force the result.
09:00:44 <Cale> (nevermind exactly what ArrowEvent is, but suffice to say that events can only have one occurrence at any given point in time)
09:00:53 <jsternberg> koeien: how do I do that?
09:01:06 <dmwit> Cale: That actually sounds pretty legit.
09:01:08 <koeien> jsternberg: deepseq
09:01:11 <ski> > do b <- [False,True]; guard b
09:01:12 <koeien> :t deepseq
09:01:12 <lambdabot>   [()]
09:01:12 <ski> > do b <- listToMaybe [False,True]; guard b
09:01:13 <lambdabot> Not in scope: `deepseq'
09:01:13 <lambdabot>   Nothing
09:01:38 <byorgey> dmwit: suppose you have some code written using the list monad, and some other code written using the Maybe monad
09:01:50 <byorgey> dmwit: now you want to interface them. would you really replace all the Maybes with [] ?
09:02:07 <byorgey> no, you use the monad homomorphism from [] to Maybe, namely, listToMaybe
09:02:34 <ion> > do b <- head [False,True]; guard b
09:02:34 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:02:34 <lambdabot>         against inferred type ...
09:02:38 <dmwit> byorgey: Your setup sounds ridiculous to me. Have you ever written code that got into that situation?
09:02:44 <ion> err
09:02:54 <ion> > do b <- (return . head) [False,True]; guard b
09:02:54 <lambdabot>   No instance for (GHC.Show.Show (m ()))
09:02:55 <lambdabot>    arising from a use of `M744169713...
09:03:10 <ion> meh
09:03:13 <byorgey> dmwit: off the top of my head I don't know.  But I don't understand why it sounds ridiculous to you.
09:03:26 <koeien> :t do let b = False in guard b
09:03:27 <lambdabot> forall (m :: * -> *). (MonadPlus m) => m ()
09:03:44 <Cale> That's kinda like what my arrow situation is
09:03:47 <dmwit> I just don't see a lot of monadic code specialized to the Maybe type.
09:04:10 <dmwit> That's not true.
09:04:11 <aavogt> dmwit: you might use Data.Map.lookup a couple times. Then rather than converting it to [] at each occurence of lookup, you put it around the whole block
09:04:13 <Cale> justMapE :: (ArrowEvent (~>)) => (a -> Maybe b) -> Event a ~> Event b
09:04:37 <Cale> That actually can't be generalised to lists, because it would break the semantics of events in our system to do so.
09:05:29 <dmwit> Cale: Yep, I agree (as I said above) that justMapE listToMaybe sounds like a pretty legitimate use.
09:06:49 <Cale> So, in general, anywhere that you have to plug something which is list-like into something which requires a Maybe :P
09:07:09 <dmwit> Anyway, let me just say that I treat listToMaybe as a code smell. Smells don't always point to bad practice, but it seems to be used much more frequently in a "needless conversion" way by newcomers to Haskell than it does in a useful way.
09:11:08 <kmc> wait, beginners know about 'listToMaybe'?
09:11:14 <kmc> i thought they just used 'head'
09:11:26 <stribor> splitEvery 2 ["abcd","defghty","hffhfhfhf"]
09:11:43 <dmwit> "intermediaters"?
09:11:52 <kmc> listToMaybe xs = if length(xs) == 0 then Nothing else Just(head(xs))
09:12:32 <wavewave> wow, making generics for existential types is very tough topic.
09:12:42 <stribor> splitEvery 2 ["abcd","defghty","hffhfhfhf"] gives [["abcd","defghty"],["hffhfhfhf"]]??
09:13:22 <dmwit> Yes.
09:13:52 <dmwit> Compare splitEvery 2 "abcddefghtyhffhfhfhf" = ["ab","cd","de",...]
09:14:45 <dmwit> or maybe compare map (splitEvery 2) ["abcd", "defghty", "hffhfhfhf"] = [["ab","cd"],["de","fg",...],...]
09:16:44 <byorgey> wavewave: yes, it is.
09:16:50 <wavewave> \me was trying to understand why http://hpaste.org/51222 didn't compile. and finally led to http://stackoverflow.com/questions/2839713/existentials-and-scrap-your-boilerplate
09:17:07 <ion> > unfoldr (\xs -> splitAt 5 xs <$ (guard . not . null) xs) ['a'..'z']  -- In all honesty, the use of listToMaybe wasn’t that appropriate here.
09:17:09 <lambdabot>   ["abcde","fghij","klmno","pqrst","uvwxy","z"]
09:17:24 <stribor> what is basically differenc ebetween compiling haskel program or running it from ghci command line
09:17:33 <wavewave> byorgey: I am reading Rodriguez's thesis
09:17:34 <monochrom> speed
09:17:38 <koeien> stribor: performance.
09:17:45 <dmwit> stribor: Compiling is faster; interpreting is more flexible and observable.
09:17:52 <monochrom> oh, and debugger features
09:18:07 <monochrom> which is what dmwit says about observable
09:18:24 <stribor> koeien: dmwit  compiling it makes it into binary code?
09:18:30 <dmwit> Yes.
09:18:31 <koeien> stribor: yes
09:18:45 <stribor> dmwit: koeien tx
09:19:09 <Phyx-> does hackage keep track of any stats at all? how much a package has been downloaded?
09:20:17 <ziman> dons publishes statistics once in a while, so, yes.
09:20:43 <wavewave> http:/igitur-archive.library.uu.nl/dissertations/2009-0518-200422/UUindex.html
09:21:14 <Eduard_Munteanu> Meaning compiled code is faster.
09:21:22 <Eduard_Munteanu> Compiling itself is another thing.
09:25:06 <narens> If I want to depend on the libraries included in haskell platform is there a single package I can list as a dependency in the cabal file?
09:25:59 <byorgey> narens: no
09:26:23 <narens> byorgey: damn, so i have to include a whole list of packages i use all the time
09:26:59 <narens> byorgey: also, why doesn't cabal build automaticlly download the dependencies for my own cabal files?
09:27:27 <byorgey> narens: cabal build only compiles.  if you do 'cabal install' it will download dependencies for your own projects.
09:28:02 <narens> byorgey: i meant install actually, but I'll double check that I actually did an install
09:28:29 <byorgey> narens: oh come on, listing a few packages is not that much work. you only have to do it once per package.  and it ensures that other people have accurate information about the versions of various packages required to build your package.
09:29:52 <koeien> narens: 'install' should fetch the dependencies
09:29:55 <narens> byorgey: i was just making typical programmer complaints...
09:30:07 <byorgey> narens: =)
09:31:29 <meditans> hi, how do I write a class of the type class Foo a where f :: a -> b -> c forcing b to be member of another class?
09:31:48 <koeien> you need multiparam type classes for that
09:31:54 <meditans> the obvious f :: (Bar b) => a -> b -> c doesn't work for me
09:31:56 <narens> byorgey: If I have two executable targets (one main exec and the other a test exec) is there a way to let the test exec depend on the libraries in the main exec? Right now I just list all the required dependencies for both
09:32:01 <koeien> meditans: class Foo b a
09:32:15 <byorgey> meditans: why doesn't that work?
09:32:24 <koeien> hmm, maybe it's not necessary.
09:33:27 <byorgey> narens: I'm not sure. take a look at the Cabal documentation.
09:33:50 <meditans> it doesn't work because when I try to define a Foo member, ghci says: Couldn't match expected type.... `b' is a rigid type variable bound by the type signature for `processAction'
09:34:13 <monochrom> then you did something else wrong
09:34:14 <jpcooper> In the context of Data.Enumerator, let's say there an iteratee which may not use all of what it takes from a stream, and when it yields something, it gives what it doesn't use in the second field of the yield statement. Is there an Enumeratee, which, if the iteratee returns unused items, gives those to the iteratee before applying the enumerator on the iteratee?
09:34:17 <byorgey> meditans: can you please paste your code on hpaste.org?  it's hard to help without knowing exactly what you are trying to do.
09:34:27 <meditans> I could do class Foo b a but there are logically separated
09:34:36 <meditans> ok.. i will post it there in a minute
09:35:25 <monochrom> please don't assign blames prematurely. it's very confusing.
09:35:26 <koeien> meditans: works for me.
09:43:57 <hpaste> meditans pasted “no title” at http://hpaste.org/51239
09:45:50 <monochrom> caller of processAction, not callee, chooses b. as the callee, you can't hardcode b to Pendente
09:45:56 <koeien> meditans: not every a that instantiates Creature is a Pendente
09:46:24 <bayesian> This is the first time I've ever seen a language that had a community so willing to try and teach you. Do any other language communities come close to this or is Haskell an anomaly?
09:47:05 <meditans> hmmm.. and how do I write a function binding that works for every type I instantiate as a creature?
09:48:04 <wavewave> meditans: you should read type variable b as forall b.
09:48:10 <monochrom> use one single data type for all "creature"s, not many data types.
09:48:37 <copumpkin> I'm thinking of making a C function pointer caller library
09:48:41 <copumpkin> anyone interested?
09:48:43 <meditans> I could do that, but the creatures are indeed very different one from another
09:49:02 <copumpkin> or does the FFI have some secret facility for that that I'm not aware of?
09:49:20 <wavewave> meditans: so processAction should be defined for any type b in Creature typeclasses.
09:49:23 <meditans> do I need language extentions to do (b forall b)? And how do I write it?
09:49:53 <wavewave> processAction :: (Creature b) => a -> b -> Message -> a means
09:50:11 <wavewave> processAction :: forall b. (Creature b) => a -> b -> Message -> a
09:50:12 <Cale> bayesian: I really don't know, but we do try :)
09:50:30 <wavewave> you already declare it in that meaning.
09:50:33 <Cale> bayesian: I suspect all research languages will generally have a fairly helpful community.
09:51:07 <bayesian> I want to design an AI
09:51:09 <wavewave> therefore your instance of MondoPendente is violating processAction declaration in World typeclass.
09:51:10 <Cale> Haskell is sort of straddling the fence between being a research language and a practical real-world language.
09:51:46 <meditans> ok, I unterstood.. so I should write (forall b. Creature b) => a -> [b] instead?
09:52:37 <wavewave> meditans: no. what I mean is (forall b) is just omitted in meaning.
09:52:59 <wavewave> f :: a -> b is the same as f :: forall a b. a -> b
09:53:11 <monochrom> no amount of "forall" will solve your problem. in fact, more problems. in other words, your problem is you already have one too many "forall".
09:53:32 <wavewave> monochrom: that's right!
09:53:59 <monochrom> just use one single data type. KISS. until it doesn't support something you want supported.
09:54:35 <monochrom> and even then, say explicitly concretely what more you need supported, not blindly try every extension
09:54:44 <wavewave> meditans: depending on what you mean, you just use one type..
09:54:56 <bayesian> Haskell
09:55:21 <wavewave> meditans: if you need more flexibility, you can use type families. I am not sure that's what you want though.
09:56:27 <monochrom> this is why I never suggest an extension until I see the concrete specification
09:56:40 <meditans> i only wanted that the function a -> b -> whatever to be implemented for each member b of Creature. This isn't still implemented, so there isn't much to do, I think :D
09:57:18 <dolio> I suggest all extensions before seeing a concrete specification.
09:57:48 <monochrom> well yeah you could just say -fglasgow-exts...
09:58:14 <dolio> Actually, I tried using that a few days back, and it doesn't turn on all extensions anymore.
09:58:43 <aavogt> it probably never enabled overlapping instances
09:58:46 <dolio> You have to use -X options for most of the new ones.
09:58:53 <monochrom> but it has the advantage of being unspecific, therefore still causing no harm
09:59:10 <meditans> @monochrom: -fglasgow-exts...?
09:59:10 <lambdabot> Unknown command, try @list
10:01:02 <wavewave> meditans: see hpaste.org/51240 if you are interested in type family solution
10:01:43 <monochrom> why do you main = putStrLn "hahha"? it doesn't do anything relevant!
10:02:13 <wavewave> monochrom : sorry ;-P, just for compilation without any option to ghc.
10:02:46 <monochrom> oh, but you could have "ghci x.hs" instead of "ghc x.hs"
10:03:02 <hpaste> meditans pasted “solution?” at http://hpaste.org/51241
10:03:06 <wavewave> yup.. ;-)
10:03:18 <monochrom> a line of code can be saved by an extra "i" on the command line!
10:03:30 <monochrom> (ok, and an extra ctrl-d afterwards)
10:03:59 <meditans> is hpaste.org/51241 a valid alternative?
10:04:34 <wavewave> meditans: please do not use -fglasgow-exts : that is obsolete.
10:04:45 <monochrom> ok, someone really takes my -fglasgow-exts seriously...
10:05:01 <bayesian> we are yesterdays future today
10:05:08 <bayesian> that is what haskell is about
10:05:20 <wavewave> monochrom: not an offense. ;-)
10:05:34 <meditans> ok :D, I will not use it, what is then the standard solution? the one posted by wave?
10:05:47 <meditans> bayesian: ;)
10:05:49 <monochrom> that's an existential type you're using there. I'm unconvinced that it is relevant.
10:06:14 <wavewave> meditans: understanding each extension one by one is illuminating.
10:06:38 <meditans> i only do that in order to gain flexibility in Creature type, which can be anything
10:07:15 <meditans> wavewave: so the problem is I do not use only the extension I need, or the actual idea?
10:08:49 <meditans> I think I will use the wavewave solution, after studying the extensions :)
10:10:12 <wavewave> meditans: I guess that  type family is closest to what you meant. But in normal situation, that can be just an overkill.
10:11:02 <wavewave> meditans: by the way, in your second example, you can use {-# LANGUAGE ExistentialQuantification #-}
10:12:02 <wavewave> meditans: anyway, there cannot be a standard solution since they are using extensions.
10:12:40 <tomberek> is ArrayRef depreciated? any replacement?
10:12:48 <meditans> wavewave: existentialQuantification is considered obsolete?
10:13:13 <wavewave> meditans; no, no.. actually it should be included in the standard in my personal thought.
10:14:22 <meditans> wavewave: thanks, you helped me a lot :)
10:14:50 <wavewave> meditans: if you are from OOP world, existential type is a way to implement virtual function.
10:15:14 <tomberek> I ask because it looks like ArrayRef has failed builds since ghc6.10
10:15:21 <wavewave> meditans: Type family can be an associated policy class or something like that.
10:16:29 <wavewave> meditans: I often reinterprete OOP ideas using existential types and type families..
10:16:46 <meditans> wavewave: indeed I can see the connection with virtual functions
10:17:07 <wavewave> meditans: although there is often very simple and elegant solution using plain haskell98.
10:17:28 <meditans> wavewave: I will study typefamilies so that I complete the picture
10:17:53 <wavewave> meditans: simply speaking it's a function of type.
10:18:25 <meditans> wavewave: and in my case the solution in plain H98 can only be reducing creature to a Data?
10:18:33 <wavewave> if you have a type "A" then there is a related type "B".. if you have this situation, then type familiy is useful.
10:19:28 <meditans> wavewave: in my opinion families are an overkilling for my situation, indeed: I think existentials are what I had in mind
10:19:47 <wavewave> meditans: yes..  I do not find a special reason to define typeclass for Creature.
10:20:17 <wavewave> meditans: I would go for making Creature as a simple plain type.
10:20:48 <meditans> wavewave: that is because in my project I would be able to switch beetween a number of Creatures without changing much of my code
10:20:57 <jimothysmithers> my i ask a question here?
10:21:01 <jimothysmithers> may*
10:21:11 <meditans> wavewave: and a typeclass declaration would me help in that.
10:21:19 <monochrom> you may ask questions
10:21:26 <wavewave> meditans: then Existential Type can be useful with that typeclass.
10:22:20 <wavewave> meditans: just experiment several things. I am also always perplexed by too many possible solutions in haskell. but everything has a lesson for that.
10:23:07 <meditans> wavewave: well said, thanks again
10:24:55 <bayesian> humjan vs compute ris the wrong attitude
10:25:14 <bayesian> it should be a muttally beneficial relationship
10:25:24 <jimothysmithers> i'm new to haskell and learning about high-order functions, currying, and partial applications.  i am trying to partially apply the function "flip" with the argument "compare", as in (in ghci:) "let y = flip compare".  when i then try to evaluate "y 3 10", i get the error "No instance for (Num ())".  However, flip compare 3 10 works as expected.  What is happening under the hood that causes this to happen?
10:25:45 <wavewave> meditans:  you're welcome :-)
10:25:58 <koeien> jimothysmithers: monomorphism restriction
10:26:02 <Cale> jimothysmithers: The problem is that ghci is specialising the type of y (unhelpfully)
10:26:05 <koeien> it's evil imo, just switch it off
10:26:06 <monochrom> "let y a b = flip compare a b" for now
10:26:38 <mauke> let y a = flip compare a
10:26:52 <monochrom> and the cause is both monomorphism restriction and ghci premature specialising types
10:27:18 <jimothysmithers> alright, thanks a bunch guys!  I'll do that for now and learn about monomorphism restriction when i get a bit further with haskell
10:27:33 <tsuraan_> I'm trying to figure out why some libraries use MonadControlIO rather than just MonadIO.  The doc page says liftControlIO allows control operations to be lifted, but what does that mean?
10:28:18 <wavewave> i never found monomorphism restriction useful. it looks like a kind of bug
10:28:22 <monochrom> exception handlers do not have to be type "IO a" when you use MonadControlIO
10:28:33 <Cale> jimothysmithers: yeah, it's an annoying thing in the Haskell 98 standard which almost nobody actually likes. You can turn it off with {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file or  :set -XNoMonomorphismRestriction in ghci.
10:29:09 <Cale> jimothysmithers: It basically just says that things which don't look like function definitions aren't supposed to be polymorphic unless they have explicit type signatures.
10:29:19 <Cale> (pattern bindings)
10:29:32 <koeien> jimothysmithers: you can also put the :set -XNoMonomorphismRestriction in your .ghci file
10:29:44 <tsuraan_> monochrom: so MonadControlIO gives more flexible error handling?  Or is it actually better error handling?
10:30:12 <jimothysmithers> thanks all ~
10:30:14 <tomberek> is ArrayRef depreciated? or is there a replacement?
10:30:21 <monochrom> I am not sure there is a difference between "more flexible" and "better"
10:30:37 <tsuraan_> fair enough
10:31:24 <monochrom> but certainly if you are doing StateT IO and you want to catch an exception, you eventually want it to accept a handler of type StateT IO rather than insisting on just IO
10:32:04 <monochrom> one day you will really want to read or write the state in your StateT
10:32:14 <monochrom> when handling an exception
10:32:28 <tsuraan_> Is it typically straightforward to implement a MonadControlIO instance for a transformer?
10:32:49 <monochrom> for specific well-known easy transformers
10:33:00 <tsuraan_> I'm using Snap, and I'd like to also use a connection pool (from pool, or resource pool), but Snap doesn't implement MonadControlIO itself
10:33:03 <monochrom> but the package already does those for you, no?
10:33:26 <monochrom> oh, then you have to work hard for it or declare "it can't be done"
10:33:48 <monochrom> or you settle with an IO-only exception handler
10:34:41 <tsuraan_> I'd be happy with that, since I don't know the difference, but the library wants MonadControlIO :)
10:35:18 <tsuraan_> but Snap is a MonadIO, so I can use liftIO for the connection pool, probably.  It will uglify things a bit, but probably not too horribly
10:37:01 <int80_h> > :t (>>)
10:37:02 <lambdabot>   <no location info>: parse error on input `:'
10:37:08 <int80_h> > t (>>)
10:37:08 <lambdabot>   Couldn't match expected type `(m a -> m b -> m b) -> t'
10:37:08 <lambdabot>         against inf...
10:37:13 <int80_h> > (>>)
10:37:13 <lambdabot>   Overlapping instances for GHC.Show.Show (m a -> m b -> m b)
10:37:13 <lambdabot>    arising from...
10:37:25 <int80_h> hmm, how do I see the type of >>
10:37:31 <tsuraan_> how does the purpose of MonadCatchIO differ from MonadControlIO
10:37:50 <int80_h> >:t (>>)
10:38:26 <monochrom> MonadCatchIO is specifically for exception handlers and nothing else
10:38:36 <azaq23> :t (>>)
10:38:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:38:57 <monochrom> MonadControlIO should be good for something else in addition
10:39:05 <azaq23> > 4 + 2 -- > is only used for execution
10:39:05 <lambdabot>   6
10:39:19 <int80_h> ah thanks
10:39:21 <ski> @help run
10:39:21 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
10:39:28 <ski> @run 4 + 2
10:39:28 <lambdabot>   6
10:39:48 <tsuraan_> monochrom: is there something good I could read to understand this?  My googling isn't getting me very far
10:40:15 <monochrom> I just read the haddock. it brings up the example of alloca in "liftIOOp"
10:41:45 <monochrom> I think basically you just use liftIOOp and liftIOOp_ most of the time
10:42:41 <Clint> does the type signature of Data.Yaml.YamlLight.parseYaml make sense?
10:43:01 <tsuraan_> ok, so in that case, a simple liftIO would bring you from (a -> IO b) -> IO b to (a -> IO b) -> m b, but liftIOOp goes all the way to (a -> m b) -> m b
10:43:12 <tsuraan_> that makes sense, I guess
10:43:22 <tsuraan_> I at least see the difference now :)
10:43:38 * ski . o O ( hmm .. "monochromism restriction" )
10:44:09 <tsuraan_> the controlIO part is a bit too abstract for me.  The liftIOOp makes sense
10:44:36 <tsuraan_> still wish one of the Data.Pool instances worked on MonadIO though :-P
10:52:19 <hpaste> int80_h pasted “can't get the return type I want” at http://hpaste.org/51243
10:53:11 <mauke> int80_h: why do you think the return line is being ignored?
10:54:48 <monochrom> where can I find the type of incrementThenDone?
10:55:04 <mauke> in the paste
10:55:04 <monochrom> sorry, it's included
10:55:13 <int80_h> mauke: because in the past (while in main :: IO, anyway) I would sometimes have return () as my final statement to fix problems like this.
10:55:29 <mauke> int80_h: then you didn't look at the error message
10:55:30 <monochrom> putTMVar jCount jcount+1 :: STM whatever, not IO whatever
10:55:35 <tsuraan_> int80_h: you're trying to run putTMVar outside an atomically
10:55:45 <int80_h> ack!
10:56:10 <monochrom> Couldn't match expected type `IO ()' with actual type `STM ()'   it already honours your () part, it just finds conflict in IO vs STM
10:56:12 <mauke> also, spacing doesn't affect precedence
10:56:32 <monochrom> and yes, that is how I found out. I actually read that sentence for real
10:57:51 <tsuraan_> int80_h: I'm not sure, but I'd guess that you want the worldHandler to have a type of ProcessState -> JobCount -> STM () so it's entirely transactional.  At least, that's how it looks to me
10:58:32 <tsuraan_> pulling jcount out of the TMVar and then acting on it sort of defeats the STM
10:58:38 <monochrom> or it is IO () but the single atomically should cover more
10:58:45 <tsuraan_> yeah, or that
10:58:47 <int80_h> tsuraan_: I do want it to be transactional. I just thought I had to have the return type be IO (), because this function gets called from main :: IO ()
10:59:35 <tsuraan_> I'd have main call "atomically $ worldHandler ...", but that's just me.  I don't know what's normal or best
11:00:04 <int80_h> I'm trying to figure out what's normal. I expect to do it the exact wrong way in my first attempt.
11:00:39 <tsuraan_> yeah, definitely.  there seems to be a lot of wrong to explore :)
11:00:40 <int80_h> when this is all done, and appears to do what I want, I'll submit it to the beginners mailing list for critique.
11:00:55 <rwbarton> almost surely you do not want to atomically read the variable and then atomically write one more than the value you read
11:01:10 <rwbarton> unless your goal is to demonstrate race conditions
11:01:32 <int80_h> well let me tell you the problem I want this TMVar to solve
11:01:49 <int80_h> I'll hpaste this. There's some exposition.
11:02:14 <copumpkin> int-e: I was thinking
11:03:20 <copumpkin> int-e: the deep cloning operation you want would probably have to all be in C/cmm, as would be my deep serialization thing
11:06:57 <hpaste> int80_h pasted “want I want this TMVar to do” at http://hpaste.org/51245
11:08:49 <int80_h> rwbarton: could you evaluate my hpaste please?
11:09:01 <tsuraan_> int80_h: I think (MVar ()) would be almost perfect for you (http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html)
11:09:29 <tsuraan_> that's just a simple mutex, which I think is what you're looking for
11:10:15 <int80_h> tsuraan: I did consider MVar, I thought I was playing it safe with a TMVar which seemed to protect better against race conditions.
11:10:26 <rwbarton> @hoogle TMVar
11:10:26 <lambdabot> module Control.Concurrent.STM.TMVar
11:10:26 <lambdabot> Control.Concurrent.STM.TMVar data TMVar a
11:10:26 <lambdabot> Control.Concurrent.STM.TMVar isEmptyTMVar :: TMVar a -> STM Bool
11:10:35 <rwbarton> @hoogle readTMVar
11:10:35 <lambdabot> Control.Concurrent.STM.TMVar readTMVar :: TMVar a -> STM a
11:10:39 <tsuraan_> takeMVar will block until a value is written to it
11:11:06 <rwbarton> is readTMVar the STM version of takeMVar?
11:11:10 <rwbarton> @hoogle takeTMVar
11:11:11 <lambdabot> Control.Concurrent.STM.TMVar takeTMVar :: TMVar a -> STM a
11:11:11 <lambdabot> Control.Concurrent.STM.TMVar tryTakeTMVar :: TMVar a -> STM (Maybe a)
11:11:18 <int80_h> tsuraan: that's what I want. If there are two attempts to write, I want a block until the first attempt is done.
11:11:21 <mauke> well, more like the STM version of readIORef
11:11:23 <tsuraan_> so if you just initailize a given job's mvar with (newMVar ()), then one job will "have the mvar" and the rest will be blocking until it gives it back
11:11:38 <mauke> oh, TMVar
11:11:57 <rwbarton> am I imagining things or is there a TVar?
11:12:15 <rwbarton> @hoogle TVar
11:12:15 <lambdabot> module Control.Concurrent.STM.TVar
11:12:15 <lambdabot> Network.CGI getVar :: MonadCGI m => String -> m (Maybe String)
11:12:15 <lambdabot> Network.CGI getVars :: MonadCGI m => m [(String, String)]
11:12:20 <mauke> there is a TVar and it looks like an IORef (while TMVar looks like an MVar)
11:12:34 <int80_h> there is a TVar, I used TMVar because initially I was using an MVar. I thought it wasn't quite right so TMVar seemed the right way to go.
11:12:57 <rwbarton> oh, readTMVar puts the value back
11:12:57 <int80_h> right
11:13:12 <int80_h> I didn't like the description of readMVar
11:13:20 <int80_h> it seemed like trouble
11:13:22 <tsuraan_> yeah, you want takeMVar, I think
11:13:37 <tsuraan_> takeMVar blocks until somebody else writes the value back
11:13:56 <tsuraan_> and takeMVar is FIFO, which might matter to you.  not sure
11:14:15 <int80_h> oh I want FIFO
11:14:32 <int80_h> okay I'll go back to MVar then
11:14:38 <hpc> i thought it was FIFO, but only by coincidence
11:14:55 <hpc> because it happened to be the easiest way to implement, even if an order wasn't specified
11:14:58 <tsuraan_> hpc: the doc says that's one of the two properties.  that, and single wake-up
11:15:06 <hpc> oh, nvm then
11:15:10 <int80_h> what does single wake up mean?
11:15:11 <rwbarton> TMVar is useful if you want to do things like "take a value from both of these variables when they're both available"
11:15:13 <hpc> remembering something else then
11:16:07 <tsuraan_> int80_h: there's a complete explanation here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html#v:takeMVar
11:16:20 <int80_h> thanks :)
11:16:52 <tsuraan_> np :)
11:18:23 <rwbarton> int80_h: I didn't catch that you were using TMVar rather than TVar
11:19:12 <rwbarton> if you replace readTMVar by takeTMVar and add another "atomically $" I think you can get what you wrote to work, but it's overkill to use STM here
11:19:35 <int80_h> rwbarton: so, MVar?
11:20:18 <rwbarton> you can use MVar, yes, but again takeMVar rather than readMVar
11:20:52 <int80_h> right. I was still using read.... from the vestiges of my prior attempt which was wrong in so so many ways.
11:21:07 <rwbarton> and you need to putMVar the MVar back in both branches of the if
11:22:35 <int80_h> I just might actually get this finished today :)
11:26:08 <Olathe> ZOMG!
11:26:18 <zomg> dat so
11:26:30 <Olathe> If you have an embedded YouTube video, and it's taking a while to load, you can use the arrow keys to play a game.
11:27:08 <Olathe> Whenever it has that circling wait thingy.
11:27:45 <zomg> I prefer pressing reload because if a youtube vid takes that long to load it's usually a sign of it not going to load at all =)
11:28:15 <Olathe> Ahh, found something about it: http://bloggeritis.com/2010/07/26/new-youtube-feature-play-nibbles-while-the-video-is-paused-and-buffering/
11:44:11 <meditans> wavewave: I was rethinking at your solution with type families http://hpaste.org/51240; Line 25 warries me: what if I had to implement a world with two types of creatures? I couldn't write the kind annotation twice, right?
11:45:38 <balta2ar> my program produces some text output. one part of it is debug only and other part is informative and important for end user. what is the best way to leave debug messages in debug build and cut them in release build? -D and -cpp options? anything else?
11:46:29 <osfameron> @pl getPrimes s e ps = map fst . filter (all (/=0) . snd) $ makeTable s e ps
11:46:29 <lambdabot> getPrimes = (((map fst . filter (all (0 /=) . snd)) .) .) . makeTable
11:46:50 <osfameron> is there a nicer . operator for functions taking multiple arguments?
11:47:04 <osfameron> I've previously defined .: for a 2 argument terminal function
11:47:19 <osfameron> but this is 3 args
11:52:25 <ski> osfameron : what type do you want ?
11:52:52 <rwbarton> .⋮?
11:53:02 <JohnLong> is this language dying?
11:53:08 <krey_> o/, why do I get the error "Not in scope: data constructor `State'"? Apparently State is a type constructor only. Am I using the wrong package? (mtl)
11:54:01 <Olathe> JohnLong: People still speak it.
11:54:07 <osfameron> ski: Int -> Int -> [Int] -> [Int] (for both getPrimes and makeTable)
11:54:10 <mm_freak_> JohnLong: it's already dead
11:54:15 <mm_freak_> i think, nobody speaks latin nowadays
11:54:47 <krey_> mm_freak_: that isn't true, but it's off topic (look on wikipedia)
11:54:58 <Olathe> JohnLong: Why do you ask?
11:55:10 <JohnLong> I want to learn it
11:55:13 <JohnLong> ;)
11:55:19 <JohnLong> that's why
11:55:24 <osfameron> JohnLong: so why not ask "I'd like to learn Haskell, can you help?"
11:55:26 <osfameron> instead of trolling
11:55:55 <JohnLong> you are right
11:56:13 <bayesian> if haskell is so great why is it dead?
11:56:21 <Olathe> JohnLong: Well, I mean, what difference would its dying or not make to that? Are you worried that you'll learn it and the compiler will no longer be developed soon? Are you worried that you won't be able to get a job in it?
11:56:31 <ski> @let infixr 9 .::; (.::) = (.) . (.) . (.)
11:56:31 <lambdabot>  Defined.
11:56:36 <ski> @type let makeTable = undefined; getPrimes = map fst . filter (all (/=0) . snd) .:: makeTable in getPrimes
11:56:36 <lambdabot> forall (f :: * -> *) a. (Functor f) => f [a]
11:57:22 <ski> @hoogle (a -> Maybe b) -> [a] -> [b]
11:57:22 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
11:57:22 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:57:23 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:58:00 <kmc> JohnLong, http://haskell.org/haskellwiki/Hackage_statistics
11:58:55 <copumpkin> the big spikes are edwardk
11:59:11 <JohnLong> thank you , everyone I;m going to find some good book about haskell
11:59:20 <JohnLong> and learn it
11:59:40 <kmc> that was easy
12:00:15 <kmc> i don't understand these people
12:00:23 <kmc> "i want to learn Haskell but first i'd better ask #haskell if they think it's a good idea"
12:00:48 * osfameron joins #cobol to ask if it's dead
12:00:55 <osfameron> actually, though, I genuinely don't want to learn any more cobol
12:01:04 <kmc> osfameron, no, but most of the people who know it are :/
12:01:14 <ski> osfameron : try #clean instead
12:01:28 <monochrom> no, it was more like "I may want to learn haskell but first I'd better provoke #haskell with false accusations"
12:02:31 <osfameron> so that a) if they don't reply, you can go away knowing that it's dead, and not worth learning, and b) if they get uppity, you can slag off the community for being stuck up?
12:02:46 <kmc> smug haskell weenies
12:02:49 * osfameron is certainly worried that it'll be hard to find a *job* learning haskell, to be fair
12:02:51 <Olathe> #cobol has one person in it. I think it's dead.
12:03:08 <monochrom> krey_: old versions of mtl had State as its own data type. recent versions have State just a type synonym for StateT s Identity
12:03:12 <osfameron> well, irc is a bit unixy.  there's probably a fixed-record chat system for cobol
12:03:32 <kmc> osfameron, knowing Haskell will help you get a job
12:03:38 <kmc> but it will be a job programming Java
12:03:59 <osfameron> kmc: yeah.  I think knowing it is *useful* even indirectly
12:04:08 <kmc> employers like it
12:04:18 <monochrom> generally you can replace data constructor "State" by function "state" to migrate from old mtl to recent mtl
12:04:18 <krey_> monochrom: so how can I fix my code that uses the data constructor? or is that a bad practise anyway?
12:04:19 <kmc> it means you learned something hard and useless just for the hell of it
12:04:31 <kmc> they don't even care what
12:04:37 <osfameron> yeah.  certainly *I* would look very seriously at a CV that had haskell (or something else) on it
12:04:39 <dylukes> kmc: It kind of baffles me how "what languages you know" is even a valid question beyond fresh graduates.
12:04:40 <krey_> monochrom: oh, I see, cheers :)
12:04:41 <dylukes> I mean,
12:04:46 <yitz> Identification Division.
12:04:53 <yitz> Nickname Section.
12:04:54 <dylukes> after a certain point, it doesn't take more than a few days to pick up a language.
12:05:00 <osfameron> dylukes: oh, hitting-the-ground-running is a nice feature
12:05:09 <kmc> that depends which ones dylukes
12:05:20 <osfameron> and, for example, even if you know Java/Perl/C/Javascript, you might have a bit of trouble picking up a Haskell codebase, say
12:05:25 <kmc> going from Python to Ruby is one thing; Java to C or Haskell is quite another
12:05:28 <yitz> Set nickname to YITZ.
12:05:28 <dylukes> Yeah, but like, I don't know Perl or OCaml
12:05:34 <kmc> anyway most employers have no ability to assess your Haskell knowledge anyway
12:05:35 <dylukes> but I think I could pick them up in under a week if needed.
12:05:40 <kmc> so you should just put it on your CV regardless
12:05:46 <kmc> and if they ask you about it in the interview
12:05:54 <kmc> say something complicated-sounding about monads
12:05:58 <Olathe> Unless you're learning Haskell.
12:06:02 <osfameron> dylukes: yeah.  so you should definitely have programming language *genres* on your CV
12:06:24 <dylukes> I'm trying to learn prolog during math class right now.
12:06:37 * monochrom has Mathematica and XSLT on CV to show genre diversity!
12:06:40 <dylukes> We're doing propositional logic, but the rest of the class is dragging their feet while I'm just like "it's all sets maaaan"
12:06:50 <dylukes> ...and then I return to prolog learning
12:07:01 <monochrom> wait, prolog during math class?
12:07:15 <dylukes> It's a class of five people. Just the math "special people" who've finished all of the other classes.
12:07:23 <dylukes> But, their overly pedantic and miss the essence of ti.
12:07:42 <dylukes> Like, an entire chapter of the book is just introducing new terminology and making more explicit that: "hey, these predicates are mostly just set membership"
12:07:49 <dylukes> and they insist on spending hours on this.
12:08:10 <mm_freak_> actually i didn't find john's question provoking…  depending on your intentions it's an appropriate question to ask, before you learn a language
12:08:27 <mm_freak_> a bit unfortunate wording, but the question is fine
12:08:35 <kmc> omg u so smart dylukes
12:08:43 <dylukes> kmc: No no, thats not my point, and I'm not.
12:08:47 <osfameron> mm_freak_: it's just an odd assumption to make on first joining a channel
12:08:54 <dylukes> I have a few B-'s in math to show for that.
12:08:54 <osfameron> it's a reasonable thing to say, with a bit more context
12:09:02 <mm_freak_> osfameron: it wasn't an assumption, it was a question
12:09:04 <kmc> smart people often get bad grades...
12:09:05 * dylukes sucks at calculus.
12:09:27 <dylukes> No I mean, there are people in this class who can solve differentials I can't even figure out... in their heads.
12:10:08 <monochrom> it's pretty easy for small minds to nitpick on small imperfections. it is also the reason why so many people here are like "I swear by this ____ font I use even though it lacks 99.99999% of unicode, I don't use the other font that covers 50% because it's T has 0.1 more pixel than I like"
12:10:10 <dylukes> kmc: And, I don't think that's true of high school classes.
12:10:25 <osfameron> mm_freak_: if someone walks into a shop and says "Is this shop closing down?" do you think that's a pure question?  Or is it informed by assumptions (having heard the shop is losing money, or seeing that the shop display is old, or that it's understaffed, etc.)
12:10:33 <monochrom> s/it's/its/
12:10:39 <dylukes> High school classes are generally simple enough that if you're smart, you can get good grades (unless you procrastinate like hell).
12:11:31 <Olathe> Well, there are 786 users in the channel.
12:11:40 <Olathe> I think that's a good sign.
12:11:42 <mm_freak_> osfameron: i would probably wonder, if he asked the same question about C# or PHP, but when surfing around it's easy to get the impression that haskell is impractical
12:11:58 <kmc> Olathe, clearly it means people need lots of help with Haskell, that it's very confusing and poorly documented
12:12:02 <kmc> a good language would have 0 users
12:12:02 <osfameron> oh, sure
12:12:05 <monochrom> I have heard of people who can solve differential equations and memorize pi and compute cube roots in their head. they are called savants.
12:12:20 <dylukes> kmc: What about people who want to discuss a language :\?
12:12:33 <dylukes> People like to discuss even the simplest things.
12:12:36 <Olathe> Yeah, but even if it means it's confusing, it has enough life to get all those confused people in here to ask about it.
12:13:28 <Eduard_Munteanu> Discuss? Syntax and typing rules are beyond discussion, they're sacred.
12:13:57 <kmc> dylukes, this is like the only channel in the world that does that
12:13:58 <kmc> mm_freak_, Haskell *is* impractical, if you're not willing to put in serious effort toward learning it
12:13:58 <kmc> people aren't willing to put in the effort to learn a new tool because the tools they know are Good Enough
12:14:00 <Eduard_Munteanu> At least for a "one true language"
12:14:15 <dylukes> kmc: I guess that's true.
12:14:31 <mm_freak_> kmc: i mean beyond learning it…  some languages are impractical even after having learned them well
12:14:32 <monochrom> I don't ask a shop "are you closing down?". I ask "are you open until [time that I need it open]?"
12:14:52 <mm_freak_> mostly by lack of libraries (prolog), but also by the language itself (PHP)
12:15:01 <mm_freak_> (yes, PHP is impractical…  people just don't realize it)
12:15:23 <kmc> "stop making useful software! stop making billions of dollars! you're using the wrong tool!"
12:15:29 <monochrom> if you're sincere for #haskell answers, you ask "how much is haskell used?" not "is haskell dying?"
12:15:46 <kmc> i'm not sure what standard of "practicality" you're using mm_freak_
12:15:49 <Eduard_Munteanu> Synctactic sugar :P
12:15:53 <kmc> but it's clearly not an empirical one
12:15:56 <monochrom> if you want to greet me you ask "how are you today? is it good" not "how bad are you today?"
12:16:17 <kmc> it's also more practical for most businesses to hire 100 mediocre Java programmers than 5 good Lisp programmers
12:16:18 <yitz> one of the reasons people like this channel is because we don't ask them if they are dying the moment they join
12:16:20 <kmc> and get shit done that way
12:16:36 <yitz> as opposed to some other language channels
12:16:51 <kmc> you don't have to like this fact, and you can swear you'll never be one of those 100 mediocre Java programmers
12:16:56 <kmc> but it still means Java is a practical tool
12:16:56 <mm_freak_> kmc: PHP is fine, if you never have to touch code…  it's fine, if you can install typo3 and some extensions and be done
12:17:01 <dylukes> Is there really a need for everyone to be using the same languages though/
12:17:10 <mm_freak_> kmc: but as soon as you have to actually touch code, it's always going to take a long time
12:17:13 <dylukes> I mean, as much as I dislike working in Java, it lets some people get work they need to get done, done.
12:17:21 <MasseR> Can I define in cabal project file that a certain flag should be set for a dependency?
12:17:27 <dylukes> And it generally constrains them well enough they don't do anything terribly bad.
12:17:38 <kmc> yep, that's exactly the point dylukes
12:17:41 <Saizan> MasseR: no
12:17:41 <dylukes> So... I mean, I don't think Java is "evil" or anything like that.
12:17:53 <kmc> businesses want software development to be a predictable, repeatable process
12:18:01 <kmc> they're willing to accept a fixed inefficiency overhead for that
12:18:12 <mm_freak_> that's true
12:18:25 <bfig_> you mean an exponentially inefficient process :D ?
12:18:37 <zachk> time is money, and when you have lots of money, just throw money at the problem
12:18:38 <mm_freak_> bfig_: yes, but they go with it
12:18:41 <Nimatek> It's not evil, just horribly inexpressive and made obsolete by Scala.
12:18:57 <kmc> if you hire 5 Lisp savants to build your system, you're going to get something amazing in 10% of that time, and/or something totally insane which is only usable by those 5 people
12:19:02 <dylukes> Scala seems to have some pitfalls.
12:19:08 * ski is scared of continuing reading a matlab manual
12:19:10 <kmc> in fact getting 5 Lisp savants to cooperate might already be pushing it
12:19:11 <dylukes> And, I would say Scala might be a bit too... difficult to fit Java's niche.
12:19:29 <zachk> what about 3?
12:19:31 <Nimatek> Scala's main pitfall is having to be compatible to Java.
12:19:39 <dylukes> kmc: That's like getting 5 Yale students to admit Princeton might have a better program in some topic.
12:19:41 <dylukes> It's not happening.
12:20:37 <dylukes> But, yeah, predictability is king. i.e, when it comes to strains of wheats and corn and whatnot, what matters is not whether a strain will grow especially well in any given environment, but that its yield is consistent regardless of environment.
12:20:42 <bfig_> i believe the real problem behind all things related to mass project programming is that you need a team comprised of good engineers if you want to use a highly expressive language
12:21:05 <azaq231> dylukes: For high school math, but you'll have to be fast for exams, and for this do all the stupid rote questions. When you think too much about the underlying concepts, you tend to be slow at tests
12:21:05 <azaq231> and you'll likely overthink questions, as well as not recognize basic rote questions (for which the class was trained) on first sight. You'll have to provide things in the one way they are wanted and
12:21:06 <azaq231> if you can't do that, you're out.
12:21:24 <dylukes> Yeah :\.
12:22:04 <dylukes> jophish: heh, I have a friend with your nick
12:22:26 <dylukes> bfig_: I haven't seen first hand myself yet, but I get the feeling our educational system is not producing said engineers...
12:23:14 <jophish> dylukes, really? It's not often I see people with my nick
12:23:16 <bfig_> when i say good engineers i'm talking about guys who can handle from c pointer arithmetic in their heads to higher order functions in haskell
12:23:17 <dylukes> bfig_: I haven't been to college yet, so I can't say. But I have interned at a few workplaces, and the average cubicle programmer seems very good at getting rote tasks done, but not much good at anything else. I guess that's the job description/goal there though.
12:23:18 <jophish> What is he like?
12:23:30 <dylukes> jophish: Uh, chip musician, 16. He has your name on espernet.
12:23:37 <jophish> ah… him
12:23:42 <dylukes> Basically all of the google results for jophish are him.
12:23:43 <dylukes> Why?
12:23:44 <jophish> stealin' ma namez
12:23:55 <jophish> Could have been me :)
12:23:58 <bfig_> dylukes, that's exactly my point
12:24:19 <dylukes> bfig_: Care to take this to #haskell-blah
12:24:28 <bfig_> sure
12:33:47 <erus`> anyone know about google dart? (their new client side scripting language for browsers)
12:34:58 <Clint> is it haskell in disguise?
12:35:23 <ski> @quote sarah
12:35:23 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
12:37:25 <gwern> @quote want.to.learn
12:37:25 <lambdabot> No quotes match. I've seen penguins that can type better than that.
12:37:35 <gwern> hm. I was sure the quote was 'don't want to learn functional'
12:39:41 <int80_h> @hoogle repeat :: a -> [a]
12:39:41 <lambdabot> Prelude repeat :: a -> [a]
12:39:41 <lambdabot> Data.List repeat :: a -> [a]
12:40:36 <ski> @index repeat
12:40:36 <lambdabot> Data.List, Prelude
12:40:51 <monochrom> repeat is so repeated :)
12:42:33 <int80_h> is there a standard convention for creating a loop that just listens for a posix signal? The example I'm using does way more than I need.
12:43:07 <kmc> forever (threadDelay maxBound)
12:43:43 <int80_h> @hoogle forever
12:43:43 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
12:43:48 <int80_h> gotcha
12:47:06 <tommd> int80_h: fix forever
12:47:43 <int80_h> tommd: what?
12:47:49 <kmc> :t fix forever
12:47:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
12:47:53 <kmc> that's a busy loop in GHC, though
12:47:54 <tommd> Mathematically the same as kmc's solution.  If you have unlimited stack and don't mind processing resources being wasted then great.
12:48:36 <int80_h> oh, I get it. a joke.
12:48:39 <tommd> yes.
12:48:45 <kmc> how does it feel like to let forever be?
12:49:16 <int80_h> forever a mon (ad)
12:49:23 <Eduard_Munteanu> SSSSZ evah
12:49:54 <monochrom> for GHC-generated programs: if you install a posix signal handler, when you get a posix signal (more like the RTS gets it), the RTS does a forkIO or forkOS (I don't know which, it doesn't say) to run your signal handler. so you shouldn't need to write any waiting code
12:51:02 <int80_h> monochrom: I didn't know that. I explicitly forked a process for the purposes of having the parent process just listen for a signal
12:51:15 <monochrom> unless you seriously have no useful work to do in all existing threads
12:51:52 <int80_h> monochrom: but you're saying a process already gets forked when a signla handler is installed right?
12:52:03 <koeien> a thread, not a process
12:52:09 <int80_h> ah yes, a thread.
12:52:26 <monochrom> no. forkIO or forkOS. and happens when the signal is received, not when you installHandler
12:53:03 <int80_h> monochrom: how is it determined weather forkIO or forkOS happens?
12:53:06 <monochrom> hoogle for System.Posix.Signals and look for "installHandler" and look for its haddock, will you?
12:53:24 <monochrom> it doesn't say. "invoke action in a new thread when (or shortly after) the signal is received"
12:53:32 <kmc> int80_h, forkIO and forkOS do nearly the same thing, anyway
12:53:47 <monochrom> I would play safe and assume it's just forkIO, i.e., fewer guarantees
12:57:53 <hpaste> osfameron pasted “recursion for a prime sieve?” at http://hpaste.org/51247
12:58:01 <osfameron> any suggestions for how to recurse this?
12:58:23 <osfameron> I was thinking at some point that I'd want "concatScanl"
12:58:42 <osfameron> but I got myself so confused with it, that I don't know even how to write it with explicit recursion...
13:00:19 <monochrom> what does getPrimes do?
13:01:11 <osfameron> monochrom: there's a {- -} comment in the paste with sample output
13:01:40 <osfameron> monochrom: it gets the primes between the squares of the 2 primes passed in as integer inputs
13:02:08 <monochrom> I don't understand the examples in the comment. why does getPrimes 2 3 [2,3] equal a list of length 2 rather than length 3?
13:02:30 <osfameron> monochrom: oh, have I made a mistake?  what would you expect?
13:02:33 <monochrom> and similarly getPrimes 5 7 [...] is length 6 not 7. what does e mean?
13:02:53 <osfameron> oh I see
13:02:56 <monochrom> I don't know what to expect, that's the problem
13:03:17 <osfameron> ok.  I had a bit of trouble understanding what the guy that explained this algorithm was getting at too
13:03:36 <osfameron> so... s and e are (badly named) pairs of primes
13:03:50 <osfameron> so:  (2,3), (3,5), (5,7), (7,11)
13:04:05 <osfameron> and in each case, we're scanning for primes in the range of their squares.
13:04:21 <osfameron> e.g. [4..9], [9..25], [25..49], [49..121], ...
13:04:23 <monochrom> is it ok if s,e are not primes?
13:04:43 <osfameron> the function would still give an output
13:04:59 <osfameron> but I suspect it's not a useful one, at least for this algorithm
13:05:03 <monochrom> alright, what does ps mean?
13:05:22 <osfameron> ps is the list of primes already sieved, in the range [2..e]
13:06:23 <osfameron> so, when we check:  getPrimes 3 5 [2,3,5]
13:06:37 <monochrom> alright, getPrimes is not going to be very useful for primes, mainly because getPrimes wants to end somewhere
13:06:39 <osfameron> we're checking all the numbers [9..25] to see if they're divisible by 2, 3, or 5
13:07:29 <osfameron> monochrom: you could code the algorithm in an imperative language fairly easily
13:08:01 <monochrom> "primes = f primes" is trying very hard to be non-imperative though
13:08:26 <osfameron> the problem seems to be that we want to iterate the list a pair at a time *and* also retain a growing list of "primes to here", while also appending a variable length list of primes discovered to the list
13:08:31 <osfameron> hence it hurting my brane
13:08:50 <osfameron> monochrom: oh sure.  the algorithm as I've stared implementing it here, is trying to be functional
13:09:04 <osfameron> I just don't know how to do the recursive part functionally
13:09:22 <any-key> I've got a bit of a conundrum...I'm trying to generate an array of tuples that contains all the permutations of (x±2, y±2) without explicitely listing out all 8 possibilities...is there a good way to approach this?
13:09:24 <osfameron> whereas I'm sure I could hack at it imperatively and make it do something
13:09:42 <any-key> I'm not looking for a solution, just a suggestion for a technique, as I'm completely stuck
13:10:19 <monochrom> if I am not required to make use of getPrimes at all, I know how to finish "primes = f primes", but I suspect you have seen that one many times and you are not looking for another copy of it
13:11:15 <danr> > let ds = [-2,0,2] in [(x+dx,y+dy) | x <- ds, y <- ds, (dx,dy) /= (0,0)
13:11:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:11:19 <danr> > let ds = [-2,0,2] in [(x+dx,y+dy) | x <- ds, y <- ds, (dx,dy) /= (0,0) ]
13:11:20 <lambdabot>   Not in scope: `dx'Not in scope: `dy'Not in scope: `dx'Not in scope: `dy'
13:11:31 <danr> > let ds = [-2,0,2] in [(x+dx,y+dy) | dx <- ds, dy <- ds, (dx,dy) /= (0,0) ]
13:11:31 <lambdabot>   [(x + negate 2,y + negate 2),(x + negate 2,y + 0),(x + negate 2,y + 2),(x +...
13:11:44 <danr> i'm the biggest spammer today :(
13:12:17 <osfameron> monochrom: I've seen various sieves, sure (though please feel free to cite any particular ones if you think they'll be informative!)
13:12:30 <osfameron> that said, my main bafflement is how to recurse this particular case
13:13:00 <osfameron> (as it was an algorithm that someone asked me to help him code up, to see if haskell was a "good fit" for it)
13:13:22 <any-key> danr: thanks so much, that's really helpful
13:13:42 <ski> > mapM (\n -> [n+2,n-2]) [10,20]
13:13:42 <danr> any-key: np :)
13:13:43 <lambdabot>   [[12,22],[12,18],[8,22],[8,18]]
13:13:50 <monochrom> "getPrimes 2 3 (2 : 3 : undefined)" does that do exactly the same thing as "getPrimes 2 3 [2,3]"?
13:14:46 <monochrom> generally I want "getPrimes s e (ps ++ undefined)" to do the same thing as "getPrimes s e ps", at least for s, e, ps satisfying suitable preconditions
13:16:45 <osfameron> monochrom: hmmm?  that'll trigger an exception on the undefined won't it... *checks* yup, it does
13:16:51 <osfameron> I don't see what you're getting at tbh
13:19:14 <monochrom> generally for a scheme like "primes = f primes" to work, f must be happy to take an input like "x : y : ⊥" and output like "x : y : z0 : z1 : z2 : ⊥"
13:20:08 <osfameron> oh.  can you give me that example, in that case? ;-)
13:20:09 <monochrom> in the case of getPrimes, since in a sense how much of ps should be consumed is already known in s and e, there is no reason why getPrimes must see the last [] cell of ps
13:21:02 <osfameron> monochrom: well, makeTable is specifically creating a table of: [mod 2, mod 3, mod 5, ...] for the range of primes.  It's looking at all the elements
13:32:06 <hpaste> osfameron annotated “recursion for a prime sieve?” with “recursion for a prime sieve? (annotation)” at http://hpaste.org/51247#a51248
13:32:28 <osfameron> monochrom: ok, ^^ is done, using explicit recursion
13:32:44 <osfameron> that is quite horrible though, right? ;-)
13:36:19 <osfameron> oh, it's also wrong
13:36:21 <osfameron> but hey ho
13:37:43 <osfameron> ah, (<=e) fixes
13:45:11 <tswett> > (isUpper 'ʔ', isLower 'ʔ')
13:45:12 <lambdabot>   (False,False)
13:45:37 <tswett> @type \ʔa -> 3
13:45:37 <lambdabot> parse error (possibly incorrect indentation)
13:45:52 <Olathe> > (isNan 'ʔ')
13:45:52 <lambdabot>   Not in scope: `isNan'
13:45:56 <mauke> > isUpper 'ẞ'
13:45:57 <lambdabot>   True
13:46:13 <Olathe> > isLetter
13:46:14 <lambdabot>   Overlapping instances for GHC.Show.Show
13:46:14 <lambdabot>                              (GHC.T...
13:46:20 <Olathe> > isLetter 'ʔ'
13:46:21 <lambdabot>   True
13:46:26 <Olathe> Wow.
13:46:36 <stribor> is there better way to add empy space to begginignend end of each element of the list of Strings rather than what i came up with
13:46:39 <stribor> map (++" ")(map (" "++) xs)
13:47:00 <tswett> stribor: I'd probably use map (\x -> " " ++ x ++ " ") xs.
13:47:08 <mauke> map (printf " %s ")
13:47:22 <tswett> On second thought...
13:47:28 <stribor> whats \x?
13:47:42 <koeien> stribor: \ introduces an anonymous function
13:47:43 <osfameron> or map (\x -> intercalate x [" "," "]) ;-)
13:48:01 <Olathe> > map (\xs -> (' ':xs) ++ " ") "zomg"
13:48:02 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:48:02 <lambdabot>         against inferred ty...
13:48:05 <stribor> anonymys function?i have to look that up:)
13:48:09 <kniu> when a paper on writing a type checker says "fresh [skolem] variable", what do they mean?
13:48:11 <Olathe> > (\xs -> (' ':xs) ++ " ") "zomg"
13:48:12 <lambdabot>   " zomg "
13:48:14 <kniu> fresh w.r.t. what?
13:48:21 <koeien> stribor: i'm sure it's in Learn You a Haskell
13:48:23 <Olathe> > map (\xs -> (' ':xs) ++ " ") ["zomg", "thx"]
13:48:25 <lambdabot>   [" zomg "," thx "]
13:48:32 <mauke> stribor: \ is how you write functions
13:48:37 <mauke> stribor: \param -> body
13:48:44 <stribor> k
13:48:46 <kniu> do I seriously have to keep some state and generate new variables with it every time?
13:52:23 <JoeyA> Does finalizeForeignPtr also deregister the foreign pointer's finalizer so it won't be called a second time?
13:52:55 * ski wonders what paper kniu is reading
13:53:12 <JoeyA> I guess I found my answer: writeIORef refFinalizers (ftype, [])
13:54:21 <JoeyA> Before that: sequence_ finalizers .  I'm surprised it's that simple.  I figured calling a finalizer would entail plenty of hash marks and other gotcha-getters.
13:59:05 <stribor> why would you want to write anonymys function like that as opoose as i did map (++" ")(map (" "++) xs)
14:00:05 <koeien> stribor: for readability, perhaps. the pointfree style is not always clearer
14:00:07 <JoeyA> stribor: You mean like map (+3) [1..5] versus map (\x -> x+3) [1..5] ?
14:00:19 <koeien> @pl (\x y z -> x*y+z^x)
14:00:19 <lambdabot> ap (flip . (((.) . (+)) .) . (*)) (flip (^))
14:00:26 <mauke> JoeyA: no, literally that code above
14:00:27 <koeien> which would you rather read?
14:00:32 <stribor> as i was trying to add empty space to front and end of each element of list of strings
14:01:00 <Olathe> > map ((++" ") . (' ':)) ["zomg", "thx"]
14:01:01 <lambdabot>   [" zomg "," thx "]
14:01:19 <JoeyA> I like
14:01:23 <Olathe> > map ((' ':) . (++" ")) ["zomg", "thx"]
14:01:25 <lambdabot>   [" zomg "," thx "]
14:01:29 <Olathe> That's probably better somehow.
14:01:45 <Olathe> Easier to get the first element or something.
14:02:10 <jsternberg> does anybody know on this page: http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/doc/html/Data-Hash-MD5.html#t:WordList
14:02:10 <mauke> I'd use (" "
14:02:13 <mauke> I'd use (" " ++) there
14:02:20 <jsternberg> what exactly Zord64 is for the constructor WordList?
14:02:24 <ion> > let surround pre post = (pre++) . (++post) in map (join surround " ") ["foo", "bar"]
14:02:25 <lambdabot>   [" foo "," bar "]
14:02:29 <JoeyA> You could also say map ((" "++) . (++" ")) to make it symmetrical and nice-looking, but cons might be slightly faster.
14:02:35 <JoeyA> (than appending a single char)
14:02:40 <JoeyA> err, prepending
14:02:44 <mauke> JoeyA: unlikely
14:02:54 <koeien> appending at the end is slow anyway
14:03:04 <ion> I’d be surprised if (" "++) and (' ':) didn’t compile identically.
14:03:09 <ion> koeien: Not necessarily.
14:03:27 <Veinor> ion: what do you mean not necessarily?
14:03:45 <JoeyA> > map ((' ':) . reverse . (' ':) . reverse) ["zomg", "thx"]
14:03:46 <lambdabot>   [" zomg "," thx "]
14:03:50 <Olathe> jsternberg: Word64 is all 64-bit naturals.
14:04:04 <Olathe> I'm not sure why they didn't go with Nat64.
14:04:06 <Veinor> @src reverse
14:04:06 <lambdabot> reverse = foldl (flip (:)) []
14:04:19 <jsternberg> what does it mean in this context? I just want to find the md5 of a list of words
14:04:53 <jsternberg> similar to using hashlib in python
14:04:58 <ion> veinor: See e.g. difference lists, which consist of delayed (++)s which are very efficient.
14:05:24 <Veinor> ah, you mean 'not necessarily over all implementations of lists'
14:05:25 <JoeyA> http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/doc/html/src/Data-Hash-MD5.html#Zord64
14:05:33 <mauke> jsternberg: in what format?
14:05:37 <JoeyA> jsternberg: The Literate Haskell source answers your question
14:05:51 <JoeyA> "Nasty kludge to create a type Zord64 which is really a Word64 but works how we want in hugs ands nhc98 too... Also need a rotate left function that actually works."
14:06:15 <ion> veinor: Difference lists generate Haskell [] lists.
14:06:38 <Veinor> right, i know
14:06:49 <Veinor> but what i'm saying is that (++) is going to be slow regardless
14:06:56 <jsternberg> I got that Zord64 was a Word64, but I have no idea what to put into that constructor parameter
14:07:08 <any-key> I'm back with more questions! Does anything seem off with this syntactically? The compiler says it can't parse line 5: http://pastebin.com/pPBpktzv
14:07:10 <mauke> <mauke> jsternberg: in what format?
14:07:11 <mauke> I have copied your paste pPBpktzv to http://hpaste.org/51249 - pray I don't copy it any further.
14:07:11 <Olathe> It looks like Zord64 is the used as the remaining length of words in the WordList.
14:07:20 <ion> (++) is going to be inefficient if it needs to do a copy. If it doesn’t, you’re probably fine.
14:07:59 <jsternberg> say I've got a list of words ["hello", "world"] and I want to find the md5 of the words contained in that list
14:08:08 <mauke> <mauke> <mauke> jsternberg: in what format?
14:08:09 <any-key> the indentation got fucked in my paste...just ignore that
14:08:25 <mauke> any-key: no, the indentation is exactly what's wrong
14:08:27 <jsternberg> mauke: I'm not sure I know what you mean, it's a [String]
14:08:29 <sbrg> jsternberg: 1. download md5 library 2. apply md5 hashing function to strings in some way
14:08:38 <Olathe> jsternberg: Do you want the MD5 numerically or in the normal hex format or what?
14:08:40 <mauke> jsternberg: the md5 hash?
14:08:41 <any-key> mauke: should I be using hard tabs?
14:08:44 <mauke> any-key: no
14:09:12 <jsternberg> I want to convert the [String] to the digest string
14:09:14 <JoeyA> map Crypto.Hash.MD5.hash
14:09:16 <jsternberg> I have been using md5s for that
14:09:41 <mauke> jsternberg: good, where's the problem?
14:10:03 <ion> The digest isn’t a string. You can serialize it as a string, though. There are a number of options for such serialization.
14:10:19 <jsternberg> ion: I know, but I'm serializing it as a string
14:10:40 <jsternberg> well, it needs to be an MD5 type and I wanted to use it on a WordList, but I don't know how to create the WordList because I'm not sure what the second parameter means
14:11:02 <mauke> jsternberg: why do you want to use it on a WordList?
14:11:06 <mauke> jsternberg: I thought you had strings
14:11:12 <ion> A base-16 number? Base64 encoding? Base-2 with happy faces for 1s and frowny faces for 0s?
14:11:17 <jsternberg> I had a list of strings, and I wanted to combine them into a single hash
14:11:27 <mauke> jsternberg: combine them how?
14:11:29 <jsternberg> I could just use "show list_of_strings"
14:11:52 <jsternberg> and hash the resulting string
14:12:24 <jsternberg> I know how to do it in python, but not yet how to do it in haskell
14:12:39 <jsternberg> in python, I would do something like on this page: http://docs.python.org/library/hashlib.html
14:12:56 <mauke> jsternberg: what's the problem?
14:13:15 <jsternberg> what does the second parameter in WordList mean?
14:13:37 <mauke> jsternberg: stop looking at WordList, goddammit
14:13:38 <jsternberg> WordList ([Word32], Zord64), I get that Zord64 is a Word64, but that doesn't help me know what to put in there other than the type
14:13:49 <mauke> jsternberg: why do you even keep talking about WordList
14:14:16 <jsternberg> I'm using Data.Hash.MD5, and that's one of the types that it can take
14:14:24 <mauke> and?
14:15:10 <jsternberg> that's why I keep talking about it and why I keep trying to use it, since I _think_ it fits what I'm doing
14:15:33 <mauke> I don't see how it's relevant at all
14:15:47 <mauke> you want to hash strings. there's a MD5 Str instance.
14:15:52 <mauke> where does WordList come in?
14:16:14 <jsternberg> I want to hash a [String], not a String
14:16:29 <mauke> concat them first
14:16:36 <jsternberg> I _could_ do "show lst" to make it into a String, but I thought using WordList would be more appropriate
14:16:40 <ion> @hoogle [String] -> String
14:16:40 <lambdabot> Prelude unlines :: [String] -> String
14:16:40 <lambdabot> Prelude unwords :: [String] -> String
14:16:40 <lambdabot> Data.List unlines :: [String] -> String
14:16:48 <mauke> jsternberg: why not BoolList?
14:16:50 <ion> @hoogle [a] -> a
14:16:50 <lambdabot> Prelude head :: [a] -> a
14:16:50 <lambdabot> Prelude last :: [a] -> a
14:16:50 <lambdabot> Data.List head :: [a] -> a
14:17:12 <jsternberg> mauke: because I don't have a list of bools?
14:17:24 <ion> You have a list of words?
14:17:24 <mauke> jsternberg: you don't have a list of numbers either
14:17:56 <jsternberg> oh, whoops, I seem to have misunderstood the meaning of Word, I forgot about the second meaning
14:18:13 <jsternberg> sorry about that
14:19:18 <ion> Does word mean an arbitrary string in some language?
14:19:55 <dmwit> It means that when talking about regexes and in other language-based theory stuff.
14:20:41 <jsternberg> and in general conversation, and I had been looking at the "words" function earlier. I likely just confused myself.
14:21:53 <ddarius> "Word" does not mean arbitrary string in general conversation.
14:22:30 <mauke> word
14:22:37 <jsternberg> ddarius: meh, okay. then I was just being stupid
14:22:58 <ddarius> Though, related to dmwit's statement, the words referred to in the Word Problem for monoids would be exactly arbitrary strings for the free monoid.
14:23:19 <sbrg> jsternberg: tqBjLWB8
14:23:21 <sbrg> eh
14:23:24 <sbrg> jsternberg: http://hackage.haskell.org/packages/archive/nano-md5/0.1.2/doc/html/Data-Digest-OpenSSL-MD5.html
14:24:03 <mauke> sbrg: terrible
14:24:12 <sbrg> mauke: how so?
14:24:22 <mauke> sbrg: it returns a String
14:24:26 <mauke> that's crazy
14:24:54 <sbrg> mauke: not if that's what he needs
14:26:04 <mauke> no, I'm pretty sure this is objectively terrible
14:26:43 <sbrg> I can't really agree. If he needs the the 16 byte hex string output which is common, this makes it easy for him
14:26:44 <mauke> the correct type for md5 would be ByteString -> ByteString
14:27:09 <sbrg> as far as I can see there are none that allow you to do that
14:27:13 <stribor> i am trying to find function inside Split module but all of them offer one of the parametar
14:27:30 <sbrg> there's PureMD5 which looks like it returns some MD5Digest type which seems completey useless
14:27:41 <mauke> and that's why I program in Perl
14:27:47 <Olathe> ByteString -> Word128 ftw
14:28:13 <stribor> like for example split (endsWith "ly") "happilyslowlygnarlylily"
14:28:18 <sbrg> There's john goerzen's MissingH which returns 4 x 32 bit
14:28:29 <stribor> == ["happily","slowly","gnarly","lily"]
14:29:31 <stribor> but what if i wanted also to apply that cut off point must be at least 10 chars long
14:38:32 <wwall> I'd like to add two values of type UTCTime together
14:39:29 <mauke> how can you add two points in time?
14:40:27 <wwall> one is a starting time, one is really just a period of time
14:41:30 <mauke> shouldn't that then be a NominalDiffTime or something like that?
14:42:23 <wwall> perhaps -- I use parseTime to parse it
14:44:40 <wwall> can I convert between UTCTime and NominalDiffTime, and if so how?
14:45:56 <mauke> I don't think that makes sense
14:46:09 <ion> @hoogle NominalDiffTime -> UTCTime -> UTCTime
14:46:10 <lambdabot> Data.Time.Clock addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
14:46:10 <lambdabot> Prelude seq :: a -> b -> b
14:46:10 <lambdabot> Control.Parallel par :: a -> b -> b
14:50:36 <ion> λ> do now <- getCurrentTime; now' <- getCurrentTime; return (unsafeCoerce (unsafeCoerce now `mappend` unsafeCoerce now' :: (Sum Integer, Sum Integer)) :: UTCTime)
14:50:39 <ion> 2164-07-05 23:59:76891.765269 UTC
14:52:09 <Olathe> So that's when the world is going to end.
14:52:49 <lispy> I wish ghc could use MSVC on windows instead of requiring mingw
14:53:27 <ion> Use mconcat to add an arbitrary number of UTCTimes together.
14:53:30 <lispy> I want to use haskell for opencl on windows, but this means that I have to install some extra mingw utils, convert the .lib file to something that mingw can use and hope for the best
14:55:12 <stribor> i am trying to split the string based on what character is and also that every split must be at most 5 characters long
14:55:39 <stribor> i am looking into Data.List.Split functions that turn string into list of strings
15:04:23 <Peaker> stribor: found your answer?
15:05:21 <stribor> well i came up with something ..let me paste it
15:06:00 <hpaste> stribor pasted “splitting” at http://hpaste.org/51250
15:07:19 <stribor> Peaker:so this does what i want sort of..lol...i would also like somehow to apply that at each splitting place also must be character 'a'
15:08:43 <wwall> ion: I get this error when I try to use mconcat: No instance for (Monoid UTCTime)
15:09:21 <Peaker> stribor: that doesn't sound like what you said earlier
15:09:23 <ion> wwall: Sorry for the confusion, i was joking. See above that line.
15:10:18 <stribor> Peaker: my idea is to split string like at each 'a' and also that id like to control lenth of each splited chunk
15:10:33 <wwall> ah... ok. That's how little I know.
15:10:51 <Peaker> stribor: splitOn "a" ?
15:11:53 <stribor> Peaker: yeah thats fine but is also like to apply another condition such that every spitted part be at least 5 in length\
15:12:55 <ion> λ> concatMap (splitEvery 5) . splitOn "a" $ "fooooooooooooooooooooobarbbbbbbbaz"
15:12:56 <ion> ["foooo","ooooo","ooooo","ooooo","oob","rbbbb","bbb","z"]
15:13:14 <Peaker> stribor: if it's shorter than 5, then what?
15:13:53 <Peaker> stribor: give an example? Your example above didn't have any string rejected for being shorter than 5
15:13:55 <ion> λ> map (splitEvery 5) . splitOn "a" $ "fooooooooooooooooooooobarbbbbbbbaz"
15:13:55 <ion> [["foooo","ooooo","ooooo","ooooo","oob"],["rbbbb","bbb"],["z"]]
15:14:29 <stribor> let me write it
15:15:42 <stribor> ion: whats $
15:15:58 <Peaker> stribor: it's a low-precedence function application operator
15:16:03 <Peaker> f $ x = f x
15:16:31 <Peaker> because it's infix and low precedence, it can be used to save parenthesis, e.g:   sum . concat $ f x
15:16:37 <Peaker> == (sum . concat) (f x)
15:16:57 <Peaker> it can also be used as a "section":
15:17:09 <Peaker> > map ($5) [(*100), (+1000), (/3)]
15:17:10 <lambdabot>   [500.0,1005.0,1.6666666666666667]
15:17:24 <osaunders> I like to think of it as visually adding parenthesis to the right. So «a b $ c d» becomes «a b (c d)»
15:17:53 <ion> Heh. I looked at the line with concatMap and thought “hmm, it could be generalized as join . fmap f”, realized a second later that’s (=<<) and remembered another second later the Monad [] instance is defined with concatMap.
15:18:00 <stribor> http://hpaste.org/51251
15:18:09 <stribor> lets say you have long input string
15:18:24 <stribor> i want to find way to split it so that output is si,miliar in size
15:18:27 <hpc> ion: welcome to the "you could have invented monads and probably already did" club :D
15:18:43 <stribor> and that it splits at character that i will supply
15:19:19 <Peaker> osaunders: it also adds parenthesis to the left, if there's infix in there
15:20:13 <osaunders> Peaker: I suppose it does
15:20:14 <Peaker> stribor: what is the split logic in your example? It's not clear (to me)
15:20:30 <Peaker> stribor: sounds like you want a line-wrapping algorithm?
15:20:53 <osaunders> stribor: Do you know about «words»?
15:21:00 <osaunders> Just as a general point of interest
15:21:02 <stribor> osaunders: no
15:21:05 <osaunders> > words "foo bar zim"
15:21:05 <lambdabot>   ["foo","bar","zim"]
15:21:30 <stribor> >words "me you her anywhere"
15:21:35 <ion> λ> splitEvery 5 <=< splitOn "a" $ "fooooooooooooooooooooobarbbbbbbbaz"
15:21:35 <ion> ["foooo","ooooo","ooooo","ooooo","oob","rbbbb","bbb","z"]
15:21:42 <stribor> > words "me you her anywhere"
15:21:42 <lambdabot>   ["me","you","her","anywhere"]
15:22:23 <stribor> Peaker: yeah line wrapping with each line same or similoar in size
15:23:47 <ion> stribor: You may want to look at the LaTeX line-wrapping algorithm as implemented by whatever man(1) uses.
15:24:46 <mizugumo> To install dph-par for ghc 7.0.3, what version should I use? A cabal install without a specific version number attempts to get dph-par-0.5.1.1 which won't play with 7.0.3. Is there a way to get a list of all versions of a pachage that are available on Hackage?
15:25:08 <Peaker> stribor: you can use words, and then a scanl (+) on the lengths, and split at the points you want (or just a manual recursion/loop)
15:25:36 <stribor> Peaker: thanks
15:25:59 <vansonsamuel> why doesn't readFile have a hClose?
15:26:50 <Peaker> vansonsamuel: in its implementation?
15:26:53 <Peaker> @src readFile
15:26:53 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
15:27:09 <vansonsamuel> YAH!
15:27:10 <Peaker> Hmm.. I guess @src isn't the real implementation -- or maybe Handles have a closer finalizer
15:27:13 <vansonsamuel> no hClose
15:27:19 <mauke> vansonsamuel: hGetContents does
15:27:51 <Peaker> @src hGetContents
15:27:51 <lambdabot> Source not found. It can only be attributed to human error.
15:28:03 <vansonsamuel> I see
15:28:19 <vansonsamuel> semiclose
15:28:26 <vansonsamuel> very interesting thanks guys!
15:32:52 <mizugumo> Is there any way to get the correct version of dph-par for ghc 7.0.3? Hackage appears to only have dph-par-0.5.1.1, which won't work with 7.0.3
16:00:12 <stribor> can anyone explain scanl....explanation found here http://www.haskell.org/hoogle/?hoogle=scanl doesnt explain well
16:00:31 <Olathe> > scanl (+) 0 [1..10]
16:00:32 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
16:00:51 <Olathe> > scanl (+) 0 [a, b, c]
16:00:52 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
16:01:12 <Olathe> > scanl (++) "" "hello"
16:01:13 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
16:01:13 <lambdabot>         against inferred ty...
16:01:32 <Jafet> > scanl (flip ( :)) "" "hello"
16:01:33 <lambdabot>   ["","h","eh","leh","lleh","olleh"]
16:01:45 <Olathe> > scanl (:) "" "hello"
16:01:45 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:01:51 <Olathe> Lies!
16:02:09 <Jafet> > scanr (:) "" "hello"
16:02:10 <lambdabot>   ["hello","ello","llo","lo","o",""]
16:02:14 <Olathe> > scanl ((++) . (:[])) "" "hello"
16:02:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:02:26 <Jafet> lambdabot doesn't like your type.
16:02:27 <Olathe> scanr is the work of SATAN!
16:02:31 <Olathe> :(
16:02:56 <stribor> i mean explanation i found here "http://zvon.org/other/haskell/Outputprelude/scanl_f.html
16:03:20 <stribor> takes result and feeds it back to the function?
16:03:50 <Olathe> > scanl (++) "" . map (:[]) $ "hello"
16:03:51 <lambdabot>   ["","h","he","hel","hell","hello"]
16:03:58 <Olathe> Take that, type checker!
16:04:34 <Peaker> @let snoc xs x = xs ++ [x]
16:04:34 <lambdabot>  Defined.
16:04:38 <Olathe> stribor: Yeah, it starts with the starting value: scanl (...) starting_value ...
16:04:52 <ddarius> @where fold
16:04:52 <lambdabot> I know nothing about fold.
16:04:55 <Olathe> stribor: Then it uses the function given to combine the starting value with the first element of the list.
16:04:58 <ddarius> @where fold_diagram
16:04:58 <lambdabot> I know nothing about fold_diagram.
16:05:01 <ddarius> @where diagram
16:05:01 <lambdabot> I know nothing about diagram.
16:05:04 <stribor> ok so get second argument and first element of the list...applies function to them and then what?
16:05:12 <ddarius> @where folddiagram
16:05:12 <lambdabot> I know nothing about folddiagram.
16:05:21 <ddarius> @src scanl
16:05:21 <lambdabot> scanl f q ls = q : case ls of
16:05:21 <lambdabot>     []   -> []
16:05:21 <lambdabot>     x:xs -> scanl f (f q x) xs
16:05:46 <newsham> ?src wine
16:05:46 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:05:51 <newsham> ?where wine
16:05:51 <lambdabot> I know nothing about wine.
16:05:52 <Olathe> stribor: Then, it takes that as a new starting value and combines it with the second element of the list.
16:05:59 <Olathe> stribor: Then, it takes that as a new starting value and combines it with the third element of the list.
16:06:01 <ddarius> @source wine
16:06:01 <lambdabot> wine not available
16:06:19 <stribor> oh it doesnt use original second argument of function
16:06:41 <ddarius> @src scanr
16:06:42 <lambdabot> scanr _ q0 []     =  [q0]
16:06:42 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
16:06:42 <lambdabot>     where qs@(q:_) = scanr f q0 xs
16:06:52 <Olathe> stribor: Like scanl (+) 0 [1..3] will combine 0 + 1 to 1. Then, it'll combine that with the second element of the list, 2, to get 1 + 2 = 3. Then it'll combine that with the third element of the list, 3, to get 3 + 3 = 6.
16:06:56 <stribor> Olathe: get it...thank you
16:07:04 <Olathe> stribor: You're welcome.
16:07:35 <ddarius> scanl is just a foldl that returns its intermediate states.
16:07:42 <Olathe> It's like cumulative foldl.
16:07:46 <Olathe> Yeah.
16:07:57 <newsham> scanl is just a function for debugging foldl
16:08:35 <newsham> > scanl (+) z [x,y,z]
16:08:36 <lambdabot>   [z,z + x,z + x + y,z + x + y + z]
16:08:42 <Jafet> :t mapAccumL
16:08:43 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:09:12 <monochrom> scanl is pretty easy, until you tie another recursion around it. then you will need my http://www.vex.net/~trebla/haskell/scanl.xhtml
16:10:13 <Peaker> ddarius: scanl is more laziness friendly than foldl
16:10:15 <ddarius> foldl f z xs = acc = z; foreach(x in xs) { acc = f(acc, x); }; return acc;    scanl f z xs = results = [z]; acc = z; foreach(x in xs) { acc = f(acc, x); results = acc:results; }; return results
16:10:35 <Dashkal> Sometimes I find the conversion from an iterative algorithm to a functional/recusrive one to feel like pulling something inside out via its arm...
16:10:46 <Peaker> (each list item represents another step in the original list, so you aren't forced to consume the entire list as with foldl)
16:10:51 <ddarius> Peaker: That should not be surprising at all given my description.  It's pretty easy to get intermediate state out quickly.
16:11:20 <Peaker> ddarius: I agree, I think "just a foldl that.." misleads to thinking it also has similar operational properties
16:11:32 <Peaker> and similar "bottomness" semantics
16:12:14 <monochrom> "is just" is just a filler phrase
16:13:21 <ddarius> Peaker: I think describing it some substantially different way would be more misleading.
16:14:11 <ddarius> I think the real way to demonstrate that it can handle infinite input is to look at the source and see that it immediately returns a value and thus is productive.
16:14:12 <newsham> \a b -> a == Just b
16:15:29 <monochrom> or plug ⊥ into the source and calculate, and you get z:⊥, so you know it is non-strict :)
16:16:00 <Peaker> btw, foldl could also immediately return a value (though it would cost some...)
16:16:02 <monochrom> eh? a == Just b requires Eq
16:16:56 <ddarius> Peaker: What value does foldl (+) 0 [1..] immediately return?
16:17:31 <Peaker> the application of (+) _|_ and _|_ :-)
16:17:45 <copumpkin> that's true of everything then
16:17:54 <copumpkin> except it's not even true here
16:17:59 <Peaker> well, scanl could return (+) ... ...  but it returns _|_ directly
16:18:02 <Peaker> s/scanl/foldl
16:18:27 <Peaker> ddarius: for an inductive Nat type, rather than an atomic int type, it could return Succ (Succ (...
16:18:58 <dolio> No, it couldn't.
16:19:11 <Peaker> dolio: stdlib foldl couldn't, a lazier foldl could
16:20:00 <monochrom> someone wrote a lazier foldl. I forgot how to do it. but one of you should just show its code so we all calculate mathematically rather than argue philosophically
16:20:35 <hpaste> gabor pasted “closed categories?” at http://hpaste.org/51253
16:20:40 <monochrom> (yes, the Leibniz dream: so two philosophers in dispute can just say, "let's calculate!", and turn the crank and settle the question)
16:20:46 <Peaker> monochrom: I wrote one -- then someone helped make it O(N) instead of O(N^2)
16:20:56 <Peaker> here's the O(N^2) one:
16:20:58 <Peaker> lfoldl f z [] = z
16:20:58 <Peaker> lfoldl f z xs = f (lfoldl f z (init xs)) (last xs)
16:20:59 <monochrom> that's 31337
16:21:47 <hpaste> gabor annotated “closed categories?” with “closed categories? (annotation)” at http://hpaste.org/51253#a51254
16:21:50 <Peaker> @hoogle Nat
16:21:50 <lambdabot> Text.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
16:21:50 <lambdabot> Text.ParserCombinators.Parsec.Token natural :: GenTokenParser s u m -> ParsecT s u m Integer
16:21:50 <lambdabot> Text.Parsec.Token naturalOrFloat :: GenTokenParser s u m -> ParsecT s u m (Either Integer Double)
16:22:01 <Peaker> where's an inductive natural type defined?
16:22:14 <ddarius> :k Mu Maybe
16:22:15 <lambdabot> *
16:22:43 <dolio> lfoldl (+) 0 [1..] = lfoldl (+) 0 [1..] + _|_ = lfoldl (+) 0 [1..]
16:23:05 <gabor> my other question, when category-extras is deprecated, what is its substitute?
16:23:14 <ddarius> dolio: You missed an init.
16:23:23 <dolio> ddarius: No, I didn't.
16:23:27 <ddarius> gabor: A bunch of other modules.
16:23:33 <dolio> init [1..] = [1..]
16:23:42 <ddarius> dolio: Yeah, I was thinking tail.
16:24:00 <ddarius> But yes, my original point is that scanl is -always- productive.
16:24:07 <ddarius> (Which is a bit redundant.)
16:24:34 <dolio> My last equation is dubious, though.
16:24:43 <DanBurton> Hey guys, anyone familiar with the euterpea libraries?
16:25:02 <gabor> ddarius: I found category-data, but it does not seem to have the Apply class
16:25:09 <copumpkin> gabor: all of edwardk's packages
16:25:16 <copumpkin> look in semigroupoids, maybe
16:25:19 <ddarius> gabor: A bunch of other modules implies more than one module.
16:25:39 <gabor> okay, will go hunting
16:26:52 <ddarius> My spoon is too big.
16:27:44 <djanatyn> In Haskell, when processing text, would you use Parsec or regular expressions?
16:27:48 <Peaker> dolio: hmm.. you win :-) Even a lazier foldl can't do it :)
16:28:05 <dolio> However, the equation goes like: v = v + _|_. And _|_ is a fixed point even for lazy naturals.
16:28:30 <ddarius> djanatyn: Is the structure I'm extracting from the text encoded in a regular language or a context-free/sensitive one?
16:29:50 <ddarius> dolio: It depends on the definition of (+).  Types don't have fixed points, functions do. (And type constructors.)
16:29:51 <copumpkin> I am a banana
16:29:57 <ddarius> _|_ is not a fixed point of Succ.
16:30:19 <ddarius> copumpkin++
16:30:39 <Peaker> ddarius: I defined (+) as lazily as I can, I think, and I can't get it to produce anything
16:30:45 <monochrom> what? why do you call yourself a banana?
16:30:50 <copumpkin> http://www.youtube.com/watch?v=mbEUR6IEifA
16:31:04 <dolio> I didn't say types have a fixed point.
16:31:49 <dolio> I said, unclearly, that _|_ is a fixed point of f x = x + _|_ for (+) addition on lazy naturals.
16:32:03 <dolio> So fix f = _|_.
16:32:19 <ddarius> dolio: More simply, you can say (+) is strict in one or the other of its arguments.
16:33:30 <int80_h> I have a series of three functions that will be evaluated upon reciving a posix signal. Each of these functions will start a new process and run a new program. Each of these will return an exit value. If any of these functions recieves an error value from the called program I want to run another function to record an error message in a log file, then go back to listening for a signal. The onlt way I can think of doing this results in a ca
16:33:52 <ddarius> Or even more simply, summing repeat Zero is never going to produce a Succ but we'll never know that.
16:34:38 <ddarius> int80_h: Get a or configure your client to split long lines.
16:35:28 <monochrom> @let lfoldl f z xs = f (lfoldl f z (init xs)) (last xs)
16:35:29 <lambdabot>  Defined.
16:35:43 <int80_h> ddarius: my client has you saying this "Get a or" what did you put in between a and or?
16:35:53 <monochrom> > lfoldl (\x y -> 0 : x) undefined [0..]
16:35:54 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:35:58 <monochrom> \∩/
16:39:32 <ddarius> > lfoldl (+) 0 [1,2,3]
16:39:34 <lambdabot>   *Exception: stack overflow
16:39:43 <ddarius> monochrom: Doesn't seem quite right.
16:39:58 <monochrom> I omit the boring base case. who cares about finite lists!
16:40:09 <Jafet> cofoldl
16:40:18 <Peaker> > lfoldl (+) 0 []
16:40:20 <lambdabot>   *Exception: stack overflow
16:40:28 <ddarius> monochrom: Perhaps you should join me in my endeavor to define cofinite mathematics.
16:40:34 <ddarius> Deny finite sets!
16:40:43 <Peaker> @let relist (_:pat) ~(x:xs) = x:relist pat xs ; relist []      []      = []
16:40:44 <lambdabot>  Defined.
16:41:08 <monochrom> only in these several minutes when I contemplate lfoldl for infinite lists
16:41:16 <Peaker> @let faster_lfoldl f z xs = foldr (flip f) z (relist xs (reverse xs))
16:41:17 <lambdabot>  Defined.
16:41:40 <ddarius> monochrom: I'm sure we can develop a cofinite foundation for all of (the REAL) mathematics in several minutes.
16:42:01 <Peaker> @let lreverse = faster_lfoldl (flip (:)) []
16:42:01 <lambdabot>  Defined.
16:42:12 <Peaker> > length $ take 10 $ lreverse [0..]
16:42:13 <lambdabot>   10
16:42:18 <Peaker> > length $ take 10 $ reverse [0..]
16:42:21 <lambdabot>  Terminated
16:42:28 <Peaker> Astalavista, baby
16:43:06 <parcs_> that is really neat
16:43:10 <monochrom> > faster_lfoldl (\x y -> 0 : x) undefined [0..]
16:43:14 <lambdabot>   mueval-core: Time limit exceeded
16:43:44 <monochrom> > faster_lfoldl (\x y -> 0 : x) [] [0..]
16:43:47 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:44:02 <Peaker> it's just an artifact
16:44:08 <Peaker> > faster_lfoldl (\x y -> 0 : x) undefined [0..]
16:44:10 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
16:44:17 <monochrom> yeah, ok good
16:45:14 <Peaker> I guess since we have foldl and foldl' anyway -- "foldl" is so rarely useful that it may as well be replaced by faster_lfoldl?
16:46:16 <ddarius> No, foldl should just be removed.
16:46:29 <parcs_> but but lazy reverse
16:47:14 <ddarius> Because the need to reverse an infinite list into an infinite list of bottoms is common.
16:47:22 <Peaker> ;-)
16:47:57 <Peaker> maybe it has some other benefits? E.g: applying the function and returning immediately?
16:48:13 <parcs_> > head $ lreverse [0..]
16:48:18 <lambdabot>   mueval-core: Time limit exceeded
16:48:23 <ddarius> I only reverse lists when I don't care about the elements.
16:49:30 <Peaker> lfoldl will run in O(1) given some functions.. that might be useful in some rare contexts :)
16:50:25 <ddarius> So will foldl on some inputs where foldl' would not.  I still think foldl should be removed.
16:51:46 <Peaker> @src foldl
16:51:46 <lambdabot> foldl f z []     = z
16:51:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:51:57 <bfig_> @src monad
16:51:57 <lambdabot> Source not found. Wrong!  You cheating scum!
16:52:03 <bfig_> @src Monad
16:52:04 <lambdabot> class  Monad m  where
16:52:04 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
16:52:04 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
16:52:04 <lambdabot>     return      :: a -> m a
16:52:04 <lambdabot>     fail        :: String -> m a
16:52:04 <parcs_> ddarius: why do you think foldl should be removed?
16:52:26 <Peaker> ddarius: How can it run in O(1) in situations where foldl' does not?  Assuming the N here is the length of the list?
16:52:52 <Olathe> @src foldl'
16:52:52 <lambdabot> foldl' f a []     = a
16:52:52 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:53:10 <Jafet> We should index all the haskell code on hackage every year. The least used Prelude export gets dropped
16:53:25 <DanBurton> I'm trying to cabal install euterpea, but cabal-install seems to hang when compiling the very last file ( http://code.haskell.org/Euterpea/src/Euterpea/Audio/Render.hs ) any ideas why this would happen?
16:53:27 <Jafet> I wonder which one would get dropped first
16:53:31 <Peaker> The prostitute coding style: Replace all your seq's with $!'s...
16:53:45 <Draconx> Jafet, until there's no remaining exports in Prelude?
16:54:08 <Peaker> foldl' f a (x:xs) = flip (foldl' f) xs $! f a x
16:54:11 <ddarius> Jafet: That would not be trivial.  foldl, for example gets used in sum.  Does using sum count as a use of foldl?
16:54:22 <dcoutts> DanBurton: presumably it's ghc that's handing right?
16:54:32 <dcoutts> DanBurton: can you tell?
16:54:40 <ddarius> parcs_: foldl is virtually always not what you want.
16:54:42 <Peaker> $! is so much nicer to read than seq expressions
16:54:52 <DanBurton> dcoutts: I would imagine so. I just have a relatively new install of the Haskell Platform
16:55:08 <DanBurton> dcoutts: on Windows, if that makes a difference
16:55:14 <ddarius> Peaker: Bang patterns are better when applicable (such as in this case.)
16:55:14 <Jafet> ddarius: that's okay, everyone should use sum'!
16:55:28 <ddarius> Jafet: No, sum should be redefined in terms of foldl'.
16:55:28 <monochrom> > faster_lfoldl (\g _ v -> case v of {[] -> 0; x:xs -> x + g xs}) undefined [0..] [2,2,2,2,2,2,1]
16:55:28 <stribor> is there function that can be applied to list so the new list is created from elements that satisfy some condition
16:55:31 <lambdabot>   13
16:55:35 <monochrom> \∩/
16:55:37 <Peaker> ddarius: where are they applicable, if you get rid of the "let" there?
16:55:39 <Olathe> Everyone should define sum in terms of foldb.
16:55:43 <Olathe> It's usually faster.
16:55:59 <dcoutts> DanBurton: you can try compiling that module on it's own calling ghc directly with -v
16:56:04 <ddarius> Peaker: You just put a bang on each a.  The let is only there for seq.
16:56:06 <Jafet> product, too
16:56:09 <ddarius> @src foldl
16:56:09 <lambdabot> foldl f z []     = z
16:56:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:56:14 <monochrom> "I put a foldr in your lfoldl so you can add while you fix" :)
16:56:34 <Peaker> ddarius: but the seq is on the result of (f a x), not on the a?
16:56:47 <Peaker> oh, I see
16:56:52 <Peaker> it doesn't matter
16:57:37 <Peaker> ddarius: well, I was doing a mechanical translation, not a semantic one -- I think maybe $! should just replace seq as the value-side primitive? (And I agree bang patterns are nicer when applicable such as here)
16:58:01 <Peaker> s/value-side/rhs
16:58:04 <monochrom> stribor: yes, try: filter even [3,1,4,1,5,9,2,6,5,3,5,4]
16:58:14 <int80_h> one idea I had was to "map errorHandler [ListofFunctions", I would want to map to terminate when an exception
16:58:16 <stribor> monochrom: sweet
16:58:25 <int80_h> happened. Is that sensible?
16:58:31 <monochrom> Olathe: what is foldb?
16:58:42 <Peaker> int80_h: what kind of exception? What do you mean by "terminate"?
16:59:20 <Peaker> int80_h: map errorHandler [ListofFunctions] = [errorHandler f0, errorHandler f1, errorHandler f2, ...] the elements are independent
16:59:49 <ddarius> map errorHandler [ListofFunctions] = [errorHandler ListofFunctions]
16:59:59 <bfig_> how can i use the ByteString class comparing chars and converting from-to char arrays?
17:00:01 <Peaker> yeah, assuming the capital there was in error
17:00:03 <monochrom> I think you want mapM_ ioaction [data, data, data]? when ioaction throws an exception, that stops the processing
17:00:09 <ddarius> Peaker: That's not the problem.
17:00:10 <incluye> @src Monad
17:00:10 <lambdabot> class  Monad m  where
17:00:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:00:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:00:10 <lambdabot>     return      :: a -> m a
17:00:10 <lambdabot>     fail        :: String -> m a
17:00:24 <Peaker> ddarius: oops, that too :-)  I guess 3:50 am is not a good time to read code :)
17:00:27 <incluye> why is the "forall a b" there? isn't it implicit?
17:00:51 <monochrom> it is implicit. lambdabot just feels like writing them
17:00:59 <incluye> well, alrighty
17:01:03 <int80_h> monochrom: that's rught. But in this case the data in the list are functions.
17:01:17 <ddarius> The odd thing is that it writes them for (>>=) and (>>) but not for return and fail.
17:01:25 <Peaker> Isn't the forall in type-classes kind of a sneaky Rank2 in H98?  You couldn't really encode that as a record in H98
17:01:35 <monochrom> you can get the same expletives in ghci if you have -fno-print-explicit-foralls too
17:01:38 <ddarius> Peaker: For constructor classes, yes.
17:01:47 <Jafet> @let foldb _ z [] = z; foldb _ _ [x] = x; foldb f z xs = (f `on` foldb f z) `uncurry` splitAt (length xs `div` 2) xs
17:01:50 <lambdabot>  Defined.
17:02:00 <Jafet> > product [1..100000]
17:02:06 <lambdabot>   mueval-core: Time limit exceeded
17:02:06 <int80_h> monochrom: this was just an idea I had, if it's sound I'll run with it.
17:02:09 <Jafet> > foldb (*) 1 [1..100000]
17:02:09 <ddarius> Jafet: There's a better one if you assume commutativity.
17:02:10 <lambdabot>   282422940796034787429342157802453551847749492609122485057891808654297795090...
17:02:10 <monochrom> err, s/no-// :)
17:02:31 <Jafet> ddarius: better how?
17:03:12 <ddarius> Jafet: A better way of splitting the list.
17:03:37 <Peaker> ddarius: what about:  class Test t where test :: a -> t ?
17:04:32 <Peaker> If you convert it to a record, you have to take the "a" from outside, and lose the Rank2'ness? not sure if it makes any difference, though
17:05:42 <int80_h> monochrom: wait, didn't read what you said closely. I wanted to map a function over a list of functions. The function I'm mapping over with would stop processing upon an exception. Am I being clear?
17:05:48 <Peaker> I don't think I've seen any explanation about the connection between type-classes and higher-ranked types.
17:06:33 <Peaker> int80_h: you're assuming that "map" is churning over the list, item by item, executing the functions one by one?
17:07:21 <Peaker> int80_h: operationally: map generates a new list of thunks. If you only force the third thunk, for example, the first two won't hit their exceptions at all.. evaluation order in pure code is unspecified
17:08:43 <monochrom> mapM_ ioaction [f, g, h]  =  ioaction f >> ioaction g >> ioaction h.  if for example ioaction g throws an exception, that stops the pipe, ioaction h won't be executed. I don't care why ioaction g throws an exception: whether it is because ioaction hates g, or because g hates ioaction.
17:09:31 <monochrom> or because ioaction and g run away together
17:10:48 <ddarius> monochrom: g might just be going through a rough spell in g's life.
17:12:50 <hpaste> samg_ pasted “Cabal dependency problem” at http://hpaste.org/51255
17:13:11 <samg_> ^^ I'm having an issue with cabal dependencies and ghc 7.2.1. Wondering if I can hack around it so I can get DSH installed. :) Thanks
17:13:17 <int80_h> ddarius: g hasn't been sleeping well lately.
17:13:24 <dcoutts> samg_: do you understand what the message means?
17:13:46 <monochrom> oh good, dcoutts is here, I can stop now
17:13:47 <samg_> dcoutts: yeah. the hint package has a dependency that is incompatible with ghc 7.2.1.
17:14:12 <dcoutts> samg_: ok, and specifically?
17:14:14 <int80_h> g started going to support groups so he could learn to cry. Then he started sleeping like a baby. BUt then another faker started going to the same groups so he's back to not being able to cry, not able to sleep.
17:14:51 <samg_> dcoutts: hint requires unix < 2.5, but ghc 7.2.1 requires unix 2.5+
17:15:02 <dcoutts> samg_: right, so what would you try first to fix it?
17:15:40 <ddarius> Jafet: The other way is to split the lists into even and odd elements.  Though this would probably be worse in a sequential algorithm but better for a parallel version (namely sparking each half-list.)
17:16:16 * int80_h waves
17:16:43 <samg_> dcoutts: I'm not sure. I could downgrade ghc, but that isn't ideal. Maybe hint supports unix 2.5 and the package information is wrong.
17:17:30 <Eduard_Munteanu> roconnor: hey, I was reading your FewDigits paper (and it's quite nice). Any idea why it renders badly (typography-wise) in some viewers / at certain zoom levels?
17:17:33 <jeffcutsinger> Does it bother anyone else that GHC says "redundant" to mean "unnecessary"?
17:17:53 <dcoutts> samg_: the latter is a good guess. hint is making a conservative assumption that it doesn't work with unix-2.5 because the author was not able to test it (since that version of the unix package didn't exist when that version of hint was released)
17:18:00 <ddarius> jeffcutsinger: I don't know what you are talking about, but the answer is "no."
17:18:01 <Jafet1> Some unnecessary things are redundant.
17:18:19 <jeffcutsinger> For instance, "The import of `Data.Maybe' is redundant". That would be true, if I imported it twice. But I imported it once and didn't need it.
17:18:23 <dcoutts> samg_: so it's worth trying:  cabal unpack hint; cd hint; vi hint.cabal; cabal install
17:18:49 <samg_> dcoutts: Thanks! I was wondering how I could override the dependency information. I will give this a shot and report back.
17:19:01 <dcoutts> samg_: and more generally if you want things to work without fussing then use the haskell-platform rather than the latest ghc on its own
17:19:02 <copumpkin> jeffcutsinger: http://snapplr.com/6a97
17:19:31 <jeffcutsinger> copumpkin: I stand corrected.
17:19:38 <samg_> dcoutts: I had issues with haskell-platform and macports. I needed ghc to be linked against macports iconv, so I used haskell-platform to bootstrap ghc.
17:19:41 <copumpkin> :)
17:20:05 <samg_> dcoutts: I didn't strictly need it to be linked to macports iconv, but it keeps things simpler ;)
17:20:10 <ddarius> You know what burn well?  Dictionaries.
17:20:28 <dcoutts> samg_: ah yes, macports and ghc hate each other, because macports installs its own iconv masking the system one. I hear homebrew doesn't have that problem.
17:20:29 <Jafet> Don't burn them; you might need them to stop bullets
17:20:47 <samg_> dcoutts: yes, this exact issue is perhaps the one which will make me finally switch to homebrew.
17:21:54 <dik> hey guys, i think i have a new mascot for haskell: http://i.imgur.com/1XoDF.jpg
17:22:08 <monochrom> this is why I hesitate to get a mac, apart from money.
17:22:32 --- mode: ChanServ set +o copumpkin
17:22:32 <dik> do you like it?
17:22:52 --- mode: copumpkin set +b *!~tim@c-76-20-80-170.hsd1.ca.comcast.net
17:22:52 --- kick: dik was kicked by copumpkin (no)
17:22:54 <Olathe> ddarius: Maps and trees do too.
17:22:58 --- mode: copumpkin set -o copumpkin
17:23:00 <Jafet> I bet dik has dressed up as that already.
17:24:51 <samg_> dcoutts: hit an error after modifying hint.cabal: http://hpaste.org/51256
17:25:41 <samg_> Not sure which one was the error that caused it to fail to install
17:26:10 <monochrom> no one is supposed to re-install or re-build or re-whatever ghc-mtl
17:26:46 <monochrom> I would escalate this to "you have too many packages"
17:26:48 <dcoutts> seems ghc-7.2 doesn't depend on ghc-mtl
17:26:49 * Eduard_Munteanu thinks Dik sounds like a nice theorem prover
17:27:06 <dcoutts> so that means that hint should not use it, and should use mtl instead
17:27:32 <samg_> This is a clean install of ghc 7.2. ghc-pkg list | wc -l = 40.
17:27:42 <samg_> dcoutts: I will further edit the cabal file then
17:27:58 <dcoutts> samg_: so you'll find the error for why haskell-src failed earlier in the build log
17:30:36 <samg_> dcoutts: this is the whole thing: http://hpaste.org/51257  I see that haskell-src fails as well
17:31:23 <monochrom> hint.cabal says: build-depends: ... mtl, ...  if impl(ghc >= 6.10) { build-depends: ... ghc-mtl >= 1.0.1.0, ghc-mtl < 1.1.0.0
17:31:49 <monochrom> the comment, though, is particularly strange: "this is to protect against the accidental selection of the completely unrelated ghc'c ghc-mtl package"
17:32:23 <samg_> Yeah, that one is well beyond me
17:33:16 <samg_> So GHC has mtl built in now?
17:34:03 <monochrom> I don't understand how depending on ghc-mtl achieves not selected ghc-mtl, but surely hint doesn't need ghc-mtl's code, the dependency there is to hack cabal's selection
17:34:36 <monochrom> s/not selected/not selecting/
17:34:45 <samg_> If hint doesn't need it, then let's try installing hint without it
17:39:05 <samg_> Nope, ambiguous Prelude: base vs haskell98
17:40:34 <stribor> how can you find type from ghci
17:40:48 <monochrom> :type id
17:40:52 <stribor> :t
17:41:16 <monochrom> it can be an expression. :type id id id
17:41:33 <Jafet> It has to be an expression
17:41:42 <shachaf> :t id runST (return 5)
17:41:43 <lambdabot>     Couldn't match expected type `m t'
17:41:43 <lambdabot>            against inferred type `forall s. ST s a'
17:41:43 <lambdabot>     In the expression: id runST (return 5)
17:41:44 <Jafet> And you thought you had choice
17:45:24 <copumpkin> > runST $ return 5
17:45:25 <lambdabot>   5
17:45:47 <copumpkin> > runST `id` return 5
17:45:47 <lambdabot>   Couldn't match expected type `m t'
17:45:47 <lambdabot>         against inferred type `forall s....
17:46:45 <monochrom> SPJ says it: $ enjoys a hack to make runST $ blah work because runST $ do blah is so common
17:47:15 <Peaker> I heard that the higher-ranked stuff will be fixed at some point?
17:47:16 <Eduard_Munteanu> > runST . return $ 5
17:47:17 <lambdabot>   Inferred type is less polymorphic than expected
17:47:17 <lambdabot>    Quantified type variable...
17:47:39 <Eduard_Munteanu> Fixed?
17:48:04 <ddarius> The hack for ($) is retarded.
17:48:09 <copumpkin> :P
17:48:28 <monochrom> one way to do the general case is impredicativity, which is promised to be fixed or killed at some point
17:48:32 <Eduard_Munteanu> What does the hack consist of?
17:49:05 <ddarius> Probably f $ x gets rewritten as f x.
17:49:17 <monochrom> the hack consists of the type-checker having a special typing rule for $
17:49:25 <Eduard_Munteanu> Uh.
17:49:55 <monochrom> yeah, "x $ y" having the same exact typing rule as "x y" will do
17:50:28 <Eduard_Munteanu> How do you fix it using impredicativity? I've heard this before, but I'm unsure how you'd type ($) or (.)
17:50:33 <Jafet> So $ is secretly treated as syntax, which coincides with the fact that programmers use it as syntax
17:50:54 <ddarius> Eduard_Munteanu: The problem only comes up because Haskell lacks impredicativity.
17:51:18 <monochrom> impredicativity allows you to instantiate type variable t to "forall s. blahblah"
17:51:34 <Eduard_Munteanu> I have a feeling it doesn't work with ImpredicativeTypes either, no?
17:52:01 <monochrom> ImpredicativeTypes works or not works depending on ghc version
17:52:04 <ddarius> Eduard_Munteanu: It definitely does work with ImpredicativeTypes and would work even better if ImpredicativeTypes was properly implemented.
17:52:06 <Eduard_Munteanu> That seems to allow stuff like   Maybe (forall a. a)
17:52:25 <ddarius> If it wasn't for ImpredicativeTypes there would be no code like: runST $ do ...
17:52:28 <monochrom> actually it only partly works
17:52:46 <stribor> can you apply filter on the list that is a list of tuples
17:52:56 <Peaker> stribor: sure
17:53:00 <ddarius> stribor: You can apply filter on any list as the type states.
17:53:01 <stribor> cant you fo filter (==a) fst b
17:53:07 <stribor> wher b ois olist of tuples
17:53:15 <monochrom> yes, it allows Maybe (forall a. a), although in practice you use Maybe (forall a. Show a => a -> String) or something
17:53:22 <Eduard_Munteanu> Oh, so it covers both the issue of actually writing these types, as well as instantiating type variables like monochrom said
17:53:29 <Peaker> stribor: filter takes a predicate function and a list, you gave it 3 arguments there?
17:53:46 <monochrom> @type ($)
17:53:46 <lambdabot> forall a b. (a -> b) -> a -> b
17:53:47 <stribor> but thfiler (==a) (fst b)
17:53:57 <monochrom> @type runST
17:53:57 <lambdabot> forall a. (forall s. ST s a) -> a
17:54:01 <Peaker> stribor: thfiler?
17:54:01 <stribor> but problem is ftt b returns first element of tuple
17:54:13 <stribor> fst sorry
17:54:42 <Peaker> > filter ((==1) . fst) [(1,2),(2,3),(1,5)]
17:54:44 <lambdabot>   [(1,2),(1,5)]
17:54:54 <Peaker> stribor: like that?
17:55:04 <stribor> something like that
17:55:12 <stribor> what is (==1) .fst)
17:55:18 <ion> @unpl (==1) . fst
17:55:18 <lambdabot> (\ d -> (fst d) == 1)
17:55:30 <monochrom> with impredicativity, you take ($) :: (a -> b) -> a -> b, instantiate a to (forall s. ST s r), b to r, that's how you can get runST $ blah
17:55:47 <stribor> --==1 . fst?
17:55:59 <ion> @src (.)
17:55:59 <lambdabot> (f . g) x = f (g x)
17:55:59 <lambdabot> NB: In lambdabot,  (.) = fmap
17:56:02 <Eduard_Munteanu> I see.
17:56:16 <stribor> > :)
17:56:16 <lambdabot>   <no location info>: parse error on input `:'
17:56:26 <Peaker> stribor: (==1) . fst        applies fst and then (==1) on fst's result
17:56:42 <samg_> arg. it seems like it will be easier to just wait until these packages are updated to ghc 7.2.1
17:56:42 <stribor> Peaker: lost
17:56:43 <ion> «(==1) . fst» «(\x -> x == 1) . fst» «\y -> (\x -> x == 1) (fst y)» «\y -> fst y == 1»
17:57:09 <Eduard_Munteanu> Still, one thing I'm not sure of... while with RankNTypes the users (as modules) don't need to enable that extension. Why is it necessary to do this for ImpredicativeTypes?
17:57:26 <Peaker> > ((+100) . (*2)) 3
17:57:28 <lambdabot>   106
17:57:37 <Peaker> stribor: do you understand this example?
17:57:43 <stribor> no
17:57:56 <ion> > (((+100) . (*2)) 3) 4
17:57:57 <lambdabot>   106
17:58:02 <Olathe> Is there some site with explanations of rank-n types and impredicative types and all that from a programmer's rather than a type theory perspective?
17:58:05 <Peaker> > (+100) ((*2) 3)
17:58:06 <lambdabot>   106
17:58:15 <ion> (sorry)
17:58:16 <stribor> yeah i see that
17:58:24 <stribor> 2*3+100
17:58:40 <Peaker> stribor: (+100) . (*2)      is the function that multiplies by 2 and then adds 100
17:59:07 <Olathe> > ((+100) . (*2)) x
17:59:09 <lambdabot>   x * 2 + 100
17:59:43 <Peaker> stribor: so:   (==5) . fst       is the function that extracts first from tuple, and then compares it to 5
17:59:47 <Peaker> @type (==5) . fst
17:59:48 <lambdabot> forall a b. (Num a) => (a, b) -> Bool
17:59:56 <stribor> oh
18:00:04 <kizzx2> @type first (==5)
18:00:05 <lambdabot> forall b d. (Num b) => (b, d) -> (Bool, d)
18:00:18 <stribor> why would you write function that way
18:00:24 <stribor> isnt there more clearer way to write it
18:00:37 <stribor> what is . operator
18:00:42 <Peaker> stribor: You can write it as:  \(x, _) -> x == 5
18:00:46 <ion> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%28%28%3D%3D5%29+.+fst%29+%2842%2C+%22blah%22%29
18:00:51 <Olathe> That's pretty clear, since it removes the variables cluttering it in other ways.
18:00:53 <Peaker> stribor: or as: \x -> fst x == 5
18:00:55 <monochrom> "clear" is subjective
18:01:03 <stribor> monochrom: true:)
18:01:08 <ddarius> Olathe: There's not much to say.  Rank n types involve having forall types to the left of a function arrow.  (Really, it's allowing alternation between universal and existential quantification, but we don't have free existentials and there are some differences in an intuitionistic framework.)  Impredicativity is simply being able to instantiate a polymorphic type to a polymorphic type.
18:01:09 <ion> @src (.)
18:01:09 <lambdabot> (f . g) x = f (g x)
18:01:09 <lambdabot> NB: In lambdabot,  (.) = fmap
18:01:16 <monochrom> upload your brain for a free analysis
18:01:20 <Peaker> stribor: (.) composes functions in a processing "pipeline", right to left. it's the mathematical composition operator
18:01:20 <copumpkin> or you can be even fancier
18:01:28 <copumpkin> f (5, _) = True; f _ = False
18:01:42 <stribor> Peaker: tx
18:01:50 <Olathe> ddarius: Yeah, but "forall types" and "existential" and "universal" are all type theory terms.
18:01:53 <kizzx2> stribor: "this way" is called Pointfree (http://www.haskell.org/haskellwiki/Pointfree), you can see the motivation and the related opinions by searching that term
18:02:01 <Eduard_Munteanu> Olathe: you can also think in terms of who chooses the type
18:02:04 <ddarius> Olathe: They are also programming terms.
18:02:15 <Peaker> stribor: How do you describe a function to a friend? "fst x == 5" or "compares the first element to 5"?
18:02:19 <ion> stribor: Step 2 in the linked page shows the expansion of the (.) step.
18:02:27 <ddarius> And actually I meant to say just "forall" not "forall types" I edited the sentence in the middle.
18:02:41 <stribor> fst x == 5 its very clear
18:02:44 <ion> stribor: Exactly as the definition of (.) says.
18:02:52 <Peaker> stribor: do you mention the name "x" to your friend when you describe \x -> fst x == 5 to other humans?
18:03:14 <monochrom> he/she uses the name "it"
18:03:18 <stribor> yes'
18:03:34 <monochrom> so he/she may like \it -> fst it == 5 the best
18:03:35 <stribor> you dont mention x
18:03:45 <Peaker> stribor: I think most humans describe the information flow, and do not name the intermediate data in the flow
18:04:39 <monochrom> no, I think most humans use "it" a million times in a sentence and it refers to 2 million different things
18:04:47 <Peaker> stribor: anyway, there are various, interesting reasons to use this style -- I like that it exposes the structure of the processing, without having to reverse-engineer it from the variable names
18:05:10 <ion> When we get decent AI, we’ll be able to name everything “it” in our intelligent programming language.
18:05:17 <ddarius> monochrom: The people with whom you speak must have -very- long sentences.
18:05:45 <monochrom> i.e., go to #math and lurk around and hear "normal" humans (newbies) write like "so it equals 0 therefore it is a minimum?" (translation: f'(x) equals 0 therefore f(0) is a minimum)
18:05:55 <monochrom> err, s/f(0)/f(x)/
18:07:07 <ion> stribor: The (.) style isn’t only a different notation, it implies you’re *thinking* in terms of function composition and not the slightly lower level of shuffling data around.
18:07:44 <stribor> true....but since i am new to haskell just trying to get going with the olnaguage
18:09:02 <monochrom> another example of high clarity writing from "normal" humans (newbies): "x^3 = 3x -> 2x+x" (translation: x^3 differentiates to 3x, 3x equals 2x+x)
18:09:31 <monochrom> so (\it = fst it -> 5) is even clearer, although haskell won't like it
18:10:32 <monochrom> sorry, s/3x/3x^2/, s/2x+x/2x^2+x^2/
18:14:17 <Peaker> stribor: it takes a while to get used to the (.) style. somewhat ironically, that style is called "points-free" :)  ("point" is a mathy name for the function argument names which disappear in this style)
18:14:43 <Peaker> When writing concrete/specific code, rather than general code, naming intermediate results becomes more important, and then points-free is a net loss..
18:14:59 <Peaker> (and most languages only deal with concrete/specific code)
18:15:00 <stribor> Peaker: :)
18:16:00 <Olathe> @pl \x -> fst x == 5
18:16:00 <lambdabot> (5 ==) . fst
18:16:13 <ddarius> "Point" is not a mathematical name for the function argument names.
18:16:26 <Olathe> @unpl (5 ==) . fst
18:16:26 <lambdabot> (\ d -> 5 == (fst d))
18:16:47 <Eduard_Munteanu> "Function applied at some point"
18:17:38 <ddarius> The term "point-free" came from approaches to topology where you avoided and eventually entirely got rid of the notion of point (i.e. element of the space.)
18:17:41 <Eduard_Munteanu> vs. "Function (possibly obtained by composing two other functions)"
18:18:37 <Olathe> It's called point-free because the points (.) are so common, it's like they're being given out for free.
18:18:53 <monochrom> hahaha
18:18:54 <Eduard_Munteanu> Hm... but "point" commonly occurs in math in relation to functions.
18:18:54 <stribor> Peaker: can you also limit the results of filter function...such as
18:18:59 <Eduard_Munteanu> Like pointed sets etc.
18:19:00 <ion> Points are like fried onion rings.
18:19:01 <stribor>  > filter ((==1) . fst) [(1,2),(2,3),(1,5)]
18:19:07 <Jafet> You have to $ them later to make up for the points.
18:19:11 <ddarius> Pointed sets is something else entirely.
18:19:25 <stribor> but to return only fst of each tuple
18:19:33 <Eduard_Munteanu> Yes, I know what it is.
18:19:35 <stribor> [1,2,1]
18:19:56 <monochrom> you add a "map" stage for that
18:20:06 <monochrom> > map fst (filter ((==1) . fst) [(1,2),(2,3),(1,5)])
18:20:07 <lambdabot>   [1,1]
18:20:09 <stribor> it returns [(1,2),(1,5)]
18:20:10 <ddarius> Eduard_Munteanu: I'm not sure how it is relevant to anything that is being said here.
18:20:20 <Jafet> :t map
18:20:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:20:30 <ion> > filter (==1) . map fst $ [(1,2),(2,3),(1,5)]
18:20:31 <lambdabot>   [1,1]
18:20:33 <Peaker> stribor: you just want a map, then, not a filter
18:20:38 <stribor> cool..you can just apply function to each like that
18:20:41 <stribor> nice
18:20:41 <Peaker> > map fst [(1,2),(2,3),(1,5)]
18:20:42 <lambdabot>   [1,2,1]
18:21:00 <stribor> how you get lamdabot to execute
18:21:01 <monochrom> well yeah you can always write f (g (h (i x)))
18:21:02 <stribor>  >
18:21:05 <Eduard_Munteanu> ddarius: well the point occurs as an argument to a function.
18:21:11 <stribor>  >
18:21:16 <ion> By not prepending the > with an extra space.
18:21:17 <Peaker> stribor: no space before the >.  Just "> <expression here>"
18:21:24 <Jafet> > [ p | p@(x,_) <- [(1,2),(2,3),(1,5)], x==1 ]
18:21:25 <lambdabot>   [(1,2),(1,5)]
18:21:35 <stribor> >[1,2,3]
18:21:41 <Eduard_Munteanu> That is, when functions between two pointed sets preserve the point.
18:21:43 * hackagebot iproute 1.2.3 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.3 (KazuYamamoto)
18:21:55 <Olathe> > [2,3,4]
18:21:56 <lambdabot>   [2,3,4]
18:21:58 <ion> eduard_munteanu: I don’t see the point.
18:22:00 <stribor> > [1,2,3]
18:22:01 <lambdabot>   [1,2,3]
18:22:02 <Eduard_Munteanu> :)
18:22:03 <Peaker> @type \xs -> [ p | p@(x,_) <- xs, x==1 ]
18:22:04 <lambdabot> forall t t1. (Num t) => [(t, t1)] -> [(t, t1)]
18:22:22 <Eduard_Munteanu> I thought it was pretty common to refer to function arguments as points.
18:22:23 <stribor> > let a = "nice"
18:22:25 <lambdabot>   not an expression: `let a = "nice"'
18:22:35 <Eduard_Munteanu> Besides the topology argument, which seems a bit more remote than that.
18:22:37 <stribor> > [1,2,3,4,5]
18:22:38 <lambdabot>   [1,2,3,4,5]
18:22:42 <Peaker> > let a = "nice" in "stribor: " ++ a
18:22:43 <lambdabot>   "stribor: nice"
18:23:41 <stribor> Peaker: cool
18:25:16 <Eduard_Munteanu> Maybe it's less common in English though.
18:25:48 <ddarius> Eduard_Munteanu: No, the elements of a space are points.  It makes sense to say that x is a point in that context, i.e. x refers to a point in the space.  It doesn't make sense to say "x" is a point.  Going from f(x) = g(h(x)) to f = g ∘ h isn't getting rid of the points.  The first argument of f is still a point (if it was before.)
18:26:25 <Peaker> > let decode radix digits = sum $ zipWith (*) (iterate (*radix) 1) (reverse digits)   in   decode 2 [1,0,1,0,0]
18:26:25 <lambdabot>   20
18:26:49 <Peaker> > let powerset = filterM (const [True,False]) in  powerset "hello"
18:26:50 <lambdabot>   ["hello","hell","helo","hel","helo","hel","heo","he","hllo","hll","hlo","hl...
18:27:00 <Peaker> > let powerset = filterM (const [True,False]) in  powerset [1..3]
18:27:00 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
18:27:05 <Eduard_Munteanu> Oh, hm.
18:27:16 <Peaker> stribor: Haskell makes lots of toy functions very fun to write :)
18:28:01 <stribor> Peaker: i have experience in imperqtive languages....this get to be very hard to write simple for loop:)
18:28:32 <kmc> does anyone know of any efforts to revive 'buddha', the declarative debugger for Haskell?
18:28:55 <ddarius> kmc: Ask Bernie.
18:29:16 <kmc> is he on IRC ever?
18:30:04 <Peaker> stribor: the stuff that are learnt first in imperative languages require some "advanced" concepts to implement *exactly* in the same way.. The stuff that you can do in Haskell are often not possible to do as nicely in other languages (advanced concepts or not..)
18:30:38 <Peaker> stribor: also, there's no need to implement them exactly the same way -- but it requires a mental shift in the way you think about programming.. This is the hard part for experienced programmers
18:30:43 <ddarius> kmc: Maybe.  Not often.  You can email him.
18:30:48 <parcs_> for loops in haskell are like the ones in python
18:30:57 <stribor> parcs_: you right about that
18:31:02 <ddarius> parcs_: In that they don't exist?
18:31:08 <Peaker> parcs_: where's continue, and break?
18:31:13 <Peaker> parcs_: and "else" on the for loop?
18:31:35 <ddarius> Peaker: The more pointed question would be "Where's for?"
18:31:48 <Peaker> ddarius: you could say it's somewhat equivalent to forM_
18:31:57 <ddarius> Peaker: Except that it is not.
18:32:00 <Peaker> ddarius: why not?
18:32:54 <ddarius> forM_ is quite a bit more general in many ways, and is lacking in the ways you mention as well as others, particularly when compared to the usual C-like for.
18:33:13 <Peaker> well, I think "for" no longer means "init, cond, inc" to people
18:33:17 <Eduard_Munteanu> Cont gives you at least break, no?
18:33:24 <ddarius> I would say that's what it means to most developers.
18:33:40 <Peaker> though with a couple of monad transformers, you can implement a little for primitive that has "continue", "break", and Python's "else"
18:33:44 <ddarius> For the form limited to iterating over a collection, foreach is probably more denotative.
18:34:04 <Peaker> ddarius: Java and C# have both departed from the classic C "for", haven't they?
18:34:08 <ddarius> Peaker: No.
18:34:26 <Peaker> Java 5 added "for in"?
18:34:41 <ddarius> Java added for(int i : ints)
18:35:08 <Nafai> how hard is it to write a binding for a C library?
18:35:17 <ddarius> C# has for(int i in ints).  C# calls the latter a foreach loop, and I'm pretty sure so does Java.
18:35:19 <copumpkin> easy
18:35:20 <monochrom> depends on the C library
18:35:31 <Eduard_Munteanu> ... and the interface you want to expose to your users
18:35:32 <ddarius> Both provide and has always provided the C-like form.
18:36:43 * hackagebot dns 0.2.1 - DNS libary in Haskell  http://hackage.haskell.org/package/dns-0.2.1 (KazuYamamoto)
18:36:50 <ddarius> Peaker: Sorry, C# uses foreach(int i in ints)
18:40:21 <Peaker> Using insanity like: http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html  you can probably get a C-like for loop too :)
18:40:34 <ddarius> Peaker: You can, but that's not forM_.
18:40:48 <Peaker> Yeah, I thought he was talking about foreach-like loops
18:40:58 <Peaker> and then forM_ is close, except for the lack of break/continue/etc
18:42:53 <ddarius> Just choose an appropriate monad and you can have break/continue/etc. as well.
18:43:50 <Peaker> have to replace forM_ with something that delimits the block, though
18:50:56 <parcs_> Cont gives continue too
18:52:38 <parcs_> wait maybe not
18:53:07 <parcs_> maybe ContT does
18:54:24 <parcs_> forM xs $ \x -> callCC $ \continue -> do ...
18:55:42 <incluye> oh man haskell has everything
18:59:42 <tgeeky> @vixen can haskell has everything?
18:59:42 <lambdabot> church is my favourite computer scientist.
18:59:52 <tgeeky> @vixen can haskell do has everything?
18:59:52 <lambdabot> Ooh, functional programmers are so hot!
18:59:57 * tgeeky slaps lambdabot
19:01:21 * Olathe gasps.
19:09:23 <parcs_> :t calCC $ \break -> forM ?xs $ \x -> callCC $ \continue -> return ()
19:09:24 <lambdabot> Not in scope: `calCC'
19:09:29 <parcs_> :t callCC $ \break -> forM ?xs $ \x -> callCC $ \continue -> return ()
19:09:30 <lambdabot> forall a (m :: * -> *). (MonadCont m, ?xs::[a]) => m [()]
19:09:37 <parcs_> what now Peaker :P
19:09:59 <kmc> :t callCC $ \break -> forM ?xs $ \x -> callCC $ \continue -> return (break, continue)
19:10:00 <lambdabot>     Occurs check: cannot construct the infinite type:
19:10:00 <lambdabot>       a = (a1 -> m b, a -> m1 b1)
19:10:00 <lambdabot>       Expected type: a
19:11:25 <kmc> using "break" throws out the list you were building
19:11:26 <kmc> :/
19:11:29 <roconnor> Eduard_Munteanu: probably because of type-3 embedded fonts
19:11:48 <Peaker> Why ContT and not MaybeT (or EitherT if you want to extend break with data)?
19:11:57 <roconnor> Eduard_Munteanu: the work around is to use ghostview
19:12:23 <Peaker> also, we're emulating imperative languages, so start with forM_, later maybe add forM
19:12:32 <ddarius> kmc: break takes an argument
19:12:33 <parcs_> yeah i meant forM_
19:13:02 <ddarius> With enough mfix you can resolve that.
19:13:12 <parcs_> :t callCC $ \break -> forM_ ?xs $ \x -> callCC $ \continue -> return (break, continue)
19:13:12 <lambdabot>     Occurs check: cannot construct the infinite type:
19:13:12 <lambdabot>       a = (a1 -> m b, a -> m1 b1)
19:13:12 <lambdabot>       Expected type: a
19:13:57 <parcs_> kmc: nothing that IORefs can't fix
19:13:58 <ddarius> You'll never be able to nakedly return the continuation from callCC.  You could easily implement recursion with it, so somewhere you'll need a recursive type or something else to hide the recursion.
19:14:38 <nexx> is it normal, that the output of putStr will only displayed after a new line?
19:14:56 <parcs_> yes, stdout is line-buffered
19:15:06 <parcs_> @hoogle hSetBuffering
19:15:06 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
19:15:11 <parcs_> use that to change it
19:15:38 <nexx> thx
19:15:45 <parcs_> actually use hFlush
19:16:18 <meteficha> myPutStr str = putStr str >> hFlush stdout
19:16:33 <Eduard_Munteanu> roconnor: ah, I see. BTW, did you get any chance to implement that in Coq?
19:16:45 <roconnor> yes
19:16:48 <Eduard_Munteanu> (or Agda or..)
19:16:50 <Eduard_Munteanu> Ah.
19:17:00 <roconnor> you may be interested in my thesis
19:17:07 <Eduard_Munteanu> I am :)
19:17:24 <roconnor> http://r6.ca/Thesis/
19:17:46 <roconnor> http://r6.ca/thesis.pdf
19:17:47 <Eduard_Munteanu> Thanks, looks nice.
19:18:05 <nexx> thank you all
19:30:50 <parcs_> :t callCC $ \break -> forM_ ?xs $ \x -> callCC $ \continue -> ?f (break, continue)
19:30:50 <lambdabot> forall b a a1 (m :: * -> *) b1. (MonadCont m, ?xs::[a], ?f::(() -> m b, a1 -> m b1) -> m a1) => m ()
19:40:36 <Eduard_Munteanu> roconnor: you say classical propositions have one proof. Is this a general result?
19:41:34 <roconnor> I have some evidence of this
19:42:06 <roconnor> Eduard_Munteanu: http://r6research.livejournal.com/21747.html
19:42:59 <roconnor> Eduard_Munteanu: interestingly, Homotopy type theory defines level 1 types (aka propositions) to be something equivalent to types with one value.
19:44:14 <Eduard_Munteanu> Hm, interesting. What sort of extensional equivalence is this?
19:44:36 <killerswan> so, how on earth do I construct a NominalDiffTime?
19:44:57 <roconnor> killerswan: use diffUTCtime
19:45:05 <roconnor> Eduard_Munteanu: what do you mean?
19:45:10 <Eduard_Munteanu> roconnor: also, just to be sure, do you consider this to be true just in Coq's type theory?
19:45:44 <killerswan> roconnor: so I want to get the current time, and then get the time of 1 day ago
19:46:12 * Eduard_Munteanu doesn't know much model theory at all, so he's unsure what it means for two proofs to be equivalent
19:46:19 <roconnor> killerswan: oh you can also use fromInteger or realToFrac or such
19:46:25 <roconnor> killerswan: units are in seconds
19:46:37 <killerswan> roconnor: ok
19:47:00 <roconnor> killerswan: you may be interested in Data.Time.Calender instead if you don't care about time of day
19:47:20 <roconnor> Eduard_Munteanu: are you aware of the Curry-Howard isomorphism?
19:47:29 <Eduard_Munteanu> Yeah.
19:47:34 <killerswan> roconnor: I have a data source that is easy to convert to a UTCTime (Twitter)
19:48:08 <dolio> roconnor: At most one.
19:48:11 <roconnor> Eduard_Munteanu: so proofs are values of types which are propositions
19:49:00 <Eduard_Munteanu> Yes.
19:49:06 <roconnor> two proofs are the same if they are the same value in type theory.
19:49:42 <roconnor> what constitues the same value in type theory is a tricky question
19:49:57 <Eduard_Munteanu> Same normal forms?
19:50:04 <roconnor> in this case I'm considering two values as equivialent if they are extenstionally equivalent.
19:50:33 <roconnor> meaning that two functions are equivalent if for equivalent inputs they have equivalent outputs
19:50:45 <Eduard_Munteanu> Oh, I get it now.
19:51:11 <roconnor> and inductive types are the same if they they normalize to the same constructor with equivalent parameters.
19:51:20 <Eduard_Munteanu> I was thinking of extensional as being defined wrt an equivalence relation.
19:51:40 <roconnor> Also interestingly, the univalent axiom of homotopy type theory implies functional extensionality
19:52:31 <roconnor> Eduard_Munteanu: oh and dolio has a very important point.  classical propositions have *at most* one proof.
19:52:38 <killerswan> roconnor: fromIntegral is working perfectly. thank you!
19:52:42 <Eduard_Munteanu> Yes, sure... they may be false :)
19:53:03 <roconnor> killerswan: ya it is tricky because it is documentation is a quite subtle.
19:54:22 <Eduard_Munteanu> So I guess it makes no sense to ask if this generalizes to non type-theoretic approaches (e.g. "normal" math).
19:54:53 <roconnor> Eduard_Munteanu: there are other notions of what it means for proofs to be the same, but I'm not very familiar with them.
19:55:03 <killerswan> roconnor: yeah, I'd add a mention of fromIntegral to the documentation for NominalDiffTime, here: http://hackage.haskell.org/packages/archive/time/1.3/doc/html/Data-Time-Clock.html
19:55:48 <roconnor> killerswan: you could try sending a suggestion to the author
20:21:42 * hackagebot vector-buffer 0.4 - A buffer compatible with Data.Vector.*  http://hackage.haskell.org/package/vector-buffer-0.4 (VivianMcPhail)
20:22:55 <kniu> @hoogle Map k (m a) -> m (Map k a)
20:22:55 <lambdabot> No results found
20:23:05 <kniu> @hoogle Data.Map.Map k (m a) -> m (Data.Map.Map k a)
20:23:05 <lambdabot> Parse error:
20:23:05 <lambdabot>   --count=20 "Data.Map.Map k (m a) -> m (Data.Map.Map k a)"
20:23:05 <lambdabot>                  ^
20:23:14 <kniu> :|
20:23:36 <kniu> @hoogle f (m a) -> m (f a)
20:23:36 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
20:23:36 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
20:23:36 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:23:39 <copumpkin> sequenceA
20:24:06 <kniu> hm
20:26:00 <kniu> okay it worked
20:26:02 <kniu> now
20:26:43 <kniu> is there a better way to avoid the whole "ambiguous occurrence" thing when I import something like Data.Traversable or Data.Foldable?
20:27:01 <kniu> besides putting "hiding (a, bunch, of, stuff)" everywhere?
20:27:18 <kniu> like
20:27:21 <Jafet> import qualified Prelude
20:27:23 <kniu> C++'s "using" directive
20:30:06 <hpaste> Cale pasted “Buddha C compilation errors” at http://hpaste.org/51259
20:31:53 <parcs_> hehe, McPhail
20:32:01 <kniu> @hoogle (a -> m b) -> (b -> m c) -> a -> m c
20:32:01 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:32:01 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
20:32:01 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:32:09 <Cale> Vivian?
20:33:12 <kniu> @hoogle (a -> b -> m c) -> m a -> m b -> m c
20:33:12 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
20:33:12 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
20:33:12 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
20:33:38 <kniu> @hoogle (a -> b -> m c) -> m a -> b -> m c
20:33:38 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
20:33:38 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
20:33:38 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
20:33:55 <Cale> Vivian McPhail has a very strange blog: http://soloqi.wordpress.com/
20:35:44 <kniu> @hoogle (a -> m b) -> (b -> c) -> a -> m c
20:35:44 <lambdabot> Language.Haskell.TH.Quote dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (b -> Maybe (Q q)) -> a -> Q q
20:38:30 <copumpkin> :t flip ((.) . fmap)
20:38:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (f1 a) -> (a -> b) -> f (f1 b)
20:38:45 <copumpkin> :t flip ((Prelude..) . fmap)
20:38:45 <lambdabot> forall a a1 b (f :: * -> *). (Functor f) => (a -> f a1) -> (a1 -> b) -> a -> f b
20:41:11 <parcs_> intriguing blog
20:42:51 <Jafet> No comment.
21:17:59 <dobblego> is there a wget/curl-like library that doesn't rely on a native binding?
21:18:16 <JoeyA> Is fromIntegral overloaded internally by GHC for efficient conversions between fixed-size types?
21:18:26 <copumpkin> yeah
21:18:31 <JoeyA> thanks
21:19:09 <ddarius> It has REWRITE rules, its not "overloaded" any more than normal.
21:19:22 <JoeyA> ah, okay
21:19:50 <ddarius> Though I guess you could abuse the RULES pragma to implement something vaguely like C++-style overloading.
21:19:52 <JoeyA> dobblego: What's wrong with libcurl?  (sorry, that doesn't answer your question)
21:20:24 <copumpkin> dobblego: http-enumerator
21:20:25 <dobblego> yeah might just use that
21:20:25 <Jafet> @src fromIntegral
21:20:25 <lambdabot> fromIntegral = fromInteger . toInteger
21:20:36 <copumpkin> dobblego: it's quite nice, despite being all enumerator-like
21:21:00 <Jafet> You can also do it with type classes, but it probably gets messier
21:30:55 <wavewave> is there WebDAV client library using haskell?
21:31:21 * cmccann changes the haskell reddit's header image, in honor of the birthday of the most important researcher in the field of using pointless style
21:31:30 <wavewave> not low level http, somewhat high level
21:31:48 <copumpkin> cmccann: oh good idea!
21:32:21 <cmccann> copumpkin, it seemed reasonably appropriate, all things considered
21:33:14 <kmc> does anyone have an example of using GHC API (directly, not through hint) to evaluate "2 + 3" or so?
21:33:25 <kmc> i'm getting "Not in scope: `+'" and can't figure out how to make it import Prelude
21:34:08 <dankna> wavewave: I don't believe there is
21:34:15 <dankna> wavewave: feel free to write one :)
21:34:20 * cmccann has only used the GHC API to parse and type check whole files
21:34:32 * dankna has only used the GHC API to load precompiled modules :)
21:34:47 <dankna> kmc: imports don't exist at that level I think
21:34:57 <dankna> kmc: what you need to do is call it Prelude.+ instead
21:35:36 <kmc> Not in scope: `Prelude.+'
21:35:44 <kmc> also, neither hint nor ghci requires me to call it Prelude.+
21:35:53 <dankna> yes, but they might be doing something clever
21:36:03 <kmc> i would like to know what that clever thing is
21:36:06 <dankna> yes
21:36:07 <dankna> I also
21:36:19 <hpaste> wavewave pasted “ghc api” at http://hpaste.org/51260
21:36:19 <dankna> what function are you using to construct the name?  mkName?
21:37:00 <wavewave> kmc: I post my snippet of ghc api in some of my code base.
21:37:12 <wavewave> http://hpaste.org/51260
21:37:20 <dankna> yeah, the bot actually seems to be working agian
21:37:22 <dankna> *again
21:37:26 <dankna> it told us the link just one line above :)
21:37:55 <hpaste> kmc pasted “babby's first ghc api” at http://hpaste.org/51261
21:38:10 <dankna> haha
21:38:35 <dankna> runStmt eh
21:38:37 <dankna> never used it
21:38:45 <kmc> i don't know
21:38:45 <dankna> I would imagine that you need to import packages before you do that
21:38:52 <kmc> the API is a fucking mess
21:38:57 <kmc> either that or i've not found the right magic docs yet
21:38:58 <dankna> I didn't realize you were having it do the parsing for you
21:39:01 <dankna> no, the former
21:39:04 <dankna> it's a fucking mess
21:39:07 <kmc> i'm just guessing and trying to fit things together by their types
21:39:24 <kmc> also i'd be interested to know how to make it eval a parsed statement, too
21:39:39 <dankna> that's easier.  I'm not sure what the name of eval is, but you construct the parse tree? heh
21:39:40 <cmccann> the GHC API has a lot of stateful magic going on behind your back
21:39:47 <dankna> for values of easier that actually map to harder
21:40:01 <cmccann> things needing to be initialized in non-obvious ways, values being here at one stage of type checking then replaced with error thunks later
21:40:13 <dankna> yeah, beware of anything stored in static flags :(
21:40:19 <dankna> it's an unsafePerformIO'd global
21:41:08 <zzo38> Cycle in type synonym declarations: <interactive>:1:5-33: type T = $(return $ TupleT 0) In the Template Haskell quotation [d| type T = $(return $ TupleT 0) |]  In the expression: [d| type T = $(return $ TupleT 0) |] In an equation for `it': it = [d| type T = $(return $ TupleT 0) |]
21:41:15 <zzo38> Can you please tell me why there is error?
21:41:42 <zzo38> Even if I put $id instead of $(...) or use a different name instead of T it is same error.
21:46:00 <dankna> hm
21:46:04 <dankna> a shame zzo38 didn't stick around
21:46:07 <dankna> I see what his problem was :)
21:48:26 <copumpkin> dankna: he's back!
21:48:31 <dankna> so I see
21:48:49 <dankna> zz038: I'm not sure I should encourage pasting code in the channel, but I believe your problem is that you are constructing a type, not a declaration
21:49:05 <dankna> you need to wrap the type in a declaration - see the template haskell API docs
21:49:22 <dankna> oh wait, no, I see now
21:49:31 <zzo38> dankna: OK, but is the error message it displays the proper one?
21:49:44 <dankna> there's a known bug whereby you can't define a type synonym's body with Template Haskell
21:49:59 <dankna> the workaround is to do the entire declaration in TH instead
21:50:07 <zzo38> dankna: Then I think it is also the bug that it displays the wrong error message, isn't it?
21:50:09 <dankna> it's because of typechecking happening too soon (or, from another perspective, too late)
21:50:12 <dankna> let me find the ticket
21:50:13 <dankna> no
21:50:18 <dankna> no, the error message is correct as far as it goes
21:50:26 <dankna> it just doesn't really make it easy to understand the root of the issue
21:51:06 <dankna> http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
21:51:12 <dankna> not a ticket but a wiki page, although it links to some tickets
21:51:48 <hpaste> kmc annotated “babby's first ghc api” with “babby's first ghc api (working!)” at http://hpaste.org/51261#a51262
21:51:59 <dankna> ah!  nice
21:53:27 <augur> happy haskell day!
21:54:59 <wavewave> hmm. interesting. I got Segmentation Fault with the new snippet.
21:56:25 <wavewave> but compile and run gives rise to 5 RunOK .. so it's just my ghci problem...
22:01:24 <kmc> so it seems «runStmt "whatever" SingleStep» is not useful unless i set breakpoints first
22:01:27 <kmc> and i'm not even sure how to do that
22:01:31 <kmc> but it's probably annoying
22:12:05 * JoeyA celebrates Haskell day by writing his own PostgreSQL binding.
22:12:18 <dankna> good way to celebrate
22:12:24 <JoeyA> :-)
22:12:41 <dankna> would you consider trying to make them similar to my direct-sqlite?
22:13:01 <dankna> I know it's unlikely to be exactly the same, since for one thing PostgreSQL is network-based while sqlite is file-based
22:13:07 * JoeyA takes a look
22:13:13 <dankna> also because mine is incomplete featurewise
22:13:24 <cmccann> they both have "sql" in the name, how different could they be?
22:13:28 <cmccann> :V
22:13:32 <JoeyA> I only plan on implementing what I need.
22:13:34 <dankna> I don't implement, say, the virtual file system abstraction, or the ability to define custom predicates and collators
22:13:42 <dankna> yeah, that's what I did too
22:14:29 <dankna> what I implemented is a very small API, as you are probably already seeing
22:14:47 <dankna> I would not be adverse to factoring SQLData into a third package
22:15:40 <JoeyA> The reasons I'm not using HDBC-postgresql are: 1) It (currently) doesn't have a provision for proper BYTEA marshalling, and 2) HDBC <strike>is</strike> was licensed under the LGPL.
22:15:43 <dankna> although I'm not sure doing that useful
22:15:55 <JoeyA> I just found out that the latest version is BSD3: http://hackage.haskell.org/package/HDBC-2.3.1.0
22:16:06 <dankna> yeah, I made direct-sqlite for a couple of reasons, but among them was needing bytestring and utf8 support
22:16:45 <dankna> oh cool, they went BSD
22:17:26 <JoeyA> There are differences in how libpq (PostgreSQL's C API) deals with results.
22:17:59 <JoeyA> Namely, instead of stepping to get result rows one at a time, you get them all in one big PGresult.
22:18:19 <dankna> really?  isn't that strictly less memory-efficient?
22:18:22 <JoeyA> To lazily retrieve rows, you use DECLARE CURSOR and FETCH rows from that.
22:18:28 <dankna> oh hmmm
22:18:34 <dankna> okay, hmm
22:18:44 <dankna> whereas SQLite effectively always has the cursor, implicitly
22:19:23 <JoeyA> I'm basically trying to keep the underlying API fairly intact.
22:19:30 <dankna> right, of course
22:19:35 <dankna> maybe you should put out a version 1.0 first
22:19:48 <dankna> and we should worry about making them similar later
22:20:10 <dankna> I would love to have a lighter-weight-but-better-with-marshalling alternative to HDBC, though
22:20:39 <JoeyA> However, I do have to simulate the synchronous API using asynchronous calls; otherwise, GHC exceptions can't interrupt them (as far as I know).
22:20:47 <dankna> right, I imagine that's true
22:20:56 <JoeyA> HDBC-postgresql doesn't do that, by the way.
22:21:06 <dankna> the GHC RTS definitely can't interrupt when foreign code has control
22:21:21 <dankna> I see
22:21:29 <dankna> you might want to keep a single thread that makes the foreign calls then
22:21:30 <JoeyA> But it does handle the case where libpq is not compiled to be threadsafe.  I plan to sidestep that.
22:21:50 <JoeyA> Well, threadsafe or not, only one thread can manipulate a connection at a time, even with PostgreSQL.
22:23:09 <dankna> gotcha
22:23:56 <dankna> well, if you have a datatype PostgreSQLControlRequest you can make a Chan of it and feed requests to the connection-handling thread that way
22:25:01 <JoeyA> I believe HDBC-postgresql does something like that.  Namely, it uses a global lock.
22:25:22 <dankna> ah, yeah, a Chan is sort of an implicit lock
22:36:50 <JoeyA> If I call newForeignPtr on a pointer, should I immediately stop using the input pointer, even if I only do it on the next line?
22:37:26 <kmc> not necessary
22:38:12 <JoeyA> At what point does the input Ptr become illegal to use in the open?
22:38:15 <kmc> never
22:38:29 <kmc> but the finalizer can run at any time after the ForeignPtr becomes unreachable
22:38:30 <JoeyA> Then what is withForeignPtr for?
22:38:37 <JoeyA> ah
22:39:35 <kmc> assuming you don't want to use the Ptr after the finalizer has run, you should touchForeignPtr after your last use of the Ptr
22:39:46 <kmc> but it's better to use withForeignPtr even if you just had the raw Ptr
22:39:52 <JoeyA> aight
22:40:22 <cheater> hi
22:40:33 <JoeyA> hello
22:41:01 <JoeyA> In my case, I was going to use it to get the status of a connection object.  Looking at the source of HDBC-postgresql, they did it a simpler way: get the status before calling newForeignPtr.
22:48:17 <Veinor> ...
22:48:21 <Veinor> this module has a 'lazy version of take'
22:49:24 <ddarius> You can certainly make take lazier than it is.
22:50:00 <Veinor> it's zipWith (flip const)
22:50:14 <Veinor> ddarius: how so?
22:51:00 <ddarius> Well I guess you would have to assume that there are at least n element for take n.
22:51:52 <Veinor> i still don't see how zipWith (flip const) [undefined, undefined] is any more useful than take 2
22:53:40 <ddarius> Is it using the standard zipWith?
22:53:58 <Veinor> yeah
22:54:01 <Cale> Veinor: It's in the case where you don't know how many elements you want to take yet
22:54:23 <ddarius> Cale: So take n where n is a Nat?
22:54:31 <ddarius> With the Nat represented by a list?
22:54:37 <ddarius> (This is horrible.)
22:54:45 <Veinor> Cale: I still don't get it
22:55:01 <Veinor> (the other side-effect, i guess, is that you can 'take' an infinite list)
22:55:06 <Cale> ddarius: yeah
22:55:16 <Cale> ddarius: They're using lists instead of Nat
22:55:18 <Veinor> oh, now i get it
22:56:36 <kmc> :t let f (In (Just n)) (x:xs) = x : f n xs; f (In Nothing) _ = [] in f
22:56:37 <lambdabot> forall t. Mu Maybe -> [t] -> [t]
22:57:05 <Veinor> :t In
22:57:06 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
22:57:29 <kmc> @src Mu
22:57:29 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
22:57:46 <Veinor> ಠ_ಠ
22:58:15 <Veinor> so how do you take the first element of a thing with that f?
22:58:15 <kmc> ꙮ ꙮ
22:58:16 <ddarius> At any rate, what I was thinking of is take' 0 xs = []; take' n ~(x:xs) = x:take' (n-1) xs which will -always- produce a length n list regardless of what the input list is.
22:58:25 <kmc> Veinor, hmm?
22:58:54 <kmc> > let take' 0 xs = []; take' n ~(x:xs) = x:take' (n-1) xs in length (take' 5 [])
22:58:55 <lambdabot>   5
22:59:05 <kmc> > let take' 0 xs = []; take' n ~(x:xs) = x:take' (n-1) xs in take' 5 []
22:59:06 <lambdabot>   [*Exception: <interactive>:3:4-54: Irrefutable pattern failed for pattern (...
22:59:07 <Veinor> kmc: what are some values of type Mu Maybe?
22:59:26 <kmc> :t iterate (In . Just) (In Nothing)
22:59:26 <lambdabot> [Mu Maybe]
22:59:29 <kmc> > iterate (In . Just) (In Nothing)
22:59:30 <lambdabot>   [In Nothing,In (Just (In Nothing)),In (Just (In (Just (In Nothing)))),In (J...
22:59:42 <Veinor> ah
23:00:06 <kmc> Veinor,  see also http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html
23:00:39 <kmc> (Mu Maybe) is isomorphic to data Natural = Zero | Succ Natural
23:01:05 <Veinor> ahh, interesting
23:03:43 <kmc> > let add (In (Just n)) m = In (Just (add n m)); add Nothing m = m; fibs = In Nothing : In (Just (In Nothing)) : zipWith add fibs (tail fibs); fromNat (In (Just n)) = succ (fromNat n); fromNat (In Nothing) = 0 in map fromNat fibs
23:03:44 <lambdabot>   Couldn't match expected type `L.Mu Data.Maybe.Maybe'
23:03:44 <lambdabot>         against inferr...
23:04:01 <kmc> > let add (In (Just n)) m = In (Just (add n m)); add (In Nothing) m = m; fibs = In Nothing : In (Just (In Nothing)) : zipWith add fibs (tail fibs); fromNat (In (Just n)) = succ (fromNat n); fromNat (In Nothing) = 0 in map fromNat fibs
23:04:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:05:02 <ddarius> I guess BlueBottle evolved to A2.
23:05:21 <kmc> > let fibs = [] : [()] : zipWith (++) fibs (tail fibs) in map length fibs
23:05:26 <lambdabot>   mueval-core: Time limit exceeded
23:05:56 <kmc> > let fibs = [] : [()] : zipWith (++) fibs (tail fibs) in map length (take 5 fibs)
23:06:00 <lambdabot>   mueval-core: Time limit exceeded
23:06:25 <Veinor> > let take' 0 xs = []; take' n ~(x:xs) = x:take' (n-1) xs in length $ take' 5 []
23:06:26 <lambdabot>   5
23:06:33 <Veinor> > let take' 0 xs = []; take' n ~(x:xs) = x:take' (n-1) xs in length $ take 5 []
23:06:34 <lambdabot>   0
23:06:39 <kmc> it works in my ghci... but is very slow of course ;)
23:06:40 <cmccann> '(...) and, when judging the relative merits of programming languages, some still seem to equate "the ease of programming" with the ease of making undetected mistakes.' ah, how little has changed in 30 years.
23:06:48 <Cale> @undefine
23:07:19 <Cale> :t cata
23:07:21 <lambdabot> forall (f :: * -> *) a. (Functor f) => (f a -> a) -> Mu f -> a
23:07:23 <kmc> cmccann, that's a quote from 30 years ago?
23:07:29 <Cale> have fun
23:07:33 <kmc> :)
23:07:53 <cmccann> kmc, it's EWD, from the late 70s or so I think
23:08:30 <cmccann> EWD667 if you're interested
23:08:37 <kmc> ah
23:09:10 <cmccann> dijkstra is always great for pithy quotes about the sorry state of software development
23:09:41 <koeien> plus ca change...
23:09:51 <Veinor> 'goto considered harmful' considered harmful
23:10:29 <ClaudiusMaximus> i have around 2000 images at around 8MB each,  some of them are very similar to others.  what's some nice algorithm that will get me a "diverse" yet "representative" small subset of images?
23:10:45 <Veinor> do you have a distance metric?
23:10:59 <ClaudiusMaximus> probably some metric based on colour histograms
23:11:08 <Veinor> if you can construc a metric on images then there's probably some algorithm to do this
23:11:11 <koeien> you could look at fourier transforms, but it depends on how the images are different
23:11:22 <kmc> if you have a metric in mind you can use k-means clustering
23:11:39 <theorbtwo> How many highly similar images are you going to have?  Just pick 20 at random, and the chances of getting too many of them that are quite similar is very low.
23:12:23 <kmc> not as low as you might think
23:12:34 <ClaudiusMaximus> theorbtwo: true, but the chances of picking from a large cluster is rather higher than from smaller clusters - i kinda want each cluster to be weighted equally (so, perhaps i should have said "non-representative" !)
23:13:23 <ClaudiusMaximus> kmc: thanks for the algorithm name, now i can search hackage
23:13:46 <theorbtwo> ClaudiusMaximus: Aha, and now you have answered your own question.  First you cluster, then you pick 20 random clusters, and finally, one image from each chosen cluster.
23:13:55 <Veinor> non-optimal: store your images in a list. repeatedly pick the first image to add to your representative, then iterate over the rest of the list to remove all images that are 'too close' to that image
23:14:06 <cmccann> kmc, I've always liked how "birthday attack" is a standard term in cryptography because of exactly that :]
23:14:29 <kmc> k-means is easy and it's already implemented several times on hackage
23:14:38 <kmc> you can come up with all kinds of crazy similarity metrics
23:14:39 <Veinor> you'll get a representative set such that no two representatives are within distance d of each other, and every element is within distance d of a representative
23:14:51 <kmc> but probably the L2 norm of the difference between color histograms is pretty good
23:15:19 <kmc> unless you have images which are very similar in color distribution but different in shape, of course
23:16:24 <ClaudiusMaximus> i think colour should be enough to get started, it was more the clustering thing i wasn't sure of - thanks all
23:17:30 <koeien> yes, it depends on the coloring
23:17:40 <kmc> to find k clusters in your samples: pick k points at random.  associate each sample to the nearest point, then move each point to the mean of its associated samples.  repeat to fixedpoint
23:17:43 <kmc> that's k-means
23:17:55 <koeien> if 'silimar' images hvae different colors, then this metric is the wrong one
23:21:27 <JoeyA> Does a foreign import ccall need to be safe if the underlying function blocks, but does not explicitly call into Haskell?
23:22:21 <hpaste> samg_ pasted “Segmentation fault when compiling DSH example program” at http://hpaste.org/51263
23:22:48 <samg_> ^^ What can I do to determine the cause of this segmentation fault? I have installed and cleaned and reinstalled GHC a few times now
23:23:54 <koeien> JoeyA: googling reveals a mailing list thread about it
23:24:17 <kmc> JoeyA, yes
23:24:18 <kmc> http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
23:24:35 <kmc> JoeyA, why do you want to make an unsafe call, anyway
23:24:36 <koeien> JoeyA: if it's unsafe, your haskell RTS will stop
23:25:12 <koeien> ah yes, it's explained in kmc's link
23:25:23 <JoeyA> Thanks
23:25:38 <koeien> for some things you don't care, like sin(), since they're pretty fast, but if you're blocking you want them to be safe
23:26:34 <kmc> you really shouldn't use "unsafe" unless you have a good reason e.g. profiling results
23:27:17 <JoeyA> What about really simple functions that don't block?
23:28:01 <kmc> do you have profiling results indicating that this is a bottleneck?
23:28:08 <koeien> then unsafe is faster
23:28:50 <JoeyA> I'd rather not create bottlenecks in the first place, if I can help it.
23:29:05 <kmc> i'd rather not use buggy libraries if i can help it
23:29:20 <kmc> doing tricky shit for no reason is a great way to introduce weird bugs
23:30:01 <JoeyA> point taken
23:30:03 <cmccann> shoot first, ask questions later
23:30:04 <kmc> here's another question: how many millions of times per second is this C function going to be called?
23:30:22 <cmccann> why spend 20 minutes with a profiler now when you could spend 2 hours with a debugger tomorrow?
23:31:11 <kmc> heh, 2 hours seems quite optimistic for subtle concurrency bugs involving a C library and the GHC RTS
23:31:46 <kmc> anyway, Haskell isn't C, we don't need to chase imaginary microoptimizations just to prove to our peers how hardcore we are
23:31:49 <cmccann> good point
23:31:50 <kmc> that's what type hackery is for ;)
23:32:31 <kmc> i thought i saw recently some actual numbers on the overhead of a safe vs unsafe ffi call
23:32:39 * cmccann implements constraint-solving algorithms using a type-level call/CC
23:32:48 <JoeyA> You do that in Haskell with:
23:32:56 <JoeyA> @pl \a b c d e -> e c d b a
23:32:56 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip . flip id))
23:33:10 <JoeyA> (proving how hardcore one is)
23:33:26 <koeien> there's a reason it's called "pointless"
23:35:15 <kmc> there's at least two reasons :)
23:35:28 <copumpkin> no u
23:35:36 <kmc> :O
23:35:40 <kmc> copumpkin, did you have said ffi numbers?
23:35:46 <copumpkin> ?
23:35:52 <kmc> on overhead of a safe vs unsafe call
23:36:00 <copumpkin> oh, nope?
23:36:03 <kmc> oh :/
23:36:17 <kmc> i vaguely recall seeing them and i thought it might have been related to your gmp / mpfr work
23:36:19 <copumpkin> I do remember seeing them recently too
23:36:25 <copumpkin> hmm nope wasn't me
23:36:40 <copumpkin> I guess it'd be fairly easy to test
23:36:51 <copumpkin> make a nop C function and foreign bind to it both ways, then call criterion on it
23:37:06 <kmc> yeah
23:37:12 <kmc> ♥ criterion
23:41:58 <hpaste> kmc pasted “safe vs unsafe ffi” at http://hpaste.org/51264
23:42:19 <kmc> i love how easy that was
23:43:30 <copumpkin> 5 minutes!
23:43:33 <copumpkin> unacceptable!
23:43:39 <copumpkin> I demand inline C in my haskell files
23:43:46 <koeien> that's slower than i expected
23:44:56 <kmc> i had to remember whether it's "ccall unsafe" or "unsafe ccall" ;P
23:45:15 <copumpkin>   2135 (2.7%) high severe
23:45:17 <copumpkin> tsk tsk
23:45:28 <kmc> ok on another machine it's 8.8 vs 93 ns
23:45:30 <frerich> What does the "ci" mean in the benchmarking output?
23:45:32 <koeien> no, I mean the safe overhead
23:45:38 <koeien> confidence interval, I'd wager
23:46:12 <ddarius> Yes, "order of magnitude" was what people were saying earlier.
23:46:44 * cmccann implements inline ASM as TH splices so that copumpkin can optimize programs more effectively 
23:46:51 <copumpkin> ooh
23:46:52 <ddarius> cmccann: See Harpy.
23:46:54 <copumpkin> and inline C?
23:46:56 <kmc> i've considered that more than once
23:47:02 <kmc> i already did inline machine code for a blog post ;P
23:47:07 <copumpkin> lol
23:47:13 <kmc> i wish criterion would plot two kernel density estimates on the same axes
23:47:36 <cmccann> no, C is too heavyweight and bloated. you want ASM, or... well I was about to suggest machine code but I guess kmc beat me to it :P
23:50:36 <cmccann> ddarius, hunh, neat.
23:51:14 * cmccann needs to stop trying to make jokes about implausible-sounding but not obviously unworkable things, they turn out to already exist far too often
23:52:03 <kmc> anyway 100 ns overhead is not a big deal for most applications
23:53:15 <ddarius> Yes, people see 13 v. 140 and freak without realizing that 13 nanoseconds is like 30 instructions or a few instructions and a memory stall.
23:53:54 <cmccann> I assume that the 13 v 140 there is the pure overhead, and would be roughly constant no matter how long the called function takes
23:53:56 <kmc> the canonical use case for "unsafe" is calling sin() from math.h
23:54:07 <kmc> for that i get 60 vs 200 ns
23:54:14 <kmc> so already the difference is decreasing
23:54:51 <cmccann> since if you're calling something that takes a milisecond anyway this sort of overhead is not that significant
23:56:16 <koeien> kmc: yes, if you're doing work it should matter less
23:56:31 <kmc> yeah, even for sin() it's only a factor of 3
23:57:17 <kmc> also it seems Prelude.sin :: Double -> Double is exactly as fast as the unsafe C import
23:57:29 <kmc> i was wondering if it might compile out to an inline primop and end up faster
23:57:34 <kmc> but that would probably not handle error conditions properly
23:57:41 <ddarius> cmccann: What are you talking about?  You could improve your performance by 0.00001%!
23:57:48 <kmc> does ghc have something like -ffast-math?
23:58:45 <ivanm> kmc: isn't that built into the language? :p
23:58:53 <kmc> is what?
23:59:42 <Axman6> use harpy and call the asm instruction directly
