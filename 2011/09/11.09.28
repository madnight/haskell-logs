00:00:53 <btutt> seen http://hackage.haskell.org/trac/ghc/wiki/Debugging ?
00:05:47 <Blkt> good morning everyone
00:22:34 <blackdog> btutt: thanks, -debug seems to give me a bit more
00:22:49 <blackdog> but running it under forkIO does seem to screw everything up :/
00:25:26 <Eduard_Munteanu> Blkt: morning
00:28:18 <blackdog> btutt: thanks, -debug seems to give me a bit more
00:28:40 <btutt> cool
00:29:03 <blackdog> interestingly, if i fork the _other_ thread, and run this one on the main thread, everything seems ok
00:30:00 <shachaf> blackdog: Does this have to do with bound threads, maybe?
00:30:13 <rostayob> oh man, i hate wikipedia, it turns out i can't smoke and i can't "drink with a straw"
00:30:28 <Axman6> wut?
00:30:33 <shachaf> Axman6: Wisdom teeth.
00:30:37 <Axman6> ah
00:31:08 <blackdog> shachaf: yeah, possibly
00:31:27 <shachaf> blackdog: Does it work if you use forkOS instead of forkIO (assuming you're using forkIO)?
00:31:38 <blackdog> i've been spoiled by haskell - i assume that anything that typechecks is fine:)
00:31:44 <rostayob> does anybody know if it's possible to have emacs remove trailing whitespace automatically?
00:31:51 <blackdog> no, i tried that - forkOS just crashed and said "use the threaded runtime"
00:31:51 <shachaf> blackdog: IO is IO.
00:31:52 <rostayob> #emacs is useless right now
00:31:58 <blackdog> which i could do, i suppose
00:32:03 <shachaf> blackdog: How about forkOS with the threaded runtime? :-)
00:32:17 <blackdog> :) if this works, i'm backing away and never touching it again
00:32:18 <shachaf> Though if you're not using it, does it matter?
00:34:05 <quicksilver> rostayob: http://www.emacswiki.org/emacs/DeletingWhitespace#toc3
00:36:20 <rostayob> quicksilver: great, thanks
01:22:06 <donri> what is the difference between "import .. as" with and without "qualified"?
01:25:23 <shachaf> @wiki Import
01:25:23 <lambdabot> http://www.haskell.org/haskellwiki/Import
01:26:59 <donri> thanks
01:37:40 <mreh> when was -hT added to GHC RTS arguments?
01:37:46 <mreh> 6.10 doesn't have it
01:37:57 <mreh> 6.12 pardon
01:39:28 <mreh> ah, 7
01:55:07 <buntfalke> Hi
01:56:22 <buntfalke> I know non-linear patterns break referential transparency, and I know they make the top-to-bottom semantic of pattern evaluation more important than might be healthy for a clean language -- my question is utterly technical: Would the Robinson algorithm for unification be able to unify non-linear patterns?
01:56:59 <buntfalke> I see no /technical/ issue arising when one would simply comment out the linearity check. Do I overlook something?!
01:58:43 <ddarius> Prolog patterns are non-linear.
01:59:08 <opqdonut> non-linear patterns are ones with repeating variables?
02:00:18 <buntfalke> opqdonut: Yes.
02:00:41 <buntfalke> ddarius: And they do use the same algorithms, as in, they work on non-linear patterns, too?
02:05:10 <ddarius> As far as I know, the Robinson algorithm is the theoretical analog of the algorithm typically used by Prolog implementations.
02:13:24 <buntfalke> Yes.
02:13:26 * buntfalke agrees
02:13:45 <buntfalke> Exam @ t-2h
02:13:47 * buntfalke goes nuts
02:13:53 <buntfalke> thanks ddarius
02:15:36 <ddarius> Also, there does not seem to be any linearity check in the algorithm.  I think you may be confusing it with the occurs check.
02:16:13 <ddarius> Finally, there's nothing about non-linear patterns that a priori violates referential transparency.
02:17:53 * hackagebot peggy 0.2.1 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.2.1 (HideyukiTanaka)
02:24:09 <buntfalke> ddarius: No, Haskell checks for the linearity -- Ronbinson itself doesnt, I know.
02:24:33 <buntfalke> And it does break referencial transparency. Example:
02:26:20 <buntfalke> "f x x = True; f x y = false", f (g x) (g x) ---> True, even for "g x = 1 + g x"
02:26:56 <buntfalke> So if "h x = 2 + h x" and you call f (g x) (h x) ---> False, even though g and h are bottom.
02:27:20 <buntfalke> Referencial Transparency states, expressions can be replaced by expressions of the same value without a change in the semantics of the programm.
02:27:39 <ddarius> Yes, you don't match the syntax, you match the values.
02:28:03 <ddarius> f x x = True would just expand into f x y | x == y = True
02:28:04 <buntfalke> So it doesnt work here, /unless/ you do not match on "The Terms are equal" but on "the Values are equal" in which case it would be no more powerfull than Guards, and hence is of no added use
02:28:21 <ddarius> Yes, Haskell has never matched terms.
02:28:38 <ddarius> And even linear matching terms would violate referential transparency.
02:28:53 <buntfalke> So, if you match terms, things break, if you dont, you add no extra expressional power.
02:30:13 <buntfalke> And there's been said on haskell cafe that it was decided against it for the sake of making sure function definitions stay as disjoint as possible, even though there is the top-to-bottom-rule, for the sake of clean code and simplicity
02:30:23 <ddarius> Yes, in Haskell the benefit of pattern matching is just convenience.
02:30:48 <buntfalke> :-)
02:33:54 <engla> the benefit of pattern matching is deconstruction, the only way to take constructors and their applied values apart
02:38:48 * Eduard_Munteanu wonders about Agda's dot patterns.
02:39:09 <buntfalke> @source return :: []
02:39:09 <lambdabot> return :: [] not available
02:39:12 <buntfalke> @source return :: List
02:39:13 <lambdabot> return :: List not available
02:39:18 <buntfalke> @source return :: [Int]
02:39:19 <lambdabot> return :: [Int] not available
02:39:41 <buntfalke> :t return :: []
02:39:42 <lambdabot>     Expecting an ordinary type, but found a type of kind * -> *
02:39:43 <lambdabot>     In an expression type signature: []
02:39:43 <lambdabot>     In the expression: return :: []
02:39:49 <buntfalke> :t return :: [Int]
02:39:50 <lambdabot>     Couldn't match expected type `[Int]'
02:39:50 <lambdabot>            against inferred type `a -> m a'
02:39:50 <lambdabot>     In the expression: return :: [Int]
02:40:20 <buntfalke> :t return :: Int -> [Int]
02:40:21 <lambdabot> Int -> [Int]
02:40:24 <buntfalke> @return :: Int -> [Int]
02:40:25 <lambdabot> Unknown command, try @list
02:40:29 <buntfalke> @source return :: Int -> [Int]
02:40:30 <lambdabot> return :: Int -> [Int] not available
02:40:32 <Younder> what are you trying to to ?
02:40:34 <buntfalke> Grml.
02:40:50 <buntfalke> I try to answer: Is the "return" of lists a simple concatenation?
02:41:08 <buntfalke> I mean, is return = concat for Lists
02:41:22 <Younder> You can't return a list lie that
02:41:33 <Younder> like
02:42:14 <Younder> try data.list
02:42:23 <buntfalke> In "[1,2,3] >>= return . succ" what's the source for return?
02:42:24 <Eduard_Munteanu> buntfalke: no, join is concat for lists
02:42:57 <Eduard_Munteanu> :t join
02:42:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
02:43:29 <buntfalke> Ah, true. concat "removes on level of Monadic structure" from a list of lists.
02:43:35 <buntfalke> Hence it's join.
02:44:25 <Younder> look you need to Know the space on the stack for the return value so either it is pointer into the heap of it is fixed
02:45:54 <buntfalke> How about that return example though. It's the (:) here. It's just the adding the neccessary cons between the 2, 3 and 4 falling out of succ, right?
02:46:41 <engla> buntfalke: return has type a -> [a]
02:46:54 <buntfalke> engla: Thanks
02:46:55 <Eduard_Munteanu> > return 2 :: [Int]
02:46:56 <lambdabot>   [2]
02:47:13 <engla> buntfalke: and   xs >>= return  must preserve xs
02:47:27 <Eduard_Munteanu> It's just return = []
02:47:49 <buntfalke> Eduard_Munteanu: that would be the empty list, and can't be.
02:47:57 <buntfalke> It has to be return = (:)
02:47:59 <Eduard_Munteanu> return x = [] x
02:48:03 <Eduard_Munteanu> or [x]
02:48:03 <engla> only return x = [x]  can work
02:48:09 <buntfalke> oO
02:48:25 <Eduard_Munteanu> Whoops.
02:48:27 <Eduard_Munteanu> Yeah.
02:48:31 <buntfalke> Oooohhh...*facepalm* never mind.
02:48:36 <buntfalke> Yesyes...
02:48:43 <buntfalke> thanks!
02:49:00 * Eduard_Munteanu forgot that works only in types
02:50:14 <engla> @pl return x = [x]
02:50:15 <lambdabot> return = return
02:50:16 <buntfalke> It's just because there's a concat in >>= that it returns a [Int] instead of an [[Int]]...
02:50:40 <engla> @pl return x = (x:[])
02:50:41 <lambdabot> return = return
02:51:05 <engla> lambdabot, you crazy
02:51:16 <Eduard_Munteanu> Heh.
02:51:56 <Eduard_Munteanu> > (:[]) 2
02:51:57 <buntfalke> Why is (>>=) :: m a -> (a -> m b) -> m b and not just "m a -> (a -> b) -> m b"?
02:51:57 <lambdabot>   [2]
02:52:06 <Eduard_Munteanu> The robot monkey operator!
02:52:22 <buntfalke> It looks like the 2nd argument to >>= has to create lots of monads just for >>= to deconstruct and merge them all the time.
02:52:44 <mysticc> what us the best way to create from a list of [(key,value)] where the key is not unique ... and convert it to [(key,[values])] , here the key is unique with a list of alll the values from the first list ... is there any built in function to do it ??
02:52:50 <Eduard_Munteanu> buntfalke: consider any monadic function.
02:52:55 <Eduard_Munteanu> Say those in IO.
02:53:07 <Eduard_Munteanu> They're of the form a -> m b
02:53:48 <engla> buntfalke: do you want to read this? http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
02:54:41 <mreh> :t evaluate
02:54:42 <lambdabot> Not in scope: `evaluate'
02:56:10 <Botje> mysticc: Map.toList . Map.fromListWith (++) . map (second return)
02:56:10 <Younder> Lazy eval is the forte of Haskell. It has just drowned in a bunch of monads (:
02:56:47 <Younder> Monads induce that order. Me thinks they are somewhat overused
02:57:31 <Eduard_Munteanu> Younder: many monads have both strict and lazy variants
02:58:16 <mysticc> Botje: whats (second return) ??
02:59:57 <buntfalke> Eduard_Munteanu: True...lists just aren't the best example to consider :-D
03:00:01 <Younder> Eduard_Munteanu, like?
03:00:19 <Eduard_Munteanu> Younder: State
03:00:20 <buntfalke> engla: Know that one
03:01:24 <quicksilver> mysticc: second return is \(a,b) -> (a, return b)
03:01:37 <quicksilver> mysticc: and, in this case, he's using return = \x -> [x]
03:01:45 <quicksilver> so, it was \(a,b)->(a,[b])
03:01:49 <Younder> identity
03:01:50 <Eduard_Munteanu> buntfalke: m a -> (a -> b) -> m b is just another variant of fmap
03:01:57 <Eduard_Munteanu> :t Prelude.fmap
03:01:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:02:16 <quicksilver> as a matter of personal taste, I think \(a,b)->(a,[b]) is more readable than second return.
03:02:23 <Eduard_Munteanu> :t flip (Prelude.fmap)
03:02:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
03:03:17 <Eduard_Munteanu> :t flip liftM
03:03:18 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
03:04:28 <Younder> Haskell still doesn't verify that a monad is in fact monadic. The three golden rules..
03:04:30 <Eduard_Munteanu> Younder: http://hackage.haskell.org/package/mtl-1.1.0.2
03:04:40 <Eduard_Munteanu> Younder: it can't.
03:04:55 <Younder> http://www.haskell.org/haskellwiki/Monad_Laws
03:05:00 <Eduard_Munteanu> Just like with any structure that's supposed to be bound to obey some laws.
03:06:23 <engla> buntfalke: ok, just asking. it introduces a -> m b  functions first and then monads, so there the bind operation's raison d'etre is to bind such functions, hence the signature
03:06:27 <Eduard_Munteanu> Unless it can be put in a form which prevents breaking those laws. But generally, Haskell's type system isn't rich enough for that.
03:08:51 <buntfalke> engla: Yes, there's a book on Haskell borrowing it's introduction to Monads from this blog post; I read the former. I just though too much of Lists as Monads, where this type of bind makes alot less sense than, for instance, in the data Debug a = D(a, String) example emplyed to introduce a -> m b type functions
03:09:04 <Younder> Eduard_Munteanu, but if you buildt a type system on top of topology it would be... Just a thought
03:09:46 <Younder> Eduard_Munteanu, only one program, to my knowlege has, Axiom
03:10:28 <Younder> http://en.wikipedia.org/wiki/Axiom_(computer_algebra_system)
03:12:35 <Eduard_Munteanu> Younder: you might want to look into dependently-typed languages and theorem provers. I'm not sure about what Axiom can do.
03:13:14 <Younder> Building a type system onto a categorical description of topology is what I will attempt to do. Wish me luck... It won't be easy
03:13:19 <Eduard_Munteanu> Wikipedia says "Axiom plans to use proof technology to prove the correctness of the algorithms (such as Coq and ACL2)."
03:14:12 <Eduard_Munteanu> Don't you mean homotopy type theory or stuff like that? :/
03:14:33 <Younder> no, I don't
03:14:50 <engla> buntfalke: the list class can't change the signature of >>= for itself
03:14:53 <Younder> That is too limiting
03:15:49 <Younder> http://www.cs.man.ac.uk/~david/categories/
03:17:29 <Eduard_Munteanu> Younder: that seems to concern itself with encoding CT structures in ML
03:18:30 <Younder> There IS.. I am trying to devise a new language I call Formula. Never the less it is a start.
03:22:45 <Younder> ML is a fine language too. Haskell is a tad better. But the encoding of the type system in GHC leaves a lot to be desired. Only two truly understand it and only Simon P. Jones is still working on it. A better apocah is found in Mark Tarver's QI. A language that never got the respect it deserved
03:23:02 <Younder> approach
03:23:17 <buntfalke> engla: Yes, of course not, but if you look at lists and lists only, you will feel as if the signature of >>= causes alot of unneccessary con- and deconstruction of lists, which could be avoided if only the signature was different -- of course that wouldnt make sense, as it would break all other monads
03:26:14 <buntfalke> I don't see the point in reinventing the wheel just because GHC encodes the type system not perfectly and there is a lack of ppl who understand it.
03:26:50 <buntfalke> You new language will not just end up with only one person truely understanding it's implementation -- yourself -- it will also ending up with a not very much larger user base.
03:26:51 <engla> that's how the list monad works and it's there to model one-element-to-many situations
03:26:52 <Younder> We have had 20 years of Haskell. It is time to take the plunge into designing a new, better, language. That is what I will try to do.
03:27:17 <Eduard_Munteanu> Younder: have you tried languages like Coq or Agda?
03:27:43 <buntfalke> It would be worth more to make Haskell more appealing to the masses, so the world is no longer limited by, say, C-dialects including C++, C#, Java, ... in every imaginable place
03:27:47 <Younder> Eduard_Munteanu, No, but I use ACL2 and Isabelle
03:28:23 <Eduard_Munteanu> I'm not sure about ACL2, but Isabelle is a different thing.
03:29:05 <Eduard_Munteanu> If you want something that feels similar to Haskell, but can do a lot more wrt proving stuff, I suggest you look into Agda.
03:29:42 <Eduard_Munteanu> *different than type-theory-based provers
03:29:50 <buntfalke> Younder: Let me know when it is ready for real world applications, as in, when the compiler optimizes well enough, and there are enough bindings to outside libraries, databases, operting systems and special drivers like GL and networking
03:30:30 <buntfalke> Don't get me wrong, it's a noble goal. I merely see little chances for success.
03:30:46 <Younder> buntfalke, don't hold your breath.. these are early days.
03:31:42 <Younder> buntfalke, I am fully aware of my chances and I go for it anyway. :)
03:32:25 <Eduard_Munteanu> Younder: for example, Agda will check that monads obey monad laws, depending on how you define them.
03:32:38 <Eduard_Munteanu> In fact, you'll have to prove that.
03:34:15 <Younder> designing compilers is an art, an art I am very good at, which is why I try. I am 44 and have a lot of experience. Weather that pay's off... well well see won't we
03:35:35 * engla pictures an old man about to leave to climb up the mountain
03:38:20 <mreh> quicksilver: for every openGL keypress snapshotWithR sees about 30 Reactive stepper events occuring, so it seems that sampleR can't keep up and the heap just grows and grows
03:38:28 <mreh> is that like the problem you were having?
03:38:44 <mreh> needless to say, openGL shouldn't be producing that many events
03:40:46 <mreh> needless to say, i'm only telling openGL to send one event per all these `stepper` events
03:43:15 <buntfalke> What's the difference between a closure and a thunk (when talking about Haskell)?
03:43:53 <mreh> i'm not qualified to answer that questin
03:44:56 <Jafet> A thunk is an implementation detail; a closure is a syntactic detail
03:46:24 <Jafet> const x = f where f _ = x -- x is brought into the closure of f
03:47:08 <Jafet> Closures have their own implementation details
03:58:54 <buntfalke> @source seq
03:58:54 <lambdabot> seq not available
03:59:11 <buntfalke> Ah, seq is primitive. I see.
04:19:25 <mm_freak> does anyone know a good beginner tutorial, which assumes no prior programming knowledge at all?
04:19:36 <hpc> @where lyah
04:19:36 <lambdabot> http://www.learnyouahaskell.com/
04:19:49 <hpc> (it pretends to assume prior knowledge, but it really doesn't)
04:20:14 <mauke> the scoundrel!
04:20:34 <hpc> preflex: seen BONUS
04:20:35 <preflex>  BONUS was last seen on #haskell 150 days, 16 hours, 55 minutes and 23 seconds ago, saying: yeah i think that's better as well
04:21:39 <mysticc> How to define a show instance for a monad ?? suppose for a State s a .. I want to print s ... for its show instance ??
04:22:19 <Saizan> you can't
04:22:52 <Saizan> State s a doesn't contain any 's', it's rather the type of functions that transform an 's' into another, while also producing an 'a'
04:25:23 <mm_freak> hpc: thanks
04:30:06 <Eduard_Munteanu> mysticc: you want to pass the state to show yourself somehow.
04:30:09 <Eduard_Munteanu> :t get
04:30:10 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
04:30:16 <Eduard_Munteanu> :t execState
04:30:17 <lambdabot> forall s a. State s a -> s -> s
04:30:28 <Eduard_Munteanu> :t runState
04:30:29 <lambdabot> forall s a. State s a -> s -> (a, s)
05:33:06 * hackagebot SableCC2Hs 0.0.0.2 - Generate a parser (in Haskell) with the SableCC parser generator.  http://hackage.haskell.org/package/SableCC2Hs-0.0.0.2 (MarcFontaine)
05:37:37 <engla> continuing on the api duplication thread. Why is there MonadPlus when it's equivalent to Monoid?
05:38:25 <EvanR-work> so you can use both
05:38:41 <EvanR-work> (and because MonadPlus came later)
05:38:51 <engla> it looks redundant
05:39:13 <EvanR-work> one of the important things about haskell i think is the expressivity
05:39:31 <EvanR-work> if everything was reduced to lambda calculus and single letter variables, it might mean the same thing, but it wont be obvious to someone
05:40:02 <EvanR-work> Monoid instances are obviously monoids, and MonadPlus instances are intended to complement the Monad instance
05:40:10 <engla> if you're implementing something and you have to define both the Monoid and MonadZero instances to care for all users, then you have more work to do and that is less expressive
05:40:22 <engla> *MonadPlus  I mean
05:40:34 <EvanR-work> you wouldnt define both to mean the same thing
05:41:01 <engla> why not?
05:41:18 <edwardk> i often do
05:41:19 <EvanR-work> you do realize all this is subjective
05:41:25 <EvanR-work> you do what you want
05:41:38 <EvanR-work> MonadPlus seems to be used mainly for parsers
05:41:51 <EvanR-work> doesnt mean it has to be
05:41:58 <EvanR-work> but i prefer monoid
05:41:58 <edwardk> engla: MonadPlus indicates that for _all_ choices of a. m a has a monoid like structure, and that that structure has certain right seminearring-like properties with regards to >>=
05:42:25 <edwardk> engla: Monoid just says that some particular value of kind * has a monoid like structure.
05:42:31 <edwardk> Neither subsumes the other.
05:42:34 <EvanR-work> didnt know that
05:42:58 <EvanR-work> semin earring?
05:43:21 <edwardk> MonadPlus has a lot of other uses. I use it in probability modeling, You can use it on lists, as a way to catch errors, etc.
05:43:47 <edwardk> A right seminnearring is a weak semiring which only offers a single distributive law
05:44:21 <engla> I can't see how Monoid is not enough
05:44:44 <edwardk> engla. Nothing prevents me from saying
05:44:58 <edwardk> instance Monoid (Foo Int) where Foo a `mappend` Foo b = Foo a
05:45:09 <edwardk> instance Monoid (Foo Double) where Foo a `mappend` Foo b = Foo b
05:45:13 <benmachine> engla: notice that the MonadPlus instance for Maybe is different from the Monoid instance
05:45:23 <edwardk> the two instances HAVE NOTHING TO DO WITH ONE ANOTHER
05:45:34 <edwardk> but with MonadPlus they must agree
05:45:58 <edwardk> not only that you know that the instance works for all choices of a. which is important in a number of higher-rank situations
05:46:02 <engla> but maybe differentiating those instances is just wrong
05:46:17 <edwardk> engla: those two examples are trivial
05:46:28 <edwardk> but instance Semigroup m => Monoid (Maybe m)
05:46:38 <edwardk> can use the semigroup structure
05:47:06 <edwardk> whereas we can know that MonadPlus Maybe doesn't do anything at all differently as the 'a's vary
05:47:16 <edwardk> and those are very different things
05:48:23 <edwardk> If I'm working in the context where I have a pair of (forall a. Maybe a)'s I can put them together with either, but only in the MonadPlus case can I put the forall back on
05:48:42 <edwardk> whereas with the Monoid case I need to pick an instance
05:48:51 <edwardk> so a has become concrete
05:49:45 <engla> ok sure, I was convinced Monoid for Maybe did what MonadPlus did
05:49:59 <edwardk> it doesn't =)
05:50:23 <edwardk> (in that case because semigroup wasn't standardized it borrows the monoid for 'a' and just avoids using its unit
05:50:58 <edwardk> in general there are a lot of cases where you need 'higher kinded' versions of classes.
05:51:29 <edwardk> because without them you just simply can't write certain code using higher rank types
05:52:50 <engla> thanks for your explanation
05:52:52 <edwardk> if you defined class Return m a where return :: a -> m a     class (Return m a, Return m b) => Bind m a b where (>>=) :: m a -> (a -> m b) -> m b -- there are a _lot_ of the combinators in Control.Monad that couldn't be written using Bind
05:53:06 <engla> all concrete monads I imagine could have used either.. I think
05:53:19 <edwardk> in simple cases.
05:53:34 <edwardk> i encourage you to try the Return and Bind example I just mentioned.
05:53:42 <edwardk> You'll find it becomes really really painful
05:53:53 <edwardk> (you may want to change the method names obviously)
05:54:23 <edwardk> we have a package of restricted monads, but they offer very few combinators because many just can't be written
05:54:31 <edwardk> gotta eun
05:54:33 <edwardk> er run
05:54:38 <engla> heh ok
05:54:46 <engla> I'm puzzled
05:54:49 <engla> but I'll try
05:55:17 <justin-kp> what do people do in haskell for tracing code?
05:55:48 <Ptival> justin-kp: http://www.haskell.org/haskellwiki/Debugging ?
05:55:52 <Cale> justin-kp: There's Debug.Trace.trace
05:56:14 <justin-kp> is there anything you need to know about Debug.Trace.trace?
05:56:31 <justin-kp> it doesn't seem to be getting called when i expect
05:56:47 <justin-kp> like will optimizations optimize it away?
05:56:56 <Cale> Well, that's because the compiler is choosing to evaluate things at a different time than you'd expect.
05:57:15 <Ptival> "You must keep in mind that due to lazy evaluation your traces will only print if the value they wrap is ever demanded."
05:57:16 <Cale> It has quite a lot of freedom to move things around.
05:57:18 <cwl> find a bug here http://www.haskell.org/haskellwiki/HXT/Practical/Weather1
05:57:42 <cwl> weatherDataURL = "http://www.weather.gov/data/current_obs/KAGC.xml" should be
05:57:50 <cwl> weatherDataURL = "http://www.weather.gov/xml/current_obs/KAGC.xml" :-)
05:57:51 <Cale> It could also be that you're never using the value that you're tracing at all, in which case it's possibly a bug.
05:57:58 <dmwit> cwl: It's a wiki. Fix it!
05:58:08 <quackquack> What language is GHC written in?
05:58:10 <justin-kp> that must be what is happening
05:58:11 <cwl> dmwit: I don't have permission
05:58:15 <Cale> quackquack: GHC Haskell
05:58:20 <justin-kp> though i don't understand why...
05:58:36 <Cale> justin-kp: How large is your program, can we have a look at it?
05:58:45 <cwl> dmwit: how to edit that page?
05:58:47 <quackquack> Cale: GHC is written in Haskell? jeez, i shoulda guessed, recursion recursion recursion
05:59:02 <Cale> quackquack: Most compilers are written in the language they compile.
05:59:02 <ion> What would be a better alternative?
05:59:04 <dmwit> cwl: http://haskell.org/haskellwiki/index.php?title=Special:Userlogin&type=signup
05:59:22 <dmwit> cwl: (via "Log in / create account" link at the top of every page)
05:59:37 <quackquack> Cale: i think i just dont understand how that works.. how did they compile it the first time?
05:59:39 <justin-kp> Cale: it is somewhat large, i think it is better if I debug myself
05:59:42 <cwl> dmwit: thanks
05:59:43 <Cale> quackquack: This is desirable because it means that improvements to the code that the compiler generates also mean that the compiler itself gets better :)
06:00:08 <Cale> quackquack: By using another implementation of Haskell which wasn't written in Haskell.
06:00:24 <dmwit> quackquack: It's the usual bootstrapping problem.
06:00:27 <quackquack> Aha, ok. that is pretty cool :)
06:00:36 <dmwit> If you follow the trail long enough, you get to somebody putting bits into memory by hand.
06:01:22 <frerich> dmwit: Which makes you wonder where that guy was coming from.
06:01:39 <justin-kp> Ptival: wiki page looks like a good resource, thanks
06:02:52 <rostayob> quackquack: you need to write a compiler in something else the very first time, but once you're bootstrapped you can keep going
06:03:13 <dmwit> The first compiler ever written was written in English.
06:03:30 <Cale> justin-kp: Anyway, the usual thing to do with Debug.Trace is to figure out what your various functions are being called with so that you can test them by hand in GHCi and ensure they produce the results you expect.
06:03:30 <dmwit> (Or perhaps some other natural language. Not trying to be a snob or anything.)
06:03:41 <erus`> dmwit: is it on github
06:03:51 <dmwit> heh
06:04:06 <rostayob> quicksilver: there is a lovely paper about the story of haskell that talks about that, it's called "Haskell: Being Lazy with Class"
06:04:15 <rostayob> well not just about that, but yeah
06:04:52 <Cale> rostayob: I'm pretty sure you mean quackquack and not quicksilver :)
06:05:17 <rostayob> yes, quackquack
06:05:36 <rostayob> or maybe quacksalver!
06:05:39 <quacksalver> I have come to the rescue to ensure maximum confusion!
06:05:40 <rostayob> what the hell
06:05:53 <quackquack> rostayob: ill look for that now :)
06:06:00 <rostayob> quacksalver: you even show up with the same color as quackquack
06:06:07 <quacksalver> eeeeexcellent
06:06:24 <quackquack> hurray, max confusion
06:08:06 * hackagebot BiobaseFR3D 0.1.1.0 - Importer for FR3D resources  http://hackage.haskell.org/package/BiobaseFR3D-0.1.1.0 (ChristianHoener)
06:08:34 <mreh> oh god
06:09:02 <mreh> ahem, what's a good reference book for lazy language implementation?
06:09:17 <mreh> or even just to learn how to optimise GHC compiled programs
06:09:30 <mreh> time and space leaks et al.
06:09:41 <mreh> core too
06:11:10 <dmwit> Those sound like three very different subjects, dude.
06:11:25 <dmwit> Lazy language implementation: the Spineless Tagless G-machine paper.
06:11:27 <absence> i seem to recall having read something about do syntax vs applicative style regarding short-circuiting, but i can't find it. anyone know what i could be thinking of?
06:11:52 <dmwit> How to optimize GHC-compiled programs: read the GHC manual section on optimizing.
06:12:32 <dmwit> Tracking down time and space leaks: read bos', dons', and ezyang's blog posts about how they did it for their programs and adapt their approach to your project.
06:12:51 <mreh> ezyang has been quite helpful in demystifying the whole process
06:12:58 <dmwit> How to read core: don't know the answer to this one, but I think there's a Stack Overflow question with an answer by dons with lots of references.
06:12:59 <mreh> pictures!!!
06:13:06 * hackagebot hieraclus 0.1.2 - Automated clustering of arbitrary elements in Haskell.  http://hackage.haskell.org/package/hieraclus-0.1.2 (PhilippPribbernow)
06:14:28 <mreh> @where bos
06:14:28 <lambdabot> I know nothing about bos.
06:14:51 <ion> I like adding “in Haskell” to the title of a Hackage package.
06:14:57 <dmwit> ?google bryan osullivan
06:14:58 <lambdabot> http://www.serpentine.com/
06:14:58 <lambdabot> Title: Index of /
06:14:59 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/Papers/slpj-book-1987/ -- this is kinda old, but much of it is still true
06:15:02 <ion> s/adding/the adding of/
06:15:48 <benmachine> absence: I think if do syntax and applicative style are both available, then they should be equivalent, but I offer no warranty
06:15:59 <dmwit> ion: Well, I suppose it differentiates it from bindings to implementations in other languages.
06:16:06 <dmwit> But I agree that it seems mostly like fluff.
06:16:40 <dmwit> I feel the same way about the gratuitous addition of "h" to the beginning of package names.
06:17:02 <absence> benmachine: that's the hunch i have too, which is why it's extra frustrating that i can't find the article/webpage/whatever. i remember trying out what that text said, and thinking it made sense at the time, but now it doesn't :)
06:17:06 <brisingr> it's like the K from kde apps
06:18:45 <Cale> absence: Every instance of Monad is also naturally an instance of Applicative, but nothing currently requires these instances to line up. However, I would consider it a bug in any library where (<*>) is not equal to ap and pure is not equal to return.
06:19:20 <mreh> what if that applicative instance is less useful than an alternative implementation
06:19:29 <Cale> Then too bad
06:19:37 <mreh> haha
06:19:41 <Cale> There should be a newtype then
06:19:45 <Cale> to distinguish
06:19:57 <copumpkin> @ask dcoutts can we please please please have "pretty" URLs on hackage 2? maybe with package names at the top level, so hackage.haskell.org/vector takes you where you'd expect to go. Putting everything under packages may be more semantically meaningful, but just makes the URL harder to remember and introduces extra text to URLs that carries no information
06:19:57 <copumpkin> @botsmack
06:19:57 <lambdabot> Consider it noted.
06:19:58 <lambdabot> :)
06:19:58 <mux> ZipList comes to mind
06:20:02 <copumpkin> okay
06:20:05 <Cale> Or just an altogether different type
06:20:06 <mreh> that would be less wtf prone I suppose
06:20:15 <brisingr> slightly off-topic, if I make something an instance of Monad is it automatically an instance of Applicative?
06:20:25 <Cale> brisingr: No, but you can write:
06:20:30 <Cale> instance Applicative MyMonad where
06:20:30 <absence> maybe the case i remember is different then
06:20:34 <Cale>   pure = return
06:20:34 <rostayob> copumpkin: is dcoutts working on hackage 2?
06:20:40 <Cale>   (<*>) = ap
06:21:04 <Cale> Similarly, you can write:
06:21:04 <brisingr> Cale, I see, thanks
06:21:10 <Cale> instance Functor MyMonad where
06:21:12 <mreh> hackage2: hack harder
06:21:13 <Cale>   fmap = liftM
06:21:27 <brisingr> oh, that makes things easier
06:21:45 <erus`> how will the number of haskell users change in 10 years?
06:22:10 <brisingr> decrease as the existing haskell users die out
06:22:32 <mreh> what's the death rate of haskell programmers?
06:22:37 <ion> 100 %
06:22:44 <mreh> per year?!
06:22:48 <ion> No, per life.
06:22:51 <erus`> whats the halflife of a haskell user?
06:23:06 * hackagebot HROOT 0.6.4 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.4 (IanWooKim)
06:23:12 <erus`> of haskell users*
06:23:12 <brisingr> remember that about 30% of haskell users ascent to a higher plane of existence
06:23:17 <btutt> heres a more interesting question: what happens to the rate of GHC change after the Simons retire? :)
06:23:17 <brisingr> *ascend
06:23:20 <Phyx-> erus`: 3 years
06:23:20 <mreh> half lives apply to populations
06:23:27 <ion> btutt: I thought only Oleg did.
06:23:32 <Phyx-> erus`: or one master study
06:23:32 <erus`> mreh: i was just in time :D
06:23:34 <ion> Err, brisingr said that. Sorry.
06:23:52 <btutt> (when they retire...)
06:24:24 <erus`> so haskell dies out and im stuck with shitty c# and shitty python. th-thanks #haskell
06:24:42 <brisingr> make the most of it while it lasts
06:24:57 <btutt> Nah. you can use C++ lambda expressions if you want. ;) or indeed F#.
06:25:42 <erus`> might aswel become a hair dresser or something
06:26:00 <mreh> Younder is going to save us all, don't worry
06:27:33 <Younder> mreh: well see. I am not so arrogant that I think I have all te answers
06:27:47 <btutt> Don't suppose anybody knows if Hoopl's DataFlowFold was tried with GHC
06:27:49 <Younder> mreh: Thats why I provoke you here :)
06:28:45 <absence> anyone know where winghci stores its history?
06:28:58 <Younder> I may stink. But it's your kind of stink.. The math kind
06:29:22 <benmachine> absence: on linux it stores it in ~/.ghc/ghci_history, not sure about win
06:29:22 <Younder> Now I will return to philosophy
06:29:45 <joe9> is there anything in the haskell ffi that provides the capability to link against a versioned shared library.? for example, I want to like with "send" of "library.so.1" instead of the function "send" in "library.so.2"?
06:30:00 <joe9> something in the foreign import call, perhaps?
06:30:20 <absence> benmachine: i found a ghci_history file, but it only contains one line, while i can go back pretty far in ghci using arrow yp
06:30:20 <benmachine> joe9: to me that sounds like it's something you'd ask the linker to sort out
06:30:24 <absence> up
06:30:24 <benmachine> but maybe I'm wrong
06:30:33 <benmachine> absence: in a fresh ghci session?
06:30:44 <absence> benmachine: yes
06:30:49 <benmachine> oh
06:30:51 <benmachine> shrug
06:31:08 <mreh> Younder: i was only kidding
06:31:09 <cheater> why don't you strace your ghci
06:31:14 <mreh> ;)
06:31:16 <benmachine> cheater: because windows
06:31:22 <cheater> oh right
06:31:26 <cheater> well windows has filemon
06:31:28 <cheater> so use that
06:31:39 <joe9> benmachine: yes, would be the linker. let me check if the linker options of ghc allow something like that.
06:31:47 <Younder> mreh, so was i ;)
06:32:24 <mreh> am I missing something, the RTS is holding onto increasing numbers of VOID objects
06:32:40 <mreh> doesn't the garbage collector come and gobble those up on every run?
06:33:05 <absence> haha, history is stored in the registry o_O
06:33:21 <benmachine> :O
06:33:45 <ion> Awesome
06:35:08 <Janni> Hi.
06:36:19 <mreh> \o
06:38:54 <Janni> I just made the discovery that it is only possible to derive Enum for enumeration type (i.e. data types having solely nullary constructors). I would have expected that it is sufficient that all of the constructors' parameters are instances of Enum. Is there a way to weaken this condition?
06:40:21 <KernelTrap> woah
06:40:24 <KernelTrap> wli is still alive?
06:40:35 <KernelTrap> thought he died
06:40:48 <mreh> Janni: the derived enum instance just enumerates the constructors in order starting from 0
06:40:53 <mux> Janni: well you can write the instance yourself instead of usnig derive
06:41:30 <Janni> Right.
06:41:45 <mreh> how you would do that for all constructors of higher kinds would be difficult without programmer input I would imagine
06:42:32 <cheater> KernelTrap: wli is fighting and kicking
06:42:56 <mreh> wli is most cheerful person I know
06:43:03 <mreh> of course he's okay!
06:43:22 <mreh> Janni: interesting question though
06:43:27 <btutt> I suppose a manual (or TH) Enum instance might be interesting if the enumerations required specific Int values to be associated with them ??
06:43:47 <KernelTrap> mreh: WHAT, wli, the guy who always talked about how he was crippled and homeless and everyone he loved is dead in the channels I know him from?
06:43:50 <KernelTrap> cheerful?
06:43:51 <Janni> mreh: It doesn't seems like a difficult problem to me....
06:43:58 <copumpkin> KernelTrap: take it elsewhere
06:44:03 <KernelTrap> copumpkin: ok
06:44:53 <mreh> Janni: you know more than me I suspect, it's probably a haskell implementation thing
06:45:02 <Janni> Anyway... pity I'm not into data-type-generic programming
06:45:05 <btutt> i.e. your Haskell code doesn't care what the enumeration values are, but some wrapped foreign calls might. (speculates)
06:45:19 <Janni> Otherwise I'd have interest in solving this problem :-)
06:45:40 <mreh> i used derived Enums the other day to generate random values of a data type, but they all had nullary constructors
06:45:52 <awwfu> private http proxy at 62.75.246.7:3128 fast
06:46:04 <mreh> that is I implemented a Random instance using to and fromEnum
06:46:55 <mreh> that's about the only use I can see for it
06:47:24 <mreh> and then you can't know the bounds without constraints
06:48:28 <mreh> is SPJ's book going to make me better at Haskell?
06:48:57 <btutt> the one about the STG machine?
06:48:59 <Janni> mreh: It's going to make you understand how Haskell is compiled.
06:49:26 <Janni> btutt: It's about much more than just the STG machine.
06:49:42 <mreh> it predates the paper, but talks about g-code
06:50:09 <mreh> hopefully It'll help me to write efficient haskell
06:50:20 <Janni> It does too (these is one of the less interesting parts of the book, because it is very specific)
06:50:50 <malorie> hi! am I right, that these two are equivalent? http://ideone.com/ajL9z
06:50:54 <mreh> I agree with what you're saying, however I have to eat :D
06:51:03 <Janni> mreh: I would recommend it if you are curious how the Haskell code you write can actually be made to do something!
06:51:52 <mreh> Janni: what, out in the Real World(TM) or just on my desktop?
06:52:02 <Janni> (to disenchant the magic)
06:52:06 <engla> malorie: no, but the idea is correct
06:52:54 <Janni> mreh: Eh, both. One thing is to get the concepts, another thing is hacking on GHC.
06:53:12 <Janni> One is a condition for the other.
06:53:15 <malorie> engla: where've I gone wrong?
06:53:24 <mreh> Janni: well what I mean, is that in the real world there are expectations on speed and efficiency
06:53:25 <Janni> But the first has value in itself (in my opinion)
06:53:36 <Janni> Oh that!
06:53:57 <Janni> (derogative inflection)
06:54:04 <engla> malorie: a zip list is just a wrapped list right. you should say  newtype ZipList' a = ZipList' [a]  right, the "payload" is a list
06:54:23 <engla> malorie: that's number one, then impl of getZipList'
06:54:46 <dino-> @seen Lemmih
06:54:46 <preflex>  Lemmih was last seen on #haskell 19 days, 3 hours, 27 minutes and 40 seconds ago, saying: Jafet: What does 'mapM_' have to do with it?
06:54:46 <lambdabot> Unknown command, try @list
06:54:57 <Janni> mreh: Yes, I think it will help you to understand the internals to write more efficient code, although I'm not quite happy about that fact.
06:55:07 <mreh> :(
06:55:29 <mreh> you wish haskell was more transparent
06:55:33 <sohum> @hoogle Maybe a -> a -> a
06:55:34 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
06:55:34 <lambdabot> Prelude asTypeOf :: a -> a -> a
06:55:34 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
06:55:45 <Janni> mreh: It helps to know, whether the compiler will be able to make your code strict or not, but I hate to reason about that.
06:56:00 <malorie> engla: so `getZipLipList' (ZipList' a) = a', given the correct newtype?
06:56:06 <malorie> s/Lip//
06:56:17 <engla> yes
06:56:27 <malorie> I see. thanks :-)
06:56:59 <Janni> mreh: It depends on the level of efficiency you want to achieve. The first stage is to understand lazy evaluation. Then you could just wait for a few years and hope that the implementors will just make sure that everything that can be made efficient will be made efficient.
06:57:08 <btutt> Wrapping your head around lazy evaluation and thunks for performance purposes is a pain. Where's that: --markup-hs-with-strictness-anlaysis option? ;)
06:57:25 <Janni> mreh: (compiler implementors I mean)
06:57:59 <Janni> (but I should encourage your willingness to enlighten yourself on the implementation of FL)
06:58:22 <Janni> Read the book! Select the right chapters, some of them are very nice to read.
06:58:26 <btutt> i.e. f x y z = <...> yields: f is strict in x and y, but not z when you demand that a call to f actually be run.
06:58:30 <mreh> haskell increases strictness where it won't change the meaning of the program
06:58:43 <Janni> GHC does.
06:58:55 <Janni> (wherever it finds a way)
06:58:57 <mreh> but there are instances where you have to change the meaning of the program to get more efficiency
06:59:15 <Janni> Or you don't have to but the compiler is not able to find a way.
06:59:29 <Janni> Because the analyses are not sophisticated enough (yet)
06:59:40 <mreh> hmmm okay
07:00:23 <Janni> So that's where it is useful to know your compiler (what is he able to optimise and what not).
07:00:47 <jeffcutsinger> GHC's a woman.
07:00:52 <Janni> But while it is useful it is also ugly, because it is specific knowledge that might become obsolete over time.
07:00:52 <jeffcutsinger> FYI
07:01:07 <dafis> jeffcutsinger: How do you know?
07:01:40 <Janni> He spends to much time trying to understand it. Isn't it obvious?
07:02:06 <Janni> It gives him headaches, but he is also glad it exists. It's a necessity
07:02:32 <Janni> There's a lot of room for analogies, I guess.
07:02:36 <jeffcutsinger> I was about to say because it behaves in a stereotypically feminine way.
07:02:54 <dafis> ?
07:03:07 * hackagebot pointed 2.0.3 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-2.0.3 (EdwardKmett)
07:03:29 <jeffcutsinger> I was making a joke. Both times.
07:03:35 <KirinDave> jeffcutsinger, let's just take that nasty little metaphor and file it away, shall we?
07:03:51 <KirinDave> Perhaps in the "not okay, but good effort" drawer.
07:06:52 <medfly> hi #haskell!
07:06:55 <jeffcutsinger> OK. Just so we're clear. I don't actually believe GHC is feminine. I just found it odd that Janni used a masculine pronoun. I also try really hard not to have preconceived notions about women. I was trying to make a joke at the expense of typically bigoted jokes. Sorry if it came off another way.
07:07:11 <KirinDave> Haha, now you're trying to hard. :)
07:07:15 <absentia> what about my nick? (m/f?)
07:07:18 <medfly> I imagine someone comes from a language where the gender neutral way to refer to someone is as a male.
07:07:56 <Janni> Hmm, did I call GHC a "he"? *checking*
07:08:00 <medfly> s/comes/speaks
07:08:07 * hackagebot data-lens 2.0.2 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.0.2 (EdwardKmett)
07:08:13 <int-e> like english? i mean you cannot really use 'it' to refer to people ...
07:08:43 <edwardk> "So that's where it is useful to know your compiler (what is he able to optimise and what not)." is where I think the warlock hunt started.  ;)
07:09:10 <int-e> yeah, 'it' works perfectly for things like compilers.
07:10:24 <Janni> Yes, you're right. Probably it is because I'm speaking a lot of Dutch these days...
07:11:48 <obiwahn> is there a command/tool that shows me evaluation steps of an expression
07:12:02 <Janni> Pen and paper (scnr)
07:13:15 <Janni> obiwahn: Actually I'm not aware of anything better than that.
07:14:26 <Janni> obiwahn: Would you be satisfied with lambda calculus?
07:14:34 <edwardk> I am apparently most active in the Nikki and the Robots community: https://launchpad.net/~ekmett hah
07:16:19 <Saizan> @where stepeval
07:16:19 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
07:16:44 <Saizan> obiwahn: ^^^ it doesn't preserve as much sharing as lazy evaluation does though
07:18:27 <Janni> Saizan: This is still pretty cool. If it isn't _too_ limited it should be very instructive to beginners...
07:21:50 <Janni> Pity that you cannot easily provide additional top-level definitions.
07:22:24 <obiwahn> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=let+mapbyfold+fun+list+%3D+foldr+%28\x+y+-%3E+%28fun+x%29+%3A+y+%29+[]+list+in+mapbyfold+%28*2%29+[1%2C2%2C3]%0D%0A
07:22:32 <benmachine> Janni: it's too limited :P
07:22:59 <Janni> benmachine: OK, I'm just starting to notice that it doesn't unfold let-bound function definitions...
07:23:19 <benmachine> Janni: I wrote it; even the things it does do it doesn't always do right
07:23:31 <obiwahn> i have expressed map with fold 1 or 2 days ago i hav tried a few things and came up with the posted - it works but i stil dont see how the y parameter inthe lamda works ....
07:30:43 <Janni> obiwahn: Can you be more specific? foldr repeatedly applies to the function you expressed as a lambda expression. The first argument is an element from the list, the second the accumulated result (starting with []).
07:31:25 <Janni> (what I meant to say is, that foldr repeatedly applies that function to those two arguments)
07:33:00 <obiwahn> i think i got it - thank you Janni
07:33:15 <Janni> To your service.
07:33:26 <Janni> *at* your service
07:34:55 <erus`> does anyone know of a blog post with some haskell interview-style questions ?
07:35:31 <Janni> erus: That one maybe? http://blog.johantibell.com/2011/08/results-from-state-of-haskell-2011.html
07:35:42 <anton`> > succ 1
07:35:43 <lambdabot>   2
07:35:54 <anton`> @src foldl'
07:35:55 <lambdabot> foldl' f a []     = a
07:35:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:36:19 <erus`> Janni: no i mean like a test at a job interview
07:59:09 <erus`> how do i build without console window opening ?
07:59:17 <erus`> *when i start the app
08:00:42 <ClaudiusMaximus> erus`: http://www.haskell.org/haskellwiki/GHC:FAQ#A_console_window_opens_when_my_application_is_supposed_to_be_GUI_only
08:01:38 <erus`> thanks
08:01:46 <erus`> i need to learn how to use cabal
08:04:42 <erus`> also can i test if an IO function failed?
08:05:52 <erus`> because i am wrapping in an Either and this may be pointless
08:06:44 <ClaudiusMaximus> :t Control.Exception.catch
08:06:45 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
08:09:16 <ClaudiusMaximus> i need me some catches in my code - currently it just breaks horribly on disk full or similar..
08:10:13 <erus`> IO really messes things up :(
08:11:12 <benmachine> ClaudiusMaximus: sometimes breaking horribly is the right way forward
08:12:07 <erus`> oh god
08:12:16 <erus`> i think i will write the opengl bits in C
08:12:16 <ClaudiusMaximus> yep, but it doesn't crash entirely, only the worker threads die
08:12:24 <benmachine> oh right
08:12:31 <benmachine> that's not ideal :P
08:12:32 <erus`> and expose some nice drawsprite functions or something
08:12:41 <ClaudiusMaximus> so the rest of the program sits there waiting around forever
08:12:43 <leod> hmm, GL in haskell isn't that horrible imo
08:13:12 <hpaste> erus` pasted “horrible” at http://hpaste.org/51864
08:13:48 <leod> could be worse :p
08:13:55 <erus`> i have to change that to returning a Ptr gluint else i cant clean up
08:14:06 <erus`> its more verbose than in C :|
08:14:54 <ClaudiusMaximus> i couldn't find anything FBO in the haskellized bindings, so i used openglraw for that part.. am i missing the obvious or is it not yet implemented?
08:15:01 <hpaste> elliott pasted “Can anyone think of a simplification of this algorithm?” at http://hpaste.org/51865
08:15:11 <elliott> ...in particular, I'd like to avoid the nested runState, and the swap is quite ugly too.
08:15:23 <elliott> It's OK if the signature changes, as long as the same essential strategy is possible.
08:16:00 <elliott> (arity is :: Tm -> Int, and basically a parameter to the algorithm.)
08:16:09 <erus`> Elliott you could get rid of the do there..... :)
08:16:21 <elliott> heh, so I could
08:16:27 <elliott> Suddenly it is perfect :-)
08:17:13 <elliott> Oh... never mind, it's broken. Back to the drawing board :/
08:18:36 <erus`> everyone seems to be writing the ui in C# these days
08:18:43 <erus`> maybe i will jump on the bandwagon
08:21:37 <juliohm> Dear all, in Ghci, how to define this function to work? let f x = floor ((1+sqrt(1+4*x)) / 2) + x
08:21:53 <juliohm> When running it f 1, a coercion problem occurs
08:21:58 <parcs> :t let f x = floor ((1+sqrt(1+4*x)) / 2) + x in f
08:21:59 <lambdabot> forall b. (RealFrac b, Floating b, Integral b) => b -> b
08:22:25 <parcs> :t let f x = floor ((1+sqrt(1+4*fromIntegral x)) / 2) + x in f
08:22:26 <lambdabot> forall a. (Integral a) => a -> a
08:22:32 <c_wraith> :t Integral
08:22:33 <lambdabot> Not in scope: data constructor `Integral'
08:22:34 <c_wraith> err
08:22:36 <c_wraith> :t floor
08:22:37 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:22:40 <c_wraith> oh.
08:22:41 <benmachine> juliohm: what do you want the function to do, mathematically?
08:22:55 <c_wraith> WHy does floor go to Integral, rather than an arbitrary Num?
08:23:00 <juliohm> benmachine, it computes the n-th non square number. :-)
08:23:32 <c_wraith> doesn't n^2 do that too?
08:23:32 <benmachine> juliohm: ah, so x is an integer?
08:23:42 <benmachine> c_wraith: missing the non-
08:23:43 <erus`> can i use Either bind in the IO monad somehow?
08:23:44 <juliohm> benmachine, yes.
08:23:49 <juliohm> parcs, thank you...
08:23:49 <tromp> :t execWriter
08:23:50 <lambdabot> forall w a. Writer w a -> w
08:23:55 <juliohm> parcs, i'm trying here...
08:23:56 <benmachine> juliohm: insert fromIntegral before the x inside the brackets
08:24:18 <juliohm> benmachine, this is what parcs said. :-)
08:24:18 <tromp> :t parse
08:24:19 <lambdabot> Not in scope: `parse'
08:24:37 <tromp> :t Text.ParserCombinators.Parsec.parse
08:24:38 <lambdabot> forall tok a. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
08:24:38 <benmachine> oh, ok
08:24:57 <erus`> @hoogle IO Either a -> (a -> IO b) -> IO Either b
08:24:57 <lambdabot> Did you mean: IO (Either a a) -> a -> IO b -> IO (Either a a) /count=20
08:24:57 <lambdabot> No results found
08:25:22 <juliohm> ok, now how to solve the floor precision, because floor 4.999999999999 is actually 5 and the function fails because that
08:25:34 <c_wraith> juliohm: use round instead
08:25:36 <mauke> floor 4.999999999999 is not 5
08:25:36 <benmachine> > map (\x -> floor ((1 + sqrt(1+4*fromIntegral x)) / 2) + x [1 ..]
08:25:37 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:25:45 <juliohm> mauke, try and see
08:25:46 <benmachine> > map (\x -> floor ((1 + sqrt(1+4*fromIntegral x)) / 2) + x) [1 ..]
08:25:47 <lambdabot>   [2,4,5,6,7,9,10,11,12,13,14,16,17,18,19,20,21,22,23,25,26,27,28,29,30,31,32...
08:25:50 <c_wraith> erus`: that type doesn't make any sense.  Either needs two type arguments
08:25:54 <mauke> > 4.999999999999
08:25:55 <lambdabot>   4.999999999999
08:25:58 <mauke> > floor 4.999999999999
08:25:59 <lambdabot>   4
08:26:04 <benmachine> > floor 4.999999999999
08:26:05 <lambdabot>   4
08:26:08 <mauke> it's 4
08:26:13 <juliohm> > floor 4.9999999999999999999999999999999999999
08:26:14 <lambdabot>   5
08:26:17 <juliohm> ;-)
08:26:19 <c_wraith> erus`: did you mean something more like IO (Either a b) -> (a -> IO b) -> IO b  ?
08:26:21 <benmachine> > 4.9999999999999999999999999999999999999 == 5
08:26:22 <lambdabot>   True
08:26:22 <mauke> > 4.9999999999999999999999999999999999999
08:26:23 <lambdabot>   5.0
08:26:30 <tromp> :q
08:26:58 <juliohm> so the function fails when the sqrt and stuff get into an integer representation
08:27:12 <benmachine> juliohm: ok so the problem is that 'floor' has an integral output
08:27:13 <mauke> what?
08:27:17 <erus`> @hoogle IO (Either a b) -> (b -> IO c) -> IO (Either a c)
08:27:18 <lambdabot> No results found
08:27:34 <c_wraith> ah, so that's what you meant.
08:27:35 <benmachine> but a floating input
08:27:49 <benmachine> oh wait
08:27:49 <benmachine> no
08:28:08 <juliohm> benmachine, i think is not related to types, it's finite representation of any computer.
08:28:09 <erus`> double monads = hours of pain and suffering
08:28:18 <benmachine> juliohm: yeah I was answering the wrong question
08:28:18 <juliohm> How to change the precision of the floor function?
08:28:28 <benmachine> you need to change the types you use, actually :)
08:28:39 <benmachine> as in, using Float and Double will always be limited precision
08:28:41 <c_wraith> :t \x f -> join $ fmap (either return f) x
08:28:42 <lambdabot> forall a (m :: * -> *) b. (Monad m, Functor m) => m (Either a b) -> (b -> m a) -> m a
08:28:52 <c_wraith> heh.  whoops, got that wrong
08:28:57 <benmachine> if you could rejig the algorithm to make do with Rational (i.e. somehow excise the square root) then you'd be fine
08:29:17 <benmachine> but I suspect you can't
08:29:20 <juliohm> benmachine, hmmm, nice. I'll think about
08:29:38 <c_wraith> oh, I see
08:29:43 <juliohm> there is another way to solve this by simple type changes?
08:29:49 <c_wraith> :t \x f -> join $ fmap (left f) x
08:29:50 <lambdabot> forall a b c. (Monad (Either c)) => Either c (Either b a) -> (b -> c) -> Either c a
08:29:54 <juliohm> s/solve/improve/
08:30:02 <benmachine> juliohm: you can use the wildly inefficient CReal, but it's probably not what you want :)
08:30:07 <c_wraith> I clear suck at this, nevermind
08:30:23 <benmachine> (and anyway might not work, real numbers are scary)
08:31:10 <m42a> You could square the floor of the root, and compensate if it's off
08:31:16 <dafis> juliohm: use integer square root
08:31:46 <juliohm> what is the definition of the integer square root? and how is it defined in Haskell? let me check...
08:32:03 <benmachine> juliohm: there isn't an inbuilt one, unfortunately, but you can implement it yourself fairly easily
08:32:36 <dafis> juliohm: largest integer such that the square doesn't exceed n; you have to implement it yourself so far
08:32:43 <juliohm> hmmm, understand, and what is the definition of the integer sqrt? is like m42a suggested?
08:33:05 <benmachine> there are several ways of doing it
08:33:06 <juliohm> ok, thank you guys. :-)
08:33:24 <benmachine> I'm sure there's a cleverer way than the one I've got, but I'll paste it anyway
08:33:54 <hpaste> benmachine pasted “isqrt” at http://hpaste.org/51866
08:34:06 <dafis> juliohm: doing what m42a suggested will work as long as your numbers are small (< 2^64), then floor (sqrt x)) is never too large and never more than 1 too small
08:34:18 <benmachine> juliohm: http://hpaste.org/51866 this works
08:35:43 <benmachine> but I'm sure there are better ways
08:35:45 <juliohm> oh nice. :-)
08:35:57 <juliohm> i'm new to Haskell, is really beautiful
08:57:30 <absence> http://stackoverflow.com/questions/2104446/how-do-you-use-control-applicative-to-write-cleaner-haskell <- in the example in the first answer (y = ifte' ...), is the reason for both True and False being printed that all parameters must be evaluated in order to lift ifte'?
08:58:16 <benmachine> absence: no
08:59:25 <benmachine> absence: well, it's not really to do with evaluation, because it's not evaluating IO that runs it
08:59:42 <monochrom> <*> causes it
08:59:47 <benmachine> right
09:00:20 <benmachine> f <*> x in terms of IO says, run f, then run x, then apply the function f yielded to the value x yielded and return the result
09:00:36 <benmachine> so x is always run even if f doesn't need the value
09:01:01 <absence> doesn't that sort of make it part of the lifting process?
09:01:24 <benmachine> f >>= (\b -> if b then x else return somethingElse) actually uses the result of f to decide whether to run x or not
09:01:24 <malorie> is this looking alright: `instance Monad [] where xs >>= f = foldl (++) [] $ fmap f xs'?
09:01:36 <benmachine> absence: do not understand your question
09:01:55 <monochrom> I suppose you define "lifting" to mean "use <$>, <*>"
09:02:10 <benmachine> malorie: that's all right, but it doesn't work when xs is infinite
09:02:13 <rostayob> malorie: xs >>= f = concatMap f xs
09:02:17 <rostayob> :t concatMap
09:02:18 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
09:02:22 <benmachine> malorie: (not sure if that leads to it breaking the monad laws or not)
09:02:22 <absence> monochrom: yes. or liftA3, which produces the same result
09:02:27 <monochrom> but I am not convinced that the applicative style means "don't use pattern matching or if-then-else"
09:03:54 <benmachine> monochrom: ...who said it did?
09:04:14 <Eidel> How can i implement this idea in haskell? and [ x `elem` xs | (x:xs) ] I assume I can use take and drop, but dont know how
09:04:46 <malorie> benmachine: nice remark
09:04:48 <monochrom> a hypothetical programmer
09:05:06 <benmachine> Eidel: I don't know what that idea is
09:05:07 <absence> benmachine: what i meant by lifting is that in the first example (x = ifte) the condition is extracted by ifte itself, while in the second example (y = ifte') the condition is extracted by the "lifting mechanism" (<$> and <*> or liftA3)
09:05:28 <rostayob> malorie: your function is doing the same thing as using concatMap, but it reverses the list since you're using foldl, and also what benmachine said
09:05:36 <benmachine> absence: where by 'extracted' you mean 'from the functor in question'?
09:05:53 <benmachine> rostayob: don't think it reverses the list - remember (++) is associative
09:05:55 <absence> benmachine: yes, the (return True)  or (pure True)
09:05:55 <rostayob> ah no
09:05:58 <rostayob> yes
09:06:04 <rostayob> was going to say it
09:06:09 <benmachine> > foldl (++) [] ["hello","there","rostayob"]
09:06:11 <lambdabot>   "hellothererostayob"
09:06:20 <malorie> rostayob: I'll take a look at concatMap. trying to wrap my head around all the type classes, currently :-)
09:06:22 <absence> benmachine: sorry i'm not too good with the proper expressions yet :)
09:06:33 <benmachine> absence: right, that's fair enough
09:06:46 <rostayob> malorie: foldl (++) [] is equivalent to concat. you're flattening a list of lists into a single list
09:06:58 <Eidel> benmachine: i would like to check if there is any duplicates of objects in a list. First check if x exists, if not throw away and check if next x exists in list
09:07:09 <benmachine> absence: I still don't understand your question
09:07:46 <rostayob> @check \xs :: [Int] -> foldr (++) [] xs == concat xs
09:07:46 <lambdabot>   Parse error at "::" (column 5)
09:07:54 <rostayob> @check \xs -> foldr (++) [] xs == concat xs
09:07:55 <lambdabot>   "OK, passed 500 tests."
09:08:10 <rostayob> you can't type annotate lambdas?
09:08:22 <benmachine> rostayob: you need ScopedTypeVariables for some reason
09:08:24 <dafis> > or [x `elem` xs | (x:xs) <- tails [1,2,3,4,5,6,7,8,9,1]]
09:08:25 <lambdabot>   True
09:08:30 <dafis> > or [x `elem` xs | (x:xs) <- tails [1,2,3,4,5,6,7,8,9,10]]
09:08:31 <lambdabot>   False
09:08:37 <dafis> Eidel: ^^?
09:08:41 <Cale> > let hasDuplicate xs = xs /= nub xs in hasDuplicate [1..10]
09:08:42 <lambdabot>   False
09:08:48 <absence> benmachine: so what i wondered is, since there is a "lifting mechanism" outside the ifte' function which extracts the condition, is it a case of "all or nothing", where having the "mechanism" extract the condition also runs the actions in the other parameters?
09:08:50 <Cale> > let hasDuplicate xs = xs /= nub xs in hasDuplicate [1,2,3,4,5,5,6,7,8,9,10]
09:08:51 <lambdabot>   True
09:08:51 <rostayob> benmachine: oh right, why isn't that in haskell98?
09:08:52 <benmachine> Eidel: I think you want nub
09:09:02 <benmachine> rostayob: because of reasons
09:09:06 <Eidel> Thanks
09:09:21 <Cale> > let hasDuplicate xs = xs /= nub xs in hasDuplicate (1 : [1..])
09:09:21 <Eidel> dafis: going to try em out ^^
09:09:22 <lambdabot>   True
09:09:39 <Eidel> benmachine: i want to specify my own functions now, when i'm learning the language
09:09:58 <benmachine> Eidel: ok, well, do it recursively, with guards
09:10:14 <benmachine> you write something like yourFunction [] = p[
09:10:15 <benmachine> er
09:10:15 <Cale> > let hasDuplicate xs = xs /= nub xs in hasDuplicate ([1..100] ++ [1..])
09:10:17 <lambdabot>   True
09:10:17 <benmachine> you write something like yourFunction [] = []
09:10:30 <benmachine> yourFunction [x] = [x]
09:10:41 <benmachine> yourFunction (x:y:xs) | ...
09:10:45 <benmachine> you can finish it off :P
09:10:51 <Eidel> ty :)
09:11:02 <benmachine> or wait
09:11:07 <benmachine> hm
09:11:12 <benmachine> well, whatever
09:11:23 <benmachine> try your best, maybe use the 'delete' function (which you can write yourself if you want)
09:12:30 <benmachine> absence: ok so it's kind of true that since the lifting is not done by ifte', it can't decide which actions to run
09:12:56 <benmachine> absence: it's more generally true that in an applicative computation, which actions will be run is sort of predetermined
09:13:09 <benmachine> or, in a more general sense, the structure of the functor can't depend on its values
09:14:35 <benmachine> absence: fundamentally if you want which action is run to depend on a previous action, you need to use a monad
09:16:21 <absence> i see. i just have trouble understanding why laziness doesn't work beyond "that's just how it is, use a monad instead" :)
09:17:16 <hpaste> “Mukesh Tiwari” pasted “Error in cabal install” at http://hpaste.org/51868
09:18:07 * hackagebot HROOT 0.6.4.1 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.4.1 (IanWooKim)
09:18:21 <keep_learning> hello all
09:18:51 <keep_learning> trying to install cabal-install but getting error
09:20:31 <absence> benmachine: does this phenomenom have a name i can google for, or do you know of an article or something that can shed more light on it?
09:21:58 <Eidel> What is !(true) in Haskell?
09:22:48 <Cale> That's not a complete expression... ! would be an infix operator
09:22:54 <Cale> Perhaps array lookup
09:23:00 <elliott_> > !(true)
09:23:01 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:23:07 * hackagebot network 2.3.0.6 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.6 (JohanTibell)
09:23:16 <rostayob> Cale: i remember a really nice .svg on folds linked by you, but i lost the link
09:23:16 <elliott_> It is <no location info>: parse error (possibly incorrect indentation).
09:23:19 <chra> > not True -- this?
09:23:20 <lambdabot>   False
09:23:21 <engla> Eidel: True and False. In haskell, not False = True
09:23:34 <Eidel> engla: thanks!
09:23:40 <Cale> http://cale.yi.org/share/Folds.svg
09:23:57 <rostayob> Cale: cool, thanks
09:24:09 <keep_learning> some one please
09:24:15 <elliott_> scanl1 is funny.
09:24:20 <elliott_> keep_learning: What error?
09:24:21 <elliott_> What command?
09:24:25 <elliott_> OS? GHC version?
09:24:58 <Cale> keep_learning: You didn't say anything about the error, so nobody can help yet
09:25:18 <keep_learning> Cale, elliott_ http://hpaste.org/51868
09:25:39 <elliott_> keep_learning: See the link in the topic:/
09:25:43 <elliott_> http://is.gd/LXRBhh
09:25:50 <elliott_> You have to do some patching and editing to get cabal-install with 7.2.
09:25:56 <elliott_> You might just want to stick with the older version of GHC.
09:26:53 <Cale> lol, base >=4 && <3
09:27:29 <Cale> Yeah, if you don't have a good reason to want 7.2.1, I recommend 7.0.3 or 7.0.4 for now.
09:27:38 <elliott_> >=4 && <3? wow, I didn't even notice that
09:27:50 <dafis> That comes up frequently
09:27:57 <elliott_> can someone upload a base 4.-2 to Hackage?
09:27:59 <elliott_> that should solve it
09:28:05 <dafis> I don't remember what caused it, unfortunately
09:28:11 <elliott_> or, hmm
09:28:18 <elliott_> I guess it'd be 4-2
09:28:21 <elliott_> which is much less funny
09:28:28 <dafis> elliott_: reinstalling base is unpossible
09:28:45 <elliott_> dafis: Well, we just have to ship it with GHC.
09:41:34 <morphles> Though im learning haskell for quite some time, i find it kinda difficult to take on anything more serious than playing around in ghc. I think i need to learn some more functional programming patterns/conventions/ways to solve problems since im seriously lacking in this area. Maybe you could sugges some resources for this? For example i want to make kinda space strategy game(turn based, so performoance absolutely does not matter for now, and i/o only thru
09:42:08 <rostayob> morphles: i suppose you've already looked at real world haskell?
09:42:12 <rostayob> @where RWH
09:42:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:42:19 <ben> (You got cut off at i/o only thru)
09:43:09 <cheater> morphles: learn to use haskell for what you use your current scripting language
09:43:23 <morphles> rostayob: started reading it a bit, i have almost finished learn you a haskell, though i should probably invest more time there too.
09:43:24 <cheater> for example, see http://cheater.posterous.com/first-haskell-script
09:43:51 <rostayob> morphles: yeah RWH is really nice
09:44:24 <morphles> Ok, so ill continue it, and maybe near the end things will seem clearer :)
09:44:31 <cheater> morphles: different languages are just different hammers. basically you should try and build up your tool kit for what you do daily
09:44:48 <cheater> morphles: learn to write small scripts to solve your daily computing problems
09:44:57 <morphles> Well i must say functional programmer is/seems to be way more different from imperative :)
09:45:07 <cheater> it's just a red hammer
09:45:11 <cheater> it's not a green hammer
09:45:12 <morphles> :)
09:45:14 <cheater> that's all
09:45:15 <Cale> morphles: How long exactly? It took me about 2 months before I felt like I could really start using Haskell for real things, and I'd say about a year to feel "comfortable"
09:45:20 <morphles> its lazy and functional quite rare combo.
09:45:29 <cheater> why
09:45:31 <cheater> i'm lazy
09:45:33 <rostayob> morphles: well you have to be pure to be lazy eh
09:45:35 <morphles> :D
09:45:38 <Cale> Though, it's also not like I spent most of that time working on learning Haskell
09:45:41 <morphles> cheater: are you functional? :D
09:45:43 <rostayob> well not "have" to, but they're best together
09:45:44 <cheater> and i am a functional member of the community yes
09:46:15 <morphles> I mostly just solved some project euler problems in ghci
09:46:29 <cheater> yea fuck project euler
09:46:33 <cheater> learn to do things like
09:46:36 <cheater> filter text in haskell
09:46:37 <morphles> And some from 99 haskell
09:46:50 <Cale> Eventually, I just ended up taking on a large-ish project (a pipeline scheduler and register allocator for PPC/Altivec code), and that sort of coalesced a lot of the things I knew.
09:46:53 <morphles> Well i kinda started my hames datafiles parsing script
09:47:18 <cheater> try checking out snap framework
09:47:24 <cheater> you can use haskell to write html and shit
09:47:32 <cheater> that's fairly useful
09:47:33 <morphles> data declarations is what i have almost no knowledhe yet
09:47:37 <morphles> hm
09:47:48 <Cale> morphles: Ah, types are pretty key to programming in Haskell :)
09:48:02 <cheater> hey cale
09:48:12 <Cale> and structuring your code at the large scale of things
09:48:17 <cheater> i've been thinking today about what the haskell equivalent of uml would be
09:48:17 <Cale> hey
09:48:20 <cheater> what do you think?
09:48:28 <morphles> though i dont know much of haskell yet, it just seems so much more close to me than any oop stuff
09:48:29 <Cale> I think it's the Haskell type language.
09:48:35 <cheater> a graphical way to somehow describe your program
09:48:37 <Cale> Haskell is its own UML
09:48:41 <Cale> oh
09:48:43 <elliott_> ?quote uml
09:48:43 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
09:48:46 <cheater> that is what i mean
09:48:49 <cheater> just graphics
09:49:04 <Cale> If you want a graphical presentation, yeah, category theoretic diagrams :)
09:49:10 <cheater> yeah i was thinking
09:49:13 <cheater> maybe like a graph
09:49:17 <cheater> each vertex is a type
09:49:24 <cheater> and functions you have implemented are arrows
09:49:27 <cheater> right?
09:49:29 <Cale> yes
09:49:35 <cheater> but like
09:49:39 <cheater> that's not enough yet
09:49:47 <cheater> what about something like interfaces?
09:50:07 <byorgey> what are interfaces?
09:50:12 <cheater> a proxy
09:50:19 <absence> http://stackoverflow.com/questions/2104446/how-do-you-use-control-applicative-to-write-cleaner-haskell/2105047#2105047 <- "Compared to monads, applicative functors cannot run its arguments selectively. The side effects of all the arguments will take place." <- does this have a name i can google for, or is there an article or something i can read to learn more about why laziness doesn't work for this case?
09:50:29 <Cale> Well, to be honest, CT isn't *perfect* for modelling Haskell in particular, since it's more general.
09:50:39 <Cale> But it does get you quite a long way
09:50:51 <cheater> since haskell is more general?
09:50:55 <cheater> or since CT is more general?
09:51:02 <Cale> absence: It has nothing to do with evaluation
09:51:13 <Cale> absence: (and hence nothing to do with laziness)
09:51:39 <Cale> absence: When they say 'run' there, they mean in the sense of 'execution', as defined by the applicative functor/monad in question.
09:52:44 <absence> Cale: so applicative lifting (or how it's called) is defined to run all the arguments first, and then call the lifted function?
09:52:46 <morphles> Hm i guess ill rewrite some of my bash scripts with haskell for a good start :)
09:52:59 <Cale> absence: Yeah.
09:53:29 <cheater> cale?
09:53:39 <cheater> :)
09:54:03 <Cale> absence: When you write f <$> x <*> y, say for the IO monad, where x and y are IO actions, when this action is executed, both x and y will be executed, and then f applied to the results
09:54:15 <Cale> cheater: CT is more general
09:54:27 <cheater> Cale: ok so CT is a good embedding
09:54:30 <cheater> that's a good sign
09:54:48 <absence> Cale: ah, that simple :) and unless i have misunderstood, a monad is a superset of applicative functors? so these extra features of the monad is what allows selective running of arguments?
09:55:09 <Cale> absence: Well... every monad is an applicative functor, so a subset. :)
09:55:26 <Cale> absence: a superset of the available methods :)
09:55:49 <DanBurton> and both are supersets of tacos
09:56:01 <Cale> So yeah, with do-notation, you can decide based on the result of x whether or not to run y, say.
09:56:30 <cheater> what if you want to assign responsibilities to your code
09:56:55 <cheater> say your application has to receive mails, process them, and send them out to a list of people in a file on disk
09:57:01 <Cale> do u <- x; if p u then (do v <- y; return (f u v)) else ...
09:57:05 <absence> Cale: ow my head ;) i meant superset as in monads being applicative functors "and more". is that right?
09:57:14 <cheater> how do you assign responsibilities to chunks of haskell code?
09:57:16 <Cale> absence: yes
09:57:31 <absence> Cale: ok thanks, it's all a bit clearer now :)
09:57:31 <Cale> cheater: Well...
09:57:48 <cheater> Cale: well :)
09:58:11 <monochrom> f <$> x <*> y translated to monad is x >>= \a -> y >>= \b -> return (f a b) or liftM2 f x y. so much for "comparing with monads"
09:58:21 <Cale> cheater: There's only ever going to be so much of the real world that you can easily specify in talking about what your program does
09:58:40 <cheater> well if i were to assign those responsibilities i would say
09:58:47 <Cale> or  do u <- x; v <- y; return (f u v)
09:58:52 <cheater> "ok this class is persistent and keeps receiving email"
09:59:15 <cheater> "this class gets called from that via an interface and processes the incoming email based on eg subject"
09:59:23 <Cale> cheater: Yeah, but that's not formal, it's just an English sentence. You can say things like that about Haskell code too :)
09:59:31 <cheater> "this class reads (and writes to) the conf"
09:59:36 <cheater> yes
09:59:43 <monochrom> if you say, "you can mix if-then-else with do-notation or >>=, that's still monadic style; you can't mix if-then-else with <*>, that would not be applicative style", that's bullshit
09:59:43 <cheater> but how do you assign those responsibilities
09:59:48 <Cale> cheater: ?
09:59:55 <Cale> cheater: Maybe via types?
10:00:04 <cheater> because in my sentences i have been assigning responsibilities to OOP classes
10:00:17 <cheater> what do i assign responsibilities to in haskell?
10:00:26 <cheater> do i assign responsibilities to a type?
10:00:54 <Cale> cheater: values?
10:00:56 <cheater> can i say "this type is responsible for parsing the config file"?
10:01:01 <Cale> Sure, you can assign responsibilities to a type
10:01:12 <cheater> can you give me an example?
10:01:14 <Cale> Saying that all values of that type are required to satisfy something
10:01:28 <absence> monochrom: i see your point. how would the "ifte" example look in applicative style if it was to only run one of the putStrLn actions?
10:01:42 <cheater> so how would you solve the problem of assigning the responsibility of parsing a config file
10:01:46 <monochrom> just write an if-then-else
10:01:48 <Cale> and then make use of the module system to ensure that the only ways to construct values of that type preserve whatever conditions you placed on the values
10:01:48 <cheater> reading from and writing to it
10:02:07 <cheater> let's take that specific example
10:02:10 <saml> cheater, write a parser
10:02:14 <Cale> Like for example, Data.Set's internal representation is a binary balanced tree whose nodes respect a given ordering
10:02:21 <cheater> can we try to work through it?
10:02:41 <monochrom> or define "ifte b x y = if b then x else y" then use ifte
10:02:47 <cheater> Cale: but i don't think that's applicable to the "config parser" situation
10:03:20 <Cale> cheater: Define a new datatype Configuration representing the contents of the config file. Write a function String -> Configuration
10:03:37 <absence> monochrom: that is the definition of ifte'
10:03:44 <Cale> cheater: That's half of a specification right there :)
10:04:29 <hpaste> “Mukesh Tiwari” annotated “Error in cabal install” with “Error in cabal install (annotation)” at http://hpaste.org/51868#a51869
10:04:31 <monochrom> if you don't have a boolean value but rather an IO Bool action, let's call it baction: (ifte <$> baction) x y
10:04:52 <monochrom> which is fmap ifte baction x y
10:04:54 <cheater> Cale: you're right now telling me the solution
10:05:02 <DanBurton> @hoogle Bool -> a -> a -> a
10:05:03 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
10:05:03 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:05:03 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
10:05:05 <cheater> Cale: we're trying to think of a way to properly define the problem
10:05:20 <Cale> How is this not properly defining the problem?
10:05:31 <cheater> it's defining the solution
10:05:32 <Cale> We want to produce values of type Configuration given some file contents.
10:05:40 <Cale> I'm not telling you how to parse
10:06:14 <absence> monochrom: right, that's what y in the example is? ifte <$> baction <*> x <*> y
10:06:23 <cheater> i still think that was a bit too solution oriented
10:06:25 <monochrom> different
10:06:29 <cheater> rather than problem analysis like
10:06:32 <Cale> What's wrong with being solution oriented?
10:06:48 <keep_learning> where can i get zlib.h and z
10:07:01 <Cale> If we also define a function Configuration -> String which pretty prints a configuration to that file format, we can make an algebraic specification of the relationship between them
10:07:03 <cheater> it's easy to quickly find a probable solution that makes you blind to other things that could have been better
10:07:04 <absence> monochrom: i don't follow..
10:07:17 <monochrom> define "ifte b x y = if b then x else y". OK?
10:07:24 <keep_learning> now it says Missing (or bad) header file: zlib.h ,  Missing C library: z
10:07:31 <cheater> well ya sure
10:07:32 <cheater> but cale
10:07:34 <absence> monochrom: yes, that's the same as ifte' in the example?
10:07:35 <Cale> We ought to have  parseConfig . showConfig . parseConfig = parseConfig  and  showConfig . parseConfig . showConfig = showConfig
10:07:43 <cheater> i'm not trying to define the technical side of this
10:07:59 <cheater> this stuff is trivial to define for every computer programmer
10:08:08 <monochrom> I don't care about ifte' or stackoverflow. just define "ifte b x y = if b then x else y". OK?
10:08:13 <cheater> we're talking about how to make the step *previous* to that
10:08:13 <monochrom> @undefine
10:08:18 <cheater> as in, the actual planning
10:08:22 <monochrom> @let ifte b x y = if b then x else y
10:08:24 <lambdabot>  Defined.
10:08:31 <Cale> cheater: Deciding whether or not you want a configuration file in the first place?
10:08:32 <saml> cheater, what do you mean? read the config file and parse it
10:08:33 <monochrom> there, ifte stand for that, and nothing else
10:08:40 <cheater> Cale: for example
10:08:49 <saml> each config should have uri and support RESTful actions
10:08:55 <cheater> Cale: and where to break up responsibilities
10:08:56 <absence> monochrom: ok :)
10:09:02 <monochrom> then use fmap ifte baction x y
10:09:04 <cheater> and how to call the units that we break up into
10:09:19 <Cale> Umm... you just do it.
10:09:21 <cheater> saml: i think you're confused, try backtracking to the beginning of the convo :)
10:09:34 <cheater> Cale: you can't "just do" applications that take years to produce
10:09:38 <cheater> that's flawed advice
10:09:46 <absence> monochrom: "No instance for (Show (IO () -> IO ()))
10:09:53 <cheater> you need to plan it, plan your plan, and plan that again
10:09:54 <cheater> :)
10:09:57 <Cale> If there's a natural decomposition of some function f you're trying to write into g . h, you can split it up like that
10:10:09 <Cale> and then compose the two pieces back together again
10:10:13 <monochrom> fmap ifte (return False) (getLine) (print 0) ?
10:10:15 <cheater> in OOP it's easy for me to break up a program into classes
10:10:19 <cheater> which have responsibilities
10:10:25 <Cale> Classes are silly, btw.
10:10:26 <monochrom> @type fmap ifte (return False) (getLine) (print 0)
10:10:27 <lambdabot>     Ambiguous occurrence `ifte'
10:10:27 <lambdabot>     It could refer to either `L.ifte', defined at <local>:1:0
10:10:27 <lambdabot>                           or `Control.Monad.Logic.ifte', imported from Control.Monad.Logic
10:10:28 <cheater> what does a haskell program break up into?
10:10:36 <monochrom> @type fmap L.ifte (return False) (getLine) (print 0)
10:10:37 <lambdabot> IO () -> IO ()
10:10:39 <alpounet> cheater, functions
10:10:42 <alpounet> organized into modules
10:10:45 <monochrom> sorry
10:10:48 <Cale> cheater: lots of stuff... modules, functions+other values,...
10:11:01 <cheater> Cale: elaborate please
10:11:26 <monochrom> @type fmap L.ifte
10:11:27 <lambdabot> forall t (f :: * -> *). (Functor f) => f Bool -> f (t -> t -> t)
10:11:28 <Cale> cheater: You can use OOP in Haskell too if you want.
10:11:36 <cheater> i don't want to
10:11:45 <cheater> i want to use haskell in haskell
10:12:38 <Cale> But classes are a silly idea, so you wouldn't want to use them. It's supposed to be object oriented programming. Objects are values whose identity is determined by their responses to a specific set of methods or messages.
10:12:48 <Cale> You can represent those in Haskell as records of some functions.
10:12:59 <Cale> (or other values)
10:13:20 <Cale> and OOP decomposes nicely into functional programming :)
10:13:42 <tac-tics> Good ol' Haskell brainwashing :)
10:13:45 <DanBurton> FSVO "nicely"
10:13:55 <Cale> Quite nicely in practice.
10:14:03 <Cale> Nicer than Java, let's just say.
10:14:23 <Cale> I think Haskell is a better OO language than Java is.
10:14:38 <tac-tics> Cale: Java's a pretty easy target :P
10:14:41 <Cale> sure
10:14:56 <tac-tics> Haskell can't really compare to a decent OO language like Ruby or C#
10:15:03 <tac-tics> (in regards to OO'ness at least)
10:15:15 <monochrom> OK, I surrender and just go back to use if-then-else itself
10:15:17 <monochrom> @undefine
10:15:23 <Cale> Better OO language than any language where method implementations are inextricably linked to the types of the objects in question.
10:15:26 <DanBurton> @faq Can Haskell compare to decent OO languages like Ruby or C#?
10:15:26 <lambdabot> The answer is: Yes! Haskell can do that.
10:15:57 <Cale> I think Haskell is still a better OO language than C#, because C# makes the same damn mistake.
10:16:14 <DanBurton> There is a certain charm to Ruby, though
10:16:22 <DanBurton> slow though it may be
10:16:23 <Cale> Of tying method implementations to the type of the objects.
10:16:26 <yrlnry> @faq Will Haskell damage my pathetic little brain?
10:16:27 <lambdabot> The answer is: Yes! Haskell can do that.
10:16:52 <absence> monochrom:  (join (fmap ifte (return True))) (putStrLn "True") (putStrLn "False")
10:17:02 <monochrom> well join is monadic
10:17:10 <absence> ah, of course
10:17:24 <yrlnry> How can I write Haskell in Hangul?
10:17:25 <Cale> Which is silly -- the type of the objects should only specify the types of the methods, not their implementations. Their implementations should be part of the objects.
10:17:38 <monochrom> @src if'
10:17:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:17:45 <monochrom> > if' True 0 1
10:17:46 <lambdabot>   Not in scope: `if''
10:17:51 <Cale> at least, according to traditional OO :)
10:17:55 <elliott_> yrlnry: it should just work... not the keywords of course
10:17:58 <elliott_> but the identifiers you define yourself
10:18:04 <elliott_> except for the uppercase thing i guess will be problematic
10:18:06 <DanBurton> lambdabot just uses if' in @pl commands.
10:18:10 <elliott_> prefix your classes with C or something? :P
10:18:24 <Cale> cheater: but enough of that rant :)
10:18:33 <monochrom> @let ifte b x y = if b then x else y
10:18:34 <lambdabot>  Defined.
10:18:48 <DanBurton> > ifte True 0 1
10:18:48 <elliott_> Surely it should be if' for ?pl compatibility.
10:18:49 <lambdabot>   Ambiguous occurrence `ifte'
10:18:49 <lambdabot>  It could refer to either `L.ifte', defined at ...
10:18:59 <elliott_> heh
10:19:01 <Cale> cheater: A common approach to breaking down problems in a functional language is to design a language in which the solution to your problem (along with many similar ones) would be easy to express.
10:19:02 <elliott_> @undefine
10:19:06 <DanBurton> > ifte True 0 1
10:19:07 <lambdabot>   Couldn't match expected type `m a'
10:19:07 <lambdabot>         against inferred type `GHC.Bool....
10:19:13 <DanBurton> wat
10:19:14 <elliott_> @let bool x y b = if b then x else y
10:19:15 <lambdabot>  Defined.
10:19:22 <elliott_> @let if' b x y = bool x y b
10:19:23 <lambdabot>  Defined.
10:19:26 <Cale> cheater: and then implement that language, embedded in whatever host language you're using (like Haskell) as a library
10:19:28 <elliott_> > if' True 9 9
10:19:30 <lambdabot>   9
10:19:39 <elliott_> DanBurton: I guess ifte is from somewhere else?
10:19:39 <elliott_> :t ifte
10:19:40 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b -> m b
10:19:44 <elliott_> nice
10:19:44 <monochrom> well we like to call it ifte
10:19:54 <elliott_> too bad, that's not valid caleskell :P
10:20:03 <DanBurton> elliott_: yeah it's defined in Lambdabot's mystical L module
10:20:10 <elliott_> nah, that's just MonadLogic
10:20:11 <Cale> What?
10:20:20 <Cale> Yeah, that's from logict
10:20:24 <Cale> on hackage
10:20:38 <keep_learning> any idea how to install this library ?
10:20:43 <keep_learning> * Missing (or bad) header file: zlib.h
10:20:43 <Cale> cabal install logict
10:20:44 <keep_learning> * Missing C library: z
10:20:45 <Cale> oh
10:20:55 <DanBurton> @where MonadLogic
10:20:56 <lambdabot> I know nothing about monadlogic.
10:21:05 <elliott_> keep_learning: zlib1g-dev on debian
10:21:06 <monochrom> depends on your OS
10:21:26 <DanBurton> @hackage monadlogic
10:21:27 <lambdabot> http://hackage.haskell.org/package/monadlogic
10:21:40 <monochrom> @hackage halting-solver
10:21:41 <lambdabot> http://hackage.haskell.org/package/halting-solver
10:21:53 <DanBurton> boo
10:22:02 <Cale> cheater: I have a video on that approach by SPJ if you want
10:22:30 <Cale> cheater: http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
10:23:03 <Cale> cheater: But to think that there's any one approach to breaking down a problem into subproblems which will fit all problems is a bit much :P
10:23:21 <elliott_> @faq Can Haskell solve software engineering?
10:23:22 <lambdabot> The answer is: Yes! Haskell can do that.
10:23:30 <DanBurton> keep_learning: Are you on Windows?
10:23:33 <monochrom> @hackage software-engineer
10:23:33 <keep_learning> elliott_, i am using fedora core 15
10:23:34 <lambdabot> http://hackage.haskell.org/package/software-engineer
10:23:47 <elliott_> keep_learning: dunno then, google it :P "zlib development libraries fedora"
10:23:48 <keep_learning> DanBurton, i am using fedora core 15
10:23:59 <DanBurton> @google zlib
10:24:00 <lambdabot> http://zlib.net/
10:24:00 <lambdabot> Title: zlib Home Site
10:24:40 <cheater> Cale: interesting
10:24:54 <cheater> Cale: is there a transcript of that video? i cannot watch videos.. i have slow internet
10:24:59 <DanBurton> keep_learning: do you have admin rights on your machine?
10:25:02 <Cale> cheater: oh... :/
10:25:08 <Cale> There's a paper, I think
10:25:09 <keep_learning> DanBurton, yes
10:25:11 <absence> keep_learning: probably install zlib-devel or something
10:25:31 <Cale> but it's nowhere near as much fun, iirc.
10:25:40 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/Papers/financial-contracts/contracts-icfp.htm
10:25:41 <DanBurton> keep_learning: Try to install zlib with rpm or yum or whatever Fedora uses
10:25:53 <koeien> (the development headers you'll need)
10:26:02 <koeien> zlib is almost surely already installed
10:26:10 <DanBurton> what they said
10:26:24 <Cale> and the paper doesn't really get at the philosophical aspects of the example
10:26:40 <ulfdoz> llh
10:26:46 <ulfdoz> sry
10:27:05 <DanBurton> keep_learning: perhaps this: http://rpmfind.net/linux/rpm2html/search.php?query=zlib-devel
10:27:24 <elliott_> yum -i zlib-devel... or whatever
10:27:27 <elliott_> dunno yum
10:28:53 <Cale> The slides are a little opaque without the talk, but the "creamy fruit salad" slide is worth looking at :)
10:29:08 <Cale> pudding combinators :)
10:31:02 <saml> peanut butter arrows give me sorrows
10:31:37 <cheater> hmmm
10:31:45 <cheater> cool thanks
10:34:52 <Cale> cheater: The idea being that traditional cookbooks will describe how to make each of several hundred desserts and perhaps list certain properties about them, which is kind of like how people were managing various sorts of financial contracts -- they would have specific programs written to handle each kind of contract.
10:35:40 <Cale> cheater: and they would often have to approximate things by just picking the closest one when they didn't have a program for that sort of contract
10:36:34 <cheater> yes go on
10:36:37 <cheater> how does haskell solve that?
10:37:18 <Cale> cheater: So instead of that approach to describing desserts, you could instead define various basic ingredients, and ways of putting those ingredients together (layering things together, mixing.) and transforming what you have (blending, chopping etc.)
10:37:45 <Cale> and then you can define various operations on those descriptions which act recursively on the way in which they're built up
10:38:09 <cheater> and what does that bring us
10:38:11 <Cale> to, say, evaluate the sugar content, print out an English language set of instructions for making it, or any number of other things
10:38:45 <cheater> you've just defined the algebra of desserts
10:38:51 <cheater> you still haven't defined one dessert
10:38:52 <Cale> and we can do a similar thing for financial contracts -- building up complex contracts from simple ones, and then recursively breaking down that description to build various estimates of the value of the contract
10:38:55 <Cale> etc.
10:39:11 <cheater> so how does haskell tell me how to make pudding
10:39:44 <Cale> You define each pudding that you want to talk about by putting together the various primitive ingredients and pudding combinators
10:39:52 <cheater> yea
10:40:13 <cheater> so what you defined with haskell is not a better way to describe puddings, just a better way to check if the description is valid
10:40:29 <Cale> So, the creamy fruit salad ends up looking like:
10:40:51 <m42a> cheater: We've constructed a language that's designed for defining desserts, so it's easier to define desserts now
10:41:15 <tromp> > 917/8
10:41:15 <cheater> the old language could define desserts too
10:41:15 <lambdabot>   114.625
10:41:41 <m42a> yes, but the new language is better at it
10:41:54 <Cale> onTopOf (whipped (take pint cream)) (mixture (chopped (take 3 apple) (optional (take 6 orange)))
10:41:54 <cheater> why
10:41:56 <m42a> desserts can be defined faster, and in a more readable way
10:42:21 <cheater> ok
10:42:23 <Cale> and less complicated desserts can then be built into more interesting ones
10:42:28 <cheater> that does not solve my original problem though
10:42:32 <cheater> which is planning haskell programs
10:42:36 <cheater> not writing haskell programs
10:42:48 <Cale> and the functions for evaluating the sugar content, say, can be derived automatically from the description of the dessert
10:42:51 <brisingr> can't you just use RElisp and be done with it? (REcipe LISt Processing)
10:43:01 <Cale> cheater: This is a plan for writing Haskell programs
10:43:07 <cheater> what is
10:43:34 <Cale> cheater: Step 1) Figure out/design a language for describing problems in the domain your problem exists in.
10:43:53 <Cale> Step 2) Implement operations for turning descriptions of those problems into solutions of various types.
10:44:01 <cheater> i'm not gonna write fifty thousand mailing lists
10:44:02 <cheater> just one
10:44:04 <Cale> Step 3) Describe your program in that language.
10:44:15 <cheater> a general solution is not only pointless but useless and counter productive
10:44:26 <Cale> Then don't be very general about it.
10:44:46 <cheater> i cannot see the use of that
10:44:51 <cheater> how would you solve my mailing list idea
10:44:59 <cheater> ok wait
10:45:00 <cheater> just a sec
10:45:05 <Cale> But it's usually worthwhile abstracting over the properties of your mailing list somehow, and there are lots of subtasks of managing a mailing list which naturally break down like this
10:45:26 <brisingr> not to mention the fact that you can easily add/remove/modify features
10:45:37 <Cale> In fact, the general task of processing mail has resulted in quite a lot of special purpose languages
10:45:46 <Cale> look at sendmail's configuration files :P
10:46:02 <elliott_> There should be a #softwaredesign or something for these kinds of things.
10:46:11 <cheater> i have a book here
10:46:17 <Botje> it'd be full of "I WNAT TO WRITE FACEBOOK LOL"
10:46:20 <DanBurton> @where HTDP
10:46:20 <lambdabot> http://www.htdp.org/
10:46:29 <cheater> it has a description of a plan for a program of the following description:
10:46:35 <elliott_> Botje: So will any channel that admits such questions given enough time :)
10:46:53 <elliott_> #haskell is not quite "I WNAT TO WRITE FACEBOOK LOL", yet.
10:47:08 <Botje> elliott_: you'd be amazed how demotivating a thorough explanation of modern web app development can be :)
10:47:20 <cheater> "This code reads configuration information from the command line and a list of email addresses from a file. It checks for mail periodically. When it finds mail, it forwards it to each of the email addresses in the file."
10:47:21 <elliott_> Botje: See, and now you have a moderation strategy.
10:47:22 <Botje> 'oh, so it's not just hacking together stuff with CGI.pm?'
10:47:32 <monochrom> we have our dose of "can you make games and website in haskell"
10:47:37 <leod> I want to write a MMORPG, where do I start
10:47:39 <Cale> cheater: Okay. That's perfectly language agnostic.
10:47:49 <cheater> how would you describe the design of this program in haskell, without writing any code?
10:47:52 <Cale> (though not OS agnostic)
10:47:53 <DanBurton> @google haskell rpg
10:47:53 <cheater> any haskell code
10:47:55 <lambdabot> http://jpmoresmau.blogspot.com/2009/04/haskell-rpg-game-uploaded-on-hackage.html
10:47:55 <lambdabot> Title: JP Moresmau's Programming Blog: Haskell RPG Game uploaded on Hackage!
10:48:08 <DanBurton> leod: try there ^
10:48:12 <Cale> That's a perfectly acceptable description of a Haskell program already, isn't it?
10:48:18 <cheater> no
10:48:21 <Cale> (at least, without writing any code)
10:48:31 <cheater> in this book, they created a UML diagram from that
10:48:41 <Cale> I might write some type signatures
10:48:44 <cheater> and only then based on that they wrote the classes
10:48:46 <cheater> how
10:48:49 <cheater> what type signatures
10:49:04 <Cale> okay... let's start breaking the problem down the way that the description does
10:49:06 <monochrom> a UML class diagram is also a lot of type signatures
10:49:15 <cheater> yes go on
10:49:27 <elliott_> monochrom: And some arbitrary "plugs", no?
10:49:40 <Cale> So, we have some configuration from the commandline, and some configuration from a file, and we'll need a way to combine them
10:49:48 <Cale> So there's a type Configuration
10:49:51 <monochrom> then again maybe you have a UML use-case diagram instead
10:50:03 <Cale> and an operation  combineConfig :: Configuration -> Configuration -> Configuration
10:50:13 <Cale> and then there's a way to get configuration from the commandline
10:50:29 <Cale> [CommandLineOpt] -> Configuration
10:50:38 <Cale> and a way to get it from a configfile
10:50:45 <Cale> parseConfig :: String -> Configuration
10:51:07 <Cale> We also need to read a list of email addresses from a file
10:51:40 <Cale> getAddresses :: FilePath -> IO [EmailAddress]
10:52:08 <Cale> (maybe String -> [EmailAddress] as part of that)
10:52:23 <Cale> "It checks for mail periodically"
10:52:36 <Cale> checkMail :: IO [Message]
10:52:49 <Cale> "When it finds mail, it forwards it to each of the email addresses in the file."
10:53:01 <Cale> sendMail :: EmailAddress -> Message -> IO ()
10:53:28 <Cale> So, we just need to write these things and then start sticking them together.
10:55:10 <Cale> checkAndForward mailingList = do ms <- checkMail; forM ms $ \message -> forM mailingList $ \addr -> sendMail addr message
10:55:20 <Cale> blah blah blah
10:56:10 <Cale> The code is so simple in that case that we don't even need to bother with the type signature, but if you want it, it's  checkAndForward :: [EmailAddress] -> IO ()
10:56:47 <Cale> cheater: Is that sufficient to start with?
10:57:01 <cheater> yeah
10:57:02 <Cale> cheater: Haskell programmers design Haskell programs in Haskell.
10:57:17 <Cale> (by and large)
10:57:41 <cheater> "by and large"?
10:57:59 <cheater> but yea
10:58:04 <cheater> that makes sense to me
10:58:13 <cheater> it was fairly inspirational
10:58:22 <cheater> gave me some new ideas
10:58:35 <tromp> > 908/8
10:58:36 <lambdabot>   113.5
10:59:44 <roconnor_> good thing I didn't use the name "selection comonad" for the store comonad, since Escardo and Oliva are using the term "selection monad" for the J monad.
11:00:42 <cheater> hi roconnor_
11:00:43 <roconnor_> hi
11:00:53 <cheater> everything ok?
11:00:53 <cheater> :)
11:01:05 <roconnor> I think so
11:01:09 <cheater> very good.
11:05:38 <ctr> I'm trying to create a function that would take a given integer and create a list of all binary sequences of length x. For example, "binary 2" would yield "[[0,0],[0,1],[1,0], [1,1]]
11:06:08 <ctr> So far I can only get one set, but not all such sequences
11:06:33 <m42a> are you doing it recursively?
11:06:49 <Cale> > replicateM 2 [0,1]
11:06:50 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
11:07:08 <Cale> (but that's cheating, perhaps :)
11:07:12 <roconnor> ah replicateM, is there no problem you cannot solve.
11:07:19 <ctr> Cale, what is replicate M? Is that a prelude?
11:07:26 <Cale> ctr: It's in Control.Monad
11:07:34 <DanBurton> @hoogle replicateM
11:07:35 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
11:07:35 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
11:08:07 * roconnor conjectures that all software can be built out of replicateM and sequence
11:08:08 <DanBurton> So when the monad is [], you end up with a [[]]
11:08:13 <dafis> > sequence (replicate 2 [0,1])
11:08:15 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
11:08:15 <Cale> ctr: It's a monadic version of replicate (which is a function for which replicate n x is just a list of n copies of x)
11:08:22 <dafis> > sequence (replicate 3 [0,1])
11:08:23 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
11:08:34 <roconnor> oh right, replicateM is just a hidden use of sequence
11:08:43 <roconnor> so really it is sequence that solves all problems.
11:08:52 <Cale> roconnor: haha, yeah
11:08:57 <Cale> sequence is pretty nice
11:09:27 <wunki> I'm reading through LYAH and I found the following code: https://gist.github.com/1248909
11:09:43 <wunki> is Haskell that smart that it known we only use the head and thus stops the evaluation of the list?
11:09:43 <Cale> ctr: But yeah, writing this recursively is a good exercise :)
11:09:49 <BrianHV> > replicate 2 [0,1]
11:09:50 <lambdabot>   [[0,1],[0,1]]
11:09:52 <Cale> ctr: Maybe use list comprehensions though :)
11:10:19 <dafis> wunki: yes
11:10:24 <ctr> I'm stuck on writing it recursively--and unlike the prelude functions, I don't want to have to include [1,0]
11:10:36 <wunki> dafis: ok, consider me impressed..
11:10:43 <dafis> wunki: that's sort of the point of laziness
11:11:22 <roconnor> wunki: if you want to really be impressed, check out: http://r6.ca/blog/20081116T213644Z.html
11:11:24 <m42a> ctr: your base case should be [] so you can represent 0 length sequences
11:12:24 <wunki> roconnor: thanks for that gem. I understand lazy evaluation (to a point), but didn't think that it would look that *far*
11:13:16 <ion> It evaluates only as far as it needs to.
11:13:51 <wunki> yes, but the knowing how far it needs to is what I'm impressed by
11:15:26 <monochrom> wunki: see my http://www.vex.net/~trebla/haskell/lazy.xhtml  it is no magic, just carefully following orders
11:16:04 <wunki> monochrom: that's pretty extensive, thank you. Instpapered it for bed reading.
11:16:37 <ctr> m42a, have you created such a function before? I'm currently only able to get [1,0] for 2 and that's all--would you recommend creating a subfunction that operates like "sequence (replicate x [] )" ?
11:16:53 <wunki> monochrom: currently it's magic for me, hopefully after your article it isn't anymore :)
11:17:55 <dafis> from a higher viewpoint, all magic looks like sufficiently advanced technology
11:19:12 <m42a> ctr: I just wrote it now, and the only builtin I used was map
11:19:56 <m42a> ctr: try looking at it inductively: can you somehow progress 1 step at a time using only the previous step?
11:21:12 <DevHC> what's the availability to hs_init() after hs_exit()?
11:21:33 <DevHC> the GHC manuals say that it can't be done
11:21:52 <DevHC> and yes, i get segfaults when doing that from 1 program
11:22:25 <ctr> m42a: Yes...
11:22:30 <DevHC> but i don't get segfaults if i 1. load a library, 2. do hs_init() and hs_exit() there, and 3. unload the library; and then repeat
11:22:44 <DevHC> so is that expected to work?
11:24:11 <m42a> ctr: So you have your inductive case, now combine that with your base case (what is a binary sequence of length 0?).
11:25:46 <ctr> would yield []
11:26:23 <m42a> ctr: Nope. What's the type of this function?
11:26:54 <m42a> ctr: And how many sequences of length 0 are there?
11:28:43 <ctr> type I'm using is Int -> :: [[int]]
11:29:29 <ctr> 0
11:29:54 <dafis> ctr: what about []?
11:32:30 * ski . o O ( "Categorical Myths and Legends" <http://www.cs.le.ac.uk/people/ah83/cat-myths/> )
11:34:45 <ctr> Simply don't know where to go...
11:35:27 <m42a> ctr: Your base case is binary 0 = [[]]
11:35:45 <DanBurton> ctr: have you made an hpaste yet? http://hpaste.org/new/haskell
11:36:43 <ctr> Whats that?
11:37:05 <ctr> Oh, I see
11:37:35 <DanBurton> you can show us exactly where you're at
11:41:19 <yebyen> ctr!
11:46:29 <m42a> Can somebody explain why Haskell accepts (length >>= return) as a valid function?  I've been trying to figure out how an Int is being treated as a monad for about 2 hours, and it's not making any sense.
11:47:01 <dafis> m42a: length is not an Int, it's a function
11:47:11 <dafis> instance Monad ((->) a)
11:47:19 <dafis> aka reader monad
11:47:34 <dafis> :t length >>= return
11:47:35 <lambdabot> forall a. [a] -> Int
11:47:42 <xplat> length >>= return just becomes length
11:47:53 <Cale> > (do x <- length; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello!"
11:47:54 <lambdabot>   (6,"!olleH","HELLO!")
11:49:01 <parcs> f >>= g = \x -> g (f x) x
11:49:06 <xplat> > map (do x <- length; y <- reverse; z <- map toUpper; return (x,y,z)) ["Goodbye", "cruel", "world!"]
11:49:06 <lambdabot>   [(7,"eybdooG","GOODBYE"),(5,"leurc","CRUEL"),(6,"!dlrow","WORLD!")]
11:49:11 <parcs> (is that correct?)
11:49:13 <Cale> "Running" a function in the function monad just means applying it to the parameter to which the whole computation has been applied.
11:49:21 <ski> @src (->) return
11:49:22 <lambdabot> return = const
11:49:22 <ski> @src (->) (>>=)
11:49:22 <lambdabot> f >>= k = \ r -> k (f r) r
11:49:31 <parcs> yey
11:49:37 <dafis> parcs: I think it is
11:49:53 * dafis is always sooo slow
11:49:57 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
11:49:58 <lambdabot>   [5,7,10,25,32]
11:50:11 <ski> > (do x <- (^2); y <- (* 3); return (x + y)) 4
11:50:12 <lambdabot>   28
11:50:40 <xplat> > (do x <- (^2); y <- (* 3); return (x + y)) z
11:50:41 <lambdabot>   z * z + z * 3
11:50:53 <ski> > liftM2 (+) (^ 2) (* 3) 4
11:50:54 <lambdabot>   28
11:51:09 <Cale> > join (*) 5
11:51:10 <lambdabot>   25
11:51:42 <xplat> > join f x
11:51:43 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:51:43 <lambdabot>    `SimpleReflect.FromExpr ...
11:51:57 <xplat> > join f x :: Expr
11:51:58 <lambdabot>   f x x
11:55:58 <dafis> > let a ^^^ 0 = 1; a ^^^ k = a ^ (a ^^^ (k-1)) in join (^^^) 3
11:55:59 <lambdabot>   7625597484987
11:56:08 <dafis> > let a ^^^ 0 = 1; a ^^^ k = a ^ (a ^^^ (k-1)) in join (^^^) 4
11:56:23 <lambdabot>   mueval: ExitFailure 1
11:56:24 <lambdabot>  mueval-core: Time limit exceeded
11:58:43 <DanBurton> :t join
11:58:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:59:36 <DanBurton> @let dub = join (+)
11:59:37 <lambdabot>  Defined.
11:59:41 <DanBurton> > dub 3
11:59:45 <lambdabot>   mueval-core: Time limit exceeded
11:59:52 <DanBurton> huh
11:59:56 <DanBurton> @type dub
11:59:57 <lambdabot> forall a. (Num a) => a -> a
12:00:31 <dafis> > 3+4
12:00:32 <DanBurton> > join (+) 3
12:00:32 <lambdabot>   7
12:00:33 <lambdabot>   6
12:00:38 <DanBurton> > dub 3
12:00:42 <lambdabot>   mueval-core: Time limit exceeded
12:01:04 <dafis> odd
12:01:05 <DanBurton> so....why is lambdabot working so hard on dub?
12:01:18 <DanBurton> > let dub = join (+) in dub 3
12:01:18 <lambdabot>   6
12:01:36 <DanBurton> @undefine
12:02:51 <DanBurton> @djinn let tautology = join (==) in \xs -> tautology xs == True
12:02:51 <lambdabot> Cannot parse command
12:03:19 <DanBurton> @djinn \xs -> join (==) xs == True
12:03:19 <lambdabot> Cannot parse command
12:03:23 <kqr> i have a couple of questions related to type classes. how come Fractional isn't a child of Ord? and what is the difference between Fractional, RealFrac, Floating and RealFloat? they contain the same types
12:03:23 <DanBurton> boo
12:03:39 <tac-tics> kqr: The standard library classes (especially for number types) are crappy
12:03:49 <tac-tics> That should answer most of your questions implicitly :)
12:03:53 <kqr> haha, alright
12:04:02 <koeien> well, Ord => Num => Fractional
12:04:05 <dafis> kqr: complex numbers are Fractional, but neither Ord nor Real
12:04:15 <kqr> oh
12:04:21 <kqr> i guess that makes sense
12:04:22 <koeien> ah, it's Eq => Num
12:04:24 <koeien> never mind :)
12:04:37 <dafis> kqr: and Rational is Fractional but not Floating
12:04:58 <DanBurton> dafis++
12:05:22 <kqr> are complex numbers part of the standard library types, or did you point out how the classes make sense?
12:05:35 <DanBurton> oh silly me I meant check not djinn xP
12:05:37 <dafis> kqr: standard, Data.Complex
12:05:40 <kqr> cool
12:05:45 <DanBurton> @check \xs -> join (==) xs == True
12:05:47 <lambdabot>   "OK, passed 500 tests."
12:06:31 <DanBurton> @check \x -> join (+) x == 2 * x
12:06:33 <lambdabot>   "OK, passed 500 tests."
12:07:42 <kqr> anyways, another unrelated question: when i specify my functions i try to make them curryable, but i find that to be a difficult thing to do. i can see several possible ways to order the arguments. some make sense from a currying point of view but are ridiculous from an interface perspective. how do you decide on the best ordering of the arguments?
12:08:09 <dafis> kqr: least changing first
12:09:07 <DanBurton> @google haskell function argument order
12:09:09 <lambdabot> http://www.haskell.org/tutorial/functions.html
12:09:09 <lambdabot> Title: A Gentle Introduction to Haskell: Functions
12:09:56 <kqr> dafis, take as an example a function to numerically differentiate another function. it could take three arguments: the function to the function to be differentiated, the point at which you want to differentiate the function and the precision with which you want to perform the differentiation
12:10:20 <kqr> dafis, would you then suggest an ordering of precision, function, value?
12:10:39 <monochrom> you have to use experience or statistical data to decide the best order. for example someone chose "map f xs" because it was observed that "map f" was used quite a lot more than the alternative
12:10:55 <kqr> (i've not studied maths in english so i lack a lot of terminology, as you might notice. i'm sorry about that)
12:12:09 <koeien> kqr: that one seems to make the most sense initially
12:12:41 <dafis> yes, I would agree
12:18:13 <ClaudiusMaximus> :t let diff = undefined :: Num a => Int -> (a -> a) -> a -> a ; d = diff 53 ; f x = x ^ 7 ; x0 = 3 in (d . d . d . d) f x0 -- another reason that order might make sense
12:18:14 <lambdabot> forall a. (Num a) => a
12:20:29 <hpaste> DanBurton pasted “Old discussion: Binary stuff” at http://hpaste.org/51872
12:22:20 <DanBurton> Do you guys see a way to write toBinary' so that it doesn't produce a reversed list?
12:22:39 <DanBurton> without using ++ [x] that is
12:23:01 <DanBurton> @src reverse
12:23:02 <lambdabot> reverse = foldl (flip (:)) []
12:23:57 <ClaudiusMaximus> @hoogle testBit
12:23:58 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
12:24:33 <akosch> i'm trying to use HDBC with ODBC (mysql) on windows, everything is dandy and works great... but I have one problem: seems like somehow integer values get quoted as well (in prepared statements). Can I do something about it?
12:25:46 <akosch> I mean I don't want to switch to raw SQL execution, but I don't want integers to be quoted either. So can I tweak this somewhere? Maybe the ODBC driver?
12:26:17 <zygoloid> > let allBits 0 = [[]]; allBits n = liftM2 (:) [False,True] $ allBits (n-1) in allBits 3
12:26:18 <lambdabot>   [[False,False,False],[False,False,True],[False,True,False],[False,True,True...
12:27:06 <akosch> or maybe this is a bug?
12:27:43 <hpaste> monochrom annotated “Old discussion: Binary stuff” with “Old discussion: Binary stuff (annotation)” at http://hpaste.org/51872#a51873
12:27:59 <monochrom> DanBurton: I have pasted a common trick for this
12:28:06 <DanBurton> > let toBits bits n = map (testBit n) [0..bits-1] in toBits 3 7
12:28:07 <lambdabot>   Ambiguous type variable `t' in the constraint:
12:28:07 <lambdabot>    `Data.Bits.Bits t'
12:28:07 <lambdabot>      a...
12:29:00 <DanBurton> monochrom: yes I figured that would be the answer. I need to familiarize myself with that trick more thoroughly
12:29:30 <monochrom> generally you write [a]->[a] functions and the semantics is "prepend"
12:29:54 <monochrom> such as (Zero :) and ([One, Zero, One ++)
12:30:00 <zygoloid> > let toBinary n = go n [] where go 0 xs = xs; go n xs = go (n `div` 2) (odd n:xs) in toBinary 123
12:30:02 <lambdabot>   [True,True,True,True,False,True,True]
12:30:05 <monochrom> err, ([One, Zero, One] ++)
12:31:32 <DanBurton> @let bin b = if b then 1 else 0
12:31:34 <lambdabot>  Defined.
12:31:46 <DanBurton> > let toBinary n = go n [] where go 0 xs = xs; go n xs = go (n `div` 2) (bin $ odd n:xs) in toBinary 123
12:31:47 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:31:47 <lambdabot>         against inferred type ...
12:32:03 <DanBurton> > let toBinary n = go n [] where go 0 xs = xs; go n xs = go (n `div` 2) (bin (odd n):xs) in toBinary 123
12:32:06 <lambdabot>   [1,1,1,1,0,1,1]
12:32:43 <zygoloid> > let toBinary n = go n [] where go 0 xs = xs; go n xs = go a (b:xs) where (a,b) = n `divMod` 2 in toBinary 123
12:32:45 <lambdabot>   [1,1,1,1,0,1,1]
12:33:08 <hpaste> “m42a ” pasted “Reader Monad” at http://hpaste.org/51874
12:33:47 <m42a> I'm trying to do reader manually to understand it, but I don't see a redex here
12:34:19 <erus`> does anyone want 'frozen synapse' i have a spare key
12:34:58 <DanBurton> erus`: is that the new humble bundle thing?
12:35:07 <erus`> yeh
12:35:34 <zygoloid> m42a: line 5 is wrong. you need parens around "length >>= (...)"
12:37:52 <zygoloid> m42a: you're missing more parens, but your big problem is line 1 is wrong. f >>= g = g (f x) x
12:39:36 <akosch> what's the closest one can get to a do-while loop?
12:40:32 <erus`> akosch: do while requires state
12:40:54 <erus`> you could have some loop in which the body returns another function and a value
12:41:08 <erus`> then loop like that
12:41:20 <akosch> erus`: sounds reasonable
12:41:57 <aavogt> @type until
12:41:59 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
12:42:00 <monochrom> I just use recursion
12:42:22 <DanBurton> @hoogle until
12:42:22 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
12:42:26 <monochrom> @src map
12:42:27 <lambdabot> map _ []     = []
12:42:27 <lambdabot> map f (x:xs) = f x : map f xs
12:42:42 <monochrom> that's a while loop, "while the list is not empty..."
12:43:56 <DanBurton> do while also implies effects. You want to perform some effect before ever checking the condition.
12:44:46 <monochrom> the effect is "change the parameter from x:xs to xs" and that is realized by mere parameter passing
12:45:43 <ghosting> Anybody know some good material on making a haskell interpreter?
12:45:56 <monochrom> basically the "side effect" of merely changing a local state variable is a piece of cake. it's the I/O outside world that really needs talking about "side effects"
12:48:13 <monochrom> if you cite ST, the real attraction is mutating a cell in a big array. it is not that exciting for merely having 5 bool variables.
12:49:41 <DanBurton> ghosting: I think /r/haskell had an article a couple weeks ago with an interpreter for a dumbed-down version of Haskell
13:01:50 <DanBurton> I always get around to posting these things long after the conversation dies
13:02:10 <hpaste> DanBurton pasted “do while” at http://hpaste.org/51882
13:03:35 <beddsy> hey all
13:03:54 <DanBurton> hey beddsy
13:04:00 <eyebloom> hi
13:04:06 <beddsy> when I do [5] ++ [5.5], the elements on the left seems to get promoted to fractional
13:04:15 <tac-tics> :t 5
13:04:15 <beddsy> this seems strange
13:04:16 <lambdabot> forall t. (Num t) => t
13:04:16 <tac-tics> :t 5.5
13:04:17 <lambdabot> forall t. (Fractional t) => t
13:04:37 <tac-tics> seems reasonable when you see that literals don't have a concrete type
13:04:46 <beddsy> I was thinking they would both generalize to Num
13:05:01 <DanBurton> but 5.5 cannot be just any num, because it is obviously fractional
13:05:02 <dafis> beddsy: 5.5 can't be an Int
13:05:09 <tac-tics> @type [5] ++ [5.5] :: Num a => [a]
13:05:10 <lambdabot>     Could not deduce (Fractional a) from the context (Num a)
13:05:10 <lambdabot>       arising from the literal `5.5' at <interactive>:1:8-10
13:05:10 <lambdabot>     Possible fix:
13:05:32 <tac-tics> @type 5.5 :: Num a => a
13:05:33 <lambdabot>     Could not deduce (Fractional a) from the context (Num a)
13:05:33 <lambdabot>       arising from the literal `5.5' at <interactive>:1:0-2
13:05:33 <lambdabot>     Possible fix:
13:05:37 <tac-tics> There's your problem :)
13:05:42 <beddsy> ah strange, I guess it does synthesize to Num
13:06:45 <beddsy> Can we have a concrete list of a type class?
13:07:12 <beddsy> Or must it be a data type?
13:07:33 <beddsy> ah, looks like it according to tactics
13:07:49 <beddsy> (sorry if I'm a little slow, my haskell is not so good)
13:08:49 <tac-tics> @type [5.5] :: [Float]
13:08:50 <lambdabot> [Float]
13:09:04 <tac-tics> beddsy: Is the above what you mean?
13:09:37 <tac-tics> beddsy: type classes are pretty much the main innovation in Haskell (that and monads), so it's all right to find them a bit confusing :)
13:09:57 <beddsy> basically, I want to know if two data types that are related only by a type class can be stored in the same list
13:10:24 <ben> existential types
13:10:38 <tac-tics> beddsy: That situation requires an extension to Haskell
13:10:45 <tac-tics> beddsy: In basic Haskell, no, you can't do that
13:11:00 <beddsy> ah, why is it not available in basic haskell?
13:11:16 <ciaranm> you need to use visual haskell for that
13:11:20 <beddsy> er, shoudl I say, why is it available via an extension
13:11:28 <tac-tics> Because the type classes are instantiated as concrete types at compilation.... or something to that note
13:11:44 <beddsy> so it's an efficiency thing?
13:11:47 <tac-tics> no, it's a type system thing
13:12:09 <ciaranm> type classes aren't interfaces. it's best not to think of them that way.
13:12:10 <tac-tics> I believe it relies on second-rank types
13:12:32 <beddsy> type classes seem more like C# generic constraints?
13:12:39 <erus`> whats the haskell way todo generics ?
13:12:43 <ski> @type 5 :: Integer
13:12:44 <lambdabot> Integer
13:12:47 <ski> @type 5 :: Int
13:12:48 <lambdabot> Int
13:12:50 <ski> @type 5 :: Double
13:12:51 <lambdabot> Double
13:13:14 <ski> @type 5 `asTypeIn` \five -> [five,5.5]
13:13:15 <lambdabot> forall t. (Fractional t) => t
13:13:26 <Ptival> aren't generics just plain parametric polymorphism?
13:13:31 <Ptival> kinda
13:13:42 <ciaranm> generics in java aren't even that
13:13:51 <tac-tics> Type classes work like this. You see TypeClass a => ... at the start of a function definition, you can fill in a with any type that has "instance TypeClass a" defined
13:13:59 <ciaranm> generics in java are just horrible wrappers around a base class with automatic casts
13:14:23 <beddsy> tac-tics, yes, but the genericty is only available at compile-time?
13:14:30 <ski> Ptival : are you talking about <http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html> or <http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html> ?
13:14:52 <ski> Ptival : or are you talking about what is called "generics" in e.g. Java or Ada ?
13:15:04 <tac-tics> beddsy: The timing isn't so important, but once you decide on a concrete type, you can only put that kind of thing in your list
13:15:14 <Ptival> ski: the last ones
13:15:23 <beddsy> I'm just trying to draw a distinction between haskell type classes and OOP's interfaces
13:15:34 <Ptival> I just didn't know Haskell had thingies called generics too
13:15:49 <ski> Ptival : ok, those are basically the same as "parametric polymorphism" in Haskell (maybe minus the "parametric", in the sense of "parametricity")
13:15:54 <beddsy> so you couldn't, for example, build an OO system from a type class system, even though they look superficially similar?
13:16:05 <erus`> is using existential types bad practise
13:16:15 <ski> not really
13:16:33 <ski> (but you shouldn't use them when there's no clear gain to doing so)
13:16:46 <Cale> beddsy: Well, you sort of could, though moreso this ability just comes from the ability to put functions together into records.
13:16:48 <erus`> i need a list of all entitys in the game world
13:16:49 <danharaj> You can often replace existential types with typeclasses or record types.
13:16:51 <ski> see <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
13:17:14 <erus`> entities are not the same type
13:17:42 <Ptival> with type classes, you can overload constants or on return types, I think it is quite hard to do so in C++ (templates...) and not possible in, say, Java, is it?
13:18:23 <Cale> beddsy: An object is just a value whose identity is determined by how it responds to a bunch of "methods" or "messages". Functions and IO actions in Haskell are first class, and we can bundle a bunch of them together into a record datatype and construct objects quite nicely.
13:18:35 <ski> beddsy : have you seen
13:18:36 <ski> @wiki OOP_vs_type_classes
13:18:36 <lambdabot> http://www.haskell.org/haskellwiki/OOP_vs_type_classes
13:18:38 <ski> ?
13:18:48 <Ptival> that would be a good start :)
13:19:01 <Cale> A nice thing about this approach is that the method implementations aren't tied to the type itself like they are in, say, Java or C#
13:19:13 <Cale> which is in my mind a lot closer to how OOP should be
13:19:32 <danharaj> I think record polymorphism would nail oop fairly well.
13:19:35 <ski> (which is a lot closer to how OOP shoudl be ? :)
13:19:49 <ski> danharaj : do you mean (record) subtyping ?
13:20:08 <danharaj> pretty much
13:20:13 <beddsy> ya, it seems objects are premised on aliasing / volatility and identity
13:21:26 <Cale> ski: Well, objects are determined by how they respond to messages. Two objects with the same type shouldn't be required to do the same things. Java and the like get around this problem by subtyping, but it introduces artificial extra distinctions between objects that respond to the same set of messages.
13:22:02 <beddsy> well guys, thanks for your help - I may be bugging you as I go on with Haskell :D
13:22:18 <ski> danharaj : have you seen "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> ?
13:22:35 <danharaj> no, but I recognize the name cardelli.
13:23:37 <Cale> beddsy: anyway, one big difference, I think the biggest difference, between Haskell typeclasses and Java interfaces as I remember them (granted, I used Java a long while ago) is that a typeclass constraint can be applied to a type variable and then that type variable can be used more than once
13:23:40 <ski> Cale : yeah, i asked whether it was the "method implementations aren't tied to the type itself", or the "like they are in, say, Java or C#" which "how OOP should be" referred to ;)
13:24:10 <Cale> beddsy: So you can say "this type, whatever instance of the class it is, has to be the same type in all these places in the signature, in addition to being a member of the class"
13:24:47 <Cale> ski: Ah, "method implementations aren't tied to the type itself" is how OOP should be :)
13:24:53 <jonafan> I think of typeclasses as a means of doing function overloading.
13:25:16 <ski> danharaj : that paper divides `polymorphism' into two common cases `universal' and `ad-hoc', further dividing `universal' into `parametric' and `inclusion' (i.e. subtyping), and `ad-hoc' into `overloading' and `coercion'
13:25:27 <danharaj> so
13:25:35 <danharaj> "proper" and "gross disgusting travesties"? :p
13:25:53 <beddsy> I wonder why Haskell makes people use the instance construction to specify a member of a class? Can't it just use somethinmg more like duck-typing?
13:26:11 <Cale> beddsy: What do you mean by that?
13:26:27 <Cale> beddsy: consider a type like   sort :: (Ord a) => [a] -> [a]
13:26:35 <ski> danharaj : also "How to make ad-hoc polymorphism less ad hoc" by Philip Wadler,Stephen Blott in 1989-01 at <http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html#class> is also relevant
13:26:46 <beddsy> That is, if matching functions exist, just make the type a member automatically
13:26:48 <Cale> beddsy: This says that the function sort takes a list of values of some ordered type a, and produces a list of values of that same type.
13:27:17 <tac-tics> beddsy: From a developer's point of view, it's nice to have that kind of thing made explicit.
13:27:17 <Ptival> beddsy: functions are not linked to types the way methods are linked to classes
13:27:32 <Cale> This type for sort will be inferred from its implementation just on the basis that it uses operations like (<) :: (Ord a) => a -> a -> Bool
13:27:56 <ski> jonafan : you can also check that ^ paper :)
13:27:59 <beddsy> You could make it match on the name instead of just the signature
13:28:00 <Cale> beddsy: So, by using typeclass polymorphic things, we can make more typeclass polymorphic things
13:28:10 <tac-tics> beddsy: Otherwise, you'd have to guess. And if a type class has multiple member requirements (Enum, for instance), then you have to also make sure ALL the methods are implemented
13:28:12 <Cale> that the people who originally defined the typeclass didn't even think of
13:28:21 <Cale> beddsy: yeah?
13:28:43 <Cale> You *could*, say something like:
13:29:00 <Cale> sort :: ((<) :: a -> a -> Bool) => [a] -> [a]
13:29:05 <beddsy> ya
13:29:16 <ski> but it's hard to infer that (in a sensible way)
13:29:33 <ski> @src sort
13:29:34 <lambdabot> sort = sortBy compare
13:29:34 <Cale> and hard to keep things neatly organised
13:29:43 <ski> @type let sort = sortBy ?compare in sort
13:29:44 <lambdabot> forall a. (?compare::a -> a -> Ordering) => [a] -> [a]
13:29:57 <beddsy> it seems that the instance construction makes the language learning curve a little higher
13:29:59 <Cale> Like, if something uses both sort and (<) then, what's the type signature? Do we have to worry about possible overloadings of sort?
13:30:04 <beddsy> *steeper
13:30:10 <Cale> beddsy: Maybe a little
13:30:17 <tac-tics> beddsy: instance lowers the reasoning curve significantly
13:30:33 <Cale> beddsy: Well... there's also lots and lots of extensions to the typeclass system which you can spend lots of time learning about
13:30:39 <Cale> beddsy: But the basic idea isn't so hard
13:30:42 <tac-tics> beddsy: You don't have to play a stupid game of "grep the definition" to figure out what classes your type instances
13:30:43 <beddsy> Is there a paper I can read to understand the difference in "reasonability"?
13:31:05 <beddsy> @Cale
13:31:05 <lambdabot> Unknown command, try @list
13:31:09 <Cale> ummm
13:31:22 <beddsy> the different algorithms required
13:31:23 <Cale> Well, I could point you at the original paper introducing typeclasses, I guess.
13:31:35 <Cale> Is that what you mean?
13:31:41 <Ptival> which was mentioned earlier by ski
13:32:03 <Cale> :t (+)
13:32:04 <lambdabot> forall a. (Num a) => a -> a -> a
13:32:08 <Cale> :t 1
13:32:09 <lambdabot> forall t. (Num t) => t
13:32:13 <Cale> :t 1 + 1
13:32:14 <lambdabot> forall t. (Num t) => t
13:32:14 <beddsy> So there were two different ways to tell which are members of a type class
13:32:28 <Cale> > 1 + 1 :: Double
13:32:28 <Ptival> :t read
13:32:29 <lambdabot>   2.0
13:32:29 <lambdabot> forall a. (Read a) => String -> a
13:32:35 <Cale> ^^ oh yeah
13:32:46 <beddsy> one is explicitly with instance, the other with duck-typing and using the name of the function as well
13:32:47 <Cale> read is a really really good example of how this is different from OO interfaces
13:32:48 <ski> s/@Cale/Cale : ^/
13:33:23 <Cale> beddsy: umm... I'm not sure I understand what you're referring to
13:33:36 <beddsy> so the consequences of implementing each is a different inference algorithm
13:33:39 <ski> Cale : well, i might say s/different/more general than/
13:34:02 <Cale> beddsy: Oh, you're talking about Haskell-as-it-is, vs. Haskell-as-it-might-have-been?
13:34:02 * ski isn't sure what beddsy means, either
13:34:14 <beddsy> Cale, ya
13:34:33 <tac-tics> Isn't every extension to Haskell and every side project a case of "Haskell-as-it-might-have-been"?
13:34:33 <beddsy> I want to understand what the consequences would be had they chosen the other way
13:34:36 <Cale> beddsy: Well, it would be pretty similar to all typeclasses being restricted to having only a single method
13:34:41 <Cale> yeah?
13:34:50 * ski recalls the "Foo as seen by Bar fans" pictures
13:35:11 <Cale> So it would basically give us less ability to group together a bunch of operations which are meant to work together.
13:35:26 <beddsy> so it would actually cripple other features?
13:35:37 <Cale> and we'd end up referring to whole collections of operations in class contexts rather than just a single typeclass
13:35:38 <beddsy> I thought it might just make the lang implementation more complex
13:35:40 <tac-tics> beddsy: Monads are one example of a typeclass with > 1 method
13:35:43 <Cale> in all our types
13:35:44 <tac-tics> Monads are critical to haskell
13:35:56 <Cale> for some value of "critical"
13:36:04 <Cale> They're not really that big a deal :P
13:36:09 <ski> well, before Haskell 1.4, there was no monads in Haskell
13:36:11 <tac-tics> They are if you like do notation
13:36:16 <beddsy> alright, that helps me a lot :)
13:36:24 <beddsy> gtg tho! thanks again alll!
13:36:34 <ski> np, beddsy
13:36:34 <Cale> beddsy: It basically helps us reduce clutter
13:36:37 <Cale> see you!
13:36:39 <tac-tics> type classes aren't a big deal either if you ask the ocaml folks
13:37:05 <Ptival> I was wondering something, are modular type classes still considered?
13:37:06 <ski> tac-tics : i've seen O'Caml folks lament the lack of type classes in their language ..
13:37:21 <ski> "modular type classes" being ?
13:38:03 <Ptival> http://www.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf
13:39:10 * ski recalls seeing that paper earlier, but can't recall reading it
13:39:52 <jonafan> yeah i'm an ocaml guy more than a haskell guy
13:39:56 <Ptival> one of the problems is that instances in Haskell have to be unique for any type, or you need to wrap that type
13:40:16 <jonafan> typeclasses make me pretty jealous
13:40:50 <Ptival> while ML modules allow to somehow gives names to different "instances", and then refer to them (but you always have to qualify by the module instance name)
13:41:04 <jonafan> The module system is cool, but + +. +/ sucks.
13:41:35 <Ptival> I didn't read the paper though
13:41:58 <Ptival> just wondered whether some unification of the type classes and modules was still being studied or not
13:42:34 <jonafan> Well, you can do almost the same things with ocaml modules.
13:42:41 <Ptival> it seems that in Coq we have somehow the two things, but I did not really look at Coq type classes yet...
13:44:32 <nyingen> in hsc2hs, is it possible to define some C helper functions in the hsc file? I thought I had seen this done, but I can't quite figure it out
13:45:43 <Ptival> well, seems that in Coq type classes are first-class with the help of dependent types so it's not the same problem
13:46:31 <erus`>   maybe haskell needs dependent types :)
13:46:38 <jonafan> i haven't looked into it much, but ocaml's modules are first class now.
13:49:10 <ski> jonafan : well, SML has (very) ad-hoc overloading for those, but you can't make such overloading yourself -- choose your poison ..
13:50:11 <ski> jonafan : hm, you can reflect a signature / module type into a corresponding value type ?
13:50:28 <jonafan> I'm not sure.
13:50:30 <ski> (btw, "those" referring to `+',`+.',&c.)
13:51:50 <ski> Alice ML has <http://www.ps.uni-saarland.de/alice/manual/tour.html#packages>, which allows packing a structure/module into a value, but you always get the same type, so it's dynamic typing there (checked at unpack time)
13:53:10 <jonafan> Ocaml got the first class modules in 3.12 which isn't in ubuntu's repos or available as a binary download on inria.fr
13:53:35 <jonafan> So I haven't really messed with it.
13:53:49 <companion_cube> strange, it's the default version on archlinux
13:54:02 <jonafan> Yeah, but that's arch.
13:54:04 <erus`> so anyone got any ideas for alternatives to overloading a base-entity class to store a list of game objects in a level?
13:54:23 <companion_cube> jonafan: yes, but they must have found the source somewhere
13:54:53 <jonafan> Yeah, but that's too much work for me
13:54:56 * ski looks at <http://caml.inria.fr/pub/docs/manual-ocaml/manual021.html#toc81>
13:55:25 <jonafan> I guess it might be in Ubuntu by now, I'm still on 10.04.
13:55:39 <ski> ok, nice, it apparently is statically typed
13:55:48 <Ptival> jonafan: http://caml.inria.fr/ocaml/release.en.html what more do you need? :)
13:56:19 <jonafan> Precompiled binaries.
13:56:59 <Ptival> for Ubuntu?
13:57:29 <jonafan> Either that or Windows.
13:58:18 <Ptival> oh right, the Windows ones are 3.11
13:58:23 <jonafan> I'm just not that desperate to try it
13:59:56 <Ptival> oh but Jonathan made a Windows installer recently
14:00:31 <Ptival> jonafan: yep, there http://gallium.inria.fr/~protzenk/caml-installer.html
14:01:20 <Ptival> 3.12.1
14:02:08 <jonafan> Ah cool
14:02:46 * jonafan wonders what 3.13 is
14:09:45 <tromp> > 908/1269
14:09:46 <lambdabot>   0.7155240346729709
14:14:15 <DukeDave> I don't know if anyone who was involved previously is around, but I'm about to re-commence trying to wrap wxAny
14:14:31 <DukeDave> All FFI heads are welcome to join in :)
14:15:55 <DukeDave> Here it is: http://hpaste.org/51854
14:25:18 <nyingen> why was -via-c removed?
14:26:23 <byorgey> nyingen: IIUC, it was removed in favor of the native code generator
14:26:33 <byorgey> and probably because no one wanted to maintain it.
14:35:26 <antgeth> does anyone have any like, prewritten code for concatenating two lists of lists
14:35:40 <antgeth> i.e. it would output a list of lists
14:35:49 <hpc> how would it concatenate them?
14:36:33 <antgeth> it would take the sublists from the first superlist, and concatenate them with the sublists from the second superlist
14:36:59 <hpc> so [xs, ys] [as, bs] would become [xs++as, ys++bs]?
14:37:25 <hpc> > zipWith (++) ["string ", "character list "] ["one", "two"]
14:37:26 <lambdabot>   ["string one","character list two"]
14:37:50 <hpc> :t zipWith (++)
14:37:50 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
14:38:07 <hpc> (ignore the Monoid context, that's caleskell talking)
14:38:37 <Philippa> I should double check it by running some test code through ghc, but I've just had a rather pleasant realisation...
14:38:43 <antgeth> it would be something like [xs, ys] [as, bs] becoming [xs, as] [xs, bs] [ys, as] [ys, bs]
14:38:53 <antgeth> er
14:38:54 <antgeth> sorry
14:38:55 <antgeth> wait
14:39:01 <Philippa> the signatures for Control.Applicative and Control.Arrow actually play pretty well together once you give yourself permission not to use returnA, don't they?
14:39:19 <antgeth>  [xs, ys] [as, bs] would become [xs++as] [xs++bs] [ys++as] [ys++bs]
14:39:31 <ski> @type zipWith (Prelude.++)
14:39:32 <lambdabot> forall a. [[a]] -> [[a]] -> [[a]]
14:39:52 <zygoloid> antgeth: looks like liftM (++)
14:39:57 <ski> > liftM2 (++) ["string ", "character list "] ["one", "two"]
14:39:58 <lambdabot>   ["string one","string two","character list one","character list two"]
14:40:26 <ski> > do xs <- ["string ", "character list "]; ys <- ["one", "two"]; return (xs ++ ys)
14:40:28 <lambdabot>   ["string one","string two","character list one","character list two"]
14:40:43 <ski> > [xs ++ ys | xs <- ["string ", "character list "] , ys <- ["one", "two"]]
14:40:45 <lambdabot>   ["string one","string two","character list one","character list two"]
14:40:55 <ski> antgeth : that's a few ways ^
14:41:28 <ski> @type Control.Arrow.returnA
14:41:29 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
14:41:41 <ski> Philippa : elaboration of what you mean ?
14:42:55 <Philippa> returnA... squicks me. Or rather, the need for arrows that're just points using ()
14:43:16 <Philippa> pure is much nicer in that regard: I want to write most of my code thinking of it from that side of things
14:43:18 <Philippa> *but*
14:44:16 <Philippa> if you've got an Applicative, finding a type and implementation for arr is trivial - the only question's whether you can usefully write first or one of its relatives. The corresponding arrow type is just that of functions inside the applicative
14:44:16 * ski usually things `pure' is less nicer :/
14:44:25 <Saizan> you mean used like: pure :: (Arrow (~>), Applicative ((~>) b)) => a -> b ~> a ?
14:44:26 <ski> s/things/thinks/
14:45:29 <Philippa> Saizan: nope, other direction. I had something that I was comfortable thinking of as an applicative, but realised I needed Arrow's fan-out operation for it
14:46:22 <Saizan> ah so you've Applicative f and Arrow (Kleisli f) ?
14:46:48 <Philippa> effectively, yeah
14:47:08 <Philippa> and I'm still free to interleave the styles and use the syntactic sugar for arrows
14:48:09 <Philippa> now I know this, most of the applicatives I've been writing should also get arrow instances
14:48:45 <Saizan> i was still at forall a. Applicative (ar a) + Category ar = Arrow ar :)
14:49:43 <Saizan> i guess we have Applicative f => Applicative (Kleisli f a) since it's just a reworked ReaderT
14:50:23 <Philippa> oh, I'm not offering something truly general
14:51:00 <Philippa> just putting some connections in place for my own future reference (I'll be implementing arr in terms of pure, won't be using an analogue of Kliesli directly)
14:51:45 * ski realizes Philippa maybe meant `Control.Applicative.pure', instead of `Control.Arrow.pure' ..
14:51:55 <Philippa> yeah
14:51:57 <Saizan> Philippa: to be clear, which is Arrow's fan-out operation? (&&&)?
14:52:07 <Philippa> yep
14:52:35 <Philippa> in my original use-case I also then discard half the result pair, but that's just happenstance
14:53:09 <Philippa> (the original usecase involves a gensym operator and another effect I want to feed those symbols into /while also returning them/)
14:53:35 <ski> "functions inside the applicative" being `i (a -> b)' ? (`Arrow (Kleisli f)' seemed to suggest `a -> i b')
14:53:48 <Philippa> ski: the former, yeah
14:53:54 <Saizan> that's also liftA2 (,) for ReaderT a f btw
14:54:14 <Saizan> oh, i (a -> b)
14:54:21 * ski replaces Saizan's `+' with a conjunction
14:55:32 * ski tries to picture "a gensym operator and another effect I want to feed those symbols into /while also returning them/"
14:57:19 <Saizan> ?type liftA2 (&&&)
14:57:20 <lambdabot> forall (a :: * -> * -> *) b c c' (f :: * -> *). (Arrow a, Applicative f) => f (a b c) -> f (a b c') -> f (a b (c, c'))
14:57:39 <Saizan> Philippa: is the arrow notation really a win?
14:59:41 <Philippa> Saizan: Yeah. I can't write code that's high-level in the perlis sense without it or something similar because point-free style loses the names of things that were in the problem-domain version of the spec
15:01:12 <Saizan> maybe this arrow instance should be somewhere in the stdlibs
15:03:33 <Philippa> I'm not sure I've /got/ a general one unless Arrow's weak enough to include what Wadler et al call "static arrows"
15:05:28 * ski for some reason first thought "loses the names of things" referred to losing names for the arrows themselves, somehow
15:05:58 <ski> Philippa : yeah, `arr' should be in a sub-class
15:06:37 <Cale> The real problem isn't so much the presence of arr as it is the extent to which arr is required because some other things are missing.
15:07:14 <Saizan> but arr is easy here: arr = pure id
15:07:47 <Saizan> http://hackage.haskell.org/packages/archive/arrows/0.4.2.0/doc/html/src/Control-Arrow-Transformer-Static.html#StaticArrow <- it seems it's already there anyway
15:08:19 <Saizan> (didn't know the name!)
15:08:21 <Cale> (I'm pretty sure I've mentioned this before, but I don't know who was here at the time.) At iPwn we have a class ArrowPair (~>) where fst :: (a,b) ~> a; snd (a,b) ~> b; swap :: (a,b) ~> (b,a); lassoc :: (a,(b,c)) ~> ((a,b),c); rassoc :: ((a,b),c) ~> (a,(b,c))
15:08:30 <Cale> and a preprocessor which takes advantage of that
15:09:10 <Cale> in order to reduce the number of occurrences of arr to just the case where you pattern match on something other than nested pairs in the arrow syntax
15:09:11 <Saizan> yep, that seems much more useful if you want to do a data-flow analysis
15:10:09 <Cale> It gave us something along the lines of an order of magnitude speedup :)
15:11:36 <Cale> I also really think that Arrow should demand that (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
15:11:49 <Cale> and to hell with the Kleisli instance
15:12:23 <Saizan> to hell with any arrow involving IO too?:)
15:12:46 <geheimdienst> :t (&&&)
15:12:47 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:12:52 <Cale> Well, any arrow involving IO which doesn't satisfy that law.
15:13:33 <Cale> You could probably devise an arrow based on IO which used concurrency to morally satisfy that law.
15:13:33 <geheimdienst> so it always gives a tuple (c, c'), right? no way to get, say, a list out of it
15:13:43 <Cale> geheimdienst: there's arr
15:13:54 <mm_freak> Saizan: no, i use arrows, which have an IO internally
15:14:12 <Saizan> mm_freak: i believe you're missing context
15:14:26 <Cale> It kinda means that only local state is allowed.
15:14:49 <mm_freak> Saizan: i'm not…  i'm not totally sure, but i think my arrow obey's Cale's law =)
15:15:20 <mm_freak> if not, it would be easy to change
15:15:31 <antilect> Chalmers people here? :)
15:15:46 <antilect> (the university)
15:15:59 <Saizan> unless your use of IO is very controlled it won't be easy to make that law hold
15:16:20 <mm_freak> Cale: i'd love to see that ArrowPair class and its preprocessor online
15:16:31 <Cale> Well, it means that the arrow diagrams that people draw actually make sense to draw.
15:16:35 <mm_freak> Saizan: ok, it might not play well with concurrency
15:16:49 <Saizan> it doesn't play well with putStrLn.
15:17:06 <Cale> In that, if you have a couple of boxes which are on different wires, you can move the boxes past each other.
15:17:08 <geheimdienst> cale: i've never used arr, but looked at the haddock. so you'd write an Arrow instance with an arr that produces the list?
15:17:15 <geheimdienst> how would such an arr look?
15:17:23 <Cale> geheimdienst: I'm not sure, what are you after?
15:17:37 <Cale> (can you write the type of the thing you want?)
15:18:06 <mm_freak> geheimdienst: i think, we're secretly referring to FRP
15:18:06 <geheimdienst> i was wondering if you could coax (&&&) to give something other than a tuple. let's say a list
15:18:12 <geheimdienst> > (succ &&& pred) 42
15:18:13 <lambdabot>   (43,41)
15:18:22 <Cale> uh, well, no
15:18:28 <Cale> :t (&&&)
15:18:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:18:37 <mm_freak> geheimdienst: in specific cases, but in general, no
15:18:41 <Cale> ^^ its type involves a pair, so it's always giving you a pair
15:18:54 <Cale> But you can combine it with other stuff that uses other types
15:18:56 <geheimdienst> oh i see :) then i had it right. my understanding was that it's locked to tuples
15:19:01 <geheimdienst> thanks a lot :)
15:19:09 <mm_freak> > (\(x,y) -> [x,y]) ^<< (succ &&& pred) $ 42
15:19:10 <lambdabot>   [43,41]
15:19:48 <Saizan> (&&&) is what stack-based languages call dup
15:19:57 <ion> > (\(x,y) -> [x,y]) . (succ &&& pred) $ 42
15:19:59 <lambdabot>   [43,41]
15:20:14 <mm_freak> ion: that one is function arrow-specific
15:20:47 <ddarius_> Saizan: id &&& id would be, but even then I would take care in trying to make that metaphor.
15:20:52 <Saizan> in lambdabot it's just "your arrow is also a Functor" specific
15:21:17 <mm_freak> :t (.) (\(x,y) -> [x,y])
15:21:18 <lambdabot> forall t (f :: * -> *). (Functor f) => f (t, t) -> f [t]
15:21:25 <mm_freak> :t (^<<) (\(x,y) -> [x,y])
15:21:26 <lambdabot> forall t (a :: * -> * -> *) b. (Arrow a) => a b (t, t) -> a b [t]
15:21:56 <siracusa> If you explicitly state the functions you import from a module, will that make the resulting binaries smaller (or have any other positive effect on the binary)?
15:22:39 <ddarius_> No.
15:22:40 <mm_freak> siracusa: unlikely
15:22:59 <siracusa> So it's just for readability?
15:23:05 <ddarius> No.
15:23:06 <mm_freak> sometimes
15:24:05 <mm_freak> explicitly hiding is probably better than explicitly importing
15:24:18 <ddarius> I disagree.
15:26:29 <hpc> ideal is a qualified import of everything, then an unqualified import of the important stuff, like types
15:28:01 <siracusa> So are there additional reasons other than avoiding name clashes?
15:50:03 <ski> Cale : can you express `(a ~> b0) -> (a ~> b1) -> (a ~> (b0,b1))' then ?
15:50:04 <ski> Cale,Saizan,mm_freak : yeah, a premonoidal structure would help with the `Kleisli m' case
15:50:52 <Cale> ski: Arrow is a superclass of ArrowPair
15:50:57 <Cale> ski: if that's what you mean :)
15:51:04 <dobblego> where is ArrowPair defined?
15:51:06 <Cale> (I might have left that out)
15:51:15 <Cale> dobblego: IPwn.FRP ;)
15:51:17 <ski> oh, i thought `ArrowPair' didn't have any superclasses
15:51:38 <dobblego> Cale: internally you mean?
15:54:24 <Cale> dobblego: yeah
15:54:40 <Cale> dobblego: Though it's something that I think we may try to make more standard.
15:54:59 <Cale> It's pretty nicely inspired by braided or symmetric monoidal categories
15:56:03 <Cale> and it really helps make arrows more practical to use for the cases that people using arrows in the first place seem to be interested in
15:56:31 * ski wonders whether Cale has any braided, non-symmetric, case in mind
15:56:45 <Cale> ski: well, not at the moment :)
15:56:53 <djahandarie> I haven't really felt the need for premonoidal categories before
15:57:03 <ski> Cale : it's a noble goal, regardless :)
15:58:01 <Cale> ski: Well -- the symmetry might not be operationally equivalent to arr (\(x,y) -> (y,x))
15:58:07 <ski> djahandarie : they would be a cure to the `swap >>> (f *** g)' non-equal to `(g *** f) >>> swap' nonsense
15:58:31 <Cale> (in our case, it isn't)
15:59:11 <ski> Cale : well, in this case i'm not really interested in `arr' :)
16:00:00 <djahandarie> Though, I do like that a strict premonoidal category is the obvious generalization from a strict monoidal category by relaxing the cartesian constraint
16:00:28 <ski> (but if you'd say the "symmetry" squared, might not be equivalent to `returnA', then i'd think it more relevant)
16:00:52 <djahandarie> I imagine you could do it for premonoidal categories too if you move to a symmetric monoidal 2-category
16:00:57 <ddarius> djahandarie: A monoidal category is that too.  Premonoidal (obviously) goes further.
16:01:33 <ski> monoidal doesn't refer to cartesianness at all, as ddarius notes
16:02:10 <djahandarie> ddarius, I mean the definition of a strict monoidal category as a monoid in the cartesian monoidal category Cat.
16:02:20 <Cale> One thing that kinda pisses me off is that in the current library, despite Arrow being a subclass of Category, returnA is defined as arr id rather than Control.Category.id
16:03:04 <Cale> Which means that we have to explicitly avoid it and use id instead, which is okay, but it's sort of a weird gotcha.
16:03:25 <ski> Cale : i'd consider that a bug
16:04:36 * ski wonders whether the `Arrow' `do' syntax expands to `returnA'
16:04:42 <benmachine> I thought arr id = id was a law
16:04:47 <benmachine> or wait
16:04:49 <benmachine> yes
16:04:51 <benmachine> that
16:05:05 <Cale> benmachine: sure, semantically ;)
16:05:16 <benmachine> Cale: isn't it a bit like liftA?
16:05:21 <benmachine> etc.
16:05:43 <ski> benmachine : the point being that you can often statically analyze `id :: Category ar => ar a a' better than `arr id'
16:05:51 <benmachine> ski: oh, I see
16:05:57 <Cale> benmachine: But it means that instead of being able to optimise away that bit, our library is faced with a black box that it can't really tell is an identity function
16:06:24 <ski> if you get `Arr f', `f' could be any opaque function, but if you have an `Id', then you know it is that
16:07:03 <benmachine> so you don't have arr id = id, except you hide any way of telling the difference
16:07:15 * ski is reminded about rings where you can decide whether an element is the (multiplicative) identity
16:07:21 <Cale> and when you have a bunch of machinery that's keeping track of which computations are subscribed to what, extra stuff like that can add up
16:08:07 <Cale> benmachine: Well, it's hidden by a module boundary, so the law holds externally still :)
16:08:37 <ski> (.. and also about ways of improving an `F' so that it is a functor .. you can do `CoYoneda F', but then you can't recognize the `FMapLift id foo' case)
16:10:40 * ski likes how Mercury (<http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html>) makes a clear distinction between equality of a representation type, and equality of the abstract type
16:12:29 <accel> is there a way to keep a ghc session active (like java's nailgun); so to run a *.hs script, it gets sent to the existing session, gets executed, then sends output back to me, w/o loading a ghc session through the process?
16:13:23 * hackagebot git-annex 3.20110928 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110928 (JoeyHess)
16:15:17 <ozataman> has anybody every gotten around the problem with TemplateHaskell enabled cabal projects not finding some C++ FFI libraries during compilation?
16:16:00 <Enigmagic> ozataman: there is a trac ticket for it
16:16:15 <ozataman> Enigmagic: ah, I didn't realize. are there any manual workarounds for now?
16:17:54 <Enigmagic> ozataman: depends on the problem you're having. the most reliable way is not to use C++ FFI from template haskell
16:18:04 <Enigmagic> ozataman: (which sucks)
16:18:12 <ozataman> Enigmagic: yeah and tough to get around in my case
16:18:28 <Enigmagic> Conal has a patch on the ticket to add support for hidden symbols
16:18:41 <Enigmagic> i haven't tested it but it looks like it would fix the problem I was having
16:20:28 <ozataman> also, TH seems to load *all* dependencies, including non-direct dependencies acquired through direct dependencies. is there a way to stop that from happening? when I use ghc --make instead of cabal install, I don't run into this TH problem
16:20:41 <ozataman> cabal install just pulls everything in
16:21:34 <Enigmagic> ozataman: http://hackage.haskell.org/trac/ghc/ticket/5197
16:21:52 <Cale> blackh writes entertaining comments :)
16:22:00 <Cale> -- | The CreateQuadrant contains the seeds of its own destruction.
16:22:00 <Cale> fromCreateQuadrant :: CreateQuadrant -> DestroyQuadrant
16:22:16 <dobblego> anyone ported tagsoup to scala? :)
16:22:24 <Enigmagic> ozataman: and no, i don't think so. i had to split my package to avoid that..
16:28:06 <Dashkal> Is there a term for the function passed into foldl?
16:29:44 <mm_freak> Dashkal: folding function, reduction function or in the case of foldl/foldl' even simply the iteration function…  i don't think there is an official name
16:30:32 <Dashkal> mmm, k
16:31:26 <Cale> combining function?
16:33:51 <Dashkal> I ended up using "handler" for lack of another term.  Writing a multi-fold for walking over a typed graph
16:34:13 <Dashkal> So instead of one of those, you get one per type of node or edge
16:34:42 <Dashkal> a few of these: (a, ?) -> (a, Bool)
16:38:39 <Saizan> together they form an algebra..
16:47:34 <shakakai> hey all, does anyone know if there's a dedicated haskell job board?
16:52:58 <Cale> shakakai: well, haskellers.com is useful to find people if you're hiring
16:53:00 <accel> where can i dlwonlaod lazylast?
16:53:02 <accel> wrong channel
16:53:22 <shakakai> Cale: awesome, I am...thx
16:53:32 <Cale> oh, it also has listings
16:53:41 <Cale> I hadn't noticed that before :)
16:55:21 <shakakai> it lists Bryan O'Sullivan as interested in FT positions...not sure how accurate the info is :P
17:00:23 <Tordek> hi
17:00:51 <Tordek> I'm trying to use parsec to make a tnetstring parser, but I ran into an obstacle
17:02:01 <Tordek> thing is, the format of a tnetstring is "<length> ":" <contents> <type>", so I must read the contents before the type; since one possibility is that it contains a list, I must "re-parse" contents
17:02:07 <Tordek> how do I do that?
17:03:42 <Jafet> Who invented this format
17:03:48 <Tordek> zed shaw
17:04:01 * Jafet writes that down, somewhere
17:04:05 <Tordek> murder list?
17:04:13 <Jafet> Murder is too painless.
17:04:18 <Tordek> haha
17:04:39 <Jafet> Anyway, I think you can, in monadic style
17:05:42 <Jafet> do x <- parseContents; t <- parseType; x' <- case t of ListType -> parseList x; OtherType -> parseOther x
17:05:49 <Tordek> (I mean, I think I can do 'choice', but that seems terribly inefficient)
17:06:48 <Jafet> Perhaps he intended you to skip <length> elements and parse <type> first.
17:07:50 <Tordek> his reasoning was "you'll still need to read all the data before parsing it; and if you're skipping it, having the length separator be always the same will be a tad more efficient"
17:09:02 <Jafet> If parseOther is id, then choice is probably less efficient
17:09:21 <madhat> why doesn't filter not Char.isSpace "test test test" work?
17:09:39 <Jafet> How do you expect it to work?
17:10:02 <Tordek> filter (not . Char.isSpace)
17:10:05 <Jafet> @pl \c -> not (Char.isSpace c)
17:10:05 <lambdabot> not . Char.isSpace
17:10:16 <Jafet> @pl \s -> filter (\c -> not (Char.isSpace c)) s
17:10:16 <lambdabot> filter (not . Char.isSpace)
17:10:27 <madhat> what is that called?
17:10:38 <Tordek> function composition
17:10:46 <Jafet> What is what called?
17:10:48 <madhat> thanks, i'll read about that
17:10:59 <byorgey> madhat: filter not Char.isSpace "test test test" passes "not" as the first argument to filter, and therefore expects Char.isSpace, the second argument to filter, to be a list
17:11:28 <byorgey> madhat: you need to add parentheses and also a composition operator, as others have pointed out
17:13:47 <madhat> byorgey: thanks, i now see why it didn't work :P
17:15:09 <cads> Is there a library for mathematical modules in haskell?
17:16:10 <cads> I mean modules of the kind we see in math, which are similar to vector spaces, except scalars come from a ring rather than a field
17:17:09 <cads> Specifically, free modules and direct sum modules, as well as rings in general
17:20:12 <cads> This is a diagram showing some of the different types and the hierarchy they fall in: http://books.google.com/books?id=HH4mVt--UsYC&lpg=PA238&dq=rubato%20composer&pg=PA90#v=onepage&q&f=false
17:21:01 <cads> This is from a music theory program implemented in Java
17:21:12 <Tordek> Jafet: if you don't mind looking at this; I'm not making sense of it. http://pastebin.com/jrhS2Q23
17:21:15 <mauke> The paste jrhS2Q23 has been copied to http://hpaste.org/51886
17:22:17 <cads> from what I understand, it uses the category of modules to great effect in modeling the concepts and patterns in music.
17:23:14 <cads> It's based on a data format called 'denotators', which in turn are based on set-valued presheaves over the category of modules and diaffine homomorphisms.
17:24:26 <byorgey> cads: perhaps in the 'algebra' package?
17:24:43 <byorgey> Numeric.Module.Class
17:25:19 <mkscrg> how does one use functions of two arguments in point-free style? say i want to negate the sum of two numbers. foo = (*(-1)) . (+) doesn't do the job
17:25:20 <btutt> Ugh. mc03 on 32bit with -O2 -fasm runs out of memory.
17:26:08 <cads> byorgey: Wow, there's a whole treasure trove here
17:26:21 <cads> byorgey: thanks!
17:26:50 <MichaelBurge> @pl (*(-1)) . (+)
17:26:50 <lambdabot> (-1 *) . (+)
17:29:50 <mkscrg> @pl (\x y -> (x + y) * (-1))
17:29:50 <lambdabot> flip flip -1 . ((*) .) . (+)
17:30:05 <narain> @pl \x y -> -(x + y)
17:30:05 <lambdabot> (line 1, column 9):
17:30:05 <lambdabot> unexpected "-"
17:30:05 <lambdabot> expecting lambda abstraction or expression
17:30:36 <byorgey> cads: its author, edwardk, also hangs out in here a lot, and would probably be delighted to discuss set-valued presheaves over the category of modules and diaffine homomorphisms.
17:32:46 <cads> hah, I bet!
17:34:42 <cads> thanks for helping me make that connection, byorgey!
17:38:11 <cads> goodnight all
17:38:40 * DanBurton is trying to learn arrows; brain might explode
17:41:51 <kmc> arrows are a let-down
17:42:51 <DanBurton> oh?
17:43:37 <DanBurton> kmc: why do you say that?
17:44:54 <kmc> not very many types support a useful Arrow instance
17:50:21 <xplat> arrows should really be called promonads
17:54:18 <kmc> is there an equivalent to the GHC IO manager in an implementation of any other language?
17:54:31 <xplat> because they are essentially strong monads built out of endoprofunctors instead of endofunctors
17:55:00 <xplat> kmc: depends what you mean by equivalent
17:55:01 <kmc> it seems like a good idea which should be widespread, but I'm having trouble coming up with examples
17:55:12 <kmc> does Oracle JVM do this?
17:55:50 <xplat> kmc: i know old JVMs did, but i think they abandoned it along the way
17:55:52 <kmc> xplat, i mean supporting a programming model where you do blocking IO on many threads, but this is rephrased using event-based IO before it hits the OS
17:55:54 <kmc> interesting
17:55:56 <kmc> do you know why?
17:56:59 <xplat> not really.  this was still in the 1990s
17:57:45 <xplat> erlang does it
17:57:47 <kmc> is there a good search term for this stuff?
17:58:39 <xplat> threads that are not mapped 1-1 to OS threads are generally called 'green threads', although there are other terms for them like 'fibers'
17:59:14 <kmc> yeah
17:59:22 <kmc> i'm wondering about the "IO manager" aspect
17:59:30 <xplat> it's not uncommon for green-thread runtimes to make an effort to multiplex IO while presenting a blocking interface to the individual threads, but the level of success varies wildly
17:59:51 <kmc> would you say GHC is one of the more successful examples?
18:01:00 <xplat> it seems to be, if only because it can fall back to using threads when it can't help blocking
18:02:22 <xplat> a lot of these efforts can't keep the semantics of green threads and os threads close enough to do that transparently, and so they block large parts of the process for things like disk reads
18:03:07 <xplat> or else they depend completely on OS-dependent async IO to do that and are very limited in portability
18:03:35 <kmc> yeah
18:05:05 <xplat> and even with IO, if you can't reschedule green threads to different os threads you can just forget it when you start swapping
18:05:13 <xplat> *even with async IO
18:05:38 <xplat> or using mmapped IO
18:06:38 <xplat> there's no sane way to redirect that stuff through an event interface, and though there are insane ways i don't think anyone has made a practical library based on them
18:19:16 <kmc> what are the insane ways?
18:21:04 <xplat> abusing memory protection to get signals delivered and swapping the stuff in yourself by using async io and stack manipulation from the signal handlers
18:22:03 <xplat> the only remotely practical thing i heard of being made with these techniques is the texas persistent store, and even that's a stretch
18:23:28 <xplat> the first part of the technique (signal handlers) is regularly used to implement write barriers for garbage collectors, though
18:24:08 <napping> I hear azul's JVM does tons of page table stuff
18:24:08 <xplat> and implementing VM in userspace is a common technique on mach where the fault handling architecture was designed for it
18:24:41 <xplat> it's just really awkward to do in unix and i don't know if it even translates to windows
18:25:06 <xplat> napping: ah, does it?  that's interesting, and the kind of place i'd expect to find it
18:25:18 <napping> http://msdn.microsoft.com/en-us/library/windows/desktop/aa366887%28v=vs.85%29.aspx
18:25:31 <napping> VirtualAlloc and friends let you do similar things on windows
18:36:55 <cwl> @src setHeaders
18:36:56 <lambdabot> Source not found. It can only be attributed to human error.
18:37:28 <napping> http://www.haskell.org/hoogle/?hoogle=setHeaders
18:38:35 <cwl> napping: I cannot find any instance implement it
18:40:10 <napping> instances are listed right under the method - Response a and Request a
19:04:00 <dsantiago> Does pattern matching create new objects on the heap?
19:04:16 <napping> no
19:04:29 <napping> maybe with enough extensions
19:04:40 <zardoz8> hello, how to convert integer to char?  0 -> '0'
19:04:41 <dsantiago> Does it create extra code, or does the compiler do that statically?
19:04:59 <napping> extra code?
19:05:11 <dsantiago> To unpack the object inside?
19:05:30 <kmc> dsantiago, a pattern-match will create new code
19:06:03 <kmc> zardoz8, i like your nick :)
19:06:10 <Nafai> zardoz8: show should do it
19:06:18 <Nafai> > show 5
19:06:19 <lambdabot>   "5"
19:06:23 <shachaf> With e.g. view patterns it certainly can.
19:06:25 <mauke> Nafai: that's not a char
19:06:28 <kmc> :t intToDigit
19:06:29 <lambdabot> Int -> Char
19:06:30 <Nafai> Ah
19:06:33 <Nafai> char, Whoops :)
19:06:34 <kmc> > intToDigit 0
19:06:35 <lambdabot>   '0'
19:06:40 <Nafai> bad Nafai
19:06:53 <Nafai> don't answer #haskell questions on an empty stomach
19:07:15 <zardoz8> thanks everyone. I googled up intToDigit  but couldn't use it so I thought it was a third party library. all fine now
19:07:18 <kmc> well (head . show) would work, but is a bit unsavory
19:07:22 <kmc> @hoogle intToDigit
19:07:23 <lambdabot> Data.Char intToDigit :: Int -> Char
19:07:23 <napping> ooh, fancy. I was thinking chr/ord.
19:07:29 <kmc> zardoz8, you'll have to import Data.Char
19:07:32 <napping> (also from Data.Char)
19:09:23 <zardoz8> yes
19:10:28 <zardoz8> I'm trying to write int2bin function, I'm obviously getting digits in wrong order. how to elegantly handle this?   int2bin 0 = []    int2bin n = intToDigit (mod n 2) : int2bin (div n 2)
19:11:13 <antgeth> haha zardoz is the most bizarre film
19:13:31 <mauke> > let int2bin n = (if n `div` 2 > 0 then int2bin (n `div` 2) else "") ++ intToDigit (n `mod` 2) in map int2bin [0, 1, 5, 11]
19:13:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:13:33 <lambdabot>         against inferred ty...
19:13:44 <mauke> > let int2bin n = (if n `div` 2 > 0 then int2bin (n `div` 2) else "") ++ [intToDigit (n `mod` 2)] in map int2bin [0, 1, 5, 11]
19:13:45 <lambdabot>   ["0","1","101","1011"]
19:14:31 <donri> can list comprehension syntax be used with any MonadPlus instance or does that question not even make sense?
19:14:52 <shachaf> donri: It can with GHC extensions.
19:14:55 <shachaf> Or in Haskell 1.4.
19:15:12 <shachaf> In Haskell 1.4 MonadPlus was actually separate from MonadZero. Those were the days, man...
19:16:11 <donri> wait, what haskell am I "on"? ghc 7.0.3
19:16:53 <Kaidelong> donri: It certainly could be, probably should be, and yes, extensions
19:17:25 <kmc> donri, GHC 7 implements Haskell 2010 by default
19:17:38 <kmc> or maybe something very close to H10
19:17:46 <kmc> you can pass -XHaskell98 if you want H98
19:17:53 <kmc> it does not support older version
19:17:58 <donri> so, what is "1.4" relative to haskell 98/2010
19:18:01 <kmc> older
19:18:05 <kmc> before 98
19:18:08 <shachaf> > compare 1.4 98
19:18:09 <lambdabot>   LT
19:18:12 <donri> ;)
19:18:16 <shachaf> 1.4 is from the good old days.
19:18:23 <shachaf> Back when everything was wonderful.
19:18:37 <donri> sarcasm?
19:18:45 <shachaf> Only slightly.
19:18:48 <donri> did the language actually get worse? :)
19:18:50 <shachaf> Haskell 1.4 was much nicer than Haskell 98.
19:18:54 <shachaf> It actually did.
19:18:56 <roconnor> donri: mostly worse
19:18:56 <kmc> did 1.4 have monomorphism restriction?
19:19:08 <kmc> shachaf, hipster
19:19:19 <shachaf> kmc: It did.
19:19:39 <Cale> 1.4 totally is the Hipster Haskell
19:19:48 <shachaf> kmc: I like how you can read that as a geheimdienst comma.
19:20:03 <donri> so did anything improve on the other hand?
19:20:07 <donri> ^_^
19:20:20 <Cale> class  (Monad m) => MonadZero m  where
19:20:21 <Cale>     zero             :: m a
19:20:21 <Cale> class  (MonadZero m) => MonadPlus m  where
19:20:21 <Cale>     (++)             :: m a -> m a -> m a
19:20:24 <Cale> awww yeah
19:20:38 <kmc> donri, H98 has the FFI (by addendum) and H10 has it built in
19:20:40 <Cale> concat           :: MonadPlus m => [m a] -> m a
19:20:40 <Cale> concat           =  foldr (++) zero
19:20:44 <kmc> H10 has qualified module names
19:20:47 <shachaf> I like how the HTML for the Haskell 1.4 report says "Haskell 1.3".
19:20:50 <thoughtpolice_> kmc: ghc supports all of h10.
19:20:52 <donri> and here i thought haskell alone was hipsterism
19:20:59 <Kaidelong> interestingly in F# computation expressions, apparently {x; y} is x `mplus` y rather than x >> y
19:21:09 <kmc> donri, hipsterism is recursive
19:21:17 <slack1256> yo dawg we put hipsterism on your hipsterism
19:21:18 <Oxfaded> im trying to finaly get my head around monads. There seems to me there should be a way to remove the middle Just but I cant work it out. Just 1 >>= \a-> Just (a+1) >>= \a -> return (a+1)
19:21:37 <Cale> class  Functor f  where
19:21:37 <Cale>     map              :: (a -> b) -> f a -> f b
19:21:49 <donri> I was a hipster before it was a hipsterism.
19:21:59 <mauke> Oxfaded: you can remove all of them with Just 3
19:22:08 <slack1256> yeah and i used lisp with M-expressions
19:22:18 <Oxfaded> mauke: I cant believe I didnt see it before
19:22:23 <Kaidelong> Cale: why (++) for MonadPlus rather than for Semigroup
19:23:09 <Cale> Kaidelong: Well, actually, I think I'd rather take ++ for Monoid than MonadPlus, but specialising to list is worse than either of those.
19:23:19 <donri> Oxfaded: in Maybe, Just and return are the same thing
19:23:19 <shachaf> Cale: No, (++) for Semigroup!
19:23:35 <Kaidelong> what shachaf said
19:23:54 <Cale> Every semigroup is easily enough made into a monoid...
19:23:54 <Kaidelong> I have run into a semigroup at least once in practice
19:24:11 <Kaidelong> Cale: what's the zero elements for routes?
19:24:19 <Cale> routes?
19:24:22 <Kaidelong> s/elements/element/g
19:24:28 <Kaidelong> routes from point a to point b
19:24:30 <Kaidelong> on a road map
19:24:42 <Oxfaded> donri: im aware of that, im finally seeing monads as a type class instead of magic. But is wrapping each step of execution in Just really neccessary or is there some trick im missing?
19:24:44 <Cale> The stationary path from a to itself
19:24:56 <Kaidelong> Cale: what's a
19:24:56 <shachaf> instance Semigroup a => Monoid (Maybe a) ?
19:25:02 <Cale> But that's not a monoid, if it's routes from point a to point b
19:25:09 <Cale> It's a category
19:25:24 <Cale> (or a groupoid)
19:25:32 <donri> Oxfaded: maybe you want functor or applicative
19:25:41 <Kaidelong> if I want to do my routing logic at compile time, at a type level, I guess I could do that
19:25:45 <Cale> Because you can't just concatenate any two routes.
19:25:47 <Kaidelong> for my purposes it was a semigroup
19:25:49 <shachaf> Oxfaded: I think you're confused about something. What are you trying to do?
19:25:52 <Cale> if they don't line up
19:25:55 <Kaidelong> yes you can. The graph is connected
19:25:59 <Cale> ???
19:26:02 <Kaidelong> you can always find an inbetween route
19:26:12 <Cale> Canonically?
19:26:23 <Kaidelong> I don't think you'll find many city road maps where that is not true
19:26:34 <slack1256> good god, if i read "ttfp" will i understand when something is a category , a monoid or a semigroup?
19:26:36 <Cale> There might be more than one connecting route
19:26:37 <napping> A canonical route between two cities?
19:26:42 <Cale> How do you choose?
19:26:49 <napping> Our beautiful national highway tree...
19:26:51 <donri> > Just 1 >>= return . (+1) >>= return . (+1)
19:26:52 <lambdabot>   Just 3
19:26:57 <Kaidelong> you choose some way and then that becomes your (++)
19:26:59 <Cale> napping: haha
19:27:17 <Kaidelong> the way it was implemented for me is that I fetched it off of the internet
19:27:20 <roconnor> slack1256: I don't think ttfp will teach you that
19:27:34 <Kaidelong> either way what I ended up with was not a category, or a monoid, but a semigroup
19:27:41 <Cale> Kaidelong: it's the empty route, anyway
19:27:53 <Cale> which takes you nowhere in zero steps
19:28:15 <Kaidelong> Cale: then where does it start or end
19:28:19 <Kaidelong> that's no longer a sensible value
19:28:22 <slack1256> roconnor: where do i look? "category theory for dummies?"
19:28:30 <Kaidelong> if you try to use it you get _|_ not an identity
19:28:40 <Cale> Kaidelong: It doesn't matter
19:28:44 <Kaidelong> yes it does
19:28:50 <slack1256> roconnor: damn "category theory for dummies" exist!
19:28:52 <Kaidelong> the zero has to be the identity element over ++
19:28:59 <napping> paths between distinct locations don't form a semigroup
19:29:00 <Cale> Kaidelong: Because when you concatenate it with any other path, it leaves that path the same
19:29:18 <napping> you can only concatenate paths on a graph if one ends where the other begins
19:29:48 <Cale> napping: That's what I'd normally say too, but he says he has some canonical way to connect the paths together
19:29:50 <Kaidelong> either way there was no zero for the actual implementation
19:29:52 <donri> > (+1) <$> ((+1) <$> Just 1)
19:29:53 <lambdabot>   Just 3
19:30:00 <Cale> but then, there's always the empty path in any graph
19:30:13 <Cale> which consists of no nodes and no edges
19:30:34 <donri> Oxfaded: ^ functor variant
19:30:37 <Kaidelong> it wasn't a very elegant implementation but I was working with a web service
19:30:52 <Oxfaded> donri: I'll look into it, I was really just playing, thanks
19:30:54 <Kaidelong> but I have ended up in a situation where, in practice, I had a semigroup
19:30:59 <napping> oh, if you mean paths like that, then the empty path should do
19:31:21 <Oxfaded> after reading some more type signatures I'm pretty sure I was just confused
19:31:26 <donri> Oxfaded: every monad is an applicative and every applicative is a functor (in my beginner understanding of things)
19:31:26 <Cale> Kaidelong: What's the concatenation of the path which goes from London to Paris with the path that goes from Sydney to Brisbane?
19:31:35 <donri> Oxfaded: they each add another layer do the mix
19:31:39 <Kaidelong> Cale: Not very useful for school buses
19:32:04 <AfC> Cale: a sub-orbital hypersonic ballistic airliner
19:33:47 <Cale> Kaidelong: If you have any semigroup (S,*), and e is not an element of S, then you can form a monoid on S union {e} by simply taking e*a = a = a*e for every a in S union {e}
19:34:26 <Cale> and multiplication between pairs of elements of S to be the semigroup operation
19:35:02 <Kaidelong> Cale: So (Semigroup m) => Monoid (Maybe m)
19:35:04 <Kaidelong> but
19:35:09 <Kaidelong> I didn't actually need a zero element
19:35:21 <Kaidelong> I just needed (++)
19:35:56 <Cale> Sure, but it's usually a good idea not to avoid it, because it gives you a natural base case for folding and so on.
19:36:19 <Kaidelong> right there is nothing wrong with making something a monoid
19:36:30 <Kaidelong> but you might as well put (++) in semigroup and just have monoid require semigroup
19:36:43 <Cale> Maybe if we get class aliases
19:37:02 <shachaf> Cale: Didn't edwardk have good justification for a Semigroup class?
19:37:07 <Cale> But otherwise, needlessly fine-grained class hierarchies are just annoyign
19:37:10 <Cale> annoying*
19:37:33 <Kaidelong> I think with an infix operator it's more justifiable
19:37:41 <Kaidelong> besides you can just put down a
19:37:50 <Kaidelong> (Monoid m) => Semigroup m where (++) = mappend
19:38:18 <Cale> hm?
19:38:43 <Cale> that can't be a class declaration
19:38:50 <Kaidelong> but it can be an instance
19:38:51 <Cale> but if it's an instance, it overlaps with everything
19:38:52 <Kaidelong> although
19:38:57 <Kaidelong> yeah
19:38:57 <Cale> which is really bad
19:39:01 <Kaidelong> other tradeoffs, quite bad
19:39:05 <Kaidelong> worse even
19:39:09 <Kaidelong> so never mind
19:40:10 <Cale> The problem is precisely that you can't just say in Haskell "if someone defines an instance of Monoid, then please act as if this instance of Semigroup is implicitly being defined as well"
19:40:30 <Cale> That's the problem that all these proposals like class aliases have aimed to solve
19:41:25 <Cale> I think constraint kinds may solve it.
19:42:05 <dobblego> I'd *love* to solve that problem
19:42:09 <Cale> I'm not sure if you're allowed to write instances for constraint synonyms directly
19:42:51 <dobblego> @hoogle findM
19:42:51 <lambdabot> Data.IntMap findMax :: IntMap a -> a
19:42:51 <lambdabot> Data.IntSet findMax :: IntSet -> Int
19:42:51 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
19:42:58 <dobblego> er where is findM?
19:43:50 <benmachine> Cale: default signatures solve it a little bit but not really
19:44:06 <Cale> dobblego: I seem to recall writing a function by that name for someone at some point, but I don't think there's one in the libraries.
19:44:19 <dobblego> boo
19:44:21 <benmachine> (you're spared the burden of writing (++) = mappend, but not instance Monoid MyType where)
19:44:22 <dobblego> thanks
19:45:09 <benmachine> I don't think constraint kinds solve it, they solve everything else instead
19:48:32 <ybit> has anyone integrated ii into xmobar?
19:48:58 <ybit> thinking alerts from irc and xmpp in xmobar would be nice
19:52:07 <kmc> not sure; you could ask #xmonad too
19:58:32 <ski> Cale : referring to <http://hackage.haskell.org/trac/ghc/wiki/KindFact> ?
20:00:18 <Cale> ski: yeah
20:01:22 <Cale> You probably can't write instances for synonyms
20:01:38 <Cale> But if you could write them for tuple synonyms, then it would be enough
20:06:45 <ski> Cale : (re `Monoid' vs. `Semigroup') well, there's the `Max' (/ `Lub') and `Min' (/ `Glb') semigroups on e.g. `Integer'
20:07:02 <ski> > maximum []
20:07:03 <lambdabot>   *Exception: Prelude.maximum: empty list
20:10:48 <cwl> I use Network.Browser.browse to request an url, but the response string was unreadable where non-ascii appears
20:16:50 <AfC> Does Network.Browser work in UTF-8 automatically?
20:17:29 <kmc> HTTP servers are allowed to send data in various encodings
20:17:59 <AfC> Indeed; I just recall a bit of chatter about having to get Haskell to treat with UTF-8 encoded strings?
20:18:10 <dobblego> I am often flipping evalState -- is there an existing function?
20:19:07 <kmc> the fact that getRequest produces a String implies that Unicode decoding has already been performed
20:19:18 <kmc> however it might be doing so incorrectly
20:19:28 <parcs> dobblego: i usually do (`evalState` initialState) foo
20:19:40 <dobblego> ah yeah
20:19:45 * ski does that too
20:19:52 <AfC> kmc: [newbie question, sorry:] So Haskell Char (and by extension String and then by guess ByteString) are Unicode?
20:19:54 <dobblego> me too now!
20:20:19 <mauke> AfC: Char is unicode, ByteString is bytes
20:20:20 <ski> AfC : no need to be sorry !
20:20:44 <AfC> ski: cheers, but I know people get a bit tired of FAQ stuff
20:20:54 <kmc> AfC, yes, a Char is a Unicode character.  String = [Char]
20:21:00 <kmc> ByteString is totally different; as the name says it holds bytes
20:21:01 <ski> @src String
20:21:02 <lambdabot> type String = [Char]
20:21:10 <kmc> if you want a packed format like ByteString but for characters, use Data.Text
20:21:21 <pikhq_> I though Char was a Unicode codepoint?
20:21:36 <kmc> yeah i guess so
20:21:37 <mauke> pikhq_: how about a scalar value?
20:21:54 <pikhq_> mauke: Unicode codepoints are scalar values. :)
20:22:08 <mauke> not all of them
20:22:51 <pikhq_> mauke: Uh, yes all of them. However, some Unicode characters are not scalar values, being composed of multiple codepoints.
20:22:58 <AfC> Most of the libraries I've hit so far have returned ByteString, so I've been assuming I'm going to have to explicitly deal with encoding issues.
20:23:11 <BlankVerse> where is Ord defined
20:23:25 <ski> @index Ord
20:23:26 <lambdabot> Prelude
20:23:37 <pikhq_> BlankVerse: Prelude.
20:23:39 <pikhq_> http://www.haskell.org/onlinereport/standard-prelude.html
20:23:41 <ski> @help index
20:23:41 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
20:23:44 <kmc> BlankVerse, you get it from Prelude, but it's actually defined in GHC.Classes in my GHC 7.0
20:23:55 <kmc> you can do ":i Ord" in ghci to find out
20:24:31 <mauke> pikhq_: no, not all of them
20:24:36 <ski> (the standard location from where to get it is `Prelude', nethertheless)
20:24:40 <mauke> pikhq_: scalar values don't include surrogates
20:24:54 <pikhq_> mauke: Surrogates are not codepoints.
20:25:13 <mauke> "Unicode Scalar Value: Any Unicode code point except high-surrogate and low-surrogate code points."
20:25:17 <mauke> unicode disagrees
20:26:43 <ski> (is that "except" a set subtraction or a complement (relative a universe) ?)
20:27:10 <pikhq_> What an utterly strange way of referring to the U+D800-U+DBFF and U+DC00-U+DFFF reserved space.
20:27:28 <mauke> well, it says "code point" both times so I'd say set subtraction
20:28:41 <pikhq_> Also, I was not referring to "Unicode Scalar Values" in stating that they are scalars. I was referring to Unicode codepoints being a subset of the naturals.
20:28:58 <ski> in that case, it could be that the sets of high-surrogate resp. and low-surrogate code points are empty ..
20:29:10 <mauke> ski: I wish
20:29:15 <mauke> also, fuck utf-16
20:29:31 <pikhq_> Agreed.
20:30:05 * ski heard asian people are more fond of utf-16
20:30:15 <pikhq_> Not really.
20:31:01 <pikhq_> For reasons beyond me, UTF-8 compresses better.
20:31:17 <mauke> haha, great
20:31:27 <pikhq_> Also, UTF-16 is only ever a win if you don't have much ASCII in your markup.
20:32:19 <pikhq_> And because of their history of using variable-length codings with the ASCII subset being fairly compact, this is generally not the case there.
20:34:48 <cwl> kmc: how to tell get
20:35:15 <cwl> kmc: how to tell getRequest not to decoding, just give me the raw string
20:37:00 <kmc> cwl, that's not a string then; it's a sequence of bytes
20:37:08 <kmc> it would be represented by ByteString or [Word8] not [Char]
20:37:19 <kmc> as for your actual question, I don't know
20:40:21 <hpaste> cwl pasted “cabal install encoding” at http://hpaste.org/51888
20:48:28 * hackagebot UtilityTM 0.0.4 - Utility functions that are missing from the standard library  http://hackage.haskell.org/package/UtilityTM-0.0.4 (TonyMorris)
20:48:30 <dobblego> preflex: seen ndm
20:48:43 <preflex>  ndm was last seen on #haskell 283 days, 9 hours, 35 minutes and 38 seconds ago, saying: if you don't, then there was a parse error
20:48:49 <ski> preflex: xseen ndm
20:48:50 <preflex>  ndm was last seen on freenode/#haskell 283 days, 9 hours, 35 minutes and 58 seconds ago, saying: if you don't, then there was a parse error
20:53:12 <donri> > foldM (\a b -> Just (a + b)) 0 [1, 2, 3] -- How to do this without lambda (or other fancy things like do-notation)?
20:53:13 <lambdabot>   Just 6
20:53:26 <Jafet> (Just .) . (+)
20:53:49 <cwl> I have a question here http://stackoverflow.com/q/7592484/757616
20:53:54 <ski> > foldM (let foo a b = Just (a + b) in foo) 0 [1, 2, 3]  -- or what Jafet said
20:53:55 <lambdabot>   Just 6
20:53:57 <cwl> About encoding
20:54:09 <donri> thanks
20:54:11 <cwl> the http response
20:54:39 <ski> > Just (foldl (+) 0 [1,2,3])  -- also works
20:54:41 <lambdabot>   Just 6
20:55:34 <Jafet> > foldl (liftM2 (+)) 0 [1,2,3] :: Just Integer
20:55:35 <lambdabot>   Not in scope: type constructor or class `Just'
20:55:38 <Jafet> > foldl (liftM2 (+)) 0 [1,2,3] :: Maybe Integer
20:55:39 <lambdabot>   No instance for (GHC.Num.Num
20:55:40 <lambdabot>                     (Data.Maybe.Maybe GHC.Inte...
20:55:49 <Jafet> > foldl (liftM2 (+)) 0 $ map Just [1,2,3]
20:55:50 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a1))
20:55:50 <lambdabot>    arising from a use o...
20:55:57 <Jafet> Oh dur
20:58:25 <ski> (huh ?)
20:59:34 <Jafet> > foldl1 (liftM2 (+)) $ map Just [0,1,2,3]
20:59:35 <lambdabot>   Just 6
21:02:12 <ski> > foldl (liftM2 (+)) (Just 0) (map Just [1,2,3])  -- ah, ok
21:02:13 <lambdabot>   Just 6
21:02:54 <Jafet> > return ()
21:02:55 <lambdabot>   No instance for (GHC.Show.Show (m ()))
21:02:55 <lambdabot>    arising from a use of `M710434033...
21:03:18 <ski> bad boy, no defaulting for you !
21:49:30 <cwl> readString of HXT is something wrapped in IO
21:49:39 <cwl> does it need to be in IO?
21:49:53 <cwl> it can be pure
21:50:03 <cwl> @type readString
21:50:40 <cwl> @info IOStateArrow
21:52:07 <quicksilver> cwl: I assume it's because it can automatically fetch DTDs and stuff
21:52:10 <quicksilver> which requires IO.
21:52:36 <quicksilver> http://hackage.haskell.org/packages/archive/hxt/9.1.4/doc/html/Text-XML-HXT-Arrow-ReadDocument.html
22:08:34 <amindfv> anyone feel like helping me with a cabal install error?
22:09:11 <shachaf> Only if you say what the error is.
22:09:35 <amindfv> :) it's gtk2hs
22:09:56 <amindfv> I've literally been trying on and off to install it for about a year and a half
22:10:18 <amindfv> it actually fails while building glib
22:10:29 <amindfv> with a simple "Exitfailure 1"
22:11:09 <shachaf> That's not a lot of information. Can you get it to show you more output?
22:11:22 <amindfv> my HP is newish (2011), and I'm following the most recent install instructions
22:11:32 <amindfv> does cabal have a verbose mode?
22:12:35 <amindfv> oh! I missed a line, about 50 lines above: "setup: The program pkg-config version >=0.9.0 is required but it could not be found."
22:13:24 <shachaf> Oh, well, there you go, I guess?
22:13:52 <amindfv> i guess
22:13:55 <amindfv> I'll give it a try
22:13:58 <amindfv> thanks haha
22:20:56 <amindfv> proper forum?: I got a pkg-config configuration error
22:20:59 <amindfv> (irony)
22:22:12 <dobblego> what parsing library does tagsoup use? it appears to have no dependencies on parsec or anything like it
22:23:02 <amindfv> I just did a basic ./config, and it gave me "configure: error: pkg-config and glib-2.0 not found, please set GLIB_CFLAGS and GLIB_LIBS to the correct values "
22:23:14 <amindfv> does that have anything to do with #haskell?
22:23:37 <MasseR> Hmph. I was sure I could do 'foo a a a = ...' if I wanted a base case where all the parameters were the same
22:24:04 <shachaf> MasseR: Nope.
22:24:13 <shachaf> How would it check whether two things are "the same"? Eq?
22:24:14 <MasseR> Apparently not
22:24:24 <kmc> MasseR, no; try:  foo a b c | (b == a) && (c == a) = ...
22:24:24 <MasseR> Good point
22:24:43 <kmc> foo a b c | all (==a) [b,c] = ...
22:25:00 <shachaf> The standard library needs a function allEq :: Eq a => [a] -> Bool
22:25:00 <kmc> Eq is already invoked in pattern-matching
22:25:03 <kmc> for numeric literals
22:25:11 <kmc> oh yeah shachaf?
22:25:17 <shachaf> kmc: Right, but that doesn't mean we should extend it to other things.
22:25:20 <kmc> *nod*
22:25:23 <shachaf> kmc: You think that's not a good function?
22:25:30 * shachaf has wanted it before.
22:25:35 <kmc> it's a fine function
22:25:58 <kmc> yeah, I think allowing «foo a a» would be bad mostly because typos become valid code
22:26:09 <kmc> and it hides the fact that you're invoking (==) which can do arbitrary weird things
22:26:35 <shachaf> I also like how Eq is just a class rather than something built into the languge.
22:26:43 <shachaf> With the exception of numeric literals, but those are a mess anyway.
22:27:15 <kmc> foo a ((==a) -> True) = ...
22:28:05 * shachaf wonders whether the (foo => a) meaning (foo -> Just a) view pattern proposal is a good idea.
22:28:51 <kmc> the sugary taste kids love
22:29:02 <kmc> it seems a bit frivolous
22:29:27 <shachaf> The idea of a pattern maybe matching and if so binding to a value is pretty fundamental.
22:29:37 <donri> what is the recommended way to parse an xml document?
22:29:46 <shachaf> REGULAR EXPRESSIONS
22:29:51 <donri> of course, thanks
22:29:54 <shachaf> Ahem.
22:29:59 * shachaf apologizes for outburst.
22:30:07 <donri> by loading up perl via ffi right?
22:30:15 <shachaf> That's the spirit!
22:30:45 <donri> the shachaf redemption
22:31:05 <shachaf> There're a few libraries but I haven't used any of them, thankfully.
22:31:14 <shachaf> One of them involves Arrow.
22:39:03 <quicksilver> shachaf: I don't like the idea of special casing Maybe into the language on aesthetic grounds
22:39:11 <quicksilver> shachaf: I'm not sure I can make that idea stand up to scrutiny.
22:39:27 <shachaf> quicksilver: Nor do I. I was just arguing against Eq a little before, which is what reminded me. :-)
22:40:00 <shachaf> quicksilver: But you must admit it's convenient and captures a common pattern. Is there a better way to do it, other than explicit Justs?
22:43:01 <iwtu> hi. I would like to ask about documentation on case of expression. I heard "case of" expression don't require class Eq unlike "if then" statement. is that truth?
22:44:03 <dobblego> iwtu: case of matches on data constructors, which is distinct to checking for equality of data structures
22:44:29 <shachaf> iwtu: Yes, they're more fundamental than Eq.
22:44:43 <shachaf> You can define Eq yourself easily enough in terms of pattern matching.
22:46:11 <kmc> iwtu, "if ... then" does not invoke Eq necessarily
22:46:25 <kmc> iwtu, "if ... then"  is like a limited version of "case" specialized to booleans
22:46:35 <iwtu> thanks guys. have any oficial link?
22:46:39 <iwtu> kmc really?
22:46:39 <kmc> «if b then t else f»  ≡  «case b of True -> t; False -> f»
22:47:02 <kmc> imo "if" should not be in the language at all
22:47:05 <iwtu> and if i use == ?
22:47:15 <kmc> that's part of Eq, yes
22:47:15 <dobblego> (and mine too)
22:47:21 <shachaf> kmc: Given that Bool has an Eq instance, that example might not be that helpful. :-)
22:47:38 <shachaf> I think few people are fans of "if" being a special case.
22:47:48 <shachaf> On the other hand, guards are also syntax that special-cases Bool.
22:48:06 <kmc> if "if" were not a reserved word you could define it as an ordinary function (with different syntax)
22:48:12 <kmc> if True x _ = x;  if False _ y = y
22:48:28 <dobblego> ...ad put the arguments around the right way
22:48:39 <shachaf> kmc: That would require extra parentheses, though.
22:48:47 * shachaf is slightly ambivalent about that.
22:48:49 <iwtu> it nice! :)
22:48:59 <kmc> iwtu, in most languages "if" (and also boolean && and ||) are special because they "short-circuit" — they don't evaluate arguments unless needed
22:49:10 <kmc> but in Haskell all function calls have this property
22:49:10 <mauke> vim is dead; does anyone here know how to get the value of t_@7 in a script?
22:49:52 <iwtu> thanks :)
22:50:31 <shachaf> mauke: What do you mean, the value? An escape sequence like \eOF?
22:50:46 <mauke> yes
22:51:45 * shachaf vaguely wonders what mauke needs that for.
22:52:01 <mauke> fixing vim's termcap entries
22:52:36 <shachaf> Is t_@7 the same thing as <End>?
22:52:45 <mauke> what do you mean by "the same thing"?
23:14:21 <jnhnum1> @pl \rec n -> if n == 0 then 1 else n * rec (n-1)
23:14:35 <jnhnum1> @pl \x y -> x + y
23:14:45 <jnhnum1> where is lambdabot :(
23:15:08 <dobblego> cabal install pointfree
23:21:05 <donri> why is it called pointfree when you write something using the point operator :P
23:21:30 <kmc> http://en.wikipedia.org/wiki/Pointless_topology
23:21:34 <erus`> because fuck you thats why
23:21:48 <erus`> :)
23:21:57 <donri> bah, that topology is just pointless
23:22:20 <erus`> are the guys who make nikki and the robots in here?
23:25:28 <donri> so pointfree refers to lack of variables?
23:25:40 <shachaf> Lack of named arguments.
23:25:48 <mauke> lock of bondongs
23:26:43 <kmc> lack of variable bindings
23:27:42 <shachaf> Oh, yes, I suppose so.
23:38:38 <kmc> :t let seq !_ x = x in seq
23:42:35 <cheater> that didn't quite work there kmc
23:42:40 <cheater> what does the ! do there?
23:42:58 <kmc> it's the BangPatterns extension
23:43:27 <kmc> if you define «f !x = ...» then forcing an application (f y) will force x before entering the body of f
23:43:40 * shachaf notes that that function is different from seq !_ = \x -> x
23:43:41 <kmc> i.e.  «f !x = ...»  ≡  «f x = x `seq` ...»
23:44:03 <kmc> it has a related but different meaning nested within another pattern
23:44:22 <cheater> i have no idea what that just meant
23:44:44 <kmc> essentially it lets you make a function less lazy
23:44:58 <cheater> what does it mean to force an application?
23:45:10 <kmc> forcing an expression = demanding its value
23:45:19 <cheater> strict eval?
23:45:28 <kmc> specifically, forcing to weak head-normal form, i.e. evaluating it far enough that the outermost term is a data constructor or a lambda
23:45:33 <kmc> this is the basic evaluation step of Haskell
23:45:37 <kmc> driven by pattern-matching
23:46:04 <cheater> is that different from making something evaluate strictly?
23:46:04 <kmc> evaluating «case x of Nothing -> 1; Just _ -> 2» will force x far enough to see what the outermost constructor is
23:46:15 <cheater> i heard in haskell you can do !x to make x evaluate right?
23:46:25 * shachaf wonders what the context of this discussion is.
23:46:37 <kmc> cheater, there's no way to force evaluation "absolutely"
23:46:47 <shachaf> Oh, it's cheater.
23:46:48 <kmc> you can only add rules of the form "if you force y, force x too"
23:47:02 <kmc> you can't say what "!x" means out of context
23:47:14 <cheater> why?
23:47:29 <kmc> if i write «let f !x = ...» then forcing a function application (f y) will force x even if f otherwise wouldn't
23:47:34 <kmc> (i shouldn't have said "before" before)
23:47:42 <cheater> > let x = 2*2 in !x
23:47:54 <cheater> lambdabot broken
23:47:59 <kmc> lambdabot missing
23:48:01 <kmc> asleep on the job
23:48:02 <cheater> probably missing the vixen coprocessor
23:48:09 <kmc> cheater, ! is part of pattern syntax, not expression syntax
23:48:19 <cheater> aha
23:48:24 <cheater> so in normal haskell
23:48:37 <cheater> what does ! really do?
23:48:46 <mauke> array indexing
23:48:58 <kmc> cheater, you mean as opposed to the non-standard BangPatterns extension?
23:49:18 <cheater> yes
23:49:30 <kmc> it's used to declare strict fields of data
23:49:42 <cheater> o?
23:49:51 <cheater> in the type?
23:49:54 <kmc> data PairL = PairL Int Int;  data PairS = PairS !Int !Int
23:50:14 <kmc> pattern-matching on the PairS constructor will force its Int fields to weak head-normal form
23:50:18 <cheater> does this mean that if i assign to PairS then what ever i assign to it gets evaluated?
23:50:21 <cheater> right
23:50:29 <kmc> so «PairL undefined undefined» is distinguishable from «undefined»
23:50:40 <kmc> but «PairS undefined undefined» is the same as «undefined»
23:50:44 <kmc> cheater, "assign to"?
23:50:53 <cheater> well construct
23:51:07 <cheater> "put in that spot where you say !Int"
23:51:07 <kmc> however «let x = PairS undefined undefined in ()» will not throw an exception
23:51:16 <kmc> because you never force the PairS constructor to begin with
23:51:27 <mauke> cheater: const 42 (PairS undefined undefined) should still be 42
23:51:28 <kmc> that's what i mean by saying there are only relative strictness annotations, and no absolute
23:51:47 <cheater> k
23:51:57 <cheater> that made some sense
23:52:22 <kmc> there is no way to write an expression e such that (const 42 e) throws an exception
23:52:24 <kmc> afaik
23:52:48 <mauke> it's easy if you cheat
23:52:58 <kmc> here throwing an exception is a way to observe evaluation
23:53:02 <kmc> mauke, oh?
23:53:14 <mauke> set e to $! undefined
23:53:19 <kmc> ;P
23:53:25 <kmc> not an expression
23:53:46 <mauke> hence cheating
23:55:03 <shachaf> Everything's easy if you cheat.
23:56:29 <kmc> so glad Haskell is getting a hash-array mapped trie implementation
