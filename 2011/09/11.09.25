00:01:07 <cheater> hey guys
00:01:24 <cheater> i remember some language had "run out of tape" errors, does anyone know what that was?
00:01:36 <cheater> i need to find an instance of such an error.
00:02:02 <shachaf> ENOMEM
00:03:26 <DasIch_> cheater: that's really just a different way of saying that you're out of memory
00:03:43 <cheater> i realize
00:03:52 <cheater> but i want to find something that specifically says "out of tape"
00:04:09 <shachaf> > text "out of tape"
00:04:10 <lambdabot>   out of tape
00:04:16 <cheater> stop trolling
00:04:21 <cheater> this is srs
00:04:31 <shachaf> Is this Haskell?
00:04:38 <shachaf> Your question doesn't make much sense.
00:04:57 <wavewave> out of haskell
00:07:20 <cheater> no it is not haskell
00:07:28 <cheater> it is a question about programming language history
00:08:04 <wavewave> i don't think you can get a better answer here than just google it.
00:09:56 <cheater> have you tried googling it?
00:10:03 <cheater> why are you assuming i have not?
00:11:04 <wavewave> cheater : don't be offended. I am just stating people here might not know the answer.
00:11:49 <cheater> i am hopeful!
00:13:12 <shachaf> cheater: I think asking "X?" is the opposite of assuming "not X".
00:14:07 <mgsloan> here we only run out of lambdas, not tape.  A noted absence of turing machines, though we've got some equivalents
00:14:09 <cheater> it is then very good that your thoughts are not my thoughts
00:14:15 <cheater> mgsloan: haha
00:14:19 <cheater> "run out of graph"
00:22:25 <mah_b> hi, what is the best way to represent a symmetrical relation in haskell? (with properties: http://hpaste.org/51772)
00:30:16 <cheater> @src withFile
00:30:16 <lambdabot> withFile name mode = bracket (openFile name mode) hClose
00:30:38 <sohum> I can't be the first person to want to generalise Map a b and a -> b
00:30:41 <cheater> huh
00:30:47 <cheater> what is bracket?
00:30:49 <cheater> @src bracket
00:30:50 <lambdabot> bracket before after thing = block $ do
00:30:50 <lambdabot>     a <- before
00:30:50 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
00:30:50 <lambdabot>     after a
00:30:50 <lambdabot>     return r
00:31:03 <copumpkin> sohum: jmcarthur had a nice Mapping class a while back
00:31:07 <cheater> ah
00:31:14 <cheater> this is pointfree
00:32:32 <sohum> copumpkin:  http://trac.haskell.org/alt-stdlib/ticket/3?
00:32:59 <copumpkin> that's the one
00:33:20 <sohum> wontfix >_>
00:33:32 <sohum> fine, I'll write up my own
00:48:11 <cheater> updated: http://cheater.posterous.com/first-haskell-script
00:48:20 <mgsloan> I defined one of those Mapping classes here https://github.com/mgsloan/curve/blob/master/Data/Curve/Classes.hs
00:48:52 <mgsloan> even had the same type families
01:16:27 <Blkt> good day eveyone
01:22:49 <knoc> t
01:23:03 <knoc> wrong window^^
01:26:43 <rostayob> Who would be interested in templates compiling to Haskell/JavaScript function?
01:26:47 <rostayob> *functions
01:30:49 <rostayob> well anyway, I just did this: https://github.com/rostayob/gogh , so you write templates and you can compile it to haskell or js, if someone wants to try it and tell me what he thinks I'd be glad
01:32:51 <yitz> rostayob: sounds like an interesting idea
01:34:30 <yitz> rostayob: you should definitely (1) upload to hackage, and (2) post about it on the web-devel list
01:34:40 <hpaste> rostayob pasted ‚Äútemplates‚Äù at http://hpaste.org/51773
01:34:49 <rostayob> yitz: this is an example
01:34:51 <rostayob> http://hpaste.org/51773
01:34:54 <yitz> not necessarily in that order
01:35:40 <rostayob> yitz: well I don't think it's ready for hackage, but I'll go to web-devel (which I wasn't aware of)
01:37:23 <yitz> rostayob: why not? doesn't work?
01:37:58 <rostayob> yitz: well it does, but this is like 10 hrs of work and I'm not sure how well it works :P
01:38:02 <yitz> rostayob: if it compiles, seems to work, and might be useful to someone, why not make it easy to install?
01:38:03 <mietek> Does anyone know more about Fourteen Days of Haskell: A Real Time Programming Project in Real Time?
01:38:17 <mietek> A talk at CUFP yesterday
01:38:32 <rostayob> yitz: well I'm not sure what the interface should be, expecially in javascript
01:38:37 <rostayob> but yeah I might upload it then...
01:38:45 <yitz> rostayob: if people use and problems are discovered, they'll let you know, and maybe even help you fix it
01:39:15 <yitz> rostayob: right, there are a lot of ways to go both in haskell and js.
01:39:38 <yitz> rostayob: one way to develop it is to support other styles perhaps
01:39:52 <rostayob> yitz: what do you mean with styles?
01:39:55 <mietek> http://cufp.org/conference/sessions/2011/fourteen-days-haskell-real-time-programming-projec
01:40:13 <mietek> I really wish they'd publish something; recordings, slides, papers, anything really
01:40:18 <mietek> *sigh*
01:40:56 <yitz> rostayob: well, it could be very useful to integrate this kind of stuff with various frameworks
01:41:24 <yitz> rostayob: e.g. haskell web frameworks like yesod and snap, and js frameworks like jquery etc.
01:41:40 <rostayob> yitz: yeah I was thinking of using it with haskell. I mean expecially the compiling to haskell part.
01:41:42 <yitz> rostayob: anyway, the people on web-devel will have better ideas than me :)
01:41:45 <rostayob> *with happstack
01:41:52 <yitz> right and happstack
01:41:59 <rostayob> yitz: Ok, I'll send a message there then :)
01:42:00 <rostayob> thanks
01:43:06 <yitz> rostayob: but you'll get more people to try it, and thus more suggestions and help, if it's on hackage and they can just say cabal install gogh
01:43:56 <rostayob> yitz: right, I'll write more tests and try the javascript part better and submit it
01:44:52 <yitz> mietek: yeah bummer. i saw this exchange in some thread on reddit recently: <q> will all the sessions at cufp be recorded? <a> no.
01:45:05 <mietek> :(
01:45:16 <yitz> mietek: i guess we all should have been in japan. not so easy for me to get there though.
01:45:25 <mietek> Not for me either
01:45:44 <mietek> The Pragmatic Haskell keynote looks very interesting, too
01:45:50 <mietek> http://cufp.org/conference/sessions/2011/keynote-pragmatic-haskell
01:46:03 <yitz> a lot of stuff
03:03:39 <kmc> just realized my "why learn Haskell" talk does not contain the word "functional" anywhere :)
03:03:45 <kmc> this happened kind of by accident
03:04:11 <rostayob> kmc: link?
03:04:16 <kmc> not up yet
03:04:18 <kmc> but will be soon
03:04:20 <kmc> by Thursday
03:04:29 <rostayob> oh, are you at the ICFP?
03:04:34 <kmc> no
03:04:37 <kmc> just a local HUG
03:04:40 <rostayob> ah ok
03:04:55 <rostayob> HUG, what a lovely acronym
03:05:05 <kmc> well i wrote the talk for a different, less haskell-indoctrinated audience :)
03:05:24 <kmc> but edwardk roped me into giving it at BAHUG :)
03:05:25 <shachaf> HUGs all around.
03:05:26 <rostayob> yeah thinking about it you wouldn't need "why learn haskell" at the ICFP
03:05:26 <kmc> yes
03:06:11 <shachaf> "why learn Haskell instead of Scheme"
03:08:40 <cheater> kmc: that is very good because "functional" is a gross misnomer
03:09:20 <kmc> yeah, on the one hand you get "Blub has lambda too, what's the big deal" and on the other hand "so you can't do IO at all? how useless"
03:09:31 <cheater> yeah
03:09:48 <cheater> that's why i call the difference "constructive" and "declarative" languages (haskell is the latter)
03:09:52 <kmc> yeah
03:09:54 <shachaf> But it has S-expressions and macros, which means it can't be Blub.
03:09:57 <kmc> i use the word "declarative" in the talk
03:10:04 <cheater> <3
03:10:16 <kmc> it seems one approach to advocating Haskell is to sell people on a philosophy of how code should be written, and then demonstrate that Haskell is the best language for writing code according to that philosophy
03:10:22 <kmc> that's a hard sell i think
03:10:31 <shachaf> That depends on the type of code.
03:10:37 <cheater> did you check out my sell on declarative
03:10:41 <cheater> in that blog
03:10:41 <shachaf> There are a lot of tasks for which Haskell isn't the best language.
03:10:55 <cheater> shachaf: such as creating a kernel oops?
03:11:27 <kmc> so i'm going for concrete examples of things you'd naturally want to do in other languages
03:11:27 <cheater> kmc: "why learn haskell" on a HUG is, however, preaching to the choir
03:11:31 <kmc> yep
03:11:38 <kmc> again, blame edwardk
03:11:39 <cheater> i suggest going to a PHP UG
03:11:41 <kmc> heh
03:11:55 <shachaf> Maybe you should call it a User Group for Haskell.
03:12:06 <cheater> kmc: that was about halfway serious
03:12:14 <cheater> kmc: there's some truth in it.
03:12:19 <shachaf> "why learn Agda" at Ruby groups is pretty popular.
03:12:24 <kmc> heh, really?
03:12:36 <shachaf> Well, no. I've only heard of one instance.
03:12:36 <cheater> u mad?
03:12:46 <kmc> copumpkin gave an intro Agda talk at BAHUG
03:12:53 <kmc> (hmm, that collides with Bay Area doesn't it)
03:12:55 <cheater> but ya, you gotta seek out your audience
03:13:00 <cheater> like a crusader
03:13:01 <cheater> of haskell
03:13:03 <shachaf> kmc: Bay Area is bahaskell.
03:13:10 <shachaf> I think the Boston one is BostonHaskell, though.
03:13:26 <cheater> shachaf: there are two bahugs.
03:13:36 <kmc> cheater, i don't want to deal with people who are actively opposed to new/good things
03:13:51 <cheater> kmc: you need to exorcise the evil out of them
03:13:54 <cheater> show them the light
03:13:54 <kmc> no u
03:14:00 <cheater> k
03:14:03 <cheater> seen my blog? done. now u
03:14:11 <shachaf> Go to a FactorUG or something.
03:14:20 <cheater> go to an EiffelUG
03:14:39 <cheater> it'll consist of all employees the company that created Eiffel, and you.
03:16:31 <cheater> kmc: try like, hackspaces or something
03:16:42 <cheater> kmc: they usually have people interested in all sorts of shit
03:16:46 <kmc> yeah
03:16:57 <kmc> you might misunderstand my motivations though
03:17:40 <kmc> this stems from people asking me to give a talk in a particular venue and me thinking up something to talk about
03:18:47 <cheater> is that for the free pizza
03:18:53 <cheater> is that the sort of false prophet you are
03:19:16 <kmc> haha
03:19:20 <kmc> i did it all for the cookie
03:19:33 <shachaf> kmc: At bahaskell we get free cookies every meeting.
03:19:46 <cheater> shachaf gives em out.
03:21:15 <kmc> shachaf, really?
03:21:17 <kmc> who pays?
03:21:27 <shachaf> I think EngineYard.
03:21:42 <rostayob> is there a HUG in london?
03:21:57 <rostayob> yes
03:21:57 <kmc> take the train to Cambridge :)
03:22:05 <rostayob> yeah i might as well do that
03:22:20 <kmc> then you can meet the Haskell Inventor's Group
03:22:21 <cheater> the train is only about 40 mins
03:22:25 <rostayob> The first meeting of the London Haskell User Group took place on 23rd May 2007, at City University in central London (currently not active).
03:22:26 <cheater> from king's cross i think
03:22:29 * shachaf might take the train to Cambridge.
03:22:44 <cheater> shachaf: it's not a M.A.N. train
03:22:50 <shachaf> I mean CAMBRI~2
03:23:22 <cheater> wtf is the City university
03:23:25 <cheater> never heard of
03:23:32 <cheater> i know the UoL
03:25:36 <shachaf> rostayob: http://www.meetup.com/hoodlums/
03:25:36 <mietek> rostayob: there's http://www.meetup.com/hoodlums/
03:25:44 <shachaf> Excellent timing.
03:25:46 <mietek> :)
03:25:53 * shachaf give mietek free cookie.
03:26:00 <mietek> NOM
03:30:49 <co_dh> greeting.
03:31:17 <co_dh> can I define 2 functors, that has the same effect on object, but different effect on morphsim?
03:31:42 <Botje> can you give an example?
03:32:23 <shachaf> I think co_dh is asking for a counterproof or example. :-)
03:32:45 <Botje> i'm not sure what 'morphism' refers to here
03:32:53 <co_dh> take list as a example, can I define 2 functor, both of they (a->b) -> ( [a] -> [b]) , but map f : a-> b to 2 different function?
03:33:10 <shachaf> Botje: Category theory functors, I assume.
03:33:28 <co_dh> I'm talking in the category of Hask, with type as object, function as morphsim.
03:33:38 <Botje> oh, that's why i don't get the question :)
03:33:45 * Botje should really dig into that CT book some day
03:33:53 <shachaf> Well, this question is just about Haskell, I guess.
03:33:56 <co_dh> the question is about general Category theory, but you can use Hask as an example.
03:34:03 <shachaf> co_dh: I'm pretty sure the answer is no.
03:34:40 <co_dh> shachaf: I have the same feeling, but need a proof.
03:35:36 <co_dh> oh, I think the Free Theorem can prove this.
03:37:20 <hpaste> Physicist pasted ‚ÄúIs it a floating point error?‚Äù at http://hpaste.org/51774
03:37:25 <shachaf> It's possible with restricted functors.
03:38:06 <shachaf> http://www.haskell.org/pipermail/haskell-cafe/2008-November/050964.html
03:40:15 <Guest55491> Is it a floating point error or what? http://hpaste.org/51774
03:41:04 <co_dh> shachaf: great thanks!!
03:41:07 <cheater> Guest55491: try pasting it five times more
03:41:10 <cheater> at least 3
03:41:20 <Guest55491> ??
03:41:35 <Veinor> Guest55491: doesn't look like FPE to me
03:41:55 <Veinor> although it might be
03:42:06 <Guest55491> does not look one to me either but what the hell it is
03:44:27 <Veinor> yeah, i got the same result
03:44:59 <Guest55491> this is crazy
03:45:38 <Veinor> it doesn't happen when i do it bigendian, though, which is odd
03:46:10 <Guest55491> I know and that's why i think it's FPE run wild
03:46:23 <Veinor> that's probably what it is
03:46:54 <Guest55491> this happens for the entry on which maximum operations have been done
03:47:14 <Guest55491> any idea about avoiding it?
03:47:41 <Veinor> not really, no. i don't have a lot of experience with numerics :/
03:49:36 <Guest55491> anyone?
03:53:18 <engla> haskell has a lot of more general versions of Prelude functions, for example Data.Foldable. Will these duplications and confusions(?) be resolved in future versions of haskell?
03:53:55 <Saizan> who knows
03:54:29 <Entroacceptor> wasn't there some effort on sanitizing the prelude?
03:55:07 * hackagebot digestive-functors 0.1.0.2 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.1.0.2 (JasperVanDerJeugt)
03:57:53 <hpc> engla: in some cases, the various definitions can't unify in the general case, so there will always be several versions of those
03:57:56 <hpc> :t (Category..)
03:57:57 <lambdabot> Couldn't find qualified module.
03:58:04 <hpc> :t (Control.Category..)
03:58:05 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
03:58:10 <hpc> :t (Prelude..)
03:58:11 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
03:58:13 <hpc> :t (.)
03:58:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:58:42 <engla> I suppose the possible unification goes deeper if you know haskell better
03:59:23 <engla> :t (Data.Foldable.fold)
03:59:24 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
04:00:15 <hpc> engla: we can't unify caleskell's (.) and Category's (.) because not all functors are categories
04:00:29 <hpc> unifying the first parameter would cause cat to be (->)
04:01:07 <hpc> or if we did it by hand, we could make (.) :: cat a b -> f a -> f b
04:01:42 <hpc> but then we would have to define it for all combinations of category and functor, a task haskell syntax isn't up to
04:02:09 <hpc> and isn't possible in the general case, since cat can have more context than the (->) it 'lifts' into
04:03:08 <hpc> i suppose if you were crazy enough you could have class Category cat => Functor cat f | f -> cat where...
04:03:25 <hpc> which says "each functor is with respect to a category"
04:03:53 <engla> I don't understand you, and I've never used Category, I'm sorry :)
04:04:17 <engla> I'm mainly wondering about the duplication like fold, concat, Map.unions etc, it's pretty endless
04:04:18 <hpc> :P
04:04:29 <hpc> yeah, it would be a lot of work
04:05:21 <engla> it should just be a matter of hiding all the special cases and using Monoid's "methods"
04:05:39 <alpounet> :t (>>>)
04:05:40 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
04:13:55 <engla> also, there is no injection function for collections (singleton, \x -> [], etc)
04:14:11 <engla> I mean (\x -> [x])
04:14:40 <ion> Injection?
04:14:42 <ion> @type pure
04:14:43 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
04:19:38 <ddarius> hpc: You'd want to do it with respect to two categories.
04:23:23 <hpc> ddarius: i would?
04:23:39 <hpc> oh, i would
04:32:29 <cheater> so guys
04:32:33 <cheater> what does "lift" do?
04:32:48 <cheater> @t lift
04:32:48 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:32:52 <Botje> which lift?
04:32:54 <cheater> :t lift
04:32:54 <lambdabot>     Ambiguous occurrence `lift'
04:32:55 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
04:32:55 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
04:33:03 <cheater> @type lift
04:33:04 <lambdabot>     Ambiguous occurrence `lift'
04:33:04 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
04:33:04 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
04:33:06 <cheater> good question
04:33:06 <Botje> liftM? liftA? the lift in monad transformers?
04:33:38 <cheater> no just "lift"
04:33:45 <cheater> i am looking at the source of ghc
04:33:45 <Botje> :t Control.Monad.Trans.lift
04:33:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
04:33:48 <Botje> tht one?
04:33:50 <cheater> InteractiveUI.hs
04:33:53 <cheater> i don't know
04:34:24 <cheater> import Control.Monad.Trans
04:34:28 <cheater> so probably yes
04:34:39 <cheater> man this guesswork always is so annoying
04:34:51 <cheater> Botje: so.. what does it do?
04:34:52 <Botje> all I see there is liftM
04:34:52 <cheater> :)
04:35:16 <cheater> keepGoing a str = keepGoing' (lift . a) str
04:36:15 <Botje> then it's probably the trans one, i guess.
04:36:23 <cheater> yeah
04:36:26 <cheater> what does that one do?
04:36:54 <Botje> if lifts the action denoted by 'a' one level into the monad stack
04:37:26 <Botje> so if you are in a ReaderT (WriterT (StateT IO))
04:37:40 <hpc> :t Control.Monad.Logic.lift
04:37:41 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
04:37:47 <Botje> and you want to use tell
04:37:48 <Botje> :t tell
04:37:49 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
04:38:12 <Botje> you need to lift tell one level up, to ReaderT (WriterT ...)
04:38:22 <Botje> so your ReaderT >>= can execute it
04:38:48 <cheater> can you give me a concrete example of code that does that?
04:39:39 <Botje> > let act = tell in runWriter (runReaderT act 5)
04:39:40 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.Reader.ReaderT
04:39:40 <lambdabot>           ...
04:39:48 <Botje> > let act = tell in runWriter (runReaderT (lift act) 5)
04:39:49 <lambdabot>   Ambiguous occurrence `lift'
04:39:49 <lambdabot>  It could refer to either `Control.Monad.Trans....
04:40:10 <Botje> > let act = tell in runWriter (runReaderT (Control.Monad.Trans.lift act) 5)
04:40:11 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.Writer.Lazy.WriterT
04:40:11 <lambdabot>      ...
04:40:16 <Botje> blergh
04:40:24 <cheater> don't hurry
04:41:40 <hpc> if you are composing a Reader and Writer like that, might i suggest you use RWS?
04:41:57 <cheater> i'm not
04:42:04 <cheater> i just want to know what lift does
04:42:06 <hpc> ah
04:42:26 <hpc> :t liftIO -- also helpful
04:42:27 <lambdabot>     Ambiguous occurrence `liftIO'
04:42:27 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
04:42:27 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
04:42:31 <hpc> ...
04:42:54 <Botje> > let act = tell [5] in runWriter (runReaderT (lift act :: ReaderT Int (Writer [Int]) ()) 5)
04:42:55 <lambdabot>   Ambiguous occurrence `lift'
04:42:55 <lambdabot>  It could refer to either `Control.Monad.Trans....
04:43:13 <Botje> > let act = tell [5] in runWriter (runReaderT (Control.Monad.Trans.lift act :: ReaderT Int (Writer [Int]) ()) 5)
04:43:14 <lambdabot>   ((),[5])
04:43:19 <Botje> gah, finally :P
04:43:56 <Botje> cheater: okay, so the inner argument of runWriter (runReaderT ... 5) needs to be of type ReaderT Int (Writer [Int]) a
04:44:08 <Botje> if you do tell [5], you only have Writer [Int] a, which is not enough
04:44:30 <Botje> lift figures out how to wrap that Writer in a ReaderT, such that runReaderT can execute it
04:45:49 <cheater> let me quickly put that line in vim
04:46:58 <fryguybob> > let lift = Control.Monad.Trans.lift in runWriter (runReaderT (do x <- ask; lift (tell [x])) 5)
04:47:00 <lambdabot>   ((),[5])
04:47:20 <cheater> why do you do "let in" there?
04:47:38 <cheater> > runWriter (runReaderT (Control.Monad.Trans.lift (tell [5]) :: ReaderT Int (Writer [Int]) ()) 5)
04:47:39 <lambdabot>   ((),[5])
04:47:56 <cheater> > runWriter (runReaderT (Control.Monad.Trans.lift (tell [5])) 5)
04:47:57 <lambdabot>   ((),[5])
04:48:22 <Botje> to easier change act
04:48:54 <cheater> why do we need to talk about "act" at all? that makes no sense
04:49:01 <cheater> we were talking about "tell" right?
04:49:15 <norm2782> can anyone help me with a Graphics.GD issue? I'm trying to combine two images, of which one has a transparent background. however, after saving, the transparncy has turned black, rather than merging into the background
04:49:24 <norm2782> here's my code: https://gist.github.com/6850b2b9f99b86276aa3
04:50:13 <fryguybob> cheater: No we are talking about lift.  Botje is abstracting out tell to "act".
04:50:35 <cheater> yeah i don't know what act is at all
04:55:05 <buntfalke> How to find out wether an operator / function is left/right-associative?
04:55:14 <shachaf> :i in ghci
04:55:27 <buntfalke> How to do it without ghci?
04:55:42 <Axman6> look at the file it was defined in :\
04:55:51 <buntfalke> @source (++)
04:55:52 <lambdabot> (++) not available
04:55:56 <shachaf> ghc -e ':i /'
04:56:01 <Axman6> heh
04:56:25 <cheater> fryguybob: let me ponder your example with reader and writer for a bit
04:56:50 <buntfalke> shachaf: Ah, it's the l/r in infixl/infixr that shows me! thanks
04:57:32 <Axman6> well, it's the l/r in infixl/infixr that makes them that way, you just happen to use that for your information :P
04:59:02 <cheater> fryguybob: can you tell me where i could find the documentation for runWriter?
04:59:49 <Axman6> :t runWriter
04:59:50 <lambdabot> forall w a. Writer w a -> (a, w)
05:00:00 <Axman6> do you need much more than that?
05:00:04 <Reisen> I'm learning Haskell, I'm not very far in, I've just started looking at types. So far I'm following, but I'm a little confused about how the minBound and maxBound functions work, how would I implement a similar function that returned 5 with :: Int and 'Z' with :: Char?
05:00:40 <fryguybob> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:runWriter
05:00:53 <cheater> thank you
05:00:55 <shachaf> Reisen: It's not a function, it's just a value.
05:01:00 <Axman6> class Default a where def :: a; instance Default Int where def = 5; instance Default Char where def = 'Z'
05:01:02 <cheater> Axman6: that is no documentation at all, are you joking?
05:01:19 <shachaf> Reisen: You can do it as class Foo a where foo :: a; instance Foo Char where foo = 'Z'; instance Foo Int where Foo = 5
05:01:20 <cheater> the type is not documentation
05:01:23 <cheater> it's just at ype
05:01:24 <shachaf> Reisen: But it's probably a bad idea.
05:01:26 <Axman6> cheater: you're not familliar with the Writer monad then?
05:02:05 <Reisen> shachaf, Axman6, ah I see, just started the section on typeclasses, thanks
05:03:02 <cheater> not at all.
05:05:04 <shachaf> Reisen: It's often overused by beginners to Haskell, though. :-)
05:07:25 <Axman6> cheater: ah, fair enough. my mistake :)
05:07:49 <Axman6> cheater: do you understand the concept of the Writer monad?
05:08:01 <cheater> not at all, and the documentation is not helping
05:08:07 <cheater> there's not one intelligible bit in there
05:08:30 <cheater> it links me to some sort of paper that it's "inspired by" and that's all
05:09:06 <Axman6> > runWriter (do {x <- return 1; tell ["Log message " ++ show x]; y <- return 2; tell ["Log message " ++ show y]; return (x+y)}
05:09:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:09:11 <Axman6> hmm
05:09:16 <Axman6> > runWriter (do {x <- return 1; tell ["Log message " ++ show x]; y <- return 2; tell ["Log message " ++ show y]; return (x+y)})
05:09:18 <lambdabot>   (3,["Log message 1","Log message 2"])
05:09:18 <cheater> however, who would want to visit decrepit links not directly related to what they want to use if you get amazingly helpful documentation such as "tell w is an action that produces the output w."
05:09:35 <Reisen> shachaf, I'll be wary about it then
05:09:45 <cheater> let me copypaste that Axman6
05:10:11 <shachaf> Reisen: It might help to figure out how they're implemented (dictionaries of functions passed implicitly).
05:10:33 <Reisen> shachaf, is there somewhere I can read about that kind of thing?
05:10:57 <Reisen> shachaf, about that in particular, but implementations of things in Haskell in general?
05:10:57 <Axman6> cheater: basically, often you'll have some operation where you need to accumulate some state, the canonical example is log messages you eventually want to write to a file. with the writer monad, you can use the tell function to add those messages to your list of messages as you go along, and when you 'run' the monad, you end up with the result it would compure, as well as all the messages
05:11:35 <shachaf> Reisen: I think _A Taste of Haskell_ brought that up, maybe?
05:11:49 <shachaf> Reisen: There's probably the paper it was first proposed in. :-)
05:12:49 <Reisen> shachaf, ah, was hoping there might be some single resource that covered things like that in general
05:13:04 <cheater> Axman6: that is amazingly helpful, thanks
05:13:32 <Axman6> cheater: i've never actually used it, so that's the only situation where I can think of using it :P
05:13:48 <shachaf> Reisen: Hmm, maybe the wiki talks about it?
05:13:58 <shachaf> Looks like it doesn't. I don't know.
05:14:07 <shachaf> Reisen: Implementation details vary between compilers, of course. :-)
05:14:18 <Axman6> you could have the state being written to be a (Sum Int) (it has to be a monoid), and use that to add things... or something. ionno
05:14:33 <Axman6> shachaf: got any interesting uses for the writer monad?
05:14:45 <Botje> I have used the writer monad to find free variables in ASTs
05:14:54 <shachaf> Axman6: ?
05:15:03 * shachaf hasn't been following the other thread.
05:15:06 <Reisen> shachaf, alright well, the dictionaries of functions passed implicitly, is this typeclasses we're talking about?
05:15:07 <shachaf> What's the context?
05:15:11 <Axman6> there's no need to :P
05:15:13 <shachaf> Reisen: Yes.
05:15:13 <Axman6> any
05:15:21 <Botje> and i've used it to split functions into several functions
05:15:24 <shachaf> Logging?
05:15:28 <Reisen> shachaf, ok, thanks again
05:15:29 <shachaf> That's pretty much that Writer is.
05:15:37 <cheater> btw, vim's colorizer for haskell sucks
05:15:49 <cheater> it loses track of bracket style comments
05:16:04 <cheater> so sometimes things will end up shown as commented or not commented, seemingrandomly
05:16:05 <shachaf> Reisen: It's usually a good exercise to figure out how such a thing works yourself.
05:16:07 <hpc> cheater: and multi-line quotes
05:16:08 <cheater> seemingly
05:16:18 <cheater> hpc: is there a better colorizer?
05:16:34 <Reisen> shachaf, will leave you alone after this question, but this looks like it talks about what you said: http://www.haskell.org/haskellwiki/OOP_vs_type_classes#Type_classes_is_a_sort_of_templates.2C_not_classes
05:16:49 <hpc> i think it's a limitation of vim, because i see that problem in other languages too
05:16:50 <shachaf> Reisen: That's true for a lot of Haskell, by the way. For instance, instead of reading tutorials about burritos in order to understand how IO could be done in a language like Haskell, think to yourself "how might I make IO work in a language like Haskell?".
05:17:36 <shachaf> Reisen: I think any article saying type classes are like C++ templates is bound to be a bad influence of some kind. :-)
05:17:52 <Reisen> Rofl
05:17:54 <Reisen> alright
05:18:19 <shachaf> Reisen: http://www.haskell.org/haskellwiki/FAQ is a good resource.
05:18:47 <Reisen> shachaf, will read, thank you
05:21:54 <cheater> hpc: i don't see that in C like quotes which start with /* and end with */
05:23:56 <Axman6> time to fix it?
05:25:15 <cheater> yeah doing that
05:25:29 <cheater> how the hell did you display the current color group?
05:25:30 <cheater> hmm
05:25:53 <Phyx-> Evening
05:34:52 <cheater> can you have nested comments in haskell?
05:34:59 <Axman6> yep
05:35:06 <cheater> like {- {- comment -} still a comment -} ?
05:35:12 <shachaf> > {- let's find {- out! -} -} 1
05:35:13 <lambdabot>   1
05:35:20 <shachaf> Apparently you can!
05:35:40 <cheater> > {- {- nested -} comment -} 2
05:35:41 <lambdabot>   2
05:35:43 <cheater> ok
05:36:09 <Axman6> > {- {- -- comment! -} -- comment? -} 1
05:36:10 <lambdabot>   1
05:36:30 <Axman6> > -- comment -} 1
05:36:31 <lambdabot>   not an expression: `-- comment -} 1'
05:36:39 <Axman6> heh
05:36:40 <shachaf> @quote eat.a.comment
05:36:40 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
05:37:02 <Axman6> omnomnom
05:37:13 <cheater> ok i think i fixed it
05:38:08 <cheater> syn region  hsBlockComment     start="{-"  end="-}" contains=hsBlockComment
05:38:12 <cheater> that's the culprit
05:38:23 <cheater> fixed it to: syn region  hsBlockComment     start="{-"  end="-}" contains=hsBlockCommentB
05:38:23 <cheater> syn region  hsBlockCommentB    start="{-"  end="-}" contains=hsBlockComment
05:38:50 <cheater> also added hsBlockCommentB everywhere the original is too
05:39:15 <fryguybob> > {- nesting has consequences -} text "-}"
05:39:16 <lambdabot>   -}
05:39:20 <fryguybob> > 42 {- {- nesting has consequences -} text "-}" -}
05:39:21 <lambdabot>   <no location info>:
05:39:21 <lambdabot>      lexical error in string/character literal at end o...
05:39:27 <hpc> cheater: you should submit a patch to vim(?)
05:39:39 <cheater> i don't know (?)
05:39:45 <cheater> i'll blog about it!
05:40:04 <cheater> first let me fix it a bit more
05:40:18 <cheater> what about the multiline quotes?
05:40:24 <cheater> what's the syntax there?
05:40:26 <hpc> http://www.vim.org/maillist.php#vim-dev -- here, after you test it, i think
05:41:09 <hpc> "this text \
05:41:12 <cheater> ok
05:41:16 <hpc>       \only has a few spaces"
05:41:18 <cwl> > 1 + 1 / 2
05:41:19 <lambdabot>   1.5
05:41:21 <hpc> (and no newline)
05:42:51 <cheater> do you have a file that triggers the bug for you?
05:43:47 <hpc> yeah, sec while i find it
05:44:55 <hpc> hmm, must have rm'd it
05:44:57 <cheater> also do you have one with the comment bug? we could test this
05:45:04 <cheater> think you can just trigger it? :)
05:46:32 <hpc> triggered it
05:46:41 <hpc> takes a bit of editing to force it though
05:47:08 <hpc> write a multiline string, then add and remove a backtick somewhere above the function definition
05:47:22 <cheater> ok just a sec
05:48:51 <hpaste> hpc pasted ‚Äúsyntaxfail‚Äù at http://hpaste.org/51778
05:49:08 <hpc> ...or just a bunch of newlines, apparently
05:49:44 <cheater> aha
05:52:02 <hpc> also, i think the change you made for block comments is faulty
05:52:28 <hpaste> hpc pasted ‚Äúnested comment blocks‚Äù at http://hpaste.org/51779
05:52:34 <hpc> pasted test case
05:53:20 <cheater> hm no, my fix just broke something else
05:53:38 <cheater> if you had something after the multiline comment then it would sometimes get colorized as a comment
05:53:39 <cheater> not good.
05:55:51 <cobbe> Are view patterns known to cause problems with match exhaustiveness in ghc 7.0.3?
05:56:23 <cobbe> I did some googling on this, but the only discussion I could find about this was several years old and involved existential types, which I'm not using.
05:57:05 <hpc> ah, the joys of context-free grammars combined with mediocre tools to describe them
05:57:20 <cheater> hpc: ?
05:57:25 <hpc> the haskell syntax file
05:57:41 <Phyx-> rofl
05:58:01 <Phyx-> did you just call Happy mediocre? :P
05:58:10 <hpc> no, vim's syntax files
05:58:24 <Phyx-> ah
05:59:00 <hpc> this isn't nearly as fun as learning agda
06:30:33 <huangyi> Is there an io manager thread for each capability, or only a single global io manager thread ?
06:33:41 <huangyi> Ok, it seems to be the latter.
06:38:53 <ben> @quickcheck (< 100) . abs
06:38:54 <lambdabot> Unknown command, try @list
06:42:16 <ben> How do I tell quickcheck I want more tests and also tests with really big numbers
06:42:24 <ben> I've never used it
06:42:47 <hpc> ben: you should try the docs
06:42:59 <hpc> @check (< 100) . abs
06:43:00 <lambdabot>   "Falsifiable, after 219 tests:\n-105\n"
06:43:39 <benmachine> ben: see quickCheckWith and stdArgs
06:44:14 <ben> I see
06:44:23 <benmachine> as for tests with really big numbers, I'm not sure if maxSize does that for you or if you need to construct them yourself
06:44:53 <ben> Seems to do it
06:44:57 <benmachine> ok cool
06:45:01 <ben> cheers
06:53:19 <cheater> so.. we have the writer monad covered, what does the reader monad do?
06:54:08 <Axman6> lets you pass in some static state that you can lookup anywhere inside the monadic action
06:54:20 <cheater> aha
06:54:28 <cheater> is there a.. reader/writer monad?
06:54:33 <cheater> like say a stack?
06:54:37 <Axman6> so, a useful place fot his is if you have a large record which has all the configuration for some action, and you don't want to explicitly pass it around
06:54:49 <cheater> yah
06:55:00 <Axman6> there's ReaderT, WriterT and... the mother of them all..., RWST
06:55:10 <cheater> RWST?
06:55:14 <Axman6> Reader, Writer, State Transformer
06:55:23 <Axman6> @unmtl RWST
06:55:23 <lambdabot> err: `RWST' is not applied to enough arguments, giving `/\A B C D E. A -> C -> D (E, C, B)'
06:55:28 <Axman6> bleh
06:55:38 <Axman6> @unmtl RWST r w s m a
06:55:39 <lambdabot> r -> s -> m (a, s, w)
06:55:45 <hpc> if you are feeling particularly insane: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
06:55:58 <shachaf> hpc: Nothing insane about Cont.
06:56:05 <cheater> i may have read that once
06:56:19 <Axman6> i should probably read that (again?)
06:56:47 <shachaf> Cont is the best monad.
06:57:29 <Axman6> cheater: you might be able to see that RWST could be quite useful in a large program, where you've got some config data, some state you need to keep track or, and some write only state like logging
06:58:23 <shachaf> RWST seems like a bit of an abomination to me.
06:58:35 <Axman6> yeah...
06:58:51 <shachaf> Cont, on the other hand, is lovely.
06:58:55 <Axman6> i don't think i'd ever actually use it, instead opting for explicit use of other simpler transformers
07:01:26 <parcs> it exists for efficiency
07:04:25 <jpcooper> hello
07:04:55 <jpcooper> could anyone tell me where I can learn more about how to read the language on the last page of http://www.itu.dk/~brabrand/banana-algebra/banana-algebra.pdf ?
07:04:56 <rostayob> jpcooper: hello
07:05:03 <hpc> Axman6: i wouldn't even use transformers, and just write it myself and give appropriate instances; some of the transformers have some annoying quirks
07:05:08 <jpcooper> I don't know what it's called
07:05:31 <rostayob> jpcooper: big step semantics?
07:06:17 <jpcooper> thanks
07:06:33 <rostayob> jpcooper: np, funny that you came on haskell to ask that :D
07:06:58 <jpcooper> well, the paper contains some Haskell and I couldn't think of anywhere more suitable :)
07:07:10 <Cale> Not *that* funny :)
07:07:26 <rostayob> well, it worked ehe
07:07:43 <Cale> It's a combination of a notation from formal logic for derivation rules (and proof trees) with some other notations
07:07:44 <cobbe> jpcooper: are you familiar with the basics and have specific questions about the paper's notation, or are you new to big-step semantics?
07:07:48 <cheater> that paper was fairly straightforward
07:08:28 <Cale> Each horizontal line denotes a derivation rule. Assumptions are listed above the line and consequences (usually a single consequence) below
07:08:47 <cobbe> read "double-down-arrow" as "evaluates to"
07:09:05 <jpcooper> cobbe: yes I'm not familiar with all of the symbols and was wondering where I could read more about them
07:09:39 <rostayob> is there an appropriate place to put documentation for executables in haddock?
07:10:09 <cobbe> plenty of people here could give you an overview of big-step semantics, but any PL semantics textbook should have an intro to the concept
07:10:32 <rostayob> It's pretty straight forward anyway
07:10:45 <Cale> "Types and Programming Languages" by Pierce is a common recommendation
07:10:57 <cobbe> rostayob: but the mathemtical language can be a bit intimidating if you haven't seen it before
07:11:09 <cobbe> Cale: been a while -- does that use big-step semantics or SOS?
07:11:12 <rostayob> isn't TAPL a bit overkill to learn about operational semantics?
07:11:13 <jpcooper> thanks I'll have a look at that
07:11:28 <Cale> It talks about big-step and small-step semantics.
07:11:58 <cobbe> I think reading any semantics text in its entire is overkill for big-step semantics; you'll probably want just a chapter or section
07:12:24 <cheater> @src GHC.exprType
07:12:25 <lambdabot> Source not found.
07:12:28 <cheater> :(
07:12:29 <Eduard_Munteanu> Big-step semantics? IIRC, there wasn't a lot about that in TAPL.
07:12:33 <cheater> where can i find source for that?
07:12:42 <Cale> Though, I can't really read all of this notation... but maybe some of it is introduced in the paper.
07:12:54 <rostayob> jpcooper: our course had this: http://www.doc.ic.ac.uk/~pg/Computation/book.pdf , "Seantics with Applications: A Formal Introduction"
07:13:50 <jpcooper> thanks
07:14:26 <Cale> cheater: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/src/InteractiveEval.html#exprType
07:14:46 <cheater> Cale: i have the ghc source tree here.. is it somewhere in it?
07:14:48 <rostayob> i'm not sure how good it is to be honest, but it's freely available so i'm linking it :P
07:14:55 <Cale> yes
07:15:16 <Cale> It's in the module called InteractiveEval
07:15:23 <cobbe> rostayob: I'd love to see that book, but Firefox is predicting a 45min download this morning.  :-(
07:15:32 <jpcooper> yeah, quite slow for me too
07:16:36 <rostayob> cobbe: gzipped postscript here http://www.daimi.au.dk/~bra8130/Wiley_book/wiley.html
07:16:38 <parcs> cheater: it's in ./compiler/main
07:16:39 <rostayob> was a lot faster for me
07:17:56 <Cale> I was able to grab the PDF from there in a few seconds
07:18:22 <cheater> ahh thank you looking there
07:18:50 <Cale> cheater: For just browsing source, I like to use the haddock source links
07:18:53 <rostayob> Cale: "here" where?
07:19:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html#v:exprType
07:19:08 <rostayob> you must have a fast connection ehe
07:19:12 <Cale> rostayob: the page you just linked
07:19:20 <Cale> I have a few megabytes down
07:19:40 <rostayob> Cale: yeah exactly, the problem is in our crappy connections not in their servers
07:19:52 <rostayob> (which are very very fast, i can assure you ehe)
07:20:26 <rostayob> they have their orn class B network in the department
07:20:52 <Cale> http://www.speedtest.net/result/1501307168.png -- it's extremely asymmetric though
07:21:10 <rostayob> Cale: scumbag network!
07:21:15 <cheater> heheh, i created a bacon for my ghc source tree, i called it ùúÜ
07:21:21 <rostayob> well scumbag connection
07:21:32 <cheater> now i can just do cd ùúÜ to go to the source tree.
07:21:36 <cobbe> jpcooper: Nielson & Nielson do introduce the notion of big-step semantics, although (on a really fast skim) they call them natural semantics and use slightly different syntax
07:21:47 <cocon> @pl \x -> f (g x) (h x)
07:21:47 <lambdabot> liftM2 f g h
07:22:02 <cobbe> They complicate matters by diving straight into languages with state, though, which isn't how I'd start if I were teaching this stuff.
07:22:44 <cobbe> But the primary effect of that is to make the reduction rules look more complicated on the page; it doesn't actually add that much theoretical complexity.
07:28:41 <cobbe> On a completely different topic: I'd like to understand the best way to implement (==) on lists as a fold, in order to take advantage of laziness.
07:28:49 <cobbe> I've got lots of experience with *strict* functional languages
07:29:03 <cobbe> so the question is how to use laziness to ensure that we don't do more comparisons than we need
07:29:41 <cobbe> (Also, I know that lists are in the Eq class, so this is in the library; I'm using lists as a standin for a more interesting type)
07:29:50 <rostayob> cobbe: foldr (\(x, y) r -> x == y && r) True
07:30:06 <rostayob> no sorry, foldr (\(x, y) r -> x == y && r) True . zip
07:30:14 <rostayob> but this doesn't take length into account, so
07:30:26 <cobbe> That was essentially what I was thinking, thankx.
07:30:28 <cobbe> *thanks.
07:30:40 <rostayob> cobbe: that wouldn't work since zip will zip lists of different lengths
07:30:42 <cobbe> (And length isn't a problem; I have to deal with that before calling fold anwyay)
07:30:43 <rostayob> but you get the idea
07:30:45 <rostayob> ok
07:31:28 <cobbe> And using (\(x, y) r -> r && x == y) would force more of the list, right?
07:31:40 <rostayob> cobbe: actually that would be better
07:31:46 <cobbe> why is that?
07:31:51 <rostayob> wait, no
07:32:20 <rostayob> they're the same i think
07:32:41 <cobbe> are they?  I thought (&&) was strict in its first argument.
07:33:29 <rostayob> cobbe: what do you mean?
07:33:34 <rostayob> well
07:33:42 <rostayob> @src (&&)
07:33:43 <lambdabot> True  && x = x
07:33:43 <lambdabot> False && _ = False
07:33:54 <rostayob> let's say that it forces the first argument yeah
07:34:00 <cobbe> That's essentially what I meant, yeah.
07:34:12 <rostayob> but it couldn't be any other way
07:34:15 <cobbe> And especially that it doesn't necessarily force the second.
07:34:29 <rostayob> yeah but... there can't be a "lazier" version
07:34:35 <cobbe> Not claiming otherwise.
07:34:46 <rostayob> ok :)
07:35:03 <cobbe> But I think that means that the second version of fold will force the recursion, even if x /= y.
07:35:16 <cobbe> Whereas the first would skip over it, which is what I want.
07:35:30 <cobbe> (Ignoring non-termination, the two versions should of course always produce the same answer.)
07:35:32 <rostayob> yes, you're right
07:36:08 <cobbe> ok, cool.  I'm still getting a handle on lazy computation, so this has been helpful.  Thanks!
07:36:33 <buntfalke> Is a function f :: a -> b -> c left- or right-associative if used like a 'func' b without any infix declaration?
07:36:43 <buntfalke> @source infixl
07:36:43 <lambdabot> infixl not available
07:36:46 <buntfalke> @source infix
07:36:47 <lambdabot> infix not available
07:37:05 <rostayob> cobbe: well I'm in the same boat, reasoning about these things can be tricky
07:37:09 <buntfalke> infix is another magic function like seq i guess
07:38:00 <cobbe> buntfalke: isn't it a keyword rather than a function?
07:38:05 <rostayob> buntfalke: infixr is not a function, you're just specifying the fixity, it's more like a language feature
07:38:16 <monochrom> "infix" is not a function. it doesn't even have a type. seq has a type.
07:38:41 <monochrom> people do not say "data" is a magic function.
07:39:30 <monochrom> there is a default if you don't use any "infix" declaration. I am too lazy to look it up now
07:40:28 <rostayob> buntfalke: http://www.haskell.org/onlinereport/decls.html
07:40:42 <rostayob> buntfalke: 4.4.3
07:40:46 <rostayob> *4.4.3
07:40:49 <rostayob> oh damnit
07:40:53 <rostayob> 4.4.2
07:40:56 <rostayob> not 3. 2.
07:41:02 <dmwit> rostayob, cobbe: You *can* have a lazier version of (&&)!
07:41:08 <cobbe> oH?
07:41:16 <rostayob> dmwit: really? how?
07:41:42 <dmwit> cabal install unamb
07:41:48 <dmwit> import Data.Unamb
07:41:53 <rostayob> is that the conal thing?
07:42:03 <dmwit> pand undefined False => False; pand False undefined => False
07:42:09 <dmwit> yes
07:42:43 <rostayob> so basically it can "recognise" undefined?
07:42:57 <dmwit> No, but it can recognize things that execute faster than undefined.
07:43:09 <rostayob> aha
07:43:22 <rostayob> well it'll still force one of the arguments. why would you say it's lazier?
07:43:31 <rostayob> it's just smarter
07:43:34 <dmwit> Because it's not strict in either argument.
07:43:40 <buntfalke> cobbe, rostayob, monochrom: thanks!
07:43:44 <dmwit> As the two examples I pasted show.
07:43:47 <buntfalke> rostayob: thanks for the section
07:43:52 <cobbe> right -- (undefined && x) is always undefined
07:44:07 <cobbe> but (unefined `pand` x) isn't always undefined
07:44:14 <dmwit> exactly
07:44:16 <cobbe> well, modulo typos, anyway.  :-)
07:44:16 <rostayob> dmwit: i guess... i'm going to take a look on how it's implemented
07:44:21 <parcs> pand undefined True ==> *** Exception: BothBottom
07:44:34 <dmwit> parcs: Right.
07:44:40 <parcs> oh duh
07:44:41 <cobbe> rostayob: heh -- good luck.  thinking about amb always makes my head hurt.  :-)
07:44:42 <parcs> >_>
07:44:55 <dmwit> parcs: You would hope that it wouldn't return True. =)
07:45:15 <rostayob> > typeRep undefined
07:45:16 <lambdabot>   Not in scope: `typeRep'
07:45:31 <rostayob> > typeOf undefined
07:45:32 <lambdabot>   Ambiguous type variable `a' in the constraint:
07:45:33 <lambdabot>    `Data.Typeable.Typeable a...
07:45:40 <rostayob> > typeOf (undefined :: Int)
07:45:41 <lambdabot>   Int
07:45:57 <dmwit> rostayob: The definition is pretty simple: pand a b = unamb (a && b) (b && a)
07:46:12 <dmwit> (modulo some fancy abstractions for commutative binary operators)
07:46:23 <byorgey> what's the nicest way you can think of to implement   (a -> Bool) -> (a -> b) -> (a -> Maybe b) ?
07:46:26 <rostayob> dmwit: yeah but what does unamb do? is it really a race between the two?
07:46:37 <rostayob> >
07:46:39 <dmwit> In other words: execute both (a && b) and (b && a) in parallel, and return the answer from the first guy that responds successfully.
07:46:41 <rostayob> oops
07:46:46 <dmwit> Yes, it's really a race.
07:46:51 <rostayob> dmwit: yeah I just can't think on how to do it with haskell right now
07:46:59 <rostayob> is unsafePerformIO involved?
07:47:07 <dmwit> rostayob: Oh, it just forkIO's two evaluate commands, then unsafePerformIO's them, probably.
07:47:13 <dmwit> I haven't looked at the internals.
07:47:15 <rostayob> dmwit: ok then it's quite ugly
07:47:22 <dmwit> There's probably some messy stuff to deal with exceptions, too.
07:47:27 <rostayob> why do we know that the bottom part will be slower?
07:47:45 <byorgey> the implementation is necessarily quite ugly, but the semantics are beautiful
07:47:48 <kamaji> How many ways of getting an ace-high straight from a 5-card hand are there in poker? I'm sure it's 1024 but this page says otherwise http://www.suffecool.net/poker/evaluator.html
07:48:02 <byorgey> rostayob: no, if one of them throws an error it just catches the error and waits for the other one
07:48:07 <dmwit> byorgey: ensure p x = guard (p x) >> return x; yourThing p f = fmap f . ensure p
07:48:13 <kamaji> Oh, royal flushes.
07:48:17 <rostayob> byorgey: oh right, that makes sense. so it's not just a race.
07:48:57 <cobbe> well, it's a race to see who gets an answer first.  If a car blows up during a race, then I think we can safely say that driver never finishes.  :-)
07:49:08 <byorgey> dmwit: yes, that's nice.  If only 'ensure' were in Control.Monad.
07:49:26 <dmwit> I went to write a proposal once. But the process is so long....
07:49:33 <byorgey> heh, yeah
07:49:45 <rostayob> ,>
07:49:51 <rostayob> oh this keyboard....
07:50:03 <rostayob> how can people actually use netbooks?
07:50:18 <rostayob> i am forced to use one now and it's a nightmare. maybe i just have big hands mah
07:50:34 <dmwit> rostayob: Plug your USB keyboard into the netbook. ;-)
07:51:02 <rostayob> dmwit: the only keyboard i found in this house is one of those 7.99 trust keyboards. my fingers actually hurt after a while
07:51:14 <rostayob> while the netbook keys are not that bad, but it's too cramped
07:51:28 <benmachine> rostayob: ime you get used to it eventually
07:51:31 <Nimatek> Chiclet style netbook keyboards are acceptable.
07:51:45 <Nimatek> You can actually type quite fast on them due to low travel times for your fingers.
07:51:45 <rostayob> and i don't want to buy a keyboard for 10 days of use. life is harsh.
07:53:01 <dmwit> yourThing p f x | p x = Just (f x) | otherwise = Nothing -- byorgey, this is also quite, quite readable, though it may affront your abstraction aesthetics =)
07:53:23 <rostayob> yeah what's wrong with guards? i like guards
07:54:09 <byorgey> dmwit: hehe, well, in this case it's not just my aesthetics that matters, but the ease of use for xmonad users
07:54:15 <byorgey> dmwit: see my recent email
07:54:25 <dmwit> oooo, email
07:54:31 <dmwit> I knew there was something I hadn't done yet today.
07:54:37 <byorgey> hahaha
07:54:54 <byorgey> then once you read your email you'll be all done!
07:54:57 <byorgey> bedtime.
07:55:01 <dmwit> haha
07:55:59 <benmachine> :t \p -> ap (<$) (guard . p)
07:56:00 <lambdabot> forall a (f :: * -> *). (Functor f, MonadPlus f) => (a -> Bool) -> a -> f a
07:56:25 <dmwit> Oh, yes, if/then/else also seems quite reasonable.
07:56:37 <dmwit> Especially for Haskell non-experts.
07:57:07 <dmwit> I suppose Just (f p) was probably a typo, but not really worth an entire message to the mailing list. =P
07:57:28 <rostayob> dmwit: anyway, I don't see how you can write a function like pand on haskell without unsafePerformIO, so I'd say it's confusing to say that is possible to write a lazy &&
07:57:30 <benmachine> yourThing p f = do b <- p; if b then Just . f else return Nothing -- :>
07:57:39 <parcs> why is there no pplus in unamb?
07:58:04 <dmwit> parcs: That's a good question. Maybe not many people use lazy numerals.
07:58:10 <dmwit> (Do you?)
07:58:29 <parcs> no
07:58:32 <parcs> but there's pmult
07:58:54 <parcs> oh
07:59:05 <parcs> because there's no short-circuiting for addition
07:59:21 <dmwit> There is, though.
07:59:34 <dmwit> It should be parIdentity (+) 0
07:59:42 <dmwit> parcs: You should send him a patch. =)
08:01:59 <kamaji> Does the haskell compiler pre-run code with constants in it?
08:02:01 <peikos> hello everybody
08:02:18 <parcs> seems kind of pointless though. but then again, so do pmin and pmax :P
08:02:22 <kamaji> say if I write a function something like `take 10 fibs` to get the first 10 fibonnaci numbers, will that be precomputed?
08:02:37 <Botje> kamaji: probably not.
08:02:50 <rostayob> no, but foo = take 10 fibs will be computed only once
08:02:59 <kamaji> oh yeah, I forgot about that
08:03:03 <peikos> I'm trying to install HP 2011.2 for 64bits OSX, but it won't let me - it said I need Xcode Developer tools first, but after installing Xcode from the app store the installer still won't recognize it's presence...
08:03:06 <kamaji> basically equivalent :D
08:03:19 <rostayob> well not exactly, a simple call won't be memoized
08:03:30 <cobbe> peikos: Snow Leopard or Lion?
08:03:33 <rostayob> well wait
08:03:36 <TheLemonMan> whats the best upstream library to calc some md5 hashes ?
08:03:37 <peikos> Lion
08:03:56 <cobbe> Ok -- can't help there, I'm afraid; I haven't upgraded yet.
08:04:01 <rostayob> kamaji: if you write take 10 fibs in multiple places, it'll be computed each time for the first time
08:04:06 <rostayob> taht's what I meant :P
08:04:09 <peikos> the old version that was installed some time ago still works, but won't let me install certain packages, prompting me to upgrade
08:04:18 <kamaji> rostayob: right, so if I do fibs10 = take 10 fibs it will only happen once
08:04:20 <kamaji> ?
08:04:23 <kamaji> yeah.
08:04:31 <rostayob> yes
08:04:38 <kamaji> I guess you can't precompute
08:04:46 <kamaji> because of the halting problem?
08:04:53 <kamaji> or at least that might be problematic
08:04:54 <rostayob> in general if you have "take 10 fibs" somewhere, that expression will be evaluated once
08:04:58 <monochrom> "everything has a first time" :)
08:05:01 <rostayob> kamaji: it's called supercompilation
08:05:22 <rostayob> (I think).
08:05:24 <kamaji> or is halting problem only for unknown inputs
08:05:36 <kamaji> sounds cool
08:05:43 <rostayob> kamaji: well you can already stall a compiler with TH :P
08:05:46 <rostayob> wait
08:06:00 <rostayob> yeah
08:06:27 <rostayob> so I don't think the primary concern is that the compiler might terminate, it's just hard to do
08:06:41 <kamaji> haha yeah I suppose
08:06:43 <kamaji> http://neilmitchell.blogspot.com/2007/12/supercompilation-for-haskell.html
08:06:49 <kamaji> that guy mentions the halting thing actually
08:07:09 <kamaji> "when the topic of non-termination comes up, I now have a good answer. The answer is homeomorphic embedding."
08:07:17 <rostayob> ah well...
08:07:17 <kamaji> I don't know what that is :D
08:07:50 <kamaji> "Compilation times are between 10 seconds and 5 minutes"
08:07:52 <kamaji> :|
08:08:07 <rostayob> firefox can beat that
08:08:16 <kamaji> lol
08:08:34 <rostayob> good ol' days compiling everything with -O73 on gentoo
08:08:38 <kamaji> 73!?
08:08:47 <kamaji> how come yours goes up to 73
08:09:06 <rostayob> my compilers are not like your compilers
08:09:15 <monochrom> I think -O73 is a joke
08:09:49 <monochrom> the actual statement is compiling everything with a million options
08:09:56 <rostayob> yes
08:10:17 <kamaji> oh :D
08:10:25 <kamaji> a friend of mine broke his laptop compiling gentoo once
08:10:28 <kamaji> the disk just died after 2 days
08:10:46 <kamaji> it was an old laptop..
08:10:57 <rostayob> i know, gentoo is dangerous, and so are its users http://funroll-loops.info/
08:10:58 <cheater> LOL
08:11:03 <rostayob> anyway, we're going ot ehe
08:12:18 <kamaji> this site is awesome
08:26:42 <ocharles> hey, I'm trying to build a project that has 1 library, and 2 executables, and getting link errors - https://gist.github.com/1240796
08:26:58 <ocharles> That shows my typical cabal clean/configure/build cycle, and my cabal file - can anyone spot what might be wrong?
08:27:19 <ocharles> urgh, script didn't do a good job capturing all my control codes :)
08:34:01 <dmwit> ocharles: cabal --version?
08:34:17 <ocharles> 1.10.1.0
08:34:40 <dmwit> Is cabal-install the most recent version?
08:34:54 <dmwit> (The real reason I asked for cabal --version, by the way.)
08:35:14 <dmwit> (Older cabal-install's didn't do executable+library correctly.)
08:35:28 <ocharles> I know, but I'm depending on >= 1.8
08:36:36 <dmwit> ocharles: I'm asking (twice now =) about the version of *cabal-install*, not the Cabal library.
08:36:56 <ocharles> I'm confused, do you not want the output of cabal --version Imentioned above?
08:37:00 <ocharles> if so, what should I check?
08:37:07 <any-key> When I attempt to compile this code, I keep getting a warning saying that I have overlapping patterns in the case statement...  http://pastebin.com/b3avsPCq
08:37:10 <mauke> The paste b3avsPCq has been copied to http://hpaste.org/51781
08:37:22 <dmwit> ocharles: cabal --version should print two lines. I want the other one.
08:37:26 <ocharles> ohh, sorry!
08:37:30 <ocharles> 0.10.2
08:37:36 <mauke> any-key: lines 5, 6, 7
08:37:38 <Botje> any-key: haskell does not do unification.
08:37:57 <Botje> any-key: so any number (besides 0) will match your first case at line 4
08:38:19 <Botje> if you want to compare you have to do it explicitly
08:38:35 <Botje> case ycoord of y | y == fy -> ...
08:38:48 <any-key> ah okay, thank you
08:39:20 <dmwit> ocharles: Hm. That looks recent enough.
08:39:26 <any-key> might as well just switch it to using guards
08:39:52 <ocharles> dmwit: yea, I thought so
08:41:12 <dmwit> ocharles: eh... does the executable depend on the library?
08:41:31 <dmwit> ocharles: If so, shouldn't you have a build-depends: line in your executable block?
08:41:42 <ocharles> dmwit: I think that cat has got truncated
08:41:44 <ocharles> one moment
08:42:21 <ocharles> https://gist.github.com/1240815 is a fresh paste, I think L21 and L27 is what you mean
08:42:35 <dmwit> yep =)
08:43:25 <dmwit> ocharles: Everything seems to check out (assuming the library files are all under src/).
08:43:28 <dmwit> So... odd!
08:44:16 <dmwit> preflex: zdec MBChatLoggerzmindexzm0zi1_MBChatLoggerziXML_dc_closure
08:44:17 <preflex>  MBChatLogger-index-0.1_MBChatLogger.XML_dc_closure
08:44:38 <dmwit> ocharles: Are you exposing all the modules you need to expose?
08:44:52 <dmwit> (i.e. at least all the modules you import in your executables?)
08:45:14 <dmwit> Perhaps you need to export MBChatLogger.XML
08:45:43 <ocharles> The indexer only depends on Parse and Index
08:45:48 <ocharles> I could try exporting that though
08:46:13 <ocharles> (MBChatLogger.XML is the only module not exposed)
08:46:33 <dmwit> ocharles: What bothers me is that, when building the executable, it seems to be attempting to re-build MBChatLogger.*
08:47:16 <ocharles> why do yo uthink that? I did clean before pasting that log
08:47:37 <ocharles> the extra exposure has seemed to rectify things, maybe a module is missing an explicit export list?
08:47:38 <dmwit> Lines 18-22.
08:47:51 <dmwit> (of your error paste)
08:48:10 <ocharles> MBChatLogger-index is the name of the library
08:48:19 <ocharles> and as I cleaned, it's building it first - that seemed fine to me
08:48:28 <dmwit> Ah, good.
08:48:32 <dmwit> Then I read incorrectly.
08:49:09 <dmwit> Is any of the three modules explicitly re-exporting the XML module?
08:49:15 <dmwit> Perhaps that is the cause?
08:49:23 <dmwit> I'm a bit uncertain here.
08:49:53 <ocharles> dmwit: I think it's because some of the modules don't specify what they export
08:50:19 <ocharles> just verifying that now
08:52:11 <ocharles> damn, same link errors
08:52:33 <ocharles> I'm not hugely bothered about having to expose the XML module, but I shouldn't really have to, wonder what's up
08:54:02 <siracusa> I'm having a problem with connectTo from the network library. If I connect to a server and my internet connection is reset by my ISP, there seems to be no error triggered by the network library.
08:54:14 <siracusa> So how do I detect such a reconnection then?
08:54:40 <siracusa> Provided I get a new IP, of course.
08:55:23 <miyako> I found Text.Printf, but is there anything like Text.Sprintf? I need to have a function: foo :: Int -> Int -> String that words like: foo 3 7 = "007"
08:56:00 <miyako> I could write it myself of course, but it seems like the sort of thing that probably exists in a library and I'm just failing at google
08:56:00 <copumpkin> printf is sprintf
08:56:06 <monochrom> printf doubles as sprintf. use the return type to control
08:56:16 <monochrom> > printf "hi" :: String
08:56:16 <copumpkin> > printf "ohai %s %d moo" "lol" 5 :: String
08:56:17 <lambdabot>   "ohai lol 5 moo"
08:56:17 <lambdabot>   "hi"
08:56:33 <monochrom> printf "hi" :: IO ()  would be the I/O version
08:56:35 <miyako> ah, okay, I thought printf returned IO ()
08:56:44 <copumpkin> I kind of dislike that it works that way
08:56:55 <hpc> miyako: easy mistake to make; the type hackery of printf is ridiculous
08:57:09 <monochrom> it's evil type class hack to get the overloading.
08:57:27 <hpc> the final values you can make with a printf call are:
08:57:28 <monochrom> or clever type class skill if you will
08:57:28 <hpc> IsChar c => PrintfType [c]	
08:57:29 <hpc> PrintfType (IO a)
08:57:54 <monochrom> is haskell exciting?
08:57:56 <monochrom> err
08:57:58 <monochrom> isn't haskell exciting?
08:58:10 <Olathe> is haskell exciting? not
08:58:18 <Olathe> Oh, wait.
08:58:36 <Olathe> not . exciting? $ haskell
08:58:47 <hpc> haskell is too predictable with it's well-defined semantics
08:59:03 <hpc> now GCC C with warnings disabled... that's interestig
08:59:28 <monochrom> with warnings enabled it's just as exciting
08:59:44 <monochrom> especially if you > /dev/null etc
08:59:51 <hpc> nah, because then you know where you are doing dangerous things
09:00:00 <monochrom> actually watching the warnings scroll is exciting too
09:00:10 * hackagebot numeric-prelude 0.2.2.1 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.2.2.1 (HenningThielemann)
09:00:40 <hpc> real men write their programs as iterated perl quines with side effects
09:00:44 <hpc> run once to do step 1
09:00:47 <hpc> run the output to do step 2
09:00:48 <hpc> etc
09:01:48 <monochrom> that defeats the purpose of electronic computers. it's no different from punch cards and weaving machines
09:01:56 <TheLemonMan> err, how do i convert a string into a Word8 array ?
09:01:57 <Olathe> Real men write iterated perl quines to automate that process.
09:02:09 <TheLemonMan> a simple "test" :: [Word8] didnt do the trick
09:02:14 <Olathe> TheLemonMan: fromIntegral, ord
09:02:15 <dmwit> TheLemonMan: Use the "encoding" package.
09:02:19 <dmwit> ?hackage encoding
09:02:19 <lambdabot> http://hackage.haskell.org/package/encoding
09:02:30 <dmwit> Olathe--
09:02:38 <Olathe> Olathe:(
09:03:00 <Olathe> > let f :: String -> [Word8]; f = map (fromIntegral . ord) in f "ZOMG olathe-- :(:(:("
09:03:00 <lambdabot>   [90,79,77,71,32,111,108,97,116,104,101,45,45,32,58,40,58,40,58,40]
09:03:19 <mauke> > let f :: String -> [Word8]; f = map (fromIntegral . ord) in f "ZOMG √≥lathe-- :(:(:("
09:03:29 <lambdabot>   [90,79,77,71,32,243,108,97,116,104,101,45,45,32,58,40,58,40,58,40]
09:03:29 <dmwit> > let f :: String -> [Word8]; f = map (fromIntegral . ord) in f "NO\1234"
09:03:29 <lambdabot>   [78,79,210]
09:03:29 <Olathe> Haha
09:03:47 <Olathe> Yeah, it destroys the lovely UTF-ness
09:03:48 <TheLemonMan> good, thanks
09:04:06 <Olathe> If you're going to be getting anything exciting, use the encoding package.
09:04:21 <dmwit> If you think you're not going to get anything exciting, you're wrong.
09:04:38 <Olathe> Thus, use the encoding package.
09:04:41 <Olathe> QED.
09:05:06 <TheLemonMan> im gonna use only ascii, this is more than enought
09:05:28 <KirinDave> Ha.
09:05:36 <dmwit> Don't say we didn't warn you.
09:05:38 <monochrom> I'm tired of refuting that
09:05:58 <dmwit> yeah
09:06:38 <Olathe> It's like those laptop manufacturer commercials. He puts in map (fromIntegral . ord), it gets Japanese, and some GPS explodes and a car goes over a cliff.
09:07:46 <TheLemonMan> then thanks god urls don't use utf16
09:07:47 <monochrom> well, it some rare cases it's kind of true. that is, you write the code today, then tomorrow your disk crashes and you completely lose the code, so during its lifetime it has only worked on ascii and then never sees the light of the day again
09:08:05 <Olathe> http://www.youtube.com/watch?v=gNHL-APd6dQ
09:09:05 <Olathe> Are there types in Hackage somewhere for URLs?
09:09:25 <Olathe> With like nice parsing stuff and so on?
09:10:42 <monochrom> non-ascii urls are on the rise
09:10:49 <Physicist> hi
09:10:54 <hpaste> Physicist pasted ‚ÄúIs it FPE?‚Äù at http://hpaste.org/51782
09:12:25 <Guest17646> Is http://hpaste.org/51782 this floating point error or something else? I asked it a few hours ago and now asking again
09:12:28 <monochrom> > 1 / 0 :: Double
09:12:28 <lambdabot>   Infinity
09:12:39 <monochrom> you get that for division by zero
09:12:41 <hpc> > 0 / 0
09:12:42 <lambdabot>   NaN
09:12:43 <Olathe> monochrom: That's true.
09:13:07 <monochrom> and that, too. you don't get numbers for FPE. (under default settings)
09:13:13 <monochrom> > (0/0) + 1
09:13:14 <lambdabot>   NaN
09:13:17 <monochrom> no wild number
09:14:04 <monochrom> wild numbers would be from numerically unstable algorithms
09:14:48 <buntfalke> Is the left-arrow "<-" in "one <- return 1" and "[x|x<-myList,x>0]" related except for the mere characters? As in: Is the <- within [|] related to monads, too?
09:14:57 <dmwit> TheLemonMan: http://stackoverflow.com/questions/2742852/„Åì„Çå„ÅØ„ÄÅ„Åì„Çå„ÇíÊó•Êú¨‰∫∫„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Åß„Åô
09:15:08 <monochrom> ha!
09:15:24 <byorgey> Guest17646: hmm, it seems like probable numeric error to me... the result agrees with myPoly very well in the high-order terms and then gets less and les accurate towards the lower-order terms
09:15:43 <byorgey> I mean numeric instability, not numeric error
09:16:00 <byorgey> buntfalke: yes, it is related
09:16:32 <buntfalke> byorgey: but "myList" in the example above is not an instance of Monad?
09:16:41 <dmwit> instance Monad [] where
09:16:45 <dmwit> Surprise!
09:16:46 <byorgey> buntfalke: in fact, in the next version of GHC the  [ ... | ... <- ... ] notation will be generalized from just lists to all monads
09:16:54 <byorgey> buntfalke: the list type is an instance of Monad
09:16:57 <Guest17646> byorgey: isn't it too wild
09:17:05 <buntfalke> dmwit, byorgey: Oh, wow...
09:17:06 <rwbarton> (which one is "the next" one? 7.4?)
09:17:09 <buntfalke> Thanks!
09:17:19 <monochrom> 7.2 already does monad comprehension
09:17:21 <Guest17646> and anything about how to control this type of thing
09:17:26 <byorgey> oh does it? neat!
09:17:42 <byorgey> Guest17646: it does seem rather wild.  I don't know, try emailing the author of that package (James Cook)
09:17:54 <parcs> Olathe: url
09:17:54 <Olathe> Apparently, they have some kind of IRI thing for internationaly URLs: http://en.wikipedia.org/wiki/Internationalized_Resource_Identifier
09:18:15 <Olathe> parcs: Ahh, thanks
09:19:35 <Guest17646> <byorgey> and know what it just repeated the thing  in matlab
09:19:46 <byorgey> hah, really?
09:19:49 <Guest17646> and there it was even worse
09:20:01 <byorgey> floating point math is hard, let's go shopping!
09:20:36 <Olathe> Money shouldn't use floating point, so I like your suggestion!
09:20:45 <dmwit> Guest17646: Can you use Rational instead of Float/Double?
09:20:55 <monochrom> indeed, for your shopping pleasure, monetary values are computed in binary-coded decimal
09:21:05 <Olathe> Yay!
09:21:14 <dmwit> Guest17646: There's never error with Rational, though you take a fairly significant speed hit, since it's software-based, not hardware-based.
09:21:22 <Guest17646> Rational would solve the problem
09:21:38 <monochrom> x87 supports bcd because banks demand it!
09:21:49 <dmwit> > -2.725965290264823 :: Rational
09:21:50 <lambdabot>   (-2725965290264823) % 1000000000000000
09:21:53 <dmwit> heh
09:22:18 <Guest17646> but isn't it disturbing that results can be this wrong
09:22:20 <monochrom> it's rather hard to do hardware-based rationals :)
09:22:22 <byorgey> > toRational pi
09:22:23 <lambdabot>   884279719003555 % 281474976710656
09:22:48 <byorgey> Guest17646: yes. yes, it is.
09:23:03 <Guest17646> and the thing with efficiency means no extensive numerical simulation
09:23:04 <monochrom> it is about as disturbing as the fact that programs can have bugs
09:23:08 <dmwit> > 3.141592653589793238462643383279502884 :: Rational
09:23:09 <lambdabot>   785398163397448309615660845819875721 % 250000000000000000000000000000000000
09:23:12 <Olathe> pi is irrational, so it should give something like that as a result.
09:23:26 <byorgey> dmwit: wait, what?
09:23:31 <hpc> > toRational (pi :: CReal)
09:23:32 <lambdabot>   *Exception: CReal.toRational
09:23:39 <dmwit> byorgey: hmmm?
09:23:41 <hpc> well that was no fun
09:23:44 <Olathe> You wouldn't expect rationality from that.
09:24:02 <byorgey> dmwit: I didn't know you could get that much precision with a floating-point constant with type Rational
09:24:26 <dmwit> You get arbitrary precision.
09:24:30 <incluye> > pi :: CReal
09:24:31 <lambdabot>   3.1415926535897932384626433832795028841972
09:24:43 <byorgey> wooooaah  <-- Keanu Reeves
09:24:45 <incluye> Impressive precision
09:24:49 <dmwit> It's read as a Rational first, then truncated to fit within Double/Float after.
09:24:50 <incluye> o_o
09:24:51 <rwbarton> "floating-point constants" are really rational contants
09:25:00 <Olathe> > cycle "Something really long. "
09:25:01 <lambdabot>   "Something really long. Something really long. Something really long. Somet...
09:25:07 <dmwit> > fromRational 3.1415 :: Double
09:25:08 <lambdabot>   3.1415
09:25:36 <Olathe> > toRational (3.1415 :: Double)
09:25:37 <lambdabot>   7074029114692207 % 2251799813685248
09:25:40 <Olathe> Lies!
09:25:47 <Olathe> > floor $ toRational (3.1415 :: Double)
09:25:48 <lambdabot>   3
09:25:52 <dmwit> heh
09:26:12 <Olathe> > 4%5
09:26:13 <lambdabot>   4 % 5
09:26:16 <dmwit> > round (pi * 10000) / 10000
09:26:17 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:26:17 <lambdabot>    `GHC.Real.Integral b'
09:26:17 <lambdabot>   ...
09:26:18 <Olathe> Okey dokey
09:26:39 <dmwit> > fromIntegral (round (pi * 10000)) / 10000
09:26:40 <lambdabot>   3.1416
09:26:41 <Olathe> Someone broke Rational's show.
09:26:49 <dmwit> What?
09:27:05 <Olathe> > 4%5
09:27:06 <lambdabot>   4 % 5
09:27:12 <dmwit> What's wrong with that?
09:27:16 <monochrom> @let increase = 100 :: Integer
09:27:18 <lambdabot>  Defined.
09:27:18 <Olathe> It's missing a denominator.
09:27:23 <Olathe> Unless my client is messed up.
09:27:23 <incluye> 5?
09:27:24 <monochrom> > 4% increase
09:27:26 <lambdabot>   1 % 25
09:27:29 <Olathe> Ahh, I see.
09:27:30 <monochrom> \‚à©/
09:27:30 <dmwit> Olathe: Your client is messing up.
09:27:34 <Olathe> Oh, OK :)
09:27:38 <Olathe> I'll look at it.
09:27:40 <incluye> > 200% increase
09:27:42 <lambdabot>   2 % 1
09:27:44 <dmwit> It shows both 4 and 5 here.
09:27:47 <incluye> > 134.6% increase
09:27:48 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
09:27:48 <lambdabot>    arising f...
09:27:58 <parcs> > toRational (22/7)
09:27:59 <lambdabot>   7077085128725065 % 2251799813685248
09:28:06 <parcs> :(
09:28:11 <byorgey> > read (show (4%5)) :: Rational
09:28:12 <lambdabot>   4 % 5
09:28:14 <dmwit> > 22/7 :: Rational -- parcs
09:28:15 <lambdabot>   22 % 7
09:28:15 <buntfalke> Can I implement an "instance Monad allWrong where" the operators do not behave as the Monad Laws actually require it? Or does the Compiler somehow check on that?
09:28:32 <Saizan>  it doesn't
09:28:33 <monochrom> no check
09:28:34 <byorgey> buntfalke: the compiler does not check.  #haskell checks.
09:28:38 <buntfalke> Thanks
09:28:38 <dmwit> buntfalke: Yes, you can. The compiler doesn't (can't!) check.
09:28:49 <byorgey> we know where you live.
09:28:53 <Philippa> my Haskell Platform download appears to be missing documentation for mtl modules (and probably other stuff outside base), where should I go complain?
09:29:10 <buntfalke> byorgey: I'll be good, promised!
09:29:15 <byorgey> ;-)
09:29:28 <dmwit> Philippa: Go to the Haskell Platform home page and click "Problems?".
09:29:32 <dmwit> troll-platform
09:30:11 <byorgey> buntfalke: this is actually an interesting limitation of Haskell's type system.  Some dependently typed language (e.g. Agda, Coq) can actually require you to provide a *proof* that your instance satisfies the required laws.
09:30:22 <buntfalke> dmwit: Well, some basic things like wether "y <- return x" ends up with y == x could be done. But it would be required to be hardcoded, as there is no way to express constraints in the definition of class Monad and thus is ugly and wont be done?
09:31:08 <dmwit> return is an arbitrary function
09:31:18 <dmwit> Checking any non-trivial property of it is undecidable.
09:31:22 <dmwit> (Rice's Theorem.)
09:31:39 <dmwit> non-trivial here means "there is some function which has the property and some function which does not have the property".
09:31:59 <byorgey> although for many instances of Monad I could easily imagine an automatic theorem prover actually verifying the monad laws.
09:32:05 <dmwit> Indeed.
09:32:13 <byorgey> even though it is not possible in general.
09:32:24 <Philippa> dmwit: cheers. Looks like it's a known problem for win32: I'll be seriously unhappy if it's still broken in the next release, and tbh someone should've put up a patched win32 installer with the extra docs
09:32:47 <dmwit> bummer
09:32:49 <buntfalke> dmwit: How so? I could write "monadIsFine x = x == y where y <- return x" and that would test at least one aspect of the instance, wouldnt it?
09:32:50 <dmwit> I hope it's fixed up soon.
09:33:02 <dmwit> buntfalke: That's not even syntactically well-formed.
09:33:10 <Philippa> it's marked critical and for the next release, but it looks like it'll be the next big Platform release :-(
09:33:19 <byorgey> buntfalke: even if it were, that would only test it for whatever particular values of x you input.
09:33:38 <buntfalke> byorgey: Oooooh...that's quite true.
09:33:40 <buntfalke> Thanks
09:34:26 <monochrom> in the absence of proving, the programmer desperately turns to testing
09:35:19 <byorgey> buntfalke: however, doing randomized testing to try to falsify monad laws (or laws for other classes) is a good idea
09:35:31 <byorgey> buntfalke: and this approach has been coded in the 'checkers' package
09:35:36 <byorgey> http://hackage.haskell.org/package/checkers
09:35:40 <Philippa> dmwit: it looks like the versioning scheme also doesn't allow for platform-specific patchlevels to the Platform
09:35:56 <buntfalke> byorgey: Thanks, nice hint
09:35:58 <dmwit> Versioning is hard.
09:37:06 <dmwit> Philippa: Did you see this thread? http://www.reddit.com/r/linux/comments/knffw/well_thats_just_outright_confusing/ =P
09:51:53 <Masxmasx{AFK}> Is it possible to define a function multiple times, for different amounts of parameters?
09:52:30 <flux> masxmasx{afk}, haskell doesn't have overloading. it does have type classes, though, but it's not quite the same thing.
09:53:37 <mauke> Masxmasx{AFK}: why not just use different names?
09:53:54 <Masxmasx{AFK}> because it's an assignment, and I figured it'd look nicer this way
09:54:03 <monochrom> please use different names
09:54:12 <dmwit> Don't listen to monochrom, do type classes.
09:54:12 <mauke> s/nicer/confusinger/
09:54:15 <dmwit> You know you want to.
09:54:20 <dmwit> LISTEN TO YOUR HEART
09:54:27 <Masxmasx{AFK}> lol
09:54:29 <mauke> class ‚ô•
09:54:43 <monochrom> the type class trick for varargs requires an extension IIUC
09:54:55 <mauke> no, printf is H98
09:54:59 <dmwit> psh, only if you don't know how many args there are statically
09:55:06 <monochrom> oh, no need for OverlappingEvilness?
09:55:15 <mauke> no, it's pretty simple stuff
09:55:22 <monochrom> ok, then do it
09:55:39 <mauke> I think it only makes sense for an arbitrary number of parameters
09:55:42 <dmwit> class MyEvilClass a where function :: a; instance MyEvilClass (Int -> Int -> Double) where; instance MyEvilClass (Int -> Int -> Int -> Double) where
09:55:50 <mauke> not "I want this thing to take 2, 3, or 5 parameters"
09:56:07 <Masxmasx{AFK}> okay this is getting too complicated. But thanks guys/gals :)
09:56:24 <mauke> dmwit: those don't look like valid instances
09:56:26 <dmwit> One line is too complicated.
09:56:27 <dmwit> sigh
09:56:35 <monochrom> things doable in Haskell 98 are not complicated
09:56:46 <Masxmasx{AFK}> for what I want to do it is, dmwit
09:56:47 <mauke> hah
09:56:48 <dmwit> mauke: Yeah, probably needs FlexibleInstances or something.
09:57:46 <siracusa> connectTo doesn't seem to yield an error if the connection is reset by the ISP (with a new IP). Is that intended?
09:59:27 <monochrom> I think you should reword it
10:02:46 <Olathe> > 4%5
10:02:47 <lambdabot>   4 % 5
10:02:48 <Olathe> Yay!
10:02:54 <siracusa> monochrom: The problem is I connect to an server via connectTo. Now my internet connection is reset by my ISP and I get a new dynamic IP address. I think the connection to the server should now also be reset, as I have a completely different IP address.
10:03:05 <mauke> > 0.8 :: Rational
10:03:06 <lambdabot>   4 % 5
10:03:18 <Olathe> > toRational pi
10:03:19 <lambdabot>   884279719003555 % 281474976710656
10:03:47 <siracusa> monochrom: But no error occurs and I don't get new any packets from the server. I want to detect this this reconnection somehow.
10:04:45 <rwbarton> if you try sending something on your connection you should get a RST from the server
10:04:52 <rwbarton> otherwise, indeed nothing will happen
10:06:13 <siracusa> But if I just pull out my network cable while connected an error occurs. Why in this case but not in case of a new IP?
10:06:52 <rwbarton> well those are very different
10:07:04 <rwbarton> the "new IP" isn't something your computer knows about at all
10:07:22 <rwbarton> assuming you are behind a NAT?
10:07:25 <FUZxxl> Why can't I see the instance of IsString for Data.ByteString.Lazy?
10:07:34 <rwbarton> I guess you might not be, then I don't know
10:08:19 <siracusa> rwbarton: behind a router, yes
10:08:20 <jwpowell> can anyone give me an example of using safeSpawnProg for XMonad?
10:08:40 <Olathe> > toRational (0.8 :: Double)
10:08:40 <lambdabot>   3602879701896397 % 4503599627370496
10:08:48 <jwpowell> i've installed xbindkeys (to launch dmenu) but only want to run it when I'm starting XMonad
10:08:59 <rwbarton> well in that case, your computer's IP is some fixed address on a local IP address space like 10.*.*.*, and it's the router's external IP address that changes... how would your computer learn about this
10:09:24 <jwpowell> so I figure running safeSpawnProg "xbindkeys" in my xmonad.hs would work
10:09:29 <Olathe> rwbarton: By asking a computer what address your packets are coming from.
10:09:37 <Olathe> rwbarton: Like whatismyip.com or something.
10:09:52 <rwbarton> well sure, but the OS's TCP stack isn't going to do that
10:10:04 <Olathe> rwbarton: No, it won't.
10:10:18 <siracusa> I see. So sending something is the only way to detect that?
10:10:41 <rwbarton> actually I'm a little surprised that even physically disconnecting your network cable breaks connections immediately
10:10:48 <rwbarton> is this a windows thing?
10:11:04 <Olathe> rwbarton: Yeah, that happens on Windows.
10:11:11 <siracusa> No immediately but after about 30 seconds or so
10:11:51 <Olathe> siracusa: Yeah, pretty much. Since the router translates everything transparently to you, you have to ask a computer past your router.
10:12:26 <siracusa> Okay, thank you all for the help.
10:12:27 <Olathe> siracusa: Some routers allow you to ask them as well what their external address is.
10:12:45 <rwbarton> (how often does your IP change your address anyways? mine changes on the order of every few months)
10:12:51 <rwbarton> er, your ISP
10:13:01 <siracusa> each 24 h
10:13:07 <Olathe> This is why lots of people use dynamic DNS services.
10:13:15 <buntfalke> siracusa: sounds German ;-)
10:13:26 <siracusa> Yeah :-)
10:13:36 <Olathe> They get a name, a service on their computer updates it every so often with the DNS provider, and the name stays consistent regardless of IP address.
10:13:39 <buntfalke> 24h-Trennung, my ass! :-) Same here.
10:15:36 <any-key> Disregarding the bad spacing, when I call the following function I get a non-exhaustive pattern error at runtime...I know it's because of the way I'm recursing, but I'm not sure what pattern I'm missing. http://pastebin.com/KbewVvB8
10:15:38 <mauke> The paste KbewVvB8 has been copied to http://hpaste.org/51783
10:16:23 <any-key> it would make sense that the last pattern matched would be [foo]:[[]] and then it would get called with [[]] which I have a pattern for, but apparently that is not the case
10:17:51 <rwbarton> why would the last element of board be an empty list?
10:18:03 <mauke> any-key: [] is missing
10:18:13 <any-key> Board is [[Bool]]
10:18:19 <any-key> heh
10:18:42 <rwbarton> the empty list of type [[Bool]] is still []
10:18:43 <mauke> your two patterns are ([] : []) and (x : board)
10:18:52 <mauke> missing: []
10:18:55 <any-key> heh, I wasn't thinking about that correctly
10:19:02 <any-key> well that works, thanks
10:19:32 <any-key> I guess the issue now is the fact that the final iteration will append [] to the end rather than doing nothing
10:23:45 <any-key> never mind, fixed it
10:23:48 <any-key> thanks for the help!
10:50:11 <sYnfo> test
10:51:25 <tgeeky> sYnfo: it's not working
10:51:53 <sYnfo> How come you are answering then ^^
10:52:23 <Philippa> I have a confusing type error
10:52:28 <Philippa> I define this: class Solveable s e where...
10:52:42 <Philippa> and just below it, this: class (Solveable s e) => ConstraintSet s c where ...
10:52:52 <Philippa> apparently the e in the latter line is out of scope. WTF?
10:53:42 <edwardk> s e and s c ?
10:54:21 <edwardk> the one on the lower line _is_ out of scope
10:54:35 <edwardk> you can have class Solvable s e | s -> e and make it work
10:54:37 <edwardk> or you can
10:54:47 <edwardk> class Solvable s c => ConstraintSet s c where
10:54:55 <edwardk> but as written it has no idea what e to choose
10:55:45 <edwardk> alternatately class Solvable s, class Solvable s => ReallySolvable s e; class Solvable s => ConstraintSet s c
10:55:56 <edwardk> depending on what relations you are trying to encode
10:58:20 <Philippa> edwardk: d'oh, missed that. Actually I should probably drop the relationship to Solveable outright: some instances of addConstraint might give a shit, but they can resolve it between themselves and s
10:58:35 <edwardk> *nods*
11:00:24 <Philippa> the error message is spectacularly unhelpful in that situation though - cheers for telling me where I screwed up :-)
11:16:53 <tsousa> Hello i dont understand what => means
11:17:01 <tsousa> can someone explain to me please?
11:17:17 <monochrom> it separates type class constraints from the rest of the type
11:17:28 <rostayob> tsousa: in a type signature, before declaring the types, you can put constraints on classes
11:17:40 <rostayob> well put constraints on the types
11:17:59 <rostayob> so show :: Show a => a -> String, means that 'a' must be an instance of the class Show
11:18:08 <monochrom> example: Num a => a -> a. I think you know the a->a part. so the other part says "I require 'a' to be an instance of Num"
11:19:01 <rostayob> you can also have multiple type classes, e.g. fromIntegral :: (Integral a, Num b) => a -> b. a must be an instance of Integral, and b must be an instance of Num
11:19:08 <byorgey> dmwit: I came up with something better: \p f x -> f x <$ guard (p x)
11:19:21 <byorgey> dmwit: or even  \p f -> liftA2 f (guard.p)
11:19:33 <edwardk> byorgey: that operation needs a name =P
11:19:44 <byorgey> dmwit: I mean, \p f -> liftA2 (<$) f (guard.p)
11:19:52 <byorgey> edwardk: which one? the whole thing I just wrote?
11:20:01 <edwardk> byorgey: or better still Alternative m => (a -> Maybe b) -> a -> m b
11:20:07 <edwardk> yes
11:20:21 <tsousa> rostayob, yes constraints on classes is what i dont understand
11:20:31 <byorgey> edwardk: I agree, I was just trying to figure out a nice way to write it
11:20:51 <rostayob> tsousa: first, do you know what a type class is?
11:21:02 <edwardk> the benefit of the Maybe version is you don't have to use a partial function for the map
11:21:14 <byorgey> edwardk: Alternative m => (a -> Maybe b) -> a -> m b  would be nice too, but then I'd still want a nice way to turn predicates into success or failure
11:21:40 <byorgey> edwardk: oh, I see what you're saying, in my case the function would always be total anyway, but yes
11:21:43 <rostayob> tsousa: try typing ":info Num" in the ghci prompt. You'll see the class methods (in this case +, *, etc) and the relative type signatures. then you'll se types that are instances of that type class
11:22:18 <rostayob> so a type class is just a set of functions with a type parameter
11:22:46 <mauke> tsousa: classes are constraints on types
11:22:47 <rostayob> anwyay I have to go, I suggest you read
11:22:55 <rostayob> @where LYAH
11:22:56 <lambdabot> http://www.learnyouahaskell.com/
11:24:16 <tsousa> yes i am reading LYAH but i dont understand that
11:29:21 <monochrom> type class is our way to set up operator overloading and function overloading (same difference)
11:30:35 <monochrom> so that for example if you define your own data type and you want "+" to work for it too, it is allowed, you just have to write type class code
11:32:06 <tsousa> humm
11:33:06 <cgroza> Hello everyone. I have problems understanding tho role of =<< in this expression : main = mapM_ (BS.hPutStrLn stdout) =<< fmap (nub . BS.lines) (BS.readFile "test.py")
11:33:28 <k0ral> why isn't Haskell lazy with imports ?
11:33:49 <k0ral> is there a technical issue or is it a choice ?
11:34:27 <monochrom> it is the same as: main = fmap (nub . BS.lines) (BS.readFile "test.py") >>= mapM_ (BS.hPutStrLn stdout)
11:34:48 <monochrom> if you don't know >>= either, I can write it in do-notation
11:35:04 <cgroza> monochrom: ok. give me a sec to think about.
11:36:27 <dolio> What does "lazy with imports" mean?
11:37:02 <monochrom> it means that if you import X but none of the instances defined in X are used, the computer skips X
11:37:15 <cgroza> monochrom: thanks. I get it now. I was confused because the partial application of mapM_ was not obvious in the =<< version.
11:37:17 <parcs> there's a warning for that
11:37:52 <k0ral> yes but I'm in a situation where it complains about an import cycle while, if you consider the actually used imports, there is none
11:38:18 <k0ral> file A imports B only for a part of it
11:38:25 <k0ral> file B imports A only for a part of it
11:39:04 <k0ral> hmmm, replace that last statement with: part of B imported by A don't require to import A but the rest of file B does
11:39:50 <k0ral> if it was lazy enough, it would only try to import things when they are used, and in my case, no cycle would be "triggered"
11:40:02 <rwbarton> You can do this somehow with ghc but I hear it's kind of a pain.
11:40:31 <k0ral> not sure I explained it that well, do you need a cleared description ?
11:40:33 <rwbarton> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/separate-compilation.html#mutual-recursion
11:40:35 <k0ral> maybe with an example ?
11:42:09 <k0ral> rwbarton: it's painful indeed :)
11:42:13 <cgroza> k0ral: maybe because it is not implemented because it is not worth the trouble.
11:43:13 <k0ral> cgroza: 2 things matter in what you said
11:43:33 <k0ral> 1/ it is not implemented : ok, then I know I need to find another way of doing
11:44:10 <k0ral> 2/ it's not worth the trouble : then why would they have bothered with lazyness in Haskell in the first place ? :)
11:45:16 <rwbarton> well, it is basically implemented, as you saw
11:46:26 <cgroza> k0ral: imagine there are 2 unqualified imports with the same functions, and the compiler encounters one. Which module should it load?
11:47:02 <cgroza>  and stoping during execution to load modules is not efficient.
11:47:15 --- mode: ChanServ set +o mauke
11:47:15 --- mode: mauke set +b $a:frendshipismagic
11:47:21 <hpc> lazy evaluation and lazy imports aren't the same thing
11:47:29 <hpc> more generally, evaluation /= importing
11:47:32 <rwbarton> the bigger issue would be cross-module typechecking
11:47:41 <hpc> if it did, we would have a pythonic import-runs-code system
11:48:00 <k0ral> but could we still imagine the same lazyness behavior with imports  ?
11:48:05 --- mode: mauke set -o mauke
11:48:43 <k0ral> cgroza: it loads the first one :)
11:49:12 <k0ral> cgroza: after all, that's what we do for example with multiple pattern-matching that would collide
11:49:19 <rwbarton> no
11:49:25 <rwbarton> but modules aren't "loaded" at runtime anyways
11:49:46 <k0ral> I mean during compilation for imports
11:50:03 <rwbarton> currently if you use an unqualified name that exists in two different imports, you get an error
11:50:12 <rwbarton> that wouldn't be any different
11:50:50 <cgroza> k0ral: the module code must be known at compile time for linkage.
11:51:00 <k0ral> I don't know the internal machinery of imports but I can't understand why would this be impossible
11:51:24 <cgroza> So you would need to wait until runtime to find and load the module...
11:51:25 <dolio> The issue is, I think that GHC tries to use modules as units of compilation.
11:51:29 <rwbarton> but in any case, the answer to your questions are (2) you can work around it with .hs-boot files, (1) mutually dependent modules aren't fully implemented in GHC because hardly anyone ever needs them
11:51:43 <dolio> So if A imports B, it checks B first.
11:51:49 <k0ral> cgroza: yes but what if the compiler kept track of "dependencies" between function definitions ?
11:52:01 <rwbarton> right, and you'd have to typecheck two mutually dependent modules simultaneously
11:52:08 <dolio> If two things are mutually dependent, it needs to check them both together, which breaks its compilation model.
11:52:18 <dolio> So you need a special helper.
11:52:39 <rwbarton> it wouldn't be impossible to work around this, and in fact I think some other Haskell compilers do support mutually recursive modules correctly (?)
11:53:07 <cgroza> k0ral: imagine a real-time program. It would need to stop and load the module.... you can't afford that...
11:53:24 <k0ral> wait a minute
11:53:38 <k0ral> I4m not following everything you all said
11:53:40 <rwbarton> modules are all statically linked together, at least as of recently
11:53:41 <k0ral> I'm*
11:53:46 <k0ral> I'm just saying
11:54:11 <k0ral> if file A only needs some functions from file B, but not all
11:54:28 <k0ral> can't the import system only import what file A needs ?
11:54:45 <rwbarton> well of course, but it has to compile B before A then
11:55:30 <rwbarton> it has no mechanism to compile "only the parts of B needed by A"
11:56:03 <k0ral> from what you all said, it seems like an odd idea, is it ?
11:57:04 <rwbarton> Automatic support for mutually recursive modules is a perfectly fine idea, it's just low on the priority list of features to be added to GHC.
11:57:05 <k0ral> that's a pity, I have one little function A needs from B, and I'll have to put it in a different file, which is kinda ugly
11:57:39 <k0ral> just not to import B from A
11:57:44 <rwbarton> can't you just put it in A then
11:58:10 <alpounet> maybe that function just should not belong to B
11:58:12 <k0ral> it would be semantically wrong
11:58:52 <rwbarton> okay, that's a bit hard to imagine but in that case you need a separate module, yes
11:59:07 <k0ral> fair enough :)
12:00:21 <Cale> k0ral: A lot of projects end up with a separate module (or some separate modules) for type definitions.
12:00:51 <Cale> um, I guess that doesn't cover your case exactly, but it's a common reason for circular deps.
12:01:39 <k0ral> Cale: yes, I also ran into that problem of the types definition long ago
12:01:47 <cbarrett> Anyone have a free minute or two to lear up some SYB generics questions I have?
12:02:08 <k0ral> Cale: my current problem is different but I'm ending up putting it in a different module
12:02:17 <mauke> cbarrett: ask first, ask to ask later
12:02:20 <mauke> where later = never
12:02:25 <cbarrett> heh
12:04:19 <cbarrett> so I'm attempting to write a function using SYB that scans the immediate subterms of a map (i.e. pairs) and looks for a specific key and returns the result or a default value. Essentially a more polymorphic version of !.
12:04:41 <Olathe> What's SYB?
12:04:50 <cbarrett> Scrap Your Boilerplate.
12:04:55 <cbarrett> Data.Generics.
12:04:56 <cbarrett> Etc.
12:05:43 <cbarrett> The map itself looks like SomeTypeclass a => Map String a, and I have instances for Int64, SomeTypeclass a => [a] and SomeTypeclass a => Map String a. (I'm writing a binding for a C library)
12:06:02 <cbarrett> (which library has its own collection classes that I need to bridge over :\)
12:06:10 <mauke> that looks like a normal map to me
12:06:15 <mauke> why can't you use ! ?
12:07:20 <cbarrett> because if you try to access two keys of different types (but still instances of SomeTypeclass) it will type error. For example Int64 and [Int64].
12:07:28 <tsousa> i think i get it. if you declare an int that variable will be able to use +,-,/* and other methods right?
12:07:41 <tsousa> if i dont use int it will not be available right?
12:08:06 <mauke> tsousa: ?
12:08:21 <mauke> cbarrett: that doesn't make sense
12:08:27 <mauke> cbarrett: either you have a map or not
12:08:31 <mauke> cbarrett: if you do, ! works
12:08:40 <mauke> cbarrett: if not, writing a more polymorphic ! won't help you
12:08:51 <tsousa> like if you declare and Int value the type class will be that int some methods like +,-,/,* right?
12:09:26 <mauke> I don't need to declare anything
12:10:08 <tsousa> yes but the typeclasses is that give Int is +,-,* and / right?
12:10:13 <mauke> yes
12:10:24 <mauke> except for /
12:10:29 <mauke> Int doesn't do /
12:10:54 <tsousa> no? so how i cand divide an number?
12:11:04 <Olathe> div
12:11:13 <Olathe> quot
12:11:15 <mauke> tsousa: depends on what you mean by "divide" and "number"
12:11:28 <cbarrett> mauke: Perhaps I'm not explaining it right. Some actual code + error messages incoming.
12:11:29 <mauke> :t (/)
12:11:30 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:11:32 <mauke> :t div
12:11:33 <lambdabot> forall a. (Integral a) => a -> a -> a
12:11:47 <tsousa> mauke, 4/2 = 2
12:11:55 <tsousa> humm ok
12:11:55 <mauke> tsousa: that doesn't help
12:11:57 <rwbarton> what is 5/3
12:12:00 <mauke> tsousa: what is 1/3?
12:12:39 <tsousa> is a fraction
12:12:58 <mauke> then you want / and Rational
12:13:04 <mauke> > 1/3 :: Rational
12:13:04 <lambdabot>   1 % 3
12:13:13 <mauke> > 10/4 :: Rational
12:13:14 <lambdabot>   5 % 2
12:13:25 <hpaste> cbarrett pasted ‚Äúpolymorphic map‚Äù at http://hpaste.org/51785
12:13:27 <mauke> > 1/3 :: Double
12:13:28 <lambdabot>   0.3333333333333333
12:13:32 <Olathe> > fromIntegral 1/fromIntegral 3
12:13:33 <lambdabot>   0.3333333333333333
12:13:34 <mauke> > 1 `div` 3 :: Int
12:13:35 <lambdabot>   0
12:13:40 <Olathe> > fromIntegral 1/fromIntegral 3 :: Rational
12:13:41 <lambdabot>   1 % 3
12:13:43 <tsousa> mauke, thanks
12:13:54 <mauke> Olathe: why fromIntegral?
12:14:11 <Olathe> mauke: If he has Ints to start with.
12:14:37 <Olathe> :t (%)
12:14:38 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
12:14:44 <Olathe> Ahh, that would work, too :)
12:14:56 <Olathe> > (1 :: Int) % (3 :: Int)
12:14:57 <lambdabot>   1 % 3
12:15:36 <mauke> cbarrett: did the other version actually work or did it just compile?
12:16:15 <ion> > ((/) `on` fromIntegral) 1 3
12:16:16 <lambdabot>   0.3333333333333333
12:16:47 <ion> Although that doesn‚Äôt work as intended if the two values are of separate types.
12:16:58 <cbarrett> mauke: actually worked.
12:17:06 <mauke> wtf
12:17:41 <mauke> you must have two separate maps
12:17:46 <cbarrett> I do not.
12:18:18 <mauke> you kind of have to
12:18:18 <rwbarton> Map is lazy in the values, right, and probably the values are of the form "read foo", so as long as you only use the right entry in the map at the right type...
12:18:35 <cbarrett> rwbarton: yes, exactly.
12:18:54 <mauke> but Map is still homogenous
12:18:55 <rwbarton> heck, you could write M.Map String (forall a. XPCable a => a)
12:19:28 <cbarrett> rwbarton: Except that you can't write an instance of XPCable for that type, since it's polymorphic.
12:19:47 <rwbarton> well, fix your fromXPC to return that type
12:19:49 <mauke> cbarrett: wouldn't it make more sense to use a variant type?
12:20:10 <cbarrett> rwbarton: it's in the typeclass.
12:20:11 <mauke> Map String (Either Int64 [Int64])
12:20:16 <rwbarton> ew
12:20:17 <rwbarton> what
12:20:38 <monochrom> I would first impeach the use of type class, yes
12:20:52 <rwbarton> fine, write a function with a different name with that type
12:21:38 <rwbarton> or use a variant, if the serialized form of one of these values tells you what its type is
12:21:43 <hpaste> cbarrett annotated ‚Äúpolymorphic map‚Äù with ‚Äúpolymorphic map (annotation)‚Äù at http://hpaste.org/51785#a51786
12:21:59 <cbarrett> Huh. That didn't work how I expected.
12:22:21 <cbarrett> rwbarton: Thanks.
12:22:24 <cbarrett> I'll give that a try.
12:22:42 <rwbarton> Can't you make Map String (forall a. XPCable a => a) an instance of XPCable a?
12:23:25 <rwbarton> anyways this is a sort of sketchy way to do things I guess
12:23:31 <cbarrett> No, the compiler complains of an "Illegal polymorphic or qualified type"
12:23:42 <cbarrett> What would you recommend instead?
12:24:30 <rwbarton> interesting
12:24:46 <rwbarton> -XReallyFlexibleInstances
12:24:51 <cbarrett> heh
12:24:52 <cbarrett> really?
12:25:01 <rwbarton> no :(
12:25:15 <monochrom> impredicative type allows Map String (forall a. XPCable a => a)
12:25:32 <monochrom> but impredicative type is pretty dead or zombie
12:25:50 <rwbarton> but not in an instance head, does it?
12:25:54 <cbarrett> Yeah and plus that doesn't even work.
12:26:08 <cbarrett> Couldn't match expected type `Int64' with actual type `forall a. XPCable a => a'
12:26:16 <monochrom> putting it in instances is an even higher level of depravity
12:26:58 <wavewave> I hope impredicative type back in ghc.
12:27:18 <rwbarton> hmm
12:27:34 <wavewave> although understanding difficulty in implementation.
12:28:23 <wavewave> I remember that grapefruit was implemented using impredicative type.
12:29:35 <cbarrett> Anyway, this is why I was hoping to use generics for this. Kind of built to operate on polymorphic data structures.
12:29:59 <wavewave> rwbarton: anyway, workaoround is using some newtype wrapper for that.
12:30:05 <rwbarton> yes
12:30:25 <rwbarton> a little ugly but not so bad if you build the extra syntax into a replacement for !
12:32:12 <wavewave> I just hope that previous decision to impeach impredicative types was due to old ghc-6 type checkers. Since we have new better ghc-7 type checker, it can come back without much headache.. my guess.
12:35:02 <rwbarton> My understanding/recollection was that impredicative types are rather a casuality of the new ghc 7 type checker
12:35:11 * hackagebot anansi 0.4.1 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.1 (JohnMillikin)
12:37:45 <Cale> Yeah, there are remnants left in there, but apparently they're broken.
12:39:06 <dolio> GHC has a bizarre notion of impredicative.
12:39:10 <wavewave> rwbarton: I am not sure about what really happpened, but my impression was that impredicative types was deprecated when ghc-6.12 came. new ghc-7 type checker engine was after it..
12:40:06 <dolio> They're broken in 7.
12:40:10 <dolio> But not deprecated.
12:40:18 <dolio> And all impredicativity is kind of broken.
12:40:22 <wavewave> I see.
12:40:27 <dolio> Not just the ImpredicativeTypes stuff.
12:40:34 <monochrom> of course, you mark it "deprecated" at version N because you plan to break it at version N+1 or later
12:42:02 <dolio> Some of the stuff that's broken isn't stuff that was deprecated.
12:42:19 <wavewave> monochrom: yeah, but ghc-7 engine appeared rather suddenly.. so I just hope that brilliant ghc implementors will figure out how to do that without much trouble with new engine. ;-)
12:42:49 <dolio> Instantiating id to (forall a. a) -> (forall a. a) wasn't deprecated, but it's broken.
12:45:11 * hackagebot ParserFunction 0.0.5 - Utilities for parsing and evaluating mathematical expressions.  http://hackage.haskell.org/package/ParserFunction-0.0.5 (EnzoHaussecker)
12:45:13 * hackagebot wumpus-core 0.52.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.52.0 (StephenTetley)
12:50:15 * hackagebot wumpus-basic 0.22.0 - Basic objects and system code built on Wumpus-Core.  http://hackage.haskell.org/package/wumpus-basic-0.22.0 (StephenTetley)
12:50:17 * hackagebot wumpus-drawing 0.7.0 - High-level drawing objects built on Wumpus-Basic.  http://hackage.haskell.org/package/wumpus-drawing-0.7.0 (StephenTetley)
12:50:19 * hackagebot wumpus-tree 0.18.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.18.0 (StephenTetley)
13:27:25 <cgroza> > @type mapM
13:27:26 <lambdabot>   <no location info>: parse error on input `@'
13:27:42 <sipa1024> :t mapM
13:27:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:29:46 <shapr> Ok, how the heck do I install ghc7 on the latest ubuntu release?
13:30:28 <c_wraith> does using the generic linux binary not work?
13:31:16 <shapr> jmcarthur_out: hey, can I get ops on #haskell-game?
13:33:01 <geheimdienst> shapr: i think the rule of thumb is, if it's not in the standard repositories, chances are somebody has a PPA with the packages you want ...
13:33:20 <rostayob> shapr: the binaries work fine for me
13:33:22 <shapr> geheimdienst: I haven't been able to find one..
13:34:14 <rostayob> shapr: http://haskell.org/ghc/download_ghc_7_0_3#x86linux
13:34:29 <shapr> rostayob: I'll try that, thanks.
13:35:20 <rostayob> shapr: i've been running ubuntu 10.04 and ghc 7 happily for a while now
13:35:43 <rostayob> for some reason most people don't like the ghc binaries, i don't know why :P
13:35:43 <shapr> I have ubuntu 11.04, so was hoping for a PPA for the most recent haskell-platform
13:36:23 <siracusa> Is there a way to cancel a threadDelay prematurely?
13:36:43 <shapr> rostayob: Mostly because my emacs and $PATH and other settings sometimes get confused about which one is most recent. I still have a beta build of ghc7 hanging around somewhere... it gets in the way.
13:36:55 <rostayob> just don't install the distro ghc
13:37:37 <rostayob> I don't know about handling multiple ghc installs
13:37:40 <rostayob> i tend to stay safe :P
13:37:46 <rostayob> anyway, bedtime
13:37:48 <rostayob> good luck ehe
13:37:51 * shapr waves to rostayob 
13:44:51 <bahblah> hi, can someone explain to me the precedence of function calls?
13:46:00 <behelit> so, i'm reading some haskell code to learn and i stubmle upon "<|>" - googling that is head, any reference where you can read up on stuff like that? :)
13:46:19 <parcs> behelit: http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/Control-Applicative.html#t:Alternative
13:46:21 <geheimdienst> bahblah: the rule of thumb is: function application binds tighter than anything else
13:46:29 <parcs> except for some stuff
13:46:30 <geheimdienst> behelit: in general, you may want hayoo or hoogle
13:46:36 <geheimdienst> @where hayoo
13:46:36 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
13:46:54 <behelit> parcs, geheimdienst: many thanks!
13:47:22 <behelit> geheimdienst: hayoo didn't return any results when searching for "<|>"
13:48:12 <randomwords> behelit: Have you tried hoogle?
13:48:16 <kmc> @hoogle (<|>)
13:48:16 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
13:48:17 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
13:48:17 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
13:48:39 <kmc> bahblah, (f x y) is ((f x) y)  -- does that answer your question?
13:49:02 <geheimdienst> behelit: you're right, hayoo can't find it. that's weird. must be a hayoo bug :(
13:49:12 <bahblah> kmc: hmm...what if x is an infix function
13:49:24 <kmc> bahblah, and you're using it infix?
13:49:30 <kmc> then it depends on the declared precedence for x
13:49:42 <kmc> but prefix function application binds tighter than all infix operators
13:49:48 <kmc> (f x + g y) = ((f x) + (g y))
13:49:55 <bahblah> i see
13:51:07 <bahblah> kmc: i'm guessing there are no functions that have variable # of args?
13:51:27 <kmc> correct
13:51:30 <kmc> every function has one argument
13:51:32 <bahblah> i think i get it now
13:51:40 <bahblah> thanks
13:52:11 <bahblah> so what if you wanted to pass an infix operator as a variable
13:52:17 <bahblah> do you pass it like (+)
13:52:24 <kmc> right
13:52:31 <bahblah> argument*
13:52:36 <kmc> and then it acts like a normal name, not infix
13:53:02 <bahblah> can you partially apply either side of an infix operator?
13:53:11 <kmc> yes
13:53:26 <kmc> you can also use a prefix name as infix by surrounding it with ``
13:53:28 <bahblah> how does that work?
13:53:32 <kmc> and you can do operatior sections with that too
13:53:37 <kmc> :t (3 `mod`)
13:53:38 <lambdabot> forall t. (Integral t) => t -> t
13:53:44 <kmc> bahblah, what do you mean how does it work?
13:53:53 <bahblah> i meant how does partially applying either side of an infix operator work
13:54:02 <kmc> work in what sense
13:54:17 <kmc> (x +) is sugar for \y -> x + y
13:54:19 <bahblah> isn't that kinda like having f x y and partially applying the y argument
13:54:24 <kmc> (+ x) is sugar for \y -> y + x
13:54:49 <kmc> there's not really any "partial application" in Haskell, though
13:54:59 <kmc> really every function takes only one argument
13:55:18 <kmc> a "two argument function" takes one argument and returns a function that takes the second argument
13:55:26 <kmc> that's why (f x y) is ((f x) y)
13:55:35 <bahblah> right
13:56:15 <dolio> > let (+) x = undefined in (5+) `seq` ()
13:56:16 <lambdabot>   *Exception: Prelude.undefined
13:56:20 <bahblah> so...infix operators can return two different functions depending on which side is applied?
13:56:30 <kmc> no
13:56:34 <kmc> not really
13:56:41 <kmc> the two "is sugar for"
13:56:49 <kmc>  rules i gave pretty much tell the whole story
13:58:14 <bahblah> i'm confused as to how both (5/) and (/5) are possible.
13:59:25 <parcs> because the parser accepts those inputs and desugars them appropriately?
13:59:26 <bahblah> kmc: can you explain the syntax \y -> x + y? sorry, i'm still reading through learn you a haskell for great good
14:00:33 <kmc> bahblah, it's an anonymous function.  takes an argument y, return x+y
14:00:35 <parcs> (5/) is the same as (/) 5. (/5) is the same as \x -> (/) x 5
14:00:38 <kmc> it's a "lambda abstraction"
14:00:57 * luqui still uses backslash
14:01:04 <kmc> i could also say that (+ x) is equivalent to ¬´let f y = y + x in y¬ª
14:01:06 <kmc> err
14:01:09 <kmc> i could also say that (+ x) is equivalent to ¬´let f y = y + x in f¬ª
14:02:11 <bahblah> ok ok
14:02:14 <bahblah> i think i understand now
14:02:16 <bahblah> thanks :)
14:03:54 <kmc> yay :)
14:14:04 <erus`> >(- 10) 1
14:14:09 <erus`> > (- 10) 1
14:14:10 <lambdabot>   -10
14:14:20 <erus`> > ((-) 10) 1
14:14:21 <lambdabot>   9
14:14:41 <erus`> > (/ 10) 1
14:14:42 <lambdabot>   0.1
14:14:50 <erus`> > ((/) 10) 1
14:14:51 <lambdabot>   10.0
14:15:01 <dmwit> > subtract 10 1
14:15:02 <lambdabot>   -9
14:15:05 <dafis> > (subtract 10) 1
14:15:06 <lambdabot>   -9
14:15:12 <dmwit> bwahaha
14:15:44 <erus`> infix; how does it work?
14:17:25 <dafis> You just do it, except you can't make a right section of (-)
14:18:34 <c_wraith> there's the very silly trick, though
14:18:40 <c_wraith> > (-10+) 1
14:18:41 <lambdabot>   -9
14:18:56 <dafis> > (+ (-10)) 1
14:18:57 <lambdabot>   -9
14:19:28 <zygoloid> > let (+-) = (-) in (+-10) 1
14:19:29 <lambdabot>   -9
14:19:43 <dafis> cheater!
14:20:35 <erus`> when will it be my turn for haskell skills?
14:21:30 <dafis> erus`: Predictions are very difficult. Especially about the future.
14:21:31 <zygoloid> erus`: one #haskell denizen gets chosen a month in the haskell skills lottery. that's why so many people lurk here
14:23:46 <shapr> Ok, time to fix my hakyll install...
14:25:53 <Stribor> if "something" is string (which is nothing more but list of chars).......why cant you do this then "something":"somethingelse"
14:26:13 <c_wraith> :t (:) -- Stribor
14:26:14 <lambdabot> forall a. a -> [a] -> [a]
14:26:14 <shachaf> @type (:)
14:26:16 <lambdabot> forall a. a -> [a] -> [a]
14:26:29 <Stribor> c_wraith: i dont understand
14:26:38 <erus`> > 's':"omething"
14:26:39 <lambdabot>   "something"
14:26:41 <shachaf> Stribor: Look at the type of (:).
14:26:50 <Stribor> opps
14:26:54 <shachaf> Stribor: It takes a Char and a list of Chars and returns a list of Chars.
14:26:55 <c_wraith> the first and second arguments of (:) don't have the same type
14:26:58 <Stribor> takes element and list of elemet
14:27:11 <Stribor> tx
14:28:00 <erus`> what is the quickest way to construct a list? currently i append to the front and then reverse when the list is finished
14:28:32 <zachk> why do you need to reverse it?
14:28:57 <erus`> just for clarity
14:29:17 <erus`> i will need to access the last elements first when using the list
14:29:21 <erus`> so i reverse it
14:29:27 <erus`> fifo
14:29:45 <zachk> are you doing this?
14:29:52 <shachaf> Your question isn't clear enough to give a useful answer.
14:30:01 <shachaf> There's always Data.Sequence, though.
14:30:02 <c_wraith> What are you actually doing?
14:30:05 <zachk> > "item"++["item","item","item"]
14:30:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:30:06 <lambdabot>         against inferred type...
14:30:10 <c_wraith> That's probably the most important question
14:30:22 <erus`> parsing a list
14:30:30 <zachk> > ["item"]++["item","item","item"]
14:30:32 <lambdabot>   ["item","item","item","item"]
14:30:45 <zachk> you using (++) to append? or (:) ?
14:31:04 <erus`> i meant (:) prepend
14:31:26 <erus`> because that should be O(1)
14:31:37 <c_wraith> That's not enough information, though.
14:32:18 <c_wraith> If you can generate the list lazily, that will probably be fastest.
14:32:49 <c_wraith> But your description of what you're doing was insufficient for determining if a lazy approach is feasible
14:33:17 <benmachine> I think Data.Sequence is underrated
14:33:19 <erus`> i dont think i can make it lazy because its generated inside monadic code
14:33:32 <dafis_> which Monad?
14:33:39 <benmachine> lazy and monadic aren't incompatible
14:33:40 <erus`> Either
14:33:41 <benmachine> at all
14:33:51 <mauke> so how about those DLists
14:34:24 <dafis> erus`: [Either e a] or Either e [a] ?
14:34:50 <erus`> the latter
14:34:54 <Stribor> is this "\n" new line xcharacter
14:35:13 <c_wraith> Stribor: yes
14:35:17 <dafis> yes, that isn't for lazy list generation
14:35:43 <Phyx-> hmm anyone else getting an Alex error when compiling haddock?
14:36:19 <dafis> Phyx-: alex version?
14:36:36 <Phyx-> dafis: 3.0.1
14:36:57 <Kaide> I've noticed that Control.Applicative doesn't actually have an (Applicative j, Applicative k) => Applicative (O j k) instance
14:37:02 <Kaide> where can I find one?
14:37:26 <Phyx-> hmm it prolly is Alex...
14:37:29 <Kaide> seems like it would be handy to get around using monad transformers
14:37:40 <dafis> Phyx-: there was a problem with that, ghc used to not being able to be built with alex-3 until recently, could well affect haddock
14:37:59 <dafis> Phyx-: try with alex-2.*
14:38:08 <Phyx-> dafis: i'm installing 2.3.2. I was able to build before using that
14:39:21 <Phyx-> weird.. cabal install 'Alex==2.3.2' and 'Alex<3.0.0' says there are no version that satisfies that
14:39:39 <dafis> Phyx-: I have 2.3.5, try that
14:39:52 <dafis> Phyx-: alex, lower case
14:40:11 <Phyx-> ah
14:40:32 <Phyx-> didn't know cabal-install was case sensitive
14:40:50 <dafis> sure is, as the hackage urls
14:41:26 <Phyx-> doesn't seem to be the case on windows though
14:41:42 <wavewave> Kaide: what do you expect as definition?
14:41:46 <Phyx-> but yeah, alex 2.3.5 worked
14:41:48 <Phyx-> thanks dafis
14:41:56 <dafis> welcome
14:46:35 <xplat> edwardk: did i hear you say something about adding gll support to trifecta?
14:46:42 <edwardk> yes
14:47:27 <edwardk> i'm adding packratting now in a way similar to what i described in the blog post, and gll is something i've been working on in the background
14:47:44 <luqui> Kaide, which O are you talking about?
14:47:51 <Kaide> type compose
14:48:00 <luqui> TypeCompose has that instance doesn't it?
14:48:07 <Kaide> hmm does it?
14:48:10 <zachk> herlihy giving lectures  http://www.youtube.com/user/Technion#p/c/0DA9BFB82ACED0AF/0/05knu1z3zOg
14:48:11 <Kaide> let me check
14:48:12 <xplat> it seems like trifecta has developed pretty far outside the parameters of the original idea.  which is handy, since it offers so many sharable bells and whistles.
14:48:20 <edwardk> i've also been building a scannerless and grammar-aware burke-fisher variant to get better error messages
14:48:23 <luqui> Kaide, if not, that is something conal is going to want to fix :-)
14:48:40 <Kaide> yes it does
14:48:41 <edwardk> xplat: well, my original idea was to add all the crap people usually write on top of their parsing library
14:48:43 <Kaide> great
14:48:49 <Kaide> so I can import Control.Compose
14:48:53 <edwardk> xplat: so perhaps i didn't properly convey its purview ;)
14:48:55 <Kaide> and use that infix :.
14:49:45 <xplat> edwardk: well, it's pretty well conveyed in the package description, but the parsing trifecta presentation seemed pretty focused on the algorithm
14:49:56 <edwardk> yes
14:50:03 <edwardk> i'll admit i just stole the name =)
14:52:01 <Panocha> I am designing a new help forum for Haskell
14:52:10 <Panocha> and will have this channel embedded with a java applet
14:52:19 <Panocha> but I am torn as to which logo to use
14:52:27 <Panocha> here is a montage of the 4 logos under consideration
14:52:30 <Panocha> I need some feedback
14:52:31 <Panocha> http://i.imgur.com/Usqtb.jpg
14:52:39 <Panocha> which one would be best in your opinion?
14:53:03 <waern> hello
14:53:12 --- mode: ChanServ set +o Saizan
14:53:32 <Nimatek> Panocha: Looks good, add some text.
14:53:38 --- mode: Saizan set +b *!*Blooop@2001:470:1f08:12e0::*
14:53:38 --- kick: Panocha was kicked by Saizan (Panocha)
14:53:39 <geheimdienst> @where ops
14:53:39 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:53:45 <geheimdienst> ... thanks, saizan
14:53:51 * zachk thanks saizan as well 
14:54:01 --- mode: Saizan set -o Saizan
14:54:27 <waern> I have a test-suite stanza in my .cabal file with a "hs-source-dirs: tests/html-tests" entry. When I do cabal upload, I get a message "'hs-source-dirs: tests/html-tests' directory does not exist." What could be wrong?
14:57:34 <Kaide> I see the guy get banned, and then click anyway
14:57:44 <Kaide> goodnight #haskell
14:57:56 <mauke> hope you like porn :-)
14:58:29 <dafis> mauke: I do, but not that variant
14:58:34 <kmc> now i must know
14:59:07 <dafis> kmc: you needn't it's neither funny nor particularly revolting
14:59:28 <kmc> yeah, boring
14:59:48 <jamie> who
15:00:00 <zachk> its stuck in my visual cortex memory from the shock value :-/
15:00:15 <mauke> in fact it looks so harmless it might have been an honest mistake
15:00:20 <ion> jamie: Justin Bieber
15:00:23 <dafis> zachk: I take it you have never been goatse'd
15:00:32 <zachk> oh i have
15:00:48 <zachk> but that was long long ago
15:00:49 <jamie> Can anyone
15:00:52 <edwardk> xplat: the main complaint i hear is about the kitchen sink worth of dependencies, but if i broke it up then i'd hear about the flood of updates. so meh. i'm going with the path that lets me get the most done
15:01:32 <jamie> Can anyone help an xmonad newbie with a question?
15:01:38 <kmc> yes
15:01:45 <kmc> though you might also try #xmonad
15:01:54 <jamie> Let me try that one.
15:02:04 <Saizan> but we like the flood of updates
15:02:12 <Saizan> it's a social event
15:02:13 <edwardk> hah
15:03:09 <edwardk> they'll still happen when i need to update stuff downstream =)
15:03:13 <kmc> edwardk, you're only 5th on the rankings of most packages uploaded (not counting updated versions)
15:03:27 * edwardk shrugs
15:03:38 <kmc> got to get the high score
15:03:40 <edwardk> unlike the snoyman i don't break EVERY module into a package ;)
15:03:47 <kmc> heh
15:04:28 <edwardk> now if you count updates, it is kinda sad
15:04:58 <geheimdienst> one function per package would mean the dependency tree would be a kind of call tree
15:06:27 <waern> I wonder if the new module signature / package stuff will lead to one module per package...
15:06:38 <xplat> that maybe wouldn't work very well with mutual recursion
15:07:14 <edwardk> .hs-boot can't even save you then
15:07:26 <luqui> waern, new module signature stuff? what is this?
15:07:30 * luqui gets excited
15:08:04 <waern> luqui: I mean the stuff under development (or in research stage, rather) based on MixML
15:10:07 <luqui> ah, found it
15:10:16 <luqui> sweet, i didn't know this was going on
15:20:23 <edwardk> luqui: link?
15:23:47 <Phyx-> hrm... why does getTemporaryDirectory not return a path into /tmp on linux?
15:25:53 <dafis> Phyx-: does return "/tmp" here
15:26:08 <kmc> it might look at $TEMP or something
15:26:23 <Phyx-> oh, wait, it's not that that's failing..
15:27:04 <geheimdienst> Phyx-: gives "/tmp" for me. according to doc, it first checks the $TMPDIR variable
15:27:30 <Phyx-> i'm getting /tmpHs2lib454423/ as an example
15:27:50 <Phyx->  /tmp/Hs2lib454423 would be more like it..
15:28:17 <mauke> % TMPDIR=2 ghc -e 'System.Directory.getTemporaryDirectory'
15:28:17 <mauke> "2"
15:29:13 <geheimdienst> i think that function is for returning the system temp directory. it's not for creating a new dir inside (like mktemp on the command line)
15:29:18 <Phyx-> yeah, it's my bug, sorry bout that
15:29:37 <Phyx-> somewhere where i combine the paths it must be borking
15:30:46 <geheimdienst> check out this: http://stackoverflow.com/questions/2978210/create-a-temporary-directory-in-haskell
15:31:08 <geheimdienst> and for combining paths i always use (</>) from System.FilePath. be aware that if the second arg is an absolute path, it will ignore the first one (as documented), so you might need to stick an extra ¬´makeRelative "/"¬ª in there
15:31:26 <Phyx-> i'm pretty sure i am using </>
15:31:34 <Phyx-> unless I accidently didn't one palce
15:31:35 <Phyx-> place*
15:31:51 <Phyx-> it's working on windows. Trying to make everything work on linux too
15:38:12 <Phyx-> heh, trying to find a bug in 2 year old code is annoying
15:38:59 <dafis> could be worse, could be COBOL
15:39:05 <Phyx-> lol
15:40:28 <Phyx-> ah, was in another module...
15:40:54 <Phyx-> does </> not append a / is one was already present?
15:43:07 <geheimdienst> what are the two arguments you're giving to (</>) ? maybe print them
15:44:42 <Phyx-> I was just wondering as to the behaviour of </> but just testing it in ghci gave me what I want. It doesn't add an extra separator is one's already there.
15:45:22 <Phyx-> anyway, it's fixed now, ty geheimdienst , mauke, kmc and dafis
16:19:41 <bfig> what is the best way to include haskell-like code in latex?
16:20:33 <dafis> lhs2tex?
16:20:46 * bfig googles the tool
16:30:37 <kmc> bfig, the 'listings' package also does a fine job
16:32:12 <bfig> kmc, that is absolutely awesome :)
16:33:24 <dylukes> how can you change the font of listings?
16:33:27 <bfig> how do you usually go around about indenting code?
16:33:27 <dylukes> Always bugs me.
16:33:34 <dylukes> you can set listings left margin
16:35:15 <bfig> ahh how stupid i am... i can just indent it like it didn't matter :p
17:20:12 * hackagebot rex 0.3 - A quasi-quoter for typeful results of regex captures.  http://hackage.haskell.org/package/rex-0.3 (MichaelSloan)
17:29:26 <hpaste> bfig pasted ‚Äúparsing error‚Äù at http://hpaste.org/51793
17:29:54 <bfig> i'm having trouble making a simple example compile, what is wrong with what i just wrote for lhs2TeX?
17:31:29 <bfig> *** Error in file ./informe.lhs line 10: `code' is not defined; perhaps you forgot to include "lhs2TeX.fmt"? is the error i get
17:34:48 <fryguybob> bfig: I just looked at a random example on lhs2tex github and a couple changes mad it compile for me.
17:35:03 <hpaste> fryguybob annotated ‚Äúparsing error‚Äù with ‚Äúparsing error (annotation)‚Äù at http://hpaste.org/51793#a51794
17:35:12 * hackagebot happstack-state 6.1.2 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-6.1.2 (JeremyShaw)
17:36:24 <bfig> fryguybob, awesome! :)
17:36:28 <bfig> thanks
17:39:46 <eyebloom> Anyone have a second for a quick type inference question?
17:39:55 <dylukes> don't ask to ask, just do it :P
17:40:33 <eyebloom> A made some example code here: http://codepad.org/lvmkBYuN
17:41:04 <eyebloom> Basically I'd like a and a' to be different or the same.
17:41:32 <eyebloom> Meaning I plan to make them different in the future but right now I'm keeping them the same.
17:41:33 <bfig> what does a' mean?
17:41:39 <eyebloom> a prime
17:41:46 <eyebloom> Same as b
17:41:48 <bfig> in the haskell type system
17:41:57 <bfig> so i can do functions a->a'->c''' ?
17:42:14 <eyebloom> bfig: I think so
17:42:18 <benmachine> bfig: you can use ' in names anywhere you can use a letter, except at the beginning
17:42:20 <JoeyA> @hoogle a -> a'
17:42:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:42:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:42:21 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:42:37 <bfig> cool
17:42:39 <JoeyA> eyebloom: There's an implicit forall on each type.
17:42:47 <benmachine> > let let'in = "let in" in ()
17:42:48 <lambdabot>   ()
17:42:54 <JoeyA> c :: forall a a'. a -> a'
17:42:59 <JoeyA> That is probably not what you mean
17:43:09 <incluye> what does $! do
17:43:12 <incluye> ungooglable
17:43:13 <JoeyA> That means the function will have to convert *any* type to *any* other type.
17:43:27 <benmachine> eyebloom: your code would typecheck if you wrote changeType = undefined
17:43:35 <benmachine> (but it would crash at runtime, of course)
17:43:35 <mauke> incluye: use hoogle, not google
17:43:37 <eyebloom> I think it's fine if the types are different
17:43:38 <JoeyA> incluye: Strict application
17:43:52 <mm_freak_> eyebloom: are you asking for type casting?
17:44:09 <JoeyA> Namely, f $! x means x will be forced when that expression is forced.
17:44:35 <O1athe> incluye: I think it's for strictness or something. Like seq.
17:44:35 <JoeyA> So if you have: data Foo = Foo Int
17:44:46 <benmachine> eyebloom: if you give a function a type declaration, it should have exactly that type, not a specific instance of that type
17:44:58 <mm_freak_> @src ($!)
17:44:58 <lambdabot> f $! x = x `seq` f x
17:45:01 <JoeyA> evaluate (Foo (sum [1..1000000]))
17:45:09 <JoeyA> That will not force the sum.
17:45:23 <JoeyA> The head-normal form is just the Foo.
17:45:37 <eyebloom> But basically if I say f :: a -> b, a and b cannot be the same
17:45:40 <JoeyA> So evaluating it gives you Foo <thunk>, where <thunk> hasn't been computed yet.
17:45:41 <incluye> > seq 1 2
17:45:42 <lambdabot>   2
17:45:46 <Olathe> @src ($!)
17:45:46 <eyebloom> I can't then say:
17:45:46 <lambdabot> f $! x = x `seq` f x
17:45:49 <incluye> "head normal form"?
17:45:51 <incluye> what is that?
17:45:54 <eyebloom> f a = a
17:45:55 <mm_freak_> eyebloom: (a -> b) and (a -> a') are the same type
17:45:56 <incluye> oh, wait
17:46:23 <benmachine> eyebloom: a and b *can* be the same, but you can't *require* them to be the same in your implementation
17:46:27 <Olathe> incluye: It means it figures out the constructor used for the value rather than waiting lazily until later.
17:46:48 <Olathe> incluye: So, if it's a list, for instance, it'll either figure out it's [] or (:) something something.
17:46:50 <eyebloom> benmachine: I see.
17:46:54 <fryguybob> eyebloom: f :: a -> b means the consumer of f gets to pick b.
17:47:01 <mm_freak_> eyebloom: you can express the equality requirement using type family syntax:  a ~ b => a -> b, but that's effectively the same as writing a -> a in the first place
17:47:07 <benmachine> eyebloom: it's important to realise that when you have a function foo :: a -> b, then it's whoever *calls* foo who gets to pick a and b, not whoever writes it
17:47:08 <bfig> fryguybob, i'm still having trouble for some reason
17:47:13 <Olathe> incluye: But that's all the work it'll do.
17:47:13 <incluye> > seq [1..] 2
17:47:14 <lambdabot>   2
17:47:24 <benmachine> (yeah, like fryguybob said)
17:47:25 <bfig> fryguybob, it says \begin is not found
17:47:37 <bfig>  \begin{document}
17:47:41 <fryguybob> bfig: :(
17:47:43 <eyebloom> Right then why doesn't this work:  http://codepad.org/EOqp91si
17:48:07 <fryguybob> bfig: perhaps one of these examples works? https://github.com/kosmikus/lhs2tex/tree/master/Examples
17:48:10 <mm_freak_> eyebloom: 'c' works
17:48:14 <mm_freak_> but your changeType doesn't
17:48:18 <fryguybob> bfig: I have to go.
17:48:34 <incluye> > undefined :: Int
17:48:35 <lambdabot>   *Exception: Prelude.undefined
17:48:38 <bfig> fryguybob, thanks for the hel
17:48:39 <bfig> p
17:49:03 <eyebloom> I see, so I'm thinking about types upside down....
17:49:05 <mm_freak_> eyebloom: your changeType function allows the caller to pick 'a' and 'a'' freely, while then it tries to use 'a' as Int and 'a'' as Bool
17:49:20 <JoeyA> By the way, think of undefined as an infinite loop.
17:49:38 <JoeyA> Unlike "null", you can't test if a value is undefined or not.
17:49:57 <JoeyA> (well, I suppose you could with some hackery, e.g. using stable names)
17:50:12 * hackagebot web-routes 0.25.3 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.25.3 (JeremyShaw)
17:50:32 <mm_freak_> eyebloom: when using a fully polymorphic type variable, you allow maximum flexibility with minimum assumptions
17:50:36 <JoeyA> > isJust $ Just undefined
17:50:37 <lambdabot>   True
17:50:44 <mm_freak_> your code though assumes that a = Int, which is wrong
17:50:46 <benmachine> eyebloom: kind of, yes. you have to realise that type signatures are declarations of what a function *can* do, not what it can't, I guess
17:50:47 <JoeyA> > isJust (Just $! undefined)
17:50:48 <lambdabot>   *Exception: Prelude.undefined
17:51:04 <JoeyA> incluye: ^ Simple example of $! above.
17:51:09 <incluye> I see
17:51:47 <eyebloom> So if I'm using general types like this I basically always have to define some typeclasses to make it work...?
17:51:54 <JoeyA> When an expression is evaluated in Haskell, it is "forced" to head normal form.
17:51:59 <incluye> > head 10 $ [1..] ++ [2..]
17:52:00 <lambdabot>   No instance for (GHC.Num.Num [[t] -> b])
17:52:00 <lambdabot>    arising from a use of `e_11012'...
17:52:08 <incluye> err
17:52:11 <JoeyA> err, weak head normal form
17:52:13 <mm_freak_> eyebloom: not necessarily, but when you need some information about the types, then yes
17:52:14 <incluye> > take 10 $ [1..] ++ [2..]
17:52:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:52:28 <mm_freak_> eyebloom: in this case you need a function, which would convert a to a'
17:52:39 <JoeyA> meaning as long as you know the top-level data constructor, you're good to go.
17:52:54 <JoeyA> when you print stuff, that ends up consuming a lot of head-normal forms
17:52:56 <mm_freak_> eyebloom: a reasonable type signature would be:  changeType :: Convert a a' => a -> a'
17:53:14 <mm_freak_> class Convert a a' where convert :: a -> a'
17:53:15 <JoeyA> > isJust $ Just $ Just $! undefined
17:53:16 <lambdabot>   True
17:53:21 <benmachine> danger, MPTCs
17:53:21 <JoeyA> > isJust $ Just $! Just $ undefined
17:53:23 <lambdabot>   True
17:53:25 <JoeyA> > isJust $ Just $! Just $! undefined
17:53:26 <lambdabot>   *Exception: Prelude.undefined
17:53:38 <mm_freak_> benmachine: i think you can only do this with MPTCs
17:54:09 <benmachine> mm_freak_: well, yes, but I wonder if it's actually what you want to do
17:54:14 <benmachine> such functions aren't that useful in practice
17:54:21 <eyebloom> mm_freak: Understood, but as I was asking I need a typeclass constraint.
17:54:29 <mm_freak_> benmachine: they are‚Ä¶  see how Data.Convertible is used in HDBC
17:54:34 <benmachine> eyebloom: why would a typeclass constraint help?
17:55:11 <eyebloom> Isn't "Convert a a'" => a constraint
17:55:16 <benmachine> eyebloom: yes
17:55:26 <benmachine> eyebloom: ok what were you actually trying to do, remind me
17:55:55 <mm_freak_> eyebloom: well, you don't /need/ a type class constraint‚Ä¶  you can also have this:  changeType :: (a -> b) -> a -> b
17:55:56 <eyebloom> I want to leave a and a' general in my code.
17:56:01 <mm_freak_> but then changeType = ($)
17:56:02 <benmachine> mm_freak_: ouch, Convertible has a billion instances
17:56:34 <benmachine> eyebloom: why?
17:56:43 <mm_freak_> benmachine: yeah, it's a PITA, when you need to define your own instances, unless you can just use an existing one‚Ä¶  the billion instances are there for picking the best representation whenever possible
17:57:02 <eyebloom> In the larger program I'm writing that's useful.
17:57:06 <mm_freak_> eyebloom: there is no defined function of type a -> b
17:57:30 <mm_freak_> so this is theoretically impossible
17:57:32 <JoeyA> (except unsafeCoerce, but that's... unsafe)
17:57:33 <ion> *cough*uns‚Ä¶rce
17:58:04 <JoeyA> unsafeCoerce is sort of like doing *(int*)"Hello" in C
17:58:27 <eyebloom> In any case thanks for attempting... I'll keep studying and try and formulate a less vague question ;)
17:58:33 <JoeyA> (on some architectures, that may crash due to misalignment)
17:59:13 <mm_freak_> eyebloom: don't think about types as containers‚Ä¶  types in haskell are more like a specification of your program
17:59:43 <mm_freak_> so type casting is not a reasonable concept in haskell
17:59:51 <mm_freak_> you might just as well use PHP
18:00:11 <eyebloom> I think the Convert a a' typeclass is what I'm looking for.
18:00:40 <jmcarthur> Convert a a' sounds like something i would never look for
18:00:53 <mm_freak_> eyebloom: the Convert type class is what you may /think/ you're looking for‚Ä¶  certainly there is a better way to express what you want to do
18:00:54 <benmachine> yeah I don't think it's what you want
18:01:27 <eyebloom> What are possible alternatives?
18:01:34 <mm_freak_> eyebloom: what's the application?
18:01:45 <benmachine> well, you can leave type signatures off everything and let inference do all the work
18:01:53 <benmachine> that sometimes works, especially in early development
18:01:59 <jmcarthur> to some extent, you can do that, at least
18:02:00 <beekar> Do i need to sudo all of my cabal'ing ?
18:02:08 <mauke> beekar: no
18:02:09 <benmachine> beekar: sudo none of your caballing
18:02:16 <beekar> k thanks.
18:02:22 <jmcarthur> beekar: cabal-install should be able to put stuff in ~/.cabal, so no
18:02:26 <ion> I haven‚Äôt read the discussion, but a generic conversion function between pairs of values for which that makes sense would be nice. conv :: Word32 ‚Üí Integer, conv :: ByteString ‚Üí [Word8], conv :: Double ‚Üí Rational etc.
18:02:31 <benmachine> beekar: you can set root-cmd: sudo in your config, but I always use local installs anyway
18:02:37 <eyebloom> I'm basically building a functor that allows one to do operations on sub-graphs of a larger graph
18:02:39 <beekar> okay.  i'm have issues.  i'll check in there.   gotcha.
18:02:51 <mauke> ion: I'm not convinced that's better than separate functions
18:02:58 <mm_freak_> beekar: sudo only for packages you want to install globally‚Ä¶  in general you don't want to install any package globally except what your operating system already provides in distribution packages
18:03:02 <eyebloom> I recently switched from doing functional stuff in Python to Haskell
18:03:32 <benmachine> I agree with mauke, generic conversion functions sound like they would lead to ambiguous types
18:03:42 <benmachine> (and aren't as self-documenting as saying fromInteger or whatever)
18:03:49 <eyebloom> Mostly I'm very happy but occasionally I get confused.
18:03:59 <benmachine> eyebloom: story of my life
18:04:06 <mm_freak_> eyebloom: i don't see where you would need to convert types there
18:04:16 <benmachine> (the last bit, not the python bit)
18:04:38 <beekar> I'm getting this for an error:  cabal: Couldn't read cabal file "HDBC/2.2.6.1/HDBC.cabal" and not finding anything useful on the web.
18:04:43 <eyebloom> Graphs can have different edge and label types depending on the operation
18:04:53 <beekar> Is that supposed to be in .cabal/packages/hackage.haskell.org/ ?
18:05:03 <beekar> wasn't sure if i need to git it
18:05:32 <beekar> i'm startin out a bit, if it's not obvious.
18:05:49 <mm_freak_> eyebloom: well, you probably already have two type variables then:  data Graph l e
18:06:00 <kmc> ion, and conv :: Double -> Int?
18:06:04 <kmc> does it round, floor, or ceil?
18:06:14 <mm_freak_> eyebloom: a function, which needs a relation between l and e should just use the proper type signature
18:06:27 <kmc> "how do I convert A to B" is really just a silly way to ask "pick some function of type A -> B"
18:06:45 <mm_freak_> labelEdges :: Graph l e -> Graph l (l, e)
18:07:05 <benmachine> beekar: I don't have any .cabal files in my .cabal folder
18:07:14 <benmachine> beekar: I assume it unpacks them during installation, though
18:07:32 <benmachine> beekar: I'd suggest making sure none of ~/.cabal or ~/.ghc is owned by root
18:07:35 <beekar> okay.  just not sure where they go.  i'll keep readin
18:07:39 <beekar> nah it shouldn't be.
18:08:09 <eyebloom> right it's more like: convertGraph :: Graph l e -> Graph l' e'
18:08:29 <mm_freak_> that doesn't seem to be a reasonable conversion
18:08:35 <mm_freak_> you probably want something like this instead:
18:08:52 <mm_freak_> convertGraph :: (l -> l') -> (e -> e') -> Graph l e -> Graph l' e'
18:08:56 <mauke> beekar: why do you care where cabal puts files?
18:09:22 <benmachine> mauke: see the error he got
18:09:32 <mauke> benmachine: for what command?
18:09:40 <mm_freak_> part of that is already given by Functor:  fmap :: (a -> b) -> Graph l a -> Graph l b
18:09:43 <benmachine> well, *I* don't know that :P
18:10:12 <beekar> ah i don't a whole lot. i'm just trying to diagnose my error and figure out where the files are it cannot read.
18:10:13 <eyebloom> Right but then I would need to plumb those conversion functions into many of the functions called by convertGraph
18:10:38 <benmachine> eyebloom: well, if you don't plumb them, how are you going to convert anything?
18:10:40 <mm_freak_> eyebloom: well, at some point the converter has to know /how/ to convert
18:10:49 <mauke> beekar: what command did you use?
18:10:59 <eyebloom> Which leads me back to a typeclass?
18:10:59 <beekar> cabal install yesod
18:11:06 <mauke> reasonable enough
18:11:11 <beekar> i thought.
18:11:14 <mm_freak_> eyebloom: i'd use a function argument, but you can certainly use a type class
18:11:15 <benmachine> eyebloom: potentially, but plumbing is usually better
18:11:30 <benmachine> (and less painful than it sounds)
18:11:37 <Guest76311> is there a standard library function that maps a list of functions to a list of values, func0 on val 0, func 1 on val 1 etc?
18:11:54 <mm_freak_> Guest76311: zipWith
18:12:00 <mm_freak_> :t zipWith
18:12:01 <mauke> beekar: you could try with --verbose=1
18:12:01 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
18:12:04 <Cale> zipWith id
18:12:10 <Cale> :t zipWith id
18:12:11 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
18:12:22 <Guest76311> ok thanks
18:12:47 <eyebloom> benmachine: How so?
18:13:04 <beekar> haha, no difference.
18:13:05 <benmachine> eyebloom: well, there can only be one type class instance for each type
18:13:16 <benmachine> eyebloom: suppose I have a type class that converts Ints to Bools
18:13:37 <benmachine> but then suppose I want to convert one thing one way, and another thing a different way
18:13:43 <benmachine> I can't write an instance for each
18:14:00 <benmachine> but if I plumb the functions, I can pass whatever I want wherever I want
18:14:05 <mauke> beekar: you could crank the verbosity level up to 3, see if it gives you more information
18:14:06 <benmachine> and it's always clear what I want to happen
18:14:19 <mauke> if all else fails, there's always strace
18:14:48 <mm_freak_> eyebloom: also with plumbing you have the additional advantage that what your function does follows from its type and its name
18:15:08 <mm_freak_> eyebloom: and following the spirit of haskell i would call this function mapGraph, not convertGraph
18:15:08 <beekar> i'll read the man, mauke.  that's a good step..
18:15:26 <mm_freak_> eyebloom: passing mapping functions is a very common concept in haskell
18:15:41 <eyebloom> Good point
18:17:15 <eyebloom> I'm righting a pretty complicated algorithm, every graph operation has an input type a traversal type and an output type so I
18:17:32 <eyebloom> I'm very worried that plumbing would become unweildy
18:18:15 <mm_freak_> eyebloom: just go ahead and write it‚Ä¶  you will realize that it's not as bad as you imagine‚Ä¶  if there is a piece of code, which gets complicated, just ask‚Ä¶  there is always an elegant way to express it
18:18:16 <benmachine> eyebloom: give it a go. if you always find yourself passing the same collections of functions around, maybe make a data type to contain them
18:20:53 <eyebloom> Well for example some of my type signatures already look like this:
18:20:55 <eyebloom> union :: (DynGraph gr, Eq b') => Sg gr a b a' b' -> Sg gr a b a' b' -> Sg gr a b a' b'
18:22:08 <eyebloom> Put a few functions infront of that and it's going to become a problem.
18:23:19 <Cale> ?
18:26:25 <eyebloom> Incidentally here's a version of the code I linked to that seems to work with plumbing. http://codepad.org/VKe9aQQ8
18:27:24 <eyebloom> So thanks for the help, I'll put more thought into this.
18:27:37 <kfhn> if I want to put the functions sin cos and exp in a list, is there a syntactically nicer way than (sin):(cos):(exp):[] ?
18:27:54 <jmcarthur> no parens needed
18:28:06 <jmcarthur> and you can use the list sugar
18:28:11 <jmcarthur> [sin, cos, exp]
18:28:25 <kfhn> ok, thanks jmcathur
18:28:53 <jmcarthur> > map ($4) [sin, cos, exp]
18:28:53 <lambdabot>   [-0.7568024953079282,-0.6536436208636119,54.598150033144236]
18:30:40 <ClaudiusMaximus> i rendered a couple of hundred images, then hacked on the code while profiling to see where it was slow, and in the process of making it not so slow i found a stupid bug which when fixed made the images look much nicer... don't know whether to rejoice in the fix or kick myself for not fixing it before rendering so many..
18:31:01 <byorgey> hehe
18:31:08 <byorgey> I'd say take what you can get.
18:31:12 <ClaudiusMaximus> ..and i guess it's time to add scripting support to my program so i don't have to type and click so much
18:31:43 <ClaudiusMaximus> is 'hint' the way to go for that these days?
18:34:23 <byorgey> ClaudiusMaximus: yep
18:34:58 <ClaudiusMaximus> i used 'plugins' a long while ago, is 'hint' similar?
18:35:57 <ddarius> ClaudiusMaximus: How long did it take to render the images?
18:37:31 <ClaudiusMaximus> ddarius: well, it wasn't so much the computation time, because luckily i cached the results on disk, it was more the entering values and clicking 'go' then doing something else while it rendered, over and over, for some days...
18:38:01 <ClaudiusMaximus> the bug was in the post processing code that was supposed to do anti-aliasing but in fact added extra aliasing :S
18:39:26 <ddarius> ClaudiusMaximus: This wasn't noticable in the early images?
18:40:36 <ClaudiusMaximus> ddarius: i did notice it looked imperfect, but i couldn't work out why, so i just lived with it - i didn't realize quite how bad it was until after i fixed it
18:54:57 * monochrom unleashes to the world: lazy evaluation tutorial! http://www.vex.net/~trebla/haskell/lazy.xhtml  Check out the 3 case studies!
18:57:23 <copumpkin> wow, impressive :)
18:57:58 <monochrom> It is not the end yet! In the next few weeks, there are more to come.
19:00:12 <monochrom> It is pretty exhausting because the pattern sublanguage of haskell is pretty rich, and there is much interaction between different patterns. consider this: the Haskell Report has to spend like 3 pages on translational rules, and that's just to nail the denotational semantics, not even lazy evaluation yet...
19:01:12 <monochrom> so currently I only cover a small part of it, just enough to appreciate sharing and the famous examples of foldr, foldl, average.
19:01:30 <eyebloom> Does anyone know if videos were made of the http://www.haskell.org/haskell-symposium/2011/index.html ?
19:01:45 <eyebloom> The symposium in Tokyo?
19:05:58 <Eduard_Munteanu> Hm, that is something, nice.
19:07:27 <ClaudiusMaximus> > 8192^2 * 8 / 1024^2
19:07:28 <lambdabot>   512.0
19:07:28 <shachaf> monochrom: Where's the "double (double 5)"?!
19:07:59 <monochrom> I already have (\x -> x+x) (3*4) for that
19:09:31 <shachaf> $ egrep '<()Cale()>.*double \(double 5\)' pre-2011-logs | wc -l
19:09:33 <shachaf> 183
19:10:17 <Cale> ROFL
19:11:12 <ClaudiusMaximus> something that confuses me a bit is:   f x y = let z = expensive x in cheap y z   -vs-   f x = let z = expensive x in \y -> cheap y z
19:11:41 <shachaf> ClaudiusMaximus: Which part confuses you?
19:11:54 <shachaf> ClaudiusMaximus: It might be clearer if you turn the function declaration syntax into an explicit lambda.
19:12:06 <mm_freak_> monochrom: good stuff‚Ä¶  i'd be happy to see more about how you can /use/ laziness, instead of just knowing how to avoid memory leaks
19:12:07 <Jafet> > f = \x -> \y -> let z = expensive x in cheap y z
19:12:08 <lambdabot>   <no location info>: parse error on input `='
19:12:15 <Jafet> s/^..//
19:12:28 <Eduard_Munteanu> I think he means the effects of eta-conversion on sharing.
19:12:31 <shachaf> Jafet: That ^ is redundant. :-)
19:12:54 <monochrom> oh, memoization (the good kind), I'll try to memoize to do that soon :)
19:12:57 <ClaudiusMaximus> right, i can see that the second form has the let floated out a level (if that's the right terminology) - is there a simple example to show why the compiler would be unwise to do it magically
19:12:57 <Jafet> I didn't know whether to escape >
19:13:12 <shachaf> Right, you but you can use s/..//
19:13:20 <monochrom> (actually don't worry, it has been on my mind early on)
19:13:23 <dankna> @hoogle [a] -> Int -> Maybe a
19:13:23 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:13:23 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:13:23 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
19:13:30 <Jafet> ClaudiusMaximus: if expensive x uses loads of space
19:13:36 <dankna> is there a version that returns a Maybe for safety? O_o
19:13:46 <Jafet> Then it gets shared across the partially applied f
19:13:55 <ClaudiusMaximus> aha, thanks - i see
19:13:57 <mm_freak_> monochrom: yeah, using vectors for that is very elegant and yet amazingly fast
19:14:05 <Jafet> @type index
19:14:06 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
19:14:07 <shachaf> dankna: Not in Data.List
19:14:26 <dankna> shachaf: okay.  thanks.
19:14:33 <shachaf> dankna: listToMaybe . drop (magicOffByOneErrorFix n)
19:14:39 <dankna> haha
19:14:43 * shachaf replaces brain use with keyboard use.
19:14:44 <ClaudiusMaximus> @hoogle atMay
19:14:44 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
19:14:48 <Jafet> (teaspoon.).(!!)
19:14:50 <shachaf> I think it's n-1.
19:14:54 <shachaf> @slap Jafet
19:14:54 * lambdabot pulls Jafet through the Evil Mangler
19:14:59 <dankna> no, it's just id
19:15:19 <shachaf> Oh.
19:15:26 <shachaf> See, that's why I don't do that sort of thing.
19:15:39 * shachaf was probably thinking of take or something.
19:15:45 <dankna> > (\index list -> listToMaybe . drop index list) 1 ['a', 'b', 'c']
19:15:45 <lambdabot>   Couldn't match expected type `[a]'
19:15:45 <lambdabot>         against inferred type `GHC.Types...
19:15:46 <Olathe> > let zomg = f . drop . subtract 1 where f [] = Nothing; f (x:_) = Just x in map (zomg 5) . iterate (1:) $ []
19:15:47 <lambdabot>   Couldn't match expected type `[a]'
19:15:47 <lambdabot>         against inferred type `[a1] -> [...
19:15:48 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/Safe/latest/doc/html/Safe.html#v:atMay
19:16:03 <shachaf> > map (listToMaybe . drop 2) ["ab","abcd"]
19:16:05 <lambdabot>   [Nothing,Just 'c']
19:16:05 <Jafet> dankna: !! is just cursed, don't do it
19:16:09 <dankna> > (\index list -> listToMaybe . drop index) 1 ['a', 'b', 'c']
19:16:10 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> Data.Maybe.Maybe a)
19:16:10 <lambdabot>    aris...
19:16:14 <dankna> Jafet: I'm trying not to, that's why I asked :)
19:16:16 <Eduard_Munteanu> !! and catch? :P
19:16:36 <shachaf> Eduard_Munteanu: That's teaspoon.
19:16:39 <dankna> > (\index list -> listToMaybe $ drop index list) 1 ['a', 'b', 'c']
19:16:40 <ClaudiusMaximus> woops, wrong one - http://hackage.haskell.org/packages/archive/safe/0.3/doc/html/Safe.html#v:atMay
19:16:40 <lambdabot>   Just 'b'
19:16:43 <dankna> there we go
19:16:43 <shachaf> Well, with unsafePerformIO
19:16:57 <ClaudiusMaximus> ('Safe' is deprecated in favour of 'safe')
19:17:07 <shachaf> unsafeSafeCracker
19:17:48 <Olathe> > let zomg = (f.) . drop . subtract 1 where f [] = Nothing; f (x:_) = Just x in map (zomg 5) . iterate (1:) $ []
19:17:49 <lambdabot>   [Nothing,Nothing,Nothing,Nothing,Nothing,Just 1,Just 1,Just 1,Just 1,Just 1...
19:19:18 <Olathe> f is like safeHead
19:19:26 <monochrom> mm_freak_: as it turns out, I write this lazy evaluation tutorial with FAQs in mind. due to "no one notices when things go right", 3/4 of the common surprises are "why do I get stack/heap overflow?!" ie the negative kind, and only 1/4 of the common questions are the positive kind "I saw this knot-tying memoization code on the web, it works and my brain has exploded". so my tutorial will have fewer positive examples.
19:21:37 <mm_freak_> true‚Ä¶  people fight laziness, although they should rather love it
19:22:03 <Olathe> They're waiting to instantiate it when it's required.
19:22:27 <monochrom> hahaha
19:22:49 <Eduard_Munteanu> I think laziness is rarely an optimization.
19:23:03 <Eduard_Munteanu> Or maybe I should say, other things may come first.
19:23:27 <ddarius> It isn't an optimization (well it is with respect to call-by-name), it's a totally different semantics.
19:24:00 <Olathe> I think laziness vs eagerness is similar to the difference between breadth-first vs depth-first.
19:25:45 <ClaudiusMaximus> does a segfault in libpango mean that i have a threading bug in my gtk2hs code? :/
19:27:11 <Cale> It's the sort of "optimisation" which takes programs that used to be an infinite loop and makes them run in a finite amount of time :)
19:27:13 <ddarius> ClaudiusMaximus: Or it could mean libpango is written in C.
19:27:56 <shachaf> C is a great language for segfaults. You can write a segfaulting program in 5 characters.
19:28:27 <shachaf> (Well, I guess it's probably undefined behavior.)
19:28:40 <Olathe> C++ is even better, since C is a pointer.
19:29:31 <Eduard_Munteanu> shachaf: main(){} ? I don't know anything shorter that could be problematic.
19:29:38 <shachaf> Eduard_Munteanu: I was thinking of "main;"
19:29:52 <Eduard_Munteanu> Oh, hrm.
19:30:08 <Eduard_Munteanu> Yeah, it makes sense.
19:30:35 <Olathe> What does that even mean?
19:30:52 <Olathe> It's declaring main to be a signed int?
19:30:58 <shachaf> Yep.
19:30:58 <ClaudiusMaximus> @bf <+
19:30:58 <Eduard_Munteanu> Yeah.
19:30:59 <lambdabot>  Done.
19:31:03 <Olathe> Ahh :)
19:32:07 <shachaf> main = 0x000000C3;
19:32:15 <shachaf> Well, I guess you need "const main" nowadays.
19:32:45 <Eduard_Munteanu> Why?
19:34:33 <shachaf> Non-const memory is non-executable by default.
19:35:22 <Eduard_Munteanu> But it might still get you a segfault, no?
19:35:30 <shachaf> Oh, yes, it'll segfault.
19:35:41 <shachaf> I meant if you don't want it to segfault. :-)
19:36:16 <Eduard_Munteanu> kthx no segfault, just wreck havoc :)
19:37:08 <wavewave> reddit post for the first time in my life :-)
19:37:36 <shachaf> wavewave: Quite an achievement!
19:38:11 <Eduard_Munteanu> You should take a pic.
19:38:51 <Eduard_Munteanu> You'll be able to say "here's me making my first reddit post" 30 yrs from now. :)
19:39:34 * Eduard_Munteanu notes he hasn't done that yet, as far as he remembers
19:40:00 <wavewave> yeah.  I hope reddit exist 30 years from now.
19:40:36 <wavewave> anyway, i found a gem written by oleg.
19:40:40 <Eduard_Munteanu> Yeah, otherwise you'll be like "back in mah days, we just used reddit" :P
19:42:04 * ddarius assures you, reddit will not exist.
19:42:39 <Olathe> The reddit2030 problem
19:43:02 <Olathe> We must solve it now while there's still time.
19:43:08 <shachaf> longbets.org
19:48:33 <Eduard_Munteanu> "382. Large Hadron Collider will destroy Earth. 10 years 02008-02018 $1,000 $500"
19:50:52 <Olathe> http://longbets.org/601/
19:54:39 <ClaudiusMaximus> ddarius: if you're curious, http://claudiusmaximus.goto10.org/g/mandelbrot/anti-aliasing-faulty.png http://claudiusmaximus.goto10.org/g/mandelbrot/anti-aliasing-fixed.png
19:57:56 <ddarius> The difference is unnoticable except in the radials just surounding the main lobes where the difference is pretty dramatic.
20:03:02 <dankna> you cannot antialias a fractal!
20:03:30 <Jafet> You can supersample it
20:03:37 <dankna> yes, but it doesn't make sense
20:03:39 <Jafet> Or you can buy a finer monitor!
20:03:43 <dankna> yes, that
20:04:08 <dankna> anyway I guess I see the effect
20:05:27 <ClaudiusMaximus> yeah this is a blend of two supersampled layers 2x magnification apart; the bug was building the layers at the wrong scale, tiles not interpolated while being downscaled, instead of rendering tiles into a sheet pixel accurate and then downscaling with interpolation
20:05:54 <dankna> ah, okay.  I see.
20:06:05 <Jafet> You need that to do zoom animations
20:06:16 <dankna> fair
20:07:46 <ClaudiusMaximus> second half of http://claudiusmaximus.goto10.org/cm/2010-08-31_optimizing_zoom_animations.html describes the blending factor, not currently using the first part in this project
20:07:55 <Jafet> Here's another way of animating https://saywh.at/mb.mkv
20:08:49 <dankna> is that your site, Jafet?  the cert is invalid
20:09:05 <Jafet> The cert is mine, not some money grubbing cert company's
20:09:12 <dankna> ah okay
20:09:20 <Jafet> Besides, I'm not taking your credit card number
20:09:26 <Jafet> (Unless you don't mind)
20:09:27 <dankna> but but
20:09:33 <ClaudiusMaximus> https is broken anyway, so who cares
20:09:39 <dankna> mm, true :(
20:11:56 <Cale> BUT WHAT IF SOMEONE IS DOING A MITM ATTACK ON MY DOWNLAOD OF THIS VIDEO FILE AND REPLACING IT wITH RICK ASTLEY??!!!1
20:12:03 <Eduard_Munteanu> ClaudiusMaximus: interesting way to offer a preview of posts
20:12:14 <Eduard_Munteanu> I mean the image glimpse.
20:12:24 <Jafet> Cale: or worse, another fractal http://adrinael.net/hr.gif
20:13:19 <ClaudiusMaximus> Jafet: this is the kind of animations i'm intending http://claudiusmaximus.goto10.org/g/mandelbrot/knotty3.gif
20:14:10 <dankna> that's a really cool animation
20:14:15 <dankna> love the color scheme btw
20:15:29 <Jafet> ClaudiusMaximus: uh, how are you changing the viewport in that sequence?
20:16:24 <Jafet> Viewing parameters, or whatever
20:16:41 <ClaudiusMaximus> Jafet: navigating by angled internal addresses - the first frame is "1 1/3 4" which is the biggest island at the top, the next is "1 1/3 4 5", then "1 1/3 4 5 6" , and so on
20:17:10 <Jafet> Ah, so it is jumping between islands.
20:17:14 <ClaudiusMaximus> yes
20:17:55 <ClaudiusMaximus> so after adding scripting support so i don't have to type an extra number for each frame, i want to add rotation detection to align them all so it doesn't spin insanely
20:18:06 <Jafet> Knowing those addresses would really let you reduce computation, by identifying interiors
20:18:30 <Jafet> How do you find the islands?
20:18:43 <dankna> easy
20:18:45 <dankna> they're colored red
20:19:16 <ClaudiusMaximus> angled internal address -> external angle -> trace external ray -> newton's method to find the center and size
20:20:28 <ClaudiusMaximus> the first arrow is using a really rubbish algorithm i came up with - need to understand the paper properly and write a not-slow version
20:20:43 <ClaudiusMaximus> dankna: :)
20:20:56 <dankna> hehe, well, I mean, I know it's more complicated than that :)
20:21:01 <dankna> but it's the same principle
20:21:49 <dankna> @hoogle negate
20:21:50 <lambdabot> Prelude negate :: Num a => a -> a
20:23:51 <ClaudiusMaximus> i don't think addresses help with reducting computation for interiors, because it's not obvious what the coordinates will be; there's ways of finding islands inside the viewport that work better (eg: http://mrob.com/pub/muency/period.html )
20:25:41 <ClaudiusMaximus> which i also want to add to my program - currently it has a button to find one near the center of the view and zoom to it, but an overlay with more information would be nice
20:27:00 <ClaudiusMaximus> > sqrt $ 1920^2 + 1080^2
20:27:01 <lambdabot>   2202.9071700822983
20:28:17 <Jafet> > sqrt $ 2560^2 + 1600^2
20:28:18 <lambdabot>   3018.8739622581134
20:28:40 <JoeyA> If I hs_init without hs_exit, what will happen?
20:29:10 <JoeyA> Will it automatically call shutdownHaskellAndExit at exit?  Or will it just leak resources, or worse?
20:29:29 <slack1256> @type hs_init
20:29:30 <lambdabot> Not in scope: `hs_init'
20:29:38 <JoeyA> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/ffi-ghc.html
20:31:33 <dankna> JoeyA: it won't do that,
20:31:37 <dankna> that is, it won't leak
20:31:50 <dankna> inasmuch as you can only ever have one hs_init/hs_exit pair
20:31:56 <dankna> (repeated ones aren't supported)
20:32:07 <dankna> so the end of your program is also the end of all resources associated with it
20:32:20 <dankna> it also won't call shutdownHaskellAndExit though
20:32:29 <dankna> you need to do it by hand
20:32:46 <dankna> this is especially important if you need to profile your code, as profiling isn't written out until the RTS shuts down
20:32:58 <JoeyA> What does that do, anyway?  Just free resources so valgrind will be happy?
20:33:05 <JoeyA> ah, okay
20:33:25 <dankna> well, making valgrind happy is an important benefit too :)
20:34:30 <slack1256> anybody here has experiences on haskell on ARM
20:34:41 <bfig> i'm having trouble understanding the newtype constructor syntax
20:34:59 <JoeyA> newtype Foo = A | B | C
20:35:08 <parcs> JoeyA: what
20:35:11 <JoeyA> oops
20:35:17 <slack1256> because the raspberry pi is out on November
20:35:30 <JoeyA> newtype can only have one constructor
20:35:40 <slack1256> joeyA: change that for a "data"
20:35:47 <JoeyA> right
20:35:53 <bfig> suppose i have data D a = Dat a, that is a data constructor. consider the same but as a newtype: newtype D a = D{Data::a}
20:36:02 <bfig> is that right?
20:36:10 <JoeyA> D {data :: a}
20:36:14 <JoeyA> err, data_
20:36:17 <JoeyA> (data is a keyword)
20:36:27 <shachaf> bfig: newtype syntax is exactly like data syntax, except restricted.
20:36:29 <JoeyA> When you see stuff like this:
20:36:31 <parcs> you are mixing record syntax and newtype syntax
20:36:34 <bfig> sorry, {Dat::a}
20:36:45 <parcs> newtype D a = Dat a
20:36:46 <JoeyA> newtype State s = State {runState :: s -> (a, s)}
20:36:57 <parcs> that's it -- just change the keyword to newtype
20:36:59 <JoeyA> It's using record syntax.
20:37:10 <slack1256> bfig: do you understand correctly the newtype intention?
20:37:22 <bfig> slack1256, yes, i am just having problems with the semantic
20:38:10 <bfig> you want to instantiate an 'empty' typeclass with possibly extra behavior, in the case of monads, and you do that by hiding the type of the monad and lifting the operations through a type which also implements the monad interface
20:38:22 <slack1256> bfig: then you're 80% done, as parcs explained, just assign a new meaning to an old datatype
20:38:28 <bfig> (this besides the 1 parameter restriction thing)
20:38:54 <bfig> but i have some practical concerns: since i can't pattern match, how can i recover the value of the thing?
20:39:13 <parcs> you can't pattern match?
20:39:15 <parcs> why not
20:39:24 <bfig> say i capture something of type d::D, then i get (Dat d)::a ?
20:39:47 <bfig> i can't pattern match what's inside, i can only reference it through the function, but that's why i'm asking, how can i reference the value inside
20:40:30 <bfig> since the Dat is not a 'constructor' itself, it is more of an 'accessor function' over the newtype, right?
20:40:59 <bfig> i have a hard time wrapping my head around the notation basically. any place where i could see some simple examples?
20:41:30 <JoeyA> newtype is exactly like data, except you can only have one constructor.
20:41:34 <Cale> bfig: If a value's name starts with an uppercase letter, then it's a data constructor and you can pattern match against it
20:41:53 <JoeyA> Oh, and it's strict in its argument.
20:42:00 <bfig> ok
20:42:07 <monochrom> f (D (Dat x)) = ... is a fine pattern
20:42:09 <JoeyA> Internally, the newtype constructor isn't even there.  It's there for typing purposes.
20:42:12 <elliott> <JoeyA> newtype is exactly like data, except you can only have one constructor.
20:42:13 <bfig> yeah if it wasn't strict it'd be no good for monadic stuff :D
20:42:16 <elliott> and one field
20:42:26 <Cale> bfig: ?
20:42:32 <monochrom> Dat is a data constructor just fine
20:42:35 <elliott> bfig: What makes you say that? The monad laws actually rely on laziness to a large degree.
20:42:43 <elliott> (e.g. IO technically violates them because it is too strict...)
20:42:54 <Cale> Does it?
20:43:18 <bfig> well, wouldn't it be a problem if you don't have an explicit state hanging around?
20:43:20 <Cale> Which monad law does IO violate?
20:43:37 <bfig> ie, if nothing is modified in the haskell runtime then why would the monad be computed?
20:43:46 <elliott> Cale: It was on haskell-cafe a while ago. return undefined >>= return or something?
20:44:09 <monochrom> return undefined >> putStrLn "hi"  poses no problem
20:44:12 <elliott> Cale: http://www.haskell.org/pipermail/haskell-cafe/2007-February/022265.html
20:44:18 <elliott> Oh, hmm
20:44:21 <elliott> That's a reply to the relevant thread
20:44:30 <elliott> Well, it'll be somewhere in that quote maze...
20:44:34 <bfig> since the newtype could be a constructor it could be on WHNF and nothing would be computed inside, right?
20:45:09 <bfig> maybe it's just the sleep... :p
20:45:12 <bfig> brb
20:45:23 <Cale> bfig: You're a little hard to understand :/
20:45:26 <monochrom> I vaguely remember a corner case of IO possibly violating a monad law, but it is not as easy as return undefined, and it is not an objectively certain violation
20:46:07 <elliott> yeah it's
20:46:08 <elliott> > > >>>>> Prelude> let f = undefined :: Int -> IO Int
20:46:08 <elliott> > > >>>>> Prelude> f `seq` 42
20:46:08 <elliott> > > >>>>> *** Exception: Prelude.undefined
20:46:08 <elliott> > > >>>>> Prelude> ((>>= f) . return) `seq` 42
20:46:08 <elliott> > > >>>>> 42
20:46:09 <lambdabot>   <no location info>: parse error on input `>'
20:46:09 <lambdabot>   <no location info>: parse error on input `>'
20:46:09 <lambdabot>   <no location info>: parse error on input `>'
20:46:09 <lambdabot>   <no location info>: parse error on input `>'
20:46:11 <lambdabot>   <no location info>: parse error on input `>'
20:46:13 <elliott> augh
20:46:56 <shachaf> > let x = undefined :: IO Int in x `seq` 1
20:46:57 <lambdabot>   *Exception: Prelude.undefined
20:46:57 <shachaf> > let x = undefined :: IO Int in (x >>= return) `seq` 1
20:46:58 <bfig> well now that i think about it, since you can instance a monad in the newtype, then when you sequence that monad you have to go through the appropriate actions anyway
20:46:58 <lambdabot>   1
20:47:11 <elliott> that seems like a pretty clear violation to me
20:47:41 <monochrom> ((>>= f) . return) `seq` 42  has very little to do with IO. more to do with lambda terms being WHNF
20:47:52 <shachaf> monochrom: What about >>= return?
20:48:19 <monochrom> what is the type of (>>= f) . return, first of all?
20:48:35 <elliott> shachaf's example is better.
20:48:42 <elliott> Since it is a direct violation and asks none of these questions :-)
20:49:32 <monochrom> (x >>= return) `seq` 1 confuses IO execution and pure value evaluation
20:49:46 <Cale> Well, undefined and const undefined ought to be the same thing. It's seq's fault that they're different :P
20:49:58 <monochrom> when you're in IO execution mode, yes, x >>= return should crap out
20:50:25 <monochrom> when you're (x >>= return) `seq` 1 ing, you don't even enter IO execution mode, period
20:50:30 <elliott> monochrom: So "x >>= return === x" doesn't actually mean that?
20:51:02 <Cale> undefined >>= return :: IO () is still morally indistinguishable from undefined :: IO ()
20:51:10 <Cale> Only seq can tell them apart
20:51:19 <elliott> Yeah, and nobody uses seq :-)
20:51:34 <shachaf> seq--
20:51:40 <elliott> @karma seq
20:51:41 <lambdabot> seq has a karma of -1
20:51:46 <elliott> @karma pseq
20:51:47 <lambdabot> pseq has a karma of 0
20:51:48 <elliott> @karma par
20:51:49 <lambdabot> par has a karma of 0
20:51:50 <shachaf> seq isn't even strict in its argument.
20:52:55 <Cale> Well, if you're using seq, you usually don't use it to try to get undefined.
20:54:45 <Cale> It's kinda funny that semantically, seq is only distinguishable from flip const in terms of the case when its first parameter is undefined, but that case should never come up in a real program.
20:54:50 <dorjesm> anyone have any example of using Network.TLS for client connections. I'm trying to use NetHaskell.IMAP to connect to gmail which requires ssl
20:56:38 <monochrom> ok, I see why it should crap out now. it's a pain to implement for GHC, so no one fixes it
20:56:53 <kmc> heh, I wrote a BSD-licensed library which depended on a LGPL-licensed library which became a MIT-licensed library
20:57:24 <kmc> funny because i gave this as an example before of why you might pick BSD license even if you have GPL deps
20:57:26 <kmc> and now it's happened to me :)
20:57:29 <monochrom> whereas if you take the "IO is implemented by a backend algebraic data type to represent the recipe", you can get it to crap out automatically
21:04:17 <bfig> i'm looking at a possible definition of a state transformer and i don't understand one part
21:05:26 <bfig> if i have a constructor {runStateT :: s -> m (a, s)}, how do i compute the monad inside? do i simply reference runStateT?
21:06:23 * monochrom shakes head. must you mix up terminologies like that? {runStateT :: s -> m (a, s)} is not a constructor. runStateT is not a constructor either.
21:06:58 <bfig> i'm not the one who started calling it like that, i'm using your own (this channel's ) terminology
21:07:20 <bfig> i can't wrap my head around the fact that runStateT can or should be a constructor in my head
21:07:23 <monochrom> well, sorry to say not my terminology
21:07:30 <bfig> how do you call them?
21:08:10 <monochrom> no name. I look at "newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}" as a whole
21:08:25 <bfig> what is runStateT ? what can i do with it and how do i use it?
21:08:34 <shachaf> Was there a web page that said something along the lines of "there are four general cases, big -> big, big -> small, small -> big, small -> small, and the only place where you really want strictness by default is the second one", or something like that?
21:08:40 * shachaf dimly recalls a discussion like that.
21:08:55 <monochrom> runStateT can be used as a field name, as though you have a record
21:09:01 <glguy> shachaf: Cale just talked about that in this channel this Friday
21:09:10 <bfig> mmm what?
21:09:12 <glguy> shachaf: and that would be in the logs
21:09:17 <monochrom> runStateT can be used as a field name, as though you have a record
21:09:31 <bfig> if i have a::StateT, i say runStateT a, does that make sense?
21:09:38 <shachaf> glguy: Hmm, it might've been Cale talking about it in this channel, though it was much longer ago than last Friday that I saw it. :-)
21:09:49 <shachaf> Do you know if there's an article somewhere that says that sort of thing?
21:09:51 <glguy> I'm sure that Friday wasn't the first time
21:09:53 <glguy> I don't know
21:09:55 <monochrom> yes.
21:10:12 * shachaf looks for the logs.
21:10:23 <monochrom> no. "a::StateT" is incomplete
21:10:36 <glguy> bfig: in "newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}", the second StateT is the constructor
21:10:37 <Cale> That might be another one of those things you could grep for
21:10:39 <Cale> haha
21:10:58 <bfig> a::(StateT Ret SomeState)
21:11:16 <bfig> or the other way. a::(StateT SomeState Ret)
21:11:28 <monochrom> how about a :: StateT SomeState IO Ret?
21:11:44 <monochrom> you really need 3 parameters there
21:11:49 <bfig> ahh. so what does the {...} syntax mean glguy
21:11:51 <bfig> ?
21:11:58 <kmc> bfig, ¬´newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}¬ª  ‚â°  ¬´newtype StateT s m a = StateT (s -> m (a, s)); runStateT (StateT x) = x¬ª
21:12:11 <kmc> (except that you also get record update and record construction syntax, but those would rarely be used in this context)
21:12:30 <bfig> ahh cool, so it is just syntactic sugar
21:12:38 <kmc> it's a record label
21:12:50 <kmc> no different from ¬´data Person = MkPerson { age :: Int, name :: String }¬ª
21:15:23 <bfig> i just had a revelation :)
21:15:31 <bfig> i suddenly understand transformers :D
21:15:45 * bfig humbly thanks for the time and patience
21:15:49 <kmc> nice :)
21:16:15 <bfig> this is what happens when you act like you know haskell while in fact you don't know shit
21:16:21 <bfig> (talking about me)
21:19:09 <shachaf> @remember glguy lazy evaluation is best 50% of time because there are 2 cases, the cases where it is the best and the cases where it is not the best
21:19:09 <lambdabot> Nice!
21:20:11 <glguy> without the context of cale's comment that could make me look silly ;-)
21:22:56 <copumpkin> onoes, flame war starting
21:23:11 <glguy> mailing list?
21:23:23 <copumpkin> new Eq and Ord instances on Double/Float
21:23:30 <kmc> morpheus is fighting neo
21:26:37 <huangjs> what's the best way to express [n..1]? and list like [2,4,6,...2n]
21:27:09 <kmc> > [2,4..20]
21:27:10 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:27:15 <huangjs> k...
21:27:20 <kmc> > [10,9..1]
21:27:21 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:27:39 <huangjs> ah i see. can i do [n, n-1, ...1] ?
21:27:39 <kmc> > map (*2) [1..10]
21:27:40 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
21:27:42 <kmc> yes
21:27:51 <huangjs> cool, thanks
21:27:57 <kmc> > let n = 10 in  [n, n-1 .. 1]
21:27:58 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:28:20 <kmc> > takeWhile (>0) $ iterate pred 10
21:28:21 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:28:39 <shachaf> @pl \n->[n,n-1..1]
21:28:40 <lambdabot> flip (ap enumFromThenTo (subtract 1)) 1
21:29:12 <huangjs> > let n = 11 in [2,4..n]
21:29:13 <lambdabot>   [2,4,6,8,10]
21:29:16 <huangjs> cool
21:29:30 <shachaf> > takeWhile (>0) $ iterate fred 10
21:29:32 <lambdabot>   [10*Exception: Fred
21:30:08 <parcs> flip ap? ew
21:30:34 <parcs> > (enumFromThenTo =<< subtract 1) 1 5
21:30:35 <lambdabot>   [0,1,2,3,4,5]
21:30:45 <parcs> curses.
21:34:16 <bfig> how do i clear screen in ghci
21:34:23 <parcs> ^L
21:34:37 <bfig> cool :D
21:34:41 <bfig> ty
21:34:53 <shachaf> :!CLS.EXE
21:35:15 <kmc> :!clear
21:35:34 <shachaf> putStr "\e[H\e[J"
21:36:49 <o-_-o> Hello
21:37:07 <shachaf> @yo o-_-o
21:37:07 <lambdabot> Couldn't find fortune file
21:37:18 <kmc> hi o-_-o
21:38:23 <purpleposeidon> shachaf: Truly it is true that RealMen‚Ñ¢ use escape codes.
21:39:16 <o-_-o> I have a list like this [n0,32,n1,32,n2,32,n3,16] all of them strings. Is it possible to make the list like this [(n0, 32), n1,32), (n2, 32),..] using only things like map, foldl, filter, zip etc., ? I did it using recursive functions, but wanted to see some magic :-)
21:39:47 <maurer_> o-_-o: Problem underspecified.
21:40:23 <maurer_> (your list is also malformed)
21:40:52 <o-_-o> maurer_: Hmm... ?
21:42:16 <shachaf> maurer_: No, "all of them strings".
21:42:23 <shachaf> instance Num String where fromInteger = show
21:42:30 <kmc> :t let alt = takeWhile (not . null) . iterate (drop 2) in \xs -> zip (alt xs) (tail $ alt xs)
21:42:31 <lambdabot> forall a. [a] -> [([a], [a])]
21:42:35 <eyebloom> What is the best way to debug haskell programs?
21:42:53 <kmc> eyebloom, that depends on the program and the bug
21:43:11 <eyebloom> Pretty basic logic bugs.
21:43:14 <shachaf> eyebloom: The Feynman method is popular.
21:43:17 <kmc> eyebloom, http://haskell.org/haskellwiki/FAQ#How_can_I_find_bugs_that_occur_at_runtime.3F
21:43:36 <eyebloom> kmc: thanks
21:43:52 <eyebloom> What is the Feynman methods?
21:44:08 <o-_-o> ["n0", "32", "n1", "32", "n2", "16"]
21:44:41 <shachaf> @google feynman method
21:44:43 <lambdabot> http://c2.com/cgi/wiki?FeynmanAlgorithm
21:44:43 <lambdabot> Title: Feynman Algorithm
21:46:10 <azaq23> time complexity depends strongly on input
21:47:35 <shachaf> As well as on machine.
21:49:17 <maurer_> shachaf: No, my issue was with his result
21:49:28 <maurer_> shachaf: His result ends a tuple that was not opened
21:49:40 <shachaf> Oh.
21:50:49 * shachaf )
21:51:55 <hpaste> bfig pasted ‚Äúproblem‚Äù at http://hpaste.org/51797
21:52:38 <bfig> what is the problem with what i wrote?
21:52:59 <bfig> i tried to rewrite it several times, i always get some weird errors on the monad transformer i defined, but i'm 90% certain it is correct
21:53:00 <shachaf> bfig: Are you sure that's deserving of its own monad instance?
21:53:05 <shachaf> Rather than just Either or something like that?
21:53:26 <bfig> shachaf, this is just practice
21:53:40 <bfig> to see if i grasped the concepts
21:53:54 <bfig> after this, a simple monadic parser
21:54:13 <bfig> but now i'm having trouble with the error transformer
21:54:36 <bfig> i'm not sure i understand in any case, is it possible my code is correctly written?
21:55:03 <shachaf> If GHC gives you an error, probably not.
21:55:34 <bfig> both times it complains of 'infinite types'
21:55:38 <shachaf> Try fixing your return first.
21:55:53 <kmc> return a = ResT (return (Res a))
21:56:09 <shachaf> bfig: Your ResT instance has to do everything your Res instance does.
21:56:25 <shachaf> It doesn't magically get the definitions just because Res is a monad.
21:56:51 <kmc> bfig, as a matter of style, I'd recommend against reusing a data type name as a constructor name, unless it's the only constructor for that type
21:57:34 <bfig> yes i don't like it either, but i'm running by the playbook
21:57:44 <kmc> also you might consider defining *only* a transformer, which can be used with Identity
21:57:45 <kmc> playbook?
21:57:53 <bfig> the practice sheet
21:58:04 <kmc> ok, i see
21:58:15 <shachaf> Practice sheet?
21:58:30 <bfig> yes
21:58:41 <shachaf> An informative answer. :-)
21:58:47 <bfig> http://www.fing.edu.uy/inco/cursos/pfa/uploads/Material/practico%203%20-2011
21:59:24 <amtal> So, Data.Data and SYB. I can get type data via String + composing constructors, at runtime. How do I do stuff with this?
21:59:38 <amtal> Can I do things like auto-define instances for arbitrarily large tuples?
21:59:50 <shachaf> amtal: Why would you want to do that at runtime?
22:00:07 <bfig_> wow damn, it's 3 am
22:00:08 <shachaf> s/runtime/all/ , of course. :-)
22:00:09 <amtal> I don't know what I'm supposed to do :E
22:00:27 <amtal> And the 9-tuple example is silly, but came up while interfacing with Erlang via BERT.
22:00:28 <kmc> amtal, did you read the first SYB paper?
22:00:36 <amtal> I might've skimmed it a bit.
22:00:39 <amtal> While sleep deprived.
22:00:40 <kmc> it has some good examples
22:00:44 <amtal> Oh
22:01:15 <kmc> amtal, one thing you can easily do with SYB is, say, reverse every String buried within a complex algebraic data type
22:01:35 <shachaf> kmc: Can you? You have to be kind of careful, because String is also a cons of a Char onto a String.
22:01:37 <kmc> the boilerplate you're scrapping is stuff like ¬´reverseAll (Foo x y) = Foo (reverseAll x) (reverseAll y)¬ª
22:01:40 <kmc> yeah, you do have to be careful
22:01:43 <kmc> i think you can do it though
22:01:46 * shachaf kind of distrusts SYB because of that.
22:02:03 <amtal> So if I have a fancy AST, I could do things like extract or manipulate every function call?
22:02:19 <kmc> yeah
22:02:35 <kmc> :t everywhere (mkT (reverse :: String -> String))
22:02:40 <lambdabot> forall a. (Data a) => a -> a
22:02:55 <shachaf> > (everywhere (mkT (reverse :: String -> String))) ("hello", 1)
22:02:56 <lambdabot>   ("elolh",1)
22:03:06 <kmc> > let f = everywhere (mkT (reverse :: String -> String)) in f (Just ["foo", "bar"], [Left 3, Right "baz"])
22:03:06 <lambdabot>   (Just ["oof","arb"],[Left 3,Right "azb"])
22:03:06 <shachaf> See?
22:03:11 <kmc> haha, ouch
22:03:36 <o-_-o> Where is alt defined
22:04:08 <shachaf> Huh, the SYB slides don't use Comic Sans.
22:04:37 <o-_-o> :T alt
22:04:39 <o-_-o> :t alt
22:04:40 <lambdabot> Not in scope: `alt'
22:04:47 <kmc> > reverse ('b' : reverse "ar")
22:04:48 <lambdabot>   "arb"
22:05:05 <shachaf> I don't think you can use everywhere for reversing.
22:05:12 <kmc> > let f = everywhere' (mkT (reverse :: String -> String)) in f (Just ["foo", "bar"], [Left 3, Right "baz"])
22:05:13 <lambdabot>   (Just ["ofo","rba"],[Left 3,Right "zba"])
22:05:32 <shachaf> Maybe you can come up with something more complicated, but off-hand I don't see how. I haven't actually used SYB, though.
22:05:47 <o-_-o> nevermind
22:05:49 <o-_-o> I am stupid
22:06:38 <shachaf> > everywhere (mkT (reverse :: String -> String)) "1234567890"
22:06:39 <lambdabot>   "2468097531"
22:06:45 <kmc> > let f = everywhereBut (mkQ (const True :: String -> String)) (mkT (reverse :: String -> String)) in f (Just ["foo", "bar"], [Left 3, Right "baz"])
22:06:46 <lambdabot>   Couldn't match expected type `GHC.Base.String'
22:06:47 <lambdabot>         against inferred typ...
22:06:48 * shachaf wonders if this presents any new golfing opportunities.
22:06:56 <ddarius> kmc: What's happening is its reversing theh tail and the tail of the tail etc.
22:06:58 <kmc> > let f = everywhereBut (mkQ (const True :: String -> Bool)) (mkT (reverse :: String -> String)) in f (Just ["foo", "bar"], [Left 3, Right "baz"])
22:06:58 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:06:58 <lambdabot>         against inferred type ...
22:06:58 <kmc> ddarius, yeah
22:08:05 <shachaf> But that's built into the behavior of gmapT.
22:08:13 <shachaf> Can it be avoided with any of the other SYB functions?
22:11:21 <shachaf> Hmm, http://www.haskell.org/haskellwiki/Scrap_your_boilerplate
22:32:05 <o-_-o> woohoo map (\xs1 -> zip (take 1 xs1) (drop 1 (take 2 xs1))) (takeWhile (not . null) (iterate (drop 2) xs))
22:32:21 <o-_-o> kmc: thanks, I based this off of your code
22:32:24 <kmc> heh
22:32:28 <kmc> my code was wrong ;)
22:32:57 <o-_-o> kmc: I know, so I kinda fixed it, but atleast you put me in the right direction
22:33:01 <kmc> cool :)
22:33:22 <o-_-o> so are there some place where there are standards patterns for doing things to lists ?
22:33:33 <o-_-o> Like take every alternate element etc.,
22:33:59 <o-_-o> is there a map with a skip ? ;-)
22:34:16 <o-_-o> skipMap n f xs
22:34:23 <o-_-o> apply f to every nth element
22:34:35 <shachaf> Why would you have one function for that instead of skip and map?
22:34:46 <o-_-o> :t skip
22:34:47 <lambdabot> Not in scope: `skip'
22:35:05 <o-_-o> shachaf: there is no skip
22:35:21 <shachaf> OK, but why would you write a skipMap function?
22:36:00 <kmc> why have concatMap when we have concat and map
22:36:43 <o-_-o> shachaf: I am not sure I understand what you are saying, I think it is just convenience.
22:36:49 <shachaf> Why have skipMap when you have skipMapFilterConcat
22:38:20 <kmc> why use skipMapFilterConcat when you have zygohistomorphic_prepromorphism
22:39:13 <shachaf> kmc: Because you want a generalized zygomorphism, obviously.
22:40:18 <kmc> "And from the new implementation it should be obvious how to implement a generalized zygohistomorphic prepromorphism, by relaxing the constraint that you have a (Base t)-Branching stream, through the use of distGHisto instead."
22:42:45 * shachaf is only a beginner in edwardkese. :-(
22:44:06 <ddarius> kmc: Because (flip) concatMap is bind.
22:44:26 <shachaf> @google flip concatMap
22:44:26 <lambdabot> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/2/960526234_VYAt3
22:44:27 <lambdabot> Title: flip concatMap - Sean Leather's Photos
22:45:13 * hackagebot googleplus 0.1.0 - Haskell implementation of the Google+ API  http://hackage.haskell.org/package/googleplus-0.1.0 (MichaelXavier)
22:46:04 <o-_-o> let fun1 (x0:x1:xs) | xs == [] = (x0,x1):[] |otherwise = (x0, x1): fun1 xs
22:46:08 <o-_-o> what is wrong with this ?
22:46:09 <o-_-o> it works
22:47:17 <cheater> haha, that made it look like some big part of Google+ could be replaced with flip concatMap.
22:48:50 <ClaudiusMaximus> gnarg. just fixed another bug - i clearly fail  (this time it was `fromIntegral :: Integer -> Double` before the subtraction instead of afterwards)
22:49:00 <ziman> o-_-o, it's better to replace the comparison with the empty list with pattern matching instead
22:50:05 <ClaudiusMaximus> @check (\x y -> fromInteger x == (fromInteger y :: Double) && x /= y)
22:50:06 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0\n"
22:50:58 <ClaudiusMaximus> @check (\x y -> fromInteger x == (fromInteger y :: Double) || x /= y)
22:50:59 <lambdabot>   "OK, passed 500 tests."
22:55:47 <kmc> @pl \x -> (Just x :)
22:55:48 <lambdabot> (:) . Just
22:58:04 <ClaudiusMaximus> > let x = 2^200 :: Integer ; y = x + 1 in (fromInteger x :: Double) == fromInteger y
22:58:05 <lambdabot>   True
23:02:02 <o-_-o> ziman: I get some error when I try to define like that
23:02:23 <o-_-o> let func2 (x0:x1:xs) = (x0,x1): func2 xs
23:02:34 <o-_-o> let func2 (x0:x1:[]) = (x0,x1)
23:03:14 <o-_-o> What is wrong with the above ?
23:03:40 <kmc> what error?
23:03:49 <o-_-o> Non-exhaustive patterns in function func2
23:03:50 <kmc> and can you hpaste the whole code?
23:04:05 <kmc> ah
23:04:10 <ziman> in the second clause, the result of the function is just a pair; in the first one, the result is a list
23:04:11 <kmc> you don't have a case for func2 []
23:04:31 <ziman> (and func2 [x])
23:04:46 <o-_-o> let func2 (x0:x1:[]) = (x0,x1):[] this didn't work either
23:04:57 <kmc> all the cases have to be inside the same "let"
23:05:10 <ziman> o-_-o, look at what the error message says; it's there to help you
23:05:33 <ziman> o-_-o, are you defining this function in ghci?
23:06:12 <o-_-o> ziman: yes
23:07:49 <o-_-o> ah...that worked
23:07:52 <o-_-o> ziman thanks
23:07:58 <o-_-o> I tried it inside a file
23:08:02 <ziman> I'd recommend firing up a text editor and writing the definition there; it's much more convenient (although there is some weird syntax to define multiline functions in ghci)
23:08:10 <ziman> great.
23:09:14 <o-_-o> But yes, it needed a func2 [] = [] definition
23:11:39 <Reisen> Hey, I'm having issues with cabal, I couldn't find anything in the cabal FAQ, I'm not sure exactly what's wrong: http://pastebin.com/LcGQXLcK
23:11:41 <mauke> The paste LcGQXLcK has been copied to http://hpaste.org/51799
23:11:50 <Reisen> I can't install anything at all without it telling me that something is unavailable
23:13:38 <cheater> why are 2-tuples called "ordered pairs"? does haskell have unordered pairs?
23:17:17 <ClaudiusMaximus> data Pair a = Pair a a ; instance Eq a => Eq (Pair a) where Pair a b == Pair x y = (a == x && b == y) || (a == y && b == x) -- perhaps
23:20:36 <o-_-o> Prelude> import Control.Monad.State
23:20:36 <o-_-o> <no location info>:
23:20:36 <o-_-o>     Ambiguous module name `Control.Monad.State':
23:20:36 <o-_-o>       it was found in multiple packages: mtl-2.0.1.0 monads-tf-0.1.0.0
23:20:40 <o-_-o> How to fix this ?
23:23:11 <erus`> looks nasty
23:27:37 <hpaste> Reisen pasted ‚ÄúGHC running out of memory.‚Äù at http://hpaste.org/51800
23:28:01 <Reisen> Above paste is my issue now, grabbed a later version of cabal to see if it solved anything, ghc runs out of memory when configuring, any idea how I can solve this?
23:30:53 <Cale> o-_-o: ghc-pkg hide one of those two packages
23:30:59 <Cale> (probably monads-tf)
23:31:42 <Cale> Reisen: interesting. How much memory is in the system you're doing this on?
23:31:51 <Reisen> 256MB, not much
23:32:02 <Cale> ah, hmm
23:32:39 <Blkt> good morning everyone
23:32:57 <Reisen> Morning
23:36:07 <Cale> Reisen: on my machine, it takes around 125MB to build that package
23:36:51 <Reisen> Cale, something must be really wrong on my end then
23:37:13 <Cale> Well, I'm on a 32 bit architecture, if it's any different for you
23:37:32 <Cale> (with only 256MB of memory, it'd be kinda funny to use a 64 bit arch :)
23:37:40 <Reisen> Yeah, using 32bit here as well
23:38:00 <elliott_> Reisen: Swap?
23:38:03 <Cale> If you're really desperate, you could try splitting those modules up into smaller parts.
23:38:26 <Cale> But yeah, can you turn on a swap file? That would certainly help
23:38:56 <Cale> How big does the ghc process get before it dies?
23:39:15 <Reisen> Oh, I feel really silly now, didn't think about swap at all
23:39:18 <Reisen> bare with me
23:39:18 * hackagebot monad-lrs 0.0.1 - a monad to calculate linear recursive sequence  http://hackage.haskell.org/package/monad-lrs-0.0.1 (BinJin)
23:39:55 <shachaf> Reisen: Also, get more RAM. :-)
23:40:13 <Cale> I figure it's got to be some kind of embedded thing
23:40:25 <Cale> Or something :)
23:40:30 <rostayob> 256 MB ought to be enough for everybody!
23:40:40 <Reisen> shachaf, It's a cheap VPS I grabbed until I get my laptop back
23:40:41 <shachaf> Even phones have more RAM than that nowadays.
23:40:44 <Cale> rostayob: You'd really think so, wouldn't you?
23:40:45 <shachaf> Ah, I see.
23:41:23 <rostayob> Cale: yeah. jokes aside, ghc is really memory hungry
23:41:51 <shachaf> Reisen: What computer are you connecting to the VPS from? :-)
23:42:15 <erus`> i couldn't compile much with less than 1gig ram (even without x)
23:42:46 <Reisen> shachaf, one I can't install linux to as my main OS sadly
23:42:47 <rostayob> erus`: I'm with 1GB of ram and life is good, what couldn't you compile?
23:43:00 <shachaf> Reisen: GHC runs under other OSes, and under VMs. :-)
23:43:04 <Reisen> shachaf, but the reason I wanted the VPS was for when I'm in class, where I normally have my laptop
23:43:18 <erus`> i had to up from 768 to compile snap
23:43:27 <Reisen> shachaf, yeah but, windows just feels so depressing to do any kind of development under D:
23:43:33 <shachaf> Cygwin, or something.
23:43:39 <Reisen> Hmm
23:43:40 <ClaudiusMaximus> someone here maybe suggested another machine on the lan's ram as swap, i tried nfs and sshfs but couldn't get it to work with either.  as it is i can't haskell properly on my old laptop with 256MB :(
23:43:43 <shachaf> Or a VM. I hear that actually works reasonably.
23:44:00 <shachaf> rostayob: Life isn't as good as it would be with 8GB.
23:44:01 <Reisen> Yeah fair points, but still doesn't change the
23:44:03 <Reisen> being in class part
23:44:08 <Reisen> which is where I normally have my laptop
23:44:21 <rostayob> shachaf: mah I had 8GB at work and it doesn't do much of a difference
23:44:30 <Reisen> putty isn't quite as 'what the hell are you doing with our computers' than setting up a VM
23:44:46 <erus`> does anyone have usage estimates for haskell ?
23:44:55 <shachaf> rostayob: But your page cache!
23:45:00 * shachaf always assumed it made a big difference.
23:45:18 <rostayob> shachaf: my page cache? TLB?
23:45:41 <elliott_> It certainly does do much of a difference, rostayob must be a human GC or something :)
23:46:12 <rostayob> elliott_: I mean 90% of the time I have a browser with like 5 tabs, a terminal with IRC and emacs. that's it
23:46:23 <elliott_> Five tabs? How?
23:46:29 <rostayob> unless you have huge projects to compile often it doesn't make a big difference
23:46:31 <rostayob> DISCIPLINE
23:46:32 <elliott_> Do you give classes?
23:46:34 <Cale> Having more than 1GB of memory has basically made me wasteful of it. I leave so much crap running now.
23:46:51 <elliott_> A hundred tabs is about my average.
23:46:57 <rostayob> elliott_: pfff
23:47:03 <Cale> I don't leave tabs open in my browser though.
23:47:08 <shachaf> rostayob: Not the page table cache, the cache for the actual disk pages. :-)
23:47:31 <shachaf> Cale: Right, because constantly spending your time worrying about closing programs is much more efficient. :-)
23:47:36 <Cale> (maybe something like 5 tabs average)
23:47:38 <rostayob> shachaf: what's the difference?
23:47:44 <rostayob> ah
23:47:46 <rostayob> the actual cache
23:47:52 <rostayob> why do you call it page cache :P?
23:48:03 <shachaf> Isn't that what it's normally called?
23:48:12 <rostayob> well I call the memory cache "cache"
23:48:14 <shachaf> Would you prefer "buffer cache"?
23:48:40 <shachaf> Oh, "cache". I guess that would reduce ambiguity.
23:48:47 <elliott_> "Disk cache"?
23:49:05 <rostayob> I'm not sure we're talking about the same thing. I'm talking about the cache between processor and memory
23:49:14 <shachaf> elliott_: I'd think of the actual cache in the disk itself.
23:49:24 <elliott_> shachaf: Strange.
23:49:33 <rostayob> there is a cache for the pages in the swap file??
23:49:34 <shachaf> rostayob: I'm talking about the cache of hard disk blocks in the RAM.
23:50:01 <Reisen> Ah, was confused, it seems OpenVZ does not support swap, which explains why I'm getting operation not permitted
23:50:02 <rostayob> shachaf: ok, I didn't know about that
23:50:33 <shachaf> It's pretty important: http://i.imgur.com/X1Hi1.gif
23:50:55 <elliott_> shachaf: SSDs make that picture slightly better.
23:51:05 <shachaf> elliott_: True. But they're much more expensive than 8GB of RAM.
23:51:11 <shachaf> Which you can get for ~$40 nowadays.
23:51:28 <elliott_> shachaf: Yeah, but you could get a pony for, like, half that.
23:51:37 <elliott_> And ponies don't have big red splotches of nanoseconds.
23:51:45 <elliott_> Well, usually.
23:51:52 <shachaf> omg ponies
23:51:58 <rostayob> shachaf: right, page cache. I had forgot about that.
23:52:28 <raichoo> ponies <3
23:52:35 <rostayob> the term "page" is confusing anyway. we should use for memory only
23:52:45 <shachaf> http://www.metlin.org/content/blog/omgponies.jpg
23:52:55 <shachaf> rostayob: Fine, "buffer cache".
23:53:03 <shachaf> I think at least Linux makes a distinction between the two, though.
23:53:13 <kmc> oh that's from http://duartes.org/gustavo/blog/post/what-your-computer-does-while-you-wait
23:53:15 <kmc> really good article
23:53:24 <kmc> (data is from, not picture)
23:53:26 <Reisen> So yeah, with no option of swap space, any idea how I can get around this problem? It still seems strange that it only uses 145MB for Cale, yet climbs to my memory limit for me
23:53:44 <Cale> Reisen: might be our ghc version
23:53:51 <shachaf> kmc: I haven't seen the article.
23:53:52 <Cale> cale@ender:~/Cabal-1.10.2.0$ ghc --version
23:53:52 <Cale> The Glorious Glasgow Haskell Compilation System, version 7.0.3
23:53:58 <kmc> SSD: http://images.anandtech.com/graphs/thessdanthology_031809001858/18641.png
23:54:00 <Reisen> Cale, ah, 7.2.1
23:54:04 <Cale> I haven't upgraded to 7.0.4 yet ;)
23:54:38 <kmc> that "Western Digital VelociRaptor" sliver represents about the fastest spinny drive you can buy
23:54:38 <TNA-MichaelK> I gave up on trying to get v7 to work and settled with 6...
23:55:15 <shachaf> kmc: That's throughput, not latency.
23:55:32 <kmc> shachaf, it's random access, so it's both
23:56:29 <Cale> 'The 7.2 branch is intended to be more of a "technology preview" than normal GHC stable branches.' -- sort of scared me off a bit, though the real reason I'm still on 7.0.x is to keep things in sync with work.
23:56:49 <Reisen> Ah, well grabbing 7.0.4 now to see if it helps
23:57:00 <rostayob> Reisen: 7.0.3 is the "current" one
23:57:10 <rostayob> the one that comes with the haskell platform
23:57:10 <Reisen> rostayob, meant 7.0.3, lazy finger hit 4
23:57:16 <rostayob> ok :)
23:57:27 <Cale> 7.0.4 exists
23:57:30 <rostayob> don't you dare download ghc 7.0.4
23:57:50 <Cale> It just has some bugfixes relative to 7.0.3
23:57:57 <Reisen> Cale, yeah, but you said 150~ MB with 7.0.3, so figured it would be safe to just go with that
23:58:12 <elliott_> rostayob: 's wrong with 7.0.4?
23:58:22 <rostayob> elliott_: nothing, just wanted to say something
23:58:31 <elliott_> heh
