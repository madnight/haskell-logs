00:00:42 <rostayob> Is it possible to show strings in ghci without ghci calling "show" on them? so that it displays newlines and stuff like that
00:01:18 <elliott> putStr
00:01:20 <koeien> rostayob: putStrLn
00:02:47 <rostayob> right, thanks
00:16:53 <gavino> :)
00:17:00 <gavino> haskell seems very cool sofar
00:17:11 <gavino> happstack looks sick
00:17:19 <koeien> that sounds about right
00:17:25 <koeien> sick?
00:22:24 <rostayob> To generate haskell code with haskell-src, should I use the pretty printing functions? I'm asking this because the pretty printing functions don't seem to add parenthesis when having something like (HsApp (HsApp this that) foo)
00:26:22 <kmc> rostayob, well, in Haskell,  (x y z) is equivalent to ((x y) z)
00:26:34 <kmc> so it's fine to omit the parentheses, and that's the typical style
00:26:40 <kmc> do you need them for some particular reason?
00:27:42 <rostayob> kmc: oh right, I got confused
00:28:06 <rostayob> but anyway, if I provide the pretty printing function with a correct syntax tree, they will provide correct code right?
00:28:24 <kmc> that's the idea... if it doesn't, that's a bug
00:28:36 <kmc> btw, haskell-src-exts seems to be more popular than haskell-src
00:28:39 <kmc> or at least comes up here more often
00:28:42 <rostayob> kmc: actually, I do have a problem
00:28:45 <kmc> because in the real world people write weirdo GHC code
00:28:57 <Jafet> Parentheses obscure the true intent of the code
00:29:08 <Jafet> Pretty printing should add its own $s
00:29:13 <kmc> meh
00:29:17 <kmc> no
00:29:20 <Jafet> But only if you pay for them
00:29:24 <Veinor> Jafet: map (filter func) x
00:29:28 <kmc> $ is the true intent of the code
00:29:50 <Veinor> i don't think that can be written without parens without splitting it up
00:29:58 <Jafet> filter func `map` x
00:30:09 <kmc> pro
00:30:12 <hno> any volunteers for helping with the bootstrap of GHC on Fedora Linux ARM hardfloat? Join us in #fedora-arm if interested.
00:30:14 <Veinor> oh yeah :P
00:30:16 <Jafet> Inorite
00:30:29 <Veinor> what's the semantics of a `f` b c d anyway
00:30:35 <Veinor> or for that matter a b `f` c d
00:30:40 <rostayob> kmc: I have the HsExp for something like "foo a && foo b"
00:30:45 <kmc> same as the semantics of ¬´f a (b c d)¬ª / ¬´f (a b) (c d)¬ª
00:30:52 <Jafet> foo `or` die;
00:31:01 <kmc> prefix application binds more tightly than infix anything
00:31:02 <Veinor> kmc: i was just asking how they get desugared, yeah
00:31:08 <kmc> you can declare fixity for a `backticked` name
00:31:18 <Veinor> which makes sence considering how 1 + f 2 3 parses
00:31:34 <rostayob> so it's something like "HsApp "(&&)" (HsApp "foo" "a") (HsApp "foo" "b")". What it generates is (&&) foo a foo b
00:31:52 <rostayob> which is not correct, right?
00:32:11 <kmc> but if you don't, it's probably infixl 9
00:32:30 <rostayob> kmc: mhm?
00:32:39 <kmc> you can declare fixity for a `backticked` name but if you don't, it's probably infixl 9
00:32:39 <rostayob> I'm using && as a function, not as an operator
00:32:46 <koeien> rostayob: no that should be (&&) (foo a) (foo b)
00:32:53 <rostayob> koeien: yeah, it isn't
00:33:44 <kmc> wha'ts the actual code?
00:34:14 <kmc> maybe you're using HsIdent instead of HsSymbol, or something
00:34:22 <rostayob> kmc: oh. yes I am :P
00:34:25 <rostayob> what's the difference?
00:34:49 <kmc> prefixing every type with "Hs" is obnoxious... hadn't they heard of qualified imports?
00:35:26 <rostayob> yeah I know :P
00:35:27 <kmc> rostayob, also the first thing you said with 'HsApp "(&&)"' doesn't type-check
00:35:31 <kmc> HsApp takes two arguments, not three
00:36:09 <rostayob> kmc: I know, I have "HsApp (HsApp "(&&)" (HsApp "foo" "a")) (HsApp "foo" "b")", but that's more readable
00:36:27 <frerich> Oooh... I only now realized that some Parsec functions are meant to be used in infix notation. Like "file = line `endBy` newline"
00:36:29 <kmc> Couldn't match expected type `HsExp' with actual type `[Char]'
00:36:40 <rostayob> kmc: yes the whole thing is extremely verbose, wait a sec
00:37:05 <hpaste> haskell-src pasted ‚Äúrostayob‚Äù at http://hpaste.org/51032
00:37:23 <rostayob> kmc: http://hpaste.org/51032
00:37:50 <Jafet> Where is parsec documented, anyway?
00:38:08 <kmc> yeah, i'm getting this same behavior
00:38:22 <rostayob> kmc: so is HsIdent the problem?
00:38:55 <hpaste> kmc annotated ‚Äúrostayob‚Äù with ‚Äúrostayob (annotation)‚Äù at http://hpaste.org/51032#a51033
00:38:56 <rostayob> in the haddock doccs the difference is not explained, I wouldn't know where to look in the report
00:38:59 <kmc> i don't know
00:40:22 <rostayob> mhm...
00:40:42 <kmc> i guess you're supposed to use HsParen explicitly
00:40:48 <kmc> that's what the parser does, anyway
00:40:50 <kmc> kinda sucks though
00:41:07 <kmc> wonder if haskell-src-exts has the same problem
00:41:18 <rostayob> yeah that sucs
00:41:21 <rostayob> *sucks
00:42:49 <rostayob> kmc: well, haskell-src-exts doesn't warn you about the fact that the pretty printer doesn't put parens
00:42:56 <rostayob> it might be worth trying...
00:42:59 <kmc> it does put parens
00:43:05 <kmc> it handles this exact example correctly
00:43:20 <rostayob> kmc: oh, great
00:43:28 <rostayob> i'll change the code later to use that
00:43:31 <rostayob> thanks for the help
00:43:38 <hpaste> kmc annotated ‚Äúrostayob‚Äù with ‚Äúrostayob (annotation) (h-s-e)‚Äù at http://hpaste.org/51032#a51034
00:43:52 <kmc> hpaste announces my pastes before the web browser returns
00:43:54 <kmc> that's kind of insane
00:46:29 <rostayob> kmc: is it? usually computers are faster than humans
00:47:06 <dmwit> But the race here is between two computers, not between a computer and a human.
00:47:34 <Jafet> kmc needs to tune the tcp stack
00:48:19 <rostayob> dmwit: right, but one computer is rendering a page, the other is pasting a line on a irc chan :)
00:48:40 <dmwit> Yeah, I'm not sure I find it insane.
00:48:41 <Jafet> Well, his computer is also rendering the line in the irc channel
00:49:05 <dmwit> IRC rendering is significantly simpler than HTML rendering, I would say.
00:49:43 <koeien> and there is extra round-trip for IRC
00:49:48 <kmc> i really don't think that's the bottleneck
00:49:54 <koeien> to freenode
00:49:57 <opqdonut> dmwit: well there are all the colours and charsets to worry about!
00:50:02 <opqdonut> :)
00:50:25 <Jafet> irc natively uses wtf-8
00:50:52 <kmc> yes
00:50:57 <dmwit> There's a lot of variables. It's a race condition. Does that summarize the comments so far?
00:51:07 <kmc> the bytes mean whatever the fuck you want them to
00:51:32 <kmc> in my codepage all bytes map to ÍôÆ
00:51:58 <dmwit> Wow, that really renders badly in this font.
00:52:31 <dmwit> Also, the Wikipedia page seems to suggest that character is used in exactly one word in exactly one book.
00:52:38 <dmwit> Which I find pretty hilarious.
00:53:01 <kmc> yep
00:53:13 <kmc> a joke by some bored monk 600 years ago
00:53:19 <kmc> and now it's in Unicode
00:53:29 <kmc> and has been the subject of deliberations by numerous standards committees
00:53:42 <dmwit> ohohoho yes
00:53:46 <dmwit> That I very believe.
00:53:49 <kmc> serious business
00:54:04 <Jafet> I still like SNOWMAN
00:54:13 <rostayob> kmc: haskell-src-exts is much better
00:54:39 <kmc> it seems so
00:54:55 <Jafet> A hundred years later people will wonder what a SNOWMAN was
00:55:21 <kmc> some good new ones in Unicode 6.0: http://www.unicode.org/charts/PDF/Unicode-6.0/U60-1F300.pdf
00:55:53 <kmc> U+1F365  FISH CAKE WITH SWIRL DESIGN
00:56:21 <dmwit> 1f36e PUDDI PUDDI
00:56:26 <kmc> see if you can figure out which country is responsible for these
00:56:35 <kmc> from the "Food symbols" and "Celebration symbols" sections
00:57:38 <kmc> i'm just glad they have separate codepoints for DROMEDARY CAMEL and BACTRIAN CAMEL
00:58:05 <kmc> > generalCategory 'üê™'
00:58:06 <lambdabot>   <no location info>:
00:58:06 <lambdabot>      lexical error in string/character literal at chara...
00:58:19 <kmc> > generalCategory '\x1F42A'
00:58:20 <lambdabot>   NotAssigned
00:58:28 <kmc> :O
00:58:37 <Veinor> kmc: why are there random reserved ones
00:58:42 <Veinor> like 1F336
00:59:00 <kmc> beats me
00:59:10 <dmwit> Do we really need to have drawings in our text?
00:59:12 <jpcooper> hello
00:59:15 <kmc> hi jpcooper
00:59:25 <kmc> dmwit, some Japanese mobile phone companies decided, yes we do
00:59:31 <dmwit> Or are they just filling up the standard because there's so much room now?
00:59:34 <kmc> and Unicode has a compatibility mandate
00:59:41 <Veinor> and why is there a reserved facial part symbol
00:59:59 <kmc> if you're a Japanese mobile phone company, you too can troll the Unicode committee
01:00:13 <kmc> myself i'm holding out hope for the Goatse character
01:00:14 <Veinor> http://gyazo.com/69f3a3bea0d7af5b25528347a2262e5b.png
01:00:53 <kmc> "Im looking for a bento box, it cant be pinku (thats japanese for pink) or any girl color. It has to be of 2 or more kotoba (that's japanese for 2 compartments) and has be be chibi(small) sized. And has to be really kawaii (cute). Also It has to be about 10-20 bux."
01:01:04 <Eduard_Munteanu> kmc: but instead you got...?
01:01:06 <flux> does this mean.. there's an ocaml logo unicode symbol, but no haskell?-o
01:01:07 <jpcooper> I have an IO (Maybe a) action. I would somehow like to extract the a values and iterate a function over the result of repeatedly applying the action until the first (IO Nothing) occurs. I'm thinking of doing this with the Data.Enumerator library. Could anyone give me some pointers?
01:01:17 <Eduard_Munteanu> (just joined)
01:01:32 <kmc> jpcooper, i'd just write the recursion directly
01:01:36 <kmc> jpcooper, (IO Nothing) doesn't mean anything
01:01:42 <dmwit> There's a Hackage package for loops like this.
01:01:43 <kmc> IO is a type constructor; Nothing is a value constructor
01:02:00 <jpcooper> kmc: the thing is that I would like to iterate lazily
01:02:22 <jpcooper> I don't want to look for the IO Nothing until it's needed, if you know what I mean
01:02:23 <kmc> meaning you want the IO execution to occur as the list is consumed?
01:02:33 <jpcooper> yes, as it is needed
01:02:36 <kmc> there's still nothing called "IO Nothing"
01:02:36 <koeien> untilNothing a = a >>= (\x-> case x of Nothing -> return (); Just _ -> untilNothing a)
01:02:51 <dmwit> jpcooper: http://hackage.haskell.org/packages/archive/monad-loops/0.3.1.1/doc/html/Control-Monad-Loops.html
01:02:51 <kmc> if you want IO execution to occur as the list is consumed then you need unsafeInterleaveIO
01:02:53 <jpcooper> kmc: you know what I mean
01:03:01 <kmc> because ordinarily evaluation can't cause execution
01:03:12 <kmc> jpcooper, no, I don't.  an IO action is emphatically *not* a "wrapped" or "tainted" value
01:03:22 <jpcooper> okay
01:03:28 <kmc> it's a recipe for getting values
01:03:29 <jpcooper> I'll explain this in a different way
01:03:32 <kmc> which recipe could be executed more than once
01:03:36 <kmc> i know what you're asking for, overall
01:03:47 <kmc> but saying "IO Nothing" is wrong in a confusing way
01:04:06 <dmwit> whileJust :: Monad m => m (Maybe a) -> (a -> m b) -> m [b]
01:04:07 <jpcooper> kmc: what should I be saying instead?
01:04:17 <koeien> "until the IO action yields Nothing"
01:04:20 <kmc> "i want to execute this action until it produces Nothing"
01:04:24 <kmc> sure
01:04:26 <dmwit> flip whileJust return :: Monad m => m (Maybe a) -> m [a]
01:04:28 <jpcooper> okay
01:04:54 <mux> I call this one "whenJust"
01:04:58 <dmwit> There's also whileJust_ in case you don't care about the returned list.
01:05:05 <mux> I have needed it multiple times already
01:05:06 <kmc> anyway, if you have something of type (IO [T]) and you want the IO to occur only as the [T] is evaluated, you need unsafeInterleaveIO
01:05:15 <mux> oh, wait, it's not the same actually
01:05:20 <jpcooper> dmwit: I tried to make something like that, but it needed to find the Nothing before giving anything
01:05:30 <jpcooper> okay thanks I'll have a look at that now
01:05:40 <koeien> yes, but unsafeInterleaveIO is unsafe for a reason :)
01:05:48 <jpcooper> is there no cleaner alternative?
01:05:51 <koeien> so you have to be a bit careful that that is what you actually want, lazy IO
01:05:52 <mux> whenJust :: Maybe a -> (a -> IO b) -> IO ()
01:05:53 <jpcooper> something with enumerator?
01:06:01 <Veinor> jpcooper: i guess the question is, what are you trying to do?
01:06:04 <kmc> jpcooper, you're asking for evaluation to drive execution. that breaks one of the basic rules of haskell
01:06:16 <kmc> so no, you can't do it without unsafeInterleaveIO or something equivalent
01:06:37 <jpcooper> I want a pure function to work on the [a], but for the as to be computed only as needed, and to stop when the Nothing is found
01:06:43 <dmwit> Fork a thread, and write a's to a Chan instead of a list.
01:07:04 <kmc> "the as to be computed only as needed"  ‚Üê computed by doing IO, right?
01:07:11 <jpcooper> do Chans and their getContents use unsafeInterleaveIO?
01:07:18 <jpcooper> yes
01:07:29 <mux> catMaybes . takeWhile isJust . map f ?
01:07:58 <koeien> jpcooper: yes, it uses unsafeInterleaveIO
01:08:02 <jpcooper> mux: the as are coming from an IO (Maybe a)
01:08:02 <dmwit> jpcooper: it sure does (getChanContents calls unsafeInterleaveIO)
01:08:05 <mux> maybe even mapMaybe if laziness is sufficient to guarantee you won't compute stuff once Nothing has been returned
01:08:16 <koeien> jpcooper: much like getContents from the Prelude
01:08:22 <jpcooper> okay
01:08:28 <o-_-o> How can update base ?
01:08:34 <kmc> o-_-o, install new GHC
01:08:35 <mux> jpcooper: not a problem, you need to learn how to lift your pure functions into the IO monad
01:08:37 <Veinor> jpcooper: i guess the question is, what's the context of this question
01:08:41 <dmwit> Can't interleave IO without calling unsafeInterleaveIO *somewhere*.
01:08:43 <koeien> o-_-o: you cannot. it's tied to ghc
01:08:49 <jpcooper> mux: what, you mean fmap?
01:09:11 <mux> fmap or >>=/do notation
01:09:22 <jpcooper> Veinor: I'm reading in pcap dumps, and in the future it will be live, but in any case I don't want it to take up more space than needed while processing packets
01:09:29 <Veinor> anyway yeah i get the feeling there should be a way to do this without unsafeInterleaveIO
01:09:30 <jpcooper> I don't want all packets to be read into memory at once
01:09:33 <dmwit> mux: You're addressing the wrong problem.
01:09:45 <mux> dmwit: yeah it seems I am - I lack enough context
01:09:50 <mux> I'll just keep silent for now and pretend to work
01:09:56 <jpcooper> mux: if you think about it, you'll see that the whole list needs to be computed
01:10:08 <Veinor> hm
01:10:26 <Veinor> vOv
01:10:29 <dmwit> jpcooper: I now understand why you want to use iterators.
01:10:37 <dmwit> s/iterators/iteratees/
01:10:38 <dmwit> whatever
01:10:46 <jpcooper> yeah I don't really understand the jargon either
01:10:52 <mux> enumerators / iteratees I guess
01:11:34 <dmwit> It definitely feels like you want to CPS-transform the function that consumes the [a], and I'm pretty sure that's what iteratees are all about.
01:11:38 <dmwit> So... go for it?
01:11:57 <dmwit> I mean, if you hate lazy IO (and who doesn't, amirite?).
01:12:25 <jpcooper> so does anyone know enough about Data.Enumerator to give me a few pointers?
01:12:27 <MHD> in Leksah is there any way to turn autocomplete off entirely ?
01:12:59 <dmwit> no =(
01:13:13 <dmwit> err, that was aimed at jpcooper, not MHD
01:13:49 <jpcooper> there doesn't seem to be so much material on the subject. I'll just have to dive in I suppose
01:17:18 <kmc> jpcooper, http://www.yesodweb.com/blog/2010/09/enumerators-tutorial-part-1
01:17:53 <jpcooper> thanks
01:19:18 <jpcooper> http://www.yesodweb.com/book/enumerator is more up to date
01:19:27 <kmc> cool
01:22:47 <ader111> a function that I'd expect to find either in Monad or Comonad is w a -> (w a -> w b ) -> w b
01:22:56 <ader111> it is a bit in between
01:23:04 <ader111> does it exist? is it interesting to implement
01:23:14 <Veinor> that's just flip fmap, isn't it
01:24:05 <ader111> oh, yeah that seems to be it. An applicative then
01:24:43 <Veinor> @type flip fmap
01:24:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
01:24:44 <ader111> or is it
01:24:52 <ader111> no it is not actualy
01:25:00 <Veinor> yeah, i didn't wee the w
01:25:16 <kmc> :t flip (<*>)
01:25:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
01:25:42 <ader111> the function is w a -> w b
01:25:44 <kmc> :t flip ($)
01:25:45 <lambdabot> forall a b. a -> (a -> b) -> b
01:26:00 <kmc> :t flip ($) :: (Functor f) => f a -> (f a -> f b) -> f b
01:26:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (f a -> f b) -> f b
01:26:03 <Veinor> yeah, i was gonna ask how that's different from flip ($)
01:27:29 <o-_-o> I have installed ghc using apt-get install blah
01:27:51 <o-_-o> So to upgrade ghc I need to upgrade my distro, right ?
01:27:53 <koeien> o-_-o: then probably you have 6.x
01:27:58 <koeien> o-_-o: that's not necessary!
01:28:01 <ader111> with w a  -> w b the user has to extract a value from w a and return a new w b
01:28:05 <koeien> you can install ghc from haskell.org/ghc
01:28:25 <koeien> pick version 7.0.3
01:28:29 <ader111> which is like a Comonad except that it is wrapped back by the user
01:29:14 <koeien> o-_-o: install it, and after that install the Haskell Platform
01:29:29 <obiwahn> does _ change the evaluation behavior?
01:30:06 <Eduard_Munteanu> obiwahn: depends on what you're comparing it to
01:30:14 <obiwahn> like f xs [] = .... copared to f _ []
01:30:18 <koeien> obiwahn: i am not sure what you mean
01:30:21 <o-_-o> koeien: before that I need to remove the ghc6 older version ? apt-get remove ghc6 ?
01:30:21 <koeien> obiwahn: no, same result.
01:30:36 <Eduard_Munteanu> Yeah, what koeien said
01:30:36 <koeien> o-_-o: that's not necessary, but it will free up some disk space
01:30:52 <o-_-o> koeien: ok
01:31:18 <koeien> o-_-o: ghc installs by defualt in /usr/local, and apt-get in /usr. they won't conflict.
01:31:21 <obiwahn> like if i head somethink like zeros = 0:zeros it would start to evaluate and then match f after the fist step
01:31:38 <o-_-o> koeien: ok
01:31:50 <obiwahn> is there a way to say that the fist argument does not matter and does not need to be evaluated?
01:32:10 <koeien> obiwahn: both f xs [] = ... and f _ [] = ... specify this
01:32:16 <obiwahn> s/head/had
01:33:37 <Eduard_Munteanu> obiwahn: it only makes a difference when you use irrefutable patterns (the '~' thingy), but that's not the case here since you're not opening the constructor
01:34:09 <koeien> > let f _ [] = 0 in f undefined []
01:34:10 <lambdabot>   0
01:34:19 <koeien> > let f xs [] = 0 in f undefined []
01:34:20 <lambdabot>   0
01:34:43 <DrTeggy> obiwahn: an evaluation strategy that ignores "stuff that does not matter" is built into the language.  There is no need to adapt your programs to enforce this.
01:35:03 <Eduard_Munteanu> > let f (Just x) = 0 in f undefined
01:35:05 <lambdabot>   *Exception: Prelude.undefined
01:35:05 <ader111> actually I looked on hayoo and hoogle and didn't find a match for w a -> (w a -> w b )-> w b
01:35:09 <Eduard_Munteanu> > let f ~(Just x) = 0 in f undefined
01:35:10 <lambdabot>   0
01:35:20 <DrTeggy> In fact, you need to adapt your programs if you want to evaluate stuff that does not matter.
01:37:06 <joachi> when is the monoid typeclass useful?
01:38:02 <Eduard_Munteanu> ader111: doesn't (=>>) suit your needs?
01:38:15 <Eduard_Munteanu> I mean, what would you use that for?
01:38:34 <koeien> joachi: if you have a monoid, then people can intuitively understand what that does. Instead of using a custom function, they can use mappend
01:38:52 <kmc> :t mconcat
01:38:53 <lambdabot> forall a. (Monoid a) => [a] -> a
01:39:04 <kmc> once you've defined how to glue together two things (mappend), you get gluing together a list of things for free
01:39:05 <ader111> Eduard_Munteanu: let me check =>>
01:39:06 <Eduard_Munteanu> > "hello" `mappend` "world"
01:39:07 <lambdabot>   "helloworld"
01:39:28 <kmc> joachi, also look at the functions using Monoid in Data.Foldable and Data.Traversable
01:39:40 <Eduard_Munteanu> ader111: it's the comonadic version of (>>=), also called extend
01:40:20 <ader111> well extend is (w a -> (w a ->  b ) -> w b )
01:40:35 <hpaste> obi pasted ‚Äú_‚Äù at http://hpaste.org/51035
01:41:03 <Eduard_Munteanu> ader111: yes. Comonadic functions are supposed to look like   w a -> b, just like their monadic counterparts are   a -> m b
01:41:29 <koeien> obiwahn: interchange lines 5 and 6
01:41:43 <koeien> obiwahn: function definitions are matched in order of appearance in the file
01:42:17 <ader111> Eduard_Munteanu: but that doesn't give the user the chance to return a wrapped value after extracting
01:43:10 <Eduard_Munteanu> ader111: what are you using comonads for?
01:43:20 <obiwahn> so having [] fist isn't good? i thoght there is not much to evaluate so it is cheap when i expect [] in as fist parameter in 50% of the calls
01:43:27 <DrTeggy> obiwahn, anyways, zeros will only be evaluated to the form _:_ (a list of at least one element).  The language does not even bother to evaluate the head (let alone the infinite tail) of the list.
01:43:32 <DrTeggy> Weak head normal form
01:43:42 <ader111> Say just 1 means Nothing and Nothing mean just 1 for me
01:43:57 <joachi> kmc: oh. so it is used in libraries. i wondered because there seems to be no point in writing "hello" `mappend` "world" instead of "hello" ++ "world"
01:44:04 <koeien> obiwahn: yes that is fine. But it only checks whether the list is empty. it does not even compute the head of the list !
01:44:21 <koeien> joachi: imo (++) should be mappend, but that's another story :)
01:44:39 <zhulikas> @t mappend
01:44:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:44:49 <zhulikas> sure I did
01:45:06 <koeien> :t mappend
01:45:07 <lambdabot> forall a. (Monoid a) => a -> a -> a
01:45:09 <Eduard_Munteanu> joachi: for example the Writer monad uses a monoid, so it works with arbitrary such monoids
01:46:07 <Eduard_Munteanu> It's not restricted to lists.
01:46:46 <Eduard_Munteanu> You could, for example, use a Seq you're snoc-ing onto
01:47:12 <hpaste> DrTeggy annotated ‚Äú_‚Äù with ‚Äú_ (annotation)‚Äù at http://hpaste.org/51035#a51036
01:47:41 <Eduard_Munteanu> ader111: I'm not sure I understand that
01:47:59 <Eduard_Munteanu> What's your specific use, and why do you need the functions to return "wrapped values"?
01:48:09 <koeien> although lists are free monoids in some sense, i suppose
01:48:20 <koeien> so in some sense the most general monoids
01:48:30 <koeien> e.g. [()] ~= N
01:48:36 <koeien> (the natural numbers)
01:48:50 <kmc> joachi, correct: there's no point to a type class if you're only using one instance
01:49:12 <Eduard_Munteanu> Yeah, if lists are "sets".
01:49:23 <kmc> but type classes let you write generic code
01:49:40 <kmc> we could have + for Int and +. for Double, like OCaml... but then you'd have to duplicate "sumInts" and "sumDoubles"
01:49:54 <kmc> this way you can write "sum" and it works on both [Int] and [Double], using their respective + operators
01:49:58 <kmc> the situation with Monoid is analogous
01:50:11 <kmc> shachaf would be shocked to see me here, defending the idea of type classes
01:52:41 <joachi> kmc: sure, but with monoids it seems like instances call the functions something else than mempty, mappend
01:53:46 <kmc> you mean that (++) exists as a separate function from mappend?
01:53:57 <kmc> that's true
01:54:17 <kmc> likewise 'map' for lists exists separately from the Functor generic 'fmap', with which it coincides
01:54:22 <kmc> but this needn't be so
01:54:29 <kmc> it's done mostly to avoid confusing beginners, I think
01:54:37 <Veinor> yeah
01:54:39 <clsmith> i think it's weird how we have lots of special case functions for lists
01:54:44 <Veinor> it'd be annoying if you had to learn about monoids in order to work with lists
01:54:46 <kmc> i'd be fine with setting (++) = mappend
01:54:56 <Eduard_Munteanu> clsmith: I sometimes find it downright annoying
01:54:57 <kmc> "it'd be annoying if you had to learn about monads in order to work with IO"
01:55:18 <Veinor> kmc: you don't really have to learn a lot about monads if all you're going to be doing is opening a file, reading it, and doing stuff
01:55:24 <kmc> exactly
01:55:24 <Veinor> if you're going to be doing complicated IO then yes
01:55:42 <kmc> you don't have to learn a lot about monoids to know that (++) concatenates two lists
01:55:42 <sohum> @pl \x ‚Üí (fst x) * u (t (snd x)) a -- I don't expect this to be useful, but
01:55:43 <lambdabot> (line 1, column 5):
01:55:43 <lambdabot> unexpected "\134"
01:55:43 <lambdabot> expecting pattern or "->"
01:55:55 <sohum> @pl \x -> (fst x) * u (t (snd x)) a
01:55:55 <lambdabot> liftM2 (*) fst (flip u a . t . snd)
01:56:09 <sohum> yea, ew.
01:56:11 <DrTeggy> that's pointless
01:56:14 <merijn> I've proposed before of steeling Racket's ideas of language difficulty levels (add more language pragma's!) and once you stop using the beginner level (++) is just mappend, map = fmap, etc :p
01:56:16 <clsmith> Veinor: besides, a monoid isn't very complicated. "a monoid is a thing which can have other things appended to it" or something.
01:56:38 <Eduard_Munteanu> A monoid is stuff you learn about in highschool...
01:56:42 <kmc> i think, if people can learn to do IO without understanding the full Monad abstraction, then they can certainly learn to use a generalized (++) on lists without understanding the full Monoid abstraction
01:56:52 <clsmith> Eduard_Munteanu: which highschool did *you* go to? :p
01:56:59 <koeien> merijn: there's Helium :)
01:57:02 <merijn> Eduard_Munteanu: Hah! You must've gone to high school in Einsteinistan or something
01:57:20 <Veinor> merijn: difficulty levels?
01:57:35 <Eduard_Munteanu> Um... we did some abstract algebra in the 12th grade... monoids, groups, rings...
01:57:36 <clsmith> i had to teach myself all about monoids, monads, functors, etc. as some people on here know :p
01:57:42 <kmc> yeah
01:57:50 <kmc> i'd be okay with import BeginnerPrelude
01:57:55 <Eduard_Munteanu> And vector spaces. But nothing really complicated.
01:57:57 <kmc> as long as people aren't super condescending about it
01:57:59 <merijn> Veinor: At "beginner level" the compiler treats map as (a -> b) -> [a] -> [b], at higher levels map would just be fmap, etc
01:58:08 <kmc> it doesn't need to be a language feature
01:58:18 <kmc> though maybe at the lowest level, "do" would be restricted to IO
01:58:19 <merijn> Veinor: The Racket compiler supports these kinda things
01:58:25 <kmc> but that can already be done with GHC -XNoImplicitPrelude
01:58:47 <clsmith> yeah, that sounds pretty cool to me. a beginner prelude.
01:58:53 <kmc> so write it :)
01:59:00 * Saizan got basic abstract algebra in high school too
01:59:08 <kmc> btw, beginner prelude should use Integer for everything
01:59:09 <clsmith> kmc: the current prelude is /mostly/ a beginner prelude :p
01:59:09 <merijn> While we're at it, can the non beginner prelude also properly require monad to be an instance of functors? >.>
01:59:12 <kmc> no Int (it's premature optimization)
01:59:15 <koeien> i like the helium idea also
01:59:28 <koeien> kmc: Int should go out of the Prelude altogether imo
01:59:33 <kmc> yeah
01:59:42 <merijn> Hmm, how big is the current prelude?
01:59:46 <clsmith> kmc: i know this is the Sufficient Compiler fallacy, but it would be lovely if the compiler could work that stuff out for itself
01:59:51 <merijn> (number of functions)
02:00:05 <kmc> Int is a low-level micro-optimized type like ByteString
02:00:17 <Eduard_Munteanu> kmc: and no typeclasses while you're at it :P
02:00:23 <kmc> the performance difference between Int and Integer can be *huge* though
02:00:25 <merijn> kmc: Don't you need ByteString for...well, bytes?
02:00:39 <clsmith> merijn: [Byte]?
02:00:40 <Eduard_Munteanu> That's for uber power users!
02:00:42 <kmc> moreso than machine ints vs bignums in typical strict languages
02:00:51 <kmc> because of unboxing
02:01:51 <merijn> Is there a proper way to beat the cabal version of Darcs into working with 7.2?
02:02:48 <rostayob> is there a way to use fully qualified names without explicitly importing?
02:03:33 <Saizan> no
02:03:54 <Saizan> you don't have to import qualified, but you still have to import
02:04:34 <rostayob> Saizan: ok, thanks. I am generating haskell code and I was wondering if there is a way to import only what's necessary
02:05:17 <koeien> -ddump-minimal-imports
02:05:28 <koeien> rostayob: or something like this ^
02:06:15 <rostayob> koeien: judging from the name, I'd guess that that will remove the useless imports
02:06:48 <rostayob> i want something that generates the import from the qualified names I'm using (e.g. Data.Functor.fmap)
02:07:20 <koeien> hmm, you will need IDE support for that
02:07:38 <koeien> and if you're generating code you'll need to look up all your identifiers
02:07:52 <b_jonas> rostayob: just try to compile it and then see what errors you're getting about identifiers not found
02:08:17 <merijn> How do I fix "Could not find module `System'. It is a member of the hidden package `haskell98-2.0.0.0'"?
02:08:43 <kmc> add haskell98 as a dependency in the .cabal file
02:08:45 <rostayob> b_jonas, koeien: the thing is that I need that to ad imports to generated code. I actually don't *need* it, but it'd be nice (:
02:09:04 <kmc> or if you're invoking GHC directly, -package haskell98
02:09:48 <koeien> or --make
02:11:02 <gienah> but ghc 7.2.1 does not seem to like haskell98, so maybe its better to change it to System.Environment, System.Exit, etc?
02:11:16 <kmc> that is probably better in the long term
02:11:47 <merijn> kmc: Thanks, is there any way to figure out which dependency lists I have to add it to, or should I just add it to all to be sure
02:12:02 <merijn> gienah: That's my entire problem, trying to install darcs with GHC7.2
02:13:12 <Eduard_Munteanu> Hey gienah, btw, I was thinking... Is there any tool that autogenerates Haskell ebuilds for Gentoo?
02:13:17 <kmc> not sure
02:13:21 <kmc> i have to sleep now... ttyl
02:13:21 <Eduard_Munteanu> There's something like that for Perl and Octave IIRC
02:13:44 <nda> @pl \x (y,z) -> (f x y, f x z)
02:13:44 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . f) f
02:13:49 <b_jonas> Eduard_Munteanu: something like what?
02:14:16 <gienah> merijn: a patch for you to fix darcs for ghc 7.2.1: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-vcs/darcs/files/darcs-2.5.2-ghc-7.2.patch
02:14:33 <Eduard_Munteanu> b_jonas: a "tool that autogenerates Haskell ebuilds for Gentoo"
02:14:46 <Eduard_Munteanu> @google g-octave
02:14:47 <b_jonas> I see
02:14:48 <lambdabot> http://g-octave.org/
02:14:48 <lambdabot> Title: Welcome to g-Octave‚Äôs documentation! ‚Äî g-Octave v0.4.1 documentation
02:15:21 <Eduard_Munteanu> I'm thinking it could be fairly easy to get the dependency information from Cabal.
02:15:23 <Ke> Eduard_Munteanu: hackport
02:15:27 <engla> why are equivalent functions duplicated with different names, such as  pure and return? wouldn't it be much better to reduce duplication?
02:15:37 <koeien> nda: (f x) *** (y, z) -- I think
02:15:43 <engla> pure and return  and ap and <*> etc
02:15:57 <Eduard_Munteanu> Ke: ah, I see, thanks.
02:16:02 <koeien> > let f = (+) in (f 1) *** (2, 3)
02:16:02 <lambdabot>   Couldn't match expected type `b' -> c''
02:16:02 <lambdabot>         against inferred type `(t, ...
02:16:15 <koeien> > let f = (+) in (f 1, f 1) *** (2, 3)
02:16:15 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
02:16:15 <lambdabot>    arising from a use of `Control...
02:16:25 <b_jonas> engla: there's (.) and fmap; also (++) and mappend
02:16:42 <Eduard_Munteanu> engla: they belong to different typeclasses
02:16:44 <b_jonas> engla: it's probably both historical and because it allows to find bugs more easily
02:16:54 <b_jonas> though that's not the case with pure versus return
02:17:12 <b_jonas> it definitely is with (.) or with (++) because those have a more specific type then fmap and mappend
02:17:25 <b_jonas> so the compiler can derive more precise error messages if you use them
02:17:30 <clsmith> hmmm, why is there no fmapM?
02:17:32 <Eduard_Munteanu> Even when they are in the same typeclass, it's nice to be able to define one in terms of another by default.
02:17:34 <gienah> Eduard_Munteanu: there is hackport
02:17:34 <engla> b_jonas: yeah exactly. Maybe the list versus generic case is motivated since the list belongs to the very basics of haskell
02:17:40 <nda> koien: it's (f x) *** (f x) (y, z)
02:17:48 <Eduard_Munteanu> Yeah, Ke just told me about it.
02:17:50 <koeien> nda: I'm talking nonsense, never mind.
02:18:23 <koeien> nda: join (***) (f x) (y, z)
02:18:24 <Saizan> engla: pure vs. return is mostly historical reasons and backwards compatibility
02:18:31 <engla> b_jonas: at least (.) and fmap are a function and infix operator pair
02:18:48 <clsmith> @hoogle fmapM
02:18:49 <lambdabot> No results found
02:18:51 <engla> Saizan: ok. In a better world, they would be the same? and we wouldn't have that confusing return function
02:18:55 <engla> confusing name
02:19:08 <nda> koien: thx, but i hoped for something without join :)
02:19:31 <b_jonas> engla: (.) versus <$> then
02:19:37 <Eduard_Munteanu> clsmith: what do you want it to do?
02:20:02 <clsmith> Eduard_Munteanu: (Functor f, Monad m) => (a -> m b) -> f a -> m (f b)
02:20:13 <Saizan> engla: yeah, most would consider a better world with Applicative as a superclass of Monad, and return as a synonym for pure
02:20:31 <b_jonas> Saizan: do you mean also Functor as a superclass of Applicative?
02:20:40 <Saizan> b_jonas: that's already the case
02:20:45 <b_jonas> oh
02:20:48 <b_jonas> but
02:20:58 <koeien> and Pointed
02:21:11 <b_jonas> wouldn't this make it hard to define new Monad instances, because you'd have to write the Applicative instance too?
02:21:16 <Saizan> not so many agree on Pointed, i think
02:21:37 <koeien> b_jonas: well, a bit, yes. but that's an easy tradeoff imo
02:22:01 <Saizan> b_jonas: yeah, that's one of the objections, i don't see it as very strong but there are proposals to overcome that anyhow
02:22:12 <clsmith> should be able to define superclasses' functions in a single given instance imo
02:22:33 <koeien> can I use the Monad instance in my efinition of Applicative?
02:22:36 <b_jonas> Saizan: yes, I think there's an extension in ghc7 that allows writing default functions in such a way
02:22:39 <Eduard_Munteanu> @hoogle (a -> m b) -> f a -> m (f b)
02:22:40 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:22:40 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:22:40 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
02:22:44 <koeien> then you can just use (<*>) = ap; pure = return
02:22:47 <b_jonas> koeien: yes
02:23:37 <clsmith> huh, traversable? eh, i suppose a functor alone doesn't provide enough information to get an fmapM without making it part of the type calss
02:23:40 <clsmith> *class
02:24:12 <koeien> you cannot "unpack" a functor, I think that's the issue
02:24:18 * Eduard_Munteanu wonders if there's a connection to strength
02:24:40 <engla> ok at least there are not strict hierarchies like "OO/inheritance" would have it or so
02:25:02 <engla> probably there will always be people to come up with new classes between two others like Applicative
02:26:41 <Eduard_Munteanu> I mean, the (a, m b) -> m (a, b) thingy
02:27:38 <merijn> gienah: Awesome, that worked (or at least seems to compile...), thanks!
02:27:52 <engla> I was reading mother of all monads yesterday: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html   my GHC 7.0 doesn't have the 'Cont' constructor. Any easy way to update the examples there?
02:27:55 <gienah> merijn: great
02:28:22 <Eduard_Munteanu> engla: did you import Control.Monad.Cont ?
02:28:23 <Saizan> engla: use the cont function
02:28:23 <fryguybob> @hoogle Cont
02:28:24 <lambdabot> module Control.Monad.Cont
02:28:24 <lambdabot> Control.Monad.Cont newtype Cont r a
02:28:24 <lambdabot> Control.Monad.Cont Cont :: ((a -> r) -> r) -> Cont r a
02:28:33 <engla> Eduard_Munteanu: I did
02:28:37 <Eduard_Munteanu> Ah.
02:28:40 <Eduard_Munteanu> What Saizan said
02:30:24 <engla> ok great, so I will try that. I don't see how I could have missed this simple thing. Yet, with Cont missing I was trying to build something working with ContT
02:31:05 <Eduard_Munteanu> (Or maybe you just need something like edwardk's Distributes.)
02:31:23 <Saizan> yeah, cont is a thin wrapper around ContT
02:31:31 <Saizan> ?type ContT
02:31:31 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
02:31:59 <int-e> ContT is not a monad transformer :/
02:32:25 <engla> it's not? it would have to be if it's called ContT
02:32:47 <int-e> ContT is Cont with a restricted type. The fact that m is a monad is never used.
02:33:10 <Saizan> (ContT r) applied to a monad m gives you a monad
02:33:19 <Saizan> that's enough for me to call it a monad transformer
02:33:31 <int-e> yes, but it also gives you a monad if m is any other type constructor.
02:33:39 <Saizan> so what?:)
02:33:48 <Eduard_Munteanu> Ah, Distributive is dual to Traversable.
02:33:52 <int-e> so calling it a transformer is misleading in my view.
02:33:53 <b_jonas> int-e: isn't it that if m is not a monad then it's unusable because you can't call runCont on it?
02:33:55 <merijn> gienah: Ah bollocks, it fails at the very end of the build because someone f-ed up the case of filenames
02:35:35 <Saizan> it's just partial information about it, like any assertion about a specific interface available to some type
02:35:51 <Saizan> b_jonas: you just need (a -> m b) for runCont, not a Monad instance
02:36:29 <int-e> Ok, I take part of my statement back; the MonadTrans instance makes it a monad transformer. But there's nothing in the type nor the monad instance that requires a monad, unlike most other monad transformers, which map bind to the underlying bind somehow.
02:37:20 <Saizan> yep, only lift uses the underlying (>>=)
02:38:04 <int-e> b_jonas: you can use it all right, just pass any continuation, any function that does something with the return value. There's only one problem - namely that the Monad instance has a superfluous "Monad m" constraint.
02:38:37 <b_jonas> oh, so it's not run but lift that needs a monad
02:38:44 <b_jonas> I see
02:39:29 <b_jonas> well, even if it works that way, I'll probably think of it as a monad transformer and apply it only to monads
02:39:29 <Saizan> int-e: it does?
02:39:40 <Saizan> int-e: there isn't one in the source
02:40:55 <b_jonas> or more likely I won't use it at all
02:41:06 <b_jonas> Cont is just too general for mee
02:41:35 <int-e> Saizan: in mtl? I see instance (Monad m) => Monad (ContT r m) where ...
02:42:27 <Saizan> int-e: which version? http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Cont.html <- here there's none, and mtl now reexports transformers
02:42:49 * Eduard_Munteanu idly wonders about CodensityT
02:43:12 * merijn kicks cabal and GHC
02:43:16 <int-e> Saizan: Ah, that's the right question.
02:43:25 <int-e> Saizan: I was looking at mtl 1.1 apparently.
02:43:37 <gienah> merijn: not sure about the f-ed up case of filenames, darcs 2.5.2 builds with ghc 7.2.1 on gentoo, maybe someone on #darcs might know
02:43:58 <merijn> I suspect it's cabal/GHC that's f'ing up, not darcs
02:44:09 <merijn> The build process fails because it can't find certain binary files
02:44:11 <Saizan> Eduard_Munteanu: Condesity is already a -T
02:44:12 <int-e> Saizan: thanks
02:44:30 <sohum> :t maybe
02:44:31 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:44:35 <Saizan> int-e: np
02:44:35 <engla> Saizan: thanks, 'cont' works fine. Except this cont monad being more of a mindfuck than I thought (now that I can try it)
02:45:08 <merijn> The reason why is obvious, because the build folder has the following directories: Darcs/, Darcs (Case Conflict 1)/, Darcs (Case Conflict 2)/, Darcs (Case Conflict 3)/, Darcs (Case Conflict 4)/
02:45:26 <merijn> So something is messing up with case sensitivity
02:45:47 <gienah> merijn: think I'm glad I haven't seen that before
02:46:47 <Eduard_Munteanu> Oh, right.
02:47:19 <int-e> Saizan: Now I wonder why ghc uses mtl 1.1 (and where? perhaps just for haskeline - it's not installed as a package)
02:49:58 <int-e> Saizan: But that's probably because of the new transformers dependency which means that the build system would have to build two packages instead of one.
02:50:36 <Saizan> seems plausible
02:51:00 <merijn> gienah: I suddenly have a sneaking suspicion what's causing it. I was working inside a folder track by dropbox. I suspect the sync was to slow and that causes it to f-up and somehow messing up the case. I just turned it off and now it succeeds in building
02:53:41 <gienah> merijn: great, glad it builds :-)
02:55:25 <merijn> On unrelated note, there's nothing like "cabal uninstall", right?
02:56:06 <koeien> ghc-pkg unregister
02:56:17 <int-e> right. ghc-pkg unregister ... and then find and remove the installed files manually if you worry about the disk space.
02:56:17 <Jafet> rm -rf optional
03:04:13 <b_jonas> um,
03:04:50 <b_jonas> I'm reading http://www.haskell.org/onlinereport/haskell2010/haskellch9.html
03:05:35 <b_jonas> specifically the definition of instance Enum Fload
03:06:03 <Veinor> right
03:06:38 <b_jonas> is it supposed to mean that [(0 :: Float), 3 .. 2] should indeed return [0, 3]; but [(0 :: Integer), 3 .. 2] should return [0] ?
03:06:46 <b_jonas> they should behave this differently?
03:06:56 <Veinor> > [(0 :: Float), 3 .. 2]
03:06:57 <lambdabot>   [0.0,3.0]
03:07:04 <Veinor> > [(0 :: Integer), 3 .. 2]
03:07:05 <lambdabot>   [0]
03:07:31 <Veinor> numeric prelude sucks, yeah
03:07:34 <b_jonas> and why doesn't it spell out the definition of instance Enum Int ?
03:07:39 <b_jonas> it doesn't suck
03:07:47 <b_jonas> the way the Float instance works actually makes sense
03:07:54 <b_jonas> and I guess the integer one too
03:08:02 <b_jonas> they just shouldn't be called the same
03:08:20 <Veinor> it omits the integer one presumably because it's 'obvious'
03:08:22 <Veinor> "Some of the more verbose instances with obvious functionality have been left out for the sake of brevity."
03:09:17 <b_jonas> so they were lazy to write them
03:09:18 <b_jonas> I see
03:15:57 <engla> there is lots that can go wrong with Float and [ .. ]
03:24:06 <clsmith> given multi-parameter classes, would MonadPlus be (Monad m, Monoid (m a)) => MonadPlus m a ?
03:24:24 <clsmith> or would Monoid a suffice?
03:25:09 <sohum> :t zip
03:25:10 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
03:25:14 <sohum> :t zipWith
03:25:15 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
03:25:16 <koeien> every MonadPlus is a Monad
03:25:39 <sohum> :t takeWhile
03:25:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
03:25:58 <brisingr> how is Eq derived? a == b = (a <= b) && (b <= a) ?
03:26:15 <koeien> brisingr: no. The compiler checks for equality on all fields.
03:26:24 <sohum> :t \a b -> takeWhile (zipWith (==) a b) a
03:26:25 <lambdabot>     Couldn't match expected type `a -> Bool'
03:26:25 <lambdabot>            against inferred type `[Bool]'
03:26:25 <lambdabot>     In the first argument of `takeWhile', namely `(zipWith (==) a b)'
03:26:32 <Jafet> Eq is not related to Ord
03:26:36 <brisingr> so I have to manually derive Eq if using equivalence classes
03:26:38 <sohum> oh, grr.
03:26:44 <koeien> brisingr: yes
03:26:50 <brisingr> thanks
03:26:52 <Jafet> In principle, they could be different, if you want to fuck with people
03:27:09 <int-e> brisingr: of course you can define the Eq instance exactly as you said, if you also define the Ord instance in the same module
03:27:24 <brisingr> yes, I plan to do that
03:27:27 <koeien>  Eq is a superclass of Ord
03:27:37 <Jafet> @src Ord
03:27:38 <lambdabot> class  (Eq a) => Ord a  where
03:27:38 <lambdabot>     compare      :: a -> a -> Ordering
03:27:38 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:27:38 <lambdabot>     max, min         :: a -> a -> a
03:27:47 <Jafet> Oh, I thought it wasn't.
03:27:58 <Jafet> But you can still make them different
03:28:08 <sohum> :t \a b -> zip (zipWith (==) a b) a
03:28:09 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [(Bool, a)]
03:28:19 <Eduard_Munteanu> (<=) and (>=) give you a definition of (==) anyway
03:28:30 <koeien> typeclass laws are not enforced at compile time
03:28:30 <sohum> :t \a b -> map snd . takeWhile fst $ zip (zipWith (==) a b) a
03:28:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:28:35 <sohum> ew.
03:28:40 <sohum> can that be cleaner?
03:29:11 <sohum> @pl \a b -> map snd . takeWhile fst $ zip (zipWith (==) a b) a
03:29:12 <lambdabot> ((map snd . takeWhile fst) .) . (flip =<< (zip .) . zipWith (==))
03:29:12 <brisingr> If I use a == b = (a <= b) && (a >= b) I should get infinite recursion
03:29:28 <brisingr> if I define only <=
03:29:38 <int-e> sohum: takeWhile (== b)?
03:29:46 <Eduard_Munteanu> brisingr: not really, why?
03:29:53 <Jafet> a == b = (a <= b) && (b <= a)
03:30:18 <brisingr> haskell derives >= after first checking == and <=
03:30:20 <sohum> :t takeWhile (==b)
03:30:20 <lambdabot> [Expr] -> [Expr]
03:30:25 <brisingr> if == is defined in terms of >= we're dead
03:30:33 <sohum> :t \b -> takeWhile (==b)
03:30:33 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
03:30:37 <int-e> @type \a b -> map snd . takeWhile fst $ zip (zipWith (==) a b) a
03:30:38 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:30:39 <Eduard_Munteanu> Ah, I assumed this was about writing your own instances
03:31:08 <Jafet> brisingr: why so sordid
03:31:11 <sohum> int-e: yea, see? I want the maximal front-string such that both lists are equal
03:31:14 <int-e> sohum: I read the code wrong.
03:31:20 * sohum nod
03:31:34 <koeien> sohum: catMaybes . takeWhile isJust $ zipWith (\a b -> if a == b then Just a else Nothing) xs ys
03:31:41 <brisingr> Jafet: ?
03:31:42 <koeien> but maybe this is not really cleaner :)
03:32:15 <koeien> map fst . takeWhile (uncurry (==)) $ zip xs ys
03:33:00 <koeien> :t map fst . takeWhile (uncurry (==)) $ zip xs ys
03:33:01 <lambdabot> Not in scope: `xs'
03:33:02 <lambdabot> Not in scope: `ys'
03:33:10 <koeien> :t \xs ys -> map fst . takeWhile (uncurry (==)) $ zip xs ys
03:33:11 <lambdabot> forall b. (Eq b) => [b] -> [b] -> [b]
03:33:15 <koeien> sohum: ^
03:33:53 <sohum> koeien: cleaner!
03:34:19 <sohum> @pl \e f q -> intersec (fp e q) (fp f q)
03:34:19 <lambdabot> (. fp) . ap . (intersec .) . fp
03:34:43 <int-e> sohum: I tend towards  commonPrefix (x:xs) (y:ys) | x == y = x : commonPrefix xs ys; commonPrefix _ _ = []
03:34:51 <Jafet> \xs ys -> last $ zipWith (\xs ys -> null.tail.group $ [xs, ys, xs `lub` ys]) (inits xs) (inits ys)
03:35:37 <Jafet> brisingr: a == b = not (a < b) && not (b < a)
03:35:48 <sohum> int-e: but but but explicit recursion obscures structure but!
03:36:04 <brisingr> Jafet: thanks
03:36:07 <Jafet> (For a probabilistic result, leave out one of the xs, ys)
03:36:25 <koeien> sohum: do as you want :) i think both expressions are readable
03:36:59 <koeien> definitions*
03:39:01 <int-e> sohum: Well, cata- and anamorphisms are nice, but this seems to me to be a hylomorphism which I don't find very intuitive. :)
03:39:50 <mjrosenb> hylowhatnow?
03:39:59 <mjrosenb> int-e: now you're just making up words :-p
03:40:07 <sohum> you totally are! :p
03:40:18 <Jafet> @quote hylo
03:40:19 <lambdabot> EvilTerran says: Hylo morphism batman!
03:41:16 <sohum> @hoogle a -> (a -> b) -> (Maybe a -> Maybe b)
03:41:17 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
03:41:17 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
03:41:17 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:41:25 <int-e> sadly, no. e.g. http://www.willamette.edu/~fruehr/haskell/evolution.html or http://en.wikipedia.org/wiki/Hylomorphism_%28computer_science%29
03:42:01 <sohum> :t Just . maybe
03:42:02 <lambdabot> forall b a. b -> Maybe ((a -> b) -> Maybe a -> b)
03:42:25 <sohum> :t \a b c -> Just $ maybe a b c
03:42:25 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> Maybe b
03:42:36 <sohum> @pl \a b c -> Just $ maybe a b c
03:42:36 <lambdabot> ((Just .) .) . maybe
03:42:37 <koeien> :t (<$>)
03:42:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:42:48 <int-e> but  map fst . takeWhile (uncurry (==)) $ zip xs ys  isn't too unreadable either.
03:44:37 <sohum> int-e: that is a classically bad wikipedia article :p
03:44:47 <sohum> koeien: I don't think I want <$>, though...
03:44:58 <sohum> I want to specialise on the Nothing case
03:45:10 <koeien> :t maybe
03:45:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:45:26 <sohum> yea, so I'm fiddling with that
03:46:05 <koeien> why do you return a Maybe b then?
03:46:19 <sohum> necessities of api
03:46:45 <koeien> then Just $ maybe a b c indeed :)
03:47:02 <sohum> yea, okay :p
03:51:08 <sohum> @pl \x -> Just $ maybe i f x
03:51:09 <lambdabot> Just . maybe i f
03:51:12 * sohum headdesk
03:52:16 <o-_-o> anyone can help me with building reactive-banana-wx ? I am trying to build it on Linux and it says
03:52:16 <o-_-o> Setup.hs:5:8:
03:52:17 <o-_-o>     Could not find module `Distribution.MacOSX':
03:55:06 <mjrosenb> o-_-o: that sounds  like someone hardcoded module name that shouldn't have
03:56:43 <o-_-o> So is there a Distribution.Linux ?
03:58:27 * hackagebot HandlerSocketClient 0.0.1 - Haskell implementation of a HandlerSocket client (API).  http://hackage.haskell.org/package/HandlerSocketClient-0.0.1 (XingboWu)
03:59:42 <jpcooper> is there a key command for haskell-mode which transposes tokens on the same level?
04:00:23 <jpcooper> say I have a type signature a -> b and I put my cursor before b, then it gives b -> a. Or maybe I would have f (x y) and I put the cursor before ( and I get (x y) f
04:01:18 <b_jonas> you want a categorical dual command? :-)
04:01:36 <jpcooper> haha, yes
04:02:27 <jpcooper> I find myself switching types around quite a bit and wondered whether there was a shortcut for it
04:02:46 <Jafet> Make a type-level lambda for flip
04:03:27 * hackagebot network-address 0.2.0 - IP data structures and textual representation  http://hackage.haskell.org/package/network-address-0.2.0 (SebastianNowicki)
04:03:41 <jpcooper> Jafet: I'm talking about transposing things in Emacs
04:03:55 <Jafet> Though you might need to write your arrows in prefix then
04:04:23 <Saizan> jpcooper: i'm pretty sure there's no such command in haskell-mode
04:04:27 <Jafet> I know you are. I'm not!
04:04:35 <o-_-o> I am installing cabal-macosx on linux, I wonder if that is a good idea
04:04:39 <jpcooper> okay
04:04:52 <jpcooper> Jafet: would you do it with type families or something?
04:04:58 <parcs> o-_-o: shouldn't be a problem
04:05:12 <Jafet> You can probably do it with fundeps
04:05:36 <Jafet> At least, while we're on the topic of masochism
04:05:44 <Saizan> type families would be more comfortable to use
04:07:12 <Saizan> you can even have one like: type instance F (a -> b) = b -> a
04:08:14 <Jafet> It won't work for (x y) f though, whatever that even means
04:23:27 * hackagebot HandlerSocketClient 0.0.2 - Haskell implementation of a HandlerSocket client (API).  http://hackage.haskell.org/package/HandlerSocketClient-0.0.2 (XingboWu)
04:23:34 <Entroacceptor> :t fold
04:23:36 <lambdabot> Not in scope: `fold'
04:23:37 <Entroacceptor> :t foldl
04:23:38 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:23:44 <Entroacceptor> why doesn't that work in a query?
04:26:10 <Saizan> you can use ?ty
04:26:44 <Saizan> commands starting with : are handled somewhat differently
04:27:50 <Entroacceptor> weird, but ok..
04:36:39 <balta2ar> is there any library which can expand shell vars in the string? I would like to be able to write like this: readFile "$HOME/somefile.txt"
04:38:16 <rostayob1> balta2ar: something here probably http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/System-Environment.html
04:38:58 <rostayob1> or you can simply call bash I guess
04:40:55 <balta2ar> I would like it to be cross-platform. bash is not usually available on Windows. Anyway, using System.Environment I have to manually scan the string and replace any var occurences.
04:41:50 <rostayob1> balta2ar: yes you do, you'd have to write a minimal parser yourself
04:42:54 <balta2ar> I hoped someone could already have implemented that. Thanks, rostayob
04:43:41 <rostayob> balta2ar: I think the behaviour of what you want would always be kind of ambiguous. but I wouldn't be surprised if something existed already
04:46:34 <balta2ar> rostayob: by ambiguity you mean the var might not be set up?
04:47:04 <rostayob> balta2ar: I mean that the behaviour is not clear, you'd have to write a little spec
04:47:22 <rostayob> you could simply say "I behave like bash" i suppose
04:47:43 <rostayob> yeah for example what to do when the variable is not defined is a problem
04:49:54 <romildo> Hi.
04:49:56 <balta2ar> in case of bash the variable is replaced with empty set of characters, AFAIK: ""
04:51:03 <rostayob> balta2ar: my point is just that I wouldn't expect to find something like this in the haskell platform since it's kind of tricky
04:51:23 <rostayob> but maybe some library has an utility like that
04:53:30 <romildo> I want a good definition of pattern, as used in pattern matching. Most of the Haskell references does not state what a pattern is, but introduces the concept by examples, and shows some pattern matchings. How would you define pattern to a computer science student? I want a definition that looks like "pattern is a phrase of the language that ..."
04:56:32 <rostayob> romildo: a pattern is something that matches one of the constructors of an algebraic data type, extracting the inner types?
04:56:48 <Saizan> it doesn't extract types
04:57:08 <rostayob> right, the inner values
04:57:10 <Saizan> also you can have multiple constructors in a single pattern
04:57:38 <Saizan> romildo: the haskell report might have a definition
04:57:43 <Saizan> @where report
04:57:43 <lambdabot> http://www.haskell.org/onlinereport/
04:57:51 <rostayob> Saizan: can you?
04:58:19 <Saizan> rostayob: (x1:x2:xs) is a valid pattern
04:58:22 <mokus> rostayob: f (Just [1,2]) has constructors Just, :, and []
04:59:02 <romildo> rostayob, this seems to be a good answer, except for the word something. What would be a better word? construct? phrase?
04:59:34 <mokus> romildo: this isn't a complete definition, but i'd focus on 2 main things they do: they select cases by matching on constructors, and they bind variables by unification
04:59:36 <rostayob> yeah but you're pattern matching the inner values, I thought that you meant different constructors of the same value
05:01:01 <romildo> Saizan, I failed to find a definition of pattern in the haskell report. But there is the syntax for them, and the rules for matching.
05:03:02 <Saizan> yeah, it doesn't give an informal definition of pattern, only the formal one
05:04:38 <Saizan> anyhow, they are a particular subset of expressions where only data constructors can appear applied
05:20:02 <romildo> I am preparing a class that introduces pattern matching to my c. s. students. Before using pattern matching I would like to present a small informal definition of the concept. Then I would introduce several form of patterns and show how they may be used on lhs of equations defining functions. Do you think the following informal introduction is good?
05:20:04 <romildo> A pattern is a phrase that allows one to analyze a value and bind variables to the data that make up the value. It is used in an operation know as pattern matching, which tries to match a pattern with a value, and can fail or succeed depending on the form of the pattern and the value. A successfull match binds the variables from the pattern to the corresponding components of the value.
05:23:50 <kate_r> does anyone know if differential fields can be expressed in a first-order language? derivatives work on functions, so derivatives are second-order functions, right?
05:24:16 <Botje> romildo: wow. that's dry.
05:25:54 <Botje> I would say data is organized in trees, and patterns are trees with holes in them. if the non-hole parts of a pattern match your data, the holes are bound to the respective subtrees
05:26:51 <applicative> why is it called 'pattern matching' rather than 'constructor matching'?
05:36:38 <Kaidelong> I know that (++) is associative, but operationally, is there a particular best way to look at it?
05:36:43 <Kaidelong> as in
05:37:00 <Kaidelong> is there any advantage to a ++ (b ++ c) over (a ++ b) ++ c or vice versa
05:37:13 <Kaidelong> even if they evaluate to the same thing when you finish running them
05:38:45 <Saizan> yes
05:38:52 <byorgey> Kaidelong: left-nested (++) takes O(n^2) time to evaluate
05:38:55 <Saizan> a ++ (b ++ c) only traverses a once
05:39:25 <Kaidelong> :info (++)
05:39:30 <Kaidelong> @info (++)
05:39:31 <lambdabot> (++)
05:39:41 <Kaidelong> well I take it ++ is right associative by default then
05:39:53 <byorgey> yes
05:42:08 <hpaste> obi pasted ‚Äúdata types‚Äù at http://hpaste.org/51042
05:44:51 <kate_r> does anyone know if differential algebra can be expressed in a first-order language? derivatives work on functions, so derivatives are second-order functions, right? but according to wikipedia, differential algebra is a FOL theory. then why would a FOL theory need a second-order language?
05:45:30 <byorgey> obiwahn: you are comparing players for equality with  p1 /= p2, but in order to do this there must be an instance of Eq for the Player type
05:45:51 <byorgey> obiwahn: you can do this easily by adding the line  'deriving Eq' after 'data Player = ...'
05:47:29 <byorgey> obiwahn: for the other error, you have declared that create2on2Team returns a list of teams, but the code only returns a list of players.
05:51:40 <obiwahn> yeahy:)
05:58:00 <hpaste> Itkovian pasted ‚Äúmonadic GA ‚Äù at http://hpaste.org/51043
05:58:43 <obiwahn> byorgey: where must i pit deriving Show?
05:58:51 <obiwahn> s/pit/put/
06:00:55 <obiwahn> deriving Eq,Show -- deriving Show deriving Eq     do not work:(
06:01:28 <Saizan> deriving (Eq,Show)
06:01:49 <hpaste> applicative annotated ‚Äúdata types‚Äù with ‚Äúdata types (annotation)‚Äù at http://hpaste.org/51042#a51044
06:03:31 <hpaste> applicative annotated ‚Äúdata types‚Äù with ‚Äúdata types (annotation) (annotation)‚Äù at http://hpaste.org/51042#a51045
06:05:09 <applicative> obiwahn, if you are just deriving Show, you write 'deriving Show' ; if you are deriving more than one it's deriving (  ,   ,  ) a comma separated parenthesis
06:07:51 <Itkovian> Any idea how to force the compiler to realise that on line 175 of the paste, the crossover should be using the 'a' from 'Entity m a' which was specified as a class constraint on the function? (http://hpaste.org/51043)
06:08:51 <koeien> {-# LANGUAGE ScopedTypeVariables #-}
06:10:11 <Axman6> Itkovian: those functions are very large
06:10:23 <Itkovian> Yeah, I am reworking the code, so ssssst.
06:10:28 <Saizan> Itkovian: you'd also have to add "forall a m. " in front of the type signature for evolutionStep
06:10:41 <Itkovian> ok, thx
06:10:43 <Saizan> in addition to ScopedTypeVariables
06:10:51 <koeien> ah, ok.
06:10:58 <Itkovian> note to self: drop by here sooner next time
06:13:27 * hackagebot MissingH 1.1.1.0 - Large utility library  http://hackage.haskell.org/package/MissingH-1.1.1.0 (JohnGoerzen)
06:18:06 <Itkovian> hmm, still no luck with the above changes
06:19:20 <joachi> is there a difference between saying that, for example, Just "blah" is an applicative value and that it is a monadic value?
06:20:07 <Saizan> you're just stressing different properties of Maybe
06:20:14 <koeien> joachi: yes, a bit
06:20:29 <koeien> joachi: every monadic value (is/ought to be) an applicative value
06:20:57 <koeien> the converse is not true
06:21:40 <joachi> what exactly is the difference in this case, with Just "blah"?
06:21:53 <applicative> the values themselves are neither, since the type is there before you make a class instance
06:22:37 <koeien> joachi: what Saizan said. Maybe instantiates both Applicative and Monad
06:22:59 <joachi> oh. which types are applicative but not monadic then?
06:23:15 <applicative> not many important ones, joachi.
06:23:24 <applicative> the textbook example is ZipList
06:23:39 <koeien> I think a ZipList is an exmaple
06:23:57 <applicative> > [(+1),(+2)] <*> [3,4]
06:23:58 <lambdabot>   [4,5,5,6]
06:24:13 <applicative> > ZipList [(+1),(+2)] <*> ZipList [3,4]
06:24:14 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList a))
06:24:14 <lambdabot>    arising ...
06:24:20 <applicative> grrrrr
06:24:47 <nda> @pl \f a b c d -> f (g a b c d)
06:24:48 <lambdabot> (. g) . (.) . (.) . (.)
06:24:58 <nda> go figure...
06:25:23 <applicative> > getZipList $ ZipList [(+1),(+2)] <*> ZipList [3,4]
06:25:24 <lambdabot>   [4,6]
06:26:16 <joachi> alright
06:26:43 <applicative> joachi, so with ZipList, the functions are applied in parallel like zip
06:27:33 <applicative> its an opposing instance of Applicative, but there is only one possible Monad instance for lists, unless maybe debauched ones
06:28:42 <Kaidelong> the monad instance for lists basically captures nondeterministic computation ala icon, prolog
06:31:54 <applicative> > [f x | f <- [(+1),(+2)], x <- [3,4]]
06:31:56 <lambdabot>   [4,5,5,6]
06:32:13 <applicative> > [f x | f <- [(+1),(+2)]| x <- [3,4]]
06:32:14 <lambdabot>   [4,6]
06:32:15 <tomberek> is there a queue structure that supports membership? or prevents the insertion of historically inserted items? or will it simply be a tupled queue and set?
06:42:56 <obiwahn> ($) :: (a -> b) -> a -> b i need to put this in words:) i have a function that creates a functions that maps a function (a->) to a ... i fail:(
06:44:14 <DasIch> obiwahn: $ takes a function a -> b and an argument a and returns b
06:44:37 <tomberek> obiwahn, $ takes a function and applies it to a value
06:46:35 <Schalken> What should I use for to parse a data type from an xml document?
06:46:50 * frerich thinks it's really nice how much you can tell about the effect of a function just by looking at its signature.
06:47:41 <tomberek> so, any ideas on a combination of a queue and set?
06:48:08 <hpaste> applicative annotated ‚Äúmonadic GA ‚Äù with ‚Äúmonadic GA  (annotation)‚Äù at http://hpaste.org/51043#a51046
06:48:33 <Saizan> tomberek: the nearest thing that comes to mind is a priority search queue
06:49:32 <Botje> obiwahn: the type is more readable as (a -> b) -> (a -> b)
06:49:37 <applicative> obiwahn ($) just means "applied to".  What would the signature of "applied to" be?  It needs a function to apply (a -> b) and and argument to apply it to (a)
06:50:09 <applicative> > let appliedTo f x = f x in (+1) `appliedTo` 1
06:50:10 <lambdabot>   2
06:50:11 <tomberek> Saizan: yeah, i was looking at that, unless I'm mistaken, not quite the same
06:50:11 <obiwahn> DasIch: like have a funtion that uses 2 arguments first argument ist fun (a->b) and the second is type a - then i create a new function using the fist fun and wait for the 2nd parameter (type a)
06:50:41 <Lemmih> Rmx: See System.Process.
06:50:44 <Lemmih> Rmx: See System.Process.
06:50:46 <Lemmih> swath: The new ones are LYAH and RWH.
06:50:56 <obiwahn> i am not so much concerned about $ more beeing able to interpret the signature
06:51:08 <Lemmih> Oops, Sorry.
06:51:48 <applicative> obiwahn, yes, it takes two arguments the first must be a function type (a -> b) the second must be the same as the argument type of the function, (a) the result is b
06:51:57 <saati> obiwahn: if you have f:: (a->b) -> a -> b and f2 :: a-> you can say f3 = f f2 and you have what you wanted
06:51:59 <applicative> thus the signature is (a->b) -> a -> b
06:52:47 <applicative> obiwahn, note that the signature can be parsed, or rather is properly parsed, (a->b) -> (a->b)
06:55:40 <applicative> so you could say: ($) takes one argument, a function (a->b) and brilliantly returns ... a function (a->b). (that in turn is waiting for an argument) ($)  is really 'id' specified to functions
06:56:53 <applicative> > let ($$$$) = id in (+1) $$$$ 1
06:56:54 <lambdabot>   2
06:58:40 <dainanaki> Just to be clear about something, strict constructors fields just evaluate the value for that field to whnf, right?
06:58:46 <koeien> dainanaki: yes
06:59:05 <applicative> Itkovian: did you see my doubtful emendation?
06:59:51 <applicative> dainanaki: yes
07:00:55 <Itkovian> applicative: nope.
07:01:19 <Itkovian> checking now
07:01:29 <applicative> it compiles, and I can see why, but I can't see why yours didn't compile
07:02:11 <dainanaki> So, in the case of ![a], that would mean that would really just mean !x : thunk (assuming that there's something in the list, right?
07:02:15 <Itkovian> ha, after the comment that function were too large I've put the crossover and mutation in separate functions myself
07:02:17 <Itkovian> so thx
07:02:26 <applicative> Itkovian: it might at least help figure out what's up.  I wonder if, if you were actually using crossEnts in the do block, ghc would know how to specify
07:02:48 <applicative> Itkovian: it occurs to me that this might come under the new rules about 'let'
07:03:25 <obiwahn> f $ x = f x -.- ($) f x = fx  -.- ($$) x = \(f,x) -> f x
07:03:34 <koeien> dainanaki: no, only the : constructor gets evaluated
07:03:42 <obiwahn> grmpf how would i write a partial application?
07:03:43 <koeien> dainanaki: not even the first element
07:04:00 <koeien> obiwahn: just like normal applications, partial applications are not special.
07:04:03 <dainanaki> hrm, that's not particularly useful then.
07:04:09 <koeien> dainanaki: on the contrary!
07:04:14 <koeien> > map (+1) [1,2,3]
07:04:15 <lambdabot>   [2,3,4]
07:04:23 <obiwahn> f3 f = f $ 3
07:04:25 <koeien> @let plus x y = x + y
07:04:26 <lambdabot>  Defined.
07:04:38 <koeien> > map (plus 3) [2,3,4]
07:04:39 <lambdabot>   [5,6,7]
07:05:09 <dainanaki> I'm not sure that I see how strictness of the list constructor helps there.
07:05:18 <koeien> so in Haskell we let function application associate to the left, so (f x y) means ((f x) y)
07:05:46 <koeien> dainanaki: but for -> in types, it's the other way around. so Integer -> Integer -> Integer really means Integer -> (Integer -> Integer)
07:06:12 <koeien> > seq (undefined:undefined) () -- dainanaki ^
07:06:13 <lambdabot>   ()
07:06:46 <koeien> err, i got confused here. :)
07:06:50 <dainanaki> :/
07:07:19 <koeien> dainanaki: it might be useful, but in general it is not in the case of a list if you want to evaluate all elements strictly
07:07:47 <hatomic> Hello. I can't cabal install gtksourceview2. Found a cached webpage ( http://tinyurl.com/3b9nu7o ) informing that a C lib must be installed. Could you tell me what file do I have to place and where?
07:08:13 <dainanaki> that's more of what I had in mind, but I'm realising that I may have just been getting overly happy with strictness.
07:08:19 <dcoutts> hatomic: e.g. on debian you need the gtksourceview-dev distro package installed
07:10:24 <hatomic> I have used --extra-lib-dirs=C:\Dev\gtksourceview-2.0.2 - where the source files are unpacked
07:12:10 <krey_> hi, can someone help me with iorefs and strefs, I can't seem to find a good tutorial
07:13:24 <applicative> Itkovian: I take back my remark about 'let' http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7 doesn't bear on the case
07:14:00 <hatomic> Passing --extra-include-dirs to cabal also does not make it work.
07:15:03 <applicative> hatomic, you need pkgconfig-depends: gtksourceview-2.0 >= 2.0.2
07:15:42 <applicative> so you need to ask your package manager for gtksourceview >= 2.0.2  or do you think you have it?
07:15:45 <byorgey> krey_: you'll probably get a better response if you just ask some specific questions.  e.g. is there something in particular you are trying to do?  some code that is causing an error and you don't understand why? etc.
07:16:58 <applicative> byorgey, krey_ is hoping to make an error
07:18:03 <hatomic> Sorry. I only installed the gtk+ bundle v2.22.1 for windows. I have the error Configuring gtksourceview2-0.12.2...
07:18:04 <hatomic> setup.exe: The pkg-config package gtksourceview-2.0 version >=2.0.2 is required but it could not be found.
07:18:35 <applicative> hatomic, grrr, wonder how you install gtksourceview on windows
07:20:46 <applicative> hatomic, this looks like it could be a little nasty...
07:25:36 <krey_> byorgey: well, we're trying to solve a search problem and we have formalised it as a 2d grid of references (linked grid?). we want to solve it in Haskell, but the idea is fairly imperative, so we thought about using IORefs and STRefs, cause someone mentioned them, but we now nothing about them
07:25:44 <applicative> hatomic, on top of gtk+, gtksourceview  requires  libxml2 2.5.x and libgnomeprint 2.8.x.  the latter is also on the win32 page http://ftp.gnome.org/pub/gnome/binaries/win32/
07:25:50 <hatomic> applicative: Yea. Using haskell under windows - it's not for the faint of heart. Minor quirks can get you stuck and feel hopeless, really.
07:26:18 <applicative> my experience is it's fine till you need some gnu library....
07:26:47 <Laugarhraun> Hi! Would it appear that \\ is strict?
07:28:00 <int-e> > head (1:undefined) \\ [3..5]
07:28:00 <lambdabot>   No instance for (GHC.Num.Num [a])
07:28:01 <lambdabot>    arising from a use of `e_1135' at <int...
07:28:18 <int-e> > head $ (1:undefined) \\ [3..5]
07:28:19 <lambdabot>   1
07:28:21 <dainanaki> I've been wondering this for a while, but it seems kind of common to map a newtype wrapper over a list of elements. How does ghc handle this, since in the code it looks like a constructor and there is function application occurring, but in theory newtypes are supposed to be free?
07:28:35 <int-e> Laugarhraun: it has to be strict in the second argument.
07:28:40 <Laugarhraun> > take 10 $ [1..] \\ [1,3..]
07:28:42 <Laugarhraun> ooooh ok
07:28:47 <Laugarhraun> thank you int-e
07:28:55 <lambdabot>   thread killed
07:29:10 <int-e> > [2] \\ ([1,3..1000] ++ [2])
07:29:31 <lambdabot>   thread killed
07:29:41 <int-e> Laugarhraun: you can write a lazy version for monotone lists.
07:30:44 <dcoutts> hatomic: you need pkg-config to know where it is
07:30:58 <int-e> > let diff (x:xs) (y:ys) | x < y = x : diff xs (y:ys) | x == y = diff xs ys | otherwise = y : diff (x:xs) ys in diff [1..] [1,3..]
07:31:01 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
07:31:05 <dcoutts> hatomic: you can do that using an env var, see the pkg-config help/docs
07:31:35 <byorgey> krey_: have you looked at the documentation?  For example, IORef is here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-IORef.html#t:IORef.  If you just follow the types there really isn't all that much to it.
07:32:16 <applicative> dcoutts is gtksourceview included in gtk+ ?
07:32:31 <dcoutts> applicative: no, it's an extension
07:32:40 <int-e> Laugarhraun: (that's the symmetric difference - leave out the y : to get the usual difference; you can also find the intersection of two (strictly) monotone lists by a minor variation on the theme.)
07:33:11 <applicative> dcoutts, that's what I thought, but maybe cabal install cant find his other gtk things either?
07:33:13 <hatomic> Do I have to build gtksourceview from source? I thought I only needed the C lib to install the cabal package.
07:33:37 <Laugarhraun> yes, I got it. Since I'm mostly working with monotonous lists I forgot it was not always so...
07:33:46 <benmachine> monotonic
07:33:50 <benmachine> not monotonous :P
07:33:59 <benmachine> unless they're also boring, I guess
07:34:03 <byorgey> > [1,1..] -- a monotonous list
07:34:05 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:34:15 <Laugarhraun> argh, bad translation (same word in French)
07:34:16 <int-e> hatomic: do you have the gtk2hs-buildtools package installed?
07:34:19 <dcoutts> applicative: cabal is relying on pkg-config to tell it the C flags and libs
07:34:33 <hatomic> int-e: yes
07:34:37 <applicative> yes that's clear
07:34:41 <benmachine> Laugarhraun: :) I wouldn't have brought it up except the notion of a monotonous list amuses me
07:34:43 <byorgey> Laugarhraun: hehe, no problem, we are not laughing at you, it was just amusing =)
07:35:04 <dcoutts> hatomic: when you run $ pkg-config --modversion gtksourceview-2.0 ,  if it can find it, then at that point cabal will also be able to find it
07:35:04 <Laugarhraun> I know, but I still felt the need to give a reason :)
07:35:49 <applicative> dcoutts, my impression was that hatomic hadn't got to the point of installing gtksourceview-2.x
07:35:50 <byorgey> Laugarhraun: you mean you use the same word in French to mean both "strictly increasing/decreasing" and "boring"?
07:36:13 <Laugarhraun> yes
07:36:26 <Laugarhraun> ¬´ monotone ¬ª
07:37:28 <luite> same in Dutch, "monotoon stijgend"
07:37:45 <dcoutts> hatomic: to get pkg-config to find it, you need to set the PKG_CONFIG_PATH to include the directory in your gtksourceview installation that contains the file gtksourceview-2.0.pc (probably in D:/gtksourcevie/lib/pkgconfig/ or wherever it was you unpacked it)
07:38:11 <hatomic> You are right. I'm searching for it and updating the PATH
07:38:19 <dcoutts> hatomic: you don't need to build gtksourceview from source, but you do need the "development" version of it, that includes the header files and the .pc file for pkg-config
07:38:41 * dcoutts has to go
07:38:45 <dcoutts> hatomic: good luck
07:40:44 <luite> I'm thinking of making a page with installation instructions for commonly used 3rd party non-haskell dependencies on windows. it would include installation instructions and pre-built binaries for many packages (like pcre, gtk, blas/lapack, sqlite, postgresql, glpk). does something like that already exist?
07:40:51 <Kaidelong> @ty return . runIdentity
07:40:54 <lambdabot> forall a (m :: * -> *). (Monad m) => Identity a -> m a
07:41:18 <Kaidelong> wonder if I could just go
07:41:42 <luite> windows users now seem to have to hunt down binaries for these things from all kinds of sources, or install msys and often do a lot of things to build them
07:41:47 <Kaidelong> sampleRVarTWith (return . runIdentity) someRVar :: IO Result
07:42:16 <applicative> luite that sounds like it would be a valuable service, if it doesn't kill you
07:42:39 <cheater_> luite, sounds like you shoud get back to working on wolfgang
07:42:53 <applicative> wolfgang?
07:42:54 <luite> applicative: I've built a fair amount of these packages myself
07:43:06 <luite> so it would just be a matter of uploading them
07:43:16 <luite> maybe checking for a new version first
07:43:24 <luite> I'm going to ignore cheater_ for now ;p
07:43:37 <cheater_> you know i'm right
07:43:52 <luite> you always are
07:44:03 <cheater_> ^^
07:44:33 * applicative wonders what cheater_ meant by that, but perhaps it is best not to know
07:44:52 <luite> applicative: wolfgang is the haskell workbook site I'm working on
07:45:06 <luite> with online mathematica-like haskell stuffs
07:45:14 <applicative> oh cool
07:46:10 <cheater_> it's like wolfram alpha or mathematica
07:46:20 <applicative> oh, i remember, I think I saw it.
07:46:44 <cheater_> so you too think i am right in thinking luite should get back to it
07:47:13 <luite> I think you should all ban me from irc to prevent me wasting precious time there
07:47:35 <byorgey> @where ops
07:47:36 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
07:47:51 <byorgey> please ban luite so he can get back to working on Wolfgang ;)
07:48:16 <quicksilver> nah, his procrastination here contributes more to the public good
07:49:26 <Laugarhraun> argh, you cannot sort infinite lists...
07:49:51 <luite> hehe
07:50:01 <Nimatek> You can, it just takes an infinite amount of time!
07:50:04 <ion> > sort [0..]
07:50:20 <Laugarhraun> anyway I'll keep this line, I'm using applicative functors and it looks badass
07:50:21 <lambdabot>   thread killed
07:50:22 <ion> lambdabot just didn‚Äôt wait long enough.
07:50:44 <Nimatek> He is not very patient, is he?
07:51:01 <byorgey> she isn't, no =)
07:51:51 <mokus> lambdabot believes any problem that can't be solved in three seconds isn't worth solving ;)
07:52:37 <Nimatek> So lamdabot is a student.
07:52:46 <Nimatek> lambdabot*
07:58:31 * hackagebot prolog 0.1 - A Prolog interpreter written in Haskell.  http://hackage.haskell.org/package/prolog-0.1 (MatthiasBartsch)
07:59:39 <kniu> There might be a leak of some sort in GHCi
08:00:02 <kniu> I left the interpreter idle overnight, and when I woke up it was using up all my memory.
08:01:16 <dafis> kniu: which GHC version?
08:04:38 <aavogt> recently (maybe still?) doing lots of :reload could make ghci memory usage expand
08:10:07 <chreekat> Hi folks, I'm trying to figure out what the best practices are for integrating cabal and dpkg. Right now, when I need to install a new library, I sort of stumble through figuring out which package provides it, seeing if it's already provided in the debian repos, and falling back to 'cabal install' if it isn't.
08:11:07 <chreekat> That's already kind of tiring, and then if I use cabal I have software running around outside of dpkg's control, which is not ideal.
08:11:22 <hatomic> I did some progress here. Pkg-config finds gtksourceview. However, the cabal package gtksourceview2 requests for libxml-2.0. Thing is there is no libxml2-devel for windows. I tried a rpm for linux to no avail. Pkg-config finds it but cabal complains.
08:12:28 <roconnor> chreekat: it is my understanding that mixing cabal and your distro's package manager will only lead to pain.
08:12:36 <roconnor> (it is also my experience)
08:13:08 <chreekat> roconnor: precisely. :) I was wondering how other people dealt with it. I mean, what's the point of having _any_ packages in the debian repos, if you can't have them all?
08:13:28 <dafis> chreekat: is it a multiuser system or your very own box?
08:13:34 <chreekat> I found some info about a tool that debianizes cabal packages, but the info is 3 years old
08:13:41 <roconnor> chreekat: I think most people make a choice between using cabal or using their disto's haskell packages.
08:14:08 <roconnor> chreekat: use cabal if you need bleeding edge hackage packages or hackage packages not in your distro
08:14:13 <byorgey> chreekat: if you find yourself often needing packages that are not provided by debian, then you are probably at the point where you just want to completely manage your Haskell packages with cabal
08:14:15 <chreekat> dafis: It's just mine.
08:14:16 <roconnor> chreekat: otherwise you can use your distro's packages.
08:14:25 <dafis> chreekat: I have my ghcs in ~/bin and use cabal install for everything, and I'm happy with it :)
08:14:47 <mux> 85/*-+852785a tout'85//785/
08:14:57 <dafis> ?
08:15:21 <int-e> vi gone bad?
08:15:27 <mux> sorry, cats.
08:15:44 <dafis> int-e: s/gone //
08:15:50 <chreekat> Ok, thanks. Glad I'm not missing anything important regarding cabal/dpkg
08:16:21 <int-e> dafis: I know. VI VI VI is the editor of the beast.
08:16:44 <mux> it would be great if cabal had something similar to python's virtualenv script
08:17:21 <int-e> is that the niche that cabal-dev tries to fill?
08:17:34 <roconnor> I kinda wish cabal would somehow prevent you from mixing cabal and distro managed packages
08:17:44 <roconnor> since it works so badly
08:17:51 * mux nods
08:18:10 <benmachine> what would be really nice would be if cabal was better at rollbacks
08:18:23 <benmachine> so when things *did* go wrong, it could work that out and fix it
08:18:34 <roconnor> cabal needs more nix blood
08:18:35 <hpaste> george pasted ‚Äúclass versus FFI export‚Äù at http://hpaste.org/51050
08:18:48 <benmachine> yes
08:23:34 * hackagebot sequor 0.2.2 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.2.2 (GrzegorzChrupala)
08:23:52 <kniu> dafis, 7.2.1
08:25:28 <dafis> kniu: okay, I'll leave an idle ghci and see whether it starts eating memory
08:26:10 <georgevdd> http://hpaste.org/51050 - is it expected that a function that's restricted to a type class can't be exported by FFI, or is that a typechecking bug?
08:27:20 <quicksilver> yes, that's expected, georgevdd
08:27:47 <quicksilver> there is no standard FFI for classes
08:28:14 <georgevdd> @quicksilver thanks - do you know of any workarounds?
08:28:15 <lambdabot> Unknown command, try @list
08:28:52 <benmachine> georgevdd: export it with a concrete type
08:29:38 <hatomic> I cant install gtksourceview dependency in windows. If anyone has installed leksah in windows please let me know. :)
08:32:46 <quicksilver> georgevdd: well, the type 'a' in Ptr a is ignored by your C program anyway
08:32:57 <quicksilver> so the class constraint is hardly relevant.
08:33:34 * hackagebot prolog-graph 0.1 - A command line tool to visualize query resolution in Prolog.  http://hackage.haskell.org/package/prolog-graph-0.1 (MatthiasBartsch)
08:33:42 <georgevdd> I'd simplified it for the sake of example
08:41:09 <aavogt> georgevdd: if that did work, how would the specific implementations (based on whatever 'a' is) be chosen in C?
08:41:15 <erus`> i have to look for a new job: does anyone need a code monkey?
08:41:49 <erus`> i have references
08:42:00 <roconnor> erus`: according to the media everyone is looking for competent software developers
08:42:56 <roconnor> http://www.npr.org/2011/09/05/140194803/for-software-developers-a-bounty-of-opportunity
08:44:34 <tgeeky> it's too bad I'm not competent.
08:44:39 <erus`> meh i have no .NET / java experience
08:44:46 <benmachine> tgeeky: yeah I thought that too :P
08:44:50 <erus`> professionally anyway
08:45:08 <georgevdd> >aavogt good question. I think I need to encode all the implementations I need for my function in a record, and pass that record as well as 'a'.
08:46:01 <roconnor> at last: object-oriented fotran
08:47:26 <benmachine> roconnor: foortran?
08:47:40 <roconnor> fortran
08:47:58 <tgeeky> fortron?
08:48:02 <benmachine> oh I was making an oo joke, I didn't even notice you spelt it wrong >_>
08:48:07 <roconnor> :D
08:50:01 <aavogt> apropos fortran http://hpaste.org/steps/50837
08:54:34 <Veinor> aavogt: haha what the hell
08:57:43 <aavogt> Veinor: that's slightly a lie because you have to run ghc twice because it doesn't seem possible to load a .so that's built (by gfortran) that's created when the quasiquote runs
08:58:09 <Veinor> ah
08:59:09 * aavogt should put the code up somewhere giggles
08:59:17 <aavogt> for giggles
09:04:23 <hpaste> obi pasted ‚Äúsignatures‚Äù at http://hpaste.org/51054
09:04:57 <obiwahn> how would i define the signature for the function and how do i find out the type using :t
09:05:47 <Botje> why would you give a type signature?
09:05:48 <c_wraith> obiwahn: you can't specify a type signature on functions in an instance.  (I'm not sure why it's not allowed)
09:06:09 <Botje> Eq already gives you the correct type
09:06:54 <obiwahn> aaaahahahaaaaaaa *think* aaahahahaaaaaaaaaaaaa - mmmmmmmmmmmmmmmmmmm k:)
09:07:18 <c_wraith> I guess it's not allowed because doing it properly for higher-kinded classes would imply scoped type variables, which is not part of the standard.
09:08:09 <c_wraith> Hmm.  doesn't even need to be higher-kinded.  Just needs to involve a type variable in the instance head.
09:11:26 <mm_freak> now what would be really great in the arrow notation is, if you could leave away the parentheses around tuples
09:11:33 <mm_freak> require -< visible, ()
09:11:39 <mm_freak> instead of:  require -< (visible, ())
09:13:34 * hackagebot omega 1.5.1 - A purely functional programming language and a proof system  http://hackage.haskell.org/package/omega-1.5.1 (GaborGreif)
09:26:45 <hpaste> lightstep pasted ‚Äúproblem installing leskah‚Äù at http://hpaste.org/51056
09:26:57 <lightstep> hello, i'm trying to install leksah using cabal-install, and i get that error
09:27:21 <lightstep> my ghc version is 7.0.3, and i just updated my cabal list
09:28:14 <lightstep> what does the error mean? it just installed 2.0.12, and complains it needs >=2.0.2
09:29:38 <rostayob> > "12" > "2"
09:29:39 <lambdabot>   False
09:29:40 <krey_> what does the # sign mean?
09:29:41 <rostayob> just kidding.
09:29:41 <lightstep> oh, i got it, i needed to install my distro's dev package. funny, i remember compiling gtk programs before
09:29:51 <benmachine> krey_: where?
09:29:57 <rostayob> krey_: it's for ghc primitive types i guess?
09:30:07 <rostayob> sorry, unboxed types
09:30:12 <krey_> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-ST.html#fixST
09:30:25 <krey_> benmachine, rostayob: ^
09:30:32 <rostayob> krey_: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/primitives.html
09:30:44 <lightstep> > "2-0.12.2" >= "2.0.2"
09:30:45 <lambdabot>   False
09:31:07 <rostayob> lightstep: I was joking ehe
09:31:59 <lightstep> what is the metadata leksah is downloading?
09:32:17 <hpaste> georgevdd annotated ‚Äúclass versus FFI export‚Äù with ‚Äúclass versus FFI export (annotation)‚Äù at http://hpaste.org/51050#a51057
09:33:00 <krey_> rostayob: why does fixST need unboxed types? more importantly, what does fixST do?
09:34:59 <rostayob> krey_: Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation. Many of the primitive operations listed in primops.txt.pp return
09:35:01 <rostayob> unboxed tuples. In particular, the IO and ST monads use unboxed tuples to avoid unnecessary allocation during sequences of operations.
09:35:57 <KirinDave> Oh smoo
09:35:59 <krey_> rostayob: thanks :)
09:36:07 <KirinDave> It was a terrible mistake to host that patched version of cabal on my s3 bucket.
09:36:17 <KirinDave> I'm gonna have a pretty big bill this month. :(
09:36:32 <dcoutts_> KirinDave: is that the patches bootstrap.sh?
09:36:32 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
09:36:40 <dcoutts_> patches/patched
09:36:41 <KirinDave> dcoutts_: Yes
09:36:45 <krey_> does anyone know what fixST is for?
09:37:11 <dcoutts_> KirinDave: I could put up a tarball on my space on code.h.o
09:37:34 <dcoutts_> KirinDave: was it a patched version of 0.10.x or from HEAD ?
09:37:56 <dcoutts_> 0.10.x needs some extra patches from HEAD to work correctly with Cabal-1.12 that comes with GHC 7.2
09:38:01 <dcoutts_> otherwise there's some bugs
09:38:02 <Saizan> krey_: it for defining cyclic structures that need ST
09:38:17 <KirinDave> dcoutts_: 1.12
09:38:27 <rostayob> Ke: I'd guess it has to do with fix? but i'm not sure
09:38:30 <dcoutts_> KirinDave: no I mean cabal-install version
09:38:34 <krey_> Saizan: we were trying to use it to write a for loop. didn't quite work out :S
09:38:37 <byorgey> krey_: you can use it to define an ST computation which depends on its own result
09:38:41 <KirinDave> dcoutts_: 10.2
09:38:49 <byorgey> krey_: you should not need it to write a for loop =)
09:38:57 <byorgey> krey_: if you want a for loop, use forM or forM_
09:39:01 <byorgey> @type forM
09:39:01 <rostayob> krey_: you're writing a for loop in ST? baaaaad
09:39:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
09:39:10 <dcoutts_> KirinDave: you mean 0.10.2, ok. Then there's other patches you need anyway
09:39:16 <KirinDave> dcoutts_: Why?
09:39:52 <krey_> rostayob, byorgey: we were trying to figure out an example use of fixST
09:40:11 <byorgey> rostayob: eh? why is that bad?
09:41:02 <dcoutts_> KirinDave: because building cabal-install-0.10.x against Cabal-1.12 introduces a bug, I'm just trying to remember what it was
09:41:12 <rostayob> byorgey: I had guessed he's using ST to change the index or something like that
09:41:17 <dcoutts_> KirinDave: because of a change in behaviour of something between Cabal-1.10 and 1.12
09:41:23 <boegel> hiya
09:41:33 <dcoutts_> KirinDave: requiring a corresponding change in cabal-install
09:41:59 <boegel> is there an 'inverse' of liftIO, to lift a monadic function into the IO monad (e.g. to use the monadic function from within main)?
09:42:02 <rostayob> byorgey: and wait a second... <byorgey> krey_: you should not need it to write a for loop =)
09:42:06 <KirinDave> dcoutts_: I did introduce a patch or two as part of the process I followed
09:42:20 <byorgey> boegel: no, not in general
09:42:25 <boegel> I found this which explains liftIO very well: http://stackoverflow.com/questions/5806716/mixing-monads-in-haskell
09:42:27 <byorgey> boegel: although there may be for specific monads
09:42:33 <boegel> but I'm also looking for the converse
09:42:48 <boegel> byorgey: so, how does one use a monadic function in main then?
09:43:06 <byorgey> boegel: well, you need some sort of function  runThisMonad :: SomeMonad a -> IO a
09:43:25 <byorgey> your particular monad may or may not have such a function
09:43:37 <boegel> byorgey: and there's no general one, like liftIO that does the reverse?
09:43:44 <byorgey> boegel: nope, it is not possible
09:43:49 <boegel> byorgey: hmmk, damn
09:43:59 <byorgey> boegel: what exactly are you trying to do?
09:44:11 <dcoutts_> KirinDave: ah yes, you'll probably find that cabal sdist is broken
09:44:20 <boegel> byorgey: see https://github.com/boegel/GA
09:44:29 <dcoutts_> KirinDave: you need this patch:
09:44:55 <byorgey> boegel: ok, at which file should I look?
09:44:59 <boegel> byorgey: I have a GA library, and I want to be able to use the evolve function with a random monad, so that scoring functions can be done with IO, or Interpreter
09:45:08 <dcoutts_> KirinDave: * Update cabal sdist to follow the changes in the Cabal lib
09:45:38 <boegel> byorgey: if you try to compile example2 (make example2), it'll fail, because the evolve function (which returns Monad m => m a) can't be hoisted into the IO of main in example2
09:45:45 <boegel> byorgey: evolve is defined in GA.hs
09:45:50 <KirinDave> dcoutts_: Ahh, indeed I had some problems with that last night!
09:45:59 <byorgey> boegel: yes, I found it
09:46:00 <luite> boegel: there are usually two ways to do something like that, either a runRandom function, or make IO itself an instand of your RandomMonad
09:46:13 <sigfpe_> What's the current recommended best way to run a map in parallel? parMap from Control.Parallel.Strategies? And what are the corresponding command line options for both for compilation and runtime?
09:46:15 <KirinDave> dcoutts_: Can you direct me to the patch? I'll update my archive.
09:46:45 <dcoutts_> KirinDave: it's in the darcs repo in cabal head, I just gave you the name of the patch
09:46:53 <KirinDave> dcoutts_: Oh. Darcs. :\
09:47:04 <krey_> rostayob: so how could I create a for loop in ST?
09:47:05 <boegel> luite: so, I need to make the user of my GA lib supply a thing like that?
09:47:05 <KirinDave> dcoutts_: I did manage to force cabal-dev add-source to work, but not without some difficulty with broken sdist.
09:47:09 <sigfpe_> There are lots of tutorials, but they all seem out of date.
09:47:14 <Phyx-> dcoutts_: quick question, is there a cabal development guide somewhere? I'm having trouble finding a few things
09:47:16 <luite> boegel: you can change it to (MonadRandom m, MonadIO m) =>
09:47:31 <dcoutts_> Phyx-: yes, on the trac
09:47:35 <luite> boegel: (though MonadRandom has more parameters)
09:47:38 <Saizan> sigfpe_: for compilation you need -threaded, for runtime +RTS -Nn where n is the number of OS threads you want to use
09:47:38 <rostayob> krey_: what do you mean with for loop? for (int i = 0; i < x; i++)?
09:47:42 <dcoutts_> Phyx-: there's a guide to the source code
09:47:48 <krey_> krey_: pretty much
09:47:59 * boegel looks into MonadRandom
09:48:01 <Phyx-> dcoutts_: ok, great, thanks, I'll go take a look
09:48:33 <sigfpe_> So for compilation I'll also need -rtsopts I guess. (I never used to need that.)
09:48:37 <byorgey> boegel: wait, I am confused.  if evolve can really operate within *any* monad, then why not IO?
09:48:41 <boegel> luite: I need something different than MonadRandom, I think
09:48:41 <dcoutts_> KirinDave: unfortunately you'll have to apply that patch manually to cabal-install-0.10.x because we did some rebasing to re-merge the cabal and cabal-install repos
09:48:49 <boegel> byorgey: it can operate with IO
09:48:50 <rostayob> krey_: well in haskell you can't get that, and for a reason (well yes you could hack something in a monad)
09:48:59 <luite> boegel: yeah, you have the user run it, but if you have a complicated monad structure, you can add a convenience run function
09:49:02 <byorgey> boegel: then what is the problem exactly?
09:49:10 <Saizan> sigfpe_: ah, yeah, that's a fairly recent change
09:49:11 <boegel> byorgey: it all depends on the user definition of the score function (see the Entity type class in GA.hs)
09:49:13 <luite> boegel: why different? IO is a MonadRandom I think
09:49:25 <boegel> byorgey: the return value of score determines what evolve will return
09:49:31 <rostayob> krey_: why do you need a for loop?
09:49:37 <byorgey> boegel: when you say "random monad" do you really mean "a monad that provides randomness" or do you mean "any old monad"?
09:49:42 <Peaker> krey_: there's forM/forM_
09:49:45 <Saizan> sigfpe_: btw, s.marlow has a tutorial linked from here http://research.microsoft.com/en-us/people/simonmar/
09:49:50 <boegel> byorgey: the latter (hence the confusion :))
09:49:55 <krey_> rostayob: well, we're trying to figure out how to use fixST
09:49:55 <dcoutts_> KirinDave: note that I'll also eventually get around to doing a cabal-install-0.12.x release which will build with Cabal-1.12 and have various new stuff
09:49:56 <boegel> luite: ^
09:50:13 <krey_> rostayob: a for loop seemed like a good idea at the time
09:50:27 <Eduard_Munteanu> forM(_) = flip mapM(_)
09:50:27 <Peaker> for imperative programming, a for loop is often a good idea
09:50:30 <luite> boegel: MonadRandom is parameterized by the random generator
09:50:31 <boegel> luite: I don't need a monad for randomness, sorry about the confusion
09:50:37 <sigfpe_> Saizan: Thanks! That looks up-to-date!
09:50:37 <luite> oh
09:50:39 <luite> ok
09:50:49 <Saizan> np :)
09:50:50 <Eduard_Munteanu> Which is more convenient when you write   forM_ xs $ \x -> do ...
09:51:02 <luite> boegel: if you want any monad, but you need to do IO, then you require it to be a MonadIO
09:51:04 <Saizan> i hope it is, the date is promising
09:51:16 <byorgey> boegel: but score does not place any restrictions on the monad used either
09:51:30 <boegel> by
09:51:39 <boegel> byorgey: no, it doesn't, that's right
09:51:51 <boegel> byorgey: it just let's the user use whatever he thinks necessary
09:51:52 <rostayob> krey_: I don't know what fixST does, but the name makes me think that is something similar to 'fix'. In any case, I don't think it's meant to write for loops :P
09:51:59 * boegel points out that he's new at all this
09:52:03 <byorgey> boegel: so what happens if you remove the   :: Identity Int   annotation in example2?
09:52:18 <boegel> byorgey: it just uses IO, and all is OK
09:52:34 <krey_> rostayob: ok, just out of interest, how would I write a for loop? (forM is considered cheating)
09:52:35 <boegel> byorgey: I guess I need a better example, where score returns something not in the IO monad
09:53:03 <boegel> byorgey: actually, in the example, the user defines score' (not score), and score defaults to "return (score' x d)"
09:53:08 <Peaker> krey_: forM/mapM is just map and sequence
09:53:14 <byorgey> boegel: that does not make sense, score is polymorphic in the monad
09:53:15 <boegel> byorgey: so here the inference to the IO monad works
09:53:36 <boegel> byorgey: the typeclass function is, but an instance might not be
09:53:51 <rostayob> krey_: cheating? what do you mean? anyway, what would the type sig of your "for loop" function be? I suspect you'd end up with forM
09:54:02 <byorgey> boegel: no, that's exactly what I'm saying.  the way you have declared it, every instance *must* be polymorphic in the monad.
09:54:03 <boegel> byorgey: what if a user defines score to return a value wrapped inside a Maybe monad?
09:54:11 <boegel> byorgey: ugh
09:54:13 <byorgey> boegel: they cannot, it will not type check.
09:54:18 <boegel> byorgey: that's not what I wanted
09:54:24 <krey_> rostayob: say I wanted to increase a STRef Int 10 times
09:54:24 <byorgey> boegel: aha, now we are getting somewhere =)
09:54:35 <boegel> byorgey: I'm glad we are
09:54:44 <boegel> byorgey: note, I never said I knew what I was doing :D
09:55:03 <rostayob> krey_: that's not a for loop, you're increasing the STRef 10 times
09:55:05 <byorgey> boegel: I never said you did =)
09:55:17 <boegel> byorgey: so, how do I make score such that an instance can use any monad?
09:55:19 <Eduard_Munteanu> You can write it as a for loop as well.
09:55:39 <byorgey> boegel: if you want the user to be able to pick the monad per instance, then m must also be one of the parameters of the Entity class
09:55:39 <boegel> byorgey: if you can point me to some documentation on something like this, that suffices :)
09:55:49 <boegel> byorgey: oh, I see
09:55:54 <byorgey> class ...  Entity m a b c | ...  where ...
09:55:58 <boegel> byorgey: that actually makes sense :)
09:56:02 <Eduard_Munteanu> forM_ [1..10] (const $ modifySTRef ref (+1))
09:56:07 <rostayob> krey_: can't you just call 'modifySTRef ref (1 +)' 10 times?
09:56:11 <byorgey> boegel: good =)
09:56:24 <Peaker> Eduard_Munteanu: might as well use replicateM_ rather than forM_ on const
09:56:29 <boegel> byorgey: since the Monad you'll use is tied to the instance you're defining
09:56:33 <Eduard_Munteanu> Yup ^^
09:56:33 <boegel> byorgey: w00! :D
09:56:36 <byorgey> boegel: right.
09:56:40 <boegel> byorgey: I'll look into that, thx
09:56:46 * boegel dives into his code
09:56:49 <byorgey> boegel: and I think there is no problem in terms of example2, IO, etc.
09:56:49 <Peaker> krey_: replicateM_ 10 (modifySTRef ref (+1))
09:57:07 <byorgey> boegel: whatever monad the user wants to use, they will have to have a way to use it however they want to use it.
09:57:35 <byorgey> boegel: either a way to run it in some IO computation, or a way to run it as a pure computation, or whatever
09:57:57 <byorgey> but you as the author of the library don't need to worry about that
10:03:27 <boegel> byorgey: well, I'll also be using the library
10:03:35 <boegel> byorgey: and I want to supply some useful examples
10:05:09 <boegel> byorgey: after I fix GA.hs, how would I use evolve if it returns "Interpreter a" (see http://hackage.haskell.org/package/hint)
10:23:41 * hackagebot egison 0.3.1.1 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.3.1.1 (SatoshiEgi)
10:28:07 <kmc> so this local heap garbage collection paper by Simon and Simon devotes a lot of effort to improving the performance of mutation
10:28:22 <kmc> because lazy evaluation implies rampant mutation behind the scenes
10:29:02 <kmc> i wonder if there are unexplored benefits to a language with strict, pure evaluation
10:29:03 <ruuby> Does a law like composition for applicative functors (pure (.) <*> u <*> v <*> w = u <*> (v <*> w)) mean anything without an implementation?
10:29:08 <kmc> where you really don't mutate heap objects ever
10:29:49 <kmc> ruuby, what do you mean?  it's saying the law ought to hold for every implementation
10:29:56 <kmc> nothing is checking that, except the library author
10:30:24 <koeien> ruuby: yes, it means that it *should* hold for all implementations, so if you write your own instance, you should prove it
10:31:04 <koeien> the compiler is not able/willing to do that for you
10:31:13 <koeien> similar for the rules for Num
10:31:16 <roconnor> I read an interesting argument against testing for producing highly reliable software.  It said that the amount of testing needed to get defect rates down to the level required for highly reliable software is so much that it is practically impossible to do unless your prior probability of failure is already extremely low, and if your prior probability is already that low, you then don't need to do testing.
10:31:42 <ruuby> kmc: oke, but where does the law come from? or is that a silly question...
10:32:13 <kmc> ruuby, it comes from wanting Applicative to have nice properties.  wanting certain algebraic manipulations to be valid
10:32:22 <kmc> i don't have a great example with Applicative
10:32:48 <roconnor> ruuby: the laws of an applicative functor are equivalent to the laws of a monoidal functor, but arguably I'm just pushing your question around.
10:32:54 <kmc> but, for example, it would be weird if you had a monad instance where  x >> (y >> z)  did something different from (x >> y) >> z
10:33:11 <kmc> i.e. do { x; do { y; z } }  vs do { do { x; y}; z }
10:33:23 <kmc> so there's a monad law about that
10:33:24 <koeien> ruuby: this one is more obscure, but think of a Num instance.
10:33:31 <Aune> Hello all, Im trying to write a IRC-bot to handle pizza orders for my weekly pizza-meets. But it is not working properly. Can you take a look: http://hpaste.org/51059
10:33:36 <koeien> ruuby: there you want that sum [x0,..,xn] = x0 + (x1 + ( ... ) ) = (..(x0+x1)+x2 + ...)
10:33:48 <koeien> or the Monad laws, if you're familiar with them, allow us to manipulate do-blocks in certain ways without changing the semantics
10:33:58 <Aune> I appreciate comments on style, but mostly Im looking for my logic errors
10:34:09 <kmc> ruuby, likewise, you want do { x <- a; return x}  to be equivalent to just a
10:34:28 <kmc> these i think can be intuitively justified without knowing category-theoretical definition of a monad
10:34:35 <kmc> maybe it's harder to justify the Applicative laws
10:35:02 <koeien> Aune: line 16, change it to 6667 -- from the top of my head
10:35:02 <roconnor> kmc: the Applicative laws are as easy to justify as the Monad laws.
10:35:42 <koeien> Aune: without the PortNumber
10:36:13 <koeien> Aune: AFAIR the PortNumber expects the port number in network byte order, which on your machine is most likely not the same as host byte order
10:36:37 <koeien> Aune: so now it's connecting to a different port than 6667
10:36:58 <Aune> koeien, I dont think that is a problem, I can connect to the server, but after connecting nothing else is happening.
10:37:06 <parcs> that looks like the example irc bot from the wiki
10:37:08 <koeien> Aune: ok, that could be
10:37:27 <MdxBhmt> I  used the bot from the wiki with port= 6667
10:37:56 <Aune> parcs, Yes, it is heavily inspired by that one
10:38:43 * hackagebot deepseq-th 0.0.0.0 - Provides Template Haskell deriver for NFData instances  http://hackage.haskell.org/package/deepseq-th-0.0.0.0 (HerbertValerioRiedel)
10:39:41 <koeien> Aune: i'm not sure :( You could try to look with a packet sniffer
10:41:11 <Aune> koeien, I think the problem lies in the "listen" function, I want it to run more or less forever, but I dont think it does
10:41:36 <bfig> consider a self-recursive type representing a balanced tree dictionary... how can i implement a lookup function in that tree?
10:41:50 <bfig> without of course entering the unsafe world :)
10:42:43 <ruuby> Oke thanks guys, it still needs some thinking on my part but l'll get there.
10:43:12 <bfig> in particular: Tree k v =  Zero k v | Succ ( Tree k ( Node k v)); Node k v = Node3 k v k v k v | Node 2 k v k v
10:43:41 <bfig> i'm not interested in insertion or deletion or anything, i'm just interested in lookup :|
10:44:27 <roconnor> bfig: what is lookup k (Zero k v) ?
10:44:33 <roconnor> er
10:44:41 <roconnor> bfig: what is lookup k0 (Zero k v) ?
10:46:30 <roconnor> oh wait
10:46:58 <roconnor> I see, this tree is a bit unusual
10:47:23 <bfig> it is a balanced tree
10:47:25 <bfig> by types
10:47:27 <bfig> :)
10:47:28 <roconnor> yep
10:50:46 <rwbarton> interesting problem
10:50:49 <roconnor> bfig: It's unclear to me how the internal keys of this tree relate to the keys that will appear below it.
10:51:13 <parcs> ooh, looks like ghc 7.4 might feature associated type defaults and Constraint kinds
10:51:16 <roconnor> bfig: I'd like to see some example trees
10:51:20 <koeien> Aune: i found a few things
10:51:29 <koeien> Aune: first of all, hGetContents should be hGetLine
10:51:39 <bfig> roconnor, well i have no idea
10:51:48 <koeien> Aune: second, you're flooding the server because all messages get a reply. You should be more careful when you're sending a privmsg
10:51:57 <bfig> roconnor, it is very likely unfeasible
10:51:58 <roconnor> bfig: do you know how to insert into this tree?
10:52:08 <bfig> roconnor, nope >_>
10:52:12 <Aune> koeien,  ok.. checking it out
10:52:24 <bfig> roconnor, i know how to insert into a keyless tree
10:52:25 <roconnor> bfig: where did this type come from?
10:52:37 <bfig> adv functional programming class exercise.
10:52:48 <bfig> the idea is to see if it can be done at all
10:52:56 <bfig> i think it can be done iff you can reflect
10:53:35 <roconnor> well there are a few plausible ways to implement lookup depending on the invarients of your tree
10:53:36 <bfig> let's assume you can ignore the keys in the Succ ( Tree k..) and you're only interested in the leaves... i don't even know how to do backtracking on this tree
10:53:40 <bfig> ie, just getting an element at all
10:53:58 <bfig> (a k,v pair from the bottom row)
10:54:32 <roconnor> bfig: do you want log(n) lookup? 'cause if you want we can flatten the tree and do a linear lookup
10:54:34 <rwbarton> I think you can get a list of all elements easily enough
10:54:49 <roconnor> bfig: but if you want log(n) lookup you need to use the internal keys
10:54:50 <bfig> roconnor, how can you flatten that tree with k-v pairs?
10:55:45 <bfig> one step at a time, how can we flatten this tree at all?
10:56:18 <roconnor> flatten (Zero k v) = [(k,v)]; flatten (Succ t) = flatten t >>= flattenNode where flattenNode (Node3 k1 v1 k2 v2 k3 v3) = [(k1,v1),(k2,v2),(k3,v3)]; flattenNode (Node2 k1 v1 k2 v2) = ...
10:56:24 <Aune> koeien, thanks, works a bit better now ^^
10:56:29 <bfig> even if you can polymorphic-recursive transverse the tree to the bottom you don't know where to stop
10:56:57 <roconnor> bfig: you may need to add type annotations to get the polymorphic recursion to typecheck.
10:57:26 <koeien> Aune: hGetContents lazily reads all input from the socket
10:57:40 <koeien> Aune: but lazy I/O is kind of evil, although sometimes convenient.
10:57:48 <koeien> Aune: in your case it's simply incorrect
10:57:52 <bfig> because you will have things like this for example: Succ ( Succ ( Succ ( (node2 (node2 ( node2 k v k' v') (node2 k'' v'' k''' v''')) ( ...)..)
10:58:06 <roconnor> bfig: sure, no problem
10:58:09 <roconnor> bfig: see above
10:58:21 <bfig> but between succ succ succ... you'll have zero(zero(zero(zero(zero....)..)
10:58:35 <Aune> koeien, so, does that mean it is waiting for an EOF or does it mean something else?
10:58:58 <roconnor> bfig: flatten (Zero k v) = [(k,v)]; flatten (Succ t) = flatten t >>= flattenNode where flattenNode (Node3 k1 v1 k2 v2 k3 v3) = [(k1,v1),(k2,v2),(k3,v3)]; flattenNode (Node2 k1 v1 k2 v2) = [(k1,v1),(k2,v2)]
10:59:14 <roconnor> oops
10:59:16 <roconnor> that isn't quite right
10:59:23 <bfig> how do you remove all the Zero?
10:59:25 <rwbarton> needs a .snd
10:59:31 <koeien> Aune: it returns immediately. the string is filled on demand with data from the socket.
10:59:32 <rwbarton> but yes, somethiing like that will work
10:59:36 <roconnor> bfig: flatten (Zero k v) = [(k,v)]; flatten (Succ t) = flatten t >>= flattenNode where flattenNode (_,(Node3 k1 v1 k2 v2 k3 v3)) = [(k1,v1),(k2,v2),(k3,v3)]; flattenNode (_,(Node2 k1 v1 k2 v2)) = [(k1,v1),(k2,v2)]
10:59:54 <roconnor> bfig: the first line
10:59:54 <koeien> Aune: but the string will only be terminated if the connection is closed
10:59:59 <roconnor> flatten (Zero k v) = [(k,v)]
11:00:18 <bfig> roconnor, what if i'm storing (Node2 key value) ?
11:00:24 <koeien> Aune: e.g. if you evaluate 'length', it's going to wait until the connection is closed
11:00:35 <bfig> ie, taking a dump over the type system
11:00:43 <rwbarton> that's fine
11:01:01 <rwbarton> *Main> treeToList (Zero 1 (Node2 2 'b' 3 'c'))
11:01:01 <rwbarton> [(1,Node2 2 'b' 3 'c')]
11:01:01 <roconnor> bfig: doesn't matter
11:01:14 <roconnor> bfig: the number of Succ cosntructors tells me when to stop recurssing
11:01:14 <rwbarton> where treeToList = roconnor's flatten
11:01:54 <roconnor> bfig: so even if you have a tree of Node2's it is fine.
11:02:02 <boegel> hmm, is there a way to make Identity an instance of MonadIO?
11:02:20 <bfig> roconnor, ok, so you can add up and do a foldr . (repeat join) ?
11:02:20 <roconnor> boegel: god I hope not.
11:02:25 <boegel> without using unsafePerformIO
11:02:27 <rwbarton> liftIO = Identity . unsafePerformIO
11:02:33 <boegel> rwbarton: :)
11:02:44 <roconnor> bfig: not really
11:02:49 <bfig> :p
11:02:52 <roconnor>  flatten (Succ t) = flatten t >>= flattenNode
11:03:01 <roconnor> bfig: here we call bind on each recursive call
11:03:05 <roconnor> bfig: and bind is doing a join
11:03:06 <benmachine> boegel: if there was, then runIdentity . liftIO :: IO a -> a
11:03:15 <bfig> yes... where is the recursive call?
11:03:23 <roconnor> right there
11:03:29 <roconnor> flatten (Succ t) = flatten t >>= flattenNode
11:03:34 <monochrom> liftIO m = Identity undefined
11:03:35 <roconnor> on the LHS of >>=
11:03:43 <bfig> ahh lol
11:03:52 <bfig> sure that will join all the types
11:03:54 <benmachine> monochrom: = undefined, usually?
11:03:59 <bfig> how do you keep track of how many succs you go down?
11:04:07 <benmachine> (usually as in Identity is usually a newtype)
11:04:13 * boegel scratches his head
11:04:19 <roconnor> flatten t will return a [(k, Node k v)]
11:04:32 <roconnor> and then flattenNode turns that into [(k,v)]
11:04:47 <monochrom> liftIO :: IO a -> Identity a; liftIO m = Identity undefined
11:05:01 * bfig thinks
11:05:01 <rwbarton> the number of Succs turns into the number of ">>= flattenNode"s
11:05:03 <roconnor> bfig: as I traverse the tree I keep pulling off Succ constructors until I get to Zero
11:05:20 <bfig> yes, but you don't remember how many times you did it
11:05:40 <roconnor> bfig: my "call stack" keeps track of that
11:05:53 <bfig> ahh i think i understand
11:07:42 <roconnor> Do people on #haskell tend to float out things in where clauses that don't depend on the parameters of the function being defined?
11:08:11 <shachaf> roconnor: Not necessarily.
11:08:59 <shachaf> If something is only likely to be useful in one place it makes sense to keep in a where clause.
11:09:11 <roconnor> good
11:09:24 <boegel> byorgey: made it work, thx! :D
11:09:47 * shachaf represents the opinions of all of #haskell, by default.
11:09:53 <roconnor> boegel: oh god!
11:10:21 <bfig> you remove the succ, then recusrively smash the first level of the tree
11:10:21 <bfig> the next call flattens the second level, and removes another succ
11:10:21 <bfig> the thing is the bind is inside the monad itself, so it is recursing over itself till yo have no more succs :D
11:10:22 <bfig> i think i understand now, very awesome :)
11:11:00 <boegel> roconnor: not making Identity an instance of MonadIO, but fixing my GA lib :)
11:11:16 * dafis is relieved
11:11:28 <boegel> roconnor: I'll have to make pure and non-pure versions of my evolve function, it's the only way
11:11:45 <roconnor> bfig: I see it as removing the Succ, then recursively smaking all the levels of the tree except for the bottom level, then we bind flattenNode to sweep of the last level.
11:11:58 <boegel> is there any naming convention for pure functions and their non-pure counterpart (that allow IO inside)?
11:12:00 <bfig> roconnor, yes :D
11:12:13 <roconnor> boegel: put IO after the non-pure one?
11:12:27 <boegel> roconnor: seems too straightforward :P
11:12:35 <rwbarton> generalise to an arbitrary monad and append M
11:12:35 <boegel> roconnor: also, evolveIO kind of sucks :P
11:12:50 <roconnor> boegel: put IO_factor_factory after the non-pure one?
11:12:55 <boegel> rwbarton: well, no, the evolve function is already generalized
11:13:28 <boegel> rwbarton: the IO version also does actual IO (reading/writing files), and will use liftIO
11:13:28 <rwbarton> give them the same name and put them in different modules and name all your types T
11:13:51 <monochrom> ha ha ha
11:14:00 <boegel> :)
11:14:04 <roconnor> rwbarton: *lol*
11:14:21 <boegel> rwbarton: different modules is not such a bad suggestion, I think
11:14:24 <rwbarton> boe	oh I see.
11:14:32 <rwbarton> er
11:14:54 <rwbarton> I don't understand how it is even possible for my terminal to do this kind of thing
11:16:44 <benmachine> boegel: call it evolveFile or something?
11:17:27 <benmachine> (also, liftIO is overrated)
11:17:30 <benmachine> actually liftIO is probably fine, although it may produce worse error messages than just providing IO functions
11:18:38 <boegel> benmachine: I'll call it evolveChkpt, because it's the checkpointing aspect that requires IO
11:18:40 <Dashkal> Looking for a suggestion cleaning up some code.  I have a function that takes a maybe and I want to have a guard inside against having that maybe have a value with the wrong property.  Nothing is fine. (code to come)
11:18:42 <boegel> thx for the suggestions guys
11:19:56 <Dashkal> My current check looks like this: if (isJust mFoo && (isRunning . fromJust $ mFoo)) ... (where isRunning is the property I'm checking)
11:20:39 <benmachine> :t maybe False isRunning
11:20:41 <lambdabot> Not in scope: `isRunning'
11:20:43 <benmachine> ff
11:20:46 <benmachine> :t maybe False isUpper
11:20:47 <lambdabot> Maybe Char -> Bool
11:20:58 <Dashkal> Oh perfect.  Thank you :)
11:21:11 <benmachine> the 'maybe' function is superb for writing all your maybe-related combinators
11:21:19 <rwbarton> or something like   case mFoo of Just x | isRunning x -> .....
11:21:25 <benmachine> notice that, for example, (>>=) is flip (maybe Nothing)
11:21:30 <rwbarton> depending on what you want to do in the ...
11:21:48 <benmachine> fmap is \f -> maybe Nothing (Just . f)
11:21:49 <benmachine> etc.
11:22:11 <Dashkal> Exactly.  I got stuck on "Cracking" the maybe and forgot I could just use "maybe" to handle things inside
11:37:24 <mkscrg> So let's say a module doesn't export a datatype's constructor but does export its record accessors.
11:37:58 <mkscrg> For example, Network.HTTP.Enumerator doesn't export a constructor for Request, but it does export record accessors like `secure`, `requestHeaders`, etc.
11:38:31 <LordBrain> Anyone here ever play with house installed in a vm?
11:39:01 <mkscrg> Is there a way to explicitly import all those the accessors for Request without naming them individually?
11:39:24 <monochrom> does Request(..) work?
11:40:21 <mkscrg> It does!
11:40:23 <mkscrg> Awesome.
11:40:58 <LordBrain> are there any ide's written in haskell?
11:41:13 <koeien> LordBrain: leksah
11:41:24 <byorgey> LordBrain: yes, Leksah and manatee come to mind
11:41:42 <koeien> also a text editor, yi
11:41:56 <LordBrain> i knew about yi
11:42:05 <LordBrain> thanks re leksah
11:42:10 <LordBrain> that looks pretty cool
11:47:22 <tromp> > nubBy(((>1).).gcd)[2..]
11:47:26 <lambdabot>   mueval-core: Time limit exceeded
11:48:15 <tromp> @src nubBy
11:48:15 <lambdabot> nubBy eq []             =  []
11:48:15 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
11:52:18 <shapr> hoi tromp, hoe gaat het?
12:00:23 <ash_> don't as patterns get evaluated in sequence?
12:01:28 <theclaw> Hi. I tried playing with xmonad's config, but when running "ghci xmonad.hs", the defined symbols aren't in my scope. Why is that?
12:01:33 <ash_> herp derp never mind i can't spell
12:01:43 <tgeeky> the herp has been derped!
12:01:59 <theclaw> e.g. "myTerminal" isn't in the scope, but it's defined in "xmonad.hs"
12:02:02 <roconnor> theclaw: try #xmonad
12:02:33 <theclaw> roconnor: it's more of a general haskell questions, xmonad.hs defines certain variables, but I can't access them
12:02:45 <dmwit> theclaw: Did it compile without errors?
12:03:00 <dmwit> Maybe paste xmonad.hs and a transcript of your ghci session to hpaste.org.
12:03:01 <koeien> theclaw: does your file start with module ModuleName(main) ?
12:03:17 <theclaw> koeien: no, it doesn't
12:03:41 <tromp> hi shapr, het gaat zijn gangetje
12:03:45 <dmwit> s/compile/whatever it does that ghci does before giving you control/
12:04:27 <theclaw> dmwit: yes, it said "Ok, modules loaded"
12:04:34 <tromp> i'm trying to desgin a t shirt out of the smallest primes program
12:05:43 <dmwit> theclaw: Maybe paste xmonad.hs and a transcript of your ghci session to hpaste.org.
12:05:46 <dmwit> ;-)
12:05:47 <rwbarton> probably you have an xmonad.o and ghci gets confused by this
12:05:56 <hpaste> johannes pasted ‚Äúxmonad.hs default config‚Äù at http://hpaste.org/51063
12:06:15 <locus> Is there a good setup for haskell-ing on a flash drive (so I can bring haskell to my CS class easily)? I'm looking at getting cabal to default to system wide and not store its exe in home like I think it did (home is not accessible)
12:06:25 <dmwit> rwbarton++
12:06:26 <rwbarton> try rm xmonad.o before running ghci
12:06:28 <theclaw> dmwit: done ;). I just thought it's always possible to run "ghci foo.hs" and access the defined symbols
12:06:31 <rwbarton> (is there a better solution?)
12:06:39 <dmwit> rwbarton: yep!
12:06:44 <dmwit> ghci '*xmonad.hs'
12:06:56 <rwbarton> ...
12:07:03 <dmwit> not kidding
12:07:06 <rwbarton> does that work with :load also?
12:07:08 <dmwit> yes
12:07:10 <koeien> then '*xmonad.o' cannot be found?
12:07:16 <rwbarton> maybe I can make emacs do that then
12:07:24 <dmwit> koeien: No, '*' is interpreted specially by ghci.
12:07:30 <koeien> ok, I see.
12:07:38 <koeien> this bugged me also for some time :)
12:07:39 <theclaw> rwbarton: that did it, thanks
12:08:49 * hackagebot email 0.1.1.1 - Sending eMail in Haskell made easy  http://hackage.haskell.org/package/email-0.1.1.1 (JohannesWeiss)
12:08:54 <dmwit> (Actually, the fact that it works from the command line is probably unintended. My guess is that they gave :load special syntax, then passed stuff from the command line directly to the same function :load uses, accidentally enabling this nice syntax.)
12:09:06 <dmwit> (But I don't know for sure.)
12:11:32 <akahn> is that documented somewhere?
12:11:43 <dmwit> Probably?
12:12:18 <akahn> ah http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/loading-source-files.html
12:12:43 <akahn> nm, it's not mentioned in there
12:12:48 <byorgey> http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#ghci-scope
12:13:05 <byorgey> "To ensure that GHCi loads the interpreted version of a module, add the * when loading the module, e.g. :load *M."
12:13:27 <dmwit> Dang, a few minutes too late.
12:13:34 <dmwit> byorgey++
12:13:48 <akahn> ty :)
12:13:49 <byorgey> =)
12:13:52 <ruuby> I'm having trouble working out this in the types: u <*> (v <*> w), v <*> w :: f (a -> b) -> f a -> f b, u <*> (v <*> w) :: ?. How is (v <*> w) merged into the the type of the composite definition?
12:14:14 <dmwit> :t (<*>)
12:14:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:14:33 <byorgey> ruuby: v <*> w :: f (a -> b) -> f a -> f b, really?
12:14:48 <dmwit> v <*> w :: f ???
12:14:57 <dmwit> You've got the wrong type for that subexpression.
12:15:08 <byorgey> (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:15:35 <byorgey> so if  v :: f (a -> b)  and  w :: f b  then  v <*> w :: f b
12:15:46 <byorgey> er, sorry, w :: f a
12:16:24 <dmwit> Using those type variables, we'd then conclude that u :: f (b -> c) and u <*> (v <*> w) :: f c
12:16:41 <dmwit> for some c
12:22:29 <ruuby> byorgey: dmwit: thanks, I think I get it now
12:23:54 * hackagebot system-fileio 0.2.2 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.2.2 (JohnMillikin)
12:23:56 * hackagebot system-fileio 0.3.2 - High-level filesystem interaction  http://hackage.haskell.org/package/system-fileio-0.3.2 (JohnMillikin)
12:28:54 * hackagebot netwire 1.2.3 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.3 (ErtugrulSoeylemez)
12:57:34 <sigfpe_> I must be losing my sanity. I replace [-1,0,1] with [-1..1] in my code and I get a different result. That's not right is it?
12:57:56 <dmwit> > [-1 .. 1]
12:57:58 <lambdabot>   [-1,0,1]
12:58:03 <dmwit> > [-1 .. 1] :: Double
12:58:04 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
12:58:05 <lambdabot>         against inferred ty...
12:58:09 <dmwit> > [-1 .. 1] :: [Double]
12:58:10 <lambdabot>   [-1.0,0.0,1.0]
12:58:21 <dmwit> sigfpe_: seems a bit odd, yeah
12:58:37 <dmwit> > [-1 .. 1] :: [Complex Double]
12:58:39 <lambdabot>   No instance for (GHC.Enum.Enum
12:58:39 <lambdabot>                     (Data.Complex.Complex GH...
12:59:19 <sigfpe_> Hmmm...seems like a compiler bug to me. I apply fmap to [-1 .. 1] and get the empty list!
12:59:45 <dmwit> Is there a small enough example to put on hpaste?
12:59:47 <koeien> surely that depends on your type
12:59:59 <dmwit> I was about to ask what type the list was at, too.
13:00:30 <dafis> > [-1 .. 1] :: [Word]
13:00:32 <lambdabot>   []
13:01:02 <dmwit> hah, perfect
13:01:43 <Veinor> > -1 :: Word
13:01:44 <lambdabot>   18446744073709551615
13:02:12 <sigfpe_> Veinor: You have it!
13:02:15 <MdxBhmt> -1 :: int
13:02:20 <MdxBhmt> aw
13:02:31 <koeien> > -1 :: Int
13:02:32 <lambdabot>   -1
13:02:39 <MdxBhmt> eureka
13:02:52 <sigfpe_> It was inferring a type I wasn't expecting. I'm sane after all.
13:02:52 <koeien> Int is also bounded.
13:03:12 <benmachine> > [-1 ..] :: Int
13:03:14 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:03:14 <lambdabot>         against inferred type ...
13:03:17 <Veinor> sigfpe_: dafis found it, i was just verifying ;)
13:03:17 <dmwit> > -999999999999999999999999 :: Int
13:03:17 <benmachine> oh wups
13:03:18 <lambdabot>   -2003764205206896639
13:03:26 <benmachine> > length ([-1 ..] :: [Int])
13:03:30 <lambdabot>   mueval-core: Time limit exceeded
13:03:35 <benmachine> oh, duh
13:03:38 <benmachine> > length ([-1 ..] :: [Word])
13:03:40 <lambdabot>   1
13:03:42 <koeien> benmachine: length also gives an Int as result ...
13:03:58 <koeien> but maybe not in lambdabot's prelude
13:04:00 <benmachine> koeien: that's fine, I meant the latter thing
13:04:01 <koeien> :t length
13:04:02 <lambdabot> forall a. [a] -> Int
13:04:10 <dmwit> :t foldl'
13:04:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:04:25 <dmwit> > foldl' (\a b -> a + 1) 0 [0 :: Int ..]
13:04:29 <lambdabot>   mueval-core: Time limit exceeded
13:04:45 <burp> > maxBound + 1 :: Int
13:04:45 <lambdabot>   -9223372036854775808
13:05:42 <MdxBhmt> maxBound + 1 ::Integer
13:05:49 <MdxBhmt> > maxBound + 1 :: Integer
13:05:50 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
13:05:50 <lambdabot>    arising from...
13:05:54 <koeien> MdxBhmt: Integer is not Bounded
13:06:06 <MdxBhmt> that as relief
13:06:07 <MdxBhmt> lol
13:06:30 <tromp> lists are not bounded either, but their length is:)
13:06:37 <benmachine> tromp: no it isn't
13:06:47 <tromp> :t length
13:06:48 <lambdabot> forall a. [a] -> Int
13:06:49 <koeien> :t genericLength
13:06:49 <lambdabot> forall b i. (Num i) => [b] -> i
13:06:57 <benmachine> the return of the length function is bounded
13:06:58 <tromp> i said length, not genericLength:)
13:07:11 <benmachine> yes but the problem there is that 'length' does not actually return the length of the list :P
13:07:27 <MdxBhmt> what does it do, then?
13:07:35 <burp> estimate it :D
13:07:38 <benmachine> it returns the length of the list squeezed into an Int
13:07:54 <koeien> what happens if you overflow an Int? is the result unspecified, but not _|_ ?
13:08:02 <burp> koeien: I just showed that
13:08:03 <benmachine> implementation-defined I think
13:08:04 <tromp> .> maxBound::Int
13:08:05 <koeien> is there wrapping around an undefined?
13:08:16 <Veinor> wrapping?
13:08:17 <tromp> > maxBound::Int
13:08:18 <lambdabot>   9223372036854775807
13:08:27 <benmachine> koeien: what does that even mean?
13:08:29 <koeien> burp: that's a coincidence. on my machine it might work differently
13:08:41 <koeien> benmachine: i mean, wrapping around an unspecified number?
13:08:47 <koeien> benmachine: like with Word32 et al
13:08:52 <benmachine> ah right
13:09:09 <benmachine> try not to use the word undefined in this context, it sounds like you're talking about
13:09:10 * koeien should read the Report
13:09:12 <benmachine> :t undefined
13:09:14 <lambdabot> forall a. a
13:09:20 <koeien> benmachine: yes, sorry about that :)
13:09:58 <benmachine> koeien: "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined; an implementation may choose error (‚ä•, semantically), a truncated value, or a special value such as infinity, indefinite, etc."
13:10:08 <benmachine> http://haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1170006.1
13:10:28 <rostayob> is there a way on parsec to express something like "all unicode chars except these"?
13:10:29 <koeien> thanks
13:10:43 <benmachine> rostayob: noneOf?
13:10:56 <koeien> notInClass
13:11:09 <benmachine> in case of emergencies there's always 'satisfy'
13:11:17 <koeien> maybe that's attoparsec tho :/
13:11:18 <rostayob> benmachine: cool, thanks
13:11:48 <dmwit> benmachine++
13:12:05 <dmwit> "in case of emergencies" is a funny phrase
13:12:16 <benmachine> :)
13:16:08 <handonson> among those many zipper libraries on hackage, what should normally be chosen for production use?
13:19:44 * roconnor needs to turn his 2-hour multiplate talk into a 20 min talk.
13:21:17 <MdxBhmt> talking fast won't be enought
13:21:21 <Tinned_Tuna> Hi, I'm a little lost; I'm trying to find more thorough documentation for this library: http://hackage.haskell.org/packages/archive/datetime/latest/doc/html/Data-DateTime.html
13:21:28 <Tinned_Tuna> in particular, parseDateTime
13:22:30 <Tinned_Tuna> (or another library that does similar things, but with better documentation)
13:22:33 <dmwit> Tinned_Tuna: Click "source", they chose literate Haskell for their documentation.
13:23:09 <dmwit> But parseDateTime is just a wrapper around the real parseTime, documented here:
13:23:14 <dmwit> http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Format.html#v:parseTime
13:23:18 <Tinned_Tuna> dmwit: ahh
13:23:20 <Tinned_Tuna> thank you
13:23:56 <Tinned_Tuna> I had no real idea where to find where that particular function was defined
13:24:00 <Tinned_Tuna> thank you ^.^
13:24:04 <dmwit> ?hoogle parseTime
13:24:05 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
13:24:05 <lambdabot> Data.Time.Format class ParseTime t
13:24:17 <roconnor> dmwit: that doesn't look like literate haskell to me
13:24:17 <dmwit> The web-version also links to the documentation when you try that.
13:24:29 <dmwit> Well, there's not a lot of literate bits.
13:24:33 <dmwit> But it's in .lhs format.
13:24:52 <roconnor> dmwit: are we looking at the same file?
13:24:56 <roconnor> http://hackage.haskell.org/packages/archive/time/latest/doc/html/src/Data-Time-Format-Parse.html#parseTime
13:25:03 <dmwit> nope
13:25:12 <dmwit> http://hackage.haskell.org/packages/archive/datetime/latest/doc/html/src/Data-DateTime.html#parseDateTime
13:26:02 <dmwit> Note the difference between Data.DateTime.parseDateTime and Data.Time.Format.parseTime
13:26:03 <roconnor> oh crap
13:26:13 <roconnor> wasn't datetime a dangerous library?
13:26:17 <Tinned_Tuna> hm?
13:26:56 <roconnor> a lot of libraries try to "simplify" time handling, but the standard libraries are about as simple as they can be and still be correct.
13:27:14 <roconnor> so these libraries tend to lead you to write error prone code
13:27:22 <dmwit> I don't think DateTime is trying to simplify it, only provide a bridge to other time code.
13:27:27 <roconnor> but I don't recall any specifics about datatime
13:27:30 <roconnor> so I could be FUDing here
13:28:08 <dmwit> Like SQL servers and the like.
13:28:54 <Tinned_Tuna> roconnor: I dislike fudding
13:29:12 <dmwit> Honestly, I don't see a lot of worthwhile functions in DateTime.
13:29:22 <roconnor> dmwit: a quick glance shows they are freely converting between UTCTime and UniversalTime; which is wrong
13:30:30 <Tinned_Tuna> *note, I only want it to be able to find the current time, and find the difference in that relative time and the current time in minutes... I don't know if that's affected by the issues you're referring to.
13:30:32 <roconnor> after Ashley went through all the trouble of disentangling all the various notions of time, these libraries just smash all the types back into one mess again. :(
13:30:52 <dmwit> Tinned_Tuna: Just use plain old Data.Time, then.
13:31:06 <dmwit> getCurrentTime and diffTime will do just what you want.
13:31:21 <roconnor> Tinned_Tuna: How do you want to handle leap seconds?
13:31:26 <dmwit> *diffUTCTime
13:31:40 <Tinned_Tuna> dmwit: I would also like it if my Haskell libraries would give me a nice massage when I inevitably break my code :-p
13:31:49 <Tinned_Tuna> roconnor: it doesn't need to be accurate
13:32:02 <Tinned_Tuna> well, let me rephrase that
13:32:08 <Tinned_Tuna> it doesn't need to be accurate to the second
13:32:26 <Tinned_Tuna> hell, it can be inaccurate to getting on for a day.
13:32:40 <roconnor> Tinned_Tuna: are you okay with getting a negative time difference even though the second event occurs after the first?
13:33:18 <roconnor> so long as the error is less than a second?
13:33:25 <Tinned_Tuna> yes
13:33:36 <Tinned_Tuna> the 'time' I'm given is a date
13:33:43 <Tinned_Tuna> I'm trying to work out if it's a few days in the past
13:34:01 <roconnor> okay, dmwit's advice is fine then.
13:34:11 <Tinned_Tuna> my code gets "YYYYMMDD" and I am just looking to see if it's >1 week old :-p
13:34:21 <Tinned_Tuna> (well, it'll be configurable in the end...)
13:34:33 <roconnor> >1 week old +/- 1 second
13:34:36 <roconnor> :)
13:35:13 <roconnor> Tinned_Tuna: as dmwit said, you can use diffUTCTime
13:35:36 <roconnor> and keep in mind that you can use realToFrac on NominalDiffTime
13:35:59 <Tinned_Tuna> lol, Data.Time makes my job easier, it has a diffDays function
13:36:10 <Tinned_Tuna> in Data.Time.Calendar
13:36:41 <Cale> yes
13:38:15 <Cale> Data.Time is quite well-designed, I'm not quite sure what this DateTime module is for.
13:38:37 <Tinned_Tuna> Cale: perhaps the writer struggled with Date.Time for some reason?
13:42:30 <roconnor> a lot of people struggle with Date.Time
13:42:35 <roconnor> it isn't easy
13:42:44 <roconnor> but it is still well-designed
13:42:59 <benmachine> the real world is complicated, suck it >_>
13:43:28 <roconnor> Tinned_Tuna: are you running linux?
13:44:22 <Tinned_Tuna> roconnor: yes? Why wouldn't I be?
13:44:45 <Tinned_Tuna> benmachine: fuck the real world. It doesn't really exist. People talk about it, but they are LIARS
13:45:05 <roconnor> Tinned_Tuna: try running "cal 9 1752"
13:45:26 <benmachine> haha oh dear
13:45:26 <koeien> the year with the missing week? :)
13:45:49 <koeien> ah even worse
13:46:19 <Tinned_Tuna> Isn't that when they re-adjusted for the gregorian calendar?
13:46:39 <dafis> roconnor: looks correct here
13:46:41 <roconnor> it is when britian switched from the Julian Calender to the Gregorian Calendar
13:46:54 <Tinned_Tuna> If it is, people rioted, claiming that they wanted their 11 days back, or something like that...
13:47:21 <roconnor> Tinned_Tuna: this is the sort of issue your "1 week ago" problem can raise
13:47:34 <Tinned_Tuna> Like I say, though, that's this theoretical concept that people call the "real world"
13:47:43 <Tinned_Tuna> it's all bunk, there's not even such a thing as the "real world"
13:48:05 <Cale> hear hear :)
13:48:36 <byorgey> Tinned_Tuna: in that case I suggest you use the Acme.Time.Now module from the acme-now package
13:48:49 <byorgey> since there is no such thing as the real world it should suit your needs perfectly
13:50:23 <Tinned_Tuna> :-p
13:51:44 <Tinned_Tuna> that package has officialy made my day. My day was not doing awesome up to then.
13:52:00 <byorgey> =)
13:56:51 <joachi> i can hardly believe how good LYAH is
13:58:27 <Saizan> and it's not butter either
13:59:07 <gwern> > 0.15 * 0.20
13:59:13 <lambdabot>   mueval: ExitFailure 1
13:59:13 <lambdabot>  mueval-core: Time limit exceeded
13:59:16 <gwern> > 0.15 * 0.20
13:59:17 <lambdabot>   3.0e-2
13:59:24 <Tinned_Tuna> well that was odd.
13:59:27 <gwern> > (0.15 * 0.20) * 100
13:59:28 <lambdabot>   3.0
13:59:44 <Tinned_Tuna> > 3.0e-2 * 1.0e2
13:59:45 <lambdabot>   3.0
13:59:56 <geheimdienst> > 15e-2 * 20e-2 * 1e2
13:59:57 <lambdabot>   3.0
14:02:36 <dmoctezuma> is it correct to have a function that return an Integer that uses readFile inside of it? (talking about pure functions)
14:02:54 <roconnor> dmoctezuma: it is impossible.
14:02:55 <monochrom> no
14:03:07 <Tinned_Tuna> Also, with Cabal, should I install a library I don't want on my system (using cabal configure, build, install), is there a de facto way of removing it?
14:03:16 <dmoctezuma> ok that explains the compiler errors
14:03:38 <dainanaki> Is there any easy way to specify the chunk size you want an enumerator to output?
14:03:52 <roconnor> ignoring the (const readFile 7) possibilities
14:03:58 <roconnor> er
14:04:01 <dmoctezuma> so I suppose I should return an IO Integer, so is there a way to convert IO String to IO Integer?
14:04:02 <roconnor> ignoring the (const 7 readFile) possibilities
14:04:03 <monochrom> Tinned_Tuna: see my http://www.vex.net/~trebla/haskell/sicp.xhtml for how to remove
14:04:07 <geheimdienst> dmoctezuma: a pure function can't use IO (can't do readFile and things like that). try reading the integer in main (main is not a pure function) and then give it into your pure function
14:04:15 <roconnor> dmoctezuma: yes
14:04:21 <roconnor> dmoctezuma: using fmap
14:04:27 <MdxBhmt>  > fold (+) $ takeN 1000 [10e-15 ..]
14:04:28 <roconnor> dmoctezuma: or liftM
14:04:36 <geheimdienst> @hoogle IO String -> IO Int
14:04:37 <lambdabot> Network.Socket send :: Socket -> String -> IO Int
14:04:37 <lambdabot> Prelude readIO :: Read a => String -> IO a
14:04:37 <lambdabot> System.IO readIO :: Read a => String -> IO a
14:04:53 <dmoctezuma> ah readIO, I was using read
14:05:01 <roconnor> @src readIO
14:05:01 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:05:02 <geheimdienst> ... that didn't work so well :) the function i meant was read
14:05:09 <geheimdienst> > read "15" :: Int
14:05:10 <lambdabot>   15
14:05:15 <monochrom> dainanaki: some of those enumFile or enumHandle functions let you choose a chunk size
14:05:16 <geheimdienst> > read "lolcats" :: Int
14:05:17 <lambdabot>   *Exception: Prelude.read: no parse
14:05:29 <Tinned_Tuna> thanks monochrom :-)
14:05:29 <dmoctezuma> it worked, thanks
14:05:30 <hpc> reads is almost always a better choice
14:05:31 <hpc> :t reads
14:05:33 <lambdabot> forall a. (Read a) => String -> [(a, String)]
14:05:43 <dainanaki> monochrom: I guess I'll just make my enumerator support that option then.
14:06:22 <MdxBhmt> > foldr (+) $ takeN 1000 [10e-15 ..]
14:06:24 <lambdabot>   Not in scope: `takeN'
14:06:46 <MdxBhmt> > foldr (+) $ take 1000 [10e-15 ..]
14:06:47 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
14:06:47 <lambdabot>    arising from a us...
14:07:00 <MdxBhmt> i'll never get it ;(
14:07:11 <monochrom> "takeN 1000 xs" is almost as redundant as "30 nCr 4"
14:07:16 <benmachine> you need another parameter in foldr
14:07:24 <Tinned_Tuna> > read "hello!" :: IO String
14:07:25 <lambdabot>   No instance for (GHC.Read.Read (GHC.Types.IO GHC.Base.String))
14:07:25 <lambdabot>    arising f...
14:07:28 <Tinned_Tuna> damn :-p
14:07:43 <benmachine> > foldr (+) 0 $ take 1000 [10e-15 ..]
14:07:45 <lambdabot>   499500.0
14:07:50 <benmachine> ...k
14:07:52 <MdxBhmt> ah, thanks D:
14:08:29 <MdxBhmt> the list didnt expanded the way i expected, thought
14:08:31 <krey_> hi, can haskell be used to conduct searches (AI problem)? (in general)
14:08:57 <dafis> @faq can haskell be used to conduct searches (AI problem)?
14:08:58 <lambdabot> The answer is: Yes! Haskell can do that.
14:09:20 <benmachine> > 10e-15
14:09:22 <lambdabot>   1.0e-14
14:09:26 <benmachine> fair
14:09:35 <krey_> dafis: cheers, but seriously... or are you saying this be a stupid question?
14:09:59 <benmachine> krey_: I think it's mostly a joke, but it's true that haskell can do nearly anything that can be done :P
14:10:04 <MdxBhmt> > foldr (+) $ take 10e15 [1e-15,1.1e-15 ..]
14:10:05 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:10:05 <lambdabot>    arising from the lit...
14:10:19 <MdxBhmt> > foldr (+) 0 $ take 10e15 [1e-15,1.1e-15 ..]
14:10:20 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:10:20 <lambdabot>    arising from the lit...
14:10:27 <dafis> krey_: It's one of the cases where the faq answer is appropriate
14:10:57 <krey_> benmachine, dafis: the problem isn't really difficult, but it involves a lot of state. does this mean that I shouldn't use haskell or that i'm not thinking "functionally"?
14:11:11 <geheimdienst> > foldr (+) 0 $ take 10^15 [1e-15,1.1e-15 ..]
14:11:12 <lambdabot>   Couldn't match expected type `[a]'
14:11:12 <lambdabot>         against inferred type `[a1] -> [...
14:11:16 <dafis> krey_: whether Haskell is *well suited* for that, however is a different question, whose answer I don't know
14:11:19 <shachaf> > (unsafePerformIO . r–µadIO) "5" :: Int
14:11:21 <lambdabot>   5
14:11:37 <benmachine> krey_: I don't know, but if I was going to learn about AI in haskell I'd start here http://hackage.haskell.org/package/#cat:ai
14:11:53 <MdxBhmt> > foldr (+) 0 $ take 10000 [1e-15,1.1e-15 ..]
14:11:54 <lambdabot>   5.0094999999997545e-9
14:12:01 <shachaf> krey_: Haskell can do state.
14:12:40 <MdxBhmt> foldr (+) 0 $ take 10000 $repeat 1e-15
14:12:45 <MdxBhmt> >foldr (+) 0 $ take 10000 $repeat 1e-15
14:13:03 <behelit> hi! is hpdf the package to use to generate pdfs? :)
14:13:07 <krey_> benmachine: wow, that looks like a horrible place to start :)
14:13:17 <dafis> MdxBhmt: needs a space after the '>'
14:13:21 <benmachine> krey_: suit yourself :P
14:13:24 <shachaf> behelit: It probably could be used for that.
14:13:24 <MdxBhmt> > foldr (+) 0 $ take 10000 $repeat 1e-15
14:13:25 <lambdabot>   1.0000000000000507e-11
14:13:38 <MdxBhmt> dafis: many thanks D:
14:13:45 <dafis> de nada
14:13:45 <exFalso> evening gentlemen
14:13:52 <dafis> evening
14:13:54 <kmc> behelit, generate pdfs of what?
14:14:04 <dafis> or, morning, rather ;)
14:14:06 <shachaf> .tex files.
14:14:16 <behelit> kmc: just text .. one page of text that i generate
14:14:30 <shachaf> behelit: An external program might be simplest to use for that.
14:15:13 <kmc> if you want your text to look good, i'd outsource the rendering to pdflatex
14:15:18 <behelit> shachaf: i'm trying to port a program to learn a little more about haskell
14:15:31 <kmc> behelit, the 'pandoc' library will help you generate TeX
14:16:26 <MdxBhmt> > let mymul a b = foldr (+) 0 $ take a $ repeat b   in mymul 10000 1e^-15
14:16:28 <lambdabot>   Not in scope: `^-'
14:16:33 <MdxBhmt> > let mymul a b = foldr (+) 0 $ take a $ repeat b in mymul 10000 1e-15
14:16:34 <lambdabot>   1.0000000000000507e-11
14:18:17 <behelit> kmc: reading!
14:18:31 <azaq23> @src replicate
14:18:32 <lambdabot> replicate n x = take n (repeat x)
14:18:37 <kmc> [La]TeX is a bizarre document format, but the output quality is fantastic
14:19:00 <benmachine> it really is bizarre in some ways
14:19:02 <kmc> and Pandoc will hide some of the ugliness of TeX code
14:19:22 <kmc> the slides i'm working on now are written in a horrible pidgin of Markdown and TeX
14:19:24 <benmachine> like, some decisions you go "well, that makes sense if you believe that the language was written to interfere as little as possible with normal text"
14:19:31 <kmc> but it's still much better than using TeX exclusively
14:19:33 <applicative> behelit, you can use hpdf to generate text. It only uses the inbuilt pdf fonts and Latin1 or whatever
14:19:40 <benmachine> and then you get \textbackslash{} and go... huh
14:20:21 <applicative> hpdf does the typesetting surprisingly well.  It is unfortunately not very hard to grasp how to use it :)
14:20:32 <applicative> not very easy, rather
14:20:40 <behelit> applicative: yeah, that's why i came here :)
14:20:48 <behelit> applicative: tried to find an example or two hehe
14:21:45 <applicative> there is a little example folder inside the tarball somewhere.  The author seems mostly to have been interested in images
14:24:03 <applicative> behelit, I doubt it is practical for most purposes.  I wish I could say that studying it was rewarding...
14:24:46 <behelit> yeah, i might scrap that part and output data into an intermediary format
14:25:10 <behelit> might actually proove to be more useful anyways
14:25:58 <born2code> @src readIO
14:25:58 <lambdabot> Source not found. :(
14:43:17 <dmoctezuma> is it valid to call an impure function from a pure function? (it seems not, but  just want to confirm an error at compiling)
14:44:34 <Saizan> pure and impure are somewhat vague terms, but you might be asking if IO X and X are somehow the same type, and they aren't
14:44:58 <kmc> dmoctezuma, there are no impure functions in Haskell, unless you dig deep into the guts of implementation
14:45:09 <kmc> a function of type (A -> IO B) is not an impure function
14:45:15 <kmc> it's a pure function which returns an IO action
14:45:26 <dmoctezuma> s/impure/functions of type IO something
14:45:36 <kmc> see http://www.haskell.org/haskellwiki/Introduction_to_IO and http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
14:45:44 <kmc> no function has type (IO something)
14:46:00 <kmc> the type constructor of a function is (->) not IO
14:46:15 <kmc> (A -> IO B) really is (A -> (IO B)), as the syntax would suggest
14:46:21 <kmc> it's an ordinary pure Haskell function
14:46:32 <kmc> you can call it anywhere you have an A
14:46:40 <kmc> what you get back is an IO action of type (IO B)
14:46:50 <dmoctezuma> I have a function returning an IO Integer, and another one (which doesn't use IO) that calls the first, it seems is not valid or so
14:46:52 <kmc> whether the IO described by that action ever gets performed is another question
14:47:16 <shachaf> kmc: There's also IO (A -> B), although that's also not a function.
14:47:22 <kmc> it's valid.  what you get back is an IO Integer, a "recipe" for how to produce Integers by doing IO
14:47:41 <kmc> your function that "doesn't use IO" might still be able to do something useful with that recipe
14:47:44 <kmc> like store it in a data structure
14:48:07 <dmoctezuma> ah I get it
14:48:34 <kmc> the "Introduction to IO" article says more on this
14:49:40 <Kaidelong> wasn't there some view of functions from a -> IO b as effectful arrows?
14:50:07 <Saizan> yes, by staying in the kleisli category
14:50:19 <Kaidelong> yeah that was what I thought
14:50:25 <Saizan> (for that particular monad)
14:50:31 <kmc> yeah.  (<=<) acts like "composition" on functions of type (a -> IO b)
14:50:34 <Kaidelong> I guess you could label that "impure functions" if you want
14:50:35 <kmc> and "return" acts like "id"
14:51:00 <kmc> yeah, it is *possible* to assign a useful interpretation to the term "impure function"
14:51:10 <kmc> it's just that when people come here asking about impure functions, they're almost always confused
14:51:36 <kmc> if you think of "IO" as a tag on "tainted" values or impure functions, then you won't be able to use IO properly
14:52:07 <Kaidelong> the best analogy I can come up with is commandlets in wpsh formerly monad
14:52:13 <shachaf> kmc: How does it practically prevent you from using IO properly?
14:52:23 <Kaidelong> but wpsh is probably even more obscure than haskell
14:52:39 <kmc> shachaf, how are you going to deal with [IO t] or Int -> IO (IO a -> IO a) or ...
14:53:20 <shachaf> kmc: Using functions :: () -> IO t, of course. :-)
14:53:23 <kmc> going from "IO is a crude hack for state in a functional language" to "actually Haskell is a good imperative language" requires understanding lots of things with types like those
14:53:26 <shachaf> Yes, I suppose the analogy doesn't work very well.
14:53:58 <kmc> yeah, you can add more special cases to a broken analogy to make it fit new things
14:54:02 <kmc> or you can use a correct analogy
14:54:26 <shachaf> Monads are like type classes.
14:54:44 <ciaranm> monads are like ponies
14:54:46 <kmc> i'm not talking about the technical question of whether there exists some interpretation of IO in terms of "impure functions"
14:54:55 <Saizan> () -> A is quite standard practice to deal with elements
14:55:00 <kmc> i'm talking about learning and teaching and effective ways of doing each
14:55:02 <Saizan> in CT i mean
14:55:22 <gwern> > 80 / 3
14:55:23 <lambdabot>   26.666666666666668
14:58:07 <Saizan> so the fact that the kleisli category is a CCC, or equivalently that this language of impure functions is higher order, is the property saying that you can manipulate IO actions like that
15:00:08 <rwbarton> the kleisli category of IO is CCC?
15:00:33 <rwbarton> wouldn't that say that IO (a -> b) is the same as a -> IO b
15:00:58 <Saizan> no
15:01:20 <rwbarton> or I guess I'm not sure what the product and exponential functors are here
15:01:27 <rwbarton> product is the product in Hask I suppose
15:01:39 <Saizan> the exponential would be A -> IO B itself
15:02:24 <rwbarton> actually it doesn't even appear to have products
15:02:48 <obiwahn> > let fold' f c (x:xs) = f x (fold' f c xs) in fold' (+) [1,2,3]
15:02:49 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> t)
15:02:49 <lambdabot>    arising from a use of...
15:02:54 <Saizan> rwbarton: how so?
15:03:05 <obiwahn> what is wrong with my fold?
15:03:25 <benmachine> obiwahn: no empty-list clause
15:03:28 <benmachine> for one
15:03:30 <rwbarton> how do you encode a pair of arrows (A -> IO B, A -> IO C) as an arrow A -> IO ??
15:03:40 <obiwahn> benmachine: i have that in my testfile:)
15:03:50 <Saizan> rwbarton: A -> IO (B,C)
15:03:57 <obiwahn> like fold' _ c [] = []
15:04:02 <benmachine> oh
15:04:04 <benmachine> that's wrong
15:04:18 <benmachine> you're never actually using c, now
15:04:19 <obiwahn> c
15:04:28 <rwbarton> but the arrows might have different effects
15:04:33 <rwbarton> you get a pair of effects on the LHS
15:04:37 <obiwahn> mistype here but not in the file
15:04:50 <benmachine> obiwahn: what leads you to think there's something wrong with it, theb?
15:04:52 <benmachine> *then
15:05:20 <obiwahn> and i get not the std signature min looks like (a -> b -> b) -> b -> [a] -> b
15:05:29 <obiwahn> s/min/mine/
15:05:35 <benmachine> :t foldr
15:05:36 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:05:47 <benmachine> ...problem?
15:06:02 <obiwahn> :t foldl
15:06:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:06:10 <benmachine> oh, you wanted a left fold?
15:06:38 <benmachine> in that case what is wrong with your fold is that it is a right fold
15:06:52 <obiwahn> u have not thought about the direction jet i have just tried to find any implementation ...
15:07:03 <rwbarton> like what if A B C are all (), then you cannot represent two IO ()s by one IO ()
15:07:31 <Kaidelong> why not rwbarton
15:07:40 <Kaidelong> @ty print "foo" >> print "bar"
15:07:41 <lambdabot> IO ()
15:08:15 <rwbarton> how do you recover (print "foo", print "bar") rather than something else like (print "foo" >> print "bar", return ())
15:08:23 <hpaste> obi pasted ‚Äúfold'‚Äù at http://hpaste.org/51071
15:08:24 <Kaidelong> @ty do { x <- print "foo"; y <- print "bar" ; return (x,y)}
15:08:25 <lambdabot> IO ((), ())
15:08:46 <Kaidelong> rwbarton: You can't recover (IO (), IO ())
15:08:55 <Kaidelong> well you can
15:09:00 <Kaidelong> but not in the way you want I don't think
15:09:30 <benmachine> depends what you want, I suppose
15:09:35 <hpaste> obi pasted ‚Äúfold'‚Äù at http://hpaste.org/51072
15:09:39 <Kaidelong> if you want to take two a -> IO b like things
15:09:48 <Kaidelong> then you should try for a -> IO (b,c)
15:10:17 <dafis_> obiwahn: you didn't pass a c in the call
15:10:31 <dafis_> fold' (+) 0 [1,2,3]
15:10:39 <Kaidelong> hmm the main difference between IO (b,c) and (IO b, IO c) I guess is that you can run the two actions separately in the second version
15:10:44 <Kaidelong> I guess it depends on what you want
15:11:02 <obiwahn> dafis_: works:)) god i am so stupid sometimes ....
15:11:17 <dafis> obiwahn: welcome to reality :)
15:13:06 <copumpkin> preflex: seen cmccann
15:13:07 <preflex>  cmccann was last seen on #haskell 6 days, 18 hours, 14 minutes and 40 seconds ago, saying: given how long it takes Java to catch up with anything new, you can just keep telling them the same thing
15:13:32 <Saizan> rwbarton: yeah, the kleisli category isn't a CCC, we just exploit that the base category is and that the monad is strong
15:13:55 <obiwahn> mh but why does the signature of foldr and foldl differ? they do the same thing but evaluate in a different way?!
15:14:13 <shapr> obiwahn: try to write them yourself...
15:14:33 <shapr> obiwahn: in one direction, all three must match, in the other, it's not necessary.
15:14:42 <Kaidelong> can djinn do existential types
15:15:29 <Kaidelong> @djinn forall a. forall b. forall c. (forall e. (e -> m e)) -> (forall d. (m (m d) -> m d)) -> (a -> m a, b -> m b) -> a -> (m b, m c)
15:15:29 <lambdabot> Error: cyclic kind
15:16:09 <Kaidelong> @djinn forall a. forall b. forall c. (forall e. (e -> m e)) -> (forall d. (m (m d) -> m d)) -> (a -> m b, a -> m c) -> a -> (m b, m c)
15:16:09 <lambdabot> Error: cyclic kind
15:16:17 <Kaidelong> okay I guess that won't work
15:16:23 <shapr> existential crisis?
15:16:43 <kmc> oh dear
15:17:02 <Kaidelong> it seems like you should be able to derive this using djinn somehow
15:17:09 <copumpkin> can djinn even deal with higher-rank types?
15:17:10 <shachaf> @djinn (forall a. a) -> (forall b. b)
15:17:11 <Kaidelong> but I'm not sure how you'd tell djinn about return and bind
15:17:11 <lambdabot> -- f cannot be realized.
15:17:18 <shachaf> copumpkin: Not as far as I know.
15:17:21 <copumpkin> Kaidelong: instantiate them yourself
15:17:24 <benmachine> @djinn (a -> m a) -> a -> m a
15:17:24 <kmc> > foldr f z [x,y]
15:17:25 <lambdabot> f a = a
15:17:25 <lambdabot>   f x (f y z)
15:17:44 <obiwahn> shapr: could you eplain it a bit more - i seem to have implemented foldr - why is it foldr and how does foldl differ? now i seem to build a memory structure form left to right and start resloving it from the right side .. is that meant by foldr?
15:17:52 <kmc> > foldr f z [x,y]
15:17:53 <lambdabot>   f x (f y z)
15:17:54 <kmc> > foldl f z [x,y]
15:17:55 <lambdabot>   f (f z x) y
15:18:00 <kmc> obiwahn, ^^^ that's the difference
15:18:06 <kmc> @src foldr
15:18:07 <lambdabot> foldr f z []     = z
15:18:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:18:08 <kmc> @src foldl
15:18:08 <lambdabot> foldl f z []     = z
15:18:09 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:18:11 <benmachine> they're different functions
15:18:13 <Kaidelong> oh that's right
15:18:17 <Kaidelong> higher rank type
15:18:19 <benmachine> they both reduce a list to a value but in different ways
15:18:21 <copumpkin> > foldl (*) z [x,y]
15:18:22 <Kaidelong> why was I thinking existentials
15:18:23 <lambdabot>   z * x * y
15:18:25 <copumpkin> > foldl (*) z [x,y,z]
15:18:27 <lambdabot>   z * x * y * z
15:18:31 <copumpkin> > foldr (*) z [x,y,z]
15:18:32 <lambdabot>   x * (y * (z * z))
15:18:36 <copumpkin> damn parentheses
15:18:54 <kmc> obiwahn, note that foldr is not tail-recursive, but can produce results incrementally, while foldl is tail-recursive but cannot produce results incrementally or work on infinite lists (it always starts at the *end* of the list)
15:19:05 <kmc> the usual rule in FP is "tail recursive == good" but this is kind of false in Haskell
15:19:13 <copumpkin> kmc: "starts"
15:19:31 <kmc> a lazy consumer and a lazy producer will form a co-routine which executes in constant space
15:19:36 <benmachine> > foldl (\_ _ -> ()) () [1 ..]
15:19:39 <lambdabot>  Terminated
15:19:40 <kmc> which can't happen if the producer is tail-recursive
15:20:47 <kmc> so am i crazy for starting these slides with mergesort instead of quicksort?
15:20:56 <benmachine> absolutely bonkers
15:21:02 <benmachine> hth
15:21:04 <kmc> @vixen am i crazy for starting these slides with mergesort instead of quicksort?
15:21:04 <lambdabot> cool, me too
15:21:12 <obiwahn> i need some time to read and understand the things you wrote so there is not much response but thank you!
15:21:13 <kmc> @nixon am i crazy for starting these slides with mergesort instead of quicksort?
15:21:14 <lambdabot> If you think the United States has stood still, who built the largest shopping center in the world?
15:21:18 <kmc> @where folds
15:21:18 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
15:21:21 <kmc> obiwahn, ^^^
15:21:25 <copumpkin> kmc: the horror!
15:21:30 <dmwit> quicksort is kind of hard in Haskell, isn't it?
15:21:40 <copumpkin> depends how you define it
15:21:42 <benmachine> non-fake quicksort is probably kinda hard
15:21:43 <benmachine> :P
15:21:53 <copumpkin> for certain values of "is"
15:21:54 <Jafet> Not hard, just long
15:21:56 <kmc> in-place quicksort is... well, not that bad, but it looks the same as in C
15:22:08 <kmc> the quicksort i meant is the fake two-line quicksort
15:22:12 <Jafet> Unless you want to do it in-place in lists
15:22:19 <kmc> which is a traditional "hook" for getting people interested in Haskell
15:22:20 <Jafet> I wonder how hard that is
15:22:23 <kmc> haha
15:22:29 <kadoban> i was pretty disappointed when i learned that the cool version isn't so cool :/
15:22:34 <kmc> try quick-sorting a linked list in in-place in C
15:22:39 <kadoban> it's still pretty though
15:22:47 <dmwit> I've always hated that strawman for exactly that reason.
15:22:53 <kmc> anyway i guess my little 'mergesort' is closer to the spirit of the algorithm it's cribbed from
15:23:00 <dmwit> People are (and ought to be!) disappointed when they see the man behind the curtain.
15:23:09 <dmwit> We ought to attract people with *real* magic.
15:23:22 <kmc> eh, it's still pretty good
15:23:43 <Jafet> Well, it has exactly the same complexity as "real" quicksort for all inputs.
15:23:45 <kmc> it's a nice concise sorting algorithm for immutable linked lists
15:23:53 <kmc> even if it doesn't deserve the name "quicksort"
15:23:54 <Jafet> So functionally, it's pretty much quicksort
15:23:58 <copumpkin> the real magic is figuring out what `let ((a, b), (c, d)) = ((1, 2), undefined) in a` evaluates to
15:24:01 <Jafet> ...which isn't quick
15:24:14 <benmachine> heh
15:24:36 <kmc> Data.List contains like five commented-out sorting algorithms
15:24:40 <ARRG> It think one of the main qualities of the basic haskell qs is that it's so obviously correct, whereas writing even a simple quicksort in imperative languages will often lead to subtile errors
15:24:52 <Jafet> A better one is let (a, b) = (b, 1) in a
15:25:05 <ciaranm> it's obviously correct and obviously awful
15:25:08 <dmwit> kmc: So, for mergesort, the two interesting bits are splitting a list and merging two lists. What's your split look like?
15:25:12 <copumpkin> Jafet: they're showing different things :)
15:25:45 <ciaranm> split is much nicer when you realise you don't have to split down the middle
15:25:53 <hpaste> kmc pasted ‚Äúmerge sort (dmwit)‚Äù at http://hpaste.org/51073
15:26:02 <Jafet> Following dmwit further, the concurrency runtime is also pretty magical
15:26:12 <dmwit> kmc: okay
15:26:23 <dmwit> Probably a good idea for intro stuff.
15:26:25 <Jafet> At least compared to any widely used language other than erlang
15:27:08 <dmwit> > let split (x:y:rest) = let (evens, odds) = split rest in (x:evens, y:odds); split short = (short, []) in split [1..10]
15:27:11 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
15:27:13 <behelit> ok, so i'm testing a few things .. and when i do a putStrLn $ show $ mydata, it outputs "doc: <<loop>>". I tried googling, but to no avail.. what does it mean? :)
15:27:24 <kmc> it means GHC detected an infinite loop and aborted
15:27:29 <behelit> ah
15:27:31 <kmc> also print = putStrLn . show
15:27:36 <obiwahn> what interpreter is lambdabot?
15:27:43 <behelit> great pointer. thanks.
15:27:43 <dmwit> ghci
15:27:49 <dmwit> hint
15:27:50 <dmwit> I mean
15:27:52 <kmc> behelit, you probably have a typo like ¬´let x = f x¬ª instead of ¬´let y = f x¬ª
15:27:55 <dmwit> or maybe mueval
15:27:56 <dmwit> crap
15:28:01 <kmc> ¬´let x = f x¬ª could be valid in some cases, but would cause a loop in others
15:28:03 <dmwit> I just obviously have no idea.
15:28:07 <Jafet> > sum [0..]
15:28:12 <kmc> obiwahn, mueval
15:28:17 <kmc> which uses hint, which uses ghc api
15:28:22 <lambdabot>   thread killed
15:28:25 <kmc> > fix id
15:28:31 <lambdabot>   mueval-core: Time limit exceeded
15:28:33 <behelit> kmc: sure did.. a _ solved it in the let statement. thanks :)
15:29:03 <kmc> > foldl' (+) 0 [0..]
15:29:07 <lambdabot>   mueval-core: Time limit exceeded
15:29:12 <kmc> > foldl (+) 0 [0..]
15:29:30 <lambdabot>   thread killed
15:35:20 <Cale> > groupBy (>=) [3,1,5,3,6,8,6,5]
15:35:24 <lambdabot>   [[3,1],[5,3],[6],[8,6,5]]
15:35:55 <Cale> > map head . groupBy (>=) $ [3,1,5,3,6,8,6,5]
15:35:59 <lambdabot>   mueval-core: Time limit exceeded
15:36:03 <Cale> whaaat
15:36:07 <benmachine> > groupBy [17,2,1,2,3]
15:36:07 <lambdabot>   Couldn't match expected type `a -> a -> GHC.Bool.Bool'
15:36:08 <lambdabot>         against infe...
15:36:08 <benmachine> er wups
15:36:12 <benmachine> > groupBy (>=) [17,2,1,2,3]
15:36:13 <lambdabot>   [[17,2,1,2,3]]
15:36:55 <Cale> > map head . groupBy (>=) $ [3,1,5,3,6,8,6,5]
15:36:57 <lambdabot>   [3,5,6,8]
15:37:14 <Cale> Doesn't look like there are any runaway processes on lambdabot's server.
15:37:20 <Cale> hrm, maybe just random slowness
15:37:35 <Cale> > scanl1 max $ [3,1,5,3,6,8,6,5]
15:37:36 <lambdabot>   [3,3,5,5,6,8,8,8]
15:37:43 <Cale> > group . scanl1 max $ [3,1,5,3,6,8,6,5]
15:37:45 <lambdabot>   [[3,3],[5,5],[6],[8,8,8]]
15:37:49 <Cale> > map head . group . scanl1 max $ [3,1,5,3,6,8,6,5]
15:37:50 <lambdabot>   [3,5,6,8]
15:38:28 <dmwit> > nub . scanl1 max $ [3,1,5,3,6,8,6,5]
15:38:28 <benmachine> Cale: what exactly is your aim here
15:38:30 <lambdabot>   [3,5,6,8]
15:38:59 <Cale> benmachine: Not much
15:39:10 <benmachine> oh, that's allowed :)
15:39:17 <Cale> I responded to someone on reddit for which this was a possible solution to their problem.
15:39:22 <Cale> http://www.reddit.com/r/haskell/comments/k8329/haskell_beginner_needs_some_help/
15:40:07 <Jafet> Looks like a sorting subroutine
15:40:08 <Cale> Oh yeah, nubBy too :)
15:40:09 <ciaranm> > let split (x:y:zs) = let (xs, ys) = split zs in (x:xs, y:ys) ; split x = (x, []) in split [1..10]
15:40:11 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
15:40:11 <dmwit> Cale: But that doesn't solve the problem as stated, the way I'm reading it.
15:40:19 <ciaranm> > let split (x:y:zs) = (x:xs, y:ys) where (xs, ys) = split zs ; split x = (x, []) in split [1..10]
15:40:20 <lambdabot>   ([1,3,4,5,6,7,8,9,10],[2])
15:40:23 <ciaranm> please explain
15:40:31 <Cale> dmwit: I also solved another possibility. It was a little ambiguous.
15:40:54 <dmwit> ciaranm: The second split clause is in the where block, not the let block.
15:41:02 <Jafet> By the way, that split is worse because it isn't stable
15:41:13 <dmwit> Jafet: eh?
15:41:14 <Jafet> splitAt (length xs `div` 2) xs is better
15:41:29 <dmwit> hm
15:41:30 <Cale> wha?
15:41:33 <obiwahn> When i look a the definition of foldl i uses the constant to combine it with the element of the list. but then it used for the empty list (list end) as well?!
15:41:34 <Cale> That doesn't do the same thing
15:41:57 <Jafet> Wait, we're writing kmc's mergesort slide for him, aren't we?
15:42:02 <dmwit> obiwahn: No, the constant isn't combined with list elements.
15:42:11 <obiwahn> sorry -- When i look a the definition of foldl it uses the constant to combine it with first the element of the list. But then it used for the empty list (list end) as well?!
15:42:16 <Cale> > foldl f z [1,2,3,4]
15:42:17 <lambdabot>   f (f (f (f z 1) 2) 3) 4
15:42:18 <dmwit> ?src foldl
15:42:19 <lambdabot> foldl f z []     = z
15:42:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:42:40 <dmwit> obiwahn: Read again. The constant isn't constant.
15:42:45 <Cale> > foldl (+) z [1,2,3,4]
15:42:46 <lambdabot>   z + 1 + 2 + 3 + 4
15:42:47 <dmwit> It changes as you get deeper in the list. =)
15:42:49 <Cale> bah
15:43:01 <Cale> (I want my brackets! :)
15:43:51 <Cale> > foldl (\xs x -> concat ["(f ",xs," ",show x,")"]) "z" [1,2,3,4]
15:43:52 <lambdabot>   "(f (f (f (f z 1) 2) 3) 4)"
15:43:58 <dafis> > foldl (/) z [1,2,3,4]
15:44:00 <lambdabot>   z / 1 / 2 / 3 / 4
15:44:03 <dmwit> Jafet: Well, my split isn't stable, but it's lazy. =)
15:44:08 <Cale> > foldl (\xs x -> concat ["(",xs,"+",show x,")"]) "0" [1,2,3,4]
15:44:09 <lambdabot>   "((((0+1)+2)+3)+4)"
15:44:10 <dafis> > foldl (^) z [1,2,3,4]
15:44:11 <lambdabot>   z * z * (z * z) * (z * z) * (z * z * (z * z) * (z * z)) * (z * z * (z * z) ...
15:45:29 <Cale> > let firstHalf xs = zip xs (takeWhile (not . null) . iterate (drop 2) $ xs) in firstHalf [1..10]
15:45:31 <obiwahn> true but when is -- foldl f z []     = z needed?
15:45:31 <lambdabot>   [(1,[1,2,3,4,5,6,7,8,9,10]),(2,[3,4,5,6,7,8,9,10]),(3,[5,6,7,8,9,10]),(4,[7...
15:45:38 <Cale> > let firstHalf xs = zipWith const xs (takeWhile (not . null) . iterate (drop 2) $ xs) in firstHalf [1..10]
15:45:40 <lambdabot>   [1,2,3,4,5]
15:45:43 <Cale> > let firstHalf xs = zipWith const xs (takeWhile (not . null) . iterate (drop 2) $ xs) in firstHalf [1..]
15:45:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:45:50 <shachaf> preflex: seen Lemmih
15:45:50 <preflex>  Lemmih was last seen on #haskell 8 hours, 54 minutes and 59 seconds ago, saying: Oops, Sorry.
15:46:24 <Cale> obiwahn: In the empty list case.
15:46:25 <dmwit> obiwahn: When the list is empty, of course!
15:46:31 <Cale> Let's evaluate:
15:46:36 <Cale> @src foldl
15:46:36 <lambdabot> foldl f z []     = z
15:46:37 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:46:43 <Cale> foldl (+) 0 [1,2,3]
15:46:50 <Cale> -> foldl (+) (0+1) [2,3]
15:46:57 <Cale> -> foldl (+) ((0+1)+2) [3]
15:47:03 <Cale> -> foldl (+) (((0+1)+2)+3) []
15:47:08 <Cale> -> ((0+1)+2)+3
15:47:15 <Cale> -> (1+2)+3
15:47:17 <Cale> -> 3+3
15:47:19 <Cale> -> 6
15:47:34 <Cale> (that is pretty much exactly what happens)
15:48:14 <benmachine> see also http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=foldl+(%2B)+0+[1%2C2%2C3]
15:48:29 <obiwahn> ok :) got it!! that took far too long i should go to bed:) thank you so much!!
15:50:02 <Cale> benmachine: It's weird and interesting that it displays (+) ((+) ((+) 0 1) 2) 3 and then evaluates that to 1 + 2 + 3
15:50:11 <obiwahn> good night -.-
15:50:13 <Cale> SUDDENLY INFIX
15:50:20 <Cale> g'night
15:50:27 <benmachine> Cale: yeah, it's another weird artifact of the way I do things
15:50:48 <benmachine> basically the definition for foldl tells it to produce f z x
15:50:53 <benmachine> so it produces (+) 0 1
15:50:59 <dmwit> Why does chromium screw up the clipboard so badly?
15:51:01 <Cale> right
15:51:03 <benmachine> but when it's evaluating that it infixes it as a side-effect
15:51:11 <Cale> But then the definition for (+)... okay
15:51:22 <benmachine> no it infixes it just because it's a symbol
15:51:22 <Jafet> Haskell is terrible for writing its own partial evaluations
15:51:43 <benmachine> because remembering exactly which application style was used is a pain
15:51:51 <benmachine> possibly I could fix that but
15:52:01 <benmachine> I think stepeval is due an axing and re-build
15:52:20 <benmachine> possibly by someone who isn't so much a noob >_>
15:52:23 <roconnor> @hoogle StoreT
15:52:24 <lambdabot> No results found
15:52:26 <dmwit> autocale.org
15:52:47 <Jafet> calebot
15:53:23 <dmwit> Do any of the interpreters on Hackage support an (non-time-based) "evaluation fuel" like GHC's optimization fuel?
15:54:00 <dmwit> "Do at most 10,000 reduction steps, then stop whether you're done or not."
15:54:18 <copumpkin> I don't think so
15:54:23 <Jafet> Why not just hook ghci
15:54:45 <Jafet> By hook I mean write a 5000 line expect script
15:55:00 <dmwit> Does ghci offer reduction fuel?
15:55:07 <monochrom> ghci debugger may be exploited for this if you set breakpoints at everywhere
15:55:16 <dmwit> neat!
15:55:42 <roconnor> @djinn (s -> a, s) -> (s -> (s -> a, s), s)
15:55:43 <lambdabot> f (a, b) = (\ c -> (\ _ -> a b, c), b)
15:55:53 <Jafet> As a benefit, you don't need to write your own buggy implementation of half of system F
15:56:02 <roconnor> @dijnn+
15:56:03 <lambdabot> Unknown command, try @list
15:56:05 <Jafet> You can just use ghc's buggy implementation of half of system F
15:56:24 <monochrom> haha
15:57:49 <dainanaki> is it "safe" to do an unsafe cast from a newtype-wrapped value to the internal type?
15:58:21 <monochrom> should be, but I wouldn't do it
15:58:36 <benmachine> dainanaki: yes, on GHC, until they feel like breaking it :P
15:58:47 <dainanaki> I'm just asking out of curiosity.
15:58:57 <kmc> dainanaki, that is one of the few documented safe cases of unsafeCoerce
15:59:16 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#v:unsafeCoerce-35-
16:00:12 <kmc> heh, that's a fun trivial question
16:00:38 <dainanaki> while I'm at it, what does GHC do when you fmap a newtype constructor over a functor?
16:00:45 <dainanaki> Does it rewrite the map out too?
16:00:59 <kmc> "name a boxed GHC type which is neither a function type nor an alegbraic data type"
16:01:18 <dafis> GHC.Any
16:01:21 <kmc> yep
16:01:23 <copumpkin> dainanaki: no
16:01:34 <kmc> btw, is there any difference between "lifted" and "boxed" in GHC usage?
16:01:42 <copumpkin> kmc: yes
16:01:47 <Jafet> That rewrite rule sounds safe to add
16:01:49 <kmc> dainanaki, i'd expect it to do that only if it resolves the type class at compile time, and then inlines into fmap
16:01:52 <kmc> i.e. not very likely
16:01:59 <copumpkin> djahandarie should add that to his newtype package
16:02:02 <Jafet> Assuming you could type it
16:02:05 <kmc> what's the difference copumpkin?
16:02:17 <dainanaki> so, it is fair to say that it's not an entirely free datatype then?
16:02:31 <benmachine> newtypes can prevent some optimisations, yes
16:02:35 <copumpkin> kmc: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
16:02:39 <copumpkin> right at the top there
16:03:15 <Cale> grr, why is nubBy still buggy?
16:03:16 <kmc> ah.  that would seem to suggest the docs around unsafeCoerce# should say "boxed" instead of "lifted"
16:03:21 <kmc> which is kind of what i thought before i read them
16:03:27 <kmc> but maybe i am still missing something
16:03:42 <copumpkin> kmc: yeah, I don't think the usage is terribly consistent
16:04:20 <kmc> :(
16:04:22 <Cale> @let nubBy' f [] = []; nubBy' f (x:xs) = x : filter (not . f x) (nubBy' f xs) -- the obvious implementation, applies the comparison to the elements of the list in the order in which they occur in the list
16:04:24 <lambdabot>  Defined.
16:04:30 <djahandarie> What am I adding copumpkin?
16:04:38 <kmc> terminology evolves and people don't bother to update old documents
16:04:42 <Cale> > nubBy (>=) [3,1,5,3,6,8,6,5]
16:04:43 <lambdabot>   [3,1]
16:04:47 <Cale> > nubBy' (>=) [3,1,5,3,6,8,6,5]
16:04:49 <lambdabot>   [3,5,6,8]
16:04:58 <Cale> ^^ annoying as fuck
16:05:07 <Cale> > nubBy (<=) [3,1,5,3,6,8,6,5]
16:05:08 <lambdabot>   [3,5,6,8]
16:05:11 <copumpkin> djahandarie: a rewrite rule for fmapping the newtype constructor or destructor over something
16:05:11 <kmc> "Template Haskell quasi-quote" is an annoying example
16:05:18 <kmc> also "type" vs "type constructor"
16:05:23 <Cale> They flipped the arguments to the comparison function.
16:05:31 <kmc> and "type family" to mean one or both of "type synonym family" and "data family"
16:05:53 <kmc> copumpkin, rewriting to unsafeCoerce?
16:06:20 <kmc> seems like this could cause segfaults on Functor instances which violate the functor laws, even internally
16:06:25 <kmc> or which do other tricky things
16:06:27 <shachaf> @quote Jafet unsafeCoerce
16:06:28 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
16:06:35 <kmc> haha
16:06:35 <copumpkin> kmc: fair enough
16:06:49 <roconnor> damn, I cannot use the variable f for both "field" and "functor"
16:06:50 <monochrom> oh w00t, heap objects have or have not an extra profiling field depending on whether profiling is turned on. no wonder profiling code and non-profiling code don't mix
16:06:51 <djahandarie> copumpkin, hmmm, why wouldn't that already be optimized away? I guess it depends if there is a fmap id rewrite rule and if it runs late enough for the newtype optimization to happen first... probably not
16:06:58 <Jafet> @quote benmachine unsafeCoerce
16:06:59 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
16:07:28 <djahandarie> Functor breaks pretty bad if you don't follow the functor laws, doesn't it?
16:07:30 <kmc> the unsafeCoerce# docs are careful *not* to say that you can, for example, coerce a [S] to [T] if you're allowed to coerce [S] to [T]
16:07:33 * benmachine giggles at Jafet's quote
16:07:38 <kmc> they only guarantee that when you know the list is empty
16:07:43 <kmc> in which case the type parameter is phanto
16:08:06 <djahandarie> By the way, I'm curious of unsafeCoercing Refls is 'safe'. I was doing it and it didn't seem to break anything
16:08:22 <kmc> Refl meaning equality evidence?
16:08:26 <djahandarie> Yeah
16:08:30 <copumpkin> djahandarie: only safe if the types are equal :P
16:08:34 <shachaf> kmc: You can't coerce [S] to [T] if you can coerce [S] to to [T]?
16:08:37 <kmc> depends on what you cast it to ;P
16:08:39 <djahandarie> Nah, types were not equal
16:08:44 <kmc> heh
16:08:46 <djahandarie> Same type constructor obviously
16:08:48 <kmc> i meant S to T
16:09:04 <kmc> obviously?
16:09:07 * kmc is confused
16:09:18 <copumpkin> djahandarie: then no
16:09:36 <djahandarie> data (:=:) a b where Refl :: a :=: a
16:09:37 <kmc> Refl :: Equal (Ptr Double) (Ptr Int)  -- like this?
16:09:46 <djahandarie> Right
16:10:05 <djahandarie> And given a certain type of Refl, I unsafeCoerced it to something else
16:10:11 <copumpkin> the actual unsafeCoercing isn't unsafe
16:10:12 <djahandarie> Using meta properties that I couldn't prove
16:10:14 <kmc> i'm dubious of that
16:10:16 <copumpkin> since Refl doesn't really contain anything
16:10:21 <djahandarie> Right
16:10:21 <copumpkin> but what you can do with it later is bad
16:10:25 <djahandarie> Hmm?
16:10:37 <copumpkin> it's effectively giving you a free ticket to unsafeCoerce anything else
16:10:42 <djahandarie> How?
16:10:47 <copumpkin> I can write a :=: b -> a -> b
16:11:06 <copumpkin> in plain ol' haskell
16:11:14 <copumpkin> if you're passing around an evil :=: that's a lie
16:11:15 <kmc> plain ol' GHC Haskell with GADTs ;)
16:11:25 <copumpkin> that's my definition of plain ol' haskell
16:11:28 <roconnor> data Pumpkin b = Pumpkin (b -> Pumpkin -> b)
16:11:31 <kmc> well, it would be okay in that Ptr case
16:11:37 <kmc> maybe
16:11:38 * roconnor isn't sure what :=: is
16:11:39 <kmc> i'm still not convinced
16:11:43 <copumpkin> well, you can already castPtr
16:12:05 <roconnor> oh
16:12:09 <kmc> can you write (f a :=: f b) -> (a :=: b)
16:12:11 * roconnor reads the scrollback
16:12:15 <kmc> then we're in trouble
16:12:25 <kmc> congruence?
16:12:34 <djahandarie> copumpkin, but the types ARE equal, I know they are. Obviously I'm saying 'trust me' when I'm unsafeCoercing
16:12:35 <copumpkin> kmc: for specific Fs, you mgiht be able to
16:12:40 <copumpkin> djahandarie: oh, sure
16:12:45 <copumpkin> that's what unsafeCoerce is for :P
16:12:49 <djahandarie> Right.
16:13:13 <djahandarie> I mean the types in the :=: constructor that is
16:13:14 <roconnor> this is the only safe use of unsafeCoerce that I'm aware of
16:13:15 <copumpkin> for you unsafeCoerce just means "I couldn't be bothered to write a proof here, but it's true anyway"
16:13:22 <djahandarie> Gah
16:13:33 <djahandarie> Annoying that there are multiple type equalities floating around in this discussion :P
16:13:46 <roconnor> to cast two different polymorphic type variables to each other that you swear are the same.
16:13:50 <Clint> what does "native" mean in aeson-native and blaze-textual-native?
16:14:36 <djahandarie> copumpkin, it's the weird 'closed' hack I did for the stuff earlier
16:14:52 <copumpkin> ?
16:15:07 <djahandarie> Hold on
16:15:19 * copumpkin holds on
16:15:28 <kmc> STAND BY FOR TRANSMISSION
16:15:30 * benmachine holds copumpkin 
16:15:36 <roconnor> what comes after triple, double, single?
16:15:40 <kmc> nurple
16:15:42 <copumpkin> quadruple
16:15:45 <copumpkin> oh
16:15:46 <ciaranm> unitary
16:15:49 <djahandarie> Well, I need to find where I put this file...
16:15:57 <copumpkin> zerble
16:16:01 <ARRG> (does it make sense to say that getLine is blocking and getContents isn't ?)
16:16:08 <djahandarie> Aha
16:16:10 <dafis> noble
16:16:27 <djahandarie> Ah crud, I didn't save it in the file. Damn. I'll just write it again
16:16:33 <shachaf> ARRG: getContents does lazy IO, which is evil and probably shouldn't be classified as "non-blocking".
16:16:51 <copumpkin> SIGPWNT? :P
16:17:06 <ARRG> evil as in "don't use it there are better ways" ?
16:17:21 <monochrom> triple trouble, double trouble, single trouble, no trouble
16:17:30 <copumpkin> evil as in "don't use it and there are other, kind of shitty but not terrible ways"
16:17:37 <hpaste> kmc pasted ‚Äúnot so phantom anymore (copumpkin, djahandarie)‚Äù at http://hpaste.org/51074
16:18:16 <benmachine> I thought cong was the other way around
16:18:22 <kmc> maybe
16:18:25 <kmc> what should i call it?
16:18:33 <benmachine> ...gnoc? :P
16:18:42 * benmachine doesn't know things
16:18:48 <copumpkin> inj
16:18:56 <ARRG> shachaf + copumpkin > Okay thank you
16:18:56 <copumpkin> that just means f is injective
16:18:56 <copumpkin> which it isn't, here
16:19:05 <djahandarie> kmc, heh
16:19:10 <kmc> it goes through, though
16:19:17 <shachaf> ARRG: No, evil as in "use it, but hush hush".
16:19:18 <kmc> hmm, type synonym families aren't injective...
16:19:32 <copumpkin> kmc: but they can't be partially applied, either
16:19:34 <benmachine> evil as in "don't necessarily expect the usual rules to apply"
16:19:42 <kmc> they woludn't be
16:20:00 <copumpkin> oh, fair enough
16:20:04 <copumpkin> prove false!
16:20:14 <kmc> one sec
16:20:32 <copumpkin> I bet it won't be as elegant as the latest proof of false in agda
16:20:46 * roconnor notices that StoreT b (Store b) a is conviently iso to Store (b,b) a
16:21:01 <copumpkin> roconnor: it's a sign!
16:21:22 <roconnor> A store sign?
16:21:31 <copumpkin> yeah
16:21:37 <copumpkin> it says "cheap cigarettes sold here"
16:21:40 <roconnor> copumpkin: actually it is a sign to remove talking about StoreT from my talk.
16:21:49 <copumpkin> oh, that too
16:22:06 <benmachine> copumpkin: Refl :: Const a Float :=: Const a Int didn't typecheck when I just tried it
16:22:22 <copumpkin> benmachine: I wouldn't expect it to
16:22:49 <copumpkin> kmc: I think it won't work, actually
16:23:00 <benmachine> then type families are sort-of-injective?
16:23:31 <copumpkin> kmc: also, they fixed it
16:23:37 <copumpkin>     Could not deduce (a ~ b)
16:23:37 <copumpkin>     from the context (f a ~ f b)
16:23:40 <copumpkin> in 7.2.1
16:23:43 <kmc> haha
16:23:54 <kmc> i see i'm behind the times
16:23:57 <kmc> so why exactly isn't it working?
16:24:01 * copumpkin shakes his head
16:24:09 <copumpkin> kmc: because there's no guarantee that f is always injective
16:24:11 <kmc> "Expected type: f0 Int :=: f0 Bool  Actual type: F Int :=: F Bool"
16:24:14 <copumpkin> oh
16:24:42 <copumpkin> kmc: it's secretly partially applied
16:24:48 <copumpkin> it may get fully applied
16:24:54 <kmc> buh
16:24:57 <copumpkin> but f (should be) unified with a partially applied type function
16:24:59 <copumpkin> which it can't see
16:25:21 <copumpkin> nor do I blame it
16:25:49 <copumpkin> man, I wish I weren't feeling so lethargic
16:25:53 <copumpkin> I want to code
16:26:15 <kmc> i don't see where the synonym family is partially applied
16:26:45 <hpaste> kmc pasted ‚Äúnot quite false‚Äù at http://hpaste.org/51075
16:27:01 <roconnor> type (f :+: g) a = Either (f a) (g a) -- is this legal?
16:27:23 <copumpkin> kmc: it needs to unify F Int with f a
16:27:29 <copumpkin> which would mean unifying f with F and Int with a
16:27:37 <kmc> roconnor, with -XTypeOperators, yes
16:27:53 <kmc> i see
16:27:55 <roconnor> kmc: how about
16:28:04 <roconnor> data (f :+: g) a = Sum (f a) (g a)
16:28:09 <roconnor> er
16:28:12 <kmc> copumpkin, and unification fails when it notices F is a partially-applied type family
16:28:18 <roconnor> data (f :+: g) a = Inl (f a) | Inr (g a)
16:28:21 <kmc> whereas it went through with Ptr because Ptr is a first-class type constructor
16:28:34 <kmc> roconnor, sure, why not?
16:28:41 <copumpkin> yeah, or more concretely, it probably just fails because it treats F Int as indistinguishable from Bool, so it doesn't even think they unify, maybe
16:28:45 <djahandarie> kmc, turn on... hmmm
16:28:47 <copumpkin> not sure specifically where they convert
16:28:49 <djahandarie> What's that extension
16:28:51 <roconnor> kmc: I can never remember the rules for : things
16:28:52 <benmachine> roconnor: the time it takes to tell you that yes, it does work, is about the same as the time it takes to write it down and load it into ghci :P
16:28:54 <kmc> -XProveFalse
16:28:57 <djahandarie> FlexibleTypeSynonyms? Or something like that
16:29:00 <djahandarie> One sec
16:29:11 <roconnor> benmachine: oh good point
16:29:16 <djahandarie> Aha, LiberalTypeSynonyms
16:29:36 <ciaranm> don't tell fox news
16:29:38 <djahandarie> Speaking of liberaltypesynonyms I think I imagine to find a way to have a full type lambda
16:29:49 <kmc> no luck djahandarie
16:29:58 <copumpkin> that doesn't give you a full type lambda
16:30:02 <copumpkin> it just expands first
16:30:08 <djahandarie> I know it isn't supposed to
16:30:09 <copumpkin> and then bitches if it needs to bitch
16:30:12 <kmc> what do we want? dependent types!
16:30:22 <djahandarie> But I think it does with ImpredicativeTypes
16:30:24 * copumpkin beckons towards the agda channel
16:30:47 <djahandarie> But GHC's ImpredicativeTypes is so fucked up it isn't even worth trying
16:30:50 <copumpkin> djahandarie: how so?
16:30:58 <djahandarie> I don't remember :P
16:31:03 <djahandarie> I had it awhile back when I was working on this stuff
16:31:16 <copumpkin> hmm
16:31:25 <djahandarie> Too busy right now to try and figure it out again
16:31:27 <ciaranm> somehow i imagine LiberalTypeSynonyms as defining Marriage to be (Either Man Woman, Either Man Woman)
16:31:49 <benmachine> ciaranm: pfft, you and your binary genders
16:32:05 <ddarius> Type lambdas are orthogonal to dependent types.
16:32:16 <ddarius> Or I should say type level lambdas.
16:33:27 <kmc> three orthogonal things make a cube :)
16:34:18 <ddarius> The third being what "type lambdas" means.
16:35:13 <Cale> lambda cube -> poset -> category
16:35:30 <djahandarie> -> higher category ?
16:36:10 <Cale> :)
16:39:19 <hpaste> gabor pasted ‚ÄúFeasible?‚Äù at http://hpaste.org/51076
16:40:14 <gabor> aagr, should be "to do with" (I am too sleepy)
16:41:29 <Cale> gabor: foo.hs:2:3:
16:41:30 <Cale>     Type declaration in a class must be a kind signature or synonym default:
16:41:30 <Cale>     type instance Final a = a
16:41:40 <Cale> (on 7.0.3)
16:42:14 <gabor> okay, what's the difference?
16:43:07 <gabor> will that compile something like "foo ord" ??
16:44:25 <gabor> Cale: I am very doubtful of the recursive call to Final at the bottom
16:44:42 <copumpkin> gabor: that's fine
16:44:44 <gabor> (line 11)
16:44:55 <copumpkin> I don't think associated type defaults work though
16:45:01 <copumpkin> at least not like that
16:45:19 <krey_> o/, I want to use a (mutable) set of references, how does one combine ST and State sensibly?
16:46:19 <Cale> okay, when I fix it to not use the default...
16:46:47 <gabor> copumpkin: it won't kill me to add a "Final" definition in each ground instance, but it surely would be nicer with defaulting :-)
16:46:49 <hpaste> Cale pasted ‚ÄúTF‚Äù at http://hpaste.org/51077
16:47:00 <Cale> which is absolutely right.
16:47:46 <copumpkin> gabor: you want a recursive call there
16:47:52 <copumpkin> foo on = foo (on undefined)
16:47:55 <copumpkin> or something like that
16:48:00 <hpaste> Cale annotated ‚ÄúTF‚Äù with ‚ÄúTF (annotation)‚Äù at http://hpaste.org/51077#a51078
16:48:07 <copumpkin> assuming your goal is to apply the function to undefined enough times to get an Int out of it
16:48:09 <Cale> yes
16:48:50 <Cale> Well, there aren't many other ways to satisfy the type constraints :)
16:48:54 <gabor> yah, foo $ on undefined seems good
16:49:01 <Cale> Unless you also know something about d
16:49:18 <krey_> please, ST + State someone?
16:49:19 <gabor> so does that compile?
16:49:27 <copumpkin> krey_: StateT ST?
16:49:35 <dafis> krey_: StateT s ST ?
16:49:36 <Cale> krey_: One doesn't combine ST and State
16:49:48 <Cale> StateT over ST is silly
16:49:54 <Cale> (though possible)
16:50:06 <copumpkin> not if you have generic functions that expect a State-like thingy
16:50:07 <dafis> Cale: why is it silly?
16:50:20 <krey_> Cale: so how do I solve my problem (having a mutable set of refs)
16:50:24 <Cale> ST gives you unbounded amounts of mutable state already
16:50:35 <copumpkin> Cale: what if you want a distinguished piece of it? :)
16:50:35 <Cale> Adding one more mutable state variable doesn't really change much.
16:50:57 <benmachine> ReaderT STVar?
16:51:01 <benmachine> er, TVar
16:51:04 <benmachine> or whatever
16:51:10 <benmachine> I forget which is which :<
16:51:12 <Cale> krey_: You can very well have a  STRef s (Set (STRef s a))
16:51:33 <benmachine> Cale: STRefs are orderable?
16:51:36 <benmachine> no they are not
16:51:39 <Cale> er, okay, right
16:51:43 <Cale> Map :)
16:51:50 <benmachine> ...map from what? :P
16:51:52 <krey_> benmachine: good point
16:51:54 <Cale> Integer?
16:52:00 <benmachine> ok fair enough
16:52:01 <hpaste> gabor annotated ‚ÄúTF‚Äù with ‚ÄúTF (annotation)‚Äù at http://hpaste.org/51077#a51079
16:52:05 <dafis> Int should suffice
16:52:12 <Cale> Int is ugly
16:52:32 <Cale> (but yes, it should suffice)
16:52:33 <krey_> Cale: I need something fast, or so we all say
16:52:34 <dafis> but efficient
16:52:45 <Cale> krey_: What are you trying to do?
16:52:52 <copumpkin> anyone know what voodoo foreignptrs use to let the runtime call the finalizer?
16:53:38 <Cale> gabor: It's equivalent to mine, which does
16:53:41 <Cale> errr
16:53:51 <Cale> oh, I see
16:54:13 <krey_> Cale: well, this is kind of silly, but I'm using haskell to do a massive search (to win a game with a quite a bit of branching), and there's a fair bit of state involved in my solution. or maybe I just can't think functionally
16:54:19 <Cale> gabor: yes
16:54:34 <gabor> great! thanks Cale! The proof is in the pudding!
16:54:43 <Cale> krey_: okay
16:55:01 <Cale> krey_: Well, a game tree sounds pretty damn immutable
16:55:16 <Cale> krey_: so what's wrong with just defining the whole game tree?
16:56:30 <Cale> Or, start out with  moves :: Position -> [Position]
16:56:44 <ddarius> gabor: That's a sticky proof.
16:57:16 <gabor> ddarius: much better than an error message :-)
16:57:58 <Cale> krey_: But perhaps you can tell me more about what the game is like
16:58:10 <Cale> There might be a good reason for introducing mutable state
16:58:15 <krey_> Cale: well, when you generate the set of "next moves", if there are several moves that lead to the same state, say k, then the payoff is "proportional" to k
16:58:45 <Cale> okay
16:59:13 <Cale> So we want to be able to compare the positions (and for efficiency, probably be able to order them as well)
17:00:21 <Cale> So that we can do something like  snd . maximumBy (comparing fst) . map (length &&& head) . group . sort . moves
17:00:59 <krey_> Cale: so the way I solved it (imperatively) was to have two "sets": one for all moves, and one for the reduced set of moves. I'd iterate through the set of all moves, and create a pointer for each move to the corresponding move in the reduced set
17:01:00 <Cale> To choose the position which has the most possible ways of arriving at it
17:02:34 <krey_> Cale: pointers -> STRef, building up the reduced set -> State (Set Move)
17:02:51 <Cale> Tell me more about the rules of this game
17:03:30 <krey_> Cale: sure
17:03:35 <Cale> (does the code I just wrote seem sensible?)
17:04:02 <ddarius> @hackage equivalence\
17:04:03 <lambdabot> http://hackage.haskell.org/package/equivalence\
17:04:06 <ddarius> @hackage equivalence
17:04:07 <lambdabot> http://hackage.haskell.org/package/equivalence
17:04:55 <krey_> Cale: well, I scanned through it, I don't think I know what most of it means, but it involves sorting, which I don't need at this point
17:05:03 <krey_> Cale: but let me tell you about the game
17:05:41 <Cale> Well, we take the list of moves from a position (as a list of new positions), and then collect those up by equality to determine which one occurred the most times, and return that.
17:06:24 <krey_> Cale: oh, I see! almost like a database query!
17:07:01 <krey_> Cale: I assume it uses Eq, which is a problem! Eq isn't O(1) unfortunately...
17:08:55 <insane> What is the correct approach to perform lazy output(printing to terminal) inside function that has a signarure: ... -> Get a
17:09:12 <insane> where Get is Data.Binary.Get
17:09:15 <shachaf> insane: The correct approach is to not do it.
17:09:30 <insane> shachaf: ok...
17:09:32 <shachaf> insane: You can return Get (a,String) and then have whatever called Get print that String.
17:09:37 <shachaf> Or something of the sort.
17:11:44 <krey_> Cale: this is the game http://i.imgur.com/MHVYx.png
17:12:35 <krey_> Cale: clicking a group of identically coloured balls causes them to explode and they are removed
17:12:55 <insane> shachaf: yup, but using that approach i will have to built the whole String in memory
17:13:13 <insane> shachaf: which I don't want to do because it might be bigger that memory available
17:13:15 <krey_> Cale: the empty spaces will be filled by balls falling down from on top of the ones that have exploded
17:13:35 <shachaf> insane: Well, it'd be lazy, wouldn't it?
17:14:06 <insane> shachaf: yes you're right
17:14:12 <insane> shachaf: thanks
17:14:57 <shachaf> insane: If it's really big a String might not be optimal, though.
17:15:08 <shachaf> You can always use Text or ByteString or some such.
17:21:45 <Cale> krey_: ah, okay
17:22:12 <Cale> krey_: Yeah, so something like the code I wrote ought to work
17:22:31 <Cale> krey_: though you might find it better just to compute the score of a move as you compute the result of it
17:22:46 <Cale> But yeah, shouldn't require any mutation
17:23:07 <Cale> You could represent a board as a Map (Integer, Integer) Colour
17:23:34 <krey_> Cale: well, I would like to have a complete list/set of moves at some point for heuristics/pruning
17:24:25 <krey_> Cale: also, does Map (Int, Int) beat IArray?
17:24:55 * ddarius thinks the board should be represented by a covector in a module.
17:26:37 <copumpkin> krey_: beat for what?
17:28:32 <Jafet> Beat with what?
17:29:14 <krey_> copumpkin, Jafet: dunno, it doesn't matter
17:29:20 <copumpkin> I mean
17:29:26 * hackagebot Crypto 4.2.4 - Collects together existing Haskell cryptographic functions into a package  http://hackage.haskell.org/package/Crypto-4.2.4 (CreightonHogg)
17:29:29 <copumpkin> you asked a question :P it's not well defined
17:29:40 <copumpkin> unless you give us a context for the question
17:31:36 <krey_> copumpkin: well, I don't even really know what I'm doing now (apart from throwing away all of my mutation infected code), i'm kinda waiting for Cale to shed light on the proper (ie. haskell) way of doing this
17:33:21 <Jafet> Hmm, IArray isn't exactly known for mutation infection
17:33:30 <Jafet> I'm not an expert on the pathology, of course
17:35:00 <sshc> Hah.  he one time I decide to use 'Int' instead of 'Integer', it turns out to be, once again, a premature optimization when I least expected it.
17:36:01 <Jafet> The problem with defining the game tree as a big data structure is that you can't forget parts of it later
17:37:55 <krey_> Jafet: well I wasn't going to hold on the tree itself, just do a DFS
17:38:21 <Jafet> Holding on to parts of the tree provides many optimizations.
17:39:11 <krey_> Jafet: I'm listening
17:39:22 <Jafet> Don't! I'm just rambling.
17:39:45 <Jafet> The computer chess has too much literature on searching game trees, if you want.
17:40:50 <ddarius> Jafet: There's no reason you couldn't forget parts of it later.
17:41:26 <elliott> it's called garbage collection :P
17:41:44 <benmachine> you need to define your algorithm sufficiently cleverly that the GC can tell when you're done with stuff, perhaps
17:41:50 <Jafet> Well, you can rebuild the tree leaving out those parts
17:42:06 <elliott> Jafet: you can also just descend in
17:42:08 <benmachine> I don't think that's what you want to do
17:42:10 <elliott> and leave no references to the parent
17:42:16 <benmachine> yes, that sounds more sensible
17:42:19 <elliott> thus making the rest of the tree garbage
17:42:30 <krey_> can someone help with the big picture, please (ie. representing data)
17:42:33 <BobFunk> what's the best way to get the haskell platform running on ubuntu?
17:42:34 <elliott> and if you never descend in, there's not much garbage to collect
17:42:42 <BobFunk> installed the haskell platform apt-get pakcage
17:42:49 <BobFunk> but it gave me ghc 6
17:42:53 <elliott> (because they'll be thunks)
17:42:53 <BobFunk> and would like 7
17:43:09 <Jafet> elliott: but if you are exploding one branch of the game tree, the other branch may remain in memory, because both are kept alive by the parent.
17:43:11 <elliott> BobFunk: you'll need to download a ghc binary, install it, download the haskell platform tarball, and compile it
17:43:16 <Jafet> Or exploring.
17:43:39 <dainanaki> How can I do ffi bindings for a variadic c function? c2hs is complaining at me that the ffi doesn't support it, but I'm pretty sure that there's not a reasonable workaround for this case that wouldn't use varargs...
17:43:40 <elliott> Jafet: Well, you can't throw away parts of the tree you're using. Since you'll of course make the tree lazy at every step, the overhead should not be much.
17:44:20 <Jafet> The problem is that most of those parts won't be used any more, even though there are references to them.
17:44:41 <elliott> Well, it seems like premature optimisation to worry about that right away. I doubt the overhead will be that much.
17:44:44 <Jafet> By most, I mean (1-c^d), where d is the depth
17:45:15 <ddarius> You could define the tree with sibling links so that you could discard the parent and traverse the sibling links discarding siblings as you went.
17:45:43 <BobFunk> elliott: ok, will do
17:45:52 <Jafet> Oh, that's interesting.
17:46:20 <elliott> BobFunk: It's fairly painless. Ignore the warnings on the GHC page to go download the Haskell Platform, it doesn't apply when you're compiling yourself (you still need the GHC binary).
17:46:56 <monochrom> the warning is for windows and mac os x
17:46:57 <Jafet> It does entail writing the search in a sort of cps, but that might be cool
17:47:07 <elliott> BobFunk: Oh, and make sure to get an old version of GHC :-)
17:47:16 <elliott> BobFunk: You want 7.0.4.
17:47:22 <elliott> (as opposed to 7.2.1.)
17:47:44 <elliott> Hmm, looks like the latest platform is targeted at 7.0.3, but it shouldn't be a big deal to use 7.0.4.
17:53:46 <BobFunk> got 7.0.3 from the link from the haskell platform
17:53:54 <BobFunk> guess I'll just go with that for now
17:57:21 <krey_> so can anybody give me a hint about datastructures for my search algorithm
17:57:28 <krey_> please?
17:58:24 <Jafet> If you use depth-first or breadth-first search, you won't need any other data structures.
17:59:53 <krey_> Jafet: so how should I get rid of the redundant moves?
18:00:03 <msx> hello. it's my first day learning haskell. is this a good tutorial? http://learnyouahaskell.com/chapters
18:00:19 <elliott> yes
18:01:24 <msx> eliott was that for me?
18:01:31 <kmc> dainanaki, your variadic C function foo() doesn't have a variant "vfoo()" that takes a va_list?
18:01:36 <Jafet> krey: what's a redundant move?
18:02:01 <elliott> msx: yep
18:02:08 <Jafet> Can the ffi even pass a va_list?
18:02:08 <msx> thanks
18:02:10 <elliott> learn you a haskell is pretty much what everyone recommends
18:02:17 <elliott> Real World Haskell is good too but it's better to read LYAH first IMO
18:02:31 <kmc> i recommend reading them both in parallel and seeing which one you like
18:02:33 <krey_> Jafet: did you see the board?
18:02:45 <Jafet> I know the game.
18:02:52 <Jafet> Are you writing a program to play it?
18:02:56 <elliott> kmc: i dunno, i think rwh jumps in a little too quickly to read in tandem immediately
18:02:58 <dainanaki> kmc: nope, the variadic function type is used for callback functions.
18:02:58 <krey_> Jafet: yes!
18:03:17 <kmc> o_O
18:03:17 <Jafet> So what's a redundant move? Every move changes the board, by definition
18:03:22 <dainanaki> kmc: any clever workarounds would be welcome.
18:03:25 <kmc> dainanaki, are you binding libopcodes?
18:03:41 <dainanaki> kmc: Nope, the Obj-C runtime.
18:03:45 <kmc> ugh
18:03:46 <kmc> ok
18:03:52 <kmc> variadic callbacks in C
18:03:52 <krey_> Jafet: yes, but some moves are equivalent, in particular if you have two adjacent yellow balls, clicking either will result in the same move
18:04:32 <kmc> dainanaki, wait, so you're importing a variadic function into Haskell?
18:04:40 <kmc> or importing a function that takes a pointer to a variadic function?
18:04:46 <dainanaki> the latter.
18:04:56 <dainanaki> but c2hs chokes on it.
18:05:11 <dainanaki> or maybe GHC's implementation of the FFI.
18:05:13 <dainanaki> not sure which.
18:05:28 <kmc> oh, then just use a bogus FunPtr type
18:05:40 <kmc> but, where are you going to get this pointer from?
18:06:12 <Jafet> krey: so for every group of balls, decide on one of them to represent the others
18:06:22 <Jafet> Equivalence classes 101
18:06:29 <kmc> dainanaki, do you need to turn a Haskell function into a pointer to a variadic C function?
18:06:35 <dainanaki> Ideally.
18:07:00 <dainanaki> But, i'm in over my head here, so I haven't gotten that far yet.
18:07:48 <krey_> Jafet: lol, i'm a mathematician :)
18:07:50 <kmc> yeah, this sounds like a party
18:08:12 <kmc> lemme think
18:08:42 <krey_> Jafet: I aim to end up having a set/list/priority queue of moves
18:10:32 <ryb> Is there some setup required to use the Riak client beyond the `cabal install`? Do I need some kind of Protocol Buffers dependency?
18:10:44 <ryb> The test in the github repo fails, for instance
18:10:53 <deech> Does Haskell have good language bindings with any of the popular scripting languages?
18:11:04 <Jafet> krey: an easy representative is the first ball that is removed, by coordinates
18:11:15 <Jafet> Another easy representative is the set of balls to be removed
18:12:11 * krey_ is thinking that he might be premature optimising...
18:12:23 <kmc> deech, maybe you should list some popular scripting languages, so we don't end up arguing forever about what a "scripting language" is
18:12:26 <kmc> it's not a term I care for personally
18:12:48 <kmc> also i recommend to go to Hackage and Ctrl-F for the names of these languages
18:13:59 <kmc> dainanaki, ok, so you can create a C stub which is called variadically, and extracts the arguments into some more reasonable format, and then calls Haskell
18:14:03 <kmc> couple problems here
18:14:12 <kmc> one is that the C function needs to know the "protocol" of this variadic call
18:14:24 <kmc> stdarg gives you no way to know the number or types of arguments
18:14:32 <deech> kmc: I did Ctrl-F on the Hackage page. Just wondering if anyone here knew of something else. Here's what I know so far: Python (there's MissingPy, but it's only from Haskell to Python) , Ruby (nothing here) , Perl (nothing here), Lua(decent beginnings a binding).
18:14:56 <elliott> I would like to see a Perl bridge. using XS from the FFI by hand seems very painful.
18:15:00 <dainanaki> deech: hubris lets you call Haskell from Ruby. Kind of old.
18:15:08 <kmc> deech, fwiw, if I had to integrate Haskell code with code in one of those languages, I'd use one of the cross-language IPC / serialization standards
18:15:26 <kmc> like json or bson or xml or yaml or protobuf or thrift or asn.1 or ...
18:15:42 <monochrom> asn.1 !
18:15:42 <kmc> maybe even xml-rpc
18:15:46 <ddarius> Jafet: I already referenced the equivalences package, though I doubt the reference was understood.
18:15:55 <kmc> if you don't need high performance, the loose coupling is easier imo
18:16:21 <deech> kmc: I've used JSON in the past. It's nice but having a good binding is more convenient for the developer. Just trying my luck.
18:16:27 <kmc> dainanaki, the other problem is that you need a different C stub for each Haskell function it might end up calling
18:16:52 <kmc> solutions i can think of here:
18:17:05 <dainanaki> yeah, I'd considered that option already, but figured there had to be something a little less horrible.
18:17:06 <kmc> - maybe there's only one Haskell function at a time.  store its pointer in a global variable
18:17:13 <Jafet> Well, I think I'm repeating half of what Cale said, anyway
18:18:26 * ddarius doesn't think any of those are "cross-language IPC / serialization standards."
18:18:29 <kmc> - do the runtime code generation yourself.  ugly, non-portable
18:19:07 <hpaste> ion pasted ‚ÄúHaskellDB ftw.‚Äù at http://hpaste.org/51082
18:19:35 <ion> ‚Üë Remind me again, is this C++ and STL?
18:19:38 <kmc> - make GHC do the runtime code generation, via foreign import "wrapper".  involves C calling Haskell calling the C varargs unpacker.  problem is, I don't know how the latter C function would find the former function's stack
18:20:01 <kmc> - make GHC do the runtime code generation by hooking the RTS at a lower level.  unknown
18:20:05 <elliott> ion: meh, a simple stack overflow
18:20:16 <elliott> I thought HaskellDB was unmaintained
18:20:36 <dainanaki> kmc: I could be wrong, but don't varargs just get treated as normal arguments without compile-time validation anyways? If that's the case, couldn't I do some clever casting of FunctionPtrs, and then pass them to a small wrapper function that casts them back to the proper  callback type?
18:20:46 <dainanaki> in C, that is.
18:20:56 <ion> The latest release: Mon May 2 15:53:16 UTC 2011
18:20:59 <kmc> i don't know if that's guaranteed
18:21:10 <kmc> a platform's varargs convention can differ from its normal convention
18:21:32 <dainanaki> hrm.
18:22:06 <elliott> ion: fair enough
18:22:18 <elliott> kmc: yeah, but it usually doesn't
18:22:26 <kmc> oh hmm
18:22:28 <kmc> http://blog.nelhage.com/2010/10/amd64-and-va_arg/
18:22:31 <elliott> I mean, it's UB as far as C as concerned, but who cares?
18:22:40 <elliott> GHC is probably less portable than that assumption.
18:22:47 <kmc> 'One could imagine simplifying the problem by stipulating a different calling convention for variadic functions, but unfortunately, for historical reasons and otherwise, C requires that code be able to call functions even if their prototype is not visible, which means the compiler doesn‚Äôt necessarily know if it‚Äôs calling a variadic function at any given call site. [edited to add: caf points out in the comments that C99 actually explic
18:22:48 <kmc> itly does not require this property. But I speculate that the ABI designers wanted to preserve this property from i386 because it has historically worked, and so existing code depended on it]'
18:22:54 <elliott> The register stuff is a pain though
18:23:04 <elliott> But I don't think it poses an actual problem
18:24:05 <dainanaki> I'm tempted to just use the libffi bindings instead.
18:24:34 <slack1256> hey guys quick question
18:24:35 <dainanaki> They seem to support varargs at the cost of being less type-safe.
18:24:48 <kmc> dainanaki, ah, that's a good idea
18:25:07 <slack1256> since haskell evaluation is = non-strict-semantics + sharing, how haskell does sharing with parallel execution?
18:25:24 <kmc> slack1256, unspecified by the Haskell Report
18:25:30 <kmc> but we can describe how GHC works
18:25:38 <dainanaki> I think I'll hack on a libffi implementation and see how that goes.
18:25:39 <dolio> Haskell doesn't specify sharing.
18:25:42 <slack1256> that would be useful
18:25:49 <dainanaki> thanks, kmc
18:25:57 <slack1256> true i forgot that!, haskell only specifies non-strict-semantics
18:26:13 <kmc> with the threaded GHC runtime, a thunk that's currently being evaluated is replaced with a "whitehole"
18:26:29 <slack1256> mmm whitehole?
18:26:32 <kmc> attempting to evaluate a whitehole suspends the current thread and places it on a waitqueue for that thunk
18:26:35 <ddarius> kmc: Haskell doesn't specify sharing in any way shape or form.  Call-by-name is completely conformant.
18:27:01 <kmc> when evaluation finishes, the whitehole is replaced with the evaluated value, and the threads on the waitqueue  are awakened
18:27:15 <kmc> there's actually a small race condition where two threads could enter the same thunk before either replaces it with a whitehole
18:27:19 <slack1256> ddarius: i was the dummy who affirmed that, sorry
18:27:27 <kmc> but this is rare and only results in duplicated work
18:27:31 <kmc> it will not change semantics
18:28:47 * ddarius should make a program that counts how often thunks get duplicated.
18:28:57 <kmc> using unsafeDupablePerformIO?
18:29:02 <kmc> i'd be interested to see the results
18:29:08 <UMT-Jose> TIRED OF NIGGERS?
18:29:14 <UMT-Jose> SICK OF THEIR MONKEYSHINES?
18:29:14 --- mode: ChanServ set +o copumpkin
18:29:16 <UMT-Jose> WE ARE TOO!
18:29:17 <dainanaki> ban please.
18:29:18 <UMT-Jose> JOIN CHIMPOUT FORUM
18:29:23 <UMT-Jose> HTTP://WWW.CHIMPOUT.COM/FORUM
18:29:25 --- mode: copumpkin set +b *!u3625@gateway/web/irccloud.com/x-ovaugyqfyyhqoijp
18:29:25 --- kick: UMT-Jose was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
18:29:30 <slack1256> i think i get it. thanks kmc
18:29:40 <kmc> i thought mentioning that URL was an automatic k-line on freenode
18:29:42 --- mode: copumpkin set -o copumpkin
18:30:30 <kmc> when i look at the fancy tricks GHC uses to do efficient lazy evaluation... I wonder what the GHC team could do on a compiler for a strict pure language
18:30:44 <kmc> people keep asking for "strict Haskell" anyway
18:31:25 <ddarius> There have been several "eager" Haskells plus several languages that are similar to Haskell but have eager semantics.
18:31:37 <slack1256> SPJ thinks that "the next haskell" will be strict,
18:31:54 <kmc> yeah
18:31:55 <slack1256> but i kind of like the expressiveness of lazy evaluation
18:32:00 <kmc> me too
18:32:11 <ddarius> As I mentioned last time, there will never be a "next Haskell."
18:32:12 <kmc> i'd like better ways to interoperate between the two
18:32:29 <kmc> like, compare GHC before bang patterns to after
18:32:31 <dainanaki> kmc: I think the libffi route still is going to encounter issues since there's not a clear way to marshall a FunPointer's args into vararg form...
18:32:34 <kmc> and imagine a few more steps in that direction
18:32:40 <ddarius> kmc: See Clean.
18:32:53 <slack1256> but from what i heard (from scheme guys) is easier to implement lazy by default with strictness annotation than the other way around
18:33:00 <kmc> f x y z | x `seq` y `seq` z `seq` False = undefined
18:33:02 <kmc> yep
18:33:16 <kmc> i just want better ways of writing strictness annotations
18:33:18 <slack1256> ddarius: why do you say that?
18:34:31 <ddarius> slack1256: Because (successful) languages never die to make way for successors.
18:34:43 <slack1256> but the strictness analyzer of ghc has gotten a lot better in 7.x
18:35:15 <ddarius> slack1256: Unless the strictness analyzer has gotten unsound, that's neither here nor there.
18:35:54 <slack1256> ddarius: i agree with that, but couldn't they come up with an idea to guarrante purity with stricteness and implement in paralel a l√° pH
18:36:27 <ddarius> There's no difficulty "guaranteeing purity with strictness."
18:36:46 <ddarius> slack1256: As I said just a few minutes ago, there have been several "eager" Haskells.
18:37:56 <dolio> Eager isn't even a good antithesis to non-strict.
18:38:10 <slack1256> ddarius: yeah, I have seen them, I wish them the best, it would be the best of both worlds
18:38:20 <ddarius> slack1256: No it wouldn't.
18:38:29 <slack1256> ddarius: how so?
18:38:38 <slack1256> ddarius: how come*?
18:38:51 <Jafet> Haskell is not strict about being non-strict, so lazy programmers pretend it is lazy.
18:39:15 <dolio> Haskell is definitely non-strict.
18:39:17 <ddarius> Jafet: Lazy is a non-semantic operational concern.
18:39:51 <copumpkin> okay
18:40:04 <slack1256> non-strictness is in the open-standard, so pretty much is written in rock unless the commite decide to change that
18:40:10 <elliott> When wrapping a C API, is there a better way to implement a ForeignPtr that requires two C functions to be called on the pointer in order to finalise than making a FunPtr from a Haskell function that calls both of them and using that as the finaliser?
18:40:12 <copumpkin> anyone know how to get cabal to pass ghc's include dir as an -I to gcc when compiling c?
18:40:12 <dolio> Operational semantics is semantics too.
18:40:26 <ddarius> dolio: I didn't say operational semantics.
18:41:18 <slack1256> copumkin: using linux (distro) or windows?
18:41:23 <dolio> You didn't say denotational semantics.
18:41:37 <ddarius> dolio: Indeed I did not.
18:41:38 <copumpkin> slack1256: mac, but I want something portable
18:42:29 <KirinDave> Humm
18:44:03 <slack1256> copumpkin: ok, I will check anyways, check that you have well defined gcc variables (shell: env, and look for something irregular)
18:44:16 <copumpkin> I'm not compiling it myself
18:44:18 <copumpkin> I need cabal to
18:44:46 <slack1256> copumpkin: right, but cabal also need to check those variables
18:45:05 <copumpkin> this is a GHC include directory
18:45:08 <copumpkin> ...
18:45:09 <dainanaki> copumpkin, is it ghc's gcc that's compiling, or an external gcc?
18:45:21 <copumpkin> this is cabal
18:45:24 <copumpkin> calling ghc on a c file
18:45:27 <copumpkin> so ghc does its own thing
18:46:55 <dainanaki> could you use -optc -I/include/dir ?
18:47:08 <copumpkin> I don't know it in a cross-platform manner
18:48:43 <copumpkin> but I think I can ask cabal
18:49:20 <elliott> Hmm, is therea ny guarantees on the order finalisers will be executed in?
18:49:38 <copumpkin> I don't think so
18:49:51 <Jafet> After an object is due for garbage collection, I guess
18:50:02 <dainanaki> actually, I think there is a guarantee maybe.
18:50:03 <elliott> Jafet: order between each other
18:50:21 <Jafet> The manual has some more documentation about this
18:50:28 <elliott> I need two finaliser functions executed in sequence; it's really gross to have to make my own Haskell function combining them and then making a FunPtr out of that.
18:50:33 <Jafet> Mainly a list of gotchas
18:50:34 <elliott> Especially since the FunPtr needs freeing too...
18:50:35 <slack1256> copumpkin: ldconfig maybe?
18:50:41 <copumpkin> slack1256: for ghc?
18:51:14 <elliott> "The finalizer will run before all other finalizers for the same object which have already been registered."
18:51:14 <elliott> aha
18:51:39 <dainanaki> I knew there was something like that.
18:51:45 <slack1256> copumpkin: run a ldconfig, and then try again
18:51:57 <dainanaki> Having just recently dealt with finaliser ordering myself.
18:52:03 <copumpkin> slack1256: that won't help
18:53:04 <_Ray_> Hi. Wondering on the universality of a technique. Today, we wanted to implement tree pruning (at a certain height) using foldr. We have data Tree a = Node a [Tree a]. We defined treeFold :: (a -> [b] -> b) -> Tree a -> b, treeFold f = g where    g (Nodo x xs) = f x (map (treeFold f) xs). Normally, to prune, we would want a function f :: Tree a -> Int -> Tree a, which prunes the tree if the int given is (say) 0. However, foldr passes the same functi
18:53:05 <_Ray_> on f over and over. So what we came up with was this: http://hpaste.org/51084 . Basically we converted this: (a -> [b] -> b) into (a -> [b -> c] -> (b -> c)), into (a -> [b -> c] -> b -> c) (the last two of which are obviously the same), in order to accomodate folding with a 'variable function'. Is this technique common? If so, is there a generalization?
18:53:38 <slack1256> copumpkin: then I don't know (i was kind of shooting blindly), well bye :)
18:53:48 <copumpkin> ah well, I'll figure it out :) thanks
18:54:03 <_Ray_> err, replace that "podar'" with prune'. I'm translating the identifiers into English for #haskell's convenience :p
18:54:42 <Jafet> Just give them one-letter names
18:55:39 <ddarius> _Ray_: Are you calling treeFold also foldr?
18:55:54 <_Ray_> yes, I am not sure if it is analogous to a right or left fold
18:56:24 <ddarius> It would be closer to a right fold, but its confusing for you to say treeFold one place and foldr somewhere else.
18:56:47 <Minimiscience> What's the easiest way to get GHC 7.* on Mac OS 10.5?  I have Xcode 3.0 and am willing to use it.
18:56:48 <KirinDave> Ugh, I actually don't know...
18:56:49 <_Ray_> oh, sorry :( we had to give it a specific name ("foldArbol"). I'm aware there's a typeclass Foldable, correct?
18:57:05 <KirinDave> So guys, I could use some advice. This question is admittedly soft and imprecise, but...
18:57:19 <ddarius> _Ray_: That's something else.  It should just be called to list.  More pointedly, there's the foldr function.
18:57:25 <KirinDave> Today I had a ton of data being spat out of iostat for a lot of different machines doing a lot of different work
18:57:48 <KirinDave> And I wanted to take all that data, parse it, and then do stats on it. I ended up doing it in ruby because I am comfortable using ruby for text processing.
18:58:02 <KirinDave> But now they want me to compute these stats weekly.
18:58:22 <_Ray_> ddarius, "called to list"? It returns another tree, not a list :o
18:58:37 <_Ray_> (Well, it returns whatever the folded function wants - in my case, a tree.)
18:58:46 <KirinDave> I was thinking, "Ah, I should use Haskell for this‚Ä¶" but I don't actually know how you go about doing cheap text processing and that sort of stuff in Haskell. Is there a library that makes it an autopilot sort of task?
18:58:55 <ddarius> _Ray_: I very poorly worded that sentence.  The Foldable class should be called ToList.
18:59:01 <_Ray_> Ah, OK
18:59:03 <dainanaki> KirinDave: Haskell is excellent for parsing.
18:59:09 <ddarius> At any rate, taking the actual (list) foldr, whenever you see h [] = z; h (x:xs) = g x (h xs) you can rewrite it as h = foldr g z.  Whether h xs has a function type or not is irrelevant.
18:59:23 <KirinDave> dainanaki: Ah, I know a bit about this, having used attoparsec a lot recently
18:59:32 <ddarius> There are plenty of examples of folds that produce functions.
18:59:42 <KirinDave> dainanaki: But generally that works best when you know the shape of the data in advance. In my case, sometimes columns will be there and sometimes they won't.
19:00:17 <KirinDave> So i can't just write something like DataConstructor <$> numberDroppingWhitespace <*> numberDroppingWhitespace
19:00:24 <_Ray_> ddarius, in this case, what I wanted was to 'change' h as the fold got deeper. Specifically, once it got to a given depth, I wanted f to always return [].
19:00:51 <Jafet> KirinDave: how is it done in ruby, then?
19:01:38 <KirinDave> Jafet: Each file starts with a set of column names. You'd break by words, then keep that around. Each subsequent column is a list of numbers with tab or space separations (depends on the version of linux)
19:01:55 <KirinDave> Jafet: I build those up as ordered lists too.
19:02:10 <KirinDave> It's actually sort of tedious to write the stats stuff in ruby, which made me think of haskell.
19:02:20 <ddarius> _Ray_: Since you wrote it using treeFold, it clearly is a fold that produces a function, it doesn't matter why you were doing it.
19:02:26 <Jafet> How is it done in ruby that you can't do the same thing, at least, in haskell?
19:02:27 <KirinDave> I just don't know what the clean approach for semi-structured data is in haskell. I've never seen an example.
19:02:33 <dainanaki> KirinDave, sounds like you can still use parsec for that.
19:02:46 <KirinDave> dainanaki: Maybe so!
19:03:02 <dainanaki> You'll probably want to use it monadically rather than applicatively
19:03:11 <KirinDave> Parser [Double]
19:03:12 <_Ray_> ddarius, right, just wondering if the "I need the function to change as it gets deeper - let's return a function" practice is common.
19:03:25 <KirinDave> And then do many of those, I guess?
19:03:42 <KirinDave> Although dang, once you have the list...
19:03:53 <dainanaki> If you know the number of columns you need for example, you can do something like replicateM numberOfColumns parseColumn
19:04:01 <dainanaki> then a newline
19:04:02 <KirinDave> I don't.
19:04:16 <dainanaki> I thought you said the top column told you what columns you have.
19:04:22 <KirinDave> Oh i see what you mean
19:04:23 <Jafet> parseColumn `endBy` newline
19:04:23 <KirinDave> Yeah
19:04:27 <KirinDave> yeah
19:05:13 <dainanaki> with that, you can make a list of lists, and end up with something like Parser [[Double]] or something.
19:05:48 <dainanaki> it's hard to give precise advice since I haven't seen any sample data
19:05:50 <ddarius> _Ray_: The function isn't changing, it simply has another argument.  At any rate (again), if I said this was uncommon or if I said it was common, how would your life change?
19:05:58 <copumpkin> anyone know how I can use Distribution.something to call ghc to get it to compile a c file?
19:06:14 <_Ray_> ddarius, maybe there's a generalization of this trick :)
19:06:47 <ddarius> _Ray_: There's no trick.  You are just using the fold at a function type.  The generalization was the fold to begin with.
19:06:57 <copumpkin> aha, ghcProgram
19:07:42 <mm_freak> :t let replicateA 0 _ = pure []; replicateA n c = liftA2 (:) c (replicateA (pred n :: Int) c) in replicateA
19:07:43 <lambdabot> forall (f :: * -> *) a. (Applicative f) => Int -> f a -> f [a]
19:07:54 <_Ray_> ddarius, the trick was, instead of using this as a function: a -> [Tree a] -> Tree a, to use a -> [Int -> Tree a] -> (Int -> Tree a).
19:08:28 <_Ray_> But anyway, I gather this isn't a common trick then.
19:09:04 <ddarius> _Ray_: What is this that you were going to use as a function a -> [Tree a] -> Tree a
19:09:05 <ddarius> ?
19:09:08 <mm_freak> KirinDave: one interesting style i use for the particular case of CSV file parsing is a parser, which returns a parser
19:09:35 <mm_freak> csvHeaderField :: Parser (Parser CsvField)
19:09:38 <ddarius> _Ray_: As far as I can tell, it isn't a common trick, because it's not a trick.  It is common.
19:09:42 <confound> yo dawg, I heard you like parsing
19:09:45 <mm_freak> many1 csvHeaderField
19:09:54 <_Ray_> ddarius, since I wanted to make a tree pruning function using fold, it was going to be of the sort prune k = fold somefunction. somefunction must return Tree a just like fold, and the rest is just hindley milnering it.
19:10:00 <mm_freak> gives you a list of parsers you can apply using 'sequence', which parses a CSV line
19:10:21 <_Ray_> Now, if instead I said prune = foldr foo, foo now returns an Int -> Tree a, and I can do the "change function as we get deeper in the recursion" thing.
19:10:51 <KirinDave> mm_freak: Clever
19:10:58 <KirinDave> Ahh yeah, and ZipList.
19:11:06 <KirinDave> Ty for helping me see how thick I am
19:11:08 <KirinDave> Gonna go do this now.
19:11:28 <dainanaki> Good luck!
19:11:29 <ddarius> _Ray_: So you realized that by adding a parameter (generalizing) you could simplify the problem.  This is exactly how O(n) reverse gets made.
19:11:53 <ezyang> What's the name of the logical rule that says that (Either a b) -> (a -> c) -> (a -> c) -> c?
19:11:57 <mm_freak> well, no ZipList is involved in my case, but go ahead
19:12:07 <ezyang> (even if I can't exhibit an Either a b)
19:12:15 <ddarius> ezyang: That's the elimination form of Either.
19:12:42 <mm_freak> ezyang: it doesn't look to me like that one is actually true
19:12:57 <ezyang> sub second one with (b -> c) >:-)
19:13:08 <Jafet> Ray: on the bright side, I found your code an interesting obfuscation
19:13:10 <mm_freak> ok, then it's just a swapped-arguments 'either'
19:13:12 <mm_freak> :t either
19:13:13 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:14:03 <_Ray_> Jafet, obfuscation of what? :o
19:14:57 <_Ray_> Oh also, if Foldable is for toList, is there a typeclass for 'things which have a foldr'?
19:14:58 <dainanaki> is there an easy way to get Typeable to repeatedly apply typeRepArgs until there are no arguments to apply?
19:15:12 <ddarius> _Ray_: No.
19:15:21 <kmc> isn't Foldable also that?
19:15:24 <kmc> you can write toList using foldr
19:15:37 <ddarius> Well, it doesn't need a class.
19:15:42 <kmc> oh, foldr'?
19:15:45 <kmc> oh, /me misreads
19:15:45 <ddarius> kmc: He doesn't mean things that have list's foldr.
19:16:04 <shachaf> Catamorphisms in general?
19:16:04 <_Ray_> Like, 'things which have map' are Functor, and it's called fmap.
19:16:05 <ddarius> kmc: I think you've double misread.
19:16:13 <ddarius> shachaf: Yes.
19:16:21 <shachaf> What would that type class look like?
19:16:24 <kmc> ah, the question is about catamorphisms?
19:16:27 <ddarius> _Ray_: Just say fold, rather than foldr.
19:16:34 <_Ray_> Ah, OK. :)
19:16:36 <kmc> _Ray_, you may enjoy http://mainisusuallyafunction.blogspot.com/2010/12/type-level-fix-and-generic-folds.html or some of the things it links to
19:16:43 <kmc> and the bananas lenses barbed wire whatever paper
19:17:16 <ddarius> _Ray_: You can define a generic fold given an algebra for a functor.  An algebra for a function is just a function F a -> a.  There is no need for a type class.
19:17:39 <ddarius> @where evolution
19:17:40 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
19:17:51 <ddarius> See that for an example (eventually)
19:18:19 <_Ray_> Don't comonads have a F a -> a?
19:19:00 <ddarius> Well I slightly misworded my earlier sentence.  The generic fold takes algebras.
19:19:13 <ddarius> The algebras represent the (+) and 0 in foldr (+) 0.
19:19:36 <ddarius> You could fold extract, but I don't think it would have much meaning.
19:19:49 <_Ray_> http://en.wikipedia.org/wiki/Catamorphism seems cool :)
19:20:57 <dainanaki> how could I reify the arguments of a function like so: reifyArgs (+) => [Integer, Integer]
19:20:58 <ddarius> :t fold alg = alg . fmap (fold alg) . out
19:21:00 <lambdabot> parse error on input `='
19:21:05 <ddarius> :t let fold alg = alg . fmap (fold alg) . out in fold
19:21:07 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
19:21:08 <dainanaki> I'm having a hard time seeing a simple implementation.
19:21:26 <dolio> > typeOf (+)
19:21:28 <lambdabot>   Integer -> Integer -> Integer
19:21:43 <dainanaki> folio, but I need the arguments individually.
19:21:47 <Jafet> What sort is [Integer, Integer]?
19:22:23 <dainanaki> dolio: typeRepArgs is almost what I'm looking for, but not quite right.
19:22:40 <dainanaki> It does partial application, which is not what I'm looking for.
19:22:41 <dolio> Just parse the result of typeOf. :)
19:22:55 <ddarius> :t typeOf (+)
19:22:57 <lambdabot> TypeRep
19:23:45 <dainanaki> dolio: you're scary.
19:24:58 <dolio> It shouldn't be hard. You just want many types separated by ->. All but the last one.
19:25:10 <dainanaki> I know.
19:25:24 <dainanaki> I'm not scared of doing it, I'm scared that you thought of that.
19:25:38 <ddarius> @hoogle TypeRep -> a
19:25:38 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
19:25:39 <lambdabot> Prelude id :: a -> a
19:25:39 <lambdabot> Data.Function id :: a -> a
19:25:45 <ddarius> Thanks Hoogle.
19:27:35 <_Ray_> Would this IO computation ever be evaluated? False && unsafePerformIO foo
19:27:53 <daigo> curious why most haskell people use emacs
19:27:54 <dolio> ddarius: Paul's excited about building a structural editor for our language at work that will only allow you to fill in well-typed terms....
19:27:55 <dainanaki> no, but don't do that.
19:27:56 <daigo> over vim
19:28:00 <ddarius> daigo: They don't.
19:28:12 <dolio> During one of our meetings, we realized that the top suggestion for every hole might be undefined and unsafeCoerce.
19:28:25 <dolio> Including the ones that shouldn't be able to be filled.
19:28:29 <dainanaki> I use undefined all the time.
19:28:30 <kmc> _Ray_, probably not
19:28:32 <daigo> ddarius: most of the screenshots for xmonad are using emacs, but that's hardly the best scientific way to gauge a populace of course :o)
19:28:46 <_Ray_> kmc: Probably?
19:28:53 <daigo> undefined sounds like a sexy editor
19:29:10 <dainanaki> Oh, it is!
19:29:32 <dainanaki> Interestingly, I have an emacsish text editor that I'm working on in Haskell.
19:29:39 <dainanaki> currently, the name is undefined.
19:29:41 <shachaf> Does Haskell actually guarantee that it won't evaluate arbitrary thunks for a bit if it feels like it?
19:29:54 <kmc> Haskell only guarantees non-strict semantics
19:30:02 <kmc> you could evaluate every expression in a parallel thread, for example
19:30:02 <ddarius> daigo: There was recently a survey done.  44% used vim.  41% used emacs.  Respondents were allowed to respond with multiple choices though.
19:30:17 <Minimiscience> So, does anyone know the easiest way to get GHC 7.* on Mac OS 10.5?  There don't seem to be any downloads that recent for Leopard.
19:30:18 <ddarius> daigo: Previous surveys have similar results.
19:31:08 <ddarius> shachaf: It definitely does not do that.
19:31:09 <kmc> x && y = (x Prelude.&& y) `unamb` (y Prelude.&& x)
19:31:20 <ddarius> shachaf: And there are variants of GHC that do exactly that.
19:31:22 <dainanaki> daigo: may I ask where you got your username from?
19:31:29 <kmc> _Ray_, have you seen conal's unamb and lub packages? quite cool stuff
19:31:51 <shachaf> @poll-add editor
19:31:53 <lambdabot> Added new poll: "editor"
19:31:53 <dolio> dainanaki: He's obviously THE daigo.
19:32:09 <kmc> lambdabot does polls???
19:32:10 <shachaf> @choice-add editor vim
19:32:11 <lambdabot> New candidate "vim", added to poll "editor".
19:32:13 <shachaf> @choice-add editor emacs
19:32:14 <lambdabot> New candidate "emacs", added to poll "editor".
19:32:17 <ddarius> kmc: Yes.
19:32:19 <kmc> @choice-add editor EDLIN
19:32:19 <lambdabot> New candidate "EDLIN", added to poll "editor".
19:32:19 <shachaf> @vote editor vim
19:32:20 <lambdabot> voted on "vim"
19:32:29 <ddarius> kmc: It was never a popular feature.
19:32:39 <Minimiscience> Don't forget ed, the standard text editor.
19:32:43 <Minimiscience> Also, butterflies.
19:32:45 <dainanaki> @vote editor emacs
19:32:45 <lambdabot> voted on "emacs"
19:32:51 <ddarius> lambdabot, in true lambdabot style, isn't very smart about it either.
19:32:57 <daigo> dainanaki: i am on the path to attain 'daigo' with Haskell in hand for life of course.
19:32:58 <Olathe> @choice-add editor switches-on-front-of-computer
19:32:59 <lambdabot> New candidate "switches-on-front-of-computer", added to poll "editor".
19:33:13 <kmc> hmm i wonder why this feature was never popular...
19:33:22 <daigo> Soon, I also hope to attain it in a single moment of Satori and truth to be laid bare in front of me.
19:33:23 <shachaf> kmc: I don't think that use of unamb is very valid.
19:33:38 <daigo> My nick is in stark contrast to my previous long-time nick: irrumat0r
19:33:56 <daigo> I have cleansed my soul and walk the earth a humbled man, dainanaki
19:34:01 <dainanaki> daigo: neat! I was wondering if you were perhaps from daigo, ibaraki
19:34:07 <kfish> @vote editor vim
19:34:08 <lambdabot> voted on "vim"
19:34:11 <ddarius> Satori reminds me of Imajica which had some good made-up names.
19:34:35 <daigo> i'm not actually a buddhist or anything though. no offense to those on the actual path to Satori, may buddha guide you
19:34:48 <daigo> i'm actually muslim, but that's a tale for another day
19:34:53 <ddarius> dainanaki: How many people do know use Connecticut as a nick?
19:35:05 <confound> I don't, because I'm not from there
19:35:11 <confound> obviously I would if I were, though
19:35:52 <dainanaki> ddarius: none. but that's because of namespacing issues. first-come, first-served.
19:36:28 <dainanaki> The guy that owns the domain that is my real name is a gay porn filmer. I would much prefer to have the domain over him.
19:37:06 <ddarius> I guess I shouldn't feel so bad then.
19:39:37 <daigo> dainanaki: this is daigo: http://en.wikipedia.org/wiki/Daigo_(Zen)
19:40:03 <dainanaki> daigo: this is daigo: http://en.wikipedia.org/wiki/Daigo,_Ibaraki
19:40:29 <elliott> dainanaki: I'm sure he thinks the opposite
19:40:40 <confound> dainanaki: this is daigo: http://en.wikipedia.org/wiki/Daigo_Umehara
19:41:21 <daigo> kindof a 'profane' or over-used Japanese word for something so significant, donchathink?
19:42:01 <dainanaki> Japanese just has a lot of character combinations that work out to the same phonetic sound.
19:42:01 <daigo> or maybe Umehara is just that amazing Ôºà„Éª‚àÄ„Éª* Ôºâ
19:42:29 <daigo> gotcha, didn't think of that. makes sense.
19:43:43 <dainanaki> It's not that uncommon in a Japanese conversation to need to specify which characters are being used, especially with the spelling of names.
19:44:44 <daigo> what is the left-most app that's listing the dirs here, looks to be part of the editor methinks. gedit perhaps? or somethign else?: http://haskell.org/wikiupload/6/65/Wraithan-Desktop-2009-12-15.png
19:44:58 <daigo> nvm, looks like gvim
19:45:09 <daigo> hmm, i wonder if we can do that in normal vim
19:45:28 <Jafet> dainanaki: unless they're part of called attacks, whereupon they just appear on screen
19:45:39 <confound> ha
19:45:43 <dainanaki> lol
19:46:00 * dainanaki shoryukens Jafet.
19:46:15 <confound> daigo: why not? nothing gui about it
19:47:13 <aspect> daigo: what confound said, and I think that's NerdTree
19:47:18 <daigo> confound: i know you can ls in the lower command bar in vim, yet it doesn't run down the side does it?
19:47:29 <daigo> nerdtree...i think i've heard of it
19:47:31 * aspect uses :vspl and :E
19:47:36 <daigo> yep
19:47:44 <confound> it might also be http://www.vim.org/scripts/script.php?script_id=184
19:48:04 <confound> the fact that that's not ls doesn't mean it's gui-specific
19:49:51 <daigo> aspect: wow, never knew about those
19:49:58 <daigo> what exactly do they do?
19:50:09 <daigo> i try to go back to normal mode from :E and esc does nothing
19:50:22 <daigo> :vspl seems to be some sort of mirror editing in a vsplit screen
19:50:29 <daigo> not sure why you'd want that last one
19:51:00 <aspect> daigo: see :h :vspl etc .... :vspl does a vertical split (analogous to :split), :E is explore - for navigating the filesystem, press enter on a file or directory to enter it
19:51:21 <daigo> yep, will check out. looks intriguing.
19:51:22 <aspect> vim /some/dir/ gives you the equivalent of :E /some/dir/
19:51:31 <daigo> just when i think i have most of vim figured out...
19:51:54 <aspect> heh.  I used to think that every so often :)
19:51:56 <confound> you don't need :E, :e will do that too
19:53:15 <aspect> ah yes, true
19:53:35 <aspect> :E can be considered a shortcut for :e <path-to-current-file>
19:53:37 <confound> :E with no args does something useful, though, unlike :e with no args
20:07:34 <elliott> Has anyone used Perl's embedding facilities via the FFI? I'm getting segfaults for simple evaluations.
20:11:35 <sero> Anyone that could maybe help me? I'm trying to modify this: http://www.haskell.org/haskellwiki/HXT/Practical/Weather1, I have this: http://pastebin.com/5smbv1Qi so far, but I get: wunder: Prelude.read: no parse
20:11:37 <mauke> The paste 5smbv1Qi has been copied to http://hpaste.org/51085
20:21:08 <Cale> sero: dewpoint_string looks something like <dewpoint_string>52 F (11 C)</dewpoint_string>
20:21:19 <Cale> which obviously isn't going to parse with 'read'
20:21:30 <Cale> well, it's the contents of that tag
20:21:37 <Cale> so just the "52 F (11 C)"
20:21:43 <geekosaur> same with the other *_string entries
20:21:53 <Cale> You probably want to be capturing dewpoint_c instead
20:22:28 <Cale> also, it apparently can be NA, even in the cases which are supposed to be numbers
20:22:36 <geekosaur> likewise relative_humidity has a % on the end which read will choke on
20:22:52 <Cale> <windchill_c>NA</windchill_c>
20:23:08 <roconnor> > maxBound :: Int32
20:23:09 <lambdabot>   2147483647
20:23:13 <roconnor> > maxBound :: Int16
20:23:14 <lambdabot>   32767
20:23:25 <Cale> You might just consider not parsing it, if you can avoid it.
20:23:28 <roconnor> @roll 1d32767
20:23:28 <lambdabot> Consider it noted.
20:23:34 <roconnor> I alway do taht
20:23:41 <roconnor> @dice 1d32767
20:23:41 <lambdabot> 1d32767 => 18878
20:24:46 <sero> Cale, ok, thanks. I'm very new to haskell, not knowing much I'm trying to make that stuff work, then my goal is to make it a bot plugin, only make it so the location is a variable vs hardcoded to one location.
20:25:04 <ddarius> Perhaps we should make a roll so roconnor won't fill up lambdabot's memory with messages to 1d4326
20:25:09 <Jafet> I wonder where all these erroneous messages go
20:25:23 <Jafet> I once sent a message to "any", whoever that is
20:25:28 <Cale> haha
20:25:30 <Jafet> preflex, xseen any
20:25:30 <preflex>  Sorry, I haven't seen any
20:25:34 <Cale> probably lots of them are undelivered
20:25:36 <any> foo
20:25:49 <Jafet> Or perhaps not.
20:26:28 <ddarius> preflex: seen Haskell
20:26:29 <preflex>  Haskell was last seen on #haskell 89 days, 17 hours, 33 minutes and 3 seconds ago, saying: > let { f k = f' k 9 ; f' 0 _ = [0] ; f' k m = do { a <- [0..m] ; ax <- f' (k-1) a ; return $ a * 10^k + ax } } in f 2
20:27:27 <sero> Cale, what would be another way of doing such a thing, if not parsing?
20:28:03 <Cale> sero: Well, I didn't look at your whole program, but if you're not doing any arithmetic with the numbers, you can afford to just leave them as strings
20:28:23 <Cale> Since it seems the weather station likes to put in irritating things like NA instead of numbers.
20:28:33 <Cale> (sometimes)
20:29:16 <daigo> @vote vim
20:29:17 <lambdabot> usage: @vote <poll> <choice>
20:29:29 <rwbarton> seriously, at least it could put Nothing instead :P
20:29:34 <Cale> So just replace ":: Float" in the definition of the Weather datatype with ":: String"
20:29:43 <Jafet> @vote editor EDLIN
20:29:44 <lambdabot> voted on "EDLIN"
20:29:51 <Cale> and then remove all occurrences of 'read'
20:30:18 <ddarius> Cale: What should they have put?
20:31:00 <sero> Cale, ah, ok. In it's original form, there were some lines that did multiplication. thanks
20:31:16 <kmc> shachaf, what's wrong with that use of unamb?
20:31:32 <Cale> ddarius: I'm not really saying they should put something else
20:31:58 <Cale> ddarius: Just that it's annoying to deal with if you're not making any use of the fact that they're numbers when they are.
20:32:21 <Axman6> @v
20:32:22 <lambdabot> "\"#$%&'()*+,\""
20:32:25 <Axman6> :|
20:32:28 <Axman6> @vo
20:32:28 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
20:32:39 <ddarius> Cale: Your wording portrays the weather stations as a malicious entity out to make your life harder.
20:33:04 <Cale> ddarius: sure :)
20:33:08 <sero> lol
20:33:15 <Jafet> The fact that they're using XML tends to support his wording.
20:33:34 <Cale> ddarius: They should be more responsible and just always have the number you're looking for! :)
20:33:43 <ddarius> Jafet: Well I'm not saying that interpretation is wrong, just that this isn't an example.
20:33:47 <Jafet> Also the fact that this is being posed as an exercise
20:34:07 <Cale> (not that I really expect that)
20:34:43 <ddarius> The rather non machine-readable, non-standardize format the data usually comes in is where they start to bring out their blind malice.
20:35:36 <sero> Cale, great! works perfectly now as I wanted. thank you very much for the help.
20:52:32 <benn> can anyone assist: trying to create a substring function to work as such-- "hello" substring 2 4 = "ell"
20:53:40 <dmwit> > take 3 . drop 2 $ "hello"
20:53:41 <lambdabot>   "llo"
20:53:46 <dmwit> > take 3 . drop 1 $ "hello"
20:53:47 <lambdabot>   "ell"
20:55:19 <benn> when writing the code, how should I? -- substring Char x y = ??
20:58:02 <_Ray_> benn, you want to first remove the first x characters of something, and of the result, remove the last y characters.
20:58:08 <_Ray_> You already have the take and drop functions.
21:00:10 <benn> I see, thank you.
21:00:10 <Cale> > let substring str n m = take (m-n+1) (drop (n-1) str) in substring "hello" 2 4
21:00:10 <lambdabot>   "ell"
21:00:10 <Cale> Kind of odd, because it's apparently 1-indexed, and inclusive on both sides.
21:06:13 <Axman6> hmm, anyone know if we have any sort of synchronisation variable which has atomic writes and multiple readers, which are woken when there's a new value?
21:06:41 <copumpkin> is it possible for us to define functions as polymorphic as unsafeCoerce#?
21:06:48 <Axman6> hmm, i guess TVars are possibly exactly what i want
21:06:50 <kmc> chan + dupChan
21:06:54 <copumpkin> or is ghc doing some weird voodoo to make it that polymorphic?
21:06:55 <ddarius> copumpkin: undefined
21:07:01 <copumpkin> ddarius: I mean polymorphic across kinds, too
21:07:07 <copumpkin> I can call unsafeCoerce# 5#
21:07:17 <Axman6> kmc: i was hoping for something with less overhead
21:07:23 <ddarius> > undefined 5#
21:07:24 <lambdabot>   *Exception: Prelude.undefined
21:07:50 <Jafet> Well, undefined is not defined.
21:08:00 <copumpkin> ddarius: what if I write f :: a -> ...
21:08:01 <ddarius> undefined = undefined
21:08:03 <Axman6> but, i'm not sure whether Chan's or TVars would have more overhead
21:08:12 <Jafet> @hoogle unsafeCoerce#
21:08:13 <lambdabot> No results found
21:08:20 <copumpkin> if I try to call that function with 5#, it tells me I have the wrong kind
21:08:22 <_Ray_> str = fix (ap (flip . (take .) . flip flip 1 . ((+) .) . subtract) . flip (drop . subtract 1))
21:08:24 <Axman6> i love the old definition of undefined: undefined | False = undefined
21:08:36 <_Ray_> haha that's disgusting
21:08:42 <Axman6> 'Is False True? if so, check again, becuase ... shit!"
21:12:33 <ddarius> "The idea of using prior electronic distribution to augment the referee process goes back to at least [8]."
21:14:43 <Cale> Even if False is True, it still gives bottom :)
21:15:01 <tom___> using def mid :: [Int] -> [Int] -- how can I mke "mid" work this way: mid [1,2,3] yields [2] or mid [1,2,3,4] yields [] ?
21:16:08 <_Ray_> you can use !!
21:16:34 <Cale> Yeah, you can compute the length and use !! in the odd case... I'm just trying to figure out something cuter than that :)
21:16:36 <_Ray_> if the length is even, [], else, !! (length/2)
21:16:47 <aspect> mid [] = []; mid [x] = x; mid x:xs = mid (reverse (drop 1 (reverse xs)))
21:16:49 <_Ray_> take n/2 drop n/2 or something
21:17:47 <Jafet> aspect: init (tail xs)
21:17:47 <Cale> mid [] = []; mid [x] = x; mid (x:xs) = mid (init xs) -- or even this
21:18:17 <Jafet> And mid [x] = [x]
21:18:25 <Cale> ah, yes
21:18:29 <Jafet> Now is a good time to mention listToMaybe
21:18:33 <Axman6> > let mid [] = Nothing; mid xs = last $ zipWith (\a b -> b) xs (xs >>= \x -> [x,x]) in mid [1,2,3]
21:18:34 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
21:18:35 <lambdabot>    arising from a use of...
21:18:46 <aspect> init = reverse . tail . reverse  ?
21:18:49 <Axman6> > let mid [] = Nothing; mid xs = Just $ last $ zipWith (\a b -> b) xs (xs >>= \x -> [x,x]) in mid [1,2,3]
21:18:50 <lambdabot>   Just 2
21:18:54 <Axman6> > let mid [] = Nothing; mid xs = Just $ last $ zipWith (\a b -> b) xs (xs >>= \x -> [x,x]) in mid [1,2,3,4]
21:18:56 <lambdabot>   Just 2
21:18:59 <Axman6> > let mid [] = Nothing; mid xs = Just $ last $ zipWith (\a b -> b) xs (xs >>= \x -> [x,x]) in mid [1,2,3,4,5]
21:19:01 <lambdabot>   Just 3
21:19:06 * Axman6 wins =)
21:19:11 <Cale> aspect: init [x] = []; init (x:xs) = init xs
21:19:31 <Axman6> Cale: x : init xs?
21:19:41 <Cale> er, yes
21:19:42 <copumpkin> I've resurrected a project I started a while ago
21:19:55 <ddarius> copumpkin: Was it three days ago?
21:20:01 <copumpkin> I plan to serialize arbitrary closures
21:20:08 <copumpkin> ddarius: nah, maybe five
21:20:17 <ddarius> copumpkin: You would make a poor Yahweh then.
21:21:48 <enthropy> > let mid x = fmap (snd . fst) $ find (\((i,_),(j,_)) -> i == j) $ zip [1..] x `zip` reverse (zip [1..] x) in [mid [1,2,3], mid [1,2,3,4]]
21:21:50 <lambdabot>   [Just 2,Nothing]
21:32:40 <tom___> One last summoning of you brilliant people: using def substring :: [Char] -> Int -> Int -> [Char]---how o create  function: substring "hello" 5 7  yield "ollo" or, substring "hello" 2 4 yield "ell"  ?
21:33:29 <kmc> ollo?
21:33:40 <kmc> > "ollo" `isInfixOf` "hello"
21:33:41 <lambdabot>   False
21:33:43 * copumpkin smells a school assignment
21:34:11 <kmc> it's not clear what you want... you should probably describe what the function does
21:34:47 <msx> why does map (+ 1) [1..5] work but map (- 1) [1..5] doesn't?
21:34:50 <aspect> substring "hello" 5 7 = "ollo"; then define the general case in terms of other functions (assuming it's consistent enough to do so)
21:34:56 <kmc> msx, stupid special case in the grammar
21:35:00 <kmc> for negative literals
21:35:10 <kmc> > map (subtract 1) [1..5]
21:35:11 <lambdabot>   [0,1,2,3,4]
21:35:17 <_Ray_> benn (860a0c1d@gateway/web/freenode/ip.134.10.12.29) has joined #haskell
21:35:20 <Cale> Well, it's not that stupid :P
21:35:26 <Cale> It is a special case
21:35:27 <_Ray_> tom___ (860a0c1d@gateway/web/freenode/ip.134.10.12.29) has joined #haskell
21:35:42 <_Ray_> Either your friend had the exact same doubt when we told him, or you are both "ben" and "tom".
21:35:46 <Cale> > map (+(-1)) [1..5]
21:35:47 <lambdabot>   [0,1,2,3,4]
21:36:34 <shachaf> > map (-1+) [1..5]
21:36:36 <lambdabot>   [0,1,2,3,4]
21:36:51 <Cale> nice, even better :)
21:36:54 <kmc> > map (¬±1) [1..5]
21:36:55 <lambdabot>   Not in scope: `
21:37:03 <kmc> @let n ¬± k = (n + k, n - k)
21:37:04 <lambdabot>  Defined.
21:37:06 <kmc> > map (¬±1) [1..5]
21:37:08 <lambdabot>   [(2,0),(3,1),(4,2),(5,3),(6,4)]
21:37:13 <shachaf> kmc: A tuple? Come on, []!
21:37:24 <shachaf> @where monad-embed
21:37:25 <lambdabot> I know nothing about monad-embed.
21:37:48 <shachaf> @where+ monad-embed http://timmaxwell.org/pages/monad-embed/
21:37:49 <lambdabot> I will never forget.
21:38:49 <msx> is there a "generic" + that works with chars?  (map (+ 2) "0123") doesn't work unfortunately
21:38:53 <elliott> shachaf: huh, that looks interesting
21:39:07 <ion> succ.succ
21:39:08 <shachaf> elliott: You should tell the author your opinions on it.
21:39:12 <kmc> > map (succ . succ) "0123"
21:39:14 <lambdabot>   "2345"
21:39:28 <kmc> > map (toEnum . (+5) . fromEnum) "0123" :: String
21:39:30 <lambdabot>   "5678"
21:39:33 <elliott> "that looks interesting" is not so interesting feedback :)
21:39:44 <kmc> > map (chr . (+20) . ord) "0123"
21:39:46 <lambdabot>   "DEFG"
21:39:57 <msx> :) thanks
21:40:05 <_Ray_> read :: [Char] -> Integer
21:43:23 <ion> > map (appEndo . mconcat . replicate 10 . Endo succ) "foobar baz"  -- :-P
21:43:25 <lambdabot>   Couldn't match expected type `a -> Data.Monoid.Endo a1'
21:43:25 <lambdabot>         against inf...
21:43:29 <ion> err
21:44:44 <ion> > map (appEndo . mconcat . replicate 10 . Endo $ succ) "foobar baz"
21:44:46 <lambdabot>   "pyylk|*lk\132"
21:47:53 <ion> > map (ala Endo foldMap $ replicate 10 succ) "foobar baz"
21:47:54 <lambdabot>   Not in scope: `foldMap'
21:48:04 <ion> > map (ala Endo Data.Foldable.foldMap $ replicate 10 succ) "foobar baz"
21:48:04 <lambdabot>   "pyylk|*lk\132"
21:49:05 <kmc> > zipWith id (iterate (succ .) id) "foobar baz"
21:49:06 <lambdabot>   "fpqeew&ii\131"
21:49:20 <kniu> @pl (\c l r -> f c [l, r])
21:49:20 <lambdabot> (. ((. return) . (:))) . (.) . f
21:49:24 <kniu> hot damn
21:50:02 <kmc> wonder if you could implement RSA in a lambdabot one-liner
21:50:24 <Axman6> hmm, can a thread be killed while it's in the middle of an STM action (and have any effects it's made inside the action reverted)?
21:51:43 <Axman6> ah, nevermind, i was doing something stupid
21:51:55 <kmc> did you find the answer?
21:52:32 <Axman6> i believe it's yes. i was forgetting to write to a synchronisation MVar that was supposed to let a parent thread know when the child had finished -_-
21:53:57 <_Ray_> the fact that this works was sort of surprising
21:54:00 <_Ray_> :t flip id
21:54:01 <lambdabot> forall a b. a -> (a -> b) -> b
21:54:22 <shachaf> _Ray_: ($) = id, so why not?
21:54:28 <sunil> can any one tell me why haskell is needeed?
21:54:32 <_Ray_> because
21:54:33 <_Ray_> :t flip
21:54:35 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
21:54:40 <kmc> i've got a good feeling about this
21:54:40 <ion> :t Prelude.flip
21:54:41 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:54:52 <_Ray_> I didn't see how id matched a -> b -> c
21:55:10 <kmc> id :: (d -> d)
21:55:12 <shachaf> _Ray_: id :: z -> z
21:55:17 <Axman6> sunil: that's not a very good question. haskell isn't needed, we can do everything with assembly. it's _useful_because it makes life easier
21:55:23 <kmc> a -> b -> c  =  a -> (b -> c)
21:55:25 <_Ray_> Right, and what is the z such that z -> z is a -> b -> c?
21:55:35 <kmc> now unify (a -> (b -> c)) with (d -> d)
21:55:38 <dmwit> _Ray_: id :: (a -> a) -> a -> a
21:55:38 <kmc> d = a = (b -> c)
21:55:49 <dmwit> _Ray_: id :: (a -> b) -> a -> b -- even
21:55:51 <sunil> Ok...axman6
21:56:03 <_Ray_> well, yes, one would need to restrict a to be a function type
21:56:18 <shachaf> _Ray_: The type of id is more general than the type of ($).
21:56:19 <_Ray_> that the typesystem knew to do that was the surprising part
21:56:22 <shachaf> So you can unify them.
21:56:24 <Axman6> sunil: i could ask why is C, or Java, or python, or erlang needed, and the answer is always that they're not
21:57:28 <sunil> Axman6 : is that because they are difficult to grasp and code
21:57:36 <sunil> i don't think so?
21:57:59 <sunil> does haskell support porting ?
21:58:05 <Axman6> no, they're not needed because you can make anything you want with assembly. but they are useful because they allow us to think at a higher level
21:58:08 <shachaf> _Ray_: It shouldn't be that much more surprising than any other unification.
21:58:09 <Axman6> porting?
21:58:13 <shachaf> @ty id 'a'
21:58:14 <lambdabot> Char
21:58:23 <kmc> sunil, you can find answers to these questions on google, wikipedia, the haskell wiki, or in an introductory haskell book
21:58:25 <shachaf> @ty id chr
21:58:26 <lambdabot> Int -> Char
21:58:30 <sunil> as in port the binaries to  windows or other linux machines|?
21:58:49 <shachaf> _Ray_: There, id has type Char -> Char and (Int -> Char) -> (Int -> Char), respectively.
21:58:55 <sunil> Axman6 : sure...thanks !
21:58:57 <Axman6> GHC can compile binaries on windows, linux, OS X, solaris, freebsd, and some other operating systems
21:59:11 <Jafet> kmc: is that a challenge
21:59:13 <_Ray_> shachaf, it's sort of like, I see it with actual types, but being done with type variables themselves was interesting.
22:00:37 <Axman6> shachaf: if you find programming fun, haskell is a fantastic language to learn, because it opens your mind to many new ways of doing things that you won't find in languages like C, Java, Python, C# etc.
22:00:44 <Axman6> bleh, he left -_-
22:00:46 <shachaf> Axman6: Good to hear!
22:00:50 <Axman6> sorry shachaf :P
22:00:51 <shachaf> Maybe I'll learn Haskell now.
22:00:59 <Axman6> shachaf: yeah, you should totz learn haskell
22:01:01 <shachaf> Nah, too much work.
22:01:19 * shachaf will stick to learning Agda or something.
22:01:30 <ddarius> shachaf: Anyway, you can do everything you can in Haskell in C#.
22:01:35 <Axman6> yeah, something easier like Agda ia probably a better place to start
22:01:55 <ion> C# even has LINQ, which is like monads but better.
22:02:05 <shachaf> ddarius: My main goal with Haskell is to go into its IRC channel and find you in it.
22:02:23 * shachaf checks ##csharp.
22:02:24 <shachaf> Nope.
22:02:27 <KirinDave> Man, I duplicated my little statistics gathering thing that was in ruby in haskell
22:02:31 <KirinDave> Using parsec was a mistake.
22:03:38 <djahandarie> Have heard that often KirinDave, unless it was a performance issue
22:03:41 <djahandarie> Haven't*
22:04:19 <Axman6> KirinDave: what are you using parsec to do?>
22:04:32 <KirinDave> Axman6: Parse a line of N floats separated by whitespace.
22:04:36 <Axman6> shit, i think i just PHP's the channel
22:04:39 <Axman6> PHP'd
22:04:52 <kmc> KirinDave, now you're going to get more parsec help than you ever wanted
22:05:14 <KirinDave> kmc: float = many space *> (P.float $ P.makeTokenParser emptyDef), not pretty.
22:05:29 <shachaf> Axman6: You mean you unPHPed it.
22:05:36 <shachaf> Finally we're free.
22:05:39 <Axman6> yeah
22:05:40 <kmc> that doesn't seem too bad to me
22:05:45 <Axman6> you can thank me later
22:05:48 <kmc> but neither does (map read . words)
22:05:53 <shachaf> <? echo 'thanks!';
22:05:57 <KirinDave> kmc: Indeed.
22:05:57 <kmc> if that's really all you want
22:06:00 <Axman6> kmc: heh
22:06:03 <KirinDave> kmc: That's all i wanted.
22:06:54 <Axman6> ?>
22:06:55 <lambdabot> Maybe you meant: . ? @ v
22:06:58 <Axman6> heh
22:07:01 <Axman6> ??
22:07:08 <Axman6> D:
22:07:15 <KirinDave> kmc: Well that's why I shouldn't have used parsec.
22:07:34 <kmc> yep
22:08:17 <Axman6> parsed is a pretty heavyweight tool, and that's not exactly parsing, it's closer to lexing really
22:08:30 <Axman6> well, i wouldn't consider it parsing
22:09:38 <ddarius> Throw in some balanced parentheses and then it will be parsing.
22:50:10 <mun> hi
22:50:57 <mun> does "ALL v. (f(x) --> x = v) & (g(x) --> x = v)" imply that the argument to f is always the same as the argument to g?
22:51:30 <Jafet> Which haskell is this?
22:51:43 <mun> Jafet, i'm just formulating it in logic
22:52:02 <koeien> mun: I think you miss some quantifiers there.
22:52:16 <mun> koeien, over x?
22:53:10 <koeien> mun: yes
22:53:17 <mun> ok, with universal quantification over x as well
22:54:54 <koeien> i think A v. A x. (f(x) -> x=v)&(g(x) -> x=v) and split off are equivalent
22:55:33 <mun> koeien, what do you mean by split off?
22:56:05 <koeien> Av. Ax. (f(x) --> x = v) & Av. Ax. (g(x) --> x=v)
22:56:39 <mun> um
22:57:43 <mun> koeien, if so, then what i stated doesn't mean that the first argument of f and g take the same value?
22:58:27 <ddarius> koeien: You don't want to quantify v twice.
22:59:25 <mun> ddarius, quantifying over x twice is fine, right?
23:00:43 <ddarius> Actually, I misread the original so koeien's version is fine.
23:02:18 <ddarius> This predicate does not seem to connect f and g at all.
23:02:51 <mun> ddarius, right. perhaps, the two shouldn't be in conjunction but rather an iff?
23:03:29 <mun> or is there some other way to properly connect them?
23:04:40 <koeien> i'm not sure what you're trying to state. injectivity?
23:05:04 <koeien> forall x.y. f(x) = g(y) --> x = y
23:05:35 <ddarius> Indeed.  "The argument of f is always the same as the argument to g" doesn't make much sense.  Regardless of what f and g are, unless their domain is empty or the singleton, I can pass whatever I want to each.
23:05:36 <koeien> err, something like injectivity
23:05:50 <mun> koeien, well, not quite injectivity because ALL x y. f(x) = g(y) isn't necessarily true.
23:06:14 <ddarius> Injectivity doesn't require that.
23:06:36 <koeien> well, injectivity is defined on 1 function right
23:07:19 <mun> basically i just want to specify that two functions f and g should always take the same value as argument.
23:08:10 <koeien> "always"? do you mean over time?
23:08:23 <koeien> that's not really how functions work
23:10:07 <Cale> forall x. x in dom(f) <=> x in dom(g)?
23:10:20 <mun> koeien, sorry, no didn't mean to consider time, as such. let me rephrase: the argument of f takes the same value as the argument of g.
23:10:32 <Cale> mun: what?
23:10:54 <koeien> it'd probably help if you'd probably some context :)
23:11:06 <Cale> mun: (That doesn't quite clarify what you mean -- functions don't *come* with their arguments.)
23:11:14 <ddarius> mun: Unless you are going to restrict them to a singleton domain, that makes no sense.
23:11:54 <koeien> maybe f :: (a -> b) -> c, and g :: (a -> d) -> e ?
23:12:01 <ddarius> Except by limiting the domain, how functions are used are not properties of the functions.
23:12:28 <koeien> 'the argument of f takes the same type as the argument of g'. but that's probably not what mun meant
23:12:34 <ddarius> Cale: Extensionality: dom(f) = dom(g)
23:12:47 <Cale> ddarius: indeed
23:13:54 <mun> i'm not sure if i'm after something on the meta-level. an example is...
23:14:22 <Cale> mun: Are you trying to say that the set of values to which it is valid to apply f is the same as the set of values to which it is valid to apply g?
23:15:50 <Cale> mun: yes? no?
23:15:50 <ddarius> Cale: It seems like he's going after some notion of well-formed formulae where it is invalid to have f(x) and g(y) in the same formula if x /= y.
23:16:08 <Cale> Well, that's interesting.
23:16:35 <mun> given f(x) and g(y), i want to say that x and y always "refer" to the same "thing"
23:16:59 <Cale> mun: So, given two elements of the codomain of f and g...
23:17:14 <ddarius> mun: Is this the example you were going to produce or response to Cale?  If the latter, kindly produce the example.
23:17:15 <Cale> You want to say that their preimages have to be equal?
23:17:33 <Cale> (and unique?)
23:17:41 <Cale> f and g are injective functions?
23:18:26 <Cale> Why are you using scare quotes around refer and thing?
23:18:38 <mun> hmm
23:19:02 <mun> Cale, well i'm using those terms very vaguely
23:19:10 <ddarius> Cale: 'don't want you to form misapprehensions that these "things" are things.  It might lead you astray.
23:19:38 <Cale> mun: It might help to be more precise here.
23:19:58 <Cale> In fact, let's be perfectly concrete
23:20:12 <ddarius> Cale: Are real numbers things to you?
23:20:34 <Cale> ddarius: In the appropriate context :)
23:20:50 <Cale> Let's define some sets and then try to define some functions which satisfy your desired condition
23:21:11 <ddarius> Cale: I'm asking for your view in your ontology.
23:21:39 <mun> let me try to construct something more concrete
23:21:45 <Cale> ddarius: In ZFC, they exist as sets.
23:22:01 <Cale> So let's choose A = {apple, blueberry, grape}, and B = the natural numbers
23:22:16 <ddarius> Cale: Does ZFC talk about things in your ontology?
23:22:35 <Cale> can you give me two functions f,g: A -> B which satisfy the property you want?
23:22:47 <Cale> ddarius: I don't know what an ontology is, really.
23:22:53 <taotree> how would I have a function that would return an infinite "list" of the results of calling getLine. A data source that keeps reading from input and returning the result.
23:23:06 <elliott> taotree: That's a bad idea.
23:23:11 <ddarius> "Let's choose A = {apple, orange} and B = the singular points of the Riemann Zeta function."
23:23:17 <Cale> taotree: fmap lines getContents
23:23:19 <elliott> fmap lines getContents...
23:23:20 <elliott> But really.
23:23:23 <elliott> You don't want to do that.
23:23:32 <dolio> Why doesn't he want to do that?
23:24:06 <elliott> dolio: Well, I'm a knee-jerk anti-lazy-IO-ist. I guess it's OK for stdin most of the time, though.
23:24:19 <mun> i actually want to say that, given two theories T and T' (represented as n-ary predicates) such that their symbols align
23:24:56 <ddarius> @wn ontology
23:24:57 <lambdabot> *** "ontology" wn "WordNet (r) 2.0"
23:24:57 <lambdabot> ontology
23:24:57 <lambdabot>      n : the metaphysical study of the nature of being and existence
23:25:09 <Cale> Sounds dumb.
23:25:13 <mun> say, i'm representing a theory T with a language {a,b,c} with a predicate P(x,y,z) where x corresponds to a, y to b, etc.
23:25:21 <taotree> thanks
23:25:27 <Cale> Metaphysical -> die die die
23:26:11 <Cale> Anyway, it should be obvious that there isn't one definition of existence.
23:26:20 <Cale> or being
23:26:30 <Cale> or truth
23:26:35 <mun> now is there a logical way to express that symbols across theories align? i'm just thinking that it might be be equivalent to aligning the arguments of a predicate.
23:26:42 <ddarius> @wn epistemology
23:26:43 <lambdabot> *** "epistemology" wn "WordNet (r) 2.0"
23:26:43 <lambdabot> epistemology
23:26:43 <lambdabot>      n : the philosophical theory of knowledge
23:26:55 <ddarius> @wn doxology
23:26:56 <lambdabot> *** "doxology" wn "WordNet (r) 2.0"
23:26:57 <lambdabot> doxology
23:26:57 <lambdabot>      n : a hymn or verse in Christian liturgy glorifying God
23:28:27 <Cale> mun: If S and T are theories, we can try to define a morphism f: S -> T and turn theories into a category, and then talk about isomorphisms of theories among other sorts of mappings.
23:30:17 <ddarius> @wn doxalogy
23:30:19 <lambdabot> No match for "doxalogy".
23:30:25 <ddarius> Not quite a word yet.
23:30:42 <mun> Cale, yes, but is there a way to establish such morphism without being formal and deal with categories?
23:30:52 <ddarius> What?
23:31:21 <Cale> mun: Well, once we've been formal about what the morphisms are, we get a category for free, and we can ignore that it's there if you prefer.
23:31:26 <ddarius> Dealing with categories is no more or less formal than logic.
23:32:41 <mun> right
23:32:41 <Cale> If you're going to do formal logic, there's not much point in doing it too informally.
23:33:34 <ddarius> What does "align" mean and why is it important that the symbols "align"?
23:33:36 <Cale> I think that if you're deep enough into logic to talk about theories and models, then it's silly to avoid formalism.
23:34:18 <_Ray_> Model theory is the closest I've gotten to philosophy.
23:34:35 <_Ray_> If I'm lucky, it'll remain so.
23:35:08 <mun> ddarius, basically it's a proof obligation that i want to generate: if the symbols align/if a signature morphism can be constructed between the two theories, certain things then happen.
23:35:27 * ddarius would say that people who approach a mathematical domain categorically are more formal than those who approach it in a "traditional" manner, but that logicians are more formal than categorists and most mathematicians except computer scientists.
23:35:42 <ddarius> mun: Define "align".
23:36:02 <Cale> We could define a morphism of theories S (written in language M) and T (written in language L) to be a function f from the sentences of M to the sentences of L such that whenever x is in S, then f(x) is in T.
23:36:14 <_Ray_> And at the end of the formalism spectrum, we have physicists.
23:37:00 <_Ray_> Cale: What operation does the morphism preserve?
23:37:08 <Cale> Truth.
23:37:36 <mun> ddarius, i'd say that the two symbols "always" take the same value.
23:37:57 <mun> i might not be precise enough.. please bear with me.
23:38:15 <ddarius> It's not that you are not precise enough, it's that you are not precise at all.
23:38:46 <ddarius> I recommend stepping back and taking a, perhaps excessively, formal approach to your entire problem until what is actually needed is clearer.
23:39:44 <Cale> mun: Is this for a course, or are you just randomly studying logic, or what?
23:41:44 <mun> Cale, this is for extending my final year project.
23:42:02 <Cale> Perhaps with more context, we can try to understand what you need better?
23:42:40 <Cale> You wouldn't happen to be the mun who wrote Frag?
23:43:15 <jpcooper> hello
23:43:39 <jpcooper> are Prelude.read exceptions meant to be caught by catch? I just tried catch ((fmap read getLine) :: IO Int) (const $ return 10)
23:43:51 <ddarius> jpcooper: No.
23:43:56 <jpcooper> instead of returning 10, I get an exception
23:44:15 <Jafet> Which catch?
23:44:18 <Cale> You're not meant to catch those. If you want to handle the parse failure, you're not supposed to use read
23:44:22 <jpcooper> ddarius: what can I use to catch any kind of exception?
23:44:26 <jpcooper> okay
23:44:39 <Cale> reads will give a list of parses (usually length 1)
23:44:44 <ddarius> Well, Control.Exception.catch is the only way you'll catch them, but read is a standard function (i.e. in the Report) and its exceptions are uncatchable by any function in the report.
23:44:45 <jpcooper> yup
23:45:12 <ddarius> It's best to avoid those types of exceptions altogether.
23:45:15 * shachaf wonders what it would take to get readMaybe into the standard library.
23:45:17 <mun> Cale, so basically, given two databases, theories, etc. that may be expressed in different languages, i want to assert that the seemingly different languages are actually related/same. with the assertion, one can then go on to do integration etc. now it is the assertion of the relationships between the languages that i'm having problem with.
23:45:24 <mun> Cale, oh, no. i didn't write Frag.
23:45:36 <Cale> jpcooper: Yeah, it's *possible* to catch those errors, but it's tricky and not good program design.
23:45:48 <jpcooper> is the error function meant to give IO errors?
23:45:55 <jpcooper> how can I throw an IO exception?
23:45:58 <ddarius> shachaf: In the de facto standard, just write it and propose it.  In Haskell 2011 or whatever, it would probably also be rather easy, though they'd probably want it in the "standard libraries" first.
23:45:59 <Cale> mun: Are you aware of the databases-as-categories stuff? :)
23:46:00 <Jafet> shachaf: readMaybe = listToMaybe.reads
23:46:13 <shachaf> Jafet: fmap fst
23:46:19 <Jafet> Oh
23:46:32 <Cale> http://vimeo.com/channels/galois#12428370
23:46:34 <Jafet> Okay, that might be long enough to include in the standard library
23:46:56 <koeien> jpcooper: no.
23:46:57 <shachaf> I'm tired of people being told "use reads and then match on this weird pattern".
23:47:07 <ddarius> @hackage safe
23:47:08 <lambdabot> http://hackage.haskell.org/package/safe
23:47:20 <shachaf> ddarius: Where does one propose it? GHC trac?
23:47:21 <Cale> mun: An interesting point about that view is that it makes it completely obvious how you should say that two databases are really the same.
23:47:34 <Cale> (if you know a bit of category theory :)
23:48:06 <mun> Cale, i've read about some of it, but i think i don't know enough category theory.
23:48:16 <ddarius> Cale: The Boston Haskell User Group talk that Ed filmed is much better in content/presentation than the Galois talk, though probably much worse in camera-work.
23:48:24 <koeien> jpcooper: see Control.Exception documentation
23:48:46 <Cale> ddarius: I've seen two talks by this guy, and I forgot which is which
23:48:49 <jpcooper> thanks
23:48:54 <Jafet> (hClose stdin >> getChar)
23:49:06 <ddarius> Cale: I was actually somewhat worried about the Boston talk because I felt his Galois talk was rather poorly presented, but it turned out fantastic.
23:49:39 <ddarius> Apparently there's a difference between < 24 after making the slides to > 2 monhs.
23:49:47 <ddarius> +t
23:50:54 <shachaf> http://hackage.haskell.org/trac/foo/
23:50:58 <shachaf> Maybe I should report it there.
23:52:25 <ddarius> For a Haskell 2011 proposal, there should be some designated place somewhere.  For a library proposal, you send an email to the maintainer, but who the "maintainer" of base is, I know not.  You can send an email to libraries@haskell.org and ask for guidance.
23:53:55 <ddarius> shachaf: Perhaps in the future when someone wants to parse something with read, I'll suggest that they use isBottom.  let result = read s if isBottom result then handleError else doStuff result
23:56:15 <shachaf> @let isBottom undefined = True; isBottom _ = False -- So simple!
23:56:16 <lambdabot>  <local>:1:0:
23:56:16 <lambdabot>      Warning: Pattern match(es) are overlapped
23:56:16 <lambdabot>               In...
23:56:28 <dolio> We already have that.
23:56:31 <ddarius> @hoogle isBottom
23:56:32 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
23:56:38 <dolio> isNothing . spoon
23:56:43 <shachaf> Oh, there's an actual isBottom?
23:56:50 <Jafet> Probably want teaspoon
23:58:56 <dolio> Not in the face! Not in the face!
