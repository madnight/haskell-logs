00:03:17 <roastbird> can we add comments in cabal?
00:10:02 <mgsloan> teaser: http://www.mgsloan.com/fib_apps2.png
00:13:21 <dmwit> roastbird: yep, use --
00:13:53 <ddarius> Ah, Doron.
00:16:31 <mgsloan> does the diagram above make sense to people? suggestions for a better way to associate types to parameters than color?
00:17:13 <ion> The Num a => a and [Int] colors are too close to each other.
00:17:28 <ion> My red/green color blindness may or may not be to blame.
00:18:44 <luite> hmm, they're not too close here, but I find the diagram confusing
00:19:51 <mgsloan> ion - yeah, that's definitely an issue with making colors matter.  I just picked the colors at random, so definitely possible refinement there
00:21:42 <mgsloan> luite - each line corresponds to a parameter being applied to a function
00:22:06 <mgsloan> the three circles above zipWith correspond to its three parameters
00:22:39 <mgsloan> when parameters are not single word / compact things, the lines get little brackets that indicate which range in the source they're referring to
00:23:19 <luite> hmm, ok
00:23:39 <mgsloan> this is intended initially as a tool for haskell noobs, and also an experiment in providing type information to the programmer at edit-time
00:25:25 <luite> I'm not sure if this kind of diagram would help me much, maybe I need to get used to it
00:25:39 <mgsloan> I think it is more helpful if you can interact with it
00:25:54 <mgsloan> this is a little interactive widget
00:26:23 <mgsloan> so you can experiment with it and see how it corresponds to your understanding of haskell's parse tree / typing
00:26:30 <luite> are you going to add support for emacs or something?
00:26:49 <mgsloan> maybe... probably not.  It depends on if emacs allows you to do arbitrary graphics on the buffer
00:27:12 <luite> then I might use it, I've been looking for type info in the buffer before, but nothing really works
00:27:59 <mgsloan> considering making an ActiveHs plugin that vends out these diagrams, as I'm already using some of its code, so may as well return the favour :P
00:28:07 <luite> hmm, not sure, it does allow bitmaps in the buffer, but I think you might be able to do this with some clever font locking
00:28:30 <mgsloan> hehe, use extended ASCII / unicode stuff
00:29:33 <luite> what do you use to get the type of some expression?
00:31:06 <luite> and for:  (1::Int)
00:31:08 <luite> oops
00:31:28 <luite> and for:  (1::Int) + a, what does it say if I request the type of a?
00:31:51 <mgsloan> ah :D
00:32:50 <mgsloan> I'm hoping that doing something like ":t let a = undefined; expr = (1::Int) + a in a
00:32:57 <mgsloan> will get me there
00:33:42 <mgsloan> currently this is only working on Decls, though, so a will need to be in scope
00:33:52 <luite> those specialized types will be much for useful (at least for me, I have hoogle for he rest :) )
00:34:10 <mgsloan> there is the issue of context making something that's polymorphic, monomorphic
00:35:15 <mgsloan> in some cases you might want to see the full polymorphic types, though, so I'll probably make it toggleable
00:35:41 <luite> yeah that's a good idea
00:39:25 <morphles> Hm I'm Looking for function with signature "(Eq a) => a -> [a] -> [[a]]" Well basically I'm looking for function to split string at specific delimiter, but i guess this can be more general. And I think i fail at hoogle... Any suggestions for such function? I found regex split, but I don't really need regex I just need delimiter.
00:42:12 <morphles> Hm there is split, i see, though signature is not what i expected. Should be good though.
00:43:42 <shachaf> morphles: Data.List.Split probably has what you want.
00:44:34 <mgsloan> luite - how goes the workbook stuff?
00:46:08 * hackagebot operational 0.2.0.3 - Implement monads by specifying operational semantics.  http://hackage.haskell.org/package/operational-0.2.0.3 (HeinrichApfelmus)
00:46:10 * hackagebot brillig 0.3 - Simple part of speech tagger  http://hackage.haskell.org/package/brillig-0.3 (EricKow)
00:46:13 <morphles> How come I can only import Data.List and not Data.List.Split? I guess I'm missing some library? Of course importing Data.List did not give me split function.
00:47:33 <luite> mgsloan: working on the front end, wiki/login stuff, a bit slower than I had hoped...
00:48:23 <mgsloan> It always is... good to hear that you're at it! looking forward to a release
00:49:57 <luite> I must try to resist the temptation to replace javascript with something else, like ghcjs :)
00:50:08 <Saizan> morphles: you've to install the package from hackage
00:51:01 <Saizan> morphles: cabal install split
00:51:01 <Rmx> Hi, I'm using panel of wxwidget to draw text. I want to round my text with boxes, and so, I need to know the size of my text. I don't know how can I know the lengh in pixel of my text. I'm stuck here, can someone help me?
00:56:55 <mgsloan> btw, you might find some of the ActiveHs code to be handy:
00:56:55 <mgsloan> https://github.com/divipp/ActiveHs/blob/master/Simple.hs / Smart.hs / Special.hs / Specialize.hs
00:57:36 <mgsloan> and yeah, I avoid webdev at all costs :D
00:59:42 <morphles> Well i managed to crete function i wanted "let split delim list = (takeWhile (delim/=) list) : (if elem delim list then split delim (tail (dropWhile (delim/=) list)) else [])"
01:00:12 <luite> mgsloan: yeah, and haskell web stuff is still all very new, lots of rough edges
01:01:21 <luite> mgsloan: oh the part that actually evaluates the code is already done
01:04:55 <shachaf> morphles: That may not be exactly the function you want.
01:05:10 <mgsloan> yup.  I'd definitely still prefer Haskell to most languages for the task, though.  Yeah, he does some pretty clever evaluation stuff http://pnyf.inf.elte.hu/fp/Economic_en.xml?yes
01:05:58 <shachaf> Oh, maybe it is.
01:06:43 <shachaf> But there are probably nicer ways to implement it, e.g. with break/span.
01:08:13 <mgsloan> I gotta hit the hay. ttyl!
01:09:21 <morphles> shachaf: thanks for all advice. Some time later maybe ill try to improve it or install module, but for now this will do perfectly fine.
01:10:21 <morphles> Though i rewriten it in file in slightly better nicer way, and probabli slightly more eficient, that avoids double list processing in if then part
01:26:09 * hackagebot brillig 0.3.1 - Simple part of speech tagger  http://hackage.haskell.org/package/brillig-0.3.1 (EricKow)
01:48:18 <Rmx> How to set or stop the auto resize in wxhaskell for widget like text fields, or button
01:49:05 <Rmx> I want to chose if they fir the text, or not
01:49:09 <Rmx> fit*
01:49:53 <Rmx> really, I'm getting crazy to not find it
01:50:04 <Rmx> because I know it's possible..
02:15:44 <augustss> yo
02:30:23 <Phyx-> augustss: hi
02:42:07 <Younder> Anyone here read 'Calendrical Calculations' by Dershowitch and  Raingold.. Recommended
02:43:00 <Younder> Dates are such a B**** to get right
02:44:47 <cheater> lol
02:47:07 <Younder> cheater, well try some-time ;)
02:47:49 <cheater> define "some" time
02:48:02 <cheater> calendrically
02:48:09 <Younder> cheater, Today...
02:48:14 <cheater> define "today"
02:48:48 <cheater> and as a follow-up, define "midnight"
02:48:50 <cheater> :D
02:49:20 <Younder> cheater, you prefer in seconds since 0:0 1.1-1970  GMT
02:49:45 <Younder> cheater, that's what my Ubuntu uses
02:49:58 <Younder> in fact all Unixen
02:52:09 <cheater> Younder, seconds in which frame of reference?
02:52:41 <cheater> i am currently exiting the solar system at near-light speed. does that mean i never have to do what you ask of me?
02:52:56 <Younder> cheater, Well we have 13 leap seconds we need to add
02:53:30 <Younder> cheater, t = t0 / sqtr(1 - v^2 / c^2)
02:53:39 <Younder> sqrt
02:54:06 <cheater> sorry?
02:54:31 <Younder> 1/ sqrt(1-v^2/c^2) is often called the gamma factor
02:54:32 <cheater> why would that apply?
02:54:35 <cheater> oh
02:54:44 <cheater> ok well you said MIDNIGHT
02:54:53 <cheater> obviously midnight ain't ever happening for me.
02:54:56 <cheater> ha.
02:55:11 <Younder> cheater, You are travelling at near light speed
02:55:17 <cheater> oh wait. *i* said midnight. bah humbug
02:55:42 <Younder> cheater, no I didn't I said 0:0
02:55:56 <cheater> :D
02:59:31 <Younder> cheater, currently only Pioneer and Voyager probes are traveling at speeds which would allow then to exit the solar system and they are traveling at well below 1% of the speed of light. You need to get up about 50% before relativistic effects become measurable
02:59:49 <Younder> for the record
03:00:14 <cheater> good to know
03:04:39 <Younder> the old physicist in /me comes out
03:05:24 <Younder> cheater, basically though I'm just a cranky old man
03:06:27 <KitB> Why would "cabal install utf8-light" work when "sudo cabal install utf8-light" doesn't
03:06:40 <cheater> old? in whose frame of reference?
03:06:52 <Younder> cheater, 43
03:07:04 <cheater> KitB, each user has his own cabal dir
03:07:24 <KitB> I should give the error, shouldn't I?
03:07:39 <Younder> KitB, It should
03:08:14 <hpaste> KitB pasted “cabal error” at http://hpaste.org/50919
03:08:47 <Younder> KitB, What is your install directory. If it is under home it would be acceptable
03:09:09 <KitB> Younder: How do I get this information?
03:10:03 <Younder> KitB, You are in tmp
03:10:37 <KitB> How do I set it to be under home?
03:10:48 <KitB> and why would this make a difference?
03:11:05 <Younder> KitB, are you using GIT instead of Darcs?
03:11:07 <cheater> Younder, i've seen much older. learn some respect for the elderly, kid.
03:11:22 <cheater> :)
03:11:33 <KitB> Younder: Erm. I'm using cabal?
03:11:39 <KitB> All on defaults.
03:11:49 <cheater> so probably darcs then?
03:11:57 <KitB> I'd assume so
03:12:03 <KitB> I'll check the package
03:12:29 <Younder> just swaw: Web site source code on Github / Real World Haskell / Haskell.org / Planet Haskel
03:12:51 <KitB> utf8-light lists its repo as being git
03:13:01 <KitB> But I assumed cabal packages were grabbed from hackage?
03:14:07 <djh__> is there any way of suggesting an edit for a hackage page?
03:15:27 <djh__> actually scrap that, when a new version of a package is uploaded to hackage, does it extract teh details from the .cabal file and put use them as a source for the "contents" page?
03:16:10 <Younder> dhj__ : emacs
03:28:44 <Saizan> djh__: yes
03:57:29 <luite> is it possible to kill all forkIO threads except the current one, freeing all resources used by them?
03:58:40 <Saizan> only if you keep track of their ThreadId, i think
03:59:26 <luite> hmm, it's code that might start new threads that I don't know of
03:59:50 <luite> perhaps better to start them in a different process then
04:00:14 <zomg> keeping track of bunch of threads was something I had to do as well
04:00:22 <zomg> and yes it seems you would need to keep track of the ThreadId
04:22:25 <rs464> Hi, can anyone tell me what cabal options I need to use to download haddock documentation with each package I download with `cabal install' ? My problem is that I am running `cabal haddock' on my own project and I receive a bunch of "Warning: The documentation for the following packages are not installed"
04:22:27 <rs464> ?
04:24:14 <luite> rs464: you should probably edit your cabal configuration to make it build haddock for all packages that you install
04:24:47 <rs464> ah yes. Good idea, is there documentation on how to do this?
04:26:11 <rs464> got it
04:26:15 <rs464> --enable-documentation
04:26:19 <rs464> thanks
04:26:42 <luite> documentation: True
04:26:44 <coppro> 1win 12
04:26:44 <luite> in your cabal config
04:27:02 <rs464> cool, thanks.
04:27:06 * rs464 changing config
04:27:18 <luite> rs464: one disadvantage though, it doesn't add source links to your cabal docs
04:27:37 <rs464> right
04:27:39 <rs464> ok
04:28:05 <luite> that's why I use a script on my own system to overwrite all docs again, to add source links, build hoogle data etc
04:40:10 <Tinned_Tuna> morning folks :-)
04:40:22 * benmachine is not a morning folk
04:41:11 <Phyx-> morning
04:42:36 <hpaste> Tinned_Tuna pasted “Still not doing Great” at http://hpaste.org/50920
04:42:40 <Tinned_Tuna> I have a question, I've written some code...
04:43:23 <Tinned_Tuna> basically, I'm getting that particular build error, but I'm not sure how to deal with it. I've tried throwing a couple of lifts at it, to no avail :-/
04:43:53 <hpaste> Eidel pasted “polymorphism” at http://hpaste.org/50921
04:44:31 <Eidel> Does anyone know how to convert an Int into a string if an Int is used? in the method above
04:44:35 <Tinned_Tuna> I was having a similar error last night, inside moveExtractFiles, which was fixed by using liftIO $ ... on the right bit
04:46:32 <Jafet> intToString = const ""
04:47:13 <Eidel> Jafet: i want to have a guard
04:47:31 <Jafet> Eidel: your code doesn't make sense to begin with
04:47:39 <Jafet> Are you sure you're using haskell?
04:47:55 <fryguybob> Eidel: Do you mean  addSpace :: Show a => a -> String ?
04:48:09 <Eidel> Jafet: Actually the 2nd line was not supposed to be there
04:48:22 <Jafet> Or it might be [a] -> String
04:48:23 <benmachine> hm
04:48:39 <Jafet> Or it could be anything, I'd wait for Eidel to explain what addSpace does
04:48:41 <Eidel> I want to be able to input either an Int or a String
04:48:54 <Axman6> hmm, we were talking ablout kinds yesterday, and i'm wondering if a in something like... Show a => a -> String has a different kind to the String, or whether there's some notion of them being different at say the level of kinds, or somewhere else
04:49:00 <fryguybob> Either Int String -> String ?
04:49:22 <Eidel> IntOrString -> String
04:49:40 <hpaste> benmachine pasted “this instance doesn't look flexible!” at http://hpaste.org/50922
04:49:46 <benmachine> oh wait
04:49:48 <benmachine> I'm silly
04:50:00 <benmachine> it is flexible.
04:50:11 <bsrk> What does ~ mean in haskell?
04:50:13 <azaq231> @kind forall a. a -> String
04:50:14 <lambdabot> *
04:50:16 <benmachine> bsrk: equality
04:50:20 <azaq231> @kind forall a. a
04:50:21 <lambdabot> *
04:50:32 <benmachine> bsrk: er, wait
04:50:36 <benmachine> bsrk: in what context?
04:50:38 <Jafet> Eidel: why Int and String in particular? What does addSpace do?
04:50:45 <bsrk> addToPending :: (RepoPatch p, ApplyState p ~ Tree)
04:50:47 <bsrk>              => Repository p C(r u t) -> FL (PrimOf p) C(u y) -> IO ()
04:50:47 <fryguybob> > let f (Left i) = show i; f (Right s) = s in (f (Left 42), f (Right "hello"))
04:50:48 <lambdabot>   ("42","hello")
04:51:06 <benmachine> bsrk: ah, in GHC with TypeFamilies, p ~ q means 'the types p and q are equal'
04:51:10 <azaq231> @kind forall t. Show t => t -> String
04:51:11 <Eidel> Jafet: im printing out a list, and it adds spaces to numbers
04:51:11 <lambdabot> *
04:51:26 <Eidel> azaq231: ill try it out!
04:51:57 <bsrk> ApplyState p is equal to Tree? What does that mean?
04:52:04 <benmachine> bsrk: I assume ApplyState is a type family
04:52:04 <azaq231> Ed
04:52:07 <benmachine> do you know about those?
04:52:23 <Jafet> Eidel: ...a list of strings and numbers? What's the type of that?
04:52:32 <bsrk> Like Integral?
04:52:37 <azaq231> Eidel: What I tried was directed at Axman6's question regarding the kind of the type variable a in the types a -> String and related
04:53:21 <Axman6> hmm, it feels odd that they have equal kinds
04:53:25 <Eidel> azaq231: aha. I saw similar lines when i read the wikibooks article about polymorphism..
04:53:46 <Axman6> i mean, String is concrete, it is the one true String, but a could be anything*
04:53:47 <Eidel> Jafet: The end results is a long String
04:54:20 <Jafet> Now I'm getting confused.
04:54:48 <bsrk> Okay I will look into type families. Thanks.
04:55:10 <azaq231> Axman6: But kinds only signify whether something is a type constructor (taking a concrete type to produce a concrete type (in case of one argument, * -> *)) (which is a function on the type level,
04:55:11 <azaq231> basically), or whether something is concrete, so, can be used as every other type
04:55:34 <azaq231> Axman6: If forall a. a wasn't of kind *, how could you construct Maybe a? After all, Maybe :: * -> *
04:55:34 <Jafet> Eidel: describe in plain english what kind of input addSpace takes, what it does to the input, and what it returns.
04:55:44 <Axman6> hmm
04:55:48 <Jafet> Crap, I said kind
04:57:44 <Eidel> Jafet: it should be able to take one String or an Int. If the input is an Int it should convert it into a String, and recusively add a whitespace at the end at the string until the string has the length 10
04:58:08 <Jafet> ...and if the input is a String?
04:58:15 <Eidel> Just add whitespace
04:59:55 <Jafet> That sounds unwise. But if you want polymorphism that way, you express it with a typeclass...
05:00:50 <Eidel> Maybe i just should convert the input variables?
05:01:02 <hpaste> Jafet annotated “polymorphism” with “polymoarphism” at http://hpaste.org/50921#a50923
05:02:08 <Eidel> Jafet: thanks! Nice code too.
05:02:21 <Jafet> Now I regret writing that.
05:02:42 <Eidel> and why is that?
05:06:13 <Jafet> Because it is wrong
05:06:38 <Eidel> I really trying to learn the spirit of haskell
05:07:04 <Eidel> I assume its better to convert the integers into string before using the funciton
05:07:07 <Jafet> Well, it is wrong in most languages generally
05:11:44 <Jafet> > printf "%10d" 1 :: String
05:11:45 <lambdabot>   "         1"
05:12:33 <Jafet> > printf "%-10d" 1 :: String
05:12:34 <lambdabot>   "1         "
05:13:30 <Jafet> But printf is too polymorphic for you
05:25:00 <moroten> what is the best way to do a type checked input? for example if the program needs to ask for age and the user types in "foo" (not a number) the prompt should appear again until a number is given.
05:25:19 <moroten> in some old code i found a function that is apparently not existing anymore: promptAgain
05:25:31 <moroten> all the way i can come to think about are pretty bulky
05:25:52 <koeien> yes, unfortunately it is a bit bulky.
05:25:56 <koeien> you should look into reads
05:26:01 <vokoda> how do I define an abstract sequence? e.g. if I want to adapt `foo = 0 : 1 : [ (a*b)+1 | (a, b) <- zip foo (tail foo)]` to add an arbitrary letter 'n' to the product of `a` and `b` instead of 1
05:26:06 <koeien> :t reads
05:26:07 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:26:24 <vokoda> *arbitrary number
05:26:39 <koeien> > reads "37" :: [(Integer, String)]
05:26:40 <lambdabot>   [(37,"")]
05:26:50 <koeien> > reads "not an integer" :: [(Integer, String)]
05:26:51 <lambdabot>   []
05:27:35 <moroten> thanks
05:27:53 <koeien> @let maybeRead = fmap fst . listToMaybe . reads
05:27:54 <lambdabot>  Defined.
05:28:01 <koeien> > maybeRead "37" :: Maybe Integer
05:28:03 <lambdabot>   Just 37
05:28:11 <koeien> > maybeRead "not an integer" :: Maybe Integer
05:28:13 <lambdabot>   Nothing
05:29:05 <koeien> vokoda: do you mean   foo n = let xs =  0:1:[a*b+n | (a,b) <- zip xs (tail xs) in xs
05:30:05 <vokoda> koeien: perhaps, let me see what that does
05:30:50 <koeien> if i'm not mistaken, your first definition is also subject to the monomorphism restriction, but that does not matter if you assume Integer
05:33:08 <vokoda> koeien: can I type it literally as you did? I'm getting `parse error on input `in'`
05:33:14 <koeien> vokoda: i missted the ]
05:33:22 <koeien> vokoda: after )
05:34:33 <saml> what is LLVMXCoreAsmPrinter? I can't find it from llvm
05:34:50 <vokoda> koeien: yeah, this does what I want - thanks. now to understand why..
05:35:11 <koeien> vokoda: do you understand the first definition? (without the n)
05:35:47 <chessguy> wow, #haskell is amazingly active for this hour of the morning
05:36:02 <vokoda> koeien: yes
05:36:13 <koeien> chessguy: i am in europe :)
05:36:39 <koeien> vokoda: the next one is not that much more complicated. let ... in ... binds variables
05:36:45 <koeien> > let x = 5 in x
05:36:46 <lambdabot>   5
05:36:57 <koeien> > let x = 1:x in x
05:36:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:37:53 <vokoda> koeien: I see. why do you need to bind the sequence to a variable to return it?
05:38:10 <koeien> vokoda: it's not necessary. You can write the following as well
05:38:44 <koeien>  foo n = [0:1:a*b+n | (a,b) <- zip (foo n) (tail (foo n))]
05:39:35 <koeien> foo n = 0:1:[a*b+n | (a,b) <- zip (foo n) (tail (foo n))] -- correction
05:40:24 <koeien> However, the first definition is (likely to be) more efficient
05:40:47 <vokoda> aha, got it. thanks koeien
05:41:42 <vokoda> ok
06:08:54 <moroten> koeien: i can not get it to work (sorry for beeing a noob). could you take a look at my code: http://hpaste.org/50924
06:09:52 <Botje> moroten: promptForInt has type String -> IO Int
06:10:01 <Botje> moroten: but return (promptForInt ...) has type IO (IO Int)
06:10:23 <Botje> drop the return in that case and your types are okay
06:10:53 <koeien> yes
06:11:59 <moroten> so i should drop return in the "Nothing" line?
06:12:23 <koeien> moroten: yes. just promptForInt msg
06:13:09 <jmcarthur> moroten: this appears to indicate a common misunderstanding that return acts like the return from imperative languages. in my opinion, it is poorly named
06:13:24 <moroten> thanks
06:14:01 <jmcarthur> moroten: all it actually does is transform a value into an action which yields that value
06:14:25 <jmcarthur> moroten: since you applied it to an action, it gave you an action which yields an action
06:15:29 <koeien> instead of an action that yields an integer
06:18:08 <Botje> return = trace "useless use of return found!"
06:18:09 <Botje> >:)
06:18:44 <jmcarthur> "useless use" uh huh
06:19:04 <ski> moroten : if you wanted to, you *could* replace
06:19:09 <ski>   Nothing    -> promptForInt msg
06:19:10 <ski> by
06:19:14 <ski>   Nothing    -> do
06:19:18 <ski>     n <- promptForInt msg
06:19:21 <ski>     return n
06:19:38 <jmcarthur> you could, but why would you want to? ;)
06:20:03 <ski> those two are equivalent, but one usually does the former, since it's shorter (and in some cases it could be more efficient)
06:20:28 <ski> well, it's good to know that if you every writes the latter, you can replace it by the former :)
06:21:04 <jmcarthur> if return wasn't a taken name already, i would use it as the name for the continuation when using callCC
06:21:18 <Axman6> ret
06:21:43 <koeien> pure
06:22:03 <koeien> instead of return
06:22:39 <jmcarthur> Axman6: sure. i was only saying that to further drive home that having return in the Monad type class is pretty far from how people (or at least I) normally understand the word
06:23:00 <Axman6> agreed
06:37:18 <kmc> i wonder how hard it would be to compile Core to SML
06:38:03 <koeien> what would be the purpose of such an exercise?
06:38:19 <jmcarthur> kmc: if core ever completely makes the transition to being strict then probably not hard
06:38:31 <kmc> i have no purpose in mind
06:38:52 <kmc> i thought the deal with laziness in Core is that thunks are only allocated by "let" and only forced by "case"
06:39:05 <kmc> which would make translation to a strict language fairly straightforward
06:39:21 <kmc> also, typeclasses are desugared to dictionary passing
06:39:50 <ski> SML doesn't have polymorphic recursion
06:40:10 <kmc> that's sad
06:40:17 <ski> yes
06:41:44 * ski suspects this maybe is a consequence of finding H-M inference so fun that they figured one'd never want to add explicit annotations for operations, in modules
06:42:14 <ski> (or maybe the idea of polymorphic recursion wasn't that well-understood at the time ML was created)
06:43:19 <kmc> what are the most important use cases of polymorphic recursion?
06:46:23 <ClaudiusMaximus> kmc: edwardk gave me an example of type tagged multi-precision arithmetic where precision can be increased at runtime
06:47:16 <ClaudiusMaximus> kmc: i didn't quite understand it all, but polymorphic recursion was the key to making it work as far as i could gather
06:47:23 <jmcarthur> recursive functions with GADTs aren't very useful without polymorphic recursion, i think
06:47:50 <luite> is there something similar to forkProcess that works on Windows?
06:52:15 <kmc> ClaudiusMaximus, interesting
06:52:24 <kmc> i wonder if that's the implicit configurations stuff, or something else
06:52:32 <kmc> implicit config does depend on polymorphic recursion
06:55:03 <monochrom> in core, "case" forces and is the only force, but "let" is not the only thunk creator. you will see things like "case ... { ... -> expression }" or even "case ... { ... -> (# state#, expression #) }", the "expression" becomes a thunk too
06:55:44 <monochrom> type classes are desugared
07:00:30 <hpc> ooh, how to type classes get desugared?
07:00:46 <hpc> is it just a bunch of fmap_IO, fmap_Maybe, etc?
07:02:59 <kmc> hpc, you can't always know at compile time which instance will be used
07:03:02 <ClaudiusMaximus> kmc: http://tunes.org/~nef//logs/haskell/11.08.19 starting around 11:11
07:03:04 <ski> there's ways to encode interesting shapes of data structures, using non-regular data types, and you usually need polymorphic recursion to be able to do much with those
07:03:35 <ski> a well known example is a perfectly balanced binary tree, i.e. with number of elements being a power of two
07:03:38 <kmc> hpc, so you pass around "dictionaries" of type-class methods
07:04:02 <kmc> data NumDict a = NumDict { addMethod :: a -> a -> a; fromIntegerMethod :: Integer -> a; ... }
07:04:12 <ski> another example ia having a list (or array or whatever) of trees, all of which must have the same shape (but can have differing elements)
07:04:15 <kmc> type class constraints behave like implicit parameters
07:04:43 <hpc> kmc: ah
07:06:16 * ski wonders whether one can do fibonacci heaps using non-regular types
07:07:46 <Saizan> gadts also tend to need polymorphic recursion
07:10:02 <kmc> anyone know why GHC dislikes lines starting with # in .lhs files?
07:10:45 <parcs> CPP
07:11:11 <kmc> it dislikes full CPP directives too
07:11:25 <kmc> i didn't turn on -XCPP
07:25:58 <Tinned_Tuna> Good god I suck at haskell :-(
07:26:36 <Botje> and you have an exam coming up, i guess?
07:26:59 <Tinned_Tuna> Botje: nope, I'm just trying to see if I can use Haskell in place of python.
07:27:12 <Tinned_Tuna> I'm decent enough with Python, but I'd really like to know Haskell well.
07:27:20 <kmc> it takes a long time to know Haskell well
07:27:39 <Tinned_Tuna> kmc: well, I'd like to be decent enough :-p
07:28:00 <kmc> i mean it takes a long time to know Haskell well enough that it's the right tool for *any* practical problem
07:28:10 <merijn> Tinned_Tuna: You can always take the imperative approach and do Haskell by stuffing everything into IO :p
07:28:39 <kmc> learning how to use IO effectively in Haskell is its own challenge, though
07:28:49 <merijn> True
07:29:01 <Tinned_Tuna> merijn: I'm trying, but failing
07:29:12 <Tinned_Tuna> http://hpaste.org/50920
07:29:19 <merijn> But there's a long road between "grokking IO" and "advanced haskell" :p
07:29:49 <Tinned_Tuna> merijn: I've graduated. I have a day job coding Java. I have time to walk a long road now :-)
07:30:05 <kmc> the more Haskell you learn, the more you will hate your day job coding Java
07:30:12 <kmc> i'm not joking about this
07:30:15 <merijn> God, don't remind me that I need to start looking for a job after graduating >.>
07:30:19 <Tinned_Tuna> and as soon as I get put down as staff correctly, I'll have access to the library. Then I'll be away
07:30:41 <Tinned_Tuna> kmc: My freelance stuff has almost entirely been done in Python
07:30:54 <Tinned_Tuna> writing Python then trying to write Java is *pain*
07:31:25 <merijn> word
07:31:30 <kmc> yeah, it will be a lot worse with Haskell
07:31:39 <kmc> because it's expressive like Python, but it also actually catches mistakes for you
07:31:44 <ski> @type (System.FilePath.</>)
07:31:44 <lambdabot> FilePath -> FilePath -> FilePath
07:31:45 <merijn> Writing Java after almost any other language is a pain :p
07:31:58 <ski> Tinned_Tuna : you should use that instead of `... ++ "/" ++ ...'
07:32:05 <Tinned_Tuna> This is fine, in a Year's time I'm intending to go get a job down south
07:32:09 <Tinned_Tuna> (if I can find another)
07:32:12 <merijn> kmc: Yeah, haskell ruined python for me :(
07:32:15 <Tinned_Tuna> oo, wow, thanks! :-D
07:32:20 <merijn> I used to be happy :p
07:32:26 <Botje> this FSMonad thing is a bit weird
07:32:32 <hpc> merijn: you should try using haskell and perl at the same time
07:32:43 <hpc> it's... very strange
07:32:45 <merijn> hpc: I never got into the madness that is perl
07:33:03 <ski> btw, you know in `do', instead of
07:33:05 <ski>   let foo = ...
07:33:08 <ski>   let bar = ...
07:33:10 <ski> you can do
07:33:13 <ski>   let foo = ...
07:33:17 <ski>       bar = ...
07:33:32 <hpc> i wrote a CPS transform of a huge perlmagick function just for fun
07:34:54 <Tinned_Tuna> neat :-D
07:36:03 <Tinned_Tuna> Any ideas about the FSMonad stuff?
07:36:22 * hackagebot dx9base 0.1 - Backend for a binding to the Microsoft DirectX 9 API.  http://hackage.haskell.org/package/dx9base-0.1 (KidoTakahiro)
07:36:24 * hackagebot dx9d3d 0.1 - A binding to the Microsoft DirectX 9 API.  http://hackage.haskell.org/package/dx9d3d-0.1 (KidoTakahiro)
07:36:34 <mistertim> Hi all!
07:36:49 <Tinned_Tuna> hello
07:37:33 <jmcarthur> Tinned_Tuna: the problem is you are trying to use IO as though it is an instance of FSMonad
07:37:36 <hpc> Tinned_Tuna: never used it, looks kind of silly
07:37:46 * ski hasn't used `FSMonad', but would try to use something from `Control.Exception' (or something similar) to close connections even in event of error
07:37:49 <Botje> Tinned_Tuna: i'm not sure what the purpose of this FSMonad is.
07:38:08 <hpc> Botje: it looks like some sort of chroot thingy
07:38:33 <Tinned_Tuna> It looks like the FileSystem monad to me ...
07:38:36 <Tinned_Tuna> http://hackage.haskell.org/packages/archive/FileSystem/1.0.0/doc/html/System-FileSystem.html
07:38:46 <Botje> Tinned_Tuna: IO also has these moveFile and removeFile things
07:39:01 <Botje> that FS monad is apparently if you want to crete transactions in the filesystem or something
07:39:17 <mistertim> Quick question -  I've written a function to find the order of magnitude (to base 10) of an Int: "order n = 10 ^ (floor $ logBase 10 n)", but I've got a slight problem in that I'm getting rounding errors - eg "logBase 10 10000 = 2.99999999999996". Any ideas of a better way of doing this?
07:39:26 <Botje> Tinned_Tuna: check System.Directory's renameFile and removeFile
07:39:31 <Botje> Tinned_Tuna: they have proper IO types
07:39:31 <jmcarthur> Tinned_Tuna: if you want to stick with this FSMonad stuff then you will need to apply one of its run functions at some point
07:39:40 <kmc> mistertim, don't use floating point
07:40:07 <mistertim> kmc aha - so I should coerce somehow to a fixed point form, or use an integer log function (if there is one?)
07:40:10 * ski . o O ( `withFS :: FS -> (forall m. FSMonad m => m a) -> IO a' )
07:40:15 <Tinned_Tuna> I don't particularly care about sticking with any single monad, I more want it to work...
07:40:30 <byorgey> mistertim: just keep doing integer divides by 10 and count how many it takes to get to zero
07:40:34 <hpc> mistertim: there's CReal, but it's slow and has a lot of edge cases where it doesn't terminate
07:40:35 <merijn> mistertim: 9 times out of 10.00000000000018754817 you don't want floats :)
07:40:52 <mistertim> byorgey - great idea! I can do it with a fold I reckon
07:40:54 <kmc> > let oom n = find (>= n) (iterate (*10) 1) in (oom 7, oom 29, oom 9000)
07:40:54 <lambdabot>   (Just 10,Just 100,Just 10000)
07:40:54 <mistertim> thanks all
07:41:03 <hpc> logarithms don't produce rational numbers, so Rational Integer is out of the question too i think
07:41:15 <mistertim> actually, kmc's is even better
07:41:25 <mistertim> thanks guys!
07:41:26 <byorgey> oh, indeed
07:41:26 <hpc> or that
07:41:32 <ClaudiusMaximus> :t find
07:41:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:41:36 <jmcarthur> Tinned_Tuna: try applying runFST to your moveExtractFiles line with some FSState. either that or just don't use this FSMonad stuff at all
07:41:38 <Tinned_Tuna> Thanks guys, I'm going to see fif I can hack it to use System.Directory
07:41:39 <kmc> there are probable more efficient ways
07:41:47 <kmc> but it also probably does not matter
07:42:00 <Tinned_Tuna> jmcarthur: that seems simpler, I'll try that, then try re-structuring
07:42:07 <Tinned_Tuna> I'll be off hacking for a few minutes :-)
07:42:10 <Tinned_Tuna> Thanks!
07:42:25 <hpc> kmc: 10 * length (show x)
07:42:25 <mistertim> It'll only ever be called once, right at startup of my program so O(log10 n) is alright :-)
07:42:33 <hpc> where x is an integer
07:42:35 <kmc> hpc, pro
07:42:48 <mistertim> hpc - hah! awesome
07:43:22 <mistertim> lateral thinking goes great with haskell
07:43:24 <telemyst> can haskell change the way you think?
07:43:25 <mistertim> :-)
07:43:32 <kmc> yes
07:43:36 <hpc> f power_of_ten = 10 * actual_oom though
07:43:46 <hpc> not sure if that boundary behavior is important to not have
07:43:48 <merijn> @faq can haskell change the way you think?
07:43:48 <lambdabot> The answer is: Yes! Haskell can do that.
07:44:06 <Tinned_Tuna> jmcarthur: as in runFST $ moveExtract ... ?
07:44:16 <Tinned_Tuna> ah, with state
07:44:19 <Tinned_Tuna> maybe I'll avoid it.
07:44:36 <n0den1te> merijn: that's not a good faq, if lamdabot answers everything in the affirmative. :P
07:44:54 <n0den1te> @faq what is lambdabot?
07:44:54 <lambdabot> The answer is: Yes! Haskell can do that.
07:45:21 <telemyst> isnt the a worry? haskell could be damaging
07:45:40 <kmc> yeah
07:45:56 <kmc> it's damaging to your ability to enjoy a job programming in PHP or Java
07:46:09 <n0den1te> kmc: No! :D
07:46:21 <Botje> Tinned_Tuna: the FSState needed by runFST can be acquired using capture/release from System.FileSystem.IO
07:46:22 <monochrom> someone actually blogged that he felt miserable at work since learning haskell
07:46:40 <mistertim> telemyst kmc: I've found myself reimplementing (or at least approximating) bits of haskell in Ruby for my day job - it doesn't make you popular with non-Haskell colleagues
07:46:48 <kmc> yep
07:46:51 <mistertim> but it makes the working day infinitely more interesting :-)
07:46:55 <luite> hmm, are there programming languages that you could learn to make a PHP programming job more enjoyable?
07:47:05 <hpc> monochrom: eventually you get annoyed at the hoops you have to go through to get certain language constructs to work
07:47:07 <mistertim> luite: brainf*ck
07:47:07 <monochrom> BASIC
07:47:14 <hpc> like short-circuiting method returning
07:47:15 <n0den1te> heh. I often find myself typing fromX in method names for Java.
07:47:20 <kmc> s/programming languages/heavy drinking/
07:47:22 <hpc> blah() {
07:47:25 <hpc> return x;
07:47:28 <hpc> thisdoesntrun();
07:47:35 <mistertim> or programming actual mechanical turing machines
07:47:49 <n0den1te> and isolating printing stuff to separate methods. aka IO.
07:48:48 <Tinned_Tuna> The System.Directory shenanigans worked!
07:48:51 <n0den1te> haskell ruined my Java experience that I cannot look forward to getting back to work, any given day. :(
07:49:23 <Tinned_Tuna> Me and my coworker forever joke that Java is on it's way to being like COBOL
07:49:28 <Tinned_Tuna> *My coworker & I ...
07:49:31 <Botje> Tinned_Tuna: hooray!
07:49:31 <kmc> that's no joke
07:49:39 <Tinned_Tuna> Thanks guys :-D
07:49:39 <kmc> a lot of java programmers acknowledge that at this point
07:49:43 <Botje> n0den1te: so write scala. to the untrained eye it looks just like java :)
07:49:50 <kmc> there's a scramble to make the next language to run on the JVM
07:49:52 <n0den1te> Tinned_Tuna: yeah, sort of. it's showing its age though. Many are now switching to Scala.
07:49:56 <Tinned_Tuna> kmc: how come we're so numerous then?
07:50:23 <Tinned_Tuna> I thought Scala was still mostly a research project? I.e. the tool chain was moving to fast for most businesses to target?
07:50:36 <n0den1te> Botje: that's what you think. Imperatively written, it looks like Java. get to generics and higher typing, it gets hairy.
07:51:07 <Botje> n0den1te: hence 'untrained eye' ;) I wrote a typechecker in scala in July
07:51:08 <kmc> if you look at Ceylon it's clearly "how can we make Java 10% less shit, but only 10% because anything more is just too radical"
07:51:23 <kmc> and there's two or three other languages targeting that niche
07:51:59 <kmc> if you want something like Java but semi-modern, use C#
07:52:07 <n0den1te> Botje: whoa... mind sharing the code? :)
07:52:40 <kmc> there's a number of #haskellers employed writing Scala code
07:52:43 <n0den1te> kmc: Ceylon's still vaporware at the moment. I trust the Hibernate folks can pull it off
07:52:53 <Tinned_Tuna> C# in a Solaris/Debian environment?!
07:53:04 <n0den1te> Tinned_Tuna: yeah, mono.
07:53:32 <Botje> n0den1te: if you're interested .. it's a gradual typing system for a language that is a cross between smalltalk and javascript
07:54:07 <n0den1te> Botje: yes, I'm interested. though from what you say, it sort of sounds like coffeescript.
07:54:19 <zmv> roflmao C#
07:54:22 <zmv> hahahahahhahahaha
07:54:41 <Botje> I rather like C#
07:55:08 <zmv> well, it's not *that* bad. it's just bad.
07:55:18 <jmcarthur> i prefer it to, say, Java
07:55:20 <n0den1te> C# did a few things that java should have done a long time ago, but the jvm/java folks at Sun stuck to their guns citing backward compatibility.
07:55:26 <kmc> yeah
07:55:34 <kmc> it has the same basic design ideas as Java, but actually follows through on those ideas
07:55:46 <kmc> Java seems to be crippled for the benefit of some hypothetical "average programmer"
07:55:59 <hpc> the java programmer is definitely average
07:56:06 <kmc> which, it being a committee design, means the lowest common denominator
07:56:11 <Tinned_Tuna> builds and "works" ... in terms of, fills up my RAM :-(
07:56:20 <jmcarthur> i get the same impression from python
07:56:30 <jmcarthur> minus the committee design
07:56:34 <roconnor> C# is better than Java?
07:56:37 <Tinned_Tuna> n0den1te: C# on solaris??
07:56:41 * roconnor makes a note to learn C#
07:56:48 <Tinned_Tuna> Debian I can totally see, but Solaris??
07:56:54 <roconnor> is there a gnu C# complier?
07:56:59 <Tinned_Tuna> roconnor: there's mono.
07:57:01 <kmc> Python definitely has a lot of fancy enough-rope features
07:57:01 <n0den1te> Tinned_Tuna: not sure about solaris, but there are mono builds that can run on *nix machines.
07:57:23 <kmc> though Java has some too, e.g. reflection
07:57:48 <n0den1te> kmc: boo, reflection. jumping over the hoops invocators.
07:58:06 <jmcarthur> reflection isn't inherently bad
07:58:07 <rs464> I'm somewhat confused as to the String free variable, described as "Font name" at http://goo.gl/I0Tos . File paths to .ttf files work, but I'd much rather specify the name of the font.
07:58:19 <jmcarthur> it's just badly done in many languages
07:58:26 <rs464> rather than a full file path (which probably isn't very portable)
07:58:52 <Botje> n0den1te: http://soft.vub.ac.be/~dharnie/private/gradual-typing-for-at-0.1.tar.bz2
07:59:16 <Botje> n0den1te: it's an eclipse project, but you will need the parser if you want to run/compile it
07:59:30 <jmcarthur> rs464: how is that variable free?
07:59:44 <jmcarthur> i can't actually answer your question, unfortunately
08:00:34 <jmcarthur> looks like it uses freetype, so you might be able to refer to freetype's documentation and see what kind of strings it expects
08:00:36 <Tinned_Tuna> I think Network.FTP.Client doesn't handle memory very well at all..
08:00:44 <telemyst> theoretically, a hyperintelligent alien race could construct a circlcular language from nothing and beam it into the internert.. once humanity is programming it there thinking will evolve and explode like the origin of language itself, again
08:00:48 <Tinned_Tuna> (or, more likely, I'm misusing it.)
08:00:53 <rs464> jmcarthur: ok I'll do that
08:01:18 <telemyst> nobody knows where haskerll came from, it stands on itsself like a snake eating its own tail and changes the way people think
08:01:36 <jmcarthur> Tinned_Tuna: i suspect you are misusing it ;)
08:01:42 <Tinned_Tuna> it came from Peyton-Jones
08:02:36 <jmcarthur> Tinned_Tuna: most likely you introduced a space leak in some recursive function somewhere
08:03:32 <n0den1te> Botje: Looks nice to me, and I don't really intend to run/compile this (just out of curiosity). And I see you have cleaned out the eclipse dot files. :)
08:04:59 <Botje> git did that for me, actually
08:05:05 <n0den1te> Botje: the tests are enough to tell me what you intended in their place.
08:05:08 <Tinned_Tuna> jmcarthur: I have only used map and it's variations, I've not used primitive recursion anywhere :-/
08:05:43 <Botje> Tinned_Tuna: wow. heh. usually people com from the other side :)
08:05:45 <jmcarthur> Tinned_Tuna: it's pretty common to run into the same problem with folds, for the record
08:05:57 <jmcarthur> but yeah, much less common than with primitive recursion
08:06:21 <jmcarthur> and yeah, it's impressive for a newbie to actually be avoiding primitive recursion :)
08:06:41 <Tinned_Tuna> I haven't bothered using folds anywhere either
08:06:45 <jmcarthur> hm
08:06:47 <Tinned_Tuna> it's mostly maps & filters
08:06:50 <jmcarthur> then things are getting weird
08:06:56 <jmcarthur> any mapM ?
08:06:57 <Tinned_Tuna> (or mapM_ s... )
08:07:01 <Tinned_Tuna> lots
08:07:06 <jmcarthur> without the underscore?
08:07:07 <Tinned_Tuna> and a few zipWithM_ s
08:07:16 <Tinned_Tuna> um, quite possibly
08:07:24 <Tinned_Tuna> lemme refresh me memory
08:07:37 <jmcarthur> it's not uncommon for mapM to be the source of high memory usage
08:08:00 <Tinned_Tuna> Not that I can see
08:08:07 <jmcarthur> hm
08:08:09 <jmcarthur> code?
08:08:12 <Tinned_Tuna> it seems to be all zipWithM_ and mapM_
08:08:26 <Tinned_Tuna> I'll repaste it, since it's changed a fair bit since I started
08:08:33 <jmcarthur> alright
08:09:06 <hpaste> Tinned_Tuna pasted “Memory Issues” at http://hpaste.org/50925
08:09:16 <Tinned_Tuna> thar she blows
08:12:06 <Tinned_Tuna> The FTP site I'm using has a number (8~ ?) of the files
08:12:13 <jmcarthur> Tinned_Tuna: not that this is likely to be where the problem is (i think), but why are you using seqList? is there some lazy IO in here i'm not aware of?
08:12:14 <Tinned_Tuna> each of which is 1.5GB to 3GB in size
08:12:35 <jmcarthur> nlst or something?
08:12:52 <Tinned_Tuna> jmcarthur: The documentation for the FTP stuff says that it may start trying to issue multiple directives to the FTP server
08:12:58 <Tinned_Tuna> before others have finished
08:13:12 <jmcarthur> huh
08:13:19 <Tinned_Tuna> " /You MUST consume all data from commands that return file data before you issue any other FTP commands./ "
08:13:30 <jmcarthur> i've never used this library. sounds complicated
08:13:52 <Tinned_Tuna> " That's due to the lazy nature of Haskell. This means that, for instance, you can't just iterate over the items nlst returns, trying to getbinary each one of them -- the system is still transferring nlst data while you are trying that, and confusion will ensue. Either open two FTP connections or make sure you consume the nlst data first. "
08:14:01 <jmcarthur> :o it's lazy IO
08:14:03 <kmc> that's not "the lazy nature of Haskell"
08:14:08 <kmc> that's a specific un-Haskelly hack
08:14:22 <jmcarthur> this is considered yucky by many people, including myself
08:14:30 <kmc> (which is also lamentably present in the standard library)
08:15:01 <Tinned_Tuna> ... cock :-(
08:15:38 <jmcarthur> it's probably not the source of your memory problems though
08:15:39 <kmc> evaluation should never cause execution
08:15:54 <kmc> but the standard IO libraries use hacks (unsafeInterleaveIO) to break this rule
08:16:01 <kmc> with various unfortunate consequences
08:16:07 <kmc> one of which is confusing people :)
08:16:26 <jmcarthur> kmc: i somewhat disagree. evaluation can do whatever the hell it wants so long as any effects it performs are unobservable
08:17:10 <jmcarthur> but that still rules out most uses of lazy IO
08:18:16 <jmcarthur> Tinned_Tuna: i'm sorry, i can't find the memory problem just by looking at the code
08:18:26 <jmcarthur> Tinned_Tuna: you might consider heap profiling
08:18:31 <Tinned_Tuna> jmcarthur: I think it may actually be part of the FTP library
08:18:49 <jmcarthur> quite possible
08:18:52 <Tinned_Tuna> downloadbinary h fn = do { r <- getbinary h fn; writeBinaryFile fn (fst r); return (snd r)}
08:19:01 <jmcarthur> perhaps it's downloading the entire file before writing it out or something silly like that
08:19:07 <Tinned_Tuna> would that likely try to store the whole bastard thing in memory?
08:19:17 <jmcarthur> depends on if getbinary is lazy IO or not
08:19:24 <Tinned_Tuna> (sorry for butchering it onto one line)
08:19:26 <n0den1te> pardon my ignorance, I thought lazy IO was non blocking and I think evaluation should not block anything, esp lazy eval.
08:19:37 <Tinned_Tuna> http://hackage.haskell.org/packages/archive/ftphs/1.0.7/doc/html/src/Network-FTP-Client.html
08:19:48 <Tinned_Tuna> getBinary is a wrapper around retrbinary
08:19:49 <jmcarthur> n0den1te: lazy IO deferrs the blocking to evaluation instead of execution
08:19:57 <Tinned_Tuna> http://hackage.haskell.org/packages/archive/ftphs/1.0.7/doc/html/src/Network-FTP-Client.html
08:20:02 <Tinned_Tuna> oops
08:20:08 <n0den1te> jmcarthur: that's... weird..
08:20:14 <Tinned_Tuna> retrbinary :: FTPConnection -> String -> IO (String, FTPResult)
08:20:15 <jmcarthur> n0den1te: yes it is
08:20:42 <Tinned_Tuna> retrbinary uses unsafeInterleaveIO
08:21:06 <monochrom> yes you should consume the whole string. but there are smart consumes and there are dumb consumes
08:21:12 <kmc> jmcarthur, fair enough
08:21:21 <jmcarthur> ah then it's lazy indeed. i think that is unlikely to be the problem then
08:21:56 <Tinned_Tuna> uses Strings as opposed to ByteStrings (I don't know if this is part of the issue, but when issuing a command to download a binary file, I'd expect ByteString...)
08:22:05 <jmcarthur> Tinned_Tuna: that function is an example of a "smart consume", using monochrom's terminology there, since it consumes all of the output from the lazy IO
08:22:11 <kmc> indeed
08:22:24 <kmc> String is emphatically the wrong type for representing binary data
08:22:27 <jmcarthur> yeah
08:22:36 <jmcarthur> i also doubt it has anything to do with the memory issue though
08:22:42 <monochrom> if you give the string right away to writeFile, and don't use the string in any other way, that's a smart consume
08:23:21 <monochrom> if all you do to consume is by seqList, that's a dumb consume, you're explicitly asking to read the whole thing into memory and keep it there
08:23:34 <kmc> this library seems a bit questionable.  maybe i'm biased because i don't like the indentation style :)
08:24:13 <kmc> but using String for binary files is not okay
08:24:43 <jmcarthur> yeah the more i learn about this library the less of it i like
08:24:55 <monochrom> smart consume is when you forget stuff you consume, byte by byte
08:25:13 <Eduard_Munteanu> It would be better if it fused.
08:25:14 <Tinned_Tuna> I'll see if it breaks when I remove the seqList...
08:25:26 <Eduard_Munteanu> But it's still quite a bad access pattern.
08:25:27 <Tinned_Tuna> (one never knows, it maybe refering to old code?)
08:25:49 <jmcarthur> i doubt the seqList is the problem if, as you say, there are only 8 files. those are just file names, right?
08:25:57 <monochrom> so for example writeFile writes out a byte *and forgets it* right away. that's a smart consume
08:26:21 * hackagebot levmar 1.2 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2 (BasVanDijk)
08:26:23 * hackagebot dx9base 0.1.1 - Backend for a binding to the Microsoft DirectX 9 API.  http://hackage.haskell.org/package/dx9base-0.1.1 (KidoTakahiro)
08:26:25 * hackagebot dx9d3d 0.1.1 - A binding to the Microsoft DirectX 9 API.  http://hackage.haskell.org/package/dx9d3d-0.1.1 (KidoTakahiro)
08:26:28 * hackagebot dx9d3dx 0.1.1 - A binding to the Microsoft DirectX 9 D3DX API.  http://hackage.haskell.org/package/dx9d3dx-0.1.1 (KidoTakahiro)
08:26:42 <Tinned_Tuna> jmcarthur: they are just file names, yes
08:26:45 <parcs> neat, directx bindings
08:26:48 <jmcarthur> huh
08:26:52 <xarch> Sigma a : *. T a is the same as Exists a. T a, isn't it?
08:26:53 <Tinned_Tuna> like, '20110908.tar'
08:27:42 <Saizan> xarch: depends, often the former is a "strong sum" while the latter is a "weak sum"
08:27:55 <xarch> hm
08:28:04 <Tinned_Tuna> (Incidently, seqList is required, otherwise the FTP connection just sits open, doing nothing.)
08:28:14 <byorgey> Saizan: what's the difference?
08:28:15 <xarch> what does that mean?
08:28:39 <Eduard_Munteanu> What's this "*." notation?
08:28:49 <Saizan> the difference is that if you project the first field out of a (Int , 1) :: Sigma a. a, you get Int
08:29:14 <Saizan> if you do it with a weak sum you get some unknown type
08:29:17 <xarch> oh yes
08:29:22 <byorgey> ah, I see
08:29:22 <ClaudiusMaximus> could   "do { r <- f ; g (fst r) ; h (snd r) }"   possibly be keeping the whole of 'r' around until after 'g' has completed?
08:29:39 <Eduard_Munteanu> Oh, ∃ in terms of Σ.
08:29:56 <Tinned_Tuna> ClaudiusMaximus: are you referring to the do-block I posted?
08:30:01 <ClaudiusMaximus> Tinned_Tuna: yes
08:30:11 <Tinned_Tuna> That was my initial thought when I saw it./
08:30:23 <Tinned_Tuna> ClaudiusMaximus: but I'm not experienced enough with Haskell to say either way.
08:30:28 <Saizan> Eduard_Munteanu: it's (a : *), the . is to delimit the quantifier
08:30:46 <ClaudiusMaximus> Tinned_Tuna: i don't know if it is the case, but it might be worth trying    (r1,r2) <- f ; g r1 ; h r2
08:31:00 * Tinned_Tuna strokes one's stubble
08:31:13 <Tinned_Tuna> What's the best way to go about faffing with the source code of a library from Hackage?
08:31:16 <jmcarthur> ClaudiusMaximus: i agree that looks like it could be a problem
08:31:22 * hackagebot hspec 0.8 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.8 (TrystanSpangler)
08:31:30 <Tinned_Tuna> http://hackage.haskell.org/packages/archive/ftphs/1.0.7/doc/html/src/Network-FTP-Client.html <- it's from here
08:31:36 <jmcarthur> Tinned_Tuna: are getbinary and writeBinaryFile exposed to you?
08:31:51 <jmcarthur> you could just write your own downloadbinary without fiddling with the library
08:31:54 <Tinned_Tuna>   yes
08:32:19 <Tinned_Tuna> I'll give that a quick go.
08:33:09 <jmcarthur> @undo do { (r1,r2) <- f ; g r1 ; h r2 }
08:33:09 <lambdabot> f >>= \ (r1, r2) -> g r1 >> h r2
08:33:14 <jmcarthur> @@ @pl @undo do { (r1,r2) <- f ; g r1 ; h r2 }
08:33:14 <lambdabot>  uncurry ((. h) . (>>) . g) =<< f
08:33:25 <jmcarthur> um, ew
08:33:29 <Tinned_Tuna> what the ever living christ?
08:34:52 <ClaudiusMaximus>  @undo desugars do notation, @pl makes things pointfree
08:35:11 <Tinned_Tuna> tis a very scary item.
08:35:23 <ClaudiusMaximus> and @@ composes operations in the bot
08:35:35 <jmcarthur> :t \f g h -> uncurry (>>) <<< g *** h =<< f
08:35:36 <lambdabot>     Couldn't match expected type `a -> (m a1, m b)'
08:35:36 <lambdabot>            against inferred type `(c, c')'
08:35:36 <lambdabot>     In the first argument of `(=<<)', namely `g *** h'
08:35:42 <jmcarthur> :t \f g h -> (uncurry (>>) <<< g *** h) =<< f
08:35:42 <lambdabot> forall (m :: * -> *) a b b1 b'. (Monad m) => m (b1, b') -> (b1 -> m a) -> (b' -> m b) -> m b
08:36:23 <jmcarthur> :t \f g h -> (uncurry (>>) <<< g *** h) <=< f
08:36:24 <lambdabot> forall (m :: * -> *) a b b1 b' a1. (Monad m) => (a1 -> m (b1, b')) -> (b1 -> m a) -> (b' -> m b) -> a1 -> m b
08:36:24 * hackagebot dx9d3d 0.1.0.1 - A binding to the Microsoft DirectX 9 API.  http://hackage.haskell.org/package/dx9d3d-0.1.0.1 (KidoTakahiro)
08:37:16 <Tinned_Tuna> memory usage is steady...
08:37:21 <jmcarthur> yay!
08:37:24 <Tinned_Tuna> appears to have been the culprit
08:37:35 <Tinned_Tuna> does someone want to submit a patch to the library maintainer?
08:37:38 <jmcarthur> out of curiosity, what optimization level are you building with?
08:37:43 <Tinned_Tuna> ghc --make ...
08:37:49 <Tinned_Tuna> no other flags
08:38:00 <jmcarthur> well i suppose the library might be built with -O at least
08:38:04 <Tinned_Tuna> do you think upping the optimization would deal nicely with it?
08:38:33 <jmcarthur> i'm on the fence about that
08:38:37 <jmcarthur> i'm suspecting not
08:39:07 <Tinned_Tuna> Should we submit a patch? Or at least notify the maintainer in some way?
08:39:35 <jmcarthur> only if it optimizes   let a = b in f (fst a) (snd a)  to  let (x,y) b = f x y  , which i'm pretty sure it shouldn't do in general
08:39:51 <Tinned_Tuna> hm ?
08:39:57 <jmcarthur> but maybe if it detects that f is strict in both arguments or something. i dunno
08:40:02 <jmcarthur> shoot i did that wrong anyway
08:40:11 <jmcarthur> should be case, not let
08:40:24 <jmcarthur> and man i such
08:40:27 <jmcarthur> *suck
08:40:28 <Tinned_Tuna> Are you referring to the optimizations the compiler makes, or notifying the maintainer of Network.FTP ?
08:40:32 <jmcarthur> the compiler
08:40:40 <Tinned_Tuna> ok, I was getting thoroughly confused :- p
08:41:04 <jmcarthur> i mistyped, then said the wrong stuff
08:41:07 <jmcarthur> ignore it :)
08:41:08 <Tinned_Tuna> haha :-D
08:41:16 <Tinned_Tuna> So, do we notify the maintainer?
08:41:20 <jmcarthur> i say do it
08:41:28 <jmcarthur> it looks like a bug to me
08:41:36 <Tinned_Tuna> what's the procedure with the Haskell community and Hackage?
08:42:09 <jmcarthur> typically just an email. if you wish to include a patch the author will probably appreciate it, but it's probably just as much work to apply a patch as to just fix it himself
08:42:25 <Tinned_Tuna> okies :-)
08:45:20 <Tinned_Tuna> Sent :-)
08:45:54 <Tinned_Tuna> (afk)
08:50:48 <Tinned_Tuna> I think it's time for a cup of tea.
08:57:56 * jmcarthur is trying to come up with a name for a function with type   Functor f => a -> Free f (Cofree f a) -> Cofree f a
08:59:29 <Tinned_Tuna> I misread that as Free f (Coffee f a)
08:59:46 <jmcarthur> free coffee!
09:00:02 <Tinned_Tuna> my thoughts exactly
09:00:04 <gwern> @quote
09:00:04 <lambdabot> dons says: applying functional approaches to the world.
09:01:19 <jmcarthur> why was that @remembered? doesn't seem interesting to me at all
09:03:10 <Tinned_Tuna> because I don't know if a functional approach necessarily works with the real world?
09:06:03 <byorgey> jmcarthur: so what does it do, duplicate the given a value at all branching sites within the Free structure?
09:06:43 <jmcarthur> yes
09:07:12 <bfig_> do you use haskell in production code a lot?
09:07:25 <bfig_> what kind of interfaces do you usually use with it?
09:07:40 <jmcarthur> i write ocaml for a living and haskell for all my hobby projects
09:07:47 <byorgey> hmm... streamify?  streamifyPrefix?  capture[Prefix]?
09:07:59 <byorgey> just brainstorming here
09:10:15 <jrosti> an old paper by Prechelt http://page.mi.fu-berlin.de/prechelt/Biblio/jccpprtTR.pdf inspired M. Odersky to rewrite similar program with Scala: http://pastebin.com/MywR7j9b, I rewrote it in Haskell: http://pastebin.com/X3utcN3J, is there any improvements to the style or other in Haskell implementation?
09:10:19 <mauke> The pastes MywR7j9b X3utcN3J have been copied to http://hpaste.org/50926 http://hpaste.org/50927
09:10:28 <Tinned_Tuna> jmcarthur: where do you work?
09:10:50 <ddarius> jmcarthur: It looks like it may be a simple generalization of the prefixing operation of CCS/CSP.
09:10:58 <jmcarthur> ultimately i'm going to do something like   data Cofree' f a = Cofree' a (f (Free f (Cofree f a))), where the Free f (Cofree f a) is treated semantically as the result of applying this function to it. this allows me to optimize, e.g., its Applicative instance such that if going deeper into the two trees doesn't change the value then you can reuse the result of the last application... if that makes any
09:11:01 <jmcarthur>  sense
09:11:29 <jmcarthur> using Free at all might not be meaningful, since i'm not actually using it like a free monad, but it makes it easier to convey the structure
09:12:14 <KirinDave> So
09:12:28 <KirinDave> For those trying to get ghc7 and cabal install
09:12:28 <KirinDave> https://gist.github.com/1169332
09:12:31 <jrosti> e.g. are list comphrehensions deprecated, and one should use do ... guard instead?
09:12:36 <KirinDave> Just found it.
09:12:39 <jmcarthur> jrosti: they are not deprecated
09:12:47 <KirinDave> Someone should topic that.
09:13:01 <monochrom> list comprehension is still in. in fact monad comprehension is recently added.
09:14:36 <monochrom> oh, it is not just mac? because package "random" is universally omitted
09:15:41 <jrosti> monochrom, thanks, any pointers to monad comprehensions?
09:16:00 <monochrom> ghc 7.2 user's guide
09:16:11 <KirinDave> monochrom: I dunno
09:16:20 <KirinDave> I don't even know why I am doing 7.2.1 on Lion
09:16:33 <KirinDave> I get literally millions of "ld: warning: text reloc in _s2Ne_info to non_lazy_ptr"
09:16:42 <KirinDave> When linking
09:17:14 <KirinDave> I had hoped 7.2.1 would fix that problem
09:17:20 <KirinDave> Hopefully ghci doesn't crash
09:17:30 <monochrom> I'm testing it on linux 32-bit now
09:17:55 <KirinDave> Does mine craft run on linux? I am tempted to express order a W series thinkpadand just ditch all these complications.
09:17:59 <monochrom> heh it breaks on linux too
09:18:01 <KirinDave> That's the only thing I'd miss.
09:18:07 <jmcarthur> KirinDave: yes
09:18:22 <KirinDave> monochrom: Well part of the problem is the package deps are just wrong for 7.2
09:18:34 <monochrom> yeah
09:18:37 <jmcarthur> KirinDave: my wife and i both run minecraft under linux on lenovos
09:19:13 <KirinDave> monochrom: The resulting base deps it tries to use is nonsensical
09:19:18 <KirinDave> Like >=4 but <2
09:19:46 <KirinDave> This patch seems to work
09:19:57 <KirinDave> I am compiling everything and got past the deps resolution
09:23:25 --- mode: ChanServ set +o monochrom
09:23:31 --- topic: set to '["GHC 7.2 and cabal-install: https://gist.github.com/1169332 (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #ha' by monochrom
09:23:38 <monochrom> yikes!
09:24:11 <KirinDave> monochrom: Ty
09:25:11 <ddarius> Wouldn't it have been simpler to simply provide the new bootstrap.sh?
09:25:47 <KirinDave> yes
09:25:52 <taotree> I'm looking for [a] -> [a] -> [(a, a)] but not zip, I want the... I guess it would be cross product (outer join instead of inner join?)...
09:25:57 --- topic: set to '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]' by monochrom
09:26:01 <taotree> So the resulting list should be m*n instead of min(m, n)
09:26:20 <ddarius> liftM2 (,)
09:27:08 <KirinDave> So all these warnings "ld: warning: text reloc in _cOp_str to _stg_ap_pppppp_info"
09:27:15 <KirinDave> Does anyone know how I can get ld to be less chatty?
09:27:20 <taotree> ddarius, ok, that's seriously cool
09:27:33 <taotree> thanks!
09:28:08 <KirinDave> Like, how can I add extra ld flags when ghc calls ld?
09:28:43 <luite> is that on os x?
09:28:48 <KirinDave> Yes
09:28:55 <KirinDave> I get tens of thousands of them.
09:29:12 <KirinDave> I pipe my output to a file (or dev null) so that my console doesn't slow my builds
09:30:45 --- mode: monochrom set -o monochrom
09:31:09 <luite> ah hmm, annoying
09:31:35 <jrosti> bfig_: I've never used haskell in production code, however, trying to learn it has been useful in production code
09:34:45 <bfig_> jrosti, in the general sense of functional approach? my question was mainly aimed at which types of interfaces were consistently used in haskell production code (be it exporting functions through FFI or using a GUI directly)
09:35:36 <KirinDave> I have had some small data plumbing in haskell now
09:35:40 <KirinDave> In a production setting
09:36:06 <KirinDave> I'm taking data from a redis channel and pushing it over a polled yesod interface
09:36:10 <KirinDave> as json
09:36:27 <KirinDave> Works great.
09:37:24 <KirinDave> The laziness is actually pretty awesome, the way it ends up, ghc just keeps the byte chunks for the iterate around until: 1, the circular buffer fills up and old entries expire or 2, someone hits the yesod interface.
09:37:41 <KirinDave> s/iterate/iteratee/ -- Oh lion.
09:37:52 <jrosti> bfig_: oh, I misundestood the question.
09:38:22 <luite> KirinDave: hehe do all applications automatically spell correct in lion?
09:38:29 <KirinDave> Yeah
09:38:36 <KirinDave> And I still can't find a preference for turning it off globally
09:38:42 <KirinDave> Maybe I am just dense, or frustrated
09:38:52 <KirinDave> At least terminal.app doesn't do that
09:39:15 <bfig_> jrosti, how has haskell helped you?
09:39:35 <luite> KirinDave: I was trying some laptops recently, to see how good the keyboards were... so I typed a few sentences quickly in a text editor and then checked how many typo's I made
09:39:46 <luite> this worked fine on the windows laptops
09:40:50 <dylukes> "You can't push a noodle".
09:40:52 <dylukes> Discuss.
09:42:05 <nolrai1123> Is there a name for something that has (<*>) :: f (a -> b) -> f a -> f b but doesnt have fmap or pure?
09:42:23 <ddarius> nolrai1123: edwardk has a class for that called Apply.
09:42:24 <KirinDave> nolrai1123: How can f (a -> b) exist without pure?
09:43:01 <ddarius> KirinDave: If the only way you could make f a's was with pure, then every Applicative would be trivial.
09:43:29 <KirinDave> ddarius: I guess I don't see how (a -> b) happens.
09:43:34 <nolrai1123> You have to anotate the function, so theres a constructor c :: (a -> b) -> otherstuff -> f a b
09:43:42 <KirinDave> ddarius: That said, I haven't seen a non-trivial applicative yet. Even the parsers are pretty straightforward.
09:44:12 <ddarius> KirinDave: I meant "trivial" in a strong sense.  They would be the identity applicative or even less useful.
09:44:27 <nolrai1123> ddarius: is edwark's Apply up somewhere?
09:44:46 <jmcarthur> it's in some weird package. semigroupoids or something i think
09:44:47 <ddarius> I think it's in his semigroupoids package, but it may be in some other package.
09:44:58 <nolrai1123> Is it worth getting?
09:45:07 <copumpkin> KirinDave: take Map k as an instance
09:45:13 <jmcarthur> i have been liking edwardk's packages lately
09:45:23 <KirinDave> copumpkin: Okay
09:45:31 <jmcarthur> as easy as "cabal install X" is, any package is worth getting ;)
09:45:32 <copumpkin> KirinDave: I can't really write pure on it
09:45:34 <copumpkin> I can write fmap
09:45:38 <copumpkin> I can write <*>
09:45:55 <copumpkin> :t M.intersectWith
09:45:55 <lambdabot> Couldn't find qualified module.
09:45:59 <copumpkin> :t Map.intersectWith
09:45:59 <lambdabot> Couldn't find qualified module.
09:46:01 <copumpkin> gah
09:46:02 <ddarius> M.
09:46:09 <ddarius> Er.
09:46:11 <KirinDave> copumpkin: EXPLANATION RUINED NO VALUE GAINED ;)
09:46:12 <ddarius> Use hoogle.
09:46:19 <copumpkin> @hoogle intersectWith
09:46:19 <lambdabot> No results found
09:46:23 <KirinDave> And there we go
09:46:33 <nolrai1123> Oh well Applys are functors too..my thing isn't even that.
09:46:34 <copumpkin> oh
09:46:35 <KirinDave> I am back in business with haskell on my mac
09:46:38 <copumpkin> :t M.intersectionWith
09:46:38 <lambdabot> forall a b c k. (Ord k) => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
09:46:46 <copumpkin> that's liftA2 on that thing
09:46:51 <copumpkin> you can easily derive <*> from it :)
09:46:55 <jmcarthur> copumpkin: pure :: Monoid k => Map k a
09:46:57 <ddarius> liftA2 ($)
09:47:12 <jmcarthur> well, (Monoid k, Ord k) i guess
09:47:14 <copumpkin> jmcarthur: that doesn't really work
09:47:19 <nh2> is there a way to turn of ghcs/hugs loop detection? "I just don't believe there is a loop!" :P
09:47:28 <jmcarthur> no?
09:47:45 <kmc> ghci doesn't bail out on loops
09:47:53 <ddarius> nh2: There has to be a loop for it to happen.
09:48:01 <monochrom> your belief is pretty irrelevant
09:48:45 <copumpkin> jmcarthur: or I guess its <*> would be something completely different :)
09:48:56 <jmcarthur> yeah
09:49:02 <jmcarthur> not sure what it would be
09:49:22 <copumpkin> every combination of keys `mappend`ed together?
09:49:28 <nh2> kmc: but it stops reduction/evaluation, I think, as it takes no CPU
09:49:41 <monochrom> do you prefer it to take CPU?
09:49:47 <jmcarthur> in order to keep the same (<*>), pure would have to give a map such that it maps to the value for all keys
09:49:54 <ddarius> jmcarthur: Correct.
09:50:03 <nh2> monochrom: yes, I also run with -B
09:50:05 <copumpkin> jmcarthur: yeah, conal had a TMap for that
09:50:09 <ddarius> You'd make a Map with default.
09:50:09 <jmcarthur> yeah
09:50:09 <copumpkin> but I don't really want that
09:50:16 <monochrom> sorry I forgot what -B does
09:50:29 <nh2> monochrom: beep on GC
09:50:49 <ddarius> Allocating memory and garbage collection both require CPU time.
09:51:41 <ddarius> At any rate, with the threaded runtime the blackholing causes the thread to block instead of giving a blackhole exception.
09:51:42 <KirinDave> I confess I dunno what Map-as-an-applicative is, copumpkin.
09:51:49 <monochrom> the black hole detection is deeply engraved as part of how ghc does lazy evaluation correctly. you have to rewrite ghc's rts to disable it (and risk implementing lazy evaluation wrong)
09:51:51 <KirinDave> I'm not sure where I'd even find that definition.
09:52:07 <ddarius> monochrom: It wouldn't be wrong, so much as inefficient.
09:52:08 <copumpkin> KirinDave: there isn't a standard instance for it
09:52:13 <copumpkin> KirinDave: but it can be an Apply easily
09:52:28 <KirinDave> copumpkin: I guess because more than one piece of data is required to pure it?
09:52:33 <monochrom> well fine you would have to rewrite ghc's rts either way
09:53:03 <nolrai1123> Is a line like "type a :-> b = Proof (a -> b)" okay haskell?
09:53:05 <ddarius> monochrom: You would have to change it, but you could probably remove it without too much effort.
09:53:15 <ddarius> nolrai1123: Not without extensions.
09:53:20 <monochrom> oh, that's nice
09:53:23 * KirinDave mutters
09:53:26 <KirinDave> It all comes back to types.
09:53:29 <ddarius> Mainly because infix type operators aren't supported in Haskell 98.
09:54:06 <ddarius> It's a superficial limitation though.
09:54:51 <monochrom> but at the end of the day I am doubtful of the benefit of "hangs and consumes" over "hangs and doesn't consume". if anything, the former is harder to kill in practice, i.e., contention of cpu and memory with whatever shell you need to kill it
09:54:51 <nh2> in the end, of course there is a loop, but I don't know why. I recursively define an Array like the wavefront example in http://www.haskell.org/tutorial/arrays.html, and it works well until I make the definition helper function (mkArray f bnds =  array bnds [(i, f i) | i <- range bnds]) strict (like mkArray f bnds =  array bnds [let res = fi in res `seq` (i, res) | i <- range bnds])
09:55:18 <KirinDave> Hummm.
09:55:31 * ddarius is surprised why this is surprising.
09:55:45 <KirinDave> This is not good.
09:55:54 <KirinDave> So ghc 7.2.1 didn't install cabal for me
09:56:12 <KirinDave> I don't have an executable.
09:56:21 <drdo> KirinDave: Are you confusing cabal with cabal install?
09:56:29 <mauke> cabal install cabal-install
09:56:32 <KirinDave> drdo: Maybe
09:56:47 <mauke> there's a package called 'Cabal'. it provides the cabal library
09:56:53 <byorgey> ghc never comes with cabal-install.
09:56:53 <KirinDave> Oh wait
09:56:55 <KirinDave> I see what happened
09:56:56 <mauke> there's a package called 'cabal-install'. it provides the cabal executable
09:56:57 <nh2> as soon as I do that, I cannot get my array ! (0,0) from (1,1), although (0,y) = y and (x,0) = x. Do you see any obvious reason why making the calculation strict leads to the loop?
09:57:04 <KirinDave> I just installed the new cabal executbale to the wrong place
09:57:26 <dylukes> Why exactly does GHC come with cabal but not cabal install >.>?
09:57:28 <dylukes> out of curiosity
09:57:42 <jmcarthur> the platform comes with cabal install at least
09:58:29 <byorgey> dylukes: I think because Cabal-as-a-library has a bunch of code dealing specifically with GHC's package format, etc., so it's important they stay in sync
09:58:35 <byorgey> but I am not 100% sure
09:58:36 <monochrom> because GHC comes with only stuff needed to build GHC itself
09:59:09 <ddarius> Cabal is always provided by the compiler.  Cabal is the interface between the compiler and the distribution tools.
09:59:13 <rwbarton> nh2: 'array' does things like make sure there are no duplicates among the indices in the list
09:59:22 <ddarius> Every compiler will have its own Cabal library.
09:59:39 <monochrom> and even that is considered too much dead weight. there are talks of not exposing libs that GHC itself needs
09:59:45 <rwbarton> > array (0, 1) [(0, 'a'), (1, 'x'), (1, 'y')] ! 0
09:59:46 <lambdabot>   'a'
09:59:50 <rwbarton> ... or does it
10:00:16 <jmcarthur> it probably just uses the latest value for a key
10:00:17 <rwbarton> > array (0, 1) [(0, 'a'), (1, 'x'), (1, 'y')] ! 1
10:00:18 <lambdabot>   'y'
10:00:20 <rwbarton> yes, it does that
10:00:57 <ddarius> rwbarton: It just interprets each pair as a write instruction into the array, it doesn't preprocess the list.
10:01:06 <nolrai1123> hhmm You know I think what I have is actualy a catagory..
10:01:13 <rwbarton> So you can't extract an element of the array without reading the indices of the entire list pairs, and you've made those depend on the values in the array.
10:01:19 <dylukes> nolrai1123: what're the arrows?
10:01:25 <ddarius> nolrai1123: It would be surprising if it wasn't.
10:01:27 <nh2> rwbarton: but how should then turning the value into a strict computation (not doing any change to the index) create a loop?
10:01:39 <loans> man i don't know if I'm ever gonna get this haskell thing
10:01:46 <rwbarton> I don't understand what you mean by "strict computation"
10:02:10 <rwbarton> "let res = fi in res `seq` (i, res)" means I can't extract i without computing res
10:02:13 <hpc> @hoogle chr
10:02:14 <lambdabot> Data.Char chr :: Int -> Char
10:02:14 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
10:02:14 <lambdabot> Network.Browser chRealm :: Challenge -> String
10:02:35 <hpc> aha, not in prelude
10:03:09 <monochrom> > array (1, 10) [ let x = i + 1 in x `seq` (i, x) | i <- [1..10] ]
10:03:10 <lambdabot>   array (1,10) [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
10:03:17 <monochrom> works, no infinite loop
10:03:27 <ddarius> monochrom: You x does not depend on the result.
10:03:37 <monochrom> that's right
10:03:37 <nolrai1123> ddarius/dylukes: I am trying to implement a type for anotated code, that is code with a math-like proof that it works.
10:04:21 <dylukes> what do you mean "type for annotated code"
10:04:42 <nolrai1123> The basic operations I want to suport are cut: Proof a b -> Proof b c -> Proof a c.
10:04:52 <nh2> rwbarton: yes, but the weird thing is: I'm not trying to extract that, I'm extracting element smaller than the current index (like 0,0), which are well defined, as they are evaluated before
10:04:53 <monochrom> > let a = array (1, 10) [ let x = if i==1 then 1 else a!1 in x `seq` (i, x) | i <- [1..10] ] in a
10:04:57 <lambdabot>   mueval-core: Time limit exceeded
10:05:00 <monochrom> there
10:05:02 <rwbarton> nh2: no
10:05:14 <rwbarton> because array uses the last pair with a given index
10:05:37 <rwbarton> it has no way of knowing that there is not a pair ((0,0), 37) later in the list
10:05:42 <nh2> ow
10:05:44 <monochrom> > let a = array (1, 10) [ let x = if i==10 then 1 else a!10 in x `seq` (i, x) | i <- [1..10] ] in a
10:05:48 <lambdabot>   mueval-core: Time limit exceeded
10:05:50 <KirinDave> Oh crap. I broke caball-install already.
10:05:50 <monochrom> same failure
10:05:55 <rwbarton> try listArray
10:05:58 <dylukes> nolrai1123: what *are* the proofs >.<
10:06:00 <rwbarton> it might not have this issue
10:06:08 <nolrai1123> thinking..
10:06:10 <dylukes> I'm trying to understand what's going on.
10:06:13 <dylukes> pasting helps.
10:06:20 <telemyst> could haskell be used for evil?
10:06:32 <ddarius> @faq Can Haskell be used for evil-doing?
10:06:32 <lambdabot> The answer is: Yes! Haskell can do that.
10:06:33 <monochrom> > let a = listArray (1, 10) [ let x = if i==10 then 1 else a!10 in x `seq` | i <- [1..10] ] in a
10:06:34 <lambdabot>   <no location info>: parse error on input `|'
10:06:42 <monochrom> > let a = listArray (1, 10) [ let x = if i==10 then 1 else a!10 in x `seq` x | i <- [1..10] ] in a
10:06:42 <lambdabot>   array (1,10) [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1)]
10:06:49 <monochrom> interesting!
10:06:59 <monochrom> (but then x `seq` x is just x)
10:07:01 <kmc> they should just put in the Haskell Report that any use of Haskell for evil is undefined behavior
10:07:05 <nh2> telemyst: at least the evil would be in a corresponding box
10:07:07 <kmc> then Haskell cannot be used for evil
10:07:08 <nolrai1123> well all i have is a dozen lines..the proofs are just concatanations of axioms.
10:07:19 <monochrom> > let a = listArray (1, 10) [ let x = if i==1 then 1 else a!1 in x `seq` x | i <- [1..10] ] in a
10:07:19 <lambdabot>   array (1,10) [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1)]
10:07:24 <rwbarton> nh2: why do you care about this strictness in the first place?
10:07:28 <nolrai1123> Not sure if thats powerful enough..but we will see.
10:07:48 <telemyst> can it calculaute permutations of infinity?
10:07:50 <rwbarton> if it's to avoid stack overflow, one option is to define the array with the lazy definition and then seq the elements in an appropriate order
10:08:05 <telemyst> every reality exists inside it
10:08:14 <rwbarton> > listArray (1, 10) ('x' : 'y' : undefined) ! 1
10:08:15 <lambdabot>   *Exception: Prelude.undefined
10:08:20 <rwbarton> aw
10:08:45 <nolrai1123> listArray reads the whole list at once?
10:08:57 <monochrom> it probably wants the cons cells
10:09:01 <hpc> also (!) isn't a function
10:09:09 <nolrai1123> ah!
10:09:13 <monochrom> > listArray (1,3) ['x', undefined, undefined] ! 1
10:09:13 <lambdabot>   'x'
10:09:19 <nh2> rwbarton: it's not the first place, I'm trying out some Levenshtein implementations, and all of them explode in memory usage
10:09:31 <rwbarton> er
10:10:48 <rwbarton> what kind of memory usage? stack or heap?
10:11:21 <monochrom> > listArray (1,2) [True, False] :: UArray Int Bool
10:11:21 <lambdabot>   Not in scope: type constructor or class `UArray'
10:11:33 <monochrom> > listArray (1,2) [True, False] :: Data.Array.Unboxed.UArray Int Bool
10:11:33 <lambdabot>   Not in scope: type constructor or class `Data.Array.Unboxed.UArray'
10:13:02 <rwbarton> nh2: the straightforward lazy version should just allocate a thunk per cell in the array, which is only a constant factor worse than storing an integer or whatever
10:16:01 <nh2> rwbarton: heap. Yes, I think that is the case, but that constant factor is what I'm trying to get rid of
10:16:47 <rwbarton> In that case you can always use an unboxed array in the ST monad
10:17:22 <nolrai1123> I don't seem to have Control.Catagory..
10:19:00 <nh2> rwbarton: I'll first try using listArray as I find the recursive definition very elegant
10:19:36 <rwbarton> > listArray (0,2) "abc" :: UArray Int Char
10:19:37 <lambdabot>   Not in scope: type constructor or class `UArray'
10:19:40 <rwbarton> hrng
10:20:01 <bugaloo> Hello
10:20:17 <bugaloo> What do people use Haskell for?  Why is it useful?
10:20:28 <monochrom> let a = listArray (1,2) ['x', a!1]  is an infinite loop for UArray, rwbarton
10:20:29 <telemyst> haskell can be used for evil
10:20:46 <rwbarton> yep, just tried that
10:20:51 <monochrom> (well, infinite loop when you later ask for either a!1 or a!2)
10:21:11 <monochrom> too bad lambdabot doesn't have UArray for testing right here!
10:21:26 <Botje> well, everyone has a right to referential transparency, even evil masterminds :)
10:21:30 <bugaloo> Seems like yet another programming language.  Does it bring anything new to the table that others haven't?
10:21:42 <telemyst> haskell is created by aliens
10:21:44 <byorgey> bugaloo: people use Haskell for just about everything.  It is useful because it lets you code at a high level of abstraction, has a great type system that helps prevent a large class of errors, and has great compiler technology and a fantastic user community.
10:22:20 <monochrom> "God rains referential transparency on righteous men as well as evil men"? :)
10:22:31 <wires_> bugaloo: i would say mainly good practical functional programming
10:22:49 <bugaloo> Oh I see.  Are there any famous projects that are written in Haskell (that are popular online)?
10:23:05 <wires_> bugaloo: it doesn't really matter
10:23:06 <leod> xmonad for example
10:23:23 <wires_> bugaloo: silk uses it, bump
10:23:27 <bugaloo> Yes, I came to this website when reading about xmonad.
10:23:34 <bugaloo> Silk?
10:23:39 <wires_> silkapp.com
10:23:46 <wires_> dutch company
10:24:27 <wires_> i heard many high frequency traders use it
10:24:38 <byorgey> bugaloo: as for being "yet another programming language", it is quite different from most mainstream languages.  Of course you don't have to take my word for it.
10:24:41 <byorgey> @where lyah
10:24:41 <lambdabot> http://www.learnyouahaskell.com/
10:25:16 <monochrom> lyah is not just another tutorial either. it's a comic
10:25:41 <monochrom> but I actually say that haskell is just another language
10:26:56 <bugaloo> byorgey and wires_:  thanks for the info, guys.  I wanted to play devil's advocate a bit to see if it's worth diving into haskell
10:27:02 <dylukes> bugaloo: My personal *opinion*, is that haskell is good for "naming things".
10:27:57 <wires_> i'd pick haskell if i needed to write bug free code to do any form of algorithmic data mangling and IO
10:28:00 <byorgey> bugaloo: the fact that playing devil's advocate does not get you immediately flamed into oblivion and kicked out of the channel is another good reason to learn Haskell
10:28:08 <byorgey> we try to be a friendly bunch =)
10:28:20 <wires_> indeed, good community
10:28:24 <rwbarton> monochrom: I wonder if possibly a definition like "let x = listArray (0,2) ['a', succ (x ! 0), succ (x ! 1)] :: Array Int Char" is actually fairly space-efficient
10:28:25 <dylukes> It excels at abstraction. Not in the same way as a lisp dialect, it's more constrained and easier to reason about for the average mortal... (constraints in this case are mostly syntactic and typing).
10:28:31 <dylukes> Haskell has a very nice community, which is great.
10:28:39 <dylukes> You know who are jerks? The OpenGL community on freenode.
10:28:47 <wires_> haha
10:28:49 <ddarius> Except me.  You questions, bugaloo, are not really going to help answer your real questions.
10:28:51 <dylukes> Most of them are magic wizards.
10:28:56 <dylukes> And won't share any knowledge with you.
10:29:14 <wires_> bitcoin channel can be pretty retarded too :)
10:29:37 <monochrom> rwbarton: it has the overhead of one indirection (even after seqing) but that's it
10:30:13 <KirinDave> I've taken upon myself the expense of hosting a patched version of cabal-install according to that gist
10:30:17 <KirinDave> http://dave.fayr.am/static/cabal-install-patched_7.2.1.tar.gz
10:30:31 <kmc> bugaloo, pandoc and xmonad are my favorite practical tools written in Haskell -- stuff I'd use even if I didn't care about the language
10:30:45 <rwbarton> hmm
10:30:46 <KirinDave> Not that I think anyone using haskell would have trouble following those directions.
10:30:51 <kmc> however, a lot of what Haskell is used for is sophisticated internal tools at banks, hardware design companies, google, facebook, etc.
10:31:34 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
10:31:51 <hpaste> parcs pasted “wat” at http://hpaste.org/50928
10:31:52 <monochrom> the really right thing to do is to put a new version of cabal-install on hackage :)
10:31:56 <rwbarton> what I want is for it to use a constant number of cons cells and thunks while being constructed
10:32:07 <parcs> oh damn
10:32:07 <rwbarton> but that definition doesn't force the values at all, so of course it won't do that
10:32:33 <KirinDave> What the balls?
10:32:44 <KirinDave> I accidentally broke my cabal-install
10:32:46 <monochrom> oh, the I don't know the details of how listArray forces and forgets the cons cells
10:32:47 <KirinDave> so I try to rebuild
10:32:49 <KirinDave> now it fails.
10:33:20 <KirinDave> https://gist.github.com/a268a1a85f25ef9f3282
10:33:26 <KirinDave> Can someone help me troubleshoot this?
10:33:34 <rwbarton> well I'd like it to avoid storing thunks in the list as it goes
10:33:41 <hpaste> parcs pasted “wat'” at http://hpaste.org/50929
10:33:45 <monochrom> haha parcs, exactly :)
10:34:04 <rwbarton> er, storing thunks in the array
10:34:09 <parcs> wait hpaste doesn't typecheck your paste?
10:34:29 <rwbarton> but I don't see how to do that without making the cons cells depend on previous values, and I'm pretty sure that won't work
10:34:37 <parcs> can someone try typechecking that and tell me if the error is justified
10:34:47 <Eduard_Munteanu> KirinDave: you might want to delete ~/.cabal and ~/.ghc and start from scratch
10:35:11 <Eduard_Munteanu> Assuming you didn't break the global Cabal store too.
10:35:26 <KirinDave> Oh I broke it all
10:35:36 <KirinDave> Homebrew and I had an argument
10:35:53 <hpaste> parcs annotated “wat'” with “wat' (annotation)” at http://hpaste.org/50929#a50930
10:36:04 <wires_> can GADT's be using in template haskell or generic programming approaches?
10:36:04 <Eduard_Munteanu> So you did --global installs?
10:36:30 <parcs> did i find a ghc bug related to record updates and typechecking
10:36:38 <KirinDave> Eduard_Munteanu: Yes. That noise is going away
10:36:54 <KirinDave> Eduard_Munteanu: Best to use the gentle fist
10:37:20 <byorgey> wires_: template haskell can be used to generate GADTs.  generic programming framework support for GADTs is more spotty.
10:37:23 <monochrom> parcs, bar = foo { x = return () } ? bar = Foo { x = return () } ?
10:37:53 <monochrom> I see, you really want foo
10:37:57 <wires_> byorgey: thanks!
10:38:09 <byorgey> wires_: RepLib supports some GADTs (I know because I just added the support for GADTs myself).  Not sure about other GP frameworks.
10:38:43 <wires_> hmm I remember there was a talk on DTP'11 about comparing generic programming frameworks... let me check
10:40:05 <parcs> monochrom: yeah this is a contrived test case
10:40:11 <parcs> it should typecheck no?
10:40:31 <wires_> ah, wait that was using agda...
10:40:39 <wires_> byorgey: thanks!
10:40:59 <monochrom> I don't know. what does the haskell report say?
10:41:24 <monochrom> bearing in mind "foo{x=blah}" is record syntax not function application or something
10:41:39 <parcs> *shrug*
10:41:54 <parcs> seems like it's related to the monomorphism restriction
10:42:23 <monochrom> no
10:42:45 <rwbarton> foo is polymorphic and how should it know which return to pick for foo when evaluating bar
10:42:57 <Eduard_Munteanu> That's strange, it seems unification should be trivial there.
10:42:58 <rwbarton> record update is allowed to change type paramteres
10:43:12 <Eduard_Munteanu> Oh.
10:43:42 <Nathan_the_Noob> Hi
10:44:16 <Eduard_Munteanu> But it looks like return () :: IO () follows quite straightforwardly.
10:44:27 <byorgey> hi Nathan_the_Noob
10:44:37 <byorgey> how goes the Noobing? =)
10:44:45 <monochrom> yikes, rwbarton nails it. "data R a = R{a::a}" then "r = R{a=10}{a=True}" haha
10:44:46 <rwbarton> that part is fine, yes, but it doesn't know which foo to pick
10:45:22 <Nathan_the_Noob> Quite well so far thanks byorgey,
10:45:28 <Eduard_Munteanu> rwbarton: Oh, you mean it doesn't know which m to pick _before_  the update?
10:45:34 <monochrom> so we're talking about (Foo{x=blah} :: Foo m){x = stuff} :: Foo IO with unknown m
10:45:37 <rwbarton> right
10:45:48 <rwbarton> the foo there need not have type Foo IO
10:46:13 <byorgey> oh, I have run into this record-update-changing-the-type problem too
10:46:21 * hackagebot hspec 0.8.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.8.1 (TrystanSpangler)
10:46:32 <Eduard_Munteanu> Naturally, one other question that arises is... why does GHC care?
10:46:35 <parcs> why must foo have a concrete type though? it's not like anything is getting evaluated
10:46:35 <rwbarton> yes, it's a little counterintuitive
10:46:53 <monochrom> "linear types change the world!" says Wadler. "Record updates change the type!" says Haskell. :)
10:47:08 <Eduard_Munteanu> Heh.
10:47:33 <Eduard_Munteanu> @remember monochrom "linear types change the world!" says Wadler. "Record updates change the type!" says Haskell. :)
10:47:33 <lambdabot> Done.
10:47:41 <rwbarton> iirc the Report explicitly allows record updates to change the type; I'm not sure what the use case is though
10:47:43 <byorgey> Nathan_the_Noob: cool, feel free to ask in here if you have any questions
10:47:45 <monochrom> as for "why", accept that only the committee knows why.
10:48:24 <parcs> here's one example http://hackage.haskell.org/packages/archive/trifecta/0.41/doc/html/Text-Trifecta-Parser-Token-Identifier-Style.html
10:48:50 <Eduard_Munteanu> rwbarton: possibly because it's supposed to be like pattern-matching on a datatype then repacking it. :/
10:49:50 <byorgey> Well, in fact, record update is just syntax sugar for precisely that, isn't it?
10:50:08 <Eduard_Munteanu> change :: (a -> b) -> Foo a -> Foo b; change f (Foo a) = Foo (f a)
10:50:23 <monochrom> a consequence of desugaring record update to case *and* not wanting to impose any more type conditions than what the case expression has. f{x=blah} = case f of Foo _ -> Foo blah, type change is allowed
10:50:30 <ddarius> The Report gives a translation.  That translation naturally will allow a new type.
10:50:57 <ddarius> It says nothing about types at all in at least the record updating section.
10:51:04 <rwbarton> yes, I see that now
10:51:06 <KirinDave> It feels so good to have a working haskell again.
10:51:18 <monochrom> (just like you want "case m of Just 10 -> Just True" because it is essential to writing fmap for Maybe)
10:52:07 <monochrom> They could add an extra type condition. But they're famous for being minimal about adding side conditions.
10:52:46 <monochrom> (and I agree. side conditions should be added only when lacking the side conditions is very harmful)
10:53:14 <byorgey> KirinDave: =)
10:54:14 <byorgey> I solved this kludgily in a few cases by adding an extra dummy field that was not being updated, thus fixing the type
10:54:45 <byorgey> since I wanted to allow users of the library to update record fields without having to add type annotations
10:56:26 <hpaste> “_Ray_” pasted “Haskell-y enough?” at http://hpaste.org/50931
10:57:37 <monochrom> bar = (foo `asTypeOf` bar){x = return ()} :)
10:58:10 <monochrom> thanks Scott for non-strictness!
10:58:45 <KirinDave> cabal-dev is still broken though. I think I understand how to fix it now. I will do that later.
10:58:56 <monochrom> (or Strachey. or Plotkin. or Landin. or Landau. whoever the scary guy it was. :) )
10:59:19 <mm_freak> got my first parallel program to work /well/
10:59:36 <mm_freak> it seems that parallelization is very good, until you need to do a lot of GC
11:00:19 <mm_freak> with two computations, which don't use GC much, i got well 180% performance
11:00:21 <ddarius> Doing a lot of GC is bad period.
11:00:59 <mm_freak> ddarius: is there a comma between bad and period?
11:01:37 <byorgey> _Ray_: there's no need to nest the where blocks
11:02:07 <_Ray_> byorgey, yeah, I just write it like I think of it mathematically. "Let x be y where y = ..."
11:02:20 <_Ray_> or "such that y = ..."
11:03:08 <byorgey> _Ray_: and personally I might inline a few of the smallest definitions, for example just write 'fmap cambiar_color' instead of defining inversa
11:03:22 <byorgey> but that doesn't really matter that much.  Other than that it looks very nice.
11:03:46 <zygoloid> _Ray_: i think generar would be clearer if written pointfully
11:04:09 <_Ray_> alright :) *notes these things down*
11:04:16 <byorgey> yes, that's true, or at least just make the first argument explicit
11:04:56 <byorgey> generar p = takeWhile en_rango . flip iterate p   -- this looks ok to me
11:05:10 <zygoloid> _Ray_: note the two suggestions from hslint (at the bottom of the paste)
11:05:24 <_Ray_> yeah, I replaced concat $ map by concatMap
11:06:16 <_Ray_> ah, didn't know one could use [Posicion -> Posicion], but that makes sense I guess :)
11:06:20 <zygoloid> i'd probably write that as direcciones >>= inversiones p, but concatMap is fine
11:06:38 <_Ray_> I was wondering if concatMap was >>= for the list applicative
11:06:46 <benmachine> concatMap is actually =<<
11:06:49 <benmachine> =<< is better than >>=
11:06:50 <benmachine> true fact
11:08:32 <azaq231> Though not for the applicative, but the list monad
11:09:33 <_Ray_> yeah, went and googled that :)
11:10:40 <zygoloid> _Ray_: direcciones = [desplazarFila x . displazarColumna y | x <- [-1..1], y <- [-1..1], (x,y) /= (0,0)]
11:12:01 <maloi> "class MonadState m s | m -> s where" what does the | m -> s mean?
11:12:09 <benmachine> maloi: functional dependency
11:12:15 <benmachine> maloi: it means each m can only have one s
11:12:22 <benmachine> so each state monad only has one state type
11:12:35 <_Ray_> zygoloid, I was wondering how to say that :)
11:12:47 <_Ray_> (thanks!)
11:13:16 <benmachine> you can't have instance MonadState (State (s,t)) s *and* instance MonadState (State (s,t)) t both at once, for example
11:13:32 <benmachine> this makes type inference much easier since once GHC knows what m is, it can tell what s is
11:14:22 <maloi> ok thank you, makes sense
11:25:00 <dylukes> So, are fundeps on the way out?
11:25:28 <ezyang> Seems like it.
11:25:39 <dylukes> What would you then use for, i.e, vector stuff?
11:25:47 <dylukes> (the usual fundeps example I've seen)
11:28:07 <kmc> you can translate fundeps to MPTC with associated types
11:28:20 <kmc> or sometimes to non-MP TC, but i'm not sure if it's always possible
11:29:16 <kmc> «class Foo a b | a -> b»  ⇒  «class (B a ~ b) => Foo a b where { type B a }»
11:29:32 <newsham> duke: why not encapsulate all three as a single api ?
11:29:36 <kmc> ⇒  «class Foo a where { type B a }»
11:30:04 <kmc> dylukes, makes sense?
11:30:17 <dylukes> associated types?
11:30:26 <kmc> yeah.  associated type synonyms, in this case
11:30:47 <newsham> oops, i just responded to ancient scrollback
11:31:42 <parcs> fundeps are more powerful than associated types
11:31:44 <maloi> this looks ugly to me :/
11:32:21 <kmc> i believe that, with superclass equality constraints like that, you can turn any fundep into an asstype
11:33:02 <hpaste> “_Ray_” pasted “Is there a common name for this funciton?” at http://hpaste.org/50932
11:33:08 <kmc> without necessarily eliminating that parameter from the instance head
11:33:12 <kmc> i'd be interested to see a counterexample, though
11:36:08 <mauke> :t uncurry (fmap . (,))
11:36:09 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
11:36:40 <mauke> :t mapMaybe (uncurry (fmap . (,)))
11:36:41 <lambdabot> forall a a1. [(a1, Maybe a)] -> [(a1, a)]
11:38:47 <dylukes> @hoogle [(a, f b)] -> [(a, b)]
11:38:47 <lambdabot> No results found
11:39:00 <dylukes> @hoogle m (a, f b) -> m (a, b)
11:39:01 <lambdabot> No results found
11:39:58 <dylukes> :t mapMaybe
11:39:59 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
11:46:20 <BobFunk> does Network.URI really not have a clean way of getting the username/pw from a uri?
11:46:36 <BobFunk> and is there some alternative library that will do that?
11:48:26 <benmachine> BobFunk: does uriAuthority not get you what you want?
11:48:52 <BobFunk> nopes
11:49:05 <monochrom> a common form of username/pw is part of http rather than part of uri
11:49:22 <BobFunk> hmm
11:49:41 <benmachine> fmap uriUserInfo . uriAuthority =<< parseURI "ftp://foo:bar@whatever.example/place"
11:49:45 <benmachine> Just "foo:bar@"
11:49:52 <BobFunk> yeah
11:49:57 <BobFunk> I've gotten that far
11:50:13 <BobFunk> and obviously I can then parse that string manually
11:50:31 <BobFunk> just seems kinda ugly compared to how I would do it in something like ruby
11:50:43 <benmachine> I'd agree that Network.URI could be better
11:51:32 <BobFunk> so was just wondering if there was some library with a cleaner way of getting to that
11:51:42 <BobFunk> if not I'll just parse the string by hand
11:51:49 <benmachine> I know there are other URI libraries
11:52:01 <benmachine> couldn't comment on whether they are better or worse
11:52:57 <monochrom> I see. this form of username/pw is probably just too uncommon
11:53:20 <benmachine> http://hackage.haskell.org/packages/archive/uri/0.1.6/doc/html/Text-URI.html this at least doesn't seem to include the @?
11:54:01 <BobFunk> monochrom: foo:bar@example.com/ is not uncommon
11:54:21 <benmachine> kind of insecure though :P
11:54:45 <BobFunk> benmachine: it's just for parsing an amqp uri from the environment
11:55:15 <BobFunk> so no security problem - not a url to put in a browser ;)
11:55:35 <BobFunk> will try the Text.URI version
11:56:09 <BobFunk> at least getting it without the trailing @ makes turning it into user/pw straight forward
11:56:15 <benmachine> yeah, just a splitAt
11:56:43 <BobFunk> yeah
12:09:57 <hpaste> nh2 pasted “Wavefront Array dynamic programming” at http://hpaste.org/50934
12:10:19 <nh2> yo yo more from the strict array front
12:11:21 * hackagebot hoogle 4.2.7 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.7 (NeilMitchell)
12:11:51 <nh2> monochrom, rwbarton: that paste contains my problem. The graph shows that something is not going as I expect, even though the foldl should make sure that the array elements are evaluated in the desired order
12:21:17 <ddarius> r `seq` r is r.
12:21:36 <mauke> id = join seq
12:22:07 <benmachine> join = (>>= id)
12:22:22 <benmachine> join = (>>= join seq)
12:22:25 <benmachine> what can possibly go wrong
12:22:42 <mauke> @pl join = (>>= join seq)
12:22:42 <lambdabot> join = fix ((=<<) . ($ seq))
12:22:48 <mauke> ($) = id
12:31:48 <ion> :t fix ((=<<) . flip (join seq) seq)
12:31:49 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
12:31:49 <lambdabot>     Probable cause: `seq' is applied to too many arguments
12:31:49 <lambdabot>     In the first argument of `join', namely `seq'
12:32:36 <ion> :t fix ((=<<) . ($ seq))
12:32:37 <lambdabot>     Occurs check: cannot construct the infinite type:
12:32:37 <lambdabot>       b = (b1 -> b1) -> b
12:32:37 <lambdabot>     Probable cause: `$' is applied to too many arguments
12:33:36 <benmachine> :t let join = (>>= join seq) in join
12:33:37 <lambdabot>     Occurs check: cannot construct the infinite type: b = (t -> t) -> b
12:33:38 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
12:33:38 <lambdabot>     In the expression: (>>= join seq)
12:33:52 <benmachine> :t join seq
12:33:54 <lambdabot> forall a. a -> a
12:34:14 <benmachine> hm
12:34:21 <benmachine> :t let join = (>>= id) in join
12:34:22 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:35:04 <Saizan> :t let join :: (Monad m) => m (m b) -> m b; join = (>>= join seq) in join
12:35:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:35:21 <benmachine> hm
12:35:25 <Saizan> polymorphic recursion ftw
12:35:52 <benmachine> sounds evil
12:36:03 <benmachine> you can't get polymorphic recursion with fix?
12:36:49 <ion> Yeah, you can’t.
12:38:04 <Saizan> a newtype should work for that
12:39:00 <benford> mm_freak: Do you have the code for NetWire anywhere (github etc)?
12:42:37 <wjlroe> Could anybody point out to me how you parse a string (json) to a data structure using Aeson? I'm banging my head against the wall here
12:49:28 <JoeyA> wjlroe: json :: Parser Value
12:49:57 <JoeyA> Apparently, the documentation (http://hackage.haskell.org/packages/archive/aeson/0.3.2.11/doc/html/Data-Aeson.html) uses "Parser" to refer to both its own parsing abstraction and that of AttoParsec.  Evil...
12:50:02 <wjlroe> it's way more complicated than that
12:50:05 <wjlroe> let result = case A.parse Aeson.json body of
12:50:05 <wjlroe>                  A.Done _ a     -> fromJSON a
12:50:05 <wjlroe>                  A.Fail _ _ err -> Error err
12:50:05 <wjlroe>   case result of
12:50:05 <wjlroe>     Success payload ->
12:50:18 <JoeyA> Indeed.
12:50:23 <wjlroe> days of scouring the web to find that
12:50:33 <wjlroe> pretty depressing really
12:50:52 <JoeyA> :(  Sounds like that's something Data.Aeson should be dealing with.
12:51:11 <JoeyA> (e.g. by providing a ByteString -> Either String Value function)
12:51:18 <wjlroe> yeah exactly
12:51:23 <JoeyA> Rather than making users have to learn about AttoParsec.
12:51:55 <JoeyA> Have you looked at AttoJSON?  What sets Aeson apart, other than speed?
12:52:53 <wjlroe> haven't seen attojson. Aeson seemed mature and was being used by the Riak library (by the same author) - so it seemed a good choice.
12:53:04 <JoeyA> ah
12:53:22 <JoeyA> There's one thing I do know about attojson: it properly handles surrogate pairs ;-)
12:53:38 <wjlroe> what does that mean?
12:59:17 <JoeyA> wjlroe: JavaScript and JSON use UTF-16 escapes, so U+1D565 is encoded as "\uD835\uDD65"
12:59:41 <wjlroe> oh right
13:01:27 <peteriserins> is there a way to implement a typeclass for types that support cons, car, cdr?
13:01:56 <ion> yes
13:01:58 <ezyang> ,seen byorgey
13:02:03 <ezyang> @seen byorgey
13:02:03 <preflex>  byorgey was last seen on #haskell 1 hour, 57 minutes and 10 seconds ago, saying: generar p = takeWhile en_rango . flip iterate p   -- this looks ok to me
13:02:03 <lambdabot> Unknown command, try @list
13:02:27 <JoeyA> wjlroe: It looks to me like Aeson made better choices regarding data representation.
13:02:39 <peteriserins> ion: could you elaborate? I had a long discussion with someone on this before and we couldn't find the answer
13:03:15 <byorgey> hi ezyang
13:03:42 <byorgey> peteriserins: well, what types would those operations have?
13:04:08 <ezyang> byorgey: Finally getting round to editing the MPI article (first grad app deadline was yesterday), just letting you know that I haven't dropped off the face of the earth ^^
13:04:16 <peteriserins> byorgey: if p is the type in the typeclass, then they would have types a -> b -> p, p -> a, p -> b respectively
13:04:18 <byorgey> ezyang: ok, thanks, no worries =)
13:05:23 <byorgey> peteriserins: oh, you want heterogeneously-typed cons?  so e.g. I could do  cons 1 (cons "helo" (cons 6.7 ()))  or something like that?
13:05:43 <peteriserins> byorgey: yes
13:05:59 <byorgey> if that is really what you want it becomes much more complicated, but it can be done.  In fact, it already has been done, and the result is called HList
13:06:02 <byorgey> @where HList
13:06:02 <lambdabot> http://homepages.cwi.nl/~ralf/HList
13:06:08 <byorgey> @package HList
13:06:08 <lambdabot> http://hackage.haskell.org/package/HList
13:06:18 <peteriserins> byorgey: interesting, I'll take a look
13:06:27 <benmachine> peteriserins: the type of your result must encode what the structure contains
13:06:31 <benmachine> or can contain
13:06:32 <byorgey> well, that doesn't give you a *type class*.  But I am not sure why you would want a type class.
13:06:57 <peteriserins> byorgey: what does it give me then?
13:07:01 <benmachine> so if you cons "foo" 7, then your return type should probably mention String and Integer
13:07:11 <peteriserins> byorgey: I want a typeclass, because I have multiple implementations
13:07:16 <peteriserins> byorgey: of the type
13:07:21 <byorgey> peteriserins: it gives you one *particular* type that supports cons, car, and cdr
13:07:27 <byorgey> peteriserins: you do?  what are they?
13:07:47 <peteriserins> well I could use a tuple
13:07:50 <kmc> data Nil; data Cons x xs;  data List t where { Nil :: List Nil;  Cons :: x -> xs -> List (Cons x xs) }
13:07:56 <peteriserins> byorgey: or Church pairs
13:09:18 <byorgey> peteriserins: the problem is that  a -> b -> p  is not actually a good type for cons.  Once you apply cons you now have something that is just of type 'p' and you have lost the information about a and b forever, so you can never take it back apart.
13:09:38 <byorgey> so you really want something of type  a -> b -> p a b
13:09:42 <peteriserins> byorgey: I see what you mean
13:10:14 <peteriserins> byorgey: ok, but are there any other ways to create parametrized types other than through 'data'?
13:10:22 <byorgey> try making a type class with operations of type  cons :: a -> b -> p a b; car :: p a b -> a; cdr :: p a b -> b  and see how far you get
13:10:36 <peteriserins> byorgey: I have that defined already, but it didn't work with my instance
13:10:47 <byorgey> peteriserins: why not? what error did you get?
13:11:09 <byorgey> peteriserins: no, 'data' is the only way of creating new types, parameterized or otherwise
13:11:22 <byorgey> actually that is a bit of a white lie, there are also data families, but I doubt that will help.
13:12:32 <peteriserins> byorgey: the type families way didn't work
13:12:50 <peteriserins> byorgey: I wanted to have the type (a -> b -> c) -> c be an instance of the type class
13:13:23 <peteriserins> byorgey: is there a way to still encapsulate this idea into a type of the form p a b?
13:13:44 <peteriserins> byorgey: or are those limited to a constructor Cons a b?
13:13:55 <byorgey> peteriserins: oh, I see what you mean, no, you would have to make a newtype wrapper around  (a -> b -> c) -> c
13:13:59 <benmachine> data ChurchPair a b = forall c. CP ((a -> b -> c) -> c)
13:14:02 <benmachine> something like that?
13:14:22 <byorgey> newtype ChurchPair a b = ChurchPair (forall c. (a -> b -> c) -> c)
13:14:30 <benmachine> byorgey: can you have existential newtypes?
13:14:34 <byorgey> I think you need the forall c. inside the constructor
13:14:38 <benmachine> oh right
13:14:47 <byorgey> you don't want an existential in this case, you want a rank-2 type
13:14:54 <benmachine> ah, yes
13:15:00 <benmachine> ok
13:15:03 <JoeyA> wjlroe: http://hpaste.org/50936
13:15:24 <JoeyA> That's an implementation of the missing decode function.  It type checks, but I don't know if it works otherwise.
13:15:24 <byorgey> however, it's a good question, I don't know whether you can have existential newtypes
13:15:48 <parcs> you can't
13:15:53 <benmachine> I didn't think so
13:16:02 <byorgey> me neither, thanks parcs =)
13:16:16 <JoeyA> In particular, Aeson might have different error-reporting conventions.
13:16:18 <benmachine>     A newtype constructor cannot have an existential context,
13:16:18 <benmachine>       but `S' does
13:16:26 <jmcarthur> well it would certainly be tough if it has to carry a type class dictionary around with it
13:16:33 <jmcarthur> in the absense of that i see no problem with it, really
13:17:01 <JoeyA> wjlroe: I'll submit a patch to the author in a few hours.
13:17:02 <peteriserins> yes i get that error exactly
13:17:13 <wjlroe> JoeyA: ok cool. thanks
13:17:24 <JoeyA> no problem.  Thanks for spotting Aeson for me :-)
13:19:57 <joe6> i am getting confused with the classes and instances. I have 3 classes Global, ShortField, BitField. I want to make the ShortField and BitField classes have instances of Global. Is that possible?
13:20:43 <joe6> global class includes all types included by ShortField and BitField classes.
13:20:51 <byorgey> peteriserins: you don't want an existential context though.  What definition are you using?  The one I pasted?
13:20:56 <joe6> s/global class/Global class/
13:21:20 <peteriserins> byorgey: yes
13:21:35 <byorgey> peteriserins: hmm, let me try, just a second
13:22:07 <hpaste> peteriserins pasted “pairing trouble” at http://hpaste.org/50937
13:22:46 <byorgey> peteriserins: no, you are using the one benmachine wrote
13:22:55 <byorgey> peteriserins: move the forall c. inside the CP constructor
13:23:02 <byorgey> peteriserins: and enable the Rank2Types extension
13:24:19 <peteriserins> byorgey: it says kind mismatch
13:24:38 <byorgey> peteriserins: yes, it should be  instance Pair ChurchPair, not instance Pair (Church a b)
13:25:46 <byorgey> also you need parens around (CP z)
13:25:59 <peteriserins> byorgey: yeah, placed them in and it compiles
13:26:03 <peteriserins> byorgey: let me see if it works
13:27:26 <peteriserins> byorgey: brilliant, it does work; thank you very much
13:27:33 <byorgey> great! you're welcome
13:27:46 <peteriserins> byorgey: where could I read up about kinds/forall?
13:28:22 <byorgey> hmm, good question, I am not sure
13:28:36 <byorgey> it's all stuff I've picked up here and there over the years
13:28:58 <byorgey> honestly the GHC user manual might be just as good a place as any
13:29:28 <peteriserins> byorgey: ok, cool
13:29:36 <mm_freak> @tell benford right now the source code repository is not public, but you can get the source code of the latest release from <http://hackage.haskell.org/package/netwire>
13:29:37 <lambdabot> Consider it noted.
13:29:45 <byorgey> also feel free to ask questions in here
13:29:47 <Cale> peteriserins: kinds are pretty simple in Haskell (at least until the next GHC ;)
13:30:03 <Cale> peteriserins: You have kind * which consists of all the types which actually have values in them
13:30:15 * byorgey looks around guiltily
13:30:16 <Cale> peteriserins: and then for any two kinds k1 and k2, there is a kind k1 -> k2
13:30:46 <mm_freak> Cale: what will be different in the next release?
13:30:47 <mjo> Is there any way to, uh, deeply construct an object? Like let x = Foo { bar = mkBaz }, and then have bar and all of its records fully deepSeq'd or something?
13:30:49 <Cale> Which is something takes some kind of type constructor and produces another. Commonly, * -> *
13:30:53 <peteriserins> Cale: oh, neat
13:31:16 <Cale> peteriserins: For example, data Tree a = Tip | Branch a (Tree a) (Tree a)
13:31:21 <Cale> will define Tree :: * -> *
13:31:37 <Cale> (a type constructor)
13:31:56 <byorgey> mm_freak: it won't be in the next release, but we are working on adding automatic lifting of data constructors to the type level, which requires (as a side benefit) adding kind polymorphism as well
13:32:25 <byorgey> there is already a prototype implementation which is coming along nicely
13:32:28 <Cale> Ah, which release are you hoping to be in?
13:32:37 <byorgey> see http://hackage.haskell.org/trac/ghc/wiki/GhcKinds
13:32:51 <byorgey> Cale: not sure at this point, whichever one it is done by =)
13:33:03 <byorgey> 7.4 is coming out around ICFP and it most definitely won't be in that one
13:33:31 <peteriserins> Cale: so if you '|' type constructors, the 'highest' kind will be taken into account (Branch in this case)?
13:33:32 <mm_freak> byorgey: i'm not sure i understand…  would that give you types on the fly?
13:33:38 <Cale> mjo: Well, if you define an object entirely out of data constructors, then it's already as evaluated as it'll ever get.
13:34:02 <Cale> peteriserins: The Tip and Branch are data constructors, down at the level of values
13:34:19 <mm_freak> peteriserins: kinds are sort of types for types…  just like f x = x has the type a -> a, F x = F x has the kind * -> *
13:34:19 <Cale> peteriserins: Tip :: Tree a, and Branch :: a -> Tree a -> Tree a -> Tree a
13:34:24 <byorgey> mm_freak: no, it would essentially let you have user-defined kinds, by lifting user-defined data types
13:34:34 <Cale> peteriserins: The kind says what Tree itself does to types
13:34:41 <byorgey> it also allows you to do some dependent-type-ish sorts of things
13:34:50 <Cale> peteriserins: That is, it takes a type (like Integer) and produces another type (Tree Integer)
13:34:54 <mjo> What do you mean by data constructors? Here's the deal: I've got these objects. Grids have cubes have tetrahedra. Right now, all of the tetrahedra stuff is calculated on the fly -- given a grid, I calculate the cube, and then the tetrahedron, and then the value.
13:35:14 <mm_freak> byorgey: interesting…  is there some demo code?
13:35:29 <joe6> can I make a class an instance of another class?
13:35:30 <mjo> It uses no memory, but way too much CPU. I would like to "store" the tetrahedra in cubes and then the cubes in the grid, which I would then pass around.
13:35:33 <byorgey> mm_freak: yes, see the wiki page I linked above
13:35:41 <mm_freak> thanks
13:35:47 <Cale> mjo: Data constructors are values starting with a capital letter or colon (:), which can be pattern matched on directly.
13:36:11 <Cale> mjo: You can also use list syntax like [1,2,3], as that's just syntax sugar for 1 : (2 : (3 : []))
13:36:32 <peteriserins> Cale: so can you do something like Tree (Type a) = ...?
13:37:16 <Cale> peteriserins: For any type a (something of kind * like Integer, or String, or [Integer], etc.), it's valid to have Tree a
13:37:29 <Cale> :k Integer
13:37:30 <lambdabot> *
13:37:33 <Cale> :k Tree
13:37:34 <lambdabot> * -> *
13:37:37 <Cale> :k Tree Integer
13:37:37 <lambdabot> *
13:37:43 <mm_freak> byorgey: wait…  right now you can't in general define instances for partially applied type synonms…  would that change?
13:37:43 <Cale> :k Tree (Tree Integer)
13:37:44 <lambdabot> *
13:37:50 <peteriserins> Cale: what would be an example of * -> * -> * then?
13:38:02 <Cale> :k Either
13:38:02 <lambdabot> * -> * -> *
13:38:02 <peteriserins> Cake: a function that takes Three?
13:38:03 <mjo> Ok, so, data Bar = Bar { baz :: Baz }; data Foo = Foo { bar :: Bar }; let x = Bar { baz=quux }; let y = Foo { bar=x } will fully evaluate quux?
13:38:04 <Cale> :k Either Integer
13:38:05 <lambdabot> * -> *
13:38:07 <byorgey> mm_freak: no, not currently
13:38:07 <Cale> :k Either Integer Bool
13:38:07 <lambdabot> *
13:38:23 <Cale> The cake is a lie
13:38:25 <peteriserins> Cale: ok, I get it
13:38:27 <Cale> > cake
13:38:28 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
13:38:29 <ion> The Cale is a lie
13:38:34 <byorgey> mm_freak: it would be really cool if it did change, but it leads into some very deep waters that I don't fully understand
13:38:45 <peteriserins> Cale: sort of :)
13:38:49 <Cale> :k StateT
13:38:50 <lambdabot> * -> (* -> *) -> * -> *
13:38:55 <Cale> :k StateT Integer
13:38:56 <peteriserins> Cale: sorry for the cake, your name is too short to tab complete
13:38:56 <lambdabot> (* -> *) -> * -> *
13:38:58 <Cale> :k StateT Integer Tree
13:38:59 <lambdabot> * -> *
13:39:01 <Cale> :k StateT Integer Tree String
13:39:02 <mm_freak> byorgey: i see…  now that would be amazing
13:39:02 <lambdabot> *
13:39:17 <mjo> In other words, if I call (bar y), will it do a bunch of computation or return instantly?
13:39:55 <mjo> baz (bar y), sorry
13:40:10 <Cale> mjo: In that case, quux will not be evaluated (though you didn't define it, so it might be evaluated already)
13:40:39 <Cale> x and y are already evaluated, in that they consist of a data constructor applied to some values
13:40:54 <Cale> (and are already in the easiest form to pattern match on)
13:41:33 <mjo> Ok, then assuming quux takes a long time to compute, is there some way I can compute it upon constructing y and just store it?
13:42:03 <mjo> I don't want it to be recomputed every time I call baz (bar y), is the thing.
13:42:07 <Cale> You can write  x = quux `seq` Bar { baz = quux }
13:42:21 <Cale> and then nothing can pattern match on x without evaluating quux first
13:42:34 <mjo> Ah, I did know that much. Now assume that instead of three levels, I have like, ten =)
13:42:44 <mjo> Is there a way to do it that doesn't suck?
13:43:46 <Cale> Well, you can use things like rdeepseq from Control.Parallel.Strategies
13:44:06 <Sgeo> Oh, he's not here
13:44:21 <ion> It’s a she. And she’s always here.
13:44:27 <Phantom_Hoover> Sgeo, YOU BROUGHT ME HERE UNDER FALSE PRE— OK, that's fine.
13:44:34 <Cale> Assuming that quux needs to be deeply evaluated,  (quux `using` rdeepseq) `seq` ...
13:44:47 <ion> Except when linode craps itself.
13:45:11 <Phantom_Hoover> ion, zzo38 needs linode?
13:45:17 <Cale> ion: wat, it wasn't clear who Sgeo was referring to
13:45:23 <ion> @hoogle using
13:45:23 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
13:46:10 <ion> cale: My crystal ball said he was referring to her. But it’s wrong every now and then. Should update the firmware.
13:46:19 <Cale> There's also rnf in Control.DeepSeq
13:46:28 <Cale> rnf quux `seq` ...
13:46:40 <Cale> That stands for "reduce to normal form"
13:46:50 <Cale> if it helps :)
13:47:17 <mjo> Hmm.. but in those cases, I need to know all of the things that the tenth thing down has as records.
13:47:28 <Cale> hmm?
13:47:38 <Cale> You just need an instance of NFData
13:47:47 <mjo> quux might not be defined anywhere near x
13:48:10 <Cale> Oh, well, the point of rnf is that it recursively goes through the whole thing
13:48:12 <joe6> is this possible? CGlobal.hs http://codepad.org/cOIcUtKi ShortField.hs http://codepad.org/FqFDlUcO, ghci error:  http://codepad.org/ad8lnrdt
13:48:37 <Cale> and evaluates all the fields of all the data constructors recursively
13:48:38 <joe6> what is the suggested/recommended way of designing for such scenarios.
13:48:40 <wieczyk> How to access type [] when Prelude is qualified? "type X = (Prelude.[]) Int" does not work.
13:49:05 <masonkramer> hi guys.  Rank newb here trying to get hands bloody.  I'm working through some codegolf.stackexchange.com examples.  Right now I'm trying to implement "stepwise", a function that takes a list and returns true each element in the list is one greater than the previous element
13:49:19 <mjo> Oh, sorry. Maybe rnf will work.
13:49:28 <masonkramer> http://hpaste.org/50938 - I get a parse error
13:49:35 <Cale> mjo: You may need to write some instances of NFData for your types
13:49:49 <joe6> I have a 2 typeclasses and second type class functions can be derived from the first type class.
13:50:01 <Cale> masonkramer: That's just because you put an expression at the top level
13:50:16 <Cale> masonkramer: Just comment out those last 2 lines
13:50:27 <joe6> how do i design for such  situation. Any thoughts, please?
13:50:28 <Cale> also, you probably should handle the case of an empty list
13:50:29 <byorgey> masonkramer: you also need parens around  y:xs in the recursive call to stepwise
13:50:30 <masonkramer> But I need to call the function to see if it works
13:50:36 <Cale> masonkramer: do that from ghci
13:50:41 <Cale> masonkramer: Or else write something like:
13:50:59 <Cale> main = do print (stepwise [4,1,2,4]); print (stepwise [1,2,3,4])
13:51:00 <mjo> I think if I make most of my functions records and compute them at construction, rnf could do it.
13:51:14 <ddarius> wieczyk: [] can never come from anywhere other than the Prelude and should not ever need to be qualified.
13:51:16 <Cale> and then you can compile the program, though it's probably easier just to use ghci
13:51:24 <mjo> Of course I'll probably go from needing 16 minutes to needing 16 gigs of RAM, but this is science.
13:52:11 <Cale> mjo: In my experience, additional strictness is something that you rarely need very much of, and usually one seq at the right place will fix everything.
13:52:21 <byorgey> wieczyk: type X = [] Prelude.Int  works for me
13:53:18 <Saizan> but Prelude.[] doesn't, suggesting RankNTypes
13:53:19 <Cale> mjo: Or else, using something like foldl' instead of foldr/foldl, or strict record fields.
13:53:26 <Saizan> i guess it's a bug in the parser
13:53:36 <Cale> (usually just one of these will solve the problem, though sometimes you need two of them)
13:54:03 <Cale> mjo: Can I look at your program?
13:54:03 <mjo> Well, I can theoretically speed my program up by 26*N where bigger N means more awesome pictures to put on my slides. I just didn't know how to go fully strict.
13:54:08 <Saizan> wieczyk: add another import Prelude ([])
13:54:18 <taotree> how would I pattern match on NaN?
13:54:42 <Saizan> you can't
13:54:42 <taotree> I have a Float parameter and I want to pattern match on if it's NaN
13:54:43 <Cale> mjo: At best you're just moving the computation around, and at worst, you're demanding more CPU.
13:54:49 <Saizan> ?type isNaN
13:54:50 <lambdabot> forall a. (RealFloat a) => a -> Bool
13:54:51 <byorgey> taotree: you can't, use the isNaN function
13:54:59 <taotree> ok
13:55:01 <mjo> Cale: I don't even know. I'd have to ask my advisor =)
13:55:02 <Cale> mjo: Strictness will only ever help with memory usage.
13:55:23 <Cale> (and GHC stack space, which is a measure of how many pattern matches are waiting to happen)
13:56:13 <Cale> Of course, lower memory usage can translate to faster programs.
13:56:22 <Cale> (if less GC has to be done)
13:56:23 <mjo> In my case, I'm taking a point at the center of a 3x3x3 cube and looking at the 26 points around it. Then, I move one unit in another direction, and do it again. Currently, I recompute all of the points even though most of them overlap.
13:56:40 <c_wraith> too much strictness creates drag...  You want to avoid that.
13:56:47 <Cale> Okay, so the real need is for memoisation.
13:56:51 <Cale> Not strictness.
13:57:44 <Cale> You can form a large array consisting of all the results of evaluating your function at various points, and index into that array instead of applying your function.
13:57:49 <mjo> Hm, maybe. The algorithm runs in parallel though. So unless I do something devious.. well, I'd have to do something devious.
13:58:06 <Cale> and so long as the array doesn't go out of scope, any result in it which is computed will remain computed.
13:58:14 <mjo> The threads would need to share the hash though, right?
13:58:17 <Cale> even in parallel :)
13:58:38 <Cale> and even with concurrency :)
13:59:52 <mjo> The concurrency is thanks to Repa's traverse function, and I couldn't think of a way to share a map between threads in what are essentially parallel 'map' operations.
14:00:01 <mjo> share a hash
14:00:49 <mjo> The thinking that led to my question was: maybe if I just use a shitload of memory and store everything in an immutable object, I can let Repa do its thing with that object.
14:00:59 <Cale> as a stupid example...
14:01:08 <ddarius> Wonderful.  Microsoft thinks I'm on a phone.
14:01:20 <Cale> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 1000
14:01:23 <lambdabot>   mueval-core: Time limit exceeded
14:01:24 <Cale> ^^ this takes forever
14:01:24 <geheimdienst> microsoft thinks i am a phone
14:01:50 <Cale> > let fibs = array (0,1000) [(n,fib n) | n <- [0..1000]]; fib 0 = 0; fib 1 = 1; fib n = fibs ! (n-1) + fibs ! (n-2) in fib 1000
14:01:51 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
14:02:00 <Cale> ^^ this is "linear"ish
14:02:19 <Cale> (not really because the numbers get big, but if you ignore the cost of addition, then linear)
14:03:08 <Cale> Note how I can define that array via mutual recursion, because the entries are lazily computed.
14:03:25 <Cale> but once the entries get computed, they stay computed forever
14:03:42 <Cale> this is true even if the array is shared between multiple threads or is being computed in parallel
14:03:47 <Cale> (by multiple sparks0
14:03:49 <Cale> )
14:03:58 <mjo> There may be some way to trick Repa into doing that, but you've hurt my head.
14:04:14 <mjo> I do understand the fibs example though.
14:04:17 <benmachine> the cost of addition is log (fib n) which is roughly n, right?
14:04:29 <Cale> benmachine: yeah
14:04:42 <Cale> Well...
14:04:43 <Cale> hmm
14:04:54 <Cale> Actually, the cost of addition is a complicated thing :)
14:05:48 <Cale> If you do the addition in the naive way, it'll be O(number of bits).
14:05:54 * benmachine is naive
14:06:09 <Cale> http://www.archive.org/details/Nicholas1987
14:06:12 <mm_freak> i need a type class resembling Alternative, but with default errors, if applicable, such that i can define an instance for (Either e)…  what would you suggest?
14:06:17 <Cale> ^^ interesting talk about the complexity of addition
14:06:49 <mm_freak> i could just use Maybe, but i don't want to constrain it…  users should be given the ability to use Either instead of Maybe
14:06:52 <Cale> There are some really clever semigroups you can put to use to do a lot better than chaining the carries along one at a time
14:08:12 <Cale> You can essentially compute the effects of the carries separately from the bitwise sum, and reassociate that computation to do it in a recursive fashion and get down to log(number of bits) delay
14:08:27 <Cale> (doing some parallel computation)
14:08:45 <Cale> I'm not sure if GMP actually does that, but your processor likely does internally to some extent.
14:09:51 <Cale> and then you can do even better, impressively :)
14:10:02 <benmachine> this video is 42 minutes long :o
14:10:31 <Cale> It's surprisingly interesting, for a 42 minute long video on how to add.
14:10:32 <ddarius> Cale: If speed can be gained by spending transistors nowadays, it is done.
14:11:18 <benmachine> also this guy on the right seems to be staring with unsettling intensity at the woman who is speaking
14:11:20 * hackagebot gitit 0.8.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.8.1 (JohnMacFarlane)
14:11:54 <ddarius> benmachine: It's the '80s, man.
14:13:02 <Cale> He's Dr. Nicholas goddamn Pippenger, and he'll stare at whoever he wants.
14:13:15 <int80_h> so I was trying to figure out the best way to express the problem I was having with newEmptyMVar, and in the process solved my problem.
14:13:25 <Cale> int80_h: :)
14:13:39 <byorgey> int80_h: trying to figure things out is an excellent way of solving problems =)
14:13:44 <int80_h> Cale: I was trying to apply what you told me the other day.
14:14:08 <int80_h> it works. :)
14:15:56 <int80_h> ah, I hope locking works the way I think it does. That's the goal today.
14:16:10 <int80_h> finding what locking does
14:17:30 <Cale> int80_h: MVars are essentially a combination of a variable and a lock. When you take the MVar, it becomes empty, and anything else trying to take the MVar gets blocked, and anything trying to put to the MVar is allowed to write it. When you put to the MVar it becomes full, and anything else trying to put to the MVar becomes blocked, while anything trying to take it succeeds.
14:18:10 <Cale> int80_h: So it's like a FIFO channel which can only contain one element at a time.
14:18:23 <int80_h> Cale: What I hope is that a queue of "take attempts" get built up, and then executed in FIFO order
14:18:42 <Cale> ah, they'll happen in a random order.
14:18:42 <int80_h> Cale: This would simplify my data structure
14:18:49 <Johannes`> hi, i don't have Text.Regex on my system using the arch package, how do i get it?
14:19:02 <Johannes`> ghc 7.0.3
14:19:25 <Cale> If you have multiple things trying to take an MVar, and it gets filled, one of them is woken up nondeterministically, and gets to proceed.
14:19:36 <int80_h> Cale: ack. Is there an obvious way to do what I want?
14:20:04 <int80_h> Cale; I would hate to make something more complicated for lack of knowing what my options are.
14:20:31 <Cale> int80_h: You could do something like make a Chan of MVars.
14:20:52 <Cale> Where requesters make a new empty MVar, write it into the Chan, and then try to take its value.
14:20:52 <int80_h> Cale: ah! okay I will investigate Chans
14:21:31 <Cale> and when the server eventually takes out the corresponding empty MVar and fills it, the client is woken up to deal with that piece of data
14:21:32 <mauke> int80_h: MVar guarantees FIFO wake-up
14:21:42 <Cale> Oh, does it?
14:22:10 <int80_h> mauke: excellent news. I was hoping this was the case.
14:22:11 <masonkramer> Cale: thanks, got it working.
14:22:28 <mauke> why not just look at the docs?
14:22:45 <masonkramer> Is my implementation of a Jolly Jumper algorithm stylistically abnormal? http://hpaste.org/50939
14:22:56 <Cale> oh, it does
14:23:01 <Cale> There are new docs :P
14:23:36 <Cale> It's interesting that they're willing to guarantee that property.
14:23:44 <c_wraith> masonkramer: well, first, look at the hlint suggestions at the bottom of that page
14:23:52 <Cale> masonkramer: Your code has tabs in it.
14:24:06 <int80_h> mauke: well the problem here is I am new to this aspect of programming. I get overwhelmed with a bunch of new info. I decided I just needed to start using them and see how they work.
14:24:10 <koeien37> masonkramer: line 20, no ( and )
14:24:12 <masonkramer> Where's the redundant if?
14:24:27 <koeien37> y - x == 1 && stepwise (y:xs)
14:24:58 <Cale> masonkramer: Make sure to configure your text editor to convert tabs to spaces.
14:24:59 <masonkramer> that's what hlint is complaining about?
14:25:04 <Cale> masonkramer: yeah
14:25:06 <koeien37> masonkramer: I suppose so. not sure.
14:25:15 <koeien37> hlint is quite smart then.
14:25:16 <masonkramer> I'm impressed
14:25:28 <Cale> If you write if expressions that have boolean results, I'm pretty sure it always complains.
14:25:34 <int80_h> I'm using "Control.Concurrent.MVar" as my reference. If they explicitly mention FIFO wake up guarantees, it was lost on me.
14:26:02 <koeien37> masonkramer: also, instead of "Jolly" and "Not Jolly" it is probably better to return a Bool
14:26:03 <Cale> int80_h: When multiple threads are blocked on an MVar, they are woken up in FIFO order. This is useful for providing fairness properties of abstractions built using MVars.
14:26:13 <Cale> int80_h: In the description of takeMVar
14:26:15 <mauke> int80_h: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent-MVar.html#v:takeMVar
14:26:15 <Cale> It's new.
14:26:29 <masonkramer> koeien37: You're right, but the codegolf problem specified the return values
14:26:35 <mauke> its newness is news to me
14:26:44 <Cale> That guarantee was never there before as well, so if you're looking at an old version of the docs, you might not see it.
14:26:53 <mauke> I've always thought MVars were built on thread queues
14:26:57 <int80_h> ah heck, it does explicitly mention it.
14:27:02 <c_wraith> depends on your definition of "never".  I seem to remember it being there as far back as 6.10
14:27:03 <Cale> Maybe it was always a guarantee, but it wasn't documented, at least.
14:27:43 <masonkramer> Here's a more interesting question, maybe
14:27:46 <Cale> http://www.haskell.org/ghc/docs/6.4/html/libraries/base/Control.Concurrent.MVar.html
14:27:58 <Cale> in 6.4, they specified that it was a random order
14:28:10 <mauke> heh, 6.4
14:28:12 <int80_h> okay I confess I start programming without reading first. I do this all the time.
14:28:17 <koeien37> masonkramer: I would write stepwise as follows. stepwise xs = all (\(x,y) -> abs (y-x == 1)) (zip xs (tail xs)) -- or something like this :)
14:28:21 <mauke> Cale: which version of base was that?
14:28:46 <c_wraith> http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/Control-Concurrent-MVar.html contains the word "FIFO"
14:28:47 <int80_h> cowboy coding?
14:28:53 <Jafet> Isn't this implemented in ghc, not base?
14:29:08 <koeien37> masonkramer: that is not necessarily more readable, however
14:29:09 <c_wraith> Jafet: it's hardly the only point of base that's ghc-dependent
14:29:16 <Cale> Hey, I started out on 5.02! :)
14:29:17 <c_wraith> err, *part* of base
14:29:33 <mauke> http://hackage.haskell.org/packages/archive/base/2.0/doc/html/Control-Concurrent-MVar.html#v%3AtakeMVar
14:29:35 <Jafet> Well, you'd have to look at old ghcs then, not old bases.
14:30:27 <Cale> I'm not even sure the base package had a version number independent of GHC then.
14:30:35 <masonkramer> what does all do?
14:30:44 <Cale> it takes a predicate and a list
14:30:45 <koeien37> :t all
14:30:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:30:54 <Cale> and checks if the predicate is true on all elements of the list
14:30:56 <mauke> masonkramer: the obvious thing
14:31:00 <geheimdienst> > all isLetter "lolcats"
14:31:00 <lambdabot>   True
14:31:01 <Cale> > all even [2,4,6,8,10]
14:31:02 <lambdabot>   True
14:31:04 <koeien37> > all (>0) [1,2,3]
14:31:04 <geheimdienst> > all isLetter "lol123cats"
14:31:05 <lambdabot>   False
14:31:05 <lambdabot>   True
14:31:06 <Cale> > all even [2,4,6,8,10,11]
14:31:07 <lambdabot>   False
14:31:10 <koeien37> lol
14:31:25 <Cale> There's also any
14:31:28 <confab> :t any
14:31:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:31:42 <masonkramer> I don't understand how it's binding two variables at a time in the list
14:31:44 <Cale> which has the same type, and does the corresponding thing: check if any of the elements make the predicate true
14:31:51 <Cale> It's not.
14:31:55 <houeland> Heh, I switched to Chan for some of my code just because MVar was only currently implemented as doing FIFO but didn't guarantee it
14:32:05 <koeien37> > let xs = [1,2,3] in zip xs (tail xs)
14:32:06 <lambdabot>   [(1,2),(2,3)]
14:32:27 <koeien37> so this is the list of tuples of  successive elements in the list
14:32:30 <Cale> houeland: I would have as well. I'm actually really surprised that they're willing to guarantee FIFO order.
14:32:40 <Cale> (forever)
14:32:56 <Jafet> Cale makes it sound so ominous.
14:32:58 <masonkramer> Oh. got it
14:33:04 <Jafet> :t forever
14:33:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:33:07 <masonkramer> youre converting to tuples with zip and then binding a single tuple
14:33:17 <hpc> @src forever
14:33:18 <lambdabot> Source not found. I am sorry.
14:33:39 <houeland> Yeah when I read about it on a page they pretty much said "the way we're doing it now, it doesn't cost anything extra, but that could possibly change in the uncertain future-times"
14:34:00 <Cale> Jafet: Well, it's not that ominous, I guess. It's just that one can imagine that some implementations would not be able to make that guarantee.
14:34:08 <Cale> (and may be faster as a result)
14:34:49 <hpaste> monochrom pasted “Ackermann-Péter in System F” at http://hpaste.org/50940
14:34:52 <Jafet> I thought you were hinting that it may not forever be optimal to use FIFO ordering
14:35:11 <Cale> Jafet: yeah, that's basically what I'm hinting at :)
14:35:17 <Cale> But now they're stuck with it (kinda)
14:35:25 <monochrom> kmc, mux: Ackermann in System F: http://hpaste.org/50940
14:35:26 <Jafet> Well, "it's FIFO" is probably a good way to define "it's fair".
14:35:30 <Cale> Because programs will rely on it and break if they ever decide to change it.
14:35:45 <Cale> But it could certainly be fair without being FIFO :)
14:36:55 <copumpkin> monochrom: did you see mokus' graham's number? https://raw.github.com/mokus0/junkbox/master/Agda/ack.agda
14:37:08 <Jafet> Sure, but no one wants to bother defining fairness
14:37:57 <Cale> distinquishable
14:38:23 <Cale> vs. squishable
14:38:58 <monochrom> I haven't seen it, but I overheard you guys talking about it last time :)
14:39:17 <benmachine> I'm interested in a definition of fairness
14:39:40 <benmachine> oh yes I remember this
14:39:43 <monochrom> but people just disbelieved me last night when I said I read from somewhere that Ackermann can be done in System F
14:39:53 <benmachine> the previous version having a comment that described 4 as incomprehensibly large
14:39:59 <monochrom> (as it turns out I read it in Theorems for Free!)
14:40:25 <ddarius> That's because people don't consider primitive recursion at higher types which wasn't allowed originally.
14:41:04 <geheimdienst> i heard that ackermann of 4 is larger than the number of protons in the universe
14:41:10 <hpc> benmachine: you know the first rule of programming is 0, 1, infinity
14:41:19 <monochrom> (except the paper doesn't show how. well, I'm glad I can not only do it myself but also by mere mechanical formula manipulation, no insight or intuition needed)
14:41:20 <benmachine> :P
14:41:21 <ddarius> hpc: That doesn't sound like a rule.
14:41:25 * geheimdienst , phd in scientific science he "heard somewhere"
14:41:37 <benmachine> geheimdienst: ackermann takes two arguments
14:41:38 <ddarius> geheimdienst: There aren't that many protons in the universe.
14:41:54 <benmachine> ddarius: there are a fair few
14:41:55 <ddarius> benmachine: The one argument version just duplicates the arguments.
14:41:58 <benmachine> oh right
14:41:59 <houeland> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html talks about fairness
14:42:23 <ddarius> benmachine: You could count all of them in far less than a kilobyte of memory
14:43:06 <Cale> Hell, you could write the number on paper by hand if you knew it.
14:43:08 <monochrom> ok, yeah, doing (Λt. blah) (∀t. stuff) is certainly an ingredient in the solution
14:43:27 <Cale> It's only something like 80 digits or so
14:44:25 <geheimdienst> benmachine: more precisely, the guy giving the lecture in question was messing around with alpha, which he said was the inverse function of ackermann. he was arguing that it's so slow-growing that O(alpha) could be regarded as practically constant. not sure what he did with the 1 vs 2 arg issue
14:44:33 <ddarius> Protons aren't conserved, so the number of them isn't well-defined.
14:44:48 <Cale> indeed
14:45:02 <ddarius> alpha is usually one-argument, corresponding to the one-argument ackermann function.
14:45:03 * geheimdienst also has a master's degree in fuzzily remembered things he heard years ago
14:45:44 <Jafet> http://en.wikipedia.org/wiki/Ackermann_function
14:45:52 <kmc> thanks monochrom
14:45:54 <ddarius> For example, the Tarjan's union-find algorithm is like O(α(n)log n) or some such.
14:45:54 <Cale> geheimdienst: You can convert that into a Master's degree in Wikipedia pretty easily.
14:46:18 <Jafet> ddarius: dropping the log(n) term
14:46:29 <Cale> http://xkcd.com/903/
14:48:15 <geheimdienst> cale, yeah i'm working on that conversion now. wikipedia sez "α(n) is less than 5 for any practical input size n"
14:49:36 <monochrom> oh, I see, you mean using primitive recursion to build a function is an important ingredient.
14:50:26 <monochrom> ow, that is hard to word right
14:50:58 <ddarius> monochrom: Yes.
14:51:06 <ddarius> monochrom: Thanks for reading my mind.
14:53:22 <Veinor> i know i asked this before but i forgot the answer i got
14:53:38 <Veinor> what's the recommended way to install the haskell platform, through my distro's package manager or by myself?
14:53:45 <Veinor> (on debian linux)
14:54:06 <parcs> package manager
14:54:13 <parcs> that's what they're for
14:54:14 <monochrom> I recommend yourself, building from source. but few people share my view
14:54:17 <parcs> to install stuff
14:54:28 <int80_h> I agree with monochrom, but I'm a n00b
14:55:01 <parcs> though i would recommend not installing the hp at all
14:55:03 <Veinor> i heard that mixing package manager libs and cabal-installed libs can end badly
14:55:06 <parcs> just ghc and cabal-install
14:55:18 * ddarius recommends just not installing the platform.
14:55:19 <int80_h> what I did was install ghc from the package manager and used that to build the latest stable ghc, then used that to build haskell platform.
14:55:23 <monochrom> my http://www.vex.net/~trebla/haskell/sicp.xhtml has scenerios of how your distro can hurt
14:55:35 <Veinor> monochrom: right, that's what i read
14:55:47 <parcs> it has bitten me yet
14:56:28 <monochrom> well if you're a pro and you know cabal-install etc under the hood, you know what to avoid, so no problems will bite you
14:56:41 <monochrom> but tell me how many people are cabal-install pros
14:56:47 <Veinor> yeah :/
14:56:53 <Veinor> it's kind of frustrating comparing cabal-install to, say, pip
14:57:36 <Cale> My solution is just to completely avoid my distribution's packages when it comes to anything Haskell-related, and it has worked out quite nicely.
14:57:56 <geheimdienst> i just install ghc from the distro and everything else through cabal. i feel cabal is better than its reputation, i rarely have any trouble at all. the distro packages however are not so grate akshully, they don't even include haddocks ... my 2 cents
14:58:03 <Veinor> that's what I did before, but fresh vm, fresh start
14:58:12 <geheimdienst> ... but i don't do funky things like mixing global and user
14:58:19 <parcs> that's a good solution except that there's no way of automatically uninstalling ghc
14:58:36 <Cale> Yeah, I install GHC's generic linux binary globally, and then everything else local.
14:58:47 <Veinor> seems sensible.
14:58:53 <int80_h> I wish someone would take on haskell platform for netbsd. I could, but no time. I suspect this is everyone's reason.
14:59:10 <ddarius> That, or no one uses NetBSD.
14:59:16 <Cale> Sure, there's no automatic uninstall, but it's easy enough to uninstall GHC by deleting a couple paths.
14:59:20 <Veinor> parcs: make a .dpkg
14:59:24 <ddarius> The Haskell Platform is also not all that important.
14:59:26 <Veinor> using whatever debian has to do that
14:59:38 <int80_h> they do, but it's not a consumer unix.
14:59:38 <parcs> Veinor: that's using a package manager
14:59:58 <int80_h> ddarius: really?
14:59:58 <monochrom> set aside a directory for ghc. edit PATH. then "uninstall"ing ghc is easy
15:00:25 <ddarius> int80_h: It's just a list of packages.  Many of which you probably won't need.  All of which you can install individually.  It is literally just a list.
15:00:27 <Veinor> parcs: true
15:00:29 <monochrom> besides, you will also be glad you did it when you want several ghc's to hang around
15:01:25 <int80_h> monochrom: I was thinking I would just make a vm for each version of ghc I want.
15:01:39 <monochrom> that's a bit extremist but ok!
15:02:06 <ddarius> There has never been any trouble with having multiple GHCs side-by-side.
15:02:18 <Peaker_> Cale: that's prone to accidental deletion of wrong paths, or not deleting everything.. and it's hard to be sure
15:03:00 <monochrom> ghc doc filenames aren't versioned. new ghc docs overwrites old ghc docs
15:03:05 <Cale> Peaker_: true. The default layout of directories in Linux is insane.
15:03:14 <ddarius> Who uses local documentation?
15:03:25 <Cale> YAY LET"S MASH EVERYTHING TOGHETHERZZ!!!11
15:03:29 <monochrom> more people should use local docs more
15:03:31 <Peaker_> Cale: well, it is optimized for by-type lookup, rather than by-package
15:03:33 <int80_h> Cale: don't even get me started on that. I try to forget I'm using linux as much as I can to avoid raging.
15:03:34 <Cale> COMVENIANT!
15:03:48 <ddarius> monochrom: I can probably generalize both my statement and your statement to: who uses documentation?
15:04:13 <Peaker> Cale: the file system is really a crappy database approximation, so you have to organize folders based on your most important lookups.. I think by-file-type might just be the most important one
15:04:21 <monochrom> I guess the answer is the few of us who answer questions in irc
15:04:21 <ddarius> In case you need to delete all the executables in your system at once.
15:04:22 <joe6> hello, could somebody please help me out with structuring of type classes.
15:04:27 <Cale> I use the local documentation. You can even have cabal auto-update an index of everything you have installed now.
15:04:32 <Peaker> (and then you have a package manager for other indexing of files, to better approximate a database)
15:04:36 <Cale> Which is awesome, except that you can't link people to it.
15:04:49 <Cale> (though I guess I could link it into my webserver)
15:05:03 <Cale> joe6: sure
15:05:04 <Peaker> well, it's nice that you need to search relatively few locations for $PATH
15:05:06 <joe6> I have 3 type classes, shortField, bitField and a CGlobal type class
15:05:06 <int80_h> monochrom: I put the docs under my pillow at night in hopes I get the info via osmosis.
15:05:14 <joe6> Cale, this is the code: http://codepad.org/PYW1aikv
15:05:39 <joe6> both the shortField and the bitField implement the function provided by the CGlobal type-class.
15:05:52 <monochrom> perhaps once upon a time PATH (or any env var) had severe length limits
15:05:53 <joe6> I am not sure of the best way to structure something like that.
15:06:13 <joe6> ideally, I would want an instance of Global when I define the class ShortField.
15:06:19 <ddarius> monochrom: Having to fiddle with the path is annoying regardless of its size.
15:06:21 <Cale> joe6: You just wrote an instance of CGlobal which is going to overlap with everything.
15:06:34 <monochrom> sorry, that cannot be the reason. symlinks would solve it
15:06:41 <Cale> (and hence can be the only instance of CGlobal as long as you want to use the typeclass)
15:06:49 <Peaker> joe6: is CType a type class (as in the class context) or a type constructor (as in the Ptr use)?
15:06:53 <joe6> as all instances of ShortField implement the functions of CGlobal in the same manner.
15:07:05 <Peaker> oh, it's a type index, missed that :)
15:07:08 <Peaker> forget my question :)
15:07:32 <Cale> This looks like only part of the code?
15:07:54 <ddarius> Cale: Where would be the challenge if he provided you with all the information?
15:08:05 <joe6> Cale, CGlobal.hs: http://codepad.org/Q5hUkGEs , ShortField: http://codepad.org/GqU2EiKG
15:08:06 <Cale> heh
15:08:18 <Peaker> monochrom: a short $PATH is good for lookup times,
15:08:24 <Peaker> monochrom: not for length limits
15:08:31 <joe6> Cale, give me a second, I will post the usage too.
15:08:57 <Peaker> monochrom: though symlinks can solve that, yeah, and I think gobolinux uses that approach.. Debian/Ubuntu/Redhat/etc just use an external index mapping packages to files
15:09:34 <joe6> Cale, Bitfield.hs: http://codepad.org/crCMgmTn
15:09:38 <Cale> joe6: Yeah, so far this looks like a less general version of the library which came out of the OpenGL binding.
15:09:54 <Cale> (with some low level details exposed)
15:09:58 <joe6> Cale, you are talking about the Data.StateVar?
15:10:04 <Cale> yeah
15:10:11 <joe6>  i took the function names from that.
15:10:45 <joe6> i have 2 types of data, shortField and bitField, both of which are CGlobal Variables.
15:10:47 <Cale> You could of course, actually use Data.StateVar for this, pretty much.
15:11:08 <Cale> Because it abstracts over how the actual values are read and written.
15:11:39 <Cale> (and so you can do arbitrary bit twiddling to read and write if you want)
15:12:13 <joe6> I cannot use the Data.StateVar, as-is, as I do some manipulation to read/write the bitFields
15:12:23 <Cale> oh?
15:12:52 <joe6> http://codepad.org/xLSO8slE
15:13:02 <Cale> yeah, I see that
15:13:15 <joe6> the instance of a bitfield just defines the cSymbol, offset and startPosition,
15:13:33 <Cale> If you can come up with an interface to your mutable state which looks like  (a -> IO (), IO a), then you can use Data.StateVar
15:13:36 <joe6> and, the get/set functions are derived fromthe above information.
15:14:22 <Cale> You can have functions which construct StateVar values for reading/writing each of the fields in a bit vector, for instance.
15:15:03 <joe6> Cale, I have a lot of bitfields and the functions are getting to be many, hence I encoded it into the typeclass.
15:15:20 <Cale> I'm not sure a typeclass is the right thing for this though.
15:15:24 <joe6> but, the bitfield and the shortfield have different functions
15:15:38 <Peaker> http://eclipsefp.github.com/features.html <-- seems impressive
15:16:22 <Cale> The downside is that you have to run Eclipse ;)
15:16:27 <joe6> Cale, i also want to use the Data.StateVar.get and $= in my usage of the bitField or ShortField. For example, I want to be able to say "Trnif $= True"
15:17:15 <Cale> joe6: If you'll allow Trnif to be trnif instead, then it'll be easy :)
15:17:38 <joe6> i have some values that I need for each bitField/shortField, From those values, I can define the Data.StateVar get/set functions.
15:17:48 <int80_h> Cale: looks like I will have to make a Chan of MVars after all, due to my need of readMVar. So thanks for the tip. You saved me some time.
15:17:59 <Cale> int80_h: cool
15:18:58 <joe6> Cale, then I would have getTrnif and setTrnif instead of what I have now, which is "Trnif $= True" and "v <- get Trnif"
15:19:29 <Cale> joe6: No, you just have one StateVar for each thing
15:19:33 <hpaste> “Michael Orlitzky” pasted “Bad” at http://hpaste.org/50942
15:20:08 <Cale> joe6: which will be defined using makeStateVar applied to the getter and setter (it's just a convenient way of bundling those two together, to solve exactly this problem)
15:20:25 <hpaste> “Michael Orlitzky” pasted “Good” at http://hpaste.org/50943
15:20:50 <mjo> Can someone tell me why "Good" works, but "Bad" doesn't? I think I'm losing my mind.
15:20:55 <Cale> joe6: Of course, you could also just write instances of HasGetter and HasSetter for your datatype
15:21:13 <joe6> Cale, That is the approach I am taking.
15:21:28 <joe6> define HasGetter and HasSetter instances for the datatype.
15:21:40 <Cale> mjo: It's because let bindings are no longer generalised/the monomorphism restriction applies
15:21:43 <shachaf> mjo: Looks like the monomorphism restriction?
15:21:55 <shachaf> @where dmr
15:21:55 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:21:56 <joe6> and, the HasGetter and HasSetter instance definitions is the same for all the ShortField types.
15:21:58 <mjo> Magic, got it.
15:22:07 <Cale> mjo: If you lift the definition of tp to the top level, or give it an explicit polymorphic type signature, then you'll be fine.
15:22:30 <shachaf> Cale: "let bindings are no longer generalised"?
15:22:50 <joe6> Instead of having to define an instance of HasGetter and HasSetter for each datatype. I am wondering if I can define for a class of datatypes?
15:23:03 <Cale> shachaf: yeah, when you define something in a let, and don't give it a type signature, it won't have its type generalised -- it's monomorphic.
15:23:29 <shachaf> @ty let f x = x + 1 in f
15:23:30 <lambdabot> forall a. (Num a) => a -> a
15:23:46 <monochrom> lambdabot is still at ghc 6.12
15:23:46 <joe6> I have the typeClass ShortField. Can I define automatically an instance of HasGetter and HasSetter for any instance of ShortField?
15:23:47 <Cale> shachaf: which is really kinda unfortunate, but it also resolves a lot of weird edge-case problems with how type-system extensions are supposed to interact
15:24:12 <Cale> Yeah, this only applies to newer GHCs.
15:24:22 <Cale> joe6: no
15:24:31 <shachaf> Oh. Newer than 7.0?
15:24:35 <Cale> joe6: Because any such instance would overlap with every other instance.
15:24:53 <Cale> joe6: and would render the typeclass unusable in all the cases which currently apply.
15:24:59 <shachaf> That's kind of a weird thing to add.
15:25:05 <Cale> I believe it's true of 7.0
15:25:13 * shachaf thought the Monomorphism Restriction was bad enough.
15:25:19 <kmc> http://hackage.haskell.org/package/unbound this looks very cool
15:25:21 <Cale> shachaf: It doesn't apply to top-level bindings
15:25:31 <shachaf> λ> :t let f x = x + 1 in f
15:25:31 <shachaf> let f x = x + 1 in f :: Num a => a -> a
15:25:32 <mjo> It doesn't work if I define 'tp' at the top-level.
15:25:34 <shachaf> (7.0.3)
15:25:45 <mjo> Cale: looks like it does?
15:25:52 <joe6> isn't that a lot of boilerplate code to be defining a HasGetter and a HasSetter instance, whereas all the information is being already provided to the ShortField Type-Class?
15:25:55 <shachaf> mjo: Try "tp x = testProperty x"?
15:25:57 <Cale> mjo: Okay, then it's the monomorphism restriction. Try tp x = testProperty x
15:26:16 <Cale> mjo: Or  {-# LANGUAGE NoMonomorphismRestriction #-}
15:26:39 <ddarius> shachaf: The vast majority of time, local functions are used at monomorphic (with respect to their type environment) types.
15:26:41 <mjo> tp x = testProperty x works, but of course I get a warning for not having a type signature
15:26:46 <tgeeky> anyone have a preference for a vim-haskell (or similar thing) on github that's good?
15:26:46 <Cale> joe6: You could make a newtype
15:26:48 <mjo> Maybe I'll just type the whole word =P
15:26:52 <tgeeky> or a corresponding dotfiles that I can take apart
15:27:15 <Cale> newtype SF a = SF a
15:27:22 <shachaf> mjo: You can also use a list of tuples and map (uncurry testProperty) over them!
15:27:35 <Cale> instance (ShortField a) => HasSetter (SF a) where
15:27:36 <Cale>  ...
15:27:39 <ddarius> shachaf: That would certainly fail.
15:27:55 <shachaf> Oh, yes.
15:28:13 <mjo> shachaf: yeah, thanks, that's the plan. I have other ways to solve this particular problem, I just thought GHC was playing a trick on me there.
15:28:16 <shachaf> Er. Never mind.
15:28:54 <Cale> mjo: It was. The monomorphism restriction sucks. It was a mistake of Haskell 98 to include it, and for some stupid reason, it's still not turned off by default.
15:29:05 <Cale> It should be a monomorphism warning instead, really.
15:29:23 <joe6> Cale, that seem smart. i am still trying to understand how that would work.
15:29:41 <mjo> I suppose it has to do some good, though, right?
15:29:48 <ddarius> mjo: Not really.
15:29:56 <joe6> with the newtype, it would ensure that I have one instance of HasSetter for the class ShortField.
15:30:04 <Eduard_Munteanu> As a warning it might be alright
15:30:06 <Cale> mjo: The reason for it is that when you define something that looks like a constant, and it's typeclass polymorphic, it's really implemented as a function, and will thus be re-evaluated (applied to the typeclass dictionary) everywhere you use it.
15:30:19 <ddarius> Cale: It doesn't have to by type class polymorphic.
15:30:43 <Cale> Well, yes, but that's the only case where it's helpful, as far as I can tell.
15:31:10 <ddarius> Polymorphic types can and will be re-evaluated as well.
15:31:23 <mjo> So, as long as I give type signatures for everything it won't do a thing?
15:31:29 <ddarius> mjo: Correct.
15:31:30 <Cale> right
15:31:52 <joe6> Cale, the newtype would include all the types with the ShortField type-class functions, correct?
15:31:57 <mjo> Ok, makes sense. For sufficiently small values...
15:32:35 <Cale> joe6: You're just required to apply the SF data constructor to tell it that you want the instance of HasSetter/HasGetter derived from the existence of a ShortField instance.
15:33:04 <Cale> joe6: It's impossible by design to know that there won't be an instance of ShortField defined in a future module.
15:33:35 <Cale> So typeclass resolution will never rely on the existence or non-existence of typeclass instances when deciding which instance to use.
15:33:47 <Cale> It relies only on the structure of the types.
15:34:07 <Cale> and *then* once it has selected an instance, it ensures all constraints which are necessary for that instance actually hold.
15:34:38 <Cale> So if you write an instance like   instance (C a) => D a where ...
15:34:50 <Cale> when it's choosing an instance, it ignores the C a constraint
15:34:55 <Cale> This looks like  instance D a where ...
15:35:01 <Cale> for that part of the process
15:35:34 <Cale> and this will obviously succeed, but it will overlap with any other instances which are present (and cause compilation to fail)
15:35:51 <Cale> So if you have an instance like this, it has to be the only instance.
15:36:44 <Cale> Makes sense?
15:37:26 <Cale> The reason it can't rely on that C a constraint for excluding the use of the instance is that it can never prove that an instance is not present, because it can't know about all the instances defined in future modules.
15:37:52 <Cale> (typeclasses are fundamentally open)
15:38:10 <joe6> Cale, i am trying to understand what you mentioned and am also trying out the idea.
15:38:28 <joe6> Cale, btw, you have amazing typing speed.
15:38:33 <mm_freak> are do-bindings strict patterns by default?
15:38:42 <mm_freak> i have the impression they are nonstrict
15:39:04 <Cale> mm_freak: they're as strict as case pattern matches
15:39:21 <mm_freak> hmm, ok
15:39:25 <mjo> Oh, REAL cute. The same thing happens with map (uncurry testProperty)
15:39:26 <Cale> mm_freak: if you write  x <- ...  it obviously doesn't have to evaluate the thing to see that it matches x though.
15:39:36 <Cale> mjo: right, because the types don't match
15:39:47 <joe6> Cale, does this make sense? http://codepad.org/LK859IDc , ghci error: http://codepad.org/QY3YsQTh
15:40:19 <mjo> I have seen the NoMonomorphismRestriction light.
15:40:31 <mm_freak> Cale: i'm (still) trying to write ArrowLoop for my signal function type…  it works, but only when i assume that no signal is inhibited
15:40:44 <Cale> joe6: yes
15:40:57 <Cale> joe6: shortField is a type variable and you're using it as a value?
15:41:21 <mm_freak> Cale: is this different for do-rec bindings?
15:41:24 <joe6> ok, let me change it.
15:41:44 <Cale> joe6: perhaps you meant to write  (cSymbol :: shortField) ?
15:41:47 <mm_freak> Cale: when i use mfix explicitly with a strict pattern, it fails, but with a nonstrict pattern it works
15:41:59 <Cale> joe6: I have the feeling that you shouldn't be using typeclasses at all here.
15:42:02 <mm_freak> the nonstrictness is the one thing that bites me, though
15:42:14 <Cale> joe6: there's a lot to be said for good ol' functional programming, you know :)
15:42:29 <Cale> mm_freak: hmm
15:42:57 <Cale> mm_freak: I'm not sure I can actually picture what's going on in your code.
15:43:16 <ddarius> mjo: In map (uncurry testProperty) there is only one instance of testProperty so it must have the same type.  This is just type checking, the monomorphism restriction is irrelevant.
15:43:28 <Cale> mm_freak: You should probably be aware that I had almost nothing to do with the actual implementation of our FRP system as I was working on other parts of the game at that time.
15:43:32 <mm_freak> also in the do-rec variant, when i use the bound pattern (Right x) it works, but when i bind to mx and case-match against that, it gives me a <<loop>>
15:43:45 <Cale> But I can try to understand why your definition loops
15:43:59 <Cale> oh
15:44:16 <mm_freak> Cale: i'd be very grateful, but i doubt that it can be solved anyway
15:44:17 <Cale> case is strict if you match against a pattern (and you don't ~ it)
15:44:23 <mjo> ddarius: Oh, I see why not.
15:44:23 <mm_freak> let me paste it
15:44:26 <mjo> er, now
15:44:54 <Cale> mjo: Not to mention that your list has values of different types in it
15:45:04 <Cale> (which is forbidden)
15:45:16 <kmc> i'm kind of in awe of the number of packages on hackage
15:45:41 <Cale> I was in awe at the number of packages in Hackage quite a while ago :P
15:45:48 <hpaste> “Ertugrul Söylemez” pasted “Unsafe ArrowLoop for FRP with signal inhibition” at http://hpaste.org/50944
15:46:10 <mm_freak> Cale: ignore the redundant 'do'…  it's historical
15:46:14 <benmachine> I, however, am completely impossible to impress
15:46:24 <Cale> When I started programming in Haskell, it was pretty much possible to be familiar with all the libraries in existence.
15:46:38 <Cale> That is no longer true.
15:46:40 <mm_freak> Cale: type Output = Either SomeException
15:47:00 <parcs> kmc: what's the number?
15:47:06 <kmc> a lot
15:47:14 <benmachine> approximately loads
15:47:20 <kmc> buttloads
15:47:55 <joe6> Cale, CGlobal.hs: http://codepad.org/ZjWa8FEV, ShortField.hs: http://codepad.org/Sa7ASilA
15:48:04 <joe6> Cale, this compiles.
15:48:12 <Peaker> mm_freak: screw arrows :)
15:48:35 <mm_freak> Cale: the way i've written the do-rec variant is also historical…  it was a strictness test…  originally it was:  rec (Right (_, d), w) <- …
15:48:44 <mm_freak> Peaker: ?
15:49:08 <Peaker> mm_freak: just expressing my disliking of Arrow and the various classes around it
15:49:39 <mm_freak> Peaker: i like them and they work very well, especially because my signal function type is not a monad…  there is no sensible way to define ArrowApply for it
15:49:47 <Cale> I've actually come to like Arrows a bit more, but I think the Arrow class has too few methods and too many laws.
15:49:53 <Peaker> mm_freak: then use Category+Applicative
15:49:53 <Cale> er, too few laws, rather
15:49:58 <Cale> Too many instances :)
15:49:58 <mm_freak> my problem is that by supporting signal inhibition i effectively locked myself out from having a clean ArrowLoop instance
15:50:07 <Cale> Kleisli should not be an instance of Arrow
15:50:21 <Peaker> Arrow is just a messed up way to re-define Category+Applicative, except it has a few useful laws that Cat+App don't have (but you can easily verify them for your instances)
15:50:34 <Peaker> Cale: why not?
15:50:41 <Cale> and it should be generally true that  (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
15:50:50 <Cale> but that law fails for Kleisli
15:51:02 <benmachine> what does it succeed for other than (->)?
15:51:07 <mm_freak> Peaker: i'm not sure that's true
15:51:14 <Cale> benmachine: lots of FRP arrows with local state
15:51:30 <Peaker> Cale: if you use the Cat+App form, you get the same issue with <*> ordering, though you can probably rotate it around
15:51:30 <benmachine> Cale: would it succeed for *some* kleislis?
15:51:40 <Cale> It would succeed for Reader monads.
15:51:45 <Cale> Only commutative monads
15:51:58 <Peaker> mm_freak: in terms of expressive power, Category+Applicative and Arrow are equivalent (you can implement either in terms of the other). The Arrow laws go a bit beyond the Cat/App laws though
15:52:35 <mm_freak> Cale: anyway, my problem is that i have to silently assume that there is a signal (i.e. the output is a Right), otherwise i seem to be enforcing too much
15:52:47 <joe6> Cale, quick question, How do you make the decision between functions vs type-classes?
15:53:03 <Cale> Also, Arrow should have generalisations of fst, snd, as well as swap :: (a,b) ~> (b,a) and left and right reassociation of pairs
15:53:15 <mm_freak> Peaker: i might switch to Cat+App, as soon as some official GHC version supports syntax sugar for it
15:53:20 <Cale> which would make it look like the definition of a symmetric or braided monoidal category
15:53:25 <benmachine> Cale: with the hope that it would be able to drop arr?
15:53:26 <Peaker> Arrow forces contravariance/covariance on its input types, greatly limiting its usefulness
15:53:32 <Peaker> s/input types/param types
15:53:35 <mm_freak> FRP without the -XArrows syntax is horrible
15:53:36 <Cale> and would also allow for much better translation of the proc/do notation
15:53:39 <mm_freak> s/FRP/AFRP/
15:53:47 <jmcarthur> Peaker: there is an ongoing blog post series out there demonstrating that the commonly cited correspondance between Arrow and Category+Functor isn't as tight as is often claimed
15:53:49 <Cale> benmachine: well, it should use arr only minimally
15:53:57 <copumpkin> Cale: more like cartesian monoidal isn't it? you don't really get any control over the tensor product used
15:53:58 <ddarius> Cale: It's meant to be a premonoidal category specifically because it is intended to capture side-effecting arrows like many Kleisli arrows.
15:53:59 <Peaker> jmcarthur: Category+Applicative, not Functor
15:54:05 <jmcarthur> err yeah
15:54:09 <Peaker> jmcarthur: the non-correspondence is just the extra laws
15:54:23 <Peaker> jmcarthur: because Category and Applicative don't have laws binding them together like Arrows do
15:54:32 <jmcarthur> right
15:54:38 <Peaker> mm_freak: Applicative doesn't need much syntax, unlike Arrows
15:54:43 <jmcarthur> but still, it means you can't necessarily make an Arrow from Category+Applicative
15:54:46 <Peaker> <$> and <*> are not so bad
15:54:47 <copumpkin> (| f x y |)
15:54:57 <Cale> copumpkin: well, you get to choose the projections, braiding, and associators.
15:55:21 <jmcarthur> at least not Arrow as is commonly defined
15:55:42 <Cale> ddarius: Right, and I don't think it should be trying to do that.
15:55:50 <Cale> It's bad notation for side-effecting things.
15:55:51 <mm_freak> Peaker: as soon as you have more complicated data dependencies you will miss proc/do
15:55:51 <Peaker> jmcarthur: sure, but practically, the space for potential Applicative/Category behaviors is small enough that it is unlikely that *the* useful Arrow is not the same Cat/App just by there being no other option
15:56:01 <mm_freak> Peaker: because there is still Category
15:56:14 <Cale> But it's pretty good notation for things which only have local state.
15:56:15 <Tinned_Tuna> heya, anyone know if GHC can perform cross compilation?
15:56:22 <Peaker> mm_freak: I like points-free style, so proc do never appealed to me
15:56:26 <jmcarthur> Peaker: i agree. i'd also add to that that Arrow would probably be more useful with fewer requirements
15:56:28 <Cale> and can give you a lot of control over sharing
15:56:44 <Tinned_Tuna> since my dev. box is 64-bit, but I'd like to build a 32-bit executable
15:56:47 <Cale> which is really why everyone writing EDSLs wants Arrow in the first place
15:56:55 <Cale> (when they want it)
15:57:00 <ddarius> Tinned_Tuna: No, it can't.
15:57:02 <Peaker> jmcarthur: Yes, "arr" forces covariance/contravariance on the type params which ruins the generality
15:57:05 <JoeyA> Does Haddock's markup syntax support URLs with a label rather than a raw link?
15:57:11 <Tinned_Tuna> ddarius: damn :-(
15:57:21 <JoeyA> e.g. <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a>
15:57:38 <Peaker> jmcarthur: and once you get rid of it, you need more combinators to make up for its loss
15:57:43 <Cale> The diagrams that everyone draws assume that >>> and *** abide, unless you add lots of cumbersome boxes to them to say precisely how they're built up.
15:57:46 <gienah> Tinned_Tuna: if the dev box is linux, then you could build a 32 bit ghc in a chroot
15:58:07 <Cale> or you pay careful attention to the way in which they're drawn (natural topological moves change semantics)
15:58:11 <mm_freak> Peaker: have you used AFRP at some point?
15:58:18 <Peaker> jmcarthur: and the use of tuples for pairs is pretty bad too -- restricting more usefulness
15:58:40 <Peaker> mm_freak: not much, but a friend of mine wrote a whole AFRP framework which we discussed a lot.. and it uses Category+Applicative
15:58:41 <Cale> which is really bad, it's like if the manner in which you draw your circuit traces was allowed to affect the behaviour of the components in your circuit
15:58:42 <mm_freak> Peaker: i generally prefer the combinators for the usual arrows, but for AFRP i really prefer proc/do
15:58:54 <Cale> (to give an analogy with EE)
15:59:04 <Peaker> mm_freak: the "peakachu" package is his AFRP framework, and "defendtheking" is an interesting game baseed on that
15:59:06 <ddarius> Cale: Which, when realized, is true.
15:59:08 <mm_freak> Peaker: if you still prefer Category+Applicative, my library provides both interfaces =)
15:59:17 <Cale> Yeah, but you try to avoid it!
15:59:46 <ddarius> Cale: Not usually.
15:59:49 <Peaker> mm_freak: It's not really AFRP because the Arrow class sucks :-)  It's similar though.. when you do "vertical composition" with arrows you get products (pairs). With his library, vertical composition yields sums (Eithers)
16:00:02 <Peaker> mm_freak: so if you combine event sources, you get an event source of *either* event, not of *both* events
16:00:17 <Cale> The whole point of the circuit abstraction is to avoid having to apply Maxwell's laws directly every time you want to understand the behaviour of a circuit, and to be able to build up abstractions recursively.
16:00:17 <Peaker> I guess AFRP forces you to use Signal sources rather than event sources
16:00:25 <Peaker> mm_freak: how do you represent an event source?
16:00:34 <mm_freak> Peaker: i don't…  events are nothing special
16:00:37 <mm_freak> type Event = Maybe
16:00:53 <Cale> Not satisfying a naturality law like the one I gave means that otherwise natural topological moves on the circuit diagrams have an impact on their semantics.
16:01:01 <mm_freak> Peaker: http://hackage.haskell.org/package/netwire
16:01:02 <Peaker> mm_freak: Yes, I don't find that very elegant, you get a product of Maybes, instead of a sum
16:01:06 <Cale> which is really bad for being able to understand the meaning of an arrow sanely.
16:01:24 <Peaker> mm_freak: When composing input event streams, it's nice to get a sum type of all events, rather than a product of all of their maybes
16:01:28 <ddarius> Cale: Yes, but in practice, routing is extremely important.  I agree, though, that such changes are not built into the behavioral semantics.
16:01:41 <Cale> It basically means that arrows can't be treated as black boxes.
16:01:44 <mm_freak> Peaker: what happens when two event sources fire?
16:03:01 <Cale> You can have an arrow diagram in which some outputs are totally disconnected from some inputs, and yet their computation from the inputs they do depend on can't be separated into another definition.
16:03:01 <Peaker> mm_freak: IIRC, you have a list of events at every "iteration"
16:03:30 <mm_freak> Peaker: i see…  i have combinators for all kinds of event combination
16:03:30 <Cale> Because they secretly rely on side-channel connections which are hidden.
16:03:36 <Cale> That sucks for modularity.
16:03:37 <Peaker> mm_freak: http://hackage.haskell.org/packages/archive/peakachu/0.3.0/doc/html/FRP-Peakachu-Program.html
16:03:58 <mm_freak> Peaker: prefer-left/return both as a list/queue them and return one after another/…
16:04:04 <Cale> and it sucks for anyone trying to do anything smart with interpreting the arrow
16:04:17 <Cale> (you can't parallelise at a *** anymore)
16:05:37 <mm_freak> Peaker: so you always have potentially multiple results?
16:06:34 <jmcarthur> in the classic FRP implementation i'm working on, events at a particular time are modeled on Bag instead of Maybes, so i always potentially have multiple results
16:08:02 <mm_freak> i had the idea to remove events altogether and represent events solely by signal inhibition
16:08:23 <mm_freak> i already have Alternative, ArrowZero and ArrowPlus instances
16:12:24 <benmachine> > do Nothing
16:12:25 <lambdabot>   Nothing
16:13:37 <jmcarthur> inhibition it certainly an interesting way to approach events in AFRP
16:13:40 <jmcarthur> *is
16:17:31 <mm_freak> do/rec notation and mfix are equally powerful, right?
16:17:37 <joe6> in haskell can I have a function with a return type that is dependent on the input types?
16:17:53 <mm_freak> joe6: yes, one way to do it is with type families
16:18:04 <mm_freak> associated types to be exact
16:18:10 <joe6> mm_freak, thanks.
16:18:11 <JoeyA> Isn't that just polymorphism?
16:18:18 <JoeyA> Or am I missing something?
16:18:33 <joe6> isn't polymorphism, having the same type for both input and output
16:18:41 <mm_freak> JoeyA: i guess he wants to have different result types depending on the argument type
16:18:43 <joe6> something like f :: a -> a
16:18:51 <joe6> but, if i have f :: a -> b
16:18:56 <rwbarton> a combination of polymorphism and possibly associated types depending on the desired kind of dependency
16:19:07 <mm_freak> like if applied to an Int, it should yield Float, but when applied to a String it should yield String
16:19:20 <JoeyA> ah, okay
16:19:24 <joe6> yes, just as mm_freak explains it.
16:20:55 <JoeyA> wjlroe: I'm still working on that Aeson decode patch.  Note that I made a mistake in the code I gave earlier.
16:21:00 <JoeyA> The last line should read Success a -> Right a
16:21:19 <JoeyA> The compiler accepted Success a -> a because FromJSON has an Either instance.
16:21:33 <benmachine> woo, excessive polymorphism
16:24:06 <copumpkin> no such thing as too much polymorphism!
16:24:12 <copumpkin> as far as I'm concerned
16:24:23 <JoeyA> > unsafeCoerce "Hello, world!"
16:24:24 <lambdabot>   Not in scope: `unsafeCoerce'
16:24:32 <copumpkin> I think premature generalization is the source of good code
16:25:08 <JoeyA> I don't have enough experience in Haskell to lean one way or the other.
16:25:38 <JoeyA> But in other languages, piling on patterns can hinder simplicity.
16:26:33 <JoeyA> Of course, there are cases where generalizing is an obvious and helpful course of action.
16:26:39 <benmachine> I've not yet come up with a good policy that is obviously correct in all cases
16:26:44 <JoeyA> lengthOfIntList :: [Int] -> Int
16:27:12 <benmachine> JoeyA: the thing is, length :: [a] -> Int is actually a much *smaller* type than lengthOfIntList
16:27:13 <mm_freak> i go with as much polymorphism as reasonable
16:27:22 <parcs> in general i'm a big fan of polymorphism
16:27:28 <benmachine> so more polymorphic is in that case more precise
16:27:28 <mm_freak> low level for speed, high level for composability
16:27:50 <JoeyA> Here, just saying length :: [a] -> Int not only makes the function more general, but it documents better what it does, and confines what it can do with the elements.
16:27:59 <benmachine> but one thing that *really* annoys me is the whole thing where people use Monad m => m a, return, and fail, instead of Maybe a
16:28:19 <JoeyA> Hmm, I haven't run into that yet.
16:28:20 <benmachine> Maybe a is a less polymorphic but much more useful type
16:28:20 <hpc> benmachine: or Either String
16:28:20 <jmcarthur> length :: [a] -> Natural   would be even better
16:28:26 <benmachine> hpc: sure
16:28:40 <JoeyA> I have run into ST array's overgeneralization.
16:28:46 <shachaf> benmachine: It annoys you because they should be using mzero, right?
16:28:50 <mm_freak> i tend to go with Either SomeException instead of Maybe
16:28:57 <JoeyA> Combined with rank 2 polymorphism, it's rather unaccessible.
16:28:58 <benmachine> shachaf: ri- no >:|
16:29:15 <mm_freak> the only issue with Either SomeException is that it's not an Alternative
16:29:38 <benmachine> mm_freak: well, when necessary, sure, but I've seen it used where the argument to fail was literally always the same string
16:29:41 <JoeyA> As I wrote here: http://codegolf.stackexchange.com/questions/1764/what-is-a-good-way-to-deal-with-tasks-that-requires-arrays-using-haskell/1768#1768
16:29:44 <hpc> benmachine: my website transforms over Either String so i can fail without worrying about wonky behavior
16:30:00 <JoeyA> "Data.Array.ST provides a mutable array type. However, the type situation is a mess: it uses a class MArray to overload every single one of its methods except for runSTArray. So, unless you plan on returning an immutable array from a mutable array action, you'll have to add one or more type signatures"
16:30:22 <mm_freak> benmachine: i guess that's a common beginner mistake
16:30:44 <kmc> ST array typing woes were the thing that inspired me to start a Haskell blog in the first place
16:31:22 <JoeyA> kmc: What is your blog?
16:31:24 <mm_freak> JoeyA: i don't think that's a big problem
16:31:49 <JoeyA> mm_freak: It is when you want to use mutable arrays ;-)
16:31:54 <jmcarthur> even the standard libraries used to have some of that fail crap. iirc, Data.Map used to have some functions (lookup, i think?) return things of type Monad m => m a so that it could use fail when the key is not in the map
16:32:02 <kmc> JoeyA, http://mainisusuallyafunction.blogspot.com/
16:32:06 <mm_freak> JoeyA: remember that Data.Array* is h98
16:32:36 <mm_freak> having runST*Array in the class would probably require some extensions for any sensible definition
16:32:45 <copumpkin> mm_freak: not really
16:32:49 <copumpkin> they use multiparameter typeclasses
16:32:57 <mm_freak> copumpkin: true
16:33:33 <benmachine> oh, and my other favourite anti-polymorphism argument is
16:33:50 <benmachine> :t forever putStrLn "this is wrong but typechecks fine"
16:33:51 <lambdabot> forall b. b
16:34:09 <copumpkin> that isn't an antipolymorphism argument
16:34:16 <copumpkin> it's polymorphism in the wrong place :)
16:34:22 <joe6> is there something like type-class heirarchy in haskell?
16:34:23 <mm_freak> anyway, i don't think that it's (easily) possible to have runArray inside of MArray
16:34:35 <benmachine> copumpkin: it's an argument to disprove "more polymorphism = more better"
16:34:38 <jmcarthur> it's an antipartiality argument i guess
16:34:45 <joe6> source: http://codepad.org/1cDfGTcU
16:34:51 <kmc> joe6, yeah, sometimes writing an instance for one class requires an instance for another
16:34:57 <jmcarthur> err
16:35:00 <kmc> e.g. Num requires Eq and Show, which is kind of dumb
16:35:01 <joe6> error: http://codepad.org/83qvJi0G
16:35:02 <jmcarthur> :t forever putStrLn
16:35:02 <lambdabot> forall b. String -> b
16:35:23 <kmc> or Applicative requires Functor
16:35:27 <ddarius> @faq Can Haskell cause you to prematurely generalize?
16:35:27 <lambdabot> The answer is: Yes! Haskell can do that.
16:35:28 <copumpkin> benmachine: my point was more that making functions "tastefully polymorphic" can be an excellent design tool to help yourself write good code. Returning Monad m => m a is a bad idea
16:35:35 <joe6> i was expecting that defining Rstif as a flag would automatically derive the underlying gettable
16:35:54 <mm_freak> runArray :: ArrayMonad a (a i e) -> ImmutableMonad a (Immutable a i e)
16:35:56 <benmachine> copumpkin: you probably agree with me, then :) the tricky part is having good taste, I think
16:35:59 <mm_freak> very ugly
16:36:20 <JoeyA> Why is using Monad for partial functions bad?
16:36:44 <mm_freak> JoeyA: it's not, but in commonly you can use the applicative interface, which is much nicer
16:36:54 <joe6> i have a situation where I want it to derive an instance of a different class, when I write an instance to one class.
16:36:56 <mm_freak> > liftA2 (+) sin cos pi
16:36:57 <lambdabot>   -0.9999999999999999
16:36:57 <hpc> JoeyA: not all monads accomodate partial functions
16:36:58 <joe6> is that possible?
16:37:01 <copumpkin> JoeyA: because fail doesn't belong in the Monad class
16:37:04 <benmachine> JoeyA: in this particular case, it's bad because it helps you to ignore errors by type-checking in places and ways that it shouldn't
16:37:05 <hpc> JoeyA: take the identity monad
16:37:12 <mauke> :t fix forever
16:37:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
16:37:32 <mm_freak> oh, for partial functions, not for partial application
16:37:32 <benmachine> like copumpkin says, the problem is fail: every Monad has a fail method even though not every Monad has a notion of failure
16:38:07 <mauke> :t [fix forever, error]
16:38:08 <lambdabot> forall a. [[Char] -> a]
16:39:07 <mauke> error = fix forever
16:40:07 <joe6> :t get (undefined::F Rstif) = get (undefined::F Rstif) :: IO (ReturnType (F Rstif))
16:40:08 <lambdabot> parse error on input `='
16:40:27 <joe6> i am wondering if there is a way to define this, without the need for the type constructor F
16:40:33 <joe6> for the newtype F a = F a
16:40:47 <joe6> source : http://codepad.org/Sm3glEFq
16:47:42 <johnfn> I know in clojure there is a function called update-in that reaches into a structure (array, 2d array, nested hash, whatever) and changes a value, returning the new object. is there something similar in haskell, or is looking for it indicative that i should approach the problem from a different angle?
16:47:59 <kmc> johnfn, http://hackage.haskell.org/package/fclabels
16:48:02 <Cale> johnfn: That sounds like a lens
16:48:02 <jmcarthur> joe6: not really. you need to the newtype so that the instance doesn't overlap everything else
16:48:11 <kmc> there's an example in the Data.Label module docs
16:48:12 <jmcarthur> *need the newtype
16:48:24 <kmc> there's a bunch of other packages for lenses too
16:48:30 <Cale> johnfn: There are a number of packages implementing lenses, fclabels which kmc linked is good.
16:48:49 <KirinDave> Man, cabal's reasoning for being mad about versions can be baffling.
16:49:10 <KirinDave> Like, it says this is a missing dep for cabal dev: mtl >=1.1 && <2.1,
16:49:13 <joe6> jmcarthur: thanks. I think I get it now. Cale was trying to explain this earlier,
16:49:18 <KirinDave> But if I cabal list, mtl 2.0.* is installed
16:49:22 <joe6> and I could not understand some of it.
16:49:31 <joe6> Cale, jmcarthur, thanks.
16:49:43 <joe6> jmcarthur: would this situation arise in agda?
16:50:19 <joe6> can I define a top level module/class and use that to derive some other underlying modules/classes.
16:50:27 <johnfn> interesting. thanks
16:50:27 <joe6> in agda, I mean..
16:50:36 <jmcarthur> since Agda lacks type classes, i doubt this would arise
16:51:08 <joe6> jmcarthur: i think agda has the module (equivalent of type classes?)
16:51:18 <jmcarthur> if you pretend modules are like classes, then agda forces you to be explicit about which one you are using in a particular scope. the compiler doesn't have to infer it automatically
16:51:50 <jmcarthur> modules and type classes have some overlap, but aren't really equivalent
16:52:05 <joe6> jmcarthur: oh, ok. thanks. so, it would be a lot more syntax in agda..
16:53:10 <jmcarthur> well, in haskell you have to explicitly specify the newtype wrapper in order to be able to choose the instance. in agda you have to explicitly specify the module. it's kind of the same situation in both cases
16:53:27 <jmcarthur> sometimes one will win and sometimes the other will win
16:53:37 <jmcarthur> usually, IMO, type classes end up with less ugly code
16:54:04 <joe6> jmcarthur: if you were to redefine this code, would you recommend any other haskell functionality that would make it easier.
16:54:23 <joe6> I could use TH and derive an instance of Gettable for every Flags instance.
16:54:41 <jmcarthur> i wouldn't do that
16:54:46 <joe6> but, other than that, is there some smart haskell way of restructuring this code, to make it simpler
16:55:32 <joe6> where there is one typeclass which is a superclass of another typeclass.
16:55:47 <jmcarthur> well i don't fully understand what you're doing in this code
16:55:50 <joe6> and the sub-typeclass can be defined by the contents of the super-typeclass.
16:56:11 <jmcarthur> the high level picture, that is
16:56:42 <Eduard_Munteanu> joe6: Agda has something like typeclasses.
16:56:47 <Eduard_Munteanu> A rather recent addition.
16:56:57 <jmcarthur> ah yeah, but i don't know how that works yet
16:56:59 <Eduard_Munteanu> They go by the name of non-canonical implicits.
16:57:55 <joe6> jmcarthur, i have 2 typeclasses, one of them is a simple set/get and another more complicated one with a bunch of attributes. The simple class' instance can be defined by the attributes of the more complex class.
16:58:07 <Eduard_Munteanu> They're just records, and Agda will pick it up from the scope (as long as there's a single matching definition).
16:58:23 <joe6> jmcarthur, the easiest way is to define the simpler class instance whenever I define the complex class instance.
16:58:52 <jmcarthur> joe6: i would have the complex class require the simple one
16:58:55 <joe6> jmcarthur: i am trying to avoid the duplicity, by trying to see if the complex class can somehow define the simpler class instance.
16:58:59 <copumpkin> preflex: seen increpare
16:58:59 <preflex>  increpare was last seen on #haskell 12 days, 15 hours, 38 minutes and 23 seconds ago, saying: dynamic/static
16:59:08 <copumpkin> @ask increpare did you make untris?
16:59:09 <lambdabot> Consider it noted.
16:59:15 <jmcarthur> joe6: not in haskell as it stands, no, but there are various proposals that might make it possible
16:59:19 <Eduard_Munteanu> http://code.haskell.org/Agda/doc/release-notes/2-2-12.txt   -- "Instance arguments" section
16:59:23 <Cale> joe6: You're still going to have to write instance declarations
16:59:23 <joe6> Eduard_Munteanu: thanks a lot for that. I will check out the non-canonical implicits.
16:59:37 <jmcarthur> joe6: this is somewhat like our situation with Functor, Applicative, and Monad
17:00:13 <joe6> yes, i guess, the Monad instance can define the Functor instanc and Applicative instance, with its' attributes.
17:00:29 <copumpkin> not in agda
17:00:43 <copumpkin> agda's instance resolution is weaker than haskell's
17:01:15 <KirinDave> I seem to have two versions of pretty installed, both with the same version. This is not good.
17:01:24 <Eduard_Munteanu> copumpkin: I'm also unsure how MPTCs work out
17:01:24 <jmcarthur> oh i didn't even know 2.2.12 is out
17:01:27 <joe6> ok, thanks a lot, guys, I think my only solution is to have an instance for each type and type-class.
17:01:33 <Eduard_Munteanu> jmcarthur: I don't think it is.
17:01:34 <copumpkin> Eduard_Munteanu: how so?
17:01:37 <jmcarthur> oh
17:01:37 <Cale> joe6: Pretty much, yeah.
17:01:44 <jmcarthur> i just see "release notes" and assumed
17:01:45 <copumpkin> jmcarthur: most people just build agda HEAD :)
17:01:53 <joe6> Cale, thanks and sorry for the bother.
17:01:59 <Eduard_Munteanu> copumpkin: I mean, can you define something like MPTCs using non-canonical implicits?
17:02:00 <Cale> joe6: Though, you might not need that extra class...
17:02:07 <jmcarthur> i don't use agda quite often enough to justify the effort to build it from HEAD
17:02:19 <Cale> joe6: I still have a feeling you might get by with just StateVar :)
17:02:24 <Cale> I might be wrong though.
17:02:27 <Eduard_Munteanu> Some features are worth the trouble.
17:03:02 <copumpkin> Eduard_Munteanu: I'd imagine so, but haven't tried. One way to find out :)
17:03:04 * copumpkin tries
17:03:36 <Cale> joe6: It's possible to define a StateVar-constructing function for accessing bit fields in any Storable.
17:03:55 <jmcarthur> seems like it should work
17:04:07 <joe6> Cale, yes, that i possible.
17:04:42 <Cale> Or even...
17:04:51 <joe6> s/i/is/
17:05:05 <Cale> bit :: (Bits a) => StateVar a -> StateVar Bool
17:05:14 <Eduard_Munteanu> I should try that too.
17:05:18 <Cale> errr
17:05:23 <Cale> bit :: (Bits a) => Int -> StateVar a -> StateVar Bool
17:06:39 <nh2> I am confused by seq. a `seq` a is said to be simply a (damn Maybe, you cannot say things like "said to be just a" without getting the feeling of saying something wrong) without any further effect. How then can the seq in foldl' have an effect? Why doesn't it just return a thunk (f acc next), how can it "evaluate" the function? I've seen examples like foldl' on (+) where the ((+) acc next) "magically" were reduced to a single Int. Other reso
17:07:31 <copumpkin> Eduard_Munteanu: works fine
17:07:33 <Cale> nh2: Your message was cut off at "Other res"
17:07:42 <Eduard_Munteanu> Oh, nice.
17:07:44 <hpaste> copumpkin pasted “implicits” at http://hpaste.org/50945
17:08:33 <Cale> nh2: We can have a look at it. x `seq` y ensures that x is evaluated before the result of evaluating y is made available for something pattern matching on this expression.
17:08:33 <nh2> ... Other resources claim that seq "reduces until it is clear that its argument is not bottom"/"reduces until the first constructor". If that is true, wouldn't that also mean that a `seq` a would reduce a which wouldn't happen in a simple "a", e.g. if a is (1+2)?
17:08:35 <Eduard_Munteanu> copumpkin: I see, thanks. Any thoughts on fundeps, though?
17:09:00 <Jafet> The first "constructor" of (1+2) is 3.
17:09:07 <Eduard_Munteanu> Or does the resolution algorithm make that a non-issue?
17:09:33 <Cale> nh2: In any context where a is being evaluated, if you were to replace it with a `seq` a, you're going to evaluate a before the result of evaluating a is made available, but hey, you were going to evaluate a anyway.
17:09:35 <copumpkin> Eduard_Munteanu: they don't really support fancy instance resolution mechanisms like that, but most cases you'd use fundeps for you can probably write anyway
17:09:37 <kmc> in GHC the first constructor of (1+2)::Int is I#
17:09:54 <kmc> however you can't distinguish (I# ⊥) from ⊥
17:09:54 <Cale> nh2: So this is pointless.
17:09:59 <Cale> nh2: Make sense?
17:10:06 <Eduard_Munteanu> Ah, I see.
17:10:51 <joe6> copumpkin: quick question, do we need "fancy instance resolution mechanisms" in agda?
17:11:19 <joe6> isn't everything much more explicit?
17:11:39 <copumpkin> we don't want them, no
17:11:45 <Cale> foldl' f z [] = z; foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
17:12:11 <Cale> This ensures that y is evaluated before the result of evaluating foldl' f y xs is made available.
17:12:24 <Cale> (to pattern matching)
17:12:52 <johnfn> im getting an error message "undefined reference to `__stginit_containerszm0zi3zi0zi0_DataziMap_'" when i type "import qualified Data.Map as Map". what could that mean?
17:12:53 <nh2> Cale: but if I just returned "a" instead of "seq a a", and a were (+) 1 2, wouldn't I return a ((+) 1 2) thunk whereas in some seq usage, I would return a "real" (1+2)=>3 ?
17:13:03 <Cale> no
17:13:16 <Cale> You'd be returning ((+) 1 2) `seq` ((+) 1 2)
17:13:27 <Cale> which if it was never evaluated, would still never be evaluated
17:13:55 <Cale> Only, it would take up a little more memory.
17:14:02 <Cale> (one cell more)
17:14:43 <benmachine> the key point about foldl' is that the accumulator is evaluated before the recursive call to foldl'
17:14:52 <Cale> Not necessarily before
17:14:59 <Cale> It's very very subtle :)
17:15:12 <benmachine> ok but the point is that one of the arguments to seq is a foldl
17:15:15 <nh2> then I don't get how this example superFastSum from http://www.haskell.org/pipermail/beginners/2010-February/003396.html works (this is an accumulator example):
17:15:30 <nh2> superFastSum s []     = s   ;      superFastSum s (x:xs) = s `seq` superFastSum (s+x) xs
17:15:31 <Cale> When evaluating x `seq` y, it is valid to evaluate y first, then x, and then return the result of evaluating y
17:16:08 <Cale> So, let's try it
17:16:18 <nh2> there we've got (they claim):            superFastSum (0+1) [2,3]     =>    (0+1) `seq` superFastSum ((0+1)+2) [3]       =>         superFastSum (1+2) [3]
17:16:26 <Cale> I'm going to just call it sum, because it's too long a name :P
17:16:50 <nh2> in that, I don't get how the (+) 0 1 magically turns into 1
17:16:56 <Cale> well, okay, they're choosing to evaluate x first in x `seq` y
17:17:01 <Cale> but it's really not necessary
17:17:01 <benmachine> nh2: I think the explanation they gave is confusing
17:17:21 <Cale> y `seq` (x `seq` y) is equivalent to x `seq` y
17:17:45 <Cale> But people often ignore this fact.
17:18:02 <Cale> (the compiler is technically allowed to rearrange them, and it sometimes does, though)
17:18:40 <benmachine> nh2: you can think of it as more like let s = 0+1 in s `seq` superFastSum (s+2) [3]
17:18:40 <Cale> All that is ensured is that x is evaluated before the result of evaluating y can be pattern matched on. Everything is only evaluated for the purposes of pattern matching.
17:18:52 <benmachine> nh2: then it's clear that the next thing to evaluate is s, so it gets evaluated in both places
17:19:04 <benmachine> (where I say next I use the term loosely, k)
17:20:16 <Cale> Yeah, okay, it might be really confusing because of sharing.
17:20:25 <Tinned_Tuna> Well, that was a crash course in Cabal packaging. good lord, that's a good packaging/build system
17:20:26 <Cale> Any parameter to a function is evaluated at most once.
17:20:39 <Tinned_Tuna> Who ever made it should be paid vast sums of money.
17:20:39 <Cale> ^^ this is really important
17:21:08 * Eduard_Munteanu might rather have good ol' autotools
17:21:14 <Cale> Eduard_Munteanu: lolololol
17:21:23 <benmachine> Tinned_Tuna: cabal is far from perfect but it's not bad considering how crazy the dependency mess called Hackage is :)
17:22:15 <Tinned_Tuna> ...
17:22:22 <Tinned_Tuna> You've clearly never used Maven.
17:22:54 <benmachine> this is true
17:23:45 <Tinned_Tuna> Maven is like... being punched in the face every time you blink. Comparatively, cabal is a massage with a happy ending.
17:23:58 <benmachine> haha fair enough
17:24:18 <Cale> autotools is so ridiculously bad, it would take a lot of effort to come up with a joke build system which was worse
17:24:33 <benmachine> Cale: that sounds like a challenge :o
17:24:48 <benmachine> but yes autotools has always given me headaches
17:24:48 <Tinned_Tuna> if you dodge *just right* you can do amazing things with Maven. More often than not, you're going to end up losing some teeth.
17:24:51 <Eduard_Munteanu> Yeah, but it's got a few really nice features. I wish Cabal had parallel building and such stuff.
17:25:44 <Tinned_Tuna> Anyways, while that's having business time, I'm off to sleep.
17:25:47 <Eduard_Munteanu> Also, cross-compiling is rather nice.
17:25:47 <Tinned_Tuna> ciao.
17:25:49 <benmachine> (is it me or should configure scripts take about a hundredth of the time they do to finish, given what they do)
17:25:59 <benmachine> sleep well
17:26:00 <Eduard_Munteanu> Tinned_Tuna: g'night
17:26:33 <Cale> nh2: Still here?
17:26:40 <Eduard_Munteanu> benmachine: yeah, in many cases you probably don't need all those checks.
17:26:52 <Eduard_Munteanu> They could also run in parallel.
17:27:01 <Cale> nh2: If you want, I can draw you some graphs which show how the thing is really evaluated.
17:27:19 <Cale> Or use let/in to represent the sharing. Are you familiar with how lazy evaluation works?
17:27:50 <KirinDave> Man, this has been an enlightening afternoon.
17:27:51 <Jafet> benmachine: a configure script goes through every unix header file on your system to convince itself that you aren't using the DJGPP compiler on AIX
17:28:09 <KirinDave> Everyone should update a few dozen packages for a ghc bump. It's a hell of a learning experience.
17:28:38 <benmachine> Jafet: even if it insists on doing that, I'm sure that should take all of half a second
17:29:27 <rwbarton> he didn't say once
17:29:32 <Jafet> Pre-caché all your unix header files then
17:29:38 <Jafet> Heh
17:31:07 <Eduard_Munteanu> kbuild is also nice in terms of features.
17:32:30 <nh2> Cale, benmachine: thanks for your help, I think I'm slowly getting closer to grokking it. It's 3am at my place though, so I'll continue tomorrow. Can you point me to the wiki pages / whatever sites you think are best explaining seq and evaluation? I read a lot of them, but many don't really help.
17:32:50 <Eduard_Munteanu> Really, I wonder if Cabal + some other build system isn't actually a better choice, at least for bigger packages.
17:33:06 <Eduard_Munteanu> For instance, Agda could use some parallelism in building it.
17:33:58 <Eduard_Munteanu> Let your favorite stuff handle building, and Cabal dependencies.
17:36:38 <Peaker> Jafet: DJGPP -- wasn't that an executable loader for DOS ("dos extender")?
17:36:57 <copumpkin> it was a compiler
17:37:09 <copumpkin> still is I think
17:37:25 <ddarius> It was a port of GCC to 16-bit DOS with an extender.
17:37:45 <Jafet> Oh, then it probably wouldn't work on AIX
17:38:01 <Jafet> It wouldn't be the first thing to not work on AIX though
17:38:28 <ddarius> Expecting it to work on AIX would be insanity.
17:47:36 <Cale> Peaker: it was a DOS port of g++
17:50:13 <ddarius> kmc: Blech, HOAS.
17:50:26 <vrthra> hello, I have a tree with two type parameters (as pasted). The first parameter is the metadata which is avaliable in all the nodes, and the second one is the content which is available on only leaves. I want to be able to make a monadic instance out of it (like other trees with data in all nodes or data only in leaves). Is it possible? Or should I look for some thing like transformers or arrows?
17:50:28 <hpaste> Vrthra pasted “Monads?” at http://hpaste.org/50946
17:50:52 <Cale> vrthra: should be easy
17:50:57 <Cale> vrthra: wait...
17:51:15 <Cale> well, it'd be easier if the _meta didn't occur in the leaves
17:51:27 <vrthra> I am trying to model a file system
17:51:46 <vrthra> and other things like that ..
17:52:30 <vrthra> meta data for both dirs and files, but content only on files
17:53:40 <vrthra> for implementing 'return' I have to make one of the data empty
17:53:46 <ddarius> Disregarding the types, return doesn't seem like it would make sense in this context.
17:53:55 <Cale> vrthra: I'm not sure a monad instance really makes sense... If your metadata is an instance of Monoid though, you can do it.
17:53:59 <ddarius> In fact, making this a monad doesn't make a lot of sense.
17:54:25 <ddarius> It's not common to want to substitute directory trees for every file in a file system.
17:54:34 <Cale> The monadic join will replace files containing directory trees with those trees.
17:54:49 <Cale> (where every file would contain such a tree)
17:55:00 <Cale> which is odd, but maybe you want it anyway
17:55:20 <vrthra> I did not understand completely
17:55:37 <vrthra> I can see how to make a monad out of either meta or just content trees
17:55:49 <vrthra> and I can see a kind of Bimonad perhaps
17:56:09 <vrthra> if I can get a function to wrap meta and content for return
17:58:42 <vrthra> What I would like to do is to pretend that the tree contains only metadata if that is possible, so that I can run queries against it.
17:59:17 <vrthra> or the other way round, pretend that it contains only data in the leaves, but leave the metadata intact
18:02:42 <vrthra> I was reading up on monad transformers, and was wondering if I can use that for doing this.
18:03:10 <jmcarthur> seems like a stretch to me
18:04:27 <vrthra> @jmcarthur monads? or transformers?
18:04:27 <lambdabot> Unknown command, try @list
18:04:37 <vrthra> jmcarthur: monads? or transformers?
18:05:12 <jmcarthur> i don't really see how transformers applies to this
18:05:35 <jmcarthur> monads maybe... but the monad this forms might not be very meaningful, as was explained above
18:05:57 <vrthra> If I can split the D.S, (not sure how to yet), with one D.S keepign the metadata, and the other keeping the content
18:06:04 <jmcarthur> this doesn't even have the right kind to be a transformer
18:06:36 <vrthra> then I can do manipulations on two levels (perhaps?).
18:06:53 <jmcarthur> all a monad transformer does is take one monad and give you another
18:08:27 <hpaste> Cale pasted “Tree monad” at http://hpaste.org/50947
18:08:57 <jmcarthur> ah i was thinking about doing that
18:09:29 <jmcarthur> you didn't eta reduce. that's an error! ;)
18:09:33 <vrthra> cale: it uses mempty, but that is not what I would like to do
18:09:41 <jmcarthur> hlint is a sensationalist program
18:09:57 <ddarius> hlint didn't complain about the superfluous parentheses.
18:10:00 <vrthra> it creates a file without metadata,
18:10:03 <ddarius> I'll need to file a bug report with Neil.
18:10:21 <jmcarthur> ah i didn't notice that
18:12:20 <vrthra> also, appending two metadata together is not defined.. (it can't be a monoid)
18:15:57 <rwbarton> < vrthra> for implementing 'return' I have to make one of the data empty
18:16:11 <rwbarton> is this what you want to do, or a problem you have encountered
18:16:27 <vrthra> it is the problem I have encountered
18:16:44 <vrthra> I can't have empty metadata.
18:17:04 <vrthra> nor can I merge two metadata together
18:18:49 <Cale> vrthra: That's the only monad on that tree type I can think of.
18:19:20 <vrthra> cale: is it possible to split the tree type so that I can have one monad for metadata and another for content?
18:19:33 <Cale> Why monad?
18:19:45 <Cale> Why should the metadata form a monad at all?
18:19:52 <Cale> Or the content, for that matter?
18:20:08 <vrthra> my idea is to use it like a normal tree monad.
18:20:23 <vrthra> the difference here is just that the tree contains more data
18:20:24 <Cale> You want to systematically replace all the leaves with other trees?
18:20:30 <vrthra> yes
18:20:32 <Cale> okay
18:20:47 <vrthra> all leaves with other leaves.
18:21:05 <Cale> Oh, well, that's just a Functor instance.
18:21:10 <Cale> Not a monad instance.
18:21:19 <vrthra> ok, I have that
18:21:31 <roconnor> vrthra: you want to do this replaces only on the contents of the leaves and not on their location?
18:22:01 <rwbarton> you could write down a type which is the type of a tree that has no metadata at the root
18:22:25 <rwbarton> dunno if this is helpful, but that should be a monad and your original thing is some kind of module over it
18:23:11 <rwbarton> alternatively, if you remove metadata from the leaves then you get the other kind of module
18:23:14 * roconnor thinks a file systems would be more likely to have a comonadic extend than a monadic bind.
18:23:36 <vrthra> roconnor: ok
18:23:38 <rwbarton> Which is what Cale suggested originally
18:23:53 <vrthra> I will read up on comonads,
18:24:31 <vrthra> rwbarton: not sure I understood what you suggest.
18:24:47 <Eduard_Munteanu> Well, zippers are comonadic, and they make sense in the context of a tree.
18:25:45 <dainanaki> Hello all, I've got an issue where I'm trying to marshal a simple C struct into Haskell using c2hs, but I'm getting something wrong and getting access violations. Could someone help me debug the code in question? This is my first serious attempt at porting a library to Haskell, so I'd really like to figure out what I'm doing wrong.
18:25:47 <dainanaki> http://hpaste.org/50948
18:26:25 <vrthra> I will readup a little more, and then come back.
18:26:52 <rwbarton> it would help (us, at least) if you defined the problem you were trying to solve a little better
18:27:55 <rwbarton> for example, a specific application for some kind of monad-like structure
18:28:22 <vrthra> what I was trying to do, was to model file systems such that I can run queries against them, say like all files/dirs created by an author or all files that contains a keyword, do operations on them like move copy etc.
18:28:47 <jmcarthur> i think a downside to having do notation is that it entices people to write monads even when they aren't necessarily the most natural way to work with a model (not that i'm saying this scenario applies to the question at hand, but it kind of sounds like that sort of situation)
18:29:44 <Eduard_Munteanu> Maybe more like an applicative functor?
18:29:54 <vrthra> The reason I thought of it as a monad is that I can see what to do if it conained either bits of data in isolation. i.e a tree with no metadata is a monad, and a tree with no content is also a monad
18:30:28 <rwbarton> I don't think the tree with no content is a monad
18:30:47 <Cale> I think it can be, but in a rather unusual way.
18:30:55 <rwbarton> or... hmm
18:31:12 <rwbarton> perhaps, which way is that?
18:31:46 <vrthra> not sure about applicative part (Eduard_Munteanu:)
18:32:09 <rwbarton> you want to somehow graft the tree contained in the metadata to the original tree I suppose?
18:32:15 <vrthra> yes
18:32:41 <Cale> yeah, you're grafting them all together
18:32:44 <Cale> into a giant tree
18:32:45 <copumpkin> I'd quite like it if do notation were made more clever, to use applicative where it can get away with it :P
18:33:03 <Jafet> Much ado
18:33:16 <Cale> with, I think as many vertices as the product of all the sizes of the contained trees?
18:33:18 <copumpkin> I guess that would involve an Applicative superclass of Monad
18:33:22 <parcs> copumpkin: why?
18:33:27 <parcs> (the former)
18:33:43 <rwbarton> the product? oh, this wasn't what I had in mind
18:33:43 <Cale> It's not a very useful monad, as far as I can tell.
18:33:50 <rwbarton> but, I see what you are thinking of now
18:34:06 <copumpkin> parcs: if you use Applicative, it's easier to reason statically about elements of the type constructed that way (parsers, for example)
18:34:21 <copumpkin> of the value, I should say
18:34:29 <parcs> hmm yeah
18:34:41 <parcs> @src (*>)
18:34:42 <lambdabot> (*>) = liftA2 (const id)
18:34:59 <copumpkin> not just that
18:36:19 * hackagebot aws 0.0.6 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.0.6 (AristidBreitkreuz)
18:36:30 <copumpkin> if I write do x <- a; y <- b; z <- c; return (f a b c)
18:36:37 <copumpkin> I could've used just applicative
18:37:06 <rwbarton> The operation I had in mind was such that the children of a vertex in the join of something are its original children union the children of the root in the tree at that vertex
18:37:24 <rwbarton> or I should say ++, rather than union
18:38:45 <kmc> is it still the case that any Haskell article will magically end up on /r/haskell
18:38:55 <copumpkin> not so much without dons around
18:38:58 <copumpkin> but I'll post it if you want
18:39:00 <kmc> what happened to dons?
18:39:07 <copumpkin> he got eaten in singapore
18:39:12 <copumpkin> but I think he's flown back to NYC now
18:39:16 <copumpkin> so who knows, he might be back
18:40:31 <Cale> Er, actually what I was thinking of is a fair bit larger than I thought for size :)  It'll be that large in memory, but with a lot of sharing involved, so it'll have a lot more vertices even.
18:42:04 <hpaste> fcr pasted “rules” at http://hpaste.org/50949
18:42:22 <fran> does anyone know why this doesn't work? ^^
18:42:28 <dainanaki> I asked a little while ago, but nobody really responded, and I'm still not sure what's wrong here:  http://hpaste.org/50948
18:43:14 <Cale> dainanaki: I looked at it and didn't see anything immediately.
18:43:22 <Cale> dainanaki: But I haven't really used c2hs that much
18:43:29 <Cale> (and it was a long time ago when I did)
18:43:36 <dankna> if I had to guess
18:43:45 <dankna> I would say that it doesn't understand the idiom of char **
18:43:56 <Cale> oh, are you using the memory allocated by alloca outside of that block?
18:44:09 <Cale> (because it deallocates the memory automatically)
18:44:12 <dainanaki> I don't think so...
18:44:55 <dainanaki> I thought that peeking just was a way to marshal data.
18:45:16 <Cale> It pretty much is...
18:45:29 <Cale> This definition is missing poke, but that's obviously not the problem
18:45:42 <dainanaki> yeah, I was trying to take things one step at a time.
18:45:52 <rwbarton> `plusPtr` 1 is not what you want, I think... that 1 means 1 byte
18:46:11 <rwbarton> don't you want to advance by sizeof(char *)
18:46:18 <dainanaki> Indeed I do!
18:46:31 <Cale> no, that does advance by the size of whatever value the pointer points to
18:46:40 <rwbarton> try advancePtr
18:47:05 <ddarius> copumpkin: I think making do-notation use Applicative when it can would lead to surprising changes in type (and possibly semantics) for seemingly superficial changes in code.
18:47:10 <Cale> errrrr
18:47:25 <copumpkin> ddarius: yeah, it definitely could
18:47:28 <Cale> maybe not
18:47:33 <dainanaki> rwbarton, there is no advancePtr.
18:47:42 <ddarius> @hoogle advancePtr
18:47:42 <rwbarton> it's somewhere
18:47:42 <lambdabot> Foreign.Marshal.Array advancePtr :: Storable a => Ptr a -> Int -> Ptr a
18:48:26 <vrthra> I wasn't looking at the join since I assumed that if I provided return and bind, that is enough, the first kind of monad (with metadata in all nodes) is here hackage : containers Data.Tree and the second kind (with content only in leaves is here http://www.haskell.org/haskellwiki/Monads_as_containers
18:48:29 <Cale> oh, right, yes, advancePtr :)
18:48:34 <dainanaki> ah, I found it in Foreign.Marshal.Array.
18:48:35 <Cale> plusPtr is useless
18:48:49 <Cale> (relatively)
18:48:51 <Cale> sigh
18:49:14 <Cale> But I guess you don't want to require an instance of Storable to add to a pointer
18:49:40 <rwbarton> plusPtr is probably used by that {#get git_strarray.count #} p thing
18:49:47 <ddarius> plusPtr is (conceptually at least) what advancePtr is built upon.
18:50:03 <ddarius> Yes, plusPtr also makes sense for structure access rather than array access.
18:50:14 <ddarius> plusPtr changes type.
18:51:00 <Peaker> I think Haskell's FFI solutions for stuff like struct access are very bad as of yet..
18:51:13 <Peaker> It would be nice to auto-generate Haskell accessor code from debug info rather than via c2hs
18:51:47 <dainanaki> Yeah, the state of the Haskell FFI is kind of sad, IMHO
18:51:56 <Peaker> I wrote an FFI-over-pipe for C (Python frontend only at the moment), which uses debug info, and it's pretty nice to freely access C types, variables, functions without first declaring them
18:52:04 <dainanaki> But I realise that it's a hard problem.
18:52:32 <Cale> dainanaki: It's actually pretty good considering what most languages' FFI is like.
18:52:32 <dainanaki> So I attempted to use peekArray as an alternative, but that didn't pan out so well.
18:52:45 <Peaker> This FFI I wrote is pretty great for unit testing C code
18:52:46 <dainanaki> Same issue.
18:53:02 <dainanaki> Peaker, care to share?
18:54:01 <rwbarton> dainanaki, did replacing 1 by 4 or 8 or whatever fix your problem?
18:54:10 <ddarius> Peaker: And if there is no debug info? or if you are using a different compiler?
18:54:11 <Peaker> dainanaki: I have a slightly bitrot'd version (from about 6 years ago I think) at http://pybuild.sourceforge.net/cinvoke.html  I've improved it but not yet released the improved version
18:54:13 <rwbarton> it sounds like peekArray ought to work
18:54:19 <Peaker> ddarius: then you can manually declare everything
18:54:36 <Cale> Has anyone gone to the trouble of verifying the monad laws for the instance of Monad for Tree in the containers package?
18:54:40 <dainanaki> peekArray still had the same issue.
18:54:52 <Peaker> ddarius: but typically you can get your hands on the debug info in your development version (though it may still have problems, seeing through implementation details)
18:54:53 <ddarius> dainanaki: What issue?
18:55:05 <dainanaki> http://hpaste.org/50948
18:55:10 <dainanaki> Segfault.
18:55:36 <mjo> Cale: thanks for the fibs example earlier (memoizing), I was able to adapt it to my problem and even use it in parallel
18:55:44 <Cale> mjo: nice!
18:55:44 <rwbarton> "segfault" is not necessarily the same issue
18:55:47 <ddarius> dainanaki: return $! StringArray ... does nothing.
18:56:10 <dainanaki> I know, that was from an earlier experiment.
18:56:16 <Cale> mjo: I should also have pointed out the existence of Data.MemoCombinators
18:56:30 <mjo> It didn't give me too much of an absolute speedup, but now, my profiling shows me that one function is responsible for 60-some% of the slowness.
19:00:28 <Sgeo> :t text
19:00:30 <Sgeo> Um
19:00:34 <Sgeo> Sorry, guys
19:00:41 <Sgeo> I think we killed lambdabot
19:00:43 <Sgeo> > 1+1
19:01:16 <shachaf> String -> doc
19:01:16 <shachaf> 2
19:01:26 * shachaf is no good as a bot.
19:01:30 <hpaste> dainanaki annotated “C structure marshalling” with “C structure marshalling (annotation) (annotation)” at http://hpaste.org/50948#a50951
19:01:49 <dainanaki> Still baffled.
19:02:02 <mjo> I think I injured myself again trying to figure out how MemoCombinators would apply to my problem.
19:02:30 <mjo> Anyway, now that I've eliminated all of the recomputation, it's obvious that I have to improve my hit detection
19:02:49 <Cale> mjo: Well, it applies in exactly the same way
19:02:53 <copumpkin> Cale: murther!
19:03:20 <copumpkin> @remember gosu Type parameters are covariant. This is not sound, and that does not matter.
19:03:22 * monochrom is a better bot but drunk now :)
19:03:22 <mjo> I've had a few glasses of scotch, it applies much more difficultly =)
19:03:28 <Cale> mjo: Except that instead of making a separate array, you just define a memoised version of your function (like the example in the MemoCombinators doc shows), and do mutual recursion with that
19:03:52 <Cale> An array is little more than a representation of a function on a finite domain anyway
19:04:02 <dainanaki> Oh FFS
19:04:08 <dainanaki> I figured out my issue.
19:04:43 <dainanaki> wait, nvm.
19:05:46 <ddarius> Just throw in some putStrLns and make sure values are what you expect them to be.
19:06:08 <dainanaki> Definitely no.
19:06:16 <Peaker> Cale: an immutable one, yeah
19:06:26 <dainanaki> I'm getting StringArray length counts as like 1123125152 and whatnot.
19:06:48 <kmc> it would be fun to have practical examples where a huge array is worse than recomputing the function
19:06:50 <kmc> due to cache, say
19:06:55 <ddarius> dainanaki: As in the count variable in peek is that?
19:07:01 <dainanaki> Yes.
19:07:25 <dainanaki> it varies, but it's generally absurdly large: 138862889749446657
19:07:31 <Peaker> kmc: a lookup table for number of enabled bits in, say, a 32-bit integer :)
19:07:32 <ddarius> dainanaki: Okay, it's possible that you are giving peek a bad pointer.
19:07:50 <Peaker> (even for 16-bit integer it makes little sense to do it, and for 8-bit integer it makes sense if you have a loop)
19:08:14 <ddarius> Or rather the pointer isn't being filled properly.
19:08:25 <dainanaki> that's what I'm wondering about. I'm not sure how to debug that.
19:08:38 <kmc> popcnt!
19:08:46 <rwbarton> try writing a C program to make sure git_tag_list does what you expect?
19:09:05 <dainanaki> yes, I could try that.
19:09:27 <rwbarton> what does {#pointer *git_strarray as StringArrayPtr -> StringArray #} mean
19:09:40 <mauke> alignment _ = 4? *sadpanda*
19:09:46 <ddarius> mauke: Agreed.
19:10:00 <dainanaki> I'm learning based off of ezyang's tutorial pages.
19:10:08 <dainanaki> That's copypasta.
19:10:21 <mauke> it's also wrong
19:10:24 <monochrom> the constant function const () :: Char -> () is better off recomputed than memoized :)
19:11:26 <monochrom> ok, not very practical example :)
19:11:33 <rwbarton> kmc: one of the early Project Euler problems is about the 3n+1 sequence and it is an example, sort of
19:11:41 <kmc> mm
19:12:01 <mauke> what type does it assign to 'count'?
19:12:02 <rwbarton> there it's good to memoize over some range [1..n] but not over every value which ever appears
19:12:09 <monochrom> oh I know, hash :: String -> Int is better off recomputed than memoized in a hash table (to beg the question! :) )
19:12:20 <dainanaki> count is :: CULong.
19:13:00 <rwbarton> maybe this doesn't qualify as practical
19:13:47 <rwbarton> dainanaki: on line 40 doesn't gitStrarrayFree need an argument (p)?
19:14:23 <dainanaki> it does, that was a typo.
19:14:44 <dainanaki> one that I've already fixed in my code.
19:16:10 <rwbarton> what's the name of this {# #} stuff?
19:16:22 <dainanaki> it's the c2hs preprocessor.
19:16:26 <dainanaki> thing.
19:17:19 <dainanaki> it has helped tremendously in binding my functions with a lot less hassle, but it's not working out so well with marshalling data structures so far.
19:18:17 <joe6> dainanaki: have u tried bindings-dsl?
19:18:39 <dainanaki> I did, it was far far more verbose.
19:25:40 <rwbarton> is it possible to examine the post-c2hs code that ghc sees?
19:43:54 <palmje> echo
19:44:06 <palmje> a echo a
19:44:26 <palmje> a {echo a}
19:44:45 <Martty> >> 'a'
19:44:55 <rwbarton> 10 GOTO 10
19:45:23 <kmc> > fix id
19:46:34 <ddarius> @quote [G][O][T][O]
20:32:02 <roconnor> @hoogle reader
20:36:44 <dankna> @hoogle maybe
20:36:50 <dankna> @fromJust maybe
20:36:51 <dankna> er
20:36:57 <dankna> @hoogle fromMaybe
20:37:01 <dankna> er, no lambdabot anyway :(
20:37:19 <parcs> a -> Maybe a -> a
20:39:25 <dankna> yes, but the question was which is which
20:39:35 <dankna> I know one of them is a -> Maybe a -> a and the other is (b -> a) -> Maybe a -> a
20:39:41 <dankna> or something
20:39:42 <parcs> fromMaybe, maybe
20:39:52 <dankna> okay, thanks I think :)
21:54:15 <fengshaun> hi all!  I'm having a bit of difficulty understanding why the 'hamming' function works in this code: http://paste.pocoo.org/show/469845/
21:54:30 <fengshaun> could someone enlighten me on how this function works exactly?
21:57:20 <ddarius> fengshaun: Evaluate it by hand making sure to evaluated leftmost, outermost first.
22:00:14 <fengshaun> ddarius: I'll try to do that, thanks!
22:12:41 <copumpkin> hey guys
22:12:48 <copumpkin> some guy wants to SOLVE PROBLEMS in haskell
22:12:49 <copumpkin> hah
22:12:58 <copumpkin> we just do theory research around these here parts, don't swe
22:14:39 <Jafet> We do solve problems! But only those expressible only in Haskell.
22:22:40 <Cale> Y U TROLL?
22:26:37 * ddarius doesn't know what prompted copumpkin to speak at all.
22:26:47 <copumpkin> haskell-cafe posting
22:31:30 * ddarius is still clueless.
22:33:56 <Chewie[]> having weird issue installing a package with cabal. the package (hakyll) requires base-4.3.0.0 but i have 4.2.0.0 and hakyll can't upgrade it.
22:34:58 <Chewie[]> "base-4.4.0.0 was excluded because of the top level dependency base -any"
22:38:19 <Chewie[]> i think i need to upgrade ghc.
22:38:25 <ddarius> Chewie[]: base is essentially part of the compiler.  What that message means is that you require a newer version of GHC to use that package, so put in a constraint restricting hakyll to an earlier version if you don't need the latest one.
22:56:46 <stulli> Speaking of GHC, when will there be a new haskell-platform release? The website says it was in July...
23:01:14 <astePC> Prelude> find-vars x = x
23:01:15 <astePC> <interactive>:1:12: parse error on input `='
23:01:20 <astePC> ?
23:16:33 <hpaste> kizzx2 pasted “How to use ArrowLoop to simplify this?” at http://hpaste.org/50952
23:17:17 <kizzx2> ^ i've got this function which returns      (ResultType, NextInputType), it smells very much like what ArrowLoop is supposed to do ((->) instance)
23:18:02 <kizzx2> i wonder if i can use `loop` the define the above function more cleanly?
23:28:58 <hpaste> kizzx2 annotated “How to use ArrowLoop to simplify this?” with “How to use ArrowLoop to simplify this? (annotation)” at http://hpaste.org/50952#a50953
23:30:35 <dolio> That's not loop.
23:30:39 <dolio> That's unfoldr.
23:31:34 <dolio> @type let swizzle (Just x, y) = Just (x, y) ; swizzle _ = Nothing in \f -> unfoldr (swizzle f)
23:31:35 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
23:31:35 <lambdabot>            against inferred type `Maybe (t, t1)'
23:31:35 <lambdabot>     In the first argument of `unfoldr', namely `(swizzle f)'
23:32:27 <dolio> Oh, wait, it's actually even simpler.
23:32:45 <dolio> @type unfoldr . Just
23:32:46 <lambdabot>     Couldn't match expected type `b -> Maybe (a, b)'
23:32:46 <lambdabot>            against inferred type `Maybe a1'
23:32:46 <lambdabot>     Probable cause: `Just' is applied to too many arguments
23:33:08 <dolio> @type \f -> unfoldr (Just . f)
23:33:09 <lambdabot> forall a b. (b -> (a, b)) -> b -> [a]
23:33:14 <Jafet> :t strong
23:33:15 <lambdabot> Not in scope: `strong'
23:33:20 <Jafet> :t strength
23:33:20 <lambdabot> Not in scope: `strength'
23:33:27 <Jafet> @hoogle strong
23:33:27 <lambdabot> Text.Html strong :: Html -> Html
23:33:27 <lambdabot> Text.XHtml.Frameset strong :: Html -> Html
23:33:27 <lambdabot> Text.XHtml.Strict strong :: Html -> Html
23:34:08 <Jafet> Err (or?)
23:34:27 <copumpkin> @let strength = uncurry (fmap . (,))
23:34:28 <lambdabot>  Defined.
23:34:30 <copumpkin> but that's the other way
23:35:17 <Jafet> Haskell has weird antonyms
23:36:12 <Jackhftang> to jafet: you have to import the module before you call strong
23:37:04 <Jafet> I thought it was imported
23:37:16 <Jafet> But it was actually introduced by sneaky pumpkins in the nighttime
23:38:51 <Jackhftang> to jafet: there three module contain definition of strong, which one do you want to use?
23:39:39 <Jafet> Neither; I'm not a web hero
23:40:50 <kizzx2> dolio: woot, thanks, `unfoldr (Just . f)` is quite clean
23:40:59 <kizzx2> dolio: but i wonder if i can use ArrowLoop just for the sake of it, though
23:42:24 <dolio> You can, but your scenario isn't what loop does.
23:43:08 <dolio> loop is for when you write things like: let (x, r) = f (y, r) in x
23:43:16 <dolio> Which is pretty unusual.
23:45:00 <Jackhftang> why is fromInteger defined in class Num?
23:47:04 <Jafet> Should it be defined somewhere else?
23:47:10 <kizzx2> dolio: actually, that definition looks extremely similar to the `stream = fst . go` part i pasted, that's why i thought i could seize this rare opportunity to finally grasp ArrowLoop :P
23:47:50 <Jafet> 3 :: t is interpreted as (fromInteger (3 :: Integer)) :: t.
23:49:04 <kizzx2> it seems like ArrowLoop roughly translates to "current value depends on a future value", which makes it some kind of "twin" with unfoldr
23:49:15 <dolio> kizzx2: For one, you never use the second result of 'go', so you might as well not have it.
23:49:22 <kizzx2> well not "twin" but i dared not to speak "dual" coz i may get brutally corrected
23:49:36 <dolio> For two, I actually mean: (x, r) = f (y, r), not (x, s) = f (y, r)
23:49:42 <dolio> Where r appears on both the right and left.
23:51:45 <Jackhftang> fromInteger seems not a property of Num. It could be defined outside class Num as (Num a) => Integer -> a. or do I miss something
23:51:58 <Jafet> How would you define it, Jackhftang?
23:52:08 <ddarius> dolio: It's not very unusual to what cycles in a "circuit" diagram, though it is unusual to want loop at the (->) arrow.
23:52:41 <ddarius> s/what/want/
23:53:48 <rotemy> Hi, where would be the best place for a Haskell newbie to ask questions on how to improve code he's writing to practice Haskell?
23:53:50 <dolio> Well, it's not unusual to want general recursion for your arrow program, which is what loop does.
23:54:28 <dolio> Tying it through a tuple like that isn't too common, although I can think of at least one example.
23:54:33 <nyingen> does vi haskell mode not do autoindent, or did I configure something wrong?
23:54:47 <mauke> vi, how quaint
23:54:54 <dolio> So its use as a combinator for writing your everyday functions is limited.
23:54:55 <nyingen> I meant vim
23:56:30 <Jackhftang> What I mean is why the language design choose to place fromInteger inside Num class. Is there special reason?
23:56:45 <kizzx2> nyingen: i think it doesn't do autoindent, i've been using it for some time but maybe i've missed it too
23:56:55 <Jafet> Jackhftang: how could you possibly define it outside of Num?
23:56:57 <Cale> Jackhftang: It's a more efficient replacement for zero and one
23:57:13 <Jafet> (You only need one!)
23:57:29 <ddarius> zero = one - one
23:57:34 <Cale> heh, yes.
23:57:59 <nyingen> kizzx2: oh well
23:58:37 <Jafet> rotemy: you're already there!
23:59:10 <rotemy> Jafet: cool!
23:59:49 <rotemy> Jafet: I was considering either this or Stackoverflow, but I thought S/O would be a bit impatient for that kind of stuff
