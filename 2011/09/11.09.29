00:12:14 <donri> is there some place i can report bugs in LYAH, or even some repo i can fork?
00:37:10 * hackagebot hieraclus 0.1.2.1 - Automated clustering of arbitrary elements in Haskell.  http://hackage.haskell.org/package/hieraclus-0.1.2.1 (PhilippPribbernow)
00:41:52 <cheater> donri: the book or the site?
00:49:48 <estan> hey folks. newb question, if running ghci from a utf-8 capable terminal emulator and the result of what i type in is a [Char] containing e.g. "ö", can i have ghci output "ö" instead of "\246" somehow?
00:50:04 <mauke> putStrLn it
00:50:24 <estan> mauke: thanks a bunch.
00:50:51 <mauke> (I like it when code happens to be valid english and vice versa)
00:51:35 <shachaf> @wn putStrLn
00:51:45 * shachaf sighs.
00:53:07 <estan> mauke: right. this is a school assignment though so i can't do what i want ;)
01:00:56 <donri> cheater: the online book
01:01:14 <donri> that is, content bugs not site bugs
01:01:45 <estan> another question (stylistic i guess); i'm writing a base case for a recursive String -> String function of mine, should i make it foo "" = "" or foo [] = [] ?
01:02:30 <A1kmm> A style question here: What is your preferred idiomatic way of writing code that takes a function f :: (a1 -> a2 -> ... -> an -> m b) and applies m a1, ma2, ... m an to it? Anything cleaner than join $ f `liftM` a1 `ap` a2 ... `ap` an?
01:02:34 <zomg> I think I'd make it "" if you're working with the string as a string
01:02:53 <zomg> but if you're working with it so that you're treating it more as a char array, then make it []
01:03:18 <donri> obviously you should write "foo" as 'f':'o':'o':[]
01:03:34 <mauke> A1kmm: return f `ap` ... `ap` ..
01:04:07 <zomg> donri: are you saying you don't have to do it like that?! ;)
01:04:19 <estan> zomg: thought so too. well i use general list functions on it, but the function is a String -> String function.
01:04:40 <estan> the input is a string in natural language (Swedish) and output is a transformation of it.
01:04:42 <A1kmm> Mauke: I'm trying to work that one out... doesn't typecheck AFAICT
01:04:45 <estan> i'll go with "" then.
01:04:46 <quicksilver> A1kmm: I would spell liftM <$> and ap <*>, giving  join(f <$> a1 <*> a2 <*> ... <*> an)
01:04:53 <shachaf> mauke: Is that preferable to f `liftM` ... `ap` ...?
01:05:10 <mauke> A1kmm: sorry, I misread your type
01:06:30 <A1kmm> quicksilver: Ah that is a bit cleaner... I forgot about using Applicative
01:07:11 <quicksilver> the join annoys me but that's life
01:07:19 <quicksilver> I can't really explain why the join annoys me anyway
01:08:07 <A1kmm> It guess it would be good if there was a way to do it without an outer function... but I can't think of one.
01:08:34 <A1kmm> unless there was another function to put on the end.
01:08:38 <shachaf> A1kmm: You could define one. :-)
01:08:47 <A1kmm> yeah...
01:09:20 <cheater> donri: what's the issue? i can forward it
01:10:17 <donri> cheater: i'd prefer to have a dumping place myself because i find things every now and then, but this particular instance it was:     import qualified Foldable as F   in the section on monoids
01:10:27 <A1kmm> let a <^> b = join $ a <*> b
01:10:35 <A1kmm> But I'd need to mess with the precedence as well.
01:10:41 <shachaf> A1kmm: Would you?
01:11:26 <A1kmm> join $ (\a b c -> return (a, b, c)) <$> (return 1) <*> (return 2) <*> (return 3) works
01:11:31 <A1kmm> Sorry...
01:11:50 <A1kmm> ((\a b c -> return (a, b, c)) <$> (return 1) <*> (return 2)) <^> (return 3) works
01:12:07 <A1kmm> but if you take away the outer brackets it doesn't work.
01:17:35 <quicksilver> A1kmm: you need to make it infixr, yes
01:17:44 <quicksilver> infixr and the same precedence as <*>
01:17:51 <quicksilver> or lower, maybe.
01:17:59 <quicksilver> hrm
01:22:29 <A1kmm> quicksilver: I think infixl is needed - <*> is infixl 4
01:22:40 <A1kmm> So it left-associates and applies the <^> last.
01:23:26 <quicksilver> A1kmm: you're quite right, thinko on my part
01:23:58 <shachaf> A1kmm: Isn't the default infixity good enough?
01:24:08 <shachaf> Assuming that it's the same as ap.
01:26:16 <hpaste> A1kmm pasted “<^>” at http://hpaste.org/51908
01:27:09 <A1kmm> That doesn't work if you comment out the infixl line
01:27:09 <TitusToia> :t <*>
01:27:22 <TitusToia> :k Maybe
01:27:33 <TitusToia> huh, where is lambdabot
01:28:12 <A1kmm> (<*>) :: Applicative f => f (a -> b) -> f a -> f b
01:28:29 <A1kmm> Maybe :: * -> *
01:28:45 <shachaf> A1kmm: I meant `ap`, not <*>.
01:30:06 <A1kmm> shachaf: Yeah, that works, although it is stylistically not as nice.
01:30:27 <shachaf> A1kmm: Right. It was the example you gave initially, though. :-)
01:50:58 <TitusToia> umm, this is the IRC Community on freenode, are there communities on let's say, undernet? and how do they fare ?
01:51:06 <TitusToia> (haskell-wise)
01:51:50 <Eduard_Munteanu> Why Undernet? Isn't Undernet some sort of cesspool? :)
01:52:42 <Eduard_Munteanu> I'm not sure, this is the main Haskell IRC channel.
01:53:37 <kmc> it's the main English-language Haskell IRC channel
01:53:43 <kmc> (and yeah, probably the main overall)
01:54:04 <kmc> i think the Russians are on another IRC server, or on XMPP or something
01:54:08 <kmc> wiki knows more
01:54:42 <donri> when i hoogle [a] i get matches for plain "a", how can i tell it to be more exact?
01:55:05 <kmc> well [a] is an instance of a ;)
01:55:12 <quicksilver> it should give [a] higher priority
01:55:13 <kmc> i think it will give you the more exact results first?
01:55:28 <Eduard_Munteanu> @hoogle f a
01:55:36 <quicksilver> http://www.haskell.org/hoogle/?hoogle=%5Ba%5D
01:55:38 <Eduard_Munteanu> @bot
01:55:46 <quicksilver> ^^ all the first page of results have a real [a] in.
01:55:55 <quicksilver> (curiously [] :: [a] isn't one of them :P)
01:56:04 <brisingr> hey λbot is dead
01:57:41 <kmc> yep
01:57:48 <kmc> Cale, lambdabot is dead :/
01:59:23 <brisingr> wait a sec
01:59:28 <brisingr> i'll put on a fallback λbot
02:01:34 <brisingr> > cycle "awesome "
02:01:41 <lambdabot2>  Terminated
02:01:43 <brisingr> > 1 + 1
02:01:51 <lambdabot2>  Terminated
02:01:57 <brisingr> what the
02:02:27 <brisingr> mueval?
02:02:52 <nlogax> > "Is it dead?"
02:03:02 <nlogax> aww
02:03:06 <brisingr> I killed it
02:03:12 <brisingr> it terminates every command
02:03:47 <brisingr> > "is it dead?"
02:04:00 <lambdabot2>  Terminated
02:04:21 <nlogax> now we'll be sued by james cameron
02:04:53 <brisingr> what should I do?
02:06:24 <brisingr> get back to you in 25 mins
02:07:13 <ski> A1kmm : .. i've also defined such an operator, previously
02:09:15 <donri> "get the only element of this list otherwise this default value" feels like this should have some idiom other than pattern matching / listToMaybe?
02:10:15 <mux> :t \default -> fromMaybe default . listToMaybe
02:10:19 <ski> `listToMaybe' doesn't work, no ?
02:10:26 <mux> sounds easy enough to me
02:11:17 <donri> mostly curious if there was some "obvious" fit in functors/applicative or something
02:11:52 * ski can't think of any
02:11:53 <quicksilver> well you could use foldr and const
02:12:06 <quicksilver> but I'd use fromMaybe and listToMaybe personally
02:12:11 <quicksilver> the intent seems clearer
02:12:20 <donri> not pattern matching?
02:12:37 <ski> `listToMaybe' would treat the "more than one element" case the same as the "one element case"
02:13:39 * ski understood the task as getting the *single* element of the list, in case the list has exactly one element, otherwise a default value
02:13:55 <quicksilver> ah, I understood it to be undefined if the list had more than one
02:14:03 <quicksilver> and so I chose whatever semantics I wanted for that case
02:14:08 <ski> (though CPS-ing the thing would probably be more general)
02:14:17 <donri> CPS?
02:14:17 <ski> ok
02:14:27 <mux> continuation passing style
02:14:53 <ski> instead of `foo :: a -> [a] -> a', you'd do `(a -> b) -> [a] -> b'
02:15:05 <kmc> head (xs ++ [default])
02:15:24 <mux> ski: you need a default 'a' too or a default 'b'
02:15:32 <ski> since the type `a' might not have a nice "default" element, but if you can choose any type `b' you want which has one, that's as good as that
02:15:40 <donri> nice one kmc
02:15:48 <mux> so b -> (a -> b) -> [a] -> b
02:15:55 <kmc> except that "default" is a keyword ;P
02:16:09 <ski> mux : er, yes, that's what i meant (i just woke up)
02:16:32 <donri> the real use case is simple handling of getArgs, so a case expression is probably best - i was just side tracking
02:17:20 <donri> where is "default" used?
02:17:28 <kmc> it's a top-level declaration
02:17:29 <ski> (it would also be possible to do `[arg] <- getArgs', in case you don't care that much how it fails if there is not a single argument)
02:17:32 <kmc> specifies which types may be defaulted
02:17:38 <kmc> by the ugly ad-hoc type-defaulting mechanism
02:17:59 <luqui> a shameless waste of a good variable name
02:18:16 <mux> \x f -> maybe x f . listToMaybe
02:18:18 <kmc> seriously
02:18:25 <donri> thefault
02:18:45 <mux> I guess I'd call it 'withHead' or something
02:19:18 <ski> luqui : obviously one ought to be able to shadow keywords (as well as rename them in a local scope)
02:19:47 <donri> how do you write a case expression on a single line with multiple cases?
02:20:02 <kmc> with braces and semicolons
02:20:03 <luqui> ski, where where = where where where = where
02:20:06 <mux> from memory, case foo of bar -> ...; baz -> ...
02:20:12 <donri> but where would the braces go?
02:20:13 <ski>   case foo of [a] -> bar a; _ -> baz
02:20:25 <ski> no need for braces
02:20:29 <ski> if you want them, then
02:20:29 * mux nods
02:20:29 <donri> ah
02:20:34 <ski>   case foo of {[a] -> bar a; _ -> baz}
02:21:10 <ski> luqui : brilliant in its lucidity !
02:21:23 <brisingr> @bot
02:22:00 <brisingr> lambdabot terminates all input, does it have something to do with mueval?
02:22:00 <ski> :)
02:22:39 <donri> why do i need the $ here, even if i add braces? contents <- readFile $ case args of [a] -> a; _   -> "Parse.hs"
02:22:52 <quicksilver> let where = let where let = where
02:24:47 <luqui> donri, ya just do.  technically it wouldn't be ambiguous, but it's just weird because function application is supposed to bind *tightly*
02:24:52 <luqui> and case is pretty loose looking
02:25:09 <mauke> meh
02:25:15 <donri> but i need it even with newlines and indentation
02:25:32 <mauke> this is like perl's broken precedence of ?:
02:25:45 <donri> wasn't that php
02:25:56 <mauke> no, php is completely stupid
02:26:08 <mauke> perl has a slight issue
02:26:10 <TitusToia> i find it pleasant to work in PHP with CodeIgniter
02:26:17 <luqui> blasphemy
02:26:20 * ski . o O ( (let ((let '`(let ((let ',let)) ,let))) `(let ((let ',let)) ,let)) )
02:26:25 <mauke> you can't write 1 ? 2 , 3 : 4 in perl
02:26:49 <mauke> the reason is that , has lower precedence than ?: so it somehow (doesn't) parse as 1?2 , 3:4
02:27:43 <donri> interesting, it's even the case in perl6
02:27:45 <mauke> the (readFile case) args of ... misparse seems similarly weird
02:28:00 <donri> > 1 ?? 2, 3 !! 4
02:28:00 <donri> Found ?? but no !! at line 1, near ", 3 !! 4\n"
02:28:13 <donri> whereas 1 ?? (2, 3) !! 4 is fine
02:28:18 <mauke> is , still an infix operator in perl6?
02:28:53 <donri> infix:<,> yep
02:29:01 <mauke> :-[
02:29:15 <mauke> I'll never let lwall design my syntax again
02:32:56 <donri> perl6 guru responds <jnthn> Place where I like that is so you can use it when passing an argument without having to add parens.
02:33:12 <mauke> that makes no sense
02:33:21 <kmc> yeah, those parentheses are the key obstacle to software quality in this world
02:33:26 <mauke> does this "perl6 guru" know C?
02:33:27 <donri> or are you saying it's because , is an infix op not syntax?
02:38:05 <brisingr> @bot
02:38:11 <mm_freak> does anyone know how to use fragment shaders with opengl in haskell?
02:38:48 <quicksilver> the same way as in C
02:41:17 <brisingr> lambdabot could not find ShowIO, help?
02:46:20 <ClaudiusMaximus> mm_freak: here's how i do it, there are probably better ways; compilation: https://gitorious.org/ruff/gruff/blobs/master/src/Shader.hs  usage: https://gitorious.org/ruff/gruff/blobs/master/src/Browser.hs#line98
02:52:13 <brisingr> where is control.parallel.strategies?
02:52:42 <kmc> 'parallel' package
02:53:00 <brisingr> cabal?
02:53:17 <mm_freak> ClaudiusMaximus: thanks a lot
02:53:32 <mm_freak> i wonder how difficult it is to actually write shader programs
02:54:33 <brisingr> and showio?
02:57:06 <moows> why this is wrong: instance (forall a. Num a) => Num (Vector3 a) where, but instance forall a. Num a => Num (Vector3 a) where is correct? http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-760004.3.1 <-- for me look ok
02:57:55 <kmc> hold on, "forall" isn't even in Haskell 2010
02:57:57 <ddarius> Definitely neither are correct for Haskell 2010.
02:58:34 <quicksilver> the first one is logically strange (even if you permit the forall keyword) since the second 'a' is out of scope of the forall
02:59:02 <moows> but the first is unreadable
02:59:06 <moows> at least for me
02:59:11 <moows> *the second
03:00:37 <kmc> well those two a's would be unrelated variables
03:00:37 <ClaudiusMaximus> the way i see it, i thought it would be more that the first's forall introduces a new 'a' shadowing the 'a' introduced on the rhs with implicit toplevel forall
03:01:17 <kmc> http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html
03:01:19 <brisingr> how do I import a module by specifying its path?
03:01:22 <kmc> also i think i saw a paper about this recently... maybe Oleg?
03:01:31 <kmc> brisingr, you can't
03:01:33 <kmc> why do you want to do that?
03:02:00 <brisingr> okay, different question then, what's the default path for modules
03:02:29 <brisingr> or rather, ShowIO is hidden, how do I unhide it?
03:03:07 <kmc> for modules that aren't in an installed package, it will search in the current directory
03:03:08 <kmc> e.g. Foo.Bar.Baz lives in Foo/Bar/Baz.hs
03:03:33 <brisingr> cool
03:03:34 <brisingr> thanks
03:04:59 <kmc> i should note that packages can be hidden as well
03:05:19 <kmc> there's -hide-package and -show-package and these things can be set "permanently" with ghc-pkg
03:05:27 <kmc> but the best way to handle it is to build your project with cabal
03:06:35 <brisingr> there
03:06:38 <brisingr> did it, thanks
03:07:00 <brisingr> > 1+2
03:07:07 <lambdabot2>   mueval-core: unrecognized option `--no-imports'
03:07:08 <kmc> cool
03:07:12 <brisingr> damn
03:07:18 <brisingr> now what
03:07:45 <shachaf> kmc: Cabal is nice if it happens to do everything you want.
03:08:07 <kmc> how profound
03:08:23 <shachaf> The point is that it often doesn't.
03:08:42 <shachaf> It's a wrapper around ghc --make.
03:09:59 <brisingr> it's just so fucking sick
03:10:09 <kmc> it's a fairly clever wrapper
03:10:25 <shachaf> Well, OK.
03:10:38 <erus`> i need a genius idea for a game
03:10:47 <erus`> so i can make lots of money like minecraft
03:10:54 <shachaf> If you have a project that consists of languages other than Haskell, say, it doesn't work that well.
03:10:58 <shachaf> Or if you want parallel compilation.
03:11:03 <kmc> i need a genius idea for lottery numbers
03:11:15 <kmc> shachaf, it does fine with C
03:11:38 <shachaf> kmc: If your project is primarily Haskell with a bit of C, maybe.
03:11:40 <erus`> but i will make my 10 million-copy-selling game in haskell and get some more users
03:11:41 <ClaudiusMaximus> it recompiles C even if it doesn't need to be, which is annoyment
03:11:50 <shachaf> From what I hear it doesn't do well with Haskell + C + C++
03:12:02 <kmc> shachaf, but C and C++ are, like, totally the same language!
03:12:23 <shachaf> kmc: It doesn't even work when you have two C files.
03:12:32 <shachaf> I like to call the language where you can have two C files C/C
03:12:38 <shachaf> And it's a great language.
03:12:43 <shachaf> @karma+ c/c
03:12:47 <ClaudiusMaximus> shachaf: works for me
03:12:48 * shachaf sighs.
03:13:10 <shachaf> ClaudiusMaximus: I was making a joke. But thanks to brisingr...
03:13:24 <shachaf> Well, there's also "thanks to the fact that it wasn't a very good joke...".
03:13:39 <brisingr> how do I cabal remove?
03:13:44 <mauke> no
03:13:53 <mercury^> erus`: you mean that you need to steal an idea so you can make money, like minecraft?
03:14:09 <erus`> yes
03:14:29 <erus`> maybe if i fuse chess with rts style development
03:14:45 <mercury^> I find it amusing that minecraft was initially even inferior to the open source game it ripped off.
03:15:20 <osfameron> has it improved now?
03:15:33 <mercury^> I don't really know. But I would suppose so.
03:15:36 * osfameron has avoided it on the basis that a) it looks rubbish, and b) is reputed to be addictive
03:16:15 <mercury^> It still looks worse than sauerbraten though, which also implemented a similar basic idea long before minecraft.
03:16:47 <mercury^> (and is also open source)
03:17:45 <kmc> brisingr, ghc-pkg hide
03:17:50 <erus`> maybe a turn based tennis game
03:17:53 <kmc> or ghc-pkg unregister
03:17:58 <kmc> but you still have to rm the files yourself
03:18:24 * osfameron imagines a turn-based tennis game played by selectively rm'ing files
03:18:51 <brisingr> I see
03:18:54 <kmc> what do you mean, of course the first company to implement an idea will get rich
03:19:04 <kmc> i will tell all my friends on Orkut, Friendster, and MySpace
03:19:05 <shachaf> kmc/c++
03:19:19 <kmc> osfameron, sounds like psdoom
03:19:41 <brisingr> here goes nothing
03:20:03 <brisingr> > 1+2
03:20:09 <osfameron> kmc: heh, hadn't heard of that
03:20:13 <lambdabot2>   3
03:20:20 <brisingr> wow, it worked
03:20:29 <osfameron> kmc: in fact what I'm thinking of would be almost the opposite idea to that.  But very cool
03:20:31 <brisingr> > cycle "awesome "
03:20:39 <lambdabot2>   "awesome awesome awesome awesome awesome awesome awesome awesome awesome aw...
03:20:50 <brisingr> some lag but better than nothing
03:21:02 <mercury^> kmc: but minecraft's only advantage over its competitors then was the undeserved hype.
03:21:04 <m42a> > cycle 3
03:21:07 <mercury^> Which makes it a bit sad.
03:21:11 <lambdabot2>   No instance for (GHC.Num.Num [a])
03:21:14 <erus`> whats new in lambdabot2? (i can rhyme, all the time)
03:21:17 <lambdabot2>    arising from a use of `e_13' at <inter...
03:21:27 <brisingr> erus`: lambdabot2 works.
03:21:30 <brisingr> that's new
03:21:45 <brisingr> well jokes aside it's identical to lambdabot normal
03:21:51 <kalven> mercury^: which competitors?
03:21:51 <brisingr> but lambdabot normal is dead
03:22:02 <erus`> does it use safe haskell?
03:22:07 * lambdabot2 > lambdabot
03:22:21 <shachaf> erus`: It's the exact same program, only run by a different person.
03:22:24 <TitusToia> what command do you use on IRC to look like you're doing something at the third person
03:22:31 <shachaf> TitusToia: ACTION
03:22:32 <m42a> TitusToia: /me
03:22:53 * TitusToia testing
03:22:57 * m42a speaks in third person
03:23:30 * TitusToia despises erp frameworks
03:24:18 <mercury^> kalven: cube, cube2/sauerbraten; there was also another one which is much closer to minecraft, but I forgot the name.
03:24:44 <kalven> mercury^: cube & cube2 doesn't share any gameplay with minecraft.
03:25:25 <mercury^> kalven: the gameplay of minecraft being?
03:25:51 <quicksilver> is sauerbraten anything remotely like minecraft?
03:26:00 <quicksilver> minecraft is a building game, the cube series are FPSes
03:26:08 <kalven> mercury^: sandbox crafting.. last time I checked, cube/cube2 was a multiplayer fps
03:26:14 <quicksilver> just having an in-game level-editor doesn't make you like minecraft
03:26:46 <mercury^> Multiplayer editing of the map is the only thing minecraft did for a long time, and cube* did it long before.
03:28:07 <quicksilver> yes, but minecraft turns the editing into a game
03:28:13 <quicksilver> (not that I've ever played it)
03:28:22 <quicksilver> I think that's quite different myself.
03:28:25 <mercury^> Well, what exactly does it do?
03:28:37 <mercury^> (to turn the editing into a game)
03:28:41 <erus`> i wanna make a game like minecraft but with real 3d CSG
03:28:41 <lambdabot2> Did you mean mine craft, mine-craft, mineshaft, aircraft or Lovecraft?
03:28:45 <erus`> whos with me?
03:28:45 <lambdabot2> Did you mean who's, whose, whoso, whoa or whops?
03:28:57 <frerich> quicksilver: Sauerbraten is basically a Quake-style ego shooter with the twist that you can switch into 'editing' mode in the heat of the action and then people can (cooperatively) edit the level.
03:28:58 <lambdabot2> Did you mean Subroutine, Sebastien, Straiten, Subaltern or Subteen?
03:29:03 <brisingr> whoops sorry
03:29:50 <quicksilver> mercury^: crafting eq, different levels of eq, different kinds of digger, etc.
03:30:09 <quicksilver> really this discussion would be better if I'd actually played it :) I'll shut up now, but from what i hear it really isn't anything like cube 2.
03:30:19 <kalven> mercury^: a quick look at some videos from both should be enough to show you how different they are.
03:30:33 <frerich> mercury^: The game of minecraft is to craft worlds; buildings, items, valleys, mountains, floating castles, you name it.
03:30:49 <osfameron> it sounds a bit like playing lego
03:30:56 <frerich> osfameron: It's very much like that.
03:31:06 <mercury^> frerich: which is something that, apart from the items, you can do in sauerbraten.
03:31:07 <osfameron> can you automate it?
03:31:27 <kalven> this is silly
03:31:30 <osfameron> is lambdabot2 spellchecking everything now?
03:32:26 <frerich> mercury^: I'm sure you can, but the focus of Sauerbraten is that the creation of levels is a mere instrument for playing the game (which is about collecting weapons, shooting stuff, scoring). In Minecraft, the creation of worlds *is* the game. You don't score, there is no winner, and there is no "next level". If you like, you can continue expanding the current world forever.
03:32:39 * frerich apologizes for being off-topic
03:32:51 <mercury^> Oh, I thought this was -blah.
03:33:56 <ski> frerich : Wouter van Oortmerssen !
03:34:29 <ski> (<http://strlen.com/language-design-overview>, there, now (a little more) on-topic)
03:36:31 <zuzu> is this s*** on ?
03:37:02 <frerich> ski: Uh, that name doesn't ring a bell for me.
03:38:29 <ski> frerich : <http://strlen.com/> links to "Sauerbraten", which he started (and it's a typical Wouter name, compare the programming language names at <http://strlen.com/language-design-overview>)
03:39:56 <ski> zuzu : it's not on
03:47:25 * hackagebot strptime 1.0.2 - Efficient parsing of LocalTime using a binding to C's strptime,  with some extra features (i.e. fractional seconds)  http://hackage.haskell.org/package/strptime-1.0.2 (EugeneKirpichov)
04:11:05 <TitusToia> t
05:03:18 * lispy grumbles
05:03:29 <lispy> I just want a simple bmp or png writer.
05:03:57 <lispy> Hackage has things in that area, but either they don't install or they only support reading of those formats
05:04:34 <kmc> the quick hack is to dump PPM and use an external conversion program
05:04:47 <lispy> I'm using that hack, but I dislike it
05:06:29 <ivanm> lispy: by "only support reading one of those formats" you mean they're parsers only, not writers?
05:06:35 <lispy> The two closest things to what I want that I have found: http://www.haskell.org/haskellwiki/Library/PNG and http://hackage.haskell.org/packages/archive/bmp/1.1.2.1/doc/html/Codec-BMP.html
05:06:45 <lispy> ivanm: yeah
05:07:23 <lispy> I'll probably use bmp
05:07:42 <lispy> png support would be nice, but as long as the image file is loadable in standard tools I'm happy
05:07:46 <ivanm> lispy: you could always do a bos and take this as an opportunity to write a good one... :p
05:08:00 <ivanm> lispy: though there's possibly the cairo stuff
05:08:22 <lispy> ivanm: cairo is a can of worms in that it requires so many non-haskell deps to exist
05:08:30 <ivanm> yeah
05:08:32 <lispy> otherwise, it probably is nice
05:08:53 <lispy> and there is a nice looking GD binding, but 'cabal install gd' failed on the C deps
05:09:34 <ivanm> it seems weird that so many people would want to read in an image, but then not do anything with it :/
05:09:47 <lispy> I would be more interested in making my own image library except a) it's quite tedious, b) it takes me pretty far afield from the actual task and I'm trying to shave fewer yaks :)
05:10:48 <ivanm> even benl23's bmp package failed to build for you?
05:10:55 <ivanm> seems it only needs binary, bytestring and base...
05:11:01 <ivanm> so I would have thought it'd work :s
05:11:16 <lispy> That one does build
05:11:28 <lispy> I think I'll try to make due with it
05:11:38 <lispy> Does bytestring support O(1) inplace updates?
05:11:50 <ivanm> IIRC there was a wrapper around imagemagick available...
05:11:58 <ivanm> lispy: no idea
05:12:05 <ivanm> I would think so
05:12:11 <benmachine> sdl-image?
05:12:24 <lispy> sdl-image requires C deps
05:12:33 * lispy is anti-C deps apparently
05:15:26 <ivanm> well, if it wasn't for that hsmagick might have done the trick
05:16:15 <estan> hm. can i type in multiline string literals in ghci somehow?
05:16:27 <lispy> Oh, using Data.ByteString.Internal, I could malloc the ForeignPtr Word8 myself, poke my rgb values into it, convert to bytestring then convert to bmp and write it out.
05:16:54 <lispy> estan: hm...haskell does support those, but I've never tried it in ghci
05:17:10 <mux> estan: I've read that it's supported in the very latest GHC version
05:17:35 <ivanm> estan: I don't know about ghci, but in source files you can do: "foo\<newline>\bar"
05:17:36 <estan> mux: alright. i'm at school so i don't think it's the very latest.
05:17:43 <estan> how would i go about it? just \ ?
05:17:45 <ivanm> replace <newline> with a literal newline + spaces
05:17:51 <estan> yea.
05:18:11 <estan> i tried \ at the ghci prompt and it barked.
05:18:25 <mux> estan: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/release-7-2-1.html
05:18:45 <ivanm> lispy: looks like even byorgey resorts to cair for his diagrams package
05:18:48 <mux> the release notes indeed say that GHCi now supports multiline input mode, enabled with ":set +m"
05:19:47 <byorgey> eh? "resorts to"?
05:19:48 <ivanm> Codec-Image-DevIL depends on C also
05:19:58 <ivanm> byorgey: lispy doesn't want to use cairo
05:20:06 <ivanm> and is trying to find a pure Haskell image library
05:20:10 <byorgey> ah.
05:20:12 <lispy> ivanm: yeah, I think I looked at a lot of the landscape and I'm not impressed :)
05:20:14 <estan> ah. thanks. guess i'll just have to wait until school updates ghc then. not sure which version i'm on at home, problably newer (running arch).
05:20:34 <ivanm> lispy: I'm guessing it's a case of "image manipulation is hard; let's do something more interesting instead!"
05:20:39 <lispy> byorgey: the GD binding looks quite nice actually, but not installable on osx
05:22:06 <lispy> I hate to bring in a bunch of C deps when so far my raytracer only depends on base
05:22:07 <karimo> Hello there ;)
05:22:26 * hackagebot parsec-numbers 0.0.1 - Utilities for parsing numbers from strings  http://hackage.haskell.org/package/parsec-numbers-0.0.1 (ChristianMaeder)
05:22:28 * hackagebot BiobaseTrainingData 0.1.2.3 - RNA folding training data  http://hackage.haskell.org/package/BiobaseTrainingData-0.1.2.3 (ChristianHoener)
05:22:35 <karimo> I'm a newbie and I have a little question for you
05:23:00 <karimo> It's a bit difficult to me joining different monads
05:23:02 <karimo> in do blocks...
05:23:26 <ion> What are you trying to do?
05:24:13 <karimo> I'm using HTTP package to convert a quite complex perl-http-client to haskell
05:24:27 <karimo> but I'm stuck quite at the start!
05:24:40 <karimo> First I'm trying to assign a UserAgent string
05:24:49 <karimo> through setUserAgent func
05:25:02 <karimo> then trying to putStr it rigth away...
05:25:05 <karimo> this is the code:
05:25:06 <karimo> getBrowser = do
05:25:07 <karimo>   setUserAgent "HopeHTTP"
05:25:07 <karimo>   s <- getUserAgent
05:25:07 <karimo>   return (putStrLn $ ">>" ++ s ++ "<<")
05:25:21 <karimo> but nothing is printed out...
05:25:35 <hpc> karimo: you are returning an IO action, but never executing it
05:25:53 <karimo> That is just what I was thinking...
05:26:03 <karimo> but when is exactly an IO monad executed?
05:26:03 <hpc> pastebin the rest of the code
05:26:11 <karimo> How to execute the monad?
05:26:18 <hpc> IO is executed by main
05:26:21 <karimo> Wait... I'll post all to you:
05:26:34 <karimo> Just this:
05:26:35 <karimo> getBrowser = do
05:26:35 <karimo>   setUserAgent "HopeHTTP"
05:26:35 <karimo>   s <- getUserAgent
05:26:35 <karimo>   return (putStrLn $ ">>" ++ s ++ "<<")
05:26:35 <karimo> main = return getBrowser
05:26:45 <ivanm> karimo: no, just "main = getBroser"
05:26:56 <hpc> so you are returning an IO (IO ())
05:26:57 <karimo> but main
05:27:00 <byorgey> karimo: also, get rid of the return on the last line of the getBrowser definition
05:27:05 <ivanm> then "ghc --make Foo.hs"
05:27:05 <eddie> hello
05:27:11 <karimo> doesn't force the type to be : IO something?
05:27:14 <byorgey> karimo: 'return' is not like in other languages where it is a keyword that must go at the end
05:27:19 <hpc> you want getBrowser = do ..., putStrLn $ ...
05:27:22 <byorgey> karimo: it is just a regular function of type  Monad m => a -> m a
05:27:46 <byorgey> karimo: if you already have something of type  (m a)  for your monad m, you do not need to wrap it in 'return'
05:27:55 <hpc> > (return putStrLn) :: Maybe (IO ())
05:27:55 <karimo> byorgey, I know that
05:27:56 <lambdabot2>   Couldn't match expected type `GHC.Types.IO ()'
05:27:56 <lambdabot2>         against inferred typ...
05:28:28 <karimo> let's see...
05:28:37 <karimo> main must have type IO something
05:28:50 <karimo> so with that code
05:28:52 <ivanm> hpc: did you really expect that to work?
05:28:59 <ivanm> @type return (putStrLn "hi")
05:29:00 <lambdabot2> forall (m :: * -> *). (Monad m) => m (IO ())
05:29:02 <karimo> I cannot just say: main = getBrowser
05:29:07 <ivanm> karimo: why not?
05:29:08 <hpc> ivanm: oh, derp
05:29:12 <byorgey> karimo: what is the type of getBrowser?
05:29:28 <byorgey> karimo: or, what do you intend for its type to be?
05:29:32 <ivanm> karimo: once you've fixed the error byorgey pointed out, it should work
05:30:26 <karimo> main cannot be just getBrowser 'cause
05:30:27 <karimo> *Main> :t getBrowser
05:30:27 <karimo> getBrowser :: BrowserAction t (IO ())
05:30:27 <karimo> *Main>
05:30:28 <hpc> karimo: look at the types of return, putStrLn, main, and getBrowser
05:30:35 <hpc> karimo: to see what went wrong
05:30:36 <karimo> but main must have type IO
05:30:43 <byorgey> karimo: by the way, I strongly recommend adding type signatures for all your top-level functions. it will help you a lot since it forces you to think about what type you intend for things to have, and ghc can help you out by telling you when they do not have the intended type
05:31:00 <EvanR-work> main :: IO ()
05:31:06 <karimo> yep
05:31:10 <ion> @type join . join . return . return . return
05:31:12 <lambdabot2> forall (m :: * -> *) a. (Monad m) => a -> m a
05:31:13 <byorgey> oh, I see, the BrowserAction monad is involved
05:31:24 <karimo> byorgey, that's the point...
05:31:36 <ivanm> karimo: you probably want to do just "return s" there
05:31:44 <karimo> byorgey, I just don't know how to "extract" the String from that Monad... passing it to putStrLN
05:31:47 <byorgey> karimo: you need some way to 'run' a BrowserAction computation to produce an IO computation.
05:31:48 <ivanm> then there'll be some function of type: BrowserAction t a -> IO a
05:32:04 <karimo> byorgey, THAT'S IT! but how?
05:32:11 <ivanm> so you run the BrowserAction, it returns the String and you print that
05:32:12 <hpc> karimo: go through the library
05:32:15 <byorgey> karimo: I don't know, it depends on BrowserAction
05:32:16 <ivanm> karimo: depends on which library you're using
05:32:18 <hpc> karimo: there's no generic function like that
05:32:26 <ivanm> oh, HTTP
05:32:28 <petermw> http://hpaste.org/51912 <- That could work - untested
05:32:29 <EvanR-work> \(BrowserAction _ io) -> io ;)
05:32:47 <karimo> no... it doesn't export constructors
05:32:58 <karimo> Network.Browser
05:33:00 <ivanm> karimo: browse
05:33:08 <ivanm> browse :: BrowserAction conn a -> IO a
05:33:20 <EvanR-work> was joking
05:33:24 <karimo> ;P
05:33:29 <ivanm> EvanR-work: _sure_ you were
05:33:38 <ivanm> I have a sneaking suspicion that you need to set your conn type somehow...
05:34:07 <karimo> It's driving me mad... it just not seems that complex
05:34:14 <karimo> let's see...
05:34:22 <ivanm> karimo: I already told you: use the browse function!
05:34:25 <petermw> http://hpaste.org/51913 <- Hm, that might be closer to what you want
05:34:33 <karimo> ivanm, trying...
05:34:43 <ivanm> petermw: don't do that
05:34:50 <petermw> What part?
05:34:58 <ivanm> petermw: just return the String in getBrowser, and then do the putStrLn in main
05:35:05 <ivanm> I think that's a better choice IMHO
05:35:09 <petermw> Well, that was my first suggestion
05:35:16 <ivanm> oh? must have missed that
05:35:29 <EvanR-work> unsafePerformIO (IO x) = x ;)
05:35:31 <ivanm> petermw: yeah, 51912 looks right
05:35:38 <ivanm> @slap EvanR-work
05:35:38 * lambdabot2 pulls EvanR-work through the Evil Mangler
05:35:44 <benmachine> ivanm: you don't need to set your conn type, it's an internally-used state parameter
05:35:53 <ivanm> benmachine: ahhh, an ST-like thing?
05:35:54 <petermw> But as his intention seemed to be to just have a few debug logs in there, ioAction might actually only be "half-evil" :)
05:36:03 <ivanm> petermw: true
05:36:05 <ivanm> karimo: http://hpaste.org/51912
05:36:12 <ivanm> ^^ by petermw
05:36:19 <benmachine> ivanm: not *really*, it's not as devious as that; all I mean is one can write BrowserAction code without knowing what it does
05:36:31 <benmachine> is ioAction at all evil?
05:36:33 <ivanm> petermw: but if the whole point is to get the user agent, then you should return it and get it when you run it
05:36:42 <ivanm> benmachine: oh, right
05:37:02 <ivanm> benmachine: I don't think it's evil in this context; I just think it's clearer to separate the HTTP stuff from the "normal" IO stuff
05:37:05 <karimo> Works yeah...
05:37:08 <ivanm> separation of concerns, etc.
05:37:12 <benmachine> yeah, probably
05:37:17 <benmachine> if you can, at least
05:37:17 <karimo> Thank you to you all
05:37:42 <karimo> The problem is that is still difficult to me to separate Monads like this... and to convert from one to each other
05:37:51 <ivanm> karimo: ignore that they're Monads
05:37:56 <ivanm> karimo: they're just different types
05:38:03 <ivanm> so you need to find a function that lets you convert types
05:38:12 <karimo> ok
05:38:15 <ivanm> same as how you need to find a function to convert an Int into a String
05:38:30 <EvanR-work> not in php!
05:38:34 <ion> convert an Int Monad into a String Monad?
05:38:45 * ivanm stares pointedly at ion
05:38:59 <ion> Pointed is not a monad, but monads are pointed.
05:39:04 <EvanR-work> Int and String cant be monads
05:39:18 <ion> > "foo" >>= return
05:39:19 <lambdabot2>   "foo"
05:39:27 <EvanR-work> oops
05:39:43 <EvanR-work> no
05:39:48 <EvanR-work> [Char] cant be a monad
05:39:49 <EvanR-work> [a]
05:39:59 <ivanm> EvanR-work: "[]" is a Monad
05:40:00 <EvanR-work> that be a monad
05:40:07 <ivanm> same as Maybe is a Monad
05:40:12 <EvanR-work> yea
05:40:19 <karimo> By the way for now I'd prefer this horrorous redundant writing http://hpaste.org/51917
05:40:59 <EvanR-work> doesnt seem to be well typed
05:41:16 <karimo> @type join
05:41:17 <lambdabot2> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:41:38 <ivanm> I don't know why it's suggesting you use join
05:42:04 <EvanR-work> because the type of that do expression is IO (IO String) ?
05:42:19 <ivanm> karimo: I still think it's better if you just have "return s" in getBrowser, and leave the putStrLn to be inside main
05:42:23 <antilect> What is a Monad really? I read about it, and still don't quite get it...
05:42:31 <ivanm> EvanR-work: is it?
05:42:35 <karimo> ivanm, it's sound better to me too
05:42:40 <karimo> it sounds*
05:42:46 <EvanR-work> ivanm: think so
05:42:47 <ivanm> getBrowser :: BrowserAction t (IO ())
05:42:57 <quicksilver> do { x <- foo; x } is "join foo"
05:43:04 <quicksilver> that's what HLint is telling you.
05:43:14 <ivanm> antilect: it's something you can define >>= and return for
05:43:15 <ion> @quote category.*endofunctor
05:43:15 <lambdabot2> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
05:43:36 <EvanR-work> ivanm: well not string, ()
05:43:47 <EvanR-work> karimo: in your paste, you didnt return a String from that action
05:43:51 <ivanm> antilect: it's usually better to just learn whilst using than to try and understand it up-front IMHO
05:44:09 <ivanm> antilect: I found RWH's approach to be really good in this regard (build up your knowledge of Monads by using them a bit at a time)
05:44:14 <ivanm> quicksilver: oh, right
05:44:30 <antilect> Thanks for the advice :)
05:44:38 <antilect> Haskell is my first programming language.
05:44:48 <antilect> So maybe if I used others before, I'd understand more about Monads.
05:44:50 <karimo> antilect, what a brave
05:45:05 <EvanR-work> no, im confused because youre returning an IO ()
05:45:21 <antilect> karimo, piece of cake :D
05:45:22 <EvanR-work> haskell is a great first language
05:45:29 <ivanm> antilect: nope, no other language really uses Monads
05:45:30 <quicksilver> antilect: unlikely; other programming languages don't have monads, or at least not by that name.
05:45:35 <ivanm> at least, not explicitly
05:45:36 <ion> karimo: It might be easier to learn Haskell without having to unlearn a bunch of stuff first.
05:45:39 <ivanm> and nowhere near as much
05:45:42 <antilect> I see... That's interesting...
05:45:59 <ivanm> antilect: e.g. F# calls them "Workflows", but they're just another approach
05:46:06 <ivanm> they're not as important to the language as they are in Haskell
05:46:12 <karimo> ion, that's true... it's nasty to unlearn a lot of weak type stuff
05:46:32 <EvanR-work> workflows, microsoft is retarded
05:46:43 <EvanR-work> everything has to be enterprise compatible
05:46:51 <ivanm> @quote fuzzy
05:46:51 <lambdabot2> Botje says: fuzzy feelings aren't always aerodynamic, unfortunately.
05:46:52 <ion> @where typeclassopedia
05:46:52 <lambdabot2> http://www.haskell.org/haskellwiki/Typeclassopedia
05:47:02 <ivanm> what's SPJ's quote about Monad naming?
05:47:10 <ion> antilect: The Typeclassopedia is worth reading. If it seems too advanced at the moment, later then.
05:47:16 <ivanm> @quote warm.*fuzzy
05:47:17 <lambdabot2> ksf says: * lambdabot locks up ksf in a Monad <ksf> mmmmh it's warm and fuzzy in here.
05:47:20 <ivanm> @quote warm.*fuzzy
05:47:20 <lambdabot2> ksf says: * lambdabot locks up ksf in a Monad <ksf> mmmmh it's warm and fuzzy in here.
05:47:22 <ivanm> bah
05:47:31 <ivanm> @google simon peyton jones monads fuzzy
05:47:33 <EvanR-work> yeah, look at Functor first, then Applicative, then Monad
05:47:33 <lambdabot2> http://lambda-the-ultimate.org/node/92
05:47:33 <lambdabot2> Title: Explaining monads | Lambda the Ultimate
05:47:43 <ivanm> EvanR-work: you forgot Pointed!
05:47:45 <brisingr> ivanm: lambdabot2 has only old quotes
05:47:47 <EvanR-work> yes
05:47:53 <ivanm> brisingr: ugh
05:47:57 <benmachine> the thing about Pointed is that it's pointless
05:47:58 <EvanR-work> Pointed is hipster
05:48:01 <benmachine> perhaps ironically >_>
05:48:04 <ivanm> didn't even notice it wasn't the real lambdabot2
05:48:14 <ivanm> benmachine: oh? I thought edwardk used it
05:48:23 <benmachine> ivanm: that doesn't automatically vindicate it :P
05:48:28 <benmachine> (imo)
05:48:29 <brisingr> ivanm: well, let's talk with cale about distributing lambdabot when he comes
05:48:42 <osfameron> to the needy?
05:48:44 <ivanm> brisingr: eh, I shouldn't even be here any more
05:48:44 <MHD> Is it just me or does Factor outmach LISP's metaprogramming by an order of magnitude?
05:48:46 <ivanm> @time
05:48:47 <lambdabot2> Local time for ivanm is Thu Sep 29 23:50:08 2011
05:48:51 <benmachine> ivanm: ok, the thing about Pointed is that I don't see the point of it, is that better? :P
05:49:13 <ivanm> benmachine: heh, fair enough
05:49:18 <brisingr> ivanm: good night then, I suppose
05:49:58 <ivanm> benmachine: I think the motivation is that there are some types which have pure but not <*>
05:50:22 <benmachine> ivanm: sure, but the question is what can you *do* with that information
05:50:30 <ivanm> *shrug*
05:50:35 <benmachine> ivanm: if there are no type class methods then there's no real reason to have the type class
05:50:38 <ivanm> I don't even use Applicative, so don't ask me! :p
05:50:49 <benmachine> er, by type class methods I mean things that are polymorphic in the type class
05:50:56 <EvanR-work> Pointed has pure and fmap?
05:50:57 <ivanm> benmachine: class Pointed p where pure :: a -> p a
05:51:10 <ivanm> EvanR-work: no, it's Functor => Pointed
05:51:19 <ivanm> so technically speaking the Pointed class itself doesn't have fmap :p
05:51:21 <benmachine> ivanm: right, what I meant was like, Monad has mapM and sequence and replicateM and etc.
05:51:25 <EvanR-work> ok same thing
05:51:43 <benmachine> (I happened to choose solely functions which also exist in Applicative, oh well)
05:51:48 <benmachine> foldM, that's a good one
05:51:56 <EvanR-work> benmachine: well what does Functor have, really
05:51:58 <ivanm> oh, you mean auxiliary functions?
05:52:08 <benmachine> ivanm: yeah, basically
05:52:16 <quicksilver> it's true you can't "do much" with Pointed functors.
05:52:24 <quicksilver> then again you can't "do much" with Functors either.
05:52:25 <benmachine> EvanR-work: there is at least (<$) and flip and such
05:52:40 <Eidel> How do i insert a value in a specific index in a list? (and overwrite the current value)
05:52:45 <Eidel> *at
05:52:54 <quicksilver> Eidel: you can't overwrite, haskell lists are immutable.
05:52:58 <benmachine> quicksilver: true. but fmap is far more ubiquitous than pure (although maybe that's because fmap exists and Pointed doesn't)
05:53:02 <ivanm> Eidel: only way I can think of is to use splitAt, pattern match on the result, etc.
05:53:03 <Eidel> quicksilver: ah, smart.
05:53:06 <quicksilver> you can take (n-1) xs ++ x ++ drop n xs
05:53:16 <ivanm> Eidel: but if you want to do that, it sounds like you're using the wrong data structure
05:53:29 <quicksilver> benmachine: agreed.
05:53:30 <EvanR-work> use an array
05:53:36 <Eidel> Ok
05:53:46 <Eidel> Good to know
05:53:51 <ivanm> consider an array, or possibly a Map instead
05:53:56 <quicksilver> or a Sequence
05:54:07 <ivanm> quicksilver: Sequence doesn't have index-based replacement functions
05:54:08 <EvanR-work> or a hash table!
05:54:10 <ivanm> (I just checked)
05:54:17 <ivanm> EvanR-work: huh?
05:54:29 <ivanm> quicksilver: oh, wait, it does
05:54:31 <ivanm> I missed update :s
05:54:36 <ivanm> I _thought_ there'd be one :s
06:02:32 * ski notes that Agda2 uses monads ..
06:05:31 <ski> Eidel : i called that operation `(!!<-) :: Integral i => [a] -> i -> (a -> a) -> [a]', to be used e.g. as `(ass !!<- y) $ \as -> (as !!<- x) $ \x -> ..x..'
06:06:01 <ski> (hint : generalize to other data structures)
06:06:49 <EvanR-work> cool
06:09:43 <ski> @quote luminaries
06:09:43 <lambdabot2> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
06:09:43 <lambdabot2> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
06:09:43 <lambdabot2> problems and as a reward the Tangled Gnomes gave them the S
06:09:57 * ski wonders what the rest of that one was
06:10:05 <parcs> @more
06:10:34 <EvanR-work> its like an ancient cuneiform tablet
06:10:38 <EvanR-work> well never know the rest
06:11:08 * ski . o O ( Abzu )
06:12:13 * ski ponders the idea of writing Haskell in sumerian
06:13:28 <saati> i doubt sumerian has the terminology to deal with programming
06:13:28 <osfameron> heh, googling for the Tangled Gnomes one shows that the quote has been incomplete since 2007
06:13:55 <mokus> the original is in the old IRC log archives, 06.07.26
06:14:04 <mokus> the end of the quote is "Secret of Haskell"
06:14:32 <osfameron> mokus++ # archaeology-fu
06:14:39 <mokus> :)
06:14:45 <EvanR-work> haha
06:15:10 <EvanR-work> you found the missing chunk of clay ;)
06:16:19 <MHD> I absolutely love data=code languages
06:17:06 <lispy> sweet, now my raytracer can dump to a .bmp file
06:17:24 <hpc> MHD: i would, but the uglies you can do by mutating functions in lisp prevents me from liking them categorically
06:17:42 <MHD> hpc: Have you looked at concatenatives?
06:17:49 <MHD> I.E. Factor?
06:18:20 <hpc> will look
06:18:51 <EvanR-work> haskell can mutation functions, look at flip!
06:18:54 <EvanR-work> mutate*
06:19:27 <hpc> ooh, neat
06:19:52 <hpc> like a generalized RPN calculator, almost
06:20:26 <saml> hello can i help you with haksell?
06:20:31 <MHD> hpc: The big thing in Factor is that one can write parser-words that mutate source code in place, allowing for, say, local variables to be a library.
06:20:41 <ski> @quote very.weird
06:20:42 <lambdabot2> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
06:21:15 <quicksilver> did he really say that?
06:21:20 <quicksilver> I doesn't quite read like his writing style.
06:21:28 <MHD> hpc: It is an RPN language ^^
06:21:48 <ski> @remember syntaxfree Many people think the core ideas behind Haskell [snip] In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their problems and as a reward the Tangled Gnomes gave them the Secret of Haskell
06:21:49 <lambdabot2> Good to know.
06:22:26 <ski> quicksilver : i'm not sure where that quote came from
06:22:44 <Raphaeljavaux> hi
06:22:45 <brisingr> ski: probably the original lambdabot has them
06:22:56 <ski> hpc : have you looked at MetaML or MetaOCaml ?
06:22:56 <saml> hi Raphaeljavaux
06:23:02 <brisingr> remember that this one is taken fresh from the repos
06:23:02 <hpc> ski: no
06:23:32 <brisingr> we really need lambdabot sync across multiple instances
06:23:33 <Raphaeljavaux> on this post, on the 5th code sample, I really don't understand what mappend is doing http://twanvl.nl/blog/haskell/finding-rectangles
06:23:41 <Raphaeljavaux> I know what monoid are
06:23:54 <ski> hpc : they give you well-typed quotations (better than TH, in that it is guaranteed that the generated code is also type-correct), which you can also pattern-match on
06:23:59 <Raphaeljavaux> this looks like function composition over functions of 2 parametters
06:24:38 <saml> where is mappend defined?
06:24:44 <saml> @info mappend
06:24:44 <lambdabot2> mappend
06:24:49 <ski> brisingr : *nod*, i already forgot that this is just a stand-in
06:24:56 <ski> @index mappend
06:24:57 <lambdabot2> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
06:25:13 <EvanR-work> mappend is a instance-specific thingy
06:25:19 <Raphaeljavaux> i don't know what instance of Monoid is running there
06:25:20 <ski> (the two latter modules just reexport it from the first one, for convenience)
06:26:01 <erus`> is there an easy way to split a list/vector into a list of lists of length n ?
06:26:12 <erus`> or should i write it myself
06:26:23 <EvanR-work> chunk
06:26:49 <saml> i think comparing
06:27:07 <osfameron> @where chunk
06:27:08 <lambdabot2> I know nothing about chunk.
06:27:13 <saml> @index comparing
06:27:14 <lambdabot2> bzzt
06:27:19 <osfameron> @index chunk
06:27:19 <ski> @type comparing
06:27:19 <lambdabot2> bzzt
06:27:21 <lambdabot2> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:27:34 <quicksilver> Raphaeljavaux: there is a instance for functions which relies on the codomain of the function being a Monoid
06:27:45 <igstan> Raphaeljavaux: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Monoid.html#line-130
06:27:54 <quicksilver> Raphaeljavaux: instance Monoid m => Monoid (a -> m)
06:28:06 <EvanR-work> chunk :: Int -> [a] -> [[a]]
06:28:07 <ski> Raphaeljavaux : see <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx>
06:28:18 <quicksilver> so "f `mappend` g" is the function which takes "x" to "f x `mappend` g x"
06:28:22 <Raphaeljavaux> igstan: nop, comparing is a -> a -> Ordering, not Ordering
06:28:29 <ski> s/Int/Integral i => i ->/
06:28:30 <quicksilver> and the underlying monoid is the Ordering monoid.
06:28:31 <osfameron> @hoogle Int -> [a] -> [[a]]
06:28:32 <lambdabot2> A Hoogle error occurred.
06:28:47 <EvanR-work> erus`: there is an implementation of chunk in Data.List.Split
06:29:08 <erus`> is that in the platform?
06:29:09 <igstan> Raphaeljavaux: ah, yes, you're right.
06:29:13 <EvanR-work> dont think so
06:29:38 <osfameron> it seemed quite hard to write chunk last time I wanted it
06:29:46 <EvanR-work> if you want to copy pasta, just go here http://www.haskell.org/haskellwiki/Data.List.Split
06:29:56 <osfameron> was surprised it wasn't in prelude
06:30:05 <EvanR-work> chunk n [] = []
06:30:07 <Raphaeljavaux> quicksilver: where is the source for the Monoid a -> b instance ?
06:30:08 <EvanR-work> chunk n xs = ys : chunk n zs
06:30:10 <EvanR-work> where (ys,zs) = splitAt n xs
06:30:36 <osfameron> oh, that's not so bad ;-)  I was probably making a meal of it...
06:30:45 <EvanR-work> chunk' n = takeWhile (not.null) . map (take n) . iterate (drop n)
06:30:48 <quicksilver> Raphaeljavaux: that same file. Although I just gave you the only interesting part of it.
06:30:53 <quicksilver> Raphaeljavaux: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Monoid.html#line-96
06:32:09 <Raphaeljavaux> thx quicksilver, it was not listed in the documentation, sry
06:32:22 <Raphaeljavaux> oh damn on me, it was :(
06:32:26 <hpaste> erus` pasted “Which is prettier? using chunks or like this?” at http://hpaste.org/51919
06:35:10 <EvanR-work> erus`: well you are using String to encode something so either way its ugly ;)
06:35:31 <erus`> EvanR-work: only to draw the level in the console
06:35:49 <EvanR-work> i dont see how youd use chunks for this
06:35:50 <erus`> i can make a 3d viewer later
06:36:27 <erus`> EvanR-work: split the vector of tiles into scanlines then draw
06:36:59 <EvanR-work> why are the tiles in a line then
06:37:01 <EvanR-work> in the first place
06:37:18 <EvanR-work> shouldnt they be in a grid
06:38:01 <erus`> 2d array
06:38:06 <erus`> like most games
06:38:10 <EvanR-work> right
06:38:18 <EvanR-work> not a vector which you must chunk
06:38:21 <erus`> 1d i mean
06:39:01 <EvanR-work> i still dont understand
06:40:08 <erus`> is it prettier to split a vector up or access the items via indexes?
06:40:26 <saml> what's monoid? it sounds like better than monad
06:40:30 <EvanR-work> i was saying you should have a grid, not a vector
06:40:54 <EvanR-work> if at somepoint its encoded as a 1d line for some reason, convert it to a grid as soon as possible
06:40:58 <EvanR-work> because it makes no sense that way
06:41:43 <erus`> i stored it in a Vector because i thought it would be quick
06:41:52 <erus`> i need todo random access etc
06:42:04 <EvanR-work> saml: a monoid is a simple arithmetic consisting of a combining operation, elements to combine, and a 'zero element' which is neutral when combining with stuff
06:42:15 <EvanR-work> the combining is associative
06:42:23 <cheater> @vixen
06:42:24 <lambdabot2> have you ever made it with a man?
06:42:46 <EvanR-work> erus`: performance
06:42:51 <EvanR-work> erus`: forget all that
06:42:57 <saml> EvanR-work, what's combining?  is it binary combining?
06:43:00 <EvanR-work> yes
06:43:02 <EvanR-work> 2+2 = 4
06:43:04 <saml> a `combine` b
06:43:20 <saml> so how is it different from arrow?
06:43:34 <EvanR-work> > [1,2,3] `mappend` [7,8]
06:43:34 <erus`> EvanR-work: so use a map or something?
06:43:34 <lambdabot2>   [1,2,3,7,8]
06:43:58 <EvanR-work> erus`: if you arent going to modify the grid, i say use a 2d Array
06:44:18 <EvanR-work> if your grid isnt very large you could use a list of lists
06:44:23 <erus`> i will modify the array every turn
06:44:27 <saml> why is []'s mappend concatenation?
06:44:36 <saml> who thought that 'd make sense for lists?
06:44:44 <EvanR-work> it doesnt?
06:45:29 <EvanR-work> saml: for alternative monoids, there are type wrappers
06:45:35 <erus`> > fromEnum 'a'
06:45:36 <lambdabot2>   97
06:45:39 <Oxfaded> why does this give incomplete pattern match warnings when replacing c with a constant works? let c = 1; f a = case a of c -> "a"; 2 -> "b"
06:45:40 <EvanR-work> > Product 3 `mappend` Product 7
06:45:41 <lambdabot2>   Product {getProduct = 21}
06:46:01 <saml> so only monad can do io?
06:46:06 <saml> is there IO monoid or arrow?
06:46:09 <erus`> > let f x = toEnum . fromEnum 'a' + x in f 1
06:46:10 <lambdabot2>   Couldn't match expected type `f GHC.Types.Int'
06:46:10 <lambdabot2>         against inferred typ...
06:46:26 <erus`> > let f x = toEnum $ fromEnum 'a' + x in f 1
06:46:27 <lambdabot2>   *Exception: Prelude.Enum.().toEnum: bad argument
06:46:31 <EvanR-work> IO is independent from Monad or Arrow
06:46:36 <EvanR-work> main :: IO ()
06:46:39 <EvanR-work> thats the important part
06:46:42 <EvanR-work> how you construct that IO is up to you
06:47:00 <EvanR-work> but >>= for IO is the only way to have one IO action follow another :S
06:47:26 * hackagebot RNAwolf 0.4.0.0 - RNA folding with non-canonical basepairs and base-triplets.  http://hackage.haskell.org/package/RNAwolf-0.4.0.0 (ChristianHoener)
06:48:19 <EvanR-work> erus`: modifying the grid all the time? well, guess you need to use a mutable array or a Data.Map instead, keyed by (i,j)
06:48:47 <erus`> well its gonna be just as messy as a 1d vector then
06:49:16 <EvanR-work> the array wont be, in my opinion
06:49:35 <EvanR-work> but Data.Map is a popular choice
06:50:37 <Oxfaded> why does this give *overlapping* (correction) pattern match warnings when replacing c with a constant works? let c = 1; f a = case a of c -> "a"; 2 -> "b"
06:51:27 <EvanR-work> erus`: in order to generate screen 'tiles' from a data.map all you need to do is map a consequtive [[(i,j)]] which you can build with a list comprehension using the Data.Map
06:51:31 <ClaudiusMaximus> > let c = 1 ; a = 2 in case a of c -> c
06:51:32 <lambdabot2>   2
06:51:35 <hpc> Oxfaded: because c is not a pattern
06:52:06 <roconnor> hpc: c is a pattern variable
06:52:11 <EvanR-work> or an Array
06:52:13 <erus`> EvanR-work: well i do that anyway just with    vector ! y*width+x
06:52:16 <hpc> patterns aren't first-class; you want something like f a | a == c = "a"; | a == 2 = "b"
06:52:21 <hpc> roconnor: well yeah :P
06:52:27 <EvanR-work> erus`: i still dont know why you want to use a vector so badly
06:52:39 <Oxfaded> hpc: im curious why it compiles then? what is it actually matching
06:52:44 <erus`> because thats how i used to write games in c(++)
06:52:47 <EvanR-work> the screen is a grid, your game is a grid, its a grid in your mind
06:52:58 <EvanR-work> c++ is a turing tarpit
06:53:08 <hpc> Oxfaded: it is doing a case match on a, then sees the pattern variable c
06:53:33 <hpc> it goes "aha! a matches this variable, becuase there's no specific constructors; c is now a in this scope"
06:53:47 <hpc> Oxfaded: for an example of why this behavior is useful
06:53:57 <hpc> > case Just 5 of (Just x) -> x
06:53:58 <lambdabot2>   5
06:54:21 <danr_> > case Just 5 of Just x -> x
06:54:22 <lambdabot2>   5
06:54:28 <EvanR-work> erus`: no justification for serializing anything unless youre writing data to a file (a ByteString) or a socket
06:54:30 <Oxfaded> ok so c is in its own scope and matching everything
06:54:32 <danr_> Redundant parentheses!
06:54:35 <Oxfaded> that makes sense
06:54:37 <antihoax> hey
06:54:42 <hpc> Oxfaded: a variable name in a pattern says "the pattern can match anything, but call it this"
06:54:46 <hpc> yeah
06:54:59 <antihoax> let sqr x = x * x
06:55:11 <antihoax> sqr (111*)
06:55:15 <antihoax> is an interesting thing
06:55:21 <erus`> EvanR-work: well it will be sent down a socket at some point :)
06:55:36 <Oxfaded> so lets say i want to use a name in place of a numeric constant, how does one go about writing that match?
06:55:38 <EvanR-work> then keep that part quarantined from the good stuff
06:55:43 <Oxfaded> patter*
06:55:48 <Oxfaded> pattern
06:55:50 <Oxfaded> god im tired
06:56:06 <MHD> this channel is astoundingly busy compared to other "fringe" language channels
06:56:19 <EvanR-work> haskell is failing to avoid success
06:56:30 <Oxfaded> thats because theres so many noobs like me suffering from brain f
06:57:02 <roconnor> Oxfaded: you have to use pattern guards with equality
06:57:11 <roconnor> (or if statements with equality)
06:57:40 <roconnor> [10:55] <hpc> patterns aren't first-class; you want something like f a | a == c = "a"; | a == 2 = "b"
06:58:03 <Oxfaded> can that be done with a case statement. my naive let c = 1; f a = case a of (a == c) -> "a"; 2 -> "b" didnt work
06:59:06 <roconnor> yes it can be used in case statement, but you should review the syntax for patten guards
06:59:13 <cheater> haha haskell a fringe language
06:59:14 <cheater> nice
06:59:23 <Oxfaded> roconnor: thanks
06:59:37 <hpc> pattern guards++
06:59:37 <dajkldas> why is it possible to pattern match on zero?
06:59:43 <roconnor> Oxfaded: oh and you should review the semantics for pattern guards too :)
06:59:54 <EvanR-work> dajkldas: you can pattern match on any value
06:59:57 <hpc> dajkldas: you mean like "case x of 0 -> ..."?
07:00:05 <EvanR-work> er... except functions
07:00:12 <roconnor> dajkldas: the compiler magically turns it into an pattern guard on equality.
07:00:22 <dajkldas> but zero has type, 0 :: (Num t) => t
07:00:45 <roconnor> dajkldas: you can use numeric literals as patterns
07:00:45 <hpc> roconnor: it does? i thought it considered character and number literals to be constructors
07:00:48 <roconnor> hpc: nope
07:00:49 <hpc> in a pattern, at least
07:01:00 <hpc> ah
07:01:09 <roconnor> hpc: you can pattern match on 0 even for your own instances of Num
07:01:23 <hpc> ooooooh
07:01:26 <hpc> neat
07:01:30 <EvanR-work> interesting
07:01:32 <roconnor> it uses an (== 0) test
07:01:51 <roconnor> ... now that I think about it this may be why Num has an Eq superclass
07:02:02 <roconnor> or at least part of the reason
07:02:02 <hpc> lol, i was just thinking that
07:02:28 <hpc> now to figure out why it wants Show
07:02:44 <roconnor> that is beyond me :D
07:03:16 <saml> hey, i download a cabal package from github.. how can I isntall all its dependencies so that i can run ./Setup.lhs configure
07:03:17 <EvanR-work> everyone likes a good Show
07:03:30 <saml> the package is not on hackage.. so i can't use cabal-install
07:03:51 <EvanR-work> you can install packages manually with cabal install
07:04:06 <saml> that's so tedius
07:04:25 <benmachine> saml: try cabal install --only-dependencies?
07:04:42 <saml> the package itself is only on github
07:04:51 <ocharles> saml: if it has a .cabal file just do "cabal install"
07:05:00 <saml> ocharles, oh thanks
07:05:01 <ocharles> or do you mean the dependencies aren't in hackage?
07:05:10 <plathrop> Has anyone translated the state monad stuff from learn you a haskell into stuff that works on mtl-2.x ?
07:05:16 <saml> i mean.. dependencies aren't in hackage.. how woudl cabal know where to fetch
07:05:53 <benmachine> oh, if dependencies aren't in hackage, then how are you expecting to be able to install them
07:06:15 <EvanR-work> the deps may have cabal files
07:06:17 <saml> magic of pure functional
07:06:19 <parcs> @hoogle MArry
07:06:19 <EvanR-work> install manually
07:06:19 <lambdabot2> A Hoogle error occurred.
07:06:28 <plathrop> alternately, can someone point me at a good up-to-date discussion of it?
07:07:41 <wabash> Hey, quick general haskell question: Haskell is great because of immutability. But can I mutate data structures if I want to? I'm doing GP/GA stuff, and so I have a whole lot of mutations going on, and it would be a hell of a lot more efficient to mutate data in place.
07:08:00 <tac-tics> wabash: No, never.
07:08:01 <EvanR-work> you mutant!
07:08:12 <wabash> tac-tics: Never? at all?
07:08:19 <tac-tics> wabash: You can use special kinds of constructs, though, that get compiled to in place update on the back end
07:08:22 <rostayob> wabash: there are monads with references, check out ST
07:08:23 <plathrop> wabash: what do you think this is, Clojure? :-P (totally a joke)
07:08:31 <wabash> Hahahaha
07:08:34 <wabash> I got it, too.
07:08:45 <saml> oh i think cabal install on that directory just works
07:08:51 <saml> i'm using pronk
07:08:59 <saml> i heard that it's better than ab
07:09:01 <wabash> rostayob: Yes, tell me a tiny bit more. Can I make a monad that, instead of doing IO as a side effect, changes state?
07:09:14 <EvanR-work> State
07:09:21 <EvanR-work> exists
07:09:39 <benmachine> State doesn't bypass immutability though
07:09:48 <plathrop> heh. I'm trying to learn how to use that darned State monad myself. Except it seems it is called StateT now and works completely differently than my tutorial :-)
07:09:56 <tac-tics> http://www.haskell.org/ghc/docs/4.08.2/set/mutablearray.html
07:10:01 <tac-tics> something like that, wabash
07:10:01 <EvanR-work> yep im ignoring any possible secret correlation between the last question and the previous ;)
07:10:08 <rostayob> wabash: state is a monad useful for computation that need to carry around a state, you're not mutating anything
07:10:16 <rostayob> while ST is different
07:10:45 <wabash> tac-tics: thank you.
07:10:54 <rostayob> wabash: State is basically a function 's -> (s, a)', that is a function that gets an initial state and returns the updated state and the result of the computation
07:11:07 <benmachine> ST is magic
07:11:09 <rostayob> wabash: the monad instance makes it easy to write computations of that kind
07:11:18 <wabash> rostayob: Hm.. looks like I'll need a bit more indepth understanding of Haskell to understand this...
07:11:31 <rostayob> but since you're concerned about performance, i think your best shot is ST, not State
07:11:49 <EvanR-work> or an IO array
07:12:09 <rostayob> yeah you can always work inside IO...
07:12:21 <tac-tics> wabash: http://www.haskell.org/haskellwiki/Arrays#Mutable_arrays_in_ST_monad_.28module_Data.Array.ST.29
07:12:29 <tac-tics> An example on how to use them
07:12:55 <wabash> Thank you. M reading them now. In a nutshell, what's ST?
07:13:00 <EvanR-work> and then make sure you say 29 hail marrys before going to bed for being concerned with performance
07:13:21 <parcs> :t memo
07:13:22 <lambdabot2> Not in scope: `memo'
07:13:51 <Eidel> can i specify requirements in a type? e.g. type IntList = [Int] can only have positive numbers
07:14:04 <rostayob> Eidel: no
07:14:10 <EvanR-work> Natural
07:14:15 <plathrop> Eidel: no, but don't listen to me I've only been doing this for a week
07:14:26 <wabash> EvanR-work: Thank you, for the general idea. But I mentioned that this is GA/GP. If you are familiar with that, you'll understand why performance is a concern right off the bat.
07:14:28 <rostayob> Eidel: you can use another type
07:14:39 <EvanR-work> wabash: im partially joking
07:15:04 <wabash> EvanR-work: also not sure how football plays fit into your religion.... :)
07:15:05 <Eidel> Oki
07:15:10 <EvanR-work> lol
07:15:19 <rostayob> welterde: GA/GP?
07:16:09 <wabash> rostayob: Genetic <Algorithms | Programming>
07:16:43 <benmachine> wabash: you'd be surprised how often mutable algorithms can be replaced with immutable ones of similar performance
07:17:05 <EvanR-work> benmachine: what about memory performance
07:17:06 <wabash> benmachine: No I wouldn't! :)  Yes, I know what you are saying. I also know the numbers.
07:17:37 <benmachine> wabash: ok, fair enough :P but searching "genetic" on the hackage package list turns up quite a bit
07:18:32 <benmachine> I imagine not all of it is mutability
07:19:06 <wabash> Sure, theres' a billion and one pet projects that people make. 95% of all GA packages I meet make some pretty....   "Rookie" mistakes for the domain. It's very straight forward to implement. But understanding algorithms vs. effective heuristics is hard, and the effect on performance can be dramatic.
07:19:21 <wabash> It's very easy to make it with immutable data structures.
07:19:24 <wabash> Sure...
07:19:47 <EvanR-work> memory is still a scarce resource
07:20:04 <tac-tics> This is why I only write code in type-checkable assembly logic
07:20:35 <Eidel> I get a strange message when I'm trying to create a QuickCheck instance to my _type_: "Illegal instance declaration for `Arbitrary Foo' (All instance types must be of the form (T t1 ... tn) where T is not a synonym." Where Foo is my type. Anyone know how to solve this?
07:20:55 <wabash> In other languages, I see an approx. 1.2x performance gain from allowing mutability in the genotype data structures, and sometimes rediculous performance gains of 50x by replacing the straight algs with heuristics, (with the same number of generations till solution)
07:21:03 <erus`> Maybe one of you can help me with a logic problem: http://i.imgur.com/m26Vn.png
07:21:13 <EvanR-work> wabash: thats just a constant factor increase ;)
07:21:20 <wabash> EvanR-work: Yep!
07:21:22 <rostayob> Eidel: what's Foo like?
07:21:34 <Eidel> rostayob: it is just a tuple with two ints in it
07:21:40 <rostayob> is it a type synonym?
07:21:52 <wabash> benmachine: I think you are correct and agree with you for the vast majority of cases. This one is a bit... special.
07:22:01 <Eidel> rostayob: Ints are represented everywhere, but does it matter?
07:22:07 <EvanR-work> wabash: tell your superiors performance estimates in terms of big O and itll make your life easier ;)
07:22:15 <wabash> Right!
07:22:24 <rostayob> Eidel: it does, as the error message says, you can't instantiate type synonyms (unless you turn on some language extension)
07:22:38 <rostayob> and anyway, if it's just type Foo = (Int, Int), Arbitrary is already ther
07:22:41 <rostayob> e
07:22:43 <wabash> I tell them in terms of "3 hours to find a viable solution" vs. "20 days to find a viable solution".
07:22:59 <EvanR-work> big O(1) days
07:23:01 <EvanR-work> lol
07:23:03 <rostayob> @check \(x, y) -> x + y == y + x
07:23:03 <lambdabot2>   unrecognized option `--loadfile='
07:23:03 <lambdabot2>  Usage: mueval [OPTION...] --expression E...
07:23:12 <Eidel> rostayob: but i would like to assign specific ranges of ints
07:23:23 <brisingr> check is broken on my implementation
07:23:33 <rostayob> Eidel: i think you can do that already with quickcheck, but i'm not sure
07:23:48 <rostayob> Eidel: and anyway, you can instantiate type synonym with the right language extension, ghc should tell you
07:24:00 <brisingr> they're broken because mueval changed cli parameters to --load-file
07:24:03 <Eidel> rostayob: ok. Yes it does, thanks
07:24:42 <rostayob> no problem, ghc error messages can be quite cryptic
07:24:52 <wabash> Ok, thanks everyone.
07:25:15 <rostayob> brisingr: where is the original lambdabot?
07:27:19 <brisingr> rostayob: In a ditch somewhere
07:27:50 <brisingr> apparently it's been broken for several hours
07:28:31 <EvanR-work> lol
07:28:51 <rostayob> poor lambdabot
07:28:57 <rostayob> Cale doesn't give her love
07:29:13 <tac-tics> I miss my @vixen :(
07:29:22 <rostayob> well now vixen is back actually
07:29:24 <rostayob> @vixen
07:29:25 <lambdabot2> i could really use a backrub
07:29:26 <brisingr> @vixen is okay in this one
07:29:26 <lambdabot2> ok what?
07:29:33 <tac-tics> oh yay!
07:29:40 <brisingr> when cale gets back tho
07:29:45 <tac-tics> Be back later, I've got a date with lambdabot
07:29:50 <brisingr> we should petition that we want vixen back
07:29:53 <dylukes> @. elite nixon
07:29:53 <lambdabot2> ONc3 Y0u g3+ iNto 7Hiz0rz GRE47 z+rEA/\/\ OF |-|i$ToRy, You CAn'7 GeT oU+.
07:30:11 <rostayob> @vixen you're going to be nixon again, soon
07:30:11 <lambdabot2> I hear ya!
07:30:18 <lambdabot2> tac-tics, I've dumped you
07:30:27 <lambdabot2> just kidding
07:30:32 <tac-tics> Oh, you <3
07:30:34 <roconnor> stream of history monad?
07:30:47 <roconnor> zygohistomoric?
07:30:48 <dylukes> comonad?
07:31:10 <roconnor> dylukes: it is easy to get out of comonads
07:31:19 <dylukes> Just coreturn out.
07:31:26 <roconnor> aka extract
07:31:27 <brisingr> it's easy to get out of monads too
07:31:32 <brisingr> if you unsafeCoerce your way
07:31:36 <roconnor> brisingr: if you are an algebra
07:31:45 <roconnor> brisingr: unsafeCoerce is unsafe
07:31:58 <rostayob> roconnor: nonsense, i use unsafeCoerce all the time
07:32:01 <dylukes> If I ever see someone on Facebook with an angsty status like "My life is full of an infinite number of choices, all leading to infinitely more, and I just can't handle this anymore"
07:32:04 <rostayob> best function in haskell
07:32:09 <dylukes> my response will be "Oh for fucks sake just coreturn."
07:32:40 <osfameron> coreturn?
07:32:47 <dylukes> :t coreturn
07:32:48 <lambdabot2> Not in scope: `coreturn'
07:32:49 <dylukes> :t extract
07:32:51 <lambdabot2> forall source. (Extract source) => (Int, Int) -> source -> source
07:32:54 <rostayob> ehe
07:32:55 <dylukes> eh, its w a -> a
07:32:56 <roconnor> wrong extract
07:33:08 <dylukes> forall w. (Comonad w) => w a -> a
07:33:27 <roconnor> osfameron: ^^
07:33:51 <rostayob> and the opposite of join, w a -> w (w a)
07:33:52 <osfameron> I imagine that applying the function signature to dylukes's Facebook musing will take a little more ;-)
07:34:21 <rostayob> why is it that Monad use bind and Comonad doesn't use... i don't know, cobind?
07:34:21 <dylukes> instance Comonad Life where
07:34:45 <rostayob> ah, it's <<=
07:35:01 <dylukes> or =>>, depending on where it is.
07:35:21 <dylukes> (<<=) :: w a -> (w a -> b) -> w b
07:38:59 <KirinDave> Huh
07:39:00 <KirinDave> Rare
07:39:02 <brisingr> really
07:39:09 <KirinDave> HSH compiles, but fails at runtime.
07:39:16 <brisingr> I was using =>> as w a -> (w a -> b) -> w b
07:39:21 <KirinDave> I knew that could happen with haskell, but I've never seen it before.
07:39:21 <brisingr> implementing it
07:39:26 <brisingr> well, now I know
07:40:47 <KirinDave> rostayob, you don't happen to have any links to real-world applications of comonads, do you?
07:41:10 <KirinDave> rostayob, There is that one about generating breadcrumb menus for websites, but the code is utterly incomprehensible to me.
07:43:15 <benmachine> KirinDave: there's this http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
07:43:28 <KirinDave> benmachine, I've seen that, and it's interesting.
07:43:38 <KirinDave> But I feel like it's a really really simple case.
07:44:01 <KirinDave> It's like, duplicate is the most complicated method I've ever seen written for a supposedly fundamental operation.
07:44:06 <erus`> http://gamedev.stackexchange.com/questions/17883/moving-players-simultaniously sweet karma up for grabs
07:44:30 <benmachine> infinite streams are also a comonad
07:45:08 <KirinDave> Well, so... there is this programming class some intro OO coders are doing
07:45:29 <quicksilver> erus`: just generate the new position (witha  representation which permits multiple players in the same square) and check for illegals (that is, multiplies in one square)
07:45:32 <KirinDave> And they have this minefield simulation. An NxN grid, strewn with mines with (x,y) & r, where r is their radius of explosion
07:45:42 <KirinDave> You trigger a mine and simulate the results.
07:45:50 <KirinDave> That's their project.
07:46:10 <erus`> quicksilver: then what if i have illegals ?
07:46:13 <KirinDave> My intuition is that you could model that with comonadic programming, but I am not sure how.
07:46:40 <KirinDave> It feels like a 1-hole-context-zipper-like-thing.
07:47:09 <quicksilver> erus`: cancel those players that moved, that are involed in the illegals.
07:47:14 * osfameron wishes he understood how multi-hole zippers work
07:47:17 <cheater> a minefield simulation... interesting
07:47:19 <quicksilver> hmm that could make other moves illegal.
07:47:20 <quicksilver> I see.
07:47:40 <KirinDave> cheater, it's a classic OO demo. class Mine { Point location, int radius }
07:47:57 <erus`> I think I made a bloody non terminating game
07:48:13 <KirinDave> cheater, but it seems like you could do this for minefields of infinite size and possibly infinite population.
07:48:27 <benmachine> quicksilver: that's fine, each move can be cancelled at most once
07:48:41 <benmachine> I mean it's a bit of a faff but it's strictly terminating
07:48:57 <cheater> KirinDave: are you by this assuming generative properties of the mine field
07:49:06 <KirinDave> cheater, yeah
07:49:13 <cheater> KirinDave: are you by this assuming generative properties of the mine field
07:49:15 <KirinDave> Although I'd be happy to just model it cleanly to start.
07:49:19 <cheater> sorry typo
07:49:27 <quicksilver> benmachine: true
07:49:44 <cheater> KirinDave: i was just thinking that a very large mine field could be a perfect example for parallel computing strategies
07:49:54 <gwern> > 1 :: Bool
07:49:55 <lambdabot2>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:49:55 <lambdabot2>    arising from the literal `1'...
07:49:56 <EvanR-work> erus`: its the game that never ends... it goes on and on my friends
07:50:24 <KirinDave> cheater, it'd be interesting. Again, I'd be happy to start by seeing if it's possible to model with comonads.
07:50:43 <KirinDave> I feel like I did with monadic programmng. There is a party and everyone knows the password to get in but me. :)
07:50:55 <cheater> how do comonads work
07:51:16 <EvanR-work> imagine an inside-out burrito
07:51:52 <KirinDave> Haha
07:51:57 <KirinDave> Inside-out spacesuit
07:52:10 <EvanR-work> lol spacesuit
07:52:16 <cheater> and the whole world is radioactive waste
07:52:21 <cheater> except inside the space suit
07:52:56 <Cale> Here's a question from the comp-sci Reddit: Given two Turing machines which are a-priori known to terminate in polynomial time on all inputs, is it possible to determine if they are equivalent?
07:52:57 <lambdabot2> Cale: You have 1 new message. '/msg lambdabot2 @messages' to read it.
07:53:43 <EvanR-work> check all inputs
07:53:49 --- mode: ChanServ set +o Cale
07:53:50 <tac-tics> Cale: is that an open question, or are you going to give us the answer? :P
07:53:51 --- kick: lambdabot2 was kicked by Cale (lambdabot2)
07:53:57 --- mode: Cale set -o Cale
07:53:57 <quicksilver> not in finite time, no.
07:53:59 <tac-tics> I would think "hell naw" is the proper response
07:54:12 <Cale> Well, Rice's theorem doesn't directly apply anymore.
07:54:16 <koala_man> can't inputs be infinite?
07:54:22 <Cale> Inputs are finite
07:54:24 <quicksilver> so with any kind of sensible definition of 'determine' no.
07:54:30 <Cale> but there are infinitely many possibilities
07:54:42 <roconnor> Cale: do we know the degrees of the polynomials in the polytime functions?
07:54:53 <tac-tics> There are infinitely many finite inputs
07:55:21 <EvanR-work> maybe you can use the termination to know something about the definition of the machine
07:55:31 <EvanR-work> then compute something from that, and know it will terminate
07:55:34 <Cale> I was thinking that perhaps one could do some kind of fancy recursion on the structure of the proof used to prove that they terminate to construct a test for their equivalence.
07:55:43 <EvanR-work> yea
07:55:46 <RichardBarrell> cheater: Comonads are Functors which have opposites for all of the sensible operations on Monads.
07:56:14 <quicksilver> Cale: you didn't specify we had a proof.
07:56:15 <cheater> can you give me some examples?
07:56:25 <quicksilver> Cale: you just said known to terminate. I thought an oracle had told us.
07:56:26 <RichardBarrell> cheater: like, instead of: return :: (Monad m) => a -> m a, you have: extract :: (Comonad w) => w a -> a
07:56:32 <tac-tics> quicksilver: Cale is a constructivist. If he says it's true, it means the proof is available to us.
07:56:37 <quicksilver> not so.
07:56:42 <cheater> RichardBarrell: go on
07:56:43 <Cale> I'm not a constructivist, you have a good point there :)
07:56:44 <quicksilver> constructivists discuss oracles too.
07:57:06 <cheater> RichardBarrell: what others?
07:57:31 <RichardBarrell> cheater: the other two are, instead of join :: (Monad m) => m (m a) -> m a, you have duplicate :: (Comonad w) => w a -> w (w a)
07:57:37 <Cale> There's certainly a difference between the case of an oracle having told us that they terminate in polynomial time and having an actual proof of this.
07:58:18 <RichardBarrell> cheater: and instead of bind, aka (>>=) :: (Monad m) => m a -> (a -> m b) -> m b, you get extend :: (Comonad w) => (w a -> b) -> w a -> w b.
07:59:01 <cheater> what does join do in the IO monad?
07:59:11 <mauke> what it always does
07:59:13 <mauke> @src join
07:59:13 <lambdabot> join x =  x >>= id
07:59:27 <mauke> runs outer action, then inner action
07:59:39 <cheater> i did not understand that
07:59:40 <Cale> cheater: join x = do y <- x; v <- y; return v
07:59:56 <mauke> the outer action constructs and returns an inner action
07:59:58 <cheater> aha
08:00:01 <cheater> interesting
08:00:05 <mauke> which is run next
08:00:10 <Cale> cheater: So it turns an IO action that computes another IO action into a normal one by running the result
08:00:34 <cheater> what does join do in the list monad?
08:00:35 <RichardBarrell> concat
08:00:35 <Cale> In the list monad it concatenates
08:00:35 <mauke> look at the type :-)
08:00:35 <RichardBarrell> > join [[1,2,3],[4,5,6]]
08:00:35 <lambdabot>   [1,2,3,4,5,6]
08:00:37 <cheater> yeah i was just thinking it probably concatenates
08:00:37 <mauke> join :: [] ([] a) -> [] a
08:00:41 <mauke> join :: [[a]] -> [a]
08:01:17 <cheater> hmm
08:01:24 <quicksilver> mauke: well from the type it could interleave or something
08:01:25 <cheater> @undo bind
08:01:25 <lambdabot> bind
08:01:33 <cheater> @undo x >>= y
08:01:33 <lambdabot> x >>= y
08:01:34 <quicksilver> in some ways it would be nice if it did.
08:01:45 <mauke> @redo x >>= y
08:01:45 <lambdabot> Maybe you meant: do read todo undo
08:01:45 <cheater> does bind have a do notation equivalent?
08:01:48 <mauke> @do x >>= y
08:01:48 <lambdabot> do { a <- x; y a}
08:01:56 <cheater> ok
08:02:10 <quicksilver> almost the whole point of do notation is its notation for binds ;)
08:02:32 <cheater> interesting
08:02:36 <glob157> tryin to decide between clojure & haskell
08:02:56 <glob157> i like the types in haskell :)
08:03:04 <Cale> glob157: Types are certainly nice to have :)
08:03:57 <Cale> In fact, I can hardly program without them any more. I rely a bit too much on the compiler catching all my trivial mistakes.
08:04:25 <EvanR-work> i use types even when the system doesnt check or enforce them. unfortunately it means all code not written by me is a type error
08:04:31 <Cale> (Not quite true, but it seems like so much more work to program without a type system)
08:05:04 <glob157> i know but i like clojures java interop
08:05:12 <parcs> learn both
08:05:13 <quicksilver> Cale: well, you just end up writing as if you had a type system.
08:05:18 <parcs> why do you want to learn only one?
08:05:22 <cheater> if i am in the list monad and x is my list and i have code like this: do {a <- x; a}  then what is my a?
08:05:35 <mauke> cheater: every element
08:05:35 <quicksilver> Cale: my lisp code (not that I write much) has ad-hoc algebraic data and very haskell-like constructs.
08:05:42 <Cale> quicksilver: Well, sort of. Except that it's *my* responsibility to check that the types match before I run the program.
08:05:48 <quicksilver> Cale: of course.
08:05:52 <mauke> cheater: do you know list comprehensions?
08:05:54 <EvanR-work> same with my js
08:05:56 <Cale> Which *sucks* :)
08:05:57 <cheater> yes
08:06:05 <mauke> cheater: well, that's effectively what you have there
08:06:11 <quicksilver> Cale: I find I make mistakes surprisingly rarely though once I think that way
08:06:18 <glob157> what u mean "as if" .... either compiler catches it... or you get weird cryptic errors ... :(
08:06:20 <brisingr> mauke: monad comprehensions right?
08:06:21 <rostayob> KirinDave: oops, i was away
08:06:21 <cheater> but i want to see the equivalence with how i know do notation from the io monad
08:06:23 <quicksilver> mauke: "every element" - well, it's concat x, isn't it?
08:06:49 <mauke> quicksilver: a is not concat x
08:07:06 <cheater> > let x = [1, 2] in do {a <- x; return 3}
08:07:06 <lambdabot>   [3,3]
08:07:32 * hackagebot peparser 0.21 - A parser for PE object files.  http://hackage.haskell.org/package/peparser-0.21 (IanGraves)
08:07:34 <cheater> ok so  <- is like a foreach
08:07:35 <mauke> > [ 3 | a <- [1, 2] ]
08:07:36 <lambdabot>   [3,3]
08:07:39 <brisingr> > let x = [1,2] in do { a <- x; return [3,3]}
08:07:40 <lambdabot>   [[3,3],[3,3]]
08:07:41 <quicksilver> mauke: right you are
08:07:47 <quicksilver> mauke: I read him to say "what is the result"
08:07:48 <mauke> > [ [3,3] | a <- [1, 2] ]
08:07:49 <lambdabot>   [[3,3],[3,3]]
08:07:52 <cheater> is <- like a foreach?
08:07:55 <mauke> yes
08:07:56 <quicksilver> mauke: but he did indeed say "what is a".
08:07:57 <rostayob> KirinDave: I'm not sure about the minefield as a comonadic computation, i don't have much experience with them anyway
08:07:59 <cheater> k
08:08:00 <Cale> Not having a (static) type system doesn't mean there are no types, it just means you're responsible for checking them all by yourself. :)
08:08:04 <mauke> cheater: you can also nest them
08:08:16 <cheater> yea i get it
08:08:43 <brisingr> mauke: it's like the monad comprehensions that were removed, isn't it?
08:08:47 <cheater> return is just : isn't it
08:08:56 <rostayob> cheater: (: [])
08:08:56 <mauke> cheater: (: [])
08:09:02 <cheater> yea
08:09:07 <cheater> that's pretty much what i have meant
08:09:08 <cheater> ok cool
08:09:12 <mauke> brisingr: huh?
08:09:13 <cheater> i'm getting a hang of this
08:09:13 <Cale> brisingr: Monad comprehensions were recently put back! :)
08:09:31 <brisingr> Cale: really? *leaps of joy*
08:09:33 <cheater> now that i got IO and List what next monad should i check out
08:09:50 <brisingr> Maybe
08:09:52 <rostayob> cheater: [(x, y) | x <- xs, y <- ys] is equivalent to do {x <- xs, y <- yx, return (x, y)}
08:09:56 <cheater> i know maybe
08:10:00 <Cale> Parser :)
08:10:05 <brisingr> State
08:10:10 <cheater> but i don't really know what the monad actions do in maybe
08:10:14 <rostayob> cheater: do you know s -> (s, a), ((,) e)?
08:10:16 <cheater> or monad functions rather
08:10:21 <Cale> I didn't really understand monads until I learned how to use Parsec
08:10:22 <rostayob> which are basically state and reader?
08:10:39 <mauke> cheater: Maybe is just a list with at most one element
08:10:42 <mauke> the rest is the same
08:10:56 <Cale> Unfortunately, Parsec is a good bit more complicated than it was when I learned it
08:11:06 <cheater> what does >>= do in Maybe?
08:11:06 <Cale> But any parser combinator library should do :)
08:11:14 <Cale> Nothing >>= f = Nothing
08:11:15 <rostayob> Cale: there is an excellent chapter in "programming in haskell" about parser combinators
08:11:19 <Cale> (Just x) >>= f = f x
08:11:38 <brisingr> unrelated: are ghci lists by default linked lists?
08:11:38 <mm_freak> rostayob: ((,) e) is not reader
08:11:38 <rostayob> that's how i learned about monads
08:11:43 <mm_freak> rostayob: ((->) e) is
08:11:46 <rostayob> mm_freak: sorry, writer
08:11:54 <rostayob> ((->) e) is reader
08:11:56 <rostayob> yeah
08:12:03 <mm_freak> ((,) e) is the coreader, i think
08:12:18 <rostayob> mm_freak: no, Monoid e => ((,) e) is writer
08:12:19 <Cale> I think I should give a little tutorial on how to construct a simple parsing monad...
08:12:25 <cheater> um
08:12:34 <rostayob> Cale: again, there is a really nice chapter in "programming in haskell" :P
08:12:39 <mm_freak> rostayob: ((,) e) is both
08:12:44 <cheater> so how does do notation work for Maybe?
08:12:46 <mm_freak> writer and coreader
08:12:53 <rostayob> mm_freak: oh, ok
08:12:55 <Cale> Yeah, but that book isn't here on IRC right now :)
08:13:08 <rostayob> Cale: ah you meant "now on IRC" eheh
08:13:12 <mauke> cheater: still a foreach loop
08:13:12 <cheater> x :: Maybe Int              do { a <- x; return a}      what is a?
08:13:19 <mm_freak> cheater: think of <- as 'extract'
08:13:22 <mauke> cheater: all elements of x
08:13:23 <cheater> mauke: ok
08:13:30 <mm_freak> trying to extract from Nothing will render the whole computation Nothing
08:13:31 <cheater> mauke: so the empty list is Nothing?
08:13:35 <mauke> yeah
08:13:38 <cheater> ok
08:13:43 <mm_freak> > do x <- Just 3; y <- Just 4; return (x,y)
08:13:44 <lambdabot>   Just (3,4)
08:13:44 <rostayob> mm_freak: why would ((,) e) be coreader?
08:13:52 <Cale> cheater: "Running" a Maybe value will either result in the value which Just has been applied to, or cause the entire do-block to evaluate to Nothing if the value is Nothing
08:14:13 <cheater> is join similar to python's all() ?
08:14:29 <rostayob> cheater: what's python's all()?
08:14:31 <cheater> Cale: is <- "running"?
08:14:33 <mm_freak> > join (Just (Just 3))
08:14:34 <lambdabot>   Just 3
08:14:36 <Cale> cheater: yes
08:14:42 <cheater> mhm
08:14:44 <rostayob> :t join
08:14:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:14:46 <Cale> > let dict = zip [0..] (words "hello there world") in do x <- lookup 2 dict; y <- lookup 1 dict; return (x,y)
08:14:47 <lambdabot>   Just ("world","there")
08:14:52 <Cale> > let dict = zip [0..] (words "hello there world") in do x <- lookup 2 dict; y <- lookup 7 dict; return (x,y)
08:14:53 <lambdabot>   Nothing
08:14:56 <mm_freak> cheater: in the case of Maybe i'd interpret "<-" as "extract"
08:14:59 <cheater> > join Just Nothing
08:15:00 <lambdabot>   Couldn't match expected type `a -> a'
08:15:00 <lambdabot>         against inferred type `Data.M...
08:15:07 <Cale> > join (Just Nothing)
08:15:08 <lambdabot>   Nothing
08:15:16 <Cale> > join (Just (Just 5))
08:15:16 <lambdabot>   Just 5
08:15:43 <rostayob> > join [[1,2,3],[4,5,6]]
08:15:44 <lambdabot>   [1,2,3,4,5,6]
08:16:03 <sp3ctum_> what does (,) mean/do?
08:16:06 <Cale> > let dict = zip [0..] [3,2,1,5,4] in do x <- lookup 2 dict; y <- lookup x dict; return (x,y)
08:16:07 <lambdabot>   Just (1,2)
08:16:08 <geheimdienst> cheater: you might be looking for concat or intercalate. in my experience, you don't often need join. what it does is "merge" an IO (IO String) into an IO String, if you ever have one
08:16:11 <Cale> > let dict = zip [0..] [3,2,1,5,4] in do x <- lookup 3 dict; y <- lookup x dict; return (x,y)
08:16:12 <lambdabot>   Nothing
08:16:14 <rostayob> :t (,)
08:16:14 <lambdabot> forall a b. a -> b -> (a, b)
08:16:24 <Cale> sp3ctum_: It forms pairs
08:16:28 <sp3ctum_> ...so it maes a tuple?
08:16:30 <sp3ctum_> ok
08:16:31 <Cale> > (,) 1 2
08:16:31 <rostayob> sp3ctum_: yes
08:16:32 <lambdabot>   (1,2)
08:16:35 <Cale> > (1,2)
08:16:36 <lambdabot>   (1,2)
08:16:36 <mm_freak> rostayob: http://hackage.haskell.org/packages/archive/comonad/1.1.1.1/doc/html/Control-Comonad.html#t:Comonad
08:16:37 <rostayob> :t (,,)
08:16:38 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
08:16:42 <rostayob> :t (,,,)
08:16:43 <mm_freak> see the instance for ((,) e)
08:16:43 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
08:17:28 <rostayob> mm_freak: mhm, ok
08:17:29 <rostayob> thanks
08:19:30 <cheater> interesting
08:19:45 <rostayob> cheater: read the typeclassopedia! it's good for you
08:19:50 <rostayob> @where typeclassopedia
08:19:50 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
08:21:57 <Cale> cheater: If you'd like, I can go over the construction of a simple (& inefficient because I don't care) parsing library
08:22:23 <rostayob> type Parser a = String -> (a, String) ehe
08:22:41 <rostayob> or something like that?
08:22:49 <Cale> newtype Parser a = P (String -> [(String, a)])
08:22:55 <rostayob> right
08:22:58 <cheater> Cale: hmm
08:23:03 <Cale> A parser for things is a function from strings to lists of pairs of strings and things.
08:23:05 <cheater> Cale: let me first check out the state monad
08:23:15 <cheater> i think that'd be a better idea at this point no?
08:23:23 <Cale> Um, we can do that, sure :)
08:23:37 <Cale> Though personally I find the State monad a little less motivating
08:23:43 <Cale> It might be useful
08:23:48 <cheater> so i remember reading up
08:23:58 <cheater> and basically you did something like this..
08:24:07 <Cale> newtype State s a = S (s -> (s,a))
08:24:10 <rostayob> Cale: the list part is just used to signal an error right?
08:24:17 <cheater> let me first say how i undertand it
08:24:19 <Cale> rostayob: And nondeterminism
08:24:21 <cheater> and then you can correct me
08:24:35 <cheater> you had a function which took some arguments plus an extra argument called the state
08:24:42 <Cale> rostayob: which you need to be able to construct parser combinators like 'many'
08:24:43 <antilect> Is python a nice language? :)
08:24:56 <rostayob> antilect: yes
08:24:56 <cheater> it returned its return value plus an extra value called the new state
08:25:00 <rostayob> Cale: yeah right
08:25:01 <Twey> FSVO ‘nice’
08:25:10 <cheater> in order to continue your algorithm you'd feed the new state to the function over and over
08:25:19 <cheater> that's how i understand the state monad
08:25:27 <Cale> antilect: It's pretty okay, as far as untyped imperative OO languages go.
08:25:34 <cheater> you could go "back in time" by using the same state again and again
08:25:50 <cheater> does that sound anything like correct?
08:25:55 <Cale> cheater: yeah, it's kinda like that
08:26:25 <cheater> so how does one use the state monad?
08:26:25 <Cale> So we represent a stateful computation of a value of type a as a function from an initial state of type s, to a pair consisting of a final state of type s, and a result of type a
08:26:29 <cheater> say i have a round robin
08:26:31 <cheater> with 3 states
08:26:39 <Cale> That is, State s a ~= s -> (s,a)
08:26:39 <cheater> states are 0 1 2
08:26:40 <DukeDave> Pop quiz: If I try and evaluate a function which is "= undefined", will I always get a crash?
08:26:48 <Cale> DukeDave: no
08:27:07 <DukeDave> Cale: Instead I'll get?
08:27:13 <Cale> DukeDave: if you evaluate the *function* and not the application of the function to its argument.
08:27:28 <Cale> Like, if you have f x = undefined
08:27:35 <Cale> > let f x = undefined in f `seq` 5
08:27:36 <lambdabot>   5
08:27:59 <Cale> > let f x = undefined in f x `seq` 5
08:27:59 <lambdabot>   *Exception: Prelude.undefined
08:28:03 <Cale> keke
08:28:04 <cheater> Cale: if i get the state monad we'll do the parser :)
08:28:07 <Cale> > let f x = undefined in f 1 `seq` 5
08:28:08 <lambdabot>   *Exception: Prelude.undefined
08:28:11 <Cale> cheater: Okay
08:28:20 <Cale> So, we define this newtype:
08:28:27 <Cale> newtype State s a = S (s -> (s,a))
08:28:37 <cheater> not sure how newtypes work
08:28:40 <Cale> ah
08:28:41 <DukeDave> Cale: Roger that
08:28:47 <Cale> Do you know how data works?
08:28:55 <cheater> not strictly
08:29:00 <Cale> data State s a = S (s -> (s,a)) is the same thing for our purposes
08:29:25 <Cale> This means we have a new datatype  State s a  for each type s and each type a
08:29:29 <cheater> how would i implement that round robin?
08:29:46 <Cale> Let's take it one step at a time
08:29:46 <cheater> i think a chunk of code would clear things up for me a bit
08:29:49 <cheater> ok
08:29:51 <Cale> I haven't even defined >>= yet :P
08:30:00 <cheater> let's not define it!
08:30:04 <cheater> let's look at some ready code
08:30:05 <Cale> and values of this type consist of the data constructor S applied to a function of type s -> (s,a)
08:30:08 <cheater> and then work from that :)
08:30:21 <Cale> So:
08:30:24 <cheater> because it's difficult for me to apply all those definitions without an example to apply them to
08:30:29 <Cale> S :: (s -> (s,a)) -> State s a
08:30:44 <Cale> We also need a way to run one of our stateful computations
08:30:49 <Cale> given an initial state
08:31:00 <Cale> runState (S f) s = f s
08:31:08 <Cale> our representation makes this really easy
08:31:10 <parcs> you should probably define join instead of >>=
08:31:16 <cheater> is a value of this type a "function that takes state"?
08:31:16 <rostayob> parcs: why?
08:31:17 <Cale> We just apply the function to the initial state
08:31:25 <parcs> rostayob: it's easier
08:31:25 <Cale> runState :: State s a -> s -> (s,a)
08:31:38 <rostayob> parcs: yeah but expecially with state you'd never use it
08:31:41 <Cale> sorry, should have put that first :)
08:32:17 <Cale> So we just apply the function to our initial state to get a final state and result
08:32:17 <cheater> gotcha
08:32:23 <cheater> yeah
08:32:24 <parcs> rostayob: but then you can think of >>= in terms of join and fmap
08:32:32 <Cale> Now, for return :: a -> State s a
08:32:46 <cheater> yeah what should s be there?
08:32:46 <rostayob> parcs: yeah but you'd define something without seeing the usefulness,
08:32:50 <cheater> any number at all?
08:32:51 <Cale> We want return v to be a computation which "does nothing" but whose result is v
08:33:00 <rostayob> parcs: which is why we have >>= and not join in the first place
08:33:10 <cheater> can you just return (0, v)?
08:33:17 <Cale> So the stateful computation we give will just pass the initial state along to be the final state.
08:33:35 <Cale> Well, let's tackle this systematically, actually
08:33:38 <cheater> Cale: how does it know what the initial state is?
08:33:39 <cheater> ok go on
08:33:41 <Cale> return v = ...
08:33:52 <Cale> We only have one way to make things of type State s a for now
08:33:56 <Cale> which is the S data constructor
08:33:59 <Cale> so...
08:34:03 <Cale> return v = S (...)
08:34:13 <Cale> and S takes a function s -> (s,a) as its parameter
08:34:15 <cheater> oh right
08:34:19 <Cale> So, we might as well use a lambda
08:34:21 <cheater> return gives us a stateful computation
08:34:23 <Cale> return v = S (\s -> ...)
08:34:28 <cheater> right ok i got i
08:34:28 <cheater> t
08:34:41 <cheater> return v = S (\s > (s, v))
08:34:45 <Cale> right
08:34:50 <cheater> yup! :)
08:34:51 <Cale> ->
08:34:52 <parcs> rostayob: that's true
08:34:54 <rostayob> @dijnn return :: a -> s -> (s, a)
08:34:54 <lambdabot> Cannot parse command
08:34:54 <brisingr> yeah
08:34:58 <Cale> okay
08:34:58 <cheater> yeah :) sorry :)
08:35:01 <rostayob> @djinn return :: a -> s -> (s, a)
08:35:01 <lambdabot> Cannot parse command
08:35:04 <Cale> and now let's look at bind
08:35:10 <cheater> ok!
08:35:25 <Cale> (>>=) :: State s a -> (a -> State s b) -> State s b
08:35:52 <rostayob> @djinn return ? a -> s -> (s, a)
08:35:52 <lambdabot> Cannot parse command
08:35:58 <rostayob> @djinn a -> s -> (s, a)
08:35:58 <lambdabot> f a b = (b, a)
08:35:59 <Cale> Bind will run the first state computation on the initial state, and then apply the function to its result to get a new stateful computation to run
08:36:23 <Cale> it'll then run that computation on the final state from the first computation to get a final final state and a result
08:36:37 <Cale> x >>= f = ...
08:37:03 <Cale> Well, we know that this is going to be something of type State s b, and probably isn't 'return v' so, might as well use S again
08:37:07 <Cale> x >>= f = S (...)
08:37:20 <Cale> and then might as well make it a lambda again, since it's got to be a function
08:37:24 <Cale> x >>= f = S (\s -> ...)
08:37:39 <Cale> Now here we want to run x with the initial state s
08:37:54 <Cale> x >>= f = S (\s -> let (s',v) = runState x s ...)
08:38:02 <Cale> getting a new state s' and result v
08:38:22 <Cale> and then we can apply f to v and get a State s b
08:38:46 <Cale> It's actually correct to just result in that right there, since it's the right type, but let's actually run it, just to be explicit:
08:39:00 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' ...)
08:39:19 <Cale> and then return the result of that
08:39:24 <Cale> x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w))
08:39:45 <Cale> So we can simplify this to:
08:39:54 <Cale> x >>= f = S (\s -> let (s',v) = runState x s in runState (f v) s')
08:39:55 <brisingr> what's wrong with x >>= f = S (\x -> let (s',v) = runState x s in (s',f v))
08:39:57 <Cale> if we like
08:40:13 <brisingr> oh
08:40:20 <Cale> brisingr: that's a type error, and s' isn't supposed to be the final state of the overall computation
08:40:25 <Cale> It's the intermediate state
08:40:34 <cheater> ok
08:40:40 <cheater> let me think about that for a sec
08:40:42 <brisingr> right
08:41:56 <Cale> cheater: Yeah, it takes a bit of getting used to since we're really doing seriously functional programming here, representing things with functions all over the place :)
08:43:15 <parcs> for comparison join m = S (\s -> uncurry runState (runState m s))
08:43:44 <Cale> There'll also be at least two more (thankfully simple) things we'll want to define to make our state monad useful. Just knowing that it's a monad doesn't let us do a whole lot with it, so we'll need a way to get and set the current state.
08:43:45 <parcs> or S . uncurry runState . runState :P
08:44:34 <Cale> get :: State s s  will be a computation which results in its initial state, and doesn't affect the state
08:45:08 <Cale> put :: s -> State s ()  will construct a computation which ignores the initial state and sets it to the given value
08:45:23 <cheater> mhm
08:45:30 <Cale> cheater: Let me know when you're caught up, or if you have any questions :)
08:45:30 <arun_> asdf
08:45:32 <cheater> how do you use put and get?
08:45:37 <cheater> do you use them in do notation?
08:45:45 <Cale> sure, if you want
08:45:53 <cheater> can you give me an example?
08:45:59 <Cale> yeah...
08:46:12 <Cale> Let's say we have this tree datatype:
08:46:25 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
08:46:38 <Cale> and we want to write a function   relabel :: Tree a -> Tree Integer
08:46:39 <Y_Less> do notation is just a wrapper for monad composition, you don't have to have it
08:46:52 <Cale> which numbers the nodes of the binary tree from left to right
08:46:57 <Cale> For example...
08:47:18 <cheater> gotcha
08:47:20 <Cale> Branch "hello" (Branch "there" Tip Tip) (Branch "world" Tip Tip)
08:47:22 <Cale> will become
08:47:32 <Cale> Branch 1 (Branch 0 Tip Tip) (Branch 2 Tip Tip)
08:47:42 <Cale> (we think of the left subtree as being before the root)
08:48:07 <cheater> so this is a binary tree yes?
08:48:10 <Cale> yeah
08:48:13 <cheater> ok
08:48:22 <cheater> sure let's try it
08:48:26 <Cale> This is something which is kinda awkward to do recursively normally, because we have to keep track of what the next available label is
08:48:34 <brisingr> yeah so we can say data Tree a = Tip | Branch (Traa a) a (Tree a) to see it easier, right?
08:48:45 <brisingr> err, Tree
08:48:47 <Cale> we want to label the root with a label which is one more than the largest label we used in the left subtree
08:49:09 <Cale> and so normally, you might add an extra parameter to keep track of that, but instead, let's use the State monad
08:49:17 <Cale> First, I'll define:
08:49:24 <Cale> next :: State Integer Integer
08:49:38 <Cale> next :: do n <- get; put (n+1); return n
08:49:54 <Cale> Which will get the next available label, and increment the state
08:49:59 <brisingr> so we just have a computation which begins at zero and then traverses the tree and increments its state each time
08:50:14 <Cale> yeah
08:50:26 <Cale> relabel' :: Tree a -> State Integer (Tree Integer)
08:50:33 <Cale> relabel' Tip = return Tip
08:51:09 <Cale> relabel' (Branch x l r) = do l' <- relabel' l
08:51:17 <Cale> (first relabel the left subtree)
08:51:17 <cheater> Cale: why is your function type State Integer Integer
08:51:20 <cheater> is it missing an arrow?
08:51:25 <Cale> no
08:51:39 <Cale> It's a stateful computation which produces the next Integer label to use
08:51:40 <cheater> how do i understand State Integer Integer?
08:51:50 <Cale> and the state type is an Integer
08:51:59 <cheater> ok
08:52:18 <Cale> So internally, it's a function Integer -> (Integer, Integer)
08:52:20 <cheater> so State X Y means stateful computation where the state is type X and the return is type Y?
08:52:25 <Cale> yeah
08:52:32 <cheater> or are X and Y swapped?
08:52:36 <Cale> no, that's right
08:52:39 <cheater> cool
08:52:41 <cheater> ok wait
08:52:43 <Cale> State s a -- state type s, result type a
08:53:19 <cheater> next :: do n <- get; put (n+1); return n <<< ahh that is straightforward
08:53:33 <Cale> oh, sorry!
08:53:37 <Cale> that should be next = ...
08:53:44 <Cale> next = do n <- get; put (n+1); return n
08:54:23 <cheater> yeah i didn't even notice the error
08:54:27 <cheater> :)
08:54:29 <Cale> okay
08:54:32 <cheater> mental corrector is on :)
08:54:33 <Cale> So now...
08:54:39 <cheater> ok can we start over with relabel'?
08:54:42 <Cale> yeah
08:54:54 <Cale> relabelling a Tip is easy, because there's no work to do
08:54:57 <mux> :t modify
08:54:58 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
08:55:03 <mux> mmm
08:55:07 <Cale> relabel' Tip = return Tip
08:55:13 <mux> modify could be made more useful by returning the old value
08:55:24 <cheater> why does return Tip change the tip from a string to an int?
08:55:30 <mux> then he could have wrote  next = modify (+1)
08:55:40 <Cale> cheater: The new Tip could be any type
08:55:45 <Cale> Tip :: Tree a
08:56:00 <Cale> But yeah, we can't write...
08:56:09 <Cale> relabel' (x @ Tip) = return x
08:56:25 <Cale> because then x :: Tree a and not Tree Integer like we want
08:56:41 <cheater> ok
08:56:49 <cheater> so right now we have...
08:56:56 <cheater> relabel' Tip = return Tip
08:56:57 <Cale> relabel' :: Tree a -> State Integer (Tree Integer)
08:56:58 <cheater> cool
08:56:59 <Cale> relabel' Tip = return Tip
08:57:00 <cheater> let's go on
08:57:04 <Cale> okay
08:57:06 <Cale> so
08:57:13 <Cale> relabel' (Branch x l r)
08:57:33 <Cale> we want to first relabel the left subtree, then pick a label for the root, and then relabel the right subtree
08:57:54 <Cale> relabel' (Branch x l r) = do l' <- relabel' l; ...
08:58:06 <Cale> relabel' (Branch x l r) = do l' <- relabel' l; x' <- next; ...
08:58:21 <Cale> relabel' (Branch x l r) = do l' <- relabel' l; x' <- next; r' <- relabel' r; ...
08:58:36 <Cale> and then we want to return a Branch constructed from the new trees and root
08:58:46 <Cale> relabel' (Branch x l r) = do l' <- relabel' l; x' <- next; r' <- relabel' r; return (Branch x' l' r')
08:58:54 <cheater> sweet
08:58:59 <cheater> the do here is the IO monad right?
08:59:03 <Cale> no!
08:59:09 <Cale> It's the State Integer monad
08:59:15 <Cale> that we've been defining
08:59:23 <cheater> mhm
08:59:37 <Cale> So everything here is 100% pure
08:59:40 <Cale> no side effects :)
08:59:57 <Cale> Just a bunch of functions and parameter passing when you get down to it
08:59:57 <cheater> could this mean that with the State Integer monad the statements in the do notation could get reordered for optimization?
09:00:18 <Cale> Yeah, the evaluation doesn't necessarily occur in any particular order
09:00:19 <cheater> ok
09:00:25 <cheater> that's cool
09:00:36 <Cale> Except as required by things that depend on other things of course
09:00:41 <cheater> yeah
09:01:25 <cheater> nice.. nice
09:01:27 <Cale> So there's a distinction even here between evaluation order and execution order
09:01:35 <cheater> oh?
09:01:56 <Cale> (execution order being the order of the State s computations in our do blocks
09:01:58 <Cale> )
09:02:22 <Cale> It makes a difference whether we write:
09:02:26 <Cale> relabel' (Branch x l r) = do l' <- relabel' l; x' <- next; r' <- relabel' r; return (Branch x' l' r')
09:02:27 <Cale> or:
09:02:36 <Cale> relabel' (Branch x l r) = do x' <- next; l' <- relabel' l; r' <- relabel' r; return (Branch x' l' r')
09:02:40 <Cale> or:
09:02:53 <Cale> relabel' (Branch x l r) = do l' <- relabel' l; r' <- relabel' r; x' <- next; return (Branch x' l' r')
09:03:10 <Cale> The tree will be relabelled differently
09:03:15 <brisingr> logically
09:03:16 <Cale> But it has nothing to do with the order of evaluation
09:03:19 <cheater> is it because of the state being increased in different order?
09:03:26 <Cale> It's the order in which we chain the computations together
09:03:28 <Cale> yeah
09:03:42 <cheater> so if it has nothing to do with the order of eval
09:03:46 <cheater> then what does it have to do with?
09:04:20 <Cale> Evaluation means turning expressions into values
09:04:33 <Cale> It doesn't matter which order we do that in here, we end up with the same value
09:04:41 <brisingr> evaluation will always be bottom-to-top right?
09:04:54 <Cale> describing a computation from an initial state to some final state and resulting tree
09:05:01 <EvanR-work> brisingr: not with lazy evaluation
09:05:08 <Cale> brisingr: Outermost-first
09:05:13 <Cale> So top-to-bottom
09:05:21 <Cale> kinda
09:05:28 <brisingr> yeah, I meant bottom as in outermost
09:05:30 <cheater> alright so
09:05:32 <Cale> ah, okay
09:05:40 <cheater> we have this
09:05:46 <Cale> If your trees grow upwards like a combinatorialist's :)
09:05:48 <cheater> can we use the state monad without do notation?
09:05:57 <EvanR-work> yeah trees grow upside down in computer land
09:06:01 <Cale> Sure
09:06:06 <cheater> how do you do that?
09:06:10 <Cale> Though you'll clearly see why we want do-notation :)
09:06:21 <Cale> relabel' (Branch x l r) =
09:06:22 <cheater> ok let's have an example
09:06:29 <Cale>   relabel' l >>= \l' ->
09:06:38 <Cale>     next >>= \x' ->
09:06:39 <cheater> right
09:06:42 <cheater> so it just works with bind
09:06:47 <cheater> what about without using bind?
09:06:48 <Cale>       relabel' r >>= \r' ->
09:06:57 <cheater> i mean i can use the Maybe monad just by using return
09:06:59 <Cale>         return (Branch x' l' r')
09:07:15 <Cale> Uh... well, we have no way to chain our computations end to end then
09:07:24 <cheater> right
09:07:33 * hackagebot sundown 0.4 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.4 (FrancescoMazzoli)
09:07:34 <cheater> the maybe monad doesn't need chaining for day to day use
09:07:35 * hackagebot qudb 0.0.1 - Quite Useless DB  http://hackage.haskell.org/package/qudb-0.0.1 (JanStepien)
09:07:36 <Cale> We'd have to pull out the S dataconstructor, which is meant to be hidden
09:07:42 <Cale> It does though
09:07:55 <cheater> ?
09:08:02 <Cale> If you're using Maybe without >>=, then you're really just using Maybe and not the Maybe monad
09:08:18 <cheater> what's the difference
09:08:26 <EvanR-work> cheater: chaining Maybe is great ;)
09:08:29 <Cale> I mean, you're not really making use of the fact that the thing is a monad
09:09:15 <cheater> @redo x >>= f
09:09:16 <lambdabot> Maybe you meant: do read todo undo
09:09:17 <DukeDave> I'm trying to debug some FFI stuff with gdb, and someone in #gdb just suggested this:
09:09:17 <DukeDave> "No symbol table info available" means you do not have full debug info (typically DWARF).  Recompile it with -g (and neither -s nor strip anywhere).
09:09:20 <Cale> In general, we'll have a library, and there might be a monad instance, but if you're not using >>= or something which works on all monads with it, then you're not really using the fact that it's a monad.
09:09:23 <cheater> `redo x >>= f
09:09:28 <plathrop> This state stuff is dead interesting. But do we have to define State ourselves now in mtl-2.x? I was following LYAH and found State was missing...?
09:09:28 <cheater> how do you redo again?
09:09:32 <DukeDave> Does anyone know how to get this in to GHC?
09:09:42 <Cale> and sure, you can use return, but, meh, you don't really need to be using it in Maybe's case, you could just use Just.
09:10:02 <cheater> Cale: aha
09:10:07 <Cale> @do x >>= f
09:10:07 <lambdabot> do { a <- x; f a}
09:10:08 <cheater> Cale: ok right yeah
09:10:10 <brisingr> import Control.Monad.State?
09:10:12 <cheater> ahh ok
09:10:13 <Cale> plathrop: uhhh...
09:10:19 <Cale> plathrop: It shouldn't be missing
09:10:32 <cheater> ok then
09:10:39 <cheater> i think i got the state monad somewhat
09:10:53 <cheater> @src relabel
09:10:53 <lambdabot> Source not found. Sorry.
09:10:53 <Cale> okay, so let's finally return to how get and put are defined
09:10:57 <Cale> they're really pretty easy
09:11:00 <cheater> go on
09:11:02 <Cale> get :: State s s
09:11:09 <Cale> get = S (\s -> ...)
09:11:13 <plathrop> Cale: warning I am a total n00b. That said, when I import Control.Monad.State I don't have a State, just a StateT
09:11:15 <Cale> well, we only have one option :)
09:11:17 <Cale> get = S (\s -> (s,s))
09:11:29 <cheater> yrsh
09:11:29 <Cale> plathrop: Oh, really?
09:11:31 <cheater> yeah
09:11:36 <cheater> put is also trivial
09:11:57 <Cale> plathrop: It says  type State s = StateT s Identity
09:12:05 <cheater> S(\s \t -> (t, s))
09:12:08 <Cale> plathrop: So you won't have a State data constructor, I guess.
09:12:12 <cheater> or something?
09:12:14 <cheater> right?
09:12:16 <Cale> plathrop: But you'll have the type synonym
09:12:27 <plathrop> OH. I see. *facepalm*
09:12:29 <brisingr> put x = S (\x -> (s,x)) ?
09:12:30 <Cale> plathrop: Which is awkward as hell for learning, but whatever, I guess.
09:12:43 <brisingr> shit
09:12:44 <brisingr> no
09:12:48 <Cale> cheater, brisingr: not quite :)
09:12:53 <plathrop> Cale: Yeah, I'm totally in the learning phase, so that's why confused.
09:12:54 <cheater> Cale: what then?
09:12:55 <brisingr> put x = S (\s -> (s,x)) ?
09:12:56 <Cale> put :: s -> State s ()
09:13:02 <cheater> ah
09:13:04 <Cale> brisingr: that's return
09:13:33 <Cale> put s' = S (\s -> (s',())
09:13:41 <Cale> er, missed a )
09:13:52 <cheater> brisingr: put overwrites the old state, so the explicit parameter to put needs to be on the left side of the tuple inside S()
09:14:23 <cheater> Cale: nice
09:15:00 <EvanR-work> or put s' = S (\_ -> (s',()))
09:15:33 <Cale> So yeah, all that the State monad does is capture an old idiom of functional programming involving passing an additional parameter around, and give us some nice combinators for putting together computations like that
09:16:08 <EvanR-work> Cale: curiously, i never use it
09:16:08 <Cale> oh, and there was one more piece I'd intended for the tree example
09:16:20 <brisingr> so basically when we have a function that uses an additional parameter is a candidate for using state
09:16:21 <Cale> relabel t = runState (relabel' t) 0
09:16:33 <brisingr> like a blowup function (I know there are easier implementations)
09:16:42 <EvanR-work> brisingr: a function that takes current state and returns possibly modified state along with another result
09:16:57 <cheater> Cale: by saying old idiom are you implying there's a new, better idiom which replaces it?
09:16:59 <Cale> brisingr: Yeah, whenever it gets tedious to chain the state parameter around and you find yourself tupling it with the outputs of subcomputations
09:17:25 <Cale> cheater: No, just that it's been around in functional programming since people stopped mutating things :)
09:17:32 <cheater> ok
09:17:33 <cheater> :)
09:17:39 <plathrop> and using the State monad just buys us the "verbs" you've discussed? Or does it buy you not haing to explicitly pass around the state?
09:17:54 <Cale> This is secretly the same idiom, even though it looks different on the surface in the end
09:18:11 <Cale> plathrop: We don't have to explicitly pass around the state, because >>= does it for us
09:18:17 <plathrop> nice
09:18:19 <brisingr> so you can use state say, for an interactive fiction game
09:18:32 <Cale> You could, certainly
09:18:41 <cheater> cale
09:18:42 <plathrop> So we can right functions that 'pretend' there's no state, and the State Monad preserves the context for us.
09:18:45 <brisingr> and we can force a new state for debugging purposes
09:18:53 <Cale> Though often I'll just start off with the parameter passing
09:18:57 <cheater> Cale: "this is secretly the same idiom" < the same as what?
09:19:09 <plathrop> cheater: The same as parameter passing
09:19:10 <EvanR-work> brisingr: interactive is the issue there rather than statehood
09:19:13 <Cale> and only if I find myself tupling my state parameter with the result a lot will I consider using the State monad
09:19:25 <cheater> ah ok
09:19:40 <Cale> cheater: Yeah, it's secretly the same thing as parameter passing, though the do-blocks make it look a little like imperative code.
09:19:45 <cheater> yeah
09:19:48 <cheater> gotcha
09:19:51 <cheater> nice!
09:19:56 <plathrop> I find this particularly interesting as I just wrote a bunch of Python where I was constantly returning tuples of (result, state)
09:20:05 <brisingr> it seems a little cumbersome tho
09:20:07 <cheater> ok, if you still want, let's make a pause and then talk about a parser
09:20:08 <cheater> :)
09:20:36 <Cale> brisingr: Well, it's *sometimes* less cumbersome than the alternative, and part of the trick is knowing exactly when.
09:20:48 <alpounet> plathrop, then you have a nice use case for the State monad heh :)
09:20:55 <plathrop> alpounet: totally :-)
09:20:56 <Cale> But a good rule of thumb is that it's when you find yourself *returning* (state, value) pairs from things.
09:21:07 <brisingr> I see
09:21:32 <plathrop> So much of my Python code begs to be functional; so I decided to learn Haskell so I could write better functional code.
09:21:37 <EvanR-work> plathrop: note that State stuff cant have any side effects, which im guessing your python had all over the place ;)
09:21:59 <dylukes> State encompasses a few things you might use side effects for though, i.e, storing/loading.
09:22:02 <alpounet> plathrop, maybe you'll actually use Haskell rather than Python then
09:22:18 <EvanR-work> dylukes: not from disk
09:22:25 <dylukes> No, no, I know.
09:22:42 <dylukes> but for instance here
09:22:43 <dylukes> https://github.com/DylanLukes/CloudHaskell-OTP/blob/master/src/Remote/OTP/OTPProc.hs
09:22:46 <dylukes> line 33.
09:22:50 <dylukes> you can get pretty darn "imperative"
09:23:19 <Davorak> So I have cabal problem is someone has a moment.
09:23:25 <Davorak> > cabal install haddock
09:23:25 <Davorak> Resolving dependencies...
09:23:25 <Davorak> cabal: dependencies conflict: ghc-7.0.3 requires array ==0.3.0.3 however
09:23:26 <Davorak> array-0.3.0.3 was excluded because ghc-7.0.3 requires array ==0.3.0.2
09:23:26 <lambdabot>   Not in scope: `cabal'Not in scope: `install'Not in scope: `haddock'
09:23:53 <plathrop> EvanR-work: believe it or not, no. I try to keep my side effects limited and write small composable functions... sound familiar?
09:24:35 <plathrop> alpounet: Maybe. Most of the time I don't have a choice - I'm in operations engineering and generally have to use the "language of choice" for whatever company I'm with.
09:24:55 <Davorak> Obviously something is wrong ghc-7.0.3 should not require both array == 0.3.0.2 and array ==0.3.0.3
09:25:26 <alpounet> yeah plathrop I guess so...
09:26:25 <plathrop> alpounet: Still, nothing at all wrong with learning more :-)
09:26:35 <plathrop> I'm a little weird anyway since my first language was Common Lisp
09:26:53 <tsousa> i am doing the problem 9 in euler with this solution http://dpaste.com/623548/ what seems to be the problem? problem9 -> http://projecteuler.net/problem=9
09:26:54 <lambdabot> tsousa: You have 1 new message. '/msg lambdabot @messages' to read it.
09:27:21 <Cale> tsousa: The search order
09:27:38 <Cale> tsousa: c <- [2..] will never finish with 2, because there are infinitely many options for b and a
09:28:00 <tsousa> Cale, so how can i solve it?
09:28:03 <Cale> > [(a,b,c) | c <- [2..], b <- [2..], a <- [2..]]
09:28:03 <lambdabot>   [(2,2,2),(3,2,2),(4,2,2),(5,2,2),(6,2,2),(7,2,2),(8,2,2),(9,2,2),(10,2,2),(...
09:28:27 <Cale> well, pick the sum first
09:28:39 <Cale> We want a + b + c = 1000
09:28:42 <tsousa> Cale but i need an inifinite list because i dont know the numbers that i will need
09:28:49 <tsousa> Cale, yes
09:28:51 <Cale> So c can be at most 1000
09:29:15 <Cale> unless we're allowing b and a to be negative
09:29:22 <Cale> (which I assume we're not)
09:29:24 <brisingr> so to recap, the state processor's return takes a value and puts it in a State; so the fundamental monad question applies, if you have already a state and a function which takes a value and puts it into a state how do you feed it to it
09:29:40 <brisingr> so we define >>=
09:30:38 <tsousa> Cale, yes we do not negative values
09:30:57 <tsousa> i put 1000 in each a,b,c and the values still doesnt os output from ghci
09:31:08 <Cale> > [(a,b,c) | c <- [1..1000], b <- [1..1000-c], let a = 1000 - c - b]
09:31:08 <lambdabot>   [(998,1,1),(997,2,1),(996,3,1),(995,4,1),(994,5,1),(993,6,1),(992,7,1),(991...
09:31:25 <Cale> > [(a,b,c) | c <- [1..1000], b <- [1..1000-c], let a = 1000 - c - b, a^2 + b^2 == c^2]
09:31:28 <lambdabot>   [(375,200,425),(200,375,425),(0,500,500)]
09:31:33 <copumpkin> tsousa: 1000^3 is a big number
09:31:45 <hpc> > 1000 ** 3
09:31:46 <lambdabot>   1.0e9
09:31:46 <Cale> > [(a,b,c) | c <- [1..1000], b <- [1..1000-c], let a = 1000 - c - b, a > 0, a^2 + b^2 == c^2]
09:31:49 <lambdabot>   [(375,200,425),(200,375,425)]
09:32:45 <Cale> > [(a,b,c) | c <- [1..1000], b <- [1..1000-c], let a = 1000 - c - b, 0 < a, a < b, b < c, a^2 + b^2 == c^2]
09:32:47 <lambdabot>   [(200,375,425)]
09:33:31 <Cale> or...
09:34:10 <Cale> > [(a,b,c) | a <- [1..1000], b <- [a+1..1000], let c = 1000 - a - b, b < c, a^2 + b^2 == c^2]
09:34:11 <lambdabot>   [(200,375,425)]
09:35:03 <Cale> > [a*b*c | a <- [1..1000], b <- [a+1..1000], let c = 1000 - a - b, b < c, a^2 + b^2 == c^2]
09:35:05 <lambdabot>   [31875000]
09:35:14 <brisingr> [(a,b,c) | a <- [1..500], b <- [a..500], let c = 1000 - a - b, b < c, a^2 + b^2 == c^2]
09:35:38 <brisingr> > [(a,b,c) | a <- [1..500], b <- [a..500], let c = 1000 - a - b, b < c, a^2 + b^2 == c^2]
09:35:39 <lambdabot>   [(200,375,425)]
09:35:57 <brisingr> they can't be larger than half the sum
09:37:04 <Cale> Or we could always enumerate pythagorean triplets instead :)
09:37:27 <Cale> @let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)])
09:37:28 <lambdabot>  Defined.
09:37:57 <elliott> When implementing Foldable, what is the correct way to handle a fold on a sequence in the error state?
09:37:59 <Cale> @let pyth r = (x,y,z) where m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]
09:38:00 <lambdabot>  Defined.
09:38:06 <Cale> > map (pyth . (+1)) $ posRationals
09:38:07 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
09:38:08 <elliott> I have "end of sequence" and "failure" as separate elements in my data-type.
09:38:21 <elliott> Should I use "throw"? (There is a SomeException inside the failure.) Treat it the same as the end of sequence?
09:38:51 <Cale> > head [a * b * c | (a,b,c) <- map (pyth . (+1)) posRationals, a + b + c == 1000]
09:38:55 <monochrom> I don't think Foldable have failure in mind
09:38:55 <lambdabot>   mueval-core: Time limit exceeded
09:38:57 <Cale> aww
09:39:27 <elliott> monochrom: Actually, I just realised it's not a Foldable; the result would have to be in a monad. :/
09:39:31 <mux> m,n generators for pythagorean triples, mmm; Cale, you're doing PE again? :-)
09:39:45 <elliott> I don't suppose there's a Foldable variant that returns a monadic action instead? :-P
09:40:34 <raek> could one say that "IO a" is the same as "State World a", where World is the type of the state of the physical world?
09:41:00 <elliott> raek: Yes, but it's not a very good model; it doesn't really describe concurrency very well, for instance.
09:41:03 <monochrom> no, it is best to not think of State World
09:41:06 <Cale> raek: Yeah, though that's a really bad analogy
09:41:32 <hpc> doesn't GHC try to make IO look like that?
09:41:33 <elliott> raek: (Actually that is basically how IO is implemented in GHC, but even that is misleading: the "world" type gets eliminated to nothingness at runtime, so in reality it's just a strange way of expressing an impure function.)
09:41:37 <Cale> hrm, I wonder why that pythagorean triple generator is missing this one...
09:41:54 <elliott> hpc: I think the State# RealWorlds are only there to force evaluation order to the compiler.
09:42:02 <elliott> So that it doesn't optimise things wrongly, which a plain (a -> b) would.
09:42:04 <monochrom> GHC uses State World as a code-generation trick only
09:42:29 <saml> hey , when do I use monad and when do I use monoid or other typeclass?
09:42:38 <saml> monad's only benefit is do notation?
09:42:41 <mux> Cale: which one? IIRC, m,n generators only generate primitive triples
09:42:41 <elliott> saml: You use a monad when there is an implementation of its methods that fit the laws.
09:42:44 <elliott> You use monoid in the same case.
09:42:52 <elliott> Monads and monoids are not really comparable; indeed, their type arguments have different kinds.
09:43:02 <elliott> Monad takes a type function needing one type; Monoid takes a type.
09:43:10 <Cale> saml: You define a monad when you notice that you can.
09:43:12 <monochrom> the State and the World do not appear in the final machine code
09:43:27 <saml> oh i see. so it's just experience thingy
09:43:31 <DukeDave> Can anyone get the PDF: http://www.haskell.org/haskellwiki/Typeclassopedia    ?
09:43:42 <Cale> saml: Don't set out to define a monad or a monoid. Design your library how you want it to look, but notice when you can define instances of these things.
09:43:56 <saml> if you're experienced in haskell, is it easy to see when you want to instantiate a certain typeclass?
09:44:03 <hpc> saml: sometimes
09:44:03 <brisingr> saml: if you face yourself with the question "I have a function f that takes a value and puts it into something; and I already have a value into a something and want to pass it to f" then you want a monad
09:44:06 <mux> Cale: oh, I was wrong. it generates all primitive triples, but it still misses some. you need a slightly more complicated formula for that
09:44:07 <saml> or is it like OOP.. something hard to get it right the first time?
09:44:10 <Cale> saml: I'd say reasonably so.
09:44:20 <Cale> mux: ah, yeah, hmm...
09:44:23 <hpc> usually the instances will be obvious
09:44:39 <hpc> occasionally someone comes up with a freaky one like the FSA comonad
09:44:51 <mux> Cale: UAD trees is what I used myself if memory serves me.. which it rarely does
09:45:43 <Cale> I'm really starting to hate this google feature of automatically searching for something I didn't type instead.
09:46:06 <hpc> Cale: https://duckduckgo.com/
09:46:15 <ciaranm> it looks like you're trying to search for zygomorphic prepromorphisms. would you like me to help with that?
09:46:23 <hpc> Cale: the zero-click box at the top is incredible
09:46:28 <plathrop> Cale: +1000
09:46:42 <plathrop> "feature"
09:49:51 <dylukes> plathrop: very familiar
09:49:52 <dylukes> :P
09:52:35 <cheater> hey Cale
09:52:40 <cheater> wanna do that parser? :)
09:52:47 <elliott_> hpc: I've never heard of the FSA comonad; should I be scraed?
09:52:49 <Cale> okay
09:52:55 <brisingr> we're eyes and ears
09:52:55 <cheater> also
09:52:56 <cheater> Cale:
09:53:19 <cheater> is Cale pronounced similar to Kyle or similar to the city on the french side of the english channel?
09:53:42 <dylukes> I always just said "kale", like the vegetable.
09:53:42 <cheater> because i can't wrap my head around this :)
09:53:46 <Cale> It's pronounced the same way as the vegetable.
09:53:49 <hpc> elliott_: finite state machine
09:53:51 <plathrop> mmm... Kale
09:53:55 <hpc> er, automata
09:53:55 <cheater> so "cayl"?
09:53:58 <Collard> hi Kale
09:54:01 <Cale> yeah, I guess
09:54:02 <Collard> we're delicious
09:54:04 <cheater> or mail?
09:54:04 <cheater> ok
09:54:12 <plathrop> dylukes: lmao
09:54:12 <dylukes> rhymes with mail, yep.
09:54:13 <Cale> Like mail with a k
09:54:14 <plathrop> dylukes: good one
09:54:20 <cheater> cool :)
09:54:26 <cheater> now let's do the parser that you wanted :)
09:54:28 <Cale> Okay
09:54:28 <elliott__> hpc: ah
09:54:31 <cheater> i'm all ears
09:54:33 <hpc> there's a sigfpe post about it
09:55:05 <Cale> So a parser will take in a String, and will produce a list of parses, each consisting of a value along with a depleted string, that's had some of the beginning removed (based on what it managed to eat)
09:55:10 <Cale> So
09:55:23 <Cale> newtype Parser a = P (String -> [(String, a)])
09:55:34 <plathrop> All this talk of tasty veggies and string eating is making me hungry :-)
09:55:53 <cheater> ok
09:55:54 <Cale> "A parser for things is a function from Strings to lists of pairs of Strings and things"
09:56:17 <brisingr> so parser is like (heads &&& tails) just that it filters out based on a rule?
09:56:18 <Cale> So, similarly to how we had runState before...
09:56:24 <cheater> plathrop: i think string is dietetic
09:56:28 <Cale> runParser :: Parser a -> String -> [(String, a)]
09:56:44 <cheater> Cale: why do we want the strings?
09:56:49 <Cale> brisingr: and it changes the type of the inits
09:56:53 <cheater> the depleted ones..
09:57:02 <Cale> cheater: Because we might want to continue parsing
09:57:08 <RichardBarrell> cheater: so that you can chain parsers together.
09:57:10 <Cale> cheater: after the thing that we found
09:57:29 <brisingr> so it's like ((read heads) &&& tails)
09:57:31 <Cale> and yes, so that we can chain parsers together end-to-end to eat up multiple values from the string and do something with them
09:57:35 <brisingr> only read is a function we define
09:57:43 <Cale> brisingr: kinda, yes
09:57:49 <cheater> but isn't the fact that we get a list... of parsed things,, doesn't that mean each of those things, put together, would give us the whole string we put into thep arser?
09:57:51 * plathrop has vague thoughts of implementing lisp in haskell
09:57:57 <Cale> no
09:58:00 <plathrop> cheater: not necessarily
09:58:06 <cheater> why do we have a list then
09:58:07 <RichardBarrell> And there's a pretty nice Monad instance for the definition of Parser that Cale just gave, where (a >>= f) feeds the result of `a` and the remaining data from `a` into f.
09:58:08 <plathrop> cheater: gotta think recursive.
09:58:10 <cheater> what does that list mean
09:58:10 <Cale> The list is a list of possible ways of reading the string, in the case of ambiguity
09:58:15 <cheater> oh ok
09:58:16 <cheater> gotcha
09:58:19 <RichardBarrell> Yeah.
09:58:21 <cheater> i was missing that part Cale
09:58:23 <Cale> Each of the parses will eat some initial part of the string
09:58:28 <cheater> ok
09:58:31 <cheater> and then
09:58:37 <cheater> by using contradictions..
09:58:41 <cheater> we can eliminate alternatives
09:58:49 <RichardBarrell> Downside is that if you have lots of ambiguous parses, your parser will become very very slow. Oh well.
09:58:50 <Cale> Yeah, if a parser gives an empty list
09:58:59 <cheater> ok
09:59:13 <cheater> RichardBarrell: that's fine with me
09:59:35 <RichardBarrell> Exponential run-time is (almost) never fine.
09:59:37 <Cale> Yeah, this won't be terribly efficient... real parser libraries will want to do something to process options breadth-first to avoid hanging on to the initial segment of the input
09:59:47 <Cale> and eliminate bad options sooner
10:00:18 <cheater> yes ok
10:00:18 <Cale> But we're doing this in the easiest way possible, so it'll be depth-first :)
10:00:18 <cheater> i realize that
10:00:18 <cheater> ok let's go
10:00:34 <cheater> so we have what.. parse :: String -> [(String, a)]
10:00:36 <cheater> yes?
10:00:51 <Cale> runParser :: Parser a -> String -> [(String,a)]
10:00:55 <cheater> right ok sorry
10:00:58 <Cale> runParser (P f) s = f s
10:01:04 <cheater> we're writing a monad here
10:01:07 <Cale> yeah
10:01:15 <Cale> Well, we will :)
10:01:23 <Cale> The runParser isn't part of the monad structure
10:01:30 <cheater> k
10:01:35 <Cale> but there's an obvious analogy to the State monad we wrote before
10:01:37 <cheater> let's continue then :)
10:01:55 <Cale> So, we can also write some very basic parsers directly
10:02:17 <rostayob> Cale: you're a good guy
10:02:35 <cheater> yes he is, so don't troll him plz
10:02:41 <RichardBarrell> Cale++ :)
10:02:44 <rostayob> i wasn't trolling him, i'm serious
10:03:00 <rostayob> this is great education, #haskell is great
10:03:01 <Cale> char c = P (\s -> case s of (x:xs) | x == c -> [(xs,x)]; _ -> [])
10:03:08 <cheater> such expounding could be embarassing to anyone
10:03:15 <cheater> hoist your petard rostayob
10:03:19 <Cale> char :: Char -> Parser Char
10:03:31 <cheater> Cale: hmm
10:03:37 <Cale> char c is a parser which tries to match the single character c
10:03:42 <rostayob> cheater: what?
10:03:48 <Cale> If it finds it, then it returns that character
10:03:53 <rostayob> whatever ehe
10:03:59 <Cale> If it doesn't, then it produces an empty list of parses and fails
10:04:05 <plathrop> Cale: yeah, you are making this one of the most valuable channels I've ever seen. Mad props.
10:04:14 <elliott__> what those guys sai
10:04:15 <elliott__> d
10:04:35 <Cale> Actually, we could save this parser for later once we have another way to write it, but I think it'll probably be good to write some simple ones by hand before tackling the monad instance
10:04:45 <Cale> We could also have:
10:05:04 <cheater> Cale: so if we have a (parser 'x') and have "xxxx" then we get something like ['x', 'x', 'x', 'x'] right?
10:05:06 <cheater> in the end
10:05:10 <cheater> after our monad has been run
10:05:14 <Cale> uhhh...
10:05:19 <cheater> well yeah i realize
10:05:24 <cheater> it'd be a tree instead probably
10:05:28 <cheater> but something-like-that?
10:05:38 <brisingr> Cale, do we have something like ["x", "xx", "xxx", "xxxx"]
10:05:38 <Cale> runParser (char 'x') "xxxx" = [("xxx",'x')]
10:05:53 <cheater> right
10:05:59 <cheater> but if we have parsed the whole string..
10:06:14 <cheater> then the right sides of runParser outputs will just be four separate instances if 'x'
10:06:18 <Cale> Well, we'll have a combinator...
10:06:21 <cheater> of 'x'
10:06:25 <Cale> many :: Parser a -> Parser [a]
10:06:30 <Cale> and it'll be the case that
10:07:03 <Cale> runParser (many (char 'x')) "xxxx" = [("","xxxx"), ("x","xxx"), ...]
10:07:20 <Cale> greediest first
10:07:38 <cheater> right ok
10:07:51 <cheater> what if we had our parser just evaluate to 1 if it encountered its digit?
10:08:12 <Cale> Well, let's do:
10:08:32 <cheater> then we'd have runParser (many (char 'x')) "xxxx" = [("", [1,1,1,1]), ("x", [1,1,1]), ...] right?
10:08:39 <Cale> oh, yes
10:08:49 <cheater> ok right cool :)
10:08:51 <Cale> We can also generalise char
10:08:59 <cheater> yes
10:09:02 <cheater> with what it should return
10:09:04 <Cale> satisfy :: (Char -> Bool) -> Parser Char
10:09:11 <cheater> oh
10:09:23 <Cale> This will succeed on characters which satify the predicate, and fail on those who don't.
10:09:23 <cheater> what would that do?
10:09:27 <cheater> ah
10:09:34 <cheater> right!
10:09:39 <cheater> i misread the type
10:09:42 <cheater> but now it's clear
10:09:52 <Cale> satisfy p = P (\s -> case s of (x:xs) | p x -> [(xs, x)]; _ -> [])
10:10:03 <cheater> yep simple
10:10:05 <Cale> and then  char c = satisfy (== c)
10:10:19 <cheater> right ok!
10:10:30 <Cale> but we can also write things like   digit = satisfy isDigit
10:10:48 <Cale> and then once we have many, we'll be able to use  many digit  to match lots of digits
10:11:00 <cheater> if we tried running our parser on a string which contains non-digits it would fail, right?
10:11:08 <cheater> and return a non-eaten string starting the first non-digit
10:11:12 <brisingr> so essentially it's like a filter, but it matches all combinations and also keeps the discards
10:11:16 <Cale> It'll just produce an empty list of parses
10:11:35 <Cale> Well... actually, with many, it'll always succeed with the 0 eaten case
10:11:50 <Cale> there'll also be many1 which ensures we eat at least one
10:12:16 <Cale> Let's define the monad stuff now :)
10:12:32 <Cale> So, return v will be a parser which "does nothing, except result in v"
10:12:44 <Cale> which in this case will mean that it doesn't eat any of the input string
10:13:02 <Cale> return v = P (\s -> [(s,v)])
10:13:45 <brisingr> looks similar to State, but it keeps all possibilities
10:14:06 <Cale> yeah... it's actually really similar to StateT [], but let's not worry about that for now :)
10:14:33 <cheater> mhm
10:14:35 <Cale> and for (>>=), we need to keep track of all the possibilities, so we'll be using a list comprehension
10:14:36 <brisingr> :)
10:14:38 <cheater> return is simple here
10:14:41 <Cale> yeah
10:14:45 <Cale> return is usually pretty simple
10:14:48 <Cale> in most monads
10:14:53 <cheater> alright
10:15:04 <Cale> p >>= f = P (\s -> ...)
10:15:05 <cheater> so now bind :)
10:15:13 <Cale> so now we want to run p on s
10:15:29 <Cale> p >>= f = P (\s -> ... runParser p s ... )
10:15:49 <Cale> and for each possible depleted string s' and result v
10:15:57 <Cale> we want to run f v on s'
10:16:02 <Cale> So...
10:16:30 <Cale> p >>= f = P (\s -> [... | (s',v) <- runParser p s; (s'',w) <- runParser (f v) s'] )
10:16:37 <cheater> o interesting
10:16:47 <cheater> this would allow us to nest blocks and stuff right?
10:16:48 <Cale> We'll use a list comprehension to keep track of all the possibilities for us
10:16:53 <cheater> and have "levels"
10:17:04 <cheater> like eg indentation levels in python.
10:17:04 <dylukes> Ah, one question
10:17:08 <Cale> um, sorta
10:17:14 <dylukes> if I'm writing a library and I have a single "include everything" file that reexports,
10:17:31 <dylukes> how can I suppress the "Warning: the import of ... is redundant" warnings.
10:17:40 <Cale> and so the results of our chained together parser will be the (s'',w)
10:17:49 <Cale> p >>= f = P (\s -> [(s'',w) | (s',v) <- runParser p s; (s'',w) <- runParser (f v) s'] )
10:17:50 <hpc> dylukes: by removing redundant imports
10:18:00 <dylukes> hpc: No I mean, say my library is Foo
10:18:04 <dylukes> and I have Foo.X and Foo.Y
10:18:11 <dylukes> and I want Foo.hs to export everything from X and Y
10:18:20 <dylukes> (er, lets say its Control.Foo, w/e)
10:18:28 <Cale> dylukes: yeah, if you're importing Foo, then don't also import Foo.X
10:18:34 <Cale> because Foo already is exporting that
10:18:37 <dylukes> no... thats not what I mean.
10:18:55 <dylukes> say my library is Control.Foo
10:19:04 <dylukes> and theres Control.Foo.Bar and Control.Foo.Baz
10:19:10 <mauke> can I see some actual code?
10:19:11 <dylukes> I want users to just be able to import Control.Foo and get everything else
10:19:29 <dylukes> module Control.Foo where \n import Control.Foo.Bar \n import Control.Foo.Baz
10:19:32 <Cale> dylukes: Yeah, I don't understand why you're getting such warnings if you're not doing that
10:19:32 <dylukes> should be that simple
10:19:45 <hpc> dylukes: it isn't; you need to re-export the modules
10:20:00 <hpc> module Foo (module Foo.Bar, module Foo.Baz) where import ...
10:20:04 <cheater> Cale: wait, how did bind look for the state monad again?
10:20:10 <dylukes> hpc: mmk thanks
10:20:15 <Cale> cheater: So what p >>= f does is that it uses p to parse the initial part of the string, and then lets f decide which parser to parse the rest of the string with, based on the result of p
10:20:20 <monochrom> module Control.Foo(module Control.Foo.Bar, module Control.Foo.Baz) where
10:20:23 <cheater> Cale: for comparison
10:20:47 <brisingr> so >>= binds the parser to all possible results
10:20:53 <Cale> cheater: x >>= f = S (\s -> let (s',v) = runState x s; (s'',w) = runState (f v) s' in (s'',w))
10:20:54 <brisingr> so in a way it also parses middle values
10:20:58 <cheater> Cale: yeah, that part is clear to me that f decides what parser to use next
10:21:13 <cheater> Cale: ok wait let me compare the two
10:21:20 <Cale> p >>= f = P (\s -> [(s'',w) | (s',v) <- runParser p s; (s'',w) <- runParser (f v) s'] )
10:21:23 <brisingr> but only if it makes sense to do so (i.e. the beginnings are correctly parsed)
10:21:53 <Cale> (It's almost identical, except that we have a list comprehension now!)
10:23:19 <cheater> exce
10:23:31 <tsousa> thinking in haskell is hard
10:23:43 <cheater> except it's really that both will look the same in do notation right Cale?
10:23:45 <cheater> i think they will
10:24:04 <Cale> brisingr: yes
10:25:02 <Cale> cheater: well, there's a way in which both are the same. It turns out we can separate out a "State monad transformer", which when applied to the Identity monad gives us (something isomorphic to) State, and when applied to the list monad (and then specialised to strings) gives us Parser
10:25:26 <Cale> If you'd like, I can go over that :)
10:25:49 <brisingr> abstract abstract monads iz eating ur cake
10:25:50 <Cale> do-notation for the Identity monad is more or less the same thing as 'let'
10:26:04 <Cale> and do-notation for the list monad is the same thing as list comprehensions
10:26:34 <hpc> and do-notation for IO is the same thing as a burrito?
10:26:34 <BlankVerse> running a yesod demo app , i get the error : "devel.hs: socket: unsupported operation (Address family not supported by protocol)
10:26:45 <cheater> Cale: interesting
10:27:17 <cheater> p >>= f = P (\s -> do (s', v) <- runParser p s; runParser (f v) s')
10:27:20 <cheater> is that correct?
10:27:25 <Cale> cheater: So that can be an expedient way to define these things if we want. But people often get way too caught up on monad transformers, so I don't like to emphasise them all that much
10:27:30 <ohwow> Has anyone read this book? http://homepages.cwi.nl/~jve/HR/ Could it be used as a textbook for learning Haskell?
10:27:38 <Cale> cheater: yeah
10:27:44 <cheater> and...
10:27:45 <Cale> that do block is in the list monad noe
10:27:46 <Cale> now*
10:27:49 <cheater> x >>= f = S (\s -> do (s',v) <- runState x s; runState (f v) s')
10:27:54 <cheater> is that also correct?
10:27:59 <cheater> because those two are *the same*
10:28:01 <Cale> and that one would sorta be in the identity monad
10:28:18 <Cale> though there you have to do a little lifting to make the types work out
10:28:31 <cheater> oh?
10:28:37 <cheater> why wouldn't it work?
10:28:47 <Cale> Well, you can't actually write a monad instance where (>>=) :: a -> (a -> b) -> b
10:28:53 <earthy> ohwow: you *could*, but it'd be a roundabout way
10:29:07 <Cale> because there's just got to be a type constructor there
10:29:12 <Cale> We can however define
10:29:18 <Cale> newtype Identity a = I a
10:29:19 <ohwow> hm
10:29:26 <ohwow> earthy: and what's the correct way?
10:29:27 <Cale> and then define a monad instance for that
10:29:27 <Cale> where
10:29:45 <Cale> (>>=) :: Identity a -> (a -> Identity b) -> Identity b
10:29:49 <earthy> http://learnyouahaskell.com/
10:29:52 <Cale> which is more or less the same thing
10:29:55 <ohwow> Learn YOu a Haskell?
10:29:56 <ohwow> ah
10:29:59 <Cale> but requires us to do a little bit of wrapping
10:30:51 <Cale> So mathematically, what you wrote is fine, but the Haskell type system doesn't have a true type-level identity function which we can write a Monad instance for
10:31:23 <cheater> aha!
10:31:25 <cheater> alright
10:31:37 <ohwow> earthy: well, you see, I have a Scheme background, so I don't want to read about functional programming over and over again. Can you recommend me anything else based on this info?
10:31:40 <cheater> ok, let's skip this for now and get back to our parser :)
10:31:42 <Cale> yeah
10:32:06 <Cale> So, we also can have:
10:32:09 <hpc> ohwow: there's a tutorial on the wiki where you write a scheme interpreter
10:32:15 <Cale> zero :: P (\s -> [])
10:32:21 <Cale> A parser which always fails
10:32:40 <Cale> and then in terms of that...
10:32:55 <brisingr> hmm, does that mean parsers can be monoids too?
10:32:56 <Cale> guard b = if b then return () else zero
10:33:03 <Cale> brisingr: indeed...
10:33:09 <Cale> Let's do that too!
10:33:12 <Cale> p +++ q
10:33:14 <cheater> ok so we have the constructor for now... and zero and guard... what else do we have?
10:33:24 <Cale> will be a parser which parses its input with both p and q and returns all possible results
10:33:29 <Cale> concatenated together
10:33:41 <Cale> p +++ q :: Parser a -> Parser a -> Parser a
10:33:51 <brisingr> yeah
10:33:58 <Cale> p +++ q = P (\s -> runParser p s ++ runParser q s)
10:34:01 <brisingr> and it's trivial to show that it has zero as identity
10:34:07 <ohwow> hpc: yeah, I saw, but it's hardly a textbook
10:34:15 <Antre> Ehm, a question, can you add several operation in a guard? like c=a+b a=b b=c
10:34:44 <Cale> Antre: guards are supposed to be boolean values, and you can do whatever you want to produce a boolean result
10:35:02 <Cale> Antre: So you can write  and [c == a + b, a == b, b == c]
10:35:03 <copumpkin> guards are allowed to be any match now
10:35:05 <copumpkin> as of h2010
10:35:06 <copumpkin> :)
10:35:07 <ohwow> "The purpose of this book is to teach logic and mathematical reasoning in practice,
10:35:07 <ohwow> and to connect logical reasoning with computer programming. The programming
10:35:08 <ohwow> language that will be our tool for this is Haskell, a member of the Lisp family."
10:35:11 <ohwow> :S
10:35:23 <copumpkin> ohwow: what book is that?
10:35:23 <Cale> ohwow: WTF
10:35:29 <Cale> ROFL
10:35:33 <brisingr> Cale: so what we have above is actually an isomorphism between List and Parser?
10:35:34 <copumpkin> I seem to remember someone linking that before
10:35:42 <Cale> brisingr: um, not quite...
10:35:46 <cheater> hahaha
10:35:51 <Cale> brisingr: They're not entirely unrelated either
10:35:51 <cheater> haskell a member of the list family
10:36:07 <cheater> Cale: ok so let's recap.. what do we have right now?
10:36:10 <brisingr> Cale: I don't quite understand
10:36:15 <monochrom> that's The Haskell Road to Logic, Math, etc
10:36:16 <ohwow> copumpkin: http://homepages.cwi.nl/~jve/HR/
10:36:25 <brisingr> we have zero which has an equivalence with []
10:36:29 <ohwow> that's quite puzzling
10:36:35 <brisingr> and +++ which has an equivalence with ++
10:36:38 <copumpkin> ouch
10:36:40 <brisingr> maybe I said it wrong
10:36:41 <hpc> there's a question about that book on SO, and the consensus was that the author was dividing languages into FORTRAN and everything-else
10:36:43 <Antre> Cale: I meant somet hing like "| i > `0660_ c=a+b a=b b=c count (i-1) a b"
10:36:56 <Cale> brisingr: Well, they're analogous, but not exactly equivalent, in that you can't just turn any list into a parser
10:37:01 <Antre> well, that didn't turn out right
10:37:08 <Cale> in a way which makes sense for +++ / ++
10:37:15 <Cale> though...
10:37:25 <brisingr> Cale: so it's not surjective
10:37:32 <Cale> we could do something funny to get an embedding of [] into Parser
10:37:33 <copumpkin> what's even more WTF
10:37:39 <Cale> but Parser definitely has more structure
10:37:42 <copumpkin> is that two of the reviews on that page repeat the same thing
10:37:47 <copumpkin> about haskell being part of the lisp family
10:37:56 <Cale> Antre: I have no idea what that code is intended to mean
10:38:15 <Antre> Ah sorry, gimme a min
10:38:16 <copumpkin> Antre: that looks almost like agda, honestly
10:38:17 <brisingr> we have two big code families: the lisp family and the brainf*ck family
10:38:50 <Antre> I started out with Haskell today. ^^;
10:38:58 <Cale> Yeah, I guess if Haskell either had to be in the Lisp family or the Brainfuck family, it would be closer to Lisp :)
10:39:07 <Veinor> dons's 'plugging haskell in' papers seem to have been lost: http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
10:39:14 <Cale> (though it's probably more of a brainfuck than brainfuck)
10:39:47 <ohwow> So, last time I checked, `Real World Haskell' was the main textbook (besides learnyouahaskell), is the situation still the same?
10:40:09 <Cale> ohwow: Pretty much. You may also want to check out the Wikibook and "Yet Another Haskell Tutorial"
10:40:13 <shachaf> "the main textbook" for what?
10:40:19 <Cale> shachaf: Learning Haskell
10:40:22 <shachaf> As long as you're reading books, there are several other good ones.
10:40:30 <Antre> http://codepaste.net/o4eno7 Well there is the whole code snippet, I'm still trying to learn Haskell, I don't know how all of the syntax works now
10:40:31 <shachaf> _Programming in Haskell_, for instance.
10:40:38 <Antre> I'm more used to prolog honestly
10:40:41 <shachaf> The reason people recommend those two is that they're available online for free.
10:40:55 <brisingr> you can use learnyouahaskell and skip all the "think functionally" stuff
10:41:06 <Cale> Antre: what does c = a + b mean. Do you mean c == a + b?
10:41:16 <Cale> Antre: Or are you intending to define c?
10:41:25 <Antre> What I tried to do what use a temp variable
10:41:44 <Antre> so yeah define c
10:41:46 <Cale> Antre: Variables in Haskell don't refer to cells whose value can be changed. They refer to values.
10:41:53 <Cale> So when c = 5, say
10:42:13 <Cale> You can't "update" c
10:42:23 <Cale> c is just another name for the value 5
10:42:36 <Antre> ah that explains things
10:42:48 <cheater> but you can shadow
10:42:49 <cheater> with let
10:43:03 <Cale> yeah, but it's not usually a good idea to do that :)
10:43:08 <cheater> check out my tutorial here: http://cheater.posterous.com/first-haskell-script
10:43:31 <Antre> will do
10:43:40 <cheater> it explains that bit exactly
10:43:41 <cheater> :)
10:43:55 <cheater> Cale: wanna continue on the parser?
10:43:58 <Cale> sure
10:44:03 <cheater> i think we both got a bit sidetracked
10:44:05 <cheater> where are we?
10:44:11 <cheater> we have a constructor P()
10:44:17 <Cale> So, now we can rewrite satisfy in terms of anyChar and guard
10:44:17 <cheater> and we have bind and return
10:44:19 <brisingr> we defined return and >>=
10:44:21 <Cale> and our monad instance
10:44:23 <cheater> and we have guard and zero
10:44:26 <brisingr> and zero, guard
10:44:26 <Cale> and +++
10:44:35 <Cale> So...
10:44:38 <cheater> and +++ yes ok
10:44:47 <Cale> satisfy p = c <- anyChar; guard (p c)
10:44:49 <Cale> er
10:44:50 <cheater> what is satisfy?
10:44:51 <Cale> satisfy p = do c <- anyChar; guard (p c)
10:45:00 <Cale> satisfy :: (Char -> Bool) -> Parser Char
10:45:10 <shachaf> <Cale> INSERT COIN TO CONTINUE
10:45:24 <Cale> shachaf: lol
10:45:32 <ghosting> 0 CREDITS
10:45:35 <Cale> was a parser which succeeded in eating a character (returning it), if it satisfies the predicate
10:45:38 * cheater pushes a nickel into Cale's ear
10:45:45 <brisingr> @trollcoins Cale 5000
10:45:45 <lambdabot> Unknown command, try @list
10:45:46 <Cale> and fails otherwise
10:45:52 <cheater> hmm
10:45:57 <cheater> right ok
10:46:01 <cheater> yes i remember
10:46:10 <Cale> So that we could write things like   digit = satisfy isDigit
10:46:11 <cheater> what is anyChar?
10:46:34 <Cale> anyChar = P (\s -> case s of (x:xs) -> [(xs,x)]; [] -> [])
10:46:54 <ohwow> hm, well, which book has better excersises: LYAH or Real World Haskell?
10:47:00 <Cale> It eats any character from the beginning of the string.
10:47:03 <cheater> ok wait
10:47:08 <cheater> what did guard do again?
10:47:18 <Cale> guard b = if b then return (); else zero
10:47:23 <Cale> er, lol
10:47:25 <Cale> guard b = if b then return () else zero
10:47:35 <Cale> the funny thing is that the semicolon there is now valid
10:47:39 <Cale> hehe
10:47:47 <cheater> hm
10:48:10 <Cale> (but don't put it there, it's an ugly hack they put into H2010 to allow people to indent if/then/else incorrectly in do-blocks)
10:48:23 <cheater> satisfy p = do c <- anyChar; guard (p c)
10:48:24 <cheater> hm
10:48:32 <Cale> so
10:48:36 <cheater> wait a sec
10:48:48 <Cale> oh, oops
10:48:57 <Cale> satisfy p = do c <- anyChar; guard (p c); return c
10:48:58 <cheater> that satisfy doesn't look right
10:49:04 <Cale> there, now it's right
10:49:04 <cheater> hmm
10:49:10 <knoc> hello, what does ?? mean in combination with data types?
10:49:10 <knoc> `Thief' is not applied to enough type arguments
10:49:11 <knoc> Expected kind `??', but `Thief' has kind `* -> *'
10:49:15 <cheater> you sure?
10:49:20 <mrcarrot> ohwow: LYAH is not having any exercises at all (which is a pity for a good book)
10:49:24 <Cale> knoc: It's more or less the same as *
10:49:31 <Cale> knoc: but also allows for unboxed types
10:49:56 <knoc> Cale: ok
10:49:59 <cheater> what does the guard in that do actually accomplish?
10:50:24 <shachaf> knoc: It means you're using Thief as the type of a value.
10:50:24 <brisingr> check for matches
10:50:40 <Cale> knoc: http://stackoverflow.com/questions/3034264/haskell-weird-kinds/3034295#3034295
10:50:40 <shachaf> knoc: Which is like using Maybe as the type of a value -- it doesn't make sense, because Thief takes an argument.
10:50:53 <shachaf> @quote unsafe.*argument
10:50:53 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
10:51:13 <Cale> cheater: let's expand its definition
10:51:19 <cheater> Cale: alright
10:51:23 <Cale> satisfy p = do c <- anyChar; if (p c) then return () else zero; return c
10:51:35 <Cale> So if p c is true, we run return (), which is a no-op
10:51:49 <Cale> (doesn't eat any characters from the string, returns a single result ())
10:51:59 <cheater> what if p c is false?
10:52:07 <Cale> but if it fails, our list of parses from zero will be []
10:52:22 <Cale> which will mean that the list of parses for the whole thing will be []
10:52:40 <cheater> why does it actually change the state of our string?
10:52:46 <Cale> It may help to imagine that we're binding the result of this computation:
10:52:51 <cheater> does zero exit the do block?
10:52:56 <Cale> satisfy p = do c <- anyChar; k <- (if (p c) then return () else zero); return c
10:53:23 <cheater> yeah still not sure how k is getting used anywhere at all
10:53:25 <Cale> zero just produces an empty list of parses, which will effectively cut off that branch of the computation, because there will be nothing to choose for 'k' there
10:53:36 <Cale> (remember the list comprehensions...)
10:53:40 <cheater> ah
10:53:41 <Cale> It's similar to how...
10:53:43 <brisingr> at first I understood, now I don't, anymore
10:53:48 <cheater> right the <- is like a nested foreach
10:54:07 <Cale> > [x | x <- [1..10], y <- if even x then [()] else []]
10:54:08 <lambdabot>   [2,4,6,8,10]
10:54:20 <Cale> > [x | x <- [1..10], y <- if even x then [(),()] else []]
10:54:21 <lambdabot>   [2,2,4,4,6,6,8,8,10,10]
10:54:24 <cheater> right no need to explain, i understand why the zero there works
10:54:31 <brisingr> oohh
10:54:37 <Cale> hopefully brisingr now understands again too :)
10:54:48 <brisingr> so it's like a filterM
10:54:54 <brisingr> similar but not quite the same
10:55:14 <Cale> kinda, in a way -- it's the list monad doing its thing :)
10:55:24 <DanBurton> for the former it's more idiomatic to do just [x | x<- [1..10], even x]
10:55:29 <Cale> right
10:55:37 <Cale> but in fact we can even write:
10:55:48 <Cale> > [x | x <- [1..10], y <- guard (even x)]
10:55:49 <lambdabot>   [2,4,6,8,10]
10:55:51 <Cale> ;)
10:55:56 <Cale> But this is a more generic guard
10:56:06 <Cale> Defined for any MonadPlus
10:56:32 <Cale> MonadPlus is a class for things with a zero (which it calls mzero) and (+++) (which it calls mplus)
10:56:33 <brisingr> so we defined guard there only for didactic purposes
10:56:38 <Cale> yeah
10:58:32 <Cale> OT: If anyone here is a fan of Kashiwa Daisuke, listening to Stella from "Program Music I" is a different experience once you've listened to Scorpion of Red Eyes from "88". :)
10:58:50 <brisingr> so guard p = if p then return () else mzero, at the general
10:58:55 <Cale> yeah
10:59:36 <Cale> So, we can probably do many now :)
10:59:47 <Cale> many :: Parser a -> Parser [a]
11:00:21 <Cale> many p = (do v <- p; vs <- many p; return (v:vs)) +++ return []
11:00:51 <brisingr> so satisfy is to many as head is to heads
11:01:00 <Cale> heads?
11:01:14 <brisingr> there's no heads?
11:01:18 <Cale> inits?
11:01:23 <Cale> > inits [1..10]
11:01:24 <brisingr> yeah inits
11:01:25 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
11:01:25 <brisingr> sorry
11:01:31 <Cale> Well, hmm...
11:01:40 <Cale> I'm not sure how to compare them
11:01:57 <brisingr> so satisfy is to many as head is to inits
11:02:01 <brisingr> would be more accurate
11:02:18 <brisingr> satisfy takes one
11:02:19 <Cale> p is to head what many p is to inits
11:02:26 <Cale> head doesn't take a predicate
11:02:29 <brisingr> yeah
11:02:29 <mercury^> satisfy is to many as head is to id.
11:02:30 <brisingr> right
11:02:33 <Cale> So it's not really analogous to satisfy
11:02:58 <brisingr> what I was trying to point out is that many also takes zero
11:03:01 <Cale> We can define a lot of the basic parsers in terms of each other
11:03:22 <Cale> We defined satisfy in terms of anyChar and guard
11:03:38 <Cale> but we could also define anyChar in terms of satisfy, if that was primitive
11:03:46 <Cale> anyChar = satisfy (const True)
11:04:16 <Cale> We can make a parser to match balanced parentheses
11:04:43 <copumpkin> rwbarton :(
11:04:51 <cheater> can you define many without using +++ ?
11:05:05 <brisingr> Cale: that makes me think about state, in the sense of counting parantheses
11:05:12 <Cale> cheater: only if we use P, or maybe some other primitives we haven't talked about
11:05:19 <Cale> parens = (do char '('; parens; char ')'; parens) +++ return ()
11:05:46 <cheater> i'm lost
11:05:46 <Cale> This is a parser which matches strings of balanced parentheses, like "(()(())())()"
11:06:14 <Cale> okay
11:06:18 <brisingr> Cale: so we can intercalate any char like
11:06:22 <Cale> So this says...
11:06:35 <Cale> To match a string of balanced parens means either:
11:07:08 <Cale> 1) matching a '(' followed by a string of balanced parens, followed by ')', followed by another string of balanced parens
11:07:22 <brisingr> parens = (do char '('; many (const True); parens; char ')'; parens) +++ return () ?
11:07:29 <Cale> 2) succeeding without matching anything
11:07:54 <brisingr> is many (const True) correct?
11:07:56 <Cale> brisingr: hmm, if you want to put other characters inside the parens...
11:07:59 <brisingr> yes
11:08:00 <Cale> er
11:08:01 <Cale> no
11:08:06 <Cale> const True isn't a parser
11:08:08 * cheater grumbles that Cale does too much at once :) and is thus difficult to follow
11:08:12 <Cale> So you can't apply many to it
11:08:26 <brisingr> okay so
11:08:40 <Cale> cheater: okay, maybe a simpler example...
11:08:41 <brisingr> many anyChar?
11:08:50 <Cale> brisingr: yeah, that would work
11:09:10 <Cale> brisingr: though perhaps you want many (satisfy (notElem "()"))
11:09:20 <brisingr> right
11:09:51 <brisingr> my main problem with Haskell is that I know what I want but in terms of an analogy, so it's never the correct type
11:09:57 <cheater> Cale: it's not about the difficulty of the things you say to me, it's about the spatial and temporal distance between separate inputs from you :)
11:09:59 <Cale> cheater: Do you know about 'sequence'
11:09:59 <Cale> ?
11:10:08 <Cale> cheater: :)
11:10:11 <cheater> refresh me please
11:10:18 <DanBurton> @src sequence
11:10:21 <Cale> sequence :: (Monad m) => [m a] -> m [a]
11:10:27 <Cale> sequence [] = return []
11:10:40 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:10:42 <hpc> Calebot is running unusually slow today
11:10:46 <cheater> but i think we'd make it with the parser if we kinda.. just concentrated on that until we're done ;)
11:10:47 <DanBurton> :(
11:10:57 <Cale> So with parsers
11:11:07 <Cale> sequence takes a list of parsers
11:11:12 <cheater> right with parsers a list of parsers goes to a parser of lists?
11:11:23 <cheater> so to speak
11:11:24 <Cale> and makes a parser which runs each of them in turn, getting a list of the results
11:11:35 <cheater> mhm
11:11:42 <Cale> So, a parser for the concatenation of that list of parsers
11:11:44 <cheater> yes
11:12:06 <Cale> string s = sequence (map char s)
11:12:20 <Cale> will be a parser which tries to match each character of a whole string
11:12:31 <Cale> (exactly)
11:12:57 <Cale> So,  string "bob"  is a parser which succeeds if and only if the start of the string it's given is "bob"
11:13:11 <Cale> and it eats that part, returning it
11:13:22 <brisingr> essentially it's sequencing ;)
11:13:41 <Cale> We actually also have a name for sequence (map f x)
11:13:43 <cheater> hmmmmmmmmmmmmmmm
11:13:49 <Cale> mapM f x = sequence (map f x)
11:13:58 <cheater> wait a sec
11:14:04 <cheater> let me think about this quickly
11:14:08 <Cale> Or:  forM x f = mapM f x
11:14:50 <Cale> forM is essentially a for-each loop
11:14:56 <Cale> We could write
11:15:15 <Cale> string s = forM s $ \c -> char c
11:15:27 <Cale> which reads like  "foreach c in s { char c }"
11:16:04 <Cale> except that it's defined as a library function and not built into the language, and it works on things which aren't IO actions, like these parsers :)
11:17:19 <brisingr> @pl \s -> forM s $ \c -> char c
11:17:30 <cheater> <Cale> and makes a parser which runs each of them in turn, getting a list of the results < so chains those parsers, and gets the final results, if the're not empty (because a "zero" happened)?
11:17:52 <brisingr> lambdabot is dead again
11:18:09 <Cale> cheater: If a zero happens, it essentially backtracks
11:18:39 <brisingr> @pl \s -> forM s $ \c -> char c
11:18:44 <lambdabot> flip forM char
11:18:54 <Cale> Or just  mapM char
11:18:55 <elliott__> \c -> char c == char :P ...well, most of the time
11:19:08 <elliott__> ===, not ==
11:19:13 <Cale> But I wanted the excess syntax :)
11:19:27 <elliott__> yeah I was saying to brisingr
11:19:43 <cheater> Cale: gotcha ok
11:19:53 <xil> hello. If I define a class with a function for an element -- something like "data A = A {funcA :: [a] -> a}" -- and if I make a whole bunch of instances of this class, maybe in a list or something, and give them all the same function for "funcA", then will Haskell store copies of that function, one for each instance, or just one that it references lazily? I know it'll all be lazy but I'm wondering how it work =/
11:19:57 <parcs> does anyone know of a library that implements peano naturals?
11:19:59 <cheater> Cale: ok i understand "string s"
11:20:11 <Cale> xil: That's not what we'd call a class
11:20:24 <parcs> there's peano-inf but it sux (quotRem isn't defined ???)
11:20:29 <Cale> xil: classes in Haskell are something else (they're not types)
11:20:47 <Cale> xil: but no, it'll only have pointers to the same thing in memory
11:20:56 <xil> Cale: my bad. I thought type and class were interchangable. I presume that a class is a typeclass in haskell?
11:20:58 <monochrom> there is also "nat"
11:21:05 <xil> Cale: also, thanks, that's what I was hoping
11:21:08 <elliott__> parcs: http://hackage.haskell.org/package/naturals ?
11:21:14 <elliott__> searching for nat is probably better than peano
11:21:14 <Cale> xil: Except that if you actually write out the same definition over and over again, it won't discover that
11:21:26 <Cale> xil: It'll make multiple copies in that case
11:21:44 <Cale> Only if you use the same variable in multiple places will it share the value between them
11:21:58 <elliott__> oh, naturals looks bad
11:22:03 <elliott__> not peano-based
11:22:50 <ohwow> Why do you need Data.Natural for?
11:23:11 <ohwow> I am just curious, why can't you use builtin type? :O
11:23:14 <saml> what is Data.Natural?
11:23:33 <saml> it's not in http://www.haskell.org/ghc/docs/latest/html/libraries/   so you don't need it
11:24:01 <saml> you mean Data.NaturalNumber ?
11:24:06 <cheater> <Cale> many p = (do v <- p; vs <- many p; return (v:vs)) +++ return []
11:24:19 <cheater> shouldn't that be: many p = (do v <- p; vs <- many v; return (v:vs)) +++ return []          ?
11:24:32 <zygoloid> no
11:24:50 <hpaste> “md2perpe+hpaste@gmail.com” annotated “numerical typing... bluh” with “numerical typing... bluh (annotation)” at http://hpaste.org/51858#a51928
11:24:56 <cheater> why not?
11:25:15 <zygoloid> proximally, that would be a type error
11:25:46 <cheater> what does <- p do?
11:25:55 <cheater> does it "eat up" part of our string that we are parsing?
11:26:18 <tac-tics> <- p tries to parse the rest of the string using the rule p
11:26:28 <cheater> right yes
11:26:29 <cheater> ok
11:26:44 <cheater> that's why we recurse with our p
11:26:55 <monochrom> you want a recursive call to many p, so it's vs <- many p
11:26:57 <cheater> whereas the string is implicitly passed on in its changed form
11:27:12 <cheater> ok
11:27:14 <cheater> makes sense
11:28:32 <brisingr> man imagine all those pseudocode guys seeing "x <- y" and saying "haskell is easy" only to discover that <- does all sorts of weird stuff like launching rockets
11:29:11 <xil> Cale: so if I did something like this http://www.pasteall.org/25281/haskell, then each element of the list returned from modifyList would reference myFunction, not have a copy of it?
11:29:24 <cheater> ok right
11:29:28 <cheater> what's next guys?
11:29:34 * cheater eyes Cale :)
11:29:38 <monochrom> actually, pseudocode guys think that launching rockets is easy, too
11:29:58 <cheater> launchRocket()
11:30:04 <brisingr> nono
11:30:09 <brisingr> launch rocket!!!
11:30:32 * monochrom has C's "x = launchrocket()" and even "x = y++" in mind
11:31:10 <tac-tics> launchRocket :: IO ()
11:31:47 <yrlnry> I have more than once been asked in Perl classes if Perl has a generalized undo or rollback feature.
11:31:49 <tac-tics> @type launchRocket
11:32:01 <lambdabot> IO ()
11:32:05 <tac-tics> :P
11:32:58 <elliott__> yrlnry: that would be convenient
11:33:15 <brisingr> launchRocket :: IO () -- actually means Initialize Offensive ()
11:33:25 <Cale> xil: yeah, it won't consume any more memory
11:33:35 <Cale> xil: but semantically, there's no way for you to tell anyway
11:33:43 <yrlnry> launchRocket should be an IO Bool, to lte you know whether it was successful.
11:33:52 <yrlnry> Or an IO Something other than (), anyway.
11:34:08 <xil> Cale: so I can't necessarily be sure all the time, but most likely Haskell will be smart about that kind of stuff?
11:34:12 <Cale> xil: since things aren't mutable, if two things are equal as values, they're essentially indistinguishable
11:34:16 <Cale> xil: yeah
11:34:17 <tac-tics> brisingr: LaunchCode c => c -> Country -> IO NuclearWar
11:34:25 <Cale> xil: You can mostly just trust the compiler.
11:34:32 <xil> Cale: okay thanks =]
11:34:33 <yrlnry> elliott__:  I always think " I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question."
11:36:00 <Cale> cheater: I have to go do some other things now, but we can go on with more of it later, or you may want to check out libraries like ReadP and Parsec
11:36:22 <plathrop> Cale: thanks for the education even though I only understood a smidgen
11:36:24 <EvanR-work> yrlnry: IO Bool to tell you whether it was successful, what was successful, that it destroyed the target sufficiently? ;)
11:36:33 <cheater> ok Cale
11:36:37 <shachaf> yrlnry: I'm pretty sure launchRocket :: forall a. IO a
11:36:38 <cheater> does Parsec do something like this?
11:36:42 * plathrop goes back to trying to get the LYAH random state example to work
11:36:44 <cheater> or does it do something more involved
11:36:52 * tac-tics thinks all monad tutorials should be launchMissiles tutorials
11:37:07 <cheater> because it would be cool to have a lib that does this parser thing in this "naiive way" what we described
11:37:24 <brisingr> so to conclude the parser lesson, we wrote all that abstract sh*t so we can write win = (do char '('; string "win"; win; string "win"; char ')'; win) +++ return ()
11:37:51 <brisingr> and not bother how it actually happens
11:38:07 <brisingr> yeah, and thanks a lot Cale :)
11:38:08 <cheater> anyway thanks a lot Cale! that was very cool, maybe we can go on later, i'm thrilled how that will work
11:38:31 <brisingr> one day we'll repay you :)
11:39:48 <elliott__> So wait, launchRocket returns? Is this system on the rocket?
11:40:02 <elliott__> Is it encased in an invincible shell or something?
11:40:10 <brisingr> you can just return rocket once it's done
11:40:43 <cheater> most projectiles belong to the person firing them
11:40:54 <cheater> it's only obvious to return property to the rightful owner
11:40:57 <yrlnry> Perhaps it should be IO Bool, and return twice, returning IO True on the rocket, and IO False on the launch system.
11:41:07 <shachaf> launchRocket :: IO RocketId
11:41:21 <shachaf> Better: launchRocket :: STM ()
11:42:06 <saml> good morning my friend
11:43:02 <tac-tics> shachaf: agreed. That way, you can launch your missiles to demonstrate your hostility, then "check" on the ransom money/political demands
11:43:12 <tac-tics> Then rollback once those demands are met
11:43:22 <elliott__> tac-tics: Neutrino missiles!
11:43:24 <shachaf> ...That's not how STM works.
11:43:43 <elliott__> shachaf: Sure it is. If it can launch a rocket, it can undo that launch.
11:44:00 <shachaf> elliott__: Right, but then the demands-being-met would also be undone.
11:44:19 <elliott__> shachaf: Hmm. You could just tell them what you simulated and get the demands met without actually firing them.
11:44:38 <elliott__> If they disagreed, launch a rocket again, undo it, and show them what happens to countries that refuse to give based on STM evidence :)
11:44:45 <elliott__> Repeat until they're convinced.
11:45:40 <shachaf> elliott__: I don't think that has anything to do much with STM at that point.
11:46:05 <elliott__> shachaf: I'm sorry that you want to operate in a way less cool universe.
11:48:36 <EvanR-work> yrlnry: basically any value that supposedly has meaning on the future effect on that io action is going to be misleading
11:49:14 <EvanR-work> if there was an IO failure in executing the action, then there should be an exception
11:49:42 <EvanR-work> beyond that effects are 'fire and forget' ;)
12:01:17 <boegel> is it frowned upon to announce (major version) releases of packages on Haskell reddit next to haskell-cafe@?
12:01:34 <boegel> to be honest, I've never used reddit before (to post stuff)
12:01:36 <dylukes> boegel: where does south park image go
12:01:44 <dylukes> boegel: Should I give those to you
12:01:48 <Cale> boegel: You can submit whatever you want to reddit
12:02:03 <Cale> If people don't like it, they'll just downvote, but package releases are probably fine
12:03:10 <boegel> dylukes: yes, mail it to me (kenneth dot hoste @ googlesmailthingie)
12:03:18 <boegel> Cale: mmhk
12:03:21 <dylukes> kenneth.hoste@gmail.com?
12:03:24 * boegel goes for it
12:03:28 <boegel> dylukes: urgh, yes
12:03:35 <dylukes> why so urgh
12:05:30 <DanBurton> there's a reason people obfuscate their email
12:05:39 <DanBurton> it's so that web scrapers don't pick it up in the logs and spam you
12:06:15 <copumpkin> dylukes: you think he was just doing that to be difficult? :P
12:06:30 <dylukes> >.<
12:06:35 <dylukes> Sorry.
12:06:37 <dylukes> Now I know.
12:06:44 <DanBurton> I wonder if tunes.org provides a way to audit your logs
12:08:16 <dylukes> boegel: isn't it already on your hackage packages though?
12:08:24 <dylukes> as well as any mailing lists... etc
12:08:38 <dylukes> DanBurton: I think its a fruitless effort
12:09:02 <DanBurton> dylukes: I concur; I usually just throw my email around and bank on google's magical spam-blocking powers
12:09:10 <dylukes> :P
12:09:30 <boegel> dylukes: it is, it's no secret :)
12:09:42 <dylukes> kenneth.hoste@gmail.com
12:09:43 <dylukes> kenneth.hoste@gmail.com
12:09:44 <dylukes> kenneth.hoste@gmail.com
12:09:45 <dylukes> ;)
12:10:27 <boegel> dylukes: hey, I'm coming for you if someone will try to sell Viagra to me
12:10:45 <dylukes> 1990's web technique. Make your page background 1pt font looped text of a bunch of buzzwords. Remove all spacing so it looks like solid black.
12:11:03 <dylukes> Add flashing text on top for coolness. Spinning babies optional.
12:11:05 * DanBurton wonders why we don't host #haskell logs on our haskell.org server
12:14:37 <elliott__> DanBurton: clog is quite traditional
12:14:52 <elliott__> it logs a lot of big-ish programming channels
12:15:16 <monochrom> it also has a 20-minute-skewed clock :)
12:15:42 <elliott__> monochrom: I think that's some kind of DST
12:15:44 <parcs> clog: hai
12:15:47 <elliott__> it changes sometime through the year
12:16:14 <elliott__> ... I'm not saying clog is good, it logs way less than it should, and that timezone problem is great because if the channel is silent for about an hour it can actually be impossible to tell whether a line is pre- or post- switchover
12:16:17 <elliott__> just that it's traditional :P
12:16:38 <monochrom> I strongly believe it is a clock skew.
12:17:01 <elliott__> Is it present in all months of the year?
12:17:02 <DanBurton> new project: write a bot to listen in on #haskell and log everything that is said.
12:17:25 <elliott__> DanBurton: Why not just get an existing log bot to do it? It can be quite a tricky problem, especially w/ redundancy.
12:17:39 <elliott__> monochrom: You could email Faré, I believe he administrates the machine
12:18:02 <DanBurton> elliott__: because it's obviously a trivial problem with Haskell at our disposal
12:18:10 <elliott__> DanBurton: heh
12:18:20 <monochrom> hmm, it is a 4-minute skew today
12:22:24 <DanBurton> @hackage irc
12:22:25 <lambdabot> http://hackage.haskell.org/package/irc
12:22:49 <monochrom> it was a 21-minute skew in February
12:24:47 <monochrom> a 15-minute skew on May 27
12:25:53 <monochrom> now I really want to know a time zone that's x hours y minutes away from EDT, where y can be 4, 15, or 21 depending on months
12:26:29 <elliott__> there's a nice open-source logbot on a channel I'm on after clog left us for like a whole week... it needs the ops to invite it though
12:30:20 <monochrom> I have op. do I qualify? on the other hand, I don't know what other ops think.
12:30:41 <monochrom> or even whether it matters
12:30:53 <elliott__> monochrom: Nah, it only works for ops not named monochrom.
12:31:11 <monochrom> cool! then I don't have to do anything :)
12:31:20 <elliott__> well, I've quite liked it because it offers raw IRC logs, uses UTC and has nice formatted logs :P
12:31:22 <elliott__> but clog is alright
12:35:13 <elliott__> monochrom: for the record though it's /invite glogbot and an example formatted log would be http://codu.org/logs/log/_ai/2011-09-27... I don't have any problem with clog though, I just wish they didn't break all the links to pre-2011 logs
12:38:19 <Tordek> I'm trying to write a parser for tnetstrings (tnetstrings.org), but I'm stuck: a tnetstring may contain a lists of tnetstrings: e.g: "8:1:a,1:b,]" would be ["a", "b"]. Since I need to fetch the contents of the list before parsing it, how do I tell parsec "try to parse this string"? This is what I have so far: http://pastebin.com/jrhS2Q23
12:38:21 <mauke> The paste jrhS2Q23 has been copied to http://hpaste.org/51930
12:38:59 * EvanR-work scratches head, fetch contents of the list before parsing it?
12:40:35 <elliott__> EvanR-work: "Tnetstrings put the length at the beginning and the type at the end so that you have to read all of the data element and cannot "stream" it.
12:40:36 <elliott__> "
12:40:49 <elliott__> seems like he Tordek to try and parse the rest of the thing to know whether it's a list or not and then get the elements
12:40:51 <elliott__> what a terrible format
12:41:03 <Veinor> tordek?
12:41:09 <Tordek> Veinor?
12:41:13 <elliott__> <Tordek> I'm trying to write a parser for tnetstrings (tnetstrings.org), but I'm stuck: a tnetstring may contain a lists of tnetstrings: e.g: "8:1:a,1:b,]" would be ["a", "b"]. Since I need to fetch the contents of the list before parsing it, how do I tell parsec "try to parse this string"? This is what I have so far: http://pastebin.com/jrhS2Q23
12:41:13 <mauke> The paste jrhS2Q23 has been copied to http://hpaste.org/51930
12:41:17 <elliott__> tordek.
12:41:21 <Veinor> ah
12:41:26 <EvanR-work> *tordek*
12:41:31 <elliott__> oh, "he Tordek to try"
12:41:37 <elliott__> very grammatical of me
12:41:47 * Tordek has so much yellow on his screen now
12:43:44 <Veinor> Tordek: hmm
12:44:57 <Veinor> option x p tries to apply p and returns what p parses if it succeeds, x if it fails
12:45:28 <Tordek> Veinor: I thought of it, but it sounds terribly inefficient (I may be wrong, though)
12:46:06 <Veinor> so what i'd do is, i'd write a parser that can parse things like "1:a,1:b"
12:46:09 <elliott__> Tordek: You don't want to use Parsec for this.
12:46:26 <elliott__> Since you have to read from both the head and tail of the tnetstring to parse any part of it, Parsec doesn't really fit at all, because this grammar is terrible
12:46:42 <elliott__> You should write a manual function to do it with a structure with good end access like ByteString or Seq
12:46:42 <Tordek> (btw: I'm doing "do return (S contents)"; is there a better way?)
12:46:59 <Veinor> the do is redundant
12:47:00 <elliott__> Tordek: drop the do
12:47:12 <Veinor> decodeContents ',' = return . S
12:47:26 <elliott__> That won't work.
12:47:32 <elliott__> All decodeContents' clause would then have to be point-free.
12:47:35 <elliott__> clauses
12:47:39 <Veinor> oh true
12:47:55 <Tordek> cool, thanks
12:48:23 <elliott__> Tordek: but yeah, Parsec will be inefficient for this
12:48:31 <Veinor> elliott__: i'm not convinced that that's the case here
12:48:35 <elliott__> as will any parser combinator library really: they're all going to assume you have less than arbitrary lookup
12:48:37 <elliott__> erm lookahead
12:48:44 <Veinor> or if it is, that that matters
12:48:49 <elliott__> Veinor: really? you have to look at the head to determine the length, then look at the tail to determine the type, then recurse
12:48:58 <elliott__> parser combinator libraries don't have operations for "tail of the string being parsed"
12:49:11 <elliott__> and the interpretation of what's between the two is entirely dependent on the tail
12:49:27 <elliott__> sure, it'll be possible to hack this into working with Parsec... but it'll just be inefficient and won't help the clarity much either
12:49:50 <Veinor> possibly
12:50:05 <Veinor> it might be the case that the typical tnetstring is short enough that that won't matter
12:50:18 <elliott__> Sure, it might not be slow in an absolute sense... but then what does using Parsec buy you?
12:50:30 <elliott__> You basically have to "gobble up N bytes, gobble a byte, check that byte, parse the N bytes according to that byte"
12:50:38 <elliott__> I guess you could like nest "parse" calls
12:50:48 <elliott__> but it seems a lot harder than just doing it with bytestrings and plain old recursion
12:50:52 <Veinor> yeah, just have your parser be recursive
12:51:02 <Veinor> also wow the reference python implementation is bad
12:51:16 <elliott__> it's not so much recursive as "parse p ...", which is just weird to use inside a parser, and you'll have to like make sure any errors propagate
12:51:24 <Tordek> how is it bad, Veinor?
12:51:49 <elliott__> since it's length-prefixed and everything, there seems to be no reason not to basically just do it manually... I mean, the point of these binary protocols is meant to be that they're simple enough not to use a proper "parser"
12:52:19 <elliott__> ...doesn't seem like a very good format though :)
12:52:20 <Tordek> elliott__: yeah, I was just trying to learn Parsec; guess it's not a good format for that, then
12:52:43 <Veinor> elliott__: amusingly the reference implementation suffers from a ~similar problem
12:52:57 <elliott__> Tordek: yeah, I'd use something like a configuration file format or simple expression language to learn Parsec
12:53:10 <Veinor> anyway, it's bad because a lot of the elif chains could be replaced by a lookup table
12:53:40 <elliott__> "type(x) is T", "data == None"... I guess whoever made this protocol isn't very good at Python
12:53:51 <Veinor> lookups = {"#" : int, "}" : parse_dict, "]" : parse_list, ...}; value = lookups[payload_type](payload)
12:54:29 <Veinor> also a lot of asserts instead of actual proper exceptions
12:55:02 <Tordek> elliott__: Zed's logic behind the format (we repeatefly tried to convince him to do <size> <type> <data> <comma>) was "you'll still need to get the whole data in-memory before trying to figure out what to do with it, and if the separator is always the same (namely, :), it'd be faster to search for it"
12:55:15 <elliott__> zed as in zed shaw?
12:55:20 <elliott__> I guess that would explain why it's terrible
12:55:25 <Tordek> name's on the site, yep
12:55:31 <elliott__> oh, it is? I tried to find one but couldn't
12:55:43 <elliott__> "Zed" and "Shaw" definitely do not appear on http://tnetstrings.org/
12:55:48 <Veinor> yeah, i don't see it
12:56:10 <Tordek> hmm, odd, thought it was
12:56:15 <Tordek> what with it being zed
12:56:18 <elliott__> Tordek: I get that it's trying to enforce doing everything in-memory, even though that's ridiculous (of course you can operate on recursive structures without loading all of them at once: that's what a filesystem is, a nested map), but it just makes parsing more awkward for a silly goal
12:58:15 <EvanR-work> seems like theres no benefit, just detriments, over putting that bit thats at the end at the beginning, keeping everything else the same
12:59:34 <monochrom> consider it a good puzzle :)
13:00:17 <EvanR-work> this isnt a game, this is real life!
13:05:50 <hpaste> tgeeky pasted “why is my stack overflow?” at http://hpaste.org/51932
13:06:26 <tgeeky> can a smartypants look at http://hpaste.org/51932 ^^ and help a brother out?
13:07:16 <elliott__> wow, some excessive spacing there
13:07:37 <elliott__> my professional opinion is that you need some strictness somewhere, probably in a loop, but don't have it :P
13:07:41 <tgeeky> elliott__: it's an internal formatting
13:07:54 <monochrom> this is very long. can you shorten it, and still be self-contained (I can load it myself without error), and still overflows?
13:08:01 <tgeeky> elliott__: (and anyone else) -- this code is typed out verbatim from Bird's book
13:08:17 <elliott__> Bird needs some more strictness.
13:08:19 <tgeeky> monochrom: you can load it without error
13:08:28 <elliott__> tgeeky: but it's not shorter than itself :P
13:08:31 <monochrom> or else, please enjoy my http://www.vex.net/~trebla/haskell/lazy.xhtml and see common modes of stack overflow
13:08:40 <MarkDBlackwell> In WinGHCi (on Windows), I have two modules (A dependent on B) in two directories scattered in my filesystem. Can I load A without B physically placed in the right place, with a folder shortcut or something?
13:09:24 <MarkDBlackwell> oops, I tried to type B followed by ')'  -- so, A dependent on B
13:10:04 <MarkDBlackwell> Sorry, it showed as an emoticon in my IRC client.
13:10:05 <tgeeky> if one is looking at my paste, the only function that matters, is the last copy of 'mkExprs'
13:10:12 <tgeeky> in particular, the 'comb' function
13:10:14 <tgeeky> is the one that's broken
13:10:46 <MarkDBlackwell> I get 'Could not find module'.
13:11:06 <elliott__> MarkDBlackwell: :set -ifoo
13:11:15 <elliott__> where foo is the directory, relative to where winghci is
13:11:27 <elliott__> um as in
13:11:30 <elliott__> where the winghci is cd'd to
13:11:45 <elliott__> not sure how you can get ghci to tell you where that is. but just use an absolute path.
13:12:22 <MarkDBlackwell> Elliott__, thanks; I can load each module, but the dependencies are not resolved; not sure I am understanding you.
13:12:45 <elliott__> MarkDBlackwell: Well, what module does it fail to load?
13:12:59 <elliott__> Can you http://hpaste.org/new what appears in WinGHCi when you try to load?
13:13:20 <MarkDBlackwell> elliott__, sorry, you're right; it fails to load
13:13:22 <MarkDBlackwell> A
13:13:46 <elliott__> MarkDBlackwell: right. so where's A?
13:13:56 <elliott__> do :set -i<directory A is in>
13:15:01 <MarkDBlackwell> :set -iC:\Documents and Settings\Mark\My Documents\develop\GitHub\MarkDBlackwell\euler-problems-haskell\EulerProblems\Eight
13:15:07 <MarkDBlackwell> Oops
13:15:42 <elliott__> MarkDBlackwell: You'll need quotes.
13:15:44 <elliott__> around the directory path
13:15:58 <MarkDBlackwell> Double quotes?
13:16:30 <elliott__> Sure.
13:18:41 <MarkDBlackwell> :set -i"C:/Doc ... gives me <no location info>: Settings/Mark/My  Starting GHCi
13:19:21 <elliott__> did you already execute the previous set?
13:19:24 <elliott__> I'd restart winghci
13:20:52 <MarkDBlackwell> I have restarted WinGHCi. I see I can do :? in it.
13:28:06 <MarkDBlackwell> I do get the error from spaces in the string, even in a freshly loaded WinGHCi as the first command. I should admit it is old: Haskell Platform 2010.2.0.0.
13:30:37 <MarkDBlackwell> Thanks to your tip, I now can do :set -v and get the list
13:30:47 <elliott__> I'd just :cd there tbh
13:32:41 <MarkDBlackwell> I can :cd to either directory and load programs from them, but without physically placing the directory containing B, can I tell Haskell to look elsewhere? Sorry to be repeating. Is there a load path?
13:32:47 <MarkDBlackwell> list?
13:33:38 <elliott__> yes
13:33:41 <elliott__> you change it with -i
13:33:45 <elliott__> used in ghci like :set -ipath:path:...
13:33:46 <elliott__> like I said :P
13:39:29 <dungbeatle> newb to haskell
13:39:45 <dungbeatle> noober newb
13:39:45 <MarkDBlackwell> I am sure you are right, but to be frank, I don't feel resolved yet, because my mind is boggled and I got a slew of error messages.
13:40:09 <dungbeatle> No I AM
13:40:12 <dungbeatle> LOL
13:42:43 <Cale> MarkDBlackwell: What's up?
13:42:52 <Cale> All questions welcome :)
13:43:22 <MarkDBlackwell> Thanks, slow because writing/typing; no worries yes, I am a newby
13:45:39 <elliott__> dungbeatle: what
13:45:44 <elliott__> oh I see
13:46:04 <dungbeatle> Q:  Are there any commercial apps written in Haskell that we would recognize
13:46:35 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
13:46:36 <elliott__> dungbeatle: no, but lots of behind-the-scenes stuff
13:46:44 <dungbeatle> Thanks
13:46:48 <elliott__> unless Cryptol or something counts :P
13:48:14 <bos> @src span
13:48:14 <lambdabot> span _ xs@[]                     =  (xs, xs)
13:48:15 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
13:48:15 <lambdabot>                   | otherwise    =  ([],xs)
13:48:24 <Cale> dungbeatle: I'm working with iPwn Studios on an iPhone game in Haskell right now :)
13:48:28 <bos> @src group
13:48:28 <lambdabot> group = groupBy (==)
13:48:33 <bos> @src groupBy
13:48:34 <lambdabot> groupBy _  []       =  []
13:48:34 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
13:48:34 <lambdabot>     where (ys,zs) = span (eq x) xs
13:48:38 <Cale> dungbeatle: It's not released yet, but we're making good progress :)
13:48:57 <MarkDBlackwell> Just chatting (names changed): Under directory AA I have a directory A containing file A.hs, which contains module AA.A and references module BB.B. If, into directory A, I place directory BB containing file B.hs which contains module BB.B, it works: WinGHCi finds the two modules okay. Now, I will try the suggestion of -set -i"path" to add to the load path.
13:50:09 <dungbeatle> Cale:  Thanks for the info that sounds facinating
13:50:25 <MarkDBlackwell> I should be able, working minimally, to move directory BB up one level from directory A up to directory AA,
13:50:46 <MarkDBlackwell> then do :set -i".." and it should work, or something like that
13:51:06 <saadam> is it possible to make quickCheck only generate numbers between x and y for a specific property?
13:51:54 <MarkDBlackwell> After :set -i".." , :set -v doesn't seem any different.
13:52:27 <dibblego> >> quickCheck $ \x y -> (x >= 0 && x <= 100) ==> x + y == y + x
13:52:27 <dibblego> +++ OK, passed 100 tests.
13:52:38 <dibblego> saadam: that's one way, another is to write your own Arbitrary
13:53:09 <ddarius> @check \x y -> (x > 100000 && x < 100100) ==> x + y == y + x
13:53:09 <lambdabot>   No instance for (Test.QuickCheck.Testable
13:53:09 <lambdabot>                     (Test.QuickCh...
13:53:10 <MarkDBlackwell> and :load "A.hs" give error message, "Could not find module `BB.B':"
13:53:16 <kmc> \v -> let vv = v `mod` (y-x) + x in ...
13:53:34 <saadam> the first way you show isn't really working, quickCheck gives up after finding only ~10 testcases
13:53:36 <MarkDBlackwell> Maybe its my old Haskell.Platform version, I am thinking.
13:53:45 <dungbeatle> Q: I have RTFL(license)  but wanted to make sure there are no restrictions to commercial use
13:54:09 <kmc> dungbeatle, restrictions on what?
13:54:16 <kmc> also, you don't need to prefix every question with "Q: "
13:54:27 <ddarius> kmc: The other question would be "license for what?"
13:54:38 <kmc> yeah, we'll get to that
13:54:40 <shachaf> It's customary to use a '?' at the end of a question to indicate that it's a question.
13:55:06 <dungbeatle> Thanks for the protocl lesson
13:55:57 <shachaf> Certainly.
13:56:12 <ddarius> shachaf: Really?
13:56:12 <shachaf> Did the license say anything about restrictions to commercial use?
13:56:35 <shachaf> ddarius: Whatever Unicode character that was, it didn't get through.
13:56:38 <dungbeatle> I write interface applications and I am currently investigating using Haskell.  I sell my apps.  Is that permissible under the Haskell License
13:56:43 <dungbeatle> ?
13:56:43 * shachaf wonders if it was his IRC client.
13:56:49 <shachaf> dungbeatle: What's the Haskell License?
13:56:53 <kmc> dungbeatle, Haskell is not a piece of software
13:57:11 * monochrom hasn't seen a "Haskell license"
13:57:15 <dungbeatle> http://haskell.org/ghc/license
13:57:23 <kmc> that's the license on GHC, not Haskell
13:57:25 <monochrom> that's GHC's license
13:57:30 <dungbeatle> My bad
13:57:31 <kmc> Haskell is a standard language defined by a spec
13:57:36 <dungbeatle> Ok on the GHC
13:57:37 <kmc> GHC is the most popular implementation of that language
13:57:44 <shachaf> Are you planning to redistribute GHC?
13:57:45 <kmc> yes, you can use GHC for commercial apps
13:57:49 <kmc> there are many examples of this
13:57:50 <shachaf> Well, I guess you redistribute parts of it.
13:58:02 <monochrom> and since you're reading it already, you are free to judge what it allows. I am not a lawyer, I wouldn't want to be responsible for interpreting it
13:58:27 <dungbeatle> Thanks for the info
13:58:38 <dungbeatle> and sorry for the confusion
13:58:38 <kmc> dungbeatle, all of the libraries that come with GHC are BSD-licensed, I believe
13:58:53 <kmc> (but integer-gmp links to the C library libgmp, which is LGPL licensed)
13:59:01 <dungbeatle> I already Plead NOOB when I first signed on
13:59:06 <kmc> (you can disable that and use integer-simple, if you don't need good performance on bignum integers)
13:59:11 <kmc> dungbeatle, individual libraries you get off Hackage can have any license
13:59:15 <zygoloid> there are companies who sell and distribute commercial software compiled with GHC
13:59:18 <kmc> most of them don't place any restriction on commercial use
13:59:39 <antihoax> yes they are the cool dudes
13:59:54 <antihoax> selling an exe file
14:00:48 <dungbeatle> I have works under BSD so I very clear with that.  I will need to reserch any 3rdP Libs on a per case basis.
14:00:54 <kmc> yeah
14:01:20 <dungbeatle> Sorry for the terrible spelling
14:01:37 <antihoax> no problem we cant read
14:01:42 <dungbeatle> Thanks all
14:05:06 <tromp> > 902/8
14:05:07 <lambdabot>   112.75
14:14:09 <tromp> > 893/8
14:14:10 <lambdabot>   111.625
14:16:24 <MarkDBlackwell> elliott__, thanks, when I moved my minimal filesystem subtree down to the filesystem root (C:\) your suggestion worked well. Thanks again!
14:18:51 <elliott__> MarkDBlackwell: great :)
14:19:16 <elliott__> MarkDBlackwell: i think it just doesn't like spaces.
14:19:21 <johnfn> in haskell, i find myself wanting to translate the imperative pattern of loop with some state over the loop, but the only way i've found is recursion with a ton of args, which seems sloppy
14:19:47 <monochrom> you can traverse a list instead
14:19:47 <kmc> why so many args?
14:20:01 <elliott__> johnfn: it's better to refactor your program... but you can try mapM_ in the state monad
14:20:32 <incluye> @unpl ((.)$(.))
14:20:32 <lambdabot> (\ b c e f -> b c (e f))
14:21:09 <shachaf> kmc: Presumably one way to translate an imperative procedure with mutation to a recursive function is to pass the state of every variable along recursively on each mutation, as well as some arguments saying where the control was at the time.
14:21:25 <johnfn> simple example i just ran into: i want to make a template engine, so i need to "remember" the nested tags i'm in, oh and the current level of indentation, and the current result...
14:22:35 <johnfn> because the idea is to build up the result as i do a pass through the template file, but that means i need to remember all that other stuff
14:22:35 <elliott__> johnfn: either use a state monad to make it more modular, or factor it out so you don't have to track these things intrinsically
14:22:40 <elliott__> and can build them on top modularly
14:22:54 <elliott__> don't ask me how to do that, it depends very strongly on your individual code's situation :P
14:24:21 <MarkDBlackwell> elliott__, It fails with spaces even when I use double-quotes. I think that eventually double-quotes need to be passed to the Windows win32 API, so perhaps I should upgrade my Haskell.Platform, or try including double-quote characters inside the string. I did that, like "\"abc\"", which I can do by itself and get the correct result ("abc") but it still fails in the :set -i command. I think I...
14:24:23 <MarkDBlackwell> ...will try the upgrade.
14:24:24 <johnfn> elliott__, hmm, yeah i understand this is pretty code-dependent. is there a general way i can approach the problem? maybe some sample code i can refer to?
14:24:58 <elliott__> johnfn: well, if you describe your task in more detail and show some code, you might be able to rope the volunteers into showing you the way :P
14:25:17 <plathrop> Is it the general wisdom that "any program" can be written in functional style?
14:26:00 <monochrom> no, it's "any problem specification" can be done in functional style
14:26:08 <tac-tics> plathrop: If you try to force a square peg into a round hole, you can often do it, but you're gonna have to work a little harder for it
14:26:28 <elliott__> plathrop: The functional style is not even the most natural style in some cases... but those cases are usually contrived :)
14:26:40 <elliott__> plathrop: But here's some good news: Haskell supports imperative coding too!
14:26:49 <tac-tics> I find the FP is useful for nothing except furthering its own agenda
14:26:51 <plathrop> tac-tics: That's kinda exactly what I'm trying to avoid. When I was learning python I kept trying to write it as other languages.
14:26:53 <elliott__> In fact, it uses an imperative model for IO.
14:26:54 <kmc> oh dear
14:27:02 <elliott__> tac-tics: Then why are you in #haskell?
14:27:09 <plathrop> elliott__: the "do" syntax, right?
14:27:15 <tac-tics> plathrop: If you're writing any kind of compiler tool, haskell is awesome
14:27:21 <elliott__> plathrop: Nah: That works in any monad.
14:27:26 <tac-tics> elliott__: because I love furthering agendas
14:27:31 <elliott__> plathrop: But do notation is one way to use the IO monad, Haskell's model of imperative programs.
14:27:55 <monochrom> I'm writing a program that transforms xml some way. is that a kind of compiler tool?
14:28:04 <tac-tics> monochrom: of course
14:28:21 <elliott__> plathrop: In fact, Haskell has better support for imperative coding than most imperative languages -- it has first-class "actions" representing some imperative code that you can transform and pass around.
14:28:30 <plathrop> monochrom: absolutely. compilers are all about transforming one type of structured data into another, right?
14:28:33 <elliott__> That lets you build control structures to fit a specific purpose.
14:29:09 <monochrom> well, I have also seen programs written in haskell to take csv input or json input or... is that a kind of compiler tool, too?
14:29:15 <tac-tics> Haskell's IO is double-edged. Actions are first class and more composable, but you need to do your own plumbing
14:29:18 <plathrop> From a pragmatic viewpoint, I guess I'm just trying to get a feel for when you might reach for Haskell versus, well let's say Python for example.
14:29:43 <Clint> in my case it's when you hate python
14:29:55 <tac-tics> plathrop: If there's an abstract syntax tree, Haskell will be better
14:29:59 <plathrop> Clint: heh, yeah, that's one reason I'm sure.
14:30:08 <elliott__> tac-tics: You don't have to plumb in Python?
14:30:12 <tac-tics> plathrop: if you want to write code for other people to extend, Python is often better
14:30:15 <kmc> "Haskell vs Python" is a separate question from "functional vs imperative"
14:30:18 <kmc> it should be noted
14:30:25 <kmc> GHC Haskell has many nice features which have nothing to do with FP
14:30:27 <elliott__> sure
14:30:29 <plathrop> kmc: sure, of course I know that
14:30:34 <kmc> like the thread scheduler and IO manager, which are all about imperative code
14:30:48 <tac-tics> Haskell and Python both have their own deficiencies that have nothing to do with the other :)
14:31:05 <tac-tics> (like Python's explicit self in the OOP model, and Haskell's abomination of a record syntax)
14:31:06 <plathrop> replace Python with Common Lisp then :-P
14:31:17 <monochrom> anyway, I have this "template engine" (the xml processor I mentioned), and I don't find myself needing to record tags, indent levels...
14:31:50 <plathrop> Or, how about this, different question
14:32:01 <johnfn> https://gist.github.com/1252126 this code is incredibly pseudo, so i hope it makes sense, but if anyone has tips about that massive where block they would be most appreciated
14:32:26 <plathrop> Some of you must be using Haskell to write code that they actually use daily, or that serves a business purpose. What kinds of projects are those?
14:32:46 <kmc> plathrop, did you see http://www.haskell.org/haskellwiki/Haskell_in_industry
14:32:48 <johnfn> the problem being that i feel like im just using recursion to fake non-imperativeness instead of coming up with the correct functional approach
14:32:50 <plathrop> Or maybe some of you are sysadmins and have written command-line utilities? Just curious what people are doing with it.
14:32:59 <plathrop> kmc: I had not :-)
14:33:08 <elliott__> johnfn: well for instance
14:33:14 <elliott__> johnfn: you want to use a tree structure
14:33:20 <elliott__> if you want to generate an output which has indentation in it
14:33:27 <elliott__> then process the tree normally
14:33:32 <elliott__> and give it indentation in your Tree → String step
14:33:40 <johnfn> hmmmm. i see
14:33:49 <Clint> johnfn: there are html libraries you can use already
14:34:01 <elliott__> Clint: that won't help them learn :)
14:34:10 <elliott__> johnfn: getting a good functional model of your program is basically all about the types
14:34:24 <johnfn> Clint, but my problem isnt html parsing, it's that i cant seem to find the right functional approach
14:34:30 <elliott__> you need to figure out which types are being used, represent them in the language (which Haskell has great support for), and then figure out how you transform input into your data into output
14:34:43 <elliott__> if you don't have the right types... your code will show it :)
14:35:06 <johnfn> elliott__, that's given me some things to think about, thanks :)
14:35:14 <elliott__> np :)
14:36:57 <monochrom> wait, you're parsing indented things, not outputting indented things, right?
14:36:58 <plathrop> elliott__: is that a general approach to functional design?
14:37:24 <elliott__> plathrop: As general as they come, I'd say
14:37:30 <tac-tics> plathrop: I'd agree with elliott__'s statement there
14:37:37 <elliott__> monochrom: yeah I realised that only after I started
14:37:48 <elliott__> monochrom: I think johnfn probably wants a separate step to transform indentation into a better nesting structure
14:38:15 <monochrom> that will do, and more recommended
14:38:30 <tac-tics> A favorite quote of mine from B. Pierce's book on types goes something like "Q. Why do we write proofs in Computer Science? They are also so boring if you have the definitions correct. A. You almost always get the definitions wrong."
14:39:03 <tac-tics> Having types helps you make sure your definitions are all kosher.
14:39:22 <plathrop> I'm sorry if I'm asking weird questions. I'm a sysadmin first and coming late to programming, for one, and for two I'm having trouble grokking FP versus OOP.
14:39:40 <elliott__> FP can do OOP (but you probably don't want to).
14:39:40 <plathrop> which is funny, because FP makes a lot more sense to me on the surface.
14:40:00 <elliott__> Actually if you reduce OOP's basic concepts in a design to FP, it almost always ends up looking like simple data types, and functions.
14:40:24 <plathrop> It's just I've trained so hard in thinking of problems in terms of transforming the state of an object versus applying functions
14:40:25 <elliott__> That often makes big simplifications obvious
14:40:40 <elliott__> Yeah, OOP is a hard paradigm to shake off
14:40:50 <plathrop> CLOS is kinda functional-flavored OOP I think
14:41:42 <elliott__> Multimethods are definitely closer to good Haskell than typical OOP (but you often end up including behaviour in "objects" in Haskell because that's kind of the equivalent of subclassing: including the relevant behaviour in the object itself)
14:42:05 <plathrop> elliott__: Yeah, that's really where I'm at. Just trying to shake off the OOP not because I hate it but so I can become more flexible.
14:42:18 <plathrop> that's the point of learning more languages, too, for me.
14:43:57 <tac-tics> plathrop: Haskell's a good way to bring to your attention all the implicit assumptions you have about how programming works ;)
14:44:56 <plathrop> One of the reasons I chose it.
14:45:15 <plathrop> but I never truly *get* a language until I write something nontrivial.
14:45:24 <plathrop> so, gotta think of a fun problem to solve
14:50:04 <MarkDBlackwell> elliott__, This bug report http://hackage.haskell.org/trac/ghc/ticket/2389 says, 'The syntax to use when the file names contain spaces is Haskell String syntax' wherein \\ is used to get \. Unlike some languages I know (Ruby, LilyPond) which take '/' and convert to '\' for us on Windows, Haskell likes us to use the actual path character (\) on Windows, it seems.
14:50:12 <elliott__> ah
14:50:24 <monochrom> \∩/ shachaf's two-monads quote makes it to HWN!
14:51:02 <elliott__> \∩/? Are you a ghost?
14:51:10 <monochrom> a robot
14:51:30 <MarkDBlackwell> So, not just double-quoted, but, e.g., "C:\\something with spaces\\and so on"  -- to tell newbies. Thanks for your help! :)
14:51:49 <ivanm> MarkDBlackwell: is that in FilePaths?
14:51:57 <ivanm> if so, you shouldn't be using literal \\ or /
14:52:04 <ivanm> and you _should_ be using </> from System.FIlePath
14:52:13 <monochrom> it's at the ghci prompt doing :cd etc
14:52:19 <ivanm> oh, right
14:52:27 <shachaf> monochrom: What?
14:52:35 <monochrom> @quote shachaf escape
14:52:35 <lambdabot> shachaf says: You can never escape having learned monads. If you learn two monads, though, you can go back to only knowing one.
14:52:39 <monochrom> that one :)
14:52:47 <shachaf> Ugh.
14:52:57 <monochrom> it's on HWN now :)
14:53:17 <monochrom> I love it very much!
14:54:09 * shachaf is glad monochrom likes it, at least.
14:55:48 <monochrom> "This commit adds support to GHCi for most top-level declarations that can be used in Haskell source files.  Class, data, newtype, type, instance are all supported, as are Type Family-related declarations."  Scary! but finally removing a long-standing FAQ. :) https://github.com/ghc/ghc/commit/3db757241ce7fb99c096c30481aefa86bb9855a1
14:57:27 <MarkDBlackwell> ivanm, no, in the :set -i<path> meta-statement to WinGHCi, like a start option.
14:57:29 <shachaf> Will it be in 7.4?
14:57:37 <MarkDBlackwell> going now
14:57:46 <ivanm> MarkDBlackwell: *nod*
14:58:14 <shachaf> monochrom: Did you play Red Alert 2?
14:58:35 <monochrom> A very little bit.
14:58:49 <shachaf> Hmm. How about Red Alert 3?
14:58:57 <monochrom> not yet.
14:59:00 <ivanm> "I've dropped a bomb... do you have it?"
14:59:24 <shachaf> Crazy ivanm.
15:02:21 <tac-tics> Hey guys, how do you "cabal install" a package, but disable profiling?
15:02:43 <elliott__> tac-tics: cabal install --disable-library-profiling
15:02:45 <ivanm> tac-tics: cabal install --disable-profiling or something
15:02:46 <elliott__> tac-tics: but why?
15:02:52 <elliott__> it'll only double the time :)
15:03:00 <monochrom> yes, you will likely regret it in a few months
15:03:09 <ClaudiusMaximus> compare with --enable-executable-profiling
15:03:12 <ddarius> monochrom: Cool.
15:03:14 <tac-tics> I don't have the proper profiling library installed
15:03:14 <ivanm> elliott__: I'm going to vaguely guess that the's mixing system packages without profiling support with whatever library he wants to build in user-space
15:03:18 <tac-tics> so it's killing my install
15:03:22 <elliott__> shachaf hates being quoted :P
15:03:26 <elliott__> re: the two monads thing
15:03:30 <elliott__> ivanm: :'(
15:03:35 <elliott__> tac-tics: you should fix that :P
15:04:01 <tac-tics> elliott__: Yes, I should, but I really don't feel like learning the ins and outs of cabal this week :)
15:04:03 <tac-tics> Some day though
15:04:05 <monochrom> alright, if you're already doomed with lacking profiling, go ahead :)
15:04:09 <elliott__> Don't need to do that, but okay
15:04:32 <ddarius> Plagiarism is the sincerest form of flattery.
15:04:41 <monochrom> haha
15:07:52 <tac-tics> It looks like for this package, i need another package called FUtil
15:07:57 <tac-tics> But cabal doesn't know wtf I'm talking about
15:08:16 <tac-tics> Is there an alternate repository that I can look through if cabal's default repo doesn't host what I want?
15:09:13 <tac-tics> ah nevermind
15:09:46 <elliott__> tac-tics: hackage
15:09:52 <elliott__> what doesn't hackage have that you want?
15:10:04 <elliott__> oh FUtil
15:10:23 <elliott__> not on hackage at least, what package wants that? ... I guess you said to never mind :)
15:11:55 <romanandreg> hey guys, what library would you recommend me to build XML documents?
15:12:33 <romanandreg> there are 3 libraries hxt, HaXml and HXML
15:12:45 <elliott__> there is HaXml. and hxt (but I don't really like it because it uses arrows a ton). I've never heard of HXML, that doesn't seem to be on hackage
15:12:47 <c_wraith> there are a lot more than 3
15:12:59 <elliott__> there's also hexpat
15:13:04 <elliott__> which is probably a lot less "haskelly"
15:13:08 <romanandreg> c_wraith: there are 3 libraries I have found*
15:13:09 <elliott__> but likely faster etc.
15:13:18 <Cale> hexpat-pickle is pretty Haskelly
15:13:19 <elliott__> oh, and libxml. there are probably a billion :P
15:13:27 <elliott__> romanandreg: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:xml btw
15:13:40 <elliott__> Cale: oh, that looks decent
15:13:57 <romanandreg> elliott__:    :-/
15:14:05 <romanandreg> elliott__:  look like a lot
15:14:12 <romanandreg> elliott__:  looks*
15:14:12 <elliott__> romanandreg: Cale sounds like he has experience with 'em, ask him :-)
15:14:29 <c_wraith> http://hackage.haskell.org/package/xml is probably the easiest to understand, though it also gives you the fewest features
15:14:30 <romanandreg> Cale: gonna check hexpat out
15:15:29 <romanandreg> c_wraith: Galois normally is  a good author
15:15:45 <tac-tics> elliott__: ok this is legitimate this time. Setup.lhs configure says I'm missing "at least one of" HSH >= 2, MonadRandom -any
15:15:46 <eikke> is there any way to convert a lazy bytestring into a strict one?
15:15:46 <romanandreg> thank you for the resources guys, I've a lot on my hands to play with thanks
15:15:48 <c_wraith> what's the option to preserve longer portions of the cost centers names in heap profiles?
15:15:59 <tac-tics> elliott__ but ghc-pkg list says they are both installed
15:16:05 <c_wraith> eikke: toList
15:16:18 <c_wraith> eikke: will turn it into a list of strict bystrings, which you can then concat
15:16:39 <elliott__> tac-tics: hmm
15:16:44 <eikke> c_wraith: hmh, makes sense... what's the best structure to use by default, lazy or strict ones?
15:16:50 <elliott__> tac-tics: ghc-pkg check?
15:16:52 <tac-tics> and nvm again, it looks like there's an install shell script that configures stuff
15:16:58 <elliott__> I wouldn't use that, but okay :P
15:17:03 <c_wraith> eikke: depends on what you're doing with them.
15:17:20 <tac-tics> elliott__: You're a more manly developer than I :P
15:17:26 <eikke> c_wraith: mainly, retrieve from disk and put on a socket
15:17:34 <elliott__> Nah, I'd be scared of whatever the script might do
15:17:42 <elliott__> eikke: probably strict
15:17:46 <eikke> ok
15:17:50 <tac-tics> I'll tell you what it does.... it sudo's into my mac XD
15:18:02 <elliott__> tac-tics: See what I mean :P
15:18:02 <c_wraith> Eh.  If you're not modifying the contents on the way, lazy might be better there.
15:18:25 <c_wraith> Because it should allow lower memory use with large files, due to lazy IO.  (sometimes lazy IO is a loss, sometimes it's a win)
15:18:54 <ddarius> Other than a few papers that were never accepted (due to coincidence and incompetence), Galois' contribution to mathematics was a collection of barely coherent notes written the day before he died..
15:21:41 <elliott__> c_wraith: Yeah, but the advantage of using strict bytestrings in chunks is that you don't have to use lazy IO :P
15:22:59 <c_wraith> elliott__: for some simple cases, the simplicity lazy bytestrings allows is a clear win.  For more complex cases, it blows up in your face.
15:23:33 <elliott__> Mm
15:25:11 <cgroza> can I have any let or where constructs in function guards?
15:25:29 <hpaste> jfp pasted “unczip” at http://hpaste.org/51933
15:25:34 <elliott__> They're expressions, so sure you can say | (let x = y in z) = ...
15:25:35 <ddarius> Sure.
15:25:35 <elliott__> But... don't.
15:25:39 <elliott__> Not where though.
15:25:46 <elliott__> Assuming you mean in the actual guard itself.
15:26:04 <hpaste> jfp annotated “unczip” with “unczip (annotation)” at http://hpaste.org/51933#a51934
15:26:35 <cgroza> can I put it after teh guards?
15:27:16 <elliott__> cgroza: Certainly.
15:27:23 <elliott__> "where" clauses only apply to one clause of a function though.
15:27:27 <elliott__> (But that can include multiple guards.)
15:31:34 <aavogt> > case () of _ | let x = 2, x == 2 -> "cgroza"
15:31:35 <lambdabot>   "cgroza"
15:32:29 <elliott__> aavogt: Huh, that comma...
15:32:31 <aavogt> but if you don't need the binding to be recursive, it's probably prettier to use:
15:32:34 <elliott__> Is it the same as list comprehensions?
15:32:38 <elliott__> Never realised that was possible.
15:32:39 <aavogt> > case () of _ | x <- 2, x == 2 -> "cgroza"
15:32:40 <lambdabot>   "cgroza"
15:33:39 <aavogt> elliott__: read the language grammar, or say use template haskell to see what kinds of uncommon things are allowed
15:33:49 <elliott__> fair enough
15:33:50 <Cale> To be fair, that's new
15:33:54 <elliott__> oh
15:34:00 <elliott__> is it just pattern guards?
15:34:02 <Cale> yes
15:34:04 <elliott__> ah
15:34:12 <elliott__> a very strange pattern indeed :P
15:34:23 <aavogt> you have an interesting definition of new, Cale
15:34:33 <Cale> Well, newer than Haskell 98 :)
15:38:28 <monochrom> in fact, you have to put "where" after all guards, not between two guards
15:41:14 <ddarius> > let f | let x = t where t = True in x | otherwise = False in f
15:41:15 <lambdabot>   <no location info>: parse error on input `|'
15:41:41 <monochrom> you need many, many {}s to mix function definitions, let, where
15:42:19 <ddarius> > let f | let x = t where t = True in x = True | otherwise = False in f
15:42:20 <lambdabot>   True
15:42:28 <ddarius> Also, no functions were defined.
15:43:02 <shachaf> > let f | let x | True = t where t = True in x = True | otherwise = False in f
15:43:03 <lambdabot>   True
15:43:39 <monochrom> oh well
15:48:35 <pedro3005> what's a good way to take from an infinite list until a repeated element is found?
15:49:27 <monochrom> repeated as in it occurs at least twice in the list, and they are arbitrarily far apart?
15:49:47 <pedro3005> repeated as in it has already been taken
15:49:48 <elliott__> > let f xss@(_:xs) = zip xss xs in f (inits [9,0,9,9,0])
15:49:49 <lambdabot>   [([],[9]),([9],[9,0]),([9,0],[9,0,9]),([9,0,9],[9,0,9,9]),([9,0,9,9],[9,0,9...
15:49:58 <elliott__> > let f xss@(_:xs) = zip xss xs in map f (inits [9,0,9,9,0])
15:49:59 <lambdabot>   [*Exception: <interactive>:3:4-28: Non-exhaustive patterns in function f
15:50:03 <elliott__> oh, duh
15:50:08 <elliott__> pedro3005: oh... then my solution won't work :P
15:50:10 <monochrom> sorry, what is "taken"?
15:50:13 <elliott__> I thought you meant consecutive equal elements
15:50:32 <pedro3005> well, i'm considering taking as an iterative process
15:50:55 <pedro3005> it would "stop" when it reaches an element already in the resulting list being built
15:51:33 <pedro3005> to clarify, i am iteratively applying a function to a number, and this is guaranteed to cycle. and I want this cycle
15:51:49 <pedro3005> but no rule for the size of each cycle or whatever
15:53:57 <monochrom> do you mind using Data.Set to store all numbers seen so far?
15:55:10 <pedro3005> well
15:55:14 <zzo38> Did you read this?   http://hackage.haskell.org/trac/hackage/ticket/891   What is your opinion of this?
15:55:17 <pedro3005> wanted to keep it short
15:55:48 <zzo38> When I make package I put a name BarrierMonad for package and for module, but maybe I should change it so that it can be made to unique
15:56:07 <elliott__> zzo38: What is the purpose of that ticket? Is there another cabal-processing tool that wants its own fields?
15:56:13 <elliott__> If so shouldn't it try and get them standardised?
15:57:21 <zzo38> elliott__: Well, in case of the standard rejected or you need to make the program yourself and do not go through the standards process, for example.
15:57:38 <elliott__> zzo38: But what's the motivating tool?
15:57:52 <zzo38> So far I have no tool.
15:58:12 <monochrom> http://en.wikipedia.org/wiki/Cycle_detection may help
15:58:24 <elliott__> zzo38: Sounds like you should write the tool first, then report the issue
15:59:22 <ddarius> monochrom: Finding a cycle is a different problem then what pedro3005 originally described.
15:59:31 <pedro3005> well I ended up using
15:59:33 <zzo38> OK; but the reason I specified it the way it is, is so that you can do it regardless of what tools.
15:59:35 <pedro3005> reverse $ f [] n where
15:59:35 <pedro3005>     f xs x = if x `elem` xs then xs else f (x:xs) (next x)
15:59:48 <zzo38> Similar to experimental MIME headers working
16:00:34 <monochrom> Data.Set speeds that up tremendously with little additional work
16:00:48 <elliott__> zzo38: Well, write a patch if you want it in... I doubt anyone else will if there's no motivating example at all
16:00:55 <elliott__> I could be wrong
16:01:30 <zzo38> OK, I will try to write a patch. It should be easy, I think.
16:01:54 <Saizan> i think x- fields are already there or were in the past
16:02:17 <pedro3005> well, I doubt the cycles will get too large, but if it starts getting slow I'll look into that
16:03:18 <Saizan> zzo38: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal-1.12.0/Distribution-PackageDescription.html#g:1 <- see customFieldsPD
16:04:36 <ivanm> wait, Cabal-1.12 has been released?
16:04:44 <ivanm> I thought 7.2.1 just had a snapshot...
16:09:02 <zzo38> O, yes, there is customFieldsPD. But will that suppress the warnings?
16:09:04 <KirinDave> http://twanvl.nl/blog/haskell/finding-rectangles
16:09:14 <KirinDave> maximumBy (comparing f `mappend` compare)
16:09:17 <KirinDave> Whaaaaa?
16:09:25 <zzo38> And can it do with sections?
16:09:27 <ClaudiusMaximus> > let double = snd . properFraction . (* 2) ; cyclic l f x = case break (== x) l of (c, _:pre) -> (reverse pre, x:reverse c) ; (_, []) -> cyclic (x : l) f (f x) in cyclic [] double (1/28 :: Rational)
16:09:28 <lambdabot>   ([1 % 28,1 % 14],[1 % 7,2 % 7,4 % 7])
16:11:40 <ClaudiusMaximus> > sortBy (comparing isUpper `mappend` compare) "hElLo WoRlD"
16:11:42 <lambdabot>   " hllooDELRW"
16:11:59 <elliott__> KirinDave: What about it?
16:12:05 <elliott__> mappend has an instance for ((-> a).
16:12:15 <ClaudiusMaximus> > sortBy (compare `mappend` comparing isUpper) "hElLo WoRlD"
16:12:16 <lambdabot>   " DELRWhlloo"
16:12:17 <incluye> where's euler's constant e in haskell
16:12:28 <shachaf> @ty (++)
16:12:29 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:12:32 <elliott__> incluye:
16:12:33 <elliott__> :t exp
16:12:34 <lambdabot> forall a. (Floating a) => a -> a
16:12:39 <incluye> > exp 1
16:12:40 <lambdabot>   2.718281828459045
16:12:44 <incluye> oh, derp
16:13:01 <Cale> > log (exp 1)
16:13:02 <lambdabot>   1.0
16:13:08 <shachaf> > logBase exp1 exp1
16:13:10 <lambdabot>   1.0
16:13:11 <elliott__> lucky
16:13:44 <hpc> > exp1
16:13:46 <lambdabot>   2.718281828459045
16:13:50 <hpc> >exp2
16:13:55 <Cale> I love Haskell's good sense to call the natural logarithm log.
16:13:55 <hpc> > exp2
16:13:56 <lambdabot>   Not in scope: `exp2'
16:14:13 <incluye> every language does that
16:14:19 <hpc> incluye: nope
16:14:25 <incluye> really?
16:14:27 <zzo38> I tried; and yes it seem that it does already suppress warning for X-
16:14:34 <incluye> afaik, lua and ruby and PHP do
16:14:47 <elliott__> zzo38: might want to close the issue :)
16:14:50 <hpc> from what i remember, java doesn't
16:14:56 <ddarius> It's those cursed mathematicians.
16:15:14 <zzo38> elliott__: It works for fields, but not for sections. So it should be partially closed?
16:15:40 <elliott__> zzo38: well it's not clear how to parse an arbitrary unknown section
16:15:47 <elliott__> what if it doesn't take a name? what if it takes two arguments at the top?
16:17:00 <dmwit> We ought to count in base e.
16:18:28 <dmwit> 0, 1, 2, 11
16:18:49 <ddarius> e+1 /= 3
16:18:50 <elliott__> Quite hard to name three
16:18:57 <dmwit> yeah
16:19:06 <elliott__> But who needs three, it's not even a power of two
16:19:19 <ddarius> elliott__: I say we should require children to state the complete number before moving no.
16:19:22 <ddarius> s/no/on.
16:19:37 <elliott__> ddarius: That would solve the pesky problem of "children existing".
16:19:38 <dmwit> I meant 0, 1, 2, 10.1, I think
16:19:52 <dmwit> > exp 1 + 1 / exp 1
16:19:52 <lambdabot>   3.0861612696304874
16:19:53 <elliott__> I don't think that's three, either.
16:20:02 <dmwit> It's less wrong than 11.
16:21:03 <KirinDave> elliott__: I guess it is ghci that is giving me trouble.
16:21:13 <elliott__> Did you import all the modules? :p
16:21:20 <KirinDave> :t seems to think so.
16:21:21 <lambdabot> parse error (possibly incorrect indentation)
16:22:04 <KirinDave> But when I actually try it with like a (+1) section it flips out.
16:22:51 <zzo38> elliott__: I think there can be a way of parsing unknown section by, if the top is not the name with colon afterward, everything up to the line break or { is a single parameter and the rest is fields if they have a colon.
16:25:10 <tsuraan_> is there something in hackage or the standard library that can give something like the results of the unix "df" command?
16:26:30 <tsuraan_> looks like Bindings.Posix.statvfs
16:26:36 <tsuraan_> now that's an ugly API
16:27:11 <zzo38> For example, I want to make up the section that has the information of preparing printouts of the program.
16:27:35 <ClaudiusMaximus> tsuraan_: also http://hackage.haskell.org/packages/archive/gnomevfs/latest/doc/html/System-Gnome-VFS-Util.html#v:getVolumeFreeSpace (found via hayoo)
16:27:59 <KirinDave> elliott__: Oh maybe I am just misreading it. :\
16:28:08 <KirinDave> Is it comparing $ f `mappend` compare ?
16:28:38 <ClaudiusMaximus> > maximumBy (comparing even `mappend` compare) [1..5]
16:28:39 <lambdabot>   4
16:28:49 <tsuraan_> ClaudiusMaximus: I didn't even think of looking there.  Thanks!
16:30:11 <elliott__> KirinDave: Depends what you mean by that
16:30:17 <elliott__> It's mappend (comparing f) compare
16:34:48 <Cale> > maximumBy (comparing length `mappend` compare) (words "here are a bunch of words")
16:34:49 <lambdabot>   "words"
16:34:51 <zzo38> To anyone writing literate Haskell blog posts, I have to tell you something: It doesn't work. If you want it to work, use the <XMP> command of HTML, or the <![CDATA[ command in XHTML.
16:35:02 <Cale> > sortBy (comparing length `mappend` compare) (words "here are a bunch of words")
16:35:03 <lambdabot>   ["a","of","are","here","bunch","words"]
16:35:52 <hpc> zzo38: except xmp is deprecated
16:36:01 <hpc> how doesn't it work?
16:36:02 <ClaudiusMaximus> Cale++   -- my examples were rubbish
16:36:41 <zzo38> hpc: In XHTML, you can use <![CDATA[ instead you don't need XMP. But if it is a normal HTML document, you should use <XMP> that is its use
16:37:06 <zzo38> (And I don't think you can use <XMP> in XHTML anyways; even if you can, you shouldn't.)
16:37:13 <ClaudiusMaximus> yeah CDATA is better except you then have to escape ]]> (which doesn't occur often in .lhs, but does in .bf)
16:38:10 <zzo38> ClaudiusMaximus: Well, yes but if you are using .bf you have other things to deal with.
16:38:17 <hpc> zzo38: i mean, how does it break? can you just not copy text?
16:38:28 <elliott__> ClaudiusMaximus: brainfuck extension is .b
16:38:31 <elliott__> ClaudiusMaximus: .bf is befunge :-)
16:38:42 <ClaudiusMaximus> elliott__: heh, ok
16:38:43 <zzo38> elliott__: Yes, I agree. (But not everyone agrees on this)
16:39:00 <zzo38> hpc: Well, if you download the file, it is not a proper Haskell code!
16:40:01 <hpc> zzo38: how do you mean? are you viewing source and copying the html?
16:40:10 <zzo38> hpc: No, downloading the file by wget
16:40:17 <hpc> oh, well duh
16:41:04 <hpc> the idea of those blogs it to be /read/ like a lhs, not run like one
16:41:08 <hpc> *is
16:41:12 <zzo38> Using the stuff most blogs do now, it would be difficult to input, too, I think.
16:41:30 <zzo38> So it is not only a problem to run the program.
16:41:52 <hpc> and those posts still run if you copy-paste it from a browser window
16:42:08 <elliott__> yeah you're meant to copy them
16:43:38 <zzo38> Those who are using the gopher protocol can ignore my suggestion because it doesn't have that problem; it is just a plain text so it work OK.
16:44:06 <zzo38> In both Brainfuck and Haskell, you can put spaces if you have to write ]]> and if it is part of a string literal (for Haskell) you can put \& in between
16:47:21 <zzo38> I want to make up the cabal fields for preparing printout. I can try to do that.
16:48:47 <wavewave> where do words "banana" and "lense" come from?
16:49:07 <dmwit> From the shape of the symbols used.
16:49:09 <dmwit> It's dumb.
16:49:37 <wavewave> what symbol? would you show me if possible?
16:49:41 <ClaudiusMaximus> arrow proc notation has (| banana brackets |) i vaguelly recall
16:49:59 <wavewave> ah.. that arrow symbol?
16:50:10 <monochrom> [( blah )]  is probably lenses
16:50:12 <eyebloom> Can anyone help me understand why the type inference in this example code does not work in "partf" but does work in "partf2" : http://codepad.org/o4Fvq5Ig
16:50:51 <monochrom> not arrow symbol. (| f |) is a way to say fold f, catamorphism
16:51:12 <shachaf> eyebloom: Because when you say f :: Num a => a -> a, that's a promise f will work for every instance of Num.
16:51:38 <dmwit> eyebloom: Because (1 :: Num a => a), but (x :: Integer).
16:51:46 <shachaf> eyebloom: Whereas parf uses x :: Integer, which is more specific.
16:51:52 <wavewave> I am reading http://www.cs.virginia.edu/~wh5a/blog/Explicit%20recursion%20schemes.html
16:52:20 <dmwit> wavewave: Oh, I thought you were reading Bananas, Lenses, and Barbed Wire or whatever that paper is.
16:52:24 <wavewave> in the middle, "With banana (cata) and lenses (ana)... "
16:52:30 <dmwit> That's the paper they got their names from.
16:52:35 <monochrom> well, banana specifically refers to the catamorphism (| |) not the arrow one
16:53:11 <eyebloom> Still not understanding, isn't Integer an instance of Num?
16:53:19 <dmwit> wavewave: So take a look at that paper if you're interested.
16:53:24 <shachaf> eyebloom: It is, but it's only one instance.
16:53:24 <zeiris> There was a project a while back that used Snap (or happstack?) to implement a Mathematica-like notebook format.
16:53:26 <dmwit> eyebloom: Yes. But not every instance of Num is Integer.
16:53:32 <zeiris> Anyone remember what its name was?
16:53:32 <eyebloom> Why does partf2 work?
16:53:33 <shachaf> eyebloom: Your function promises that it works for every instance.
16:53:45 <shachaf> eyebloom: Because (1 :: Num a => a), not (1 :: Integer).
16:54:04 <wavewave> dmwit: yes. I am downloading it now.. Thanks.
16:54:04 <monochrom> 1 is polymorphic
16:54:07 <monochrom> > 1 :: Int
16:54:09 <lambdabot>   1
16:54:13 <monochrom> > 1 :: CReal
16:54:14 <lambdabot>   1.0
16:54:20 <monochrom> 1 belongs to everybody
16:55:16 <monochrom> every 1 belongs to everyone. everyone is happy. :)
16:55:29 <zeiris> Oh my god this is driving me nuts. It let you graph functions, Haskell functions, and it was in the browser and looked like Mathematica.
16:55:38 <zeiris> Showed up on reddit a few times a couple of months ago.
16:55:53 <eyebloom> Ok understood now.
16:57:31 <eyebloom> The reason I'm posting this code is because I'm feeling like in every function type specification I have to express every typeclass that in every subfunction it calls.
16:57:45 <wavewave> Is there a library parsing  TeX file into haskell datatype?
16:57:49 <monochrom> yes that's the idea. C++ does the opposite.
16:58:18 <elliott__> zeiris: Wolfgang Alpha?
16:58:22 <eyebloom> So if I add a debug command at the top of the chain I have to add Show a to every function that calls it.
16:58:25 <elliott__> Or whatever.
16:58:33 <zeiris> Wolfram Alpha isn't in Haskell though.
16:58:35 <hpc> wavewave: http://haskell.org/hoogle/?hoogle=latex -- signs point to "no"
16:58:39 <elliott__> zeiris: I said Wolfgang.
16:58:47 <zeiris> Oh man, did he really make that pun? :D
16:58:51 <elliott__> Oh, it was Wolfgang Lambda, I think
16:58:59 <elliott__> But the pun was definitely intentional
16:59:07 <eyebloom> So my type definitions are just getting ridiculously long.
16:59:21 <eyebloom> Is there any way to combat that?
16:59:22 <elliott__> eyebloom: don't debug like that
16:59:27 <elliott__> and use fewer typeclasses
16:59:31 <elliott__> and use less polymorphism :P
17:00:10 <eyebloom> elliott: well that's a different story... but in general I've found debugging in Haskell extremely difficult.
17:00:26 <elliott__> eyebloom: Are you coming from a compiled language?
17:00:54 <eyebloom> C, C++, Java, Python
17:01:04 <elliott__> People coming from something like Python where the interactive debugging style is prominent will have a much easier time -- and debugging in Haskell will be even easier than other languages for them, because of the tendency for pure functions, and for small, reusable, generic ones.
17:01:21 <elliott__> GHCi is basically the most flexible debugger you will find :)
17:01:33 <hpc> elliott__: and also python's shell being industrial-strength shit
17:01:39 <Eduard_Munteanu> Uh.
17:01:47 <elliott__> eyebloom: To debug, you should test as small components as you can.
17:01:52 <Philippa> I dunno: I'd like a debugger that's embedded language aware, myself
17:02:04 <eyebloom> Right well how can I get GHCi to trace from an exception and show me all of the parameters in the stack that lead to that exception?
17:02:09 <elliott__> eyebloom: Keep trying out the more and more complicated functions built up on top of ones you've already tested until you've found the failure.
17:02:11 * monochrom is not very impressed with python interpreter's reload story
17:02:13 <elliott__> Then you know where the problem is.
17:02:15 <elliott__> You can't.
17:02:17 <hpc> eyebloom: the "stack" in haskell is not what you think
17:02:25 <elliott__> (it doesn't even make much sense)
17:02:27 <elliott__> But you don't need to.
17:02:40 <hpc> @quote oasis
17:02:40 <eyebloom> Right, I understand about laziness.
17:02:40 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
17:02:48 <elliott__> eyebloom: If you test the smaller parts and then the larger parts, you will see where the problem is.
17:02:56 <elliott__> It takes some getting used to, but stack traces are really minor in Haskell, you barely ever need or want them.
17:03:28 <monochrom> actually GHCi has a debugger. but it only works for interpreted code. read the GHC user guide for how to use its debugger and how to ensure you're loading interpreted code (not *.o files)
17:03:37 <dcsobral> Reading LYAH here, and I got a question.
17:03:47 <elliott__> monochrom: Does anyone really use it?
17:03:54 <monochrom> I haven't used it :)
17:04:00 <elliott__> It seemed awkward and klunky to me; as someone who never wanted a debugger in e.g. Python, I didn't see any reason to check it out
17:04:10 * Eduard_Munteanu tried but it didn't help that much... didn't try really hard though
17:04:13 <hpc> i didn't even want a debugger in java
17:04:24 <hpc> print statements did more than enough
17:04:39 <elliott__> dcsobral: go on :)
17:05:11 <dcsobral> On chapter three, it describes how to create a head' function using pattern matching. No problem there, but it has an empty list case, which is defined as 'error "some message"'.
17:06:09 <elliott__> dcsobral: ok, and? :P
17:06:20 <monochrom> I do not exactly understand or agree with the complaint about proliferating Show for debugging. my reason is rather involved.
17:06:25 <dcsobral> How's error defined? I see it's type is [char] -> a, but how can that type be defined?
17:06:34 <elliott__> :t error
17:06:35 <lambdabot> forall a. [Char] -> a
17:06:43 <elliott__> dcsobral: Basically, you can imagine
17:06:49 <eyebloom> I understand the difference between pure functional and imperative code, but I think there are certain situations where it would be nice to see all the parameters that lead up to a certain conditional breakpoint.
17:06:50 <elliott__> error s = infinite loop
17:06:52 <dcsobral> If there was inheritance, I could see it returning bottom like in Scala. But, here...
17:06:52 <hpc> dcsobral: it's defined in scary magic ways
17:06:56 <elliott__> :t let x = x in x
17:06:57 <lambdabot> forall t. t
17:07:01 <elliott__> dcsobral: You can see that this has the right type for error's return
17:07:11 <elliott__> dcsobral: It's just that in practice our implementations give more helpful "error"s :)
17:07:21 <monochrom> if your function to be diagnosed has specific enough types, e.g., all-out Integer or even just Num, you already have Show implicitly, you don't have to write it
17:07:29 <elliott__> The only inhabitant of (forall a. a) is _|_, aka undefined, aka an infinite loop.
17:07:35 <elliott__> Errors are just another kind of _|_ that the implementation provides.
17:07:45 <elliott__> So basically the answer is, it is built in to the implementation.
17:08:06 <eyebloom> Even if the debugger needs to force evaluation of certain expressions to give you that information.
17:08:16 <dcsobral> s/inheritance/subtyping/
17:08:18 <eyebloom> Sorry to rant.
17:08:29 <monochrom> if your function is fully polymorphic, like a->a, you don't actually print out the "a" value for debugging. you use Wadler's "free theorems" and a few test cases, and that closes the file.
17:08:46 <Eduard_Munteanu> I wonder if it isn't a better idea to use a separate typeclass for debugging messages.
17:08:52 <hpc> @free id :: a -> a
17:08:52 <lambdabot> f . id = id . f
17:08:53 <ddarius> monochrom keeps files of bugs.
17:09:02 <elliott__> eyebloom: With all due respect, you are not experienced with Haskell, and most people who are disagree with you :-)
17:09:29 <elliott__> Stack traces are sometimes useful, but if you get into the functional paradigm and using GHCi effectively, I do think you will find they are not as useful as you think for most debugging.
17:09:42 <monochrom> "free theorems" for f::a->a says: either (regardless what a is, f terminates and behaves as id) or (regardless what a is, f non-terminates). so you just test it at one type, one value, and that's it.
17:09:43 <elliott__> Learning Haskell requires a bit of faith that however alien it is it'll pay off and make sense at "the end".
17:10:08 <Philippa> eyebloom: if you really, /really/ care, shove it in a monad and build your preferred debugging framework there
17:10:08 <zeiris> Haskell digs itself into a hole so deep, that it comes out the other side and finds a new world.
17:10:17 <Philippa> it's not actually that hard to do
17:10:17 <zeiris> All the "restrictions" end up being a good thing.
17:10:33 <Philippa> zeiris: almost all, anyway. I'd still like a good way to define new binders
17:10:35 <ddarius> The inmates are running the asylum.
17:10:40 <hpc> worded in a happier way, the restrictions turn into things you can assume won't ever happen
17:10:42 <eyebloom> elliott: Point taken. Can you point me to any good tutorials on debugging Haskell.
17:10:54 <hpc> so it's not "things you can't do", it's "things you can expect"
17:11:06 <dcsobral> Kind of disappointing to find out error is magic... :-(
17:11:10 <eyebloom> By the way you aren
17:11:16 <monochrom> similarly for functions like [a]->[a]. at most you print out the list skeleton, e.g., how many cons cells. you don't print out the "a" contents. you just use concrete type and concrete values for a few tests to confirm.
17:11:20 <eyebloom> 't Conal Elliott are you?
17:11:21 <Eduard_Munteanu> If you write code that's a lot like C in Haskell, then perhaps you need something like gdb indeed.
17:11:24 <elliott__> No, I'm not :)
17:11:31 <eyebloom> :0
17:11:32 <hpc> conal is conal
17:11:38 <wavewave> eyebloom: at least for type inference, use false type signature and see the error message from compiler.
17:11:49 <elliott__> eyebloom: Well, I don't know of any tutorials specifically for debugging Haskell. But I think that you should basically try and use GHCi as much as you can at every stage and it'll come naturally.
17:12:02 <elliott__> If you're using Emacs, C-c C-l is great.
17:12:05 <hpc> Eduard_Munteanu: does gdb and compiled haskell play nice?
17:12:16 <elliott__> hpc: not even vaguely
17:12:17 <wavewave> eyebloom: that's especially useful for a type mismatch inside a definition in function.
17:12:18 * ddarius almost never uses GHCi.
17:12:18 <Eduard_Munteanu> You don't need gdb-like stuff that much because most pieces in a Haskell program are well isolated.
17:12:20 <conal> eyebloom: hi
17:12:25 <hpc> elliott__: lol
17:12:31 <eyebloom> Hah
17:12:45 <monochrom> "free theorems" for g::[a]->[a] says that if one test behaves like g [1,2,3] = [3,2,1], then g [x,y,z] = [z,y,x] for all x,y,z, for all types. you don't print out "general" x, y, z for debugging
17:12:47 <eyebloom> Been reading your papers Conal, nice to see you here.
17:12:54 <conal> eyebloom: :)
17:12:54 <Eduard_Munteanu> So there aren't full-fledged, unsafe pointers flying around from one part of the program to the other.
17:13:20 <elliott__> conal: Do you think there's a way I could profit from people thinking I'm you?
17:13:21 <Eduard_Munteanu> hpc: hm, I didn't try, but I'd guess that doesn't give you much information
17:13:31 <eyebloom> Conal: Was there ever public source code for Pan?
17:13:33 <ddarius> monochrom: See SmallCheck.
17:13:35 <hpc> Eduard_Munteanu: i kind of want to try now
17:13:35 <conal> elliott__: worth a try.
17:13:40 <wavewave> eyebloom: like let a = xxx , or  where a = xxx ... you can add a :: ( Int or whatever don't make sense )  and see what happens.
17:13:44 <elliott__> conal: I'll get right on it
17:14:05 <wavewave> eyebloom : for that, sometimes you may need extenstion ScopedTypeVariables
17:14:19 <conal> eyebloom: yeah quite a while ago. it's bit-rotted quite a lot. depended on some obsolete windows libraries.
17:14:23 <Philippa> eyebloom: how much total code are you trying to debug right at this moment, and what sort of structure does it have at runtime?
17:14:29 <Eduard_Munteanu> hpc: hm, I'd be curious.
17:14:58 <conal> eyebloom: i have a much more recent system that combines & updates the functionality of Pan and of Vertigo and targets modern GPUs.
17:15:35 <eyebloom> conal: I'll have to read more of your newer stuff.
17:15:47 <conal> eyebloom: it's been stalled for quite a while by the absence of a ghci-friendly, cross-platform gui library.
17:15:52 <Philippa> (also, is it failing with an exception, or just giving the wrong values?)
17:15:53 * ddarius recommends reading some of Conal's even older stuff.
17:15:57 <eyebloom> Phillippa: What I'm writing is a lot more complicated than the examples.
17:16:08 <conal> ddarius: what old stuff do you like?
17:16:24 <Philippa> eyebloom: Doesn't matter
17:16:35 <Philippa> I mean, obviously it makes things a bit more painful for you right now, but even so
17:16:44 <ddarius> conal: The "Semi-Functional Implementation of a Higher-Order Logic Programming Language" paper is good.
17:16:50 <conal> ddarius: ah :)
17:17:04 <hpc> Eduard_Munteanu: there's a note in the trac wiki about it, but it's involved
17:17:07 <conal> that *is* an oldie.
17:17:09 <hpc> http://hackage.haskell.org/trac/ghc/wiki/Debugging/CompiledCode?redirectedfrom=DebuggingGhcCrashes
17:17:09 <eyebloom> Most of my types have four primitive type parameters so it gets a little out of control.
17:17:12 <Philippa> I mean, if you're trying to debug a KLoC or greater all at once then yeah, you're in trouble for letting things get that bad...
17:17:32 <Eduard_Munteanu> Ah.
17:17:57 <eyebloom> conal: Qt is not GHCi friendly view FFI?
17:18:00 <eyebloom> *via
17:18:11 <elliott__> Wrapping C++ libraries to Haskell is a huge pain
17:18:12 <Philippa> eyebloom: eh. You should see the time I accidentally introduced polymorphic recursion because I'd refactored some stuff to a type alias /but missed out the renaming in the recursive instance of the datatype/
17:18:13 <conal> eyebloom: i don't know. i haven't tried.
17:18:16 <elliott__> I gather
17:18:22 <DukeDave> Ooh, FFI and C++ conversation
17:18:26 * DukeDave is glad he has a beer
17:18:27 <elliott__> eyebloom: You probably don't want your types to have four parameters.
17:18:31 <ddarius> C++ libraries in general aren't very friendly too any language (including C++) and Qt isn't even C++.
17:18:41 <elliott__> eyebloom: That + way too many class contexts strongly sets off my overcomplication alarms.
17:19:16 <Philippa> elliott__: it does make you wonder if someone's got half way through encoding something nasty and missed a hugely simplifying abstraction, certainly
17:19:19 <dobblego> dcsobral: how goes the learning? what are you up to?
17:19:54 <elliott__> Philippa: Or perhaps is using (Num a) => Foo ... a ... everywhere because they haven't realised they should just use Integer :)
17:20:08 <Philippa> or just not be writing the damn annotation
17:20:14 <eyebloom> elliott: It may be that my algorithm is overcomplicated, but I'm also plumbing just about everything rather than using my own typeclasses at this point because I'm really trying to understand the design a little bit as I'm writing.
17:20:34 <Philippa> there's a lot to be said for not annotating until the typechecker pukes on something
17:20:52 <Philippa> (and then commenting out whatever makes it puke and finding out the types you've got and whether they're what you expected)
17:21:01 <elliott__> eyebloom: Yeah, I would strongly suggest reducing the number of type parameters. If you hpaste.org some code we might be able to help.
17:21:02 <hpc> Philippa: it is sometimes really hard for others to read that code without the signature to help out
17:21:11 <wavewave> I did C++/haskell conversion... it ends up with making my own template program for that.
17:21:17 <hpc> especially because usually others only read code when a bug pops up
17:22:01 <wavewave> see my HROOT code on hackage. ;-)
17:22:58 <Philippa> hpc: sure. But you do that once you've got something stable enough you don't mind putting your name to it, IYSWIM?
17:23:15 <saml> hey, data A = A { version :: (IsString a) => a }   why can't I do this?
17:23:31 <elliott__> saml: you need "forall a. (IsString a) => a" BUT you really don't want to do that.
17:23:34 <saml> is there a way to do it?  I'm writing HttpResponse.. and I want to use IsString
17:23:37 <eyebloom> elliott__: Here is just an example of some of my type signatures http://hpaste.org/51936
17:23:39 <elliott__> That is _equivalent_ to data A = A { version :: String }
17:23:45 <elliott__> erm
17:23:49 <elliott__> not quite I guess
17:23:50 <elliott__> hmm
17:23:52 <elliott__> you don't want it though :)
17:24:04 <elliott__> eyebloom: Ouch. Can you show us your actual type definitions?
17:24:08 <elliott__> Those are _definitely_ overgeneralised.
17:24:18 <wavewave> saml: you seem to want Data type context.
17:24:18 <saml> data A (IsString a) => a = A { version :: a}   ?
17:24:22 <eyebloom> one sec
17:24:24 <elliott__> wavewave: definitely not.
17:24:29 <elliott__> saml wants existential quantification
17:24:32 <dobblego> data A a = A { version :: a }
17:24:36 <wavewave> saml that's obsolete
17:24:42 <elliott__> saml: data A = forall a. (IsString a) => A { version :: a }
17:24:42 <saml> I want my HttpResponse to use String, ByteString, Text... etc
17:24:45 <elliott__> saml: but please do not do it :)
17:24:45 <dobblego> op :: IsString a => A a
17:24:49 <elliott__> yeah what dobblego said is reasonable
17:24:51 <hpc> saml: you don't want a class context on a data declaration
17:25:07 <dobblego> saml: put the context (IsString) on the operations, not the data type
17:25:17 <saml> coolio thanks
17:25:18 <hpc> eyebloom: oh god, your code looks like edwardk's, and not in the good way
17:25:29 <hpc> (;))
17:25:45 * ski . o O ( "Socrates: What Aristotle is going to say is false. Aristotle: What Socrates just said is true." )
17:25:53 <eyebloom> http://hpaste.org/51937
17:26:06 <elliott__> eek
17:26:31 <elliott__> For a start, you should probably use explicit data types rather than tuples when you have more than two elements :P
17:26:38 <elliott__> But you really want to cut down on your type parameters there.
17:26:51 <elliott__> You probably want no more genericity than is necessary.
17:27:16 <wavewave> eyebloom: you may need context synonyms in ghc 7.4
17:27:30 <elliott__> wavewave: I doubt it...
17:27:32 <wavewave> to shorten your context.
17:27:38 <eyebloom> I don't think I can at this point. I'm doing a very specific type of subgraph traversal that requires two different types of graphs.
17:27:41 <elliott__> I think there's a design flaw here, that shouldn't just be patched away :)
17:28:13 <elliott__> eyebloom: Well, for a start, the gr parameter.
17:28:19 <elliott__> Can you replace that with an explicit graph type?
17:28:22 <Philippa> eyebloom: write your own type classes
17:28:40 <Philippa> they'll have most of the Eq etc stuff as superclass requirements or similar
17:28:43 <Philippa> hi liyang
17:28:57 <elliott__> eyebloom: All the Shows are definitely unnecessary though
17:29:04 <elliott__> That's not how you should be debugging :P
17:29:20 <elliott__> Without them the signature is much more reasonable although still a little complicated for my tastes
17:29:26 <elliott__> eyebloom: btw, [x] ++ xs --> x : xs
17:29:29 <elliott__> in your http://hpaste.org/51936
17:29:37 <eyebloom> elliott__: It's the compiler that told me to make them.
17:29:48 <elliott__> eyebloom: Remove the debugging code you have
17:29:56 <elliott__> There's a better way for sure
17:30:00 <conal> i know it's off-topic, but i could use a basic pointer in using git. i have a repo (not on github) that i've cloned (on a different machine), and i can commit changes & push. on the master side, 'git log' shows my commit, but i don't know how to then get the commit to show up in my working files. and maybe there's a better workflow.
17:30:16 <kmc> you could ask #git
17:30:20 <elliott__> conal: git merge?
17:30:23 <wavewave> ahh, is all typeclasses only for debugging?
17:30:37 <conal> elliott__: i'll take a look. thx.
17:30:42 <elliott__> conal: git pull is git fetch + git merge
17:30:42 <saml> hey, do I use String.. and pack to ByteString?  or do I use ByteString from the beginning (doing all operations like concatenation..  in ByteString) ?
17:31:01 <elliott__> saml: use bytestring, lazy bytestring if you concatenate a lot
17:31:02 <parcs> yeah, #git is a friendly community
17:31:11 <saml> elliott__, thanks
17:31:17 <kmc> saml, String holds characters, ByteString holds bytes
17:31:23 <kmc> so there are many incompatible ways to convert between t hem
17:31:24 <elliott__> saml: np
17:31:30 <monochrom> if you have uninterpreted bytes, use ByteString throughout. if you have characters, use String or Text
17:31:34 <eyebloom> wavewave: Correct. Which leads back to my main issue which was in order to use the upstream show, the typeclasses come all the way down the chain.
17:31:43 <conal> elliott__: do you mean instead of pushing?
17:31:43 <kmc> http://hackage.haskell.org/packages/archive/text/0.11.1.5/doc/html/Data-Text-Encoding.html
17:31:48 <elliott__> monochrom: I think it's more "do I concatenate strings then pack them or use BS throughout" rather than "bytestring or text"
17:31:53 <elliott__> conal: I meant on the master end
17:32:07 <elliott__> conal: if they're in git log but don't show up in the working files, then you need to git merge or git checkout
17:32:29 <elliott__> conal: OTOH, I wouldn't even have a checkout on the master end, I'd just have a bare foo.git directory... I guess you could be working on the master for some reason but I dunno why
17:32:43 <elliott__> but yeah, I don't think "git push" does a checkout on the destination
17:32:50 <ClaudiusMaximus> host1$ git push host2 host1branch   host2$ git merge host1branch -- is my workflow, probably flawed
17:32:50 <elliott__> so you have to do that yourself if you want the changes in the working copy there
17:32:52 <conal> elliott__: part of the oddity of my set-up is that the clone machine can see the master but not vice versa.
17:32:55 <conal> oops
17:32:56 <eyebloom> wavewave: Even if it's just Eq b, and Eq b' I find it annoying to have to keep defining that constraint for every function.
17:33:00 <conal> elliott__: part of the oddity of my set-up is that the clone machine can see the master but not vice versa.
17:33:04 <monochrom> elliott__: what kmc says. it's almost like "Int array vs Double list"
17:33:12 <elliott__> monochrom: yeah, 'strue
17:33:16 <saml> is there sprintf  for ByteString?
17:33:19 <elliott__> conal: huh
17:33:23 <conal> all i'm trying to accomplish right now is the ability to edit on either machine and stay in sync.
17:33:30 <monochrom> if it's raw bytes, you shouldn't even have intermediate String
17:33:40 <elliott__> conal: Well, "pull" is nicer than "push". But you can't pull with a weird network like that.
17:33:41 <parcs> conal: i would use a bare central repo that both machines clone out of and push to
17:33:46 <elliott__> conal: "git merge" without arguments will do what you want, I think
17:33:58 <saml> I want to do...    "HTTP/%s %d OK\r\n ...." % (version, status, )
17:34:05 <elliott__> conal: on the master, after a push
17:34:08 <elliott__> (from the clone)
17:34:09 <monochrom> and if it's characters, then the choice is Text throughout vs String intermediates then pack to Text
17:34:12 <parcs> conal: pushing to a non-bare repo is confusing and by default disallowed i think
17:34:39 <conal> parcs: what's a bare repo?
17:34:46 <Philippa> eyebloom: you don't have to define shit. Comment it out, let it compile, fill it back in with what :t tells you
17:34:52 <parcs> conal: it's a  repo without a working tree
17:34:52 <conal> elliott__: 'git merge' wants an argument of some sort.
17:35:11 <elliott__> conal: git merge HEAD?
17:35:26 <wavewave> eyebloom: I am not opposed to making generic interface as your code. For annoying typeclasses problem, constraint synonym will be a solution within few motnths.
17:35:27 <Philippa> you've only got a problem (that is, a need for requirements) if you use polymorphic recursion, rank-n polymorphism or perhaps one or two other things I've forgotten because IME they're pretty much irrelevant
17:35:38 <conal> parcs: ah. so maybe i ought to have a bare repo *and* a working tree on the master machine?
17:35:40 <elliott__> wavewave: Defining your own class is easier than constraint synonyms
17:35:43 <eyebloom> Phillippa: Like I said, it's the compiler that keeps telling me I need to do it.
17:35:47 <elliott__> yeah I agree with parcs too
17:35:56 <elliott__> it's probably better to keep your master separate from any working copy
17:36:05 <elliott__> conal: then you can just "git pull" from the master in the master-machine working copy too
17:36:08 <Philippa> eyebloom: based on previous, overly-generic annotations, or something else?
17:36:13 <wavewave> elliott__ : that's also true.. agree.
17:36:18 <monochrom> turn on {-# LANGUAGE NoMonomorphismRestriction #-} to waive type signatures?
17:36:22 <Philippa> (are you doing polymorphic recursion?)
17:36:22 <elliott__> Philippa: because eyebloom is inserting debugging code and that causes a wave of synonyms
17:36:24 <elliott__> because it requires show
17:36:37 <Philippa> elliott__: but you /don't need that/ if there aren't any type annotations to start wtih
17:36:38 <Philippa> *with
17:36:41 <elliott__> Philippa: well, sure
17:36:42 <conal> ah, okay. i understand that setup. that's what i'll do. thanks, elliott__ and parcs .
17:36:46 <saml> x |> f = f x    -- is there something like this? is it not recommnded?  instead of  a . b. c $ x,  I would do  x |> c |> b |> a
17:36:47 <elliott__> np
17:37:04 <elliott__> saml: It's not common but some people want it.
17:37:16 <eyebloom> But I understand, this is just a very abstract part of my code, at some point a b a' b' (which are node and edge labels) will all be defined differently by a calling function, so I actually need this.
17:37:16 <elliott__> I would avoid it because it'll confuse people reading your code :)
17:37:30 <wavewave> elliott__ : but sometimes just adding context is needed.
17:37:31 <conal> how would i get my bare repo from my non-bare repo? just remove the working files?
17:37:36 <conal> and then clone?
17:37:51 <elliott__> conal: git clone --bare working master.git
17:37:54 <Philippa> elliott__: I'm totally serious when I say that sometimes, it's better to yank the things and let ghci figure it out. Do your debugging sans annotations, then put them back in again
17:38:02 <elliott__> cd working; set up remotes so that origin is master.git
17:38:10 <elliott__> (man git-remote)
17:38:25 <Philippa> it's just that obviously you have to yank annotations all the way up the chain too
17:38:27 <wavewave> elliott__ : if I do not want instance defeintioin.
17:38:31 <elliott__> (probably git remote set-url origin /path/to/master.git)
17:38:36 <elliott__> wavewave: yeah
17:38:42 <conal> elliott__: thx.
17:38:53 <eyebloom> Phillippa: I've definitely tried that move, it hasn't worked well for me most of the time.
17:38:55 <wavewave> I mean class (context) => typeclass a
17:38:56 <elliott__> master.git isn't a very good name though, I'd call it project-name.git :P
17:39:11 <wavewave> is not the same as f :: (context ) => ....
17:39:30 <elliott__> It isn't?
17:39:39 <elliott__> It is if you define instances of the typeclass for all your types.
17:39:44 <monochrom> master.git is a good name because you hardcode it in shell scripts and shell aliases and it works polymorphically for all projects
17:39:52 <wavewave> subclass is not synonym class.
17:39:54 <Philippa> eyebloom: the face you're using type synonyms rather than concrete types probably isn't helping you, FWIW
17:40:29 <elliott__> monochrom: But it can contain branches other than master.
17:40:32 <elliott__> There's a clash of terminology.
17:40:36 <wavewave> strictly smaller than synonym : although you can make them almost equal by making every class you need as instance
17:40:42 <Philippa> if they're concrete types then you can get the typeclass machinery to play ball with them reliably
17:40:52 <wavewave> s/class/type
17:41:56 <wavewave> I am not sure tht I can explain well here but I mean logically they are different.
17:42:26 <eyebloom> Phillippa: Right but doesn't that help you see what is essential in your algorithm. generic types and typeclasses like Ord and Eq to me help you see clearly just exactly what is needed from each type. It's just annoying that things get so verbose.
17:42:31 <saml> wait... IsString is very limiting..
17:42:44 <Philippa> eyebloom: Those concrete types can still be polymorphic as you like
17:42:50 <wavewave> but.. practically I agree with elliott__ . making my own typeclass and define instances for that is okay.
17:42:54 <saml> it does not have definition for length, isEmpty, concat.. etc
17:43:08 <saml> is there a reason for it? should I write such typeclass?
17:43:11 <elliott__> saml: it's not "a string type", it's "string literals".
17:43:25 <saml> is there a typeclass for string types?
17:43:27 <elliott__> saml: I would use ByteStrings: an HTTP response should be encoded.
17:43:28 <Philippa> they're just not synonyms any more, they have identity of their own - which means that the type class machinery can confidently spot what the intention was
17:43:40 <Philippa> saml: IsString?
17:43:41 <elliott__> It's wrong to use a Text or String, because what encoding do you send it down the wire as?
17:43:44 <saml> elliott__, how about Text?
17:43:50 <elliott__> saml: <elliott__> It's wrong to use a Text or String, because what encoding do you send it down the wire as?
17:43:51 <elliott__> :)
17:43:53 <elliott__> They're Unicode.
17:44:02 <elliott__> An HTTP response should have its data encoded (or it might even be binary and so not textual at all).
17:44:26 <saml> I remember someone said only Text should be used
17:44:32 <saml> for the future
17:44:35 <elliott__> For text.
17:44:39 <elliott__> Text is only for Unicode text.
17:44:43 <elliott__> ByteString is for bytes.
17:44:46 <elliott__> Well. Octets.
17:44:48 <monochrom> yes, I said that. until just before output, of course
17:45:14 <Philippa> eyebloom: sorry, that's probably culture clash - "concrete" isn't the same as "monomorphic" around here
17:45:19 <saml> so, .. i should pack to ByteString just before sending.
17:45:34 <saml> and use Text internally.. for various processing?
17:45:42 <monochrom> well, it becomes "encode" rather than "pack". choice of UTF-8 or GB18303
17:45:43 <saml> or should I just use String internally?
17:45:46 <dcsobral> Is there a block-comment?
17:45:47 <monochrom> err, GB18030
17:45:49 <elliott__> You would not use Text at all if you are sending a binary file.
17:45:53 <elliott__> dcsobral: {- ... -}. People don't really use it much.
17:45:59 <elliott__> Apart from file headers.
17:46:04 <Philippa> I use it
17:46:14 <elliott__> OK, I don't see people using it much :P
17:46:16 <monochrom> I swear by {- -}
17:46:17 <eyebloom> Phillippa: What do you mean by concrete can still be polymorphic?
17:46:22 <saml> ah that makes sense. thanks
17:47:36 <Philippa> eyebloom: "Concrete" just means you can have a value of that type in your hand, as it were. [1,2,3] :: [Integer] is completely monomorphic and concrete...
17:47:56 <monochrom> -- is safer for "commenting out code", sure. but that's hardly the major kind of comments
17:48:14 <Philippa> eyebloom: Maybe a is still 'concrete', it's a matter of where the a came from. Type synonyms are... not so good for the type class machinery though, because there's nothing to mark out /intent/
17:48:45 <monochrom> if your comments actually explains things, remembering to add yet another -- for every extra line is frustrating
17:48:55 <Philippa> monochrom: agreed entirely
17:49:27 <monochrom> plus when it comes to haddock, {- -} is easier to control what haddock thinks
17:49:42 <elliott__> adding two spaces inside {--} for each line is frustrating too :P
17:50:15 <monochrom> two spaces and nothing else? essentially empty comments? well don't write them, ever.
17:50:20 <eyebloom> Phillippa: Basically I have some very generic graph traversals that will sometimes work on graphs where the labels are numbers, [Char], and Bool depending on the type of function calling the traversal.
17:50:39 <Philippa> roconnor_: Are you up for making Multiplate support subcategory encodings via ConstraintKinds if we get standard libs for doing such stuff with? I'm itching to pull some filthy tricks with plate transformers once I'm allowed that little bit of extra knowledge
17:51:02 <Philippa> eyebloom: yes, that was obvious
17:51:09 <eyebloom> Phillippa, I don't see a way around using a type variable.
17:51:10 <elliott__> monochrom: No, I mean
17:51:15 <Philippa> eyebloom: and I didn't say you shouldn't
17:51:16 <elliott__> {-\n  a\n  b\n-}
17:51:30 <elliott__> {--} has almost as much overhead as -- for each line, only one byte less
17:51:35 <elliott__> Unless you don't indent them at all, which is... weird
17:51:35 <Philippa> what I'm saying is you shouldn't be using type synonyms. Less type, more newtype or data
17:51:46 <eyebloom> I see
17:52:19 <Philippa> one advantage of doing that is you can then put the constraints in those datatypes' constructors instead. Sneaky, but saves you typings later on
17:52:20 <eyebloom> So then how would you translate Sg gr a b a' b' to a concrete type?
17:52:30 <eyebloom> Sorry
17:52:39 <eyebloom> type Sg gr a b a' b'
17:52:40 <monochrom> well you don't need any of the spaces there. you can keep the newlines. {-a\nb\n-} or even {-a\nb-}
17:53:11 <eyebloom> or: type Sg gr a b a' b' = (gr a' b', [Node], gr a b)
17:53:20 <eyebloom> that's the whole line sorry.
17:53:21 <Philippa> data Sg gr a b a' b' = SG (gr a' b') Node (gr a b)
17:53:25 <Philippa> for a first pass
17:53:32 <eyebloom> ok
17:53:38 <ski> s/Node/[Node]/ ?
17:53:42 <saml> data A = A | B {x::Y}     f :: A -> Foo.      f (B {x :: x})  ?
17:53:47 <Philippa> ski: yep, my bad
17:53:51 <saml> how can I write pattern matching for such record?
17:54:02 <eyebloom> Keep in mind I'm new: What does that buy me?
17:54:06 <Philippa> only, now you can put Eq constraints on stuff on the SG constructor
17:54:06 <saml> ah sorry. "record" was the term i was looking for
17:54:07 <ski> saml : bad syntax
17:54:19 <Philippa> data Sg a ... = Eq a => ...
17:54:34 <Philippa> (someone else can tell you which extensions to turn on for that)
17:54:43 <wavewave> Philippa : isn't that deprecated?
17:54:44 <elliott__> I'm not sure it needs any
17:54:45 <ski> or, hm, maybe that all wasn't supposed to be part of the same 'data' declaration ..
17:54:49 <elliott__> wavewave: no, datatype contexts are
17:54:51 <elliott__> those look like
17:54:53 <elliott__> data (Eq a) => Sg ...
17:55:10 <eyebloom> Phillipa: can you write that out without the ellipsis?
17:55:20 <ski> saml : you can say `f (B {x :: xValue}) = ..xValue..'
17:55:23 <hpaste> monochrom pasted “comparing -- and {- -} for haddock” at http://hpaste.org/51938
17:55:29 <deech`> Hi all, are there any common idioms/advice for translating C++ to Haskell? I don't know C++ very well, but I do know some Haskell and Java.
17:55:39 <ski> saml : er, sorry, should be : you can say `f (B {x = xValue}) = ..xValue..'
17:55:46 <elliott__> deech`: delete all the code and start again from the problem statement
17:55:53 <wavewave> hmm I am confused..  I need an experiemnt
17:56:10 <monochrom> in my paste, if you use -- for haddock, there are compulsory newlines you must put in. if you use {- -}, no compulsory newlines
17:56:30 <deech`> elliott__: Tens of thousands of lines unfortunately. It will have to be incremental.
17:56:37 <ski> wavewave : `data Sg a ... = Eq a => ...' is not deprecated, `data Eq a => Sg a ... = ...' is (or ought to be)
17:56:38 <monochrom> actually, s/newlines/blank lines/
17:56:44 <elliott__> deech`: Sounds like a misguided project to convert it incrementally.
17:56:55 <elliott__> The structure of the code is not likely to cross over well a tall.
17:56:58 <ski> (wavewave : if the former is allowed, you need an extension for it)
17:57:05 <elliott__> Maybe others are more optimistic than me.
17:57:06 <eyebloom> deech: Look for side effects and migrate them out of functions. Translate loops to recursion.
17:57:38 <elliott__> monochrom: well sure... there have to be better ways to sell block comments than being able to collapse some haddock directives at the start into one confusing line :P
17:57:38 <deech`> eyebloom: Yes, that's great advice.
17:57:50 <elliott__> eyebloom: Don't translate loops to recursion.
17:57:59 <elliott__> Recursion is not what you want at least seventy percent of the time.
17:58:06 <elliott__> We like combinators :)
17:58:18 <monochrom> sure, certain blank lines help me. but ought not be compulsory. I may like to add a blank line between $sec2 and * Types. but no one should force me to do more than that.
17:58:28 <eyebloom> Ok translate loops to mappings.
17:58:40 <elliott__> Not every fold is a map :-P but alright
17:58:53 <eyebloom> Which are recursive inside anyways :p
17:58:59 <deech`> I'm just looking for every opportunity to get Haskell into the neuroscience environment.
17:59:12 <wavewave> ski: oh.. I thought for existential type, forall was mendatory..
17:59:27 <monochrom> no, you got it backwards. block comments don't need selling. sell me -- comments. tell me what it does better apart from commenting out code temporarily.
17:59:28 <Philippa> eyebloom: translate loop /structures/ to recursion, then make those HOFs
17:59:53 <Philippa> I use general recursion more than I should, but mostly it's when I'm feeling too lazy to look up the right library function
18:00:03 <elliott__> monochrom: Shrug, I just like them aesthetically. It is no big deal. Wadler's law and all.
18:00:13 <ski> wavewave : *nod*, not an existential
18:01:24 <wavewave> ski: not an existential.. that's right.. hmm. I am still confused about the meaning.
18:01:31 <monochrom> ok, but you now know that more people than you think use {- -}
18:01:49 <wavewave> ski: data Test a = (Foo a ) => MkTest a
18:02:02 <wavewave> then MkTest :: (Foo a) => a -> Test a
18:02:05 <wavewave> is it right?
18:02:13 <Philippa> eyebloom: the thing about recursive /inside/ is that so long as you know it's the right pattern of behaviour you don't care about unpacking the recursion yourself. Really, combinators're better when you can
18:02:14 <ski> yes, i think so
18:02:18 <elliott__> monochrom: Well, two more. :p
18:02:37 <ski> (wavewave : note that i don't recall if that's allowed by any extension, but if it is, it ought to do that)
18:02:52 <wavewave> how about data (Foo a) => Test a = MkTest a ?
18:03:08 <wavewave> MkTest is still :: (Foo a) => a -> Test a ?
18:03:16 <ski> that's bad (because of how HAskell 98 specifies it to work)
18:03:56 <eyebloom> I had been wondering about the difference between data and type. They don't seem like orthogonal concepts to me.
18:04:17 <ski> the problem is that if you doo `foo (MkTest a) = ..a..', then that will still infer `foo :: Foo a => Test a -> ..a..', i.e. *requiring* the caller to provide `Foo a' anyway
18:04:18 <eyebloom> data is just leaves on the type tree basically.
18:04:32 <wavewave> type = type to type function , data = type to value function.. in some sense.
18:04:58 <benmachine> wavewave: that's weird
18:05:11 <ski> instead of not requiring the caller to provide `Foo a' (since that must have been the case to be able to use the constructor), and then instead the pattern-matching should provide `Foo a' inside `..a..'
18:05:24 <benmachine> the important thing about 'type' i.e. type synonyms is that they're just a bit like macros, and don't add any expressivity at all
18:05:40 <benmachine> they're purely for readability of code
18:06:00 <ski> eyebloom : `type' just gives new names to old types, `data' (and `newtype') constructs *new* types, otoh
18:06:01 <benmachine> 'data' actually creates a new type and its constructors
18:06:06 <deech`> Does qtHaskell have a repository? I was wondering if there was any continued development on it.
18:06:30 <benmachine> as a general rule if you can't do something without 'type' you can't do it with 'type'
18:06:58 <eyebloom> what is the difference between data and newtype?
18:07:05 <coppro> w/in 15
18:07:13 <deech`> eyebloom: newtype can only take one constructor
18:07:16 <benmachine> (so you can't for example say type Foo a = Char and then declare instance Monad Foo, even though it looks like it should be right)
18:07:27 <elliott__> deech`: One constructor with one field.
18:07:28 <ski> `newtype' is like `data', but always haves one constructor taking one argument -- there's also a small semantic difference
18:07:29 <wavewave> ski: okay, I see.. I thought both are deprecated.. it's not. thanx.
18:07:30 <elliott__> And its field is strict.
18:07:34 <benmachine> http://haskell.org/haskellwiki/Newtype
18:07:35 <dobblego> eyebloom: a newtype only has one constructor with one argument and it is strict in that argument
18:07:43 <benmachine> I wrote that article but I'm not sure it's very good ^
18:07:50 <eyebloom> why have it then.
18:07:51 <benmachine> elliott__: kinda-sorta
18:08:12 <deech`> eyebloom: I remember reading that it was a little more efficient, although I can't remember why.
18:08:12 <elliott__> eyebloom: Because the runtime representation of a newtype is identical to its field.
18:08:16 <eyebloom> Why not just have data, and some are defined with one constructor
18:08:16 <dobblego> eyebloom: the compiler can freely remove the indirection level, but the programmer can get some type-saety
18:08:18 <elliott__> That means there's absolutely no overhead.
18:08:21 <benmachine> it's strict inasmuch as newtype Blah = MkBlah Int has MkBlah _|_ = _|_
18:08:25 <elliott__> And there's no additional lazy thunks.
18:08:27 <benmachine> but pattern-matching on it is not strict
18:08:30 <ski> the intension is that upon type-erasure, using `newtype Abstract = Wrap Representation', a value of type `Abstract' will be represented in the same way as a value of type `Representation'
18:08:33 <elliott__> benmachine: Well, close enough :P
18:08:48 <eyebloom> can
18:09:02 <ski> (of course there is no requirement for that exact operational semantics, only that the corresponding denotational semantics hold)
18:09:06 <eyebloom> can't the compiler just figure that out....
18:09:13 <eyebloom> I'm guessing no.
18:09:28 <benmachine> eyebloom: no, because the difference has an impact on the meaning of your program
18:09:32 <elliott__> eyebloom: It would change semantics.
18:09:40 <ski> `newtype' is not really an "optimization" of `data', if that's what you're thinking
18:09:42 <benmachine> eyebloom: in general, optimisations should make things faster, but not change what they do
18:10:03 <benmachine> whereas there is a small but unignorable difference in how data and newtype behave with pattern matching
18:10:09 <ski> s/faster/faster and\/or use less memory/
18:10:19 <benmachine> sure
18:10:28 <wavewave> I cancel my type-to-type and type-to-data statement.. that's simply wrong.. I am confused with typeclass and GADT relation.
18:11:37 <ski> `newtype' is e.g. useful if you want basically a `type', but can't use that because you need to make an `instance', or to have a recursive type
18:11:51 <ski> @src Mu
18:11:51 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
18:11:53 <ski> e.g.
18:12:21 <benmachine> newtypes are also "safer" than type synonyms in the sense that they must be explicitly wrapped or unwrapped
18:12:32 <benmachine> so you can create abstract types with newtype
18:12:51 <benmachine> (by hiding the constructors)
18:13:14 <dcsobral> Are case expressions rare in Haskell code?
18:13:16 <ski> considering `Mu Maybe', that has elements `_|_',`In Nothing',`In (Just _|_)',`In (Just (In Nothing))',`In (Just (In (Just _|_)))',&c.
18:13:24 <wavewave> ski: what happen if I define  Mu in terms of data?
18:13:40 <ski> note that `In _|_' is not another element, since that is the same as `_|_' -- but it wouldn't be if we used `data' instead
18:14:32 <ski> so, we get basically `type Mu f = f (Mu f)', here, except we can't actually do cyclic type-synonyms
18:14:40 <ski> (O'Caml supports that, though)
18:14:46 <benmachine> dcsobral: this depends a bit on style, but I use them all the time
18:15:22 <ski> (the reason why it's not allowed in mosty type systems is that it can make common errors harder to find, so quality of type checking is worse)
18:15:26 <benmachine> ski: it would be if we used data instead, you mean?
18:15:45 <benmachine> oh wait
18:15:47 <ski> benmachine : hm, which statement are you referring to ?
18:16:01 <wavewave> ski: haskell disallows type Mu f = f (Mu f) because it has a strictly levelled kind system, is it right ?
18:16:05 <benmachine> ski: I'm getting confused because In _|_ would be another element if we used data
18:16:10 <benmachine> so it wouldn't be the same as _|_
18:16:13 <elliott__> dcsobral: reasonably common
18:16:41 <benmachine> wavewave: it's not about kinds, you can kind that expression fine
18:16:51 <benmachine> it's just that type synonyms are intentionally quite restrictive
18:16:52 <ski> wavewave : it disallows (directly) cyclic types, since allowing them would mask common errors, inferring strange cyclic types instead
18:16:56 <ddarius> wavewave: No.  The semantics of type declarations is essentially syntactic unfolding.
18:16:58 * hackagebot dpkg 0.0.1 - libdpkg bindings  http://hackage.haskell.org/package/dpkg-0.0.1 (ClintAdams)
18:17:03 <ski> wavewave : every cycle have to pass through a `data' or a `newtype'
18:17:10 <monochrom> I use "case" when in the middle of a do-block
18:17:15 <benmachine> the idea is that right at the beginning of type checking you can immediately expand and then discard all type synonyms
18:17:30 <benmachine> (although in practice you probably don't, because you want good error messages)
18:17:31 * ski can't recall whether termination of type checking is also an issue here or not
18:18:03 <ddarius> ski: It isn't.  At least, not factoring in type classes and various other extensions.
18:18:40 <saml> hey, how can I convert   Data.ByteString.Lazy.Internal.ByteString -> Data.ByteString.ByteString
18:18:49 <ski> ddarius : that's what i seemed to recall .. (judging from how O'Caml can allow them), though i was unsure
18:19:12 <benmachine> saml: fromChunks or toChunks, I forget which
18:19:18 <saml> thanks
18:19:24 <parcs> saml: Data.ByteString.concat . Data.ByteString.Lazy.toChunks
18:19:27 <benmachine> toChunks, I think
18:19:28 <benmachine> yeah
18:20:33 * ski wonders whether saml really wants to concatenate all the chunks (as opposed to doing something for every chunk)
18:20:47 <wavewave> ddarius, ski: I see , thnx. f :: *-> * , Mu f :: *, then f (Mu f ) :: *.. so they are okay..
18:21:11 <ski> wavewave : *nod*, so what's the kind of `Mu' ?
18:21:48 <companion_cube> Mu f = f (Mu f) may prevent unification with other types, right?
18:21:53 <wavewave> ski : (*->*)->* ?
18:22:01 <ski> exactly
18:22:03 <companion_cube> since there is a occur check
18:22:03 <ddarius> :t fix
18:22:04 <lambdabot> forall a. (a -> a) -> a
18:22:36 <ski> companion_cube : well, the point was that to allow `type Mu f = f (Mu f)', one would need to remove the occurs-check (as `ocaml -rectypes' does)
18:23:01 <companion_cube> uh, ok
18:23:24 <companion_cube> then you cannot guarantee termination of type check, but if you now what you're doing...
18:24:05 <ski> companion_cube : well, you can unify rational terms too, if you're a little bit careful ..
18:24:09 <wavewave> I still didn't get the relation between this and untyped y combinator is  not expressbile. would you explain this?
18:24:19 * ski . o O ( `newtype k (Mu f) = InCxt (k (f (Mu f)))' )
18:26:02 * ski supposes wavewave really meant "y combinator" by "untyped y combinator"
18:26:20 <ski> (such as the turing or the ackerman fixpoint combinator)
18:26:52 <ski> (also, those *are* expressible, if you use a recursive *type*)
18:26:53 <wavewave> y = \f-> (\x -> f (x x) ) (\x -> f (x x) )
18:27:31 * Philippa rather likes Y expressed in terms of S
18:27:38 * ddarius decides that Jeremy Singer, Gavin Brown, Mikel Lujn, Adam Pocock, and Paraskevas Yiapanis have no fucking clue what "object-orientation" is.
18:27:39 * ski grins
18:27:55 <monochrom> who is Jeremy Singer?
18:27:58 <ski> ddarius : what book are those authors of ?
18:28:05 <ski> (or paper ?)
18:28:24 <Philippa> ski: I take it you've seen that version of Y?
18:28:30 <ddarius> They are the authors of a paper titled "Fundamental Nano-Patterns to Characterize and Classify Java Methods"
18:28:30 <wavewave> y must be a type of Mu....
18:28:44 <saml> http://hpaste.org/51939    how can I read from Socket?   line 24
18:29:00 <monochrom> perhaps it only requires Java clue, not OOP clue...
18:29:00 <saml> I want the server to respond with http request
18:29:02 <ski> wavewave : you may be interested in seeing roconnor_'s "Y Combinator in Haskell" at <http://r6.ca/blog/20060919T084800Z.html>
18:29:14 <ski> Philippa : yeah :)
18:29:20 <wavewave> hmm  am I understnanding this correctly.
18:30:04 <elliott__> saml: see ByteString
18:30:15 <wavewave> ski: oh. thanks
18:30:15 <elliott__> hGet, hGetSome, etc.
18:30:27 <Philippa> ski: especially fun combined with the other way of writing the definition of a fixpoint, of course. It's the version I pull out around mathematicians
18:30:36 <ski> wavewave : btw, the type `Mu' in that post is unrelated (well, not that related, anyway) to the above `Mu' -- i would call the one in that post `Santa' instead
18:31:01 <saml> then i need to write http parser.. request dispatcher.. database access.. html template.. then I have Haskell Enterprise
18:31:18 <saml> i don't think i can all of them today
18:31:27 <elliott__> There exist web frameworks, you know :)
18:31:44 <wavewave> ski: yeah I see it.
18:31:47 <saml> snap and warp were difficult to read
18:32:31 <wavewave> Mu plays a role like a blocker in type check system. hmm
18:32:32 <saml> i want to create Haskell Enterprise, meaning something easy to read and maintain... sacrificing web scale compatible performance
18:32:43 <monochrom> I think it's easier to just say: Y is not expressible in System Fω (for example). System Fω's types have more flexibility than Haskell's if you ignore Haskell's recursive types. It is not so clearcut what to say about Y and Haskell.
18:33:36 <ddarius> saml: Isn't that the opposite of what "Enterprise" means?
18:33:44 <elliott__> ddarius: I was just thinking the same thing :)
18:33:45 <monochrom> you have "newtype X = ... X ..." in Haskell, and that certainly helps write a modified Y
18:33:56 <Philippa> monochrom: really the fun with haskell's in ripping the fixpoints off things, anyway. I'd sorta like a way to be able to do that automatically for things that were declared in a recursive let block
18:34:20 <ski> wavewave : see <http://en.wikipedia.org/wiki/Curry%27s_paradox> .. hm, they've changed the wording :(, before it was "If this sentence is true, then Santa exists."
18:34:26 <saml> is this good style:  import Network.Socket (accept, withSocketsDo, sClose)    ?
18:34:32 <elliott__> saml: sure
18:34:39 <elliott__> ski: It's for the children :P
18:34:53 <elliott__> ski: Now /I/ raised my children believing Germany borders China, so this is quite a problem...
18:34:56 <saml> the reason why I did that is because when I do  :load Main.hs in ghci, I get to do :t accept
18:35:01 <ski> Philippa : by the "other version", do you meant the ackerman(sp ?) one ?
18:35:10 <elliott__> saml: well don't import things you don't use
18:35:19 <ddarius> What about the geography challenged logicians?
18:35:29 <saml> if I just   did  import Network.Socket,  ghci won't let me :info accept.
18:35:36 * monochrom 's favourite is newtype US'Economy = Ctor (Money -> US'Economy)
18:36:21 <saml> an IDE will be nice.. that manages import
18:36:46 <ClaudiusMaximus> @hoogle accept
18:36:47 <lambdabot> Network accept :: Socket -> IO (Handle, HostName, PortNumber)
18:36:47 <lambdabot> Network.Socket accept :: Socket -> IO (Socket, SockAddr)
18:36:47 <lambdabot> Network.CGI data Accept a
18:36:55 <Philippa> ski: no, definition (of fix) rather than implementation
18:37:11 <Philippa> ski: fix f = (f . fix) f
18:37:26 <ski> ah, ok
18:37:44 <stribor> if function read takes string and returns type of a.....why then i get interactive error when i do read "something"
18:37:46 <Philippa> which starts to look impressively similar to Y in terms of S and . (with f bound)
18:38:21 <Philippa> it's /much/ more mind-bending than the lots-of-lambdas version
18:38:46 <stribor> oh...ghci doesnt know what to return
18:38:48 <stribor> makes sense
18:38:48 <DanBurton> > read "foo" :: String
18:38:49 <lambdabot>   "*Exception: Prelude.read: no parse
18:39:13 <DanBurton> I guess String doesn't have a read instance?
18:39:15 <monochrom> > read "foo"
18:39:16 <lambdabot>   *Exception: Prelude.read: no parse
18:39:20 <monochrom> > read "()"
18:39:21 <lambdabot>   ()
18:39:24 <monochrom> \∩/
18:39:33 <monochrom> String has a read instance
18:39:46 <monochrom> > read "\"hi\"" :: String
18:39:47 <lambdabot>   "hi"
18:40:41 <ClaudiusMaximus> i have some code like  fromIntegral . round  that I changed to  fromIntegral . (id :: Int -> Int) . round  to avoid ambiguity - looks ugly to me, but i didn't think of a cleaner solution yet
18:40:46 <stribor> >read "5" +2
18:41:19 <stribor> .,.
18:41:19 <DanBurton> > read "5" + 2
18:41:20 <lambdabot>   7
18:41:24 <DanBurton> space after >
18:41:39 <stribor> > read "5" + 2
18:41:40 <lambdabot>   7
18:41:47 <stribor> DanBurton: thanks :)
18:41:50 <ddarius> ClaudiusMaximus: If you are going to do that, why not give round or fromIntegral the type signature?
18:42:06 <monochrom> make a "roundInt x = round x :: Int"
18:42:07 <ddarius> Or at least define: asInt :: Int -> Int; asInt = id
18:42:09 <wavewave> ski: Now I got a better understanding of data type context..and why it should be disallowed.
18:42:29 <wavewave> ski: data (Foo a) => Test2 a = MkTest2 a
18:43:02 <ski> wavewave : well, afaiui, it's not so much that it should be disallowed as the fact that the Haskell 98 specification of it is not very useful
18:43:04 <wavewave> ski: this must be interpreted as MkTest2 :: a -> (Foo a) => Test2 a
18:43:19 <DanBurton> :t round
18:43:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:43:28 <ClaudiusMaximus> ddarius, monochrom: thanks for two fine suggestions -- i'd probably need ScopedTypeVariables to give explicit type signatures, though
18:43:36 <DanBurton> > (round 2.3) :: Int
18:43:37 <wavewave> so it automatically give rise to MkTest2 :: (Foo a ) => a -> Test2 a
18:43:37 <lambdabot>   2
18:44:38 <wavewave> ski: I mean... it doesn't make mucch sense.. in my point of view.
18:45:11 <ski> Philippa : hm, .. sounds like you maybe want something like `callWithRecursionCatcher :: (((a -> a) -> a) -> a) -> a' to be used as `callWithRecursionCatcher (\recursionCatcher -> ..(recursionCatcher (\f -> ..f..))..(recursionCatcher (\g -> ..g..))..)'
18:45:17 <ddarius> ClaudiusMaximus: Not for the case you mentioned.  If you have a more complex case, then that's probably the thing to do, though I think it's possible to always avoid needing scoped type variables.
18:45:46 * ski thinks one maybe can so that (modulo composable-continaution side-effects), using `shift' and `reset'
18:45:49 <wavewave> good.. every day, I learn something here ;-D
18:46:56 <ski> wavewave : well if you got `MkTest2 :: Foo a => a -> Test2 a' and that worked as expected (which the current design doesn't, when matching on `MkTest2 <pat>'), that would be opk
18:46:59 <ski> s/opk/ok/
18:47:02 <ddarius> Today I learned that a person who goes by the nick wavewave said "good.. every day, I learn something here ;-D"
18:47:32 <ski> in fact, you can get that "proper" behaviour by
18:47:37 <ski>   data Test2 :: * -> *
18:47:38 <elliott__> Today I learned that a person who goes by the nick ddarius said "<ddarius> Today I learned that a person who goes by the nick wavewave said "Today I learned that a person who goes by the nick wavewave *killed for crimes against humanity*
18:47:39 <ski>     where
18:47:46 <elliott__> ("")
18:47:48 <ski>     MkTest2 :: Foo a => a -> Test2 a
18:48:03 <monochrom> Today I learned Mu.
18:48:43 <ddarius> elliott__: I did not say "<ddarius>" anything.
18:48:48 <elliott__> ddarius: I noticed that after pasting :(
18:48:54 <ski> > fix (\x -> "Today i learned that a person who goes by the nick lambdabot said :" ++ show x)
18:48:55 <elliott__> Can you say it so it becomes retroactively true?
18:48:55 <lambdabot>   "Today i learned that a person who goes by the nick lambdabot said :\"Today...
18:49:49 <deech`> Is there a Haskell GUI binding available that allows for easy deployment on a Mac. The few that I've seen seem to require installing X11.
18:49:54 <ski> @remember syntaxfree Many people think the core ideas behind Haskell [snip] In the Deep Complex Universe some Gnomes were having Tangling problems.
18:49:54 <lambdabot> It is stored.
18:50:15 <ski> hum, no
18:50:29 <ski> @remember syntaxfree Many people think the core ideas behind Haskell [snip] In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their problems and as a reward the Tangled Gnomes gave them the Secret of Haskell
18:50:30 <lambdabot> Done.
18:50:51 <comedy> hello?
18:50:59 <ski> hi there ?
18:51:04 <deech`> comedy: hello.
18:52:29 <comedy> deech`
18:52:40 <ski> comedy
18:52:47 <deech`> comedy: sup.
18:53:07 <ski> deech` : inf.
18:53:23 <comedy> -help
18:53:36 <ski> well, what do you want help with ?
18:54:15 <comedy> just come to say hello to you
18:54:25 <comedy> and have a look
18:54:38 * ski takes a good look at comedy
18:54:45 <wavewave> deech`: does Mac not come with X11?
18:54:51 * ski thinks comedy looks funny
18:55:08 <deech`> ski: I bet he gets that a lot.
18:55:30 <fazzone> Is there an obvious way that I'm missing to do a 2D mark-contiguous-region sort of thing?
18:55:33 <ski> comedy : if/when you have any actual questions about Haskell programming, you're welcome to ask them
18:55:37 <deech`> wavewave: No I don't think so. Have you had luck installing wxWidgets or GTK2HS on a Mac?
18:55:51 <wavewave> I am using gtk2hs on mac.
18:55:58 <Philippa> ski: sorry, was talking elsewhere for a bit. A minor tweak on the identity monad coupled with mfix is good enough for my purposes I guess, anyway
18:56:38 <wavewave> deech` : what tool do you use? Fink? MacPorts? or homebrew?
18:56:46 <deech`> wavewave: and what would other mac users have to do to install your app?
18:56:53 <Philippa> or, y'know, transforming the thing by hand and then manually applying fix
18:56:55 <wavewave> deech`  : I am using homebrew and it works fine.
18:57:22 <ddarius> fazzone: Please list all the ways that you are missing and we'll tell which are the obvious ones.
18:57:27 <wavewave> deech`: hmm. that's not clear to me.
18:57:33 <ski> Philippa : hm, are you trying to do something like weave effects into a basically pure recursion ?
18:58:43 <Philippa> ski: that's one of my more common reasons for pulling that one, yeah. Another's relatives of the expression problem
18:58:53 <deech`> wavewave: If you wrote a GTK2HS app and wanted to give it to me, what would I have to do to get it running on my Mac? For example, on Windows I have to install the GTK executable, on Linux it's apt-get libgtk*.
18:59:10 <fazzone> ddarius: I tried some horrid abomination with STArrays but there has to be a neater way
18:59:44 <ski> Philippa : in case you've not seen it before : <http://hpaste.org/10060/repaste_of_poormandebug>,<http://hpaste.org/10061/example_usage>
19:01:12 <Philippa> ski: also, "basically pure" is going to be inside a monad still, at least. But yeah - I'm going to do it in my series of posts on type inference soon, and in that particular case I really ought to do the transformation by hand
19:01:46 <Philippa> it's also fun if your "non-standard fix" is actually translating from another datatype too
19:01:56 <Philippa> sort of a fixy worker/wrapper
19:02:28 <ski> (those pastes are repastes of ones i made in 2008-11-19, apparently)
19:03:01 * ski wonders what `mark-contiguous-region' might be
19:03:40 <ski> preflex: xseen chrisdone
19:03:40 <preflex>  chrisdone was last seen on freenode/#haskell 7 days, 5 hours, 52 minutes and 51 seconds ago, saying: the time performance is reliable
19:03:58 <fazzone> ski: given a predicate, an adjacency-function (Ix i) => i -> [i], and a 'center' point, return the points (indices) in the same 'blob' as the center point?
19:04:23 <ski> ok
19:05:17 * ski was thinking `mark-contiguous-region' might be some emacs command in some obscure mode (<=> a mode ski doesn't know)
19:07:33 <fazzone> Then again, it probably is an emacs command
19:07:35 <ddarius> ski is an emacs master.
19:07:56 <ivanm> preflex: seen chrisdone
19:07:57 <preflex>  chrisdone was last seen on #haskell 7 days, 5 hours, 57 minutes and 7 seconds ago, saying: the time performance is reliable
19:08:05 <ivanm> bah
19:08:13 <ivanm> oh, wait, ski had just been looking for him as well
19:08:14 <DanBurton> so I've been musing over this question...isn't there a GHC extension that can do something like this? http://stackoverflow.com/questions/7603509/haskell-syntax-for-or-in-case-expressions/7604758#7604758
19:08:29 <ski> Philippa : by "basically pure", i meant like how `fact :: Monad m => (Natural -> m Natural) -> (Natural -> m Natural)' there satisfies `forall f. exists g. fact (return . f) = return . g'
19:08:47 <ivanm> DanBurton: no, unfortunately :(
19:08:51 <ivanm> I've wanted something like that though
19:09:03 <DanBurton> it seems like it would be super-easy to implement
19:09:13 <ski> ddarius : i am !? thanks for letting me know :)
19:09:56 <DanBurton> I mean, we can't let F# and OCaml beat us out, now can we? ;)
19:10:56 <ski> DanBurton : unfortunately Haskell doesn't (yet) have disjunctive patterns (hint : help lobby/complain to fasten it's inclusion)
19:11:09 <comedy_> :q
19:11:21 <ski> (DanBurton : btw, several SML implementations has that as well, e.g. SML/NJ)
19:11:34 <DanBurton> yarrrrrrrrr
19:11:45 <ski> comedy_ : wrong window ?
19:12:00 * ski . o O ( "wring wondiw" ? )
19:12:08 <DanBurton> how does one go about proposing these sorts of things for haskell prime?
19:12:25 <comedy_> i wanna close the chat window
19:12:41 <ski> comedy_ : you could try `/quit' (without the quotes, of course)
19:13:09 <ski> comedy_ : or you could try your browser's "close tab" or "close window" thing
19:13:11 <ski> ..
19:14:27 <ivanm> is there a version of zipWith that will return the remaining values?
19:14:38 <ivanm> bonus points if it works on Seq values, though just lists would be fine
19:14:49 <Cale> ivanm: there is, if you write it
19:14:55 <ivanm> Cale: obviously ;)
19:15:13 <Cale> But not in the standard library
19:16:02 <ski>   (a -> b -> c) -> [a] -> [b] -> ([c],Maybe (Either (a,[a]) (b,[b])))  -- ?
19:16:20 <ivanm> ski: why tuples?
19:16:46 <ivanm> wouldn't it just be: (a -> b -> c) -> [a] -> [b] -> ([c], Either [a] [b]) ?
19:16:52 <ClaudiusMaximus> to avoid equal length lists having two representations
19:17:06 * ski really wants to say something like `(a -> b -> c) -> [a] -> [b] -> ([c],Pushout [a] [b])', where `Pushout [a] [b]' is to avoid distinguishing `Left []' and `Right []'
19:17:12 <ddarius> type NonEmptyList a = (a, [a])
19:17:24 <ivanm> ClaudiusMaximus: I suppose, but in that case I wouldn't care which it returns out of Left [] and Right []
19:17:26 <ivanm> but yeah
19:17:49 <ivanm> ski: though that would then fail to work if they _are_ equal length
19:17:55 <ivanm> wait, that wouldn't work for me either
19:18:00 <wavewave> deech` : I guess that the obvious way is to make your client install gtk on mac os x .
19:18:11 <ddarius> But, as ski should know, for a pushout you'd need to specify two -functions- not just two types.
19:18:14 <ivanm> I need a fold over the results...
19:18:44 <ski> ivanm : if they were equal length, then you get a `Nothing' (or something that corresponds to both `Left []' and `Right []' in the sketchy pushout-version)
19:18:51 <wavewave> deech` : there is some standard way to install gtk on mac os x. like using macports or fink or homebrew.
19:18:55 <ivanm> ski: *nod*
19:18:58 <ski> ddarius : indeed, hence "something like"
19:19:01 <ivanm> wavewave: probably
19:19:07 <ivanm> but I wouldn't know how :)
19:19:12 * ski isn't even sure how to notate what he wants, sanely
19:19:17 <ClaudiusMaximus> (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]   might work?
19:20:00 <wavewave> deech` : if you want to know how to make a package including all gtk stuff... I do not know
19:20:10 <ski> possibly i want some way of making the common case a subtype of the two types ..
19:20:59 * ski suspects that won't work out well with subsumption semantics, though
19:21:27 <wavewave> deech` : If gtk can be statically linked, there is some native cocoa gtk lib.. then the executable will run without X11 and other dyn lib.
19:21:37 <ivanm> what I'm _wanting_ to do is a foldr over two sequences, and then return the result as well as the remaining sequences (at least one of which will be Seq.empty)
19:22:10 <ski> ivanm : hm, you want to "parallel" folds ?
19:22:17 <ivanm> I suppose the best approach is to write a version of zip that returns an Either with some remainder (if they happen to both be empty - which I doubt - then just arbitrarily choose one)
19:22:20 <ski> s/to/two/ (*sigh*)
19:22:41 <benmachine> ClaudiusMaximus: in principle it could work, but it's not as neat as something you can patternmatch
19:22:44 <ivanm> ski: no: I have two lists of nodes that need to be connected up in a graph
19:23:03 <ivanm> my intuition is that one of them (and I know which one) will always be longer, but I can't guarantee that yet
19:23:39 <ski> ivanm : then what did you mean by "I'm _wanting_ to do is a foldr over two sequences" ?
19:24:14 <ivanm> ski: something like: foldr f g $ zip as bs
19:24:28 <ivanm> so using zipWith doesn't help me (don't know why I thought it would)
19:24:44 <ski>   foldrSeq2 :: (a -> b -> o -> o) -> (Seq a -> o) -> (Seq b -> o) -> o -> Seq a -> Seq b -> o  -- ?
19:25:30 <ivanm> actually, doesn't need to be a right-fold... anyway
19:25:48 <ski> mhm
19:25:56 <ivanm> something like: (a -> b -> g -> g) -> g -> Seq a -> Seq b -> (g, Seq a, Seq b)
19:25:57 <wavewave> how about zipWith with a constuctor   Left l , Right r , Both l r , Nothing ?
19:26:05 <ivanm> where one of the resulting Seq's will be empty
19:26:28 <ivanm> wavewave: zipWith as defined drops remaining elements; I need them to remain
19:26:29 <wavewave> and fold an action over that data type?
19:26:38 <ClaudiusMaximus> is there any simple pure rasterization library? need to check which pixels (representing squares, not idealized sample points) are covered (even partially) by a rectangle (arbitrarily rotated and with subpixel coordinate resolution).  output bitmap is small (32x32 pixels)
19:26:40 <ivanm> actually, even easier: just return both, forget about the Either
19:26:42 * ski . o O ( `(Maybe l,Maybe r)' )
19:27:05 <wavewave> you can append infinite Nothing.. for both and later truncate?
19:27:12 <ski> yeah, what ivanm said is nicer
19:27:23 <ivanm> zip' (a:as) (b:bs) = first ((a,b) :) zip' as bs; zip' as bs = ([],(as,bs))
19:27:39 <ivanm> wavewave: except I need to know how many to take later
19:27:41 <ddarius> ClaudiusMaximus: If the "pixels" are actually squares, isn't this a pure geometry problem and not a rasterization problem at all?
19:28:32 <ddarius> It sounds like doing axis-aligned bounding box intersections against an arbitrary rectangle.
19:28:53 <ddarius> A little bit of quad tree or BSP and you should be set.
19:28:59 <wavewave> signalling the end by Nothing Nothing. ... hmm maybe it will be a kind of dirty code.
19:28:59 <ClaudiusMaximus> ddarius: yeah, that's pretty much the problem expressed in fewer words :)
19:35:37 <ski> > remberUptoLastJust [Nothing,Just 'a',Just 'b',Nothing,Nothing,Just 'c',Nothing,Nothing]
19:35:39 <lambdabot>   [Nothing,Just 'a',Just 'b',Nothing,Nothing,Just 'c']
19:36:45 <ski> > remberUptoLastJust (zip ([Nothing,Just 'b',Just 'c'] ++ repeat Nothing) ([Just 'x',Nothing,Just 'z'] ++ repeat Nothing))
19:36:46 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
19:36:46 <lambdabot>         against inferred ...
19:37:37 <ski> > (remberUptoLastJust . map (uncurry (liftM2 (,)))) (zip ([Nothing,Just 'b',Just 'c'] ++ repeat Nothing) ([Just 'x',Nothing,Just 'z'] ++ repeat Nothing))
19:37:39 <lambdabot>   [Nothing,Nothing,Just ('c','z')*Exception: stack overflow
19:37:58 <ski> wavewave ^
19:39:31 <wavewave> ski: hmm I don't understand stack overflow.. something is too strict?
19:39:54 <ski> the problem is that you can't detect the infinite tail of `Nothing's, and remove them all
19:42:30 <wavewave> ski: but in this case, we need to truncate only when first (Nothing,Nothing) happened.
19:42:58 <wavewave> ski: so I suggest that not using Maybe as a resultant zip but some other type.
19:43:12 <ivanm> if I have the ViewPatterns enabled, shouldn't this work for sequences? foo (viewl -> (a :< as)) = ... ?
19:43:13 <wavewave> (Maybe a, Maybe b)
19:43:41 <ivanm> wavewave: wait, are you _still_ golfing what I said? :o
19:44:13 <ski> if you start with  [Nothing,Just 'b',Nothing,Just 'c']  and  [Just 'x',Nothing,Nothing,Just 'z']  then you'd not want to stop at the first `(Nothing,Nothing)'
19:44:15 <DanBurton> Hey guys, tell me what you think of this new wiki page about expanding the case statement syntax
19:44:19 <DanBurton> @wiki MultiCase
19:44:19 <lambdabot> http://www.haskell.org/haskellwiki/MultiCase
19:44:26 * ski is maybe getting away from the original problem here, though
19:45:04 <wavewave> ski: so you do not have assumption that the list is packed fromt the front.
19:45:05 <ivanm> DanBurton: not sure if I like that syntax
19:45:17 <ivanm> I can see the cases get rather long if you have large patterns you're matching against
19:45:26 <wavewave> ski: then , there is really no way to detect end.
19:45:35 <wavewave> ski: you need another state EOF.
19:45:37 <DanBurton> ivanm: you could use layout, as in the last example
19:45:44 <ski> ivanm : i think so
19:45:51 <elliott__> DanBurton: It seems like a pretty food idea, it's in other languages after all, but I wonder if a helper function in a where clause doesn't work most of the time
19:45:55 <elliott__> just passing the same parameters
19:46:20 <ski> wavewave : waitamoment, i have to recall what the original problem was
19:46:29 <ivanm> ski: you mean mine? :p
19:46:39 <ivanm> ski: this solves it for me: zip' (a:as) (b:bs) = first ((a,b) :) zip' as bs; zip' as bs = ([],(as,bs))
19:46:57 <ivanm> but I'm trying to adapt it for lists rather than Seq, and ViewPatterns don't seem to like me :@
19:46:58 <wavewave> yeah. I note that.
19:47:15 <DanBurton> elliott__: sure it works, but at the same time, it's such a simple extension that other languages have; makes you wonder "why not Haskell?"
19:47:19 <ski> ivanm : i'm not sure -- someone was talking about zipping lists while getting the left-over pieces at the end back
19:47:32 <elliott__> DanBurton: dunno... that syntax will not work anyway
19:47:33 <ivanm> ski: yes, that was me!
19:47:36 <elliott__> it conflicts with pattern guards
19:47:47 <ivanm> elliott__: will it? how?
19:47:56 <ivanm> those matches aren't within a guard
19:47:56 <elliott__> well... I think it will :)
19:47:59 <DanBurton> pattern guards aren't in the Haskell spec, though, are they?
19:48:03 <elliott__> yes they are
19:48:11 <DanBurton> I thought they were a ghc extension
19:48:13 <ivanm> Haskell2010 has them, doesn't it?
19:48:17 <elliott__> they were, then they weren't
19:48:21 <elliott__> ivanm: seems you are right
19:48:37 <elliott__> oh right they are not in guards
19:48:41 <elliott__> right yeah that's fine
19:48:51 <ivanm> dammit, importing an infix constructor sucks
19:48:53 <ski> DanBurton : how will you express the pattern `(LT | GT) : foo' with that syntax ?
19:48:53 <ivanm> and GHC lies
19:49:06 <ivanm> To import it use  `import Data.Sequence (ViewL (:<))'
19:49:09 <ivanm> ^^ lies!!!
19:49:15 <elliott__> ivanm: how does that lie? oh, you need extra parens
19:49:16 <ivanm> it needs to be: ViewL((:<))
19:49:19 <ivanm> elliott__:
19:49:20 <elliott__> I'd just import ViewL(..)
19:49:20 <DanBurton> ski: case ordVal of LT, GT -> foo
19:49:21 <ivanm> yup
19:49:27 <elliott__> avoids all that nastiness :P
19:49:39 <ski> ivanm : well, obviously ..
19:49:39 <ivanm> can anyone check if that error is still wrong on 7.2.1 ?
19:49:56 <ivanm> (i.e. try: import Data.Sequence((:<))
19:50:05 <ivanm> ski: I trusted that error message!
19:50:11 <ivanm> took me a while to figure out that it was wrong!
19:50:19 <DanBurton> it does appear to have potential ambiguity when dealing with guards, though
19:50:19 <ski> report a bug ?
19:50:56 <ivanm> ski: I will; just hoping that someone can check if it still exists in 7.2.1 or not for me
19:50:57 <ski> DanBurton : no, you were supposed to nest the disjunctive pattern inside the pattern `... : foo'
19:51:02 <ivanm> if it does, then I'll report it
19:51:20 <DanBurton> ski: yeah, after thinking about it I realized.
19:51:34 <DanBurton> ski: my suggested syntax only works for very simple cases
19:51:37 <ski> it has an ambiguity with tuple syntax, is my point
19:51:49 <DanBurton> and | has ambiguity with guards :(
19:51:50 <ski> since `(LT , GT) : foo' wouldn't work
19:52:54 <ivanm> @get-shapr
19:52:55 <lambdabot> shapr!!
19:52:56 <DanBurton> ski: of course with my suggested syntax you could do `LT:foo, GT:foo' but that's not quite as powerful
19:53:02 <elliott__> DanBurton: I think it's fine for it to work only with one level
19:53:10 <elliott__> do the other languages handle the more complex cases?
19:53:18 <DanBurton> dunno
19:53:27 <shapr> ivanm: You called?
19:53:28 <ski> DanBurton : well, one reaolution (slightly ugly) could be that you have to bracket in a `case' to get a disjunctive pattern, so `case ... of (Left (a,_) | Right (a,_)) -> ..a..' but not  `case ... of Left (a,_) | Right (a,_) -> ..a..'
19:53:33 <ivanm> shapr: hi! ;)
19:54:01 <elliott__> DanBurton: I mean, if you have two hugely complicated nested pattern alternatives like that you need to refactor anyway :P
19:54:12 <shapr> Geez, 19 second lag :-(
19:54:15 <DanBurton> yeah true
19:54:30 <ski> DanBurton : obviously most(all?) other pattern constructions should distribute over disjunctive patterns -- if they don't, i don't want those crippled disjunctive patterns either
19:55:18 <elliott__> DanBurton: you could do (Left a | Right a) -> ... to avoid guard ambiguity
19:55:21 <elliott__> but that clouds the common case
19:55:27 <elliott__> How about \/? :p
19:55:37 <ski> elliott__ : heh, what i said :)
19:55:39 <DanBurton> V?
19:55:49 <elliott__> \/
19:55:51 <elliott__> disjunctive
19:55:57 * ski suggests `||||'
19:56:10 * DanBurton doubts that would catch on
19:56:13 <elliott__> ```,,Or.>|
19:57:02 <DanBurton>  them guards >,<
19:57:11 <ski> btw, while we're at it, `@' should be generalized to full conjunctive patterns
19:57:24 <miyako> I have kind of a general question I've been thinking about for a couple of days I was hoping to get some insight on. I'm trying to write a (simple) syntax highlighter and I'm trying to come up with a clean idiomatic type, but I am experiencing design paralysis
19:57:26 <DanBurton> for example?
19:57:27 <ski> (because of view patterns, if nothing else)
19:57:47 <ivanm> in case anyone cares: http://hackage.haskell.org/trac/ghc/ticket/5523
19:58:00 <ivanm> ski: why, doesn't @ work with view patterns?
19:58:22 <ski> DanBurton : `foo ((viewl -> first :< back) @ (viewr -> front :> last)) = ...'
19:58:24 <ski> ivanm ^
19:58:37 <ivanm> :o
19:58:40 <ivanm> wow...
19:58:47 <ivanm> if you could do that, that'd be cool
19:59:12 <ivanm> possibly difficult to keep track of if you abused it too much, but cool
19:59:13 <ski> it's the natural generalization of `@'
19:59:21 <DanBurton> basically do two matches at once
19:59:28 <ivanm> ski: then you do more @'s inside the patterns... :p
19:59:42 <ski> it's just that in the absense of more powerful patterns like view patterns, one can always simplify away this powerful use of `@'
19:59:53 <ski> ivanm : naturally :D
20:00:15 <elliott__> <ski> DanBurton : `foo ((viewl -> first :< back) @ (viewr -> front :> last)) = ...'
20:00:17 <elliott__> ski: augh
20:00:28 <ski> elliott__ : wouldn't that be great !?
20:00:59 <elliott__> ivanm: confirmed on 7.2.1
20:01:04 <ivanm> elliott__: ta
20:01:05 <elliott__> ski: I... guess...
20:01:15 <ski> soon we'll be writing function equations where the bulk of the code is to the left of `=' -- imagine the power !
20:01:28 <ivanm> dammit, the usage of foldl' precludes the function having the nice morphism...
20:01:48 <ivanm> @pl \ m (n1,n2) -> f n1 n2 m
20:01:49 <lambdabot> (`ap` snd) . (. fst) . flip (flip . f)
20:01:50 <elliott__> ski: we need recursion in patterns
20:01:58 <ski> (and i mean non-trival functions, not silly little puny things)
20:02:02 <elliott__> monadic patterns. (actually this would be useful:)
20:02:15 <elliott__> foo m | x <- m = return (x+9)
20:02:34 <DanBurton> o_O
20:02:51 <ski> elliott__ : you mean like `map f ((f -> b):(map f -> bs)) = bs' ?
20:03:08 <elliott__> ski: no the patterns _themselves_ have to be recursive. (wow is that valid?)
20:03:38 <elliott__> btw you mean b:bs
20:03:49 <ski> elliott__ : or like `loop@(foldr cons nil) (a:(loop -> o)) = cons a o' ?
20:03:55 <elliott__> :D
20:04:09 <ski> yes, s/= bs/= b:bs/
20:04:44 <ski> hm, recursive patterns .. interesting idea
20:05:09 <elliott__> ski: map f (uncons -> maybe [] (\(f -> x, map f -> xs) -> x:xs) -> r) = r
20:05:31 <elliott__> I like how it's readable :/
20:05:41 <ski> well, that's ugly imo
20:05:48 <elliott__> make it better :-)
20:06:24 <ski> (and i assume that isn't supposed to be an example of recursive patterns (since it isn't))
20:06:29 <elliott__> it isn't, yeah
20:06:43 <elliott__> ivanm: I found where that error is produced inside GHC... maybe I will have a go at fixing it
20:06:47 * elliott__ has never delved into the GHC codebase before.
20:08:17 <ski> hm, should i consider recursive patterns using `let', or using a `rec <variable> in <pattern>' syntax ?
20:08:38 * ski has already pondered `let'-patterns before, so that might be easier
20:09:21 <elliott__> ski: Perhaps we should get pattern synonyms first
20:11:07 <ski> considering `foo (let a ^ 3 = c; b * c = d in (a,b)) = ...', this would bind `a',`b',`c',`d' in `...'
20:12:52 <ski> so how about `foo (let as = False : as in as) = ...', this would match the input with `as', and then match the result of the expression `as' with the pattern 'False : as' -- hm, that seems problematic
20:13:07 <elliott__> lol (let as = _:as in as) = True
20:13:13 <elliott__> ski: observable sharing through patterns? :P
20:13:24 <ski> as i said, problematic
20:13:49 <ski> maybe i'm misunderstanding what recursive patterns should be, though
20:14:20 <elliott__> ski: I dunno... as long as they're Turing complete
20:14:39 <elliott__> I want a brainfuck interpreter that's just main | ... huge mess of binding and patterns and guards ...  = result
20:14:45 <ski> (well, we definitely *don't* want to observe sharing)
20:15:04 <elliott__> why not :D
20:15:11 <elliott__> breaks referential transparency... but so cool
20:15:21 <ski> because it would break lots of useful code improvements
20:15:39 <elliott__> just use them anyway, who cares if the patterns are nondeterministic
20:15:41 * ski wonders whether that is true
20:15:52 <elliott__> well observable sharing breaks referential transparency
20:15:55 <ski> (i.e. what i just said before)
20:15:55 <elliott__> so you cannot assume code is pure any more...
20:15:59 <elliott__> which is a pretty major assumption :)
20:16:19 <ski> hm, right you are
20:17:34 <ski> hm .. i wonder whether recursive patterns make more sense with codata ..
20:19:29 <tactics> Does haskell require an extension to allow instances of a typeclass to be guarded by instaces of other type classes?
20:19:31 <ski> `rec r in In (\0 -> r)' could be one (a bit trivial) example of such a pattern
20:19:41 <tactics> like Monad m => instance Foobar m where
20:19:43 <tactics> for examle
20:20:16 <ivanm> tactics: that's usually a bad idea
20:20:27 <elliott__> ski: heh, how would that work?
20:20:27 <ski> tactics : you can do `instance Monad m => Foobar m', but when resolving instances, it won't take the `Monad m' part into account when deciding which instance to use
20:20:31 <ivanm> since it means a) you can't create a custom instance of FooBar for a particular monad
20:20:47 <ivanm> and b) it means you can't add any more instance of _any_ type afterwards
20:20:50 <ski> tactics : which means that in that case you can't have any other instance, since `m' overlaps with everything
20:21:28 <ivanm> tactics: ^^ this is because the constraint dictionary is only kept at compile time
20:21:35 <ski> @type let f = In (\_ -> f) in f
20:21:37 <lambdabot> forall t. Mu ((->) t)
20:21:37 <DanBurton> but there are those dirty little OverlappingInstances and UndecidableInstances pragmas...
20:21:43 <ski> elliott__ : it would match things of tha tytpe
20:22:00 <ski> but this is not a very useful type, we need some outputs as well
20:22:06 <elliott__> heh
20:22:45 <ski> so assume we have `data SSP a b = MkSSP (a -> (b,SSP a b))'
20:23:03 <ski> (well, make that `newtype', just because)
20:24:03 <ski> now we can consider a pattern `rec r in MkSSP (\(42 * 17) -> (b,r))'
20:24:23 <ski> but that's problematic, since we can't check that all infinitely many `b's are the same
20:24:58 <ski> (this pattern is basically picking out a single infinite path in the (well, usually) infinite tree that is `SSP a b')
20:25:23 <ski> so we wamt to somehow "reify" the `b's into a list/stream of them
20:26:18 <ski> (btw, note that the `42 * 17' there is an *expression*, namely the input that we're passing to the function, before we match the result on `(b,r)')
20:27:55 <ski> `let r = MkSSP (\(42 * 17) -> (b,r)) in r' ought to be equivalent to the (still non-sensical) `rec r in MkSSP (\(42 * 17) -> (b,r))', because of how `rec'-`in' works
20:29:32 <ski> `let r (b:bs) = MkSSP (\(42 * 17) -> (b,r bs)) in r bs' otoh would be a pattern that binds `bs' to the stream/list of all the consecutive `b's on the path that consists of always choosing the '42 * 17' branch at each node in the tree :)
20:31:20 <ski> it would start by matching the input on the `r bs' after the `in', and that match would defer to the definition of the named (parameterized) pattern `r'
20:31:47 <ski> but in any case, if the match succeeds, it will bind `bs' in the pattern `r bs'
20:32:12 <milkpost> Im in a monoid (i think) and I do something like `fd <- readFile path`.  So is there a way to apply a function to fd and then store it somewhere else?  would I even want to do that?
20:32:35 <DanBurton> in a monad I believe you mean
20:32:38 <milkpost> because I have another function that parses the input using parsec
20:32:43 <milkpost> DanBurton: yes, thank you.
20:33:11 <ski> so, looking at `r (b:bs) = MkSSP (\(42 * 17) -> (b,r bs))', we match the pattern `r bs' with the left-hand side `r (b : bs)', as usual, (and the `b' and `bs' there are local variables, not the same as the previous `bs'), so we bind the previous `bs' to `b : bs', for two new variables that we are to bind later
20:33:34 <milkpost> https://gist.github.com/1252669
20:33:54 <DanBurton> milkpost: sure you can use fd afterwards
20:33:59 <milkpost> here is a sample of what I'm looking at. `parseFile` is returning a tuple or erring out,
20:34:18 <ski> then we match the current input with `MkSSP (\(42 * 17) -> (b,r bs)', which unwraps the constructor, feeds `42 * 17' to the function inside, and matches the result on `(b,r bs)' which binds the `b' from before, and also recursively matches `r bs' on the next `SSP a b', just as before
20:34:21 <DanBurton> milkpost: fd is a strange name for the contents of a file, though
20:34:30 <ski> elliott__ : have i lost you yet ? ;)
20:34:33 <milkpost> DanBurton: what I'm asking is can I use `parseFile` like: nfd <- parseFile fd
20:34:36 <elliott__> oops, you were talking? :D
20:34:40 <elliott__> I was busy in other channels
20:34:45 * elliott__ reads
20:34:52 <milkpost> DanBurton: yeah, FileData
20:35:11 <DanBurton> milkpost: you should instead do this:   let nfd = parseFile fd
20:35:16 <elliott__> ski: pattern matching on (\constant -> result) is pretty great
20:35:22 <milkpost> ok, that's what I was just going to ask if I should do
20:35:24 <milkpost> lol
20:35:29 <milkpost> so that makes me feel OK.
20:35:43 <ski> elliott__ : yeah, i got that idea some year or two(?) ago
20:36:01 <elliott__> ski: that was my main blocker understanding basically
20:36:13 <elliott__> ski: (\x -> r) $ x = r
20:36:14 <elliott__> ...valid? :p
20:36:49 <ski> elliott__ : that would also be useful to combine with conjunctive patterns : `(\(length as) -> x) @ (\(findIndex b bs) -> y)'
20:36:56 <elliott__> haha, awesome
20:37:12 <elliott__> ski: I note that (\arg -> pat) is the same as (($ arg) -> pat)
20:37:16 <elliott__> which is not so bad a syntax
20:37:28 <ski> elliott__ : well, i'd say `(\x -> r) x = r', and yes, that's usually called the beta0 reduction rule
20:37:41 <elliott__> ((length as $) -> x) @ ((findIndex b bs $) -> y)
20:37:56 <elliott__> ski: ah, that was meant as a definition of ($)
20:38:37 <ski> elliott__ : yeah, but sometimes i wish the pattern `<expr> -> <pat>' was written like `inv <expr> <pat>' instead
20:38:50 <elliott__> heh
20:38:55 <ski> elliott__ : ah, ok -- then it's a valid definition, yes
20:42:34 <ski> (note that `f (inv f x) = x' would be a valid reduction law .. could also be written as `(forall x. g (inv f x) = x) => g = f')
20:43:22 <elliott__> ski: that's defining f x = f x? heh
20:43:46 <ski> `f (inv f x) = x' would mean that, if given an input, call it `y', such that when passing it through `f' would yield `x', then passing it to `f' *does* yield `x' :)
20:44:17 <ski> no, that's not defining anything at all, it's supposed to be a valid law, for reasoning about programs
20:44:55 <ski> s/then passing it/then passing `y'/
20:45:13 <elliott__> right
20:45:28 <ski> otoh, `inv f (f x) = x' wouldn't be a valid law
20:45:59 <ski> since if you have an `y' such that if you pass it through `f' you get `f x', it doesn't have to be the case that `x' is the same as `y'
20:46:35 <ski> interesting, so `inv' appears to construct pre-inverses / sections
20:47:08 * ski wonders if he's missing anything with `f (inv f x) = x' or if it actually is that nice
20:47:52 <ski> (and of course, all i said about `inv f (...)' can be stated in terms of the extant syntax `f -> ...')
20:48:04 <elliott__> How long does ./sync-all in a GHC checkout take, I wonder...
20:49:42 <ski> elliott__ : anyway, i'm glad you prodded me into understanding recursive patterns of the style `let r (b:bs) = MkSSP (\(42 * 17) -> (b,r bs)) in r bs' :)
20:49:50 <elliott__> very good :P
20:49:52 <parcs> elliott__: a couple of minutes for the first time. ghc-tarballs is the big one
20:50:01 <elliott__> parcs: oh good, that one finished
20:50:11 <elliott__> ski: do you actually use patterns this complex in real code? I might have to avoid it :)
20:50:41 <elliott__>     datacon = ppr . rdrNameOcc $ ieName ie
20:50:41 <elliott__> ah, GHC has great function names
20:50:50 * ski now wonders how to use an extant stream of `a's to make the choices of which subtree to descent into, instead of always using `42 * 17'
20:51:36 <ski> elliott__ : well, Haskell doesn't support `let' in patterns at all (currently (.. we'll see in the future, muahaha !))
20:51:49 <ski> elliott__ : i'm just attempting to understand the theory of them
20:51:56 <elliott__> right
20:52:12 <ski> (the theory that unfolds itself when i think about it in the right way, i.e.)
20:53:08 <elliott__> ivanm: I think I know the patch to make to fix your bug; it should be a oneliner
20:53:54 * ski thinks that because the apparent input `b:bs' to `r' in `r (b:bs) = ...' actually acts like an output, then an actual input would look like it was an output, in terms of expression syntax
20:54:31 <ski> (hm, "actually acts" sounds overloaded ..)
20:54:53 <ivanm> elliott__: oh? nice!
20:55:02 <elliott__> ivanm: someone used ppr when they meant pprPrefixVar :-)
20:55:04 <elliott__> (thank god for grep)
20:55:10 <ivanm> heh
20:55:21 <elliott__> ivanm: ...in fact, there is another bug: if the type name is an operator, it fails at that too :-)
20:55:31 <ivanm> heh
20:56:26 <elliott__> hmm... I need to make a local binding of a SDoc for dataType, but the constructor version is named datacon... having datatyp and dataType in scope at the same time could get confusing... :)
20:56:30 <elliott__> these are the _hard_ problems of GHC hacking
20:58:43 <ski> elliott__ : btw, a possibly useful idea (for understanding this) is that `<exp> -> <pat>', i.e. `inv <exp> <pat>', is equal to `let <exp> x = <pat> in x'
20:59:21 <elliott__> does anyone know any infix data types in base?
20:59:52 <elliott__> I guess there aren't any
21:00:00 <elliott__> heh, Ratio has one but the constructor is hidden
21:01:45 <elliott__>     datacon_occ = rdrNameOcc $ ieName ie
21:01:46 <elliott__>     datacon = parenSymOcc datacon_occ (ppr datacon_occ)
21:01:49 <elliott__> ivanm: uhh... think it might have already been fixed
21:02:13 <elliott__> seems so
21:02:24 <elliott__> ivanm: I guess you can close it :P
21:02:53 <ski> hmm `let r (b:bs) = (a:as,MkSSP (\a -> (b,let (as,s) = r bs in s))); (as,q) = r bs in q' is what i want, but it seems unnecessarily clunky ..
21:03:43 <milkpost> does haskell have a library for parsing liquid?
21:03:44 * ski supposes this possibly is no more clunky than
21:03:44 <ski> @src span
21:03:45 <lambdabot> span _ xs@[]                     =  (xs, xs)
21:03:45 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
21:03:45 <lambdabot>                   | otherwise    =  ([],xs)
21:04:03 <ski> (where you have to match the result of the recursive call on a pattern)
21:04:24 <elliott__> ski: that IS ugly though :P
21:04:38 <elliott__> (state monad would help there.)
21:04:39 * ski can swallow liquid (well, *some* liquids), without parsing ..
21:04:52 <ski> elliott__ : yeah, maybe something like that
21:04:59 <elliott__> (I like how span avoids constructing an additional []...)
21:05:02 <elliott__> "avoids"
21:05:04 <ski> elliott__ : can you follow the pattern, though ?
21:05:10 <elliott__> ski: yeah
21:05:14 <ski> (hint : read from right-to-left)
21:05:18 <elliott__> like C :P
21:06:32 <elliott__> > let span _ [] = put [] >> return []; span p xss@(x:xs)   | p x       = (x:) <$> span p xs'   | otherwise = return xs in span f [x,y,z]
21:06:33 <lambdabot>   Not in scope: `xs''
21:06:35 <elliott__> geh
21:06:37 <ski> heh, C is more inside-out, i think
21:06:44 <elliott__> > let span _ [] = put [] >> return []; span p xss@(x:xs)   | p x       = (x:) <$> span p xs   | otherwise = return xs in span even [0,9,0,9]
21:06:45 <lambdabot>   No instance for (GHC.Show.Show (m [a1]))
21:06:46 <lambdabot>    arising from a use of `M3985197...
21:06:52 <elliott__> > let span _ [] = put [] >> return []; span p xss@(x:xs)   | p x       = (x:) <$> span p xs   | otherwise = return xs in runState (span even [0,9,0,9]) []
21:06:53 <lambdabot>   ([0,0,9],[])
21:06:57 <elliott__> heh
21:07:07 <c_wraith> Hmm.  Is there an inverse of zip`ap`tail that's nearly as clean?
21:07:18 <ulfdoz> But the name mangling is close to C++. ;)
21:07:36 <ski> wouldn't it be great if we could declare the type signature of `(!!)' as
21:07:38 <ski>   (_ :: [a]) !! (_ :: Int) :: a
21:07:43 <ski> in Haskell !?
21:08:31 <dobblego> zip`ap`tail loses information
21:08:39 <c_wraith> Oh.  I guess zip`ap`tail isn't 100% invertible.  You can't distinguish the results of running it on length-0 and length-1 lists
21:08:51 <c_wraith> it's invertible aside from that, though
21:08:51 <ski> (note, we already have something in this vein / C-like in `data Foo = MkFoo Bar Baz', where `MkFoo Bar Baz' acts like an abbreviation of `MkFoo (_ :: Bar) (_ :: Baz)' (which is to have type `Foo'))
21:09:40 <ski> c_wraith : yeah, blame `zip' :)
21:14:22 <ski> > let span _ [] = tell [] >> return []; span p xss@(x:xs) = (if p x then ((x :) <$>) else censor (x :)) (span p xs) in runWriter (span even [0,1,2,3])
21:14:23 <lambdabot>   ([0,2],[1,3])
21:14:27 <ski> elliott__ ^
21:14:32 <elliott__> ski: nice
21:14:50 <elliott__> blame me for pattern-matching tuples → state :)
21:14:58 <elliott__> I don't like that if though
21:16:01 <hpaste> elliott pasted “span” at http://hpaste.org/51947
21:16:03 <elliott__> i like that
21:16:36 <ski> > let span _ [] = return []; span p xss@(x:xs) = (if p x then ((x :) <$>) else (modify (x :) >>)) (span p xs) in runState (span even [0,1,2,3]) []  -- closer to your version
21:16:37 <lambdabot>   ([0,2],[3,1])
21:17:21 <elliott__> heh
21:18:06 <ski> > let (<><) = flip (liftM2 (flip const)); span _ [] = return []; span p xss@(x:xs) = (if p x then ((x :) <$>) else (<>< modify (x :))) (span p xs) in runState (span even [0,1,2,3]) []  -- hm, didn't work out either
21:18:07 <elliott__> ivanm: weird that your bug was fixed in HEAD but not 7.2.1 -- I guess it must be recent
21:18:07 <lambdabot>   ([0,2],[3,1])
21:18:12 <elliott__> or maybe they didn't pull that in for 7.2.1?
21:18:20 <elliott__> also, does anyone know what happened to 7.2 without the .1?
21:19:20 <dobblego> mapMaybe id ==? catMaybes
21:19:32 <ski> @type mapMaybe id
21:19:33 <lambdabot> forall b. [Maybe b] -> [b]
21:19:34 <ski> @type mapMaybe
21:19:35 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
21:19:44 <ski> dobblego : yes
21:19:48 <dobblego> ta
21:20:08 <dobblego> @check \x -> mapMaybe id x == catMaybes (x :: [Maybe Int])
21:20:08 <lambdabot>   "OK, passed 500 tests."
21:20:12 <ski> that's similar to `sequence = mapM id'
21:20:19 <dobblego> right
21:21:33 <ski> (also `mapMaybe f = catMaybes . map f' and `mapM f = sequence . map f')
21:22:25 <ski> (you can prove the earlier identities from those, depending on `map id = id' .. can you prove the converses ?)
21:23:16 <ski>   mapMaybe f  =  mapMaybe (id . f)  =  mapMaybe id . map f  =  catMaybes . map f
21:23:47 <ski> that assumes `mapMaybe (g . f) = mapMaybe g . map f', though .. does that follow from free theorems ?
21:23:55 <ski> @free mapMaybe
21:23:56 <lambdabot> $map_Maybe g . h = k . f => $map g . mapMaybe h = mapMaybe k . $map f
21:25:09 <ski> hm, try setting `g = id' so `$map g . mapMaybe h = mapMaybe h', then we want `h = g . f'
21:27:13 <ski> so `$map_Maybe g . h = k . f' becomes `g . f = k . f' (using `$map_Maybe id = id') and `$map g . mapMaybe h = mapMaybe k . $map f' becomes `mapMaybe (g . f) = mapMaybe k . $map f'
21:27:22 <ski> (sorry, two different `g's in use above)
21:27:24 <ski> hm
21:28:10 <ski> ok, if we now set `k = g', then the assumption `g . f = k . f' is provable, so we get the result `mapMaybe (g . f) = mapMaybe g . $map f'
21:28:24 <ski> QED
21:39:32 <q0tw4> Can I write something like "instance Monad m => Monad :\b :-> (a -> m b)" where :\b :-> <type expression> :: * -> * is lambda function for types?
21:40:11 <ivanm> q0tw4: not sure I follow what you're trying to do
21:41:01 <q0tw4> I need for instance Monad (a -> m b)
21:41:45 <kmc> q0tw4, no
21:41:50 <kmc> you can introduce a new type
21:41:57 <ivanm> newtype MonadFunc a b = MF { func :: a -> m b }
21:41:58 <ivanm> ?
21:42:09 <Cale> @src ReaderT
21:42:09 <ivanm> no, that'd need to be MonadFunc m a b
21:42:09 <lambdabot> Source not found. Take a stress pill and think things over.
21:42:39 <Cale> newtype ReaderT r m a = ReaderT (r -> m a)
21:42:53 <ivanm> or that
21:42:53 <ivanm> :p
21:42:54 <Cale> instance (Monad m) => Monad (ReaderT r m)
21:43:07 <Cale> (It's already in the library)
21:44:52 <q0tw4> I have version with newtype but I don't like write constructor every time I use this monad
21:45:05 <ivanm> q0tw4: you don't need to
21:45:11 <ivanm> just when writing your Monad instance
21:45:16 <ivanm> that's what return, etc. is for
21:45:30 <ivanm> there's also ask, etc.
21:45:33 <ivanm> @hoogle ask
21:45:33 <lambdabot> Control.Monad.Reader.Class ask :: MonadReader r m => m r
21:45:33 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
21:45:33 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
21:46:04 <ivanm> and since ReaderT has already been defined, you'll never need to use the constructor!
21:47:31 <elliott__> Cale: nice way to say Kleisli
21:50:06 <q0tw4> how can I write something like do { putStrLn >> putStrLn } :: MonadFunc String IO ()?
21:50:30 <elliott__> you can't
21:50:35 <elliott__> putStrLn doesn't have the right type
21:50:38 <elliott__> but you can do
21:50:41 <elliott__> :t putStrLn >=> putStrLn
21:50:42 <ivanm> and why would you?
21:50:42 <lambdabot>     Couldn't match expected type `()' against inferred type `[Char]'
21:50:42 <lambdabot>       Expected type: ()
21:50:43 <lambdabot>       Inferred type: String
21:50:43 <elliott__> which also does not work :)
21:50:44 <elliott__> but
21:50:46 <elliott__> :t print >=> print
21:50:47 <lambdabot> forall a. (Show a) => a -> IO ()
21:50:49 <elliott__> does (but it is useless)
21:50:53 <elliott__> (it prints the value then ())
21:52:36 <q0tw4> :t >=>
21:52:38 <lambdabot> parse error on input `>=>'
21:52:46 <q0tw4> :t (>=>)
21:52:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
21:53:03 <ivanm> q0tw4: why are you wanting to do this?
21:54:14 <q0tw4> I try to replace \p -> do { f1 p; f2 p } by do { f1; f2 }
21:55:38 <adnap> is it possible to convert from Int to GLint and from Float to GLfloat?
21:55:39 <ivanm> @type liftM2 (>>)
21:55:40 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
21:55:50 <ivanm> adnap: does fromIntegral, etc. work?
21:55:56 <elliott__> adnap: GLfloat == Float
21:56:00 <elliott__> It's just a type synonym
21:56:05 <adnap> i don't think so
21:56:09 <elliott__> Yes.
21:56:19 <ivanm> elliott__: I think that changed at some point
21:56:24 <adnap> it did
21:56:27 <elliott__> ivanm: Last release 2009
21:56:28 <ivanm> which is why the new OpenGL libraries aren't in the platform
21:56:44 <ivanm> elliott__: it got split up
21:56:46 <elliott__> oh, huh
21:56:54 <adnap> ivanm: do you know the newest one that doesn't incorporate the change?
21:56:55 <elliott__> yeah you are right looks like a wrapper
21:57:14 <ivanm> adnap: the one in the platform? *shrug*
21:57:17 <elliott__> still, the OpenGL packages worry me, not a single one released since 2009
21:57:27 <adnap> yes, i have run into this problem before
21:57:30 <ivanm> elliott__: if they still work, do they need to be updated?
21:57:32 <adnap> with conal
21:57:50 <elliott__> ivanm: no, but I doubt nobody has found non-trivial improvements in three years
21:58:02 <adnap> ivanm: not allowing an automatic conversion from GLfloat to Float breaks so much code
21:58:16 <adnap> ivanm: there are many typeclass errors
21:58:26 <ivanm> adnap: I'm pretty sure there's a function to convert one Rational instance to another
21:58:32 <ivanm> @hoogle Float -> Double
21:58:32 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
21:58:32 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:58:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:58:36 <ivanm> that's the one
21:58:39 <ivanm> realToFrac
21:59:02 <ivanm> elliott__: maybe it's just because no-one is using them? (admittedly a bit of a catch-22 situation)
21:59:10 <adnap> okay, thanks. i think it's better to have ugliness in the opengl api than to have ugliness spread through everyone else's code
21:59:21 <elliott__> ivanm: I find that hard to believe too :)
21:59:34 <adnap> the realToFrac needs to be called once in the opengl api
21:59:43 <cwl> can I do something like profiling in GHCi for functions
21:59:47 <adnap> not thousands of times in everyone else's
21:59:55 <cwl> measure the cost of a function
21:59:56 <ivanm> cwl: you can profile compiled executables
22:00:17 <cwl> ivanm: can I do it just invoke the function in the ghci?
22:00:19 <ivanm> cwl: and ghci has a debugger, so you can do the "randomly stop and see where it is" approach to hot-spot profiling
22:00:23 <elliott__> adnap: you could be polymorphic on Floating.
22:00:25 <ivanm> cwl: AFAIK, no
22:01:47 <cwl> ivanm: I see, I thought I find something like that in stackoverflow, I cannot find it any more
22:02:38 <cwl> If I want to compare two functions, the only way is just write test and compile it, then profiling it?
22:02:50 <ivanm> cwl: oh, you want to benchmark?
22:02:52 <ivanm> use criterion
22:02:58 <cwl> ivanm: yes
22:02:59 <ivanm> profiling /= benchmarking
22:03:04 <cwl> ivanm: sorry
22:03:12 <ivanm> bos has some good tutorials on using criterion on his blog IIRC
22:03:19 <ivanm> @google haskell criterion tutorial
22:03:20 <lambdabot> http://www.serpentine.com/blog/2009/09/29/criterion-a-new-benchmarking-library-for-haskell/
22:03:21 <lambdabot> Title: teideal glic deisbhéalach » Blog Archive » Criterion, a new benchmarking libr ...
22:10:12 <Rmx> what is the type * in * -> * ??
22:10:42 <mauke> no
22:14:57 <coppro> Rmx: * -> * is not a type, it's a kind
22:15:02 <coppro> * is a concrete type
22:15:26 <coppro> * -> * is a one-argument type (like [])
22:15:32 <coppro> * -> * -> * is a two-argument type
22:15:33 <coppro> and so on
22:21:30 <q0tw4> I think that \f1 :: IO () f2 :: IO () ... fn :: IO () -> do { f1; f2; ... fn } is simpler that using some monad for syntax do { f1; f2; .. fn } where fi :: Handle -> IO () and Handle is passing to fi implicitly
22:22:28 <q0tw4> but \f1 f2 f3 duplicates
22:34:51 <ski> q0tw4 : hm, maybe you want `runReaderT $ do { ReaderT f1; ReaderT f2; .. ReaderT fn }' ?
22:35:09 <ski> @type \f1 f2 f3 -> runReaderT $ do { ReaderT f1; ReaderT f2; ReaderT f3 }
22:35:10 <lambdabot> forall r (m :: * -> *) a a1 a2. (Monad m) => (r -> m a1) -> (r -> m a2) -> (r -> m a) -> r -> m a
22:35:39 <ski> @type \f1 f2 f3 -> runReaderT $ do { a <- ReaderT f1; b <- ReaderT (f2 a); ReaderT (f3 a b) }
22:35:40 <lambdabot> forall r (m :: * -> *) a a1 a2. (Monad m) => (r -> m a1) -> (a1 -> r -> m a2) -> (a1 -> a2 -> r -> m a) -> r -> m a
22:36:15 * ski wonders whether one can deprecate whether it is known that a type is a synomym (as a preparation to making it abstract, or into `data' or `newtype')
22:36:20 <ski> (apropos <adnap> ivanm: not allowing an automatic conversion from GLfloat to Float breaks so much code)
22:36:45 <ivanm> ski: what you do mean?
22:42:37 <ski> ivanm : i mean that if you export `type Foo = ...' from a module, you'd like to mark as deprecated the knowledge of `Foo' being a type synonym, but not marking `Foo' itself deprecated
22:42:50 <ivanm> hmmm....
22:43:23 <ski> so that any use of `Foo' that doen't require expanding the type synonym wouldn't trigger the deprecation, but if you *need* to rely on that it is equal to `...', then you get the warning
22:43:31 <ivanm> do we actually have deprecation warnings available in GHC?
22:43:56 <q0tw4> ski: yeah, I wrote monad with the same behavior but it is worse than \h -> do { f1 h; f2 h; ... fn h } where fi :: Handle :: IO ()
22:44:07 <ski> that way you could later change it to an abstract type, or to `data Foo = ...' or `newtype Foo = ...', after everyone has been given due time to not rely on it being a type synonym
22:44:14 <q0tw4> fi :: Handle -> IO ()
22:44:25 <elliott__> ivanm: btw, did you see that I said your bug is fixed in HEAD?
22:45:06 <ivanm> elliott__: nope; trac hasn't sent me an email yet :p
22:45:13 <elliott__> ivanm: nah, I mean, it is already fixed :)
22:45:19 <ivanm> heh
22:45:21 <elliott__> I checked out the code to make the fix I came up with... but something similar is already there
22:45:30 <ivanm> well, I guess the bug'll be closed then
22:45:32 <ski> ivanm : <http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#warning-deprecated-pragma>
22:46:27 <ski> q0tw4 : yes, the `r' above could be `Handle'
22:52:04 <ivanm> elliott__: yeah, bug 5385 apparently
22:52:11 <elliott__> HEHE
22:52:12 <elliott__> hehe
22:52:14 <elliott__> capslock...
22:53:01 <ivanm> *gasp* you mean you haven't re-mapped caps to ctrl yet? :o
22:53:02 <ivanm> :p
22:53:06 * ski . o O ( have you MOVED your CAPS LOCK yet, today !? )
22:53:27 * ivanm -> buy food
22:54:06 <elliott__> i don't think caps lock as ctrl is very ergonomic
22:54:07 * ski rotated left control, caps lock, and left super, also rotating 1 - 9,0
22:54:12 <elliott__> at least my pinky doesn't feel up to that
22:57:32 <mno2> @help
22:57:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:10:37 <hjulle> I have a program which works when I use runhaskell, but fails to compile using ghci
23:15:28 <rostayob> hjulle: can you post the error?
23:15:58 <hjulle> (.text+0x215): undefined reference to `spreadsheetzm0zi1zi2_DataziSpreadsheet_fromStringSimple_closure'
23:16:01 <hjulle> uppg2.o: In function `sym_info':
23:16:01 <hjulle> collect2: ld returned 1 exit status
23:16:04 <hjulle> (.text+0x6b1): undefined reference to `__stginit_spreadsheetzm0zi1zi2_DataziSpreadsheet_'
23:16:07 <hjulle> uppg2.o: In function `rs2_srt':
23:16:09 <hjulle> (.data+0x80): undefined reference to `spreadsheetzm0zi1zi2_DataziSpreadsheet_fromStringSimple_closure'
23:16:58 <kmc> hjulle, ghci doesn't compile, maybe you mean ghc?
23:16:59 <kmc> try ghc --make
23:17:06 <rostayob> hjulle: ok, next time paste it somewhere
23:17:24 <q0tw4> @type \f1 :: ReaderT Handle IO () f2 :: Handle ReaderT IO () f3 :: ReaderT Handle IO String -> runReaderT $ do { f1; f2; x <- f3; liftIO $ putStr x }
23:17:26 <lambdabot> parse error on input `Handle'
23:17:28 <hjulle> rostayob: ok
23:17:50 <hjulle> kmc: Thanks. It worked
23:17:52 <rostayob> hjulle: and yeah try --make as kmc said - if you have ghc 7 is already on
23:18:14 <q0tw4> @type \f1 :: ReaderT Int IO () f2 :: ReaderT Int IO () f3 :: ReaderT Int IO String -> runReaderT $ do { f1; f2; x <- f3; liftIO $ putStr x }
23:18:15 <lambdabot> parse error on input `Int'
23:18:19 <hjulle> Is there a standard way of installing ghc 7 on ubuntu?
23:18:32 <q0tw4> @type \f1 :: ReaderT r IO () f2 :: ReaderT r IO () f3 :: ReaderT r IO String -> runReaderT $ do { f1; f2; x <- f3; liftIO $ putStr x }
23:18:33 <rostayob> hjulle: if with "standard" you mean using the repos
23:18:34 <lambdabot> parse error on input `r'
23:18:50 <rostayob> hjulle: there are probably some unofficial repos, but what i do is simply to download the binaries
23:19:08 <q0tw4> @type \f1 f2 f3 -> runReaderT $ do { f1; f2; x <- f3; liftIO $ putStr x }
23:19:09 <lambdabot>     Ambiguous occurrence `liftIO'
23:19:09 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
23:19:09 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
23:19:24 <hjulle> rostayob: ok, do I need to uninstall the old version first?
23:19:28 <rostayob> hjulle: http://www.haskell.org/ghc/download_ghc_7_0_3#binaries
23:19:40 <rostayob> hjulle: yeah that would be better, along with the haskell packages
23:19:58 <rostayob> install the binaries and then the haskell platform, and then use cabal to install additional packages
23:20:11 <hjulle> rostayob: Ok. Thank you
23:20:32 <q0tw4> This is solution of my problem
23:21:13 <rostayob> hjulle: np, ubuntu will always lag behing since it comes out every 6 months
23:21:20 <rostayob> and since ghc goes fast :)
23:22:12 <kmc> haskell platform comes out no more than every 6 months too
23:22:18 <kmc> but there's a delay
23:28:12 <rostayob> kmc: yeah but considering that's it's tricky to mix distro's packages and hackage packages
23:28:30 <rostayob> i find it almost impossible not to use cabal all the way, even in a rolling release distro like arch
23:28:41 <rostayob> gentoo does a better job i think, they have an haskell overlay
23:29:15 <kmc> yeah
23:46:17 <rostayob> not strictly haskell, but is there a way to make insert the unicode characters for ::, -> etc., instead of just displaying them?
23:49:42 <q0tw4> What do you think about using ContT in with* functions for foreign data types? For example withCString :: Monad m => String -> ContT CString m r. Example of using: do { s <- withCString "Hello"; c_func s }. Maybe it will be better to make some new monad ScopedT = ContT.
23:56:30 <MatrixFrog> rostayob, wouldn't that depend on what text editor you're using?
23:56:46 <rostayob> MatrixFrog: oh yeah, forgot to mention I'm using emacs
23:56:56 <rostayob> the thing is that emacs already displays them
23:57:06 <rostayob> i think it's called font locking
23:57:11 <MatrixFrog> oh, how fancy of you emacs
23:57:29 <rostayob> but then the indentation is all messed up when reading the code with something else
23:59:12 <MatrixFrog> well i suspect there is some way, but i wouldn't know what it is
23:59:19 <MatrixFrog> is there an irc channel for emacs?
