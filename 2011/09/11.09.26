00:01:21 <Reisen> Rofl, well it definitely helped
00:01:43 <Reisen> compiled every dependency for cabal, until cabal-install itself, ghc out of memory, don't even know
00:02:16 <Reisen> looks like I'm not going to get around this without more memory, I'll just have to live without it for a while
00:02:25 <Reisen> thanks for all the help, I appreciate it
00:02:34 <rostayob> Reisen: just compile somewhere else
00:02:55 <rostayob> I guess you just have to run applications there anyway, not develop
00:03:30 <Reisen> it was casual developing I wanted to do there
00:04:50 <rostayob> Reisen: oh, then I don't think that's an option if you want to do haskell
00:05:53 <elliott_> just use a vm :p
00:05:54 <Reisen> yeah, seems so sadly, I guess you get what you pay for with a budget openvz vps
00:06:19 <Reisen> elliott_, yeah shachaf was saying the same, but I can't just setup a VM on the computers in class
00:06:24 <elliott_> true :P
00:06:33 <rostayob> Reisen: wait, what's the problem?
00:06:48 <Reisen> rostayob, as in, with ghc? or in class?
00:07:00 <rostayob> Reisen: the problem with the class computers :P
00:07:18 <Reisen> I can't install software to them
00:07:27 <Reisen> putty I can run off my USB stick without a problem
00:07:30 <rostayob> Reisen: but you can ssh into machines?
00:07:38 <rostayob> ah ok. can't you leave your machine running?
00:08:02 <rostayob> or can't you put ghc in an usb?
00:08:32 <cheater> Reisen: what are you doing?
00:08:34 <Reisen> I thought you couldn't? I did search around for running GHC portably
00:08:39 <Reisen> but didn't find much with google
00:09:21 <rostayob> Reisen: I'm not sure, but you could try i guess. there's also hugs which is probably a lot more lightweight if you just need a simple interpreter to play with
00:09:34 <rostayob> and you have nice error messages!
00:09:36 <Reisen> cheater, was looking for a way to have access to linux and ghc from class while I'm without my laptop
00:10:30 <rostayob> Reisen: anyway, you can always leave your machine running no?
00:10:59 <cheater> Reisen: i have recently run into your problem as well on a vps
00:11:07 <cheater> Reisen: were you trying to compile ghc itself?
00:11:21 <cheater> oh right you were compiling cabal
00:11:26 <Reisen> rostayob, it's not ideal, but possible, also horrible being windows
00:11:26 <cheater> i think that's probably not the best way
00:11:31 <Reisen> cheater, yeah
00:11:43 <rostayob> Reisen: well if your machine is windows it's your fault :P
00:11:46 <cheater> what works for me is: 1. get the generic GHC package, install
00:11:51 <cheater> 2. download haskell platform, install
00:11:58 <Reisen> rostayob, it is indeed
00:12:04 <cheater> did you try doing it like that?
00:12:12 <Reisen> cheater, I didn't, let me try that
00:12:46 <cheater> because I didn't actually have to do "runhaskell Setup.hs"
00:12:55 <elliott_> Reisen: haskell platform still does all the cabal builds
00:12:57 <Reisen> Oh, I feel so stupid now
00:12:59 <elliott_> so it won't solve any out-of-memory
00:13:16 <cheater> get the generic binary here: http://haskell.org/ghc/download_ghc_7_0_3.html#distros
00:13:19 <Reisen> I installed cabal from my package manager before, but had a load of dependency errors with it
00:13:27 <cheater> and the source installer: http://lambda.galois.com/hp-tmp/2011.2.0.1/haskell-platform-2011.2.0.1.tar.gz
00:13:28 <Reisen> just occured to me now I'm not using 7.2.1, it's probably fine
00:13:39 <cheater> Reisen: interesting
00:14:10 <cheater> Reisen: it's probably a good idea to remove everything related to haskell (using eg aptitude purge, not aptitude remove) before installing what's on those two links
00:14:53 <cheater> (i went as far as use "find" on my hard disk to remove everything related to ghc, cabal, or haskell.)
00:15:20 <Reisen> actually all just went perfectly, feel like an idiot for not doing this before
00:15:45 <cheater> so did using those two links work for you?
00:15:52 <cheater> or did you get it from the package manager?
00:15:58 <Reisen> package manager
00:16:01 <cheater> ah cool
00:16:04 <Reisen> but your suggestion is what reminded me
00:16:05 <cheater> what OS are you on?
00:16:06 <Reisen> so thank you
00:16:08 <Reisen> arch
00:16:09 <cheater> yw :)
00:16:35 <elliott_> Reisen: you really want a swapfile; the compile will still break if you run out of RAM, no matter which method you go through
00:17:13 <Reisen> elliott_, for the depencies I wanted I got away with memory it seems, as for swap, seems it's a complete nonoption with OpenVZ, so I just have to hope I never need anything that will break my RAM limit
00:17:27 <elliott_> right. well, haskell-platform will still build cabal-install
00:17:32 <elliott_> which exhausted your ram didn't it?
00:17:43 <Reisen> yeah, but  I grabbed the prebuilt binaries from my package manager
00:18:05 <Reisen> so I didn't need to worry about it
00:18:53 <elliott_> Reisen: then the haskell-platform source tarball is not what you want
00:19:03 <elliott_> mixing distro and source packages does Very Bad Things
00:19:14 <elliott_> especially when the program (cabal-install) is included in the source package
00:19:17 <Reisen> Yeah it isn't, that's what I said to cheater
00:19:22 <elliott_> oh, okay
00:19:28 <elliott_> misread :)
00:19:44 <Reisen> didn't use the source tarballs, problem before was I was using 7.2.1 and so the packages from my package manager were exploding
00:19:56 <elliott_> right
00:20:49 <Reisen> So yeah, all solved, thanks for the time and help, never had as much help in any channel as I have here
00:39:18 * hackagebot cpphs 1.13 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.13 (MalcolmWallace)
00:59:18 * hackagebot hs-java 0.1 - Java .class files assembler/disassembler  http://hackage.haskell.org/package/hs-java-0.1 (IlyaPortnov)
01:20:01 <Jeanne-Kamikaze> who would've thought getting to build your C++ project on windows after 123172398 hours of failed attempts would be so satisfying
01:20:29 <Jeanne-Kamikaze> party at my house tonight, everyone is invited
01:21:10 <mreh> check my statements for sanity, but wouldn't a Random instance for any Enum be desirable?
01:21:58 <mreh> i don't suppose it's possible automatically right now
01:22:03 <mreh> unless bounded
01:27:06 <c_wraith> mreh: there's also the fact that such an instance would be undecideable and overlap nearly everything
01:27:13 <c_wraith> in fact, it *would* overlap everything
01:27:53 <mreh> c_wraith: is everything an enum and bounded?
01:28:11 <quicksilver> mreh: instances of the form Enum a => Random a overlap everything.
01:28:30 <quicksilver> that reads as "a Random instance for every type 'a', which adds an Enum constraint"
01:35:35 <mreh> it also makes for a crummy implementation :)
01:36:12 <mreh> well, my naive way of doing it for abstract data types, just mapping them onto the first n integers
01:36:52 <mreh> how can 6 in a row be considered random
01:37:53 <btby> mreh: https://www.xkcd.com/221/
01:38:32 <kmc> xkcd hurrr hurrr
01:38:59 <mreh> scott adams made that joke already
01:40:05 <mreh> ironically he assembled it from random garbage in his garage
01:40:49 <mreh> http://da.nieltiggemann.de/science/rng/strip_notes.html
01:42:00 <mreh> anyway, -blah
01:45:20 <btby> mreh: Thanks, didn't see that one before.
01:46:13 <btby> What's the cheapest option for Haskell hosting nowadays? NearlyFreeSpeech?
01:47:00 <merijn> What do you mean by Haskell hosting?
01:47:12 <mreh> Haskell hosting, I'm intruiged
01:47:23 <merijn> Hosting websites/apps written in Haskell, hosting code, etc?
01:47:42 <rostayob> btby: nearlyfreespeech has haskell? that hosting company is great. it's probably simple cgi anyway
01:47:59 <mreh> compile it on a vps
01:48:07 <rostayob> btby: if you want to do serious web dev with haskell, you need to be able to compile stuff :)
01:48:22 <rostayob> you might be able to do something on nfs anyway i guess
01:48:28 <elliott_> you can upload compiled cgis
01:48:28 <merijn> Wouldn't it be cheapest to just get a VPS?
01:48:31 <elliott_> with static linking
01:48:32 <elliott_> but they'll still be cgis
01:48:37 <rostayob> yeah
01:48:38 <elliott_> merijn: nearlyfreespeech are way cheaper than a vps
01:48:41 <merijn> That way you can do whatever the hell you want
01:48:49 <btby> Yeah, NFS offers CGI.
01:48:57 <mreh> merijn: easiest I would say, not cheapest, but not expensive either
01:49:04 <rostayob> btby: I guess you can have fun with CGI but for everything "serious
01:49:11 <rostayob> " you need something else
01:49:24 <btby> Gotcha, looks like Linode / EC2 is the way to go then.
01:49:32 <rostayob> yeah that's an option
01:49:38 <rostayob> i have a linode, they're quite good
01:49:38 <c_wraith> isn't heroku free?
01:49:40 <elliott_> btby: plug for http://prgmr.com/ instead of linode :p
01:49:56 <rostayob> prgmr is the hardcore version ehe
01:49:58 <rostayob> but i'm lazy
01:50:11 <elliott_> does Linode really offer much more? apart from automatic wiping I can't think of anything really
01:50:13 <elliott_> maybe backups
01:50:20 <rostayob> automatic backups, nice interface
01:50:45 <rostayob> and prgmr is not that cheaper anyway
01:50:51 <elliott_> fair enough
01:51:37 <rostayob> well actually, it is.
01:51:46 <rostayob> the yearly one. mhm.
01:52:20 <rostayob> the plans are very different anwyay
01:53:21 <btby> prgmr looks exactly like what I need. Heroku is tempting because it's free, but looks like deploying wouldn't be as straightforward as a Xen instance.
01:53:56 <rostayob> btby: heroku is free and has haskell?
01:54:03 <rostayob> wasn't heroku really expensive?
01:54:33 <rostayob> and afaik it doesn't have haskell
01:55:26 <btby> rostayob: Sorry, I might have misunderstood c_wraith's question/assertion.
01:55:49 <rostayob> yeah I just checked
01:57:52 <kmc> heroku lets you run other languages now
01:57:57 <kmc> there's  ablog post about using haskell on it
01:59:06 <rostayob> mhm interesting
01:59:24 <kmc> cheap xen instance sounds like the path of least resistance
01:59:33 <kmc> compiling will require lots of ram, but you can compile locally and copy binaries
01:59:40 <kmc> with ghc, haskell libs are statically linked by default
01:59:55 <cheater> yeah but can you totally cross compile?
02:00:04 <cheater> like say host is 32 and target is 64
02:00:05 <rostayob> cheater: yes, as long as you have the same glibc :P
02:00:07 <rostayob> ah
02:00:08 <rostayob> no
02:00:14 <rostayob> afaik
02:00:20 <cheater> that's not good
02:00:28 <rostayob> but I regularly compile stuff and then run it on the remote server
02:00:42 <cheater> but you probably compile it on the same thing it runs on right?
02:01:04 <rostayob> cheater: not really, again the only thing that really matters is glibc
02:01:20 <btby> What about HaLVM by Galois?
02:01:20 <cheater> but you still need to have the same arch
02:01:28 <cheater> you just said that you need the same arch?
02:01:34 <rostayob> cheater: yes yes, but different systems
02:01:38 <cheater> ok
02:01:46 <cheater> but not like bsd and linux?
02:01:49 <cheater> just linux and linux
02:01:56 <rostayob> cheater: linux and linux yeah
02:01:59 <cheater> k
02:02:21 <kmc> btby, what about it
02:02:42 <kmc> cheater, you can run 32-bit binaries on a typical x86_64 linux system
02:02:52 <kmc> but it's still easier to match the architecture exactly, yes
02:02:53 <btby> kmc: Wouldn't it simplify transitioning applications between host/target?
02:03:26 <kmc> you're proposing to write your Haskell webapp as a standalone operating system?
02:03:28 <cheater> kmc: ya
02:04:27 <btby> kmc: Just a thought for a large volume ones. Probably not a good idea for the general case.
02:04:43 <kmc> large volume in what sense?
02:04:57 <btby> Requiring performance gains.
02:05:24 <btby> Over working with OS layer.
02:05:26 <kmc> it could be useful in some specialized purposes
02:05:29 <rostayob> I'd guess that you can't just get a snap application and compile it on halvm...
02:05:48 <rostayob> I think that you can do fairly specific things on a thing like that
02:06:06 <cheater> kmc: Web Scale
02:06:32 <kmc> btby, the OS does a lot of clever things to manage resources efficiently
02:06:40 <kmc> you will have to reimplement many of those things yourself
02:06:54 <kmc> in the average app you would do better to use more OS features, not fewer
02:06:59 <cheater> also you'd most likely be limited to 1 core
02:07:04 <cheater> which cuts your efficiency in 8.
02:07:09 <kmc> is that a specific HaLVM limitation
02:07:14 <cheater> no idea
02:07:30 <cheater> but multi-cpu OSes are not easy to get right
02:07:34 <kmc> ineed
02:07:36 <kmc> indeed*
02:07:46 <btby> kmc: Yeah, my understanding of it is derailed by flawed JVM analogy.
02:07:50 <btby> As I see now.
02:07:58 <kmc> the JVM is *also* doing lots of clever things for performance
02:08:19 <rostayob> btby: halvm is GHC runtime bolted on Xen
02:08:27 <kmc> sophisticated JIT compilers have a huge advantage over traditional compilation
02:09:01 <kmc> do note that on the Shootout, Oracle Java 7 server VM beats GHC Haskell and is the second place language overall
02:09:07 <buntfalke> Hi
02:09:08 <kmc> s/language/implementation/
02:09:09 <kmc> hi buntfalke
02:09:31 <cheater> can you jit haskell?
02:09:35 <kmc> yes
02:09:38 <kmc> it would kick ass
02:09:41 <cheater> do you jit haskell?
02:09:51 <kmc> there's no "production-ready" project for it afaik
02:09:57 <kmc> talk to edwardk about it
02:09:57 <btby> Oh. =(
02:10:05 <cheater> why does edwardk do everything
02:10:12 <rostayob> haskell on the JVM would be great, but haskell is a bitch of a language to write a compiler for
02:10:30 <kmc> i think writing a compiler for Haskell is significantly easier than writing a compiler for C++
02:10:31 <buntfalke> Are IO actions magic/hardcoded? As in: Could I implement myPutChar without relying on the predifined IO functions like putChar/putStr/...?
02:10:34 <btby> Clojure is tempting in that case.
02:10:47 <kmc> buntfalke, no you can't (not in vanilla standard Haskell, anyway)
02:10:49 <rostayob> kmc: yeah but C++ is the only harder language I can think of
02:10:54 <buntfalke> kmc: thanks!
02:11:04 <buntfalke> Explains a lot :-)
02:11:17 <cheater> kmc: i think that the notion of compiling just in time seems compatible with haskell's notion of evaluating just in time
02:11:22 <kmc> Haskell on the JVM would be significantly less good than Haskell on a purpose-built STG-machine tracing JIT
02:11:28 <kmc> yeah
02:12:10 <btby> By the way, is there any established way to run Haskell on GAE?
02:12:15 <rostayob> kmc: I guess, the cool thing about haskell on the JVM would be running  haskell everywhere and the interoperability with existing java stuff
02:12:16 <kmc> not afaik
02:12:25 <kmc> there's at least two Haskell-like languages on JVM
02:12:37 <kmc> Frege and another one
02:12:47 <cheater> Go?
02:12:59 <kmc> y u trollin cheater
02:12:59 <rostayob> lambda-something
02:13:04 <cheater> y no?
02:13:29 <kmc> rostayob, i think any competent Haskell programmer could write a Haskell compiler after reading about 100 pages of papers
02:13:48 <kmc> i think there are plenty of other languages where you will do worse
02:13:57 <thoughtpolice_> the whole real-haskell-on-jvm thing has been done like, at least 3 times before i'm pretty sure. anybody interested in it doesn't have the expertise to work on it, and the people who have the expertise don't see it as a priority. i wonder outside of JVM library access what the JVM would actually buy you
02:14:00 <rostayob> ah no, LambdaVM is something else http://wiki.brianweb.net/LambdaVM
02:14:14 <thoughtpolice_> keep in mind you're going to go through hoops to use those JVM libs too, since they're not pure by any stretch of the imagination
02:14:24 <rostayob> kmc: well the STG one alone is like 80 pages
02:14:27 <kmc> if you read "Typing Haskell in Haskell" and "Implementing Lazy Functional Languages on Stock Hardware: The Spineless Tagless G-machine"
02:14:37 <cheater> thoughtpolice_: relocability
02:14:42 <rostayob> thoughtpolice_: in the same way that C functions are not pure
02:14:45 <kmc> then you know enough to write a working if not super fantastico Haskell compiler
02:14:49 <cheater> thoughtpolice_: there's a huge, huge ecosystem built for the jvm
02:14:52 <rostayob> kmc: yeah that's a bit more than 100 pages
02:14:57 <kmc> rostayob, hmm, i thought it was less than that
02:15:03 <rostayob> iirc
02:15:14 <cheater> you can do a shitload with languages that are JVM in terms of administration and book-keeping
02:15:31 <kmc> you can also ignore parts of it that a) discuss optimizations, or b) discuss workarounds for targeting C which are not relevant if you use something like LLVM
02:15:39 <rostayob> kmc: yes, the STG one alone is 80 pages
02:16:00 <kmc> ok shall i revise 100 to 200?
02:16:08 <rostayob> kmc: :)
02:16:12 <kmc> and i guess one should include the Haskell Report as well
02:16:14 <cheater> thoughtpolice_: in fact, no one would be too interested in using the JVM lib, it's just the "portability"
02:16:19 <kmc> since you have to know what you're implementing ;P
02:16:33 <cheater> or rather, the ease of finding something that will run your code in a not so bad fashion
02:16:34 <kmc> i think much easier than "Haskell on the JVM" would be a good Haskell - Java bridge via FFI and JNI
02:16:45 <rostayob> note that the only viable haskell compiler right now is a compiler that is a drop in replacement to GHC
02:16:53 <rostayob> which is what makes it harder
02:16:56 <thoughtpolice_> cheater: ok, that's a fair enough point. i'm just not sure personally if the seeming impedance mismatch will be worth it (fancy types are going to probably need cajoling on the jvm, GHC's threads are way better for most use cases in haskell,) overall, but like I said people are interested in it.
02:17:00 <rostayob> i'm sure implementing haskell98 is not that bad
02:17:36 <thoughtpolice_> maybe i'm wrong though and some willing hacker just needs to do it, *and* maintain it. the second part is also pretty important
02:17:36 <kmc> rostayob, if your goal is "compile all code anywhere that anyone has ever called 'Haskell'"
02:17:51 <cheater> thoughtpolice_: i am not saying it's a good idea to put haskell in the JVM
02:17:56 <kmc> rostayob, but if your goal is something useful and practical, you can work in standard Haskell or a slight extension
02:18:00 <cheater> i'm just saying what the good sides are of it
02:18:00 <rostayob> kmc: no, my goal is to compile most of the stuff that ghc compiles, a bit what PyPy is to CPython
02:18:04 <kmc> ah
02:18:07 <cheater> i cannot decide if it's a good or bad idea
02:18:09 <kmc> which version of GHC?
02:18:16 <thoughtpolice_> cheater: yeah, that's what i'm trying to do
02:18:18 <rostayob> kmc: the current one
02:18:21 <kmc> okay
02:18:40 <kmc> why is that your goal?
02:18:52 <cheater> PyPy is a very interesting projects
02:18:56 <rostayob> no that's not my goal, that'd be my goal if i wanted to write a haskell compiler
02:19:05 <cheater> the performance gains you get over standard python are really surprising
02:19:12 <kmc> rostayob, why?
02:19:14 <rostayob> and anyway, the fact that the haskell ecosystem is completely dependent on ghc is kind of bad imho
02:19:39 <kmc> rostayob, GHC already does a good job of being GHC.  maybe if you write another compiler you should target a niche that does not require 100% feature compatibility with GHC
02:19:46 <kmc> i agree it's a problem
02:20:07 <rostayob> kmc: mah, i understand what you're saying but in practice it doesn't really work
02:20:08 <thoughtpolice_> i think everybody agrees it's a problem. monoculture is bad
02:20:09 <cheater> well
02:20:24 <cheater> i think PyPy has performance gains over CPython because CPython sucks ass
02:20:39 <rostayob> we really rely on quite a lot of GHC extensions
02:20:42 <cheater> the makers of it are definitely not published and revered language researchers
02:20:58 <thoughtpolice_> actually they are published
02:20:58 <cheater> whereas PyPy is from the ground up made to be good
02:21:03 <thoughtpolice_> oh nvm
02:21:07 <thoughtpolice_> i misinterpreted that sorry
02:21:07 <cheater> thoughtpolice_: but are they revered?
02:21:15 <cheater> ok
02:21:22 <thoughtpolice_> cheater: i thought you meant the pypy people, not the people who made cpython
02:21:31 <cheater> yeah i meant the cpython makers
02:21:44 <cheater> i'm not saying they hadn't shoved a whitepaper here or there
02:21:59 <rostayob> well cpython might not be great, but it runs anywhere
02:22:09 <cheater> but it's not like you'll find citations to Guido on ArXiv
02:22:26 <rostayob> if you want to run a haskell program on some not-so-common or not powerful machine, tough luck
02:22:42 <cheater> why would you want that
02:22:47 <kmc> you're using the word "Haskell" to mean "GHC Haskell" and it's annoying me
02:23:02 <cheater> haha GHC/Haskell
02:23:12 <rostayob> kmc: not really, in general there aren't portable lightweight haskell compilers
02:23:19 <kmc> Hugs is an interpreter for Haskell 98 and it's still an interpreter for Haskell 98, even though it hasn't been released since 2006.  because Haskell 98 has not been released since 1998
02:23:19 <thoughtpolice_> i write GHC/haskell at night and C/C++ during the day!
02:23:20 <cheater> Haskell is GHC/Haskell without the GHC.
02:23:30 <rostayob> kmc: hughs is not portable and is just an interpreter
02:23:34 <kmc> yeah
02:23:36 <rostayob> *hugs
02:23:49 <rostayob> nhc is lightweight but it's just x86...
02:23:50 <cheater> GHC/Haskell is like Linux/Gnu
02:23:51 <kmc> i thought it was reasonably portable
02:23:58 <kmc> what about the output of YHC?
02:24:06 <kmc> it is supposed to be portable too?
02:24:12 <rostayob> yhs is dead i think
02:24:14 <kmc> er, i meant JHC
02:24:14 <quicksilver> rostayob: "hugs is not portable" ?
02:24:17 <thoughtpolice_> nhc isn't very difficult to port from what I remember
02:24:22 <kmc> YHC has a bytecode interpreter which might be portable
02:24:25 <kmc> even if the compiler itself isn't
02:24:25 <thoughtpolice_> hugs is pretty portable since it's all C
02:24:30 <thoughtpolice_> yhc had a bytecode interpreter, yeah
02:24:35 <quicksilver> portability is one of the main advantages of hugs.
02:24:39 <thoughtpolice_> JHC just compiles to straight C99
02:25:03 <rostayob> quicksilver: what does it work on? and anyway the main problem is that hugs is just an interpreter
02:25:04 <thoughtpolice_> this is also an advantage for JHC, because you can take a program it spits out and literally run it just about anywhere (wii, your phone, your desktop, etc)
02:25:10 <thoughtpolice_> (NB: this requires that JHC actually works)
02:25:15 <rostayob> that's why is portable anyway, it doesn't have to generate code
02:25:15 <quicksilver> rostayob: it essentially works everywhere.
02:25:26 <kmc> yeah, i know people were using JHC for Wii dev
02:25:30 <rostayob> quicksilver: oh, interesting
02:25:49 <quicksilver> it has been compiled for phones, palm pilots, washing machines, stainless steel cutlery.
02:26:05 <thoughtpolice_> rostayob: hugs is written almost entirely in C. there's very little in there that would be difficult to port, and people have ported it to quite a few things
02:26:13 <thoughtpolice_> s/almost//
02:26:15 <rostayob> ahah ok, then i was mistaken about hugs. it's still not something you can work with if you want to write applications
02:26:17 <kmc> rostayob, anyway you did not say "compiler" you said "run a haskell program on some not-so-common or not powerful machine"
02:26:25 <kmc> meh
02:26:39 <kmc> you're making baseless assertions
02:26:51 <cheater> why can't you use hugs?
02:27:10 <rostayob> kmc: what's the baseless assertion - apart the "hugs is not portable" one?
02:27:15 <kmc> rostayob, why should we believe your statements about the usability of hugs when you're clearly not very familiar with it?
02:27:31 <cheater> because it's an interpreter
02:27:39 <cheater> and all interpreters are worse than compilers
02:27:41 <kmc> the "hugs can't be used for applications" assertion
02:27:51 <rostayob> kmc: I've used hugs for a year, and it's just an interpreter with nice error messages
02:27:55 <cheater> *obviously*
02:28:05 <kmc> perhaps you're confusing "interpreter" with "REPL"?
02:28:09 <merijn> cheater: Worse != not capable of running full applications
02:28:09 <osfameron> interpreters *are* compilers.  or vice versa.
02:28:23 <rostayob> kmc: ok, you can't produce a binary with hugs.
02:28:27 <cheater> merijn: i think you thought i meant what i said there.
02:28:34 <kmc> rostayob, so?
02:28:44 <kmc> you can produce a single file which, when executed, will run your program
02:28:46 <cheater> rostayob: most linux isn't binaries
02:28:52 <cheater> yet it works
02:29:02 <merijn> rostayob: I would have thought that Ruby/Python are running full applications proves you don't need binaries
02:29:05 <kmc> people write 'applications' in Perl and Python and PHP and other languages with names starting with P
02:29:13 <cheater> there's a difference between "binary" and "executable"
02:29:26 <merijn> Hell, a significant part of the FreeBSD infrastructure is written entirely in sh and Makefiles
02:29:28 <cheater> NONE of the web applications you'll find on people's CVs come in binary form
02:29:40 <cheater> and the web is all you see all day long
02:29:43 <cheater> your assertion sucks
02:30:03 <rostayob> uff ok, ok. my original point is that if you write a haskell application you won't end up with portable code
02:30:27 <cheater> portable to what?
02:30:31 <thoughtpolice_> merijn: it's almost frightening how much infrastructure is powered by sh and makefiles, yes
02:30:32 <buntfalke> @source <-
02:30:33 <lambdabot> <- not available
02:31:03 <merijn> buntfalke: If you're referring to the "<-" in do-notation, that is just syntactic sugar
02:31:07 <rostayob> cheater: to whatever. if you write python, for example, the reference implementation supports this: http://en.wikipedia.org/wiki/CPython#Supported_platforms
02:31:14 <cheater> so?
02:31:31 <cheater> if you're writing your IndustryApplication why would you run it on anything else than windows, linux, or unix?
02:31:41 <rostayob> so if I want to run my haskell application on some embedded platform or whatever, it's going to be really hard
02:31:41 <buntfalke> merijn: What's it translated to?
02:31:57 <cheater> why do you want to run your haskell application on some embedded platform?
02:32:03 <thoughtpolice_> cheater: i have an EnterpriseApplication so it needs to run in the cloud-javascript-browser
02:32:04 <buntfalke> merijn: I search for some kind of formap definition. Source, maths, ...
02:32:08 <kmc> @undo do { y <- f x; return (g y) }
02:32:09 <lambdabot> f x >>= \ y -> return (g y)
02:32:11 <cheater> you're obviously complaining that your tank doesn't have a good city mileage
02:32:31 <rostayob> cheater: what do you mean "why do you want to run my haskell application on some embedded platform
02:32:32 <merijn> buntfalke: "do {s <- some expr; foo s}" gets translated to "(some expr) >>= foo"
02:32:34 <danr_> @pl f x >>= \ y -> return (g y)
02:32:35 <lambdabot> g `fmap` f x
02:32:42 <rostayob> I have an embedded platform, i want to program it, i like haskell
02:32:52 <rostayob> isn't that enough?
02:32:52 <buntfalke> Oh. I see
02:32:58 <cheater> no
02:33:02 <merijn> buntfalke: Actually, to be exact it gets translated to "(some expr) >>= \s -> foo s"
02:33:04 <rostayob> no?
02:33:10 <cheater> haskell is not a language made for embedded platform programming
02:33:18 <rostayob> cheater: who decided that?
02:33:19 <merijn> rostayob: Look at Habit?
02:33:24 <cheater> i have
02:33:32 <rostayob> oh shit, why?
02:33:34 <thoughtpolice_> cheater = decider
02:33:40 <cheater> because i am the decider
02:33:41 <buntfalke> merijn: How do those two differ in practise? I see the two different types, but they look very semantically equal.
02:33:48 <buntfalke> kmc: thanks
02:33:51 <rostayob> cheater: no, why did you decide that eheh
02:33:57 <cheater> whim
02:34:08 <rostayob> also, i doubt that anyone "decided" that python could run on embedded platforms ehe
02:34:15 <merijn> buntfalke: They are semantically equal in this case. But imagine if s occurs multiple times in the lambda, prevents duplication
02:34:37 <merijn> buntfalke: If you do statement is longer the lambda scopes over *all* following lines
02:34:42 <merijn> s/you/your
02:35:13 <buntfalke> @undo do {s <- getChar; putChar s; putChar s}
02:35:14 <lambdabot> getChar >>= \ s -> putChar s >> putChar s
02:35:15 <rostayob> and hugs is not an option really if you want to do something serious, but if you guys want to argue otherwise, whatever
02:35:42 <merijn> buntfalke: "do { s <- some expr; foo s; bar s}" translates to "(some expr) >>= \s -> do { foo s; bar s}"
02:35:44 <kmc> rostayob, you've said that several times, yes
02:36:00 <cheater> rostayob: of course they have
02:36:07 <cheater> rostayob: everything in Python is decided
02:36:12 <cheater> obviously you have missed PEP11
02:36:30 <rostayob> cheater: I mean when guido created the language in the first place
02:36:33 <rostayob> it just evolved that way
02:36:54 <cheater> guido didn't create a language, he postulated a language
02:37:00 <cheater> it was co-created by many
02:37:08 <rostayob> well haskell is the same now
02:37:22 <merijn> buntfalke: As you can see, without the lambda in your example you'd read two different characters instead of using the same one twice
02:38:04 <rostayob> kmc: yeah I've said that and I think everyone would agree with that, despite the fact that "every interpreter is a compiler, and vice-versa"
02:38:41 <cheater> rostayob wins the undisputed prize for most boring conversation of the week
02:38:44 <cheater> and it's only monday
02:38:51 <rostayob> cheater: aha
02:39:03 <rostayob> I don't think it's boring, but ok
02:39:12 <buntfalke> merijn: Ah, I see. Can s be shadowed in the follow-up "do"? "do { s <- some expr; foo s; bar s; s <- some expr2; test s}" would become "(some expr) >>= \s1 -> do { foo s1; bar s1} >> (some expr2) >>= \s2 -> test s" is this correct?
02:39:14 <cheater> i know you don't
02:39:15 <kmc> cheater++
02:39:22 <buntfalke> merijn: notice i used >> once instead of >>=
02:39:48 <buntfalke> s1 and s2 is just to clearify which is meant, they were both s in the first form
02:39:54 <rostayob> one day you'll understand
02:40:02 <merijn> buntfalke: >>= is only used after a <-, all other semicolons are replaced with ">>"
02:40:20 <merijn> buntfalke: Also, the s doesn't need to be renamed in the translation, normal scoping rules solve the problem
02:40:34 <Jafet> Except for let-statements
02:40:36 <buntfalke> yes, so my translation is correct?
02:40:36 <mauke> <buntfalke> s1 and s2 is just to clearify which is meant, they were both s in the first form
02:40:42 <mauke> buntfalke: no
02:40:56 <mauke> buntfalke: why does your translation have an inner do block?
02:41:38 <buntfalke> Does it matter? It would be partially translated, that inner foo-bar do-block would have to be >>'ed, too.
02:41:54 <mauke> but there are no nested blocks in the original
02:42:20 <buntfalke> Does it change the sematics?
02:42:22 <cheater> i am asking myself that same question
02:42:35 <mauke> good question
02:42:36 * buntfalke tries to translate it completely
02:42:37 <merijn> mauke: Probably my mistake since my example of expanding the <- I didn't expand the following lines with >>
02:42:57 <mauke> probably not because of the monad laws
02:43:09 <merijn> buntfalke: "do { s <- some expr; foo s; bar s; s <- some expr2; test s}" expands to "(some expr) >>= \s -> foo s >> bar s >> ((some expr2) >>= \s -> test s)"
02:43:22 <mauke> do { s <- some expr; foo s; bar s; s <- some expr2; test s }
02:43:24 <merijn> Unless I f'ed up
02:43:30 <mauke> some expr >>= \s -> do { foo s; bar s; s <- some expr2; test s }
02:43:39 <mauke> some expr >>= \s -> foo s >> do { bar s; s <- some expr2; test s }
02:43:46 <mauke> some expr >>= \s -> foo s >> bar s >> do { s <- some expr2; test s }
02:43:57 <mauke> some expr >>= \s -> foo s >> bar s >> some expr2 >>= \s -> do { test s }
02:44:00 <mauke> some expr >>= \s -> foo s >> bar s >> some expr2 >>= \s -> test s
02:44:13 <merijn> Yay, I got it right, modulo redundant parentheses
02:44:39 <Jafet> @undo do { s <- some expr; foo s; bar s; s <- some expr2; test s }
02:44:39 <lambdabot> some expr >>= \ s -> foo s >> bar s >> some expr2 >>= \ s -> test s
02:44:49 <buntfalke> mauke: Thanks!
02:44:57 <merijn> buntfalke: Anyway, as you can see normal scoping rules already make the "s" in test s refer to the proper s
02:45:32 <merijn> These examples make me really appreciate do-notation
02:46:03 <buntfalke> merijn: Yes, I just renamed it to show that I mentally think of this s-scoping, and would like agreement on it's correctness :-)
02:46:17 * buntfalke is a monad-n00b :-)
02:47:29 <buntfalke> How would it be possible to translate "do { s <- getChar; putChar s; putChar s}" /without/ using the lambda "\s ->"?
02:47:46 <mauke> @undo do { s <- getChar; putChar s; putChar s}
02:47:46 <lambdabot> getChar >>= \ s -> putChar s >> putChar s
02:47:52 <mauke> @unpl getChar >>= \ s -> putChar s >> putChar s
02:47:52 <lambdabot> (getChar >>= \ s -> (putChar s) >> (putChar s))
02:47:56 <mauke> @pl getChar >>= \ s -> putChar s >> putChar s
02:47:56 <lambdabot> liftM2 (>>) putChar putChar =<< getChar
02:48:01 <mauke> there we go
02:48:04 <buntfalke> what does "pl" stand for?
02:48:07 <mauke> pointless
02:48:32 <mauke> what it does is convert code to points-free form
02:48:36 <mauke> i.e. without lambdas
02:48:46 <merijn> "getChar >>= putChar &&& putChar"?
02:49:16 <mauke> doesn't that require tuples?
02:49:30 <buntfalke> merijn: That would be an arrow(right?), and don't they in turn rely on monads?
02:49:44 <mauke> :t putChar &&& putChar
02:49:45 <lambdabot> Char -> (IO (), IO ())
02:49:51 <mauke> yeah, not what we want
02:49:58 <merijn> I was afraid of that, yeah :\
02:50:03 <buntfalke> :-)
02:50:21 <mauke> :t getChar >>= join (>>) putChar
02:50:22 <merijn> buntfalke: &&& is one of the Arrow functions, yes. But to me they make more sense when you ignore the entire concept and arrows and just look at their signatures
02:50:22 <lambdabot> IO ()
02:50:40 <buntfalke> is there a command line too which does what lambdabot can do? so i can do it offline? (i know query the bot, but still...)
02:50:42 <merijn> s/concept and/concept of
02:51:01 <merijn> There is a ghci with lambdabot support, yeah
02:51:04 <mauke> lambdabot, theoretically
02:51:06 <merijn> Forgot what its called though
02:51:12 <mauke> goa
02:51:27 <buntfalke> merijn: (arrows) Same for me so far :-)
02:53:01 <kmc> :t (&&&)
02:53:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:53:26 <kmc> for (Arrow (->)) that's  (b -> c) -> (b -> c') -> (b -> (c, c'))
02:55:59 <mauke> (&&&) :: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
02:56:25 <merijn> What is ~>?
02:56:33 <opqdonut> a type variable
02:56:49 <opqdonut> (an infix one)
02:56:54 <buntfalke> Looks like a drunken -> :-d
02:56:56 <merijn> ah, right
02:57:02 <osfameron> an infix variable?
02:57:08 <osfameron> it's shaped like an op?
02:57:13 <kmc> yep
02:57:13 <opqdonut> yeah
02:57:17 <kmc> an operator not starting with :
02:57:24 <kmc> : is "upper case" i.e. a constructor
03:19:46 <osfameron> yay! http://dl.dropbox.com/u/4274210/cat/recurcat.gif
03:20:18 <merijn> osfameron: Add it to the lambdacats site? :) (If that allows new additions)
03:21:03 <osfameron> looks like the arcanux lambdacats site is defunct
03:21:10 <merijn> @where lambdacats
03:21:10 <lambdabot> http://tinyurl.com/lambdacats
03:21:13 <osfameron> they are on http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960526154_fqpKB though (via google)
03:21:19 <osfameron> aha
03:22:11 <osfameron> deguerre<TAB> meh, not on irc
03:22:55 <merijn> I should just get a nice TLD for that and mirror it :>
03:24:37 <buntfalke> :t liftM2 (>>)
03:24:38 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, Monad m1) => m1 (m a) -> m1 (m b) -> m1 (m b)
03:24:47 <buntfalke> Omfg.
03:25:35 <merijn> It's scary that that is making sense to me
03:25:48 <kmc> oh dear
03:26:00 <mauke> :t liftM2 (>>) f
03:26:01 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m, SimpleReflect.FromExpr (m1 (m a)), Monad m1) => m1 (m b) -> m1 (m b)
03:26:06 <kmc> i once got screwed over because i wrote (>>) when i meant «liftM2 (>>)»
03:26:10 <mauke> :t liftM2 (>>) id
03:26:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m b) -> m a -> m b
03:26:19 <kmc> (>>) works for functions but is not very useful ;P
03:26:19 <mauke> better
03:26:22 <kmc> > (pred >> succ) 3
03:26:23 <lambdabot>   4
03:26:41 <mauke> buntfalke: set m1 = (e ->)
03:30:46 <mysticc> How to change the version of base
03:31:00 <kmc> upgrade GHC
03:31:12 <mysticc> I am not able to install some packages because it requires base<4
03:31:22 <kmc> those packages need to be updated for your GHC
03:31:27 <mysticc> kmc: I want to degrade to base 3.x
03:31:39 <kmc> then you will have to downgrade to GHC 6.8
03:31:45 <kmc> or you can use GHC 6.12 with the base3-compat package
03:31:49 <kmc> but not GHC 7
03:31:49 <mysticc> the package is xmonad-utils
03:31:54 <buntfalke> :t liftM2 (>>) putChar putChar
03:31:55 <lambdabot> Char -> IO ()
03:32:02 <buntfalke> :t liftM2 (>>) putChar
03:32:03 <lambdabot> forall b. (Char -> IO b) -> Char -> IO b
03:32:08 <kmc> or you could update the package
03:32:43 <mysticc> kmc: No luck with updating the package .. the latest version requires base < 4
03:34:40 <mysticc> kmc: how to check the current version of base installed
03:35:19 <kmc> mysticc, by updating i meant that you'd edit the code and fix it up
03:35:28 <kmc> mysticc, ghc-pkg list base
03:35:35 <kmc> again though, the version of base is tied to the version of GHC
03:36:02 <kmc> you cannot get base version 3 unless you downgrade to GHC 6.8
03:36:14 <kmc> or you can downgrade to GHC 6.12 and modify xmonad-utils to use the base3-compat package
03:36:25 <mysticc> ok .. I already downgraded ...
03:36:30 <kmc> or you can modify xmonad-utils to be compatible with base-4
03:36:40 <hpaste> buntfalke pasted “@pl@undo do{[...]}” at http://hpaste.org/51803
03:36:58 <gienah> mysticc kmc: the approach I normally use is to hack the cabal file, then patch the breakages in the source code
03:41:12 <mysticc> how to reinstall all the installed packages , thorough cabal
03:43:00 <gienah> miniplex: no idea about re-installing all installed packages through cabal. For base 4, things like changing import Control.Exception to import Control.OldException, like for example: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/miniplex/files/miniplex-0.3.4-base4.patch
03:47:38 <buntfalke> @source sequence
03:47:39 <lambdabot> sequence not available
03:48:36 <buntfalke> > return []
03:48:37 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
03:48:37 <lambdabot>    arising from a use of `M14955061...
03:48:52 <buntfalke> ?
03:49:04 <merijn> buntfalke: It doesn't know which monad you want to return [] into
03:49:25 <kmc> > return [] :: Maybe [Int]
03:49:26 <lambdabot>   Just []
03:49:27 <int-e> > return [] :: [[Int]]
03:49:28 <lambdabot>   [[]]
03:49:39 <kmc> > (return [] :: Bool -> [Int]) True
03:49:40 <lambdabot>   []
03:50:18 <buntfalke> Hmm, I see...
03:50:37 <merijn> buntfalke: [] can be any arbitrary list and return can insert something into an arbitrary monad. Normally type inference lets the compiler determine which type of list and which monad you meant
03:50:49 <merijn> Absent any context you will have to tell it explicitly which you meant
03:51:38 * buntfalke nods
03:54:07 <buntfalke> @do p >>= \x -> q >>= \y -> return (x:y)
03:54:08 <lambdabot> do { x <- p; y <- q; return (x : y)}
04:18:34 <aleator> Hey, is there a name for f a b = (a <$>) . b ?
04:18:51 <Leif_Bork> Hi!
04:19:08 <opqdonut> :t let f a b = (a <$>) . b in f
04:19:09 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:19:50 <opqdonut> looks like "fmap.fmap"
04:19:54 <opqdonut> also known as "fmap fmap fmap"
04:23:53 <hpc> also known as (.:) sometimes
04:28:24 <Leif_Bork> To cabal install, I pass along the following ghc options: -rtsopts=all -threaded
04:28:39 <mysticc> I have a pkg installed but when I try to import it in ghci it says can't find module ... what can be the problem
04:29:26 <Leif_Bork> Yet, when I run my program with +RTS -N -RTS it says unexpected RTS argument: '-N4' and Most RTS options are disabled. Link with -rtsopts to enable them.
04:32:08 <kmc> Leif_Bork, does 'cabal install' understand those flags?
04:32:30 <Leif_Bork> kmc: I use --ghc-options=
04:32:32 <kmc> i'd guess you need something like --ghc-option=-rtsopts --ghc-option=-threaded
04:32:32 <kmc> ah
04:32:49 <kmc> maybe you should 'cabal clean' and try again?
04:33:52 <Leif_Bork> kmc: Thanks! I'll try!
04:37:36 <mysticc> I have installed a module using cabal but I am not able to import it .. says module not found .. ??
04:38:10 <rostayob> mysticc: what package is it? does ghc-pkg list show it?
04:38:45 <mysticc> rostayob: xmonad-contrib ... yes it shows it
04:39:18 <rostayob> and the module is?
04:39:53 <mysticc> XMonad.Util.WorkspaceCompare
04:40:44 <rostayob> mysticc: works for me... what error do you get if you try ":m XMonad.Util.WorkspaceCompare"?
04:41:41 <mysticc> <no location info>: Could not find module `XMonad.Util.WorkspaceCompare':
04:42:18 <rostayob> mysticc: and ghc-pkg list lists xmonad-contrib?
04:42:25 <mysticc> rostayob: yup
04:42:34 <rostayob> then I don't know, wait for someone else
04:42:59 <mysticc> I can even find it inside ~/.cabal/lib/
04:52:00 <plat0_> Is there a way to express in the Haskell type system that for function f :: [T] -> [T], f xs is the same length as x (for some specific type T, say Int if you like)
04:52:18 <plat0_> *... f xs is the same length as xs ..
04:52:29 <rostayob> plat0_: no, maybe dependent types will help you?
04:52:31 <opqdonut> yes there is, but only if you use a custom [] type that tracks the length
04:52:41 <opqdonut> and it might get unwieldy
04:52:42 <rostayob> oh right, if you define a custom type you can
04:52:53 <rostayob> but not with lists
04:53:21 <plat0_> OK, I have the same question about the "shape of trees" too, or any other similar datastructure
04:53:33 <opqdonut> same applies
04:53:36 <plato0> OK
04:53:54 <plato0> So somehow Church encode the length into the datatype?
04:53:55 <rostayob> plato0: maybe this will be of interest http://okmij.org/ftp/Haskell/types.html#branding
04:54:06 <rostayob> it's not exactly what you're asking for but it's related
04:54:07 <opqdonut> one way of "proving" things like that is saying "f = fmap g"
04:54:31 <opqdonut> that will retain the shape due to the functor laws
04:54:32 <rostayob> plato0: well you don't encode them with functions like church numerals, but with type classes
04:55:01 <rostayob> plato0: http://hackage.haskell.org/package/type-level
04:55:35 <plato0> opqdonut: sure, but f might not be expressible in that form.  It might be sort, for example.
04:55:43 <opqdonut> or, relatedly, making f more generic: f :: (Functor fun) => fun T -> fun T
04:55:56 <plato0> Basically I'm curious to what extent properties of a function can be encoded in the type system.
04:55:57 <opqdonut> of course you can substitute Functor for some other type class which has the necessary primitives
04:56:02 <opqdonut> like, I don't know, Traversible?
04:56:07 <Leif_Bork> kmc: It worked! I'm very happy to announce you a grant of 11 karma points! If the karma point system is unknown to you, I can inform you that 11 karma points is about equal to 35 cars doing softer decelerations for you at pedestrian crossings during a time span of about 3-5 months.
04:56:10 <opqdonut> probably not
04:56:33 <Botje> Leif_Bork: I wish to subscribe to your newsletter.
04:57:08 <mysticc> Any Body who can tell ... I have a module installed but I am not able to import it ??
04:57:20 <kmc> yay
04:57:30 <mysticc> says  <no location info>: Could not find module `XMonad.Util.WorkspaceCompare
05:02:46 <mysticc> kmc: ^^
05:03:48 <mreh_> how can I mod a floating point number somebody
05:03:58 <mreh_> best I've got is repeated subtraction
05:05:09 <dino-> Good morning Haskell people.
05:05:25 <dino-> mreh_: Can you give me more info, or example of what's not working?
05:05:46 <quicksilver> mreh_: mod' from Data.Fixed
05:06:02 <quicksilver> @hoogle mod'
05:06:02 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
05:06:02 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
05:06:18 <quicksilver> > 5.5 `mod` 1.2
05:06:19 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:06:19 <lambdabot>    `GHC.Real.Integral a'
05:06:19 <lambdabot>   ...
05:06:25 <quicksilver> > 5.5 `mod` 1.2 :: Double
05:06:26 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
05:06:26 <lambdabot>    arising from a use ...
05:06:35 <quicksilver> > 5.5 `mod'` 1.2 :: Double
05:06:36 <lambdabot>   0.7000000000000002
05:07:12 <Leif_Bork> Botje: Thank you, I believe, tho IRC filters out mosts signs of irony.
05:07:16 <rostayob> plato0: actually, this is exactly what you're looking for: http://www.ict.kth.se/forsyde/files/tutorial/tutorial.html#FSVec . they encode the numbers with some data types representing the digits, and a type constructor :* to concatenate digits
05:07:30 <mysticc> still no bodu to help with <no location info>: Could not find module `XMonad.Util.WorkspaceCompare
05:07:43 <Botje> Leif_Bork: I wasn't being ironic. I like the idea of a standard unit of karma :)
05:07:43 <rostayob> in general, while this things can be done in haskell, they're kind of awkward
05:07:54 <rostayob> mysticc: if noone answered, no one can help right now
05:08:15 <mysticc> rostayob: ok ... I think I will ask again later ...
05:08:16 <Botje> mysticc: have you tried #xmonad?
05:08:53 <mreh_> quicksilver: thanks
05:09:28 <kmc> quicksilver, oh, that's very good to know :)
05:09:29 <kmc> thanks
05:23:24 <plato0> rostayob: Oh that's nice, thanks.
05:29:50 <elliott> hi
05:29:52 <elliott> oops
05:29:54 <elliott> wrong window
05:30:01 <elliott> but hi anyway
05:32:13 <rostayob> elliott: hi
05:32:26 <plato0> hi
05:33:11 <erus`> @src liftM
05:33:11 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:33:56 <erus`> i love monads so hard
05:35:00 <elliott> :t liftM
05:35:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
05:35:03 <elliott> :t fmap
05:35:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:35:10 <elliott> erus`: I love functors so hard.
05:42:05 <mreh_> quicksilver: before I got sidetracked I meant to ask about Reactive again
05:43:02 <mreh_> could you provide some insight into the whole channel architecture, I've got a massive space leak like yours on key press events, like it's reprocessing every key press since the start
05:43:30 <mreh_> i've seen the fix you made, but i'd really like a generalised understanding :)
05:44:27 <mreh_> @seen quicksilver
05:44:27 <preflex>  quicksilver was last seen on #haskell 37 minutes and 53 seconds ago, saying: > 5.5 `mod'` 1.2 :: Double
05:44:28 <lambdabot> Unknown command, try @list
05:44:35 <mreh_> fleeb
05:44:59 <skatez|peecee> http://ccinsider.comedycentral.com/files/2011/04/Glee-vs-Futurama.jpg
05:49:38 * hackagebot vault 0.1.0.0 - a typed, persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.1.0.0 (HeinrichApfelmus)
05:50:51 <erus`> are the ICFP talks online anywhere yet?
05:54:27 <rtharper_> Question: Am teaching a course for a bunch of programmers but Haskell n00bs, need a good text editor installed on the machine
05:54:34 <rtharper_> some of them are coming from a windows only (no emacs) background
05:54:42 <rtharper_> but the course machines are macs
05:54:51 <rtharper_> any editor suggestions?
05:55:20 <erus`> gedit ofc
05:55:57 <erus`> works great on windows and *nix so im sure it works on mac
05:56:09 <erus`> has syntax highlighting for haskell out of the box
05:56:15 <parcs> why no emacs?
05:56:38 <erus`> parcs: because you have to learn all the shortcuts and stuff?
05:56:42 <parcs> no you don't
05:56:48 <parcs> there's a toolbar on top
05:57:09 <osfameron> yeah, but you might accidentally press a shortcut that you then can't get out of ;-)
05:57:33 <rostayob> also, you have to manually install haskell-mode. gedit is probably better for beginners anyway
05:57:45 <erus`> can you move the cursor with the arrow keys?
05:57:50 <rostayob> erus`: ofc
05:58:06 <rostayob> which editor doesn't do that?
05:58:19 <osfameron> vim!
05:58:26 <osfameron> well, vi
05:58:27 <rostayob> you can move with the arrow keys in vim
05:58:27 <dino-> Not true. You're in the wrong mode.
05:58:29 <rostayob> maybe in vi
05:58:31 <rostayob> yeah
05:58:32 <osfameron> even vim lets you move the arrow keys
05:58:40 <osfameron> but real vim users will look at you funny if you do ;-)
05:58:50 <rostayob> well in insert mode
05:59:13 <osfameron> oh, the arrow keys work in any mode
05:59:24 <rostayob> well 'j
05:59:24 <osfameron> I've just trained myself out of using them...
05:59:38 <rostayob> j will type j in insert mode ehe
05:59:49 <quicksilver> there are two kinds of people in the world. People who can learn to use emacs, and people who should never be let near a computer which is capable of anything apart from facebook and email ever again.
05:59:51 <parcs> i think emacs is ideal. it is very advanced but can be used as a 'simple' text editor, and it has haskell-mode
06:00:08 <mreh_> WHAT ABOUT VIM?
06:00:21 <rostayob> parcs: not really, switching buffers for example is not that simple without knowing how
06:00:35 <osfameron> has the emacs documentation been updated to not consistently refer to keys that DON'T EXIST? ;-)
06:00:42 <rostayob> gedit is a lot better if you have to teach a class
06:00:47 <aninhumer> Perhaps just have emacs available for people who want to learn it?
06:00:49 <parcs> rostayob: there's a Buffer menu option on top..
06:00:52 <erus`> quicksilver: there are many types of people in the world, you fall into the elitist-with-aspergers category
06:00:57 <parcs> Buffer -> foo.hs, Buffer -> bar.hs
06:00:58 <parcs> easy
06:01:01 * osfameron eventually completed the emacs onboard tutorial after third attempt (mostly having given up in frothy rage the first two times)
06:01:07 <rostayob> parcs: no, having visible tabs is easier
06:01:14 <rostayob> (note that i'm a hardcore emacs user eh)
06:01:17 <parcs> easier, but it's still easy
06:01:32 <mreh_> quicksilver: just want to know if you're ignoring my questions deliberately, if so I'll go away :D
06:01:47 <rostayob> well, iswitch-moe is great, it's just that you have to explain the people how it works
06:01:49 <dino-> vim has excellent tutorial built-in as well.
06:01:56 <quicksilver> mreh_: which question?
06:02:13 <mreh_> quicksilver: it was pushed up about two screns
06:02:15 <dino-> Well, vimtutor comes with it
06:02:16 <quicksilver> oh, that one
06:02:17 <osfameron> dino-: yeah.  but to be fair, with vim, you'd spend the whole first lesson teaching the class vim.  Which isn't ideal.
06:02:21 <quicksilver> didn't see it, sorry
06:02:29 <mreh_> np
06:02:34 <erus`> you guys can run a vim/emacs course before rtharper_'s haskell class
06:02:36 <dino-> osfameron: I can agree with that.
06:02:51 <rtharper_> erus`: It's a one week intensive course, I only do the practical portion
06:03:05 <quicksilver> erus`: and you fall into the "acting like an idiot" category.
06:03:11 <rostayob> rtharper_: i think that gedit is ideal, works well on every major platform, supports haskell, lightweight
06:03:23 <rtharper_> rostayob: yeah, thanks everyone =)
06:03:27 <rtharper_> I will put emacs on there as well
06:03:29 <rtharper_> for those who want it
06:03:32 <mreh_> i've met professional programmers who like gedit
06:03:50 <rtharper_> but I need something for the lowest common denominator, as well
06:04:09 <quicksilver> erus`: (1) throwing around terms like 'aspergers' in a derogatory fashion sucks (2) my comment was not intended seriously.
06:04:12 <parcs> what is confusing about emacs to the lowest common denominator?
06:04:13 <aspect> don't try and teach people emacs or vim in a day.  that's just asking for alienation.  those that want it will go out of their way to use it -- let the rest muddle along with something a little more familiar
06:04:15 <parcs> just curious
06:04:28 <osfameron> throwing around asparagus would be tasty (though out of season, so maybe not)
06:04:51 <rostayob> parcs: the overwhelming number of options for one, selecting and copying/pasting text
06:04:58 <osfameron> parcs: terminology.  documentation.  chording keystrokes.  buffers.
06:05:03 <aninhumer> osfameron: depends if it's cooked (perhaps, I don't know how it tastes raw)
06:05:08 <quicksilver> mreh_: events shouldn't end up being evaluated twice, AFAICR.
06:05:22 <erus`> I didnt mean to upset you quicksilver, i was just playing along
06:05:22 <rostayob> parcs: an interface like gedit is much more familiar to the avg user
06:05:31 <quicksilver> mreh_: each 'point in time' becomes a simple haskell value, should get evaluated at most once.
06:05:42 <quicksilver> erus`: OK, good :)
06:05:59 <rostayob> i love emacs, but the default key bindings SUCKS
06:06:06 <parcs> hmm yeah i guess a new user would still be intimidated by a gui like emacs'..
06:06:12 <quicksilver> mreh_: the potential leak that I think I'm aware of is caused by not evaluating often enough (so the thunks spiral in size). Evaluating too often shouldn't be a problem.
06:06:29 <rostayob> parcs: oh also, the undo mechanism
06:06:33 <rostayob> that's still confusing to me
06:06:42 <parcs> ah yeah
06:06:44 <parcs> right
06:06:45 <rostayob> thank god for undo-tree
06:06:50 <merijn> rtharper_: Which platform is this course on? *nix?
06:07:06 <rtharper_> merijn: mac
06:07:13 <merijn> Ah
06:07:30 <merijn> Everyone on OSX seems to wank over TextMate, but of course that isn't free and I never used it :p
06:07:37 <parcs> lol
06:07:39 <rtharper_> merijn: I am an OS Xuser
06:07:43 <rtharper_> I prefer vi
06:07:45 <rostayob> merijn: that exists for windows as well
06:07:45 <parcs> merijn: the new thing is sublime text 2 dude
06:07:47 <rtharper_> well, MacVim
06:07:48 <mreh_> quicksilver: okay, that makes sense, just watching it grow more or less linearly and never bottom out is strange
06:08:05 <mysticc> Is there a way to reinstall all the broken packages listed in ghc-pkg check
06:08:08 <merijn> rtharper_: So am I, I do everything in MacVim :p
06:08:11 <jpcooper> hello
06:08:17 <jpcooper> is it possible to test for type equality in ghci?
06:08:17 <rostayob> mysticc: cabal install --reinstall world maybe?
06:08:22 <merijn> I'm just using hyperbole for comic effect :p
06:08:37 <rostayob> jpcooper: Data.Typeable can do that, but for monomorphic types
06:08:39 <osfameron> what's undo-tree?
06:08:52 <merijn> Maybe something like Nano?
06:08:54 <rostayob> osfameron: it visualizes your changes in emacs, it's pretty cool
06:09:00 <jpcooper> rostayob: say I've defined a type synonym. I would like to test whether a given value has the same type as it
06:09:01 <mysticc> rostayob: I just want to correct the broken packages ... will it not reinstall all the packages again ??
06:09:03 * osfameron still hasn't quite got around to learning the "new" undo mechanism in vim either
06:09:11 <osfameron> or, tbh, how to handle multiple files in one vim instance...
06:09:19 <parcs> lol
06:09:20 <rostayob> osfameron: emacs undo system is pretty powerful, but without a tool like that it's messy
06:09:38 * hackagebot reactive-banana 0.4.2.0 - Small but solid library for  functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.4.2.0 (HeinrichApfelmus)
06:09:38 <rostayob> jpcooper: typeOf
06:09:40 <rostayob> :t typeOf
06:09:41 <lambdabot> forall a. (Typeable a) => a -> TypeRep
06:09:41 <merijn> osfameron: Me neither, I just use several vim instances (well a mix of multiple files per instance and multiple instances)
06:09:45 <parcs> look what you have created rtharper_ !
06:09:49 <merijn> For a beginner class anything with syntax highlighting and auto-indent should be sufficient
06:09:56 <rostayob> jpcooper: i'm not sure about how typeOf works with type synonym
06:10:00 <rostayob> but you can investigate
06:10:01 <jpcooper> rostayob: that isn't exactly what I want
06:10:03 <osfameron> merijn: yeah!  Lots of separate windows so I can see multiple files at same time.
06:10:22 <jpcooper> never mind
06:10:27 <merijn> osfameron: I use tmux for vertical splitscreen so I have one vim on one side and one on the other :p
06:10:29 <osfameron> I occasionally vim a list of files, and :bn through them, but I usually quit out of that quite quickly, otherwise I'll get confused.
06:10:30 <rtharper_> parcs: I know I know, it's like putting blood in shark-infested waters =p
06:10:54 <rostayob> jpcooper: can't you do typeOf foo == typeOf (undefined :: Type)?
06:11:18 <parcs> jpcooper: `:type undefined :: a ~ b => ()` ?
06:11:24 <merijn> osfameron: Did you set it up so it automatically yanks/pastes to/from the OS clipboard? That drastically improved my life
06:11:56 <osfameron> merijn: interesting.  But I'm using MacVim which at least handles copy/paste more sanely than linux did, so mostly not an issue
06:12:47 <mreh_> quicksilver: theoretically speaking wouldn't you see the program not respond in a timely fashion if it didn't sample quickly enough?
06:12:55 <jpcooper> rostayob: I have defined the type synonym type GenericT = forall a . (Data a) => a -> a. I would like to test whether a given function conforms to that type
06:13:06 <jpcooper> I thought ghci may provide such a thing
06:13:24 <merijn> osfameron: If you add "set clipboard+=unnamed" to your .vimrc then yank/paste will automatically go to the OSX clipboard too. Which means you can use yank to copy stuff and then simply hit Cmd-v to paste it on a pastesite. Or copy something from the web with Cmd-c and the simply paste with p (which means you no longer need to ":set paste"!)
06:13:25 <mreh_> quicksilver: I've probably got a lack of strictness problem somewhere
06:13:29 <mreh_> no matter
06:13:58 <osfameron> merijn: oo, interesting
06:14:15 <merijn> The only problem I have now is that I sometimes try to yank on remote hosts when connecting over SSH and then getting confused when it pastes the wrong thing :p
06:14:40 * hackagebot reactive-banana-wx 0.4.2.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.4.2.0 (HeinrichApfelmus)
06:15:15 <osfameron> merijn: and it only works in the gui vim :-(
06:15:31 <merijn> It also works on the terminal, but slightly more effort required
06:15:48 <merijn> Are you using screen/tmux or some other terminal multiplexer?
06:16:01 <osfameron> on osx?nope
06:16:12 <obiwahn> how do i express map by fold? mymap (\x _-> (fun x): ) []
06:16:14 <merijn> oh, how are you starting vim in your terminal?
06:16:36 <osfameron> merijn: 'vim' (which points at the mvim binary, but in console mode)
06:17:05 <osfameron> that said, most of my vim sessions at the mo are in my linux vm... but that's another story
06:17:25 <merijn> Odd, my vim command is also just a symlink to mvim and I have it working...
06:18:25 <rtharper_> obiwahn: why are you discarding the second argument?
06:18:31 <osfameron> oh wait, 'vim' is pointing at /usr/local/bin/vim... perhaps I broke my setup
06:18:51 <osfameron> ah no, that does symlink to mvim
06:19:08 <tswett> > (-5^2)
06:19:09 <lambdabot>   -25
06:19:50 <quicksilver> mreh_: yes, it is possible for the IO "pump" to take up too much type and start failing to respond in a timely way to external events
06:20:03 <quicksilver> mreh_: "too much time" (weird haskell based typo?)
06:20:24 <quicksilver> mreh_: a good way to monitor whether this is happening / how much it's happening is high on the list of things you need to make this stuff robust.
06:21:07 <parcs> jpcooper: `:t someFunction :: GenericT` if it doesn't complain then someFunction is a GenericT
06:21:24 <jpcooper> thanks parcs
06:22:00 <weltensegler> Hello everyone. I want to get one element from a set that satifsfies a certain condition. Is there a faster/better way then <code>Set.findMin $ Set.filter predicate mySet</code> ?
06:22:35 <quicksilver> mreh_: in general, when you have a system which has simple declarative style and all the "work" is done implicitly, it becomes less transparent :(
06:22:40 <rostayob> jpcooper: oh, I thought you needed to test for type equality in a program. in that case, you can do what parcs said :)
06:22:48 <buntfalke> How to pronounce "<-" in "c <- getChar"? And what about >>, >>= and so forth?
06:22:59 <rostayob> and let the type inference engine do the work
06:23:10 <antihoax> greetings
06:23:12 <merijn> buntfalke: ">>=" is called bind, not sure about the others
06:23:30 <buntfalke> So <- pply too, as that's what it does.
06:23:59 <buntfalke> And I could call >> "connect" or so, just to have a word for it.
06:24:03 <buntfalke> thanks merijn
06:25:09 <antihoax> i have considered starting out with ghc, though the examples are unclear and there are many 404-s
06:25:26 <buntfalke> merijn: "The operator (>>) called "then" is a mere" (http://en.wikibooks.org/wiki/Haskell/Understanding_monads)
06:25:27 <quicksilver> buntfalke: some people pronounce "<-" as "gets".
06:25:36 <buntfalke> quicksilver: thanks
06:25:38 <antihoax> i see syntax has changed
06:26:26 <obiwahn> rtharper_: because i give fold a fun a-> b -> b and i do not use the 2nd arg really
06:26:28 <merijn> antihoax: What do you mean by "starting out with ghc"? Learning haskell?
06:26:36 <obiwahn> maybe i should but i am too blind:(
06:26:46 <rtharper_> :t foldr
06:26:47 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:26:52 <rtharper_> so what is the second argument?
06:26:58 <obiwahn> a list
06:27:02 <rtharper_> obiwahn: it's important to consider what is happening
06:27:03 <rtharper_> yes
06:27:06 <rtharper_> what list?
06:27:10 <antihoax> wanted to start learning haskell
06:27:26 <obiwahn> the one that i build to return in the end
06:27:39 <merijn> antihoax: And you haven't done any functional programming stuff before?
06:27:58 <quicksilver> obiwahn: the second argument is what to return if you pass the empty list.
06:28:10 <quicksilver> obiwahn: (that's not *all* its used for, but it's a good intuition on what it should be)
06:28:14 <antihoax> merijn<< i have just evaluated my first few lines of functional math :)
06:28:28 <merijn> antihoax: I recommend downloading the Haskell Platform for your OS (http://hackage.haskell.org/platform/) and reading "Learn You a Haskell", which is available online at http://www.learnyouahaskell.com/
06:28:32 <parcs> weltensegler: you can use a fold: Set.fold (\x r -> r <|> guard (p x) >> return x) Nothing mySet
06:28:42 <buntfalke> merijn: Why, you think Haskell wouldnt be a good first functional language? I started out with SML, but I don't quite see the difference as far as the learning matters, it's just that SML is rather useless :-D
06:29:02 <antihoax> Linux matrix.arpa 3.0.3-rt12 #14 SMP PREEMPT RT Sat Sep 24 03:40:24 CEST 2011 x86_64 GNU/Linux
06:29:10 <buntfalke> merijn: Ah, I see. Never mind that :-D
06:29:11 <merijn> buntfalke: Now, I just mean that if you know any ML you can probably start with something more advanced then Learn You a Haskell
06:29:15 <merijn> s/Now/No
06:29:21 <antihoax> already installed and tried ghci ... with examples....
06:29:32 <buntfalke> merijn: Agreed.
06:29:42 <buntfalke> antihoax: not ghci, the haskell platform.
06:30:02 <buntfalke> antihoax: that's the compiler/interpreter, plus utility libraries.
06:30:10 <parcs> weltensegler: err, put parens around guard ... x if you want to do that
06:30:13 <mreh_> quicksilver: naturally, okay, thanks again
06:30:17 <merijn> antihoax: Haskell Platform is essentially GHC + loads of 3rd party libraries. But if you have just GHC that is fine when you're just playing around
06:30:20 <buntfalke> You'll need those anyway. Ever tried coding C without libc? ;-)
06:30:26 <antihoax> well its about 1GB installed
06:31:00 <merijn> antihoax: Like I said, I think Learn You a Haskell is a good place to start reading and getting a basic understanding of Haskell. The GHC wiki pages...probably not so much :>
06:31:25 <osfameron> Haskell Platform is far more than that.  It's a single entrypoint for an easy-to-install, well-maintained package, on multiple operating systems
06:31:52 <antihoax> merijn<< ok ty, will see
06:32:11 <merijn> There's also Real World Haskell, but I feel that is more useful as a follow-up book since it tends to gloss over some of the basics
06:32:17 <parcs> :t Data.Set.fold (\x r -> r <|> (guard (?p x) >> return x)) Nothing ?mySet
06:32:19 <lambdabot> forall a. (?mySet::S.Set a, ?p::a -> Bool) => Maybe a
06:32:33 <dankna> @hoogle Monad
06:32:33 <lambdabot> module Control.Monad
06:32:33 <lambdabot> module Data.Graph.Inductive.Monad
06:32:33 <lambdabot> module Data.Graph.Inductive.Query.Monad
06:33:01 <obiwahn> can you
06:33:21 <weltensegler> parcs, thank you. I am still a bit uneasy with this monadic things. I really should look into it a bit more! Thanks again.
06:36:24 <sral> hi, is there anyway to check type equality except using Data.Typeable?
06:36:35 <obiwahn> arr its super ugly:)  mapbyfold fun = myfoldr (\x y -> [(fun x)] ++ y)
06:36:45 <obiwahn> is there a nicer way?
06:38:22 <sipa> @pl \x y -> [(fun x)] ++ y
06:38:22 <quicksilver> obiwahn: well, fun x : y is a nicer way of writing [fun x] ++ y
06:38:22 <lambdabot> (++) . return . fun
06:38:23 <obiwahn> i have tried n times (fun x) : y
06:38:39 <parcs> weltensegler: no problem. here's a more direct version: Set.fold (\x r -> case r of Nothing | predicate x -> Just x; _ -> r) Nothing mySet . can you follow that?
06:39:45 <antihoax> do you think its a cool thing to do vectorgraphics/cad/cnc with haskell ?
06:39:51 <erus`> who hosts the cabal servers?
06:41:31 <weltensegler> parcs, yes, i can. But won't it go through the entire set anyway? Or is GHC smart enough, too optimize that away?
06:42:50 <parcs> i believe it will still have to go through the entire set
06:42:54 <dankna> hmm
06:42:54 <dankna> so
06:43:11 <dankna> I'm trying to implement a datatype FillableArray which adds a fill pointer to any MArray
06:43:18 <dankna> and I'm trying to write an MArray instance for this type
06:43:30 <quicksilver> weltensegler: I believe the findMin + filter approach will be fine.
06:43:34 <dankna> (a fill pointer is just an index value that says "this many elements are actually used")
06:43:54 <dankna> I've got a "slight" problem, which is that MArray expects the array to have nonzero size
06:43:57 <parcs> quicksilver: what if filter returns an empty set?
06:44:03 <dankna> but for my FillableArray I really do want to allow zero sizes
06:44:18 <dankna> thoughts, anyway?  should I define my own MArray-like interface instead?
06:44:24 <dankna> s/anyway/anyone/
06:44:50 <weltensegler> parcs and quicksilver, i think i will stick with the findMin approach. Sorry for my really bad typo up there. Thanks for being there.
06:44:50 <quicksilver> parcs: minView then ;)
06:45:12 <parcs> ah :P
06:46:33 <obiwahn> ist it possilbe to define foldbymap with one call of map and no further recursion?
06:47:16 <antihoax> added ssl
06:48:09 <weltensegler> quicksilver, Thanks for pointing me at minView.
06:50:24 <byorgey> obiwahn: what is foldbymap?
06:50:55 <obiwahn> i am trying to express fold with map
06:51:19 <byorgey> that cannot be done.
06:51:30 <antihoax> hi everyone
06:51:36 <antihoax> do you think its a cool thing to do vectorgraphics/cad/cnc with haskell ?
06:51:58 <saml> antihoax, yes
06:52:05 <antihoax> was hoping it would be easier and more stable than in C
06:52:05 <byorgey> @faq is it a cool thing to do vectorgraphics/cad/cnc with haskell ?
06:52:06 <lambdabot> The answer is: Yes! Haskell can do that.
06:52:26 <saml> antihoax, yes since haskell is functionally pure, you can be stable
06:52:27 <dankna> it is a cool thing!
06:53:10 <antihoax> ahaha the bot knows all?
06:54:09 <mauke> @faq does the bot know all?
06:54:10 <lambdabot> The answer is: Yes! Haskell can do that.
06:55:03 <buntfalke> Is error a primitive function? How else can it have an arbitrary return type?!
06:55:18 <mauke> buntfalke: error x = error x
06:55:18 <mm_freak_> antihoax: you may want to experiment with 'gloss', which is a purely functional animation library
06:55:22 <mauke> in theory, that is
06:55:26 <mauke> in practice it is primitive
06:55:34 <buntfalke> mauke: Ah, okay. Thanks :-)
06:56:24 <byorgey> buntfalke: any function can have an arbitrary return type if it never returns =)
06:56:54 <buntfalke> I feel like a middle school student again, functional programming is so different...
06:57:10 <buntfalke> byorgey: Yes, I just noticed that "never returning" is quite key here :-)
06:57:16 <byorgey> buntfalke: yep, that's a common feeling
06:57:23 <byorgey> buntfalke: it means your brain is expanding =)
06:57:35 <mauke> template<typename T> T foo() { throw "lol no"; }
06:58:34 <monochrom> brain expanding is not a good sign... will explode
06:58:51 <antihoax> mm_freak_<< ty im writing notes ;>
06:58:51 <buntfalke> byorgey: Then I hope not to the top, it's quite the rectangle already ;-)
06:59:22 <merijn> @quote head.explodes
06:59:23 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
07:00:12 <obiwahn> @src fix
07:00:12 <lambdabot> fix f = let x = f x in x
07:00:31 <buntfalke> Is there any actual computation left in the resulting binary if I switch all optimizations on and create a programm that does neither reading IO, nor uses random numbers?
07:00:40 <quicksilver> yes, lots of it.
07:00:44 <quicksilver> GHC is not a magic compiler
07:00:50 <quicksilver> it does very little partial evaluation
07:01:18 <buntfalke> Why not? Isn't it easy to see you never call one of the reading primitive IO functions?
07:01:31 <buntfalke> And thus it will always be the same result anyway?
07:01:31 <quicksilver> partial evaluation is not simple.
07:01:44 <quicksilver> your program may not terminate.
07:01:53 <buntfalke> Oh. Quite true.
07:02:16 <plato0> It could try, couldn't it?  Just run the program for a bit and see if it terminates ...
07:02:25 <quicksilver> some people think that more partial evaluation is a good way to write compilers
07:02:30 <quicksilver> see also, supercompilation.
07:02:38 <quicksilver> I do not know who is right. But I do know it isn't easy.
07:02:46 <buntfalke> Damn that halting problem...
07:03:24 <buntfalke> plato0: So after how many minutes would you say it should stop trying?
07:04:07 <buntfalke> plato0: what if it's hundrets of megabytes of code, and you still progress through the files as you evaluate it, but you have no clue how long this will go on?
07:04:50 <plato0> buntfalke: Well either that will happen at compile time or run time.  Best to get this all out of the way at compile time IMO.
07:04:51 <merijn> The solution, switch to a non-Turing complete language which guarantees strong termination and then just add a coprogramming monad (or other construct)
07:06:05 <buntfalke> plato0: So how long do you wanna wait for the compilation, until you say "does not terminate"?
07:06:22 <merijn> buntfalke: Same problem at runtime
07:06:25 <buntfalke> plato0: what if it is proper code, but should not terminate? As in: produce a line by line list of all primes
07:06:27 <merijn> buntfalke: So not an issue
07:06:28 <buntfalke> merijn: no.
07:06:33 <tdammers> well, duh, until it doesn't terminate...
07:07:06 <merijn> If your code doesn't terminate, what does it matter if you find out at compile time or at runtime?
07:07:11 <buntfalke> tdammers: Pray, how many seconds of waiting does "it doesnt terminate" mean? 5? 15? how do you tell?
07:07:22 <tdammers> that's the point
07:07:26 <buntfalke> merijn: You cannot find out. See the halting problem.
07:07:28 <dankna> merijn: what if your code does something useful without terminating?
07:07:35 <tdammers> either you can find a way to prove that it cannot terminate...
07:07:43 <tdammers> ...or it terminates...
07:07:47 <buntfalke> merijn: And it might be a proper programm, and still doesnt terminate. example: produce all primes, print out line by line.
07:07:48 <tdammers> ...or you wait forever
07:08:19 <buntfalke> tdammers: Not true. You cannot write a programm which finds this proof for any arbitrary other program. this is the halting problem.
07:08:25 <buntfalke> Google it...
07:08:27 <plato0> 18:10 < tdammers> ...or you wait forever
07:08:30 <tdammers> exactly
07:08:52 <buntfalke> ...
07:08:55 <merijn> buntfalke: You're not getting what I'm saying...I don't need an explanation of the halting problem...
07:08:58 <tdammers> there are programs that never terminate, but can be shown to not terminate
07:09:07 <tdammers> and then there are those that are subject to the halting problem
07:09:42 <merijn> buntfalke: You specified calculating stuff which didn't do IO/Random at compile time. Outputting primes does IO so is exempt from the discussion
07:09:57 <buntfalke> merijn: I said /reading/ IO
07:10:30 <plato0> buntfalke: I agree that it's a tricky to define exactly what you want precompilation to do, but in some circumstances it would be worth speculatively running the program at compile time.
07:10:39 <tdammers> if IO is not allowed at all, then the program must not terminate
07:10:41 <zygoloid> you would still have a problem with subexpressions which are never evaluated by your program, and which do not terminate
07:10:50 <buntfalke> Besides, a programm which doesn't do /any/ IO is just an expensive way to heat your apartment.
07:10:55 <tdammers> otherwise, the mere fact that it does terminate constitutes a form of output
07:11:06 <merijn> zygoloid: Why? If execution is lazy, then why not speculative execution at compile time
07:11:33 <zygoloid> merijn: because you can transform an always-terminating program into a non-terminating compilation that way
07:12:04 <merijn> zygoloid: Why?
07:13:56 <merijn> If the expression is evaluated at runtime, runtime doesn't terminate either. And if it is not evaluated at runtime then why would speculative execution during compilation evaluate it?
07:14:03 <zygoloid> merijn: "do x <- getLine; if f x then nonTerminatingThing else terminatingThing". now suppose f x is always False, but not provably so. speculative evaluation of nonTerminatingThing would be bad...
07:15:22 <asdf_> hello
07:15:55 <plato0> zygoloid: Only if you refuse to accept any intermediate state as part of your compiled form.
07:16:06 <Lickmybum> hello fellow haskelllers
07:16:16 <rostayob> Lickmybum: hello funny nickname
07:16:33 <plato0> zygoloid: Why not just terminate the speculative compilation after N transformations and choose the representation that has the best time/space tradeoff so far?
07:16:41 <Lickmybum> i agree
07:16:50 <rostayob> :)
07:17:04 <Lickmybum> obvs darlin
07:18:23 <Lickmybum> does anyone wanna write me a program that determines whether a given number is prime?
07:18:29 <zygoloid> plato0: sure, that would be fine. but i thought we were talking about letting compilation not terminate if a program contains a non-terminating subexpression
07:19:20 <plato0> zygoloid: I think as is often the case in bandwidth-limited discussions, we weren't really sure what we were talking about.
07:20:22 <zygoloid> :)
07:21:02 <tdammers> isprime n = any (\x -> n `mod` x == 0) [2..(n-1)]
07:21:38 <rostayob> better if you go up to sqrt n
07:21:41 <opqdonut> @pl (\x -> n `mod` x == 0)
07:21:41 <lambdabot> (0 ==) . (n `mod`)
07:21:58 <opqdonut> @pl (\x -> mod n x == 0) -- rather
07:21:59 <lambdabot> (0 ==) . mod n
07:22:07 <opqdonut> rostayob: best to use AKS
07:22:45 <rostayob> opqdonut: yeah but going up to sqrt is still simple and clear :)
07:23:20 <rostayob> you could also sieve, maybe scanl?
07:23:33 <opqdonut> a more important performance optimization is to use a static list of the 10 first primes or so
07:23:44 <tdammers> see, the nice thing is, he left 5 seconds too early :D
07:24:01 <rostayob> oh lickmybum quit :(
07:24:10 <tdammers> that's the beauty of it
07:25:20 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
07:25:22 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:26:18 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in isPrime 252097800623
07:26:22 <lambdabot>   mueval-core: Time limit exceeded
07:26:47 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in isPrime 22801763489
07:26:50 <lambdabot>   True
07:27:57 <mysticc> When I do sudo ghci .. it is able to search for a package but not when I do ghci .. Whats the problem ??
07:28:37 <tromp> > let z c(_:t)='.':c t;o c(h:t)=h:c t;p n=let s=o.n in fix s('P':p s)in".."++p z
07:28:39 <lambdabot>   "..P.P.P...P.P...P.P...P.....P.P.....P...P.P...P.....P.....P.P.....P...P.P....
07:29:22 <rostayob> mysticc: check permission of the folder with the module? chmod +rx'd it?
07:29:41 <buntfalke> How to pronounce "\x -> x*x"?
07:30:27 <rostayob> buntfalke: lambda x, x times x?
07:30:41 <Cale> I agree, "lambda x, x times x"
07:30:49 <buntfalke> rostayob, Cale: Thanks.
07:31:51 <mysticc> rostayob: Also ghc-pkg list --global ,, shows the package but not ghc-pkg list   ???
07:33:55 <rostayob> mysticc: so you don't have access to the system wide packages?
07:34:19 <dmwit> mysticc: Give up. Reformat your hard drive and start over. ;-)
07:34:24 <rostayob> yeah really ahah
07:34:47 <mysticc> dmwit: Cant never think about it :p
07:34:54 <dankna> @hoogle lg
07:34:55 <lambdabot> Data.Data AlgConstr :: ConIndex -> ConstrRep
07:34:55 <lambdabot> Network.Browser AlgMD5 :: Algorithm
07:34:55 <lambdabot> Network.Browser AlgMD5sess :: Algorithm
07:34:57 <dankna> @hoogle log
07:34:57 <lambdabot> Prelude log :: Floating a => a -> a
07:34:57 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
07:34:58 <lambdabot> Network.CGI logCGI :: MonadIO m => String -> m ()
07:34:59 <dmwit> mysticc: More seriously, though, that is really weird, and I would honestly consider just reinstalling GHC from zero if I ran into that situation. =P
07:35:06 <dankna> > logBase 2.0 8.0
07:35:06 <lambdabot>   3.0
07:35:22 <Cale> > logBase 2 8
07:35:23 <lambdabot>   3.0
07:35:31 <rostayob> mysticc: what are the permissions to the folder with the global libraries? do you have access to it as a normal user?
07:35:31 <cheater> @hackage fix
07:35:31 <lambdabot> http://hackage.haskell.org/package/fix
07:35:41 <dmwit> ?index fix
07:35:42 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
07:35:46 <cheater> ah ok
07:35:46 <cheater> thanks
07:35:49 <cheater> :))
07:35:52 <dmwit> =)
07:35:53 <cheater> i was just gonna ask!
07:36:07 <dmwit> ?hackage is a really, really dumb command
07:36:07 <lambdabot> http://hackage.haskell.org/package/is a really, really dumb command
07:36:16 <dmwit> =)
07:36:23 <mysticc> rostayob: Yeah I have read access to them
07:36:59 <cheater> interesting, so what does this code do?
07:37:00 <cheater> let z c(_:t)='.':c t;o c(h:t)=h:c t;p n=let s=o.n in fix s('P':p s)in".."++p z
07:37:15 <rostayob> mysticc: i have no idea
07:37:43 <rostayob> what platform are you on? if you're on linux did you install ghc from from your distros packages?
07:37:52 <mysticc> rostayob: arch
07:38:12 <mysticc> It was all working good since few days back ..
07:38:19 <rostayob> mysticc: so you installed from pacman? i think the people from
07:38:24 <rostayob> #archlinux might help you
07:38:32 <mysticc> Yup ...
07:38:40 <cheater> tromp: what is that code?
07:38:41 <cheater> :)
07:38:45 <rostayob> maybe you mixed arch's haskell packages with cabal packages badly or something like that
07:38:48 <dmwit> I doubt the #archlinux folks will have a better clue than the #haskell folks.
07:38:53 <tromp> a prime number sieve
07:38:54 <franzejr> hello everyone
07:39:03 <rostayob> dmwit: well since the #haskell folks have no clue
07:39:06 <rostayob> it can't be worse
07:39:08 <cheater> tromp: ah
07:39:13 <dmwit> heh
07:39:18 <cheater> tromp: i thought it looked whitenoisey
07:39:21 <dmwit> <- also an Arch Linux user
07:39:31 <cheater> and indeed that would characterise a prime sieve
07:39:31 <dmwit> I've been circumventing pacman since GHC 6.8. =P
07:39:38 <cheater> tromp: how does it work?
07:39:39 <rostayob> mysticc: anyway, this is quite controversial but i usually avoid using distros ghc/haskell packages, and go with the binaries and cabal packages
07:39:46 <dmwit> yes
07:39:52 <rostayob> it's all too messy and you end up using cabal all the time anyway
07:40:01 <rostayob> and mixing them is a mess
07:40:26 <dmwit> mysticc: By the way, did you get my message in #xmonad? Have you checked what "ghc-pkg check" says?
07:40:44 <tromp> a more readable version is
07:40:46 <tromp> primes0 yes no = no:no:p z where
07:40:48 <tromp>   z c (_:t) = no:c t
07:40:49 <tromp>   o c (h:t) =  h:c t
07:40:51 <tromp>   p n = let s = o.n in fix s (yes:p s)
07:41:23 <mysticc> dmwit: The problem is corrected .. I just did sudo ghc xmonad.hs
07:41:32 <rostayob> aha, some creative use of fix
07:41:40 <tromp> o^n(z) sets every (n+1)st bit to 0
07:41:41 <dmwit> mysticc: I wouldn't exactly call that "corrected"...
07:42:18 <mysticc> dmwit: Yeah just a workaround ... now atleast I got my taskbar back .. till the time I find a more stable fix
07:43:03 <mysticc> dmwit: what does ghc-pkg list --global shows ?? because it is showing my packages but not ghc-pkg list ??
07:43:39 <mysticc> since I am not using any sudo here so I think it is not the problem of permission rather the problem of some path variables not set
07:44:44 <dmwit> It's a bit odd, I agree. "ghc-pkg list" is supposed to show both the "--global" and the "--local" results.
07:44:57 <mysticc> dmwit: Sorry It shows ...
07:45:06 <dmwit> hpaste.org
07:45:11 <dmwit> Don't paste in-channel, please.
07:46:03 <mysticc> dmwit: Ok .. my bad .. It first shows the global database then the user database .. but why then ghc is not able to load it but sudo ghc is ??
07:47:31 <mysticc> dmwit: I think I am not able to use any global package without sudo
07:48:53 <dmwit> What does ghc-pkg check say?
07:50:16 <Saizan> or maybe you've installed some packages in root's user db.
07:50:25 <dmwit> wow
07:50:28 <dmwit> awesome
07:50:43 <Saizan> check sudo ghc-pkg list --user
07:51:08 <Saizan> and don't use sudo with cabal in the future :)
07:51:11 <mysticc> Saizan: Nothing
07:51:23 <mysticc> dmwit: http://paste.pocoo.org/show/482775/
07:51:51 <dmwit> mysticc: I think I may have found your problem, possibly.
07:51:58 <dmwit> mysticc: You have about eighteen broken packages.
07:52:19 <mysticc> dmwit: Yeah .. but how to fix them
07:52:42 <dmwit> cabal install --reinstall them
07:53:09 <antihoax> isnt there some permission setting?
07:56:40 <mysticc> dmwit: Isnt there any path settings from where ghci loads the modules ??
07:57:02 <dmwit> Yes.
07:57:48 <dmwit>                             Linus Akesson presents:
07:57:48 <dmwit>                    The Game Of Life implemented in Brainfuck
07:57:51 <dmwit> hm
07:58:00 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#package-databases
07:58:07 <dmwit> (Sorry for the first mispaste.)
07:58:43 <rwbarton> it sounds more interesting
07:58:53 <dmwit> =)
08:16:13 <njckname> This is homework related, so don't bother reading if you don't care to help. I had to write a few functions and then test them with QuickCheck. I wrote the functions but trouble is with QuickCheck, I am using a custom type called a Set and I do not know how to get QuickCheck to generate values for that type. We were given a "generator" but no one knows how it's supposed to be used and it doesn't compile either. I find the QuickCheck documentatio
08:16:13 <njckname> n hard to comprehend so I thought of asking here.
08:16:32 <njckname> Here is the type and generator http://pastie.org/2594879
08:17:07 <dmwit> Do you know how to use QuickCheck for other types?
08:17:13 <njckname> Yes
08:17:24 <dmwit> Okay.
08:17:42 <dmwit> To make it compile, you probably just have to indent the last two lines a bit more (so they're at a deeper level than "arbitrary").
08:17:55 <dmwit> Then you use QuickCheck on your Set type just like you would on other types.
08:18:11 <dmwit> Write a property that should be satisfied.
08:18:57 <njckname> It still doesn't compile, I get 'Undefined variable "orderedList""'
08:19:14 <dmwit> import QuickCheck
08:19:26 <dmwit> sorry
08:19:43 <dmwit> not QuickCheck; but the haddocks suggest that Test.QuickCheck.Modifiers should do.
08:20:16 <dmwit> or Test.QuickCheck.Arbitrary
08:21:34 <njckname> "Can't find imported module" - I'm afraid. I'm using WinHugs, I'll try to get those modules to load and then I'll be back
08:22:05 <dmwit> Sounds like you may not have QuickCheck installed.
08:22:23 <rwbarton> or you might have QuickCheck 1 when you need QuickCheck 2 or vice versa
08:22:41 <njckname> I do have QuickCheck installed, since I used it before
08:23:07 <dmwit> If your course doesn't require hugs, I strongly recommend grabbing the Haskell Platform. It comes with GHC (which is superior to Hugs in a lot of ways, and inferior in very few) and QuickCheck.
08:23:38 <rwbarton> in fact it looks like orderedList is new in QuickCheck 2
08:27:50 <njckname> I am going to install the Haskell Platform then
08:27:51 <dmwit> njckname: Still making progress?
08:27:55 <dmwit> ah, great
08:28:02 <rwbarton> is "let (I# x) = y :: Int in ..." strict in y, if I don't use x?
08:28:45 <dmwit> I'm pretty sure let-bindings are lazy.
08:28:48 <rwbarton> I'm trying to understand why "let !(I# nlimbsi) = fromIntegral nlimbs" produces the error "Illegal bang-pattern (use -XBangPatterns)" in ghc 7.2 but apparently not ghc 7.0
08:28:57 <rwbarton> maybe just a bug in previous versions
08:29:17 <dmwit> Yes, recent GHC's have been much more strict about requiring certain extensions to be turned on to get certain features.
08:29:25 <Igloo> rwbarton: It is strict in x, and hence in y
08:29:40 <dmwit> > let (x, y) = undefined in 3 -- really?
08:29:40 <Igloo> You can test it with "let (I# x) = undefined in ()"
08:29:41 <lambdabot>   3
08:30:05 <Igloo> dmwit: x and y are lifted types there. x is unlifted.
08:30:08 <rwbarton> or I could, if I remembered where I# was :)
08:30:17 <Igloo> rwbarton's x is unlifted, I mean
08:30:24 <dmwit> aah
08:30:33 <dmwit> ?index I#
08:30:33 <lambdabot> GHC.Exts
08:30:41 <rwbarton> aha, GHC.Types
08:30:56 <rwbarton> well, when I write that I get "Warning: Pattern bindings containing unlifted types should use an outermost bang pattern:"
08:31:09 <rwbarton> but I can't use the bang pattern without -XBangPatterns
08:31:21 <dmwit> I get that warning *twice*. =P
08:31:24 <rwbarton> which all sort of makes sense, but is a little odd
08:31:29 <dmwit> It really, really wants to warn me.
08:31:32 <quicksilver> dmwit: you were warned once but you didn't listen ;)
08:32:34 <rwbarton> Heh, when I try this in ghc 6.12 it tells me leaving out the bang pattern will be an error in ghc 6.14.
08:32:42 <rwbarton> Could still happen I guess!
08:33:31 <quicksilver> rwbarton: well unlifted types are an extension in themselves, it's not completely absurd for them to depend on other extensions.
08:34:03 <quicksilver> rwbarton: maybe what's bizarre is that unlifted types aren't *specifically* a named extension but implicitly involve others.
08:34:16 <rwbarton> Right, so anyways I guess the fix for this library (HsOpenSSL) is just to enable BangPatterns in the cabal file
08:38:54 <rwbarton> ... or I could just use the latest version, which already has this fix.
08:40:47 <dmwit> rwbarton: Oh, I've done that like eight times on my laptop (where I decided I would be on the cutting edge and use GHC 7.3).
08:41:14 <dmwit> Spend 30 minutes fixing something to work in 7.3... clone repository to compose a patch... *facepalm*
08:41:23 <rwbarton> I'm on a slightly less cutting edge, but it's still a bit sharp
08:41:50 <dmwit> And there's nobody to blame but yourself. That's the worst part.
08:42:29 <nwf> Hullo channel: silly question.  Is unsafeInterleaveIO equivalent to (return :: a -> IO a) . unsafePerformIO?
08:43:47 <eyebloom> Can anyone chat about reading a GHCi history?
08:43:58 <eyebloom> debug history that is.
08:44:06 <Saizan> nwf: yep
08:46:42 <njckname> Installed the Haskell Platform and QuickCheck 2 and now the generator compiles
08:47:05 <njckname> I wrote a function to use with QuickCheck, called prop_test http://pastie.org/2595029
08:47:40 <njckname> But I get this compilation error: http://pastie.org/2595034
08:48:46 <dmwit> njckname: Just delete the "where types = ..." line.
08:49:03 <dmwit> Also, your indentation is really weird.
08:49:25 <dmwit> Also also, why are you giving two names for this property?
08:49:36 <dmwit> (namely "dummy" and "prop_test")
08:49:42 * hackagebot blaze-html 0.4.1.7 -   http://hackage.haskell.org/package/blaze-html-0.4.1.7 (JasperVanDerJeugt)
08:50:23 <njckname> I thought I needed to say what type of data I want QuckCheck to generate, so I thought I needed to say "where types =." that's why I used the second fun prop_test
08:50:27 <njckname> Anyway, it is working now
08:50:32 <njckname> Thank you very much
08:51:33 <njckname> Oh yeah, one more thing actually
08:52:10 <njckname> I need to try something first, then I'll ask
08:52:44 <tsousa> i already read the first two chapters of LYAH which exercices can i do?
08:55:42 <njckname> OK, it all works it seems. Can I get QuickCheck to show me the tests it runs?
09:02:10 <njckname> I tried verboseCheckWith and it shows just this, http://pastie.org/2595104, That can't be right, innit? This means it's only testing empty Sets?
09:03:29 <bfig> >:t lift
09:03:32 <bfig> :t lift
09:03:33 <lambdabot>     Ambiguous occurrence `lift'
09:03:34 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
09:03:34 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
09:03:46 <bfig> :t ControlMonad.Error.lift
09:03:47 <lambdabot> Couldn't find qualified module.
09:03:51 <saml> > lift your hands up
09:03:52 <lambdabot>   Ambiguous occurrence `lift'
09:03:52 <lambdabot>  It could refer to either `Control.Monad.Trans....
09:03:56 <bfig> :t Control.Monad.Error.lift
09:03:58 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
09:04:59 <bfig> :t Control.Monad.Logic.lift
09:05:00 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Logic.MonadTrans t, Monad m) => m a -> t m a
09:05:07 <saml> why not symbol or atom in haskell?
09:05:38 <bfig> how should i interpret lift in this context?
09:05:45 <bfig> (in general, in monad transformers)
09:05:48 <mreh_> can I locate a cost center more easily than guesswork with SCC?
09:06:50 <mreh_> I'm looking at a .prof trace trying to find an fmap
09:07:54 <mreh_> in the source
09:07:59 <dmwit> ?tell njckname No, it's not telling you it only tested empty Set's. It's telling you it only tested Set's that had a single element, namely (). You can test at other Set types (say Set Int instead of Set ()) to get more interesting tests.
09:07:59 <lambdabot> Consider it noted.
09:08:14 <saml> bfig, lift is lifting stuff
09:08:29 <saml> lift a value up in the monad layer
09:08:41 <Younder> duh
09:08:50 <bfig> so for a transformer i should just wrap it in the constructor?
09:09:05 <bfig> ie, lift = Const  ?
09:10:07 <mreh_> it's the same as fmap
09:10:10 <saml> yes
09:10:41 <Younder> yes, it doesnt change anything, the good bit is in the return
09:11:17 <saml> import qualified Control.Monad.Trans as T;    instance T.MonadTrans YourNewType where  lift m = YourNewType (T.lift m)
09:12:05 <Younder> saml, still it is kinda hackish
09:13:19 <saml> Younder, how would you do ? instead of using monad transformers
09:13:54 <saml> you have two monads. and you want to compose them. what do i do?
09:14:09 * JuanDaugherty thinks if hackish was anathema to haskell, there wouldn't be brainfuck support
09:14:17 <saml> so that in the composed monad, i can use two kinds of monads
09:14:26 <Younder> saml: I refer you to 'purely functional data structures'
09:15:24 <saml> monad isn't data structure
09:15:46 <Younder> JuanDaugherty, lol
09:15:50 <armlesshobo> it's a structure
09:15:58 <erus`> its a class
09:16:05 <rostayob> mauke: Monad is a type clas
09:16:07 <rostayob> s
09:16:11 <saml> it's datastructure plus semantics
09:16:30 <rostayob> it's just a type class, it's a function that you can bind
09:16:33 <rostayob> *functor
09:16:36 <Younder> which is a HUGE mistake in Haskell.
09:16:51 <saml> what does binding a functor mean?
09:17:23 <rostayob> saml: >>= is the bind operation, (>>=) :: m a -> (a -> m b) -> m b
09:17:31 <saml> so you have two type classes.. how can you create a new type class that are sum of the two?
09:17:34 <rostayob> you can also define a monad in terms of join :: m (m a) -> m a
09:18:11 <bfig> saml, that doesn't work
09:18:24 <rostayob> saml: a monad transformer is not a "sum" of two monads
09:18:34 <saml> what is monad transformer?
09:18:42 <rostayob> @info MonadTrans
09:18:43 <lambdabot> MonadTrans
09:18:47 <zygoloid> saml: class (A x, B x) => AB x where; instance (A x, B x) => AB x where; -- ?
09:18:49 <rostayob> :t lift
09:18:50 <lambdabot>     Ambiguous occurrence `lift'
09:18:50 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
09:18:50 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
09:18:58 <rostayob> :t Control.Monad.Trans.lift
09:18:59 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Control.Monad.Error.MonadTrans t, Monad m) => m a -> t m a
09:19:07 <Younder> Category theory can be viewed as a foundation of mathematics. Thus monads a category theoretic construct should be in it's gut's
09:19:22 <saml> in english
09:19:28 <saml> what is monad transformer in english?
09:19:42 <Younder> Not super-imposed as a type class
09:19:57 <bfig> it is a wrapper for adding behavior to a preexisting monad as far as i understand
09:20:08 <saml> so why is it not "sum" ?
09:20:15 <saml> that sounds like sum
09:20:16 <rostayob> saml:  a monad transformer is an instance of MonadTrans, and a MonadTrans is a class whose only function is lift. lift needs to respect some laws, specifically lift . return = return, lift (m >>= f) = lift m >>= (lift . f)
09:20:20 <rostayob> that's all
09:20:25 <saml> is there monad transformer that can do minus?
09:20:37 <saml> like, A + B = C
09:20:51 <bfig> you have a monad m a, and you want it to be a maybe monad... so you make a transformer MaybeT  which has something of type  m (Maybe a)
09:20:59 <saml> so given monad C, the function gives you Monad B
09:21:01 <roconnor> a monad transformer is a type constructor that takes a monad and turns it into another monad.
09:21:12 <Younder> rostayob, but it is up to you to enforce that law.. not good
09:21:38 <saml> so, you creaeta  monad, C,  using transformer.  now how do you take away monad A from C?
09:21:40 <rostayob> if you want to know what you can do with a monad transformer, it basically lets you have an inner monad, and you can "lift" operations to execute in the inner monad. it probably also has a function that "runs" the outer monad and leaves you with the inner one, but not necessarely
09:21:46 <saml> f C = B
09:21:50 <saml> g A B = C
09:21:56 <rostayob> saml: "sum" doesn't mean much in that context
09:22:11 <Cale> lol, I just realised that I have the UNIX book the girl version of Garth was carrying in Wayne's World 2.
09:22:14 <saml> you added B's functionality to A to create C
09:22:22 <Cale> http://www.flickr.com/photos/benfrantzdale/62337296/ <-- UNIX Network Programming by Stevens
09:22:24 <saml> now I want to take B's functionality from C to get A
09:22:40 <rostayob> no, a sum is a commutative operation, it's not representative of what a monadtrans is, at all
09:22:53 <roconnor> we wouldn't call it a sum because the sum of two functors is already defined as something else.
09:23:02 <saml> so, A + B  != B + A
09:23:05 <Younder> Cale, we all have it ;)
09:23:08 <saml> where + is applying monad transformer
09:23:17 <rostayob> saml: just drop the sum analogy :P
09:23:21 <rostayob> it's just confusing
09:23:26 <saml> then what is it?
09:23:28 <rostayob> you're not "fusing" the two monads together
09:23:30 <saml> "adding "
09:23:32 <rostayob> i told you what is it
09:23:48 <rostayob> if you want to understand what to do with it, there are a lot of examples
09:23:56 <rostayob> you might want to look at the typeclassopedia
09:23:56 <saml> no what is it?
09:24:02 <rostayob> @where typeclassopedia
09:24:03 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:24:06 <roconnor> saml: the formal definition of a monad transformers is given in the modular monad transformers paper
09:24:09 <Cale> A monad transformer doesn't even act on two monads. It transforms one monad and produces another
09:24:43 <saml> what's inverse of monad transformer?
09:24:48 <Younder> a typecast
09:24:53 <rostayob> saml: MonadTrans in haskell is a type class, I told you the signature of "lift" and its rules, that's all a MonadTrans is in haskell
09:24:56 <saml> what's a typecast?
09:24:56 <rostayob> Younder: what?
09:25:06 <Cale> Monad transformers tend not to have inverses in Haskell.
09:25:07 <roconnor> saml: why do you think monad transformers would have inverses?
09:25:16 <Cale> Though conceptually, they could.
09:25:23 <Cale> (some of them could)
09:25:26 <saml> you mean lift is not injective ?
09:25:28 <KirinDave> That monatron library
09:25:31 <Cale> Well, IdentityT does :)
09:25:46 <Cale> lift is almost never surjective
09:25:48 <KirinDave> It has transformers with interesting properties
09:26:05 <saml> i don't think i can ever program in haskell
09:26:11 <KirinDave> saml: Why?
09:26:20 <saml> i'm not smark like you
09:26:22 <saml> smark
09:26:27 <Cale> You don't need to use monad transformers to program in Haskell.
09:26:29 <rostayob> i'm not smark either
09:26:34 <KirinDave> smal: I am the least qualified person in this wroom.
09:26:38 <roconnor> I don't think that lift needs to be injective.
09:26:43 <saml> no, you are smark
09:26:45 <Cale> They're not all that important.
09:26:54 <KirinDave> saml: I can barely type. I can barely remember my trig identities, even. I'm terrible at everything.
09:27:01 <KirinDave> saml: And yet I find haskell weirdly comforting.
09:27:14 <Younder> rostayob, It is the equivalent of a type cast. A monad transformer is more formal but achives the same result. converting one type into another. Kinda like a plug in yout pac has one interface and the one you get has a second you need a converter
09:27:29 <Cale> Younder: That is a *very* rough analogy
09:27:30 <saml> that's good for you. probably you just read many good things on proggit
09:27:39 <roconnor> Const (Const ()) can probably be made into a fine monad transformer.
09:27:39 <rostayob> Younder: then every type constructor is equivalent to a type cast
09:27:44 <KirinDave> smal: It's true that Haskell will make you feel stupid at the outset tho. There is this whole "learning a new base methodology  for computation" to get around.
09:27:47 <roconnor> with a non-injective lift
09:27:47 <rostayob> every type with a parameter
09:27:52 <Younder> Cale, true, but a very useful one
09:27:54 <KirinDave> dangit, stop autocompleting that wa, Colloquy
09:27:58 <rostayob> Younder: I don't think so, but ok
09:28:14 <Cale> I'm not sure it is useful, I'm afraid...
09:28:24 <rostayob> Younder: i think is really really misleading
09:28:36 <rostayob> considering what I type cast is in most languages
09:28:47 <rostayob> :t cast
09:28:48 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
09:28:51 <rostayob> this is a type cast
09:29:25 <Eduard_Munteanu> @hoogle unsafeCoerce
09:29:25 <Cale> A monad is a type constructor T which comes along with a given interface consisting of an implementation of return :: a -> T a, and "bind" (>>=) :: T a -> (a -> T b) -> T b
09:29:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:29:26 <roconnor> saml: http://www.fceia.unr.edu.ar/~mauro/pubs/mmt/mmt.pdf -- page 4, Definition 9
09:29:33 <Eduard_Munteanu> No, this is a cast :P
09:29:44 <Cale> A monad transformer is a type constructor which takes a monad as a parameter, and produces another monad
09:29:53 <rostayob> Eduard_Munteanu: you're bad
09:29:54 <Younder> rostayob, type conversion, more..
09:30:07 <rostayob> Younder: so Maybe is a type cast?
09:30:11 <Cale> For example, if T is some monad, then StateT T is also a monad.
09:30:18 <saml> i find it hard to read greek stuff
09:30:27 <roconnor> Cale: and has a monad morphism from the old monad to the new monad
09:30:35 <Cale> yeah
09:30:42 <rostayob> saml: why? greek letters are impressive
09:30:48 <rostayob> a page full of greek letters looks good
09:30:50 <Eduard_Munteanu> saml: Greek symbols in math or similar?
09:30:56 <Cale> along with return :: a -> StateT T a, and (>>=) :: StateT T a -> (a -> StateT T b) -> StateT T b
09:30:59 <saml> i know.. i think i'm not trained/educated enough for me
09:31:01 <saml> for it
09:31:04 <Younder> rostayob, no maybe is a hack to allow unions
09:31:17 <rostayob> Younder: unions?
09:31:18 <saml> yah i don't have much math background
09:31:28 <Cale> saml: Monad transformers are purely a Haskell thing
09:31:31 <rostayob> saml: me neither
09:31:39 <Eduard_Munteanu> TBH, I struggle to read full words, even if I'm ok with reading symbols in math.
09:31:53 <Cale> saml: While monads come from mathematics, those people don't really discuss monad transformers much.
09:32:01 <Cale> (If at all)
09:32:05 <saml> The set MT of monad transformersˆconsists of tuples T = (T, retT , bindT , liftT ), where T : (∗ → ∗) → (∗ → ∗)
09:32:17 <rostayob> saml: i was actually never seriously formally educated in maths, apart in uni, but that's just in the past 2 years
09:32:20 <bfig> what is wrong with this? instance T.MonadTrans ResT where \n  lift m = ResT $ m >>= return
09:32:26 <rostayob> Younder: AST are unions
09:32:45 <Cale> Younder: whaaat
09:32:50 <rostayob> /AST/ADT
09:32:59 <Cale> Younder: Do you program in Haskell? :)
09:33:09 <saml> bfig, that seems wrong. you need to do  RestT (T.lift m)
09:33:17 <Cale> Maybe isn't a hack, and it doesn't do anything I'd consider "allowing unions"
09:33:25 <bfig> saml, why do T.lift ?
09:33:34 <bfig> why do i need to lift it makes no sense
09:33:35 <rostayob> no but if anything, any data type is a union of products in haskell
09:33:41 <saml> bfig, to lift up to RestT
09:33:43 <Cale> rostayob: well, that's truer :)
09:33:48 <Cale> A disjoint union of products
09:33:56 <Eduard_Munteanu> I guess Either is a hack for errno then :)
09:33:59 <Cale> + recursion + lots of other stuff
09:34:05 <saml> m is layers and layers of multiply applied monad transformer
09:34:19 <rostayob> Cale: yeah but usually that's the context in which i hear the word "union" in haskell
09:34:20 <saml> no.. m is like  (mt1 . mt2. mt3 ....) originalMonad
09:34:34 <saml> so, I think  T.lift m  lifts up to proper location.
09:34:37 <Younder> Cale, yes. But I feel this monad fixation has somewhat obscured that Haskell was intended to be a functional language.
09:34:40 <rostayob> saml: no but seriously. you don't need to be formally educated in maths to be good at haskell.
09:34:43 <bfig> saml, but lift is supposed to know when to stop already
09:34:52 <bfig> ie, you don't lift arbitrarily, you lift a single level
09:34:58 <saml> rostayob, okay. you are not good at math but good at haskell.
09:35:03 <rostayob> the problem is that a lot of haskell users are formally educated in maths, so they write formally :)
09:35:05 <byorgey> Younder: eh? there is nothing non-functional about monads.
09:35:05 <Cale> Younder: Uhh... maybe. Though it's not like monads aren't also functional programming.
09:35:21 <saml> bfig, i don't know.. i just copy and paste from snippets and modify a bit
09:35:28 <saml> i can't comprehend what's really going on
09:35:29 <Cale> In fact, you can't even discuss monads in a language which doesn't support first class functions.
09:35:42 <Cale> Because (>>=) needs to take a function as a parameter
09:35:54 <roconnor> Since monads are a useful tool for createing tree-like structures, I'm a little surprised they don't appear more often in other languages. :)
09:35:59 <erus`> do function pointers count?
09:36:01 <Younder> Cale, That's like saying you can't do functional programming in C
09:36:05 <Cale> (as does fmap, if you go fmap/return/join)
09:36:09 <rostayob> Younder: well Monads don't have much to do with your previous assertions :P
09:36:19 <rostayob> Younder: also, what's wrong with monads?
09:36:27 <Younder> Cale, Monads brake the rules
09:36:41 <Cale> Younder: are you just trolling, or do you want me to explain this?
09:37:06 <Eduard_Munteanu> Most monads aren't magic in any way.
09:37:18 <Cale> Monads don't break any rules.
09:37:23 <roconnor> Arguably all monads aren't magic in any way.
09:37:35 <Eduard_Munteanu> You can even consider them to be sugar.
09:37:36 <rostayob> Eduard_Munteanu: all monads that are implementable in haskell are not magic
09:37:49 <rostayob> the only "magic" one are the ones implemented in the compiler
09:38:05 <Cale> rostayob: and hey, even IO is implementable in Haskell
09:38:10 <Eduard_Munteanu> rostayob: yeah, I mean they don't need any magic primitives like IO or ST do
09:38:21 <rostayob> Cale: yeah I suppose
09:38:25 <Younder> Cale, it is complicated.  By the way I have spendt most of the year studying Adowey's 'category theory' A very strong theory which goes straight to the foundations of mathematics
09:38:44 <rostayob> Younder: tell me more about this 'category theory'
09:38:46 <Cale> Younder: That is my favourite intro to CT
09:38:53 <Eduard_Munteanu> Awodey, even.
09:39:26 <Younder> Cale, Well I found cathegory theory should be the base of topology which in turn should be at the base of the type system
09:39:27 <Eduard_Munteanu> Younder: wait, you mean Haskell monads aren't really monads? That'd be another thing.
09:39:40 <rostayob> topology?
09:39:53 <Younder> Eduard_Munteanu, the aren't but that is another story
09:39:56 <rostayob> I'm loving this discussion
09:40:13 <rostayob> sadly i have to go
09:40:21 <erus`> oh boy here we go
09:40:40 <roconnor> Younder: the post-modern interpretation of type theory is as homotopy.
09:40:50 <rostayob> i'd say post-postmodern
09:41:13 <rostayob> http://www.somethingofthatilk.com/comics/14.jpg
09:41:28 <KirinDave> Storm clouds on the horizon of #haskell.
09:41:57 --- mode: ChanServ set +o Cale
09:42:02 <Cale> WINTER IS COMING
09:42:41 --- mode: Cale set -o Cale
09:42:54 <Younder> well it is logical.. Set theory provides you with just another implementation of the description. Category theory goes beyond the implementation and just describes the effects. Much better for a formal analysis on a computer.
09:43:17 <hii> Hai
09:43:27 <Cale> hi hii
09:43:28 <Eduard_Munteanu> O HAI
09:43:42 <hii> I have an understanding problem concerning a function from the book LearnYouAHaskell
09:43:48 <hii>     powerset :: [a] -> [[a]]
09:43:48 <hii>     powerset xs = filterM (\x -> [True, False]) xs
09:43:54 <hii> this function
09:44:08 <hii> why does it work that way:     ghci> powerset [1,2,3]
09:44:08 <hii>     [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:44:21 <Younder> In a sense Monad transformers are a mapping from one user space to another
09:45:12 <hii> shouldn the resulting list be [[1],[2],[3]] ?
09:45:24 <Cale> Younder: How so?
09:45:28 <Jaxan> hii: do you know what a powerset is?
09:45:31 <hii> yes
09:45:40 <hii> I dont understand WHY this function produces one
09:45:42 <Jaxan> why do you think, that would be the result then ?
09:45:45 <Younder> later
09:45:46 <Jaxan> oh
09:45:50 <Cale> hii: for each element of the list, either keep it, or drop it
09:46:02 <Cale> hii: That's what that code says, essentially.
09:46:07 <hii> but
09:46:30 <saml> hii, i think the secret is in filterM  and list being monad, too
09:46:31 <hii> I thought filter just takes ONE element of a list, so how can for example  [1,2,3] be a list member
09:46:49 <mauke> hii: this is filterM, not filter
09:46:53 <Cale> hii: filterM is being used in the list monad here. "Running" a list in the list monad means selecting an element from it in all possible ways.
09:46:57 <jpcooper> j #gp2011
09:47:00 <jpcooper> whoopsie
09:47:12 <Cale> > do x <- [1,2,3]; y <- [4,5]; return (x,y)
09:47:13 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
09:47:15 <Cale> yeah?
09:47:33 <Cale> In this case...
09:47:48 <hii> aw
09:47:49 <Cale> filterM :: (a -> [Bool]) -> [a] -> [[a]]
09:48:15 <hii> ok got it
09:48:23 <Cale> For each element of the list, we apply the function to get a list of options for whether it should be kept or not
09:48:35 <Cale> We could do one which unconditionally keeps even numbers:
09:48:38 <KirinDave> Man I am having a hell of a time choosing a new laptop model to make my Big Return To Linux. :\
09:48:51 <Cale> > filterM (\x -> if even x then [True] else [True, False]) [1,2,3]
09:48:52 <lambdabot>   [[1,2,3],[1,2],[2,3],[2]]
09:48:53 <rostayob> KirinDave: just a sec, i have the solution for you
09:48:59 <KirinDave> My desire to do more haskell has progressed so far that I want competent haskell more than I want mac os x.
09:49:12 <rostayob> KirinDave: if you live in the UK the dell refurbished laptops store is a goldmine.
09:49:24 <rostayob> i don't know if there is a US equivalent, but probably
09:49:26 <KirinDave> rostayob: I'm looking at a new work laptop
09:49:40 <KirinDave> rostayob: So far the Lenovo W520 seems to be the way to go. I'm just bummed it's so thick.
09:49:44 <saml> get an ipad
09:49:54 <KirinDave> saml: Got 2.
09:49:55 <rostayob> KirinDave: ah, you want to spend a lot of money. then it's fine
09:50:02 <saml> can you give me one thanks.
09:50:16 <KirinDave> rostayob: I want something I can compile scala on. Have you tried this? Scalac is the Microsoft Word of compilers.
09:50:16 <hii> Cale, I didn't get how to understand the part [True, False]
09:50:27 <KirinDave> rostayob: It scales to fill available computing power.
09:50:27 <hii> in the function body of filterM
09:50:31 <rostayob> KirinDave: i've just bought a beast of a laptop for 660
09:50:44 <KirinDave> rostayob: Quad core i7? SSD? 8gb ram?
09:50:45 <rostayob> i didn't even want a powerful laptop
09:50:54 <roconnor> hii: in the function argument of filterM
09:51:41 <hii> I actually dont get what [True, False] means
09:51:45 <rostayob> KirinDave: http://pastebin.com/sv3bqVYX why would you need 8GB of RAM? where is this world going?
09:51:47 <mauke> The paste sv3bqVYX has been copied to http://hpaste.org/51808
09:51:58 <rostayob> I've never ever swapped since I have 4GB I think
09:52:01 <rostayob> never ever came close
09:52:08 <rostayob> what do you guys do with 8GB of RAM?
09:52:11 <KirinDave> rostayob: I need more than that, by far.
09:52:18 <KirinDave> I could easily use 32
09:52:30 <KirinDave> rostayob: I have to model clusters of hardware in EC2. I use virtualbox for this.
09:52:32 <rostayob> KirinDave: do you run a mysql server on your laptop?
09:52:37 <rostayob> oh, close enough.
09:52:40 <KirinDave> My macbook pro caps out at maybe 2-3 small machines.
09:52:53 <rostayob> well then you shouldn't do it on a laptop
09:52:54 <KirinDave> But with 32gb of ram, I could model many more, or even a real database server.
09:53:02 <KirinDave> Why?
09:53:04 <rostayob> just do in on a rented server or something
09:53:09 <KirinDave> Haha
09:53:14 <rostayob> because it's a huge waste of money do that on a laptop
09:53:15 <KirinDave> Renting servers with these specs is expensive.
09:53:23 <rostayob> cramming all those resources on a portable thing
09:53:23 <Eduard_Munteanu> rostayob: you can typecheck some Agda libraries with 8GiB RAM :P
09:53:33 <KirinDave> rostayob: I don't understand.
09:53:54 <rostayob> I think it's just insane that we "need" 8GB of ram on a workstation now
09:53:56 <KirinDave> rostayob: What use would it be if it wasn't mobile? It's meant to be a working machine.
09:54:15 <KirinDave> rostayob: Yeah well, it's not that much anymore. Heck, ultraportables are starting to come with 4gb standard.
09:54:16 <rostayob> because you can do all these experiments remotely?
09:54:27 <rostayob> who decided that is not that much?
09:54:33 <rostayob> i idle around 300MB
09:54:40 <KirinDave> rostayob: The industry and moore's law?
09:54:40 <rostayob> even less
09:54:47 <rostayob> KirinDave: yeah ok, keep buying
09:55:02 <KirinDave> rostayob: I feel like you are projecting derision my way for having a job that requires memory intensive work.
09:55:07 <KirinDave> I don't really get it.
09:55:37 <rostayob> KirinDave: no sorry, it's not personal, i just think this race towards super powerful laptops is kind of mad
09:55:38 <KirinDave> But as for why I want a portable, I just don't think desktops make much sense. I want to be able to work on my commute, work at home, work at work. I can't always assume I have great connectivity.
09:55:47 <yitz> KirinDave: he's not projecting derision at you, he's projecting it at the manufacturers
09:55:50 <KirinDave> Ah.
09:56:09 <rostayob> also, the electronics market in general is completely insane
09:56:13 <KirinDave> why?
09:56:18 <KirinDave> Becuase it's scaling exponentially?
09:56:24 <rostayob> you can buy a really powerful laptop for 600
09:56:30 <rostayob> great processor ram and gpu, whatever
09:56:33 <rostayob> but it's built like shit
09:56:37 <rostayob> you can cook stuff in it
09:56:37 <KirinDave> yeah
09:56:40 <rostayob> the keyboard sucks
09:56:43 <KirinDave> I agree.
09:56:49 <KirinDave> That's why I'd never consider something like a dell.
09:56:53 <KirinDave> Their laptop designs are awful.
09:56:54 <rostayob> *all* of them, apart from thinkpad and maybe dell latitudes, are like that
09:57:02 <KirinDave> Toshiba is coming around, it seems.
09:57:08 <rostayob> KirinDave: dell latitudes are ok
09:57:09 <KirinDave> And Asus is a quietly competent contender.
09:57:11 <Cale> DUDE, YOU'RE GETTING A DELL!
09:57:13 * Eduard_Munteanu suggests we could talk this over in -blah
09:57:16 <Cale> lol
09:57:16 <KirinDave> True.
09:57:19 <dankna> I like how "all of them" never includes Macs
09:57:21 <rostayob> Eduard_Munteanu: you're right
09:57:27 <KirinDave> "your rite"
09:57:36 <Eduard_Munteanu> amirite? :P
09:57:43 <rostayob> KirinDave: and anyway, it's not even worth trying anymore, they're all bad even thinkpads
09:57:47 <rostayob> so i just buy the cheap ones
09:57:52 <rostayob> possibly used
09:57:59 <rostayob> but yeah this belongs to -blah
10:03:11 <knoc> hello, I've come to a situation where I want to partial apply record-syntax
10:03:36 <DanBurton> knoc: meaning...what exactly?
10:03:37 <knoc> but ghci tells me: Warning: Fields of `G' not initialised: gString
10:04:18 <erus`> DanBurton: pass record accessors around
10:04:23 <erus`> excuse my spelling
10:04:32 <knoc> np; i thought about that ;)
10:04:43 <DanBurton> knoc: right; I don't think Haskell supports partially-applied record syntax for creating new records
10:04:47 <knoc> but then I have to reorder deconstructor arguments^^
10:04:50 <knoc> ok
10:05:02 <knoc> so I could try a lambda epression?
10:05:07 <DanBurton> definitely
10:05:16 <tac-tics> > length ['a', 'b',..]
10:05:17 <lambdabot>   <no location info>: parse error on input `..'
10:05:25 <knoc> kk
10:05:29 <tac-tics> > length ['a', 'b'..]
10:05:30 <lambdabot>   1114015
10:07:34 <Clint> what's a sane way of using unfoldr with b -> IO (Maybe (a,b))
10:07:42 <erus`> when will record syntax functions be first class?
10:07:53 <mreh_> look at this funny guy in my heap profile ->(#,,,#)
10:08:04 <mreh_> dead zoidberg?
10:08:07 <plat0> He looks like an evil fly.
10:08:16 <DanBurton> erus`: no clue
10:08:18 <Botje> Clint: you can't
10:08:18 <Eduard_Munteanu> Woo boo boo boo
10:08:39 <Clint> Botje: hmm
10:08:42 <DanBurton> Clint: maybe lift unfoldr into IO or something nasty
10:09:02 <Clint> and then join?
10:09:02 <erus`> DanBurton: what is the correct term for a record syntax function?
10:09:13 <DanBurton> :t liftM unfoldr
10:09:14 <lambdabot> forall b a (m :: * -> *). (Monad m) => m (b -> Maybe (a, b)) -> m (b -> [a])
10:09:42 <DanBurton> erus`: record accessor I believe is the correct term
10:09:53 <DanBurton> @wiki record syntax
10:09:54 <lambdabot> http://www.haskell.org/haskellwiki/record_syntax
10:10:06 <byorgey> Clint: I think you'll have to write your own unfoldM
10:10:17 <Clint> :(
10:10:36 <mokus> or pull in a library that provides one, like monad-loops
10:11:01 <Clint> ahh
10:11:22 <DanBurton> @hoogle a -> m b -> (m (a -> b))
10:11:23 <lambdabot> No results found
10:11:49 <DanBurton> @hoogle (a -> m b) -> (m (a -> b))
10:11:50 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
10:11:59 <Clint> mokus: thanks
10:12:01 <DanBurton> promote huh..interesting..
10:12:50 <Axman6> @hackage monad-loops
10:12:50 <lambdabot> http://hackage.haskell.org/package/monad-loops
10:13:27 <Botje> unfoldM f s = do { x <- f s; case x of { Nothing -> []; Just (el, s') -> do { els <- unfoldr f s'; return (el:els) } }
10:13:31 <Botje> something like that.
10:13:59 <byorgey> DanBurton: most monads cannot support an operation like promote
10:14:12 <byorgey> Gen is rather special in that regard.
10:15:04 <DanBurton> yeah I'm trying to imagine how to do it for the IO monad but it's not really clicking
10:15:46 <byorgey> DanBurton: the problem is that with (a -> m b)  you get to decide what effects to produce based on the a.  With  m (a -> b) you have to decide on the effects before you ever get to see an a.
10:16:24 <byorgey> however, the other direction, m (a -> b) -> a -> m b, is unproblematic
10:16:57 <DanBurton> byorgey: makes sense
10:17:22 <ion> :t \ff a -> ($ a) <$> ff
10:17:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
10:18:58 <elliott> Is there no way to derive (Generic) for a data type without depending on ghc-prim?
10:19:04 <elliott> It's not exported from GHC.Exts.
10:19:39 <TotoTitus> is there any non-interruptible discussion going on? I'm going through Learn you a Haskell, and i've encountered something which bugs me.
10:19:51 <TotoTitus> as in, i have a question
10:19:55 <byorgey> TotoTitus: all discussions on #haskell are interruptible.
10:20:05 <byorgey> ask away.
10:20:05 <TotoTitus> ah
10:20:12 <TotoTitus> here i go
10:20:26 <TotoTitus> data Barry t k p = Barry { yabba: p, dabba: t k }
10:20:36 <elliott> ::, not :
10:20:40 <TotoTitus> yes
10:20:47 <TotoTitus> It has a kind of (* -> *) -> * -> *
10:20:47 <byorgey> ok
10:20:54 <TotoTitus> all fine
10:21:01 <TotoTitus> and we're making this an instance of Functor
10:21:04 <elliott> ...also, if "import GHC.Generics (Generic)" works but "import GHC.Generics" then referencing Generic later (as ''Generic in some TH stuff) says Generic isn't in scope, who's bug is it?
10:21:08 <byorgey> (* -> *) -> * -> * -> *, right?
10:21:18 <TotoTitus> right again
10:21:19 <bfig> yes you missed one
10:21:24 <byorgey> TotoTitus: ok
10:21:34 <TotoTitus> which means partially applying until we get a * -> *
10:21:42 <TotoTitus> very well.
10:21:45 <armlesshobo> yup
10:21:49 <TotoTitus> instance Functor (Barry a b) where
10:22:05 <heiz> Hi! I wish \ to be a function(not syntax). How can I write my own function that will generate lambda functions?
10:22:12 <TotoTitus> fmap f (Barry { yabba = x, dabba = y} ) = ...
10:22:26 <TotoTitus> when writing a function fmap
10:22:34 <Botje> heiz: how would you inject new variable namesz?
10:22:36 <TotoTitus> we're facing a concrete type
10:22:39 <Axman6> well, you want to change the yabba using f no?
10:22:48 <TotoTitus> my problem is with dabba
10:22:53 <TotoTitus> why isn't dabba y z ?
10:22:55 <TotoTitus> of type y z ?
10:23:05 <TotoTitus> (or, insert any other letter)
10:23:06 <Axman6> why does anything need to be done with dabba?
10:23:13 <byorgey> it is of type (a b)
10:23:25 <TotoTitus> because initially Dabba was defined as a "t k " field
10:23:27 <byorgey> given  instance Functor (Barry a b)
10:23:30 <Axman6> or (t k) in your original definition
10:23:41 <heiz> @Botje mb as a string. I don't know how to start.
10:23:41 <lambdabot> usage: @vote <poll> <choice>
10:23:51 <TotoTitus> did the author forget the additional type of "dabba " ?
10:23:51 <byorgey> TotoTitus: those letters are just placeholders, the particular letters used don't matter
10:24:00 <TotoTitus> of course, that's my point
10:24:03 <TotoTitus> i mean
10:24:05 <TotoTitus> around the point
10:24:14 <Botje> heiz: it's a pretty weird request. is this homework?
10:24:22 <TotoTitus> in the body of fmap, whe're dealing with a fully fledget Barry a b c
10:24:30 <TotoTitus> fledged*
10:24:36 <TotoTitus> which means, yabba is of type "c"
10:24:44 <TotoTitus> and dabba should be of type " a b "
10:24:50 <byorgey> right
10:25:01 <TotoTitus> and the author mentioned only a single type for dabba
10:25:01 <byorgey> so what's the question?
10:25:12 <heiz> not exactly.
10:25:15 <byorgey> TotoTitus: where?
10:25:24 <TotoTitus> Barry { Yabba = x, dabba = y} )
10:25:24 <TotoTitus> OHHH
10:25:27 <TotoTitus> IT PATTERN MATCHED
10:25:29 <TotoTitus> sorry
10:25:31 <byorgey> those are names, not types =)
10:25:37 <TotoTitus> i got confused
10:25:38 <Axman6> fmap f (Barry x tk) = Barry (f x) tk
10:25:41 <TotoTitus> Y can be anything, right
10:25:50 <Axman6> yes
10:25:52 <byorgey> TotoTitus: but also (a b) IS a single type.  It is the application of a to b.
10:26:01 <Axman6> like Maybe Int
10:26:14 <TotoTitus> yeeah, a is the computational context for b
10:26:21 <TotoTitus> type constructor
10:26:26 <TotoTitus> sweet
10:26:29 <Axman6> Barry "Hello" (Just 3) would have type Barry Maybe Int String
10:27:09 <TotoTitus> the syntax confused me, since i've yet to grasp it enough
10:27:13 <Axman6> TotoTitus: you seem to have gotten a long way into learning haskell without visiting #haskell. the general consensus is 'you're doing it wrong' if that's the case :P
10:27:26 <Axman6> (mainly because you're missing out on the majority of the awesome haskell community)
10:27:39 <TotoTitus> well, i've visited Learn you a Haskell several times
10:27:43 <byorgey> well, now TotoTitus knows about #haskell, so no lasting harm done =)
10:27:45 <TotoTitus> but this time i've gotten into it
10:27:50 <TotoTitus> i have been here before
10:27:54 <TotoTitus> but i have not interacted
10:28:05 <knoc> observation is also interaction ;)
10:28:06 <Axman6> you should, we're very helpful :P
10:28:16 <knoc> like in quantum physics
10:28:18 <TotoTitus> (well, one night i began telling everyone my life-story-about-programming), but that's a different issue
10:28:29 <byorgey> hehe
10:28:29 <TotoTitus> here, on #haskell
10:29:03 <TotoTitus> Well, i'm off, the IO chapter (which i've read before, but not that attentively) is before me
10:29:11 <TotoTitus> thanks lads
10:29:19 <Axman6> stick around and ask questions
10:30:13 <TotoTitus> yeah, this language isn't like anything i've ever seen
10:30:25 <saml> what language?
10:30:29 <saml> chinese?
10:30:30 <TotoTitus> Haskell !
10:30:30 <knoc> english?
10:30:47 <saml> haskell is similar to miranda
10:30:55 <TotoTitus> i am saying this being previously exposed to Lisp
10:31:01 <tac-tics> No one in the history of every has used or heard of Miranda
10:31:09 <tromp> miranda is similar to SASL
10:31:19 <DanBurton> so...this is obviously evil; can someone tell me what this will break?
10:31:34 <DanBurton> promoteIO f = return $ \a -> unsafePerformIO (f a)
10:31:38 <tac-tics> It's like ML if ML allowed lazy evaluation and disallowed side effects
10:31:51 <TotoTitus> it's like F#, ... no, no just kidding
10:31:55 <DanBurton> promoteIO :: (a -> IO b) -> IO (a -> b)
10:31:59 <Eduard_Munteanu> Minus the verbose syntax.
10:32:14 <TotoTitus> salut Eduard, i suspect that you are Romanian
10:32:22 <Eduard_Munteanu> TotoTitus: yup
10:32:27 <Eduard_Munteanu> o/
10:32:57 <elliott> DanBurton: Everything.
10:33:20 <byorgey> DanBurton: the resulting IO (a -> b) action will not do anything initially, but at some future, unpredictable time (or maybe never, or maybe more than once) when the function is evaluated it will cause an IO effect to happen.
10:33:33 <TotoTitus> side effect ?
10:33:35 <elliott> DanBurton: augh <- promoteIO gimmeARandomNumberAndAddThisToIt; print (map gimmeARandomNumberAndAddThisToIt [0..])
10:33:36 <bfig> what is reasonably to assume by 'define the MonadReader instance of ResT ?'
10:33:51 <elliott> erm
10:33:53 <elliott> DanBurton: augh <- promoteIO gimmeARandomNumberAndAddThisToIt; print (map augh [0..])
10:34:10 <bfig> s/reasonably/reasonable
10:34:46 <DanBurton> elliott: ah that makes sense. I had the vague idea but that example is good
10:35:11 <elliott> for a better demonstration, map augh [x,x,x,x] for the same x
10:35:17 <elliott> suddenly beta-reduction is broken :)
10:35:32 <DanBurton> indeed
10:36:01 <TotoTitus> i have yet to find a PDF with Learn you a Haskell along with the pretty images, does anyone have a link ?
10:36:26 <TotoTitus> sorry for the slightly engrishy english, i'm too tired to speak properly
10:36:32 <TotoTitus> or lazy
10:36:34 <Eduard_Munteanu> LYAH has been published in dead tree form IIRC.
10:36:44 <TotoTitus> dead tree ?
10:36:49 <Botje> TotoTitus: you can buy it from the publisher.
10:36:49 <Axman6> the book
10:36:50 <Eduard_Munteanu> Paper :)
10:37:01 <Axman6> @learn you a haskell book
10:37:01 <lambdabot> http://www.haskell.org/learning.html
10:37:06 <Axman6> @google learn you a haskell book
10:37:07 <lambdabot> http://learnyouahaskell.com/faq
10:37:07 <Axman6> >_>
10:37:07 <lambdabot> Title: Learn You a Haskell for Great Good! - FAQ
10:37:11 <Axman6> hmm
10:37:40 <Eduard_Munteanu> http://nostarch.com/lyah.htm
10:37:51 <DanBurton> @google amazon learn you a haskell
10:37:52 <lambdabot> http://www.amazon.com/Learn-You-Haskell-Great-Good/dp/1593272839
10:38:25 <DanBurton> botfeed
10:38:27 <DanBurton> @botfeed
10:38:28 <lambdabot> Unknown command, try @list
10:38:33 <dmwit> ?botsnack
10:38:34 <lambdabot> :)
10:38:34 <DanBurton> doh what is the command to feed lambdabot
10:38:36 <sipa> g/wc
10:38:42 <DanBurton> @botsnack
10:38:43 <lambdabot> :)
10:39:04 <dmwit> ?bot
10:39:05 <lambdabot> :)
10:40:04 * dsouza truly considers lambdabot a nice piece of software :-)
10:40:23 <TotoTitus> lambdabot is spy !
10:40:34 <TotoTitus> mentlegen
10:40:50 <erus`> oh boy here we go. meme time
10:41:27 <TotoTitus> over 9000 memes
10:49:43 <TotoTitus> What i find extremely interesting:
10:50:05 <DanBurton> ?
10:50:12 <enzuru> - elisp
10:50:21 <enzuru> is that what you wanted to say?
10:50:28 <TotoTitus> The Lisp community is very well known for the presence of Lisp fanatics within it, yet in an at least equally interesting community
10:50:35 * enzuru coughs.
10:50:35 <TotoTitus> (Haskell), i've yet to see
10:50:51 <TotoTitus> well, you got the point
10:50:52 <DanBurton> <-- Haskell fanatic
10:51:05 <TotoTitus> oh, let me rephrase
10:51:12 <TotoTitus> most of the people who use Lisp have a scent of fanatism
10:51:18 <DanBurton> lol
10:51:23 <TotoTitus> i was once touched by it
10:51:30 <enzuru> But elisp is importante.
10:51:46 <TotoTitus> probably i'm wrong and i'm speaking nonsense, but, that's how i felt
10:51:47 <TotoTitus> elisp ?
10:51:48 <enzuru> To the spiritual growth of young women and men in the programming world.
10:51:50 <TotoTitus> emacs Lisp ?
10:51:53 <enzuru> Yes.
10:52:00 <enzuru> haskell-mode is coded in elisp!
10:52:09 <enzuru> they are symbiotic!
10:52:16 <DanBurton> the cool thing about Lisp is that there are only parens, so it is surprisingly easy to learn
10:52:18 <TotoTitus> hmm, what does in have in comparison to Common L./Scheme ?
10:52:36 <TotoTitus> yes, homoiconicity, or how's it called, extremely cool
10:52:43 <DanBurton> elisp == guile ?
10:52:52 <enzuru> it's a watered down language basically just used to extend an editor. clisp and elisp split years ago, but one or two things jump the pond to the other.
10:53:11 <enzuru> no, but there is a movement of emacs users who want to replace elisp with guile
10:53:24 <TotoTitus> quote from the internet "Having Common Lisp is just like owning an Elephant "
10:54:23 <bfig> TotoTitus, what?
10:54:23 <Kaidelong> Haskell's || and && are not commutative, wondering how big a problem this is
10:54:44 <bfig> Kaidelong, most programming languages don't have || and && commutative...
10:54:46 <DanBurton> not commutative? they are short-circuited, just like any other language
10:54:54 <monochrom> oh, DanBurton: http://www.vex.net/~trebla/haskell/lazy.xhtml
10:55:11 <DanBurton> monochrom: oooohhhhhh thanks!
10:55:12 <TotoTitus> never mind, some guy emphasising on the power of CL, i just grabbed what he said
10:55:25 <Kaidelong> I guess it's commutative as far as boolean logic is concerned
10:55:34 <Kaidelong> so if you use them as boolean operators then you are fine
10:55:59 <monochrom> SML uses the names "andalso" "orelse" so you don't guess they are commutative
10:56:06 <saml> can i help you?
10:56:21 <Kaidelong> monochrom: SML isn't pure so it's kind of a different question there
10:56:32 <Kaidelong> the actual effects produced can be different depending on the order
10:56:52 <DanBurton> monochrom: do you mind if I link to this on StackOverflow and/or reddit?
10:57:00 <monochrom> I don't mind
10:57:43 <Kaidelong> what are the practical considerations in the way of making || and && commutative in haskell?
10:57:50 <Kaidelong> or is it just a historical thing that they aren't?
10:58:03 <monochrom> Haskell is non-strict, ⊥&&x and x&&⊥ can have different effects, too
10:58:21 <Kaidelong> why?
10:58:32 <Kaidelong> you could concurrently evaluate both values
10:58:44 <Kaidelong> and get a non-strict operator that is still commutative
10:58:45 <tromp> and get an error
10:58:51 <monochrom> yes, that will be the most non-strict
10:59:01 <tromp> e.g. if empty l or head l == ...
10:59:15 <Kaidelong> (and maps nicely to the trivalent operators Kleene used)
11:00:32 <Kaidelong> so I'm wondering if there is a big disadvantage to having the operators commutative
11:00:36 <Kaidelong> I can't think of one offhand
11:00:46 <Botje> no shortcircuiting.
11:00:52 <monochrom> I guess it's just historical. 20 years ago no one wanted to implement parallel-or. the next best thing is assymetric, conditional non-strictness
11:01:13 <rwbarton> isn't concurrent evaluation rather more expensive?
11:01:15 <Botje> cheap-operation || expensive-operation
11:01:31 <Kaidelong> Botje: the expensive one gets terminated after the cheap one finishes
11:01:42 <Botje> well, yes
11:01:51 <Botje> but that's the whole point of shortcircuiting :)
11:02:13 <Botje> if you introduce concurrent-or, i'd still like a short-circuiting or
11:02:26 <Kaidelong> yeah well you don't have to choose
11:02:37 <rwbarton> well you have to choose which one is called (||)
11:02:41 <Kaidelong> yeah
11:02:56 <dmwit> The unamb package provides pand and por.
11:03:02 <dmwit> So if you want them, you can have them.
11:03:08 <Kaidelong> unamb is pretty nice
11:08:25 <Philippa> I'm having a "dammit, this design doesn't quite work out as nicely as it should" moment...
11:08:49 <Philippa> I've got something that I'd originally intended to be in an Applicative, which I may be able to keep that way rather than go to full-blown monads
11:08:50 <Philippa> *but*
11:09:16 <Philippa> I need it to support a gensym effect and a constrain effect, and I need to be able to use the results of gensyms in constrains
11:09:47 <elliott> Add a bindGenSymToConstrain? :-P
11:10:57 <Philippa> elliott: well yeah, or at least a variant of constrain that does the equivalent. Thing is, I want to make it clear that my constraint-generating code doesn't do anything with the generated symbols except put them inside structures inside constraints: I want to rule out branching based on the result of gensym
11:13:38 <Philippa> eh, it'll do. It's still something of a design wart though, and it's not like I like Arrows any better
11:15:01 <TotoTitus> What is the implicit context when using 'let' without an 'in' ?
11:15:10 <TotoTitus> scope, i mean
11:15:20 <elliott> TotoTitus: only applies inside a "do" block
11:15:30 <elliott> and it encloses the rest of the do block
11:15:45 <elliott> (actually, if the pattern match fails, it's a failure inside the monad, but you probably don't care about that for now)
11:16:03 <TotoTitus> that means forgetting the 'in' anywhere else will lead to an exception ?
11:16:14 <elliott> no exception -- a runtime syntax error
11:16:28 <elliott> or a type error depending I guess
11:16:31 <TotoTitus> ah, i see, thanks
11:19:18 <mysticc_> I am in a weird situation .. I am using state monad to capture the state of an execution .. the type is State s (Maybe a) .. and I have a function of type Stmt->State s (Maybe a). I have a list of Stmt type and a dummy Stmt type. I have to run the function over list and then 0 or more times over dummy so that the number of NotNothing output is some constant n ??
11:19:21 <geheimdienst> TotoTitus: outside of a do block, only let...in is possible (let without in is disallowed). the compiler will tell you
11:19:41 <Philippa> elliott: I think I may have a bonus problem that screws me over further, too. The obvious "bind" solution stops me from /then/ returning the gensym separately because only the constrain function gets to see it. So yeah, I think this is a job for arrows. *puke*
11:20:29 <mysticc_> doing just sequence over the list does not help in my case ..
11:20:35 <navaati> hello
11:20:42 <elliott> Philippa: I'm so glad I never developed an intuition for arrows, so I never have to deal with the feeling "oh no, this is an arrow".
11:20:59 <navaati> is there a way in haskell to do traditionnal unix SHM using mmap ?
11:21:11 <Philippa> elliott: well, I have the problem that I want to make it really, really clear I don't need higher-orderness
11:21:20 <Philippa> and a couple of other bits and pieces about my dataflow
11:21:29 <elliott> navaati: yes but it's quite ugly.
11:21:32 <rostayob> arrows are weird. those tuples.
11:21:41 <Philippa> rostayob: they're just environments
11:21:55 <Renze> good evening!
11:21:55 <Philippa> (though it'd be nicer if they were records than tuples)
11:22:03 <elliott> navaati: http://hackage.haskell.org/package/vector-mmap, http://hackage.haskell.org/package/hmatrix-mmap, http://hackage.haskell.org/package/bytestring-mmap, http://hackage.haskell.org/package/bindings-mmap, http://hackage.haskell.org/package/mmap
11:22:05 <elliott> take your pick :P
11:22:14 <rostayob> Philippa: yeah, but having those tuples makes them feel kind of constrained in a way
11:22:15 <navaati> elliott : what do you mean ? in the unix system dev context, why should it be ugly ?
11:22:28 <elliott> navaati: first two are based on the last one listed, the mmap package, which is nice in that it works on windows
11:22:34 <elliott> navaati: well, because it is kind of like lazy io
11:22:36 <Philippa> rostayob: that's supposed to be the point :-) You can see all the dataflow explicitly
11:22:37 <Renze> i've got a questing about compiling; as I am trying to create an exe for 'simple' people to work with, i only get a .o file with 'ghc --make myfile.hs', am i doing anything wrong?
11:22:40 <elliott> in that it introduces some impurity
11:22:48 <Renze> (i work with windows 7 64 bits)
11:23:06 <rostayob> Philippa: I guess, I just get sad when I look at the type sig :)
11:23:08 <elliott> Philippa: unless you use arrow notation and turn the compiler into a rube goldberg machine :P
11:23:12 <Philippa> meh. It may be easier for sanity's sake to just write /all/ the code in monadic style
11:23:26 <Philippa> elliott: even then it's in the types
11:23:40 <Blkt> good evening everyone
11:23:45 <elliott> I wonder if you can implement arrow notation inside Haskell, by having like an arrow notation monad
11:24:45 * hackagebot cpphs 1.13.1 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.13.1 (MalcolmWallace)
11:25:50 <TotoTitus> http://pastebin.com/WR7W7zA1
11:25:51 <DanBurton> Blkt: good afternoon
11:25:52 <mauke> The paste WR7W7zA1 has been copied to http://hpaste.org/51809
11:25:56 <TotoTitus> i have pasted a question here
11:26:54 <elliott> TotoTitus: because in "else foo", foo is an expression
11:27:04 <elliott> just like in "main = foo", foo is an expression
11:27:12 <elliott> so do use do notation from the inside, you have to use "do"
11:27:22 <elliott> the "if/then/else" inside a do block is not a different if/then/else to the outside
11:27:28 <elliott> it's the same if everywhere :)
11:27:37 <elliott> just in this case, you're using it to create a monadic action
11:27:58 <TotoTitus> my mind is so tied to if (block, sequence) else (block, sequence)
11:28:17 <mauke> do you know the ?: operator?
11:28:20 <TotoTitus> yes
11:28:25 <TotoTitus> i get it
11:28:28 <TotoTitus> gotcha
11:28:31 <mauke> (that's what if-then-else is)
11:28:31 <navaati> oh, and for the beauty of your code, check this and try to use it :
11:28:34 <elliott> Gotchaen.
11:28:35 <navaati> :t when
11:28:36 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:28:45 <navaati> @source when
11:28:45 <lambdabot> when not available
11:28:47 <elliott> In fact
11:28:49 <elliott> :t unless
11:28:50 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:28:51 <Axman6> when is quite handy
11:28:52 <elliott> is more appropriate here :-)
11:29:07 <navaati> oh, nice elliott, i didn't know this one :)
11:29:28 <TotoTitus> i'll dig into it once i properly understand monads
11:29:34 <hpaste> elliott annotated “pastebin.com/WR7W7zA1” with “TotoTitus: tweaked it a bit :-)” at http://hpaste.org/51809#a51810
11:29:41 <elliott> hehe, just demonstrating it
11:29:47 <elliott> if/then/else is simpler at this point I'd think
11:29:48 * hackagebot pastis 0.1.2 - Interface to the past.is URL shortening service  http://hackage.haskell.org/package/pastis-0.1.2 (AlpMestanogullari)
11:30:09 <TotoTitus> thanks
11:30:23 <TotoTitus> so, unless implicitly returns an IO action ?
11:30:29 <elliott> :t unless
11:30:30 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:30:33 <elliott> in this case, m = IO
11:30:34 <elliott> so
11:30:37 <elliott> Bool -> IO () -> IO ()
11:30:38 <TotoTitus> i see
11:30:44 <elliott> and when it's true, it's just "return ()"
11:30:51 <TotoTitus> thanks elliott, and lambdabot
11:30:53 <elliott> ?src when
11:30:54 <lambdabot> when p s = if p then s else return ()
11:31:01 <elliott> ?src unless
11:31:01 <lambdabot> unless p s = if p then return () else s
11:31:03 <elliott> :)
11:31:07 <DanBurton> unless is in Control.Monad btw, iirc
11:31:14 <TotoTitus> *pats lambdabot
11:31:21 <TotoTitus> pets
11:31:22 <Axman6> unless = when . not right?
11:31:42 <navaati> :t when . not
11:31:43 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:31:55 <DanBurton> sounds right
11:32:00 <DanBurton> @src unless
11:32:01 <lambdabot> unless p s = if p then return () else s
11:32:02 <navaati> lambdabot says right ;)
11:32:05 <DanBurton> @src when
11:32:06 <lambdabot> when p s = if p then s else return ()
11:32:08 <DanBurton> psh
11:32:32 <TotoTitus> tis funny, strong typedness, coming from heavy exposure to Javascript, where you can divide numbers with Objects, and nothing crashes
11:33:13 <navaati> it's a shame that the only language allowed in browser is this shit
11:33:45 <hpaste> elliott annotated “pastebin.com/WR7W7zA1” with “TotoTitus: I ruined your code...” at http://hpaste.org/51809#a51811
11:33:56 <TotoTitus> Douglas Crockford: "Javascript is not...just a pile of mistakes "
11:33:58 <elliott> This is why you should stay away from @pl.
11:34:08 <TotoTitus> pl ?
11:34:15 <elliott> @pl \a b c -> c (b a) a
11:34:15 <lambdabot> flip =<< ((flip . flip id) .) . flip id
11:34:31 <elliott> It makes all code point-free (has no explicitly bound lambda variables).
11:34:50 <elliott> Forget it exists for as long as you can. :p
11:34:54 <DanBurton> @pl if p then s else return ()
11:34:54 <lambdabot> if' p s (return ())
11:35:28 <elliott> That's a cheat, if' is not in the standard library :-)
11:35:41 <navaati> :t flip id
11:35:42 <lambdabot> forall a b. a -> (a -> b) -> b
11:35:48 <TotoTitus> :k Maybe
11:35:49 <lambdabot> * -> *
11:35:54 <navaati> :t ($)
11:35:55 <lambdabot> forall a b. (a -> b) -> a -> b
11:35:55 <TotoTitus> huh, this thing works
11:36:06 <TotoTitus> :sudo make me a sandvich
11:36:08 <navaati> :t flip $ flip id
11:36:09 <lambdabot> forall b a. (a -> b) -> a -> b
11:36:26 <navaati> WTF !
11:36:46 <Axman6> ?
11:36:53 <Axman6> what's wrong?
11:36:59 <Axman6> :t flip
11:37:00 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:37:17 <Axman6> FFFFFFUUUUUUUU Cale -_-
11:37:23 <navaati> ($) = flip $ flip id !
11:37:30 <magicman> :t \f a b -> f b a -- Actual flip.
11:37:31 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
11:37:53 <Clint> :t fmap
11:37:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:38:07 <elliott> Axman6: Stop feeding Haskell code into a standard Caleskell compiler :-)
11:39:42 <TotoTitus> --help
11:39:44 <TotoTitus> -help
11:40:03 <Eduard_Munteanu> :t (Prelude..)
11:40:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:40:41 <byorgey> @list
11:40:41 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:40:41 <Eduard_Munteanu> :t (Prelude.flip)
11:40:43 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:41:17 <byorgey> TotoTitus: ^^^ perhaps?
11:41:30 <TotoTitus> yes ?
11:41:46 <TotoTitus> probably lambdabot is still making my sandvich
11:42:54 <roelvandijk> Anyone here speak Czech?
11:43:42 <Clint> only enough to order beer
11:44:08 <roelvandijk> Clint: Is it wrong to assume you don't regularly order 201 beers?
11:44:11 <dmwit> navaati: There's a better way to say that!
11:44:20 <dmwit> navaati: f = flip (flip f), and ($) = id
11:44:31 <dmwit> navaati: So *of course* ($) = flip (flip id)
11:44:32 <dmwit> =)
11:44:53 <navaati> …
11:44:59 <TotoTitus> ehm...how many of you guys are using Windows? (i have he feeling i'm an odd bird here)
11:45:03 <DanBurton> flip . flip $ id ==> id
11:45:15 <Renze> me
11:45:15 <navaati> :t ($)
11:45:16 <dmwit> flip . flip $ f ==> f
11:45:16 <lambdabot> forall a b. (a -> b) -> a -> b
11:45:18 <navaati> :t id
11:45:19 <lambdabot> forall a. a -> a
11:45:22 <elliott> :t (==>)
11:45:23 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
11:45:24 <elliott> Oh, wait.
11:45:27 <elliott> haha
11:45:28 <dmwit> :t id `asTypeOf` ($)
11:45:29 <lambdabot> forall a b. (a -> b) -> a -> b
11:45:33 <DanBurton> $ is id specialized for functions
11:45:49 <dmwit> :t let ($) :: (a -> b) -> a -> b; ($) = id in ($)
11:45:50 <lambdabot> forall a b. (a -> b) -> a -> b
11:46:10 <antihoax> someone knows how to make a function that takes any number of parameters and makes an average for example?
11:46:12 <dmwit> navaati: id has type "a -> a" for all "a"... including function types!
11:46:23 <Clint> roelvandijk: who can say
11:46:24 <trinithis> I've always preferred \x -> (\y -> (\z -> (\w -> w) z) y) x
11:46:26 <dmwit> so id :: (a -> b) -> (a -> b)
11:46:39 <dmwit> which is just a different way to parenthesize (a -> b) -> a -> b
11:47:06 <roelvandijk> antihoax: Have a look at the source of printf in Text.Printf
11:47:07 <dmwit> antihoax: Yes, there's a Stack Overflow question about that.
11:47:11 <dmwit> antihoax: One second.
11:47:16 <navaati> yeah, it's so obvious, how is it possible that I have never got that… this is also why i love haskell
11:47:36 <byorgey> antihoax: just make a function that takes a list instead.
11:48:23 <antihoax> ok thanks
11:49:29 <navaati> i know there are agdaists here, so… is agda long to build (the language platform, not agda programs) ?
11:49:31 <dmwit> antihoax: My answer to that question in detail: http://stackoverflow.com/questions/6168880/why-is-such-a-function-definition-not-allowed-in-haskell/6298414#6298414
11:49:55 <dmwit> But yeah, simplest is to just take a list instead.
11:50:55 <elliott> navaati: not really
11:51:48 <navaati> ok, because it's long to only get the darcs repo, so i'm a bit afraid ^^
11:52:22 <dmwit> darcs has never been known for its speed. =P
11:52:32 <elliott> navaati: something wrong with the hackage version?
11:52:33 <elliott> I'm no agda-er
11:53:46 <navaati> elliott : no, but the ebuild for gentoo gets the darcs sources
11:53:51 <elliott> ah
11:54:26 <navaati> this is annoying as i don't want a dev version
11:54:36 <elliott> just cabal install Agda-executable?
11:54:36 <navaati> is agda so young that it's in dev yet ?
11:54:43 <elliott> doesn't really matter if gentoo knows about it :P
11:54:45 <Mkman> can someone explain to me what does the weight and height does in the where in this code? http://dpaste.com/621474/
11:55:02 <Eduard_Munteanu> navaati: there's #agda btw
11:55:20 <Eduard_Munteanu> navaati: and no, it doesn't take a long time to build
11:55:34 <Eduard_Munteanu> Not even close to GHC anyway.
11:55:41 <dankna> blargh!
11:55:43 <dankna> too many MVars
11:55:53 <dankna> they really lead to deadlock rather easily :(
11:56:17 <navaati> Eduard_Munteanu: oh, sorry, i once heard agda talkings here so i thought it was the right place
11:56:32 <Axman6> Mkman: the where clause is defining a new function called bmi, which has parameters names height and weight
11:56:39 <Eduard_Munteanu> I suppose it's ok, I just hinted there was an Agda channel as well.
11:57:05 <Mkman> Axman6: oh thanks
11:57:36 <bfig> how would i define an instance of MonadReader? ie, 'instance MonadReader r m => MonadReader r (X m) where
11:57:59 <byorgey> bfig: looks good so far
11:58:01 <bfig> i know i have to define ask and local, but i don't know how i would make sense out of r, since i don't know what it is
11:58:27 <byorgey> bfig: r is the type of the "read-only state" or "environment" that is implicitly available
11:58:52 <bfig> how is it implicitly available? it is not evident at all
11:59:05 <byorgey> bfig: you can get it ant any time by calling 'ask'
11:59:10 <byorgey> *at any time
11:59:24 <bfig> but i need to define it, how can i define something in terms of something i haven't defined already
11:59:30 <elliott> bfig: what is X?
11:59:43 <bfig> elliott, it should be a monad... in my case a monadT
11:59:50 <bfig> (which is itself a monad of course)
11:59:51 <elliott> but what /is/ it
11:59:57 <byorgey> bfig: if you have an instance of  MonadReader r m   then you can use ask, local, etc.
12:00:00 <elliott> is there some specific X you are trying to write an instance for?
12:00:06 <fritschy> hey #haskell I have a small problem which defies my head getting around it... I have a alist with possible multiple values for each key, but as distinct tuples in the alist - have not yet discovered a way to build a map out of it. I'm reading Data.Map docs, but can't figure out how to get this working eith insertWith for example. Hints appreciated...
12:00:39 <bfig> yes, i want to write it for a 'Maybe' monad i defined, and it's maybe transformer
12:00:39 <Renze> i've got a questing about compiling; as I am trying to create an exe for 'simple' people to work with, i only get a .o file with 'ghc --make myfile.hs', am i doing anything wrong? (i work with windows 7, 64 bits)
12:00:49 <Axman6> well, you need to build a Map Key [Value] right?
12:00:53 <byorgey> fritschy: do you want the map to contain just a single value for each key? or multiple values?
12:01:25 <fritschy> byorgey: no, i need all of them... that's actually the problem of my thinking - i think
12:01:38 <bfig> can you give me a simple example of this?
12:01:43 <byorgey> Renze: perhaps you want  ghc --make -main-is myfile myfile.hs ?
12:01:45 <Axman6> fritschy: then you need something like Map Key [Value]
12:01:53 <fritschy> Axman6: exactly
12:01:54 <trinithis> Does myfile.hs have "main"?
12:02:23 <Axman6> then you use: foldl (\acc x -> insertWith (++) [x] acc) empty xs
12:02:26 <elliott> Yeah, Renze, it must be a Main module
12:02:29 <byorgey> @type Data.Map.insertWith
12:02:31 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
12:02:34 <elliott> So give no module declaration and define main or explicitly say module Main where ...
12:02:42 <byorgey> fritschy: in this case the 'a' in the type of insertWith is [Value]
12:02:42 <Axman6> or, whatever you need to do to put those arguments in the right order =)
12:02:57 <Axman6> :t foldl
12:02:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:03:11 <fritschy> byorgey: ack
12:03:16 <fritschy> foldl... darnit
12:03:19 <fritschy> ;)
12:03:32 <Axman6> foldl (\acc (k,v) -> insertWith (++) k [x] acc) empty xs
12:03:40 <rwbarton> or something like fromListWith (++) . map (\(key, val) -> (key, [val]))
12:03:40 <elliott> Has anyone mentioned you probably want foldl' yet?
12:04:06 <Renze> byorgey, elliott: thanks both :) works now!
12:04:56 <elliott> Renze: np :)
12:05:00 <byorgey> bfig: for example, suppose we have  data Identity m a = Identity (m a)
12:05:04 <Axman6> elliott: i'm not sure you do here. it really depends on how the map will be used later
12:05:16 <elliott> Renze: trinithis is the one who made me realise what your problem was though :)
12:05:23 <elliott> Axman6: Yeah, just parroting the party line :P
12:05:30 <byorgey> bfig: then we can write   instance MonadReader r m => MonadReader r (Identity m) where  ask = Identity ask
12:06:08 <byorgey> bfig: the 'ask' on the LHS is the one you are defining for Identity m.  The 'ask' on the RHS is the ask for m, which has already been defined
12:06:27 <byorgey> bfig: it looks recursive but it is not
12:06:50 <dmwit> sneaky Haskell
12:06:53 <byorgey> bfig: does that make any sense?
12:07:13 <bfig> byorgey, http://lambdaman.blogspot.com/2007/10/monadreader.html <- i'm reading this
12:07:23 <byorgey> type classes are awesome and sneaky.
12:07:31 <byorgey> bfig: let me take a look
12:07:33 <bfig> let me read this, absorb, go do something i need to do, then come back with more questions :)
12:07:42 <bfig> (i'll be back in about 3:30 hs
12:08:25 <byorgey> bfig: ok, I may or may not be around then, but I'm sure someone will =)
12:08:48 <fritschy> Axman6, byorgey: yes, foldl with the accumulator being the map and insertWith (++) does the trick. Thanks you
12:08:50 <bfig> thanks for the help so far :)
12:09:05 <byorgey> bfig: you're welcome =)
12:09:20 <TotoTitus> :t forever
12:09:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
12:09:28 <byorgey> fritschy: as elliott mentioned, you will want to use Data.List.foldl'  instead of foldl
12:09:45 <byorgey> fritschy: it is the same as foldl but stricter, so it leads to better memory usage
12:09:59 <byorgey> s/so it/and/
12:10:14 * edwardk waves hello.
12:10:23 <dmwit> hi!
12:10:26 <byorgey> hiya edwardk
12:10:45 <dmwit> What's new in Kmettland?
12:11:07 <edwardk> not too much. adding packrat parsing, gll, and a scannerless burke-fisher variant to trifecta
12:11:22 <edwardk> and simplifying a bunch of the error handling code
12:11:33 <byorgey> is a burke-fisher anything like a kingfisher?
12:11:58 <ciaranm> no, it's a chess match
12:12:21 <edwardk> burke-fisher is a global error correction strategy for GLR, LR, LL, GLL, etc. style parsers
12:12:28 <edwardk> ciaranm: hah
12:12:45 <fritschy> byorgey: I am aware of strict insertWith and foldl :) but I really need some more fold exercises.
12:12:45 <byorgey> hehe
12:12:55 <byorgey> edwardk: sounds awesome
12:13:26 <byorgey> edwardk: did I hear you say something about your parsing library being useful for indentation-aware parsing?
12:13:31 <fritschy> darnit, brb
12:13:49 <edwardk> i don't think burke ever played fischer actually ;)
12:14:06 <edwardk> byorgey: yeah there is a parser transformer for adding layout
12:14:08 <ciaranm> indentation-aware parsing discriminates against blind people. if you don't use braces you're worse than hitler.
12:14:24 <Nafai> eek
12:14:36 <byorgey> edwardk: nice
12:14:41 <Nafai> I didn't think about that :(  I'm going blind and the two languages I use the most use indentation significantly
12:14:57 <Botje> haskell supports braces just fine
12:14:59 <byorgey> edwardk: a while ago I tried writing an emacs .org parser with parsec and it ended up being really ugly
12:15:01 <DanBurton> @google python for the blind
12:15:03 <lambdabot> http://www.python.org/about/success/bats/
12:15:03 <lambdabot> Title: Python Success Stories
12:15:04 <edwardk> nafai: its not _terrible_ if you can use a braille term when you need to deal with fiddly indentation bits
12:15:22 <Nafai> edwardk: good to know
12:15:36 <edwardk> i actually spent the better part of 3 years working with blind users
12:15:43 <byorgey> Nafai: at least with Haskell, it would be easy to write a utility to parse some Haskell source and add explicit braces
12:15:45 <edwardk> which is funny since i went from that to 3d graphics ;)
12:15:50 <dankna> that IS funny
12:16:25 <tsousa> i am learning some recursion with haskell, where can i get some exercices on recursion to expand my knowloadge?
12:16:46 <fritschy> Haskell assimilation: I am in the work of assimilating 2 coworkers to learn haskell :D
12:16:52 <edwardk> tsousa: to get exercises for working with recursion, first you must get exercises for working with recursion.
12:16:53 <ciaranm> tsousa: try to reimplement map, fold etc
12:17:14 <Botje> tsousa: SICP has some nice exercises, but you will need to reinterpret them with proper tree datatypes first
12:18:01 <edwardk> byorgey: there is also a literate comment style parser transformer in there
12:18:07 <edwardk> byorgey: in case you like bird tracks
12:20:47 <byorgey> mmm, parser transformers
12:20:57 <byorgey> sounds all compositional and yummy
12:21:09 <edwardk> you can apply monad transformers to them as well
12:21:23 <byorgey> nifty =)
12:21:37 <TotoTitus> what is a parser transformer ?
12:21:43 <edwardk> i'm still working out some details but the intention is to port my c preprocessor as another parser transformer
12:21:51 <DanBurton> monads in disguise?
12:21:59 <dankna> more than meets the eye
12:22:06 <edwardk> DanBurton: they are all monad transformers as well, but they preserve additional structure
12:22:48 <edwardk> for instance one adds support for skipping comments in whitespace, etc.
12:23:12 <byorgey> TotoTitus: something that can be applied to a parser in order to produce another parser (with additional features, etc.)
12:23:16 <edwardk> i may reduce my dependence on them slightly because they tend to pile up lots of state outside of the main monad, but so far they are at least convenient
12:23:44 <edwardk> DanBurton: the transformer reference finally clicked.
12:23:46 * edwardk headdesks
12:24:18 <byorgey> hahaha
12:25:10 <edwardk> some things i was hoping to add as transformers have had to become different base monads or stream types. (like packrat support)
12:25:28 <byorgey> autoparsers, transform and Roll (f (Mu f)) !
12:25:58 <edwardk> and i have yet to figure out how to fit gll parsing into the same framework as my main parsers because they parse full CFGs and (<|>) has very different semantics
12:37:22 <bahblah> in learn you a haskell for great good, it says that because of haskell's laziness filtering or mapping multiple times over a list will go over the list only once
12:37:27 <Philippa> edwardk: to my great annoyance, I think my typecheckers need at least arrows :-(
12:37:39 <Botje> bahblah: yes, the various passes will be combined
12:37:41 <elliott> :t (((<$>)<$>(,))<*>)
12:37:42 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> a1 -> f (a1, a)
12:37:43 <edwardk> ?
12:37:49 <bahblah> i'm not sure how laziness makes that possible
12:37:56 <Philippa> (great annoyance because arrows are a PITMFA to actually work with when you're not just using the -> instance
12:37:59 <Philippa> )
12:38:12 <Philippa> was hoping to get by with just an applicative
12:38:33 <edwardk> bahblah: filter even [1..] -- hasn't gone through and filtered the list yet, its when you look at it that filter finds the next element that matches the predicate
12:38:35 <Philippa> but the interaction between a name supply and a writer full of constraints makes that not quite pan out
12:39:30 <Cale> bahblah: The way to understand it is to calculate :)
12:39:48 <Philippa> I mean, the "good" news is that writing them in terms of arrows is likely to "prove" a bunch of properties for free still, but right now I'm just saying sod it and writing the monadic versions
12:39:52 <bahblah> Cale: any simple examples?
12:40:14 <edwardk> similarly with map, so if you map (`div` 2) (filter even [1..]) when the head element is demanded map will demand one from the filter and filter will go through the original list, find one that matches even
12:40:18 <Cale> Let's try...  map (*2) (filter even [0..])
12:40:25 <edwardk> hah
12:40:25 <Cale> @src map
12:40:26 <lambdabot> map _ []     = []
12:40:26 <lambdabot> map f (x:xs) = f x : map f xs
12:40:31 <Cale> @src filter
12:40:31 <lambdabot> filter _ []     = []
12:40:32 <lambdabot> filter p (x:xs)
12:40:32 <lambdabot>     | p x       = x : filter p xs
12:40:32 <lambdabot>     | otherwise = filter p xs
12:40:39 <edwardk> i'll let cale run with this one ;)
12:40:44 <hpc> damn my phone Cale, that was what i was going to say
12:40:58 <Cale> wow, we almost picked the exact same example. I was even considering (`div` 2)
12:41:17 <Cale> okay
12:41:24 <Cale> So first thing to do is apply map
12:41:30 <Cale> but map needs to pattern match
12:41:39 <Cale> (remember, lazy evaluation is outermost-first)
12:41:45 <bahblah> Cale: i was thinking more of quicksort where you filter lesser than pivot and greater than pivot
12:41:50 <shachaf> map (double . double) (fitler even [5..])
12:42:10 <hpc> bahblah: quicksort in haskell isnt really quicksort
12:42:19 <bahblah> !
12:42:22 <Cale> so, because map needs to pattern match on the list, and because filter even [0..] isn't in the form [] or (x:xs) yet, we need to evaluate it
12:42:25 <bahblah> ?*
12:42:26 <lambdabot> Maybe you meant: . ? @ v
12:42:46 <bahblah> how is it not quicksort?
12:42:47 <byorgey> blackdog: if you have two separate calls to filter, they probably are not combined into one traversal.
12:42:56 <hpc> bahblah: linked list stuff fucks with the complexity of the algorithm
12:42:59 <byorgey> er, blahblah, sorry
12:43:03 <hpc> it runs too slow
12:43:04 <Cale> and filter needs to pattern match too, so we evaluate [0..] by one step to get 0:[1..]
12:43:33 <shachaf> hpc: Well it is quicksort if it's actual quicksort.
12:43:35 <Cale> and then filter even (0:[1..]) = 0 : filter even [1..], because even 0 is True
12:43:43 <shachaf> s/ll/ll,/
12:43:48 <bahblah> so in the case of quicksort are the two filters combined?
12:43:53 <bahblah> or not
12:43:53 <Cale> bahblah: no
12:43:56 <bahblah> ok
12:43:58 <Cale> bahblah: But they can be
12:44:03 <Cale> if you use partition
12:44:14 <bahblah> yeah i see
12:44:31 <bahblah> but it seemed like black magic if haskell could combine them
12:44:37 <bahblah> so i came on here to ask
12:44:47 <Axman6> bahblah: unless you write your partition function not using filter, you will traverse the list twice in the usual 'quicksort' example
12:44:57 <Cale> > let qsort [] = []; qsort (x:xs) = qsort less ++ [x] ++ qsort greater where (less,greater) = partition (< x) xs in qsort "Hello there"
12:45:01 <lambdabot>   mueval-core: Time limit exceeded
12:45:21 <Cale> errr
12:45:24 <Axman6> o.O
12:45:25 <bahblah> iget that they can be combined not using filter
12:45:28 <d34df00d> Hi!
12:45:33 <Axman6> i think you need the [x] case too
12:45:34 <Cale> > let qsort [] = []; qsort (x:xs) = qsort less ++ [x] ++ qsort greater where (less,greater) = partition (< x) xs in qsort "Hello there"
12:45:37 <lambdabot>   " Heeehllort"
12:45:37 <bahblah> and that filters can be combined
12:45:48 <Cale> It was just random slowness on the lambdabot server
12:45:48 <d34df00d> I'm trying to use Numeric.FAD to get jacobian for a function expressed as a (homebrewn) tree.
12:45:53 <DanBurton> @botfeed
12:45:53 <lambdabot> Unknown command, try @list
12:45:56 <Cale> (that code is correct)
12:45:56 <DanBurton> doh
12:45:58 <DanBurton> forgot again
12:46:09 <bahblah> it just boggled my mind if haskell could automatically combine the two filters in quixksort
12:46:14 <Axman6> DanBurton: snack
12:46:19 <d34df00d> The function evaluating the tree takes the values of the variables as a set of Doubles.
12:46:45 <Cale> bahblah: But what *will* happen is if you do  filter p . filter q $ xs  it'll automatically be transformed into  filter (\x -> q x && p x) xs
12:46:51 <DanBurton> @botsnack
12:46:51 <lambdabot> :)
12:46:52 <DanBurton> yay
12:46:57 <d34df00d> Though FAD passes 'Dual tag Double', and how do I supposed to pull that Double out of it?
12:47:01 <bahblah> Cale: i understand that
12:47:04 <Cale> bahblah: That's not by laziness, but an explicit rewriting rule specified in the library
12:47:13 <d34df00d> That's a newtype, and the original Tower ctor is hidden in FAD impl.
12:47:16 <Cale> though, laziness does get you most of the way there
12:47:22 <bahblah> ic
12:47:27 <Cale> in that the list can already be processed one element at a time in any case
12:47:30 <Axman6> i believe you get that sort of behaviour for free if you use supercompilation
12:47:41 <Axman6> hmm, maybe not that specific one
12:47:47 <Cale> (it's just that the intermediate cells which are almost immediately garbage can be avoided in the first place)
12:47:50 <bahblah> i was mostly interested in the two filter in quicksort case
12:48:38 <Axman6> bahblah: it would be possible to implement an optimisation like that, but it would not be very general purpose i think
12:48:56 <d34df00d> So, well, to sum it up: how to pull a Double out of 'Dual tag0 Double' and pass it to a function in existing code eating doubles?
12:48:57 <Cale> d34df00d: realToFrac perhaps?
12:49:15 <bahblah> so does is debugging in haskell hard because of laziness where something blows up way later when it finally gets evaluated?
12:49:35 <Axman6> bahblah: it can be difficult, yes
12:49:38 <Cale> bahblah: Well... kinda
12:49:52 <d34df00d> Cale: hm, thanks, that gets me to next type error :)
12:50:00 <Cale> bahblah: There's also generally a lot less of it to do.
12:50:02 <Axman6> but, when things blow up, you come to us and we show what you're doing wrong ;)
12:50:11 <Cale> bahblah: and referential transparency makes things easy
12:50:12 <bahblah> lol
12:50:12 * d34df00d tried different to* and from* functions and forgot about realToFrac :(
12:50:14 <DanBurton> > take 10 qsort . reverse $ [1.1000]
12:50:15 <lambdabot>   Not in scope: `qsort'
12:50:50 <davidt_> Hi all. Is anyone aware of an existing IRC server written in Haskell?
12:51:32 <Cale> bahblah: In most other languages, the result of computing something can depend on the precise state that the system is in, and most of what's tricky about debugging is making sure that this surrounding state is just right to cause the bug, and ensuring that the effects that the computation had on that state are just the right ones.
12:51:33 <zachk> > take 10. sort . reverse $ [1..100]
12:51:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:51:49 <bahblah> Cale: right
12:51:54 <d34df00d> Hm, BTW, could anyone explain the error message http://paste.pocoo.org/show/482935/ ?
12:51:57 <Cale> (perhaps by copying parts of that state beforehand and making sure that it changed in the right way)
12:52:02 <d34df00d> Or, at least, point me to a good explanation :)
12:52:03 <Cale> In Haskell, you don't have that problem
12:52:08 <Cale> (for the most part)
12:52:31 <bahblah> so you can reproduce bugs easily in haskell
12:52:36 <bahblah> but once you do
12:52:42 <Axman6> davidt_: hmm, i seem to remember someone writing one, that used SSL, for use internal to their company. might have been chris done
12:52:47 <bahblah> what's the general process like?
12:52:48 <Cale> d34df00d: It's saying that your type signature says something is completely polymorphic (type a), but it's actually a Dual thing
12:53:31 <Cale> bahblah: Break the thing down into smaller parts until you have a piece which is either obviously wrong, or the problem magically goes away because the parts are too simple to be incorrect anymore.
12:53:48 <Axman6> bahblah: you read your code and find the bug :P
12:54:09 <davidt_> Axman6: Great found it! thanks
12:54:32 <d34df00d> Cale: ah, ok. And why it's an error?
12:54:39 <Axman6> davidt_: are you the GHC LLVM David T.?
12:54:49 <d34df00d> Shouldn't the type inference engine then assume that it's a Dual thing, or smth like that?
12:55:19 <Cale> d34df00d: Because the type signature says the caller is allowed to provide/demand any type a, but the function can't handle any type, it can only handle Dual something Double values.
12:55:32 <BrianHV> I'm trying to compile a module with ghc -c -no-hs-main Doubler.hs and it's still saying The function `main' is not defined in module `Main'. what am I missing?
12:55:43 <d34df00d> Hm, that makes sense, thanks.
12:55:55 <Cale> d34df00d: When you provide a type signature, it can't be more polymorphic than the actual code.
12:55:56 <bahblah> with laziness doesn't it take up a lot more memory?
12:56:13 <Cale> bahblah: It can also take a lot less memory
12:56:25 <d34df00d> Yeah, that's a good and reasonable restriction.
12:56:26 <bahblah> ahh right
12:56:45 <Axman6> d34df00d: s/reasonable/sane
12:56:59 <d34df00d> Thanks :)
12:57:01 <Axman6> the alternative would be... disasterous i think
12:57:09 <d34df00d> English is not my strong point :)
12:57:17 <Cale> I think 'reasonable' was fine
12:57:43 <d34df00d> And FAD doesn't work with my trees, oh. Incorrect results.
12:57:47 <Axman6> yeah, reasonable was perfectly correct, but i was making the point that having it any other way would be madness =)
12:57:50 <Cale> It would be plausible to allow providing type constraints in the other direction too.
12:58:37 <Cale> Like, you could say   foo <:: a -> a  or something, and it would just mean that foo is a function from some type to itself, but allow type inference to constrain it the rest of the way
12:58:51 <Cale> But yeah, it doesn't do that :)
12:59:14 <bahblah> so what's going to blow my mind the hardest in haskell, the type system, monads, or ?? (the syntax has already blown my mind ;) )
12:59:39 <d34df00d> Immutability, for me.
12:59:45 <bahblah> i have a bit of fp experience so far mind not in million pieces
12:59:48 <ben> iteratees
12:59:49 <d34df00d> Makes me think quite the other way as I used to in C++ or such.
12:59:52 <Cale> Monads probably won't really. They're a little overhyped. It's just a simple pattern that a bunch of libraries fall into.
13:00:35 <bahblah> d34df00d: already familiar with immutability from a bit of clojure
13:00:40 <bahblah> :p
13:00:49 <bahblah> but yeah it is awesome
13:00:58 <Axman6> bahblah: probably in that order, the type system, monads, more monads, oh my god, even more amazing monads, MONAD TRANSFORMERS!?!??? iteratees... hmm, i'll try learning iteratees again... nope... ok, one last time... HOLY CRAP ITERATEES ARE AWESOEM
13:01:00 <dsouza> bahblah: actually monads were kind of hairy for me at first (haskell was my first functional language)
13:01:16 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p * p <= n) $ primes in primes
13:01:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:01:40 * Cale is not impressed by iteratees
13:01:47 <Axman6> Cale: for moar speed, use ram :P
13:01:55 <Axman6> rem*
13:02:02 <bahblah> what are iteratees
13:02:02 <shachaf> rember
13:02:11 <shachaf> @google what are iteratees
13:02:12 <lambdabot> http://en.wikipedia.org/wiki/Iterator
13:02:12 <lambdabot> Title: Iterator - Wikipedia, the free encyclopedia
13:02:14 <shachaf> Aw.
13:02:15 <Axman6> Cale: i think they need better syntax, and better naming
13:02:22 <Axman6> you suck google
13:02:22 <shachaf> @google what are +iteratees
13:02:23 <lambdabot> http://stackoverflow.com/questions/3788853/what-makes-iteratees-worth-the-complexity
13:02:23 <lambdabot> Title: haskell - What makes Iteratees worth the complexity? - Stack Overflow
13:02:26 <Cale> bahblah: A mechanism for doing lazy stream I/O.
13:02:29 <elliott> iterIO is the first iteratee package I liked.
13:02:46 <Axman6> Cale: i thought they were an alternative to lazy IO
13:02:57 <elliott> I never liked the seemingly-arbitrary iteratee/enumerator/enumeratee distinction, so I really liked how iterIO unified them.
13:03:06 <ben> Cale: I would not say impressed as much as that I am utterly overwhelmed
13:03:09 <Cale> Well, they don't rely on lazy evaluation, but they're "lazy" in a sense.
13:03:29 <Axman6> elliott: yeah, i thought it looked quite good. still hasn't solved the naming issue though. I feel using names like Producer, Transformer and Consumer (or, something similar but better) would make it easier to grok
13:03:51 <dolio> Incremental might be a better word.
13:03:58 <elliott> Axman6: meh, Inum/Onum/Iter are at least consistent, imperfect sure but "monad" doesn't mean much either :)
13:04:16 <Cale> ben: Yeah, and the fact that you can be overwhelmed is probably the same reason why I'm not impressed. I think that a good solution to the problem that iteratees solve should look simple externally, and all the iteratee libraries I've seen do not have impressively simple type signatures.
13:04:19 <elliott> and the fact that there's just one piping operator plus the monadic stuff instead of like twenty is nice too :P
13:04:33 <mysticc> How to debug a haskell program ??
13:04:42 <Axman6> with ghci
13:04:50 <Cale> and most of the iteratee code I've seen has been ugly and too focused on chunks
13:04:51 <DanBurton> define "haskell program"
13:04:54 <Clint> if i pass a Ptr to a c function which modifies it, how do i get the new value of the pointer?
13:04:56 <Axman6> and also keeping your functions small
13:04:57 <saml> web scale
13:04:59 <elliott> Cale: Not to sound like a broken record but I've found iterIO's types to be very simple in practice. I mean, Inum might look slightly messy, but that's just because it avoids rank two types.
13:05:07 <elliott> (Otherwise it's just be "Inum in out m".)
13:05:11 <ben> The enumerator library has really confused with all its combinators and funny types :<
13:05:22 <Axman6> Clint: modifies what, the data pointed to by the pointer?
13:05:23 <mysticc> DanBurton: Any haskell application ..
13:05:26 <elliott> And personally none of my code talks about chunks at all.
13:05:34 <DanBurton> mysticc: I assume you have a particular one you'd like to debug?
13:05:41 <Axman6> cqbecause Ptr in haskell is just a C pointer to a region of memory really
13:05:45 <Cale> mysticc: How to debug a python program?
13:06:01 <elliott> How to debug a bug?
13:06:11 <Axman6> bug spray
13:06:15 <elliott> Thanks
13:06:17 <DanBurton> mysticc: start by solving all of your type errors. Then there's an 80% chance that it works correctly ;)
13:06:17 <mysticc> I wanted to ask about any debugger
13:06:19 <waern> Cabal question: I have a "hs-source-dirs: tests/html-tests" entry in my test-suite stanza. When I do 'cabal upload' I get: 400 Error in upload
13:06:20 <ski> Cale : if `_a' syntax is used for non-generalized type variables, it could be `foo :: _a -> _a' then. this would allow one to also specify that other tyvars must be general (one could alternatively use `forall', of course)
13:06:22 <waern> 'hs-source-dirs: tests/html-tests' directory does not exist.
13:06:30 <waern> anyone knows what's going on?
13:06:31 <Cale> ski: yeah
13:06:42 <Clint> Axman6: like void change_this_pointer_to_somewhere_else(void *p);
13:06:44 <DanBurton> mysticc: I don't know of any step-by-step debuggers for Haskell
13:06:45 <Axman6> mysticc: ghci has a debugger, but pretty much no one uses it, because there's not much need
13:06:57 <DanBurton> Axman6: oh? how does it work?
13:07:03 <mysticc> DanBurton: I have corrected the type errors .. I want to find out when it goes in an infinite recursion ..
13:07:04 <Cale> People mean a lot of different things when they say "debugger"
13:07:15 <Axman6> Clint: i'm not sure what you mean there. you can only change the data pointed to by that pointer using that function
13:07:40 <Clint> Axman6: oh, right
13:07:42 <Axman6> DanBurton: ghci's debugger is step by step, as well as other things
13:07:57 <DanBurton> mysticc: you could throw it on hpaste.org and we can help you
13:08:06 * ski should try to get more familiar with Buddha
13:08:10 <DanBurton> @google ghci debugger
13:08:12 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
13:08:12 <lambdabot> Title: 2.5.�The GHCi Debugger
13:08:28 <ski> @where buddha
13:08:28 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
13:08:42 <ski> ^ declarative debugger
13:08:51 <Cale> mysticc: It's usually enough to just load the code up in ghci and start applying functions to values, and seeing if you get reasonable output. Since they can't behave differently in context from how they behave for you in GHCi, you can understand and examine the behaviour of parts of your program in that fashion.
13:09:19 <d34df00d> Cale: hm, that works from the type system aspect, but fails to work as expected.
13:09:41 <Cale> If you're having trouble isolating examples where some property breaks, you can use QuickCheck, which is an automated testing library. You pass quickCheck a boolean property of some parameters, and it will try to find parameters for which the property is False.
13:09:45 <d34df00d> http://paste.pocoo.org/show/482942/
13:10:04 <d34df00d> I guess it messes up with the tags used by the FAD.
13:10:36 <Cale> d34df00d: I am almost entirely unfamiliar with this library
13:10:52 <d34df00d> Oh :(
13:11:07 <Cale> Dual tag a is a numeric type, so you can just use numeric literals and have them be that type though
13:11:38 <ski> mysticc : you might find declarative debugging (see above) interesting ..
13:11:38 * DanBurton muses over the choice of naming the declarative debugger "buddha"
13:11:39 <d34df00d> Cale: yep, but my function for evaluating tree takes doubles and returns doubles.
13:11:44 <d34df00d> I guess that'd break that code.
13:12:22 <Cale> d34df00d: I think the point of this library is to provide a numeric type on which derivatives can be computed automatically based on the computations which were done on the numbers.
13:12:36 <Cale> d34df00d: So if you convert back and forth, you lose that information.
13:13:05 <Cale> (which explains the zero derivative you're getting)
13:13:30 <d34df00d> Yes, I think so as well.
13:14:06 <Cale> Thankfully, this Dual type provides almost all the same functions as Double does, so perhaps you can just generalise your code to work on arbitrary Fractional/RealFloat types?
13:14:13 <d34df00d> But I can't think of a way to combine my already existing Double-based code with that Num thinks.
13:14:16 <mysticc> ski: its not on cabal?
13:14:18 <Cale> (perhaps you'd like to hpaste it?)
13:14:34 <d34df00d> Cale: oh, the code is available publically, but there is a lot of. And it's noobish :)
13:14:49 <Cale> That's okay, I'll have a quick look if you want
13:15:01 <KirinDave> So what is the popular/preferred toolkit to write GUI apps for Linux in haskell
13:15:03 <d34df00d> Ok, let me commit the last version.
13:15:04 <d34df00d> Thanks :)
13:15:06 <Cale> Why is it using Double specifically?
13:15:20 <Cale> If you remove all the type signatures, does type inference get Double?
13:15:30 <quackquack> In haskell, is there any way to create an interval? like, in ruby `[0..5]` would expand to `[0,1,2,3,4,5]`
13:15:36 <Cale> > [0..5]
13:15:37 <lambdabot>   [0,1,2,3,4,5]
13:15:47 <Cale> > [0,2..10]
13:15:48 <lambdabot>   [0,2,4,6,8,10]
13:15:48 <merijn> quackquack: Surprise, that works :p
13:15:49 <KirinDave> quackquack: It's almost like someone inspired both languages. :)
13:15:52 <Cale> > [0,2..]
13:15:53 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
13:15:55 <KirinDave> Haha
13:15:56 <Cale> > [0..]
13:15:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:16:03 <KirinDave> Do that in ruby.
13:16:29 <d34df00d> Cale: see, the code in question is in https://github.com/0xd34df00d/gennl/blob/master/hs/ExprTree.hs
13:16:37 <Cale> > ['a'..'z']
13:16:38 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
13:16:43 <d34df00d> Particularly, lines 101-111.
13:16:43 <Cale> > ['a','c'..'z']
13:16:44 <lambdabot>   "acegikmoqsuwy"
13:16:45 <merijn> let fibonacci = 0 : 1 : zipWith (+) fibonacci in fibonacci
13:16:45 <quackquack> Thank! can it be done with an interval other than 1?
13:16:57 <merijn> > [1,5..10]
13:16:58 <lambdabot>   [1,5,9]
13:17:01 <Cale> > [13,17,..100]
13:17:02 <lambdabot>   <no location info>: parse error on input `..'
13:17:05 <Cale> > [13,17..100]
13:17:06 <lambdabot>   [13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97]
13:17:17 <d34df00d> Cale: but it's also used, for example, in https://github.com/0xd34df00d/gennl/blob/master/hs/Genetic.hs (38-44 and a lot of other places).
13:17:59 <ski> mysticc : apparently not .. (i hadn't checked buddha in a long time, the talk about debugging brought it to mind)
13:18:14 <Cale> d34df00d: Well, the automatic differentiation stuff will obviously hate the random number generator :)
13:18:15 <KirinDave> Do people just hold their nose and use the GTK+ bindings?
13:18:16 <KirinDave> or
13:18:26 <KirinDave> Is there some cool gtk-bound FRP library?
13:18:40 <Cale> (if there's any interaction there...)
13:18:48 <ski> mysticc : there's also a (much simpler, but slightly related) <http://hackage.haskell.org/package/hood> on hackage
13:18:51 <d34df00d> Cale: hm, there is obviously some.
13:18:59 <d34df00d> Or not... Let me check.
13:19:00 <ski> (mysticc : itym s/on cabal/on hackage/)
13:19:32 <sm> hey all. How come writeFile doesn't do the automatic unix/windows line end conversion that openFile/hPutStr/hClose does ?
13:19:50 <d34df00d> Well, I hardly feed values from the random generator to the 'compute' function from the typeclass.
13:19:59 <Cale> d34df00d: Your ExprTrees though don't look very specific to Double :)
13:20:03 <Axman6> KirinDave: because you haven't written something better yet
13:20:11 <KirinDave> Axman6: ??
13:20:12 <d34df00d> So I guess that'd work.
13:20:28 <Axman6> KirinDave: oh, i added a 'Why' to the beginning of your sentense =)
13:20:31 <Cale> d34df00d: So instead of using that  type Const = Double
13:20:37 <Cale> make it:
13:20:41 <KirinDave> Axman6: No no no. I just want to know if that is what people are doing.
13:20:49 <d34df00d> Cale: yep, but could I just replace that Doubles with a and '(RealFrac a) =>' in front of signatures?
13:20:50 <Cale> data ExprTree a = ... | LeafConst a
13:20:52 <KirinDave> If that is what one does in #Haskell-Rome, I will do it.
13:21:00 <d34df00d> Cale: ok, thanks, I'd try now.
13:21:05 <Cale> and see where it complains, and adjust types accordingly
13:21:21 <Cale> and if you succeed you'll be about to use Dual instead.
13:21:24 * d34df00d loves strongly-typed languages for that ease of somewhat-refactoring.
13:21:25 <Cale> able*
13:21:44 <EvanR-work> i find it easy to fundamentally rewrite the core of the code
13:21:46 <Cale> yes, it's nice to just make some breaking change and then hammer away at it with the compiler
13:22:05 <Cale> and then have it all work once it compiles again :)
13:22:15 <d34df00d> Cale: hm, also, since I've already shown you my code, there is one more question :)
13:22:20 <mreh> I can see fmap_a1yM in my profiling, how can I track that to actual code?
13:22:38 <KirinDave> This looks interesting http://kevin.atkinson.dhs.org/fg/doc/FG.html
13:22:41 <d34df00d> See ExprTree.hs 113-121 and maybe 126.
13:22:45 <Axman6> mreh: do you have the call tree view?
13:22:53 <d34df00d> Also, Genetic.hs 186-199.
13:22:58 <Cale> People think static type systems are restrictive, but they actually let you get away with not thinking about types. :)
13:23:22 <mreh> Axman6, yeah, there are multiple fmaps on the same level, are they in ordered?
13:23:26 <mreh> order*
13:23:30 <Cale> d34df00d: okay
13:23:31 <d34df00d> I see somewhat common pattern there, especially with, for example, choosing the right node to operate upon, but I was unable to make something fold-style for that, or smth like that.
13:23:32 <shachaf> Cale: They *are* restrictive.
13:23:35 <KirinDave> Oh, and THIS one is even documented
13:23:37 <KirinDave> http://www.haskell.org/haskellwiki/Grapefruit
13:23:40 <d34df00d> What's the good way of doing that?
13:23:42 <EvanR-work> Cale: well, in practice people dont assign enough meaning to the data in the first place, so they werent thinking about the types
13:23:46 <shachaf> Cale: Which is in some cases helpful and in some cases not.
13:23:51 <EvanR-work> leading to trainwrecks
13:24:01 <Axman6> mreh: ah, not cool. i'm not sure. try adding cost centres
13:24:13 * shachaf wants a general purpose (\x y -> x (x y)) function!
13:24:17 <EvanR-work> haskell forces you to assign meaning to data
13:24:20 <Axman6> {-# SCC "fmap1" #-} fmap foo bar
13:24:43 <Cale> d34df00d: Just trying to understand what this does...
13:24:48 <d34df00d> I was stopped by the thought that I'd most likely still need to pass all the child nodes to the "step function", and seems like I won't get that much code reduced.
13:25:08 <d34df00d> Cale: one replaces a node by the given index (like in BFS "discovered index") to another node.
13:25:24 <d34df00d> Cale: other returns subtree starting from the node, once again, by its index.
13:25:26 <d34df00d> Etc.
13:25:43 <d34df00d> Oh, sorry, s/BFS/DFS/
13:25:54 <quackquack> How would i generate an interval list like this: [3.25, 3.5, 3.75 (and so on)]
13:26:06 <Cale> > [3.25, 3.5 ..]
13:26:07 <lambdabot>   [3.25,3.5,3.75,4.0,4.25,4.5,4.75,5.0,5.25,5.5,5.75,6.0,6.25,6.5,6.75,7.0,7....
13:26:37 <quackquack> Wo.. haskell knows its stuff
13:26:50 <Cale> (that list is infinite btw)
13:27:21 <EvanR-work> unless youre a finitist
13:27:21 <shachaf> > [3.25,3.5 .. 3.9]
13:27:22 <lambdabot>   [3.25,3.5,3.75,4.0]
13:27:28 <Axman6> quackquack: if you've been impressed by ruby, you've mind is about to be blown by haskell
13:27:46 <Cale> shachaf: That's a bug in the standard unfortunately.
13:27:55 <Cale> shachaf: Well depending on how you look at it
13:28:03 <rwbarton> no it's not, grr
13:28:05 <cheater> how does the bug work exactly?
13:28:13 <Cale> Personally, I think [a, b .. c] should never contain any element larger than c
13:28:19 <Axman6> @src enumFromThenTo
13:28:20 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:28:20 <shachaf> Double being Enum is a bug in the standard. :-)
13:28:22 <Axman6> :(
13:28:22 <cheater> oh that is what you mean
13:28:23 <cheater> well
13:28:29 <Cale> Nah, Double can be Enum
13:28:40 <cheater> the thing is in order to generate such a list the element larger than c has to be generated always
13:28:43 <Axman6> Cale: me too, i can't think of a case where you'd ever want that
13:28:45 <shachaf> > [1.0,1.1..2.0]
13:28:47 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
13:28:47 <cheater> so you're generating an element and then throwing it away
13:28:48 <rwbarton> what???
13:28:51 <cheater> that's not a cool thing
13:28:56 <d34df00d> Cale: hm, and why my code worked at all?
13:29:03 <quackquack> Axman6: yeah, im coming from ruby.. functional programming is _amazing_
13:29:20 <d34df00d> Ah, sorry, messed Floating with Float :)
13:29:26 <Axman6> floating point is much less amazing -_-
13:29:56 <EvanR-work> use the floating isnt enum extension
13:29:58 <rwbarton> > let s = sum $ map (^2) [1.0,1.1..2.0] in (s :: Double, realToFrac (s :: Rational) :: Double)
13:29:59 <hpaste> tgeeky pasted “minfree from Bird” at http://hpaste.org/51812
13:29:59 <lambdabot>   (25.850000000000016,25.85)
13:30:03 <Cale> cheater: That's not a problem
13:30:10 <rwbarton> do you really want that first answer to be 21.85?
13:30:22 <Axman6> > map (show . (^1024)) [1..]
13:30:23 <lambdabot>   ["1","179769313486231590772930519078902473361797697894230657273430081157732...
13:30:39 <Axman6> > map (show . (^1024)) [1..] !! 100
13:30:41 <lambdabot>   "26612566117305021291272917047288038406483651534987212580975791224181509109...
13:30:53 <Axman6> > length (map (show . (^1024)) [1..] !! 100)
13:30:55 <lambdabot>   2053
13:30:58 <tgeeky> can someone take a look at ^^, and let me know how to proceed? It's a verbatim copy from Bird's book...
13:31:18 <shachaf> > fmap fmap fmap fmap fmap show (^1024) [1..]
13:31:20 <lambdabot>   ["1","179769313486231590772930519078902473361797697894230657273430081157732...
13:31:25 <Cale> tgeeky: n  div  2
13:31:33 <Cale> tgeeky: that div should be in backticks
13:31:40 <Cale> n `div` 2
13:31:48 <tgeeky> Cale: gah. I had it that way to start :/
13:31:54 <tgeeky> Cale: thanks.
13:31:57 <Axman6> tgeeky: i doubt it, you need `'s around div
13:32:05 <Axman6> bleh, beaten
13:32:19 <tgeeky> i deleted them because it broke syntax highlighting :/
13:32:29 <Axman6> :\
13:32:38 <Cale> What editor?
13:32:51 <Axman6> that's because the syntax highlighter in your editor is broken, not because the syntax is wrong :P
13:32:59 <tgeeky> Cale: gvim windows
13:33:05 <merijn> > 10 `div` 2
13:33:05 <Axman6> though, if you user 'div' instead of `div` then that would likely happen
13:33:06 <lambdabot>   5
13:33:09 <Cale> okay, that's odd
13:33:10 <merijn> > 10 div 2
13:33:10 <lambdabot>   10
13:33:17 <Cale> I use gvim on linux and it's fine.
13:33:18 <merijn> oh, duh
13:33:19 <tgeeky> i knew div should be in backticks...
13:33:27 <tgeeky> anyway, back to it
13:33:30 <merijn> Silly numbers as functors
13:33:35 <Cale> merijn: hehehe
13:33:39 <Cale> As functions*
13:33:54 <Cale> Or really, functions as numbers
13:33:57 <d34df00d> Cale: also, what's better? Adding type requirements to the functions using 'ExprTree a' or the ExprTree declaration itself?
13:34:08 <Cale> d34df00d: You have to have the type parameter
13:34:13 <d34df00d> I guess the former, but maybe I'm missing it.
13:34:30 <d34df00d> Cale: hm, surely, and I do, in the ExprTree :)
13:34:32 <Cale> I guess you could change ExprTree so that it uses Dual numbers instead
13:34:43 <sheyl> hi
13:34:45 <Cale> and not have a type parameter
13:34:56 <Cale> but you can't make it polymorphic if you don't have a parametric type there
13:34:56 <Axman6> hmm, just started reading a paper... got scared when i realised it was written by Oleg :(
13:35:04 <Cale> sheyl: hello
13:35:13 <merijn> Axman6: Oleg isn't *that* bad, right?
13:35:13 <d34df00d> Hm.
13:35:15 <sheyl> hello Cale
13:35:23 <merijn> The iteratee paper seemed very readable anyway
13:35:27 <Axman6> merijn: he can be pretty bad...
13:35:38 <d34df00d> I think it's better to try to make it polymorphic, so that further changes to type requirements won't require me to rewrite some code, isn't it?
13:35:45 <Axman6> not sure i've read the iteratee paper. if i have, i took nothing away from it
13:35:56 <merijn> Axman6: What's he score on a scale of 0 to McBride? :>
13:36:07 <Axman6> no idea
13:36:14 <Cale> d34df00d: I think so
13:36:33 <xivix> okay, so i'm new to haskell
13:36:44 <zmv> nice
13:36:49 <xivix> and I cannot for the life of me get my head around how Wikipedia defines an infinite list of fibonacci numbers
13:37:08 <xivix> is there any good tools to allow you to step through lazy evaluation?
13:37:10 <xivix> or something?
13:37:28 <merijn> xivix: How does wikipedia define it?
13:37:33 <d34df00d> Also, is there a way to declare a synonim for a set of requirements?
13:37:38 <xivix> the definition of the infinite list is:  fibs = 0 : scanl (+) 1 fibs
13:37:52 <d34df00d> I've tried declaring 'class SuitableConst a' and then 'instance (Fractional a, Random a, Ord a) => SuitableConst a'
13:37:52 <Cale> d34df00d: not yet, but they're coming :)
13:38:11 <d34df00d> But it comlains "Constraint is no smaller than the instance head".
13:38:16 <d34df00d> s/coml/compl/
13:38:22 <shachaf> @google constraint kinds
13:38:23 <Axman6> xivix: i think the zipWith version is a bit easier to understand
13:38:24 <lambdabot> http://blog.omega-prime.co.uk/?p=127
13:38:24 <lambdabot> Title: Constraint Kinds for GHC | :: (Bloggable a) => a -> IO ()
13:38:25 <Cale> Oh, yeah, you can do that
13:38:27 <merijn> xivix: scanl is confusing imo
13:38:33 <merijn> xivix: I prefer
13:38:40 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
13:38:40 <d34df00d> Cale: and what the error means?
13:38:41 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:38:42 <merijn> > let fibonacci = 0 : 1 : zipWith (+) fibonacci (tail fibonacci) in fibonacci
13:38:43 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:38:45 <merijn> damn
13:38:50 <merijn> Too slow
13:38:51 <Axman6> snap
13:38:56 <Cale> class (Fractional a, Random a, Ord a) => SuitableConst a
13:39:01 <shachaf> d34df00d: WHy not just declare the class as -- yes, that
13:39:01 <Cale> instance SuitableConst a
13:39:06 <quackquack> Can you map to a function that takes 2 arguments?
13:39:28 <Axman6> quackquack: what would the two arguments be?
13:39:32 <engla> xivix: you can insert the definition of scanl and solve that fib step by step manually
13:39:33 <shachaf> If what you did worked, you'd still have to specify the constraints that you were using manually.
13:39:43 <d34df00d> Hm.
13:39:45 <Cale> d34df00d: There are normally constraints on allowed instances which ensure that compilation will always terminate
13:39:46 <merijn> quackquack: You mean "map f list" where f takes two arguments? The answer is, because f does not take two arguments, it takes one argument and returns a new function
13:39:56 <Axman6> quackquack: also, it's worth noting that all functions in haskell only take one argument
13:39:57 <quackquack> merijn: yes
13:40:07 <merijn> answer is yes, even
13:40:28 <merijn> :t map (+) [1..10]
13:40:29 <lambdabot> forall a. (Num a, Enum a) => [a -> a]
13:40:31 <quackquack> Axman6: i know that in theory, but still unsure of how to use it to my advantage
13:40:31 <xivix> engla: i was trying to do that
13:40:41 <Axman6> > map ("hello " ++) ["world","quackquack"]
13:40:43 <lambdabot>   ["hello world","hello quackquack"]
13:40:55 <engla> p
13:41:09 <xivix> engla: but i keep getting stuck on the recursive list with no further definition
13:41:16 <xivix> i'm probably doing it wrong
13:41:19 <d34df00d> Oh, great, that works.
13:41:21 <d34df00d> Thanks :)
13:41:33 <d34df00d> Cale: though I had to specify the same set of prerequisites in the instance decl.
13:41:36 <merijn> quackquack: "map (+) [1..10]" returns a list of function which take a number and add 1, 2, 3, etc respectively to it
13:41:42 <d34df00d> And UndecidableInstances, once again.
13:41:49 <Axman6> xivix: i'll try and write out the steps for you for the zipWith version if you like
13:42:00 <xivix> by that i mean 0:scanl (+) 1 (0 : scanl (+) 1 (0: scanl (+) 1...
13:42:06 <merijn> > (map (+) [1..10] !! 1) 0
13:42:07 <lambdabot>   2
13:42:08 <shachaf> > map (uncurry (+)) [(1,2),(3,4)] -- Are you looking for something like this?
13:42:09 <lambdabot>   [3,7]
13:42:10 <merijn> > (map (+) [1..10] !! 2) 0
13:42:10 <lambdabot>   3
13:42:13 <xivix> Axman6: i'll try giving the zipwith version a shot myself
13:42:15 <quackquack> merijn: i think I see. so in my case, I would want to map once with the 1st argument, then again with the second.
13:42:34 <shachaf> quackquack: Well, probably not.
13:42:40 <quackquack> shachaf: ah, i hadnt seen the uncurry function before! that should do it
13:42:41 <shachaf> quackquack: It depends on what your case is. What is your case?
13:42:47 <Cale> d34df00d: yeah, it's a bit awkward and for that reason, kinda uncommon for people to actually do that. People are working on a better solution which will also let us abstract over typeclass constraints and other cool things like that :)
13:42:49 <xivix> I'll check back if i can't get that one
13:43:01 <engla> xivix: it's starting with fib = 0 : (we didn't evaluate this yet). Right. if you only ever access the head of the list, the rest is not evaluated. Then if you want to check out the second argument, you see that scanl's source moves its initial value (1 here) to the front so you get  fib = 0: 1: (....)  etc.
13:43:03 <merijn> quackquack: Well, after the first map you have a *list of functions*, you can map a second value over it but map takes a function, not a value
13:43:05 <Cale> d34df00d: see: http://blog.omega-prime.co.uk/?p=127
13:43:09 <hpc> quackquack: if that's what you want, it's a bit more idiomatic to use zipWith
13:43:12 <merijn> quackquack: So it sort of depends on waht you want to do
13:43:24 <hpc> > zipWith (+) [1..5] [100, 200, 300, 400, 500]
13:43:25 <lambdabot>   [101,202,303,404,505]
13:43:28 <xivix> engla: that's helpful, thanks
13:43:50 <merijn> quackquack: If you have a function f and one argument should be the same for and the other come from the list you'd either use currying or flip
13:43:56 <d34df00d> Oh, thanks for the link.
13:44:10 <merijn> quackquack: Say I want to do "1 +" item in list you'd do
13:44:16 <merijn> > map (1+) [1..10]
13:44:16 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:44:20 <zygoloid> s/currying/partial application/
13:44:32 <quackquack> merijn: what is flip? and hpc: zipWith looks useful!
13:44:43 <merijn> quackquack: flip flips the argument order
13:44:52 <merijn> > 10 / 2
13:44:52 <ion> @type flip
13:44:53 <lambdabot>   5.0
13:44:53 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:44:54 * hackagebot fields-json 0.1 - Abusing monadic syntax JSON objects generation.  http://hackage.haskell.org/package/fields-json-0.1 (MariuszRak)
13:44:55 <hpc> quackquack: what you probably see flip as is
13:44:58 <ion> @type Prelude.flip
13:44:58 <merijn> > (?) 10 2
13:44:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:44:59 <lambdabot>   Not in scope: `?'
13:44:59 <hpc> flip f x y = f y x
13:45:03 <merijn> damn
13:45:05 <merijn> > (/) 10 2
13:45:06 <lambdabot>   5.0
13:45:09 <merijn> > flip (/) 10 2
13:45:09 <alpounet> (flip f) a b = f b a -- quackquack
13:45:10 <lambdabot>   0.2
13:45:29 <quackquack> ah, ok
13:45:33 <hpc> in lambdabot, flip fContainer x = fmap ($ x) fContainer
13:45:57 <hpc> fmap is the generalization of stuff that behaves like 'map'
13:46:09 <merijn> quackquack: Since map expects the list item to be the second argument of the function you can use flip to reorder them
13:46:12 <hpc> or rather, /a/ generalization
13:51:57 <Axman6> xivix: http://hpaste.org/51814 is how the evaluation of the fibs I showed proceeds
13:56:30 <xivix> Axman6: thanks, I'll check that out
13:58:23 <d34df00d> Cale: ok, I now get this error: http://paste.pocoo.org/show/482976/
13:58:29 <d34df00d> Why would it infer Double from somewhere?
13:58:31 <xivix> Axman6: thanks for taking the time to type all that out. it really helps
13:58:40 <d34df00d> I don't have a single mention of Double anymore.
13:59:06 <d34df00d> unaryOps is declared simply as unaryOps = [ (Sin, sin), (Cos, cos), (Log, log) ]
13:59:53 <Cale> Try adding {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your file and see if the error changes.
14:00:40 <Cale> (I think it's defaulting the type of unaryOps, because of a silly rule about pattern bindings being required to be monomorphic if they don't have type signatures)
14:01:14 <d34df00d> Yep, thanks.
14:01:26 <d34df00d> That worked.
14:05:19 <d34df00d> Cale: BTW — I actually encountered a couple of cases where lack of this restriction breaks code.
14:05:29 <d34df00d> And, AFAIK, it's considered for removal.
14:05:36 <d34df00d> So there will be a way to turn it back on, I guess?
14:06:15 <Cale> d34df00d: yeah, it should really just be a warning
14:06:54 <Cale> There are cases where polymorphism like that can make code run slower than it looks (the polymorphism means that things which look syntactically like constants are really not constants and will be recomputed each time they're used)
14:07:16 <Cale> But mostly it's just a huge waste of programmer time tracking down problems that it causes.
14:07:50 <d34df00d> Yeah, I saw those examples.
14:08:03 <d34df00d> But I mean some code wasn't compiling cause of me disabling the restriction.
14:08:53 <mgsloan> http://hackage.haskell.org/packages/archive/rex/0.3/logs/failure/ghc-7.2 <- hmm, anyone know why this is happening?
14:09:47 <antihoax> i wonder how, i wonder why, yesterday you talked about the blue blue skyyy
14:11:42 <rata_> hi
14:11:57 <ulidtko> hi there
14:12:01 <rata_> is there a way to get the root node from a Data.Map?
14:12:21 <d34df00d> ulidtko: hi!
14:12:35 <ulidtko> d34df00d: ohai handsome
14:12:37 <rata_> something like "root Tip = Nothing; root (Bin _ k v _ _) = Just (k, v)"
14:13:08 <rata_> (the problem with that fn is that Tip and Bin aren't exported by Data.Map)
14:13:24 <ulidtko> rata_: you can't be sure that Data.Map will expose its internals to you
14:13:37 <ulidtko> in fact, it'd be very wrong for it to do so.
14:13:43 <rata_> ulidtko: I'm sure it doesn't
14:13:50 <ulidtko> and yet?..
14:14:04 <ulidtko> why, at all, do you need the root node?
14:14:23 <rata_> I'm porting ocaml code
14:15:17 <ulidtko> to haskell?
14:17:46 <d34df00d> Oh, one more type problem.
14:19:53 <d34df00d> http://paste.pocoo.org/show/482986/
14:20:07 <d34df00d> I guess it's pretty clear from the pasted parts of code.
14:24:35 <rata_> ulidtko: yes, to haskell
14:24:45 <rata_> (sorry, I was on the phone)
14:25:19 <ulidtko> rata_: and you definitely need to access the internal structure of Map directly?
14:25:39 <shachaf> rata_: Why do you need that?
14:26:31 <rata_> shachaf: I'm porting ocaml code to haskell
14:26:32 <rata_> ulidtko: I'm not yet sure if I need it, but I'd like to see the code compile first
14:26:50 <shachaf> rata_: Does OCaml have a Data.Map equivalent that exports its internals?
14:27:02 <rata_> I haven't understood yet why he is using the internals of IntMap
14:27:15 <shachaf> You can probably just copy the source of Data.Map into a file.
14:27:24 <rata_> well yes
14:27:27 <shachaf> It's probably a good idea to understand it, though. :-)
14:27:27 <rata_> that's a way
14:27:40 <rata_> yes, I know
14:27:48 <ulidtko> rata_: anyway, you better drop the idea of sidestepping the public interface of Map
14:27:49 <shachaf> rata_: I don't think there's a better way. Data.Map doesn't export its internals for a reason.
14:27:59 <ulidtko> yeah, exactly.
14:28:01 <magicman> d34df00d: That is because you say, in the class definition, that 'compute' should work for *any 'b' at all*, while the definition you give for 'ExpTree a' only works for that specific 'a'.
14:28:17 <rwbarton> what are you even going to do with the root node?
14:28:31 <magicman> (according to its type signature, anyway)
14:28:37 <rata_> I was afraid you were going to say this
14:29:16 <DanBurton> ok guys code challenge: is there a better way to express this?
14:29:17 <rwbarton> well, depending on what you want to do with it, there may be awful, horrible hacky work-arounds
14:29:31 <DanBurton> > Set.fromList . concatMap f . set.toList
14:29:32 <lambdabot>   Not in scope: `Set.fromList'Not in scope: `set'Not in scope: `toList'
14:29:33 <rata_> I'll have to figure out in which strange way he's using IntMap to require use its internals
14:29:40 <d34df00d> magicman: yep, and how this could be solved? I don't know in the typeclass definition that that one 'a' that parametrizes the GAble class can have parameters itself.
14:30:32 <ulidtko> DanBurton: is List.nub what you need?
14:30:49 <rwbarton> one example of an awful, horrible hacky work-around would be to just copy the definition of the IntMap data type and unsafeCoerce a real Data.IntMap.IntMap to it
14:30:56 <DanBurton> ulidtko: not necessarily. I just need `concatMap` on Sets
14:31:05 <shachaf> ulidtko: List.nub uses Eq.
14:31:24 <DanBurton> shachaf: Sets require Ord so that isn't an issue
14:31:36 <ulidtko> shachaf: and it's O(n^2), I know. Set also uses Eq, doesn't it?
14:31:37 <shachaf> DanBurton: Right, but nub is O(n^2).
14:31:47 <DanBurton> true
14:31:50 <shachaf> ulidtko: Set uses Ord, so it's much faster.
14:31:59 <shachaf> DanBurton: Oh. Why not just use map and concat, then?
14:32:03 <shachaf> I guess Set doesn't have concat.
14:32:05 <ulidtko> DanBurton: have you looked for fmap?
14:32:10 <shachaf> You can probably implement it easily enough.
14:32:14 <magicman> d34df00d: The 'b' in 'compute', that's only one possible 'b' per instance? Or can you have multiple possible such 'b's for which "compute" makes sense?
14:33:08 <DanBurton> ulidtko: Set doesn't have a functor instance :(
14:33:12 <ski> Cale : re ".. but they actually let you get away with not thinking about types.", it would possibly be better if more warnings about incomplete/missing,overlapping,unused things were enabled by default in GHC .. (cf. SML and O'Caml)
14:33:14 <DanBurton> the Ord constraint screws stuff up
14:33:27 <ulidtko> DanBurton: so disappointing
14:33:33 <magicman> d34df00d: You could use the MultiParamTypeClasses extension, and parameterize the class over the 'b' as well, but then you'd have to define a new instance for every 'b' (perhaps better to have 'compute' be in its own typeclass). If it's only one 'b' per instance, an associated type is perhaps better.
14:33:37 <monochrom> "Ord considered Odd"
14:33:44 <d34df00d> magicman: I guess the latter one.
14:33:57 <mkscrg> any database.mongodb users on here right now?
14:34:05 <d34df00d> But I don't think that restricting to one 'b' per instance would be a problem.
14:34:19 <d34df00d> And what's associated type?
14:34:25 <shachaf> Restricted Functors!
14:34:31 * shachaf distrusts restricted functors.
14:34:39 <ulidtko> why?
14:34:44 <shachaf> Their very name is a lie. They can do anything.
14:34:55 <shachaf> With fmap you can be sure there's only one reasonable instance for a type.
14:35:01 <shachaf> With restricted functors, who knows?
14:35:41 <DanBurton> :t (>>=)
14:35:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:35:56 <Cale> d34df00d: did you solve that problem?
14:35:58 <dolio> Restricted functors are functors from a subcategory of Hask to Hask.
14:36:09 <dolio> Wide (I think) subcategory.
14:36:09 <Cale> d34df00d: You have a random b in the type signatures for your GAble class
14:36:59 <Cale> d34df00d: which, being completely unconstrained, means that compute produces a value which could have any type at all. There are not so many values with that property -- the only such value being nontermination.
14:37:03 <d34df00d> Cale: not yet.
14:37:17 <Cale> :t undefined
14:37:18 <lambdabot> forall a. a
14:37:27 <Cale> ^^ that's the only thing it could possibly produce
14:37:34 <d34df00d> Cale: well, and how could I restrict it?
14:37:40 <d34df00d> Or, well, make somewhat meaningful?
14:38:04 <Cale> Oh, I see, b also occurs in the input to that function
14:38:11 <Cale> Sorry, I missed that
14:38:17 <magicman> d34df00d: Associated types are a nonstandard language extension. Then you can put type definitions in a class declaration.
14:38:21 <Cale> but a doesn't
14:38:21 <d34df00d> Yep, that was my next question, why would it be of any type :)
14:38:35 <dolio> Oh, no, not wide.
14:38:35 <dolio> Full subcategory.
14:38:50 <d34df00d> Cale: but 'a' is the type class instance variable.
14:38:54 <d34df00d> Or how it's called correclty.
14:38:59 <d34df00d> So I guess it's restricted to.
14:39:06 <Cale> yeah
14:39:14 <Cale> But it seems that your code assumes that a = b
14:39:19 <d34df00d> Yep, surely.
14:39:24 <d34df00d> Oh, sorry, no.
14:39:29 <Cale> er, not quite
14:39:35 <d34df00d> My code assumes dependency between them.
14:39:36 <Cale> hmm
14:39:38 <Cale> yeah
14:39:39 <d34df00d> That is, a = ExprTree b.
14:39:41 <d34df00d> Or vice versa.
14:39:45 <magicman> d34df00d: So you'd have "class GAble a where { type Thing a :: *; mutate :: ... ; ... ; compute :: [(String, Thing a)] -> a -> Thing a; ...}
14:39:56 <Cale> So maybe you want  class ... GAble a b | a -> b where
14:40:06 <magicman> Or functional dependencies, yeah.
14:40:10 <d34df00d> Cale: I'm not familiar with that notation, what does it mean?
14:40:50 <Cale> It means that the typeclass has two type parameters, and that the type a uniquely determines the type b
14:41:10 <d34df00d> Oh, seems like that's just what I need.
14:41:15 <d34df00d> Thanks, I'd try that :)
14:41:15 <Cale> (so that for any given a, there is at most one type b for which there is an instance GAble a b)
14:41:24 <d34df00d> magicman: thank you as well, I now know one more feature :)
14:41:49 <Cale> yeah, it's equivalent to using that associated type, like magicman showed
14:42:12 <magicman> d34df00d: Keep in mind that you need some additional LANGUAGE pragmas on top of the file for either of those methods.
14:42:16 <Cale> Associated types are the newer way to do it. Sometimes one syntax or the other works out more nicely.
14:42:44 <magicman> In this case, there's no real difference, is there?
14:43:00 <d34df00d> magicman: yeah, ghci has already told me about those.
14:43:05 <magicman> Cool :)
14:43:32 <d34df00d> Too many parameters for class `GAble' (Use -XMultiParamTypeClasses to allow multi-parameter classes)
14:43:46 <d34df00d> And then Fundeps in class `GAble' (Use -XFunctionalDependencies to allow fundeps)
14:43:54 <d34df00d> Well, Haskell is an awesome language :)
14:44:41 <d34df00d> Err... Now I should put the second param in every place where I use the "GAble a"
14:45:14 <Cale> yeah :P
14:45:25 <d34df00d> Hm, I'd also try magicman's solution then :)
14:45:27 <Cale> That's one advantage of the other notation, I guess :)
14:48:25 <d34df00d> Hmm.
14:48:41 <d34df00d> magicman: and if I want to return that Thing a from some function not associated with the typeclass, how do I do that?
14:49:08 <d34df00d> There is getChromoFit :: (RandomGen g, GAble a) => a -> GAState g a -> ??? that should return the same type as 'compute' does.
14:49:28 <magicman> Still use "Thing a".
14:49:56 <d34df00d> Just tried, and it still tries to use Double instead.
14:50:04 <d34df00d> Though I don't get why yet.
14:50:36 <d34df00d> Ah, I'm an idiot :)
14:51:29 <eyebloom> If I'm using Debug.Trace will it only print when the expression is forced?
14:52:08 <eyebloom> i.e. in a case or if statement
14:56:27 <d34df00d> Oh, I don't get it still :(
15:00:04 <magicman> d34df00d: What's going wrong now?
15:02:33 <d34df00d> Well, I've googled http://www.haskell.org/haskellwiki/GHC/Type_families and now try to understand how I could write contraints for "ComputeRes a"
15:02:39 <d34df00d> (I called your Thing as ComputeRes).
15:03:11 <d34df00d> Cause I get a lot of things like "Could not deduce (Eq (ComputeRes a)) arising from a use of `elem'", and seems like it makes sense to define these requirements in one place.
15:03:48 <magicman> Ah, right.
15:04:45 <d34df00d> In my instance decl I write "type ComputeRes (ExprTree a) = a", if that matters.
15:05:32 <magicman> That's fine.
15:10:49 <eyebloom> Is it me or is debugging haskell extremely difficult.
15:11:47 <d34df00d> Oh, great, (almost) fixed that.
15:12:04 <d34df00d> FlexibleContexts and class declaration like:
15:12:06 <d34df00d> class (Eq a, Show a, Formattable a, Ord (ComputeRes a), RealFloat (ComputeRes a), Formattable (ComputeRes a)) => GAble a where
15:12:12 <d34df00d> Starts looking scary...
15:12:28 <magicman> Huh...
15:13:21 <d34df00d> Oh, sad, sad...
15:13:21 <magicman> Yeah, it does. Seeing how ComputeRes is defined *in* the class...
15:13:40 <DanBurton> eyebloom: it's just you ;) anything we can help with?
15:13:58 <d34df00d> "Dual tag a" isn't a Random neither my own Formattable class.
15:14:30 <magicman> Why are you putting those constraints on the class definition?
15:14:49 <magicman> Would it make sense to have them on instance definitions, with the appropriate type of ComputeRes filled in?
15:15:37 <d34df00d> magicman: hm, makes sense.
15:15:40 <magicman> Otherwise, now is when it may pay off to take another look at Cale's suggestion of MultiParamTypeClasses and FunctionalDependencies.
15:16:07 <magicman> Because then you can do stuff like "class (Eq a, Show a, Formattable a, Ord b, RealFloat b, Formattable b) => GAble a b | a -> b where"
15:16:08 <d34df00d> But nevertheless, seems like I need the return type of my 'compute' function to be Random and such.
15:16:25 <magicman> You can also put those constraints on the member function itself:
15:17:03 <magicman> class (Eq a, Show a, Formattable a) => GAble a where {...; compute :: (Ord (ComputeRes a), ...) => ...}
15:17:23 <d34df00d> Oh, at least it computes the jacobian correctly now.
15:17:33 <DanBurton> @pl (\f g x y -> f (g x y))
15:17:33 <lambdabot> (.) . (.)
15:17:56 <ulidtko> boobs!
15:18:03 <ulidtko> wai~
15:18:28 <DanBurton> +_+ not boobs....
15:18:45 <magicman> (.).(.) is the owl-operator.
15:18:59 <DanBurton> I call it compose2
15:19:02 <DanBurton> or .*
15:19:03 <d34df00d> Oh.
15:19:09 <d34df00d> ulidtko: gotta summon Crazy_Owl then :)
15:19:19 <magicman> *nod*
15:19:23 <magicman> Some people call it `dot`
15:19:25 <ulidtko> d34df00d: he wouldn't appreciate
15:19:36 <ulidtko> as a lisper...
15:19:40 <mauke> (.)(.)(.)  -- booobs?
15:19:43 <d34df00d> ulidtko: maybe he'd forget his lisp after this.
15:19:49 <d34df00d> mauke: Total Recall?
15:19:55 <mauke> dingo!
15:19:59 <ulidtko> Arney!
15:20:00 <magicman> I like how (.)(.)(.) is the same as (.).(.).
15:20:09 <ulidtko> i love Arney, he's cool
15:20:30 <DanBurton> magicman: o_O lol cool
15:20:41 <magicman> Minus that last dot. Perhaps I shouldn't try to care about punctuation if it involves function composition.
15:20:51 <kmc> mauke, congratulations, you are the 9000th person to make that joke
15:20:51 <ulidtko> magicman: because of associativity. Easy one.
15:21:00 <kmc> your prize is a $20 gift certificate to Hackage
15:21:18 <DanBurton> magicman: it wasn't written as a section, so my brain was able to parse it correctly
15:21:19 <d34df00d> ~
15:21:28 <magicman> Good, good :)
15:21:30 * ddarius would've given a 50% off certificate
15:21:36 <d34df00d> I _must_ make this compile fine since it calculates the jacobian correctly now!
15:25:10 <d34df00d> Awesome! I have lift!
15:26:57 <Eduard_Munteanu> kmc: what's wrong, you don't like tritties? :P
15:27:31 <magicman> d34df00d: Congrats!
15:29:02 <Eduard_Munteanu> I suppose Coq jokes are even more common.
15:29:13 <ulidtko> Coq jokes?
15:29:32 <Eduard_Munteanu> @quote coq
15:29:33 <lambdabot> sorear says: <sorear> Unfortunately, Coq *cannot* prove that your program will terminate before the heat-death of the universe. <psnively> Right. That's a software engineering problem, not a
15:29:33 <lambdabot> computer science problem. ;-)
15:29:39 <Eduard_Munteanu> @quote coq
15:29:39 <lambdabot> edwardk says: whenever you see 'auto' [in coq code] read it as 'then magic happens'
15:29:47 <Eduard_Munteanu> Bah, anyway.
15:30:00 <Eduard_Munteanu> @quote coq
15:30:00 <lambdabot> sorear says: <sorear> Unfortunately, Coq *cannot* prove that your program will terminate before the heat-death of the universe. <psnively> Right. That's a software engineering problem, not a
15:30:00 <lambdabot> computer science problem. ;-)
15:30:27 <ulidtko> what is Coq anyway?
15:30:36 <d34df00d> Description:         Coq is a proof assistant written in O'Caml
15:30:37 <Eduard_Munteanu> A theorem prover with a funny name
15:30:41 <d34df00d> © eix
15:31:02 <ulidtko> oh
15:31:04 <Eduard_Munteanu> I guess the French thought otherwise.
15:31:27 <d34df00d> magicman: and the only thing left is to deal somehow with the usage of that Dual thing with randoms.
15:31:29 <Eduard_Munteanu> IIRC, it references the Gallina prover or something.
15:31:58 <d34df00d> I either think of lifting the returned value for standard types into Dual, or implementing the whole typeclass.
15:32:04 <Eduard_Munteanu> Ah, no... "Gallina is the kernel language of Coq"
15:32:14 <d34df00d> The latter seems more clean, since there would be no hacks for lifting whenever needed.
15:32:53 <magicman> @hoogle Dual
15:32:54 <lambdabot> Data.Monoid newtype Dual a
15:32:54 <lambdabot> Data.Monoid Dual :: a -> Dual a
15:32:54 <lambdabot> Data.Monoid getDual :: Dual a -> a
15:32:57 <magicman> That one?
15:33:52 <d34df00d> magicman: nope, from Numeric.FAD.
15:33:53 <ski> iiuc, Coq is named after Theirry Coquand (maybe also as a pun on CoC, the Calculus of Constructions ?)
15:33:58 <d34df00d> http://hackage.haskell.org/packages/archive/fad/1.0/doc/html/Numeric-FAD.html
15:34:37 <d34df00d> Do I get correctly that minimal definition for Random instance is random and randomR?
15:34:56 <int-e>  
15:36:04 <magicman> d34df00d: That is correct.
15:36:49 <Younder> d34df00d, why such a difficult name?
15:37:08 <int-e> ca
15:37:18 * ski wonders whether `randomR :: (Random a,Ix a,RandomGen g) => (a,a) -> g -> (a,g)' would have been better
15:37:20 <int-e> sorry.
15:37:28 <d34df00d> Younder: to write int author = 0xd34df00d; in code.
15:37:35 * glguy split random and randomR into different classes on a recent project as random doesn't make sense for Integer and randomR doesn't make sense for nonces (among other examples)
15:37:40 <Bella> Hello
15:37:56 <Eduard_Munteanu> Bella: hi
15:38:02 <d34df00d> That's just IRC disallowing nicks starting from numbers :(
15:38:06 <geheimdienst> > 0xdeadf00d
15:38:07 <lambdabot>   3735941133
15:38:14 <Younder> d34df00d, yes I got the hex bit, but I never bothered to rtanslate it into ascii
15:38:18 <Bella> I'm really dumb in Haskell but I seriously want to be good at it.
15:38:18 <Eduard_Munteanu> ski: hrm, that sounds more likely, yeah.
15:38:31 <ski> geheimdienst : "nonce" being ?
15:38:39 <Bella> Is there anyone out there who's good in this would be willing to personally teach me?
15:39:02 <geheimdienst> ski: how do you mean?
15:39:04 <Bella> I would pay if the price is reasonable
15:39:06 <Eduard_Munteanu> Yeah, I think Gallina is a reference to Coq :/
15:39:12 <glguy> ski: a single use unpredictable value used in cryptography
15:39:14 <ski> geheimdienst : as in, what does it mean ?
15:39:42 <ski> glguy : a one time pad ?
15:39:47 <d34df00d> Younder: you hardly lost anything :)
15:39:58 <Eduard_Munteanu> @wn nonce
15:39:59 <lambdabot> *** "nonce" wn "WordNet (r) 2.0"
15:40:00 <lambdabot> nonce
15:40:00 <lambdabot>      n : the present occasion; "for the nonce" [syn: {time being}]
15:40:03 <geheimdienst> ski: you might be mistaking me for glguy :) but see here http://en.wikipedia.org/wiki/Cryptographic_nonce
15:40:05 <d34df00d> That's just another stupid name just to fit into 32 bites and such.
15:40:07 <Bella> just email me if interested...
15:40:08 <d34df00d> s/bites/bits/
15:40:16 <Bella> halfpirate1210@gmail.com
15:40:35 <ski> geheimdienst : oh, sorry -- indeed i was
15:40:40 <Eduard_Munteanu> Bella: why not ask questions in here?
15:40:43 <Cale> Bella: If you ask questions here, I think you'll find people more than willing to help out :)
15:41:22 <Younder> d34df00d, f0 is not an ASCII code
15:41:24 <Bella> I don't really have any questions it's just that I barely passed my basic haskell in my 1st year and im not very happy about it :(
15:41:30 <Bella> now im in second year
15:41:59 <copumpkin> Bella: do you like vampires?
15:42:03 <Eduard_Munteanu> Bella: do you know LYAH?
15:42:06 <Eduard_Munteanu> @where lyah
15:42:06 <lambdabot> http://www.learnyouahaskell.com/
15:42:09 <Cale> haha
15:42:21 <Bella> :)
15:42:23 <Bella> lol
15:42:26 <Younder> rotfl
15:42:32 <ski> glguy : hm, i'm not sure what those have to do with ranges, though
15:43:15 <dylukes> Bella: If you ask questions we'll sparkle and stalk you.
15:43:28 <glguy> ski: Don't worry about that specific example; the point is that there are types that aren't ordered but from which you could want a random element
15:43:35 <d34df00d> Hm, I personally learned from RWH.
15:43:44 <d34df00d> I think it's a very good book.
15:43:52 <glguy> and there are types that don't have interesting default bounds (like Integer)
15:43:55 <d34df00d> Also, arrows are awesome!
15:44:00 <magicman> Both excellent resources, IMHO.
15:44:00 <d34df00d> random g = (first lift) (random g)
15:44:09 <ski> glguy : fully agreed
15:44:12 <Bella> really? where can i buy it?
15:44:16 <Bella> the book i mean
15:44:22 <d34df00d> Bella: it's available online.
15:44:26 <ski> @where rwh
15:44:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:44:30 <d34df00d> Though I don't remember the address out of my head.
15:44:49 <magicman> LYAH is perhaps more newbie-friendly than RWH, but both are good reads.
15:44:58 <ski> Bella : but you should probably take a look at LYAH (mentioned above, with link), as well
15:45:20 <dylukes> I'd read LYAH first.
15:45:24 <BrianHV> I remember seeing a presentation or document of some sort that described how typeclasses were implemented at the compiler level. anyone happen to know what that was?
15:45:26 <Bella> LYAH...
15:45:36 <Cale> @where lyah
15:45:37 <lambdabot> http://www.learnyouahaskell.com/
15:45:39 <dylukes> @where lyah
15:45:39 <lambdabot> http://www.learnyouahaskell.com/
15:45:43 <dylukes> Damnit.
15:46:05 <ski> well, that's only three times it's been mentions now :)
15:46:10 <Bella> cool!
15:46:37 <ski> (in case it wasn't clear, "LYAH" is an initalism of "Learn You A Haskell")
15:46:46 <d34df00d> Hm.
15:46:58 <d34df00d> I thought nothing could be friendlier than RWH :)
15:47:04 <d34df00d> Gotta take a look at LYAH then.
15:47:24 <kmc> d34df00d, i don't think the Arrow abstraction is all that useful.  the functions are useful for the specific arrow (->), yes
15:47:25 <d34df00d> magicman: Cale: thank you guys a lot, you've saved me from implementing partial symbolic differentiation myself :)
15:47:37 <kmc> the fact that they're generalized to a mostly-useless typeclass is unfortunate
15:47:48 <d34df00d> And now I know a bit more nice features of Haskell.
15:47:51 <kmc> because it makes them look a lot scarier
15:48:01 <d34df00d> kmc: what do you mean?
15:48:12 <ski> Bella : btw, as you read, if there's something that you don't understand, or you get stuck on an exercise, it's probably a good idea to keep this #haskell IRC channel open so you can ask questions (you know, you can even just lurk, and learn from what other people say)
15:48:14 <Bella> Oh LYAH...i get it now..I got this already but it didn't really help my assignment during my 1st year.
15:48:20 <Bella> pretty hard to me that time
15:48:21 <Bella> pjew
15:48:24 <Bella> *phew
15:48:34 <kmc> :t first
15:48:35 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:48:44 <Bella> or maybe i don't really understand
15:48:47 <Bella> *amused*
15:48:53 <Bella> lemme try RWH
15:49:35 <ion> :t first `asAppliedTo` (undefined :: a -> b)
15:49:37 <lambdabot> forall b c d. (b -> c) -> (b, d) -> (c, d)
15:50:04 <d34df00d> Hm.
15:50:10 <d34df00d> kmc: and? :)
15:50:24 <kmc> well the latter type is a lot easier to understand
15:50:33 <Bella> Thank you guys, if there's any more easy haskell tutorials just send the links to my email!
15:50:39 <kmc> and the vast majority of Haskell programmers will never use the more general version
15:50:42 <Bella> halfpirate1210@gmail.com
15:50:48 <kmc> so i'd rather have both, in different modules
15:50:56 <kmc> kind of like map and fmap
15:51:03 <Bella> i mean easy to understand
15:51:20 <kmc> though at the same time i'd like the opposite with map and fmap
15:51:25 <ion> (I’d rather have just map, which is the Functor function.)
15:51:40 <kmc> (the Functor abstraction is a lot more useful than the Arrow abstraction)
15:52:00 <d34df00d> kmc: once you start reading Arrow a => a b c as just b -> c, things get much, much easier, I think.
15:52:01 <BMeph> kmc: What about the likes of 'on' and 'fix', which are also in multiple modules?
15:52:07 <dylukes> :t asAppliedTo
15:52:08 <lambdabot> forall t b. (t -> b) -> t -> t -> b
15:52:16 <kmc> d34df00d, sure
15:52:22 <kmc> but you have to figure that out or have someone tell you
15:52:35 <kmc> BMeph, they are?
15:52:38 <d34df00d> Well, I've learned that once hlint pointed me at *** and I googled for it.
15:52:41 <d34df00d> What's asAppliedTo?
15:52:58 <kmc> @src asAppliedTo
15:52:58 <lambdabot> Source not found. My mind is going. I can feel it.
15:53:03 <BMeph> kmc: ...yes. :)
15:53:19 <kmc> example?
15:53:38 <kmc> d34df00d, it does not appear to be in any standard module
15:53:47 <ion> a `asAppliedTo` b = a `asTypeIn` ($ b)  -- i think
15:53:59 <ion> And as for asTypeIn, let me think…
15:54:01 <kmc> :t asTypeIn
15:54:02 * ski prefers spelling it as `first :: Arrow ar => ar a0 a1 -> ar (a0, b) (a1, b)', alternatively as `first :: Arrow (~>) => (a0 ~> a1) -> ((a0, b) ~> (a1, b))', using syntax extension
15:54:02 <lambdabot> forall a b. a -> (a -> b) -> a
15:54:17 <magicman> I think its definition is just "const". Its main feature is being able to restrict type.
15:54:29 <magicman> +grammar.
15:54:32 <ion> a `asTypeIn` f = a where _ = f a?
15:54:35 <ski> magicman : yes, that's why i invented it
15:54:42 <Bella> bye. bless u all! xxx
15:54:51 <ski> @src asTypeIn
15:54:51 <lambdabot> a `asTypeIn` f = a where _ = f a
15:54:51 <lambdabot> infixl 0 `asTypeIn`
15:54:55 <d34df00d> kmc: hm, I couldn't find it.
15:54:58 <ion> Ah, there’s @src for that.
15:55:20 <ski> yeah, it's only in lambdabot (afaik)
15:55:33 <ski> @src asAppliedTo
15:55:34 <lambdabot> Source not found. You untyped fool!
15:55:44 <ski> @botsmack
15:55:44 <lambdabot> :)
15:55:56 <d34df00d> :(
15:56:19 <magicman> XD
15:56:37 <d34df00d> Oh, 4 a.m. already, gotta sleep well at least today.
15:56:37 <magicman> That the automagic typo-detection making it think it gets a treat? :p
15:56:43 <d34df00d> Haskell is way too entertaining and fun.
15:57:02 <ion> @botslack
15:57:02 <lambdabot> :)
15:57:04 <quackquack> How do i access the mathematical constant `e` in haskell?
15:57:07 <kmc> > exp 1
15:57:08 <lambdabot>   2.718281828459045
15:57:16 <quackquack> kmc: ty!
15:57:54 <ion> How do i access the mathematical constant ‘1’ in Haskell?
15:57:55 <d34df00d> Thank you all once again, you're maybe the most awesome and friendly community I've ever seen.
15:57:57 <ion> > (log . exp) 1
15:57:59 <lambdabot>   1.0
15:58:17 <monochrom> > 239489324 - 239489323
15:58:18 <lambdabot>   1
15:58:42 <DanBurton> > (\a -> a / a) 48672
15:58:43 <lambdabot>   1.0
15:58:57 <tgeeky> > 1.0
15:58:58 <lambdabot>   1.0
15:59:03 <magicman> ohsnap
15:59:04 <QtPlatypus> > succ 0
15:59:05 <lambdabot>   1
15:59:12 <tgeeky> QtPlatypus: wrong!
15:59:41 <QtPlatypus> tgeeky: He didn't say which 1.
15:59:53 <QtPlatypus> So I went for the natural answer
15:59:58 <DanBurton> > (\n -> n - pred n) 978324
15:59:59 <lambdabot>   1
16:00:20 <ion> > (<*>) (-) pred 978324
16:00:21 <lambdabot>   1
16:00:28 <kmc> > In (Just (In Nothing))
16:00:30 <lambdabot>   In (Just (In Nothing))
16:00:49 <DanBurton> :t ln
16:00:50 <lambdabot> Not in scope: `ln'
16:00:54 <monochrom> > atan 1 * 4 / pi
16:00:55 <lambdabot>   1.0
16:01:03 <kmc> > let z = In Nothing; s = In . Just in iterate s z
16:01:05 <lambdabot>   [In Nothing,In (Just (In Nothing)),In (Just (In (Just (In Nothing)))),In (J...
16:01:17 <monochrom> it's a fixed point of \x -> atan x * 4 / pi :)
16:02:19 <DanBurton> :t fix $ \x -> atan x * 4 / pi
16:02:21 <lambdabot> forall a. (Floating a) => a
16:05:26 <dmwit> DanBurton: ...that's probably undefined, by the way.
16:05:37 <ski> anyway, <http://code.haskell.org/lambdabot/State/L.hs> has the definitions of `asTypeIn' and `asAppliedTo' (and <http://code.haskell.org/lambdabot/State/source> has the things that the `src' command reports)
16:05:50 <DanBurton> dmac1: yeah that's why I just looked at its type. It would keep going forever
16:08:52 <DanBurton> :t scanl
16:08:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:09:17 <DanBurton> :t scanl1
16:09:18 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
16:13:39 <DanBurton> @let myfix f guess = let x = f guess; diff = abs (x - guess) in if diff < 0.0001 then x else myfix f ((x + guess) / 2)
16:13:41 <lambdabot>  Defined.
16:13:54 <DanBurton> myfix (\x -> atan x * 4 / pi) 38954
16:14:01 <DanBurton> > myfix (\x -> atan x * 4 / pi) 38954
16:14:03 <lambdabot>   1.0001461821332687
16:14:06 <mkscrg> how do i get ghc to load a specific version of an installed package?
16:14:19 <kmc> write a cabal file
16:15:14 <monochrom> use -package and -hide-package
16:15:24 <mkscrg> kmc: so if i run ghc in the same directory as an appropriate cabal file, it will figure it out? how about ghci?
16:15:30 <shachaf> DanBurton: Don't call that function "fix". :-(
16:15:33 <mkscrg> monochrom: are those flags to ghc?
16:15:38 <monochrom> yes
16:15:38 <DanBurton> @pl let x = f guess; diff = abs (x - guess) in if diff < 0.0001 then x else myfix f ((x + guess) / 2)
16:15:39 <lambdabot> if' (abs (f guess - guess) < 0 . 1) (f guess) (myfix f ((f guess + guess) / 2))
16:15:50 <mkscrg> monochrom: excellent. thanks
16:15:54 <monochrom> "myfix" is fine
16:15:54 <DanBurton> doh
16:16:20 <DanBurton> shachaf: maybe I should call it fixDoubleToDouble
16:16:34 <kmc> mkscrg, no, you'd build with ghc
16:16:36 <kmc> err
16:16:38 <DanBurton> or rather, fixDoubleToDoubleApproximate
16:16:38 <kmc> you'd build with cabal
16:17:00 <kmc> and you'd run ghci like so http://mainisusuallyafunction.blogspot.com/2010/09/ghci-and-cabal.html
16:18:04 <DanBurton> @pl let myfix f guess = let x = f guess; diff = abs (x - guess) in if diff < 0.0001 then x else myfix f ((x + guess) / 2) in myfix
16:18:05 <lambdabot> fix (join . (ap .) . flip flip ((abs .) . subtract) . (liftM2 (ap . ap (flip . flip (if' . (< 0 . 1)))) .) . flip flip (flip flip 2 . ((/) .) . (+)) . (((.) . (.)) .))
16:18:09 <kmc> since process-1.0 uses Strings in a broken way: is there an alternative to 'process' which uses a byte type for command arguments?
16:18:23 <DanBurton> oh boy. thanks lambdabot
16:18:32 <mkscrg> kmc: also excellent!
16:19:01 <kmc> :t flip flip
16:19:02 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
16:19:18 <kmc> :t let f = Prelude.flip in f f
16:19:19 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
16:19:30 <DanBurton> o_O
16:19:42 <DanBurton> where did lambdabot pull that functor stuff
16:20:00 <shachaf> From L.hs
16:20:09 <DanBurton> :t flip
16:20:10 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
16:20:17 <kmc> she has some... non-standard definitions
16:20:19 <kmc> :t map
16:20:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:20:22 <kmc> hmm
16:20:25 <kmc> :t (.)
16:20:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:20:38 <DanBurton> so just in case I want to flip functors i can...o_O
16:21:01 <shachaf> http://code.haskell.org/lambdabot/State/Pristine.hs
16:21:03 <kmc> :t flip (fmap . ($))
16:21:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
16:21:14 <shachaf> DanBurton: It's not really "flipping a functor".
16:21:35 <magicman> :t flip . flip
16:21:35 <DanBurton> shachaf: then what would you call it?
16:21:36 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
16:22:15 <shachaf> I don't know. Flipped application of a function in a functor, or something.
16:22:19 <shachaf> I wouldn't really give it a name.
16:25:17 <kfish> morning
16:25:34 <DanBurton> @let flipflip b f a = f a b
16:25:35 <lambdabot>  Defined.
16:25:42 <kfish> anyone know where to get minDouble, maxDouble from?
16:25:44 <DanBurton> :t flipflip
16:25:45 <lambdabot> forall t t1 t2. t -> (t1 -> t -> t2) -> t1 -> t2
16:25:54 <geheimdienst> > minBound :: Double
16:25:55 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
16:25:55 <lambdabot>    arising from a use o...
16:26:06 <geheimdienst> bah
16:26:11 <kfish> yeah :(
16:26:16 <DanBurton> that's what I thought too geheimdienst
16:26:22 <DanBurton> @google haskell double minbound
16:26:23 <lambdabot> http://zvon.org/other/haskell/Outputprelude/minBound_f.html
16:26:24 <lambdabot> Title: Haskell : minBound
16:26:29 <ion> kfish: https://gist.github.com/1188115
16:26:58 <DanBurton> @botsmack
16:26:59 <lambdabot> :)
16:27:02 <kfish> ion, wow, thankyou so much!
16:27:13 <kfish> much better than my previous solution:
16:27:16 <kfish>     where
16:27:17 <kfish>         minDouble = -1000.0 -- lol
16:27:17 <kfish>         maxDouble = 10000.0 -- lol
16:27:24 <geheimdienst> ion: somewhat more bizarre than i expected, but whatever ...
16:28:12 <kfish> ion++
16:30:34 <Saizan> that fix trick is cool
16:34:38 <Saizan> @tell quicksilver this fix trick (by ion) solves the ScopedTypeVariables debate, i think :) https://gist.github.com/1188115
16:34:38 <lambdabot> Consider it noted.
16:35:46 <copumpkin> oh neat
16:35:48 <copumpkin> ion++
16:35:57 <kmc> what's the debate?
16:45:32 <ion> Yeah, what’s the debate?
16:45:34 * ski thought he saw the generalized `flip' above somewhere at <http://www.funmath.be/>, but can't find it now ..
16:48:07 <DanBurton> @src flip
16:48:08 <lambdabot> flip f x y = f y x
16:48:46 <DanBurton> the @src command apparently doesn't draw from the same resource as lambdabot's evaluation engine
16:49:53 <ion> The @src command draws from a manually written text file.
16:50:01 <DanBurton> o_O
16:50:33 <ion> > flip [pred, id, succ] 42
16:50:35 <lambdabot>   [41,42,43]
16:50:53 <ion> > fmap ($ 42) [pred, id, succ]
16:50:54 <lambdabot>   [41,42,43]
16:51:15 <dylukes> Anyone in here good with monad transformers >.>?
16:51:16 <dylukes> http://cl.ly/ASHl
16:51:31 <ion> > Prelude.flip fmap [pred, id, succ] ($ 42)
16:51:32 <lambdabot>   Not in scope: `Prelude.flip'
16:52:06 <dylukes> Also relevant, what library would you guys recommend for monad transformers, to escape fundeps?
16:53:14 <ski> you can't use `lift' like that
16:53:24 <pchiusano> copumpkin: you around?
16:53:26 <dylukes> ski: :\, when I didn't have the new type it was fine before.
16:53:40 <DanBurton> > flip fmap [pred, id, succ] ($ 42)
16:53:41 <ski> since `OTPProc' is not a monad transformer, you can't use `lift' for that purpose
16:53:42 <lambdabot>   [41,42,43]
16:53:54 <dylukes> hm
16:54:01 <glguy> Saizan: That seems like a complicated way to do http://hpaste.org/51816
16:54:12 <dylukes> ski: So how would I accomplish my behavior? OTPProc can't exactly be a monad transformer, I don't think.
16:54:15 <glguy> Is there a mailing list thread about this?
16:54:32 <ski> > [pred, id, succ] `flip` 42
16:54:33 <lambdabot>   [41,42,43]
16:54:53 <shachaf> > [pred, id, succ] `sequence` 42
16:54:54 <lambdabot>   [41,42,43]
16:55:20 <ion> > Just length `flip` "foo"
16:55:22 <lambdabot>   Just 3
16:55:29 <shachaf> dylukes: Derive MonadProcess or something like that, presumably.
16:55:37 <ion> > length `fmap` Just "foo"
16:55:39 <lambdabot>   Just 3
16:55:51 <dylukes> I'm not sure how MonadProcess would look ;~;
16:56:03 <dylukes> I'm terrible/new to transformers and etc
16:56:16 <ski> dylukes : make a new function `liftProcessMtoOTPProc :: ProcessM a -> OTPProc s a' (possibly with a more verbose name) ?
16:57:10 <dylukes> ;~;
16:57:12 <dylukes> still a bit unsure.
16:57:17 <shachaf> lift''ProcessM'a''to''OTPProc's'a
16:57:22 <dylukes> >_>
16:57:26 * ski wonders why `withOTP' doesn't have type `s -> OTPProc s a -> ProcessM a' (or preferably flipped ?)
16:57:44 <dylukes> oh, whoops, should be a
16:57:48 <dylukes> and it doesn't because of how it's used
16:57:49 * shachaf hopes OTP isn't "Open Telecom Platform".
16:57:56 <DanBurton> ion++
16:57:58 <dylukes> shachaf: it may or may not be.
16:58:12 * shachaf would recommend not using the Erlang name.
16:58:21 <dylukes> shachaf: It's a placeholder name.
16:59:04 <ion> > Just length <*> Just "foo"
16:59:05 <lambdabot>   Just 3
16:59:31 <Saizan> glguy: yep, but it'll work even when you can't exploit the MR for result
16:59:44 * ski wonders why `terminate' is invisible in the source
17:00:24 <ski> (.. oh, that's possibly errors from an earlier version)
17:00:57 <Saizan> ion, kmc: the "debate" being if it's always possible to do without ScopedTypeVariables by using `asTypeOf` and similar
17:01:51 <ion> I don’t see how the fix trick changes anything in that regard.
17:02:09 <glguy> In this case it might be better to use a custom "fix" which passes "error "don't use this argument"" instead of the actual fixpoint
17:02:24 <glguy> to avoid the loop when you screw up :)
17:02:54 <ion> glguy: Yeah, what i did only works when you make extra sure there’s no recursion. :-)
17:03:18 <dylukes> now how to define liftOTP .__.
17:03:31 <Saizan> ion: glguy's version works only because result has a typeclass context so gets monomorphized by the MR
17:04:02 <dylukes> orite
17:04:26 <glguy> Saizan: so I guess next we need an example problem where you don't have a type-class to help
17:04:34 <glguy> without the type class it doesn't really matter what type it was
17:05:45 <Saizan> or you can see it the other way around :)
17:09:07 <hpaste> geheimdienst pasted “creative-argument-parsing” at http://hpaste.org/51817
17:09:38 <geheimdienst> dear haskell hive mind, please give me feedback on these 6 lines ^^
17:10:30 <ion> repeat Nothing
17:10:49 <Eduard_Munteanu> Can haskell-src-exts operate on compiled modules?
17:11:16 <mauke> geheimdienst: cycle [x] = repeat x
17:11:16 <geheimdienst> ion: oh right, thanks :)
17:11:22 <mauke> damn
17:11:35 <Eduard_Munteanu> I'm looking for a nice way to extract exported things and types from a Haskell module.
17:11:48 <mauke> (rawPath : prefix : suffix : []) = [rawPath, prefix, suffix]
17:12:14 <Eduard_Munteanu> (preferably without having it look at the source)
17:12:16 <ski> dylukes : it writes itself more or less, no ?
17:12:27 <geheimdienst> > let [a,b] = [42,37] in (a,b)
17:12:28 <lambdabot>   (42,37)
17:12:30 <mauke> zipWith fromMaybe [error "omg no arguments", "-", ""]
17:12:30 <dylukes> no, I decided to take a different approahc.
17:12:31 <Eduard_Munteanu> There's also the GHC API but it looks a bit twisted.
17:12:37 <ski> (just use your inner djinn !)
17:12:45 <dylukes> a lift-to is inconsistent, so I'm writing a lift-from ProcessM
17:12:49 <geheimdienst> mauke: right, good catch
17:12:50 <dylukes> adding a MonadProcessM class.
17:13:18 <dylukes> https://gist.github.com/1243989
17:13:32 <dylukes> I'm not good at reasoning about these things yet
17:13:40 <dylukes> I'm also not sure how to introduce the state :|
17:14:00 <ski> dylukes : are you going to have more than one instance of the class ?
17:14:10 <dylukes> ski: I might.
17:14:21 <dylukes> It's quite likely, anyhow.
17:15:20 <geheimdienst> okay, thanks guys :)
17:17:20 <dylukes> hm, I have an idea
17:17:25 <DanBurton> geheimdienst: this is getting a little picky, but `mapM_ print [rawPath, prefix, suffix]` is a little shorter than a separate print line for each one
17:18:05 <kfhn> is it possible to define several different tuple patterns for the same function, like one pattern for (x,y) and one for (x,y,z)?
17:18:09 <geheimdienst> DanBurton: yeah, that was just for illustration/testing. the actual program actually does something with those :)
17:18:17 <shachaf> kfhn: What does that mean?
17:18:30 <mauke> DanBurton: print [rawPath, prefix, suffix]
17:18:42 <DanBurton> mauke: but that doesn't put them on separate lines
17:18:57 <mauke> this is just for testing anyway
17:18:58 <ion> mapM_ print [rawPath, prefix, suffix]
17:19:03 <shachaf> p[r,p,s]
17:19:04 <sal23> I am looking around in GHC source for >>= definition of [a]…what are the usual steps for looking it up? I did recursive find and grep for >>= under libraries/ but found only ListT implementation, not [a]
17:19:12 <mauke> @src [] >>=
17:19:12 <lambdabot> Source not found. Wrong!  You cheating scum!
17:19:18 <mauke> @src [] (>>=)
17:19:18 <lambdabot> xs >>= f     = concatMap f xs
17:19:47 <shachaf> sal23: :i [] in ghci.
17:19:58 <sal23> ha, yeah, forgot that
17:20:00 <geheimdienst> sal23: i don't think you'd normally dive into ghc source. you can just hayoo or hoogle and click the "source" link next to the function
17:20:04 <geheimdienst> @hoogle (>>=)
17:20:05 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
17:20:05 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
17:20:05 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
17:20:36 <dylukes> .__.
17:20:39 <dylukes> ski: I feel so stupid now.
17:20:44 <dylukes> OTProc . lift
17:20:46 <dylukes> derp
17:21:08 <kfhn> fun (x,y) = x+y     is it possible to make   fun (x,y,z) = x + y +z      too?
17:21:29 <mauke> kfhn: what would fun's type be?
17:22:34 <shachaf> TupleSum a => a -> Int
17:22:49 <mauke> shachaf: that's not H98!
17:22:58 <shachaf> mauke: Who cares about H98?
17:23:04 <kfhn> sorry I'm newbeish, some kind of generic tuple?
17:23:10 <mauke> kfhn: there are no generic tuples
17:23:11 <ion> sal23: I hoogled for (>>=), clicked the only result, saw that the instance list had [], clicked Source for class Monad m, got to http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#Monad and scrolled down a bit.
17:23:14 <shachaf> kfhn: The short answer is "you don't want to do that".
17:23:53 <geheimdienst> kfhn: if you need something of variable length, you probably want a list ... [1,2,3]
17:24:05 <sal23> ion: thanks…that is exactly what I was trying to learn
17:24:17 <kfhn> should I use Dynamics in a List instead?
17:24:21 <shachaf> kfhn: No.
17:24:40 <shachaf> mauke: Hmm, are you sure it can't be done in H98?
17:25:02 <mauke> shachaf: I have my doubts about the instances
17:25:36 <ion> sal23: But as shachaf said, ‘:i []’ in ghci gives the module directly. That’s a more reliable method.
17:26:00 <ski> kfhn : if you're thinking about using `[Dynamic]', you're *probably* better for using separate functions instead
17:26:15 <shachaf> mauke: Oh, because it's distinct types. Hmm.
17:26:46 <ski> (to paraphrase an old saying : you should only use `Dynamic' if you know why you shouldn't use it)
17:26:50 <shachaf> mauke: No, you can do it.
17:26:54 <sal23> ion: yep, I use :i in ghci but didn't know I could do ":i [] (>>=)"
17:27:09 <mauke> shachaf: how?
17:27:24 <shachaf> class Foo a where foo :: a -> Integer
17:27:38 <ion> sal23: I think that just prints the same results as ‘:i []’ and ‘:i (>>=)’ separately.
17:27:38 <shachaf> instance (Integral a, Integral b) => Foo (a,b) where foo (x,y) = toInteger x + toInteger y
17:28:05 <co1in> register co1in
17:28:21 <shachaf> identify co1in hunter2
17:28:42 <kmc> Saizan, hm, I thought it was already know to be possible
17:28:45 <ion> sal23: ‘:i []’ tells you the Monad instance is defined in GHC.Base which you can hoogle or look up in the source tree. It’s just coincidental the [] instance definition happened to be in the same file as the class definition.
17:29:33 <ion> identify co1in correct horse battery staple
17:30:03 <shachaf> mauke: It's the same trick Printf uses, isn't it?
17:30:11 <dmwit> I wonder whether Haddock has any plans for documenting orphan instances.
17:30:34 <mauke> shachaf: ah, like that
17:32:14 <dmwit> kfhn: Why bother, when we can already perfectly well write sum [x,y] and sum [x,y,z]?
17:32:24 <dmwit> > [sum [x,y], sum [x,y,z]]
17:32:25 <lambdabot>   [0 + x + y,0 + x + y + z]
17:32:41 <co1in> hi folks. I am resuming a haskell project after the summer. Foolishly, perhaps, I updated all the bits. I notice that the "binary" package is now hidden. Does that mean I should use something else?
17:32:46 <dmwit> Just use sharper parentheses and you're there. =)
17:32:55 <shachaf> > [foldl1' (+) [x,y], foldl1' (+) [x,y,z]]
17:32:55 <ion> Has anyone came up with a trick to type ‘id :: Foo -> Foo’ without the repetition (and without something as long as (`asTypeOf` (undefined :: Foo)), while we wait for someone to add (:: Foo) sugar to Haskell ;-)?
17:32:56 <lambdabot>   [x + y,x + y + z]
17:33:22 <bahblah> how do you know when to use foldr vs foldl??
17:33:24 <shachaf> co1in: I don't think so?
17:33:31 <shachaf> @google foldr vs foldl
17:33:32 <lambdabot> http://stackoverflow.com/questions/384797/implications-of-foldr-vs-foldl-or-foldl
17:33:32 <lambdabot> Title: haskell - Implications of foldr vs. foldl (or foldl') - Stack Overflow
17:33:58 <co1in> thank you shachaf
17:34:05 <kfhn> so there isn't an obvious way to deconstruct an abitrary tuple into say a [Dynamic] or similar?
17:34:15 <sal23> ion: yep, found it in GHC/Base.lhs…so, basically look up info in ghci, and use that to look up source
17:34:17 <shachaf> co1in: ...Was that particularly helpful?
17:34:21 <dmwit> bahblah: Is your operator left-associative or right-associative? ;-)
17:34:30 <shachaf> co1in: Why is it hidden? Can you provide more context?
17:34:42 <shachaf> kfhn: Dynamic is typically a bad idea.
17:35:08 <dmwit> kfhn: There probably is a way. But if you don't know how now, you probably should try to do something else.
17:35:22 <co1in> shachaf: It just seems to come that way after having installed the current x86_64 platform and ghc-7.2.1 (which is needed for Lion).  (Actually it was the Lion upgrade, and not the Haskell upgrade, that was risky :)
17:35:35 <mauke> ion: type Endo a = a -> a
17:35:41 <mauke> ion: id :: Endo Foo
17:36:24 <co1in> When I try to compile my code, it says "Could not find module `Data.Binary.Get'
17:36:24 <co1in>     It is a member of the hidden package `binary-0.5.0.2'.".  It felt like this was a kind of deprecation
17:36:30 <shachaf> co1in: Compile it with cabal?
17:36:39 <shachaf> co1in: Maybe it just needs to be in the dependency list? :-)
17:37:03 <mauke> co1in: what command are you using to compile it?
17:37:13 <co1in> "cabal install binary"
17:37:15 <shachaf> COMPILE.EXE
17:37:30 <shachaf> co1in: "cabal install binary" is giving you an error saying binary is hidden?
17:37:33 <co1in> Actually, "cabal install binary —reinstall" seems to have worked!
17:37:46 <co1in> No, I get the error when I build my code with ghc —make *.hs
17:37:52 <co1in> (I don't say *.hs, but you get the idea)
17:37:57 <DanBurton> is there a GHC extension for type-level lambdas? like \a -> Either b a ?
17:38:15 <mauke> DanBurton: probably not; that would do funky things to the type system
17:38:28 <DanBurton> mauke: such as?
17:39:00 <mauke> I don't remember the details; probably undecidability/turing completeness
17:39:07 <ion> If you want an initial accumulator which you’ll update for each list item and get the result upon reaching the end of the list, use foldl'. If you want to fold potentially infinite lists lazily and *don’t* need to use the accumulator strictly in your fold function, use foldr.
17:39:30 <DanBurton> @google haskell type-level lambda
17:39:32 <lambdabot> http://www.haskell.org/haskellwiki/Type_arithmetic
17:39:32 <lambdabot> Title: Type arithmetic - HaskellWiki
17:40:18 <dylukes> can anyone tell me how to set the load path from within GHC?
17:40:34 <dmwit> :set -i, probably
17:40:44 <DanBurton> GHC or ghci?
17:41:00 <dylukes> ghci
17:41:11 <dmwit> Hm, :set -i doesn't seem to work.
17:41:17 <dylukes> I'm in emacs in Foo.Bar.Baz and I want to import Foo.Q.Z
17:41:21 <DanBurton> @wiki ghci
17:41:22 <lambdabot> http://www.haskell.org/haskellwiki/ghci
17:41:37 <dmwit> dylukes: Do you know how to do it from the command line?
17:41:52 <dylukes> dmwit: ghci? sure.
17:41:55 <dylukes> I just don't feel like it :P
17:42:00 <dylukes> and its more convenient to have my emacs ghci instance
17:42:19 <dmwit> dylukes: I'm asking because it's usually straightforward to convert the command-line thing to within ghci.
17:42:25 <dmwit> Not because I'm asking you to do it from the command line.
17:42:32 <ion> bahblah: ↑ I think that’s about it, but i’m sure someone will correct or supplement it.
17:42:40 <dylukes> :\
17:42:50 <dmwit> dylukes: (...and I don't know how to do it from the command line, hence the question.)
17:43:29 <dmwit> So... how do you do it from the command line?
17:44:00 <dylukes> ummm
17:44:05 <dylukes> start ghci with -i ?
17:44:13 <dmwit> Nope.
17:44:16 <dmwit> Just tested it.
17:44:24 <dmwit> Otherwise :set -i would be the answer.
17:44:40 <dmwit> You can change directory with :cd. Is that enough for you?
17:45:25 <dmwit> (-i only seems to affect where it looks for things imported by modules it's loading, not for the file you actual :load.)
17:49:56 <bahblah> is foldr and foldl more canonical over the use of recursion?
17:50:43 <DanBurton> bahblah: more idiomatic, yes. that's why they exist
17:51:05 <dylukes> dmwit: thats what I need
17:51:20 <dylukes> ah, I see the problem here
17:51:29 <DanBurton> bahblah: use of filter and map are even more encouraged, if they solve the problem you have
17:51:46 <bahblah> i'm fine with the abstractions provided by filter and map
17:52:01 <bahblah> but having trouble wrapping my mind around foldr and foldl
17:52:09 <bahblah> i've only been familiar with reduce
17:52:11 <dylukes> every time I load it it does
17:52:11 <dylukes> Prelude> :cd /Users/dlukes/Documents/Projects/CloudHaskell-OTP/
17:52:12 <dylukes> Prelude> :load "src/Remote/OTP/OTPProc.hs"
17:52:21 <dylukes> I don't know why it decides to go there of all places.
17:53:05 <bahblah> especially with the implications of laziness and the possibility of stack overflows with foldr and foldl
17:53:07 <dylukes> oh but it magically works now, odd
17:53:56 <blackdog> so, i want to be able to call modifyMVar, but in the Yesod GGHandler monad stack
17:53:59 <blackdog> at the moment, i'm doing a hacky "liftIO $ takeMvar mvar; mystuff; liftIO $putMVar mvar" sort of thing. is there a better way?
17:54:26 <blackdog> if I call liftIO on the action itself, it doesn't work because it wants to run in that stack, not in IO
17:55:44 <DanBurton> bahblah: as long as you're not dealing with infinite lists, if you're not sure about the laziness, then use foldl' which is strict
17:56:20 <DanBurton> > foldl' (+) [1..1000]
17:56:21 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
17:56:21 <lambdabot>    arising from a us...
17:56:27 <bahblah> and if dealing iwth infinite lists...foldr is the way to go?
17:56:51 <DanBurton> bahblah: yeah. that or give up; at least foldr might be able to help you extract partial results ;)
17:57:04 <DanBurton> there is, of course, no way to traverse an infinite list
17:57:20 <DanBurton> *entirely
17:57:41 <dylukes> DanBurton: sure there is, it just takes infinite time
17:57:41 <DanBurton> > foldl' (+) 0 [1..1000]
17:57:43 <lambdabot>   500500
17:57:50 <DanBurton> @botsnack
17:57:50 <lambdabot> :)
17:58:05 <bahblah> > foldl1' (+) [1..1000]
17:58:06 <lambdabot>   500500
17:58:25 <dylukes> @help
17:58:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:58:29 <dylukes> @list
17:58:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:58:30 <DanBurton> dylukes: no human or computer that I know of can last for infinite time, though :P
17:59:15 <JoeyA> What is a suitable punishment for not providing type signatures for top-level definitions?
17:59:25 <dobblego> a type error
17:59:33 <JoeyA> :-)
17:59:40 <blackdog> JoeyA: i'd like to tell you, but i don't think i will. you can ask me questions, though.
17:59:40 <ion> -Wall -Werror
17:59:50 * DanBurton hides, having occasionally not provided type signatures for top-level definitions
18:00:27 <JoeyA> I find that they are crucial for making Haskell code readable.
18:00:55 <DanBurton> sometimes I like to make a function a TLD, but its function is clear enough from how it is written
18:01:03 <DanBurton> *its name
18:02:03 <DanBurton> does main need a type signature?
18:02:09 <JoeyA> that's one I usually omit
18:02:19 <JoeyA> but I've started putting it to make ghc -Wall happy.
18:03:13 <DanBurton> I need to start using ghci with -Wall. I just do Haskell for fun and almost never actually compile with ghc
18:03:24 <JoeyA> An example from the 'email' package: sendSimpleEmail backend from to subject text = ...
18:03:36 <JoeyA> Maybe I can figure out what it does, but what types does it work with?
18:03:42 <DanBurton> lol
18:03:54 <DanBurton> good point
18:04:04 <Axman6> check out mimi-mail
18:04:07 <Axman6> mime*
18:04:55 <KirinDave> I am trying to build some libraries under 7.2.1
18:05:19 <KirinDave> https://gist.github.com/655f459907a033cadad3
18:05:21 <JoeyA> Axman6: Thanks, that's what I was looking for (even though I omitted the question ;-) )
18:05:27 <hpaste> mkscrg pasted “Unfamiliar record syntax” at http://hpaste.org/51818
18:05:29 <KirinDave> I do not get why that is failing, anyone have any ideas?
18:05:30 <Axman6> =)
18:05:32 <mkscrg> can someone explain this syntax to me? i think it's enabled by some extension i'm not familiar with: http://hpaste.org/51818
18:06:26 <KirinDave> I don't get why it's saying -any
18:06:26 <Axman6> i think it's the record puns extension
18:06:32 <KirinDave> And also, stream is installed
18:06:32 <Cale> mkscrg: That's record wildcard syntax
18:06:43 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html#v:RecordWildCards
18:06:45 <Axman6> or wildcards...
18:06:57 <Cale> mkscrg: It takes the values for the fields from definitions of the same names that are in scope
18:06:58 <Axman6> what are record puns?
18:07:22 <Cale> puns is where you can pattern match like   foo (Thing { thingName, thingColor }) = ...
18:07:37 <mkscrg> Cale: thanks. i'm debugging someone else's code and was pretty confused
18:07:55 <DanBurton> tbh puns kinda weird me out, cuz of the shadowing
18:09:01 <Cale> It can be pretty convenient though
18:09:11 <Cale> if you don't need the field extractors locally
18:10:09 <JoeyA> If you do, then use lambda-case! :-)
18:10:53 <JoeyA> err, no need for it
18:11:15 <JoeyA> err, won't work, as nested patterns will shadow parents.
18:12:00 <JoeyA> I guess it would be nice if you can do:  foo (Thing { a <- thingName, b <- thingColor })
18:12:06 <JoeyA> = ...
18:13:07 <JoeyA> Wasn't sure about a = thingName, since using record syntax on the RHS is: thingName = ...
18:15:43 <ski> JoeyA : well, since you can say `Things { a = thingName , b = thingColor }' as an expression, the natural thing would be to reuse the same syntax in patterns, if it makes sense (and it does)
18:16:36 <JoeyA> ski: Even when a and b aren't selectors of Things?
18:16:42 <geheimdienst> what's that "Thing { a <- thingName" syntax? never seen an <- before in that place
18:16:54 <JoeyA> I made it up.
18:17:04 <ski> well, `a' and `b' must be field names of the record, otherwise it doesn't work
18:17:05 <geheimdienst> oh i see :D
18:17:47 <JoeyA> ski: In the example, thingName and thingColor were the fields.
18:17:49 <KirinDave> Maybe I need to rebuild cabal-install from darcs.
18:18:32 <ski> no, `thingName',`thingColor' were the expressions with which the fields were initialized / the patterns with which the values of the fields were matched
18:18:41 <ski> JoeyA ^
18:19:10 <mauke> ski: no, they're field names
18:19:23 <ski> this is assuming something like `data ... = Things { a :: ... , b :: ... }'
18:19:38 <geheimdienst> KirinDave: i think you just need to install the Stream package
18:19:53 <KirinDave> geheimdienst: I did.
18:20:17 <ski> mauke : if they're field names, one would have had to flip the left- and right- hand sides of the `='s
18:20:22 <geheimdienst> is it hidden? try "ghc-pkg list". if it's blue, it's hidden
18:20:25 <mauke> yes
18:20:33 <ski> (and JoeyA didn't do that)
18:22:54 <JoeyA> It'd be fun to write a simple library for colors that lets you do things like: bluish $ greenish red
18:23:56 <mauke> 0.1 `blueish` red
18:24:22 <geheimdienst> bright red, dark red ...
18:24:38 <mauke> 0.1 `blueish` bright red
18:24:55 <geheimdienst> ... this might actually be a good idea
18:25:01 <JoeyA> (blue * 0.1) `ish` red
18:25:14 <KirinDave> Ugh
18:25:23 <KirinDave> So even though I have stream-0.4.2 installed
18:25:31 <KirinDave> which i did by manually tweaking its cabal file.
18:25:50 <KirinDave> but now when I try to cabal-install elsewhere
18:25:52 <KirinDave> it cries out
18:25:59 <mauke> KirinDave: what does ghc-pkg list say?
18:26:01 <KirinDave> "No, I need base <4.4
18:26:06 <KirinDave> mauke: It agrees I have it installed
18:26:19 <Hannspree> who wants to see me and my girlfriends get wet and strip?
18:26:32 <mauke> idoru++
18:27:25 <donri> during cabal install snap: http://paste.pocoo.org/show/483074/ is my ghc broken?
18:27:55 <shachaf> donri: Looks broken.
18:28:29 <geheimdienst> donri: some kind of 32 vs 64 bit snafu? i notice there's x86_64 in the output
18:28:32 <donri> from ppa:mbeloborodiy/ppa, that guy hang out here bychance?
18:28:34 <shachaf> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=622731
18:28:35 <mauke> donri: http://hackage.haskell.org/trac/ghc/ticket/5004
18:33:52 <redgetan> join #emacs
18:34:54 <ski> (.. already there)
18:34:56 * hackagebot composition 0.2 - Combinators for unorthodox function composition  http://hackage.haskell.org/package/composition-0.2 (DanBurton)
18:37:47 <MarkDBlackwell> Please forgive my newbishness; I'm considering porting some Ruby methods to Haskell. I've already done Enumerable#each_cons (for 'each consecutive'), which, from a list, makes a list of short lists: e.g., eachCons 4 [1,2,3,4,5,6] would be [[1,2,3,4],[2,3,4,5],[3,4,5,6]]. It was useful in solving Euler's problem number eight: given a huge number, find the five consecutive digits with the...
18:37:49 <MarkDBlackwell> ...greatest product. Am I right that there isn't such a function in Haskell, already?
18:38:46 <DanBurton> stop...Hoogle time
18:39:00 <DanBurton> @hoogle Int -> [a] -> [[a]]
18:39:01 <dobblego> can't Hoogle this
18:39:01 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
18:39:01 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:39:01 <lambdabot> Prelude take :: Int -> [a] -> [a]
18:39:11 <dobblego> Data.List.Split by the way
18:39:58 <geheimdienst> > map (take 4) $ tails [1..6]
18:39:59 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6],[5,6],[6],[]]
18:40:09 <geheimdienst> MarkDBlackwell: you might be interested in that ^^
18:40:25 <shachaf> MarkDBlackwell: There isn't one built-in, but you can do something geheimdienst-style.
18:40:46 <shachaf> However, that'll give you those last n elements, which you probably don't want.
18:40:55 <geheimdienst> filter it for only lists of length 4 and you're good to go. i used only the most basic functions (= Prelude functions)
18:41:11 <DanBurton> > map (take 4) $ filter (\xs -> length xs == 4) tails [1..6]
18:41:11 <shachaf> geheimdienst: :-(length)
18:41:12 <lambdabot>   Couldn't match expected type `[[a]]'
18:41:12 <lambdabot>         against inferred type `[a1] ->...
18:41:20 <DanBurton> > map (take 4) $ filter (\xs -> length xs == 4) $ tails [1..6]
18:41:21 <lambdabot>   [[3,4,5,6]]
18:41:31 <DanBurton> waitaminute
18:41:38 <DanBurton> let me try that again
18:41:50 <DanBurton> > filter (\xs -> length xs == 4) $ map (take 4) $ tails [1..6]
18:41:51 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:42:00 <DanBurton> filter after map, derp
18:42:09 <ski> hm .. `forall as,n. length as = n => length (eachCons 0 as) = n+1'
18:42:42 <geheimdienst> shachaf: u no likes a length? wat wuld u make insted??
18:42:59 <BMeph> Actually, since it starts there, takeWhile might be a better choice than filter. :)
18:43:14 <DanBurton> I was thinking that too
18:43:29 <ski> hm, some kind of list subtraction thingie might be handy
18:43:46 <DanBurton> @src (//)
18:43:46 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
18:43:50 <BMeph> > takeWhile (not . null . drop 3) . map (take 4) $ tails [1..6]
18:43:52 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:44:55 <donri> tails?
18:44:59 <shachaf> BMeph++
18:45:03 <shachaf> Not as if it matters, of course.
18:45:25 <geheimdienst> i think the (not . null . drop 3) thing is kinda roundabout ...
18:45:55 <shachaf> @let notNullDrop n = not . null . drop n
18:45:56 <lambdabot>  Defined.
18:46:03 * shachaf takes a bow.
18:46:13 <Cale> > ap (zipWith const) (drop 4) . map (take 4) . tails $ [1..6]
18:46:15 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:46:31 <DanBurton> let foo n xs = take (length xs - n + 1) . map (take n) . tails xs
18:46:31 <Cale> kekeke
18:46:32 <BMeph> @let unTake n = not . null . drop (pred n)
18:46:33 <lambdabot>  Defined.
18:46:37 <DanBurton> @let foo n xs = take (length xs - n + 1) . map (take n) . tails xs
18:46:39 <lambdabot>  Defined.
18:46:46 <DanBurton> > foo [1..6] 4
18:46:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:46:48 <lambdabot>         against inferred type ...
18:46:53 <DanBurton> doh
18:46:55 <BMeph> That way, you can use the same 'n' for that, and the take in the map. ;)
18:46:58 <ski> @src tails
18:46:59 <lambdabot> tails []         = [[]]
18:46:59 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
18:47:02 <ski> donri ^
18:47:04 <Cale> > (zipWith const <*> drop 4) . map (take 4) . tails $ [1..6]
18:47:06 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:47:09 <Cale> > (zipWith const <*> drop 4) . map (take 4) . tails $ [1..10]
18:47:11 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10]]
18:47:23 <ski> > tails "abcd"
18:47:24 <lambdabot>   ["abcd","bcd","cd","d",""]
18:47:26 <DanBurton> > foo 4 [1..6]
18:47:27 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
18:47:27 <lambdabot>    arising from a use...
18:47:30 <donri> ski: i don't have it, new since something?
18:47:38 <DanBurton> :t foo
18:47:39 <Cale> Computing lengths is admitting defeat
18:47:39 <geheimdienst> cale: can you pull the 4 out? pointless plz
18:47:40 <lambdabot> forall a. Int -> [[a]] -> [[[a]]]
18:47:40 <geheimdienst> ;)
18:47:43 <luqui> :t foo
18:47:44 <lambdabot> forall a. Int -> [[a]] -> [[[a]]]
18:47:57 <Cale> I guess I could...
18:48:06 <Cale> But it'd make it ugly
18:48:10 <BMeph> Cale: Computing a length you don't care about is admitting defeat. ;)
18:48:17 <luqui> foo 2 [[1,2,3],[4,5,6]]
18:48:18 <geheimdienst> cale: i was kidding
18:48:20 <luqui> > foo 2 [[1,2,3],[4,5,6]]
18:48:21 <lambdabot>   [[[1,2]],[[4,5]],[]]
18:48:22 <DanBurton> @let foo n xs = take (length xs - n + 1) . map (take n) . tails $ xs
18:48:23 <lambdabot>  <local>:12:0:
18:48:23 <lambdabot>      Warning: Pattern match(es) are overlapped
18:48:23 <lambdabot>               I...
18:48:30 <ski> > (map (tail . inits) . tails) "abcd"
18:48:32 <lambdabot>   [["a","ab","abc","abcd"],["b","bc","bcd"],["c","cd"],["d"],[]]
18:48:38 <ski> @index tails
18:48:38 <lambdabot> Data.List
18:48:42 <ski> donri ^
18:48:44 <DanBurton> you guys mind if I undefine?
18:48:58 <donri> oh so the "only prelude" was a lie :)
18:49:05 <mkscrg> was there some change between 7.0.3 and 7.2.1 that was related to the RecordWildCards extension?
18:49:06 <DanBurton> @let foo2 n xs = take (length xs - n + 1) . map (take n) . tails $ xs
18:49:07 <lambdabot>  Defined.
18:49:12 <mkscrg> i.e. that might break code that used it?
18:49:20 <DanBurton> > foo2 4 [1..6]
18:49:22 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:49:26 <Cale> mkscrg: Not that I'm aware of
18:50:06 <luqui> wtf ubuntu, get with the program.  i'm stuck here at 6.12
18:50:10 <mkscrg> Cale: ok. I found some code that uses it, works on 7.0.3, is broken on 7.2.1, and works when the code is refactored to avoid using the extension
18:50:11 <ski> @remember Cale Computing lengths is admitting defeat
18:50:12 <lambdabot> It is forever etched in my memory.
18:50:16 <mkscrg> weird
18:50:31 <DanBurton> @pl let foo3 n xs = take (lengt xs - n + 1) . map (take n) . tails $ xs in foo3
18:50:32 <lambdabot> join . ap (flip . (((.) . take) .) . flip flip 1 . ((+) .) . flip ((-) . lengt)) ((. tails) . map . take)
18:50:56 <DanBurton> @pl let foo3 n xs = take (length xs - n + 1) . map (take n) . tails $ xs in foo3
18:50:56 <lambdabot> join . ap (flip . (((.) . take) .) . flip flip 1 . ((+) .) . flip ((-) . length)) ((. tails) . map . take)
18:51:03 <DanBurton> missed the h in length xP
18:51:17 <luqui> woah
18:51:20 <luqui> flip flip 1
18:51:27 <luqui> :t flip flip 1
18:51:28 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num a) => f (a -> b) -> f b
18:51:48 <DanBurton> back to flip flip are we? xD
18:51:53 <DanBurton> :t flipflip
18:51:55 <lambdabot> forall t t1 t2. t -> (t1 -> t -> t2) -> t1 -> t2
18:52:06 <DanBurton> @src flipflip
18:52:06 <lambdabot> Source not found. You type like i drive.
18:52:11 <luqui> :t flip flip
18:52:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
18:52:19 <DanBurton> aw forgot how I defined it
18:52:22 <luqui> oh something funny about this flip
18:52:23 <luqui> :t flip
18:52:23 <ski> @type Prelude.flip Prelude.flip 1
18:52:24 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:52:24 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
18:52:37 <donri> it's shit like this, haskell
18:52:55 <Cale> kekeke
18:52:56 <ski> luqui : what !?, it's a straight-forward generalization
18:53:07 <luqui> yes, it is
18:53:10 <luqui> i just wasn't expecting it
18:53:20 * ski coughs
18:53:30 <luqui> and flip is a pretty terrible name
18:53:34 <luqui> for this new thing
18:53:44 <ski> would `transpose' be better ?
18:53:51 <donri> flipflop
18:53:57 <DanBurton> wibblewobble
18:54:07 <ski> (<http://www.funmath.be/> calls it "transposition")
18:54:13 <donri> one art please
18:55:00 <luqui> ooh funmath looks... fun
18:55:22 * ski . o O ( <http://remix.kwed.org/download.php/2047/Lagerfeldt%20-%20Flip%20the%20Flop%20%28Rock%20My%20Commodore%29.mp3> )
18:57:44 <johnFreeman> Coming from Flash: any similarities between flash and haskell?
18:57:59 <johnFreeman> (and yes, I know one is functional and other is imperitive)
18:58:20 <ben> I thought flash was for playing videos
18:58:40 <BMeph> flash is functional? ;þ
18:58:41 <DanBurton> johnFreeman: you mean ActionScript?
18:59:14 <johnFreeman> BMeph: it isn't!
18:59:19 <johnFreeman> DanBurton: Okay, sure
18:59:31 <johnFreeman> Just like flash games and such I know how to program in
18:59:59 <luqui> AS supports HOFs right?
19:00:03 <DanBurton> well Haskell doesn't come with a suite for making stuff like Adobe...er...whatever it is that they give you to make flash stuff
19:00:23 <johnFreeman> Adobe Flash
19:00:31 <moriramar> Excuse me, does Control.Monad.ST.ST have anything to do with Control.Monad.State.StateT?
19:00:41 <johnFreeman> I think either 10 or 11 is the newest version
19:00:43 <luqui> so Haskell will help you to think about code in a way that you can write very compact ActionScript code that nobody but other haskell programmers can understand
19:00:43 <DanBurton> isn't there some IDE?
19:01:03 <DanBurton> luqui: lol
19:01:20 <mauke> moriramar: no
19:01:34 <moriramar> mauke, Ahh, thanks. I got confused again...
19:01:49 <kmc> johnFreeman, Haskell is also imperative.  http://haskell.org/haskellwiki/FAQ#Wait.2C_is_Haskell_imperative_or_is_it_functional.3F
19:02:06 <kmc> paradigms describe code styles, not languages
19:02:06 <kmc> and they're an intellectual crutch
19:02:10 <kmc> learn all the techniques and use them as appropriate
19:02:21 <luqui> i believe it is spelled
19:02:24 <luqui> learn ALL THE TECHNIQUES
19:02:34 <DanBurton> oh it's called Adobe Flash Builders xP
19:02:36 <DanBurton> the IDE
19:02:44 <DanBurton> *Builder
19:02:44 <johnFreeman> luqui: then why do they only teach java/flash in uni?
19:02:49 <luqui> which uni?
19:03:00 <johnFreeman> most Australian ones
19:03:10 <kmc> johnFreeman, don't know, but it's lamentable
19:03:11 <kmc> http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html
19:03:13 <blackdog> johnFreeman: that's not true.
19:03:19 <johnFreeman> Althought UNSW teaches Haskell
19:03:19 <blackdog> I taught Haskell at UNSW and Sydney
19:03:25 <MarkDBlackwell> Thanks, DanBurton (and others)! In Prelude, your foo2 worked well for me:   foo2 n xs = take (length xs - n + 1) . map (take n) . tails $ xs     . So, I'm thinking of doing a module with all the Ruby methods, wouldn't that invite Ruby programmers more? (In addition to making a lot of unidiomatic  Haskell code, of course.)
19:03:40 <blackdog> MarkDBlackwell: i reckon a cheat sheet would be better.
19:03:50 <luqui> blackdog++
19:03:53 <johnFreeman> blackdog: well I mean Victoria ones
19:04:02 <DanBurton> MarkDBlackwell: I think a module wouldn't hurt though
19:04:09 <blackdog> johnFreeman: and Macquarie has a bunch of FP hackers, although i don't know if they have a course
19:04:15 <DanBurton> the docs could serve as a cheat sheet
19:04:29 <blackdog> yeah, don't know about melbourne. i think they're all too-cool-for-school fixie-riding rubyists :)
19:04:43 <DanBurton> MarkDBlackwell: what exactly are the ruby methods that you wish were in Prelude?
19:04:45 <dobblego> I teach Haskell voluntarily because the unis around here are afraid of making sense
19:05:15 <MarkDBlackwell> blackdog, thanks; a cheat sheet -- better and easier!
19:05:21 <luqui> when tu esta learnando espanol, do tu usar englisho words o do tu usar un dictionario?
19:05:28 <blackdog> the split
19:05:39 <blackdog> urk. the split stuff is the worst - i think most rubyists expect it to be included
19:05:55 <johnFreeman> blackdog: Java has a split method in the String class
19:05:55 <blackdog> where instead we have a couple of funny specialised versions like words and lines
19:06:03 <MarkDBlackwell> All of them, for Rubyist comfort, is the idea. :)
19:06:27 <MarkDBlackwell> (DanBurton)
19:06:28 <blackdog> MarkDBlackwell: i take it you're a rubyist getting your feet wet in FP?:)
19:06:45 <johnFreeman> what's FP?
19:06:49 <blackdog> i've been trying to get the rubyists in for ages. we need more web types.
19:06:52 <blackdog> functional programming
19:06:52 <donri> file pointer
19:07:01 * incluye is a former rubyist
19:07:28 <DanBurton> blackdog: plenty of rubyists are aready into FP; ruby blocks are just a handy syntax for higher order functions
19:07:30 <johnFreeman> my friend who is a games developer in Java said ruby is useless. He was forced to use it for his server
19:07:41 <johnFreeman> as in useless with Java etc
19:07:42 <MarkDBlackwell> blackdog, Feet wet, yes, just starting; finished through the modules chapter in _Learn You a Haskell For Great Good_. :)
19:08:08 <DanBurton> I love LYAH. So much. It's what started me on Haskell, too.
19:08:32 <MarkDBlackwell> blackdog, a Rubyist, yes, previously Java, C++, Fortran; Algolish. Love functional-style programming in Ruby. :)
19:08:37 <blackdog> DanBurton: Functional means that the primary method of composition is through functions rather than mutable references, not just that you can pass closures around
19:08:43 <kmc> DanBurton, they're not *just* that; they also have properties resembling first-class continuations
19:09:11 <blackdog> johnFreeman: ruby's a lovely little language for certain things. i'd certainly rather use it than java.
19:09:23 <kmc> this channel can argue about what the word "functional" means for hours on end
19:09:45 <DanBurton> Let's do it! >.>
19:10:02 <kmc> generally there's one camp that argues that "functional" should only be applied to languages exactly like Haskell in every way
19:10:18 <MarkDBlackwell> blackdog, thanks, single-assignment, lazy evaluation, functional, very appealing personally. :)
19:10:19 <kmc> and another which takes it as a general term including almost every modern language
19:10:21 <morolin> kmc: I always thought that "functional" means "the language architect had a hard-on for the lambda calculus"
19:10:28 <kmc> and another that basically accepts whatever wikipedia / their textbook says
19:11:00 <kmc> morolin, what about a language like Python, where the official dogma is that Functional Programming is UnPythonic, yet they use FP techniques constantly under different names
19:11:01 <DanBurton> the cool thing about Haskell is its type system restrictions. Which is weird because normally you'd think that restrictions would be annoying
19:11:21 <kmc> it's restricting me from writing incorrect code
19:11:34 <DanBurton> good ol' Guido
19:11:36 <incluye> like list comprehensions
19:11:41 <MarkDBlackwell> I love it -- and people say it was inspired by _why_the_lucky_stiff's Ruby book -- any information on whether that's true?
19:11:44 <companion_cube> or itertools
19:11:49 <MarkDBlackwell> (DanBurton)
19:12:03 <kmc> DanBurton, i think there's a lot of cool things about Haskell besides types.  i've put together a 50-slide presentation about why you should learn Haskell (which will be uploaded in a few days) and I barely mention types
19:12:08 <kmc> i also don't use the word "functional" anywhere
19:12:17 <donri> wait, python thinks FP is unpythonic?
19:12:22 <DanBurton> MarkDBlackwell: you mean regarding  LYAH? Not sure; sounds kinda true though.
19:12:24 <morolin> kmc: AFAIK, Guido doesn't have a crush on lambda calc, so that'd be a no
19:12:32 <c_wraith> donri: ever since map and filter were deprecated
19:12:51 <kmc> were they actually deprecated, or just moved out of the default namespace?
19:12:53 <DanBurton> kmc: so what, in a nutshell, do you find cool about Haskell?
19:13:04 <companion_cube> donri: lambda are deliberatly restricted in python
19:13:08 <kmc> DanBurton, when i post the slides i'll send you a link :)
19:13:16 <DanBurton> yessssssssssssss
19:13:30 <donri> listcomps are generally preferred over map and filter, reduce was moved to a stdlib in py3
19:13:36 <DanBurton> man I love #haskell where have you been all my life
19:13:48 <MarkDBlackwell> DanBurton, yes, LYAH.
19:14:33 <kmc> DanBurton, a lot of it is that Haskell and GHC have features for making unusually composable code: declarative programming, equational reasoning, laziness, pattern-matching, sharing, EDSLs, first-class IO, first-class concurrency, STM, pure parallelism
19:14:34 <donri> companion_cube: you could argue they're more like haskell than others because of that ;)
19:14:57 <donri> i.e. just one expression
19:15:48 <MarkDBlackwell> DanBurton: I mean I like Ruby's functional part of all the methods like map that do whole collections.
19:16:02 <kmc> DanBurton, and GHC is a great compiler with cool features like the IO manager
19:16:35 <kmc> DanBurton, and there's an awesome library/tool ecosystem: QuickCheck, Criterion, hpc, profilers, Threadscope, Haddock, Cabal, cabal-install, Hackage
19:16:54 <MarkDBlackwell> kmc, composable functions; Ruby, too.
19:16:54 <luqui> companion_cube, what, to single expressions?  like haskell? ;-)
19:17:20 <kmc> and the Haskell community is very active; there's always something new going on
19:17:25 <companion_cube> but in hasell everything is expresion, whereas in python an expresion is not enough
19:17:39 <kmc> and i think it's reached a good balance between academic pure research and real-world applications
19:17:42 <DanBurton> kmc: don't forget Hoogle. I heart Hoogle.
19:17:48 <kmc> oh yeah, that's in my slides too
19:17:53 <kmc> i skimmed them quickly ;)
19:17:59 <DanBurton> :)
19:18:25 <kmc> companion_cube, not true that everything is an expression, not by a long shot
19:18:48 <kmc> in fact Haskell has the statement / expression syntactic division like most other languages
19:18:49 <DanBurton> are your slides freely available? I'd love to evangelize Haskell to my fellow college students sometime, maybe at our ACM programming club or something
19:18:54 <kmc> DanBurton, they will be
19:18:57 <kmc> in a few days
19:19:17 <DanBurton> throw links on reddit, I dare you
19:19:33 <kmc> i'll let someone else deal with the /r/programming den of trolls and morons
19:19:51 <DanBurton> I was thinking more along the lines of /r/haskell
19:20:02 <blackdog> kmc: do you mean declarations? I can't offhand think of a statement in haskell
19:20:08 <KirinDave> Is /r/programming that hard on haskell?
19:20:14 <MarkDBlackwell> kmc, the restrictions are empowering, strangely
19:20:14 <DanBurton> not that anyone there needs to be evangelized, but several of us I'm sure would appreciate the resource
19:20:15 <blackdog> 'do' is just syntactic sugar, right?
19:20:21 <DanBurton> blackdog: right
19:20:22 <KirinDave> blackdog: yes
19:20:29 <KirinDave> blackdog: The code for it surprised me.
19:20:55 <blackdog> KirinDave: in haskell, things are either far more simple than you expect, or deeply and surprisingly complex:)
19:20:55 <DanBurton> luqui got a blog post through on /r/programming I noticed. It fared rather well.
19:21:00 <kmc> KirinDave, yeah.  there was a lot of Haskell hype a few years ago, and then a backlash
19:21:11 <kmc> they go through phases of being obsessed with some language / webapp framework
19:21:15 <luqui> it has happened twice
19:21:21 <luqui> incidentally, both were posts I almost deleted
19:21:23 <kmc> when i checked out they were all hard for node.js
19:21:34 <kmc> but i assume they've moved on to COBOL on Cogs or something
19:21:50 <dobblego> /r/programming is a cesspit of chronic stupidity, why take it seriously?
19:21:59 <DanBurton> I have a love-hate relationship with JavaScript. On one hand, it's so flexible. On the other hand, it's so flexible.
19:22:17 <luqui> dobblego, i disagree.  there are plenty of intelligent people on /r/programming
19:22:30 <luqui> but their extreme dogmatism prevents them from ever saying anything constructive
19:22:31 <DanBurton> dobblego: the highest-voted comments and submissions are usually quite good. Just ignore the low-voted ones.
19:22:33 <dobblego> luqui: I agree, but it's not worth it
19:22:54 <kmc> i'm happy to rant about /r/programming over in #haskell-blah
19:22:57 <luqui> they just aren't humble, like haskell programmers :-)
19:23:05 <dobblego> yeah #haskell-blah
19:23:06 <DanBurton> :)
19:23:28 <DanBurton> yeah we're supposed to be talking about endofunctors or something over here
19:23:46 <luqui>  /r/programming's mama is an endofunctor
19:26:29 <luqui> soooo.... how bout them applicative functors?
19:26:40 <kmc> blackdog, "do" is just syntactic sugar but "statements vs expressions" is explicitly a syntactic distinction
19:27:00 <companion_cube> kmc: but haskell statemtsn are declarations, right?
19:27:04 <kmc> no
19:27:10 <kmc> the key difference is that Haskell lets you build expressions out of statements, while most languages only directly support statements built out of expressions
19:27:11 <companion_cube> i don't get it then
19:27:14 <DanBurton> applicative are my favorite kind of functors
19:27:15 <luqui> example of haskell statement?
19:27:20 <kmc> x <- readFile "foo"
19:27:24 <donri> well sure haskell has statements, but it's more expression-oriented than e.g. python
19:27:33 <kmc> these are just the names of the nonterminals in the grammar in the Report
19:27:36 <companion_cube> kmc: but you can still  write it as an e xpression
19:27:43 <luqui> ah you are still talking about do notation
19:27:56 <luqui> it has been gradually working its way out of my awareness
19:27:57 <kmc> anyway the original claim was "everything in Haskell is an expression" and there are many counterexamples to that
19:28:02 <companion_cube> in python, you cannot do anything without imperative statements
19:28:15 <donri> in my python-tainted mind, a statement is something you can't "inline"
19:28:16 <DanBurton> kmc: when, exactly is something not an expression?
19:28:27 <DanBurton> in Haskell
19:28:32 <cbarrett> kmc: that's the same as the expression: readFile "foo" >>= $ \x -> ...
19:28:34 <luqui> donri, like a where clause.  except that's a declaration i think...
19:28:44 <kmc> DanBurton, when it's not matched by the grammar rooted at the nonterminal named "exp" in the Haskell 98 Report
19:28:56 <luqui> cbarrett, ... eh?
19:28:59 <donri> i'd call import/class/data "statements" in haskell
19:29:04 <kmc> not expressions:  patterns, types, declarations, module import/export lists
19:29:04 <DanBurton> kmc: ?_? good answer I guess
19:29:27 <kmc> "do" statements
19:29:41 <kmc> (and the corresponding bits of list comprehensions)
19:29:46 <DanBurton> donri: good point
19:29:57 <kmc> donri, but you'd be wrong
19:30:16 <kmc> these are just the names of the nonterminals in the grammar in the Report
19:30:19 <kmc> there is nothing more fundamental to it
19:30:28 <DanBurton> @where haskell2010
19:30:29 <lambdabot> I know nothing about haskell2010.
19:30:32 <DanBurton> boo
19:30:33 <kmc> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
19:30:47 <kmc> maybe i should say that Haskell does not have statements, it only has stmts
19:30:47 <DanBurton> how do you register links for lambdabot's @where ?
19:30:55 <donri> i probably would be wrong, i'm a total noob :)
19:30:58 <kmc> @where+ haskell2010 http://www.haskell.org/onlinereport/haskell2010/
19:30:59 <lambdabot> I will never forget.
19:31:01 <kmc> @where h2010
19:31:01 <lambdabot> I know nothing about h2010.
19:31:05 <kmc> @where+ h2010 http://www.haskell.org/onlinereport/haskell2010/
19:31:05 <lambdabot> I will never forget.
19:31:14 <DanBurton> @where h2010
19:31:14 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
19:31:16 <DanBurton> yay
19:31:19 <aavogt> can't we call it H10?
19:31:32 <DanBurton> @where h10
19:31:33 <lambdabot> I know nothing about h10.
19:31:33 <aavogt> it's not as if there's any confusion with haskell-1910
19:31:44 <DanBurton> @where+ h10 http://www.haskell.org/onlinereport/haskell2010/
19:31:45 <lambdabot> Okay.
19:31:53 <JoeyA> Why is Data.ByteString.putStrLn deprecated (in favor of Char8.putStrLn), but Data.ByteString.getLine isn't?
19:32:07 <DanBurton> Also, we should rename the language from "Haskell" to simply "H"
19:32:15 <kmc> in languages in general, the syntactic class of "statements" refers to syntax describing imperative actions which are to be sequenced or conditionalized by control flow
19:32:19 <DanBurton> single-letter language names are all the rage
19:32:28 <cbarrett> luqui: see the code sample following "It allows an expression such as" here: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
19:32:31 <kmc> a key aspect of statements is a production like  stmt ::= '{' stmts '}'
19:32:58 <cbarrett> kmc: despite the name, they are semantically still expressions...
19:33:07 <kmc> we are explicitly talking about syntax not semantics
19:33:09 <cbarrett> note that the do construct is a "do expression"
19:33:20 <kmc> yes
19:33:32 <kmc> and ({ int x = 2; int y = 3; x + y }) is an expression in GNUC
19:33:44 <DanBurton> kmc: but when someone says "everything in Haskell is an expression", they're talking semantically, not syntactically
19:33:46 <companion_cube> but not in python
19:33:50 <luqui> cbarrett, i was being a pedant because we were talking about syntax
19:34:10 <luqui> it's not a closed expression if you need dots to express it...
19:34:14 <kmc> DanBurton, i'm not sure what "semantically an expression" would even mean, but I'm sure it does not include types or modules
19:34:27 <companion_cube> that's declarations
19:34:32 <luqui> semantically expression = has denotation?
19:34:33 <aavogt> everything in Haskell is something in Haskell
19:34:33 <kmc> types are not declarations
19:34:40 <luqui> aavogt, lol
19:34:47 <DanBurton> types are optional
19:34:47 <kmc> for example (x :: t) is an expression made from an expression and a type
19:34:50 <kmc> no declaration in sight
19:34:55 <DanBurton> most of the time, that is
19:35:04 <kmc> also true, but irrelevant
19:35:05 <companion_cube> kmc: gg
19:35:24 <kmc> good game?
19:35:25 <donri> for me an expression is something that evaluates to some value
19:35:28 <aavogt> luqui: anything more specific is probably wrong in some interpretation
19:35:53 <luqui> programmers are quite prone to make judgements such as "everything is a X"
19:36:07 <kmc> http://conal.net/blog/posts/everything-is-a-function-in-haskell
19:36:22 <DanBurton> if conal does it then it must be ok
19:36:23 <luqui> which to me only says "X is a meaningless concept"
19:36:32 <donri> every programmer is a judgement-proner
19:36:35 <kmc> luqui, no, sometimes it's a meaningful concept and they are just wrong
19:36:36 <luqui> DanBurton, cf unamb
19:36:41 <kmc> like the "everything is a function in Haskell" statement
19:36:55 <companion_cube> kmc: yep
19:37:15 <kmc> companion_cube, meaning that you think the argument is not worth continuing? wise choice :)
19:37:47 <companion_cube> kmc: yeah, let's talk about something more interesting
19:37:50 <donri> wait, is "everything is a function in Haskell" a statement or an expression
19:38:03 <companion_cube> like "everything is a category in haskell" ;)
19:38:16 <companion_cube> donri: a first-order predicate !
19:38:22 <monochrom> everything is a plain text file in haskell
19:38:22 <companion_cube> everything is a first order predicate !
19:38:37 <donri> everything is a Maybe in Perl
19:38:39 <kmc> derp
19:38:40 <companion_cube> s/predicate/formula/
19:38:42 <Cale> EVERYTHING IS A THING
19:38:49 <DanBurton> everything is ones and zeros in computers
19:38:50 <kmc> everything is permitted
19:38:52 <companion_cube> everything is a memory leak in java
19:38:56 <monochrom> everything belongs to everything. everything is happy.
19:39:03 <kmc> SO WHAT DO U THINK OF PHP
19:39:04 <donri> everything is getting old now
19:39:06 <DanBurton> @let everything = undefined
19:39:07 <lambdabot>  Defined.
19:39:13 <DanBurton> > everything
19:39:14 <lambdabot>   Ambiguous occurrence `everything'
19:39:14 <lambdabot>  It could refer to either `L.everything',...
19:39:19 <monochrom> everything is undefined!
19:39:20 <Cale> :t L.everything
19:39:22 <lambdabot> forall a. a
19:39:39 <donri> no, everything is just defined as undefined
19:39:45 <monochrom> haha
19:39:47 <luqui> lol
19:39:57 <DanBurton> I agree with lambdabot. "Ambiguous occurrence 'everything' "
19:40:03 <donri> :D
19:40:17 <monochrom> you win
19:40:32 <DanBurton> @botsnack
19:40:32 <lambdabot> :)
19:40:32 <JoeyA> Shouldn't that be "anything" ?
19:40:54 <JoeyA> Functions aren't first-class citizens even in Haskell... unless someone can implement a Serialize instance for it.
19:40:58 * ski prefers the term "command" to "statement" -- statement sounds more like the clauses of Prolog
19:41:25 <ski> (`(x :: t)' is a type ascription expression)
19:41:27 <ski> blackdog : Melbourne has Mercury
19:41:41 <JoeyA> @faq Is it possible to implement a Serialize instance for (->) ?
19:41:42 <lambdabot> The answer is: Yes! Haskell can do that.
19:41:43 <Cale> executive order
19:42:09 <DanBurton> Cool, lambdabot says Hsakell can serialize (->). Let's do it. xP
19:42:28 <mauke> serialize f = "(->)"
19:42:30 <JoeyA> Actually, more like (Serialize a, Serialize b) => Serialize (a -> b)
19:42:55 <luqui> (CoSerialize a, Serialize b)
19:42:55 <DanBurton> imho you don't have to be able to serialize the types in order to serialize a function that operates on them
19:43:20 <JoeyA> Being able to serialize a function would be really useful, in my opinion.
19:43:28 <luqui> that doesn't really seem like the topic of an opinion
19:43:45 <DanBurton> yes but I'm not 100% certain so I call it opinion ;)
19:43:55 <JoeyA> (even if it the binary were tied to a specific arch)
19:44:04 <DanBurton> doh
19:44:19 <luqui> DanBurton, actually.. you need to be able to serialize anything in the closure of the function
19:44:26 <luqui> which is not reflected in the type
19:44:27 <JoeyA> It should probably be (Typeable a, Typeable b) => Serialize (a -> b)
19:44:44 <luqui> so if functions are serializable
19:44:50 <luqui> then every value  must be serializable
19:44:51 <DanBurton> luqui: that...would make it very difficult then
19:44:52 * ski . o O ( <http://web.archive.org/web/20070706205236/http://durchholz.org/jo/fpl-marshalling-survey/index.html> )
19:45:18 <JoeyA> Implementing that would require access to the underlying representation of things.
19:45:51 <JoeyA> And some things use foreign pointers rather than just data constructors.
19:46:13 <luqui> yes it is a big practical issue
19:46:20 <ski> JoeyA : see e.g. O'Caml in above survey
19:46:24 <luqui> not just one of those "why didn't they do it"
19:48:02 <ski> (O'Caml allows marshalling closures between processes running the same program compiled by the same compiler version, on the same platform)
19:48:50 <JoeyA> Can those closures be written to disk?
19:48:54 <DanBurton> sounds easier to just use an interpreter and pass code around as text
19:48:58 <ski> JoeyA : i think so
19:49:25 <luqui> Clean does it too no?  i don't know what its constraints are
19:49:39 <luqui> i mean, using a VM is a nice trade-off in the middle
19:49:54 <Nisstyre> DanBurton: a quine?
19:50:23 <ski> (of course, there will always be problems trying to marshall resources like e.g. mutable cells and sockets (one could do like Oz and Alice ML, communicate transparetnyly with the original resource over the network))
19:50:36 <JoeyA> Being able to store closures gives "stored procedure" a whole new meaning ;-)
19:50:40 <DanBurton> Nisstyre: kindasorta
19:50:52 <Nisstyre> yeah, like a partial quine
19:50:57 <Nisstyre> that outputs a certain function
19:51:48 <JoeyA> I suppose closure serialization could be achieved by making the serialization function fallible.
19:51:50 <DanBurton> I imagine Template Haskell could bundle a function with it's textual representation, though, or something weird like that.
19:52:08 <JoeyA> A closure is a block of code and some context values.
19:52:36 <JoeyA> Serialization of the closure could check that each value is serializable (which would require storing tags with every closure, I suppose).
19:52:41 <ski> (<http://www.mozart-oz.org/home/doc/dstutorial/index.html> and <http://www.ps.uni-saarland.de/alice/manual/tour.html#distribution>, respectively)
19:52:47 <DanBurton> JoeyA: Haskell serialization atm is infallible?
19:53:30 <ski> luqui : last i looked, Clean compiled to an intermediate ABC bytecode
19:53:31 <DanBurton> JoeyA: I suppose it's up to each person that creates an instance to make it so
19:53:49 <JoeyA> I'm talking about serializing closures.  The Serialize class doesn't have a provision for invalid Haskell structures, and it shouldn't.
19:53:58 <JoeyA> (but serializing closures would need it)
19:54:13 <JoeyA> Err
19:54:23 <MarkDBlackwell> DanBurton, I thought my solution wouldn't work for infinite lists, but it does!   eachCons :: [a] -> Int -> [[a]]
19:54:24 <MarkDBlackwell>   eachCons x n
19:54:26 <MarkDBlackwell>     | n <= 0 = [[]]
19:54:28 <MarkDBlackwell>     | otherwise = consecutives
19:54:28 <JoeyA> Serializing a closure could fail if any of the context values aren't serializable.
19:54:29 <MarkDBlackwell>     where
19:54:31 <MarkDBlackwell>       sequences = map (`drop` x) [0..(n-1)]
19:54:33 <MarkDBlackwell>       consecutives = [y | y <- transpose sequences, n==length y]
19:54:39 <companion_cube> MarkDBlackwell: pastebin.
19:54:57 <DanBurton> MarkDBlackwell: cool sauce, congrats
19:55:21 <hpaste> MarkDBlackwell pasted “eachCons” at http://hpaste.org/51819
19:55:53 * ski would set `eachCons x n | n < 0 = error ("eachCons _ " ++ showsPrec 11 n "")'
19:56:11 <MarkDBlackwell> DanBurton, thank you; that was my original solution -- I might adopt yours. :)
19:56:41 <DanBurton> MarkDBlackwell: but my version wouldn't work on infinite lists since it checks the length of the input list, which is infinite
19:56:57 * ski idly wonders why MarkDBlackwell swapped the arguments of `eachCons'
19:57:09 <JoeyA> @hoogle eachCons
19:57:09 <lambdabot> No results found
19:57:32 <JoeyA> @djinn [a] -> Int -> [[a]]
19:57:32 <lambdabot> Error: Undefined type []
19:57:44 <JoeyA> @djinn m a -> Int -> m (m a)
19:57:44 <lambdabot> Error: Undefined type Int
19:57:45 * DanBurton wonders what order ski is referencing
19:58:18 <luqui> JoeyA, or any of the context variables' context variables
19:58:33 <luqui> but maybe one of the context variables is a closure, and if only you evaluated it it would become serializable
19:58:48 <DanBurton> is there a reason djinn doesn't recognize the [] type?
19:58:57 <luqui> yeah
19:59:04 <luqui> the solver doesn't understand recursive types
19:59:05 * shapr hugs luqui 
19:59:10 * Samy hugs shapr
19:59:15 * luqui hugs Samy
19:59:21 * Samy hugs amathew 
19:59:22 <MarkDBlackwell> ski, for Rubyists' comfort, to matching the original Ruby:  [1,2,3,4,5].each_cons(3).to_a  gives [[1, 2, 3], [2, 3, 4], [3, 4, 5]] .
19:59:25 <Nafai> shapr!
19:59:25 * DanBurton backs away slowly
19:59:32 * luqui suggests a sex party
19:59:40 * DanBurton backs away more quickly
20:00:16 <DanBurton> so Ruby has each_cons built into it?
20:00:17 <JoeyA> luqui: I guess regular values would be checked for a Serialize instance, and closures would involve recursing on the serialize-closure function.
20:00:34 <luqui> you can't really check for an instance at runtime
20:00:45 <JoeyA> (more simply, the Serialize instance for a closure would step through the context variables)
20:01:12 <luqui> i guess you could if you saved that info
20:01:18 <JoeyA> Right, that's why most GHC wouldn't be able to support it, practically speaking.
20:01:20 <MarkDBlackwell> DanBurton, yes: Enumerable#each_cons  ,  see http://www.ruby-doc.org/core/classes/Enumerable.html#M001515
20:01:30 * DanBurton just tried that out on tryruby.org :)
20:01:58 <DanBurton> Ruby's got some cool stuff
20:02:52 <MarkDBlackwell> DanBurton, yes, powerful composable methods, so thinking of making a Haskell module for the few left out.
20:03:43 <ski> MarkDBlackwell : but what does `[1,2,3,4,5].each_cons(0).to_a' give ?
20:04:06 <JoeyA> @let eachCons n = takeWhile ((== n) . length) . map (take n) . tails
20:04:07 <lambdabot>  Defined.
20:04:15 <luqui> ski, argument error
20:04:17 <JoeyA> > eachCons 3 [1..]
20:04:19 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
20:04:25 * DanBurton wishes tryruby.org supported backspace T_T
20:04:25 <JoeyA> > eachCons 3 [1..5]
20:04:25 <ski> MarkDBlackwell : originally you talked about `eachCons 4 [1,2,3,4,5,6]', not `eachCons [1,2,3,4,5,6] 4'
20:04:27 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
20:04:30 <MarkDBlackwell> ski, I suppose this is what I'm learning, that it's good to use the Haskell usual order of eachCons x n  because the list in Ruby was left of the method name, anyway. Probably good to go with eachCons x n .
20:04:39 <ski> luqui : bad Ruby !
20:04:40 <luqui> those practical languages never get the corner cases right
20:05:16 <JoeyA> > eachCons 0 [1..]
20:05:18 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
20:05:36 <MarkDBlackwell> ski, Ah, I made it up, more Haskell-like at first on chat -- now I see what you mean -- sorry about that!
20:05:43 <DanBurton> ski: in ruby it produces an "invalid argument error"
20:05:47 <ski> MarkDBlackwell : i would probably prefer having the count argument before the list argument -- it appears that partially applying on the count would be more common that partially applying on the list
20:05:56 <DanBurton> ski: actually, "ArgumentError: invalid size"
20:05:58 <JoeyA> > eachCons 0 [1..10]
20:06:00 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[]]
20:06:16 <ski> DanBurton : it ought to give `[[],[],[],[],[],[],[]]' ..
20:06:38 <DanBurton> ski: because that's what the Haskell version does?
20:06:54 <KirinDave> I wonder if I should just downgrade back to ghc 7.0.*
20:06:59 <KirinDave> Being on 7.2.1 is a brutal road
20:07:01 <DanBurton> an error makes more sense to me
20:07:19 <MarkDBlackwell> I tested it originally, and now, too:  [].each_cons(1).to_a returns an empty list, no error.
20:07:20 <DanBurton> KirinDave: noooooooooooo
20:07:32 <KirinDave> DanBurton: I cannot get these packages to install. No matter what I do
20:07:41 <KirinDave> hackage is just a minefield.
20:07:41 * ski likes the term "most GHC"
20:07:47 <DanBurton> KirinDave: well in that case, I guess so /sigh
20:07:58 <MarkDBlackwell> DanBurton, I suppose each consecutive 'no elements' doesn't make much sense.
20:08:55 <DanBurton> > repeat []
20:08:56 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
20:09:07 <ski> > map (eachCons 3) (words "frobnicate the veeblefitzer")  -- partially applying on the counnt
20:09:09 <lambdabot>   [["fro","rob","obn","bni","nic","ica","cat","ate"],["the"],["vee","eeb","eb...
20:09:12 <DanBurton> seems to me that is what it should produce for an input of 0
20:09:18 <MarkDBlackwell> ski, I see, an infinite list of empty lists! Well, in Ruby, if I convert to an array, they don't infinite lists.
20:09:22 * ski can't counnt
20:10:04 <donri> python: [x[i:i+size] for i in range(len(x)-size+1)]
20:10:07 <ski> MarkDBlackwell : no, `l.each_cons(n).to_a' ought to give a list of length `n+1', that should be entirely feasible in Ruby
20:10:34 <ski> (a list of length `n+1' with each element being the empty list, i.e.)
20:11:15 <DanBurton> ski: disagree; it should be an infinite list, not a list of length n+1. In my mind it's like it starts at the beginning and then takes 0 elements. Then it's still at the beginning and takes 0 elements agian.
20:11:30 <DanBurton> and again and again
20:11:33 <DanBurton> like an iterator
20:11:43 <ski> MarkDBlackwell : er, sorry, i'm goofing that up -- i *meant* `l.each_cons(0).to_a' where `l' is a list of *length* `n'
20:11:48 <ski> (sorry, i haven't slept)
20:12:01 <DanBurton> no wait that's wrong jk
20:12:07 <DanBurton> ignore what I just said
20:12:34 <DanBurton> it just clicked in my brain
20:13:22 <DanBurton> in any event, if you're using each_cons(0) you're probably doing it wrong anyways. Why not just `map const []` ?
20:13:33 <DanBurton> and prepend []
20:13:45 * ski . o O ( <http://sv.wikipedia.org/wiki/Lidnersk_kn%E4pp> )
20:14:03 <ski> DanBurton : consistency
20:14:24 <MarkDBlackwell> DanBurton, Ruby has some lazy evaluation libraries which work with Enumerators, one of which is returned by the bare [1,2,3].each_cons(1) . They can be infinite: http://www.ruby-doc.org/core/classes/Enumerator.html
20:14:46 <ski> if there's no good reason to exclude the trivial cases, they ought to be included (such that they extrapolate correctly from the other cases)
20:14:49 <DanBurton> ski: well let's email the Ruby devs and tell them their each_cons is inconsistent
20:15:17 * ski is opposed to unfair discrimination against zero and friends
20:15:24 <luqui> getting the "useless" corner cases of a function right means that you don't have to do as much work to get the corner cases of functions using that function right
20:15:34 <luqui> and those corner cases might be useful for various things
20:15:39 <luqui> usually the correctness of a recursive definition
20:15:41 * DanBurton discriminates against negatives
20:16:29 * ski takes the inverse of discriminants
20:16:50 <DanBurton> so wait if you do each_cons(-2) should that take the two elements directly *before* each position in the list?
20:17:14 <DanBurton> in that case our Haskell definition fails
20:17:16 <MarkDBlackwell> ski, very funny; it's because of the problem of usually having no infinite lists in Ruby, that they reject taking elements 0 at a time. ;/
20:17:39 <ski> MarkDBlackwell : again, infinite lists are unrelated to this issue
20:18:11 <luqui> DanBurton, yeah i think that is a reasonable extension
20:18:25 * luqui does his daily lament that there is no Nat type in haskell
20:18:31 <MarkDBlackwell> ski, an infinite-list version could be written in Ruby, but I think the Rubyists will be happy with a Haskell port that extends it a little bit.
20:18:45 <DanBurton> let negativeFriendlyEachCons n xs | n < 0 = same as eachCons but using `heads` instead of `tails` ?
20:18:52 <ski> in case `l' has `n' elements, then `l.each_cons(k).to_a' will have `n+1-k' elements
20:18:59 <luqui> DanBurton, you mean inits?
20:19:08 <ski> so if `k' is `0', it should have `n+1' elements, to complete the pattern
20:19:32 <DanBurton> luqui: yeah I guess. My brain said "what's the opposite of tails" and the answer seemed to obviously be "heads" ;)
20:19:34 <ski> MarkDBlackwell ^
20:20:12 <MarkDBlackwell> ski, well, I mean [1,2,3].each_cons(0).to_a is rejected due to it probably producing an infinite length. If you want to say Ruby is wrong, I agree with you. :)
20:20:37 <ski> DanBurton : i'd first try to find a law that relates `eachCons (n0 + n1)' to `eachCons n0' and `eachCons n1'
20:20:57 <luqui> MarkDBlackwell, each_cons(0) should not produce an infinite length list
20:21:01 <luqui> I think that's what we're getting at
20:21:35 <ski> DanBurton : then `eachCons (-n)' (for negative `-n') should be such that it together with `eachCons n' (which is a known case) is related to `eachCons 0' (also a known case)
20:22:20 <MarkDBlackwell> ski, so you would only ever get two lists back -- haha -- why do I get the feeling you are kidding?
20:22:56 <ski> MarkDBlackwell : to be fully clear, i'm not claiming `[1,2,3].each_cons(0).to_a' ought to give an infinite list. i'm claiming it ought to give a list of four elements (each an empty list)
20:23:34 <ski> > eachCons 3 [0,1,2]
20:23:36 <lambdabot>   [[0,1,2]]
20:23:37 <ski> > eachCons 2 [0,1,2]
20:23:39 <lambdabot>   [[0,1],[1,2]]
20:23:40 <ski> > eachCons 1 [0,1,2]
20:23:41 <lambdabot>   [[0],[1],[2]]
20:23:43 <ski> > eachCons 0 [0,1,2]
20:23:45 <lambdabot>   [[],[],[],[]]
20:23:49 <MarkDBlackwell> ski, what is (^)?  please
20:23:50 <ski> see the pattern ?
20:24:10 * ski hasn't mentioned `(^)' here, but ok .. :
20:24:15 <ski> @type (^)
20:24:16 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
20:24:19 <MarkDBlackwell> DanBurton, each consecutive negative number of elements should produce something imaginary, I would think.
20:24:26 <ski> > 2 ^ 6
20:24:27 <lambdabot>   64
20:24:44 <companion_cube> > 1 ^ (-1)
20:24:45 <lambdabot>   *Exception: Negative exponent
20:24:53 <ski> > 1 ^^ (-1)
20:24:54 <lambdabot>   1.0
20:25:00 <ski> @type (^^)
20:25:01 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
20:25:02 <ski> @type (**)
20:25:03 <lambdabot> forall a. (Floating a) => a -> a -> a
20:25:15 <MarkDBlackwell> ski, well, each consecutive helps in Euler problem eight, which is to find five consecutive digits in a large number with the greatest product. It's a useful method.
20:25:39 <luqui> MarkDBlackwell, produce lists of negative length, perhaps
20:26:03 <luqui> we're not taking roots so i don't know where the imaginary bit comes in :-)
20:26:17 * ski thinks finding digits in decimal numerals is a bit silly
20:26:52 * ski played around one time with "diff-lists of negative length"
20:28:15 <ski> > ((\('a' : 'b' : 'c' : s) -> s) . (\s -> 'a' : 'b' : 'c' : s)) ""  -- a la this
20:28:17 <lambdabot>   ""
20:29:00 <MarkDBlackwell> ski, that's interesting about the pattern. Hm...
20:30:33 <MarkDBlackwell> luqui, yes, just being poetic. Yes, I know, Haskell has some powerful mathematics people, more mathematical than I, if I can be forgiven under the 'big tent' of Haskell. :)
20:30:53 <DanBurton> ski I think you missed the real question about ^
20:30:59 <luqui> it was actually a pun, i didn't figure you meant imaginary as in sqrt(-1)
20:31:57 <DanBurton> MarkDBlackwell: if I say something but forget to prefix it with someone's name, then I write "YourName ^" in a later comment. The ^ is simply to direct your attention upwards to my prevoius comment
20:32:29 <mzero> is there no way to ask cabal to take advantage of multiple processors and build more than one module at a time?
20:32:42 <shachaf> mzero: Not really.
20:32:54 <DanBurton> not yet anyways
20:32:57 <shachaf> mzero: It's sad. :-(
20:33:04 <mzero> sigh - good thing I bought this fancy new multi-processing laptop  :-P
20:33:10 * shachaf would prefer to be sad rather than fix things.
20:33:26 * DanBurton thinks shachaf should stop being sad and get to work
20:33:27 <MarkDBlackwell> ski, back a few lines, after you said, 'so if `k' is `0', it should have..., you said to me, MarkDBlackwell ^  -- I suppose you were pointing to that comment, and saying, 'look up', it is for me! :D
20:33:39 * mzero has had enough of Yak shaving and needs to actually write his freakin' Haskell slides....
20:33:41 * shachaf preempted DanBurton's remark.
20:33:43 <dobblego> http://paste.pocoo.org/show/483102/ what am I doing wrong?
20:33:50 <shachaf> mzero: You can always use make...
20:34:24 * DanBurton used inception to make shachaf write that remark in the first place @_@
20:34:52 <shachaf> dobblego: letters1 separated by spaces doesn't seem to include "abc xyz ".
20:35:00 <MarkDBlackwell> DanBurton, thanks, I understand about ^ now. :)
20:35:38 <dobblego> shachaf: I missed out _ <- spaces in there
20:35:46 <shachaf> > ^ <
20:35:46 <shachaf>   |
20:35:47 <lambdabot>   <no location info>: parse error on input `^'
20:35:50 <DanBurton> MarkDBlackwell: good :)
20:35:51 <dobblego> http://paste.pocoo.org/show/483103/
20:36:10 <shachaf> dobblego: Still not working?
20:36:11 <mzero> pandoc is like one big lesson in standing on the shoulders of giants, eh? Man, that installs a galaxy load of packages!
20:36:20 <dobblego> right not working
20:36:45 <shachaf> dobblego: Maybe a is getting ["abc"], and then the first _ is getting " "?
20:37:23 * DanBurton has randomly installed several unnecessary packages today simply because they were brought up on irc, including djinn, hoogle, snap, and now pandoc
20:38:59 <shachaf> Wait, what I said doesn't make sense.
20:39:11 <DanBurton> anyone familiar with the art of documenting your package on hackage?
20:39:31 <Rmx> Hi, what is the name of those equations I see in various papers involving strange symbols from category theory ? I would like to understand them
20:39:39 <dobblego> shachaf: it's failing to parse since it sees the space and expects a following space or a letter
20:39:50 <dobblego> Rmx: denotational semantics perhaps
20:39:57 <DanBurton> I uploaded the package called "composition" but it ain't got no docs for the primary module: Data.Composition http://hackage.haskell.org/package/composition
20:40:03 <Rmx> thanks, I'm taking a look right now
20:40:55 <ski> MarkDBlackwell : oh, so i apparently did
20:41:11 <ski> when you wrote `(^)', i was thinking about the haskell operations
20:42:14 <ski> Rmx : any example paper ?
20:42:29 <Rmx> hm, no, not denotational semantics, I'm speaking about those vertical lines with mathematical symbols above and under it
20:42:30 <DanBurton> @google cabal user's guide
20:42:32 <lambdabot> http://www.haskell.org/cabal/users-guide/
20:42:32 <lambdabot> Title: Cabal User Guide
20:42:32 <Rmx> yes
20:42:35 <Rmx> I'm linking it now
20:43:00 <Rmx> http://www.cs.yale.edu/homes/hl293/download/NEPLS-talk.pdf
20:43:07 <Rmx> page called CAA type
20:43:14 <Rmx> around 1/3 of the paper
20:43:25 <Rmx> there is no page numbers.. sorry
20:43:59 <michaelbaker> Hello everyone. I'm reading through Real World Haskell. In chapter 6 the author explains how the Show is implemented without concrete types. Using his description I've written https://gist.github.com/1244357 , but I don't understand why that works. Why does Haskell decide that MyShow Char is the correct instance to use when I apply myShow to a list of Chars?
20:44:00 <Rmx> "CAA types"*
20:44:22 <MarkDBlackwell> luqui, well, yes, I was intuitively thinking it would be an imaginary number, for some reason I hadn't worked out, yet. Perhaps the result should contain a negative number of lists, which when multiplied by the negative size of each, would constitute the original list. Then, if the sublist length is chosen to be about the square root of the original list length, it works: positive or...
20:44:23 <MarkDBlackwell> ...negative. That's still not imaginary, unless I joke that the original list had a negative length. Well, let's say that it does, for some backward list. Then each consecutive sublist could have an imaginary length and there be an imaginary number of them. I uphold the equivalence of positive and negative length lists, after all! <jokingly>
20:44:55 <luqui> %-)
20:46:24 <DanBurton> michaelbaker: it doesn't use the MyShow Char instance. It uses the (MyShow a) => MyShow [a] instance
20:47:16 <michaelbaker> DanBurton: But then how does the version of myShowList defined in the MyShow Char instance get used?
20:47:18 <ski> Rmx : you're talking about inference systems (probably an inference system for type checking/assignment, in your case)
20:47:23 <MarkDBlackwell> ski, that's good, no problem.
20:47:26 <Rmx> (x : α) ∈ Γ
20:47:27 <Rmx> Γ ⊢ x : α
20:47:32 <Rmx> things like this
20:47:41 <Rmx> with vertical line between the 2 lines
20:47:46 <DanBurton> michaelbaker: I was second guessing myself, but I think I've got it now
20:47:54 <ski> Rmx : in general, see Natural deduction and Sequent Calculus (and to a lesser degree other proof styles, like Hilbert-style)
20:47:57 <Rmx> lots of papers are full of it
20:48:17 <MarkDBlackwell> Everyone, this is indeed a friendly channel of people, as advertised! Thanks again
20:48:18 <Rmx> thanks
20:48:18 <DanBurton> michaelbaker: you see it looks up the MyShow [a] instance of "myShow" and it sees that "myShow = myShowList".
20:48:35 <ski> Rmx : the vertical line means : if (the conjunction of) the things above the line are true, then the thing below the line is true
20:48:58 <ski> (though, on second thought, i think it's actually a *horizontal* line, no ?)
20:49:00 <DanBurton> michaelbaker: so then it needs to invoke "myShowList" on a [Char], at which time it looks at the MyShow Char instance
20:49:09 <Rmx> ouf, yes, sorry o_O
20:49:16 <Rmx> horizontal
20:49:22 <MarkDBlackwell> bye
20:49:26 <DanBurton> michaelBaker: does that make sense?
20:49:27 <Rmx> and thanks again
20:49:32 <ski> MarkDBlackwell : welcome back soon !
20:49:48 <MarkDBlackwell> ski, thank you, very much. :)
20:50:49 <michaelbaker> DanBurton: I see that progression, but I still don't get how it matches [Char] against MyShow Char. How does it pull the concrete type out of the list and use that to find the right instance?
20:51:37 <DanBurton> michaelbaker: well you see, it needs to call "myShowList", which has type "[a] -> String", for some "a" which is an instance of MyShow
20:52:16 <dobblego> http://paste.pocoo.org/show/483104/ simplified
20:52:17 <DanBurton> michaelbaker: so when it sees that you are giving it a [Char], it instantly knows that "a" is "Char", and therefore it should use the MyShow Char instance
20:53:41 <DanBurton> michaelbaker: to use the MyShow [a] instance of "myShowList" (which you didn't define), it would need a [[something]], so that it would match [something] to "a"
20:54:46 <dobblego> sepEndBy appears to be the answer
20:54:50 <michaelbaker> DanBurton: Oh! Ok! So it has to do with pattern matching the type that I give it with the definition of the type class.
20:54:51 <DanBurton> dobblego: well of course. in the case of x, the space at the end does not separate letters
20:55:17 <dobblego> DanBurton: so it should discontinue parsing at that point -- it appears that sepEndBy is specifically for this purpiose
20:55:55 <DanBurton> dobblego: suppose so; tbh I'm not that experienced with parsec
20:56:04 <DanBurton> michaelbaker: yeah that's the idea
20:56:26 <michaelbaker> DanBurton: Thanks!
20:56:42 <DanBurton> michaelbaker: though I don't think "pattern matching" is the correct term for types, it is the correct idea. I would call it "unification" in that case, but that's just getting technical ;)
20:57:31 <michaelbaker> DanBurton: I'm Ok with technical :) Do you have any suggested reading on unification?
20:58:01 <sanjoyd> Is ! is for strict fields in data constructors?
20:58:11 <sanjoyd> (These things are hard to Google. :()
20:59:49 <shachaf> sanjoyd: Yes.
21:00:10 <shachaf> sanjoyd: They're easier when you already know the answer.
21:00:16 <shachaf> @google strict fields in data constructors
21:00:17 <lambdabot> http://www.haskell.org/tutorial/moretypes.html
21:00:18 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again
21:00:48 <sanjoyd> shachaf: thanks!
21:01:43 <DanBurton> michaelbaker: um...I always forget the name of this book
21:02:57 <DanBurton> michaelbaker: PLAI that's it
21:02:59 <DanBurton> @where PLAI
21:03:00 <lambdabot> http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/
21:03:17 <michaelbaker> DanBurton: Cheers
21:03:55 <shachaf> michaelbaker: You don't need to know a whole lot about unification to understand Haskell types. :-)
21:04:11 <aspect> what's the language on the cover of PLAI?
21:04:17 <DanBurton> michaelbaker: cheers :) see Section X: types. It's not Haskell-specific, and that book is rather deep so beware ;)
21:04:33 <aspect> looks a bit like burmese or malayalam .. which are pali or devangari descended?
21:04:56 <michaelbaker> Ok, I'll give it a go and come back to it later if it's over my head.
21:05:41 <DanBurton> aspect: I was vaguely going to suggest "cuneiform" but I'm not even sure I know what that means or why I thought that is what it is
21:09:06 * DanBurton just asked about the language on the cover of PLAI at #racket for kicks and giggles
21:09:51 <aspect> heh, it's in the faq
21:09:59 * DanBurton got a response from "offby1" who said "I think its Blub"
21:10:06 <aspect> haha
21:10:43 <aspect> I was close
21:11:11 <aspect> seems to be an old form of Kannada, which is a close neighbour of Malayalam
21:11:52 <shachaf> > reverse "
21:11:53 <lambdabot>   <no location info>:
21:11:53 <lambdabot>      lexical error in string/character literal at end o...
21:11:59 * DanBurton is now reading the wikipedia article on Shravanabelagola @_@
21:12:05 <shachaf> > reverse "malayalam"
21:12:06 <lambdabot>   "malayalam"
21:12:49 <aspect> yay for diversions from programming languages into natural languages (and beyond!)
21:12:59 <DanBurton> > reverse . reverse $ "malayalam"
21:13:01 <lambdabot>   "malayalam"
21:13:19 <shachaf> aspect: We have a channel for that.
21:13:46 <DanBurton> :t <*>
21:13:46 <aspect> shachaf: how "beyond" does it get?
21:13:47 <lambdabot> parse error on input `<*>'
21:13:52 <DanBurton> :t (<*>(
21:13:53 <lambdabot> parse error (possibly incorrect indentation)
21:13:56 <DanBurton> :t (<*>)
21:13:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:14:47 <shachaf> aspect: The topic should be a good sample.
21:15:33 <DanBurton> @pl let watisthis x = g x (y x) in watisthis
21:15:34 <lambdabot> ap g y
21:15:55 <DanBurton> :t ap
21:15:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:16:42 <DanBurton> @let isPalindrome = ap (==) reverse
21:16:43 <lambdabot>  Defined.
21:16:58 <DanBurton> > isPalindrome "malayalam"
21:17:00 <lambdabot>   True
21:17:16 <luqui> > (==) <*> reverse $ "malayalam"
21:17:17 <lambdabot>   True
21:17:34 <DanBurton> <*> is the same as ap, right?
21:17:43 <shachaf> @check \xs -> isPalindrome xs == isPalindrome (reverse xs)
21:17:44 <lambdabot>   Not in scope: `isPalindrome'Not in scope: `isPalindrome'
21:18:55 <DanBurton> @check let isPal = (==) <*> reverse in \xs -> isPalindrome xs == isPalimdrome (reverse xs)
21:18:56 <lambdabot>   Not in scope: `isPalindrome'Not in scope: `isPalimdrome'
21:19:02 <DanBurton> doh
21:19:11 <DanBurton> @check let isPal = (==) <*> reverse in \xs -> isPal xs == isPal(reverse xs)
21:19:12 <lambdabot>   "OK, passed 500 tests."
21:19:19 <DanBurton> @botsnack
21:19:20 <lambdabot> :)
21:21:24 <DanBurton> @help check
21:21:25 <lambdabot> check <expr>
21:21:25 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
21:22:25 <DanBurton> @pl \xs -> isPal xs == isPal(reverse xs)
21:22:25 <lambdabot> liftM2 (==) isPal (isPal . reverse)
21:23:29 <shachaf> DanBurton: Did I embarrass you off?
21:24:07 <DanBurton> shachaf: nah, I just remembered that I was still on, so I checked to see if anyone said anything before I logged off that channel, and indeed you had
21:24:18 <DanBurton> so of course I couldn't resist saying hi. but then I left.
21:25:23 <DanBurton> I work for Jay McCarthy, a prof who is way into Racket, so I try to poke around #racket once in a while.
21:27:10 * DanBurton muses over how quickly DevHC came and went
21:28:22 <DanBurton> well yall are putting me to sleep. Sweet dreams, everyone (whenever night is for you..for me it's now)
21:48:56 <sanjoyd> I'm trying out template haskell, and am stuck at this: http://pastebin.com/nEN9vAU1
21:49:02 <mauke> The paste nEN9vAU1 has been copied to http://hpaste.org/51821
21:49:16 <sanjoyd> How do I quote an outside identifier to inside a [d|...|] ?
21:50:32 <sanjoyd> Also, is it possible to collapse a [Q [Dec]] to a Q [Dec]?
21:51:35 <napping> sure, just use the Monad instance
21:51:55 <ski> @type liftM concat . sequence
21:51:56 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
21:53:12 <napping> for the first, unfortunately pattern splices still do not seem to be supported
21:53:53 <sanjoyd> Oh, okay.  Will try to do it in longhand, I guess.
21:54:06 <kmc> that annoys me roughly every time i use TH
21:54:52 <napping> yeah, it's pretty strange there are pattern quotes but no pattern splices
22:04:00 <sanjoyd> Weird that runQ emits GHC.Types.:, which throws an error when I try to compile the TH expression.
22:04:15 <sanjoyd> And it isn't there in the GHC.Types documentation either.
22:04:41 <napping> that one is a bit odd
22:04:44 <napping> > :info (:)
22:04:45 <lambdabot>   <no location info>: parse error on input `:'
22:04:59 <napping> data [] a = ... | a : [a] -- Defined in GHC.Types
22:05:41 <napping> That syntax in built in, but some places say it's from GHC.Types
22:05:46 <sanjoyd> :|
22:06:07 <sanjoyd> So how do I go about using the expression?  Is there a GHC.Types.Cons equivalent?
22:07:40 * sanjoyd looks up InfixP
22:10:19 <napping> do you want the Con?
22:10:57 <sanjoyd> I'll try myself for a while; will ask again if still stuck.  I think I get around with a mkName ":".
22:11:23 <napping> it should
22:11:35 <napping> it's not like you can shadow the name anyway
22:14:44 <wagle> anyone know who used to do the (now defunct) "rubrication" blog?
22:19:40 <shachaf> wagle: Maybe jacobian?
22:29:19 <hpaste> meric pasted “fromExp” at http://hpaste.org/51822
22:30:00 <meric> So I 've got a function with type (Exp a -> a), can I make it do something special when `a` is Bool?
22:30:06 <meric> http://hpaste.org/51822
22:30:42 <napping> not with that type, no
22:30:49 <KirinDave> This is incredible.
22:31:04 <KirinDave> Wrong channel
22:31:13 <napping> but you have (Elt a) =>, so maybe
22:31:18 <luqui> what is Exp?
22:31:23 <luqui> er i mean Elt
22:31:30 <luqui> and also Exp
22:31:45 <meric> well, just look at them as some sort of typeclasses
22:32:06 * mauke rolls eyes
22:32:10 <meric> ...
22:32:13 <meric> its from accelerate
22:32:35 <meric> http://hackage.haskell.org/packages/archive/accelerate/0.8.1.0/doc/html/Data-Array-Accelerate.html
22:33:10 <luqui> meric, depends.  do you want to do something semantically different?
22:33:13 <shachaf> mauke's eyes may have been influenced by the fact that Exp isn't a type class.
22:33:20 <meric> yes I do.
22:33:22 <mauke> I don't see Elt in there
22:33:38 <meric> Its an incomplete documentation
22:33:56 <shachaf> Anyway, no, you probably can't. Depending on what you're after.
22:33:59 <meric> that's why I avoided telling you but since you rolled your eyes.
22:34:11 <napping> maybe Exp a -> Bool?
22:34:45 <luqui> meric, you might want to make fromExp a method of Elt
22:34:51 <luqui> that's basically the only way
22:34:54 <meric> ok
22:35:48 <hpaste> meric pasted “fromExp 2” at http://hpaste.org/51823
22:36:10 <meric> I could implement it like ^, but I thought I could do better.
22:36:14 <meric> I'll try make it a method
22:36:46 <napping> It's hard to say more without a definition of Exp or Elt
22:37:14 <meric> can I just randomly append a method to a class?
22:37:38 <napping> now it looks like maybe Exp is a GADT that might support some interesting definition
22:37:39 <luqui> oh you don't have control over the source of the class?
22:38:05 <meric> I just thought its a bad idea to modify the source of the library im using...
22:38:31 <meric> Sorry I seem like a newbie, its because I am.
22:38:50 <napping> well, Elem extends typeable
22:39:24 <luqui> meric, it's ok
22:39:47 <luqui> there is often an impedance mismatch between beginners and hackers in this channel
22:39:57 <luqui> because the way haskell problems are broken down is different than a lot of languages
22:40:01 <luqui> so people ask impossible things a lot
22:40:15 <meric> ok =\
22:40:16 <napping> http://hackage.haskell.org/packages/archive/accelerate/0.8.1.0/doc/html/src/Data-Array-Accelerate-Smart.html
22:40:54 <luqui> oh my
22:40:57 <luqui> this module looks magical
22:41:12 <napping> Yeah, lots of magic here
22:41:55 <meric> ...yeah
22:42:32 <luqui> so, what's your goal?
22:42:47 <meric> make a function that can convert a Exp a into a
22:43:20 <napping> Isn't that what Interpreter is for?
22:43:27 <meric> accelerate compiles your code into cuda, and sends it to the GPU, I'm just trying to find a way to get values back
22:43:38 <meric> (well, I found it, just trying to write it well)
22:44:07 <meric>  http://hpaste.org/51823 works, but... it doesn't feel "right"
22:44:32 <luqui> so fromExp is wrong in the Bool case?
22:44:43 <meric> yeah
22:44:45 <meric> it looks ugly
22:44:48 <meric> "fromExpBool"
22:44:51 <luqui> right
22:45:02 <luqui> and fromExp being... you know... incorrect is a thing too
22:45:03 <meric> to the human, both does the same thing
22:45:20 <meric> what do you mean, can you elaborate?
22:45:23 <napping> why doesn't (toList(run $ unit $ x))!!0 work for Bool too?
22:46:13 <meric> it so happens that they haven't implemented `Array(Exp Bool)`
22:46:33 <meric> with other stuff, like numbers, I put it in the array, run it, and get the value back
22:46:35 <napping> Ah, well, this isn't a good project for starting out
22:46:40 <meric> can't do it with bool.
22:46:57 <meric> Too bad this is what my professor is making me do, huh.
22:47:29 <luqui> i am not that familiar with accelerate
22:47:31 <meric> Nah, just kidding, but yeah, my university thesis is to write something using it.
22:47:33 <meric> ok
22:47:39 <luqui> but can you convert it to an int
22:47:42 <luqui> and then convert back?
22:47:43 <meric> i can
22:47:44 <luqui> something like that?
22:47:55 <luqui> oh right, but it's ugly
22:47:57 <meric> but, will I be able to write it as a special case?
22:48:03 <meric> of fromExp
22:48:05 <meric> and keep the same name
22:48:24 <luqui> unfortunately no
22:48:31 <luqui> you'd need to make an instance of Elt Bool
22:48:47 <meric> ahh
22:48:51 <luqui> or maybe you could subclass Elt
22:48:53 <meric> I get it.
22:48:57 <meric> maybe I should. :)
22:49:04 <luqui> and then submit a patch :-)
22:49:33 <luqui> actually I think technically you would need to *superclass* Elt
22:49:39 <luqui> which is something Haskell is... not very good at
22:49:56 <luqui> oh no a subclass would work
22:50:04 <napping> anyway, it sounds like you probably should talk to the package maintainers, and if it's incomplete you do want to consider changing the source
22:50:11 <meric> I'll look into it...
22:50:11 <luqui> class MyElt a where something
22:50:28 <luqui> instance (Elt a) => MyElt a where ...   -- bad form, but sometimes you need to
22:50:36 <luqui> instance MyElt Bool where ...
22:50:47 <napping> um, that's not sounding like a very good solution
22:51:12 <luqui> why?  because of the overlapping?
22:51:48 <napping> compared to either making a proper instance Elem Bool, or a special purpose Exp Bool -> Bool
22:51:49 <luqui> i don't like overlapping instances.  i also don't like having to contact package maintainers just to extend a library.
22:52:02 <luqui> yeah i guess making an Elt Bool instance would be just as easy
22:52:07 <luqui> ok I take back my subclass idea
22:52:41 <luqui> it's an orphan... but orphan / overlapping have the same modularity problems
22:53:59 <napping> that looks like a bad implementation of fromExpBool
22:54:08 <napping> doesn't it only say "True" on the expression 1==1?
22:54:38 <napping> how about \e -> fromExp (boolToInt e) == 1
22:55:45 <meric> it says : if x is (True::Exp Bool) then return True::Bool
22:56:14 <meric> I couldn't figure out how to write (True::Exp Bool) so I just wrote (1==*1) to coax it.
22:56:28 <napping> "it"?
22:56:36 <luqui> I think it says if x is *the syntactic expression* "1==*1"
22:56:45 <meric> if x is true
22:56:46 <luqui> probably not what you want
22:56:48 <meric> then x == (1==*1)
22:56:57 <luqui> what about (2==*2)
22:57:18 <meric> ok nvm it doesn't actually work
22:57:25 <meric> I'll go fix it and update a new version
22:58:56 <hpaste> meric pasted “fromExpBool” at http://hpaste.org/51824
22:58:59 <meric> there
23:00:16 <luqui> that looks more reasonable
23:02:07 <napping> How is Elt different from Elem?
23:02:54 <meric> the latter is deprecated
23:03:26 <napping> in what version?
23:03:43 <meric> um, 0.9.0.0
23:03:49 <napping> where's that?
23:04:41 <meric> https://github.com/sseefried/accelerate
23:05:11 <napping> is it still a subclass of Typeable?
23:06:00 <luqui> still going to need to get the dictionary from somewhere
23:06:29 <meric> I'm looking through the source
23:06:34 <napping> if so, you could probably make a single function if you really need to
23:06:38 <meric> but is there a command to easily check the class
23:06:41 <napping> :info
23:07:12 <meric> yes it is still a subclass of Typeable
23:07:22 <meric> class (Show a, Data.Typeable.Typeable a,....
23:07:30 <napping> where is it defined?
23:07:37 <luqui> napping, i'm curious how you are going to use that to solve this problem though
23:07:38 <napping> is there an instance for Bool?
23:07:49 <meric> I found it using :info
23:07:51 <meric> there is
23:07:58 <meric> instance Elt Bool -- Defined in Data.Array.Accelerate.Array.Sugar
23:07:58 <napping> fromExp was happy to assume (Elt a) =>
23:08:14 <luqui> oh... there *is* an instance of Elt Bool?
23:08:27 <luqui> meric, so how is fromExp broken in the Bool case?
23:08:51 <meric> Well, when I use it on a Exp Bool, it just says it hasn't been implemented for the CUDA backend yet
23:08:57 <meric> but it works if you use the Interpreter
23:09:02 <meric> the Interpreter uses the CPU
23:09:07 <meric> but the CUDA one uses the GPU
23:09:31 <napping> I thought the point was to get the CPU one working
23:09:37 <meric> ", it just says it hasn't been implemented for the CUDA backend yet" -> specifically, Exp Bool arrays are not implemented
23:10:11 <meric> oh, well the point is to get the GPU one working; if I want to use the CPU one, I should just use straight Haskell
23:10:34 <meric> the Exp a -> a one works for Bools too in the Interpreter
23:11:07 <luqui> oh so they made an Exp Bool instance, and then said error "not implemented"
23:11:13 <meric> but I want to get it working for CUDA; I just switched to testing on a CUDA device. but all my code is written with fromExp, not fromExpBool
23:11:17 <luqui> that's probably the least useful decision
23:11:25 <luqui> but napping's typeable idea will work now
23:11:35 <napping> not at all, this lets you have subexpressions of type Bool for conditionals inside your array code
23:11:53 <meric> oh I can actually look at the types during runtime? :D
23:11:59 <napping> how often do you write a gpu program that returns a single bool?
23:12:02 <luqui> meric, yeah, Typeable lets you do that
23:12:18 <luqui> napping, at least once if you are meric?
23:12:23 <napping> et f a = case cast a of Nothing -> a; Just x -> case cast (x + 1 :: Int) of Just r -> r; Nothing -> a in (f 'X', f "str", f (10::Int))
23:12:28 <napping> > let f a = case cast a of Nothing -> a; Just x -> case cast (x + 1 :: Int) of Just r -> r; Nothing -> a in (f 'X', f "str", f (10::Int))
23:12:29 <lambdabot>   ('X',"str",11)
23:12:37 <meric> napping: My program has several dozen steps, each step I need to check a condition to see if I terminate.
23:12:47 <napping> o/' one of these things is not like the other o/'
23:12:54 <meric> so, several dozen "programs" that return a single bool each...
23:13:29 <napping> anyway, this sounds very much like you should talk the to maintainers about making it work, if you have a use case and all
23:14:02 <meric> I think its already on their TODO list, if when I try to use it, it says "not implemented"...
23:14:23 <napping> that sounds like "we couldn't think of a reason to bother"
23:14:58 <napping> or you could just have each step of your program return an int flag for now
23:14:58 <meric> ok.. I'll talk to them about it
23:15:04 <meric> or that.
23:15:19 <napping> what's a gpgpu program without at least one ugly hack?
23:15:38 <meric> :)
23:15:55 <napping> just be glad you don't have to do it all with multitexturing!
23:16:06 <meric> ...yeah
23:16:11 <napping> those were the (bad) days
23:16:31 <meric> lucky I wasn't born then.
23:17:23 <napping> it's probably hard to get bool arrays working, if cuda doesn't do them
23:17:46 <meric> I'll just use my fromExpBool
23:17:57 <meric> and talk to them about it
23:18:08 <napping> the scalar case seems easiser
23:18:26 <meric> fromScalar x = x ! index0
23:18:27 <meric> yeah
23:18:30 <meric> definitely
23:18:43 <meric> wait that turns a Scalar into Exp
23:18:55 <napping> well, more that it's actually reasonable to coerce through int
23:19:05 <napping> with cuda having a bool type
23:19:59 <meric> I don't understand
23:20:14 <napping> you are using a function for evaluating arrays
23:20:21 <meric> yes
23:20:21 <napping> just using it on a very short array
23:20:28 <meric> mmhm
23:20:30 <napping> cuda doesn't allow bool (or char) arrays
23:20:40 <meric> yup
23:20:49 <napping> so there's no way to support arrays of bools in accelerate
23:21:00 <napping> and there doesn't seem to be a direct scalar evaluation function
23:21:17 <meric> I think I get the gist of what you're saying now.
23:21:36 <napping> you want a nicer interface than cuda provides, so it might not be easy
23:21:43 <meric> it'll be more complicated to convert a haskellian bool into int form and back
23:21:48 <meric> compared to just using Ints
23:23:33 * hackagebot fix-imports 0.1.3 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-0.1.3 (EvanLaforge)
23:51:32 <wavewave> is there any benchmark of each type of haskell arrays against C array (or assembly array)?
23:52:18 <wavewave> for pure array, just reading, for ST and IO array, read /write
23:52:35 <kmc> not that i've seen
23:52:42 <kmc> you could put it together quickly with Criterion
23:52:49 <Axman6> only for Ptr
23:53:03 <shachaf> Such microbenchmarks are often misleading unless done carefully.
23:53:07 <Axman6> well, the speed for Ptr's is slightly slower than C arrays i believe
23:53:24 <luqui> i'd like to see a C array program ported to imperative ST benchmarked
23:53:24 <Axman6> but yes, that's not something that's very useful to benchmark
23:53:54 <wavewave> Axman6: where can I see that benchmark for Ptr?
23:54:25 <Axman6> the best you'll find is on the language shootout. but i haven't seen anyone do such a boring benchmark anywhere before
23:54:43 <hpaste> boegel pasted “transformers fail” at http://hpaste.org/51825
23:54:59 <boegel> anybody know what can cause this? ^
23:55:19 <wavewave> I am curious how fast ST array is especially.
23:55:26 <wavewave> STU array.
23:55:56 <kmc> it should be exactly as fast as IOUArray
23:56:13 <wavewave> oh. that's good.
23:56:46 <Axman6> wavewave: STUArrays are not as fast as they could be because of their use of Ix for indices. Vectors might be a better comparison to C arrays
23:56:51 <wavewave> so internally, ghc treats it the same as IOUArray?
23:56:59 <Axman6> they are basically the same
23:57:18 <Axman6> type IOUarray a = STUArray RealWorld# a or something like that
23:58:30 <wavewave> does Vector have similar interface to ST array? thawing and freezing.
23:59:20 <wavewave> I found STVector.
23:59:37 <wavewave> okay.. that's good.
