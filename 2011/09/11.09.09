01:04:48 --- topic: '["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]'
01:04:48 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Sat Sep 03 10:10:12 2011]
01:05:06 <Jafet> I wonder what it returns for sockets, symlinks, directory junctions, or anything in a plan9 space
01:06:07 <Veinor> i assume it follows symlinks
01:06:12 <Veinor> oh, doesFileExist
01:11:06 <lpsmith> Well,  I figure if sort counted the number of monotonic runs it had to compute,  it could use that to choose a "better" shape of the binary tree.   That could probably be done pretty cheaply
01:13:10 <lpsmith> It'd be interesting to generate pessimal family of inputs for this potential weakness:   number of monotonic runs as one less than a power of two,  with runs near the root of the tree of merges having the largest elements to make sure that elements in the big complete tree that's far from the root gets copied a maximal number of times.
01:13:35 <lpsmith> that way you could gauge the most optimistic improvement possible by merging more intelligently.
01:17:30 <lpsmith> well, by choosing a better tree of merges, that is
01:18:11 <Jafet> My plan was to only merge lists shorter than c*2^k at step k
01:20:17 <lpsmith> yeah, some reordering of runs I did consider,  but that does sound a lot more difficult to come out ahead with than simply choosing a truly balanced tree
01:21:54 <lpsmith> now,  if you have the length of a list,  how do you efficiently create a binary tree...
01:22:00 <Jafet> "Reordering"? You mean, changing (merge a b) to (merge b a)?
01:22:08 <Jafet> Or changing associativity?
01:22:36 <lpsmith> well, associativity and/or commutativity,  based on the lengths of the lists to be merged
01:23:25 <Jafet> It's not commutative, because sort should be stable. So you can't do that.
01:23:42 <Jafet> At least, I'm pretty sure it's currently stable.
01:24:10 <lpsmith> yeah, it should be stable, and I believe it is currently.  You are right.
01:25:53 <lpsmith> It is stable... the one thing i didn't immediately see was the fact that breaking the input into increasing runs reversed the decreasing runs... but that's stable because you know that those elements have to move past each other anyway
01:26:38 <lpsmith> But that makes me wonder if I have a left-biasing bug in my nubSort.
01:26:51 <lpsmith> I don't think I do
01:27:04 <lpsmith> I probably considered that already
01:27:06 <aslambabubhai> hiii
01:27:47 <aslambabubhai> yup i want to know abt haskell basic concept
01:28:31 <aslambabubhai>  r u there
01:28:40 <DrTeggy> Haskell Basic?
01:28:42 <ivanm> no, we're not
01:28:48 <shachaf> @hackage BASIC
01:28:48 <lambdabot> http://hackage.haskell.org/package/BASIC
01:28:55 <DrTeggy> ah, that one
01:29:51 <aslambabubhai> thanks for it
01:30:28 <ivanm> I somehow doubt that's what aslambabubhai wants...
01:30:46 * DrTeggy too
01:30:48 <lpsmith> You guys are terrible,  we are going to lose our reputation for being a friendly welcoming channel.  :)
01:30:52 <aslambabubhai> can u suggest any good preference book for haskell introduction
01:31:01 <lpsmith> @where LYAH
01:31:01 <lambdabot> http://www.learnyouahaskell.com/
01:31:02 <DrTeggy> Oh yes.
01:31:28 <DrTeggy> Yes, that's a great resource for getting to know the language.
01:31:37 <aslambabubhai> thats looks  good
01:31:49 <ivanm> lpsmith: we discussed that a couple of weeks back, and decided that saying we were a friendly welcoming channel was arrogant and thus we shouldn't claim that anymore... :p
01:32:00 <lpsmith> hahaha
01:32:59 <Wild_Cat> instance Monad Goto where...
01:33:06 <gaurav__> 2+3
01:33:15 <gaurav__> 2+3
01:33:17 <lpsmith> >  2+3
01:33:18 <lambdabot>   5
01:33:19 <gaurav__> add
01:33:21 <aslambabubhai> i want 2 know abt monads
01:33:30 <gaurav__> hiiiiiiiiiii
01:33:36 <aslambabubhai> hi
01:33:37 <ion> Sorry, one can only three know ABT monads.
01:33:51 <DrTeggy> aslambabubhai, hmm, monads aren't hardly the best entry point to Haskell.
01:33:54 <ivanm> aslambabubhai: learn Monads by using them whilst you read tutorials and work on code
01:33:59 <gaurav__> hey tell me about haskell
01:34:07 <ivanm> I think RWH has one of the best approaches to learning Monads
01:34:17 <gaurav__> RWH??
01:34:18 <ivanm> "O HAI, we've actually been using Monads all along!"
01:34:23 <ivanm> Real World Haskell
01:34:24 <ivanm> @where rwh
01:34:25 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:34:34 <ivanm> gaurav__: what do you want to know?
01:34:38 <DrTeggy> Don't forget to encourage the RWH authors to work on a new edition.
01:34:56 <gaurav__> i want to prerate haskell
01:35:03 <aslambabubhai> is hasskell is usefull for preparing game concept
01:35:04 <gaurav__> but i dont know c and c++
01:35:06 <ivanm> gaurav__: "prerate" ?
01:35:18 <ivanm> aslambabubhai: some people write games in Haskell
01:35:46 <DrTeggy> https://spreadsheets.google.com/spreadsheet/viewform?formkey=dHpfU3FtRW5uWnlvLUYzeE1Kc25kZlE6MQ
01:35:47 <aslambabubhai> is any 1 there
01:35:50 <gaurav__> what??
01:36:01 <jitu> hi
01:36:10 <jitu> hi asalam bhai
01:36:29 <gaurav__> hey
01:36:33 <gaurav__> where r u
01:36:55 <ivanm> aslambabubhai: you know we're here, we've already started answering your questions...
01:37:03 <ion> Note that jitu, gaurav__ and aslambabubhai all come from the same address.
01:37:03 <jitu> hey i am from briten
01:37:06 <leod> is it troll time?
01:37:18 <ivanm> ion: I was just thinking about that...
01:37:27 <gaurav__> yes
01:37:28 <aslambabubhai> haahaa n i m frm india?
01:37:29 <ivanm> (as in thinking to check that)
01:37:29 <lpsmith> yeah, all three are connected from the same IP
01:37:36 <Jafet> That's so mean, ion.
01:37:44 <DrTeggy> lpsmith, that's called time-sharing.
01:37:46 <DrTeggy> :-)
01:37:56 <lpsmith> lol
01:38:03 <jitu> lol
01:38:05 <lpsmith> Oh, ion already pointed that out
01:38:06 <aslambabubhai> lol.......
01:38:17 <jitu> hey
01:38:20 <gaurav__> sir tell me pls
01:38:30 <lpsmith> is there an op around?
01:38:38 <shachaf> @where ops
01:38:39 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:38:39 <gaurav__> i dont have a knowledge about c and c++
01:38:40 <aslambabubhai> thats we r teaching u the concept of time sharing
01:38:41 <jitu> please tell me about manods
01:38:51 <gaurav__> so can i learn haskell???
01:38:51 <ivanm> gaurav__: why do you need a knowledge about C or C++ ?
01:39:02 <ivanm> gaurav__: sure
01:39:05 <aslambabubhai> which language dear????????
01:39:08 <gaurav__> sir haskell is based on c and c++
01:39:18 <lpsmith> not C++
01:39:21 <ivanm> aslambabubhai: huh?
01:39:31 <ivanm> gaurav__: no it isn't
01:39:34 <aslambabubhai> yup
01:39:34 <ion> ivanm: No need to bite.
01:39:45 <lpsmith> C, sort of,  but you don't need to know C unless you are going to interface with something written in C or hack on the runtime.
01:39:50 <ivanm> not unless you mean in the sense that Haskell runs on Unix-based OSs and they are based upon C
01:39:57 <gaurav__> ok than i directly learn haskell
01:40:07 <aslambabubhai> y  r u  cmg on the concept of c n c++
01:40:08 <jitu> please tell me why haskell?
01:40:19 <ivanm> jitu: why Haskell what?
01:40:48 <gaurav__> sir what is the best way to learn haskell?
01:40:48 <aslambabubhai> 4 wat purpose we use haskel
01:40:58 <jitu> why we used haskell for programming ?
01:41:01 <aslambabubhai> wats its sisnificance
01:41:07 <ivanm> we use Haskell because we want to
01:41:14 <ivanm> for it's significance/difference, see the wikipedia page
01:41:20 <frerich> Maybe they are three students sitting in some class in the middle of India right now, forwarding questions.
01:41:33 <jitu> yes
01:41:41 <ivanm> frerich: yeah, I did consider that, which is why I'm trying to keep answering their questions
01:41:47 <ivanm> but when they keep repeating the same ones...
01:41:57 <gaurav__> yes sir we are in same class
01:42:20 <aslambabubhai> sir pls give detail
01:42:22 <ivanm> so why are you all here?
01:42:27 <ivanm> because you want to learn Haskell?
01:42:36 <ivanm> if so, someone already pointed out LYAH to you
01:42:39 <aslambabubhai> 2  know about haskeelll
01:42:41 <gaurav__> sir we sitting on different p.cs
01:42:50 <ivanm> @where LYAH
01:42:50 <lambdabot> http://www.learnyouahaskell.com/
01:42:58 <gaurav__> but our clg ip off p.cs are same
01:43:26 <aslambabubhai> wat is the significance of using haskell in daily life
01:43:43 <lpsmith> gaurav__, aslambabubhai jitu,  you've been told to go read LYAH.
01:43:49 <quicksilver> there are some great tutorials on haskell, which you've been pointed to
01:44:00 <quicksilver> RWH, LYAH, possibly the wikibook
01:44:07 <quicksilver> this channel is better suited for specific questions
01:44:15 <gaurav__> thanx
01:44:17 <gaurav__> sir
01:44:48 <ivanm> @google haskell wikipedia
01:44:49 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)
01:44:49 <lambdabot> Title: Haskell (programming language) - Wikipedia, the free encyclopedia
01:45:00 <ivanm> ^^ there, read that for an idea about what Haskell is
01:45:13 <lpsmith> aslambabubhai, gaurav__, jitu:  once you've read some LYAH, and have some specific questions you are welcome to come back here
01:45:32 <gaurav__> thanx sir or mam
01:45:51 <gaurav__> LYAH
01:45:58 <gaurav__> send a link of LYAH
01:46:04 <lpsmith> @where LYAH
01:46:04 <ivanm> again:
01:46:05 <lambdabot> http://www.learnyouahaskell.com/
01:46:10 <priyanka> hi gaurav i have joined
01:46:37 <gaurav__> hiiii
01:46:41 <DrTeggy> I sometimes wish I would not know Haskell at all so that I could have the wonderful experience of discovering the language again.
01:46:44 <ivanm> priyanka: as we've told your seeming compatriots: this channel is useful for specific questions, etc.
01:46:56 <ivanm> to learn Haskell, see http://www.learnyouahaskell.com
01:47:02 <ivanm> (just to try and avoid repeats :p)
01:47:03 <priyanka> no sir
01:47:18 <priyanka> we are here for specific reason
01:47:51 <b_jonas> DrTeggy: there's always something new to learn
01:48:09 <priyanka> i am not getting my heskell teacher properly
01:48:12 <ivanm> DrTeggy: maybe learn AGDA?
01:48:13 <DrTeggy> b_jonas, that's true, fortunately.
01:48:24 <priyanka> so i want to learn haskell
01:48:40 <DrTeggy> ivanm, yeah, maybe.
01:48:46 <gaurav__> bye thanku sir
01:49:00 <ivanm> @where lyah
01:49:01 <lambdabot> http://www.learnyouahaskell.com/
01:49:03 <gaurav__> but can i download LYAH book
01:49:07 <ivanm> @where wikibook
01:49:07 <lambdabot> http://en.wikibooks.org/wiki/Haskell
01:49:13 <ivanm> priyanka: ^^ there you are
01:49:26 <ivanm> gaurav__: you can buy a PDF version
01:49:30 <priyanka> yes sir
01:49:42 <ivanm> and if you google you may be able to find a PDF of the website
01:49:42 <gaurav__> sir this site is not open]
01:50:25 <ivanm> uhhh.... which one?
01:50:30 <ivanm> LYAH is working...
01:50:42 <gaurav__> not it is not working
01:51:09 <ivanm> how is it not working?
01:51:13 <ivanm> the website loads here
01:51:17 <gaurav__> http://en.wikibooks.org/wiki/Haskell this site is not opening]
01:51:23 <ivanm> I just opened it
01:51:33 <gaurav__> kk
01:51:48 <ivanm> try http://en.wikibooks.org/wiki/Haskell/Print_version and http://upload.wikimedia.org/wikipedia/commons/2/26/Haskell.pdf as well
01:51:59 <priyanka> sir please tell me something about the scope of haskell
01:52:13 <shachaf> Lexical.
01:52:14 <ivanm> priyanka: huh?
01:52:19 <ivanm> what do you mean?
01:52:19 <ion> blueish yellow
01:52:20 <gaurav__> kk
01:52:39 <priyanka> there are a few companies are using haskell in india
01:54:21 <priyanka> then i say that there are no career in haskell within india
01:54:32 <lpsmith> Does somebody happen to know a good bit-hack for un-setting the most significant bit?
01:54:40 <priyanka> are you there sir?
01:54:49 <ivanm> priyanka: many universities teach Haskell not because it's necessarily going to get you a job
01:55:09 <ivanm> but because it's a good language to learn in terms of teaching you programming discipline, various programming techniques and stretching your mind
01:55:10 <priyanka> so for what??
01:55:20 <leod> do the foldr/foldl websites still exist, where you could see the structure they create?
01:55:33 <priyanka> according to me many jobs on the basis of haskell
01:55:54 <DrTeggy> lpsmith, maybe in http://graphics.stanford.edu/~seander/bithacks.html ?
01:56:02 <ivanm> *shrug* there are some companies that use it
01:56:15 <ivanm> mainly smallish consultancy companies and some financial ones
01:56:17 <lpsmith> DrTeggy: already looking at it :)
01:56:24 <shachaf> leod: Looks like they don't contain the old contents, at least.
01:56:24 <priyanka> which companies?
01:56:29 <leod> shachaf: :(
01:56:44 <ivanm> @google haskell in industry
01:56:46 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
01:56:46 <lambdabot> Title: Haskell in industry - HaskellWiki
01:57:01 <ivanm> http://haskell.org/haskellwiki/Haskell_in_industry
01:57:05 <ivanm> (since lambdabot was taking too long)
01:57:07 <ivanm> bah
01:57:18 <shachaf> leod: They're owned by the same person, though, so there might be hope for them coming back.
01:57:29 <shachaf> leod: Email him.
01:57:32 <leod> i hope so, heh
01:57:36 <leod> good idea
01:58:55 <priyanka> thank you sir
01:59:27 <priyanka> i will be next functional programming developer
02:00:56 <lpsmith> ivanm: I think that was IRC taking too long,  I got lambdabot's message before yours :)
02:01:26 <confab> trolltech?
02:01:41 <ivanm> lpsmith: yeah, could be
02:01:44 <lpsmith> DrTeggy: yeah I'm thinking the best approach would be to round down to the next smallest power of two and then subtract
02:01:58 <lpsmith> unfortunately Haskell is terrible at bit twiddling
02:02:44 <lpsmith> err,  I mean GHC is terrible at bit twiddling
02:03:40 <ivanm> lpsmith: qualified before a devotee of nhc, uhc, hugs, etc. gets going? :p
02:04:02 <lpsmith> lol, I doubt any of those are any better
02:04:36 <lpsmith> qualified before somebody points out that we might have a haskell compiler that's good at bit twiddling someday
02:04:43 <ivanm> ahhh
02:04:49 <lpsmith> the language isn't bad at it,  the implementations are.
02:04:57 <ivanm> lpsmith: some future version of GHC might be excellent at bit twiddling!
02:04:58 <ivanm> :p
02:05:03 <lpsmith> exactly :)
02:05:07 <mm_freak_> they're not as good as C, but certainly not bad
02:05:16 <mm_freak_> you just shouldn't use Integer for bit twiddling
02:05:40 <lpsmith> mm_freak_: have you ever looked at the assembler generated by GHC from bit twiddling algorithms?
02:05:56 <mm_freak_> lpsmith: no, but i've done comparison benchmarks
02:07:28 <lpsmith> well, I haven't done the benchmarks,  but I have compared assembler.  On most of them I wouldn't expect GHC to be competitive.
02:08:21 <lpsmith> Not with C or assembly language
02:09:02 <lpsmith> Now if you are doing bit twiddling in Python or whatever, yeah GHC probably beats the pants off of it.
02:10:00 <lpsmith> anyway,  it doesn't matter for my application
02:20:09 <mm_freak_> lpsmith: i agree that the bit twiddling in Data.Bits is slow
02:20:35 <mm_freak_> if you want to do that, use UArray or unboxed Vector over Bool
02:21:04 <mm_freak_> i usually get about 60%-70% of GCC speed
02:28:39 <lpsmith> what kind of bit twiddling do you do?   I'm talking mostly stuff on a single word
02:28:47 <lpsmith> duh...
02:29:11 <lpsmith> Due to a conceptual mistake, the merge tree used by sort isn't as bad as I thought it was
02:29:33 <lpsmith> 2^n - 1 in particular isn't pessimal
02:29:48 <lpsmith> 2^n + 1 on the other hand is
02:30:42 <balta2ar> ghc fails to make the program with -prof which uses HTTP module: "Perhaps you haven't installed the profiling libraries for package `HTTP-4000.1.1'?" How do I fix that?
02:31:54 <koeien> balta2ar: cabal install http --reinstall -p
02:32:18 <balta2ar> koeien: -p for profile?
02:32:29 <koeien> balta2ar: there is a way to configure Cabal to always build the profiling versions for libraries you install
02:32:42 <koeien> balta2ar: yes, -p builds two versions of your package. it stands for profile
02:33:06 <koeien> one of the versions is without profiling, including optimizations, since profiling slows your program down
02:34:30 <balta2ar> koeien: can I build HTTP and dependent modules with a single command? it says now that mtl profiling lib is missing
02:35:23 <balta2ar> koeien: configuring Cabal this way would be great. how do I do that?
02:35:40 <koeien> balta2ar: i'm not sure, i chase dependencies manually in this case, but you could try adding --upgrade-depdencies
02:35:50 <ceii> balta2ar, I'd suggest setting library-profiling to true in your .cabal/config, scrapping your current package database, and rebuilding from scratch
02:36:11 <ceii> I don't think there's a way of recursively rebuilding dependencies at the moment
02:40:06 <tsousa> which are the most famous haskell opensource apps?
02:40:24 <ceii> tsouta: xmonad and darcs probably?
02:40:24 <koeien> tsousa: I think darcs, ghc, xmonad
02:40:32 <ceii> oh yeah, ghc :)
02:41:08 <tsousa> ghc is written in haskell?
02:41:14 <ceii> yep
02:41:26 <ceii> except the runtime which is in written in C
02:41:31 <koeien> yes, but the runtime in C
02:42:31 <tsousa> ok question. i am not a very good programmer, i just did some exercices in c and python, in large programming project i simple cant do it. do you think haskell can help me?
02:43:16 <sp3ctum> tsousa, don't stress about not being very good unless you have to because of your job or something
02:43:36 <ceii> tsousa, do you mean: can Haskell help you move from exercices to a larger project?
02:43:43 <tsousa> ceii, yes
02:43:47 <Jafet> Why not read How to Design Programs?
02:43:57 <Guest52862> hi guys, do you know some good tutorial,written in simple language, to learn about designating types in haskell ? it will be on my exam soon, and i still can't do it correctly.
02:44:30 <tsousa> sp3ctum, but i want to be good :)
02:45:04 <sp3ctum> tsousa, you will be in time. you probably have what it takes but are not that experienced just yet
02:45:07 <ceii> I don't think it's qualitatively easier to do this with Haskell. As much as I'd like to encourage you to learn it, of course.
02:45:14 <companion_cube> "How to design programs" is this a book about haskell programs?
02:45:24 <Jafet> Nope, it's SICP for idiots
02:45:33 <sp3ctum> so the worst thing is getting depressed and losing interest, at least in the long run
02:45:36 <ceii> if you want to get a taste of larger projects, do it in languages you already know.
02:45:36 <aslambabubhai> u idiot
02:45:38 <Jafet> It's written by educators, and is supposed to be good
02:45:46 <companion_cube> :/
02:46:08 <aslambabubhai> yo
02:46:10 <Jafet> I would have tsousa read it.
02:46:14 <Guest52862> hi guys, do you know some good tutorial,written in simple language, to learn about designating types in haskell ? it will be on my exam soon, and i still can't do it correctly. Will someone help me ?
02:46:24 <aslambabubhai> ya.
02:46:48 <tsousa> Jafet, it's better than sicp?
02:47:04 <ceii> Guest52862, I'm not sure what you mean by "designating" types. But have you tried reading Learn you a Haskell?
02:47:09 <ceii> @where lyah
02:47:09 <lambdabot> http://www.learnyouahaskell.com/
02:47:39 <Guest52862> @lambdalot i've just read it
02:47:39 <lambdabot> Unknown command, try @list
02:47:44 <Jafet> tsousa: for your needs, maybe.
02:48:05 <Jafet> "Better" isn't relevant, anyway--nothing stops you reading both
02:48:08 <sp3ctum> i recommend that book too
02:48:20 <aslambabubhai> chal yar bye kal milenge sir dukh gaya mera to tere se bat karke
02:48:24 <sp3ctum> also the one about designing programs, but maybe the haskell book first
03:09:52 <aleator> Anyone know how to pass multiple extra-include-dirs to cabal on the command line?
03:20:03 <magicman> > (\(+) -> 5 + 2) (*)
03:20:04 <lambdabot>   10
03:20:13 <magicman> Oh, wow, it works.
03:20:23 <Jafet> > let 2 + 2 = 5 in 2 + 2
03:20:25 <lambdabot>   5
03:20:40 <Jafet> @src on
03:20:41 <lambdabot> (*) `on` f = \x y -> f x * f y
03:20:48 <magicman> Well, yes. It just never occurred to me that you could bind symbols by lambda :p
03:21:12 <dafis> symbols are just variables, in that place
03:21:45 <magicman> *nod*
03:21:54 <Jafet> @pl (\(+) x y -> y + x) (-)
03:21:54 <lambdabot> (line 1, column 4):
03:21:55 <lambdabot> unexpected "+"
03:21:55 <lambdabot> expecting pattern
03:22:26 <Jafet> @vixen abort retry fail
03:22:26 <lambdabot> I Think you're fake
03:36:49 <jpcooper> there has been a discussion on Haskell Cafe regarding the usage of mapM with IO. Someone has said, "The problem is that IO's semantics imply that nothing can be made available
03:36:53 <jpcooper> before the entire list has been consumed and a large thunk is built on the
03:36:53 <jpcooper> way.
03:37:05 <jpcooper> could someone please explain that?
03:37:42 <Lemmih> jpcooper: You can't get the first result until the last result has been computed.
03:38:10 <Jafet> orly.
03:38:59 <jpcooper> why is that?
03:39:27 <ivanm> if I build something with ghc on one machine, and try to run it on another machine which doesn't have libgmp on it, is it possible to just copy the libgmp.so file somewhere and get my binary to just use that?
03:39:33 <ivanm> @src mapM
03:39:33 <lambdabot> mapM f as = sequence (map f as)
03:39:37 <ivanm> @src sequence
03:39:37 <lambdabot> sequence []     = return []
03:39:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:39:38 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:39:39 <Lemmih> jpcooper: Because of the semantics of IO.
03:39:44 <Jafet> ivanm, if the libgmp.so would work there, yes.
03:39:51 <ivanm> jpcooper: ^^ because of how sequence is defined
03:39:52 <jpcooper> Lemmih: yes that is exactly what the quote said
03:40:11 <ivanm> to construct the list, it waits until it evaluates the rest of it first
03:40:18 <Jafet> IO's semantics don't imply anything like that
03:40:26 <Jafet> Eg. mapM_ print [0..]
03:40:33 <jpcooper> yes of course
03:40:34 <ivanm> Jafet: how do I tell the binary where to find it though?
03:40:37 <jpcooper> thanks
03:40:50 <Jafet> ivanm: put it where the binary wants it to be. See ldd
03:41:07 <Lemmih> Jafet: What does 'mapM_' have to do with it?
03:41:18 <Jafet> @src sequence_
03:41:19 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
03:42:00 <ivanm> Jafet: any way to put it elsewhere? (since I can't exactly go and shove an extra library in /usr/lib on the second machine)
03:42:10 <Jafet> Oh, IO's semantics does imply that. Sorry.
03:42:25 <ivanm> or would that require re-compiling it using that other location?
03:42:31 <dafis> ivanm: fiddling with LIBRARY_PATH might help
03:42:57 <Cale> Hey, you could fork a new thread in which to perform the computations and write their results into a Chan that you read back with getChanContents
03:43:07 <ivanm> doesn't seem to work :s
03:43:11 <Cale> But that pretty much amounts to using unsafeInterleaveIO anyway
03:43:17 <ivanm> and echo "$LIBRARY_PATH" returns an empty list
03:43:28 <ivanm> s/list/string/
03:43:30 <ivanm> Cale: heh
03:44:35 <ivanm> dafis: it's LD_LIBRARY_PATH, and it works now! :D
03:44:48 <ivanm> (I knew there was some variable LD_<something>, but thought it was LD_LOADPATH :s)
03:44:50 <dafis> ivanm: great
03:45:28 <ivanm> now to work out how to set LD_LIBRARY_PATH when ssh'ing in to that machine, without setting it on the other machine (since it uses the same .bashrc)
03:45:54 <Jafet> ivanm: ld -R
03:46:03 <Jafet> I'm not sure if you can use -R=.
03:46:16 <Jafet> And what it would mean in that case
03:46:37 <ivanm> don't have ld on that machine :/
03:46:40 <Phyx-> Does anyone know by chance in Cabal, when using a Custom buildtype, where is the Setup.lhs information stored? Can you get to it from a PackageDescription?
03:46:40 <Jafet> Also, that might require you to bypass ghc a bit
03:46:53 <ivanm> (it's only meant to be an ssh gateway box, but I want to be able to access a darcs repo from it)
03:48:05 <mm_freak_> jpcooper: mapM is fine for some monads like Maybe, but in general you would rather want to avoid it, if you can
03:48:17 <mm_freak_> of course sometimes keeping the entire list in memory is exactly what you want
03:48:30 <mm_freak_> but in all other cases you may want to use foldM or other combinators instead
03:50:38 <dafis> mm_freak_: Maybe isn't entirely unproblematic either for mapM, you still have to traverse the entire list to find out whether you have a Nothing or Just
03:52:14 <mm_freak_> > mapM (const Nothing) [1..]
03:52:14 <lambdabot>   Nothing
03:52:17 <mm_freak_> no, you don't
03:52:42 <dafis> yeah, I meant to say 'when you get a Just'
03:52:45 <quicksilver> mm_freak_: if you get an early nothing that's easy :)
03:53:00 <mm_freak_> well, i would expect exactly that =)
03:53:03 <quicksilver> sure
03:53:05 <Jafet> Well, it doesn't use unbounded space.
03:53:07 <quicksilver> it can't do anything else
03:53:15 <quicksilver> but it's still a factor
03:53:16 <mm_freak_> also you still get constant memory if you want
03:53:29 <mm_freak_> > mapM Just [1..] !! 100000
03:53:30 <lambdabot>   Couldn't match expected type `[b]'
03:53:30 <lambdabot>         against inferred type `Data.Mayb...
03:53:58 <dafis> > maybe 0 head $ mapM Just [1 .. 100000]
03:53:59 <lambdabot>   1
03:54:03 <dafis> > maybe 0 head $ mapM Just [1 .. 1000000]
03:54:05 <lambdabot>   *Exception: stack overflow
03:54:09 <mm_freak_> > maybe 0 (!! 100000) mapM Just [1..]
03:54:10 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe [a]'
03:54:10 <lambdabot>         against inferre...
03:54:15 <mm_freak_> > maybe 0 (!! 100000) $ mapM Just [1..]
03:54:17 <lambdabot>   *Exception: stack overflow
03:54:21 <mm_freak_> > maybe 0 (!! 1) $ mapM Just [1..]
03:54:23 <lambdabot>   *Exception: stack overflow
03:54:31 <mm_freak_> right
03:54:42 <mm_freak_> i see what you mean
04:06:11 <lpsmith> Jafet: It looks like I might be able to save ~ 13% on a pessimal input.   That analysis might be flawed though
04:07:48 <lpsmith> http://hpaste.org/51127
04:08:33 <ClaudiusMaximus> is it feasible that a literal [0..] in the middle of an expression in a function gets treated as a CAF and kept around?  otherwise i have no clue where my memory leak is
04:08:49 <lpsmith> that's a slightly better shaped tree, but as I mentioned,  the shape that sort currently uses isn't as bad as I thought
04:09:28 <Jafet> ClaudiusMaximus: CAFs can be garbage collected, sometimes
04:09:44 <Jafet> Perhaps ghc is not doing it on the right granularity
04:10:13 <Jafet> I doubt ghc is eager to promote constants to CAFs, though
04:10:21 <ClaudiusMaximus> maybe i'll try my  [(x+0-x)..] trick and see if it fixes
04:10:33 <Jafet> Heh
04:12:35 <lpsmith> mm_freak_: also my impression why Data.Bits is "slow" isn't so much because it itself is slow, but rather it's limited by problems in GHC's native code generator.  I should investigate assembly dumps from the LLVM and C backends, they might be considerably better.
04:12:37 <dafis> ClaudiusMaximus: That might not help, iirc, there are rules for x+0 and x-x
04:12:52 <tomberek> howdy
04:13:25 <ClaudiusMaximus> dafis: i seem to recall it helping before, but that was with an older ghc (currently on 7.0.4/integer-simple)
04:13:37 <tomberek> is there a safe way to convert an STRef into an Ord instance such as Int?
04:14:07 <tomberek> currently it just has Eq, unable to put it into Set or use IntSet
04:14:12 <lpsmith> hmm, they aren't already?
04:14:14 <lpsmith> I guess not
04:14:15 <dafis> ClaudiusMaximus: the rules might or might not both fire, you'll never know unless you look at the core
04:14:54 <quicksilver> lpsmith: it would cost a word, that's the problem
04:15:03 <quicksilver> they're reluctant to make IORef/STRef more expensive just to get an ord instance
04:15:06 <quicksilver> although it is annoying.
04:15:18 <tomberek> quicksilver, lpsmith: I was thinking of making an STC monad. a ST with a Counter.  I did it with a CounterT transformer, but would like to build it in, such that 'lift's all over the place aren't needed
04:15:30 <lpsmith> Well, it makes sense,  the GC can move STRefs around
04:15:44 <lpsmith> so you won't get consistent results
04:15:54 <quicksilver> tomberek: well, not very many lifts really, there aren't all that many ST functions
04:15:58 <lpsmith> couldn't you pair it with a stable name?
04:16:02 <quicksilver> you can just prelift the ones you care about.
04:16:10 <quicksilver> lpsmith: just pairing it with a counter is enough.
04:16:14 <quicksilver> that's what tomberek is suggesting
04:16:17 <tomberek> quicksilver, exactly, I was thinking of pairing an Int (or word) within the STRef and using that
04:16:22 * quicksilver nods
04:16:47 <tomberek> that way every STRef has a 'stable name'
04:16:53 <ClaudiusMaximus> dafis: well, it seems to be working, ~30MB memory in use instead of 3GB...
04:16:57 <tomberek> without using IO
04:16:59 <lpsmith> err, stable names aren't ord either
04:17:00 <dafis> nice
04:18:09 <tomberek> quicksilver, lpsmith: how much better/worse would this be in clarity or performance compared to the simple CounterT with lifted operations?
04:19:44 <lpsmith> tomberek: I'm not sure what you are asking for
04:20:04 <lpsmith> meaning  STRef s (Counter, ...)  ?
04:20:06 <jpcooper> I'm running a Get parser on a ByteString in ghci with Data.Serialize.Get's runGet. Could anyone explain why it should print Right " and just hang there?
04:20:13 <lpsmith> You couldn't use compare because compare is pure
04:20:19 <lpsmith> but I don't think that's what you mean
04:20:32 <lpsmith> You'd want  (Counter, STRef s ...)
04:20:59 <lpsmith> and actually, by "Counter",  I mean "Int"
04:21:33 <tomberek> lpsmith, so something like newtype STCRef s a = STCRef (Int,STRef s a)   ?  and then all the associated inc, dec, reset, get, newSTCRef etc?
04:22:40 <lpsmith> yeah,  though you probably want   data STCRef s a = STCRef !Int (STRef s a)
04:22:53 <lpsmith> probably want a ! on the STRef too
04:23:00 <Tasser> are there plans for hpaste.org to support a bunch of other hls?
04:23:18 <tomberek> lpsmith, that way I can guarantee that I can do something like STCRef s a -> Int
04:23:43 <lpsmith> tomberek: sure:   const some_int  :-P
04:23:56 <lpsmith> err
04:24:13 <lpsmith> actually I'm wrong.   You can get the Int out
04:24:32 <Jafet> jpcooper: infinite loop somewhere
04:24:50 <lpsmith> and that wasn't a question, that was a statement.  Nevermind :-/
04:25:16 <tomberek> lpsmith: I currently am able to get an explicit -> implicit conversion of a graph and back, but I have to provide the 'index' by hand. I'd like the monad to make it for me, so I figured I'd build it into ST
04:26:10 <tomberek> lpsmith: I didn't like the use of IO in 'Type Safe Observable Sharing' or the Ref extension in Lava
04:26:17 <lpsmith> If you aren't going to introduce your own CounterT monad,  newSTCRef would need to have a different API:  e.g. be passed a STRef to a counter.
04:26:44 <lpsmith> The Counter monad should probably be a Reader with a STRef if you go that count.
04:27:47 <tomberek> lpsmith: yes, i did that for now to see if it's doable, but I think making an STC monad might be cleaner, what do you think?
04:28:44 <Jafet> lpsmith: pretty sure all the bangs in roundUpPow2 are redundant, mind you
04:33:44 <Jafet> You could also look into collecting (length xs) from the runs code
04:34:12 <Jafet> I guess that's not asymptotically significant, though
04:35:00 <tomberek> .
04:52:11 <hpaste> Me pasted “Ambigous type variable” at http://hpaste.org/51130
04:52:21 <behelit> oh, neat
04:52:26 <behelit> i pasted that
04:52:27 <behelit> :)
04:52:51 <behelit> can anyone help me read that?
04:53:11 <jpcooper> Jafet: there's no recursion in the parser
04:53:21 <ivanm> behelit: it's the division
04:53:29 <ivanm> is integral division sufficient?
04:53:35 <behelit> ivanm: but, what is it saying really?
04:53:38 <ivanm> oh, you want to round _up_
04:53:49 <ivanm> behelit: OK, the problem is this:
04:53:53 <ivanm> @type mod
04:53:54 <lambdabot> forall a. (Integral a) => a -> a -> a
04:53:56 <ivanm> @type (/)
04:53:57 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:54:11 <tomberek> it can't fuse them
04:54:14 <ivanm> behelit: so mod requires an Integral value, and / requires a Fractional value
04:54:19 <ivanm> there's no type that's an instance of both
04:54:33 <ivanm> to put it crudely, the former implies no decimals and the latter requires decimals
04:55:44 <behelit> but, "12 / 12" in ghci works?
04:56:13 <Jafet> :t let x = 12; _ = x / x in x
04:56:15 <lambdabot> forall t. (Num t) => t
04:56:19 <behelit> because numbers are Num?
04:56:37 <Jafet> :t (/)
04:56:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:56:38 <ivanm> @type 12 / 12
04:56:39 <lambdabot> forall t. (Fractional t) => t
04:56:47 <ivanm> behelit: it's not an integral!
04:57:01 <ivanm> behelit: in ghci, it will default to a Double value
04:57:03 <ivanm> > 12 / 12
04:57:04 <lambdabot>   1.0
04:57:06 <behelit> I see
04:57:09 <Jafet> Many integrals are fractional.
04:58:01 <Phyx-> i wonder if warsow has improved..
04:58:27 <tomberek> ivanm: hey, i've been throwing more graph ideas around, I can make an updatable doubly linked explicit graph, and i have freeze/thaw operations into both frozen explicit and implicit graphs. The explicit graphs are VERY fast, operations in O(1)
04:59:05 <ivanm> what do you mean by explicit/implicit ?
04:59:17 <ivanm> Jafet: but not Integrals? :p
04:59:36 <behelit> so, what would a "proper" solution be? fromIntegral works, but what would a haskell programmer do? :)
04:59:44 <Jafet> Of course not. No Integrals are Fractional.
04:59:49 <tomberek> explicit =   data Graph a = Node [Graph] a [Graph]   and implicit data Graph a = Graph [ (Int,a,[Int]) ]   --roughtly
04:59:56 * Jafet wonders if that is true
05:00:01 <frerich> behelit: If integral division is ok for you, you could just use div instead of /
05:00:07 <ivanm> behelit: I've seen and used a divUp function before, that should do what you want
05:00:08 <behelit> frerich: ah
05:00:18 <ivanm> (the ceiling $ fromIntegral a / b stuff)
05:00:28 <ivanm> frerich: he's rounding _up_ though
05:00:47 <Jafet> (a + b-1) `div` b
05:00:54 <Jafet> I'm kidding, don't use that.
05:00:59 <ivanm> that's the one
05:01:09 <tomberek> ivanm: the updatable explicit graph lives in ST using STRefs, but can be frozen into a non-monadic explicit or implicit... and thawed back into ST
05:01:16 <ivanm> oh? why not?
05:01:44 <balta2ar> hm, haskell2010 is shadowed by default in ghc 7.0.2. should modern programs use haskell2010 or haskell98? what would you recommend?
05:02:25 <Jafet> ivanm: only works for positive values that aren't near maxBound
05:02:32 <ivanm> huh, numeric prelude has a divUp function
05:02:43 <ivanm> but I'm not sure I get how it works...
05:03:21 <Jafet> tomberek: and the representation of the graph relies on STCRef?
05:03:40 <ivanm> oh, duh, I get it now
05:03:52 <ivanm> n `divUp` m = negate $ (-n) `div` m
05:04:22 <tomberek> Jafet: I couldn't figure out a way to make a zipper of a graph, so I made a doubly linked graph using STRef
05:04:24 <Jafet> minBound `divUp` minBound = (-1)
05:04:41 <hpaste> Me pasted “Ambigous type variable” at http://hpaste.org/51131
05:04:51 <behelit> oops, that was me again :)
05:04:59 <Jafet> No, that was me!
05:05:01 <behelit> so, that works.. is that .. well .. crap? :)
05:05:12 <tomberek> Jafet: so I can do read and traversal without ST or STRef, but to allow modification and addition of nodes, I had to use ST
05:05:23 <insane> I have a function that parses a binary file using lazy bytestrings and returns a result: Get ([Packet]). Inside it composes the partial values like this: return $ packets ++ oldPackets. Another function takes the packets and prints them using putStrLn. How to achieve the effect of laziness in order for packets that are already available to be printed to console?
05:05:30 <behelit> (besides the nonsensical function and variable names)
05:05:33 <Jafet> Ambiguous type variable means you should add a type signature somewhere.
05:06:24 <Jafet> insane: I don't think you can, since Get can decide to fail later
05:06:40 <Jafet> (invalidating what was parsed so far)
05:07:00 <insane> So is it possible to parse files larger than available memory using Get?
05:07:26 <ivanm> depending on the parser, yes
05:08:16 <hpaste> Me pasted “Ambigous type variable” at http://hpaste.org/51133
05:08:24 <behelit> haha, i did it again! :)
05:08:38 <behelit> ok, that's a version that works (again, nonsensical naming)
05:08:54 <daniled> @pl \ns -> filter (\(cat, _, _) -> cat /= "Bad") (Map.elems ns)
05:08:54 <lambdabot> (line 1, column 24):
05:08:55 <lambdabot> unexpected ","
05:08:55 <lambdabot> expecting operator or ")"
05:08:55 <lambdabot> ambiguous use of a non associative operator
05:09:20 <ivanm> Jafet: since my IRC died, did you answer why using divUp like you said was bad?
05:09:31 <daniled> @pl \ns -> filter (\cat -> cat /= "Bad") (Map.elems ns)
05:09:32 <lambdabot> filter ("Bad" /=) . Map.elems
05:10:29 <Jafet> <Jafet> ivanm: only works for positive values that aren't near maxBound
05:10:45 <ivanm> which appears to be this case, does it not?
05:10:56 <Jafet> Yes.
05:11:02 <behelit> ivanm: you'r the first result when googling "haskell divup", just so you know! :)
05:11:08 <behelit> you're*
05:11:28 <ivanm> yeah, I know
05:11:36 <ivanm> but the link doesn't exist anymore :(
05:12:20 <behelit> works on my computer (tm)
05:12:40 <Jafet> Note that your divUp doesn't work for signed minBound.
05:12:53 <ivanm> it's the wrong one though
05:13:09 <ivanm> Jafet: that one was from numeric-prelude
05:13:12 <ivanm> I used one like what you posted
05:13:25 <Jafet> Well, mine is blatantly wrong anyway
05:13:40 <ivanm> behelit: that link on hpaste isn't mine; hpaste died and was resurrected with its DB gone
05:14:05 <behelit> ivanm: http://ircarchive.info/haskell/2007/4/22/28.html that is the first result for me
05:14:40 <ivanm> behelit: yeah, but the link from there to the source I mean
05:14:47 <behelit> ah
05:20:36 <Phyx-> hmm doing cabal install <anything> fails with
05:20:38 <Phyx-> "getCurrentDirectory: does not exist (No such file or directory)"
05:21:14 <Clint> sounds like you're in a nonexistent directory
05:21:47 <Phyx-> oh i was
05:21:59 <Phyx-> but why does that even matter to cabal?
05:22:45 <koeien> cabal wants to install first a .cabal file in the current wd
05:22:53 <koeien> s/install/find
05:22:56 <hpaste> “Mukesh Tiwari” pasted “Not able to install gtk2hs” at http://hpaste.org/51135
05:23:18 <born2code> hello all
05:23:31 <Phyx-> koeien: but that shouldn't be the case when doing cabal install <package> right? so is that a bug?
05:23:34 <Phyx-> born2code: hi
05:23:38 * ivanm waves in born2code's general direction
05:23:51 <ivanm> Phyx-: yeah, sounds like a bug to me
05:24:02 <born2code> i am trying to install gtk2hs but getting gtk2hs-buildtools-0.12.0 failed during the configure step. The exception was: ExitFailure 1
05:24:21 <born2code> could some one tell me how to install gtk2hs
05:24:37 <ivanm> born2code: which OS?
05:24:43 <born2code> ubuntu
05:24:54 <dainanaki> born2code: you need to install alex
05:25:09 <insane> So what how should I write my binary parser (using ByteStrings and Get) in order for results to be printed immediately not when the whole file is parsed?
05:25:31 <scooty-puff> trying to dlopen a haskell .so, getting: /usr/lib/ghc-7.0.2/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc7.0.2.so: undefined symbol: cosh
05:25:34 <scooty-puff> any advice?
05:25:43 <born2code> dainanaki: after installing alex then i should install gtk2hs ?
05:26:24 <ivanm> born2code: gtk2hs-buildtools first
05:26:28 <dainanaki> born2code: cabal install gtk2hs-buildtools, then cabal install gtk2hs
05:26:33 <ivanm> if the build still fails, report the build error
05:27:38 * hackagebot swish 0.6.0.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.0.1 (DouglasBurke)
05:28:07 <born2code> dainanaki: its still failing
05:28:18 <dainanaki> ok, show us the errors.
05:28:25 <Phyx-> in a pastebin!
05:29:08 <hpaste> “Mukesh Tiwari” annotated “Not able to install gtk2hs” with “Not able to install gtk2hs (annotation)” at http://hpaste.org/51135#a51138
05:29:34 <born2code> dainanaki: http://hpaste.org/51135
05:29:43 <born2code> dainanaki: first i installed alex
05:30:03 <luite> http://hpaste.org/51136 <- anyone seen this error? I've installed the ghc 7.2.1 amd64 binaries from the ghc site, non haskell deps installed with macports, OS 10.7.1
05:30:07 <born2code> and then cabal install gtk2hs-buildtools
05:30:44 <dainanaki> It looks to me like you probably don't have /home/ntro/.cabal/bin in your path
05:30:54 <dainanaki> can you run alex from the command line?
05:31:57 <born2code> no i can't run alex form command line
05:32:52 <dainanaki> there's your problem then.
05:33:32 <born2code> i need to add /home/ntro/.cabal/bin to my system path
05:33:36 <dainanaki> yep.
05:33:40 <born2code> dainanaki: thank you
05:33:56 <dainanaki> then start up a new terminal session and retry.
05:34:01 <dainanaki> good luck!
05:37:57 <dafis> luite: XCode version 3.2?
05:38:01 <luite> 4.1
05:39:50 <dafis> luite: the download page says it requires 3.2 (and is for 10.6), which binary did you download?
05:40:02 <luite> oh perhaps I can't read ;p
05:40:48 <luite> ah right, yeah I got the 10.6 install
05:41:01 <luite> this laptop came with 10.7, don't think I can downgrade
05:41:07 <scooty-puff> anyone ever use a haskell .so from c, with c's main, using dlopen?
05:41:49 <hpaste> “Mukesh Tiwari” annotated “Not able to install gtk2hs” with “Not able to install gtk2hs (annotation) (annotation)” at http://hpaste.org/51135#a51139
05:41:59 <luite> I'll try to build one from source, but how can I uninstall the old version? the uninstall instructions on the wiki don't work
05:42:42 <born2code> dainanaki: i am still not able to get it .
05:42:59 <byorgey> born2code: cabal install happy
05:43:20 <dafis> born2code: what's the problem? alex/happy not found?
05:43:51 <born2code> dafis: initailly it was alex and now its happy
05:44:11 <born2code> dafis: both are making me unhappy :)
05:44:44 <dafis> born2code: so, then cabal install happy; cabal install gtk2hs-buildtools; cabl install gtkwhatever
05:45:26 <dainanaki> born2code, if you get any more error messages that tell you something is missing, try installing it first and then let us know after trying that.
05:46:58 <dafis> Are there any Windows users here?
05:47:32 <luite> I have Windows, on another computer
05:48:08 <dafis> luite: have you any idea what could be the problem using double quotes for quoting on windows?
05:48:53 <luite> hmm, for what? command line args?
05:49:15 <dafis> yes, particularly a path containing a space
05:49:24 <Phyx-> dafis: how so?
05:49:44 <luite> dafis: hmm, that usually works fine here :)
05:49:49 <Phyx-> same
05:50:04 <Eduard_Munteanu> Doesn't cmd already use double quotes when autocompleting paths?
05:50:06 <Phyx-> powershell also accepts single quotes
05:50:37 <dafis> Phyx-: dunno, in a test, it was changed from double quotes to single quotes, the reason given was "be careful with quoting on windows", unfortunately, that broke the test for ghci (at least on linux)
05:52:03 <Phyx-> dafis: I'm not aware of any issues with them, it's the default way of quoting paths with spaces
05:52:12 <ivanm> born2code: cabal install happy
05:52:38 <dafis> Phyx-: then why was it changed?
05:52:50 <dafis> (I know, you don't know)
05:53:55 <Phyx-> dafis: perhabs the person who changed it misdiagnosed the reason the test were failing.
05:54:11 <insane> I need to print the partial results parsed by Data.Binary.Get parser but it seems to me that if I call putStrLn . runGet ... it starts printing when the whole file has been parsed. I cannot use putStrLn inside my parser function because it returns IO() not Get(). What would be the correct way to make my parser print immediate results in such case?
05:55:09 <Phyx-> heh, msdn searches stackoverflow now too
05:55:09 <insane> I achieve my goal if I use trace function inside the parser function, but that's not how it should be done correctly
05:55:22 <quicksilver> I don't think you can do that insane, Binary just doesn't work like that.
05:55:45 <quicksilver> but if your Get function returns a list of strings, that list should be generated lazily
05:55:51 <quicksilver> C.f. http://haskell.1045720.n5.nabble.com/Data-Binary-GetT-or-td3106526.html
05:55:54 <Eduard_Munteanu> insane: I think Data.Binary.Get stuff is strict. You might want to use WriterT on top of Get.
05:56:08 <ivanm> Eduard_Munteanu: isn't binary lazy?
05:56:17 <insane> Eduard_Munteanu: Data.Binary.Get isn't strict
05:56:34 <insane> Eduard_Munteanu: at least that's what I've read. The Data.Binary.Strict.Get is I think
05:56:36 <Eduard_Munteanu> Hm, maybe I'm confusing with something else.
05:56:37 <dainanaki> insane: you may want to look at enumerators then as a way of incremental io, but that may be overkill for what you're working on.
05:56:50 <ivanm> Eduard_Munteanu: cereal is strict by default
05:56:56 <Eduard_Munteanu> Ah.
05:58:27 <Jafet> Which extension is needed to make this compile? for :: [a] -> (a->b) -> [b]; for xs f = for' xs where for' :: [a] -> [b]; for' = map f
05:58:38 <Jafet> I thought it's ScopedTypeVariables
05:59:26 <dafis> Jafet: you need an explicit forall then to bring a and b into scope
05:59:43 <dafis> Jafet: but why not simply for = flip map?
06:00:04 <hpaste> “Mukesh Tiwari” annotated “Not able to install gtk2hs” with “Not able to install gtk2hs (annotation) (annotation) (annotation)” at http://hpaste.org/51135#a51140
06:00:12 <ivanm> and the ScopedTypeVariables language extension enabled
06:00:17 <ivanm> oh, you said that
06:00:38 <Jafet> I'm writing a signature to force Int over Integral n => n, and the signature is polymorphic
06:00:55 <born2code> i am still not able to install. Sorry guys for this many questions.
06:01:45 <born2code> cabal install gtk ask for cairo when i am installing cabal install cairo , i am getting error
06:02:17 <dafis> born2code: I remember that, some Cabal version mixup, I think. Unfortunately I don't remember how to resolve. What Cabal version was your cabal built with?
06:02:37 <Jafet> Hm, using Int produces a small speed improvement.
06:02:49 <Jafet> Probably was defaulting to Integer.
06:03:23 <byorgey> born2code: yeah, what is the output of  cabal --version ?
06:03:42 <born2code> cabal-install version 0.10.2 using version 1.10.2.0 of the Cabal library
06:04:00 <byorgey> hmm, that is quite recent, that should work OK
06:04:16 <byorgey> born2code: and what version of ghc?
06:04:40 <born2code> The Glorious Glasgow Haskell Compilation System, version 6.12.3
06:05:35 <ivanm> maybe the version of Cabal is too new?
06:05:51 <Jafet> No, the version of GHC is too old!
06:06:03 <ivanm> born2code: can you please do: ghc-pkg list Cabal
06:06:14 <ivanm> Jafet: yeah, I think it's a version mis-match for Cabal
06:06:44 <byorgey> born2code: how did you install ghc? was it already installed for you?
06:07:12 <dainanaki> I'm thinking he probably did it through apt.
06:07:30 <born2code> apt-get
06:07:45 <dafis> when will people learn not to trust their package managers?
06:07:53 <born2code> var/lib/ghc-6.12.3/package.conf.d    Cabal-1.8.0.6
06:08:03 <born2code> home/ntro/.ghc/i386-linux-6.12.3/package.conf.d    Cabal-1.10.2.0
06:08:13 <byorgey> aha
06:08:18 <born2code> output of  ghc-pkg list Cabal
06:08:28 <byorgey> that does not look promising
06:09:33 <byorgey> born2code: was there a particular reason that you did  cabal install cabal-install  first?  was it not working before?
06:09:46 <Jafet> lpsmith: what are your "pessimal" sort inputs?
06:10:20 <born2code> byorgey: it asked that a new update availabe so i installed it
06:10:22 <lpsmith> Jafet: I haven't made them yet
06:10:51 <Jafet> Where did you figure ~ 13% from?
06:11:20 <dafis> yep, version mismatch
06:11:25 <dafis> #if (__GLASGOW_HASKELL__ >= 700)
06:11:25 <dafis> #define CABAL_VERSION CABAL_VERSION_ENCODE(1,10,0)
06:11:25 <dafis> #else
06:11:25 <dafis> #if (__GLASGOW_HASKELL__ >= 612)
06:11:25 <dafis> #define CABAL_VERSION CABAL_VERSION_ENCODE(1,8,0)
06:11:40 <byorgey> born2code: try this:  cabal install -DCABAL_VERSION_MINOR=10 gtk
06:11:51 <lpsmith> But... runs should return 17 lists,  and the last list should contain the largest element.
06:11:54 <dafis> Setup thinks it has to deal with Cabal-1.8, but it meets 1.10
06:12:11 <byorgey> yes, I just remembered seeing this once before too
06:12:24 <byorgey> I am pretty sure setting -DCABAL_VERSION_MINOR made it work last time I saw it
06:12:31 <dafis> born2code: what byorgey suggested will probably work
06:13:10 <Phyx-> is it just me, or does the cabal-install on hackage not build
06:13:13 <lpsmith> Jafet:  I figured the ~13% from comparing the shape of the tree that sort currently uses to the tweaked shape my foldt uses.
06:13:36 <born2code> byorgey: cabal: unrecognized option `-DCABAL_VERSION_MINOR=10'
06:13:37 <lpsmith> and counting the number of times the elements would have to be copied
06:14:03 <byorgey> Phyx-: it is just you.
06:14:10 <Jafet> lpsmith: ah.
06:14:14 <byorgey> born2code: oh, sorry, just a second
06:14:25 <Phyx-> byorgey: i keep getting
06:14:26 <Phyx-> Distribution/Client/GZipUtils.hs:44:12: Not in scope: data constructor `StreamError'
06:14:29 <Phyx-> etc
06:15:09 <lpsmith> The biggest savings come from lists of length 2^n+1,  and seems to max at 17 and then decrease in terms of percent
06:15:26 <Jafet> A test here with my length-tracking sort gives about 1/3 improvement.
06:15:44 <lpsmith> that's pretty good
06:16:15 <lpsmith> like I said,  my analysis was pretty crude.
06:16:20 <Jafet> I think you can construct more pessimal inputs if you pay attention to the sequence lengths, too.
06:16:22 <dafis> born2code: I think -cpp-otions="-DCABAL_VERSION_MINOR=10"
06:16:37 <byorgey> born2code: ok, sorry, try this:  cabal --ghc-option=-DCABAL_VERSION_MINOR=10 install gtk
06:16:48 <byorgey> not cpp-options I think
06:16:51 <Jafet> Like the quicksort pessimal input, which was defined very particularly and probably took some insight to find
06:17:32 <lpsmith> Jafet: did you combine the length-finding with the runs?
06:18:29 <byorgey> Phyx-: hmm, strange
06:18:29 <Jafet> Nope. I'm still experimenting with whether it's more efficient to use a pair of lists, or a list of pairs, or a list of a special strict pair type.
06:18:41 <lpsmith> heh
06:18:42 <Jafet> Right now, it's just mergeAll (xss, map length xss).
06:18:52 <Phyx-> byorgey: i get that with the 10.x versions. the previous ones build fine
06:19:04 <Phyx-> Cabal inself did build and install
06:19:23 <lpsmith> wait, is mergeAll one of the functions defined in the where clause by "sortBy"?
06:19:45 <Jafet> It's the mergesort function, basically.
06:19:51 <lpsmith> why are you map length xss?
06:19:59 <Jafet> To get the lengths of the runs.
06:20:25 <lpsmith> right,  all I care about in my proposed improvement is knowing the number of runs
06:20:43 <born2code> byorgey: thank you
06:20:45 <ivanm> @ask chrisdone in haskell-emacs, is it possible to get some kind of highlighting for `infix` like haskell-mode has?
06:20:45 <lambdabot> Consider it noted.
06:20:51 <byorgey> born2code: did it work?
06:21:17 <born2code> byorgey: its installing but not finished .
06:21:23 <byorgey> born2code: great!
06:21:31 <born2code> byorgey: :)
06:21:42 <born2code> byorgey: one more thing
06:21:45 <dafis> born2code: you might also need that option for other gtk2hs packages
06:21:58 <lpsmith> I mean, if you have insight into how to use other information to speed up sort,  I'm interested in hearing about it... :)  but are we talking about two different sets of possible improvements here?
06:22:13 <Jafet> lpsmith: rearranging based on the run lengths can be significant. Imagine [al,bl,cl] = length <$> [as,bs,cs], then (as `merge` bs) `merge` cs traverses up to 2*(al+bl)+cl elements; as `merge` (bs `merge` cs) traverses al+2*(bl+cl)
06:22:14 <born2code> byorgey: if i have to install webkit then i have to use the same thing
06:22:14 <byorgey> born2code: what's that?
06:22:34 <lpsmith> Jafet: right
06:22:37 <byorgey> born2code: not necessarily
06:22:47 <Jafet> I'm not sure what's a good way to combine both optimizations.
06:23:04 <byorgey> born2code: you have to use that --ghc-option=... stuff if you see this warning:
06:23:07 <byorgey> warning: #warning Setup.hs is guessing the version of Cabal. If compilation of Setup.hs fails use -DCABAL_VERSION_MINOR=x for Cabal version 1.x.0
06:23:28 <byorgey> notice that warning was in your last paste
06:23:51 <lpsmith> well, your optimizations might well subsume mine
06:24:08 <byorgey> born2code: but for most things you won't need it
06:24:23 <byorgey> gtk is one of the most difficult things to install
06:24:30 <born2code> byorgey: yes
06:24:44 <Jafet> I installed gtk pretty easily--I think (I never tried using it)
06:24:59 <Jafet> Of course, installing packages on a broken world may be more challenging
06:25:00 <lpsmith> Jafet:  that's also a worst-case analysis,  as merge can stop if it reaches the end of one list
06:25:17 <born2code> byorgey: till now its most difficult installation of haskell library
06:25:44 <Jafet> lpsmith: to sell your patch, you need to find every way to make sort look bad!
06:25:51 <Jafet> Hence "up to".
06:26:18 <lpsmith> oh, I missed "up to"... fair enough! =)
06:27:24 <lpsmith> ok,  so your sort is about 1/3 faster in the pessimal case,  but seemingly slower than GHC's current sort in the "average" case?
06:28:19 <Jafet> Yes, a few percent
06:28:29 <lpsmith> I see
06:28:38 <Jafet> My "average" is newStdGen.
06:29:01 <Jafet> Maybe I should read the core, before I try strictifying.
06:30:02 <Jafet> Okay, I can see the core, but I can't read it.
06:30:25 <lpsmith> yeah, it takes effort to read.  I've read some, but I'm hardly good at it either
06:30:37 <lpsmith> it doesn't help that documentation is pretty sparse
06:30:54 <lpsmith> I find it easiest to look for the identifiers you care about
06:31:10 <lpsmith> as in, search for them with your text editor or pager
06:31:17 <tswett> With cabal, can I download a package, modify it, and install the modified version?
06:31:35 <lpsmith> tswett: absolutely
06:31:48 <lpsmith> tswett: cabal unpack is useful for that
06:32:13 <Jafet> cabal unpack, configure, build, register
06:32:40 <luite> tswett: if you modify the cabal file, make sure to update the version number
06:32:41 <lpsmith> shouldn't there be a haddock and copy in there
06:32:53 <tswett> Jafet: fetch before unpack, right?
06:33:22 <Jafet> Er, left?
06:33:32 <Jafet> I've only ever had to reinstall packages.
06:33:35 <hpaste> “Mukesh Tiwari” annotated “Not able to install gtk2hs” with “Not able to install gtk2hs (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/51135#a51142
06:33:40 * tswett shrugs.
06:33:55 <Jafet> Yo dawg, you like annotations
06:34:03 <tswett> I surely need to download the package at *some* point, but maybe attempting to install the package takes care of that.
06:34:29 <byorgey> tswett: cabal unpack  fetches the package for you if it's not already downloaded
06:34:30 <born2code> byorgey: for webkit installation its showing some error
06:34:32 <mm_freak_> what's the current state of the art in haskell XML parsing?  i'm seeing haxml being used a lot
06:34:37 <Jafet> install is the kitchen sink command, until the faucet breaks
06:35:24 <byorgey> tswett: and also, you should only need to do cabal unpack, edit, then just run 'cabal install' in the package's root directory
06:35:37 <byorgey> born2code: what's the error?
06:35:39 * tswett nods.
06:35:57 <dafis> tswett: unpack downloads if necessary
06:35:58 <byorgey> born2code: oh, wait, I see you pasted it, let me look
06:36:07 <tswett> Can I do cabal unpack while cabal update is running?
06:36:34 <byorgey> born2code: ah, any time it complains about a 'pkg-config package' that means there is something you need to install through apt-get first
06:36:53 <byorgey> born2code: try something like apt-get install webkit or maybe apt-get install webkit-dev
06:37:29 <dafis> my money is on -dev
06:37:31 <byorgey> born2code: apparently the haskell webkit package is just some bindings to the external webkit library, so you have to install that external library first
06:39:26 <born2code> byorgey: so first i need to install external library and then install haskell library ?
06:41:03 <Eduard_Munteanu> born2code: yes
06:41:25 <born2code> Eduard_Munteanu: thank you
06:41:26 <Eduard_Munteanu> Not just the library itself, but the headers might be needed too.
06:41:43 <Eduard_Munteanu> (these are usually separate packages in binary distros)
06:42:13 <Ivoz> Hi there, I'm at tryHaskell, wondering how I could use (:) with map?
06:42:24 <benmachine> Ivoz: to achieve what exactly?
06:42:31 <Ivoz> anything!
06:42:34 <benmachine> ...
06:42:35 <Ivoz> I tried map ((:) 'a') [[1],­[2],[3]]
06:42:45 <benmachine> what does -[2] mean?
06:42:48 <Ivoz> I don't have an aim atm, I'm just going through the tut
06:42:59 <Schalken> How do I call isAlphaNum on a Word8?
06:43:14 <Ivoz> [2] is a list containing 2, not sure about -
06:43:16 <benmachine> Schalken: you don't; Word8s are not characters
06:43:44 <benmachine> Ivoz: - used like that is prefix negation
06:43:53 <benmachine> it works on numbers, not lists
06:44:01 <byorgey> Ivoz: the problem is that you cannot construct a list containing a character and a number
06:44:09 <byorgey> Ivoz: lists must contain all elements of the same type.
06:44:18 <byorgey> however, this works:
06:44:20 <Ivoz> ahhh
06:44:31 <byorgey> > map ((:) 6) [[1],[2],[3]]
06:44:32 <lambdabot>   [[6,1],[6,2],[6,3]]
06:44:34 <tswett> benmachine: well, can you convert a Word8 into a Char and then call isAlphaNum on it?
06:44:47 <Schalken> benmachine: …maybe I should be using Data.Text, then...
06:44:51 <byorgey> Ivoz: so you had the right idea =)
06:44:51 <hpc> > map (6 :) [[1],[2],[3]]
06:44:52 <benmachine> tswett: in principle yes
06:44:52 <lambdabot>   [[6,1],[6,2],[6,3]]
06:44:54 <Ivoz> kewl
06:45:00 <benmachine> Schalken: tell us a little about your background
06:45:01 <Ivoz> thanks byorgey
06:45:05 <byorgey> sure
06:45:13 <benmachine> if you're using ByteString to get that Word8 from, then there are a few ways you can get a Char instead
06:45:28 <byorgey> Ivoz: and as hpc points out, ((:) 6) can also be written (6 :)
06:45:28 <Schalken> benmachine: As in where I grew up? :P
06:45:47 <benmachine> Schalken: haha, if you like :P but I meant, why are you trying to do this thing
06:45:58 <benmachine> in particular am I right in guessing that you're working with ByteStrings
06:46:13 <Ivoz> can you join tuples together, like with lists?
06:46:24 <Ivoz> oh you can't.
06:46:26 <Ivoz> that's sad
06:46:51 <benmachine> well, you can write a function like joinTuples :: (a,b) -> (c,d) -> (a,b,c,d)
06:46:57 <Schalken> benmachine: I'm parsing an XML document from a file and basically need to work with it's contents as Data.Text (as it seems). It's natural language processing.
06:47:21 <dafis> Schalken: in that case, use Data.Text
06:47:23 <benmachine> Schalken: so where do the Word8s come in? or are you just saying you'll use Text instead (which sounds sensible, I suppose)
06:47:55 <benmachine> Ivoz: if you can come up with a good type for the tuple-joining function you can probably write it
06:48:01 <Schalken> benmachine: Well first I need to know if I can get Data.Text through the XML parser (Text.XML.Light) which I am yet to investigate. :P
06:48:07 <Ivoz> is there a 'third' function or just fst and snd?
06:48:18 <benmachine> @hoogle (a,b,c) -> c
06:48:19 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
06:48:19 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
06:48:22 <benmachine> hm
06:48:35 <engla> there is no third function, also fst or snd don't work with triples
06:48:44 <benmachine> engla seems to be correct
06:48:50 <tswett> The problem with Haskell is that a function always has to return the same type regardless of the input value.  You can't say 'f True = "cats"; f False = 50'.
06:48:52 <benmachine> I thought there was a fst3 around somewhere but I can't find it anymore
06:49:03 <benmachine> one usually deals with larger tuples by pattern-matching
06:49:05 <tswett> But luckily, we have things like Maybe and Either to make things a bit easier.
06:49:16 <dafis> tswett: sure, all you need is instance Num [Char]
06:49:22 <benmachine> dafis: shh :P
06:53:23 <Eduard_Munteanu> Or you can use nested tuples, e.g. (a, (b, c)), snd . snd gives c, but that's not much of an improvement
06:53:30 <Eduard_Munteanu> s/tuples/pairs/
06:54:41 <Ivoz> snd (1, (2, 3))
06:54:56 <Ivoz> > snd (1, (2, 3))
06:54:58 <lambdabot>   (2,3)
06:55:13 <Ivoz> > snd snd (1, (2, 3))
06:55:15 <lambdabot>   Couldn't match expected type `(a, b)'
06:55:15 <lambdabot>         against inferred type `(a1, b...
06:55:27 <Ivoz> > snd (snd (1, (2, 3)))
06:55:28 <lambdabot>   3
06:55:31 <int-e> Eduard_Munteanu: everybody loves cddr :P
06:55:35 <companion_cube> > snd . snd $ (1, (2, 3))
06:55:37 <lambdabot>   3
06:55:51 <Ivoz> I think I need to learn . and $ first :S
06:56:02 <hpc> Ivoz: ($) is function application
06:56:04 <int-e> @src ($)
06:56:04 <Ivoz> and ,
06:56:04 <lambdabot> f $ x = f x
06:56:05 <hpc> f $ x = f x
06:56:07 <Eduard_Munteanu> > (snd . snd) (1, (2, 3))
06:56:09 <lambdabot>   3
06:56:14 <hpc> (f . g) x = f (g x)
06:56:17 <Eduard_Munteanu> int-e: cddr?
06:56:22 <Jafet> > let f x = x . x $ (1, (2, 3)) in f snd
06:56:23 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t1, t)
06:56:52 <hpc> Jafet: needs some foralls
06:57:01 <int-e> Eduard_Munteanu: In lisp, cddr = cdr . cdr, and cdr is pretty much equivalent to snd.
06:57:14 <Eduard_Munteanu> Oh.
06:57:21 <Ivoz> > cdr
06:57:22 <hpc> int-e: they work more like head and tail on hetero-lists
06:57:22 <lambdabot>   Not in scope: `cdr'
06:57:30 <Eduard_Munteanu> Actually, Agda's tuples are like that.
06:57:45 * Jafet has existentialist type
06:57:49 * Eduard_Munteanu doesn't know Lisp
06:57:56 * quicksilver has nihilistic type
06:57:58 <tswett> Coq seems to be better than Agda in... at least one way.
06:58:05 <Ivoz> why do you need $ when you can just write f x
06:58:19 <hpc> Ivoz: it has a very low precedence
06:58:32 <int-e> hpc: but conses are completely untyped. the list thing is a convention.
06:58:35 <Jafet> You get paid more if you know how to use ($).
06:58:44 <hpc> snd . snd (1,(2,3)) = snd . (snd (1, (2, 3)))
06:58:47 <Eduard_Munteanu> > map ($ 5) [(+1), (*2), (+3)]
06:58:48 <lambdabot>   [6,10,8]
06:58:55 <hpc> also for that trick
06:59:07 <tswett> Ivoz: $ is never necessary, but "x . x $ y" may look better than "(x . x) y".
06:59:10 <int-e> snd . snd (1,(2,3)) = snd (snd (1, (2, 3)))
06:59:13 <hpc> Ivoz: it's used in continuation passing style a lot
06:59:23 <int-e> (correcting a typo)
06:59:26 <hpc> cps-transform x = ($ x)
06:59:31 <Eduard_Munteanu> tswett: in what way?
06:59:37 <Eduard_Munteanu> Erm, Coq vs Agda.
06:59:38 <Ivoz> I think I'll go back to tryhaskell for a bit
06:59:42 <Eduard_Munteanu> I don't know much Coq.
06:59:54 <Eduard_Munteanu> @where platform
06:59:55 <lambdabot> http://hackage.haskell.org/platform/
07:00:00 <bscarlet> Ivoz: the low precedence lets you skip annoying parentheses: f (g a b c d) can be written f $ g a b c d, which can help you avoid close parentheses building up at the end of the expression
07:00:14 <Eduard_Munteanu> Ivoz: you might want to get the Haskell Platform and install it ^
07:00:52 <tswett> Eduard_Munteanu: well, I guess there are two ways I know of.  Coq contains a neat little interactive theorem prover that can be easier to use than writing out proofs as functions; and I hear that Coq is based on a specific theory, whereas Agda is just sort of ad-hoc.
07:01:15 <Ivoz> If "abc" is just syntactic sugar for 'a':'b':'c':[], why won't let ("abc") = "xyz" in a work?
07:01:18 <Eduard_Munteanu> Agda isn't really ad-hoc it's just a bit more experimental.
07:01:34 <hpc> Ivoz: 'a' is a literal
07:01:40 <hpc> > let 1 = 2 in 1
07:01:41 <lambdabot>   1
07:01:42 <Eduard_Munteanu> Besides it has an automated prover as well, and tactics are on the way (via reflection) IIUC.
07:01:43 <byorgey> Ivoz: should let 'a' = 'b' work?
07:01:59 <simon> if my datatype should be an Enum and my datatype is finite, should I throw an exception at the last element or wrap around or what?
07:02:00 <hpc> > let 'a' = 'z' in 'a'
07:02:01 <lambdabot>   'a'
07:02:05 <hpc> > let 'a' = 'z' in 'z'
07:02:06 <lambdabot>   'z'
07:02:12 <byorgey> Ivoz: you can do  let [a,b,c] = "xyz" in a
07:02:25 <Eduard_Munteanu> One of the more visible differences is cumulative universes, or the lack of in Agda.
07:02:45 <Jafet> > let !'a' = 'z' in 'a'
07:02:46 <lambdabot>   *Exception: <interactive>:3:4-13: Non-exhaustive patterns in pattern binding
07:02:50 <benmachine> > let "abc" = "xyz" in ()
07:02:50 <ivanm> Ivoz: because you can't assign one character to equal another
07:02:51 <lambdabot>   ()
07:02:56 <benmachine> ...I thought so
07:03:00 <mux> I thought you couldn't use [] syntax in pattern matches
07:03:06 <benmachine> you can
07:03:06 <byorgey> sure you can
07:03:10 <benmachine> you can also use string syntax
07:03:13 <byorgey> > let [a,b,c] = "xyz" in a
07:03:15 <lambdabot>   'x'
07:03:17 <benmachine> so it *does* work
07:03:17 <dafis> simon: depends, if it's Bounded, you should throw, if it's not, you may wrap
07:03:17 <Eduard_Munteanu> At times, Agda is broken though.
07:03:22 <ivanm> you can do:
07:03:26 <benmachine> depending on what you wanted it to do
07:03:30 <Jafet> In the good old days of fortran, you could change the value of 0, etc
07:03:44 <Jafet> Because the value of 0 was kept in a register sometimes
07:03:46 <ivanm> > let (a:b:c:[]) = "xyz" in b
07:03:47 <lambdabot>   'y'
07:03:50 <byorgey> > let "abc" = "xyz" in a  -- this does not work no matter what you intend
07:03:50 <hpc> mux: [x,y,z] desugars to (x:y:z:[]), which is a valid pattern
07:03:54 <lambdabot>   mueval-core: Time limit exceeded
07:04:01 <benmachine> simon: the standard types throw exceptions, but I'd check the doc to see if that's mandatory
07:04:08 <benmachine> > succ maxBound :: Int
07:04:08 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
07:04:25 <tswett> Eduard_Munteanu: now, I'm not quite sure how universes work in Coq and Agda.  If I remember correctly, Coq has a hierarchy Type1 : Type2 : Type3 : Type4 : . . ., but the hierarchy is made invisible by calling all of those types Type.  Does Agda do it more explicitly or something?
07:04:44 <benmachine> byorgey: because a is not in scope?
07:04:59 <benmachine> wait a sec
07:05:00 <benmachine> > a
07:05:01 <lambdabot>   a
07:05:12 <Ivoz> do you really need the brackets in "let (a:_) = "xyz" in a"? Is there a reason for having them?
07:05:19 <byorgey> benmachine: right, although lambdabot does have a in scope, I forgot about that
07:05:20 <dafis> benmachine: if you're not Ord/Bounded, wrap is fine, succ Saturday = Sunday
07:05:20 <benmachine> Ivoz: you don't need them
07:05:36 <byorgey> > let a:_ = "xyz" in a
07:05:36 <koeien> Ivoz: stylistic reasons
07:05:37 <lambdabot>   'x'
07:05:37 <Eduard_Munteanu> tswett: in Coq, you have Set k <: Set k + 1, while in Agda it's Set k : Set k + 1, IIUC
07:06:00 <Ivoz> koeien: why is that a good style?
07:06:03 <byorgey> Ivoz: if you have several patterns you need the parens, like for example  f (a:_) (b:_) = ...
07:06:07 <hpc> Ivoz: you need the parens in function definitions, for parsing reasons
07:06:08 <tswett> Eduard_Munteanu: what does <: mean, again?
07:06:14 <benmachine> "For any type that is an instance of class Bounded as well as Enum, the following should hold:
07:06:15 <hpc> Ivoz: so people just do the same in let
07:06:17 <benmachine> The calls succ maxBound and pred minBound should result in a runtime error. "
07:06:27 <benmachine> simon: http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/Prelude.html#t:Enum
07:06:30 <Eduard_Munteanu> tswett: subtyping. Basically, higher universes actually contain lower ones.
07:06:48 <koeien> Ivoz: I can't really say. to me it looks nicer. but it's completey arbitrary
07:07:18 <tswett> Eduard_Munteanu: ah.  So in Coq, it is not true that every value has exactly one type.
07:07:29 <tswett> Eduard_Munteanu: anyway, does k have to be a natural number in both systems?
07:07:45 <Eduard_Munteanu> tswett: in Agda, Bool is in Set, but not in Set 1
07:08:04 <Ivoz> ah i see
07:08:15 <Eduard_Munteanu> tswett: yeah, I think it has to be natural.
07:08:30 <Eduard_Munteanu> Although I've seen something about Set \inf, if I'm not confusing things, I'm not sure.
07:08:40 <Ivoz> > @
07:08:41 <lambdabot>   <no location info>: parse error on input `@'
07:08:52 <Ivoz> > @src (@)
07:08:53 <lambdabot>   <no location info>: parse error on input `@'
07:09:17 <Ivoz> @src (@)
07:09:18 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:09:27 <Ivoz> @src @
07:09:27 <lambdabot> Source not found. Do you think like you type?
07:09:27 <Eduard_Munteanu> tswett: I think there is a smallest type that contains a given value in Coq, though :/
07:09:28 <byorgey> Ivoz: @ is special syntax, not a function
07:09:34 <Eduard_Munteanu> Again, I'm not really sure about Coq.
07:09:41 <Ivoz> gar
07:09:46 <tswett> Eduard_Munteanu: makes sense.
07:09:51 <byorgey> Ivoz: the pattern  x@(blah)  both matches against the pattern blah, AND gives the name x to the whole thing
07:09:53 <tswett> Now, is either Set or Prop a subtype of Type?
07:10:11 <Ivoz> is that the only place @ is used?
07:10:13 <Eduard_Munteanu> Dunno, Agda uses only Set.
07:10:15 <koeien> Ivoz: e.g. f xs@(hd:tl) bind hd to the head of the list, tl to the tail, and xs to the full list
07:10:20 <byorgey> > let x@(a:b:_) = [1,2,3,4] in a : b : x
07:10:22 <lambdabot>   [1,2,1,2,3,4]
07:10:26 <Eduard_Munteanu> It doesn't make the Set <-> Prop distinction
07:10:30 <byorgey> Ivoz: yes
07:10:43 <tswett> Eduard_Munteanu: in Coq, I meant.
07:10:46 <Ivoz> its rather special then
07:10:53 <tswett> Er, right, you said "dunno" to that one.
07:11:04 <koeien> Ivoz: yes, it's some sugar. you don't really *need* to use it
07:11:17 <Eduard_Munteanu> Yeah, it's just some stuff I picked about Coq, I haven't actually used it much at all.
07:11:36 <byorgey> tswett: Set and Prop are both subtypes of Type.
07:11:56 <Eduard_Munteanu> Funny thing is, Ulf's original paper on Agda speaks about Set k <: Set k + 1 but that never happened AFAIK
07:11:57 <Ivoz> ok thankyou for the help everyone
07:12:01 <Ivoz> you're very nice
07:12:01 <byorgey> Ivoz: yes, it is
07:12:06 <Ivoz> hopefully I come back soon
07:12:11 <byorgey> Ivoz: you're welcome, come back anytime =)
07:12:13 <koeien> Ivoz: don't hesitate :)
07:12:28 <tswett> byorgey: neat.  And are there any other subtypings like that?  Could I make Rational a subtype of Real, say?
07:13:07 <byorgey> tswett: no.  technically it's not actually subtyping, it's sub*kind*ing
07:13:25 <Eduard_Munteanu> I'm not sure either of these allow you to declare datatypes in anything but Set.
07:13:31 <tswett> Huh.
07:13:34 <Eduard_Munteanu> erm, anything but Set k
07:13:47 <byorgey> tswett: although Coq does have some nice mechanisms for type class sub/superclassing and  subrecords
07:14:02 <byorgey> but it's not quite the same thing as subtyping.
07:14:11 <tswett> Eduard_Munteanu: gee, that would be fun.  Declare a new type whose kind is Natural...
07:14:47 <byorgey> tswett: yes, we will get that in Haskell soon =)
07:15:00 <byorgey> Coq and Agda both allow you to declare datatypes at any level.
07:15:01 <tswett> When do we get dependent types in Haskell?  :P
07:15:24 <Eduard_Munteanu> Yep, but not as members of arbitrary kinds, just Set k.
07:15:27 <byorgey> never.  However, we already have dependent-type-like-programming
07:15:33 <quicksilver> tswett: http://hackage.haskell.org/trac/ghc/wiki/KindSystem
07:15:46 <Eduard_Munteanu> e.g. data Foo : Bool ... isn't valid
07:15:58 <quicksilver> it is a small, conservative step towards a system with some limited form.
07:16:28 <insane> why print 100 `seq` [0..3] doesnt print 100 at the beginning before returning the list?
07:16:39 <Eduard_Munteanu> You also can't pattern-match on universes, probably because they're open in a sense, so I guess if you could do that, matching on normal types would be broken as well.
07:17:18 <tswett> insane: "print 100" is an action.  Merely evaluating an action, which is what seq does, is not enough to run it.
07:17:26 <Eidel> What is the keyword Some used for?
07:17:43 <koeien> insane: execution is not evaluation
07:17:55 <Eduard_Munteanu> Eidel: where did you see that? I don't think it's a keyword.
07:17:58 <hpc> insane: a nice (but flawed) metaphor is that evaluation is like compiling an action
07:18:06 <hpc> and execution is running it
07:18:22 <Eidel> Eduard_Munteanu: in eclipse..
07:18:22 <byorgey> quicksilver, tswett: that page is quite old but most of the current work is along similar lines
07:18:25 <insane> is there a way to execute it as well?
07:18:32 <koeien> insane: you can only execute an IO action by sticking it in the "main" function
07:18:35 <hpc> :t unsafePerformIO -- insane
07:18:36 <lambdabot> Not in scope: `unsafePerformIO'
07:18:39 <byorgey> quicksilver, tswett: see http://hackage.haskell.org/trac/ghc/wiki/GhcKinds for current work
07:18:40 <tswett> insane: and remember, if you get forty different explanations of the same thing, you only have to understand one of the explanations before you've understood the thing.  :)
07:18:47 <Eduard_Munteanu> Eidel: it looks like a constructor :/
07:18:51 <koeien> insane: for debugging purposes, you can use unsafePerformIO. for other usages i can't really recommend it
07:18:54 <hpc> unsafePerformIO is NOT a good idea unless you just want to print it for debugging
07:19:14 <Eidel> Eduard_Munteanu: Ah! Because of the capital S :)
07:19:14 <Eduard_Munteanu> Not even then, just use Debug.Trace
07:19:23 <insane> hmm, I'd like to actually print it not just for debugging purposes
07:19:27 <Eduard_Munteanu> @hoogle trace
07:19:28 <lambdabot> Debug.Trace trace :: String -> a -> a
07:19:28 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
07:19:28 <lambdabot> module Debug.Trace
07:19:34 <quicksilver> byorgey: yeah, SPJ wrote something more recently which was, in my memory, quite similar.
07:19:37 <quicksilver> but I don't know where
07:19:44 <Eduard_Munteanu> That takes care of specifying non-inlining pragmas.
07:20:12 <Peaker> insane: There's the filelocation and traceutils packages for convenience Trace wrappers
07:21:05 <Eduard_Munteanu> @hoogle some
07:21:05 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
07:21:06 <lambdabot> Control.Exception data SomeException
07:21:06 <lambdabot> Control.Exception SomeException :: e -> SomeException
07:21:18 <Schalken> benmachine: Data.Text was successful. Although it is annoying that although Text.XML.Light accepts Data.Text as a source to parse XML from, the XML structure it returns always contains Strings that I have to repack with Data.Text.pack. :( Ahwell.
07:21:37 <quicksilver> byorgey: oh, yes, on the link you pasted :)
07:22:00 <Eduard_Munteanu> I think there's Idris if you want Haskell + dependent types
07:22:06 * dafis is going to install dev tools on windows, *shudder*
07:22:09 <Eduard_Munteanu> Without totality and other stuff.
07:22:24 <Peaker> String ought to die... [Char] would still be (rarely) useful, but a synonym like that would encourage that awful type's use.. But Haskell really ought to get polymorphic replacements for its monomorphic list functions, text functions, bs functions, etc
07:22:25 <dafis> is that as painful as it sounds?
07:22:31 <bscarlet> insane: do { print 100; return [0..3] }
07:22:54 <Eduard_Munteanu> But I haven't tried it. I wouldn't be surprised if Agda was in fact better, at least it's got Haskell and C FFI and you can disable the termination checker.
07:23:36 <Peaker> insane: the type must not lie about what it does, so if the type is: [Int] the type is explicitly saying it will not print stuff.. You want the type to be IO [Int].   This is a trade-off, of course.. For the types not to lie, we have to work harder when changing the meaning of code (to update the types), but we get benefits from not lying, too
07:24:06 <Schalken> Peaker: I think the fact that we can't just flick a switch and make everything that works with a String now work with a Text is indicative of a much larger problem.
07:24:26 <insane> So now my problem is that my function lazily builds a list of parsed packets and returns the Get ([IO ()]). What I'd like to do is to print the packets as they are parsed from the file, not when the parsing is done.
07:24:51 <Peaker> Schalken: I agree, the standard library is way too monomorphic.. and it's weird, because Haskell has some of the strongest polymorphism mechanisms in the PL world, and some of the most monomorphic standard libraries
07:25:05 <Eduard_Munteanu> Yeah, I think Prelude is at fault here.
07:25:06 <benmachine> polymorphism is overrated
07:25:20 <Eduard_Munteanu> Fusion is pretty bad too.
07:25:23 <Peaker> insane: what you want, then, is basically a Get monad transformer, rather than a Get monad
07:25:27 <Peaker> benmachine: why?
07:25:29 <benmachine> monomorphic types make life easier for the type checker, and typically provide better information
07:25:48 <Peaker> benmachine: Sure, polymorphism has disadvantages, but I think the advantages (e.g: swapping out Text for String seamlessly) far outweigh those
07:25:52 <Eduard_Munteanu> Just use typeclasses and SPECIALIZE?
07:25:59 <benmachine> I don't think they *far* outweight those
07:26:15 <benmachine> I mean you could equally well make that transition seamless by changing imports
07:26:20 <benmachine> and keep the benefits of monomorphism
07:26:21 <Peaker> benmachine: Good error messages are not that important, and you can use more type annotations when you need them
07:26:25 <dainanaki> We really just need a training wheels Prelude that's monomorphic and a more generalised Prelude that's polymorphic.
07:26:30 <dainanaki> methinks.
07:26:32 <Eduard_Munteanu> (assuming you find a good model that makes it clear when things fuse etc.)
07:26:43 <Schalken> Peaker: I think the real problem is that the interface of pattern matching can't be reimplemented. As soon as you define something in terms of a data type, like [Char], rather than a type class, you're stuck.
07:26:47 <benmachine> Peaker: but I don't *want* to use type annotations, they're just a more verbose of doing what I wanted to do in the first place
07:26:54 <benmachine> I can just as well say "you can use conversion functions"
07:27:00 <Peaker> benmachine: not really -- because you'd have to swtich the imports of *everything*, and you get a cartesian multiplication of modules (Lazy vs Strict Text vs String, Lazy vs Strict BS, etc)
07:27:16 <tac-tics> "Let me type you a question: (r -> r) -> r?"
07:27:19 <Peaker> benmachine: conversion functions are expensive
07:27:26 <Peaker> (runtime)
07:27:36 <Eduard_Munteanu> tac-tics: ask djinn
07:27:37 <benmachine> Peaker: I'm not convinced that switching imports is hard
07:27:38 <quicksilver> Peaker: so are typeclasses
07:27:43 <Eduard_Munteanu> @djinn (r -> r) -> r
07:27:44 <lambdabot> -- f cannot be realized.
07:27:51 <tac-tics> hey, lambdabot's back!
07:27:51 <benmachine> or harder than using polymorphic functions
07:27:52 <quicksilver> conversion functions and typeclasses are essentially identical solutions
07:27:52 <Peaker> Schalken: I disagree -- pattern matches are a fine way to define monomorphic functions, and the indirection layer is above those, and I think that is OK
07:28:11 <quicksilver> the typeclass just gets the typechecker to insert the conversion function automatically
07:28:14 <Peaker> quicksilver: type-classes can be specialized/compiled to nothing in the common case.. Text<->String conversions cannot
07:28:37 <hpaste> scooty-puff pasted “main.c” at http://hpaste.org/51144
07:28:42 <Peaker> quicksilver: A function that's polymorphic to any ByteString instance will not convert the BS back and forth..
07:28:57 <Eduard_Munteanu> quicksilver: hm? if you used typeclasses it's reasonable to assume you don't need to do any conversion.
07:28:57 <hpaste> scooty-puff pasted “Foo.hs” at http://hpaste.org/51145
07:29:16 <scooty-puff> can anyone compile the pasted main.c and Foo.hs and have it work when you run ./main?
07:29:19 <scooty-puff> it does not work for me
07:29:25 <scooty-puff> but not sure if i'm just not doing it right
07:29:29 <Peaker> benmachine: How do you switch the imports of Data.Binary.Get so it works with the right kind of byte strings?
07:29:34 <scooty-puff> the comments at the top of each list how i am compiling them
07:29:46 <benmachine> Peaker: I don't know because I don't use binary?
07:29:51 <Peaker> benmachine: do you propose manually duplicating all code for each monomorphic case?
07:29:53 <quicksilver> scooty-puff: AFAIK you're not doing it right.
07:30:01 <Schalken> Peaker: But then something I write over [a] doesn't automatically work with "ListLike a", when it certainly should. It should work with anything that supports the list interface, but it can't because Haskell doesn't recognise a data type as an "interface".
07:30:03 <quicksilver> scooty-puff: if you're going to call haskell from C you have to set up the haskell runtime.
07:30:07 <hpaste> scooty-puff annotated “Foo.hs” with “Foo.hs (annotation)” at http://hpaste.org/51145#a51146
07:30:08 <benmachine> Peaker: no, I propose having a name for every distinct implementation
07:30:18 <scooty-puff> quicksilver: ok
07:30:21 <Peaker> Schalken: Then pattern-matching is too low-level for your purpose.. You can use a higher-level API to work with the input
07:30:23 <quicksilver> Eduard_Munteanu: well, it was a slightly less precise argument than that.
07:30:40 <benmachine> so if the underlying functions are genuinely different, then they have different names (or different modules, if that pleases you)
07:30:50 <quicksilver> Eduard_Munteanu: my point is that typeclasses insert extra work to be done at each polymorphism point; SPECIALISE can remove that work
07:30:51 <Peaker> benmachine: But implementations that are defined in terms of lower level operations could really not care about whether it's a strict or lazy BS, but you'd have to duplicate them, once to import this, and once to import that
07:30:56 <Eduard_Munteanu> Ah.
07:31:00 <quicksilver> Eduard_Munteanu: but then again, conversion functions can be removed by RULES
07:31:04 <scooty-puff> quicksilver: right now its failing at the dlopen call - i know i need hs_init, etc., and will add it - but right now its complaning about hsghc-prim having undefined symbol cosh
07:31:07 <benmachine> Peaker: hmm, now I see what you mean
07:31:18 <dainanaki> We're basically just dancing around the idea of ML-style modules here...
07:31:37 <Peaker> dainanaki: that's one solution, but type-classes exist today, and also solve the problem
07:31:43 <scooty-puff> quicksilver: tried the init step here: http://www.well-typed.com/blog/30 but it still fails
07:31:53 <quicksilver> scooty-puff: it's easier if you compile the C with ghc.
07:31:53 <benmachine> Peaker: okay, I'll accept that that's a legitimate use of polymorphism; but for example I don't necessarily buy the idea that map = fmap is obviously a good idea
07:32:03 <quicksilver> scooty-puff: if you want to compile the C with gcc you have to know which runtime libs to link.
07:32:12 <scooty-puff> quicksilver: this is a plugin to an existing c application - is this possible?
07:32:17 <benmachine> it's nice to have monomorphic versions of functions, because they make type errors more likely
07:32:33 <quicksilver> scooty-puff: yes, it's possible, you jsut have to manually do the stuff which ghc does automatically
07:32:38 * hackagebot cabal-macosx 0.1.2 - Cabal support for creating Mac OSX application bundles.  http://hackage.haskell.org/package/cabal-macosx-0.1.2 (AndyGimblett)
07:32:49 <quicksilver> which is, basically, linking in the RTS and some haskell pacakges
07:32:55 <quicksilver> I don't know how to do that by hand I'm afraid
07:32:59 <Peaker> benmachine: I think it's a case of throwing the baby with the bathwater
07:33:00 <scooty-puff> quicksilver: it will eventually be a plugin for gtags, which expects a function void parser(const struct parser_param *param);, how do i do that linking?
07:33:03 <scooty-puff> quicksilver: k
07:33:06 <quicksilver> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
07:33:11 <Peaker> benmachine: there are better solutions (though perhaps more radical) to the error message problem
07:33:28 <Schalken> Peaker: The problem is I then have to be aware that I'm going to need that beforehand. When I write by function over [a], I need to think "Hmm, what if I want this to work with other things that a listy?" and chose "ListLike a" instead. The fact that I even need to think about that is a problem, because whoever wrote the Prelude obviously didn't.
07:33:31 <Peaker> benmachine: for example, a good IDE could do type-inference as you go, and thus specialize fmap to map very early
07:33:51 <scooty-puff> quicksilver: tried -lHSrts - before it failed on missing stg_<...>, after that is linked, it fails on the cosh undefined symbol i mentioned - tried linking HSghc-prim - maybe not doing it quite right..
07:33:59 <benmachine> Peaker: a good IDE could also replace all the functions you used with the concrete type you wanted :P
07:34:05 <benmachine> probably much more easily actually
07:34:15 <benmachine> (I mean in the no-typeclass model)
07:34:33 <Peaker> Schalken: that's more of a cultural issue -- maybe we need to de-emphasize list pattern-match use.. Though a function [a] -> ... often just expresses the concept of a pure consumer/iteratee.. and can be lifted into more polymorphic form
07:34:38 <dainanaki> The other issue is that there a lot of things that are *almost* list-like, but don't quite support all of the functionality that a list does.
07:34:48 <benmachine> dainanaki: exactly
07:35:01 <dainanaki> So having type classes be fine-grained enough ends up getting really verbose
07:35:02 <benmachine> so there's ListLike and StringLike and FiniteListLike and MaybeInfiniteSortaThing
07:35:10 <Peaker> benmachine: but they don't necessarily have to exist, because making them exist means duplicating code (which is like manually doing a C++'s template compiler work.. :)
07:35:11 <quicksilver> dainanaki: or support it with radically different complexities and expected use patterns.
07:35:43 <quicksilver> an advantage of concrete data structures is that it's easier for programmers to use them correctly.
07:35:44 <Peaker> I don't think a class like ListLike makes much sense -- Traversable and nice small meaningful classes are probably a better route -- if they can cover the needed structure
07:35:55 <benmachine> Peaker: I'm starting to think that we're thinking of different examples here and hence arguing about different things
07:36:09 <Peaker> If you have a class that has all instances be isomorphic to some type, there's little point in not using the concrete type
07:36:17 <benmachine> ah
07:36:21 <benmachine> *definitely* with you there :)
07:36:27 <quicksilver> Peaker: actually something slightly more general than that is true.
07:36:31 <dainanaki> I think we can agree that there always exists room for improvement, but there is no silver bullet for all solutions.
07:36:34 <dainanaki> :)
07:36:49 <benmachine> dainanaki: I think the benefits of monomorphism are frequently understated
07:36:53 <quicksilver> Peaker: it's actually if you have a class with a unique initial object through which all uses factor, then there is no point not using that initial object.
07:37:10 <Peaker> benmachine: I think the problem of error messages is an accidental problem of the way we use non-interactive text to encode programs
07:37:16 <Peaker> accidental artifact, that is
07:37:24 <Peaker> benmachine: so I don't really like the argument-from-error-messages
07:37:37 <Peaker> quicksilver: what is an "initial object"?
07:37:51 <benmachine> Peaker: but it's not just error messages; too much polymorphism makes things that shouldn't type-check, type-check
07:37:55 <quicksilver> in this context, it's a most general concrete data structure.
07:37:59 <benmachine> Peaker: so here is my favourite example that I keep using
07:38:12 <benmachine> :t forever putStrLn "hello" -- I have actually encountered this bug in actual code
07:38:13 <lambdabot> forall b. b
07:38:21 <benmachine> drove me up the wall
07:38:22 <Peaker> benmachine: too much polymorphism in the stuff you use, that's true.. too much polymorphism in the stuff you export -- the opposite is true
07:38:24 <quicksilver> so, 'Maybe a' is the most general case for a Monad which supports "fail"
07:38:38 <Peaker> benmachine: when you're forced to define a more polymorphic function, you have less freedom (to make bugs, too)
07:38:40 <benmachine> a clearly incorrect usage, resulting from a typo, causes a silent infinite loop
07:38:43 <quicksilver> so you might as well just Maybe a is a better return type than MonadFail m => m a
07:38:47 <quicksilver> @quote initial
07:38:47 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
07:39:17 <quicksilver> Peaker: there really is an error message argument and it's not just about our encoding of programs.
07:39:19 <Eduard_Munteanu> Was James McKinna in here?
07:39:24 <benmachine> quicksilver: we ignore the String argument to fail like all sensible do? :)
07:39:27 <quicksilver> Eduard_Munteanu: no, that was a mailing list post.
07:39:33 <Eduard_Munteanu> Ah.
07:39:34 <quicksilver> benmachine: in the context of that example, yes.
07:39:37 <Peaker> quicksilver: though it may not be that strong of an argument with a good IDE, IMO
07:39:48 <quicksilver> benmachine: if you want to include the String, the initial object is "Either String"
07:39:54 <dainanaki> I think I'm gonna start making my monad fail instances rm -rf things randomly
07:40:03 <dainanaki> teach people to use that abomination!
07:40:05 <benmachine> dainanaki: :P
07:40:06 <quicksilver> benmachine: which is also a perfectly good return type if you do want a String indicating what went wrong.
07:40:11 <byorgey> ghc used to do that for ill-typed programs
07:40:12 <Peaker> quicksilver: it can visualize the inferred types as you go -- including the selected instances for generalized functions (or showing you if they remain general)
07:40:24 <quicksilver> Peaker: I understand what you're saying but I think you're missing a point.
07:40:44 <quicksilver> the point is things like (1 + "a") type checking
07:40:57 <quicksilver> gets even worse with OverloadedStrings
07:41:03 <Schalken> Peaker: To be honest, I think we need to de-emphasize pattern matching all together because it's a non-reimplemetable interface. Whose to say this problem we describe with lists won't occur for some other structure. What people should really do is, as soon as they define a data type, immediately wrap it in a type class and start working with the type class. If the Prelude did that to begin with we wouldn't have all this pain wit
07:41:10 <quicksilver> it type checks as "any type b which is both Num and String"
07:41:22 <quicksilver> when you have lots of typeclasses everywhere, everything type checks
07:41:27 <quicksilver> and you infer types like
07:41:29 <Peaker> quicksilver: why can't (1 + "a") try to select an instance right at that point (and fail to type-check), rather than deferring instance selection to later?
07:41:39 <quicksilver> Peaker: because of polymorphism!
07:41:40 <Eduard_Munteanu> Schalken: view patterns are bit like pattern matching
07:41:45 <quicksilver> that instance might be defined in a anotehr module
07:41:47 <quicksilver> later.
07:41:49 <quicksilver> or by another user
07:41:58 <quicksilver> in a module which simply uses this module as a library.
07:42:02 <Eduard_Munteanu> So I guess that could do in some cases.
07:42:15 <mm_freak_> any reason to prefer mtl over transformers?
07:42:20 <mm_freak_> except the type classes
07:42:40 <benmachine> mm_freak_: I always preferred transformers to mt
07:42:41 <quicksilver> in the worst case everything passes type checking, and you get types like "a -> b -> c, where a is Num and String and ListLike, b is Foldable and Monoid and Monad"
07:42:42 <benmachine> mtl
07:42:43 <Peaker> quicksilver: are you talking about the interactive problem here, where you get the error too late? the position of the error can be correct even after-the-fact (whole program type-checking)
07:42:52 <benmachine> or more accurately, transformers+monads-fd
07:43:03 <benmachine> (or even better, transformers+monads-tf)
07:43:03 <mm_freak_> benmachine: yeah, monads-fd was my first thought
07:43:07 <quicksilver> Peaker: depending what you mean by 'too late', I might be.
07:43:07 <mm_freak_> uhm
07:43:12 <mm_freak_> yeah, i meant monads-tf
07:43:20 <benmachine> mm_freak_: transformers+monads-fd is now called 'mtl'
07:43:26 <benmachine> as in it basically re-exports those now
07:43:26 <Peaker> quicksilver: the interactive code editor can do "whole program editing", where it does know the global instance list as you edit
07:43:44 <Peaker> quicksilver: or at least have a workaround with blacklisted instances
07:43:50 <mm_freak_> i prefer type families over fundeps, but my question is actually:  any reason /not/ to use transformers directly?
07:43:50 <Peaker> (if you're editing a library)
07:43:55 <benmachine> whee, workarounds, no drawbacks to those :P
07:44:08 <quicksilver> Peaker: it cannot possibly know that.
07:44:12 <mm_freak_> i.e. without monads-fd/-tf
07:44:15 <benmachine> mm_freak_: transformers is basically a subset of mtl
07:44:23 <quicksilver> Peaker: you can be writing a library which will be used, in 15 years time, by a programmer 8000 miles away.
07:44:24 <benmachine> if you can do what you want with transformers you might as well
07:44:29 <quicksilver> Peaker: how can you know what instances he will define?
07:44:31 <mm_freak_> i see
07:44:37 <mm_freak_> alright, thanks
07:44:55 <Peaker> quicksilver: the IDE can also be made to assume that user code that uses the edited code will not add instances for concrete types already known (or give warnings rather than errors for stuff stemming from missing instances like that)
07:45:11 <Peaker> quicksilver: it sounds like a surmountable problem
07:45:11 <quicksilver> I think you're walking into a tarpit.
07:45:15 <quicksilver> go ahead at write it then :)
07:45:22 <quicksilver> it sounds completely unsurmountable to me.
07:45:25 <Eduard_Munteanu> MTL2, right?
07:45:34 <Peaker> quicksilver: basically, only orphan instances can be a problem here, right?
07:45:34 <quicksilver> there are lots of cases where new code might well add instances
07:45:39 <quicksilver> no
07:45:50 <Peaker> why not? We're talking about a case of a concrete type -- with a known type-class
07:45:58 <Peaker> either we already see the instance, or it's an orphan
07:46:00 <quicksilver> Peaker: I'm not talking about concrete types.
07:46:07 <quicksilver> I'm talking about inferred polymorphism
07:46:11 <benmachine> in (1 + "a") you've two polymorphic types
07:46:20 <benmachine> someone could invent a new type and instance both
07:46:25 <Peaker> "a" is monomorphic (or you mean the string-like extension?)
07:46:27 <quicksilver> will there ever be a type which is an instance of Listlike, IsString, and Traversable?
07:46:38 <benmachine> Peaker: yeah, that was what I was thinking
07:46:42 <quicksilver> in general it's hard to answer questions like that.
07:47:01 <quicksilver> as programmers we may have an instinctive idea that some combinations are not very sensible
07:47:03 <benmachine> quicksilver: modulo kind inconsistencies :P
07:47:06 <quicksilver> (like IsString and Num)
07:47:09 <quicksilver> benmachine: indeed.
07:47:18 <quicksilver> benmachine: "Traversable a for some a"
07:47:22 <benmachine> fair
07:47:39 <quicksilver> Peaker: I'm not saying this is the only kind of error message.
07:47:47 <quicksilver> I agree there are some classes of error message which you are quite righ
07:47:51 <quicksilver> and a good IDE can help.
07:47:54 <Peaker> quicksilver: ok, I thought you meant concrete types..   contradicting type-classes are more of a challenge, but an IDE could still warn about type class contexts that have no known instantiations (and cover the majority of cases), and have some special-cases to cover other cases
07:48:02 <quicksilver> I'm just pointing at one particular class of error messages
07:48:08 <benmachine> (see also: http://hackage.haskell.org/package/NumLazyByteString )
07:48:18 <quicksilver> which arise from haskell's type inference algorithm and the open world typeclass system
07:48:26 <quicksilver> typeclasses are *never* a piece of negative evidence
07:48:33 <quicksilver> so they never cause inference errors
07:48:37 <quicksilver> they simply pile up constraints.
07:48:52 <Peaker> quicksilver: you're being very absolutist :-) The IDE doesn't have to do strict, absolute type-checking.. It can give "heuristic warnings" that will be 90% accurate
07:48:55 <Eduard_Munteanu> I wonder if you can make comprehensions work with stream-fusion stuff
07:49:17 <benmachine> Peaker: I have a feeling you'll start making a lot of stylistic assumptions that won't be valid for everyone
07:49:18 <dainanaki> I thought they already did.
07:49:22 <Peaker> quicksilver: and with a bit of community-effort, some IDE pragmas near defined type-classes, these heuristics can probably be tuned to ~100%
07:49:26 <Eduard_Munteanu> and stuff like [1..10]
07:49:29 <quicksilver> The more type signatures you change to use typeclasses instead of concrete types, the more errors you convert into accumulated constraints.
07:49:36 <quicksilver> Peaker: I'm being absolutist and you're inventing numbers.
07:49:42 <Peaker> :-)
07:49:50 <quicksilver> Peaker: I agree that heuristic warnings can be X% accurate
07:49:58 <quicksilver> you suggest X is around 90 rising to 100
07:50:06 <quicksilver> I suggest it's around 9 x 10^(-15)
07:50:10 <benmachine> giggle
07:50:10 <quicksilver> rising to 1.
07:50:15 <Peaker> heh
07:50:35 <quicksilver> it varies a lot by code base
07:50:37 <quicksilver> and coding style
07:50:38 <Peaker> how many type-classes actually exist in a real-world code-base? How hard would it be to specify the contradictions between them?
07:50:41 <quicksilver> and all kinds of things.
07:50:46 * Eduard_Munteanu wants a constitutional quicksilver 
07:50:50 <benmachine> Peaker: not as many as you think there should be :P
07:50:51 <quicksilver> we don't have any practical experience in this
07:50:58 <quicksilver> I'd love to see someone try
07:51:05 <quicksilver> I think it's an interesting piece of SE research
07:51:14 <quicksilver> I'd love it to work well, it's just not obvious to me it will.
07:51:24 <Peaker> btw: In whole-program mode (as opposed to library mode) -- there's no problem here at all (all instances are known)
07:51:29 <Peaker> SE?
07:51:35 <quicksilver> software engineering
07:52:08 <Peaker> I guess you could mostly edit even your libraries in whole program mode -- and add instances for stuff that you don't really have/need but your users will need
07:52:20 <Peaker> (a bit of a nuisance, but perhaps a small price to pay?)
07:53:08 <Peaker> so if the IDE sees 2 constraints -- and no actual instance of both, it can warn, and you can add one to shut him up if it makes sense
07:53:34 <quicksilver> you can fix a lot of the errors I'm describing by careful and correct signatures on exported names
07:53:34 <Peaker> with flexible instances, this can probably get tricky/hairy, but maybe it can work
07:53:40 <quicksilver> or on all top-level names, perhaps.
07:53:50 <Peaker> well, I use top-level type signatures on everything anyway :)
07:53:54 <quicksilver> they're more of a problem in development than with a finished product.
07:54:04 <quicksilver> but development is the activity we're trying to make easy
07:54:09 <tac-tics> Hey. Does anyone know of a handy table that equates different lambda calculuses with the logical systems of equivalent power?
07:54:15 <quicksilver> and, I think, it's development benmachine was thinking of when he tried to outline some of the issues.
07:54:29 <quicksilver> with enough typeclasses, all expressions typecheck.
07:54:36 <benmachine> possibly
07:54:49 <Peaker> anyway, Haskell error messages suck anyway, and we all make do :)
07:54:57 <quicksilver> foo :: A -> B -> C -- this requires specific types for the first and second arguments
07:55:01 <hpc> tac-tics: you mean like regexes and the various grammars?
07:55:07 <SamB_XP> I always thought they were pretty awesome
07:55:13 <Peaker> quicksilver: not in "whole program mode", and not "show . read"
07:55:19 <hpc> i don't think so
07:55:29 <quicksilver> foo :: AClass a, BClass b => a -> b -> C -- this typechecks for *all* possible haskell expressions in first and second arguments
07:55:29 <tac-tics> hpc: I mean Simply Typed Lambda Calculus <---> Propositional Logic
07:55:31 <SamB_XP> compared to what you get from the likes of gcc...
07:55:38 <hpc> tac-tics: ah, not sure
07:55:39 <quicksilver> (it just adds two constraints)
07:55:44 <Peaker> SamB_XP: "infinite type in this 8 line function.. somewhere"
07:55:46 <tac-tics> and SystemF <---> First order logic (or whatever)
07:55:56 <Peaker> SamB_XP: that's my pet-peeve ghc error
07:55:56 <hpc> you should make one
07:56:02 <hpc> and put it on the haskell wiki
07:56:03 <tac-tics> I know the type theory, but I don't know my logical systems
07:56:05 <SamB_XP> okay, so the errors themselves are often puzzling
07:56:08 <quicksilver> so basically whenever you make an argument typeclass polymorphic, you will never get a type error from that argument.
07:56:17 <tac-tics> hpc: I would if I knew anything about logics :P
07:56:20 <Peaker> quicksilver: except for ambiguous types?
07:56:58 <quicksilver> Peaker: right.
07:58:02 <Peaker> anyway, I hate prevalent String use and the ByteString type mismatches far more than I care about error messages (which suck already in many cases, even without type-classes..)
07:58:36 <Peaker> monomorphic code is less useful even after development is done.. and that is IMO more important than the ease of development
07:58:39 <SamB_XP> but the messages show you the code in question, include column numbers, tell you both types when there's a mismatch...
07:58:59 <Peaker> In fact, the actual editing of code (the phase you go and fight error messages) is a very small amount of the time spent on real projects, IME
07:59:35 <SamB_XP> ... and have you ever seen what vector<string> looks like in an error message?
07:59:40 <Peaker> so optimizing it at the expense of the quality of the result is a bad idea
08:00:01 <Peaker> SamB_XP: I write C and Haskell, not C++.. and yeah, gcc error messages suck too, but ghc's are more frustrating a lot of the time
08:00:28 <SamB_XP> Peaker: I don't usually write C++ either
08:00:50 <Peaker> SamB_XP: the infinite-type error I am talking about, btw, doesn't actually tell you where it is at.. just that your (potentially large) definition has an infinite type in it somewhere
08:00:53 <SamB_XP> but I was hacking on crawl or something, and I guess I forgot a .c_str() somewhere ;-P
08:00:58 <SamB_XP> or put one where I shouldn't have
08:01:03 <Peaker> SamB_XP: then comes the binary-search phase, where I replace half of the function with "undefined" to see if type-checks, to find the wrong place
08:01:33 <tac-tics> Peaker: Sometimes, I feel like it would be helpful for GHC errors if the *compiler* had a step evaluator
08:01:42 <SamB_XP> what was that extension that lets type signatures bind type variables for signatures further in?
08:01:46 <benmachine> this is why I need to learn about type systems and write a explain-my-type program
08:01:55 <SamB_XP> that one could be pretty handy, too
08:02:12 <tac-tics> benmachine: what kind of program are you thinking about?
08:02:19 <Peaker> SamB_XP: ScopedTypeVariables?
08:02:24 <SamB_XP> probably
08:02:39 <benmachine> tac-tics: essentially one that runs through the type-checking algorithm, printing out what it thinks is equal to what and why
08:02:52 <benmachine> I did it for lambda calculus once, I think
08:02:55 <benmachine> then it got complicated :x
08:03:00 <tac-tics> Ah. So it shows you all the unifications and the justifications for each?
08:03:20 <benmachine> yes
08:03:26 <SamB_XP> I admit that the type errors in RML are much easier to follow
08:03:52 <SamB_XP> but that's no reason to prefer a language that only supports monomorhpic types!
08:04:09 <scooty-puff> can anyone get this: http://weblog.haskell.cz/pivnik/building-a-shared-library-in-haskell/ to work with ghc7, shared object packages?
08:04:13 <Peaker> What's RML? A restricted ML?
08:04:15 <scooty-puff> i cannot..
08:04:16 <benmachine> I think my objection was possibly overstated
08:04:49 <SamB_XP> Peaker: it's the langauge used to reprogram the robot you play in the ADVENT portion of boundvariable.org
08:04:52 <benmachine> but largely related to what quicksilver said about initial objects, in that your output type should be as small as possible while still reflecting exactly what you do
08:05:10 <quicksilver> benmachine: hyperbole in #haskell? HOW DARE YOU!
08:05:24 <benmachine> :P
08:05:28 * benmachine hides in shame
08:05:37 <quicksilver> imagine how dull Peaker's life would be if we didn't argue with him.
08:06:05 <benmachine> it's a public service, really
08:06:36 <Peaker> heh.. I'm actually procrastinating on fixing build errors from a 3-minute build cycle
08:06:43 <Peaker> (3-minutes to get the next build error after I fix one :-( )
08:07:11 <benmachine> it's obviously all the deferred errors from all your typeclasses
08:07:33 <SamB_XP> I mention RML mostly because I actually wrote a type checker for, so I know exactly how trivial the type errors are
08:08:16 <SamB_XP> I don't remember quite how specific I got the error messages to be, though
08:10:44 <tac-tics> Does anyone know of any studies done on nameless representations of Algebraic types or GADTs?
08:11:13 <tac-tics> such that a computer could algorithmically decide whether two data structures were STRUCTURALLY equivalent?
08:11:39 <SamB_XP> (I wrote my own typechecker because running it through the compiler in the codex caused too much swap thrashing for my patience...)
08:12:20 <SamB_XP> tac-tics: define structurally equivalent
08:12:47 <tac-tics> I mean data Foo = Foo and data Bar = Bar are both equivalent in the sense they are * kinded types with a single, parameterless constructor
08:12:58 <SamB_XP> But there has been *some* work on that with algebraic datatypes
08:13:06 <hpaste> Minstrell pasted “Algebraic type predicates” at http://hpaste.org/51151
08:13:28 <tac-tics> and Nat would be equivalent to data Silly = TooMuch | NotEnough Silly
08:13:38 <Minstrell> may the predicated be expressed better?
08:13:48 <tac-tics> regardless of the order or names involved.
08:14:03 <SamB_XP> regardless of order? why?
08:15:13 <tac-tics> SamB_XP: My idea is basically a distributed theorem prover. Any user could write their own data structures, functions, etc and prove theorems about them
08:15:25 <tac-tics> But people are bound to re-invent the same datastructures over and over
08:15:51 <tac-tics> So it would be nice, when comparing two people's environments, to be able to unify their data structure definitions automatically
08:16:21 <tac-tics> And say "Your Nat is the same as My Silly, therefore, your theorems have corresponding variations for my data structures"
08:16:23 <Saizan> convert to the generating functor in algebraic notation, apply some normalization, compare
08:17:01 <tac-tics> What's a generating functor?
08:17:44 <Eduard_Munteanu> F in D = Mu F?
08:18:13 <SamB_XP> http://blog.lab49.com/archives/3011 talks about a notation...
08:18:19 <Saizan> http://comonad.com/reader/2008/generatingfunctorology/ <- this stuff
08:19:03 <tac-tics> Saizan: Yes. I think I've seen that before. That's about what I want
08:20:02 <Saizan> Hinze i think should have some papers on these kind of isomorphisms between types
08:20:09 <SamB_XP> try http://www.google.com/search?q=algebraic%20data%20type%20calculus
08:21:01 <Saizan> tac-tics: the pattern calculus also feels related
08:21:14 <tac-tics> thanks
08:23:22 <SamB_XP> "calculus" may match everything from lambda calculus to differential calculus, but seems to result in more things talking about algebraic notations for the types
08:24:34 <SamB_XP> I mean, if you think about it, it's easier to deal with such datatypes using that sort of notation in both differential calculus and lambda calculus...
08:26:40 <obiwahn> is there a channel on functional programming theory (for noobs)?
08:27:02 <zachk> there is paper after paper on it
08:27:10 <zachk> but its all high level theory
08:28:46 <tac-tics> obiwahn: What level are you at?
08:28:47 <obiwahn> i am just getting started with strict monotonic functions chains and their upper bounds ...
08:29:46 <tac-tics> That doesn't sound so beginner :P
08:30:34 <Saizan> that's beginner domain theory :)
08:30:51 <obiwahn>  -> beginner :)
08:31:01 <SamB_XP> hey, there's noobs at all levels ;-P
08:31:13 <tac-tics> SamB_XP: They all make you feel pretty dumb at first. Then they click.
08:31:17 <tac-tics> Except the ones that never do....
08:31:19 <monochrom> chain of partial lists is easier. ⊥, 0:⊥, 0:0:⊥, 0:0:0:⊥ ... the limit is the infinite list 0:0:0:...
08:31:22 <Saizan> here would be a decent place to ask about domain theory
08:32:40 * hackagebot happstack-server 6.2.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.2.4 (JeremyShaw)
08:35:48 <Minstrell> isA and isB is "boilerplate code" in http://hpaste.org/51151 , is there a way to avoid the declarations? An ADT may have much more constructors...
08:36:06 <Minstrell> or it's unavoidable?
08:36:21 <quicksilver> Minstrell: there are metaprogramming tools to do that for you
08:36:33 <quicksilver> data.derive, drift
08:36:51 <quicksilver> http://hackage.haskell.org/packages/archive/derive/latest/doc/html/Data-Derive-Is.html does the isA, isB stuff
08:36:55 <quicksilver> (although it's undocumented :P)
08:37:04 <Minstrell> quaestor, I see, thanks
08:37:23 <quicksilver> well, documented in the comments int he source
08:37:24 <quicksilver> http://hackage.haskell.org/packages/archive/derive/latest/doc/html/src/Data-Derive-Is.html#makeIs
08:37:46 <tac-tics> Minstrell: deriving (Eq)
08:37:50 <tac-tics> isA becomes (==A)
08:37:55 <tac-tics> isB (==B)
08:38:17 <Minstrell> tac-tics, suppose data C = A Int | B
08:38:26 <quicksilver> tac-tics: yes, but not for the case where there are params :)
08:38:42 <quicksilver> in general things like 'isA/isB' are useful to have.
08:38:46 <tac-tics> define your own instance of Eq, but it'll be about the same length
08:38:47 <quicksilver> although I don't need them *that* often.
08:38:55 <tac-tics> At some point, you have to code your code if you want to run your code :P
08:39:08 <quicksilver> it's mechanical boilerplate though
08:39:10 <Minstrell> s/quaestor/quicksilver/ (annoying autocomplete =\)
08:39:16 <quicksilver> which is why things exist to write it for you.
08:39:30 <tac-tics> quicksilver: I want to say I've seen a constructor inspecting GHC extension before
08:39:35 <tac-tics> Maybe that's what he's looking for
08:40:16 <Peaker> Minstrell: is* accessors sound like Boolean Blindness (http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/)
08:40:25 <quicksilver> very occasionally, given data C = A Int | B
08:40:32 <quicksilver> I want a shadow data type with just constructors
08:40:41 <quicksilver> data CCons = C_A | C_B
08:40:44 <quicksilver> (for lack of a better name)
08:40:50 <Peaker> quicksilver: do you have any useful examples?
08:40:57 <quicksilver> and getCons A = C_A; getCons B = C_B
08:41:04 <quicksilver> Peaker: working over the ADT of a program, perhaps
08:41:20 <quicksilver> wanting to check "if this is either a lambda abstraction or a let statement then do this else do that"
08:41:23 <Saizan> getCons A{} = C_A
08:41:30 <quicksilver> Saizan: sorry, yes, thanks.
08:41:48 <quicksilver> Peaker: obviously you can always just write the case statement
08:41:53 <quicksilver> with the appropriate {}.
08:42:00 <Peaker> quicksilver: or write catamorphisms and use some consts
08:42:00 <quicksilver> but sometimes you want to abstract over lists of constructors
08:42:11 <quicksilver> Peaker: right. but if your data type has 12 constructors
08:42:16 <quicksilver> then the catamorphisms are ugly to use
08:42:24 <quicksilver> you want to have a 'set of constructors' as a term.
08:42:40 * hackagebot happstack-hamlet 6.2.0 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-6.2.0 (JeremyShaw)
08:43:05 <Peaker> quicksilver: maybe you need specialized catamorphisms, if you have distinct meanings to groups of constructors?
08:43:15 <stepkut> what is the difference between aeson and aeson-native?
08:43:20 <Peaker> quicksilver: also, it's likely that the different fields means you need to really do different things? (e.g: recurse into the fields?)
08:43:41 <quicksilver> Peaker: maybe I do need specialised catamorphisms.
08:43:48 <quicksilver> btu sometimes it's more convenient and readable to write
08:44:26 <quicksilver> foo | getCons p `elem` [CLam,CApp,CLet] = {- ... -} | otherwise = {- ... _}
08:44:41 <quicksilver> I'm not claiming this comes up particularly often, mind you.
08:44:55 <quicksilver> but it does come up occasionally, especially with very large types.
08:44:56 <tswett> Is it just me, or does the SDL package contain no code?
08:45:07 <quicksilver> I recognise the pattern and I've seen people ask about it here before, too.
08:46:05 <Peaker> quicksilver: I wonder under what examples it is OK to do something on these constructors while completely ignoring their fields
08:46:14 <elliott> stepkut: Looks like it uses Haskell code for double conversion rather than double-conversion
08:46:26 <elliott> The latter doesn't work in GHCi or apparently with TH
08:46:47 <elliott> But the former (-native) is slower, apparently
08:47:08 <obiwahn> what is the \uCODE for bottom
08:47:30 <tswett> Never mind, I think I've found it.
08:47:42 <tac-tics> ⊥
08:47:49 <tswett> obiwahn: the Unicode codepoint for the "bottom" symbol?  It's... whatever that is.
08:47:53 <quicksilver> Peaker: well, often you don't ignore the fields. Often you do pass the whole expression down as well.
08:47:57 <elliott> tswett: it's just ffi glue (the sdl package)
08:47:58 <tswett> > ord '⊥'
08:47:59 <lambdabot>   8869
08:48:12 <int-e> Peaker: https://secure.wikimedia.org/wikipedia/en/wiki/List_of_logic_symbols
08:48:14 <tac-tics> http://www.fileformat.info/info/unicode/char/search.htm?q=%E2%8A%A5&preview=entity
08:48:20 <int-e> sorry. obiwahn:
08:48:21 <Jafet> > generalCategory '⊥'
08:48:22 <lambdabot>   MathSymbol
08:48:27 <quicksilver> Peaker: if getCons p `elem` [CLam,CApp,CLet] then alphaRename p else p
08:48:30 <tswett> elliott: indeed, but it took me a moment even to figure out where that was.
08:48:49 <obiwahn> 衩moep
08:48:54 <tac-tics> @type generalCategory
08:48:54 <elliott> tswett: Enjoy your poke and peek calls
08:48:55 <lambdabot> Char -> GeneralCategory
08:49:12 <tac-tics> > generalCategory 'る'
08:49:13 <lambdabot>   OtherLetter
08:49:34 <Peaker> quicksilver: but alphaRename will have to match those anyway?
08:49:40 <Peaker> quicksilver: in order to recurse?
08:49:54 <quicksilver> Peaker: often. But maybe alphaRename just uses a general purpose catamorphism or perhaps even fmap.
08:49:57 <quicksilver> Peaker: who knows :)
08:49:58 <stepkut> elliott: thanks
08:50:17 <hpaste> insane pasted “lazy bytestring” at http://hpaste.org/51154
08:50:22 <quicksilver> Peaker: in a perfect world the type would be refined and you wouldn't pass 'p' you'd pass something which only has the three constructors App/Lam/Let
08:50:37 <quicksilver> Peaker: but then you end up with hundreds of variants of your data types with only certain subsets of the constructors.
08:51:22 <Peaker> quicksilver: I guess the ML anonymous sum types could come in handy (or was it OCaml?)
08:51:48 <insane> does anyone know why the code at http://hpaste.org/51154 creates the whole infinite ByteString first instead of treating it lazyily? Data.Binary.Get was supposed to be lazy...
08:52:01 <quicksilver> Peaker: ocaml, yes, this is exactly the one of the use cases people discuss for them.
08:52:40 * hackagebot cassandra-thrift 0.8.5 - thrift bindings to the cassandra database  http://hackage.haskell.org/package/cassandra-thrift-0.8.5 (KirkPeterson)
08:55:17 <elliott> insane: wow, what are you doing?
08:55:31 <insane> elliott: what do you mean?
08:55:38 <elliott> it looks like you're interleaving your parsing and output for some strange reason
08:55:59 <elliott> in fact, it looks like you're just using Data.Binary for output, no parsing at all
08:56:27 <Peaker> elliott: It's just a test that I suggested in order to see if Binary.Get was lazy or not (though I may have recommended a wrong test) :)
08:56:33 <elliott> oh
08:56:44 <elliott> ok, I was worried insane thought that was a good way to structure their program :P
08:56:58 <Peaker> I guess it can trigger issues with sequence_ on long lists
08:57:05 <elliott> main = mapM_ print . BL.unpack $ BL.repeat 0 -- equivalent :P
08:57:11 <insane> elliott: it's just a simple example, but what I'm trying to do is to parse binary file in chunks and output these chunks immediately as they're parsed, not when the whole file is parsed (because it might be huge)
08:57:15 <elliott> except maybe not equivalent if it doesn't work
08:57:22 <Minstrell> Peaker, http://hpaste.org/51155 in addition to the http://hpaste.org/51151. I just need to filter out inputs that can throw exceptions (the real function has more arguments and matchings).
08:57:27 <elliott> insane: ok. so why not "Get [ParsedChunk]"
08:57:31 <elliott> and then mapM_ over that?
08:57:38 <elliott> rather than reading a list of IO actions
08:58:29 <insane> elliott: does it change anything in regards to laziness?
08:58:39 <elliott> insane: it should be equivalent.
08:58:45 <elliott> lists are lazy :P
08:58:52 <elliott> it depends on whether Data.Binary is, of course
08:58:58 <elliott> but if it isn't, it'll be just as strict
08:59:02 <Minstrell> Peaker, doing this by pattern matching in the function body is uglier...
08:59:14 <Peaker> elliott: what if you want to interlace IO actions with the lazy parsing? Is that possible without resorting to separate Get computations?
08:59:44 <insane> elliott: well that's the exact point. It should be, that's what's written in the docs, but this example shows that it really isn't. At least if the example isn't doing something wrong.
08:59:47 <elliott> Peaker: If Get is lazy, then you can just Get [a] and mapM_ over that and it'll be interlaced.
08:59:53 <Peaker> Minstrell: you're using "isA" and then you're using "fromA" partially/unsafely inside, right?
08:59:55 <elliott> If you want to take input too, I wouldn't want to use Get anyway.
09:00:01 <elliott> insane: right, yeah
09:00:12 <elliott> insane: it's a reasonable testcase, just not a good way to structure a program, which is what I thought you thought it was :P
09:00:16 <Peaker> elliott: yes, so the question is -- whether this test stack-overflowing proves Get is not lazy, or just triggers some bad behavior elsewhere (e.g: sequence not nice on stack use)
09:00:34 <elliott> yeah
09:00:50 <Minstrell> Peaker, yes, for example: map fromA as
09:01:01 <Peaker> Minstrell: I think it's much nicer to use:  getA :: C -> Maybe (a fields here)   and then use  catMaybes on that
09:01:03 <elliott> Peaker: sequence (repeat (print ()) seems to run forever here, FWIW
09:01:16 <Peaker> elliott: leak like crazy unless you sequence_ :-)
09:01:25 <elliott> 17955 elliott   20   0  100m  43m  23m S  100  1.2   0:30.33 ghc
09:01:27 <elliott> apparently not, somehow
09:01:38 <elliott> I don't know _why_ it's not leaking :P
09:01:43 <Peaker> Minstrell: No partiality is needed here
09:02:09 <Peaker> Minstrell: This is the point of "boolean blindness" -- booleans don't carry enough information, so it becomes up to you, rather than up to the compiler, to prove the safety of your code
09:02:28 <Peaker> (and makes it harder to follow the code, because you have to track the history of every boolean to know what it actually means)
09:03:14 <Peaker> Minstrell: catMaybes on:  map getA, of course.. which actually has a nice alias:  mapMaybe
09:03:16 <Peaker> @hoogle mapMaybe
09:03:17 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
09:03:17 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
09:03:18 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
09:03:45 <Peaker> The last one is the one I'm referring to
09:03:52 <tswett> Peaker: does "Boolean blindness" refer to the idea that simply given a Boolean value, you have no idea what it means?
09:04:02 <Minstrell> Peaker, I agree, if I omit the guards then the safety of the code will be violated =(, and it's up to me, not the compiler...
09:04:32 <Peaker> tswett: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/   Yes, that's the main gist -- but it elaborates on alternatives and pros of using richer types than boolean
09:04:52 <Peaker> Minstrell: So what you really want is more like a Maybe getter for the fields rather than a boolean checker for constructors
09:05:43 <Peaker> Minstrell: you can also use:  [x | A x <- xs]
09:06:10 <Minstrell> Peaker, thanks, I'll try
09:06:26 <Peaker> > [x | Left x <- [Left 5, Right 'a', Left 8, Right 'b', Right 'c', Left 9]]
09:06:27 <lambdabot>   [5,8,9]
09:06:56 <CindyLinz> hi
09:07:24 <CindyLinz> i'm curious abount why GHC didn't complain about the type ambiguity.. # http://hpaste.org/51156
09:08:12 <CindyLinz> The k and k2 in this code could be Int or Integer. If I put IO Int or IO Integer after the getLine..
09:08:33 <tswett> @index Int32
09:08:34 <lambdabot> Data.Int, Foreign
09:09:29 <Peaker> CindyLinz: because Num instances have special defaulting rules
09:09:49 <Peaker> CindyLinz: you can use {-# OPTIONS -Wall #-} at the top of your file to enable "all warnings" and one of them will be that you got a default type specialization
09:09:50 <CindyLinz> oh.. defaulting rule... @@"
09:10:24 <CindyLinz> Peaker: where can I find the default rules?
09:11:00 <Jafet> You mean the default default rules?
09:11:30 * tswett decides the easiest solution to this problem is to not write an SDL application using Haskell on OS X.
09:11:43 <CindyLinz> Jafet: yes ^^|
09:11:52 <Peaker> I don't understand how they could design a nice language like Haskell, and throw in a special keyword like "default" that exclusively applies to one library class as a special case
09:12:04 <Peaker> That seems like a really basic mistake to make
09:12:16 <Peaker> Why not:  default Num .... ?
09:13:19 <Peaker> CindyLinz: From http://www.haskell.org/tutorial/numbers.html: The "default default" is (Integer, Double), but (Integer, Rational, Double) may also be appropriate. Very cautious programmers may prefer default (), which provides no defaults.
09:13:46 <CindyLinz> Peaker: thanks ^^
09:14:09 <tswett> Won't default () cause strictly more compilation errors and have no other effect?
09:14:21 <Peaker> tswett: is causing compilation errors a bad thing?
09:14:45 <Peaker> more compilation errors is one of the best things about Haskell :-)  (less runtime errors..)
09:14:46 <tswett> Peaker: it depends on whether the code has bugs that are worth fixing or not.
09:14:49 <Jafet> See also ghci's default default rules http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
09:15:03 <Peaker> tswett: and using Integer vs Int could definitely represent performance/correctness bugs
09:15:08 <tswett> If it does, give a compiler error so you can fix it.  If it doesn't, leave me alone.  :)
09:15:41 <benmachine> Peaker: what if you had default Eq (Integer, Int) and default Show (Int, Integer) and then had let x = 1 + 1 in if x == 2 then show x else ""
09:15:58 <Peaker> tswett: so you want a "Sufficiently Smart Compiler (TM)"? :)
09:16:06 <tswett> Yes, yes.  :)
09:16:25 <Peaker> benmachine: conflicting defaulting rules for 'x' in line ...
09:16:25 <Jafet> ghci has a default Monad IO
09:16:31 <Jafet> Among other things
09:16:43 <Jafet> Also a default * ()
09:16:56 <Jafet> Yet no one seems to complain about those
09:17:05 <benmachine> well, ghci is not for writing programs
09:17:10 <benmachine> it's not really a programming language
09:17:14 <benmachine> it's for playing with things
09:17:20 <benmachine> haskell should aspire higher
09:17:34 <Jafet> Wait, I thought that was haskell in general
09:17:38 <benmachine> (the overzealous defaulting actually is sometimes annoying... see:)
09:17:40 <tac-tics> benmachine: My sentiments agree
09:17:47 <benmachine> @check \xs -> xs == reverse xs
09:17:49 <lambdabot>   "OK, passed 500 tests."
09:18:12 <benmachine> Jafet: defaulting applies somewhat in haskell, but ghci has defaulting-on-steroids
09:18:39 <tac-tics> Haskell is a compiler. It compiels type theory thesis papers to grant money intermediate code.
09:19:02 <Peaker> ghci could be more interactive... "ambiguous type, here's a prompt to choose what type you actually want"
09:19:50 <benmachine> Peaker: go code it :P
09:20:14 <Jafet> That's going to be more useful in ghc than ghci, in fact
09:20:15 <obiwahn> benmachine: what does the check expression exactly say?
09:20:43 <Jafet> Check if, for any value of type [()], it equals its reverse
09:20:48 <benmachine> obiwahn: lambdabot is verifying that for all lists xs, xs == reverse xs
09:21:00 <benmachine> it doesn't mention that it's decided to check this for lists containing only ()
09:21:03 <Peaker> s/for all/for a sample
09:21:14 <benmachine> Peaker: well, verifying, not proving :)
09:21:35 <Peaker> It could be nice if it at least issued a "ambiguous type specialized to .." warning line there
09:21:49 <benmachine> -fwarn-defaulting?
09:21:58 <benmachine> or you mean it should be turned on for lb?
09:22:09 <Jafet> ghci doesn't give warnings... it runs off, tyres screeching.
09:22:41 <Peaker> benmachine: for lb it doesn't really matter :)
09:22:46 <Peaker> but as a default for ghci
09:28:40 <dafis|windows> Peaker: echo "-Wall" >> ~/.ghci
09:34:23 <Peaker> in continuation to insane's question -- given the lack of GetT, what's a good way to incrementally parse very large inputs (e.g: infinite lazy bytestrings)?
09:36:36 <cadabra> Using parsec, how do I parse out parse out ['a', 'a', 'a'] from "    a  a     a  "? I thought `parseTest ((many (spaces >> char 'a')) >> spaces >> eof) "   a a  a  "` would work, but it fails with "expecting space or "a""
09:37:17 <Peaker> cadabra: I'm guessing that "many" doesn't backtrack
09:37:47 <dafis|windows> cadabra: the spaces in 'many (spaces >> char 'a')' consume something after the last a
09:38:05 <cadabra> I see. So I tried many (try (..
09:38:20 <cadabra> And got ()
09:39:03 <dafis|windows> cadabra: spaces >> many (char 'a' >>= \x -> (spaces >> return x))
09:40:30 <cadabra> I see.h,
09:42:06 <Peaker> cadabra: or: ((Text.Parsec.many . Text.Parsec.try $ spaces >> char 'a') <* (spaces >> eof))
09:42:48 <superchargers> sorting algorithms
09:43:53 <cadabra> What is <*?
09:44:09 <roconnor> @src (<*)
09:44:10 <lambdabot> (<*) = liftA2 const
09:44:41 <Peaker> @type (<*)
09:44:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
09:44:56 <Peaker> cadabra: it's like (>>) but the value from the left one is used, rather than from the right
09:45:02 <roconnor> cadabra: a <* b will run the effects of a and b but return the value of a
09:45:15 <cadabra> Okay.
09:45:17 <obiwahn> what does it mean when a function is total?
09:45:31 <Peaker> obiwahn: That for all possible inputs, it has a valid output
09:45:36 <roconnor> obiwahn: for every total input value the output is a total value.
09:45:44 <Peaker> roconnor is more accurate :)
09:45:46 <tac-tics> obiwahn: 1/x is NOT a total function, for instance, because 1/0 has no value
09:46:07 <tac-tics> in Haskell, length is not total, because length of an infinite list does not return a value
09:46:53 <tac-tics> (+1) IS total, because every number has a successor
09:47:24 <hpc> tac-tics: not all numbers
09:47:38 <hpc> > (+1) (maxBound :: Int)
09:47:39 <lambdabot>   -9223372036854775808
09:47:43 <hpc> oh
09:47:54 <hpc> > succ (maxBound :: Int)
09:47:55 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
09:47:59 <hpc> suspicious
09:48:26 <tac-tics> hpc: Stop being pedantic at the cost of this man's education!
09:48:33 <tac-tics> :P
09:48:48 <hpc> :P
09:49:16 <tac-tics> Total means for all x, f(x) eventually returns a value
09:49:51 <erus`> >sum [1..(maxBound :: Int)]
09:50:02 <erus`> > sum [1..(maxBound :: Int)]
09:50:03 <tac-tics> Many dependently typed languages (Coq, Idris) require ALL functions be total.
09:50:06 <lambdabot>   mueval-core: Time limit exceeded
09:50:16 <roconnor> tac-tics: I don't like the operation tone of your words :/
09:50:22 <roconnor> *operational
09:50:24 <roconnor> :)
09:50:42 <erus`> tac-tics: what about agda?
09:50:56 <tac-tics> Dunno much about agda, but I think that too
09:51:18 <tac-tics> dep type languages are esp. common to have that restriction, because type checking involves computation
09:51:19 <tac-tics> a
09:51:30 <tac-tics> and you always want type checking to terminate (you want type checking to be TOTAL)
09:51:31 <roconnor> agda constantenty has tricky ways of making partial functions :)
09:51:48 <roconnor> aka bugs
09:51:57 <superchargers> does anyone use Symfony
09:52:17 <Schalken> superchargers: The web framework?
09:52:59 <erus`> i really wanna try the std::thread stuff
09:53:03 <superchargers> mhm
09:53:18 <Schalken> superchargers: not I.
09:55:00 <superchargers> schalken what kind of projects are you working on
09:55:11 <obiwahn> a function is total when every item in the input domain is mapped to the output domain? and there is no undefined behavior?
09:55:23 <tac-tics> yep
09:55:54 <tac-tics> In the context of programming, usually that also means no throwing exceptions, no bottom values, no unhandled cases, etc.
09:56:44 <Peaker> tac-tics: is an infinite list a total input for length?
09:57:12 <tac-tics> inputs aren't total. Functions are total.
09:57:36 <obiwahn> how can an argument be total? it can be mapped or not
09:57:48 <Peaker> roconnor: isn't its totality check provably sound?
09:58:25 <roconnor> I don't know what you mean
09:58:43 <Eduard_Munteanu> The latest Agda bug had something to do with irrelevance.
09:58:47 <erus`> agda cant do lazy lists?
09:59:05 <roconnor> obiwahn: in DCPO's total values are the maximal elements of the lattice
09:59:12 <Eduard_Munteanu> erus`: what do you mean by lazy lists? Surely it's lazy.
09:59:27 <roconnor> obiwahn: in Haskell speak, a total value is a value which has no bottoms in subexpressions.
09:59:31 <tswett> Can Agda do infinite lists?
09:59:33 <roconnor> such as infinite lists
09:59:35 <Eduard_Munteanu> But you can only do infinite lists as codata.
09:59:48 <erus`> can i have an agda function like f x = 1 : f x ?
09:59:54 <roconnor> Agda has some hacky mechanisms for codata.
10:00:01 <Peaker> roconnor: I would hope that Agda's totality checking is not something that's debugged until people are comfortable, but something that someone proves the correctness of?
10:00:29 <roconnor> Peaker: it is more like it is debugged until people are comfortable.
10:00:49 <Eduard_Munteanu> erus`: in a way, yeah.
10:00:51 <rwbarton> someone proves the correctness in an early version, then someone else adds a new type system feature, then who knows what happens
10:00:57 <Peaker> tac-tics: are values not total/partial too?   f :: Int ; f = f        this is not a partial function, so what partial thing is it?
10:01:07 <roconnor> Peaker: typically in these systems proving that all functions are total is equivalent to proving that they are consistent.
10:01:28 <Eduard_Munteanu> erus`: the thing is codata must be productive (that is, you must be able to evaluate it piecewise in finite time)
10:01:42 <roconnor> Peaker: so such proofs can typically only be carried out in proof systems less reliable than the one you are trying to prove sound.
10:02:06 <Peaker> roconnor: bummer :)
10:02:22 <tac-tics> Peaker: There's probably some correspondence when you deal with lazy haskell values, but generally, you speak of functions
10:03:00 <roconnor> Peaker: if you do manange to prove Agda is total in Agda that entails that you have partial functions.  Oh the irony.
10:03:06 <tac-tics> Peaker: and in that particular example, you're defining f in terms of itself.... meaning under the covers you have a fix point expression in there. And fix isn't total
10:03:19 <tac-tics> In fact, fix is what makes things NOT total in Haskell ;)
10:03:31 * Eduard_Munteanu begins to think that Godel dude was the biggest troll ever
10:03:35 <roconnor> tac-tics: that and non-monotonic data types
10:03:42 <roconnor> and that oleg rank2 stuff
10:03:45 <roconnor> and ...
10:04:04 <tac-tics> Peaker: in that case, f = fix id :: Int
10:04:22 <Peaker> tac-tics: so fix is a partial function, but a value defined in terms of fix is not a function, yet it can be partial.. so I think not only functions are total/partial?
10:05:10 <tac-tics> Peaker: f = fix id :: Int
10:05:13 <tac-tics> Evaluate fix id
10:05:23 <tac-tics> fix id = id (fix id) = fix id = ....
10:05:25 <tac-tics> it loops.
10:05:51 <tac-tics> So fix is partial. And it turns out, it isn't defined for the input "id"
10:06:01 <tac-tics> So in a sense, f isn't well defined
10:06:03 <Peaker> tac-tics: I understand -- I am just asking, if partiality is a property of functions -- what do you call values that are defined as the result of an application of a function to an input it is partial for?
10:06:24 <tac-tics> You don't call them values :P
10:06:32 <tac-tics> You call them _|_ or bottom or undefined
10:06:47 <roconnor> I'm not too sure what the problem here is.  It is pretty clear what partial values in CPOs are.
10:06:48 <Peaker> usually people tend to say that bottom is a value, or in fact: "the least-defined value"
10:07:14 <roconnor> well, I guess you need to know what a CPO is
10:07:24 <roconnor> I suppose that isn't entirely clear
10:07:24 <tac-tics> Peaker: It depends on who you're talking to and what their field is, of course
10:08:00 <tac-tics> But when I say value, personally, I mean a term in its normal form
10:09:41 <Peaker> roconnor: CPO?  C.... partial order?
10:09:49 <obiwahn> complete
10:09:49 <Eduard_Munteanu> Complete.
10:10:20 <roconnor> ah
10:10:24 <obiwahn> it has a smalles element and every chain has a supremum
10:10:39 <roconnor> I just realized what tac-tics says makes total sense from an ML point of view
10:11:04 <roconnor> boy it has been a long time since I thought of expressions and values that way
10:11:07 <tac-tics> roconnor: What part? I'm always curious when I make any sense at all :)
10:11:19 <roconnor> [13:56] <tac-tics> But when I say value, personally, I mean a term in its normal form
10:11:23 <tac-tics> ah
10:11:30 <ciaranm> making sense from an ml point of view isn't making sense!
10:11:34 <roconnor> that is totally how ML people would define a value
10:11:40 <tac-tics> roconnor: I broke out my B. Pierce text yesterday, and that's how he defines it.
10:11:56 <tac-tics> I'm not so interested in Haskell, but the community is just the best function Programming community there is
10:12:13 <monochrom> this is a lot of double talk, triple talk. some of you are talking about systems like Coq where functions are strict, there are no lazy lists etc., you don't worry about f(0:0:⊥) because you don't have 0:0:⊥. some other of you are talking about haskell.
10:12:29 <Eduard_Munteanu> tac-tics: there's #haskell-blah in case you find yourself going way too offtopic :)
10:12:35 <tac-tics> monochrom: We're cross-discipline :)
10:12:48 <roconnor> tac-tics: ya, people in Haskell typically have a different perspective on values.
10:12:55 * zachk goes cross-eyed 
10:13:03 <monochrom> well, being on different pages is not a subtitute for cross-discipline
10:13:21 * rwbarton has infinite lists but not 0:0:⊥
10:13:47 <tac-tics> Besides, having to deal with _|_ everywhere as a value just adds a lot of work
10:13:58 <roconnor> tac-tics: probably because it is unusual to have functions like (const 0) that take "non-values" and return values
10:13:59 <tac-tics> and defeats a big part of what typing was invented to do >_<
10:14:36 <tac-tics> but I'll admit infinite anything for basically free is kinda neat
10:14:52 <roconnor> tac-tics: We (or at least I) typically get around that work by ignoring partial values :)
10:15:49 <roconnor> ya, the problem with the normal form point of view is that infinite lists are still total values, but they don't really have a normal form.
10:17:34 <obiwahn> in Haskell a fun must be monotone but not continuous?!
10:17:55 <obiwahn> or are both required to be computable?
10:17:56 <Eduard_Munteanu> Monotone how?
10:17:59 <benmachine> I think it does have to be continuous
10:18:03 <benmachine> Eduard_Munteanu: information content
10:18:03 <roconnor> obiwahn: they are all continuous
10:18:21 <roconnor> Eduard_Munteanu: monotone wrt to the PO in the CPO
10:18:45 <roconnor> Eduard_Munteanu: if we make the input more defined the output doesn't become less defined.
10:18:45 <Eduard_Munteanu> According to definedness ordering?
10:18:45 <benmachine> so if x contains more information than y, then f x contains at least as much information as f y
10:18:47 <monochrom> every haskell function is continuous
10:18:50 <Eduard_Munteanu> Ah.
10:18:52 <rwbarton> continuity is what stops a function from e.g. determining whether a list is infinite
10:19:10 <roconnor> continuous implies monotone
10:19:29 <tac-tics> How is continuous typically defined for FP functions?
10:19:38 * Eduard_Munteanu would like to know too
10:19:50 * tgeeky guesses: you can keep talking limits and/or colimits?
10:19:53 <b_jonas> but what does continuous mean?
10:19:55 <tac-tics> Continuity isn't defined by open sets like in analysis is it?
10:19:56 <monochrom> f (lim i. x i) = lim i. f(x i)
10:20:03 <tac-tics> ah
10:20:07 <tswett> tac-tics: as far as I know, it actually is.
10:20:12 <roconnor> something like the limit of asscending chains is mapted to the limit of the image of the chain.
10:20:25 <b_jonas> ah
10:20:29 <monochrom> sometimes we s/lim/sup/ because sup is the only limit for this purpose
10:20:38 <Eduard_Munteanu> roconnor: in definedness ordering again, no?
10:20:38 <roconnor> you can turn this into a statement about open sets
10:20:43 <roconnor> Eduard_Munteanu: right
10:20:47 <b_jonas> but that's not really continuous, only lower (or upper, I dunno) half continuous or something like that, right?
10:21:05 <tgeeky> b_jonas: that sounds like the definition of continuous assoaciated with the Reals
10:21:18 * roconnor tries to remember what the basic open sets are
10:21:23 <b_jonas> tgeeky: yeah
10:21:26 <benmachine> b_jonas: I guess the other way would be trivial since the information ordering is probably well-ordered?
10:21:46 <benmachine> so a strictly decreasing sequence in terms of information content is probably eventually constant
10:21:47 <b_jonas> I don't really know. I don't actually know topology.
10:21:50 <b_jonas> I ust pretend to.
10:21:51 <obiwahn>  i have to understand all thoese concepts to get to the fixpoints:)) but when i think i understnad one i have forgot about the other:)) buhuhu
10:22:13 <roconnor> I think the basic open sets are you generated by a single point in the CPO and taking all the points above it.
10:22:17 * tgeeky tried guffawing 'buhuhu' and liked it
10:22:21 <roconnor> *are generated
10:22:22 <Eduard_Munteanu> obiwahn: hm? Not really.
10:22:23 <monochrom> example. what is length (0:0:0:...)? answer: that's length (limit of ⊥, 0:⊥, 0:0:⊥ etc) = limit of (length ⊥, length (0:⊥), length (0:0:⊥) etc) = limit of (⊥, ⊥, ⊥ etc) = ⊥
10:22:27 <b_jonas> benmachine: no, I don't think so
10:22:28 <tswett> roconnor: aren't the basic open sets simply expressions with holes in them, a la "Just (Right _, [Nothing, _, Just Nothing])"?
10:22:37 <benmachine> b_jonas: mm?
10:22:54 <rwbarton> things get trickier when you consider the CPOs for function types
10:22:57 <benmachine> tswett: sounds like the same
10:23:01 <b_jonas> benmachine: take the sequence [[(),(),(),...],[_|_,(),(),...],[_|_,_|_,(),...],...]
10:23:06 <rwbarton> ezyang had a nice blog post with some examples
10:23:15 <b_jonas> benmachine: that's strictly decreasing in definedness but is not eventually constant
10:23:16 <roconnor> tswett: ya, I think that is the same as I'm trying to say.  Put bottoms into your holes and you have a point in the DCPO and all the points above it are all the ways you can fill in those holes.
10:23:44 <rwbarton> or yeah, rather than a function type you can use an infinite list I guess
10:23:50 <tswett> Rather, given an expression, the set of all ways of filling it in is an open set.  It... nah, I know less about this than others.
10:23:57 <benmachine> b_jonas: hm, good point. shrug.
10:24:02 <b_jonas> ah, I see
10:24:12 <tswett> Aren't all definable functions continuous anyway?
10:24:17 <b_jonas> so continuous in this sense is a refinement of monotonous
10:24:24 <benmachine> *monotonic
10:24:30 <benmachine> not boring >_>
10:24:30 <Eduard_Munteanu> Heh.
10:24:37 <monochrom> yes, programming languages make sure all definable functions are continuous
10:24:38 <roconnor> basicOpens = { {y | x <= y} | x \in D}
10:25:01 <Eduard_Munteanu> Where's this stuff covered in more detail?
10:25:11 <monochrom> essentially you need unbounded non-determinism to get discontinuity. that is, even bounded non-determinism stays continuous
10:25:13 <roconnor> b_jonas: yep, being continuous implies being monotone
10:25:23 <Eduard_Munteanu> TAPL? (I don't remember seeing that)
10:25:31 <tswett> And yet not all continuous functions are definable.  Most functions Integer -> Bool are undefinable, but all of them are continuous, right?
10:25:40 <tswett> (Assuming that there are no infinite Integers.)
10:25:40 <rwbarton> I think these are the basic closed sets, though, not the open ones...
10:25:48 <roconnor> tswett: that is correct
10:25:58 <monochrom> TaPL does not cover this stuff. you need a more intimidating book, or else a lattice theory book
10:25:59 <b_jonas> tswett: correct
10:26:05 <tswett> rwbarton: aren't they both?
10:26:09 <benmachine> so we have monotonic < continuous < computable?
10:26:14 <rwbarton> they should not be both
10:26:18 <roconnor> benmachine: yep
10:26:19 <rwbarton> though they are very similar
10:26:22 <Eduard_Munteanu> monochrom: I have something on lattices, but I'm not sure they talk about PLs
10:26:23 <tgeeky> i have a hard time seeing functions of Integer -> Bool being continuious
10:26:36 <monochrom> the irony is that this stuff itself is not intimidating. it just doesn't appear in easy books
10:26:50 <b_jonas> tgeeky: that's because Integers are always either bottom or completely strict
10:26:54 <tgeeky> monochrom: that's not irony
10:27:01 <roconnor> tgeeky: given Integer and Bool both the discrete topology makes every set theoretic function continuous in our CPO setting.
10:27:07 <b_jonas> so at least if the function maps bottom to bottom then it's continuous
10:27:07 <Eduard_Munteanu> Lattices didn't seem particularly intimidating.
10:27:30 <tgeeky> roconnor: hm. that does make sense.
10:27:31 * benmachine wonders if it's reasonable to give Integer a discrete topology
10:27:34 <monochrom> right, lattice theory books aren't intimidating
10:27:49 <brisingr> benmachine: I'd think so
10:27:58 <roconnor> tgeeky: topology is really important in CS, but everything is taught from a set theoretic perspective for some reason.
10:28:03 <monochrom> but this cpo stuff is covered in either easy lattice theory books or intimidating programming language books
10:28:08 <rwbarton> the relevant topology here is discrete on the values aside from _|_
10:28:11 <b_jonas> benmachine: Haskell integers, yes. the problem is, you can't define those from functions or algebraic types.
10:28:19 <b_jonas> (not in a way that respects seq at least)
10:28:20 <roconnor> tgeeky: I guess it is becasue topology is only relevent when dealing with Higher order functions
10:28:21 <benmachine> b_jonas: right, that's what I was thinking
10:28:23 <Eduard_Munteanu> Is there a lot on lattice theory? I've seen some things in a book on universal algebras, groups, rings etc.
10:28:24 <tgeeky> roconnor: yes, I've noticed. And it's starting to annoy me, finding cited examples of things that are grounded in set theory
10:29:08 <Eduard_Munteanu> Damn, I should read some topology sometime.
10:29:10 <roconnor> tgeeky: have you seen the isomorphism between ((Integer -> Bool) -> Bool)  and Integer?
10:29:19 <b_jonas> Eduard_Munteanu: there's at least half a semester of lattice theory I think
10:29:30 <monochrom> mathematicians' topology also focus on Hausdorff spaces, whereas the topologies you need for programming languages are not Hausdorff. so mathematicians' topology books are of little help except for the first chapter
10:29:44 <roconnor> Eduard_Munteanu: unfortunately most topology is about Hausdorff spaces, and these DCPOs are usually not Hausdorff.
10:29:50 <roconnor> gah
10:29:54 <roconnor> monochrom beat me
10:29:54 <monochrom> hahaha
10:30:04 <tac-tics> monochrom: Oh good. I really felt I understood the *first* chapter in my topology book :D
10:30:07 <tgeeky> roconnor: no, and that seems irresponsible to me. :o
10:30:09 <tac-tics> The rest not so much...
10:30:13 <monochrom> you can just go photocopy chapter 1 :)
10:30:17 <Eduard_Munteanu> That's nice for analysis though.
10:30:26 <tac-tics> I still don't "get" compactness
10:30:27 <tswett> roconnor: when you say (Integer -> Bool) -> Bool, is -> giving us only the continuous functions?
10:30:30 <roconnor> tgeeky: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:30:34 <roconnor> tswett: of course ;)
10:30:48 <tswett> Since, you know, beth_2 and beth_0 are not exactly equal.  :)
10:30:59 <tgeeky> roconnor: hehe, I'm glad I used the word 'irresponsible' instead of 'impossible'
10:31:13 * monochrom is more interested in babe_2 and babe_0 XD
10:31:33 <monochrom> hehe irresponsible
10:31:39 * Eduard_Munteanu thought programmers were more likely to be interested in C3POs :P
10:32:22 <roconnor> In some sense it is probably best to simply borrow the termonology from topology but give it approprate definitions in the CPOs that we deal with rather than using that traditional topological definitions.
10:32:43 <ciaranm> why on earth would you want to borrow terminology from topologists?
10:32:46 <roconnor> so forget about open sets for defining continouous and simply think about accending chains
10:32:58 <rwbarton> algebraic geometry uses spaces which are very similar to the ones coming from CPOs
10:33:06 <monochrom> yeah, this is why I just write f(lim i. x i) = lim i. f(x i) and screw all those open sets
10:33:14 <roconnor> ciaranm: fine, let's make up our own termonology so that everything feels warm and fuzzy :)
10:33:19 <monochrom> and moreover s/lim/sup/
10:33:21 <ciaranm> at least half of the difficulty of topology is that the names they use for things are utterly stupid
10:33:38 <tac-tics> ciaranm: That's how I feel about category theory >__>
10:33:41 <b_jonas> ciaranm: no, that's the problem with _stochastics_, not topology
10:33:42 <roconnor> what should we call compact types?
10:33:48 <b_jonas> whoa
10:33:59 <monochrom> (even when in real analysis, I prefer sup and inf to epsilon-delta anyway)
10:34:20 <Eduard_Munteanu> Wait, how do you use sup/inf there?
10:34:27 <Eduard_Munteanu> For, e.g., continuity?
10:34:28 <tac-tics> Bitches don't know 'bout my catamorphisms
10:34:36 <monochrom> oh haha you may like the youtube video about hitler hating the names "open" and "closed" :)
10:34:47 <ciaranm> monochrom: indeed
10:35:03 <monochrom> f(sup i. x i) = sup i. f(x i)
10:35:25 <tswett> monochrom: is that the same Hitler video used for everything else?
10:35:30 <monochrom> yes!
10:35:40 <ciaranm> it's one of the better downfall parodies i've seen
10:35:49 <tommd> preflex: seen tmorris
10:35:49 <ciaranm> "it's not your fault, you barely know any topology"
10:35:49 <preflex>  Sorry, I haven't seen tmorris
10:36:05 <tswett> Where there are a bunch of guys in the room, and Hitler asks most of them to leave, and then he gets really angry, and then all sad...
10:36:10 <Eduard_Munteanu> monochrom: would that imply / be equivalent to delta-epsilon continuity for real analysis?
10:36:33 <Eduard_Munteanu> Or at least involved in defining it?
10:36:43 <rwbarton> if you have that axiom for both sup and inf then yes
10:36:55 <azaq23> My Fuehrer, we call a set that is both open and closed a clopen set.
10:36:56 <Eduard_Munteanu> Hm, interesting.
10:37:07 <rwbarton> however it breaks down as soon as you want to do anything else whatsoever
10:37:13 <rwbarton> like analysis on R^2
10:37:31 <ciaranm> i have a book that has all the different equivalent definitions in a nice pretty table for that kind of thing... trying to remember which one it is
10:37:32 <monochrom> I wouldn't relate to epsilon-delta. epsilon-delta requires metric space. we so don't have metric space for programming languages
10:37:48 <tgeeky> roconnor: My intuition says this this is a more specific example than the isomorphism you stated. Doesn't this article depend on specificially using base binary?
10:38:01 <Eduard_Munteanu> monochrom: ah no, you said you preferred that even in the context of real analysis.
10:38:02 <ciaranm> there are at least a dozen completely different looking equivalent definitions of continuity
10:38:17 <monochrom> if you relate to "f^-1 maps open to open" and you keep hacking on what is "open" you'll have it, but I wouldn't bother with that either
10:38:41 <roconnor> tgeeky: (Integer -> Bool) is kinda like base binary
10:38:53 <mauke> http://abstrusegoose.com/394
10:38:55 <tgeeky> roconnor: yes, but then you do (that) -> Bool
10:39:01 <tgeeky> so you're fanning into binary and then back out?
10:39:03 <monochrom> no, I said in real analysis I still prefer inf sup
10:39:09 <Eduard_Munteanu> rwbarton: it does? I would've guessed there's a sensible extension to higher dimensional metric spaces
10:39:29 <roconnor> (Nat -> Bool) is iso to Stream Bool
10:39:34 <roconnor> and Integer and Nat are iso
10:39:44 <roconnor> so (Integer -> Bool) is iso to Stream Bool
10:40:21 <tac-tics> What do you mean by iso here?
10:40:27 <hpc> isomorphic
10:40:33 <Eduard_Munteanu> BTW, I always wondered why the CT limit arrow goes left :/
10:40:36 <tac-tics> what does he mean by isomorphic though
10:40:38 <obiwahn> implies strictness continuity?
10:40:48 <ciaranm> tac-tics: equivalent up to isomorphism, obviously
10:40:55 <Eduard_Munteanu> (and colimit right)
10:41:09 <hpc> tac-tics: probably a broken explanation, but two sets are isomorphic if there exists a bijection between them
10:41:20 <monochrom> but if you want to know more: limsup = inf of (sup of something), liminf = sup of (inf of something), lim is when limsup=liminf. no balls.
10:41:33 <tac-tics> ciaranm: I'm going to in-place update your face so it is isomorphic to the complement of my fist
10:41:40 <ian_mi> hpc: so only the same cardinality?
10:41:42 <ciaranm> hpc: careful. that only holds for sets, not for other categories
10:41:42 <Eduard_Munteanu> Yeah, I know about lim sup and lim inf.
10:41:46 <roconnor> tac-tics: we can go from Stream to Nat -> Bool by the (!!) function
10:41:50 <obiwahn> other way then it works
10:41:58 <tac-tics> hpc: yeah. But any infinite data structure is isomorphic to any other in that sense
10:41:59 <hpc> ciaranm: yeah, i don't know the more general definition
10:42:08 <monochrom> but limsup and liminf is just for real analysis
10:42:23 <roconnor> tac-tics: and we can go from Nat -> Bool to Stream Bool by foo f = f 0 :: foo (f . pred)
10:42:44 <Eduard_Munteanu> That's used pretty much regularly to define pointwise vs uniform continuity and such
10:42:47 <ian_mi> tac-tics: wouldn't Integer not be isomorphic to [Bool]?
10:42:57 <Eduard_Munteanu> And similar contexts.
10:43:06 <erus`> is anyone working on a mini haskell compiler/interpreter ?
10:43:35 <ciaranm> f : A -> B is iso if exists g : B -> A such that g o f = 1_A and f o g = 1_B, and A and B are iso if such an f exists
10:43:58 <hpc> ciaranm: that's the general definition?
10:44:03 <hpc> shiny
10:44:05 <ciaranm> hpc: that's the category theory definition
10:45:08 <ciaranm> you've got to be careful because in, say, Posets, bijective functions aren't necessarily iso
10:45:13 <monochrom> "isomorphic" is an ad-hoc-polymorphic thing
10:45:33 <roconnor> monochrom: if you say naturally isomorphic it is less ad-hoc
10:45:36 <Eduard_Munteanu> Yeah, in Set you can just say monic + epic.
10:45:40 <monochrom> i.e., group-isomorphic? order-isomorphic?
10:46:25 <roconnor> isomorphisms depend on the category being used, yes.
10:46:47 <tgeeky> roconnor: interesting. thanks for the pointer.
10:47:08 <roconnor> so while I might say Nat and (Nat -> Bool) -> Bool are isomorphic, Cale might disagree since we are working in different categories.
10:47:29 <monochrom> @quote monochrom polymorphic
10:47:29 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
10:48:07 <Eduard_Munteanu> Erm, s/continuity/convergence/ above
10:52:47 <Peaker> monochrom: superman vs. batman?
10:53:23 <monochrom> haha
10:53:24 <Eduard_Munteanu> They're isomorphic.
10:53:31 <hpc> Peaker: not a pointless debate! ;)
10:54:23 <Eduard_Munteanu> Or you can go isomorphic up to isomorphism :P
10:54:47 <Eduard_Munteanu> (no kidding, that's actually used)
10:56:52 <roconnor> Eduard_Munteanu: presumably this type of thing will become natural when homotopy type theory becomes the new foundations.
10:57:41 <roconnor> I had a dream about homotopy type theory last night.  This is not a healthy sign.
10:57:44 <ciaranm> finding foundations is an exercise in picking something perverse enough that it takes a hundred years for people to figure out how horribly full of holes it is
10:57:57 <pierrechc> hi, did anyone manage to install the latest Hmatrix on OS X ?
10:58:07 <roconnor> ciaranm: I think that is becoming less true
10:58:19 <ciaranm> roconnor: oh yeah? prove that your foundations are sound!
10:58:37 <roconnor> oh those sorts of holes
10:58:51 <rostayob> @pl \x y -> App x (genUnQual y)
10:58:51 <lambdabot> (. genUnQual) . App
10:58:59 * zachk now knows why godel died from starvation 
10:59:19 <kmc> because he was paranoid and thought everyone was trying to poison him?
10:59:38 <Eduard_Munteanu> BTW, is there any decent (read easy) intro to HTT?
10:59:44 <arcatan> a reasonable assumption
11:00:05 <roconnor> HTT?
11:00:14 <Eduard_Munteanu> roconnor: Homotopy Type Theory
11:00:25 <obiwahn> he could not decide to eat?
11:00:26 * Eduard_Munteanu has seen that abbrev flying around
11:01:20 <monochrom> "unique up to unique (ismorphism up to isomorphism)"
11:01:48 <byorgey> Eduard_Munteanu: Bob Harper's introductory blog posts are a good place to start, I think, beginning here: http://existentialtype.wordpress.com/2011/05/30/higher-dimensional-type-theory/
11:02:02 <byorgey> not that I am by any means an expert.
11:02:04 <ciaranm> are there any decent books on type theory?
11:02:25 <roconnor> ciaranm: I learned everything from TTFP
11:02:28 <roconnor> @where TTFP
11:02:28 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
11:02:31 <ciaranm> ta
11:02:37 <Eduard_Munteanu> byorgey: thanks
11:10:20 <hpaste> int80_h pasted “forkIO and signal handlers” at http://hpaste.org/51157
11:11:15 <roconnor> I wonder why homotopy type theory wouldn't have quotients
11:11:40 <obiwahn> continuous -> monotone + f (lub S) `less defined` lub (f S)
11:13:29 <incluye> > 1
11:13:32 <lambdabot>   1
11:13:55 <incluye> > let filterFirst g (x:xs) = if (g x) then xs else x:filterFirst g xs
11:13:56 <lambdabot>   not an expression: `let filterFirst g (x:xs) = if (g x) then xs else x:filt...
11:14:51 <incluye> > let filterFirstNot g (x:xs) = if (g x) then xs else x:filterFirst g xs in filterFirstNot (==3) [1,2,3,2,3,3,4]
11:14:51 <lambdabot>   Not in scope: `filterFirst'
11:14:52 <incluye> > let filterFirstNot g (x:xs) = if (g x) then xs else x:filterFirstNot g xs in filterFirstNot (==3) [1,2,3,2,3,3,4]
11:14:52 <lambdabot>   [1,2,2,3,3,4]
11:14:52 <incluye> maybe ghci would be a better decision for this
11:16:52 <kostas> incluye, it's ok, keep spaming
11:17:49 <incluye> kostas: will do
11:18:06 <kostas> maybe I'll learn something
11:23:40 <brisingr> any good comonad tutorials?
11:23:40 <brisingr> can't seem to find anything promising on good ol' google
11:24:15 * roconnor should write a comonad tutorial
11:24:47 <elliott> comonads are like conuclear waste
11:25:01 <tac-tics> roconnor: What the balls is a comonad?
11:25:16 <tac-tics> and I swear if you answer that it's the dual of a monad, I'll costab you in the face
11:25:17 <Peaker> > let filterFirst f = uncurry (++) . second (drop 1) . break f   in filterFirst (==3) [1,2,3,1,2,3]
11:25:18 <brisingr> (I can imagine what a comonad is from its name)
11:25:19 <lambdabot>   [1,2,1,2,3]
11:25:28 * osfameron has forgotten what "co-" means.. :-(
11:25:32 <Eduard_Munteanu> brisingr: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
11:25:50 <brisingr> thanks
11:26:13 <roconnor> tac-tics: if a monad is like a tree where you can substute trees into the leaves, then a comonad is a tree with values on each node of the tree that you can redecorate.
11:26:57 <Eduard_Munteanu> tac-tics: a simple example is a zipper
11:27:04 <Peaker> tac-tics: if you define Pointed as:  pure :: a -> m a,   Functor as fmap,  Join as:  m (m a) -> m a       Monad is (Pointed, Functor, Join).         Then you have: Copointed:  extract :: w a -> a    Functor is still Functor,  Duplicate:  duplicate :: m a -> m (m a)     and CoMonad is (Copointed, Functor, Duplicate)
11:27:43 <Peaker> last m's should have been w's
11:27:57 <copumpkin> eww Pointed
11:28:10 <irql> mmm
11:28:11 <roconnor> basically a comonad is a christmas tree that you are never statified with and you keep changing the decorations.
11:28:23 <brisingr> hmm
11:28:31 <shachaf> Do comonads correspond to "comonoids" of some sort?
11:28:32 * roconnor thinks that makes a fine terrible analogy
11:28:35 <tac-tics> roconnor: but you can duplicate the ornimaents and smash them to get whatever's inside?
11:28:38 <rwbarton> is this the burrito analogy of comonads
11:28:54 <tac-tics> is there a co-continuation?
11:29:06 <irql> convince me to learn haskell
11:29:08 <Eduard_Munteanu> I think edwardk said Cont = Cocont but I'm not sure.
11:29:11 <Peaker> how are the monad laws expressed in terms of return,fmap,join?
11:29:23 <irql> give me reason
11:29:23 <roconnor> tac-tics: ah, the duplicate commonad of a comonad takes the tree and decorates them with mini chirsmass tress looking like the part of the tree that was hanging below that node.
11:29:30 <shachaf> Peaker: Similar to the monoid laws.
11:29:34 <osfameron> tac-tics: surely that's a "ntinuation"?
11:29:41 <Peaker> @type liftM join
11:29:42 <brisingr> so a comonad is a monad in the opposite category
11:29:42 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => m1 (m (m a)) -> m1 (m a)
11:29:44 <rwbarton> it's easiest to start by writing down the types that the two sides of the laws have
11:29:44 <tac-tics>  osfameron lol
11:29:54 <shachaf> join . join === join . fmap join
11:29:55 <Peaker> @type join . liftM join
11:29:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
11:30:04 <Peaker> shachaf: ah, I figured that...
11:30:16 <rwbarton> m (m (m a)) -> m (m a) -> m a for associativity and m a -> m (m a) -> m a for the unit axioms
11:30:20 <Peaker> shachaf: that's associativity.. then you have:  join . return = join, and return . join = join ?
11:30:20 <brisingr> stupid question: can I write a Comaybe? why or why not
11:30:24 <roconnor> irql: you like to capture invariants of you data structures with types and you like to reason equationally about your programs.
11:30:40 <rwbarton> and in each case there are two ways to write the first arrow, but they become equal after composing with join
11:30:57 <Eduard_Munteanu> brisingr: what do you do with coreturn Nothing?
11:31:11 <byorgey> Peaker: not quite, join . return = join . fmap return = id
11:31:14 <irql> roconnor: but the syntax does not inspire me
11:31:25 <brisingr> Eduard_Munteanu: right, of course
11:31:36 <Peaker> @type join . return
11:31:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
11:31:45 <roconnor> tac-tics: ya, the co-continutation comonad is in the opposite category of haskell, so when you flip all the arrows back you see that you get the continuation monad back
11:31:59 <roconnor> irql: really?
11:31:59 <Peaker> @type return . join
11:32:01 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a. (Monad m, Monad m1) => m1 (m1 a) -> m (m1 a)
11:32:10 <roconnor> irql: I like the 2-d layout
11:32:10 <byorgey> Peaker: those are left and right identity laws for return
11:32:19 <benmachine> roconnor: the ntinuation monad?
11:32:21 <brisingr> @hoogle comonad
11:32:22 <lambdabot> No results found
11:32:25 <benmachine> *comonad
11:32:25 <roconnor> irql: pattern matching makes equational reasoning a bit more natural.
11:32:32 <Peaker> byorgey: I don't understand,  is it not true that join . return = return . join?
11:32:33 <roconnor> benmachine: :D
11:32:41 <shachaf> Peaker: return . join /= id, of course.
11:32:45 <byorgey> Peaker: no, it isn't
11:32:57 <Peaker> oh, too much reliance on the types on my part :-)
11:32:58 <byorgey> > return . join $ [[1,2,3], [4,5,6]]
11:32:59 <lambdabot>   No instance for (GHC.Show.Show (m [a]))
11:33:00 <lambdabot>    arising from a use of `M45983266...
11:33:08 <shachaf> > return . join $ [[1,2],[3,4]] :: [[Int]]
11:33:10 <lambdabot>   [[1,2,3,4]]
11:33:13 <irql> roconnor: is good "only" for math programs?
11:33:27 <Eduard_Munteanu> brisingr: basic definitions are here... http://hackage.haskell.org/package/comonad-1.1.1.1
11:33:30 <byorgey> > join . return $ [[1,2],[3,4]] :: [[Int]]
11:33:32 <lambdabot>   [[1,2],[3,4]]
11:33:38 <byorgey> > join . fmap return $ [[1,2],[3,4]] :: [[Int]]
11:33:39 <lambdabot>   [[1,2],[3,4]]
11:33:53 <roconnor> irql: good for any program where you want to capture invariants in data types.
11:34:09 <irql> roconnor: Scheme syntax as I prefer
11:34:09 <Eduard_Munteanu> You can also look at the other packages by edwardk... http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=comonad
11:34:13 <byorgey> oh, well, actually, you can just use a simple list for those
11:34:21 <byorgey> > join . return $ [1,2,3] :: [Int]
11:34:23 <lambdabot>   [1,2,3]
11:34:27 <irql> roconnor: in the field of functional languages
11:34:31 <roconnor> irql: ah, well, you can write everything prefix if you really like it that way.
11:34:45 <Eduard_Munteanu> Peaker: you can't join an (m a) for example
11:35:07 <Eduard_Munteanu> > concat [1,2,3,4]
11:35:09 <lambdabot>   No instance for (GHC.Num.Num [a])
11:35:09 <lambdabot>    arising from a use of `e_11234' at <in...
11:35:10 <shachaf> Monads are just like IRC channels, really.
11:35:23 <shachaf> instance Monad Channel where join = ...
11:35:28 <roconnor> irql: but pattern matching is nicer and safer than using projection functions everywhere to decompose your data.
11:36:26 <_Ray_> xD
11:36:56 * Eduard_Munteanu remembers experimenting with a co-do notation, but he didn't find much meaning in that
11:37:01 <shachaf> roconnor: "projection functions" are things like head/tail/null?
11:37:14 <Peaker> I think it could be interesting if Haskell had numeric names for the monad-hierarchy classes:  class Lift0 m where lift0 :: a -> m a ;  class Lift1 m where lift1 :: (a -> b) -> m a -> m b ; class Lift2 m where lift2 :: (a -> b -> c) -> m a -> m b -> m c ; default impls for lift3..someN, <*>.    A Join class too. Then, maybe an Applicative class alias for 0,1,2.  Monad alias for 0,1,2,Join.  Functor alias for 1(?)
11:37:27 <roconnor> shachaf: things like car and cdr
11:37:46 <roconnor> shachaf: You can think of head and tail as projection functions too
11:37:47 <Peaker> Pointed alias for 0
11:37:58 <irql> roconnor: i have a sticker of haskell, with a purple monster with a guitar :/
11:38:01 <roconnor> shachaf: null isn't
11:38:06 <shachaf> roconnor: Things like foldr/maybe are as safe as pattern matching (if not as nice, sometimes).
11:38:17 <roconnor> irql: is the monster fuzzy?
11:38:30 <roconnor> shachaf: yes
11:38:34 <Peaker> maybe it could make the relationships between classes more apparent
11:38:39 <Eduard_Munteanu> Monads are fuzzy fluffy things.
11:39:09 <irql> robbert: so so
11:39:11 <erus`> someone described monands as a space suit
11:39:14 <erus`> :)
11:39:15 <benmachine> Eduard_Munteanu: I tried to come up with a sensible codo but I can't see how it would work
11:39:20 <roconnor> erus`: http://telofy.soup.io/post/23797479/Think-of-a-monad-as-a-spacesuit
11:39:43 * shachaf wonders if there's a one-level foldr, i.e. \z c l -> case l of [] -> z; (x:xs) -> c x xs
11:39:46 <shachaf> @ty \z c l -> case l of [] -> z; (x:xs) -> c x xs
11:39:47 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
11:40:02 <Eduard_Munteanu> benmachine: yeah, one problem is you already need a 'w a' value to begin with, though you can have a run<Comonad> function
11:40:04 <benmachine> shachaf: I've had a use for that in the past, but there isn't a standard one
11:40:09 <shachaf> @hoogle a -> (b -> [b] -> a) -> [b] -> a
11:40:10 <lambdabot> No results found
11:40:30 <Eduard_Munteanu> By analogy, for comonads it's "unsafe" to put stuff into them.
11:40:55 <Eduard_Munteanu> Just as it's "unsafe" to extract stuff from monads.
11:41:23 <brisingr> whoa whoa
11:41:24 * shachaf suspects that considering comonads to "have stuff in them" is as unhelpful as considering monads to "have stuff in them".
11:41:43 <Eduard_Munteanu> Yeah, it kinda is.
11:42:18 <shachaf> Eduard_Munteanu: What's an example of a comonad that doesn't have a total function :: a -> w a? :-)
11:42:32 <brisingr> so so
11:42:41 <brisingr> the powerset of [1..] is a comonad?
11:43:08 <rwbarton> "the powerset of [1..]" doesn't appear to have kind * -> *
11:43:19 <Eduard_Munteanu> shachaf: Void :P. No, I don't mean that, but there's no way you can "put stuff into it" without having knowledge of its inner workings.
11:44:47 <dafis> Nice to be back on a sensible OS :D
11:44:48 <rwbarton> but maybe I'm missing some context where a statement like this is sensible
11:44:57 <Eduard_Munteanu> _^[1..] could be.
11:45:01 <roconnor> typically you will have to put lots of a's into a w to make a (w a)
11:45:21 <Eduard_Munteanu> That too.
11:45:29 <roconnor> rwbarton: I'm missing the context too
11:45:34 <brisingr> hmm so I don't seem to get it
11:45:51 <Eduard_Munteanu> brisingr: a (co)monad requires a functor
11:46:04 <shachaf> roconnor: Fortunately I have a handy function repeat :: a -> [a]. :-)
11:46:05 <brisingr> right, right
11:46:21 <roconnor> shachaf: that's true you can put the same a in a lot of times
11:53:37 <brisingr> still confused
11:54:37 <Eduard_Munteanu> brisingr: why?
11:54:44 <Eduard_Munteanu> I mean, in what way?
11:55:29 <brisingr> hmm
11:55:35 <brisingr> practical examples
11:55:41 <Eduard_Munteanu> brisingr: just like a monad is a functor T : C -> C with two natural transformations, a comonad is a functor too
11:55:52 <Eduard_Munteanu> Zippers.
11:56:08 <Eduard_Munteanu> It's actually really similar to the cellular automata thingy, as sigfpe remarks there.
11:56:19 <brisingr> hmm
11:57:05 <brisingr> oh oh got it
11:57:12 <brisingr> it's like a pointer isn't it?
11:57:26 <brisingr> coreturn (whole stuff) = pointer
11:57:52 <Eduard_Munteanu> coreturn gives you the thing in focus, when a zipper is a list with a focus
11:59:09 <roconnor> a tree with data hanging at all internal nodes is a good example of a comonad
11:59:29 <roconnor> coreturn (aka extract) pulls the fruit off the root of the tree.
11:59:42 <brisingr> cojoin?
12:00:02 <Eduard_Munteanu> The dual of join... cojoin :: w a -> w (w a)
12:00:09 <Eduard_Munteanu> Also known as duplicate.
12:00:23 <hpc> :t duplicate
12:00:24 <lambdabot> Not in scope: `duplicate'
12:00:27 <Eduard_Munteanu> (well probably just in Haskell and FP papers)
12:00:32 <hpc> ah
12:00:32 <roconnor> brisingr: cojoin makes a new tree decorated by mini trees forms by the branches pruned from the original tree at that node.
12:00:55 <roconnor> so if (A <- B -> C) is our tree
12:01:03 <roconnor> the the cojoin (aka dupicate) of this tree is
12:01:04 <Eduard_Munteanu> In a cellular automata, cojoin replaces each cell with the whole thing again.
12:01:18 <roconnor> (A) <- (A <- B -> C) -> (C)
12:01:31 * roconnor isn't sure that is a good illustration
12:01:32 <brisingr> so cojoin in a zipper
12:01:34 <hpc> roconnor: ooh, that's a good visual
12:01:49 <Eduard_Munteanu> Then you map a computation over each such cell made up of a copy of the "universe", and coreturn the element in focus.
12:01:55 <zong_sharo> i do read sigfpe's post on comonadic celluar automations, but i still don't "get" comonads completely
12:02:15 <zong_sharo> what else i can read about comonads?
12:02:27 <Eduard_Munteanu> This lets you compute the transformation for each cell in isolation.
12:02:36 <roconnor> brisingr: cojoin in a zipper makes a new zipper of zippers where each spot of the zipper is a copy of the orignal zipper focused at that spot.
12:02:38 <Eduard_Munteanu> (since you operate on a copy)
12:03:16 <brisingr> so so
12:03:26 <roconnor> *refouced at that spot.
12:03:31 <roconnor> *refocused
12:03:54 <brisingr> say a zipper <a b C d> where capital is focus
12:04:09 <roconnor> so if (AB[C]D) is our oringinal zipper then ..
12:04:20 <ziman> non-strictness seems to be essential here, doesn't it?
12:04:27 <brisingr> cojoin <a b C d> = <<A b c d> <a B c d> <a b C d> <a b c D>> with <a b C d> in focus
12:04:28 <Eduard_Munteanu> ziman: sure
12:04:45 <Eduard_Munteanu> brisingr: yeah
12:04:46 <roconnor> ([A]BCD)(A[B]CD)[(AB[C]D)](ABC[D])  is the cojoin
12:04:59 <brisingr> cool
12:05:00 <roconnor> brisingr: you got it
12:05:13 <brisingr> w00t
12:05:26 <roconnor> now for coalgebras of comonads
12:05:31 <brisingr> thanks, once again
12:05:38 <brisingr> whoa, there's more?
12:05:39 <roconnor> :P
12:05:44 <roconnor> nah, I'll stop for now
12:05:48 * Eduard_Munteanu would want to hear about that too
12:05:57 <ziman> Eduard_Munteanu, I mean, in comonads in general, as opposed to different kinds of monadic stuff that can be implemented reasonably in strict languages.
12:06:02 <roconnor> no one actually knows what a coalgebra for a comonad is.
12:06:10 <hpc> roconnor: no one?
12:06:19 <roconnor> hpc: well Jeremy Gibbons doesn't.
12:06:23 <hpc> lol
12:06:35 <Eduard_Munteanu> ziman: hm, I don't know, but I assume just like you have strict monads, you also have strict comonads
12:07:06 <Eduard_Munteanu> Algebras for monads seem quite intuitive, but for comonads... :/
12:07:38 <roconnor> Eduard_Munteanu: that seems to be the problem
12:07:53 <zong_sharo> other insightful reading on comonads people should know about?
12:07:59 <roconnor> brisingr: I just like coalgebras for comonads because lenses are coalgebras for the store comonad.
12:09:04 <brisingr> roconnor: uhh
12:09:23 <roconnor> worries that brisingr isn't familiar with 3 out of 4 of those words
12:09:28 <hpc> the store comonad is like State?
12:09:36 <roconnor> hpc: it is related to state
12:09:41 <brisingr> heard of lenses
12:09:49 <brisingr> actually tried to read about them, but didn't understand
12:09:56 <roconnor> data Store i a = Store (i -> a) i
12:10:23 <roconnor> I think lenses are extremely important and overlooked ... but that is maybe because I've been studying them lately.
12:11:00 <roconnor> hpc: most people call the store comonad the costate comonad
12:11:15 <roconnor> I'm trying to make costate a bit more warm and fuzzy
12:11:28 <ziman> cowarm and cofuzzy?
12:11:33 <roconnor> yep
12:11:48 <mokus> no, cofuzzy and cowarm ;)
12:11:59 <roconnor> brisingr: conceptually a lens is just a pair of a getter and a setter function for a field of a record
12:12:15 <roconnor> mokus: cwarm or cofuzzy
12:12:19 <roconnor> *cowarm
12:12:28 <mokus> roconnor: oh yea, thanks ;)
12:12:34 <brisingr> roconnor: with a "focus"?
12:12:49 <roconnor> brisingr: not really
12:12:55 <brisingr> but they're lenses:(
12:13:15 <roconnor> lenses are used to focus in on a field of a record in the state monad
12:13:27 <brisingr> :)
12:13:37 <roconnor> focus :: Lens r f -> State f a -> State r a
12:13:54 <roconnor> so if you have some State f a thing that operates on a field of some larger record
12:14:27 <roconnor> if you have a lense you can lift taht state operation to one that operates on that field of a the whole record
12:14:56 <jsternberg1> I'm trying to learn haskell, and I'm making a program that needs to parse a file
12:15:29 <jsternberg1> I'm currently keeping the context of the state of what the parser has found in a data type that's using record syntax
12:15:31 <monochrom> would it be too ambitious? would the file be too hard to parse?
12:15:38 <jsternberg1> no, I can parse it
12:15:57 <jsternberg1> but right now, I'm using record syntax and I need to also add a list of ex. source files
12:16:07 <jsternberg1> right now, I've got something like
12:16:19 <jsternberg1> data Context = Context { ... bunch of state ... }
12:16:31 <jsternberg1> and to add a source file, I wrote a function that would take the old context
12:16:43 <jsternberg1> and just modify the source files, then return the new type
12:17:07 <jsternberg1> unfortunately, this is long (about 5 lines) and I have to do this for each parameter
12:17:16 <jsternberg1> and when I add new ones, it's a pain in the ass (I have to change each one of these)
12:17:20 <jsternberg1> is there an easier way to do this?
12:17:30 <zong_sharo> jsternberg1: mind paste a code?
12:17:52 <jsternberg1> yea, hold on
12:17:57 <Eduard_Munteanu> @where hpaste
12:17:57 <lambdabot> http://hpaste.org/
12:18:07 <jsternberg1> exactly what I was looking for
12:19:03 <hpaste> jsternberg pasted “file parser” at http://hpaste.org/51159
12:19:19 <jsternberg1> that's the relevant section, imagine lines 11-17 repeated for each one of the Context parameters
12:20:05 <jsternberg1> I'm also not sure how efficient this is, I know clojure uses persistent data structures that make something like this not very expensive, but I don't know enough about haskell to know about what it does
12:20:44 <nooodl> i think floating point numbers are being weird here. http://hpaste.org/51160
12:20:47 <rwbarton> for the last line you can write "addSource ctx src = ctx { sourceFiles = src : sourceFiles ctx }", using record update syntax
12:21:22 <monochrom> I don't see why you have to repeat lines 11-17
12:21:31 <rwbarton> although I'm sure roconnor will be happy to tell you how you can write even shorter code using lenses!
12:21:49 <zong_sharo> jsternberg1: ctx { sourceFiles = src : sourceFiles ctx, libraries = libraries ctx , ...} - so you can only alter revelant fields of structure, no need for contextType = contextType ctx
12:22:00 <dafis> nooodl: well, 150.50 is exactly representable, 25.60 not
12:22:12 <jsternberg1> cool, didn't know that (I've been learning out of "Learn You a Haskell For Great Good" where I didn't see anything about that)
12:22:15 <rwbarton> and what you're doing copies about 5 pointers, so it is reasonably efficient but would not be if you had, say, hundreds of fields
12:22:30 <roconnor> ya, record update syntax will make jsternberg1's life much better
12:22:32 <nooodl> dafis, can i somehow make comparisons a bit more tolerant?
12:22:45 * hackagebot tau 6.28 - Tau, the ratio between any circle's circumference  and radius.  http://hackage.haskell.org/package/tau-6.28 (BrentYorgey)
12:22:54 <roconnor> nooodl: use fixedfloat
12:23:05 <roconnor> nooodl: from Data.Fixed
12:23:12 <Eduard_Munteanu> byorgey: no really, what's that?
12:23:20 <dafis> nooodl: use Rational
12:23:35 <nooodl> Eduard_Munteanu, http://tauday.com/ this?
12:23:57 <Eduard_Munteanu> Hah.
12:24:00 <zong_sharo> jsternberg1: but, because you update most of the fields, and because haskell's records syntax is quite restrictive - you may benefit from lenses or whatnot
12:24:01 <byorgey> Eduard_Munteanu: just a little package defining tau, you know, for when you need tau =)
12:24:07 <erus`> is Dynamic really slow?
12:24:27 <monochrom> I haven't heard of Dynamic being slow
12:24:34 <jsternberg1> I'll take a look at it
12:24:49 <jsternberg1> thanks, I thought I was missing something really simple
12:24:53 <zong_sharo> jsternberg1: ouch, sry - i'm actually overlooked this, you only update one field at a time
12:25:00 <zong_sharo> my bad
12:25:15 <Eduard_Munteanu> Heh, 6.28
12:25:22 <zong_sharo> then foo { bar = f (bar foo) } record update will do the trick for you
12:25:27 <byorgey> Eduard_Munteanu: =)
12:25:45 <byorgey> Eduard_Munteanu: if I update the package I will just add more significant digits to the version number
12:26:08 <Eduard_Munteanu> Ah, the TeX way
12:26:47 <byorgey> indeed
12:43:51 <parcs> byorgey: you might as well define τ noo
12:43:53 <parcs> too
12:44:17 <byorgey> parcs: my terminal doesn't support unicode, which character is that?
12:45:56 <parcs> tau
12:46:03 <parcs> lowercase
12:46:46 <parcs> if you're going to pretentiously use tau over 2*pi you might as well use the actual symbol :P
12:48:37 <byorgey> parcs: oh, hehe, I see
12:49:03 <byorgey> parcs: hmm, would that require enabling any extensions?
12:49:33 <roconnor> byorgey: I don't think so
12:49:42 <byorgey> neat
12:49:50 <parcs> @let τ = 2*pi
12:49:52 <lambdabot>  Defined.
12:49:59 <parcs> > τ
12:50:01 <lambdabot>   6.283185307179586
12:50:01 <koeien> no, there is UnicodeSyntax but I think that only refers to using the forall sign instead of "forall" and so on
12:50:10 <byorgey> ah, right, that's what I was thinking of
12:52:30 <parcs> :t τ
12:52:31 <lambdabot> <no location info>: not an expression: `'
12:53:02 <Eelis> parcs: what would you say it is that tau users pretend?
12:53:03 <elliott> :t does not do unicode.
12:53:04 <lambdabot> parse error on input `do'
12:53:15 <elliott> Eelis: wat?
12:53:30 <tgeeky> really? that's a huge bummer.
12:53:30 <elliott> parcs said pretentiously, not pretend...iously
12:53:33 <Eelis> elliott: he called them pretentious :)
12:53:49 <elliott> Adjective: Attempting to impress by affecting greater importance, talent, culture, etc., than is actually possessed.
12:54:00 <applicative> > let  αβγδεζηθικλμνξοπρστυφχψω = 2*pi in αβγδεζηθικλμνξοπρστυφχψω
12:54:02 <lambdabot>   6.283185307179586
12:54:05 <Eelis> ah, so pretending to have these qualities
12:54:11 <tgeeky> parcs: actually, there is a valid point in strictly using tau instead of 2*pi
12:54:27 <tgeeky> in a few circumstances
12:55:35 <dafis> saves ink
12:55:48 <Eelis> so i guess in this case he feels that tau users just /pretend/ to value tau for the right reasons and are really just in it for popularity?
12:56:06 <tgeeky> Eelis: something like that, probably.
12:56:17 <Eelis> what a curious idea. oh well :)
12:56:28 <byorgey> ugh, Haddock doesn't support Unicode very well
12:56:46 <tgeeky> byorgey: let's make "haddock 2.0"
12:56:58 <byorgey> it is already at 2.9.2
12:57:05 <tgeeky> hence the quotes, though I didn't know that
12:57:32 <tgeeky> byorgey: haskell documentation with diagrams and unicode built in :o
12:57:36 <byorgey> Haddock works pretty well for the most part, I am not interested in redoing it =)
12:57:57 <byorgey> tgeeky: sounds awesome, but I don't see why we have to start over =)
12:58:39 <parcs> Eelis: unfortunately english isn't as regular as you pretend it is
12:58:53 <tgeeky> parcs: I see what you did there.
12:58:55 <Eelis> hm :(
12:59:14 <luite> does anyone here have a flymake script that works with cabal-dev or cabal?
12:59:46 <luite> (cabal-dev if a cabal-dev dir is found, fallback to cabal if only a .cabal file)
12:59:56 <argiopeweb> Does anyone know GPipe well enough to have an idea why paintColor and its ilk use so much cpu time (in excess of 70% of total application time% according to the profiler)?
13:00:37 <Eelis> parcs: i'm just trying to understand what you meant. i'm not sure how i'd do that "irregularly"
13:01:07 <elliott> Eelis: parcs said that tau users are pretentious in their use of tau. if you know the definition of pretentious, how can this be confusing?
13:02:42 <Eelis> elliott: well, as you can see in the meaning of "pretentious" that you quoted, it leaves open quite a broad spectrum of possible meanings, presumably to be inferred from context. that is what i was attempting to do
13:02:46 * hackagebot tau 6.283 - Tau, the ratio between any circle's circumference  and radius.  http://hackage.haskell.org/package/tau-6.283 (BrentYorgey)
13:03:10 <byorgey> now featuring a unicode symbol for tau
13:03:13 <elliott> what's with the double-space after "circumference"
13:03:17 <elliott> it's not in the .cabal file
13:03:17 <tgeeky> parcs: anyway, there are two uses that I'm aware that using tau might be useful: 1. physical equations where you are being meticulious in tracking of constants (ie, c != h != 1), and 2. infinite product definitions (of pi, in particular)
13:03:25 <byorgey> elliott: good question, I was wondering that myself
13:03:43 <byorgey> elliott: I guess it's because there's a line break there
13:03:51 <erus`> what are apartment prices like near central park?
13:03:53 <elliott> no there isn't
13:03:56 <elliott>                      ratio between any circle's circumference and radius.
13:04:25 <byorgey> elliott: there is in the one I'm looking at
13:04:30 <dylukes> C = 2πr, A = πr^2
13:04:34 * elliott is looking at http://hackage.haskell.org/packages/archive/tau/6.283/tau.cabal
13:04:41 <elliott> which is presumably where hackagebot gets it from
13:04:43 <dylukes> elliott: ratio is 2π (or tau if you prefer), no?
13:04:47 * applicative dimly remembers a post of byorgey in which he is cabalizing a package that boldly 'defines x'
13:04:51 <elliott> not in http://hackage.haskell.org/packages/archive/tau/6.28/tau.cabal either
13:04:55 <elliott> dylukes: eh?
13:05:36 <dylukes> C = πd, C = 2πr, C = tr
13:05:48 <dylukes> t = C / r
13:05:50 <byorgey> elliott: I think you are looking at the Description instead of the Synopsis
13:05:52 <dylukes> :|
13:05:57 <elliott> byorgey: oh, ah
13:06:03 <JoeyA> In GHC, is it possible to handle excessive memory usage by a single thread without disrupting the other threads?
13:06:07 <byorgey> applicative: I don't think that was me, doesn't ring a bell
13:06:15 <JoeyA> (I asked this on StackOverflow too: http://stackoverflow.com/questions/7297654/how-to-cap-memory-usage-of-haskell-threads )
13:06:43 <byorgey> elliott: ah, there was a space after 'circumference' at the end of the line, presumably that's why
13:06:55 <JoeyA> From what I can tell, the answer is no: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
13:06:56 <tgeeky> byorgey: ah, EOLWS!
13:06:56 <elliott> byorgey: heh :)
13:07:02 <JoeyA> "GHC currently does not throw HeapOverflow exceptions."
13:07:05 <dankna> so
13:07:09 <applicative> byorgey: it had to do with cabal init
13:07:26 <dankna> I found what is probably a GHC bug (it gives me a runtime failure claiming it is one and asking me to please report it; the only reason I'm not sure is that my GHC is modified by me :) )
13:07:30 <byorgey> applicative: oh, hm, maybe
13:07:33 <JoeyA> Not only does GHC not support handling memory overflows per-thread, it doesn't really handle it at all.  Is my assessment correct?
13:07:38 <dankna> rather than invest the time to fix it, I wish to work around it with an alternative design
13:07:43 <tgeeky> dankna: report it anyway
13:07:47 <dankna> perhaps if I describe what I am doing, someone can suggest one
13:07:49 <JoeyA> (other than by crashing)
13:07:51 <dankna> you think?  hm
13:07:59 <byorgey> applicative: oh, haha, you're right, http://byorgey.wordpress.com/2010/04/15/cabal-init/
13:08:03 <byorgey> I had forgotten about that =)
13:10:07 <applicative> yes thats it, it was slightly different in my memory like "this is a great package, defines x once and for all"
13:10:12 <tgeeky> byorgey: lies on your blog! package defining tau > package defining x
13:10:26 <tgeeky> applicative: hehe you guys have been working so hard to find x! here it is!
13:10:42 <byorgey> tgeeky: technically, that post did not say it would ALWAYS be the best package ever
13:10:49 <tgeeky> byorgey: true :)
13:10:54 <tgeeky> byorgey: no 'forall t.'
13:13:18 <tgeeky> short survey: how many of us have heard of / dealt with: Holors ( http://en.wikipedia.org/wiki/Holor ) or time scale calculus ( http://en.wikipedia.org/wiki/Time_scale_calculus ) ?
13:15:33 <roconnor> tgeeky: Holour
13:15:52 <tgeeky> roconnor: no, the original paper called it Holor
13:15:56 <byorgey> hehe
13:15:59 <roconnor> :)
13:17:06 <tgeeky> he also introduced 'merates', 'kinetors' and some other jargon  :o
13:17:26 <roconnor> tgeeky: zygotors
13:17:28 <byorgey> oudors
13:17:36 <byorgey> parahomothetors
13:17:39 <rwbarton> certainly every mathematician has dealth with complex numbers, scalars, vectors, matrices, tensors, and quaternions, and I would say that approximately 0 of them have ever heard the term Holor
13:17:43 <roconnor> *lol*
13:18:02 <tgeeky> rwbarton: hehe, at least 1 of them (me) has
13:18:05 <copumpkin> ooh a holor
13:18:17 <tgeeky> rwbarton: and holors are actually generalizations of those things
13:18:31 <copumpkin> rwbarton: I think edwardk is in search of speakers for bostonhaskell!
13:19:38 <rwbarton> copumpkin: hmm, are there dates planned?
13:20:09 <copumpkin> rwbarton: not until he finds people to give talks :)
13:20:14 <byorgey> I have a new theory of zeptoepikatahomoioexoskotors which unifies the study of holors and zygohistomorphic prepromorphisms, just need to find some time to write it up
13:20:14 <copumpkin> you got anything to talk about?
13:20:24 <rwbarton> not off the top of my head
13:20:31 <rwbarton> but possibly I could come up with something
13:20:31 <copumpkin> boo :(
13:20:36 <copumpkin> woo!
13:20:40 <roconnor> copumpkin: byorgey want to talk about his new theory
13:20:44 <roconnor> *wants
13:20:52 <copumpkin> we should fly him to boston
13:21:11 <byorgey> if you fly me to boston I would be happy to talk about zeptoepikatahomoioexoskotors
13:21:44 <acowley> wasn't he a bad guy in He-Man?
13:21:53 <byorgey> LOL
13:22:20 <tgeeky> you're thinking of snuffulufagus. zeptoepikatahomoioexoskotors are a brand of shoes that let you kill Jedi Knights.
13:22:23 <JoeyA> Is Int 64-bit on 64-bit platforms?
13:22:30 <JoeyA> or usually close to?
13:22:37 <byorgey> JoeyA: yes
13:22:49 <byorgey> > maxBound :: Int  -- wonder what lambdabot is running on
13:22:50 <lambdabot>   9223372036854775807
13:22:51 <applicative> > maxBound :: Int
13:22:52 <lambdabot>   9223372036854775807
13:23:02 <JoeyA> Thanks.
13:23:09 <applicative> byorgey beat me :(
13:23:16 <byorgey> > 2^63
13:23:17 <lambdabot>   9223372036854775808
13:23:28 <JoeyA> > 2^63 :: Int
13:23:29 <lambdabot>   -9223372036854775808
13:24:12 <JoeyA> Really, my question is: what is a good type to use in Haskell to represent an amount of memory?
13:24:13 <acowley> > 2^63 - 1 :: Int
13:24:15 <lambdabot>   9223372036854775807
13:24:17 <JoeyA> E.g. the amount of RAM on the computer
13:24:30 <koeien> JoeyA: imo, Integer
13:24:38 <JoeyA> makes sense
13:24:51 <JoeyA> But that'll pull in GMP.
13:24:55 <JoeyA> (if I'm not mistaken)
13:25:06 <JoeyA> Meh, I'll just use Int64.
13:25:13 <dankna> Word64
13:25:13 <byorgey> JoeyA: or Word64?
13:25:14 <koeien> yes, Integer uses GMP in GHC
13:25:15 <koeien> Word64
13:25:31 <koeien> it's unsigned and has useful overflow guarantees, but that's not always an advantage
13:25:32 <byorgey> presumably you don't want negative numbers
13:25:34 <applicative> > maxBound :: Word64
13:25:36 <lambdabot>   18446744073709551615
13:25:48 <applicative> > minBound :: Word64
13:25:49 <lambdabot>   0
13:25:57 <JoeyA> Well, Word64 doesn't exactly guard against negative numbers.  It just overflows and becomes a huge positive number.
13:26:19 <byorgey> > maxBound :: Word64 + 1
13:26:20 <lambdabot>   Could not deduce (GHC.Enum.Bounded
13:26:20 <lambdabot>                      ((+) GHC.Word.Word6...
13:26:26 <koeien> > maxBound+1::Word64
13:26:27 <lambdabot>   0
13:26:35 <JoeyA> minBound - 1 :: Word64
13:26:36 <tgeeky> 0 is a *huge* positive number
13:26:39 <JoeyA> > minBound - 1 :: Word64
13:26:40 <lambdabot>   18446744073709551615
13:26:53 <applicative> > maxBound * maxBound :: Word64
13:26:54 <lambdabot>   1
13:27:13 <acowley> deep
13:27:45 <koeien> acowley: not terribly, Z/2^64Z is a ring
13:27:52 <applicative> > (0-1) * (0-1) :: Word64
13:27:53 <lambdabot>   1
13:28:10 <koeien> a commutative one, even
13:28:39 <acowley> koeien: My depth gauge is very shallow
13:28:46 <roconnor> a Z-algebra even
13:29:06 <elliott> JoeyA: "pull in gmp"?
13:29:22 <elliott> JoeyA: there's integer-simple to avoid gmp. But any ghc compilation pulls in gmp if it's a ghc with gmp.
13:29:35 <elliott> Especially since the standard library uses Integer a lot.
13:29:45 <acowley> Question: I have a test suite in a cabal file. Is there a cabal-install invocation that will get it to download the dependencies of the test suite?
13:30:09 <acowley> "cabal install --enable-tests" did not work
13:32:03 <ttuegel> acowley, what version are you using?
13:32:42 <acowley> ah, right! I'm using cabal-install 0.10.2 with 1.10.1.0 of Cabal
13:33:02 <acowley> but I'm on GHC 7.2.1, so I probably have a semi-janky cabal setup
13:34:50 <ttuegel> acowley, hmm, i thought we fixed that...
13:35:04 <acowley> ttuegel: which part?
13:35:13 <ttuegel> acowley, fetching test deps
13:35:37 <acowley> ttuegel: so cabal install --enable-tests should work? Are my versions too old?
13:36:20 <ttuegel> acowley, you have the latest version, i may be thinking of a development version. i may also be thinking of something i thought i did but never got around to... let me check
13:36:40 <acowley> ttuegel: also contradicting my claimed jankyness status, after manually installing my testing dependencies everything is good
13:36:58 <acowley> ttuegel: if nothing else, consider it a feature request! :)
13:38:24 <ttuegel> acowley, i'll look into it. if it's not in the dev version i'll try to get it working. clearly, 0.10.2 won't do it, so you'll just have to stick with doing deps manuall for now
13:39:17 <rwbarton> copumpkin: actually, there is a topic I've been thinking about some recently and could probably make into a talk--how to model a VCS with category theory
13:39:23 <acowley> ttuegel: btw, in case you're an appropriate recipient, the test-suite support is really excellent!
13:39:28 <luite> if you have multiple conditional cpp-options in a .cabal file, are they combined?
13:39:38 <rwbarton> copumpkin: although my talk might not contain the word "Haskell", I think it still might be of interest
13:40:27 <ttuegel> acowley, thanks! it's very much still a work in progress. it was my gsoc project last year... it probably should have been finished by now... ;)
13:41:09 <acowley> ttuegel: I'm using it with test-framework in a new little project, and it has completely lived up to my hopes
13:41:36 <hpaste> rostayob pasted “templates” at http://hpaste.org/51161
13:41:47 <acowley> copumpkin: I could give a talk about how Coq makes me rather cross sometimes!
13:42:00 <copumpkin> rwbarton: that'd be fun!
13:42:10 <copumpkin> rwbarton: we had spivak give a talk on his categorical databases a while ago
13:42:15 <hpaste> rostayob annotated “templates” with “templates (annotation)” at http://hpaste.org/51161#a51163
13:42:29 <ttuegel> acowley, i'm glad! the eventual goal is to make cabal able to look inside your test suites and see which test cases are failing, and put that info on hackage. obviously we're not there yet :)
13:42:37 <copumpkin> rwbarton: ed typically tries to get a "down to earth" talk and a more theoretical one
13:42:47 * hackagebot cabal-ghci 0.1.1 - Set up ghci with options taken from a .cabal file  http://hackage.haskell.org/package/cabal-ghci-0.1.1 (EtienneLaurin)
13:43:10 <acowley> ttuegel: I'm just grateful that there's now a reasonable way to layout tests in a cabalized project. It had been a real sore point.
13:43:35 <roconnor> @check \a b -> (a <= not b) = not (a && b)
13:43:36 <lambdabot>   Parse error at "=" (column 22)
13:43:39 <roconnor> @check \a b -> (a <= not b) == not (a && b)
13:43:39 <lambdabot>   "OK, passed 500 tests."
13:44:07 <ttuegel> acowley, i've seen some of the gymnastics people went through with flags and conditionals to include their tests... "eww" is all i can say
13:46:25 <rostayob> I am writing a templating system that compiles templates to haskell functions. I have the basic functionality working, this is an example: http://hpaste.org/51161 . The thing is that I'd like to have a way to access fields in a certain object, expecially since I'd like to compile the same templates to JS as well. The problem is that when I write the templates I wat the type to be inferred
13:46:27 <rostayob> automatically, and this makes it difficult to use functions derived from the record syntax, which is what I tought of
13:47:17 <rostayob> But I guess it's impossible to have a type safe data type with named fields right?
14:02:17 <rwbarton> rostayob: Perhaps you could have a type class for each field name you use, e.g. class HasColor a t where getColor :: a -> t, and then use getColor wherever there is a reference to the color field in a template
14:02:44 <rwbarton> With this approach you'd need to define all the type classes you use in a centralized place
14:02:54 <rostayob> rwbarton: this is a solution, but not a practical one I'm afraid
14:03:26 <rwbarton> Hmm, OK. What about it makes it impractical?
14:03:43 <rostayob> rwbarton: the fact that I have to define a type class for each field of each data type
14:03:58 <rwbarton> I see.
14:04:02 <rostayob> also, there might be different fields of the same type
14:04:18 <rwbarton> Well, I don't know how practical this is either, but you can encode strings in the type system and use those as a parameter of your type
14:05:05 <rwbarton> and with some template haskell this might be tolerable, or if you don't care much what the generated code looks like
14:05:16 <rostayob> rwbarton: "encode strings in the type system" == create something empty data types to use as keys?
14:05:51 <rwbarton> right so... data (:::) a b; data Nil; data C; data O; ...; instance HasField (C ::: O ::: L ::: O ::: R ::: Nil) a where ...;
14:06:53 <rwbarton> where class HasField f a t where getField :: f -> a -> t, and for f you pass in undefined :: C ::: O ::: L ::: O ::: R ::: Nil
14:07:40 <rostayob> rwbarton: wait, once you define what type, how do you retrieve a single element?
14:08:07 <rwbarton> well I compile [color foo] to "getField (undefined :: C ::: O ::: L ::: O ::: R ::: Nil) foo"
14:08:15 <ddarius> roconnor: SmallCheck would have been better for that.
14:08:37 <rwbarton> and somewhere I define "instance HasField (C ::: O ::: L ::: O ::: R ::: Nil) MyType ItsColor where getField _ a = getTheColorOf a"
14:09:21 <rostayob> rwbarton: ahah, that is interesting.
14:09:48 <rostayob> it would probably work, but it's kind of hacky. how do you guys come up with these ideas :D?
14:10:13 <rwbarton> well yeah, this is why it wasn't the first thing I suggested :)
14:12:37 <rostayob> rwbarton: anyway, thanks for the input. I don't think that what I want to do is actually possible in a nice way in Hasklel
14:12:40 <rostayob> *haskell
14:15:04 <rostayob> rwbarton: maybe the best thing is to compromise and have a simple map to look up on...
14:15:34 <roconnor> @scheck \a b -> (a <= not b) == not (a && b)
14:15:35 <lambdabot>   "OK, passed 500 tests."
14:15:49 <rwbarton> OCaml's row polymorphism seems to be more or less what you want.
14:15:56 <roconnor> anyone seen Bauer and Kavler's CReal implemenation anywhere?
14:17:33 <rostayob> rwbarton: I don't know much about OCaml, what I want is simply something like "class Lookup a b c where; lookup a b :: a -> b -> c", but b is a string
14:17:33 <rostayob> and not a type
14:17:53 <rostayob> lookup :: a -> b -> c
14:17:56 <rwbarton> but Haskell doesn't like to assume that two modules are referring to the same thing just because they use the same name, but requires that they import that name from the same place
14:18:15 <rwbarton> which is the problem you're running into, I think.
14:19:11 <rwbarton> right, and if we had support for type-level strings, you could just write that.
14:19:19 <rostayob> rwbarton: yes
14:19:38 <rostayob> your trick is a smart way of emulating that
14:19:54 <rwbarton> and we sort of do, with the type constructor stuff that I did, yeah
14:20:06 <rwbarton> but it's ugly, though you can make it less ugly (or maybe just differently ugly) with template hsakell
14:20:52 <rostayob> rwbarton: yep that's true... but the ultimate goal is to have a mapping between these types and JSON objects, and that is really easy with record syntax + Data.Data, so I'll probably end up simply importing the functions explicitely
14:21:25 <rostayob> the json library already has a function Data a => a -> JSON, or something similar
14:21:47 <rostayob> basically I want to cross compile the same templates to Haskell and JavaScript
14:59:36 <dented42> I'm using the Data.Enumerator library, I noticed that every iteratee occurs in a specific monad. My question is therefore, is there a way to 'lift' one kind of iteratee into another?
15:00:14 <ivanm> preflex: seen Axman6
15:00:15 <preflex>  Axman6 was last seen on #haskell 18 hours, 26 minutes and 17 seconds ago, saying: ghci*
15:11:26 <c_wraith> dented42: Maybe.  Some kinds of transformations just aren't going to be possible.  Others might be.
15:12:57 <dented42> c_wraith: yeah. what I want is the 'liftTrans' function, but it's been marked as obsolete and there is no indication as to what I should use in it's place
15:13:24 <c_wraith> ah.  not sure what the replacement for that is.
15:13:58 <dented42> c_wraith: and I'm curious as to why it was marked obsolete
15:20:05 <jooodes> hello. i've got a type that doesn't implement Eq. i've then got a list of them. i want to see if the list is empty, so i do a == []. that fails as i don't have eq, but surely i can do it anyway? the compiler doesn't need to use compare to see its an empty array. what can i do?
15:25:06 <koeien> jooodes: use null or pattern match
15:25:16 <koeien> :t null
15:25:17 <lambdabot> forall a. [a] -> Bool
15:25:41 <ivanm> where null is an implicit pattern match
15:28:14 <jooodes> koeien: ok - that works thanks - how come it works? doesn't pattern matching have to use compare itself?
15:28:57 <koeien> jooodes: no
15:29:15 <koeien> case ys of [] -> ... ; (hd:tl) -> ...
15:30:29 <shachaf> jooodes: (==) isn't a primitive thing like in a lot of other languages.
15:30:40 <shachaf> jooodes: It's just a function; you could define a similar one yourself if you wanted to.
15:30:51 <shachaf> Case expressions/pattern matching *is* primitive.
15:35:14 <Eduard_Munteanu> And it only works on constructors.
15:43:02 <conal> has anyone here gotten gloss-glfw to work on mac os x?
15:48:34 <shachaf> Oh, conal. I was asking yesterday if there's any usable library implementing some of the image transformation things you talked about in your talk a while ago.
15:48:50 <shachaf> I see a few things that seem mostly unmaintained.
15:49:22 <conal> shachaf: i don't know of any either. sry.
15:51:49 <conal> ah. wow. i got gloss-examples working under ghci on mac. with real mac windows and without killing ghci. very encouraging!
15:52:33 <acowley> conal: is the EnableGUI stuff built in or do you need to take special action?
15:53:32 <conal> acowley: appears to be built-in now. i just had to read the directions and run ghci with -fno-ghci-sandbox -framework Carbon .
15:53:35 <roconnor> I love the levels that appear in homotopy type theory
15:53:49 <conal> or, even easier, add ":set -fno-ghci-sandbox -framework Carbon" to my ~/.ghci
15:54:02 <roconnor> Trival < Boolean < Set < groupoids
15:54:16 <acowley> conal: wow, that's really good news. Does it work from within haskell-mode, too?
15:54:27 <roconnor> Logic is on level 1 - the booleans
15:54:30 <conal> acowley: trying now ...
15:54:31 <roconnor> Set theory is on level 2
15:55:15 <acowley> roconnor: I have a slight problem with HTT in that I don't know the first thing about it while everything I've read about it starts with what must be thing >= 2.
15:56:10 <roconnor> acowley: it's easy to go down levels.  The type of "equalty" between two things at level n is at level n-1
15:56:18 <conal> acowley: yes it does. this is great! now i think i can finally get back to functional graphics, by using glfw-b and learning to play the same tricks as gloss-glfw uses.
15:57:14 <acowley> roconnor: So, equality of groupoids is a Set?
15:57:19 <shachaf> conal: Does that mean there's going to be a working library sometime? :-)
15:57:41 <roconnor> acowley: that's what I understand
15:57:56 <acowley> roconnor: but what does that even mean?
15:58:01 <conal> shachaf: could be :) maybe we'll even get a cross-platform, ghci-friendly gui library i can rebuild my tangible values stuff on. and tangible functional programming.
15:58:22 <acowley> roconnor: is it something like equality parameterized over a set?
15:58:25 <roconnor> acowley: it means given two groupoid objects, there is a set of paths (aka arrows) connecting them.
15:58:44 <roconnor> bidirectional arrows since we are a groupoid
15:58:54 <acowley> but shouldn't equality of two sets induce a set of arrows between them for the individual elements?
15:59:18 <roconnor> yep, two arrows may or may not be equalivalent
15:59:45 <roconnor> this is then standard way to do category theory in type theory
15:59:56 <roconnor> where arrows are types with an equivalence relation on them.
16:00:04 <acowley> But I thought Set equality was a Bool
16:00:18 <roconnor> ah sorry I was misleading with bool
16:00:23 <acowley> I guess I don't see why groupoid equality is a set of paths while Set equality isn't
16:00:47 <roconnor> I used scare quotes on "equality"
16:01:25 <acowley> Also, I took away from something or other that only degenerate paths are arrows, while normally you'd have another object parameterizing the path
16:01:31 <roconnor> equality on sets is a type with at most one element
16:02:04 <acowley> roconnor: and that element maps like set elements?
16:02:48 <conal> shachaf: are you looking for something like http://conal.net/Pan ?
16:03:14 <roconnor> ya because given two objects x and y in a set, classically speaking either x = y is inhabited (aka provable) or x = y isn't inhabited.
16:03:14 <conal> shachaf: (infinite, continuous images)
16:04:21 <acowley> roconnor: I guess that still leaves me a bit fuzzy on why groupoid equality is so different from that.
16:04:22 <roconnor> the "equality" on a groupoid isn't really an equiality; it is the generalization of this equality notion on sets to be set valued rather than proposition valued.
16:04:54 <conal> shachaf: i have a new implementation of Pan and Vertigo (http://conal.net/Vertigo) that generates crazy-fast GPU code. it's been blocked for a long time now by the lack of a cross-platform, ghci-friendly, user-friendly GUI library.
16:05:01 <acowley> roconnor: that sounds crazy to me! I don't see how Sets are an extension of propositions
16:05:37 <rwbarton> well a closed sentence is a proposition
16:05:54 <BMeph> byorgey: Thank you for the delightful tau package, it's an Inspiration! ;)
16:05:59 <rwbarton> a formula with one free variable describes a set, the set of values for which the formula is true
16:05:59 <roconnor> acowley: well, we identify the empty set with the false proposition and any singleton set with the true proposition.
16:06:58 <rwbarton> "exists x. p(x)" is just a proposition, but we can also remember the set of x for which p(x) holds
16:07:28 <conal> shachaf: i have three possible resolutions in mind: (a) somebody fixes the GUI problem for all of us, (b) create a new GUI library on OpenGL (now more viable with glfw-b), and (c) give up on haskell-based execution and generate web GUIs. I'm currently pursuing the last option.
16:07:59 <rwbarton> I'm not sure how convincing this line of reasoning is, but it's basically how I think about it.
16:08:16 <acowley> rwbarton: that makes it seem to me that you are saying a proposition is interchangeable with a set
16:08:29 <rwbarton> a set retains more information
16:08:47 <rwbarton> a common thing to do with a set, though, is to remember only whether or not it is nonempty
16:08:56 <acowley> rwbarton: but I thought the argument here is that a proposition of equality between sets is something less than equality between groupoids
16:09:14 <roconnor> acowley: I think it is nicer to see it emerge from the bottom
16:09:15 <rwbarton> sorry, I did sort of jump in in the middle.
16:09:36 * rwbarton reads more history
16:10:02 <dolio> A natural equivalence on sets is isomorphism.
16:10:09 <roconnor> acowley: types of level 0 are types that are contractable.  And there is only one type (upto homotopy equivalence) that is contractable, the unit type
16:10:09 <acowley> Yes, I follow the singleton set argument, but I still don't really follow the extension to sets of order > 1
16:10:10 <dolio> But there may be many ways that one set is isomorphic to another.
16:10:18 <rwbarton> I think maybe a clearer statement is "equality of two things IN a groupoid is a set"
16:10:26 <rwbarton> and "equality of two things IN a set is a proposition"
16:10:40 <rwbarton> "equality of two things IN a proposition is trivial" (because a proposition is a 1-element set)
16:10:41 <dolio> So you can consider the identity type between sets to be a type of isomorphisms.
16:10:55 <roconnor> acowley: types of level 1 are types whose path space, (aka "equalities")  between points are of type 0.
16:10:59 <dolio> Rather than crushing it down to a proposition remembering only that two sets are isomorphic.
16:12:12 <rwbarton> right.
16:12:25 <rwbarton> whereas if you have two elements of a set, they are either equal or not equal, there is nothing more to say
16:12:27 <acowley> I think I'm hung up thinking about equality as something other than a proposition
16:12:59 <roconnor> acowley: ya, these "equalities" are generalizations of propositional equality
16:13:02 <rwbarton> That's probably because we're extending "equality" to situations where normally one would use another word, like "isomorphism"
16:13:09 <acowley> I guesss I'm lost in roconnor's quotation marks :)
16:13:19 <dolio> Equivalence is the right term.
16:13:20 <acowley> rwbarton: Yeah, I think so
16:13:24 <roconnor> right, isomorphism is one of these generalized "equalities"
16:13:30 <dolio> Two elements of a set are equivalent if they are equal.
16:13:36 <dolio> Two sets are equivalent if they are isomorphic.
16:13:50 <roconnor> right
16:13:57 <acowley> and two groupoids are equivalent if they are *****
16:14:05 <roconnor> and two sets can be equiavlent in many different ways
16:14:07 <rwbarton> but, "they are isomorphic" contains an existential quantifier (the "exists x." I mentioned earlier)
16:14:24 <dolio> Two groupoids are equivalent if there exists a groupoid homomorphism that has an inverse up to isomorphism.
16:14:25 <rwbarton> acowley: well the normal word is equivalent.
16:14:36 <roconnor> but two set elements can only be equivalent in at most one way
16:14:54 <acowley> rwbarton: I'm glad I've forced the invocation of a circular definition
16:15:38 <rwbarton> it's not actually circular, of course
16:15:53 <monochrom> that's like forcing a thunk let x=x in x :)
16:15:53 <acowley> rwbarton: the circularity is what I bring to the table
16:15:53 <roconnor> and proofs of propositions are all equivalent to each other :)
16:16:25 <rwbarton> it's as circular as "instance IdentityT m where return = IdentityT . return ..."
16:16:34 <monochrom> otoh if you craft the circular definition to be well-founded, it's fine
16:16:40 <shachaf> conal: Well, I didn't have anything speific in mind, I just saw some interesting-seeming C++ code that worked on images and thought that it looked terribly low-level and imperative, and remembered your talk.
16:16:44 <dolio> And there exists something that is equivalent to everything in a contractible space.
16:16:51 <rwbarton> that is, we are defining equivalence for X in terms of equivalence for some other thing Y
16:17:13 <acowley> rwbarton: namely the equivalence relation the groupoid is equipped with for its elements?
16:17:23 <siracusa> I'm getting deadlocks when using multiple threads and MVars. Spaming my program with print commands seems to make the problem go away but it also makes debugging nearly impossible. So are there any general tricks how to find the cause of such problems? Like getting the state of all threads and MVars or so?
16:17:30 <SharkMonkey> Will any of thse haskell IDES let me hover over variables in a function and tell me what type GHC thinks they are?
16:17:43 <rwbarton> no, equivalence between groupoids is something else, what dolio wrote above (has an inverse-up-to-natural-isomorphism)
16:18:08 <rwbarton> I was just saying that there is no more familiar term in this case, as there was at the first few levels
16:18:36 <rwbarton> btw, are the topologists losing on the level-indexing debate? I would put Trivial at level -2
16:18:43 <acowley> Well I'm trying to see what the equivalence for groupoids (X) is defined in terms of (Y)
16:19:09 <roconnor> rwbarton: hard to say.  It is a bit strange to start your natural numbers at -2
16:19:13 <rwbarton> Y can be categories or something, it wasn't the best analogy
16:19:54 <dolio> acowley: The definition is that two (n+1)-type are (n+1)-equivalent if there exists an morphism between them that has an inverse up to n-equivalence.
16:20:11 <dolio> And for a certain n, the existence of such a thing is trivial.
16:21:25 <dolio> Except, people really want to talk about infinity-groupoids, where that breaks down.
16:22:32 <dolio> Some people, at least.
16:22:47 <dolio> And really, there's no cutoff in type theory.
16:23:03 <rwbarton> roconnor: I agree that if HTT is eventually hoped to become a new "foundation for mathematics", it will look strange in the first chapter to start everything at -2...
16:23:11 <dolio> You can have identities between identities between .... as far up as you like for any type.
16:23:37 <dolio> Voevodsky just renumbers everything starting at 0.
16:23:52 <rwbarton> topologists are used to dealing with weird index shifts anyways so it's not that big a deal
16:24:06 * djahandarie shakes fist at topology
16:24:20 <Eduard_Munteanu> Groupoids as categories with inverses?
16:24:56 <dolio> Yes.
16:25:44 <acowley> how did they come up with -2, and why *wouldn't* you just call that point 0?
16:26:02 <dolio> Because they chose category for 1.
16:26:03 <djahandarie> Because something else used to be 0 and they had to count down from there, I think
16:26:06 <dolio> Or groupoid.
16:26:06 <djahandarie> Yeah
16:26:13 <acowley> oh that's just awful
16:26:17 <rwbarton> what?
16:26:19 <dolio> Then set is 0, proposition is -1 and contractible is -2.
16:26:22 <acowley> will the perils of backwards compatibility never end?
16:26:26 <dolio> Counting down.
16:27:02 <dolio> I guess there's some similar situation in topology, too. But I don't know enough topology to know what it is.
16:27:24 <acowley> Is there a lot of existing math that refers to levels without further explanation thus making a renumbering undesirable?
16:27:29 <rwbarton> it's not that arbitrary... it's related to \pi_n which is defined as pointed maps from the n-sphere
16:27:40 <rwbarton> like \pi_0(X) is the set of connected components of X, so you have set at level 0
16:27:42 <acowley> I worry I'd cry every time I started the natural numbers with -2
16:27:52 <rwbarton> \pi_1(X) only sees the groupoid structure of X
16:28:34 <rwbarton> essentially it's that groupoids have 1-dimensional structure, namely you can draw lines and circles on them
16:28:40 <rwbarton> sets have only 0-dimensional structure
16:29:15 <rwbarton> that's where the indexing comes from... then you extend it down to negative numbers
16:29:27 <dolio> It's not entirely arbitrary for categories, either.
16:29:45 <dolio> Sets have 0-cells. Categories have 0-cells and 1-cells, etc.
16:29:50 <dolio> If you start numbering objects at 0.
16:30:07 <dolio> Except, it's hard to see how you get -1 and -2 that way.
16:30:33 <rwbarton> and 0-cells and 1-cells are not arbitrary names either, we draw a 0-cell as a point and a 1-cell as a line
16:30:42 <dolio> Yes.
16:30:58 <rwbarton> but yes, you need to apply some formalism to see how the negative levels work out
16:31:28 <dolio> Unless you're into string diagrams. Then everything gets turned inside out.
16:31:39 <dolio> And you draw 0-cells as regions, 1-cells as lines and 2-cells as points.
16:31:40 <Saizan> would CoNat still be at level 0?
16:32:21 <dolio> Or, start higher if you have higher than 2-cells.
16:34:38 <rwbarton> it's neat that you can also construct the sequence from scratch starting from "triviality", also
16:39:07 <roconnor> HTT textbook: Chapter -2: Contractable spaces
16:39:42 <rwbarton> that's chapter -1, chapter -2 has an even better title :)
16:40:01 <rwbarton> or maybe not
16:40:02 <roconnor> HTT textbook: Chapter -2: Contractable space
16:41:19 <rwbarton> that would be great though, I hope the HTT textbook does that.
16:43:13 * roconnor tries to visualize a -1 dimensional sphere
16:45:57 <roconnor> [20:16] <rwbarton> like \pi_0(X) is the set of connected components of X, so you have set at level 0
16:46:10 <roconnor> this sounds like you are saying sets are at level 0 because sets are at level 0
16:46:16 <roconnor> which feels kinda arbitrary
16:46:52 <copumpkin> roconnor: you can calculate its volume at least
16:47:15 <roconnor> I guess \pi_{-1}(X) is the proposition that X is non-empty
16:47:38 <roconnor> and \pi_{-2}(X) = * for every X
16:47:47 * copumpkin calculates the volume of the -1-dimensional unit ball
16:49:42 <Eduard_Munteanu> Is there an extension to negative dimensions?
16:49:52 <copumpkin> it's defined in terms of the gamma function
16:49:53 <Eduard_Munteanu> There was that Sierpinski thing for positive reals.
16:49:58 <copumpkin> which is defined in several places negatively
16:50:13 <copumpkin> where several = uncountably infinitely man
16:50:39 <Eduard_Munteanu> Erm, Hausdorff
16:50:41 <roconnor> > pi**(-1/2)/gamma(1/2)
16:50:42 <lambdabot>   Not in scope: `gamma'
16:50:54 <Rotaerk> hrm just saw mention of the gamma function in two channels within 5 minutes of one another
16:50:56 <copumpkin> wow
16:50:59 <copumpkin> the volume is 1/pi
16:51:34 <copumpkin> yay math
16:51:38 * Eduard_Munteanu remembered the Sierpinski carpet had a non-integer Hausdorff dimension
16:52:00 <roconnor> Eduard_Munteanu: lots of fractals do
16:52:18 <roconnor> copumpkin: now draw a picture of it
16:52:27 <Olathe> Are there any horrible consequences to being able to have types as a first-class type, so that you can write normal functions that can return them and so on, and so you can write things like Zomg :: Integer -> Type to get a type constructor that takes an Integer argument to form a type?
16:52:37 <Eduard_Munteanu> Intuitively, I guess they're almost in the next higher dimension.
16:53:01 <kmc> Olathe, read about dependently-typed languages
16:53:02 <kmc> like Agda
16:53:05 <copumpkin> roconnor: gimme some -1-dimensional paper to put it on
16:53:08 <Olathe> Alright, thanks.
16:53:32 <roconnor> copumpkin: I'll give a 0 dimineional piece of paper and you can draw in a corner of it
16:53:35 <copumpkin> Olathe: yeah, come to #agda
16:53:40 <Eduard_Munteanu> There aren't really any horribly wrong consequences.
16:53:40 <djahandarie> COME
16:53:41 <djahandarie> COME!
16:54:10 <roconnor> Olathe: there are some minor issued about termination and typechecking, but nothing horrible
16:54:49 * roconnor wonders if this means that the true propoistion has volume 1/pi
16:55:35 <roconnor> dolio: interesting the volume of a hypershpere reaches 0 at -2
16:55:47 <roconnor> *at dimension -2
16:57:00 <rwbarton> roconnor: \pi_0(X) is defined in terms of pointed maps out of the pointed 0-sphere, which are just points of X
16:57:10 <rwbarton> up to homotopy/a path between them
16:57:27 <rwbarton> so it comes down to your indexing convention for spheres
16:57:31 <roconnor> right
16:57:54 <roconnor> clearly we've mistakenly numbered the sphere
16:57:55 <rwbarton> what happens at \pi_{-2} is a little weird
16:58:00 * hackagebot eddie 0.5 - Command line file filtering with haskell  http://hackage.haskell.org/package/eddie-0.5 (MikeMeyer)
16:58:07 <roconnor> rwbarton: why?
16:58:55 <rwbarton> well actually, already at \pi_{-1} there are problems, because \pi_n is usually defined in terms of maps between pointed spaces, and if a space is pointed, it is nonempty automatically
16:59:27 <rwbarton> in other words the hierarchy for pointed spaces collapses earlier than for non-pointed spaces
16:59:41 <rwbarton> levels -2 and -1 are the same
17:00:20 <roconnor> how is \pi_n defined?
17:00:20 <rwbarton> you should actually be using something other than \pi_n, but it's equivalent to using \pi_n if your spaces are pointed and n>=0
17:00:48 <rwbarton> \pi_n(X) = [S^n,X]_* where [A,B]_* is {maps A -> B preserving the basepoint} / {homotopy through basepoint-preserving maps}
17:02:26 * roconnor goes back to trying to imagine S^{-1}
17:02:33 <roconnor> it has volume 1/pi
17:02:44 <roconnor> probably negative surface area
17:03:05 <roconnor> so ... hard ... to ... imagine
17:03:16 <rwbarton> that's 1/pi of some (-1)-dimensional unit I imagine :)
17:03:24 <roconnor> ya
17:03:28 <rwbarton> so if you made it twice as big, its area would be cut in half
17:03:38 <roconnor> I guess
17:04:25 <roconnor> though I think there might only be two sizes
17:05:04 <roconnor> doesn't even make any sense
17:05:34 <roconnor> rwbarton: you are right, there must be a better definition of \pi_n
17:06:15 <roconnor> rwbarton: is \pi_n only defined for X having a base point?
17:06:29 <rwbarton> unless n<=0, yes
17:06:47 <rwbarton> arguably that is a different definition but it's one that makes sense to make
17:07:18 <roconnor> so if I pick different base points I can get different fundamental groups?
17:07:33 <roconnor> hmm
17:07:35 <roconnor> I guess so
17:07:44 <rwbarton> if they are in different connected components they can really be different
17:08:01 <rwbarton> otherwise they will be isomorphic, but to get an isomorphism you need to choose a path between your points to transport loops along
17:08:37 <roconnor> but if you pick two isomorphic paths you get the same isomorphism?
17:08:44 <rwbarton> yes
17:08:52 <rwbarton> you just need to choose a homotopy class of paths
17:09:08 <rwbarton> same applies to every \pi_n for n>=1
17:09:21 <rwbarton> (still choosing paths)
17:09:27 <roconnor> why not n=0?
17:10:11 <rwbarton> well \pi_0 makes sense without a choice of basepoint
17:10:20 <rwbarton> since it turns out to be the set of connected components of your space
17:10:54 <roconnor> so it is still true for n=0
17:10:57 <rwbarton> I suppose the same statements are literally true for \pi_0, but they're sort of vacuous
17:11:36 <rwbarton> except that changing the base point of a pointed set can't ever change its isomorphsm type
17:12:17 <rwbarton> there is a better statement to be made here...
17:13:15 <Jafet> So, I have a function f _ [x] = x; f k xs = f (succ k) (g k xs), and I want to find out how much time each pass takes.
17:13:27 <Jafet> How do I abuse the profiler to do this?
17:16:47 <Schalken> How do I fix "Cannot find default module for breakpoint. Perhaps no modules are loaded for debugging?" ?
17:16:49 <Olathe> Jafet: Could you use debug printing with unsafePerformIO getting the time?
17:17:08 <Olathe> I'm not sure how to use the profiler very well.
17:17:10 <Jafet> That's boring. I want to abuse the profiler to do this.
17:17:23 <Olathe> Haha, OK.
17:18:15 <nolrai23> so is there a better way to write "varArrays = (listArray (minBound, maxBound)) `map` [[a,b,c,d] | a <- rgb, b <- rgb, c <- rgb, d <- rgb]" cause there seems like there should be.
17:18:16 <rwbarton> roconnor: there is a term "homotopy k-type" for a space X for which all \pi_n(X) are trivial for n > k and any choice of base point; alternatively you can say that every map S^n -> X is homotopic to a constant map for n > k (with no basepoints involved).
17:18:18 <Schalken> I'm following the instructions for the GHCi debugger in the GHC docs.
17:19:18 <cmccann> nolrai23, replicateM?
17:19:29 <rwbarton> roconnor: every space has a "best approximation" by a homotopy k-type for each k.  These spaces are better invariants than just remembering \pi_0, \pi_1, ... individually.
17:19:32 <cmccann> > replicateM 2 [1,2]
17:19:33 <lambdabot>   [[1,1],[1,2],[2,1],[2,2]]
17:19:55 <rwbarton> if you set k=-1, 0, 1, ... in that definition, you get {0 or 1 point spaces}, sets, groupoids, ...
17:20:01 <Olathe> > listArray (0, 3) [1, 2, 3, 4]
17:20:01 <cmccann> or in general, use sequence
17:20:02 <lambdabot>   array (0,3) [(0,1),(1,2),(2,3),(3,4)]
17:20:15 <cmccann> > sequence [1,2] [3,4,5]
17:20:16 <lambdabot>   [1,2]
17:20:19 <cmccann> err
17:20:24 <cmccann> > sequence [[1,2], [3,4,5]]
17:20:25 <lambdabot>   [[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
17:20:31 <copumpkin> man, I can't wait for real restricted monads/functors/etc. in GHC 7.4
17:20:35 <copumpkin> well
17:20:42 <copumpkin> we'll need to get the classes changed first :)
17:20:46 <copumpkin> but the language support will be there
17:21:06 <shachaf> sequence . replicate 4, yes.
17:21:18 <rwbarton> roconnor: and I guess if you phrase "homotopic to a constant map" correctly, it also works for -2 (with S^{-1} being the empty space)
17:21:24 <nolrai23> cmccan: Thanks!
17:21:30 <shachaf> copumpkin: Wait, we're getting restricted moonads/functors/etc. in GHC 7.4?
17:21:42 <copumpkin> the language features we need for them, yes
17:21:48 <copumpkin> not the actual classes :)
17:21:52 <copumpkin> although you could write the classes yourself
17:21:57 <shachaf> What language features do we need?
17:22:08 <copumpkin> constraint kinds is what they added
17:22:20 <rwbarton> oh neat
17:22:25 <shachaf> I thought you could get away with Haskell as it is.
17:22:27 <copumpkin> so you can write
17:22:32 <copumpkin> type Moo a = Ord a
17:22:41 <copumpkin> (Moo a) => a -> a -> a
17:22:43 <copumpkin> or
17:22:54 <copumpkin> type family Constraints f a :: Constraint
17:22:58 <copumpkin> type instance Constraints Set a = Ord a
17:23:02 <djahandarie> Which is awesome.
17:23:15 <copumpkin> he also added associated type defaulting
17:23:44 <rwbarton> hmm, this is a funny question
17:23:57 <rwbarton> is the unique function from the empty set to itself a constant function
17:24:44 <shachaf> rwbarton: Sure.
17:24:47 <nolrai23> >  listArray (0, 3) `map` replicateM 4 [0..2]
17:24:48 <lambdabot>   [array (0,3) [(0,0),(1,0),(2,0),(3,0)],array (0,3) [(0,0),(1,0),(2,0),(3,1)...
17:25:01 <rwbarton> well, there are two definitions you could give for a function f : A -> B to be constant
17:25:02 <copumpkin> isConstant :: (f : a -> b) -> (x y : a) -> f x == f y
17:25:17 <rwbarton> the other is exists b in B. forall a in A. f a = b
17:25:32 <copumpkin> I prefer mine
17:25:33 <copumpkin> :)
17:25:39 <djahandarie> I like copumpkin's more too
17:25:59 <rwbarton> mine is equivalent to "factors through a one-element set"
17:26:36 <copumpkin> but that makes your function not a constant function
17:26:41 <rwbarton> right
17:26:48 <copumpkin> which feels wrong, ergo mine > yours
17:26:49 <copumpkin> ;)
17:26:49 <rwbarton> for this HTT application, I want it to not be
17:26:52 <copumpkin> oh ok
17:27:02 <rwbarton> perhaps this means I shouldn't use the phrase "constant function"
17:27:07 <nolrai23> rwbarton: I would say it is if you want it to be.
17:27:35 <shachaf> @whatis HTT
17:27:35 <lambdabot> I know nothing about htt.
17:27:54 <rwbarton> it would be fun to do a poll on "Please define what it means for a function f : A -> B to be constant" and see how many answers have the empty function defined as constant.
17:28:15 <cmccann> probably most would, or would be ambiguous
17:28:21 <copumpkin> shachaf: http://homotopytypetheory.org/
17:28:24 <copumpkin> @where+ HTT http://homotopytypetheory.org/
17:28:24 <lambdabot> I will never forget.
17:28:30 <copumpkin> liar
17:28:48 <incluye> homotopy
17:28:56 <ian__> How can listArray accept both ((t, t1), (t2, t3)) and (t, t1) for its first argument?
17:29:12 <cmccann> why wouldn't it?
17:29:18 <cmccann> those are index bounds, right?
17:29:21 * centrinia defines a function to have a non-empty domain.
17:29:47 <rwbarton> oh I suppose some set theorists might actually do that
17:29:53 <rwbarton> I would have to exclude their answers then
17:29:59 <shachaf> rwbarton: I just asked someone and his definition was exists b. forall a in A. f a = b
17:30:10 <shachaf> rwbarton: Rather than exists b in B.
17:30:12 <ian__> Not why wouldn't it, how /can/ it
17:30:17 <rwbarton> heh
17:30:20 <shachaf> At least that was his justification for allowing it to be a constant function.
17:30:28 <rwbarton> oh no, another unexpected ambiguity
17:30:45 <rwbarton> I suspect you bias people if you ask the way I did, starting with the empty function.
17:30:57 <shachaf> Right, I asked him first and then brought up the special case.
17:31:19 <aaandroid> in typeclassopedia, what does 'the kind of f must be * -> *' mean?
17:31:39 <incluye> looks like it must be a function that takes one argument
17:31:47 <rwbarton> It occurs to me that in set theory, a function is often just defined to be a set of pairs where the first elements of the pairs are all distinct, so that B is never specified
17:31:47 <incluye> but I wouldn't know i'm no good with this
17:32:05 <shachaf> aaandroid: It means that's what the kind must be. :-) It takes a type and returns a type.
17:32:08 <shachaf> @whatis kind
17:32:09 <lambdabot> I know nothing about kind.
17:32:11 <koeien> aaandroid: it means that f is a type constructor
17:32:13 <centrinia> That sounds like relational algebra.
17:32:18 <Cale> ian__: Typeclasses! :)
17:32:24 <Tinned_Tuna> rwbarton: that kind of definition is sufficiently abstract to be useful in mathematics
17:32:24 <shachaf> @whatis+ kind http://www.haskell.org/haskellwiki/Kind
17:32:24 <koeien> aaandroid: it takes one argument, and then returns a type.
17:32:25 <cmccann> ian__, the first argument is of type Ix i => (i, i), so any instance of Ix works
17:32:25 <lambdabot> Unknown command, try @list
17:32:31 <Cale> :t listArray
17:32:32 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
17:32:32 <koeien> aaandroid: an example is Maybe.
17:32:42 <shachaf> @where+ kind http://www.haskell.org/haskellwiki/Kind
17:32:43 <lambdabot> I will remember.
17:32:50 <Cale> ian__: It accepts a pair of type (i,i) where i is any instance of the typeclass Ix
17:32:53 <incluye> or maybe Int
17:32:57 <shachaf> "This Haskell-related article is a stub."
17:33:37 <ian__> could a function, say "zipWithX :: n -> [[a]] -> [b]" where n is an n-ary function that works on the transposed list of arguments
17:33:56 <ian__> err n would be the arity, and then there would be another argument with the function
17:33:56 <shachaf> ian__: n-ary functions are tricky.
17:33:58 <aaandroid> thanks, everyone!
17:34:04 <shachaf> Because all functions are 1-ary. :-)
17:34:30 <ian__> zipWithX 2 (+) [ [1, 2, 3], [2, 3, 4] ]
17:34:38 <Cale> Also, [[a]] isn't necessarily rectangular
17:34:39 <copumpkin> definitely not like that, no
17:34:52 <Jafet> Okay, I ended up unrolling the iterations to have different cost-centers for each one.
17:35:17 <Cale> (though I guess you could omit any column that didn't have enough elements from the result...)
17:36:03 <cmccann> which doesn't solve the problem of wanting the first argument to be n-ary, rather than something like e.g. a fold that can accumulate arguments
17:36:06 <Tinned_Tuna> ian__: Suppose the list of lists is l
17:36:09 <Cale> ian__: The 2 would have to change the type of zipWithX, but since it's a parameter, it could depend on values only available at runtime, but that's too late, because types only exist at compile time.
17:36:32 <Tinned_Tuna> one could imagine folding $ over (map head l)
17:36:42 <Tinned_Tuna> but I don't think it'd work out too nice
17:36:44 <Jafet> It's easy! But you have to write it something like this zipWithX (undefined :: S (S Z)) (+) ([1,2,3] ::: [2,3,4] ::: TNil) :: [Int]
17:36:55 <cmccann> ugh, don't use undefined
17:37:16 <Jafet> Well, with a bit more work it can be inferred from the list type
17:37:25 <Olathe> zipWithX :: ([[a]] -> b) -> [[a]] -> b
17:37:29 <Olathe> Take that!
17:37:31 <Tinned_Tuna> Cale is right
17:37:32 <Cale> Yeah, you need a representation of 2 which is in a type all on its own.
17:37:46 <cmccann> Jafet, something like this I expect? :P https://github.com/isomorphism/typewriter/blob/master/Data/Typewriter/Variadic/Apply.hs
17:38:08 <Tinned_Tuna> zipWithX :: Int -> (a -> a -> ... -> b) -> [[a]] -> b
17:38:10 <Tinned_Tuna> I think?
17:38:56 <cmccann> (the code there is using type-level nats, but it's not really any harder to recurse on a type-level list with a known Nil type)
17:39:21 <Jafet> "ridiculous, utterly inexcusable type hackery"
17:39:29 <cmccann> quite so
17:39:42 <Jafet> "I couldn't install agda"
17:39:49 <Tinned_Tuna> Jafet: nout wrong with a bit of a bodge every now and again ;-)
17:40:07 <cmccann> Jafet, it's no fun if you can do it properly :D
17:44:26 <hpaste> eternalmatt pasted “sudoku” at http://hpaste.org/51168
17:48:35 <eternalmatt> would anyone like to help me refactor some impossible code?
17:48:45 <eternalmatt> http://nopaste.me/paste/16237913864e6abeed3ab37
17:50:04 <Olathe> How do I get it to stop moving text up and down?
17:50:27 <Olathe> Ahh, found it.
17:50:55 <eternalmatt> if anyone interested, i'm having trouble breaking up my massive list comprehension
17:51:11 <ivanm> eternalmatt: any particular reason for yet another sudoku implementation?
17:51:19 <ivanm> and is that nopaste version the same as the hpaste version?
17:51:25 <eternalmatt> yes, for extra credit homework
17:51:27 <Jafet> matt: clearly, you need to pass value as a parameter to newgrid.
17:51:32 <eternalmatt> and because i wrote this myself
17:51:44 <eternalmatt> @Jafet, how?
17:51:44 <lambdabot> Unknown command, try @list
17:52:09 <Jafet> By passing it as a parameter to solved.
17:52:13 <Olathe> newgrid value = whatsit value
17:52:21 <eternalmatt> oh
17:52:23 <eternalmatt> I'm sorry
17:52:35 <eternalmatt> look at valid
17:52:36 <Olathe> Oh, wait.
17:52:47 <eternalmatt> problem arises at solvedgrid /= Nothing
17:52:56 <eternalmatt> THAT is where things become out of scope
17:53:23 <Jafet> Okay, so what the hell is solvedgrid?
17:54:02 <rwbarton> this is the sort of thing I like to write with do notation in the list monad
17:54:13 <eternalmatt> solvedgrid is the result of calling "solve" on the next position of a new grid
17:54:29 <Olathe> eternalmatt: How about http://nopaste.me/paste/18542808684e6ac0a04a6ab ?
17:54:39 <Olathe> eternalmatt: value should then be in scope for that.
17:54:53 <eternalmatt> @Olathe i think that might work
17:54:54 <lambdabot> Unknown command, try @list
17:54:55 <Jafet> Well, you'll have to pass this solvedgrid to valid.
17:55:16 <eternalmatt> brb, i'll try this. it'll take a minute to refactor
17:55:28 <rwbarton> solvedgrid is supposed to be the same as solved it looks like?
17:55:36 <Olathe> eternalmatt: If you use where like that, all the functions inside the where get all the variables' values outside of it.
17:55:45 <Olathe> Or something like that.
17:56:11 <Jafet> @undo [ solved | value <- [1..9], let solved  = solve (replaceIndex grid i j value) i (j+1), (and ( map (notElem value) [getRow grid i, getCol grid j, getBox grid i j])) && solved /= Nothing]
17:56:12 <lambdabot> concatMap (\ value -> let { solved = solve (replaceIndex grid i j value) i (j + 1)} in if (and (map (notElem value) [getRow grid i, getCol grid j, getBox grid i j])) && solved /= Nothing then [
17:56:12 <lambdabot> solved] else []) [1 .. 9]
17:57:06 <rwbarton> that's pretty fancy
17:57:13 <Jafet> wtf, undo is scary
17:57:15 <rwbarton> I didn't know @undo could do that
17:58:11 <Jafet> Oh, it's still rewriting. I thought it was doing type inference.
17:58:51 <eternalmatt> @rwbarton, sorry that was a typo, you're right.
17:58:52 <lambdabot> Unknown command, try @list
17:58:58 <rwbarton> @undo [ x | x <- Just 3 ]
17:58:58 <lambdabot> concatMap (\ x -> [x]) Just 3
17:59:04 <rwbarton> boo
17:59:08 <eternalmatt> @Olathe i'm getting a parse error on the new where
17:59:09 <lambdabot> Unknown command, try @list
17:59:25 <rwbarton> @undo [ x | x <- f a ]
17:59:26 <lambdabot> concatMap (\ x -> [x]) f a
17:59:54 <Eduard_Munteanu> Supposedly it operates on the desugared comprehension.
18:00:23 <eternalmatt> hmmmmmm
18:00:24 <rwbarton> @undo do { x <- f a; return x }
18:00:24 <lambdabot> f a >>= \ x -> return x
18:00:46 <eternalmatt> well now, it accepts the second "where", but now "valid" is out of scope for "filter"
18:02:56 <Olathe> Try moving that outside of the new inner where.
18:03:14 <Olathe> Put it back on the same level as tryValues
18:03:26 <Olathe> Like just by unindenting it.
18:04:32 <eternalmatt> "naked expression at the top level" ?
18:04:59 <eternalmatt> oh
18:05:02 <eternalmatt> sorry, unrelated
18:07:18 <eternalmatt> solvedgrid, not in scope; value not in scope; http://nopaste.me/paste/19517514364e6ac35ac936d
18:08:38 <rwbarton> wait
18:08:47 <tactics> When you want to create a prototype calculus/language what strategy do you guys use?
18:08:50 <rwbarton> your "valid" isn't even a function at all
18:08:51 <tactics> Do you start off with eval semantics?
18:08:54 <tactics> Or with typing?
18:13:39 <Jafet> matt is programming-by-guessing
18:13:46 <eternalmatt> matt is newb
18:15:00 <copumpkin> there's newb and there's guessing
18:15:28 <monochrom> there are newbies, blind guessing, and genetic algorithms
18:15:50 <monochrom> (yes! I rank genetic algorithms as the worst)
18:16:14 <Jafet> Systematic blind guessing
18:16:49 <tactics> blind newbies have made the basis of very powerful systems
18:16:53 <tactics> such as PHP
18:16:58 <tactics> >__>
18:17:24 <Eduard_Munteanu> Pretty Helpless Programmer? :P
18:17:36 <tactics> Eduard_Munteanu: by trade
18:17:45 <tactics> but at night....
18:17:51 <tactics> I don my cape and mask
18:17:53 <tactics> and become....
18:17:59 <tactics> the Phantom Type....
18:18:45 <ion> I put on my robe and wizard hat
18:19:07 <Olathe> Ooh! Where did you buy that hat?
18:19:11 <Eduard_Munteanu> ... and write VB code.
18:19:27 <kmc> ion++
18:20:00 <tactics> Does anyone know about any papers on the topic of combining dependent types with reference types?
18:23:18 <ddarius> You just do it.
18:23:59 <dolio> So that's what Nike's been talking about all these years.
18:36:12 <ddarius> Someone needs to temp ban jmad980
18:36:31 <Eduard_Munteanu> @where ops
18:36:32 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
18:36:42 --- mode: ChanServ set +o copumpkin
18:37:24 --- mode: copumpkin set +b jmad890!*@*
18:37:31 <ddarius> Try harder
18:37:34 <copumpkin> lol
18:37:39 --- mode: copumpkin set +b jmad980!*@*
18:39:22 <Eduard_Munteanu> You could remove the other ban, who knows, maybe somebody uses the other nick ;)
18:39:37 <ddarius> wtf?
18:39:44 <copumpkin> lol
18:39:53 <ddarius> Apparently, you'll have to ban at least the username rather than the nick.
18:40:01 --- mode: copumpkin set +b *!jmad@*$#haskell-ops
18:40:40 --- mode: copumpkin set -bb jmad890!*@* jmad980!*@*
18:40:57 <Eduard_Munteanu> What's with the $#haskell-ops thingy?
18:40:59 <centrinia> How about setting a ban on jmad*!*@*
18:41:06 <copumpkin> wtf
18:41:18 <SamB_XP> that hostname looks like a good thing to ban, if you ask me...
18:41:27 <centrinia> That was my second thought.
18:41:28 --- mode: copumpkin set +b *!*@user-jail.underscorepipe.com$#haskell-ops
18:41:40 <SamB_XP> though maybe not, if all users go in user-jail
18:41:48 --- mode: copumpkin set -b *!jmad@*$#haskell-ops
18:41:59 <copumpkin> sorry, on phone
18:42:14 <ddarius> copumpkin: Where are you?
18:42:28 <copumpkin> in my apartment
18:42:46 <ddarius> Producing your own excess flood?
18:43:06 <Tinned_Tuna> hmm, this is mildly interesting
18:43:07 <ddarius> Unrelatedly, I need to eat.
18:43:07 <Tinned_Tuna> https://docs.google.com/document/pub?id=1votaZebTxgM1_uwUe1cafU7EcFiS8qnYcJuYcJZ_F_Y
18:44:16 --- mode: copumpkin set -o copumpkin
18:44:38 <Eduard_Munteanu> I've actually done something similar when I implemented adaptive Huffman coding.
18:44:59 * ddarius has a GUI that builds a complete binary tree from clicks and stuff to demonstrate maintaining control state.
18:45:04 <Tinned_Tuna> Eduard_Munteanu: I just ignored the binary tree bit and split up the input list and reversed as necessary
18:45:42 <Tinned_Tuna> wc -l on my source file is like 26 lines :-p
18:45:47 <roconnor> ddarius: in haskell?
18:45:49 <ddarius> Tinned_Tuna: It explicitly says not to do it.
18:45:50 <ddarius> roconnor: Yes.
18:46:00 <roconnor> ddarius: what GUI kit?
18:46:41 <Tinned_Tuna> ddarius: I don't do reading the instructions.
18:47:00 <Tinned_Tuna> reading is cheap, show me the code ;-)
18:47:34 <ddarius> Well, it's based on a concurrent GUI framework thing I made that should easily be able to use different backends.  The actual backend I used is Gtk2hs.  The app is probably the worst way of building a tree as the point was solely to demonstrate maintaining state.
18:47:42 <Tinned_Tuna> an interesting corollary is: How does one build such a tree in Haskell?
18:48:36 <ddarius> To correct my earlier statement, my program doesn't build complete binary trees, it builds whatever tree you want in a depth first order.
18:49:05 * roconnor wants ddarius's program to fight hydras
18:51:34 <ivanm> roconnor: why hydras in particular?
18:51:50 <roconnor> ivanm: because you always win!
18:51:55 <roconnor> ... eventually
18:52:00 <ivanm> heh
18:53:50 <hpaste> ddarius pasted “gui” at http://hpaste.org/51169
18:54:21 * roconnor wonders if guitv still works
18:54:37 <ddarius> The gtkButtonView etc. are the adapters, the actual program is basically buildBinaryTreeExample and main.
18:54:52 <Schalken> I have two "Data.Map k v"s. How can I efficiently combine them into a "Data.Map k (Maybe v, Maybe v)", where the Maybe indicates if a value was present in the map for this key?
18:56:01 <roconnor> Schalken: unionWith?
18:56:07 <roconnor> @hoogle unionWith
18:56:07 <lambdabot> Data.IntMap unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
18:56:07 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
18:56:07 <lambdabot> Data.IntMap unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
18:56:26 <roconnor> hmm
18:56:30 <roconnor> maybe that isn't good enough
18:56:37 <roconnor> oh
18:56:53 <Schalken> roconnor: Yeah, unionWith doesn't allow a different output value.
18:57:08 <Schalken> roconnor: err, type for the values of the output.
18:57:15 <roconnor> Schalken: map the first one with \x -> (Just x, Nothing) and the second with (\y -> (Nothing, Just y))
18:57:33 <roconnor> and then unionWith
18:57:56 <ddarius> You can just unionWith mappend
18:58:08 <ddarius> Almost.
18:58:25 <Schalken> roconnor: Ah, yeah, that's what I'm already doing. I was hoping there was something better because it's outrageously slow.
18:58:28 <ddarius> Er, you can.
18:58:40 <Schalken> ddarius: How do you mean?
18:58:41 <stribor> i have file myFile.hs and i would like to load it  and use functions from it..i am on ghci prompt command line
18:58:49 <stribor> how would i load it
18:58:57 <Schalken> stribor: :l myFile.hs
18:59:03 <Tinned_Tuna> I've had my fill of haskell for this night so I'm going to bed :-)
18:59:04 <rwbarton> > Just "test" `mappend` Nothing
18:59:05 <lambdabot>   Just "test"
18:59:07 <Tinned_Tuna> See you laters guys
18:59:16 <stribor> Schalken: thank you
18:59:22 <rwbarton> > Just 1 `mappend` Nothing
18:59:23 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:59:23 <lambdabot>    `Data.Monoid.Monoid t'
18:59:23 <lambdabot>  ...
18:59:24 <ddarius> > (Just 'a', Nothing) `mappend` (Nothing, Just 'b')
18:59:25 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
18:59:25 <lambdabot>    arising from a use o...
18:59:48 <ddarius> > (First $ Just 'a', Nothing) `mappend` (Nothing, First $ Just 'b')
18:59:49 <lambdabot>   Couldn't match expected type `Data.Monoid.First GHC.Types.Char'
18:59:49 <lambdabot>         aga...
19:00:12 <Olathe> zomgMerge a b = foldr (\key result -> Map.addThingy (Map.getMaybeThingy key a, Map.getMaybeThingy key b) result) Map.empty (keys a ++ keys b)
19:00:15 <cmccann> roconnor, does "data Hydra a = Cons a (Hydra (a,a))" count as sufficiently hydra-like?
19:00:27 <Olathe> Oh, wait.
19:00:43 <Olathe> zomgMerge a b = foldr (\key result -> Map.addIfWeDontHaveYetThxThingy key (Map.getMaybeThingy key a, Map.getMaybeThingy key b) result) Map.empty (keys a ++ keys b)
19:00:52 <stribor> how do i set vi editor from ghci command prompt
19:00:58 <roconnor> cmccann: I forget the rules for the hydra game
19:01:44 <ddarius> Bah, First Nothing.
19:01:53 * cmccann has no idea what you were even talking about, just wanted to suggest a list-like type that has more heads every time you remove one
19:02:24 <roconnor> cmccann: http://math.andrej.com/2008/02/02/the-hydra-game/
19:02:32 <Schalken> Olathe: Yeah, I can do that but I thought because unionWith mentions something about "the efficient hedge-union algorithm" it would be faster than doing a lookup on every key.
19:02:37 <Eduard_Munteanu> stribor: try setting the EDITOR env variable
19:02:46 <Eduard_Munteanu> export EDITOR="vim"
19:03:10 <Olathe> Hmm...
19:03:12 <stribor> Eduard_Munteanu: from command line?
19:03:20 <Eduard_Munteanu> stribor: yes
19:03:37 <cmccann> roconnor, aha, that's pretty neat
19:03:40 <ddarius> cmccann: You need arbitrary ordinals.
19:03:41 <Eduard_Munteanu> If it works, you can put that into ~/.bashrc later
19:03:57 <roconnor> of course if PA isn't consistent then perhaps you cannot win.
19:04:15 <stribor> Eduard_Munteanu: tx
19:04:19 <Eduard_Munteanu> (it also changes the default editor for other software, like mutt or git)
19:08:44 <roconnor> why does DeepArrow depend on haskell-src
19:09:11 <roconnor> god, haskell package modularity leaves so much to be desired
19:09:33 <copumpkin> yup
19:10:02 <roconnor> copumpkin: lets start our own cabal
19:10:09 <copumpkin> :P
19:10:13 <copumpkin> it's tough
19:10:16 <roconnor> ya
19:10:23 <ahkurtz> roconnor: can you explain why succinctly? I'm a noob, and curious about that, as it's been an issue in all the other languages I've learned
19:10:24 <roconnor> :(
19:10:33 <ddarius> @hackage franchise
19:10:33 <lambdabot> http://hackage.haskell.org/package/franchise
19:11:07 * cmccann wonders what the minimal number of packages is needed to collectively depend on everything in hackage with nonzero reverse deps
19:11:45 <ivanm> does anyone actually use franchise?
19:12:08 <roconnor> ahkurtz: http://www.reddit.com/r/haskell/comments/hgcpk/too_many_libraries/c1vaqb5
19:15:19 <ahkurtz> roconnor: haha, killer! and by you no less. thanks!
19:15:43 <JoeyA> Does Leksah do any automatic indentation and such?
19:16:08 <JoeyA> s/and such//
19:17:05 * ddarius interprets roconnor's response as "No."
19:17:13 <Eduard_Munteanu> I guess that's what you get when you don't use autoconf and check for pretty printing support, or have a --enable-pp option :P
19:17:30 <roconnor> ddarius: what was the question?
19:18:07 * Eduard_Munteanu should sleep
19:18:08 <Eduard_Munteanu> o/
19:20:18 <ahkurtz> what is an "orphan instance"
19:20:46 <roconnor> ddarius: ah
19:20:57 <roconnor> cmccann: ya, that data Hydra thing wasn't what I was thinking of
19:22:04 <eyu100> > replicateM 3 [0,1]
19:22:05 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
19:22:17 <eyu100> rofl
19:22:17 <eyu100> how efficient is this?
19:22:49 <eyu100> converting 200 to binary:
19:23:08 <eyu100> > (replicateM 8 [0,1]) !! 200
19:23:10 <lambdabot>   [1,1,0,0,1,0,0,0]
19:23:19 <eyu100> heh
19:23:29 * ddarius thinks he was completely misinterpreted by roconnor.
19:25:10 <kmc> ahkurtz, an orphan instance is an «instance C T» which is a) not in the module where class C is defined, and b) not in the module where type T is defined
19:25:32 <kmc> ahkurtz, the significance is that two modules might each define a separate, conflicting orphan instance
19:25:51 <kmc> whereas non-orphan instances must be unique if you managed to successfully import the class and the type in the first place
19:26:27 <ddarius> kmc forgot the significance of the significance.
19:27:08 <ahkurtz> will ghc blow up in the case that two modules conflict?
19:27:40 <ahkurtz> thanks for answering, I found out about google and am now on the haskell wiki, so no need no regurgitate further. I'll R the FM
19:27:52 <digitteknohippie> anyone know the brief outline of the story of what happened to himerge (the portage gui written in haskell)?  did developers just lose interest or something?
19:28:34 <ddarius> ahkurtz: Any module which (in)directly uses one orphan instance can never be used with a module that (in)directly uses another orphan instance.
19:30:21 <archergent> Funny question for you: Say if Haskell was banned completely tomorrow; what language would you switch to and why?
19:31:49 <djahandarie> Agda
19:32:02 <djahandarie> Because it's better than Haskell anyways!
19:34:16 <kmc> i'd switch to GHC Haskell
19:34:28 <kmc> GHC might want to change its name in such an event, though
19:34:34 <ivanm> archergent: see the results of the recent state of haskell survey by tibbe for more answers
19:34:59 <ivanm> kmc: GGC? (THe Glasgow "GHC Haskell" Compiler") :p
19:35:20 <kmc> still has "Haskell" in it
19:36:16 <ivanm> hmmm..
19:36:30 <ivanm> we could use Haskell-ish rather than Haskell?
19:36:41 <kmc> Glasgow Has a Compiler
19:37:05 <kmc> if people decided Haskell was doomed they might work more on Disciple
19:37:14 <kmc> except that the main (only?) Disciple implementation is written in Haskell
19:37:23 <ivanm> heh
19:37:59 <archergent> Interesting that vi/emacs are the most used environments to work with Haskell (according to state of Haskell)
19:38:05 <ivanm> kmc: well, I believe benl23 plans on bootstrapping down the track
19:38:16 <kmc> cool
19:38:33 <ivanm> kmc: he told me he just doesn't want to fall into clean's mistake of going for bootstrapping too early before the syntax, etc. has settled down
19:39:19 <ivanm> archergent: it's a combination of two things: 1) IDE support isn't as good as for languages like Java, and 2) there is less of a need for an IDE as there is for languages like Java
19:39:22 <archergent> Strange, and rather sad, to see that only 4% would switch to Java as a replacement for Haskell.
19:39:22 <kmc> "The proportion that use Haskell for web development rose from 23% to 32%, most likely because we now have two quality web frameworks: Snap and Yesod."
19:39:25 <ivanm> besides, Unix is my IDE :p
19:39:27 <kmc> ouch, is that a burn against happstack?
19:39:29 <ivanm> archergent: why?
19:39:34 <ivanm> why would we want to move to Java?
19:39:50 <ivanm> kmc: I'm guessing that it's just that there's more noise, etc.
19:39:55 <ivanm> so people become more interested
19:40:11 <archergent> It's rather similar (apart from syntax and arrays) but I just thought that most Haskell people would also be Java users
19:40:15 <ivanm> could be a bit of a burn in the sense that happstack is seen as too difficult/outdated
19:40:58 <ddarius> archergent: It's 2%.
19:41:00 <archergent> Also, what does it mean by "domain" in "In which domain(s) are you using Haskell?"?
19:41:49 <ahkurtz> how are Java and Haskell similar? What?
19:42:11 <kenjin2201> Hello, I'm studying "The haskell school of expression", but keep failing to import "Haskore" library.  "import Haskore" doesn't work.
19:42:21 <kmc> this channel sees daily rants against the stupidity of Java
19:42:36 <ddarius> kmc: Do they do it while I'm at work?
19:42:39 <archergent> kmc: What are some of the common arguments?
19:42:50 <kmc> Java's actually one of a small number of languages which don't even have first-class functions
19:43:02 <kmc> which means even the most basic things from Haskell won't work
19:43:04 <ddarius> It has anonymous inner classes.
19:43:39 <ivanm> archergent: how is it rather similar?
19:43:45 <archergent> I don't believe that, but I'll take your word for it ;)
19:44:11 <ivanm> apart from that they're both turing-complete languages based upon the English language, there's almost nothing of note to say that they're similar
19:44:14 <kmc> they both use the "class" keyword
19:44:17 <archergent> ivanm: Almost everything but syntax and the whole functional thing. Also the typing method etc
19:44:17 <kmc> they both aren't C
19:44:28 <kmc> "the whole functional thing"
19:44:33 <archergent> kmc: Java is almost C
19:44:46 <kmc> archergent, you should probably explain why you think they *are* similar
19:44:57 <kmc> instead of just saying "they're similar except for X, Y, and Z, oh, and P Q R also"
19:44:58 <archergent> kmc: You could argue of it's existence being for the expansion of C with OO
19:45:01 <kmc> that's not exactly helping your case
19:45:20 <archergent> kmc: Okay, well I'll take you up on that offer. Explain why they're not
19:45:26 <kmc> don't want to
19:45:30 <archergent> (that wasn't meant to sound aggressive)
19:45:30 <kmc> you're the one who made a claim
19:45:41 <archergent> I don't want to either! I've already said their differences
19:45:51 <kmc> then we agree: Java and Haskell are very different
19:45:52 <kmc> moving on?
19:46:03 <archergent> No
19:46:04 <archergent> But moving on
19:46:17 * ddarius doesn't think archergent knows anything about Haskell.
19:46:21 <incluye> if I had to think of one programming language that was least like Haskell, I think I would go with java
19:46:30 <archergent> I've had this argument many times, almost daily. I haven't lost any of them
19:46:43 <ahkurtz> I dunno, C is maybe less like Haskell? Assembly language?
19:46:44 <archergent> incluye: fortran?
19:47:00 <incluye> archergent: well, I guess languages that are still used
19:47:13 <kmc> fortran is still used
19:47:14 <Draconx|Laptop> incluye, so, fortran?
19:47:15 <kmc> in a big way
19:47:16 <ivanm> incluye: I dunno, brainfuck springs to mind...
19:47:33 <archergent> incluye: My database tutor uses fortran currently
19:47:33 <kmc> fortran is still a good choice for turning mathematical formuale into really fast machine code
19:47:39 <archergent> ivanm: useless language
19:47:40 <ddarius> ivanm: Brainfuck is typesafe.
19:47:44 <incluye> people use fortran?
19:47:49 <kmc> scientists
19:47:52 <ahkurtz> it's fast!
19:47:53 <archergent> incluye: mmhm
19:48:00 <latros> ime fortran gets called, not written...
19:48:00 <incluye> why not just use ASM?
19:48:08 <augur> any know of descriptions of computation and computational classes based on the "style" of the computation rather than things like time/space complexity?
19:48:09 <kmc> because fortran compilers do heavy optimization
19:48:11 <latros> fortran was made to not have to do that, actually
19:48:14 <kmc> and assemblers do no optimization
19:48:14 <archergent> incluye: You've lost this argument. Just back down
19:48:15 <latros> as in, that was the point in the first place
19:48:24 <kmc> fortran is higher-level than C, in that the optimizer can assume more
19:48:30 <kmc> C lets you play lots of low-level tricks which break optimization
19:48:33 <incluye> archergent: is that how you won all the previous arguments?
19:48:43 <incluye> kmc: got it
19:48:43 <archergent> incluye: Whatever
19:49:20 * ddarius recommends saving time and kickbanning archergent, but he'll just go get food instead while you guys come to this conclusion.
19:49:30 <ivanm> archergent: ... so?
19:49:37 <kmc> i think this is a good situation for "official warning from op" rather than "kickban"
19:49:38 <kmc> but i'm not an op
19:49:41 <archergent> Please don't ban me! I have an interest in Haskell :(
19:49:54 <archergent> I'm just making my argument because you asked me to tell my reasoning
19:50:08 <Jafet> ddarius gets food a lot
19:50:14 <ivanm> I would argue that Fortran is more similar to Haskell than Java, etc. because its arrays allow variable bounds rather than just [0,n-1]
19:50:15 <ivanm> :p
19:50:19 <archergent> We can forget about the argument if you want. I don't want a ban
19:50:37 <maj10> augur: Category theory?
19:50:54 <archergent> Anyway, out of curiosity what OS do most of you guys using?
19:50:55 <augur> maj10: quite broad.
19:51:00 * incluye is linuxing
19:51:20 * kmc Debian GNU/Linux
19:51:26 <ddarius> archergent: Do you have a Haskell related question?
19:51:26 * incluye Arch
19:51:48 <archergent> How'd you get that pink text without your names?
19:52:02 <archergent> ddarius: Well I am interested in how you program Haskell
19:52:02 <archergent> on what OS etc
19:52:08 <ddarius> archergent: Do you have a Haskell related question?
19:52:08 <archergent> under what environment
19:52:24 <archergent> ddarius: :( I'm going to come back later. I don't think I'm welcome here
19:52:35 <archergent> :(
19:52:36 <incluye> vim
19:53:10 * djahandarie tells ddarius to go get some food and stop scaring off the noobies
19:53:21 <centrinia> Smalltalk seems to be dissimilar to Haskell.
19:53:25 <ddarius> Beginners have Haskell related questions.
19:54:56 <SharkMonkey> Is there a #haskell social channel to direct people with questions like that?  ##not-haskell?
19:55:07 <djahandarie> Yeah, #haskell-blah
19:55:08 <centrinia>  #haskell-blah :p
19:55:33 <ddarius> #haskell-blah gets off-topic often.
19:55:38 <accel_> has any programming langauge that has won the turing award
19:55:40 <accel_> gained mainstream adoption?
19:55:55 <centrinia>  #haskell-blah can only get off-topic by discussing Haskell. :p
19:56:01 * ddarius wonders if there is still an injunction against talking about veggie-sex.
19:56:03 <ddarius> centrinia: Indeed.
19:56:57 <edwardk> centrinia: and i'm guilty of dragging it off-topic in that regard more often than not =/
19:57:06 <kmc> accel_, the best thing about a question like that is that you can define "mainstream adoption" however you like
19:57:07 <augur> veggie sex?
19:57:11 <augur> like when vegetables have sex?
19:57:17 <edwardk> er.. in the haskell sense, not the veggie-sex sense
19:57:21 <augur> shouldnt that be in #haskell-blah?
19:57:44 <kmc> accel_, anyway, the answer is "no" because the Turing award is given to sets of people, not to languages, and usually for a number of contributions
19:58:07 <kmc> Wirth got it in 1984 "For developing a sequence of innovative computer languages, EULER, ALGOL-W, MODULA and PASCAL"
19:58:11 <ddarius> The topic in #haskell-blah explicitly forbade talk about veggie-sex.  It's surprising how often it came up unwittingly during that time.
19:58:26 <kmc> Pascal was definitely widely adopted, at least for teaching
19:58:33 <edwardk> eventually they'll tire of bitcoins as well
20:00:03 <edwardk> pascal was an amazingly productive language for me for a time
20:00:11 <kmc> oh, and Backus got it in part for working on FORTRAN
20:00:34 <kmc> so there's at least two examples of a plausible interpretation of what you meant accel_
20:12:10 <JoeyA> What is a good way to pass a Haskell structure from one process to another?  (both written in Haskell)
20:12:28 <kmc> binary or cereal
20:12:34 <JoeyA> That's what I was thinking.
20:12:51 <kmc> do you require great speed?
20:12:58 <kmc> distributed across a network?
20:13:08 <kmc> what are the structures like? do they contain functions or IO actions?
20:13:25 <JoeyA> Pure values, no functions.
20:13:41 <Jafet> Functions are pure values!
20:13:49 <kmc> yep
20:13:54 <Jafet> So are IO actions!!
20:14:42 <JoeyA> Background: http://hackage.haskell.org/trac/ghc/ticket/5476
20:15:24 <JoeyA> I want to perform computations that could potentially use a lot of memory quickly (edge case), but I don't want to crash other threads.
20:15:27 <Jafet> Define "memory usage" for one thread
20:16:56 <Jafet> Making a bug report for that is a good way to waste the developers' time...
20:17:02 <JoeyA> Given a collection of values (passed in from another thread), perform a computation and force the result in one IO thread (e.g. using evaluate).
20:17:31 <JoeyA> Jafet: It's a missing feature, is it not?
20:17:44 <Jafet> You haven't defined a feature
20:17:49 <JoeyA> Being able to support multiple clients and perform potentially explosive computations.
20:18:03 <JoeyA> (without disrupting other clients when one fails)
20:18:13 <Jafet> Well, you haven't defined a feature well.
20:18:18 <JoeyA> Jafet: I defined the feature quite well in the ticket.
20:18:26 <JoeyA> catchHeapOverflow :: Int64 -> IO a -> IO a -> IO a; catchHeapOverflow limitBytes handler action = ...
20:18:42 <Jafet> What happens when two threads share a value? Who gets blamed for it?
20:20:00 <JoeyA> I discussed that in the last paragraph.  Essentially, I'm happy if I can perform computations entirely in one thread and gracefully handle the case where those computations use more than a specified amount of memory.
20:20:40 <Jafet> See, you haven't defined "memory usage" well. So short of you giving the patch to ghc, I'm not sure if anyone will write it
20:20:50 <kmc> technically, you can catch the heap overflow exception
20:20:58 <kmc> but i'm not sure this is guaranteed to really actually work
20:21:07 <joe6> i have a module that has 314 files (autogenerated) and it is taking a while for cabal to compile and install the module. I am just doing "cabal install" to install the module.
20:21:07 <JoeyA> For my case, I don't care what happens if I share the data with another thread before finishing catchHeapOverflow.  I'll just try not to.
20:21:23 <kmc> a module has only one file; do you mean a package?
20:21:24 <Jafet> The heap overflow exception could be sent to any thread, I think
20:21:26 <joe6> Is there a better way of getting the cabal install to be quicker?
20:21:29 <kmc> ah, right
20:21:36 <Jafet> It's not any finer-grained than a sigsegv, for instance
20:21:39 <joe6> kmc, yes, the package.
20:21:45 <JoeyA> According to the docs, GHC doesn't throw HeapOverflow...
20:21:49 <kmc> oh
20:22:21 <JoeyA> > foldl (+) 0 [1..]
20:22:40 <lambdabot>   thread killed
20:23:04 <joe6> kmc, like cabal caching the results oslt?
20:23:10 <kmc> not afaik
20:23:15 <kmc> cabal doesn't even do parallel make :/
20:23:17 <JoeyA> Without the right optimizations, forcing that explodes in memory usage.
20:23:28 <kmc> though you can rejigger your cabal package to be Makefile-based
20:23:33 <kmc> at significant complexity
20:23:45 <Jafet> You can mmap a shared region and pass your data to the other process that way. Basically writing C.
20:24:03 <JoeyA> I thought about doing that.
20:24:16 <JoeyA> But that would pretty much defeat the purpose of using Haskell for my application, for the most part.
20:24:18 <Jafet> A Storable instance should be much faster than Binary
20:24:29 <JoeyA> Ah, that's good to know.
20:24:43 <Jafet> Well, it depends of course on what you wrote in the instance.
20:25:40 <JoeyA> Succinctly: catchHeapOverflow (20*1024^2) (error "Out of memory!") (evaluate (foldl (+) 0 [1..]))
20:25:41 <kmc> it's not "writing C".  you can use 'binary' and pass those through a shared memory region and still for the most part use them as ordinary haskell values
20:25:52 <Jafet> With regard to your trac ticket, I feel it's rather counterproductive
20:26:02 <JoeyA> How so?
20:26:31 <Jafet> You don't define the semantics of your request beyond what you happen to want for this program, so it's questionable whether the request applies to other programs as-is
20:26:55 <Jafet> Also, I'm pretty sure that doing this in ghc is going to take more than a few lines of code
20:29:31 <JoeyA> I don't know exactly how GHC manages memory (beyond understanding the concept of two-space garbage collection).  How exactly the feature should work depends partly on that.
20:30:06 <JoeyA> Does GHC keep track of what thread is using a memory pool?
20:30:39 <JoeyA> Assuming a bunch of objects are created in a thread and never shared with another thread, is it possible to tell what thread is using the memory?
20:31:01 <Jafet> Look, take your concept of "thread" from linux/posix/C/etc. Then burn it.
20:31:13 <JoeyA> I know GHC uses lightweight threads.
20:31:29 <JoeyA> If I were doing this in C, I wouldn't be using threads, anyway.
20:31:50 <JoeyA> I'm also aware that lazy evaluation makes things... interesting.
20:32:52 <Jafet> To do the accounting you want, the best way is probably to modify the collector to produce memory usage sums for each thread stack.
20:33:57 <JoeyA> Sounds right.
20:34:01 <kmc> i wonder if you could enable heap profiling and get some of this for free
20:34:40 <JoeyA> GHC supports lightweight threads.  Are GHC thread stacks for OS threads or Haskell threads?
20:34:48 <Jafet> I think it counts occupancy in a different way
20:37:13 <JoeyA> Jafet: Thinking in mark-sweep terms, are you suggesting this?  Traverse stack of thread in question, total the amount of memory marked as used, and blame the thread for that memory.
20:37:45 <JoeyA> So it's possible for one thread to be blamed because it's sharing data with another thread.
20:37:47 <Jafet> Since any collector has to traverse the live set, any collector can count memory occupancy.
20:37:55 <JoeyA> The programmer simply has to avoid that.
20:38:10 <Jafet> However, counting it uses extra memory.
20:38:47 <Jafet> Possibly a lot of extra memory, depending on the details.
20:39:34 <JoeyA> This might actually be simpler to implement: evaluateCap :: Int64 -> a -> IO (Maybe a)
20:40:17 <Jafet> No, same difference
20:40:20 <JoeyA> It takes a given memory limit and value, forces the value, and returns Just ... on success, Nothing on overflow.
20:40:30 <kmc> you could lower HpLim and then add the check to the GC
20:40:43 <kmc> this could be done based on per-Haskell-thread info which is loaded into the Capability struct
20:40:57 <kmc> i think it's doable but the best way to find out is to write the GHC patch yourself :)
20:41:21 <Jafet> Concurred
20:41:38 <JoeyA> Is HpLim per-thread or per-process?
20:42:38 <Jafet> Oh, the profiler already uses extra memory to count.
20:43:34 <Jafet> "The space overhead is currently 2 extra words per heap object, which probably results in about a 30% overhead."
20:43:56 <Jafet> Personally, I wouldn't dump 30% of my memory on this
20:44:30 <JoeyA> Here's what I had in mind: evaluateCap stores a pointer to the object in an array, paired with context it needs to throw an exception understood by evaluateCap.
20:45:22 <JoeyA> The garbage collector would traverse the array of caps, and mark each value one by one.
20:46:00 <JoeyA> Between marks, it will see how much space became used, and blame the thread for it.
20:46:19 <JoeyA> If the amount of space that became used is greater than the cap, it tells the thread to throw an exception.
20:46:31 <JoeyA> Does that make sense?
20:47:09 <Jafet> What's a cap and why is there an array of them?
20:47:40 <sebz> is there a function to take a "product" of two lists?
20:47:41 <JoeyA> A cap consists of a value pointer and a maximum number of bytes that pointer may bring in when marked.
20:48:11 <Jafet> sebz: which "product"
20:48:19 <kmc> > liftM2 (,) "abc" "xyz"
20:48:20 <sebz> so given l1, l2, it would give [(i,j) | i <- l1, j <- l2]
20:48:30 <kmc> god damn it, where did lambdabot go
20:48:31 <JoeyA> sebz: zipWith (*) multiplies each item.  [(x, y) | x <- lx, y <- ly] produces the Cartesian product of the lists lx and ly.
20:48:32 <sebz> I'm thinking of lists as sets
20:48:42 <kmc> Cale... what's going on with lambdabot?
20:48:54 <JoeyA> kmc: Probably ticked her off with my memory overflow.
20:48:57 <kmc> haha
20:48:57 <Jafet> sequence ["abc", "xyz"]
20:49:12 <kmc> if we need better hosting or more redundancy or something, i'm sure we can pass the plate and make that happen
20:49:26 <kmc> λbot is an incredibly valuable resource
20:49:37 <JoeyA> I think lambdabot could benefit from evaluateCap ;-)
20:49:41 <sebz> Jafet: wow, okay how does that work?
20:49:58 <kmc> JoeyA, mueval already provides that for lambdabot
20:50:01 <Jafet> sebz: list monad
20:50:10 <JoeyA> sequence [putStrLn "Hello", putStrLn "World"]
20:50:26 <JoeyA> That performs two IO actions in sequence, and returns a list of the results (namely, [(), ()])
20:50:48 <Jafet> JoeyA: if you have the collector count the size of each pointer recursively, it's going to use, like, 30% extra memory all by itself
20:50:52 <JoeyA> sequence ["abc", "xyz"] "performs" two lists, and gives you a "list" containing the result ;-)
20:51:13 <JoeyA> do {x <- "abc"; y <- "xyz"; return [x, y]}
20:51:20 <sebz> got it
20:51:23 <sebz> thanks a lot
20:51:25 <ion> joeya: That generates an IO action that upon execution performs the two IO actions in sequence and results in a list of the results.
20:51:35 <Jafet> In current ghc, it's also going to use 30% extra memory for the rest of the program
20:51:38 <JoeyA> Jafet: But you shouldn't need to count the size per pointer.
20:51:55 <Jafet> Er, size of each value pointed to by the pointer.
20:52:26 * Jafet resists the urge to use "pointee"
20:52:46 <JoeyA> You count the overall memory added to the reachable set.
20:53:01 <JoeyA> In a simple copying collector, that's just end - start
20:53:12 <JoeyA> (where end and start are pointers to the to-space)
20:53:23 <SamB_XP> it gets more complicated in a multi-generation copying collector...
20:53:24 <JoeyA> So (end' - start') - (end - start)
20:53:44 <Jafet> You want ghc to make the thread run with a completely isolated memory region?
20:53:50 <Jafet> Again, threads are not programs
20:54:18 <Jafet> All threads share the same heap; your plan won't work
20:54:41 <SamB_XP> oh, lambdabot runs those in the main process?
20:54:53 <JoeyA> Is it possible to tell, at basically any given moment during collection, how big the "marked" set currently is?
20:55:18 <SamB_XP> GHC doesn't generally use mark/sweep
20:55:28 <JoeyA> Right, I'm using "marked" abstractly.
20:55:43 <Jafet> That's not enough. Say part of x has already been collected. When x is collected, the collector doesn't re-collect that part. So the size of that part has to be stored somewhere.
20:55:47 <JoeyA> The set of data that is known to be reachable.
20:55:56 <Jafet> So you have to add size accounting for the entire program heap.
20:57:27 <Gracenotes> hm. how interesting are rule-based inference engines? (most famous of them prologs, which are top-down)
20:57:33 <Jafet> It's either that, or you magically prevent computations in evaluateCap from sharing values with the outside. That's halfway to doing it in a separate process.
20:58:20 <JoeyA> If we invoke evaluateCap on the same value twice (e.g. in two threads, or nested), at most one cap will be blamed for any data the value brought in.  The other will probably be blamed with 0 bytes.
20:58:22 <Jafet> Gracenotes: |<------->| ?
20:58:59 <Gracenotes> Jafet: >_> as far as their relevance in academia nowadays, I guess
20:59:17 <Jafet> JoeyA: but you'll need a lot of overhead to do all that
21:01:07 <JoeyA> At the beginning of garbage collection, everything is in the to-space, so the to-space takes zero bytes.
21:01:29 <JoeyA> Instead of copying data pointed to by the stack, we start by traversing the caps.
21:03:06 <JoeyA> Per cap, we 1) See how big the to-space currently is, 2) copy/redirect the block pointed to by the pointer for this cap 3) See how big the to-space is now, 4) Use subtraction to determine how much to blame the cap
21:04:02 <JoeyA> So unless GHC's garbage collector uses some really weird data structure, it should be trivial to see how big the to-space is at any moment.
21:04:10 <JoeyA> We don't have to do it often, either, just once per cap.
21:04:20 <Jafet> So you propose that if a program has several restricted threads, the collector starts by collecting these threads first, and if the memory size of the reachable set of a thread exceeds its limit, it may or may not be killed
21:04:49 <JoeyA> right
21:05:10 <Jafet> You still have to add accounting data for cyclic structures. Or are you going to arbitrarily outlaw those as well?
21:06:20 <ddarius> It worked for Python and Perl and I think Tcl.
21:06:25 <Jafet> ...this feature request is ill-thought-out. I would just find the fastest way to serialize it and pass it to an isolated process, which is what you're trying to implement inside a thread.
21:06:45 <JoeyA> I don't care about the sum of usable space by a given thread.  I only care how much space is brought in when the garbage collector visits it.
21:07:04 <JoeyA> Child blocks might have already been visited, in which case they won't be counted.
21:07:25 <JoeyA> So if two threads share data, one thread will be blamed and the other will not.
21:08:23 * ddarius implements JoeyA's idea as nufork action = do tid <- forkIO action; throwTo tid HeapOverflow
21:08:26 <JoeyA> It's up to the user to ensure that the expression they're evaluating isn't present in another thread.
21:13:12 <ash_> so… ghc -package ghc is failing for me, and I have never used the -package flag before, but this lib i downloaded is asking for it
21:15:00 <edwardk> joeya: you may be interested in rob ennals' thesis. he describes a detailed 'blame' setup for haskell thunk evaluation
21:15:23 <edwardk> JoeyA: he needed it to get optimistic evaluation working nicely in ghc, but you might be able to exploit the blame model
21:16:46 * ddarius considers becoming a professional flavorist.
21:18:46 <ion> ddarius: Like Flavor Flav?
21:19:53 <kmc> Python and Perl forbid cyclic structures?
21:20:26 <kmc> optimistic eval?
21:20:47 <ezyang> Well, Perl has trouble with them because it's refcounted.
21:20:51 <SamB_XP> Python has a cycle collector
21:20:58 <SamB_XP> I dunno about perl
21:21:03 <kmc> perl might just punt on it
21:21:10 <kmc> but it does let you build cyclic structures
21:21:32 <SamB_XP> but my suspicicion is that they do, too
21:22:23 <SamB_XP> of course, Jython uses normal garbage collection only
21:28:40 <ddarius> kmc: I believe they did at one point.
21:31:04 <ddarius> "Cluster headache is probably the worst pain that humans experience. I know thats quite a strong remark to make, but if you ask a cluster headache patient if theyve had a worse experience, theyll universally say they haven't. Women with cluster headache will tell you that an attack is worse than giving birth. So you can imagine that these people give birth without anesthetic once or twice a day, for six, eight
21:31:04 <ddarius> , or ten weeks at a time, and then have a break. It's just awful." The more you know.
21:31:32 <Dashkal> I "only" get migranes.  I consider myself lucky
21:32:54 <ddarius> Cluster headaches are also known by the name "suicide headache."
21:33:13 <Rotaerk> I wonder how they compare in pain to some of the most painful venoms
21:33:36 <ion> http://en.wikipedia.org/wiki/File:Clusterhead.jpg
21:46:01 <JoeyA> Well, thanks for humoring me (about per-thread memory caps).  I guess for now I'll just place a timeout when performing the computation, and hope memory usage doesn't grow too fast.  (the people who will be writing executable code are trustworthy)
21:46:08 * Olathe pines for lambdabot.
21:46:17 <JoeyA> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Timeout.html
22:08:34 <dave1231> ddarius:  apparently http://en.wikipedia.org/wiki/Trigeminal_neuralgia is right up there on the list of things not to get
22:09:40 <armlesshobo> do I only need to specify a type if i'm writing a function in a module?
22:09:53 <ddarius> I actually arrived at cluster headache from trigeminal.
22:11:18 <latros> armlesshobo: you don't need to specify a type then, either
22:11:30 <latros> (not all the time, anyway)
22:11:44 <armlesshobo> latros: hmm. i think i misspoke. I'm new to haskell and am trying to wrap my finger around it ;)
22:11:54 <ddarius> There are only a few cases in Haskell 98 where you need to specify a type at all.
22:12:27 <armlesshobo> by type i mean something like "reverse :: [a] -> [a]"
22:12:30 <latros> yeah
22:12:37 <armlesshobo> that's right?
22:12:40 <latros> you don't need to specify a type signature almost ever
22:12:43 <armlesshobo> to call that a type?
22:12:44 <armlesshobo> hmm
22:12:45 <armlesshobo> ok
22:12:47 <latros> in haskell 98
22:12:47 <latros> also
22:12:51 <latros> that's a type signature
22:12:56 <latros> [a] -> [a] is a type
22:13:04 <latros> that right there says that the function reverse has that type
22:13:35 <armlesshobo> i see
22:13:37 <armlesshobo> okay
22:14:17 <latros> you still don't need to specify it, though
22:14:17 <armlesshobo> ok
22:14:28 <armlesshobo> btw...
22:15:02 <armlesshobo> if i see something like "foo :: a -> a -> a -> a"
22:15:19 <armlesshobo> that means, foo takes three arguments and maps to type a?
22:15:29 <armlesshobo> of type a*
22:15:38 <latros> that's one interpretation
22:15:38 <ddarius> No, it means foo takes one argument and maps it to a function (a -> a -> a).
22:15:41 <zzo38> Is there a proper name in category theory for having only the "unit" function of a monad and not join/fmap?
22:15:44 <latros> the more accurate interpretation
22:15:49 <latros> is what ddarius said
22:16:00 <latros> it's a pointed functor, zzo
22:16:04 <ddarius> zzo38: Pointed functor, though I don't think categorists talk about just pointed functors too much.
22:16:12 <latros> fmap is there, though
22:16:31 <latros> unless you meant something that literally only has a unit function
22:16:37 <latros> in which case I have no idea
22:16:45 <zzo38> latris: Yes I do mean literally only has a unit function.
22:17:03 <latros> yeah, I don't think category theory has a name for that because it's not really categorically interesting at all
22:17:14 <armlesshobo> ddarius: hmm. how does it map to (a->a->a) and not (a->a)?
22:17:21 <latros> uh
22:17:29 <latros> ->
22:17:30 <zzo38> I know it is useless by itself
22:17:32 <latros> is right associativie
22:17:33 <armlesshobo> i though it was right associative
22:17:36 <latros> *right associative
22:17:37 <latros> so
22:17:45 <armlesshobo> so the right most two would be (a->a)
22:17:47 <latros> a->a->a->a = a->(a->a->a)
22:17:49 <kmc> foo :: a -> (a -> (a -> a))
22:17:54 <armlesshobo> ahhhhhhh
22:17:54 <latros> = a->(a->(a->a))
22:18:02 <armlesshobo> i got it now
22:18:17 <armlesshobo> is that assuming the funciton is curried, though?
22:18:21 <latros> it always is
22:18:34 <kmc> "currying" is a convention for how to represent multi-argument functions
22:18:37 <latros> if you uncurry it, it takes a single tuple argument
22:18:38 <armlesshobo> pure*
22:18:43 <latros> uh
22:18:44 <kmc> it's the "default" convention in Haskell, in that the syntax encourages you to use this convention
22:18:58 <latros> pure/impure is subtle here
22:19:02 <armlesshobo> i think i meant to use 'pure'
22:19:07 <kmc> there are no impure functions in Haskell
22:19:08 <latros> the truly impure things in haskell are not functions
22:19:12 <kmc> unless you cheat and use unsafePerformiO
22:19:22 <kmc> (and use it "wrong")
22:19:35 * kmc looooooooves scare quotes
22:19:51 <kmc> neither a function of type (A -> IO B) or an IO action of type (IO B) is in any way impure
22:20:04 <armlesshobo> i was under the impression that the functions that come with haskell are pure, but what you as a developer code may not necessarily be pure
22:20:10 <kmc> they're both ordinary first-class values which can be passed around, stored in data structures, etc.
22:20:14 <kmc> without any effects going off
22:20:17 <latros> not really, armlesshobo
22:20:20 <kmc> armlesshobo, where'd you get that impression?
22:20:21 <copumpkin> Cale: no lambdabot :(
22:20:35 <armlesshobo> kmc, i may have misread the book i was reading
22:20:36 <latros> the *truly* impure bits are IO actions, but they too are ordinary values until you try to fully evaluate them
22:20:41 <kmc> no
22:20:42 <kmc> that's wrong
22:20:47 <kmc> evaluation != execution
22:20:56 <kmc> you can evaluate an IO action all you like and no IO occurs
22:21:00 <latros> oh?
22:21:07 <armlesshobo> true
22:21:09 <latros> I'm not sure how you would do that
22:21:12 <kmc> (putStrLn "Hello world!") `seq` ()
22:21:16 <kmc> try that in ghci
22:21:17 <latros> ah
22:21:29 <kmc> armlesshobo, anyway, you can't make an impure function by composing pure functions... that's a pretty simple mathematical fact
22:21:30 <latros> I don't have to try it, I see what you're going for
22:21:41 <latros> interesting
22:21:48 <latros> IO is one of my big weak points still
22:21:54 <kmc> the only IO action which is ever executed is the one named "main"
22:21:57 <kmc> or one you type at the GHCi prompt
22:21:59 <armlesshobo> kmc: but you could make an impure function using other impure funcitons
22:22:04 <kmc> yeah armlesshobo
22:22:17 <kmc> or using language constructs like mutation or side effects
22:22:31 <kmc> but in Haskell you can't mutate or cause side effects through function application and evaluation
22:22:48 <kmc> you can only describe mutations or side effects
22:22:51 <kmc> those descriptions are IO actions
22:22:57 <latros> well
22:22:59 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:23:01 <latros> main executes them
22:23:04 <latros> er
22:23:05 <latros> is executed
22:23:08 <kmc> yeah
22:23:11 <latros> and if need be thne other stuff gets executed
22:23:14 <kmc> yeah
22:23:15 <latros> so that main knows what to do
22:23:16 <latros> *then
22:23:24 <kmc> because the action named 'main' can be built by gluing together actions that come from elsewhere
22:23:30 <kmc> the gluing is done with (>>=)
22:23:31 <latros> right
22:23:36 <latros> also right
22:23:46 <latros> I just didn't catch that you could fully evaluate an IO action at all outside main
22:23:50 <latros> should've thought about doing it with seq
22:23:59 <latros> (I'm ignoring GHCi)
22:24:06 <kmc> yeah, it's a little bit weird that you're allowed to
22:24:11 <kmc> because IO is an abstract type
22:24:23 <kmc> also it's not fully evaluated, just to weak head-normal form
22:24:34 <latros> now you're beyond me :p
22:24:41 <kmc> (return (2+2)) `seq` ()   -- will probably not perform the addition
22:24:52 <latros> I see
22:24:56 <kmc> whnf means the outermost thing is a constructor or a lambda
22:25:05 <kmc> but there can be thunks (unevaluated function applications) buried within
22:25:09 <copumpkin> what's a good name for a deepseq that needs no typeclass?
22:25:15 <kmc> try (Just undefined) `seq` ()
22:25:16 <kmc> it won't error out
22:25:20 <latros> you are correct:
22:25:23 <latros> Prelude> (return [1..] :: IO [Int]) `seq` ()
22:25:23 <latros> ()
22:25:40 <kmc> [1..] `seq` () -- is also fine
22:25:45 <kmc> (1 : undefined) `seq` ()
22:25:45 <latros> interesting
22:25:50 <kmc> because (:) is the constructor
22:25:55 <kmc> it's only forcing the outermost constructor
22:25:58 <latros> right
22:26:05 <kmc> > (undefined : undefined) `seq` ()
22:26:08 <lambdabot>   ()
22:26:10 <latros> so this is why we have deepseq
22:26:15 <kmc> yeah
22:26:15 <latros> ...
22:26:16 <latros> huh
22:26:20 <latros> that one is weird
22:26:23 <kmc> but don't use deepseq if you don't really have to
22:26:26 <latros> I see why, though
22:26:27 <latros> yeah
22:26:28 <kmc> it's usually possible to avoid it
22:26:37 <kmc> and it's inefficient, because it has to walk the whole data structure
22:26:44 <armlesshobo> looks like i have a lot of reading to do :P
22:26:47 <kmc> poking every bit as it goes
22:26:50 <copumpkin> and can't deal with cyclic datastructures
22:26:50 <latros> my stuff is usually not very complicated, tbh
22:27:06 <latros> my most complex thing I've written in the last few months is only 60 lines
22:27:08 <armlesshobo> i'll take that on tomorrow. I'm gonna pass out on the keyboard if i don't go to bed soon :P
22:27:12 <latros> it's an uncertainty propagation module
22:27:13 <kmc> you could make a very fancy GHC-specific deepseq which deals with cycles
22:27:14 <kmc> maybe
22:27:19 <copumpkin> yes, I'm doing that :P
22:27:22 <kmc> :D
22:27:22 <latros> defines a constructor and some numerical instances
22:27:24 <copumpkin> that's why I was asking for a name
22:27:31 <armlesshobo> kmc: latros: g'night, thanks for your help :)
22:27:32 <copumpkin> it also has no NFData constraint
22:27:35 <kmc> 'night armlesshobo
22:27:35 <latros> np armlesshobo
22:27:38 <copumpkin> it's deepestseq
22:27:47 <latros> funky thing
22:27:56 <kmc> might go for deeperseq, don't want to limit your future options
22:28:02 <latros> is that it lets you have an uncertain quantity whose "certain" field is an uncertain quantity
22:28:05 <copumpkin> if I deepseq (const undefined 5)
22:28:10 * latros has no idea what the hell this means
22:28:10 <copumpkin> that won't fail
22:28:13 <copumpkin> my deeperseq will
22:28:17 <kmc> latros, Uncertain (Uncertain a) -- ?
22:28:21 <latros> yep
22:28:30 <latros> I have no idea how to concretely interpret this
22:28:31 <ddarius> copumpkin: Does it put function into normal form?
22:28:33 <kmc> can you write a function Uncertain (Uncertain a) -> Uncertain a -- ?
22:28:44 <latros> I can write a trivial one
22:28:49 <latros> I can't think of a concrete one
22:29:00 <latros> like, that has anything to do with uncertain quantities
22:29:04 <kmc> well, if you can, then Uncertain is probably a monad
22:29:11 <kmc> probability monads are already a thing people have studied
22:29:22 <latros> I couldn't even get it to be a proper functor
22:29:24 <copumpkin> ddarius: well, it really depends on how it got compiled. If it's represented as a partial application or an application (rather than being statically evaluated somehow to 5) then I can see the undefined and will try to evaluate it
22:29:29 <latros> I'm skeptical as to whether it's a proper monad
22:29:40 <latros> my "trivial one", by the way
22:29:43 <latros> was just returning the first field
22:29:51 <latros> which...does not seem to be consistent with the idea of join
22:30:00 <latros> and probably violates the hell out of a monad law
22:30:56 <latros> especially since there is a natural return
22:31:40 <latros> but, anyway, the natural fmap does not make sense over enough types
22:31:44 <latros> to have a functor
22:32:00 <latros> (specifically it's not a functor on Hask, it's a functor on a vastly smaller category)
22:32:49 <ddarius> Usually the first thing one wants to check when deciding whether something is a monad is whether it is a functor.
22:33:00 <latros> yeah
22:33:08 <latros> I thought it would be a functor, and had an elegant functor instance
22:33:42 <latros> but the forall in the type signature of fmap
22:33:47 <ddarius> Writer (First w) a
22:33:48 <latros> breaks that horribly
22:34:07 <latros> (the implicit forall)
22:34:19 <latros> eh, I'll show what I meant:
22:35:05 <latros> http://pastebin.com/Nyu3thy3
22:35:07 <mauke> The paste Nyu3thy3 has been copied to http://hpaste.org/51170
22:35:17 <latros> uh...huh
22:35:21 <latros> that's weird
22:35:37 <kmc> what is?
22:35:43 <latros> the thing the bot just did
22:35:57 <kmc> pastebin.com sucks
22:35:58 <latros> agh
22:36:00 <latros> I meant f
22:36:02 <latros> on the rhs
22:36:04 <latros> I had g before
22:36:08 <latros> changed only on one side
22:36:10 <kmc> it's full of pop-up ads and shit
22:36:16 <ddarius> mauke is not a bot
22:36:21 <latros> oh?
22:36:30 <latros> awfully responsive for a non-bot
22:36:33 <kmc> mauke has a bot :)
22:37:55 <hpaste> latros pasted “uncertfmap” at http://hpaste.org/51171
22:38:07 <latros> ...that is pretty snazzy
22:38:15 <latros> aaagh
22:38:17 <latros> more g's
22:38:25 <hpaste> latros pasted “uncertfmap” at http://hpaste.org/51172
22:38:30 <latros> there we are
22:38:33 <latros> anyway
22:38:35 <latros> you may see the problem
22:39:23 <latros> wait
22:39:35 <latros> ...no, that wouldn't work, nvm
22:40:06 <latros> kmc?
22:40:21 <latros> (sorry, not sure if you're still paying attention/interested)
22:41:01 <kmc> busy, sorry
22:41:04 <latros> k
22:56:37 <tomberek> hodwy
23:13:15 <edwardk> yo
23:15:39 <ddarius> edwardk: What's an application of Grbner bases you think I'd be interested in?
23:19:30 <edwardk> hrmm
23:20:10 <edwardk> integer programming?
23:20:56 <edwardk> the 3-color problem
23:23:24 <kmc> what's an example of a function on parsec parsers which is simple and obviously useful
23:23:33 <kmc> but is more interesting than «lexeme p = spaces *> p»
23:23:43 <ddarius> Most of the combinator ones.
23:24:04 <ddarius> chainl is pretty compelling.
23:24:53 <edwardk> actually lexeme p = p <* spaces ;)
23:25:05 <ddarius> And of course there is the expression parser.
23:26:06 <edwardk> maybe something nearer and dearer to my heard than yours would be extracting invariants in phylogenetic trees
23:27:00 <edwardk> s/heard/heart/
23:30:10 <ddarius> What's the appeal of phylogenetic trees to you?
23:32:51 <edwardk> used to work with bioinformatics data and with linguistic data, both have phylogeny concerns
23:33:27 <edwardk> the former to try to figure out common ancestors of actual species, the latter to figure out common ancestors for languages and dialects for linguistic hypotheses
23:40:51 <cadabra`> How could I use Parsec to parse this: "{ foo }", where foo may contain '{' and '}', but I can guarantee that they're balanced?
23:41:56 <edwardk> cadabra: if you just use 'braced' you'll be fine, as long as the parser for foo is smart enough to leave the trailing brace unmolested
23:44:21 <cadabra`> Where is braced defined?
23:44:39 <ddarius> @hoogle parens
23:44:39 <lambdabot> Text.Read parens :: ReadPrec a -> ReadPrec a
23:44:39 <lambdabot> Text.Parsec.Token parens :: GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m a
23:44:39 <lambdabot> Text.PrettyPrint.HughesPJ parens :: Doc -> Doc
23:44:50 <edwardk> its in Text.Trifecta.Token
23:44:52 <edwardk> er
23:44:56 <edwardk> Text.Parsec.Token
23:45:11 <edwardk> (or Text.Trifecta.Parser.Token) ;)
23:45:19 <cadabra`> The problem is that foo is completely arbitrary unstructured text, so all foo can do is look for the closing }...
23:45:45 <cadabra`> Sorry, arbitrary unstructured except for the fact that it contains balanced braces.
23:45:47 <edwardk> cadabra: the problem you have is the fact that { …. } } has two completely ambiguous parses
23:45:52 <edwardk> wait
23:45:57 <edwardk> oh
23:46:02 <edwardk> you CANguarantee they are balanced
23:46:06 <edwardk> i misread tat
23:46:15 <edwardk> then just balance them yourself
23:46:17 <edwardk> one sec.
23:46:46 <cadabra`> That's what I'm working on doing.. :)
23:47:56 <edwardk> take a look at the http://hackage.haskell.org/packages/archive/trifecta/0.36.2/doc/html/src/Text-Trifecta-Parser-Token-Style.html multiLineComment example
23:48:13 <edwardk> when commentNesting = True, that deals with pairing up {-'s with -}'s for instance
23:49:53 <ddarius> No Dyck languages?
23:49:58 <edwardk> not yet
23:50:14 <edwardk> i need to figure out a nice way to add an arbitrary monoid to the rope
23:50:24 <edwardk> without exploding the amount of code i'm dealing with
23:50:36 <edwardk> or adding ruinous amounts of overhead
23:51:24 <edwardk> then i can fit the dyck languge stuff in. i need it before i can port the preprocessor though
