00:00:03 <DevHC> that's been fixed, but:
00:00:14 <DevHC> what's up with the date of 2002-10-25 in the ghc manpage?
00:00:48 <kmc> haha
00:00:54 <kmc> i'll bet nobody bothered to bump the date
00:06:11 <pelotom> quasiquoting seems pretty cool... has anyone ever used it to make an idiomatic Applicative notation like [| f a b c d |]?
00:08:23 <uniquenick> is there a way to define more than one function in a where?
00:08:37 <kmc> uniquenick, yeah, you just do
00:08:45 <kmc> line them up in the same column, if you're not using braces and semicolons
00:09:52 <kmc> pelotom, i think that's http://hackage.haskell.org/packages/archive/haskell-src-meta-mwotton/0.1.0/doc/html/Language-Haskell-Meta-QQ-Idiom.html
00:10:16 <kmc> also 'she' has it, but that's an external preprocessor
00:10:36 <kmc> i'm not sold on its utility though
00:10:49 <kmc> i think the existing operators for Applicative are fine
00:10:59 <kmc> it's better not to define custom syntax if you don't need to
00:11:11 <pelotom> oh? why not?
00:11:15 <pelotom> ah
00:11:47 <pelotom> what do you think of this? http://hpaste.org/51597
00:12:09 <kmc> not sure
00:12:18 <pelotom> it reads nice to me
00:18:37 <morolin> Does anyone know of a repository of well-written Haskell examples?  I've read through Learn You a Haskell, and I'm going through Real World Haskell while fidding with Project Euler problems/Hoogle, but it'd be nice to have a bunch of example code to show what good practices are.  Preferably commented?
00:18:54 <pelotom> bleh, got disconnected, did I miss anything?
00:19:37 <morolin> pelotom: a few joins/quits but no talking
00:19:58 <JoeyA> morolin: Hackage?  ;-)
00:20:09 <DevHC> should having 2 GHCs installed work? i have on in /usr/local/... and one in $HOME/local_hs/...
00:20:11 <kmc> morolin, i wrote http://mainisusuallyafunction.blogspot.com/2010/10/tour-of-real-toy-haskell-program-part-1.html as part of an answer to such questions :)
00:20:28 <kmc> Hackage is a great repository of well-written and poorly-written Haskell examples
00:20:32 <ehamberg> DevHC: yes.
00:20:44 <kmc> I consider most of what I've uploaded to be well-written; of course, that may not be true :)
00:20:45 <DevHC> i'm getting segfaults in hs_init() D:
00:20:55 <kmc> but at any rate you can ask me questions about it on irc
00:20:58 <ddarius> morolin: Just buy a book by Bird.
00:22:34 <pelotom> morolin: you could try searching for popular Haskell projects on github
00:23:26 <pelotom> https://github.com/languages/Haskell
00:23:29 <kmc> popularity ≠ quality
00:23:31 <ddarius> I search for popular programming languages when I want to find well-designed programming languages.
00:23:49 <kmc> hah bos is owning this page
00:24:16 <kmc> pandoc is a great program, but i haven't looked at its code
00:26:44 <pelotom> true, but quality is harder to quantify
00:26:53 <DevHC> </crash>. did i miss anything?
00:27:01 <kmc> xmonad is another nice program written in Haskell
00:27:10 <pelotom> maybe look at the Yesod codebase
00:27:33 <kmc> the xmonad code is pretty good, but there are things i would do differently
00:27:40 <kmc> but don't listen to me because i haven't finished my wm yet
00:27:44 <shachaf> kmc: Like the fundamental design of everything? :-)
00:27:56 * kmc wonders if morolin is still here... answer is "no"
00:27:59 <kmc> that too shachaf
00:28:00 * hackagebot peggy 0.1.0 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.1.0 (HideyukiTanaka)
00:28:02 * hackagebot bdelta 0.1 - Simple, fast binary diff/patch  http://hackage.haskell.org/package/bdelta-0.1 (JoeyAdams)
00:28:03 <shachaf> kmc: ...Have you started?
00:28:15 <kmc> yeah
00:28:38 <kmc> i have like 500 LoC
00:29:30 <shachaf> That's the entirety of xmonad 0.1!
00:29:46 <kmc> i know right
00:29:58 <shachaf> Is anything public yet?
00:29:59 <frerich2> I was recently toying with the idea of developing a DSL (a combinator library is what I was thinking of) in Haskell which can be used to express message-based IPC protocols using so that I can describe the possible handshakes and message exchanges much like I'd write a parser. Eventually, I'd like to generate C++ code out of that. Is anybody aware of a project which goes in this direction already?
00:30:04 <shachaf> I'm getting tired of metacity.
00:30:32 <kmc> i don't have much X code yet... it's mostly a mockup that draws the layout to a SDL window using DrawingCombinators
00:30:34 <kmc> so i can play with the UI
00:30:50 <kmc> to me, it's far from obvious what the best keyboard UI is for the window management model i have in mind
00:30:53 <Botje> frerich2: smells like session types
00:30:56 <kmc> that's one advantage of xmonad's dynamic approach
00:31:57 <shachaf> kmc: Yes, I've wondered about that before.
00:32:00 <kmc> data Mosaic = Split Axis Rational Mosaic Mosaic | Leaf [Window]
00:32:20 <shachaf> How's Ion's UI?
00:32:23 <kmc> is the model in question
00:32:23 <frerich2> Botje: Neat, I wasn't aware of this yet - googling for 'haskell session types' yielded some interesting hits. Turns out there's even a 'sessions' package on hackage. Thanks!
00:32:30 <kmc> shachaf, not great iirc, but it's been a long time
00:32:39 <kmc> i did most of my pane-splitting with the mouse
00:32:50 <shachaf> kmc: You should put the code online so we can all monitor your every move!
00:32:54 <kmc> heh
00:32:57 <kmc> maybe
00:33:07 <lpsmith> kmc:  so is this for your own learning,  or are you hoping to do something better than xmonad in a way that cannot be done by configuring/extending xmonad?
00:33:15 <shachaf> Ah, "maybe".
00:33:31 <shachaf> lpsmith: I think the idea was that it was different enough that you wouldn't gain that much from building it on top of xmonad.
00:33:34 <kmc> lpsmith, some of both, but i'm aiming for something very different from xmonad
00:33:35 <kmc> correct
00:33:45 <kmc> i won't claim it's universally better
00:33:47 <lpsmith> ah, cool
00:33:48 <kmc> i'll claim it's more what i want
00:33:58 <kmc> and i think what i want would be hard to implement cleanly on top of xmonad
00:34:19 <kmc> but the xmonad codebase is a good resource in writing your own wm in haskell, of course
00:34:37 <shachaf> kmc: The xmonad people were always talking about how they wanted to switch to a different X11 library.
00:34:41 <kmc> yeah
00:34:47 <shachaf> xcb, I think.
00:34:48 <lpsmith> I really should give xmonad a serious try;  unfortunately last time I tried it all my pretty fonts didn't work.
00:35:04 <kmc> lpsmith, fonts? xmonad doesn't display any text
00:35:12 <kmc> or does it somehow wreck text in other apps
00:35:34 <lpsmith> I know, right?   Somehow all my apps stopped using pretty fonts.
00:35:45 <shachaf> It might just be that gnome-settings-daemon wasn't running.
00:35:48 <kmc> yeah
00:35:55 <shachaf> So there's your fix. :-)
00:35:58 <lpsmith> hmm,  I'll keep that in mind :)
00:36:00 <lpsmith> thanks :)
00:36:03 <kmc> it sounds like something you could fix with a magic incantation in your xsession
00:36:24 <kmc> do you have the same problem when you use other window managers directly (as opposed to part of a "desktop environment")
00:36:31 <lpsmith> yeah, I didn't spend much time on it,  just fired it up.
00:36:47 <lpsmith> I haven't used a non-default window manager in like,  8+ years.
00:36:55 <lpsmith> ok, maybe not quite that long.
00:37:09 <DevHC> so i have PATH and LD_LIBRARY_PATH set to $HOME/local_hs/bin and $HOME/local_hs/lib, respectively. is that sufficient to compile and run programs with my local ghc?
00:38:08 <lpsmith> Really, I have better things to do than wrangle X Windows and other system administration tasks;  I use Ubuntu (I'm lame that way)
00:38:48 <lpsmith> I miss a number of things about WindowMaker though; which I used to use.
00:40:15 <kmc> lpsmith, that's funny because my friends who use Ubuntu keep complaining about Unity and all the bugs and the shit that breaks in every release
00:40:22 <kmc> and i'm blissfully unaffected by any of that
00:40:37 <kmc> so i think xmonad on a barebones X setup actually saves me time and annoyance
00:40:52 <lpsmith> hah,  I don't upgrade releases that often,  and I quickly shied away from Unity
00:40:56 <shachaf> kmc: Absolutely.
00:41:01 * shachaf is using metacity out of laziness.
00:41:12 <kmc> but haskell is lazier herp derp
00:41:22 <b_jonas> agreed
00:41:22 <shachaf> Probably because setting up xmonad in a reasonable way took a long time back in the day, or something.
00:41:28 <kmc> what i want (and might eventually write) is a haskell library for writing window managers
00:41:34 <kmc> which imposes fewer design decisions than xmonad does
00:42:05 <kmc> you can write your wm using the xmonad libraries but you inherit its notion of StackSet and layout algorithm and workspaces and screens and ...
00:42:49 <lpsmith> ahh... you couldn't implement a more traditional Macintosh-like windowing scheme
00:43:00 * hackagebot NestedSampling 0.1.3 - A port of John Skilling's nested sampling C code to Haskell.  http://hackage.haskell.org/package/NestedSampling-0.1.3 (IssacTrotts)
00:43:02 * hackagebot yices 0.0.0.11 - Haskell programming interface to Yices SMT solver  http://hackage.haskell.org/package/yices-0.0.0.11 (KiYungAhn)
00:43:02 <kmc> or a static tiling window manager
00:43:04 <kmc> which is what i want
00:43:44 <lpsmith> I can definitely see the utility to that
00:44:00 <lpsmith> especially if you really put the time and effort into a few good layouts for common situations
00:44:22 <kmc> eh
00:44:27 <kmc> it's not that much effort even
00:44:32 <kmc> usually i want just a few splits
00:44:37 <kmc> and i could draw on the screen where i want the splits
00:44:44 <kmc> but with xmonad i have to express that in some ass-backwards way
00:44:56 <kmc> by picking a "layout algorithm" and then setting "parameters" for that algorithm
00:45:15 <kmc> (i'm actually looking for a keyboard UI, not drawing per se, but you see i think)
00:45:38 <lpsmith> well, drawing on the screen sounds interesting,  people used to do some static layouts in their xsession
00:45:56 <b_jonas> I'm also running a barebones X session
00:46:25 <b_jonas> with icewm (a little bit patched on some machines) as the window manager but with unusual config options
00:46:54 <kmc> with xmonad, if i have a two-column layout and want a third column, i have to edit my config and add a new layout from the ThreeColumn module (which is a completely new piece of code) and then figure out what "messages" it accepts to adjust the number of windows in each column, and bind keys for those, and hope that the split ratios i want are even expressible at all
00:46:57 <kmc> it's kind of insane
00:47:43 <kmc> i want keybindings for "add new column/row" or "split this column/row" or "move this split"
00:47:58 <kmc> as far as i can tell it would be pretty ugly to implement this as an xmonad layout module
00:48:46 <kmc> i don't care about drawing the splits vs moving them with keys
00:48:50 <b_jonas> tee hee
00:48:53 <kmc> i prefer keyboard input actually
00:49:28 <kmc> but that's not what i'm emphasizing here
00:49:29 <b_jonas> yeah, I once thought fvwm would be a panacea to all my window manager problems, because it's simple but configurable. then I read the documentation.
00:50:29 <b_jonas> so anyway, as far as I know, there's no "ultimate" window manager yet
00:50:45 <b_jonas> if you want custom settings, you have to write code.
00:50:48 <kmc> yeah there never will be
00:51:07 <kmc> i'm fine with writing code to customize
00:51:10 <kmc> i like this aspect of xmonad
00:51:30 <b_jonas> apparently window managment is like editor, you can't make a program that can do anything window manager without it doing everything else.
00:51:46 <b_jonas> um, does that parse?
00:51:53 <DevHC> not here :>
00:51:55 <b_jonas> let me rephrase
00:52:22 <b_jonas> window managers are like editors: you can't have a program that does anything you want a window manager to do unless that program also does everything else as well
00:52:24 <lpsmith> Yeah, I understood. I think.  Like emacs
00:52:37 <kmc> i don't think that's true at all
00:52:40 <shachaf> Emacs has a window manager, you know.
00:52:56 <kmc> unless by "does everything else" you mean "is a library written in a general-purpose language"
00:53:21 <lpsmith> hah, I didn't know.  that doesn't surprise me though.   Part of the default distro, or somebody wrote some elisp once?
00:53:52 <shachaf> Someone wrote some elisp, but I think it actually has nonzero users.
00:54:14 <DevHC> the ULTIMATE WM would be like X MiB in binary size (where X is large :P), and you would spend your lifetime learning it
00:54:23 * shachaf envies LISP people for their ease of dynamically changing code at runtime and such.
00:54:25 <kmc> and it  would actually be GHC plus the xlib bindings
00:55:12 <b_jonas> shachaf: what? isn't smalltalk better than lisp in that?
00:55:19 <lpsmith> XWEM's website hasn't been updated in like 8 years
00:55:21 <shachaf> b_jonas: Smalltalk too.
00:55:57 <lpsmith> I think it's safe to say it probably has close to 0 users
00:56:03 <shachaf> XWEM?
00:56:12 <shachaf> I was talking about StumpWM.
00:56:13 <lpsmith> Emacs windows manager
00:56:29 <shachaf> Wait, no, I wasn't.
00:56:32 <shachaf> That's Common Lisp.
00:56:38 * shachaf doesn't remember what he was talking about anymore.
00:56:42 <lpsmith> lol :)
00:56:58 <kmc> we were talking about how Haskell is better than all other programming languages and everyone who doesn't use it is dumb
00:57:01 <kmc> i'm pretty sure
00:57:04 <shachaf> Oh, right.
00:57:06 <shachaf> @brain
00:57:07 <lambdabot> Here we are, Pinky--at the dawn of time!
00:57:15 <kmc> @ghc
00:57:16 <lambdabot> ghc says: Implicit-parameter bindings illegal in a parallel list comprehension
00:57:16 <shachaf> "What we talk about every night, Pinky"
00:57:35 <shachaf> "parallel list comprehension"? Has someone been updating @ghc?
00:57:45 <kmc> it's not exactly a new extension
00:57:59 <kmc> it was there in GHC 6.6 when I started, I think
00:58:11 <lpsmith> yeah, it's really old
00:58:12 <kmc> [ f x y | x <- xs | y <- xs ]  ≡  zipWith f xs ys
00:58:35 <lpsmith> I think it might have even gotten in sometime in GHC 5
00:58:40 <b_jonas> what's this lambdabot ghc command? does it print only real messages? does it combine messages from parts?
00:58:55 <b_jonas> oh, I should just check the source
00:59:35 <lpsmith> http://www.haskell.org/ghc/docs/5.04/html/users_guide/syntax-extns.html#PARALLEL-LIST-COMPREHENSIONS
00:59:47 <shachaf> Oh.
00:59:56 * shachaf thinks of GHC 6.6 as pretty new.
01:00:08 <kmc> so what are some cool GHC extensions which are no longer supported?
01:00:17 <kmc> there's linear implicit parameters
01:00:18 <shachaf> LANGUAGE Haskell1.4
01:00:52 <kmc> i wish
01:00:56 <kmc> then i could be a true hipster
01:01:17 <b_jonas> hmm, I can't find it
01:02:28 <cicatristeza> hello i am trying to install haskell on arch linux. whats the best way?
01:02:37 <shachaf> What are linear implicit parameters?
01:02:40 <kmc> cicatristeza, Haskell is not a piece of software
01:02:47 <kmc> cicatristeza, perhaps you want to install Haskell Platform or GHC
01:02:50 <lpsmith> actually parallel list comprehensions appear to be new with 5.0
01:03:02 * shachaf remembers the existence of the Google.
01:03:02 <kmc> @google haskell platform arch
01:03:05 <lambdabot> http://www.archlinux.org/packages/extra/i686/haskell-platform/
01:03:05 <lambdabot> Title: Arch Linux - haskell-platform 2011.2.0.0-4 - Package Details
01:03:20 <shachaf> kmc: Should be called the GHC Haskell platform, right?
01:03:26 <kmc> srsly
01:04:01 <kmc> perhaps i can use Häskëll as a synonym for GHC Haskell
01:04:44 <int-e> kmc, is that a condensed form of Haskell''''?
01:04:46 <shachaf> How about Наskеll?
01:05:01 <shachaf> > "Наskеll"
01:05:02 <lambdabot>   "\1053\1072sk\1077ll"
01:05:09 <kmc> or ןןǝʞsɐɥ
01:05:18 <shachaf> That should be Caleskell.
01:05:18 <mercury^> Häskëll is even pronounced the same way as Haskell.
01:06:02 <kmc> cool, GHC5 had pattern guards
01:06:02 <ddarius> shachaf: A horrible idea.
01:06:10 <ddarius> Pattern guards are rather old.
01:06:22 <shachaf> ddarius: Which one?
01:06:29 <ddarius> Linear implicit parameters.
01:06:30 <lpsmith> It looks like most of GHC5 extensions still work.
01:06:44 <lpsmith> Hugs supported TREX, among other things,  which has disappeared
01:06:51 <ddarius> An extension has to be rather horrible for it to be removed.
01:06:52 <int-e> shachaf: Naskyell?
01:07:07 <kmc> TRex isn't in the latest Hugs?
01:07:13 <kmc> nyanskell
01:07:17 <Eduard_Munteanu> Heh.
01:07:27 <kmc> -XGenerics was removed recently
01:07:43 <kmc> was not particularly horrible, but i think not that useful and it's been replaced by something better
01:07:47 <kmc> better (?)
01:08:11 <int-e> shachaf: funny though ... had to figure out the hard way that these were cyrillic letters.
01:08:22 <kmc> i guess -XRecursiveDo is still supported
01:08:33 * shachaf isn't sure he wants to know what "the hard way" is.
01:10:37 <lpsmith> Honestly,  I seem to recall more trouble was caused by e.g. qualified names and changing the lexical syntax of comments than disappearing extensions
01:10:48 <kmc> when did the lexical syntax of comments change?
01:11:01 <lpsmith> circa 2000 or 2001
01:11:07 <lpsmith> --* used to be a comment
01:11:11 <kmc> ah, that
01:11:15 <lpsmith> now it's an infix operator
01:12:04 <kmc> > let (--*) = (+) in 2 --* 3
01:12:05 <lambdabot>   5
01:12:15 <kmc> so this means GHC is not Haskell 98 compliant?
01:12:19 <kmc> or is there a way to turn it off?
01:12:28 <lpsmith> hmm
01:12:33 <shachaf> #define --* + in 2 --* 3
01:12:35 <kmc> or did they amend the Haskell 98 Report
01:12:40 <lpsmith> maybe that's H98, I'm not sure
01:12:50 <lpsmith> maybe I just learned of this corner case around that time
01:13:17 <lpsmith> though the thing is,  I remember helping a faculty member with some recently published code from another faculty member at another university that didn't work for exactly that reason
01:13:40 <lpsmith> Fortunately I'd learned about this situation like literally the night before he asked about it.
01:14:01 <kmc> convenient
01:14:06 <kmc> i'm always surprised by how often that happens
01:14:20 <shachaf> I'm always surprised by how constantly it doesn't happen.
01:14:30 <DevHC> ghc no longer does _stub.c files?
01:17:43 <lpsmith> yeah,  --* being an infix operator is H98
01:18:12 <lpsmith> I don't know if they amended the report, or that was original H98.  Maybe the code was for a pre-98 version of hugs or something
01:18:28 <lpsmith> maybe the code wasn't as recent as I seem to recall
01:19:28 <DevHC> no ghc experts here? :>
01:23:00 * hackagebot prolog-graph-lib 0.1 - Generating images of resolution trees for Prolog queries.  http://hackage.haskell.org/package/prolog-graph-lib-0.1 (MatthiasBartsch)
01:23:02 * hackagebot prolog-graph 0.1.0.1 - A command line tool to visualize query resolution in Prolog.  http://hackage.haskell.org/package/prolog-graph-0.1.0.1 (MatthiasBartsch)
01:26:32 <DevHC> http://hpaste.org/new
01:26:33 <DevHC> A web handler threw an exception. Details:
01:26:33 <DevHC> Language/Preprocessor/Cpphs/Position.hs:(88,0)-(90,51): Non-exhaustive patterns in function cpp2hask
01:26:53 <Feierfuchs> @pl \x -> [(x, False), (x, True)]
01:26:53 <lambdabot> ap ((:) . flip (,) False) (return . flip (,) True)
01:27:07 <Feierfuchs> :t ap
01:27:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:27:43 <Jafet> (`zip` [False,True]) . repeat
01:33:01 <hpaste_> FFFFFFFFFFFIIIIIIII pasted “TROLOLOLOLO” at http://hpaste.org/51606
01:33:06 <cicatristeza> in emacs haskell-mode, how do i exit the ghci?
01:33:40 <DevHC> does this backtrace show anything to anyone? http://hpaste.org/51606
01:38:38 <DevHC> btw
01:38:55 <DevHC> -btw
01:43:00 * hackagebot hashmap 1.2.0.1 - Persistent containers Map and Set based on hashing.  http://hackage.haskell.org/package/hashmap-1.2.0.1 (MilanStraka)
01:45:12 <DevHC> this channel is as dead as my granny
01:45:36 <rostayob> DevHC: no it isn't
01:45:48 <rostayob> this channel is THE BEST
01:45:49 <rostayob> ok?
01:46:32 <DevHC> roger that :]
01:46:51 <quicksilver> just nobody around who knows GHC internals enough to comment on your error, devhc
01:47:03 <rostayob> DevHC: I didn't even get your question
01:47:19 <DevHC> want them?
01:47:32 <rostayob> want what?
01:47:37 <DevHC> the questions
01:47:44 <rostayob> sure
01:47:55 <rostayob> questions are interesting anyway ehe
01:48:29 <DevHC> i have 2 GHCs installed, one in /usr/local/... and one in $HOME/local_hs/.... should that work?
01:48:39 <DevHC> cuz i'm getting segfaults in hs_init()
01:49:14 <DevHC> i have added $HOME/local_hs/bin to PATH and $HOME/local_hs/lib to LD_LIBRARY_PATH
01:49:16 <whald> if I have a lengthy computation in ST, is there some clever way to get progress reports to the user from that? i mean besides the obvious doing "many not-so-lengthy computations" from IO
01:49:28 <DevHC> also
01:49:39 <DevHC> has GHC stopped creating _stub.c files?
01:50:05 <rostayob> DevHC: ok, I can't help you
01:50:05 <DevHC> segfault bt btw: http://hpaste.org/51606
01:50:10 <rostayob> why are you doing that?
01:50:27 <DevHC> lol
01:50:30 <quicksilver> I can helpfully tell you that having two GHCs installed should be fine
01:50:34 <DevHC> none of ur business?
01:50:35 <quicksilver> I can't explain why it isn't working for you though :(
01:50:37 <DevHC> :P
01:50:42 <quicksilver> maybe the validation is something though.
01:50:49 <quicksilver> all the developers have multiple GHCs installed
01:50:53 <DevHC> :o
01:51:01 <quicksilver> you might have better luck in #ghc although that's normally quiet at this time in the morning
01:51:25 <rostayob> DevHC: mah just curious
01:51:46 <DevHC> ity
01:51:57 <DevHC> -ity
01:52:31 <Jafet> @quote (whald|oasis)
01:52:32 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
01:52:48 <rostayob> ahah
01:53:33 <rostayob> is Debug.Trace just "unsafePerformIO . putStrLn"? or is it something different?
01:53:52 <Jafet> That's a valid definition, yes
01:54:08 <whald> Jafet: I know about trace, but unfortunately I'd like to do something more elaborate that just write a line to the console
01:54:46 <whald> I envisioned something like a channel where I can put things in in ST and take them out in IO
01:54:54 <Jafet> Whatever you want to do, you can stick it in unsafePerformIO
01:55:15 <whald> Jafet: but isn't that unsafe?
01:55:52 <Jafet> It may be unsafe.
01:55:55 <rostayob> whald: yes, but if you're debugging
01:56:21 <rostayob> whald: but yes with unsafePerformIO haskell is not there to save you :P
01:56:44 <rostayob> also, there are 2 or 3 rules to follow when using it (like not inlining the function using it)
01:56:57 <Jafet> GHC is generally quite nice about unsafePerformIO.
01:57:41 <ddarius> Jafet: Stick it in an STM action.
01:57:43 <whald> basically I have a computation that can easily run for hours, and i want a progress bar 'cause i want it nice :-) so the only "real" way is to split the computations and drive the whole thing from IO, where I can do what I want -- there are no concepts around this?
01:58:09 <Jafet> Until you involve unpredictable execution orders
01:59:00 <Jafet> ddarius: even then, ghc makes your action quit rather than do something undefined
01:59:10 <rostayob> whald: well if you want to display a progress bar somewhere you have to go through IO
01:59:20 <b_jonas> whald: you can use a progress bar without splitting the computation: print 0%, do the computation, print 10%, wait as much time as the computation took, print 20%, wait, print 30%, etc
01:59:47 <Jafet> b_jonas: heh
01:59:53 <obiwahn> > fix (\b->"mrgl"++b)
01:59:57 <lambdabot>   mueval-core: Time limit exceeded
02:00:08 <Jafet> Or do it the windows way with a cyclic bar
02:00:08 <obiwahn> > fix ("mrgl"++)
02:00:11 <lambdabot>   "mrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmr...
02:00:34 <obiwahn> why does it evalutate to different things?
02:00:41 <rostayob> obiwahn: does it?
02:00:44 <Jafet> > take 20 $ fix (\b -> "mrgl"++b)
02:00:46 <lambdabot>   "mrglmrglmrglmrglmrgl"
02:00:50 <Jafet> > fix (\b -> "mrgl"++b)
02:00:51 <obiwahn> > take 10 fix ("mrgl"++)
02:00:52 <lambdabot>   Couldn't match expected type `[a]'
02:00:52 <lambdabot>         against inferred type `(a1 -> a1...
02:00:52 <lambdabot>   "mrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmr...
02:01:00 <Jafet> lambdabot hiccuped, that's all
02:01:06 <rostayob> obiwahn: it's lambdabot fault
02:01:30 <obiwahn> ok:)
02:01:36 <obiwahn> it should be the same?!
02:01:42 <quicksilver> they aren't different things.
02:01:49 <rostayob> obiwahn: yes, they're bot infinite lists, which is the correct answer
02:01:50 <quicksilver> the first one didn't evaluate it got killed
02:02:18 <Jafet> @pl \b -> "mrgl"++b
02:02:18 <lambdabot> ("mrgl" ++)
02:03:12 <Jafet> whald: another way is to have your action produce a list of checkpoints while it computes, and have the progress display block on evaluation of the list
02:03:28 <rostayob> obiwahn: you're asking for a list xs such that ("blah" ++ xs) == xs
02:03:57 <obiwahn> i am asking for a function:)
02:04:02 <rostayob> xs is, of course, an infinite list of "blah"s :P
02:04:15 <rostayob> :t fix
02:04:17 <lambdabot> forall a. (a -> a) -> a
02:04:44 <Jafet> whald: do let computation :: a -> ST s [()]; let meter = zipWith const [1..] $ runST computation; mapM_ (\n -> putStrLn (show n ++ "%")) meter;
02:05:02 <rostayob> obiwahn: you're asking for a value
02:05:03 <Jafet> Er wait, that doesn't work
02:05:05 <DevHC> cycle "FU" is also such a list
02:05:11 <Jafet> Well, you figure it out
02:05:37 <rostayob> DevHC: well cycle "FU" == concat (repeat "FU")
02:05:38 <DevHC> no w8
02:06:06 <DevHC> cycle "FU" is a fixpoint of (++"blah")
02:06:25 <rostayob> you mean cycle "blah"
02:06:29 <DevHC> no
02:06:32 <DevHC> :]
02:06:34 <rostayob> why "FU"?
02:06:42 <hpaste_> Nel pasted “parse cv” at http://hpaste.org/51607
02:06:44 <DevHC> because that is more epic than "blah"
02:06:57 <rostayob> yeah but then cycle "FU" is a fixpoint of (++ "FU") :P
02:07:03 <DevHC> lol
02:07:06 <rostayob> not of (++ "blah")
02:07:11 <obiwahn> -- fix (\b->"mrgl"++b) <-- is that a function?
02:07:33 <DevHC> cycle "FU" is a fixpoint of both (++"blah") and (++"FU")
02:08:03 <rostayob> DevHC: what? why?
02:08:25 <DevHC> obiwahn: no, ("mrgl"++) is a function, but fix ("mrgl"++) isn't
02:08:38 <rostayob> obiwahn: we had this discussion yesterday here, turns out that that's not a function
02:08:40 <DevHC> rostayob: observe:
02:08:44 <rostayob> http://conal.net/blog/posts/everything-is-a-function-in-haskell
02:08:51 <DevHC> > cycle "FU"
02:08:51 <Jafet> @type fix ("mrgl"++)
02:08:52 <lambdabot>   "FUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFU...
02:08:52 <lambdabot> [Char]
02:08:57 <DevHC> > cycle "FU" ++ "blah"
02:08:58 <lambdabot>   "FUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFUFU...
02:09:04 <DevHC> i see no difference :P
02:09:06 <Jafet> Is [Char] a type of functions?
02:09:26 <rostayob> DevHC: oh right, it's (++ "FU") not ("FU" ++)
02:09:42 <rostayob> fair enough
02:09:53 <DevHC> repeat 'F' ++ repeat 'U'
02:09:54 <DevHC> > repeat 'F' ++ repeat 'U'
02:09:56 <lambdabot>   "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
02:10:13 <obiwahn> the fix gives me a function so that f x = x ?!
02:10:27 <rostayob> yeah yeah, but cycle "FU" is not a fixed point of ("blah" ++)
02:10:32 <obiwahn> so why is fix ("mrgl"++) not a function?
02:10:39 <rostayob> which is what I thought that meant, but it didn't :P
02:10:50 <quicksilver> obiwahn: fix gives you a value "x" such that f x = x.
02:10:51 <Jafet> obiwahn: what is a function?
02:10:51 <rostayob> obiwahn: fix ("mrgl" ++) gives you a value
02:10:55 <quicksilver> obiwahn: (not a function)
02:11:10 <obiwahn> no
02:11:12 <Jafet> rostayob: that isn't a function value
02:11:34 <obiwahn> @src fix
02:11:35 <lambdabot> fix f = let x = f x in x
02:11:44 <DevHC> in one terminology, everything is a function, ie: (5) is a function taking 0 arguments, (++) is a function taking 2 arguments, etc.
02:11:49 <rostayob> Jafet: function value?
02:12:00 <osfameron> @where fix
02:12:00 <lambdabot> I know nothing about fix.
02:12:01 <DevHC> in another terminology a function is what u can apply to other things
02:12:08 <Jafet> Some values are functions.
02:12:26 <quicksilver> DevHC: (5) is a function taking 0 arguments is neither useful terminology nor common terminology.
02:12:28 <rostayob> Jafet: ok, define function then
02:12:50 <DevHC> quicksilver: it is, however, 1337 terminology
02:13:00 <Jafet> rostayob: a value of type a -> b, for some types a, b
02:13:24 <Jafet> Well, that gives the types of all functions.
02:13:28 <ddarius> > 5 5
02:13:29 <lambdabot>   5
02:13:32 <rostayob> Jafet: ok, then "fix (++ "blah")" is not a function
02:13:49 <rostayob> well on lambdabot numbers are strange, but that's another story :P
02:14:25 <DevHC> lambdabot is WRONG(TM), it just applied 5 to 5 !
02:14:29 <Jafet> rostayob: yes. Don't let the trolls mulch your head.
02:14:40 <b_jonas> ah, is that like maple? I think maple has numbers callable.
02:14:43 <rostayob> > fmap (+ 1) 5
02:14:44 <lambdabot>   No instance for (GHC.Num.Num (f a))
02:14:44 <lambdabot>    arising from a use of `e_115' at <in...
02:14:46 <b_jonas> > 3 8
02:14:47 <lambdabot>   3
02:14:52 <quicksilver> to be precise, then, what I meant is:
02:14:59 <quicksilver> DevHC: (5 :: Int) is a function taking 0 arguments is neither useful terminology nor common terminology.
02:14:59 <rostayob> :t flip fmap 5
02:15:00 <lambdabot> forall a b (f :: * -> *). (Functor f, Num (f a)) => (a -> b) -> f b
02:15:09 <quicksilver> 5 :: Num a => a is another matter entirely.
02:15:12 <b_jonas> :t (let { uh = 3; vh = uh 5; } in uh)
02:15:13 <lambdabot> forall t. (Num t) => t
02:15:17 <opqdonut> > 1 2 3 4 5
02:15:18 <lambdabot>   1
02:15:19 <DevHC> quicksilver: it is, however, 1337 terminology
02:15:31 <b_jonas> um,
02:15:37 <b_jonas> does lambdabot has monomorphism restriction on?
02:15:42 <rostayob> in lambdabot, numbers are functors.
02:16:08 <rostayob> > fmap 5 5
02:16:09 <lambdabot>   No instance for (GHC.Show.Show (f b))
02:16:09 <lambdabot>    arising from a use of `M3464012129...
02:16:15 <rostayob> pff
02:16:36 <b_jonas> > let { u = []; } in (u ++ [5 :: Int], u ++ [)
02:16:37 <lambdabot>   <no location info>: parse error on input `)'
02:16:42 <DevHC> @where monomorphismrestriction
02:16:42 <lambdabot> I know nothing about monomorphismrestriction.
02:16:43 <b_jonas> > let { u = []; } in (u ++ [5 :: Int], u ++ [True :: Bool])
02:16:44 <lambdabot>   ([5],[True])
02:16:53 <b_jonas> yep, lambdabot has monomorphism restriction off I think
02:16:55 <b_jonas> hm
02:17:10 <b_jonas> then how do I ask it about the type of 3 it has in (3 5) ?
02:17:23 <b_jonas> there must be some trick for that
02:17:46 <b_jonas> perhaps with higher-order types or something
02:17:46 <quicksilver> b_jonas: that test doesn't prove it; the monomorphism restriction doesn't affect parametric polymorphism
02:17:55 <int-e> @type \f -> (3 `asTypeOf` f) 5
02:17:56 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => (t1 -> t) -> t
02:18:04 <quicksilver> :t let x = 3 in const (x 5) x
02:18:05 <lambdabot> forall a. (Num a) => a
02:18:20 <quicksilver> :t let x = 3 in const x (x 5)
02:18:21 <lambdabot> forall a. (Num a) => a
02:18:31 <quicksilver> hrm...
02:18:41 <b_jonas> hmm, wait, maybe I'll have to look up how the monomorphism restriction works
02:18:44 <rostayob> :t let {x = 3; y = x 5} in x
02:18:45 <lambdabot> forall t. (Num t) => t
02:18:59 <quicksilver> it doesn't work because lets generalise
02:18:59 <int-e> heh. no monomorphism restriction means it's generalized for each instance.
02:19:04 <Jafet> :t (0 `asTypeOf` ?a) 0
02:19:05 <lambdabot> forall t t1. (Num (t1 -> t), ?a::t1 -> t, Num t1) => t
02:19:08 <engla> how does the number as functor work?
02:19:18 <obiwahn> -- fix (rstring = \_ -> "mrgl"++rstring)
02:19:18 <rostayob> engla: magic
02:19:20 <Jafet> Numbers aren't functors
02:19:21 <b_jonas> ah wait
02:19:27 <obiwahn> > fix (rstring = \_ -> "mrgl"++rstring)
02:19:28 <lambdabot>   <no location info>: parse error on input `='
02:19:32 <quicksilver> :t (\x -> const x (x 5)) 3
02:19:33 <lambdabot> forall t b. (Num t, Num b) => t -> b
02:19:35 <rostayob> Jafet: they are here
02:19:44 <obiwahn> > fix (rstring _ = "mrgl"++rstring)
02:19:45 <lambdabot>   <no location info>: parse error on input `='
02:19:50 <b_jonas> quicksilver: yep, that's the way, thanks
02:19:58 <quicksilver> b_jonas: :) lambdas don't generalise
02:20:02 <quicksilver> even with DMR off.
02:20:10 <b_jonas> yep
02:20:20 <obiwahn> > fix (rstring _ = "mrgl"++(rstring 1))
02:20:22 <lambdabot>   <no location info>: parse error on input `='
02:20:27 <b_jonas> not unless you add extra type signatures
02:20:29 <quicksilver> rostayob, Jafet : to be precise, there is one Num instance which is also a Functor
02:20:53 <DevHC> > let rstring _ = "mrgl" ++ (rstring undefined) in fix rstring
02:20:55 <lambdabot>   "mrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmr...
02:21:00 <quicksilver> Nums in general can't be Functors since the kind is wrong...
02:21:18 <Jafet> Wait, which instance?
02:21:25 <b_jonas> ah, so this is for the
02:21:29 <b_jonas> > (1 + sin) 1
02:21:30 <lambdabot>   1.8414709848078965
02:21:30 <rostayob> quicksilver: yeah but I can't remember what instance is it and how it works
02:21:30 <b_jonas> thing
02:21:32 <hpaste_> Nel pasted “parse cv” at http://hpaste.org/51608
02:21:46 <quicksilver> it's the function one I think
02:21:53 <ddarius> > (sin^2 + cos^2) 2
02:21:54 <rostayob> quicksilver: Num (a -> b)?
02:21:55 <lambdabot>   1.0
02:21:57 <quicksilver> unless there is something more general I'm not aware of
02:21:58 <quicksilver> yes.
02:22:00 <b_jonas> lambdabot is strange
02:22:08 <rostayob> oh yes
02:22:12 <rostayob> :t flip fmap 5
02:22:13 <lambdabot> forall a b (f :: * -> *). (Functor f, Num (f a)) => (a -> b) -> f b
02:22:27 <Jafet> a->b isn't generally a functor
02:22:29 <rostayob> mh
02:22:39 <quicksilver> yes it is
02:22:42 <quicksilver> it's a monad too
02:22:47 <Jafet> That's (a->)
02:22:50 <rostayob> Jafet: ((->) a) is
02:22:50 <quicksilver> well the (a->) part of it
02:22:53 <rostayob> eh
02:23:01 <Jafet> So yeah, even the kind is wrong
02:23:04 <obiwahn> id say it gives me beack the function and because the function does not care about params it is instantly caleld and the result is shown
02:23:13 <rostayob> so it should be Num (a ->)
02:23:14 <quicksilver> Jafet: but you use fmap on values of kind * anyway.
02:23:15 <Jafet> I don't know what you're all on about
02:23:17 <rostayob> boh. i don't know.
02:23:26 <quicksilver> > fmap (+1) 5
02:23:27 <lambdabot>   No instance for (GHC.Num.Num (f a))
02:23:27 <lambdabot>    arising from a use of `e_115' at <in...
02:23:38 <b_jonas> what?
02:23:40 <quicksilver> > (fmap (+1) 5) $ 12
02:23:41 <lambdabot>   6
02:23:56 <quicksilver> Jafet: ^^ that; a number '5' being a functor.
02:24:14 <rostayob> quicksilver: why doesn't fmap (+1) 5 work?
02:24:28 <rostayob> ah you have to apply it to something
02:24:31 <quicksilver> ambiguous type
02:24:36 <rostayob> but the error message is horrible
02:24:40 <quicksilver> yup
02:24:51 <Jafet> That looks to me like 5 "contains a" functor, but isn't quite one
02:25:06 <rostayob> is there some code being generated? 'e_115'?
02:25:41 <rostayob> does lambdabot replaces your vars with unique names?
02:25:58 <rostayob> man lambdabot's code must be interesting ahah
02:26:29 <rostayob> even the fact that
02:26:31 <rostayob> > x + 5
02:26:32 <lambdabot>   x + 5
02:26:45 <rostayob> :t x + 5
02:26:46 <lambdabot> Expr
02:26:52 <DevHC> > (x + 1)^2
02:26:53 <lambdabot>   (x + 1) * (x + 1)
02:27:00 <rostayob> yo
02:27:04 <DevHC> > (x + 1) * (x + 1)
02:27:05 <lambdabot>   (x + 1) * (x + 1)
02:27:07 <opqdonut> rostayob: that's actually not lambdabot's code
02:27:13 <opqdonut> that's just Data.Expr or whatever
02:27:28 <rostayob> opqdonut: data.expr?
02:27:31 <opqdonut> a library
02:27:36 <DevHC> > x^2
02:27:38 <lambdabot>   x * x
02:27:41 <DevHC> > x^1337
02:27:43 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
02:27:45 <rostayob> well the fact that it just falls back to Expr if it can't interpret the expression is kind of strange
02:27:51 <opqdonut> the variable x in lambdabot's environment is bound to something like Var "x"
02:27:57 <opqdonut> no magic involved
02:27:58 <opqdonut> :t x
02:27:59 <lambdabot> Expr
02:28:04 <rostayob> :t u
02:28:05 <lambdabot> Expr
02:28:09 <DevHC> > y^1337
02:28:10 <lambdabot>   y * y * (y * y) * (y * y * (y * y)) * (y * y * (y * y) * (y * y * (y * y)))...
02:28:11 <rostayob> :t q
02:28:12 <lambdabot> Expr
02:28:13 <opqdonut> :t f
02:28:14 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
02:28:19 <opqdonut> :t xx
02:28:20 <lambdabot> Not in scope: `xx'
02:28:22 <opqdonut> you see?
02:28:32 <rostayob> opqdonut: ok, it's still kind of hacky.
02:28:48 <quicksilver> sure, but it's not a lambdabot hack
02:28:50 <opqdonut> yeah
02:28:51 <quicksilver> it's a haskel hack :)
02:28:52 <b_jonas> and... is there some function that substitutes stuff in an Expr?
02:28:52 <engla> any docs for all lambdabot changes?
02:28:52 <quicksilver> http://hackage.haskell.org/package/simple-reflect
02:29:09 <b_jonas> ah
02:29:25 <rostayob> actually simple-reflect is really cool
02:29:37 <opqdonut> it is
02:29:39 <Jafet> Not really a hack, either
02:29:56 <b_jonas> > expr (2+2)
02:29:56 <Jafet> It's just a number that remembers everything you did to it
02:29:57 <lambdabot>   2 + 2
02:30:22 <rostayob> the weird thing is that I can just write them directly in the prompt
02:31:32 <b_jonas> hmm, strange
02:31:44 <b_jonas> I can't find such a function in simple-reflect
02:31:51 <b_jonas> is that because it's not possible, or just not implemented?
02:32:18 <rostayob> b_jonas: what would be the type of that function?
02:32:40 <b_jonas> rostayob: I guess String -> Expr -> Expr -> Expr
02:32:56 <DevHC> obiwahn: i am you father
02:33:05 <whald> is there some library exposning gcc's "__sync_fetch_and_add" or similar from ghc?
02:33:20 <rostayob> b_jonas: ok then I misunderstood, what are you looking for again :P?
02:33:55 <Jafet> What on earth is __sync_fetch_and_add and why would you use it?
02:34:56 <b_jonas> rostayob: I'd like a function subst such that (subst "x" y (f x + 1)) evaluates to (f y + 1); where f, x, y are from simple-reflect
02:35:09 <b_jonas> rostayob: subst :: String -> Expr -> Expr -> Expr
02:35:49 <rostayob> b_jonas: you can just generate a function with fromExpr
02:36:02 <whald> Jafet: it's an thread-safe way to increment a value without explicit locking. it's often cheap because of hardware support, http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html
02:36:12 <rostayob> b_jonas: http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/Debug-SimpleReflect-Expr.html#v:fromExpr
02:36:28 <b_jonas> what does that do?
02:36:38 <Jafet> whald: and how would you expect to use some gcc intrinsic from ghc haskell?
02:36:47 <b_jonas> how do I use it this way?
02:36:59 <rostayob> > fromExpr (x + 1) 5
02:37:00 <lambdabot>   Not in scope: `fromExpr'
02:37:04 <Jafet> I assume you don't want to modify ghc to work with that builtin.
02:37:22 <rostayob> b_jonas: I've never used it, but from the instances I suppose it converts your expr in a function to use
02:37:29 <whald> Jafet: no, but I could imagine that it's possible to have a package which exposes that functionality
02:37:36 <Jafet> Calling that from the FFI sounds like a huge waste of time, for you and for the computer.
02:37:50 <int-e> @hackage bits-atomic
02:37:51 <lambdabot> http://hackage.haskell.org/package/bits-atomic
02:38:13 <b_jonas> oh well, if I want to play with symbolic num expressions, I have other libraries for that :-)
02:38:23 <whald> Jafet: what I basically need is a rather large vector of floats, the then have some threads increment the values in that vector
02:38:38 <b_jonas> non-haskell ones I mean
02:38:50 <b_jonas> whald: floats?
02:39:13 <whald> b_jonas: yes, the Float type
02:39:58 <Jafet> int-e: Is the FFI overhead really so low as to make that package feasible?
02:40:19 <rostayob> b_jonas: actually no, since the only base FromExpr instance is Expr itself
02:40:23 <int-e> whald: there's no such support for floats - you'll have to do with compareAndSwap and casts
02:40:28 <whald> if I give every thread it's own scratchspace for doing the accumulation and merge them afterwards it's a huge waste of memory, and evenen worse is the cache thrashing
02:40:49 <int-e> Jafet: an unsafe call is just a plain C function call - some register shuffling and a call instruction.
02:40:56 <rostayob> b_jonas: in other words, it doesn't seem to be possible to do what you want to
02:40:59 <rastapopoulos2> hi, can someone help me with this : http://stackoverflow.com/questions/7498343/parse-a-cv-file
02:41:05 <int-e> Jafet: it's the safe calls that are truly expensive.
02:41:10 <Jafet> An unsafe call blocks the whole RTS, afaik
02:41:23 <Jafet> Not something fun to do with threads
02:41:32 <int-e> Jafet: yes, but those operations do not block. that's the whole point.
02:41:57 <rostayob> Jafet: does it? even with -threaded?
02:41:59 <Jafet> Oh, I see.
02:42:10 <rastapopoulos2> hpaste version : http://hpaste.org/51608
02:42:22 <rastapopoulos2> ?
02:42:24 <Jafet> rostayob: especially with -threaded.
02:43:04 <b_jonas> rostayob: thanks
02:43:38 <rostayob> Jafet: why "especially"?
02:44:08 <int-e> rostayob: especially in the threaded RTS. "blocking the RTS" meaning that the RTS cannot do garbage collection until the foreign call returns. other work, in particular normal allocations, can proceed concurrently.
02:44:25 <Jafet> -threaded doesn't magically give you N RTSes, you still have one RTS
02:44:29 <int-e> rostayob: especially since the term is meaningless in the non-threaded RTS.
02:44:44 <obiwahn> http://conal.net/blog/posts/everything-is-a-function-in-haskell <- the guy is dumb
02:45:10 <rostayob> int-e: oh, ok. so in a safe call, there can be no thread switching?
02:46:02 <Jafet> For a safe call, the RTS spends a few hundred instructions setting things up so that it is safe to run along with the ccall.
02:46:25 <Jafet> Clearly, that's not going to work for atomic memory intrinsics.
02:47:48 <rostayob> ohhhhh ok I misread, I thought you were saying that safe calls blocked
02:48:01 <rostayob> while I knew the opposite, from this blog post http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
02:48:04 <rostayob> ok, makes sense now
02:48:24 <rastapopoulos2> my code doesn't compile, i seem to have a problem with thi lookup function but can't resolve it
02:49:38 <int-e> rostayob: from an FFI user's perspective, unsafe calls must not block. safe calls may. ;-)
02:50:22 <rostayob> int-e: yeah
02:51:17 <rastapopoulos2> anyone?
02:51:21 <quicksilver> "blocking the whole RTS" doesn't block other threads though
02:51:31 <quicksilver> (unless those other threads are stuck waiting for GC)
02:51:51 <rostayob> rastapopoulos2: it's usually better to psate the error as well
02:52:15 <koeien> rastapopoulos2: opt1 and opt2 are of type String, not Int
02:52:19 <koeien> you're missing a read somewhere
02:53:03 <Jafet> I thought it blocked more things than GC
02:53:28 <quicksilver> there might be other RTS services I'm not sure
02:53:36 <Jafet> Like the IO manager
02:53:41 <quicksilver> but the bottom line is that "normal" excution can continue
02:56:21 <int-e> Jafet: The IO manager should be unaffected (except for a few FFI calls that the IO manager does itself - there were some problems on Windows in this area ... for network sockets maybe? I forgot.)
02:56:23 <rastapopoulos2> koeien : thanks it works!! rostayob : i will keep that in mind
02:57:07 <dhaddy> hey guys. why isn't "d = (f) . (\a b -> [a,b])" equal to "d ab = f [a,b]"?
02:57:45 <rostayob> dhaddy: first of all, the second function is not valid
02:57:46 <dhaddy> I can move to lambda like "d = \a b -> ..."
02:57:48 <koeien> should be (f .) . (\a b -> [a,b])  and d a b = f [a,b]
02:58:18 <rostayob> dhaddy: then what koeien said, you have two arguments there
02:58:31 <int-e> koeien: no, it's equivalent to d b = f (\b -> [a, b])
02:58:32 <rostayob> @pl d a b = f [a,b]
02:58:33 <lambdabot> d = (f .) . (. return) . (:)
02:58:56 <int-e> koeien: ergh. d a = ...
02:59:11 <dhaddy> sorry, netcat+irc is a mess..
02:59:15 <koeien> yeah, i was just guessing intentions
02:59:23 <dhaddy> anyways, thanks for the input
02:59:28 <rostayob> int-e: if you want it point free (removint both arguments)
02:59:30 <int-e> koeien: and I meant to reply to dhaddy. Sorry.
03:00:28 <dhaddy> Right, will print the messages and try to parse the output :) Thanks! (off to lecture)
03:02:10 <obiwahn> koeien: fix  ("mrgl"++) <- returns the fix a func or a val?
03:02:28 <Cale> > fix  ("mrgl"++)
03:02:30 <lambdabot>   "mrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmrglmr...
03:02:51 <koeien> obiwahn: that expression is not a function
03:02:57 <obiwahn> is it the constant function that is found?
03:02:58 <koeien> it is a value.
03:03:04 <Cale> It's just a String
03:03:09 <Cale> as you can see there
03:03:12 <koeien> (all functions are values, the converse is not true)
03:03:14 <Cale> :t fix  ("mrgl"++)
03:03:15 <lambdabot> [Char]
03:03:31 <Cale> ^^ no (->) in the type -> not a function
03:03:37 <obiwahn> is the function called because it takes 0 arguments so that we get the value?
03:03:43 <Cale> It's not a function
03:04:13 <Cale> Every function has one parameter
03:04:20 <koeien> (and *exactly* one)
03:04:30 <Cale> Functions that appear to take more parameters are just producing other functions as their result
03:05:14 <obiwahn> what does fix exactly do?
03:05:19 <int-e> @src fix
03:05:19 <lambdabot> fix f = let x = f x in x
03:06:00 <rostayob> obiwahn: if you have a function f it gives you a value so that f x = x
03:06:06 <obiwahn> let fix f x = f (f x) in fix ("mrgl"++)
03:06:09 <obiwahn> > let fix f x = f (f x) in fix ("mrgl"++)
03:06:10 <lambdabot>   Overlapping instances for GHC.Show.Show
03:06:10 <lambdabot>                              ([GHC....
03:06:36 <int-e> ow :)
03:06:40 <rostayob> obiwahn: it's useful to define recursive lambdas
03:06:41 <obiwahn> rostayob: no
03:07:21 <rostayob> obiwahn: no?
03:07:26 <obiwahn> look
03:08:02 <rostayob> obiwahn: ?
03:08:11 <obiwahn> it gives you a function:)
03:08:12 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
03:08:14 <lambdabot>   3628800
03:08:21 <Cale> :t fix
03:08:22 <lambdabot> forall a. (a -> a) -> a
03:08:29 <Cale> ^^ it doesn't always give you a function
03:08:29 <rostayob> > fix (const "hello")
03:08:30 <lambdabot>   "hello"
03:08:31 <hpaste_> Nel pasted “parse cv 3” at http://hpaste.org/51609
03:08:41 <obiwahn> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
03:08:43 <Cale> :fix (1:)
03:08:46 <Cale> > fix (1:)
03:08:47 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:08:54 <osfameron> can fix create non-infinite lists?
03:08:57 <Cale> sure
03:09:05 <rostayob> > fix (const [])
03:09:06 <lambdabot>   []
03:09:06 <Cale> > fix (const [1,2,3,4])
03:09:07 <rostayob> ehe
03:09:07 <lambdabot>   [1,2,3,4]
03:09:49 <osfameron> could you define map in terms of fix, for example?
03:09:54 <Cale> yep
03:10:02 <obiwahn> Cale: i do not understnad how it can not return a function from the theoretical perspective ...
03:10:28 <Cale> > fix (\map f xs -> case xs of [] -> []; (y:ys) -> f y : map f ys) (*10) [1,2,3,4,5]
03:10:29 <lambdabot>   [10,20,30,40,50]
03:10:47 <Cale> obiwahn: Uh, I don't understand why you think it should.
03:11:02 <Cale> fix f = let x = f x in x
03:11:08 <Cale> ^^ why must x be a function?
03:11:20 <int-e> > let (even, odd) = fix (\ ~(even, odd) -> (\n -> if n == 0 then True else odd (n-1), \n -> if n == 0 then False else even (n-1))) in (even 42, odd 42)
03:11:21 <lambdabot>   (True,False)
03:11:23 <rostayob> osfameron: in general you can use fix (\f x y z -> something using f recursively, or terminating)
03:11:32 <Cale> All we know about x there is that it's both a valid argument to f, and that it's a valid result of f
03:11:35 <rostayob> if you don't have the terminating base case it diverges
03:11:52 <rostayob> as it would if you defined the function normally anyway
03:11:54 <Cale> We know that f is a function because it's being applied to x
03:12:00 <int-e> note: (even, odd) is not a function: it's a pair of functions :)
03:12:04 <Cale> So its type is f :: a -> b for some a and b
03:12:12 <osfameron> though... in that fix definition above what's inside the lambda is basically the definition of map anyway, no?
03:12:16 <Cale> and we can tell that a = b, because x :: a and x :: b
03:12:30 <Cale> So fix takes some function (a -> a) and gives a value of type a
03:12:47 <b_jonas> int-e: ah, that even/odd is a nice example
03:12:49 <Cale> osfameron: sure, except that the lambda I passed in isn't recursive
03:13:00 <Cale> osfameron: It just takes a function as an argument
03:13:05 * hackagebot invertible-syntax 0.2.1 - Invertible syntax descriptions for both parsing and pretty printing.  http://hackage.haskell.org/package/invertible-syntax-0.2.1 (TillmannRendel)
03:13:07 * hackagebot prolog-graph 0.1.0.2 - A command line tool to visualize query resolution in Prolog.  http://hackage.haskell.org/package/prolog-graph-0.1.0.2 (MatthiasBartsch)
03:13:25 <osfameron> Cale: well, it is recursive, in that it accepts a function 'map' which it then recurses to, no?
03:13:42 <Jafet> It uses fix to recurse.
03:13:43 <Cale> Um... recursive means that it calls itself.
03:13:46 <rostayob> osfameron: that's not recursion
03:13:50 <osfameron> ah, though at that point 'map' isn't bound to that function
03:14:04 <rostayob> osfameron: is \f x -> f x + 1 recursive?
03:14:06 <osfameron> ... every time I start to understand fix, I then get confused
03:14:33 <Cale> > map (fix (\fac n -> if n == 0 then 1 else n * fac (n-1))) [0..6]
03:14:34 <lambdabot>   [1,1,2,6,24,120,720]
03:14:48 <int-e> osfameron: But tying knots is fun!
03:15:00 <Cale> > (\fac n -> if n == 0 then 1 else n * fac (n-1)) undefined 0
03:15:01 <lambdabot>   1
03:15:05 <Cale> > (\fac n -> if n == 0 then 1 else n * fac (n-1)) undefined 1
03:15:06 <lambdabot>   *Exception: Prelude.undefined
03:15:18 <Cale> > (\fac n -> if n == 0 then 1 else n * fac (n-1)) ((\fac n -> if n == 0 then 1 else n * fac (n-1)) undefined) 1
03:15:19 <lambdabot>   1
03:15:48 <Cale> As we iterate this function, it becomes defined on more and more of its domain
03:15:58 <Cale> (it being the resulting function)
03:16:20 <Cale> Another definition for fix is   fix f = f (fix f)
03:16:26 <Cale> (though it's less efficient)
03:16:42 <rostayob> but kind of easier to reason about imho
03:16:45 <sanjoyd> osfameron: it calculates the least fixed point of something.  So the least fixed point of \f x = if x == 0 then 1 else x * (f $ x - 1) [=M] is factorial since M factorial = factorial.
03:17:54 <osfameron> sanjoyd: I don't understand "least fixed point" or "M" there
03:18:16 <sanjoyd> osfameron: fixed point of a function f is x such that `f x = x'.
03:18:58 <sanjoyd> osfameron: the concept of "least" is harder to explain -- in a way it means that the result has no extra information.
03:19:08 <Jafet> fix produces the fixed point that is less defined than any other fixed point, if it exists.
03:19:22 <obiwahn> the least is something like: nonterm =\x -> nonterm (x+1)
03:19:46 <sanjoyd> osfameron: So the least fixed point of \f (x, _, _) = (1, _, _) is (1, undefined, undefined) and not (1, 3, 5).
03:19:53 <sanjoyd> Even though the latter satisfies the equation.
03:20:01 <obiwahn> it could be 3 but that would not be the least edined
03:20:03 * sanjoyd checks if he is talking out of his ass or is actually right.
03:20:38 <Cale> obiwahn: So consider the least fixed point of something like (1:). undefined isn't a fixed point, because it's sent to 1:undefined, which is defined :)
03:20:42 <sanjoyd> > fix (\(x, y)->(1, y)
03:20:43 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:20:49 <sanjoyd> > fix (\(x, y)->(1, y))
03:20:50 <rostayob> btw, https://plus.google.com/107890464054636586545/posts/EbSuoRA6FTw
03:20:53 <lambdabot>   mueval-core: Time limit exceeded
03:21:06 <sanjoyd> Talking out of my ass it is.
03:21:36 <Jafet> Well, that's just a detail.
03:21:43 <Jafet> > fix (\~(x,y) -> (1,y))
03:21:44 <lambdabot>   <no location info>: parse error on input `->'
03:21:52 <Jafet> > fix (\ ~(x,y) -> (1,y))
03:21:56 <lambdabot>   mueval-core: Time limit exceeded
03:22:00 <Jafet> > fst $ fix (\ ~(x,y) -> (1,y))
03:22:01 <lambdabot>   1
03:23:23 <malorie> http://ideone.com/PDnYY <-- is this looking correct? (especially line 14)
03:23:39 <obiwahn> Cale: can i see values as constat functions?
03:23:54 <rostayob> obiwahn: it's easy, if the type signature has an arrow, it's a function.
03:23:56 <Jafet> rostayob: heh
03:24:13 <Cale> obiwahn: You can, though that means that every value is a function which pretty much makes the word "function" meaningless.
03:24:16 <rostayob> obiwahn: values are just values
03:24:19 <obiwahn> what about constructors?
03:24:19 <sanjoyd> osfameron: another way of looking at this fix is this:
03:24:20 <Jafet> Part of me says it's a bad idea to formally do that, even if programmers do that
03:24:27 <rostayob> obiwahn: constructors are definitely functions
03:24:36 <Cale> Except nullary constructors
03:24:40 <sanjoyd> osfameron: fix applies f on undefined infinite number of times.
03:24:43 <Cale> Nothing isn't a function
03:24:44 <obiwahn> how do you construct 1
03:24:45 <Cale> Just is a function
03:24:45 <rostayob> Cale: ofc
03:24:57 <sanjoyd> osfameron: so, in the factorial example, in the first iteration, we get
03:25:03 <osfameron> sanjoyd: on undefined?!
03:25:14 <sanjoyd> if x == 0 then 1 else x * (undefined $ x - 1).
03:25:18 <osfameron> I've followed the expansion of fix, and it kinda makes sense
03:25:23 <osfameron> but there was nothing about undefined in it
03:25:31 <sanjoyd> osfameron: if you understand it, fine.
03:25:35 <Cale> osfameron: Well, there was also nothing infinite about it :)
03:25:41 <sanjoyd> osfameron: this is just another conceptual way to look at it.
03:26:08 <sanjoyd> osfameron: so, in the next iteration, we get if x == 0 then 1 else x * (F $ x - 1) where F is what I typed in above.
03:26:10 <osfameron> Cale: oh, I didn't follow the expansion infinitely... that would have taken too long
03:26:29 <osfameron> sanjoyd: oh, you're sustituting F in for "undefined" ?
03:26:35 <sanjoyd> osfameron: if you see carefully, this will work correctly for x = 0 and x = 1.  F would've worked correctly only for x = 0.
03:26:43 <Cale> osfameron: In fact, the definition of fix which involves 'let' finishes its work in constant time.
03:27:01 <sanjoyd> And so on, and after inf. applications, it'll work with any integer. :)
03:27:13 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
03:27:33 <Cale> -> (let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x) 10
03:27:40 <obiwahn> @src fix
03:27:41 <lambdabot> fix f = let x = f x in x
03:27:49 <sanjoyd> osfameron: This is what fix f = f (fix f) does.
03:27:59 <Cale> -> (let x = \n -> if n == 0 then 1 else n * x (n-1) in x) 10
03:28:00 <sanjoyd> But it is less efficient, as someone pointed out.
03:28:57 <Cale> -> let x = \n -> if n == 0 then 1 else n * x (n-1) in if 10 == 0 then 1 else 10 * x (10 - 1)
03:29:02 <Cale> -> etc. etc.
03:29:35 <Cale> It just ends up forming a cycle in the expression in memory.
03:37:11 <obiwahn> let fix f = f (fix f) in fix 100
03:37:14 <obiwahn> > let fix f = f (fix f) in fix 100
03:37:15 <lambdabot>   100
03:37:29 <Cale> kekeke
03:37:35 <Cale> > 100 0
03:37:36 <lambdabot>   100
03:37:44 <sanjoyd> > 100 1
03:37:45 <lambdabot>   100
03:37:48 <obiwahn> i think it is not enough to say numbers behave strange
03:37:54 <Cale> There's an instance of Num for functions in lambdabot
03:37:54 <sanjoyd> Huh?
03:38:04 <Cale> It comes from the vector-space library which is imported.
03:38:05 <obiwahn> you need one theory for all the stuff
03:38:07 <sanjoyd> > :t 100
03:38:07 <Cale> You can write things like:
03:38:08 <lambdabot>   <no location info>: parse error on input `:'
03:38:16 <sanjoyd> @type 100
03:38:17 <lambdabot> forall t. (Num t) => t
03:38:18 <Cale> > (cos^2 + sin^2) 5
03:38:19 <lambdabot>   0.9999999999999999
03:38:23 <Cale> > (cos^2 + sin^2 + 1) 5
03:38:24 <lambdabot>   2.0
03:38:41 <yitz> malorie: looks good to me
03:38:47 <Cale> Because of the instance of Num for functions :)
03:39:03 <Cale> obiwahn: When you write 1, what it really means is fromInteger (1 :: Integer)
03:39:36 <yitz> > show sin
03:39:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:39:38 <lambdabot>    arising from a use of `...
03:39:48 <obiwahn> Cale: what does that mean?
03:40:03 <Cale> obiwahn: fromInteger :: (Num a) => Integer -> a
03:40:10 <yitz> Cale: ha! functions have not one, but *two* Show instances in lambdabot!
03:40:15 <Cale> obiwahn: So it means that numeric literals are polymorphic
03:40:21 <Cale> yitz: yeah ;__;
03:40:32 <Cale> it's hard to avoid importing Show instances for functions from everywhere
03:40:37 <Cale> Since we import so many modules
03:40:59 <yitz> there really needs to be a way to control import of instances in Haskell.
03:41:24 <Jafet> Cale, you should monkey patch the modules to remove one of them
03:41:36 <Jafet> I suggest keeping the old one, naturally
03:41:49 <quicksilver> all modules which have Show instance for functions should be removed from hackage
03:41:59 <quicksilver> ideally removed from all the hard disks in the world, permanently.
03:42:17 <DevHC_> ah
03:42:19 <yitz> quicksilver: you could probably do that using unsafePerformIO
03:42:20 <Cale> quicksilver: Oh come on. It's okay to define Show instances like that, they just need to be in their own module.
03:42:25 <DevHC_> we troll mauke with nested comments
03:42:33 <DevHC_> we troll quicksilver with Show instances for functions
03:42:42 <Cale> haha
03:42:56 <yitz> Cale: there is no such thing as an instance in its own module. unfortunately.
03:42:58 <Cale> > 1 + 1 {- {- PROBLEM? -} -}
03:42:59 <lambdabot>   2
03:43:05 <DevHC_> ROFL
03:43:15 <Cale> yitz: well, yes, they can leak out
03:43:29 <Peaker> quicksilver: I want a DebugShow class that's always instantitated, for everything
03:43:35 <Cale> yitz: But these ones are pretty much for debugging anyway
03:43:52 <Cale> So there's usually no reason to import them into a library module.
03:44:08 <yitz> Cale: kind of ironic to create bugs using an instance meant for debugging
03:44:13 <Cale> heh
03:44:17 <Cale> Well, 'bugs'
03:45:58 <yitz> Cale: i hope you have woken up early today. or is this yet another haskell-induced all-nighter?
03:46:05 <quicksilver> Cale: yes, non-canonical orphan instances need to be kept nice and segregated
03:46:11 <Cale> no, I'm just up early
03:46:12 <obiwahn> > let fix f = f (fix f); returnconst _ = 1 in fix returnconst
03:46:13 <lambdabot>   1
03:46:13 <quicksilver> Cale: treat them like velociraptors.
03:46:17 <yitz> Cale: yay!
03:46:49 <obiwahn> > let returnconst _ = 1 in returnconst
03:46:50 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
03:46:50 <lambdabot>    arising from a use of ...
03:46:52 <malorie> yitz: thanks
03:47:48 <hpc> > (const 1) (const 1)
03:47:49 <lambdabot>   1
03:48:09 <hpc> > (fix const) (fix const) 1 2 3
03:48:10 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
03:48:13 <hpc> bah
03:48:53 <obiwahn> @src const
03:48:54 <lambdabot> const x _ = x
03:49:38 * Jafet pushes hpc down the ramp
03:49:42 <DevHC_> > fix (fix . (++))
03:49:44 <lambdabot>   ()
03:49:48 <DevHC_> weird
03:51:06 <obiwahn> fix . (++)
03:51:09 <obiwahn> > fix . (++)
03:51:11 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:51:11 <lambdabot>    arising from a use of `...
03:52:10 <obiwahn> @src .
03:52:11 <lambdabot> (f . g) x = f (g x)
03:52:11 <lambdabot> NB: In lambdabot,  (.) = fmap
03:53:22 <DevHC_> > let f . g = \x -> f (g x) in fix (fix . (++))
03:53:24 <lambdabot>   ()
03:54:09 <obiwahn> what does const do?
03:54:18 <Entroacceptor> @src const
03:54:18 <lambdabot> const x _ = x
03:54:24 <obiwahn> is it to ignore additional parameters?
03:54:40 <Entroacceptor> yes
03:54:43 <obiwahn> Entroacceptor: explain the semantics please
03:54:51 <Entroacceptor> :t const
03:54:52 <lambdabot> forall a b. a -> b -> a
03:55:21 <Entroacceptor> so, const "Hallo" is a function that takes something and returns "Hallo"
03:55:40 <Entroacceptor> const x _ = x means it ignores the second parameter
03:55:41 <rostayob> > const undefined "blah"
03:55:42 <lambdabot>   *Exception: Prelude.undefined
03:55:48 <DevHC_> > map (*2) [1,3,1,2]
03:55:49 <lambdabot>   [2,6,2,4]
03:55:50 <rostayob> > const "blah" undefined
03:55:51 <lambdabot>   "blah"
03:55:55 <DevHC_> > map (const 0) [1,3,1,2]
03:55:56 <lambdabot>   [0,0,0,0]
03:56:11 <obiwahn> so a value is a func with 0 arguments
03:56:20 <DevHC_> indeed :D
03:56:21 <obiwahn> :)
03:56:27 <rostayob> obiwahn:  a value is *not* a function
03:56:34 <rostayob> well.
03:56:36 <DevHC_> rostayob: stfu
03:56:40 <obiwahn> :P
03:56:42 <rostayob> whatever. i won't get in this discussion anymore.
03:56:46 <DevHC_> @ tell rostayob u r not 1337
03:56:49 <DevHC_> @tell rostayob u r not 1337
03:56:50 <lambdabot> Consider it noted.
03:56:58 <rostayob> ehe
03:56:58 <lambdabot> rostayob: You have 1 new message. '/msg lambdabot @messages' to read it.
03:57:04 <Entroacceptor> > \->"hello"
03:57:04 <lambdabot>   <no location info>: parse error on input `\->'
03:57:08 <Entroacceptor> > \a->"hello"
03:57:09 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [GHC.Types.Char])
03:57:09 <lambdabot>    arising ...
03:57:16 <Entroacceptor> > (\a->"hello") a
03:57:17 <lambdabot>   "hello"
03:57:23 <Entroacceptor> > (\->"hello")
03:57:24 <lambdabot>   Not in scope: `\->'
03:57:55 <DevHC_> that syntax is not part of teh specification, but it is really required though
03:58:09 <rostayob> what would that mean?
03:58:13 <obiwahn> \_ ->"hello"
03:58:16 <obiwahn> > \_ ->"hello"
03:58:17 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [GHC.Types.Char])
03:58:17 <lambdabot>    arising ...
03:58:25 <obiwahn> > const (\_ ->"hello")
03:58:26 <lambdabot>   Overlapping instances for GHC.Show.Show
03:58:26 <lambdabot>                              (b -> ...
03:58:36 <Veinor> 'a value is a function with zero arguments' is meaningless
03:58:41 <DevHC_> \ | x > 10 -> "large"
03:58:41 <Veinor> what does that function return?
03:58:45 <rostayob> yeah I agree, but whatever
03:58:48 <DevHC_>   | otherwise -> "small"
03:58:59 <DevHC_> voila, 0-argument lambda
03:59:05 <DevHC_> with boolean guards
03:59:15 <rostayob> DevHC_: so is the x implicit?
03:59:17 <rostayob> as a argument?
03:59:22 <obiwahn> Veinor: it is not meaningless if it gives you the means to handle everything in the same way
03:59:30 <DevHC_> rostayob: ?
03:59:37 <rostayob> where did you get the "x" from
03:59:38 <obiwahn> it is meaningless to have funtions with one arument
03:59:38 <Veinor> obiwahn: yes it is
03:59:41 <Veinor> because
03:59:44 <DevHC_> the surroundings
03:59:44 <Veinor> what does the function '2' return?
03:59:54 <obiwahn> but it makes it easier to proof some thoreticl stuff
03:59:59 <Veinor> like what?
04:00:06 <rostayob> DevHC_: why do you need the lambda at all?
04:00:17 <DevHC_> > let x = 4 in if x > 10 then "large" else "small"
04:00:18 <lambdabot>   "small"
04:00:23 <rostayob> you simply want a construct to put guards somewhere
04:00:29 <rostayob> but it's  not a lambda function
04:00:37 <quicksilver> actually DevHC_ is showing two new things there
04:00:40 <DevHC_> because usage of | looks a lot better than if-then-else words
04:00:48 <quicksilver> nullary lambdas, and lambdas with guards
04:00:58 <quicksilver> existing (non-nullary) lambdas don't support guards either.
04:00:59 <rostayob> DevHC_: yeah but the two things don't have to come together
04:01:19 <obiwahn> Veinor: like when you want to translate haskell to lamda calculus to do type checking
04:01:20 <rostayob> I mean a construct to put guards wherever you want would solve the lambda-with-guards problem
04:01:22 <DevHC_> rostayob: yes they should
04:01:28 <obiwahn> then you can have only one argument
04:01:31 <DevHC_> even pattern matching
04:01:40 <obiwahn> same stuff with fix and functions
04:01:41 <rostayob> like if-then-else but with guards
04:01:46 <Veinor> right, i'm fine with functions only having one argument
04:01:48 <rostayob> I don't see why you should overload \
04:01:54 <Veinor> but what i'm not fine with is '2' being described as a 'zero-argument function
04:01:58 <quicksilver> obiwahn: what you are saying is not true.
04:02:03 <DevHC_> i'm not overloading \
04:02:18 <DevHC_> in top-level function definitions u can use something like
04:02:26 <DevHC_> f x | x > 10 = "large"
04:02:33 <quicksilver> obiwahn: there is no need (and no benefit) from calling values "0-arg functions" in terms of a translation to lambda calculus
04:02:33 <DevHC_>     | otherwise = "small"
04:02:45 <quicksilver> obiwahn: lambda calculus doesn't have 0-arg functions either.
04:02:45 <DevHC_> now replace f with \
04:02:48 <rostayob> DevHC_: yes I get what you're saying, but you could simply have some construct to put use guards wherever you want
04:02:51 <DevHC_> and that is what a lambda should look like
04:02:54 <rostayob> like if-then-else
04:03:14 <DevHC_> if-then-else clutters things up
04:03:29 <obiwahn> quicksilver: ok
04:03:32 <obiwahn> pure lamda
04:03:50 <rostayob> DevHC_: my point is that if I wanted to create a constructor to use guards outside function definition you don't necessarely have to do it that way
04:04:18 <obiwahn> you define 1 = \f x -> x
04:04:18 <rostayob> and I can't see the use of a nullary lambda anyway
04:04:35 <quicksilver> obiwahn: I am aware of the church encoding.
04:04:44 <quicksilver> obiwahn: and various other ways to encode values as functions.
04:04:45 <obiwahn> 1 = \f x -> f x
04:04:54 <quicksilver> obiwahn: EVEN IN THOSE SCHEMES there is no such thing as a zero argument function.
04:05:37 <obiwahn> but when you do not care about the argumet
04:05:44 <obiwahn> then it is almost the same
04:05:46 <obiwahn> 1 5
04:06:05 <obiwahn> 1 does not care about any further arguments
04:06:07 <DevHC_> rostayob: u can also live without lambdas.
04:06:23 <quicksilver> obiwahn: it absolutely does care. It forbids them.
04:06:26 <rostayob> DevHC_: well lambdas are useful. nullary lambdas are not
04:06:29 <quicksilver> > (1 :: Int) 5
04:06:30 <lambdabot>   Couldn't match expected type `t1 -> t'
04:06:30 <lambdabot>         against inferred type `GHC.T...
04:06:36 <osfameron> what is life without plumtree's potted lambdas?
04:06:39 <quicksilver> Int is not a function type.
04:06:49 <quicksilver> Cale: do you see the pain caused by this overloading? ;)
04:07:05 <Cale> wat
04:07:30 <Cale> > (1 :: Int -> Int) 5
04:07:31 <lambdabot>   1
04:07:41 <Cale> > (1 :: Int -> (Int -> Int)) 5 7
04:07:42 <lambdabot>   1
04:07:56 <Cale> > (1 :: Int -> ((Int -> Int) -> Int)) 5 7
04:07:57 <lambdabot>   1
04:08:20 <Cale> > (1 :: Int -> ((Int -> (Int -> Int)) -> Int)) 5 7
04:08:21 <lambdabot>   1
04:08:39 <quicksilver> Cale: I know what it does ;) I only complaing as it's adding weight to a spurious argument that everything is a function.
04:08:48 <Cale> oh, well...
04:08:54 <Cale> That's still clearly false.
04:08:57 <quicksilver> Cale: you know, working with ipwn has changed you.
04:09:13 <Cale> Oh?
04:09:20 <obiwahn> i dont say everything is a function
04:09:24 <Cale> I've always loved polymorphism
04:09:35 <Cale> :t (.)
04:09:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:09:37 <obiwahn> but the way fix works it must return a function
04:09:43 <Cale> obiwahn: Why?!
04:09:46 <quicksilver> obiwahn: no, that is not true.
04:09:54 <Cale> obiwahn: Why do you think that? It makes no sense.
04:09:57 <Cale> :t fix
04:09:58 <lambdabot> forall a. (a -> a) -> a
04:09:59 <quicksilver> obiwahn: fix can return all kinds of things, e.g. infinite lists.
04:10:00 <Cale> ^^ look at the type
04:10:11 <Cale> 'a' is not necessarily a function type
04:10:15 <quicksilver> Cale: You never used to say "wat" ;)
04:10:19 <Cale> It could be, for example, Integer.
04:10:25 <DevHC_> rostayob: nullary lambdas r useful when coupled with pattern guards
04:10:27 <Cale> quicksilver: Oh, that's not iPwn's influence.
04:10:41 <Cale> That's probably the SC2 community.
04:10:48 <Cale> Or maybe Reddit
04:11:10 <rostayob> DevHC_: you don't need to make up "nullary lambdas" to create a construct with guards
04:11:20 <DevHC_> ORLY
04:11:26 <DevHC_> show me how
04:11:34 <Cale> case
04:11:35 <DevHC_> (note: u may not use TLDs)
04:11:39 <DevHC_> cale: fu2
04:11:42 <Cale> (case () of _ | ... -> ...)
04:12:24 <obiwahn> Cale: beacuse you have a var on rhs
04:12:35 <rostayob> you can use case as cale said or just stick them somewhere, guard | blah = whatever ....
04:12:37 <obiwahn> that is somehow defined via a recursive function
04:12:39 <Cale> obiwahn: what does that matter?
04:13:00 <Cale> obiwahn: There can be recursive non-function values.
04:13:01 <obiwahn> then you buil a infinita chain of functions
04:13:13 <obiwahn> and pick the least upper bound
04:13:20 <Cale> obiwahn: I can have an Integer value which is arbitrarily complicated to compute.
04:13:28 <Cale> Or even a Bool
04:13:31 <obiwahn> wich happens to be most undefined fixpoint
04:14:07 <Cale> obiwahn: Functions are involved in the construction of the value, sure.
04:14:13 <Cale> Doesn't mean that the value is a function.
04:14:16 <obiwahn> as soon as you use recursion you have some kind of function
04:14:19 <Cale> NO!
04:14:29 <rostayob> ahah
04:14:30 <Cale> A function is involved in fix, of course.
04:14:37 <Cale> Look at the type!
04:14:39 <Cale> :t fix
04:14:41 <lambdabot> forall a. (a -> a) -> a
04:14:50 <Cale> It takes a function from things to things and it gives a thing
04:14:57 <hpc> obiwahn: let ones = 1 : ones in ones -- look ma, no functions!
04:14:57 <obiwahn> ok
04:14:59 <Cale> That thing doesn't have to be a function.
04:15:06 <hpc> > let ones = 1 : ones in ones -- look ma, no functions!
04:15:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:15:13 <Cale> Right
04:15:24 <Cale> and you could say, "well, (1:) is a function there"
04:15:32 <obiwahn> what is :
04:15:39 <rostayob> :t (:)
04:15:39 <Cale> But it's silly to call the result of a function a function all the time.
04:15:40 <lambdabot> forall a. a -> [a] -> [a]
04:15:45 <hpc> obiwahn: it cons's lists
04:15:46 <rostayob> obiwahn: cons
04:15:55 <obiwahn> :looks like some kind of function
04:15:55 <rostayob> appends an element to the beginning of a list
04:15:59 <hpc> 1:[2,3,4] = [1,2,3,4]
04:16:07 <rostayob> Cale: he got you there. (:) is clearly a function.
04:16:09 <hpc> x:[] = [x], etc
04:16:11 <rostayob> and you're using it
04:16:37 <Cale> > fix (const True)
04:16:38 <lambdabot>   True
04:16:38 <Blkt> good afternoon everyone
04:16:46 <Cale> ^^ is True a function? I would say no.
04:16:58 <Cale> It can't take any parameters, so it's not a function.
04:16:58 <obiwahn> i would say yes
04:17:06 <rostayob> i would say conga
04:17:23 <obiwahn> fix True
04:17:24 <Cale> Functions take values of one type, their domain, and associate them with values of another type, their codomain.
04:17:26 <obiwahn> > fix True
04:17:27 <lambdabot>   Couldn't match expected type `a -> a'
04:17:27 <lambdabot>         against inferred type `GHC.Bo...
04:17:50 <Cale> fix True doesn't work, because fix requires a function as its parameter, and True isn't a function.
04:17:57 <Cale> It's a Bool
04:17:59 <Cale> :t True
04:18:00 <lambdabot> Bool
04:18:06 <yitz> <troll> is undefined a function? </troll>
04:18:27 <Cale> undefined is completely polymorphic, so it can be any type, including function types
04:18:31 <rostayob> :t undefined :: (a -> a)
04:18:32 <lambdabot> forall a. a -> a
04:18:40 <Cale> But it doesn't have to be :)
04:18:45 <Cale> :t undefined :: Bool
04:18:46 <lambdabot> Bool
04:18:51 <chra> Has this been mentioned? http://conal.net/blog/posts/everything-is-a-function-in-haskell
04:19:05 <obiwahn> the guy is stupid
04:19:06 <rostayob> chra: yes, but obiwahn thinks that conal is "dumb"
04:19:10 <hpc> chra: last week i think :P
04:19:11 <rostayob> yeah exactly.
04:19:22 <chra> rostayob: Huh, ok.
04:19:27 <Cale> Conal is probably one of the smartest people around.
04:19:54 <yitz> conal and Cale agree. looks like obiwahn is toast.
04:19:57 <rostayob> obiwahn, trolling haskell with style
04:20:22 <Cale> obiwahn: What is your definition of "function"?
04:20:58 <yitz> Cale: morphism in some category
04:21:01 <Cale> obiwahn: The relevant definition that everyone is using here is that a function is a value whose type has -> as its top-level type constructor.
04:21:12 <obiwahn> a symbol that takes 0 to n args and returns something
04:21:23 <Cale> Things without -> in their type cannot be functions by this definition.
04:21:33 <Cale> obiwahn: Every value can take 0 args.
04:21:38 <quicksilver> obiwahn: calling people stupid is not constructive; calling conal stupid is simply untrue.
04:22:01 <Cale> So that would mean every value is a function, which is stupid because it means that function and value are synonyms.
04:22:13 <obiwahn> ok soory i dont even know the guy - and it was bad:(
04:22:17 <Cale> and so the terminology of calling things functions is pointless
04:22:28 <Cale> If you take that route
04:22:41 <Cale> Do you see what I mean?
04:22:56 <Cale> Surely whatever our definition of function is, it shouldn't include all values.
04:23:18 <Cale> Because otherwise there's no point, we can just keep calling things values and not functions.
04:23:32 <Cale> (it's easier to type after all)
04:23:48 <Cale> obiwahn: yeah?
04:24:07 <obiwahn> i see your point
04:24:09 <tactics> Are you people gettign into arguments over definitions of terms again?
04:24:12 <tactics> >__>
04:24:29 <obiwahn> mmh i shall read the logs on the last discussion:()
04:24:31 <Jafet> What Cale just typed is very hard to troll against, but there's the STLC route
04:24:40 <Entroacceptor> tactics: you can reduce 90% of all discussions to that
04:24:41 <Jafet> UTLC, rather
04:24:53 <b_jonas> the XTLA route?
04:24:55 <tactics> Entroacceptor: Seriously, I know right?
04:25:10 <obiwahn> Cale: http://en.wikipedia.org/wiki/Kleene_fixpoint_theorem
04:25:18 <obiwahn> it is about chains of functions
04:25:28 <obiwahn> and that theorem is used in haskell
04:25:51 <obiwahn> so how can the fixpoint be something that is not a functions
04:26:01 <obiwahn> i have to look aht the : example again
04:26:19 <obiwahn> > let ones = 1 : ones in ones
04:26:20 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:26:21 <quicksilver> Jafet: here's an idea - resist the temptation to troll at all? :)
04:26:45 <benmachine> obiwahn: the theorem discusses the fixed point of a function - the fixed point itself is not a function
04:27:14 <quicksilver> obiwahn: the fixpoint of a function need not be a function ;)
04:27:20 <quicksilver> in general, it won't be.
04:27:30 <benmachine> yeah, need not be, rather than isn't
04:27:35 <benmachine> Entroacceptor: I disagree; maybe you can reduce 90% of all boring arguments so
04:27:41 <Jafet> quicksilver: but Cale is like a quintain for trolling!
04:27:59 <tactics> This isn't worth being awake at 7:30 for :P
04:28:03 <tactics> I'll see you guys more around 11
04:28:04 <Entroacceptor> benmachine: I won't argue about a number I pulled out of thin air ;)
04:28:14 <quicksilver> as a simple (non-haskell) example, the function f(x) = x+1 / 2 has a fixed point over R
04:28:23 <benmachine> Entroacceptor: I argue about its order of magnitude! most arguments I have are actually pretty cool
04:28:24 <quicksilver> that fixed point is 1 (which is not a function!)
04:28:54 <hpaste_> hpc pasted “evaluation of fix” at http://hpaste.org/51610
04:28:58 <Entroacceptor> benmachine: I wasn't talking about you, but the whole world.
04:29:02 <hpc> obiwahn: relevant paste
04:29:23 <benmachine> Entroacceptor: well, I can't dispute that, I suppose
04:30:02 <yitz> Jafet, tactics: these are worthwhile topics to discuss on this channel, so it's not harmful trolling.
04:30:37 <rostayob> yitz: we've been going in circles for a while
04:30:48 <Jafet> I was discussing trolling.
04:31:28 <obiwahn> > fix (\g -> 1:g)
04:31:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:31:36 <yitz> rostayob: true, going in circles causes dizzyness
04:31:59 <obiwahn> quicksilver: good example:)
04:32:24 <yitz> Jafet: i think people discussing trolling are stupid. oh, oops - sorry.
04:32:57 <Jafet> You're welcome.
04:33:01 <benmachine> metadiscussion is dangerous, it can go inductive
04:34:02 <yitz> > fix (("This discussion is about " ++) . show)
04:34:03 <obiwahn> i hope you still talk to me guys:) i do not want to troll but understand ...
04:34:03 <lambdabot>   "This discussion is about \"This discussion is about \\\"This discussion is...
04:34:34 <Entroacceptor> maybe just learn? "In Haskell, a function takes exactly one argument"
04:35:20 <obiwahn> iw would say in lambda:)
04:35:30 <obiwahn> or simple haskel
04:35:48 <rostayob> in lambda calculus is the same
04:36:13 <rostayob> (every function takes exactly one argument)
04:38:03 <obiwahn> let one in ones .... must be transformed to -> fix (\g -> 1:g)
04:38:27 <erus`> http://byorgey.files.wordpress.com/2011/05/monad_tutorial.jpg
04:38:39 <Entroacceptor> that "ones" doesn't take an argument, so it's not a function
04:38:50 <Entroacceptor> how you arrive at the value is irrelevant
04:38:53 <quicksilver> obiwahn: it is not actually transformed to that, but yes, that is an equivalent way of writing it.
04:44:14 <obiwahn> as fa as i understand ones = 1 : ones  must be rewritten because you cannot define a symbol on the right when itself occurs on the rhs
04:44:29 <obiwahn> on the left...
04:44:49 <obiwahn> or better define semantics of the symbol
04:45:44 <obiwahn> so we need an approximation function that is good enough
04:47:31 <obiwahn> ill go to my professor's consultation hour and ask him and return:)
04:50:12 * frerich2 imagines the professor throwing his hands up in the air, going "Jeez, dude! Conal Elliott!!"
04:51:03 <hpaste_> “/dev/humancontroller” pasted “UBER HASKELL SYNTAX” at http://hpaste.org/51611
04:52:19 <benmachine> DevHC_: multi-level guards would be nice but you would need to resolve the ambiguity somehow
04:52:31 <benmachine> probably by making | introduce a layout context, which might be ugly
04:52:44 <benmachine> notice that I can (and sometimes do) write definitions like
04:53:08 <Cale> I prefer just allowing sections of case
04:53:10 <benmachine> guard b | b = return () | otherwise = mzero
04:53:39 <Cale> So a case expression with a missing scrutinee  case of ...  is translated to  \fresh -> case fresh of ...
04:53:40 <benmachine> as for the nullary-lambdas idea, there's no reason why you'd use lambdas here, since what you're doing has nothing to do with a lambda
04:54:07 <rostayob> which is what I've been trying to tell him :P
04:54:12 <Cale> obiwahn: Why can't you do that?
04:54:13 <DevHC_> it's just something to introduce the availability for a |
04:54:19 <int-e> DevHC_: f x y | x = 1337 = "uber" and \Just s -> s should be parse errors. nested guards are potentially ambiguous as has already been said
04:54:24 <benmachine> DevHC_: what's your problem with case
04:54:27 <Cale> obiwahn: Why can't you define something recursively in terms of itself when it's not a function?
04:54:28 <rostayob> DevHC_: yeah but it's confusing, since it has nothing to do with lambda functions
04:54:41 <Cale> obiwahn: Who told you that rule?
04:54:43 <int-e> DevHC_: ok, \Just s -> is a type error really.
04:55:04 <DevHC_> benmachine: yet another keyword. i'd prefer to replace it with complex symbol-syntax
04:55:15 <Cale> obiwahn: It seems pretty clear that the Haskell evaluator can break that rule, and is perfectly implementable, so why should it be a rule?
04:55:25 <obiwahn> Cale: how do you get the meaning of ones = 1:ones?
04:55:27 <benmachine> DevHC_: I'd prefer to have readable syntax; you can define languages with no keywords, and they're awful
04:55:31 <DevHC_> int-e: thank u for ur opinion, kthxbye!
04:55:34 <int-e> > let f Just 1 = 0 in 0 -- hmm, it's a syntax error after all; only the arity matters
04:55:35 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
04:55:39 <rostayob> brainfuck anyone
04:55:48 <quicksilver> obiwahn: fixed point semantics.
04:55:48 <chromeyellow> I need to read and write an Excel file from Haskell. What library should I use?
04:55:55 <int-e> rostayob: it's been a while
04:55:55 <quicksilver> obiwahn: (as you suggested earlire I'm sure)
04:56:04 <benmachine> Cale: http://hackage.haskell.org/trac/ghc/ticket/4359 if you like case sections this might be the place to say so
04:56:04 <DevHC_> benmachine: what about that guard b | b example?
04:56:24 <benmachine> DevHC_: it looks like a nested guard in your syntax, but it's actually two guards
04:56:54 <int-e> DevHC_: but I would like to see an extension like that for lambda expressions.
04:57:03 <Cale> obiwahn: Well, you can define it as the least fixed point, or in practical terms, the operational semantics is via pattern matching. So when it gets matched by a case expression like   case ones of [] -> ...; (x:xs) -> ..., ones evaluates to 1 : ones and then x matches 1 and xs matches ones, and the evaluator proceeds with the corresponding body of the case expression.
04:57:04 <benmachine> int-e: see the ticket!
04:57:08 <chromeyellow> > putStrLn "I need to read and write an Excel file from Haskell. What library should I use?"
04:57:09 <lambdabot>   <IO ()>
04:57:32 <chromeyellow> > unsafePerformIO $ putStrLn "I need to read and write an Excel file from Haskell. What library should I use?"
04:57:33 <lambdabot>   Not in scope: `unsafePerformIO'
04:57:42 <benmachine> chromeyellow: I don't know if there is one; can you export to CSV and use that instead?
04:57:44 <Cale> obiwahn: and then if xs is pattern matched upon further, it is again expanded according to the definition
04:57:47 <DevHC_> > let { f x | x > 0 = 0 | otherwise = 4 } in f 0
04:57:47 <b_jonas> chromeyellow: try var instead of putStrLn
04:57:48 <lambdabot>   4
04:57:49 <Cale> obiwahn: yeah?
04:58:01 <DevHC_> benmachine: ok
04:58:08 <obiwahn> we are taliking about 2 different thins now
04:58:17 <obiwahn> lets takle only  one arg
04:58:31 <obiwahn> pattern matching compilcates everything abit
04:58:31 <Cale> obiwahn: In fact, in a good real world implementation, we don't even have to repeat the expansion, because we just end up with a cycle of pointers in memory.
04:58:37 <chromeyellow> benmachine: no, that's not an option:(
04:58:54 <Cale> Pattern matching is what drives evaluation forward in Haskell.
04:59:23 <Cale> At a low-enough level, nothing ever gets evaluated without being matched on by a case expression (in the core language of GHC, for example)
04:59:34 <b_jonas> that much is easy, but how does mfix work?
04:59:51 <Cale> b_jonas: You're asking me?
04:59:55 <obiwahn> but there is not much overlap between fix and paatern matching
05:00:02 <Cale> mfix is defined on a per-monad basis
05:00:07 <benmachine> mfix is scary
05:00:09 <Cale> obiwahn: sure...
05:00:34 <obiwahn> match (pat1 pat2 par3) exp1 exp2 exp3 =>>
05:00:43 <Cale> obiwahn: Apart from the fact that you can understand how things work by looking at what happens when a case expression scrutinises the result.
05:00:54 <Cale> (in an operational sense)
05:00:57 <obiwahn> if (isa_n-tuple exp)
05:01:09 <Cale> This isn't Haskell code...
05:01:16 <obiwahn> then match pat1 (seln,1 exp)..
05:01:34 <obiwahn> but that is an example how pattern matching is implemented
05:01:50 <obiwahn> is and match would be build in functions
05:02:22 <DevHC_> benmachine: then the proposed nested guard syntax is changed to: f x | y <- m x = \ | g z -> ...
05:02:29 <DevHC_> but that gets really ugly now D:
05:02:31 <obiwahn> but i under stand how pattern matching can be implemented there are for sure better ways
05:02:34 <Cale> Pattern matching (against a single data constructor) is implemented by forcing evaluation (to weak head-normal form), followed by checking an integer tag, and binding some pointers to expressions.
05:02:43 <jane_> good morning fellas. what is the intuition behind ((->) e) monad's implementation of >>= ? I fail to see it.
05:03:15 <koeien> :t (>>=)
05:03:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:03:17 <Cale> jane_: The intuition is that each function in the computation is being supplied the parameter that the overall computation is being supplied
05:03:25 <quicksilver> jane_: the intuition is that both actions have a 'hidden argument' of type e
05:03:25 <b_jonas> DevHC_: when guard syntax extensions go, I want guards in if, such as if pat <- expr then expr2 else expr3
05:03:26 <koeien> jane_: it's like the Reader monad.
05:03:33 <quicksilver> jane_: and the same value is given to both.
05:03:34 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
05:03:35 <lambdabot>   ("hello","olleh","HELLO")
05:03:49 <Cale> jane_: ^^
05:03:51 <koeien> jane_: (if you're familiar with it)
05:04:43 <koeien> so it is a computation in which actions can read a "state"
05:04:55 <koeien> like in Cale's example, the "state" is the string "hello"
05:05:07 <DevHC_> b_jonas: u do know that if-then-else is a function...
05:05:25 <DevHC_> if b then x else y == ifThenElse b x y
05:05:28 <b_jonas> DevHC_: it is now. it wouldn't be with this extension
05:05:33 <Cale> a "state" which never changes... is it really a state? :)
05:05:35 <DevHC_> ifThenElse (pat <- expr) ...
05:05:40 <b_jonas> DevHC_: with this extension, the part after if would be any guard
05:05:44 <koeien> Cale: well, yeah, for lack of a better word.
05:06:07 <koeien> a "hidden variable" is probably better, like quicksilver suggested :)
05:06:07 <Cale> "environment" would be another decent word
05:06:07 <b_jonas> it could be a simple expressoin (implicitly matched to True) or a more complicated guard
05:06:07 <DevHC_> blargious.
05:06:15 <koeien> ah yes.
05:06:25 <nooodl> wow. this infinite type error message is infinite
05:06:32 <jacobian> nice :)
05:06:37 <b_jonas> nooodl: really?
05:06:42 <nooodl> i can't ctrl-c out of it... had to close ghci
05:06:43 <nooodl> yep.
05:06:45 <Cale> nooodl: Whoa, wtf.
05:06:47 <jane_> Cale, quicksilver: thanks guys. that made sense.
05:06:51 <Cale> nooodl: That's a bug
05:06:53 <jane_> koeien: never heard of it.
05:06:57 <b_jonas> hmm, we need a lambdacats image about that
05:07:08 <koeien> jane_: well, now you do. the Reader monad is exactly ((->) e)
05:07:13 <koeien> (wrapped in a newtype)
05:07:18 <Cale> nooodl: If you can, please report it (or at least paste the code on hpaste for us to try!)
05:07:31 <scarlet_eyes> Hello. I am not sure how to ask this question properly, but. I have written a lot of math in Excel and macros, however I want to learn a programming language to simplify the implementations of these formulas. I've been going through different online tutorials, but I can't seem to make proper sense of it, I believe I am missing something in translation; is there... a book or tutorial I should read to better understand ...
05:07:37 <b_jonas> there are images of cats watching a cat on a monitor to the infinity
05:07:37 <scarlet_eyes> ... the concepts needed to do this?
05:07:47 <nooodl> it was a result of me messing around with lambda calculus
05:07:50 <hpaste_> nooodl pasted “infinite error message?” at http://hpaste.org/51612
05:08:04 <koeien> @where lyah
05:08:04 <lambdabot> http://www.learnyouahaskell.com/
05:08:08 <nooodl> try :loading that into ghci
05:08:08 <koeien> scarlet_eyes: ^
05:08:09 <Cale> scarlet_eyes: Have you tried "Learn you a Haskell"?
05:08:14 <jane_> koeien: why wrapped in a newtype? what does it do differently?
05:08:36 <scarlet_eyes> I hadn't yet, no. Thank you.
05:08:50 <Cale> scarlet_eyes: Also, don't be afraid to ask any questions you might have here.
05:08:52 <koeien> jane_: it makes the intention clearer.
05:09:06 <koeien> jane_: it's for readability
05:09:15 <koeien> jane_: newtype makes an isomorphic type with a new name
05:09:17 <poet> hi #haskell!
05:09:24 <Cale> scarlet_eyes: This channel strives to be quite beginner-friendly :)
05:09:27 <jane_> koeien: okay, thanks.
05:09:33 <quicksilver> jane_: having a direct Monad instance for (->) causes certain typos to either give no error, or a suprising error.
05:09:33 <benmachine> nooodl: well, wow.
05:09:55 <nooodl> benmachine, same there?
05:09:58 <quicksilver> jane_: some people argue that's not a good thing.
05:10:07 <quicksilver> Reader doesn't have that problem.
05:10:07 <benmachine> nooodl: yes
05:10:08 <jane_> quicksilver: but haskell does have a direct monad instance for (->), doesn't it?
05:10:16 <koeien> jane_: also, if you don't, you might write something that typecheck unintentionally
05:10:31 <Cale> nooodl: ROOOOFL
05:10:32 <quicksilver> jane_: depends what you mean by 'haskell' ;) It's in the standard library in Control.Monad.Instances
05:10:40 <rostayob> nooodl: wow, that's amazing ahaha
05:10:42 <DevHC> did i miss the infinite type error code?
05:10:42 <koeien> jane_: Caleskell for sure does :)
05:10:44 <quicksilver> I can't remember if it's re-exported from Control.Monad but I think it is not.
05:10:50 <DevHC> LINK PLX
05:10:54 <rostayob> DevHC: http://hpaste.org/51612
05:10:54 <jane_> quicksilver: that's exactly what i meant. ;)
05:10:55 <Cale> http://hpaste.org/51612
05:10:58 <jane_> koeien: lol
05:11:16 <Cale> Is anyone already working on a GHC bug report?
05:11:27 <nooodl> the problem is i was too deep into messing around with all of this that i can't really see what's causing that to happen
05:11:31 <Cale> (and has anyone tried it in HEAD yet?)
05:11:36 <DevHC> lambda calculus is inconsistent
05:11:48 <koeien> ghc 6.12.3 works for me
05:12:01 <nooodl> yeah, lambda calculus and types don't go together
05:12:03 <koeien> (well, it gives a finite error message)
05:12:05 <rostayob> this is great, it even crashes emacs with ghc-mod
05:12:49 <benmachine> quicksilver: I think it isn't because Control.Monad is a h2010 module
05:13:02 <benmachine> and (inexplicably) h2010 doesn't have the instance
05:13:22 <d-best> hey, what does $ do? I'm reading learn you a haskell, and it isn't explained
05:13:33 <d-best> like putStrLn $ "Some string"
05:13:35 <koeien> d-best: ($) is id
05:13:36 <benmachine> d-best: isn't it?
05:13:43 <DevHC> basically $ means: the rest of the expression parenthesized
05:13:49 <benmachine> d-best: basically if you have foo bar baz $ wibble whatever thing
05:13:50 <koeien> d-best: it's used to suppress parentheses
05:13:52 <Cale> d-best: f $ x = f x, but $ has really low precedence
05:13:53 <d-best> ohh maybe I skipped over it
05:13:56 <benmachine> this means (foo bar baz) (wibble whatever thing)
05:14:13 <benmachine> you can view it as a function-application operator
05:14:18 <d-best> I thought it related somehow to the io functions, but then it's probably something explained earlier in the book
05:14:18 <Cale> (whereas normally function application has higher precedence than any infix operator)
05:14:20 <koeien> d-best: e.g. f (g (h y)) might be written as f . g . h $ y
05:14:27 <Cale> d-best: nope!
05:14:28 <koeien> d-best: it's not at all related to IO
05:14:34 <koeien> @src ($)
05:14:35 <d-best> haha thanks guys
05:14:35 <lambdabot> f $ x = f x
05:14:41 <d-best> you're one active bunch >_>
05:14:46 <DevHC> Cale: cut down the use of the n word
05:15:10 <scarlet_eyes> Oh, I'm going to try reading through Learn You A Haskell first, but I will try.
05:15:11 <nooodl> it's useful for other things, too. map ($3) [(+2),(*5),(^2)]
05:15:17 <benmachine> d-best: http://learnyouahaskell.com/higher-order-functions it's in this chapter
05:15:17 <hpaste_> Cale annotated “infinite error message?” with “infinite error message? (annotation)” at http://hpaste.org/51612#a51613
05:15:36 <Cale> That's the error message from 6.12.3
05:16:27 <d-snp> woops, better now
05:16:32 <rostayob> so wait, (m ->) monad instance is basically "return = const; m >>= f = \x -> f (m x) x"?
05:16:46 <Cale> rostayob: yes
05:16:56 <Cale> That's exactly is
05:16:56 <koeien> is that a free theorem?
05:16:57 <Cale> it*
05:17:07 <Cale> koeien: I believe so
05:17:09 <rostayob> Cale: cool I got it right
05:17:22 <benmachine> @djinn (r -> a) -> (a -> r -> b) -> r -> b
05:17:24 <lambdabot> f a b c = b (a c) c
05:17:32 <rostayob> damnit djinn
05:17:52 <benmachine> of course that doesn't tell you that it's the *only* possible implementation, but I think it is
05:22:08 <hpaste_> awdaw pasted “awdawd” at http://hpaste.org/51615
05:25:57 <benmachine> @djinn Not (Not (Not a)) -> Not a
05:25:58 <lambdabot> f a b = void (a (\ c -> c b))
05:30:25 <quicksilver> benmachine: well  have some sympathy with the surprising error message view
05:30:46 <benmachine> quicksilver: hm?
05:31:09 <quicksilver> :t do putStrLn; return 4
05:31:10 <lambdabot> forall b. (Num b) => String -> b
05:31:38 <quicksilver> benmachine: I was expecting "ERROR - putStrLn requires 1 argument and you gave it none"
05:31:42 <benmachine> heh
05:31:44 <quicksilver> well, of course, I wasn't expecting that :)
05:31:49 <quicksilver> but that's what you might hope for.
05:32:01 <quicksilver> that's the argument that the (->) instance makes surprising things type-check.
05:32:05 <benmachine> sure, but instead you got No instance for Monad ((->) r); possible fix: write one
05:32:15 <quicksilver> yeah that isn't really that much better :)
05:32:21 <benmachine> yes, I have some sympathy with that argument
05:32:37 <benmachine> but I don't think it's possible to avoid the (->) r instance completely
05:32:44 <frerich2> Actually, you got me there, I almost wanted to point out that your code is broken but then thought 'Hm no, he probably knows better than me, so lets lurk a bit longer and wait for an explanation'.
05:32:48 <benmachine> or at least it's not desirable
05:33:13 <benmachine> and I'd much rather avoid orphan instances in this case than sometimes-bad-errors
05:34:32 <benmachine> quicksilver: I'd *hope* that either your explicit type signatures or your context would cause problems there
05:34:49 <benmachine> (no instance for Num (IO ()); possible fix: write one)
05:35:00 <benmachine> (possible addendum: please don't write one)
05:35:19 <Cale> You could write one...
05:35:26 <benmachine> well actually I guess you could use the applicative-num instance
05:35:33 <benmachine> with a dummy eq/show
05:35:41 <Cale> You could write an instance of Num for (), and an instance Num a => Num (IO a)
05:35:46 <Cale> lol
05:36:10 <Cale> Yeah, can't do Eq or Show
05:36:39 <quicksilver> benmachine: in general missing out arguments gives poor errors in haskell already
05:36:51 <quicksilver> this is a disadvantage of curried functions
05:36:56 <benmachine> mm
05:37:07 <applicative> all that damn currying violates common sense, it's like laziness!
05:37:10 <ion> Eq: const False. Show: const "<IO>"
05:37:13 <quicksilver> consider map (+) [1,2,3]
05:37:14 <ion> ;-)
05:37:24 <quicksilver> although lambdabot thinks differently on that one, as usual
05:37:32 <quicksilver> :t map (+) [1,2,3]
05:37:34 <lambdabot> forall a. (Num a) => [a -> a]
05:37:39 <quicksilver> ah no, it doesn't. Good.
05:37:42 <mux> oh, foce once it doesn't
05:37:44 <benmachine> perversely, Eq: const True is a "better" implementation
05:37:46 <mux> for*
05:37:49 <quicksilver> point is that typechecks but really I'd missed out a parameter.
05:38:06 <quicksilver> typically missing out one parameter on the second argument to 'map' will typecheck, just in a different way.
05:38:07 <benmachine> (inasmuch as it's an equivalence relation)
05:38:10 <quicksilver> because it's still a function.
05:38:43 <ion> > map (+) [1,2,3] <$> pure 4
05:38:44 <lambdabot>   Couldn't match expected type `a -> b'
05:38:44 <lambdabot>         against inferred type `[a1 ->...
05:38:46 <benmachine> quicksilver: yes. but of course we *do* want to be able to write map (+ 3) [1,2,3]
05:38:57 <ion> > map (+) [1,2,3] <*> pure 4  --typo
05:38:59 <lambdabot>   [5,6,7]
05:39:05 <benmachine> (well, in fact, we *sometimes* want to be able to write map (+) [1,2,3])
05:39:09 <quicksilver> benmachine: definitely.
05:39:20 <quicksilver> benmachine: I'm not really sure what my point is :)
05:39:22 <DevHC> i really have a feeling that this "infinite" error message isn't infinite, just very long
05:39:29 <benmachine> quicksilver: "life is hard"
05:39:37 <quicksilver> as we make our language more efficient and dense, we make it less and less likely that typos fail to typecheck
05:39:42 <benmachine> DevHC: that was my hypothesis, but I let it go for a while and didn't get anywhere
05:39:43 <quicksilver> more and more likely they typecheck but with a surprising type.
05:40:02 <benmachine> DevHC: feel free to run it forever, and when you're done let us know what you found out
05:40:41 <benmachine> quicksilver: sometimes I wonder about DRY; does redundancy sometimes guard against errors?
05:40:46 <koeien> quicksilver: do you feel overloading is overused in api's?
05:40:48 <quicksilver> benmachine: yes, it does.
05:40:54 <quicksilver> koeien: sometimes. E.g. text.regex.
05:41:08 <benmachine> Text.Regex was a semi-comical example
05:41:19 <quicksilver> benmachine: the messages that distance space ships and satellites send to earth sometimes contain as much as 150% added redundancy.
05:41:30 <quicksilver> this guards against errors.
05:41:34 <benmachine> quicksilver: sure, but that's guarding against a different kind of error, surely
05:41:38 <benmachine> well
05:41:42 <benmachine> arguable I guess
05:41:47 <quicksilver> I am suggesting there is a loose analogy at least :)
05:41:50 <applicative> DevHC, are you saying, it's not a bug, it just takes a lot of pages for ghc to formulate its objection?
05:41:50 <benmachine> heh
05:41:55 <opqdonut> I think DRY means something different
05:41:56 <quicksilver> it's a trade off between information content and verbosity
05:42:04 <DevHC> applicative: yes
05:42:12 <opqdonut> it means don't copy-paste something that should only have one implementation
05:42:20 <benmachine> it's a transmission error, only in the one case you're transmitting across vast reaches of space, and in the other you're transmitting across the gooey boundary at the edge of your brain
05:42:22 <opqdonut> like a snippet of code that extracts information x from y
05:42:35 <opqdonut> because then if you subtly change y you'll have to find all of those places
05:42:40 <benmachine> opqdonut: my understanding of it was that each piece of information should have one authoritative source
05:43:02 <benmachine> although I guess there are varying degrees to which you can take it
05:43:06 <opqdonut> right
05:43:27 <benmachine> according to wikipedia, The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system."
05:43:43 <benmachine> top-level type signatures in haskell programs violate this regularly
05:43:49 <benmachine> redundancy for the sake of error checking
05:44:09 <ion> …and documentation.
05:44:52 <Cale> Attempting to formalise a principle like that is kinda silly though.
05:45:20 <benmachine> Cale: well, following it religiously is silly, but it should be emphasised
05:45:21 <Cale> It's more of a rule of thumb than something worth being precise about.
05:45:27 <applicative> DevHC, you're right, it did stop
05:45:31 <benmachine> I mean, one of the things I like about haskell is how little I have to repeat myself
05:45:48 <byorgey>  if you follow that rule to its extreme, we should be compressing all our source files
05:45:54 <benmachine> if I've gotta do something ten times with slightly different parameters here and here, I can map a function over a list of tuples
05:45:54 <koeien> gzip x.hs
05:46:07 <koeien> less redundancy!
05:46:10 <benmachine> :P
05:46:15 <byorgey> exactly.
05:46:26 <Cale> bzip2 x.hs
05:46:30 <koeien> even less :)
05:46:31 <Cale> even less(?)
05:46:32 <quicksilver> gzip benmachine
05:46:48 * benmachine curls up into a ball
05:47:30 <Cale> IT'S NOT ENOUGH. WE MUST DEVISE THE PERFECT COMPRESSOR. ACTIVATE THE IMPOSSIBILITY THEOREM SUPPRESSOR FIELD!
05:47:48 <byorgey> bwooooOOOOO
05:47:54 <tromp> i only devised the ultimate decompressor
05:48:40 <applicative> the 'infinite error message' is actually *only* 30405215 characters long
05:48:55 <koeien> applicative: but it does terminate?
05:49:05 <koeien> or is it because of RAM exhaustion?
05:49:10 <buntfalke> Is it in any way common to name Haskell source files *.asc?!
05:49:23 <applicative> koeiein, it ended gracefully with Prelude>
05:49:24 <koeien> buntfalke: never seen it
05:49:48 <buntfalke> koeien: Thanks, so I'll ignore it an go on with *.hs
05:50:01 <benmachine> thirty million characters, huh
05:50:20 <benmachine> is this the last time we get to complain about C++ template errors? :P
05:50:46 <benmachine> "how to write a Haskell program which results in an error message five orders of magnitude larger than it is"
05:52:08 <d-snp> argh my mind is so weak, I read 'functors are things that can be mapped over' and I just glaze over
05:52:10 <DevHC> lol
05:52:17 <Cale> applicative: I think it's still a bug
05:52:30 <DevHC> how to write a real infinite loop for some C++ compilers:
05:52:31 <DevHC> template <typename T> struct hax { hax<T*> operator->(); };
05:52:31 <DevHC> int main() { hax<void> h; h->pwnt; }
05:52:32 <applicative> Cale, I think that is a fair suspicion
05:52:33 <Cale> d-snp: mapped over in the sense of map on lists
05:52:49 <koeien> DevHC: there are also programs that GHC does not terminate on
05:52:52 <Cale> > map (*10) [1..10]
05:52:53 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
05:52:54 <applicative> in fact there are 381 largely distinct occurs check problems
05:52:55 <Cale> > fmap (*10) [1..10]
05:52:56 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
05:52:57 <engla> benmachine: since the type signature is specified right next to the implementation, it's not at all bad
05:53:01 <Cale> > fmap (*10) (Just 3)
05:53:02 <d-snp> with lists I unuderstand it, but how does it work with Maybe?
05:53:02 <lambdabot>   Just 30
05:53:08 <Cale> > fmap (*10) Nothing
05:53:09 <lambdabot>   Nothing
05:53:12 <DevHC> koeien: without TH?
05:53:12 <koeien> @src fmap Maybe
05:53:12 <lambdabot> Source not found. I feel much better now.
05:53:15 <koeien> DevHC: yes
05:53:19 <DevHC> koeien: i can haz?
05:53:21 <koeien> @src Maybe fmap
05:53:22 <lambdabot> fmap _ Nothing       = Nothing
05:53:22 <lambdabot> fmap f (Just a)      = Just (f a)
05:53:27 <ion> Maybe acts like a list with a maximum length of one.
05:53:37 <d-snp> oh hmm
05:53:54 <d-snp> alright, that can be understood.. so why do they call it functor then? :P
05:53:56 <benmachine> engla: yes, I know, but there's still a tradeoff sometimes
05:53:58 <Cale> With IO actions, it applies the function to the result of the IO action.
05:54:09 <d-snp> why not call it data structures?
05:54:10 <koeien> d-snp: because of mathematics.
05:54:12 <d-snp> hmm
05:54:15 <Cale> d-snp: Because they're endofunctors in the sense of category theory.
05:54:28 <benmachine> DevHC: I believe they're in the GHC user guide, in the bugs section
05:54:30 <koeien> not all data structures are functors, but a lot of them are
05:54:33 <Cale> d-snp: not all datastructures are functors
05:54:47 <koeien> benmachine: yeah
05:55:00 <benmachine> data Thing a = Wibble (a -> a) -- not a Functor
05:55:07 <DevHC> koeien, benmachine: is it GHC-specific, or by the nature of the definition in the Report?
05:55:12 <koeien> DevHC: it's a GHC bug
05:55:29 <Cale> data Bool = False | True  -- also not a Functor
05:55:42 <ion> When a value “contains” zero or more other values or can generate a value, fmap applies a function to the contained/generated value(s), retaining the “structure” unchanged.
05:56:13 <DevHC> not in http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html
05:56:16 <Cale> d-snp: For various types of "computation", the Functor instance will apply the function to the "result" of the computation.
05:56:30 <d-snp> hmm ok
05:56:33 <Cale> d-snp: For example, with IO,  fmap :: (a -> b) -> IO a -> IO b
05:56:39 <koeien> DevHC: 13.2.1
05:56:57 <Cale> Will take an IO action producing values of type a, and turn it into an IO action producing values of type b by applying the function to the result.
05:57:01 <ion> :t getLine
05:57:01 <DevHC> oic :>
05:57:02 <lambdabot> IO String
05:57:04 <ion> :t fmap length getLine
05:57:05 <lambdabot> IO Int
05:57:09 <ion> :t length
05:57:09 <Cale> Similarly for things like Parser a
05:57:10 <lambdabot> forall a. [a] -> Int
05:57:15 <applicative> the first impossible type is   t0 = (t0 -> t0 -> t0) -> t0 -> t0 -> t0  the last of 381 is: t0 = ((t0 -> t0 -> t0) -> (t0 -> t0 -> t0) -> t0 -> t0 -> t0) -> (t0 -> t0 -> t0) -> t0 -> t0 -> t0
05:57:55 <jane_> :t =<<
05:57:56 <lambdabot> parse error on input `=<<'
05:58:04 <Cale> :t (=<<)
05:58:04 <koeien> :t (=<<)
05:58:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:58:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
05:58:17 <Cale> =<< is just flipped over >>=
05:58:19 <koeien> you need ()s around operators if you're not using them infix
05:58:40 <jane_> koeien: okie dokie
06:00:52 * applicative was going to paste the complete error message, which he is thinking may not even be an unreasonable message, but it's too big to fit in his paste machinery
06:01:54 <jane_> Does ST monad make IO kinda obsolete?
06:02:00 <koeien> jane_: no, not at all
06:02:15 <koeien> jane_: it's not possible to run IO actions inside the ST monad
06:02:36 <koeien> it is possible to run ST actions
06:02:49 <koeien> it's only possible to run IO actions by sticking them in 'main' somehow
06:03:10 <jane_> koeien: Okay. Maybe I am missing the point of ST monad
06:03:13 <koeien> i.e. there is no runIO :: IO a -> a, but there is a runST :: ST a -> a
06:03:23 <leod> @hoogle IO a -> a
06:03:23 <lambdabot> Foreign unsafePerformIO :: IO a -> a
06:03:23 <leod> :P
06:03:23 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
06:03:23 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
06:03:32 <koeien> leod: ... i know :)
06:03:37 <leod> come to the dark side!
06:03:46 <ion> unsafPerformST
06:03:48 <ion> e
06:04:07 <koeien> jane_: ST exists because sometimes it's more efficient to have algorithms with mutable state
06:04:10 <DevHC> > (return >=> return) 1
06:04:11 <lambdabot>   No instance for (GHC.Show.Show (m a))
06:04:11 <lambdabot>    arising from a use of `M5765902753...
06:04:30 <ion> > (return <=< return) 1 :: Maybe Integer
06:04:31 <lambdabot>   Just 1
06:04:33 <koeien> jane_: in that case, you can write your algorithm in ST. the type system guarantees that this mutable state does not "leak" to the outside
06:05:07 <dino-> Hello Haskellers
06:05:37 <koeien> jane_: you can allocate memory in actions in the ST monad, read and update references
06:05:44 <Eduard_Munteanu> dino-: hi
06:05:53 <jane_> koeien: okay, i kinda get it now. thanks!
06:06:06 <koeien> jane_: the wiki has a page on it, I'm sure
06:06:08 <jane_> i have a few more questions to shoot. hope you guys dont mind:D
06:06:09 <dino-> I needed the hSimpleDB library and found that it not building against recent things (like GHC7 and hxt). Fixed it and now need to submit patches.
06:06:27 <dino-> But it has no homepage. Anybody offhand know if this guy is in source control somewhere?
06:06:42 <dino-> Lemmih: Are you here?
06:07:47 <obiwahn> mmh Cale i guess you are right somehow ... my ghc gives me errors on things like 1 1 1
06:07:58 <koeien> cale is always right :)
06:08:13 <obiwahn> > 1 1 1
06:08:14 <lambdabot>   1
06:08:15 <Cale> obiwahn: Indeed, you need a special instance of Num for numeric constants to be treated as functions
06:08:15 <jane_> comonad, cokleisli - what are these co-brothers of familiar control patterns? where would you use them?
06:08:16 <rostayob> somehow
06:08:39 <koeien> jane_: "co-" in mathematics means often that the arrows are reversed
06:08:42 <obiwahn> s/somehow//
06:09:18 <koeien> so a comonad is something with a  c a -> a, and a c a -> (c a -> b) -> c b
06:09:30 <Cale> obiwahn: When you write 1, the thing that you get is dependent on what type is inferred, and how it's constructed is determined in a canonical way by the implementation of fromInteger for that type
06:09:38 <Cale> obiwahn: for example
06:09:40 <Cale> > 1 :: Float
06:09:42 <lambdabot>   1.0
06:09:47 <Cale> > 1 :: Ratio Integer
06:09:48 <lambdabot>   1 % 1
06:09:53 <Cale> > 1 :: Integer
06:09:54 <lambdabot>   1
06:10:00 <Cale> > 1 :: Word8
06:10:01 <lambdabot>   1
06:10:04 <Cale> and so on
06:10:14 <koeien> jane_: note that this is the "reverse" of  a -> m a  and  m a -> (a -> m b) -> m b
06:10:34 <koeien> as for examples, I'm not sure
06:10:43 <Cale> obiwahn: In lambdabot, this mechanism is extended with an instance for functions, so that numeric literals can be treated as constant functions.
06:10:44 <koeien> comonads don't occur so often in haskell practice afaik
06:10:46 <obiwahn> @where fix
06:10:46 <lambdabot> I know nothing about fix.
06:10:59 <rostayob> @src fix
06:10:59 <lambdabot> fix f = let x = f x in x
06:11:03 <rostayob> @hoogle fix
06:11:04 <lambdabot> Data.Function fix :: (a -> a) -> a
06:11:04 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
06:11:04 <lambdabot> module Control.Monad.Fix
06:11:05 <Eduard_Munteanu> jane_: this is a nice example of comonads uses: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
06:11:08 <obiwahn> which module contains fix?
06:11:11 <obiwahn> ah
06:11:18 <koeien> jane_: I think sigfpe has an article on it
06:11:30 <ion> The literal “42” in Haskell code means “fromInteger n” where n is the Integer value for 42.
06:12:29 <int-e> obiwahn: also Data.Function
06:12:37 <jane_> koeien: Is this the one? http://blog.sigfpe.com/2006/06/monads-kleisli-arrows-comonads-and.html
06:12:59 <obiwahn> i have imported Control.Monad is there a way to import .*
06:13:07 <int-e> obiwahn: no
06:13:24 <rostayob> obiwahn: "import Control.Monad" imports all the functions in Control.Monad
06:13:38 <koeien> jane_: i was referring to http://blog.sigfpe.com/2008/03/comonadic-arrays.html, but there are more
06:13:41 <rostayob> all the functions exported by Control.Monad
06:13:42 <tdammers> ...but not the sub-modules of Control.Monad...
06:13:48 <rostayob> nope
06:13:56 <jane_> koeien: thanks, reading.
06:14:03 <rostayob> http://www.youtube.com/watch?v=LJP1DphOWPs
06:14:07 <int-e> obiwahn: there are no sub-modules really, despite the hierarchical namespace.
06:14:07 <koeien> jane_: also Eduard_Munteanu's link
06:14:33 <tdammers> true, though A.B and A.B.C are usually related
06:14:40 <dino-> Shit, somebody has been changing hSimpleDB on github more more recently than what's on hackage
06:14:58 <dino-> Like by 2 years
06:15:44 <DevHC> rostayob: conal is trolling with puppet animals? :>
06:15:50 <int-e> Control.Monad.* is a bad example -- that namespace does contain many implementations of unrelated monads.
06:15:59 <rostayob> DevHC: no, I just like the way he says "nope"
06:16:08 <rostayob> nope. they're dead.
06:16:40 <copumpkin> rostayob: #haskell-blah
06:17:11 <quicksilver> go Ross : ""would effectively exclude alternative operating systems, according to Professor Ross Anderson of Cambridge University"
06:17:13 <rostayob> copumpkin: yeah sorry
06:17:16 <dino-> Eh, it hasn't even been changed to use recent hxt in the github version. huh
06:18:40 <tdammers> well, not EVERYTHING fits into a hierarchy
06:27:50 <DevHC> zomg i've found a ghc buog
06:28:19 <jane_> @pl \x y -> 2 * x + 2 * y + 9
06:28:19 <lambdabot> flip flip 9 . ((+) .) . (. (2 *)) . (+) . (2 *)
06:28:20 <DevHC> specifying a different optimization level (-O#) does not recompile the object file :>
06:28:28 <koeien> -fforce-recomp
06:28:32 <koeien> or touch $file.hs
06:28:41 <jane_> hpaste_: hello
06:28:51 <DevHC> or rm file.o
06:31:03 <Eduard_Munteanu> @bot
06:31:03 <lambdabot> :)
06:31:26 <mamalujo> I was considering trying out frp for some gui. Last I read about it (w/o doing anything about), grapefruit and reactive were new and looked promising; now grapefruit seems to have build failure on anything >ghc-6.10 , and reactive besides a build failure on 7.0, also warns of some "serious bugs". Is reactive-banana then the right one to try? Though its wx module too says it fails to build on 7.0? Are others just rotting or is this ...
06:31:32 <mamalujo> ... temporary? or am I missing some other good choices?
06:32:40 <byorgey> mamalujo: I would try reactive-banana, it's the only one of those three which I think is under active development at the moment
06:33:16 <byorgey> mamalujo: and its author, apfelmus, often hangs out in here and I'm sure would be responsive via email if you had questions about it
06:33:44 <mamalujo> right, thx, that's what I'll try then
06:34:52 <buntfalke> 'type' renames existing types and has no new contructor, 'newtype' does the same, but instroduces exactly one constructor, and data introduces an arbitrary amount of them (e.g. for a binary tree with leafs and such)?
06:35:39 <opqdonut> right
06:35:41 <byorgey> buntfalke: right
06:35:52 <opqdonut> also, the constructor introduced by newtype is unary
06:36:20 <opqdonut> or maybe you implied that already
06:36:25 <buntfalke> Great, thanks!
06:36:49 <buntfalke> Seems I got it afterall. The report takes a little getting used to
06:37:51 <Eduard_Munteanu> There's mm_freak_'s netwire, if you're looking for a new FRP toolkit
06:38:00 <Eduard_Munteanu> s/toolkit/lib/
06:38:19 <koeien> buntfalke: almost. close enough
06:38:43 <Eduard_Munteanu> @hackage netwire
06:38:43 <lambdabot> http://hackage.haskell.org/package/netwire
06:38:58 <koeien> buntfalke: in runtime, newtype does not incur a performance penalty
06:38:59 <Eduard_Munteanu> I haven't tried it yet, but I'm planning to.
06:39:35 <Eduard_Munteanu> I'm not sure it does gui stuff yet.
06:39:51 <mysticc> I am confused with pure and impure functions ... what will be the type of a function which takes name of the file as input and returns a list of Strings read from it.. will it be String -> IO String ??
06:40:05 <koeien> String -> IO [String]
06:40:19 <koeien> but it's more precise to say the following
06:40:44 <danr> Are maybe, either and uncurry considered catamorphisms?
06:40:44 <koeien> this is a function that takes a String and returns an IO action that, when executed, returns a list of Strings
06:41:14 <rostayob> danr: catamorphism == folds, at least in haskell (afaik)
06:41:29 <mysticc> koeien: What if I want String -> [String] function
06:42:02 <koeien> mysticc: that's possible, but such a function cannot perform IO
06:42:20 <buntfalke> koeien: (perf penalty) as it is just a rename, and the others cause packing and introduce another level of indirection?
06:42:20 <koeien> mysticc: it cannot read from files, launch missiles, and so on
06:42:36 <koeien> buntfalke: type is an alias (just a new name for something)
06:42:42 <danr> rostayob: well for lists, the catamorphism is a fold
06:42:42 <buntfalke> okay
06:42:47 <rostayob> danr: you might want to read "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" if you want to know more
06:42:48 <rostayob> danr: yes
06:42:54 <koeien> buntfalke: using data will have some indirection
06:43:28 <koeien> buntfalke: so if you have newtype X = X Integer, then in runtime (X 37) is the same as 37
06:43:34 <koeien> i.e. the X constructor does not exist in runtime
06:43:40 <rostayob> danr: fold is generalized with the Foldable type class
06:43:48 <koeien> whereas for data, there is a difference
06:44:15 <byorgey> rostayob: however, the Foldable class does *not* give you catamorphisms.  it gives you something slightly less powerful.
06:44:19 <byorgey> danr: maybe and either are catamorphisms.  I don't think uncurry is.
06:44:22 <danr> rostayob: I guess I have to read up on F-algebras, according to the wiki page
06:44:26 <koeien> so for a newtype   X undefined   and  undefined  are the same, whereas for data they aren't
06:44:40 <danr> byorgey: but uncurry would be the "destructor" for tuples :)
06:44:55 <buntfalke> koeien: So neither type nor newtype cause a performance penalty, only data does?
06:44:56 <danr> it follows the same pattern
06:44:57 <rostayob> byorgey: oh ok. I guess I'll read that paper sooner or later
06:45:17 <buntfalke> koeien: or does newtype, too, as it causes additional matching / checking on types or so?
06:45:19 <buntfalke> Hm.
06:45:45 <buntfalke> Actually I don't need that level of detail (yet), should learn more of the actual language first :-)
06:46:02 <koeien> buntfalke: yeah exactly. that's why i said "close enough" in the beginning
06:46:11 <koeien> but type is very different from the other two
06:46:13 <byorgey> danr: I see what you're saying, I guess you can see it as a very degenerate catamorphism
06:46:51 <koeien> buntfalke: type just introduces an alias. e.g. type String = [Char]. everywhere you see String you can replace it by [Char] and still have a valid program
06:47:09 <koeien> and vice versa
06:48:05 <mysticc> How to check if a string represents a number or not .. eg "12" represents a number .. and what is the best way to convert it to Int .. I know one way of doing read "12" :: Int
06:48:06 * hackagebot BiobaseInfernal 0.5.4.1 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.5.4.1 (ChristianHoener)
06:48:18 <rostayob> danr: oh, I see what you mean now
06:48:51 <rostayob> danr: I didn't understand you were referring to the functions maybe and either
06:49:31 <danr> rostayob: aha, sorry I guess I could have made that clearer ^^
06:50:38 <rostayob> danr: no it's me not reading carefully :P
06:50:42 <rostayob> a long standing problem of mine
06:50:52 <frerich2> mysticc: I think the simplest way would be to use the 'reads' function
06:51:35 <xyz> @pl (\b d -> a b (c d))
06:51:35 <lambdabot> (. c) . a
06:51:37 <frerich2> mysticc: 'reads' gives you the 'remainder' of the string which it couldn't parse; if that stirng is empty, then you had a number.
06:51:54 <quicksilver> (all isDigit) is a crude way to check if a string looks like a number
06:52:01 <quicksilver> only positive integers in that case
06:52:09 <mysticc> frerich2: Thanks
06:52:16 <mysticc> quicksilver: Yeah thats good too
06:52:17 <quicksilver> if you need to be more than that then you might as well use reads.
06:53:54 <tromp> you mean non-negative:)
06:55:52 <koeien> > read "0xFF" :: Integer
06:55:53 <lambdabot>   255
06:55:58 <rostayob> byorgey: why is it that Foldable does not give you catamorphism?
06:57:08 <rostayob> :t Foldable.foldr
06:57:09 <lambdabot> Couldn't find qualified module.
06:57:44 <rostayob> well anyway, the only difference between the classical foldr and Foldable foldr is the type of the thing to fold, which is polymorphic in Foldable
06:57:53 <rostayob> well which is parametrized
06:58:06 <BlankVerse> mysticc: send ipt invite
06:58:32 <Saizan> Foldable.foldr is not a catamorphism for the type which is a Foldable instance
06:58:47 <quicksilver> rostayob: because catamorphisms are about the *actual* structure of data types, not the fact they can be mapped to a list.
06:59:33 <mysticc> frerich2: Why the type of reads is [(a,String)] and not (a,String)
07:00:09 <dafis> mysticc: what if there's no parse or more than one?
07:00:10 <quicksilver> it returns and empty list if it doesn't aprse
07:00:20 <rostayob> quicksilver, Saizan: oh ok, I think I see the difference
07:00:26 <quicksilver> > reads "abcd" :: [(Int,String)]
07:00:27 <lambdabot>   []
07:00:47 <mysticc> dafis: example of more than one parse ??
07:01:38 <Cale> mysticc: The Read instances in the Prelude happen to never give you alternate parses
07:01:51 <Cale> mysticc: But the class is designed to allow for it
07:02:21 <dafis> mysticc: I have never encountered one, but one could write a parser that returned several possible parses for some inputs
07:02:37 <mysticc> ok ... Thanks ...
07:02:41 <Cale> mysticc: So, for example, one possibility would be for it to give you a list of parses like this:
07:03:18 <Cale> reads "123apple" -> [(123,"apple"), (12,"3apple"), (1,"23apple")]
07:03:39 <Cale> but it's uncommon for that to be helpful
07:04:22 <Cale> > reads "123apple"
07:04:23 <lambdabot>   []
07:04:32 <Cale> > reads "123apple" :: [(Integer, String)]
07:04:33 <lambdabot>   [(123,"apple")]
07:04:48 <Cale> so the default instance won't give you the other possibilities
07:05:02 <mysticc> ok ...
07:05:02 <armlesshobo> reads "123apple" :: [(Char, String)]
07:05:13 <armlesshobo> > reads "123apple" :: [(Char, String)]
07:05:14 <lambdabot>   []
07:05:20 <Cale> You can use list comprehensions to chain parsers of this type together pretty reasonably.
07:06:09 <dmwit> > reads "123apple" :: [(Int, String)]
07:06:10 <lambdabot>   [(123,"apple")]
07:06:18 <dmwit> > reads "'1'23apple" :: [(Char, String)]
07:06:19 <lambdabot>   [('1',"23apple")]
07:07:03 <Cale> > [(x,y) | (x,':':s') <- reads "123:456", (y,"") <- reads s']
07:07:04 <lambdabot>   []
07:07:24 <armlesshobo> > reads "[1,2,3]apple" :: [([Int],String)]
07:07:25 <lambdabot>   [([1,2,3],"apple")]
07:07:28 <Cale> oops!
07:07:29 <dmwit> Cale: :: [Int]
07:07:36 <dmwit> [(Int,Int)], I mean
07:07:37 <Cale> > [(x,y) | (x,':':s') <- reads "123:456", (y,"") <- reads s'] :: [(Integer, Integer)]
07:07:38 <lambdabot>   [(123,456)]
07:07:54 <Cale> Types are rather important using reads :)
07:08:26 <dmwit> > [(x,y) | (x,':':s') <- reads "():()", (y,"") <- reads s']
07:08:27 <lambdabot>   [((),())]
07:08:31 <dafis> > reads "\\SOH" :: [(Char,String)]
07:08:32 <lambdabot>   []
07:08:32 <Cale> hehe
07:08:46 <Cale> > reads "'\\SOH'" :: [(Char,String)]
07:08:47 <dmwit> > reads "'\\\SOH'" :: [(Char,String)]
07:08:48 <lambdabot>   [('\SOH',"")]
07:08:48 <lambdabot>   []
07:09:02 <bgamari> If I have a list of values of type "data MyType = A | B | C", how do I get the first value of value constructor e.g. A?
07:09:03 <ion> > [ (x,y) | (x, ':':s') <- (reads :: ReadS Integer) "123:456", (y, "") <- (reads :: ReadS Integer) s' ]
07:09:04 <lambdabot>   [(123,456)]
07:09:08 <dafis> > reads "\"\\SOH\"" :: [([Char],String)]
07:09:09 <lambdabot>   [("\SOH","")]
07:09:09 <armlesshobo> Cale: what's s'?
07:09:21 <dmwit> > reads "'\\\SOH'" :: [(Char,String)] -- Which response was which?
07:09:22 <lambdabot>   []
07:09:24 <Cale> armlesshobo: the remainder of the string after parsing the first number
07:09:25 <bgamari> Or even just filter on the value constructor
07:09:36 <armlesshobo> Cale: doh... ty
07:09:38 <Cale> (and removing the colon)
07:09:38 <armlesshobo> :P
07:09:39 <dmwit> good
07:10:09 <dmwit> bgamari: A doesn't contain any values.
07:10:09 <Cale> bgamari: If you derive an instance of Bounded, then minBound will do that
07:10:13 <bgamari> I could define a function and pattern match, but this would need to be done for every value constructor
07:10:15 <armlesshobo> mysticc: once you understand that, try parsing out the contents of /etc/passwd
07:10:21 <armlesshobo> mysticc: assuming you're running linux
07:10:21 <dmwit> bgamari: Oh, sorry, I misunderstood the question.
07:10:23 <bgamari> dmwit: It does in my code
07:10:25 <armlesshobo> unix*
07:10:28 <Cale> bgamari: errr
07:10:40 <Cale> bgamari: I think I misunderstood the question too.
07:10:40 <dmwit> Perhaps I still don't understand the question.
07:10:46 <Cale> Same here :)
07:11:06 <bgamari> I have a type "data MyType = A Int | B String | C Double", for instance
07:11:14 <bgamari> I have myList :: [MyType]
07:11:32 <bgamari> I want to get all of the values in myList of value constructor A, for instance
07:11:32 <dmwit> And you want just the A's?
07:11:35 <bgamari> yes
07:11:37 <dmwit> Okay.
07:11:41 <dmwit> Two ways, one good, one bad.
07:11:49 <quicksilver> [ x | A x <- myList ]
07:11:57 <dmwit> isA (A {}) = True; isA _ = False -- the good way
07:12:07 <dmwit> quicksilver's way is the bad way. =)
07:12:10 <bgamari> dmwit: Right, that's what I suggested
07:12:14 <bgamari> What makes it bad?
07:12:16 <quicksilver> \o/
07:12:34 <bgamari> Having to define an isA for every value constructor is a tad annoying
07:12:43 <imphasing> Oh man. Map is so easy to implement as a fold, I never really got how awesome that is.
07:12:52 <dmwit> bgamari: It just relies on a sort of weird behavior of pattern matching inside do blocks/list comprehensions.
07:13:01 <bgamari> dmwit: I see
07:13:09 <quicksilver> I don't think it's particularly weird.
07:13:14 <quicksilver> I think it's very convenient.
07:13:14 <Cale> > let map f = foldr (f . (:)) [] in map (*10) [1..10]
07:13:15 <lambdabot>   No instance for (GHC.Num.Num [a])
07:13:15 <lambdabot>    arising from a use of `e_110110' at <i...
07:13:17 <Cale> er
07:13:19 <dmwit> Unlike most pattern match failures (which throw exceptions), this one returns no results.
07:13:21 <Cale> > let map f = foldr ((:) . f) [] in map (*10) [1..10]
07:13:23 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
07:13:34 <cgroza> or you could have a lambda inside the list comprehension...
07:13:37 <quicksilver> bgamari: tools exist to write those 'is' functions if you need them often.
07:14:16 <quicksilver> I like the list comp because it unwraps and filters at the same time.
07:14:18 <obiwahn> > fix (\x -> x/2 + 1)
07:14:18 <dmwit> I don't know. "Bad" is probably the wrong word for what I mean.
07:14:22 <lambdabot>   mueval-core: Time limit exceeded
07:14:27 <dmwit> quicksilver: right
07:14:32 <quicksilver> obiwahn: wrong kind of fixed point.
07:14:40 <obiwahn> :(
07:14:42 <bgamari> quicksilver: hmm, alright
07:14:44 <Cale> Well, hey, undefined is a fixed point of that function
07:14:45 <dmwit> Maybe it's better to just leave off adjectives and say that there are two alternatives.
07:14:49 <quicksilver> obiwahn: that's a mathematically fixed point but it's not the "least" fixed point in the order that domain theory uses.
07:15:01 <quicksilver> well, I mean "the answer you wanted isn't the last fixed point"
07:15:05 <Cale> wait, what? :)
07:15:07 <quicksilver> undefined is the least fixed point, indeed.
07:15:41 <hpaste_> Ben pasted “Parsec” at http://hpaste.org/51620
07:15:42 <Cale> He never actually said what he expected to get :)
07:15:54 <bgamari> Cale, quicksilver, dmwit: I'm beginning to think I'm just not writing this code optimally, http://hpaste.org/51620
07:16:09 <rostayob> Cale: I think he wanted 1
07:16:11 <bgamari> MyType represents a block of a file parsed with Parsec
07:16:13 <rostayob> no
07:16:15 <obiwahn> 2
07:16:18 <rostayob> 2
07:16:27 <bgamari> There should be exactly one of each type of block in the file
07:16:41 <Cale> bgamari: Well, you could probably stand to use more Applicative stuff.
07:16:43 <bgamari> Currently I just parse all of the blocks, building a list of MyType
07:17:02 <Cale> bgamari: But aside from that, it looks good to me, unless there's a performance issue with it.
07:17:14 <quicksilver> Cale: I knew what he wanted because I gave him that fixed point earlier as an example :)
07:17:22 <bgamari> Cale: Yeah, I'm still not entirely comfortable with Applicative
07:17:29 <bgamari> Cale: Nope, performance is acceptable
07:17:51 <bgamari> Cale: It just bothers me that I build this list of values, only to go back and pick it apart
07:18:06 * hackagebot kqueue 0.1.2 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.2 (ErikHesselink)
07:18:08 * hackagebot dbus-client 0.3.0.1 - D-Bus client libraries  http://hackage.haskell.org/package/dbus-client-0.3.0.1 (JohnMillikin)
07:18:23 <bgamari> Cale: I could use Parsec's user state to build a data structure representing the whole file, containing a field for each type of block
07:18:33 <bgamari> Cale: but I feel as though that is an abuse of user state
07:18:43 <Cale> Well, it's pretty common to combine the lexer and the parser with something like parsec... I haven't looked carefully at what your program is doing yet :)
07:19:21 <bgamari> Cale: Alternatively, I could try to build this structure in the prmTopFile parser
07:19:40 <Cale> Perhaps you want a "permutation parser"
07:19:42 <dmwit> bgamari: One of each, but no set order?
07:19:45 <dmwit> If so...
07:19:52 <dmwit> dang, Cale, you type just a hair faster than me =P
07:20:36 <bgamari> dmwit: I think it's safe to assume order
07:20:36 <imphasing> "One big difference is that right folds work on infinite lists, whereas left ones don't!" <- seems like it should be the other way around?
07:20:47 <koeien> imphasing: no
07:20:48 <koeien> @src foldl
07:20:49 <lambdabot> foldl f z []     = z
07:20:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:20:51 <imphasing> Infinite lists have a starting point (left side) but no end (right side) I would think?
07:20:58 <dmwit> bgamari: Oh, well, if the order is fixed, then you are definitely doing it wrong.
07:21:03 <copumpkin> you're thinking of it wrong
07:21:13 <nooodl> i'm making a 20x20 2D array where each element is False by default
07:21:30 <nooodl> "array ((0, 0), (19, 19)) [((i, j), False) | i <- [0..19], j <- [0..19]]" looks like it isn't the best way to do this
07:21:32 <bgamari> dmwit: Figures ;)
07:21:34 <Cale> imphasing: yes
07:21:51 <dafis> > foldr (++) "" (cycle "ha!")
07:21:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:21:52 <lambdabot>         against inferred ty...
07:21:59 <Cale> imphasing: foldr starts on the left
07:22:05 <dafis> > foldr (++) "" (repeat "ha!")
07:22:06 <lambdabot>   "ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha!ha...
07:22:11 <Cale> foldr f z [1,2,3]
07:22:12 <imphasing> Cale: wat :|
07:22:17 <dafis> > foldl (++) "" (repeat "ha!")
07:22:17 <bgamari> dmwit: You'd suggest that I just hard code the order in prmTopFile?
07:22:19 <Cale> -> f 1 (foldr f z [2,3])
07:22:21 <lambdabot>   mueval-core: Time limit exceeded
07:22:27 <imphasing> I guess they both start on the left?
07:22:28 <Cale> and then f gets to do its thing
07:22:29 <copumpkin> imphasing: foldr _associates_ the binary operation to the right, whereas foldl does it to the left
07:22:32 <dmwit> bgamari: do { v <- versionDecl; n <- atomNameBlock; c <- chargeBlock; l <- residueLabelBlock; p <- residuePointerBlock; return (v, n, c, l, p) } -- or whatever order it's in
07:22:36 <dmwit> bgamari: yes
07:22:46 <dmwit> bgamari: If you know the order, you should do that.
07:22:53 <Cale> imphasing: in a sense, yes, but foldr always reduces to something which isn't directly foldr in one step
07:22:53 <copumpkin> imphasing: you can't magically jump to the end of a singly linked list efficiently, so neither of them do that
07:22:53 <cgroza> What's wrong with this comprehension: let b = [x| x <- a, \Nothing -> True a] ? I am trying to filter out all Just's...
07:22:56 <dmwit> bgamari: That's what parsing is all about. =)
07:23:03 <Cale> @src foldr
07:23:04 <lambdabot> foldr f z []     = z
07:23:04 <dmwit> bgamari: If you don't know the order, then yeah, look at permutation parsers.
07:23:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:23:08 <Botje> cgroza: what does True a even mean?
07:23:22 <Cale> ^^ foldr f z immediately passes control to f in the nonempty case
07:23:31 <Botje> @src catMaybes
07:23:32 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:23:35 <dmwit> If you expect a particular order, and it's not in that order, you should complain!
07:23:36 <cgroza> Botje: a minute. i think i realized something.
07:24:02 <bgamari> dmwit: Alright, I suppose that's quite reasonable
07:24:02 <Cale> So f is allowed to produce part of its result, or perhaps stop the computation altogether, before looking at its second argument (which resumes the foldr)
07:24:14 <nooodl> why does [x | Just x <- ls] work :O
07:24:20 <bgamari> dmwit: Not sure why I didn't think to do that to begin with
07:24:48 <imphasing> Cale: Ooooh, I see...
07:24:49 <Cale> nooodl: because failures to pattern match inside list comprehensions skip those values
07:24:51 <nooodl> isn't the "... <-" in a list comprehension supposed to be just one name
07:24:53 <dafis> > fail "oops" :: [Int]
07:24:55 <lambdabot>   []
07:24:55 <cgroza> Botje: fixed it. I was passing the wrong argument for the lambda
07:24:58 <Cale> @src foldl
07:24:58 <lambdabot> foldl f z []     = z
07:24:59 <imphasing> Thanks :)
07:24:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:25:08 <dmwit> nooodl: No, it can be a pattern.
07:25:13 <Cale> ^^ in the nonempty list case, foldl just greedily calls itself, not allowing f to do anything
07:25:16 <dafis> nooodl: it's a pattern
07:25:21 <dmwit> nooodl: In which case values that don't match the pattern call "fail" instead.
07:25:24 <rostayob> > foldr const 0 $ repeat 1
07:25:25 <lambdabot>   1
07:25:28 <nooodl> oh, right
07:25:29 <Cale> (it builds up a big expression of f's)
07:25:29 <rostayob> > foldl const 0 $ repeat 1
07:25:32 <dafis> dmwit: type slower, please ;)
07:25:34 <nooodl> just like you can do "(a, b) <- c"
07:25:43 <dmwit> nooodl: Yes, exactly.
07:25:54 <dmwit> dafis: ok =)
07:25:55 <imphasing> Cale: Ah right, and foldr builds the partial list first?
07:26:06 <lambdabot>   thread killed
07:26:52 <Cale> foldr applies f immediately, and f gets to possibly produce part or all of its result before pattern matching on its second parameter and causing the recursive foldr to be evaluated
07:27:20 <Cale> > foldr (\x y -> x) 0 [1..]
07:27:24 <lambdabot>   1
07:27:37 <Cale> > foldr (\x y -> x : y) 0 [1..]
07:27:38 <lambdabot>   No instance for (GHC.Num.Num [a])
07:27:38 <lambdabot>    arising from a use of `e_101' at <inte...
07:27:42 <Cale> > foldr (\x y -> x : y) [] [1..]
07:27:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:27:54 <rostayob> > foldr1 f [a, b, c] :: Expr
07:27:56 <lambdabot>   f a (f b c)
07:28:01 <rostayob> > foldl1 f [a, b, c] :: Expr
07:28:03 <lambdabot>   f (f a b) c
07:28:16 <Cale> Another way to think about foldr f z is that it replaces each (:) in the construction of the list with f and any [] at the end with z
07:28:31 <Cale> foldl doesn't quite have as nice an interpretation
07:28:47 <Cale> http://cale.yi.org/share/Folds.svg -- but see this :)
07:30:05 <Cale> foldr and scanl are the ones which behave nicely w.r.t. lazy evaluation
07:30:46 <Cale> Well, scanr can too, in a sense.
07:31:09 <Cale> But scanl works well even when f is strict.
07:31:19 <Cale> > scanl (+) 0 [1..]
07:31:21 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
07:31:31 <JoeyA> > length $ scanl (+) 0 [1..]
07:31:59 <nooodl> <lambdabot> nope
07:32:02 <imphasing> that @src command would be sweet to have in ghci :)
07:32:04 <Cale> lambdabot is slow today... I should check that everything is okay
07:32:21 <Cale> imphasing: It just reads from a curated text file
07:32:22 <imphasing> Thanks for your help Cale, it's becoming a bit clearer now :D
07:32:25 <imphasing> Ah, ok
07:32:49 <Cale> Some of the definitions aren't the real ones in GHC even, they're mostly chosen for clarity :)
07:32:59 <Cale> Most of them are from the Report
07:33:00 <JoeyA> I might have just OOMed lambdabot
07:33:06 <rostayob> imphasing: Expr is even clearer
07:33:10 <rostayob> then @src
07:33:12 <rostayob> at least imho
07:33:14 <dafis> > scanr const 0 [1 .. ]
07:33:16 <Cale> JoeyA: not with that length thing, surely.
07:33:18 <lambdabot>   mueval-core: Time limit exceeded
07:33:24 <JoeyA> > 2+2
07:33:25 <lambdabot>   4
07:33:30 <dafis> > scanr const 0 [1 .. 5]
07:33:30 <tac-tics> They say Cale can foldl' infinite lists!
07:33:31 <lambdabot>   [1,2,3,4,5,0]
07:33:32 <Cale> maybe it just neglected to give you the timeout message for some reason
07:33:37 <Cale> tac-tics: hah
07:33:41 <rostayob> > foldr (+ 1) 0 [1, 2, 3, 4] :: Expr
07:33:42 <lambdabot>   1 + 1
07:33:44 <dafis> @src scanr
07:33:45 <lambdabot> scanr _ q0 []     =  [q0]
07:33:45 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
07:33:45 <lambdabot>     where qs@(q:_) = scanr f q0 xs
07:33:48 <rostayob> oh right it reduces it
07:33:51 <JoeyA> Cale: The thunks aren't forced in my expression, so the code above leaks memory.
07:33:53 <rostayob> > foldr (+ 1) x [1, 2, 3, 4] :: Expr
07:33:55 <lambdabot>   1 + 1
07:33:57 <JoeyA> I almost OOMed myself trying to run it.
07:33:59 <Cale> JoeyA: sure
07:34:21 <rostayob> > foldr f 0 [1, 2, 3, 4] :: Expr
07:34:23 <lambdabot>   f 1 (f 2 (f 3 (f 4 0)))
07:34:27 <rostayob> > foldl f 0 [1, 2, 3, 4] :: Expr
07:34:28 <lambdabot>   f (f (f (f 0 1) 2) 3) 4
07:34:33 <Cale> JoeyA: though lambdabot limits both space and time usage in a strict way
07:34:42 <quicksilver> JoeyA: lambdabot only gives it a rather short time to run before killing it, though, and runs under rlimits.
07:35:11 <rostayob> from that is pretty clear why "foldr1 const [1..]" works and "foldl1 const [1..]" doesn't
07:35:48 <Cale> foldl1 (flip const) [1..]  also doesn't work though :)
07:35:57 <Cale> (but that also should be clear)
07:36:23 <rostayob> Cale: you meant foldr1 (flip const)
07:36:30 <rostayob> > foldr1 (flip const) [1..]
07:36:34 <lambdabot>   mueval-core: Time limit exceeded
07:36:36 <Cale> nope, I meant foldl
07:37:03 <rostayob> well yeah, both flipped and normal
07:37:21 <Cale> foldl1 (flip const) [1..] looks like it might work to get the last element, except that clearly doesn't exist :)
07:37:27 <rostayob> ah yeah
07:38:24 <Cale> You wouldn't have to dig through an infinite application of f's, but you still have to find the end of the list.
07:41:28 <chrisdone> http://hpaste.org/51607 — i indent my code with a potato
07:43:25 <mah_b> Hi, are there other better program inspectors than hlint?
07:44:45 <tromp> there's #haskell, but that's only suitable for one-liners:)
07:45:24 <dafis> hpaste works for several lines
07:45:38 <dafis> (together with #haskell)
07:46:08 <mah_b> but both use hlint under the hood, don't they?
07:46:48 <mah_b> anyway, thank you
07:46:51 <quicksilver> as far as I know hlint is the only tool that does that kind of thing.
07:47:01 <leod> yeah, #haskell definitely uses hlint under the hood
07:47:36 <mamalujo> ok, this wasn't fun, but reactive-banana-wx finally works :) .cabal file lacked two dependencies, and making wx themselves to work required facing bug #5289 (solved in 7.4 for linux only) and not using runhaskell...
07:47:39 <dafis> chrisdone: your indentation for case is eeeevil
07:47:43 <Jafet> GHC is possibly better than hlint.
07:47:53 <chrisdone> dafis: yeah, i feel like i'm being trolled by that guy's indentation
07:48:05 <Jafet> In any sense that they're comparable at all--they inspect different things
07:48:11 <dafis> chrisdone: whose?
07:48:19 <chrisdone> dafis: the one i pasted
07:48:44 <dafis> chrisdone: yeah, who did it? emacs-mode-0.(-12)?
07:49:32 <Zevras> Any major new tutorials come out in the last year or so? I really want to try to get haskell, but generally find LYAH to be too superficial (is there any example in there longer than 4 or 5 lines?) and RWH tends to lose me around chapter 6
07:49:42 <Zevras> so something in-between would be ideal
07:50:07 <dafis> Any volunteer to write LYARWH?
07:50:43 <rostayob> Zevras: have you read all LYAH? I don't think it's superficial, I think it's great if you want to learn the basics
07:50:49 <imphasing> I'm finding LYAH to be pretty great myself, out of all the tutorials I've found so far
07:50:50 <Jafet> You don't really have to get haskell.
07:51:03 <dafis> haskell gets you
07:51:07 <Jafet> Lots of people don't, and it works fine for them.
07:51:15 <rostayob> if you stare at haskell to long...
07:51:29 <Jafet> That joke is dead
07:51:33 <Zevras> rostayob: But I know the basics... I've done FP in other languages (Lisp, ML, etc)
07:51:36 <obiwahn> dafis: what is the rw?
07:51:48 <Zevras> what I don't find in lyah is any actual substantial worked examples
07:51:52 <Zevras> just lots of cute one liners
07:51:54 <rostayob> Zevras: you probably need LYAH anyway for tye typing system stuff
07:51:56 <dafis> obiwahn: real world
07:51:59 <rostayob> *the type system
07:52:03 <Zevras> which are fine and all for learning stuff like foles
07:52:05 <Zevras> *folds
07:52:06 <obiwahn> i would read i :)
07:52:27 <Zevras> but it doens't really seem to get into stuff like actual tasks that are more than a single data transformation
07:52:43 <imphasing> Everything is a single data transformation
07:52:52 <imphasing> Just composed with other ones :D
07:53:06 <rostayob> Zevras: so wait, you understand already the material that LYAH covers? In that case, you should be able to stand on your own feet and start writing something
07:53:20 <rostayob> I'd read the typeclassopedia as well
07:53:38 <rostayob> @where typeclassopedia
07:53:38 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
07:54:06 <rostayob> and you can browse the chapters that look interesting of RWH, you don't have to read it sequentially
07:54:09 <Zevras> rostayob: I wouldn't say I *know* it
07:54:15 <Zevras> but it seems a bit...hand wavy
07:54:22 <Zevras> like he focused more on stuff that haskell is good at
07:54:25 <Jafet> Zevras: why do you want to "get haskell"?
07:54:28 <Zevras> and not how to approach more general problems
07:54:44 <rostayob> Zevras: you need to understand those things to understand code written in haskell :P
07:54:49 <mamalujo> Zevras: maybe that Scheme in 48hrs then? I found A Gentle Introduction good too - despite the title, it presumes some knowledge of fp and focuses on what's different about hs
07:55:52 <rostayob> Zevras: if you already know ML maybe this is the chapter you need more http://learnyouahaskell.com/making-our-own-types-and-typeclasses
07:56:18 <Jafet> I guess if you already know ML, then you're a target of the Gentle Introduction
07:56:39 <Jafet> Regardless, you should answer the question I asked.
07:57:13 <rostayob> well we'd first have to define "get haskell" more precisely eheh
07:57:25 <Zevras> Jafet: Isn't it sort of obvious? Haskell is cool...I'd like to be able to use it productivly e.g. right actual systems in it
07:58:00 <Clint> and wrong them
07:58:08 <rostayob> ahah
07:58:15 <armlesshobo> man, haskell never ceases to surprise me with all the cool things it can do. and still, i've only begun to scratch the surface
07:58:16 <Jafet> They tend to be wrong to start with.
07:58:33 <Jafet> Zevras: then what's wrong with RWH?
07:58:46 <rostayob> Zevras: anyway I'd worry if you get bored by LYAH. it's great
07:59:07 <mamalujo> Zevras: hmm, no I think for practical-style introduction, RWH is really the way to go, but you should be able to use that if you're somewhat comfortable w the language itself
07:59:14 <Zevras> Jafet: RWH starts off fine, and then it sort of jumps off the deep end
07:59:24 <Jafet> Zevras: if you have a short attention span... leave it at the door.
07:59:25 <armlesshobo> Zevras: well, there's a lot to be learned with RWH and LYAH. I contend it would be insufficient to not read either of those books
07:59:26 <Zevras> it's like...ok ok ok ok ok WTF?
07:59:35 <mamalujo> hehe
07:59:59 <Jafet> Alternatively, if you have a question about RWH, you can ask it here.
08:00:25 <Zevras> now that I look at it, it looks like lyah has grown since I looked at it
08:00:28 <Zevras> which was several years ago
08:00:37 <Zevras> I only remember it having like 8 chapters
08:00:38 <armlesshobo> Zevras: you must understand that it's important that you play with the examples they give you. Don't just settle for face value.
08:01:03 <armlesshobo> Use what you learned in previous chapters and go buck wild with it.
08:01:38 <mamalujo> Zevras - really, try a little bit more about the lang itself then first, (perhaps for eg implementing scheme using parsec lib would be practical enough a task to keep you interested, rather than dry lang ref). then go back to that 'deep end' :)
08:01:47 <monochrom> yeah, "ok ok ok wtf" gives out an impression that you're doing a spectator sport
08:02:11 <Jafet> Be nice, it's probably just ADHD.
08:03:29 <armlesshobo> Zevras: you should just read through the book(s) once, look at more practical examples online, and then reference books as necessary
08:03:33 <armlesshobo> Zevras: in your case.
08:03:47 <rostayob> nanomad: ngi?
08:04:16 <Zevras> ok, sounds like a plan
08:04:42 <nanomad> rostayob: no goku
08:04:47 <nanomad> rostayob: :)
08:05:05 <nanomad> rostayob: sì :)
08:05:17 <rostayob> nanomad: cool :)
08:05:45 <nanomad> ahhh
08:08:06 * hackagebot emgm 0.4 - Extensible and Modular Generics for the Masses  http://hackage.haskell.org/package/emgm-0.4 (SeanLeather)
08:12:26 <matthiasgorgens> @pl  Functor f => (a -> b) -> (a1 -> f a) -> a1 -> f b
08:12:26 <lambdabot> (line 1, column 17):
08:12:26 <lambdabot> unexpected ">"
08:12:26 <lambdabot> expecting variable, "(", operator or ")"
08:12:45 <matthiasgorgens> (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
08:13:12 <matthiasgorgens> hmm.
08:13:40 <rostayob> matthiasgorgens: maybe you meant djinn?
08:13:59 <rostayob> but it wouldn't work anyway :P
08:14:21 <quicksilver> maybe he meant hoogle
08:14:33 <rostayob> quicksilver: maybe. but djinn is cooler
08:14:45 <dafis> :t \f g -> fmap f . g
08:14:51 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
08:15:20 <quicksilver> :t \f g -> fmap f Prelude.. g
08:15:21 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => (a -> b) -> (a1 -> f a) -> a1 -> f b
08:15:26 <quicksilver> dafis: ;)
08:16:32 <Blkt> cya tomorrow everyone
08:23:12 <nanomad> FlashCode: weechat-tcl.c:96: error: implicit declaration of function `Tcl_DictObjPut'
08:23:24 <nanomad> that's the only error I got
08:25:49 <nanomad> wrong chan sorry
08:27:15 <monochrom> heh tcl
08:41:11 <matthiasgorgens> rostayob, i guess i meant djinn, yes.
08:42:20 <matthiasgorgens> dafis, yes, i fonud that.  but i was looking for a more pointless version.
08:44:11 <dafis> @pl \f g -> fmap f . g
08:44:11 <lambdabot> (.) . fmap
08:44:26 <dafis> pointless enough?
08:44:39 <leod> maybe a bit too pointless
08:44:50 <dafis> (fmap f .)
08:47:02 <mysticc> > :t sequence
08:47:03 <lambdabot>   <no location info>: parse error on input `:'
08:47:11 <mysticc> >:t sequence
08:47:13 <dafis> :t sequence
08:47:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:47:45 <buntfalke> Is there something comparable to the Haskell Report for, let's say, C? I know there are the Standards like C99, but are they in any way -- uhm -- usable, readable for reference in an every day manner like it is the case with Haskell?
08:47:47 <dafis> mysticc: no > for :t
08:48:32 <dafis> buntfalke: by far not as readable, but the authoritative spec
08:49:07 <armlesshobo> :t \f g -> f -> g -> Int
08:49:09 <lambdabot> parse error on input `->'
08:49:10 <buntfalke> Okay, thought so
08:49:12 <buntfalke> thanks dafis
08:49:53 * Cale could make some glib remarks about the reasons for this.
08:50:22 <dafis> glibc remarks?
08:54:12 <mysticc> It sounds crazy but I want something similar to sequence with a limit on the lenght list .. I have a infinite list [m (Maybe a)]  and I want to sequence  until the length of all Just type outputs  becomes some constant n .. Note monad is of type Maybe a so it may return nothing and I am not counting nothing ...
08:58:45 <ClaudiusMaximus> mysticc: i'd attack that problem with recursion, i doubt there's a ready made combinator for that
09:00:10 <mysticc> ClaudiusMaximus: Can you guide me to the approach I should take ... I have made mycustomsequence which neglects Nothing as output .. but still wondering on how to limit the size ??
09:02:21 <ClaudiusMaximus> i don't know if this is the "best" approach, but it'd be my first try - something like:  foo n [] = return [] ; foo 0 xs = return [] ; foo n (x:xs) = do m <- x; case m of Nothing -> ... ; Just a -> ...
09:06:23 <ClaudiusMaximus> :t \n -> take n . catMaybes . sequence
09:06:25 <lambdabot>     Couldn't match expected type `Maybe a' against inferred type `[a1]'
09:06:25 <lambdabot>       Expected type: [[a1]] -> [Maybe a]
09:06:25 <lambdabot>       Inferred type: [[a1]] -> [[a1]]
09:07:06 <leod> @type catMaybes
09:07:08 <lambdabot> forall a. [Maybe a] -> [a]
09:12:34 <leod> @type \n xs -> take n . catMaybes <$> sequence xs
09:12:35 <lambdabot> forall a (f :: * -> *). (Monad f, Functor f) => Int -> [f (Maybe a)] -> f [a]
09:12:40 <leod> not sure if it does the correct thing, though :P
09:14:22 <ClaudiusMaximus> > take 5 . catMaybes <$> sequence . cycle [Just 3, Nothing]
09:14:23 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
09:14:23 <lambdabot>         against inferred ...
09:14:31 <ClaudiusMaximus> > take 5 . catMaybes <$> (sequence . cycle) [Just 3, Nothing]
09:14:32 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
09:14:32 <lambdabot>    arising from a use of...
09:14:37 * ClaudiusMaximus gives up
09:15:28 <leod> well, it expects a list of Maybes wrapped in some other monad
09:17:24 <ClaudiusMaximus> > (take 5 . catMaybes) <$> (sequence . cycle) [Just 3, Nothing]
09:17:25 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
09:17:25 <lambdabot>    arising from a use of...
09:17:37 <ClaudiusMaximus> oh! true
09:17:55 <ClaudiusMaximus> > (take 5 . catMaybes) <$> (sequence . cycle . map (:[])) [Just 3, Nothing]
09:17:57 <lambdabot>   *Exception: stack overflow
09:18:06 <ClaudiusMaximus> > (take 5 . catMaybes) <$> (sequence . cycle . map Just) [Just 3, Nothing]
09:18:08 <lambdabot>   *Exception: stack overflow
09:18:12 <leod> interesting
09:18:17 <armlesshobo> monadicus
09:18:35 <armlesshobo> from now on, refer to me as monadicus
09:18:41 <armlesshobo> the dragonslayer
09:19:36 <sbrg> burritocus
09:19:49 <leod> right, sequence isn't lazy in that way
09:20:00 <leod> it can't terminate on infinite lists, can it?
09:20:05 <Axman6> no
09:20:12 <Axman6> @src sequence
09:20:12 <lambdabot> sequence []     = return []
09:20:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:20:12 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
09:20:18 <leod> because it has to give you one m [a]
09:20:53 <rwbarton> it might be able to, depending on the monad, but usually it won't
09:20:56 <Axman6> well because in he definition given there you have to run every action in xs before you can return v:vs
09:21:08 <rwbarton> > sequence $ repeat Nothing
09:21:10 <lambdabot>   Nothing
09:21:16 <leod> right!
09:22:10 <ClaudiusMaximus> > (take 5 . catMaybes) <$> (sequence . cycle) [Just (Just 3), Just Nothing, Nothing]
09:22:12 <lambdabot>   Nothing
09:22:57 <rwbarton> in the Maybe monad, it has to continue far enough to find out if there are any Nothings in the list, so if the list is infinite and there aren't any it can't return
09:25:09 <leod> yes, that makes sense
09:25:20 <leod> for some reason sequence has always been a bit mysterious to me
09:25:49 <BlankVerse> how do i create an instance of Int data type?
09:26:34 <BlankVerse> i have
09:26:43 <BlankVerse> instance YesNo Int where
09:26:49 <BlankVerse> yesno 0 = True
09:26:53 <BlankVerse> yesno + = False
09:27:03 <BlankVerse> srrry , yesno _ = False
09:27:16 <BlankVerse> calling yesno 23 , gives me error
09:27:28 <monoidal> BlankVerse: yesno (23 :: Int)?
09:27:31 <dafis> BlankVerse: yesno (23 :: Int)
09:27:38 <dafis> grrrr
09:27:47 <BlankVerse> yesno (23 :: Int)
09:28:02 <BlankVerse> so what does it do exactly
09:28:04 <BlankVerse> it works
09:28:18 <dafis> it tells the compiler which type to use
09:28:29 <BlankVerse> ahh .. ok , never came across that before
09:28:32 <dafis> :t 23
09:28:33 <lambdabot> forall t. (Num t) => t
09:28:35 <monoidal> BlankVerse: a normal number like 23 is polymorphic and can be used both as integer as float, for example 23 + 3.1
09:28:35 <BlankVerse> thanks
09:29:35 <dafis> so, without a signature, the compiler doesn't know whether to complain about a missing instance or to use Int or what
09:29:39 <BlankVerse> monoidal: got it... thats why we have fromInteger for adding a list's length with a float
09:29:52 <dafis> fromIntegral
09:29:56 <dafis> :t length
09:29:57 <lambdabot> forall a. [a] -> Int
09:30:14 <BlankVerse> :t fromInteger
09:30:15 <lambdabot> forall a. (Num a) => Integer -> a
09:30:26 <monoidal> BlankVerse: yes. A better solution would be that length would return any Num, but Prelude is kept that way
09:30:32 <mrcarrot> does anyone know about any good set of exercises? preferable something that would fit together with LYAH
09:30:32 <BlankVerse> > length [1..10] + 2.3
09:30:33 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
09:30:34 <lambdabot>    arising from the lit...
09:30:52 <BlankVerse> fromInteger . length [1..10] + 2.3
09:31:04 <BlankVerse> > fromInteger . length [1..10] + 2.3
09:31:06 <lambdabot>   Couldn't match expected type `f GHC.Integer.Type.Integer'
09:31:06 <lambdabot>         against i...
09:31:15 <BlankVerse> > fromInteger $ length [1..10] + 2.3
09:31:16 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
09:31:17 <lambdabot>         against inf...
09:31:30 <monoidal> BlankVerse: If you have *any* type, and implement instance Num for it, the function fromInteger will specify how to convert an integer literal to the type
09:31:33 <azaq23> @hoogle genericLength
09:31:34 <lambdabot> Data.List genericLength :: Num i => [b] -> i
09:31:44 <dino-> Having trouble finding this in GHC docs..:
09:32:07 <monoidal> BlankVerse: for example, if you define instance Num Bool where fromInteger 0 = False; fromInteger _ = True; then you can write (5 :: Bool) and that will be True
09:32:08 <dino-> I'd like to have -Wall in the .cabal and then turn off warnings in one specific source file.. is there a pragma for that?
09:32:45 <BlankVerse> monoidal: how can i read the source of Num typeclass?
09:32:56 <monoidal> BlankVerse: in GHC, :i Num
09:32:59 <monoidal> GHCi
09:33:00 <BlankVerse> and all the Data.* modules
09:33:12 <ClaudiusMaximus> dino-: you can turn off specific warnings with -fno-warn-foobaz or similar, and there's a pragma for ghc options
09:33:28 <siracusa> dino-: {-# OPTIONS_GHC -w #-}
09:33:29 <BlankVerse> monoidal: i was asking about their definition
09:33:50 <BlankVerse> monoidal: :i shows only declarations
09:33:52 <monoidal> BlankVerse: the definition of a type class is only a list of methods with types, no implementation
09:34:02 <dino-> Ah, do the actual GHC switch as a prams with OPTIONS_GHC
09:34:14 <monoidal> BlankVerse: the behaviour of fromInteger is a special thing built-in into language
09:34:19 <BlankVerse> monoidal: ok , thats true ... but the instances are defined
09:34:32 <BlankVerse> monoidal: somewhere and I wanted to look into the surce
09:34:36 <BlankVerse> * source
09:35:24 <dafis> @src Num
09:35:25 <lambdabot> class  (Eq a, Show a) => Num a  where
09:35:25 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:35:25 <lambdabot>     negate, abs, signum     :: a -> a
09:35:25 <lambdabot>     fromInteger             :: Integer -> a
09:35:36 <BlankVerse> @src Int
09:35:37 <lambdabot> data Int = I# Int#
09:35:46 <BlankVerse> @src instance Num Int
09:35:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:36:11 <chrisdone> unsafePerformScienceOnRockets
09:36:45 <monoidal> BlankVerse: instances like Num Int are built-in and it's hard to find their source; for most of Prelude, http://www.haskell.org/onlinereport/standard-prelude.html
09:37:04 <imphasing> @src foldr1
09:37:05 <lambdabot> foldr1 _ [x]    = x
09:37:05 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
09:37:05 <lambdabot> foldr1 _ []     = undefined
09:37:52 <chrisdone> chris@cn-done:~$ hoogle 'Int -> Int' | head
09:37:53 <chrisdone> Test.HUnit.Base ListItem :: Int -> Node
09:37:54 <chrisdone> ~_~
09:37:58 <Rc43> Hy, guys.
09:38:05 <chrisdone> hoogle, why are you so silly?
09:38:23 <Rc43> Can I make application such way that I will be able change code while running?
09:38:37 <chrisdone> Rc43: yes, but with great difficulty and pain
09:39:01 <imphasing> paul graham would be yelling about lisp right now
09:39:02 <Rc43> chrisdone, I can't somehow use ghci for that?
09:39:05 <yitz> Rc43: it depends what you want to change and how
09:39:29 <yitz> Rc43: in short, it depends what your application is
09:39:37 <Rc43> imphasing, for lisp it is standard?
09:39:51 <chrisdone> it is built into lisp, yes
09:39:53 <bayesian> I beleive haskell was created in 7 literal days
09:40:13 <yitz> Rc43: if you are designing telephone exchange equipment with huge realtime systems that require 100% uptime even when upgrading the software, you might want to look at Erlang
09:40:15 <bayesian> 6000 years ago
09:40:30 <Rc43> yitz, for example I want a MVC system and I want to make controller changeable without restart.
09:40:47 <chrisdone> snap can do something like this, if it works
09:41:02 <chrisdone> it reloads the code when the files change
09:42:11 <Rc43> So using erlang or lisp for such problem isn't a pain?
09:43:00 <bayesian> The power of haskell is immense
09:43:15 <bayesian> I know in my heart
09:43:20 <Rc43> oh
09:43:30 <Rc43> erlang can do it because it is on VM?
09:44:14 <Rc43> Haskell can be runned on LLVM, so may be it will be less hard to implement on-fight code refreshing?
09:44:14 <mm_freak_> Rc43: haskell can do that, but for real time deployment of individual components, erlang is also good
09:44:36 <mm_freak_> in haskell the easiest way is to write individual components as plugins or individual programs
09:44:40 <Rc43> > on-fight, lol
09:44:42 <lambdabot>   <no location info>: parse error on input `,'
09:44:44 <mm_freak_> using cabal this is easy to do
09:45:08 <yitz> Rc43: if what you want is a web site which needs high reliability even while upgrading the software, it is certainly possible to do that in haskell just as easily as on any other platform.
09:45:28 <dino-> Some of this is made easier in Erlang by it not having such a strong idea of typing too.
09:45:32 <yitz> Rc43: it would be very modular with separation of concerns.
09:46:19 <yitz> Rc43: but you wouldn't want to start out with a particular OO design pattern as a hard-wired requirement though.
09:46:36 <mm_freak_> dino-: i don't think typing is related to that at all
09:46:37 <yitz> Rc43: haskell is intentionally not an OO language.
09:47:00 <mm_freak_> in fact dynamic typing would even stand in the way of having /safe/ upgradable plugins
09:47:20 <dino-> mm_freak_: I was thinking of the hotfix updating of live systems.
09:47:31 <mm_freak_> dino-: me too
09:47:34 <bayesian> Haskell is REAL and it's here today
09:47:50 <Rc43> yitz, so you think that such problems i should solve with OO?
09:47:58 <yitz> Rc43: no
09:48:03 <mm_freak_> anyway…  compiled haskell can't help you with hotfix upgrading of individual code files
09:48:06 <Rc43> yitz, or it is easy to create haskell modules?
09:48:12 <mm_freak_> if you want to do that, you need to use interpreted haskell
09:48:25 <Rc43> mm_freak, but ghci can load compiled code
09:48:37 <lgm> Good day, Haskellians!
09:49:04 <mm_freak_> Rc43: true
09:49:07 <dmwit> Howdy, lgm.
09:49:12 <yitz> Rc43: if you decide to begin with that you are using an OO language, then yes. otherwise, define your actual functional requirements and then design a system that does that in the natural way on the development platform you are using.
09:49:52 <chrisdone> > "good m" ++ replicate 50 'o' ++ "rning"
09:49:53 <lambdabot>   "good moooooooooooooooooooooooooooooooooooooooooooooooooorning"
09:50:00 <mm_freak_> i always have problems expressing what i want cleanly in OOP
09:50:08 <bayesian> Only haskell programmers should be allowed to have children
09:50:21 <chrisdone> chris@cn-done:~$ hoogle 'Int -> Int' | head
09:50:21 <chrisdone> Test.HUnit.Base ListItem :: Int -> Node
09:50:21 <chrisdone> does this make sense to *anyone*?
09:50:28 <mm_freak_> OO is such a poor concept, which just forces me to put containers around everything, i feel
09:50:32 <imphasing> Does it make sense to think of foldr as giving the combinator the accumulator argument as the first arg and the next item the second, whereas foldl gives the combinator the accumulator as the first argument?
09:50:35 <mm_freak_> that's true at least for C++ style OO
09:50:50 <bayesian> think outside the bOOx
09:50:51 <mm_freak_> imphasing: reverse that, then it's true
09:51:00 <yitz> Rc43: if by "MVC" you don't mean the classic OO design pattern but rather that you want to separte concerns, then yes, you can do it in haskell.
09:51:01 <imphasing> er, yeah hehe
09:51:12 <Rc43> yitz, mm_freaka, can you tell me how runtime module loadiing will look?
09:51:17 <imphasing> foldr gets the accumulator second, foldl gets the accumulator first
09:51:31 <mm_freak_> Rc43: haven't used it myself, but there is at least one library on hackage
09:51:48 <chrisdone> i can't tell if this is a bug or some clever logic that i don't understand
09:51:58 <Rc43> mm_freak, what's name of lib?
09:52:02 <imphasing> chrisdone: Is there a difference?
09:52:02 <imphasing> :D
09:52:12 <mm_freak_> imphasing: it's actually a bit more…  note that foldl has different associativity and following from that different semantics
09:52:28 <chrisdone> imphasing: yeah, for the former the bug fix would be in the software, for the latter the bug fix would be for me ;)
09:52:34 <Rc43> yitz, what do you mean by "concern"? Working unit?
09:52:59 <yitz> Rc43: if by "changeable without restart" you don't mean a Java framework or something, but just that you want your web site to keep running when you install software upgrades (for example), then yes, haskell is fine.
09:53:01 <mm_freak_> Rc43: found two, direct-plugins and plugins
09:53:15 <mm_freak_> both give you dynamic linking
09:53:15 * hackagebot xml 1.3.10 - A simple XML library.  http://hackage.haskell.org/package/xml-1.3.10 (IavorDiatchki)
09:53:18 <Rc43> mm_freak, thanks
09:53:29 <bayesian> WHY IS HASKELL SO EXCITING
09:53:45 <mm_freak_> there is also happstack-plugins, but i guess that one is specific to happstack
09:54:01 <lgm> i have a question about parameterized monads, again
09:54:45 <Rc43> yitz, I mean frequent changes while development (but it is solved with ghci + compiled parts) and agile module (plugin?) connecting.
09:54:48 <lgm> reference: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.159.2355&rep=rep1&type=pdf
09:55:42 <Rc43> mm_freak, i think i needn't happstack, i dont think about web-app.
09:55:45 <yitz> Rc43: no, "concern" means some logically distinct part of your functional requirements. like the visual appearance of your web site vs. storing persistent data vs. the interactive workflow that the user experiences, etc.
09:55:51 <lgm> In Atkey's presentation, a parameterized (strong monad) has a mult (that's join in Haskell lingo) with the type
09:57:01 <yitz> @vixen please forward all @faq requests to bayesian
09:57:02 <lambdabot> I can take it. The tougher it gets, the cooler I get.
09:57:11 <Cale> bayesian: having a good time with it?
09:57:12 <Rc43> yitz, so here [21:48] the second variant (i want to separte concerns)
09:57:29 <bayesian> I didnt install it
09:57:38 <bayesian> Haskell is based on circular logic
09:57:39 <lgm> mult :: ((((A -> S2) -> S3) -> S1) -> S2) -> (A -> S1) -> S3
09:57:43 <bayesian> you need it to use it
09:57:56 <bayesian> therefore, it is the first cause
09:58:24 <mysticc> how to define takeM which has type :: Int -> m [a] -> m [a] ... it takes first n entries from the list inside monad
09:58:26 <mysticc> ?
09:58:50 <lgm> the term he claims satisfies this type is \k -> f( \k' -> k' k )
09:58:58 <dafis> liftM (take n)
09:59:45 <bayesian> It could have ben beamed down by aliens
09:59:54 <BlankVerse> @src Data.Map
09:59:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:59:57 <bayesian> that explains why nobody knows wher it came from
10:00:11 <asflierl> maybe the penguins know
10:00:19 <lgm> sorry, if f :: (((A -> S2) -> S3) -> S1) -> S2, then \k -> f( \k' -> k' k ) : (A -> S1) -> S3
10:00:25 <bayesian> "UFO" regularly travel from the ice wall over earth
10:00:50 <rwbarton> :t \f -> \k -> f (\k' -> k' k)
10:00:51 <lambdabot> forall t t1 t2. (((t -> t1) -> t1) -> t2) -> t -> t2
10:00:56 <bayesian> they could have realized that LAMBDA is the true language of the universe
10:01:08 <asflierl> or they felt like making a joke
10:02:04 <lgm> This would mean that (\k' -> k' k) : ((A -> S2) -> S3) -> S1
10:02:31 <rwbarton> @djinn ((((a -> s2) -> s3) -> s1) -> s2) -> (a -> s1) -> s3
10:02:32 <lambdabot> -- f cannot be realized.
10:02:36 <lgm> which would mean that k' : (A -> S2)-> S3
10:02:58 <rwbarton> @djinn ((((a -> s1) -> s2) -> s2) -> s3) -> (a -> s1) -> s3
10:02:59 <lambdabot> f a b = a (\ c -> c b)
10:03:19 <bayesian> haskell could be the catalyst of radical political change
10:03:30 <Rc43> I suppose, that http://hackage.haskell.org/package/direct-plugins or http://hackage.haskell.org/package/plugins also will help me to implement common interface between my modules, right?
10:03:56 <Rc43> I will need such interface to be able implement different versions of components.
10:04:19 <lgm> however, we know that k : A -> S1
10:04:34 <lgm> so, k' cannot be applied to it
10:05:24 <lgm> Can anyone verify this calculation?
10:05:31 <rwbarton> djinn just did
10:05:33 <bayesian> lgm, Yes
10:05:39 <lgm> i believe that the Atkey paper is in error
10:05:46 <bayesian> I am witness
10:05:49 <bayesian> to this calculation
10:05:58 <parcs> preflex: seem apfelmus
10:06:02 <yitz> @. pl djinn ((((a -> s1) -> s2) -> s2) -> s3) -> (a -> s1) -> s3
10:06:03 <lambdabot> f = (. flip id)
10:06:05 --- mode: ChanServ set +o Saizan
10:06:06 <parcs> preflex: seen apfelmus
10:06:06 <preflex>  apfelmus was last seen on #haskell 77 days, 22 hours, 56 minutes and 30 seconds ago, saying: byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
10:06:13 <imphasing> bayesian is a bot, right? :?
10:06:13 <bayesian> HALLELUJA
10:06:19 --- mode: Saizan set +q bayesian!*@*
10:06:29 <Saizan> too much noise.
10:06:43 --- mode: Saizan set -o Saizan
10:07:29 <lgm> Cale: are you there?
10:09:39 <FredOverflow> What are the Monad equivalents of <$> and <*> from Applicative?
10:10:07 <shachaf> FredOverflow: liftM and ap
10:10:16 <shachaf> Though why use them?
10:10:33 <monoidal> FredOverflow: also ap = liftM2 ($)
10:10:40 <dafis> to not need an additional Applicative constraint
10:10:58 <monoidal> and liftM = fmap
10:11:43 <mm_freak_> FredOverflow: also you may want to use liftA2 instead of (<$>) and (<*>)
10:12:12 <mm_freak_> (&&) <$> eval' a <*> eval' b = liftA2 (&&) (eval' a) (eval' b)
10:12:19 <mm_freak_> personally i find the latter much more readable
10:12:20 <rwbarton> lgm: where is this example in that paper?
10:12:47 <FredOverflow> mm_freak_: Are you reading stack overflow? :)
10:13:15 <kirindave> Ugh, my friends are giving me a tough time about STM today.
10:13:16 * hackagebot dingo-widgets 0.0.2 - Dingo Widgets  http://hackage.haskell.org/package/dingo-widgets-0.0.2 (BardurArantsson)
10:13:34 <kirindave> http://queue.acm.org/detail.cfm?id=1454466 is being brought up.
10:13:35 <mm_freak_> FredOverflow: yes ;)
10:13:40 <rwbarton> oh I see it
10:13:48 <FredOverflow> mm_freak_: okay got it working
10:13:49 <dafis> kirindave: atomically replaceFriends
10:14:03 <kirindave> dafis: They just love java.util.concurrent
10:14:06 <kirindave> Don't h8
10:14:23 <mm_freak_> FredOverflow: anyway, whenever you want to make parameters implicit, ask yourself whether you really want to make them implicit or just want to save yourself some typing
10:14:43 <mm_freak_> in the latter case, you shouldn't need to change the type signature, but just use a different set of combinators
10:15:10 <FredOverflow> mm_freak_: Just trying to understand Monads better is all.
10:15:24 <copumpkin> kirindave: they're assholes
10:15:31 <rwbarton> lgm: there's no error in the paper, you've expanded the type of that mult function incorrectly (T(R_1, R_2, A) is not (A -> R_1) -> R_2 but rather (A -> R_2) -> R_1)
10:15:58 <kirindave> copumpkin: I dunno if I agree.
10:15:59 <simon> which functions should I implement when adding an instance for (MonadState MyState m)?
10:16:09 <copumpkin> kirindave: or rather, they're misinterpreting STM as found to be a failure by those guys as STM as an inherent failure
10:16:19 <kirindave> I wish I knew more about the various implementations of STM to debate it.
10:16:26 <copumpkin> kirindave: I'd expect STM to fail if you need to track all variables all the time
10:16:28 <mm_freak_> FredOverflow: monads are also a certain combinator style
10:16:30 <copumpkin> because you have rampant mutation
10:16:42 <copumpkin> kirindave: when you can designate one or two shared state variables as STM-worthy
10:16:46 <kirindave> copumpkin: Right, usually it ends up being tightly controlled in haskell and clojure.
10:16:48 <copumpkin> then I think it's a clear win
10:16:49 <copumpkin> yeah
10:17:02 <mm_freak_> FredOverflow: in many cases the applicative style is nicer than the monadic style, but you can't always use it
10:17:05 <copumpkin> but that won't ever stop people from citing that almost completely unrelated research at us
10:17:05 <kirindave> I mean, appending to a TVar Sequence in haskell is plenty fast.
10:18:02 <copumpkin> yep
10:18:03 <Cale> kirindave: STM *is* only a research toy if your assumption is integration into a language like Java, which makes it totally unreasonable.
10:18:21 <kirindave> Cale: I think Clojure does a good job of it.
10:18:36 <kirindave> Although clojure is more like saddling java rather than integrating with it.
10:18:52 <copumpkin> I think people trying to integrate STM into all variables/assignment are just missing the point, honestly
10:19:35 <lgm> rwbarton: thanks! i was wondering if i introduced a twist somewhere
10:19:39 <lgm> let me check this
10:19:59 <kirindave> copumpkin: And also The Boat, which is gradually leaving them behind.
10:20:05 <Cale> fsvo reasonable... clojure can get away with it to a fair extent because they've managed to make most operations pure, even if they don't really control what's allowed to cause effects and what isn't
10:20:22 <lgm> thing is -- if i've twisted it, i've twisted it twice
10:20:47 <Cale> Though even in clojure, it's not safe like it should be.
10:20:50 <kirindave> copumpkin: Already working with things like haskell in parallel programming is an order of magnitude easier than doing it with j.u.c. I just don't really have the heart to tell them this yet.
10:21:00 <copumpkin> yeah
10:21:04 <kirindave> They're busy being grumpy about <+>
10:21:05 <copumpkin> even doing crazy imperative stuff!
10:21:09 <kirindave> and other operator-like calls.
10:21:09 <copumpkin> which is sad
10:21:26 <copumpkin> cause everyone knows haskell is only good for writing fibonacci
10:22:55 <b_jonas> copumpkin: fibonacci and factorial
10:23:21 <imphasing> Scans are like folds, but instead of reducing to a value, they append each computed value to a list?
10:23:30 <imphasing> Seems like just a shortcut for a fold
10:23:50 <b_jonas> imphasing: yes, but they're very useful
10:23:56 <imphasing> Like the way map is implemented as a fold, I imagine map could be implemented as a scan pretty easily too..
10:24:29 <b_jonas> imphasing: it can, but not as a scan1
10:25:43 <wavewave> hi, all
10:25:53 <wavewave> I have a question on license.
10:26:33 <wavewave> if my code statically links to some GPL code, then my code cannot be published under BSD3. Is this right?
10:27:09 <augur> copumpkin!
10:27:21 <b_jonas> wavewave: try asking on #gnu ...
10:27:23 <augur> whats a good visualization of a binary space?
10:27:28 <augur> with n binary dimensions
10:27:58 <wavewave> b_jonas: sorry that I am asking here.. but it's haskell package that will be on hackage.
10:28:33 <tsuraan> wavewave: I think you can dual-license GPL/BSD, and then people can take interesting bits of your code without giving back.  is that what you want?
10:28:34 <b_jonas> wavewave: okay, sorry, ask here first, but if you don't get an answer, ask on #gnu, but beware that it's full of trolls
10:28:49 <lgm> rwbarton: you were correct! the double twist (alternately, untwisting what i twisted) gives the right types
10:29:08 <mokus> i would think the code can be distributed under any license you want, but if the binary is distributed then it must be licensed under gpl
10:29:09 <lgm> for some reason i'm just not trusting the Atkey paper
10:29:14 <byorgey> rostayob: did anyone answer your question about the difference between Foldable and catamorphism?
10:29:20 <chrisdone> yeahhhh http://chrisdone.com/anything-hoogle.ogv
10:29:29 <Saizan> wavewave: afaiu, your sources can still be BSD3, but an executable built using your lib will have to respect both the terms of the GPL for the lib and BSD3 for your code
10:29:36 <chrisdone> bit slow, i need to make it asynchronous, but, nice.
10:29:39 <kmc> wavewave, tsuraan I think you can link BSD code to GPL code without even dual-licensing the BSD code
10:29:43 <FredOverflow> @pl \a b -> (&&) <$> eval' a <*> eval' b
10:29:43 <lambdabot> (((&&) <$>) .) . (. eval') . (<*>) . eval'
10:29:46 <kmc> you're just required to comply with *both* licenses for the linked binaries
10:29:51 <kmc> as Saizan said
10:30:02 <tsuraan> sounds reasonable :)
10:30:04 <kmc> ignorant assholes will get angry at you for doing this
10:30:13 <kmc> but i think it's better, if you want your code to be widely used
10:30:14 <tsuraan> they're always angry about something though
10:30:27 <kmc> better than using a more restrictive license just because someone else does
10:30:34 <kmc> after all, maybe someone replaces the GPL dep down the line
10:30:36 <wavewave> tsuraan b_jonas Saizan kmc : thanks !! it makes sense to me now.
10:30:46 <kmc> or maybe someone wants to copy a helpful function or two from your code
10:30:54 <kmc> or maybe the author of the GPL dep relicenses it!
10:31:06 <tsuraan> like Jerasure did :)
10:31:11 <c_wraith> Huh.  I should change non-cryptr to bsd3
10:31:14 <c_wraith> err, nano-
10:31:24 <imphasing> This is the best I could do implementing map as a scan: scanMap f (x:xs) = scanl (\acc e -> f e) (f x) xs
10:31:28 <imphasing> Is there a better way?
10:31:57 <kmc> implement it as a fold instead :)
10:32:28 <byorgey> imphasing: that is not a correct implementation of map, because it crashes on the empty list
10:32:44 <imphasing> That's trivial to fix with a pattern though
10:33:00 <imphasing> I'm not worried about correctness so much, just if I'm thinking the right way
10:33:26 <c_wraith> not that glibc will ever be anything but lgpl...
10:33:37 <c_wraith> But maybe someone else will implement the function I bound to
10:34:12 <byorgey> imphasing: well, that works fine.  for a different solution, try having the scan build up prefixes of the mapped list, then take the last element as the result
10:34:26 <byorgey> that way you won't need to handle the empty list specially
10:35:04 <saml> hey, anyone wants to be CTO in new york city?
10:35:05 <imphasing> I'm not sure I get what you mean by "prefices of the mapped list" :/
10:35:13 <wavewave> chrisdone: Cool! is it publicly available?
10:35:26 <saml> prefices?
10:35:40 <copumpkin> saml: o.O
10:35:50 <copumpkin> CTO of some dude's basement
10:35:52 <dafis> > map head $ scanl ((:) . (+2)) [] [1 .. 5]
10:35:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
10:36:02 <byorgey> imphasing: like if you do  map (+1) [1,2,3],  the scan should build [[], [2], [2,3], [2,3,4]]
10:36:13 <imphasing> byorgey: Ah, I understahdn
10:36:15 <imphasing> whoa
10:36:17 <imphasing> Understand
10:36:23 <imphasing> Thanks :D
10:36:26 <byorgey> imphasing: however, I guess that will be inefficient, you should also try doing that with a scanr instead
10:36:56 <hpaste_> chrisdone pasted “anything-hoogle” at http://hpaste.org/51624
10:37:07 <saml> copumpkin, http://nymag.com/newyork/jobs/#cto
10:37:07 <byorgey> the scanr would build up suffixes instead of prefixes
10:37:21 <saml> it's high paying job. and you'll be mentoring me. aren't you excitied? you can use haskell.
10:37:46 <chrisdone> wavewave: that's the source. nothing to it. it's a bit jerky though because it launches the process synchronously, i'm going to write an async version that won't have any jerking effects
10:38:11 <byorgey> rostayob: to see the difference, try writing a function of type  Data.Tree.Tree -> Int  that computes the maximum number of children of any node.
10:38:16 * hackagebot dingo-core 0.0.3 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.0.3 (BardurArantsson)
10:39:05 <byorgey> rostayob: you can write it using  treeCata :: (a -> [b] -> b) -> Tree a -> b, but you cannot write it using the Foldable interface
10:42:10 <Rc43> Hi again.
10:42:35 <Rc43> How can I show float in decimal with fixed number length?
10:43:00 <dafis> Rc43: Numeric.showFFloat
10:43:15 * hackagebot nano-cryptr 0.1.1.2 - A threadsafe binding to glibc's crypt_r function  http://hackage.haskell.org/package/nano-cryptr-0.1.1.2 (CarlHowells)
10:43:16 <dafis> > showFFloat (Just 7) pi ""
10:43:17 <kmc> > printf "%5.2f" 0.333333333333 :: String
10:43:17 <lambdabot>   "3.1415927"
10:43:18 <lambdabot>   " 0.33"
10:44:05 <Rc43> > showFFloat Nothing pi ""
10:44:06 <lambdabot>   "3.141592653589793"
10:44:12 <Rc43> > showFFloat Nothing pi "asdasd"
10:44:13 <lambdabot>   "3.141592653589793asdasd"
10:44:24 <Rc43> > showFFloat Nothing 1 "asdasd"
10:44:25 <lambdabot>   "1.0asdasd"
10:44:30 <Rc43> > showFFloat 10 1 "asdasd"
10:44:31 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
10:44:31 <lambdabot>    arising f...
10:44:34 <dafis> > showFFloat (Just 27) pi ""
10:44:35 <lambdabot>   "3.141592653589793000000000000"
10:44:37 <azaq23> > take 20 $ show (pi :: CReal)
10:44:38 <lambdabot>   "3.141592653589793238"
10:44:42 <Rc43> > showFFloat (Just 10) 1 "asdasd"
10:44:43 <lambdabot>   "1.0000000000asdasd"
10:44:53 <Rc43> Ok, it is nice for me. Thanks.
10:46:13 <byorgey> which package defines CReal?
10:46:36 <kamehameha> @pl \n -> take n $ repeat n
10:46:37 <lambdabot> ap take repeat
10:46:48 <byorgey> ah, numbers
10:46:49 <dafis> byorgey: numbers, iirc
10:46:53 <byorgey> thanks
10:46:58 <kamehameha> :t ap
10:46:59 <kmc> also http://hackage.haskell.org/package/HERA
10:47:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:47:37 <Rc43> print "\n"
10:47:41 <Rc43> > print "\n"
10:47:43 <lambdabot>   <IO ()>
10:47:43 <nooodl> why does lambdabot use things like ap and liftM2 in its point-free forms? they look monad-related
10:48:09 <kmc> it uses them because they're useful?
10:48:13 <kmc> i don't understand the question
10:48:23 <kmc> @src (->) (>>=)
10:48:23 <lambdabot> f >>= k = \ r -> k (f r) r
10:48:27 <kmc> @src (->) return
10:48:28 <lambdabot> return = const
10:48:47 <kmc> ^^^^ describes how monad combinators apply to functions
10:49:10 <kmc> @pl \x -> h (f x) (g x)
10:49:11 <lambdabot> liftM2 h f g
10:49:31 <leod> this kind of use of monads is pretty hard to read, imo
10:49:36 <leod> maybe i just need more experience
10:49:39 <nooodl> woah. alright
10:49:39 <kmc> i agree
10:49:41 <nooodl> same here
10:49:55 <kmc> it is sometimes the nicer way to write something but not that often
10:49:57 <wavewave> chrisdone: I am trying your anything..  It shows pattern: prompt... but it is not following as I type.
10:50:02 <leod> you always need to recall the definitions of >>= here
10:50:08 <kmc> there's no guarantee that @pl produces readable code... it usually does the opposite
10:50:24 <wavewave> chrisdone: I just do M-x anything when it starts.
10:50:35 <byorgey> > floatRadix (pi :: CReal)   -- found a funny error message
10:50:35 <wavewave> when emacs starts I mean..
10:50:36 <lambdabot>   *Exception: CCeal.floatRadix
10:50:37 <kmc> since monads are all about dodgy broken analogies, i can give you a dodgy broken analogy for that ((->) r) monad
10:51:01 <wavewave> chrisdone: what might cause the problem?
10:51:13 <dafis> :i CReal
10:51:16 <chrisdone> wavewave: do you have hoogle installed?
10:51:26 <kmc> say i have «data Three = A | B | C»;  then «Three -> Int» is much like «(Int, Int, Int)»
10:51:34 <dafis> @info CReal
10:51:35 <lambdabot> CReal
10:51:38 <Rc43> How can I declare type like (Float -> Float) ?
10:51:41 <kmc> a function of type (S -> T) is like a container of T's which is indexed by S
10:51:46 <copumpkin> kmc: omg I was just talking about that with dylukes yesterday
10:51:49 <nooodl> thanks for the info lambdabot
10:51:51 <wavewave> chrisdone: yes.. at the shell prompt, I can use 'hoogle'
10:51:57 <kmc> and so the Functor instance for ((->) S) does what you expect for containers
10:52:12 <kmc> Rc43, declare?
10:52:12 <Rc43> oh.. type Fun = Int -> Int
10:52:15 <kmc> in what context
10:52:16 <kmc> ah
10:52:16 <chrisdone> wavewave: where did you put the code i pasted? it should come after anything.el
10:52:22 <chrisdone> hm wait
10:52:29 <kmc> yeah, 'type' declares type synonyms
10:52:42 <chrisdone> wavewave: ah, remove the whole (defvar anything-sources …) block from anything.el
10:52:50 <leod> kmc: oh, that's actually a pretty good analogy
10:52:50 <Rc43> never use that =/
10:52:55 <wavewave> I added (load "~/.emacs.d/anything.el") before your snippet.
10:53:05 <chrisdone> wavewave: ah, scratch that
10:53:10 <chrisdone> wavewave: change my defvar to setq
10:53:15 <chrisdone> should do the trick
10:53:15 * hackagebot dingo-widgets 0.0.3 - Dingo Widgets  http://hackage.haskell.org/package/dingo-widgets-0.0.3 (BardurArantsson)
10:53:32 <hpaste_> Andreas pasted “Building local-gc branch of ghc” at http://hpaste.org/51625
10:55:11 <Andreas___> Hi, I'd like to try the new local-gc collector. It looks like there is a branch of ghc that includes this (the 'local-gc' branch. I tried to get it, but it failed to build. I've put the the build error here http://hpaste.org/51625. If anyone has any advice on how to fix this, that would be great!
10:55:26 <wavewave> chrisdone: great!! it works! thanks very much..
10:55:46 <chrisdone> wavewave: woot
10:56:10 <wavewave> chrisdone: by the way, in your snippet, I found one parenthesis is missing.
10:56:29 <wavewave> after (volatile)))  ..
10:56:36 <chrisdone> woops
10:56:44 <chrisdone> i c/p'd with the mouse
10:57:05 <copumpkin> chrisdone: I don't think you should talk about c/p in here
10:57:09 <leod> @src (->) fmap
10:57:09 <lambdabot> fmap = (.)
10:57:21 <leod> right :P
10:57:26 <chrisdone> copumpkin: haskellers don't like Captain Picard?
10:57:34 <wavewave> chrisdone: thanks! this is exactly what I want!
10:58:11 <chrisdone> wavewave: isn't it too slow for you?
10:58:33 <wavewave> chrisdone: of course, if it's faster, then it's better ;-)
10:58:51 <wavewave> but it's okay with me now. my computer is pretty fast.
10:59:59 <saml> your computer runs windows8?
11:00:09 <chrisdone> rofl he made an OS joke
11:00:39 <wavewave> runs iOS6
11:01:06 <chrisdone> wavewave: i think… that hoogle only supports being launched once, so there's a launch overhead. but it might be ok. /me tests
11:02:34 <yitz> Andreas___: try asking about that on #ghc
11:02:44 <wavewave> chrisdone: maybe running  a local hoogle server and getting a text from the server using command line interface would be good.
11:02:55 <Andreas___> yitz: thanks, I'll do that.
11:03:06 <wavewave> since hoogle already comes with hoogle server.
11:03:18 <chrisdone> wavewave: yeah but it seems hoogle demands to run on port 80. or does it? if so, we might as well patch it to support taking in queries from stdin and outputting stuff
11:03:45 <wavewave> you can change it by --port
11:03:53 <wavewave> hoogle server --port=xxxx
11:03:55 <chrisdone> ah. hoogle --help is useless
11:04:03 <chrisdone> cool. maybe we can use that
11:04:30 <nooodl> @src null
11:04:31 <lambdabot> null []     = True
11:04:31 <lambdabot> null (_:_)  = False
11:04:39 <wavewave> chrisdone: hoogle seems to use cmdargs pkg. (N. Mitchell is the author of cmdargs,too)
11:05:03 <nooodl> that second pattern looks like a butt. (*kicked from #haskell*)
11:05:09 <wavewave> chrisdone: then, hoogle [command] --help gives detail help on the [command].
11:05:24 <wavewave> hoogle --help gives a list of command
11:05:36 <imphasing> Why does the function composition operator exist? isn't something like (reverse . sort) the same as (reverse sort) ?
11:05:39 <chrisdone> wavewave: ahh, ok. thanks
11:05:41 <wavewave> hoogle 'command' --help gives a list of available options
11:05:54 <Jafet> Wait till nooodl discovers the bitwise-or operator.
11:05:57 <wavewave> I am using cmdargs for every program now I am making.
11:06:00 <Saizan> imphasing: no, reverse . sort = \x -> reverse (sort x)
11:06:03 <wavewave> ;-)
11:06:25 --- mode: ChanServ set +o Saizan
11:06:45 <byorgey> imphasing: (reverse sort) is passing 'sort' as the first argument to 'reverse', which does not type check since reverse expects a list and sort is a function.
11:07:07 --- mode: Saizan set -o Saizan
11:07:10 <chrisdone> wavewave: i use cmdargs too, but haven't used a per-command --help before
11:07:12 <byorgey> imphasing: note that  reverse (sort [3,1,4])  and  (reverse sort) [3,1,4]  are quite different
11:07:45 <imphasing> Ah, that's right.. so composition is to compose functions before they're even called, whereas I can call a function, get the results, and give that to another function just fine without composition
11:07:59 <wavewave> chrisdone: good to know ;-)
11:08:04 <erus`> byorgey: dont you mean (reverse . sort) ?
11:08:16 <byorgey> erus`: no, imphasing was asking about (reverse sort)
11:08:28 <erus`> compile error ?
11:08:29 <byorgey> imphasing: right.
11:08:44 <erus`> > reverse sort
11:08:45 <lambdabot>   Couldn't match expected type `[a]'
11:08:45 <lambdabot>         against inferred type `[a1] -> [...
11:08:52 <byorgey> erus`: yes, that's the point
11:08:52 <imphasing> Awesome, I can almost feel my brain expanding heh
11:08:54 <shachaf> reverse :: (a -> b) -> (b -> a)
11:09:02 <byorgey> imphasing: excellent =)
11:09:04 <erus`> > reverse . sort
11:09:05 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a])
11:09:05 <lambdabot>    arising from a use ...
11:09:21 <imphasing> Always wondered why I implemented "compose" in my scheme interpreter... the more you know.
11:09:30 <Jafet> coreverse
11:09:42 <erus`> scheme should have currying :)
11:09:46 <shachaf> coreverse :: (a <- b) <- (b <- a)
11:09:49 <chrisdone> wavewave: eh i don't know how to do web requests off the top of my head in elisp. for now we're stuck with slow ;)
11:09:50 <imphasing> erus`: I have a curry function :P
11:09:53 <imphasing> That's about it.
11:10:04 <kmc> erus`, currying is a convention; it's not a language feature
11:10:18 <erus`> ((+) 1 2) would work in my world
11:10:25 <kmc> iirc scheme lets you write  (define ((f x) y) ...)
11:10:29 <wavewave> chrisdone: I think we had better make a script for that.. not inside elisp.
11:10:38 <kmc> erus`, that would ruin the bit where + works on arbitrarily many arguments
11:10:43 <wavewave> since you just call hoogle in your elisp.
11:10:45 <imphasing> I've considered implementing partial application in my scheme interpreter.. that would only work with functions with fixed arguments though
11:11:03 <wavewave> replace hoogle to some script..(maybe haskell script is better. ;-)
11:11:04 <shachaf> kmc: Due to laziness in Haskell, "(x)" ~ "x" (Scheme-style parentheses). :-)
11:11:05 <erus`> kmc function have 1 arguement in my world
11:11:12 <imphasing> ((lambda (a b)) foo) would give me another lambda expecting more functions
11:11:18 <imphasing> Not sure how handy that would be for scheme though
11:11:24 <imphasing> er, arguments not functions
11:11:27 <chrisdone> wavewave: if hoogle could take queries from stdin then any app could use it more easily
11:11:35 <chrisdone> as a pipe
11:11:38 <wavewave> then just use curl.. or something.
11:11:49 * shachaf isn't sure what he's going on about anymore.
11:11:56 <chrisdone> wavewave: nou
11:12:10 <dmwit> I thought there was a command-line version of hoogle already.
11:12:25 <kmc> erus`, that isn't scheme then
11:12:34 <imphasing> yeah curried functions in scheme would only work for fixed args, unless I implemted a type system too I guess
11:12:37 <kmc> anyway (+) in scheme evaluates to 0
11:12:40 <erus`> bastardized scheme
11:12:58 <Saizan> dmwit: there is
11:13:08 <Jafet> Schmashkell
11:13:26 <chrisdone> kmc: i think that's a general lisp thing. they think it's 'logical'
11:13:50 <imphasing> (+) crashes my scheme interpreter :|
11:13:53 <wavewave> chrisdone: there can be a good way..... not far from now..
11:14:02 <erus`> i really need to finish my language ...
11:14:15 <imphasing> erus`: What kind of language?
11:14:19 <kmc> mine evaluates (+) to 0
11:14:28 <kmc> (mzscheme)
11:14:34 <erus`> imphasing: its a lazy functional language
11:14:41 <erus`> with pattern matching
11:14:47 <chrisdone> tell me more
11:14:54 <imphasing> kmc: Mine's a toy scheme interpreter, it's expecting numerical arguments so just dies with none :(
11:15:00 <imphasing> Guess I should add an implicit default argument
11:15:03 <kmc> imphasing, but the sum of no things is 0
11:15:06 <kmc> > sum []
11:15:07 <lambdabot>   0
11:15:09 <kmc> > product []
11:15:10 <lambdabot>   1
11:15:22 <shachaf> imphasing: I don't think you're allowed to call it Scheme unless it implements RnRS, or something like that.
11:15:22 <kmc> your implementation probably has the wrong base case
11:15:43 <imphasing> shachaf: Hence why my project is called "scheme-ish" :P
11:15:53 <imphasing> Although I'm working on r5rs compatibility
11:16:51 <imphasing> It's the argument thing that crashes it, it's trying to cast the only argument (an empty list) to a numerical type
11:16:57 <imphasing> Free type system, thanks C# :P
11:17:20 <chrisdone> your scheme implementation is bad and you should feel b ad
11:17:31 <imphasing> It's very bad, I don't pretend it's good :P
11:17:34 <chrisdone> :p
11:17:56 <imphasing> I can implement coroutines at least though, that made me happy
11:19:16 <nooodl> erus`, isn't lambdurp yours?
11:19:25 <erus`> yeah
11:19:35 <erus`> people still remember ?
11:19:52 <erus`> (working title)
11:19:55 <imphasing> I like it :D
11:20:04 <imphasing> lambderp works too
11:20:30 <nooodl> i don't know how i remembered that
11:20:35 <kmc> imphasing, does it have first-class continuations?
11:20:39 <mah_b> is there a way to write [(f a, d) | a <- g, let c = h a, isJust c, let Just d = c] in a more elegant way?
11:20:59 <imphasing> kmc: Yes, that's my proudest achievment in it so far :P
11:21:08 <imphasing> Moving from a recursive evaluator to a stack-based one was a nice learning experience
11:21:20 <Saizan> [(f a, d) | a <- g, Just d <- return $ h a]
11:21:27 <imphasing> Not just exit procedures either, I was pretty stoked about that :D
11:21:46 <nooodl> i'm trying to prettify: array ((0, 0), (19, 19)) [((i, j), False) | i <- [0..19], j <- [0..19]]
11:21:59 <kmc> i don't like arrays :/
11:22:00 <nooodl> basically a 20x20 array filled with False
11:22:05 <nooodl> me neither.
11:22:08 <rwbarton> listArray ((0, 0), (19, 19)) $ repeat False
11:22:47 <nooodl> it's for an implementation of conway's game of life. any better data structures i could use?
11:23:12 <nooodl> [[Bool]] would work, i guess
11:23:34 <byorgey> [[Bool]] would be annoying for implementing the game of life though
11:23:53 <leod> yeah, use a Data.Map :P
11:23:54 <Cale> A Map or Set could work
11:24:09 <nooodl> Set for a 2D array?
11:24:19 <Cale> Sure, the set of active cells
11:24:51 <nooodl> that's an interesting way of looking at it
11:25:06 <kmc> i would use Map and then if performance becomes an issue switch to unordered-containers or something
11:25:08 <rwbarton> an ordinary immutable array is fine... as long as you're creating a whole new array each time, rather than expecting small updates to be efficient
11:25:28 <kmc> updating small parts of a map will be much more efficient
11:25:35 <wavewave> chrisdone: haha, I incorporated this with my hooglelocal script.. Now it can search my local packages
11:25:42 <kmc> probably
11:26:12 <wavewave> just add +package1 +package2 .. after hoogle search blahblah
11:26:25 <nooodl> i'm going to try the Set solution
11:26:30 <nooodl> it feels haskelly
11:26:53 <wavewave> chrisdone: this will boost up my productivity..  lol
11:27:11 <ClaudiusMaximus> i'd be surprised if there weren't some theorems out there giving average long term density of live cells
11:28:03 <ClaudiusMaximus> (for finite regions)
11:29:53 <nooodl> @src Data.Set.elems
11:29:53 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:30:00 <nooodl> @src Set.elems
11:30:00 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:30:09 <nooodl> erm?
11:31:45 <Cale> nooodl: None of Data.Set's code is in the text file that @src looks in for source
11:31:53 <nooodl> ah.
11:32:02 <Cale> nooodl: But you can look at the source by clicking the source links from the Haddock documentation
11:37:25 <chrisdone> wavewave: hurrah
11:43:02 <imphasing> How do you control the associativity of a function in haskell? Or is everything always right-associative unless it's "special"?
11:46:46 <parcs> everything is by default left associative with precedence level 9
11:47:12 <parcs> you can change this with infixl/infixr/infix declarations
11:48:21 <tromp> 8*14
11:48:24 <tromp> > 8*14
11:48:25 <lambdabot>   112
11:48:48 <imphasing> parcs: Ah, okay. Thanks :)
11:49:32 <mm_freak_> imphasing: works also for non-operators
11:49:42 <mm_freak_> infixr 5 myFunc
11:49:49 <mm_freak_> when using `myFunc` syntax
11:49:59 <imphasing> Ah, that's pretty cool
11:50:07 <imphasing> Reminds me of Clean..
11:50:23 <imphasing> Or maybe Clean reminds me of Haskell :P
11:51:29 <byorgey> Clean reminded you of Haskell the whole time and you never knew it until this moment
11:53:50 <parcs> i believe the syntax is infixr 5 `myFunc`
12:06:14 <nomeata> Hi. I am profiling my code with -hd. Is there a way to make ghc qualify the constructor name with the type? I want to distinguish between the Bin of IntMap, Map, Set and IntSet...
12:10:46 <mysticc> I want to define a function g which can apply a function f to a list of arguments .. eg g (+) [1,2] = (+) 1 2 ..... The problem is the length of the list is the arity of the function f ... is there already such a function ?
12:11:08 <Cale> mysticc: think about the type that such a function would have
12:11:28 <Cale> (It doesn't exist)
12:11:43 <Cale> You can't know at compile time how long a list is
12:11:49 <HenryTrollins> guys i'm writing an operating system in haskell and i'm not sure how to access registers can anyone explain?
12:11:54 <Cale> So you can't know how many arguments the function needs to take
12:12:05 <Cale> and so there can't be a suitable type
12:12:17 <mysticc> Cale: Suppose I know ... I have  defined my list in my program ... then what ...
12:12:23 <Cale> HenryTrollins: Maybe look at House.
12:12:38 <zachk> henrytrollins if you dont know how to access a register in your target language, you are not going to go very far writing an os
12:12:56 <Cale> http://programatica.cs.pdx.edu/House/
12:13:11 <hpaste> nooodl pasted “game of life” at http://hpaste.org/51626
12:13:29 <nooodl> anything really slow about this?
12:13:40 <HenryTrollins> zachk: well so far i got it to dual boot next to windows so i would say i'm not doing too bad i just need a hand
12:13:49 <mysticc> Cale: I have define list as l =  [a , b , c ,d]  now want to do f a b c d .... the problem is there are so many list and I dont want to do it manually ....
12:14:03 <nooodl> i like how short it is but 300 generations of a simple pattern takes 10 seconds or so
12:15:15 <nooodl> wait. not a simple pattern. i guess calculating the next generation takes longer depending on how much cells are alive
12:16:43 <mysticc> Cale: I have a list whose length is known at compile time ... I want to map on it and then apply it as arguments to a function ... what is the best way to do that ??
12:17:01 <zachk> mysticc: do you know how to construct a list?
12:17:04 <byorgey> mysticc: you can write such a function for any particular length.  appList4 f [a,b,c,d] = f a b c d
12:17:19 <byorgey> mysticc: you just can't write a function that will work generically for any length list
12:17:51 <mysticc> byorgey: ok ... similar to zip and zipwith which are defined upto zip7 ...
12:17:58 <byorgey> mysticc: right
12:18:02 <Cale> mysticc: Maybe the function should take lists to begin with?
12:18:15 <Cale> (why lists?)
12:18:37 <obiwahn> when i have a function that reads a string and i want to replace a space with some string how would i do it?
12:19:07 <obiwahn> my problem ist that i use (x:xs) as input but try to append with ++
12:19:32 <obiwahn> i guess there is the error but i do not see how to rewrite it in a proper way
12:19:33 <copumpkin> > "moo baa woof" >>= \x -> case x of ' ' -> "ohai"; z -> [z]
12:19:34 <lambdabot>   "mooohaibaaohaiwoof"
12:19:47 <nomeata> In GHC, is there a difference in memory consumption between an unevaluated hunk and an constructor capturing all the free variables?
12:20:12 <obiwahn> can i do it without monads?
12:20:16 <HenryTrollins> ok.. i'm one step further now, i got my os booting on my bb 9700 bold but it hangs at 'image error 45920 please contact rim support', any ideas?
12:20:24 <wires> NOooo MUST USE MONADS
12:20:30 <Cale> obiwahn: xs >>= f there is the same thing as concatMap f xs
12:20:31 <shachaf> obiwahn: No, [] is a monad no matter what.
12:20:38 <wires> :)
12:21:14 <obiwahn> @src concatMap
12:21:14 <lambdabot> concatMap f = foldr ((++) . f) []
12:21:42 <Cale> concatMap f xs is the same thing as  concat (map f xs)
12:22:09 <wires> so, I don't understand how cabal-dev works... In python/virtualenv you "source bin/activate" (some shell script that sets paths etc) and then work in the environment. I this also how cabal-dev works, or not?
12:22:09 <TA-Dan> @src map
12:22:09 <lambdabot> map _ []     = []
12:22:10 <lambdabot> map f (x:xs) = f x : map f xs
12:22:18 <Cale> (except that in less fancy Haskell implementations, concatMap is more efficient -- but in GHC, they compile to the same thing)
12:22:30 <TA-Dan> funny, map isn't implemented with foldr even though it clearly uses the foldr pattern
12:22:59 <shachaf> TA-Dan: Every list function "uses the foldr pattern". :-)
12:23:27 <erus`> can someone buy hoogle.com pelase
12:23:32 <copumpkin> shachaf: oh yeah?
12:23:36 <erus`> i keep typing it in
12:23:39 <imphasing> erus`: I'm sure it's bought up
12:23:47 <erus`> it is
12:23:59 <rostayob1> what are the advantages of using Reader e instead of ((->) e)? apart from the clearer naming, with ((->) e) we don't even need to lift functions with asks
12:24:01 <erus`> lets all donate and buy it
12:24:12 <b_jonas> TA-Dan: that's probably also not the full implementation of map. there are probably rewrite rules about it.
12:24:28 <shachaf> copumpkin: You got a problem with it?
12:24:29 <Cale> nooodl: It's significantly faster if compiled with -O2
12:24:51 <copumpkin> shachaf: write cycle with foldr
12:25:09 <tromp> > 2104/657
12:25:10 <lambdabot>   3.202435312024353
12:25:15 <DanBurton> copumpkin: oh goodness I think that was a RWH exercise or something
12:25:39 <nooodl> @src cycle
12:25:40 <lambdabot> cycle [] = undefined
12:25:40 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:25:47 <Cale> nooodl: (though not really the fastest thing in the world :P)
12:25:49 <dafis> > let cyc xs = let ys = foldr (:) ys xs in ys in cyc "1234"
12:25:50 <lambdabot>   "12341234123412341234123412341234123412341234123412341234123412341234123412...
12:26:05 <imphasing> nice :)
12:26:07 <DanBurton> mind = blown
12:26:10 <nooodl> dafis, genious
12:26:11 <copumpkin> oh that's not what I meant
12:26:35 <ion> > let cyc = fix . (++) in cyc "foo"
12:26:36 <rostayob1> > let cyc = concat . repeat in cyc "asd"
12:26:37 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
12:26:38 <dafis> copumpkin: BE MORE SPECIFIC THEN, IT'S CYCLE WRITTEN WITH FOLDR
12:26:38 <lambdabot>   "asdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdas...
12:26:46 <copumpkin> :P
12:26:52 <shachaf> copumpkin: cycle cx = foldr (:) (cycle xs) xs
12:26:54 <dafis> sry, accidental caps lock
12:26:56 <Cale> nooodl: I think part of the problem is that your sets of neighbours in the cells to check overlap, but you're keeping them as a list rather than a Set, so it ends up computing the same cell 4 times in many cases...
12:27:13 <copumpkin> shachaf: yeah, fuck that
12:27:13 <shachaf> Bah, too late as usual.
12:27:19 <DanBurton> ion: wat
12:27:27 <ion> How do you type a nine-word sentence, send it and *then* notice you had caps lock on? :-D
12:27:30 <DanBurton> ion: very cool, but how does it work o_O
12:27:49 <rostayob1> DanBurton: fix f = f (fix f)
12:27:49 <shachaf> copumpkin: What did you mean, then?
12:28:10 <copumpkin> shachaf: I mean that if you wrap foldr in something else and don't restrict what you're folding over, sure, you can write anything at all
12:28:18 <obiwahn> @src >>=
12:28:18 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:28:21 <copumpkin> but saying all list functions can be written with foldr is kind of meaningless then
12:28:24 <shachaf> copumpkin: Sure, that's what I meant.
12:28:25 <copumpkin> tail is a pain
12:28:26 <nooodl> Cale, i'd considered that. would it be any faster if i converted the list to a Set first?
12:28:33 <shachaf> copumpkin: It's not true of e.g. foldl
12:28:44 <copumpkin> foldr is just general recursion if you let yourself fold over repeat ()
12:29:09 <dafis> ion: not looking at the screen, simple
12:29:44 <b_jonas> hmm
12:29:53 <b_jonas> @type True -- comment
12:29:54 <lambdabot> Bool
12:30:06 <Cale> nooodl: It's a bit faster
12:30:27 <b_jonas> when I enter ':t True -- comment' in ghci 6.12.1, it answers 'True -- comment :: Bool'
12:30:37 <b_jonas> that's a bit strange, though it's syntactically correct
12:30:45 <nooodl> b_jonas, heh
12:30:56 <b_jonas> I don't have ghc 7 installed, maybe it's better
12:30:57 <imphasing> haskell comments can end mid-line? :O
12:31:04 <imphasing> Oh, never mind.
12:31:05 <b_jonas> imphasing: no, but you can omit the type
12:31:10 <erus`> @hoogle [Bool] -> Bool
12:31:10 <lambdabot> Prelude and :: [Bool] -> Bool
12:31:11 <lambdabot> Prelude or :: [Bool] -> Bool
12:31:11 <lambdabot> Data.List and :: [Bool] -> Bool
12:31:14 <imphasing> Yeah :)
12:31:20 <nooodl> clearly a bug, should become True {- comment -} :: Bool :)
12:31:31 <erus`> @hoogle all
12:31:31 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
12:31:32 <lambdabot> Data.ByteString all :: (Word8 -> Bool) -> ByteString -> Bool
12:31:32 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
12:31:43 <joe6> i am trying to build haskell-platform 2011.2.0.1 with ghc 7.2.1, and am getting errors with syb-0.3 http://codepad.org/UWkMskpz, any suggestions on how I can fix something like that? get rid of the syb-0.3 from the haskell-platform package or ..?
12:31:54 <erus`> @hoogle all (== True)
12:31:55 <lambdabot> Parse error:
12:31:55 <lambdabot>   --count=20 "all (== True)"
12:31:55 <lambdabot>                      ^
12:32:10 <rostayob1> erus`: that's asking too much :P
12:32:13 <nooodl> copumpkin, so is there a solution?
12:32:19 <copumpkin> to what?
12:32:23 <shachaf> @check \x -> (==True) x == id x
12:32:24 <lambdabot>   "OK, passed 500 tests."
12:32:39 <nooodl> cycle with foldr
12:32:57 <shachaf> nooodl: copumpkin's point was that there wasn't.
12:32:57 <rostayob1> @checl \x -?> all (== True) x == and x
12:32:57 <lambdabot>   Parse error at "-?>" (column 4)
12:33:01 <rostayob1> @checl \x -> all (== True) x == and x
12:33:02 <lambdabot>   "OK, passed 500 tests."
12:33:04 <shachaf> Of course, copumpkin disallows general recursion.
12:33:14 <rostayob1> checl?
12:33:29 <imphasing> he must be okay with corecursion then, if he's a copumpkin..
12:33:53 <shachaf> Corecursion is what GHC core does, right?
12:34:26 <dafis> joe6: URL 404ed
12:34:47 <joe6> ok, thanks. will send it again.
12:34:49 <hpaste> Cale pasted “Life” at http://hpaste.org/51627
12:34:53 <imphasing> I would guess so, since it's usually used with lazy eval
12:35:17 <joe6> http://codepad.org/ckdo1Wji dafis
12:36:19 <any-key> I've got an awesome parse error in the following: http://pastebin.com/QZYxW7Hs
12:36:22 <mauke> The paste QZYxW7Hs has been copied to http://hpaste.org/51628
12:36:34 <any-key> It says there's a pattern error on line 3 at the ==
12:36:51 <erus`> pattern matching is really easy to interpret :) compiling might be a pain though
12:37:00 <dafis> joe6: yes, Generics stuff was changed and moved in 7.2.1, you can't compile syb-0.3 with it, I think
12:37:00 <Cale> nooodl: ^^ did you see my paste?
12:37:04 <nooodl> yep
12:37:55 <joe6> dafis, ok, thanks.
12:38:28 <dafis> any-key: case i of ty -> ..., not i == ty ->
12:38:40 <any-key> dafis: oh wow...
12:38:45 <any-key> I feel dumb now
12:38:52 <any-key> perhaps it's time for a break...
12:38:59 <dafis> any-key: and in the paste, your indentation is broken
12:39:08 <obiwahn> is | allowed in lamda?
12:39:24 <any-key> dafis: yeah, I'm aware...I'm having trouble getting Vim to cooperate on the spacing
12:39:27 <nooodl> why -O2 and not -O3?
12:39:38 <dafis> nooodl: no difference
12:39:42 <Cale> nooodl: primarily because -O3 doesn't exist
12:40:01 <obiwahn> any-key: what exactly is you vim trouble?
12:40:12 <Cale> It used to be that -O3 would get you no optimisation :)
12:40:23 <Cale> But they made it clip the range :)
12:40:39 <imphasing> Cale: I bet that was an annoying shock to people who thought it was "moar better!"
12:40:44 <zachk> does -o1 have any advantages over -o2?
12:40:56 <any-key> obiwahn: I have it set to two-space tabs, haskell is very picky about whitespace
12:41:17 <Cale> zachk: Your program compiles a bit faster. In pathological cases, it might avoid bugs in the compiler.
12:41:21 <dafis> Cale: I think -On, n>= 2, gives -O2 since loong ago (6.2 at least)
12:41:26 <dthurn> Is it possible to declare datatypes in GHCI, like "data Bool = True | False" ?
12:41:34 <imphasing> dthurn:
12:41:37 <imphasing> dthurn: It is now :)
12:41:39 <imphasing> in 7.2
12:41:47 <nlogax> yay!
12:42:06 <dthurn> awesome to hear, even if I'm still on 7.0 with Haskell Platform :)
12:42:19 <obiwahn> any-key: http://github.com/nathanaelkane/vim-indent-guides
12:42:29 <obiwahn> maybe that will help
12:42:31 <Cale> dthurn: Mainly you'll want to put all your definition code in a file and load it with ghci to play around with expressions
12:42:32 <obiwahn> i used it with python
12:42:56 <dafis> imphasing: I think it will be first in 7.4
12:43:05 <inetic> hi, when you are creating a project, what is your usual tree structure? do you have some of the modules lurking in the same directory as the "main" non-module? or do you put all of them in some 'Modules' directory? silly question, I know, but still...
12:43:13 <any-key> obiwahn: I actually have that loaded, I forgot about it
12:43:17 <any-key> thanks
12:43:21 <imphasing> dafis: Ah.. I was talking about this: https://github.com/ghc/ghc/commit/3db757241ce7fb99c096c30481aefa86bb9855a1
12:43:31 <imphasing> I thought it was out in this release :(
12:44:15 <dafis> imphasing: SimonM pushed that today, so it's in HEAD now
12:44:28 <chrisdone> OMG
12:44:28 <erus`> are IO values ever lazy?
12:44:33 <imphasing> Ah, guess I jumped the gun a little :P
12:44:40 <chrisdone> http://www.reddit.com/r/haskell/comments/kmxf2/ghci_now_supports_all_toplevel_declarations/
12:44:40 <chrisdone> https://github.com/ghc/ghc/commit/3db757241ce7fb99c096c30481aefa86bb9855a1
12:44:41 <imphasing> dthurn: ^
12:44:43 <chrisdone> omgomgomg
12:44:47 <Cale> inetic: It goes exactly according to how you want your modules to be named hierarchically.
12:44:55 <chrisdone> Daniel Winograd-Cort♥
12:45:02 <imphasing> He's the man :)
12:45:04 <Cale> inetic: So, mostly based on the structure of your project.
12:45:12 <obiwahn> is it possible to teach lamdabot a function?
12:45:20 <chrisdone> spoke to him at camhac when he told me about this, i was so excited
12:45:28 <Cale> obiwahn: @let ...
12:45:34 <obiwahn> nice:)
12:45:49 <inetic> Cale, thanks, I was thinking maybe there is some convention about this, but I guess there isn't
12:45:50 <Cale> It'll last until someone does @undefine which clears everything
12:45:53 * chrisdone downloads and builds
12:45:55 <tromp> @let fib a b = a:fib b(a+b)
12:45:57 <lambdabot>  Defined.
12:46:02 <erus`> i might have to re implement a thunk type :|
12:46:36 <obiwahn> @forget fib
12:46:36 <lambdabot> Incorrect arguments to quote
12:46:46 <tromp> > fib 1 3
12:46:46 <lambdabot>   [1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,...
12:46:52 <obiwahn> how do i delete a definition?
12:47:44 <monochrom>  @undefine, and it deletes all
12:48:04 <monochrom> in fact, let me undefine for you
12:48:06 <monochrom> @undefine
12:48:11 <tromp> > fib 1 3
12:48:12 <lambdabot>   Not in scope: `fib'
12:48:19 <b_jonas> > fibonacci 10
12:48:20 <lambdabot>   Not in scope: `fibonacci'
12:48:28 <b_jonas> > fact 10
12:48:28 <lambdabot>   Not in scope: `fact'
12:48:31 <b_jonas> > factorial 10
12:48:31 <lambdabot>   Not in scope: `factorial'
12:48:35 <obiwahn> @let spank = concatMap (\c -> if c == ' ' then " *spank* " else [c])
12:48:36 <lambdabot>  Defined.
12:48:44 <monochrom> > waldo
12:48:45 <lambdabot>   Not in scope: `waldo'
12:48:49 <obiwahn> @undefine spank
12:48:55 <b_jonas> good, the canonical homework functions are not predefined
12:48:57 <b_jonas> > fac 5
12:48:58 <lambdabot>   Not in scope: `fac'
12:49:06 <monochrom> no, it undefines everything, not just what you ask for
12:49:28 <tromp> > product[1..5]
12:49:29 <erus`> @hoogle (M a -> b) -> M a -> M b
12:49:29 <lambdabot>   120
12:49:29 <lambdabot> Warning: Unknown type M
12:49:29 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
12:49:56 <tromp> > product[1..0]
12:49:57 <lambdabot>   1
12:50:21 <tromp> > product[1,2..0]
12:50:22 <lambdabot>   1
12:50:37 <dafis> > [1 .. 0]
12:50:38 <lambdabot>   []
12:50:40 <tromp> > [1,2..0]
12:50:41 <lambdabot>   []
12:50:59 <erus`> @hoogle [M a] -> M [a]
12:51:00 <lambdabot> Warning: Unknown type M
12:51:00 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:51:00 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:51:04 <dafis> > [1 .. -1] :: [Word]
12:51:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:51:08 <tromp> > [1,0..2]
12:51:10 <lambdabot>   []
12:51:21 <nooodl> i'll never write a single line of code as cool as fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
12:51:51 <obiwahn> mh is there a file that lamdabot reads / treis to read except the prelude where i can put code?
12:51:58 <obiwahn> tries
12:52:20 <nooodl> obiwahn, probably better off using hpaste or something
12:52:29 <Cale> obiwahn: Pristine.hs
12:52:38 <Cale> obiwahn: in ~/.lambdabot/State
12:52:43 <Cale> if you're running your own lambdabot
12:54:53 <Eduard_Munteanu> Cale: btw, does lambdabot build right now?
12:55:06 <Cale> Eduard_Munteanu: uh, my copy of it does
12:55:10 <Eduard_Munteanu> I heard it's not straightforward to get it working.
12:55:14 <Cale> On this machine which has GHC 6.12.4
12:55:22 <Eduard_Munteanu> Ah.
12:55:24 <Cale> or whatever
12:55:29 <Cale> (6.12.3?)
12:55:37 <dafis> yes
12:55:45 <Cale> yes, 6.12.3
12:55:49 <Saizan> @version
12:55:50 <lambdabot> lambdabot 4.2.2.1
12:55:50 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:55:57 <dafis> last of the glorious sixes
12:56:01 <Saizan> used to have the ghc version, i think
12:57:26 <Cale> Saizan: yeah, I remember that as well
12:59:29 <obiwahn> Eduard_Munteanu: i have built it with ghci 7.* from hackage
13:00:55 <obiwahn> there was some problem with show but and i had to change the building of mueval so that it uses --with-ropts or something like that
13:01:10 <obiwahn> s/but//
13:02:58 <obiwahn> is there a good introduction to use haskell for writing programs? not only palying with nice expressions?
13:03:33 <parcs> i don't think there is such an introduction for any programming language
13:04:55 <armlesshobo> obiwahn: use what you learn from the books that are out there.
13:05:02 <zachk> obiwahn did you roll your own lambdabot?
13:05:25 <obiwahn> its \msg hbot :)
13:05:33 <erus`> @hoogle (a -> a -> M a) -> M a -> Ma  -> M a
13:05:34 <lambdabot> Warning: Unknown type M
13:05:34 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
13:05:34 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
13:05:58 <obiwahn> @import Control.Monad
13:05:59 <lambdabot> Unknown command, try @list
13:06:05 <armlesshobo> @list
13:06:06 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:06:08 <armlesshobo> :)
13:06:12 <rostayob1> was IO like it is before monads were introduced in haskell?
13:06:14 <erus`> guys i have 2 IO a types i need to apply to an IO (a -> a -> a)
13:06:17 <erus`> can i do that?
13:06:18 <obiwahn> @load Control.Monad
13:06:18 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
13:06:31 <rostayob1> I mean the functions operating on IO
13:06:45 <copumpkin> rostayob1:?
13:07:09 <dafis> :t ap
13:07:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:07:13 <rostayob1> copumpkin: was the "Monad" typeclass present from day 1 in haskell?
13:07:14 <erus`> @undo { a <- c; a <- d; f a b }
13:07:14 <lambdabot>  Parse error at "{" (column 1)
13:07:16 <dafis> erus`: ^^
13:07:26 <copumpkin> :t let zomg f x y = do { f <- f; x <- x; y <- y; return f x y }
13:07:27 <lambdabot> <no location info>:
13:07:27 <lambdabot>     not an expression: `let zomg f x y = do { f <- f; x <- x; y <- y; return f x y }'
13:07:29 <copumpkin> :t let zomg f x y = do { f <- f; x <- x; y <- y; return f x y } in zomg
13:07:30 <lambdabot> forall (m :: * -> *) t b t1. (Monad m) => m (t -> m b) -> m t1 -> m t -> m b
13:08:16 <rostayob1> copumpkin: yeah but if I think I read somewhere that monads were introduced at some point, they weren't always there in haskell
13:09:09 <rostayob1> I was just curious if the semantics of IO were the same before - if what I'm saying is true
13:09:54 <Saizan> there wasn't an IO type before :)
13:10:09 <pumpkin> @ty liftM3 id
13:10:11 <lambdabot> forall a2 a3 r (m :: * -> *). (Monad m) => m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
13:10:14 <pumpkin> there we go
13:10:15 <pumpkin> rostayob
13:10:24 <hatomic> I need help with a license issue. Can I use the Simplified BSD License for an application using wxhaskell?
13:11:07 <rostayob1> Saizan: oh, ok, I also found this http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf , that answers my questions
13:11:38 * kowey hopes he asked his first SO question right... http://stackoverflow.com/questions/7506639/what-is-the-current-status-of-ghc-on-64-bit-windows
13:13:15 <keep_learning> :t liftM3
13:13:16 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
13:13:58 <keep_learning> :t liftM2
13:13:59 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:14:21 <rostayob1> Saizan: "Since a stream in Haskell is only a lazy list, a Haskell program has the type: type Dialogue = [Response] -> [Request]" (1992)
13:14:32 <rostayob1> interesting ehe
13:15:51 <hpaste> erus` pasted “can i prettify this?” at http://hpaste.org/51630
13:16:13 <armlesshobo> hmm. has anyone noticed strange behaviors between an interpreted haskell program and a compiled one?
13:16:24 <chrisdone> what kind of differences?
13:16:33 <hpc> armlesshobo: are you using something like opengl that requires external libraries?
13:16:41 <armlesshobo> hpc: no, a fairly simple program
13:17:06 <armlesshobo> i'll paste it, one sec
13:18:29 <monochrom> there are differences all the time
13:20:58 <Saizan> erus`: join $ apply bs <$> evaluateExpression bs l [] <*> evaluateExpression bs r []
13:26:53 <obiwahn> Cale: what are L and Pristine used for? is Pristine the original file and L that what is loaded?
13:28:52 --- mode: ChanServ set +o Saizan
13:30:17 <erus`> @hoogle putc
13:30:17 <lambdabot> Prelude putChar :: Char -> IO ()
13:30:17 <lambdabot> System.IO putChar :: Char -> IO ()
13:30:18 <lambdabot> Network.CGI getInputContentType :: MonadCGI m => String -> m (Maybe String)
13:31:19 <hpaste> armlesshobo pasted “Simple Program” at http://hpaste.org/51631
13:31:50 <armlesshobo> that's what i'm talking about
13:32:03 <armlesshobo> could anyone shed some insight as to why this happens?
13:32:27 <armlesshobo> it's like the first and second line are switched
13:32:33 <armlesshobo> when it's compiled
13:32:37 <Cale> obiwahn: right
13:32:46 <erus`> @hoogle Double -> Integer
13:32:46 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
13:32:47 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
13:32:47 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
13:32:53 <Cale> obiwahn: Whenever someone does @undefine, Pristine.hs gets copied over L.hs
13:32:59 <dafis> armlesshobo: BUFFERING
13:33:05 <dafis> sry
13:33:33 <erus`> @hoogle Integer -> Char
13:33:34 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
13:33:34 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:33:34 <lambdabot> Prelude show :: Show a => a -> String
13:33:38 <dafis> ghci stdout isn't buffered, stdout for compiled binaries is line-buffered
13:33:43 <erus`> @hoogle Double -> Char
13:33:43 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:33:43 <lambdabot> Prelude show :: Show a => a -> String
13:33:43 <lambdabot> Text.Show show :: Show a => a -> String
13:34:52 <dafis> armlesshobo: hFlush stdout; or hSetBuffering stdout NoBuffering ( both need import System.IO)
13:35:25 <erus`> > (fromInteger (123 :: Int)) :: Char
13:35:26 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
13:35:26 <lambdabot>         against inf...
13:35:41 <armlesshobo> dafis: i'll give that a shot, thanks
13:35:54 <dafis> erus`: fromIntegral
13:36:39 <hpc> @src fromIntegral
13:36:39 <lambdabot> fromIntegral = fromInteger . toInteger
13:38:09 <dafis> oh, wants Char
13:38:26 <dafis> erus`: toEnum, Data.Char.#chr
13:38:33 <dafis> Data.Char.chr
13:39:15 <hnsz> For the first time I'm writing some actual code in Haskell (practical assignment. I have the feeling it is completely unreadable. http://codepad.org/YHe8FiH3
13:39:29 <erus`> ah toEnum :)
13:40:14 <erus`> my putc 'h' --ello world program now works :)
13:40:23 <armlesshobo> dafis: also, does it not recognize DEL or BCKSPC?
13:40:37 <erus`> need to check if lazy lists will work without a thunk type
13:41:48 <dafis> armlesshobo: windows?
13:41:50 <hnsz> Can someone tell me if the code I linked looks half decent or is just incomprehensible?
13:41:55 <armlesshobo> dafis: nope, linux
13:41:57 <hnsz> http://codepad.org/YHe8FiH3
13:42:13 <erus`> hnsz: its readable :)
13:42:23 <hnsz> erus`: But?
13:42:24 <dafis> armlesshobo: then it should work with readline/haskeline
13:42:26 <hnsz> erus`: :p
13:42:34 <erus`> no its very clear
13:42:50 <azaq23> also, the CSV format exists
13:42:53 <armlesshobo> dafis: i'm using getLine :S
13:42:56 <monochrom> it's perfectly fine. I write code like that too. wouldn't bother to refactor or make more abstract if it is not large
13:43:19 <hnsz> erus`: Oh great thanks.  I was thinking maybe I should use more descriptive names for the arguments but if you say so then great! :)
13:44:19 <hpc> haskell is pretty good at encouraging nondescriptive argument names :P
13:44:26 <hnsz> Hehe
13:44:34 <armlesshobo> lol
13:44:43 <hnsz> Maybe it's jsut because it's formatting strings :p
13:44:59 <hpc> hnsz: are you using tabs?
13:45:21 <hnsz> UHm I'm using vim I think it's converting tabs to spaces
13:45:26 <armlesshobo> dafis: your suggestions didn't work :(
13:45:30 <hpc> 8 spaces of indentation is a lot, imo
13:45:51 <hpc> that's the only thing i can think of to improve that code
13:45:54 <tac-tics> 8 is super overkill
13:45:55 <monochrom> you're free to use descriptive names
13:46:00 <armlesshobo> tab = 4 spaces
13:46:12 <kmc> don't use tabs in .hs source files, ever
13:46:15 <tac-tics> One language I used and love to use advocates 2 spaces
13:46:19 <tac-tics> It works out really well, actually
13:46:22 <hnsz> Well Linus Torvalds says 8 so .. :)
13:46:30 <geheimdienst> my rule of thumb is: the bigger its scope, the longer the name. for a variable used only across 2 lines, "x" or "a" is fine and a three-word name would just clutter things up. for a variable used across the entire file, use longer names
13:46:32 <hpc> tac-tics: perl?
13:46:40 <dafis> armlesshobo: I meant the readline package resp the haskeline package, which take care of line editing stuff, however, if you're using 6.10, that one used editline, which was poor
13:46:46 <tac-tics> Linus Torvalds is also kinda a PITA
13:46:47 <hpc> (you need two spaces to accomodate some of the deeper loops)
13:46:48 <shachaf> kmc: What, you want me to open a new editor window for every .hs source file?
13:46:54 <tac-tics> hpc: #fantom
13:46:58 <monochrom> the haskell report also says 8
13:46:59 <hpc> ah
13:47:04 <armlesshobo> tac-tics: yeah, a whiney little man
13:47:21 <kmc> Linux uses 8 to discourage deeply nested control flow... instead you're supposed to make helper functions named foo, do_foo, sys_foo, do_sys_foo, __foo, __foo_, etc.
13:47:54 <armlesshobo> do_foo_foo
13:47:56 <hpc> kmc: except then you get all these wonky function names that look like noise
13:47:57 <tac-tics> kmc: That's also the reason LISPers use parens, isn't it? But that doesn't stop them from nesting shit until it's buried XD
13:47:58 <armlesshobo> foo_foo_sys
13:48:08 <armlesshobo> tac-tics: lol
13:48:18 <monochrom> helper functions for loops has the extra benefit of one simple "return" quits the loop without a lot of "goto"s or a lot of flags
13:48:18 <kmc> tac-tics, no it's not
13:48:25 <shachaf> foux_du_fafa
13:48:39 <kmc> parens and indentation are orthogonal in lisp just as braces and indentation are orthogonal in C
13:48:54 <monochrom> but by then it showcases the dumbness of C rather than the cleverness of the helper function method
13:49:02 <shachaf> I think tac-tics meant "they use parentheses to discourage deep nestings".
13:49:04 <geheimdienst> kmc: i guess it would be more sensible for linus to lobby for adding something like "where" to c
13:49:04 <hpc> monochrom: and if you screw up, the debugger has an easier time giving function names than line numbers
13:49:08 <shachaf> I doubt that's true, though.
13:49:30 <kmc> geheimdienst, last i hear they were trying to morph 'sparse' into a fancier preprocessor for C
13:49:42 <hpc> is anyone else really annoyed by haskell functions with huge 'where' clauses?
13:49:52 <monochrom> I am not
13:50:11 <monochrom> I also write nested where's
13:50:25 <kmc> tac-tics, i don't understand the thing you said about LISP; is it a joke that i don't get
13:50:26 <hnsz> fancy :p
13:50:32 <hpaste> melle pasted “RWH p98 ex7” at http://hpaste.org/51633
13:50:33 <kmc> is the joke just that you put "lisp" and "parentheses" in the same sentence?
13:50:39 <hpc> it's hard for me to read; i suppose i just can't handle parsing nested scopes in haskell
13:51:05 <melle> Hi all, noobish question here... working through RWH, can't seem to spot the error...
13:51:57 <dafis> melle: wrong argument order
13:52:06 <dafis> :t foldr
13:52:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:52:21 <hpc> jeez, it's so disorienting when people paste before they ask
13:52:27 <melle> dafis: Doh, thx! :)
13:52:29 <dafis> melle: where step c (acc, done) = ...
13:52:36 <hpc> i was waiting for the paste and didn't notice it above the question :P
13:53:03 <erus`> @hoogle ([a] -> b) -> M [a] -> M b
13:53:03 <lambdabot> Warning: Unknown type M
13:53:03 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
13:53:12 <geheimdienst> "a function in a where is like a top-level function except it's a buddy of this containing function and can see his arguments as well ..."
13:53:15 <erus`> anyone know of a function like that>
13:53:22 <hpc> erus`: fmap
13:53:35 <dafis> liftM
13:53:39 <hpc> (<$>)
13:53:54 <dafis> liftA
13:54:04 <hpc> arr
13:54:08 <geheimdienst> @hoogle liftA
13:54:08 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
13:54:08 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:54:09 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
13:54:21 <erus`> oh no :(
13:54:27 <geheimdienst> liftA is the same as fmap?
13:54:29 <parcs> is there a recent project that's similar to liskell?
13:54:30 <erus`> my language is strick
13:54:37 <erus`> strict*
13:54:44 <DanBurton> @hoogle fmap
13:54:44 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:54:44 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:54:45 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
13:54:59 <hpc> :t arr
13:55:00 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
13:55:08 <hpc> oh, not arr
13:55:09 <monochrom> a function in a where is like a top-level function except that the containing function has added the sub-function to his google+ circles...
13:56:13 <dafis> monochrom: is a google+ circle something like beer buddies?
13:56:27 <monochrom> I don't know. what is beer buddies?
13:56:29 <dafis> (only without the fun and beer)
13:56:38 <hpaste> erus` pasted “strict evaluation” at http://hpaste.org/51634
13:56:51 <dafis> monochrom: guys you occasionally go out and have a beer with
13:56:52 <erus`> is there anyway to make looper lazy without re implementing thunks?
13:57:12 <geheimdienst> a c++ friend class is one that has the other class friended on facebook, but has the relationship status set to "it's complicated ..."
13:57:38 <monochrom> some circles are like beer buddies
13:58:02 <dafis> geheimdienst: I thought a C++ friend class was one you allowed to touch your private parts
13:58:04 <hnsz> What if I want a class that is complex number and I make the getters friendly methods?
13:58:23 <hpc> @remember dafis I thought a C++ friend class was one you allowed to touch your private parts
13:58:23 <lambdabot> It is forever etched in my memory.
13:58:28 <monochrom> a circle is a set of other google+ accounts. that is all. just ZFC. you can use it for whatever you like
13:59:16 <monochrom> except that unfortunately because google's data centres have ultrafinitism limitations, you can't do really advanced things like transfinite ordinals there
13:59:20 <parcs> https://plus.google.com/107890464054636586545/posts/EbSuoRA6FTw
13:59:25 <parcs> genius
14:00:05 <hpc> monochrom: so a circle is like a ring, without the binary operations
14:00:27 <DanBurton> is anyone familiar with basic socket networking in Haskell?
14:00:57 <hpaste> DanBurton pasted “Simple Client” at http://hpaste.org/51636
14:01:22 <DanBurton> I have an echo server running on port 3000 but this simple client isn't working =/
14:01:24 <tac-tics> What a friendly server :D
14:01:28 <hpc> :t withSocketsDo
14:01:29 <lambdabot> Not in scope: `withSocketsDo'
14:01:35 <hpc> @hoogle withSocketsDo
14:01:36 <lambdabot> Network withSocketsDo :: IO a -> IO a
14:01:36 <lambdabot> Network.Socket withSocketsDo :: IO a -> IO a
14:01:36 <lambdabot> Network.Socket.Internal withSocketsDo :: IO a -> IO a
14:01:41 <DanBurton> :m +Network
14:01:55 <parcs> DanBurton: are you sure the server is not the problem?
14:02:08 <shachaf> DanBurton: Works for me.
14:02:14 <DanBurton> fairly sure; I can telnet in and get it echoing
14:02:47 <DanBurton> but when I runhaskell client.hs it says "connect: does not exist (connection refused)"
14:03:13 <DanBurton> is there any reason on a Linux machine why it wouldn't want to connect to "localhost"?
14:03:17 <geheimdienst> DanBurton: have you tried 127.0.0.1 instead of localhost?
14:03:18 <parcs> try "127.0.0.1" instead of "localhost"
14:03:24 <parcs> curses
14:03:31 <frigga1> Is it legal to have a type class with no function declarations?
14:03:39 <Cale> frigga1: yes
14:03:47 <DanBurton> cool that worked
14:03:54 <kmc> frigga1, also the declarations in a type class do not need to be functions
14:04:03 <DanBurton> why wouldn't it parse "localhost" though?
14:04:12 <shachaf> Not only legal, but moral as well.
14:04:20 <hpc> that's strange, it doesn't work for me even with 127.0.0.1
14:04:23 <kmc> @src Bounded
14:04:23 <lambdabot> class  Bounded a  where
14:04:23 <lambdabot>     minBound, maxBound :: a
14:04:41 <shachaf> There are also functions like getChar.
14:05:02 <frigga1> How do you declare a class like that?
14:05:04 <monochrom> "localhost" may resolve to some other IP if system setup is flawed
14:05:05 <geheimdienst> hpc: you got something listening on port 3000?
14:05:05 <kmc> shachaf, it's your new personal mission to confuse beginners?
14:05:11 <kmc> frigga1, leave off the "where"
14:05:14 <frigga1> Ahh
14:05:15 <hpc> geheimdienst: oh, derp
14:05:18 * shachaf apologizes.
14:05:23 <kmc> «class Foo a»
14:05:29 <shachaf> I should probably save it for #-blah. Or for nowhere at all.
14:05:31 <kmc> you can also have an empty "where" body but there's no need
14:05:59 <DanBurton> monochrom: that's weird; I can ping localhost and it uses 127.0.0.1 so I have no clue what is misconfigured
14:06:08 <frigga1> Ahh, I was forgetting the 'a'
14:06:08 <monochrom> you can have "module Nothing where" and leave it empty :)
14:06:08 <parcs> DanBurton: what platform are you on?
14:06:08 <shachaf> class Multiplicative a => Semigroup a
14:06:15 <DanBurton> parcs: Fedora Linux
14:06:26 <DanBurton> parcs: on a school computer
14:06:28 <kmc> frigga1, 0-parameter type classes are allowed with the MultiParamTypeClasses extension
14:06:33 <kmc> but they are of limited utility
14:06:39 <shachaf> kmc: No they're not. :-(
14:06:50 <kmc> in standard Haskell every type class has exactly one type parameter
14:07:03 <hpc> shachaf: how would you use one?
14:07:07 <frigga1> kmc: Oh, I want the parameter...just forgot it.
14:07:32 <parcs> DanBurton: works for me
14:07:37 <parcs> localhost, that is
14:07:47 <shachaf> hpc: class RiemannHypothesis; f :: RiemannHypothesis => ...
14:07:51 <tac-tics> kmc: In standard Haskell, couldn't you typeclass pair types?
14:07:53 <DanBurton> trippy
14:08:03 <parcs> in ghci, try importing Network.BSD and running fmap hostAddress $ getHostByName "localhost"
14:08:04 <tac-tics> kmc: as a replacement for multitype classes?
14:08:10 <parcs> then with "127.0.0.1"
14:08:12 * shachaf wishes 0-parameter classes were allowed.
14:08:29 <c_wraith> I still don't get that.
14:08:34 <c_wraith> I've seen people say it before.
14:08:51 <c_wraith> But I remain unconvinced it helps, given that classes only ever get added to contexts.
14:09:09 <monochrom> DanBurton's code works for me on ubuntu. I have "nc -l 3000" on the other side
14:09:14 <copumpkin> what's the point of a 0-parameter class?
14:09:16 <copumpkin> it won't hurt
14:09:24 <geheimdienst> DanBurton: check your /etc/hosts file. i didn't ever change anything in there, but apparently the default on my distro results in that i can't "ping localhost" but i can "ping localhost.localdomain".
14:09:25 <copumpkin> but I don't see any useful purpose for them
14:09:43 <shachaf> Consistency if nothing else.
14:09:48 <parcs> 0-parameter classes in type contexts would always succeed no?
14:10:01 <shachaf> parcs: If there's an instance.
14:11:19 <A1kmm> Does anyone know if Sven Panne is still maintaining his packages uploaded to Hackage? I got a 'mailbox full' bounce to patches I sent to his sven.panne@aedion.de mailbox
14:11:25 <hpc> shachaf: wait, what does that do?
14:11:54 <parcs> A1kmm: someone working on the opengl bindings tried to reach him a couple of months ago with no success
14:12:00 <frigga1> Anyone here familiar with convex optimization?
14:12:35 <DanBurton> hm my /etc/hosts looks fine; it has localhost as 127.0.0.1. Guess I'll just stick with the explicit address /sigh
14:12:48 <A1kmm> parcs: hmm, not sure what to do with my patches to OpenAL and alut then.
14:13:03 <A1kmm> (which fixes dyn package building on Windows platforms)
14:13:06 <parcs> upload a new package :P
14:13:15 <kmc> tac-tics, in standard Haskell there are also other restrictions on type classes; in fact the *only* instance you can write for (,) is «instance .... => C (a, b)»
14:13:16 <monochrom> ditch fedora and switch to ubuntu or whatever
14:13:43 <tac-tics> kmc: Well, you could always newtype it, couldn't you?
14:13:45 <kmc> you can't have, say, «instance C (Int, b)» and «instance C (a, Char)»
14:14:12 <rostayob1> can you say "instance C ((,) a)"?
14:14:15 <dafis> A1kmm: mailto:hopengl@haskell.org
14:14:23 <A1kmm> parcs: Maybe I should see if there is an obvious mailing list to put down as a maintainer, and then ask that list to review my patch, then upload it if everything is fine.
14:14:34 <A1kmm> dafis: hmm, but do they do OpenAL as well?
14:14:37 <kmc> rostayob1, yeah
14:14:41 <parcs> A1kmm: sounds good
14:14:47 <A1kmm> (which is an audio library)
14:15:20 <dafis> A1kmm: probably not, but perhaps they have an idea, having taken over one or two of Sven's packages
14:15:49 <dafis> (like, perhaps you could take over OpenAL)
14:16:42 <dafis> rostayob1: yes, that's legal H98 too
14:17:23 <shachaf> kmc: You can add constraints, though.
14:17:41 <A1kmm> dafis: Thanks, I'll try that list and see if they want to take over maintainership, or if they can suggest somewhere better.
14:18:07 <shachaf> So e.g. Text.Printf has class IsChar c where fromChar :: Char -> c; toChar :: c -> Char; instance (Char a) => C [a] where ...
14:19:38 <erus`> o crap
14:22:33 <DanBurton> On the topic of networking...can I get a code review on my echo server?
14:22:37 <hpaste> DanBurton pasted “Echo Server” at http://hpaste.org/51637
14:23:39 <parcs> DanBurton: look at the errors displayed underneath the paste
14:24:04 <DanBurton> parcs: I did see those. Anything else?
14:24:13 <copumpkin> use forever
14:24:16 <copumpkin> instead of explicit recursion
14:24:40 <DanBurton> :t forever
14:24:40 <hpc> :t forever
14:24:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:24:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:24:42 <DanBurton> lol
14:24:50 <copumpkin> pass runConn just h
14:25:04 <copumpkin> instead of passing it the full conn triple and then ignoring the other two elements
14:25:12 <parcs> don't use explicit import lists unless trying to resolve ambiguities
14:26:02 <parcs> add type signatures to top-level definitions
14:26:21 <geheimdienst> DanBurton: quite nice :) for those debug messages like in 20-21, i sometimes use trace from Debug.Trace
14:26:41 <geheimdienst> DanBurton: have you compiled it with -Wall? it should tell you things like what parcs just mentioned
14:27:41 <DanBurton> these are all great suggestions thanks everyone
14:28:30 <kmc> HLint and ghc -Wall are both great resources
14:28:47 <kmc> i sometimes like to use explicit import lists
14:29:02 <kmc> if the module is making a point about "we can implement foo using only bar and baz"
14:29:07 <geheimdienst> (hlint is the thing that produced the warnings under your paste)
14:29:22 <kmc> you can get stronger guarantees by restricting what you import
14:29:27 <kmc> e.g. importing readIORef but not writeIORef
14:29:53 <shachaf> Explicit imports can be such a hassle, though.
14:30:26 <geheimdienst> kmc: that's kind of a good point. in that case it outweighs the hassle, i think
14:30:31 <mamalujo> wiki on explicit vs implicit imports indeed suggests that for importing other ppl's modules, you should either import qualified, or explicitly. http://www.haskell.org/haskellwiki/Import_modules_properly
14:30:35 <geheimdienst> s/kind of//
14:30:52 <kmc> did anyone make a quasiquoter for inline C yet?
14:31:29 <geheimdienst> mamalujo: my opinion is that qualified (short names) is much better than explicit. much less hassle
14:31:57 <mamalujo> right. Though qualified operators look strange to me.
14:32:12 <kmc> yeah, i do qualified imports for everything except "standard" libraries
14:32:20 <kmc> or a few other special cases
14:34:23 <shachaf> There's a tool that will magically fix your imports if they're all qualified.
14:34:50 <kmc> there's also ghc -ddump-minimal-imports
14:36:01 <geheimdienst> shachaf: interesting, how do you mean "magically fix"?
14:36:58 <shachaf> geheimdienst: http://hackage.haskell.org/package/fix-imports
14:38:11 <geheimdienst> awesome, thanks
14:38:20 <matthew-_> so, amortized constant-time functional queue data structure. The need to do a ++ on a join is unfortunate - you can reach a pathological case where you end up a very long way away from amortized constant time.
14:38:35 <matthew-_> are there standard solutions to this problem?
14:39:08 <hpaste> DanBurton pasted “Echo Server v0.2” at http://hpaste.org/51638
14:39:22 <DanBurton> there how's that guys? ;)
14:39:47 <DanBurton> the only thing I couldn't manage was avoiding explicit recursion with runConn
14:40:57 <DanBurton> tacking on forever $ at the beginning just made it keep looping; it's supposed to stop if isEof or all isSpace line
14:43:20 <geheimdienst> that's perfectly all right, you only want runConn called sometimes. forever is for calling always
14:43:25 <Hazkel> hello
14:43:49 <DanBurton> Hazkel: hi
14:44:02 <Hazkel> where can i find tutorial for QuickCheck
14:44:13 <Hazkel> im new to haskell
14:44:15 <DanBurton> geheimdienst: cool, thanks
14:44:22 <copumpkin> @google quickcheck tutorial
14:44:23 <Hazkel> Hi DanBurton
14:44:26 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
14:44:26 <lambdabot> Title: Introduction to QuickCheck - HaskellWiki
14:44:39 <Hazkel> thank you
14:44:57 <copumpkin> http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
14:44:59 <geheimdienst> and really, look into ditching all those "(blah, blah)" parens in the imports :) it'll save you pain, particularly as the list gets longer
14:45:25 <DanBurton> I suppose. It just makes me feel snug when I restrict the imports.
14:46:25 <Hazkel> copumpkin thanx
14:46:56 <DanBurton> @hoogle [a] -> Maybe a
14:46:57 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
14:46:57 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:46:57 <lambdabot> Prelude head :: [a] -> a
14:47:37 <geheimdienst> DanBurton: my rule of thumb is to simply import stuff from the base package, from other packages i do "import qualified Blah.Blah.Blah as B"
14:48:20 <DanBurton> is it true that there are no name clashes in any of the base libs?
14:49:53 <geheimdienst> DanBurton: i think there's a few. Data.Map has a function "map" that's different from Prelude.map ... nothing serious. and the compiler will tell you about any clashes and you can solve those
14:50:48 <DanBurton> geheimdienst: I suppose that's true
14:51:07 <engla> I think Data.Map is outside base
14:52:40 <dafis> yep, containers
14:54:08 <geheimdienst> guys, it was just a rule of thumb :) just a rough guideline
14:54:10 <sanoff> hello, gentlemen
14:54:33 <sanoff> what in general does this mean:   A ~ SomeType ?
14:55:09 <byorgey> sanoff: it means that those two types are equal
14:56:43 <sanoff> byorgey, i am trying to work with what is called "polymorphic components" (data SomeC = SomeC (forall a. Num a => a))
14:57:11 <sanoff> i can create these values, but cannot distinguish one from another, being given val :: SomeC
14:57:19 <geheimdienst> sanoff: it's described here: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-families.html#equality-constraints i always found it a little hard to find :)
14:57:47 <byorgey> sanoff: what do you mean, you cannot distinguish them?
14:58:19 <byorgey> sanoff: do you have some particular code you could share which does not work or does not do what you want/expect?
14:58:33 <sanoff> geheimdienst, thanks,
14:58:55 <byorgey> sanoff: given val :: SomeC, you can pattern match on it using a pattern like  (SomeC n), then you can do Num operations on n
14:59:14 <sanoff> byorgey, i need to write fun :: SomeC -> String, such that fun (SomeC (1::Int)) returned "this is int", but fun (SomeC (2:: Double)) wrote "this is double", is that possible?
14:59:32 <byorgey> sanoff: that is not possible with only a Num constraint.
14:59:35 <rwbarton> that is not what your SomeC type says
15:00:21 <rwbarton> with your SomeC n, n has to be a value of *every* type that is an instance of Num simultaneously
15:00:45 <shachaf> sanoff: Do you really *need* that?
15:00:47 <sanoff> uh oh. I stumble on this already tenth tmie ;)
15:02:44 <byorgey> sanoff: perhaps you want   data SomeC = forall a. Num a => SomeC a
15:03:20 <byorgey> that means that SomeC will contain a value of *some* type, which is guaranteed to be an instance of Num, but we don't know which.
15:04:06 <byorgey> it would be possible to tell which type it is if you add a Typeable constraint.  However, there is almost certainly a better way to do whatever you are trying to accomplish.
15:04:18 <byorgey> sanoff: what is it you are ultimately trying to achieve?
15:05:00 <sanoff> http://hpaste.org/51639
15:06:25 <sanoff> that was my *real* question
15:07:26 <rwbarton> is the RecoverablePane class really empty?
15:08:22 * hackagebot hbeanstalk 0.2.3 - Client for the beanstalkd workqueue service.  http://hackage.haskell.org/package/hbeanstalk-0.2.3 (GregHeartsfield)
15:08:35 <rwbarton> oh wait
15:08:37 <byorgey> that's not unreasonable (until we get constraint synonyms), it adds Typeable, Show, and Read constraints
15:09:03 <rwbarton> yeah, the shifting variable names threw me off
15:09:22 <sanoff> nope, it is not empty.
15:09:38 <sanoff> looking at it, it has     getPane         ::  delta (Maybe alpha)
15:09:42 <sanoff> (adding it to the post)
15:10:16 <hpaste> sanoff annotated “polymorphic component question” with “polymorphic component question (annotation)” at http://hpaste.org/51639#a51640
15:10:31 <byorgey> sanoff: you need to add a Typeable constraint for alpha
15:11:33 <sanoff> byorgey, this woule be too python-ish, no?
15:11:36 <sanoff> would
15:11:51 <rwbarton> okay, and what do you mean by "get IDEBuffer"?
15:12:12 <sanoff> i need to get filePath from it
15:12:30 <sanoff> fileName, to be precise
15:12:51 <byorgey> sanoff: is there a Pane method for getting the file name?
15:13:09 <sanoff> no, it's in SourceBuffer, record label.
15:13:19 <sanoff> in IDEBuffer
15:13:32 <rwbarton> presumably there are panes without associated files, or something
15:14:32 <byorgey> this doesn't make sense.  something about the design is wrong here.
15:14:33 <sanoff> rwbarton, true, there are other instances of Recoverable panes
15:14:48 <byorgey> sanoff: what happens if you get an IDEPane that does not contain an IDEBuffer, but some other type?
15:14:49 <sanoff> byorgey, no, it all makes sense, maybe I'm presenting it wrong way
15:15:03 <sanoff> byorgey, i need to do nothing... it should be a case
15:15:09 <sanoff> "case" statement
15:15:37 <rwbarton> @type cast
15:15:38 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
15:15:52 <byorgey> sanoff: you should not need to do an explicit case on the *type* of a value. that is what type classes are for.
15:16:15 <byorgey> sanoff: add a method to Pane which returns a Maybe String  with the file name, or Nothing if there is no file name
15:16:35 <sanoff> byorgey, no, this is not an option, i want whole IDEBuffer record set.
15:16:52 <sanoff> i managed to do it somehow, seems almost proper way, but by coincidence..
15:17:17 <hpaste> sanoff annotated “polymorphic component question” with “polymorphic component question (annotation) (annotation)” at http://hpaste.org/51639#a51641
15:17:24 <byorgey> sanoff: well, again, you can just add a Typeable constraint on alpha in the declaration of RecoverablePane
15:19:08 <byorgey> that code will not work
15:19:20 <byorgey> there is no guarantee that z has the right type
15:19:47 <byorgey> if you add a Typeable constraint you can use 'cast' as rwbarton suggested.
15:20:00 <rwbarton> well, I just don't understand what 'getPane' does
15:20:01 <byorgey> try casting z to the type IDEBuffer, and do a case on the result
15:20:29 <sanoff> i am sorting this out..
15:20:39 <rwbarton> z is forced to have type Maybe IDEBuffer by the pattern match, so it will use the IDEBuffer instance of getPane, and who knows what that does but it exists...
15:22:40 <byorgey> oh, hmm
15:23:01 <byorgey> yeah, I am lost =P
15:26:29 <rwbarton> so basically you're calling some instance of makeActive which may or may not be from IDEBuffer, and then calling IDEBuffer's instance of getPane
15:26:35 <rwbarton> hard to say but I expect this is not what you really want to do
15:27:33 <rwbarton> so here is a question, is there some way to use the Typeable beta constraint? after all alpha and beta determine each other...
15:28:19 <rwbarton> > typeof (3 :: Int)
15:28:20 <lambdabot>   Not in scope: `typeof'
15:28:25 <rwbarton> > typeOf (3 :: Int)
15:28:26 <lambdabot>   Int
15:28:29 <rwbarton> > typeOf (undefined :: Int)
15:28:31 <lambdabot>   Int
15:28:32 <sanoff> I have found th esolution
15:28:45 <sanoff> in leksah code they use Typeable ;-)
15:28:52 <sanoff> what a pity!
15:29:01 <sanoff> they use cast
15:30:08 <rwbarton> oh, Pane alpha delta already has a Typeable alpha context
15:30:59 <sanoff> yes, class (Typeable alpha, PaneMonad delta) =>  Pane alpha delta | alpha -> delta  where
15:31:16 <sanoff> i should have noticed that
15:32:25 <rwbarton> > typeOf typeOf
15:32:26 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:32:26 <lambdabot>    `Data.Typeable.Typeable a...
15:32:47 <rwbarton> > fix typeOf
15:32:48 <lambdabot>   TypeRep
15:33:33 <kmc> hehe
15:33:36 <hpc> > fix typeOf
15:33:37 <lambdabot>   TypeRep
15:33:42 <hpc> oh, derp
15:33:51 <hpc> :t fix typeOf
15:33:52 <lambdabot> TypeRep
15:33:54 <hpc> :D
15:34:10 <antgeth> is there somewhere i can look at how the map and foldl functions work?  by which i mean, like, look at their "source"
15:34:18 <hpc> @src map
15:34:19 <lambdabot> map _ []     = []
15:34:19 <lambdabot> map f (x:xs) = f x : map f xs
15:34:22 <hpc> @src foldl
15:34:23 <lambdabot> foldl f z []     = z
15:34:23 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:34:32 <antgeth> well that was easy
15:34:33 <antgeth> haha
15:34:34 <antgeth> ty
15:34:42 <Peaker> @type \f -> foldr ((:) . f) []
15:34:43 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
15:34:48 <hpc> antgeth: there's also a "source" link next to every function and data structure in hackage docs
15:34:59 <Peaker> antgeth: that's a simpler map, if you grok foldr
15:35:03 <Peaker> (and points-free)
15:35:14 <Peaker> hpc: but base isn't on there, it's in the ghc docs I think
15:35:18 <Peaker> (and has no src links iirc)
15:35:25 <hpc> foldr ((:) . f) []?
15:35:40 <hpc> http://hackage.haskell.org/package/base
15:36:09 <Peaker> oh, has sources too
15:36:15 <DanBurton> @let map' f = foldr ((:) . f) []
15:36:16 <lambdabot>  Defined.
15:36:25 <DanBurton> > map' (^2) [1..5]
15:36:27 <lambdabot>   [1,4,9,16,25]
15:36:29 <Peaker> hpc: yeah, what's the question?
15:36:39 <hpc> Peaker: just forgot it all :P
15:37:06 <hpc> still not that great at pointlessing functions of more than two arguments
15:37:12 <DanBurton> @pl map
15:37:13 <lambdabot> map
15:37:23 <DanBurton> -.-
15:37:27 <hpc> @unpl (:) . f
15:37:28 <lambdabot> (\ c -> ((:)) (f c))
15:37:32 <Peaker> Maybe it's more readable as:  argument f (:)     or f ~> id ~> id $ (:)
15:38:00 <Peaker> @where SEC
15:38:00 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
15:38:04 <Peaker> hpc: have you read that?
15:38:05 <hpc> oh god, what's (~>)?
15:38:11 <hpc> ah
15:38:30 <hpc> Peaker: i have, but it was back when i was an idiot :P
15:39:01 <Peaker> hpc: well, argument f  and  result f   are functions that lift `f` to apply at the left or right side of a (->)
15:39:31 <DanBurton> @let map'' f = let step x acc = f x : acc in foldr step []
15:39:32 <lambdabot>  Defined.
15:39:39 <Peaker> hpc: ~> is a right-associative operator (to mirror ->)  that lifts the function on its left to operate on the argument, and the function on its right to operate on the result
15:39:43 <DanBurton> map'' (+1) [2..4]
15:39:48 <DanBurton> > map'' (+1) [2..4]
15:39:50 <lambdabot>   [3,4,5]
15:40:01 <Peaker> hpc: so a ~> b ~> c ~> d       will apply a,b,c,d  on the respective positions in the type   a->b->c->d
15:40:27 <Peaker> hpc: so if the functions a,b,c,d have types:  a->a', b->b', c->c', d->d' respectively, then  a~>b~>c~>d   will have type:  (a->b->c->d)->(a'->b'->c'->d')
15:41:07 <Peaker> ~> is to result and argument    what *** is to first and second
15:41:30 <Peaker> ((a *** b) *** (c *** d))   will apply a,b,c,d to their respective positions in the type  ((a,b),(c,d))
15:41:47 <antgeth> @src filter
15:41:48 <lambdabot> filter _ []     = []
15:41:48 <lambdabot> filter p (x:xs)
15:41:48 <lambdabot>     | p x       = x : filter p xs
15:41:48 <lambdabot>     | otherwise = filter p xs
15:42:14 <Peaker> > (((+1) *** (*10)) *** ((+100) *** (+1000))) $ ((0,0),(0,0))
15:42:15 <lambdabot>   ((1,0),(100,1000))
15:42:20 <deech> Are there some examples of binding Haskell to objects returned by dynamic languages? Specifically I'd like to enhance the Lua-Haskell binding and was wondering how to convert a Lua table to a Haskell datatype.
15:42:22 <Peaker> oops
15:42:24 <hpc> Peaker: reading the article; so far it's making 1000000% more sense
15:42:40 <DanBurton> so I just tried to cabal install lambdabot, so as to enjoy further adventures with lambdabot without cluttering #haskell, but cabal-install gave me this error: "cannot configure QuickCheck-2.4.1.1. It requires ghc -any. There is no available version of ghc that satisfies -any." wtf? I have ghc 6.12.3; that doesn't count as -any?
15:43:54 <c_wraith> DanBurton: that usually means there was some other conflict.  But you know you can /query lambdabot to interact with it in a private channel?
15:44:09 <hpc> Peaker: he seems to be leaving out a lot of code; he talks about inEvent but never gives the definition or type
15:44:24 <DanBurton> c_wraith: oohhh cool. I'm still miffed at cabal-install though =/
15:44:39 <Peaker> hpc: typically that's just fmap or such
15:44:58 <c_wraith> DanBurton: Lambdabot is notoriously hard to get working, because of its design.  Don't be too concerned about it.
15:45:08 <deech> bos: Thanks for your great talk and workshop at Strange Loop!
15:45:15 <Peaker> hpc: something like:  inEvent f (Event x) = Event (f x)
15:45:48 <DanBurton> c_wraith: but now I suddenly want QuickCheck, because I can't have it :( cabal install quickcheck results in the same
15:45:52 <Peaker> hpc: ideally we'd get it for free from an instance to some standard class (e.g: the misnamed Newtype class)
15:46:29 <hpc> heh
15:46:29 <Peaker> DanBurton: try -v
15:46:43 <hpc> Peaker: what's the definition of (~>)? it wasn't given in the blog post
15:46:44 <c_wraith> or -v3 if you're feeling extreme
15:46:59 <Peaker> hpc: yeah, that was in another blog post and I can't find it
15:47:03 <conal> hpc: there are some follow-up posts.
15:47:23 <kmc> deech, something like this?  data LuaValue = LInt Int | LString String | LTable (Map LuaValue LuaValue)
15:47:30 <Peaker> hpc: arg ~> res   =   argument arg . result res     is one possibility
15:47:34 <DanBurton> Peaker: -v gave nothing extra
15:47:36 <Peaker> hpc: infixr 2 ~>
15:47:52 <DanBurton> c_wraith: -v3 spat out some crap but means nothing to me xP
15:47:53 <kmc> deech, the alternative is to focus on the things lua values can do, rather than enumerating them explicitly
15:47:59 <kmc> so you can build a record of functions for those operations
15:48:07 <hpc> Peaker: oh, cool
15:48:11 <Peaker> hpc: another possibility is:  (arg ~> res) f = arg >>> f >>> res
15:48:36 <Peaker> hpc: it's nice that you get the visual alignment with (a ~> b) ~> c ~> d   with the same-looking type
15:48:52 <deech> kmc: Ooh, cool. I like that.
15:49:02 <hpc> Peaker: yeah, it's quite nice
15:49:20 <hpaste> DanBurton pasted “cabal install quickcheck -v3” at http://hpaste.org/51642
15:49:24 <Peaker> hpc: the not-nice thing is sprinkling the ~> expression with lots of id's, because you just want to touch one of the things :)
15:49:53 <hpc> Peaker: fortunately (id ~> id) = id
15:49:54 <Peaker> hpc: my use above:  map f = foldr (f ~> id ~> id $ (:)) []
15:50:35 <hpc> :t (\x -> y) . (:)
15:50:36 <lambdabot> forall a. a -> Expr
15:51:01 <Peaker> @let (arg~>res) f = arg>>>f>>>res
15:51:02 <lambdabot>  Defined.
15:51:06 <Peaker> oops, forgot infixr
15:51:10 <Peaker> @undef
15:51:25 <Peaker> @let infixr 2 ~> ; (arg~>res) f = arg>>>f>>>res
15:51:26 <lambdabot>  Defined.
15:51:29 <hpc> f ~> id = (f .) -- working out the identities in my head
15:51:35 <hpc> id ~> f = f
15:51:50 <Peaker> hpc: f ~> id = argument f = flip (.) f = (. f)
15:51:56 <hpc> oh, yes
15:52:05 <hpc> and (. (. f)) = (f .)
15:52:11 <hpc> hence f ~> id ~> id
15:52:15 <Peaker> why?
15:52:35 <Peaker> @type \f -> (. (. f))
15:52:36 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => f a -> (f b1 -> b) -> (a -> b1) -> b
15:52:37 <hpc> er, doublederp
15:52:45 <Peaker> @type \f -> (f .)
15:52:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:52:50 <hpc> keep thinking map f = foldr (f . (:)) []
15:53:16 <Peaker> if that were the case, it'd be operating on the result of (:) applied to a single arg
15:53:24 <hpc> :t \f -> (. (. f)) (:)
15:53:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> [f b] -> [f b]
15:53:27 <Peaker> so f would always have to be taking a [a]->[a] type as an arg
15:53:32 <hpc> :t \f -> (f .) (:)
15:53:33 <lambdabot> forall b a. (([a] -> [a]) -> b) -> a -> b
15:53:44 <DanBurton> @pl let step x acc = f x : acc in foldr step []
15:53:44 <lambdabot> foldr ((:) . f) []
15:54:04 <hpc> yeah
15:54:21 <Peaker> :t \f -> (. f) (:)
15:54:22 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ([a] -> [a])
15:54:24 <hpc> @unpl (. (. f))
15:54:25 <lambdabot> (\ b e -> b (\ i -> e (f i)))
15:54:57 <Peaker> hpc: in my head I keep translating that to: argument . argument $ f    to understand what it means :)
15:55:49 <Peaker> argument.argument       goes:  ((HERE -> b) -> c)
15:55:53 <hpc> :t (:) . f
15:55:54 <lambdabot> forall a (f :: * -> *). (SimpleReflect.FromExpr (f a), Functor f) => f ([a] -> [a])
15:56:02 <hpc> :t (:) Prelude.. f
15:56:03 <lambdabot> forall b a. (Show a, SimpleReflect.FromExpr b) => a -> [b] -> [b]
15:56:16 <hpc> ooooooh, suddenly it makes sense now
15:56:42 <hpc> a -> [b] -> [b]
15:56:46 <hpc> f ~> id ~> id
15:57:00 <Peaker> hpc: yep
15:57:03 <hpc> you may now return to your regularly scheduled knowing-more-than-me
15:57:26 <DanBurton> ok guys another random question about hackage: so I uploaded my first package yesterday, http://hackage.haskell.org/package/composition-0.1 , but it's undocumented. I thought cabal sdist would at least generate docs based on the type signatures of the exposed functions. How do I add documentation?
15:57:26 <Peaker> hpc: when ~> clicked it all became so simple :)
15:57:36 <Peaker> hpc: I think a good IDE can really make ~> and *** and stuff work nice visually
15:58:02 <Peaker> hpc: see a type of an expression, select via nav/search/mouse which type in there you want to lift a func to, and you get a SEC there
15:58:19 <hpc> :t f ~> id ~> id
15:58:20 <lambdabot> forall a b a1 b1. (Show a, SimpleReflect.FromExpr b) => (b -> a1 -> b1) -> a -> a1 -> b1
15:59:09 <Peaker> hpc: it's contravariant, on left side of arrow, slightly confusing
15:59:28 <hpc> yeah
16:00:06 <hpc> i see how the type works though
16:00:17 <hpc> (b -> a1 -> b1) ->
16:00:21 <hpc> a -> a1 -> b1
16:00:26 <hpc> f :: (a -> b)
16:00:38 <hpc> timey wimey
16:00:49 <hpc> @where sec
16:00:49 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:00:56 <hpc> (ff crash)
16:02:05 <hpc> :t (~>)
16:02:06 <lambdabot> forall (cat :: * -> * -> *) a b b1 c. (Control.Category.Category cat) => cat a b -> cat b1 c -> cat b b1 -> cat a c
16:02:52 <conal> hpc: see also (argument.argument)
16:03:14 <hpc> i don't like how it associates (f ~> g) ~> h for types a -> (b -> c) though
16:03:38 <Peaker> ~> lifts the   cat a b     and     cat b1 c      to apply on both sides of     cat b b1     so b and b1 are replaced by a and c, resulting in cat a c
16:03:39 <hpc> it'd be nicer to somehow have more symmetry there, though i know it would be probably not possible
16:03:48 <Peaker> hpc: that's why it's infixr
16:03:48 <hpc> yeah
16:04:15 <Peaker> :t chr ~> ord ~> length
16:04:16 <lambdabot> forall a. (Char -> Int -> [a]) -> Int -> Char -> Int
16:05:02 <Peaker> or do you mean some other form of symmetry?
16:05:27 <ben_> in what way are enumerators/iteratees like a left fold?
16:05:31 <hpc> Peaker: i mean it would be nice if the parens "went the same way"
16:05:46 * hpc is just being ocd
16:05:50 <Peaker> hpc: they do once ~> is defined to be infixr
16:05:58 <hpc> yeah
16:06:14 <hpc> er, if they had the same fixity then
16:06:22 <hpc> (i know it's not possible)
16:07:22 <rwbarton> :t (chr ~> ord) ~> length
16:07:23 <lambdabot> forall a. ((Int -> Int) -> [a]) -> (Char -> Char) -> Int
16:07:23 <Peaker> ben: Iteratees represent a state machine that eats an input sequence element by element, updating its state. I guess that's somewhat similar to a left fold that eats an input sequence element by element, updating its accumulator
16:07:32 <ben> right
16:10:28 <Peaker> > ((chr ~> ord) ~> length) (\f -> f (\c -> [c])) id
16:10:29 <lambdabot>   The lambda expression `\ c -> ...' has one argument,
16:10:29 <lambdabot>  but its type `GHC.Typ...
16:12:08 <Peaker> > ((chr ~> ord) ~> length) (\f -> [f 1]) id
16:12:10 <lambdabot>   1
16:12:33 <Peaker> > ((chr ~> ord) ~> length) (\f -> [undefined,undefined]) id
16:12:34 <lambdabot>   2
17:20:24 <hpaste> “,lñm” pasted “m,m” at http://hpaste.org/51643
17:20:57 <djahandarie> roconnor, you at ICFP?
17:21:18 <roconnor> djahandarie: I was
17:22:01 <djahandarie> Oh yeah, it just ended didn't it
17:22:07 <roconnor> yep
17:22:16 <djahandarie> Fun?
17:23:39 <roconnor> it was alright
17:23:44 <roconnor> I like ITP more
17:23:52 <monochrom> w00t, ITP
17:23:54 <roconnor> I kinda hate the ACM
17:24:21 <djahandarie> Are you sticking around for the dependent types thing? That happens after ICFP right?
17:24:26 <djahandarie> Or did that happen before..
17:24:30 <roconnor> djahandarie: it happened before
17:24:35 <roconnor> I wasn't invited :(
17:24:37 <djahandarie> Aw :(
17:24:43 <roconnor> it's okay
17:24:56 <roconnor> I'm not currently working entirely in dependent types at the moment
17:24:58 <roconnor> :(
17:25:01 <djahandarie> :(
17:25:14 <copumpkin> poor roconnor
17:25:16 * copumpkin comforts roconnor 
17:25:23 <roconnor> :)
17:25:23 <copumpkin> roconnor: rewrite purecoin in coq now!
17:25:27 <djahandarie> Haha
17:25:30 <roconnor> lambdabot says I frown the most on #haskell
17:25:41 <copumpkin> roconnor: :O
17:26:00 <copumpkin> don't be sad!
17:26:01 <roconnor> copumpkin: I sort of was considering the haskell purecoin as a first step towards a coq purecoin
17:26:05 <copumpkin> oh nice
17:26:31 <roconnor> that said I'm slowly losing interest in bitcoin
17:26:48 <roconnor> though I really should finish purecoin
17:26:55 <roconnor> it's almost doneish
17:27:17 <zmv> wtf bitcoin
17:27:39 <roconnor> zmv: is that a question?
17:28:11 <roconnor> copumpkin: what time is it there?
17:28:13 <roconnor> oh
17:28:20 <roconnor> my IRC client says it is 21:25
17:28:25 * hackagebot PrimitiveArray 0.0.4.0 - Unboxed, multidimensional arrays based on the primitive  package.  http://hackage.haskell.org/package/PrimitiveArray-0.0.4.0 (ChristianHoener)
17:29:00 <djahandarie> Reminds me of when I switched my laptop to the Japanese timezone then neglected to fix it for like a year of being back in EST
17:29:00 <zmv> roconnor: kinda
17:29:26 <roconnor> djahandarie: you must have been very early to meetings
17:29:54 <copumpkin> roconnor: same
17:31:21 <roconnor> zmv: it's a crazy libertain crypto currency designed to give the illusion of anonymity for transactions while not being anonymous at all.
17:31:53 <geheimdienst> it's money with money laundering built-in?
17:32:31 <copumpkin> it's not designed to give that illusion :P
17:33:55 <roconnor> geheimdienst: more like a honey-pot of money launderers
17:34:02 <roconnor> *for money launderers
17:34:10 <geheimdienst> :)
17:34:24 <monochrom> it is designed to give people debates and controversies
17:34:43 <copumpkin> I think that's a noble goal
17:35:14 <monochrom> \∩/
17:35:27 <geheimdienst> trolling by currency
17:35:36 <monochrom> my goal is to nullify debates and controversies
17:35:44 <monochrom> @quote monochrom debates
17:35:45 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
17:37:40 * Rotaerk polymorphs monochrom.
17:51:31 <sanoff> f1 :: IO (Maybe a), f2 :: a -> IO (), how to compose them so Nothing returned by f1 will not get f2 called
17:53:12 <mauke> :t ?f1 >>= maybe (return ()) ?f2
17:53:13 <lambdabot> forall (m :: * -> *) a. (?f1::m (Maybe a), Monad m, ?f2::a -> m ()) => m ()
17:54:18 <copumpkin> bind on MaybeT IO probably does it too
17:55:05 <mauke> :t ?f1 >>= maybe (putStr "hello\n") ?f2
17:55:06 <lambdabot> forall a. (?f2::a -> IO (), ?f1::IO (Maybe a)) => IO ()
17:56:21 <sanoff> mauke, thanks
17:56:51 <sanoff> i thought there's something already
17:59:23 <joe6> just read the article on reddit.com/r/haskell about using haskell in a startup. Has anyone used Jenkins for continuous builds? Any experiences?
18:00:09 <joe6> is there something like that in haskell that is widely used or well regarded?
18:04:41 <joe6> shaker, nemesis, cabal build, seem to be some of the options.
18:50:04 <kmc> joe6, what's wrong with Jenkins? isn't that what the talk says they use?
18:50:41 <joe6> kmc, i am sorry, I had some irssi issues. I am not sure if anyone replied to what I posted.
18:50:50 <joe6> nothing wrong with jenkins, just not in haskell.
18:51:06 <joe6> and I do not want to muck around with java, if i don't have to.
18:51:23 <joe6> shaker seems to be an alternative, but I am not sure how good that is.
18:51:31 <joe6> about to try it in a few hours or tomorrow.
18:54:41 <kmc> why does it matter what language Jenkins is written in?
18:55:03 <kmc> i don't think it's a good use of resources to reimplement all the software in the world in Haskell
18:55:19 <shachaf> Traitor!
18:58:43 <sm> joe6: two others are yesod devel (continuously builds yesod apps) and sp (continuously runs ghc --make)
18:59:36 <joe6> sm, thanks.
19:00:02 <joe6> sm, have you tried shaker?
19:00:09 <sm> not yet.. you ?
19:00:20 <joe6> let me check on sp, that is probably what i need.
19:00:30 <sm> http://joyful.com/darcsden/simon/hledger/Makefile#L-18
19:00:31 <joe6> i need something like the continuous action of shaker.
19:02:14 <sm> sp may work better if your project spans multiple packages
19:13:08 <joe6> sm, what is the url for sp, I cannot seem to find it.
19:13:22 <sm> joe6: I just gave it
19:13:39 <joe6> ok, that is sp. I thought it was showing the usage of sp
19:13:48 <sm> I think. There's another one or two in the makefile
19:14:30 <sm> ie my branch, which is the one you want. That url will show you the original home link
19:15:28 <joe6> ok, thanks a lot.
19:15:55 <sm> np. It's fantastic, I use it constantly
19:16:16 <joe6> and, comes highly recommended.
19:21:11 <JoeyA> I'd like to propose a name for a GHC extension: -XImpregnableTypes.  I don't know what it would do, though.
19:21:35 <djahandarie> Rejected, too easy to write.
19:21:47 <JoeyA> hmm?
19:22:08 <frio_> -XReallyImpregnableExtendedTypeFamilyManager
19:22:16 <JoeyA> heh
19:22:43 <JoeyA> Should probably be ImpregnableInstances
19:23:04 <monochrom> haha djahandarie wins
19:23:34 * edwardk walked in on an interesting conversation
19:24:07 <JoeyA> Why thank you!
19:24:12 <JoeyA> You are too kind.
19:25:45 <napping> edwardk: where is the current Trifecta version?
19:26:03 <napping> somehow the latest version cabal grabs now has a MonadTokenParser
19:26:24 <edwardk> interesting
19:26:31 <frio_> joe6: fwiw though, continuous building is fantastic
19:26:34 <napping> also, it defines brackets with <>
19:26:38 <napping> instead of []
19:26:51 <frio_> the sbt ~build command for scala does continuous builds of your projects, and that was a godsend when i was developing
19:26:53 <edwardk> http://hackage.haskell.org/package/trifecta-0.47 doesn't have one
19:26:59 <napping> I've got another project going that needed an interpreter - or rather, had an interpreter that needed a parsser
19:27:00 <frio_> instant reporting of failed builds + test errors
19:27:09 <edwardk> what version did you pull?
19:27:13 <copumpkin> frio_: "instant", considering scala's epic build times :)
19:27:19 <copumpkin> but yeah, it is nice
19:27:21 <copumpkin> I use it all the time
19:27:25 <frio_> well, sure copumpkin :p
19:27:28 <edwardk> also, i've been working on GLL parsing to see if i can get you something with decent error recovery ;)
19:27:34 <napping> just browing on github, to see if I could find any version online that explained MonadTokenParser
19:27:36 <joe6> frio_, yes, i loved it too. i think there is something in vim, that checks out your file with a :w too.
19:27:45 <frio_> fast enough for the ~20k LOC i had, luckily
19:27:48 <edwardk> MonadTokenParser is older, it was around 0.44 or 0.45
19:27:55 <napping> oh, weird
19:27:56 <frio_> thatd be cool joe6
19:28:09 <napping> if it's obsolete, how do you change the comment syntax?
19:28:10 <joe6> frio_, there is one like that already.
19:28:12 <frio_> id like to hear how you find jenkins if you try it; im quite keen to roll out a CI system for all my code
19:28:28 <napping> ah, ended up with 0.41 somehow
19:28:51 <dolio> Did you forget to cabal update?
19:28:57 <edwardk> comment syntax is supplied by whatever whiteSpace implementation you use for your parser. the default Parser … a instance just parses actual whiteSpace.
19:29:11 <frio_> im sure there is joe6; my recent work has been in java (fffffffffuuuuuuuuuuuuuuu) sadly, so ive been using "big" IDEs rather than vim :)
19:29:35 <frio_> so, itd be cool if i still actively used vim :p
19:29:46 <edwardk> but you can either use the Language parser transformer and pass it a CommentStyle or you can make a custom newtype wrapper and instantiate the whiteSpace (er. someSpace) parser yourself using buildSomeSpaceParser from Text.Trifecta.Parser.Token.Style
19:30:06 <edwardk> Language (Parser …) a is probably the easiest way
19:30:42 <edwardk> the problem with the old MonadTokenParser was it was really inconvenient for folks to just pick up the library and parse something
19:31:00 <frio_> which reminds me, are there any decent c# channels around?
19:31:03 <edwardk> now they can use it and integer, etc. largely do what they expect
19:31:17 <frio_> which reminds me, are there any decent c# channels around?
19:31:19 <edwardk> and they can add layout, literate comments, and comments using the parser transformers
19:31:23 <edwardk> frio_: no
19:31:58 <frio_> :(
19:32:03 <napping> they'd have funny names anyway, ##c#
19:32:23 <djahandarie> They decided to add another # just for symmetry purposes.
19:32:27 <napping> Yeah, I was looking for something like that, guess I had the wrong one
19:32:54 <napping> ah, hadn't run cabal update in a while
19:33:05 <edwardk> napping: i think i figured out a way to get decent error reporting from a 'list of successes'/gll/glr parser btw. still working on getting a kind of error production for gll that feels like an lalr error production though
19:33:44 <napping> I think a kind of recovery that followed the dyck skeleton could be enough
19:34:03 <napping> Not that I see how to automatically implement that either
19:34:10 <edwardk> basically trying to get the best of both worlds between parsec-style and glr style
19:34:35 <napping> well, can you implment a non-greedy version of many?
19:35:07 <edwardk> the main problem with most glr-style and list-of-successes parsers is they just silently close parsers as they fail, whereas with parsec-style parsers they only take one parse
19:35:31 <napping> That doesn't sound like a problem so far
19:35:35 <edwardk> without gll not really. the best you can do is manytill
19:36:03 <napping> well, manytill until the parser used after the current parser in the context accepts a character
19:36:07 <edwardk> well, the former means you don't know why the parse failed, the latter is great for unambiguous grammars but it means the applicative fragment had really better be context free ;)
19:36:33 <napping> You can close any parser that doesn't explicitly use the special error term
19:37:01 <edwardk> its a bit trickier in the monadic fashion because i don't know the current 'production' in a meaningful way
19:37:55 <edwardk> also i want to be able to deal with ambiguity in a controlled fashion. so what i started doing was plotting out a style of gll parser that deals with ambiguity rather explicitly, so you can say what parts of the grammar should be ambiguous and where you want it to have a single parse, etc.
19:38:10 <napping> and you are not allowed to make >>= have special significance
19:38:23 <napping> hmm, maybe you can try
19:38:25 <edwardk> that way you can deal with things like the (a) & (b) ambiguity in the c++ grammar without resorting to a lexer hack, deferring it to type checking time
19:38:55 <napping> that's hardly the worst! You've heard of elkhound/elsa?
19:38:56 <edwardk> its more a matter that without an actual value to put in i can't call the function =P
19:39:00 <edwardk> yes
19:39:14 <edwardk> i've spent a fair bit of time with elkhound
19:39:35 <napping> Well, it seems perfectly reasonable to make an error recovery combinator require a default value
19:39:50 <edwardk> in fact what motivated me to think about gll was going back and looking at a tech talk given by mcpeak
19:40:17 <hpaste> “Justin Hamilton” pasted “Parse_ID_formal” at http://hpaste.org/51645
19:40:28 <edwardk> anyways the main point is that the _monad_ takes you pretty far outside of context free
19:40:36 <edwardk> in fact the applicative can
19:40:53 <edwardk> what i'm trying to do is build a nice gll in-haskell dsl that doesn't though
19:41:13 <jamiltron> Hello, I'm having some problems wrapping my head around Parsec. I've been going through the Write You A Scheme Tutorials, and have decided I want to try writing a bunch of parsers for a grammar that I have.
19:41:58 <jamiltron> Particually, I'm trying to compose a parser where I parse out an identifier followed by open-and-close square brackets.
19:42:32 <jamiltron> I think that there's a simple solution to this, but I'm getting tripped up on a "last statement in a 'do' must be an expression" error.
19:42:45 <edwardk> it is requiring me to dig up a bunch of my old observable sharing tricks
19:42:45 <mauke> ok, that's just syntax
19:42:51 <mauke> I can do syntax!
19:42:58 <jamiltron> I wish I could do syntax
19:43:19 <mauke> show me your codings
19:43:27 <jamiltron> http://hpaste.org/51645
19:43:51 <napping> actually, something like manyTill that doesn't consume the characters used by the end parser should be enough to emulate any error recovery where "error" comes before a token
19:43:51 <edwardk> jamiltron: its probably your spacing
19:44:05 <edwardk> jamiltron: the do isn't aligned properly
19:44:20 <edwardk> the 'char' has to line up with the x in x <- parseIdentifier
19:45:07 <jamiltron> edwardk: Ah! Thank you so much.
19:45:39 <mauke> jamiltron: solution: always start a new line after do/where/of
19:45:50 <edwardk> jamiltron: to make your indentation less brittle i recommend putting the words after do on the next line, and then lining up there, that way you don't have to change the indentation on n lines whenever you change the identifier name
19:46:00 <jamiltron> ok, that makes sense
19:47:11 <napping> hmm, is anything wrong with notFollowedBy . notFollowedBy ?
19:48:51 <edwardk> nah, it'll double negate just fine
19:49:15 <napping> but skip consuming input
19:49:20 <edwardk> sure
19:49:47 <napping> is there a quick way to run a parser if I actually want the result?
19:49:56 <napping> I ended up copying parseTest
19:49:56 <edwardk> lookAhead ?
19:50:01 <edwardk> oh
19:50:07 <edwardk> not yet =/
19:50:23 <edwardk> it wasn't in the parsec api as such so i didn't put it in yet
19:50:35 <edwardk> usually i parseFromFile for real content
19:50:57 <napping> ah, lookAhead
19:51:04 <napping> yeah, that's better
19:51:10 <napping> manyTill .. (lookAhead ..)
19:51:53 <jamiltron> What is the best way in parsec to parse optional characters? So I already have a parser for Identifier, but I want to build a parser that matched Identifier or Identifier[] or Identifier[Number]?
19:52:07 <edwardk> that is pretty much the usual error recovery approach used in parsec
19:52:36 <edwardk> optionMaybe or option
19:57:53 <napping> well, manyTill anyChar (lookAhead ??)
20:03:04 <edwardk> that'll probably work for a lot of grammars
20:03:32 <edwardk> you'll need to do a fair bit of crazy plumbing for types, and the default value, and its not a perfectly general use pattern, but it should get you by
20:03:55 <edwardk> since you'll need to track the fact that you recovered an error in the parse result
20:09:19 <napping> I could log a diagnostic (if I figure out how to make nice ones)
20:21:35 <edwardk> hrmm, directly embedding packrat parser memotables into larger packrat parser memotables using lenses doesn't suck
20:23:04 <djahandarie> agile scrum Haskell social microblog development
20:23:26 <edwardk> is that retaliation for me throwing random buzzwords out?
20:23:57 <djahandarie> ;)
20:25:59 <djahandarie> (Only doing kmc's dirty work for him)
20:26:06 <edwardk> hah
20:28:03 <hpaste> djahadnarie pasted “agile scrum” at http://hpaste.org/51646
20:28:23 <djahandarie> Man. I know I need to switch my nick when I start misspelling it myself.
20:30:16 <edwardk> hah
20:30:22 <edwardk> you going to boston haskell this month?
20:30:32 * copumpkin applies peer pressure to djahandarie 
20:30:47 <djahandarie> Ouch.
20:31:37 <edwardk> "It was super effective"
20:32:13 <djahandarie> I think I can go, though I might be a tiny bit late
20:32:19 <edwardk> fair nuff
20:32:25 * copumpkin applies more peer pressure
20:32:58 <edwardk> copumpkin: haven't you ever watched television? anime? the same attack never works twice
20:33:14 <edwardk> you need a powerup
20:33:21 <edwardk> a montage
20:33:23 <edwardk> something
20:33:28 * copumpkin applies ninja pressure skills + threat of five point palm exploding heart technique
20:33:44 <edwardk> better =)
20:34:38 <djahandarie> これて…なんとすごい力…
20:35:13 <edwardk> =)
20:35:18 <pikhq_> わー。その術はすごーい！
20:49:16 <DevHC> what does "zi" mean?
20:49:32 <mauke> preflex: zdec zi
20:49:32 <preflex>  .
20:50:13 <DevHC> ?
20:50:47 <mauke> ?
20:50:55 * DevHC hands preflex some botsnack
20:51:05 <mauke> preflex: botsnack
20:51:06 <preflex>  ☺
20:51:11 <mauke> preflex: zenc ?
20:51:11 <preflex>  z3fU
20:51:22 <DevHC> lol
20:51:59 <DevHC> so zi is a [a-zA-Z0-9]-encoded . char?
20:52:11 <mauke> yes
20:52:24 <mauke> z-encoding is the symbol mangling scheme used by ghc
20:53:05 <DevHC_> where was it
20:53:07 <DevHC_> -t
20:53:09 <DevHC_> <DevHC> so zi is a [a-zA-Z0-9]-encoded . char?
20:53:56 <mauke> <mauke> yes  <mauke> z-encoding is the symbol mangling scheme used by ghc
20:54:22 <elliott> What's a good way to get a random element out of an arbitrary Map? I'd rather avoid converting it to a list.
20:54:34 <elliott> Something using split?
20:55:08 <mauke> preflex: zenc int __cdecl SolomonData(int) (?SolomonData@@YAHH@Z)
20:55:08 <preflex>  intz20Uzuzucdeclz20USolomonDataZLintZRz20UZLz3fUSolomonDataz40Uz40UYAHHz40UZZZR
20:55:17 <djahandarie> Why not just generate a random number based on the size of the map, then use !?
20:55:31 <elliott> djahandarie: Because my keys aren't integral?
20:55:40 <DevHC_> preflex: dec base_GHCziBase_zdfMonadIO_closure
20:55:44 <djahandarie> Ah, that would do it. lol
20:55:46 <DevHC_> preflex: zdec base_GHCziBase_zdfMonadIO_closure
20:55:46 <preflex>  base_GHC.Base_$fMonadIO_closure
20:57:02 <djahandarie> elliott, elemAt should work
20:57:24 <djahandarie> :t M.elemAt
20:57:25 <lambdabot> forall k a. Int -> M.Map k a -> (k, a)
20:57:50 <elliott> Oh, thanks :)
20:59:51 <punkkk> Hey all, I'm working on a problem set and bogged down on one. I'm trying to create a function remove :: [Int] -> [Int] that will remove duplicates from a given list. So far Ive only been able to create a function that remove consecutive duplicates.
21:00:27 <mauke> remove = nub
21:00:35 <punkkk> without using nub
21:00:39 <mauke> :-(
21:00:48 <napping> Set.toList . Set.fromList ?
21:00:48 <mauke> remove = S.toList . S.fromList
21:01:02 <napping> requires Ord, but that's fine for Int
21:01:20 <mauke> remove = map head . group . sort
21:02:20 <antgeth> hey punkkk
21:02:48 <napping> nothing that just depends on Eq is going to look very nice
21:03:06 <antgeth> orrrrr not
21:03:59 <napping> remove l = filter (`elem`l) [minBound..maxBound]
21:04:23 <napping> I do believe that's O(n)
21:04:35 <Cale> remove [] = []; remove (x:xs) = x : remove (filter (/= x) xs)
21:05:01 <mauke> napping: hahaha
21:05:03 <napping> >length ([minBound..maxBound]::Int)
21:05:10 <napping> > length ([minBound..maxBound]::Int)
21:05:11 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:05:11 <lambdabot>         against inferred type ...
21:05:22 <dolio> Yep, O(n).
21:05:50 <napping> oh, that's going to be slow
21:06:37 <napping> > toInteger (maxBound :: Int) - toInteger (minBound :: Int) + 1
21:06:38 <lambdabot>   18446744073709551616
21:07:17 <djahandarie> > genericLength ([minBound..maxBound] :: [Int])
21:07:18 <lambdabot>   *Exception: stack overflow
21:07:19 <djahandarie> Heh.
21:08:03 <napping> > filter (`elem`[1,2,1,4,3,2::Int]) ([0..maxBound]++[minBound])
21:08:06 <antgeth> hey punkkk
21:08:07 <lambdabot>   mueval-core: Time limit exceeded
21:08:26 <napping> works better in ghci :)
21:08:39 <antgeth> i couldn't get that one or the insertInOrder
21:08:39 <napping> Cale: it is homework
21:10:25 <napping> You should take a bit of time to convince yourself that it takes O(n^2) time if you just use equality tests
21:11:12 <napping> otherwise you might not think to write something as inefficient as an actual solution
21:11:51 <djahandarie> It's integers, you should be able to go faster than O(n^2)
21:11:57 <DevHC_> in ghc: -debug to include debugging symbols (notably for C source)?
21:12:04 <djahandarie> Though it wouldn't be equality.
21:12:50 <punkkk> insertinorder was tricky but fairly obvious once i got it--i suspect removedups is the same
21:13:02 <antgeth> well
21:13:03 <antgeth> haha
21:13:09 <antgeth> everything is fairly obvious once you get it
21:13:47 <antgeth> i can't get the duplicates one without using filter
21:14:11 <punkkk> same
21:15:14 <antgeth> i have resigned myself to turning it in with the function in complete
21:15:18 <antgeth> but if you come up with something
21:15:19 <antgeth> do tell
21:15:21 <antgeth> : )
21:21:54 <JoeyA> When the return value of a callback action is discarded, is it better to use a or () as the return type?
21:22:10 * ddarius prefers a.
21:22:14 <JoeyA> () may be less convenient, but it warns the user that the return value isn't used for anything.
21:22:31 * djahandarie uses Void
21:22:48 <napping> um, a free "a" also indicates to the users that they shouldn't use expect anything interesting to happen to the result
21:23:01 <JoeyA> I certainly do prefer  a  for things that don't return, like error and exit.  It corresponds to the principle of explosion from logic.
21:23:17 <napping> it works the same way if you are taking a callback
21:23:36 <napping> (Arg -> IO a) -> IO Stuff must just use the callback for effect
21:24:22 <JoeyA> ah, true
21:24:41 <dolio> If the a in a positive position works in lieu of false for explosion, then the a in negative position works for unit/triviality/whatever.
21:24:50 <JoeyA> However, if in an application, the user expects that value to be used for something, their compiler won't tell them.
21:24:51 <mauke> nice, there's a Data.Void
21:24:57 <JoeyA> :t forM_
21:24:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
21:25:52 <mauke> hmm, I wonder why it uses 'data' before ghc 7
21:33:47 <yitz> JoeyA: yeah () is traditional, but it causes seemingly unneeded inconvenience sometimes
21:34:03 <yitz> JoeyA: i wonder if there is any reason not to use a
21:34:51 <shapr> srsly, how do I install ghc7 on ubuntu 11.04?
21:35:16 <yitz> e.g. mapM_ :: (a -> m b) -> [a] -> m c
21:36:17 <ddarius> yitz: mapM_ f xs >>= print
21:36:18 <JoeyA> yitz: That case is different.  That would imply mapM_ doesn't return :P
21:36:34 <dalaing> shapr: I did it the other night via http://haskell.org/ghc/download_ghc_7_0_3#binaries
21:36:48 <ddarius> Admittedly that would have a type error.
21:36:50 <yitz> ddarius: yeah true
21:36:54 <ddarius> s/print/putStrLn
21:37:33 <ddarius> yitz: But yeah, to implement that type you'd have to return undefined.
21:37:43 <glguy> yitz: try to write a mapM_ with the type:   (a -> IO b) -> [a] -> IO c
21:37:59 <ddarius> Whereas, mapM_ :: (a -> m b) -> [a] -> m () would simply be the most general type if you wrote mapM_.
21:38:26 * hackagebot monadbi 0.1 - Extract underlying monads from monad transformers  http://hackage.haskell.org/package/monadbi-0.1 (AnupamJain)
21:38:49 <yitz> ddarius: the burden to return undefined would be about the same as the burden to return ()
21:39:12 <ddarius> yitz: I'd rather not explicitly inject undefineds in my program.
21:39:14 <djahandarie> Except it's evil.
21:39:21 <yitz> ddarius: also true
21:39:39 <yitz> altogether it's worse, not better
21:39:43 <djahandarie> mapM_ f xs = unsafeCoerce
21:39:56 <yitz> djahandarie: haha
21:40:07 <glguy> Yeah, it's much better to just write a loop than use undefined ;) keep your haskell program clean
21:40:19 <glguy> mapM_ f x = mapM_ f x
21:40:31 <ddarius> glguy: Eta reduce.
21:40:54 <ivanm> preflex: seen chrisdone
21:40:54 <preflex>  chrisdone was last seen on #haskell 8 hours, 24 minutes and 45 seconds ago, saying: what kind of differences?
21:41:01 <glguy> I can't stand aggressive eta reduction :-p
21:42:02 <scott_hickey> noob question about ghci: is there a way to have numbers with decimal places read as exact numbers/rationals instead of double?
21:42:22 <ddarius> > 1.23435489374598723495273984723985729374324 :: Rational
21:42:23 <mauke> well, you could use type annotations
21:42:23 <lambdabot>   30858872343649680873818496180996432343581 % 2500000000000000000000000000000...
21:42:27 <mauke> like that
21:42:38 <mauke> I don't know if loading a file with a 'default' declaration affects ghci
21:42:59 <scott_hickey> it didn't seem to but i'm brand new to this
21:43:25 <dannynn_> Ive been using list comprehensions to find the fist element in a list that satisfies a certain condition like this - take 1 [x|x<-[1..], x >10].  is there a better way to do this?
21:43:26 * hackagebot dclabel 0.0.1 - The Disjunction Category Label Format.  http://hackage.haskell.org/package/dclabel-0.0.1 (DeianStefan)
21:43:41 <mauke> yeah, looks like it doesn't
21:43:55 <glguy> dannynn_: how about:    find (> 10) [1..]
21:43:57 <scott_hickey> I tried putting default(Integer, Rational) into a file and loading, 1.1 + 0.1 still returned 1.200000002 or
21:44:18 <dannynn_> didnt know about find, thanks :)
21:47:42 <djahandarie> Can someone give me a usage of unsafeCoerce that will segfault ghci?
21:48:28 * hackagebot lio 0.0.1 - Labeled IO library  http://hackage.haskell.org/package/lio-0.0.1 (DeianStefan)
21:49:12 <Jafet> Is that supposed to be difficult?
21:49:23 <Jafet> unsafeCoerce (Just ()) :: String
21:49:35 <mauke> unsafeCoerce 1 2
21:50:01 <mauke> Jafet: "\-1236496139"
21:50:02 <Jafet> Nice
21:50:51 <djahandarie> I guess coercing to functions is a solid way to do it.
21:51:10 <Jafet> Safely unsafe
21:52:44 <ddarius> unsafeCoerce (peek nullPtr) :: IO ()
21:52:50 <mysticc> recommend a library whose source I should read ....?
21:53:07 <ddarius> MFC
21:53:55 <djahandarie> ddarius, hah. :)
21:56:54 <ivanm> @tell chrisdone it seems that haskell-emacs doesn't seem to call hasktags properly; something about not passing proper params: > xargs: hasktags: No such file or directory
21:56:54 <lambdabot> Consider it noted.
21:59:06 <mysticc> can any body show there vim config for haskell :)
22:00:30 <mysticc> >unsafeCoerce (Just ()) :: String
22:08:27 * hackagebot monadfibre 0.1.2 - Monadic functions which provide Choice and Parallelism.  http://hackage.haskell.org/package/monadfibre-0.1.2 (AnupamJain)
22:13:17 <DevHC^> what does the report say about the definition of sort? is sort (or sortBy) defined by exact code, or rough wording?
22:23:31 <ivanm> DevHC^: here's a crazy idea: look it up! :p
22:23:40 <ivanm> but I think it's meant to be a stable sort
22:23:47 <ivanm> with the sample implemntation being a mergesort
22:23:59 <ddarius> The sample implementation is insert sort.
22:24:06 <ivanm> oh, wait, that's right
22:24:13 <ivanm> and GHC uses mergesort for performance
22:27:37 <Jafet> @where prelude
22:27:37 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
22:28:41 <DevHC^> @src sortBy
22:28:41 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
22:28:45 <yitz> DevHC^: no implementation, only that it should be stable.
22:28:57 <DevHC^> sortBy (\a b -> if (a `mod` b) < (b `div` 2) then GT else EQ) [2,4,2,1,2,5,3]
22:29:00 <DevHC^> > sortBy (\a b -> if (a `mod` b) < (b `div` 2) then GT else EQ) [2,4,2,1,2,5,3]
22:29:01 <lambdabot>   [2,2,2,4,5,1,3]
22:29:23 <DevHC^> so the function is not well-defined
22:32:11 <yitz> DevHC^: if you use a comparison function which does not even define a partial ordering, then indeed the results are not well defined.
22:34:31 <django> If I want to define a cube in haskell within a module, and define a function say scale :: Cube -> Cube
22:35:00 <django> define a function say scale :: (Point -> Cube) -> Cube
22:35:14 <django> What is the most idiomatic way to define Cube?
22:36:24 <yitz> django: scale :: Cube -> Cube makes sense. I don't understand scale :: (Point -> Cube) -> Cube
22:36:27 <mauke> what's a Cube?
22:37:47 <django> yitz: Given some cube and some x,y,z return a cube scaled to that size, is what I am trying to do.
22:38:05 <django> mauke: That is what I am trying to decide a list of 8 points?
22:38:29 <mauke> django: why not type Cube = ()?
22:39:00 <c_wraith> You can describe all cubes with a point and a vector...  In a lot of non-unique ways.
22:39:01 <mauke> django: and that sounds more like scale :: Point -> (Cube -> Cube)
22:39:34 <c_wraith> Err.  guess you need two vectors.
22:39:40 <c_wraith> but only the length of one matters.
22:41:00 <c_wraith> that's annoying.  And makes me wonder if there's a better representation possible.
22:41:09 <BlankVerse> http://paste.pocoo.org/show/480371/
22:41:18 <BlankVerse> error during cabal install chart
22:42:04 <c_wraith> BlankVerse: well.  did you make sure that gtk2hs-buildtools is in your path, like it said to do?
22:42:06 <mauke> BlankVerse: and?
22:42:26 <c_wraith> BlankVerse: that output isn't garbage.  it's telling you exactly what the problem is.
22:43:39 <django> Actually I supose I should just define a cube as a vertex buffer.
22:44:58 <yitz> a cube can be defined as an amount of water and a temperature < 0 C.
22:46:34 <yitz> django: mauke is right. we need to know what you are doing with these cubes. are they part of some mathematical calculation? are they graphical objects that you want to render? what properties do they have?
22:47:44 <fizruk> @pl (\x f -> f x x)
22:47:44 <lambdabot> flip =<< flip id
22:48:57 <fizruk> @pl (\f g e -> f e (g e))
22:48:58 <lambdabot> ap
22:49:11 <fizruk> :t ap
22:49:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:50:10 <fizruk> @ (\f g e -> f e (g e)) :: Functor f => f (a -> b) -> f a -> f b
22:50:18 <fizruk> @pl (\f g e -> f e (g e)) :: Functor f => f (a -> b) -> f a -> f b
22:50:18 <lambdabot> (line 1, column 44):
22:50:18 <lambdabot> unexpected ">"
22:50:18 <lambdabot> expecting variable, "(", operator or ")"
22:50:38 <fizruk> @pl ((\f g e -> f e (g e)) :: (Functor f) => f (a -> b) -> f a -> f b)
22:50:38 <lambdabot> (line 1, column 47):
22:50:38 <lambdabot> unexpected ">"
22:50:38 <lambdabot> expecting variable, "(", operator or ")"
22:51:01 <yitz> fizruk: @pl doesn't understand type annotations
22:51:17 <Jafet> When you're golfing, you do everything to avoid type annotations
22:51:44 <fizruk> yitz: i see)
22:51:49 <mauke> :t (\f g e -> f e (g e)) :: Functor f => f (a -> b) -> f a -> f b
22:51:50 <lambdabot>     Couldn't match expected type `(->) t' against inferred type `f'
22:51:51 <lambdabot>       `f' is a rigid type variable bound by
22:51:51 <lambdabot>           an expression type signature at <interactive>:1:33
22:51:54 <yitz> Jafet: @pl is not always a good tool for golfing
22:51:57 <mauke> fizruk: that type is incorrect anyway
22:52:20 <Jafet> Well, it helps up to a point
22:52:30 <yitz> @pl \f x y z w -> f w x y z
22:52:31 <lambdabot> (((flip .) . flip) .) . flip
22:52:33 <fizruk> mauke: oh, it is :)
22:52:55 <Jafet> That point probably being when you learn all the instances of Applicative and Monoid
22:52:56 <yitz> @pl \f x y z w -> f w z y x
22:52:56 <lambdabot> flip . ((flip . (flip .)) .) . flip . (flip .) . flip
22:53:07 <mauke> :t (<*>)
22:53:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:54:12 <yitz> @pl \f a b c d e g h -> f h g e d c b a
22:54:14 <lambdabot> flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .)
22:54:14 <lambdabot>  . flip . (flip .) . flip
22:54:25 <fizruk> :t (<*>) :: e -> (a -> b) -> (e -> a) -> e -> b
22:54:26 <lambdabot>     Occurs check: cannot construct the infinite type:
22:54:26 <lambdabot>       e = a -> b -> e -> b
22:54:26 <lambdabot>     In the expression: (<*>) :: e -> (a -> b) -> (e -> a) -> e -> b
22:54:43 <mauke> flipping will continue until morale improves
22:54:49 <fizruk> :t (<*>) :: (e -> (a -> b)) -> (e -> a) -> e -> b
22:54:50 <lambdabot> forall e a b. (e -> a -> b) -> (e -> a) -> e -> b
22:55:04 <yitz> mauke: sometimes @pl flips out
22:55:28 <Axman6> flup!
23:32:15 * hackagebot NestedSampling 0.1.4 - A port of John Skilling's nested sampling C code to Haskell.  http://hackage.haskell.org/package/NestedSampling-0.1.4 (IssacTrotts)
23:35:09 <Blkt> good morning everyone
23:38:10 * ddarius may have a use for this nested sampling code.
23:39:54 <copumpkin> looks neat
23:40:02 <copumpkin> although it's a straightforward translation of an imperative loop
23:40:05 <copumpkin> with IORefs and all
23:41:00 <ddarius> Well it's more the algorithm I have use for than the code.
23:41:12 <ddarius> And even then I'm not sure of that.
23:45:46 <frozendevil> Has anyone gotten GHC compiling to an iPhone recently?
23:48:01 <ivanm> when using the enumerator library, how do you actually get data in?
23:48:11 <ivanm> an explicit "Chunks foo" ?
23:49:26 <ivanm> it doesn't help when the yesod website is down...
23:49:42 <yitz> ivanm: you read them from a file or a handle?
23:49:56 <ivanm> yitz: no, I'm wanting to use it to write data
23:50:03 <ivanm> to see how it compares to lazy I/O
23:57:51 <yitz> ivanm: yeah, it looks like if you have static data you can just wrap it in Chunks, use yield to make that an Iteratee, then feed it to the Enumerator.
23:58:07 <ivanm> ta
23:58:18 * ivanm tries to work out how to squash all this stuff together
