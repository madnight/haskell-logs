00:00:16 <ddarius> "The ultimate goal is to fire the gun at 64 megajoules, making it capable of sending a bullet 200 miles in six minutes. That’s 10 times farther than the Navy’s already-powerful guns can fire, keeping its ships far out of range of enemy anti-ship systems."
00:00:53 <shachaf> copumpkin: You're all talk and he's all code?
00:01:01 <copumpkin> yep
00:02:42 <copumpkin> implement http://www.cake23.de/traveling-wavefronts-lit-up.html in haskell
00:04:15 * ddarius doesn't have WebGL.
00:04:52 <shachaf> Get with the times, ddarius.
00:05:44 <copumpkin> ddarius: it's quite pretty
00:06:54 <ddarius> copumpkin: I have a pretty good idea what it roughly looks like.
00:07:09 <kmc> WebGL sounds great!  i'm sure happy to expose the entire Linux DRI subsystem, my vendor's closed-source drivers, and an incredibly complex DMA-capable PCI device as remotely-accessible ring 0 attack surface!!
00:07:33 <copumpkin> kmc be hatin
00:07:48 <kmc> the linux DRM code is the worst code
00:08:18 --- mode: ChanServ set +o mauke
00:08:19 --- kick: turtlesalltheway was kicked by mauke (turtlesalltheway)
00:08:31 <kmc> it is my least favorite kernel subsystem
00:08:55 <ddarius> All the kernel subsystems are like children to kmc.
00:09:09 --- mode: mauke set -o mauke
00:20:13 --- mode: ChanServ set +o mauke
00:20:13 --- mode: mauke set +b $a:frendshipismagic
00:21:03 --- mode: mauke set -o mauke
00:23:36 <aerholt> ,13,22]
00:23:42 <aerholt> oops!
00:23:45 <aerholt> hi everyone :)
00:27:39 <ddarius> > map ord "hi"
00:27:40 <lambdabot>   [104,105]
00:48:12 --- mode: ChanServ set +o mauke
00:48:12 --- mode: mauke set -q $a:frendshipismagic
00:49:02 --- mode: mauke set -o mauke
00:53:09 <squidz> hi everybody. Should I learn haskell as my scripting language? I am a java programmer and want something I can develop quickly in. Also want it to be a functional language. I'm not sure which language I should commit to, either haskell or clojure. Clojure has all the java libraries that i'm used to, but the elagance and culture/philosophy seems to interest me more with clojure. Is that enough to ignore my jvm advantages with clojure?
00:53:44 <Jafet> Yeah, you should try clojure
00:55:08 <squidz> damn I was hoping to be pursuaded from what I already suspected, but it's better to have honest input
00:55:25 <ehamberg> what about scala?
00:56:33 <squidz> what would be the main differences between clojure and scala?
00:56:50 <mm_freak> squidz: if you want a somewhat powerful type system and still the java libraries, give scala a shot
00:57:28 <mm_freak> if you don't absolutely need java libraries, you may also try haskell, but prepare for a steep learning curve
00:57:45 <squidz> for some reason or another I thought clojure would be better than scala, but is that not the opinion here?
00:58:22 <companion_cube> scala is statically typed, which is cool
00:58:58 <kmc> clojure tries harder to push functional style
00:59:08 <kmc> clojure lets you call Java the same way haskell lets you call C
00:59:19 <kmc> in scala the java concepts are actually first class citizens
00:59:29 <companion_cube> like, classes ?
00:59:32 <kmc> the idea is that java programmers can start writing java-in-scala on day one, and gradually learn fp
00:59:34 <squidz> hm not sure if i like that
00:59:54 <squidz> but as long as it doesnt restrict things
01:00:00 <kmc> yeah, it makes scala quite the kitchen-sink language
01:00:11 <kmc> because it has to reconcile Java and ML type systems and more
01:00:42 <kmc> i think you should learn Haskell because it's cool
01:00:47 <kmc> but don't expect it to be a practical tool right away
01:00:53 <kmc> it takes a lot of patience to get there
01:01:05 <kmc> learn clojure too; they're both interesting languages
01:01:14 <kmc> clojure definitely has things haskell doesn't, and vice versa
01:01:21 <copumpkin> even scala is interesting in some ways
01:01:31 <squidz> alright. Do yall know if it scala treats code as data
01:01:42 <kmc> not in the direct way Clojure and other lisps do
01:01:55 <kmc> but any language can be used to manipulate code in any language
01:02:05 <kmc> it's more a question of how annoying it is
01:02:10 <squidz> yeah
01:02:19 <kmc> Facebook uses Haskell code to automate refactoring their PHP code
01:02:27 <b_jonas> but I _don't_ want to directly manupulate code
01:02:53 <b_jonas> doing that just leads to ugliness usually
01:03:13 <Saizan> "but i do not want functional programming!"
01:03:25 <kmc> haha
01:04:00 <b_jonas> hey, I do want functional programming and first-class functions
01:04:05 <b_jonas> but not manipulating code more than that
01:04:11 <b_jonas> sometimes I don't even want first-class functions
01:04:12 <kmc> b_jonas, sure, but sometimes macros are the least ugly solution
01:04:25 <kmc> people use them in C and Haskell even though they're super ugly
01:04:26 <squidz> out of clojure and scala which do you think is more practical and which do you think has more theoretical potential
01:04:28 <Saizan> @quote rules.of.go
01:04:29 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
01:04:39 <squidz> dont ask what I mean by theoretical potential cause I'm not really sure
01:04:43 <kmc> squidz, not really on-topic here
01:05:43 <Jafet> You can program in Go?
01:05:54 <kmc> Jafet, Go on an infinite board is PSPACE-complete
01:05:58 <squidz> also consider that
01:06:53 <b_jonas> is that proven?
01:07:01 <squidz> but I think I am more of a functional thinker
01:07:07 <kmc> b_jonas, yeah
01:07:13 <b_jonas> fun
01:07:19 <kmc> it's in _Computational Complexity_ by Papadimitriou
01:07:38 <kmc> probably in some paper, possibly named "Go is PSPACE-complete"
01:07:44 <kmc> that's how they name things
01:07:56 <Jafet> It makes bibtex easier
01:08:16 <companion_cube> is clojure still hype?
01:08:21 <kmc> sigh
01:08:36 <b_jonas> reminds me to the discussion on mathoverflow on how chess on an infinite board (with finite number of pieces) might even be uncomputable
01:08:48 <b_jonas> which is crazy
01:08:57 <kmc> companion_cube, are you really expecting a useful conversation to follow from such a question?
01:09:03 <Jafet> Just encode a program into a starting position.
01:09:08 <companion_cube> kmc: nope :)
01:09:33 <companion_cube> i'm just curious of how the perception of programming languages evolved
01:09:37 <companion_cube> evolves*
01:10:28 <kmc> i think you can measure hype pretty objectively by counting reddit articles or something
01:10:44 <b_jonas> companion_cube: the high level programming language of today is the low level language of tomorrow
01:10:57 <kmc> i gave up on reddit a while back but last i checked they were obsessed with javascript as the new hot language
01:11:02 <b_jonas> because CS people try to solve everything by adding a layer of abstraction
01:11:04 <kmc> probably have moved on to something new
01:11:16 <b_jonas> think haskell is too simple? cue to template haskell!
01:11:34 <kmc> yeah, TH is about 10 times as hard to write per line of code
01:11:40 <kmc> though i've not had much practice
01:11:47 <b_jonas> think you understand C++ templates? cue to variadic templates and relaxed rules for templates!
01:11:55 <companion_cube> :D
01:12:00 <kmc> maybe if i wrote 250 lines of TH then it would only be 4x as hard
01:12:27 <kmc> but i think i could have a happy life while writing less than 250 lines of TH total
01:13:31 <Saizan> macro systems where you have to be aware of the generated code don't exactly feel like layers of abstraction to me
01:14:17 <Jafet> Layers of distraction
01:14:45 * hackagebot digest 0.0.1.0 - Various cryptographic hashes for bytestrings; CRC32 and Adler32 for now.  http://hackage.haskell.org/package/digest-0.0.1.0 (EugeneKirpichov)
01:15:19 <b_jonas> Saizan: but they give great opportunities for obfuscations!
01:15:40 <b_jonas> what? crc32 and adler32 are not cryptographic hashes!
01:16:07 <b_jonas> they're breakable hashes used to check data integrity against errors, not against malicious tampering.
01:17:52 <moroten> what could be wrong with my "if" on line 24-26. i can not get it to compile: http://hpaste.org/50972
01:18:30 <Botje> your if should start at or after the putStrLn on the line aboe
01:20:15 <moroten> Botje: thanks
01:20:43 * frerich wonders if ezyang does the nice drawings on the blog himself
01:21:56 <moroten> something is still wrong with my code as i get a bunch of:
01:21:58 <moroten>     No instance for (Random (IO Int))
01:21:58 <moroten>       arising from a use of `randomRIO'
01:21:58 <moroten>     Possible fix: add an instance declaration for (Random (IO Int))
01:23:24 <Botje> you cannot pass promptForInt directly to compare
01:23:45 <moroten> how should it be done?
01:23:57 <shachaf> Get an Int, pass that Int to compare.
01:23:57 <Botje> guess <- promptForInt
01:24:02 <Botje> compare guess number ...
01:27:18 <moroten> Botje: thanks again
01:32:56 <moroten> Botje: could you tell me why the prompt is displayed after i have been typing in the integer?
01:33:06 <moroten> this is the new paste: http://hpaste.org/50973
01:33:15 <shachaf> moroten: It might have to do with buffering.
01:33:29 <shachaf> Try hFlush stdout or hSetBuffer stdout NoBuffering
01:37:51 <moroten> shachaf: thanks, that it was
01:40:54 <Saizan> maybe we should add a prompt :: String -> IO String which does the hFlush'ing to the stdlib
01:42:23 <moroten> thank you all that helped me. now i have my first haskell program working. here is the working source: http://hpaste.org/50974 . if there is anything that i could have been doing better, please tell so i can improve!
01:45:12 <Botje> you could factor the 'game over' logic into guessTheNumber
01:45:18 <Botje> instead of duplicating it
01:45:39 <skogh4836> i lost
01:47:51 <moroten> Botje: please, explain how :)
01:49:06 <Botje> guessTheNumber number 0 = putStrLn "game over"
01:49:14 <Botje> guesStheNumber number tries = (as before)
01:49:26 <moroten> ah, thanks
01:50:12 <b_jonas> also, maybe tell the player that he has four guesses.
01:51:50 <Botje> also, you should put in a bias for 7 ;)
01:52:37 <b_jonas> Botje: doesn't randomRIO do that for you?
01:53:30 <Botje> randomRIO will try to give you a uniform distribution
01:55:05 <moroten> guess <- promptForInt "\nYou have"++show(tries)++"guesses left. Your guess:"
01:55:24 <moroten> that is not working... should not show make a string out of a number?
01:55:35 <b_jonas> moroten: you need more parenthesis in taht
01:56:35 <Botje> moroten: ++ has a very low precedence
01:56:53 <Botje> it parses as (promptForInt ...) ++ show tries ++ "guesses..."
01:57:10 <Botje> whereas you want promptForInt (... ++ show tries ++ ...)
01:57:24 <shachaf> Botje: It's more that application has a very high precedence. :-)
01:57:54 <Botje> heh, that also works ;p
02:04:22 <moroten> hmm, why is this not working:
02:04:24 <moroten>  25         if tries > 1
02:04:24 <moroten>  26                 then guess <- promptForInt ("\nYou have "++(show tries)++" guesses left. Your guess:")
02:04:27 <moroten>  27                 else guess <- promptForInt "\nYou have 1 guess left. Your guess:"
02:05:38 <Cale> moroten: You have <- outside of do syntax
02:06:03 <moroten> if i put a do there it is also complaining
02:06:25 <Cale> It'll probably complain that the last line of a do-block must be a simple statement
02:06:27 <Cale> yeah?
02:06:34 <moroten> it is saying "The last statement in a 'do' construct must be an expression"
02:06:37 <Cale> yes
02:07:40 <Cale> So in each case here, you're naming the result of promptForInt 'guess', but then what do you want to do with that guess?
02:08:31 <moroten> Cale: it is line 24 rewritten: http://hpaste.org/50974
02:09:07 <Cale> You probably want   guess <- if tries > 1 then ... else ...
02:10:51 <moroten> Cale: thanks, that it is!
02:12:45 <xrl> any prewritten libs which will calculate expected val, variance for a list?
02:12:57 <xrl> *prewritten, aka, existing ;)
02:13:31 <Saizan> maybe the "statistics" package
02:13:39 <moroten> okay, here is my new improved version: http://hpaste.org/50977 anything else that could be done better?
02:13:47 <Eduard_Munteanu> hmatrix might also have it
02:14:32 <Eduard_Munteanu> Google finds this... http://hackage.haskell.org/packages/archive/hmatrix-gsl-stats/0.1.2.10/doc/html/Numeric-GSL-Statistics.html
02:15:04 <xrl> ah, i guess I should look in to using vectors
02:15:20 <xrl> although my lists always have < 10 items
02:25:10 <frerich> moroten: I'd try to move more code out of the 'IO' functions
02:32:36 <Saizan> for something this small it might not be worth it, though it might be a useful exercise
02:34:17 * ddarius wants to recast the Regge calculus.
02:36:46 <ddarius> Luca Cardelli is getting older...
02:37:07 <moroten> frerich: any suggestion on how i could do it?
02:40:50 <frerich> moroten: For instance, you show a different prompt depending on the number of tries left. This construction of the prompt could be moved into a separate (pure!) function like 'prompt :: Int -> String'. Same for the hint string which is printed.
02:45:54 <ddarius> Tarski was a trig cookie.
02:48:58 <moroten> without intending to start an editor war, what editor do you consider best for haskell (especially when it is about handling indentation)?
02:49:52 <moroten> i am normally using vim, myself. but without extra configuration it is pretty poor at doing indentation. if you have any good suggestion for configuring vim, i am thankful
02:50:09 <ddarius> There are haskell modes for vim.
02:50:17 <ddarius> The best editor is the one you're familiar with.
02:50:29 <ddarius> If you want, you can look at an IDE like Leksah or EclipseFP.
02:50:53 <mauke> in Haskell indentation is semantically active instead of being derived from the structure of the code
02:50:55 <ddarius> Most people in the Haskell community seem to use either emacs or vim.
02:50:57 <moroten> it needs to be a TUI editor as i am doing everything over ssh (from ramdom computes without X)
02:51:02 <mauke> so I'm not sure how much you can automate this
02:51:06 * balta2ar personally uses emacs-haskell-mode and he is quite happy with it. There are two modes of indentation.
02:52:27 <shachaf> mauke: More than Notepad.
02:52:33 <mauke> of course
02:52:39 <mauke> notepad doesn't count
02:52:49 <shachaf> Fine, more than EDIT.COM.
02:53:31 <mauke> notepad isn't an editor, it's a thin executable wrapper around a text field widget
02:53:48 <ddarius> There are some fancy text fields out there.
02:53:49 <gienah> http://projects.haskell.org/haskellmode-vim
02:54:30 <gienah> http://www.vim.org/scripts/script.php?script_id=1968
02:56:40 <b_jonas> EDIT.COM is nice, because it has undocumented wordstar-like key bindings
02:57:27 <ddarius> edit.com has a -lot- of features that aren't obvious at first.
02:58:28 <dave1231> the countdown to ed is on...
02:58:42 <b_jonas> dave1231: edlin first
02:58:48 <b_jonas> which is like a dumbed down ed
02:58:55 <shachaf> ddarius: Oh?
02:58:56 <b_jonas> you'd think you can't dumb down ed further
02:58:57 <b_jonas> but you can
02:59:02 * shachaf doesn't have a copy handy to try out.
02:59:06 <ddarius> b_jonas: cat
02:59:10 <dave1231> so dd after that?
02:59:22 <shachaf> cat without shell redirection is useless.
03:00:04 <Ke> I sometimes use cat to read text files
03:00:27 <ddarius> From one perspective, cat should -only- allow shell redirection.
03:00:44 <Ke> how come?
03:00:54 <ddarius> Admittedly, that would superficially defeat its namesake purpose.
03:01:10 <b_jonas> ddarius: no no, cat -a to terminal is useful
03:01:55 <shachaf> b_jonas: I believe Ken Thompson wrote a paper about that.
03:02:01 <shachaf> Or someone. Or something.
03:02:24 <shachaf> Oh, it was Rob Pike, and it was a presentation. And it was -v.
03:02:36 <b_jonas> same thing
03:02:43 <b_jonas> I see
03:03:24 <shachaf> ddarius: Is that the perspective that says "all UNIX utilities should be functions :: String -> String given to interact"?
03:03:25 <ddarius> Ke: cat is given far more authority than it actually needs and that is due to the fact that it is given file names.  Redirection means cat only needs the capability to read stdin and write stdout.
03:03:31 <ddarius> shachaf: No.
03:03:53 <shachaf> Ah, authority.
03:05:48 <b_jonas> ddarius: that's because it was invented at the dawn of unix, before you could write '(cat foo; cat bar) | someprogram' in your shell
03:06:11 <ddarius> b_jonas: It doesn't have much to do with when it was written.
03:06:16 <b_jonas> well maybe you could write it as 'sh -c "cat foo; cat bar" | someprogram' but that's awkward
03:06:33 <b_jonas> so you need arguments to concatenate multiple files
03:06:56 <ddarius> b_jonas: Indeed, but nothing stops the shell from passing handles to cat rather than strings.
03:07:20 <b_jonas> heh
03:07:58 <b_jonas> but old shells also couldn't do that I think
03:08:52 <mauke> { cat <foo; cat <bar; } | baz
03:09:03 <ddarius> b_jonas: They couldn't do it because their designers weren't even trying to do it.
03:09:24 <int-e> mauke: ow. cat foo bar
03:09:24 <b_jonas> true
03:09:44 <shachaf> int-e: See previous discussion.
03:10:25 <int-e> right. still, ow :)
03:10:26 <b_jonas> though DOS1 comes close, with the shell passing pre-filled with structures the program just has to pass to the open syscall when you use filenames as arguments
03:10:31 * shachaf tries to remember the difference between {} and () for the shell.
03:10:36 <DasIch> what do I use to parse html? i've found tagsoup which is supposed to be a parser but it doesn't even create a tree nor allows me to extract data using xpath, css selectors or something similar
03:10:44 <int-e> () spawns a subshell.
03:10:56 <shachaf> {} doesn't?
03:11:05 <ddarius> DasIch: tagsoup is for tag soup.  I.e. broken HTML that can't be put into a tree structure.
03:11:16 <b_jonas> that is, of course, an optimization: it's easier if the shell does that once than if every program has to reimplement it
03:11:22 <ddarius> DasIch: I imagine there are a lot of packages on hackage with "html" in their names.
03:11:42 <mauke> ddarius: that sounds wrong
03:11:52 <DasIch> ddarius, a lot of html is invalid
03:12:02 <mauke> all html can be put into a tree structure
03:12:08 <shachaf> mauke's value of "a lot" is influenced by CPAN.
03:12:19 <shachaf> mauke: Not necessarily!
03:12:32 <DasIch> ddarius, it is very rare that you can't create any tree structure from it
03:12:32 <ddarius> DasIch: Yes.  Do you want to deal with invalid HTML or not?
03:12:42 <DasIch> ddarius, possibly
03:13:01 <shachaf> <b>A<s>B</b>C</s> probably exists somewhere.
03:13:19 <ddarius> shachaf: It surely exists all over the place.
03:13:30 <ddarius> mauke: Broken HTML is not HTML.
03:13:44 <DasIch> ddarius, that is a rather impractical view
03:14:19 <benmachine> tagsoup can also parse fragments and so forth
03:14:22 <mauke> DasIch: there seem to be several modules to make trees from tagsoup
03:14:42 <mauke> like hexpat-tagsoup
03:15:02 <ddarius> Personally, I'm of the view that if you don't -have- to support broken input formats, then you shouldn't.  Being strict on output, but lax on input was a mistake; the mistake that got us into this mess.
03:16:36 <ddarius> It would've worked if everyone followed, but then we wouldn't need to be lax on input.
03:18:33 <benmachine> being lax on output was the mistake :P
03:18:48 <benmachine> which I guess being lax on input perpetuated
03:19:26 <ddarius> benmachine: It's a strange thing that virtually all programs used are syntactically correct.
03:19:45 <int-e> shachaf: {} doesn't unless it has to -- for piping a | b, the shell has to spawn subprocesses for a and b anyway, so {} | ... and () | ... are indistinguishable as far as I can make out.
03:19:58 <shachaf> Ah.
03:20:31 * shachaf for a moment thought that int-e was restoring the earlier discussion of record updates.
03:20:42 <int-e> shachaf: but a=1; { a=2; }; echo $a  will echo 2, while the same with () will print 1.
03:21:14 <shachaf> Ugh.
03:21:18 <int-e> Sorry. Unix is more interesting than Haskell. Ok, I'm kidding.
03:21:32 <shachaf> a=1; { a=2; } | cat; echo $a; will print 1
03:21:34 <ddarius> int-e: I think you are missing a word or three in your first statement.
03:21:53 <shachaf> So much for treating |cat as an identity.
03:21:57 <ddarius> Maybe not.
03:23:20 <mux> int-e: actually, both will print 1
03:23:29 <mux> also, { } is supposed to never fork a subshell
03:23:49 <mux> not just sometimes
03:24:15 <int-e> yes. but | always forks so you have lost already when you pipe stuff.
03:24:24 <int-e> however,  a=1; { a=2; }; echo $a
03:24:27 <int-e> does print 1.
03:24:28 <mux> | does not fork
03:24:32 <int-e> sorry. 2.
03:24:33 <mux> running a command will fork
03:24:39 <mux> but that's not pipe per se
03:24:50 <mux> int-e: no it does not; try it
03:25:11 <int-e> mux: I did try it. dash and bash agree and print 2.
03:25:22 <shachaf> ashachaf@argon:~$ a=1; { a=2; }; echo $a
03:25:22 <shachaf> 2
03:25:25 <mux> bash is known not to follow standard properly
03:25:30 <shachaf> Ah, bash.
03:25:42 <int-e> hence I tried dash, which is supposedly conforming to posix
03:25:45 <mux> FreeBSD's /bin/sh will print 1 - and I trut it a million times more than bash on these points.
03:25:50 <mux> trust*
03:26:52 <mux> coming back on |, it doesn't fork anything by itself, it'll just cause the shell to run dup2() after the fork() and before the execve() to clone stdout/stderr/stdin depending on the case
03:40:03 <ddarius> Damn parallel "dimensions."
03:54:00 <erus`> anyone know of a dictionary that has syllables?
03:54:57 <dankna> for programmatic or human use?
03:55:01 <Eduard_Munteanu> I think LaTeX uses babel for hyphenation, so it might be worth investigating that.
03:55:03 <dankna> and what do you need it for precisely?
03:55:06 <erus`> programmatic use
03:55:20 <erus`> to lookup the number of syllables in a word
03:55:23 <dankna> you might look into this project -- http://icon.shef.ac.uk/Moby/
03:55:32 <dankna> but you'll have to, at a minimum, write a parser for its line-based format
03:56:50 <ClaudiusMaximus> i think cmudict has phonemes
03:57:08 <ddarius> This article is fairly interesting, not really on topic: http://plato.stanford.edu/entries/geometry-finitism/
03:57:47 <ClaudiusMaximus> gives output like "F AH1 NG K SH AH0 N AH0 L . P R OW1 G R AE2 M IH0 NG"
03:58:10 <dankna> cmudict does, yes, but it's a smaller dictionary than moby, and included in it
03:58:20 <ClaudiusMaximus> ooh, ok
03:59:41 <erus`> cmudict has still like AO T = ought
03:59:51 <erus`> how can i count syllables with that
04:00:51 <dankna> yeah, you can't quite
04:01:02 <dankna> Moby is better
04:01:29 <ddarius> That phoneme output makes me think of stenography.
04:02:04 <dankna> heh, I once was going to make a lossy compressor for text, for didactic purposes
04:02:07 <dankna> never finished it though
04:02:38 <dankna> it was going to canonicalize words to their simplest forms, and choose more-common synonyms for unusual ones
04:02:49 <erus`> apparently i can match against this V CV VC CVC CCV CCCV CVCC where C is constenant and V is vowel
04:03:07 <erus`> consonant *
04:03:11 <dankna> moby actually has separators for syllables
04:03:28 <dankna> and information on which syllable is emphasized, which if you're doing some sort of computational poetry thing might be useful to you
04:04:20 <erus`> im making a rap bot
04:04:25 <dankna> I see
04:05:07 <erus`> i want to write a haskell rap
04:05:13 <dankna> hah, cool
04:05:54 <dankna> cf. http://userpages.monmouth.com/~colonel/writings/banana.html for relevant humor
04:06:39 <dankna> (I would like to have a macro that would recite that poem to a troll before kicking him :D)
04:06:43 <erus`> 'Are out of date; therefore, Banana Nose,'
04:06:47 <dankna> (but it would spam the channel unnecessarily)
04:07:00 <dankna> Thy logic, like they locks, is disarray'd
04:07:05 <dankna> *thy
04:08:43 <dankna> of course this is a fake, but hey
04:09:39 <erus`> absinth is one syllable apparently :|
04:09:51 <dankna> according to Moby?
04:09:52 <dankna> hm
04:09:54 <dankna> that should be two
04:09:56 <erus`> yup
04:10:11 <dankna> well, it's a nontrivial problem :/
04:10:15 <erus`> in the hyphenated dict
04:10:29 <dankna> perhaps you can take the phonetic and wikipedia's list of the possible spellings of each phoneme in English
04:10:31 <dankna> and correlate
04:10:37 <dankna> wait, no, you don't need to do that
04:10:48 <erus`> the rest look ok
04:10:50 <dankna> match the patterns you were saying before, but against phonemes, not against the spelling
04:10:59 <dankna> or include a special-case for that word, heh
04:11:12 <erus`> i can get the relationship between words by watching this channel
04:11:14 <dankna> but if it's got one error I guarantee you it's got others
04:11:15 <dankna> okay
04:11:23 <dankna> The gostak distims the dulches?
04:11:46 <erus`> then my rap will have a truly haskell feel to it also
04:11:51 <dankna> nodnod
04:12:00 <ClaudiusMaximus> burrito, yo
04:14:44 <ARRG> Hi
04:15:20 <Axman6> 'lo
04:18:02 <ARRG> I've just started learning Haskell after having played with Scala for a while and I have difficulties with the syntax when chaining operations
04:18:03 <Eduard_Munteanu> 'Fi
04:18:38 <Eduard_Munteanu> Do you mean function composition?
04:18:46 <ARRG> Yeah, for example :
04:19:20 <ARRG> I have a function collatz :: (Integral a) => a -> [a], and would like to do something like "map (takeWhile (>1) collatz) [1..100]"
04:19:28 <ARRG> But can't figure out exactly how to write that out
04:19:56 <hpc> :t takeWhile -- ARRG
04:20:04 <hpc> crap
04:20:12 <azaq23> map (takeWhile (> 1) . collatz) [1 .. 100]
04:20:18 <hpc> well, that
04:20:20 <Eduard_Munteanu> > (map (+1) . map (*2)) [1..5]
04:20:36 <hpc> takeWhile :: predicate -> list -> list
04:20:42 <azaq23> . is function composition, (.) :: (a -> b) -> (b -> c) -> (a -> c)
04:20:46 <hpc> collatz :: thing -> list
04:20:51 <ARRG> huh... okay, phew
04:20:55 <hpc> follow the types ;)
04:21:04 <erus`> @hoogle (a -> M b) -> [a] -> [b]
04:21:05 <ARRG> Turns out the tutorial I'm following hadn't adressed "." yet
04:21:19 <Eduard_Munteanu> What tutorial is that?
04:21:27 <ARRG> http://learnyouahaskell.com/
04:21:34 <Axman6> Eduard_Munteanu: not M [b]?
04:21:37 <Eduard_Munteanu> Ah. That's usually recommended in here.
04:21:38 <Axman6> uh, erus`
04:21:41 <Axman6> :t mapM
04:21:46 <engla> it's a good tutorial
04:21:48 <erus`> where is lambdabot?
04:21:55 <azaq23> And remember that every haskell function is binary, so, if f takes two arguments, it actually only takes one to produce another (closured over) function which takes the other argument - so f . g = f
04:21:55 <azaq23> (g x) is always true, but if f takes more than one parameter, you're only composing on the first parameter
04:21:56 <Axman6> lambdabot! :'(
04:22:02 <Axman6> preflex: type mapM
04:22:09 <Axman6> you suck preflex
04:22:22 <Axman6> Cale: where's lambdabot?
04:22:38 <azaq23> Axman6: It died a few minutes ago, ping timeout
04:22:39 <ARRG> I guess it'll become clear once I reach the part about composition then
04:22:47 <ARRG> Thanks guys
04:23:04 <Eduard_Munteanu> There isn't much to it, really.
04:23:08 <Axman6> (f . g) x = f (g x)
04:23:27 <hpc> :t takeWhile (> 1)
04:23:33 <lambdabot> forall a. (Num a, Ord a) => [a] -> [a]
04:23:39 <Axman6> :t mapM
04:23:46 <Axman6> lambdabot!
04:23:46 <Eduard_Munteanu> Some also write   f . g $ x   instead of    (f . g) x
04:23:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:23:57 <Eduard_Munteanu> @botsnack
04:23:58 <Axman6> erus`: try that
04:24:05 <lambdabot> :)
04:24:12 <ARRG> Yeah it's mostly that coming from Scala (in which most function calls are actually method calls, and thus infix) things are a bit confusing at first
04:24:44 <hpc> f . g . h ... $ x is generally called compositional style
04:25:53 <Axman6> azaq23: yeah, you'll have to be become untainted
04:25:57 <Axman6> uh, ARRG
04:28:33 <Saizan> azaq23: you meant every haskell function is unary?
04:28:35 <dankna> who was it who convinced me last night to use STM
04:28:38 <dankna> it doesn't solve my problem
04:29:02 <azaq23> Saizan: Uh, yes
04:29:08 <zmv> Saizan: yes.
04:29:11 <zmv> oh lag.
04:29:23 <Cale> dankna: What is your problem?
04:29:36 <Eduard_Munteanu> Maybe kmc? I usually see him excited about STM.
04:29:40 <dankna> Cale: well, I failed last night to state it concisely; here's the example I gave
04:29:46 <dankna> yes, that might have been who it was :)
04:30:10 <dankna> I had been using MVars for this, but they didn't work - I feel like I need a slightly higher-level abstraction that provides reentrancy in the sense I'm about to show an example of
04:30:23 <dankna> probably implementable in terms of them if I could figure out what semantics it needs to have
04:30:38 <dankna> so I've got a record with a lot of MVars in it, right
04:30:49 <Cale> okay
04:30:49 <dankna> and I've got utility functions that do things such as look up the contents of some of those MVars
04:31:02 <Cale> (why not a single MVar with the whole record?)
04:31:03 <dankna> and I've got higher-level functions that do larger actions
04:31:29 <dankna> (because this actually does need to run concurrently and that would result in "locking" larger chunks than necessary)
04:31:36 <Cale> okay
04:31:49 <dankna> what I would like is for my higher-level functions to be able to call my utility functions
04:32:03 <dankna> instead, I wind up having to essentially flatten the flow control, duplicating the utility functions into the higher-level ones
04:32:15 <zmv> heh. it's kinda unfortunate english depends on tones for meaning.
04:32:18 <dankna> because the higher-level one often already holds (has emptied) the MVar that the lower-level one wants
04:32:50 <zmv> dankna > who was it who convinced me last night to use STM / Cale > dankna: What is your problem? -- LOL
04:33:06 <dankna> so it's undesirable because it involves a lot of code duplication and prevents clean factoring
04:33:11 <dankna> zmv: haha yeah
04:33:22 <zmv> :D
04:33:38 <Cale> zmv: I thought it seemed quite appropriate
04:33:42 <Cale> haha
04:33:52 <zmv> heh
04:34:32 <Eduard_Munteanu> dankna: why does your high-level API have to take the MVar itself?
04:34:35 <Cale> Umm... well, STM does *kinda* solve that problem.
04:34:47 <dankna> Eduard_Munteanu, well, to provide atomicity.
04:34:58 <Cale> In that TVars can't even be empty
04:35:32 <dankna> Eduard_Munteanu, for example if I have to modify two fields, each of which is an MVar, I have to acquire A, acquire B, release B, release A in that order
04:35:34 <dankna> to prevent deadlock
04:35:37 <erus`> whats wrong with this:      otherwise = (filter (/='Â¥') w, length $ filter (=='Â¥') w)
04:35:46 <erus`> parse error on =
04:35:48 <Cale> dankna: But hmm, maybe the smaller pieces should be taking some things as pure parameters?
04:35:49 <dankna> also to prevent deadlock I have to keep track of and always use a canonical order for acquisition, which is annoying but oh well
04:36:00 <dankna> Cale: it's a thought, yes
04:36:11 <dankna> Cale: they don't really simplify much if they do that though
04:36:15 <Cale> erus`: more context?
04:36:19 <Saizan> erus`: probably lack a | at the start
04:36:35 <Cale> erus`: Yeah, is the otherwise in a guard?
04:36:48 <Eduard_Munteanu> dankna: maybe your lock is too fine-grained?
04:36:52 <dankna> if TVars can't be empty they don't provide concurrency which doesn't help me
04:36:56 <dankna> Eduard_Munteanu, it's possible
04:37:02 <Cale> dankna: They do, though.
04:37:04 <dankna> I had been looking at TMVars but hm
04:37:04 <erus`> ah yeah thanks guys
04:37:13 <Saizan> dankna: STM would simplify that because you'd just be reading TVar's and deal with atomicity separately
04:37:15 <Eduard_Munteanu> Do you have a huge record?
04:37:17 <dankna> hmmmm
04:37:18 <ddarius> dankna: What does emptiness or not have to do with concurrency?
04:37:24 <dankna> it's not huge yet, but it's going to be
04:37:30 <ddarius> You can write concurrent programs with IORefs.
04:37:33 <dankna> ddarius: yeah, nothing, never mind, I get how it works now
04:37:34 <Cale> dankna: You write transactions on TVars which are STM actions, and you apply 'atomically' to them to get IO actions.
04:37:45 <Cale> dankna: The transactions are composable.
04:38:04 <dankna> right, I get it.  it's doing clever things to ensure a consistent view, behind the scenes
04:38:27 <Cale> Yeah, right now it's pretty much just optimistic
04:38:41 <ddarius> (Actually, the "emptying" semantics of MVars is to -limit- concurrency.)
04:38:44 <dankna> well, let me play with the TVar approach for a bit and see if it works for me
04:38:50 <dankna> (ddarius: well yes, that's what I meant to say)
04:39:08 <dankna> (s/doesn't provide concurrency/doesn't provide concurrency control/)
04:39:25 <ddarius> STM provides it in a different manner.
04:39:31 <dankna> (but you're right, it's not strictly necessary given what STM does)
04:40:24 <erus`> it works :D
04:40:35 <erus`> ok now i need to make a word net thing
04:40:47 <erus`> everyone talk about haskell things
04:41:05 <dankna> I thought we were
04:45:13 <erus`> the dictionary has zygomorphic :)
04:45:17 <dankna> haha nice
04:46:11 <erus`> but no haskell
04:46:25 <erus`> maybe a dictionary lookup is not gonna work
04:47:35 <dankna> well, it will if you augment the dictionary with heuristics for unknown words
04:47:39 <dankna> or simply spit out a list of unknown words
04:47:41 <dankna> and add them by hand
04:47:50 <erus`> hmm
04:47:53 <dankna> you'll have to do that anyway, to recognize proper names and such
04:47:59 <dankna> also, why are you running this live and not on the logs?
04:48:23 <erus`> there is a javascript port of the latex hyphenating algorithm
04:48:27 <erus`> maybe i can port to haskell
04:48:30 <dankna> hmm
04:48:54 <erus`> the alternative is the read the 60 page paper
04:49:11 <dankna> haha
04:52:13 <dankna> okay so I did some work on rewording my program to use STM and found a deeper problem that I think keeps me from using it
04:52:25 <dankna> there's no way (by design) to embed an IO action in an STM action
04:52:56 <Saizan> right, you can only return one
04:53:02 <dankna> right
04:53:20 <dankna> I need to intersperse some primitives with this lock-acquisition stuff
04:53:34 <dankna> STM basically just does cleverness to make the locks implicit
04:53:38 <dankna> which is very clever indeed
04:54:04 <dankna> but I'm not seeing how I can, say, make a primitive action (in IO) atomic with the modification of the variables that hold its result
04:54:39 <Saizan> heh, you'd have to implement locking on top of STM
04:54:59 <dankna> indeed
04:55:06 <dankna> that would kinda defeat the entire purpose :)
04:55:40 <Saizan> unless implementing the kind of locking you want is harder on top of MVar's than on top of STM :)
04:55:44 <ddarius> I believe there is a functional version of the LaTeX algorithm or a similar algorithm in a not-60-page paper.
04:56:03 <dankna> it's probably precisely the same, really
04:56:47 <dylukes>  I think personally, the _easiest_ way to ensure concurrency is simple queueing.
04:57:02 <dankna> that's? a way to not use concurrency
04:57:03 <dylukes> well, to ensure proper results in a concurrent environment.
04:57:16 <dankna> that's a way to make your concurrent environment behave almost like a non-concurrent one
04:57:22 <dankna> it's certainly the easiest way to do what you said
04:57:27 <dankna> but it's useless and terrible :)
04:57:32 <dylukes> or make a non-concurrent environment act like an almost concurrent one
04:57:38 <dylukes> I didn't say it was a good idea, just that it works.
04:57:41 <dankna> haha okay
04:59:36 <ddarius> dankna: Do you have some example code?
05:00:08 <dankna> ddarius: well, it's in pieces right now because I've just reworded it from MVars to TMVars to TVars without being able to run it in between :)
05:00:32 <ddarius> dankna: I just want to see what you are more or less trying to do
05:00:36 <dankna> okay, one sec
05:00:37 <ddarius> Code speaks clearly.
05:01:03 <dankna> http://dankna.com/himitsu/Ansible.hs
05:01:10 <dankna> (this is an IRC client, btw)
05:01:15 <dankna> (Ansible is its name)
05:01:36 <dankna> (an ansible is a hypothetical device capable of faster-than-light communication.  I originally wanted a name that suggested annoying trolls, but gave up on finding a good one :D)
05:03:08 * ddarius is unable to formulate a question precisely.
05:03:11 <dankna> hmm
05:03:16 <dankna> muse about the subject imprecisely
05:03:18 <dankna> and I can probably answer it
05:04:01 <ddarius> dankna: It was a side question.
05:04:16 <dankna> okay
05:04:19 <ddarius> dankna: However, if this is for an IRC client are you sure the "coarse-grained" approach isn't adequate?
05:04:41 <dankna> I'm not certain, no
05:04:47 <dankna> I knew that was going to come up, heh
05:05:08 <ehamberg> dankna: annoying troll: https://secure.wikimedia.org/wikipedia/en/wiki/J%C3%B6tunn ;-)
05:05:21 <dankna> I suppose the clean way to do that would be to use StateT instead of ReaderT and acquire the big-hammer lock outside this module altogether
05:05:29 <ddarius> dankna: It's just that the problem you are making may be far worse than any performance gain it provides, if any.
05:05:37 <dankna> well, yeah
05:05:44 <dankna> ehamberg, hah!  interesting!
05:06:01 <ddarius> dankna: I tend to like message passing styles of concurrency a la Erlang.
05:06:11 <dankna> hm
05:07:57 <ddarius> (Actually, I've grown less keen on asynchronous messaging for intra-application communication.)
05:08:03 * dankna nods
05:08:08 <ddarius> Less keen on the asynchronous part that is.
05:08:33 <dylukes> ddarius: I tend to think asynchronous is good between layers of an application, but not necessarily within each one.
05:08:41 <dylukes> i.e, you don't want synchronous communication with the UI :P
05:08:47 <dylukes> that's a recipe for disaster.
05:09:28 <ddarius> dankna: If you haven't read it, I highly recommend Reppy's thesis on CML.  It's fairly beautiful (even with ML syntax).  It's not directly pertinent to your problem though.
05:09:38 <dankna> okay, I'll give it a look at some point, because I haven't, no
05:09:56 <ddarius> dylukes: Actually, Pike's "A Concurrent Window System" was a windowing system that communicated through synchronous channels.
05:10:14 <dylukes> ddarius: I'm not talking about a window system,
05:10:22 <dylukes> but UI within an application itself.
05:10:53 <dylukes> you can't have the UI ever deadlocking (and any cases you might you should just use modals to represent the inability to interact temporarily)
05:10:57 <ddarius> It's quite easy to make a asynchronous channel from a synchronous one and it's easy to stick a shim in between to separate out that concern.
05:11:12 <erus`> wiktionary has rhyming words :D
05:11:17 <dankna> nice
05:11:21 <ddarius> dylukes: I'm pretty sure you can't have a windowing system deadlock either.
05:11:28 <dylukes> ddarius: What I mean is,
05:11:33 <dylukes> say you have a program and when you click a button,
05:11:39 <dylukes> it starts downloading a file
05:11:50 <dylukes> and the entire UI freezes, because that thread is currently waiting on the download
05:12:01 <ddarius> dylukes: That's not what I was originally talking about.
05:12:39 <ddarius> I'm talking about asynchronous v. synchronous message passing.  Whether asynchronous or synchronous, the solution to a blocking call, like your downloading of a file is to fork a thread.
05:12:51 <ddarius> I actually prefer blocking calls.
05:13:32 <dylukes> anyways
05:13:33 <dylukes> I have to go
05:21:42 <elliott> What's a decent package to use for vectors used as dynamic-length lists, that properly preallocate additional space on expansion? (Preferably persistent.)
05:22:28 <ddarius> robustifier :: SChanSource a -> SChanSource (Maybe a); robustifier chan = do (src,snk) <- newSourceSink; forkIO (forever (select [readChan chan ~> writeChan snk . Just, timeout 30 ~> \() -> writeChan snk Nothing])); return src
05:23:04 <ddarius> elliott: I'm not sure if there is a premade package, but ultimately it just comes down to one or a few functions on an existing immutable array type.
05:23:05 <tomh> hmm is there a convinient function to do sequence on a map?
05:23:12 <ddarius> mapM ?
05:23:17 <ddarius> @bot
05:23:17 <lambdabot> :)
05:23:20 <elliott> ddarius: Yeah, it does.
05:23:22 <ddarius> @src mapM
05:23:22 <lambdabot> mapM f as = sequence (map f as)
05:23:25 <elliott> I was just hoping I could be lazy :)
05:23:32 <Axman6> tomh: do you mean a Map?
05:23:37 <tomh> yeah
05:23:48 <Axman6> ah, that's a different story
05:23:48 <tomh> Data.Map
05:23:56 <elliott> ddarius: Basically I was just worried that "vector"'s vectors wouldn't over-allocate on expansion but I guess they almost certainly do.
05:24:02 <Axman6> but... there might be something in Data.Traversable
05:24:11 <tomh> there is a sequence there
05:24:14 <elliott> tomh: sequence . toList?
05:24:20 <elliott> has to be in some ordering
05:24:22 <Axman6> ddarius: do you know of anything? i've never used Traversable
05:24:24 <ddarius> elliott: They probably don't.
05:24:38 <ddarius> @hoogle sequenceA
05:24:38 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
05:24:39 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
05:24:40 <tomh> elliott: toList generates [(k, a)]
05:24:41 <elliott> ddarius: Huh, really?
05:24:50 <elliott> tomh: OK, elems :P
05:25:11 <tomh> yeah, but then I get all raw elements, I need to get them back in the map with correct key
05:25:33 <tomh> I could write that, but I thought there might be a more convinient method :P
05:25:44 <jmcarthur> didn't hpaste support more languages for syntax highlighting in the past? it looks like right now it only supports haskell and ruby
05:25:59 <Axman6> i'm sure it used to support C
05:26:21 <ddarius> elliott: It would probably say amortized constant time for cons if it did.
05:26:29 <dankna> didn't hpaste used to be, um, a completely different program though? :)
05:26:31 <ddarius> So you may need to make your own thin wrapper.
05:26:41 <elliott> ddarius: Yeah, fair enough.
05:26:41 <Axman6> i'm sure the new hpaste supported C though
05:26:45 <elliott> Won't take much work.
05:26:53 <dankna> hm, okay
05:26:56 <ddarius> Axman6: The new hpaste or the new new hpaste?
05:27:21 <Axman6> the new new hpaste
05:27:31 <Axman6> i used it in the last few months to paste C
05:27:47 <ddarius> I think the newest hpaste is only a couple of months old.
05:27:57 <ddarius> Maybe less.
05:28:13 <brisingr> I thought hpaste had C
05:28:33 <brisingr> I see only hs and ruby
05:28:54 <tomh> Traversable.sequence seems to compile
05:28:59 <tomh> so it must be correct :D
05:29:24 <phercek> do two GHC threads allocate from the same heap or do they allocate from different heaps (which could reference each other)? (the second case would not interleave data of two threads in memory so much ... hopefully leading to better cache behavior)
05:29:25 <Axman6> heh
05:29:56 <Axman6> phercek: probably better to ask in #ghc
05:30:04 <dankna> same heap
05:30:04 <phercek> thanks
05:30:20 <phercek> dankna: ok, thanks
05:30:33 <dankna> but #ghc is more authoritative than my own understanding :)
05:30:40 <phercek> ok
05:30:45 <phercek> going there
05:31:34 <Jafet> Cache? What's that?
05:31:41 <Botje> phercek: there was a paper about it recently
05:32:03 <phercek> Botje: do you have a link?
05:32:17 <Botje> Multicore Garbage Collection with Local Heaps
05:32:33 <ddarius> elliott: Actually, vector doesn't do that (at least in its pure interface) because it's not that trivial for a persistent interface.
05:32:39 <Botje> they have a nice discussion about when to promote data from local to global
05:33:02 <phercek> Botje: got it; thanks
05:33:06 <Jafet> I think cache is a theoretical construct by dons.
05:33:20 <Jafet> phercek: ghc has used a two-generation collector for some time.
05:34:14 <elliott> ddarius: Yeah, I guess that's true.
05:34:24 <phercek> Jafet: yes I know, but I do not think my question is about generations, I believe it is mostly unrelated to generations
05:34:54 <elliott> I just hope "V.cons v (V.replicate (V.size v) 0)" is fast :P
05:35:00 <elliott> Erm, ++ not cons
05:35:31 <Axman6> shouldn't be too bad for Vector
05:35:53 <Axman6> it doesn't actually allocate arrays unless it has to i believe, preferring stream fusion
05:36:10 <elliott> right
05:40:18 <ddarius> elliott: There are several structures on hackage that can give random access at various asymptotics with growing while being persistent.
05:40:51 <elliott> Yeah; I'm just trying to find them :P
05:41:41 <ddarius> @hackage random-access-list is one obvious candidate just from perusing the Data Structures category of hackage.
05:41:41 <lambdabot> http://hackage.haskell.org/package/random-access-list is one obvious candidate just from perusing the Data Structures category of hackage.
05:41:51 <ddarius> You can also use finger trees.
05:42:04 <ddarius> Edison no doubt has multiple structures that could be used.
05:42:07 <elliott> That looks reasonable.
05:43:22 <ddarius> Though now I'm curious if you can make an add for MVector that does the exponential growth thing while producing a MVector that can be used as normal.
05:44:01 <mux> is Edison still maintained? last time I looked at it, it seemed dusty
05:44:23 <ddarius> I mean it's easy to over-allocated and then slice, but I don't think MVector gives you the means to grow the bounds without reallocating a new array unless the actual instances of MVector are smarter than the defaults.
05:44:57 <ddarius> mux: The interface aspects of it should probably be rewritten to use type families.
05:45:41 <ddarius> But yeah, it looks like Robert Dockins gave up.  I'm surpised he stuck it out as long as he did.
05:47:04 <ddarius> I guess slices have no way of knowing really anything about their parent arrays.
05:47:53 <dfjklaaf>  
05:47:54 <dfjklaaf> 15:28 -!- zekna [~zekna@c-24-7-45-147.hsd1.ca.comcast.net] has joined #haskell
05:47:54 <dfjklaaf> 15:28 < ddarius> Though now I'm curious if you can make an add for MVector that does the
05:47:59 <dfjklaaf> sorry
05:48:09 <ddarius> That said, I doubt a lot of the code in Edison needs any particular maintenance.  For example, the last upload of it was 2008 but it builds on GHC 7.
05:52:02 <ddarius> It may use n+k patterns though (!)
06:14:32 <nda> hi
06:14:37 * dankna signs nda
06:14:43 <dankna> sorry, can't respond to that
06:14:52 <nda> @pl (\(x, y) -> (f x, f y))
06:14:52 <lambdabot> f *** f
06:21:04 <nda> @pl \a (b, c) -> (a + b, a + c)
06:21:04 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (+)) (+)
06:21:37 <nda> @pl \a (b, c) -> (b + a, c + a)
06:21:38 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (+)) (+)
06:22:26 <confab> what does pl do?
06:23:27 <elliott> confab: makes code elegant, beautiful, efficient
06:23:32 <elliott> free of named variable bindings
06:23:46 <Axman6> i does none of those things imo
06:23:52 <confab> what does it really do?
06:23:54 <elliott> it certainly does the last :P
06:24:05 <elliott> the first three MAY be subjective.
06:24:06 <ddarius> @help pl
06:24:06 <lambdabot> pointless <expr>. Play with pointfree code.
06:24:11 <Axman6> confab: it makes code point free (so there's no free variables)
06:24:14 <confab> ah
06:24:17 <Jafet> @pl \a b c d e f g h -> h g f e d c b a
06:24:19 <confab> cool thanks
06:24:20 <lambdabot> flip (flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (
06:24:20 <lambdabot> flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))))
06:24:26 <ddarius> elliott: It doesn't make code more efficient.
06:24:27 <Axman6> @pl f x = x + 2 * x
06:24:28 <lambdabot> f = ap (+) (2 *)
06:24:34 <elliott> Axman6: yeah, but then all the variables are expensive :(
06:24:43 <elliott> ddarius: It might do, if your compiler really liked point-free code.
06:24:50 <elliott> I don't really deal in facts.
06:24:59 <elliott> They're so constraining.
06:25:15 <ddarius> Don't worry.  Reality is just a fad anyway.
06:25:19 <confab> !hoogle ap
06:25:25 <confab> err
06:25:30 <confab> @hoogle ap
06:25:30 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
06:25:30 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
06:25:31 <lambdabot> Control.Arrow app :: ArrowApply a => a (a b c, b) c
06:25:48 <elliott> ap aka <*>
06:25:50 <Axman6> ap is also known as <*> in applicative
06:25:55 <Axman6> bah
06:25:58 <Axman6> you suck elliott
06:25:59 <Axman6> :P
06:26:01 <elliott> (fmap aka <$>)
06:26:14 <confab> thanks, i thought that looked familiar
06:26:20 <ddarius> ap and (<*>) are not the same, though they should be the same when both are defined.
06:26:36 <confab> :t ap
06:26:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:26:41 <Jafet> :t (<*>) `asTypeOf` ap
06:26:41 <confab> :t <*>
06:26:42 <lambdabot> forall (f :: * -> *) a b. (Applicative f, Monad f) => f (a -> b) -> f a -> f b
06:26:42 <lambdabot> parse error on input `<*>'
06:27:05 <Jafet> :t liftA2 `asTypeOf` liftM2
06:27:06 <lambdabot> forall a b c (f :: * -> *). (Applicative f, Monad f) => (a -> b -> c) -> f a -> f b -> f c
06:27:09 <Axman6> :t asTypeOf `asTypeOf` asTypeOf
06:27:10 <lambdabot> forall a. a -> a -> a
06:27:13 <Axman6> >_>
06:27:23 <elliott> :t asTypeOf asTypeOf asTypeOf asTypeOf
06:27:24 <lambdabot> forall a. (a -> a -> a) -> a -> a -> a
06:27:26 <elliott> useful
06:27:36 <ddarius> This axiom system for special relativity assumes a photon at every spacetime point.  In fact, it assumes (if we use reals as our quantities) an uncountable infinity of photons at every spacetime point.
06:27:40 <Jafet> :t undefined `const` asTypeOf
06:27:40 <lambdabot> forall a. a
06:28:07 <ddarius> :t const `asTypeOf` asTypeOf
06:28:08 <lambdabot> forall a. a -> a -> a
06:28:15 <confab> :t <$>
06:28:16 <lambdabot> parse error on input `<$>'
06:28:24 <Axman6> :t (<$>)
06:28:24 <confab> :t (<$>)
06:28:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:28:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:29:23 <ddarius> I guess it could have most of those photons be massless (energyless,) so it isn't necessarily a problem.
06:30:25 <nda> @pl \a (b, c) -> (f a b, f a c)
06:30:26 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . f) f
06:31:39 <Jafet> ddarius: not a problem for coconstructivists!
06:32:54 <ddarius> Jafet: You can probably get tenure somewhere if you start working on a theory of coconstructivism.  (Well, not -immediately- after you start working on it.)
06:33:23 <monochrom> after you finish constructing it. or coconstructing it?
06:37:44 <elliott> coconstructionism sounds nice. accepting the existence of no finite objects?
06:38:24 <roconnor> *lol*
06:38:33 <monochrom> heh fun
06:38:42 <elliott> "The naturals aren't real, but only because of those pesky elements!"
06:39:14 <elliott> cool, you have to reject powersets for that... also almost everything
06:39:21 <elliott> could be fun
06:40:21 <Eduard_Munteanu> Ultrainfinitism? :P
06:40:22 <monochrom> though you have to reject almost everything, there are still infinitely many things you don't have to reject, so don't despair just yet! XD
06:41:23 <iwtu> what is difference between Data.Set.elems and Data.Set.toList ?
06:41:43 <Eduard_Munteanu> @hoogle Data.Set.toList
06:41:44 <lambdabot> Data.Set toList :: Set a -> [a]
06:41:52 <Eduard_Munteanu> @hoogle Data.Set.elems
06:41:53 <lambdabot> Data.Set elems :: Set a -> [a]
06:42:18 <iwtu> maybe some order
06:42:39 <Eduard_Munteanu> Yep.
06:42:45 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/src/Data-Set.html#elems
06:42:47 <monochrom> probably no difference
06:43:08 <Eduard_Munteanu> Wait, no :)
06:43:18 <Eduard_Munteanu> monochrom is right.
06:43:32 <Eduard_Munteanu> elems = toList = toAscList
06:43:32 <benmachine> certainly no difference in code
06:43:33 <iwtu> how does he know? :)
06:43:48 <Eduard_Munteanu> iwtu: look at the source code
06:43:51 <benmachine> one could argue about whether there's any difference in meaning, but I don't think so
06:43:54 <monochrom> in a sense they are all there so you can just guess a name without looking up docs and it just works
06:44:01 <Axman6> iwtu: i'd guess they're just both there because they're both common names for the same thing
06:44:08 <elliott> Well, toList and elems presumably don't guarantee order API-wise.
06:44:11 <elliott> Whereas toAscList would.
06:44:25 <Eduard_Munteanu> Yeah, it probably makes sense for other stuff, like arrays
06:45:05 <Eduard_Munteanu> (or so you can have drop-in replacements that don't have a similarly ordered internal representation)
06:46:19 <iwtu> it makes sence. C++ has also more name for the same funcioniality.. because of some hierarchy I think
06:48:36 <Eduard_Munteanu> The bad part is these things don't use typeclasses :(
06:49:21 <Axman6> indeed -_-
06:54:49 <ARRG> Whenever you get a "non-exhaustive patterns" exception, is there a way to see what input generated the exception ?
06:55:15 <Botje> add a manual match at the bottom
06:56:07 <Axman6> ARRG: foo e = error $ "foo: unmatched \"" ++ show e ++ "\""
06:56:23 <ARRG> Okay thanks :)
06:56:40 <elliott> Oh, I thought Axman6 was expressing some kind of weird frustration.
06:56:57 <Axman6> heh
06:57:49 <dainanaki> he is an axman after all.
06:57:52 <dainanaki> kind of scary
06:58:12 <Botje> he comes after people who write bad code :)
06:58:14 * Axman6 is just a lumberjack and he's ok
06:58:45 <nda> @pl \f (x, y) -> (f x, f y)
06:58:46 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
06:58:56 <nda> ...
06:59:07 <monochrom> @type (***)
06:59:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:59:39 <nda> yes, i could do (f *** f) (x, y)
07:00:02 <monochrom> yeah, apart from that, no nice way
07:00:06 <Axman6> :t join (***)
07:00:07 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:00:28 <nda> bummer
07:00:31 <Axman6> :t join (***) (undefined :: a -> b)
07:00:33 <lambdabot> forall b c. (b, b) -> (c, c)
07:00:48 <Axman6> you suck lambdabot, pay attention to my variable names!
07:01:34 <monochrom> @djinn (a->b) -> (a->a->r) -> (b->b->r)
07:01:35 <lambdabot> -- f cannot be realized.
07:02:19 <companion_cube> @djinn (a->b) -> ((a,a) ->r) -> ((b,b) -> r)
07:02:20 <lambdabot> -- f cannot be realized.
07:02:28 <confab> curious
07:02:33 <confab> why is it pl and not pf?
07:02:48 <geheimdienst> confab: it's "pointless"
07:03:04 <confab> my argument?
07:03:06 <Philonous_> @djinn (b->a) -> (a->a->r) -> (b->b->r)
07:03:06 <confab> ;)
07:03:06 <lambdabot> f a b c _ = b (a c) (a c)
07:03:22 <nda> very subtle :D
07:03:52 <geheimdienst> c0nfab, no, pl stands for _p_oint_l_ess
07:04:04 <mun> hi
07:04:05 <confab> right
07:04:19 <confab> but isn't it called point free?
07:04:38 <mun> in logic, if a function takes in a set as an argument, e.g., f(S) where S is a set, then does the underlying logic have to be second-order or higher?
07:04:55 <nda> yes, point-less is somewhat biased
07:05:17 <nda> yet it can be considered a pun
07:05:52 <monochrom> yes second-order at least
07:05:58 <companion_cube> mun: i don't think so, if set is a theory in your logic
07:06:27 <companion_cube> but if you call "sets" the values that satisfy a predicate, then yes
07:06:28 <mun> monochrom, is that because f is a second-order function, as sets are represented as unary predicates?
07:06:36 <monochrom> yes
07:06:48 <mun> companion_cube, hmm what do you mean by set being a theory in the logic?
07:07:25 <companion_cube> mun: using a symbol for membership and adding some axioms of theory of sets to your logic
07:07:51 <mun> right. sure.
07:08:29 <companion_cube> but then "set" is just a syntactical notion, in contrast to full-fleged sets represented by predicates
07:08:56 <monochrom> @djinn (a->b) -> ((a->a->r)->r) -> ((b->b->r) -> r)
07:08:57 <lambdabot> f a b c = b (\ d _ -> c (a d) (a d))
07:09:09 <companion_cube> oO
07:09:18 <monochrom> @pl \a b c -> b (\ d _ -> c (a d) (a d))
07:09:18 <lambdabot> flip (.) . ((const .) .) . (flip =<< (ap .) . flip (.))
07:09:27 <monochrom> haha not any better!
07:09:44 <companion_cube> why lambdabot succeeds for a more complicated type?
07:09:47 <monochrom> ( ((a->a->r)->r) is an encoding of (a,a) )
07:09:59 <companion_cube> indeed
07:10:03 <companion_cube> a CPS encoding?
07:10:12 <monochrom> yes, also church encoding
07:10:21 <companion_cube> oh, right
07:10:36 <monochrom> I erred at first with (a->a->r) alone
07:10:41 * companion_cube never realised that church encoding for integers was a kind of CPS
07:10:56 <Peaker> monochrom: are you looking for a nice points-free of that?
07:11:07 <monochrom> yes. failed.
07:11:15 <Peaker> SECs give automatic nice points free for that :)
07:11:15 <confab> @unpl flip (.) . ((const .) .) . (flip =<< (ap .) . flip (.))
07:11:16 <lambdabot> (\ v c f -> c (\ an _ -> ((\ m au ag -> (m au) >>= \ ad -> ag >>= \ ac -> return (ad ac)) >>= \ j k l -> j l k) (\ p s -> p (v s)) f an))
07:11:27 <confab> jesus
07:11:46 <companion_cube> enlarge your readability!
07:11:52 <monochrom> what is SEC?
07:11:57 <Peaker> @where SEC
07:11:57 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
07:12:10 <Peaker> @let argument = flip (.)
07:12:11 <lambdabot>  Defined.
07:12:13 <Peaker> @let result = (.)
07:12:15 <lambdabot>  Defined.
07:12:28 <monochrom> well yeah if you have more builtins you get nicer pointfree formulas
07:12:38 <Peaker> yeah
07:13:11 <Peaker> @let infixr 2 ~> ; (f ~> g) = argument f . result g
07:13:12 <lambdabot>   Parse error in pattern:
07:13:17 <monochrom> Prelude.Twitter.Pointfree will contain all pointfree combinators implementable in 140 tokens or less
07:13:18 <Peaker> @let infixr ~> 2 ; (f ~> g) = argument f . result g
07:13:18 <lambdabot>   Parse error: 2
07:13:20 <confab> @pl \abc -> b (\ d _ -> c (a d) (a d))
07:13:20 <lambdabot> const (b (const . liftM2 c a a))
07:13:37 <Axman6> \abc /= \a b c
07:13:38 <confab> oh oops
07:13:38 <companion_cube> lol @ Prelude.Twitter
07:13:43 <confab> @pl \a b c -> b (\ d _ -> c (a d) (a d))
07:13:44 <lambdabot> flip (.) . ((const .) .) . (flip =<< (ap .) . flip (.))
07:13:52 <Peaker> not allowed to put redundant () in infix definition syntax? Interesting
07:14:20 <Peaker> @type \f -> (f ~> f ~> id)
07:14:21 <lambdabot> forall (f :: * -> *) a a1. (Functor f) => f a -> (a -> a -> a1) -> f (f a1)
07:14:38 <Peaker> Caleskell :-(
07:14:50 * hackagebot bit-vector 0.1.0 - Simple bit vectors for Haskell  http://hackage.haskell.org/package/bit-vector-0.1.0 (AdamFoltzer)
07:15:05 <Peaker> @pl \f -> (f ~> f ~> id)
07:15:05 <lambdabot> (line 1, column 10):
07:15:06 <lambdabot> unexpected "~"
07:15:06 <lambdabot> expecting variable, "(", operator or ")"
07:15:19 <Peaker> @pl \f -> (f `op` f `op` id)
07:15:19 <lambdabot> (`op` id) . join op
07:15:35 <Peaker> @pl \f -> (f `op` (f `op` id))
07:15:35 <lambdabot> ap op (`op` id)
07:15:52 <danr> @type join (***)
07:15:53 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:18:37 <whald> is there something objectionable about the uniqueid package? it seems to do exactly what i need, but it seems like a shortcut around using a state monad, and i'd rather not regret porting my code to using it (currently i'm passing parameters around and i'd like to improve this)
07:19:30 <monochrom> @type \f xy k -> k (f (xy (\x y -> x))) (f (xy (\x y -> y)))
07:19:31 <lambdabot> forall t t1 t2 t3. (t -> t1) -> ((t2 -> t2 -> t2) -> t) -> (t1 -> t1 -> t3) -> t3
07:19:47 <elliott> whald: Does Data.Unique not meet your needs?
07:19:55 <elliott> uniqueid even says "After improvements of the value-supply package it is now deprecated."
07:20:05 <elliott> whald: (Data.Unique is in the stdlib.)
07:21:10 <whald> elliott: oh, i've only read that http://hackage.haskell.org/packages/archive/uniqueid/0.1.1/doc/html/Data-Unique-Id.html page, which does not mention the deprecation
07:21:15 <monochrom> @type \f xy k -> k (xy (\x y -> f x)) (xy (\x y -> f y))
07:21:16 <lambdabot> forall t t1 t2 t3. (t2 -> t) -> ((t2 -> t2 -> t) -> t1) -> (t1 -> t1 -> t3) -> t3
07:21:27 <whald> elliott: so if it's in the stdlib i guess it's ok to use it
07:21:39 <elliott> whald: No, Data.Unique.Id is not.
07:21:41 <elliott> whald: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Unique.html is.
07:23:27 <whald> elliott: but newUnique is in IO, while idFromSupply isn't monadic at all, that's why i'd prefer it
07:23:47 <elliott> Are you sure your construction is referentially transparent?
07:23:50 <elliott> I somewhat doubt it.
07:24:18 <monochrom> @type \f xy c -> xy (\x y -> c (f x) (f y))
07:24:19 <lambdabot> forall t t1 t2 t3. (t -> t1) -> ((t -> t -> t2) -> t3) -> (t1 -> t1 -> t2) -> t3
07:24:36 <dylukes> elliott: It works the same say as a PRNG
07:24:38 <Axman6> whald: what you're after is something that obviously has side effects. you should not make your code lie
07:24:50 <dylukes> Except the pattern is a simple increment, not a complex mersenne or anything
07:24:50 <monochrom> @pl \f xy c -> xy (\x y -> c (f x) (f y))
07:24:50 <lambdabot> flip (.) . (flip =<< ((flip . ((.) .)) .) . flip (.))
07:25:02 <monochrom> haha nevermind
07:25:25 <companion_cube> Data.Unique.Id is the Id functor ?
07:25:29 <dylukes> It seems @pl is generally useless.
07:25:40 <whald> Axman6: i guess you are right, that's why i was suspicious of the uniqueid package
07:25:40 <elliott> I use ?pl all the time.
07:25:44 <dylukes> companion_cube: No the Identity functor is in Data.Functor.Identity
07:25:49 <monochrom> I usually do it by hand :)
07:25:51 <companion_cube> uh, ok
07:26:01 <elliott> dylukes: yes, and a PRNG is not referentially transparent, if accessed as "PRNG -> NextValue" that updates the PRNG
07:26:19 <dylukes> PRNG -> (NextValue, NewPRNG)
07:26:36 <elliott> Perhaps I misunderstand the use of uniqueid.
07:26:37 <Axman6> whald: it seems to me that a state monad is by far the nicest way to do what you want. just make the state [0..] and define newUnique = get >>= \(x:xs) -> put xs >> return x
07:27:00 <elliott> whald: If dylukes is correct and you use it by basically doing "Supply -> (Id, Supply)", then that is exactly a state monad.
07:27:04 <elliott> ?unmtl State Supply Id
07:27:04 <lambdabot> Supply -> (Id, Supply)
07:27:11 <dylukes> elliott: basically.
07:27:17 <dylukes> :P
07:27:18 <elliott> No, exactly.
07:27:22 <dylukes> well, yeah
07:28:10 <whald> thanks everyone involved, i'll just do it in a monad, then i'll at least understand what's going on
07:28:23 <companion_cube> are the SEC related to lenses ?
07:28:30 <whald> huh, never thought i'll *ever* write that :-)
07:30:00 <Peaker> companion_cube: SECs are more general than lenses (and less powerful)
07:30:31 <MHD> Is there any good tutorials for all those advanced things you guys juggle around?
07:30:35 <companion_cube> so lenses are SEC, but not the opposite?
07:31:25 <Peaker> companion_cube: A lens setter is a SEC
07:31:38 <companion_cube> ok,thanks
07:32:08 <Peaker> oh, sorry, actually a lens' "modify" function is a SEC
07:32:18 <Saizan> is "SEC" even so well defined?
07:32:20 <Peaker> (it needs to edit a given function)
07:33:05 <Peaker> Saizan: I think the relatively accurate definition can be inferred from conal's post... Something that "lifts" a function to operate within a context, in a way that is composable
07:33:31 <Saizan> so no :)
07:33:34 <Peaker> :)
07:33:45 <Peaker> accurate enough to talk about whether lens are SECs, and decide a lens modify is :)
07:34:29 <companion_cube> Peaker: it's more like the "modify" function for MBox, for instance, i guess
07:34:38 <Peaker> MBox?
07:34:41 <Peaker> @hoogle MBox
07:34:43 <lambdabot> No results found
07:34:46 <Saizan> i guess "higher order function" is the well defined concept in that neighborhood
07:35:04 <companion_cube> oops, MVar
07:35:17 <dylukes> Peaker: did you ever write a "better" iteratee's package?
07:35:32 <Peaker> Saizan: I think it has to: A) take a function  B) return a "modified" function that is a "lifted" version of its input
07:35:44 <Peaker> dylukes: nope, I'm staying up to 4-5 am almost every day on my work duties :)
07:35:50 <dylukes> oh jeez
07:36:04 <Peaker> Doing a blitz to finish it properly..
07:36:34 <Saizan> Peaker: so fix :: ([a] ->  [a]) -> [a] wouldn't be a sec?
07:36:44 <Peaker> Saizan: right
07:37:03 <Peaker> @type result . fix
07:37:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => ((a -> b) -> a -> b) -> f a -> f b
07:38:01 <kmc> what about STM Eduard_Munteanu
07:40:00 <Saizan> you were accused of suggesting STM to dankna :)
07:40:44 <kmc> oh dear
07:40:55 <Eduard_Munteanu> Oh, it was just a guess. :)
07:42:27 <Eduard_Munteanu> kmc: well... did you? :P
07:43:04 <dons> huh. i didn't realize i'd not been here for >60 days
07:43:12 <swath> hi, im a newbie having a weird problem, if anybody could be help it would be great...i seem to have two identical files, one of them works, one of them complains about how im using a "do," the specific error is "The last statement in a 'do' construct must be an expression: contents <- readfile "record.txt" putStr contents
07:43:14 <byorgey> dons: welcome back =)
07:43:14 <dons> that's the longest gap in 10 years!
07:43:27 <swath> and the weird thing is i have another file with the same 5 lines of code and it works perfectly
07:43:39 <dons> cheers byorgey
07:43:49 <byorgey> swath: perhaps one of the files has some tabs instead of spaces?
07:44:06 <byorgey> swath: that sort of error can sometimes be caused by improper indentation
07:44:27 <swath> ugh, no matter which language i learn i can't get away from this trivial formatting crap
07:44:27 <fryguybob> @vixen Are you glad dons is back?
07:44:28 <lambdabot> isn't it obvious?
07:44:30 <jordyd> if GLfloat is defined as "type GLfloat = Float", then I should be able to pass a Float to a function that accepts GLfloats, right?
07:44:42 <elliott> jordyd: Yes.
07:44:59 <byorgey> swath: you can get away from trivial formatting crap in Haskell if you use explicit  {  ... ; ... ; ... }  for do-blocks
07:45:03 <Saizan> but i thought it was a newtype in recent versions?
07:45:03 <dankna> Swath: learn Lisp
07:45:17 <dankna> Lisp is blissfully free of trivial formatting crap
07:45:21 <byorgey> swath: indentation is just syntax sugar for implicitly inserting braces and semicolons
07:45:23 <dankna> it makes Haskell's syntax look baroque
07:45:36 <Peaker> dankna: and nice :)
07:45:37 <elliott> swath: Stop blaming the language for your errors :P
07:45:39 <Saizan> swath: or by making your editor insert spaces instead of tabs
07:45:46 <MHD> A language's flaws are its charms
07:46:16 <dankna> Peaker: I do disagree.  Haskell's syntax is too complex.  It needs to be simpler.
07:46:21 <MHD> I still find C to be a... Dare I say, /elegant/ abstraction over assembler.
07:46:25 <dankna> not parentheses exactly, but simpler
07:46:35 <dankna> MHD: C is actually very well-designed, yes
07:46:44 <MHD> Unfortunately C++ is not
07:46:59 <MHD> C# is a little better
07:46:59 <swath> my error? the code was fine =p
07:47:01 <Peaker> dankna: Haskell syntax is pretty simple
07:47:08 <dankna> Peaker: yes - but not simple enough
07:47:24 <elliott> swath: No it wasn't
07:47:26 <kmc> MHD, C has no portable, reliable, efficient way to make tail calls
07:47:28 <MHD> The amount of DSLs in standart library Haskell is staggering
07:47:29 <elliott> If it was fine, GHC would accept it
07:47:30 <Peaker> MHD: C has quite a bit of low-hanging fruit inelegance that could be gotten rid of
07:47:35 <elliott> It didn't, so it isn't
07:47:36 <byorgey> elliott: oh, come off it.
07:47:47 <swath> GHC is not the decider of what is good code and what is not.
07:47:52 <MHD> kmc: no that's true,
07:48:00 <MHD> Peaker: Yeah, again.
07:48:06 <MHD> But that is the charm of C
07:48:09 <elliott> byorgey: Well, it's true. Compiling is a pretty minimum standard for good code.
07:48:12 <MHD> It's like 70's hairstyles
07:48:16 <swath> if i write an incredibly elegent algorithm in pseodo code, or even more basic, a sequence of pictures, it isn't bad code because GHC wouldn't accept it.
07:48:26 <Peaker> MHD: heh, C's array/ptr behavior, and C's type declaration syntax are not exactly charming :)
07:48:29 <byorgey> elliott: I disagree.
07:48:44 <elliott> swath: It's certainly bad Haskell, just like most C programs are bad Haskell; pseudocode is something else.
07:48:44 <Eduard_Munteanu> MHD: and it's still worn by today's hippies :P
07:49:00 <MHD> Peaker: hexdigit["0123456789ABCDEF"]
07:49:08 <swath> maybe incorrect haskell.
07:49:14 <swath> "bad" to me means something else.
07:49:33 <Peaker> dankna: if C had treated arrays as ordinary first-class values (like structs), and allowed both to be used as values in all contexts (e.g: ==), and had decent type declaration syntax, it would have been much more elegant, and slightly more practical to use
07:50:01 <byorgey> elliott: please stop. arguing with newbies just because they are justifiably frustrated at an annoying corner of the language gets no one anywhere.
07:50:05 <Peaker> and if C had been stricter in its type checking (enums are not ints!) it would have been really useful
07:50:09 <MHD> Peaker: Go ahead and make that then. Parsec and LLVM will do it in a jiffy.
07:50:21 <erus`> yeah
07:50:22 <kmc> meh
07:50:23 <erus`> fork it
07:50:26 <elliott> byorgey: I'm not arguing at all, but fine
07:50:40 <kmc> Eduard_Munteanu, quite possibly :)
07:51:25 <kmc> no language is free of trivial syntactic issues, except maybe the likes of Brainfuck
07:51:25 <MHD> Anyone ever checked this out: http://sites.google.com/site/steveyegge2/five-essential-phone-screen-questions
07:51:29 <dankna> Peaker: true
07:51:50 <MHD> kmc: I do wish that it used curly braces though
07:51:56 <kmc> Lisp has syntax too... it has three layers of syntax instead of two, and some people disingenuously claim the top layer does not exist
07:52:35 <swath> somebody just needs to write an automated programming assistant that knows how to fix many of the trivial types of errors safely.
07:52:55 <Peaker> kmc: some claim the bottom layers don't exist either "Lisp has no syntax at all!"
07:52:58 <elliott> I call that GHC :P
07:53:06 <kmc> GHC doesn't fix your errors for you
07:53:07 <monochrom> what are the 3 layers?
07:53:11 <kmc> it gives advice, usually unhelpful advice
07:53:14 <MHD> swath: Oh, yeah, that's a field I'm going to look into. We call it AI.
07:53:27 <elliott> Maybe I'm nostalgic for a time when GHC's errors were actually helpful.
07:53:28 <swath> GHC complains when you have a tab instead of a space. thats not much for assistance!
07:53:37 <kmc> swath, languages that try to second-guess the programmer are usually a disaster
07:53:37 <Peaker> monochrom: I'm assuming token parsing, AST, and then the special-forms/macros
07:53:40 <MHD> kmc: It gives better advice than Gcc's c++
07:53:45 <kmc> ok, so?
07:53:53 <Peaker> (the last layer is encoded in terms of the former, which is encoded in terms of the former)
07:53:55 <monochrom> oh, I forgot tokenizing
07:54:05 <kmc> yeah.  tokens, s-exprs, special forms
07:54:52 <monochrom> well then, most programming languages have 2 layers
07:54:57 <kmc> yes
07:54:57 <Eduard_Munteanu> The problem with fixing trivial stuff is you still have to check and see it does what you want.
07:55:05 <kmc> GHC could attempt to guess how big your tabs should be
07:55:09 <kmc> i don't think that's worth the effort
07:55:11 <Botje> ogres have layers too!
07:55:28 <kmc> it should, however, warn if you use tabs and spaces to indent lines in the same file
07:55:29 <Eduard_Munteanu> Unless it's obvious to the computer there's a single logical answer.
07:56:18 <swath> maybe all that's needed is less cryptic error messages.
07:56:28 <Eduard_Munteanu> But yeah, it's a common question/complaint "why doesn't the compiler fix it if he thinks it's wrong?". :)
07:57:13 <Saizan> the problem is that giving "good" error messages is a matter of second-guessing the user too
07:57:37 <byorgey> swath: the problem with tabs is that they correspond to different amounts of space depending on your editor setting.  So the Haskell standard specifies that a tab is equal to a certain number of spaces (I forget how many).
07:57:42 <kmc> 8
07:57:50 <kmc> swath, also, did you see hlint?
07:58:03 <byorgey> swath: this leads to indentation errors when you use tabs but display them as some number of spaces other than 8
07:58:13 <swath> i havent seen much, im a newbie.
07:58:27 <Peaker> Haskell has quasiquoting, so 3 layers too
07:58:30 <kmc> hlint will check for many style errors and potential mistakes
07:58:32 <byorgey> swath: it is not an error to use tabs, just strongly recommended against for obvious reasons.
07:58:37 <kmc> Peaker, no it doesn't
07:58:37 <swath> just trying to solve some practical work problems with haskell in the form of working with ugly big data sets
07:58:43 <kmc> also that's not really the same at all
07:59:02 <kmc> swath, you can download hlint; also hpaste.org will run hlint on pasted haskell code
07:59:17 <byorgey> just 'cabal install hlint'
07:59:28 <Peaker> kmc: how do Haskell macros differ from lisp ones except for being a bit harder to work with?
07:59:43 <byorgey> does hlint warn you when you use tabs?
08:00:06 <swath> caball sounds like *nix =p
08:00:23 <kmc> Peaker, there are no Haskell macros
08:00:24 <swath> cabal*
08:00:40 <Peaker> kmc: with {-# LANGUAGE TemplateHaskell #-} enabled
08:00:44 <kmc> but you mean whatever subset of Template Haskell happens to be implemented by GHC today
08:00:49 <kmc> which changes rapidly, btw
08:01:24 <MHD>  hmm
08:01:27 <byorgey> swath: what do you mean?
08:01:34 <MHD> lisps are interesting
08:01:42 <kmc> anyway the key difference is that TH is bolted onto the side, and missing lots of stuff, whereas languages like Lisp are *defined* in terms of interpreting an s-expression as code
08:01:49 <byorgey> swath: it works on Windows too
08:01:53 <swath> ah, i see. cabal is just a haskell add-on type thing
08:01:56 <Peaker> gnome has this wonderful feature of putting windows visually on top, while sending keyboard events to windows on bottom
08:02:03 <byorgey> swath: did you install the Haskell Platform? or just ghc?
08:02:07 <kmc> actually i do not know how Common Lisp is defined; but Scheme is defined this way
08:02:10 <swath> i have the platform.
08:02:15 <byorgey> swath: then you have cabal =)
08:02:22 <kmc> swath, cabal is a utility for downloading / compiling / installing Haskell programs and libraries
08:02:52 <Peaker> kmc: not being the focus of the language is an important difference -- but Haskell with TH/QQ still has 3 layers..
08:03:17 <kmc> sure, if you like
08:03:18 <Saizan> lisp would have 3 layers even without macros
08:03:21 <sshc> Is anybody here aware of a function somewhere that behaves like foldl' but allows users to stop traversing the list (using the current accumulator) at any time?
08:04:18 <benmachine> > foldl f z [a,b,c]
08:04:20 <lambdabot>   f (f (f z a) b) c
08:04:28 * benmachine tries to work out how this would work
08:04:30 <Saizan> sshc: foldM in the Either monad
08:04:42 <byorgey> sshc: sounds like you want a strict foldr perhaps?
08:04:47 <Saizan> (or Cont if you like)
08:04:58 <byorgey> you can't do it with a left fold.
08:05:17 <elliott> > foldr (flip f) z (reverse [a,b,c])
08:05:18 <lambdabot>   f (f (f z a) b) c
08:05:19 <jmcarthur> i think Saizan wins this round
08:05:22 <elliott> You sort of can :P
08:05:34 <Saizan> a strict foldr wouldn't let you stop before having traversed the whole list, it starts processing from the bottom
08:05:42 <Peaker> @src foldM
08:05:42 <lambdabot> foldM _ a []     = return a
08:05:42 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
08:05:46 <Eduard_Munteanu> There might be something like that amongst recursion schemes.
08:05:46 <Saizan> sshc: in fact, you might just want scanl
08:05:50 <Eduard_Munteanu> But I don't know those well.
08:05:56 <Saizan> sshc: take only a prefix of the resulting list
08:06:12 <benmachine> does sound like foldM is the sensible thing
08:06:18 <Eduard_Munteanu> (I mean e.g. catamorphisms)
08:06:37 <Peaker> If you don't have a result when stopping in the middle, then MaybeT is nice
08:06:48 <Peaker> (or Maybe)
08:07:19 <Saizan> > scanl (+) 0 [1..]
08:07:20 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
08:09:02 <sshc> Saizan: Cont seems like the most elegant solution (although Either would work too).  Thanks
08:09:20 <swath> so if im reading a (text) file using readFile, and then i putStr it, the end result is a string, which is an instance of list?
08:09:30 <Peaker> sshc: it's better to use the least-powerful facility that solves the problem.. and Cont is much more powerful than stop-at-middle
08:10:00 <Saizan> ?type let abort x = Cont $ \ _ -> x in abort
08:10:01 <lambdabot> Not in scope: data constructor `Cont'
08:10:06 <Saizan> ?type let abort x = cont $ \ _ -> x in abort
08:10:07 <lambdabot> forall r a. r -> Cont r a
08:10:13 <monochrom> yes string is a list
08:10:27 <swath> so i can use break on a string?
08:10:36 <byorgey> swath: sure
08:10:47 <kmc> "instance of" is not correct terminology
08:10:50 <kmc> but yes, strings are lists
08:10:53 <monochrom> but the end result of putStr is not a string. it's some I/O effects and return value ()
08:10:53 <kmc> type String = [Char]
08:11:23 <swath> crap, so how do i take this IO crap and stringify it?
08:11:28 <byorgey> > break (> 'o') "Hello world!"
08:11:29 <lambdabot>   ("Hello ","world!")
08:11:52 <kmc> swath, why would you want to turn the result of putStr into a string?  if you just want a string, don't putStr it
08:12:03 <swath> but readFile makes it IO
08:12:05 <swath> not a string
08:12:06 <byorgey> swath: in a do-block you can say    str <- readFile "foo"
08:12:07 <swath> i need a string
08:12:10 <byorgey> swath: then str is a String
08:12:20 <kmc> swath, http://www.haskell.org/haskellwiki/Introduction_to_IO
08:12:22 <swath> :t readFile
08:12:23 <lambdabot> FilePath -> IO String
08:12:41 <byorgey> swath: in general if  blah :: IO Foo  and you put    foo <- blah  , then  foo :: Foo
08:13:17 <byorgey> but yes, read the Introduction to IO, ISTR it's pretty good
08:13:58 <monochrom> (you can putStr and have a linux device driver at the receive end, that will get you the string and no IO type)
08:15:31 <byorgey> monochrom: hard to write a linux device driver on Windows ;)
08:15:54 <monochrom> oh, windows
08:16:54 <swath> my workplace uses windows, therefore i do too. pretty simple =p
08:17:38 <monochrom> well then, the receive end could be a VBScript
08:17:44 <ARRG> Hmmm... could someone explain me why :t foldl1 (*) gives [Integer] -> Integer whereas :t foldl1 (max) gives me [()] -> () ? The types for * and max are similar and I don't get why Num gets transformed to Integer, while Ord becomes ().
08:17:44 <byorgey> hehe
08:18:18 <monochrom> @type foldl1 max
08:18:19 <benmachine> ARRG: if you're doing things in ghci then the answer is that ghci is trying to be helpful and doing it badly
08:18:19 <lambdabot> forall a. (Ord a) => [a] -> a
08:18:27 <byorgey> ARRG: it's probably because of defaulting and the monomorphism restriction
08:18:30 <ARRG> Oh :p... ok
08:18:42 <benmachine> ARRG: if you do the same things in a real haskell file you will probably get better results
08:18:50 <ARRG> I'll try
08:18:53 <byorgey> ARRG: I can guess that you did not actually type  :t foldl1 (max)  at the ghci prompt, but rather defined  foo = foldl1 max  and then did  :t foo, right?
08:19:03 <ARRG> Yeah
08:19:04 <Peaker> ARRG: I like to use:    :set -XNoMonomorphismRestriction   (in my ~/.ghci file) so I don't heard of it
08:19:14 <byorgey> ARRG: the best solution is to turn off the monomorphism restriction... like Peaker just suggested
08:19:15 <Peaker> hear*.. the MR is dreadful
08:19:24 <monochrom> in ghci ":type foldl1 max" is "foldl1 max :: Ord a => [a] -> a". ghc version 7.0.3
08:20:00 <byorgey> ARRG: you can also put  {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your .hs file
08:20:03 <monochrom> the peril of lying when you ask questions
08:20:38 <monochrom> (why would answerers encourage such perils by "I guess you really mean ___"?)
08:20:49 <swath> i think im cursed. nothing i wrote works, haha
08:20:55 <swath> write, rather.
08:21:00 <benmachine> monochrom: because we like to be helpful
08:21:03 <monochrom> (just bloody don't guess. make him/her confess lying and tell the truth)
08:21:11 <ARRG> monochrom > I was trying to simply the problem, not to lie :p
08:21:28 <byorgey> monochrom: that just wastes everyone's time.
08:21:29 <ARRG> Thanks anyway it does work from a file, and I will turn off this monomorphism thing
08:22:10 <monochrom> well IMO giving people incentives to be more precise is more helpful. in the long run anyway. every programmer needs that precision. in code. in docs. in specs. everywhere.
08:22:26 <byorgey> simplifying the problem before asking a question is a time-honored tradition, so you don't burden the people you're asking with extraneous details.  it just takes a while to learn which details are important.
08:22:55 <benmachine> besides, people don't like to be told they're lying
08:23:15 <monochrom> part of properly simplifying the problem is actually testing ":type foldl1 max" before asking
08:23:31 <monochrom> emphasis on *properly*
08:23:35 <benmachine> sure
08:23:41 <benmachine> some people don't pose questions properly
08:23:45 <benmachine> we try to answer them anyway
08:24:33 <byorgey> swath: if you paste what you have on hpaste.org we can take a look
08:24:49 * hackagebot http-enumerator 0.7.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.0 (MichaelSnoyman)
08:24:51 * hackagebot uri-enumerator 0.0.0 - Read and write URIs  http://hackage.haskell.org/package/uri-enumerator-0.0.0 (MichaelSnoyman)
08:25:53 <Saizan> to be pragmatic, reducing from 2 lines of code to 1 is never going to be a win
08:26:10 <benmachine> snoyman doesn't shy away from dependency lists :<
08:26:35 <hpaste> swath pasted â€œsimple parsing failâ€ at http://hpaste.org/50981
08:26:46 <swath> =p
08:26:52 <swath> im so bad its not even funny, go easy on me
08:27:13 <fryguybob> swath: let hcontents = breakh contents
08:27:19 <Peaker> swath: starting with Haskell is difficult :)
08:27:30 <Peaker> (especially with background in imperative languages)
08:27:44 <swath> peaker, i have no background at all pretty much, except in maths
08:28:30 <Peaker> swath: ah, then Haskell should be easier.. it will still take a while to get used to the type system (especially the IO type stuff) and error messages
08:29:53 * hackagebot xml2html 0.0.0 - blaze-html instances for xml-enumerator types  http://hackage.haskell.org/package/xml2html-0.0.0 (MichaelSnoyman)
08:29:55 * hackagebot xml-catalog 0.0.0 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.0.0 (MichaelSnoyman)
08:29:57 * hackagebot xml-enumerator 0.4.0 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.4.0 (MichaelSnoyman)
08:29:59 * hackagebot xml-hamlet 0.1.0 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.1.0 (MichaelSnoyman)
08:30:01 <swath> i basically just want to start with a text file, then break it up into a list of lists, at specified spots. should be easy, but im struggling hard lol
08:30:36 <companion_cube> :t interact lines
08:30:37 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
08:30:37 <lambdabot>       Expected type: String
08:30:37 <lambdabot>       Inferred type: [String]
08:30:48 <Saizan> swath: replace line 6 with "let hcontents = breakh contents" as fryguybob suggests
08:31:00 <swath> i did, its still failing
08:31:05 <Peaker> swath: In IO "do" blocks, each statement (statement=line, typically, but you can add more lines to the same statement by indenting them) is one of:   "let <bindings>",   "<expression>",   or "name <- <expression>"   in the latter two forms, the <expression> must be of IO type
08:31:13 <ARRG> byorgey > I'm actually surprised that :type -checking an expression or its let-bound name makes a difference. Is this also true out of ghci ?
08:31:39 <fryguybob> @type putStr -- swath
08:31:40 <lambdabot> String -> IO ()
08:31:43 <Saizan> swath: ah, yeah, because breakh returns a pair of strings, while puStr wants just one
08:31:48 <fryguybob> @type print -- swath
08:31:49 <lambdabot> forall a. (Show a) => a -> IO ()
08:31:55 <Saizan> swath: so you've to pick one of them
08:32:25 <Saizan> swath: e.g. "putStr (fst hcontents)" for line 7 would print the first of the two
08:32:42 <hpaste> monochrom annotated â€œsimple parsing failâ€ with â€œsimple parsing fail (annotation)â€ at http://hpaste.org/50981#a50982
08:33:01 <Peaker> also:  let (header, footer) = breakh contents     would also work
08:33:56 <byorgey> ARRG: yes, it is surprising.  It's because of the monomorphism restriction, and yes, it's also true in ghci.
08:34:00 <monochrom> oh haha, if I annotate that in turn, it becomes "simple parsing fail (annotation) (annotation)"
08:34:30 <byorgey> ARRG: essentially, the idea is that when you define something of the form  foo = blah,  you may expect that foo will only be computed once
08:34:51 <byorgey> ARRG: but if it is type-class polymorphic, it will in fact be recomputed every time
08:34:52 <swath> monochrom's suggestions worked
08:34:54 <swath> thank you kindly!
08:35:23 <byorgey> ARRG: so the monomorphism restriction says that certain things of the form foo = blah must be monomorphic to avoid this recomputation
08:35:30 <Peaker> swath: playing with pure values in ghci is easier, when starting out, than writing correct IO programs in files
08:35:36 <byorgey> ARRG: but as you have seen, this usually causes more confusion than it saves.
08:36:19 <byorgey> ARRG: in fact it is likely that the monomorphism restriction will be removed from a future Haskell standard.  Hence our recommendation to just turn it off.
08:36:25 <swath> peaker, but im trying to do something that would actually save me and my coworkers a lot of time. so my hands are going to get dirty regardless.
08:36:41 <swath> once i have the data in a pure form, im hoping it will be easy again
08:37:03 <ARRG> byorgey > okay, interesting thanks. And so what is the fundamental difference between * and max that makes one work and the other fail ? I guess the difference comes from what Ord and Num are respectively but I don't really understand what it is
08:37:04 <monochrom> @tell chrisdone next April 1, I suggest this prank on hpaste: the nth annotation has its title formed by appending fib n copies of "(annotation)", instead of just n copies
08:37:05 <lambdabot> Consider it noted.
08:37:05 <Peaker> swath: one important principle of good design is to make your IO side a small wrapper for the rest of the program which should be pure
08:37:31 <swath> peaker: maybe i should get rid of the "do" approach altogether, then?
08:37:36 <Peaker> ARRG: I think it is the ugly default Num instance rules
08:37:41 <byorgey> ARRG: well, you were also running afoul of ghci's rather aggressive type-defaulting rules
08:37:46 <swath> i actually dont like this whole "do" thing
08:38:04 <swath> id rather work on functions that just call eachother, and i choose the first one that gets called
08:38:05 <Peaker> swath: "do" is nice syntax, but when gaining an initial understanding, it helps to use (>>=) and (>>) directly
08:38:09 <byorgey> ARRG: if there is a type  Num a =>  a ...  and it doesn't know which type to pick, by default it picks Integer
08:38:10 <monochrom> if you don't like "do", you can use >>= and a lot of lambdas
08:38:15 <byorgey> ARRG: but for Ord it picks ()
08:38:42 <ARRG> Okay so that's not a thing in the type system per se
08:38:51 <byorgey> ARRG: right, it isn't
08:39:00 <ARRG> Thank you :)
08:39:04 <byorgey> ARRG: sure =)
08:39:21 <hpaste> monochrom annotated â€œsimple parsing failâ€ with â€œsimple parsing fail (annotation) (annotation)â€ at http://hpaste.org/50981#a50984
08:39:51 <byorgey> ARRG: if you write   foldl1 max "abrfojwelkjfg"  it will work just fine, since then it knows to pick Char
08:40:28 <byorgey> ARRG: but of course if you turn off the MR this will not be an issue anyway.
08:42:13 <swath> so putStr is kind of useless it seems anyway, at least for my purposes lol
08:42:20 <swath> i'll have to define my own function that works a bit better for what i want
08:46:53 <swath> IO makes everything overcomplicated
08:47:04 <swath> i can see why making it a small wrapper type thing is the way to go
08:47:12 <swath> de-emphasize it as much as possible
08:49:25 <swath> hrm, using break with characters like "(" seems to be throwing me off...
08:49:25 <kmc> that's really not how it works
08:49:35 <kmc> it's not a wrapper, and it's not deemphasized
08:49:47 <kmc> Haskell has lots of support for imperative programming
08:49:49 <swath> like if i want to break at any "H(" within a string?
08:49:54 <kmc> it has stuff like STM which few other imperative languages have
08:50:12 <kmc> it just takes more than an hour to get used to the way imperative programming works in Haskell
08:51:01 <swath> i have no interest in programming imperatively. i just want to define lots of functions and at the end of the day type in giveMyResult input.txt
08:51:05 <swath> and have it tell me what i want
08:51:26 <kmc> :t interact
08:51:27 <lambdabot> (String -> String) -> IO ()
08:53:13 <engla> yeah, if you use interact you can make a filter function and ignore IO in the rest of the program
08:53:49 <kmc> swath, anyway i wasn't saying you're doing imperative programming.  i was responding to your comment about why IO is designed how it is
08:53:56 <swath> so my main statement would be interact (filter)?
08:54:05 <kmc> yes (but you don't need the parentheses)
08:54:19 <swath> well, filter could be many things, or something
08:54:34 <swath> interact stuff
08:55:27 <swath> i guess IO is designed how it is because it's so...deadly
08:55:30 <swath> ?
08:55:44 <swath> it's like, contaminated, disgusting
08:56:03 <kmc> no
08:56:13 <kmc> sometimes people see it this way, but i think it's unhelpful
08:56:39 <kmc> you're thinking that IO is just a "taint bit" applied to values
08:56:42 <kmc> that's not how it works
08:56:50 <kmc> a value of type (IO Int) is not a "tainted Int"
08:56:58 <swath> then what the hell is it?
08:56:59 <kmc> it's an imperative program which produces Ints
08:57:10 <kmc> the program hasn't been run yet
08:57:21 <kmc> you might never run it, or you might run it more than once and get different values each time
08:57:29 <kmc> Haskell programs are functional programs which compute imperative programs
08:57:35 <swath> so it's like, a current Int
08:57:42 <swath> rather than a static int
08:57:45 <swath> it's like flexible or something
08:57:49 <kmc> no
08:57:53 <kmc> it's a program which produces Ints
08:57:57 <drdo> no, it's more like a computation that produces an Int
08:57:59 <kmc> a recipe for producing Ints
08:58:04 <kmc> the recipe is not the cake
08:58:06 <gentleben> are there any good docs on the"SYSTEM" cost centre?
08:58:09 <swath> so it's a function that grabs an int
08:58:20 <kmc> it's something that in other languages would be called a function
08:58:35 <gentleben> I am trying to run down some runaway allocaitons
08:59:00 <kmc> in most languages you use functions for argument dependence, side effects, and delayed evaluation
08:59:06 <kmc> Haskell has different constructs for each of these
08:59:47 <swath> i see. so i can't directly evaluate IO data with list functions or whatever until i name it separately or something, or at the least distinguish the data from the IO data.
08:59:49 * hackagebot egison 0.3.1.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.3.1.0 (SatoshiEgi)
09:01:03 <kmc> you're still thinking in terms of tainted vs untainted values
09:01:03 <kmc> instead think of it this way:  you can't use the result of a program until you run it
09:01:03 <kmc> the IO values are programs
09:01:03 <swath> how else can i think? im reading a file, but the file isnt a string yet, its an IO String, whatever the heck that means. the file is a recipe?
09:01:03 <kmc> "read this file" is a description of IO which could be performed
09:01:13 <kmc> swath, did you read that Introduction to IO document?
09:01:49 <swath> i skimmed it
09:01:49 <kmc> ok
09:01:49 <kmc> read it for real
09:01:49 <kmc> it's not long
09:02:09 <hpc> swath: readFile :: String -> IO String; foo = readFile "/var/foo"; foo :: IO String
09:02:25 <hpc> foo = "read in the file and hold onto a string that is the contents of the file"
09:02:42 <hpc> biggerfoo = foo >>= \x -> blahblahblah
09:02:59 <kmc> swath, "whatever the heck that means"  â† i told you what it means, and so does the IO article
09:03:06 <hpc> biggerfoo = "read in the file, then do blahblahblah, where x is the string that we read from the file"
09:13:00 <mux> http://okmij.org/ftp/continuations/zipper.html#traversable <- this is great
09:13:10 <mux> dons: thanks for posting it to reddit :-)
09:13:24 <monochrom> oh mux, have you seen my ackermann in system f? :)
09:13:40 <mux> oh, no I didn't, please shoot! :-)
09:14:31 <monochrom> it's in http://hpaste.org/50940
09:16:02 <mux> holy induction batman
09:16:04 <mux> this is good
09:16:08 <monochrom> haha
09:16:15 <copumpkin> this is fun: http://okmij.org/ftp/Haskell/impredicativity-bites.html
09:16:47 <monochrom> it's pretty easy once I stopped thinking and started calculating, as Dijkstra said so.
09:17:20 <monochrom> (well, what Dijkstra said was s/thinking/interpreting/ )
09:17:34 <mux> I should try it with the system F interpreter from TAPL
09:17:45 <Eduard_Munteanu> As if Haskell weren't inconsistent already :)
09:17:53 <mux> where the heck did I put this
09:17:55 <monochrom> (i.e., he said, don't interpret [the meaning of] the formulas, just manipulate them uninterpreted)
09:18:29 <Eduard_Munteanu> Though injectivity bit Agda as well in the past, no?
09:18:31 <mux> seems like my system F code I was so prouf of found its way into /dev/null
09:18:34 <copumpkin> Eduard_Munteanu: this one doesn't use general recursion though
09:18:41 <copumpkin> or premade bottom values
09:18:45 <monochrom> yeah, thank Peirce for implementations of various type systems
09:19:35 <monochrom> well impredicativity+typecase is bad enough already. (loses parametricity.)
09:19:49 * hackagebot authenticate 0.10.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.10.2 (MichaelSnoyman)
09:19:51 * hackagebot mime-mail-ses 0.0.0.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.0.0.2 (MichaelSnoyman)
09:19:53 * hackagebot yesod-auth 0.7.1.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.1.1 (MichaelSnoyman)
09:20:02 <monochrom> (also loses normalization, doesn't it?)
09:21:08 <sshc> What is an efficient data structure that's well suited for a fixed-size queue (once it fills up)?  For example, I might use one of these queues to record the last three keystrokes on the title screen of a game.  It's initially empty, "[]".  I press 'C' and then 'H', so the queue is now [H, C] (head is most recent).  Then I press 'A', so the quue is ['A','H','C'].  After I press 'N', the queue is
09:21:14 <sshc> ['N','A','H'] ('C', the oldest element, was popped from the queue).
09:22:26 <kmc> sshc, Data.Sequence perhaps
09:22:31 <kmc> there are specialized queue types too
09:22:46 <kmc> how big is the queue actually?
09:23:44 <sshc> kmc: It arbitrarily varies
09:23:48 * sshc looks at Data.Sequence
09:24:46 <sshc> Ah, seuqences are much more efficient than lists for this
09:27:14 <roconnor_> would a ciruclar buffer (and array) be good for sshc's fixed sized queue?
09:27:32 <kmc> not immutably
09:27:46 <kmc> maybe if it's really small
09:28:04 <roconnor> ya I guess if you have to copy the entire array on each enqueue and dequeue it would be bad
09:28:12 <roconnor> though in the ST monad it wouldn't be so bad.
09:28:24 <roconnor> depends on the application I guess
09:28:26 <kmc> you can copy a 16-byte queue in one or two instructions on x86
09:29:22 <hpc> depends on if it is in a register or not
09:29:50 * hackagebot RNAwolf 0.3.2.0 - RNA folding with non-canonical basepairs and base-triplets.  http://hackage.haskell.org/package/RNAwolf-0.3.2.0 (ChristianHoener)
09:30:04 <roconnor> 16-bytes is enough for anyone
09:32:42 <tromp> > (\_ -> _) ()
09:32:43 <lambdabot>   Pattern syntax in expression context: _
09:33:23 <tromp> > let _ = () in _
09:33:24 <lambdabot>   Pattern syntax in expression context: _
09:33:38 <kmc> > _
09:33:39 <lambdabot>   Pattern syntax in expression context: _
09:33:48 <tromp> > let __ = () in __
09:33:49 <lambdabot>   ()
09:35:19 <sshc> roconnor, kmc: I only need a push operation (which pops the oldest element if the queue is full) and a way to "convert" it to a list when I'm done
09:35:57 <brisingr> dumb question: can all Functors be made instances of Monad?
09:36:11 <roconnor> brisingr: nope
09:36:13 <brisingr> been bugging me for a while, couldn't find a counterexample
09:36:25 <kmc> sshc, pretty easy to implement with Sequence
09:36:37 <brisingr> so what's the functor that isn't a monad, too?
09:36:37 <roconnor> brisingr: there was a recent reddit thread on this
09:36:37 <kmc> brisingr, there was a recent SO question about that, i think
09:36:42 * roconnor tries to find it
09:36:42 <kmc> or that
09:36:50 <roconnor> oh maybe it was SO
09:38:36 <sshc> brisingr: You'd need to derive both "a -> f a" and "f a -> (a -> f b)" from just "(a -> b) -> (f a -> f b)"
09:38:44 <roconnor> brisingr: http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad/7220865#7220865
09:39:08 <roconnor> brisingr: lists examples of non-functors, functors that are not applicative, applicative that is not monad, and monad.
09:39:22 <applicative> oh yeah, awesome reply from Conor McB
09:39:38 <brisingr> thank you very much
09:40:01 <roconnor> brisingr: the examples are very very simple and not entirely useful other than to illustrate
09:40:57 <rwbarton> his dismissal of Void is a bit flimsy IMO
09:41:05 <brisingr> and then the next stupid question emerges: apart from artificial examples, are most functors used in ha
09:41:06 <applicative> maybe too simple to be intelligible...
09:41:12 <brisingr> haskell monads too?
09:41:38 <rwbarton> I mean it's fine to ignore _|_ if that is what one wants to do, but the question seems to be well-formed if one does not ignore _|_ as well
09:41:54 <brisingr> it seems pretty natural that we'd usually want a functor to be a monad too
09:42:05 <roconnor> brisingr: that is harder to judge
09:42:07 <brisingr> In my defense, I did say usually
09:43:04 <roconnor> brisingr: BTW, I use often use reader(-like) monads using applicative style since, although they are monads, the extra monad functionality isn't very useful and I prefer the applicative style.
09:43:30 <brisingr> I see
09:43:38 <roconnor> indeed, I also use monads in applicative style whenever I can get away with it.
09:44:43 <applicative> Set in the sense of Data.Set isn't a monad, right?
09:45:27 <roconnor> applicative: it is a monad, but not in the Haskell sense of the word.
09:46:03 <ptc> Do people use hasktags? Does it work for them? Running into some trouble myself...
09:46:10 <applicative> I havent thought about this for a while, is Set in the Data.Set sense a Haskell Functor type?
09:46:24 <swath> this is going to be a really stupid question, but since every type of list is it's own type eg [String, String] is different from [String, String, String], if i'm define a function that takes [String] and returns [String, String, ..., String], with the number of elements int he list depending on input, how do i handle the type of the output?
09:46:32 <rwbarton> the question is a bit uncomfortable, since Set a is generally considered to "make sense" only when a has an Ord instance and the usually considered equality on Set a is not structural equality
09:46:48 <applicative> swath, "stupid" questions are what we are here for...
09:47:29 <ptc> swath: I think you're thinking of tuples? Lists can only contain one type, which in the case of [String, Stringâ€¦] is just [[Char]]
09:47:30 <applicative> swath [String,String] is not a type name, do you mean the pair of tuple type (String,String)?
09:48:00 <swath> ah, so im mixing tuples in for no reason
09:48:21 <swath> thanks ptc/applicative
09:48:26 <ptc> np
09:48:36 <applicative> swath, yes there is some unclarity on that in your question.
09:49:33 <dmwit> :t cont
09:49:35 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
09:49:41 <dmwit> :t traverse
09:49:42 <swath> i think [[Char]] will be sufficient for me.
09:49:42 <lambdabot> Not in scope: `traverse'
09:49:52 <dmwit> :t Data.Traversable.traverse
09:49:53 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:51:03 <dmwit> huh
09:52:06 <dmwit> Oh, I see.
09:54:16 <azaq23> swath: Haskell lists are linked lists, can only take one type and are defined as the recursive datatype data List t = Cons t (List t) | Nil - tuples take more than one type and only make n values of
09:54:17 <azaq23> each type available at the same time (assuming an n-tuple) (tuples are haskell product types)
09:55:32 <swath> yeah i think i may eventually turn my stuff into a tuple, but i dont need that type yet
10:03:58 <elliott> Is there anything standard for a "full" associative map? i.e., always created with defaults for the whole keyspace, lookups don't return Maybe, and no delete.
10:04:09 <elliott> I can just use Data.Maps but it results in some ugly fromJusts.
10:06:08 <EvanR-work> elliott: Array ;)
10:06:19 <elliott> I suppose that works :P
10:06:49 <joachi> "liftA2"? they're not very good at naming things
10:06:58 <elliott> Hmm, it might even be feasible; Ix looks pretty simple
10:07:25 <elliott> joachi: liftA2 = lift a two-argument function to an applicative
10:07:35 <elliott> like liftM2, the same for monads
10:07:44 <elliott> (likewise liftM, liftM3...)
10:07:46 <applicative> liftA2 is from liftM2 , liftM2 from liftM
10:08:13 <applicative> there was a general rule in some earlier period of putting M at the end of 'monadic' operations
10:08:37 <elliott> fM >>=M returnM
10:08:45 <EvanR-work> lol
10:09:00 <monochrom> a wrapper over Data.Map (or hash map) will work. yes there are a couple of ugly fromMaybes or pattern matchings, this is why you wrap it once and for all
10:09:23 <applicative> joachi, but why write liftA2 af ax ay when you can write af <*> ax <*> ay ?
10:09:30 <monochrom> oh, you mean anything standard. no, not yet. :)
10:09:35 <elliott> applicative: those aren't the same thing
10:10:05 <elliott> monochrom: yeah, I was just thinking that an array would be a better way of storing it... but ha, that's literally just an array, so I'll make an arry
10:10:06 <elliott> array
10:10:07 <joachi> applicative: i just read about how liftA2 does that
10:10:10 <applicative> sorry, <$> for <*> hit return too often
10:10:16 <joachi> still pretty cryptic naming
10:10:23 <EvanR-work> elliott: except for performance issues with updating
10:10:27 <elliott> better cryptic than painful
10:10:28 <monochrom> array works if the domain is small enough
10:10:38 <elliott> The keyset's twenty-six items big, so I'm not too worried
10:10:49 <EvanR-work> either way, the implementation should be hidden frmo the interface
10:10:53 <monochrom> haha, yeah 26 is small :)
10:11:00 <elliott> I could do it as a tuple
10:11:04 <elliott> (a,a,a,a,a,a,a,a,a,a,a, I've lost count
10:11:11 * monochrom giggles
10:11:17 <EvanR-work> that would suck
10:11:24 <applicative> liftA2 takes a two place function a -> b -> c , and 'lifts' it into [a] -> [b] -> [c] or IO a -> IO b -> IO c
10:11:33 <EvanR-work> twentysecondth
10:11:46 <luite> you could make a lookupDefault :: (Ord k, Default v) => k -> Map k v -> v
10:12:06 <joachi> why do they call it "lifting"?
10:12:13 <monochrom> a few days ago someone asked "I want to use foldl' to count letter frequency. I don't want to use 26 foldl's". I answered "fold over a Data.Map or a 26-tuple!"
10:12:25 <applicative> joachi, it's a good metaphor, lifting, raising
10:12:28 <monochrom> everyone liked the 26-tuple option :)
10:12:42 <ciaranm> you're forgetting the unicodes!
10:12:44 <elliott> hmm, what we really need is a bunch of machine-generated code for numerical access to N-ples
10:12:59 <elliott> onehundredandfourteenth :: (Onehundredandfourteenthple xs x) => xs -> x
10:13:04 <monochrom> yeah I was forgetting the unicodes
10:13:17 <applicative> joachi, so 'fmap' lifts a function a -> b and elevates it into the world of Foo a and Foo b for some Functor type Foo _
10:14:20 <ciaranm> :t (,,,,,,,,,,,,,,,,,,,,,,,,,)
10:14:21 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (a, b, c,
10:14:22 <lambdabot>  d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z)
10:14:26 <joachi> is that type of thing used often then?
10:14:32 <elliott> joachi: all the time
10:14:40 <elliott> fmap is usually called (<$>)
10:14:48 <applicative> joachi,its all we eve do, it's a dream
10:14:51 <elliott> foo <- transformResult <$> getFromDatabase
10:14:57 <applicative> all we ever do.
10:15:57 <applicative> > liftA2 (+) [1,2,3] [10,20,30]
10:15:58 <lambdabot>   [11,21,31,12,22,32,13,23,33]
10:16:03 <sbrg> ciaranm: Nice.
10:16:23 <applicative> > fmap (+10) [1,2,3]
10:16:24 <lambdabot>   [11,12,13]
10:16:27 <sbrg> Now I can tell my friends "Haskell has a built-in way to print the alphabet using the type system without ever mentioning 'Char' or 'Int'"
10:16:41 <sbrg> (so and so)
10:17:56 <applicative> sbrg, now you must figure out how to employ the typechecker as a spell-checker
10:18:08 <sbrg> applicative: oleg did it
10:18:10 <sbrg> in the type system
10:18:14 <applicative> no!
10:18:15 <sbrg> (Did I do it right?)
10:18:27 <sbrg> I need that t-shirt
10:18:30 <monochrom> @quote olge
10:18:30 <lambdabot> gwern says: Haskellers! Tonight we write in Malbolge!
10:18:34 <monochrom> @quote oleg
10:18:35 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
10:18:43 <monochrom> @quote oleg
10:18:44 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
10:18:52 <joachi> <$> used with IO actions is pretty cool.
10:18:55 <gwern> hehe. writing in malbolge is worse than dining in hell
10:18:59 * applicative wonders what he meant by that
10:19:05 <sbrg> gwern: I hear hell is pretty nice.
10:19:07 <elliott> joachi: also lists: you may have heard of it as "map" :-)
10:19:16 <sbrg> It's a dry heat, supposedly
10:19:19 <gwern> sbrg: satan is the prince of lies, keep in mind
10:19:48 <sbrg> gwern: Oh, I heard it from a guy who moved there last year.
10:20:06 <applicative> joachi, yes, but  liftA2 (++) (readFile x) (readFile y) is the same idea, for two places. It 'returns' the concatenation of the fileContents
10:20:12 <gwern> sbrg: pfft, yeah. welcome to chiron beta prime...
10:20:44 <sbrg> lol
10:32:19 <swath> opinions on the best books on haskell that are fairly comprehensive with lots of examples?
10:32:41 <swath> i found some lists online, but almost all seem somewhat dated
10:33:29 <hpc> LYAH is a good one
10:33:33 <Lemmih> swath: The new ones are LYAH and RWH.
10:34:06 <applicative> @where LYAH
10:34:06 <lambdabot> http://www.learnyouahaskell.com/
10:34:22 <swath> learn you a haskell is much too light for what im looking for
10:34:32 <applicative> @where RWH
10:34:32 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:35:25 <applicative> swath, there are a lot of examples in RWH, some of them use advanced libraries, so they are already a little broken here or there.
10:36:30 <applicative> swath, but in fact its quite up to date of course
10:36:47 <swath> my problem is that very few people seem to really get intot he nitty gritty of just plain old syntax, but i can pick up a lot of it by looking at how examples are implemented, and the more complex or nuanced the example the more syntax i can gleen from it
10:37:41 <swath> for instance, how do i use a function like break if i want it to break at a quotation mark, or parenthesis?
10:37:52 <swath> since im using that syntax to describe where i want to break already
10:37:54 <applicative> swath, right, it is frequently difficult to find examples that suit one's level; this holds though one's level keeps changing.
10:37:56 <swath> i just seem to confuse the compiler
10:38:04 <applicative> @type break
10:38:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:38:22 <applicative> > break (== 'a') "hah"
10:38:23 <lambdabot>   ("h","ah")
10:38:31 <Saizan> swath: character have to appear between single quotes
10:38:36 <Saizan> > ')'
10:38:37 <lambdabot>   ')'
10:38:43 <Saizan> > '?'
10:38:44 <lambdabot>   '?'
10:38:56 <swath> break (== 'H(') "aH(ah"
10:39:11 <swath> > break (== 'H(') "aH(ah"
10:39:13 <sbrg> swath: that's two characters
10:39:13 <lambdabot>   <no location info>:
10:39:13 <lambdabot>      lexical error in string/character literal at chara...
10:39:19 <applicative> swath you want something different
10:39:28 <applicative> try the library Data.Split
10:39:37 <Saizan> H( would be 2 characters, you can use double quotes for strings: "H("
10:39:46 <Saizan> though break won't help with that then
10:39:58 <swath> lol
10:40:09 <Saizan> since the predicate is supposed to look at a single character at a time
10:40:15 <swath> turtles beneath turtles!!!!!
10:40:54 <applicative> http://hackage.haskell.org/packages/archive/split/0.1.4.1/doc/html/Data-List-Split.html
10:41:24 <swath> yeah, reading it already
10:41:29 <swath> seems to be perfect, ironically
10:41:30 <Saizan> > find (\(_,xs) -> "H(" `isPrefixOf` xs) . tails $ "aH(ah"
10:41:31 <lambdabot>   Couldn't match expected type `(t, [GHC.Types.Char])'
10:41:31 <lambdabot>         against inferr...
10:41:46 <applicative> sorry, that page isn't opening for me, try http://hackage.haskell.org/package/split/ swath
10:42:41 <swath> > splitOn "H(" "ahaH(ahaH(a"
10:42:42 <lambdabot>   Not in scope: `splitOn'
10:42:42 <swath> boo.
10:42:51 <Saizan> we should have a zipper in the stdlibs
10:43:06 <applicative> annoying that splitOn isn't there
10:43:08 <swath> > import Data.List.Split
10:43:09 <lambdabot>   <no location info>: parse error on input `import'
10:54:15 <sshc> kmc: How should I implement the push function, particularly popping the other end?  I don't see anything in http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html that permits me to pop an element from an end of a sequence
10:55:34 <Saizan> sshc: viewr
10:56:18 <sshc> Saizan: Ah; thanks.
10:59:31 <kmc> viewr is nice with ViewPatterns, but you can use it without
10:59:48 <ARRG> @src on
10:59:49 <lambdabot> (*) `on` f = \x y -> f x * f y
11:02:09 <swath> why is haskell so unpopular compared to the big imperative languages?
11:02:22 <swath> i kind of dont understand why certain languages are popular
11:02:55 <EvanR-work> swath: popularity is inversely proportional to quality
11:03:07 <EvanR-work> i.e. worse is better
11:03:35 <ARRG> EvanR-work > PHP isn't that big :o
11:03:41 <swath> you wouldn't think that would be true amongst people as intelligent as professional computer programmers
11:03:45 <EvanR-work> php is hugely popular
11:03:49 <mike-burns> Killer apps.
11:03:59 <EvanR-work> haskell is too 'acadmic'
11:04:04 <EvanR-work> i dont get monads
11:04:05 <mike-burns> PHP, Ruby, C all have killer apps. C# and Java have tons of marketing.
11:04:18 <mike-burns> This isn't about the language, it's about other things.
11:04:34 <EvanR-work> er whats Cs killer app
11:04:36 <swath> but academics is about getting shit done. its just about getting HARD shit done, generally
11:04:37 <mike-burns> unix
11:04:47 <EvanR-work> lol
11:04:57 <ciaranm> half the world runs on c
11:04:59 <EvanR-work> whats c++ killer app
11:05:02 <mike-burns> games.
11:05:07 <EvanR-work> thats not an app
11:05:11 <ciaranm> EvanR-work: your desktop
11:05:15 <hpc> the source engine is entirely C++
11:05:17 <EvanR-work> not my desktop
11:05:19 <geheimdienst> swath: in my view, haskell has some weak spots regarding documentation and teaching. the haddock pages, even for the "base" package, are often incomplete, unhelpful, and devoid of examples. that's very unfortunate
11:05:21 <elliott> "thats not an app" you're kidding right
11:05:24 <ciaranm> your browser is written in c++
11:05:31 <EvanR-work> 'computer games' isnt a killer app
11:05:35 <EvanR-work> thats like 'operating systems'
11:05:41 <mike-burns> Or unix
11:06:07 <swath> geheimdienst: i can agree with that in my experience. it seems i have like literally 2 - 3 books to choose from...and all will be incomplete
11:06:09 <ARRG> C runs (on) most embedded systems too, which is a significant part of its market share
11:06:32 <EvanR-work> swath: you can only learn haskell by reading and writing code
11:06:38 <ciaranm> if you want a measure of whether or not you can write real programs in haskell, try asking people to name ten real programs written in haskell. and you'll see that they'll dignify you with an attempt at an answer.
11:06:48 <mike-burns> This isn't to say that Haskell wouldn't be awesome at these things; just that no one has made The Killer App of Haskell.
11:06:49 <swath> that's a blatant lie, evanr.
11:06:55 <mike-burns> It'll probably be FRP.
11:07:05 <ciaranm> ask people to name ten real programs written in c and they'll laugh at you
11:07:06 <elliott> k
11:07:07 <elliott> oops
11:07:17 <EvanR-work> mike-burns: well its going to be hard to write 'games' in haskell
11:07:26 <EvanR-work> i.e. as many games as c++
11:07:26 <swath> games have already been written in haskell
11:07:29 <hpc> ciaranm: most haskell programs are internal tools
11:07:29 <mike-burns> This is true; most of the engines are in C++.
11:07:54 <swath> certain types of games would probably be easier to write in haskell than other languages
11:08:02 <swath> lets say your game takes place inside of a fractal.
11:08:06 <EvanR-work> lol
11:08:06 <ciaranm> which is kinda funny, because c++ programmers tend to consider games programers to be scum
11:08:41 <EvanR-work> in order to see why haskell isnt accepted, look at why scala and f# are 'accepted'
11:08:43 <Nimatek> Carmack recently shit all over programmatically generated content, rightfully so, imo.
11:08:47 <Nimatek> shat*
11:09:04 <swath> what do you mean by "programmatically generated content"
11:09:13 <ciaranm> scala and f# are accepted because you can take code written in either and run it on a real computer
11:09:16 <Nimatek> I meant procedurally generated.
11:09:18 <mike-burns> Most of this software is easier to write in Haskell, in some aspect, but there's more to it than just writing a game that is inside a fractal. There's the game engine, the known optimizations, the existing communities.
11:09:37 <ciaranm> (since unfortunately a jvm counts as a real computer now)
11:09:39 <mike-burns> Scala is great because I can write Android apps using it.
11:09:45 <swath> niamtek: as a principle, or shat on the way people were doing it?
11:10:09 <Nimatek> swath: As a principle.
11:10:10 <swath> because generating data procedurally is a pretty generic principle, and central to like, all of computer science.
11:10:23 <EvanR-work> yeah, tell carmack to stop using compression plz
11:10:44 <EvanR-work> its algorithically generated content
11:10:44 <TTimo> he was just saying that you can't replace a good artist with algorithms. pretty much unrelated to functional vs procedural
11:10:56 <Nimatek> No, in games not in all computer science.
11:11:10 <swath> tell him to play ADoM
11:11:11 <Nimatek> TTimo: Precisely.
11:11:45 <EvanR-work> TTimo: well, good artists can be used to make generated content, like the artist chose the sequence of brush stokes to store
11:11:46 <ARRG> ciaranm > isn't there a JHaskell somewhere ?
11:12:20 <swath> artists who make good procedurally generated content are generally referred to mathematicians.
11:12:25 <swath> does carmack not like mathematics?
11:12:26 <EvanR-work> lol
11:12:28 <TTimo> ahah swath
11:12:31 <TTimo> very true
11:13:33 <TTimo> swath: I don't think he likes mathematics no. He never went to college. He absorbs math strictly as a means to an end
11:14:36 <TTimo> all the internal id matrix code is column major ;-(
11:14:40 <EvanR-work> lol
11:14:47 <EvanR-work> time to pass judgment
11:14:49 <EvanR-work> on the man
11:14:49 <swath> my h askell project is to do datamining for my company as a bit of a hobby and hope to grow something out of it. a lot of white collar types are currently doing a crude version of what im picturing with crap-tastic excel, i think i can do a better job with haskell, or at least writing some tools and at least giving the tools to them, lol
11:15:02 <swath> and i picture a lot of haskell being done on this type of scale, so you never see a lot of "killer aps"
11:15:09 <swath> because its just proprietary internal code owned by companies
11:15:14 <swath> that they will never ever share or release
11:16:06 <swath> montsanto uses haskell, so does google, and various financial groups for quantitative analysis...
11:16:13 <kmc> yep exactly
11:16:16 <kmc> monsanto uses it?
11:16:18 <swath> all of which falls under some umbrella of either data mining or data management
11:16:18 <swath> yes
11:16:34 <kmc> hey, there was a big reddit thread about "what would you change in Haskell" a while back
11:16:36 <kmc> anyone have a link?
11:16:48 <ciaranm> reddit.com
11:16:49 <ciaranm> hth
11:16:52 <copumpkin> swath: do they use haskell for evil?
11:17:21 <swath> Yes.
11:17:21 <kmc> http://www.reddit.com/r/haskell/comments/fvabx/greenfield_haskell/
11:17:32 <applicative> copumpkin, but (to paraphrase President Nixon) if you use haskell to do it, it isn't evil.
11:17:35 <swath> montanto i believe has developed haskell code that tries to optimize the number of farmers they fuck over, per year
11:17:46 <copumpkin> oh sweet
11:17:48 <copumpkin> sounds like my kind of job
11:17:55 <copumpkin> except I generally prefer the farm animals to the farmers
11:18:34 <swath> but dont even get me started on montsanto, i could rant all day lol
11:18:46 <ciaranm> hey, monsanto has greenpeace doing lobbying for it. lets them get away with all kinds of crazy stuff.
11:18:58 <swath> they're evil.
11:18:58 * applicative is genetically modified
11:19:38 <swath> there's nothing wrong with genetically modifying stuff. there is something wrong with deliberately leaving in it's ability to reproduce and pollinate other's crops, then suing the people who get their stuff pollinated.
11:19:40 <applicative> copumpkin, what do you make of the Better Do? controversy
11:19:50 <copumpkin> applicative: I started it
11:20:02 <ciaranm> swath: funny story about that: the reason they do that is because greenpeace got a law passed requiring them to make their crops infertile
11:20:13 <applicative> copumpkin, I think, if it was good enough for '98 it's good enough for '11.
11:20:18 <copumpkin> lol
11:20:29 <copumpkin> yeah, "good enough" is what we should strive for :)
11:20:36 <swath> yeah, and it's still fertile.
11:20:47 <copumpkin> swath: #haskell-blah, maybe :)
11:21:00 <ville> TTimo: what's so sad about column-major?
11:21:05 <applicative> copumpkin, i think you should have recommended a 'moo' notation though.  But I am still studying Doel's comment
11:21:52 <kmc> hmm there was another one too, i think
11:22:46 <swath> can i make a function that generates new, named functions that i can call on, instead of just forgotten lambda?
11:22:48 <applicative> oh I see, it's simpler than i thought.  I was puzzled by the analogy with let.
11:23:35 <applicative> swath doesn't (+) make a new named function according to the first thing you apply it to?  (1+) (2+) (3+)
11:23:47 <rwbarton> I am in favour of moo notation
11:24:02 <swath> i have no idea.
11:24:53 <applicative> swath when you 'generate the new functions', what is generating them?  an index, argument, parameter or whatever? -- if so it's just a 2 place function.
11:25:20 <swath> an IO, probably. or a set, in stricter terms
11:26:17 <applicative> swath there is, for example the type (IO (Int-> Char))
11:28:46 <applicative> swath, but suppose you have a command line utility that reads from stdin and applies a different function to the string according to an option -- is that the right structure?
11:29:02 <kmc> Map String (String -> String)
11:29:15 <swath> no, or at least i dont think so
11:29:51 <swath> because in that case, i would want to allow for the person to type in tags like -dosomethingspecific, but still operate well even if they didnt put that there
11:31:24 <applicative> swath, right, so there is a default function
11:32:19 <swath> why couldnt the function always run, but if they type in nothing it's just an identity function that gets applied?
11:33:54 <swath> like runprogram = dosomething() function,    and runprogram -domsomething = dosomething(1) function, where dosomething() is just Identity
11:34:04 <applicative> do {as <- getArgs, case as of ("-dosomethingspecific":_ )-> interact dosomethingspecific ; _ -> interact dothedefault}  -- something like that
11:34:09 <copumpkin> > (x+y+z)^3
11:34:10 <copumpkin> x^3+y^3+z^3
11:34:10 <lambdabot>   (x + y + z) * (x + y + z) * (x + y + z)
11:35:03 <applicative> swath, then e.g. do {as <- getArgs, case as of ("-dosomethingspecific":_ )-> interact dosomethingspecific ; _ -> interact id}
11:35:32 <applicative> missing semicolon in there, perhaps among other difficulties...
11:36:04 <swath> meh CLI is far away anyway lol
11:36:16 <swath> if i can get this to the point where im even sharing it with ppl who want a CLI, ill be happy
11:36:33 <swath> for now ill just do it ghetto, change my program then run again
11:39:16 <peteriserins> how come one f x = f x is not id?
11:39:27 <peteriserins> they do have different types, but should they?
11:40:03 <sshc> Wow, GHC 7.2's spell checking is nice :)
11:40:11 <KirinDave> sshc: Yeah I was noticing that last night
11:40:26 <KirinDave> sshc: It's actually shockingly helpful. Even does a good job with gibberish spaceship operators
11:40:39 <peteriserins> ah one f x implies f can be applied to x, so it is an id for functions; is that it?
11:41:49 <kmc> spell checking?
11:41:54 <swath> i dont understand peter
11:42:11 <swath> wouldn't one f x = id iff one f = id?
11:42:41 <applicative> the spellchecking is annoying until it isn't
11:42:42 <swath> or however you phrased it
11:43:14 <peteriserins> swath: I mean one = id
11:43:25 * applicative designs a gibberish spaceship operator 
11:43:30 <swath> lol, depends on what book you're reading.
11:43:33 <rwbarton> your 'one' is an id for functions, yes
11:44:12 <applicative> kmc, it's in ghc 7.2, the spellchecking
11:44:40 <peteriserins> cool, interesting to see the Church numerals be unique in some sense
11:46:11 <mdgeorge> hello
11:46:36 <applicative> sshc, KirinDave how do you trigger the spellchecking I'm having difficulty reproducing my experience...
11:46:37 <mdgeorge> what's the best way to return complicated data structures from the ST monad?
11:46:57 <mdgeorge> do I have to walk the whole thing and copy it, or is there a better way?
11:47:00 <KirinDave> applicative: Import ByteString, refer to it subsequently as Bytestring
11:47:07 <swath> spellchecking while programming? isn't that kind of like giving a spellchecker to Lewis Carroll?
11:47:09 <peteriserins> @pl \f x -> f x
11:47:10 <lambdabot> id
11:47:15 <applicative> mdgeorge: runST?
11:47:33 <KirinDave> it's kinda crazy tho, sometimes it finds things I _haven't_ imported, and I really wonder how it's doing that.
11:47:44 <mdgeorge> applicative: I understand that...my question is, you can "freeze" mutable arrays into unmutable arrays
11:47:45 <KirinDave> I suspect it's looking at things other modules import but don't re-export.
11:47:50 <mdgeorge> without copying them
11:48:11 <mdgeorge> applicative: I was wondering if there's a way to "freeze" data structures that have lots of pointers
11:48:30 <hpc> mdgeorge: try hoogling stuff that has to do with that array type
11:48:39 <KirinDave> mdelaney: So long as they don't point to yet more mutable stuff, it's all good
11:48:42 <KirinDave> Doh
11:48:44 <mdgeorge> hpc: I want to make my own type
11:48:44 <KirinDave> sorry
11:48:52 <hpc> ah
11:48:54 <KirinDave> mdgeorge: So long as they don't point to yet more mutable stuff, it's all good
11:49:12 <mdgeorge> KirinDave: but can they be dereferenced outside of ST?
11:49:25 <KirinDave> mdgeorge: Assuming you write your impl right, yes.
11:49:29 <hpc> the reference cannot even escape from ST
11:49:36 <hpc> only the value itself
11:49:42 <KirinDave> mdgeorge: But yeah, it would be incorrect to let things "leak"
11:50:07 <mdgeorge> I'm building a search structure imperatively, but then I want to freeze it into a value, and be able to traverse it from non-ST code
11:50:18 <mdgeorge> maybe that's not the right approach
11:50:41 <hpc> try building it another way; if the structure is recursive you should build it recursively
11:50:55 <hpc> if it's a hash of some sort, that structure already exists somewhere
11:51:55 <mdgeorge> hpc: it's a defining example in the lazy functional state paper that introduces ST: basically a graph algorithm that relies on update to efficiently avoid having to rewrite the entire graph for every update.
11:59:21 <mjo> Is there some place I can look for fast implementations of library functions? For example, right now, I'd like a fast (\\).
11:59:45 <Botje> you generally turn to more suitable data structures than lists
12:00:23 <Botje> sets are O(m*log n) instead of O(m*n)
12:01:52 <mjo> Hmm.. I'll look at arrays I guess. I'm pretty sure I can write a fast difference function, it just seems like someone would have already done it.
12:02:12 <EvanR-work> heh
12:02:19 <EvanR-work> with an array its going to be m*n
12:02:34 <tech2> mjo: what are you actually wanting to do?
12:02:39 <DasIch> mjo: use a set
12:02:45 <ian__> any good resources for understanding functors and <*> <* *>
12:02:52 <b_jonas> also \\ requires only Eq on the elements so you can't have that one fast
12:03:01 <b_jonas> you need Comparable or something
12:03:07 <b_jonas> which is why you use some set-like stuff
12:03:36 <mjo> I have a list of 24 objects, most of which I'm going to throw away. I'm doing an "expensive" computation to decide which ones to keep.
12:03:57 <EvanR-work> :t all
12:03:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:04:01 <EvanR-work> use that
12:04:04 <EvanR-work> somehow
12:04:12 <EvanR-work> er
12:04:13 <EvanR-work> :t filter
12:04:14 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:04:17 <EvanR-work> ;)
12:04:19 <ian__> :t (<*>)
12:04:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:04:24 <mjo> However, I can throw away 3/4 of them just by.. well, knowing that they won't be a winner.
12:04:26 <luite> ls -l
12:04:40 <EvanR-work> just by knowing?
12:04:52 <mjo> But removing 18 items from a list of 24 is actually slower than doing the expensive computation!
12:04:53 <luite> oops
12:05:08 <Cale> mjo: Arrays would be at least as slow as lists for set difference. Set will keep the elements ordered conveniently to make difference fast.
12:05:08 <EvanR-work> mjo: have you tried filter
12:05:41 <mjo> Yeah. I need to do the expensive calculation on all 24 of them before I can filter.
12:05:42 <EvanR-work> filter (not . winner) xs
12:05:49 <EvanR-work> why?
12:06:16 <mjo> winner xs = x | expensive x == minumum (expensive xs)
12:06:35 <DasIch> mjo: do you actually know that the calculation is too expensive?
12:06:56 <mjo> It's certainly slower than an equality comparison, which is how I'd like to drop them from the list =)
12:07:04 <DasIch> mjo: unless it is too expensive it doesn't matter how expensive it is
12:07:24 <EvanR-work> premature optimization
12:07:30 <mjo> My program takes 16 hours to run =P
12:07:49 <DasIch> mjo: and this particular part takes 15hours?
12:07:49 <rwbarton> people always prematurely assume that a problem is a case of premature optimization
12:08:01 <mjo> The "expensive" operation isn't too expensive, but it gets called billions of times.
12:08:05 <mjo> Any savings is big savings
12:08:07 <EvanR-work> all generalizations are false
12:08:27 <Cale> Including that one
12:08:31 <EvanR-work> hehe
12:08:34 <ion> Hitler used generalizations, too.
12:08:40 <DasIch> mjo: you have proven that this is an issue by using a profiler?
12:08:41 <EvanR-work> ooohh
12:08:47 <Cale> This conversation is over
12:08:59 <Cale> mjo: anyway
12:09:02 <mjo> Yep, 60 some percent of my time is spent in this function.
12:09:16 <ion> At the point of godwining the conversation has just started!
12:09:37 <Cale> mjo: what function are you computing?
12:10:03 <mjo> I have a set of 24 tetrahedra, and I want to know which one contains a given point. One of them must.
12:10:24 <DasIch> mjo: parallelization?
12:10:37 <mjo> All the tetrahedra form a larger cube, though, so if for example the point is in the bottom half of the cube, I can already drop 12 of the tetrahedra as candidates
12:11:02 <mjo> With list difference, it turns out that doing the hit test 24 times is actually faster than doing the set difference and hit test 12 times
12:11:13 <mjo> er s/set/list
12:11:31 <Cale> That's possible
12:12:10 <mjo> DasIch: The whole thing is already parallelized; doing these tests in parallel isn't going to save me anything except on the very last one out of billions.
12:12:14 <Cale> List difference is necessarily quadratic, because it doesn't assume the lists are ordered.
12:12:32 <applicative> ian__: have you seen Learn You a Haskell?  <*> and <**> are specific to the 'applicative' functors
12:12:58 <roSievers> Hi, I'm new to Haskell and just got confused by some type signatures:
12:13:18 <mjo> I can order this list by hand easily; is Data.Set going to be the fastest implementation of difference then? Actually, hell, the lists are constants. I can just compute them by hand once.
12:13:20 <applicative> we love type signatures here
12:13:33 <ion> Has anyone ever found use for <**>? :-P
12:13:37 <ciaranm> type signatures are the best kind of signature
12:13:49 <EvanR-work> mjo: if its constants, then just defined the diff as a function of the constants
12:13:51 <monochrom> I use flip (<**>) all the time.  <duck>
12:13:53 <EvanR-work> and it will be a constant
12:13:56 <ion> hah
12:13:58 <kmc> :t (<**>)
12:13:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
12:14:03 <roSievers> in ghci: ":t fromIntegral . length"
12:14:11 <roSievers> got I type signature I understand
12:14:12 <rwbarton> If your lists are ordered, you can write a merge-like \\ in linear time
12:14:12 <swath> what is <**>?
12:14:21 <ion> flip (<*>)
12:14:22 <kmc> roSievers, what are the type signatures
12:14:28 <applicative> @type fromIntegral . length
12:14:28 <kmc> ion, it doesn't execute the effects left-to-right?
12:14:29 <lambdabot> forall b a. (Num b) => [a] -> b
12:14:41 <mjo> Yeah I don't know why I asked this in hindsight, there are only 8 possible results of me calling (\\). I'll just compute them all by hand.
12:14:44 <rwbarton> but, you might be better off putting these tetrahedra in an octree or something
12:14:57 <roSievers> the info ghci gives me, when I enter ":t ..."
12:15:02 <rwbarton> Why would you use {top+bottom} \\ {bottom} to compute {top}?
12:15:05 <applicative> roSeivers ^^^ that means the number can be in an any 'number' type you please
12:15:06 <ion> kmc: Ah, good point. It does indeed.
12:15:11 <rwbarton> If you have {bottom} then surely you have {top} already also
12:15:18 <roSievers> like  (Num b) => [a] -> b
12:15:26 <mjo> rwbarton: clarity, not much else
12:15:39 <swath> i can probably invent a situation where you have {bottom} but not {top}
12:15:40 <applicative> roSeivers, the trouble is, How to read it? (Num b) => [a] -> b
12:15:45 <ion> kmc: I had only read the haddock description which says â€œwith the arguments reversedâ€ which was ambiguous, leading to the misconception.
12:15:55 <applicative> @type length
12:15:56 <lambdabot> forall a. [a] -> Int
12:15:58 <Cale> roSievers: It means that for all types a and b, if b is an instance of the class Num, then the expression you wrote can have type [a] -> b
12:16:07 <mjo> Right now, the code reads like: if point in top half, candidates = candidates \\ bottom_half_tetrahedra
12:16:09 <monochrom> (Num b) => [a] -> b is polymorphic in b, with the condition that whichever you end up using for b must be an instance of the type class called Num. do you know type class?
12:16:16 <roSievers> but when I do "let len = fromIntegral . length", ":t len" got a different type signature
12:16:23 <rwbarton> how about ... candidates = top_half_tetrahedra
12:16:28 <Cale> roSievers: ah, monomorphism restriction
12:16:32 <rwbarton> or I see, you want to intersect several things
12:16:35 <applicative> indeed!
12:16:52 <mjo> I do top/bottom, left/right, and forward/back. But still, that's just 2^3 I'll have to compute
12:16:59 <Cale> roSievers: It's a technical condition which applies to pattern bindings (things that look like definitions of constants syntactically)
12:17:03 <rwbarton> yes, this is my octree suggestion
12:17:07 <monochrom> monomorphism restriction plus ghci choose one concrete type for you
12:17:15 <monochrom> s/choose/choosing/
12:17:28 <roSievers> will this happen in "normal" haskell?
12:17:35 <rwbarton> where it is not really that much of a tree, since it has only one level
12:17:50 <mjo> Ooh these look cool. I didn't know about them, thanks.
12:17:56 <monochrom> only the monomorphism restriction part happens in normal haskell. ghci is not normal
12:18:01 <rwbarton> just an 8-tuple of the various lists
12:18:09 <Cale> roSievers: You can either turn it off with {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your source or :set -XNoMonomorphismRestriction in ghci. Or you can give an explicit type signature for len, or you can define len with a function parameter.
12:18:18 <applicative> roSievers, there is defaulting going on.
12:18:25 <Cale> roSievers: let len x = fromIntegral . length $ x
12:18:32 <roSievers> so it is a feature, that haskell does it?
12:18:35 <monochrom> another example of ghci choosing one concrete type for you: "x <- newEmptyMVar", x's type is MVar Any.
12:18:42 <roSievers> not some restriction
12:18:51 <rwbarton> depending on who you ask, it is a feature
12:18:57 <Cale> roSievers: It's an annoying "feature" of the standard which everyone hates.
12:18:58 <elliott> roSievers: It's not something you want in GHCi but it's fairly useful in source files. Sometimes.
12:18:59 <applicative> roSievers, ghci will naturally read things as Integer, Double and () as appropriate.
12:19:01 <elliott> Yeah OK it's terrible.
12:19:20 <elliott> Oh, I thought we were talking about defaulting not the MR.
12:19:35 <applicative> roSievers, do you have a .ghci configuration file?  we can get rid of this once and for all :)
12:19:36 <rwbarton> I think most people agree a "polymorphism warning" would have been better
12:19:44 <monochrom> MR alone would say "let's see more code to choose a type properly"
12:19:49 <roSievers> and in "normal" haskell it doesn't really matter, because Haskell will just inferr the right type for me?
12:19:59 <roSievers> when I use that "len" later?
12:20:06 <monochrom> ghci says "let me close my eyes and choose the worst type for you"
12:20:11 <rwbarton> if you only ever use it at one type, then yes
12:20:12 <ARRG> haha
12:20:29 <roSievers> ok, thank you
12:20:31 <rwbarton> but if you try to use it at more than one type, you will get an error
12:20:41 <Cale> roSievers: Well, it can still bite you -- the fact that len is a pattern binding without a type signature will mean that it can only have a monomorphic type
12:20:51 <rwbarton> > let len = fromIntegral . length in (len [1,2,3] :: Int, len [4,5] :: Integer)
12:20:53 <lambdabot>   (3,2)
12:20:56 <rwbarton> oops
12:21:01 <rwbarton> this never works for me :P
12:21:22 <monochrom> some chance lambdabot turns off MR
12:21:22 <rwbarton> oh probably because lambdabot has no MR
12:21:23 <applicative> roSievers, to see it in action you can vary with :set -XNoMonomorphismRestriction and later back to :set -XMonomorphismRestriction
12:21:37 <rwbarton> yes in "real Haskell" you get an error
12:21:41 <roSievers> If I add a type right signature above "len"s defintion (in a compiled hs file) i could get a function that returns Num?
12:21:41 <Cale> btw, it should really be {-# LANGUAGE NoMR #-}
12:21:51 <Cale> NoMonomorphismRestriction is too annoying to type :P
12:22:03 <NemesisD> is it possible to point cabal at a cabal file in a directory? i want to package a tool as a cabal package but not necessarily release it to hackagedb
12:22:06 <Cale> roSievers: Yes
12:22:16 <NemesisD> Setup.lhs isn't enough because it doesn't do stuff like install dependencies
12:22:25 <Cale> roSievers: The rule only applies to things which look like definitions of constants, and which don't have type signatures.
12:22:25 <applicative> roSievers: I very rarely regret having put :set -XNoMonomorphismRestriction in my .ghci file
12:22:35 <monochrom> just use EclipseFP and auto-completion! (well, actually, I don't know whether EclipseFP completes that one)
12:22:42 <luite> NemesisD: you can just cabal install in that directory
12:23:05 <monochrom> anyway yeah it should be {-# LANGtab NoMonotab #-}
12:23:08 <NemesisD> oh
12:23:36 <Cale> I don't like syntax which relies on editor features to be usable when it doesn't have to.
12:24:11 <applicative> it should be {-#LANG#-}
12:24:13 <luite> NemesisD: if you have many unpublished packages, it might be easier to host your own hackage repository
12:24:14 <elliott> {-lng nmr-}
12:24:19 <monochrom> no, you enter the letters t, a, b manually there! :)
12:24:25 <Cale> oh, lol
12:24:50 <merijn> Any nicer way of parsing command line options or should I just use getArgs?
12:25:12 <Botje> there's option parsing stuff on hackage
12:26:34 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Console-GetOpt.html#v:getOpt
12:26:37 <ion> It looks like your code may be affected by the monomorphism restriction. Do you want to add NoMonomorphismRestriction?
12:26:56 <hpc> ion: i read that as italicized google correction text
12:26:59 <merijn> hpc: Excellent, thanks
12:27:10 <copumpkin> kmc: design decision about that memory thingy
12:27:42 <ion> That was supposed to be said by Clippy.
12:27:56 <copumpkin> should I build it on foreignptrs so we can use foreign/mapped memory, or build it on ByteArray# so we can be nice and garbage-free?
12:28:54 <kmc> sorry, what's the advantage of ByteArray#?
12:29:02 <hpc> ion: maybe i am just strange, but clippy was never as annoying as the new "i know better than you" google autocorrect
12:29:03 <copumpkin> the GC can move it
12:29:09 <copumpkin> so you don't get memory fragmentation
12:29:18 <copumpkin> not that I expect to be making craptons of these things
12:29:20 <copumpkin> and discarding them
12:30:22 <kmc> why is ByteArray# better than malloc'd (ForeignPtr Word8) for that?
12:30:45 <copumpkin> a ForeignPtr can only be backed by pinned memory
12:30:56 <kmc> ah
12:31:05 <kmc> GHC can copy a ByteArray# when it wants to, compacting the heap?
12:31:08 <kmc> which could improve locality
12:31:10 <copumpkin> yeah
12:31:14 <kmc> hmm
12:31:17 <applicative> the search engine overruling you is so impossibly depraved.  they pour billions into making the search engine more and more worthless each year
12:31:22 <kmc> how hard would it be to allow both?
12:31:32 <copumpkin> you can pin a ByteArray# if you really want to, but only a new one (you can't change an existing one to be pinned)
12:31:58 <copumpkin> hmm
12:32:21 <ion> hpc: I just prefix the search terms with a plus (the â€œthis is the exact term i want to search forâ€). What is really annoying is that Googleâ€™s autocorrect has started to â€œfixâ€ even those.
12:32:59 <copumpkin> kmc: probably not that hard, if I wanted to allow it at the leaves. Each chunk of memory could be either a foreign pointer or a bytearray, I guess
12:33:02 <swath> search engine market is basically a monopoly =(
12:33:15 <copumpkin> you'd need a test at every chunk to decide which you're doing, but that probably isn't a huge cost
12:33:15 <swath> and it's so expensive to compete nearly nobody even tries
12:33:21 <copumpkin> compared to what you'll be using the memory for
12:33:22 <hpc> search engines aren't the market, the ads are the market
12:33:32 <applicative> is Bing any better, or just much worse?  Maybe we should invent a giant search machine, called GrownUp --even supports 'boolean expressions' etc etc
12:33:36 <swath> search engine SHOULD be the market.
12:33:42 <swath> id pay a monthly fee for a really good engine.
12:33:47 <swath> wouldn't you?
12:33:55 <confab> no
12:34:14 <tromp> @hoogle nubBy
12:34:15 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
12:34:19 <applicative> yes
12:34:25 <swath> well then search engines will forever suck, if nobody is willing to pay for them
12:34:28 <kmc> copumpkin, yeah, you could test or you could vtable it
12:34:43 <kmc> but either way there is a cost
12:34:49 <copumpkin> yeah
12:35:01 <kmc> copumpkin, on KISS principle i'd just go with ForeignPtr
12:35:08 <kmc> i mean, everyone loves ByteString and it uses pinned memory
12:35:11 <applicative> swath no you just need ads.  keep in mind that google was better when it was in a garage.  it isn't actually that expensive
12:35:19 <copumpkin> kmc: yeah, fair enough
12:35:40 <copumpkin> the user of it shouldn't be aware of that, anyway
12:35:42 <kmc> just be careful not to make any design decisions which would make a dual approach massively more difficult
12:35:45 <copumpkin> so I can fool around with it later
12:35:48 <kmc> yeah
12:35:52 <b_jonas> what should I do if I don't like how all haskell code has to be recompiled when I upgrade ghc even just between point releases? couldn't they try to preserve binary compatibility?
12:36:09 <b_jonas> I mean, I know it's harder than with perl or python or C++ because of the elaborate runtime system
12:36:16 <kmc> b_jonas, they could, but it's a drain on the GHC team's resources
12:36:21 <b_jonas> but isn't the point of point release only bugfixes?
12:36:23 <kmc> it's a direct tradeoff with making GHC actually better
12:36:31 <applicative> b_jonas, but then we would be deprived of the pleasure of watching ghc recompile it all!!
12:36:34 <b_jonas> probably I should just upgrade ghc less often
12:36:37 <ciaranm> preserving binary compatibility is the first step towards supporting horrible broken stuff for hundreds of years
12:36:38 <kmc> i agree there's probably a way to do it for bugfixes without huge pain
12:36:38 <swath> applicative: then people aren't really paying for the search engine, they are merely selling their time to the company at hand IE google, who uses that time in order to sell ad space. therefore google's main incentive becomes not to improve the search engine, but to improve the value of their advertisements
12:36:44 <kmc> open a ticket or ask in #ghc, maybe
12:37:22 <swath> because they wont make much more money by improving the engine, but they make a lot more money by making the ads more effective per unit time people invest
12:37:22 <EvanR-work> google has incentive to do a lot of bad things, but they value their reputation
12:37:30 <EvanR-work> and people trust them, for better or worse
12:37:47 <applicative> surely no one is so stupid as to think google is anything but a bloated menace
12:37:57 <ciaranm> well yes, but they're not microsoft
12:38:05 <confab> whats the difference?
12:38:08 <b_jonas> okay, I can understand that the GHC team doens't have resources to make it work that way
12:38:16 <applicative> -blah territory here.
12:38:18 <b_jonas> but is there some practical solution for users like me?
12:38:19 <swath> the difference is that at least microsoft is honest about being a bloated menace.
12:38:25 <confab> haah
12:38:28 * applicative is with swath
12:38:29 <b_jonas> should I just upgrade ghc less often?
12:38:54 <ciaranm> b_jonas: you should write your own compiler. with blackjack. and hookers!
12:39:05 <confab> matter of fact, forget the compiler
12:39:20 <b_jonas> ciaranm: "blackjack. and hookers"? what?
12:39:24 <swath> but seriously, search engine market reminds me so much of the insurance market. all the money/profits the companies make are turned into improving the cash return of their product, NOT improving the product itself.
12:39:32 <confab> b_jonas, futurama
12:39:38 <b_jonas> ah
12:39:48 <EvanR-work> insurance is a risky business
12:39:53 <tromp> @hoogle gcd
12:39:54 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
12:40:00 <confab> nearly as dangerous as searching
12:40:17 <applicative> b_jonas, how difficult is it?  somehow when i install a new ghc i take the occasion to sort out my absurd mixture of package versions.
12:40:23 <b_jonas> (on the other hand I'm quite impressed on how the gcc team manages to keep libstdc++ abi binary compatible for such a long time. it seems very hard to do.)
12:40:32 <confab> on a serious note, what do you suggest swath?
12:40:54 <swath> for search engines?
12:40:55 <ciaranm> b_jonas: and as a result, c++ programs are about 20% slower than they should be
12:40:56 <confab> qyes
12:40:58 <EvanR-work> altavista
12:41:14 <swath> i suggest we need a different business model to see real improvement.
12:41:17 <b_jonas> applicative: I do that once a year with perl. I reinstall every module. but I only have to do that once per minor version, not once per point release. upgrading (stable) perl to point releases is almost painless.
12:41:22 <confab> such as?
12:41:31 <EvanR-work> pay per search
12:42:55 <swath> it needs to be separated from the advertisements, is all. the financial incentive can't come from the advertisements or that's all that will be invested in
12:42:59 <applicative> b_jonas, I see.
12:43:15 <swath> it ends up being a huge long term cost to everybody because development on what's important halts and money is spent on shit nobody cares about
12:43:35 <NemesisD> luite: how would i uninstall a package installed from a cabal file. ghc-pkg unregister pkgname doesn't seem to work
12:44:03 <luite> NemesisD: there's not real uninstall, unregister is usually enough
12:44:20 <pcavs> will as patterns match if their sub destructuring does not match? I assumed not, but I wanted to check
12:44:21 <luite> you don't really need uninstall since you can have multiple versions of a package installed
12:44:35 <applicative> NemesisD: It unregisters it.
12:44:45 <NemesisD> luite: unregister says it can't find the package
12:44:51 <NemesisD> yet the bin exists on my system
12:44:52 <Botje> pcavs: no, they won't
12:45:09 <EvanR-work> swath: uhm, the ads are the important part
12:45:12 <luite> NemesisD: if it's only an executable, then ghc-pkg doesn't register it
12:45:15 <applicative> NemesisD, yes, you can delete it and the corresponding library directory if there is one
12:45:31 <NemesisD> oh sorry, yeah its just an executable
12:45:40 <luite> see ghc-pkg list for the registered pkgs
12:45:52 <NemesisD> is there a reliable way to delete it on all different configurations of cabal then? i want my users to have an easy way to get rid of it
12:46:19 <applicative> you might just make a binary to be put in /usr/local or something, no?
12:46:59 <NemesisD> i'm fine with it being in the cabal bin directory since cabal was used to install it, i find it odd that it gives the user no interface to uninstall executables though
12:47:00 <applicative> NemesisD: if it's just the binary, there's "rm .cabal/bin/NemesisDAwesomeness" ...
12:47:20 <swath> evanR: the ads are only important insofar as it's who pays google
12:47:31 <NemesisD> applicative: i know thats how i can remove it from my system but i want a reliable way so anyone with any configuration of cabal can uninstall it
12:47:31 <EvanR-work> swath: wrong
12:47:47 <swath> and what services are being bought. if it's the advertisements are being bought, then it's them that get invested in.
12:47:48 <applicative> you could also install a binary, NemesisDAwesomenessUninstall, which deletes itself and the other
12:47:58 <b_jonas> ciaranm: quite possible. it might be better if libstdc++ jumped abi version faster.
12:48:10 <NemesisD> yeesh
12:48:30 <applicative> NemesisD: but oonly the ones in the same directory
12:48:34 <NemesisD> thats insane to me. is the lack of an uninstall for executables a deliberate design decision in cabal?
12:48:36 <EvanR-work> swath: advertising is a hugely important aspect of business, and google started a revolution in more relevant ads
12:49:20 <b_jonas> the installed library is only 1.3M large, so it shouldn't be hard to have multiple versions installed
12:49:32 <applicative> NemesisD, it is certainly not optimized for distributing executables to the non-Haskellizing public
12:50:24 <swath> advertising is backwards, for the same reason risk management in insurance is, and basically just got banned in the USA for health care insurance, lol
12:50:25 <NemesisD> i guess not. ill just put a note in the readme to basically rm `which pkgname` if they want to uninstall
12:50:26 <b_jonas> and gcc has changed a lot in the meanwhile, mostly for good, and quite a lot of that is specifically related to c++, so there would be a need for some changes
12:50:43 <EvanR-work> swath: no
12:50:59 <applicative> NemesisD, you might look into distributing it in binary form.  Pandoc for example used to have problems like this, but is now just installed as a binary on all platforms withour cabal
12:51:11 <EvanR-work> off topic
12:51:15 <ciaranm> b_jonas: the problem is when you have half your libraries using one libstdc++ abi and half using the other
12:51:21 <applicative> NemesisD, or rather, that is an option, for the non haskellizing users
12:52:08 <b_jonas> ciaranm: hmm, yes, that could be a problem
12:52:15 <b_jonas> because then you can't pass a vector from one to another
12:52:21 <NemesisD> applicative: well my thing is this project is just going to be on github. i don't plan on distributing it just yet and i feel weird about checking the compiled binary into source control
12:52:35 <confab> swath, how is search supposed to make money if it doesn't come from ads?
12:52:41 <b_jonas> at least that's a problem as long as those libraries expose a C++ interface
12:52:58 <Melvar> Just out of curiosity, is it ever useful to have something like a (Monad m) => m (a -> m b) ?
12:53:09 <applicative> NemesisD, I understand.  Does github have a way of putting a binary up though?  I notice that pandoc is using its old google code site for this
12:53:12 <dcoutts> NemesisD: no, not a deliberate design decision, just hasn't floated to the top of the TODO list
12:53:13 <swath> by charging to use it.
12:53:29 <b_jonas> good point
12:53:38 <applicative> NemesisD, dcoutts is here!
12:53:39 <ciaranm> why would i pay? bing is free
12:53:44 <kmc> Melvar, that's not going to be very useful if it's really polymorphic over all a and b
12:54:09 <EvanR-work> confab: theres many ways to run a business
12:54:16 <EvanR-work> some better than others
12:54:30 <confab> swath, would this pay search engine offer over a few search engine?
12:54:34 <confab> free*
12:54:51 <Melvar> kmc: By the â€œlike aâ€ I mean this, specialized in any variables.
12:54:52 <justin-kp> can ordinary users add compiler plugins to support deriving Blah?
12:54:57 <swath> imagine a world where you cant buy a car, there is only public transportation. its slow, and doesnt work that great. the advertisements cover all the walls on the inside of the vehicle, many people can be inside it at once, and relevant advertisements automatically appear on the walls nearest to you.
12:55:08 <applicative> NemesisD, I think as long as people installing it are using git clone and then cabal install they will be okay with rm .cabal/bin/NemesisD
12:55:20 <justin-kp> or are you stuck with deriving Show, Eq, etc
12:55:24 <swath> personally, i think most people would rather just pay the small fee or even have their own car!
12:55:27 <EvanR-work> swath: youre politically incorrect, and off topic
12:55:46 <swath> comparing searching to travelling is politically incorrect?
12:55:52 <kmc> Melvar, ok, then sure it could be useful
12:56:08 <kmc> IO (String -> IO ())  -- this is my type for an action that starts an asynchronous logger daemon
12:56:09 <confab> swath, but cars offer many advantages over public transit, you would have to offer a similar amount of advantages over free search
12:56:19 <applicative> NemesisD, it just needs to be spelled out in your deluxe readme.markdown
12:56:21 <ciaranm> swath: private transportation goes against the great communist ideal
12:56:37 <swath> good thing im not a communist
12:56:45 <kmc> good thing you're all off topic
12:57:09 <EvanR-work> i invited swath to #bitcoin-politics
12:57:11 <confab> quick, someone relate it to monads so we can keep talking about it
12:57:26 <kmc> Melvar, it's an action that produces a function which accepts log messages
12:57:31 <kmc> makes sense?
12:57:42 <ciaranm> does category theory count? you can think of the category of journeys, where objects are places and arrows are trips
12:57:46 <b_jonas> burittos and communism?
12:57:50 <b_jonas> hmm
12:58:03 <EvanR-work> politburito
12:58:18 <kmc> man, politburrito would be a good name for a band
12:58:18 <Melvar> kmc: Yes, makes sense. Thank you, I thought there must be something useful in that form.
12:58:22 <kmc> :)
12:58:33 <confab> politto?
12:58:37 <vrthra> Hi, I am trying to create a monad transformer to a tree structure, Tree m = Node m [Tree m], having trouble translating the bind from Tree monad to the transformer. any help would be appreciated.
12:58:39 <hpaste> vrthra pasted â€œmonad transformerâ€ at http://hpaste.org/50987
13:03:12 <qweeak> what kind of channel is it ?
13:03:24 <mjo> Wow, computing the list of 6 candidates by hand, rather than list-differencing out 18 of them, cut my execution time *in half*
13:03:59 <EvanR-work> mjo: meh, constant factor speedup
13:04:03 <EvanR-work> boring
13:04:19 <swath> might not be constant factor
13:04:28 <swath> since he only gave the speed increase with respect to a specific size
13:04:46 <EvanR-work> his problem is fixed size
13:04:51 * hackagebot cabal2nix 1.14 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.14 (PeterSimons)
13:04:54 <EvanR-work> period
13:05:13 <swath> you can make an infinite version of any problem.
13:05:33 <ciaranm> you can?
13:05:47 <swath> yes
13:06:09 <ciaranm> what if my problem involves computing all the powers of a particular element in a finite group?
13:06:54 <swath> so now your problem involves computing the functions that generate all the powers of particular elements of many different finite groups, an infinite set even.
13:07:50 <ciaranm> what if my problem involves finding all the finite simple groups?
13:08:09 <swath> lol.
13:08:54 <swath> you can always alter a definition or problem statement to make a finite problem infinite
13:08:59 <luite> I have a process with a few running threads (one a loop, the other blocked, waiting for another process). from a third thread I call exitSucces, but the program does not get terminated, the other thears keep running
13:09:03 <luite> how can I fix this?
13:09:07 <luite> the other threads
13:10:02 <ciaranm> swath: enumerate the even prime numbers
13:10:53 <swath> ciaranm: generalize the notion of "prime" and extend the problem to finding prime elements in all types of structures where the prime definition holds, and enumerating those.
13:13:25 <benmachine> luite: I believe exitSuccess operates by throwing exceptions
13:13:37 <benmachine> luite: you may have to somehow signal the "main" thread and kill that
13:13:40 <benmachine> possibly with throwTo
13:13:45 <luite> benmachine: yeah I've already found it, need to do it from the main thread
13:14:06 <luite> well actually gweber in the #yesod channel found it for me :)
13:14:36 <benmachine> ok cool
13:16:12 <merijn> What's the proper syntax for updating a record field again? I keep forgetting and can't seem to quickly find it...
13:16:32 <benmachine> merijn: value{ record = thing }
13:16:33 <Botje> haskell{replies="Glorious Stero!"}
13:16:42 <benmachine> Botje: how apposite
13:16:43 <benmachine> :P
13:16:52 <Botje> (or was it majestic?)
13:16:59 <benmachine> @quote stereo
13:17:00 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
13:17:04 <benmachine> ...
13:17:09 <Botje> O_o
13:17:13 <swath> lol
13:17:17 <benmachine> @quote stereo[^l]
13:17:18 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
13:17:22 <benmachine> :<
13:17:34 <hpc> XD
13:18:07 <swath> there should be a recursive quote feature, where it quotes somebody who was referencing the quote. how could you tell, i wonder?
13:19:06 <merijn> benmachine, Botje: Thanks
13:22:48 <digitteknohippie> i've been reading loads from realworldhaskell and learnyouahaskell, and various searches on the topic, but still not sure how to go about adding a simple ifeellucky google search to my minimal bot.  time to cry for help. ^_^  help!  lol.http://www.wastedartist.com/scripts/daskeb/daskeb.hs (the bot in question).  see the commented out !goog command... that's as far as i've got, and not even sure it's the right way to go. unsur
13:24:36 <benmachine> digitteknohippie: your message got cut off at 'way to go. unsur'
13:25:03 <digitteknohippie>  unsure how to send the request to google, or return and print the result.  much thnx for any help.   (thnx for the heads up benmachine)
13:25:31 <benmachine> digitteknohippie: well, to do HTTP communication with google, you'll probably want an HTTP library
13:25:40 <benmachine> there's one called, amazingly, HTTP :)
13:25:58 <benmachine> I believe there's a simpleHTTP function which may do exactly what you want
13:29:12 <digitteknohippie> thnx benmachine, that's got my ball rolling again.  reading up.  ...will be back next time i get stuck. :)
13:29:41 <benmachine> http://hackage.haskell.org/package/HTTP
13:29:44 <benmachine> docs are linked there
13:33:16 <sbrg> I prefer http-enumerator over HTTP.. HTTP has these inconsistent naming conventions in some places(at least one), strange API and it was actually bugged for me last time I used it.
13:33:27 <sbrg> + the enumerator supports SSL and comes with a simpleHTTP function as well
13:34:30 <benmachine> sbrg: HTTP isn't actually that good
13:34:38 <benmachine> but http-enumerator has a billion more dependencies
13:34:42 <sbrg> ah
13:34:44 <monochrom> interesting. thanks for the suggestion
13:35:06 <benmachine> HTTP seems to be "just good enough" most of the time
13:35:40 <copumpkin> yeah, I'm not a fan of HTTP at all
13:35:57 <monochrom> to be fair, back then when HTTP came about at first, the whole community was like "everything is a custom-made monad edsl" so HTTP's "Browser" monad wasn't strange
13:36:03 <benmachine> it's not a jewel but I use it effectively
13:36:15 <digitteknohippie> just good enough, and less dependancies sounds like what better suits my goals here, keeping daskeb's code short n simple as possible.
13:36:24 <benmachine> mm
13:36:31 <copumpkin> monochrom: I actually quite like the browser monad
13:36:38 <benmachine> yeah
13:36:40 <copumpkin> some things in it don't really work very well though, iirc
13:36:44 <copumpkin> but I haven't used it in a while
13:36:45 <benmachine> yeah :P
13:36:50 <benmachine> the major drawback of HTTP is the bugs
13:37:00 <monochrom> presumably http-enumerator could be splitted so you don't need all the dependencies all the time
13:37:04 <benmachine> I have to use the git version in a project I'm doing
13:37:15 <benmachine> monochrom: presumably, yes, and I'd be in favour of that
13:37:17 <benmachine> but no-one's done it
13:37:28 <benmachine> personally I think there's a niche for HTTP, it just needs a bit more love
13:37:40 <benmachine> at the moment there's just one very reluctant maintainer
13:44:48 <Tinned_Tuna> Morning folks
13:44:58 <Tinned_Tuna> well, late-evening, folks :-_
13:44:59 <Tinned_Tuna> well, late-evening, folks :-)
13:45:08 <confab> afternoon?
13:45:10 <Eduard_Munteanu> Morning, Tinned_Tuna
13:45:23 <Eduard_Munteanu> (actually it's late at night here)
13:45:52 <Tinned_Tuna> I feel like a ninja, I have a working Haskell program that's a not just a trival set of non-monadic functions ^.^
13:52:28 <Philonous> Tinned_Tuna:  Actually, all functions are monadic. instance monad (-> r) where return = const; join f x = f x x
13:52:51 <digitteknohippi1> ooh, just found the module XMonad.Actions.Search ... looks interesting
13:55:24 <MHD> hey guys, I have problems installing Yi on my fedora 15 box. apparently some .so files are plain text, which cabal doesn't like. specifically it's ncurses. any ideas?
13:56:08 <dcoutts> MHD: does it fail during a template haskell bit of compilation?
13:59:14 <MHD> dcoutts: it fails when compiling Data.Trie on loading package terminfo
13:59:19 <Eduard_Munteanu> Philonous: ANF?
14:00:33 <dcoutts> MHD: mm, the problem is that ghc needs to load the C libs so it can run the template Haskell code, which is really just like loading the C libs in ghci. When it's not a real .so file then dlopen() does not work on it.
14:01:13 <dcoutts> MHD: now I think a more recent ghc version can interpret very simple so linker scripts, not sure which version though
14:01:40 <dcoutts> MHD: there's workarounds with symlinks, but it's not very satisfactory
14:02:39 <MHD> dcoutts: I need it anyways
14:03:36 <Eduard_Munteanu> I remember Philippa explaining that (Administrative Normal Form) to me, but I forget the details. It was about lifting function application into a monad.
14:04:10 <Eduard_Munteanu> (so I wondered whether there was a connection)
14:04:55 <ian__> a function just returned the value Just Nothing :::/
14:05:58 <monochrom> that's of type Maybe (Maybe x)
14:06:20 <monochrom> it's a legit type but I haven't seen it used in practice
14:06:34 <ian__> i know
14:07:49 <monochrom> hehe
14:09:53 <byorgey> for when you are REALLY not sure
14:16:39 <Cale> It comes up sometimes. Kinda rare. More common to have something like [Maybe a] or Maybe [a]
14:17:12 <Cale> Which also have more than one "empty" value
14:21:34 <dankna> I used Maybe (Maybe x) once
14:21:49 <dankna> it was the result of an SQL query which could fail to exist in two distinct ways
14:21:54 <dankna> either the query itself could fail to produce a result
14:22:00 <dankna> or the result could be SQL's NULL value
14:23:15 <parcs> > case Mu undefined of Mu _ -> ()
14:23:16 <lambdabot>   Not in scope: data constructor `Mu'Not in scope: data constructor `Mu'
14:23:32 <monochrom> the value constructor is In
14:23:42 <parcs> > case In undefined of In _ -> ()
14:23:43 <lambdabot>   ()
14:23:53 <parcs> @src Mu
14:23:53 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:24:12 <monochrom> it is the same as "case undefined of _ -> ()"
14:24:49 <copumpkin> > case undefined of In _ -> ()
14:24:49 <lambdabot>   ()
14:26:50 <benmachine> case fix In of _ -> ()
14:26:54 <benmachine> > case fix In of _ -> ()
14:26:55 <lambdabot>   Couldn't match kind `(* -> *) -> *' against `* -> *'
14:27:08 <monochrom> on a technicality :)
14:27:08 <benmachine> ...
14:27:10 * benmachine tries to work this out
14:27:15 <copumpkin> :t In
14:27:15 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
14:27:23 <benmachine> ohh
14:27:25 * benmachine silly
14:27:48 <copumpkin> > fix (In . out)
14:27:49 <lambdabot>   No instance for (GHC.Show.Show (f (L.Mu f)))
14:27:49 <lambdabot>    arising from a use of `M909...
14:27:53 <monochrom> with In.out or out.In
14:27:58 <monochrom> s/with/either/
14:27:59 <copumpkin> > case fix (In . out) of In _ -> ()
14:28:00 <lambdabot>   ()
14:28:08 <parcs> :t fmap (In . fix) In
14:28:09 <lambdabot>     Couldn't match expected type `f (Mu f) -> f (Mu f)'
14:28:09 <lambdabot>            against inferred type `Mu f1'
14:28:09 <lambdabot>     Probable cause: `In' is applied to too many arguments
14:29:22 <benmachine> copumpkin: the hokey cokey?
14:29:31 <copumpkin> what?
14:30:05 <benmachine> in out in out etc.
14:30:14 <copumpkin> oh :)
14:30:39 <benmachine> :P sry
14:36:49 <deech> Hi all, I was reading through the Implicit Configurations paper (http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf) and I noticed some odd syntax that looks like: "normalize a :: M s a = ...". This causes a parse error, is there some extension I should be enabling?
14:37:00 <MHD> I am having some dire trouble installing yi
14:39:34 <deech> Hmm .. apparently I had to do "normalize (a :: M s a) = ...". I didn't even know that was legal syntax.
14:39:52 <Cale> actually, you probably just need to move the type signature to the other side
14:39:55 <Cale> or delete it
14:40:21 <Cale> That type signature was meant to apply to the whole left hand side
14:40:31 <Cale> (given the overall type signature for the thing)
14:40:33 <MHD> how do i tell cabal to add another lib to the linker arguments?
14:40:55 <deech> Cale: Ah that makes way more sense. I guess Oleg et al. were working with an older version of GHC.
14:41:09 <Cale> deech: I'm not sure that was ever actually valid.
14:41:11 <rwbarton> perhaps they just used that notation to save space
14:41:30 <deech> Cale: It's in the Haskell source distributed with the paper.
14:41:38 <Cale> oh, interesting.
14:42:00 <rwbarton> I tried with PatternSignatures but that didn't make it work
14:42:19 <Cale> Try ScopedTypeVariables
14:42:32 <deech> rwbarton: Yeah, just to be safe I did -fglasgow-exts and that didn't work either.
14:42:41 <Cale> -fglasgow-exts still exists?
14:42:55 <deech> Cale: I get a warning saying its deprecated.
14:43:02 <Cale> I see
14:43:22 <Cale> lexically scoped type variables is the extension they say it falls under
14:43:30 <chreekat> Hey folks, is there a cleaner way to do something like "clampSpacecraft s = s { body = (body s) { centerMass = centerMass' } }" ? Specifically, is there a nicer way to do updates to datatypes within datatypes?
14:43:36 <Cale> So you could try {-# LANGUAGE ScopedTypeVariables #-} to turn that on
14:43:37 <rwbarton> that doesn't seem to help either though
14:43:38 <Philonous> Eduard_Munteanu:  ( -> r) is just the reader monad. And I was merely nitpicking because the expression "non-monadic functions" made me cringe
14:43:38 <kmc> chreekat, fclabels
14:43:41 <kmc> @hackage fclabels
14:43:41 <lambdabot> http://hackage.haskell.org/package/fclabels
14:44:04 <Cale> chreekat: lenses (like fclabels provides)
14:44:04 <deech> Cale: Nope didn't work. Weird.
14:44:08 <kmc> did anyone ever do a comparison of the 4 or 5 lens libraries?
14:44:13 <chreekat> kmc: thanks! the name is familiar; I'll check it out
14:44:13 <mun_> hi
14:44:19 <mun_> does first order logic support types?
14:44:33 <maltem> typed first-order logic does :p
14:44:36 <MHD> I need cabal to compile Yi with an extra linking library. How do I do that?
14:44:40 <benmachine> chreekat: you could look at any of the various GHC extensions for dealing with records, but they're all a bit strange
14:45:08 <benmachine> there's some punning extension whereby you can write { centerMass = centerMass } as just { centerMass }
14:45:32 <Cale> mun_: A first order logic usually only discusses one type of thing, so usually no... but there are things like first order set theory, where you can end up using sets like types.
14:45:45 <rwbarton> mun_, typed first-order logic is also sometimes called many-sorted first-order logic
14:46:00 <benmachine> and various similar
14:46:12 <MHD> is it possible to pass ekstra linker options to a cabal install?
14:46:14 <Cale> Yeah, it's easy enough to imagine being able to quantify over more than one type of first-order values.
14:46:16 <mun_> Cale, hmm why does FOL talk about only one type of thing?
14:46:26 <rwbarton> it's primarily a matter of preference whether you allow multiple sorts or not
14:46:56 <mun_> rwbarton, right. but why isn't many-sorted FOL the standard instead?
14:47:16 <rwbarton> it's more convenient from the theory side to only have one sort to worry about, and you can encode a many-sorted theory as a single-sorted theory
14:47:20 <swath> i can't think of many situations where you'd truly want to directly work in first order logic
14:47:23 <rwbarton> it just cuts down on notational overhead and so on
14:47:33 <mun_> right
14:47:35 <Cale> mun_: Well... you usually want models of a FOL theory to be sets which have some corresponding functions and relations on them satisfying the theory.
14:47:54 <Cale> and you tend to think of all the members of that set as having the same type
14:48:14 <Cale> It's enough generality for a lot of algebraic theories.
14:48:27 <swath> set theory sucks
14:48:30 <swath> fuck sets.
14:48:33 <Cale> why?
14:48:41 <mun_> i see
14:49:19 <rwbarton> in a many-sorted logic your models are tuples of sets (U_1, ..., U_n), with various functions between products of them... already it's more to write down
14:49:37 <rwbarton> U_i being the universe of values of type i
14:50:16 <swath> set theory becomes ridiculously cumbersome when your structures are defined by properties and are discrete. set theory just obfuscates it because of the notation. there's nothing wrong with having tuples, but it's better to have a smaller set of adorned tuples than it is to have a gigantic list of unadorned tuples following this draconian nesting pattern
14:50:21 <MHD> I have some trouble installing Yi
14:50:43 <MHD> I need to link my executable to libtinfo.so
14:50:53 <MHD> how do I do that in a cabal install?
14:50:57 <Cale> The category of sets has a lot of nice properties.
14:51:24 <rwbarton> mun_: anyways I agree that many-sorted logics are nice, these are just the arguments in favor of using single-sorted ones
14:51:41 <Cale> It has all small limits and colimits, exponentials, a subobject classifier...
14:52:01 <MHD> How do I make cabal link to an extra lib dunring cabal install
14:52:03 <mun_> thanks
14:52:05 <MHD> Pease
14:52:09 <MHD> please
14:52:12 <MHD> anybody?
14:52:29 <benmachine> MHD: does cabal install --help shed any light?
14:52:35 <MHD> nope
14:52:44 <Peaker> MHD: Please don't spam, people take time to alt-tab to irc client, read your question, etc
14:52:50 <MHD> I need to pass it libtinfo.so
14:53:02 <Clint> edit the .cabal file
14:53:20 <parcs> yes, the extra-libraries option
14:53:35 <mun_> if my logical theory has the following axioms {ALL x. foo(x) := bar(x) + bax(x); bar(a) = 0} what is the right terminology for describing foo(a)? is foo(a) "undefined" because bax(a) is "undefined"? but to work out the value of foo(a), one infers it from the axioms, so "undefined" can't be right?
14:53:40 <MHD> Clint: THANK YOU
14:54:26 <swath> what is +?
14:54:42 <mun_> swath, addition. let's assume foo, bar, bax all return naturals
14:55:31 <swath> it wouldn't quite be undefined. your result would be then 2bar(a), whatever bar(a) happens to be.
14:56:13 <swath> and since bar(a) = 0, foo(a) = 0
14:56:26 <mun_> swath, but there's no value of bax(a)
14:56:35 <rwbarton> swath: one of those "bar"s isn't a "bar"
14:56:41 <swath> hahaha
14:56:59 <swath> well then foo(a) = bax(a)
14:57:13 <swath> that's a silly function
14:57:37 <swath> wtf(x) = 0*haha + nowai(x)
14:57:46 <rwbarton> I wouldn't ever want to say something like "foo(a) is undefined", rather I would want to say something more like "foo(a) has different values in different models of the theory".
14:58:05 <mun_> right
14:58:25 <rwbarton> of course strictly speaking that is a tautology... and I'm not really a logician so I would defer on topics of terminology
14:58:37 <mun_> rwbarton, but what if you're working in a higher-order logic, it wouldn't be appropriate to talk about models there, right?
14:58:56 <Cale> mun_: So all your quantifiers are quantifying over naturals?
14:59:05 <Cale> and a is a natural number constant?
14:59:09 <swath> logically that's definitely undefined if bax(x) has no definition.
14:59:19 <rwbarton> I assume this is an extension of some theory of naturals and foo, bar, bax are function symbols
14:59:24 <Cale> mun_: The type of things which a FOL quantifies over are unspecified.
14:59:29 <Cale> (by the logic itself)
14:59:30 <rwbarton> that have been added to the language of naturals
14:59:37 <Cale> But they all have the same type
15:00:05 <mun_> Cale, well, let's say it quantifies over a subset of the naturals. sorry, i was quite vague there.
15:00:12 <Cale> So, you can apply any function symbol in the logic to any value
15:00:20 <mun_> {ALL x:S. foo(x) := bar(x) + bax(x)
15:00:23 <Cale> So you don't just have a logic anymore
15:00:35 <Cale> You have a logic + (part of) an interpretation for it
15:02:22 <swath> cale, more than that
15:02:57 <swath> + is a lot more than a logic
15:03:01 <swath> addition is a big ball of shit
15:03:01 <Cale> ?
15:03:02 <mun_> Cale, why can i apply any function symbol to any value?
15:03:34 <swath> mun_ because you didn't give any restrictions
15:03:44 <Cale> So you have some first order language here, with function symbols + (binary), foo, bar, baz (unary), and constant symbols a and 0, at least, and a binary relation symbol :=
15:04:06 <Cale> yeah?
15:04:23 <swath> cale: that's how many hundreds of pages into principia mathematica?
15:04:25 <swath> =o
15:04:27 <Cale> swath: ?
15:04:36 <Cale> It's zero pages into principia mathematica
15:04:45 <Cale> + isn't necessarily addition
15:04:50 <Cale> It's just a function symbol
15:04:51 <juld> hi, i'm trying to update BlogLiterately but i get stuck. Could someone help me?
15:04:52 <swath> he said it was
15:04:54 <swath> i asked
15:04:59 <swath> he said + is specifically addition
15:05:07 <mun_> swath, but i've asserted that bar(a) = 0. so how is it unrestricted?
15:05:17 <rwbarton> yes, that's where "(part of) an interpretation for it" comes from
15:05:22 <mun_> yeah, let's assume + is addition.
15:05:37 <Cale> Well... we can axiomatize addition :)
15:05:51 <swath> we can, but it's not trivial
15:05:54 <Cale> we'll need a successor function
15:05:57 <Cale> It's pretty trivial
15:06:05 <Cale> It's just the Peano axioms
15:06:09 <Cale> + a bit
15:06:41 <juld> :( someone?
15:06:49 <Cale> http://en.wikipedia.org/wiki/Peano_axioms#First-order_theory_of_arithmetic
15:07:00 <Cale> juld: Could you say what you're stuck on?
15:07:08 <copumpkin> just use presburger!
15:07:19 <copumpkin> peano is like using monad when you can use functor
15:07:37 <Cale> Sure, if you like
15:07:55 <Cale> We could just use Peano axioms minus the two about multiplication even.
15:08:06 <copumpkin> that's what I said! :P
15:08:13 <copumpkin> sort of :)
15:09:15 <Cale> juld: It's pretty hard for people to know if they can help without knowing what your problem is
15:09:37 <hpaste> juld pasted â€œI make it compiles but it's not running very well :Sâ€ at http://hpaste.org/50992
15:10:19 <rwbarton> I find it difficult to formalize the difference between foo and bar at all, given the existence of nonstandard models of arithmetic
15:10:37 <juld> when i run it i get: BlogLiterately: System.Console.CmdArgs.Implicit, unexpected flag (Arg_): Help "URL of blog's xmlrpc address (e.g. http://example.com/blog/xmlrpc.php)"
15:12:01 <Cale> Oh, it uses that crazy CmdArgs library...
15:12:37 <mun_> according to http://en.wikipedia.org/wiki/Higher-order_logic HOL doesn't support polymorphic types. then how come most HOL reasoners do support polymorphic types?
15:12:43 <juld> i'm using the latest "stable" version of any package involved :S and i think I understand something wrong in the difference between cmdargs version
15:14:01 <rwbarton> Perhaps I should say something roughly like: an isomorphism between the Nat-parts of two models of this theory extends to an isomorphism of bar, but not to an isomorphism of foo.
15:14:06 <juld> yeah, cmdargs it's really annoying for me :S i dont know what the error is telling me :(
15:14:06 <Cale> juld: yeah, probably. I'm not terribly familiar with that library, I just know that it does a lot of crazy impure stuff to generate its commandline argument parser.
15:14:10 <rwbarton> And perhaps there's some logical terminology for that
15:15:14 <xrl> is "se" some sort of special value in haskell? I tried removing its definition from a function but the code still compiled
15:15:53 <juld> cale: i think i gonna try the pure version of cmdArgs just to see what happens :S
15:16:00 <mun_> but then according to http://proof-technologies.com/Glossary "HOL logic : (n)  A classical, higher-order logic based on Church's typed lambda
15:16:00 <mun_> calculus, with a polymorphic, non-dependently-typed type system."
15:16:15 <headclone> quick question from a newbie, anyone?
15:16:25 <mun_> and on wikipedia: "The term "higher-order logic", abbreviated as HOL, is commonly used to mean higher order simple predicate logic. Here "simple" indicates that the underlying type theory is simple, not polymorphic or dependent."
15:16:30 <mun_> they seem to contradict?
15:17:06 <headclone> > can anyone tell me how to get syntax highlighting working for haskell in notepad++?
15:17:07 <lambdabot>   <no location info>: parse error on input `in'
15:17:31 <Cale> juld: Probably a good idea :)
15:18:10 <parcs> headclone: it probably doesn't recognize haskell
15:18:17 <byorgey> headclone: no idea, I don't think too many people use notepad++ for editing Haskell
15:18:22 <Cale> mun_: I think there's (somewhat unfortunately), a specific logical system called "HOL" which doesn't just mean "higher order logic"
15:18:44 <headclone> parcs: it doesn't natively, but is there a package or plugin that could make it?
15:19:08 <mun_> Cale, indeed. but i think both the wikipedia and that glossary refer to the HOL logic, right?
15:19:09 <byorgey> headclone: if you want an IDE with good support for Haskell I recommend trying EclipseFP or Leksah
15:21:41 <Cale> mun_: Compare: http://en.wikipedia.org/wiki/Higher-order_logic  with  http://en.wikipedia.org/wiki/HOL_theorem_prover
15:22:02 <headclone> byorgey: i'm just starting the haskel tutorial, would that be overkill?
15:22:18 <Cale> The HOL theorem prover takes its name from higher order logic, but people also use HOL as an abbreviation of "higher order logic" more generally.
15:22:32 <Cale> So you have to be quite careful about what thing people are talking about
15:22:58 <byorgey> headclone: perhaps, I don't know.  It depends how important it is to you to have syntax highlighting =)
15:23:17 <Cale> dude, much simpler text editors than that have syntax highlighting for haskell
15:23:18 <mun_> Cale, yeah. but http://en.wikipedia.org/wiki/Higher-order_logic talks about the logic, and so is http://proof-technologies.com/Glossary under "HOL logic : (n)"
15:23:49 <byorgey> Cale: can you recommend a good one then?  all I know is emacs =)
15:23:50 <Cale> The second link is about the theorem prover
15:23:56 <mun_> but the wikipedia entry says HOL typically refers to a logic with a simple type system, without a polymorphic type system.
15:23:57 <Cale> The first link you gave is about the logic
15:24:03 <Cale> yes
15:24:18 <Cale> You have to be careful because there's a theorem prover called HOL
15:24:25 <Cale> which is not just simple arbitrary higher order logic
15:24:36 <Cale> but a specific higher order logic system with lots of extra features and stuff
15:25:16 <Cale> byorgey: I thought that Notepad++ came with Haskell syntax highlighting.
15:25:48 <sohum> @hoogle Eq a => (a -> a -> a) -> Map a k -> Map a k -> Map a k
15:25:49 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
15:25:49 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
15:25:53 <mun_> Cale, yeah, but the entry "HOL family : (n)" refers to the HOL theorem prover, isn't it? why do you think the entry "HOL logic : (n)" refers to the theorem prover as well? because it claims that it has a polymorphic type system?
15:26:14 <sohum> um
15:26:27 <Cale> oh, maybe not...
15:26:29 <Cale> huh
15:26:35 <headclone> byorgey: its not that important, just a convenient feature, i guess
15:26:38 <sohum> @hoogle Eq k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
15:26:39 <lambdabot> Data.Map unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
15:26:39 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
15:26:46 <headclone> which of the two you recommended is better in your opinion?
15:26:47 <Cale> http://research.cs.queensu.ca/home/cisc260/2007w/Resources.html links to a haskell syntax highlighting file for notepad++
15:26:51 <sohum> okay, so only those two
15:27:41 <Cale> mun_: That entire glossary is *specifically* about the theorem prover
15:27:51 <Cale> mun_: Not about logic in general
15:28:00 <byorgey> headclone: I think EclipseFP is probably better, but you may find it too complex if you are not familiar with Eclipse already.
15:28:29 <Cale> I kinda think it's insane to use an IDE for Haskell at this point :P
15:28:42 <Cale> None of them are really satisfying to me.
15:28:44 <mun_> right
15:28:59 <byorgey> headclone: oh, did you see the syntax file for notepad++ that Cale linked to above?
15:29:01 <Peaker> Cale: seems like EclipseFP made some impressive progress
15:29:16 <Peaker> Cale: the last reddit showoff of features seemed very nice
15:29:30 <mun_> so, neither FOL or HOL support a polymorphic type system in their standard form?
15:29:47 <Cale> mun_: right
15:29:59 <Cale> mun_: Neither of them have anything to do with types in their standard form
15:30:20 <Cale> They don't even have anything recognisable as a type system, unless you count arities.
15:30:28 <fryguybob> headclone: I use notepad++ and I think the highlighting worked for me out of the box.  I don't think it works for .lhs files though.
15:30:31 <headclone> byorgey: oh, no, can i see it?
15:30:57 <mun_> Cale, so what does one need in order to augment HOL for it to support polymorphism?
15:31:07 <headclone> also, i've used eclipse for ages for java
15:31:29 <byorgey> headclone: http://research.cs.queensu.ca/home/cisc260/2007w/Resources.html
15:31:42 <Cale> Yeah, I really thought that Notepad++ came with Haskell syntax by default. I see complaints online by people saying that it automatically picks Haskell syntax highlighting when faced with ActionScript files (hehe)
15:31:59 <headclone> sweet thanks
15:32:04 <Cale> mun_: Well... first you need to add a type system
15:32:18 <Cale> mun_: Because these logics don't have type systems.
15:32:49 <Cale> So it doesn't even make sense to talk about polymorphism yet, since you can apply any function symbol to any arguments that exist.
15:32:58 <mun_> right
15:34:16 <Cale> So, you stick your favourite type system onto the HOL, and whatever polymorphism it has will be the polymorphism of the logic, I guess.
15:35:03 <Cale> In general, it's probably a big tedious process, but most of it should be pretty obvious.
15:35:10 <Cale> (like most things in logic :P)
15:35:41 <MHD> cabal gives me weird errors
15:35:58 <mun_> right
15:36:22 <ARRG> Quick question because I'm not sure I got that right. If i define a datatype  "data (Ord k) => Test k" and then write a function "func :: Test k -> b", Haskell doesn't infer that k derives Ord ?
15:36:40 <hpaste> MHD pasted â€œWeird Cabal Errorâ€ at http://hpaste.org/50994
15:37:10 <MHD> Anybody know what the hell^
15:37:18 <dankna> that is weird
15:37:24 <dankna> try again with -v3
15:37:42 <benmachine> ARRG: yeah, datatype contexts don't do what you want them to do
15:37:51 <benmachine> ARRG: they were outright removed in haskell2010 for being useless
15:38:31 <hpaste> MHD annotated â€œWeird Cabal Errorâ€ with â€œWeird Cabal Error (annotation)â€ at http://hpaste.org/50994#a50995
15:38:39 <ARRG> Okay... that's a bit disappointing. Thanks benmachine
15:38:42 <rwbarton> IIRC the only thing they do is add an artificial (Ord k) context to all the constructors of Test k; so the answer to your question is yes
15:38:53 <MHD> danka: I don't know what to infer from that
15:38:59 <benmachine> ARRG: you may find GADTs do what you want
15:39:05 <MHD> damnka: put it in an annotation
15:39:25 <rwbarton> (or non-generalized but existentially quantified ADTs)
15:39:35 <rwbarton> (but use GADTs anyways)
15:39:56 <MHD> dankna: can't seem to spell your name right
15:40:09 <MHD> put it in an annotation
15:40:14 <MHD> got a clue?
15:40:25 <ARRG> GADTs... ok I'll look that up thank you
15:40:58 <rwbarton> You might find the documentation on existentially quantified types more directly relevant to your situation
15:42:07 <Cale> ARRG:  data Test k where Con1 :: (Ord k) => k -> Test k
15:42:15 <Cale> ARRG: something like that
15:42:26 <MHD> You have got to be shitting me
15:42:26 <dankna> MHD: hmm
15:42:37 <Cale> ARRG: it'll pack an Ord dictionary along with the constructor when you make values then.
15:42:56 <MHD> dankna, It looks like there's an accidental incrementation of the tempfile name
15:42:58 <dankna> MHD: the link is failing because cabal is trying to pass the -ltinfo option to ld
15:43:08 <dankna> no, that's not it
15:43:13 <MHD> ok
15:43:17 <dankna> it invokes ghc to turn 2577.c into 2577.o
15:43:24 <dankna> then it invokes ld to turn 2577.o into 2578.o
15:43:27 <dankna> but ld fails
15:43:30 <MHD> so what should I pass -ltinfo to?
15:43:32 <dankna> and see why it fails?  unrecognized option
15:43:40 <monochrom> "/usr/bin/ld: cannot find -ltinfo"
15:43:40 <dankna> oh, do you know what -ltinfo is?
15:43:43 <dankna> is that something you gave it?
15:43:52 <MHD> yes
15:43:57 <MHD> yi needs it apparently
15:44:02 <rwbarton> when is "data Test k where Con1 :: (Ord k) => k -> Test k" good style compared to putting an Ord k instance on all your functions (like in Data.Map)?
15:44:03 <dankna> the question should be, why did you give it that and what are you hoping it will accomplish
15:44:04 <dankna> ah :/
15:44:04 <monochrom> perhaps you need one more "-"
15:44:09 <dankna> so you don't know why then
15:44:13 <dankna> yeah, possibly what monochrom said
15:44:22 <benmachine> monochrom: it's not a long option
15:44:31 <monochrom> then sorry
15:44:34 <Cale> rwbarton: When you don't mind having fancy extensions? :)
15:44:35 <dankna> gah, when will we get typed command lines already :D
15:44:39 <MHD> when i try to compile yi normally it gives me this missing symbol
15:44:44 <monochrom> but ld is disliking -ltinfo, that's for sure
15:44:48 <dankna> what's the missing symbol?
15:44:59 <rwbarton> It also means you are storing pointers to dictionaries in your data, right?
15:45:06 <MHD> can't remember of the top of my head, but it is in tinfo
15:45:14 <Cale> rwbarton: yes
15:45:22 <dankna> oh!  it's a library
15:45:24 <benmachine> do you *have* libtinfo? is it somewhere sensible?
15:45:36 <dankna> the proper place to put a library flag is in other-libraries: in the .cabal file
15:45:41 <Cale> rwbarton: It compiles to  Con1 :: Ord k -> k -> Test k
15:45:43 <Cale> essentially :)
15:45:56 <MHD> dankna: what part of the cabal file would that be?
15:45:58 <rwbarton> yeah
15:46:14 <rwbarton> so it's possible that ARRG's problem would be best solved by just writing all the (Ord k) contexts
15:46:25 <Cale> and then unpacks and uses the dictionary from there when you pattern match with case
15:46:36 <Cale> (which is the tricky part to get right with regard to typechecking)
15:46:59 <dankna> MHD: the Executable section
15:47:11 <Cale> Well, it's six of one, half a dozen of the other.
15:47:18 <Cale> :)
15:47:18 <dankna> it should just be other-libraries: tinfo, I believe
15:47:32 <monochrom> half-empty dozen? half-full dozen? XD
15:47:43 <Cale> If it makes sense to restrict the data constructors, it probably makes sense to carry evidence around with the data.
15:48:32 <Cale> You're going to end up passing those instances around anyway
15:48:47 <Cale> and they've got to come from somewhere
15:49:05 <Cale> I suppose if you had large aggregates of data, it might suck to have lots of pointers to the same instance.
15:49:15 <rwbarton> if I have a Map with a million items in it, though, it doesn't seem good to store a million poitners, yeah
15:49:32 <Cale> But pff, constant factor :)
15:49:51 <mun_> Cale, so with HOL with polymorphism again, what would be an example polymorphism type system that one could extend HOL with?
15:49:58 <dalaing> Cale: rwbarton: any advice on which way to default as a Haskell newb?
15:50:12 <MHD> dankna: cabal dislikes other libraries
15:50:16 <Cale> dalaing: Just add the contexts to your functions
15:50:21 <dankna> MHD: let me check what the option is called
15:50:24 <Cale> dalaing: That way you don't need extensions
15:50:24 <dalaing> until now I thought adding an Ord k instance on the functions was the way
15:50:46 <Cale> dalaing: Yeah, it's simple, and most of the time it's just fine.
15:50:52 <dalaing> cool, thanks heaps
15:51:00 <dankna> ah!  it's extra-libraries not other-libraries
15:51:24 <Cale> mun_: Well, you're essentially transfiguring the whole thing, so basically any type system in existence.
15:51:42 <Cale> mun_: You're redefining everything to do it, so you can do whatever you want.
15:51:46 <nkpart> I'm surprised that this bug (http://hackage.haskell.org/trac/ghc/ticket/2551) on multiple modules per file was so quiet
15:52:05 <monochrom> you can use hindley-milner polymorphism as a starter
15:52:06 <rwbarton> dalaing: Giving GADT constructors contexts is really useful when the type (k in this case) doesn't appear as an argument of the GADT
15:52:09 <rwbarton> if that made sense
15:52:34 <rwbarton> so, something like data Test {- no k -} where Con1 :: (Ord k) => k -> Test k
15:52:39 <rwbarton> Perhaps you already know this :)
15:52:50 <dalaing> it's right at the edge of my knowledge
15:52:56 <Cale> nkpart: One module per file is not that difficult a restriction to cope with
15:53:14 <sohum> @hoogle (a -> a) -> (a,b) -> (a,b)
15:53:15 <Cale> nkpart: Particularly since we don't have module-level functions or anything like that.
15:53:15 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
15:53:15 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:53:15 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
15:53:33 <sohum> @hoogle (a -> c) -> (a,b) -> (c,b)
15:53:33 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
15:53:34 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:53:34 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
15:53:45 <dalaing> although that does look like something that'd be _really_ nice to have when you needed it
15:53:54 <nkpart> Yeah I cope okay :)
15:54:11 <Cale> nkpart: And it helps the sanity of people who are new to a project, by making it possible for them to find modules without having to grep.
15:54:13 <nkpart> I think being able to package things up in different modules, in a single file, would be handy
15:54:14 <monochrom> haskell's module system is boring enough to be ok with one file per module
15:54:51 <Cale> Once you start sticking lots of modules into one file, people have to remember which modules are in which file.
15:55:12 <mun_> Cale, thanks
15:55:28 <nkpart> Well the ridiculous conclusion to that would be to have a function in a file named after the function
15:55:33 <nkpart> so we don't have to grep for them either :)
15:56:26 <dankna> MHD: is that working for you?
15:56:40 <Cale> sure... though most if not all modules are of a decent size that you can reasonably spend a decent amount of time working on just one module
15:57:09 <Cale> Most functions or value definitions are only a few lines.
15:57:11 <nkpart> what would a module-level function be?
15:57:35 <Cale> nkpart: A function which takes one or more modules as parameters and produces a module as its result.
15:57:44 <MHD> Woohoo! I have yi!
15:57:48 <monochrom> if you shift paradigm to a smalltalk-like system altogether, you no longer have files, you just have modules, you ask for individual modules and you get them, you don't worry that the implementation prefers to store individual characters into mysql, that is, each row has the fields: module, line number, column number, character
15:58:09 <Cale> Essentially, a module parametrised over what modules it imports.
15:58:56 <nkpart> Ah right, interesting
15:59:11 <Cale> So you can plug in different implementations of the same library and get functionality in terms of that
15:59:35 <Cale> (including, crucially, type definitions in terms of types defined in those parameter libraries)
15:59:37 <monochrom> sml has module-level functions called functor
15:59:41 <Cale> right
16:00:01 <Cale> Does it allow module-level general recursion?
16:00:03 <geheimdienst> cale: sounds vaguely how those hashes stuck to packages include the hashes the package depends on ...
16:00:30 <Cale> That might be interesting :)
16:00:32 <monochrom> I believe not
16:00:51 <benmachine> Cale: modules that import themselves? :o
16:00:54 <Cale> (but probably pretty pointless)
16:00:58 <Cale> benmachine: yes
16:01:01 <benmachine> or, well, I suppose mutual recursion is pointful
16:01:06 <benmachine> in some cases
16:01:35 <monochrom> but ask Robert Harper for sure :)
16:02:26 <kadoban> is there a (probably builtin) module that helps work with filenames.  looking for stuff like, get the extension of a given filename, etc.
16:03:13 <monochrom> yes! comes with ghc too. System.FilePath
16:03:18 <ddarius> I'm pretty sure (completely certain) that the ML module system is explicitly designed to be strongly normalizing.
16:03:54 <geheimdienst> > "lol" </> "cat"
16:03:55 <lambdabot>   Not in scope: `</>'
16:04:04 <geheimdienst> oh grate
16:04:17 <ddarius> It would be very unlike ML designers to blatantly add in something that would make the type checker loop.
16:06:44 <AIFunctional> This website is quite nifty~
16:07:02 <monochrom> you mean tryhaskell.org?
16:07:07 <AIFunctional> yeah
16:07:25 <monochrom> yes, best thing since www :)
16:11:45 <kadoban> monochrom: thanks (for System.FilePath)
16:31:13 <kmc> @run fix ((0:) . scanl (+) 1)
16:31:15 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:50:23 <Hazkel> register info
16:50:36 <Hazkel> lol
17:19:37 <AIFunctional> what exactly does the function map do?
17:20:21 <Samy> :t (+ 1)
17:20:21 <lambdabot> forall a. (Num a) => a -> a
17:20:26 <copumpkin> it applies a function to every element in a list
17:20:29 <tgeeky> I think it takes maps (like pictures of your neighborhood), and functions them
17:20:29 <Samy> > map (+ 1) [ 1 .. 10 ]
17:20:30 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
17:20:33 <ddarius> map id = id, the rest is determined by the type.
17:20:47 <tgeeky> oh, that's backwards.
17:21:05 <geheimdienst> > map (*2) [1..5]
17:21:06 <lambdabot>   [2,4,6,8,10]
17:21:40 <Axman6> > map show [1,2,3[
17:21:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:21:42 <Axman6> > map show [1,2,3]
17:21:43 <lambdabot>   ["1","2","3"]
17:22:18 <kmc> @src map
17:22:18 <lambdabot> map _ []     = []
17:22:18 <lambdabot> map f (x:xs) = f x : map f xs
17:22:25 <ddarius> > map f [x,y,z]
17:22:27 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:22:27 <lambdabot>    `GHC.Show.Show b'
17:22:27 <lambdabot>      a...
17:22:37 <ddarius> > map f [x,y,z] :: Expr
17:22:39 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
17:22:39 <lambdabot>         against inferred ...
17:22:39 <kmc> > map f [x,y,z] :: [Expr]
17:22:41 <lambdabot>   [f x,f y,f z]
17:24:51 * hackagebot Digit 0.0.3 - A data-type representing digits 0-9  http://hackage.haskell.org/package/Digit-0.0.3 (TonyMorris)
17:25:55 <Axman6> AIFunctional: make sense?
17:27:16 <Peaker> Name it DecimalDigit? :P
17:36:11 <dalaing> I'm wondering if that's the Tony Morris from the Brisbane functional programming group
17:37:56 <copumpkin> yes
17:39:30 <mun_> if some constant c is of type T, is it right to say that "T is the type assigned to c", or is it the other way around: "c is assigned to type T"?
17:40:34 <mauke> I shall assign the type judgment (c :: T) to your code, sir
17:40:42 <ddarius> The former would be more common, but "assigned" is a bit imperative.
17:40:56 <monochrom> I don't think it matters
17:41:19 <mun_> ddarius, why is it imperative?
17:44:12 <kmc> i would say "T is the type assigned to c" but i'd rather not say either
17:44:16 <ddarius> It somewhat comes down to Church v. Curry approaches to types.  I would say Haskellers tend to be (ironically) of the Church perspective.
17:44:31 <kmc> "T is the type of c" is just as good
17:44:35 <kmc> ddarius, what are the two approaches?
17:44:37 <monochrom> I just say "c has type T"
17:44:41 <drdo> I usually just say "c is in T" or "c has type T"
17:45:09 <kmc> map (3 ::) [Int, Float, Double]
17:45:18 <monochrom> oh! TaPL mentions Church vs Curry too
17:45:22 <ddarius> So, for example, True is not something that has meaning without a type.  It is inherently a Bool, rather than being arbitrarily "assigned" the type Bool by the type system which could have just as well "assigned" a different type.
17:45:59 <ddarius> kmc: Church-style is that terms have no meaning without types.  Curry-style is that you have a collection of meaningful terms and types simply classify that collection.
17:46:13 <kmc> i see
17:46:15 <drdo> ddarius: True is a type constructor
17:46:25 <ddarius> drdo: No, True is a data constructor.
17:46:27 <geheimdienst> how about polymorphic things? (read "lol") could have lots of types
17:46:39 <ddarius> geheimdienst: They have polymorphic types.
17:46:43 <kmc> it has a single polymorphic principal type
17:46:48 <kmc> (up to Î±-equivalence)
17:46:49 <lpsmith> Is there documentation available for GHC's variant of C--?
17:47:05 <kmc> some type systems don't have principal types, though
17:47:29 <kmc> you can have a situation where x :: S and x :: T will both typecheck, but there's no type which generalizes both S and T
17:47:37 <kmc> that's bad
17:47:43 <copumpkin> lpsmith: I think your best bet is http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType
17:47:46 <copumpkin> that's what I've been using
17:48:08 <kmc> i forgot whether GHC loses principle typing property if you pull out all the stops
17:48:11 <monochrom> no, but I have figured out that Sp stands for stack pointer, Hp stands for heap pointer (at allocation sites, if the heap hasn't been exhausted yet, you just increment the heap pointer to say you allocate more stuff)
17:48:19 <lpsmith> Ahh, I was looking at GHC's binding to the GMP actually :)
17:48:49 <copumpkin> lpsmith: what about it?
17:49:51 * hackagebot cab 0.1.6 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.6 (KazuYamamoto)
17:50:26 <lpsmith> copumpkin: well, I'm looking to actually get a small start on the extended gmp bindings we talked about.  That and the existing bindings don't use the standard FFI, but uses some hand-written cmm code
17:50:33 <monochrom> GHC loses principle typing property when enough extensions are enabled. the recent SPJ et al. type checking paper says it. it is also why he is so keen on MonoLocalBinds --- if there is no principle type, may as well mono it or else gimme a type sig
17:50:54 <copumpkin> lpsmith: I had a patch in the ghc trac to add some gmp functions people thought would help to our binding
17:51:01 <copumpkin> but they've been rotting in there for over a year now
17:54:29 <lpsmith> copumpkin: do you have a link?
17:55:06 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3489
17:55:37 <lpsmith> heh, found it about the same time I got your message
18:01:28 <lpsmith> hmm, interesting
18:03:03 <lpsmith> Though I seem to recall that somebody was explaining that the limited binding to the GMP was intentional.
18:03:42 <lpsmith> So I've wondered if it wouldn't be better to have extended bindings on Hackage or something,  external to GHC
18:11:33 <magicman> >_<
18:11:51 <magicman> For months now, I have :set -XNoMonorphismRestriction in my .ghci, and I hadn't noticed the typo.
18:12:24 <monochrom> hehehe
18:13:50 <shachaf> magicman: It tells you when it doesn't recognize a flag, though.
18:14:11 * shachaf used to have -XOverloadedStrings, but sadly it causes defaulting annoyances.
18:14:33 <magicman> Yeah. I only noticed it because I just installed a new GHC, and the error message was different than what I was used to.
18:14:42 <magicman> No clue why I didn't notice it before :P
18:16:08 <parcs> shachaf: defaulting annoyances like what?
18:16:14 <parcs> oh foo = "foo"
18:17:05 <shachaf> parcs: "a" ++ "b"
18:17:08 <shachaf> Almost anything you'd want to do with strings.
18:19:06 <lpsmith> copumpkin: I don't suppose you've experimented with going through S# and J# constructors and the standard FFI to get to GMP?   It might make things a bit less dependent on the internals of GHC.   Also have you considered attempting an "external" binding instead of getting GHC to accept your patch?
18:27:18 <copumpkin> lpsmith: it can't be done easily without cmm, really
18:28:01 <lpsmith> yeah, I hadn't really started investigating that possible avenue yet
18:29:33 <copumpkin> lpsmith: I do have an external binding to parts of the mpn API in gmp
18:29:34 <copumpkin> for naturals
18:29:42 <copumpkin> but it's mostly a copy of integer-gmp still
18:29:51 * hackagebot netwire 1.2.0 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.0 (ErtugrulSoeylemez)
18:29:57 <copumpkin> if you look at that or also the mpfr binding that edwardk and I have been working on, you can see what's needed
18:30:19 <copumpkin> but the basic issue is that gmp has a global allocator and integer-gmp sets it to the ghc allocator
18:30:36 <copumpkin> which means you need to jump through some hoops to make sure the GC notices you still hold references to the memory
18:31:08 <lpsmith> Yeah, I kinda figured that from glancing at the cmm code, even though I didn't understand most of it
18:31:45 <lpsmith> obviously I don't understand the details of that issue at this point in time.
18:32:42 <copumpkin> you could still write a mostly C binding to gmp even with the allocators, but it'd be a pain
18:34:48 <lpsmith> Do you know if the gmp binding has the issue of stopping other system thread while in the GMP?   (I would assume not... that would seem to be a major shortcoming)   I also assume the gmp binding performs better than a hypothetical standard-ffi binding
18:35:45 <kmc> i imagine the gmp calls are equivalent to "foreign import unsafe", for speed
18:35:52 <kmc> and that they're expected to be quick and non-blocking
18:36:03 <lpsmith> I don't think you can make that assumption
18:36:06 <kmc> i do not have hard knowledge on this
18:36:36 <lpsmith> To clarify, I don't think you can assume gmp calls are quick and non-blocking
18:36:45 <kmc> it's possible you can DoS the whole GHC runtime by doing arithmetic on gigantic Integers
18:36:58 <lpsmith> oh, it is.  Hmm
18:37:00 <kmc> is there a different reason why they might not be quick and non-blocking?
18:37:15 <kmc> (other than gigantic integers, i mean)
18:37:16 <copumpkin> it definitely blocks GC while it's happening (although the individual calls do run GC if necessary)
18:37:18 <lpsmith> No, just crazy arithmetic on large enough integers is what I had in mind
18:37:19 <copumpkin> I doubt it blocks anything else
18:37:42 <kmc> i bet you could fix this with some kind of lamentable UNIX hack
18:38:03 <kmc> SIGALRM handler which longjmps back to the gmp call and does it the safe way
18:38:07 <kmc> or some shit like that
18:38:18 <lpsmith> well, I would think that blocking GC would be enough to cause problems in some situations
18:38:44 <kmc> ah, because GMP itself wants to allocate in the GHC heap?
18:38:56 <lpsmith> even if computation can proceed independently in some other operating system thread
18:39:00 <lpsmith> kmc: right
18:39:04 <kmc> hmm
18:39:27 <kmc> copumpkin, what did you mean by "although the individual calls do run GC if necessary"
18:39:37 <copumpkin> there's a macro called MAYBE_GC that they all call
18:39:40 <kmc> what happens when GMP asks the GHC allocator for memory and there isn't any?
18:39:46 <copumpkin> beatas me :)
18:39:48 <copumpkin> beats
18:41:14 <lpsmith> heh,  maybe the gmp needs non-blocking async arithmetic :-P
18:41:29 <kmc> haha
18:41:36 <kmc> if only gmp would sit at the other end of a pipe we can epoll
18:42:08 <copumpkin> :P
18:42:25 <kmc> out of curiosity, how does integer-simple performance compare to integer-gmp?
18:43:37 <ddarius> Presumably horribly.
18:43:43 <lpsmith> no idea.  I'd imagine it'd take some serious effort to be competitive with the gmp
18:47:38 <kmc> probably
18:47:49 <kmc> one annoyance is that you can't switch integer libs unless you recompile ghc
18:47:51 <kmc> (to my knowledge)
18:48:12 <tgeeky> hm? you can't just write your own?
18:48:28 <lpsmith> we have.  It's called integer-simple
18:48:41 <ddarius> kmc: You may be able to use the integer-simple modules directly.
18:48:43 <kmc> well you can't make the already-compiled code in 'base' and such use your Integer
18:48:46 <kmc> yeah
18:48:48 <tgeeky> and you have to recompile ghc to use it?
18:49:05 <kmc> but maybe this is not a huge problem, because there just aren't many library functions for Integer specifically
18:49:09 <tgeeky> kmc oh. but that's fine, if you are replacing Int or Integer, then you may as well just roll your own everything
18:49:13 <ddarius> tgeeky: The only reason this was done at all is because GMP is GPL.
18:49:30 <tgeeky> ddarius: and that's objectionable?
18:49:38 <kmc> (LGPL)
18:49:42 <mm_freak> ok, next release of netwire is outâ€¦  events are now solely based on signal inhibition, which seems to be much more convenient than the traditional approach using something like Maybeâ€¦  it's also faster and saves you a lot of switchesâ€¦  i'd be grateful for feedback
18:49:48 <kmc> tgeeky, for some people.  the integer-simple work was funded by the Industrial Haskell Group
18:49:48 <ddarius> LGPL and GHC (usually) statically links.
18:49:56 <tgeeky> kmc: i was just about to say
18:50:00 <lpsmith> tgeeky: it can be for users of GHC.
18:50:08 <tgeeky> kmc: these quants might not want to share things :O
18:50:15 <kmc> tgeeky, they aren't publishing their binaries anyway
18:50:15 <ddarius> It's only recently that integer-simple was added.
18:50:37 * tgeeky departs to the airport
18:50:47 <kmc> most software in the world is neither published as binary nor as source
18:51:01 <tgeeky> yeah
18:51:02 <ddarius> tgeeky: It does mean you can't distribute your stuff as BSD in theory.
18:51:14 <kmc> it's true that sometimes quants within a company will share libs with other quants on a binary-only basis
18:51:21 <lpsmith> BSD is GPL-compatible
18:51:44 <kmc> right
18:51:52 <kmc> compatible means that it is possible to comply with the terms of both licenses at once
18:52:06 <kmc> LGPL does impose terms beyond the BSD terms, though
18:52:15 <lpsmith> so it's not a problem unless you want to make a proprietary fork of ostentiably BSD-licensed code
18:52:18 <lpsmith> exactly
18:52:37 <kmc> it's a problem because LGPL requires that you make your binary re-linkable by the end user
18:52:49 <kmc> which for GHC Haskell would mean distributing .hi and .o files
18:52:59 <kmc> well maybe not .hi
18:53:09 <ddarius> lpsmith: Which is something that you may well want to do, and you don't want to then find out you can't because of an non-obvious LGPL dependence that you have no way of avoiding.
18:53:18 <ddarius> Probably .hi too.
18:53:53 <lpsmith> ddarius: yup, that'd be the problem.  :)
18:53:57 <Jafet> Is this problem a problem?
18:54:15 <ddarius> Presumably enough of a potential problem that something was done about it.
18:54:17 <kmc> it's a problem for some people, enough that they funded the IHG to get rid of it
18:54:21 * kmc thinks we're going in circles now
18:54:28 <Jafet> Oh, I missed this memo
18:55:51 <lpsmith> but yeah,  my understanding is this licensing issue why GHC HQ is reluctant to release more extensive bindings to the GMP
18:56:19 <kmc> interesting
18:56:33 <kmc> i also wonder how much Haskell code cares about the performance of Integer
18:56:37 <lpsmith> As it makes it potentially more difficult to get out from the LGPL for less-than-obvious reasons.
18:57:11 <kmc> like, if you spend a week writing a decent BSD-licensed multi-precision integer library in C
18:57:21 <kmc> it won't perform as well as GMP
18:57:25 <dalaing> I know very very little about GHC internals - what are the problems with dynamically linking GMP ?
18:57:26 <Jafet> Or just link libtommath
18:57:35 <kmc> but it might perform well enough to make GMP not the default
18:57:47 <kmc> also, yeah, there must be BSD-licensed libs already... is libtommath one?
18:58:17 <Jafet> x% of haskell code doesn't need kick-ass Integer performance. The remaining 1-x% is useless without kick-ass Integer performance.
18:58:25 <Jafet> Where x is, 98 or something.
18:58:31 <lpsmith> hah
18:58:37 <dalaing> the question I'm really interested in: is dynamic linking avoided on principle, or is there a technical hurdle?
18:58:44 <Jafet> Perhaps they should fix ghc to be able to link gmp via ffi
18:58:50 <kmc> dalaing, GMP is compiled to use the GHC allocator
18:59:02 <kmc> which means the vanilla libgmp already on your system would not work
18:59:09 <dalaing> ah
18:59:13 <kmc> however maybe GHC could distribute a separate dynamically-linked gmp
18:59:29 <Jafet> It would be extra work to keep that up-to-date
18:59:43 <pikhq_> They could make a vanilla libgmp work; IIRC you can pass it an allocator.
18:59:50 <dalaing> more or less work than replicating GMP? :)
18:59:53 <Jafet> On the other hand, the gmp developers seem to be releasing too slowly
19:00:03 <Jafet> So perhaps you only need to do that, say, once a year
19:00:09 <Nimatek> What exactly is the problem with LGPL?
19:00:19 <Nimatek> You can still use it in non-free code.
19:00:29 <lpsmith> Jafet:  the limited bindings to the GMP limits that percentage too... say you have kick-ass modular exponentiation,  jacobi symbols,  etc,  and  Haskell would be potentially more useful and you'd see more code that is dependent on good integer performance.
19:00:38 <Jafet> pikhq: but it manages its memory internally, so I'm guessing that won't work with garbage collection
19:00:41 <pikhq_> Nimatek: It's somewhat difficult to comply with in GHC, because GHC doesn't do dynamic linking.
19:00:46 <kmc> Nimatek, <kmc> it's a problem because LGPL requires that you make your binary re-linkable by the end user which for GHC Haskell would mean distributing .hi and .o files
19:00:49 <pikhq_> Jafet: Oh. Bleh.
19:01:02 <Nimatek> pikhq_, kmc - Ah, okay.
19:01:04 <Jafet> pikhq: in other words, you pass it both a malloc and a free.
19:01:15 <pikhq_> Jafet: Yeah.
19:01:26 <kmc> Jafet, i assume you would only ship a new libgmp with each new GHC, same as now
19:01:53 <pikhq_> And then it does its own allocation, in hopes that it can do better.
19:02:13 <lpsmith> Jafet,  there are problems associated with the ffi that might not be present with the current binding
19:02:14 <pikhq_> Well. Maybe it can; malloc isn't exactly the fastest allocator interface.
19:03:25 <lpsmith> like,  the overhead of a "safe" call to C is on the order of 100ns on my laptop.    An "unsafe" call is more like 7ns,  but unsafe calls block the GHC runtime from doing anything until it completes,  even in other OS threads.
19:04:04 <Jafet> If you're using gmp, 100ns is probably inconsequential
19:04:20 * copumpkin tries to catch up with the conversation
19:04:32 <Jafet> Your operations are using something like 100Âµs
19:04:50 <ddarius> copumpkin: It's not worth it.
19:04:51 <lpsmith> The safe calls however,   allow computations to proceed inside other OS threads,  if you are running a multithreaded runtime.
19:05:01 * copumpkin stops catching up with the conversation
19:05:34 <Jafet> Just throw around CT jargon and we'll assume you're following it
19:06:01 <copumpkin> extranatural transformation
19:06:09 <copumpkin> we need two of them for gmp
19:06:21 <copumpkin> and one profunctor
19:07:32 <lpsmith> Jafet:  100Âµs seems pretty high for small integer arithmetic
19:08:27 <lpsmith> I'm assuming that's for whatever larger integers you tend to deal with?
19:10:44 <lpsmith> Jafet: by "small integer" I mean something that fits into a few machine words
19:11:22 <ddarius> 100µs is on the order of half a million cycles.  There's a whole lot that you can do in half a million cycles.
19:12:47 <Jafet> Oh, ok.
19:13:07 <Jafet> What sort of code uses numbers of that size?
19:15:07 <lpsmith> project euler problems when you don't want to think about keeping things from overflowing.
19:15:41 <lpsmith> And therein lies the reason why these extended gmp bindings haven't been a very high priority for me
19:17:23 <lpsmith> But it'd be nice to have access to faster gmp ops sometimes,  and I can see how that could benefit Haskell and potential issues
19:17:26 <kmc> but project euler is like the main way people decide whether haskell is worthwhile!
19:17:47 <dolio> The shootout is way more important for that.
19:17:50 <Jafet> It probably still beats doing them in java.
19:18:11 <ddarius> copumpkin: two categories, one functor
19:18:31 <dolio> I make all my decisions based on the performance of a very specifically limited prime sieve program.
19:18:37 <copumpkin> I'd accept nothing less
19:19:00 <ddarius> "Should I marry Clara?  To the Shootout!"
19:19:25 <lpsmith> I mean,  I used hugs (GHC 5?) in my number theory course,  I liked Haskell for the purpose but it was slow.   But then again I never really had to do any demanding computations in it either
19:19:55 <ddarius> I don't understand "hugs (GHC 5?)"
19:20:07 <lpsmith> I think it was hugs, but maybe it was GHC 5
19:20:27 <ddarius> lpsmith: Did it have crappy error messages?
19:20:41 <lpsmith> I don't remember
19:20:51 <ddarius> GHC 5 wasn't that long ago.
19:21:00 <lpsmith> uhh... 11 years?
19:21:04 <lpsmith> 10?
19:21:04 <ddarius> Yes.
19:21:32 <lpsmith> All I remember is that I started using GHC 5 from the very first release and very rarely used Hugs after that
19:21:58 <ddarius> So you started using GHC about a year or so before me.
19:22:03 <lpsmith> Before that I used hugs almost exclusively, though I did toy with GHC from time to time.
19:22:24 <lpsmith> Yeah,  I started using GHC like literally the first day GHC 5 was released
19:22:53 <Jafet> If the FFI is too slow, what else can be done?
19:23:12 <ddarius> Write C and bind to coarser functions.
19:23:26 <ddarius> Or you may be using the FFI in an inefficient manner.
19:23:38 <lpsmith> Well, I don't understand all the reasons that GHC has a very custom binding to GMP, but I assume that's part of it.
19:23:45 <ddarius> Alternatively, Harpy or the LLVM bindings.
19:24:09 <Jafet> Assuming <lpsmith> the overhead of a "safe" call to C is on the order of 100ns
19:24:46 <lpsmith> On my laptop, using ghc 7, yeah, that's what I've observed
19:24:48 <lpsmith> IIRC
19:25:48 <lpsmith> it's a bit more than an order of magnitude slower than an unsafe call.
19:28:43 <AIFunctional> I understand that I can ask for the type using :t, but how do I define one myself?
19:29:42 * ddarius finds that question bizarre.
19:29:54 <ddarius> AIFunctional: By reading an introduction to Haskell.
19:30:00 <lpsmith> AIFunctional: type,  newtype, data
19:30:01 <monochrom> could you give an example?
19:30:06 <AIFunctional> yes please
19:30:24 <Jafet> writeFile "foo.hs" type; :load foo.hs
19:31:08 <parcs> you can't define a type within ghci
19:32:02 <parcs> why is newtype called newtype anyway?
19:32:13 <dalaing> AIFunctional: when you say "asking for the type" are you talking about data types or about the types of functions?
19:32:21 <Jafet> It defines a newtype.
19:32:22 <ion> It creates a new type instead of just an alias.
19:32:31 <zomg> parcs: apparently there's a magazine about haskell in japan, adorned with lots of anime characters
19:32:40 <zomg> It's called "newtype"
19:32:49 <zomg> (and it has nothing to do with haskell, but it was a funny idea)
19:32:50 <zomg> =)
19:33:30 <AIFunctional> I want to create a new data type; define a type called Person that is a triple with the name of the person, age of the person and the name of the father, for example
19:33:48 <ion> Iâ€™d suggest reading an introduction to Haskell.
19:33:51 <ion> @where lyah
19:33:51 <lambdabot> http://www.learnyouahaskell.com/
19:34:02 <Jafet> An introduction to ghci
19:34:11 <Jafet> Sorry, typo
19:34:26 <AIFunctional> I just went through the tutorial on tryhaskell.org.
19:34:58 <AIFunctional> First time ever trying to program in something other than a computational scripting language
19:35:13 <AIFunctional> bare with me
19:35:40 <dalaing> AIFunctional: Learn you a Haskell is a pretty good resource to get started
19:36:15 <parcs> zomg: :P
19:36:23 <parcs> those crazy japanese
19:36:48 <zomg> hehe
19:39:38 <dalaing> AIFunctional: do you have a project in mind?  even something small that'll give you an excuse to play around with bits and pieces of Haskell as you learn them?
19:41:53 <AIFunctional> Yeah, it's currently an AI class, and I have homework I am trying to do as an introduction to the language
19:45:13 <AIFunctional> Is it more that I cannot declare a type in the Try Haskell evaluator on the tryhaskell.org website?
19:45:29 <AIFunctional> addThree :: Int -> Int -> Int -> Int
19:45:36 <lpsmith> I don't think you can define your own type in tryhaskell.org, but I haven't used it much
19:45:40 <shachaf> AIFunctional: Indeed; you can only evluate expressions.
19:45:42 <monochrom> tryhaskell.org doesn't let you declare things.
19:45:49 <lpsmith> It looks like it's just the ghci prompt
19:45:58 <shachaf> lpsmith: Not even that.
19:46:14 <lpsmith> so yeah, you have to graduate beyond tryhaskell pretty quickly
19:46:20 <shachaf> It's closer to lambdabot's "> ".
19:46:30 <shachaf> Get yourself a real Haskell implementation.
19:46:36 <shachaf> Like a piece of paper and the Report.
19:46:40 <lpsmith> lol
19:46:49 <dalaing> AIFunctional: you might have more luck if you write a file ie filename.hs
19:47:23 <dalaing> AIFunctional: then you can run ghci and do :load filename.hs in order to play around with it
19:47:30 <dalaing> at least as a first step
19:47:51 <lpsmith> I'm a big fan of computing by pencil and paper.  If I'm really trying to understand an algorithm,  I often resort to that
19:48:26 <lpsmith> executing some of the finer points of haskell by pencil and paper get kind of burdensome.  I haven't found a particularly good way to do it.
19:49:29 <Jafet> @where stepeval
19:49:30 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
19:54:09 <zomg> lpsmith: I can never understand you pen people. I avoid pen and paper as much as I can =)
19:54:35 <monochrom> tryhaskell.org does not let you declare things, but the server behind it can, just not exposed by tryhaskell.org. you can use my http://www.vex.net/~trebla/haskell/testbed.cgi it just calls the same server. enter declarations in the big box
19:54:40 <zomg> The only thing I like them for is pencil spinning tricks :D
19:54:55 <lpsmith> zomg:  pen is not acceptable.  I insist on pencil
19:54:58 <lpsmith> :)
19:55:00 <zomg> heh
19:55:51 <lpsmith> I find the disipline that pencil and paper is helpful
19:56:11 <lpsmith> and it's fun to say that you can compute things by hand that most people can't
19:57:23 <vrthra> Hi, (I had asked before but the channel was queit then) I am trying to make a monad transformer for a simple tree data structure based on the list monad transformer implementation. My current implementation is pasted below. I am stuck at the point where I apply the runTree on the child nodes. Have been stuck at this for hours, and any help is appreciated.
19:57:29 <hpaste> vrthra pasted â€œTree monad transformerâ€ at http://hpaste.org/50997
19:58:11 <hpaste> vrthra annotated â€œTree monad transformerâ€ with â€œTree monad transformer (annotation)â€ at http://hpaste.org/50997#a50998
20:02:20 <vrthra> at the last point, I have an error for ts_ which says [Tree b] expected , actual [m (Tree b)]
20:02:44 <vrthra> but using sequence returns an error, expected type [m a] actual [Tree a]
20:10:59 <vrthra> any pointers at all? :(  [ http://hpaste.org/50997#a50998 ]
20:18:56 <monochrom> @pl \f -> fold (f 1) f
20:18:56 <lambdabot> fold =<< ($ 1)
20:19:07 * monochrom snickers!
20:19:33 * Jafet Kit-Kat
20:25:54 <dalaing> ah my brain
20:27:10 <parcs> :t ?fold =<< ($ ?l)
20:27:11 <lambdabot> forall b a b1. (?fold::b1 -> (a -> b1) -> b, ?l::a) => (a -> b1) -> b
20:27:53 <parcs> :t flip ?fold <*> ($ ?l)
20:27:54 <lambdabot> forall b a b1. (?fold::b1 -> (a -> b1) -> b, ?l::a) => (a -> b1) -> b
20:36:02 <dalaing> hmm - my brain seems to have recovered, which means that I'm probably missing something...
20:48:45 <Jafet> vrthra: what a mess. Try writing join first
20:49:13 <vrthra> :(,
20:50:03 <vrthra> thanks still, I assumed no one was looking at it.
20:50:08 <Jafet> :t join
20:50:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:50:33 <vrthra> had been staring at it for more than a day now
20:51:18 <Jafet> I'm not even sure if there is a unique sensible definition for TreeT
20:52:35 <Jafet> Oh wait, you can't write join without first writing >>=.
20:53:56 <ion> fooJoin = â€¦; instance Monad Foo where { m >>= f = fooJoin (f <$> m)
20:54:11 <ion> -- workaround for the Monad class lacking join
20:54:34 <ion> instance Monad Foo where
20:54:43 <ion>   m >>= f = join' (f <$> m)
20:54:47 <ion>     where join' = â€¦
20:55:00 <Jafet> I mean, I can't see how to write join without using >>= at the outermost level
21:04:50 * hackagebot xml-enumerator 0.4.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.4.1 (MichaelSnoyman)
21:06:46 <eyu100> is there a runnable version of the js stg machine on the web?
21:07:21 <Jafet> There's an STG machine in javascript?
21:07:37 <eyu100> I tried using the code on the wiki but an innocent-seeming thunk was nonterminating and I couldn't figure out why
21:07:41 <eyu100> http://www.haskell.org/haskellwiki/STG_in_Javascript#Aug_25.2C_2007
21:32:41 <Jafet> vrthra: ts_ <- forM b_ts $ \b_t -> runTreeT (TreeT (return b_t) >>= f)
21:33:33 <hpaste> vrthra pasted â€œnewâ€ at http://hpaste.org/50999
21:33:38 <vrthra> this is my current status
21:34:13 <zomg> I keep reading your nick as urethra
21:34:14 <vrthra> Jafet: I will check yours too, I am not sure if I got it right
21:34:15 <zomg> >_>
21:34:21 <vrthra> 8)
21:34:44 <Jafet> There may be more than one right way.
21:35:29 <vrthra> true,
21:37:10 <vrthra> Jafet: thanks a lot for spending so much time :), and helping me
21:37:15 <vrthra> really appreciate it.
21:37:41 <Jafet> I now remember why I dislike monad transformers
21:38:01 <vrthra> hmm, I think I will think twice before the next one :)
21:38:55 <vrthra> now off to bed :), bye
21:57:16 <copumpkin> does "this sentence is false" when translated to intuitionist logic, correspond to a hyperfunction?
21:57:53 <yitz> copumpkin: that sounds like zen
21:57:53 <ghartshaw> @pl (\u v -> foldl (+) 0 (zipWith (*) u v))
21:57:54 <lambdabot> (foldl (+) 0 .) . zipWith (*)
22:02:34 <ghartshaw> @unpl dot
22:02:35 <lambdabot> dot
22:02:41 <ghartshaw> @unpl ((.).(.))
22:02:42 <lambdabot> (\ i b c f -> i (b c f))
22:03:01 <ghartshaw> @unpl ((.).(.)) (foldl (+) 0) (zipWith (*))
22:03:01 <lambdabot> (\ c f -> foldl (+) 0 (zipWith (*) c f))
22:03:45 <ion> > fix (== False)
22:03:48 <lambdabot>   mueval-core: Time limit exceeded
22:05:31 <ghartshaw> @unpl flip . (. flip id)
22:05:32 <lambdabot> (\ k b c -> k (\ f -> f c) b)
22:10:41 <akosch> I'm writing a genetic algorithm and wondering if I should use lists to encode my chromosomes: obviously I want to slice them up and glue them together a _lot_...
22:11:06 <mwc> akosch: lists are better suited to data that can be processed in serial.
22:11:09 <shachaf> akosch: If you're going to want indexing, lists probably won't be very good.
22:11:28 <mwc> you might be better off with a zipper if you need to split things apart and put them back together after inserting or deleting pieces
22:12:05 <Jafet> Data.Sequence
22:12:22 <akosch> I was thinking of some mutable type, would fit the mutation stage pretty well
22:12:24 <Jafet> Zippers are neat, but it's not always easy to make them work.
22:12:45 <Jafet> What does mutability have to do with it?
22:13:34 <akosch> Jafet: well I want to alter only tiny pieces of them, but a lot of times
22:14:49 <Jafet> If the modifications are very localized, then a zipper is appropriate.
22:15:05 <akosch> Jafet: I don't really know if that could be done efficiently using immutable types
22:15:36 <akosch> Jafet: ok, I'll check on zipper: never heard of it before... thanks!
22:17:08 <Jafet> What does mutability have to do with efficiency here
22:17:35 <kmc> Jafet, it's not well-known that there are datastructures which can be non-destructively updated without a full copy
22:17:37 <ddarius> Jafet: Mutable = fast just like eager = fast.
22:17:46 <Jafet> Lists, zippers and Sequences all let you modify certain parts efficiently
22:17:48 <kmc> akosch, a tree is an example of such a datastructure
22:17:50 <ddarius> Didn't you know?
22:18:22 <dalaing> akosch: http://learnyouahaskell.com/zippers, although someone else might have a better starting point
22:18:24 <kmc> if you represent your chromosome with a Map or IntMap, then it's easy to update at specific points without copying the whole thing, and without in-place mutation
22:18:44 <Jafet> ddarius: will those make my computer faster? It already has racing stripes.
22:18:46 <kmc> Sequence is another good suggestion
22:19:54 <akosch> thanks for all the suggestions: now I have a few hours of reading material ;)
22:20:05 <kmc> it's true that in-place update has the potential to be much faster, because it provides much narrower guarantees
22:20:49 <kmc> but you really want the broader guarantees when you move to parallel processing
22:21:05 <liyang> On the topic of Zippers: http://okmij.org/ftp/continuations/zipper.html#traversable
22:25:16 <copumpkin> liyang: did you see his proofs of false?
22:30:25 <dolio> He just ported it.
22:30:34 <liyang> copumpkin: where?
22:30:54 <copumpkin> http://okmij.org/ftp/Haskell/impredicativity-bites.html that one
22:31:23 <copumpkin> proving false in haskell obviously isn't surprising, but it's not one of the usual ways :P
22:34:14 <ghartshaw> @pl \f x -> x
22:34:15 <lambdabot> const id
22:34:42 <ghartshaw> \c -> c (+1) 0
22:35:25 <ghartshaw> @pl
22:35:26 <lambdabot> (line 1, column 1):
22:35:26 <lambdabot> unexpected end of input
22:35:27 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
22:35:34 <ghartshaw> @pl \c -> c (+1) 0
22:35:35 <lambdabot> flip ($ (1 +)) 0
22:36:17 <dolio> It was written in Coq first.
22:36:24 <dolio> And an alternate version in Agda.
22:36:56 <copumpkin> ah
22:39:25 <dolio> Of course, Haskell is the only one with all the pieces built in.
22:50:56 <akosch> this is an "interesting" way of presenting zippers: http://en.wikibooks.org/wiki/Haskell/Zippers
22:55:09 <zomg> Theseus eh
22:55:26 <zomg> I saw some Prolog tutorial which had lots of Pulp Fiction references in it
22:58:24 <akosch> zomg: do you have a link?
23:03:42 <xrl> I'm staring to use records but since the properties have generic names ("queue", "se", etc) I'm having some collisions
23:04:05 <xrl> can I filter those out when I do the module export call?
23:04:33 <Jafet> Collisions with what?
23:04:45 <xrl> when you define a record it defines functions for each property
23:04:53 <xrl> so now there's a queue function
23:05:03 <xrl> which is handy, but it's stepping on other piece's toes
23:05:03 <ehamberg> there is a discussion about this problem here: http://www.reddit.com/r/haskell/comments/k4lc4/yesod_the_limitations_of_haskell/
23:06:11 <Jafet> Okay, give them different names. Or import those names qualified.
23:06:24 <Jafet> Or use ghc's record field scoping extension.
23:06:48 <xrl> my file, Factor.hs, defines one immediately useful function and two data types... could I just do qualified imports whenever I import Factor?
23:07:42 <zomg> akosch: http://cs.union.edu/~striegnk/learn-prolog-now/html/index.html
23:14:17 <xrl> definitely frustrating
23:14:40 <xrl> seems like generating all the accessors should have finer grain controls
23:17:36 <Jafet> Or use import ... hiding.
23:25:08 <xrl> Jafet: oh, hiding, good idea
23:32:06 <b_jonas> brisingr: you could derive Enumerable, then something like show x | Deuce <= x && x <= Ten = show (1 + fromEnum x)
23:32:28 <b_jonas> no wait, I should let you ask the question first
23:34:20 <brisingr> oh right
23:34:35 <brisingr> I want to show the ranks in a card game, how do I do that?
23:34:48 <brisingr> your idea is excellent b_jonas, thanks
23:35:05 <brisingr> another thing, which is bugging me
23:35:37 <brisingr> say I have a data Blah = Stuff | OtherStuff | MoreMoreStuff blah blah
23:35:41 <brisingr> say a lot of them
23:36:05 <brisingr> and the Show instance of each to be only the first letter i.e. show OtherStuff = "o"
23:36:43 <brisingr> these questions are trivial but I can't find them on google
23:37:27 <Jafet> You haven't yet asked ay question
23:37:34 <brisingr> how do I do that?
23:38:37 <brisingr> I mean I could hack something but this is haskell, I wouldn't want to do that
23:38:58 <Jafet> Write a preprocessor, or use Template Haskell
23:39:10 <Jafet> Or hire a chinese teenager to do it for you
23:39:34 <cheater> or Galois
23:43:03 <Jafet> If you have that many constructors, though, you're going to have problems beyond having to write Show instances
23:43:04 <ddarius> > gshow (Just 3)
23:43:06 <lambdabot>   "(Just (3))"
23:43:24 <shachaf> @index gshow
23:43:25 <lambdabot> Data.Generics.Text, Data.Generics
23:43:27 <ddarius> You can write a generic show function and then just do instance Show Blah where show = myGenericShow
23:44:13 <ddarius> @hoogle Constr -> String
23:44:14 <lambdabot> Data.Data showConstr :: Constr -> String
23:44:14 <lambdabot> Data.Data constrFields :: Constr -> [String]
23:44:14 <lambdabot> Prelude show :: Show a => a -> String
23:44:17 <shachaf> import statements in ghci don't support semicolons. :-(
23:44:31 <ddarius> @hoogle Constr -> Name
23:44:32 <lambdabot> Data.Data fromConstr :: Data a => Constr -> a
23:44:33 <lambdabot> Data.Data fromConstrB :: Data a => d -> Constr -> a
23:44:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:44:38 * shachaf should write a ghci macro that supports the best features of import and :m.
23:45:15 <brisingr> oh oh, thanks
23:50:50 <MHD> I'm installing the llvm bindings on a fedora box. What directories should I hand the ./configure for --with-llvm-prefix and --with-llvm-bindir?
23:52:24 <hpaste> Plop pasted â€œPlop is hereâ€ at http://hpaste.org/51000
23:55:38 <brisingr> yes plop it's more than this, hpaste will in fact also spam #haskell with your ransom paste
23:55:44 <brisingr> *random
