00:01:19 <kmc> Rotsor, I think you're looking for the 'lift' function
00:01:40 <kmc> or you can use variables from outside a splice inside a splice, in which case they get lifted automatically
00:01:50 <kmc> er s/splice/quote/
00:03:25 <kmc> «let x = 3 in [| x |]»  ⇒  «LitE (IntegerL 3)»
00:03:26 <Rotsor> Oh, lift it is!
00:03:52 <Rotsor> It can't lift functions though :-\
00:03:56 <elliott_> oh, there's an easier way than litE (integerL x)?
00:04:02 <elliott_> neat :P
00:04:07 <elliott_> Rotsor: neither can read/show
00:04:23 <elliott_> can't really persist closures like that
00:04:30 <kmc> «let x = 3 in [| show x |]»  ⇒  AppE (VarE GHC.Show.show) (LitE (IntegerL 3))
00:04:33 <Rotsor> Indeed. That's unfortunate.
00:04:37 <kmc> so you can see that treatment of names in quotes is complex
00:04:42 <kmc> here "show" was quoted but "x" was lifted
00:05:02 <kmc> i don't remember all the rules but they're in the paper
00:06:01 <elliott_> lift is a rather annoying nameclash
00:06:32 <kmc> «x = 3; y = [| x |]» gives different results from «y = let x = 3 in [| x |]»
00:08:52 <kmc> > [| 3 |]
00:08:53 <lambdabot>   <no location info>: parse error on input `|'
00:08:56 <kmc> :(
00:09:09 <kmc> lunabot had TH
00:11:44 <mm_freak_> dalaing: i thought more like some higher level library above opengl
00:11:57 <mm_freak_> because simple test graphics hurt with opengl
00:23:09 <kmc> still no pattern splices though :(
00:23:12 <kmc> unless i missed the memo
00:23:53 <kmc> i still think something like Liskell is probably the way to go for metaprogramming in Haskell
00:25:04 <kmc> you treat Haskell as syntactic sugar for a more regular abstract syntax
00:25:19 <kmc> without all the different syntactic classes for expressions, patterns, decls, etc
00:25:22 <kmc> and you metaprogram in that
00:26:22 <kmc> metaprograms lose the sugar but it's not clear this is a usability loss
00:27:19 <kmc> however, it would seriously interfere with the plans to make quoted expressions statically carry the type of the expression if spliced
00:28:09 <kmc> i don't think that's a compelling feature
00:28:17 <kmc> but some people really want it
00:28:31 <flux> hm, wouldn't stripping sugar early affect cases when you want to extend the sugar?
00:28:44 <flux> would list comprehensions be sugar?
00:30:41 <Eduard_Munteanu> flux: it is
00:30:49 <kmc> extend the sugar how?
00:30:58 <kmc> TH already can't change concrete syntax
00:32:40 <kmc> hmm
00:32:51 <kmc> list comprehensions are already sugar for concatMap, filter, and such
00:33:07 <kmc> but probably you want to manipulate a quoted list comprehension as a list comprehension
00:33:45 <flux> in OCaml type-directeed syntax extensions are sometimes missed, but I guess type classes would make up for that in Haskell
00:34:16 <kmc> so i'd say [ f x | x <- z ]  should be something like (do (<- x z) (return (f x)))
00:34:30 <kmc> or you don't have to forget the fact that it's a list comprehension and not a "do"
00:35:40 <kmc> but at this level it makes sense for them to be very close syntactically
00:36:04 <kmc> (i don't know what Liskell and Lisk actually do)
00:36:46 <kmc> i also wouldn't mind a Lisp that had a more concrete sugary syntax like Haskell's, but that's a different beast entirely
00:37:31 <Kaidelong> wouldn't that be simple to implement?
00:37:42 <kmc> relatively
00:37:46 <kmc> though there are a lot of decisions to be made
00:37:52 <kmc> how do you represent algebraic data in Lisp?
00:38:21 <kmc> i'm sure someone has a package for pattern-matching in Lisp -- in fact, I'm sure 10 people have each written 80% of one, declared "works for me", and set it aside
00:38:30 <kmc> and that they are not compatible
00:38:47 <kmc> maybe it's in CLOS somewhere
00:38:49 <kmc> i really don't know
00:43:59 <quicksilver> kmc: (':just x) vs (':nothing) or a similar scheme
00:44:10 * applicative was reading 'A View from the Left' which attributes an implementation of pattern matching to the father of Conor McB, in the early 70s if I understood
00:44:24 * applicative means, in Lisp
00:44:34 <quicksilver> but I think when you start playing those games you rapidly wish you had some form of type checking and/or inference, I think.
00:45:03 <kmc> yeah, it is very easy to invent a system for algebraic data and pattern matching in lisp
00:45:10 <kmc> and i expect it is very hard to find the best one
00:45:18 <kmc> that's what i mean by "a lot of decisions to be made"
00:45:25 * quicksilver nods
00:45:35 <Eduard_Munteanu> Why not get some rebindable syntax in Haskell then?
00:45:36 <kmc> for example, this means Haskell lists aren't Lisp lists
00:45:47 <kmc> Eduard_Munteanu, relevance being?
00:46:04 <Eduard_Munteanu> Metaprogramming?
00:46:05 <quicksilver> kmc: unless you special case them, yes.
00:46:17 <osfameron> I thought haskell lists *were* pretty much the same as Lisp lists?
00:46:33 <osfameron> oh wait, you can cons something with a not-list
00:46:36 <kmc> osfameron, have you been following the context of the discussion?
00:46:37 <kmc> that too
00:46:54 <quicksilver> osfameron: not under the encoding I just suggested
00:47:19 <kmc> osfameron, we're talking about a Haskell-like syntax for Lisp
00:47:37 <Eduard_Munteanu> It seems to be that getting a Haskell-ish Lisp isn't really the nicest idea.
00:47:52 <osfameron> yeah - I saw the general context, but amn't really following, sorry...
00:47:56 <kmc> and how you would encode algebraic data types in Lisp
00:48:26 <quicksilver> Eduard_Munteanu: well, I think I agree; on the other hand, when you program in lisp you occasionally *do* need a trick like this
00:48:28 <kmc> and one obvious choice is to encode each algebraic value as a list with the constructor (as a symbol) in the first position, and the fields if any in the rest
00:48:42 <quicksilver> and if you had a uniform trick, there might be libraries to deal with it uniformly
00:48:43 <kmc> as quicksilver said, (':just 3) and (':nothing) and such
00:48:56 <quicksilver> instead, each programmer comes up with his own
00:48:59 <quicksilver> maybe that's the lisp way :)
00:49:41 <kmc> osfameron, but this means the Haskell list [2,3] would be the Lisp value (':haskell_cons 2 (':haskell_cons 3 (':haskell_nil))) and not directly (2 3)
00:49:51 <kmc> quicksilver, exactly
00:50:00 <andras> Hi guys.  I'd like to generate a list of Strings from a String, which is the list of "tokens" the initial String contained, delimited by a separator.  For whitespace, this is simple (words), but is there a simple way of doing it with a user-supplied separator condition?
00:50:11 <kmc> andras, look at the 'split' package
00:50:34 <osfameron> kmc: isn't the haskell list really HaskellCons 2 (HaskellCons 3 (HaskellNil))) too ?
00:50:34 <quicksilver> @hackage split
00:50:34 <lambdabot> http://hackage.haskell.org/package/split
00:50:53 <osfameron> well, being 2:3:[]
00:51:00 <quicksilver> osfameron: Yes. But the point is that you don't end up encoding haskell lists as lisp lists.
00:51:11 <quicksilver> which is a shame at least aesthetically
00:51:20 <osfameron> oh I see
00:51:23 <kmc> it's a shame for interoperability
00:51:25 <ddarius> Lisp lists are a shame aesthetically.
00:51:27 <osfameron> though, it being Lisp, you'd just write a macro
00:51:37 <quicksilver> lisp is a shame aesthetically
00:51:39 <andras> kmc, quicksilver: ah, great, thanks
00:51:59 <quicksilver> OOPS I ACCIDENTALLY THE WHOLE AESTHETIC
00:52:33 <kmc> the fundamental difference is that in Haskell, lists are just one example of algebraic data, and in Lisp algebraic data is just one example of lists
00:53:22 <quicksilver> (lists are just one convention on how to use dotted pairs)
00:53:27 <kmc> that too :)
00:53:34 <ddarius> Using lists to encode algebraic data types is a bad idea.
00:53:43 * hackagebot maude 0.2.0 - An interface to the Maude rewriting system.  http://hackage.haskell.org/package/maude-0.2.0 (DavidLazar)
00:54:06 <quicksilver> ddarius: why? and how would you do it?
00:54:47 <kmc> are there any dynamically-typed languages with algebraic data and pattern-matching as a standard feature?
00:55:07 <quicksilver> one of these trendy new kids on the block like scala or groovy or something?
00:55:14 <kmc> scala's statically typed
00:55:26 <kmc> groovy i don't know
00:56:18 <kmc> "Groovy is like a super version of Java. It can leverage Java's enterprise capabilities but also has cool productivity features like closures, builders and dynamic typing."
00:56:22 <ddarius> quicksilver: It's rather inefficient even with a "light" encoding.  The "light" encodings tend to be broken in an unbelievable number of ways.  The heavy encodings may not be broken but are fragile.  I would use the various structure/object support provided, and indeed this is what typical "algebraic data type" macros in Lisps do.
00:56:39 <ddarius> Groovy is like the worst of all worlds.
00:56:50 <kmc> ddarius, it doesn't just use, it leverages
00:56:53 <kmc> don't you see
00:56:58 <kmc> Haskell doesn't leverage anything, we just use
00:57:17 <kmc> that's why Haskell will never be popular on The Enterprise
00:57:26 <kmc> i.e. NCC-1701
00:57:44 <quicksilver> loquacious llames leverage lambdas lovingly
00:57:51 <quicksilver> s/llames/llamas/
00:59:26 <kmc> i guess http://groovy.codehaus.org/Builders is sort of like algebraic data
01:00:58 <zeiris> I'm trying to understand how to do pathing on a simple functional BSP tree, and my brain is starting to leak out of my ears. Does anyone have recommended reading/Haskell code on the topic?
01:01:23 <zeiris> The one time I implemented A* in Haskell, it looked very imperative... I'd like to know if there's a functional way of doing it.
01:01:24 <kmc> what's pathing?
01:01:50 <zeiris> Finding a path from A to B in a 3D grid of walls and empty space.
01:01:52 <kmc> zeiris, have you seen http://www.haskell.org/haskellwiki/Zipper
01:02:23 <zeiris> I've seen the idea come up repeatedly.
01:02:40 <ddarius> @hackage astar
01:02:40 <lambdabot> http://hackage.haskell.org/package/astar
01:03:19 <ddarius> There was a paper a while back about how pretty much any implementation of map, I believe, was broken due to improper lists.
01:04:02 <Kaidelong> what's an improper list?
01:06:57 <kmc> Kaidelong, in Lisp, a cons cell where following cdrs hits something that isn't nil or a cons cell
01:07:17 <kmc> like (cons 2 3) aka '(2 . 3)
01:25:21 <cicatristeza> hello, i would like to start learning haskell. i use emacs on arch. what do you suggest?
01:25:47 <ddarius> cicatristeza: I suggests reading one of the various introductions to Haskell freely available.
01:26:30 <Eduard_Munteanu> @where lyah
01:26:31 <lambdabot> http://www.learnyouahaskell.com/
01:26:34 <rostayob> cicatristeza: I suggest lyah
01:26:38 <Eduard_Munteanu> That's usually suggested.
01:29:22 <Kaidelong> kmc: So for example 1:undefined ?
01:31:30 <elliott_> What's it mean if you get an undefined symbol error for an FFI library when some Template Haskell code runs, but everything links fine normally in a non-TH program?
01:31:37 <elliott_> No dynamic libraries were built, or?
01:35:05 <cicatristeza> how did you folks learn
01:36:32 <rostayob> cicatristeza: personally reading code and haddock, and typeclassopedia
01:36:35 <rostayob> and papers
01:36:50 <rostayob> and some chapters of RWH :P
01:37:09 <rostayob> but the best resource for beginners is probably LYAH
01:39:28 <cicatristeza> whats haddock
01:40:01 <rostayob> cicatristeza: haddock is the software used to generate API documentation for haskell. for example, this is the haddock documentation for the current base library: http://hackage.haskell.org/package/base
01:40:57 <elliott_> cicatristeza: http://learnyouahaskell.com/ is LYAH
01:41:01 <elliott_> if you haven't seen it
01:42:02 <freeasjesus> helloeveryone:)
01:42:06 <cicatristeza> what sorts of things do you folks make with it
01:42:13 <elliott_> programs
01:42:21 <rostayob> cicatristeza: with haskell? all sorts of thing eheh
01:42:24 <kmc> Kaidelong, there aren't any improper lists in Haskell
01:42:38 <cicatristeza> e.g.? i have seen ClaudiusMaximus' toys for example
01:43:03 <elliott_> data ListOfQuestionablePropriety a b = Proper | Improper b | Cons a (ListOfQuestionablePropriety a b)
01:43:05 <elliott_> the most useful list type
01:43:09 <rostayob> cicatristeza: Xmonad, darcs, yesod, whatever
01:43:18 <kmc> cicatristeza, i recently made http://hackage.haskell.org/package/dewdrop
01:43:23 <rostayob> there is a lot of useful software written in haskell floating around
01:43:43 <kmc> there are not many public 'end user' apps in Haskell
01:44:10 <kmc> it's used for internal tools at banks, Facebook, Google, NASA, NSA, various startups, ...
01:44:21 <rostayob> kmc: Google?
01:44:35 <kmc> yeps
01:44:37 <kmc> http://k1024.org/~iusty/papers/icfp10-haskell-reagent.pdf
01:44:41 <kmc> that describes one project
01:44:47 <kmc> i'm told there have been others
01:45:05 <tr|ck> kmc: very cool indeed... (talking about dewdrop)
01:45:16 <kmc> facebook uses it to automate PHP refactoring... https://github.com/facebook/lex-pass
01:45:18 <kmc> tr|ck, thanks
01:45:18 <cicatristeza> ClaudiusMaximus: are you here? i saw you live once, twas kul
01:45:20 <rostayob> kmc: oh right, I'm working at google now and I didn't know ehe
01:45:25 <kmc> haha
01:45:28 <kmc> it's a big place, i hear
01:45:31 <rostayob> yes
01:45:35 <kmc> and pretty decentralized compared to other companies that size
01:45:38 <kmc> but i've not worked there
01:45:46 <rostayob> kmc: I'm just an intern anyway :P
01:45:49 <kmc> yeah
01:45:58 <kmc> seems half the people i know were Google interns at some point
01:46:06 <rostayob> kmc: yeah there's a lot of us
01:46:34 <tr|ck> kmc: I use to program in LISP, I stopped about 15 years ago. Last week I came across haskell and since then I can't stopping studing it. :) hopefully by the end of the month I'll be a little productive.
01:46:41 <tr|ck> s/use/used/
01:46:50 <kmc> haha, cool
01:47:04 <rostayob> kmc: I'm trying to get an haskell internship next year :P
01:47:54 <elliott_> Is there a way to specify linker options to be used when running Template Haskell code?
01:48:01 <kmc> rostayob, where?
01:48:28 <rostayob> kmc: tsuru capital
01:48:46 <rostayob> (the only one i could find)
01:48:52 <kmc> ah cool!
01:49:57 <rostayob> they have a nice exercise on their website, they seem to have liked my code, but these small companies are a lot harder to get into!
01:50:15 <kmc> yeah
01:50:22 <kmc> i really like small companies
01:50:35 <rostayob> I don't know yet, we'll see eheh
01:50:57 <kmc> ah, the code sample thing is new
01:51:05 <kmc> (ish)
01:51:14 <rostayob> it's a simple parser, the main thing is to make it fast
01:51:33 <rostayob> it's parsing a pcap capture
01:52:18 <quicksilver> kmc: that was an interesting icfp experience report, thanks for the link
01:52:19 <cheater> rostayob: half the team in #snapframework is working for google.
01:52:34 <cheater> where are you located rostayob?
01:52:36 <kmc> rostayob, i've worked in high-frequency finance... not my favorite industry, but it could be good given the right circumstances
01:52:47 <rostayob> cheater: well definitely gregory collins is working for google, I didn't know there were others
01:52:49 <kmc> i think it's interesting tsuru puts salaries on the job listing page
01:52:51 <rostayob> cheater: I'm in london
01:52:54 <kmc> that's v. unusual
01:53:01 <cheater> i didn't know there was google in london
01:53:13 <rostayob> cheater: it's like the 2nd or 3rd biggest office
01:53:14 <cheater> last time someone from google tried to recruit me while i was in london it was ireland
01:53:18 <cheater> weird
01:53:36 <rostayob> but it's 1/3 engineering, the rest is sales/marketing etc
01:53:58 <rostayob> kmc: well I don't really know what I'm doing, but I know I love haskell eheh
01:54:28 <quicksilver> I'm fairly sure google's london office is not their 2nd or 3rd biggest
01:54:40 <quicksilver> as cheater says, they didn't used to have any techies there at all
01:54:46 <quicksilver> they do now, though.
01:54:48 <rostayob> quicksilver: it's growing fast
01:55:17 <rostayob> it's definitely one of the biggest
01:55:22 <kmc> rostayob, so do i, but i've also quite enjoyed jobs where i don't write much haskell
01:55:49 <kmc> the last place i worked, most of the company knew haskell even though we didn't use it for anything
01:56:33 <rostayob> quicksilver: ah no, you're right, it's not the third, but it's still pretty high up
01:57:08 <kmc> at least three of them (besides me) have uploaded to hackage
01:57:18 <cheater> quicksilver: google's recruitment team can build up a huge office overnight
01:57:26 <cicatristeza> what is hatex useful for exactly?
01:57:27 <quicksilver> that's true, cheater
01:57:31 <cheater> i think it mostly happened because of the exodus at yahoo london
01:57:55 <kmc> cicatristeza, for writing out LaTeX files, I think
01:57:59 <kmc> though i might use pandoc for that instead
01:58:17 <quicksilver> cicatristeza: for producing very structured or formulaic documents like invoices and so on, it would be handy
01:58:36 <quicksilver> (especially if you already know how to write a LaTeX setup for your invoice style0
01:58:41 <kmc> maybe you have a Haskell program which generates some document, and you want a beautiful looking pdf without having to screw around with fonts and layout for n+1 hours
01:58:46 <rostayob> kmc: yeah I guess. do you have any internship suggestions?
01:59:05 <cicatristeza> i see, this could be super useful
01:59:06 <kmc> LaTeX produces wonderful beautiful output from bizarre ugly input
01:59:33 <cicatristeza> default latex typography **looks** so tasty i get hungry
01:59:48 <kmc> so you gain a lot by having a high-level library which hides some of the ugliness of TeX concrete syntax
02:00:01 <kmc> see also pandoc and its ability to generate LaTeX from markdown
02:00:05 <kmc> rostayob, hmm, suggestions of what sort?
02:00:43 <osfameron> not-having-to-write-latex ftw
02:00:46 <rostayob> kmc: of where to apply, next year I have to do a 6 months internship anyway
02:00:49 <osfameron> not having to debug it would be even nicer
02:00:55 <kmc> rostayob, have to?
02:01:06 <kmc> "Error: Something's wrong"
02:01:11 <rostayob> kmc: yes as part of my course
02:01:16 <kmc> interesting
02:01:20 <kmc> i don't have much advice
02:01:23 <cicatristeza> org-mode has a nice abtsraction too, but of a  different sort to haskell obviously
02:01:38 <kmc> pandoc can output org-mode
02:02:23 <rostayob> kmc: my goal would be mainly to work with a small company, but as I said it's harder to get. let's see how tsuru goes anyway
02:02:38 <kmc> the last small company i worked for got bought by Oracle
02:02:44 <kmc> i don't know what it's like to work there anymore
02:03:01 <kmc> before that i worked in high-frequency finance, i can tell you a bit what i think about that field
02:03:59 <cicatristeza> kmc: what?
02:04:14 <ddarius> A small company is harder to get into but there are much more of them.
02:04:30 <rostayob> kmc: yeah also because you hear a lot of strange stories around HFT
02:04:35 <kmc> cicatristeza, what which?
02:04:50 <kmc> rostayob, i will elaborate in #haskell-blah?
02:04:56 <rostayob> kmc: cool, see you there
02:13:43 * hackagebot lushtags 0.0.1 - Create ctags compatible tags files for Haskell programs  http://hackage.haskell.org/package/lushtags-0.0.1 (BitConnor)
02:18:43 * hackagebot HTF 0.8.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.8.0.0 (StefanWehr)
02:56:49 <erus`> can map be proven not to terminate ?
02:57:02 <erus`> i mean to terminate
02:57:18 <erus`> assuming the function being applied terminates
02:57:40 <jacobian> It's co-terminating
02:57:56 <jacobian> Assuming the input is codata and the function is total
02:58:23 <jacobian> It's terminating if the input is data and the function is total
03:00:14 <erus`> how do people check if a function terminates. (it must be some approximation?)
03:00:18 <hpaste_> cwl pasted “yesod error” at http://hpaste.org/51562
03:00:34 <jacobian> You can prove a function is terminating using various methods
03:00:46 <cwl> very strange error
03:00:53 <cwl>     Multiple declarations of `Handler'
03:00:54 <jacobian> Usually you show that some well founded relation holds on the parameters of the recursive function
03:01:19 <jacobian> Structural recursion is a nice way to get a well fonded relation for free
03:02:06 <kmc> erus`, in a language like Agda or Coq, you prove termination simply by making sure every recursive call is at a strictly smaller argument
03:02:09 <kmc> (structurally smaller)
03:02:50 <kmc> doesn't work in Haskell because the data is actually codata; you can have infinite lists
03:03:00 <kmc> i can make a list which is infinite iff the Riemann zeta hypothesis is true
03:03:24 <Jaxan> do'n go there
03:03:28 <cwl> kmc: could you look at my code http://hpaste.org/51562
03:03:29 <erus`> is it true?
03:03:35 <kmc> is what true
03:03:36 <jacobian> haha
03:03:37 <cwl> there is a strange error
03:03:44 <jacobian> The Riemann zeta hypothesis :)
03:03:57 <kmc> cwl, i don't know
03:04:03 <erus`> yesn or no
03:04:17 <kmc> erus`, if you can answer that question you'll win at least US$1,000,000
03:04:20 <jacobian> I put 15 eur says yes
03:04:25 <kmc> haha
03:04:51 <Veinor> i'm willing to bet it is just on the basis of large counterexamples generally not showing up
03:05:01 <tr|ck> kmc: I think now it's worth around US$5,000,000
03:05:06 <kmc> heh
03:05:34 <kmc> Veinor, i think there are some conjectures which were disproven by large counterexamples
03:05:39 <Veinor> right
03:05:40 <erus`> will this be solved first or P != NP
03:05:53 <jacobian> Zeta probably has a better chance of being solved
03:05:58 <Veinor> skewes' number comes to mind
03:06:08 <jacobian> I expect P != NP to still be open when I die
03:06:13 <kmc> heh
03:07:14 <Jaxan> maybe they are equivalent
03:09:18 <exeter> I'm trying to read some files with haskell (hGetContents).Some of them are not text files: I get this error: "/quad_c_mini.png: hGetContents: invalid argument (invalid code page byte sequence)"
03:09:40 <kmc> exeter, it's trying to read them as Unicode text probably in your locale's default encoding
03:09:57 <kmc> exeter, if you're reading binary files you should probably use ByteString IO
03:10:05 <kmc> String is inherently a text, Unicode type
03:10:25 <kmc> Veinor, you can also think of any complex, difficult proof as a large counterexample to the inverse of the proposition
03:10:43 <kmc> Gödel-style
03:10:45 <Veinor> haha
03:11:29 <exeter> kmc: I'm reading them... just to copy them in another location really. They can be anything, from text to images, etc. Is there a "common" function/type I could use?
03:11:54 <kmc> exeter, if you're just copying, then you want to copy bytes, no?
03:12:27 <exeter> yes, I suppose so (question being: let's say I copy a text file byte by byte. No problem in that, right?)
03:12:39 <kmc> yep
03:12:40 <kmc> that's fine
03:12:57 <exeter> cool. Thanks kmc
03:13:04 <kmc> :)
03:16:40 <kmc> Veinor, the enumeration used in proving the 4 Color Theorem is maybe a more explicit example of proof-as-large-counterexample
03:17:03 <Veinor> did they ever find a proof that's not 'reduce to 1000 special cases, check said cases'?
03:17:18 <kmc> not that i'm aware of
03:17:25 <kmc> someone did formalize that proof in Coq, though
03:17:58 <kmc> meaning the trusted code is now Coq's typechecker + their implementation of R2 and such + their statement of the problem
03:18:01 <Jaxan> there was a shorter proof, but i don't know whether it was correct or not
03:18:16 <kmc> and not particularly special-purpose code
03:19:04 <kmc> here is a bizarre open problem: http://en.wikipedia.org/wiki/Hadwiger%E2%80%93Nelson_problem
03:19:20 <kmc> "The answer is unknown, but has been narrowed down to one of the numbers 4, 5, 6 or 7. The correct value may actually depend on the choice of axioms for set theory"
03:20:43 <erus`> is it hard to implement a parser for infix operators using agda's _*_ =  notation?
03:20:49 <erus`> seems like it would be
03:20:59 <Veinor> kmc: ... that's really bizarre
03:22:36 <kmc> http://en.wikipedia.org/wiki/Khinchin%27s_constant is a surprising property known to hold for almost all real numbers, but "it has not been proven for any specific real number whose full continued fraction representation is not known"
03:23:01 <kmc> erus`, it seems hard to me too.  i read a paper about it but didn't understand
03:25:35 <quicksilver> kmc: then again, almost all real numbers are uncomputable
03:26:00 <quicksilver> kmc: so there are lots of things about 'almost all' real numbers which it's hard to work with
03:26:02 <kmc> yep
03:26:08 <kmc> "real" numbers my ass
03:26:20 <kmc> nothing could be more absurd than the real numbers
03:26:33 <quicksilver> except daytime tv
03:26:56 <plat0> When I write the following, what is the semantics of the "let"?
03:26:57 <plat0> g x y = do
03:26:57 <plat0>         let a = x * 2
03:26:57 <plat0>             b = y - 3
03:26:57 <plat0>         return $ a + b
03:27:30 <kmc> if god created the integers then certainly man creating the reals is original sin
03:27:35 <quicksilver> plat0: that's the same as let a = x*2; b = y-3 in return (a+b)
03:27:45 <quicksilver> plat0: not sure if that helps you or not
03:28:00 <plat0> I guess what I'm asking is "is it syntactic sugar?"
03:28:11 <plat0> It does not appear to be a standard "let"...
03:28:13 <quicksilver> yes, it's syntactic sugar for what I wrote
03:28:13 <kmc> let-in-do is sugar for the other form of let, yes
03:28:21 <kmc> do itself is sugar
03:28:23 <int-e> @undo do let { a = x*2; b = y*3 }; return $ a + b
03:28:23 <lambdabot> let { a = x * 2; b = y * 3} in return $ a + b
03:28:30 <quicksilver> let in a do block is sugar for let {decl} in do {rest of do block}
03:29:10 <quicksilver> basically you get to miss out the 'in' and save yourset from cascading indentation
03:29:15 <plat0> OK, this was not obvious from a couple of minutes' googling "do notation".  All the references I've seen tell you how to translate to >> and >>=, but not to let in
03:29:43 <kmc> "do" is not sugar for "let"
03:29:49 <kmc> let-in-do is sugar for let-not-in-do
03:29:59 <kmc> do is sugar for (>>=) and (>>) as you noted
03:30:23 <kmc> do is also sugar for "case" and "fail" but we don't like to talk about that
03:30:27 <opqdonut> :D
03:30:34 <kmc> @undo do { Just x <- a; return x }
03:30:35 <lambdabot> a >>= \ b -> case b of { Just x -> return x; _ -> fail ""}
03:30:51 <plat0> Seems like an oversight that this is not mentioned on http://en.wikibooks.org/wiki/Haskell/do_Notation
03:31:16 <kmc> you could fix it :)
03:31:43 <plat0> I wouldn't know what to fix it too, other than to mention that readers ought to be aware that there's more to say ...
03:31:57 <Andrew7> looking to hire programmer : http://pastebin.com/80mWWUhR
03:31:58 <plat0> s/too/to/
03:31:59 <mauke> The paste 80mWWUhR has been copied to http://hpaste.org/51563
03:32:30 <kmc> Andrew7, spam is not welcome here, especially when it has nothing to do with Haskell
03:32:52 <Andrew7> it is not spam
03:33:25 <kmc> that's, just, like, your opinion, man
03:33:54 <Botje> Andrew7: there are job boards for that. #haskell is not a job board.
03:34:03 <Andrew7> ok
03:34:12 <Andrew7> where are job boards
03:34:54 <Andrew7> ?
03:35:47 <kmc> @google job boards
03:35:48 <lambdabot> http://www.monster.com/
03:35:48 <lambdabot> Title: Find Jobs. Build a Better Career. Find Your Calling. | Monster.com
03:38:57 <quicksilver> Andrew7: it is spam. Don't do it again.
03:41:06 <Andrew7> thank you
03:41:08 <Andrew7> bye
03:46:01 <parcs> is fail "" the actual call? or is it like fail "Pattern match failure ..."
03:46:10 <kmc> probably the latter
03:46:21 <kmc> don't know if the Report specifies the exact string
03:46:27 <kmc> but that's why it's there
03:46:39 <parcs> thought so
03:46:42 <parcs> lazy lambdabot
03:50:35 <hpaste_> ocharles pasted “Could not deduce (pk ~ Ref)” at http://hpaste.org/51564
03:51:07 <ocharles_> Can anyone explain why I'm getting that error? From what I understand, GHC doesn't see that Ref is an instance of PrimaryKey, even though I declared that instance
03:51:49 <rostayob> ocharles_: type families I guess
03:51:55 <rostayob> (without even reading the code)
03:52:06 <kmc> ocharles_, no, it's saying your code assumes pk = Ref but you did not write this assumption
03:52:24 <quicksilver> ocharles_: you suggest that that instance will work for any PrimaryKey type 'pk'
03:52:32 <quicksilver> but the code you wrote specifically uses 'Ref'
03:53:04 <ocharles_> Oh, hm, yes, I see
03:53:59 <quicksilver> that's a suspicious lookin instance, anyhow
03:54:03 <rostayob> wait, I tought that the ~ keyword was used with type families only, is it a more general keyword used by ghc?
03:54:13 <quicksilver> it creates an instance for "Convertible SqlValue (pk a)" for ALL pk and ALL a
03:54:20 <quicksilver> for example, it creates an instance for [Int]
03:54:26 <quicksilver> (pk = [], a = Int)
03:54:38 <ocharles_> right, that's why I constrained pk to be PrimaryKey
03:54:38 <quicksilver> and for Either String String (pk = Either String, a = String)
03:54:39 <quicksilver> etc.
03:54:43 <ocharles_> and [] is not a PrimaryKey
03:54:44 <quicksilver> ocharles_: no, you didn't.
03:54:51 <quicksilver> not really.
03:55:05 <quicksilver> you created an instance for ALL pk and ALL a - an instance which adds a constraint, though.
03:55:05 <kmc> type classes :(
03:55:07 <parcs> rostayob: the latter. you need TypeFamilies to use it in user code though
03:55:16 <rostayob> parcs: oh, ok.
03:55:22 <rostayob> and lazy pattern bindings too
03:55:36 <quicksilver> ocharles_: constraints on instance heads do no reduce the scope of the instance
03:55:43 <quicksilver> they just pile on a constraint when you unify.
03:55:53 <ocharles_> oh
03:56:18 <kmc> you know all that stuff about "Haskell type classes are a logic programming language like Prolog"?  yeah, it's a total lie.  there's no backtracking.
03:56:26 <kmc> not even a GHC extension
03:57:20 <int-e> That's why Oleg has this hierarchy of three TypeEq classes, right?
03:57:33 <hpc> you can get the type system to be turing complete, which technically makes it "like" any other language :P
03:57:37 <kmc> something like
03:58:06 <quicksilver> it's not because backtracking is hard
03:58:14 <quicksilver> it's because backtracking is incompatible with typeclasses
03:58:20 <quicksilver> doesn't make sense with open worlds
03:58:25 <quicksilver> doesnt' make sense with module composition
03:58:35 <quicksilver> if you allowed backtracking, module composition would be non-monotonic
03:58:50 <kmc> yeah
03:58:55 <kmc> separate compilation is why we can't have nice things
03:59:02 <deliium> @type map
03:59:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:59:20 <kmc> if i ever design a serious language I think i will try very hard to give it whole-program semantics, and have clever implementations which cache compilation results transparently
03:59:23 <int-e> kmc: but yeah all that means that you have more of a functional programming flavor than a logic programming one
03:59:36 <int-e> (on the type level)
03:59:43 <kmc> yeah
04:00:05 <quicksilver> kmc: separate compilation is an implementation detail, but module composition is not.
04:00:24 <quicksilver> having modules compose non-monotonically in terms of instance search would be quite undesirable
04:00:28 <kmc> int-e, it makes sense if you think of instance resolution as structural recursion on a type
04:00:48 <quicksilver> at most, I think, you could mark certain typeclasses as 'closed' and then there would be no instances coming in from outside
04:00:58 <quicksilver> but I have previously argued -- that's no longer a typeclass, in the haskell sense.
04:01:03 <quicksilver> (it might be a useful thing, but it's something else)
04:01:14 <hpc> it's a type family isn't it/
04:01:15 <hpc> ?
04:01:18 <kmc> quicksilver, can you give a concrete example of the non-monotonicity
04:01:21 <kmc> type families are also open
04:01:25 <hpc> bah
04:01:40 <kmc> hmm, does "Objects to Unify Type Classes and GADTs" propose a "closed" modifier?
04:01:47 <kmc> i don't recall
04:01:57 <quicksilver> kmc: well, suppose you have an instance for [a] in one module, and behaviour in that module is what you intend.
04:02:17 <quicksilver> kmc: if you then compose a second module with a different instance for [Bool] and that "takes priority" because it's more specific
04:02:25 <quicksilver> then you surprisingly change the semantics of the first.
04:02:39 <quicksilver> it's slightly more involved to come up with an example using typeclass constraints but the idea is the same.
04:03:00 <kmc> quicksilver, can't you compute the set of all possible instances and complain if there's more than one?
04:03:18 <kmc> (maybe only to some fixed depth, if you have no structural termination condition)
04:03:30 <quicksilver> (module A has instance for Foo a => [a], but concrete type Bar is not instance of Foo, so that instance is not used, perhaps a more generic one is used instead. Module B comes along and adds a Foo instance for Bar and suddenly instance selection changes)
04:03:48 * hackagebot spreadsheet 0.1.2 - Read and write spreadsheets from and to CSV files in a lazy way  http://hackage.haskell.org/package/spreadsheet-0.1.2 (HenningThielemann)
04:05:58 <quicksilver> kmc: it's not that more than one instance exists; it's that if you have some 'choose the best match' rule than a second module coming in can make a match which was previously discarded by backtracking suddenly become the best one after all.
04:06:22 <kmc> yeah, but the old instance is still valid too
04:06:35 <kmc> i'm proposing that you allow backtracking but still require a unique match
04:06:45 <kmc> not "pick the best"
04:07:02 <kmc> i could be wrong, but i think that's still a potentially useful extension
04:09:50 <quicksilver> It's always potentially useful to explore the design space
04:10:35 <kmc> maybe i'll come up with an example
04:10:36 <kmc> maybe not :)
04:10:56 <kmc> thanks for explaining — you clarified for me why an unrestricted backtracking approach would be problematic
04:11:09 <kmc> and now i will sleep :)
04:11:12 <kmc> 'night all
04:11:42 <rostayob> night
04:13:13 <hpc> hmm, what's the epsilon of Double on a 32-bit machine?
04:13:26 <ion> In the very last dream before waking up this morning i realized something:
04:13:29 <ion> @type Data.Traversable.sequenceA `asAppliedTo` (undefined :: a -> b -> c)
04:13:29 <lambdabot> forall a a1 b. (Data.Traversable.Traversable ((->) a1)) => (a1 -> b -> a) -> b -> a1 -> a
04:13:32 <ion> @type Prelude.flip
04:13:33 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:14:02 <quicksilver> hpc: 5.96e-08
04:14:02 <benmachine> ion: functions aren't traversable, though
04:14:04 <koala_man> a double's always ieee double precision floating point, right?
04:14:10 <quicksilver> according to wikipedia. http://en.wikipedia.org/wiki/Machine_epsilon
04:14:23 <quicksilver> oh, double on a 32 bit machine
04:14:29 <quicksilver> not 32-bit floating point.
04:14:36 <hpc> yeah
04:14:38 <ion> benmachine: Unless you define the instance. ;-)
04:14:41 <quicksilver> "32 bit machine" doesn't give you enough information to know what epsilon is :P
04:14:46 <hpc> google says one thing, but i can get way farther
04:14:48 <hpc> >
04:14:51 <hpc> er
04:14:55 <benmachine> ion: you have to throw undefineds at it, I think
04:15:03 <quicksilver> x86 machines have this freaky x87 80bit type
04:15:10 <quicksilver> most other machines use IEEE 64 bit
04:15:12 <hpc> ah right
04:15:18 <benmachine> @type traverse
04:15:19 <lambdabot> Not in scope: `traverse'
04:15:22 <benmachine> fff
04:15:50 <benmachine> (a -> f b) -> t a -> f (t b)
04:16:10 <benmachine> = (a -> f b) -> (r -> a) -> f (r -> b)
04:16:19 <benmachine> which I don't think you can implement
04:16:34 <hpc> looks like 1.0e-308
04:16:54 <quicksilver> hpc: that's the representable number closest to zero, that's not epsilon.
04:17:22 <hpc> oh
04:17:22 <benmachine> you could do it with (r -> f b) -> f (r -> b) but that doesn't exist in general
04:17:42 <hpc> oh derp
04:17:54 <Jafet> Not really 1.0 either
04:18:24 <Jafet> > last $ takeWhile ((/=0).snd) $ zip [0..] $ iterate (/2) 1
04:18:27 <lambdabot>   (1074,5.0e-324)
04:18:37 <Jafet> Okay, that's just subnormality.
04:19:03 <Jafet> quicksilver: heh, "most" other machines?
04:34:51 <applicative> If I use DeriveFunctor, how do I find what instance GHC wrote?  I remember seeing this described somewhere but cant find it
04:35:05 <rostayob> applicative: -ddump-something
04:35:15 <rostayob> can't remember what something is.
04:35:22 <applicative> a clue!
04:35:42 <rostayob> in general the -ddump-whatever show what's the current state after the various passes
04:36:02 <applicative>  -ddump-deriv seems like....
04:36:03 <rostayob> -ddump-deriv
04:36:05 <rostayob> yeah
04:36:12 <Jafet> Compilers should accept wildcard switches
04:36:40 <dankna> really what it should be is
04:36:45 <Jafet> -fglasgow-exts becomes -X*
04:36:53 <dankna> the command line should be able to pass an arbitrarily complicated data structure
04:36:56 <dankna> rather than text
04:37:01 <rostayob> -ddump-* wouldn't be fun at all
04:37:06 <applicative> hard to read, but there it is with  -ddump-deriv
04:37:13 <applicative> thanks
04:37:42 <Jafet> dankna: then you'd end up passing the whole program in the command line
04:38:04 <rostayob> applicative: if that's hard, try -ddump-simpl
04:38:08 <dankna> Jafet: well, in a manner of speaking, yes.  part of that structure would be capabilities to read the files comprising the source.
04:38:10 <rostayob> ghc core ftw
04:39:22 <anakreon> Hi. I'm trying to install alex with cabal on ubuntu,  ghc-6.12.3. I get the error message "cabal: dependencies conflict: ghc-6.12.3 requires containers ==0.4.1.0 however
04:39:22 <anakreon> containers-0.4.1.0 was excluded because ghc-6.12.3 requires containers
04:39:22 <anakreon> ==0.3.0.0
04:39:22 <anakreon> "
04:40:20 <anakreon> It seems as if ghc requires containers 0.3 and 0.4.1 at the same time.
04:40:55 <rostayob> anakreon: I don't know what your problem is in this case, but I'll still suggest to download GHC 7
04:41:49 <anakreon> It is not available yet on ubuntu. I hopped there is a solution for ghc 6
04:43:10 <rostayob> anakreon: you can still download the binaries
04:43:20 <benmachine> anakreon: don't install new versions of containers
04:43:37 <rostayob> anakreon: (which is what I do)
04:43:56 <benmachine> anakreon: in general if you install new versions of packages that came with ghc, it gets confused
04:44:48 <anakreon> Thanks for your advice. I'll try to find binaries of ghc for ubuntu.
04:44:59 <Jafet> That's still a horrible error message
04:45:26 <rostayob> anakreon: http://haskell.org/ghc/download_ghc_7_0_3#distros
04:45:48 <rostayob> you can install that and then the haskell platform
05:11:03 <erus`> anachron: good luch
05:11:11 <erus`> i just installed arch
05:25:18 * frerich decides he should really read up what people mean with 'co-' all the time when talking about 'codata' and 'cofunctor' and whatnot.
05:25:38 <dmwit> "co-" means "reverse all the arrows in the category"
05:25:45 <dmwit> But it's, like... a formal reversal.
05:26:04 <dmwit> So if it's the category of functions, you just write f : A -> B when you mean f is a function that takes B's to A's.
05:26:13 <dmwit> (It's not magically a function in the other direction.)
05:26:28 <dibblego> when they say "cofunctor", they really mean contravariance, not duality
05:26:38 <frerich> Ok, so... is it possible to exlpain it without depending on me knowing what a 'category' is? :-}
05:26:45 <dmwit> A contravariant functor is a functor on the dual category, dibblego.
05:27:00 <Jafet> Why would you not know what a category is!
05:27:14 <Jafet> (A category is a basic notion, comparable to set)
05:27:38 <dmwit> frerich: No, but "category" is very simple: it's a collection of arrows, each of which have a domain and range.
05:27:52 <dmwit> arrows with comparable domains and ranges can be composed, and the category is closed under composition.
05:28:03 <dmwit> Lots of things happen to have this kind of structure.
05:28:25 <dmwit> (There's a couple of other sanity rules -- like composition should be associative, and that there should be identities for the composition at each domain type.)
05:28:43 <frerich> Is "arrow" yet another concept, or can I really think of something like a vector? :-}
05:28:59 <dmwit> frerich: What an "arrow" is depends on which category you're talking about.
05:29:11 <frerich> Ah.
05:29:17 <dmwit> But the generic term only demands that you can associate each arrow with two pieces of information: a domain and a range.
05:29:32 <frerich> So in the category of functions, an 'arrow' is a mapping between... two domaisn? Or two ranges? Or something like that?
05:30:08 <dmwit> One example of a category is where the arrows are functions and the domains and ranges are sets.
05:30:32 <frerich> Ah. What's another example of a category?
05:30:36 <hpc> frerich: in haskell terms, a category is an instance of class Category (~>) where id = a ~> a, (.) = (b ~> c) -> (a ~> b) -> (a ~> c)
05:30:54 <Jafet> dmwit: while you're at it, could you explain Hask
05:31:01 <dmwit> Any partially ordered set gives rise to a category, where an arrow "f : A -> B" is simply a statement of the fact that A <= B.
05:31:22 <hpc> frerich: the Kleili category is, for any Monad m, id = return; (.) = (<=<)
05:31:28 <dmwit> Hask is a category where the arrows are Haskell functions, and the objects (domains and ranges) are Haskell *types*.
05:31:56 <dmwit> frerich: If you know a bit of algebra, basically every kind of algebra gives rise to a category where the arrows are homomorphisms.
05:32:12 <dmwit> e.g. Group is the category whose arrows are group homomorphisms, and whos domain and ranges are groups.
05:32:28 <dmwit> There's lots more examples.
05:32:42 <maltem> Since we're at discussing categories, does anybody share my impression that the notation for limits and colimits ("lim" with an arrow beneath it) has the arrows the wrong way around?
05:32:43 <dmwit> Physics has a few neat ones.
05:32:47 <ion> benmachine: aye
05:32:56 <frerich> dmwit: I must admit I last had to tinker with *morphisms about, I think, ten years ago (at the university). I forgot almost anything. It becomes painfully obvious when trying to read articles about haskell.
05:33:10 <dmwit> hah
05:33:30 <dmwit> frerich: Well, the thing I didn't understand about categories for a long time was this:
05:33:46 <dmwit> *Most* categories have *much* more information available about them than what the bare definition asks for.
05:34:04 <frerich> I was hired out of university during the .com boom; it turned out to work well for me (luckily), but the gap in education shows now that I play with Haskell.
05:34:07 <dmwit> The bare definition just asks for a composition operator and domain/codomain operators.
05:34:33 <dmwit> But just about any *particular* category is much richer -- you can do more things with each particular arrow or each particular object.
05:35:05 <dmwit> Look at Hask: there's tons you can do with a function other than ask what it's domain and range type are.
05:35:20 <frerich> if "co- means "reverse all arrows in the category", and a category  is "a collection of arrows, each of which having a domain and range"... isn't a "codomain"a recursive definiton? :-}
05:35:27 <dmwit> You can apply it to other things, you can pair it up with other things, you can pass its type to a type constructor...
05:35:40 <dmwit> frerich: =)
05:36:30 <dmwit> Most people use "codomain" as a synonym for "range". Then, when you reverse the arrows, you add "co" to both "domain" and "codomain" to get "codomain" and "cocodomain", and, as we all know, two "co-"s cancel out...
05:36:51 <imphasing> they become... conan!
05:37:01 <dmwit> (I think it's meant to be a bit cute. =)
05:37:03 <hpc> co-NaN
05:37:07 <imphasing> hah
05:37:15 <int-e> dmwit: Yeah I was wondering what you'd get if you send a category theorist to fetch a coconut.
05:37:59 <dmwit> Just don't ask them to make you hot chocolate. You might get hot a instead!
05:38:31 <frerich> I think the puns are getting a bit painful. :-}
05:38:42 <danr> int-e: a nut?
05:38:42 <frerich> Thanks for your patience to explain all this though :-)
05:39:42 <maltem> danr, only up to unique isomorphism
05:39:51 <int-e> danr: yes, but what kind?
05:40:04 <dmwit> All nuts are isomorphic, who cares what kind?
05:40:08 <danr> int-e: * ?
05:40:18 <maltem> expect it to look somewhat unfamiliar, but still serving perfectly well as a nut
05:40:26 <int-e> danr: Heh. I might prefer a # nut.
05:40:49 <danr> A Constraint nut? (ConstraintKinds required)
05:41:17 <int-e> A cracked (unboxed) one.
05:41:22 <imphasing> Just listening to you guys make puns feels like I'm learning :P
05:42:59 <danr> imphasing: Oh you can say that in an arbitrary monad: "return listening to you guys ..."
05:43:33 <imphasing> One day I'll get those damn monads licked :P
05:43:42 <imphasing> And maybe understand wtf you just said
05:45:29 <danr> Nothing complicated. In the Maybe monad, return = Just
05:46:09 <imphasing> I'm realizing that it's just an API essentially.. but how that manages to allow referential transparency to be preserved with side-effect producing code makes my head hurt :/
05:46:21 <imphasing> s/it's/monads are/
05:46:30 <Jafet> danr: unsafeCoerce . Right
05:46:51 <danr> Jafet: not portable ^^
05:47:21 <Jafet> Eh, which versions of ghc won't that work on?
05:49:24 <danr> Jafet: oh I was considering the possibilities of other Haskell compilers than ghc
05:50:41 <Jafet> But under compiling our code, they all have to be isomorphic to ghc!
05:51:35 <dmwit> imphasing: Oh, well, there's your problem.
05:51:47 <Jafet> @quote monads.are
05:51:47 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
05:51:51 <dmwit> imphasing: Monads don't allow referential transparency to be preserved with side-effecting code.
05:52:32 <erus`> sex has side effects
05:52:39 <dmwit> Now it's your job to figure out whether referential transparency is preserved or whether Haskell has side-effecting code.
05:52:46 <maltem> imphasing, you get referential transparency by the definition of Haskell. This is independent of considering monads
05:53:09 <Jafet> type Monad = IO
05:53:15 <imphasing> So haskell allows side-effecting code without the using of IO monads?
05:53:24 <dmwit> Nope.
05:53:33 <imphasing> :|
05:53:39 <dmwit> But this is fun. Let's see if you can get the answer with only yes-or-no questions. =P
05:53:45 <dibblego> haskell disallows side-effecting code and this has nothing at all to do with monads
05:53:48 <dibblego> sorry
05:53:51 <maltem> imphasing, if you want to be nit-picking then you have to say that there are no side effects
05:53:57 <danr> condoms? What are ndoms?
05:54:02 <erus`> haskell has side effects
05:54:08 <dmwit> imphasing: (Hint: even code with an IO type isn't side-effecting, believe it or not.)
05:54:19 <Jafet> danr: don't reverse the arrows on those things
05:54:29 <Jafet> It burns
05:55:09 <imphasing> dmwit: So monads are the way of working around haskell's disallowing of side effecting code while still allowing you to touch the real world?
05:55:14 <imphasing> At least, IO monads
05:55:31 <dibblego> "...nothing at all to do with monads"
05:55:35 <quicksilver> well the monad part isn't important for that goal.
05:55:42 <erus`> we should write a dialect of haskell with no IO and guaranteed termination.
05:55:44 <imphasing> It's a method of getting around it though
05:55:46 <dmwit> imphasing: The usual distinction to make is that evaluating a value with IO type is pure, and produces a recipe for impure actions that are then executed by the run-time system.
05:55:57 <dmwit> imphasing: It's pure in the sense that you *always get the same recipe*.
05:56:04 <quicksilver> IO actions are a way to disallow side effecting code and have first class actions which the runtime executes for effects.
05:56:12 <quicksilver> that doesn't mention (or involve) the word Monad.
05:56:12 <Jafet> erus`: and give it an ugly name like "agda"
05:56:22 <quicksilver> monads are an observation that this idea shares common structure with other things
05:56:26 <erus`> agda has IO?
05:56:29 <quicksilver> (failure, continuation, state)
05:56:35 <dmwit> Even though sometimes when you crack an egg you get two yolks. =)
05:56:36 <quicksilver> and that common structure we call 'monads'
05:56:53 <imphasing> quicksilver: Hmm... I see.
05:57:10 <Jafet> erus`: whether it does or not is irrelevant, because you don't ever run agda programs
05:57:20 <Jafet> Therefore, they trivially terminate!
05:57:55 <benmachine> Jafet: is that true? I thought agda was capable of being a programming language
05:57:59 <benmachine> rather than just a theorem prover
05:58:02 <benmachine> at least in principle
05:58:39 <Jafet> Okay, some people run their programs. But that's no fun.
05:59:03 <imphasing> Give me another couple months of attempting to learn haskell and maybe this will start making more sense :D
05:59:36 <Jafet> (If a program is never run, does it halt?)
06:00:02 <Watermind> when running cabal update I'm getting this...
06:00:04 <Watermind> "cabal: error while loading shared libraries: libHSold-locale-1.0.0.2-ghc6.12.3.so: cannot open shared object file: No such file or directory"
06:00:05 <erus`> undefined
06:00:07 <roelvandijk> Jafet: If you interpret halting as a state transition then no...
06:00:19 <Watermind> any suggestions...
06:00:31 <benmachine> Jafet: I think does-it-halt is a property of a program that depends on what it would do if it were run
06:00:35 <benmachine> regardless if it is or not
06:00:50 <theorbtwo> All programs that are run will eventually halt (with the heat death of the universe).  However, no programs that are not run halt.
06:01:03 <imphasing> Can I think of a monad as just a simple type that exposes an API to operate on the type's data? Or is this not helping my cause :/
06:01:04 <konan> Dear all, I am trying to understand the ST monad from SPJ and Launchbury
06:01:24 <konan> 's "Lazy Functional Threads" paper.
06:01:28 <Jafet> ST isn't a monad, but (ST s) is.
06:01:33 <dmwit> Watermind: nasty
06:01:44 <benmachine> Jafet: I think it's reasonable to call (ST s) "the ST monad" :P
06:02:01 <maltem> imphasing, sounds fine
06:02:04 <dmwit> Watermind: Maybe ask your package manager who's in charge of that object file and reinstall that package?
06:02:06 <Jafet> Oh right, it is
06:02:19 <Watermind> dmwit: wait I just found this https://bugzilla.novell.com/show_bug.cgi?id=683898
06:02:24 <konan> Jafet: Fair point, but SPJ's paper uses the same term, and so I do too.
06:02:28 <Watermind> sounds like a problem with opensuse :(
06:03:16 <konan> I have a surface understanding of what rank-2 types are but I do not understand how they prevent a mutable reference to pass from one thread to other thread?
06:03:28 <konan> Can someone please explain this?
06:03:42 <quicksilver> you can only use the reference when the 's' matches
06:03:43 <hpc> konan: suppose you returned an STRef; it would have type (STRef s a)
06:03:46 <Watermind> guess I'll just install the new opensuse in november
06:03:49 <quicksilver> (in STRef s a)
06:04:03 <quicksilver> and since you don't know what that 's' is, you can't possibly pass it around
06:04:07 <hpc> konan: now when you pass it to another ST action, the s is still "too highly ranked"
06:04:19 <hpc> so the next ST action has type (ST s1 a)
06:04:19 <quicksilver> that's what the rank-2 does, it lets you work with an unknown but consistent 's'
06:04:31 <quicksilver> which is different to all other unknown but consistent 's'es
06:04:58 <konan> quicksilver, hpc: okay i think i get it a little
06:05:20 <konan> but not sure if i still get it fully
06:05:35 <hpc> konan: play around with functions that return higher-ranked values and see what happens
06:05:40 <Jafet> You could start with http://haskell.org/haskellwiki/Phantom_type
06:05:55 <Jafet> s is an existentially quantified phantom type
06:07:01 <konan> hpc, Jafet: okay, thanks for the pointers!
06:07:02 <Jafet> It's a particularly phantommy phantom type
06:07:22 <Watermind> is there any recommended book for learning about existentially quantified type from a theoretical point of view?
06:08:25 <benmachine> Jafet: apparently s is not a phantom type
06:08:52 <Watermind> for universaly quantified types one would just study ML (prenex) style polymorphism, and then System F
06:09:07 <Jafet> Hm, from which apparition do you say this?
06:09:07 <Watermind> but for existentially quatified types I'm not sure what to read
06:09:29 <Saizan> you can church encode them in System F
06:09:30 <benmachine> Jafet: what I thought phantom types were, and what I'm guessing you think they are, isn't what they actually are :P
06:09:47 <benmachine> Jafet: did you read that article (fairly recently?)
06:09:47 <quicksilver> a phantom type is one which doesnt' appear in the actual definition of the type
06:09:53 <quicksilver> with abstract types you can't tell
06:10:04 <quicksilver> "phantom" is not an abstract property, it's a concrete one.
06:10:08 <nominolo> Watermind: existentials can be modelled using System F
06:10:19 <benmachine> quicksilver: right
06:10:31 <quicksilver> since STRef is abstract I think you can argue that it's not appropriate to ask if the 's' is phantom.
06:10:53 <Watermind> Saizan: nominolo: but is that the usual presentation? or are they usually presented in some sort of standardized way that then can be shown as possible to encode using System F?
06:10:54 <benmachine> quicksilver: actually, according to the definition I've heard, it's STRef that would or would not be phantom, on account of s
06:11:13 <benmachine> if this is wrong then tell me so's I can correct it again :P
06:11:20 <Saizan> Watermind: sometimes you just get them defined as exists a. T a = forall r. (forall a. T a -> r) -> r
06:11:28 <nominolo> Watermind: well, they're from logics
06:11:34 <dmos> I'd like to generate haddock for yi with linked sources, but cabal install -fdochack yi only installs pure hadock since I can't pass arguments to haddock, and I can't figure out how to get 'cabal unpack yi && cd yi* && cabal haddock --hyperlink-source' to run with the dochack flag (without fails on cabal bug #656). Pointers appreciated.
06:11:42 <benmachine> the example in the article is newtype Const a b = MkC a -- Const is a phantom type, because b doesn't appear on the RHS
06:11:51 <Jafet> Well, none of the ways you construct an ST action involve a value of type s, so it's a spectre in that sense
06:11:56 <Saizan> Watermind: maybe with some syntactic sugar to build and unpack them as pairs of a type and a value
06:12:33 <nominolo> dmos: -f<foo> is an argument to cabal configure
06:12:38 <Jafet> In that ST does not ever involve any values of s.
06:12:49 <dmos> nominolo: ah. ok, I'll try that.
06:12:56 <quicksilver> Jafet: yup.
06:13:05 <Saizan> Watermind: if you happen to have TAPL there's a chapter on this
06:13:18 <quicksilver> benmachine: I doubt that's consistent. I have often used it (and seen others use it) to refer to the unused parameter not the whole type.
06:13:25 <Watermind> Saizan: yes I just don't know if that'd be the best way to go about really understanding them... just like I can enconde any  (finite strict) integer list as integers, but that's not how I'd study lists
06:13:31 <quicksilver> benmachine: here is a non-haskell citation, using it to refer to the parameter ; http://ocaml.janestreet.com/?q=node/11
06:13:45 <Jafet> Since ST is abstract, I'm inclined to call newSTRef, etc. public constructors of ST
06:13:54 <Watermind> Saizan: oh it does... ok that should do
06:14:20 <Jafet> Some of the examples on that page do a similar thing
06:14:45 <benmachine> quicksilver: hm. that's what I thought, but I was told otherwise (by ddarius iirc)
06:14:52 <Watermind> nominolo: do you also know any good logic book on the subject?
06:15:30 <nominolo> Watermind: no.  In TAPL they're called "objects" I think
06:15:53 <Watermind> ok so seems like I need to go back to TAPL
06:16:04 <Watermind> for some reason I didn't remember seeing it mentioned there
06:16:04 <Saizan> Watermind: in this case the encoding is quite close to how you'd use them anyway
06:16:06 <Watermind> thanks
06:16:12 <Watermind> Saizan: I see
06:16:22 <Saizan> maybe it's a paragraph more than a chapter, it's been a while :)
06:16:45 <Saizan> but they are also used to represent objects, so that would also be relevant
06:16:59 <imphasing> Does "maybe :: b -> (a -> b) -> Maybe a -> b" read as "maybe takes 3 arguments, b, a function returning b given a, and a Maybe a, returning b"?
06:17:37 <hpc> imphasing: you could also read it as "take a default value and a function from a to b, then return a function from Maybe a to b"
06:17:47 <nominolo> Watermind: yes, there's no chapter or section titled "existential types" in TAPL
06:18:12 <hpc> maybe 0 (+ 1) = "if Nothing, 0, else Just (x+1)
06:18:13 <hpc> "
06:18:19 <imphasing> hpc: That would be one curried form, correct?
06:18:21 <rostayob> imphasing: that type sig is equivalent to "maybe :: a -> ((a -> b) -> (Maybe a -> b))"
06:18:26 <hpc> imphasing: yeah
06:18:48 <benmachine> imphasing: your original interpretation was basically correct
06:18:58 <Watermind> nominolo: Saizan: now I'm getting confused, I just checked on amazon, and there's a small chapter (24) named existential types
06:19:08 <Watermind> just 16 pages though
06:19:14 <imphasing> Sweet :)
06:19:20 <Watermind> rather tiny :S
06:19:41 <benmachine> imphasing: although, notice that 'b' could be a function type, so it's actually possible for maybe to take more than 3 arguments
06:19:51 <benmachine> > maybe (const 0) (+) (Just 7) 8
06:19:52 <lambdabot>   15
06:19:56 <Saizan> Watermind: less to know, no?:)
06:19:58 <benmachine> > maybe (const 0) (+) Nothing 8
06:20:00 <lambdabot>   0
06:20:05 <Watermind> Saizan: true
06:20:15 <nominolo> Watermind: oh, missed that
06:20:20 <dmos> nominolo: that did the trick, thanks.
06:20:23 <Watermind> Saizan: I was just wondering about semantics and all that
06:20:53 <imphasing> I guess you can pass another curried function to b, which would expand the number of arguments..
06:20:57 <Watermind> Saizan: if there's any interesting ways to model it
06:21:05 <imphasing> thinking in terms of arguments might not be helping me out here
06:21:12 <imphasing> Does haskell ever have more than 1 argument to it's functions?
06:21:18 <hpc> imphasing: no
06:21:22 <benmachine> imphasing: this is why some people say "every function has exactly one argument, but sometimes they return a function"
06:21:23 <imphasing> Good :D
06:21:35 <hpc> if you are feeling silly, you can write functions that take a tuple as a parameter
06:21:44 <benmachine> hpc: exactly one tuple :P
06:21:56 <hpc> but that's usually reserved for people who only know java :P
06:21:58 <Watermind> Saizan: but I guess since it is encoded in System F, then there's not much to be said specifically about semantics of Existential Types
06:22:01 <nominolo> Watermind: TAPL also defines it as {exists X, T} = forall Y. (forall X. T -> Y) -> Y
06:22:04 <Jafet> Now, now, there are languages that actually do that
06:22:07 <hpc> benmachine: ;)
06:22:12 <Watermind> nominolo: right
06:22:13 <osfameron> though... the language allows you to define functions as if they took >1 parameter, and gives you helpful error messages that state the number of those parameters...
06:22:34 <benmachine> osfameron: yes. this is why I don't have that much truck with the exactly-one-argument way of doing things
06:22:44 <nominolo> Watermind: but also presents direct yping rules
06:22:49 <benmachine> I mean, it's true, but in practice you think of most functions as taking n arguments for some n
06:22:56 <Watermind> nominolo: ah that's nice
06:23:08 <Jafet> The one-argument view does benefit compiler writers
06:23:36 <benmachine> Jafet: it's very important that people understand the one-argument view, in terms of theory
06:23:48 <nominolo> Jafet: not that much
06:23:49 <dmwit> > let len(x, y) = sqrt(dot(x, y, x, y)); dot(x1, y1, x2, y2) = x1 * x2 + y1 * y2 in len(3, 4) -- Haskell for C programmers
06:23:50 <lambdabot>   5.0
06:24:13 <imphasing> So in haskell, "func a b c" is just "(((func a) b) c)" ?
06:24:18 <benmachine> imphasing: yes
06:24:18 <dmwit> imphasing: yes
06:24:23 <imphasing> Awesome :)
06:24:23 <benmachine> imphasing: yes
06:24:28 <dmwit> benmachine: yes
06:24:28 <hpc> dmwit: i would hate to see haskell for the lispers that only ever learned dynamic scope
06:24:29 <rostayob> imphasing: yes
06:24:33 <nominolo> Jafet: in terms of representation, yes.  In practise, functions are often also seen as taking multiple arguments at once
06:25:00 <hpc> it depends on how convenient it is to shift your perspective
06:25:06 <imphasing> hpc: My brain is in perpetual scheme mode due to writing a scheme in C#, so learning haskell is feeling so clean and lovely :D
06:25:15 <imphasing> So much assurance from haskell
06:25:17 <imphasing> It's lovely.
06:25:28 <Jafet> Well, we don't really need more than one optimizing compiler anyway
06:25:30 <hpc> it's nice for (+) to think of it as two arguments, but for const, you are usually better off thinking with currying
06:26:00 <benmachine> dmwit: yes
06:26:11 <saml> hi i'm here
06:26:15 <imphasing> So I guess haskell generates more functions by partial application of the first argument to a function?
06:26:23 <benmachine> saml: yes
06:26:23 <Jafet> The default evaluation method used by ghc is still to stuff arguments one by one into closures, I think
06:26:29 <saml> use template haskell to generate cdr caaaadr.. etc
06:26:41 <benmachine> Jafet: GHC does 'arity analysis' I think
06:26:41 <imphasing> How does haskell know when it needs to actually evaluate the function instead of partially apply another argument?
06:26:41 <hpc> heh
06:26:45 <benmachine> although I don't know what for
06:26:59 <hpc> imphasing: follow the types
06:27:05 <imphasing> Ah, right.
06:27:11 <Jafet> You mean the optimization pass that places arguments in registers?
06:27:36 <Jafet> Well, that's rather not-default in terms of how the compiler essentially works
06:28:40 <Jafet> imphasing: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution
06:28:56 <benmachine> imphasing: I'd say it knows based on the definitions
06:28:59 <Jafet> viel spass
06:29:09 <benmachine> imphasing: suppose you have map f [] = blah
06:29:16 <Jafet> Oh, I read "haskell" as "ghc".
06:29:25 <benmachine> then we know to 'evaluate' map when it has two arguments
06:29:37 <benmachine> (although the use of evaluate here is a little strange)
06:29:41 <saml> imphasing, it's called curry rice
06:29:43 <konan> @pl sequence $ replicate (length xs) xs
06:29:44 <lambdabot> sequence (replicate (length xs) xs)
06:29:55 <imphasing> saml: mmmm curry
06:30:07 <hpc> @pl \xs -> sequence $ replicate (length xs) xs
06:30:07 <lambdabot> sequence . (replicate =<< length)
06:30:09 <konan> @pl \xs -> sequence $ replicate (length xs) xs
06:30:10 <lambdabot> sequence . (replicate =<< length)
06:30:18 <hpc> ooh, nice and compact
06:30:36 <saml> > replicate 1
06:30:36 <imphasing> benmachine: Oh snap, you get partial application for free.. just calling a function with less arguments than it takes gives you a partially applied function :P
06:30:37 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [a])
06:30:37 <lambdabot>    arising from a use of...
06:30:39 <imphasing> That's awesome :D
06:30:43 <saml> > replicate (return ())
06:30:44 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:30:45 <lambdabot>         against inferred type ...
06:30:54 <benmachine> yes
06:30:55 <hpc> > replicate 5 4
06:30:55 <konan> This lambdabot seems to make use of function monad a lot.
06:30:56 <lambdabot>   [4,4,4,4,4]
06:30:59 <imphasing> I thought it was just a feature for function evaluation by haskell, not something I get to play with :D
06:31:38 <saml> currying shadow is functions
06:32:34 <konan> where can i get to see the implementation of instance of monad for (->) ?
06:32:45 <saml> currying is like  changing (x,y) -> z    to   x -> (y -> z) -> z
06:32:56 <benmachine> konan: it's probably in Control.Monad.Instances, but I bet you can write it yourself
06:33:00 <quicksilver> konan: http://haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/src/Control-Monad-Instances.html
06:33:02 <benmachine> saml: without the -> z at the end
06:33:11 <benmachine> (x,y) -> z => x -> y -> z
06:33:17 <imphasing> Does partial application involve basically saving the continuation of a function without the rest of the arguments passed, or does this not have anything to do with continuations..
06:33:20 <dmwit> ?src return (->)
06:33:21 <lambdabot> Source not found. Just try something else.
06:33:25 <dmwit> ?src return []
06:33:25 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:33:28 <dmwit> ?src [] return
06:33:28 <lambdabot> return x    = [x]
06:33:31 <nyingen> three packages in a row I just looked at on hackage, which are simple bindings to foreign libs, have build failures on 7.0
06:33:32 <dmwit> ?src (->) return
06:33:33 <lambdabot> return = const
06:33:37 <saml> benmachine, you need the last -> z.   x -> (y -> z)   composeed with (y -> z) -> z
06:33:38 <dmwit> ?src (->) (>>=)
06:33:38 <lambdabot> f >>= k = \ r -> k (f r) r
06:33:44 <dmwit> konan: There you go!
06:33:49 <benmachine> imphasing: I don't think it necessarily has anything to do with continuations
06:34:00 <benmachine> saml: one sec
06:34:02 <saml> first function takes x and returns  (y -> z).   the second function takes (y -> z) and returns z
06:34:15 <benmachine> @type let f :: (x,y) -> z; f = undefined in curry f
06:34:16 <lambdabot> forall a b z. a -> b -> z
06:34:23 <hpc> imphasing: dont worry about implementation for now; it is rather scary
06:34:29 <imphasing> hehe okay
06:34:32 <hpc> really cool, but scary
06:35:04 <benmachine> saml: pretty sure you're confusing things here
06:35:19 <benmachine> the second function *is* y -> z, so it takes y
06:35:24 <benmachine> and returns z
06:36:25 <dmwit> :t curry
06:36:26 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:36:30 <dmwit> settled
06:36:48 <imphasing> haha, types can have "forall" :|
06:36:55 <saml> benmachine, no..   look here: http://www.dabbleboard.com/draw?b=Guest818494&i=0&c=612d765465c194d4745b74dd2316cbdc8f233d74
06:37:03 <saml> that's currying
06:37:08 <imphasing> sorcery I say.
06:37:28 <hpc> imphasing: if you leave it off, the forall is implicit and not practically important
06:37:35 <saml> you need to last -> z. in math. but not in haskell type signature
06:38:09 <dmwit> saml: "You don't have access to the drawing or the drawing has been deleted."
06:38:18 <benmachine> saml: I can't see half of it
06:38:47 <hpc> that's one broken website
06:38:58 <saml> http://i.imgur.com/6ONwF.png
06:39:37 <saml> maybe i'm wrong
06:39:40 <saml> lol
06:39:48 <dmwit> I think you're just confused.
06:39:50 <benmachine> saml: I don't follow your drawing at all, but yes you are wrong :P
06:40:05 <saml> f :: x -> y -> z
06:40:17 <saml> f x  returns a function,  f1, f2, f3, ...
06:40:20 <int-e> yu roll?
06:40:21 <saml> depends on x
06:40:31 <jacobian> that's how yu roll
06:40:32 <benmachine> saml: right
06:40:43 <saml> so my second diagram is capturing it
06:40:45 <quicksilver> you can't properly represent currying in haskell, because haskell doesn't have any notion of "function which takes two arguments" to uncurry.
06:40:56 <quicksilver> we sometimes pretend that's what tuples are
06:40:58 <saml> see? my diagram is right
06:41:01 <benmachine> saml: no
06:41:02 <dmwit> saml: no
06:41:05 <saml> yes
06:41:05 <quicksilver> which gives us the library functions curry and uncurry
06:41:08 <hpc> saml: f (x, y) = x + y
06:41:13 <quicksilver> but sometimes that makes it more confusing not less ;)
06:41:16 <benmachine> saml: your second diagram is confused; you do not ever give a function as an argument to f
06:41:19 <hpc> saml: f x y = x + y -- (x -> y -> z)
06:41:34 <saml> (y -> z) -> z   means you take a function and returns z
06:41:41 <hpc> saml: f x g {- g :: y -> z -} = wtf do we apply g to?
06:41:43 <benmachine> saml: right, but f doesn't take a function
06:41:43 <dmwit> saml: But that's not what you do.
06:41:47 <saml> one instance of (y -> z)  is f1
06:41:49 <dmwit> saml: You take a *y* and return a z.
06:41:56 <saml> that's optimization
06:41:57 <benmachine> 'f x' doesn't take a function either
06:42:03 <dmwit> saml: No. It's a completely different type.
06:42:17 <benmachine> saml: you seem to be confusing input types and output types
06:42:27 <dmwit> ?djinn ((x,y) -> z) -> (x -> (y -> z) -> z)
06:42:28 <lambdabot> -- f cannot be realized.
06:42:32 <dmwit> saml: Proof.
06:42:36 <saml> yah it's not in haskell
06:42:42 <dmwit> It's not in math, either.
06:42:51 <dmwit>  ?djinn is a first-order logic theorem prover
06:43:06 <quicksilver> I think saml's arrows aren't the function type arrows
06:43:12 <benmachine> dmwit: "appeal to djinn" probably doesn't aid understanding :P
06:43:16 <hpc> saml: https://secure.wikimedia.org/wikipedia/en/wiki/Currying
06:43:17 <quicksilver> they're more a handwaving "this goes to this goes to this" kind of arrow
06:43:22 <benmachine> quicksilver: I think they are sometimes and aren't sometimes
06:43:26 <saml> yah it's natural tarnsformation
06:43:27 <quicksilver> benmachine: yeah, that too :)
06:43:28 <hpc> go forth and edumacate yourself
06:43:29 <int-e> saml: ah your diagram is confusing: x -> (y -> z) -> z is misleading, what you should really have is x -> (y -> z) and a separate table for each (y -> z)
06:43:45 <saml> i so confused!
06:44:14 <benmachine> saml: ok so when you curry a function that takes two arguments, you get a function that takes one argument and returns a function that takes the other argument
06:44:33 <benmachine> the types are (x,y) -> z and x -> y -> z respectively
06:44:36 <saml> let me update my drawing
06:44:40 <saml> i think my drawing is confusing
06:44:45 <benmachine> x -> y -> z is the curried form of (x,y) -> z
06:45:08 <jacobian> is there a mnemonic for remembering which way is curried, and which is uncurried?
06:45:44 <tac-tics> jacobian: @type
06:45:46 <dankna> curried is the convenient way
06:45:46 <tac-tics> @type curry
06:45:47 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:45:48 <benmachine> jacobian: not really. it's not terribly important in any case
06:45:49 <jacobian> haha
06:45:53 <rostayob> ahah this is great (the live drawing thing). we should move from IRC to drawing.
06:45:53 <jacobian> thanks tac-tics :)
06:46:07 <quicksilver> jacobian: 'Curry' had a clever idea, and his clever idea was to use curried functions, which we use in haskell.
06:46:17 <tac-tics> quicksilver: That is more practical
06:46:23 <jacobian> ah, good one
06:46:23 <saml> http://i.imgur.com/VgHDo.png   this might be better
06:46:28 <quicksilver> for the record, I don't like benmachine's argument.
06:46:31 <benmachine> I used to always get curry and uncurry confused, and basically just used whichever one typechecked
06:46:35 <quicksilver> (x,y) -> z doesn't have two arguments
06:46:39 <quicksilver> it has one (which is a tuple)
06:46:49 <quicksilver> haskell can't really represent uncurried functions, as I said before
06:46:51 <benmachine> quicksilver: I'm aware of the problem, but I don't know how to avoid it
06:46:55 <quicksilver> we just use tuples and pretend.
06:47:07 <quicksilver> A x B ---> C (uncurried)
06:47:07 <benmachine> quicksilver: I'm curious though, isn't that basically what mathematics does too?
06:47:15 <hpc> benmachine: yes
06:47:16 <quicksilver> A ---> B ---> C (curried)
06:47:21 <hpc> much to everyone's dismay
06:47:22 <saml> i thik of currying as function template
06:47:28 <saml> f<a>(b);
06:47:31 <benmachine> when is 'a function of two arguments' ever anything *but* a function on tuples?
06:47:51 <quicksilver> benmachine: you're right, and yet... there is a difference.
06:47:56 <Jaxan> saml: the analogy doesn't work for more than 2 arguments
06:48:13 <saml> look at ATS, i think it holds
06:48:18 <benmachine> Jaxan: does it work for 2 arguments? >_>
06:48:29 <Jaxan> a little
06:48:33 <quicksilver> benmachine: but the point is, other programming languages do have that distinction.
06:48:41 <quicksilver> benmachine: in C, foo(x,y) really is a function with two arguments
06:48:47 <quicksilver> there is no tuple being formed.
06:49:00 <benmachine> quicksilver: I suppose so.
06:49:18 <hpc> in javascript, uncurried foo(x,y) would be curried to foo(x)(y)
06:49:19 <Jaxan> benmachine: the fact that f<a> is a function makes the analogy work (but f itself isn't, so it breaks)
06:49:19 <imphasing> Soo.. what's the point of the curry function in the first place? I guess people are writing functions that take tuples and they want to partially apply them?
06:49:27 <int-e> I wonder. I have used 'uncurry' from time to time, but I can't remember the last time I used 'curry'. Is there any use for 'curry' in Haskell at all? :)
06:49:31 <quicksilver> it's clever that haskell overloads the "multiple arguments" notation used by C-like languages so it works for tuples.
06:49:34 <hpc> imphasing: some functions return tuples
06:49:37 <hpc> :t zip
06:49:38 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:49:40 <quicksilver> I say clever as if it's haskell's idea but of course it isn't.
06:49:41 <imphasing> Ah, right
06:49:43 <hpc> :t (***_
06:49:44 <lambdabot> parse error (possibly incorrect indentation)
06:49:45 <hpc> :t (***)
06:49:45 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:49:46 <imphasing> Interesting/..
06:49:48 <rostayob> imphasing: it's useful sometimes. if you zip two lists and have a function that operates on the two values
06:49:53 <int-e> (This is because the Haskell convention is to define curried functions, of course)
06:49:53 <quicksilver> it's much older
06:50:25 <benmachine> imphasing: in practice I don't use curry much, if ever
06:50:37 <dmwit> int-e: I could make up a situation, but I doubt it would come up.
06:50:38 <hpc> > map (uncurry (+)) $ zip [1..10] [10,20..100]
06:50:38 <lambdabot>   [11,22,33,44,55,66,77,88,99,110]
06:50:43 <benmachine> because most functions are already in that form
06:50:54 <dmwit> :t curry
06:50:56 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:51:00 <benmachine> imphasing: 'uncurry' is actually a more useful function, I find
06:51:22 <benmachine> quicksilver: I kind of agree with you but that leaves me at a bit of a loss to help people who don't understand about partial application in haskell
06:51:22 <imphasing> So uncurry takes a curried funciton (which I guess is every function) and transforms it into a function that takes tuples?
06:51:25 <imphasing> Or a single tuple
06:51:32 <dmwit> int-e: Say you were representing points as (x,y) tuples and had some function that took a point. Now you come along and want to apply it to a bunch of points, all of which have the same x value, but different y values.
06:51:36 <hpc> benmachine: explain it in javascript
06:51:36 <rostayob> :t uncurry
06:51:37 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:51:38 <rostayob> :t curry
06:51:38 <dmwit> map (curry f x) ys
06:51:39 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:51:46 <benmachine> imphasing: uncurry does what the type signature says it does
06:51:46 <dmwit> int-e: So you'd use curry in the map. =)
06:52:04 <rostayob> @dijnn (a -> b -> c) -> (a, b) -> c
06:52:05 <lambdabot> f a (b, c) = a b c
06:52:14 <rostayob> @dijnn ((a, b) -> c) -> a -> b -> c
06:52:14 <lambdabot> f a b c = a (b, c)
06:52:18 <quicksilver> benmachine: well my preference is to use the concrete syntax of another language where it is possible to show the difference.
06:52:26 <benmachine> quicksilver: fair enough, noted
06:52:26 <quicksilver> benmachine: javascript is a good one if they know javascript.
06:52:35 <quicksilver> but it is a fiddly thing to explain
06:52:47 <quicksilver> because there is much *less* to it than the questioner probably expects.
06:52:48 <int-e> dmwit: Yes, of course. I should've asked for actual uses, really. Maybe I should grab a hackage snapshot and grep to satisfy my curiosity.
06:52:51 <rostayob> quicksilver: well in javascript you can simply return closures all the way
06:52:52 <dmwit> > zipWith (+) [1..10] [10,20..100] -- hpc
06:52:54 <lambdabot>   [11,22,33,44,55,66,77,88,99,110]
06:53:02 <rostayob> quicksilver: but in haskell it's implicit
06:53:03 <hpc> @src zipWith
06:53:03 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:53:03 <lambdabot> zipWith _ _      _      = []
06:53:06 <quicksilver> rostayob: precisely. So you can see the difference directly.
06:53:06 <imphasing> So if I had a function 'add :: Int -> Int -> Int' the uncurried form would be 'add :: (Int, Int) -> Int' and I would have to pass the arguments as a tuple?
06:53:07 <hpc> @src zip
06:53:07 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
06:53:07 <lambdabot> zip _      _      = []
06:53:15 <dmwit> hpc: zip = zipWith (,) -- of course
06:53:20 <hpc> :P
06:53:24 <benmachine> imphasing: (uncurry only works on pairs, in particular, and functions 'with two arguments')
06:54:47 <hpc> http://www.haskell.org/haskellwiki/Currying -- all you really need to know about currying, plus links to what it is good for
06:55:19 <int-e> @type uncurry id
06:55:20 <lambdabot> forall b c. (b -> c, b) -> c
06:55:31 <benmachine> that article is guilty of the same problem that quicksilver commented on, as well
06:55:51 <benmachine> it describes one function as the curried form of another, and then says all functions are curried
06:55:58 <hpc> ah, true
06:56:02 <saml> we need to learn about history of currying. where it came from in what context
06:56:17 * saml finds original paper
06:56:32 <hpc> saml: it came from lambda-calc
06:56:54 <saml> http://lambda-the-ultimate.org/node/2266
06:57:39 <tac-tics> Does Djinn support any notion of a Void datatype?
06:57:46 <tac-tics> aka: False, aka Empty?
06:57:55 <tac-tics> @djinn Void -> Void
06:57:55 <lambdabot> f a = a
06:58:06 <copumpkin> of course
06:58:06 <tac-tics> Ask a question that can be programmatically solved....
06:58:07 <benmachine> @djinn a -> Not (Not a)
06:58:07 <lambdabot> f a b = b a
06:58:20 <copumpkin> @djinn Not (Not (Not a)) -> Not a
06:58:21 <lambdabot> f a b = void (a (\ c -> c b))
06:58:23 <Veinor> @djinn Not (Not a) -> a
06:58:23 <lambdabot> -- f cannot be realized.
06:58:27 <tac-tics> @djinn (a->b) -> ((Not b) -> (Not a))
06:58:28 <lambdabot> f a b c = b (a c)
06:58:48 <benmachine> Veinor: no LEM :>
06:59:03 <tac-tics> Djinn seemed kinda silly to me until I started learning about Dependent Types
06:59:03 <benmachine> or double-negation elimination, if there's a snappy name for that
06:59:10 <tac-tics> Actually, all of Haskell seemed silly until then >__>
06:59:28 <hpc> @djinn Void -> a
06:59:29 <lambdabot> f = void
06:59:34 <hpc> @src void
06:59:35 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:59:40 <mux> that's quite interesting, given that Haskell doesn't have dependent types
07:00:01 <tac-tics> mux: I didn't *understand* it until I got basic notions of dep. types under my belt
07:00:23 <copumpkin> the concepts are often cleaner
07:00:25 <copumpkin> with DT
07:00:30 <int-e> saml: In that post, is the  'A 'b  a pair?
07:00:43 <mux> tac-tics: I know that feeling, though in my case reading TAPL was "enough"; reading about DTs actually made my brain die a little
07:00:54 <imphasing> "In conclusion currying is a special case of partial application and hence can be termed so." <- I like this.
07:00:57 <imphasing> Makes sense to me.
07:01:12 <mux> doesn't to me :-P
07:01:22 <tac-tics> Then it's easy, polymorphism is function application, type classes are function application, and monads.... are still just monads, but I know at least I can encode the laws in types, so I can rest assured at least the fundamental laws of logic agree they aren't just made up by some nerd in Glasgow
07:01:33 <mux> hahah
07:01:38 <tac-tics> mux: TAPL?
07:01:46 <imphasing> Partial application can partially apply more than one argument, whereas currying reduces everything to 1 argument functions, is what I'm taking from it.
07:01:48 <mux> tac-tics: yeah, types and programming languages by benjamin pierce
07:01:52 <rostayob> @where TAPL
07:01:53 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:02:09 <int-e> saml: of course the irony is that in Haskell you'd implement papply as curry (or, perhaps, flip curry) - the distinction becomes very blurry.
07:02:17 <saml> int-e, i'm not sure. not sure the difference between 'CAPITALLETTER   and 'lowercase
07:02:21 <tac-tics> mux <3 Pierce
07:02:30 <tac-tics> I swear to god, that is my favorite book of all time.
07:02:33 <int-e> saml: Ok then. I'm confused about the same thing.
07:02:33 <tac-tics> I was reading it last night >___>
07:02:35 <mux> yeah, I don't know if I'd be able to write Haskell if it wasn't for him
07:02:41 <mux> TAPL just rocks
07:02:50 <mux> so much that I like cuddling the book.
07:02:56 <mux> omg, did I just say that aloud?
07:03:02 <Nafai> I need to get that book :(
07:03:07 <tac-tics> mux: I think a lot of people end up learning Haskell in school, and they get the whole natural deduction, structural induction proofs, etc drilled into them
07:03:07 <rostayob> wow, I didn't even know that book and I write haskell every day!
07:03:11 <imphasing> Why are you so expensive, textbooks.. :(
07:03:12 <tac-tics> But for me, I needed pierce to do that for me
07:03:32 <tac-tics> mux: I once had a dream about that book.
07:03:36 <rostayob> imphasing: libraries are cool
07:03:43 <tac-tics> For a long time, I had recurring dreams about two things: UFOs, and my ex girlfriend
07:03:45 <mux> tac-tics: hahaha, you seem to have even more issues than I :-P
07:03:51 <tac-tics> And one night I had a dream with BOTH UFOs *and* my Ex
07:04:03 <mux> she was taken away by aliens? that would fit
07:04:10 <tac-tics> There was a saucer flying around my room, and I was freaking out. So I grabbed the heaviest thing I could find in the room to throw at it
07:04:18 <imphasing> lol
07:04:22 <tac-tics> Which was Types and Programming Languages by B. Pierce.
07:04:26 <imphasing> Which was your ex?
07:04:27 <tac-tics> I remember it vividly
07:04:28 <imphasing> Aw damn.
07:04:28 <slack1256> lol
07:04:35 <imphasing> That would have beenfunnier.
07:04:37 <imphasing> :P
07:04:45 <mux> I really hope she's heavier than TAPL indeed
07:05:13 <tac-tics> She was pretty slim. She certainly didn't match the volume of KNOWLEDGE in that book.
07:05:22 <dankna> that's a highly amusing dream
07:05:23 <dankna> I approve
07:05:58 <tac-tics> It knocked the saucer off balance and it flew away
07:06:19 <tac-tics> TAPL: Useful for both type systems programming and fending off alien assault.
07:06:40 <Nafai> tac-tics: very nice dream
07:06:58 <tac-tics> But honestly, it's the best text I've ever written about programming languages
07:07:04 <tac-tics> Better than SICP, which I also liked a lot
07:07:14 <osfameron> TaPL?
07:07:18 * quicksilver never knew that tac-tics wrote TaPL.
07:07:21 <osfameron> it's very mathsy
07:07:25 <tac-tics> Like SICP, it's a low-handwaving text
07:07:28 <osfameron> I found the first chapter very hard to get through
07:07:33 <tac-tics> quicksilver: read/write
07:07:34 <tac-tics> whatever
07:07:36 <osfameron> but brain-stretching
07:07:37 <quicksilver> :)
07:07:52 <tac-tics> osfameron: I skipped most of the math, to be honest.
07:08:19 <tac-tics> It tries to cater to proves and to language designers equally
07:08:23 <dmwit> haha
07:08:45 <tac-tics> My induction-fu wasn't good enough (until I understood dependent types....)
07:08:45 <osfameron> it has mathsy definitions of things like (>=) which are fascinating, but quite alien as a programmer
07:08:45 <dmwit> The implication is that not only did tic-tacs write TaPL, he also wrote a handful of *other* books about PL that he didn't like as much. =D
07:08:47 <imphasing> Hm, I guess "pointfree style" is basically using partial application and composing those partially applied functions?
07:08:50 <imphasing> Seems clean.
07:09:03 <dmwit> tac-tics
07:09:05 <dmwit> dang
07:09:15 <tac-tics> dmwit: See how we all make typos sometimes :P
07:09:44 <dmwit> Totally.
07:09:55 <int-e> Often, point-free style can be recognized by an overabundance of dots.
07:10:18 <Clint> lots of points
07:10:36 <slack1256> damn you #haskell, at this rate you will make spend more on textbook tha beer per week
07:10:38 <osfameron> should we call it the "pointillist" style ?
07:10:57 <jacobian> hah :)
07:11:03 * osfameron persuaded his library to order TaPL
07:11:12 <osfameron> I think I'm the only person who's actually taken it out (once)
07:11:20 <tac-tics> lol
07:11:20 <osfameron> I should probably go back
07:11:37 <jacobian> I have it sitting open on my guitar case next to me.
07:11:41 <int-e> @pl \a b c d e -> a (b c) (d e)
07:11:41 <lambdabot> (((.) .) .) . (.)
07:11:46 <int-e> osfameron: yes :)
07:11:51 <tac-tics> Every time Haskell "hooks" me again, I go back and grab TaPL out of my closet
07:11:56 <slack1256> couldn't you ask your library to lend the book ... to somebody in chile?
07:12:07 <osfameron> I'd buy TaPL as an eBook I think
07:12:14 <mux> TAPL is also incredibly useful at convincing girls to leave you the fuck alone because you're an annoying geek anyways.
07:12:21 <slack1256> !!!! (enlightenment)
07:12:24 <copumpkin> read TTFP
07:12:28 <copumpkin> it's free online
07:12:30 <mux> (corollary to the above: never leave TAPL in sight when girls come over to your appartment)
07:12:38 <tac-tics> mux: I find the best girl repellant is Starcraft
07:12:49 <mux> starcraft repels even me :)
07:12:52 <mux> I'm no gamer
07:12:54 <copumpkin> and it contains more details on the type system most people around here care about
07:12:54 <int-e> mux: I can see it. "Wanna cuddle?" "No. Let me read you a story from this book instead."
07:12:56 <copumpkin> @where ttfp
07:12:57 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
07:13:01 <copumpkin> READ IT NOW
07:13:05 <mux> int-e: hahahaha
07:13:18 <tac-tics> int-e: Chapter 2. Proof of soundness.
07:13:44 <tac-tics> Let t be a term. By structural induction on t, we consider each rule as a case of the form of t
07:13:52 <slack1256> so. first ttfp, then TaPL, and then rest in peace?
07:13:57 <slack1256> Im OK with it
07:13:58 <tac-tics> T-Abs....
07:14:15 <mux> "...onto the meta-theory of subtyping now."
07:14:19 <mux> "you still with me?"
07:14:20 * Saizan wonders if that's the right order
07:14:25 <matthiasgorgens> I guess it improves in usefulness once you get married.
07:14:40 <matthiasgorgens> "I take out the trash, if you listen to my book."
07:14:40 <copumpkin> no, just ttfp
07:14:42 <copumpkin> screw tapl
07:14:49 <copumpkin> then read attapl
07:14:59 <slack1256> @where attapl
07:14:59 <lambdabot> http://www.cis.upenn.edu/~bcpierce/attapl/
07:15:02 <mux> ATTAPL made jelly out of my brain
07:15:12 <mux> but only the first few times I read it.
07:15:20 <mux> then it was already jelly to begin with
07:15:34 <mux> PCC is so cool though
07:15:48 <rostayob> you guys actually read those books from cover to cover?
07:15:53 <mux> sure
07:15:58 <mux> several times for good measure
07:16:02 <rostayob> wow
07:16:10 <mux> then I use it as reference of course
07:16:15 <Saizan> did you do the exercises?
07:16:25 <mux> I only did about 20% of them I think
07:16:40 <osfameron> PCC?
07:16:50 <mux> osfameron: proof carrying code
07:16:57 <jacobian> I did a lot of the TAPL exercises
07:17:03 <jacobian> I don't think I did any of them in ATTAPL
07:18:06 <dankna> huzzah for proof-carrying code
07:18:10 * dankna is a big advocate of it
07:18:55 <rostayob> mux: so wait, you read two books about types for kicks? don't you get bored?
07:19:36 <mreh> apparently not, if he read a second
07:19:44 <leod> from the looks of it this is so complicated, you could hardly get bored
07:19:48 <leod> maybe frustrated
07:20:00 <mux> rostayob: dude, you have no idea how incredibly interesting those bokos are
07:20:10 <mux> it's not really complicated, TAPL is very progressive
07:20:12 <rostayob> mux: I'll find out soon, but I know I'll get bored
07:20:20 <mux> that's why I think it's a good idea to read it cover to cover
07:20:34 <rostayob> but I never considered textbooks as something to "read" like that
07:20:48 <leod> oh man, these hardcovers are always so expensive
07:20:50 <mux> it's great in the subway when you have nothing else to do anyways
07:21:14 <rostayob> mux: in the subway it wouldn't be productive anyway, i can't really focus on the subway :P
07:21:18 <rostayob> and i need to write
07:21:21 <mux> too many pretty girls?
07:21:22 <leod> yeah
07:21:24 <leod> heh
07:21:24 <mux> I know that.
07:21:30 <matthiasgorgens> rostayob, that's what the margins are for.
07:21:38 <leod> they are usually to small
07:21:43 <mreh> @seen conal
07:21:44 <preflex>  conal was last seen on #haskell 5 days, 20 hours, 11 minutes and 47 seconds ago, saying: roconnor: no, i won't be at ICFP this year. will you?
07:21:44 <lambdabot> Unknown command, try @list
07:21:46 <leod> too*
07:21:57 <rostayob> matthiasgorgens: I don't buy those books, I just get them at the library
07:22:00 <leod> 50 euro for a book :(
07:22:03 <matthiasgorgens> rostayob, oh, ok.
07:22:08 <rostayob> buying them is an insane waste of money
07:22:20 <rostayob> seriously, the textbooks prices are fucked up
07:22:22 <mreh> burning them would be a waste of money
07:22:24 <mux> I think I used to buy "unix internals" by uresh vahalia 70 EUR or so
07:22:29 <mux> those books ARE expensive
07:22:30 <matthiasgorgens> it's cheap entertainment, if you read them cover to cover.
07:22:36 <mux> (great book about kernel programming, btw)
07:22:42 <matthiasgorgens> the euros/h price is probably smaller than going to the cinema.
07:22:55 <mreh> has anyone else played with reactive and found out how to make feedback loops?
07:23:04 <mux> it used to be my favourite one before I read TAPL
07:23:06 <rostayob> matthiasgorgens: I guess so. personally i don't buy books at all. if i *really* like a book i'll read it twice
07:23:13 <matthiasgorgens> rostayob, some of them cost so much, because they have to spread out the fixed costs of making a book over a very small print run.
07:23:22 <mux> yeah
07:23:31 <leod> some books are good as a reference though (e.g. TAOCP)
07:23:38 <rostayob> but buying books doesn't make sense to me. a book is not a tool (most of the times. buying some reference books can be useful)
07:23:39 * mux nods
07:23:47 <matthiasgorgens> rostayob, I don't buy them (in general) either.  I got a few books in gothic script that I picked up at flea markets.
07:23:55 <mux> I wouldn't even attempt/want to read TAOCP cover to cover
07:24:03 <leod> yeah
07:24:08 <mux> now THAT would be boring
07:24:19 <matthiasgorgens> and i bought a copy of moby dick.  the 5 pounds were probably going to be cheaper than the late fees at the library.
07:25:06 <matthiasgorgens> By the way, is anyone going to Hal-9?
07:25:45 <mreh> I don't think so Dave
07:25:54 <rostayob> matthiasgorgens: well on amazon most of the classics are like 1.5£ :P
07:26:32 <int-e> mux: I really loved the sorting chapter ... especially the effort that went into tape management. :)
07:27:04 <jacobian> I agree though that text books are well overpriced
07:27:25 <imphasing> I think everyone dislikes publishers of all scientific things :P
07:27:33 <mux> int-e: I would love TAOCP a lot more if knuth didn't feel he had to invent a damn language to write the algorithms with :-P
07:27:42 <mux> also, quite often the maths are way over my head
07:27:46 <osfameron> and a whole language to typeset the book with
07:27:48 <slack1256> the more specific the book the more expensive
07:27:50 <mux> and fuck, I like maths.
07:28:00 <osfameron> did he also make his own paper, out of trees he grew himself?
07:28:08 <int-e> mux: Yeah I skipped a lot of the math development and almost all the MIX programs.
07:28:12 <tac-tics> @where TAOCP
07:28:12 <dankna> I think he was right, he did need his own language
07:28:12 <lambdabot> I know nothing about taocp.
07:28:21 <mux> METAFONT + TeX + MIX
07:28:22 <dankna> he makes the case for it in the preface
07:28:29 <mux> that's a lot to do to write a book in the end :)
07:28:34 <hpc> texmix sounds like a cereal brand
07:28:35 <dankna> saying basically that if he picked an existing language, people would assume his books were about the language
07:28:37 <int-e> mux: luckily that still leaves quite a bit left to read :)
07:28:43 <mux> int-e: yeah! :)
07:29:22 <quicksilver> dankna: also, if he picked a language, he'd spend too long worrying about the peculiarities of that language.
07:29:41 <int-e> @where+ TAoCP http://www-cs-staff.stanford.edu/~uno/taocp.html
07:29:41 <lambdabot> Good to know.
07:29:44 <dankna> quicksilver: yes, that as well
07:29:50 <quicksilver> because he is such a 'details' person he never feels he can ignore peculiarities
07:29:55 <dankna> haha yeah
07:30:02 <mux> quicksilver: sounds about right given that he still didn't finish it even using his own language :-)
07:30:05 <mreh> quicksilver: Jules?
07:30:10 <quicksilver> if a statement he makes isn't precisely, literally, 100% true, he explains it in parens on a footnote.
07:30:28 <quicksilver> mreh: how dare you address me by my real name in this anonymous cyberpunk environment!
07:30:34 <mreh> aaah!
07:30:47 <mreh> I couldn't remember your nick until it appeared
07:30:51 <mux> quicksilver: and he seems to be getting worse and worse at this - the size of the TAOCP books grows exponentially :-)
07:30:57 <quicksilver> "until" it appeared?
07:30:59 <quicksilver> I'm always here...
07:31:14 <mreh> quicksilver: you stopped speaking for five minutes, what were you doing?
07:31:16 <mreh> anyway
07:31:45 <mreh> I'm playing with your reactive, pretty great stuff, made an openGL program, having fun, got kinda stuck though
07:31:52 * slack1256 wonders how heavy is TAOCP
07:32:10 <slack1256> it could kill a little child during a earthquake
07:32:43 <mreh> was looking for some input on cyclic dependencies and also your thoughts on expanding to include calculus, but I'm guessing that's just a pure function on a polynomial
07:32:49 <rostayob> I'm going to have a course about type systems next year. this is the homepage of the lecturer: http://www.doc.ic.ac.uk/~svb/ . note the email address, and the picture which is a gif that briefly changes once in a while
07:32:59 <rostayob> so studying types does that to you?
07:33:09 <quicksilver> mreh: the answer to both of them is the same, isn't it?
07:33:12 <quicksilver> you need a solver.
07:33:12 <imphasing> No, but too mush LSD might.. :O
07:33:14 <imphasing> What a site.
07:33:17 <quicksilver> I think.
07:33:18 <rostayob> yeah, really
07:33:23 <jacobian> What's a good reference on formal derivatives of types?
07:33:29 <quicksilver> not a trivial thing unfortunately
07:33:38 <quicksilver> jacobian: McBride
07:34:01 <mreh> quicksilver: bummer
07:34:10 <imphasing> the nude painting all over that site makes it even funnier
07:34:24 <quicksilver> jacobian: http://strictlypositive.org/calculus/
07:34:59 <quicksilver> mreh: I generally unwrap my algorithms and just make them explicit iterative simulations
07:35:26 <quicksilver> mreh: velocity_(n+1) = velocity_(n) + acceleration_(n)
07:35:28 <mreh> I was trying to model wind resitance as proportional to the velocity of some thing, it forms a cyclic dependency with the acceleration
07:35:50 <quicksilver> well you make the acceleration at time n depend on the velocity at time n-1
07:35:55 <quicksilver> which is, admittedly, imprecise
07:35:57 <quicksilver> but it's practical.
07:36:02 <mreh> quicksilver: yes, okay
07:36:06 <quicksilver> solvers are hard! let's go shopping.
07:36:29 * imphasing finally got the amb function running in his scheme, makes me want to write a SAT solver
07:36:35 <imphasing> Haskell sounds more fun though
07:36:54 <mreh> velocity is a behaviour though, which i suppose I'll be sampling anyway
07:37:07 <quicksilver> well you can make them a discrete behaviour
07:37:14 <quicksilver> the approximation above
07:37:17 <quicksilver> and then you interpolate
07:37:28 <quicksilver> so the continous behaviour just interpolates between the samples
07:37:34 <quicksilver> pretty sure my stars demo does that?
07:37:47 <quicksilver> no documentation and very few comments, of course.
07:37:53 <mreh> quicksilver: quite likely, I didn't scrutenise it closely though
07:38:34 <mreh> i can live with imprecise
07:39:10 <mreh> conal was talking about root finding for colissions, but I suppose that's all open research
07:39:37 <imphasing> How does one define a new data constructor?
07:40:00 <rostayob> imphasing: data Foo = Foo Int?
07:40:08 <rostayob> where Foo :: Int -> Foo
07:40:09 <imphasing> Wouldn't that be a typr constructor?
07:40:09 <quicksilver> mreh: yes. For me the question about root finding is "how do I design it so I can stop it if it's too slow" ?
07:40:14 <imphasing> Hm
07:40:17 <rostayob> imphasing: Foo in that case is also a type constructor
07:40:24 <rostayob> the one on the LHS is the type constructor
07:40:43 <Saizan> imphasing: you can only define a data constructor as part of defining a type with "data" or "newtype"
07:40:50 <imphasing> Oooooh...
07:40:51 <mreh> quicksilver: why would cyclic dependencies need a solver exactly?
07:40:59 <imphasing> Okay thanks :)
07:41:13 <quicksilver> mreh: that's the worry about clever implicit stuff - clever implicit stuff doesn't know what framerate I'm trying to maintain so it doesn't know how long it can afford to spend finding roots
07:41:26 <rostayob> imphasing: "data Foo a = Bar a" in this case Foo is a type constructor of kind * -> *, and Bar is the data constructor of type Int -> Foo
07:41:34 <quicksilver> mreh: so you need to design something which can bail if it runs low on time. Or agree that it's OK to drop frames.
07:41:51 <quicksilver> mreh: well, what are the solutions to "x = y; y = u; u = x" ?
07:41:52 <rostayob> kind signatures are like type signatures but they have stars :P
07:42:16 <quicksilver> mreh: simplistic cylicity leads to infinite loops.
07:42:31 <rostayob> imphasing: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
07:43:05 <imphasing> Thanks for the link, never even heard of "kinds" until just now :P
07:44:27 <imphasing> So do kinds have a kind? :P
07:44:40 <jacobian> quicksilver: Thanks
07:45:03 <rostayob> imphasing: no, types have a kind
07:45:12 <rostayob> :k Maybe
07:45:12 <lambdabot> * -> *
07:45:15 <rostayob> :k Int
07:45:16 <lambdabot> *
07:45:36 <rostayob> :k StateT
07:45:37 <lambdabot> * -> (* -> *) -> * -> *
07:45:46 <mreh> quicksilver: I'm going to look at unrolling, thanks for the hint, how do you control the granularity of your iterations?
07:45:57 <rostayob> :k Maybe Int
07:45:57 <lambdabot> *
07:46:08 <quicksilver> mreh: clumsily with a hardcoded constant :)
07:46:14 <quicksilver> mreh: I'm sure there is something to be said for being cleverer.
07:46:19 <tac-tics> imphasing: kinds have a super-kind
07:46:20 <imphasing> rostayob: Ah, so a kind is basically the structure of a type
07:46:24 <imphasing> tac-tics: wat
07:46:27 <tac-tics> imphasing: some languages do make use of superkinds
07:46:30 <quicksilver> however the important point is to decouple the simulation speed from the framerate
07:46:38 <mreh> quicksilver: well, sometimes you have to sacrifice being clever for being finished
07:46:39 <imphasing> Interesting :O
07:46:42 <quicksilver> more frames just gives you more interpolation, not a different simulation result.
07:47:10 <mreh> quicksilver: fewer frames gives you less accuracy, so a potentially increasing error no?
07:47:13 <rostayob> imphasing: well I'm not too sure about the language here, but you get the idea
07:47:20 <tac-tics> imphasing: Essentially, you have an infinite "tower" of terms. Terms < Types < Kinds < Superkinds < (we don't use names for anything past this point)
07:47:33 <quicksilver> mreh: no, because frames are just how often you display and this is quite separate.
07:47:34 <rostayob> yeah you can go on forever
07:47:47 <quicksilver> mreh: you simulate at a fixed rate (say 100 iters per second)
07:48:05 <mreh> aha
07:48:07 <mreh> i get you
07:48:12 <quicksilver> and you display as many frames as you can or capped at a sensible cap possibly.
07:48:18 <quicksilver> actually I only simulated at 10/second IIRC
07:48:19 <mreh> any samples inbetween are interpolated
07:48:26 <quicksilver> because I wanted to test interpolation
07:48:28 <imphasing> tac-tics: That's pretty coo
07:48:29 <quicksilver> which worked really nicely.
07:48:37 <leod> are you talking about a game?
07:48:45 <mreh> leod: games yes
07:48:48 <leod> ah
07:49:02 <leod> i wish there were more open source games written in haskell
07:49:07 <tac-tics> imphasing: Generally, the more "interesting" your type system, the higher the tower goes.
07:49:09 <mreh> Haskelloids
07:49:16 <quicksilver> leod: well it doesn't have to be. Any kind of visualisation of an evolving system.
07:49:20 <imphasing> So I guess a kind is basically the type information without the type data itself..
07:49:26 <leod> quicksilver: yeah, that's why i asked :)
07:49:27 <quicksilver> leod: games are the most motivating example for many people though.
07:49:42 <tac-tics> imphasing: The easiest way to understand kinds are type constructors
07:49:44 <tac-tics> @kind Int
07:49:45 <lambdabot> *
07:49:46 <tac-tics> @kind Char
07:49:46 <lambdabot> *
07:49:52 <tac-tics> @kind Maybe Int
07:49:53 <lambdabot> *
07:49:55 <tac-tics> @kind Maybe
07:49:56 <lambdabot> * -> *
07:50:00 <mreh> I've written an open source game
07:50:10 <mreh> well, cloned it off an old game
07:50:10 <tac-tics> Maybe is a function in the type world that makes a * to another *
07:50:21 <leod> mreh: Haskelloids is cool, but i wish there was something.. bigger
07:50:27 <imphasing> tac-tics: Ah, I think I get it :D
07:50:28 <mreh> leod: I agree
07:50:29 <imphasing> In some way.
07:50:35 <quicksilver> leod: frag is fairly big
07:50:35 <mreh> but developers need bread
07:50:39 <imphasing> Type "functions" :|
07:50:42 <imphasing> Seems weird, but cool.
07:50:50 <leod> quicksilver: yeah, that's the biggest example i know of
07:50:51 <mreh> wait 20 years an i'll open source the game that I MAKE
07:50:58 <rostayob> imphasing: well the kind depends on how many other types you need to form a "concrete" types
07:51:03 <mreh> oops, caps
07:51:06 <rostayob> and what kind of type you need
07:51:08 <imphasing> I guess that's what a type constructor is, a "function" that operates on and returns types
07:51:14 <tac-tics> imphasing: The usefulness appears later on in life, once you learn about more interesting extensions to Haskell and other languages
07:51:15 <leod> mreh: heh
07:51:28 <rostayob> so with Maybe a = Nothing | Just a you need an "a" to form a concrete type
07:51:34 <imphasing> partially applied type constructors :|
07:51:36 <imphasing> sorcery!
07:51:49 <rostayob> while data Bool = True | False is already concrete
07:52:00 <imphasing> Ah, right, since it's not polymorphic..
07:52:03 <tac-tics> imphasing: Also, when you have polymorphism, such as id :: a -> a, what you really have is a type forall a. a -> a
07:52:09 <mreh> quicksilver: if you find the lines that are unwrapped and iterating let me know
07:52:18 <tac-tics> Polymorphism is a function (in the term world) which takes a type (a paramter of kind *)
07:52:21 <rostayob> it's even easier to partially apply with type constructor, you might have "Foo a b" and say "Foo a Int"
07:52:21 <tac-tics> @type id
07:52:22 <lambdabot> forall a. a -> a
07:52:41 <tac-tics> The "forall" can be thought of as an extra parameter you pass a type to (instead of a value)
07:53:19 <imphasing> So I guess "terms" are another concept of "type" but higher level?
07:53:45 <imphasing> Not in match, but maybe I'm jsut confused
07:53:48 * hackagebot cofunctor 0.1.0.1 - DEPRECATED: use the "contravariant" package  http://hackage.haskell.org/package/cofunctor-0.1.0.1 (BrandonSimmons)
07:53:50 <imphasing> s/match/match/
07:53:52 <imphasing> *math
07:54:36 <imphasing> Haskell's type system is so much richer than anything I've ever worked with :O
07:54:38 <mamalujo> imphasing: no, just the contrary, thats the normal values, like data constructors, functions etc
07:54:40 <rostayob> imphasing: I'm not sure I get what you mean
07:55:24 <imphasing> "Polymorphism is a function (in the term world)" <- trying to decipher "term world" here :)
07:56:09 <mamalujo> imphasing: 'types' of types are kinds
07:56:20 <quicksilver> mreh: well Deus.Stars.Model.evolveStarField is the "work out state at time n+1 from state at time n"
07:57:02 <quicksilver> mreh: then in the main function 'timewiseIterate" runs that function every 400ms to form an Event
07:57:13 <copumpkin> aww
07:57:16 <copumpkin> poor cofunctor
07:57:21 <copumpkin> I bet edwardk smacked him down
07:57:29 <quicksilver> mreh: and then the 'interpolate' stuff makes it into a smooth behaviour.
07:57:33 <edwardk> sadly, i did
07:57:42 <copumpkin> EPIC PWNAGE
07:57:51 <asmyoussof> hello world
07:57:51 <edwardk> i was a little more polite than that
07:57:57 <elliott> If one gets "cannot find symbol" linker errors from an FFI-using package when using the bytecode interpreter (i.e., GHCi and Template Haskell code), even though compiled code works fine, what does this mean? Do I need to build a shared version of the library?
07:58:01 <copumpkin> oh, you didn't just way PWNT with a link to contravariant?
07:58:03 <edwardk> i just said there was already a contravariant package and that cofunctor = functor ;)
07:59:02 <edwardk> i just found it hilarious that the one time i touch contravariant in 6 months (because some folks had asked for an infix operator for contramap), someone else uploads something literally within the same hackagebot spam cycle
07:59:16 <edwardk> that does a subset of the same things
07:59:41 <copumpkin> :)
08:05:05 <elliott> I guess nobody is an expert in bytecode interpreter FFI linkage issues :p
08:17:04 <Andreas_> Hi, is it possible to use a 64bit ghc (on linux) to build 32 bit binaries?
08:17:17 <quicksilver> Andreas_: no.
08:17:33 <Andreas_> Do I need to get a 32 bit ghc?
08:18:01 <Andreas_> the i386 distribution?
08:18:08 <quicksilver> yup
08:18:35 <Andreas_> OK, thanks
08:23:49 <imphasing> Hmm... is a functor akin to a closure?
08:25:17 <imphasing> I guess not, it's just something that can be mapped apparently
08:44:37 <imphasing> Is it possible to define a function with a variable number of arguments in haskell?
08:44:46 <b_jonas> imphasing: not really
08:44:49 <elliott> Yes, but you almost certainly don't want to.
08:44:54 <tac-tics> imphasing: There are techniques that allow it
08:44:57 <imphasing> I was hoping the answer was "no" :(
08:44:57 <tac-tics> @type printf
08:44:58 <lambdabot> forall r. (PrintfType r) => String -> r
08:45:06 <elliott> imphasing: It is "no", in practice
08:45:10 <imphasing> Okay good :D
08:45:10 <elliott> But why do you want it to be no
08:45:11 <tac-tics> imphasing: You use infinite types to do it.
08:45:29 <imphasing> elliott: Because it would make the curried functions stop making sense to me pretty much
08:45:36 <elliott> tac-tics: Infinite types? Not really, it's just polymorphic recursion, no?
08:45:40 <tac-tics> Basically, a function a -> B where B can either be a concrete type or an a->B
08:45:51 <b_jonas> imphasing: that's basically why we have array constructor [x1,x2,x3,...,xn] as primitive syntax
08:46:03 <imphasing> Ah, cool..
08:46:05 <tac-tics> elliott: It's analogous, but yeah, maybe it's not true infinite types
08:46:07 <b_jonas> instead of just a function
08:46:27 <tac-tics> b_jonas: we don't need list syntax. It's just nicer than x1 : x2 : x3 : []
08:46:37 <tac-tics> @type printf
08:46:38 <lambdabot> forall r. (PrintfType r) => String -> r
08:46:41 <b_jonas> tac-tics: we don't _need_ it, but it would be really ugly to not have it
08:46:44 <tac-tics> @type printf "a" 2 [1,2,3]
08:46:45 <lambdabot> forall t t1. (Num t, PrintfType ([t] -> t1)) => t1
08:46:55 <imphasing> I can sort of see how this "infinite type" thing would allow that though...
08:46:59 <tac-tics> @type printf 1 2 3 4 5 :: IO ()
08:46:59 <imphasing> Which sounds hard to understand.
08:47:00 <lambdabot>     No instance for (Num String)
08:47:00 <lambdabot>       arising from the literal `1' at <interactive>:1:7
08:47:00 <lambdabot>     Possible fix: add an instance declaration for (Num String)
08:47:13 <elliott> imphasing: It isn't really.
08:47:16 <b_jonas> there's a good reason why so many languages have something similar
08:47:18 <elliott> It's just a novel application of typeclasses.
08:47:30 <elliott> But trying to understand it at what I assume is a pretty early stage in your Haskell education is probably counterproductive.
08:47:32 <imphasing> Maybe I don't understand typeclasses well enough yet :)
08:47:44 <tac-tics> elliott: For sure :P
08:48:14 <benmachine> tac-tics: definitely not infinte types
08:48:21 <elliott> Maybe we should start just lying to people. "Can Haskell do variadic functions?" "No. Never."
08:48:29 <benmachine> imphasing: printf is dark magic, ignore it for now
08:48:30 <tac-tics> benmachine: ok, no, they're not infinite types X(
08:48:34 <Phyx-> why?
08:48:37 <tac-tics> But you can ALSO do it with infinite types
08:48:51 <b_jonas> tac-tics: could you?
08:48:51 <imphasing> With type hackery, I can imagine anything is possible in haskell. Pretty much any paradigm can get replicated nicely it seems :)
08:48:58 <imphasing> And not just "turing complete" replication
08:49:02 <b_jonas> imphasing: nicely?
08:49:03 <benmachine> tac-tics: the trouble is that there's such a thing as an "infinite type error" and people already get confused by that
08:49:13 <imphasing> infinite types seem pretty elegant, but confusing
08:49:14 <b_jonas> imphasing: I think this vararg stuff is a counterexample
08:49:24 <b_jonas> imphasing: because varargs can't be done in haskell nicely
08:49:35 <Phyx-> b_jonas: yup, i'm confused now myself
08:49:49 <b_jonas> Phyx-: why?
08:49:50 <benmachine> imphasing: there are some fairly reasonable things which aren't possible, but not many of them, and usually you don't care
08:50:11 <b_jonas> benmachine: can you give an example of what you're thinking of, besides varargs?
08:50:23 <Phyx-> b_jonas: because unless there's some other meaning for an Infinite type, I don't see how anything with them can work..
08:50:52 <imphasing> Eventually the infinite type will reach a concrete type
08:50:57 <imphasing> At elast the way I'm imagining it
08:51:00 <benmachine> b_jonas: I think what I had in mind was, e.g. we have liftA2 and liftA3 and liftA4 but you can't define liftAn
08:51:15 <Phyx-> imphasing: then it's not really infinite now is it? so why call it that?
08:51:21 <imphasing> Because the definition is infinite
08:51:23 <hpc> benmachine: isnt that dependent types?
08:51:24 <b_jonas> benmachine: ah
08:51:30 <benmachine> hpc: yes, basically
08:51:59 <imphasing> The type definition is recursive and infinite it seems, but the concrete type is reached based on some magic of how haskell interprets curried functions and how many of them there are (arguments)
08:52:02 <int-e> not even with some printf-type class hackery?
08:52:14 <int-e> @type printf
08:52:14 <imphasing> But this is just me waxing poetic about something I don't understand ;P
08:52:15 <lambdabot> forall r. (PrintfType r) => String -> r
08:52:25 <mekeor> \\
08:52:34 <benmachine> int-e: possibly, but it wouldn't be statically typed in that case
08:52:55 <erus`> are there any docs online for writing a C(++) targeting functional language compiler?
08:53:03 <b_jonas> benmachine: in my eyes, the problem is not that you can't define it as one function, but also that once you want to have liftA3 and liftA4 in a library, you'll also want a lot of related utility functions whose number explodes exponentially
08:53:09 <int-e> benmachine: but it would. Text.Printf is completely type-driven, what may fail at runtime is the pattern match with the template string.
08:53:20 <b_jonas> sure, we have liftA3 in the library, but that's not the point
08:54:09 <benmachine> b_jonas: right. there's no uniformity
08:54:24 <benmachine> which is related to why there's not e.g. a Functor instance for tuples of size > 2
08:55:03 <benmachine> int-e: the thing with printf is it type-checks way too easily
08:56:34 <rwbarton> you can write liftAn which takes an argument (undefined :: S (S (... Z))) which tells what n is
08:57:03 <benmachine> rwbarton: possibly you could do that, but it would be kind of heavyweight to do so
08:57:13 <benmachine> I suppose you'd then put 'one' and 'two' and so forth in libraries
08:57:15 <rwbarton> yes, it wouldn't be that useful really
08:57:19 <rwbarton> right
08:57:37 <benmachine> but it would be nice if we could have 1 in certain contexts be inferred to be type S Z, etc.
08:57:41 <rwbarton> with tuples there is no hope because n-tuples for various n have nothing in common (except via TH I guess)
08:57:48 <rwbarton> hm
08:57:58 <benmachine> if TH were better it would address my concerns somewhat
08:58:37 <b_jonas> rwbarton: as long as you only want tuples up to some small maximum, you could use a typeclass to match all them in standard haskell
08:58:38 <tac-tics> undefined is like a drifter who will live anywhere the cops don't get on his case.
08:58:47 <tac-tics> He inhabits all sorts of places you wouldn't expect to find him
08:59:30 <Eduard_Munteanu> Was HList mentioned already?
08:59:47 <imphasing> I thought a space was function application... but (/10) works :|
08:59:54 <Eduard_Munteanu> (or whatever alternatives there may be)
08:59:55 <b_jonas> Eduard_Munteanu: no, what's that?
09:00:05 <Eduard_Munteanu> Oleg's heterogenous lists.
09:00:06 <benmachine> imphasing: works in what sense?
09:00:13 <rwbarton> you can also use nested tuples
09:00:23 <imphasing> benmachine: Gives me back a partially applied function, but there's no function application there :(
09:00:45 <imphasing> I would expect '(/) 10' to be the way to do that
09:00:49 <benmachine> imphasing: (/10) is equivalent to flip (/) 10, if that makes you happy
09:00:59 <benmachine> (/) 10 also works, but gives you a different function
09:01:02 <rwbarton> (/10) is \x -> (x/10)
09:01:15 <benmachine> imphasing: this is just a syntactic convenience, called an operator section
09:01:16 <rwbarton> and (10/) is \x -> (10/x)
09:01:22 <benmachine> rwbarton is correct
09:01:53 * Eduard_Munteanu just tried to guess the context, might've gotten things wrong
09:02:21 <imphasing> I guess I need to figure out what \x -> foo means
09:02:23 <rwbarton> the context was basically the existence of things like liftA3 and zip7
09:02:25 <imphasing> Looks like a lambda though.
09:02:34 <benmachine> imphasing: looks like, and is
09:03:00 <benmachine> Eduard_Munteanu: HList is relevant but not simple :P
09:03:18 <benmachine> oh there's something else as well
09:03:26 <benmachine> when you have polymorphic functions
09:03:38 <imphasing> Is there a reason why \x -> (x/10) != (/) 10 ?
09:04:09 <benmachine> imphasing: because (/) 10 gives the first argument to (/) and waits for the second
09:04:19 <benmachine> it is the same as \x -> (10/x)
09:04:33 <applicative> > (^) 2 5
09:04:34 <lambdabot>   32
09:04:41 <benmachine> anyway I was talking about polymorphic functions
09:04:49 <applicative> > (2^) 5
09:04:50 <lambdabot>   32
09:04:57 <benmachine> another limitation (of sorts) of haskell's type system is
09:05:22 <benmachine> ok so say I have a tuple (3,5), and I want to apply (div 60) to both parts
09:05:32 <benmachine> > join (***) (div 60) (3,5)
09:05:33 <lambdabot>   (20,12)
09:05:36 <benmachine> no problem
09:05:49 <benmachine> but now suppose I have (3,'x'), and I want to apply show to both parts
09:05:56 <benmachine> > join (***) show (3,'x')
09:05:57 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
09:05:57 <lambdabot>    arising from the literal `3...
09:06:00 <benmachine> it doesn't work
09:07:24 <benmachine> I have to write show twice to use it at two types
09:07:32 <imphasing> Weird..
09:07:42 <imphasing> Even though they are both Show, right?
09:07:51 <imphasing> Num and Char should both be Show..
09:07:56 <benmachine> they are both show
09:08:17 <benmachine> the reason for this is complicated, and I meant it for b_jonas not you :P
09:08:28 <benmachine> or rwbarton or whoever I was talking to
09:08:47 <benmachine> but basically it's because I'm passing 'show' to another function, it loses its polymorphism
09:08:58 <imphasing> I'm just trying to follow along :)
09:09:20 <benmachine> sure but you shouldn't worry about niche cases when you're learning :P
09:13:57 <dolio> @type join (***)
09:13:58 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
09:18:35 <imphasing> Hmm... it seems like by doing (`elem` ['A'..'Z']) you're partially evaluating only the second argument.. is this possible to do without a section? Is there a way I can apply only the 2nd, 4rd or whatever argument to a function instead of just the first?
09:19:08 <applicative> what is lambdabot importing that it gets that type for join (***)
09:19:27 <applicative> i guess its just a Monad instance for (->) a
09:20:22 <imphasing> s/partially evaluating/partially applying/
09:21:11 <imphasing> I guess the magic is in the section, where (`elem` ['A'..'Z']) creates a lambda that can be partially applied again?
09:21:40 <tac-tics> @type (`elem` ['A'..'Z'])
09:21:40 <lambdabot> Char -> Bool
09:21:42 <tac-tics> yup
09:21:52 <tac-tics> It's not a "lambda" script, but yeah, it's a function
09:22:04 <tac-tics> err
09:22:06 <tac-tics> strictly*
09:22:07 <tac-tics> not script
09:22:32 <imphasing> How can I partially apply that function without a section though? Say I want to do something like 'elem _ ['A'..'Z']'
09:22:47 <imphasing> Pretend the _ is me ignoring an argument
09:22:56 <imphasing> I guess I have to flip the function first, then partially apply it
09:23:08 <Guest92470> flip elem ['A' .. 'Z']
09:23:12 <imphasing> `flip elem ['A'..'Z']` maybe
09:23:13 <imphasing> oooo
09:23:16 <imphasing> Yay :)
09:23:18 <imphasing> I get it, thanks :D
09:24:14 <applicative> ah, the instance Monad ((->) a) is in the memorable  Control.Monad.Instances, where else?
09:25:13 <imphasing> You guys are going to ruin me, now I'm going to be trying to write crappy software in haskell for reals :P
09:25:20 <imphasing> The type system is just so awesome, I can barely stand it.
09:29:33 <tac-tics> imphasing: Why do you think the type system is awesome? Out of curiosity?
09:29:49 <Eduard_Munteanu> Mind there's other stuff that will blow your mind even more :P
09:30:08 <tac-tics> *cough*dependenttypes*cough*
09:30:09 <imphasing> It let's me do things with types that I would have to accomplish with regular code in another language, pretty much
09:30:16 <Eduard_Munteanu> Yeah ^^ :)
09:30:16 <imphasing> So much logic seems like it can and should be defined in types
09:30:22 <jacobian> haha, yeah, I was just going to say
09:30:37 <jacobian> dependent types gets you logic for real
09:31:31 <tac-tics> Personally, I think they should start off teaching untyped LC, then Simply Typed LC, then dependent types
09:31:38 <tac-tics> Then work their way back to the practical stuff
09:32:04 * imphasing started programming PHP because it was fun, dunno if untpyed LC would be as fun to learn
09:32:23 <jacobian> yeah, I started by writing RPGs in basic
09:32:39 <jacobian> haskell is higher order fun
09:33:53 <tac-tics> Untyped is just Lisp
09:33:56 <tac-tics> more or less
09:34:12 <jacobian> I like agda a lot but I wish it had tactics and the ability to mix and match between tactics and terms with holes the way Coq does.
09:34:22 <imphasing> define and lambda are all you need to get LC in scheme pretty much :)
09:34:40 <Eduard_Munteanu> jacobian: it has tactics... well, one so far.
09:35:10 <imphasing> I've been considering adding a type system to my scheme interpreter.. I think learning haskell will help me a lot there
09:35:11 <Eduard_Munteanu> jacobian: somebody recently got the ring solver to work with reflection
09:35:36 <Eduard_Munteanu> The resulting proofs are rather long, but still.
09:36:07 <Eduard_Munteanu> Besides, there's Auto/Agsy, if that counts as tactics.
09:36:26 <jacobian> never used them
09:36:30 <tac-tics> imphasing: The Simply Typed LC would help you understand the gist of adding types of an untyped Scheme
09:36:44 <Eduard_Munteanu> C-c C-a I mean.
09:36:50 <Eduard_Munteanu> jacobian: btw, there's #agda :P
09:36:50 <jacobian> That's cool
09:38:36 <jacobian> I'm going to go play with auto now :)
09:38:40 <imphasing> hmm... can haskell be used as a proof assistant without much trouble? It has depandant types..
09:38:55 <tac-tics> imphasing: Haskell does not have depdendent types
09:38:58 <imphasing> As in, would anyone
09:38:59 <imphasing> Oh..
09:39:18 <tac-tics> Dependent types are more powerful than Haskell's type system
09:39:34 <Eduard_Munteanu> There some *fake* dependent types tricks, but that doesn't count as DT.
09:39:40 <imphasing> Ah, I see it's possible to simulate it
09:39:40 <Eduard_Munteanu> *There's
09:39:58 <Eduard_Munteanu> Not really, just for some limited use cases.
09:40:11 <imphasing> There's Ivor I guess :D
09:40:26 <Eduard_Munteanu> Besides, Haskell is inconsistent.
09:40:31 <tac-tics> Ivor is nice an minimal
09:40:36 <Eduard_Munteanu> imphasing: there's Agda :P
09:40:49 <tac-tics> I emailed the creator of Ivor, though, and he said he's using Ivor mostly for Idris's backend
09:40:56 <tac-tics> So Ivor isn't really guaranteed to be stable
09:41:00 <jacobian> It would be nice to be able to mix consistency and inconsistency
09:41:02 <imphasing> I'll probably try to tackle one of these proof assistant languages sometime.. they seem really cool :)
09:41:14 <hpc> jacobian: haskell and coq can call each other i think
09:41:27 <jacobian> I've used coq and extracted to haskell
09:41:31 <jacobian> That's actually what I do currently
09:41:42 <Eduard_Munteanu> Agda actually aims to be a useful DT programming language, besides being a theorem prover.
09:42:02 <jacobian> But it would be nice if the type system could some how firewall the inconsistent sections from the consistent sections in a way that was comprehensible from the type.
09:42:10 <Eduard_Munteanu> (it can FFI to Haskell and C already)
09:42:20 <tac-tics> jacobian: That's actually not too difficult to do
09:42:30 <tac-tics> The hard part is finding a system where it's useful and the two words "play nice"
09:43:16 <tac-tics> You can define two kinds of function constructors a pure -> which always terminates and a fixable -> where it's not guaranteed
09:44:00 <tac-tics> In the former, you HAVE to use structural recursion to define functions and all functions terminate, and in the latter, you can use fix :: (r->r)->r to define general recursion, but you lose the termination guarantee
09:44:09 <tac-tics> But then, you can't use impure functions in pure definitions
09:44:21 <tac-tics> Without somehow proving their totality first
09:45:08 <tac-tics> (or asserting it in an axiom)
09:45:22 <tac-tics> (which is effectively what FFI nets you)
09:45:26 <hpc> tac-tics: you could have lift :: (a ~> b) -> a -> b, where (~>) is proof-arrow
09:45:39 <tac-tics> hpc: Yup
09:45:43 <hpc> unsafeFix :: (a -> a) ~> a
09:45:47 <hpc> etc
09:46:23 <hpc> (for when you really can't be arsed to use structural recursion)
09:47:23 <tac-tics> Personally, I think the lack of mutability is a bigger issue than non-termination for making DT (and Haskell) popular / practical in most development contexts
09:47:38 <tac-tics> We live in a world where shit changes
09:48:07 <hpc> tac-tics: nah, or lisp would be more popular
09:48:07 <tac-tics> Monads help, but monads require heavy plumbing
09:48:18 <hpc> it has mutation and dynamic (read: no) types :P
09:48:22 <tac-tics> Lisp is unpopular because of the parens
09:48:25 <tac-tics> Let's not kid ourselves
09:48:32 <hpc> yeah, true
09:48:35 <Eduard_Munteanu> I wouldn't say mutation on the language level is the problem, rather not being able to use immutable data structures and having the compiler turn that into in-place mutation and that sort of stuff.
09:48:40 <tac-tics> But we tell ourselves its the lack of type systems, because we don't want to feel so shallow
09:49:21 <hpc> what gets me is that you have to write out "lambda" entirely
09:49:39 <hpc> more than the mutation, type system, and syntax
09:49:41 <tac-tics> lol
09:49:46 <Eduard_Munteanu> There are still lots of performance gains to be had from using stuff like ST or IO, over similar algorithms that use immutable data.
09:49:47 <hpc> it's how many strokes it is to make a damn lambda
09:50:04 <tac-tics> Eduard_Munteanu: I'm sure you've seen DDC, yeah?
09:50:05 <Eduard_Munteanu> hpc: in agda-mode? :)
09:50:15 <hpc> Eduard_Munteanu: CL in vim
09:50:17 <Eduard_Munteanu> tac-tics: hrm, doesn't ring a bell
09:50:41 <tac-tics> It's a Haskell offshoot that uses region variables and a type-effect system
09:51:01 <tac-tics> You can write imperative code in it, then mask the imperative part to extract pure functions.
09:51:19 <tac-tics> And there's type-class based mutability constraints
09:51:40 <tac-tics> The type system is a little heavy, but you can do some really awesome things in it
09:52:16 <Eduard_Munteanu> tac-tics: what does it stand for?
09:52:49 <tac-tics> http://disciple.ouroborus.net/
09:52:51 <Eduard_Munteanu> There's Clean, with it's uniqueness typing system.
09:52:55 <tac-tics> Disciplined Disciple Compiler
09:53:04 <Eduard_Munteanu> Oh, I've heard about that.
09:53:17 <cheater> disciple, yeah, heard of it at least once.
09:53:20 <tac-tics> Being able to use real mutable arrays is kinda cool
09:53:49 <Eduard_Munteanu> Well, STUArrays are pretty much real mutable arrays anyway.
09:53:53 * hackagebot composition 0.1 - Combinators for unorthodox function composition  http://hackage.haskell.org/package/composition-0.1 (DanBurton)
09:54:25 <hpc> i wish it would haddock without waiting for a build
09:54:36 <tac-tics> Eduard_Munteanu: Yeah, but you have to generate them in the IO monad, don't you? :)
09:54:37 <hpc> don't want to download the tarball
09:54:44 <Eduard_Munteanu> What I'm saying is the problem's when you avoid using those mutable structures.
09:54:49 <Eduard_Munteanu> Then you hit a performance brickwall.
09:55:07 <tac-tics> In DDC, you can have real life globals that sit around doing what you want: being a place to store your dirty, dirty singleton values
09:55:20 <Eduard_Munteanu> tac-tics: no, you can just runSTUArray, build it inside that computation, and get back an immutable array.
09:55:30 <Eduard_Munteanu> (which isn't in ST)
09:56:03 <tac-tics> Eduard_Munteanu: Well, one use case that's hard in Haskell
09:56:18 <tac-tics> Is having a mutable data structure that is used to channel data to distant parts of the code
09:56:30 <tac-tics> And DDC does a pretty good job with that
09:57:39 <tac-tics> You end up with a function which is mostly pure. Pure except that it reads from a region
09:58:04 <JoeyA> In Attoparsec, how do I override a parser's error message?
09:58:05 <tac-tics> It basically lets you annotate functions with "how impure" they are
09:58:07 <JoeyA> > parseOnly (double <?> "Oh noes") "hello"
09:58:08 <lambdabot>   Not in scope: `parseOnly'Not in scope: `<?>'
09:58:15 <JoeyA>  Left "Failed reading: takeWhile1"
09:58:44 <JoeyA> I tried doing it this way: parseOnly (try double <|> (empty <?> "Oh noes")) "hello"  But that produces Left "Failed reading: empty".
09:58:59 <hpc> JoeyA: you might do it with
09:59:08 <hpc> fail "error message" <|> parser
09:59:12 <hpc> er
09:59:21 <hpc> reverse that i think
10:00:07 <JoeyA> hpc: Thanks, that worked:  parseOnly (double <|> fail "By the monads!") "hello"
10:00:45 <hpc> it probably works the other way too; applicative monoid, etc
10:01:47 <JoeyA> parseOnly (fail "By the monads!" <|> try double) "hello"  -- doesn't work
10:02:12 <hpc> ah, k
10:03:02 <JoeyA> I wonder if (Atto)Parsec violate the monad/applicative/etc. laws by not rewinding on failure by default.
10:03:23 <hpc> too bad, because you could do some awesome stuff with do-notation if fail behaved like mempty
10:03:44 <mm_freak_> JoeyA: no, they don't, unless state monads also violate them
10:03:46 <engla> how do I make a function like fix but taking a start value? I.e. iterate until a fixpoint is reached
10:04:24 <mm_freak_> engla: the fixed point is reached immediately…  are you trying to perform recursion using 'fix'?
10:04:37 <hpc> fix' start end f | end start = start; | otherwise = fix' (f start) end f
10:04:57 <hpc> would be fixed-point iteration up to a stop condition
10:05:32 <imphasing> Shouldn't flip be of type 'flip :: (a -> b -> c) -> (b -> a -> c)'? when I do :t flip I get 'flip :: (a -> b -> c) -> b -> a -> c' ...
10:05:44 <hpc> imphasing: it's curried
10:05:45 <imphasing> Oh... it's returning a higher order function, which I guess is curried
10:05:49 <imphasing> Ah, ok
10:05:56 <mm_freak_> imphasing: that's the same, because (->) is right-associative
10:06:09 <hpc> imphasing: for extra fun, figure out how this works:
10:06:10 <hpc> :t flip
10:06:11 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:06:17 <imphasing> lol
10:06:21 <hpc> > flip [succ, pred] 5
10:06:22 <lambdabot>   [6,4]
10:06:27 <engla> hpc: ok something like that maybe, I can't quite read it
10:06:46 <hpc> engla: put it on two lines and it will make sense
10:07:14 <sbrg> hpc: wut
10:07:20 <imphasing> I was getting confused because to specify a HOF as an argument, it needs to be in parens.. but I guess the return value doesn't matter, it can be curried
10:07:52 <hpc> imphasing: yeah; right-associative means that x -> y -> z == x -> (y -> z)
10:08:06 <mm_freak_> > let gcd = fix (\r x y -> if y == 0 then x else r y (mod x y)) in gcd 12 15
10:08:07 <lambdabot>   3
10:08:10 <mm_freak_> @ engla
10:08:15 <hpc> imphasing: this will become relevant again when you learn folds
10:08:42 <imphasing> Right, but for a HOF in a type declaration, like 'flip :: (a -> b -> c)' the HOF is in parens.. I guess the return value is different though
10:08:53 <mm_freak_> engla: but honestly, fix is only convenient for infinite recursion
10:09:04 <rwbarton> I get the same result with fail "By the monads!" on either side of <|>, and with or without try
10:09:07 <mm_freak_> for finite recursion, better use explicit recursion
10:09:46 <mm_freak_> JoeyA: the correct pattern is:  try a <|> b
10:10:01 <hpc> even for infinite recursion, ones = 1:ones is nicer than ones = fix (1:)
10:10:02 <hpc> imo
10:10:05 <mm_freak_> JoeyA: (<|>) only tries the alternative, if the first parser didn't consume
10:10:06 <parcs> mm_freak_: why?
10:10:24 <rwbarton> :t let f :: (a ~ [a]) => a -> a; f x = [x] in f
10:10:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
10:10:25 <lambdabot>       Expected type: [a]
10:10:25 <lambdabot>       Inferred type: a
10:10:25 <engla> mm_freak_: I'm trying to find a fixpoint, it's not for infinite recursion
10:10:29 <mm_freak_> that's true for at least parsec and attoparsec
10:10:53 <parcs> anonymous recursion is useful, naming is hard
10:10:54 <mm_freak_> engla: 'fix f' /is/ the least defined fixed point of f
10:11:07 <mm_freak_> engla: it doesn't help you with fixed point values, if that's what you're looking for
10:11:09 <hpc> mm_freak_: i think he means numerical fixed points
10:11:10 <engla> mm_freak_: imagine the function safeTail [] = [], safeTail xs = tail xs;     findfix safeTail "hi there"  is ""   because "" is a fix point when starting at "hi there"
10:11:12 <mm_freak_> parcs: why what?
10:11:35 <mm_freak_> engla: then 'fix' is not what you're looking for
10:11:39 <engla> mm_freak_: I'm looking at expanding a graph of all forced matches, until no more forced matches can be added. that's the fixpoint.
10:12:00 <engla> mm_freak_: I never said I looked for fix, I was talking about how I define this function I need, something like fix
10:12:19 <mm_freak_> oh, sorry…  depends, what type should your function have?
10:12:30 <mm_freak_> your fixed point finder that is
10:12:31 <engla> (a -> a) -> a -> a   I think
10:12:41 <mm_freak_> that's impossible
10:12:42 <engla> why?
10:12:44 <monochrom> engla: find f x0 = if f x0 == x0 then x0 else find f (f x0)
10:13:03 <mm_freak_> engla: you need at least enumeration and some notion of equality
10:13:09 <monochrom> and it is not "like" fix
10:13:12 <engla> ah yes, Eq a
10:13:23 <mm_freak_> (Bounded a, Enum a, Eq a) => (a -> a) -> a
10:13:24 <engla> monochrom: maybe not
10:13:31 <hpc> it's only like fix in the sense that they are both recursive
10:13:34 <engla> mm_freak_: bounded? it's not about numbers
10:13:58 <mm_freak_> engla: you still need to search the space of possible values
10:14:09 <engla> find :: Eq a => (a -> a) -> a -> a   sounds good
10:14:17 <engla> mm_freak_: it doesn't search, it iterates from the start value
10:14:26 <rwbarton> mm_freak_: there is a starting value for the search
10:14:30 <mm_freak_> engla: your type signature doesn't allow iteration
10:14:35 <engla> monochrom: thanks for understanding what I meant
10:14:50 <mm_freak_> you need some way to try "the next" value
10:14:54 <engla> mm_freak_: please elaborate, (a -> a) sounds perfect for iteration
10:15:21 <mm_freak_> engla: a -> a is perfect for iteration, if it iterates the whole space, yes
10:15:44 <rwbarton> in many applications one knows that if x is not a fixed point, f x is "closer" to being one than x was
10:15:53 <rwbarton> presumably engla has such an application in mind
10:16:00 <mm_freak_> btw, for that pattern there is 'iterate'
10:16:03 <mm_freak_> > iterate succ 1
10:16:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:16:07 <monochrom> generally, "I want YYY like XXX" is the best way to miscommunicate
10:16:33 <mike-burns> But also maps closely to how we think.
10:16:51 <monochrom> no, maps closely to how people misthink
10:16:58 <mm_freak_> engla: in general, finding fixed points in the sense you want them needs a special purpose algorithm
10:16:58 <engla> mm_freak_: the application is expanding a graph of vertices with forced neighbor matches (forced by the rules), and it will always eventually come to a point where all forced matches are filled in
10:17:10 <monochrom> "I want YYY" is accurate and sufficient
10:17:17 <engla> mm_freak_: in haskell we use abstractions. the algorithm is inside (a-> a)
10:18:02 <engla> monochrom: thanks again
10:19:59 * DukeDave just asked about something in #bash
10:20:18 <DukeDave> I forgot what 'normal' programmer channels are like out there :|
10:20:45 <hpc> DukeDave: visit #python sometime, and you will never want to remember again
10:21:10 <imphasing> ##php is hilarious from time to time :)
10:21:16 <imphasing> Or all the time.
10:21:20 <DukeDave> hpc: I can only imagine, it's war out there isn't it! What makes us so soft and cuddly?
10:21:25 <herself> I joined python around the same time I got in here
10:21:35 <rwbarton> must be the monads
10:21:42 <herself> rwbarton: o/
10:21:57 <hpc> DukeDave: as i understand it, the learning curve is sufficiently steep/tall here that everyone feels like a newbie in one way or another
10:22:08 <monochrom> I was in #python for a while. not bad. I especially like that fact that they have a bot for copying pastebin.com pastes to a better pastebin, too.
10:22:18 <rwbarton> herself: funny how much overlap there is between the channels I'm in
10:22:19 <hpc> monochrom: we have one too
10:22:23 <hpc> it's called mauke :P
10:22:39 <monochrom> yes, I am delighted that great minds think alike
10:23:13 <herself> rwbarton: yeah, I noticed that too
10:24:37 <herself> good night!
10:24:39 <herself> o/
10:35:12 <tromp> i visited #python to discuss a  python program consisting of nothing but lambdas
10:35:35 <tac-tics> tromp: Why? Pythoners don't believe in lambdas
10:36:06 <tromp> mostly for amusement. some pythoners are quite fond of lambda
10:36:12 <hpc> only anonymous functions :P
10:36:19 <Eduard_Munteanu> Pythoners seem a bit cold-blooded :P
10:36:20 <hpc> what's the point of verbs if you can't noun them
10:36:57 <int-e> tromp: I imagine it computed primes?
10:37:05 <monochrom> yeah, talk the talk, then walk the walk, then program the program, and test the test
10:37:29 <tromp> yes, the primes i ported from lambda calculus
10:38:13 <tromp> it looks better in python than in perl
10:38:19 <monochrom> in ancient Chinese, many nouns could be verbs too. example: Confuscius wifed his daughter to one of his student
10:38:32 <copumpkin> shi shi shi shi shi shi shi shi shi shi shi shi shi shi
10:38:42 <monochrom> err, Confucius
10:39:00 <mm_freak_> i visited #python too for a program almost only of lambdas…  interestingly some people, although pointing out that what i was doing was stupid, helped me with my problem
10:39:12 <copumpkin> monochrom: you come across http://en.wikipedia.org/wiki/Lion-Eating_Poet_in_the_Stone_Den ?
10:39:23 <monochrom> no
10:39:39 <copumpkin> the recording of it is pretty good
10:39:48 <monochrom> hehe
10:51:16 <incluye> @pl \a b -> a !! b
10:51:16 <lambdabot> (!!)
10:51:57 <incluye> @pl \a b -> b !! a
10:51:57 <lambdabot> flip (!!)
11:10:57 <obiwahn> is there some kind of lexing lib for haskell?
11:11:13 <copumpkin> alex
11:11:17 <copumpkin> that's a generator though
11:14:23 <parcs> trifecta does tokenizing
11:14:52 * copumpkin wrote some simple code to price options in haskell yesterday
11:15:00 <copumpkin> tonight I shall make it bettar
11:22:37 <TNA-MichaelK> copumpkin: Cool, is that for work or just you playing with code?
11:22:47 <copumpkin> just for fun
11:25:02 <elliott> how do you write tail with foldr again?
11:25:17 <tsuraan_> if I have a record with { x :: ![a] }, that only forces evaluation of the first cons element of the list, and not the entire list, right?
11:25:18 <copumpkin> annoyingly
11:25:23 <copumpkin> yeah
11:25:23 <elliott> annoyingly is fine
11:25:47 <elliott> or was that to tsuraan_
11:26:04 <TNA-MichaelK> copumpkin: good to hear, that's why I do most things...
11:26:54 <dmwit> :t foldr
11:26:55 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:27:48 <dmwit> > foldr (\x (xs, tail) -> (x:xs, xs)) ([], []) [1..5]
11:27:49 <lambdabot>   ([1,2,3,4,5],[2,3,4,5])
11:28:34 <imphasing> elliott: why do you need to use foldr? wouldn't pattern matching be simpler?
11:29:00 <dmwit> imphasing: Well, foldr is what you get for free from the definition of lists in System F... perhaps he's programming in System F. =P
11:29:26 <imphasing> System F.. sounds scary :O
11:29:40 <dmwit> Well, it's what you get from the Church encoding of lists. No matter what system you're in.
11:29:42 <elliott> thanks dmwit... I swear there was a simpler way though
11:31:49 <jacobian> System F isn't particularly scary
11:32:52 <jacobian> foldr is nice because if your input is (co)data and your function is total, your output is (co)data.
11:33:23 <copumpkin> your input is always codata!
11:33:32 <dmwit> Speak for yourself!
11:33:56 <jacobian> Sometimes my input is data :)
11:33:58 * hackagebot chan-split 0.3.0 - Concurrent Chans as read/write pairs. Also provides generic  Chan pair class.  http://hackage.haskell.org/package/chan-split-0.3.0 (BrandonSimmons)
11:33:59 <imphasing> Oh, I never really thought of how to church encode lists..
11:34:18 <jacobian> Forall A . A -> (A -> A) -> A
11:34:22 <jacobian> oops
11:34:46 <jacobian> Forall B. Forall A. A -> (B -> A -> A) -> A
11:34:58 <jacobian> first one is nats
11:35:59 <mah_b> hi, how can i parse a text file containing a line of integers separated by spaces? (Path -> IO [Int])
11:36:28 <comonad> mah b: Do you prefer lazy IO or enumeratee/iteratee
11:36:39 <comonad> since the solutions will be different depending on that
11:36:49 <jacobian> The first A is a nil, the second (B -> A -> A) is a cons
11:37:27 <Saizan> B is more free than universally quantified, it should be List = \ B -> Forall A. A -> (B -> A -> A) -> A if your specific type system allows lambdas there
11:37:41 <TNA-MichaelK> So, fst, is a polymorphic function because it can simply work on any type?
11:37:53 <jacobian> good point
11:38:18 <mah_b> I believe I prefer lazy IO (btw the list is very short (<100), so I don't really care about footprint), though I'm rather new to all this concepts
11:38:37 <TNA-MichaelK> jacobian: Nice user name
11:39:00 <Watermind> This really surprised me... I'm supposed to teach some tutorials on propositional logic, and the notes say   that  -> associates to the right, i.e.  p -> q -> r   means  (p -> q) -> r
11:39:00 <jacobian> :t fst
11:39:01 <lambdabot> forall a b. (a, b) -> a
11:39:04 <Watermind> is this usual?
11:39:24 <Eduard_Munteanu> Watermind: it's the other way around
11:39:38 <Eduard_Munteanu> p -> q -> r  parses as   p -> (q -> r)
11:39:45 <koeien> Cale: are you still maintaining the fingertree-psqueue package? It doesn't build due to a dependency base<=4. if i change it into base<5 it compiles
11:39:48 <Watermind> Eduard_Munteanu: I know that is the case in Haskell
11:40:07 <Saizan> Watermind: that's what "associates to the right" means
11:40:24 <Watermind> Saizan: waaaait I meant left opss
11:40:35 <Watermind> Saizan: that was me and my right association bias :P
11:40:46 <Watermind> so I expected it to associate to the right
11:40:50 <Watermind> but they have it to the left
11:40:54 <Saizan> that'd be unusual
11:41:01 <Watermind> yeah I thought so too
11:41:05 <Eduard_Munteanu> Associativity to left/right is just a convention after all.
11:41:28 <Watermind> I know therefore me wondering if, in the context of propositional logic it is usually the other way around
11:41:33 <chrisdone> what's that haskell benchmarking library?
11:41:35 <Watermind> or just something this professor decided to do
11:41:41 <Watermind> arbitrarily
11:41:53 <parcs> chrisdone: criterion?
11:42:04 <chrisdone> ah, thanks
11:42:15 <chrisdone> memory failing me in my old age
11:42:43 <Eduard_Munteanu> I guess it might make sense since you can't transpose it to (a, b) -> c, or otherwise transform it in some other way.
11:43:21 <Watermind> Eduard_Munteanu: you can
11:43:34 <Eduard_Munteanu> (p -> q) -> r ?
11:43:37 <Watermind> Eduard_Munteanu: a ^ b -> c
11:43:48 <Watermind> Eduard_Munteanu: err no if it were the other way around...
11:43:56 <Watermind> Eduard_Munteanu: maybe I didn't get what you mean...
11:43:56 <k0ral> hi, what does this "cabal: Can't find transitive deps for haddock" mean when I try to "cabal haddock" my project ?
11:44:04 <Eduard_Munteanu> Ah, yeah.
11:44:19 <DanBurton> Hey guys, I came to blatantly self-advertise my latest SO question which I desperately want answered with the best quality possible. Ready, set, go: http://stackoverflow.com/questions/7490768/what-are-haskells-strictness-points
11:44:20 <TNA-MichaelK> Polymorphic functions can work on any data type, correct?
11:44:20 <Eduard_Munteanu> q^p -> c
11:44:42 <Eduard_Munteanu> TNA-MichaelK: "polymorphic" is relative. Unless constrained, yeah.
11:44:57 <Eduard_Munteanu> :t (+)
11:44:58 <lambdabot> forall a. (Num a) => a -> a -> a
11:45:21 <TNA-MichaelK> Enduard_Munteanu: ahhh so (+) is a polymorphic function too then
11:47:43 <Eduard_Munteanu> TNA-MichaelK: something is _not_ polymorphic when it mentions only concrete types, I'd say.
11:47:56 <jacobian> TNA-MichaelK: Yeah, except there is a constraint on the 'a'.
11:48:13 <TNA-MichaelK> What's the constraint javobian?
11:48:19 <Eduard_Munteanu> Num a
11:48:35 <TNA-MichaelK> Can't you splice strings together with (+)?
11:48:41 <Eduard_Munteanu> That is, whatever a that is, it must be an instance of Num.
11:48:59 <Eduard_Munteanu> :t (Prelude.++)
11:49:00 <lambdabot> forall a. [a] -> [a] -> [a]
11:49:09 <applicative> mah_b: what's wrong with (map read . words)
11:49:37 <TNA-MichaelK> Interesting, thanks
11:49:50 <Eduard_Munteanu> :t mappend
11:49:51 <lambdabot> forall a. (Monoid a) => a -> a -> a
11:50:24 <mah_b> applicative: thank you, my solution would have been longer (recursion over reads). Thank you.
11:51:09 <hpaste_> Fran pasted “Life.hs” at http://hpaste.org/51581
11:51:19 <applicative> mah_b you might need to specify the type of read, of course.  This is just the standard Prelude sort of way.
11:52:01 <franny> Hey, folks, I'm having trouble with the above paste. It's giving me the error "Functional dependencies conflict between instance declarations:"
11:52:48 <franny> (on LifeCell)
11:53:32 <franny> I'm sure I'm doing something wrong; would anyone be able to spot what? :)
11:54:00 <monochrom> must you use type classes?
11:55:26 <franny> monochrom, they're pretty fundamental to my design in this case.
11:55:59 <monochrom> well, I don't know about TriangularCell, HypercubicCell, and all that, so no comment.
11:57:21 <hpaste_> Fran pasted “Life.hs errors” at http://hpaste.org/51582
11:57:33 <ozataman> anyone around with experience using the vector package?
11:57:33 <franny> That's the exact error I'm getting ^
11:57:59 <mm_freak_> ozataman: sure, just ask
11:58:06 <JoeyA> Does <?> in Attoparsec actually do anything?
11:58:23 <hpc> JoeyA: use the source, luke
11:58:33 <ozataman> mm_freak_: thanks. do extracted elements from a vector? maintain references to the vector?
11:58:35 <mm_freak_> JoeyA: yes, it does
11:58:41 <hpaste_> Fran pasted “CellularAutomaton.hs” at http://hpaste.org/51583
11:58:49 * monochrom hates "use the source"
11:59:04 <rwbarton> peruse the source
11:59:06 <hpaste_> Fran pasted “Triangle.hs” at http://hpaste.org/51584
11:59:06 <mm_freak_> ozataman: for unboxed vectors, no, for regular vectors that really depends on the element
11:59:29 <franny> And those two pastes have the definitions of "HypercubicCell" and "TriangularCell".
11:59:30 <ozataman> I have an application where I use a vector of unboxed vectors and create several smaller chunks from the larger chunks over time
11:59:47 <ozataman> I get what seems like a memory leak of FROZEN_ARRAY_POINTERS
11:59:51 <JoeyA> mm_freak_: Most of the parsers have their own error wrapper, overriding mine:  parseOnly (word8 98 <?> "my error") "a"   Left "Failed reading: satisfy"
11:59:54 <ozataman> when profiling under -hy
12:00:21 <JoeyA> I'm trying to figure out when I can use <?> rather than having to do something awkward with try, <|>, and fail
12:00:29 <ozataman> I checked and checked; it really doesn'y look like older vectors need to be kept around
12:00:56 <mm_freak_> ozataman: if you take a splice of a vector, the whole vector is retained in memory
12:00:59 <ozataman> this is what keeps getting retained: MUT_ARR_PTRS_FROZEN
12:01:13 <mm_freak_> ozataman: if you want to take a splice and forget the rest, use the 'force' function
12:01:44 <ozataman> mm_freak_: hmm, that might just be what I need. let me give it a try
12:02:27 <franny> Basically, I want "lifeRule" to accept (an array|a map) of (Integral|an n-tuple of Integrals|a list of Integrals|Triangle) to Bool.
12:02:30 <mm_freak_> JoeyA: of course an outer (<?>) may replace your message
12:03:07 <JoeyA> Oh, I see.  Result returns a list of contexts.
12:03:20 <JoeyA> Thanks
12:03:56 <mm_freak_> ozataman: note that there is a tradeoff…  you can take as many splices as you want without any extra memory except the reference
12:04:28 <mm_freak_> also try to write your vector code in a way, which allows fusion, as far as that's possible in your algorithm
12:05:05 <ozataman> I basically have a dynamic algorithm where a function gets recursively called with sub-slices of an initial vector
12:05:17 <ozataman> would backpermute retain the previous vector?
12:06:26 <franny> Given all that, would anyone know why my functional dependencies are conflicting?
12:06:29 <mm_freak_> it wouldn't, but are you operating on those slices in a way, which produces new vectors?
12:07:42 <Cale> franny: You say that i -> n in the class declaration
12:07:49 <JoeyA> I wish Attoparsec had a variant of fail that didn't prepend "Failed reading: "
12:07:50 <ozataman> well, I have several operations that likely create new vectors.. I sort, them, extract elements from inner vectors into new vectors, etc.
12:07:55 <Cale> franny: But then you define more than one n for a given i
12:08:05 <ozataman> backpermute essentially shuffles the initial dataset for each run of the algo
12:08:39 <Cale> franny: In particular, you have instances  LifeCell Ordering i  (guaranteed to conflict with everything), and then  LifeCell [Int] i
12:08:52 <Cale> (also guaranteed to conflict with any other instance)
12:09:00 <mm_freak_> ozataman: can't you write your algorithm with lazy vectors somehow?  instead of wrapping a destructive algorithm around your vector, you can wrap your vector around a constructive algorithm
12:09:24 <Cale> and then LifeCell TriangularNeighbor TriangularCell, which conflicts with the other two if i = TriangularCell
12:10:13 <mm_freak_> ozataman: in other words, try to express your final vector in terms of 'generate'
12:10:20 <imphasing> Man, polymorphic types are so much cooler than my C# generics :(
12:10:24 <franny> Cale: Hmm. I only want the first to apply if i is an Integral, though; TriangularCell and anything in class HypercubicCell aren't going to be Integral.
12:10:43 <Cale> franny: Note that the compiler is not allowed to assume that TriangularCell isn't an instance of Integral, because it could always be defined as an instance of Integral in a future module.
12:10:52 <franny> Oh, I see.
12:11:16 <mamalujo> imphasing: I haven't tried C# - but thought generics were supposed to be analogous to parametric polymorphism ala haskell/ml etc?
12:11:35 <imphasing> mamalujo: Basically, but the type system in haskell lets you do so much more :O
12:11:41 <mamalujo> ah
12:11:43 <franny> Cale: is there a proper way to get the effect I'm looking for (be able to accept any of the three, somehow)?
12:11:55 <ozataman> mm_freak_: I'll need to think about this a little bit. the final result is not even a vector; it's a custom data structure. I use vectors because I need efficient indexing to elements. I really need the full dataset in memory and sort it with respect to different elements over time, sub-select parts and repeat many times
12:11:57 <Cale> For the purposes of determining which instance applies in any given situation, the compiler ignores the class context and only looks at the structure of the types. Then, once a unique instance is found and selected, it ensures that the class constraints are satisfied.
12:11:58 <nooodl> i was reading http://www.haskell.org/haskellwiki/Show_instance_for_functions looking for an answer to the "How can lambdabot display this:" question
12:12:01 <nooodl> it never got answered :(
12:12:15 <Cale> nooodl: Sorry, what was your question?
12:12:19 <Cale> franny: hmm
12:12:32 <mm_freak_> mamalujo: one thing C#'s generics (or .NET's in general) can't do is, i don't know what to call it, but let me call it higher order polymorphism
12:12:42 <mm_freak_> it can't be polymorphic on types of kind * -> *
12:13:04 <mamalujo> aha, I see
12:13:10 <TNA-MichaelK> Why do you guys use Haskell?
12:13:12 <nooodl> Cale, lambdabot displays functions as "<Char -> Int>"
12:13:20 <mm_freak_> TNA-MichaelK: fun and money
12:13:21 <nooodl> i want ghci to do that, too
12:13:22 <Cale> nooodl: sure
12:13:57 <mm_freak_> ozataman: i see…  well, try the 'force' thing
12:13:59 <TNA-MichaelK> mm_freak_: what sorts of tasks?  money how?
12:14:08 <ozataman> mm_freak_: giving it a try now
12:14:08 <Cale> nooodl: instance (Typeable (a -> b)) => Show (a -> b) where show f = concat ["<", show (typeOf f), ">"]
12:14:24 <mm_freak_> TNA-MichaelK: mainly network applications
12:15:40 <monochrom> preflex: seen TNA-MichaelK
12:15:40 <preflex>  TNA-MichaelK was last seen on #haskell 1 minute and 41 seconds ago, saying: mm_freak_: what sorts of tasks?  money how?
12:15:51 <monochrom> nevermind
12:16:03 <franny> The easy way out would be to just limit lifeRule to handle n-cubic Game of Life universes, but I was hoping to be able to support triangular, hexagonal, etc. ones too.
12:16:33 <Cale> nooodl: something like that, anyway... I think there's a package on Hackage which has show instances for various things
12:16:49 <TNA-MichaelK> monochrom: I was asking what particular uses you guys had with this language, it seems very strange.
12:17:22 <Cale> TNA-MichaelK: I'm working for a company writing an action RPG for iPhones and other mobile devices in Haskell.
12:17:47 <mm_freak_> well, i found haskell to be very suitable for networking and web applications…  i'm using it productively for pushing mails around
12:17:51 <tac-tics> Cale: Isn't that against the iPhone dev EULA?
12:17:55 <copumpkin> no
12:17:57 <Cale> tac-tics: no
12:18:06 <Cale> TNA-MichaelK: It looks strange, but it's really a programming language like any other general purpose language. You can safely use it to get things done :)
12:18:23 <copumpkin> although I generally try to avoid getting things done
12:18:23 <Cale> Only, it's more fun.
12:18:25 * copumpkin shudders
12:19:09 <JoeyA> attoparsec doesn't export Data.Attoparsec.Internal.Types .  Is there a way to beat the system and access it?
12:19:34 <copumpkin> JoeyA: you can bug bos
12:19:41 <mm_freak_> JoeyA: fork attoparsec, but why would you want to?  what are you going to do?
12:19:50 <TNA-MichaelK> Cale: Thanks, so there are libraries for doing GUI stuff for your game then?  Or, are you creating your own libraries and creating the 3D environment via Linear Algebra type transformations?
12:20:08 <copumpkin> linear algebra is too elementary for Cale
12:20:14 <copumpkin> he uses braided monoidal categories for his games
12:20:34 <Cale> TNA-MichaelK: For the desktop version we're using for testing, we're just using OpenGL.
12:20:40 <JoeyA> mm_freak_: fail appends "Failed reading: " to every error message.  I'm trying to write a variant that doesn't.
12:20:56 <mm_freak_> JoeyA: or just don't use fail
12:21:02 <JoeyA> In my particular case, I'm running a Parser once per line, and using the fail message as error messages the user can optionally see.
12:21:25 <mm_freak_> there is (<?>) for errors with context
12:21:41 <JoeyA> Rather than errors like "Failed reading: satisfy", I want to put my own description.
12:22:02 <Cale> TNA-MichaelK: For the iPhone itself, we have a little bit of C++ code (which doesn't have GC to worry about) that does OpenGL ES stuff, and our Haskell program sends it descriptions of what animations to draw, etc.
12:22:04 <mm_freak_> yes, there is (<?>) for that =)
12:22:26 <Cale> It's easier on a desktop machine because you don't have to worry about the GC eating up too much time.
12:23:28 <TNA-MichaelK> GC is what?
12:23:29 <JoeyA> I guess I'll just do that, and use the head of the error context list as my error message.
12:23:32 <Cale> Garbage collector
12:23:49 <JoeyA> But for my case, parser <??> errmsg = parser <|> Parser (\i0 a0 m0 kf _ks -> kf i0 a0 m0 [] errmsg) would be a whole lot easier...
12:24:09 <TNA-MichaelK> ah, I've only heard of GC in Java... I guess all languages have them though?
12:24:18 <Cale> Yeah, pretty much all high level languages
12:24:20 <tac-tics> TNA-MichaelK: Most good ones.
12:24:29 <tac-tics> TNA-MichaelK: C and C++ don't, for example
12:24:47 <TNA-MichaelK> I'm most familiar with C, then some web languages
12:24:47 <tac-tics> TNA-MichaelK: Functional programming languages do, virtually universally
12:24:55 <JoeyA> Instead, I have to replicate parseOnly's functionality
12:25:27 <tac-tics> TNA-MichaelK: the GC's job is to figure out which objects need to be free()'d and to free() them for you
12:25:28 <TNA-MichaelK> Cale: Is making a game in Haskell harder than C would you say?
12:25:31 <mm_freak_> JoeyA: attoparsec is really for high speed parsing of byte streams…  if you want something more flexible and easier to use, consider using parsec instead
12:25:52 <JoeyA> mm_freak_: But I need speed.  I don't need a whole lot of flexibility, just the ability to fail with my own error message.
12:25:59 <tac-tics> Making a game in Haskell is hard for different reasons than in C :P
12:26:04 <mm_freak_> TNA-MichaelK: haskell is harder to learn that C, but once you know it, making a game in haskell is way easier
12:26:24 <Cale> On a PC, garbage collections are fast enough that you basically won't notice them. On an iPhone though, a major GC (which happens once every few minutes) can take up to around 300ms, which is pretty noticeable if your program freezes for that long. So the little bit of C++ code can continue drawing the animation it was drawing during that time and it smooths over the time where the Haskell program has to collect garbag
12:26:24 <Cale> e.
12:26:49 <Cale> TNA-MichaelK: I'd say it's significantly easier in a lot of ways.
12:27:09 <tac-tics> The actual GAME logic is much easier in Haskell
12:27:13 <TNA-MichaelK> Cale: Ah, that's an interesting work around, cool
12:27:16 <tac-tics> Any sort of logic in C is a pain :/
12:27:26 <tac-tics> But for pushing bits around, C is God
12:27:26 <mm_freak_> tac-tics: everything is easier, even the imperative part of calling OpenGL
12:27:55 <TNA-MichaelK> tac-tics: that is to say C is more efficient? what do you mean for pushing bits around?
12:27:58 <mm_freak_> C is only faster, but almost never easier
12:28:30 <tac-tics> TNA-MichaelK: C is much more direct. In Haskell, it's hard to figure out how your code will be compiled down to assembly
12:28:35 <mm_freak_> TNA-MichaelK: C compilers generally optimize very well at the low level
12:28:35 <tac-tics> In C, it's almost a word-for-word replacement
12:28:47 <mm_freak_> i.e. you get very fast bit operations and number crunching
12:28:56 <Cale> tac-tics: Well, that used to be more true than it is today :P
12:28:57 <TNA-MichaelK> Cale: If you do game building, what did you think of the "Unlimited Detail" search algorithm, do you think it's a sham?
12:29:10 <Cale> TNA-MichaelK: I have no idea, but it looks real.
12:29:23 <Cale> I don't see any reason why it should be a sham.
12:29:28 <tac-tics> Cale: Yeah, but C without optimizations is still relatively Pretty Damn Fast
12:29:49 <mm_freak_> in general, the haskell compiler GHC is smarter than the average C compiler, but when it comes to low level stuff, C compilers will outperform GHC
12:30:13 <TNA-MichaelK> I've had several people tell me that it was fake and prerendered, but it seems sensible that an algorithm could be developed to only render what is seen
12:30:14 <Cale> tac-tics: These days even the assembly doesn't correspond in a particularly obvious way to how the machine is actually running the code though :P
12:31:13 <tac-tics> I honestly haven't written many optimizing C compilers, so I'll trust you Cale :)
12:31:22 <Cale> TNA-MichaelK: There's a video of some game review guys going in for an in-person test to try it out, and they seemed impressed.
12:31:40 <Cale> tac-tics: Well, this is actually after the C compiler has done its job
12:32:19 <mm_freak_> TNA-MichaelK: for a somewhat outdated tech demo of haskell gaming, see the 'frag' game
12:32:35 <Cale> tac-tics: The processor itself will do instruction reordering and pipelining, and executes instructions in parallel in separate parts of the chip
12:32:39 <TNA-MichaelK> Cale: Huh wow, I never saw that video, thanks.  *looking for it*
12:32:42 <tac-tics> Personally, I'm more of a "let it perform like shit, at least I can debug it" sort of guy
12:33:09 <tac-tics> I get flamed for it, but I abhor tail call optimization
12:33:16 <tac-tics> because it kills my stack traces ;(
12:33:35 <Cale> Well, tail call optimisation shouldn't even really exist. The call stack shouldn't exist either :P
12:33:54 <TNA-MichaelK> mm_freak_: tac-tics: So, you'd say that computational research may be best optimized in C but for more difficult things to understand coding it in Haskell may make better logical sense?  I was thinking of using Haskell for coding Calculus of Variations problems...
12:33:55 <tac-tics> Cale: You speak blasphemy to the C developers of the world
12:34:13 <Cale> Tail call optimisation only makes sense if you have that silly stack in your implementation in the first place, but it's totally not required.
12:34:17 <tac-tics> Haskell will be your friend in CoV problems, I'd think
12:34:37 <mm_freak_> TNA-MichaelK: haskell is fine for number crunching, but not for absolute high speed number crunching…  however, you can write the high speed stuff in C and use haskell to put it all together
12:34:49 <TNA-MichaelK> tac-tics: that's what I was thinking, it seems to be very much structured around abstract high level mathematics.
12:35:15 <tac-tics> I imagine CoV is also pretty symbolic
12:35:20 <Cale> TNA-MichaelK: Actually, I'm of the opinion that if you have a task where you really need to get every drop of performance out of your hardware, Haskell is still pretty decent as a metalanguage for writing low-level code.
12:35:21 <tac-tics> C really sucks at symbolic manipulation
12:35:54 <ozataman> mm_freak_: I don't think it is an issue of force. Any chance there is a pointer-related memory leak? MUT_ARR_PTRS_FROZEN s are just keep getting retained even if I force everything. There really is no need for them to be retained. It is true that I generate thousands/millions of vectors, but they should be released in due time...
12:35:56 <TNA-MichaelK> mm_freak_: interesting idea, I guess that makes sense.  It sounds like you guys combine languages like I do with web languages (which I feel is probably much easier)
12:35:56 <mm_freak_> Cale: not always…  haskell is hard to translate to C in your head
12:36:10 <tac-tics> You have to find the right balance between a program that runs fast and a program that runs correctly
12:36:10 <Cale> TNA-MichaelK: Look at things like Atom...
12:36:28 <Cale> http://hackage.haskell.org/package/atom
12:36:33 <rwbarton> or, do some symbolic calculations in Haskell and then compile the resulting formulas using the llvm bindings
12:36:36 <yrlnry> yeah, because it's important to get the wrong answer as quickly as possible.
12:36:42 <mm_freak_> ozataman: usually you can count on the GC to be on time, so your issue may be laziness
12:36:50 <rwbarton> that won't be much fun in C
12:36:53 <Cale> You can always write a Haskell program to write the C program for you :)
12:37:08 <mm_freak_> ozataman: as long as a value depending on a vector is not calculated, that vector has to be kept in memory
12:37:09 <Cale> (or native code directly)
12:37:45 <ozataman> mm_freak_: OK, I'll just force a stdout putStrLn of the final result periodically. let's see.
12:37:46 <TNA-MichaelK> Cale: What a wonderful idea!
12:37:47 <Cale> For a lot of high-performance problems where you might try using C, writing a special purpose compiler in Haskell is pretty reasonable as well.
12:38:24 <mamalujo> heh. which reminds me, is supercompilation something we'll see in ghc any time soon? I see it has a trac page that hasn't been touched in almost a year
12:38:29 <Cale> (and has the advantage that you can brute force your way through some optimisations which are hard to do by hand)
12:38:47 <mm_freak_> TNA-MichaelK: haskell is a very decent web language as well =)
12:38:50 <ozataman> mm_freak_: I was asking inc ase a foreignptr was mistakenly left unmanaged by GC. I'm really not familiar with vector internals
12:38:51 <rwbarton> Atom's target language is C right?
12:38:54 <Cale> yeah
12:39:24 <TNA-MichaelK> Cale: writing a special purpose compiler in Haskell sounds daunting...
12:39:39 <TNA-MichaelK> mm_freak_: Woah, no way, know any examples?
12:39:44 <mm_freak_> ozataman: you shouldn't have to worry about the internals, unless you sense a bug in the vector package
12:39:45 <Cale> Well... it depends how daunting your original task is :)
12:39:54 <kmc> TNA-MichaelK, much better in Haskell than otherwise
12:39:59 <mm_freak_> TNA-MichaelK: see the yesod framework or happstack
12:39:59 <Cale> Note that you don't have to write a parser
12:40:27 <mm_freak_> TNA-MichaelK: both full featured web frameworks suitable for rapid development
12:40:35 <ozataman> mm_freak_: right, which is what I was suggesting. I think I'm wrong though. Force-showing intermediate results reduced the retained pointer space significantly. Thanks - let me mess around a bit more.
12:40:36 <Cale> You can make the language embedded in Haskell, and just generate code from some Haskell datastructures.
12:40:59 <mm_freak_> ozataman: 'seq'/'deepseq' are your friends then
12:41:06 <mm_freak_> or a cleaner expression of your dependencies
12:41:10 <Cale> http://hackage.haskell.org/package/language-c -- we have some pretty nice-looking libraries for generating C code.
12:41:22 <Cale> http://hackage.haskell.org/package/harpy -- and x86 code
12:41:36 <mm_freak_> ozataman: often turning your algorithms inside out is the way to go in haskell, like i suggested with 'generate'
12:41:44 <imphasing> I'm considering re-writing some of my work software in haskell for lulz and learning, does anyone haev a favorite HTTP interface for haskell? I just need a simple place for clients to make POST requests that I can process :)
12:41:58 <imphasing> I figure building real software is probably a little better for learning..
12:41:58 <rwbarton> there's also some really fancy new package like harpy
12:42:16 <rwbarton> with a much harder-to-remember name
12:42:17 <imphasing> An apache module would be sweet :D
12:42:36 <ozataman> mm_freak_: yeah, but I really don't see it here...yet
12:43:42 <TNA-MichaelK> Wow, thanks guys.
12:43:57 <mm_freak_> imphasing: have a look at WAI
12:44:02 <mm_freak_> = web application interface
12:44:12 <imphasing> mm_freak_: Thanks :)
12:44:23 <mm_freak_> it's a very simple HTTP framework, which you can use to take requests and send responses quickly
12:44:24 <Cale> TNA-MichaelK: But yeah, for a lot of desktop applications, nothing like that is required :)
12:44:59 <Cale> TNA-MichaelK: Haskell code compiled by GHC tends to run fairly fast, and GHC improves all the time as well.
12:45:18 <mm_freak_> imphasing: as for apache, WAI is generic and can support different gateway interfaces…  currently it supports fastcgi, cgi, scgi, warp and snap
12:45:26 <mm_freak_> the latter two are web servers written in haskell
12:45:41 <TNA-MichaelK> I've never made a haskell file yet, I just finished the tryhaskell.org site...
12:45:53 <Cale> TNA-MichaelK: Oh! Then try it! :)
12:45:57 <mm_freak_> usually you would set up an nginx for proxying and warp/snap for your haskell application
12:46:15 <mm_freak_> with nginx you can also use fastcgi, but warp is more convenient =)
12:46:24 <TNA-MichaelK> I don't think I have GHC yet even... I'm not sure how to either... synaptic?
12:46:53 <imphasing> mm_freak_: Awesome, this looks pretty much like what I need thanks :D
12:46:56 <kmc> TNA-MichaelK, get Haskell Platform
12:46:58 <kmc> @where platform
12:46:58 <lambdabot> http://hackage.haskell.org/platform/
12:47:41 <Cale> DevOps Borat: I watch movie The Social Network with Russian subtitle. I like part when main character is mention Apache and subtitle say nginx!
12:48:08 <TNA-MichaelK> lambdabot: Yey! Thanks!
12:48:14 <mm_freak_> lol
12:48:27 <mm_freak_> Cale: where's that from?
12:48:32 <Cale> http://twitter.com/#!/devops_borat
12:49:24 <TNA-MichaelK> actually, one more question, I'm not quite sure which one to grab (I am using Mint), natty perhaps?
12:49:33 <Cale> oh
12:49:41 <mamalujo> TNA-MichaelK: though if you're using debian testing, you can just use synaptic - the latest platform stable release is automatically updated for it
12:49:46 <Cale> Do what I do and just install the GHC generic linux binary
12:49:51 <Cale> :)
12:50:15 <Cale> http://haskell.org/ghc/download_ghc_7_0_4#x86linux
12:50:36 <mm_freak_> Cale: likely the protagonists use nginx/lighttpd anyway =)
12:50:49 <mm_freak_> high volume sites tend to avoid apache nowadays
12:50:58 <Cale> and then get http://hackage.haskell.org/packages/archive/cabal-install/0.10.2/cabal-install-0.10.2.tar.gz
12:51:05 <Cale> and run the bootstrap.sh from that
12:51:44 <Cale> It's maybe not as nice as using your package manager for uninstalling things, but all the Debian-derived packages for GHC are annoying. :P
12:53:06 <Cale> Someone should make .deb packages for GHC which install exactly what GHC installs, rather than severing things into 100 tiny annoying packages
12:53:18 <Cale> One per GHC version :)
12:54:22 <mm_freak_> debian feels very hostile for developers anyway
12:54:29 <mm_freak_> no matter what you want to do, it's difficult
12:54:53 <imphasing> All in the name of Free Software though!
12:56:29 <TNA-MichaelK> imphasing: Agreed!
12:56:40 <mamalujo> Cale: is this all, or is there even more spam: http://packages.debian.org/source/wheezy/ghc that's just 5 current packages, one of which is doc
12:57:10 <mm_freak_> imphasing: i understand that debian is a religion…  hard to believe they didn't build a church yet =)
12:57:15 <Cale> mamalujo: You'll be missing a bunch of libghc-* packages
12:57:46 <Cale> mamalujo: Which ones, I can't say exactly, because a lot of the libghc* packages in debian are extra stuff not included with GHC
12:58:01 <shirt> anyone try NixOS?
12:58:08 <mamalujo> Cale: aha, right. I though all of that was their partial packaging of hackage stuff
12:58:28 <mm_freak_> shirt: i did…  great concept, but i'm waiting for it to become less experimental
12:58:41 <kmc> mm_freak_, what problems did you run into?
12:58:47 <mm_freak_> kmc: none
12:59:00 <deech> I'm at the Strange Loop conference and Gerald Sussman said that all languages are obsolete but called Haskell "the most advanced obsolete language he knows". That's kind of a compliment I guess.
12:59:31 <kmc> haha
12:59:36 <kmc> anything not obsolete?
12:59:39 <mm_freak_> deech: i wouldn't call it the most advanced language
12:59:45 <deech> kmc: Nope not even Scheme.
12:59:49 <kmc> ok
12:59:51 <kmc> that's a downer
12:59:57 <mamalujo> heh. wonder what he thinks is non-obsolete then - dependently typed stuff or
13:00:09 <mm_freak_> not a language
13:00:15 <mm_freak_> he said that all languages are obsolete
13:00:37 <kmc> so how should we make software then?
13:00:48 <mamalujo> you may be taking that too literally - I understood that to mean all existant/non-experimental
13:00:51 <c_wraith> mind-meld with the hardware
13:00:58 <mm_freak_> kmc: GUI builders of course
13:01:03 <kmc> :(
13:01:17 <mm_freak_> what is better than a mouse-driven GUI builder?
13:01:35 <mm_freak_> or we just write our applications in microsoft access
13:01:37 <mamalujo> um, everything that isn't mouse-driven :)
13:01:39 <deech> kmc: I dunno, but all his examples were in Scheme. His Blub has his own take on dataflow concurrency built in.
13:01:44 <kmc> a mouse-driven GUI builder isn't cool
13:01:50 <kmc> you know what's cool?  1,000 mouse-driven GUI builders
13:01:58 <kmc> heh
13:02:06 <deech> kmc: Running on a thousand processors.
13:02:23 <mm_freak_> kmc: i'd expect those to be rather very hot
13:02:24 <companion_cube> (1000 mouse)-driven GUI builder ?
13:02:54 <kmc> what is this conference like / about anyway?
13:03:09 <deech> Although at the same conference Bryan O' Sullivan did a great talk on Haskell startups.
13:03:32 <kmc> is the talk online?
13:03:54 <deech> kmc: I'm at the conference now, so it'll be a month or so before InfoQ starts hosting it.
13:04:00 <mm_freak_> anyway, i think haskell is approaching the best tradeoff between power and practicality
13:04:21 <deech> kmc: Strange Loop 2011, languages, concurrency, big-data etc.
13:04:21 <kmc> mm_freak_, you mean best available at the moment, or best possible?
13:04:35 <deech> kmc: We have Rich Hicket delivering the keynote.
13:04:40 <deech> s/Hicket/Hickey
13:04:41 <mm_freak_> kmc: best possible within the space of abstractions we know today
13:05:47 <deech> Got to go, Hickey's up!
13:05:52 <kmc> have fun :)
13:32:43 <ddarius> quicksilver: Look up the paper "First-class phantom types."
13:34:36 <quicksilver> ddarius: well two people using the term that way (even such respected people) doesn't necessarily prove that's the only way the term is used ;)
13:34:39 <quicksilver> interesting paper though
13:35:07 <ddarius> quicksilver: It's also the way the term was used on the old wiki.  I don't deny that other people use the term differently.
13:35:21 <ddarius> Many people call partial application "currying."
13:35:33 * quicksilver nods
13:35:34 <quicksilver> true enough
13:40:24 <augur> anyone know of good a good representation for the space 2^n for low n (like, say, about 10) that represents the different dimensions on as equal footing as possible?
13:42:24 <tromp> how about Int?
13:42:34 <tromp> good for 2^32 at least
13:42:45 <augur> not a very good visualization tho
13:43:03 <augur> sorry i should specified graphical representation :)
13:43:29 <engla> print the number in binary
13:43:38 <tr|ck> augur: what about using a periodic rpresentation?
13:43:38 <augur> not a good graphical representation!
13:43:49 <augur> tr|ck: periodic how?
13:44:04 <aavogt> scatterplot matrix
13:44:10 <augur> aavogt: ?
13:44:22 <tr|ck> you take a base number to cycle the one you want to represent.
13:44:35 <aavogt> except you can probably do something more efficient in each of the little panels because there are only 4 combinations for you
13:44:56 <augur> aavogt: im not sure what you mean
13:44:56 <tr|ck> this tecnique is used to spot voip nodes on a peer to peer system
13:45:08 <augur> tr|ck: do you have a reference example?
13:45:45 <tr|ck> I should have the link to an interesting document somewhere, let me check...
13:48:16 <augur> im trying to construct a chart of symbols that represent points in a 10-or-so dimensional binary space and its tricky to think of an organization that's not incredibly sparse or unmemorable :\
13:48:39 <augur> or more importantly, one that doesnt scatter related groups all over the place
13:49:15 <aavogt> augur: I'm suggesting you might get away with looking at planes where only 2 parameters vary at once
13:49:49 <augur> aavogt: that would have a lot of redundancy but i suppose it could be done
13:50:02 <augur> infact, you can get 3 dimensions if you do it right
13:51:05 <augur> but that would mean you have to repeat all 2^10 or so points about 4 times
13:51:13 <augur> three or four times
13:58:58 <tr|ck> augur: I didn't find the doc I was talking about, anyhow it was too specific on VoIP, this http://en.wikipedia.org/wiki/Conway_chained_arrow_notation is what I meant, though.
13:59:19 <tr|ck> 2
13:59:29 <tr|ck> sorry, the cat...
14:01:24 <darq> Hello guys. Just wanted to ask if there is something similar to http://4clojure.com/ for Haskell? It's kinda fun to learn when you have something like this
14:01:49 <dibblego> http://tryhaskell.org
14:02:27 <dibblego> (though it doesn't have the problems -- I have some though)
14:05:29 <darq> NIce :) but yeah the problems and registratiotion would make it more interesting ... there is also a list of top users
14:05:46 <dibblego> I don't know of anything like that for haskell sorry
14:07:07 <darq> No problem :) I can learn without this but i think this would help Haskell to get more popular
14:08:09 <Ptival> hopefully, some of you guys should receive an email by me!
14:09:45 <mike-burns> Is the implication here that Clojure is more popular now?
14:10:43 <rs464> Can someone explain to me why, when I 'ghc-pkg latest process', I get process-1.0.1.5, but when I 'cabal install glade', the first thing it prints out is: Resolving dependencies... Downloading process-1.0.1.5... ?
14:11:08 <benmachine> rs464: there are several possible reasons
14:11:10 <rs464> cabal knows about the installed process-1.0.1.5 (in /usr/lib/ghc-7.0.2/package.conf.d)
14:11:20 <applicative_> it knows what's latest, but doesn't have the source?
14:11:34 <benmachine> rs464: possibly it needs to rebuild the package against some different set of dependencies
14:11:39 <applicative_> oh latest is latest installed of course, its ghc-pkg
14:11:58 <benmachine> rs464: you shouldn't let it do so
14:12:03 <rs464> ghc-pkg states that in /usr/lib/ghc-7.0.2/package.conf.d, process-1.0.1.5 exists
14:12:10 <benmachine> rs464: can you hpaste your full ghc-pkg list?
14:12:14 <rs464> sure
14:12:16 <rs464> one sec
14:12:34 <benmachine> (also, run ghc-pkg check, just in case)
14:13:15 <hpaste_> “Rob Stewart” pasted “cabal dependencies” at http://hpaste.org/51588
14:13:51 <darq> I wouldn't say that... but it looks like there is more stuff going on there. Personally I like Haskell better. Probably because of the JVM people give it more attention...
14:14:21 <applicative_> it wants to put a version of process in --user even though it's the same version.
14:14:34 <applicative_> the same as the one in --global, I mean
14:14:34 <rs464> why would it want that?
14:14:46 <rs464> why does the --global version suffice ?
14:15:02 <applicative_> it wants it to depend on something different than the one in --global is depending on?
14:15:37 <benmachine> rs464: the things that concern me are you have local installations of directory and filepath
14:15:41 <benmachine> that's probably a bad idea
14:15:55 <rs464> yes, I agree it probably is
14:16:04 <rs464> I'll remove the local one
14:16:04 <benmachine> can you unregister them?
14:16:24 <rs464> doing so now
14:16:28 <applicative_> it wants the new process to depend on the new filepath in --user
14:16:43 <benmachine> there's also a local and a global html
14:16:48 <benmachine> rs464: how do you install packages?
14:17:07 <ludus_sl> darq: you can use Haskell at spoj: http://www.spoj.pl/
14:17:22 <benmachine> monochrom: *oh*, it's your name backwards, how about that
14:17:26 <benmachine> I get it now
14:17:37 <benmachine> rs464: http://www.vex.net/~trebla/haskell/sicp.xhtml this makes interesting reading
14:18:08 <applicative_> benmachine, I don't see that the new packages in --user are a problem, one always has millions of them if your version of the platform has been around for a while
14:18:35 <rs464> benmachine: you're right - that worked. I unregistered my local directory and filepath
14:18:51 <rs464> not sure how I was supposed to deduce that solution from the errors, but many thanks.
14:19:02 <rs464> benmachine: will take a read
14:19:10 <applicative_> rs464: did you come on any actual problem installing glade?
14:19:16 <benmachine> rs464: by coming and asking us :P I think good error messages is one of cabal's weaknesses
14:19:24 <benmachine> (i.e. that it doesn't have them)
14:20:05 <rs464> I agree, the number of times I've just `rm ~/.ghc ~/.cabal' needlessly
14:20:07 <rs464> :-(
14:20:28 <benmachine> admittedly cabal does quite a hard job
14:20:38 <benmachine> because hackage is updated so frequently, and rather haphazardly
14:21:27 <rs464> right. I'd *love* a mechanism is hackage to see how many download requests have been made to hackage
14:21:31 <rs464> also..
14:22:07 <rs464> I'd like the transition between compatibility with ghc versions on hackage to be smoother
14:22:17 <benmachine> how do you mean?
14:22:44 <rs464> I've submitted packages that won't build (and therefore won't show haddock documentation), because my package depends on another, which depends on another, which isn't compatible with ghc 7.2.1
14:22:58 <benmachine> ah, I see what you mean
14:23:57 <rs464> And (for whatever reason?), hackage only attempts to build with the latest version of ghc... why doesn't it try with multiple backward versions, so that at least the haddock documentation is visible
14:24:00 <rs464> that'd be really useful
14:24:23 <cgroza> Hello everyoneo. I am currently studying Monads and the operation sequencing using  return >> and >>=  is clear to me. What I don't understand is how Monads allow returning different values with the same arguments... Anyone can explain me?
14:24:29 <benmachine> well, it would probably put more stress on the buildbot
14:24:49 <benmachine> cgroza: what do you mean?
14:25:05 <benmachine> I strongly suspect the answer is that they don't
14:25:06 <c_wraith> cgroza: >>= and >> are polymorphic.  they do different things depending on their type
14:25:26 <c_wraith> @src liftM2
14:25:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:25:37 <cgroza> benmachine: getLine can return different values when called. I thought you can't do that in haskell.
14:25:43 <c_wraith> oh.
14:25:48 <c_wraith> that's not type-related at all.
14:25:56 <benmachine> cgroza: this isn't about monads, this is about IO
14:26:10 <cgroza> benmachine: how is that accomplished then?
14:26:13 <c_wraith> IO values are values, not functions.
14:26:29 <c_wraith> getLine is always the same IO value
14:26:40 <c_wraith> the value happens to be the description "read a line of input"
14:26:55 <cgroza> c_wraith: so it does not matter if a different string is wrapped inside the IO?
14:27:12 <c_wraith> cgroza: an IO String is *not* a string wrapped inside IO
14:27:18 <mm_freak_> cgroza: getLine does not return different values each time
14:27:21 <mm_freak_> it always returns the same value
14:27:25 <benmachine> cgroza: the way people often describe it is that a Haskell program is a method of writing a 'recipe'
14:27:26 <c_wraith> cgroza: it's instructions for performing IO and getting a string
14:27:35 <mm_freak_> but the value is not a line read from the terminal, the value is the particular action to do so
14:27:39 <mm_freak_> the action is always the same
14:27:48 <benmachine> your haskell program constructs a series of instructions for what IO to do, and it always constructs the same instructions
14:28:02 <benmachine> but those instructions are then run by your computer, and can result in different outputs in different situations
14:28:12 <cgroza> I think I get it now.
14:28:26 <tac-tics> Maybe you guys should start with state threading?
14:28:39 <c_wraith> state threading is never good to *explain* IO.
14:28:42 <mm_freak_> cgroza: in fact, getLine is not even a function, it's really just a value, a recipe as benmachine calls it
14:28:43 <c_wraith> it's fine to implement it
14:28:50 <benmachine> c_wraith: oh, I think the opposite :P
14:29:02 <benmachine> state threading is a good metaphor, but it doesn't actually work
14:29:14 <cgroza> So how can I bulid such an action?
14:29:19 <mm_freak_> c_wraith: you really view state threading is a good way for an implementation?  i'd think that an implementation just uses a DSL
14:29:42 <cgroza> s/bulid/build
14:29:42 <benmachine> mm_freak_: the GHC implementation is 'baton-passing', which looks a bit like state threading
14:29:44 <c_wraith> I mean state threading in the sense that ST and IO are the same thing, at an implementation level
14:29:53 <mm_freak_> data IO where GetLine :: IO String | PutStrLn :: String -> IO () | …
14:29:55 <benmachine> cgroza: you mean, how could you define getLine?
14:30:00 <cgroza> benmachine: yes.
14:30:08 <benmachine> cgroza: you could use getChar
14:30:24 <cgroza> benmachine: ok thanks.
14:30:29 <benmachine> cgroza: but at some point you have to have a 'primitive' function
14:30:47 <benmachine> cgroza: that can't be defined in pure haskell, and must be provided by the compiler or OS instead
14:30:47 <c_wraith> cgroza: you define IO actions in terms of other IO actions, the return function, pure computations, and (advanced users only) FFI calls
14:31:15 <mm_freak_> cgroza: IO is magic…  it allows you to break out of haskell by supporting calling operating system functions…  but this has nothing to do with purity or the type system
14:31:49 <mm_freak_> you can combine existing IO actions in haskell, but you can also create new, unrelated ones by magic
14:31:53 <tac-tics> IO is magic, but no more magic than being able to add integers
14:32:05 <cgroza> mm_freak_: so I should just swallow that and not think about too much...
14:32:07 <c_wraith> being able to add integers is actually *deep* magic.
14:32:09 <benmachine> tac-tics: one could devise a representation of integers in pure haskell that can be added
14:32:15 <tac-tics> The definitions for many IO primitives cannot be specified in Haskell
14:32:22 <tac-tics> They are written into the language
14:32:35 <tac-tics> benmachine: I could do the same for the whole world ;)
14:32:42 <mm_freak_> cgroza: that's a good idea…  there isn't so much to understand about IO, just view it as an embedded recipe language for real world interaction
14:33:14 <cgroza> mm_freak_: ok. I guess that will not stop me from understanding haskell :D
14:34:12 <tac-tics> especially when you have "do" notation
14:34:17 <tac-tics> You can forget what IO even is
14:34:22 <tac-tics> as long as you know the rules
14:34:24 <mm_freak_> cgroza: in fact, once you are somewhat fluent, you will be able to create your own MyIO monad, which you can translate to IO
14:34:36 <tac-tics> <- "takes something out of the box"
14:34:42 <tac-tics> That's pretty much it, actually >_>
14:34:43 <mm_freak_> and once you understand how to do that, you will also have an idea of how a compiler might translate IO into machine code
14:34:47 <mm_freak_> that's really it
14:34:57 <tac-tics> do { line <- getLine; putStr line }
14:35:01 <tac-tics> getLine :: IO String
14:35:06 <tac-tics> the <- takes the string out of the box
14:35:06 <mm_freak_> tac-tics: bad example though =)
14:35:09 <tac-tics> and sets line equal to it
14:35:13 <mm_freak_> getLine >>= putStr
14:35:31 <tac-tics> mm_freak_: It's not a bad example. Just because there's two ways to do it
14:36:16 <mm_freak_> tac-tics: it was a joke with a small element of truth, but it suffices for the purpose
14:36:51 <mm_freak_> i always prefer to teach IO with the actual combinators
14:37:01 <mm_freak_> and apparently cgroza knows them already
14:38:41 <tac-tics> I prefer to always teach things the opposite the way the teacher is teaching them :P
14:38:53 <tac-tics> That's what makes me a good programmer
14:39:03 <tac-tics> Because I'm stubborn as hell
14:39:14 <mm_freak_> as long as that doesn't imply i'm a bad one =P
14:39:19 <tac-tics> And I want nothing more than to prove everyone I'm smart and they're wrong
14:39:44 <ddarius> <- "takes something out of the box" is perhaps the absolute worst way to describe its behavior.
14:39:47 <mm_freak_> ok, i'm a bad programmer in other languages, because i always try to implement FRP some way
14:40:01 <shachaf> tac-tics: Please don't talk about boxes in this channel. :-(
14:40:13 <shachaf> foo :: IO a isn't a box containing an a.
14:40:26 <shachaf> @quote kmc box
14:40:26 <lambdabot> No quotes match. Maybe you made a typo?
14:40:26 <tac-tics> ddarius: That's how I imagine it, and it works for me
14:40:28 <Clint> lockbox
14:40:41 <mm_freak_> do-notation is naturally bound to interpretations, hence "taking out of the box"
14:40:47 <mm_freak_> that's why i prefer to teach with the combinators
14:41:03 <tac-tics> Maybe "Take it out of the box that is the real world, which doesn't exist at compile time, but sure as hell exists at runtime"
14:41:15 <tac-tics> But I prefer terseness over exactness most of the time
14:41:16 <tac-tics> :)
14:41:20 <ddarius> mm_freak_: The connotations of do-notation is not "taking out of the box" anyway.  It would be imperative assignment if anything.g
14:41:25 <shachaf> What? getLine is the box is the real world now?
14:41:41 <stribor> hello Stribor
14:42:00 <ocharles_> Is there a way to get GHC to emit a warning if I use "undefined"?
14:42:13 <mm_freak_> ddarius: sure, but still the box interpretation is quite common among beginners, and it's easy to make it
14:42:14 <ocharles_> I'm stubbing my API, but I was hoping there was something a bit safer than "grep 'undefined'"
14:42:26 <ddarius> mm_freak_: Because people and introductions keep telling them that.
14:42:27 <tac-tics> ocharles_: try import Prelude hiding (undefined) or whatevever
14:42:39 <shachaf> In do-notations, typing "foo" has the connotations of "execute foo"; "x <- foo" has the connotations of "execute foo and call the 'result' x".
14:42:53 <ocharles_> tac-tics: wouldn't that cause an error, not a warning?
14:42:56 <cgroza> I was told that line <- getLine; myFunc line is translated to : getLine >>= (\x -> myFunc x)
14:43:04 <tac-tics> ocharles_: What need have you for warnings?
14:43:08 <tac-tics> ocharles_: Or...
14:43:16 <shachaf> cgroza: Yep.
14:43:16 <ddarius> shachaf: That's exactly the connotation that is desired, and is the denotation as well.
14:43:22 <ocharles_> tac-tics: something nagging me when I compile, and the option to enable -Werror when it's time to get implementing
14:43:29 <tac-tics> You could import Prelude hiding undefined, then undefined = WarningThisIsUndefined
14:43:40 <tac-tics> and declare WarningThisIsUndefined as a data type and constructor :)
14:43:46 <mm_freak_> ocharles_: since 'undefined' is not the only notion of an intentional bottom, there is really little you can do except importing Prelude hiding the variants
14:43:51 <tac-tics> ah
14:43:52 <shachaf> ddarius: Well, for varying meanings of "execute". For e.g. [] that's not the word you'd usually use.
14:43:56 <mm_freak_> ocharles_: there are undefined, error, throw, etc.
14:44:08 <ddarius> shachaf: You're executing a computation in a non-deterministic language.
14:44:23 <ocharles_> mm_freak_: I had a feeling the fact it meant _|_, but was just hoping GHC had a nice way to treat it specially
14:45:14 <ocharles_> I could abuse deprecated too, and define my own "undefined" that's deprecated :)
14:45:15 <shachaf> ocharles_: Instead of "undefined", you could use your own _|_ value, and then stop defining it once you don't want to use it anymore.
14:45:17 <mm_freak_> ocharles_: you can find intentional bottoms to some extent, yes…  if 'base' is your only dependency, then there are not many ways to express it
14:46:09 <ocharles_> shachaf: I don't think that solves my problem of having it create warnings, that would just be silent, or an error
14:46:13 <ocharles_> unless I misunderstand you
14:46:27 <shachaf> What's the difference between a warning and an error?
14:46:42 <tac-tics> Errors don't generate an executable
14:46:44 <ocharles_> I mean compile time error
14:46:47 <tac-tics> Warnings do, but bitch at you
14:47:02 <mm_freak_> ocharles_: what shachaf means is, define your own:  notImplemented :: a
14:47:04 <ocharles_> yep, and let me treat them as errors when it's more important I focus on them
14:47:10 <mm_freak_> notImplemented = error "Not implemented"
14:47:10 <shachaf> myUndefined = unsafePerformIO c_gets -- Link-time error. :-)
14:47:31 <shachaf> mm_freak_: Right, but ocharles_ wants a warning.
14:47:34 <tac-tics> ocharles_: I don't know of a way you can do that
14:47:38 * shachaf thinks warnings are in general a bad idea.
14:47:40 <ocharles_> shachaf: yes, but I want warnings, not errors :) ghc already have -Werror for when I want it more severe
14:48:01 <tac-tics> ocharles_: Sounds like something you could add to the core ;)
14:48:08 <tac-tics> ocharles_: to spite shachaf
14:48:14 <ocharles_> haha
14:48:18 <mm_freak_> ocharles_: you can make your notImplemented deprecated easily
14:48:25 <tac-tics> And me (because warnings are the wrong way of doing it :P )
14:48:30 <ocharles_> I'll add -Wlack-of-warnings to create a warning if you've got no warnings
14:48:47 <ocharles_> mm_freak_: yea, that's what I was considering doing
14:49:22 <mm_freak_> although i'd go with the usual wisdom and let it generate errors instead…  if that's less convenient, you may want to consider using another editor =)
14:50:09 <ocharles_> Actually... quick thought, but first - motivation
14:50:25 <ocharles_> I'm stubbing out a little API that'll be used in the future, and "merge" and "delete" aren't used at all yet
14:50:37 <ocharles_> so I can just use undefined for their definitions, but if I don't export them, I'll get a warning they are unused
14:50:40 <ocharles_> which is probably Good Enough
14:51:03 <ocharles_> as to fix that warning I'll have to actually use them, and hopefully I'll think about it and won't just stick them in my exports :P
14:51:13 <mm_freak_> ocharles_: you can also just not define them, instead of defining them as bottom
14:51:22 <mm_freak_> once you find use for them, add their real definitions
14:51:37 <ocharles_> mm_freak_: Hrm, already have the type signature written
14:51:45 <ocharles_> and I have to have a binding with that, right?
14:51:48 <mm_freak_> then comment it out
14:51:55 <ocharles_> right, thought you'd say that :)
14:52:11 <shachaf> ocharles_: Is one warning for all oof them sufficient sufficient?
14:52:12 <mm_freak_> really, haskell doesn't go well with leaving holes =)
14:52:27 <ocharles_> shachaf: perhaps, what are you going to suggest?
14:52:56 <shachaf> ocharles_: {-# LANGUAGE CPP -}; myUndefined = error "oh no!"; #warn You didn't uncomment this!
14:52:59 <shachaf> s/un//
14:53:32 <shachaf> Then when you comment it out they turn into errors.
14:54:25 <mm_freak_> ocharles_: you can also change the type of your undefined stuff
14:54:33 <mm_freak_> definedPlus :: Int -> Int
14:54:38 <mm_freak_> undefinedPlus :: a (Int -> Int)
14:55:20 <ocharles_> how does that help, other than failing to type check when I use it?
14:55:23 <ocharles_> or is that the main reason?
14:55:53 <mm_freak_> it's the main reason…  you can then find where it's used…  but yes, that will also give you errors instead of warnings
14:56:58 <mm_freak_> this is just a dirty way of expressing:  data FindMyUsage :: * -> *; plus :: FindMyUsage (Int -> Int)
14:58:59 <mm_freak_> which raises an interesting question:  are nonexported types lost, once a library is compiled?  or does GHC retain types until the final linking?
15:00:26 <byorgey> mm_freak_: I think the .hi file may have type information, but the .o does not
15:00:42 <mm_freak_> i see
15:01:19 <byorgey> ah yes, I found something that explicitly says the .hi file contains information about nonexported types, or at least types whose constructors are not exported
15:01:55 <byorgey> oh, haha, wait, that was from the documentation for GHC 2.10 =P
15:02:20 <mm_freak_> that may be outdated =)
15:02:30 <ocharles_> so if I want to talk about my idea of -Wundefined or something, where would be a place to do that?
15:02:33 <ocharles_> a mailing list?
15:02:45 <shachaf> http://www.haskell.org/ghc/download_ghc_210
15:02:50 <ocharles_> i dunno much about anything when it comes to ghc hacking :)
15:02:53 <shachaf> ocharles_: Probably, or #ghc.
15:03:18 <ocharles_> none real time is probably best for me, given the magnitude of reading I'll have to do at the same time
15:03:24 <shachaf> But I doubt anyone would want that particular flag. A more general {-# WARNWHENTHISISUSED identified #-} *might* be useful.
15:03:34 <byorgey> mm_freak_: indeed. however I would be surprised if there is *less* information in the .hi files than there used to be. =)
15:03:35 <mm_freak_> ocharles_: i'd suggest a mailing list…  if other people like the idea, it may be worth writing a feature request for (or just implement it yourself into GHC and send a patch)
15:03:38 <ocharles_> sure, that's why I wanted to talk about it on a list first
15:03:45 <shachaf> Oh, in fact, that already exists.
15:04:18 <mm_freak_> byorgey: i guess, the type information has to be there, so that you can still typecheck values of nonexported types
15:04:35 <ocharles_> While we're on the subject of toolchains, is there anyway to get `cabal haddock` to provide useful information on what *doesn't* have documentation?
15:04:45 <ocharles_> 7/9 78% is not particularly useful to me
15:04:47 <mm_freak_> other than that nonexported types act sort of like fully polymorphic types to me
15:05:15 <mm_freak_> ocharles_: right now i don't think so, but it really counts only top level definitions as far as i've seen
15:05:34 <tsuraan_> is there a standard way to get (init lst, last lst) with a single pass through the list?  Explicit recursion is easy enough, but I'm wondering if there's a nice way to do it through some Data.List functionality
15:06:00 <ocharles_> mm_freak_: yes that seems right, the 2 were missing a | next to the --
15:06:02 <shachaf> tsuraan_: I don't think so.
15:06:03 <Peaker> Does anyone know Python's "nested" function? I'm wondering how to encode its type in Haskell... It seems non-trivial
15:06:13 <shachaf> init and last are usually a bad idea anyway. :-)
15:06:45 <kmc> what's the function?
15:06:45 <azaq23> Peaker: nested? from contextlib? that's only relevant for with statements
15:06:45 <Peaker> kmc: do you know Python's "with"?
15:06:45 <comonad> If you need init and last I think DList provides O(1) for those
15:06:45 <kmc> it does?
15:06:45 <kmc> Data.Sequence does
15:06:45 <Peaker> azaq23: yes, and "with statements" are basically Control.Exception.bracket
15:07:10 <byorgey> comonad: no it doesn't, DList only provides constant-time cons and snoc
15:07:19 <byorgey> to deconstruct a DList you have to convert to a regular list first
15:07:24 <mm_freak_> Peaker: what does 'nested' do?
15:07:24 <comonad> byorgey: Nevermind then.
15:07:31 <shachaf> DList x is just (x++); it's not magic at all.
15:07:32 <kmc> afaik because of their higher-order representation, the only way to inspect a DList is to convert it to a regular list
15:07:43 <kmc> but that's not true of Data.Sequence
15:07:47 <Peaker> mm_freak_, kmc: basically Python has a syntax called "with" which is basically a syntax for the bracket function:
15:07:53 <Peaker> with some_file as f:
15:07:56 <kmc> yeah, i know the with statement
15:07:59 <Peaker>   with other_resource as g: ...
15:08:01 <tsuraan_> I suppose I could change my code to use a Seq if I need to
15:08:04 <kmc> can't be a regular function because lambda is for suckers ;)
15:08:07 <shachaf> Peaker: "with" is just a thing that takes a lambda and uses it with some restrictions, isn't i?
15:08:16 <tsuraan_> I'll see if it's a real bottleneck :)
15:08:16 <shachaf> Peaker: Any exception-handling has to be done in the with handler.
15:08:25 <azaq23> Peaker: true enough
15:08:49 <mm_freak_> Peaker: if that's it, just nest 'bracket'
15:09:09 <Peaker> shachaf: with CONTEXT as OBJ: BODY     it basically calls CONTEXT.__enter__() assigns the result into OBJ, and then executes BODY, and then CONTEXT.__exit__(exception info here)
15:09:17 <Peaker> mm_freak_: Except you can't do something like this easily:
15:09:36 <Peaker> so with nested, you can write:  with nested([ open(fn) for fn in ... ]) as files: ...
15:09:58 <Peaker> you can write a manual recursion to nest your brackets, but that's not as nice as a combinator
15:10:48 <mm_freak_> Peaker: [a] -> (a -> IO r) -> (r -> IO ()) -> ([r] -> IO b) -> IO b
15:11:01 <kmc> :t \xs ys -> bracket (sequence xs) (\rs -> sequence_ $ zipWith ys rs)
15:11:03 <lambdabot> Not in scope: `bracket'
15:11:09 <kmc> :t \xs ys -> Control.Exception.bracket (sequence xs) (\rs -> sequence_ $ zipWith ys rs)
15:11:10 <lambdabot>     Couldn't match expected type `[m a]'
15:11:10 <lambdabot>            against inferred type `[b] -> [c]'
15:11:10 <lambdabot>     In the second argument of `($)', namely `zipWith ys rs'
15:11:23 <mauke> zipWith wat
15:11:34 <kmc> er
15:11:36 <Peaker> mm_freak_: then you have the same initializer/finalizer for the entire list?
15:11:37 <kmc> :t \xs ys -> Control.Exception.bracket (sequence xs) (\rs -> sequence_ $ zipWith ($) ys rs)
15:11:38 <lambdabot> forall a a1 c. [IO a] -> [a -> IO a1] -> ([a] -> IO c) -> IO c
15:11:45 <Peaker> mm_freak_: consider a nested([a bunch of different contexts here]) ...
15:12:03 <parcs> tsuraan_: init is already O(1)
15:12:13 <shachaf> ocharles_: Yes, what you want is easy; just use {-# WARNING myUndefined "don't use this" #-}
15:12:13 <Peaker> I think it turns out to be something like: [ContT IO r a] -> ContT IO r [a]
15:12:16 <kmc> parcs, it is?
15:12:25 <tsuraan_> parcs: are you thinking of head?
15:12:28 <mm_freak_> Peaker: 'a' is fully polymorphic…  you can use a type class
15:12:41 <kmc> init has to walk the entire list re-allocating cons cells until it gets to the second-to-last one
15:12:42 <Peaker> A partially-applied bracket (that just needs a body) is basically a ContT IO r a  (r=anything, a=the resource)
15:12:45 <mm_freak_> in the initialization function you can make use of the class functions
15:12:55 <Peaker> mm_freak_: it's the same 'a' in the entire list
15:12:55 <ocharles_> shachaf: aha!
15:12:58 <kmc> @unmtl ContT IO r a
15:12:58 <lambdabot> (a -> r IO) -> r IO
15:13:05 <kmc> @unmtl ContT r IO a
15:13:05 <lambdabot> (a -> IO r) -> IO r
15:13:22 <Peaker> mm_freak_: you could mess it up with existentials, etc, but I think it's diverging away from "nested", which I think is nicer
15:13:26 <mm_freak_> Peaker: well…
15:13:42 <parcs> kmc: hmm, i see
15:14:05 * hackagebot RSA 1.0.6.2 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.0.6.2 (AdamWick)
15:14:07 <Peaker> I think the ContT thing works, I'll try
15:14:27 <shachaf> I don't think you should need ContT.
15:14:41 <kmc> :t sequence :: [ContT IO r a] -> ContT IO r [a]
15:14:41 <lambdabot>     `IO' is not applied to enough type arguments
15:14:42 <lambdabot>     The first argument of `ContT' should have kind `*',
15:14:42 <lambdabot>     but `IO' has kind `* -> *'
15:14:45 <mm_freak_> Peaker: data Bracket :: * -> * where Bracket :: a -> (a -> IO r) -> (r -> IO ()) -> Bracket r
15:14:49 <kmc> :t sequence :: [ContT r IO a] -> ContT r IO [a]
15:14:50 <lambdabot> forall r a. [ContT r IO a] -> ContT r IO [a]
15:14:55 <parcs> i was under the impression take and init were O(1)
15:15:08 <Nikki> [42, 13, 22]
15:15:09 <shachaf> Everything's O(1) if you don't evaluate the thunk!
15:15:15 <kmc> what shachaf said
15:15:18 <mm_freak_> Peaker: [Bracket] -> ([Bracket] -> IO a) -> IO a
15:15:33 <mm_freak_> Peaker: you may also find a way using type families
15:15:55 <shachaf> parcs: Think of the actual data structure. You have the linked list 1:2:3:[], and you want to make the linked list 1:2:[].
15:16:28 <shachaf> This is without mutation, so it has to be O(n) in both time and space, as far as that means something.
15:16:39 <mm_freak_> also i would do it without ContT, because otherwise it won't work with generalizations like monad-control
15:16:48 <Peaker> mm_freak_: you've got a kind error there
15:17:02 <Peaker> mm_freak_: also, what's the point of the "a" there?
15:17:02 <kmc> if you use mutation then it's a different function anyway
15:17:12 <Peaker> mm_freak_: I think Bracket is actually ContT IO r a
15:17:16 <mm_freak_> Peaker: oh, silly me
15:17:22 <Peaker> (just a partially applied bracket to 2 args)
15:17:24 <parcs> shachaf: yeah, i see
15:17:26 <Peaker> @type bracket
15:17:27 <lambdabot> Not in scope: `bracket'
15:17:31 <Peaker> @type Control.Exception.bracket
15:17:32 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:18:10 <kmc> Peaker, the transformed monad is always the second-to-last type parameter
15:18:26 <mm_freak_> Peaker: you can certainly express this in terms of ContT, but as said i wouldn't
15:18:39 <Peaker> kmc: whoops
15:19:06 <Peaker> mm_freak_: why not? It's simpler than GADTs/existentials/etc
15:19:29 <Peaker> I think it's also natural to think of a Python "context" as a partially applied bracket, whose type is really a ContT r IO
15:20:23 <mm_freak_> Peaker: you effectively constrain yourself to IO
15:21:12 <mm_freak_> so far nobody has found a way to write, for example, a MonadControlIO instance for a CPS monad
15:21:51 <Peaker> mm_freak_: well, I'm built on top of bracket which is contrained to IO, but I'm really constrained to whatever bracket (or an alternate function) uses
15:21:51 <mm_freak_> i sense there may be a very easy way to express this using a type family
15:22:19 <mm_freak_> Peaker: 'bracket' can be generalized
15:22:46 <kmc> hmm, this is interesting... so you can code in a style like do { x <- withFile "foo"; y <- withFile "bar"; z <- acquireWhatever ... }, within ContT r IO
15:22:57 <kmc> and it all gets released at the end of runContT
15:23:11 <kmc> is that correct?
15:23:13 <Peaker> mm_freak_: great, then so can this if it is built on top of it.. (without any type families, I dont think)
15:23:38 <mm_freak_> kmc: i like the idea
15:23:40 <Peaker> kmc: Yeah, I haven't thought about that (obvious in retrospect) :)
15:23:49 <kmc> that's almost nicer than 'bracket', except for the problems mm_freak_ points out about transforming IO
15:23:50 <mm_freak_> but isn't that just region-based IO?
15:23:51 <Peaker> kmc: makes sense to have bracket actually return a ContT r IO rather than a synonym
15:24:16 <ion> Ooh, nice
15:25:07 <mm_freak_> if you find a way to write this without ContT, then it gives a nice general pattern, which you can lift beyond IO
15:25:09 <Peaker> and "nested" is sequence, doh!
15:25:10 <tsuraan_> > Prelude.length $ Prelude.map (Data.ByteString.pack . (:[])) [1..1000]
15:25:11 <lambdabot>   Not in scope: `Data.ByteString.pack'
15:25:37 <kmc> you can also have something of type   ContT a IO a -> ContT r IO a
15:25:43 <tsuraan_> > :l Data.ByteString
15:25:44 <lambdabot>   <no location info>: parse error on input `:'
15:25:55 <mm_freak_> note also that ContT allows cheating
15:25:59 <tsuraan_> can I get lambdabot to use bytestrings?
15:26:05 <kmc> which causes nested resources to be released at this point within a larger computation
15:26:08 <kmc> (i think)
15:26:17 <kmc> tsuraan_, use for what?
15:26:18 <mm_freak_> it doesn't give a static guarantee that the resources are released, unless you hide the constructor of ContT
15:26:22 <kmc> > Data.ByteString.pack [0..10]
15:26:23 <lambdabot>   Not in scope: `Data.ByteString.pack'
15:26:59 <kmc> mm_freak_, yeah, I'd be inclined to hide the continuation machinery (it will scare people anyway)
15:27:10 <comonad> sigh why is it not read :: String -> Maybe a
15:27:26 <kmc> comonad, stupidity
15:27:26 <kmc> http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
15:27:49 <hpaste_> tsuraan pasted “strange result of map” at http://hpaste.org/51590
15:27:53 <kmc> (there's no good reason afaik)
15:27:53 * shachaf considers proposing a function :: String -> Maybe a for the standard library.
15:27:54 <comonad> kmc: Oh, neat.
15:27:58 <shachaf> How accepting are they of that sort of thing?
15:28:03 <tsuraan_> kmc: in the pastie
15:28:04 <mm_freak_> :t listToMaybe . map fst . reads
15:28:05 <lambdabot> forall a. (Read a) => String -> Maybe a
15:28:18 <tsuraan_> is that result sane?
15:28:18 <comonad> kmc: The main problem that annoys me is that read . show is of type a -> b when it ought to be something like a -> Maybe b...
15:28:55 <ion> > (listToMaybe . map fst . reads) "42invalid" :: Maybe Integer
15:28:55 <mm_freak_> :t fmap show . listToMaybe . map fst . reads
15:28:56 <lambdabot> String -> Maybe String
15:29:00 <lambdabot>   mueval: ExitFailure 1
15:29:00 <lambdabot>  mueval-core: Time limit exceeded
15:29:02 <ion> > (listToMaybe . map fst . reads) "42invalid" :: Maybe Integer
15:29:05 <lambdabot>   Just 42
15:29:20 <kmc> > length ([0..1000] :: [Word8])  -- tsuraan_
15:29:21 <lambdabot>   233
15:29:30 <nikki_> server down? i keep getting terminated error?
15:29:54 <comonad> I don't think that `safeRead "42invalid" = Just 42` is good behavior though
15:30:10 <mm_freak_> comonad: then add an additional filter
15:30:11 <ion> > (listToMaybe . map fst . filter (not . null . snd) . reads) "42invalid" :: Maybe Integer
15:30:12 <lambdabot>   Just 42
15:30:17 <ion> err
15:30:20 <ion> > (listToMaybe . map fst . filter (null . snd) . reads) "42invalid" :: Maybe Integer
15:30:21 <lambdabot>   Nothing
15:30:41 <tsuraan_> kmc: 233 seems like a really weird top limit for a word8
15:30:59 <kmc> > 1000 `mod` 256
15:31:00 <lambdabot>   232
15:31:39 <mm_freak_> > length ([minBound .. maxBound] :: [Word8])
15:31:40 <lambdabot>   256
15:31:40 <tsuraan_> kmc: aha, I get it :)
15:32:12 <JoeyA> See, this is the problem with C.  You can't formally analyze what a program will do.
15:32:16 <JoeyA> Oh wait, wrong channel.
15:32:21 <kmc> haha
15:32:32 <dainanaki> seems like the right channel to me.
15:32:37 <ddarius> s/C/Haskell/
15:32:43 <kmc> bashing languages other than Haskell is always on-topic here ;P
15:32:49 <JoeyA> forall a. See, this is the problem with a.
15:32:51 * ddarius bashes Haskell.
15:32:53 <comonad> you can if its not using nondeterministic behaviors but what C program doesn't? :)
15:32:54 <ion> Also bashing Haskell is.
15:33:02 <shachaf> kmc: Bashing Haskell is also -- sigh, why do I even try?
15:33:12 * dainanaki bashes. bash bash bash.
15:33:23 <kmc> zsh zsh zsh
15:33:31 <ddarius> If you want a language for which that statement arguably isn't true, see SML.
15:33:40 <comonad> haskell98 can be bashed because of no multi parameter type classes ;)
15:33:49 <mm_freak_> kmc: i bash haskell a lot, but for real issues, not for childhood issues
15:33:53 <kmc> haha
15:33:53 <ddarius> Haskell 2010 doesn't have multiparameter type classes.
15:34:08 <shachaf> Nor does SML.
15:34:14 <comonad> 2010 too then. But most people seem to target 98 or GHC
15:34:15 <Peaker> It's pretty awesome how Python's nested turns out to be *yet another* special case of sequence :)
15:34:28 <kmc> "awesome"
15:34:40 <Peaker> kmc: Why not *awesome*? :)
15:34:53 <ddarius> All programs are special cases of some generic monadic operation.
15:35:21 <Peaker> well, first I hadn't noticed the relationship between bracket and ContT. Then I hadn't noticed that the type of nested I was looking for was just "nested"
15:35:28 <mm_freak_> for example, haskell won't let me do this:  proc -> x <- do { x' <- comp1 -< (); comp2 -< x'^2 }; returnA -< sqrt x
15:35:33 <mm_freak_> and that sucks a lot
15:35:34 <Peaker> ddarius: But it's interesting when "some" turns out to be one of the simple/basic combinators
15:35:43 <Peaker> mm_freak_: eww.. arrows :-)
15:35:57 <kmc> Peaker, it's not awesome because it reminds me that Python is uglier than people think
15:36:00 <mm_freak_> you know, i love my arrows =)
15:36:18 <JoeyA> I wish Haskell expressions could apply to more than just values in memory
15:36:19 <Nafai> Peaker: I wrote a function in Python the other day to filter out None and almost called it catMaybe
15:36:24 <ddarius> kmc wants only to look at beautiful things.
15:36:30 <JoeyA> e.g. an on-disk database.
15:36:33 <Peaker> kmc: well, "awesome" describes Haskell here.. I don't take it for granted that Haskell helps me unify so many concepts that seem distinct into the same ones
15:36:39 <ddarius> Nafai: Not catMaybes?
15:36:48 <Nafai> er, yeah, that's what I meant :)
15:37:06 <ddarius> catOptions?
15:37:12 <kmc> catMaybes = lambda xs: ( x for x in xs if x )
15:37:15 <ddarius> (Freakin' MLs)
15:37:24 <mm_freak_> seriously i should propose extending the arrow notation in a few ways
15:37:28 <Peaker> Nafai: Well, catMaybes is not any more general than the Python equivalent, though (even if nicer)
15:37:45 <JoeyA> :i catMaybes
15:37:54 <JoeyA> > 2+undefined
15:37:56 <lambdabot>   *Exception: Prelude.undefined
15:38:00 <Peaker> catMaybes xs = [x | Just x <- xs]
15:38:06 <kmc> @src catMaybes
15:38:06 <lambdabot> catMaybes ls = [x | Just x <- ls]
15:38:14 <Peaker> ls??
15:38:26 <JoeyA> Hmm, guards also filter?
15:38:32 <dobblego> catMaybes :: (Foldable f, MonadPlus m) => m (f a) -> m a
15:38:37 <kmc> JoeyA, that's a list comprehension
15:38:45 <kmc> JoeyA, pattern-match failure in list comprehensions discards that element
15:38:48 <Peaker> JoeyA: It's not a "guard" here, it's pattern match failures in list comprehensions acting like they do in "do" blocks -- call "fail"
15:38:59 <JoeyA> Ah, I wondered that earlier today.
15:39:01 <JoeyA> Didn't think it did.
15:39:03 <kmc> this is imo one of the most useful properties of list comprehensions
15:39:08 <Peaker> > fail "hi" :: Maybe Int
15:39:08 <shachaf> Peaker: eLementS
15:39:09 <lambdabot>   Nothing
15:39:09 <JoeyA> > [x | Just x <- [Just 5, Just 7, Nothing, Just 9]]
15:39:10 <lambdabot>   [5,7,9]
15:39:15 <kmc> if your compr. does not use this property, it is likely nicer written point-free
15:39:17 <ion> @unpl [ x | Just x <- xs ]
15:39:17 <lambdabot> [x | Just x <- xs]
15:39:18 <dobblego> kmc: I agree
15:39:20 <ion> @undo [ x | Just x <- xs ]
15:39:21 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) xs
15:39:34 <shachaf> kmc: My comprehensions are comprehensive, though!
15:39:54 <Nafai> kmc: I find myself writing list comprehensions a lot, but always wondered if they were the most idiomatic way of doing it
15:40:03 <Peaker> what is a nice points-free way to write catMaybes?
15:40:19 <JoeyA> > let xs = [Just 5, Just 7, Nothing, Just 9] in [(x, y) | Just x <- xs | y@Nothing <- xs]
15:40:20 <lambdabot>   [(5,Nothing)]
15:40:30 <Peaker> > concat . map maybeToList $ [Just 5, Nothing]
15:40:30 <ion> filter isJust
15:40:32 <lambdabot>   [5]
15:40:38 <Peaker> ion: no -- that leaves the Maybe wrapper
15:40:48 <kmc> map fromJust . filter isJust  -- not nice
15:40:58 <ion> Ah, indeed.
15:41:01 <yebyen> does anyone cabal install haddock?
15:41:07 <kmc> :t concatMap maybeToList
15:41:08 <lambdabot> forall b. [Maybe b] -> [b]
15:41:08 <yebyen> it seems to be incompatible with the latest version of alex...
15:41:09 <JoeyA> I do.
15:41:13 <dobblego> @type (=<<) maybeToList
15:41:14 <lambdabot> forall b. [Maybe b] -> [b]
15:41:14 <Peaker> ion: which is really bad, because then the type mismatches the data and encourages "isJust" (a coworker new to haskell used   map fromJust . filter isJust  <-- I explained why its yucky to her.. receptive!)
15:41:26 <yebyen> i'm trying to get leksah compiled, it depends on haddock
15:41:35 <Peaker> dobblego: why not a section?
15:41:41 <yebyen> running ubuntu oneiric
15:41:45 <kmc> yeah, there should be a more explicit automatic way to warn beginners about fromJust and head and such
15:41:45 <dobblego> I'm too cool for section school
15:41:47 <kmc> does HLint catch them?
15:41:57 <ion> I completely agree, i just didn’t think what it actually returns. :-)
15:42:04 <Peaker> kmc, dobblego: So it turns out even when you use the compr. feature, the points free is nicer :)  But you could say it's because of the existence of maybeToList
15:42:09 <yebyen> JoeyA: you cabal install haddock?
15:42:14 <kmc> yeah
15:42:24 <JoeyA> It worked for me.
15:42:28 <dobblego> Peaker: you could replace maybeToList with Foldable.toList I think
15:42:34 <kmc> Peaker, it's more convenient when you're using it on your own types and haven't written a whole library of conversions and foomorphisms for those types
15:42:39 <yebyen> hmm
15:42:46 <Peaker> @type (Data.Foldable.toList =<<)
15:42:47 <lambdabot> forall (t :: * -> *) b. (Data.Foldable.Foldable t) => [t b] -> [b]
15:42:51 * ddarius doesn't really care much for list comprehensions.  If they were removed from the language, I would not shed a tear.
15:42:54 <kmc> iirc, Uniplate is based around this pattern-match-failure behavior
15:42:58 <Peaker> dobblego: nice :)
15:43:00 <kmc> (PMFINAE?)
15:43:15 <kmc> ddarius, but what about "do"? and what about do + fail
15:43:18 <yebyen> JoeyA: no issues? what system, did you compile your own ghc?
15:43:25 <Peaker> kmc: btw, my awesomeness threshold may be lower now as I've been doing allnighters of programming C for a long while now :)
15:43:39 <kmc> i'd like to move "fail" to its own class (wasn't it that way in H1.4?)
15:43:58 <ddarius> kmc: I'd probably miss do but not very much.  I certainly use do quite a bit more than list comprehensions.
15:44:06 <JoeyA> Though my experience with cabal tends to be like this: 1) Install some packages 2) Be happy for a while 3) Get an install failure involvingdirectory-1.1.0.0 and Cabal-1.10.1.0 4) Nuke my ~/.cabal from orbit and start over.
15:44:16 <ddarius> kmc: They use MonadZero and mzero.
15:44:18 <Peaker> kmc: Not only that, I read in the mythology that Awesome Haskell 1.4 had a separate MonadZero from MonadPlus, and that "do" which had pattern match failures had MonadZero constraint rather than Monad constraint
15:44:26 <kmc> yeah
15:44:35 <kmc> but mzero won't take an error message, which is sometimes useful
15:44:40 <yebyen> JoeyA: Couldn't match expected type `(AlexPosn, Char, [Byte], String)' with actual type `(t0, t1, t2)' AlexInput vs (t0,t1,t2)
15:44:51 <JoeyA> yebyen: You could try installing an older version of alex, I suppose.
15:44:52 <yebyen> JoeyA: don't really know how to interpret that, other than versions don't mix...
15:45:00 <kmc> (but maybe it's only really useful for fail = error, which you'd omit instead)
15:45:05 <JoeyA> Though my ghc-pkg list doesn't list an alex
15:45:11 <Saizan> JoeyA: it doesn't make sense to remove ~/.cabal/ you should remove ~/.ghc/ instead
15:45:24 <ddarius> kmc: But arguably the message that the pattern match failure will provide isn't too useful, and you can easily use throwError for the other cases.
15:45:25 <Peaker> what's the advantage of comprehensions putting the final result expression first?  It's nice to have syntax to avoid the do overhead ({} and return) but I am not sure I like mathematical notation here
15:45:25 <JoeyA> I might have done that too
15:45:31 <yebyen> JoeyA: I don't know how to do that... there was an alex in haskell-platform, maybe i shouldn't try to install from cabal
15:45:45 <kmc> "it's what Python does"
15:45:52 <kmc> also, yeah, maths
15:46:03 <JoeyA> When I do ghc-pkg list, I don't see alex for some reason.  Maybe I need to add a switch.
15:46:11 <kmc> alex is a tool, not a library
15:46:11 <Peaker> kmc: It could be sane to allow an optional error message in MonadZero (so you can either implement mzero or fail that is semantically equivalent/cannot be distinguished, but has debug info attached)
15:46:18 <yebyen> JoeyA: I don't see it either... no idea
15:46:27 <kmc> (or maybe it's both)
15:46:40 <scooty-puff> what happens if a finalizer for a foreign ptr throws an error?
15:46:58 <yebyen> kmc: so how do you list it? (and remove it)
15:47:03 <kmc> dunno
15:47:10 <kmc> alex --version
15:47:19 <kmc> rm $(which alex)
15:47:37 <JoeyA> Alex version 2.3.5
15:47:59 <JoeyA> <command line>: can't load .so/.DLL for: ncursesw (/usr/lib/libncursesw.so: file too short)
15:48:07 <JoeyA> That's a problem I got trying to install yi.
15:48:19 <yebyen> JoeyA: i'll try that version, hopefully it will just overwrite the old (new) version 3.0.5
15:48:25 <kmc> yeah, your libncursesw.so is a linker script
15:48:42 <kmc> you should edit yi.cabal to specify the name of whatever the 'real' nurses library is
15:49:33 <JoeyA> What's a good way to do that?  Unpack the tarball in my .cabal directory?
15:49:42 <kmc> cabal unpack yi
15:49:56 <kmc> cd yi-*; vim yi.cabal; cabal install
15:50:39 <JoeyA> It might actually be the terminfo-0.3.2.2 package
15:50:43 <kmc> oh, but maybe... yeah
15:50:57 <kmc> or hscurses
15:51:52 <yebyen> JoeyA: that helped, thanks... haddock compiled this time... now if leksah compiles, i'll be really impressed
15:52:03 <malorie> hi! I'm trying to make (,) an instance of Functor and was wondering what `fmap (+1) (1,1)' should yield? my current solution yields (1,2), I'm not sure though, whether that's correct
15:52:15 <kmc> (,) can't be an instance of Functor; it has the wrong kind
15:52:20 <dobblego> malorie: (,) has the wrong kind, paerhaps you mean ((,) t)
15:52:25 <malorie> dobblego: exactly
15:52:37 <kmc> instance Functor ((,) t) where fmap f (x,y) = (x, f y)
15:52:44 <dobblego> malorie: data MyPair a b = MyPair (a, b); instance Functor (MyPair a) where ...
15:52:50 <malorie> kmc: nice! that's my current solution :-)
15:53:04 <azaq23> @src , fmap
15:53:05 <lambdabot> Source not found. You type like i drive.
15:53:08 <kmc> or you can go with «data Two a = Two a a; instance Functor Two where fmap f (Two x y) = Two (f x) (f y)»
15:53:40 <kmc> @src (,) fmap
15:53:40 <lambdabot> fmap f (x,y) = (x, f y)
15:54:07 <JoeyA> Why can't GHC load linker scripts?
15:55:56 <benmachine> malorie: for each type, there's only one functor instance that works
15:56:07 <stribor> is there way to clear the screen when working with ghci interpreter
15:56:14 <kmc> :! clear
15:56:22 <stribor> something similiar as "clear' for linux command line
15:56:33 <stribor> kmc: thank you
15:56:53 <benmachine> malorie: by "works" I mean satisfies the laws; so if you have a functor instance, and it satisfies the laws, then it is "the" functor instance
15:57:07 <fryguybob> stribor: Ctrl-L might do that (but not on Windows).
15:57:43 <malorie> benmachine: I see. so there is no way to enforce certain semantics, in the type-system, or so?
15:57:44 <stribor> yeah i am running ubuntu....slows me down because i am trying to do everything from command line
15:58:42 <benmachine> malorie: there's no way to enforce the functor laws in the type system, specifically
15:58:48 <benmachine> although
15:58:55 <benmachine> I believe if you prove one of them the other is automatic
15:59:06 * ddarius has never used GHCi, GHC, or vim from anything other than the command line.
15:59:43 <Saizan> yes, fmap id = id is enough to deduce the other
15:59:59 <parcs> JoeyA: you mean ghci?
16:00:26 * ddarius should see if he can show that from a notion of naturality for a strong functor.
16:00:41 <JoeyA> parcs: Compiling also loads things sometimes.  Maybe it is using ghci in there.
16:01:34 <kmc> yeah, Template Haskell code is interpreted the same way as ghci code
16:02:13 <parcs> JoeyA: well the only issue i'm aware of is that of linker scripts and dynamic linking
16:02:41 <parcs> and the reason for that is because
16:02:42 <parcs> r
16:03:24 <parcs> err, anyway, dlopen doesn't support linker scripts, and that's what ghc uses
16:04:04 <JoeyA> Thanks
16:04:08 <JoeyA> So it's not Haskell's fault, then ;-)
16:05:19 <Saizan> should be fixed in the next version of ghc though
16:05:33 <ddarius> Saizan: How'd they fix it?
16:06:22 * ddarius isn't sure the thing Saizan is saying is fixed is the thing that he thinks Saizan is saying is fixed.
16:11:28 <Saizan> ddarius: they added some check for linker scripts in the ghci loader so now they should work with it, iirc
16:12:12 <Saizan> http://hackage.haskell.org/trac/ghc/ticket/2615
16:12:43 <stribor> guys how can you just from reading function type know how many paramethars has and what type it is output
16:14:12 <JoeyA> Where is the manual for yi?
16:14:24 <shachaf> stribor: You can't.
16:14:33 <shachaf> id can have any number of parameters, for instance.
16:15:00 <shachaf> Alternatively (and more accurately): Every function has exactly one parameter, and the type it returns is the thing on the right side of the ->
16:15:00 <byorgey> stribor: to a first approximation, if a function has type  a -> b -> c -> d, then it takes parameters a, b, and c, and outputs type d.
16:15:04 <stribor> how can you know what output it gives
16:15:22 <byorgey> but as shachaf points out it is not actually quite so simple, because the output can itself be a function type.
16:15:24 <malorie> I'm trying to make ((->) t) an instance of Functor as well. `instance Function ((->) t) where fmap f ((->) a b) = ((->) a (f b))' doesn't work though. what am I doing wrong?
16:15:29 <stribor> byorgey: yes thats simple one:)
16:15:35 <malorie> s/Function/Functor/
16:15:43 <byorgey> malorie: ((->) a b) is a type, not a value
16:15:53 <byorgey> values of that type are functions
16:15:59 <stribor> what if its a->b->(c->d)
16:16:55 * shachaf is annoyed that ":i ->" doesn't work in ghci.
16:16:58 <byorgey> stribor: right, so the real answer is that that function takes only one argument of type a, and retuns as its output a function of type  (b -> (c -> d))
16:17:24 <stribor> byorgey: exactly...problem is what if brackets are not specified
16:17:26 <byorgey> now, that output function in turn takes an argument of type b and returns a function of type  (c -> d)... which takes an argument of type c and returns something of type d
16:17:36 <byorgey> stribor: -> associates to the right
16:17:46 <byorgey> stribor: so  a -> b -> c -> d  always means   a -> (b -> (c -> d))
16:18:15 <stribor> byorgey:  so in case you just typed how you read output?
16:18:36 <shachaf> malorie: fmap :: (a -> b) -> f a -> f b; in the ((->) t) instance, fmap :: (a -> b) -> (t -> a) -> t -> b
16:18:44 <shachaf> malorie: So write a function implementing that type.
16:18:58 <malorie> shachaf: I'll give it a try
16:19:20 <byorgey> stribor: intuitively, you can think of it as a function taking three parameters and returning something of type d.  But really, it is a function which takes a single 'a' and returns a function, and so on
16:19:52 <stribor> byorgey: ok
16:21:06 <stribor> byorgey: i read somewhere that you can read function type in this fashion:..how many arrows thats how many input paramethars are
16:21:11 <hpc> the GHC Prelude definition of sortBy is butt-ugly
16:21:28 <kmc> stribor, every function has exactly one input parameter
16:21:31 <hpc> too huge a where-clause and no type signatures
16:21:37 <kmc> stribor, some functions return functions
16:21:39 <stribor> kmc?
16:21:50 <kmc> so «a -> b -> c» means «a -> (b -> c)»
16:21:53 <stribor> i know but input params i am talking about
16:21:59 <kmc> a function that takes 'a' and returns a function of type (b -> c)
16:22:03 <kmc> that's what i'm talking about too
16:22:46 <stribor> well lets say this "drop" function
16:22:57 <stribor> type is Int -> [a] -> [a]
16:23:05 <stribor> takes in Integers and list of type
16:23:11 <stribor> returns list of type a
16:23:12 <stribor> correct?
16:23:21 <kmc> that's a correct shorthand description
16:23:24 <jmcarthur> stribor: take and Int and returns a function from lists to lists
16:23:31 <kmc> «drop 5» is a function of type [a] -> [a]
16:23:39 <kmc> drop :: Int -> ([a] -> [a])
16:23:51 <benmachine> number of arrows = number of parameters doesn't work for functions that *take* functions
16:24:01 <jmcarthur> you're rule is okay except for higher order functions
16:24:03 <shachaf> drop :: let res = [a] -> [a] in Int -> res
16:24:03 <jmcarthur> :t map
16:24:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:24:05 <jmcarthur> *your
16:24:09 <kmc> stribor, and when you call it, «drop 5 xs» means «(drop 5) xs»
16:24:17 <stribor> oh ok ...i se what you mean
16:24:47 <jmcarthur> if you apply your rule to the map function then it would say that map expects three arguments, but it really only expects "two" (really just one, as we said, but speaking informally it's nonetheless okay to pretend we have multiargument functions)
16:25:12 <stribor> jmcarthur: yes thats what i mean    for example
16:25:17 <kmc> for map i prefer to think of (a -> b) -> ([a] -> [b])
16:25:26 <jmcarthur> me too
16:25:46 <kmc> turns a function on elements into a function on lists, whether or not you immediately use that function on lists
16:25:51 <stribor> for map i would say that map takes function and list as parametars
16:25:54 <stribor> is that wrong?
16:26:01 <jmcarthur> stribor: the nice thing is that you can shift the way you think about functions as is convenient. it's okay to think of map as a function of one argument *or* as a function of two
16:26:13 <kmc> stribor, it's not wrong exactly, but it's an oversimplification
16:26:21 * shachaf likes to think of id as a function of all the arguments.
16:26:25 <kmc> map takes a function of type (a -> b) and returns a function of type ([a] -> [b])
16:26:34 <kmc> i feel like we just went through this with "drop"
16:26:37 <shachaf> Or 3! 3 is a great function.
16:26:43 <stribor> kmc: yes....but in reality when you want to run mapo
16:26:44 <jmcarthur> > 3 "foo"
16:26:45 <lambdabot>   3
16:26:46 <stribor> you have to give it
16:26:49 <stribor> one function
16:26:50 <shachaf> > 3 id 5 "hello" (text "arguments go here")
16:26:51 <stribor> and one list
16:26:51 <lambdabot>   3
16:26:54 <kmc> > let g = map succ in g "abcd"
16:26:55 <lambdabot>   "bcde"
16:26:59 <kmc> stribor, ^^^^ no you don't
16:27:07 <stribor> map (someFunction) myList
16:27:08 <kmc> also, don't think about "running" functions
16:27:24 <jmcarthur> stribor: what does it mean to "run map"?
16:27:33 <stribor> jmcarthur: execute it
16:27:39 <jmcarthur> stribor: what does that mean?
16:27:40 <shachaf> kmc: But... instance Monad ((->) r)!
16:27:50 * shachaf can *so* run a function, man.
16:27:55 <stribor> jmcarthur: want function to give me some output
16:28:07 <kmc> stribor, then «map succ» has given you some output
16:28:10 <kmc> that output is another function
16:28:40 <kmc> maybe you're confused because you can't print functions in GHCi
16:28:42 <stribor> map succ.....what is that "output function"
16:28:56 <kmc> > (map succ) [1,3,4]
16:28:57 <jmcarthur> stribor: "map succ" is just a value. nothing has to "run" to get it
16:28:57 <lambdabot>   [2,4,5]
16:29:25 <kmc> while you can't print functions, that's not a very fundamental problem... they're still values
16:29:38 <jmcarthur> stribor: if i bind that to a variable called x, x is just map succ
16:29:51 <stribor> well you cant print function in any laguage
16:30:00 <kmc> there are some where you can
16:30:05 <stribor> if i have for loop inside some c- functions
16:30:07 <jmcarthur> stribor: if i bind  map succ [1,2,3]  to x, x is just  map succ [1,2,3]
16:30:09 <stribor> i can print values
16:30:12 <stribor> but not function
16:30:22 <kmc> functions are values in Haskell, though
16:30:34 <jmcarthur> stribor: nothing says x has to be [2,3,4] (although that is also a valid representation for map succ [1,2,3])
16:30:38 <shachaf> stribor: You can print functions in some languages!
16:31:06 <stribor> shachaf: not that i knowq
16:31:58 <malorie> benmachine, shachaf: thanks! I've got it to work. `instance ((->) t) Functor where fmap f g = f . g' that was pretty hard to figure out, imo. given, I was heading in the wrong direction..
16:32:28 <shachaf> @src .
16:32:28 <lambdabot> (f . g) x = f (g x)
16:32:29 <lambdabot> NB: In lambdabot,  (.) = fmap
16:33:14 <benmachine> malorie: http://blog.tmorris.net/20-intermediate-haskell-exercises/ this might be interesting for you
16:33:21 <malorie> I was constantly trying to do something like `fmap f (\t -> a) = (\t -> (f a))' :-)
16:33:32 <jmcarthur> @let printFun f = print $ map (id &&& f) [minBound..maxBound]  -- for some functions, prints enough information to be able to recreate that function later
16:33:33 <lambdabot>  Defined.
16:33:48 <jmcarthur> > printFun (succ :: Bool -> Bool)
16:33:49 <lambdabot>   <IO ()>
16:33:51 <malorie> benmachine: thanks
16:33:56 <jmcarthur> oh duh, no IO in lambdabot
16:34:11 * hackagebot LTree 0.1 - Tree with only leaves carrying the data.  http://hackage.haskell.org/package/LTree-0.1 (RahulGopinath)
16:34:57 <benmachine> @let showFun f = show $ map (id &&& f) [minBound .. maxBound]
16:34:58 <lambdabot>  Defined.
16:35:05 <benmachine> > showFun not
16:35:07 <lambdabot>   "[(False,True),(True,False)]"
16:35:42 <jmcarthur> > text $ showFun not
16:35:44 <lambdabot>   [(False,True),(True,False)]
16:35:48 <jmcarthur> yay fake IO
16:35:51 <benmachine> :P
16:38:19 <Peaker> does the Monad instance of (ContT r m) really depend on the monad instance of "m"? It seems ContT r m a = Cont (m r) a   and can use the same instance which doesn't need that Monad instance?
16:38:53 <ddarius> Peaker: No.
16:39:01 <jmcarthur> doesn't need it
16:39:13 <jmcarthur> you need it when you "run" it though
16:39:16 <ddarius> It doesn't depend on anything about m at all.
16:39:32 <Peaker> jmcarthur: that's up to you, isn't it? You get your "m r" and go about your way
16:39:35 <jmcarthur> right
16:39:47 <Peaker> ddarius: ah, so ContT isn't really a monad transformer?
16:39:52 <jmcarthur> sure it is
16:39:56 <ddarius> Peaker: It is a monad transformer.
16:39:58 <jmcarthur> it takes any monad and makes a monad
16:40:01 <Peaker> well, it is, but it is not specific to transforming monads
16:40:33 <benmachine> instance Monad (ContT r m) -- Defined in Control.Monad.Trans.Cont
16:40:36 <benmachine> no context
16:41:13 <Peaker> ah, cool :)
16:41:24 <Peaker> I thought maybe I was missing some different behavior with ContT vs. the Cont instance
16:41:34 <Saizan> "lift" needs the Monad context though
16:41:37 <ddarius> ContT r m a = Cont (m r) a
16:41:43 <benmachine> Peaker: the reason why ContT exists, I think, is for kind reasons
16:41:52 <benmachine> e.g. you can write a MonadTrans instance for ContT r
16:41:55 <Peaker> ddarius: Yeah, I've always known the type structure matches that -- I wasn't sure if the monad instances also do
16:42:07 <Peaker> benmachine: yeah -- and due to what Saizan said..
16:42:15 <Peaker> I was just trying to write the MonadTrans instance to figure it out myself
16:42:20 <Peaker> (alt-tabbing there :)
16:43:43 <Peaker> Yeah: lift action = ContT $ (action >>=)
16:43:57 <ddarius> Peaker: You can just look at the definition of (>>=) and return and see that they are the same.
16:44:17 <Peaker> ddarius: Yeah, it's what I did, though I just wrote them myself for both and saw that it works out
16:44:24 <Peaker> (more educational that way, I think)
16:44:38 <Peaker> Wanted to make sure I'm not making some big misunderstanding on the road
16:45:31 <ddarius> I wouldn't say that they "work out" to be the same.  They should be literally the same code (except Cont/runCont being replaced with ContT/runContT.)
16:45:56 <Peaker> ddarius: Yeah, I meant that I actually used the same code -- to see that it type-checks
16:46:55 <Peaker> I was thinking whether it is possible to make a Bracket monad around ContT to weaken it just to support bracket nesting -- but I'm not sure if it's practical.. if runBracket exposes the internal structure, you get all the power of ContT again
16:47:48 <Peaker> Another alternative, is to stick with the type for bracket/etc (which is perhaps too powerful?) and then using bracket combinators like:    nested = runContT . sequence . map ContT      (convert to ContT and back to get the existing combinators)
16:48:17 <Peaker> hlint in my head is saying: runContT . mapM ContT :-)
16:49:38 <benmachine> :)
16:49:50 <copumpkin> that's a handy function
16:50:40 <Peaker> @type runContT . mapM ContT
16:50:41 <lambdabot> forall r (m :: * -> *) b. [(b -> m r) -> m r] -> ([b] -> m r) -> m r
16:51:44 <copumpkin> @type runContT . mapM ContT . map withCString
16:51:44 <lambdabot> Not in scope: `withCString'
16:51:47 <Peaker> I had a little TODO list of implementing the "nested" combinator (now done) and my next item is implementing a typed two-way parsing/building library (like pickler combinators) that supports wire-formats
16:52:04 <Peaker> @index withCString
16:52:04 <lambdabot> Foreign.C.String, Foreign.C
16:52:04 <mgsloan> hello! is there a good way to recompile all of your cabal after updating your GHC?
16:52:19 <Peaker> @let nested = runContT . mapM ContT
16:52:21 <lambdabot>  Defined.
16:52:36 <Peaker> @type nested . map Foreign.C.withCString
16:52:37 <lambdabot> forall r. [String] -> ([Foreign.C.String.CString] -> IO r) -> IO r
16:52:57 <Saizan> mgsloan: "cabal install world" might work
16:53:08 <Peaker> hmm.. you could think of "nested" as mconcat in some Monoid, too.. and then re-use mconcatMap
16:53:18 <benmachine> foldMap
16:53:24 <Peaker> Yeah
16:53:24 <benmachine> I think it's called
16:53:44 <hpc> :t nested
16:53:45 <lambdabot> forall b (m :: * -> *) r. [(b -> m r) -> m r] -> ([b] -> m r) -> m r
16:53:47 <mgsloan> Saizan: it looks like that's doing it sofar! thank you!
16:53:48 <Peaker> I guess you couldn't though, the types don't add up
16:54:03 <jmcarthur> writing reasonable instances for MonadFix or ArrowLoop can be frustrating :\
16:54:19 <jmcarthur> at least for me
16:54:24 <Peaker> jmcarthur: When is MonadFix useful?
16:54:46 <Peaker> I saw "forward labels" and "do blocks" for electrical circuits as two examples
16:54:53 <jmcarthur> i've used mfix a few times, but mostly with IO
16:54:54 <Peaker> but neither is very compelling
16:55:32 <jmcarthur> in this case i'm fiddling around with some AFRP stuff
16:56:50 <Peaker> I thought about context-free grammar parsing via Applicative -- and you need a fix combinator so that the recursion is visible to the parser builder, if you are to compile the parser to an efficient automaton.. So maybe it makes sense to have:  class ApplicativeFix f where  fixA :: (f a -> f a) -> f a      (and it's distinct from fix)
16:56:52 <benmachine> I once tried to use mfix to make a reverse-state-monad transformer
16:56:58 <benmachine> that was probably inadvisable
16:57:12 <jmcarthur> heh
16:57:19 <benmachine> Peaker: does that really need to be a class?
16:57:29 <jmcarthur> when is a reverse-state-monad transformer useful? ;)
16:57:30 * copumpkin throws a party for kmc
16:57:34 <Peaker> benmachine: of course not, but it sounds like it may be more generally useful
16:57:45 <hpc> jmcarthur: when you don't want your code to be understood by java coders
16:57:48 * jmcarthur throws kmc for a party
16:58:03 <Peaker> benmachine: I have no idea.. if I actually implemented it, I'd probably start out with a specialized combinator for the parser type
16:58:04 <hpc> :t mfix
16:58:04 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
16:58:05 <benmachine> jmcarthur: someone genuinely asked for one in here once, but I think the answer was "this is what you want, but this is not what you want"
16:58:36 <copumpkin> Peaker: that type seems wonky
16:58:49 <Peaker> copumpkin: what's wonky? :)
16:58:50 <jmcarthur> my type is sufficiently complicated that i'm making this instance by starting with a greatly simplified version of it as gradually adding complexity back. i hope this approach works
16:58:53 <hpc> why is the Maybe instance for MonadFix defined the way it is? -- http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Fix.html#mfix
16:59:00 <jmcarthur> s/as/and/
16:59:01 <copumpkin> Peaker: your type for fixA
16:59:09 <jmcarthur> yeah i hate that maybe instance
16:59:11 <Peaker> copumpkin: nm I ran "define:wonky" :)
16:59:24 <jmcarthur> i suspect the justification is that you have to be careful using mfix anyway
16:59:27 <benmachine> hpc: it has to be that way, to avoid being too strict
16:59:30 <hpc> couldn't it be something like mfix f = let a = f =<< a in a
16:59:31 <hpc> ?
16:59:36 <benmachine> and actually iirc you can't possibly hit the error case
16:59:44 <benmachine> hpc: I suspect that's always _|_
16:59:45 <Peaker> copumpkin: consider the type of a recursive context-free parser.. the parser itself is some: Parser a,  and it wants to use itself, a Parser a
16:59:55 <benmachine> since >>= for Maybe is strict in the first argument
17:00:04 <hpc> ah right
17:00:38 <Peaker> copumpkin: if you use "fix" the structure of the parser becomes opaque
17:00:42 <copumpkin> Peaker: sure
17:00:54 <copumpkin> but why (f a -> f a)?
17:01:17 <Peaker> copumpkin: (Parser a -> Parser a)  (generalized preemptively :)
17:01:45 <Peaker> copumpkin: what other type would you expect?
17:02:12 <benmachine> hpc: if f needs to pattern-match its argument before yielding a constructor, i.e. f is strict, then mfix is _|_ anyway
17:02:37 <hpc> benmachine: im still confused
17:02:37 <hpc> benmachine: unJust is still strict
17:02:40 <hpc> @src Maybe (>>=)
17:02:42 <benmachine> hpc: otherwise, f must yield a constructor before pattern-matching its argument; if that's Nothing, f can't do anything else, and we're done; otherwise we're fine
17:03:08 <hpc> > mfix (const Nothing)
17:03:19 <hpc> lambdabot?
17:03:21 <lambdabot> (Just x) >>= k      = k x
17:03:21 <lambdabot> Nothing  >>= _      = Nothing
17:03:22 <lambdabot>   Nothing
17:03:44 <copumpkin> Peaker: something closer to mfix's type?
17:03:47 <benmachine> mfix (const Nothing) = let a = const Nothing (unJust a) in a = let a = Nothing in a = Nothing
17:03:53 <benmachine> er
17:03:56 <hpc> > let mfix f = fix (f =<<) in mfix (const Nothing)
17:03:58 <benmachine> to clarify
17:03:59 <copumpkin> Peaker: it's pretty unusual to get an "f a" as input
17:04:00 <lambdabot>   mueval-core: Time limit exceeded
17:04:03 <hpc> oh, i see
17:04:11 <benmachine> mfix (const Nothing) ==> let a = const Nothing (unJust a) in a ==> let a = Nothing in a ==> Nothing
17:04:24 <hpc> > let mfix f = fix (>>= f) in mfix (const Nothing)
17:04:28 <lambdabot>   mueval-core: Time limit exceeded
17:04:31 <hpc> oh derp, that's the same
17:04:45 <benmachine> :)
17:05:36 <hpc> (>>=) has to keep looking at Nothing with every bind, to see what it is
17:05:42 <benmachine> yep
17:06:25 <Peaker> copumpkin: but for the Parser case I don't think any other type works
17:06:29 <hpc> now i wanna see if unJust ever hits the error case
17:06:44 <Peaker> copumpkin: The parser may need to call itself multiple times
17:07:07 <benmachine> hpc: it doesn't, for reasons outlined above
17:07:16 <Peaker> copumpkin: Maybe (a -> f a) -> f a     could be made to work, but it's going to require a lot of encoding, I think
17:07:22 <copumpkin> Peaker: how about mutual recursion?
17:07:23 <Peaker> English "Maybe" there, not the type
17:07:30 <Peaker> copumpkin: example type?
17:07:39 <copumpkin> Peaker: I guess you could nest those somehow
17:07:56 <Peaker> copumpkin: yeah, that just occurred to me too, that's what I meant by "a lot of encoding"
17:08:03 <Peaker> copumpkin: because the structure isn't nested, really
17:08:14 <ion> @type unJust
17:08:15 <lambdabot> Not in scope: `unJust'
17:08:17 <Peaker> so you're going to have to encode flatness on top of that nestedness
17:09:13 <jmcarthur> > mfix $ const Nothing
17:09:14 <lambdabot>   Nothing
17:09:27 <copumpkin> :t fix . (>=>)
17:09:28 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
17:09:33 <benmachine> all MonadFix instances look kind of scary
17:09:35 <jmcarthur> > mfix $ \x -> Just (1:x)
17:09:36 <lambdabot>   Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:09:43 <benmachine> apart from fixIO which I think I understand
17:09:44 <Peaker> I was disappointed when there was no nice Applicative-based fast-parser package
17:09:50 <copumpkin> ski showed me that
17:09:51 <benmachine> and the function one which is relatively straightforwad
17:09:56 <hpc> benmachine: yeah, trying to figure out fixIO now
17:10:44 <hpc> oh my, the source for that function is eeeeeeevil
17:11:24 <benmachine> ah, interestingly you *can* hit the error case for MonadFix (Either e)
17:12:14 <Saizan> hard to prevent that
17:12:25 <hpc> fixIO throws a loop exception if you give it a function that evaluates the parameter ever
17:12:44 <bgamari> Why does Control.Monad.when only work with IO monads with no return value?
17:12:45 <benmachine> hpc: where's fixIO defined?
17:12:49 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#fixIO
17:13:07 <hpc> :t when
17:13:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:13:08 <Saizan> not really "ever"
17:13:21 <benmachine> hpc: no this is where the unsafeInterleaveIO comes in
17:13:31 <Peaker> bgamari: the word "monad" refers to the type.  The "IO" type is a monad.  "IO a" is not a monad.. it's often called an "action"
17:13:33 <benmachine> it just needs to evaluate less than it writes, like fix
17:13:45 <ion> bgamari: What should it result in in the false case otherwise?
17:13:54 <bgamari> Peaker: Alright, s/IO monads/actions
17:13:55 <Peaker> bgamari: so the question is why "when" only works with actions that yield ()
17:14:08 <Peaker> bgamari: well, "when" is like an "if" with no "else" clause, right?
17:14:17 <bgamari> ion: Alright, I see the issue
17:14:42 <hpc> benmachine: can you come up with an example of fixIO working with getLine and putStrLn? i am at a loss
17:15:53 <bgamari> Peaker, ion: Thank you
17:16:44 <Peaker> bgamari: note that in many other languages (e.g: C) an "if" always takes actions that yield (), even when it has an "else"
17:17:47 <benmachine> hpc: I've had the brilliant idea of finding an example with forkIO; brb, forkbombing self
17:18:00 <monochrom> fixIO is the concrete name of mfix for IO
17:18:11 <monochrom> therefore it will not forkbomb
17:18:19 <benmachine> oh, you've got a point
17:18:41 <monochrom> main = do { mfix (\_ -> putStrLn "hi") }   count how times the effect happens!
17:18:43 <Peaker> mfix is supposed to only "execute" the action once?
17:18:52 <Peaker> and cause a "loop" only in the pure value side?
17:19:06 <monochrom> yes. it is supposed to ty values only
17:19:11 <jmcarthur> seems like most of my uses for fixIO have been to create IORefs containing actions which themselves depend on the IORef
17:19:15 <benmachine> monochrom is right
17:19:38 <ddarius> Peaker: mfix is exactly what letrec and such from imperative languages translates to (albeit usually letrec must be guarded by an abstraction which makes it a bit trivial.)
17:19:39 <hpc> it's supposed to ty?
17:19:42 <Peaker> jmcarthur: the "OO trick"?
17:19:42 <monochrom> see my http://www.haskell.org/haskellwiki/MonadFix
17:19:46 <Saizan> hpc: tie
17:20:07 <jmcarthur> Peaker: just creating actions that only execute once
17:20:19 <Peaker> ddarius: I haven't used letrec in other languages... Only read some code that did. But not enough to develop an intuition about the effects
17:20:41 <Peaker> jmcarthur: yeah, I saw it a lot when using "mfix" to get a "self" parameter which contains the IORefs
17:20:46 <Peaker> (Mainly in Oleg's stuff)
17:20:48 <jmcarthur> Peaker: basically like a thunk. IORef initially contains an action that, when executed, rewrites the value in the IORef to just return the result, and then returns the result
17:20:54 <jmcarthur> ah
17:21:01 <jmcarthur> yeah that sounds about right i guess
17:21:06 <Peaker> I didn't like Oleg's OOHaskell much
17:21:25 <monochrom> newtype X = X (IORef X); circle :: IO (IORef X); circle = fixIO (\x -> newIORef x)   a node that points to itself
17:21:27 <hpc> oh i see now
17:21:29 <ddarius> If you saw (letrec x = print "hi" in x) in an eager, impure language would your first expectation be that print "hi" would execute more than once?
17:21:46 <monochrom> err sorry, circle = fixIO (\x -> newIORef (X x))
17:21:55 <hpc> ddarius: my first expectation would be that i not understand the language :P
17:22:06 <ddarius> (Actually, I guess my wording is adequate regardless of evaluation order.)
17:22:12 <Peaker> ddarius: well, if "x" appeared inside an expression that is an argument to print maybe I would be confused to think that
17:22:40 <Peaker> I don't see the point of poorly emulating poor languages in a nice language.. except to "show you can" ("my language is more powerful than yours")
17:22:42 <cgroza> Can anyone tell me what () means in a monad context. Like in Maybe () or IO ()L
17:22:47 <hydo> What would the 'right way' be to convert from Double to Data.Text ?  I've been using (T.pack . show) but I'm getting weird formats suddenly.  ie. 1.01 going to 1.0e-200 etc.
17:22:51 <Peaker> cgroza: same thing it means in all contexts
17:23:06 <cgroza> Peaker: as empty tuple?
17:23:14 <Peaker> cgroza: yeah.. also called a "unit type"
17:23:23 <monochrom> the type () has only one value, also called ()
17:23:25 <jmcarthur> cgroza: it just means that the only value you can bind from it is ()
17:23:41 <monochrom> yes it's a bit annoying that the type and some of its values use the same name
17:23:41 <Peaker> cgroza: it has 1 value (),  and the possibility of not-yielding-a-value ("bottom") but that's less important
17:23:49 <ddarius> Peaker: Haskell is not more powerful than theirs and the point is that "imperative" letrec is useful.  mfix wasn't added to show up other languages.
17:23:58 <cgroza> Thanks
17:24:08 <Peaker> ddarius: I'm not talking about "mfix" in that statement... I'm talking about Oleg's OOHaskell paper
17:24:42 <ddarius> Peaker: My mistake.
17:25:01 <Peaker> ddarius: I made it unclear, saying it after the followup there
17:25:08 <Peaker> ddarius: What did you think of OOHaskell?
17:25:46 <dmwit> hydo: There's a package.
17:25:49 <dmwit> hydo: one sec, let me find it
17:25:57 <monochrom> actually fixIO may be useful for imperative OO too. let the crosstalk fly...
17:26:04 <Peaker> I think it does make a point about Haskell's power (manages to create a DSL that seems to beat some OO languages in their own game.. but their game stinks :) )
17:26:17 <dmwit> ?hackage double-conversion
17:26:19 <dmwit> hydo: There
17:26:28 <dmwit> ?botsnack
17:26:32 <monochrom> @bots
17:26:35 <monochrom> whee
17:26:39 <dmwit> whumph
17:26:47 <dmwit> hydo: http://hackage.haskell.org/package/double-conversion
17:27:21 <byorgey> :]
17:27:29 <dmwit> Hiya, byorgey!
17:27:39 <byorgey> hiya dmwit
17:27:41 <byorgey> !
17:28:24 <dmwit> [!](http://www.youtube.com/watch?v=2P5qbcRAXVk)
17:28:30 <lambdabot> http://hackage.haskell.org/package/double-conversion
17:28:30 <lambdabot> :)
17:28:30 <lambdabot> :)
17:28:47 <byorgey> hehe
17:29:19 <byorgey> that's a nice arpeggiated diminished chord there
17:29:28 <ddarius> Peaker: The basic ideas had been around for quite awhile.  The elaboration of those basic ideas in OOHaskell is mostly too cumbersome to use.
17:29:28 <ddarius> The comparisons with O'Caml's object system was mostly to validate that it was "really" OO.
17:29:28 <ddarius> It's quite easy to make systems/encodings that are not capable of doing everything that is expected of an OO system.
17:29:57 <hydo> yay!  thanks dmwit
17:32:40 <monochrom> virtual'particle = mfix (\t -> forkIO (killThread t))  creates one thread that kills itself.
17:33:48 <monochrom> actually I should carefully check the doc for the semantics of killThreading oneself
17:34:18 <ddarius> monochrom: What are you worried about?
17:34:47 <mm_freak_> monochrom: i'm very sure that loops
17:35:19 <monochrom> killThread is supposed to block and wait. well I guess during the wait, the exception arrives, and that ends it all
17:35:33 <mm_freak_> yes, it does loop
17:35:49 <monochrom> how do you know it loops
17:36:00 <mm_freak_> i tried it
17:36:09 <JoeyA> Doesn't loop for me
17:36:16 <JoeyA> (in GHCi)
17:36:17 <monochrom> yes I mean what observations lead you to your conclusion
17:36:28 <JoeyA> It just returns thread IDs
17:36:35 <monochrom> and how do you know there is no other explanation
17:36:38 <mm_freak_> hmm, no, it doesn't…  i'm not sure i'm expressing the same thing with DoRec
17:36:49 <mm_freak_> the mfix variant works
17:36:55 <mm_freak_> > do rec { t <- forkIO (killThread t) }; return ()
17:36:55 <mm_freak_> <interactive>: <<loop>>
17:36:56 <lambdabot>   Not in scope: `forkIO'Not in scope: `killThread'
17:39:17 <mm_freak_> why does it work with mfix, but not with DoRec?
17:40:08 <JoeyA> In AttoParsec, is it a legitimate pattern to produce an error with empty <?> "Error message" ?
17:40:30 <JoeyA> Attoparsec
17:40:40 <mm_freak_> JoeyA: sure
17:41:08 <JoeyA> thanks
17:41:39 <monochrom> interesting
17:44:39 <mm_freak_> is it possible that mfix is more expressive than DoRec?
17:44:51 <mm_freak_> i can't get it to work with DoRec
17:45:24 <mm_freak_> interestingly in the DoRec variant it's the child thread, which loops
17:45:43 <monochrom> rec is translated to mfix
17:46:19 <benmachine> mm_freak_: sounds nondeterministic to me
17:46:57 <mm_freak_> monochrom: sure, but can every mfix computation be expressed in terms of DoRec?
17:47:12 <monochrom> I don't know. but this one can
17:47:33 <mm_freak_> is it different from my variant?
17:47:39 <monochrom> no
17:47:40 <mm_freak_> > do rec { t <- forkIO (killThread t) }; return t
17:47:40 <mm_freak_> <interactive>: <<loop>>
17:47:40 <mm_freak_> ThreadId 668
17:47:41 <lambdabot>   Not in scope: `forkIO'Not in scope: `killThread'
17:47:42 <benmachine> I bet if you put in some threadDelays it wouldn't loop
17:48:02 <mm_freak_> benmachine: indeed
17:48:13 <mm_freak_> the threadDelay solved it
17:48:22 <mm_freak_> in fact a simple 'yield' solved it
17:54:26 <JoeyA> What's a good way to create Infinity and NaN as literal numbers?
17:54:31 <JoeyA> > (1/0, 0/0)
17:54:32 <lambdabot>   (Infinity,NaN)
17:54:39 <JoeyA> Just do that?
17:55:03 <ddarius> Yes.
17:55:04 <parcs> depending on what you want to do, isNaN and isInfinity might suffice
17:55:16 <JoeyA> I don't want to compare, I want to form literals.
17:55:33 <JoeyA> I'm parsing the possibility of Windows-style literals like 1.#INF
17:55:44 <JoeyA> (which I've spotted in production data)
17:56:29 * ddarius is not sure that translating it to Infinity is the best resolution...
17:57:19 <ddarius> Admittedly, there is likely no clean resolution.
17:57:52 <JoeyA> I'd rather paint the bike shed brown for now.
17:58:35 <ddarius> JoeyA: This isn't a bikeshedding issue.
17:59:23 <JoeyA> Why not?
18:00:27 <ddarius> Translating to Infinity and particularly to NaN might be the -wrong- thing to do, not just an unpleasant way of accomplishing something.  But I don't know what you are trying to do.
18:04:14 <monochrom> mfix (\t0 -> forkIO (killThread t0) >>= \t1 -> return t1) will give you the <<loop>> exception. this is the desugared form of the rec block. verified by comparing core
18:07:59 <mm_freak_> monochrom: thanks
18:11:05 <shachaf> monochrom: Isn't that a violation of a monad law?
18:14:12 * hackagebot husk-scheme 3.3 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.3 (JustinEthier)
18:15:13 <kmc> preflex, seen bos
18:15:13 <preflex>  bos was last seen on #haskell 1 day, 2 hours, 27 minutes and 4 seconds ago, saying: AfC: i'm actively writing better docs today
18:19:13 <mm_freak_> monochrom: operationally mfix (forkIO . killThread >=> return) /= mfix (forkIO . killThread)
18:19:34 <mm_freak_> does that have any effect on the monad laws, as shachaf says?
18:22:34 <copumpkin> > map concat . replicateM 4 types
18:22:34 <lambdabot>   Couldn't match expected type `[a]'
18:22:34 <lambdabot>         against inferred type `GHC.Types...
18:22:36 <copumpkin> > map concat . replicateM 4 $ types
18:22:38 <lambdabot>   ["FactoryFactoryFactoryFactory","FactoryFactoryFactoryFacade","FactoryFacto...
18:22:48 <copumpkin> > drop 20 . map concat . replicateM 4 $ types
18:22:50 <lambdabot>   ["FactoryFactorySingletonSingleton","FactoryFactorySingletonVisitor","Facto...
18:22:57 <copumpkin> > drop 200 . map concat . replicateM 4 $ types
18:22:58 <lambdabot>   ["FactorySingletonDelegateSingleton","FactorySingletonDelegateVisitor","Fac...
18:23:38 <copumpkin> > sort . map concat . replicateM 4 $ types
18:23:39 <lambdabot>   ["AdapterAdapterAdapterAdapter","AdapterAdapterAdapterDecorator","AdapterAd...
18:23:51 <copumpkin> :(
18:24:12 * hackagebot monadfibre 0.1 - Monad Transformer to provide Choice and Parallelism.  http://hackage.haskell.org/package/monadfibre-0.1 (AnupamJain)
18:40:10 <fazzone> :t liftA2 (+) (2*) (3+)
18:40:11 <lambdabot> forall a. (Num a) => a -> a
18:41:17 <fazzone> Why does that not work in GHCI?  it complains that it can't find the Functor ((->) r) instance, which is strange, because it must exist somewhere, right?  ((->) r) is Applicative, so mustn't it also be a Functor?
18:43:22 <cmccann> yes, but the instance isn't defined in anything that's imported by default
18:43:34 <fazzone> Where is it defined?
18:43:53 <dalaing> fazzone: works for me in ghci - although I do have Control.Applicative imported
18:44:12 * hackagebot skein 0.1 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1 (FelipeLessa)
18:45:00 <cmccann> the functor instance is in Control.Monad.Instances I think
18:45:04 <cmccann> which clearly makes all kinds of sense
18:45:13 <cmccann> particularly since Functor isn't even required by Monad
18:46:00 <fazzone> so it is!  thanks!
18:46:13 <cmccann> I would expect the instance to be available after importing Control.Applicative, though
18:46:27 <cmccann> since instances are highly contagious
18:47:05 <benmachine> if the Applicative instance is in scope, I'm pretty sure the Functor instance must be
18:47:58 <benmachine> it worksforme
18:49:30 <cmccann> the Applicative instance obviously needs the Functor instance, and as far as I know you should get the Functor instance transitively
18:49:45 <cmccann> due to instances being very contagious, as I said
18:50:09 <monochrom> hehe "contagious"
18:52:25 <benmachine> cmccann: right. the Functor instance must be in scope where the Applicative instance is defined, because of the superclass
18:52:33 <benmachine> and if it's in scope there it's also in scope everywhere that imports there
18:52:46 <benmachine> so my guess is fazzone is either hallucinating, or hit a GHC bug :)
18:53:30 <cmccann> monochrom, it's descriptive and accurate enough, isn't it? ;]
18:54:09 <hpaste_> fazzone pasted “Functor ((->) r) instance?” at http://hpaste.org/51593
18:54:24 <fazzone> that's what I get.  Am I using an outdated version of GHC? (probably)
18:56:18 <cmccann> it works for me, but I'm on a different GHC version and have a bunch of imports in my .ghci that I'm too lazy to remove right now to test this :T
19:05:33 <benmachine> it's a bug in GHC; it goes away when one does :m +Control.Applicative rather than the import
19:05:44 <cmccann> interesting
19:05:58 <benmachine> doesn't seem to happen on my 7.2.1
19:06:33 <benmachine> so I guess it's sorted
19:06:58 <bgamari> What would cause Parsec to misreport line numbers?
19:07:10 <bgamari> Left "(unknown)" (line 13, column 1):
19:07:10 <bgamari> unexpected "%"
19:07:20 <bgamari> Yet the "%" is on line 12
19:07:30 <bgamari> column 1
19:08:10 <djahandarie> Hm, so my current way of monitoring if a machine is alive is using connecTo, then lazy IO reading a few characters from it. I then wrap that in a System.Timeout.timeout. If it returns Nothing, the box is down, otherwise it's up.
19:08:17 <djahandarie> connectTo*
19:09:12 <djahandarie> But timeout has been failing to work for me in certain cases (it doesn't timeout). Does anyone have an idea how I could achieve the same end of checking if a certain service is alive on a remote machine?
19:10:56 <ddarius> Why lazy IO?
19:11:40 <djahandarie> Because I'm lazy.
19:12:45 <djahandarie> Think that could be causing a problem? I'll try changing that part up
19:16:38 <shachaf> Is there a way to import a module from the current directory in ghci?
19:17:26 <monochrom>  :add File.hs
19:18:41 <shachaf> Is there a :remove?
19:19:37 <monochrom>  :load is really a remove-everything then :add
19:20:25 <moriramar> shachaf: :m - xxx
19:21:48 <shachaf> That doesn't seem to work.
19:22:15 <shachaf> :add also removes all definitions.
19:22:21 <shachaf> Why can't I just :m +? :-(
19:37:52 <shachaf> getChar is a function, everybody: http://www.haskell.org/onlinereport/haskell2010/haskellch7.html
19:38:20 <shachaf> (Or http://www.haskell.org/onlinereport/io-13.html , I guess.)
19:39:48 <kmc> haha shachaf
19:39:55 <ddarius> shachaf: Note the verbiage in the following paragraphs: "The getChar operation", "the getLine operation", "the readIO function"
19:40:17 <shachaf> "These functions"
19:40:18 <ddarius> Admittedly, it also says "the read operation from class Read"
19:40:36 <ddarius> shachaf: Yes, it clearly should say "These values"
19:40:45 <ddarius> And the table should be "Input Values"
19:40:56 <ddarius> I'm sure that would be much clearer.
19:41:56 <ddarius> It does consistently use the term "operation" for all values on non-function type, and "function" for all values of function type from the "Input Functions" table.
19:42:40 <shachaf> Maybe "operation" means "something of a monadic type", and they mean "read" in the (r ->) monad.
19:43:11 <ddarius> The ((->) r) instance is not in the Report.
19:43:42 <shachaf> That's true.
19:44:07 <shachaf> (r ->) is still a monad. :-)
19:44:21 <ddarius> read is, however, a method, not a function.
19:45:47 * shachaf wonders why the name "method".
19:46:08 <shachaf> I assume it's not a coincidence that it's the same word as used in OO.
19:46:30 <ddarius> @google how to make ad-hoc polymorphism less ad-hoc
19:46:34 <lambdabot> http://portal.acm.org/citation.cfm?id=75283
19:46:34 <lambdabot> Title: How to make ad-hoc polymorphism less ad hoc
19:46:55 <cmccann> yes, I expect that terms common in OO were chosen deliberately in order to confuse newcomers as much as possible
20:06:52 <shachaf> @botsnakc
20:08:54 <djahandarie> LOOK WHAT YOU DID SHACHAF
20:09:52 <shachaf> djahandarie: :-(
20:11:46 <cbarrett> hello.
20:12:20 <shachaf> Greetings, cbarrett.
20:18:07 <cbarrett> I'm writing a Haskell binding for XPC (which is a new Apple IPC framework). It was coming along pretty well until I started trying to write quickcheck tests for the marshaling code.
20:19:02 <cbarrett> Long story short, it's crashing a whole bunch.
20:19:15 <cbarrett> XPC objects are reference counted and it seems like they're getting deallocated from under the runtime, or at least I've already fixed one bg involving that. :\
20:19:27 <cbarrett> *the haskell runtime.
20:20:00 <Axman6> i was wondering whether it would be possible to write a haskell binding for XPC, glad to see someone is
20:20:53 <cbarrett> it's really quite nice.
20:21:25 <cbarrett> https://github.com/cbarrett/XPC-Calc The project is kind of a mess, I'm planning on cleaning it up a bit more this weekend.
20:21:29 <Axman6> cbarrett: are you using foreign pointers so you can retain the objects at creation/first encountering them, and release them when the GC has determined it's no longer visible?
20:21:35 <cbarrett> Axman6: yup
20:21:48 <cbarrett> the crashing code is in the Quickcheck branch, with all my debugging junk checked in as well.
20:27:55 <cbarrett> sigh.
20:28:00 <cbarrett> internet here is really bad.
20:29:04 <Axman6> hmm, why are you using Ptr and not ForeignPtr?
20:29:45 <cbarrett> for which?
20:30:20 <Axman6> for XPCObject
20:30:36 <cbarrett> Interesting. I hadn't considered that.
20:30:44 <cbarrett> withXPC uses ForeignPtr internally
20:31:55 <cbarrett> Does the FFI support ForeignPtr as a return / argument type for functions?
20:32:27 <Axman6> you should use ForeignPtr so that you can retain the object at creation/when it's received, and the ForeignPtr contains the function for releasing the object when the runtime sees it's gone out of scope
20:32:56 <Axman6> not sure, it's been a while since I've used the FFI, but if not, you should hopefully be able to convert a Ptr into a ForeignPtr
20:33:28 <cbarrett> Axman6: So the latter I'm already doing.
20:34:17 <cbarrett> See for example the Int64 instance of XPCable and the definition of withNewXPCPtr.
20:35:37 * Axman6 would consider turning 'error $ printf "fromXPC: invalid type. Expecting %s (int64), got %s"' into a function inside that module
20:35:55 <cbarrett> Yeah, that whole code is going to get rewritten.
20:37:09 <Axman6> where is Eq for XPCType defined?
20:37:55 <cbarrett> XPCType is Ptr XPC, so it's pointer equality.
20:38:13 <Axman6> should it be pointer equality?
20:38:14 <cbarrett> (Which is what the C API specifies)
20:38:17 <Axman6> ah ok
20:38:20 <Axman6> how odd, heh
20:39:35 <cbarrett> well in the C API it's #define XPC_TYPE_INT64 (&_xpc_type_int64)
20:40:08 <Axman6> ah fair enough
20:40:22 <Axman6> seems odd not to use something like an enum
20:41:18 <cbarrett> I assume that since xpc_type_t is a pointer to a structure they store some capability information there.
20:41:29 <Axman6> do you plan to make it possible to write XPC daemons using just Haskell? (so, the haskell program can call xpc_main)
20:41:36 <cbarrett> Axman6: ya
20:41:41 <Axman6> excellent
20:42:00 <cbarrett> some supporting C functions may be needed until blocks support arrives
20:42:10 <cbarrett> but they should be pretty trivial.
21:02:38 <djahandarie> ddarius, switching to strict IO didn't help.
21:02:59 <ddarius> djahandarie: I didn't think it would make a difference.
21:09:28 <ddarius> djahandarie: So I'm assuming it's just blocking indefinitely when there is no data?
21:10:29 <djahandarie> I just added a bunch of debugging, but it takes awhile for the problem to actually happen. The timeout seems to work even when it is waiting on no data.
21:11:24 <ddarius> So what is the problem?
21:12:26 <djahandarie> Not specifically sure yet, but System.Timeout.timeout sometimes doesn't timeout, the internal IO action just stays alive and blocks everything. When the problem occurs this time around I'll have a little more info.
21:13:13 <djahandarie> I suspect it might be something blocking during the connect, not blocking on lack of data.
21:13:32 <djahandarie> I'll probably dump it into strace and see what's happening soon enough
21:59:28 <mzero> my it's quiet when everyone is in Tokoyo
22:01:03 <glguy_> I think we're in the middle of a net split still
22:01:25 <mzero> oh - that's sad -- I see 309 members - that does look small
22:02:04 <JoeyA> everyone found out how bad Haskell programs leak space.
22:02:09 <JoeyA> jk
22:02:30 <shachaf> mzero: Oh, is *that* where everyone is?
22:02:30 <ddarius> JoeyA: Nah, their clients just crashed due to all the thrashing.
22:02:37 <JoeyA> LOL
22:02:48 <JoeyA> When doing an FFI import of a pure function, is it safe to just say foo :: CInt -> CString?
22:03:03 <JoeyA> (rather than foo :: CInt -> IO CString and using unsafePerformIO)
22:03:47 <mzero> I think so... but I can't help wonder what function Cint -> CString could possibly be pure
22:04:05 <glguy_> the CStrings could come out of a static lookup table
22:04:08 <mzero> One that returns pointers to only constant strings?
22:04:39 <JoeyA> Yes
22:04:42 <JoeyA> Error strings
22:05:34 <mzero> ah, like converting errno to strings - gotcha
22:08:09 <shachaf> Can you do an FFI import as IO (CInt -> CString)? :-)
22:08:39 <shachaf> mzero: Are you aware of the bahaskell meetings, by the way? I don't think I've seen you there.
22:09:15 <mzero> I am aware, but SF meetings mid-week evenings doesn't work for one with small kids :-)
22:09:51 <shachaf> Ah, fair enough.
22:10:06 * shachaf wonders whether to go to the bacat meeting.
22:13:02 <wreel> shachaf: are those meetings welcoming/useful for folks who are new to haskell?
22:13:47 <shachaf> wreel: Of course! You should come.
22:13:53 <shachaf> There's one tomorrow.
22:14:16 <wreel> can't make it if it's tomorrow evening. whereabouts in SF?
22:14:38 <shachaf> EngineYard.
22:14:58 <Volt_> shachaf: Awesome. I'll probably be going, haha.
22:15:19 <wreel> cool, i'll look up the details for the future ones
22:15:33 <shachaf> I don't think there's any talk planned for this meeting -- the plan is some sort of micro-hackathon or something.
22:15:44 <shachaf> wreel: You can subscribe to http://groups.google.com/group/bahaskell
22:15:51 <wreel> sweet, thanks
22:16:20 <wreel> is that the only one in the bay area?
22:16:36 <shachaf> Only Haskell meeting?
22:16:41 <shachaf> As far as I know, yes.
22:16:47 <wreel> k
22:16:56 <wreel> was hoping to avoid traveling into the city haha
22:17:11 <shachaf> Given that the organizer lives in Palo Alto, I assume I'd know if there was one in the south bay.
22:17:14 <wreel> sf, how i loathe thee!
22:17:19 <mzero> at the risk of fracturing -- perhaps we should have one down here!
22:17:25 <shachaf> wreel: Where are you traveling from?
22:17:37 <mzero> we had the Bay Area Hackathon in Mtn. View
22:17:57 <wreel> san mateo, not even far, but my rate of road rage increases non-linearly with every minute spent unsuccessfully finding parking
22:18:15 <shachaf> mzero: A fair number of people come from San Jose/Mountain View/Palo Alto, so it might be possible.
22:18:27 <shachaf> wreel: It's a few blocks from the Caltrain station in SF.
22:18:31 <wreel> oh, that's great
22:25:03 <ddarius> You could consider carpooling.
22:25:48 <shachaf> People usually do, or take the train.
22:27:15 <wreel> gotta run, thanks again for the info
22:33:28 <hpaste_> nyingen pasted “race condition?” at http://hpaste.org/51595
22:34:01 <nyingen> I'm trying to learn the ffi, so I wrote a small C class
22:34:09 <nyingen> and some wrapper functions
22:34:24 <nyingen> strangely, this function I just pasted returns the correct result most of the time, but other times crashes the program
22:34:44 <nyingen> any ideas?
22:35:00 <shachaf> nyingen: More context?
22:35:03 <nyingen> the 'sz' parameter sometimes ends up containing garbage instead of the correct number
22:35:34 <nyingen> shachaf: should I paste the C code as well?
22:35:47 <shachaf> Pasting something runnable, if it's not too big, is usually best.
22:35:51 <nyingen> oh, ok
22:36:06 <shachaf> (Unless you're sure you know where the problem is.)
22:36:29 <nyingen> shachaf: well, there are 3 files. test.h, test.c, and test.hsc
22:36:45 <nyingen> this 'getNewStr' is the only function I'm calling (from ghci)
22:37:23 <shachaf> @paste all three, I guess.
22:37:35 <nyingen> ok, brb
22:39:20 <nyingen> as separate files? or all in the same paste?
22:39:26 <wavewave> hi, everyone.
22:41:35 <wavewave> is anyone familiar with building nexus algorithm?
22:42:57 <nyingen> hm, no option for C language on hpaste
22:43:01 <nyingen> oh well
22:43:09 <shachaf> nyingen: Just put it all in one big paste or something.
22:43:23 <shachaf> Language "" is the best language.
22:44:29 <hpaste_> nyingen pasted “race condition” at http://hpaste.org/51596
22:45:28 <nyingen> calling 'getNewStr' from ghci sometimes returns the correct string, other times crashes the program due to an out-of-memory error (because the 'sz' parameter for packCStringLen) somehow contains garbage
22:45:57 <nyingen> the program is nonsense; I just wanted to test my grasp of #peek etc before attempting an actual project
22:47:55 <glguy_> nyingen: on a 64-bit machine?
22:48:08 <nyingen> glguy_: yes
22:48:13 <nyingen> I was wondering about that
22:48:15 <glguy_> Int in haskell is 64-bit
22:48:18 <glguy_> int in C is 32-bit
22:48:30 <glguy_> packCString takes an Int sz parameter
22:48:37 <glguy_> so your #peek is peeking an Int
22:48:45 <glguy_> You need to specify the type you want sz to be
22:48:48 <glguy_> which is a CInt
22:48:51 <glguy_> and then cast that
22:49:01 <glguy_> The C types are in Foreign.C.Types
22:49:37 <nyingen> hm, ok
22:49:49 <glguy_> #peek only helps you find the correct byte offset
22:50:30 <nyingen> I'm not sure what you mean by 'cast'
22:50:45 <glguy_> :t fromIntegral
22:51:02 <glguy_> well, if lambdabot was here it would show you the type of that cast :)
22:51:11 <nyingen> ah yes, I'm familiar with fromIntegral
22:51:30 <nyingen> so CInt is 32 bits?
22:51:48 <glguy_> It is
22:52:16 <glguy_> unless you tried to run your program on a different architecture where it wasn't
22:52:20 <glguy_> but it almost always is
22:52:34 <nyingen> got it
22:52:37 <glguy_> (and might always be for platforms GHC supports)
22:52:42 <nyingen> any idea why it worked some of the time, and crashed other times?
22:53:00 <nyingen> just out of curiosity
22:53:12 <glguy_> Well, if that struct is aligned then there could be padding between the two fields
22:53:20 <glguy_> alloca probably doesn't initialize the memory
22:53:27 <glguy_> so it would work if the memory you were using was zero filled
22:53:29 <glguy_> and not work otherwise
22:53:33 <glguy_> (my best guess)
22:54:11 <nyingen> I see
22:55:52 <nyingen> so what about the alignment constraint in the Storable instance?
22:56:10 <nyingen> that would also need to correspond to a 64-bit type?
22:57:28 <glguy_> http://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs suggests that you define
22:57:32 <glguy_> #let alignment t = "%lu", (unsigned long)offsetof(struct {char x__; t (y__); }, y__)
22:57:49 <glguy_> to let the compiler actually work it out
22:58:04 <nyingen> ah, neat
22:58:45 <glguy_> The milestone for the "#alignment" feature in hsc2hs is GHC 7.4.1, but I don't know if anyone is actually working on it
22:59:47 <nyingen> I see
23:02:18 <andras> goooooood morning
23:02:49 <andras> I've written a piece of code which isn't as elegant as I'd like it to be -- need help
23:03:06 <andras> I have a simple data type such as this:
23:03:07 <glguy_> Best to start by pasting it to hpaste.org
23:03:38 <andras>   data TestData = TA | T1 | L1 | SX deriving (Show)
23:04:37 <andras> now I'd like to create a way of parsing this type, but if I derive Read too, then the resulting implementation of read is very strict about what it gets
23:05:23 <andras> in particular, if it gets a string that isn't exactly the name of a constructor, then the whole program fails with an error message (not a very verbose one either)
23:05:41 <glguy_> you can detect failure using [reads]
23:06:11 <glguy_> But ideally you should be writing a separate parsing function if you want to have a want to parse the type differently than the Read instance would generate
23:06:24 <glguy_> Read and Show are meant to parse and present data that looks like source code
23:08:02 <andras> glguy_: that's exactly the issue: how do I write such a parsing function elegantly? Now I have something along the lines of a search for a match between the input and a show on each constructor, resulting in a Maybe. But ...
23:08:27 <andras> glguy_: for this, I explicitly duplicate the list of constructors in a list which is mapped over
23:09:12 <andras> glguy_: and, as we know, duplicate code is one instance too much. Is there a way of iterating over all constructors of a type or suchlike, without repeating the constructors in a list (and possibly omitting one or two by accident)?
23:09:20 <glguy_> You can either duplicate the list and write a little parser or you can use the standard Read instance with the [reads] function to avoid asynchronous exceptions halting your program
23:10:10 <glguy_> You can do what you are talking about with Template Haskell (iterating over a list of the constructors), but this is going to be much heavier weight than is appropriate for this case.
23:10:32 <glguy_> Another approach could be to derive Enum for your type and you could use that to produce a list of the constructors and [show] them
23:10:50 <glguy_> Prelude> map show [minBound .. maxBound :: Bool]
23:10:51 <glguy_> ["False","True"]
23:10:54 <glguy_> something like that
23:12:34 <glguy_> Prelude> let readBool x = let xs = [minBound .. maxBound :: Bool] in lookup x (zip (map show xs) xs) in readBool "False"
23:12:34 <glguy_> Just False
23:12:50 <glguy_> Instance "parser" ;-)
23:13:46 <nyingen> glguy_: casting doesn't seem to be helping the situation...would the fact that this is ghc 6.12.1 make any difference?
23:14:14 <glguy_> still attempts to allocate way too much memory?
23:14:34 <nyingen> yeah
23:14:37 <nyingen> only sometimes
23:15:02 <glguy_> and you pasted the whole of the code?
23:15:06 <hpaste_> pelotom pasted “Easy Infix Applicatives!” at http://hpaste.org/51597
23:15:07 <glguy_> or is that an excerpt?
23:15:11 <nyingen> nope, that's everything
23:15:37 <glguy_> can you paste your new version?
23:15:49 <andras> glguy_: thanks a lot, just a minor correction: the type also needs to derive Bounded in addition to Enum
23:16:34 <andras> glguy_: other than that, this is exactly what I was looking for -- I simply love Haskell and this channel...
23:17:04 <shachaf> > read " True " :: Bool
23:18:17 <hpaste_> nyingen annotated “race condition” with “race condition (annotation)” at http://hpaste.org/51596#a51598
23:18:34 <glguy_>       sz <- ((#peek BType, bLen) bt) :: IO CLLong
23:18:38 <glguy_>   int bLen;
23:18:47 <glguy_> These need to match
23:18:54 <nyingen> I guess I'm not understading something about the marshaling of these integral types
23:18:58 <wavewave> pelotom: that's cute.
23:19:22 <nyingen> glguy_: I thought in the previous version 'sz' was inferred to be CInt
23:19:31 <glguy_> nyingen: You've told C that bLen is an int, and you told Haskell that it is a long long
23:19:51 <glguy_> The previous version inferred to be the Haskell type Int
23:19:57 <nyingen> oh, I see
23:20:01 <pelotom> wavewave: :)
23:20:08 <nyingen> glguy_: IO CInt is what I want
23:20:13 <glguy_> correct
23:20:19 <nyingen> that was stupid :)
23:20:24 <nyingen> but hey it's 3am
23:20:44 <nyingen> and now it seems to work
23:21:06 <nyingen> glguy_: appreciate your help. I learned quite a bit here
23:21:26 <glguy_> I'm glad I was able to help.
23:22:58 * hackagebot hobbits 1.0 - A library for canonically representing terms with binding  http://hackage.haskell.org/package/hobbits-1.0 (EddyWestbrook)
23:26:46 <augur> haskelliers!
23:32:58 * hackagebot dtd-text 0.1.1.2 - Parse and render XML DTDs  http://hackage.haskell.org/package/dtd-text-0.1.1.2 (YitzGale)
23:52:59 * hackagebot hmatrix 0.12.0.1 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.12.0.1 (AlbertoRuiz)
23:54:04 <shachaf> @botsnack
23:54:04 <lambdabot> :)
23:57:15 <kmc> boy that was a scary few hours
23:57:22 <kmc> @botsnakc
23:57:23 <lambdabot> :)
23:57:30 <shachaf> kmc: Oh, you were on the Other Side?
23:57:44 <Ptival> the dark side
23:57:46 * shachaf was wondering why the world was gloomier.
23:57:48 <Ptival> only a few people
23:57:53 <kmc> trapped on the dark side of the moon
23:58:07 <kmc> we sent a man to the moon just to watch him die
23:59:49 <DevHC> oh lol there's a "teh" word in some (unfortunately old) ghc manpage
