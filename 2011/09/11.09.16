00:00:18 <ddarius> http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport?action=history
00:00:23 <kmc> where does it say dynamic linking with elf on amd64 is not possible?
00:00:34 <slack1256> mrcarrot: reading
00:01:10 <mrcarrot> kmc: in the beginning it is saying: "Some minor work is required to make it generate position independent code for x86 ELF platforms (Linux and others)"
00:01:27 <kmc> mrcarrot, ok, I must have misinterpreted what you meant by "not possible"
00:01:43 <kmc> anyway as ddarius points out, this page is 2 years old
00:01:56 <erus`> are there many other languages with lazy evaluation ?
00:02:09 <kmc> erus`, strictly (heh) speaking, Haskell doesn't have lazy evaluation
00:02:14 <ddarius> erus`: Not serious languages that have it as a default.
00:02:25 <kmc> erus`, it has non-strict semantics
00:02:35 <erus`> whats the difference ?
00:02:41 <kmc> lazy eval is one of several ways to implement those semantics
00:03:10 <kmc> call-by-name evaluation would also satisfy the requirements in the Haskell Report, but would be incredibly inefficient
00:03:18 <kmc> a more interesting alternative is laziness + speculative parallelism
00:03:54 <mrcarrot> the funny thing is that lazy evaluation is one of the most loved feature inside of the haskell community and the most criticized on wikipedia
00:03:55 <slack1256> erus`: miranda lang and clean also are lazy by default
00:04:15 <kmc> afaik Haskell is the only language with non-strict semantics (and popular implementations using laziness) which approaches "mainstream" or "used for practical work"
00:04:18 <slack1256> erus`: clean lang*
00:04:47 <kmc> miranda is basically a predecessor to Haskell
00:05:11 <kmc> mrcarrot, it's not universally loved in the Haskell community
00:05:14 <slack1256> yeah: I don't think i has seen much develoment after the 90's
00:05:22 <erus`> is there no lazy lisp/scheme ?
00:05:33 <ddarius> erus`: Not serious ones.
00:05:33 <kmc> erus`, there are
00:05:38 <kmc> Racket comes with a lazy dialect, i think
00:05:51 <kmc> nobody uses it for "real work", afaik
00:06:19 <kmc> erus`, you can also do lazy evaluation in almost any high-level language
00:06:24 <kmc> by explicitly building and forcing thunks
00:06:35 <kmc> however this requires some kind of mutable state
00:06:39 <erus`> kmc yeah but thats a pain
00:06:42 <ddarius> I wouldn't say that most Haskellers "love" laziness.  Many see value in it, but probably wouldn't be too heart-broken if it were removed.
00:06:42 <kmc> you couldn't do it in a strict pure functional language
00:06:48 <mrcarrot> ocaml is also having lazy evaluation... but you have to tell it to be lazy
00:06:59 <mrcarrot> it is not happening automatically
00:07:01 <kmc> mrcarrot, isn't that like any other language?
00:07:26 <kmc> i would be upset if implicit laziness were removed from Haskell/GHC entirely
00:07:36 <kmc> but i'd very much like to see better ways to override that default
00:07:40 <kmc> including perhaps for entire modules
00:07:41 <slack1256> i would also be upset
00:07:48 <mrcarrot> i would also be upset
00:08:08 <kmc> non-strict semantics are more composable
00:08:20 <kmc> a lot of things that have to be special in other languages are ordinary functions in Haskell, for this reason
00:08:24 <ddarius> kmc: I didn't say you wouldn't be heart-broken at all.
00:08:34 <kmc> that's valuable
00:09:42 <kmc> the core concepts in Haskell are unusual and difficult to learn, but they fit together nicely and there just aren't that many of them
00:09:43 <kmc> laziness contributes to that
00:10:22 <erus`> i would like to meet someone who learned haskell before any other language
00:10:26 <slack1256> with laziness you trade some performance for expressiveness power
00:10:39 <slack1256> I am that kind of person erus`
00:11:02 <slack1256> i didn't know any lang (plus i don't have any background on CS)
00:11:10 <erus`> can you write C code now?
00:11:28 <slack1256> now yes, i entered college so it was obligatory
00:12:04 <erus`> do you find C easier?
00:12:21 <shachaf> Comparing C and Haskell isn't really fair.
00:12:28 <kmc> they're for totally different things
00:12:38 <applicative> which isn't it fair to?
00:12:42 <shachaf> Either.
00:12:43 <kmc> applicative, either
00:12:56 <slack1256> no :), but some things are easier on it, some algorithms are made to play with arrays (md5 for example)
00:13:18 <kmc> meh, Haskell has arrays
00:13:21 <kmc> even mutable arrays
00:14:00 <ddarius> Cryptol
00:14:01 <slack1256> yeah but aren't as basic knowleged as in C, here in haskell the basic data structure are List, C arrays
00:14:10 <kmc> yeah
00:14:17 <erus`> i learnt C first. Thats not much that i couldnt write quicker in C than haskell
00:14:26 <kmc> i would say the basic datastructure in Haskell is the algebraic data type in general
00:14:35 <kmc> of which lists are one example
00:14:51 * ddarius would say that what lazy lists usually represent are very common, often built-in, things in many modern languages.
00:15:01 <kmc> always funny to find blog posts gushing about Maybe, which miss the point that it's just Example 1 of algebraic data
00:15:14 <kmc> or languages which hardcode some Maybe-like type and then declare "well, we're as cool as Haskell now"
00:15:17 <dobblego> kmc: I've tried pointing that out countless times
00:15:29 <slack1256> lazy list on others langs are called streams right?
00:15:36 <moriramar> Excuse me, I was trying to solve SPOJ 02 PRIME1 with http://pastebin.com/Am6A7Vg6 (ghc -O2 -o N002 -dynamic N002.hs), and I got <<loop>> after input 2 lines of numbers. I know that iter is written poorly and should be replaced by some standard functions, but before that, what causes the <loop>? Thank you.
00:15:39 <kmc> slack1256, or generators, or loops
00:15:43 <ddarius> kmc: It's an extremely handy example.  Very high power-to-weight ratio.  Also, Either is essentially fundamental thing that is missing from most languages.
00:15:58 <ddarius> kmc: Or enumerator, iterators, etc.
00:16:05 <flux> slack1256, there's a difference. typically streams are consumed, whereas you can have a reference to the head of a lazy list and keep it
00:16:22 <flux> maybe some languages have 'persistent streams' perhaps?
00:16:36 <kmc> that's true; in Python a generator is a mutable object which will forget elements after you request them
00:16:53 <slack1256> flux: right!
00:17:20 <kmc> lists in Haskell act interchangeably like data or like control flow
00:17:49 <kmc> dobblego, to whom? with success?
00:18:08 <dobblego> mostly to scala (former java) or C# guys (who have fromMaybe as language syntax)
00:18:12 <dobblego> with limited success
00:18:24 <mrcarrot> slack1256: out of curiousity, how did you end up learning haskell as first language? most have never heard about haskell when they begin to program
00:18:26 <ddarius> I would say many (most?) examples of the use of lists in Haskell should not be described as "Haskell uses lists, C uses arrays" but as "Haskell uses lists, C uses for-loops."
00:18:54 <ddarius> dobblego: Nullable is not Maybe (unfortunately)
00:19:00 <ddarius> *not like
00:19:10 <dobblego> ddarius: ??
00:19:58 <slack1256> well, i have to thanks to my brother, he told me when i was 15 that programming languages should help you to express your ideas
00:20:16 <slack1256> and that haskell fit perfectly with that definition
00:20:19 <ddarius> int?? is not like Maybe (Maybe Int)
00:20:33 <ddarius> I'm pretty sure it is actually syntactically invalid.
00:20:58 <dobblego> ddarius: null ?? "abc" == "abc"; "def" ?? "abc" == "def"
00:21:07 <shachaf> Clearly in C the pointers 0,1,2,... should express different levels of Maybe nesting.
00:21:14 <shachaf> Why restrict yourself to NULL?
00:21:18 <kmc> ??
00:21:27 <kmc> ¿¿
00:21:42 * shachaf awaits interrobang from kmc.
00:21:44 <ddarius> dobblego: Yes, I know (though I wasn't sure whether you were referring to it with your previous "statement.")  My point is that Nullable is not Maybe.
00:22:01 <erus`> do you guys memorize the unicode codes or have really cool keyboards?
00:22:15 <kmc> erus`, i use X's Compose key feature
00:22:16 <dobblego> ddarius: I'm not sure where Nullable comes into it
00:22:26 <ddarius> int? is Nullable<int>
00:22:33 <buntfalke> applicative: (folds discussion) thanks for the link
00:22:34 * shachaf memorized all the Unicode codepoints.
00:22:38 <dobblego> right, I meant something else
00:22:41 <shachaf> Not their meanings, though.
00:22:48 <slack1256> erus`: some people have 2 or 3 monitors, i have 6-7 modified keyboards xD
00:23:25 <ddarius> dobblego: You meant the ?? which operates on Nullables.
00:23:32 <ddarius> ?? operator
00:23:32 <lambdabot>  operator
00:23:37 <ddarius> Thanks lambdabot.
00:23:43 <kmc> thambdabot
00:23:50 <erus`> im going to write a lazy scheme like language
00:23:56 <ddarius> erus`: Why?
00:24:10 <erus`> because im bored at work
00:24:14 <kmc> erus`, if you implement a scheme-like language in Haskell, it may end up lazy without you trying
00:24:25 <kmc> it's not clear what "write a language" means
00:24:30 <kmc> write the spec or implement it or both
00:24:35 <applicative> buntfalke: yeah, tibbe puts a lot of stuff together for you, or so it was for me when I read it.
00:24:39 <ddarius> erus`: Why not go whoring instead?  It's probably a lot more entertaining.
00:24:40 <erus`> writing a compiler in haskell feels like cheating
00:24:44 <kmc> if you just want to play with a lazy scheme-like language, Racket has one
00:24:55 <shachaf> kmc: The implementation is the spec!
00:25:00 <shachaf> Take inspiration from Ruby.
00:25:15 <kmc> my language is derived by running QuickSpec on the compiler
00:26:15 <slack1256> erus`: if you're serious, let me know to play with it
00:26:59 <ddarius> slack1256: You can write a lazy Scheme in about five minutes.
00:27:50 <slack1256> ddarius: i don't know much about lisp or compilers in general, so maybe for me would be 5 years
00:28:55 <ddarius> I doubt it.
00:29:59 <slack1256> if i recall right there is a tutorial "write yourself a scheme in haskell"
00:30:05 <slack1256> maybe i should look at it
00:30:20 <Spockz> is the SNMap from http://community.haskell.org/~simonmar/papers/weak.pdf accessible from somewhere? I can't find it through hoogle
00:40:49 <erus`> > let f = 1 : f in f
00:40:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:40:56 <buntfalke> applicative: still reading the haskell.org/wiki on foldr/l/l' and such, will have a look soon
00:41:19 <buntfalke> Slow newbie is slow ;-)
00:41:42 <erus`> > let f = f ++ 1 in f
00:41:43 <lambdabot>   Ambiguous type variable `m' in the constraints:
00:41:43 <lambdabot>    `GHC.Num.Num m'
00:41:43 <lambdabot>      ari...
00:41:52 <erus`> > let f = f ++ [1] in f
00:41:55 <lambdabot>   mueval-core: Time limit exceeded
00:42:17 <erus`> does `:` have to evaluate the left side first?
00:42:25 <kmc> that's not quite what's going on
00:42:46 <kmc> lambdabot starts printing the list from the first element
00:42:54 <kmc> the first element of (1 : f) is clearly 1
00:43:08 <kmc> but the first element of (f ++ [1]) is the first element of f which is the first element of (f ++ [1]) which is...
00:43:21 <kmc> that depends on the definition of (++) of course
00:43:28 <erus`> > let f = 1:f in f !! 3
00:43:29 <lambdabot>   1
00:44:20 <kmc> what's the third element of f? well, it's the third element of (1:f), which is the second element of f, which is the second element of (1:f), which is the first element of f, which is the first element of (1:f), which is 1
00:44:20 <erus`> so f is [Evaluated 1, Thunk]
00:44:47 <kmc> erus`, not operationally
00:44:52 <kmc> it's actually a (:)-cell with a pointer to itself
00:44:56 <kmc> a circularly linked list of one element
00:45:41 <ddarius> Also [x,y] means x:y:[]
00:47:43 <erus`> let f n = n : f (n+1) in f 0
00:47:48 <erus`> > let f n = n : f (n+1) in f 0
00:47:48 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
00:48:13 <kmc> erus`, you might enjoy playing with the 'vacuum' package
00:48:18 <erus`> i can understand how that one works
00:48:20 <kmc> it can render graphs of heap objects visually
00:50:12 <erus`> should I just internally represent 1:f as a  (LazyList (Evaluated 1) (Thunk blah)) ?
00:50:30 <ddarius> Someone should make a vacuum that renders the graphs audibly.
00:50:46 <fasta> What does A <= B, with A and B types mean in type theory again?
00:50:47 <kmc> erus`, represent for what purpose?
00:51:14 <erus`> well i need to represent it somehow, to build an AST
00:51:23 <kmc> seems reasonable
00:51:30 <kmc> or you can represent that thunk with a Haskell thunk
00:51:30 <ddarius> fasta: Whatever it is defined to mean.
00:51:48 <erus`> kmc: im implementing in javascript
00:52:00 <erus`> i wanna write a lazy language in a non lazy one
00:52:00 <kmc> haha
00:52:13 <fasta> ddarius: it is not defined.
00:52:17 <kmc> wrap every js value in function(){...}
00:52:20 <kmc> now it's a lazy language ;P
00:52:28 <shachaf> kmc: Well, non-strict.
00:52:28 <ddarius> non-strict
00:52:33 <kmc> sigh
00:52:36 <kmc> nerrrrrds
00:52:37 <fasta> ddarius: never mind.
00:52:50 <kmc> fasta, maybe subtyping?
00:52:51 <ddarius> kmc: You can't be a pedant and then get upset by pedantry.
00:53:02 <kmc> ddarius, who says i can't be a hypocrite?
00:53:04 <kmc> ;P
00:53:06 <shachaf> ddarius: I've found it to be very possible.
00:53:08 <kmc> anyway i am not upset
00:53:26 <fasta> Is there any Haskell compiler written in a style which is meant to be understood by others?
00:53:27 <kmc> but i will use as my excuse that i was echoing erus`'s wording
00:53:36 <OLiverr> just another little question: did anyone of you use Control.Concurrent by any chance and can tell me how I get those file descriptors for threadWaitRead o.O
00:53:48 <kmc> OLiverr, why do you want to call threadWaitRead yourself?
00:53:51 <OLiverr> because I need to block my haskell application while the vba stuff is doing something
00:53:59 <fasta> I thought UHC was meant to be that, but I opened a random file and at least that file was not documented.
00:54:10 <kmc> OLiverr, just do a normal read
00:54:12 <ddarius> kmc: That's the real killer though.  It makes your statement outright false, not just imprecise.
00:54:38 <OLiverr> kmc,  a normal read? but does it block?
00:54:55 <kmc> OLiverr, yes
00:54:55 <OLiverr> i could make an infinite loop but .. yeah..
00:55:20 <kmc> OLiverr, in GHC Haskell you use threads and blocking IO, and the runtime system implements this with event-based IO system calls
00:55:26 <kmc> like epoll on linux or kqueue on bsd
00:55:41 <kmc> i think it's not quite as clever on Windows, but it will still block effectively
00:56:18 <kmc> i don't know what those Fd's even mean on Windows
00:56:21 <shachaf> I was under the impression Windows's APIs were nicer for that sort of thing than epoll/kqueue.
00:56:24 <OLiverr> hm so when I'm at the end of a file and let's say I make a getLine, it wil block when there is no more line to read o.O ?
00:56:30 <obiwahn> @smack Cale
00:56:30 * lambdabot jabs Cale with a C pointer
00:56:39 <kmc> OLiverr, yeah.  that's the default behavior of IO in most languages
00:56:55 <kmc> OLiverr, sometimes people turn their code inside out to get different behaviors, but in GHC Haskell you generally do not need to
00:56:55 <OLiverr> well but not in C/C++
00:57:05 <kmc> yeah it is
00:57:11 <OLiverr> hm? no o.O
00:57:19 <kmc> C and C++ are two different languages
00:57:36 <OLiverr> If a read over the file end I get an eof maybe but no block o.O
00:57:46 * ddarius will start saying C/C++/C# to bother kmc.
00:58:02 <kmc> OLiverr, oh, I misunderstood
00:58:10 <kmc> i thought you were reading from console or network socket or something
00:58:14 <kmc> yeah, the end of a file is the end of a file
00:58:24 <OLiverr> hm no
00:58:29 <kmc> threadWaitRead won't help you there either
00:58:39 <OLiverr> I would to this but with vba it's adventurrous :D
00:58:46 <OLiverr> hm ok
00:58:51 <kmc> if you need to monitor a plain file for changes, your options are a) poll it constantly, b) use some system API like inotify on Linux
00:58:56 <OLiverr> then I misunterstood the effect of this one
00:59:17 <kmc> threadWaitFd is used in the implementation of blocking IO for sockets etc
00:59:23 <kmc> er threadWaitRead
00:59:32 <OLiverr> ok..
01:00:49 <mrcarrot> int i = 'z'; printf("%d",i);   <--- strange that this is allowed in C (no check if it is an int or not)
01:01:10 <obiwahn> Cale: where is nixon?
01:01:22 <OLiverr> and for such an constant poll i have to use recursion?
01:01:23 <kmc> what's wrong with that mrcarrot? char is an integral type, it's implicitly converted to int
01:01:36 <flux> mrcarrot, varargs are untyped at the receiving end
01:01:43 <OLiverr> or is there anything loop-like in haskell?
01:01:48 <kalven> 'z' /is/ int in C
01:01:55 <kmc> OLiverr, loops in Haskell are ordinary library functions implemented using recursion
01:01:59 <kmc> :t forever
01:02:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
01:02:02 <kmc> @hoogle forever
01:02:02 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
01:02:23 <kmc> @hoogle mapM_
01:02:23 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
01:02:23 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
01:02:23 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
01:02:26 <kmc> @hoogle forM_
01:02:26 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
01:02:26 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
01:02:28 <OLiverr> hm ok and they don't complain running some time? ;)
01:02:36 <kmc> shouldn't
01:02:39 <Axman6> mrcarrot: why? characters are just numbers in C
01:02:43 <shachaf> @ty forever and ever
01:02:44 <lambdabot> forall b. b
01:02:53 <kmc> OLiverr, a busy polling loop is probably terribly inefficient
01:02:57 <kmc> you could slow it down with threadDelay
01:03:07 <Axman6> kalven: not really. 'z' is char, which has sizeof 1 (i think)
01:03:16 <OLiverr> yeah thought about it already
01:03:33 <koeien> char is by definition sizeof 1
01:03:43 <koeien> and 'z' is an int
01:03:46 <kalven> Axman6: 'z' is int in C and char in C++
01:03:46 <koeien> (in C)
01:03:50 <mux> Axman6: kalven is right though; character literals are int's in C
01:04:01 <Axman6> >_<
01:04:13 <OLiverr> already though about somehow freaking some input to the stdin of the haskell process but I think I'm a the wrong place here ;)
01:04:20 <Axman6> C, Y U KEEP GETTING MOAR FUCKED UP THE MOAR I LEARN?
01:04:31 <merijn> Axman6: Story of my life
01:04:58 <ddarius> Axman6: Ignorance is Bliss.
01:05:03 <mux> scumbag C, makes you think you know it... :-)
01:05:04 <Axman6> it truly is
01:05:07 <obiwahn> Cale: i have found a Vixen.hs in Plugins but when i grep for nixon I dont find anything useful
01:05:28 <Axman6> C: the more you know it, the more scared you become
01:05:58 <merijn> The more I know about C, the more I feel we need something like Habit >.>
01:05:59 <kalven> yeah, stick to C++ :)
01:06:13 <koeien> kalven: wut
01:06:19 <merijn> kalven: Can't tell if sarcasm
01:06:38 <mux> we seem to be all reddit-infected
01:06:53 <Axman6> :(
01:07:10 <merijn> mux: Of course, I had to point /etc/hosts to an empty void earlier this week to regain my productivity
01:07:15 * Axman6 remembers when reddit wasn't all memes and actually used to amaze him with cool stuff everyday
01:07:16 <ddarius> C++ > C
01:07:20 <merijn> Didn't work because now I'm here, :p
01:07:25 <mrcarrot> C is syntactic sugar for asm (really, a compilator is not big, each function maps very nicely to a few lines of asm)
01:07:27 <kmc> > "C++" > "C"
01:07:28 <lambdabot>   True
01:07:52 <kmc> mrcarrot, if C is a portable assembler then why can't i do tail calls
01:07:57 <merijn> mrcarrot: No it's not
01:08:01 <koeien> mrcarrot: goto.
01:08:11 <shachaf> C++ is indeed much bigger than C.
01:08:15 <merijn> mrcarrot: ASM is much nicer then C, just not as portable
01:08:19 <mrcarrot> it is... optimization is another thing... that adds size to the compilator
01:08:32 <Axman6> compilator?
01:08:36 <mux> merijn: heh, I feel the pain
01:08:45 <Axman6> never heard that one before. where are you from mrcarrot?
01:08:56 <merijn> mrcarrot: You can do lots of things in ASM which you can't do in C, so calling it "just syntactic sugar" is all sorts of wrong
01:09:09 <merijn> mux: Didn't work of course, I'm talking here now...
01:09:15 <ddarius> merijn: Haskell is just syntactic sugar for assembly.
01:09:41 <kalven> people who think C is portable assembler should read the "what every C programmer should know about undefined behavior"-series from the llvm blog
01:09:47 <mrcarrot> finland... in uni i programmed a bit of asm too. i wrote an irc bot in it. i had one course where i learned about developing compilators. there we looked at how C maps to asm
01:10:07 <shachaf> Haskell has a fair bit of semantic sugar.
01:10:07 <Axman6> ddarius: it used to be syntactic sugar for C
01:10:08 <Axman6> XD
01:10:22 <mrcarrot> there are things that are complicated too in C... and not trivial in asm. but most is pretty trivial
01:11:04 <Axman6> kalven: is there anything that's come out of that project that isn't just sheer awesomeness?
01:11:39 * hackagebot zot 0.0.2 - Zot language  http://hackage.haskell.org/package/zot-0.0.2 (YoshikuniJujo)
01:11:44 <ddarius> Axman6: Since C is just syntactic sugar for assembly, my statement stands.  Also, HBC didn't see C at all.
01:11:58 <Oxfaded> im currently using hWaitForInput to "wait for input" but it throws an exception if the handle closes. But upon entering the wait the handle is open, so I cant check before waiting. How are you supposed to get around this?
01:12:19 <Axman6> i was just commenting on the progression of GHC from compiling using C to having its own native code generator
01:12:30 <flux> oxfaded, so you have another thread closing the handle?
01:12:50 <Axman6> Oxfaded: catch the exception
01:13:16 <Oxfaded> well, a remote server, if that counts as another thread
01:13:46 <yakov> hey
01:13:47 <flux> ok. I was thinking if the descriptor becomes invalid, which isn't what happens here then. just regular socket programming :)
01:13:48 <kalven> Axman6: I can't think of anything
01:14:00 <Axman6> =)
01:15:47 <yakov> where's latest haskell platform? "next release" is overdue..
01:16:51 <erus`> Whats the name for a value that is not a function?
01:17:18 <yakov> constant
01:17:21 <erus`> i would say Constant but this is not true for an IO thing
01:17:58 <yakov> IO thing has functional type, hasn't it? ;-)
01:18:09 <flux> erus`, depends on the point of view. isn't do_echo = "echo hello world" a constant as well, and it's an action that can be evaluated?
01:18:24 <flux> (uh oh, s/it's/its/)
01:18:41 <flux> (actually scratch that ;-))
01:18:41 <aspect> no, you were right the first time -- "it is"
01:18:50 <shachaf> erus`: Why is it not true for IO?
01:19:00 <merijn> erus`: The correct name for a value that is not a function is..."a value"
01:19:07 <Axman6> erus`: IO isn't special really
01:19:11 <aspect> non-applicable value? :)
01:19:18 <merijn> Of course functions can also be values, but still :>
01:19:19 <shachaf> merijn: No, that doesn't exclude functions.
01:19:31 <shachaf> Anyway, in Haskell everything is a function, right?!
01:19:45 <yakov> right!
01:19:55 <yakov> be purist and call it 0-ary function!
01:20:09 <koeien> flux: (putStrLn "hello world") is not a function, no
01:20:11 <merijn> yakov: And then get savaged by Conal
01:20:11 <yakov> but again this is not technically corrent
01:20:23 <aspect> in what context do you need to make this distinction?
01:20:27 <shachaf> yakov: No, not right. :-(
01:20:58 <yakov> shachaf, i though IO values has functional type anyway as I wrote above..
01:21:10 <yakov> "0-ary function" was a joke actually ;-)
01:21:17 <yakov> but my memory is vague.
01:21:18 <shachaf> yakov: What do you mean, "has functional type"?
01:21:29 <shachaf> yakov: foo :: IO a is just a value.
01:21:38 <flux> wouldn't this be correct: in "a b = b" the part "a b" is a function, but "a" is a value or constant?-)
01:21:39 <koeien> it's quite an ordinary value
01:21:44 <yakov> well, you can't take the value out of it without application!
01:21:50 <shachaf> flux: No, a is a function.
01:21:54 <koeien> flux: no. a is the function.
01:22:02 <shachaf> Yacoby: It doesn't *have* a value in it.
01:22:20 * shachaf mistabs.
01:22:36 <flux> so it depends on the type of an expression if it's a value or a function?
01:22:43 <shachaf> flux: ?
01:22:47 <yakov> well, check tha damn type!
01:23:00 <flux> well, if you have a = xxx, is "a" a function or a value?
01:23:02 <yakov> if it has -> then it's not "a value" definitely
01:23:08 <flux> or does it depend on xxx?
01:23:16 <koeien> it's always a value.
01:23:18 <shachaf> yakov: Functions are values.
01:23:20 <koeien> it could be a function
01:23:24 <shachaf> yakov: Also, "IO a" has no "->".
01:23:34 <koeien> String -> IO () is a function
01:23:40 <yakov> well.. ok..
01:23:43 <obiwahn> @babel de en sprache
01:23:43 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
01:23:43 <koeien> (a value of type)
01:23:55 <yakov> i mean, see for IO
01:24:01 <koeien> a value of type String -> IO () is a function. A value of type IO () is not a functio
01:24:05 <shachaf> Yes, but f _ = x; f :: String -> IO () is an example of such a value.
01:24:23 <koeien> functions are values
01:24:42 <koeien> > map ($ 3) [(+1), (+2)]
01:24:43 <lambdabot>   [4,5]
01:24:58 <yakov> take the Constant.. at least it suggest the indended usage
01:25:10 <flux> koeien, would it also always be constant, or only constant if xxx is not a function?
01:25:13 <yakov> sure functions are first-class.. we all know that
01:25:23 <yakov> the guy wanted a catchy name for the thing AFAIU
01:25:37 <koeien> flux: well, it is a constant. but it might not be a constant function
01:25:51 <yakov> anyway, where's the latests and greatests Haskell Platform?! :-)
01:25:59 <yakov> I don't want to install all by hand ;-)
01:26:37 <koeien> if you say, f x = x+1, then f is not a constant function. but it is very similar to f = [], in that we cannot change the value of f.
01:26:52 <shachaf> Functions are also constants, though.
01:27:11 <ddarius> There're two ways of reading "constant function."
01:27:15 <shachaf> "constant function" has a specific meaning.
01:27:39 <koeien> we don't really use the word "constant" though, except in the context of a function that is a constant function (forall x y. f x == f y)
01:31:02 <erus`> How can I tell if i am using to many type declarations (going over the top) ?
01:31:30 <shachaf> My .ghci file makes ghc take 1.2 seconds longer to run.
01:31:44 <jacobian> do people actually write point free code without going through the process of transforming pointed code equationally to obtain the result?
01:32:06 <shachaf> jacobian: Sometimes, sure.
01:32:12 <shachaf> When it's clearer.
01:33:48 <jacobian> I can write: map = (flip foldr []) . ((: ).)   but only by way of transforming it.  It looks a bit like gibberish to me when its done :)
01:34:22 <shachaf> It looks a bit like gibberish when reading it too.
01:35:20 <shachaf> On the other hand, writing f = g . h . i instead of f x = g (h (i x)) is perfectly natural, of course.
01:35:49 <shachaf> Sometimes point-free style is more confusing, sometimes less.
01:36:13 <ddarius> People would write map f = foldr ((:) . f) []
01:36:14 <shachaf> People don't do it for the sake of golf, after all; only use it it helps with something.
01:36:34 * shachaf 's rule of thumb is that flip is almost always too much.
01:36:54 <ion> Also, you can choose to get rid of just *some* of the points. E.g. only ‘xs’ in the definition of map in terms of foldr.
01:37:43 <ion> Ah, ddarius already gave that example.
01:38:39 <jacobian> map f = foldr ((:) . f) [] is a lot more readable
01:38:44 <erus`> what a cool name for a functional language?
01:38:47 <shachaf> @ty fmap fmap fmap fmap flip foldr [] (fmap (:))
01:38:48 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
01:38:57 <ion> erus: Java
01:39:00 <jacobian> lol
01:39:04 <erus`> haskell script
01:39:12 <erus`> because its not much like haskell
01:40:15 <erus`> also can i export everything in a module quickly ? i thought it was something like (..) but it didnt work
01:40:38 <nlogax> if you don't have an exports list, i think all top level bindings are exported
01:40:52 <erus`> ah yes
01:41:33 <jacobian> shachaf how did you get that?
01:41:56 <shachaf> jacobian: By hand, sadly.
01:42:12 <jacobian> Did you just stare at it, or transform it from the previous?
01:42:29 <shachaf> The latter.
01:42:32 <shachaf> Those fmaps are all (.)s.
01:42:35 <shachaf> @ty (.) (.) (.) (.) flip foldr [] ((.) (:))
01:42:36 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
01:43:00 <jacobian> wow
01:43:29 <shachaf> jacobian: For bonus points eliminate those last parenthese. :-)
01:44:09 <jacobian> map = fmap fmap fmap fmap flip foldr [] $ fmap (:)
01:44:28 <shachaf> Doesn't count, the parenthese are just implicit there.
01:44:34 <jacobian> haha
01:46:20 <shachaf> jacobian: a b (c d) ==> (a b . c) d ==> fmap (a b) c d ==> (fmap . a) b c d ==> fmap fmap a b c d
01:48:10 * frerich2 thinks all this "fmap fmap fmap fmap" sounds like some monster from the sesame street.
01:53:15 <Jafet> @google fmap fmap fmap
01:53:16 <lambdabot> http://www.haskell.org/pipermail/reactive/2008-November/000054.html
01:53:17 <lambdabot> Title: [reactive] To fmap fmap or not?
01:53:38 <shachaf> Fun fact: fmap fmap fmap fmap fmap fmap == fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
01:54:13 <Jafet> "No instance (Eq ..."
01:54:19 <shachaf> s/=/==/
01:54:43 <Jafet> @type (.)(.)(.)(.)(.)(.) `asTypeOf` (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
01:54:43 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1 b. (Functor f1, Functor f) => (a -> a1 -> b) -> f1 a -> f1 (f a1 -> f b)
01:55:03 <Jafet> @type (.)(.)(.)(.)(.)(.)(.)(.)(.)(.) `asTypeOf` (.)(.)(.)(.)(.)(.)
01:55:04 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1. (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
01:55:10 <Jafet> Oh, they are equivalent
01:55:33 <Jafet> ...not that that was the correct way to prove it
01:55:50 <shachaf> What's not correct?
01:56:36 <shachaf> @ty let d f g x = f (g x) in d d d d d d `asTypeOf` d d d d d d d d d d
01:56:37 <lambdabot> forall t t1 t2 t3 t4. (t1 -> t2 -> t3) -> (t -> t1) -> t -> (t4 -> t2) -> t4 -> t3
01:56:50 <shachaf> @ty let d f g x = f (g x) in d d d d d d d d d d `asTypeOf` d d d d d d
01:56:51 <lambdabot> forall t t1 t2 t3 t4. (t3 -> t -> t1) -> (t4 -> t3) -> t4 -> (t2 -> t) -> t2 -> t1
02:07:36 <obiwahn> > foldr (++) [] (replicateM 4 "ar")
02:07:38 <lambdabot>   "aaaaaaaraaraaarraraaarararraarrrraaaraarrarararrrraarrarrrrarrrr"
02:07:49 <obiwahn> a pirate i was meant to be:)
02:09:58 <merijn> Trim the sails and roam the sea?
02:10:26 <obiwahn> less singing more sailing!
02:10:53 <merijn> We could avoid scurvy if we all eat an orange...
02:12:03 <obiwahn> aehm - door hinge? Nonono - guess the song is over then:)
02:12:21 <erus`> I have implemented an AST pretty printer before writing a compiler :D
02:12:33 <erus`> i think im doing this the wrong way round
02:15:03 <ddarius> Since you don't need an AST pretty printer at all in a compiler, one could make that case.
02:20:56 <ion> > fix (\f (x:xs) -> x : f (xs ++ case x of { 'a' -> "ar"; 'r' -> "ra" })) "arr"
02:20:57 <lambdabot>   "arrarraraarraraarraararraraarraararraraararraarraraarraararraraararraarrar...
02:21:40 <raichoo> @type fix
02:21:41 <lambdabot> forall a. (a -> a) -> a
02:25:16 <jacobian> > fmap (fmap fmap fmap fmap foldr (++) []) replicateM 4 "ar"
02:25:17 <lambdabot>   "aaaaaaaraaraaarraraaarararraarrrraaaraarrarararrrraarrarrrrarrrr"
02:29:09 <hpaste> Zr40 pasted “type error” at http://hpaste.org/51410
02:29:57 <Zr40> I'm getting a strange type error and I can't see why
02:30:09 <shachaf> Error: strange type
02:30:34 <shachaf> Why are you <-ing showIntAtBase ...?
02:30:40 <koeien> Zr40: let is different from <-
02:30:45 <shachaf> And the other thing?
02:31:02 <shachaf> No need for <- in that program.
02:31:19 <koeien> Zr40: <- is used to extract values from monadic actions
02:31:35 <koeien> let is used to bind names to values
02:32:03 * shachaf hmphs at "extract".
02:32:09 <koeien> since showIntAtBase is not an IO action, you shouldn't use <-. Instead say let str = showIntAtBase 2 ...
02:32:28 <koeien> Zr40: the reason for the type error is that [] is also a Monad.
02:32:47 <Zr40> ah, I see
02:32:51 <koeien> Zr40: so str will have type Char there, which you might not expect.
02:33:02 <shachaf> No need to use the M-word, koeien. :-)
02:33:10 <Botje> Milk?
02:33:42 <shachaf> Munteanu
02:35:39 <Eduard_Munteanu> shachaf: hm?
02:35:47 <shachaf> Eduard_Munteanu: "Munteanu" is the M-word.
02:35:58 <shachaf> Unless we're talking about "monkey".
02:36:21 <koeien> Zr40: if you don't know about monads, you can ignore what I said about it :) It's not important.
02:36:36 <koeien> it just explains the reason for this particular error message
02:36:48 <koeien> and use s/monadic/IO
02:37:46 <Eduard_Munteanu> Oh, heh.
03:01:13 <whald> bear with me if my question is overly board, but is there a more idiomatic way to accomplish this:
03:01:36 <whald> I have a monad which basically provides two monadic functions
03:01:53 <incluye> fi'm already board
03:01:54 <whald> this is implemented using a StateT
03:02:13 <whald> s/board/broad :-)
03:02:57 <erus`> how can i import a module from one directory up?
03:02:57 <whald> well, my state is basically carrying around the "real" functions to which is forwarded by the monad's functions
03:03:39 <whald> so my monad's functions read basically: rnd' n = ask >>= \s -> Sampled $ (lift $ func1D s n) :: (PrimMonad m) => Int -> Sampled m Float
03:03:52 <whald> this looks ugly to me
03:04:31 <whald> my "state" provides that func1D
03:05:55 <whald> so i grab the "right" function from my state and forward there
03:08:05 <applicative> erus` you mean with ghci
03:08:10 <applicative> ?
03:09:02 <applicative> If its registered, you import it by its name :)
03:09:04 <erus`> i want to lay out my directorys like a/b/c where c needs to load a module from b
03:12:30 <erus`> also a.b cannot import a.b.c :|
03:13:44 <erus`> omg
03:16:11 <applicative> erus, there shouldn't be any problem if the module names follow the hierarchical rules.  if you are compiling one of them, you will have to do it from the outermost directory
03:16:16 <applicative> or am i following
03:18:18 <erus`> yeah
03:18:25 <erus`> but when testing with ghci its a pain
03:19:11 <applicative> yes I'm constantly tripped up by it
03:19:26 <hpaste> “Mukesh Tiwari” pasted “Error in running cabal install” at http://hpaste.org/51412
03:19:55 <applicative> or rather, my primitive editor invites this
03:20:59 <born2code> i am getting error for  cabal install keys --dry-run -v
03:21:19 <born2code> http://hpaste.org/51412
03:26:12 <applicative> born2code man, that's opaque. Detritus from old ghc installations is the natural explanation, except it's hard to see how
03:28:31 <born2code> applicative: i did not get you .
03:29:13 <applicative> At first I thought, maybe an old .cabal/config or something but the error is from inside ghc I think, looking at other references to it.
03:29:14 <born2code> applicative:  ghc is latest version  7.2.1
03:29:40 <applicative> yes, see someone else had it recently http://stackoverflow.com/questions/6581041/problem-with-scion-not-found
03:29:47 <born2code> applicative: so why its complaning about old version
03:36:24 <koeien> FWIW, using the Haskell Platform is recommended.
03:40:13 <applicative> I can't find the source that would generate an error like that.
03:40:51 <applicative> people who installed the Platform seem to be among those who came across it
03:41:35 <born2code>  I have gone through the link but  it did not help very much .
03:42:25 <applicative> no it didn't i was just using it to show it exists, there are other similar cases if you just google the whole error
03:44:39 <applicative> born2code: I don't suppose you get anything more revealing with cabal install keys --dry-run --verbose=3
03:45:12 <Eidel> Does anyone know how to put anything at the end of a zipper data structure? Do I have to iterate through the whole list?
03:46:04 <magicman> @hoogle Maybe (m a) -> m (Maybe b)
03:46:05 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
03:46:05 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
03:46:05 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
03:47:06 <koeien> :t maybe
03:47:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:47:35 <koeien> :t maybe (return Nothing) (fmap Just)
03:47:36 <lambdabot> forall a (m :: * -> *). (Monad m, Functor m) => Maybe (m a) -> m (Maybe a)
03:48:27 <born2code> applicative: yestered i got some issues regarding local and global namespace . So it was suggest to me before installing any package check the dependency.
03:48:55 <born2code> if any package in global namespace so don't install it user space using cabal install
03:49:03 <ddarius> Eidel: A zipper is like a data structure with a pointer into it.
03:49:08 <born2code> thats why i was checking to avoid this problem
03:49:36 <applicative> you were proposing to install keys in user space, though, right?
03:50:00 <applicative> i mean, that's the default when you do "cabal install pony" or whatever
03:57:05 <born2code> applicative: yes , yesterday i came to this problem because i installed lot of global packages also in user space
03:57:35 <born2code> no bencmachino today :(
03:57:40 <born2code> applicative: and finally i have to remove my ghc installation :(
03:57:54 <applicative> the arrangement of them now looks okay though -- or anyway what I do -- the Platform libraries are global everything else local
03:58:39 <applicative> Except this isn't a Haskell Platform installations since it's using ghc-7.2 (as I am at the moment)
04:01:02 <applicative> you could use a master like dcoutts I think, it is probably very simple.  I take it if you just do "cabal install keys --user" you get the same error?
04:02:59 <applicative> though it's hard to see how adding "--dry-run" could itself be triggering a special error
04:02:59 <born2code> applicative: yes
04:03:32 <born2code> cabal install keys --user is giving same error
04:04:30 <hpaste> applicative annotated “Error in running cabal install” with “Error in running cabal install (annotation) (annotation)” at http://hpaste.org/51412#a51414
04:05:08 <applicative> this is what --dry-run tells me.  You need e.g. comonad, what happens if you do "cabal install comonad --user --dry-run" or whatever
04:06:10 <born2code> applicative: same error
04:06:26 <applicative> grrrrr I'm at a loss.
04:07:22 <born2code> applicative: no problem . thank you for your efforts . i posted it on haskell-cafe
04:07:39 <applicative> good idea.  be good.
04:09:21 <engla> all the non-hierarchical libraries, like for example Char, are they deprecated or will they be?
04:12:00 <Alligadi> hm
04:12:04 <ddarius> engla: They are already gone.
04:12:23 <Alligadi> evens­1 = [ n | n <- natur­als , even n ]
04:12:28 <Alligadi> nice
04:12:40 <engla> ddarius: ok. I wonder why I have them. they are listed as haskell98 in my ghc-doc though
04:12:45 <Alligadi> im wondering how to do the same in python without causing a memory overflow :D
04:13:08 <ddarius> engla: Yes, and the current standard is Haskell 2010.
04:13:18 <erus`> what are the two parts of a function application called?
04:13:39 <engla> Alligadi: itertools
04:14:02 <Alligadi> hmm
04:14:48 <engla> ddarius: I have that installed too. Anyway so this sort of means that haskell does not dwell on backward compatibility which is good
04:15:49 <ddarius> engla: The non-hierarchical names were effectively obsolete anyway.  They haven't been used in practice for the better part of the last decade.
04:17:48 <Alligadi> but it wouldnt be a set then
04:17:55 <Alligadi> it would be a function or are im wrong?
04:18:16 <engla> Alligadi: a python iterable
04:33:05 <mamalujo> so, are there some interesting haskell related blogs not aggregated on planet.haskell?
04:33:51 <ddarius> Probably.
04:34:49 <ddarius> Also Planet Haskell doesn't aggregate Haskell related blogs.  It aggregates blogs of people in the Haskell community (who choose/allow their blog to be aggregated.)
04:36:41 <mamalujo> yes, I understand how it works (surely my choice of phrasing wasn't paticularly unclear)
04:36:41 * hackagebot crocodile 0.1.1 - An offline renderer supporting ray tracing and photon mapping  http://hackage.haskell.org/package/crocodile-0.1.1 (TomHammersley)
04:41:14 <obiwahn> w x y = y(x x y) -- why is it impossibel to define something like that?
04:41:27 <obiwahn> > w x y = y(x x y)
04:41:28 <lambdabot>   <no location info>: parse error on input `='
04:41:46 <obiwahn> > let w x y = y(x x y) in w _ _
04:41:47 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
04:41:57 <obiwahn> > let w x y = y(x x y) in w id 2
04:41:57 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
04:43:00 <quicksilver> obiwahn: because there is no "simple" type x could have so x could be applied to itself
04:43:04 <quicksilver> (similarly y)
04:43:14 <quicksilver> this is just a limitation of H-M type inference and related algorithms.
04:43:24 <quicksilver> if you annotate a type specifically you can do it.
04:43:32 <hpaste> “md2perpe+hpaste@gmail.com” annotated “type error” with “type error (annotation)” at http://hpaste.org/51410#a51415
04:43:37 <quicksilver> (with a suitable higher-rank type)
04:44:50 <whald> does it make sense to add both, inline and specialize pragmas, to a function?
04:49:33 <rtharper_> whald: Depends on the phase orders (I don't know how they work)
04:49:40 <whald> tomh: are you the one with the crocodile renderer?
04:49:51 <rtharper_> but if they are interleaved, you might inline away anything you want to specialise
04:49:58 <tomh> whald: crocodile renderer?
04:50:20 <tomh> oh thats a different tomh
04:50:25 <tomh> im the original tomh
04:50:28 <whald> the one hackagebot told about, from TomHammersley
04:50:31 <whald> tomh: hehe :-)
04:51:35 <whald> rtharper_: thanks for the info, i thought if it's inlined, it's specialized anyway, but seems things are more complicated. as always. :-)
04:54:07 <Eduard_Munteanu> BTW, is there a name for H-M + rank-2 inference?
04:54:12 <jeltsch> Is this supposed to work:
04:54:12 <jeltsch>     type instance Something arg = forall a. (arg,a)
04:54:12 <jeltsch> I’m getting the error message “Illegal polymorphic or qualified type” with GHC 6.12.1 and RankNTypes enabled.
04:55:34 <Eduard_Munteanu> (or maybe I should ask whether there's any practical rank-2 inference algorithm)
04:55:58 <quicksilver> Eduard_Munteanu: no, there isn't.
04:56:12 <quicksilver> Eduard_Munteanu: specifically, rank-2 inference is not convergent
04:56:22 <quicksilver> so in some sense there "cannot" be a good one.
04:56:31 <quicksilver> confluent, I mean, sorry.
04:56:57 <Eduard_Munteanu> Oh hm. I know inference for k >= 3 is proven impossible.
04:56:58 <quicksilver> jeltsch: I imagine it's not supposed to work.
04:57:08 <quicksilver> jeltsch: polymorphic types are not first-class.
04:58:34 <Eduard_Munteanu> quicksilver: but by no confluence you mean you don't get any reasonable principal typing property?
04:58:54 <quicksilver> Eduard_Munteanu: yes, I think that is roughly the same thing.
04:59:03 <quicksilver> Eduard_Munteanu: terms can have more than one reasonable type.
04:59:09 <jeltsch> quicksilver: Might it work with something like ImpredicativeTypes?
04:59:11 <Eduard_Munteanu> Yeah, I see.
04:59:19 <quicksilver> but some of those reasonable types might not be consistent with a larger context.
04:59:38 <quicksilver> you can get some way by progression with multiple possibilities and backtracking... but that's not feasible
04:59:42 <quicksilver> (has exponential cases)
04:59:55 <quicksilver> and it also fails to have good substitution properties
05:00:09 <aavogt> if giving the necessary information were shorter  ex.    f (g :: Num a => a) = (g 1, g 1.0)  it might be less of a pain
05:00:11 <Eduard_Munteanu> Haskell has some exponential corner cases no?
05:00:14 <quicksilver> you can, I think, identify sublogics of rank-2 in which you get something confluent.
05:00:28 <quicksilver> jeltsch: it might do but I fear it will not :)
05:00:28 <Eduard_Munteanu> H98/2010 I mean.
05:00:35 <aavogt> (for whatever the current algorithm in ghc is)
05:00:45 <quicksilver> jeltsch: I tihnk you will need a newtype or data wrapper to hide the polymorphism away
05:00:49 <quicksilver> I could be wrong, though.
05:01:05 <Eduard_Munteanu> Anyway, I'm not a big fan of full inference.
05:07:20 <quicksilver> Eduard_Munteanu: H-M type inference is linear in the size of the inferred types
05:07:34 <quicksilver> Eduard_Munteanu: it can occasionally be exponential in the size of the term.
05:07:43 <quicksilver> (that is, there exist terms whose types are exponentially big)
05:07:52 <quicksilver> but we tend not to write those terms.
05:08:18 <quicksilver> the exponential backtracking I mention for a possible 2-rank inference algorithm with backtracking can be caused by quite innocent looking terms, I believe.
05:09:47 <Eduard_Munteanu> Ah, I see.
05:10:25 <quicksilver> @tell chrisdone quote marks best used for ''quotation'' not for *emphasis* kthxbye :)
05:10:25 <lambdabot> Consider it noted.
05:14:14 <quicksilver> Eduard_Munteanu: let a=();b=(a,a);c=(b,b);d=(c,c);e=(d,d);f=(e,e);g=(f,f) in g
05:14:52 <quicksilver> Eduard_Munteanu: (example of a term whose type is longer than the term. ISTR there is a worse example I have forgotten how to construct.
05:18:14 <Eduard_Munteanu> Hm I think that fmap thingy was bad too.
05:19:28 <quicksilver> obviously the point is not merely that it's longer, but that each time you add a clause it gets twice as long ;)
05:19:32 <quicksilver> but I'm sure you spotted that.
05:24:17 <byorgey> let f a = (a,a) in f.f.f.f.f.f.f   -- same idea but a bit more concise
05:32:09 <mekeor> what are the differences between "data Foo = F { foo :: Integer, bar :: String }" (data-type) and "(Integer, String)" (tuple) ?  which one do you prefer? when would you use which?
05:33:04 <quicksilver> the difference is that F is a new type you have invented
05:33:13 <quicksilver> (Integer,String) is a standard type
05:33:32 <quicksilver> they have different purposes but for important data structures, define your own types.
05:34:36 <frerich> quicksilver: 'Foo' is the new type, right?
05:35:22 <Aune> there is a splitAt :: Int -> [a] -> ([a],[a]), is there a standard splitOn :: (Eq a) a -> [a] -> ([a],[a]) or a wordsOn :: a -> [a] -> [[a]] somewhere in the standard libraries? Hoogle cant find it for me.
05:36:04 <quicksilver> frerich: yes.
05:36:07 <quicksilver> Aune: No.
05:36:15 <quicksilver> Aune: but see Data.List.Split on hackage
05:36:29 <parcs> i.e the 'split' library
05:36:32 <quicksilver> http://hackage.haskell.org/package/split-0.1.4.1
05:36:40 <Aune> ok, will take a look
05:36:59 <Aune> Is there a reason it isnt in Data.List?
05:38:57 <byorgey> Aune: yes, the reason is no one can agree on exactly which function(s) ought to be added
05:39:22 <quicksilver> I thought it was to help keep this IRC channel busy
05:39:36 <quicksilver> without someone looking for a list-split three times a day, what would we talk about?
05:39:42 <mekeor> quicksilver: thank you.
05:39:57 <quicksilver> anyhow, byorgey generously offered to explore the design space with the split package
05:39:57 <Aune> byorgey,  Well, thats as good a reason as any it seems.
05:40:31 <quicksilver> :)
05:42:18 <Aune> wow, thats a lot more ways to split lists than I thought possible
05:43:51 <int-e> > unzip [(1,2),(1,3),(1,4)] -- splitting a list sideways *g*
05:43:52 <lambdabot>   ([1,1,1],[2,3,4])
05:45:30 <int-e> @hoogle (a -> (b, c)) -> [a] -> ([b], [c])
05:45:31 <lambdabot> No results found
05:47:04 <koeien> @djinn (a -> (b,c)) -> [a] -> ([b], [c])
05:47:05 <lambdabot> Error: Undefined type []
05:50:37 <byorgey> Aune: Yes, that's exactly why no one could agree =)
05:51:21 <int-e> @type (&&&) <$> map . (fst .) <*> map . (snd .)
05:51:22 <lambdabot> forall a b a1. (a1 -> (a, b)) -> [a1] -> ([a], [b])
05:53:03 <Aune> byorgey, yeah, in my mind it went from "people are silly who cant agree" to "of course people cant agree on this, I can hardly agree with myself on this"
05:53:12 <byorgey> hehe =)
05:53:13 <int-e> @type (&&&) `fmap` fmap fmap (fmap fst) <*> fmap fmap (fmap snd) {- once more for fans of fmap -}
05:53:15 <lambdabot> forall (f :: * -> *) a b a1. (Functor f) => (a1 -> (a, b)) -> f a1 -> (f a, f b)
06:00:12 <Cheery> Hi. Is there guys who have been working on apps that have used&modified directed graphs?
06:00:55 <Cheery> I'm having trouble with doing an internal data model for my editor.
06:00:57 <Cheery> http://paste.pocoo.org/show/477014
06:01:41 * hackagebot tokenize 0.1.2 - Simple tokenizer for English text.  http://hackage.haskell.org/package/tokenize-0.1.2 (GrzegorzChrupala)
06:02:38 <Cheery> I think I try kick it myself yet later today.
06:10:46 <erus`> this was like 20 LOC in haskell http://ideone.com/F4SmX
06:11:41 * hackagebot sirkel 0.1 - Sirkel, a Chord DHT  http://hackage.haskell.org/package/sirkel-0.1 (MortenLysgaard)
06:12:49 <kizzx2> will hackage do `cabal haddock` for me automatically or do i need to write somethign?
06:12:58 <kizzx2> in the "preview mode" i see there are no hyperlinks to the documentation?
06:14:40 <parcs> finally, a paste site with facebook integration
06:15:01 <ivanm> parcs: :o
06:15:07 <parcs> kizzx2: it's automatic
06:15:11 <ivanm> you want facebook integration with a paste site? :o
06:15:18 <kizzx2> parcs: thanks :)
06:15:34 <kizzx2> there is this warning saying "you can't upload with teh same version number" or someting making me feel nervous
06:15:55 <ivanm> kizzx2: well, bump the version then...
06:16:08 <ivanm> if you've already uploaded foo-x.y.z you can't override that same version
06:16:18 <kizzx2> version 0.2 -- "updated because i botched the last hackage upload"
06:16:30 <kizzx2> version 0.3 -- "updated because i mispelt my email addr"
06:16:45 <ivanm> kizzx2: if it's not a major version change in the API, then you should bump the 4th digit
06:16:47 <ivanm> @where PVP
06:16:48 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
06:16:51 <ivanm> kizzx2: ^^
06:17:01 <kizzx2> ivanm: o thanks
06:17:52 * ivanm should do the same as copumpkin's computer...
06:25:33 <hpaste> “md2perpe+hpaste@gmail.com” annotated “Can I use a GADT (Phantom Type) to solve my problem?” with “Can I use a GADT (Phantom Type) to solve my problem? (annotation)” at http://hpaste.org/51357#a51416
06:25:43 <siracusa> What are the advantages of inserting SPECIALIZE pragmas? The docs just say it will create extra code versions but I can't see why you'd want that.
06:26:48 <ClaudiusMaximus> might run faster.  i ended up removing them from one of my projects because ghc did it for me automagically anyway
06:27:49 <ClaudiusMaximus> like if you have some algorithm using RealFloat a =>  , a Float version and a Double version might be specialized if you use them
06:29:40 <kizzx2> siracusa: i think the motivation is that  typeclass potentially degrade perforance (http://www.haskell.org/haskellwiki/Performance/Overloading)
06:29:45 <kizzx2> siracusa: this thing called "dictionary"
06:30:33 <kizzx2> siracusa: i guess you can think of it as a vtable in C++, if you will
06:31:41 <siracusa> Hhm, I can't open that link
06:32:01 <kizzx2> that's odd
06:32:04 <siracusa> ah works now
06:32:42 <quicksilver> the main advantage of specialized code is that it can be inlined, siracusa
06:32:48 <quicksilver> and then optimised further
06:33:06 <quicksilver> or specialisation alone may permit more optimisation rules to fire
06:33:29 <quicksilver> not sure that first part is quite true :)
06:33:41 <quicksilver> actually inlining can happen without specialization.
06:33:45 <quicksilver> so it's more the second part.
06:34:14 <kizzx2> there's a pragma called SPECIALIZE INLINE :P
06:34:41 <ziman> I'd say it's more about Num dictionary lookups vs. fast integer math, for example.
06:35:20 <kizzx2> i think the use of this pragma should not arise too much
06:35:29 <siracusa> Interesting, I always thought that instance lookup is done at compile time
06:35:33 <kizzx2> it sounds like something the compiler can figure out for itself, given enough time and effort
06:36:20 <kizzx2> siracusa: i used to think so, but it gets compilcated when things are spread across different modules. looks like it turns out sometimes a dictionary is needed
06:36:50 <kizzx2> one of those situation is you write a library function       Num a => a -> a -> a
06:37:06 <kizzx2> when your library is compiled the compiler doesn't know waht kind of Num instance will get used by the client
06:37:32 <siracusa> Ah, I see
06:37:40 <kizzx2> and i heard one of the optimization GHC does is put the whole function "definition" inside teh .hi file
06:37:48 <kizzx2> for simple cases
06:37:51 <kizzx2> so it can inline the whole thing
06:40:49 <tswett> > [3,4,]
06:40:50 <lambdabot>   <no location info>: parse error on input `]'
06:40:57 * tswett nods.
06:41:23 <ski> kizzx2 : i think other cases are polymorphic recursion, and existentials
06:42:12 <kizzx2> existentials definitely
06:42:49 <quicksilver> well the simple reason you need dictionaries is for separate compilation.
06:43:24 <quicksilver> GHC putting method bodies in .hi files is a small step towards whole-program compilation
06:44:13 <quicksilver> with whole program compilation as an assumption from the start, you could always resolve type classes at compile time, I think, although it could be arbitrarily hard.
06:44:28 <quicksilver> I think you could always unravel the polymorphic recursion? if you can see the whole program.
06:44:30 <kizzx2> and hopefully not towards C++ compilation speed :P
06:44:49 <ski> quicksilver : what if it depends on input data ?
06:44:58 <quicksilver> ski: I don't think it can
06:45:07 <quicksilver> because that would imply the *type* depended on input data
06:45:11 <quicksilver> and haskell can't do that.
06:45:28 <ski> hmm
06:45:37 <kizzx2> ski: i think the input data has a type in the first place?
06:46:08 <ski> i'm pondering a `Foo -> exists x. C x *> Bar x' case
06:46:34 <keep_learning> i have three installation of ghc and i want to remove it before installing ghc7
06:46:45 <ski> can we somehow make something with polymorphic recursion that is "similar enough"
06:47:00 <hpaste> “md2perpe+hpaste@gmail.com” annotated “Can I use a GADT (Phantom Type) to solve my problem?” with “Can I use a GADT (Phantom Type) to solve my problem? (annotation)” at http://hpaste.org/51357#a51417
06:48:23 <keep_learning> which ghc gives /usr/local/bin/ghc , which ghc-6.10.3 gives /usr/bin/ghc-6.10.3 and which ghc-6.12.1 gives /usr/local/bin/ghc-6.12.1
06:48:54 <keep_learning> so if i delete these executable and rm -rf ~/.ghc
06:49:09 <keep_learning> will it remove all the ghc
06:49:32 <hpaste> “Alex R” pasted “containers-0.3.0.0 issue” at http://hpaste.org/51418
06:49:32 <obiwahn> :t (myfix f = f (myfix f))
06:49:33 <lambdabot> parse error on input `='
06:49:49 <obiwahn> hwo do i get type from selfdefined functions with lamdabot?
06:49:54 <obiwahn> types
06:50:04 <ski> @type let myfix f = f (myfix f) in myfix
06:50:06 <lambdabot> forall t. (t -> t) -> t
06:50:31 <rpglover64> Does anyone know how to fix the type error I just pasted (due to packages)
06:50:35 <whald> when using record syntax, how are the odds the accessor functions getting inlined? they show up in my profiling results and amortize to quite something, which makes me worry
06:50:46 <obiwahn> i do not get the other fix definition:(
06:50:51 <obiwahn> @src fix
06:50:51 <lambdabot> fix f = let x = f x in x
06:51:14 <obiwahn> how must i read that?
06:51:24 <quicksilver> whald: they are almost certainly inlined *except* when profiling?
06:51:32 <ski> it's nicer to write that as `fix f = x where x = f x', imo
06:51:37 <quicksilver> whald: (because the profiler inserts cost centres which inhibit inlining)
06:51:46 <danr> Well, if x is f x, then f x is f (f x), which is f (f (f x)), and so on
06:51:49 <quicksilver> whald: (you can't observe anything without changing it! ;)
06:52:33 <quicksilver> whald: anyhow, just being inlined doesn't mean they don't take time.
06:53:12 <merijn> obiwahn: It infinitely applies itself to its result
06:53:47 <merijn> > "This goes on forever " ++ fix ("and ever"++)
06:53:48 <lambdabot>   "This goes on forever and everand everand everand everand everand everand e...
06:54:05 <merijn> Damn, forgot a space
06:54:07 <merijn> Oh well
06:54:30 <koeien> > fix (1:)
06:54:31 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:54:54 <obiwahn> myfix f = f (myfix f) here i see it - as well as in ski's version but with let it was a bit hidden to me
06:56:05 <whald> quicksilver: I'll have to decide if what you said is good news or bad news for me :-)
06:56:41 * hackagebot qrcode 0.1 - QR Code library in pure Haskell  http://hackage.haskell.org/package/qrcode-0.1 (ChrisYuen)
06:56:43 <merijn> obiwahn: Oh, yeah. That's just a but unclear. "let X = Y in Z" == replace all X's in Z with Y's. So "fix f = let x = f x in x" is clearer when you ignore the naming and it becomes "let x = f x in x"
06:56:57 <whald> quicksilver: my profiling results are a bit obscured as they are, so i'll have to do something about that
07:10:28 <obiwahn> > fix (\b->"arrr"++b)
07:10:28 <lambdabot>   "arrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrarrrar...
07:11:08 <obiwahn> > fix (++"arrr")
07:11:12 <lambdabot>   mueval-core: Time limit exceeded
07:13:05 <cebrian> hi, Im having a strange error and I'd like to brainstorm possible causes
07:13:21 <cebrian> If I write filter (areConnected graph fixp) l_cand
07:13:29 <cebrian> it works correctly
07:13:37 <cebrian> but if I want to negate the condition
07:13:45 <cebrian> filter (not.areConnected graph fixp) l_cand
07:13:53 <cebrian> I get a compilation error
07:13:59 <cebrian> how could this be?
07:14:15 <kizzx2> obiwahn: http://www.vex.net/~trebla/haskell/fix.xhtml this page explains fix very clearly
07:14:19 <mauke> cebrian: because you're doing something wrong
07:14:48 <obiwahn> thanks
07:14:50 <dalaing_> do you need spaces around "."
07:15:01 <hpc> cebrian: try (not . blahblah) instead of (not.blahblah)? i know there's some edge condition where ghc does stupid things when spaces are missing
07:15:12 <cebrian> it does not work either with spaces
07:15:14 <cebrian> :(
07:15:23 <kizzx2> cebrian:  (not $ areConnected graph fixp)
07:15:27 <rwbarton> my guess is the code you're showing us is not your real code
07:15:29 <hpc> :t not
07:15:29 <lambdabot> Bool -> Bool
07:15:39 <hpc> :t filter
07:15:39 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:15:45 <merijn> Pastebinning a type error is a bit more useful then saying "it doesn't work"
07:15:51 <hpc> kizzx2: won't typecheck no matter how hard you try
07:16:04 <kizzx2> hpc: yes i just noticed its filter
07:16:09 <kizzx2> :P
07:16:16 <mauke> hpc: 'not' can't be a module name
07:16:19 <cebrian> ok, Ill paste the error
07:16:57 <hpaste> cebrian pasted “Problem with filter” at http://hpaste.org/51419
07:17:03 <hpc> mauke: oh, i remember what it is now
07:17:40 <mauke> cebrian: why did you redefine 'not'?
07:17:50 <cebrian> I didn't
07:17:50 <hpc> mauke: when you leave out spaces with nested lets, it can parse it in different ways
07:17:55 <mauke> cebrian: totally did
07:18:03 <rwbarton> agreed, not :: [Vertex]
07:18:05 <mauke> hpc: how?
07:18:19 <cebrian> do you want I paste bin the full let case?
07:18:23 <byorgey> cebrian: can you please paste your code as well?
07:18:27 <cebrian> yes
07:18:29 <quicksilver> cebrian: your error indicates that 'not' has the type [Vertex]
07:18:36 <mdmkolbe> What is the current state of the art for implementing/most efficient way to implement environments in Haskell?  Would it be Data.IntMap?  Is there some way to (safely) hide memory references in non-monadic code (i.e. the environment key is some sort of Ref/STRef/whatever and the value is just directly stored inside it)?
07:18:39 <quicksilver> you must have (inadvertantly?) rebound not
07:18:52 <hpc> > let a = 2 in let a = 1 in a+a
07:18:53 <lambdabot>   2
07:18:56 <hpc> > let a = 2 in let a = 1 in a + a
07:18:56 <lambdabot>   2
07:19:05 <hpaste> cebrian pasted “Problem with filter” at http://hpaste.org/51421
07:19:05 <hpc> hmm
07:19:21 <mauke> cebrian: (cur_v:not)
07:19:30 <mauke> cebrian: and that's not the full code
07:19:51 <quicksilver> cebrian: well, "cur_v:not" gives a clue that you have indeed rebound not somewhere :)
07:20:02 <quicksilver> you must believe it's a list to put it on the right of a :
07:20:11 <cebrian> ohhhhhh
07:20:16 <cebrian> now I see......
07:20:23 <cebrian> wow, thank you
07:20:31 <cebrian> yes I used a parameter called not
07:20:35 <mauke> heh
07:20:38 <quicksilver> :)
07:20:40 <cebrian> because of the algorithm transcription
07:20:49 <cebrian> thanks a lot
07:21:06 * ski one time used `a',`b',`c' as well as `r',`g',`b' ..
07:21:14 <byorgey> #haskell Detective Service at your service
07:21:24 <byorgey> ski: heh
07:22:23 <byorgey> mdmkolbe: if you really want non-monadic code you could put the environment inside a global IORef I suppose.
07:22:52 <byorgey> mdmkolbe: but usually in the sort of code where I want some sort of environment I am using a monad anyway, and I just add a  ReaderT Environment to the stack
07:23:21 <rwbarton> it'd be nice if with -Wall ghc could warn about the shadowing even when there's also a type error as here
07:23:25 <byorgey> mdmkolbe: IntMap works great if your keys are Ints, otherwise just use a Map.
07:23:52 <byorgey> rwbarton: does it not do that?
07:24:06 <rwbarton> not in 6.12 at least
07:24:10 * byorgey agrees that would be nice
07:25:09 <djahandarie> Hmm, is there a nice way to wait on a TMVar to be updated? The way I did it was by adding a TChan () which just sends a 'ping' when there is an update, but I was wondering if there was a nicer way
07:25:29 <quicksilver> rwbarton: *especially* if the type error is on a shadowed term.
07:25:35 <quicksilver> rwbarton: (or relates to a shadowed term)
07:25:45 <rwbarton> indeed! it would be quite helpful here, although the warning is not on by default anyways
07:26:04 * hpc shadows id all the time on his website
07:27:12 <mdmkolbe> byorgey: this is for a (semi-)production compiler, and I've got a strong suspicion that env lookup is one of our bottlenecks.  It is not where to store the env that is the problem, but the implementation of the env itself.  (If I were in ML or scheme, env lookup is one instruction (i.e. put the data in the identifier itself).  Obviously this only works when we can mutate (and change the type of) the stored data.)
07:29:10 <byorgey> mdmkolbe: oh, that kind of thing can be done in Haskell too.  For example GHC actually uses mutable vars when doing unification, rather than carry around an environment.
07:30:50 <byorgey> mdmkolbe: I'm trying to find you to a link to a paper I recall that explains the technique
07:31:46 <djahandarie> Mutation?!
07:31:59 <quicksilver> yeah, GHC's dirty secret :(
07:32:03 <quicksilver> it's not written in haskell at all.
07:32:06 <quicksilver> loads of cheats.
07:32:08 <djahandarie> Lies!!!
07:32:15 * djahandarie covers his ears and yells
07:33:23 <byorgey> mdmkolbe: ah, "Practical Type Inference for Arbitrary-Rank Types" by Peyton Jones et al.
07:33:23 <tac-tics> Clearly haskell isn't the language I thought it was.....
07:33:36 <mdmkolbe> byorgey: but I presume that doing so requires all env lookups be monadic, right?  (I'm not adverse to monadic, but I'm working on a code base that is using non-monadic environments, and I'd rather avoid a wholesale rewrite.)
07:33:52 <byorgey> what? Haskell is the world's best imperative language.
07:33:55 <byorgey> mdmkolbe: yes, it does
07:34:18 * byorgey doesn't see what all the fuxx is about
07:34:22 <byorgey> fuss, even
07:34:31 <djahandarie> byorgey, ... that was published two days ago?
07:34:39 <djahandarie> Hmm, no, 2007
07:34:40 <rwbarton> are we just talking about putting IORefs in a Map, or something more sinister?
07:34:41 <byorgey> uh... what?
07:35:03 <djahandarie> byorgey, the date on top sayd 14 September 2001, but it was just an update :P
07:35:13 <byorgey> rwbarton: no, that's all
07:35:22 <byorgey> djahandarie: 14 September 2001 was not two days ago either
07:35:26 <obiwahn> > let f _ = 1 in (f True) + (f 3)
07:35:27 <lambdabot>   2
07:35:34 <djahandarie> byorgey, 2011... leave me alone :(
07:35:35 <mdmkolbe> byorgey: I just got the version from SPJ page, where in the 88 pages of goodness am I supposed to be looking?
07:35:38 <byorgey> djahandarie: =)
07:36:13 <byorgey> mdmkolbe: just skim until you find where they explain the framework they're using, or ISTR there's an appendix at the back with some code
07:36:28 <byorgey> mdmkolbe: you don't care about the algorithms described in the paper, just the implementation approach
07:37:46 <mdmkolbe> rwbarton: actually, I'm guessing that you wouldn't even put them in a Map.  Just use the IORef as the identifier
07:39:04 <byorgey> yeah, I think that's the idea.  So you don't have to do lookups in a data structure at all.
07:50:20 <obiwahn> how do i allow nonshallow types?
07:50:30 <obiwahn> > let f _ = 1 in (f True) + (f 5)
07:50:31 <lambdabot>   2
07:50:42 <obiwahn> my bot can not evaluate something like this
07:51:28 <erus`> thats an error?
07:51:40 <erus`> nope
07:51:41 * hackagebot gutenberg-fibonaccis 1.0.0 - The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project.  http://hackage.haskell.org/package/gutenberg-fibonaccis-1.0.0 (JustinHanekom)
07:51:58 <obiwahn>  No instance for (GHC.Num.Num GHC.Bool.Bool)
07:51:58 <copumpkin> o.O
07:52:39 <Nimatek> Lol.
07:52:57 <quicksilver> that an... interesting thing to upload to hackage?
07:52:59 <rostayob> wow, that's a useful package
07:53:31 <hpc> lol
07:53:39 <koeien> hahahaha, lol
07:53:46 <hpc> it doesn't even generate them, it's just a huge list of numbers
07:54:00 <Nimatek> Finally the first 1001 Fibonacci numbers are in the public domain!
07:54:14 <koeien> hpc: yeah i saw it
07:54:15 * byorgey installs it
07:54:17 <hpc> version 1.1 will "compress" them with the naive algorithm :P
07:54:23 <rostayob> yes, it's a [Integer] with all the numbers.
07:54:25 <rostayob> amazing.
07:54:26 <quicksilver> considering haskell can calculate them in under a second on my machine
07:54:39 <erus`> rostayob: not an IO [Integer] ?
07:54:48 <copumpkin> http://snapplr.com/4b3q
07:54:50 <koeien> nope.
07:54:53 <rostayob> erus`: ? no it's just a list with all the numbers hard coded
07:54:53 <quicksilver> it's not like it's an expensive thing which is worth having as a static things
07:54:55 <byorgey> quicksilver: don't waste your precious CPU time when they are already pre-calculated!!
07:55:06 <copumpkin> "The lastFib function returns the last Fibonacci number in the list"
07:55:17 <copumpkin> just in case you want the 1001st fibonacci number
07:55:38 <copumpkin> "The fibsLen function returns the number of Fibonacci numbers, in the first1001Fibs list"
07:55:42 <rostayob> for the curious: 70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501
07:55:58 <erus`> is this haskell humour?
07:55:59 <rostayob> ahahahah fibsLen
07:56:07 <hpc> oh man, it would have been hilarious if it actually fetched the numbers from the project gutenberg page
07:56:36 <byorgey> wow, it takes a REALLY LONG time to compile
07:56:37 <erus`> i can imagine you all snorting as you laugh
07:56:42 <copumpkin> he should have a firstFib too
07:57:05 <parcs> obiwahn: :set -XNoMonoLocalBinds
07:57:19 <rostayob> also, there is a "isFib" which does something stupid
07:57:20 <Nimatek> When will the evil corporation finally relinquish their patents on the next 1001 Fibonacci numbers?
07:57:24 <Nimatek> corporations*
07:57:29 <byorgey> ghc has my CPU pegged using 1.8% of my 6GB of ram trying to compile Gutenberg.Fibonaccis
07:58:19 <byorgey> ok, it was up to 10% memory so I killed it
07:59:11 <obiwahn> :t \f->(f True) + (f 5)
07:59:12 <lambdabot>     No instance for (Num Bool)
07:59:12 <lambdabot>       arising from the literal `5' at <interactive>:1:18
07:59:12 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
07:59:37 <hpc> byorgey: i was able to ghci it
07:59:38 <byorgey> obiwahn: higher-rank polymorphism cannot be inferred
07:59:50 <rostayob> byorgey: really? it took nothing to compile on my machine
08:00:03 <byorgey> rostayob: interesting.  What version of ghc?
08:00:20 <rostayob> byorgey: 7.0.3
08:00:32 <byorgey> hmm, I was using 7.2.1, let me try with 7.0.3
08:00:52 <parcs> 7.2.1 is really slow to compile some things
08:01:06 <parcs> like Data.Text
08:01:08 <byorgey> perhaps the real point of this package is as a passive-aggressive bug report of a performance regression in GHC  =)
08:01:17 <hpc> ghc is munching on 22% of my mem right now
08:01:19 * quicksilver nods
08:01:28 <rostayob> well, I can confirm it works well
08:01:29 <quicksilver> well GHC has always had a bad reputation on long constant lists
08:01:36 <hpc> lol, it doesn't even link
08:01:39 <quicksilver> and, I think also on large integers?
08:01:39 <copumpkin> large constants in general
08:01:45 <copumpkin> it also builds up Integers in a funky way
08:01:46 <hpc> /usr/bin/ld: /usr/lib/ghc-6.12.1/libHSrtsmain.a(Main.o): in function main:(.text+0x10): error: undefined reference to 'ZCMain_main_closure'
08:01:49 <hpc> /usr/bin/ld: /usr/lib/ghc-6.12.1/libHSrtsmain.a(Main.o): in function main:(.text+0x18): error: undefined reference to '__stginit_ZCMain'
08:01:52 <hpc> collect2: ld returned 1 exit status
08:03:13 <rostayob> hpc: your compiler is not good enough for gutenber-fibonaccis.
08:03:40 <byorgey> huh, you're right, 7.0.3 compiled it for me with no problems -- memory usage only got up to about 3%
08:03:51 <byorgey> and it took about 10 seconds
08:04:02 <kadoban> wow, really long lists it doesn't do well? that's kind of surprising
08:04:02 <byorgey> whereas 7.2.1 was crunching away for several minutes before I killed it
08:11:02 <byorgey> hmm, perhaps it's related to http://hackage.haskell.org/trac/ghc/ticket/5284
08:29:23 <Cheery> nobody still here
08:30:18 <tac-tics> I'm here
08:30:23 <tac-tics> Are there any other survivors??
08:30:40 <mamalujo> of what?
08:31:10 <tac-tics> The netsplit
08:33:32 <mamalujo> hm, it looked massive enough, but I thought one is supposed to see a notice that a netsplit occured, and when  it ended
08:35:15 <hpc> no, but it does say QUIT: netsplit
08:35:22 <hpc> for each person
08:35:36 <hpc> none of those were netsplits
08:36:41 * hackagebot gutenberg-fibonaccis 1.0.1 - The first 1001 Fibonacci numbers, retrieved from the Gutenberg Project.  http://hackage.haskell.org/package/gutenberg-fibonaccis-1.0.1 (JustinHanekom)
08:36:50 <mamalujo> I don't even see those, just a mix of  Connection reset by peer, Quit: Leaving, Ping timeout etc
08:37:14 <mamalujo> right
08:39:22 <Cheery> it seems nobody is going to solve the editor problem for me
08:40:15 <Cheery> so I'll have to try solving it myself again and again, until I get it
08:42:34 <Cheery> anyone want a chance of participation?
08:46:50 <byorgey> Cheery: what's the editor problem?
08:48:51 <Cheery> byorgey: I need a graph sort of.. I'd have to be able to copy between different graphs, modify those graphs and hold information for undo from each operation done.
08:49:54 <Cheery> byorgey: I've considered it'd be a directed graph, possibly acyclic. node would be either list or leaf.
08:51:11 <warrenharris_> wdm: good morning
08:51:41 <Cheery> byorgey: unfortunately, it has given me already some challenges to structure code for that model.
08:52:08 <Cheery> the worst of that being it grows complex and unwieldy
08:52:21 <Cheery> hi warrenharris_
08:53:39 <mamalujo> byorgey: if I may be so bold to nag, how is the typekinds stuff progressing? I ask since I see GhcKinds trac wiki page is fairly active, and apparently includes some code for the extension, but there the design appears to be to keep the kind level distinct
08:54:10 <byorgey> mamalujo: it is going well.  we are indeed keeping the kind level distinct for now.
08:54:30 <byorgey> mamalujo: the reason is that collapsing the type and kind levels makes the equational theory much, much more complicated
08:54:39 <byorgey> so for now we are starting out with something simple
08:55:00 <mamalujo> I see, good, nice to hear its all part of the same master plan ;-)
08:55:20 <byorgey> mamalujo: we are working on a paper for TLDI, due in a little under a month, so you will be able to read more about it then
08:55:44 <mamalujo> great! looking forward to reading whatever I may be able to follow there :)
09:08:42 <coppro> win 129
09:41:48 * hackagebot numeric-tools 0.1.0.0 - Collection of numerical tools for integration, differentiation etc.  http://hackage.haskell.org/package/numeric-tools-0.1.0.0 (AlexeyKhudyakov)
09:50:18 <vrthra> hello, is there a reason the Zipper and TravelTreee/TravelBTree described in the haskell wiki are not available in hackage?
09:50:25 <vrthra> are they obsoleted by any package?
09:50:44 <hpc> @hoogle Zipper
09:50:44 <lambdabot> No results found
09:50:47 <vrthra> this is the wiki link http://www.haskell.org/haskellwiki/Zipper_monad/TravelBTree
09:52:39 <hpc> @src Mu
09:52:39 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
09:53:16 <KirinDave> I confess
09:53:21 <KirinDave> That type confuses the hell out of me
09:53:26 <KirinDave> As do Free monads.
09:55:42 <copumpkin> KirinDave: it's the analog to fix
09:55:55 <copumpkin> fix f = f (fix f)
09:56:10 <copumpkin> type Mu f = f (Mu f)
09:56:15 <copumpkin> except we can't have type functions that recurse
09:56:18 <copumpkin> so we wrap it in a newtype
09:56:18 <KirinDave> So it's fix for types?
09:56:21 <copumpkin> yes
09:56:30 <KirinDave> The Newest Type.
09:56:40 <copumpkin> freshtype
10:00:02 <shachaf> KirinDave: Just look at some examples of recursive types and it'll make sense.
10:00:11 <KirinDave> are there artesian, organic types?
10:00:14 <KirinDave> Local-grown?
10:05:25 <kamatsu> Hi all, I'm delivering a lecture on the HM type inference algorithm (W) next week to a PLs course.
10:06:10 <copumpkin> omg it's a kamatsu
10:06:13 <kamatsu> anyone got any advice? My understanding of the algorithm came fairly quickly, so I'm not sure what people will have trouble with
10:06:35 <monochrom> show examples
10:06:36 <kamatsu> copumpkin, omg, it's a pumpkin
10:08:22 <kamatsu> examples, yes
10:08:35 <kamatsu> but, what I'm more referring to is, how should I try and explain it?
10:08:55 <hpc> kamatsu: you can take any examples you want from here, if they help: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=4
10:09:14 <copumpkin> :t fix . (>=>)
10:09:15 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
10:09:37 <kamatsu> last time i gave this lecture, I just presented the inference rules and tried to convey some intuition as to what they were doing
10:09:48 <kamatsu> I got a lot of half-hearted nods and scared looks
10:10:14 <byorgey> did you put all the inference rules on one slide?
10:10:28 <hpc> kamatsu: open with one good example, then infer the type by hand
10:11:10 <hpc> kamatsu: then show them the rules and show how they map to the manual way
10:11:22 * hpc is giving this advice without actually knowing the HM algorithm in any detail
10:11:40 <hpc> but it's how i think i would learn it best
10:12:10 <byorgey> kamatsu: you could also talk about what would go wrong if you allowed higher-rank types
10:12:22 <kamatsu> hpc: your example calls unification "pattern matching", unification is pattern matching that goes both ways, it's not exactly the same
10:12:23 <byorgey> the restriction to prenex polymorphism is one of the most interesting/subtle points
10:12:26 <kamatsu> but good intuition nonetheless
10:13:04 <kamatsu> byorgey, we haven't talked about higher ranks yet
10:13:26 <byorgey> it's easy enough to define
10:13:32 <kamatsu> in fact, we only introduced type variables last week, and they're all prenex universally quantified.
10:13:49 <byorgey> fair enough, just a suggestion.
10:13:53 <kamatsu> but we could introduce it before ty-inf if it adds value to the explanation
10:14:55 <kamatsu> they have to implement it themselves for their assignment
10:15:15 <kamatsu> so i'm not too fussed if they don't understand the tiniest details in the lecture
10:15:39 <kamatsu> they need to get a picture of how it all works though, need to be convinced that it actually does what it's supposed to.
10:15:45 <TheLemonMan> the arguments passed to the foldr callback are accumulator and item (in this order), right ?
10:16:00 <kamatsu> :t foldr
10:16:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:16:01 <byorgey> TheLemonMan: no, other way around.
10:16:10 <kamatsu> byorgey is right
10:16:14 <hpc> TheLemonMan: sum = foldr (+) 0
10:16:29 <hpc> TheLemonMan: if that helps you remember
10:16:34 <kamatsu> hpc: he's talking about the function arg
10:16:38 <tac-tics> TheLemonMan: Using the word "Callback" is kinda funny in Haskell :)
10:16:38 <byorgey> hpc: that doesn't help at all.
10:16:46 <hpc> oh
10:17:10 <TheLemonMan> oh, and does foldl takes them the other way round ?
10:17:16 <byorgey> TheLemonMan: yes
10:17:24 <byorgey> > foldr f z [a,b,c]
10:17:25 <lambdabot>   f a (f b (f c z))
10:17:42 <kamatsu> so, there's really three sorts of areas that you have to get right when implementing W, right?
10:17:45 <byorgey> TheLemonMan: you can remember the order if you remember how foldl and foldr work (see above)
10:17:46 <hpc> > foldl f z [a,b,c]
10:17:47 <TheLemonMan> subtle tiny differences that makes you go nuts
10:17:47 <lambdabot>   f (f (f z a) b) c
10:18:00 <kamatsu> 1 is trivial type inference like integer literals are of type int, or primop inferences
10:18:24 <kamatsu> 2 is type inference which needs unification to succeed, like function application
10:18:47 <kamatsu> and 3 is type inference which needs some type information to propagate from some other part of the program around into your subexpressions (i.e why you need to hold on to your unifiers)
10:19:01 <tac-tics> TheLemonMan: diagrams are helpful here
10:19:02 <tac-tics> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
10:19:25 <mauke> I've memorized foldr \x z and foldl \z x
10:19:26 <tac-tics> fold basically replaces the cons's (:) with the operator you pass
10:19:30 <tac-tics> and nil with the constant you pass
10:25:54 <bos> preflex: src odd
10:26:01 <bos> preflex: @src odd
10:26:04 <bos> bah
10:26:08 <mauke>  odd = not . even
10:26:09 <bos> @src odd
10:26:10 <lambdabot> odd = not . even
10:26:14 <bos> @src even
10:26:15 <lambdabot> even n = n `rem` 2 == 0
10:26:17 <mauke> even = not . odd
10:26:18 <bos> much better
10:26:25 <TheLemonMan> so, a foldl is the same as a foldr with flip applied to the callback
10:26:37 <mauke> unlikely
10:27:02 <TheLemonMan> well, if i don't care about list order it should
10:27:12 <mauke> > foldr (\x z -> show x ++ z) "." [1,2,3]
10:27:13 <lambdabot>   "123."
10:27:21 <EvanR-work> TheLemonMan: well theres laziness to think about
10:27:25 <mauke> > foldl (flip (\x z -> show x ++ z)) "." [1,2,3]
10:27:26 <lambdabot>   "321."
10:27:56 <EvanR-work> mauke: its the same, he doesnt care about order ;)
10:28:43 <TheLemonMan> this because in the learn you a haskell tutorial its building a binary tree using a foldr without any explanation
10:28:43 <ido> > puts "hi"
10:28:44 <lambdabot>   Not in scope: `puts'
10:28:46 <shachaf> It's still different even for an associative function.
10:28:49 <ido> > "hi"
10:28:49 <lambdabot>   "hi"
10:29:09 <TheLemonMan> there's no reason to use a foldr there so i started thinking of why it did so
10:29:38 <EvanR-work> as far as i know no one ever uses foldl
10:29:45 <EvanR-work> except for foldl'
10:29:58 <EvanR-work> for special cases
10:31:39 <shachaf> @src sum
10:31:39 <lambdabot> sum = foldl (+) 0
10:31:59 <EvanR-work> shouldnt that be foldl'
10:32:09 <copumpkin> GHC figures that out
10:32:13 <copumpkin> and makes it equivalent to foldl'
10:32:22 <EvanR-work> GHC probably has nothing to do with @src ;)
10:32:23 <copumpkin> however, foldl' didn't exist in the report so it's still defined as foldl
10:33:09 <EvanR-work> basically foldl' exists so you can define sum ;)
10:45:42 <JoeyA> In transformers, this is how the MonadPlus instance is implemented:
10:45:44 <JoeyA> m `mplus` n = StateT $ \s -> runStateT m s `mplus` runStateT n s
10:45:47 <JoeyA> Isn't that wrong?
10:46:08 <JoeyA> Shouldn't any state change on the left side be propagated to the right side?
10:46:54 <JoeyA> (Control.Monad.Trans.State.Strict)
10:47:13 <keep_learning> what is difference between import Data.IntMap (IntMap)
10:47:13 <keep_learning> import qualified Data.IntMap as IntMap
10:47:43 <hpc> keep_learning: import Foo (Bar) imports Bar from Foo
10:48:01 <hpc> import Foo as Bar imports everything from Foo, but pretends the module is named Bar
10:50:58 <byorgey> JoeyA: no, mplus represents choice
10:51:15 <byorgey> JoeyA: if the first computation fails you don't want to keep around the changes to the state that you made while trying it
10:51:37 <JoeyA> oh, d'oh
10:51:50 <JoeyA> I was thinking of Applicative
10:51:56 <JoeyA> thanks
10:52:00 <byorgey> sure
10:57:58 <Olathe> How do I control the order that list comprehensions generate elements in?
10:58:39 <tac-tics> Olathe: What do you mean exactly?
10:58:50 <tac-tics> > [x * x | x <- [1,2,3]]
10:58:52 <lambdabot>   [1,4,9]
10:59:04 <tac-tics> The order will be the same as the inputs you give it
10:59:38 <Olathe> > [(a, b) | a <- [1..3], b <- [1..3]]
10:59:39 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
10:59:48 <Olathe> Ahh, so the last one gets incremented first.
11:00:47 <Olathe> Thanks.
11:01:17 <tac-tics> Olathe: ah, I see what you mean. You can read the <- almost like "for loops" in the generators
11:01:22 <tac-tics> Same with using List as a monad
11:01:46 <tac-tics> > do { x <- [1,2,3]; y <- ['a', 'b', 'c']; return (show x ++ show y) }
11:01:48 <lambdabot>   ["1'a'","1'b'","1'c'","2'a'","2'b'","2'c'","3'a'","3'b'","3'c'"]
11:02:13 <tac-tics> Reads just like "for x in [1,2,3] { for y in [a, ,b,c] { return x + y} }
11:03:00 <Olathe> Ahh, cool.
11:11:07 <shachaf> Olathe: It's just concatMap.
11:34:37 <elliott> Does GHC do -fllvm by default nowadays?
11:34:41 <elliott> (If yes, starting in which version?)
11:35:39 <parcs> to
11:35:40 <parcs> no
11:35:52 <elliott> Aw.
11:36:04 <parcs> fllvm just started working for me on 7.2
12:07:28 <TheLemonMan> im trying to write an instance for a custom data type named Struct
12:08:01 <TheLemonMan> i wrote instance Eq (Maybe Struct) but GHC complaints about it being an illegal declaration
12:08:14 <mauke> indizzle
12:08:35 <mauke> write an instance for Eq Struct instead
12:09:11 <TheLemonMan> what if i want it to inherit maybe values too ?
12:09:33 <mauke> huh?
12:09:33 <mauke> what do you mean by "inherit"?
12:09:58 <parcs> there's an Eq instance for Eq a => Maybe a so if your data type T has an Eq instance so does Maybe T
12:10:55 <benmachine> and also Maybe (Maybe T)
12:11:10 <TheLemonMan> arr, wait, can i define a type with maybe option too or it's only for use in type declarations ?
12:11:19 <mauke> what
12:12:16 <TheLemonMan> im definitely not good at explaining my thoughts
12:13:13 <dmwit> Why not paste (to hpaste.org) some code you thought should work but didn't?
12:13:20 <dmwit> Perhaps that would help.
12:14:24 <parcs> you can define a custom type that looks like Maybe and is specific to your data but it's best to reuse the abstractions that are already provided for you
12:14:48 <hpaste> TheLemonMan pasted “whatever” at http://hpaste.org/51426
12:15:27 <mauke> TheLemonMan: why do you think that should work?
12:15:46 <TheLemonMan> i'm pretty sure the maybe part is wrong
12:16:13 <dmwit> TheLemonMan: Yes. Delete it, and the Just bits, too.
12:16:30 <parcs> create an Eq Struct instance instead
12:16:45 <dmwit> instance Eq Struct where (Struct p1 p2) == (Struct p3 p4) = p2 == p4
12:16:56 <mauke> s/p[13]/_/g
12:17:12 <dmwit> Yep, the style can be improved.
12:17:17 <dmwit> But first make it work!
12:17:19 <dmwit> =)
12:17:31 <TheLemonMan> i already did that but wanted to try using maybe too
12:18:01 <dmwit> TheLemonMan: There's already an instance Eq a => Eq (Maybe a)
12:18:12 <dmwit> TheLemonMan: So if you have Eq Struct, then you have Eq (Maybe Struct) for free.
12:19:27 <parcs> TheLemonMan: you can't define an Eq (Maybe Struct) instance because haskell is by default very conservative in what kind of instances you can define
12:19:36 <parcs> err. ghc
12:19:51 <Nimatek> > Just "test" == Just "test"
12:19:52 <lambdabot>   True
12:20:58 <bfig> >Nothing == Nothing
12:21:02 <bfig> > Nothing == Nothing
12:21:03 <lambdabot>   True
12:21:08 <bfig> > Nothing == Something
12:21:09 <lambdabot>   Not in scope: data constructor `Something'
12:21:18 <bfig> > x == x
12:21:19 <lambdabot>   True
12:21:28 <bfig> one more...
12:21:36 <bfig> > Something == Something
12:21:37 <lambdabot>   Not in scope: data constructor `Something'Not in scope: data constructor `S...
12:21:48 <mauke> @let a === b = cast a == Just b
12:21:49 <lambdabot>  Defined.
12:21:57 <mauke> > x === "test"
12:21:59 <lambdabot>   False
12:22:02 <TheLemonMan> what if i want to do something like Nothing == (Struct "poow" 3) ?
12:22:05 <mauke> > Just "test" === "test"
12:22:07 <lambdabot>   False
12:22:11 <mauke> TheLemonMan: that makes no sense
12:22:17 <monochrom> can't be done. don't do it.
12:22:20 <mauke> TheLemonMan: two values can't be equal if they have different types
12:22:37 <koeien> they can't even be tested for equality
12:23:14 <mauke> > "koeien" === Just "koeien"
12:23:15 <lambdabot>   False
12:23:24 <engla> why does lambdabot evaluate the above?
12:23:27 <koeien> Nothing is of type Maybe a, Struct "poow" 3 is of type Struct. These are different
12:23:29 <dmwit> > cast "qoeid" :: Maybe String
12:23:30 <lambdabot>   Just "qoeid"
12:23:36 <koeien> engla: because mauke is evil :)
12:23:43 <dmwit> > cast "qoeid" == Just "qoeid"
12:23:44 <monochrom> if you really want to push it, you may be better off forgetting "Maybe Struct" altogether and re-designing Struct to include your own "null" case
12:23:44 <lambdabot>   True
12:23:51 <engla> oh, triple ===
12:23:51 <dmwit> mauke: my brain exploded
12:24:19 <dmwit> > "koeien" == "koeien"
12:24:20 <lambdabot>   True
12:24:30 <TheLemonMan> gotcha, i think i got it now
12:24:32 <mauke> > True === True
12:24:34 <lambdabot>   True
12:24:40 <dmwit> oh
12:24:43 <dmwit> terrible
12:25:37 <keep_learning> @Data.IntMap
12:25:37 <lambdabot> Unknown command, try @list
12:25:53 <hpaste> int80_h pasted “why am I getting this error?” at http://hpaste.org/51428
12:26:55 <parcs> delete the "in"
12:26:58 <dmwit> int80_h: In do-blocks, let blocks are allowed to not have "in".
12:27:08 <dmwit> Then, they end when the indentation level changes.
12:27:10 <koeien> int80_h: you have the let..in confused
12:27:16 <mauke> int80_h: you've got syntax errors in lines 18, 19, 20
12:27:17 <dmwit> So, you're trying to "end" the let block twice.
12:27:40 <int80_h> ah
12:27:42 <int80_h> thanks
12:27:50 <koeien> int80_h: so, line 17 is fine, but then write another "let" in line 18. Then delete the "in" in line 20
12:28:08 <monochrom> why are you interleaving let-in with do-notation?
12:28:26 <koeien> do { let x = 3 in Just x }
12:28:40 <koeien> > do { let x = 3 in Just x }
12:28:41 <lambdabot>   Just 3
12:28:42 * koeien runs
12:29:06 <monochrom> you need to start a second let block after "jobFileNames <- processedPath <$> getDirectoryContents directoryPath"
12:29:06 <dmwit> > do let {x = 3}; Just x
12:29:07 <lambdabot>   Just 3
12:29:24 <dmwit> hm
12:29:29 <dmwit> > do let x = 3; Just x
12:29:30 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:30:02 <int80_h> monochrom: I tried to figure out a way to avoid interleaving, couldn't come up with any. Suggestions?
12:30:07 <monochrom> "do let x = 3; Just x" means "do {let {x = 3; Just x}}"
12:30:25 <monochrom> I just suggested starting a second let block
12:30:48 <int80_h> ah, I responded before reading that
12:30:57 <monochrom> "let {x=1}; y <- f x; let {z = y}" is just fine
12:31:23 <Clint> is there a pointfree form of \x -> read x :: Float ?
12:31:39 <dolio> read
12:31:52 <mauke> read :: String -> Float
12:32:16 <Clint> mauke: thanks
12:32:16 <mauke> why are you using Float?
12:32:26 <koeien> unless you have a good reason, use Double instead
12:32:41 <Clint> i have no reason
12:32:56 <mauke> :t (`asTypeOf` 0.0) . read
12:32:57 <lambdabot> forall a. (Fractional a, Read a) => String -> a
12:33:00 <mauke> good enough
12:35:45 <int80_h> monochrom: I started a new let block after jobFileName <- ..., but now it's making the same complaint about the line that starts the new let block
12:36:16 <mauke> show me </morpheus>
12:36:20 <int80_h> oh I missed the suggestion about the in
12:38:02 <int80_h> hmm parse error on my where clause, I'll paste
12:39:42 <hpaste> int80_h pasted “parse error in where clause” at http://hpaste.org/51429
12:40:43 <ion> int80_h: The ‘where’ probably can’t be indented more than the ‘do’ above.
12:40:54 <mauke> I don't see why not
12:41:10 <mauke> oh, I see why
12:41:16 <int80_h> do tell :)
12:41:26 <mauke> int80_h: why is line 16 indented as if it was a let binding?
12:41:36 <c_wraith> honestly, that should work if you just take out the "do"
12:42:00 <ion> Hmm. There’s ‘getFileContents $ sort $ sortJobNumbers’ without ‘=’ in a let block.
12:42:25 <c_wraith> yeah, readJobFile is all messed up
12:42:36 <int80_h> c_wraith: I thought you needed do notation, or de-sugared equivilent if using functions returning IO Sometype
12:42:45 <ddarius> Why?
12:42:48 <c_wraith> @undo foo
12:42:48 <lambdabot> foo
12:42:54 <c_wraith> @undo do foo
12:42:54 <lambdabot> foo
12:43:07 <c_wraith> if you have a single expression, there's no need for anything else
12:43:14 <int80_h> ddarius: I guess I made a faulty generalization based on previous observations of other people's code.
12:43:33 <c_wraith> do is only needed if you don't want to use >>=
12:43:37 <c_wraith> (or >>)
12:43:45 <mauke> c_wraith: that's the de-sugared equivalent
12:43:57 <tsuraan> I was wondering if anybody could critique an Enumeratee I just got working.  It does two useful things: the fold-ee function can terminate the folding, and on EOF it gives the user the ability to do a final handling of the fold's state.  pastie is at http://hpaste.org/51430
12:44:00 <c_wraith> mauke: my point was more about the result of the de-sugaring
12:44:06 <ddarius> A value of type IO A is just a value as any other.
12:44:22 <koeien> :t putStrLn "x"
12:44:23 <lambdabot> IO ()
12:44:32 <koeien> @let main = putStrLn "x"
12:44:34 <lambdabot>  Defined.
12:44:35 <c_wraith> mauke: if the de-sugared version doesn't have a >>= or >> in it, then... desugaring didn't change much.
12:44:40 <koeien> -- ^ is valid
12:44:44 <koeien> @undef
12:45:12 <wavewave> hi..
12:45:19 <koeien> it's possible to write main = do putStrLn "x" as well, doesn't harm.
12:45:34 <wavewave> is there a way to install ghc on an old linux machine with glibc 2.5 ?
12:45:40 <wavewave> ghc 7
12:45:42 <wavewave> I mean.
12:45:48 <mauke> built it from source, I guess
12:45:51 <mauke> *build
12:46:12 <wavewave> mauke: thnx!
12:46:46 <ddarius> main = do do head [putStrLn "x"]
12:47:29 <benmachine> > do do do do do do do do do ()
12:47:29 <lambdabot>   ()
12:48:00 <c_wraith> > do 5
12:48:00 <lambdabot>   5
12:48:01 <ion> > do do do do do do do do do do do do do do do do batman
12:48:03 <lambdabot>   batman
12:48:13 <c_wraith> batman = text "batman"
12:48:39 <wavewave> hope that this building ghc from source will work.
12:49:45 <int80_h> I removed the do, and now have a parse error, I'll just put it back
12:50:41 <DevHC> sizeOf (a :: forall a. Num a => a) == 8. hmm !
12:51:03 <ddarius> > sizeOf (undefined :: Integer)
12:51:04 <lambdabot>   Not in scope: `sizeOf'
12:51:08 <DevHC> FAIL.
12:51:12 <Phyx-> how would that work?
12:51:17 <tac-tics> kythe: hey
12:51:29 <Phyx-> there's a storable defined for num?
12:51:43 <Phyx-> that seems silly...
12:51:44 <DevHC> i wonder if sizeOf (a :: forall a. Num a => a) increases if i add new instances of (Storable a, Num a)
12:53:44 <Phyx-> why did you define a Storable for num?
12:54:03 <c_wraith> forget "why"...  "how" seems appropriate?
12:54:29 <DevHC> Phyx-: i did not
12:54:34 <c_wraith> DevHC: are you on a 64-bit system?
12:54:41 <DevHC> c_wraith: no
12:54:46 <Phyx-> DevHC: why is it working then?
12:55:16 <DevHC> Phyx-: let's just say that it may have something to do with ghci
12:55:39 <DevHC> > show (4 :: Num a => a)
12:55:39 <lambdabot>   "4"
12:55:44 <Phyx-> heh, defaulting shouldn't be happening there should it
12:55:50 <Phyx-> and even so doesn't it default to Integer?
12:56:02 <Phyx-> which shouldn't be possible to define a sizeOf for
12:56:16 <DevHC> it seems that it "defaults" to Double or something
12:56:19 <c_wraith> actually, 8 sounds right for Integer
12:56:24 <c_wraith> @src Integer
12:56:24 <lambdabot> data Integer = S# Int#
12:56:24 <lambdabot>              | J# Int# ByteArray#
12:56:37 <c_wraith> See how there are two single-word fields in the larger constructor?
12:56:40 <DevHC> holy hashmarks!
12:56:49 <Phyx-> c_wraith: hmm
12:57:10 <Phyx-> c_wraith: yeah, you're right about that, on a 32bit system anyway
12:57:29 <fritschy> is there any better way to do this (take 2 elements of a list after the first 5): take 2 $ drop 5 l
12:58:08 <mauke> fritschy: no
12:58:37 <fritschy> mauke: ok :) - just thought maybe I missed some library function...
12:58:39 <DevHC> to me it seems that (Num a) "defaults" to Double or something
12:58:50 <Phyx-> :t sizeOf
12:58:51 <lambdabot> Not in scope: `sizeOf'
12:59:26 <ion> > typeOf (4 :: Num a => a)
12:59:26 <lambdabot>   Integer
12:59:47 <ion> > typeOf (4 :: forall a. Num a => a)
12:59:48 <lambdabot>   Integer
13:00:12 <ion> > typeOf (4.0 :: Num a => a)
13:00:13 <lambdabot>   Could not deduce (GHC.Real.Fractional a)
13:00:13 <lambdabot>    from the context (GHC.Num.Num a...
13:00:33 <parcs> there is no instance Storable Integer
13:00:45 <Phyx-> @src Double
13:00:46 <lambdabot> data Double = D# Double#
13:00:52 <chrisdone> @tell bos where's that benchmarker that you said outperforms ab?
13:00:52 <lambdabot> Consider it noted.
13:01:33 <parcs> we're benchmarking benchmarkers, how meta
13:01:54 <ion> devhc: Say, you have «n :: Num a => a; n = 4». You can do «show n» and the defaulting rule will apply. Inlining the type and the definition of n doesn’t change the semantics.
13:02:20 <luite> httperf maybe?
13:02:37 <DevHC> ion: i have no idea what u've just said.
13:02:40 <parcs> siege probably
13:03:00 <benmachine> Num a defaults to Integer
13:03:22 <benmachine> but ghci has extended defaulting, maybe it's clever
13:03:24 <DevHC> Integer does NOT have a Storable instance :/
13:03:26 <benmachine> and defaults to Int
13:03:49 <Phyx-> benmachine: but then sizeOf shouldn't return 8 on a 32bit system
13:03:56 <benmachine> Phyx-: magic happens
13:04:04 <TheLemonMan> huh, arent file handles declared as maybe ?
13:04:27 <Phyx-> benmachine: lol
13:04:38 * DevHC is making a slim example
13:05:16 <benmachine> > typeOf (undefined :: Num a, Storable a => a)
13:05:17 <lambdabot>   <no location info>: parse error on input `=>'
13:05:25 <benmachine> > typeOf (undefined :: (Num a, Storable a) => a) -- bah.
13:05:26 <lambdabot>   Not in scope: type constructor or class `Storable'
13:05:31 <ion> > let n = 4 :: Num a => a in show n  -- defaults to Integer
13:05:31 <benmachine> double bah.
13:05:31 <lambdabot>   "4"
13:05:39 <ion> > show (4 :: Num a => a)  -- defaults to Integer
13:05:40 <lambdabot>   "4"
13:05:43 <benmachine> DevHC: prints Double in ghci
13:05:47 <benmachine> so yes, it defaults to Double
13:06:09 <JoeyA> Because it's MonadState s m | m -> s, does that mean I am not able to define one monad with two simultaneous states?
13:06:25 <parcs> > Foreign.sizeOf True
13:06:26 <lambdabot>   Not in scope: `Foreign.sizeOf'
13:06:30 <Phyx-> benmachine: isn't Double just the first instance it finds that satisfies the constraint?
13:06:34 <parcs> > Foreign.Storable.sizeOf True
13:06:35 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'
13:06:48 <benmachine> Phyx-: right, probably
13:06:58 <Phyx-> benmachine: e.g. it's pure luck than anything else
13:07:10 <benmachine> JoeyA: right, yes, although you can have a tuple of states :)
13:07:20 <JoeyA> I guess I could roll my own state monad class.
13:07:26 <benmachine> Phyx-: not exactly, it'll be down to the defaulting order
13:07:34 <kmc> TheLemonMan, "declared as maybe"?
13:07:50 <JoeyA> (well, one class per state type needed in the application)
13:09:42 <Phyx-> benmachine: isn't such an order abitrary? in the case of multiple possibilities? much like what happens when UndecidableInstances is enabled?
13:11:10 <benmachine> Phyx-: well, it's standardised somewhere
13:11:14 <kmc> UndecidableInstances makes order arbitrary?
13:11:22 <benmachine> no
13:11:27 <benmachine> that sounds like incoherent
13:12:02 <Phyx-> yeah, I was doubting which it ewas, undecideable ot incoherent
13:12:09 <benmachine> undecidable is the nice one :)
13:13:08 <DevHC> how do i get a list of classes?
13:16:00 <yshavit> Hi all, I'm trying to learn me some haskell,  and I think I've done my self-assigned sample app wrong. There's lots of nested case statements and such yuckiness
13:16:13 <Phyx-> DevHC: hm? list of classes?
13:16:18 <kmc> yshavit, you can put your code on hpaste.org and we'll take a look
13:16:20 <tac-tics> yshavit: @hpaste
13:16:21 <c_wraith> yshavit: put it on hpaste, and ask for some tips
13:16:23 <tac-tics> @hpaste
13:16:23 <lambdabot> Haskell pastebin: http://hpaste.org/
13:16:26 <tac-tics> :)
13:16:54 <yshavit> kmc, tac-tics : Already got it on ideone.com, I was just typing out my specific questions :)  Sorry about that...
13:17:37 <kmc> a pastebin with multiple animated banner ads
13:17:50 <kmc> not as obnoxious as pastebin.com thouh
13:18:02 <hpc> pastebin.com is obnoxious?
13:18:24 <kmc> it has pop-over ads hpc
13:18:24 <yshavit> basically I have a tree whose nodes are constructed as Node (String Bool [Node]). The bool represents "is this interesting", and what I want to do is optimize out the uninteresting branches: those for which the Node is uninteresting *plus* has no children (after optimization)
13:18:33 <yshavit> so, with that introduction, here's the code:
13:18:43 <hpc> kmc: oh, well noscript :P
13:18:57 <hpaste> yshavit pasted “nodes” at http://hpaste.org/51432
13:19:02 <yshavit> http://hpaste.org/51432
13:19:15 <yshavit> oh, whoops, sorry for the spam against hpaste  :)
13:19:28 <kmc> hpaste, yeah, you can work around bad websites, or you can avoid using them
13:19:45 <kmc> yshavit, do you know about 'maybe' and 'fromMaybe'?
13:19:47 <yshavit> kmc: to be honest I didn't even know it had animated banner ads... apologies for that
13:19:51 <kmc> @src maybe
13:19:51 <lambdabot> maybe n _ Nothing  = n
13:19:51 <lambdabot> maybe _ f (Just x) = f x
13:19:53 <kmc> @src fromMaybe
13:19:54 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
13:19:57 <yshavit> kmc: yeah, I'm using Maybe
13:20:02 <tac-tics> yshavit: The only arguable weirdness is opt'
13:20:03 <kmc> yshavit, it's not a big deal... just giving some reasons why i personally prefer hpaste
13:20:10 <kmc> yshavit, maybe, not maybe
13:20:12 <kmc> maybe is a function
13:20:12 <tac-tics> You can use fromJust or you can use Maybe as a monad and replace it with "do" notation
13:20:13 <kmc> :t maybe
13:20:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:20:16 <kmc> don't use fromJust
13:20:34 <yshavit> kmc: oh, I didn't know about maybe the func. :)
13:20:56 <tac-tics> Yeah, maybe seems best in this case
13:20:59 <kmc> yeah, check that out and also fromMaybe
13:21:07 <yshavit> I'll try and re-write this with those, thanks for the tips guys!
13:21:47 <yshavit> tac-tics: I'm trying to stay away from Monads for juuust a bit, because they seem scary once you get past the really trivial "do" stuff. One step at a time.
13:22:11 <dylukes> monads are only hard if you think they are :\
13:22:15 <tac-tics> yshavit: Yeah. They are just helpful for writting cleaner code in some circumstances
13:22:22 <tac-tics> but it's better to understand what you're doing first, IMO
13:22:43 <yshavit> tac-tics: oh, no doubt, I'm not going to give up on monads
13:23:40 <kmc> instead of saying "use monads" say "use this (>>=) operator, which has a simple concrete meaning for Maybe"
13:23:40 <yshavit> dylukes: I'm sure once I get the hang of them, I'll wonder what I'd found so confusing.
13:23:48 <kmc> it also has different meanings for other types, but that's irrelevant
13:23:50 <kmc> @src Maybe (>>=)
13:23:51 <lambdabot> (Just x) >>= k      = k x
13:23:51 <lambdabot> Nothing  >>= _      = Nothing
13:23:52 <dylukes> kmc: ^
13:23:55 <kmc> not much to it
13:24:12 <dylukes> I think maybe is the best introduction in general.
13:24:49 <yshavit> kmc: is there a way to get that from ghci?  Ie, the equivalent of :type but for a classtype?
13:24:55 <dylukes> I think if we didn't say "monads", and just told people to use >>=, they'd get it really quick.
13:25:13 <kmc> yshavit, i don't know what you mean by "classtype" and i don't think what i just got from lambdabot is anything like that
13:25:18 <kmc> but you can private-message lambdabot and use @src etc.
13:25:34 <yshavit> kmc: erm, I may have had the wrong word, sorry. Basically I meant ">>= as applied to a Maybe"
13:25:54 <yshavit> kmc: but you're right, that's not at all what lambdabot gave you, so nevermind me.
13:26:09 <yshavit> dylukes: >>= alone is simple enough, I agree -- it's the Monad.State stuff that scared me off a bit.
13:26:14 <kmc> yshavit, afaik there's no easy way to ask ghci to specialize a polymorphic type
13:26:19 <dylukes> State can wait.
13:26:22 <dylukes> :P
13:26:23 <kmc> yshavit, well... (State s) is a different monad from Maybe
13:26:30 <kmc> all kinds of scary things happen to be monads
13:26:33 <c_wraith> Hmm.  where is the haddock for the ghc api?
13:26:39 <Cale> Also, saying "use monads" collectively in that way makes it sound like they all solve one problem, or kind of problem. It's kinda like saying "Oh, I have this problem, I think I'll use libraries to solve it."
13:27:00 <ddarius> Using libraries would probably be a good idea.
13:27:01 <Cale> Well, sure, there might be a library which solves your problem, but "libraries" is a little general.
13:27:01 <DevHC> Phyx-: the list of imported/defined classes i have in the current ghci session
13:27:03 <kmc> yshavit, it's a little like avoiding (+) on Ints because it also works on infinite-dimensional octonion vector spaces
13:27:05 <yshavit> kmc: right, that I know. I think basically the book I'm reading from explained the Monad type and I said "okay, easy enough, not sure if I understand the implications but I'll read on..."
13:27:15 <kmc> there is no "Monad type"
13:27:19 <dylukes> Monad is not a type.
13:27:30 <dylukes> It's a class of types. Some type just might happen to be a monad...
13:27:32 <yshavit> what's it called again? theh thing that is is?
13:27:37 <dylukes> Type class.
13:27:37 <kmc> type class
13:27:46 <kmc> in other words, Monad is an interface, implemented by many different types, some very simple, some very complex
13:27:47 <c_wraith> yshavit: the big trick with monads is that there isn't a trick.  It's just a really simple api many types implement, that happens to follow a couple rules which add up to "does kind of what you'd expect"
13:27:47 <yshavit> ah, type class.  I was saying class type, sorry.
13:28:00 <dylukes> c_wraith: ^
13:28:06 <dylukes> The bottom line is, theres no way to "understand monads"
13:28:13 <dylukes> each one is unique, and happens to share some common properties.
13:28:18 <ion> Well, they’re like burritos.
13:28:31 <dylukes> I swear
13:28:40 <dylukes> if I hear another goddamn burrito metaphor, I will unwrap you.
13:28:44 <yshavit> dylukes, c_wraith : yeah, and I think that's my problem -- I'm trying to understand The One Thing That All Monads Are, which there isn't one.
13:28:50 <JoeyA> Is there a name for the idea of, when using a monad transformer, swapping out the current inner monad temporarily?  For example: StateT s (Writer w) () -> StateT s m w
13:29:00 <Cale> Every time you are about to make a statement about monads, try replacing the word "monads" with "libraries", and see if it still makes any sense.
13:29:13 <dylukes> Cale: that's a great policy.
13:29:21 <yshavit> btw guys, I really appreciate that nobody's jumping down my throat on these newbie questions. I realize it must be pedantic for you guys.
13:29:21 <c_wraith> JoeyA: Not really.  The way monad transformers are implemented, that doesn't actually make sense
13:29:28 <companion_cube> libraries are like burritos ?
13:29:32 <JoeyA> hmm
13:29:52 <tac-tics> Libraries are like a nuclear waste container. Hey Cale, it works!
13:30:43 <Cale> yshavit: Well, there are obviously a few things which all monads have in common -- all monads consist of a type constructor along with some implementations of return and (>>=) which satisfy some laws.
13:31:14 <ion> Learn about functors and applicative functors first.
13:31:29 <Cale> yshavit: and a bunch of stuff in Control.Monad applies to all monads, but will apply differently to each monad, depending on how return and >>= were implemented
13:31:31 <JoeyA> c_wraith: Doesn't it make sense in the case of a state monad, though?  The signature above could be satisfied by getting the current state, running the inner action, setting the state to the one produced, and returning the result.
13:31:58 <c_wraith> @src StateT
13:31:58 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:32:01 <c_wraith> blah
13:32:04 <yshavit> Cale: right. I think it's more that I read about this >>= function, didn't quite understand its full implications, and then the book started throwing me into Monad.State and kinda went from there, and before I knew it I was lost. I'm sure I'll get it once I put it to practice a bit.
13:32:07 <tac-tics> Monads are for threading state, threading containers, writing parsers, and not much more you need to care about </opinion>
13:32:10 <JoeyA> I'll try to implement that
13:32:19 <TheLemonMan> haskell is so frustrating... im having more issues with catch blocks
13:32:24 <TheLemonMan> catch (openFile "test" WriteMode) (\_ -> putStrLn "error" )
13:32:42 <c_wraith> well.  newType StateT s m a = StateT { runStateT :: s -> m (s, a) }
13:32:56 <Cale> TheLemonMan: Which catch is that?
13:32:57 <no_gravity> Talking about variable names ... An object that has only 3 properties: x,y,z - would you rather call it a point or a vector?
13:33:03 <yshavit> alright, I think I need to focus down on maybe and fromMaybe :)
13:33:14 <tac-tics> no_gravity: I'd call it a 3-tuple in Haskell
13:33:16 <c_wraith> no_gravity: depends on how it's used.  I might call it either.
13:33:17 <dylukes> tac-tics: non deterministic computations :0
13:33:20 <leod> depends on if it's a point or a vector
13:33:22 <dylukes> ListT IO is so much fun :D
13:33:25 <ion> yshavit: What book? Did you try LYAH?
13:33:33 <TheLemonMan> Cale: it should just catch any io error
13:33:34 <yshavit> ion: O'Reilly
13:33:45 <tac-tics> no_gravity: The the difference between a point and a vector is what field you're working in.
13:33:51 <dylukes> LYAH's monad introduction is good.
13:33:53 <yshavit> ion: I just heard about LYAH today, it's going to be my weekend project I think. Sounds like you recommend it?
13:34:00 <dylukes> It takes more of the approach kmc suggests.
13:34:02 <c_wraith> JoeyA: if you look at that above implementation, you see that the choice of m isn't something you can just change.  It's rather fundamental to the type
13:34:02 <no_gravity> tac-tics, c_wraith: Im thinking about the name of the object in my new 3d framework. so its a very fundamental decision.
13:34:06 <Cale> TheLemonMan: catch :: IO a -> (IOError -> IO a) -> IO a -- from System.IO
13:34:07 <dylukes> yshavit: One suggestion however,
13:34:11 <wavewave> hi.
13:34:12 <dylukes> you may want to skip its chapter on applicatives.
13:34:19 <tac-tics> no_gravity: What do you intend to use it for?
13:34:21 <dylukes> It will confuse you if you try to conflate it with the functor/monad stuff too much.
13:34:24 <yshavit> dylukes: alright, thanks.
13:34:25 <Cale> TheLemonMan: So, the exception handler has to return a Handle to use if you're going to use it like that
13:34:33 <dylukes> yshavit: Don't get me wrong its really interesting.
13:34:36 <dylukes> Just, read it after monads.
13:34:37 <wavewave> For logging, is hslogger the best package? are there any alternative?
13:34:44 <yshavit> dylukes: oh, no I figured that's what you meant. :)
13:34:46 <Cale> TheLemonMan: otherwise, you need to put the stuff that you're going to do with the Handle inside the catch
13:34:59 <c_wraith> no_gravity: But are you representing points, or vectors?  A vector is a difference between points.  They are fundamentally different things.
13:35:02 <shachaf> dylukes: Huh? That's silly.
13:35:06 <no_gravity> tac-tics: for example the camera has an instance of this object as a property to hold its position.
13:35:11 <shachaf> The order that the book presents things seems fine to me.
13:35:14 <ion> yshavit: You may want to read the Typeclassopedia at some point as well to gain further understanding.
13:35:18 <no_gravity> c_wraith: whats the difference?
13:35:18 <dylukes> shachaf: Like three people I know complained they had trouble getting applicatives.
13:35:20 <ddarius> no_gravity: A position is a point.
13:35:24 <dylukes> Like, they felt like they didn't see the point.
13:35:26 <tac-tics> no_gravity: There are some systems where points and vectors are totally distinct. In those cases, vectors are the DIFFERENCES between two points, and you can't add points together
13:35:29 <Cale> TheLemonMan: this is because  openFile "test" WriteMode :: IO Handle
13:35:32 <dylukes> I just figure going from functor->monad will be easier.
13:35:34 <dylukes> for the moment.
13:35:34 <c_wraith> no_gravity: you probably want both types and vectors, and operations to keep the two distinct from each other
13:35:37 <Cale> TheLemonMan: and that forces a = Handle
13:35:42 <Cale> in the type of catch
13:35:42 <ddarius> no_gravity: The location of Washington DC and New York city are points.  What point is their sum?
13:35:43 <c_wraith> err, both *points* and vectors
13:35:45 <shachaf> dylukes: Right, applicatives are point-free.\
13:35:47 <TheLemonMan> tbh i dont get how to handle the errors, in C i would just return a negative value, in haskell i don't know what to do
13:35:48 <tac-tics> no_gravity: But in other systems, they are the same type, and you have to keep them straight what they mean
13:36:02 <Cale> TheLemonMan: Maybe, perhaps?
13:36:03 <no_gravity> ok. i think i call it a point.
13:36:10 <dylukes> shachaf: rockin' that n-conversion
13:36:18 <kmc> class WorkflowParadigm m where { synergizeWorkflows :: m a -> (a -> m b) -> m b; leverageCoreCompetency :: a -> m a }
13:36:29 <Cale> TheLemonMan: The returning a negative value thing is an awful hack to deal with the fact that C has no Maybe type
13:36:34 <dylukes> kmc: Are you writing F#?
13:36:36 * ddarius -always- has separate point and vector types.
13:36:37 <kmc> guys i solved the problem of Haskell in The Enterprise
13:36:39 <tac-tics> no_gravity: Personally, I'd call it a vector, since a "direction with a length" doesn't sound like a "point" to me
13:36:45 <shachaf> dylukes: Is that supposed to be an eta?
13:36:50 <dylukes> shachaf: yeah sorry >_>
13:36:55 <Cale> η
13:37:01 <kmc> BUT HOW WILL YOU PRONOUNCE IT FOLLOWED BY A MU
13:37:08 <dylukes> η-conversion, happy?
13:37:19 <shachaf> 03b7
13:37:25 <dylukes> kmc: "im"?
13:37:28 <shachaf> I would've been fine with "eta-conversion".
13:37:32 <TheLemonMan> err, do you have an example ? i really don't get this
13:37:34 <Cale> kmc: rofl
13:37:49 <kmc> I type η with Compose g j
13:38:03 <Cale> kmc: Isn't that what they decided to call monads over at microsoft?
13:38:10 <kmc> hehe
13:38:16 <geheimdienst> composegj?
13:38:20 <ion> factoryAdapterSingletonDelegate :: m (m a) → m a
13:38:20 <kmc> MSR isn't microsoft now?
13:38:58 <kmc> ion, that's more of a GenericUnwrappingVisitorFunctorFactory
13:39:12 <tac-tics> If it were me, I'd have called monads "plumbing"
13:39:19 <yshavit> @src  fromMaybe
13:39:20 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
13:39:22 <ion> Functor is a scary word, and not enterprise anough.
13:39:25 <ion> enough
13:39:38 <kmc> ion, no "functor" is what you call a function in C++ or Java which is trying to be first-class
13:39:50 <no_gravity> tac-tics: well, the position of the camera is a point, isnt it?
13:39:58 <kmc> it's a first-class function wrapped in enough protective boilerplate that it can survive in this scary world
13:40:04 <ion> ok
13:40:18 <tac-tics> no_gravity: it is, but linguistically, I think calling a "point" a "vector" is fine, but calling a "vector" a "point" is weird outside of a math class.
13:40:31 <kmc> i bet octonions don't even form a vector space
13:40:43 <no_gravity> tac-tics: ah. interesting thought.
13:40:47 <tac-tics> no_gravity: but really, names are names. Choose what makes sense to you, and make sure everyone else agrees.
13:40:51 <shachaf> kmc: Is a function pointer a functor?
13:41:10 <tac-tics> shachaf: in C maybe.
13:41:17 <shachaf> In C++, I mean.
13:41:21 <kmc> shachaf, no, but it adheres to the Callable Concept
13:41:46 <kmc> that's actually why it matters to overload operator() instead of a member function with an ordinary name
13:42:06 <copumpkin> kmc: they aren't even associative
13:42:06 <kmc> because then you can write a template which accepts either your object or a bare function pointer
13:42:12 <kmc> because C++ templates are duck-typed
13:42:33 <ddarius> copumpkin: They just need one associative operator.
13:44:02 <yshavit> am I totally wrong, or could fromMaybe have been easy defined in terms of maybe?  myFromMaybe a = maybe a id   ?
13:44:09 <kmc> that is correct
13:44:30 <yshavit> okay, thanks. Not saying the given impl of fromMaybe is wrong of course, just wanted to sanity check myself
13:44:31 <ddarius> yshavit: Every function on Maybe could easily be defined in terms of maybe.
13:44:40 <kmc> @check \x -> maybe a id x == fromMaybe x
13:44:40 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:44:47 <kmc> @check \v x -> maybe v id x == fromMaybe x
13:44:47 <lambdabot>   Occurs check: cannot construct the infinite type:
13:44:47 <lambdabot>    a = Data.Maybe.Maybe (...
13:44:57 <yshavit> ddarius: ah, that would make sense.
13:44:58 <kmc> @check \v x -> maybe (v :: Char) id x == fromMaybe v x
13:44:59 <lambdabot>   "OK, passed 500 tests."
13:45:06 <kamaji> Can I put a thing in the IO monad?
13:45:11 <kmc> what
13:45:15 <tac-tics> kamaji: return
13:45:25 <kamaji> oh yeah :D
13:45:26 <kamaji> thanks
13:45:27 <tac-tics> @type return :: a -> IO a
13:45:28 <lambdabot> forall a. a -> IO a
13:45:40 <kmc> return takes a value and returns an IO action which, if executed, would produce that value and have no other effects
13:45:49 <kamaji> getGen = maybe getStdGen (return.mkStdGen)
13:45:49 <kamaji> yay
13:46:04 * copumpkin always does unsafePerformIO . return
13:46:09 <kmc> haha
13:46:12 <copumpkin> and return . unsafePerformIO
13:46:30 <shachaf> copumpkin: You need to return . unsafePerformIO when you're <-ing
13:46:37 <c_wraith> the latter is very close to unsafeInterleaveIO
13:46:40 <shachaf> Because let is too many extra characters.
13:46:43 <yshavit> ddarius: actually, that little quip is very helpful. I think as I work through my example, I'm going to think only in terms of maybe at first, and then simplify to fromMaybe or whatever else as needed.
13:46:44 <copumpkin> shachaf: exactly
13:47:17 <Clint> is there no sgml library on hackage?
13:47:21 <kmc> 'maybe' is the catamorphism for Maybe, right?
13:47:31 <shachaf> Yes.
13:47:33 <ddarius> @google site:hackage.haskell.org sgml
13:47:44 <shachaf> @src maybe
13:47:46 <lambdabot> http://hackage.haskell.org/trac/ghc/browser/docs/ffi-art.sgml?rev=944c6afd73b32287f9981539127ba7060bd57e54
13:47:46 <lambdabot> Title: /docs/ffi-art.sgml – GHC
13:47:46 <lambdabot> maybe n _ Nothing  = n
13:47:46 <lambdabot> maybe _ f (Just x) = f x
13:48:02 <copumpkin> does it actually work out to be a catamorphism for some constant functor that doesn't recurse?
13:48:04 <copumpkin> I guess so
13:48:11 <ddarius> Of course it does.
13:48:39 <ddarius> In fact, Maybe is the free monad of Const ().
13:48:48 <copumpkin> fancy
13:48:58 <yshavit> hm, question about composition now. :type show.Just is (Show a) => a -> String, which makes sense to me. As I understand it, that would mean "take your input a, wrap it in a Just, and then call show on the Maybe"
13:49:02 <hpaste> “Joey Adams” pasted “Swap out the inner monad when using StateT” at http://hpaste.org/51433
13:49:03 <yshavit> but show show.Just 1 fails
13:49:22 <yshavit> as does show (show.Just 1)
13:49:37 <kmc> yshavit, because function composition is different from function application
13:49:39 <ion> > (show . Just) 1
13:49:40 <lambdabot>   "Just 1"
13:49:42 <kmc> show . Just 1  ≡  \x -> show (Just 1 x)
13:49:45 <kmc> which is a type error
13:49:58 <kmc> > show $ Just 1
13:49:59 <lambdabot>   "Just 1"
13:50:01 <kmc> @src (.)
13:50:01 <lambdabot> (f . g) x = f (g x)
13:50:02 <lambdabot> NB: In lambdabot,  (.) = fmap
13:50:02 <kmc> @src ($)
13:50:02 <lambdabot> f $ x = f x
13:50:03 <monochrom> fully parenthesize to be sure
13:50:05 <JoeyA> c_wraith: I think the function I defined there does what I want.  It suspends the current inner monad, to run a different inner monad.  The effect on the state is seen in the result.
13:50:07 <yshavit> ion, kmc: ah, makes sense, thanks.
13:50:21 <ddarius> monochrom: 'only works if you know how to parenthesize.
13:50:33 <yshavit> show (Just 1) works as expected, got it
13:53:34 <monochrom> I know some logic courses mandate full parenthesization, at least early on. "if f, g are formulas, then (f∧g), (f∨g) are formulas"
13:55:05 <kmc> the next step in whitespace sensitivity is to parse "x + y+z" as x+(y+z) and "x+y + z" as (x+y)+z
13:55:30 <tac-tics> monochrom: I learned logic from Hofstadter, and his book used full parens
13:55:34 <tac-tics> and I turned out all right :)
13:55:52 <dylukes> kmc: Are you serious or not?
13:55:54 <monochrom> yes, I actually prefer full parenthesization for beginners
13:56:05 <copumpkin> q   +  x + y+z
13:56:06 <dylukes> I'm not certain thats a good idea, but it could be interesting haha.
13:56:14 <dylukes> for single expressions...
13:56:22 <dylukes> copumpkin's example shows exactly why not...
13:56:28 <tac-tics> monochrom: I think most people don't quite get it. They teach pemdas in school, but I don't think many people fully grasp what's really going on.
13:56:38 <benmachine> copumpkin: "expand this sum"?
13:57:00 <acowley> I like that, it's the syntactic equivalent of "wait for it...."
13:57:01 <tac-tics> Pemdas is there to eliminate as many parentheses are is sensible
13:57:04 <dylukes> tac-tics: Don't get what? fixity/associativity?
13:57:05 <tac-tics> But by default, the parens are there
13:57:17 <benmachine> I got taught bidmas
13:57:32 <tac-tics> dylukes: They don't understand where the rules for PEMDAS come from
13:57:38 <tac-tics> They are totally arbitrary, afterall
13:57:44 <ddarius> We should use even more parentheses.  Every student should use von Neumann's onion.
13:57:56 <dylukes> tac-tics: I just supposed they were arbitrary but picked for convenience. :\
13:57:58 <benmachine> we could do everything in RPN
13:57:59 <monochrom> part of the problem of pemdas is that it is advertised as order of evaluation when it is not. it is order of parsing. however, I agree that telling kids about both "parsing" and "evaluating" is too complicated. I don't know how to do it better.
13:58:08 <benmachine> except that's hard as heck to actually parse and use
13:58:08 <monochrom> @quote monochrom lazy
13:58:09 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
13:58:09 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
13:58:10 <dolio> ((x + ((y + z))))
13:58:15 <acowley> come to think of it, foldr is the catamorphism form of "wait for it..."
13:58:16 <dylukes> I learned PBMMPPULCDADMABRRRBBBLLTAAMMBBC
13:58:22 <dylukes> It's the operator precedence of C.
13:58:34 <dylukes> acowley: `seq` is I CANT WAIT FOR IT!
13:59:01 <kmc> dylukes, i think it's a bad idea
13:59:09 <acowley> dylukes: yes, seq is ruining the delivery by spoiling the punchline
13:59:09 <kmc> i don't think it's so bad that nobody should implement it and try to use it
13:59:09 <dylukes> kmc: kk good, seemed weird from you
13:59:11 <tac-tics> dylukes: If we're gonna make jokes about it, I learned "p". I come from a LISP background :)
13:59:24 <dylukes> tac-tics: lul
13:59:26 <kmc> istr a serious (but not very popular) language which had this
13:59:30 <dolio> dylukes: kmc isn't the first one to suggest it.
13:59:38 <ddarius> Fortress?
13:59:52 <kmc> fortress does? o-O
13:59:59 <dolio> f x*y * z+w
14:00:02 <dylukes> hey by the way
14:00:09 <Cheery> well this wasn't so hard as I thought. It only required very few changes into my original model I tried. http://paste.pocoo.org/show/477201
14:00:10 <dylukes> I still need a name for my dependently typed language I'm working on.
14:00:23 <erus`> how long til the IFPC
14:00:37 <kmc> dylukes, i suggest some kind of pun on "coq"
14:00:44 <tac-tics> dylukes: Depper, Deppy, Typetran, Typo, Typsy
14:00:47 <parcs> erus`: sep 30th i think
14:01:00 <erus`> bummer
14:01:06 <erus`> i wanna watch new haskell vids
14:01:08 <monochrom> @remember dylukes I learned PBMMPPULCDADMABRRRBBBLLTAAMMBBC. It's the operator precedence of C.
14:01:08 <lambdabot> I will never forget.
14:01:11 <monochrom> hehehehe!
14:01:15 <tac-tics> dylukes: Normstrong
14:01:15 <dylukes> lol
14:01:26 <dylukes> tac-tics: What does that even mean.
14:01:36 <dylukes> I will turn too...
14:01:37 <dylukes> http://www.dotomator.com/web20.html
14:01:39 <tac-tics> normstrong... dep. typed languages are usually strongly normalizing
14:02:03 <Cheery> the world will soon see a programmer editor that's designed for directed acyclic graphs.
14:02:11 <dylukes> define strongly normalising?
14:02:11 <tac-tics> Actually, you can't use that one. I want to call *my* dep. typed language NormStrong :)
14:02:14 <kmc> Cheery, soon? people have been working on that for decades
14:02:27 <kmc> do you mean a structural editor?
14:02:31 <Cheery> kmc: yay
14:02:40 <Cheery> or something like that.
14:02:47 <acowley> You always know where you'll stand with Norm Strong
14:02:48 <Cheery> kmc: well I'll show it once I'm further with it. :)
14:02:59 <tac-tics> dylukes: http://en.wikipedia.org/wiki/Normalization_property_(abstract_rewriting)
14:03:10 <JoeyA> Jumpbridge
14:03:12 <tac-tics> every sequence of rewrites eventually terminates to a term in normal form
14:03:21 <Cheery> kmc: have they been really working on it for decades?
14:03:25 <kmc> i think so
14:03:27 <Cheery> kmc: why they aren't anywhere then?
14:03:42 <kmc> a) because it's hard
14:03:44 <Cheery> I mean.. I've just been working on this for months.
14:03:47 <kmc> b) why aren't Haskell or Lisp anywhere?
14:03:52 <dylukes> tac-tics: idk if I'll hold that.
14:03:55 <tac-tics> basically that all functions terminate (and terminate regardless of evaluation style)
14:03:59 <dylukes> I'd like to have an notion of IO present.
14:04:05 <dylukes> I'm aiming for dependent typing in a practical context.
14:04:14 <kmc> Cheery, the problem isn't to make some structural editor.  the problem is to make it good, and then to convince other people to use it
14:04:15 <tac-tics> dylukes: Oh..... Good luck with that.....
14:04:17 <tac-tics> Lol <3
14:04:21 <dylukes> ;)
14:04:31 <copumpkin> everyone wants DTs in a practical context
14:04:33 <kmc> Cheery, you can go find many research papers on this topic
14:04:39 <Cheery> kmc: oh that thing. Well the good model gets a far.
14:04:40 <Cheery> :)
14:04:45 * monochrom has been using a structural editor for a decade. http://www.cs.nott.ac.uk/~rcb/mathspad/
14:04:47 <tac-tics> copumpkin speaks the truth :)
14:04:49 <dylukes> copumpkin: and? I think you'd have to make some concessions,
14:04:54 <dylukes> but I don't think it's impossible.
14:05:07 <copumpkin> with great power comes great responsibility
14:05:19 <kmc> it's really, really, really hard to get people to use something new
14:05:21 <kmc> even if it's better
14:05:26 <tac-tics> copumpkin: Great responsibility and scary ass type declarations
14:05:31 <dylukes> kmc: Sure, thats not the problem I'm trying to solve.
14:05:36 <kmc> i'm talking to Cheery
14:05:39 <dylukes> oh
14:05:40 <copumpkin> you use fancier types, you must expect to put more work into constructing terms of those types
14:05:43 <dylukes> I'm not really trying to solve any problem..
14:05:43 <insomnia_> Hi all! I have a puzzle: Why does this work func = zipWith(++) [[],[1],[1,2]] [[1,2],[2],[]]  and not this func x = zipWith(++) inits(x) tails(x) ?
14:05:49 <dylukes> copumpkin: Of course.
14:05:55 <copumpkin> that more work is often a lot more work
14:05:57 <kmc> and with something like a structural editor, there are like a billion tiny conceptual and UI decisions
14:05:57 <dylukes> But I don't think, that just because you CAN make fancier types,
14:05:59 <dylukes> that you HAVE too.
14:06:00 <copumpkin> I definitely think it's possible
14:06:01 <kmc> each of which will piss off someone
14:06:02 <Cheery> kmc: well.. I didn't thought about forcing anyone else to use it. I want to do a kernel by using this thing.
14:06:06 <monochrom> in fact, I no longer write raw latex myself, I use mathspad exclusively for latex output and/or a lot of formulas
14:06:09 <parcs> insomnia_: my eyes
14:06:10 <copumpkin> dylukes: sure, you can write haskell in agda and not really have much trouble
14:06:19 <copumpkin> except with termination :)
14:06:21 <kmc> Cheery, ok, you asked "why aren't they anywhere" which i thought was about popularity
14:06:24 <copumpkin> in fact, look up cayenne
14:06:30 <copumpkin> preflex: seen augustss
14:06:30 <preflex>  augustss was last seen on #haskell 13 days, 12 hours and 39 seconds ago, saying: yo
14:06:36 <Cheery> kmc: it's good you say those things. :)
14:06:37 <benmachine> well a structural editor fundamentally has to be clever, which means not simple, which means hard to use, unless you're very good
14:06:46 <Cheery> kmc: I'm really curious why this hasn't catched fire yet.
14:07:02 <copumpkin> @ask augustss is cayenne available for download anywhere?
14:07:03 <lambdabot> Consider it noted.
14:07:14 <kmc> they're also deeply tied to a language
14:07:19 <ddarius> copumpkin: Just dust off your copy of LML.
14:07:28 <parcs> insomnia_: zipWith(++) inits(x) tails(x) is the same as zipWith (++) inits x tails x
14:07:39 <Cheery> kmc: oh that.. I've got solution on that further I go. it's partially given in by my friend who worked on customization.
14:07:42 <parcs> you need to put parens around `inits x` and `tails x`
14:07:43 <dylukes> Well copumpkin, what I'd like to do,
14:08:01 <benmachine> oh, and < tac-tics> copumpkin: Great responsibility and scary ass-type declarations
14:08:22 <dylukes> is basically try to make dependent typing an existing feature, without necessarily forcing it
14:08:25 <Cheery> kmc: I believe.. once I've written teh kernel, I can modify this to be WYSIWYG for typing in kernel manuals.
14:08:30 <copumpkin> dylukes: hm?
14:08:33 <dylukes> i.e, if theres an existing length observed list type
14:08:36 <dylukes> its not very hard to use
14:08:46 <dylukes> for the average newbie, thats not hard to grasp or make use of.
14:08:54 <dylukes> But it is undeniably useful :\
14:09:01 <copumpkin> well, we can do that in haskell
14:09:27 <dylukes> I don't think dependent types necessarily introduce complexity unless the programmer invites it :)
14:09:27 <copumpkin> length-indexed lists don't really require DTs
14:09:27 <Cheery> kmc: I remember we've been chatting about this before have we?
14:09:29 <kmc> maybe?
14:09:31 <dylukes> copumpkin: No but they're cleaner.
14:09:31 <copumpkin> DTs are more about dependent functions and sums
14:09:38 <copumpkin> or functions and products, I should say
14:09:45 <dylukes> I have to go eat dinner.
14:09:45 <dylukes> brb.
14:09:54 <ddarius> Also, if you require termination, that does introduce complexity.
14:09:58 <benmachine> copumpkin: what if you want to make a list whose length is only known at runtime, don't you need DTs for that?
14:10:13 <copumpkin> no
14:10:13 <ddarius> [a] is a list whose length is only known at run-time.
14:10:35 <Cheery> kmc: I'm a bit in middle like 'this is going to change things' and 'this is going nowhere' attitude.
14:10:36 <copumpkin> benmachine: the way you'd treat those in a DT language is the same as how you'd do it in haskell, more or less
14:10:54 <benmachine> copumpkin: hm, ok.
14:10:54 <Cheery> kmc: the failures I've done with writing an editor have accumulated to be numerous
14:11:16 <copumpkin> benmachine: namely, some sort of existential-like thing
14:11:19 <benmachine> I suppose I was just thinking of writing, say, replicate, on length-indexed lists
14:11:23 <copumpkin> benmachine: within the existential, you "know" the length
14:11:34 <copumpkin> you can even sort of write replicate
14:11:40 <Eduard_Munteanu> Or you can use plain Haskell-ish lists.
14:11:45 <Cheery> kmc: still after that long journey, 35 lines of documentation describes what I've got right now.
14:11:47 <Eduard_Munteanu> You know their length at runtime.
14:12:06 <benmachine> Eduard_Munteanu: hmmmmm
14:12:16 <Cheery> kmc: it's like.. wtf?! any reasonable research lab would have already archived this project I'm doing :D
14:13:24 <Eduard_Munteanu> If you want to know it at compile-time, then you use something like Agda's Vec (lists indexed by length)
14:13:54 <Cheery> kmc: once I've got something tackled together I can use a little bit already, I'll write a program in it, which I'll compile and test against C source code programs.
14:13:55 <djahandarie> Man, getting the weirdest STM bug that I can't seem to track down in my app code
14:13:56 <benmachine> Eduard_Munteanu: right, but that's DT :P
14:14:08 <c_wraith> seriously, anyone know how to get haddock for the ghci api?  Is there an easier way than getting the ghc code?
14:14:08 <Eduard_Munteanu> Yeah, or at least fake dependent types.
14:14:19 <Cheery> kmc: actually I started this time from that compiler thing.. and moved to this once I wanted to do benchmarks. :P
14:15:01 <Eduard_Munteanu> But you don't have to use one over the other, DT languages don't force you.
14:15:11 <c_wraith> oh, google knows.  I feel dumb for asking now
14:15:23 <tac-tics> Just as a pure language has to be careful to scrape all the state out of programming, dependent types have to be careful to scrape all the non-termination
14:15:41 <Eduard_Munteanu> DT is actually orthogonal to totality.
14:15:55 <Eduard_Munteanu> I think Idris is a DT language, but it's not total.
14:16:02 <monochrom> GHC's library haddock main page has a link to GHC API's haddock main page
14:16:03 <copumpkin> so was cayenne
14:16:04 <Eduard_Munteanu> Or Agda if you disable the termination checker.
14:16:05 <tac-tics> Eduard_Munteanu: not if you want a deterministic type checker
14:16:18 <tac-tics> which maybe you don't
14:16:32 <dolio> It will be deterministic.
14:16:37 <dolio> It just may never complete.
14:16:44 <tac-tics> it would give a whole new meaning to the phrase "I am working, code's compiling"
14:17:03 <c_wraith> wow, GHC has its own internal secret MonadIO inside of the ghc api
14:17:16 <monochrom> [obligatory xkcd reference] :)
14:17:38 <parcs> and MonadException
14:17:42 <tac-tics> That reminds me.... I think I found a race condition in GHCi last night :/
14:17:43 <c_wraith> yep
14:17:56 <monochrom> yes, it's GHC's own MonadIO, which doesn't unify with whatever MonadIO you install
14:18:12 <Eduard_Munteanu> I wonder if you can have the termination checker abort compiling if it'd result in an infinite loop, and in no other case.
14:18:15 <kmc> compile-time type checker that might not terminate is not a problem.  the problem (as I understand it) is that you want to use types as evidence for runtime coercions, and if you don't prove termination, you have to preserve those proof terms until runtime and evaluate them
14:18:35 <tac-tics> Eduard_Munteanu: How do you know if the loop it's stuck in is infinite?
14:19:02 <Eduard_Munteanu> I assume the same way Coq or Agda detect non-totality.
14:19:05 <kmc> by solving diophantine equations
14:19:08 <kmc> ;P
14:19:11 <tac-tics> kmc: ;)
14:19:23 <copumpkin> Eduard_Munteanu: by only allowing structural recursion?
14:19:36 <tac-tics> kmc: Personally, I like asking the barber who shaves him.
14:19:40 <djahandarie> Aha, lazyness strikes again.. damn...
14:19:51 <monochrom> no, none of those provers detect non-termination. they just go conservative and say "your purported termination proof doesn't make sense".
14:19:51 <Eduard_Munteanu> Anything so you end up with a non-total language, but which typechecks in finite time.
14:20:05 <Eduard_Munteanu> Yeah, that's fair ^^
14:20:54 <tac-tics> I had an idea the other day. That if you had an imperative language with only local reads and writes such that you could mask them, it'd probably be easier to write a lot of programs that way vs. structural recursion
14:21:11 <tac-tics> Since most "real world" programming is abusing for loops.
14:21:59 <TheLemonMan> how would i use a maybe for openfile return if the return is IO Handle ?
14:22:03 * hackagebot splaytree 0.1 - Provides an annotated splay tree  http://hackage.haskell.org/package/splaytree-0.1 (JohnLato)
14:22:05 <tac-tics> As long as your lists and iterators are finite, it's more intuitive (IMO) to write programs with for loops than structural recursion*
14:22:29 <monochrom> openFile throws an exception. do you mind catching and handling exceptions?
14:22:46 <glguy> :t try
14:22:47 <lambdabot> Not in scope: `try'
14:23:02 <glguy> Prelude Control.Exception> :t try
14:23:02 <glguy> try :: Exception e => IO a -> IO (Either e a)
14:23:27 <djahandarie> Man, this feels really nasty, laziness shouldn't be doing this
14:23:49 <TheLemonMan> if i use exceptions i should write all the io code into the catch block
14:24:37 <monochrom> you can also use the "try" wrapper to convert exceptions as Either's.
14:24:41 <djahandarie> And when I add a seq it tells me that I'm nesting atomically blocks. Nice.
14:24:46 <monochrom> s/ as / to /
14:25:10 <glguy> djahandarie: Did you unsafe interleave your IO?
14:25:21 <djahandarie> Nope, no unsafe going on anywhere
14:26:36 <kmc> tac-tics, what's the big difference between «for (x in xs) { ... }» and «for xs (\x -> ...)» ?
14:26:50 <kmc> also what do you mean by "an imperative language with only local reads and writes such that you could mask them"?
14:27:14 <Eduard_Munteanu> How's Idris these days, btw?
14:27:15 <monochrom> I bet the latter is like ST.
14:27:25 <tac-tics> kmc: I mean, in an imperative language, it's really easy to reason about when something is a valid terminating program in most practical cases.
14:27:35 <TheLemonMan> so handler <- try $ openFile "file" ReadMode should return the error code in Left and the handle in Right
14:27:51 <Eduard_Munteanu> I wonder if it's nicer to use for programming.
14:27:55 <monochrom> and I bet the former is not the difference mentioned. more like «for xs (\x -> ...)» vs «let loop = ... loop ... in loop»
14:27:56 <Eduard_Munteanu> erm, nicer than Agda
14:27:57 <tac-tics> Only allow for loops which iterate over finite lists*
14:28:21 <kmc> tac-tics, that's because most imperative languages don't allow infinite lists
14:28:23 <dylukes> tac-tics: Only allow for non infinite lists.
14:28:31 <kmc> not because they're imperative
14:28:38 <tac-tics> kmc: you *would* have to watch out for iterators though
14:29:04 <tac-tics> but in my day job, almost all the code is just enter a function, loop a few times, write some values, and return a value.
14:29:36 <kmc> you can implement such loops as higher-order functions and prove termination generically
14:29:40 <hpaste> yshavit pasted “nodes2” at http://hpaste.org/51435
14:29:40 <tac-tics> I dunno. My impression of Dep Types is that structural recursion can be a pain in the ass.
14:29:44 <kmc> there's no need for them to be magical special built-in syntax
14:30:03 <tac-tics> recursion in general, actually :)
14:30:18 <yshavit> if people have a sec, can you see if I'm on the right track with that hpaste? I tried to use maybe to fix my previous nodes example
14:30:48 <kmc> looks pretty good yshavit
14:31:08 <djahandarie> Yeah, just had to add the write sprinkle of strictness to fix this issue, but man that was weird to track down
14:31:13 <djahandarie> right*
14:31:17 <kmc> yshavit, what's the goal here? drop nodes which have False []?
14:31:32 <yshavit> kmc: exactly
14:31:38 <Eduard_Munteanu> djahandarie: was it a STM bug after all?
14:31:53 <djahandarie> Eduard_Munteanu, I'm not sure.
14:32:05 <acowley> anyone here done much with multisets and/or permutations in Coq or Agda?
14:32:22 <kmc> yshavit, you know how lists have this "filter" function that takes a function which says what to drop?
14:32:23 <yshavit> kmc: and when you put it that way... I wonder if a map + filter would be better?
14:32:27 <kmc> exactly
14:32:33 <djahandarie> I was using Lazy IO and threads/STM, the problem was somewhere in the combination of those things
14:32:36 <kmc> i'm not sure either, but i think it would be worth trying
14:32:53 <wavewave> hi.. is there some haskell library for getting information like 'lsof'?
14:32:55 <kmc> djahandarie, oh man, that sounds like a great way to do some IO inside a transaction
14:32:57 <yshavit> kmc: I'll definitely give that a shot. I have to head home now, but it'll be my homework
14:33:04 <kmc> cool yshavit :)
14:33:06 <djahandarie> kmc, yep.
14:33:19 <wavewave> finding which program is using a file.
14:33:25 <djahandarie> That is what was happening and it was pretty weird
14:33:38 <wavewave> I want to have some haskell library for that.
14:33:44 <djahandarie> Whatever, problem solved, I'll just sweep it under the rug :P
14:34:17 <monochrom> system "lsof"
14:34:21 <yshavit> good night, everyone. Thanks again for your help, guys!
14:34:28 <Eduard_Munteanu> acowley: dunno, try to ask here, or in #agda
14:35:11 <wavewave> monochrom: I know :-) , but parsing it is quite cumbersome... I just wanna know if there is some work already done. ;-P
14:35:22 <kmc> so maybe this is a dumb question, but:  is there any work towards integrating GHC's STM with external transactional systems like databases?
14:35:27 <monochrom> oh, parsing is a pig, yes
14:36:24 <monochrom> (was hoping that you just let the user parse)
14:36:42 <acowley> Eduard_Munteanu: I'd like to have a function that moves a sublist of a list to the front of a list, and prove that the result is a permutation of the original list. I do this now with Coq tactics to prove that a given application of my function is a perm., but this ends up causing me some performance headaches
14:36:50 <wavewave> monochrom: probably, not that difficult. but I think parsing is not a platform-indep option in this case.
14:37:23 <Eduard_Munteanu> kmc: hm, that sounds interesting.
14:37:24 <wavewave> I guessed some System.Posix.XXX has  such a thing...
14:37:26 <acowley> Eduard_Munteanu: I'd like to have a lemma that says that any application of this function (along with suitable membership hypotheses) results in a permutation
14:37:33 <Eduard_Munteanu> (I haven't heard, but ...)
14:37:50 <kmc> wavewave, I don't think POSIX provides a way to access that information
14:37:54 <kmc> i'm not sure, though
14:39:30 <DukeDave> Is anyone here familiar with cabal-dev?
14:40:28 <Eduard_Munteanu> acowley: why doesn't your function output the result and a proof that it's a permutation of the input?
14:42:19 <acowley> Eduard_Munteanu: this is a good question that I've asked myself several times. The trouble is that it's easy to write the obvious function, but seems to require quite a bit of deconstruction to get something that can be more carefully typed
14:42:31 <tac-tics> I have to say, an undervalued selling point of Haskell and type theory... all the professors are tech savy and know how to publish their thesises online for free
14:42:55 <Eduard_Munteanu> tac-tics: aye
14:43:27 <DukeDave> I'm doing "cabal-dev install --reinstall mypackage", but it doesn't seem to be updating the sandbox local package (although it is rebuilding)
14:43:53 <acowley> Eduard_Munteanu: I think the main trouble I'm having is that I haven't put my finger on what the right intermediate steps are
15:07:50 <Rc43> Hi guyz.
15:08:21 <Rc43> Tell me please, how can i convert [[]] to matrix? Which libs i should to use?
15:08:53 <JoeyA> What type of matrix?
15:09:00 <JoeyA> (what library, in particular?)
15:09:43 <JoeyA> You could convert it to an Array, which supports multidimensional indexing: http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array.html#t:Array
15:09:55 <Rc43> JoeyA, didn't understand you =/ I need a matrix of numbers like [[1,2],[3,4]]
15:10:12 <JoeyA> That's a list of lists.
15:10:23 <JoeyA> And [[]] is also a list of lists.
15:10:35 <mauke> yay!
15:11:10 <Rc43> JoeyA, I mean a matrix with rows like in this list
15:11:28 <mauke> Rc43: I don't understand what you want
15:11:35 <mauke> do you have sample input/output?
15:12:16 <Rc43> btw, the array will be nice for me, I need only operation of getting element by index
15:13:04 <mauke> [...] !! i
15:13:29 <Nimatek> > [[1,2],[3,4]] !! 1 !! 0
15:13:30 <lambdabot>   3
15:15:03 <weak_head_normal> Hi, is this a good place to ask about cabal?
15:15:24 <kmc> weak_head_normal, it's a fine place... there's also #hackage but it's usually dead
15:15:30 <JoeyA> I want to define a type class whose instances define types specific to that class (type families).  For example: class Foo m where {data Item :: *; data Key :: *; key :: Item -> Key}
15:15:46 <JoeyA> The problem is, key's signature results in an error because it doesn't mention m
15:16:02 <Rc43> mauke, it is slow
15:16:16 <kmc> JoeyA, i think you want «class Foo m where { data Item m :: *; data Key m :: *; key :: Item m -> Key m }»
15:16:26 <kmc> Rc43, then use Array, or Map (Int,Int) Value
15:16:40 <Rc43> yep
15:17:01 <Eduard_Munteanu> Or hmatrix if you want to do linear algebra stuff with it.
15:17:08 <Eduard_Munteanu> @hackage hmatrix
15:17:08 <lambdabot> http://hackage.haskell.org/package/hmatrix
15:17:41 <weak_head_normal> so, my problem is: when I type "cabal install sdl" it hangs up at linking, works for several minutes and tells me, that collect2 was killed with signal 9. What could that mean?
15:17:43 <JoeyA> kmc: Ah, makes sense.  So even though m isn't actually used inside the data declaration, it's just there so the compiler can keep its wits about what I'm trying to do?
15:18:41 <kmc> it couldn't be used
15:18:48 <kmc> because you're just declaring a type family
15:18:52 <kmc> not defining any types in that family
15:19:04 <JoeyA> Also, if I do say data Item instead of data Item m, does it not form a type family, then?
15:19:27 <kmc> it has no indices then
15:19:37 <kmc> i'm not sure if it's syntactically valid
15:19:53 <kmc> it's not such a meaningful question because this is a GHC extension anyway
15:19:54 <JoeyA> I got some code to compile with that.  I guess the compiler just treats it as one type or something?
15:19:58 <kmc> corner cases are liable to change without warning
15:19:59 <kmc> yeah
15:20:02 <JoeyA> okay, thanks.
15:20:18 <gienah> weak_head_normal: I guess the "signal 9" implies this is some unix os?
15:20:33 <kmc> JoeyA, GHC lets me write "data family T :: *; data instance T = MkT Int"
15:20:45 <kmc> but i don't think this is different from "data T = MkT Int"
15:21:04 <weak_head_normal> gienah: yes, arch linux
15:21:25 <gienah> weak_head_normal: it will want something like media-libs/libsdl
15:22:12 <gienah> weak_head_normal: I wonder if it may have ran out of virtual memory, not sure if it would die with signal 9 if it did
15:24:12 <weak_head_normal> gienah: that may be the case, since my computer has only 256 MB of ram and when installation hangs, hard disk is under heavy usage.
15:24:42 <kmc> weak_head_normal, you can try switching to the "gold" linker instead of GNU ld
15:25:18 <weak_head_normal> gienah: but I still wonder why does it happen? I can compile C/C++ programs with libsdl wihout any problems/
15:25:19 <Eduard_Munteanu> Heh, does Arch have stuff like media-libs/libsdl?
15:25:20 <JoeyA> In a type family, is it possible to require a type to be in a type class?  e.g. class Foo m where {data (Ord (Key m) => Key m :: * }
15:25:29 <Eduard_Munteanu> (that sounded like Gentoo stuff)
15:25:31 <JoeyA> Or should I just do that in functions that need Ord?
15:25:43 <gienah> weak_head_normal: I think there is a set of binary haskell packages for arch linux (not completely sure)
15:25:46 <JoeyA> i.e. Ord (Key m) => ...
15:26:16 <parcs> Eduard_Munteanu: yeah
15:26:17 <kmc> JoeyA, class (Ord (Key m)) => Foo m where { data Key m :: * }
15:26:23 <weak_head_normal> Eduard_Munteanu: I do not remember if it was avaliable via pacman or I compiled it from source
15:26:36 <kmc> JoeyA, iirc this is a pretty new GHC feature, or maybe it's only the use of equality constraints in that position which is new
15:26:44 <gienah> Eduard_Munteanu: yes media-libs/libsdl is gentoo, not sure what the package is called on arch linux
15:27:09 <parcs> weak_head_normal: try cabal install --ghc-option "-pgml /usr/bin/ld.gold" sdl
15:27:25 <JoeyA> kmc: Thanks.  I'll probably just do it per-function for the time being.
15:27:52 <kmc> o
15:27:53 <kmc> ok
15:28:00 <kmc> what's the general problem you're trying to solve here?
15:29:32 <parcs> weak_head_normal: eh actually that doesn't work. the main goal is to use the memory-efficient gold linker to link stuff instead of the default one. what i do is override 'ld' within my $PATH variable to point to ld.gold.
15:29:56 <JoeyA> kmc: I'm implementing an expression evaluator of sorts, with the handling of variable scopes abstracted out into its own module.
15:30:15 <kmc> ok
15:30:23 <kmc> and where do type classes with associated types come into it?
15:30:26 <JoeyA> So I'm doing some weird form of dependency injection.
15:30:59 <JoeyA> I'm defining a MonadScope typeclass, which is expected to implement the state operations needed, report errors, and supply the types used.
15:31:20 <weak_head_normal> parcs: invoking cablal with those options causes error: "/usr/bin/ld.gold -fno-stack-protection: unknown option"
15:31:35 <gienah> weak_head_normal: linking haskell packages can use lots of virtual memory, the ghc --disable-split-objs requires less memory during the link (ghc docs say that is the default anyway, not sure if cabal overrides it somehow)
15:31:47 <parcs> weak_head_normal: yeah. try overriding 'ld' within your $PATH
15:32:32 <JoeyA> Anyway, thanks for the help.
15:32:33 <kmc> JoeyA, ah, and did you consider abstracting in a way other than defining a new type class?
15:33:27 <weak_head_normal> parcs: I'm sorry to admit that I don`t know how to do it.
15:33:29 <JoeyA> kmc: I originally considered implementing a monad transformer for it.  But I'd be duplicating quite a bit of the transformer my interpreter will use.
15:33:56 <JoeyA> So my strategy is to implement against type classes that supply the required functionality.
15:34:11 <ozataman> hi all. is there an easy way to turn a non-Main module into an executable?
15:34:53 <benmachine> ozataman: does it have a main, or a thing with type IO thing which looks sort of mainish?
15:35:10 <JoeyA> I would be using pure values instead, but I need access to IO.
15:35:10 <gienah> weak_head_normal: there is an option, not sure if it would help or not: cabal configure --disable-split-objs
15:35:13 <ozataman> benmachine: yep, no problem with having a main in the module
15:35:29 <benmachine> ozataman: ghc has a -main-is switch
15:35:39 <geheimdienst> @remember benmachine ozataman: does it have a main, or a thing with type IO thing which looks sort of mainish?
15:35:39 <lambdabot> It is forever etched in my memory.
15:35:39 <benmachine> cabal has a Main-is: field
15:35:53 <benmachine> geheimdienst: :P
15:36:16 <ozataman> lol
15:36:25 <geheimdienst> i think it's clear and eloquent and yet funny
15:36:59 <benmachine> ozataman: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#options-linker -main-is is documented here
15:37:57 <ozataman> benmachine: cool, there we go. thank you! I'm surprised I haven't noticed it for this long :)
15:38:34 <weak_head_normal> gienah: --disable-split-objs didn't help either
15:39:31 <weak_head_normal> gienah: I found precompiled packages in aur, so my problem is solved. Thank you all for your help.
15:39:37 <benmachine> ozataman: GHC is full of secrets :o
15:39:58 <gienah> weak_head_normal: right it was these ones I was thinking might help: https://wiki.archlinux.org/index.php/Haskell_package_guidelines#.5Bhaskell.5D
15:44:27 <shurane> So I'm reading Real World Haskell, and it's telling me about the Text.Regex.Posix module, but I can't find it on my ghci (6.12.1). Where can I find it?
15:44:46 <shurane> s/on my/in
15:44:56 <dibblego> does partitionEithers :: [Either a b] -> ([a], [b]) generalise?
15:47:55 <hpc> dibblego: partition :: Alternatives container => [container a] => [[a]] -- like this?
15:48:08 <benmachine> dibblego: that's a vague question. if you were feeling silly you could make it Foldable f => f (Either a b) -> ([a], [b]) but I'm not sure there's much point
15:48:33 <dibblego> hpc: I think I need to have both type variables of the Either in the signature -- I have it generalised to MonadPlus, but I never like that
15:48:36 <gienah> @hoogle Text.Regex.Posix
15:48:37 <lambdabot> module Text.Regex.Posix
15:48:37 <lambdabot> Text.Regex.Posix getVersion_Text_Regex_Posix :: Version
15:48:37 <lambdabot> package regex-posix
15:48:49 <gienah> shurane: ^^
15:49:10 <hpc> if you want it generalized to arbitrary numbers of type variables, that's kind polymorphism, which haskell doesn't like
15:49:26 <gienah> @hackage regex-posix
15:49:26 <lambdabot> http://hackage.haskell.org/package/regex-posix
15:49:29 <dibblego> no, I want it generalized specifically to a binary functor
15:49:29 <benmachine> I don't like it either, it sounds confusing
15:49:48 <shurane> gienah: oh, so regex isn't included by default? Alright, cool.
15:49:50 <hpc> dibblego: http://hackage.haskell.org/package/bifunctors
15:49:53 <hpc> that should help
15:50:31 <dibblego> @type let lefts = (=<<) (either (const mzero) return); rights = (=<<) (either (const mzero) return) in lefts &&& rights
15:50:31 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => m (Either a a1) -> (m a1, m a1)
15:50:49 <gienah> shurane: yes regex-posix is on hackage, and part of the haskell platform
15:50:51 <hpc> you probably want something in Bifoldable
15:50:55 <dibblego> er that's still not where I want anyway, but yeah
15:50:58 <benmachine> dibblego: I assume one of those should be either return (const mzero)
15:51:07 <dibblego> right, I've been fiddling with Bitraversable and Bifoldable
15:51:31 <dibblego> @type let lefts = (=<<) (either return (const mzero)); rights = (=<<) (either (const mzero) return) in lefts &&& rights
15:51:32 <lambdabot> forall (m :: * -> *) a b. (MonadPlus m) => m (Either a b) -> (m a, m b)
15:51:36 <dibblego> thanks
15:52:18 <copumpkin> > let lefts = (=<<) (either return (const mzero)); rights = (=<<) (either (const mzero) return) in lefts &&& rights $ [Left 5, Right 2, Left 1, Left 2, Right 6]
15:52:20 <lambdabot>   ([5,1,2],[2,6])
15:54:52 <dibblego> it's like Bitraversable.bisequence with some arrow swapping
15:59:09 <dibblego> my kmett power is weak
16:01:23 <c_wraith> This one's new.  I'm not used to seeing "Bus Error" and then my shell prompt when using ghci
16:02:17 <DevHC> get used to it
16:02:38 <c_wraith> I'll probably see quite a lot of it in the next few days
16:02:38 <DevHC> > array (0,maxBound-1) [] :: Array Int Char
16:02:39 <lambdabot>  Terminated
16:03:38 <kmc> yikes c_wraith, what are you doing?
16:03:57 <c_wraith> kmc: learning the ghc api.
16:05:11 <kmc> i see
16:05:21 <kmc> what OS?
16:05:23 <c_wraith> well, it's infinitely repeatable
16:05:26 <c_wraith> osx 10.6
16:05:37 <kmc> ah, i don't remember any way to get a Bus error on x86 Linux
16:05:52 <adrake> I get bus errors out of gdb periodically on x86 Linux
16:06:03 <monochrom> misalignment gets you bus error on x86 linux
16:06:10 <kmc> ah, on SSE ops or something?
16:06:26 <c_wraith> ooh, segfault this time
16:06:43 <monochrom> but misalignment takes conscious effort in ghc api
16:06:52 <Eduard_Munteanu> Or a really broken CPU ;)
16:07:36 <hpaste> c_wraith pasted “segfault” at http://hpaste.org/51436
16:07:51 <bos> @src gcd
16:07:51 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
16:07:51 <lambdabot> gcd x y = gcd' (abs x) (abs y)
16:07:51 <lambdabot>    where gcd' a 0  =  a
16:07:51 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
16:08:19 <c_wraith> seriously, I'm not sure what *that* segfaults
16:10:20 <c_wraith> yeah, seems like I'm doing something wrong, if runGHC always segfaults
16:10:26 <c_wraith> or causes a bus error
16:11:04 <parcs> did you do any code editing yet?
16:11:43 <c_wraith> huh?
16:12:09 <parcs> is that the vanilla api that you are using?
16:12:11 <DevHC> why isn't gcd 0 0 defined?
16:12:38 <c_wraith> yes, I'm not changing the ghc api, just using it
16:13:12 <hpc> > gcd 1 0
16:13:13 <lambdabot>   1
16:13:14 <Eduard_Munteanu> DevHC: because anything divides zero?
16:13:16 <hpc> > gcd 0 1
16:13:16 <lambdabot>   1
16:13:22 <juliohm> Dear all, i'm really interested in learn Haskell, i've ended with two options (Python or Haskell) by discarding a lot of languages which share the same features. What are the good points and points in adopt Haskell as a second non performance language for professional scripts?
16:13:23 <Eduard_Munteanu> So it'd be infinity.
16:13:39 <juliohm> and bad points*
16:14:14 <Eduard_Munteanu> well, besides zero itself
16:14:25 * juliohm should pick Python or Haskell?
16:14:38 <hpc> > gcd 0 2
16:14:39 <lambdabot>   2
16:14:39 <DevHC> even 0 divides 0
16:14:43 <hpc> > gcd 2 0
16:14:44 <lambdabot>   2
16:14:49 <Eduard_Munteanu> juliohm: can you expand on "professional scripts"?
16:15:08 <DevHC> and GCD is NOT defined by selecting the "biggest" divisor
16:15:12 <hpc> from this, it looks like gcd _ 0 = 0, and gcd 0 _ = 0; there's no discontinuity at gcd 0 0 to stop them from defining it
16:15:13 <Eduard_Munteanu> DevHC: mm, I guess you're right technically, it does.
16:15:25 <hpc> as far as "graphing" the function goes
16:15:28 <juliohm> Eduard_Munteanu, readable, easy to maintain, portable as possible.
16:15:35 <Saizan> http://www.haskell.org/haskellwiki/FAQ#Should_I_learn_Haskell.3F
16:16:07 <DevHC> zomg, look: http://hackage.haskell.org/trac/ghc/ticket/3304
16:16:09 <Eduard_Munteanu> Yeah, that should be good reference ^
16:16:42 <Saizan> brief though
16:16:52 <parcs> c_wraith: ah. fwiw i'm not experiencing that issue. maybe it's a mac thing
16:18:16 <juliohm> Ok guys, thank you. Let me read the docs properly. ;-)
16:19:16 <c_wraith> parcs: hmm, confirmed.  It works on linux
16:19:23 <kmc> juliohm, the performance you get in Haskell without trying will still be a lot better than the performance you get in Python without trying
16:19:33 <kmc> speaking in invalid generalizations, of course
16:20:08 <kmc> juliohm, the main problem is that code isn't readable unless you know the language, and not many people know Haskell
16:20:30 <kmc> and it's difficult to learn; it's not like asking a Ruby programmer to learn Python
16:20:30 <DevHC> @src gcd
16:20:30 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
16:20:30 <lambdabot> gcd x y = gcd' (abs x) (abs y)
16:20:30 <lambdabot>    where gcd' a 0  =  a
16:20:30 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
16:21:55 <juliohm> kmc, understand. About your first statement, what did you meant? Haskell has better performance than Python code? :-)
16:22:15 <kmc> well, languages don't have performance; implementations do
16:22:42 <kmc> and performance in any language is largely a matter of how hard you work at it
16:22:54 <kmc> and how much you sacrifice other things -- clarity, readability, speed of development
16:23:15 <kmc> but what i mean is that nice-looking haskell code compiled with GHC will usually run much faster than nice-looking Python code interpreted by CPython
16:23:15 <juliohm> oh, nice.
16:23:31 <kmc> because GHC is a sophisticated optimizing compiler, and CPython is an awful interpreter
16:23:43 <kmc> this is particularly true if you're using concurrency or parallelism
16:23:55 <kmc> CPython is a joke for those
16:24:08 <juliohm> kmc, what is the format of the compiled code in Haskell? Is the so called C-- language?
16:24:24 <kmc> there's no format for compiled code "in Haskell"
16:24:34 <kmc> different compilers can do different things
16:24:41 * juliohm really needs to read about Haskell before make stupid questions. :-P
16:24:50 <kmc> GHC is the compiler most people use, and it produces real actual native machine code
16:25:06 <DevHC> @src lcm
16:25:06 <lambdabot> lcm _ 0     =  0
16:25:06 <lambdabot> lcm 0 _     =  0
16:25:06 <juliohm> You mean ELF binaries?
16:25:06 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
16:25:08 <kmc> C-- (actually Cmm) is just the name of one of GHC's internal intermediate forms, before it produces machine code
16:25:22 <kmc> juliohm, ELF on Linux, PE on Windows...
16:25:25 <juliohm> Seems really amazing.
16:25:25 <kmc> machine code.
16:25:29 <juliohm> yep. :-)
16:25:48 <juliohm> Thank you for explain, let me learn Haskell... ;-)
16:25:59 <kmc> have fun :)
16:26:05 <kmc> don't hesitate to ask questions here if you run into trouble
16:26:46 <juliohm> Thank you kmc :-)
16:26:51 <kmc> juliohm, you might also be interested in http://haskell.org/haskellwiki/FAQ
16:27:06 <kmc> but i'm biased 'cause i wrote most of it ;)
16:27:54 <Nimatek> Careful, Haskell can be negative for your motivation when you have to work on something in a language like Java.
16:29:02 <kmc> yep
16:29:56 <c_wraith> Oh.
16:30:09 <c_wraith> I wonder if this is related to that stack corruption bug
16:31:26 <kmc> which?
16:31:30 <c_wraith> http://hackage.haskell.org/trac/ghc/ticket/5003
16:31:32 <c_wraith> I bet it's that
16:34:06 <kmc> interesting
16:34:12 <kmc> systems programming is a delight
16:34:53 <hpaste> “Joey Adams” pasted “Can a type class parameterize a type member of its context class?” at http://hpaste.org/51438
16:35:42 <kmc> JoeyA, you're trying to give a type instance in a class definition; usually they'd only be allowed in class instances
16:36:08 <kmc> there is some sensible meaning analogous to default implementations of overloaded functions
16:36:10 <JoeyA> Indeed.  I'd like to know if it's possible to constraint the type of a family member when "subclassing" like that.
16:36:12 <kmc> but iirc unimplemented in ghc
16:37:17 <JoeyA> I guess I could require methods fromInt and toInt to force the type to act like Int when I want it to.
16:39:07 <hpaste> kmc annotated “Can a type class parameterize a type member of its context class?” with “for JoeyA” at http://hpaste.org/51438#a51439
16:39:14 <juliohm> Ok, first question: Why [-2^29, 2^29-1] instead of the common range for signed integers?
16:39:44 <mauke> juliohm: tag bits
16:39:44 <juliohm> Forgetting about the Integer type which can deal with arbitrary precision.
16:39:50 <kmc> juliohm, so that Haskell implementations have the option to use two bits of a machine word as tags
16:39:55 <kmc> e.g. to distinguish integers from pointers
16:40:14 <kmc> juliohm, GHC does not do this, and on GHC an Int will be a machine word
16:40:21 <kmc> that's only the *minimum* mandated range
16:40:39 <juliohm> hmmm, understand.
16:40:43 <kmc> note that an Int on 64-bit GHC is 64 bits even though a C int is 32-bits on some 64-bit platforms
16:40:57 <kmc> (also very weird custom builds of GHC will not obey the above)
16:41:18 <juliohm> Ok, perfect answer. :-)
16:41:37 <mauke> well, C only guarantees 16 bits for int, so Haskell is still better :-)
16:41:37 <kmc> JoeyA, on 7.0 i get "Alas, GHC 7.0 still cannot handle equality superclasses"
16:41:46 <Jafet> Due to ghc's data representation, Int might as well be the machine word size
16:42:26 <kmc> GHC leaves some extra information around (in info tables; in update frames on the continuation stack) to tell it which words are heap pointers and which are not
16:42:56 <JoeyA> Thanks
16:42:58 <hpc> does it need those?
16:43:03 <kmc> yes, for garbage collection
16:43:07 <kmc> it needs to know which pointers to follow
16:43:12 <hpc> i thought it knew which were pointers and which were int at typechecking time
16:43:15 <kmc> that's where tag bits would be used
16:43:18 <hpc> ah
16:43:28 <kmc> hpc, it also knows then, but the RTS needs to know too
16:43:43 <hpc> yeah i see now
16:44:06 <mauke> solution: static gc passes generated at compile time
16:44:36 <kmc> GHC does some of that, actually
16:44:42 <Jafet> ghc doesn't need to solve another halting problem now, does it.
16:45:02 <kmc> in that some info tables point at a custom "garbage collect me" function
16:45:09 <kmc> while others have a common layout and use a common function
16:45:33 <kmc> (much of what I know about how GHC works comes from reading papers which were published in, like, 1992, so it may be inaccurate)
16:45:50 <kmc> GHC *does* these days use the low bits of a pointer as tags
16:46:00 <kmc> to indicate which constructor (if any) is known to live behind that pointer
16:46:14 <kmc> but it doesn't reserve tag bits in machine ints (Int#)
16:48:56 <kmc> JoeyA, does it make sense? i haven't tested this all the way
16:49:38 <kmc> JoeyA, oh, hmm, I think you can never write an instance for Bar with this code
16:50:01 <kmc> because FooType is a *data* family, and so you're required to define a *new* type in the Foo instance
16:50:08 <kmc> which will never be equal to the existing BarType
16:50:15 <kmc> you could make it work with a type *synonym* family
16:51:30 <hpaste> “Joey Adams” annotated “Can a type class parameterize a type member of its context class?” with “Trying to put the context on a function instead” at http://hpaste.org/51438#a51440
16:51:52 <hpaste> kmc annotated “Can a type class parameterize a type member of its context class?” with “for JoeyA (annotation)” at http://hpaste.org/51438#a51441
16:52:19 <kmc> this'll have the same problem JoeyA
16:52:30 <kmc> (putting the context on a function)
16:53:08 <JoeyA> Thanks.
16:53:39 <JoeyA> I could probably do what I want with functional dependencies.  The only downside is that I'll have to supply a lot of parameters.
16:54:15 <kmc> or you could try to find a non-typeclass solution
16:54:18 <JoeyA> For my case, I probably might as well give up on the dependency injection and use stub types for now.
16:54:26 <kmc> i.e. passing around the functions you want in an ordinary data type
16:56:20 <kmc> @quote LukePalmer
16:56:20 <lambdabot> LukePalmer says: ...when you use an advanced feature, you need a yet more advanced feature to abstract over it... But all you need to abstract over a function is another function.
16:56:56 <kmc> this is a classic rant of mine... I think functional programming is underappreciated in the Haskell community
16:57:03 <JoeyA> heh
16:57:52 <geheimdienst> omg you can pass functions around? since when?!
16:58:12 <kmc> geheimdienst, only in Javascript
16:58:28 <dibblego> haha
16:58:55 <mauke> bah, javascript stole it from perl
16:58:57 <geheimdienst> oh. right. but it's a little tedious, isn't it ... "function () { return ... }" is a lot of typing
16:59:08 <mauke> sub { ... }  # much better
16:59:16 <kmc> and you don't need "return"!
16:59:21 <mauke> inorite
16:59:30 <JoeyA> There's always CoffeeScript
16:59:50 <kmc> geheimdienst, it proves that functional programming is tedious, right?
17:02:10 <Dashkal> php has the best lambdas.  String -> (a -> b)
17:02:23 <kmc> hehe
17:02:31 <kmc> C#'s lambda is simultaneously a syntax quotation
17:02:38 <kmc> that kind of wrecks parametricity
17:02:42 <kmc> but it's useful
17:27:45 * edwardk waves hello.
17:33:38 <kmc> hi edwardk
17:37:09 <edwardk> yo
17:37:29 <kmc> do you know if there's been any work towards integrating GHC's STM with external transactional systems, like databases?
17:37:53 <dolio> I haven't heard of any.
17:38:03 <edwardk> none that i know of, big distributed transaction systems kinda took a blow when microsoft realized they couldn't STM all of .net and nothing has really been done since
17:38:06 <dolio> For what that's worth.
17:38:59 <kmc> i wonder what kind of hooks the STM implementation would have to expose
17:39:16 <kmc> in order for someone to write, say, a SQL database binding which let you execute SQL statements in STM
17:39:27 <kmc> you'd want a way to register a callback to be executed on transaction commit
17:39:38 <edwardk> you'd probably need to buy into an external two-phase commit, which is very non-STM-y
17:39:47 <kmc> *nod*
17:54:55 <edwardk> @pl \r -> addCaret (delta r) r
17:54:55 <lambdabot> addCaret =<< delta
18:06:04 <blackdog> https://gist.github.com/1223533
18:06:04 <blackdog> getting an ld crash with compiling a simple file on mac, ghc 7.2.1.
18:06:04 <blackdog> on two separate machines... can anyone confirm?
18:23:04 <shirt> how can i write a function 'f :: (String, String) -> String' that will turn ("foo", "bar") into "foo.bar"?
18:23:36 <Jafet1> What will it turn (str1, str2) into?
18:23:53 <shirt> str1 ++ "." ++ str2
18:24:03 <Jafet> See, you've already written the function!
18:24:15 <shirt> i'm looking for something that is point free :)
18:24:27 <Jafet> @pl f (str1, str2) = str1 ++ "." ++ str2
18:24:27 <lambdabot> f = uncurry ((. ('.' :)) . (++))
18:24:59 <shirt> hm...
18:25:06 <Jafet> I suppose you won't be given any points for writing that.
18:25:26 <shirt> will ghc compile both of these to the same code?
18:26:16 <parcs> shirt: see System.Directory.(<.>)
18:26:28 <Jafet> Why do you care that they are "the same"?
18:27:02 <parcs> :t (System.FilePath.<.>)
18:27:03 <lambdabot> FilePath -> String -> FilePath
18:27:04 <shirt> Jafet: just curious
18:27:40 <Jafet> Note that pl actually transformed str1 ++ '.' : str2.
18:28:34 <shirt> clever fellow
18:28:54 <Jafet> ghc will produce code that does the same thing -- whether or not it produces the same core, IR, or machine code, is anyone's guess
18:29:15 <Jafet> Some people here have much better guesses, though
18:34:58 <edwardk> shirt: in general no, it won't. the inliner doesn't fire on partially applied functions like it does on fully saturated ones, so you'll get very different inlining behavior. however, neither behavior is better than the other in all cases
18:35:50 <shirt> interesting
18:35:52 <edwardk> shirt: otoh, if you are writing a function that takes a tuple as an input randomly, you probably have other stylistic differences that will far outweigh any such fiddly inliner differences
18:36:40 <kmc> premature optimization is the root of something something
18:36:49 <Jafet> something something darkside
18:37:02 * edwardk is pretty evil then. ;)
18:37:24 <shachaf> edwardk is certainly something.
18:38:12 <edwardk> "easily bored" is probably the best way to fill in that blank ;)
18:54:32 <hpaste_> Stribor pasted “recurisve” at http://hpaste.org/51442
18:54:50 <stribor> can someone help me with this function....i am getting type error
18:55:51 <c_wraith> stribor, can you include the error message, too?
18:56:22 <c_wraith> though, your first case *cannot* happen.  a non-empty list can never equal an empty list
18:56:32 <hpaste_> stribor pasted “error” at http://hpaste.org/51443
18:56:44 <monochrom> s/myFunction (a ++ x) tail xs/myFunction (a ++ x) (tail xs)
18:57:07 <stribor> my foirst case was x:xs =[] then it is empy list
18:57:12 <stribor> why cant it be empty list
18:57:15 <monochrom> but I am not sure whether it should be "(tail xs)" or just "xs"
18:57:24 <c_wraith> stribor: (x:xs) can *never* be an empty list.
18:57:31 <monochrom> hehe
18:57:49 <stribor> well x:xs means it has head and tail right?
18:57:54 <monochrom> c_wraith means it is always False, you're wasting computer's time
18:57:56 <stribor> >tail[]
18:58:02 <stribor> > tail []
18:58:03 <lambdabot>   *Exception: Prelude.tail: empty list
18:58:12 <c_wraith> > 5 : []
18:58:13 <lambdabot>   [5]
18:58:21 <stribor> > tail []
18:58:22 <lambdabot>   *Exception: Prelude.tail: empty list
18:58:32 <c_wraith> No matter what xs is, putting something in front of it with (:) means that the result is non-empty
18:58:58 <monochrom> > ("" : []) == []
18:58:59 <lambdabot>   False
18:59:04 <monochrom> there, an extreme case
18:59:24 <stribor> so how would i make base case then
18:59:39 <c_wraith> well, your function isn't handling the case of an empty input list
19:00:03 <c_wraith> it's pattern matching the (:) constructor for lists, but not the [] constructor
19:00:05 <stribor> well if my input list is empty i still have another input which is string
19:00:07 <monochrom> myFunction a [] = ?
19:00:15 <stribor> string:[]=
19:00:27 <stribor> its [a]
19:00:40 <monochrom> cool, add it to your code
19:00:42 <stribor> a [] = [a]
19:01:03 * monochrom should not get involved in this
19:01:10 <stribor> is there anything else wrong with it that you can point me to
19:01:24 <stribor> i think monochrome should get involved very much so:)
19:02:04 * hackagebot trifecta 0.47 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.47 (EdwardKmett)
19:02:52 <edwardk> i redesigned the way i was plumbing diagnostic messages through trifecta. now there are a much simpler set of combinators, and many fewer twisty passages they must take going through the parser
19:03:39 <c_wraith> so...  it's not a maze of twisty packages all alike anymore?
19:04:03 <edwardk> nah, like my github, it is a twisty maze of packages all different.
19:04:04 <monochrom> I recommend putting this homework aside, write and test and understand something way simpler first. you are not ready for this homework.
19:04:49 <hpaste_> strobor pasted “new cpde” at http://hpaste.org/51444
19:05:08 <monochrom> for example if you define "f (x:xs) = xs" find out what it does. if you define "g (x:xs) = tail xs" find out what that does it. you may be surprised
19:05:16 <stribor> i am ready its just that i dont get this function
19:05:23 <stribor> this function is more then i understand
19:07:19 <monochrom> I am serious. It is how I learned when I was a student. I got homework, I screened it to find out what basic knowledge it is trying to test me on. Then I threw away the homework and drilled on the basic knowledge purely for two weeks.
19:08:02 <monochrom> Then just two hours before the deadline I recovered the homework and started doing it. I was very successful.
19:08:09 <stribor> yeah i know....i just dont get why would this kind of function be put on the beginer course in haskell
19:08:52 <monochrom> I observed that every classmate who hacked on the homework directly and solely for two weeks were unsuccessful.
19:09:35 <stribor> ouldn't match expected type `[String]'            against inferred type `[a] -> [a]'..............................does that mean that expected type is list of strinf and i am passing [a]->[a]
19:09:51 <Nafai> monochrom: sounds like you were a lot smarter in school than me :(
19:10:25 <monochrom> or as dumb as a computer, i.e., blindly but faithfully do dependency chasing
19:11:03 <edwardk> monochrom: i do uch the same thing when coding. see a problem, chase after all of the things to make that one piece of code pretty and eventually get back to where i started
19:11:14 <edwardk> lots of dependency chasing
19:11:38 <edwardk> it drives people who pair program with me nuts sometimes (sorry dolio!)
19:12:31 <tgeeky> edwardk: check this out http://hpaste.org/51445
19:12:39 <tgeeky> edwardk: let me know if that looks nicely arranged to you :o
19:13:20 <edwardk> it is a bit wide for my taste and i don't like the )->'s but otherwise not too bad
19:13:36 <tgeeky> edwardk: yeah, it's 140 char wide
19:14:07 <edwardk> well, i don't mind 140 chars of width if they ad needed bt for instance import qualified     Data.Functor.Constant       as     FunC   -- nothing is forcing the space between qualified and Data
19:14:14 <edwardk> s/ad/are/
19:14:26 <tgeeky> edwardk: right, I'm spacing like that to align things vertically over the whole document
19:15:06 <tgeeky> edwardk: in general, though, a presentation of types bunched up like this (rather than type .. function  .. type .. function)
19:15:14 * edwardk shrugs. i tend to space within a local group. if i can't see the other thing i'm aligning with because it is off th screen below me, why am i bothering to align with it?)
19:15:14 <tgeeky> seems more revealing
19:15:27 <tgeeky> edwardk: oh, the transformation was automatica
19:15:29 <tgeeky> automatic*
19:15:34 <tgeeky> this was inverted from the original
19:15:42 <edwardk> ah
19:15:54 <tgeeky> i'm making my silly whitespace tensor project
19:17:00 <edwardk> this reminds me i need to put together some combinators for doing grouped alignment in my pretty printer library
19:17:16 <edwardk> not quite _this_ severe, but some
19:17:20 <tgeeky> edwardk: at some point, I'm probably going to break down and use your library to implement things
19:17:45 <tgeeky> but I am going to do revision's 1 and 2 "my way" and see where it leads
19:17:50 <edwardk> *nods*
19:18:04 <tgeeky> intuition is awesome, and it sucks. at the same time. :(
19:18:29 <tgeeky> edwardk: trifecta really is a nirvana of code, though
19:18:46 <tgeeky> probably the cleanest library ever, given the spread of functions
19:19:13 <tgeeky> s/functions/functionality/
19:19:42 <edwardk> thanks. =)
19:19:45 <tgeeky> edwardk: btw, did you know someone is using multiplate to do JS stuff: http://hackage.haskell.org/packages/archive/WebBits-multiplate/0.0.0.1/doc/html/src/BrownPLT-JavaScript-Multiplate.html
19:20:54 <edwardk> i've been trying to make sure i always have room to grow because there is so much more than needs to hang off of the hierarchy
19:21:39 <edwardk> well, gershom uses compos all over the place in jmacro, so that isn't all THAT shocking =)
19:21:41 <tgeeky> edwardk: yes. I'd love to look through the mile-high diff view later
19:22:03 <tgeeky> edwardk: so, Hinze published a new paper about Streams
19:22:12 <tgeeky> edwardk: or, he is going to, in ICFP November...
19:22:28 <edwardk> to what end?
19:23:08 <tgeeky> Proving The Unique Fixed-Point Principle Correct - An Adventure with Category Theory
19:23:13 <edwardk> ah
19:23:18 <monochrom> . o O ( a stream has only one end. the beginning end. )  <duck>
19:23:48 <edwardk> it has 2. the beginning and when you got tired of following it ;)
19:23:57 <edwardk> like a lot of webcomics
19:25:54 <monochrom> category theory and unique fixed point together sounds scary. I have been there. (prove that in common categories of CPOs, least fixed points exist so that the like of "data [a] = [] | a:[a]" are ok.)
19:26:13 <Jafet> Or papers
19:26:43 <tgeeky> well, his paper makes it sound like he has almost characterized all streams by a few paramters (how many things they gobble, how many things they spit out, per recursion)
19:27:08 <monochrom> "an adventure with category theory" is not an exaggeration!
19:27:14 <tgeeky> no, it's really long
19:28:04 <tgeeky> edwardk: this http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf -- which now loads, and previously didn't, is what I'm reading now
19:29:48 <edwardk> tgeeky: ah neat. i'd seen the fold version before, the fact that you can do it with unfolds is a pretty neat result
19:30:08 <tgeeky> edwardk: I think it's probably going to be relevant to generally invertible parsing/printing, too
19:30:21 <edwardk> meh
19:30:46 <tgeeky> edwardk: it seems like invertible-syntax is built at the bottom-most layer with the Maybe monad (and then he goes to show that (Either ..) doesn't work propery)
19:30:49 <edwardk> invertible parsing yields pretty crappy intermediate ASTs
19:31:03 <tgeeky> edwardk: well, again, I'm parsing in blocks, not characters
19:31:16 <edwardk> *nods*
19:32:02 <edwardk> i've actually been looking at adding a Syntax class to trifecta that can be used for things like parens, char, and a few others that are invertible
19:32:03 * tgeeky thinks about doing some clever stuff with (24,8) (8,24) bit parsing :o
19:32:12 <edwardk> that way i can make some small parts of the grammar invertible
19:32:15 <tgeeky> edwardk: yeah, i actually partially impemented 'chiral' combinators
19:32:21 <edwardk> even if i don't go out of my way to make the entire parser that way
19:32:39 <tgeeky> edwardk: however, there is something to say about *just* doing invertible "whitespace"
19:32:40 <edwardk> chiral?
19:33:26 <tgeeky> edwardk: yeah, differentiating between things which should be spaced in pairs () {} [] versus things that should be spaced infix only , . etc
19:33:26 <edwardk> well, one way to get invertible whitespace might be to just log an interval map of where all the comments are in the whitespace
19:33:38 <edwardk> that is basically the approach i'm taking currently
19:34:01 <tgeeky> edwardk: well, the other thing to note, in my humble opinion, is that *everything* in comments is "whitespace"
19:34:04 <edwardk> (that being the interval map)
19:34:06 <tgeeky> even though it matters where it is
19:34:30 <edwardk> well, the whiteSpace parser for a parser in trifecta is responsible for consuming comments typically
19:34:59 <tgeeky> but i imagine inverting a single file's: [whitespace, pragmas, comments, imports, exports] -- the things whose placement either doesn't matter in the document (type signatures)
19:35:12 <edwardk> so for Literate it consumes literate comments, for Language it uses whatever comment style you pick, the base Parser just parses real whitespace, Layout makes it aware not to parse virtual semicolons and virtual braces, etc.
19:35:23 <tgeeky> or things whose place does matter in the document, and hence you can control it completely (imports, LANGUAGE pragmas)
19:35:40 <tgeeky> edwardk: right, but Literate is tex, right?
19:35:53 <tgeeky> edwardk: if you have a more ambiguious literate format (haskell-in-markdown)
19:36:10 <edwardk> the trifecta literate parser does both \begin{code} … \end{code} and bird tracks (lines starting with >)
19:36:17 <tgeeky> then you might want (even though it seems hard) to highlight code-in-comments-in-code-in-comments-in-code
19:36:36 <edwardk> you actually can get comments that straddle literate comments ;)
19:36:40 <edwardk> and they parse correctly
19:36:56 <tgeeky> stop tempting me, heathen!
19:37:05 * tgeeky grabs his invertible pitchfork
19:37:46 <edwardk> \begin{code}\n   {- …. \n \end{code} …. \begin{code}\n   -} -- straddles the literate comment
19:37:46 <edwardk> and you get a LiterateComment highlight for the end{code} … begin{code} block and a Comment interval for the {-    to -}
19:38:26 <edwardk> (and LiterateSyntax highlights so you can know where the \begin{code} and \end{code} are on the ends of the literate comment (or where the bird tracks are for highlighting purposes
19:38:58 <edwardk> the CPP parser transformer will probably add another comment style for #if 0
19:39:52 <stribor> > let a =  "name":["something","somethingelse"]
19:39:53 <lambdabot>   not an expression: `let a =  "name":["something","somethingelse"]'
19:40:13 <Jafet> Stop straddling parentheticals, edwardk
19:40:28 <edwardk> )
19:40:34 <stribor> does this expression  "name":["something","somethingelse"] result in ["name","something","somethingelse"]
19:40:40 <tgeeky> edwardk: that is getting in the way of my markdown headers :o
19:40:42 <edwardk> stribor: yes
19:40:50 <Cale> > "name":["something","somethingelse"]
19:40:50 <monochrom> > "name":["something","somethingelse"]
19:40:51 <lambdabot>   ["name","something","somethingelse"]
19:40:51 <lambdabot>   ["name","something","somethingelse"]
19:40:53 <stribor> and isnt that type a [String]
19:41:00 <monochrom> yes
19:41:01 <Cale> stribor: yes
19:41:06 <monochrom> @type "name":["something","somethingelse"]
19:41:06 <edwardk> tgeeky: well, i was planning on writing a markdown parser so i could parse markdown within comments or in literate blocks
19:41:08 <lambdabot> [[Char]]
19:41:18 <stribor> i am getting type errort that this [[Char]]
19:41:19 <monochrom> simplies to [String]
19:41:31 <mauke> stribor: what's the error message?
19:41:50 <monochrom> is forthcoming
19:42:17 <solidsnack> edwardk: Would comment straddling as you describe, simply cause the inner \end...\begin to be unmarked?
19:42:37 <tgeeky> edwardk: there is a sundown (C) based parser that (1) you can test agianst, (2) you can benchmark against
19:42:46 <stribor> no error now:)
19:43:01 <stribor> i guess haskell do loves me sometimes:)
19:43:13 <edwardk> solidsnack: it depends on if you layer Literate over Language or Language over Literate.
19:43:23 <edwardk> layering Language over Literate is safer though
19:43:40 <solidsnack> edwardk: What does this look like in code? Is there an example posted somewhere?
19:43:47 <solidsnack> (Late to the discussion.)
19:44:03 <tgeeky> edwardk: I presume you haven't read the literate programming book by knuth?
19:44:15 <tgeeky> i was surprised to see that it was a collection of essays :o
19:44:17 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Rich.hs
19:45:05 <solidsnack> Oh, interesting.
19:45:09 <shirt> @pl f x = x 1
19:45:10 <lambdabot> f = ($ 1)
19:45:15 <edwardk> you can use that and parseFromFile (rich LiterateStart haskellLanguageDef (some parser)) "Your.literateSourceFile"
19:45:16 <solidsnack> Layout is layered on top of them?
19:45:28 <edwardk> yeah
19:45:38 <solidsnack> That is like, the "blockiness" parser?
19:45:39 <joe6> anyone using this: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023122.html
19:45:46 <joe6> any experiences to share?
19:45:49 <joe6> do you like it or not
19:45:52 <edwardk> layout gets you indented parsing for things like where, do, etc.
19:46:01 <joe6> http://stephan.walter.name/files/haskellcomplete.vim specifically
19:46:07 <edwardk> and the understanding of virtual semicolons, etc needed to support that
19:46:16 <edwardk> but in a language-neutral manner
19:46:26 <solidsnack> edwardk: Oh, interesting.
19:46:40 <tgeeky> joe6: that looks like something one would do well to generate
19:46:45 <tgeeky> joe6: and since it's from 2007...
19:47:03 <joe6> tgeeky, how?
19:47:21 <tgeeky> joe6: dunno, I might give it a shot.
19:47:28 <tgeeky> joe6: but also hackage --hoogle options
19:47:34 <joe6> it would be great to generate it from ~/.cabal
19:47:58 <tgeeky> joe6: yes, I'll take a look
19:48:00 <tgeeky> joe6:
19:48:03 <edwardk> solidsnack: the Literate parser takes the base parser which just treats real spaces as white space and adds the skipping of the code outside \begin{code}..\end{code} or bird tracks.   layering the Language on top lets you pick a comment style (e.g. {- … -} with nested comments and -- for single line comments)
19:48:09 <tgeeky> joe6: you might want to use something like
19:48:20 <tgeeky> neocomplcache -- https://github.com/Shougo/neocomplcache
19:48:20 <edwardk> then adding Layout on top lets you have indentation based control if you want it
19:48:38 <tgeeky> joe6: and then us something like haskdogs http://hackage.haskell.org/package/haskdogs-0.2 <-- to create ctags
19:49:01 <edwardk> all of those basically add additional state tracking (a reader in the case of Language) to better know how to manipulate whitespace
19:49:10 <joe6> tgeeky, i am using neocomplcache. I am trying to configure it to work properly with haskell.
19:49:32 <edwardk> and in the literate and layout case add more information to 'marks' so that if you want to seek back to a previous parser location it remembers the layout and literate state it was in
19:49:48 <edwardk> which is useful when you need two pass parsing over some things
19:50:11 <solidsnack> So how is the "virtual semicolon" encoded in a language independent way?
19:50:17 <edwardk> e.g. if you wanted to parse haskell identifiers with the correct fixity y seeking back
19:50:20 <joe6> ok, will have to figure out the haskdogs vis-a-vis neocomplcache and ivm.
19:50:24 <joe6> /ivm/vim/
19:50:39 <tgeeky> joe6: no idea what haskdoes actually does, since I haven't used it.
19:50:49 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Layout/Monad.hs#L55
19:50:55 <tgeeky> joe6: also, there is 'GOA' -- ghci on acid
19:50:59 <tgeeky> which might have some interesting related stuff.
19:51:02 <solidsnack> edwardk: I am reading through the modules; looking at LanguageDef, it doesn't seem to have any notion of delimiters like that.
19:51:06 <edwardk> you can choose to use the 'semi' combinator that comes with the monad you are in or you can use another
19:51:28 <solidsnack> Oh, interesting.
19:51:31 <edwardk> LanguageDef doesn't know about semi colons, that comes in MonadParser because i needed it to be there so i could transform it as you go up the tower
19:51:57 <solidsnack> It's not independent so much Language but rather of anything parseable at all...
19:52:16 <solidsnack> Any parser can be made layoutable?
19:52:31 <edwardk> well, you'd need to work with the grammar to make it possible
19:52:43 <edwardk> but the general idea was that Layout takes care of the hard parts of layout for you
19:52:49 <solidsnack> Hmm.
19:53:01 <edwardk> so you can just use parens, etc. and it 'does the right thing'
19:53:02 <luite> joe6: I have some scripts on github that build a hoogle index for all installed pkgs, you'll get the text index files which should be easy to use for that (just parse the module .... lines and then collect all type sigs below)
19:53:04 <solidsnack> As long as you use the semi combinator?
19:53:55 <edwardk> reserved "do" >> laidout (semiSep statement) -- done ;)
19:54:07 <joe6> luite, that would be awesome.
19:54:16 <joe6> luite, what is the github link?
19:54:27 <zong_sharo> how do i construct Ptr (Ptr CChar) ?
19:54:40 <tgeeky> omg! luite updated his githubs!!!
19:54:41 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Layout/Combinators.hs#L61
19:54:42 <zong_sharo> (const **char counterpart)
19:54:42 <tgeeky> praise the lord
19:55:19 <edwardk> laidout does the haskell-style layout rule of use literal { }'s with real ;s or optionally take the indentation of the next lexeme and start there
19:55:31 <luite> joe6: not really quality stuff or anythign :p https://github.com/luite/haskell-scripts/blob/master/update-hoogle
19:56:06 <tgeeky> luite: don't be so modest. even medicore code is better than no prior art at all
19:56:16 <edwardk> and the tricky result <$ layout <?> "…" case in enableLayout is just enough to make it so let … in blocks can parse correctly as long as the statement parser doesn't consume the "in"
19:56:41 <edwardk> so you get the benefits of the usual lexer hack without a lexer hack
19:57:12 <edwardk> it is a little more expensive than it should be, due to the way it has to be built with transformers
19:58:07 <luite> joe6: anyway you're interested in the $DOCFILE, the text hoogle index :)
19:58:16 <edwardk> i have a version of layout in scala that is more efficient because it can use a modified packrat parser (extending the notion of location with the current layout stack) to memoize the 'layout' parser that determines if layout yields whitespace, a virtual semi, virtual right brace or some other value
19:58:29 <edwardk> and how much text is consumed
19:59:16 <edwardk> so if you are silly and 'try' a lexeme parser a lot you might pay more than you should, but then hat is a pretty poorly factored grammar to begin with
20:01:47 <yshavit> kmc: not sure if you're still there, but I took another jab at my nodes example (from a few hours ago). I've got it down to two variations. One's a bit longer, the other has some redundancy:
20:01:53 <yshavit> http://hpaste.org/51446
20:02:24 <yshavit> basically my struggle is in concisely handling the root node, once I've defined how to handle its children
20:02:28 <edwardk> solidsnack: also LanguageDef is strictly optional. it just makes it take less boilerplate to define a parser type. you can always define your own monad like dylukes does in https://github.com/ekmett/STGMA/blob/master/src/Scan.hs#L28
20:02:54 <edwardk> but there he has to spend 40 lines setting up how he deals with whitespace and comments
20:03:38 <tgeeky> edwardk: by the way, the point of my task, is to allow the document itself how to deal with whitespace and comments
20:03:39 <NemesisD> hi all. im confused. Data.Time.Calendar Day clearly has an instance for read: http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Calendar.html#t:Day yet in ghci: read "2011-05-25" :: Day gives me no instance for (Read Day)
20:03:55 <mauke> NemesisD: you're probably missing an import
20:04:05 <tgeeky> edwardk: at least, that's the current idea.
20:04:11 <NemesisD> in ghci i did :m +Data.Time.Calendar
20:04:19 <edwardk> tgeeky: that is what mode lines are for ;)
20:05:02 <solidsnack> edwardk: This sort of thing seems to be a huge step in allowing people to mint little languages...
20:05:28 <solidsnack> ...but it may not actually make these little languages easier to deal with as a part of a larger system.
20:06:12 <yshavit> http://hpaste.org/51447 <- slight improvement over my previous one
20:06:27 <kmc> hi yshavit
20:06:29 <edwardk> solidsnack: well, my goal was to make it easier to generate a lot of the common tools, things like generating ctags, syntax highlighting, c preprocessing, getting nice diagnostics, etc.
20:06:31 <kmc> i'm still here :)  i'm always here
20:06:42 <yshavit> kmc: I figured if you weren't, you'd just ignore me ;)
20:06:55 <solidsnack> edwardk: Oh, really?
20:07:04 <solidsnack> Didn't see that part.
20:07:25 <edwardk> the c preprocessing is still in a test project, but it should be ported over soon when i find time
20:07:33 <joe6> https://github.com/ujihisa/neco-ghc anyone tried this?
20:07:35 <dibblego> hey edwardk, can partitionEithers be generalised on the binary functor?
20:08:36 <edwardk> partitionEithers :: [Either a b] -> ([a],[b]) ?
20:08:42 <dibblego> yes
20:08:53 <kmc> yshavit, did you try factoring out the "decide which nodes to throw out" from "traverse and throw out some nodes"?
20:09:11 <edwardk> it isn't a very nice operation
20:09:11 <solidsnack> It would seem though, that for mini-languages, generating code is as big a deal as parsing/writing it.
20:09:11 <edwardk> from a theory standpoint
20:09:14 <dibblego> heh, I agree
20:09:38 <yshavit> kmc: no, didn't try that. Is this a liftM thing?
20:09:44 <solidsnack> Like, you have a language for describing bread; you a web service that receives bread expressions and renders breads in flour.
20:10:17 <solidsnack> But, there is a need to generate the bread expressions from any of Ruby, PHP, C, Prolog...
20:10:22 <edwardk> solidsnack: well i have to set my scope somewhere. right now i'm limiting my purview to parsing and reporting problems with the code. code emission is another project ;)
20:10:28 <kmc> yshavit, well, it looks like you kind of did, in opt
20:10:30 <kmc> because you define this 'f'
20:10:34 <solidsnack> edwardk: Sure.
20:10:43 <solidsnack> Is it something you've thought about?
20:10:48 <kmc> but i'd try defining that f elsewhere and passing it as a parameter
20:10:55 <edwardk> dibblego: nah, doesn't really generalize in any meaningful way
20:11:02 <dibblego> yeah didn't think so, thanks
20:11:43 <solidsnack> I've sometimes thought, the thing to do is always have a fallback syntax that was YAML, so basic things -- like string-quoting -- were handled.
20:12:09 <edwardk> solidsnack: not really the kind of problem that makes me eager to get out of bed in the morning if you know what i mean ;)
20:12:14 <solidsnack> I see.
20:12:30 <yshavit> kmc: do you mean a fairly literal refactoring, just move the f definition to top-level and pass it in as an arg to opt? Or something fancier than that?
20:13:05 <edwardk> i am looking at adding some trifecta configuration stuff, for a while the config file was going to look fairly yaml'y, now its tending towards something more cabal.config like
20:13:49 <edwardk> but i wasn't really planning on dictating too much structure for the languages themselves. just giving tools for parsing
20:14:03 <edwardk> since most of the time you didn't design the language you are parsing. json, c, haskell, etc.
20:14:13 <yshavit> kmc: btw, about method names... I come from the Java world, where f would probably be nodeFilter, n would be nodeName, etc. The Real World Haskell book I got likes really short names like n, f -- is that the norm in Haskell?
20:15:21 <edwardk> yshavit: yes, we tend to name things with length proportional to their scope. if you use it locally over a couple of lines, calling something 'f' is fine. if you use it over a whole file, probably a word or two.
20:15:30 <kmc> yshavit, i dunno, move it out and then see if other stuff can be refactored around it
20:15:31 <edwardk> if you use it across an entire project, you may wax a bit more verbose
20:15:38 <kmc> the best name is no name
20:15:44 <yshavit> kmc: will do that, thanks
20:15:52 <yshavit> edwardk: that makes sense
20:16:01 <elliott> edwardk: btw, someone in another channel was switching parsec code over to trifecta, and gave up trying to change what Trifecta thinks the tab width is. how difficult would it be to make that configurable?
20:16:07 <edwardk> it tends to lead to a nice sense of 'location' in your code, and like kmc says, sometimes you can get away with naming things entirely -- by eta reduction or pointfree programming, etc.
20:16:08 <kmc> let keepAllElementsOfListWhichAreLessThanTwo = filter (<2)
20:16:15 <elliott> (specifically they wanted tabs to count as one column)
20:16:26 <elliott> they weren't using any of the layout stuff or anything so that's not important
20:16:30 <yshavit> kmc: refactoring it gives me another idea, I could probably generalize this pretty easily so it's not just on Node, but any tree-like class.
20:16:35 <kmc> class?
20:16:48 <edwardk> elliott: ouch. that one is pretty deeply embedded right now
20:16:48 <yshavit> kmc: class type?
20:16:52 <kmc> Haskell is fairly good at not requiring you to name things just for the hell of it
20:16:54 <Jafet> It may not be best to take inspiration from a language where people write things like AbstractSingletonFactory.
20:17:03 <elliott> edwardk: so he discovered when he reached Delta's monoid instance :)
20:17:04 <edwardk> i was meaning to make some stuff to configure tabstops
20:17:06 <yshavit> Jafet: ha, point taken :)
20:17:11 <solidsnack> edwardk: Well, I think the issue is not so much dictating the grammar of the source languages, as providing a way to derive a parser for a more easily generated form.
20:17:19 <edwardk> but then i'd have to make everyone pay for that functionality
20:17:26 <elliott> edwardk: The only thing I could think of to do it would be to add tab width to the Deltas themselves
20:17:29 <kmc> compare Java "Kingdom of Nouns"
20:17:33 <elliott> That's kind of awful, but low-impact
20:17:45 <kmc> yshavit, class type?
20:17:48 <edwardk> not really low-impact. because then you can't generate them locally
20:17:53 <Jafet> Actually, you can use short (locally scoped, following edwardk) names in most languages. Probably even java, if you try.
20:18:05 <elliott> edwardk: Implicit variables? :-P
20:18:09 <yshavit> Jafet, kmc, edwardk: I'm actually fine with short names, I just wanted to make sure it's not annoying to read for you guys ;)
20:18:19 <kmc> short names for small scopes is what i prefer
20:18:24 <edwardk> well, if i had to do it, i'd probably pick up a configuration parameter in delta
20:18:29 <edwardk> i'm planning on adding one anyways
20:18:35 <yshavit> kmc: sigh, I keep getting this phrase wrong. The interface type thingie, let me look it up
20:18:35 <kmc> yshavit, are you picturing a type class for tree-like data structures? a new type class you'd invent?
20:18:35 <elliott> edwardk: hmm, isn't this what Oleg's... what was it, configuration stuff is meant to be?
20:18:37 <edwardk> so it could tell you what your tabstops are, etc.
20:18:44 <yshavit> kmc: yes
20:18:45 <elliott> not configuration...
20:18:47 <elliott> I forget the name :)
20:18:52 <edwardk> elliott: yes and i use reflection fairly heavily
20:19:00 <elliott> yeah, reflection, that's the one
20:19:07 <kmc> yshavit, beginners to Haskell have a strong tendency to over-use type classes, and to define lots of new types and type classes
20:19:19 <edwardk> i already need to extend delta with a user provided monoid
20:19:24 <yshavit> kmc: we're polymorphism junkies
20:19:26 <edwardk> because i need it for my c preprocessor
20:19:33 <edwardk> andfor my dyck language skeleton code
20:19:36 <kmc> yshavit, but type classes aren't the king of polymorphism in Haskell
20:19:40 <elliott> heh, he was writing a C parser
20:19:42 <edwardk> both need user state associated with the current rope
20:20:34 <kmc> yshavit, I think it goes double for people who are coming from Java... because Java requires you to invent a new type for every new behavior.  but in Haskell behaviors (i.e. functions or IO actions) are first-class values, and you can pass them to ordinary functions and store them in ordinary data structures
20:20:35 <yshavit> kmc: so, how's this for a thought? I generalize opt such that it takes (Node -> [Node]) -> (Node -> Bool).
20:20:36 <edwardk> well the intention is that the c preprocessor will come with trifecta, so you can just take some parser stack and apply a CPP parser transformer to it
20:20:37 <elliott> apparently he also had a bit of a pain parsing from a bytestring... I think he just ripped out the parse-from-file functions and modified them at the end of it all
20:20:50 <edwardk> and it'll automatically start reporting errors inside of macro expansions
20:21:00 <elliott> heh, cool
20:21:02 <yshavit> kmc: that way, you get to define (a) what's an interesting node and (b) how to navigate the tree, and I take care of the rest. Is this getting to be more Haskelly?
20:21:08 <elliott> dunno if that'll work for him, he has some pretty special requirements
20:21:11 <Jafet> I sometimes feel that functions are still first-and-a-half-class, because you can't deconstruct them in any way
20:21:13 <kmc> yshavit, yes, I think so
20:21:19 <elliott> Jafet: You can apply them.
20:21:20 <yshavit> kmc: I feel like Neo.
20:21:22 <edwardk> well, he's welcome to talk to me
20:21:40 <elliott> edwardk: I told him to, but you were offline, and now you're online and he's not :-P
20:21:43 <kmc> yshavit, people say that type classes are like Java's interfaces, but I much prefer (when possible) the style where interfaces are described by data types, and different implementations are just different values of that type
20:22:01 <monochrom> you can call it an abstract data type if you can't deconstruct it. that's cool, abstract data types can still be first-class
20:22:03 <edwardk> the problem with changing the tab stops is i actually space them back out when rendering the line
20:22:10 <kmc> yshavit, and now all kinds of generic configurable proxy adaptor factory mumbo can be implemented with simple ordinary functions
20:22:14 <kmc> and no type classes in sight
20:22:23 <elliott> edwardk: yeah, I don't think that matters for him
20:22:24 <edwardk> so it would also infect Rendering
20:22:27 <elliott> edwardk: although you could just leave them as \t
20:22:31 <elliott> and let the terminal deal with them
20:22:32 <yshavit> kmc: it took me a bit to do the mental switch, but once I got it, I think I like Haskell's way a lot.
20:22:35 <edwardk> doesn't work
20:22:39 <elliott> why not?
20:22:47 <edwardk> because i can render the 'middle' of a line
20:22:50 <elliott> ah
20:23:05 <edwardk> if your terminal is narrower than the line width i 'focus' the error message so that the cursor stays in focus
20:23:23 <yshavit> kmc: actually, overall my impression of Haskell is very positive so far! I looked at a couple other functional or functional-and-OO languages that didn't rub me quite the right way
20:23:27 <kmc> yshavit, yeah, it definitely takes getting used to
20:23:31 <edwardk> and put <  >'s and the beginning or end of the line to show it overflowed or underflowed in either direction
20:23:56 <edwardk> the carets, spans and fixits float accordingly
20:24:05 <elliott> edwardk: I wonder if a C preprocessor transformer might not belong in a separate model... but that's probably just me thinking of how long the module list is now :-P
20:24:12 <kmc> yshavit, yes, I like Haskell not because it's functional but because it's good
20:24:19 * monochrom is glad he did not grow up in OO
20:24:22 <edwardk> elliott: it hooks into delta pretty deeply
20:24:27 <kmc> which includes getting lots of small things right
20:24:34 <yshavit> kmc: yeah
20:24:39 <elliott> edwardk: hmm, really? why?
20:24:56 <yshavit> kmc: so, for my more generic opt, I'm still "allowed" to use paramterized types, right?
20:24:59 <edwardk> because i need to replace the current 'single file' with an actual stack of files for #include's and #line directive purposes.
20:25:02 <yshavit> kmc: as in, it wouldn't be boneheaded?
20:25:04 <elliott> heht
20:25:06 <elliott> heh
20:25:11 <kmc> i don't think it would be
20:25:14 <elliott> that sounds pretty general-use, really
20:25:15 <kmc> but where do you think it would fit in?
20:25:18 <shirt> @pl (\x -> case foo x of { Nothing -> Nothing; Just y -> Just (bar y)})
20:25:19 <lambdabot> (line 1, column 22):
20:25:19 <lambdabot> unexpected "{"
20:25:19 <lambdabot> expecting variable, "(", operator or ")"
20:25:19 <elliott> in that any preprocessor would want to do that
20:25:24 <edwardk> and to make it monoidal it also incurs 'stack debt'
20:25:33 <edwardk> so i have 'negative includes' in the monoid
20:25:41 <yshavit> kmc: speficially, I'm thinking opt a :: (a -> [a]) -> (a -> Bool) -> a -> Maybe a
20:25:42 <monochrom>  @pl does not know about case
20:25:46 <edwardk> and knowledge of what macros are being expanded
20:25:55 <edwardk> (including 'negative macros')
20:25:56 <kmc> yshavit, ah, yeah, that might work
20:26:14 <monochrom> what is negative macro?!
20:26:17 <yshavit> kmc: cool, let me give this a spin
20:26:47 <edwardk> e.g. the delta from somewhere in the middle of a macro expansion to somewhere just after it would include the stack effect of ending the macro in the delta
20:26:47 <kmc> yshavit, a hidden benefit of polymorphism is that it restricts which things the function can observe, which means there's a lot more you can say about the function just from its type signature
20:26:51 <kmc> "parametricity"
20:27:06 <yshavit> kmc: I've noticed that!
20:27:22 <edwardk> monochrom: lets think about this differently. a monoid for dyck languages
20:27:29 <shirt> @pl (foo >>= return . (liftM bar))
20:27:30 <lambdabot> fmap bar `fmap` foo
20:27:40 <edwardk> monochrom: what i want is a monoid that represents parsing balances parentheses
20:27:42 <kmc> almost every other language loses this because they have some run-time cast operator where you can ask "is that 'a' really an Int"
20:27:55 <yshavit> kmc: it's really neat that I can just :browse Data.Maybe, and most methods are pretty self-explanatory. [Maybe a] -> [a] can really on do one reasonable thing
20:28:06 <edwardk> it turns out i can represent that monoid as a pair of numbers.
20:28:20 <kmc> Haskell has that cast, too, but its use gives rise to a type-class constraint, so is still evident from the type
20:28:23 <edwardk> ))(((  is represented by 2 3
20:28:31 <kmc> yshavit, yeah
20:28:53 <edwardk> we cancel matching parens ))((( + )) = ))(
20:29:03 <edwardk> so far so good?
20:29:20 <edwardk> you have a number of unmatched 'closing contexts' followed by a number of unmatched 'opening contexts'
20:29:49 <edwardk> now it is pretty easy to show that you can glue together these values associatively and that there is a unit (0,0)
20:30:26 <edwardk> when we view #include directives in c preprocessing you get a similar set of matched opening and closing contexts. entering a file, and returning from a file
20:30:53 <edwardk> you get #line directives that look like: # "foo" 12 0 1 2   out of ghc
20:31:36 <edwardk> saying you are entering or exiting file foo and your new line number is 2, and a few numbers that some times get used for flags to indicate whether it is a system header and if it is from you entering, returning, etc.
20:31:42 <NemesisD> do you guys know of any tools for generating application templates? i tend to write a lot of JSON web api libraries and they are all designed pretty much the same for the most part
20:32:05 <edwardk> i need to match those up, but because it is a monoid i may parse a closing context for something i haven't entered yet.
20:32:34 <monochrom> someone asked in comp.lang.haskell "can (a,b)->a return a different value from the 1st component?" I used parametricity to answer no, it has to be the same value from the 1st component or it has to die. http://groups.google.com/group/comp.lang.haskell/msg/a1444af2476a6a53
20:32:55 <edwardk> i may also wind up with closing contexts where the delta includes returning from a macro
20:33:40 <solidsnack> NemesisD: Snap has an app template system. http://snapframework.com/docs/quickstart Not sure how much that will actually do for you, though.
20:33:52 <edwardk> monochrom: did that help?
20:35:25 <solidsnack> NemesisD: In something like WAI/Yesod, you could reify the pattern and create "apps" as Haskell values and then mount them in the server.
20:35:36 <edwardk> elliott: if i can get away with it i'll try to make it so i can extend Delta cleanly with the extra information or make it so I build a rendering with a more general mark type, then i could put the c preprocessor in another package, but i'm not in a hurry to make development more difficult by splitting everything in trifecta up
20:35:49 <elliott> edwardk: yeah
20:36:38 <edwardk> i still don't understand why your friend needs one column tabstops though ;)
20:37:12 <elliott> edwardk: well, you'd have to ask :) but I think it's because he doesn't use eight-column tabstops but has an editor that makes jumping to a codepoint offset easy :-P
20:38:22 <edwardk> but even so, he could largely ignore the column information i give, i have a column byte in delta as well that provides the offset from the beginning of line in bytes
20:38:48 <edwardk> if he doesn't care about the rendering of the source line then he can just use that if he must
20:39:05 <edwardk> (assuming he doesn't care about utf-8)
20:39:22 <elliott> hmm, maybe he missed it :) I think he wanted to keep the usual diagnostics, though, just changing the column... but I don't think it's a huge deal, I mean he just gave up in the end :P
20:39:41 <edwardk> -P
20:39:44 <edwardk> =P
20:41:59 <edwardk> on a completely unrelated note i'm trying to figure out a nice way to generate elastic tabstops in a pretty printer
20:44:22 <Nafai> I'm trying to move into a library some stuff I had part of another function and in a where clause in my xmonad.hs, but I can't seem to get the types right:
20:44:30 <Nafai> https://gist.github.com/1223626
20:46:23 <monochrom> i wonder if you would like (property =? value --> action) instead of [...]
20:46:42 <monochrom> and then of course the ( ) is redundant
20:47:33 <Nafai> *nods*
20:47:51 <Nafai> Well, this is where I started from (which currently works): https://github.com/Nafai77/config/blob/master/HOME/_xmonad/xmonad.hs#L182
20:50:23 <monochrom> the original code has a concat to cancel the extra []s
20:50:36 <monochrom> > concat [ [1], [2], [3] ]
20:50:37 <lambdabot>   [1,2,3]
20:50:41 <Nafai> right
20:51:05 <monochrom> is a clumsy way to write [1,2,3] especially if you're hardcoding it
20:51:32 <monochrom> > concat [ [x] | x<-[1..10] ]
20:51:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:51:40 <monochrom> is a clumsy way to write
20:51:48 <monochrom> > [ x | x<-[1..10] ]
20:51:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:51:54 * Nafai nods
20:51:58 <elliott> is a clumsy way to write
20:52:00 <elliott> > [1..10]
20:52:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:52:16 <Nafai> I was doing it this way because I was just replacing the list comprehension with the function call
20:52:21 <Nafai> but I'm definitely open to better style
20:52:23 <monochrom> well yeah but a better example is [f x | x<-[1..10]]
20:52:30 <Jafet> > let (..) = enumFromTo in 1 .. 10
20:52:32 <lambdabot>   <no location info>: parse error on input `..'
20:52:36 <elliott> map f [1..10]... I'm just being difficult :-P
20:52:36 <edwardk> elliott: trying to figure out how i can make a modeline parser transformer for reading vim and emacs mode lines and adjusting tabstops, etc. appropriately
20:52:46 <elliott> edwardk: haha, awesome
20:53:12 <Jafet> > let (…) = enumFromTo in 1…10
20:53:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
20:53:18 <kmc> nice!
20:53:19 <edwardk> worst case i can just write a parser that skims for them
20:53:39 <edwardk> then run it on the rope before feeding it to the user parser
20:53:41 <kmc> then [1…10] is... not exactly intuitive
20:54:36 <Jafet> [_.._]
20:54:52 * Jafet doesn't know if that's valid
20:55:05 <monochrom> well, when you refactor code, you will certainly run into redundancies like this, and you have to decide whether to carry over the same redundancy with much effort or simplify it with ease
20:55:21 <Nafai> I'm all for simplification
20:55:23 <Nafai> :)
20:56:18 <monochrom> to carry over the redundancy, you have to genPropertyManageHooks :: [PropertyManageHookInfo] -> [[ManageHook]], and then test :: [[ManageHook]], test = genPropertyManageHooks infos, or something
20:56:50 <Nafai> wow, indeed
20:57:18 <Nafai> is there a better idiom to use than a list comprehension to take it down to just [ManageHook]?
20:58:13 <monochrom> [property =? value --> action | (property, action, values) <- propertyHookInfo, value <- values] is just fine and type is just [ManageHook]
21:02:07 <Nafai> thanks for the help
21:02:32 <Nafai> trying to get back into the Haskell mindset
21:02:35 <monochrom> you're welcome
21:05:50 <yshavit> kmc: I think I've got it now. :) http://hpaste.org/51448
21:05:56 <yshavit> opt :: (a -> [a]) -> (a -> [a] -> a) -> (a -> Bool) -> a -> Maybe a
21:06:54 <yshavit> (node -> children) -> (node, newChildren -> newNode) -> (isNodeInteresting) -> Node -> Maybe Node
21:18:56 <yshavit> and now with type classes as a helper: http://hpaste.org/51450  The hpaste page says there's an eta reduce, what's that? gchi and gch don't complain about it
21:22:16 <yshavit> Oh, I think I see! The offending line is "createNew (Node n b _) cs = Node n b cs", and I think the compiler is trying to remind me that I can trim off the "cs" from both sides, and in partially-applied land it's the same thing
21:22:47 <kmc> yshavit, ah, yeah, the thing under it is a HLint suggestion
21:22:52 <kmc> btw you can run hlint on your own machine if you like
21:23:21 <yshavit> kmc: neat, thanks
21:24:44 <yshavit> kmc: This toy app has come quite a way from its first inception. :) Hopefully it's becoming less "Java guy writing Haskell" and more "reasonable Haskell code"
21:25:48 <kmc> cool :)
21:25:51 <kmc> it looks pretty good
21:26:04 <kmc> i'm not sold on the type class being useful, but i'm not convinced that it's *not* useful, either
21:26:07 <yshavit> kmc: thanks, and thanks for pointing me in the right directions
21:26:55 <yshavit> kmc: yeah, I can see that point.  I don't have enough Haskell experience yet to know that is is useful, but partially I just wanted to confirm that I understood how to do it
21:27:34 <kmc> yeah
21:27:40 <kmc> it's good to explore the design space
21:27:43 <yshavit> kmc: is this an idiom that happens in real code? That is, you have a generic function, and then a variant of it which takes advantage of a type class?
21:27:57 <yshavit> kmc: sounds like you're saying no, but I just want to make sure
21:28:21 <kmc> yshavit, it sounds like e.g. Data.List.sort vs Data.List.sortBy
21:28:27 <kmc> so yeah, it's common
21:28:47 <kmc> in some sense, type classes are just syntactic sugar for implicit function parameters
21:29:11 <kmc> you can imagine that every function with an "(OptTree a) =>" constraint instead gets a tuple of type (a -> [a], a -> [a] -> a, a -> Bool) as an extra argument
21:29:28 <kmc> in fact that's very close to how GHC implements type classes
21:30:28 <yshavit> kmc: right, that makes sense.
21:30:58 <yshavit> kmc: And last question (I promise!), is the createNew concept reasonable? I think most implementations would be about the same, which is "copy most of the a, except for its children, which I'll provide."  Something about that seems... off... to me.
21:32:49 <kmc> hmm
21:32:55 <kmc> it seems fairly reasonable
21:33:07 <kmc> you're trying to make this very generic and polymorphic
21:33:21 <kmc> that usually results in a few weird things
21:33:23 <yshavit> kmc: right, and I recognize it's probably overkill -- as you said, just exploring the space
21:33:31 <kmc> it's a tough call whether it's worth it or not in any particular situtaion
21:33:35 <kmc> but this doesn't seem egregious
21:33:49 <kmc> look at "Scrap your Boilerplate" for an example of rather insane things being done in the name of generic traversal
21:34:31 <yshavit> is that in Real World Java? The name rings a bell from the TOC
21:35:06 <yshavit> kmc: It could be I'm just stuck in the mindset of mutable structures, where I want to say "just remove the unneeded elements" rather than "create a fresh copy of yourself, this time without unneeded elements"
21:38:14 <kmc> yshavit, SYB is a series of Haskell papers, and a Haskell library
21:38:33 <yshavit> kmc: oh, okay. That may be for another day then...
21:38:36 <kmc> "boilerplate" is a generic (pun intended) term for boring, repetitive code that could be machine-generated
21:39:28 <yshavit> kmc: I know what boilerplate is, I just didn't know if you were referring to a specific chapter in RWH. I'm pretty sure there's a chapter there with that name, close if not exactly
21:42:13 <Jafet> Real World Java? How quaint
21:42:48 <yshavit> Jafet: oh, ha, I must be getting tired. I meant Real World Haskell. :)
21:43:57 <kmc> that reminds me of http://i.imgur.com/iPhtB.jpg
21:44:34 <dankna> haha
21:44:34 <dankna> nice
21:44:42 <yshavit> kmc, Jafet : Watch it now, I still code Java for my day job. ;)
21:45:06 <Jafet> http://nerdnirvana.org/wp-content/uploads/2009/09/javascript-500x375.jpg
21:45:29 <Jafet> What animal is on that java book
21:46:01 <dankna> I have a picture of a (real, not drawn) cat sleeping on top of a book called "Animals in Motion".  apropos to silly pictures of books.
21:46:02 <yshavit> Jafet: I don't see any Java books there.
21:46:03 <Jafet> Looks like a squirrel with a nut.
21:46:17 <shachaf> Are you people implying that a "Haskell: The Good Parts" book would be thicker than a definitive guide, or something?
21:46:20 <napping> yshavit: "quaint" sounds fair enough - surely nobody has been surprised in a long time that Java can be used in the "Real World"
21:46:44 <napping> though I seem to recall some griping about garbage collection and bytecodes when it was newish
21:46:53 <shachaf> "The Java Road to Logic, Maths, and Programming"
21:47:15 <Jafet> kmc: to be fair, the lower book is "9 BOOKS IN 1"
21:47:29 <shachaf> napping: Well, everyone knows that garbage collection is impractical for real-world use.
21:47:44 <yshavit> napping: yeah, I'm taking this all as good-natured ribbing. Speaking of all this, I should google to see if there's a JVM Haskell impl
21:48:13 <yshavit> Haskell's GC is another thing I've been wondering about, but that can wait
21:48:22 <kmc> shachaf, "you people"
21:48:27 <napping> I don't think there's too much interesting in the GC
21:48:30 <kmc> yshavit, Haskell does not specify much about GC
21:48:33 <elliott> yshavit: no, there isn't (yes, there is, but it's dormant and unmaintained (you might be interested in Frege though))
21:48:34 <kmc> GHC has a pretty fancy one, though
21:48:35 <elliott> re JVM
21:49:02 <yshavit> elliott: that's too bad (maybe? I don't actually know that it is :)  )
21:49:24 <elliott> yshavit: it's a jvm language that's been on /r/haskell recently that's similar to haskell but has a few arbitrary changes for no apparent reason :P
21:49:32 <kmc> yshavit, the Haskell standard has very little to say about operational details like garbage collection.  it doesn't even mandate lazy evaluation
21:49:43 <elliott> ISTR that there are several major obstacles to bringing a lazy language like Haskell to the JVM efficiently, though
21:49:46 <yshavit> kmc: I'd be curious to know what sorts of analysis is generally done to say that Foo can stay on the stack, Bar needs to go in the heap and be GCed, etc
21:49:54 <kmc> the behavior from GHC which people rely on in order to produce efficient code is a good deal more specific then what's in the Report
21:49:56 <elliott> so you might just want to stop wanting a JVM implementation :)
21:50:01 <kmc> yshavit, ah, effectively everything goes on the heap
21:50:04 <elliott> yshavit: everything is on the heap
21:50:06 <kmc> yshavit, but heap allocation is much much cheaper than C malloc
21:50:16 <kmc> in fact, the heap looks like a stack.  to allocate you simply increment a pointer
21:50:26 <kmc> the difference is that memory is reclaimed by garbage collection, instead of by popping stack frames
21:50:41 <shachaf> Increment? Sacrilege!
21:50:42 <yshavit> hm. I would think there's a lot of stuff you could put on a stack and pop
21:50:46 <kmc> GHC also has a stack but it's not a function call stack;  it's a stack of nested thunk-forcings, a stack of nested pattern-matchings
21:51:23 <kmc> (and it has a function-call stack if you turn on profiling)
21:51:37 <elliott> shachaf: To allocate, you simply add to a pointer, then forget about the old one?
21:51:38 <napping> GHC is reasonably good about unboxing integers and the like - local values go on the stack, it's just that lots of those are pointers to heap-allocated thunks
21:51:52 <elliott> yshavit: if heap allocation is ~as efficient as stack allocation, why bother?
21:51:57 <elliott> yshavit: also, you'd have to do unboxing for that to help at all
21:52:08 <shachaf> elliott: I meant increment as opposed to decrement.
21:52:09 <napping> More to the point, I don't know of any pathologies with the GC that make you have to avoid otherwise perfectly reasonable looking code
21:52:10 <elliott> e.g. put an Int on the stack, you gain nothing, since the integer value inside is boxed
21:52:12 <kmc> individual heap allocations are as cheap as stack allocation, but then you pay for it in GC
21:52:19 <elliott> you still have to dereference the heap pointer inside
21:52:49 <yshavit> elliott: heap allocation, sure, but then you're also stressing the GC that much more, whereas popping a stack frame is easy. But I'm sure smarter compiler writers than I have figured out this stuff :)
21:53:14 <kmc> anrd yeah, it's a squirrel
21:53:21 <yshavit> I mean, in Java, you try to avoid Integer and work with int as much as possible (e.g.), since that way you avoid the heap/GC
21:53:40 <kmc> yshavit, sounds like Java is failing to abstract that away
21:53:43 <kmc> failing to be a high-level language
21:53:45 <napping> I thought the JVM was getting pretty good about escape analysis and stuff
21:54:05 <elliott> yshavit: That sounds like superstition to me.
21:54:14 <elliott> Well, so do most things Java programmers do.
21:54:24 <yshavit> elliott: could be! it once was true, don't know that it still is (or how much)
21:54:27 <kmc> yshavit, GHC Haskell has a similar distinction between boxed and unboxed integers, but we mostly ignore it, and let GHC unbox things automatically
21:54:48 <napping> Integer sounds like the sort of thing that should be automatically stack allocated and scalarized
21:54:51 <kmc> yshavit, unboxed integers are not first-class values -- you can't use them in polymorphic containers, for example.  which is true in Java as well
21:54:55 <yshavit> kmc: I'm not saying Java's right in this, and I agree it's nice for a language to handle it for us.
21:55:05 <kmc> though Java 1.5+ hides that fact somewhat
21:55:28 <napping> yshavit: I'm saying if you use Integer in your java program, and it doesn't escape the method, I'd expect it to turn into a single primitive integer on the stack anyway
21:55:30 <yshavit> I guess I don't know enough yet about Haskell's boxing/unboxing
21:56:02 <elliott> yshavit: Everything is boxed, unless you append a # to it and import a scarily-named non-portable module, or use {-# UNPACK #-} in an ADT declaration.
21:56:12 <yshavit> napping: they can probably do that, sure. But most of the time if you're using an Integer it's so you can use it outside of the method, e.g. to pass to a collection.
21:56:13 <elliott> And you don't want to do either of those unless you've profiled and it helps.
21:56:15 <napping> not to say I've actually looked at the jitted code (or even know how to get ahold of the generated instructions)
21:56:16 <elliott> A lot.
21:56:23 <elliott> After trying everything else that isn't micro-optimisations.
21:56:25 <Jafet> Boxing is a GHC detail; lifting is more relevant to the value semantics
21:56:26 <yshavit> elliott: oh, interesting
21:56:40 <elliott> (That #-appending only works for Int and Word types.)
21:56:47 <elliott> (Also it requires a language extension in addition to the GHC module.)
21:56:49 <kmc> yshavit, Haskell does not say anything about boxing / unboxing.  it's a GHC implementation detail, and the fact that you can observe it at all or use unboxed values is a GHC extension to the language
21:57:01 <elliott> Can we just call it GHCskell?
21:57:02 <yshavit> napping: also, any boxed value can be null, and primitives can't -- so there's a functional difference, and they'd have to ensure that you don't use it if they wanted to unbox for you
21:57:04 <elliott> It would be so much simpler.
21:57:07 <Jafet> elliott: not really true
21:57:14 <kmc> elliott, sure, I say "GHC Haskell" but whatever floats your boat
21:57:23 <elliott> Jafet: Yeah, OK, stuff can be unboxed if GHC thinks it's a good idea.
21:57:26 <Jafet> RealWorld#, Addr#, Char#, I#
21:57:29 <elliott> I don't see that happening much though. Or what were you going to say?
21:57:31 <elliott> Oh.
21:57:37 <elliott> Hmm, what's I#?
21:57:37 <kmc> i see your I# and raise you a J#
21:57:40 <kmc> @src Int
21:57:40 <lambdabot> data Int = I# Int#
21:57:46 <elliott> Oh. I thought you were mentioning it as a type.
21:57:50 <kmc> also there's no RealWorld#
21:57:54 <yshavit> And I recognize that boxing is an implementation detail, but that implementation is what I was curious about wrt heap/stack/GC
21:58:00 <elliott> There's State#.
21:58:01 <kmc> it's (State# RealWorld) and RealWorld is instantiating a phantom type parameter
21:58:08 <yshavit> I'm not curious because I think it's wrong, just because I'm curious. :)
21:58:10 <kmc> yshavit, ah, I'm just emphasizing the distinction between Haskell and GHC
21:58:28 <yshavit> kmc: got it
21:59:06 <kmc> does that phantom type parameter provide anything other than a little protection against mistakes made by GHC developers?
21:59:22 <Jafet> It lets you write PrimState, doesn't it
21:59:29 <Jafet> PrimState IO ~ RealWorld
21:59:37 <elliott> I've always wondered why IO isn't simply defined as "data IO a = IO a".
21:59:39 <napping> kmc: State# is also used for ST
21:59:45 <elliott> I mean, you can do all the necessary pseqs in (>>=) and the like.
21:59:55 <napping> ST s a = State# s a, I think
21:59:55 <elliott> Why have that unboxed tuple and the eliminated-at-runtime world type?
22:00:10 <elliott> napping: State# s -> (# State# s a, a #), I expect.
22:00:14 <elliott> s/s a/s/
22:00:16 <elliott> Or is the a first?
22:00:16 <kmc> elliott, probably to inhibit some optimizations
22:00:31 <elliott> kmc: Gross :(
22:00:38 <kmc> i don't know
22:00:40 <dolio> State# is probably guaranteed to be compiled to a 0-bit value.
22:00:44 <kmc> it is
22:00:53 <dolio> Which s is not.
22:00:59 <dolio> In the case of ST.
22:01:18 <kmc> napping, sure, State# is used for ST, but why couldn't you say «newtype ST s a = ST (State# -> (# State#, a #))»
22:01:26 <kmc> i.e. making it phantom of ST rather than phantom of State#
22:01:45 <kmc> my understanding is that you *could*, and tagging State# just provides a bit more sanity checking inside ST / IO implementation guts
22:01:50 <kmc> i was wondering if there's another reason
22:02:21 <napping> I haven't tried to mess with that, but I'd worry about the optimizer confusing different State# from different threads once you opened that up
22:02:30 <napping> data dependencies should sort it out, I suppose
22:02:32 <dolio> If you do that then access to the ST constructor is unsafe.
22:03:43 <napping> yshavit: you can find most things described in Peyton-Jones' papers at research.microsoft.com/~simonpj
22:04:07 <yshavit> napping: cool, I'll bookmark that. Thanks!
22:05:19 <napping> There's quite a lot to just browse through, so ask for pointers
22:05:28 <tkahn6> hey guys is it just me or are the data accessors for the data types in the Pcap library on hackage unaccessible?
22:05:31 <napping> looks like there's a recent paper on the GC, for example
22:05:51 <kmc> i'm excited for independent per-core minor GC
22:05:56 <kmc> i hope that's in mainline GHC soon
22:06:01 <tkahn6> when i go to compile the example on http://hackage.haskell.org/packages/archive/pcap/0.2/doc/html/Network-Pcap.html
22:06:15 <tkahn6> it says `caplen` is not in scope
22:06:33 <tkahn6> which is an accessor for PktHdr
22:07:03 <tkahn6> forgive me if that's not the correct term for that
22:07:18 <elliott> Well, you can just extract it with (PktHdr sec usec caplen len).
22:07:28 <tkahn6> yeah
22:07:36 <elliott> Though that's documentation from an old version of the package.
22:07:40 <elliott> Try http://hackage.haskell.org/packages/archive/pcap/0.4.5.1/doc/html/Network-Pcap.html.
22:07:44 <tkahn6> ohhh damn
22:07:55 <tkahn6> thanks! i did have to add the Network qualifier in the beginning
22:07:55 <elliott> hdrCaptureLength is the name for it in the latest version, looks like.
22:07:58 <tkahn6> :)
22:08:00 <tkahn6> thank you
22:08:31 <Jafet> "NOTE: The IO representation is deeply wired in to various parts of the system."
22:08:39 <napping> yshavit: "Haskell on a Shared-Memory Multiprocessor" is probably the best single paper about the runtime, though bits are getting out of date
22:08:40 <Jafet> That might be another reason to not change stuff
22:09:07 <yshavit> napping: cool, thanks.
22:09:34 <yshavit> hmm, /me thinks his toy app is getting monadic maybe?
22:10:48 <napping> I guess the old "Unboxed values as first class citizens" might still be the overview of unboxed values
22:11:37 <edwardk> another really good one is rob ennals' phd dissertation on speculative parallelism because it spends so much time talking about the structures used to evaluate the spineless tagless g-machine via c--
22:12:00 <edwardk> er sorry
22:12:07 <edwardk> s/speculative parallelism/optimistic evaluation
22:12:18 <cwl> @src foldl1
22:12:36 <cwl> :t "123"
22:12:41 <lambdabot> foldl1 f (x:xs) = foldl f x xs
22:12:43 <lambdabot> foldl1 _ []     = undefined
22:12:47 <lambdabot> [Char]
22:14:41 <yshavit> alright, well I'd better get to bed.  Good night, everyone!
22:14:53 <yshavit> Thanks for being so welcoming :) I'll be back
22:17:29 <applicative> what makes a man hackage the first 1001 fibonacci numbers? http://hackage.haskell.org/package/gutenberg-fibonaccis-1.0.0
22:19:09 * applicative plans his gutenberg-fibonacci-extras with fib 1001 through fib 2000
22:19:45 * kmc uploads a GPL-licensed replacement
22:20:07 <napping> Does not appear to be historical interest
22:20:08 <edwardk> =)
22:20:37 <Jafet> What makes Project Gutenberg list them?
22:21:12 <edwardk> kmc: oh noes. but we have commercial extensions that have already extended it well beyond 5000 fibs. how can we compete with your openness?
22:22:05 <napping> maybe a list of *all* fibonacci numbers?
22:22:23 <edwardk> brilliant
22:23:03 <ketil> I'm having some trouble building my program, it complains about no applicative instance for "Either String".  This works elsewhere, so there's apparently some incompatibility in a library somewhere.  Anybody know the details?
22:23:51 <shachaf> ketil: Hmm, it seems to be defined in Control.APplicative.
22:24:13 <edwardk> > let fibs :: [Integer]; fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
22:24:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:24:14 <napping> not in 6.12, though
22:24:23 <edwardk> fear my leet open source skills
22:24:41 <jgroszko> oh boo, (read ".1")::Float no worky :(
22:24:44 <ketil> shachaf, not here?
22:24:53 <shachaf> ketil: What version of GHC and/or base?
22:25:15 <ketil> 6.12.3 (default Ubuntu 11.04)
22:25:19 <napping> jgroszko: yeah, it must be "0.1
22:25:57 <elliott> applicative: they're more reliable
22:26:02 <elliott> You can't trust those on-the-fly fibonacci generators.
22:26:19 <jgroszko> napping: know of any quick way to make it more forgiving? :/
22:26:25 <elliott> ketil: Control.Monad.Instances might help; if not, you can define your own quite easily.
22:26:26 <edwardk> ketil: check Control.Monad.Instances
22:26:32 <napping> jgroszko: prepend a 0?
22:26:48 <elliott> {- |The fibsLen function returns the number of Fibonacci numbers
22:26:48 <elliott>  - |in the first1001Fibs list.
22:26:48 <elliott> -}
22:26:53 <napping> of course, that wont work if you have a -
22:26:56 <jgroszko> napping: well, could also be -.1
22:26:58 <elliott> What a thoroughly useful integer.
22:27:09 <ketil> I used to define my own instance, but got a complaint, and removed it.  And now it fails to build elsewhere, so I need to limit the versions.  But of which package?
22:27:21 <elliott> ketil: What you want to do is upgrade GHC. :p
22:27:36 <elliott> You'll probably have to restrict yourself to an older base, if you don't want to join this century.
22:28:13 <ketil> elliott, Yes, I know. But it's difficult enough to have to tell users to apt-get and compile stuff.  Compiling a compiler is one bridge too far, I fear.
22:28:40 <elliott> ketil: You could use the CPP language extension and check the GHC version; if it's below whatever, define your own instance.
22:28:58 <elliott> I'd just forget about users. What is a user, anyway? A user is a producer of bug reports, and I hate bug reports.
22:29:29 <ketil> elliott, of course, or use cabal flags or something.  But the question is what the 'whatever' should be.
22:29:30 <ketil> :-)
22:29:37 <elliott> ketil: Probably seven.
22:34:48 <ketil> Funny, it /is/ defined in Control.Applicative.  It isn't listed as an instance, but I can <$> on Either values.  Is that part of the "WrappedMonad" instance, I wonder?
22:35:46 <ketil> Is there a changelog for 'base', or some other way to check which version this was changed?
22:38:06 <cwl> question about match
22:38:20 <cwl> data Type1 = ...
22:38:24 <cwl> data Type2 = ..
22:38:36 <cwl> instance Show Type1 ..
22:38:41 <cwl> instance Show Type2 ..
22:38:44 <ketil> Okay, it's "fixed", but how can I find out *when*?  http://hackage.haskell.org/trac/ghc/ticket/4095
22:38:58 <cwl> display :: (Show a) => a -> String
22:39:05 <cwl> display (Type1 a) = ..
22:39:07 <napping> ketil: well, the GHC download page for each old version includes links to the docs. Not a great way to check...
22:39:11 <cwl> display (Type2 a) = ...
22:39:17 <kmc> cwl, can't
22:39:18 <shachaf> cwl: No, you can't do that.
22:39:26 <kmc> cwl, also, use hpaste for longer than a few lines
22:39:26 <shachaf> cwl: For one, Type1 is a type, not a value.
22:39:28 <cwl> is wrong, ghci complains Type2 dont match Type1
22:39:44 <applicative> you want another class Displayable maybe?  Not that one should add classes much
22:39:45 <shachaf> Also, when you have a Show constraint, you *can't* know what type you're getting.
22:39:51 <shachaf> You can only perform type class operations on it.
22:40:26 <cwl> I want function display to accept different type by pattern matching
22:40:41 <cwl> Type1 Type2 are also type constructor
22:41:15 <applicative> cwl, fine you can make a class Displayable a where display :: a -> String
22:41:38 <applicative> instance Displayable Type1 where display (Type1 x) = foo x
22:41:58 <cwl> applicative: If I want a function to accept different type, I must make the function a function of some class?
22:41:58 <applicative> instance Displayable Type2 where display (Type2 x) = bar x
22:42:09 <napping> cwl: you might also consider making a new type, like data Tagged = TaggedType1 Type1 | TaggedType2 Type2
22:42:22 <applicative> if you put it in those terms, yes.  but there are other plans, as napping is noting
22:42:46 <cwl> napping: It is a type with different constructors
22:43:04 <applicative> napping, if you know there is a restricted range of things you want displayed, not an open ended heap, it is better to do it with types, not classes, probably
22:43:48 <Jafet> cwl: a type constructor is a type that constructs other types. If you mean that Type1 is also constructor, just call it a constructor.
22:44:15 <Jafet> Maybe is a type constructor -- for each type a::*, (Maybe a) constructs a type.
22:44:32 <applicative> Nothing and Just are the constructors or data constructors,
22:45:39 <Jafet> display :: Either Type1 Type2 -> String
22:45:57 * Jafet wonders if sum types should have less typing overhead.
22:46:18 <shachaf> Jafet: Typing as in keyboard?
22:46:36 <shachaf> kmc would have you use GADT syntax for every data type.
22:46:57 <Jafet> I won't allow him. I need polymorphic lets
22:47:12 <kmc> hmm, does -XGADTSyntax enable -XMonoLocalBinds?
22:47:13 <applicative> It would be nice to use something like bras and kets for Either types: <"Not defined for zero"|   vs   |1220>
22:47:23 <kmc> heh applicative
22:47:38 <Jafet> applicative: doesn't generalize though
22:47:47 <napping> that would be pretty misleading, wouldn't it?
22:48:09 <edwardk> jafet: sure it does. <_| and |_> in something agda-ish
22:48:10 * applicative stands by his insane plan
22:48:19 <Jafet> To a sum of more types, that is
22:48:19 <tgeeky> applicative: i'm working on something like that, but you can't have regular characters inside of infix operators, so it'll have to be inverted from what you're picturing
22:48:40 <napping> it's not "data Either a b = Left (b -> Double) | Right b", after all
22:49:04 <tgeeky> applicative: you could do:    o < "Not defined for zero" || vs || 1220 > o
22:49:29 <tgeeky> (assuming you take back (||))
22:49:39 <applicative> tgeeky, i grant it is a parsing nightmare, this is why we have mad genius write our compilers
22:49:45 <applicative> mad geniuses
22:50:07 <Jafet> Whenever you don't like parsing your language, sit back and remember that it could have been C++
22:50:45 <napping> applicative: the <f|x> notation means linear operators and vectors. It would be quite misleading to borrow it for either
22:51:15 <Jafet> How about (a|) and (|b)
22:51:26 <applicative> napping yes, it is only the element of orientation, right left, that survives
22:51:58 <Jafet> Hm, then the constructor is ambiguous.
22:53:09 <Jafet> Unless they're named (_|) and (|_)
22:54:22 <applicative> I guess with PostfixOperators I can already have, e.g. ("No value" >) (3454 <) which sort of suggests "look elsewhere" vs. "looky here"
22:54:27 <Jafet> But it generalizes! eg. (|_|), which is the face of SHE users when this syntax gets adopted
23:02:05 * hackagebot unordered-containers 0.1.4.3 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.4.3 (JohanTibell)
23:20:52 * hackagebot dimensional 0.10.1.2 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.10.1.2 (BjornBuckwalter)
23:51:26 <hpaste_> applicative pasted “bra/ket Either (agda)” at http://hpaste.org/51452
23:54:50 <tkahn6> hi guys is there any way to resolve the following error...
23:54:52 <tkahn6>     Couldn't match expected type `time-1.4:Data.Time.Clock.Scale.DiffTime'            against inferred type `time-1.1.4:Data.Time.Clock.Scale.DiffTime'
23:58:17 <applicative> yipe
