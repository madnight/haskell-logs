00:08:35 <kmc> ghc -XEquirecursiveTypes
00:15:34 <ziman> ghc -XUntyped
00:18:36 <copumpkin> ziman: -XUntypedWithNoTypeclassesSadly
00:22:27 * ddarius has trained copumpkin well.
00:22:41 * copumpkin barks obediently
00:22:52 * ddarius smacks copumpkin on the nose with a newspaper.
00:22:57 * copumpkin whimpers
00:31:18 <ian__> *Main> groupBy (<) [10, 50, 50]
00:31:18 <ian__> [[10,50,50]]
00:31:24 <ian__> makes absolutely no sense to me
00:31:36 <ian__> i'm expecting [[10, 50], [50]]
00:31:59 <napping> it's not too sensible on things that are not an equivalence relation
00:32:02 <ddarius> ian__: The meaning of groupBy is only defined if the passed in function is an equivalence relation.
00:32:11 <copumpkin> it compares with the beginning of each group
00:32:11 <copumpkin> not pairwise
00:32:21 <ddarius> ian__: Think about how you would implement groupBy for (==) and the behavior will make sense.
00:32:36 <ian__> so what am i looking for
00:36:57 <ian__> i want something that compares pairwise
00:37:25 <copumpkin> > zipWith (==) <*> tail $ [10,50,50]
00:37:26 <lambdabot>   [False,True]
00:37:35 <copumpkin> > zipWith (<) <*> tail $ [10,50,50]
00:37:36 <lambdabot>   [True,False]
00:40:00 <ddarius> For you copumpkin: plasmonster
00:42:23 <copumpkin> ian__:
00:42:24 <copumpkin> map (map fst) (groupBy ((. snd) . (&&) . not . snd) (zip [10, 50, 50] (False : (zipWith (<) <*> tail)
00:42:30 <ian__> thanks
00:42:43 <copumpkin> @pl \xs -> map (map fst) (groupBy ((. snd) . (&&) . not . snd) (zip xs (False : (zipWith (<) <*> tail)
00:42:44 <lambdabot> (line 1, column 99):
00:42:44 <lambdabot> unexpected end of input
00:42:44 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or ")"
00:42:51 <copumpkin> @pl (\xs -> map (map fst) (groupBy ((. snd) . (&&) . not . snd) (zip xs (False : (zipWith (<) <*> tail))
00:42:51 <lambdabot> (line 1, column 101):
00:42:52 <lambdabot> unexpected end of input
00:42:52 <lambdabot> expecting variable, "(", operator or ")"
00:43:00 <copumpkin> gah
00:43:24 <copumpkin> @pl map (map fst) . groupBy (\x y -> not (snd x) && (snd y)) . (\xs -> zip xs . (False:) . (zipWith (<) <*> tail) $ xs)
00:43:24 <lambdabot> map (map fst) . groupBy ((. snd) . (&&) . not . snd) . (zip `ap` ((False :) . (zipWith (<) <*> tail)))
00:43:27 <copumpkin> there!
00:43:58 <copumpkin> > map (map fst) . groupBy ((. snd) . (&&) . not . snd) . (zip <*> ((False :) . (zipWith (<) <*> tail))) $ [10,50,50,51,1,1,2,3]
00:44:00 <lambdabot>   [[10,50],[50,51],[1],[1,2,3]]
00:45:15 <copumpkin> map (map fst) . groupBy (((&&) . not) `on` snd) . (zip <*> ((False :) . (zipWith (<) <*> tail)))
00:45:18 <copumpkin> that seems clenaer
00:45:39 <copumpkin> ddarius: plasmonster? :O
00:45:41 <ddarius> @src groupBy
00:45:41 <lambdabot> groupBy _  []       =  []
00:45:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:45:41 <lambdabot>     where (ys,zs) = span (eq x) xs
00:50:53 <tibbe> edwardk: here
00:50:53 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
00:51:24 <tibbe> @tell c_wraith done
00:51:24 <lambdabot> Consider it noted.
00:53:04 <hpaste_> edwardk pasted “Unicode CharSet” at http://hpaste.org/51485
01:05:42 <hpaste_> edwardk pasted “more charset stuff” at http://hpaste.org/51486
01:15:04 <jav__> Uhm... somehow I can't (easily) find this in the cabal docs: How do I activate a flag in a cabal file? ... "Do I run cabal install -f myflag"? or do I need to configure first?
01:16:10 <kmc> you use it with configure, iirc
01:18:38 <edwardk> @ask copumpkin did you add primops for copying bytearray# data or just array# data?
01:18:38 <lambdabot> Consider it noted.
01:53:08 <jav__> Does cabal somewhere remember what flags a project was compiled with? ... somehow I managed to set another flag and now can't get it to forget that.. even "cabal clean" doesn't change that... I'm really confused
02:22:36 <alpounet> jav__, have you looked at the .cabal file of the project ?
02:24:17 <jav__> alpounet: yes, I did .. actually the problem somehow disappeared, I'm not sure what the problem was
02:28:07 <mysticc> ]whats the difference between sleep and nanosleep in system.posix.unistd
02:29:13 <mysticc> and why ctrl+c does not work if I want to stop my process during sleep
02:29:18 <napping> don't the docs say?
02:30:45 <napping> http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.5.0.0/System-Posix-Unistd.html
02:31:53 <mysticc> napping: I am not able to exit from my program using ctrl+c if sleep is called .... does it blocks the interrupts ..
02:36:05 <napping> ghc or ghci?
02:37:54 <mysticc> ghci
02:38:30 <napping> hmm, I think ghci may have some of it's own signal handlers complicating things
02:40:56 <napping> it works with ghci
02:48:14 <napping> with ghc, rather. Doesn't work in ghci
04:02:01 <edon> any implementations of reduced ordered binary decision diagrams on haskell except the obdd package?
04:47:20 <obiwahn> > (+) (f True) (f 3) where f _ = 1
04:47:21 <lambdabot>   <no location info>: parse error on input `where'
04:47:34 <obiwahn> > (+) (f True) (f 3) where {f _ = 1}
04:47:35 <lambdabot>   <no location info>: parse error on input `where'
04:47:56 <leod> > lef f _ = 1 in (+) (f True) (f 3)
04:47:57 <lambdabot>   <no location info>: parse error on input `='
04:48:03 <leod> :(
04:48:48 <yitz> leod: lef?
04:48:52 <leod> huh!
04:48:55 <obiwahn> > let f _ = 1 in  (+) (f True) (f 3)
04:48:56 <lambdabot>   2
04:49:01 <leod> how did that happen :D
04:50:23 <obiwahn> :t let f _ = 1 in  (+) (f True) (f 3)
04:50:23 <lambdabot> forall a. (Num a) => a
04:50:33 <fenris_kcf> hy. i'm a little confused about recursive list comprehension... why does "take 5 primes" lead to an infinite loop, when "primes" is defined as:
04:50:35 <fenris_kcf> primes = (2 : [n | n <- [3..], all (\p -> mod n p /= 0) (take (n-1) primes)])
04:51:29 <obiwahn> take 5 [1..]
04:51:32 <obiwahn> > take 5 [1..]
04:51:33 <lambdabot>   [1,2,3,4,5]
04:52:44 <obiwahn> > let fun x = take 5 [1..] : fun x in fun []
04:52:45 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
04:53:35 <ddarius> fenris_kcf: To return 3 it has to first know that 3 is a prime.
04:54:05 <fenris_kcf> so i have to use the intervall [2..] instead?
04:54:48 <fenris_kcf> ... no, that doesn't work either.
04:54:53 <yitz> fenris_kcf: how about n-2 instead of n-1?
04:54:59 <fenris_kcf> i'll try..
04:55:38 <fenris_kcf> well, that gives some more output than just "[2"
04:55:45 <fenris_kcf> but also doesn't terminate
04:55:53 <fenris_kcf> and shows wrong numbers
04:56:36 <yitz> let primes = (2 : [n | n <- [3..], all (\p -> mod n p /= 0) (take (n-2) primes)]) in take 5 primes
04:56:42 <yitz> > let primes = (2 : [n | n <- [3..], all (\p -> mod n p /= 0) (take (n-2) primes)]) in take 5 primes
04:56:46 <lambdabot>   mueval-core: Time limit exceeded
04:56:59 <yitz> ah right
04:57:26 <fenris_kcf> recursive list comprehension really's freaking me out...
04:57:28 <ddarius> You don't want to take the last 9 or 8 -primes- when n = 10, you want all the primes less than 10 (or you can use better bounds than that.)
04:57:28 <yitz> your taking the primes still gets ahead of computing them
04:58:37 <dylukes> Does anyone have a sublime-build for cabal projects?
04:58:44 <dylukes> I'm not sure how to set it up, but it looks convenient :3.
04:58:54 <yitz> > let primes = (2 : 3: [n | n <- [5..], all (\p -> mod n p /= 0) (takeWhile (< n `div` 2) primes)]) in take 5 primes
04:58:55 <lambdabot>   [2,3,5,7,11]
04:59:15 <dylukes> You should memoize that :0.
04:59:35 <obiwahn> > let drop_mult x xs= [y|y<-xs , y `mod  x /=0]; drop_all (x:xs) = x : drop_all (drop_mult x xs) in take (drop_all [2..])
04:59:36 <lambdabot>   <no location info>: parse error on input `x'
04:59:39 <dylukes> Oh well.. I guess that does memoize here.
04:59:39 <fenris_kcf> w00t, yitz. thx
04:59:46 <obiwahn> > let drop_mult x xs= [y|y<-xs , y `mod`  x /=0]; drop_all (x:xs) = x : drop_all (drop_mult x xs) in take (drop_all [2..])
04:59:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:59:46 <lambdabot>         against inferred type ...
04:59:50 <dylukes> > take 100 primes
04:59:51 <lambdabot>   Not in scope: `primes'
05:00:13 <dylukes> :t all
05:00:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:00:18 <dylukes> @src all
05:00:18 * hackagebot compdata 0.4 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.4 (PatrickBahr)
05:00:18 <lambdabot> all p =  and . map p
05:00:33 <dylukes> yitz: hm?
05:01:11 <dylukes> @let primes = (2 : 3: [n | n <- [5..], all (\p -> mod n p /= 0) (takeWhile (< n `div` 2) primes)])
05:01:12 <lambdabot>  Defined.
05:01:16 <dylukes> > take 10 primes
05:01:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
05:01:21 <dylukes> > take 50 primes
05:01:22 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:01:55 <fenris_kcf> why "(< n `div` 2)"?
05:02:13 <jmcarthur> and why not [5,7..]
05:02:25 <dylukes> jmcarthur: yeah I was thinking that myself.
05:02:27 <incluye> and why n / 2 instead of sqrt(n)
05:02:32 <dylukes> this is searching more numbers than it needs too.
05:02:39 <dylukes> to*
05:02:43 <jmcarthur> most such algorithms do, though
05:02:57 <dylukes> the probabilistic algorithms for primes are nea.
05:03:04 <dylukes> I recall knuth mentioning a couple.
05:03:23 <dylukes> i.e, they just give you a set of numbers which are highly likely to be primes, as well as the probability of such.
05:03:32 <obiwahn> > let drop_mult x xs = [y|y<-xs , y `mod` x /= 0]; drop_all (x:xs) = x : drop_all (drop_mult x xs) in take (drop_all [2..])
05:03:33 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:03:33 <lambdabot>         against inferred type ...
05:04:21 <obiwahn> i do not see the error:(
05:04:53 <ddarius> take takes an Int parameter.
05:05:00 <obiwahn> > let drop_mult x xs = [y|y<-xs , y `mod` x /= 0]; drop_all (x:xs) = x : drop_all (drop_mult x xs) in take 10 (drop_all [2..])
05:05:01 <lambdabot>   [2,3,5,7,11,13,17,19,23,29]
05:05:04 <dylukes> You can use Fermat's Little Theorem for much faster prime number finding... but its not necessarily correct :).
05:05:21 <koeien> err, there are carmichael numbers
05:05:24 <dylukes> And it will miss some numbers entirely
05:05:27 <dylukes> koeien: ^
05:05:37 <dylukes> koeien: it depends on your goals :P
05:05:46 <obiwahn> damn forgetting params is one of my most frequent mistakes in haskell:(
05:11:54 <obiwahn> @src and
05:11:54 <lambdabot> and   =  foldr (&&) True
05:12:16 <obiwahn> @all
05:12:20 <obiwahn> @src all
05:12:20 <lambdabot> all p =  and . map p
05:12:32 <ddarius> Exercise: Represent all as a foldr by fusing the map and the foldr in and.
05:16:49 <Olathe> @type foldr
05:16:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:16:55 <obiwahn> \f list ->  foldr (&&) True (map f list)
05:17:39 <obiwahn> :t \f list ->  foldr (&&) True (map f list)
05:17:42 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:17:53 <Olathe> @type \f -> foldr (\x r -> f x && r) True
05:17:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:18:14 <koeien> Olathe: seems correct
05:18:16 <ddarius> @src foldr
05:18:16 <lambdabot> foldr f z []     = z
05:18:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:18:20 <ddarius> Er,
05:18:22 <ddarius> @src map
05:18:22 <lambdabot> map _ []     = []
05:18:23 <lambdabot> map f (x:xs) = f x : map f xs
05:18:25 <ddarius> Blech.
05:18:31 <ddarius> map = foldr ((:) . f) []
05:18:35 <ddarius> map f
05:18:56 <ddarius> foldr c n . foldr ((:) . f) [] = foldr (c . f) n
05:19:12 <ddarius> :t \p -> foldr ((&&) . p) True
05:19:13 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:19:24 <Olathe> @type let all' _ [] = True; all p (x:xs) = case p x of { True -> all p xs; False -> False } in all'
05:19:25 <lambdabot> forall t t1. t -> [t1] -> Bool
05:19:55 <Olathe> @type let all' _ [] = True; all' p (x:xs) = case p x of { True -> all p xs; False -> False } in all'
05:19:56 <lambdabot> forall t. (t -> Bool) -> [t] -> Bool
05:21:55 <Olathe> Now Completely Fused (TM)
05:21:56 <obiwahn> ddarius: nice:)
05:23:04 <jmcarthur> random thought: of software written in haskell and actually used outside the haskell community, i think pandoc is one of the most underappreciated
05:23:18 <ddarius> Olathe: You are calling the library all.
05:23:31 <ddarius> It seems pretty appreciated.
05:45:02 * applicative appreciates pandoc
05:51:03 <huangyi> I've tries ten times to register an account in ghc trac without success, because i can't recognise the captcha. i swear to god i'm a human being. Does anybody can help me to register an account?
05:51:32 <hpc> i hate it when that happens
05:51:46 <obiwahn> 1 + 2 ?
05:52:01 <huangyi> It seems like hand writing english.
05:53:30 <huangyi> I'm not native english speaker, so hand writing style is hard to recognise for me.
05:54:32 <obiwahn> huangyi: 1 + 2 = ?  (captcha)
05:54:33 <applicative> huangyi, I see what you mean, it's pretty obscure.  If you reload the page you get a different one, I guess you noticed
05:54:43 <dafis> huangyi: indded, that looks a bit hard to figure out (though the first one was okay; the second one I looked at was mean)
05:55:42 <dylukes> http://cl.ly/AEB1
05:55:46 <dylukes> text editor I'm looking at
05:55:47 <dylukes> thoughts?
05:56:11 <dylukes> (the sidebar is a wee bit big in the screenshot because I was resizing it, but you get the idea)
05:57:11 <dafis> dylukes: a bit Macish, but looks okay
05:57:17 <dylukes> http://cl.ly/ACoa
05:57:23 <dylukes> Its surprisingly actually cross platform.
05:57:26 <DasIch> dylukes: looks nice
05:57:34 <dylukes> It's all python scripted and supports text mate bundles.
05:57:48 <dylukes> Trying to figure out how to write a build system plugin for cabal
05:57:55 <applicative> funny, i was just trying to build sublime text 2 on my dubious kde gizmo here
05:58:02 <dylukes> applicative: heh
05:58:42 <DasIch> dylukes: (not that looking nice is really that important, emacs and vim don't really look nice either)
05:58:53 <dylukes> DasIch: of course.
05:58:54 <dylukes> :P
05:59:01 <obiwahn> huangyi: sorry :( i wanted to make you solve integral(e^((-x)^2)) as captcha .. in case you wonder about my trolling:(
05:59:20 <dylukes> obiwahn: chain rule?
05:59:46 <dylukes> e^((-x)^2) * -x^3/3
05:59:47 <dylukes> I think.
05:59:50 <huangyi> I've registered succesfully now ;-)
06:00:17 <dafis> :D
06:00:31 <applicative> huangyi, great
06:00:43 <huangyi> with the help of google translate, which correct simple spell mistakes.
06:00:45 <dylukes> oh, no its apparently 1/2 sqrt(π) erfi(x) + C
06:00:46 <dylukes> wtf
06:01:17 <applicative> it seems reasonable to lodge a complaint against that form of captcha, but I don't know who you'd mention it to.
06:01:50 <ddarius> dylukes: You don't immediately recognize a Gaussian and know that it integrates to the error function?
06:02:21 <dylukes> ddarius: GAH
06:02:39 <dylukes> But... thats a very specific gaussian :\
06:03:12 <dylukes> b = 0, c = sqrt(1/2)
06:03:16 <dylukes> a = 1
06:03:32 <dylukes> and idk what the error function is.
06:03:41 <dylukes> my knowledge of this stuff is next to none.
06:04:06 <aavogt> if anything it's easier to see/remember it without variables to shift and scale it
06:04:40 <dylukes> I s'pose so.
06:05:10 <dylukes> What is "the error function"?
06:05:36 <dylukes> This "erfi"
06:05:37 <applicative> is it insane to put up a ticket on the ghc trac, complaining that the trac itself has a defect?  where is the ghc trac trac?
06:05:54 <dylukes> applicative: You need template trac to do metaticketing.
06:06:03 <ziman> I don't think that e^((-x)^2) is a gaussian :)
06:06:17 <dmos> anyone successfully used cabal install yi (0.6.4.0) with GHC 7.0.3 (HsPlatform 2.0.1/MacOSX/32bit)? My build fails by default with ExitFailure 11 and ExitFailure 6 if run in verbose with the additional remark of ghc: internal error: evacuate: strange closure type 54037
06:06:17 <dmos>     (GHC version 7.0.3 for i386_apple_darwin)
06:06:18 <dmos>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
06:06:34 <dylukes> general form is ae^(-(x -b)^2 / 2c^2) ziman
06:06:41 <dylukes> a = 1, b = 0, c = sqrt(1/2)
06:06:42 <plat0> ziman: yes, that's why the intergral was erfi and not erf
06:06:55 <applicative> i like the idea of a 'strange closure type'
06:06:58 <dylukes> and you get e ^ -x^2
06:07:02 <ddarius> dylukes: Which is slightly off since the negative is in the inside rather than the outside.
06:07:06 <ddarius> of the square
06:07:15 <dylukes> oh.
06:07:18 <dylukes> you're right.
06:07:21 <dylukes> :\
06:07:23 <ddarius> ziman is correct
06:07:29 <dylukes> Didn't catch that. Whelp.
06:07:41 <ziman> but plat0 appears to have a point.
06:08:49 <ddarius> This GHC Trac captcha is expanding my vocabulary.
06:10:39 <applicative> I'm seeing either 'hulloc' or 'hulloo'  Somehow I don't think either is going to make it into my vocabulary
06:11:00 <dylukes> Hm
06:11:04 <dylukes> I'm seeing "inglip summoned"
06:11:07 <dylukes> as my captcha
06:11:25 <ddarius> The most recent one I got was "medias" which is not going to make it into my vocabulary.
06:11:27 <Nimatek> All hail inglip.
06:13:06 <ddarius> Didn't know the word "dossal" though.
06:13:23 <dafis> ddarius: sure it wasn't dorsal?
06:14:02 <ddarius> Yes.
06:14:11 <ddarius> @wn dossal
06:14:12 <lambdabot> *** "dossal" wn "WordNet (r) 2.0"
06:14:12 <lambdabot> dossal
06:14:12 <lambdabot>      n : an ornamental hanging of rich fabric hung behind the altar
06:14:12 <lambdabot>          of a church or at the sides of a chancel [syn: {dossel}]
06:14:41 <dafis> aw
06:15:19 <dylukes> uxoricide
06:15:27 <dylukes> a useful list: http://phrontistery.info/kill.html
06:15:37 <koeien> dylukes: that word is actually easy with a little knowledge of latin :)
06:15:37 <dafis> dylukes: that's sometimes understandable
06:19:33 <ddarius> Yes, you can apply knowledge of Latin to learn from what formic acid derives.
06:25:17 <applicative> dmos: I haven't been able to build with with ghc 7.2...  but I just recompiled yi yi contrib and my yi.hs on OS X without event ... using my copy of 7.0.3.   Its the 64 bit Haskell Platform version though
06:26:00 <applicative> uxoricide is not advisable
06:27:07 <dmos> applicative: thanks for looking into that. I thought along the same lines (32b vs 64bit). I have the 32bit version installed though, and just invoking the installer of the 64bit version bails out shortly before the end. Any idea how to uninstall the haskell platform pkg properly?
06:27:34 <applicative> hm isn't there an uninstall script buried in there?
06:27:36 <dmos> (OS is all 64bit, so it would be a win anyway).
06:28:25 <dmos> applicative: yeah, just found it.
06:28:34 <dmos> will see how far I get.
06:29:09 <applicative> oh cool i was about to give the place.  you should also kill some local conf things maybe, I don't know what the uninstaller will remove.
06:31:09 <not-parcs> how do i tell cabal to build/provide links the highlighted source code in the generated haddocks?
06:31:55 <dmos> applicative: judging from how fast it went, I think it just unregistered the packages, the rest has to be removed by hand (eg. hard sudo rm -r /Library/Haskell/)
06:33:09 <dmos> applicative: another question, how do I tell cabal to rebuild all (user) packages now?
06:33:17 <applicative> I see.  Anyway, I don't think you need to worry about things in ~/.ghc/... since the subdirectory distinguish the various versions of the compiler anyway
06:33:23 <ddarius> applicative: 'more interested in prolicide.
06:35:41 <applicative> dmos, I don't think there's any way (there use to be an 'update everything' incantation, if  I remember, which was a disaster.)
06:36:18 <dmos> ah, so dependencies get 'upgraded' (recompiled) when I install new stuff. that works, too.
06:36:48 <dmos> applicative: yeah, read about that. I assume the problem to be that cabal isn't a full package manager.
06:37:35 <applicative> dmos, if you just cabal install x y z w t u v all at once when you have the new compiler -- which is what I'm doing with my new sloppy arch installation here -- cabal install can do all its crazy version inferences at once, which is good
06:38:04 <applicative> you would do well to have a list of the stuff you installed before, or the things you actually used
06:38:23 <dmos> yeah, that's what I'll probably do. Running a yi install right now, so we'll see whether my problems persists or not.
06:39:32 <dmos> applicative: your 'sloppy arch installation' is in a VM or on a server? I'm asking because I was thinking of putting the whole install into a VM myself...
06:40:07 <parcs> preflex: seen apfelmus
06:40:08 <preflex>  apfelmus was last seen on #haskell 74 days, 19 hours, 28 minutes and 13 seconds ago, saying: byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
06:43:28 <plat0> UL liverpool
06:43:36 <plat0> sorry, wrong channel :S
06:44:28 <Sk_> Anyone who would be nice enough to help me with a homework-assignment?
06:45:14 <koeien> Sk_: sure, we can guide you
06:48:22 <Sk_> koeien: I am supposed to make a function that creates an infix operator, that put together the values of two datatypes. But I can't even understand where to begin
06:49:27 <koeien> well first thing to note is that in Haskell, infix operators are normal functions
06:49:43 <koeien> you can define your own operators easily, e.g.
06:49:57 <koeien> @let x .*. y = x * y * 2
06:49:59 <lambdabot>  Defined.
06:50:03 <koeien> > 2 .*. 4
06:50:04 <lambdabot>   16
06:50:18 <Sk_> Ok
06:50:18 * hackagebot compdata 0.4.1 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.4.1 (PatrickBahr)
06:50:23 <koeien> now we have a, non particularly useful, function defined.
06:50:28 <koeien> we can also use it as follows,
06:50:33 <koeien> > (.*.) 2 4
06:50:35 <lambdabot>   16
06:50:41 <dylukes> Sk_: What do you mean "put together the values of two datatypes"?
06:50:50 <Clint> 5 + "blue"?
06:50:58 <Sk_> I'm sorry my english is boot so good
06:50:58 <dylukes> I think he means a sum type.
06:51:06 <koeien> this also holds for other functions, such as (+) and (*). They are not special
06:51:07 <Sk_> the whole assignment is a blackjack game, but the thing i'm stuck on is creating "(<+) :: Hand -> Hand -> Hand".
06:51:13 <koeien> > (+4) 2
06:51:14 <lambdabot>   6
06:51:26 <koeien> Sk_: ok. how is Hand defined?
06:51:27 <dylukes> Sk_: What does (<+) do?
06:51:50 <dylukes> I'm guessing Hand = Normal Int | BlackJack | Bust
06:51:52 <dylukes> or something like that.
06:51:58 <dylukes> Could we see the assignment proper?
06:52:02 <dylukes> No one in here will do it for you, mind you.
06:52:08 <Sk_> given two hands, <+ should put the first one on top of the second one
06:52:16 <koeien> well erm, we need Soft and Hard in blackjack, afaik
06:52:17 <Sk_> Absolutely, I'm only after some guidance
06:52:21 <dylukes> koeien: true.
06:52:31 <dylukes> Hand = Soft Int | Hard Int | Bust
06:52:34 <koeien> so a hand is a number of cards.
06:52:36 <Sk_> hand is "data Hand = Empty | Some Card Hand"
06:52:47 <koeien> aha, I see.
06:52:56 <dylukes> wait, what
06:53:02 <dylukes> its a list?
06:53:08 <koeien> dylukes: isomorphic to :)
06:53:12 <applicative> dmos, no it's on some netbook i was using to have a copy of Windows
06:53:42 <dylukes> instance Functor Hand where...
06:53:43 <dylukes> so tempted haha
06:53:48 <applicative> dmos, of course I wrecked the Windows installation installing arch, but there are worse things
06:53:59 <koeien> Sk_: well, so you can define (<+) using pattern matching. first of all, try to think about the base case
06:54:10 <koeien> what is Empty <+ h, for example.
06:54:20 <koeien> dylukes: doesn't work, * -> * vs *, the kind is not correct :)
06:54:52 <dylukes> koeien: meh
06:55:22 <Sk_> koeien: so it should be that Empty <+ h2 = h1 and vice versa first?
06:55:59 <koeien> what is h1 there?
06:56:13 <dylukes> handmap :: (Card -> Card) -> Hand -> Hand
06:56:13 <dylukes> handmap f Empty      = Empty
06:56:14 <dylukes> handmap f (Some c h) = Some (f c) (handmap f h)
06:56:16 <dylukes> nonetheless koeien :P
06:56:40 <koeien> Sk_: it's not in scope.
06:56:55 <dylukes> It's a Foldable, I believe.
06:57:11 <dylukes> Sk_: if you have a <+ b
06:57:14 <dylukes> is b on top of a?
06:57:16 <koeien> What is the empty hand and then h2 added to it?
06:57:20 <dylukes> (the arrow would indicate that)
06:57:58 <Sk_> Ah, Empty <+ h2 = h2 and h1 <+ Empty = h1
06:58:14 <koeien> Sk_: that's right. But that does not cover all the cases
06:58:45 <koeien> so now we have covered Empty <+ h2. What about Some c h <+ h2   ?
07:00:31 <applicative> Some c h <+ Empty = Some c h , I affirm
07:02:15 * applicative cant remember, do the somehow fuse hands in blackjack?
07:02:33 <dylukes> you get cards one at a time in blackjack though
07:02:49 <koeien> that's true, except for the starting hand
07:02:58 <dylukes> mm
07:03:50 <koeien> Sk_: a hint: you can use <+ again in the right hand side of   Some c h <+ h2 = ....
07:04:38 <applicative> keeping in mind that h and h2 are both hands
07:04:49 <dylukes> Let the types guide you.
07:05:50 <applicative> structural recursion on Hands
07:06:03 <dylukes> Keep in mind, structural recursion is when
07:06:09 <dylukes> you take something large, and break it down recursively
07:06:24 <dylukes> You're working with smaller pieces each time. that should be a good hint.
07:06:25 <applicative> It's when the hand on the right hand side is smaller than on the left
07:06:34 <dylukes> You can use pattern matching to take things apart.
07:06:49 <dylukes> Think about your hand as if it was placed face down in a stack.
07:06:57 <dylukes> You can only peel the top card off, one at a time
07:07:09 <dylukes> and you want to insert a second hand underneath it
07:07:12 <dylukes> how would you do it?
07:10:35 <Sk_> remove all the cards and then put them back?
07:11:01 <dylukes> okay visualize this
07:11:08 <dylukes> the cards lie flat on the table
07:11:21 <dylukes> when you lift one, it hovers in mid air up in magical thunk-space
07:11:33 <dylukes> so if the cards are from top to bottom 1,2,3
07:11:40 <dylukes> when you lift each one, the order stays, but they're now floating
07:11:56 <dylukes> when, when there are no cards (Empty!)
07:12:08 <dylukes> you can just put the entire new hand on the table
07:12:14 <dylukes> and the cards will fall when you're done
07:12:39 <dylukes> consider
07:12:47 <dylukes> f x = f (f x)
07:13:00 <dylukes> you can use a = b to mean 'a can be substituted for b'
07:13:15 <dylukes> so you can keep "expanding" that to f(f(f(f(f(f(.... etc
07:13:34 <dylukes> in the case of +>, its going to end, its not infinite. because you're working with smaller pieces
07:13:46 <dylukes> not bigger ones (notice here we're expanding f x into something bigger)
07:14:00 <dylukes> so, try writing out each step of <+
07:14:10 <dylukes> and see how it expands out, then crunches back
07:15:22 <dylukes> (Some c h1) <+ h2 = ...?
07:15:35 <dylukes> what do you need to do there?
07:15:50 <dylukes> you've "lifted" c into the air
07:15:54 <dylukes> what do you need to do to the rest of h1?
07:20:05 <Sk_> could it be something like (Some c h1) <+ h2 = h1 <+ h2 ?
07:32:55 <dylukes> Sk_: close!
07:33:01 <dylukes> but you're losing c then
07:33:17 <dylukes> You're trying to "lift" the card, not throw it away :)
07:33:35 <dylukes> what you're doing there is just throwing each card c away
07:33:37 <dylukes> expand it out
07:42:26 <Sk_> dylukes: (Some c h1) <+ h2 = (c h1) <+ h2 ?
07:42:38 <dylukes> c isn't a function though is it
07:42:46 <dylukes> What you want is
07:42:51 <Sk_> now i feel really stupid :(
07:42:55 <dylukes> " a new hand beginning with the card you just lifted,
07:43:07 <dylukes> where the rest of the cards are the rest with the new hand stuck under that"
07:43:15 <dylukes> imagine you have
07:43:20 <dylukes> [1,2,3] <+ [4,5,6]
07:43:51 <dylukes> now you want
07:43:58 <dylukes> what?
07:44:09 <dylukes> first you lift the first card off the table, which is 1
07:44:20 <dylukes> so you're breaking it into 1 and 2,3
07:44:25 <dylukes> this is the same as using Some c h
07:44:30 <dylukes> c is the 1, h is the 2,3
07:44:31 <dylukes> right?
07:44:34 <dylukes> so now you have
07:44:51 <dylukes> Some 1 [2,3] and you have [4,5,6]
07:45:05 <dylukes> remembering that [x,y,z] is the same as Some x [y,z]
07:45:07 <dylukes> is the same as
07:45:23 <dylukes> Some x (Some y (Some z Empty))
07:45:45 <dylukes> so, with our two hands, lets write them out entirely
07:46:07 <dylukes> Some 1 (Some 2 (Some 3 Empty)) <+ Some 4 (Some 5 (Some 6 Empty))
07:46:19 <dylukes> so, each "Some" is made up of a card, and a hand.
07:46:24 <dylukes> so what we really want to do here
07:46:35 <dylukes> is replace the "empty" at the end of the first hand,
07:46:45 <dylukes> with the second hand.
07:46:51 <dylukes> (note, every hand eventually ends with Empty)
07:47:17 <Sk_> (Some c h1) <+ h2 = (c h1) <+ h2 ?
07:47:20 <dylukes> I'm going to write S and E, they're shorter
07:47:23 <dylukes> no, you can't do that
07:47:28 <dylukes> Thats the same as saying
07:47:39 <dylukes> if c is "9",
07:47:45 <dylukes> (9 h1) <+ h2
07:47:48 <Sk_> sry, i wrote the same thing as before by mistake :P
07:48:11 <dylukes> S 1 (S 2 (S 3 E)) <+ h2
07:48:19 <dylukes> Our goal is to replace E with h2.
07:48:25 <dylukes> we already have that
07:48:59 <dylukes> E <+ h2 = h2
07:49:02 <dylukes> so
07:49:09 <dylukes> S X E <+ h2 should be what?
07:49:14 <dylukes> S X h2 logically
07:49:35 <dylukes> so, S X (S Y E) <+ h2 will need to be S X (S Y h2)
07:49:40 <dylukes> but how can you do that?
07:50:31 <dylukes> S X (S Y E) <+ h2     ==>     S X ( S Y E <+ h2)
07:50:45 <dylukes> theres your final hint. Those mean the same thing don't they?
07:51:34 <hatomic> Other than the functional reactive libraries like fruit and yampa, do you know anyone or any library implementing higher level functions for wxhaskell?
07:52:24 <Sk_> dylukes: Yes, I think i kind of understand, but i will have to work with it a little while! :) Thanks for taking the time to help me!
07:54:23 <dylukes> S 1 (S 2 (S 3 E)) <+ h2 =>
07:54:23 <dylukes> S 1 (S 2 (S 3 E) <+ h2) =>
07:54:24 <dylukes> S 1 (S 2 (S 3 E <+ h2)) =>
07:54:25 <dylukes> S 1 (S 2 (S 2 h2))
07:54:32 <dylukes> Think on it for a bit.
07:54:33 <dylukes> It'll click.
07:56:18 <Sk_> dylukes: Thank you! :)
07:56:54 <dylukes> Sk_: there are different ways about thinking about structural recursion that work better for different people
07:57:17 <dylukes> you can see it as unfolding and then folding back up (this is formalized by unfold/fold, and catamorphisms/anamorphisms),
07:57:27 <dylukes> or you can see it as rewriting and "pulling" something inward.
07:57:36 <dylukes> or many many other ways..
08:03:42 <lambdanaut> If I understand correctly, accessing an "index" of a list is O(n) while accessing an index of an array in something like C++ is O(1) constant time because it's just grabbing that point in memory as apposed to digging through a data structure
08:04:01 <kmc> that's correct
08:04:13 <kmc> (and it's not a statement about languages; both C++ and Haskell have both lists and arrays)
08:04:28 <lambdanaut> does haskell have mutable arrays?
08:04:30 <kmc> yes
08:04:37 <kmc> IOArray, STArray, many others
08:04:40 <kmc> look at the 'vector' package too
08:04:45 <lambdanaut> oh cool! Thanks!
08:04:48 <kmc> but!
08:04:53 <kmc> O(1) is overrated
08:05:02 <kmc> pure functional data structures are *much* nicer to work with
08:05:05 <Olathe> O(0) is the best.
08:05:06 <kmc> especially in a concurrent context
08:05:14 <kmc> so consider something like Data.IntMap instead
08:05:27 <kmc> or the hash-tries in the unordered-containers package
08:05:31 <kmc> those are "O(1)" too
08:05:40 <kmc> in reality asymptotic analysis is totally inadequate
08:05:46 <kmc> it is a way to compare algorithms papers not real programs
08:06:03 <benmachine> asymptotic analysis is inappropriate in some situations
08:06:20 <kmc> the memory hierarchy — cache, cache, cache, main memory, disk — is proof that even raw memory access isn't O(1)
08:06:29 <benmachine> I think to say that it's useless for "real programs" is an overstatement
08:06:41 <kmc> i don't claim it's totally useless
08:06:58 <benmachine> baby, bathwater, etc.
08:07:08 <kmc> i think programmers (as opposed to algorithms theorists) should be really hesitant to look below O(n)
08:07:11 <kmc> and should profile instead
08:07:24 <kmc> sure, it's good to know if you're using an O(n) or O(n^3) algorithm
08:07:24 <benmachine> oh, that I might agree with
08:07:37 <benmachine> or an O(n!) algorithm :P
08:07:41 <kmc> but comparing O(log n) with O(1) is almost useless
08:07:50 <kmc> there are cases where the O(n^2) algorithm is faster too
08:08:07 <kmc> these analyses don't consider cache effects at all
08:08:21 <hpc> kmc: for very small values of n, the O(log n) solution would take negative time!
08:08:25 <kmc> srsly
08:08:40 <benmachine> hpc: heehee
08:08:57 <kmc> this is an important point if you're advocating functional languages
08:09:06 * benmachine runs interval bisection on an empty set and achieves time travel
08:09:10 <kmc> because most people are taught that the hash table is the god of data structures
08:09:44 <kmc> the hash trie has the same asymptotics, but people are indoctrinated with "trees == slow, hash table == awesome"
08:09:48 <hpc> they are also taught that it has O(1) access time, which is just a flat out fabrication
08:10:22 <kmc> like, the max depth of a 32-ary hash-mapped trie is going to be 13 or so
08:10:35 <kmc> but people will tell you that O(13) is much worse than O(1)
08:13:05 <kmc> a 32-ary trie which fits on a real machine probably has a depth of like 5
08:13:45 <kmc> and they have cheap pure-functional update
08:13:48 <aspect> O(13) wat
08:13:51 <kmc> but pure-functional programming is for weirdos
08:14:01 <kmc> so say "lock-free concurrency with cheap snapshotting"
08:14:04 <kmc> now people pay attention
08:14:09 <alpounet> ok, i have a Handle (which actually corresponds to a socket) and i would like to know is there's smth to read without actually reading it with bytestring's hGetLine
08:14:10 <rtperson> hey, can someone answer an openAL related question? (It's really a ForeignPtr question, but OpenAL is what I'm working with...)
08:14:25 <kmc> rtperson, just ask :)
08:14:33 <alpounet> hIsEOF seems to block until i get something to read
08:14:46 <incluye> okay so if O(1) is constant time
08:14:48 <incluye> what is O(2)
08:15:02 <hpc> alpounet: hWaitForInput?
08:15:10 <kmc> incluye, they both are
08:15:11 <companion_cube> slower constant time
08:15:13 <kmc> "O(13)" is a joke
08:15:21 <incluye> okay well i've seen O(4) before
08:15:25 <companion_cube> lol
08:15:27 <incluye> yeah must be a joke
08:15:27 <kmc> also a joke
08:15:29 <rtperson> OK, I have a simple array of sample data in the form "UArray Int Int16". I have to write that data to a foreignPtr of type GHC.ForeignPtr.ForeignPtr
08:15:30 <incluye> *nod*
08:15:36 <kmc> sometimes people write O(4) as a joke for O(α(n))
08:15:41 <kmc> α being the inverse Ackermann function
08:15:46 <aspect> O(2) is to O(1) what O(2n^2+100n+1) is to O(n^2)
08:15:50 <companion_cube> O(1) can be slower than O(4)
08:15:58 <rtperson> my question is what's the best way to turn the array into the ForeignPtr
08:16:01 <kmc> my general claim here is that constant factors, cache effects, etc. are much more important than asymptotics once you get below O(n)
08:16:07 <hpc> alpounet: hWaitForInput :: Handle -> Int -> IO Bool
08:16:14 <kmc> rtperson, I think you're supposed to use a Storable array for that
08:16:25 <kmc> or 'vector's storable vectors
08:16:27 <kmc> can you switch?
08:16:46 <rtperson> I looked at Storable. I'm using HCodecs to read in the sample data (in a WAV file)
08:16:52 <alpounet> hpc, i'm gonna try it
08:16:56 <kmc> and you want a ForeignPtr to the existing data?
08:16:58 <rtperson> So I'd still need to translate to Storable
08:17:05 <rtperson> kmc, yes
08:17:25 <kmc> looks like HCodecs is overloaded on the MArray / IArray type classes
08:17:41 <kmc> so you should be able to use it with Data.Array.Storable
08:17:42 <kmc> does that not work?
08:18:07 <rtperson> The type I have is SampleData from Data.Audio
08:18:20 <rtperson> it may be possible to translate, but it's something I've never done before
08:18:47 <kmc> i see
08:18:48 <rtperson> I'm pretty sure there's an easy way to do it :)
08:18:59 <rtperson> (one that I just haven't discovered yet)
08:19:12 <kmc> the thing is, I don't think it's guaranteed that a UArray is backed by memory which is compatible with C arrays
08:19:17 <kmc> that's what StorableArray is for, after all
08:19:30 <rtperson> kmc, exactly the issue I'm running into
08:20:04 <rtperson> And it looks like the original idea behind HCodecs was to serialize YampaSynth data
08:20:09 <kmc> or maybe it's just that regular UArrays can move around in the GHC heap without warning
08:20:14 <kmc> so those pointers don't stay valid
08:20:24 <kmc> how big are the arrays? and how many times per second do you need to process one?
08:20:36 <rtperson> The one idea I was playing around with was encoding the data as a ByteString
08:20:39 <alpounet> hpc, works like a charm, thanks!
08:21:01 <kmc> rtperson, i'd just copy that UArray into a http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/Data-Vector-Storable-Mutable.html
08:21:03 <rtperson> they're not that big
08:21:11 <kmc> and see if it performs acceptably
08:21:19 <rtperson> about 19KB
08:22:49 <rtperson> kmc, you mean doing an entire map copy? (I'm not against doing that, I just wondered if there's another way)
08:26:02 <kmc> i think there's not an easy way
08:26:14 <kmc> since afaik the UArray can move around in garbage collection
08:26:23 <kmc> how often do you need to do this copy?
08:26:27 <rtperson> makes sense.
08:26:48 <rtperson> Really, I just need to copy it once, to fill a buffer that will be used over and over
08:27:08 <rtperson> the copying can be done during initialization
08:27:08 <kmc> the other option is to modify HCodec to write a storable something to begin with
08:27:10 <kmc> okay
08:27:14 <kmc> then i'd just copy
08:27:45 <rtperson> yeah. My first inclination was just to parse the WAV files myself, since the format is very simple.
08:31:53 <inetic> hi, is there a different set of APIs for writing binary files other then the Data.Binary.Put? I'm looking for something along the lines: "writeInt32le handle 123" ...
08:32:19 <hpc> inetic: ByteString?
08:34:37 <kmc> does blaze-builder do binary?
08:34:47 <inetic> hpc, I need to be able to seek in the file
08:35:17 <kmc> int-e, you could mmap the file and use it as a mutable array
08:35:29 <hpc> inetic: they are just operations on ordinary Handles, so all the other operations are available in... System.IO iirc
08:35:40 <hpc> including hSeek
08:36:04 <inetic> hpc, thanks, gonna check it out
08:36:14 <kmc> er sorry s/int-e/inetic/
08:36:20 <parcs> kmc: do explain
08:36:23 <kmc> which?
08:36:42 <parcs> mmapping a file to use as an array
08:37:17 <kmc> well, you map the file contents into memory
08:37:17 <inetic> kmc, I have a data structure which if instantiated takes couple of GB in memory, so I think I can't use mmap, but thanks for suggestion
08:37:43 <kmc> and then use e.g. Data.Vector.Storable.Mutable.unsafeFromForeignPtr
08:37:55 <kmc> inetic, memory mapping does not imply that the whole file lives in RAM
08:38:12 <parcs> kmc: ah okay
08:38:17 <kmc> the OS will write pages back to disk and drop them from RAM as necessary
08:38:17 <inetic> kmc, aha, right
08:38:35 <kmc> this is why mmap can be a lot more memory efficient than explicit buffering
08:38:46 <parcs> inetic: hSeek, hGet, etc are pretty efficient
08:39:05 <kmc> taking a couple GB of virtual address space could be an issue on 32-bit machines
08:39:27 <kmc> Linux gives you 3GB by default, and the GHC runtime will want lots of that
08:39:34 <kmc> but if you're on a 64-bit machine, no worries
08:40:00 <inetic> kmc, it's still an issue because swapping takes a lot of time
08:40:21 <kmc> your goal here is to write to a file, right?
08:40:23 <davean_> inetic: exactly the same amount of time writing it out would take
08:40:57 <kmc> by using mmap you invoke a lot of sophisticated machinery in the OS
08:41:10 <kmc> which will manage memory and IO efficiently
08:42:15 <zaphix> So I'm trying to write a toy compiler for a toy imperative language in Haskell, and can't think of a very good way to represent use-def/def-use chains without pointers into the AST.  What's the idiomatic way to do this kind of thing?  Some kind of zippered AST?
08:42:15 <inetic> could be, I'll keep that in mind, but I think I'll first check out the System.IO way, thanks though
08:42:36 <parcs> this package may interest you: http://hackage.haskell.org/package/vector-mmap
08:42:45 <kmc> oh, nice
08:42:45 <davean_> Ok, not "exactly", you dirty stuff in chunks and those don't always line up with disk, but basicly the same
08:43:37 <kmc> yeah, I'd guess there are pathological cases for mmap, but it sounds like inetic is dismissing out of hand the decades of work that have gone into making memory-mapped IO work efficiently
08:43:58 <davean_> (sometimes more efficiently then the other options)
08:44:01 <kmc> it's like the foundation of a modern OS
08:45:03 <parcs> :t undefined :: forall a b. a
08:45:03 <lambdabot> forall a. a
08:45:15 <kmc> memory-mapped IO is easy and efficient
08:45:18 <inetic> kmc, :-) please don't take it like that, I said I'm not dismissing anything, I'm just choosing the way of least resistance :-), if that will not be what I wanted, I'll try something else
08:45:35 <parcs> looks like 'unsafeMMapMVector' has an unused quantified 's' in its type signature :P
08:46:03 <copumpkin> parcs: probably me fucking up
08:46:03 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
08:46:09 <copumpkin> parcs: fix it and reupload :P
08:46:21 <parcs> i lost my hackage password :(
08:46:22 <kmc> inetic, if vector-mmap works, it's probably less effort than manually seeking all over your file
08:46:31 <kmc> and if it doesn't work you can yell at copumpkin
08:46:52 <copumpkin> @tell edwardk only Array#, because the others can be copied with foreign calls to standard memcpy
08:46:52 <lambdabot> Consider it noted.
08:47:00 <inetic> kmc :-)
08:47:42 <inetic> have to go, girlfriend is asking for attention :-), thanks again
08:50:04 <kmc> haha, ok
08:50:05 <kmc> good luck
08:53:25 <kmc> copumpkin, what's the story with ByteArray# and Array#
08:53:36 <copumpkin> what about them?
08:53:44 <kmc> well, how do they differ
08:54:10 <copumpkin> oh, Array# contains boxed haskell values
08:54:22 <copumpkin> so needs to keep pointers in it
08:54:39 <copumpkin> it carries a card table to keep track of what's dirty
08:54:54 <copumpkin> so the GC can avoid traversing it every time it gets modified
08:55:09 <copumpkin> (and will only look at things that change)
08:55:31 <kmc> ah, right
08:55:48 <kmc> so IOArray is implemented with Array# and IOUArray with ByteArray#?
08:55:52 <copumpkin> yeah
08:56:17 <kmc> and you added a new primitive for Array#, which is aware of card-marking and such?
08:56:21 <copumpkin> yep
08:56:22 <kmc> for copying Array# i mean
08:56:23 <kmc> cool
08:56:25 <kmc> shiny
08:56:30 <kmc> any particular application in mind?
08:56:33 <copumpkin> then tibbe rewrote it so it unrolls for small static amounts
08:56:36 <copumpkin> I was doing it for tibbe
08:56:37 <kmc> nice
08:56:45 <copumpkin> for his HAMT thingy
08:56:57 <kmc> excellent
08:57:20 <copumpkin> :D
08:57:25 <kmc> we should publicize the hell out of that once it's ready
08:57:26 <copumpkin> I also added two essential primops
08:57:39 <kmc> "these are as good as hash tables but you can copy them cheaply and modify them without locks"
08:57:47 <kmc> that might get some attention ;)
08:57:50 <copumpkin> :D
08:58:02 <kmc> Rich Hickey has been pushing the same ideas for a while
08:58:03 <copumpkin> sizeofByteArray# :: ByteArray# -> Int#
08:58:15 <copumpkin> yep
09:00:18 <kmc> it's basically insane that people do shared-memory concurrency in languages with pervasive mutation and monolithic data structures like hash tables
09:00:24 <kmc> i know i'll find little disagreement here
09:00:38 <copumpkin> no, you have it all wrong
09:00:42 <copumpkin> if you can't do that, you're a shitty programmer
09:00:42 <kmc> but i think the realization of this insanity is dawning on the general programming community
09:00:45 <kmc> if not the solutions
09:00:51 <kmc> that's right, good programmers don't make mistakes
09:00:53 <kmc> neither do unicorns
09:00:56 <copumpkin> real programmers can keep track of all that stuff and not fuck it up
09:00:57 <zaphix> haha
09:01:07 <copumpkin> this is why john carmack is a shitty programmer
09:01:12 <kmc> copumpkin, that's why there's no concurrency bugs in Linux kernel, right?
09:01:26 <copumpkin> yeah
09:01:34 <kmc> certainly not rare catastrophic concurrency bugs that take several months of concerted testing to track down
09:01:55 <kmc> any good programmer could keep straight the two dozen types of locks and RCU flavours they use
09:02:45 <zaphix> So I'm trying to write a compiler for a toy imperative language in Haskell, and can't think of a very good way to represent use-def/def-use chains without "pointers" into the AST.  What's the idiomatic way to do this kind of thing?  Some kind of zippered AST (the "web" generalization of zippers that is)?
09:04:00 <kmc> can you elaborate on use-def / def-use chains?
09:04:37 <zaphix> kmc: so data structures that represent: x = 42 (def) ... (elsewhere in AST): y = x + 99; x = x + 2; ...
09:04:54 <zaphix> you'd have an easy association between the def of x and the uses that it reaches
09:05:03 <kmc> ah; I've only seen/used the unsophisticated approach of explicit names
09:05:15 <kmc> and scopes i.e. maps with names as keys
09:05:25 <zaphix> in OO land where i'm still a tad more comfortable, this is typically done by a linked list of pointers into the AST to the nodes that have relevant uses
09:05:31 <zaphix> (for def-use chains, that is)
09:05:50 <kmc> the problem of manipulating code in languages with name binders is like the great unsolved problem of mechanized metatheory
09:05:57 <zaphix> hehe
09:06:13 <Olathe> What are name binders?
09:06:21 <copumpkin> why wouldn't de bruijn work here?
09:06:55 <zaphix> copumpkin: i don't really know what that is
09:08:25 <copumpkin> I guess dealing with shadowing might be hard
09:08:52 <Olathe> You could have a map per scope.
09:08:54 <copumpkin> zaphix: I was thinking of http://en.wikipedia.org/wiki/De_Bruijn_index
09:08:55 <zaphix> yeah; this is the first step in a series of analysis/renaming passes for eventually converting to ssa form
09:09:06 <Olathe> Then, just go up the hierarchy until you found the one you're looking for.
09:09:22 <dankna> one option would be to build it as a recursive structure - you do have pointers, they're just disguised
09:09:23 <zaphix> Olathe: what are the values in the map, though? whole AST subtrees, replicated?
09:09:31 <Olathe> name -> value
09:09:56 <Olathe> If you're doing lazy stuff, sure. Otherwise, fully evaluate to a value, store that.
09:10:09 <zaphix> dankna: well, the AST itself is a recursive structure, but how do i represent the notion of a series of locations in this structure?
09:10:17 <dankna> hm
09:10:21 <dankna> well, I'd need to see the details
09:10:25 <zaphix> dankna: (this is why i asked about whether or not it's the "web" extension to zippers)
09:11:01 <Olathe> Like, your AST can have a store by name instruction.
09:11:37 <Olathe> And the code generator can figure out how to do that.
09:11:58 <Olathe> This is independent from the map idea.
09:12:03 <zaphix> i see
09:14:50 <Veinor> how can i write unit tests that involve random number generator properties? for example, if i write a pickRandom :: [a] -> IO a, how can I test that the chosen element is always in the list?
09:15:34 <kmc> HUnit can deal with those, can't it?
09:16:30 <Cale> Veinor: There's a QuickCheck module which deals with IO-performing properties, iirc.
09:16:57 <Veinor> well, the other alternative would be to test pickRandom' :: [a] -> StdGen -> a, but that would depend on the implementation of the StdGen
09:17:07 <zaphix> Yeah, check out PropertyM IO a in QuickCheck.Monadic
09:17:21 <Olathe> unsafePerformIO
09:17:25 <Cale> Don't unsafePerformIO for that :P
09:17:33 <Cale> I mean, you could...
09:18:02 <Olathe> My evil plans to spread the use of unsafePerformIO have been foiled again!
09:18:23 <Veinor> haha
09:18:52 <Cale> It's just that the semantics of any code which uses unsafePerformIO is questionable to begin with, so if you're trying to make sure your program is correct, introducing questionable tests to do it...
09:19:05 <Olathe> That's a good point.
09:20:55 <Veinor> (the specific case here is that i'm writing a markov-based generator, and i want to ensure that all the n-length substrings are present in the training corpus)
09:21:14 <kmc> Veinor, cool, i also wrote a markov chain text generator in Haskell :)
09:21:24 <kmc> mine doesn't have unit tests though :/
09:22:18 <copumpkin> kmc--
09:22:28 <kmc> :(
09:22:30 <copumpkin> kmc++
09:22:41 <kmc> :D
09:22:55 <benmachine> I wrote one in python, and then I wanted to turn it into haskell but thought "this has probably been done at least twice already"
09:22:58 <kmc> i mean, it's not a "serious" program
09:23:16 <Veinor> there's already markov-chain, but that lacks a few features that i want
09:23:31 <Veinor> such as the ability to transition to an end state
09:23:37 <benmachine> Veinor: oh right, are you going to release a competing library :o
09:23:43 <Veinor> yes :o
09:23:52 <Veinor> which means i need a package name and a module name
09:24:15 <copumpkin> markov-in-chains
09:24:15 <copumpkin> show him who's who
09:24:21 <Veinor> haha
09:26:15 <Veinor> maybe... Data.List.Markov ?
09:26:20 <Veinor> and markov-list
09:27:37 <copumpkin> but you want it to be a monad transformer!
09:27:54 <benmachine> Control.Monad.Trans.Data.Data.Data.Markov
09:27:55 <copumpkin> it ain't real haskell otherwise
09:28:05 <copumpkin> tridata
09:28:11 <copumpkin> now that's what I'm talkin about
09:29:14 <benmachine> I keep meaning to tell people about this http://www.srcf.ucam.org/~bm380/machine/haskell/overqualified-modules but I put it off until I get a comment system
09:29:22 <benmachine> (no-one say disqus)
09:29:42 <jrslepak> what's the most recent version of ghci?
09:30:16 <Cale> http://haskell.org/ghc/
09:30:24 <Cale> 7.2.1 is the newest release of GHC
09:30:35 <Cale> But of course, there are newer development builds
09:30:42 <kmc> benmachine, interesting
09:30:56 <hpc> benmachine: god no; that code is disqusting
09:31:08 <jrslepak> so that applies to ghci as well? thanks Cale
09:31:17 <kmc> benmachine, my philosophy is basically:  very general utility which does what it says on the tin => generic qualified Data.Whatever name
09:31:25 <benmachine> hpc: your use of the word 'that' here lacks specificity :P
09:31:34 <kmc> specialized tool which can't be described in less than a paragraph  => arbitrary name
09:31:47 <benmachine> kmc: why Data?
09:31:54 <kmc> not always data
09:31:58 <benmachine> sure but
09:31:59 <kmc> whatever fits
09:32:09 <benmachine> hmm
09:32:09 <kmc> i get your point about overqualified
09:32:14 <kmc> at the same time i don't want to buck the trend too much
09:32:17 <benmachine> heh
09:32:26 <kmc> i.e. Data.Vector.Storable.ByteString fits in with Data.Vector.Storable.*
09:32:32 <benmachine> mm
09:32:36 <kmc> and is sort of the one obvious thing that would go there
09:33:18 <kmc> but hdis86 contains Hdis86.* and not Data.MachineLanguages.X86.Disassembler.TheParticularDecisionsMadeByVivekThampi.TheParticularDecisionsMadeByMe
09:33:37 <benmachine> :)
09:33:50 <hpc> your points about Monoid and Functor are spot on
09:34:21 <kmc> dewdrop contains Dewdrop.* and not Security.Exploits.Tools.RemoteCodeExec.ReturnOriented.Gadgets.Finder.*
09:34:41 <benmachine> I might overstate the problem slightly; maybe I just want Control. and Data. and friends to go away
09:35:00 <ben> Control.Exception and Control.Concurrent seem to make sense
09:35:04 <hpc> i really like Control.
09:35:13 <ben> and I don't think Data.Word or Data.Map are that ambiguous either
09:35:20 <kmc> i just wish modules could re-export qualified imports
09:35:20 <benmachine> ben: but what's wrong with Exception and Concurrent?
09:35:28 <kmc> then i'd have a module with all my common imports
09:35:57 <Cale> I agree. Data.* and Control.* are silly hierarchies.
09:36:00 <hpc> kmc: me too! that's the one thing stopping me from using a parsing library for my website, is the name collisions
09:36:13 <kmc> it's arbitrary to say that monads are control and monoids are data ;)
09:36:29 <kmc> with lazy higher-order programming the line gets really blurry
09:36:46 <ben> benmachine: I dunno, if you flatten the namespace theoretically there's a huge list of modules in the top-level.
09:36:51 <kmc> so what?
09:36:55 <Cale> I actually initially found the hierarchical names really irritating, though I've pretty much gotten used to them.
09:36:56 <benmachine> obviously Data.List should be Control.List :D
09:36:59 <ben> At some point I'd probably go "hmm, what was that data-structure module again" and start looking in Data.
09:37:09 <kmc> Monad.* is not more ambiguous than Control.Monad.*
09:37:16 <Olathe> How can I strictly compare Doubles (without corrections for really close numbers)?
09:37:24 <kmc> strictly?
09:37:31 <ben> I agree that it's not more ambiguous but it seems more orderly to stash it into some prefix
09:37:33 <Cale> Olathe: < ?
09:37:37 <ben> along with Applicative and Functor and friends, ideally
09:37:43 <Cale> > pi < 3
09:37:44 <lambdabot>   False
09:37:52 <Cale> > pi < (3 :: Double)
09:37:52 <benmachine> ben: I don't think the hierarchy is used like a directory hierarchy in practice
09:37:52 <lambdabot>   False
09:37:56 <benmachine> nor should it be
09:38:04 <kmc> yeah, it's rare to browse modules by hierarchy
09:38:10 <benmachine> and I agree that it "seems more orderly" but I don't agree that that means anything :P
09:38:13 <kmc> i usually browse modules by a text search on the whole name or description
09:38:21 <Olathe> Ahh, OK. Thanks.
09:38:35 <ben> So what's the point of the hierarchic thing again?
09:38:39 <Cale> Olathe: == also works
09:38:44 <ben> Just throw it out whole?
09:38:50 <Cale> Olathe: Though it's not as useful for Double
09:38:58 <Cale> Olathe: and there's also compare
09:39:00 <benmachine> ben: I think *some* uses of hierarchical modules are okay, ish :P
09:39:01 <Cale> :t compare
09:39:01 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:39:09 <benmachine> ben: Haskell.Parser I'd accept
09:39:09 <Cale> :t [LT, EQ, GT]
09:39:09 <lambdabot> [Ordering]
09:39:15 <ben> Just import everything by package names!
09:39:30 <benmachine> because both of those pieces of information are essential to understanding what it does
09:39:52 <ben> But now you're just throwing random words in the name
09:39:55 <ben> and not making a hierarchy
09:39:58 <benmachine> (although I don't really see what's wrong with HaskellParser tbh)
09:40:01 <ben> Why not Parser.Haskell? :V
09:40:02 <Cale> I think it sucks that I have to import Data.Map the same way in every module of my program, and I can't define a prelude for my program somewhere which imports and re-exports it the way I want.
09:40:12 <benmachine> ben: fair question
09:40:34 <Cale> import Data.Map (Map); import qualified Data.Map as M
09:40:44 <Cale> ^^ this is annoying to have to do over and over
09:40:53 <benmachine> clearly imports need to be first-class
09:40:57 <benmachine> or something
09:41:02 * benmachine hazy on the details
09:41:08 <Cale> Well, I should be able to export M
09:41:14 <rwbarton> can you splice in import declarations with TH?
09:41:29 <benmachine> rwbarton: I suspect TH runs after imports have been resolved, but I'll check
09:41:31 <hpc> benmachine: nah, just have re-exports preserve the qualifications they would have in the module that is importing them
09:41:35 <Cale> and have it export things qualified
09:41:51 <hpc> module Foo (module Bar) where import qualified Bar -- like that
09:41:55 <rwbarton> it seems like there are a lot of things that could go wrong with that
09:42:04 <benmachine> rwbarton: I don't see an import in the TH Dec type
09:42:10 <hpc> module Foo (module Bar) where import qualified Bar as Foo.Bar -- or like that
09:42:30 <rwbarton> oh... well that wasn't one of the ones I thought of
09:42:35 <benmachine> hpc: does that mean you could import Foo and get Foo.Bar.stuff?
09:42:41 <hpc> benmachine: yeah
09:42:55 <Veinor> anyway
09:42:59 <benmachine> hpc: hmm. it's kind of nice that atm you can work out exactly which module a thing came from by its qualification
09:43:01 <Veinor> does this mean I should just use Markov? :V
09:43:07 <ziman> How about type-driven identifier disambiguation instead? :)
09:43:23 <benmachine> Veinor: I think that would be what I would suggest, but consensus is against me, so do what you like :P
09:43:25 <hpc> benmachine: the second one would do what you described; the first would just give Bar.stuff
09:43:33 <Veinor> haha
09:43:48 <Cale> Yeah, I guess there's some room for abuse if you're not careful
09:44:12 <benmachine> Veinor: I don't honestly think it's the most important thing in the world
09:44:22 <benmachine> I should probably put "bikeshedding warning" at the top of that page
09:44:36 <Cale> module Foo (module Data.Set) where import qualified Data.Map as Data.Set -- trololol
09:44:46 <benmachine> haha
09:45:01 <hpc> Cale: i love it
09:47:03 <Veinor> i'll probably just go with Data.List.Markov because i don't like bucking the system
09:47:05 <Veinor> Cale: haha
09:47:32 <hpc> Data.List.Chain.Markov.Generator :P
09:47:47 <hpc> .MarkovGeneratorInstanceFactorySingleton :D
09:47:55 <benmachine> :>
09:48:46 <Veinor> hpc: what is this, haskell++?
09:50:55 <Olathe> C++ = C, but one step further into random memory.
09:51:21 <hpc> Olathe: one step closer to a segfault?
09:52:03 <Olathe> Of course
09:53:30 <kmc> Cale, I think for my one-off scripts, I'll just do that with CPP
09:53:43 <kmc> (import a bunch of stuff, qualified)
09:53:47 <kmc> don't think i'd release code that way, though
09:56:37 <Rc43> Hi.
09:56:44 <kmc> hi Rc43
09:58:26 <Rc43> How to write getting divisors function in a good way? I have tried "divisors n = [d' | d <- [2..(floor.sqrt) n], d mod n == 0]", but it fails and demand to do something with types.
09:58:42 <Rc43> *mod n d == 0 of course
09:59:35 <byorgey> Rc43: sqrt can only be called on floating-point types, and mod only on integral types, and 'n' cannot be both
10:00:00 <Veinor> > let divisors n = filter (\d -> d `mod` n == 0) [2 .. floor (sqrt $ fromIntegral n)]
10:00:01 <lambdabot>   not an expression: `let divisors n = filter (\d -> d `mod` n == 0) [2 .. fl...
10:00:05 <Veinor> > let divisors n = filter (\d -> d `mod` n == 0) [2 .. floor (sqrt $ fromIntegral n)] in divisors 60
10:00:05 <lambdabot>   []
10:00:16 <Veinor> > let divisors n = filter (\d -> n `mod` d == 0) [2 .. floor (sqrt $ fromIntegral n)] in divisors 60
10:00:17 <lambdabot>   [2,3,4,5,6]
10:01:03 <Veinor> > let divisors n = filter ((==0) . (n `mod`)) [2 .. n/2] in divisors 60
10:01:04 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:01:04 <lambdabot>    `GHC.Real.Integral t'
10:01:04 <lambdabot>   ...
10:01:23 <Rc43> let divisors n = [d | d <- [2 .. floor (sqrt $ fromIntegral n)], mod n d == 0] in divisors 60
10:01:37 <Rc43> sooooo?
10:01:55 <kmc> > let divisors n = [ d | d <- takeWhile ((<n) . (^2)) [2..], n `mod` d == 0 ] in divisors 60
10:01:56 <lambdabot>   [2,3,4,5,6]
10:02:11 <Veinor> > let divisors n = filter ((==0) . (n `mod`)) [2 .. n `div` 2] in divisors 60
10:02:13 <lambdabot>   [2,3,4,5,6,10,12,15,20,30]
10:02:32 <benmachine> Veinor: once you have the ones up to the square root, you can find all the others by straight division
10:02:36 <kmc> > let divisors n = filter ((==0) . (n `mod`)) $ takeWhile ((<n) . (^2)) [2..] in divisors 60
10:02:38 <lambdabot>   [2,3,4,5,6]
10:02:48 <Rc43> > takeWhile ((<n) . (^2)) [2..]
10:02:50 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
10:02:52 <Rc43> lolwhat?
10:02:53 <Veinor> true.
10:02:56 <kmc> :t n
10:02:57 <lambdabot> Expr
10:03:04 <kmc> > takeWhile ((<50) . (^2)) [2..]
10:03:05 <lambdabot>   [2,3,4,5,6,7]
10:03:16 <benmachine> Rc43: ignore lb's madness
10:03:31 <benmachine> > sort [z,y,x]
10:03:32 <lambdabot>   [x,y,z]
10:03:47 <Cale> lol
10:03:57 <Cale> > x < y
10:03:58 <lambdabot>   True
10:04:01 <Veinor> that's
10:04:01 <Cale> > y < x
10:04:02 <lambdabot>   False
10:04:06 <Veinor> i don't even know what to say about that
10:04:30 <Rc43> let divisors n = [d | d <- [2 .. floor (sqrt $ fromIntegral n)], mod n d == 0] in divisors 60
10:04:48 <Veinor> you need the > at the start
10:04:50 <Rc43> Why it don't launch it?
10:04:52 <Rc43> aa
10:04:55 <Rc43> > let divisors n = [d | d <- [2 .. floor (sqrt $ fromIntegral n)], mod n d == 0] in divisors 60
10:04:56 <lambdabot>   [2,3,4,5,6]
10:04:59 <Rc43> cool
10:05:21 <Veinor> but you're better off writing that using a filter
10:05:23 <benmachine> it's probably faster if you calculate the prime factors first and then do some products
10:05:28 <kmc> Rc43, i would filter by the square rather than by the square root
10:05:30 <benmachine> just sayin'
10:05:43 <benmachine> kmc: just because floating point is the devil?
10:05:48 <Rc43> kmc, sqrt is much longer?
10:05:52 <Veinor> > let divisors n = filter (\n -> mod n d == 0) [2 .. floor (sqrt $ fromIntegral n)]
10:05:53 <lambdabot>   not an expression: `let divisors n = filter (\n -> mod n d == 0) [2 .. floo...
10:05:56 <Veinor> > let divisors n = filter (\n -> mod n d == 0) [2 .. floor (sqrt $ fromIntegral n)] in divisors 60
10:05:57 <lambdabot>   []
10:05:58 <kmc> i think it's nicer
10:06:08 <Veinor> > let divisors n = filter (\d -> mod n d == 0) [2 .. floor (sqrt $ fromIntegral n)] in divisors 60
10:06:08 <lambdabot>   [2,3,4,5,6]
10:06:11 <Veinor> there we go.
10:06:11 <kmc> code looks better, no fromIntegral noise
10:06:14 <kmc> i would not worry about speed
10:06:24 <Rc43> kmc, but squaring every number is soooooooo slow
10:06:29 <kmc> is it?
10:06:31 <kmc> did you benchmark it?
10:06:33 <kmc> what are you using this code for?
10:06:34 <Veinor> so is repeatedly testing every divisor
10:06:35 <Rc43> nope
10:06:37 <kmc> are you running with ghc -O2?
10:06:43 <kmc> if you're writing one-liners for project euler, it doesn't matter
10:06:54 <benmachine> if it's too slow use a better algorithm, rather than worrying about how you do the square root check
10:07:00 <Rc43> but I think sqr of every from [1..10000] is longer then sqrt of 100000
10:07:10 <kmc> longer?
10:07:16 <Rc43> slower
10:07:24 <kmc> did you benchmark it?
10:07:42 <kmc> use this package: http://hackage.haskell.org/package/criterion
10:08:05 <benmachine> if you care :P
10:08:08 <kmc> if you want to pointlessly micro-optimize your code according to how computers worked in 1970, use C
10:08:24 <kmc> if you want to write correct code first, and then optimize the bits that need optimizing, use Haskell
10:08:28 * copumpkin cowers
10:08:45 * benmachine sheepers
10:09:05 <copumpkin> I wonder if pumpkin would wer
10:09:11 <Veinor> haha
10:09:19 <Veinor> cokmc wers from pumpkin
10:10:15 <Veinor> but yeah there's no point in optimizing code until you need to optimize it
10:10:48 <kmc> well there's "i want to make this code pointlessly fast because it shows how hardcore i am"
10:10:51 <kmc> i think that's a fine game to play
10:11:08 <kmc> it's harmful when that thinking creeps into "serious" code, though
10:11:27 <kmc> anyway even then, you want to measure and iterate, not guess based on whether sqrt or square was faster on the VAX or something
10:11:44 <Rc43> but really, sqring of every number is awfull
10:11:50 <Rc43> *l
10:12:06 <copumpkin> Rc43: oh yeah?
10:12:06 <Veinor> 14:06:04        <kmc> well there's "i want to make this code pointlessly fast because it shows how hardcore i am"
10:12:11 <Veinor> don't you mean pointfreely fast? :D
10:12:26 <benmachine> Rc43: it's not all that bad. multiplication is easy
10:12:26 <copumpkin> Rc43: do you avoid squaring one number every time you send packets out over a network, too?
10:12:42 <copumpkin> when you're writing a network protocol implementation
10:13:20 <kmc> Rc43, stop repeating the same uninformed line
10:13:31 <Rc43> copumpkin, ifor network it is minor waste
10:13:34 <kmc> we understand your opinion, you have no evidence for it, let's move on
10:14:06 <benmachine> I think I've benchmarked this before, and he's probably right, but again if you want to make a factor search faster there are much better ways to do it
10:14:13 <copumpkin> Rc43: what makes you think it's less of a waste here?
10:14:30 <copumpkin> Rc43: or to put it more bluntly, do you micro-optimize your bubblesort, too?
10:14:53 <kmc> yes, I think Rc43 is probably correct about the sign of this irrelevant quantity
10:15:07 <kmc> i want to encourage the gathering of evidence rather than the repeating of Common Wisdom from ages ago
10:15:11 <copumpkin> anyway, I think this discussion is a strong indicator of the need for popeye's chicken
10:15:13 <Rc43> kmc, because if I will doing brute force for finding a lot of numbers satisying some criteria it may waste all night but not just one minute
10:15:14 <kmc> criterion makes it dead simple
10:15:29 <copumpkin> so I intend to acquire popeye's chicken
10:15:31 <benmachine> Rc43: it might do. but you should check, instead of assuming
10:15:36 <kmc> Rc43, then you *definitely* want to spend 2 minutes figuring out which way is really faster
10:15:42 <kmc> cri
10:15:42 <kmc> ter
10:15:42 <kmc> ion
10:15:42 <kmc> Rc43, are you doing Project Euler?
10:16:04 <Rc43> benchmachine, I have checked it 5 minute ago
10:16:07 <Veinor> i just tried it in ghc, and squaring doesn't really get annoyingly slow until 1000000
10:16:09 <Rc43> kmc, yes
10:16:43 <Rc43> Veinor, for 10 000 000 it is about 1 sec for me.
10:16:46 <kmc> Rc43, did you compile with ghc -O2?
10:16:55 <Rc43> kmc, forgot =/
10:17:03 <Veinor> yes, that's 'annoyingly slow'
10:17:06 <Veinor> :P
10:17:10 <kmc> Rc43, you should know that PE is more about mathematical knowledge than skill at microoptimization
10:17:22 <Rc43> kmc, I know
10:17:30 <kmc> i think no PE problem is supposed to take running overnight
10:17:35 <parcs> it takes 1 second to compute (10^7)^2 ?
10:17:37 <benmachine> they're supposed to take 1 minute
10:17:52 <Rc43> kmc, i am talking not only for PE, i didn't think about it now
10:18:03 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in sum (take 20000 primes)
10:18:06 <lambdabot>   2137755325
10:18:18 <Rc43> parcs, map (^2) [1.. 10 000 000]
10:18:30 <benmachine> Rc43: in this case, good mathematics will help you much more than good programming
10:18:40 <kmc> and both will help you more than bad programming
10:18:50 <Cale> There's a draconian timelimit on lambdabot computations, but 100k will go rather quickly (just not under the 2s limit or whatever it is)
10:18:53 <Rc43> benchmachine, i know, why you are talking only for PE?
10:19:00 <kmc> lambdabot is also not compiling with ghc -O2
10:19:17 <benmachine> Rc43: I mean, for calculating factors of a number
10:19:34 <benmachine> Rc43: you're thinking about sqrt versus square, where really you should be using a different algorithm completely
10:19:34 <Rc43> -O2 is really nice
10:19:37 <benmachine> unless you don't care about speed
10:19:43 <Cale> Also, note that this version is cheaper than the even more naive version because it only checks the primes.
10:19:55 <Cale> (up to the square root)
10:20:16 <Rc43> benchmachine, ok, i understood
10:20:22 <Cale> There's no need to check all the numbers up to the square root, or even just the odd ones. Only check primes. :)
10:20:39 <benmachine> primes up to the square root :P
10:20:50 <Rc43> about -O2, can it reduce "length $ ......10000000." to just "10000000"?
10:20:53 <benmachine> I wrote an integer square root function once
10:20:55 <benmachine> it wasn't very good
10:21:13 <benmachine> Rc43: maybe, sometimes
10:21:22 <benmachine> I've heard llvm can do constant folding
10:21:26 <benmachine> or whatever it's called
10:21:54 <Cale> Rc43: no
10:22:16 <Cale> Well, it could, if there was a RULES pragma for it. But there isn't in the standard library.
10:22:42 <Cale> If you mean reducing  length [a..b] to b - a in the case of integers.
10:22:53 <Cale> er... b-a+1 ;)
10:23:02 <copumpkin> I think dons had a blog post about getting it to add up sum [1..100000] on UVector at compile time with -fvia-C
10:23:05 <copumpkin> a while ago
10:23:51 <benmachine> copumpkin: I thought that was llvm
10:24:05 <copumpkin> it was before llvm
10:29:50 <benmachine> http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/ this, anyway
10:30:38 <hpaste_> kmc pasted “factoring two ways (for Rc43)” at http://hpaste.org/51490
10:31:06 <KirinDave> kmc: So you were the one who sent me the link to the monatron stuff, right?
10:31:22 <kmc> don't think so
10:31:30 <kmc> oh, is that the monad zipper?
10:32:06 <KirinDave> Yea
10:32:13 <benmachine> kmc: oh, did squaring turn out to be faster after all?
10:32:17 <kmc> no
10:32:26 <KirinDave> I'm just confused. I read the paper, I even understand most of it.
10:32:38 <benmachine> k I can't read benchmarks clearly :P
10:32:46 <KirinDave> I don't see any downside at all, even in the slightest, to using this library.
10:33:10 <JoeyA> Does GHC 7 use LLVM (by default) now?
10:33:28 <KirinDave> So why do we still use mtl in ghc 7.>0?
10:33:31 <KirinDave> Just legacy?
10:33:47 <kmc> i don't know
10:33:53 <kmc> i don't know much about the monad zipper stuff
10:34:08 <benmachine> KirinDave: what's this link?
10:34:20 <benmachine> (but yes, mtl has lots of inertia)
10:34:31 <kmc> anyway mtl-2 is a wrapper for transformers + monads-fd, or something
10:34:35 <JoeyA> It's mentioned here: http://book.realworldhaskell.org/read/monad-transformers.html
10:35:02 <JoeyA> (mtl is)
10:35:17 <KirinDave> benmachine: So these guys made explicit the stack of monad transformers and then used a zipper-like newtype system to let you _explicitly_ interact with layers of the monad stack.
10:35:30 <KirinDave> benmachine: it makes it really trivial to, say, build things meant to run in the _middle_ of a monad stack
10:35:39 <KirinDave> It's not magical
10:35:49 <KirinDave> There are some considerations with how things can be composed because it uses open recursion
10:36:05 <KirinDave> Like for example, their fib decl makes an easy decision but implementing iteratees would be more subtle.
10:36:06 <benmachine> KirinDave: what is the actual address of the actual link :P
10:36:15 <KirinDave> Oh
10:36:40 <benmachine> sry I should possibly have said where instead of what
10:36:40 <KirinDave> benmachine: http://hackage.haskell.org/package/Monatron-0.3.1 and http://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/ifl2010.pdf
10:36:59 <KirinDave> They're working on a pearl paper too http://people.cs.kuleuven.be/~tom.schrijvers/Research/papers/monad_zipper_draft.pdf
10:37:44 <benmachine> thx
10:38:12 * benmachine puts it in the papers directory, where interesting things go to die
10:38:24 <DevHC> around when did the 1st release of the Safe extension come?
10:38:28 <DevHC> (by date)
10:38:35 <KirinDave> benmachine: I'd recommend trying to get to this one
10:38:37 <benmachine> it's new in 7.2
10:38:46 <DevHC> <DevHC> (by date)
10:38:54 <KirinDave> haha, day of miscommunication
10:38:59 <benmachine> DevHC: go look it up :P
10:39:12 <benmachine> http://haskell.org/ghc/
10:40:06 <DevHC> kthx
10:56:54 <stribor> is there zipWith that returns list rather then int
10:57:07 <mauke> zipWith returns a list
10:57:18 <Olathe> @type zipWith
10:57:19 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:57:26 <copumpkin> zipWith knows nothing of Int
10:57:31 <c_wraith> in fact, there are no numbers of any sort in zipWith
10:57:51 <Olathe> stribor: Do you have a simplified example of what you've tried and what you want?
10:58:27 <stribor> i dont....i am trying to figure myself...i missed when i was looking online that zipWith returns int
10:58:29 <stribor> sorry about that
10:59:44 <hpaste_> Satvik pasted “String Regex” at http://hpaste.org/51491
11:01:04 <mysticc> I was doing this for String ... but can not do it for ByteString .. can anybody help http://hpaste.org/51491
11:01:22 <Olathe> stribor: Oh, no problem.
11:01:33 <kmc> ByteStrings store bytes, not characters
11:01:35 <stribor> Olathe: thats for help
11:02:17 <mysticc> kmc: Cant find a similar function to do simple regex matching in Bytestring
11:03:23 <kmc> well, it would be a regular expression of bytes, not characters
11:03:54 <kmc> but anyway, i don't know of one, sorry
11:05:03 <mysticc> kmc: Ok thanks ... will convert to string then try the above .... will not make much difference because bytestring is not very long ..
11:05:17 <kmc> mysticc, what's the character encoding in the bytestring?
11:05:24 <kmc> there's many incompatible ways to convert a ByteString to a String
11:05:51 <mysticc> kmc: Its of type Data.ByteString.Lazy.Interna
11:06:02 <kmc> that doesn't determine the character encoding
11:06:12 <kmc> Strings hold Unicode characters
11:06:16 <mysticc> kmc: How to find the encoding ??
11:06:26 <kmc> there are many different, incompatible standards for how a Unicode character can be represented by a sequence of bytes
11:06:37 <kmc> these are called "encodings"
11:06:38 <mysticc> kmc: Its a html page
11:06:43 <kmc> ok
11:06:49 <kmc> you can go read about how HTML specifies encoding
11:06:51 <kmc> i think it's kind of a mess
11:07:32 <kmc> or you can just assume it's ASCII-compatible and only match ASCII characters
11:07:37 <kmc> that assumption may be wrong
11:09:40 <kmc> see also http://www.joelonsoftware.com/articles/Unicode.html
11:10:13 <kmc> the ByteString type doesn't specify encoding because it doesn't assume your data represents characters at all
11:10:21 <kmc> it's a string of *bytes*, like it says on the tin :)
11:10:32 <kmc> an encoding-tagged ByteString wrapper could be useful
11:10:51 <kmc> but if you want to work with it as characters, it's usually best to just convert to Text
11:12:16 <Olathe> Why aren't the list operators and functions polymorphic, Haskell, why?!?
11:12:24 <Peaker> Didn't the world converge on utf8 as the "One True Encoding (TM)"?
11:12:56 <Olathe> It would be so nice to be able to use list operations on bytestrings and so on.
11:12:57 <kmc> Olathe, (++) is polymorphic, it's just named "mappend"
11:13:07 <kmc> Olathe, why would it be nice?
11:13:08 <Olathe> Yeah, those long names are hard to use.
11:13:23 <kmc> Peaker, there's a lot of content that's not in utf-8
11:13:31 <kmc> even if it's supposed to go away, it's not going away any time soon
11:13:33 <Olathe> It makes the code verbose and ugly.
11:13:41 <Olathe> And you can't pattern match consistently.
11:14:09 <Olathe> It would be nice to recursively handle a bytestring like let f (a:as) = ...
11:14:11 <kmc> well, it would be hard to support pattern-matching ByteStrings without ViewPatterns
11:14:28 <kmc> you'd have to say let f (uncons -> Just (a,as)) = ...
11:14:31 <Olathe> I don't mean ViewPatterns, I think, but something like polymorphic constructors.
11:14:40 <kmc> ok, but that doesn't exist in GHC
11:14:44 <Olathe> I know.
11:14:46 <kmc> and would probably be rejected because ViewPatterns do
11:14:46 <Olathe> I wish it did.
11:15:16 * shachaf isn't really happy with ViewPatterns.
11:15:24 <kmc> the government standard character encoding in China (PRC) is GB 18030 which is not UTF-8
11:28:20 <ment> is there a pure-haskell module for reducing matrices to row echelon form (or general linear algebra package)?
11:29:05 <Gagis> ment hmatrix might be capable of all kinds of magic
11:29:22 <Gagis> I think it wraps at least lapack and blas and at least some features of gsl too
11:29:26 <ment> Gagis: can it work over arbitrary field?
11:29:40 <Gagis> Dunno. I havent got to try it properly yet.
11:29:43 <copumpkin> no
11:31:39 <ment> ok, any other suggestions?
11:36:14 <laar> is there some way to do the following  (part of arrow notation)?
11:36:15 <laar> vals <- pValues -< x
11:36:15 <laar> mappings <- pMapping vals -< x
11:37:54 <monochrom> that requires ArrowApply. when you have it, mappings <- pMapping vals -<< x
11:38:38 * laar thanks monochrom
11:38:50 <laar> I've got an arrow apply
11:42:34 <kmc> if you have ArrowApply then you can use the monad interface instead, no?
11:46:12 <monochrom> yes if you make a Monad instance
11:46:26 <laar> kmc, according to the ghc docs I could
11:47:00 <laar> sry I aready do, if I'm not mistaken
11:47:47 <laar> so, it looks like a need to do some more reading on arrows, does anyone know some good resources?
11:48:32 <kmc> why are you using arrows?
11:50:12 <laar> kmc, because it's fun and I would like to do something new
11:50:25 <kmc> ok
11:52:14 <c_wraith> So, what's the point of saying the maintainer of a package is libraries@haskell.org when I have to subscribe before I can send bug reports?
11:52:28 <c_wraith> Isn't that rather discouraging, when you want to report a problem?
11:52:39 <copumpkin> subscribe to libraries@ and tell people to stop doing that
11:52:49 <monochrom> haha
11:53:03 <monochrom> but I'm pretty sure the subscribe requirement is to fight spam
11:53:20 <Olathe> Do they have the openid things?
11:54:48 <monochrom> consider "what's the point of saying the maintainer of a package is dons@gmail.com when I have to guess how to be marked as non-spam by its spam filter before I can send bug reports"
11:55:16 <c_wraith> The difference is, it takes no work to not have a bug report be marked as spam.
11:55:27 <monochrom> I am not so sure of that
11:55:52 <c_wraith> Given how many I've received at my gmail address for the package I maintain, I'm pretty sure of it :)
11:56:29 <monochrom> someone else's spam filter is a black box. you don't know its secret rules. subscription is a white box, you know its rule and you know how to comply and it is 100% successful
11:56:53 <monochrom> well yeah dons@gmail.com is an example. consider sss@vex.net
11:56:53 <c_wraith> honestly, though, I'm not sure why this even exists.  This isn't a bizarre thing.  It's "haskell-src doesn't compile on ghc 7.2, and a one-line change fixes it"
11:57:40 <c_wraith> Seems like this should have been fixed before 7.2 was even released
12:02:44 <kmc> what's the change?
12:03:24 <Saizan> teh question is, why are you using haskell-src rather than haskell-src-exts ?
12:03:35 <kmc> that too
12:03:42 <kmc> hse has a better api also
12:03:48 <kmc> in my limited experience
12:04:15 <c_wraith> I'm not.  I'm fixing dependencies of hint
12:04:27 <c_wraith> and the change is removing the haskell98 build-depends entry
12:04:37 <monochrom> oh hi Saizan, do you want to deop yourself?
12:04:50 <Saizan> ah, yeah
12:04:54 --- mode: Saizan set -o Saizan
12:05:05 <kmc> c_wraith, i don't think external library brokenness is supposed to block a GHC release
12:05:09 <copumpkin> byorgey: congratulations!
12:05:10 <kmc> that's what Platform is for
12:05:19 <byorgey> copumpkin: thanks! =)
12:05:35 <copumpkin> byorgey: did you get lots of sleep the night before? I hear you won't be getting any for the next year or so
12:05:51 <copumpkin> :)
12:05:59 <byorgey> I did get lots of sleep the night before.  And none last night.
12:06:47 --- mode: ChanServ set +o Saizan
12:07:05 --- mode: Saizan set -b *!*paulh@*.onsnetstudenten.nl
12:07:10 <byorgey> should try doing some coding, just to see what comes out.
12:07:11 --- mode: Saizan set -o Saizan
12:07:37 <byorgey> but I doubt I can even summon the willpower.
12:14:06 <slack1256> apart from ghc, there is another compiler compliant of haskell 2010
12:14:17 <elliott> Has anyone used iterIO? I see it has no reverse dependencies on Hackage. Just wondering if anyone has any comments on it, whether they'd choose it over enumerator, etc.
12:14:27 <slack1256> also another maintained compiler (supero,yhc)
12:14:43 <elliott> slack1256: yhc is unmaintained
12:14:46 <elliott> unless someone picked it up
12:26:36 <parcs> elliott: it's supposedly simpler/more intuitive than other iteratee implementations
12:27:23 <elliott> parcs: The advantages touted on its homepage are definitely compelling, I'd just like to hear that /someone/ has used it before using a new, one-release library in a large project :P
12:27:34 <elliott> (The alternative is probably enumerator.)
12:40:21 * hackagebot system-argv0 0.1 - Get @argv[0]@ as a FilePath.  http://hackage.haskell.org/package/system-argv0-0.1 (JohnMillikin)
12:42:19 <georgevdd_> Anyone care to help me with ghci vs editline when resuming (using fg) in a terminal?
12:42:56 <georgevdd_> After resuming, moving to previous history items doesn't display them, though they are still reused on pressing Enter
12:43:32 <Saizan> version of ghc?
12:43:45 <georgevdd_> v6.12.3
12:43:51 <georgevdd_> so, using editline I believe
12:44:02 <georgevdd_> same behaviour on OSX or on Ubuntu
12:44:30 <georgevdd_> and the problem only occurs after suspending (with C-z) and then resuming
12:44:49 <georgevdd_> it's a minor bug but pretty annoying
12:44:57 <shachaf> georgevdd_: I can reproduce the behavior on GHC 6.12 but not on 7.
12:45:02 <shachaf> So upgrading might work. :-)
12:45:13 <georgevdd_> haha, that's ... disappointing ;)
12:45:26 <georgevdd_> guess I'll give that a shot - thanks
12:45:46 <mzero> do either of you know how to force a 64-bit build when building GHC on Mac OS X?
12:45:48 <shachaf> Hmm, in fact, when I suspect and then resume ghci 6.12, no keyboard input is visible.
12:45:54 <mzero> (or anyone here for that matter)
12:47:14 <georgevdd_> oh, nor do I ...
12:47:23 <georgevdd_> ... see any input at all when resuming
12:47:59 <georgevdd_> I'm sure it's some kind of terminal settings issue
12:48:10 <georgevdd_> because it works to begin with
12:48:43 <dylukes> mzero: What OS X version?
12:48:51 <mzero> 10.7 (ducks)
12:48:54 <dylukes> If you're not running Lion, just get 7.0.4 through brew.
12:49:12 <dylukes> uh, I have a custom brew formula you can use for 7.2.1, but it won't support the haskell-platform package
12:49:21 <dylukes> but, thats what you get for using 7.2.1
12:49:37 <mzero> georgevdd: what happens if you reset (or hard reset) the terminal when in that state?
12:49:57 <georgevdd_> mzero: how?
12:50:17 <mzero> dylukes - I'm trying to build 7.0.4 --- because I'm trying to build the package for Haskell Platform
12:50:35 <dylukes> Oh right, 7.0.4 doesn't work :)
12:50:39 <dylukes> it will install, but it can't compile
12:50:46 <dylukes> it will only work for interpreted mode.
12:50:52 <mzero> georgevdd: on Mac OS X's Terminal app, Shell menu (or clover-R and option-clover-R)
12:50:54 <dylukes> there's a bit of a conundrum currently.
12:50:57 <georgevdd_> mzero: nothing, but I just noticed that my input *is* printed once I press Enter
12:51:03 <georgevdd_> so perhaps this is a line control issue
12:51:03 <dylukes> 7.0.4 will not work. 7.2.1 will.
12:51:17 <dylukes> But then you don't get the haskell-platform, and you'll have to install cabal yourself :P
12:51:27 <mzero> dylukes - alas, HP 2011.3.0.0 includes 7.0.4 -- I don't get to change that
12:51:32 <dylukes> (it has some incorrect dependencies hardwired in bootstrap.sh)
12:51:40 <dylukes> mzero: give up on HP for now on OS X
12:51:43 <mzero> dylukes - I *am* the packager of HP
12:51:45 <mzero> for Mac OS X
12:51:58 <dylukes> mzero: Oh, well, 7.0.4 doesn't work on Lion.
12:52:00 <mzero> I'm the one trying to build a working HP for people
12:52:00 <dylukes> So give up.
12:52:03 <dylukes> It just does not work. Period.
12:52:10 <dylukes> It will not compile, because of incompatibilities with ld.
12:52:30 <shachaf> Defeatist.
12:52:55 <mzero> what if it is built on 10.6 --- it seems to compile code just fine, but fails in the link step -
12:52:59 <dylukes> mzero: https://github.com/mxcl/homebrew/pull/6925
12:53:03 <mzero> but only with respect to HSinteger-gmp
12:53:56 <dylukes> It will fail linking to almost any core packages.
12:54:52 <DevHC_> in http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html#safe-trust,
12:54:58 <DevHC_> what is the significance of "All of M's direct imports are trusted by C"?
12:55:03 <mzero> 'k - it only reports on that one , but imagine it could just fail on the next, eh?
12:55:15 <dylukes> exactly.
12:55:18 <mzero> I'm surprised, since I am using Xcode 3.2.3 on 10.7
12:55:23 <inetic> guys, how do I convert from an Integer/Int/Int32/... to ByteString, I tried `encode num` but it seems encode encodes to Data.ByteString.Lazy.Internal.ByteString instead of Bytestring.
12:55:23 <dylukes> It's just because ld is a lot whinier.
12:55:26 <DevHC_> ie. is there a module which successfully compiles, without "All of M's direct imports are trusted by C" being true?
12:55:30 <mzero> and my 7.0.2 GHC install works just fine
12:55:37 <dylukes> mzero: The bottom line is, 7.2.1 compiles fine,
12:55:44 <edwardk> @ask tibbe did you ever determine if an empty Array# was valid?
12:55:44 <lambdabot> Consider it noted.
12:55:48 <dylukes> but they won't accept my patch until there's a haskell platform that is compatible with 7.2.1
12:55:52 <dylukes> which there isn't, yet.
12:55:55 <DevHC_> successfully compiles with -XSafe*
12:56:03 <dylukes> So, we're waiting for the HP folks.
12:56:13 <georgevdd_> inetic: what do you want in your bytestring? An ASCII representation of the decimal representation of the number, or something else?
12:56:24 <DevHC_> and similarly, what is the significance of "All of M's direct safe imports are trusted by C"?
12:57:21 <inetic> georgevdd_, I want a 4-byte representation of the number (non textual)
12:57:40 <georgevdd_> inetic: and do you care about byte ordering?
12:57:40 <inetic> georgevdd_, want -> would like :-)
12:58:01 <inetic> georgevdd_, yes
12:58:09 <georgevdd_> inetic: network byte order?
12:58:37 <inetic> georgevdd_, the default on x86, believe it's little endian
12:59:29 <mzero> dylukes: well, I don't know why Duncan has suggested that HP will skip 7.2.1 -- I just try to build and package what is in the master HP .cabal file.... though it is pretty big feedback if 7.0.4 won't work on Lion
12:59:43 <inetic> georgevdd_, (I'm writing a binary file, later I'll be reading it from C)
13:00:00 <georgevdd_> inetic: toChunks will take you from lazy ByteStrings to strict ones
13:00:04 <georgevdd_> does that help?
13:00:27 <dylukes> mzero: 7.0.4 _will not work_
13:00:30 <inetic> georgevdd_, hold on
13:00:34 <dylukes> this has been established for a while
13:00:38 <dylukes> we just need to wait for a HP that works
13:00:39 <mzero> I'm assuming by your patch, you mean the one you pointed me to.... do you have any pointers to what the actual 7.0.4 incompatibility is? What I was trying to do was just rebuild 7.0.4 from scratch on 10.7, hoping that with a consistent build environment it might just owrk
13:00:42 <mzero>  
13:01:04 <dylukes> It wont.
13:01:09 <dylukes> I tried a hundred times, so has dankna
13:01:15 <mzero> I get it - I want to know why
13:01:40 <mzero> because, see, if you're waiting for an HP on Mac OS X 10.7 --- you're ultimately waiting on me! :-)
13:02:13 <mzero> and I'm trying' real hard to get a full grasp of the issues here
13:02:20 <dankna> I'm not actually waiting haha
13:02:24 <dankna> I haven't tried a hundred times
13:02:27 <georgevdd_> shachaf: thanks! Upgrading to 7.0.3 worked.
13:02:29 <dankna> but I tend to run custom-built GHCs
13:02:33 <dylukes> dankna: ^
13:02:38 <dylukes> dankna has a .pkg version of 7.2.1
13:02:41 <dankna> so the prepackaged HP is not really necessary for me personally
13:02:41 <dylukes> he posted it on g+ a while ago
13:02:49 <dylukes> Yeah, I don't really need the HP  :\
13:02:57 <dankna> dylukes: there's a distinction though between HP's .pkg and GHC's .pkg
13:03:00 <dankna> the latter is what I have
13:03:01 <dylukes> I just install GHC, then bootstrap cabal, and I'm good to go.
13:03:04 <dylukes> dankna: I know.
13:03:06 <inetic> georgevdd_, shame I have to import yet another module for one function (Data.ByteString.Lazy) but, it does work, many thanks!
13:03:09 <dankna> now
13:03:10 <dylukes> That's why I said of 7.2.1 :P
13:03:14 <dankna> for attracting new users
13:03:18 <dylukes> HP is great for that.
13:03:21 <dankna> it would be nice to have HP
13:03:41 <dankna> mzero: can you hpaste the errors you're getting?
13:03:45 <dankna> I might be able to help you diagnose them
13:04:37 <siracusa> Can anyone point me to the exact syntax of Cabal package names? I cannot find it in the Cabal docs.
13:04:39 <hpaste_> mzero pasted “7.0.4 on 10.7 link error” at http://hpaste.org/51501
13:04:52 <dankna> oh wow
13:04:53 <dankna> interesting
13:04:57 <dankna> integer-gmp isn't building
13:05:13 <georgevdd_> inetic: it kind of makes sense. It'll be much more efficient to write out a lazy list of (large) strict bytestrings than a lazy list of tiny lazy bytestrings
13:05:14 <dankna> or rather, isn't linking
13:05:18 <mzero> no - it is built- that is the built version that came from GHC center al's 7.0.4 pkg
13:05:31 <mzero> it is that things compiled with that compiler won't link against that lib
13:05:32 <dankna> right, I misspoke
13:05:33 <dankna> hmm
13:06:14 <dankna> apparently gcc has hit the same problem (I googled "pointer in read-only segment not allowed in slidable image")
13:06:23 <mzero> when I build HP for Mac, I take GHC's official Mac .pkg, unpack it into a sandbox, and then build the HP additional packages with the sandboxed compiler
13:06:30 <dankna> I see
13:06:35 <dankna> is this sandbox a full chroot?
13:06:57 <mzero> yeah - when I googled it I came across people who had systems with confused macports based libs and non-macports based libs
13:07:00 <dankna> doesn't seem to be specific to Lion
13:07:11 <dankna> yes, makes sense.  running in a chroot is a good idea.
13:07:33 <dankna> so that does rule out a wrong version of gmp someplace else
13:07:40 <mzero> so my next thought was the perhaps GHC 7.0.4 was built in an incompatible environment with 10.7, so I thought I'd try building GHC on 10.7 - but that doesn't seem to work
13:07:56 <dankna> nor is it going to, you need a newer GHC to build on 10.7
13:08:07 <dankna> I would actually think that maybe GMP is the problem
13:08:12 <dankna> and in need of rebuilding
13:08:19 <mzero> actually, I don't need to chroot - the tools and GHC both have enough env variables to get them to all look in the right places
13:08:28 <dankna> hmm, if you're sure
13:08:52 <mzero> well, at least in this case - I can see that yes indeed, that is sandboxed version
13:08:56 <dankna> anyway as I say, GHC 7.0.4 is not compatible with Lion
13:09:13 <dankna> (because of gcc being legacy-fied by Apple)
13:09:18 <mzero> so what changed in 7.2.1 to make it compatible?
13:09:37 <dankna> we (against my advice and in a great hurry, haha) learned to compile with clang-llvm instead
13:09:42 <mzero> ah - but that isn't the case on my system ---- gcc is gcc, not llvm-gcc
13:09:43 <dankna> er
13:09:47 <dankna> llvm-gcc
13:09:54 <dankna> really?
13:09:57 <dankna> you built it custom then?
13:10:02 <mzero> yes - I don't have Xcode 4 installed on purpose
13:10:06 <dankna> gotcha
13:10:11 <dankna> okay, so you should be able to build it
13:10:12 <mzero> I have only Xcode 3.2.3
13:10:21 <dankna> I still think GMP could probably do with a rebuild
13:10:27 <mzero> (I've been holding my system back rev anticipating the need for this particular build)
13:10:32 <dankna> gotcha
13:11:02 <dankna> because looking at what the error actually means
13:11:04 <mzero> right - alas, can't get the GHC 7.0.4 tree to rebuild on my system... seems to be no way to bootstrap a 64 bit build from a 32 bit 7.0.2
13:11:16 <mzero> sigh
13:11:35 <dankna> true, you have to start from a 64-bit binary
13:11:43 <dankna> or back all the way up to like 6.8 when cross-compiling still worked
13:11:48 <dankna> and build successive versions off of that
13:11:57 <dankna> which takes, to a first order of approximation, forever
13:12:27 <mzero> right - sigh, my cross compilation fixes (substantially improved by Ian) didn't make it into the build until 7.2.mumble
13:12:31 <dankna> gotcha
13:13:01 <dankna> anyway the error is telling you
13:13:13 <dankna> that Lion now uses address-space randomization by default
13:13:24 <dankna> that is, libraries are loaded at random addresses rather than fixed ones
13:13:33 <dankna> as a security measure - it makes it harder for injected code to do anything
13:13:40 <mzero> ah - wonder if there is a link flag that would turn that off
13:13:54 <dankna> probably, but anyway, furthermore it's saying that the version of GMP.framework that you are running against
13:14:23 <dankna> uses a pointer to its own data
13:14:29 <dylukes> Ruby is useful for shit like this.
13:14:30 <dylukes> https://gist.github.com/1225552
13:14:36 <dankna> in a segment that can't be modified at load time because it is read-only
13:14:46 <dankna> since this broke not just us but gcc and guile as well
13:14:48 <dylukes> (i.e, as a slightly nicer shell script)
13:14:58 <dankna> they MUST have fixed it upstream by now
13:15:03 <dankna> so you should acquire and build the latest GMP
13:15:42 <dankna> note that unless you're particularly aware of the issue, you probably have /Library/Frameworks/GMP.framework from ages ago, way out of date
13:15:54 <KirinDave> dylukes: Well if there was an import statement for all the salient libraries, Haskell isn't much differet.
13:16:12 <mzero> I am, in fact, aware of the old GMP things that plague us!
13:16:16 <dankna> okay :)
13:16:23 <dylukes> KirinDave: True, you could write the same thing in haskell easily too, though maybe with a little more effort.
13:16:48 <KirinDave> dylukes: I think what the secret sauce is there is the `` syntax.
13:16:52 <dylukes> Yep.
13:16:54 <dylukes> ;P
13:17:08 <dylukes> It's quasiquoting to sh
13:17:12 <dylukes> nothing you couldn't' accomplish in TH.
13:17:27 <dylukes> Just have TH generate the required mess [sh| ... |]
13:17:29 <dylukes> from *
13:17:36 <dylukes> or something like that.
13:21:14 <MHD> Is there, like, a haskell/type inference/type theory/category theory joke compilation?
13:21:45 <elliott> MHD: http://tunes.org/~nef/logs/haskell/
13:22:02 <KirinDave> dylukes: I guess this is a thing? https://github.com/jgoerzen/hsh/wiki
13:22:17 <dylukes> that's convenient :P
13:23:10 <dolio> edwardk: So, I looked in the implementation of iteratee, and it looks like they handle Done x (Chunk []) specifically, making it actually a monad.
13:23:59 <edwardk> hrmm
13:23:59 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
13:23:59 <kmc> oh, that's a fun idea dylukes
13:24:19 <dolio> Done x (Chunk []) >>= f = f x, effectively.
13:24:21 <dylukes> kmc: I was thinking of data I could plot with d3.js
13:24:23 <edwardk> yeah
13:24:24 <dylukes> and I thought, oh, my deps.
13:24:25 <dylukes> :\
13:24:30 <edwardk> i recall that from my slides actually =)
13:24:35 <dylukes> so... here I am.
13:24:43 <dolio> Except they have all kinds of CPS going on.
13:25:11 <kmc> dylukes, so what Haskell expression should [sh|  ... |] expand to?
13:25:20 <dylukes> I have no clue.
13:25:23 <dylukes> Something in IO, no?
13:25:47 <kmc> i guess a call to readProcessSource
13:25:51 <kmc> err readProcess
13:25:53 <kmc> bad haddock
13:26:06 * dylukes slaps kmc with a smelly haddock.
13:26:12 <edwardk> glad i never finished that article then ;)
13:26:16 <kmc> 'cause you want to use its output as a string, no?
13:26:44 <kmc> dylukes, but you want string interpolation
13:26:52 <kmc> so probably i should wrap one of the existing interpolation quasiquoters
13:27:00 <kmc> except it'd be nice to sh-escape the interpolated strings
13:27:01 * kmc ponders
13:28:31 <dylukes> yay I have json deps
13:28:37 <dylukes> now time to do something with them
13:28:51 <shachaf> Convert them to YAML?
13:29:08 <KirinDave> Are type families a newer extension of haskell?
13:29:18 <kmc> yeah
13:29:22 <kmc> they arrived in GHC 6.10+
13:29:27 <dylukes> Type Families and MultiParamTypeClasses are TheCoolThingToDo™
13:29:30 <dylukes> FunDeps are so out.
13:29:33 <kmc> i don't know if they were implemented in another compiler earlier
13:29:41 <KirinDave> Because I see a lot of code  that doesn't use them and probably could.
13:29:41 <kmc> though the idea of type-indexed families of types is old
13:29:48 <kmc> KirinDave, yeah
13:29:54 <kmc> like HList
13:30:01 <kmc> oh god, HList
13:30:03 <KirinDave> dylukes: I wish RWH didn't just brush past fundeps as "a complex thing"
13:30:10 <kmc> meh
13:30:10 <shachaf> Has any compiler implemented the new constraint kinds thing?
13:30:16 * shachaf is looking forward to that in GHC 7.4.
13:30:17 <kmc> shachaf, GHC HEAD
13:30:23 <dylukes> The Constraint Kinds thing looks neat.
13:30:27 <KirinDave> What is that?
13:30:30 <dylukes> Will this allow me to do type level type membership testing?
13:30:31 <dylukes> ie
13:30:31 <benmachine> shachaf: you say that like there's more than one compiler >_>
13:31:00 <dolio> Fundeps are a complex thing. No one can agree on what they should actually mean.
13:31:15 <shachaf> They mean that one thing depends on another thing.
13:31:17 * shachaf saves the day.
13:31:28 <kmc> KirinDave, my 2¢ is that beginners massively overuse type classes, and extensions enable that... common to see beginner code with {-# LANGUAGE FlexibleInstances, OverlappingInstances, UndecidableInstances, BizarroInstances #-} and a dozen classes and instances, when they could, like, pass a function to a function and be done
13:31:31 <dolio> shachaf: I've had people argue that point.
13:31:43 <kmc> KirinDave, so I think covering fundeps in RWH, which is a sort of intro book, would be counterproductive
13:31:57 <KirinDave> kmc: I see.
13:32:05 <shachaf> RWH is supposed to be a sort of intro book?
13:32:11 <kmc> KirinDave, however I really like the topics chapters in RWH, and I think a topic chapter on type / class hackery would be fun.  but maybe it belongs in Advanced World Haskell
13:32:15 <hpc> kmc: at the moment, my idea of classes is just as a way to say "this thing obeys these laws if you use these functions"
13:32:22 <Saizan> there's a very simple meaning from database theory, though ghc let you break that..
13:32:27 <kmc> Warp Zone Haskell
13:32:31 * shachaf uses LANGUAGE BizarroInstances all the time.
13:32:45 <KirinDave> I don't even know what BizarroInstances does
13:32:53 <shachaf> You don't want to.
13:32:53 <hpc> KirinDave: it's made up
13:32:56 <KirinDave> Oh
13:32:57 <KirinDave> Dang
13:33:06 <KirinDave> See I was like, "I am prepared to be owned again
13:33:20 <KirinDave> Some kind formal specification for bizarro-ness.
13:33:21 <hpaste_> ocharles pasted “Understanding type families” at http://hpaste.org/51502
13:33:24 <hpc> KirinDave: there's incoherent instances though, and seriously don't learn that
13:33:32 <shachaf> KirinDave: It's actually a synonym for FunctionalDependencies.
13:33:36 <hpc> in fact, forget i told you they exist
13:33:40 <KirinDave> Ha
13:33:42 <KirinDave> Well
13:33:42 <ocharles> Hi, I'm trying to understand the use of type synonyms with type families in type classes, but the above doesn't compile
13:33:54 <Saizan> the day BizarroInstances looks legit i believe should also be the day we stop adding extensions to GHC
13:33:59 <ocharles> I'd expect it to print '1', but I must be missing something...
13:34:16 <shachaf> Saizan: That day has passed, sadly.
13:35:16 <kmc> I believe the thought process is roughly "Java requires a thing here, so Haskell must also require a thing, and it looks like that thing is type classes"
13:35:21 <ocharles> when I compare to http://www.haskell.org/haskellwiki/GHC/Indexed_types#An_associated_type_synonym_example - it looks like my code should work (to me, of course :>)
13:35:21 * hackagebot csv-enumerator 0.9.3 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.9.3 (OzgunAtaman)
13:35:36 <parcs> ocharles: what is the error?
13:35:41 <ocharles> oh, that'd help
13:35:57 <kmc> the true functional programming solutions are usually in the "so clear and obvious that you would never think of it" category
13:36:22 <KirinDave> kmc: I feel that way about iteratees.
13:36:24 <ocharles> the error is https://gist.github.com/1225574
13:36:25 <parcs> ocharles: i think you mean `foo "Hello"`, not `Waffle "Hello"`
13:36:38 <kmc> (i'd rather say "pure FP" rather than "true FP" but y'all have overloaded that term)
13:36:47 <ocharles> parcs: I mean foo $ Waffle "hello", but the compiler catches the actual problem
13:36:59 <ocharles> (this code is just meant to illustrate my actual larger code which has the same compile problem)
13:37:46 <shachaf> ocharles: bar :: Test a => Blah a -> Int, but you're calling it with a particular instance of Blah.
13:38:03 <shachaf> ocharles: (This is using the general function bar, not the one defined in the specific instance.)
13:38:17 <shachaf> Er, Blah from a particular instance of Test.
13:38:22 <shachaf> Wait, never mind.
13:38:24 <KirinDave> ocharles: I do not see how your example is consistent. Waffle never enters into your instance.
13:39:07 <KirinDave> Blah is supposed ot be  aplaceholder for a variety of things, but it can't magically convert Waffle to (a, bs)
13:39:10 <ocharles> I'm not sure if I follow that, I create a Waffle in main. (I'm meant to call 'foo' on it too)
13:39:23 <ocharles> I create that tuple in the foo function though
13:39:53 <shachaf> ocharles: How is it supposed to figure out which instance of Test to use in Bar?
13:40:15 <ocharles> ah, a good point :)
13:40:28 <KirinDave> Yeah
13:40:48 <KirinDave> It gets through the "foo" part just fine.
13:40:52 <ocharles> My options are a proxy return value then, or an extra ignored parameter?
13:41:52 <ocharles> data Proxy a = Int, bar :: Blah a -> Proxy a. then foo can ask for "bar (...) :: Proxy a" with XScopedTypeFamilies
13:42:12 <ocharles> how does it work in http://www.haskell.org/haskellwiki/GHC/Indexed_types#An_associated_type_synonym_example though?
13:42:32 <ocharles> How does insert know which "Elem ce" to take?
13:42:45 <stribor> .
13:42:55 <kmc> KirinDave, I don't know... the iteratee idea is pretty compelling, but the APIs I've actually seen look kind of nasty
13:43:08 <kmc> I'm waiting for things to shake out a bit more before i commit to iteratees
13:43:35 <kmc> that's why e.g. Hdis86.Incremental exposes a simpler API you could build an enumeratee (?) out of, but doesn't actually bind to an iteratee library
13:43:55 <kmc> it also lowers the cognitive barrier to using the library
13:43:57 <KirinDave> kmc: The big problem with writing iteratees is that they use a "continue step where step _ = …" pattern
13:44:01 <joachi> why are type systems, type thery such a big deal?
13:44:03 <kmc> since knowledge of iteratees is not widespread
13:44:10 <KirinDave> kmc: The type inference almost always goes totally insane if you make the slightest error
13:44:21 <KirinDave> And the way that where clauses cook out means that it can be very hard to debug
13:44:31 <kmc> joachi, because they help you catch errors at compile time, help you structure code, help you automate testing and refactoring...
13:44:33 <KirinDave> I've learned to write each clause one at a time, compling each time as you go.
13:44:41 <KirinDave> And to always write the EOF one first since it's usually the simples.
13:44:42 <parcs> ocharles: the problem is that what if another instance of test is instatiated with type Blah C = (Int, [Int]) ?
13:44:55 <ocharles> parcs: Yea, I get the issue
13:45:04 <kmc> you may protest "Well, Java's type system doesn't do any of those things"... that's right, that's why you need the theory.  they haven't got it
13:45:11 <ocharles> but I don't quite see how the wiki example doesn't do any extra magic and it just seems to work
13:45:13 <parcs> ocharles: the answer is to use data type/newtype families
13:45:15 <kmc> you need a good type system for it to be worth while
13:45:17 <joachi> kmc: is that so? do you know of any text about such advantages?
13:45:26 <parcs> they ensure an injectivity of the type function
13:45:41 <kmc> joachi, most intro books on Haskell will spend some time on this
13:45:54 <hpc> joachi: https://secure.wikimedia.org/wikibooks/en/wiki/Haskell/The_Curry-Howard_isomorphism
13:46:05 <hpc> joachi: not entirely a friendly intro, but the gist of it is that every type is a proof
13:46:05 <kmc> meh, I think Curry-Howard is a side note in most languages
13:46:14 <kmc> if you're using Coq or Agda, that's something else
13:46:28 <kmc> but e.g. Haskell's type system is unsound as a logic
13:46:41 <parcs> ocharles: in the wiki example no class method is calling another class method
13:46:44 <danharaj> What are you talking about, of course bottom is inhabited!
13:47:00 <ocharles> parcs: ah, yes
13:47:01 * danharaj moons the monitor
13:47:17 <kmc> also every type is a *proposition* and every *term* is a proof
13:47:38 <parcs> ocharles: http://paste.pocoo.org/show/478229/ see there for a solution
13:48:09 <joachi> is it because of this i get errors more often when writing in haskell than in other languages and then the errors are most often type errors?
13:48:11 <dylukes> kmc: You actually going to write that QQ?
13:48:31 <ocharles> parcs: oh yes, that's a good enough solution for me
13:48:48 <ocharles> thanks!
13:49:18 <parcs> no problem
13:49:36 <KirinDave> parcs: You should add the difference between these two to the wiki, man
13:49:41 <KirinDave> parcs: That's extremely illustrative.
13:49:51 <kmc> joachi, more errors or more compile-time errors?
13:50:06 <kmc> 'cause static types turn runtime errors into compile-time errors, and that's a very good thing
13:50:07 <joachi> compile-time errors
13:50:21 <KirinDave> Yeah well write iteratee code
13:50:29 <kmc> (it's a good thing which is at odds with human psychology, but that's a side note)
13:50:36 <KirinDave> then ask yourself if these are really runtime errors or just boneheaded syntax making it hard to specify what types you want.
13:50:45 <kmc> yeah, no library is perfect
13:51:05 <kmc> also the other correct answer for most people who ask "why do i get so many errors in haskell" is "you haven't learned haskell yet"
13:51:26 <kmc> Haskell makes you think hard up front, and be precise about what you want, and the reward is software that works
13:51:39 <kmc> as opposed to banging out lots of nonsense code and patching it up post-hoc
13:51:45 <KirinDave> Although
13:51:49 <KirinDave> If what you want is not very complex
13:51:58 <KirinDave> Or rather, the common case is not very complex
13:52:09 <KirinDave> Haskell makes you march through the same weeds even though you may not care.
13:52:14 <kmc> yeah
13:52:21 <kmc> but the overhead gets smaller as you learn more
13:52:26 <KirinDave> It's a trade off, albeit one that seems obviously frightening to make.
13:53:09 <kmc> it turns out that many things which people will tell you are essential advantages of dynamic typing actually have a better treatment in Haskell, even though statically checked
13:53:31 <kmc> e.g. algebraic data types, testing, refactoring
13:53:48 <edwardk> TIL if you don't care about the order of the set bits you extract from a number you can avoid the table lookup in debruijn-multiplication-based set bit indexing
13:56:20 <DevHC^> what's the difference between http://hackage.haskell.org/trac/ghc/ and http://hackage.haskell.org/trac/ghc2/ ?
13:57:24 <kmc> my theory is that "banging out lots of nonsense code" and "hunting down bugs" both feel like getting shit done, and so are psychologically rewarding, even though they mostly canceling out
13:57:45 <KirinDave> Where did I get cut off
13:57:50 <kmc> staring at an empty editor thinking really hard just makes you feel dumb
13:57:54 <KirinDave> Did my shit about matasano escape the fireball of my wireless failing?
13:58:07 <kmc> even if you then emit a 2-line fold function which solves the problem perfectly with no bugs
13:58:10 <kmc> even if you save time in net
13:58:19 <kmc> KirinDave, the last i got was <KirinDave> It's a trade off, albeit one that seems obviously frightening to make.
13:58:20 <KirinDave> kmc: I wrote a whole thing about how hard it is to dedicate yourself to failing hard for months as an adult professional.
13:58:26 <KirinDave> So I was saying
13:58:26 <DevHC^> and wtf is http://hackage.haskell.org/trac/igtest/ ?
13:58:41 <kmc> oh, cool, I want to read
13:58:42 <KirinDave> I know some matasano guys. They talk to me about how they don't run into haskell code often
13:58:57 <KirinDave> but in general, if they do, it is not something they can do any real exploits on
13:59:10 <KirinDave> "unless it's something inter-protocol, like exploiting encoding errors.
13:59:13 <kmc> what's matasano?
13:59:23 <kmc> a security lab?
13:59:26 <KirinDave> A pretty big-deal security consulting company
13:59:55 <KirinDave> kmc: My essay with a deliberately provocative title was at: http://dave.fayr.am/posts/2011-08-19-lets-go-shopping.html
14:00:11 <kmc> it's all about provocative titles :)
14:00:19 <KirinDave> I'm working on a new essay about how ruby programmers already pine for monadic code every time they use ||= and &&=
14:00:24 <KirinDave> They just have a shitty type system for doing it.
14:00:51 <kmc> i like your headline font
14:00:57 <KirinDave> ty
14:01:07 <KirinDave> Kinda went for an old school newsletter.
14:01:15 <KirinDave> I dunno why firefox is being a bitch about the body font tho...
14:05:44 <mysticc> hey .. Is there a method by which I can apply a list of functions to the same argument and result the result .. somewhat opposite of map
14:06:32 <kmc> yes
14:06:38 <KirinDave> Oh kmc.
14:06:39 <kmc> > map ($ 3) [pred, succ]
14:06:40 <lambdabot>   [2,4]
14:07:39 <KirinDave> Doesn't <*> for List do that too?
14:08:18 <copumpkin> > flip [pred, succ] 3
14:08:19 <lambdabot>   [2,4]
14:08:30 <copumpkin> KirinDave: not really
14:08:38 <copumpkin> > [pred, succ] <*> [3]
14:08:39 <lambdabot>   [2,4]
14:08:48 <copumpkin> > sequence [pred, succ] 3
14:08:49 <lambdabot>   [2,4]
14:09:29 <KirinDave> Oh I misread the sequencing requirement.
14:09:50 <kmc> KirinDave, "In an industry that changes as rapidly as software engineering does"... see, I think it *doesn't* change that rapidly, for the reasons you spell out
14:10:03 <kmc> the syntax we're using this month for ALGOL or S-expressions does change
14:10:30 <kmc> the boundary of the possible changes, in terms of raw computational power
14:10:35 <kmc> but our methods don't change very much
14:10:38 <kmc> and our tools don't
14:12:49 <KirinDave_> ugh, this wifi.
14:12:54 <KirinDave_> reboot reboot reboot.
14:13:14 <KirinDave_> kmc: I think that the kinds of things we write change in their focus and application all the time.
14:13:22 <KirinDave_> kmc: What I write now is very different from what I wrote in 2004.
14:13:40 <ousado> kmc: in comparison to which other industry doesn't it change fast?
14:14:03 <mzero> :t flip
14:14:03 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
14:14:15 <mzero> ah - not your Prelude's flip
14:14:35 <KirinDave> kmc: I knew more than a few people who would conspiratorially lean over the table and tell me—with some relief—that they don't have to learn anything else after rails.
14:14:47 <KirinDave> kmc: A wink and a sip of beer would convince them to confide that the web is the "final frontier."
14:15:08 <kmc> ousado, i mean that the common wisdom is "software changes very rapidly" and I'm saying that a lot of the change is superficial
14:15:17 <KirinDave> Except here we are going back to these weird little special-purpose mobile apps like we're all happy windows 1.0 or MacOS 6 programmers.
14:15:24 <kmc> KirinDave, yep.  time-sharing on central infrastructure is the future
14:15:32 <monochrom> every generation thinks its work is the final word. this is why death is so beautiful.
14:15:33 <kmc> did i say "time-sharing on central infrastructure"? i meant "the cloud"
14:15:47 <KirinDave> kmc: One day there will be a compuer. In every pot.
14:15:56 <KirinDave> s/puer/puter/
14:16:05 <KirinDave> although Pu'er is delicious.
14:16:21 <kmc> and yeah, it's super weird that desktop apps are moving to The Cloud, and simultaneously Apple's push for HTML5 phone apps was rejected and now they're local, native code in Objective fucking C
14:16:35 <KirinDave> Personally I like ObjC
14:16:44 <kmc> sure, but it's not exactly the Web 2.0 of programming languages
14:16:46 <KirinDave> most of the benefits of C++, much less of the unfolding and fractal insanity of that space.
14:16:59 <kmc> it's an old-school, memory-unsafe, local native code C linkage sort of language
14:17:04 <KirinDave> All my C++ friends are super into typelists.
14:17:09 <KirinDave> I just look and sigh.
14:17:27 <KirinDave> "It's almost like you've got compiler hooks."
14:17:31 <kmc> anyway we're prolly veering too far here into "You know what sucks? Languages that aren't Haskell"
14:17:42 <KirinDave> ah
14:17:48 <kmc> i will finish reading your article :)
14:17:51 <KirinDave> I like ObjC.
14:17:54 <KirinDave> I stand behind that.
14:19:17 <kmc> KirinDave, so you said "I wrote a whole thing about how hard it is to dedicate yourself to failing hard for months as an adult professional"
14:19:21 <kmc> can you elaborate?
14:19:54 <mamalujo> KirinDave: I don't disagree, but its syntax at first glance at least looks a bit schizoid w 2 notations crammed into one lang
14:20:01 <KirinDave> kmc: Sorta "Your first time wasn't gentle"
14:20:04 <DevHC^> does GHCi work with -XSafe?
14:20:09 <kmc> ah
14:20:17 <KirinDave> kmc: And novelty.
14:21:30 <KirinDave> kmc: "That requires patience and dedication on a level that most professionals reserve only for actually completing clear business goals. Very few people feel comfortable failing-let alone failing over and over- once they’re out of their formative years. We’re all supposed to be professionals now, right?"
14:22:20 <KirinDave> To someone like me who is steeped in the OO tradition from the very beginning of my real programming years, coming to haskell at age 30 is sorta like asking me to be 7 again. It can be very frustrating.
14:22:28 <kmc> *nod*
14:22:52 <kmc> this is one reason why schools should expose you to more ideas
14:24:13 <joachi> the very first course in my computer science program is introductory functional programming using haskell :)
14:24:23 <KirinDave> Nice.
14:24:29 <KirinDave> In mine it was java, doing UI programming
14:24:57 <Nimatek> I find cultivating mental flexibility to be useful thing. And any concept that requires me to learn new ways of thinking is always an interesting challenge.
14:25:04 <Nimatek> a useful thing*
14:25:19 <mzero> heh! My real programming years started pre-OO... So when OO came around I had all the wonder and joy and frustration of being 7 again... then got on board... had a blast.... and 20+ years later  got to do it all over again with functional programming. Only this time I knew to just enjoy the ride!
14:25:34 <KirinDave> copumpkin: Good tweet.
14:25:58 <KirinDave> kmc: Let's go back to that other game where everyone else sucks for a moment.
14:26:06 <copumpkin> KirinDave: thanks :)
14:26:10 <copumpkin> well, kind of sad that it's good
14:26:11 <KirinDave> kmc: Guess what the #1 objection to that essay I got in my email was.
14:26:42 <monochrom> I was brought up in a school in which "principles of programming languages" was two courses, not one. That helped.
14:28:28 <epsilonhalbe> hey people - cabal configure - produces files with unreadable/printable characters and this error
14:28:28 <epsilonhalbe> cabal: fd:7: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
14:28:53 <monochrom> oooh, locale funninest
14:29:02 <epsilonhalbe> i wanted to make haddock docu afterwards but this also crashes
14:29:25 <kmc> KirinDave, what was it?
14:30:22 <KirinDave> kmc: Paraphrasing and cleaning up the consensus it was: "Hard things aren't good things!", mostly by js coders. At a close #2 was, "We're not concerned with how to do a thing, but that we do it. You may have time to jerk off, but we are solving problems in the real world."
14:30:36 <KirinDave> kmc: #2 was mostly from java and scala programmers I know.
14:30:43 <kmc> right
14:31:00 <kmc> well, i think it's okay that some people see programming as just a job, and don't want to get better or understand it better than they need to to collect paycheck
14:31:19 <kmc> i'd personally rather not work with those people, though i think the opposite stereotype of the obsessive leet ninja koder is stupid as well
14:32:15 <copumpkin> kmc: how about the rockstar!
14:32:32 <kmc> i do think those people will become obsolete over time
14:32:38 <kmc> but maybe not each individual
14:32:42 <copumpkin> but I'm awesome
14:32:53 <copumpkin> you should be honored to have me coding for you
14:32:58 <dibblego> heh I said that to my surgeon the other day
14:33:11 <kmc> if you want a 40 year programming career, just attach yourself to a technology like COBOL or Java which is guaranteed to have 40+ years of lifetime as legacy cruft
14:33:22 <kmc> in fact you become more valuable as your peers give up or die
14:33:23 <KirinDave> Yeah
14:33:30 <dibblego> "you've laid down too much bone, we need to go in again", "sorry for being awesome"
14:33:59 <KirinDave> dibblego: Oh hey btw
14:34:03 <dibblego> hi
14:34:05 <KirinDave> dibblego: I actually did most of that iteratees thing
14:34:16 <Nimatek> KirinDave: I've never noticed pointers being the filter that people struggle to get past. For some reason I keep reading that on the internets though.
14:34:31 <KirinDave> dibblego: From the other day? The iteratees for csv thing?
14:34:41 <dibblego> ok
14:34:51 <KirinDave> dibblego: Actually the hardest part was trying to make it so that the mtl doesn't totally bone up the ability to reuse it mid stack
14:35:12 <KirinDave> dibblego: I sorta got sidetracked diving into http://hackage.haskell.org/package/Monatron-0.3.1
14:37:01 <copumpkin> KirinDave: holy shit
14:37:07 <copumpkin> KirinDave: you have an under construction animated gif on your website
14:37:09 <copumpkin> <3
14:37:17 <KirinDave> copumpkin: I could not not have one.
14:38:00 <monochrom> the next step is to make it a flash object
14:38:42 * monochrom contemplates building a page so that every letter is a flash object
14:38:58 <stribor> [(([Char], [Char], [Char]), [Char])]................is this triple and string?
14:39:20 <stribor> how would i get out only this part ([Char], [Char], [Char]), [Char])
14:39:34 <stribor> ([Char], [Char], [Char]),
14:40:39 <rwbarton> I thought the next step was to implement it in Agda
14:41:09 <kmc> no, you need to make it Web 2.0 AJAX
14:41:27 <kmc> like http://cheese.blartwendo.com/web21-demo.html
14:41:34 <copumpkin> monochrom: there's almost something like that
14:41:41 <copumpkin> monochrom: for having fancier fonts than most browsers support
14:41:51 <copumpkin> if you really care about your typography :)
14:41:56 <copumpkin> it's not quite every letter
14:42:54 <monochrom> most flash bigots use one single flash object for the whole page. I push the limit, I use 1000 flash objects
14:45:16 <elliott> Does GHC ever compile a "case" on a fixed-size, small integral type like Word8 into a jump table? I have a huge nested if/then/else in the Core I'm looking at here, which makes me a bit sad.
14:45:19 <elliott> Well, nested case/True/False.
14:45:36 <elliott> Or is that done at a later stage?
14:46:04 <kmc> wonder if llvm does that
14:46:16 <copumpkin> elliott: it's the fucking Num behavior there :/
14:46:59 <elliott> copumpkin: Hmm, but it's a case; surely those have nothing to do with Num?
14:47:05 <elliott> Or is it because fromInteger gets involved?
14:47:06 <stribor> [(a, b) | a <- (myFunction  s r), b <- someList, a == fst b]
14:47:23 <stribor> does this comprehension list make sense
14:47:43 <copumpkin> elliott: it's because a pattern match on a literal has to be an Eq comparison, but it could make it smarter at a lower level
14:47:46 <copumpkin> I guess it just doesn't
14:48:07 <elliott> copumpkin: I'm considering just doing newArray# -> writeArray# my case branches in (they're monadic actions) -> readArray#.
14:48:13 <Saizan> stribor: if myFunction returns a list and b is a tuple
14:48:16 <elliott> But that's gross, and maybe the writes won't get optimised away, in which case it'll do no good.
14:48:33 <stribor> yes b is tuple
14:48:45 <stribor> what i am trying to say with this comprehension is this
14:49:01 <stribor> draw element a from (my function) and draw b from list of tuples
14:49:08 <copumpkin> elliott: why not just do a case match on a primitive Int# or Word#?
14:49:12 <copumpkin> I think those are fine
14:49:32 <stribor> return to me only elementts "if element in a is same as first element of tuple"
14:49:32 <dalaing> is the first element of the tuple a list?
14:49:38 <elliott> copumpkin: you mean upconvert it into a Word then get the Word# out?
14:49:42 <elliott> that could work
14:50:14 <stribor> dalaing:  its nt
14:50:38 <dalaing> stribor: if a is a list, then the first element of the tuple needs to be a list as well then, yeah?
14:51:01 <stribor> first element is tuple as well
14:51:49 <dalaing> stribor: does myFunction return a list?
14:52:07 <Saizan> stribor: anyhow, what's the problem you are having?
14:52:09 <stribor> yes ...list of triples
14:52:24 <elliott> copumpkin: oh, heh, I think it actually might have optimised it out now
14:52:27 <elliott> thanks to a different change
14:52:30 <Saizan> dalaing: 'a' will be an element of that list
14:52:47 <elliott> oh, no, it hasn't :/
14:53:00 <stribor> myFunction returns list of triples
14:53:30 <stribor> b list is list where each element is Triple and String
14:53:35 <dalaing> fst isn't defined for triples though, right?
14:53:47 <stribor> that triple is of same type as myFunction returns
14:53:50 <dalaing> ah, nevermind
14:53:57 <dalaing> pre-coffee here
14:54:01 <stribor> lol
14:54:19 <dalaing> stribor: are you getting incorrect behaviour or a compile error?
14:54:27 <stribor> compile
14:54:42 <dalaing> maybe paste the error message?
14:55:01 <stribor> ok give me sec
14:55:01 <Saizan> and more of the code
14:56:06 <elliott> hmm, where is W8# exported? Data.Word seems to export it, but importing Data.Word doesn't get me it here
14:56:08 <elliott> with MagicHash on
14:56:15 <hpaste_> Stribor pasted “error” at http://hpaste.org/51505
14:56:54 <stribor> i think my list makes sense i am just getting types wrong somewhjere
14:57:22 <Saizan> stribor: [(a, b) | a <- (myFunction s r), b <- c, a == fst b]
14:57:32 <Saizan> stribor: [(a, snd b) | a <- (myFunction s r), b <- c, a == fst b] -- try this
14:57:41 <elliott> Or is it not exported anywhere? :/
14:57:51 <stribor> Saizan: give me sec
14:58:00 <Saizan> elliott: GHC.Word ?
14:58:23 <elliott> Saizan: oh, hmm, thanks; that's not in my documentation index for some reason
14:59:14 <stribor> Saizan: it compiles no error....ill check if output is correct
14:59:21 <stribor> Saizan: what did i do wrong in my logic
15:01:06 <Saizan> you're trying to make a list of (Type A, Type B), and b is already a (Type A, Type B) so you can't use it for the second field directly, you've to use only the second field of b
15:02:00 <dalaing> could you just use [ b | ... ]
15:02:46 <stribor> Saizan: thank you so much
15:03:32 <elliott> copumpkin: thanks, that worked :)
15:03:43 <elliott> didn't help the speed any, but oh well :P
15:03:50 <elliott> at least the Core makes me less unhappy now
15:06:34 <DevHC^> > show $ array (1,1) [(1,2),(1,3)]
15:06:34 <lambdabot>   "array (1,1) [(1,3)]"
15:06:55 <DevHC^> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html, 13.1.1.6
15:07:08 <DevHC^> for efficiency? why the LAST, and not the FIRST?
15:07:28 <benmachine> presumably it steps through the list and applies all of them without any checks
15:07:39 <DevHC^> "applies"?
15:07:44 <elliott> writes
15:07:48 <elliott> to the mutable pointer underlying the array
15:07:58 <elliott> it's a forM_ type structure
15:07:58 <DevHC^> u do know that the values r lazy
15:08:07 <benmachine> yes
15:08:07 <elliott> yes.
15:08:24 <elliott> it writes the _pointer of the thunk_ to the underlying mutable array.
15:08:40 <benmachine> well, why even say that
15:08:40 <benmachine> it writes the value to the array
15:08:52 <elliott> DevHC^: to take the last value -- which would be pointless, anyway, as it's an error, no point having sane behaviour for an error -- would involve reversing the list first.
15:08:58 <elliott> erm
15:09:01 <elliott> DevHC^: to take the _first_ value -- which would be pointless, anyway, as it's an error, no point having sane behaviour for an error -- would involve reversing the list first.
15:09:21 <elliott> or inserting checks, which might as well just signal an error rather than doing the thing you want, since they'll pay the performance cost anyway
15:09:28 <DevHC^> ok
15:10:04 <DevHC^> is anyone working on
15:10:18 <DevHC^> > array (0,maxBound-1) [] :: array Int ()
15:10:19 <elliott> working on what?
15:10:19 <lambdabot>   Couldn't match expected type `array'
15:10:19 <lambdabot>         against inferred type `GHC.Arr...
15:10:32 <elliott> > array (0,maxBound-1) [] :: Array Int ()
15:10:33 <lambdabot>  Terminated
15:10:43 <elliott> DevHC^: why do you want to allocate a ridiculous amount of memory?
15:10:46 <incluye> > (maxBound :: Int) - 1
15:10:46 <lambdabot>   9223372036854775806
15:10:48 <IceD^> nice way to check if all list els are eq: all (\ x -> head xs == x) xs
15:10:57 <DevHC^> irrelevant
15:11:00 <DevHC^> the runtime or whatever segfaults.
15:11:04 <DevHC^> that's a BUOG
15:11:33 <benmachine> DevHC^: go search the tracker
15:11:41 <DevHC^> http://hackage.haskell.org/trac/ghc/ticket/229
15:11:41 <elliott> yeah ok it probably shouldn't segfault
15:11:43 <DevHC^> damn i'm fast
15:11:52 <benmachine> it doesn't segfault, it panics
15:11:55 <elliott> DevHC^: if you're so fast why didn't you search the tracker first :P
15:11:57 <elliott> benmachine: segfaults here
15:12:01 <benmachine> oh
15:12:04 <benmachine> panics here
15:12:05 <elliott> in ghci
15:12:06 <elliott> The Glorious Glasgow Haskell Compilation System, version 7.0.4
15:12:09 <IceD^> that was question btw :)
15:12:11 <DevHC^> and does a bus error on some other system
15:12:13 <benmachine> 7.2.1
15:12:18 <benmachine> it panics and then aborts
15:12:28 <elliott> bus error is just OS X's segfault
15:12:32 <elliott> most of the time
15:12:37 <benmachine> that's not quite true
15:12:37 <DevHC^> lol
15:12:39 <lucca> they do mean different things.
15:12:49 <benmachine> I believe OS X does bus error when you null deref
15:13:01 <benmachine> or this might have been back in the ppc days, I forget
15:13:04 <elliott> I think it does it for dereferencing something you're not allowed to, too.
15:13:18 <elliott> At least that was my experience when I used OS X.
15:13:18 <elliott> I never saw a segfault.
15:13:26 <elliott> Of course bus errors exist on other systems, it's just almost universally OS X nowadays since they're rare elsewhere.
15:13:52 <lucca> other architectures will do things like buserr for unaligned word reads
15:14:11 <benmachine> oh, I think I got segfaults out of OSX
15:14:16 <benmachine> was a while ago though
15:14:52 <lucca> reads or writes off the end of stack or sbrk, or to unmapped pages or to mapped pages contrary to mprotect() settings should probably give you a segfault, but I haven't looked.
15:15:23 * hackagebot anansi 0.4 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4 (JohnMillikin)
15:24:01 <DevHC^> ok, let's try this again...
15:24:04 <DevHC^> in http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html#safe-trust:
15:24:19 <DevHC^> what is the significance of "All of M's direct imports are trusted by C"?
15:24:42 <elliott> It means that the condition is satisfied if all of the modules named in M's import statements are trusted by C.
15:25:09 <DevHC^> ie., can a module be successfully compiled with -XSafe, if it does not satisfy "All of M's direct imports are trusted by C"?
15:25:23 * hackagebot anansi-hscolour 0.1 - Colorized looms for Anansi  http://hackage.haskell.org/package/anansi-hscolour-0.1 (JohnMillikin)
15:25:31 <elliott> DevHC^: Indeed.
15:25:34 <elliott> Erm.
15:25:36 <elliott> DevHC^: No.
15:25:43 <elliott> (Thought I saw a "no".)
15:25:49 <elliott> DevHC^: That's kind of the point of -XSafe; it restricts the code.
15:26:03 <DevHC^> ok, so "All of M's direct imports are trusted by C" is redundant. remove!
15:26:11 <DevHC^> also "All of M's direct safe imports are trusted by C"
15:26:13 <elliott> DevHC^: Howso?
15:26:19 <DevHC^> Both of these hold:
15:26:19 <DevHC^>     * The module was compiled with -XSafe
15:26:19 <DevHC^>     * All of M's direct imports are trusted by C
15:26:28 <elliott> Oh, hmm.
15:26:28 <DevHC^> (1) implies (2)
15:26:33 <elliott> No, I was wrong.
15:26:36 <elliott> I was misreading the documentation.
15:26:44 <elliott> Also, are you fishing for GHC bugs or something? :-P
15:27:14 <DevHC^> no, just want to make this clear
15:27:54 <DevHC^> so again, can a module be successfully compiled with -XSafe, if it does not satisfy "All of M's direct imports are trusted by C"?
15:29:02 <monadic> Is there a good way to automatically make an index or table of contents for all my haskell packages with documentation installed locally? Right now I'm using browser bookmarks and such but thats pretty unstable because they break every time I update a package.
15:29:43 <benmachine> DevHC^: I think it can; note that the person who compiles the module may not be the same person as who uses it
15:30:58 <benmachine> so someone who trusts Foo can compile a module with -XSafe that imports Foo, but if C doesn't trust Foo then C doesn't trust your module
15:35:16 <DevHC^> i feel that there's definitely something WRONG(TM) here, i just need to point it out
15:36:39 <benmachine> well, get back to us when you've worked it out
15:37:09 <DevHC^> S00N(TM).
15:58:21 <haskellrookie> new to haskell
15:59:50 <AtnNn> haskellrookie: welcome :)
16:00:17 <haskellrookie> Thank you coming from C++ and C# background my friend told me to try this language
16:00:36 <Pseudonym> If you know Modern C++, you'll like Haskell.
16:00:37 <koeien> some good resources are Learn You a Haskell
16:00:47 <koeien> by andrei alexandrescu?
16:01:01 <koeien> @where lyah
16:01:01 <lambdabot> http://www.learnyouahaskell.com/
16:01:02 <haskellrookie> is haskell oop
16:01:06 <Pseudonym> koeien: That's the book, but "Modern C++" is a shorthand for that and things like it.
16:01:10 <haskellrookie> thank you i will try it
16:01:11 <Pseudonym> haskellrookie: Yes, and no.
16:01:19 <monadic> No and no
16:01:21 <Pseudonym> It depends what you mean by "OOP".
16:01:27 <Pseudonym> It's OO in the Alan Kay sense.
16:01:42 <haskellrookie> i mean can i make classes, create object,
16:01:45 <Pseudonym> If that helps.
16:02:06 <haskellrookie> is it like python
16:02:23 <Pseudonym> Python borrowed a lot from Haskell.
16:02:31 <Pseudonym> But no, it's not like Python.
16:02:56 <haskellrookie> what can i do with haskell. Can use it to make website, games, or gui
16:03:03 <azaq23> @faq
16:03:03 <lambdabot> The answer is: Yes! Haskell can do that.
16:03:11 <mamalujo> how is it oop in any sense? wouldn't a prereq for that be having subtyping?
16:03:43 <Pseudonym> "class" in Haskell means something slightly different than it does in other languages.
16:03:46 <hpc> mamalujo: object-orientation isn't well-defined
16:03:49 <Pseudonym> Let me try to explain.
16:04:06 <haskellrookie> My firend told me its super fast language. if it is i wonder if there is library to work in c#, i am a web programmer
16:04:07 <Pseudonym> When you say "class Foo" in Java, C++, C#, you're actually doing _three_ things.
16:04:24 <hpc> haskell has some elements of what many consider to be OO, but it doesn't have subtypes like java does
16:04:24 <Pseudonym> 1. You're defining a new type, "Foo".
16:04:37 <Pseudonym> 2. You're defining a _set_ of types also confusingly called "Foo".
16:04:47 <Pseudonym> 3. You're declaring that the type Foo is a member of the set of types Foo.
16:04:54 <Pseudonym> The set of types is Foo and all of its subclasses.
16:05:09 <Pseudonym> Did that make sense, haskellrookie?
16:05:10 <Cale> mamalujo: Subtyping isn't that crucial for OOP. The more important thing is the ability to define values which are distinguished by the manner in which they respond to messages.
16:05:11 <monadic> Meh haskell data is more comparable to a C union
16:05:12 <Eduard_Munteanu> haskellrookie: there are Haskell web frameworks
16:05:18 <Cale> (or "methods")
16:05:22 <Pseudonym> monadic: More like a Pascal variant union.
16:05:25 <haskellrookie> yes i get it
16:05:25 <dolio> You're also defining a module called Foo with a bunch of functions operating on Foos in it.
16:05:30 <monadic> Well a C union and data saying which part of the union
16:05:34 <benmachine> monadic: except that C unions require dark magic and manual checking to not screw up
16:05:35 <Eduard_Munteanu> @google yesod
16:05:38 <lambdabot> http://www.yesodweb.com/
16:05:38 <lambdabot> Title: Yesod :: Homepage
16:05:41 <benmachine> well, the magic isn't that dark
16:05:46 <benmachine> except inasmuch as it's C
16:05:48 <monadic> benmachine: Hence my little comment there.
16:05:50 <Pseudonym> haskellrookie: In Haskell, those three things are separated.
16:05:52 <mamalujo> I'm not sure its super fast either. shootout puts it at ~x2 of C, and thats after some craze of optimizing those quite intensly, no?
16:05:55 <hpc> monadic: except it isn't a tagged union at runtime because static types :P
16:06:11 <Eduard_Munteanu> mamalujo: probably a lot better than Python or PHP anyway.
16:06:17 <haskellrookie> wow great i have to check it out with the web library
16:06:18 <mamalujo> yeah, def that
16:06:26 <Pseudonym> Which has one implication which is counter-intuitive to people coming from other OO languages, which is that a class is not a type.
16:06:35 <Pseudonym> Haskell makes the distinction between a type and a set of types.
16:06:35 <mauke> monadic: haskell data is C enum+struct+union
16:06:38 <Eduard_Munteanu> If your reference is C, then it might not sound that great.
16:06:42 <dolio> 50% of the performance of C is fast.
16:06:54 <geheimdienst> (speed is overrated. if it was so damn important, we'd all be using assembler for everything)
16:07:10 <Pseudonym> But, haskellrookie, it has an advantage. You can declare a type to be a member of a class _after_ you've made the type.
16:07:18 <benmachine> geheimdienst: well, sure, but it's not irrelevant
16:07:18 <monadic> geheimdienst: C is faster than Assembler nowadays because the compiler can optimize better than you can.
16:07:21 <haskellrookie> well i am saying java is slow so haskell must be faster than java
16:07:23 <benmachine> performance is a priority for GHC
16:07:25 <Eduard_Munteanu> geheimdienst: not actually true IMHO, C or Fortran compilers produce really good asm code these days
16:07:37 <Eduard_Munteanu> geheimdienst: better than the average programmer can put out anyway.
16:07:44 * monochrom liked Pascal!
16:07:45 <Pseudonym> haskellrookie: A class in Haskell is like a concept in C++.
16:07:54 <Peaker> haskellrookie: Haskell is different enough from C, Python, C#, etc, that writing something non-trivial like a web application as the very first program may be a bad approach to learning :-)  I recommend starting with www.learnyouahaskell.com and/or solving some Euler problems
16:08:05 <Peaker> monadic: that's a myth
16:08:16 <mauke> Peaker: it's true
16:08:18 <monadic> Peaker: Yeah... not really.
16:08:25 <Peaker> mauke, monadic: I guess it depends on who "you" is
16:08:29 <monochrom> Einstein's theory implies that assembly cannot be faster than c :)
16:08:29 <mauke> I am me
16:08:47 <Pseudonym> C is faster than assembler because the C programmer is allowed to use the C compiler and a profiler and drill down to assembler for the bits which matter.
16:08:47 <monochrom> @quote monchrom einstein
16:08:47 <lambdabot> No quotes for this person.
16:08:47 <monochrom> @quote monochrom einstein
16:08:47 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
16:08:47 <Eduard_Munteanu> monochrom: you're a relativist, go away :P
16:08:50 * monochrom fails at his own nick!
16:08:53 <Jafet> instance Ord (Speed ProgrammingLanguage)
16:08:54 <hpc> monadic: there's nothing to stop a programmer from doing what the compiler does, then doing other improvements by hand
16:09:08 <hpc> ergo assembly is at least as fast as c
16:09:09 <haskellrookie> what do you guys use haskell for currently
16:09:16 <Peaker> mauke, monadic: Optimizing specific sections of code with some inline assembly still helps.  Using some platform-specific hints to the compiler about the assembly it should generate also helps
16:09:19 <Eduard_Munteanu> Don't want ya to teach our kids that garbage. :P
16:09:22 <monadic> haskellrookie: Everything
16:09:30 <mauke> Peaker: [citation needed]
16:09:40 <mauke> Peaker: I've never seen me improve code by using inline asm
16:09:47 <Cale> haskellrookie: I'm working for a company called iPwn Studios on an action RPG for iPhones and other mobile devices.
16:09:57 <Cale> (In Haskell)
16:10:09 <monochrom> Einstein's theory implies that microcode cannot be faster than c [citation needed]
16:10:28 <Pseudonym> mauke: Platform-specific hints really do help, though.
16:10:35 <Pseudonym> Say, for enabling SSE instructions.
16:10:35 <Cale> Haskell is a general purpose language. If it's something that can be done on a computer, you can probably program it in Haskell.
16:10:38 <haskellrookie> does haskell have a library to connect to opengl
16:10:43 <Cale> Yes
16:10:44 <monadic> haskellrookie: yes
16:10:46 <Cale> Several, actually
16:10:50 <haskellrookie> how about a gui library
16:10:53 <monadic> haskellrookie: yes
16:10:54 <hpc> monochrom: and C++ runs backwards through time
16:10:54 <Jafet> monochrom: "The last good thing written in C was Franz Schubert's Symphony number 9."
16:10:56 <Cale> Sure, there are a few of those
16:11:04 <Eduard_Munteanu> mauke: it probably makes sense for stuff like BLAS, though
16:11:06 <haskellrookie> wow that is great
16:11:06 <monadic> Everything C can do Haskell can with FFI as well
16:11:06 <Peaker> mauke: There are some libraries such as atomic operations used for lockless stuff that are not commonplace and/or have shortcomings, and at least we had to write our own versions using some inline assembly
16:11:10 <monochrom> @quote Franz
16:11:10 <lambdabot> No quotes match. It can only be attributed to human error.
16:11:23 <Peaker> mauke: There are cpu-hints such as prefetch via inline assembly used by e.g: Linux kernel
16:11:24 <Eduard_Munteanu> Or the crazy stuff atlas-blas does during compiling.
16:11:24 <monochrom> @quote symphony
16:11:24 <lambdabot> No quotes match. Sorry.
16:11:32 <mauke> Peaker: none of those are me
16:11:36 <monochrom> Jafet: I like that one too :)
16:11:36 <Pseudonym> Jafet: Shouldn't that be the last "great" thing?
16:11:41 <Eduard_Munteanu> That's really pico, not micro optimization :P
16:11:44 <Peaker> mauke: Linux's foreach linked list macro uses prefetch to reduce cache misses
16:11:47 <Pseudonym> Otherwise you miss the pun.
16:11:57 <haskellrookie> where can i get libraries for gui and opengl wrapper for haskel
16:12:06 <monadic> haskellrookie: Hackage!
16:12:10 <Peaker> mauke: Ok, but there are people who still drill down to inline assembly to optimize the output of the C compiler
16:12:15 <Eduard_Munteanu> @where hackage
16:12:16 <lambdabot> http://hackage.haskell.org/package/
16:12:24 <Pseudonym> (Schubert's 9th is nicknamed the "Great", for those who are unaware.)
16:12:25 <Jafet> Hm, it's always transcribed as "good".
16:12:34 <Pseudonym> Huh.
16:12:55 <haskellrookie> wow i am sold thanks alot guys i am going to dig in to this language and see it for myself
16:13:05 <monochrom> let's just rename it to "the good symphony"
16:13:13 <Pseudonym> Great as opposed to little.
16:13:23 <Pseudonym> Like omega and omicron.
16:13:25 <benmachine>     Not in scope: data constructor `Cookie'
16:13:25 <benmachine>     Perhaps you meant `MkCookie' (imported from Network.Browser)
16:13:30 <benmachine> that is in fact exactly what I meant
16:13:32 <benmachine> <3 GHC
16:13:43 <monadic> benmachine: Is that new in 7.2?
16:13:45 <geheimdienst> Schubert's 9th Symphony (Teh Awsum)
16:13:47 <hpc> new GHCs do that now?
16:13:49 <Jafet> Glasgow Haskell Clippy
16:13:49 <benmachine> monadic: 7 or 7.2
16:13:53 <benmachine> I forget which
16:14:07 <monadic> benmachine: I haven't seen that on my 7.0.1 so it must be 7.2 (currently its compiling... sigh takes so longgggg)
16:14:18 <monadic> I want to try out the new generics support
16:14:58 <Pseudonym> It looks like you're trying to use mutable global state. Don't do that.
16:15:04 <mamalujo> Jafet: in any case, w/o the 'great', I'd disagree w that (Stravinsky had a famous  Symphony in C , Shostakovich's 7th is in C)
16:15:45 <monochrom> the last awesome thing written in C was my symphony
16:15:57 <dylukes> :0
16:16:07 <monochrom> and the last awesome thing written in C# was my concerto
16:16:10 <hpc> https://www.youtube.com/watch?v=hbjOEnxTF8c -- relevant
16:16:15 <mamalujo> hah
16:17:37 <geheimdienst> monochrom: that spoils the joke, because your musical pieces would have been written after C-the-language was invented, in all likelihood
16:18:01 <monochrom> oops, you're right
16:18:03 <Pseudonym> Do we allow C minor?
16:18:21 <benmachine> what do you get when you drop a piano down a mineshaft?
16:18:24 <Pseudonym> Mahler's symphony #2 is famously in that.
16:18:43 <monochrom> I love many C minor pieces and C# minor pieces
16:18:48 <Pseudonym> benmachine: An awesome Mythbusters episode.
16:18:52 <benmachine> Pseudonym: :>
16:18:54 <geheimdienst> #Haskell™. Analyzing Your Jokes To Death™.
16:19:24 <copumpkin> how many pieces do you know in G# minor? :)
16:19:48 <mamalujo> hehehe
16:19:55 <geheimdienst> copumpkin: this many http://en.wikipedia.org/wiki/List_of_symphonies_in_G_minor
16:19:58 <Pseudonym> copumpkin: I actually know one from memory, but it's kinda embarrassing.
16:20:02 <Pseudonym> "Poker Face"
16:20:07 <byorgey> a lot more than I do in F# minor
16:20:09 <copumpkin> geheimdienst: G#?
16:20:20 <copumpkin> also, I mean piano pieces
16:20:30 <benmachine> you could play poker face on the piano
16:20:58 <copumpkin> conveniently, I happen to be listening to one such piece right now
16:21:07 <Pseudonym> Which one?
16:21:20 <geheimdienst> copumpkin: i putted in a "#" but the browser thinks i want the page "List_of_symphonies_in_G" and the anchor "_minor"!!1!
16:21:29 <copumpkin> Rachmaninoff's prelude op 32 no 12
16:21:40 <copumpkin> one of my favorite preludes
16:22:02 <copumpkin> sort of an unusual one
16:22:03 <monochrom> oh, Rach, that bizarre guy
16:22:13 <Pseudonym> Oh, that's a good one.
16:22:22 <copumpkin> I also love that prelude with the quintuplets (?) in the left hand
16:22:31 <monochrom> he surely sharps and flats your key left right and centre
16:22:48 <Eduard_Munteanu> Well, Rachmaninoff stuff is tough.
16:23:20 <copumpkin> Op 32 # 5 is my other favorite prelude
16:23:25 <copumpkin> most of them are pretty good though :)
16:23:34 * Pseudonym has been listening to a lot of Messaien lately.
16:24:00 <copumpkin> haven't even heard of it :)
16:24:07 <Pseudonym> Olivier Messiaen.
16:24:14 <Pseudonym> It's... well, ambient in a Debussy kind of way.
16:24:29 <copumpkin> (I really like quintuplets (or is pent-?) in my music)
16:24:52 <Pseudonym> Messiaen also wrote for the Ondes Martenot. Look that up.
16:25:30 <copumpkin> (Beethoven's Appasionata first movement and his #32 first movement also have them, mmmm)
16:25:34 <copumpkin> will look :)
16:25:38 * copumpkin summons spotify
16:25:48 * Eduard_Munteanu finds even weirder stuff enjoyable, like some of Grisey's stuff: http://www.youtube.com/watch?v=kX77MC5oXDY
16:25:53 <lucca> there are replicas of the ondes martenot interface out there
16:26:18 <lucca> People have written music for theremin too.  Those are /really/ obnoxious to play.
16:26:39 <Jafet> http://www.youtube.com/watch?v=68_j6yU4Whg
16:26:43 <Pseudonym> The ondes martenot appeals to be because I'm a cellist, like Martenot himself.
16:27:03 <Pseudonym> He wanted a keyboard instrument that you could articulate like a cello.
16:27:29 <copumpkin> ah :)
16:27:35 <Pseudonym> Eduard_Munteanu: I'm guessing this loses something by being a recording. You'd want to see this live in a proper acoustic space, no?
16:28:17 <Eduard_Munteanu> Pseudonym: I think there have been live performances of that
16:28:40 <mamalujo> Messiaen, really? I've found him quite difficult to follow last I tried. perhaps should again.
16:28:52 * geheimdienst takes an ibm model m and bolts it to a cello. it's a keyboard instrument now. you're welcome.
16:29:05 <mamalujo> ;-
16:29:06 <Pseudonym> The clickiest cello ever.
16:29:17 <Nafai> geheimdienst: the ultimate geek instrument
16:29:27 <Jafet> It's already a keyboard instrument!
16:30:03 <mamalujo> Nafai: how does the cello contribute to its geekiness? because, if bolted on something different would make it geekier, its not ultimate ;)
16:30:35 <Nafai> good point.
16:30:37 <Pseudonym> Technically, "ultimate" means "final".
16:30:50 <Nafai> a model m bolted onto a theramin (Sp?)
16:31:00 <geheimdienst> it also is not "the clickiest cello ever", because i haven't even started with the mice yet
16:31:09 <mamalujo> hehe
16:31:12 <ddarius> The theremin is an obnoxious instrument.
16:31:13 <Jafet> So if you added the typewriter ball, it would become penultimate?
16:33:57 <hpc> ddarius: not if you play the resulting sound with a musical tesla coil
16:34:00 <stribor> is there any functions one can do on triples
16:34:11 <stribor> that are already part of library
16:34:45 <ddarius> show, (==), probably vector-space has instances as well
16:34:59 <Eduard_Munteanu> @hoogle (a, b, c)
16:34:59 <lambdabot> Test.QuickCheck three :: Monad m => m a -> m (a, a, a)
16:34:59 <lambdabot> Data.Graph.Inductive.Graph labEdges :: Graph gr => gr a b -> [LEdge b]
16:34:59 <lambdabot> Data.Time.Calendar toGregorian :: Day -> (Integer, Int, Int)
16:35:00 <Pseudonym> Data.Tuple.HT
16:35:16 <Eduard_Munteanu> Anyway, if you want projections, you can define them yourself.
16:35:26 <Pseudonym> @hoogle fst3
16:35:26 <lambdabot> No results found
16:35:27 <hpc> if you are using triples, you probably want your own data structure
16:35:34 <Eduard_Munteanu> Yeah ^^
16:35:44 <hpc> or at least use a nested tuple (a, (b, c))
16:36:44 <stribor> all i need to be able to access first second and third element of each tuple
16:37:22 <tomberek> is there something about type families that requires an additional (case XXX `cast` (a :: b ~ c)) construct in Core? I'm noticing this in an inner loop.
16:38:39 <byorgey> tomberek: that just means applying the corcion a to the term XXX
16:38:51 <byorgey> tomberek: a is a coercion witnessing the equivalence of the types b and c
16:39:05 <byorgey> if XXX has type b, then XXX `cast` (a :: b ~ c) has type c
16:39:44 <byorgey> tomberek: when you write a type family equation like  type instance Foo a = b,  it generates a coercion axiom  Foo_Ax :: Foo a ~ b
16:39:58 <Eduard_Munteanu> stribor: you can pattern-match, or use something like record syntax
16:40:01 <tomberek> byorgey: yeah, that's what it looks like, but that is the only difference I see between two versions of a program, and there are two or three of those coercions in one of my inner loops that runs 100,000,000 times
16:40:05 <byorgey> so in general using type families will definitely involve applying coercions, but coercions are not specific to type families
16:40:23 <Eduard_Munteanu> s/something//
16:40:40 <stribor> oh nice pattern match....can you show me example on how to take out int from this triple (1,4,5)
16:40:46 <tomberek> byorgey: makes sense, but is there a way to remove? or optimize it?
16:40:49 <stribor> a:b:c
16:40:49 <stribor> ?
16:40:50 <byorgey> tomberek: hmm, does it actully slow things down?
16:41:07 <tomberek> stribor:  secondInt (_,a,_) = a
16:41:10 <byorgey> tomberek: coercions have no runtime representation, and doing a cast is a no-op at runtime
16:41:29 <Eduard_Munteanu> stribor: no, that's for lists
16:41:34 <tomberek> byorgey: I could be wrong, but I see no other differences in the Core
16:41:44 <Eduard_Munteanu> stribor: f (a, b, c) = ...
16:41:47 <byorgey> tomberek: and you are seeing a difference in performance?
16:41:59 <stribor> =?
16:42:11 <adrian_berg> How many packages total are in Hackage?
16:42:20 <Eduard_Munteanu> = whatever you want to do with those components
16:42:22 <tomberek> byorgey: i though so too, but I'm noticing a 30% difference in run time
16:42:36 <stribor> oh ok....let me play with that:)
16:42:37 <Eduard_Munteanu> sumTriple (a, b, c) = a + b + c
16:42:40 <stribor> Eduard_Munteanu: thank you
16:42:54 <byorgey> tomberek: interesting, it's probably worth sending an email to glasgow-haskell-users@haskell.org
16:43:06 <ddarius> Pseudonym: What's been going on in your life of late?
16:43:13 <Eduard_Munteanu> (assuming suitable types)
16:44:21 <tomberek> byorgey: i thought I'd ask on here first, perhaps there are some common ways to speed things up...... side question: does using a newtype for a type family provide the same benefits as regular?
16:44:38 <ddarius> byorgey: Well, even if the coercion itself has no cost, it could block other optimizations.
16:45:06 <byorgey> ddarius: that's true.
16:45:10 <tomberek> ddarius: ah, that might be it
16:45:41 <byorgey> the treatment of coercions is also tricky since even though they have no runtime representation, they still must be evaluated strictly to ensure you can't produce bogus coercions by writing an infinite loop
16:46:38 <ddarius> I'm sure the Simons would be interested nevertheless.
16:46:47 <tomberek> ddarius, byorgey: what I'm working on: I made a self-optimizing generic reference. So depending on the Monad and the type, it creates an optimized reference. Unboxed when it is possible, a standard STRef/IORef otherwise.
16:46:49 <monadic> Yay! GHC 7.2 _finally_ finished compilation
16:46:51 <adrian_berg> How many packages total are in Hackage?
16:47:04 <monadic> adrian_berg: Alot
16:47:18 <adrian_berg> A number helps
16:47:30 <bcw> adrian_berg, hayoo says "Concurrently search more than 3.299 packages..."
16:47:33 <Eduard_Munteanu> adrian_berg: you could get http://hackage.haskell.org/packages/archive/00-index.tar.gz from the main page, and count packages from that
16:47:40 <Eduard_Munteanu> Maybe.
16:47:41 <tomberek> and it works almost as well as hand coding two separate reference types, except for that 30$
16:47:55 <Eduard_Munteanu> "tarball of package descriptions", that is
16:48:17 <monadic> http://hackage.haskell.org/packages/pkg-list.html is an alternative, counting the different categories at the top
16:48:25 <stribor> if this is x:xs paterrn matching for list where x is head and xs is tail.......if i say x is head........and that head is actually tuple...would call fst x give me that first element?
16:48:26 <Eduard_Munteanu> Also, Hayoo says "Concurrently search more than 3.299 packages and more than 309.492 functions!"
16:48:28 <adrian_berg> Not quite a fourth of what python has
16:48:36 <byorgey> however, note that the pkg-list.html lists packages multiple times
16:48:49 <monadic> stribor: yes, but you could do in better style: (x, x'):xs
16:48:57 <byorgey> stribor: yes. you can also pattern match on it like  (x,y):xs
16:49:06 <stribor> where (x,) is what?
16:49:08 <monadic> pattern matching is generally preferable imo
16:49:15 <tomberek> that's matching
16:49:17 <stribor> where (x,y) is ?
16:49:19 <monadic> stribor: It is pattern matching on a tuple
16:49:26 <stribor> neat...thank you
16:49:46 <tomberek> so.... f  (  (x1,x2):xs  )  = x1
16:49:49 <Eduard_Munteanu> adrian_berg: as much as Haskell tried to avoid success, and it didn't work well for it :/
16:50:30 <adrian_berg> Thank you much for the help! I need to study
16:52:34 <stribor> can you do then myFunction (x,y):xs = something
16:53:01 <Eduard_Munteanu> stribor: you'll need to wrap (x,y):xs in paranthesis
16:53:19 <stribor> ((x,y):xs)
16:53:25 <Eduard_Munteanu> Yeah.
16:53:34 <stribor> why do we have to do that?
16:54:21 <tomberek> byorgey, so there's no way to get around that coercion? inserting explicit type signatures?
16:55:18 <byorgey> tomberek: no, even with an explicit type signature a coercion is still needed
16:55:22 <Cale> stribor: because without them it parses as  (myFunction (x,y)) : xs
16:55:38 <tomberek> actually, now that i think of it, i guess not, because anyone should be able to add more classes and data family instances
16:55:51 <DevHC^> is there an example case where we cannot use mySeq to replace seq?
16:56:06 <byorgey> tomberek: GHC core terms have the property that they syntactically encode their own typing derivations
16:56:15 <Cale> DevHC^: What was mySeq?
16:56:29 <Cale> DevHC^: The instance of seq for function types can't be written in Haskell
16:56:31 <DevHC^> a "home-made" version of seq
16:56:47 <Eduard_Munteanu> stribor: because function application binds tighter than ':'
16:56:48 <Cale> > (const undefined) `seq` 5
16:56:49 <lambdabot>   5
16:56:51 <shachaf> DevHC^: Well, it depends on how you home-make it. :-)
16:56:54 <Cale> > undefined `seq` 5
16:56:55 <lambdabot>   *Exception: Prelude.undefined
16:56:56 <shachaf> DevHC^: Does it work on functions?
16:56:58 <tomberek> byorgey, dang: cause otherwise everything works perfectly, a fast non-allocating traversal
16:57:09 <stribor> tx
16:57:09 <DevHC^> let me ask the question in a different way
16:57:10 <Eduard_Munteanu> stribor: tighter than anything else with an exception.
16:57:17 <Cale> There's no other way to force the evaluation of a function
16:57:19 <DevHC^> what would life look like without seq in Haskell?
16:57:22 <byorgey> tomberek: it is definitely worth asking about on glasgow-haskell-users
16:57:30 <tomberek> ok, thanks
16:57:34 <DevHC^> (but with mySeq)
16:57:44 <shachaf> > (const undefined `seq` 5, undefined `seq` 5)
16:57:45 <lambdabot>   (5,*Exception: Prelude.undefined
16:57:47 <Cale> DevHC^: Similar, with more class contexts
16:58:10 <benmachine> and you still can't evaluate functions
16:58:13 <Cale> DevHC^: There used to be an Eval typeclass for that.
16:58:24 <benmachine> s/still //
16:58:33 <Cale> (it actually used to be that way, before seq was made primitive)
16:58:41 <shachaf> Cale: It was still magic.
16:58:42 <tomberek> byorgey, i'll try to condense and strip it down to the bare essentials into a few lines and still capture the difference, not sure if that'll work though
16:58:58 <Cale> shachaf: maybe, though it wouldn't have to be
16:59:05 <shachaf> Cale: Well, it worked on functions. :-)
16:59:21 <Cale> Yeah, a function instance would be magic
16:59:25 <shachaf> Instances were implicitly autoderived for every type.
16:59:39 <DevHC^> benmachine: what r u saying?
17:00:26 <byorgey> tomberek: that would probably be very helpful, although I realize sometimes that is difficult
17:00:26 <tomberek> byorgey: i have NoMonomorphismRestriction on with one version, can that be causing the case/cast difference as well? or contributing?
17:00:52 <byorgey> tomberek: I am not 100% sure, but I doubt it
17:01:00 <tomberek> byorgey: ok, i'll look into it, it's interesting stuff anyway
17:01:37 <stribor> I have list that goes like this [((String,String,String),String),((String,String,String),String)....]
17:01:42 <benmachine> DevHC^: what others said; if seq didn't exist, there would be no way to safely force a function to be evaluated
17:01:46 <stribor> Why cant i pattern match it like this     ((x,y,z),d):xs
17:01:59 <hpc> stribor: parens around the whole pattern
17:02:09 <DevHC^> the question is: why is evaluating a function required?
17:02:10 <hpc> f (foo:foos) ...
17:02:12 <stribor> ((x,y,z),d):xs)
17:02:13 <benmachine> similarly, there would be no difference between undefined and const undefined
17:02:28 <stribor> but does my pattern make sense
17:02:28 <byorgey> stribor: right.
17:02:30 <benmachine> DevHC^: presumably for the same reasons evaluating anything is required
17:02:33 <byorgey> stribor: sure
17:02:41 <stribor> byorgey:  th
17:02:50 <stribor> byorgey: tx:)
17:02:55 <hpc> stribor: and use a data structure; that's a horrid tuple
17:02:58 <byorgey> stribor: however, as a meta-comment, I do not recommend using ((String,String,String),String) for anything
17:03:22 <stribor> why
17:03:32 <tomberek> ugly
17:03:36 <DevHC^> benmachine: seq is not the only way to evaluate things
17:03:39 <byorgey> create a data type with descriptive names like   data Foo = Foo { name :: String, description :: String, whatsit :: String}
17:03:47 <tomberek> easier to read if you have records
17:04:07 <DevHC^> > let { f :: Int -> Int -> Int ; f x = undefined } in (f `seq` "ok", f 1 `seq`"ok", f 1 2 `seq` "ok")
17:04:07 <tomberek> you can unpack them and it's almost the same thing
17:04:07 <lambdabot>   ("ok","*Exception: Prelude.undefined
17:04:09 <benmachine> DevHC^: you can't evaluate functions without applying them, and there's no good way to decide what to apply to them
17:04:14 <DevHC^> > let { f :: Int -> Int -> Int ; f x y = undefined } in (f `seq` "ok", f 1 `seq`"ok", f 1 2 `seq` "ok")
17:04:15 <lambdabot>   ("ok","ok","*Exception: Prelude.undefined
17:04:28 <DevHC^> why is this required?
17:04:34 <benmachine> good question
17:04:43 <benmachine> someone in the language committee way back when thought it was necessary
17:04:46 <benmachine> I don't know why
17:05:26 <stribor> can you use pattern matching inisde list comprehension
17:05:51 <byorgey> stribor: sure
17:05:59 <stribor> k'
17:07:03 <amathew> what are some good websites for beginner haskell projects
17:07:17 <DevHC^> just stay away from LYAH
17:07:46 <Pseudonym> Sorry, work beckons.
17:07:48 <amathew> does that site even have problem sets / beginner projects?
17:08:11 <dalaing> what's wrong with LYAH?
17:08:15 <DevHC^> meh nvm
17:08:38 <dalaing> I'm genuinely interested
17:09:11 <dalaing> rather than trying to start a bookwar :)
17:09:46 <Eduard_Munteanu> There's also...
17:09:47 <Eduard_Munteanu> @where rwh
17:09:47 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:09:55 <Cale> Lots of people like LYAH
17:09:57 <Jafet> Books make great kindling.
17:10:03 <kmc> i think LYAH and RWH could each rub people the wrong way
17:10:10 <dalaing> RWH did more harm than good for me initially
17:10:13 <kmc> i don't think either book is objectively bad
17:10:21 <kmc> they've both helped a lot of people learn haskell
17:10:50 <dalaing> bird and walder had some good exercises
17:11:15 <dalaing> "Introduction to functional programming"
17:11:47 <Peaker> dalaing: I've got a coworker who doesn't like technical texts being "fun"
17:11:59 <Peaker> dalaing: he said he wanted something essentially "more boring" than LYAH
17:12:13 <dalaing> Peaker: language spec?
17:12:48 <dalaing> that's got to be more boring, right? although I haven't read it yet...
17:12:51 <Peaker> heh
17:13:03 * Eduard_Munteanu didn't find the "Gentle Introduction [...]" to be that bad either
17:13:23 <geheimdienst> i had to disobey quite some orders at work to keep the lolcats i put in the technical documentation
17:13:38 <ddarius> Gentle Introduction uber alles.
17:13:39 <Eduard_Munteanu> LYAH is a bit too much on the "for dummies" side, I guess that might annoy some people expecting a more formal presentation :/
17:13:50 <dalaing> I struggled with the fact that RWH had exercises based on stuff it hadn't introduced yet, and didn't motivate big chunks of what they were doing in some places
17:13:55 <ddarius> Jafet: They do.
17:14:02 <kmc> RWH's examples are big and messy
17:14:13 <kmc> to drive home the point that Haskell works for big, messy projects and not just for calculating Fibonacci numbers
17:14:22 <kmc> but that perhaps interferes with learning
17:14:35 <ddarius> Fibonacci uber alles!
17:14:43 <Peaker> RWH turned off my friend as well.. he had difficulties going through the type-class chapter (and he's by no means hard-of-learning)
17:14:57 <Peaker> I think I recall he also complained the order of concepts was not well thought of
17:15:27 <hpc> the lyah section on type classes made immediate sense to me
17:15:28 <kmc> suppose i were to write another introduction, aiming for it to be recommended alongside LYAH and RWH
17:15:30 <kmc> what should i do?
17:15:38 <hpc> kmc: i would write lyah :P
17:15:40 <ddarius> kmc: Market.
17:15:51 <kmc> market?
17:15:54 <dalaing> RWH scared me off for a bit, then I tried LYAH and the lack of exercises meant it wasn't sinking in, then I went through "introduction to functional programming" which helped heaps
17:16:16 <dalaing> then I hit the tail end of LYAH and the specific chapters of RWH I needed
17:16:22 <kmc> i think the conflation of the two goals "learn Haskell" and "learn FP" is unfortunate
17:16:25 <Eduard_Munteanu> Google uber alles, really
17:16:26 <ddarius> @wn market
17:16:27 <kmc> (speaking generally, not about a particular book)
17:16:28 <lambdabot> *** "market" wn "WordNet (r) 2.0"
17:16:28 <lambdabot> market
17:16:28 <lambdabot>      n 1: the world of commercial activity where goods and services
17:16:28 <lambdabot>           are bought and sold; "without competition there would be
17:16:28 <lambdabot>           no market"; "they were driven from the marketplace"
17:16:30 <lambdabot> [16 @more lines]
17:16:36 <dalaing> now I'm all out of books and madly googling any terms that look helpful
17:16:38 <kmc> ddarius, I know what the word means; I don't know what you're getting at by it
17:16:41 <ddarius> The verb is what I wanted.
17:16:52 <geheimdienst> i found rwh difficult because of the "here's a solution, but that's bad because of X, so here's a fix, and here's another fix, and here's some other thing that needs to be addressed", and you end up not knowing which code they really "meant" and which was problematic
17:17:13 <kmc> ddarius, you think RWH and LYAH aren't marketed effectively?
17:17:19 <ddarius> No, I think they are.
17:17:32 <ddarius> If you want to be recommended with them, you will need to market effectively.
17:17:34 <hpc> geheimdienst: like reading a patch history in tutorial form?
17:17:34 <geheimdienst> ddarius: i guess he needs to produce some content before he can market it ...
17:17:40 <hpc> i hate those
17:17:45 <ddarius> geheimdienst: Silly you.
17:17:58 <kmc> yeah, i was more interested in suggestions on content
17:18:01 <ddarius> geheimdienst: Anyway, he is already attempting to market it.
17:18:02 <dalaing> kmc: something like bird and walder or shapiro's text on lisp crossed with what RWH was trying to do would be pretty good
17:18:07 <kmc> ok
17:18:15 <kmc> i guess i will have to read all these other intro texts
17:18:18 <Eduard_Munteanu> Isn't it available in dead tree form already? :/
17:18:59 <DevHC^> "the existence of seq weakens Haskell's parametricity properties.", "In the presence of seq, the foldr/build-rule is not anymore a semantic equivalence.", etc.
17:19:04 * Eduard_Munteanu wants a "Basic Category Theory for Haskellers" :P
17:19:11 <ddarius> Eduard_Munteanu: Why?
17:19:12 <DevHC^> looks like seq is asking to get shot down
17:19:39 <dalaing> kmc: I'd love to see a text with an intro to haskell with exercises and/or mini-projects that build across chapters in the first half and a second half on getting things done, although that might be asking for two books
17:20:00 <Eduard_Munteanu> ddarius: why not? Think about a nicely edited collection of edwardk's blog posts :)
17:20:09 <ddarius> Eduard_Munteanu: That would be horrible.
17:20:23 <Eduard_Munteanu> :(
17:20:59 <byorgey> ddarius: why?
17:21:19 <Eduard_Munteanu> I don't mean for the usual Haskeller, just somebody who wants to see what all that CT is all about when put to good use.
17:21:43 <dalaing> kmc: the trick for me for some of my favourite texts - and I don't know what proportion of people learn in the same way as me - was the nature of the exercises
17:22:19 <hpc> Eduard_Munteanu: i think what i would do is explain the principles behind Functor, Monoid, etc
17:22:32 <hpc> Eduard_Munteanu: and then point to a good wikipedia page and say "here you go"
17:22:32 <ddarius> byorgey: Most of his posts are very detail oriented.  Few of them would be "basic" category theory.  In fact, few of them would really be things categorists care about at all.  If you ask -any- categorist what a zygomorphism is, they will have no idea what you are talking about.  A lot of his work is "what can we do in Haskell," which is interesting by, in many cases, not very illuminating of category theory.
17:22:50 <elliott> DevHC^: We bear the existence of seq because it is useful.
17:23:03 <elliott> It used to be in a typeclass, but I gather that made signatures too burdensome.
17:23:13 <Eduard_Munteanu> hpc: erm, it's more like I want to see why edwardk bothers so much over Yoneda without googling through lots of research articles :)
17:23:16 <ddarius> s/by/but/
17:24:00 <DevHC^> where is it stated in the report, that (undefined :: a -> b) is _|_, as opposed to (\x -> _|_)?
17:24:10 <kmc> one thing i want to do, if i ever write a haskell intro, is avoid comparisons to other languages or really appealing to prior programming knowledge at all
17:24:17 <ddarius> undefined is _|_.
17:24:23 <byorgey> ddarius: oh, I see, I thought you were talking about "Basic Category Theory for Haskellers" as opposed to an edited collection of edwardk's posts
17:24:27 <kmc> i'd want to teach haskell from first principles
17:24:35 <byorgey> personally I do not think they would be the same at all.
17:24:37 <dalaing> kmc: shapiro's lisp book had a blend of little reinforcement problems, some mini-projects that were built up over the book, and implementing bits of lisp using other bits of lisp so you had to think about what it was doing - that really helped
17:24:54 <DevHC^> let's amend the report
17:25:27 <byorgey> DevHC^: undefined is always _|_ at any type
17:25:43 <byorgey> they are synonyms.
17:25:44 <kmc> cool
17:25:54 <kmc> yeah, metacircularity is great
17:26:00 <kmc> unfortunately a bit outside the scope of a Haskell intro
17:26:02 <copumpkin> > case undefined of In f -> text "no u"
17:26:03 <lambdabot>   no u
17:26:08 <byorgey> in the presence of seq, \x -> _|_ is more defined than undefined.
17:26:15 <dalaing> kmc: same would apply for making people write variants of their own fold I guess
17:26:15 <Peaker> I forget what meta-circularity is
17:26:17 <kmc> you can at least implement much of the std lib, though
17:26:23 <kmc> and toy models of IO and such
17:26:29 <kmc> to de-mystify those things
17:26:30 <DevHC^> (_|_ :: (a :: *)) is newly defined as the _|_ in the old sense, and (_|_ :: (a :: * -> x)) is a value which is not _|_, but (\x -> _|_)
17:26:33 <dalaing> kmc:  you could sneak monads in via a few repitions of Maybe etc...
17:26:37 <elliott> DevHC^: why?
17:26:43 <elliott> (const undefined) works for the latter.
17:26:49 <elliott> and your proposal is incredibly semantically confusing.
17:26:57 <geheimdienst> how about having the reader implement parts of Prelude? head, zip, map, ...
17:27:04 <kmc> yeah
17:27:15 <dalaing> kmc: and there'd be some scope to do some good mind-opening stuff with functor / monoids/ applicative if you could get the order / building-up of exercises and content just right
17:27:16 <byorgey> DevHC^: that is like saying 3 is equal to 3 except when adding it to 6, in which case it really means 4
17:27:22 <ddarius> byorgey: While there are some things that could be done to better gear a category theory introduction to Haskellers, I think there are already enough that are close enough.  In particular, I think Barr and Wells' lecture notes are good on their own merits and also use examples and terminology that should be pretty readily graspable by a Haskell programmer interested in category theory.
17:27:24 <DevHC^> not really, it's pretty clear:
17:27:27 <Eduard_Munteanu> DevHC^: all types contain 'undefined'
17:27:28 <elliott> Peaker: it's not really well-defined
17:27:39 <elliott> Peaker: but basically "an evaluator that utilises the host implementation's facilities"
17:27:52 <elliott> it basically requires homoiconicity to be truly meaningful
17:27:52 <DevHC^> seq on (a -> b) types does not go bottom, and only has effects on (a) types
17:27:59 <byorgey> ddarius: agreed, I like those lecture notes
17:28:06 <elliott> DevHC^: who mentioned seq? you were talking about adding a new language construct "_|_".
17:28:07 <kmc> elliott, ah, so it's a more specific term than "self-hosting"?
17:28:08 <DevHC^> so one could apply seq to (a -> b) types without effect
17:28:17 <Eduard_Munteanu> Anyway, can we at least agree edwardk should really write a book? :P
17:28:19 <elliott> kmc: well, it certainly has stronger _implications_
17:28:25 <elliott> I don't know that metacircularity can be defined precisely
17:28:26 <ddarius> Eduard_Munteanu: He's worked on some.
17:28:27 <DevHC^> i mentioned seq.
17:28:32 <elliott> but I wouldn't call GHC metacircular
17:28:34 <kmc> i thought this was just a case of "Lisp people use one term, everyone else uses another"
17:28:40 <elliott> or an interpreter that looked like GHC
17:28:44 <DevHC^> i've also quoted the report: "the existence of seq weakens Haskell's parametricity properties."
17:29:11 <elliott> DevHC^: Your change would not fix that.
17:29:12 * ddarius hates the term "homoiconic."  It doesn't mean anything, or at least anything meaningful.
17:29:15 <dalaing> kmc: if you ever do start on the book and want feedback etc... let me know, I'd love to see how it progresses / turns out
17:29:21 <elliott> DevHC^: Anyway, you can create a _|_ of type (a -> b) even if undefined doesn't let you:
17:29:24 <elliott> foo :: a -> b
17:29:28 <elliott> foo = let x = x in x
17:29:31 <DevHC^> elliott: ORLY
17:29:38 <mauke> elliott: foo = foo
17:29:42 <elliott> If you believe you can detect all such cases, I invite you to give Turing a call; he has a halting problem you may be interested in.
17:29:45 <copumpkin> ddarius: it does provide you with some meaningful information
17:29:52 <elliott> mauke: I was trying to make it not look like something trivially detectable.
17:29:53 <copumpkin> ddarius: about the person who used the word :)
17:29:54 <DevHC^> first of all, in what sense does seq weaken Haskell's properties?
17:29:57 <kmc> i'd also want the book to be very very declarative and denotational in the beginning
17:30:01 <ddarius> copumpkin: I typed too slowly.
17:30:05 <kmc> don't talk about "Haskell does this, Haskell does that"
17:30:15 <kmc> just equations and properties and meaning
17:30:15 <DevHC^> well, first of all, "In the presence of
17:30:15 <DevHC^> seq
17:30:15 <DevHC^> , the
17:30:15 <DevHC^> foldr
17:30:15 <DevHC^> build
17:30:16 <DevHC^> -rule is not anymore a semantic equivalence. "
17:30:24 <DevHC^> what else?
17:30:46 <elliott> DevHC^: People have thought about this extensively before you; there is no simple solution that's satisfactory to everyone.
17:31:04 <DevHC^> elliott: go on
17:31:15 <elliott> DevHC^: Go on what?
17:31:21 <DevHC^> explain
17:31:26 <elliott> Explain what?
17:31:35 <DevHC^> what have the People thought about?
17:31:57 <elliott> The issue of seq wrt. Haskell's properties and what changes might be made to lessen their effect while retaining its utility.
17:32:00 <DevHC^> what are the things in my idea that do not satisfy some people ?
17:32:09 <Peaker> DevHC^: can you repeat your idea?
17:32:19 <elliott> It doesn't fix the issue; like I demonstrated, you can define a bottom value of type (a -> b) even if undefined does not yield one.
17:32:39 <dalaing> kmc: I think the holy grail for exercises would be some over-arching project that requires a specific data structure - introduce it first, manipulate it the long way to demonstrate the language, then start introducing things like function / monoid / applicable, end up with foldable / traversable and/or a zipper for the structure
17:32:49 <dalaing> kmc: depends on how far you want to go with it I guess :)
17:33:50 <eyebloom> What is the best way to step through and debug haskell programs?
17:33:55 <DevHC^> elliott: no, { foo :: a -> b ; foo = let x = x in x } is not the bottom as under my definition of bottom
17:34:58 <napping> equivalent to const bottom?
17:35:04 <elliott> DevHC^: Yes, it is bottom.
17:35:05 <DevHC^> yes
17:35:10 <DevHC^> napping^
17:35:10 <elliott> Whether you think it is or not, it's bottom.
17:35:19 <elliott> And (foo `seq` anything) = bottom too.
17:35:25 <elliott> So you haven't solved the seq-on-functions issue in the slightest.
17:35:31 <DevHC^> i said
17:35:47 <DevHC^> that seq on functions not to have effect on bottomicity
17:35:59 <DevHC^> so foo is not bottom, and seq cannot be used to disprove that
17:36:01 <mauke> so you want seq to break parametricity
17:36:10 <DevHC^> ?
17:36:17 <mauke> isFunction :: a -> Bool
17:36:28 <mauke> isFunction x = x `seq` True
17:36:45 <napping> isFunction () == True
17:36:46 <mauke> isFunction x = (undefined `asTypeOf` x) `seq` True
17:36:56 <DevHC^> lol
17:37:35 <elliott> DevHC^: seriously, unless it takes you more than a week to come up with your idea, there is a very good chance it has already been proposed.
17:37:44 <DevHC^> of course.
17:37:47 <mauke> `catch` (\(SomeException _) -> False)
17:38:00 <DevHC^> and now, let's talk about this idea, possibly YET AGAIN.
17:38:07 <copumpkin> :O
17:38:21 <ddarius> elliott: This idea has not been proposed because it's completely retarded.
17:39:03 <elliott> ddarius: Well, I wouldn't use those words, but it certainly hurts about a hundred times more than it helps, yes.
17:39:03 <copumpkin> lol
17:39:12 <DevHC^> ddarius: ORLY, explain what is wrong with this idea
17:39:20 <ddarius> elliott: That's why I'm here.  I would use those words.
17:39:23 <copumpkin> I've been to Orly
17:39:24 <elliott> Can you please stop saying "ORLY" all the time?
17:39:27 <elliott> It's really grating.
17:39:39 * copumpkin pulls out his Orly Owl for elliott 
17:39:41 <DevHC^> what about words like "retarded"?
17:39:56 <elliott> copumpkin: You kidnapped an owl from Orly?
17:40:03 <copumpkin> http://orlyowl.tripod.com/sitebuildercontent/sitebuilderpictures/orly.jpg
17:40:12 <copumpkin> yep
17:40:16 <elliott> I am left underwhelmed.
17:41:09 <napping> DevHC^: I think you are on a useful track, but need to go much farther to repair the semantic damage
17:41:36 <DevHC^> which is why we are discussing this
17:41:56 <benmachine> DevHC^: I suspect that seq is the way that it is because in practice it is occasionally necessary to force evaluation of functions
17:42:07 <benmachine> e.g. to prevent huge thunks building up
17:42:17 <DevHC^> example?
17:42:22 <napping> oh, wait, if you are trying to incorporate seq it's not like what I'm thinking of
17:42:30 <napping> heh, execution efficiency
17:42:39 <benmachine> DevHC^: I said "I suspect" because I don't have an example :P
17:42:45 <napping> no chance of that down the direction I
17:42:47 <napping> 'I'm thinking of
17:43:13 <elliott> Are record accessors exposed with the "Foo(...)" syntax in a module declaration, or do they have to be named separately? I distinctly recall the truth surprising me at least twice.
17:43:17 <napping> edwardk: I got a parser working and the error message is spiffy, but I haven't figured out how to cram an ErrState into an ErrLog
17:43:42 <napping> I have no clue what many of the types are supposed to represent
17:44:09 <edwardk> the problem is ErrState isn't quite a diagnostic
17:45:08 <napping> like, why is there a set of Carets?
17:45:33 <edwardk> ?
17:45:36 <elliott> DevHC^: example: foldr (.) id (huge list)
17:45:42 <edwardk> which version of trifecta are you on?
17:45:48 <elliott> I think seqing that will help in cases of huge lists
17:45:55 <napping> whatever was on Hackage as of a day or two ago
17:45:57 <ddarius> elliott: No.
17:46:06 <edwardk> can you ghc-pkg list | grep trifecta ?
17:46:21 <napping> trifecta-0.47
17:46:24 <edwardk> k
17:46:32 <edwardk> what do you mean a 'list of carets'?
17:46:34 <SonicvanaJr> Is there a pattern for handling Maybe t when you're expecting t that a new haskell programmer may not know?
17:46:48 <elliott> ddarius: Hmm, right, (.)'s result is in WHNF.
17:46:49 <napping> I said set, as in Set
17:46:55 <elliott> A hugely-nested unsafe memoisation?
17:46:56 <kmc> :t fromMaybe -- SonicvanaJr
17:46:57 <lambdabot> forall a. a -> Maybe a -> a
17:46:59 <kmc> :t maybe -- SonicvanaJr
17:46:59 <elliott> (As in, that does unsafePerformIO from outside.)
17:47:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:47:01 <edwardk> oh
17:47:14 <elliott> But that's probably (unsafePerformIO (do ...; return (\... -> ...)), so it wouldn't help.
17:47:16 <kmc> > map (fromMaybe 3) [Just 2, Nothing, Just 4]
17:47:17 <lambdabot>   [2,3,4]
17:47:21 <edwardk> in here http://hackage.haskell.org/packages/archive/trifecta/0.47/doc/html/Text-Trifecta-Diagnostic-Err-State.html
17:47:53 <kmc> SonicvanaJr, pattern-matching is the most fundamental way, but these helper functions are useful
17:48:02 <napping> yeah, that's one example. I'm just generally having a hard time trying to work out what all the types (and fields of types) are supposed to represent
17:48:10 <edwardk> those are the 'expected' messages. normally when we get ready to render a diagnostic message from an ErrState we take those and bundle them together if they wind up at the location of the ultimate error or attach them grouped elsewhere
17:48:11 <SonicvanaJr> kmc: Thanks.
17:48:57 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/0.47/doc/html/src/Text-Trifecta-Parser-Prim.html#why describes how i turn an ErrState into an actual diagnostic
17:49:43 <edwardk> the idea is that you have a bunch of messages that say what was expected where that contributed to the current error
17:50:07 <edwardk> most of the time i can just draw the ^ at the location and all the things that were expected were expected at the same location, so i generate a message like
17:50:23 <edwardk> error: foo, expected: bar, baz, semi-colon, or quux
17:50:27 <napping> I looked through that file, but I didn't see where to get a Highlights Delta or ByteString to call it, or what the Bool meant, so I continued browsing around through other things
17:50:43 <edwardk> otherwise i may have to attach separate notes at multiple cursor locations
17:50:50 <napping> Oh, also it returns Diagnostic (Doc t) and parseTest seems to need a Diagnostic String
17:50:58 <napping> I guess fmap show could solve that, maybe
17:51:18 <edwardk> yeah the problem is i don't currently expose what you want/need
17:51:47 <edwardk> ErrState exists because the user message type doesn't have any good way to embed panics or failures
17:52:01 <napping> so, you'd have a Set (Caret String) where each thing in the set describes one token that might have been expected, and you deduplicate repeated locations?
17:52:11 <edwardk> exactly
17:52:21 <edwardk> it used to be just a Set String
17:52:32 <napping> Oh, then what knows how to string together the list of token names into a single message?
17:52:36 <edwardk> which is basically the behavior of parsec (they keep it in a list of messages
17:52:58 <edwardk> why does that with expect xs = text "expected:" <+> fillSep (punctuate (char ',') (Prelude.map text $ ignoreBlanks $ Prelude.map extract xs))
17:53:23 <edwardk> then based on what kind of diagnostic it is, it bolts that onto your pretty printed error message
17:53:32 <napping> Ah, so it was integer
17:53:34 <edwardk> normally your diagnostics are just Diagnostic String
17:53:52 <napping> I think a one-line description of each type would immensely improve the comprehensiblity of the documentation
17:54:02 <edwardk> i agree
17:54:24 <edwardk> i've mostly been trying to figure out the right shape everything should have. only recently have i started having people actually want to use it ;)
17:54:43 <napping> I could paste the parser somewhere
17:55:03 <edwardk> i may eliminate ErrState and fold its functionality into Diagnostic
17:55:15 <napping> it seems to handle correct input (not sure about the extent of lets), and the diagnostics are pretty, but I only get one
17:55:22 <edwardk> i've recently begun a lot of cleanup on the diagnostic front
17:55:49 <edwardk> if need be you can just log your diagnostic and then use mzero
17:55:59 <napping> Here's the exercise, describing the recovery I'm trying to get: http://llvm.cs.illinois.edu/~vadve/cs426/html/project.html
17:56:21 <edwardk> can you hpaste or drop me a github link or something to the grammar you have?
17:57:41 <edwardk> ah all the recovery notes in http://llvm.cs.illinois.edu/~vadve/cs426/Project/mp1.pdf ?
17:57:55 <napping> here's a temporary paste http://pastebin.com/Zp5BKjkg
17:57:57 <mauke> The paste Zp5BKjkg has been copied to http://hpaste.org/51507
17:58:11 <napping> ?
17:58:40 <napping> I was trying to avoid leaving a permanent copy of a grammar for a language used only for compiler assignments...
18:00:31 <Cale> I have a feeling that mauke has a script running in his client which does that automatically
18:00:41 <ddarius> napping: You should be able to get it deleted with the Report/Delete link, if it is a problem.
18:01:20 <edwardk> so when something goes wrong in lexing you want to resume according to the rules in that pdf and track that you've gone wrong somewhere so you can fail in the end?
18:01:32 <mauke> not anymore: http://mauke.dyndns.org/interweb/http%3A//hpaste.org/51507.html
18:01:36 <napping> that's what I was aiming for
18:01:46 <edwardk> k
18:02:34 <napping> more generally, just a way to do something like bison-style error recovery
18:02:34 <elliott> temporary pastes kind of break the logs
18:02:35 <elliott> but yeah, mauke definitely does that automatically
18:03:18 <mauke> elliott: you have no proof!
18:03:25 <edwardk> first thing i guess we need is a place to actually say that something went wrong and we recovered so when you're done parsing you don't go to use the result. probably swapping to something like WriterT All (Parser String) instead of Parser String
18:03:30 <benmachine> he's just really fast at typing
18:03:38 <elliottcable> I have all of hte proof.
18:03:42 <elliott> http://pastebin.com/Zp5BKjkg
18:03:42 <elliott> http://pastebin.com/Zp5BKjkg
18:03:42 <mauke> The paste Zp5BKjkg has been copied to http://hpaste.org/51507
18:03:42 <elliottcable> How much of the proof do you want?
18:03:42 <mauke> The paste Zp5BKjkg has been copied to http://hpaste.org/51507
18:03:42 <elliott> http://pastebin.com/Zp5BKjkg
18:03:42 <mauke> The paste Zp5BKjkg has been copied to http://hpaste.org/51507
18:03:43 <elliott> http://pastebin.com/Zp5BKjkg
18:03:43 <mauke> The paste Zp5BKjkg has been copied to http://hpaste.org/51507
18:03:48 <elliott> mauke: wow, you really _are_ fast at typing
18:03:48 <elliottcable> I have bags and bags and bags of proof.
18:03:55 <mauke> elliott: up + enter
18:03:55 <elliott> hi elliottcable
18:04:03 <Jafet> You are too, elliott!
18:04:03 <edwardk> then you can tell (All False) and when you runWriterT at the end get out whether or not the parser failed
18:04:05 <elliottcable> hi not-elliott
18:04:14 <elliott> mauke: Ah, okay. I'm done testing then
18:04:15 * elliott http://hpaste.org/51507
18:04:23 <elliottcable> having an argument in #elliottcable about whether or not bottled water is evil
18:04:24 <elliott> Darn.
18:04:29 <elliottcable> my garage: http://ell.io/3WI7
18:04:32 <elliottcable> so, I think not.
18:04:33 <elliott> elliottcable: You have a channel named after yourself?
18:04:46 <benmachine> elliott: you mean you *don't*?
18:04:46 <shachaf> elliott: He also has a nick named after himself. Sadly, it's taken.
18:04:51 <Pseudonym> Which side of the argument are you takeing?
18:04:52 <edwardk> i may bundle a Recovering parser transformer that does that intrinsically
18:04:54 <Pseudonym> taking
18:05:08 <edwardk> til now i've done so by hand
18:05:11 <elliottcable> Pseudonym › “fuck the environment, and fuck logic, I like my bottled water.” ← that side.
18:05:14 <napping> edwardk: hmm, it sounds like it will be necessary to write a parser that skips the bad parts
18:05:16 <elliott> shachaf: And now I have #elliott, too!
18:05:19 <elliott> elliottcable: Pony up the cash, bro.
18:05:21 <edwardk> yes
18:05:28 <elliottcable> elliott › you declined my offer, if I remember correctly. ^‿^
18:05:41 <napping> running into the problem that bison-style error token doesn't seem to have much of a semantic interpretation
18:05:51 <elliottcable> I’ve been trying to get the owner of http://pa.ws/ to sell
18:05:54 * ddarius likes bottled water when the local water is undrinkable.
18:05:57 <elliott> elliottcable: It involved an insufficiently large amount of money. I am open to bartering.
18:06:01 <elliottcable> but he keeps declining every offer, and I’ve gone pretty damn high /=
18:06:05 <elliottcable> elliott › hah!
18:06:33 <edwardk> the other problem is bison style error tokens are rather intrinsically an LALR concept
18:06:47 <Zira> How is going to Haskell from Python?
18:07:02 <edwardk> in LL(k) you usually write some kind of manually skip and resume case
18:07:15 <Pseudonym> Zira: Bernie Pope is working on a Python to Haskell compiler, IIRC.
18:07:43 <kmc> Zira, you mean for learning?
18:07:47 <napping> they are certainly described in terms of the machine
18:07:47 <Zira> yes.
18:07:56 <kmc> pretty hard? i don't know how to quantiy
18:08:02 <kmc> Haskell is hard; it's very different from most languages
18:08:08 <napping> I think something similar might be rationalize in a probabilistic parsing framework
18:08:21 <Pseudonym> kmc: Non sequitur.
18:08:45 <kmc> ?
18:09:00 <Pseudonym> Just because it's very different doesn't make it hard.
18:09:17 <napping> low probability productions for error from any token, and to glom extra tokens onto error
18:09:17 <kmc> Pseudonym, ; ≠ ⇒
18:09:35 <Pseudonym> Fair enough, but I dispute that Haskell is hard.
18:09:44 <kmc> ok
18:09:56 <kmc> i like to set expectations of difficulty high
18:09:59 <Pseudonym> Czech isn't hard. Lots of kids speak it.
18:10:24 <napping> bad example, lots of kids speak any language, regardless of difficulty
18:10:25 <mauke> chinese is the easiest language in the world
18:10:33 <ddarius> kmc: It would be ⇐ that would be the relevant implication.
18:10:41 <kmc> ugh
18:10:47 <Pseudonym> Were Haskell your first programming language, you wouldn't find it difficult.
18:10:47 <kmc> this channel is full of pedants ;P
18:11:06 <kmc> Pseudonym, that's clearly not the situation Zira is in.  and i disagree anyway
18:11:08 <Pseudonym> The problem is that if it's not your first language, you probably need to unlearn some false assumptions.
18:11:10 <napping> Zira: I'd learned Python right before Haskell, without much trouble
18:11:11 <kmc> some of the reasons it's difficult would go away
18:11:13 <kmc> others would not
18:11:16 <edwardk> napping: there is something similar to that in uu-parsing-lib
18:11:28 <edwardk> napping: they track the 3 most probable parses as they go
18:11:31 <Pseudonym> But here's the thing. Learning Haskell makes your Python better.
18:11:35 <edwardk> in a breadth first fashion
18:11:39 <ddarius> Pseudonym: You'd probably find it the most difficult language you learn, if it were your first language.
18:11:42 <geheimdienst> i think nearly everyone learns haskell after learning some other language. the case of haskell as a first language is largely theoretical
18:11:49 <Nimatek> Java is hard. All the boilerplate blots out the sun.
18:11:50 <morolin> Pseudonym: Do you have any data to back that up?  (About haskell being eaiser if it was your first language?)
18:11:55 <edwardk> that way they never have to backtrack
18:12:00 <kmc> geheimdienst, a fair number of schools use it as an intro language
18:12:14 <kmc> morolin, it's Common Wisdom, which isn't to say it's actually justified
18:12:18 <Pseudonym> I don't personally, but it was taught as a first language in several undergraduate computer science courses around the world in the late 90s.
18:12:22 <Zira> Is one likely to run into terms in the documentation that one has not run into learning Python?
18:12:25 <Pseudonym> There is some hard data on it.
18:12:31 <Pseudonym> Zira: Yes.
18:12:35 <kmc> oh yes Zira
18:12:37 <ddarius> geheimdienst: There are tons of people who learned Haskell as their first language in universities.
18:12:47 <Pseudonym> True of most languages, BTW.
18:13:04 <morolin> Pseudonym: huh, interesting.  Didn't know that any schools used it as an intro language.
18:13:17 <geheimdienst> yes yes, but most people enrolling in computer science have at least dabbled in whatever language
18:13:25 <kmc> not sure about that geheimdienst
18:13:28 <Pseudonym> geheimdienst: Not as true as you might think.
18:13:30 <kmc> maybe half
18:13:41 <Pseudonym> Especially in the dot.com era.
18:13:45 <kmc> would be interested in knowing the actual number
18:14:33 <Pseudonym> Remember, there are a lot of people who do CS as an undergrad for whom that's not their major.
18:14:48 <kmc> Zira, the important Haskell concepts are different from the concepts in other languages, and accordingly they have different names
18:14:53 <Pseudonym> They're actually trying to be meteorologists or something, for which some computer programming is a prerequisite.
18:14:56 <edwardk> geheimdienst: the fact that it is such a mixed bag is why a lot of colleges started using scheme as their intro language, the "how to design programs" school of thought is that it levels the playing field and rewards hard work rather than leading to a class that is boring for the folks who have programmed or impossible for those who havent
18:15:05 <kmc> Zira, you may be used to the idea that each new language is just new syntax and terminology for old ideas, but that's not the case here
18:15:10 <shachaf> kmc: Or sometimes they're the same concepts and have different names.
18:15:13 <ddarius> Not representative, but in my military tech school I'd say less than say 5% of the people who were going to go into a programming career field had any prior programming experience and probably less than 10% had significant programming experience.
18:15:17 <shachaf> Or sometimes they're different concepts and have the same name.
18:15:20 <kmc> (well, the ideas *are* old, but they're from other even more obscure languages)
18:15:21 <napping> edwardk: I though antlr did something similar, but I guess its not that similar after all
18:15:30 <Zira> kmc: I am only familiar with Python thus far.
18:15:33 <kmc> ok
18:15:38 <Pseudonym> edwardk: It also means that you're learning Computer Science(tm) in the first semester rather than, say, Quirks in the Syntax of C.
18:15:47 <napping> Zira: hmm, I'd done some C and stuff before
18:16:03 <kmc> Zira, if you know Python then learning Ruby is mostly a matter of learning new syntax and terms.  if you know Python then learning Haskell requires learning a totally new way to think
18:16:13 <edwardk> napping: you have the disadvantage of being the first person that is actually trying to _use_ trifecta for anything non-trivial other than dylukes so be aware there are some rough edges still ;)
18:16:32 <dylukes> :D
18:16:35 <dylukes> I've found bugs!
18:16:41 <edwardk> new ones?
18:16:46 <dylukes> no, I mean before.
18:16:48 <edwardk> whew
18:16:49 <edwardk> yeah
18:16:51 <dylukes> and, why not just call him the second person then
18:16:54 <dylukes> I like being the first person.
18:16:57 <edwardk> for a while try was braindead and didn't backtrack ;)
18:17:00 <dylukes> It makes me feel like a hackage hipster.
18:17:03 <napping> I'm not sure I'd recognize a bug if it bit me
18:17:09 <dylukes> Gridbugs.
18:17:09 <kmc> Zira, I think it's well worth the effort, but don't expect to write some amazing complicated program in the first day or even the first month
18:17:10 <dylukes> Hate'm.
18:17:23 <kmc> there's a lot of struggling to do something simple and then it 'clicks'
18:17:28 <kmc> and repeat
18:17:41 <Zira> kmc: If I had such expectations, they were killed while learning Python.
18:17:47 <kmc> i see
18:17:57 <dylukes> I think Ruby is simpler and more elegant than Python.
18:18:07 <dylukes> It's generally more consistent and simpler structurally.
18:18:13 * JoeyA is writing some amazingly complicated program after the first year and a half (at least I think it is ;-) )
18:18:23 <dylukes> I also appreciate the existence of the Module in Ruby.
18:18:24 <kmc> dylukes, I'm not interested in arguing about Ruby vs Python, especially in #haskell
18:18:26 <napping> Zira: meh, don't let people worry you, get an implementation and some documentation and try stuff
18:18:27 <dylukes> kmc: I agree.
18:18:44 <edwardk> i never had a place for ruby. i knew both perl and python, when i first encountered it, so it never had a role that it fit better than any of the other languages i knew
18:18:45 <dylukes> I don't think its a valid thing to argue really...
18:18:59 <napping> Zira: There are said to be better tutorials than the Gentle Introduction and the language standard these days...
18:19:03 <DevHC^> does GHCi work with -XSafe?
18:19:07 <dylukes> edwardk: I've found perl incomprehensible, and python's supposed "principle of lease surprise" never kicked in.
18:19:14 <kmc> DevHC^, did you try it?
18:19:18 <DevHC^> no
18:19:25 <kmc> DevHC^, I've not read that it doesn't work...
18:19:27 <napping> Zira: even learning Ruby or Lua or something, they have different names for stuff, and different stuff
18:19:28 <kmc> I've not tried it either
18:19:32 <edwardk> perl makes a lot of sense if you've written 10 years or shell programs and c before coming to it ;)
18:19:35 <DevHC^> (and i don't have access to GHC >7.0.3)
18:19:37 <kmc> edwardk, funny that
18:19:40 <kmc> edwardk, also awk and sed :)
18:19:44 <edwardk> if you haven't, you aren't the target audience ;)
18:19:52 <Pseudonym> Yeah, Perl is a better shell/AWK/sed.
18:19:55 <edwardk> kmc: how do you think you got anything done in your shell programs ;)
18:20:04 <Pseudonym> Oh, and expect.
18:20:09 * ddarius isn't the target audience of Perl.
18:20:22 <Zira> napping: Names might be different, but reading the Python documentation, not knowing any languages prior to that, made certain aspects difficult, as there were some concepts one were expected to already know.
18:20:28 <kmc> for me, sed is a domain-specific language for applying regex substitutions, and awk is a domain-specific language for printing the nth whitespace delimited field of each line
18:20:33 <kmc> i'm vaguely aware that they are capable of more
18:20:33 <ddarius> @google gawk high level language
18:20:34 <lambdabot> http://www.gnu.org/software/gawk/manual/gawkinet/html_node/Gawk-Special-Files.html
18:20:34 <lambdabot> Title: Gawk Special Files - TCP/IP Internetworking With `gawk'
18:20:39 <ddarius> Not what I wanted.
18:21:09 <Pseudonym> kmc: You can write AWK programs longer than one line, you know that? Of course, if you are, you're probably doing something wrong...
18:21:19 <kmc> yep
18:21:49 <kmc> UNIX is overcomplete; there are many subsets of tools each of which suffices to get stuff done
18:22:05 <edwardk> dylukes: its main raisons d'etre are the fact that it reduced the number of processes spawned by an insane number speeding things way up, had cpan, which made it possible to talk to anything, and most importantly it really was the first language to give you some REALLY strong primitives like hashes and arrays right out of the box
18:22:30 <dylukes> yeah, I can imagine
18:22:31 <edwardk> coming at it today i'd be hard pressed to pick it up. most of those advantages have been picked up by other languages
18:22:32 <Pseudonym> kmc: Just like Perl.
18:22:33 <dylukes> I never learned any perl though.
18:22:48 <dylukes> Before my time I suppose.
18:23:02 <napping> Zira: hmm, I think assuming you already know things might be a bit less of a problem
18:23:06 <Pseudonym> I was personally chewed out by ESR for using Perl.
18:23:20 <Pseudonym> This was at a Perl conference, mind you. Where my paper won an award.
18:23:46 <Pseudonym> Admittedly, the Perl conference coincided with OSCON.
18:23:48 <napping> Zira: Expecting you to understand a new concept from a brief but probably technically complete definition is another matter...
18:24:07 <edwardk> perl is how we ran the entire phone company and ISP where I used to work. I'd written billing, accounting, provisioning systems, the terminal server, heck out DHCP server was written in perl.
18:24:11 <edwardk> er heck our
18:24:52 <dylukes> perl also made regexes easy no?
18:24:56 <edwardk> had RADIUS implemented in perl, a bunch of code for rating telephone calls, etc.
18:24:57 <edwardk> yeah
18:25:01 <tomberek> what's the root difference between a data family inside of a type class vs a root level one? associated vs family?
18:25:39 <edwardk> tomberek: nothing except that saying you have an instance of the class means you must have a type family or data family instance that lines up
18:25:49 <parcs> you can default an associated type
18:25:51 <edwardk> tomberek: associated types are just sugar
18:26:01 <edwardk> parcs: well, now you can =)
18:26:09 <tomberek> parcs: well, that's in HEAD, right?
18:26:20 <parcs> yeah :P
18:26:47 <bcw> dylukes, "principle of least surprise" is a Ruby slogan, not Python
18:26:54 <tomberek> edwardk: would there be any advantage to moving an associated type outside to make it a data family?
18:26:58 <dylukes> bcw: oh right XD
18:27:05 <dylukes> Python is one-good-way-to-do-anything no?
18:27:10 <dylukes> i.e, one specific way
18:27:18 <edwardk> yeah perl is "do what i mean", python is "there is one right way to do it", ruby doesn't like surprises ;)
18:27:24 <dylukes> btw, is there any way to tell ghc-pkg
18:27:25 <napping> edwardk: I think I'll have to manually write a resynchronization thing that consumes tokens and stops before anything that looks like it might start a valid term
18:27:28 <dylukes> "stop fuckign coloring my output?"
18:27:42 <edwardk> napping: yes, no way around that
18:27:42 <shachaf> dylukes: | cat
18:27:43 <napping> I guess if I only recover at terminators it's a bit easier
18:27:45 <DevHC^> lol
18:27:46 <DevHC^> trol: internal error: getMBlock: mmap: Invalid argument
18:27:46 <DevHC^>     (GHC version 7.0.3 for i386_unknown_freebsd)
18:27:46 <DevHC^>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
18:27:54 <Pseudonym> bcw: Ruby insists that you shouldn't be surprised if a non-duck quacks.
18:27:59 <dylukes> shachaf: well yes, but then I have parens ...
18:28:02 <bcw> dylukes, yeah, "there should be one--and preferably only one--way to do it".  along with ~10 other sloagans in "The Zen of Python" (shown by "import this")
18:28:06 <dylukes> ugh I'll just remove them with my regex
18:28:08 <shachaf> dylukes: Just like most every other program that colors output.
18:28:12 <mauke> dylukes: the python motto is a lie, of course
18:28:12 <edwardk> napping: sorry if i wasn't clear about that in the beginning
18:28:14 <shachaf> dylukes: Regex? What?
18:28:16 * ddarius is unsurprised that ruby recapitulates typical misdesigns.
18:28:18 <dylukes> from __future__ import braces
18:28:32 <bcw> heh, yeah, that one is funny too
18:28:34 <napping> edwardk: well, I have a vague notion of a "manyRecover" that takes a list of alternative productions, and somehow gathers their start sets for use in error recovery
18:29:25 <napping> It's too bad combinator parsers are so nice to write, but don't do much error recovery
18:29:38 <edwardk> well, i have an applicative parser fragment that deals with generating the swierstra and duponcheel static parser initial character set
18:29:43 <ddarius> Use a combinator parser that does error recovery.
18:30:12 <elliott> DevHC^: Are going around passing ridiculous numbers to functions that allocate memory or something?
18:30:25 <DevHC^> yes
18:30:26 <elliott> Or are you really trying to find the appropriate structure to allocate a bajillion gigabytes? :-P
18:30:29 <edwardk> i could get that into trifecta and then you could use the noneOf … for the starter set
18:30:40 <napping> ddarius: which are there? I only remember seeing the apparently uncontrollable automatic recovery in uu-parsing
18:30:55 <dylukes> rubular is wonderful
18:31:05 <DevHC^> i'm still trolling around with that array segfault case
18:31:48 <DevHC^> i get this mmap error when the (number of Ints  * 4) just wraps around a 32-bit unsigned int (on a 32-bit system)
18:31:59 <dylukes> lol just remember ghc-pkg dot
18:32:01 <dylukes> >_>
18:33:36 <napping> Perhaps I need to fashion my own parser combinator library
18:33:48 <Pseudonym> napping: Why not? Everyone else does.
18:35:54 <ddarius> napping: I thought polyparse also did error recovery stuff.  UU would be the most significant one.
18:38:38 <ddarius> The UU parsing lib documentation is unusually structured.
18:39:49 <elliott> Utrecht code is like the uncanny valley of Haskell.
18:39:59 <dylukes> http://71.182.229.20/~dlukes/index.html
18:39:59 <dylukes> OH GOD
18:40:01 <dylukes> cabal dependencies
18:40:04 <dylukes> are so terrifying
18:40:04 <dylukes> :<
18:41:19 <napping> ddarius: thanks, I'd forgotten about polyparse
18:41:28 <mgsloan> I've been messing with something that tries to search for a token subset that compiles
18:41:35 <dolio> Use frisby.
18:41:38 <edwardk> i don't recall anything magic for recovery in polyparse
18:41:41 <mgsloan> so if you've got some malformed fragments, they'll be elided
18:41:41 <napping> you often have to insert tokens
18:42:06 <ddarius> @hackage frisby
18:42:06 <lambdabot> http://hackage.haskell.org/package/frisby
18:42:09 <napping> edwardk: from a cursory inspection, it sounds like of like the bracket combinators may be wired into error recovery, or something
18:42:26 <dolio> Wow, did he actually cabalize it himself?
18:42:26 <napping> can trifecta work over lexed input?
18:42:29 <edwardk> oh, well, that is going into trifecta once the dyck language skeleton works
18:42:37 <bcw> i have tried to use frisby w/o success.  i couldn't find any complete examples that use it.  just the tiny examples in the docs
18:42:59 <dolio> I've never used it.
18:43:20 <edwardk> not as such, but what you can do is make a lexer that generates "P Token" for your parser P, and then consume those
18:43:31 <dolio> I like the idea of a set of parsers that depends essentially on laziness, though.
18:44:05 <ddarius> dolio: Did you read the papers on Packrat parsing (i.e. on Pappy?)
18:44:30 <dolio> Nah, it's in my ever expanding pile.
18:44:41 <dolio> I've skimmed some packrat stuff before.
18:46:10 <dolio> I also like that frisby is a combinator library, instead of a parser generator like pappy.
18:46:43 <dylukes> edwardk: maybe I should make a plot of the intermodule dependencies in Trifecta :P
18:46:45 <dolio> It's also the only interesting use of mfix I've ever seen anyone come up with, I think.
18:46:51 <ddarius> dolio: There was a combinator library made as well along with pappy.
18:46:55 <edwardk> sounds like fun
18:47:12 <edwardk> yeah frisby is pretty neat
18:47:17 <dylukes> edwardk: all I need is a json file with the following structure
18:47:38 <edwardk> well you can pretty easily grep to get the import list
18:47:45 <dylukes> {nodes: <a list of nodes with the name property>, links: <a series of {source: node_index, target: node_index}}
18:47:52 <edwardk> or write a few lines of perl ;)
18:47:59 <dylukes> or a regex >_>
18:48:01 <ddarius> or a few lines of Haskell.
18:48:08 <dylukes> many ways to approach this
18:49:27 <elliott> dolio: I've seen another legitimate use of mfix.
18:49:34 <elliott> To generate an infinite list of IORefs.
18:49:57 <ddarius> Any time you use letrec or the equivalent in an impure language, that would translate to a use of mfix .
18:51:12 <monochrom> I don't think mfix can generate infinitely many IORefs. how did you see it done?
18:51:24 <dolio> Not just letrec, though.
18:51:32 <dolio> Value-recursive letrec.
18:51:35 <napping> edwardk: I don't see how you'd use P Token
18:51:58 <napping> unless you mean to layer individual parsers on that which parse one token and fail if it's not the one they wanted? sounds ineffecient
18:51:59 <ddarius> dolio: I'm not saying every case would be non-trivial.
18:52:09 <monochrom> recall that mfix (blah putStrLn blah) only executes the putStrLn once, as does mfix (blah newIORef blah) executes the newIORef once
18:52:59 <edwardk> string = do StringToken s <- token; return s    int = do IntToken n <- token; return n  -- is a boring way to do it
18:53:17 <napping> wouldn't that rerun the token parser and backtrack a lot?
18:53:36 <napping> anyway, the diagnostics in trifecta are very nice
18:53:37 <edwardk> sure
18:53:47 <edwardk> thanks =)
18:54:27 <edwardk> i mostly focused on the messages themselves. i haven't actually put too many combinators together for handling them yet though
18:55:56 * ddarius decides that he should probably do enough of the assignments so that he doesn't fail these classes.
18:56:21 <elliott> <monochrom> I don't think mfix can generate infinitely many IORefs. how did you see it done?
18:56:24 <elliott> monochrom: it used unsafeInterleaveIO
18:57:05 <monochrom> well that's cheating
18:57:18 <copumpkin> Mu IORef
18:57:32 <elliott> Hey, I'm just saying, it's a use of mfix I've seen in practice :P
18:57:36 <elliott> copumpkin: nice
18:57:51 <monochrom> I would say it's a use of unsafeInterleaveIO
18:57:58 <ddarius> :t mfix $ newIORef . In
18:57:59 <lambdabot> Not in scope: `newIORef'
18:58:02 <elliott> monochrom: One that wouldn't work without mfix
18:58:14 <elliott> Well, I don't think
18:59:30 <monochrom> I see it now. it has to combine both
19:00:25 <napping> edwardk: did I send you the language grammar?
19:01:58 <edwardk> you sent me a link to a website that had a pdf and a gzipped set of files
19:02:14 <monochrom> I should add such a pathological application to the haskell wiki page for mfix!
19:02:52 <monochrom> (after these messages from our sponsors!)
19:03:51 <JoeyA> Is it possible to run hlint on a cabal package rather than just an individual .hs file?
19:07:40 <blackdog> JoeyA: find . -iname '*\.hs' |xargs hlint ?
19:07:45 <blackdog> go ugly early, i always say
19:07:56 <ddarius> It is mildly interesting that Mu IORef is not a trivial structure.
19:08:17 * ddarius doesn't want to meet blackdog's wife.
19:08:48 <blackdog> ddarius: my girlfriend, and i hasten to add this applies only to programming. she's a peach.:)
19:10:15 <JoeyA> I learned a new phrase, thanks.
19:10:39 <JoeyA> (urbandictionary.com is ever helpful)
19:18:42 <DevHC> > 1 + 1
19:18:51 <DevHC> hmm, DOSy :]
19:19:03 <lambdabot>   thread killed
19:19:11 <DevHC> :D
19:21:20 <bcw> Denial Of Servicey or Disk Operating Systemsy? :P
19:22:15 <DevHC> the latter, obviously :P
19:22:49 <Cale> > 1 + 1
19:22:50 <lambdabot>   2
19:23:14 <mkfort> > 2 ** 8
19:23:15 <lambdabot>   256.0
19:23:22 <DevHC> Cale: only while i pwn lambdabot @ PM sp4m
19:25:04 <hpaste_> “unbounded IORef chain” pasted “monochrom” at http://hpaste.org/51508
19:25:47 <monochrom> elliott: I don't need mfix in http://hpaste.org/51508 , just ordinary recursion (fix, if you like)
19:26:22 <elliott> monochrom: hmm. I managed to track down the program with it, I'll paste what it does
19:27:14 <hpaste_> “elliott (not my code)” annotated “monochrom” with “monochrom (annotation)” at http://hpaste.org/51508#a51509
19:29:04 <monochrom> the mfix there is for another purpose
19:30:09 <monochrom> the mfix there sets up a cyclic structure rather than an unbounded structure
19:38:57 <monochrom> you use unsafeInterleaveIO and mutual recursion between newNode and newNodes to create an infinite tree. (each node happens to contain an IORef, but that's just an incidental field, not a pointer to another node.) if all you need is forward pointers, i.e., parent node points to children, that's all you need, you can end here.
19:39:42 <monochrom> you use mfix to set up back pointers, i.e., from child node back to parent node. that is all it does. it does not help build infinite structures at all.
19:40:20 <shachaf> Any structure with a back pointer is infinite. :-)
19:40:34 <c_wraith> > mfix [ ("a" ++), ("B" ++) ]
19:40:35 <lambdabot>   Couldn't match expected type `a -> m a'
19:40:35 <lambdabot>         against inferred type `[a1]'
19:40:36 <monochrom> that does not conflict with what I said.
19:40:55 <c_wraith> > mfix $ \x [ ("a" ++ x), ("B" ++ x) ]
19:40:56 <lambdabot>   <no location info>: Parse error in pattern
19:40:58 <monochrom> if you don't already have an infinite structure, mfix does not add one.
19:41:03 <c_wraith> > mfix $ \x -> [ ("a" ++ x), ("B" ++ x) ]
19:41:09 <lambdabot>   mueval: ExitFailure 1
19:41:09 <lambdabot>  mueval-core: Time limit exceeded
19:41:11 <c_wraith> I swear, I've used this language before
19:41:49 <monochrom> if you delete all occurences of "parent" and the code about the "width" field, you can delete the "mdo".
19:42:21 <shachaf> Isn't mdo considered deprecated nowadays?
19:42:25 <monochrom> and of course change the type sig of newNode accordingly (one fewer parameter)
19:42:27 <monochrom> yes
19:43:10 <ddarius> s/mdo/do rec/
19:44:50 <monochrom> actually in this code the node doesn't have a pointer to parent, sorry. but the code wants to know about the parent just for parent's width
19:46:08 <monochrom> oh hahaha, I swapped the "author" field and the "title" field!
19:48:32 <blast_hardcheese> This isn't a haskell question in particular, but I don't really know where to ask it; Gitit's ReStructuredText renderer doesn't seem to fully process internal links to section headers, I was wondering if anyone had a page using RST for reference before I file a bug report
19:49:20 <hpaste_> monochrom annotated “monochrom” with “monochrom (annotation) (annotation)” at http://hpaste.org/51508#a51513
19:49:54 <monochrom> just pass the widths around, and you no longer need to pass around the whole parent, and you no longer need mdo
19:50:58 <monochrom> I erred in the new type sig. oh well
19:52:13 <blast_hardcheese> An example of my issue is here: http://blast.hardchee.se/gitit/Wmii
19:53:04 <blast_hardcheese> At the bottom, you'll see lots of different link attempts, none of them are actually rendered as links, despite the fact that Xmodmap_ /should/ work
19:55:40 <blast_hardcheese> Whoops, battery's dying and I've got no plug; Sorry for asking and running
20:05:23 <eboyjr> I'm looking for a reason why someone would use a 7-tuple. Any idea?
20:05:33 <eboyjr> besides a 7-dimentional point
20:05:53 <shachaf> eboyjr: Masochism.
20:05:57 <shachaf> And/or sadism. Either works.
20:06:35 <eboyjr> What if I'm into that? How could I use a 7-tuple
20:06:39 <eboyjr> lol
20:06:57 <Cale> eboyjr: Usually if the tuples get that large, you're better off defining your own datatypes
20:07:07 <shachaf> eboyjr: Returning a bunch of values from a thing.
20:07:14 <eboyjr> Yeah i'm just curious if anyone can think of a good reason
20:07:30 <shachaf> E.g. (things, things, things, things) <- liftIO . atomically $ do ....; return (things, things, things, thigns)
20:07:43 <eboyjr> You can't use a datatype for that?
20:07:53 <shachaf> When it's for a one-time use? Seems overkill.
20:08:08 <eboyjr> Ah, I see
20:08:44 * shachaf would welcome a better way of doing that.
20:09:41 <ddarius> eboyjr: For a 7D point, you'd probably want a data type with strict fields.
20:17:18 <ash_> so… if mapM is giving you problems, how do I figure out the right "map" to use?
20:17:31 <eboyjr> brute force
20:17:49 <shachaf> ash_: You figure out what you want to do and then you take the function with the right type.
20:17:56 <shachaf> mapM is just sequence . map
20:18:11 <shachaf> sequence .: map, rather.
20:18:15 <shirt> Usage of 8-tuple: https://github.com/bitc/omegagb/blob/master/src/Joypad.hs
20:18:42 <ddarius> shirt: That should clearly be a record.
20:19:13 <shirt> ddarius: probably
20:19:16 <ddarius> Also that is lazy in a way that is likely rather bad as well as lazy in a way that probably isn't good.
20:19:28 <ddarius> It's also just wastefully written.
20:19:38 <mysticc> I have a program and I want to execute a function if user pressed ctrl+c or closes the terminal ... is there a way to do that ??
20:20:42 <BMeph> mysticc: Yes. I don't know how, but I know there is a way.
20:20:49 <shachaf> GHC has instances of Show for up to 14-tuples.
20:22:16 <napping> "A 211-tuple is too large for GHC
20:22:21 <napping> (max size is 62)"
20:23:01 <shachaf> Hmm, ghci 7 gives different error messages for "((,,) True True True) True" and "(True,True,True) True)".
20:25:11 <parcs> mysticc: see Control.Exception.catch and and Control.Exception.UserInterrupt
20:27:59 <BlankVerse> mysticc: chal class
20:34:41 * elliott reads what monochrom said about the code
20:34:53 <monochrom> whee!
20:35:14 <elliott> heh, I see
20:35:28 <elliott> does that really use the same types?
20:35:31 <elliott> I don't think you can add MemNodes
20:36:22 <monochrom> No, I erred in the type sig. Should be newNode :: BranchEnv -> WidthType -> MemNode -> Trit -> IO MemNode
20:36:40 <elliott> right
20:40:23 * hackagebot termination-combinators 0.1 - Termination combinators for forcing non-terminating algorithms to terminate  http://hackage.haskell.org/package/termination-combinators-0.1 (MaxBolingbroke)
20:41:51 <elliott> @faq Can Haskell solve the halting problem?
20:41:51 <lambdabot> The answer is: Yes! Haskell can do that.
20:41:58 <copumpkin> termination combinators, eh
20:42:14 <monochrom> the paper behind termination combinators is called "termination combinators forever" hahaha
20:42:33 <blast_hardcheese> oh wow.
20:52:55 <slack1256> is there any algorithms book that use haskell as a example lang?
21:00:06 <Eduard_Munteanu> slack1256: Purely Functional Data Structures has some Haskell code IIRC
21:00:27 <Eduard_Munteanu> @where okasaki
21:00:27 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
21:04:38 <slack1256> but data structures isn't more focused on data structures not bases en destructive update?
21:07:07 <slack1256> but you're right, okasaki look good. thanks!
21:13:15 <Davorak> GHC internal error's are something I should file a bug report correct? Something like:`ifThenElse' is not in scope during type checking, but it passed the renamer
21:19:05 <ddarius> Davorak: If you are not doing something crazy and there isn't already a bug filed.  Also, if you want to be extra nice, you can try against newer version to see if the problem hasn't already been fixed.
21:20:40 <Davorak> Useing ghc language extension, RebindableSyntax, to make fromRational convert to custom data type considered crazy?
21:22:01 <Davorak> ddarius: Using ghc language extension, RebindableSyntax, to make fromRational convert to custom data type considered crazy?
21:24:51 <parcs> when using RebindableSyntax and if-then-else you have to bind a function ifThenElse it seems
21:26:13 <parcs> there should probably be an ifThenElse in the prelude..
21:27:10 <shachaf> parcs: Oh, neat.
21:27:21 * shachaf is pleased that that can be rebound.
21:27:26 * shachaf is still not pleased with its existence.
21:28:32 <Davorak> parcs: Yeah I figured that out after binding ifThenElse to if' is when the error happened.
21:29:17 <Davorak> parcs: yeah I figured that out. After ...
21:29:23 <parcs> it sucks that you have to define ifThenElse when using RebindableSyntax even if you have no intention of rebinding it
21:29:42 <parcs> RebindableSyntax and if-then-else*
21:30:27 <copumpkin> "We give a denotational model for graphical user interface (GUI) programming using the Cartesian closed category of ultrametric spaces."
21:30:28 <copumpkin> of course!
21:32:16 <dalaing> that's just a set up for "We assume a denotational model for graphical user interface (GUI) programming using the Cartesian closed category of ultrametric spaces [1]."
21:33:22 <dalaing> well, I'd chuckle anyhow
21:38:03 <SonicvanaJr> If I have something like this https://gist.github.com/1226015 how can I see if AVal is ALoc AReg for instance via pattern matching?
21:38:14 <edwardk> copumpkin: clearly if you run out of room in your window design you can always just add another dimension.
21:39:32 <copumpkin> I like to double my dimensions when I run out
21:39:35 <copumpkin> a bit like an arraylist
21:39:41 <ddarius> copumpkin: Neel is leaning toward throwing out ultrametrics for the topos of trees.
21:46:28 <dalaing> SonicvanaJr: isAReg (ALoc (AReg _)) = True
21:46:38 <dalaing> SonicvanaJr: isAReg _ = False
21:46:48 <dalaing> ... I think
21:51:14 <SonicvanaJr> dalaing: Worked, thanks!
21:51:21 <SonicvanaJr> It's too late >.<
21:51:44 <ricky> SonicvanaJr: Oh hi :-)
22:03:34 <ddarius> copumpkin: Better to grow by 1.5.
22:06:30 <mysticc> I want to perform some cleanups before my program exits (by calling a function) ..Is there a way to ensure that this function always get called even if I press ctrl+c or any other ..
22:06:32 <edwardk> that half a dimension is somewhat hard to come by. then you have to muck around with fractals
22:06:54 <kmc> mysticc, Control.Exception.bracket
22:13:11 <dingfeng> @class synonyms
22:13:12 <lambdabot> Unknown command, try @list
22:16:17 <parcs> bracket or finally
22:19:07 <shurane> kmc: so a few days ago I asked if I could generate C code with Haskell. Another intent for that question was to see if I could use the resulting code on other platforms -- i.e. Android NDK or iOS or platforms that run C. Essentially, I wanted something like Gambit or Chicken for Scheme. Should I be looking at another compiler instead for something like that?
22:20:33 <shurane> s/Haskell/ghc
22:21:43 <shachaf> shurane: As far as I understand, GHC generates "portable" C, but it tends to be very slow.
22:24:26 <copumpkin> shachaf: no, it's not portable
22:25:07 <shachaf> copumpkin: Oh.
22:25:23 <shachaf> I thought the unregisterized variant was?
22:26:33 <kmc> unreg'd still cares about the layout of various C structs etc
22:26:36 <kmc> look at JHC
22:38:24 <shurane> kmc: yup, that's what a google search tells me
22:38:29 <wavewave> hi.
22:38:51 <wavewave> can haddock documetation have some images ?
22:39:24 <copumpkin> wavewave: no, that would make the documentation too good, and we try to avoid that around here
22:39:49 <wavewave> copumpkin: to avoid success?
22:40:03 <copumpkin> among other things, yeah
22:41:20 <wavewave> if we don't mind success, I would like to have images, graphviz support and latex support in haddock.
22:41:45 <wavewave> latex support using mathjax.
22:49:04 <copumpkin> wavewave: the usual open-source answer to that is "if you want it, implement it" :)
22:49:13 <copumpkin> I don't think haddock's been getting much love recently
22:49:29 * shachaf certainly has never given haddock any love.
22:49:38 <shachaf> As far as I'm concerned reading .hs files is usually more convenient.
22:50:23 * hackagebot http-enumerator 0.7.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.7.1 (MichaelSnoyman)
22:51:52 <hpaste_> “The least helpful GHC warning” pasted “elliott” at http://hpaste.org/51517
22:52:00 <elliott> Oops, got the fields the wrong way around.
22:52:04 <elliott> But seriously, look at that thing.
22:53:01 <shachaf> elliott: What's not helpful about that?
22:53:02 <copumpkin> lol
22:53:04 <copumpkin> bug report
22:53:24 <elliott> shachaf: Well, I suppose it /is/ precise.
22:53:29 <elliott> copumpkin: I'm on an old version, so.
22:53:33 <copumpkin> oh
22:53:45 <elliott> And, I mean, it's not /incorrect/ or anything.
22:55:24 <shachaf> elliott: If you match a Word8, and give it all 256 possibilities, it'll still complain about missing patterns. :-(
22:55:59 <elliott> shachaf: It even warns against unmatched impossible GADT patterns!
22:56:39 <elliott> (I created an insane GADT and typeclass just to eliminate unmatched pattern warnings.)
22:56:42 <elliott> (But no.)
22:57:01 <shachaf> elliott: You probably deserve that if you were doing that sort of thing.
22:57:15 <elliott> shachaf: It was _solely_ to get warnings to shut up.
22:57:27 <shachaf> -w
22:58:21 <elliott> shachaf: But I want warnings for unmatched patterns, just not in those functions :-(
22:58:31 <elliott> I ended up just redesigning the whole thing and then they went away.
23:04:26 <mysticc> what is the module for getting password from the user ... getLine shows the password?
23:05:23 <Veinor> hSetEcho stdin False; getLine; hSetEcho stdin true;
23:05:46 <Veinor> something like that
23:06:10 <mysticc> Very weird way ... I thought there would be some dedicated function to do :)
23:18:35 <mysticc> kmc : ther
23:19:20 <shachaf> mysticc: Нет.
23:27:56 <mysticc> Any body knows why finally is working when I press ctrl+c but not when I send a sigterm signal from outside to the program ??
23:32:15 <kalven> ctrl+c sends sigint
23:36:43 <c_wraith> still, sigterm should result in an async exception that finally handles, too.  Unless signal handlers are being messed with.
23:37:16 <c_wraith> are you using the ghc api, directly or not?  It's one of the more egregious things, in terms of messing with signal handlers unnecessarily
23:37:42 <mysticc> I am just using finally from Control.Exception ...
23:38:22 <mysticc> c_wraith: I dont know why it is not handling the case when I am sending sigterm from outside
23:39:34 <mysticc> Do I need to catch all exceptions and do something ??
23:48:56 <ddarius> Java's syntax for invoking generic methods is unbelievable.
23:49:24 * hackagebot NestedSampling 0.1.1 - A port of John Skilling's nested sampling C code to Haskell.  http://hackage.haskell.org/package/NestedSampling-0.1.1 (IssacTrotts)
23:50:00 <Botje> you mean via reflection?
23:52:54 <tdammers> anyone have any experience with using libcairo with haskell?
23:53:58 <ddarius> Botje: No.
23:56:59 <edwardk> i'm thinking i can add packrat parsing to trifecta in a rather straighforward way.
23:59:25 * hackagebot NestedSampling 0.1.2 - A port of John Skilling's nested sampling C code to Haskell.  http://hackage.haskell.org/package/NestedSampling-0.1.2 (IssacTrotts)
