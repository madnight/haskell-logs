00:00:46 <TNA-MichaelK> How would I look for a Function of a certain type?
00:01:02 <ivanm> @where hoogle
00:01:03 <lambdabot> http://haskell.org/hoogle
00:01:04 <ivanm> @where hayoo
00:01:05 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
00:01:16 <ivanm> hoogle is more accurate but only searches the haskell platform libraries by default
00:01:20 <ivanm> hayoo searches all of hackage
00:01:44 <Axman6> @hoogle a -> b -> a
00:01:45 <lambdabot> Prelude const :: a -> b -> a
00:01:45 <lambdabot> Data.Function const :: a -> b -> a
00:01:45 <lambdabot> Prelude seq :: a -> b -> b
00:01:51 <kmc> hoogle is more accurate, that's why it suggests unsafeCoerce for every function
00:01:55 <kmc> because unsafeCoerce is the best function
00:02:08 <shachaf> kmc: Not as good as undefined!
00:03:12 <Axman6> @hoogle a -> b
00:03:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:03:13 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:03:13 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
00:03:23 <luqui> shachaf, undefined is not (necessarily) a function
00:03:32 <shachaf> luqui: Right, that's why it's better.
00:03:37 <luqui> mm
00:03:49 <shachaf> unsafeCoerce needs an argument in order to be of any use.
00:03:51 <Axman6> undefined is ALL THE THINGS!
00:03:57 <shachaf> What if you don't have any inhabited types?
00:04:02 <TNA-MichaelK> @hoogle a -> Bool
00:04:02 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
00:04:02 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
00:04:02 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
00:04:03 <shachaf> Well, there's always unsafeCoerce unsafeCoerce.
00:04:08 <shachaf> @ty unsafeCoerce unsafeCoerce
00:04:09 <lambdabot> Not in scope: `unsafeCoerce'
00:04:09 <lambdabot> Not in scope: `unsafeCoerce'
00:04:13 <wavewave> @hoogle Int -> String
00:04:13 * shachaf sighs.
00:04:13 <lambdabot> Prelude show :: Show a => a -> String
00:04:13 <lambdabot> Text.Show show :: Show a => a -> String
00:04:13 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
00:04:29 <shachaf> @ty unsafeCoerce unsafeCoerce
00:04:30 <lambdabot> forall b. b
00:04:44 <wavewave> @hoogle String -> Int
00:04:44 <lambdabot> Test.HUnit.Base Label :: String -> Node
00:04:45 <lambdabot> Prelude read :: Read a => String -> a
00:04:45 <lambdabot> Text.Read read :: Read a => String -> a
00:05:15 <wavewave> Hmm why does it show Node?
00:05:24 <kmc> there's a lot of values of type a -> Bool
00:05:28 <Axman6> TNA-MichaelK: what are you looking for? we're usually even better than hoogle for basic questions =)
00:05:38 <wavewave> human hoogle
00:05:43 <Axman6> aren't there only like 6 kmc?
00:06:11 <kmc> undefined, const undefined, const True, const False, \x -> x `seq` True, \x -> x `seq` False
00:06:15 <kmc> that's 6 yeah
00:06:15 <Axman6> (6 is a guess)
00:06:24 * Axman6 wins!
00:06:25 <kmc> operationally there are many more
00:06:26 <Axman6> heh
00:06:30 <luqui> wavewave, I think type Node = Int
00:06:42 <kmc> perhaps «\x -> x `seq` undefined» is an interesting one
00:06:49 <ivanm> yeah, in fgl "type Node = Int"
00:06:53 <TNA-MichaelK> Axman6: kmc: lol, thanks
00:06:58 <shachaf> kmc: Operationally, you mean?
00:07:04 <Axman6> TNA-MichaelK: what are you actually after?
00:07:09 <kmc> 's what i said? /me confused
00:07:13 <TNA-MichaelK> I'm looking to count the number of Trues in a list
00:07:21 <wavewave> Hmm. in HUnit, it's not.
00:07:39 <kmc> :t length . filter id
00:07:40 <lambdabot> [Bool] -> Int
00:07:45 <shachaf> Ah, never mind.
00:07:48 <ddarius> Why do you have a list of booleans?
00:07:49 <kmc> :t \f -> length . filter f
00:07:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
00:07:55 <wavewave> anyway.
00:08:14 <TNA-MichaelK> ddarius I'm counting primes
00:09:45 <ivanm> TNA-MichaelK: so why do you have a list of Bool though?
00:09:53 <ivanm> if you want the number of primes, do: length . filter isPrime
00:10:04 <ivanm> (or whatever your Int -> Bool function is to check for primality)
00:10:22 <TNA-MichaelK> kmc: I'm not sure how to implement ":t length . filter id" for a given list and id, I assume id=True here
00:10:44 <TNA-MichaelK> isPrime is an actual function?
00:10:50 <ivanm> no
00:10:56 <ivanm> and you don't need to implement it
00:11:04 <ivanm> > length . filter even [1..10]
00:11:04 <lambdabot>   No instance for (GHC.Real.Integral [a])
00:11:05 <lambdabot>    arising from a use of `GHC.Real....
00:11:11 <ivanm> :o
00:11:19 <ivanm> oh, right
00:11:22 <ivanm> > length . filter even $ [1..10]
00:11:24 <lambdabot>   5
00:11:33 <ddarius> TNA-MichaelK: id is a function.
00:11:33 <ivanm> ^^ number of even numbers between 1 and 10 inclusive
00:11:34 <ddarius> :t id
00:11:35 <lambdabot> forall a. a -> a
00:12:51 <TNA-MichaelK> ddarius: thank you, I figured it was a dummy variable
00:13:16 <TNA-MichaelK> ivanm, thanks for the filtering of even...
00:13:53 <earthy> um, TNA-MichaelK, be sure that id is *not* a dummy
00:14:02 <earthy> it is the very useful and important 'do nothing'function
00:14:24 <ivanm> earthy: it doesn't do _nothing_!
00:14:33 <ivanm> I would say the do nothing function is more like "const ()"
00:14:35 <earthy> or rather do nothing special :)
00:14:41 <TNA-MichaelK> hmm, well, after I complete this puzzle you guys can bash my solution ; )
00:14:52 <Axman6> earthy: i think id's argument would be quite offended :P
00:14:59 <Axman6> TNA-MichaelK: will do :P
00:15:38 <TNA-MichaelK> length . filter True [True,Flase], was what I figured should work based off of ivanm's even filtering...
00:15:39 <earthy> const () actually does more than id...
00:15:51 <ivanm> TNA-MichaelK: no
00:15:56 <ivanm> first of all, the type is wrong
00:16:07 <earthy> the first argument to filter should be a function
00:16:12 <ivanm> earthy: well, it's lazier: it ignores the provided value!
00:16:23 <kmc> all Haskell functions are "do nothing" functions ;)
00:16:23 <ivanm> TNA-MichaelK: note the type of filter
00:16:27 <ivanm> @type filter
00:16:27 <earthy> ivanm: *and* returns a different type, unless the provide value is ()
00:16:28 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:16:36 <ivanm> earthy: find: "const undefined"
00:16:52 * earthy grins
00:16:56 <ivanm> TNA-MichaelK: so you want a function that takes a Bool (as you have a list of Bools) and returns a Bool
00:17:01 <ivanm> @hoogle Bool -> Bool
00:17:01 <lambdabot> Prelude not :: Bool -> Bool
00:17:01 <lambdabot> Data.Bool not :: Bool -> Bool
00:17:01 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
00:17:02 <earthy> that's even more effectful than id! :)
00:17:17 <ivanm> so, you could use not, but it does the opposite of what you want
00:17:23 <ivanm> consider the id function:
00:17:24 <ivanm> @type id
00:17:25 <lambdabot> forall a. a -> a
00:17:25 <ivanm> @src id
00:17:26 <lambdabot> id x = x
00:17:33 <ivanm> it just takes the provided value and returns it
00:17:35 <TNA-MichaelK> Thanks for clarifying
00:17:38 <ivanm> which in this case is what we want
00:17:48 <ivanm> TNA-MichaelK: so, filter keeps all values for which the provided predicate returns True
00:17:57 <ivanm> since we want True to return True, we use id
00:18:05 <ivanm> > length . filter id $ [True, False, True]
00:18:07 <lambdabot>   2
00:18:16 <wavewave> @hoogle IVar
00:18:16 <lambdabot> Network.CGI.Monad cgiVars :: CGIRequest -> Map String String
00:18:16 <lambdabot> Network.CGI.Protocol cgiVars :: CGIRequest -> Map String String
00:18:16 <lambdabot> Network.CGI.Protocol getCGIVars :: MonadIO m => m [(String, String)]
00:18:46 <TNA-MichaelK> oh, wow, that's how to implement what kmc was saying
00:19:03 <mm_freak_> wavewave: IVar is also used in monad-par (Control.Monad.Par)
00:19:33 <TNA-MichaelK> hah, nice! There are 168 primes in 1..1000
00:19:39 <wavewave> mm_freak_ : yeah, that's actually I am searching.
00:19:52 <TNA-MichaelK> and 1229 in 1..1000
00:19:55 <TNA-MichaelK> 0
00:20:55 <wavewave> congrat!
00:21:31 <wavewave> you cannot go back to the world with lower-order functions.
00:21:35 <ddarius> > length(nubBy((>1).:gcd)[2..1000])
00:21:37 <lambdabot>   168
00:21:51 <TNA-MichaelK> wavewave: true story
00:22:05 <TNA-MichaelK> ddarius: thanks for rocking my world
00:22:22 <ddarius> > nubBy((>1).:gcd)[2..]
00:22:25 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:22:25 <TNA-MichaelK> let prime x = (all (>0) (map snd (map (divMod x) [2..x-1]))) in length . filter id $ (map prime [2..1000])
00:22:45 <TNA-MichaelK> > let prime x = (all (>0) (map snd (map (divMod x) [2..x-1]))) in length . filter id $ (map prime [2..1000])
00:22:46 <lambdabot>   168
00:23:58 <Axman6> TNA-MichaelK: why use divMod  and snd when you can use mod?
00:24:04 <Axman6> > 7 `mod` 4
00:24:06 <lambdabot>   3
00:24:23 <ivanm> and I'd be tempted to use not . any (==0)
00:24:25 <kmc> TNA-MichaelK, also (map f (map g xs)) is (map (f . g) xs)
00:24:28 <kmc> which is easier to read
00:24:31 <ivanm> seems clearer about what it does IMHO
00:24:34 <ivanm> though means the same thing
00:25:13 <TNA-MichaelK> kmc: thanks for clarifying
00:25:43 <TNA-MichaelK> Axman6: Because I don't know many functions yet, that's why divMod, it's how I thought of the problem.
00:26:04 <wavewave> \me loves point-free style
00:26:11 <Axman6> no worries :) it takes time to learn what's on offer, and even longer to figure out how to fit it all together
00:26:49 <Kaidelong> any (/=0)
00:26:51 <TNA-MichaelK> > let prime x = (all (>0) (map (snd . (divMod x)) [2..x-1]))) in length . filter id $ (map prime [2..1000])
00:26:52 <lambdabot>   <no location info>: parse error on input `)'
00:26:57 <Kaidelong> err
00:27:00 <Kaidelong> all (/=0)
00:27:02 <Kaidelong> I mean
00:27:09 <Kaidelong> look at me forgetting my predicate logic
00:27:18 <TNA-MichaelK> kmc: I tried your simpler method of writing it
00:28:17 <wavewave> Hmm current hackage script is pretty simple..
00:28:27 <wavewave> quite surprising to me.
00:28:49 <TNA-MichaelK> kmc: never mind, I got it, thanks
00:29:04 <kmc> :)
00:29:13 <Axman6> > let primes = 2 : filter isPrime [3,5..]; isPrime x = all (/= 0) . map (mod x) . takeWhile (\n -> n*n <= x) $ primes in primes
00:29:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:30:02 <TNA-MichaelK> see this is why I should have refrained until I finished, may as well try to figure out how these work now though
00:30:11 <kmc> i like that Axman6
00:30:30 <shachaf> > nubBy(((>1).).gcd)[2..]
00:30:30 <kmc> mutual recursion between a function and a list
00:30:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
00:30:34 <wavewave> that's more efficient.
00:30:41 <shachaf> Oh.
00:30:47 <kmc> so clear from the code how it works, yet so unexpected that it works
00:30:52 * shachaf is late once again.
00:31:13 <TNA-MichaelK> which one is more efficient?
00:31:19 <TNA-MichaelK> I like shachaf's method
00:31:20 <kmc> Axman6's i expect
00:31:29 <shachaf> TNA-MichaelK: ddarius said it first.
00:31:29 <mm_freak_> kmc: it works because of the (2:)
00:31:31 * hackagebot cryptohash 0.7.3 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.3 (VincentHanquez)
00:31:33 <kmc> yep
00:31:37 <shachaf> And many people before him (I assume).
00:31:38 <TNA-MichaelK> yeah, a while bach
00:31:50 <kmc> shachaf's relies on implementation details of nubBy
00:31:54 <TNA-MichaelK> a while back
00:31:58 <mm_freak_> kmc: and it totally needs that takeWhile to take only up to the square root
00:32:00 <wavewave> Axman6 solution
00:32:01 <kmc> yes
00:32:02 <TNA-MichaelK> huh, was thinking that might be autocorrect
00:32:09 <mm_freak_> otherwise the recursion will diverge
00:32:10 <shachaf> kmc: Yes, it's kind of disgusting.
00:32:41 <ivanm> use the wheel implementation from that paper!
00:33:23 <TNA-MichaelK> let primes = 2 : filter isPrime [3,5..]; isPrime x = all (/= 0) . map (mod x) . takeWhile (\n -> n*n <= x) $ primes in primes..............  ok don't you need to do something like "let name x = x*blah in ...." ?
00:34:00 <ddarius> Beginner's and their imagined arbitrary limitations.
00:34:25 <TNA-MichaelK> ddarius, I'm accustomed to C, can you really blame me?
00:34:43 <ddarius> Yes.
00:34:52 <TNA-MichaelK> What's the shortest use of isPrime you can think of?
00:35:02 <ivanm> "isPrime 0"
00:35:10 <TNA-MichaelK> >isPrime 0
00:35:11 <ivanm> ^^ shortest realistic use of the isPrime function
00:35:11 <ivanm> :p
00:36:06 <TNA-MichaelK> ah, haha
00:37:57 * wavewave wonders if haskell compilation in haskell can be equally efficient as original. 
00:38:06 <ivanm> wavewave: huh?
00:38:22 <wavewave> I am thinking of partial evaluation
00:38:33 <ivanm> I'm trying to work out what exactly you mean by that statement
00:38:47 <ivanm> since it doesn't really make any sense
00:39:33 <wavewave> It's a bad sentence. even I cannot understand what I am saying. ;-P
00:39:48 <mm_freak_> the shortest use of isPrime is "isPrime" ;)
00:39:58 <mm_freak_> and it has type Integral a => a -> Bool ;)
00:39:59 <ivanm> mm_freak_: well, you're not actually using it there, are you?
00:40:02 <ivanm> just listing it
00:40:07 <mm_freak_> ivanm: sure you are
00:40:16 <mm_freak_> application is an operation…  you are using application, not isPrime =P
00:40:21 <ivanm> heh
00:40:35 <TNA-MichaelK> would anyone mind helping me breakdown Axman6's prime counting?
00:40:40 <wavewave> Just consider a language described by haskell datatype and compile inside haskell.
00:41:04 <ivanm> wavewave: still not making much sense
00:41:08 <wavewave> compile  Lambda term to \x -> blah blah
00:41:13 <ivanm> are you wanting some kind of run-time evaluated DSL?
00:41:18 <wavewave> yes.
00:41:41 <ivanm> OK, that's a different story
00:41:47 <ivanm> isn't that what bluespec, etc. does?
00:42:02 <wavewave> I haven't heard of bluespec.
00:42:27 <wavewave> oh. i see.
00:42:30 <wavewave> I heard of it.
00:42:43 <wavewave> anyway..
00:43:25 <wavewave> Lambda "x" ( App (Func "+") (Var "x") (Value 3))
00:43:31 <wavewave> or something like that..
00:43:43 <wavewave> now I want to compile it to \x->(x+3)
00:44:09 <wavewave> not using ghc again..
00:44:53 <wavewave> i.e I wouldn't accept that compile the data into a string source file and run ghc or use ghc api .... that's not my solution.
00:46:18 <ivanm> right, so you evaluate it and run it
00:46:29 <ivanm> @google haskell scheme 24
00:46:31 <wavewave> because lambda, the resultant code is not efficient as native haskell.
00:46:33 <lambdabot> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
00:46:38 <ivanm> wavewave: ^^
00:46:48 <kmc> there are really too many packages on hackage
00:46:58 <kmc> we need a better way to search them
00:47:02 <kmc> (not like i'm helping)
00:47:36 <wavewave> but if we can use a fixed number of combinators, it can be efficient.
00:47:47 <ivanm> huh?
00:47:54 <ivanm> you're really not making much sense wavewave
00:47:54 <wavewave> I am considering S,K combinators.
00:48:05 <ddarius> That won't be efficient.
00:48:14 <ivanm> there are various implementations/translators for the lambda calculus in haskell already
00:48:18 <ivanm> it's a common assignment project
00:48:27 <ddarius> wavewave: If you are interested in compiling to combinators, you should look at David Turner's early work doing that.
00:48:47 <wavewave> ddarius: I know that it's inefficient at all..
00:49:14 <wavewave> ddarius: we need to have supercombinator .
00:49:42 <wavewave> ivanm: would you remind me of some useful packages?
00:49:55 <ivanm> wavewave: depends upon what you want to do
00:49:56 <ddarius> That's not the problem, though supercombinators are a potential route for optimization.
00:51:06 <wavewave> ivanm: I want to make a kind of supercompilation (?) program
00:51:18 <ivanm> no idea
00:51:24 <wavewave> hmm. again it does not make any sense. kk
00:51:26 <ivanm> but I would question why you'd want to do that
00:51:35 <ivanm> I think I understand what you want
00:51:50 <ivanm> but you're better off IIUC writing a new language with a full-blown compiler, etc.
00:51:52 <wavewave> I just want to experiment some different evaluation scheme.
00:51:58 <ivanm> _then_ making it a supercompilation one
00:52:04 <ivanm> wavewave: which language though?
00:52:27 <wavewave> let us confine ourselves to simple lambda calculus.
00:52:54 <ivanm> so, you want to write a lambda calculus compiler?
00:53:10 <wavewave> I want to try to make a fully-lazily evaluated lambda language.
00:53:22 <ivanm> why not start with that "Write yourself a scheme in 48 hours" tutorial I linked to above?
00:54:32 <weltensegler> Hello, sorry for interrupting. How do i write a function <code>myfun :: [a] -> a</code> that gives me an element of type a that is not in the list?
00:54:55 <ivanm> weltensegler: in general, you can't
00:55:02 <ivanm> you have to narrow down what a is
00:55:11 <ivanm> even then, you need to define your semantics
00:55:28 <wavewave> that seems to me more focused on parsing.
00:55:29 <ivanm> say you have it for Int: given [1..10], what should it return?
00:55:30 <weltensegler> ivan`, yes of course, i meant what is the most general way you can think of.
00:55:43 <ivanm> weltensegler: there _is_ no general way
00:55:57 <ivanm> though bird's latest book had a nice implementation on picking the shortest Int not in a list
00:56:00 <ivanm> *smallest
00:56:19 <wavewave> let us assume that parsing is already done.. Now I have AST as data structure.
00:56:46 <weltensegler> ivan`, i'm not looking for a general way, but for a way that allows for a big class of types.
00:57:00 <wavewave> Now evaluation is the problem.
00:57:03 <ivanm> there isn't one in general
00:57:07 <ivanm> and I'm ivanm, not ivan` :p
00:57:23 <ivanm> weltensegler: you can kinda do it with Bounded and Enum I suppose...
00:57:35 <weltensegler> ivanm, sorry XChat expands to ivan` automagically.
00:57:38 <ivanm> @type ([minBound..]\\)
00:57:39 <lambdabot> forall a. (Bounded a, Enum a, Eq a) => [a] -> [a]
00:57:58 <ivanm> weltensegler: that's weird, when I used xchat it expanded to the most recently used nick, not the alphabetically first one
00:58:00 <ivanm> must be an option
00:58:09 <ivanm> anyway, that's probably the most general one I can think of ^^
00:58:19 <ivanm> oh, wait, not quite
00:58:26 <ivanm> @type head . ([minBound..]\\)
00:58:27 <lambdabot> forall a. (Bounded a, Enum a, Eq a) => [a] -> a
00:58:33 <ivanm> but that's a horrible implementation
00:59:11 <ddarius> ivanm: It is an option.
00:59:25 <ddarius> (And not the default.)
00:59:27 <ivanm> ahhh
00:59:42 <ivanm> I must have changed it then
00:59:48 <ivanm> I like tweaking options ;)
01:00:43 <ivanm> weltensegler: though do I dare ask _why_ you want to do this?
01:01:54 <kmc> is it possible to do bold text in Haddock?
01:01:54 <weltensegler> i have a constraint network in a specific relation algebra and reduce that network to a simpler algebra. But for that, i have to introduce some helper nodes.
01:02:05 <ivanm> no
01:02:19 <ivanm> well, I suppose you can if you tweak the CSS after it generates it so that emph does bold instead of italics...
01:02:19 <kmc> i will use all caps instead :)
01:02:21 <ivanm> but in general, no
01:02:27 <ivanm> just /emph/
01:02:32 <ivanm> and @monospace@
01:02:33 <weltensegler> ivan, or was that to specific?
01:02:47 <ivanm> weltensegler: possibly a bit :)
01:04:20 <wavewave> again... my question was  compile AST into haskell function in run time and run it in the same run time. Can we reach the equal efficiency as native haskell function?
01:05:22 <ivanm> wavewave: I doubt it in general
01:05:31 <ivanm> but I wonder why you want to do that
01:05:50 <ivanm> wavewave: note that unless you basically implement a JIT interpreter, you won't have any optimisations, etc.
01:06:09 <ivanm> so no, it won't be as good as a compiled version
01:06:25 <wavewave> ivanm: this is just a curiosity. ;-)  .. optimization is of course another issue.
01:06:40 <ivanm> well, you said equal efficiency: that implies optimisations
01:07:17 <wavewave> let me compare the result with ghc without any optimization. :-)
01:08:05 <ivanm> it's still compiled vs interpreted
01:08:35 <wavewave> ivanm: yes. that compilation and interpretation difference..
01:08:59 <wavewave> If we have a fixed combinator.. interpretation becomes compilation.
01:09:09 <ivanm> now, if you're actually asking "is Haskell a good language to write a compiler/interpreter in", then the answer is yes
01:09:25 <ivanm> I'm not sure what a "fixed combinator" is, but I can't see how interpretation == compilation
01:09:35 <ivanm> the latter implies creating some kind of stand-alone binary execution file
01:09:44 <weltensegler> I also thought of restricting the problem to the Enum class, but i have the problem, that i want to allow the type a to be of String.
01:09:48 <ivanm> the former implies that you read the file in and run it within some other program
01:09:57 <shachaf> ivanm: Compilation is just an optimization on interpretation. :-)
01:09:58 <ivanm> possibly with some form of byte-compilation
01:10:32 <luqui> it depends on how you define compilation
01:10:36 <wavewave> ivanm: If the runtime does not need 'lookup' function for a name, that's compiled.
01:10:46 <ivanm> shachaf: sure, but how can interpretation magically become compilation whilst running it?
01:10:58 <luqui> if you are thinking in terms of machine code, binary files, etc., then futamura doesn't talk about that
01:11:06 <ivanm> weltensegler: well, you need to have some notion of "what are possible values"
01:11:07 <shachaf> @google just-in-time compilation
01:11:08 <lambdabot> http://en.wikipedia.org/wiki/Just-in-time_compilation
01:11:08 <lambdabot> Title: Just-in-time compilation - Wikipedia, the free encyclopedia
01:11:10 <wavewave> interpretation is basically 'need for name lookup'
01:11:28 <ivanm> weltensegler: how do you determine what a valid String is?
01:12:03 <weltensegler> ivan, i don't. Any String i allowed.
01:12:17 <wavewave> luqui: that's very relevant. Thanks for noting that.
01:12:19 <ivanm> weltensegler: OK, let me re-phrase that: how do you come up with a possible String?
01:12:22 <ivanm> @instances Enum
01:12:23 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
01:13:20 <wavewave> SK compilation is a compilation in that sense to me.
01:13:39 <wavewave> but of course it's very inefficient.
01:13:46 <ivanm> what is "SK compilation" though?
01:13:58 <ivanm> google results seem to be about music compilation albums or something :/
01:14:16 <wavewave> every lambda function can be written as point free style.
01:14:26 <ivanm> ... so?
01:14:29 <wavewave> in terms of S,K,I... combinators.
01:14:41 <ivanm> every function can be written point-free, that's what the @pl plugin does
01:14:49 <weltensegler> Oh. Of course one could enumerate them if i only allowed for ascii symbols. While i don't know if that is trivial in Haskell i was hoping for a solution that doesn't restrict the type a to Enum.
01:15:08 <ivanm> weltensegler: you need to have some kind of restriction of "how to generate"
01:15:13 <wavewave> ivanm: that means no variable at all.
01:15:19 <ivanm> so, if you create some other class of "Generatable", you could use that
01:15:28 <ivanm> wavewave: yes, I know what pointfree means
01:15:32 <wavewave> ivanm: it is very nontrivial in fact.
01:15:33 <erus`> anyone got any ideas for a haskell themed protest ?
01:15:49 <ivanm> erus`: are you protesting for or against haskell?
01:15:54 <wavewave> \x -> ( \y -> x+ (\z -> y + x^2 +z )))
01:15:57 <ivanm> wavewave: I fail to see the relevance
01:16:02 <erus`> maybe a sit-in infront of w3 for failing to include haskell as a standard client side scripting language?
01:16:11 <ivanm> erus`: why would they?
01:16:14 <wavewave> write the above function without x, y, z
01:16:29 <ivanm> @pl \x -> ( \y -> x+ (\z -> y + x^2 +z )))
01:16:29 <lambdabot> (line 1, column 38):
01:16:29 <lambdabot> unexpected ")"
01:16:29 <lambdabot> expecting variable, "(", operator or end of input
01:16:32 <ivanm> bah
01:16:34 <erus`> because the community demand it
01:16:39 <wavewave> sorry ;-P
01:16:40 <ivanm> @pl \x -> ( \y -> x+ (\z -> y + x^2 +z ))
01:16:41 <lambdabot> liftM2 (.) (+) (((+) .) . (+) . (^ 2))
01:16:49 <ivanm> ^^ done
01:16:50 <ivanm> so what?
01:17:07 <wavewave> good! that's it..
01:17:37 <wavewave> although you need to have liftM2 liftM3 ....
01:17:52 <wavewave> liftMx is called super combinator.
01:18:32 <luqui> wavewave, haha, twas a context-free guess :-)
01:18:46 <ivanm> ... and?
01:19:27 <ivanm> I'm still not getting why you would want to try and work out how to interpret lambda calculus at run-time in such a way that it's comparable to having the said functions implemented in the program already and compiled
01:19:59 <luqui> because if those functions were generated dynamically by some combination of logic
01:20:05 <luqui> perhaps depending on runtime values
01:20:29 <luqui> then you could get the speed of compiled code without having to "see" the whole structure of the code at compile time
01:21:10 <ivanm> luqui: OK, but why only lambda calculus? and what does it have to do with being point-free?
01:21:11 <luqui> eg.  enter an exponent, and i will compute [1..10,000] raised to that exponent
01:21:14 <wavewave> luqui: yes. you can explain much better than me about what I am thinking.
01:21:41 <luqui> maybe this is a group conversation
01:22:12 <luqui> and i love this shit.  worked a long time on lazy specialization.
01:22:15 <wavewave> I am in fact rather confused in what I am thinking.
01:22:18 <luqui> oh
01:22:32 <wavewave> anyway.. would you proceed?
01:22:59 <luqui> combinators have some rather nice properties
01:23:03 <wavewave> I love to hear about that lazy specialization.
01:23:47 <wavewave> I will explain later in what context I came to this thought.
01:23:51 <luqui> eg. if you compile a function down to.. hmm, let's say SK for simplicity
01:24:09 <luqui> call it f
01:24:15 <luqui> let g = f K
01:24:23 <luqui> then evaluate g 1 and g 2
01:24:45 <luqui> g = S K K which can be reduced to I, and then g is simpler
01:24:49 <luqui> but that was a bad example
01:24:52 <luqui> because it's false :-)
01:25:16 <luqui> ok need a good example
01:26:29 <luqui> S (K a) b c = K a c (b c) = a (b c)
01:26:29 <ivanm> to summarise: is the stated purpose that somehow you could work out that you don't need any kind of whole-program optimisations to get performant code?
01:26:49 <luqui> oh going all useful on us huh?
01:27:00 <luqui> sortof
01:27:01 <ivanm> heh
01:27:14 * Axman6 recently wrote an assignment for parsing lambda calculus, and converting it to SK calculus
01:27:15 <ivanm> OK, I've heard a rationale now
01:27:18 * ivanm -> eat dinner
01:27:21 <Axman6> and back again :o
01:27:37 <luqui> the thing that specialization (combinator reduction is kind of half-specialization) does is it lets you abstract as much as you want without losing any optimizations
01:27:48 <luqui> at a certain point compilers can't see past your abstractions anymore
01:30:17 <wavewave> so that's a limitation in SK compilation, you mean?
01:31:02 <luqui> well, it's a limitation of all performant modern compilers
01:31:06 <luqui> including SK compilation
01:31:39 <luqui> but combinator compilation maintains a *little* bit of these specialization properties
01:32:02 <luqui> supercombinator compilation, as I believe GHC does, (inventing appropriate combinators at compile time), does better than SK
01:32:26 <wavewave> yes.. basically by treating multiple argument lambda at once.
01:33:46 <luqui> but yeah, my mind is foggy, need to get back into this :-)
01:33:47 <wavewave> seems to me that difference comes from treating argument list as list or array
01:34:15 <luqui> i never gave enough attention to supercombinator compilation
01:34:21 <luqui> so i don't really know what it's all about
01:34:50 <wavewave> I mean SK compilation has basically O(n) complexity in getting nth argument but supercombinator treat argument array  as a whole
01:35:12 <wavewave> that's my intuition..but not sure...
01:35:12 <luqui> oh that's an interesting way of seeing it
01:35:23 <luqui> yeah that makes some sense to me
01:35:46 <luqui> also you don't need exponential space to encode the argument "getting" operations
01:35:49 <luqui> which is a plus :-)
01:35:57 <wavewave> luqui: good. actually I had this intuition two days ago. first say to somebody. ;)
01:36:59 <wavewave> anyway.. I was thinking of what would be the merit of more lazy evaluation scheme for some time.
01:37:06 <wavewave> lazier
01:37:25 <luqui> oh yeah it has amazing potential
01:37:28 <wavewave> lazy evaluation makes function composition more useful.
01:37:43 <wavewave> then what's benefit from fully laziness.
01:37:51 <wavewave> I found that this is very useful.
01:37:58 <luqui> making function composition *even more* useful
01:38:06 <wavewave> yes, it is!
01:38:30 <wavewave> you can define very very very small pieces of codes as separate functions.
01:38:49 <wavewave> normally that is not efficient
01:38:53 <luqui> Let Nat be the peano naturals: Nat = Zero | Succ Nat
01:39:08 <luqui> then the type Nat -> a  is not only semantically but *operationally* equivalent to Stream a
01:39:25 <luqui> the function induces an appropriate data structure, with garbage collection and all
01:39:42 <wavewave> because in complex function, such small functions are called duplicatedly.
01:40:30 <wavewave> but by fully lazy evaluation, you can lambda-lift all shared expression at once..
01:41:06 <wavewave> I haven't thought of that Nat example.
01:41:23 <luqui> comes from this post http://lukepalmer.wordpress.com/2009/07/07/emphasizing-specialization/
01:41:32 <luqui> first discovery of lazy specialization and i am super excited
01:42:05 <luqui> the lambda lifting is not really the advantage in my eyes
01:42:10 <luqui> evaluating under a lambda
01:42:19 <TNA-MichaelK> let e = exp 1
01:42:20 <luqui> essentially "optimizing" a function with some partial evaluation
01:42:27 <TNA-MichaelK> oops, sorry, thought I was in terminal
01:42:41 <luqui> er partial information
01:42:50 <luqui> that's where the power comes from
01:42:54 <wavewave> oh.. that looks great article.
01:43:21 <wavewave> anyway... I actually started from very practical situation..
01:43:33 <wavewave> some matrix operation..
01:44:17 <wavewave> I need to define something X which is X1 . X2 and X1 = Y1 . Y2 and X2 = Z1 . Z2.... and so on..
01:44:39 <wavewave> and inside Y1, Y2, Z1, Z2... lots of duplicated operations..
01:45:09 <wavewave> to reduce those operations.. I had to keep some global states.
01:45:37 <wavewave> actually that's why all gsl functions has 'workspace' global state for all complex operations.
01:45:58 <luqui> yeah, sounds not composable
01:46:16 <luqui> though if you know these are matrix operations
01:46:24 <wavewave> but as a meaning.. just simply define X1 = Y1 . Y2 and X2 = Z1 . Z2 should be right.
01:47:01 <wavewave> anyway.. that's a starting point of what I am thinking.
01:47:05 <luqui> sure
01:47:15 <luqui> you might be able to get that in Haskell
01:47:19 <luqui> by making matrix operations a category
01:47:30 <luqui> that you can do some post-processing on before turning it into a "real" function
01:47:59 <wavewave> now... i am wondering if we can have some "small" language inside haskell with different semantics.
01:48:04 <luqui> yes
01:48:07 <luqui> EDSL
01:48:17 <luqui> Haskell is ... basically the best language for that
01:48:31 <gdijkstra> Different semantics?
01:48:31 <wavewave> so I came to the question of this partial evaluation efficiency.
01:48:52 <luqui> (i interpreted the phrase loosely)
01:49:07 <wavewave> for me, "fully lazy semantics" , but of course you can think of any.
01:49:15 <kmc> it's not the best
01:49:22 <luqui> oh you mean operational semantics
01:49:51 <wavewave> kmc: I understand it.. that's why we need 'small' language.
01:49:53 <kmc> at least, it's not the most flexible EDSL host
01:49:57 <kmc> "best" is a tough call
01:50:09 <luqui> kmc, and i am super super biased
01:50:12 <wavewave> kmc: ah.. you're talking about EDSL.
01:50:22 <kmc> surely you're not saying #haskell is biased toward Haskell ;)
01:50:37 <luqui> no
01:50:46 <luqui> i think all other channels are unfairly biased against Haskell
01:51:03 <luqui> we're the only ones who are right
01:51:11 <luqui> it is the only explanation
01:51:14 <wavewave> since we look like elitists.
01:51:37 <wavewave> although we are just enthuastic.
01:52:23 <wavewave> enthusiasm accompanies hatred. understandable.
01:52:35 <wavewave> anyway..
01:55:25 <wavewave> evaluation and composability are always interesting to me.
01:56:15 <wavewave> this kind of free thinking about evaluation became only possible since we live in pure world.
01:57:09 <luqui> eh, you could implement a specializer for an imperative language
01:57:15 <luqui> which would isolate the pure parts
01:57:24 <luqui> it would just be a lot more complicated
02:00:04 <erus`> can functions that return a value in a monad be lazy?
02:00:22 <shachaf> What's "a value in a monad"?
02:00:32 <erus`> like an IO a
02:00:38 <erus`> but not an IO in this case
02:00:39 <shachaf> Or Maybe a?
02:01:00 <shachaf> I don't see what what a function returns has to do with whether it's strict or not (assuming that's what you meant).
02:02:03 <kmc> :t const (Just undefined)
02:02:05 <lambdabot> forall a b. b -> Maybe a
02:02:12 <Kaidelong> erus`: what you are probably wondering about would be what happens when you run the result through >>=, and that depends on the monad
02:02:19 <erus`> yeah
02:02:23 <erus`> when i bind
02:02:25 <jacobian> Luke Palmer's omega-monad allows you to compose infinite streams.
02:02:27 <erus`> can that be lazy?
02:02:30 <Kaidelong> yes
02:02:34 <Kaidelong> it also can not be lazy
02:02:39 <Kaidelong> it depends on the implementation of >>=
02:02:39 <shachaf> Everything can be lazy.
02:02:45 <shachaf> What does this have to do with monads?
02:02:57 <jacobian> shachaf: I think that's his question
02:03:01 <erus`> IO bind is not lazy?
02:03:14 <shachaf> What do you mean by "lazy"?
02:03:26 <Kaidelong> I think with IO
02:03:35 <Kaidelong> if you have (a >>= b)
02:03:48 <Kaidelong> the IO action a WILL be run if the IO action a >>= b is run
02:04:06 <Kaidelong> even if the value from a doesn't get demanded in the result of b
02:04:14 <shachaf> Of course.
02:04:24 <Kaidelong> so in that sense it is not lazy, I guess
02:04:28 <Kaidelong> but that's really desirable
02:04:28 <shachaf> That's true of actions in general.
02:04:33 <shachaf> That's how (>>) works.
02:04:33 <Kaidelong> otherwise a >> b wouldn't work
02:04:39 <shachaf> It doesn't really have to do with laziness, though.
02:04:41 <wavewave> omega monad...
02:04:46 <shachaf> Assuming that by laziness you mean non-strictness.
02:05:20 <Kaidelong> anyway yes when you bind an IO action in do syntax
02:05:29 <Kaidelong> it will happen "before" the other things happen
02:05:41 <Kaidelong> this isn't neccessarily true of other IO-monad like things, like Orc
02:05:51 <Liskni_si> can anyone explain why test (\x -> (x :: Bool) == x) in LazySmallCheck does not terminate?
02:05:56 <wavewave> ohmygod monad
02:06:07 <shachaf> Can we not use IO as an example of a monad? It's weird.
02:06:29 <Kaidelong> I think erus` was really talking about IO anyway?
02:06:51 <erus`> well i wanna return a monad (my own error type)
02:06:55 <luqui> Identity is a nice example monad for such questions :-)
02:06:58 <erus`> but i dont care about ordering
02:07:02 <shachaf> "return a monad"?
02:07:09 <erus`> and i want it to be evaluated at the last possible time
02:07:23 <shachaf> luqui: data Null a = Null is even nicer.
02:07:23 <Kaidelong> hmm well you want to be working in something else other than IO then
02:07:40 <wavewave> we can make a lazy IO by unsafeInterleaveIO. is it right?
02:07:52 <erus`> and i wanna use bind because its less verbose than lost of pattern matching
02:07:59 <shachaf> In an affine monad u >> v === v
02:08:02 <Kaidelong> I think there was a better way than unsafeInterleaveIO
02:08:19 <kmc> «return undefined» may be an example of whatever it is that you're after
02:08:28 <luqui> erus`, if it is Either (the standard error monad), then checking whether or not there was an error will run the whole computation
02:08:31 <kmc> if you're talking about IO you need to be clear about the difference between evaluation order and execution order
02:08:35 <luqui> by
02:08:43 <luqui> 'The whole computation" i mean the monadically bound bits
02:08:46 <shachaf> kmc: That's true of every monad. :-)
02:08:56 <kmc> it's not clear for some monads what "execution" means
02:09:09 <kmc> it is very clear for IO
02:09:26 <shachaf> It is for most of them that I can think of.
02:09:27 <wavewave> execution : in state     evaluation : in value ?
02:09:47 <kmc> evaluation is what happens when you apply functions to arguments and then pattern-match on the result
02:09:52 <kmc> it's pure computation
02:09:53 <wavewave> probably state monad has a meaning for execution.
02:09:59 <erus`> i had all my function return an (IO value) before and had to create my own Thunk type to delay computation
02:10:13 <erus`> but i dont need IO anymore but i would like possible errors
02:10:20 <luqui> wavewave, then surely the reverse state monad has a dual notion...
02:10:26 <kmc> coexecution!
02:10:39 <wavewave> ohmygod monad.
02:10:52 <wavewave> has everything.
02:11:14 <wavewave> coexecutive coevaluation
02:11:34 * hackagebot regions 0.11 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.11 (BasVanDijk)
02:11:44 <erus`> or maybe i can just catch an 'error' somehow
02:11:50 <erus`> that would be easier
02:12:44 <erus`> then i dont need to wrap everything in an Either or whatever
02:12:57 <Kaidelong> what's wrong with wrapping stuff in Either
02:13:01 <Kaidelong> Either is a monad too
02:13:09 <Kaidelong> also you can only catch error in the IO monad
02:13:48 <Kaidelong> and if you want to do more than just propagate the exception there's always either
02:13:50 <Kaidelong> @ty either
02:13:51 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:14:12 <erus`> Kaidelong: but i dont wanna re-implement thunks again
02:14:16 <erus`> it seems silly
02:16:17 <erus`> i guess that doesnt make much sense without any context
02:16:34 * hackagebot regions-monadstf 0.3.1.7 - Monads-tf instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadstf-0.3.1.7 (BasVanDijk)
02:16:36 * hackagebot regions-mtl 0.3.1.7 - mtl instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-mtl-0.3.1.7 (BasVanDijk)
02:16:38 * hackagebot regional-pointers 0.7 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.7 (BasVanDijk)
02:18:29 * wavewave is reading Luke Palmer's lazy specialization article
02:21:02 <erus`> :t either
02:21:03 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:21:40 * hackagebot safer-file-handles 0.11 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.11 (BasVanDijk)
02:21:42 * hackagebot safer-file-handles-bytestring 0.3.0.1 - Extends safer-file-handles with ByteString operations  http://hackage.haskell.org/package/safer-file-handles-bytestring-0.3.0.1 (BasVanDijk)
02:21:44 * hackagebot safer-file-handles-text 0.2.0.2 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.2.0.2 (BasVanDijk)
02:21:47 * hackagebot usb-safe 0.14 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.14 (BasVanDijk)
02:26:32 <kmc> pop quiz: there's one bit of expression syntax that binds tighter than function application.  what is it?
02:26:50 <ddarius> Record update.
02:26:52 * shachaf raises hand.
02:27:01 <kmc> yes shachaf
02:27:14 <mauke> do patterns count as expression syntax?
02:27:19 <kmc> no
02:27:22 <mauke> aw
02:27:29 <kmc> which examples are there in patterns?
02:27:35 <mauke> @
02:27:39 <kmc> (ddarius had the answer and in record time)
02:27:51 <kmc> > let x@Just 3 = Just 3 in x
02:27:52 <lambdabot>   <no location info>: Parse error in pattern
02:27:58 <kmc> > let x@(Just 3) = Just 3 in x
02:28:00 <lambdabot>   Just 3
02:28:07 <shachaf> Actually there are two, aren't there?
02:28:12 <shachaf> Record update and record creation.
02:28:15 <kmc> > let x@(Just 3) = Just 4 in x
02:28:16 <shachaf> Two different things.
02:28:16 <lambdabot>   *Exception: <interactive>:3:4-22: Irrefutable pattern failed for pattern (x...
02:28:22 <kmc> *nod*
02:28:40 <shachaf> > Just {}
02:28:42 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
02:28:42 <shachaf> > (Just) {}
02:28:43 <lambdabot>   <no location info>: Empty record update
02:28:59 <mauke> > (Nothing){}
02:29:00 <lambdabot>   <no location info>: Empty record update
02:29:35 <shachaf> > id StateT {runStateT=error"a"} {runStateT=error"b"}
02:29:39 <lambdabot>   No instance for (GHC.Show.Show
02:29:43 <lambdabot>                     (Control.Monad.Trans.Sta...
02:30:40 <luqui> my eyes are burning
02:31:20 <shachaf> kmc: Do I get a candy for burning luqui's eyes?
02:31:39 <mreh> quicksilver: Haskelloids-reactive: internal error: MVAR object entered! (GHC version 6.12.1 for i386_unknown_linux) Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
02:31:50 <mreh> weeeee
02:32:02 <mreh> it kind of works though, however once in a while that happens
02:34:08 <kmc> :(
02:35:27 <erus`> kmc No instance for (Monad (Either InterpreterError)) arising from a use of `mapM'
02:35:48 <erus`> :|
02:36:20 <quicksilver> mreh: that's cute.
02:36:23 <shachaf> kmc import Control.Monad.Instances
02:36:36 <quicksilver> mreh: are you still using nasty unsafePerformIOs?
02:36:41 <mreh> quicksilver: nay
02:36:52 <mreh> quicksilver: want the code?
02:36:53 <quicksilver> woot.
02:36:57 <erus`> :t Either
02:36:58 <lambdabot> Not in scope: data constructor `Either'
02:36:59 <quicksilver> yes please
02:37:03 <erus`> @hoogle Either
02:37:03 <lambdabot> module Data.Either
02:37:04 <lambdabot> Prelude data Either a b
02:37:04 <lambdabot> Data.Either data Either a b
02:37:09 <mreh> quicksilver: I hope that woot was ironic :)
02:37:23 <erus`> oh Either isnt a monad?
02:37:25 <luqui> @erus, I think you need Control.Monad.Error for that instance
02:37:25 <lambdabot> Unknown command, try @list
02:37:34 <luqui> erus, I think you need Control.Monad.Error for that instance
02:37:35 <shachaf> erus`: Of course not. It has kind * -> * -> *
02:37:46 <mreh> i think leaks time fairly badly, but you can play with that, show me how you identify those pesky leaks
02:37:53 <mreh> code in a sec
02:38:10 <erus`> is there a mapF for functors?
02:38:29 <kmc> :t fmap
02:38:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:38:38 <kmc> that's the one and only function in the Functor type class
02:38:40 <shachaf> I'm sure you can figure that out the answer to your question from the type of fmap. :-)
02:38:48 <kmc> (or is (<$) in there these days)
02:38:57 <luqui> yes for some reason the f goes at the beginning for functors and at the end for monads
02:39:12 <luqui> it is an essential category-theoretic truth
02:39:20 <kmc> fmap is not a Functor analogue of mapM
02:39:30 <luqui> oh right
02:39:31 <luqui> duh
02:39:34 <erus`> @hoogle (a -> m b) -> [m a] -> [m b]
02:39:34 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:39:34 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:39:34 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
02:39:35 <luqui> liftM
02:39:40 <luqui> fmap vs. liftM
02:39:42 <mreh> cabal wont zip up my source files
02:39:44 <shachaf> Clearly liftM should be called mmap.
02:39:45 <luqui> reapply joke
02:39:46 <shachaf> mmap()
02:39:50 <mreh> do they *have* to be in a separate source dir
02:39:57 <erus`> @hoogle (a -> m b) -> [m a] -> m [b]
02:39:58 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:39:58 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:39:58 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
02:39:58 <kmc> :t \f -> sequenceA . map f
02:40:00 <lambdabot> Not in scope: `sequenceA'
02:40:05 <kmc> :t \f -> Data.Traversable.sequenceA . map f
02:40:06 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => (a1 -> f a) -> [a1] -> f [a]
02:40:08 <erus`> i need mapM for functors
02:40:09 <shachaf> liftM :: Monad m => () -> (a -> b) -> m a -> m b
02:40:18 <kmc> erus`, are your functors also monads?
02:40:19 <luqui> erus`, doesn't exist
02:40:22 <shachaf> erus`: Too bad.
02:40:23 <kmc> or at least Applicative
02:40:26 <luqui> erus`, applicative functors
02:40:40 <shachaf> erus`: You know you can get an instance Monad (Either e) from Control.Monad.Instances, right?
02:41:01 <erus`> well i do now :)
02:41:44 * hackagebot spine 0.1 - Simple implementation of the generic spine view  http://hackage.haskell.org/package/spine-0.1 (SeanLeather)
02:41:44 <mreh> where can I drop a small tarball to the internets?
02:41:58 <erus`> why is it not standard?
02:42:16 <shachaf> mreh: ompldr.org?
02:43:17 <mreh> shachaf: i like it
02:43:33 <erus`> shachaf: how can i import just     import Control.Monad.Instances (Functor (Either a))
02:43:38 <mreh> powered by 404 retarded geese
02:45:00 <quicksilver> erus`: you can't control instance import
02:45:02 <quicksilver> (un)fortunately
02:45:28 <mreh> well, you can chose not to import a module
02:45:42 <mreh> quicksilver: uploading... (-_-)
02:45:45 <quicksilver> \o/
02:45:45 <erus`> Functor(..) works well enough i guess
02:46:05 <quicksilver> erus`: if you import antyhing from the module you import all instances.
02:46:18 <erus`> oh i see
02:46:47 <erus`> whats the rational behind not making Either a monad in the first place?
02:46:58 <mreh> quicksilver: http://ompldr.org/vYWhxcA
02:47:20 <luqui> erus`, none really.  the standard instance sucks in a way though
02:47:27 <luqui> it has a typeclass constraint on the first argument
02:47:32 <quicksilver> mreh: excellent. Got it
02:47:33 <luqui> which is really annoying if you want errors to compose
02:47:42 <mreh> quicksilver: i've only seen it happen once, only played it twice
02:47:52 <shachaf> luqui: That's not true.
02:48:07 <mreh> quicksilver: the game is all defined in Test.hs
02:48:46 <shachaf> @src Either return
02:48:46 <lambdabot> return        = Right
02:48:46 <mreh> also do a diff between our Reactive sources, check nothing changed
02:48:47 <mreh> highly unlikely
02:48:47 <mreh> but possible
02:48:48 <shachaf> @src Either (>>=)
02:48:48 <lambdabot> Left  l >>= _ = Left l
02:48:48 <lambdabot> Right r >>= k = k r
02:49:13 <shachaf> Either (forall a. a) ~ Maybe
02:49:20 <luqui> instance (Error e) => Monad (Either e) where
02:49:20 <luqui>     return        = Right
02:49:20 <luqui>     Left  l >>= _ = Left l
02:49:20 <luqui>     Right r >>= k = k r
02:49:20 <luqui>     fail msg      = Left (strMsg msg)
02:49:30 <shachaf> luqui: That's not the instance I have. :-)
02:49:40 <luqui> looking here: http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/src/Control-Monad-Error.html
02:49:59 <luqui> did it get relaxed in a recent version?
02:50:01 <mreh> luqui: still interested in games?
02:50:03 <quicksilver> luqui: we're talking about Control.Monad.Instances.
02:50:27 <shachaf> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Instances.html
02:50:39 <luqui> ah i just googled
02:50:43 <luqui> was looking at 6.12
02:51:08 <luqui> cool
02:51:10 <luqui> i approve.
02:51:38 <luqui> heh, the docs are wrong
02:52:09 <shachaf> luqui: True. Submit a patch!
02:54:07 <mreh> quicksilver: I can't replicate it again, the source is unchanged since it happened, I'll let you know if I can make it happend
02:54:46 <luqui> mreh, not so much
02:54:49 <luqui> mildly
02:54:54 <obiwahn> is | useable in lamda expressions? like \a -> | a ... ?
02:55:06 <shachaf> obiwahn: What's that supposed to mean?
02:55:16 <mreh> luqui: okay, i was going to suggest you look at quicksilver's reactive
02:55:28 <mreh> if you haven't already
02:55:31 <luqui> frp is still interestin! :-)
02:56:00 <obiwahn> fun a | a == True = "foo" | otherwise = "False"
02:56:07 <luqui> where do i find this?
02:56:19 <hpaste> erus` pasted “thisIsTheTest doesnt terminates” at http://hpaste.org/51696
02:56:32 <luqui> obiwahn, oh, no.  that'd be cool :-)
02:56:45 <erus`> any ideas how i can get that to return a value without making a Thunk type?
02:56:56 <shachaf> \a -> case () of () | ...
02:57:21 <leod> at that point i'd much rather write a named function :p
02:57:27 <shachaf> Or, if you want to confuse C programmers: \a -> case() of() |
02:57:38 <obiwahn> eheh:P
02:57:48 <mreh> luqui, with difficulty, d/l this, it's in there under Reactive.hs http://ompldr.org/vYWhxcA
02:57:58 <shachaf> To be fair, it won't confuse them very much.
02:59:03 <luqui> erus`, yeah... you have implemented call-by-value semantics by introducing the error monad
02:59:17 <obiwahn> brackets confused me a lot a the beginning:)
02:59:34 <erus`> luqui: whats the alternative ?
02:59:55 <luqui> erus`, what is the goal of your Error type?
03:00:09 <luqui> do you wish to have a language mechanism for catching errors?
03:00:15 <luqui> or is it just kind of a "top-level" precaution
03:00:23 <erus`> no just report errors in the interpreter
03:00:41 <erus`> applying a value to a non function or something
03:00:58 <luqui> here is one of my favorites
03:01:06 <luqui> i think henning has a module for this
03:01:10 <luqui> instead of using an error monad
03:01:13 <luqui> use a *writer*
03:01:56 <luqui> with this monoid:  data E = NoError | Error;   mempty = NoError; mappend NoError NoError = NoError; mappend _ _ = Error
03:02:09 <luqui> then your computation can be lazy
03:02:23 <luqui> and you can force the error independent of the computation
03:03:29 <luqui> ironically, it is tricky and subtle to model a lazy language in a lazy language
03:04:25 <erus`> yeah :P
03:05:01 <luqui> that monoid instance will still give you subtle difficulties when it comes to the corner cases of nontermination
03:05:20 <luqui> it is not lazy enough; to make it lazy enough, you need unamb
03:05:32 <ddarius> The "correct" thing to do isn't to use a different monad, but to use a different monadic style.
03:05:58 <luqui> ddarius, go on...
03:06:32 <quicksilver> if you think you need unamb you're asking the wrong question :)
03:06:38 <ddarius> As I mentioned a few days back, there are multiple continuation passing style transformations corresponding to call-by-value or call-by-name.  Both are just special cases of call-by-value or call-by-name monadic style transformations.
03:06:47 <erus`> using a Thunk type doesn't seem so inelegant in comparison
03:07:39 <bonobo123> hi all
03:07:49 <luqui> ddarius, can we get call by need though?
03:08:01 <ddarius> The key idea (which is fairly obvious) is probably clearest by the action of these transforms on types.  Call-by-value CPS transforming transforms A -> B to A -> Cont B, whereas the call-by-name is A -> B to Cont A -> Cont B.
03:08:14 <bonobo123> I just got containers sources from git, I would like to run the tests that are in there... how do I get around doing it?
03:09:31 <ddarius> luqui: That's essentially just "memoizing" the computations which involves adding state and sharing.  You can't get call-by-need just by using a different style.
03:09:38 <luqui> quicksilver, why do you say that?
03:10:09 <luqui> ddarius, ya.  thus we are modeling the evaluation strategy purely
03:10:33 <luqui> nice, a lot of work
03:10:52 <luqui> for simple things, i prefer to transfer haskell's semantics
03:10:54 <quicksilver> luqui: its side condition is too high price to pay.
03:11:11 <luqui> quicksilver, you mean a = b when not bottom?
03:11:17 <quicksilver> luqui: as part of a *target* language, using a frontend compiler which could statically verify the side condition, sure.
03:11:20 <quicksilver> yes.
03:11:25 <luqui> yeah i agree
03:11:33 <luqui> so "you need unamb" was a little strong
03:11:38 <luqui> you need something based on unamb
03:11:59 <luqui> unamb needs as much care as unsafePerformIO (though is semantically cleaner)
03:12:25 <luqui> aka: can't be done with sequential evaluation
03:16:09 <luqui> quicksilver, this looks like a straightforward demagicalization of conal's reactive
03:16:10 <luqui> yay
03:16:15 <luqui> how's it performing?
03:16:25 <luqui> (not just speed, but cleanliness etc.)
03:16:49 <luqui>  /cc mreh
03:17:52 <quicksilver> luqui: it works for a few examples of mine and one of mreh's
03:18:03 <quicksilver> luqui: It has known bugs which may or may not be hard to solve :)
03:18:12 <luqui> haha
03:18:15 <luqui> i know that story :-)
03:18:26 <quicksilver> luqui: Future `mappend` can, in principle, put the wrong future first
03:18:53 <quicksilver> if the runtime manages to yield the one that finished second, first, since GHC threads have no appropriate fairness guarantee.
03:19:13 <quicksilver> However that doesn't cause a problem in the kind of examples I write
03:19:35 <quicksilver> (if two very-nearly-simultaneous events get permuted in order that's not really a big issue for a game/physical simulation)
03:19:50 <luqui> yeah true
03:20:00 <quicksilver> that's about as far as I got when I stopped working on it 2 (?) years ago
03:20:16 <quicksilver> I need to write a test case for that (probably by adding artificial sleeps to make it more likely to happen)
03:20:20 <quicksilver> and think of a fix.
03:20:42 <quicksilver> it runs my just-about non-trivial "Stars" simulation with no long-term memory leaks
03:20:47 <quicksilver> which was my first milestone of "Success"
03:20:59 <luqui> :-)
03:21:01 <mreh> i was very impressed
03:21:30 <quicksilver> luqui: it's very easy to accidentally cause an ever-growing thunk which is never inspected
03:21:37 <quicksilver> hanging of an event which you only use for timing, or something.
03:21:51 <quicksilver> we need better run-time profiling to catch this kind of issue I think
03:22:01 <mreh> quicksilver: i was going to ask how you catch them?
03:22:10 <mreh> but with difficulty by the sounds of it
03:22:26 <luqui> or like... dons's strict concurrency frpized
03:22:53 <luqui> don't know if that's possible, we're blurring denotation and operation more
03:23:19 <quicksilver> luqui: well I thought we could have a primite to merge a Strategy a with an Event a
03:23:33 <quicksilver> luqui: which would make it easy to do "as much evaluation as you want to avoid a memory leak" as you go along.
03:23:46 <quicksilver> but that doesn't help in catching things - just gives you a convenient way to solve them when you do.
03:23:54 <luqui> yeah
03:24:06 <quicksilver> the idea is the strategy would get applied to *every* instance of that event, even if it never gets observed.
03:24:11 <luqui> hmmm, would it be a sin to make events strict...
03:24:15 <quicksilver> (unless, of course, the entire event gets GCed)
03:24:28 <quicksilver> mreh: well I observe them using the heap profiling
03:24:42 <quicksilver> mreh: and then I experiment with different heap profile options until I pin it down
03:24:48 <quicksilver> in a small program it's not that hard to work out what it must be.
03:25:05 <mreh> quicksilver: it's also not hard to make a big program into smaller bits :)
03:25:05 <quicksilver> luqui: it would be quite reasonable for a large class of programs
03:25:11 <mreh> cool, i'll have a play
03:25:38 <luqui> quicksilver, yeah, but runtime behavior of compositions of programs can interact nontrivially
03:26:44 * hackagebot svm-simple 0.2.5 - Medium level, simplified, bindings to libsvm  http://hackage.haskell.org/package/svm-simple-0.2.5 (VilleTirronen)
03:26:44 <luqui> so i've just stayed up until 5:30 am.  fun day tomorrow
03:27:02 <luqui> need bed.  thanks for reminding me about frp mreh, thanks for lib quicksilver
03:27:12 <mreh> mreh, np
03:27:30 <erus`> anyone at ICFP?
03:28:21 <mreh> tokyo yes?
03:28:42 <erus`> are they filming the haskell talks?
03:29:32 <obiwahn> waht is the reverse function for ord? - eg ord 'a'
03:29:50 <ahf> usually, it's chr
03:29:51 <quicksilver> obiwahn: chr
03:29:56 <quicksilver> > chr 65
03:29:57 <lambdabot>   'A'
03:35:38 <erus`> does Right meh = return meh ?
03:36:22 <erus`> yes
03:41:36 <parcs> @src Either return
03:41:37 <lambdabot> return        = Right
03:58:40 <hpaste> “md2perpe+hpaste@gmail.com” annotated “What does <|> do?” with “What does <|> do? (annotation)” at http://hpaste.org/51687#a51699
04:01:07 <BobFunk> having some Enumerator trouble
04:01:34 <BobFunk> is there any way to combine an Enumeratee String String IO String with an Iteratee String IO ()
04:01:44 * hackagebot dingo-core 0.0.3.3 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.0.3.3 (BardurArantsson)
04:11:20 <navaati> hello
04:12:15 <navaati> is it possible that, if I read and write in an IORef at the same time (in two concurrent trheads), problem appears ?
04:16:49 <quicksilver> navaati: I would recommend that you don't do that, but it shouldn't cause any particularly problem.
04:16:58 <quicksilver> you will just find it hard to be confident what you read.
04:18:15 <navaati> ok, but i mean, there won't be memory corruptions/incoherent values because of writing while reading, or things like that ?
04:18:28 <quicksilver> nope
04:18:39 <navaati> ok, fine, thank you
04:18:49 <navaati> so i don't even need mvars
04:20:15 <quicksilver> MVars help you construct systems which are easier to reason about
04:21:55 <cheater> hey guys
04:22:06 <cheater> so how do i get the latest HP and ghc on my ubuntu 10.04?
04:22:19 <cheater> download the generic ghc binary, then compile HP from source?
04:22:31 <cheater> and do i then recompile ghc?
04:23:18 <quicksilver> you shouldn't need to recompile ghc
04:23:23 <quicksilver> can't you use a binary of the platform?
04:23:39 <hpaste> erus` pasted “help me reduce the pattern matching plox” at http://hpaste.org/51700
04:25:07 <navaati> quicksilver: actually i don't need synchronising between threads : i have a displaying loop at 50fps that write events to an IOvar and read drawing data from another, and a simulation loop running as fast as possible that read events and write drawing data
04:26:23 <navaati> well, saying it like this makes me thinking that maybe i should use a MVar for the event var, if i want to guarantee that i don't miss events
04:26:31 <navaati> makes me think*
04:26:44 <freeasjesus> How do you swear in Haskell?
04:26:52 <opqdonut> unsafePerformIO
04:28:32 <Nafai> opqdonut: Nice!
04:29:36 <parcs> navaati: if you have one IORef you can use atomicModifyIORef
04:31:33 <navaati> parcs: values are written in a thread and read in another, so they are never modified in the same thread
04:32:12 <ClaudiusMaximus> @hoogle tryReadChan
04:32:13 <lambdabot> No results found
04:32:48 <navaati> @hoogle isChanEmpty
04:32:48 <lambdabot> No results found
04:33:00 <ClaudiusMaximus> @hoogle isEmptyChan
04:33:01 <lambdabot> Control.Concurrent.Chan isEmptyChan :: Chan a -> IO Bool
04:33:14 <ClaudiusMaximus> but that's deprecated/removed/buggy depending on library versions
04:33:29 <navaati> really ? i was also thinking about it
04:33:48 <navaati> the doc don't say anything about this deprecation
04:33:55 <frerich> erus`: Are you tm1rbrt on stackoverflow.com ?
04:34:04 <erus`> yerp
04:34:15 <frerich> erus`: I thought that code sample looked familiar...
04:34:50 <erus`> you can recognise my ugly code idioms
04:34:53 <ClaudiusMaximus> navaati: well, the result would be out of date as soon as it returns - but the bug is that it can block under certain circumstances iirc
04:36:09 <navaati> "the result would be out of date as soon as it returns" ? i don't understand this :/
04:36:53 <ClaudiusMaximus> suppose it returns True, but another thread writes to the Chan before you get to do anything with that information
04:37:32 <ClaudiusMaximus> likewise if it returns False, another thread could read the value before you
04:37:43 <navaati> then i'll get the event on the next frame, wich is an acceptable behaviour
04:37:44 <ClaudiusMaximus> http://hackage.haskell.org/trac/ghc/ticket/4154 is the bug i referred to
04:38:24 <ClaudiusMaximus> the second case is the awkward one if you want to keep doing something else instead of blocking
04:41:32 <navaati> oh, i see
04:42:15 <navaati> in my case i can't run into this problem since i only have one thread writing an an other reading
04:43:35 <ClaudiusMaximus> cool
04:45:34 <ClaudiusMaximus> i need to rewrite the job scheduler for one of my projects, it's got an annoying race condition somewhere that sometimes forgets some jobs that need doing (possibly when jobs were started for the previous task, and not yet completed, and the next task also needs those jobs)
04:50:56 <erus`> @hoogle (a -> a -> M b) -> M a -> M a -> M b
04:50:57 <lambdabot> Warning: Unknown type M
04:50:57 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
04:50:57 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
04:51:09 <erus`> i need a double bind
04:51:10 <erus`> :|
04:51:30 <navaati> :t liftM2
04:51:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:52:30 <parcs> :t liftM3 id
04:52:32 <lambdabot> forall a2 a3 r (m :: * -> *). (Monad m) => m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
04:52:32 <quicksilver> erus`: you just use >>= twice
04:52:37 <navaati> :t join . liftM2
04:52:38 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
04:52:59 <quicksilver> :t \f a b -> a >>= \va -> b >>= \vb -> f va vb
04:53:00 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
04:53:15 <quicksilver> erus`: to be honest most people find that easier to read in do notaiton.
04:53:22 <quicksilver> but, it is just using >>= twice.
04:53:25 <djahandarie> Hey all -- any thoughts this morning on why http://hpaste.org/51694 is erroring?
04:54:02 <djahandarie> I could see this error happening if it was trying to unify a with Int or something, but it should just be trying to unify two free type variables, so I don't see the issue.
04:54:17 <buntfalke> Hi
04:54:31 <Axman6> hi buntfalke
04:55:24 <quicksilver> djahandarie: it's point is, basically, that you'll never be able to use that constructor, so it won't let you define it.
04:55:56 <djahandarie> quicksilver, do you understand why?
04:55:59 <dmwit> Yay!
04:56:02 <quicksilver> djahandarie: if you write "X blah" for some concrete term blah, it will never be able to work out which 'a' you are using because it's not mentioned in the type of X
04:56:08 <dmwit> Type normalization, now in GHC HEAD!
04:56:11 <quicksilver> and type families are not injective.
04:56:22 <parcs>  it works when a type instance for Tag f a is defined
04:56:27 <ClaudiusMaximus> to my noob never-used-tf looks like unification of that expression would lead to infinite type?
04:56:35 <shachaf> quicksilver: But it doesn't error if you don't use record syntax.
04:56:44 <quicksilver> then I withdraw my guess
04:56:49 <quicksilver> and recommend a post to g-h-u ;)
04:57:17 <shachaf> @where g-h-u
04:57:18 <lambdabot> I know nothing about g-h-u.
04:57:23 <quicksilver> glasgow-haskell-users
04:57:27 <quicksilver> it's a mailing list
04:57:32 <djahandarie> quicksilver, also, replace one of the (Tag f a) with just a, and it works.
04:57:34 <shachaf> Ah.
04:57:45 <shachaf> djahandarie: But if you get rid of one of them, it doesn't.
04:57:54 <parcs> shachaf: but you can't create a function that accesses that constructor's argument
04:58:16 <shachaf> I don't think that was the question, though. :-)
04:58:23 <rwbarton> I think it's like what quicksilver except the problem is with x and not X
04:58:27 <parcs> you said "it doesn't error if you don't use record syntax."
04:58:44 <djahandarie> Yes, rwbarton is correct, but I still don't see the issue and when it is not erroring in similar cases.
04:58:51 <djahandarie> and why*
04:58:59 <quicksilver> I think there is a bug here somewhere
04:59:01 <shachaf> parcs: Oh, I see.
04:59:06 <quicksilver> I'd expect all variants of that to be rejected.
04:59:35 <djahandarie> Let me try to do something evil with it then
04:59:47 <parcs> actually you _can_ create the record accessor yourself, but only if you let its type be inferred
05:00:01 <djahandarie> parcs, I tried that, couldn't get it to work.
05:00:37 <rwbarton> the issue is suppose v :: X c f, then x v :: forall a. c (Tag f a) (Tag f a), but knowing the type "c (Tag f a) (Tag f a)" can never tell me what a is
05:01:05 <parcs> djahandarie: worksforme
05:01:12 <rwbarton> whereas if you replace one (Tag f a) by a, then "c a (Tag f a)" does tell you what a is, so it's possible to apply x
05:01:17 <ClaudiusMaximus> i got confused by all the shadowing in x(X{x=x})=x
05:01:24 <djahandarie> Hmmm
05:01:36 <parcs> data X c f = X (forall a. c (Tag f a) (Tag f a)); y (X x) = x
05:01:44 * hackagebot neither 0.3.0 - Provide versions of Either with good monad and applicative instances.  http://hackage.haskell.org/package/neither-0.3.0 (MichaelSnoyman)
05:02:00 <rwbarton> my guess is that parcs is using an older ghc than djahandarie
05:02:04 <buntfalke> Is there a strict scanl, like foldl'?
05:02:08 <djahandarie> He is, that is why
05:02:17 <Axman6> @hoogle scanl'
05:02:18 <lambdabot> No results found
05:02:32 <buntfalke> Axman6: tried that already :-)
05:02:36 <djahandarie> Is there a reason why we need to know what a is? I don't need to in my case, I want it to be polymorphic.
05:02:36 <buntfalke> Why is that?
05:02:39 <Axman6> i guess not =)
05:02:47 <rwbarton> well consider this
05:02:47 <ClaudiusMaximus> @src scanl
05:02:48 <lambdabot> scanl f q ls = q : case ls of
05:02:48 <lambdabot>     []   -> []
05:02:48 <lambdabot>     x:xs -> scanl f (f q x) xs
05:02:55 <Axman6> well, i think it's because scanl's results are lazy
05:03:01 <rwbarton> I have v :: X C F and now I write x v :: C Int Int
05:03:13 <Axman6> i'm not sure a strict scanl will be very useful
05:03:14 <parcs> i'm on ghc 7.0.3
05:03:28 <djahandarie> Shouldn't it error then?
05:03:34 <buntfalke> Axman6: It would if you need all intermediate results anyway
05:03:58 <Axman6> well, the sub expressions will get forced when you use them
05:04:00 <rwbarton> if you can tell that it would error on that usage, why not give you the error earlier? that is what newer ghc does
05:04:01 <ClaudiusMaximus> Axman6: it might be useful in the same circumstances that a strict iterate is useful
05:04:27 <buntfalke> Here http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#With_scanl it would be usefull
05:04:38 <ClaudiusMaximus> > iterate (+1) 0 !! 1000000
05:04:40 <lambdabot>   *Exception: stack overflow
05:05:03 <Axman6> hmm, this is true
05:05:08 <buntfalke> @hoogle iterate'
05:05:08 <lambdabot> No results found
05:05:37 <rwbarton> djahandarie: it would be fine if there was some syntax for explicit application of a term of a type like "forall a. c (Tag f a) (Tag f a)" to the type "a"... but there isn't
05:06:07 <Axman6> > let iter' f x = x `seq` let x' = f x in x : iter' f x' in iter (+1) !! 100000
05:06:07 <lambdabot>   Not in scope: `iter'
05:06:07 <Axman6> > let iter' f x = x `seq` let x' = f x in x : iter' f x' in iter' (+1) !! 100000
05:06:08 <lambdabot>   Couldn't match expected type `[a]'
05:06:08 <lambdabot>         against inferred type `a1 -> [a1]'
05:06:21 <Axman6> > let iter' f x = x `seq` let x' = f x in x : iter' f x' in iter' (+1) 0 !! 100000
05:06:22 <lambdabot>   100000
05:06:29 <Axman6> > let iter' f x = x `seq` let x' = f x in x : iter' f x' in iter' (+1) 0 !! 1000000
05:06:31 <lambdabot>   1000000
05:06:36 <djahandarie> rwbarton, I suppose I could hack around this back manually adding an 'a' everywhere outside of the type function to basically manually do that?
05:06:57 <djahandarie> s/back/by/
05:06:57 <rwbarton> such applications are inferred from specifying a type like x v :: c Int Int... but in this case you can never recover a from the type, because type families are not injective
05:07:24 <rwbarton> right, you could add a as an argument to c perhaps
05:07:50 <djahandarie> rwbarton, to give a little more context, x is actually monad's join, where c is a category, and Tag f goes from some tag to a type function representing my functor.
05:08:04 <Axman6> > let scanl' f z [] = [z]; scnal f z (x:xs) = z `seq` let z' = f z x in z : scnal' f z' xs in drop 100000 $ scanl' (+) 0 [1..]
05:08:05 <lambdabot>   Not in scope: `scnal''
05:08:12 <Axman6> > let scanl' f z [] = [z]; scnal f z (x:xs) = z `seq` let z' = f z x in z : scanl' f z' xs in drop 100000 $ scanl' (+) 0 [1..]
05:08:13 <lambdabot>   *Exception: <interactive>:3:4-22: Non-exhaustive patterns in function scanl'
05:08:25 <Axman6> eh?
05:08:34 <djahandarie> rwbarton, the Tag hack is basically to just get around partially applying type families
05:08:48 <Kaidelong> what's HPC in the context of haskell
05:09:02 <Kaidelong> this "Design and Implementation of XMonad" slide show mentions it
05:09:07 <Axman6> the code coverage thing in GHC?
05:09:09 <Axman6> @where hpc
05:09:10 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
05:09:17 <hpc> oh, hi
05:09:24 <Axman6> there you are
05:10:55 <djahandarie> rwbarton, so, I really do want values like   f :: forall a. LTE (ClampEven (ClampEven a)) (ClampEven a)   to go in that record -- but I clearly need to think about this more.
05:11:12 * djahandarie wonders off to think about it
05:12:23 <djahandarie> Oh, and sorry, I actually simplified it for that example, it was originally   data Monad c f = Mon { ... , monJoin :: forall a. c (Tag f (Tag f a)) (Tag f a) }
05:19:43 <rwbarton> djahandarie: it occurs to me that sometimes Tag f a would determine a, since f is known
05:20:01 <rwbarton> so perhaps GHC should allow this after all...
05:22:38 <parcs> djahandarie's code compiles if you add a contrived 'type instance Tag f a = a'
05:22:54 <parcs> what is the implication of this?
05:22:58 <rwbarton> well that certainly would let you recover a from Tag f a!
05:23:36 <rwbarton> of course at that point you might as well have just written 'a' originally in place of 'Tag f a'
05:24:07 <parcs> you can successfully substitute the a on the RHS for any type
05:24:12 <parcs> and it still compiles
05:24:25 <rwbarton> really? how about, say, Bool
05:24:27 <rwbarton> oh
05:24:27 <parcs> yep
05:24:44 <rwbarton> well I guess that sort-of makes sense because then the compiler knows that a is in fact irrelevant
05:25:43 <rwbarton> > let x :: forall a. Int ; x = 3 in x
05:25:44 <lambdabot>   3
05:25:53 <rwbarton> you've done the equivalent of that
05:27:02 <parcs> i think i understand why the code doesn't compile now
05:27:45 <parcs> that's a bad error message though
05:40:00 <nomeata> With this promising ConstraintKinds extension, can I implement custom constraints of kind "Constraint"? For example, a constraint FiresMissles so that I can tell by the constraints on main whether it calls "launchMissles :: FiresMissles => IO ()" somewhere?
05:41:48 <imphasing> Is <*> like $, but for boxed up stuff?
05:42:13 <shachaf> imphasing: No.
05:42:19 <imphasing> Yeah, it's more like a map I guess..
05:42:21 <imphasing> Hm :/
05:42:24 <shachaf> Functors aren't boxes.
05:42:40 <quicksilver> well that depends what you mean by boxes
05:42:42 <shachaf> You're probably thinking of <$> anyway.
05:42:47 <quicksilver> if by boxes you meant functors then the answer is yes
05:42:50 <shachaf> quicksilver: If you mean "functors", then sure. :-)
05:42:58 <quicksilver> or applicatives, indeed
05:43:01 <shachaf> Or monads.
05:43:05 <imphasing> I mean a monad, I thought a functor was just a function that works on a monad?
05:43:27 <quicksilver> imphasing: nope.
05:43:28 <imphasing> It seems like it behaves like $ with monadic values, except it also works like fmap it seems
05:43:41 <quicksilver> imphasing: A functor is a type class, like a monad.
05:43:42 * shachaf would recommend erasing the word "monad" from your mind.
05:43:57 <quicksilver> > (Identity negate) <*> (Identity 5)
05:43:58 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity a))
05:43:58 <lambdabot>    arisi...
05:44:08 <quicksilver> gah
05:44:12 <quicksilver> > (Identity negate) <*> (Identity (5::Int))
05:44:14 <lambdabot>   No instance for (GHC.Show.Show
05:44:14 <lambdabot>                     (Data.Functor.Identity.I...
05:44:16 <imphasing> "Functors can do one thing, and one thing only, they can apply a function to a value inside an outer construction." so is this not correct?
05:44:27 <shachaf> imphasing: Nope.
05:44:28 * parcs hands quicksilver runIdentity
05:44:30 <imphasing> :(
05:44:37 <quicksilver> imphasing: that is what they can do
05:44:37 <imphasing> y u lie to me internet.
05:44:44 <imphasing> Hm
05:44:49 <shachaf> There is no "value inside".
05:44:53 <quicksilver> imphasing: you just identified the wrong part as being the functor.
05:44:59 <quicksilver> imphasing: the functor is not the function.
05:45:04 <imphasing> It's the wrapper?
05:45:07 <quicksilver> yes.
05:45:13 <imphasing> Hm, I see.
05:45:14 <quicksilver> a functor is a wrapper with a recipe for applying functions
05:45:15 <shachaf> A functor can mean many things. Almost all of the time, it doesn't even contain any value.
05:45:25 <shachaf> I think calling it a "wrapper" is misleading.
05:45:25 <quicksilver> "inside" it for some sense of the word inside.
05:45:41 <shachaf> quicksilver: "inside" in the sense that "box" means "functor". :-)
05:45:44 <rwbarton> nomeata: ddarius has been advocating nullary type classes for a while, which is equivalent to your suggestion, I think.
05:45:44 <quicksilver> well, it's a type wrapper.
05:45:46 <imphasing> wait, so is a functor a monad? because that sounds a lot like a monad
05:45:52 <quicksilver> imphasing: yes, all monads are functors.
05:45:57 <quicksilver> imphasing: functors are just simpler.
05:46:02 <imphasing> interesting..
05:46:04 <quicksilver> monads can do more tricks.
05:46:08 <shachaf> quicksilver: Right, but imphasing is treating it as a value wrapper. It's an important distinction to make, I think.
05:46:17 <shachaf> rwbarton: nullarytypeclasses++
05:46:17 <nomeata> rwbarton: thx. Probably much easier to implement now that constraints are just types.
05:46:24 <quicksilver> shachaf: perhaps, perhaps. But it's not necessarily the right rechnique to pull apart every word he says
05:46:30 <imphasing> So it's not wrapping a function, it's a wrapper over a function application strategy?
05:46:32 <shachaf> nomeata: Nah, nullary type classes have always been trivial to implement. :-)
05:46:43 <quicksilver> imphasing: it is a type.
05:46:48 <imphasing> I guess you pass the function the functor applies to it
05:46:56 <shachaf> quicksilver: Right; I didn't think that's what I was doing.
05:46:59 * shachaf will reexamine.
05:47:00 <quicksilver> imphasing: more precisely, a type constructor, a related class of types.
05:47:06 <quicksilver> imphasing: "Maybe" is a functor.
05:47:09 <nomeata> shachaf: ok, let me rephrase: Probably trivial to implement now that constraints are just types. :-)
05:47:26 <quicksilver> so are lists ([]) and lots of other things.
05:47:39 <shachaf> nomeata: I'm pretty sure it's been nothing more than an artificial restriction ever since MPTCs and FlexibleContexts have been around.
05:48:17 * shachaf needs to go.
05:48:29 <shachaf> imphasing: Despite anything I may have said, you should listen to quicksilver. :-)
05:48:36 <imphasing> Is it ever possible to get a String type out of an IO container in haskell? Or will you always have to work through a monad to work with impure results?
05:48:42 <imphasing> shachaf: I appreciate your comments too :D
05:48:55 <quicksilver> imphasing: in a sense you always have to work through the monad
05:48:59 <shachaf> imphasing: "IO String" isn't really an impure result.
05:49:03 <quicksilver> in practice this is not inconvenient
05:49:13 <quicksilver> and it doesn't "pollute" your program
05:49:26 <shachaf> In fact, there's nothing "impure" about it. It's just a value.
05:49:26 <quicksilver> you can write most of your program as a very large, pure, function String -> String
05:49:36 <quicksilver> and you just need one application of 'fmap' to apply it to your IO String.
05:49:58 <imphasing> quicksilver: Ah, I see
05:50:20 <shachaf> imphasing: A value of type "IO String" is like a recipe for making a String.
05:50:47 <shachaf> imphasing: You can execute it multiple times, and each time, it'll do something and then provide you with a String.
05:51:06 <shachaf> It's not an "impure String", and it doesn't contain a String anywhere inside it.
05:51:13 <imphasing> Aaahhhhh...
05:52:01 <imphasing> So is thinking of monads as a structured form of function composition a bad idea? It seems like you're basically creating a recipe for composing functions then giving it something to work on...
05:52:18 <shachaf> imphasing: I'm not sure I understand what you mean.
05:52:24 <shachaf> Where's the composition?
05:52:34 <shachaf> getLine :: IO String isn't a function, it's just a value.
05:53:00 <imphasing> The composition would be the process of getting the string from IO, which would be the value of the monad itself the way I'm thinking of it
05:53:01 <quicksilver> imphasing, shachaf : "composition" but not function composition.
05:53:15 <quicksilver> monads are definitely about structured composition
05:53:31 <quicksilver> >>= and >> are both composition operators for a suitably general interpretation of composition
05:53:41 <quicksilver> building up large recipes from small recipes
05:53:45 <quicksilver> recipes are compositional
05:53:48 <shachaf> quicksilver: So is >=>. :-)
05:53:51 <quicksilver> yes.
05:53:54 <mux> so is ;\n
05:53:56 <imphasing> Man that's cool
05:54:37 <shachaf> imphasing: I think you're misusing the word "monad", by the way. getLine isn't a monad, and "IO String" isn't a monad. "IO" is a monad, if that helps you with anything, but the fact that it's a monad isn't even all that relevant if you're just trying to understand how it works.
05:54:37 <frerich> Are there also strange monads which are supposed to be used as 'meta monads', containing other monads. So that oyu're wrapping the 'real' value like an onion?
05:55:00 <shachaf> Monads don't wrap values! :-(
05:55:00 <imphasing> So do you have to implement a >>= for each monad type? It seems like 'bind' needs to be different for each monad :/
05:55:09 <shachaf> Hmph.
05:55:26 <shachaf> imphasing: Yes.
05:55:37 <quicksilver> imphasing: precisely.
05:55:47 <dankna> indeed, a different bind is the main reason to have a monad at all
05:55:53 <imphasing> shachaf: Yeah, I have a hard time grasping what the monad even is, is it the type that implements the interface with bind and return basically?
05:56:01 <dankna> that's precisely correct
05:56:02 <quicksilver> imphasing: in fact, a more platonic view is that you "discover" that your data type is a monad when you "notice" there is a sensible way to implement >>= for it.
05:56:07 <shachaf> Each monad puts you in a different bind.
05:56:09 <frerich> shachaf: With 'real value' I wasn't thinking of a Haskell value but of the result value of 'executing' the monadic value
05:56:34 <dankna> a monad is a particular meaning for bind and return (and fail, for bad reasons, but don't worry about that)
05:56:42 <quicksilver> frerich: but getLine returns a different value each time you execute it.
05:57:09 <shachaf> frerich: I think that's an unhelpful way of thinking about it. There is no "real value", or maybe there are several, or maybe they're different each time, or who knows.
05:57:19 <quicksilver> frerich: (and 'execution' is not clean general notion, although all monads have some kind of 'run' behaviour to make them useful)
05:57:25 <imphasing> quicksilver: I guess the referential transparency is still there because getLine is returning the recipe for getting a line and not the line itself, which is always the same?
05:57:25 <tigger_> Hi there, hoping someone can help me out with this. Some code I'm having trouble understanding: http://hpaste.org/51701. Line 15, how exactly does the type 'a' come in scope?
05:57:30 <frerich> quicksilver: Yeah. Of course executing an 'action' like getLine can yield something different each time. Or it oculd also yield the same. In any case: I was wondering whether there are monads which are used to 'encompass' other actions.
05:57:43 <dankna> imphasing, again, yes, that's just right
05:57:46 <Saizan> frerich: anyhow to compose monads there are "monad transformers"
05:57:49 <shachaf> quicksilver: I think "execution" has a reasonably clear meaning in every monad.
05:58:11 <Botje> tigger_: m has type Parser a, f has type a -> Parser b
05:58:12 <Saizan> frerich: which are quite onion-like
05:58:13 <imphasing> Sweeet, maybe I'll be able to work with IO soon without my brain exploding ;P
05:58:30 <shachaf> tigger_: It's an argument to ks'
05:58:47 <quicksilver> tigger_: that line is defining a function ks'
05:58:53 <quicksilver> tigger_: it brings into scope "a" as a parameter
05:59:04 <shachaf> tigger_: You're defining a local function ks' that takes an argument "a" and returns "runParser (g a) kf ks".
06:00:57 <shachaf> imphasing: getLine isn't "returning a recipe", by the way, because it's not a function.
06:00:58 * frerich wonders whether so many people, including himself, have trouble grasping what the 'monad deal' is all about because for whatever explanation somebody comes up with, somebody else will find a counter-example where the explanation (or analogy) doesn't apply.
06:01:02 <shachaf> imphasing: It *is* a recipe.
06:01:14 <shachaf> frerich: Yep.
06:01:17 <imphasing> Aaaah...
06:01:21 <shachaf> @google monad tutorial fallacy
06:01:23 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
06:01:23 <lambdabot> Title: Abstraction, intuition, and the “monad tutorial fallacy” « blog :: Brent -> ...
06:01:30 <shachaf> frerich: Analogies are pretty unhelpful.
06:01:46 <shachaf> Your best bet is probably not to analogize -- just look at concrete cases.
06:02:48 <imphasing> I feel like some of the confusion comes from everyone talking about monads like they're things, instead of actions.. it seems like they're sequences of actions, not concrete "things" so I always get confused when they're used like nouns since it doesn't seem to make sense..
06:02:57 <imphasing> That's probably beceause I have an imcomplete understanding though
06:03:04 <shachaf> imphasing: Monads aren't actions, they're type constructors. :-)
06:03:11 <Cale> kmc: make sure that your talk gets recorded, sounds like something that would be good to have up on Reddit/etc. :)
06:03:55 <imphasing> @src Just
06:03:55 <lambdabot> Source not found. I feel much better now.
06:04:03 <Cale> imphasing: The word "monad" refers to the type constructor (along with the definition of return and >>= for it)
06:04:14 <shachaf> The word "monad" is pretty odd. It seems that people hear it and immediately decide that that's what Haskell is about, and come up with a bunch of strange meanings for it.
06:04:15 <Cale> imphasing: Not the values of that type
06:04:22 <shachaf> Either that or there are a lot of misleading guides around.
06:04:29 <dankna> I like to say "monadic action" or just "action" to mean "value in a monad"
06:04:34 <dankna> I dunno if it's standard usage
06:04:37 <Cale> Well, I know there are a lot of misleading guides
06:04:47 <fryguybob> @src Maybe
06:04:48 <lambdabot> data Maybe a = Nothing | Just a
06:04:52 <Cale> But I don't know how many of them people actually read.
06:04:57 <shachaf> dankna: I like to call [1,2,3] an action too. :-)
06:05:00 <dankna> ie, the type constructor "IO" is a monad; applying that type constructor to some specific type foo, "IO foo", is an action
06:05:08 <dankna> shachaf: haha, yeah, that's the problem with it
06:05:12 <mauke> types aren't actions :-|
06:05:14 <Cale> dankna: Values of type IO t are actions
06:05:22 <Cale> Not the type IO t itself :P
06:05:24 <dankna> Cale: that's what I was saying
06:05:34 <dankna> Cale: worded it a little ambiguously
06:05:53 <shachaf> I think one of the biggest confusions Haskell beginners have is between values and types.
06:06:00 <shachaf> Which is kind of odd, because I doubt you get that in e.g. C.
06:06:11 <dankna> yeah, that's an interesting observation actually
06:06:13 <dankna> I think you're right
06:06:15 <shachaf> I guess C has fewer, simpler types.
06:06:20 <hpc> i think it's the unfamiliar notation
06:06:24 <dankna> it took me an age and a half to understand that "type constructor" was even a thing
06:06:29 <dankna> and wasn't the same thing as "data constructor"
06:06:44 <hpc> it took me forever to figure out data declarations
06:06:46 <dankna> C has exactly one type constructor, that being *
06:06:59 <dankna> data declarations never bothered me for some reason
06:07:01 <hpc> data TypeCon TypeParam = DataConstructor Type Type
06:07:12 <dankna> yeah
06:07:22 <hpc> the data constructor in the middle of a bunch of types just totally threw me off
06:07:23 <imphasing> It seems like a data constructor is just a simpler type constructor? Like a type constructor constructs polymorphic types and a data constructor constructs "primitive" single value types?
06:07:32 <dankna> imphasing: not exactly this time
06:07:34 <shachaf> data TypeCon TypeParam where { DataConstructor :: Type -> Type -> TypeCon TypeParam }
06:07:46 <dankna> imphasing: a data constructor, applied to its arguments (which are data), gives a value
06:07:52 <dankna> imphasing: a type constructor, applied to its arguments (which are types), gives a type
06:07:55 <hpc> shachaf: i think that would have helped, honestly
06:07:57 <shachaf> imphasing: A data constructor is just a thing that makes data. A type constructor is a thing that makes a type.
06:07:59 <mauke> dankna: * and [] and ()
06:08:09 <dankna> imphasing: type constructors and data constructors occur in different grammatical contexts
06:08:20 <Cale> data constructors live on the left hand side of :: and type constructors live on the right hand side
06:08:21 <dankna> mauke: oh, you're right
06:08:32 <Cale> values :: types
06:08:58 <imphasing> Ah, so `Maybe Int' would be a type constructor and `Just 1' would be a data constructor?
06:08:59 <Cale> Just and Nothing are examples of data constructors, Maybe is an example of a type constructor
06:09:00 <hpc> shachaf: though it would probably have pushed me down a more OO perspective with stuff like data [] where {[] :: [a], (:) :: a -> [a] -> [a]}
06:09:06 <mauke> far more than you ever wanted to know about C declarations: http://mauke.dyndns.org/stuff/c/how-to-declare.txt
06:09:10 <dankna> they also live in two namespaces, so for example you can have "data () = ()", which promotes confusion
06:09:20 <mauke> imphasing: 'Maybe' is a type constructor, 'Just' a data constructor
06:09:24 <dankna> (well, that one is in the prelude, so you can't, but if it weren't you could)
06:09:41 <imphasing> mauke: Is there a place I can see the definitions of both of them?
06:09:50 <shachaf> @src Maybe
06:09:51 <lambdabot> data Maybe a = Nothing | Just a
06:09:56 <mauke> ^ there
06:09:57 <Cale> dankna: Also, it's not valid syntax
06:09:59 <imphasing> using @src Just didn't work :(
06:10:00 <shachaf> imphasing: That defines three new names: Maybe, Nothing, and Just
06:10:03 <dankna> Cale: yes, also, that :)
06:10:18 <dankna> Cale: but nonetheless () is a type constructor and also () is a data constructor
06:10:25 <dankna> Cale: as special-case syntax :)
06:10:32 <imphasing> shachaf: Is that the definition of Just in that type constructor? Or is Just defined elsewhere?
06:10:45 <shachaf> imphasing: It's defined there.
06:11:12 <dankna> the correct term for the full declaration "data Maybe a = Nothing | Just a" is "data declaration".  the "type constructor" is just the "Maybe" part of it.
06:12:21 <imphasing> So could you make a data constructor, that say, given an int gives you an int incremented by one?
06:12:29 <imphasing> Or is that not part of the data ctor functionality?
06:12:46 <dankna> hmm
06:12:49 <mauke> constructors are, they don't do
06:13:11 <imphasing> But the name sounds so actiony :(
06:13:11 <dankna> all data constructors are functions; not all functions are data constructors.  someone check me on that (I'm worried it's untrue in the case of 0-ary ones).
06:13:17 <shachaf> imphasing: That's just a function. :-)
06:13:22 <mauke> any data constructor that gives you an int would have to be part of the definition of int
06:13:26 <dankna> incrementing by 1 is a function, certainly
06:13:27 <hpc> dankna: all data constructors are values
06:13:29 <shachaf> imphasing: Are you thinking of an OO constructor?
06:13:34 <shachaf> If so, forget that.
06:13:35 <imphasing> shachaf: Yes :(
06:13:36 <dankna> hpc: okay, that's a better way of putting it, thank you
06:14:29 <dankna> yeah, a Smalltalk-style-OO constructor doesn't have an equivalent in Haskell terms
06:14:33 <quicksilver> dankna: if you want to be a scrupulous pedant, there is a canonical value associated with each data constructor, and we give it the same name. However the constructor *is* not that value; the constructor is strictly *more* than just a value.
06:14:49 <dankna> quicksilver: that's a fair way of putting it, yes
06:15:21 <quicksilver> and if you want to be a scrupulous pedant, IRC is your natural home ;)
06:15:38 <imphasing> wait, is a data cunstructor only used with algebraic types?
06:15:47 <hpc> imphasing: it might help if you think of a data constructor as kind of a pattern that a value can take
06:15:52 <dankna> haha yeah, quicksilver
06:16:01 <hpc> imphasing: for example, a list can either be empty, or a thing cons'd onto another list
06:16:09 <dankna> imphasing: no, record types have it too
06:16:16 <hpc> aka, either [] or (value : list)
06:18:30 <tigger_> maybe it has to do with language extensions? http://hpaste.org/51702
06:19:14 <tigger_> sorry, the question was in line 15, where does the variable a come into scope
06:19:59 <mauke> tigger_: newtype Parser a
06:20:02 <quicksilver> tigger_: you got a couple of answers
06:20:07 <quicksilver> tigger_: did you not see them?
06:20:10 <rwbarton> didn't people answer this question already?
06:20:18 <tigger_> oh no, sorry I think my connection was disconnected
06:20:25 <tigger_> is tehre a way to look up history
06:20:27 <rwbarton> it comes into scope the same way x does in "let f x = x^3 in f 5"
06:20:28 <quicksilver> tigger_: line 15 defines a local function "ks'" with a parameter "a"
06:20:42 <quicksilver> tigger_: so that definition brings a into scope (and then uses it almsot immediately)
06:20:52 <quicksilver> like f x = x + 1 brings x into scope and then uses it.
06:20:57 <tigger_> okay gotcha
06:21:31 <Cale> https://sites.google.com/site/gallantlabucb/publications/nishimoto-et-al-2011 -- wow! :)
06:21:32 <tigger_> so it one of the language extensions necessary for that since unless you use a let declartation, the type value isn't clear?
06:23:26 <tigger_> oh nevermind, sorry. I'm such an idiot
06:23:27 <quicksilver> tigger_: don't understand the quesiton? no language extension is involved in function definitions, they are basic
06:23:31 <tigger_> thanks for the help
06:23:33 <quicksilver> :)
06:23:48 <tigger_> haha
06:24:54 <imphasing> Is (,) a data constructor?
06:25:09 <byorgey> imphasing: yes, and it is also a type constructor
06:25:33 <byorgey> or rather, there are two things, one a data constructor and one a type constructor, which both happen to have the name (,)
06:25:48 <imphasing> Ah, ok
06:25:55 <byorgey> Cale: wow, that's pretty cool! and they used Haskell, eh? ;)
06:26:00 <quicksilver> this using the same name for two different things is quite confusing when trying to grasp the fundamentals clearly
06:26:13 <quicksilver> once you get the hang of it, it is quite neat and compact.
06:26:15 <Cale> byorgey: Not that I know of
06:26:25 <Cale> byorgey: But it's cool enough regardless :P
06:26:29 <Axman6> > (,) 1 2
06:26:30 <lambdabot>   (1,2)
06:26:34 <quicksilver> but note that ML made different choices - the type is t * u and the value is (a,b) for example.
06:26:41 <byorgey> Cale: I know, I was just teasing. =)  I agree it's very cool regardless/
06:26:43 <quicksilver> arguably less confusing.
06:26:51 <shachaf> I think overloading parentheses is a bad thing.
06:27:01 <shachaf> Types and values both.
06:28:29 <dankna> it's not an unqualified good thing, but I think it works out
06:28:50 <imphasing> > (,) (Just 1) Nothing
06:28:51 <lambdabot>   (Just 1,Nothing)
06:29:05 <dankna> :k (,)
06:29:07 <lambdabot> * -> * -> *
06:29:12 <shachaf> dankna: I think it causes a lot more bad than good.
06:29:15 <dankna> :t (,)
06:29:16 <lambdabot> forall a b. a -> b -> (a, b)
06:29:28 <imphasing> Why can't I do `(,) $ Just 1 $ Nothing'? :D
06:29:39 <shachaf> imphasing: Because $ is right-associative, sadly.
06:29:40 <dankna> shachaf: well, I'm in sympathy with that sort of reasoning
06:29:59 <dankna> imphasing: you can do (,) (Just 1) (Nothing)
06:30:01 <shachaf> dankna: It's even worse how parentheses are overloaded for application in C.
06:30:01 <imphasing> Oh, I see
06:30:10 <imphasing> That's passing Nothing to Just 1 I guess
06:30:10 <dankna> shachaf: yes, I hate that
06:30:21 <shachaf> imphasing: Yep.
06:30:21 <dankna> imphasing: yes, quite so
06:30:32 <hpc> not as bad as how they are overloaded in perl
06:30:33 <shachaf> imphasing: If $ was the right way around, it would work, though.
06:30:38 <imphasing> Is there a left associative low precedence function application operator?
06:30:47 <dankna> not that I'm aware of
06:30:48 <shachaf> Not unless you define it yourself.
06:30:51 <imphasing> Ah
06:31:19 <shachaf> Cale: That is neat.
06:32:02 <imphasing> Cale: Whoa. That's really cool.
06:32:16 <dankna> it is very cool (I had already heard of it, because I'm so connected~)
06:36:50 <dmwit> Is there a Haskell' proposal for fixing the fixity of ($)?
06:36:59 <shachaf> dmwit: I doubt it.
06:37:00 <shachaf> Cale?
06:37:40 <imphasing> dmwit: wouldn't that break basically... everything?
06:37:51 <imphasing> It would be better to add a different operator I would think
06:38:01 <hpc> imphasing: i think it would only break lines with several ($)s
06:38:10 <dmwit> imphasing: No, it wouldn't break everything.
06:38:12 <parcs> > let ($$) = ($) in (,) $$ Just 1 $$ Nothing
06:38:13 <lambdabot>   (Just 1,Nothing)
06:38:24 <dmwit> imphasing: It would only break code written by people who wrote a $ b $ c instead of the proper a . b $ c
06:38:29 <parcs> hmm that didn't work in ghci
06:38:31 <imphasing> I can imagine there's lots of existing code using lots of $, all that code would stop working I presume
06:38:34 <imphasing> Ah...
06:38:40 <Cale> I would really like there to be
06:38:45 <imphasing> Yeah, I guess function composition makes more sense there
06:38:55 <shachaf> Cale: how is propposal formed
06:39:05 <quicksilver> unfortunately there is a good reason to write a $ b $ c so there is at least some code out there which would break
06:39:11 <dmwit> You need to do way instain wiik!
06:39:44 <dmwit> Really? What's the good reason?
06:39:45 <shachaf> I'm not *completely* convinced about infixl $
06:40:08 <shachaf> It's nice that you can put "blah blah blah $" in front of almost any expression and have it work out.
06:40:12 <imphasing> seems like the idea is to reduce paren nesting, which it does
06:40:21 <shachaf> Rather than worry about whether it already has a $ in it, and if so you should use ., and otherwise not.
06:40:46 <shachaf> imphasing: The idea is that you could reduce it even more if it was infixl, because of things like (,) $ Just 1 $ Nothing
06:40:55 <quicksilver> dmwit: code like withMemoryManagement $ withWindowing $ \w -> withFudgets $ withBadgets $ do {.....}
06:41:06 <shachaf> Whereas if you want to say a b (c d (e f g)), you can just say a b . c d . e f $ g
06:41:22 <shachaf> quicksilver: I typically use a . there.
06:41:23 <parcs> (,) $ Just 1 $ Nothing is a bad example
06:41:29 <dmwit> quicksilver: What's wrong with withMemManage . withWind $ \w -> withFudg . withBadgets $ do
06:41:39 <parcs> it's no worse than (,) (Just 1) Nothing
06:41:39 <quicksilver> dmwit: you need a $ whenever the lambda comes up
06:41:47 <dmwit> quicksilver: fixity doesn't apply there
06:41:52 <quicksilver> and it's quite annoying having to switch betweem $ and . when you see lambda
06:42:27 <shachaf> It's what I typically do anyway.
06:42:39 <shachaf> I've grown to like $ less and less more the I've used Haskell.
06:42:40 <dmwit> Okay. I'm not convinced, but I can understand that other people have different preferences than me.
06:42:48 <shachaf> More than one in a row almost always feels bad.
06:42:55 <rwbarton> I actually like having the choice between f . g $ x and f $ g $ x, sometimes f . g just doesn't feel like a "unit" to me
06:42:59 <rwbarton> depending on the context
06:43:11 <parcs> $ is only truely useful when delimiting do
06:43:15 <shachaf> rwbarton: I suspect that's an acquired taste. :-)
06:43:23 <rwbarton> really?
06:43:26 <rwbarton> I think quite the opposite
06:43:31 <hpc> parcs: and trailing lambdas
06:43:36 <quicksilver> I prefer (.) almost always
06:43:37 <imphasing> > \x -> x + 1 . \x -> x + 2 $ 1
06:43:38 <lambdabot>   Overlapping instances for GHC.Show.Show
06:43:38 <lambdabot>                              (((a -...
06:43:39 <hpc> foo $ \x -> ...
06:43:39 <parcs> hpc: yeah
06:43:40 <shachaf> Hmm, fair enough.
06:43:40 * byorgey often writes code using an unholy mixture of $ and ., then later goes back and pretties it up
06:43:42 <imphasing> :(
06:43:55 <quicksilver> but the lambda/do argument vaguely convinces me that just doing a switch wouldn't be simple
06:44:01 <imphasing> > (\x -> x + 1) . (\x -> x + 2) $ 1
06:44:02 <lambdabot>   4
06:44:06 <imphasing> hmpf
06:44:10 <rwbarton> for instance, I often write forever $ ... and runST $ ... so why should I not write forever $ runST $ ...
06:44:24 <shachaf> rwbarton: I guess things like "zip [1..]" feel unnaturally split up when using (.)
06:44:48 <shachaf> It depends on how much you view $ as syntax, maybe.
06:44:54 <hpc> shachaf: in that case i would let something = ... in zip [1..] something
06:45:09 <hpc> if the inner thing is more a unit than f . g, give it a name
06:45:13 <shachaf> hpc: That's way overkill.
06:45:18 <shachaf> In many cases, anyway.
06:45:29 * shachaf must really >>= undefined, though.
06:45:36 <shachaf> Good luck forming propposal.
06:45:51 * cheater shachaf >>= undefined.
06:47:41 <parcs> > let id = (>>=) (=<<) (=<<) const in id 42
06:47:42 <lambdabot>   42
06:47:50 <BobFunk> anyone know if theres an easy way to output an Data.Bson Document as json ?
07:03:09 <Cale> I never chain $'s together, always f . g . h $ x style or explicit parens.
07:05:03 <Axman6> there are times when using multiple $'s seems to make sense, like when you're doing something like forkIO $ a . b . c $ x
07:05:03 <Axman6> but, that's just me
07:07:12 <Cale> I'll still use (.) there
07:08:56 <rwbarton> Axman6: yeah, good example
07:08:57 <Entroacceptor> (.) f g $ x?
07:09:17 <Axman6> now you're just being ridiculous :P
07:10:03 <quicksilver> Cale: what about forkWithThreadId $ \tid -> a . b . c $ x
07:10:16 <Cale> That's not an instance of chaining $
07:10:19 <quicksilver> Cale: (for some invented primitive but the pattern is realistic enough)
07:10:25 <quicksilver> right, it's not.
07:10:33 <quicksilver> but you'd still do it?
07:10:33 <Cale> (and it seems fine to me)
07:10:34 <Cale> yeah
07:10:37 <quicksilver> OK
07:10:41 <geheimdienst> so, i notice cabal installed "directory-1.1.0.0" in ~/.cabal, while ghc-pkg says exactly that is already installed in /usr/something. any ideas?
07:10:44 <quicksilver> well the argument is that, by analogy with that
07:11:10 <quicksilver> it's annoying to switch between $ and . depending on whether your construct takes a fresh parameter
07:11:21 <parcs> geheimdienst: if it ain't broke don't fix it :P
07:11:23 <Cale> Not that annoying...
07:11:33 <quicksilver> can't say it bothers me hugely but there it is
07:11:39 <Saizan> geheimdienst: does ghc-pkg list two of them?
07:11:55 <geheimdienst> saizan: yeah. one global, one user
07:12:22 <Saizan> geheimdienst: unregister the user one before it's too late
07:12:24 <Cale> It's a very different meaning too
07:12:41 <Saizan> geheimdienst: assuming it's the same exact version
07:12:52 <Saizan> @google sicp cabal
07:12:54 <lambdabot> http://www.vex.net/~trebla/haskell/sicp.xhtml
07:13:01 <Saizan> in case you haven't read it ^^^
07:13:05 <hpc> why does cabal have separate global and user repos, if it's just going to cause trouble?
07:13:30 <geheimdienst> okay, will uninstall the user one
07:14:59 <Saizan> hpc: it's ghc itself that has them, but the idea is that you don't need root privileges to install in the user db, also you can't screw your global packages if you only do that
07:15:38 <hpc> ah
07:16:34 <Saizan> it also wouldn't cause as much trouble if cabal were fixed to deal better with abi hashes
07:16:55 <rwbarton> I don't know how to explain it beyond giving examples, but somehow 'sum . map read . words $ str' and 'forkIO $ forever $ putStrLn $ "You wrote: " ++ str' feel different to me
07:17:12 <rwbarton> of course fmap and (.) also feel different to me, so it's no wonder Cale would disagree
07:17:20 <armlesshobo> hmmm...hFlush stdout doesn't fix my issue with the first line of text not printing out when I compile my haskell program
07:17:54 <Cale> forkIO . forever . putStrLn  is a perfectly good function :)
07:18:24 <armlesshobo> if a newline char isn't output, it doesn't show
07:18:28 <rwbarton> it is not a unit in how I perceive the program 'forkIO $ forever $ putStrLn $ "You wrote: " ++ str'
07:18:33 <rwbarton> so I do not write it that way
07:20:47 <rwbarton> it's as unnatural to me as writing (\f -> forkIO $ f $ putStrLn $ "You wrote: " ++ str) forever
07:22:30 <c_wraith> rwbarton: My interpretation of that is that you don't believe functions that take and return monadic values are real functions.
07:23:16 <rwbarton> what?
07:23:32 <copumpkin> :O
07:23:38 <copumpkin> how are they not functions?
07:23:38 <rwbarton> it has nothing to do with that
07:24:29 <rwbarton> the point is that in f (g (h x)), it may or may not make sense to abstract over f, g, h, or x
07:25:00 <rwbarton> in the former example, it seems to make a lot of sense toabstract over x, so f . g . h $ x is good notation
07:26:51 <c_wraith> you really think abstracting over forkIO . forever doesn't make sense?
07:27:10 <c_wraith> That's a *really* common use of forkIO
07:27:21 <rwbarton> in a particular context, it may not
07:27:43 <geheimdienst> hmm ... what makes cabal disregard global packages? my original problem was i said "cabal install fix-imports", and it decided it needed to put (among others) directory, haskell98, and process in ~/.cabal. the versions it put there are exactly what ghc-pkg lists as present in /usr
07:27:43 <erus`> :t LiftA2
07:27:44 <lambdabot> Not in scope: data constructor `LiftA2'
07:27:55 <erus`> :t liftA2
07:27:56 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
07:28:14 <rwbarton> Honestly I find it odd that this is controversial, so probably I'm just not explaining myself very well.
07:28:17 <c_wraith> geheimdienst: they may be the same versions, but built against a different dependency.  check their abi hash
07:28:24 <erus`> :t liftA3
07:28:25 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
07:28:29 <erus`> good old lift
07:28:31 <geheimdienst> c_wraith: oh, right, good point
07:28:36 <quicksilver> rwbarton: I think your point of view makes sense (although I don't particularly agree with it)
07:28:59 <quicksilver> rwbarton: I certainly don't object to you holding it :)
07:29:18 <Saizan> geheimdienst: you probably have upgraded some dependency of those and cabal is constructing an install plan that picked that so it has to rebuild them against the upgraded dependency
07:29:44 <rwbarton> Okay, right, and I'm not claiming this is a particularly major thing, just that I would feel minorly inconvenienced by not being able to express this if $ had the other associativity.
07:30:16 <Saizan> geheimdienst: btw, cabal install ... --dry-run -v gives more details of the choices
07:30:49 <geheimdienst> yeah, i'm definitely doing that more now, instead of just blindly installing :)
07:31:25 <c_wraith> I almost never install something without --dry-run checking first
07:31:30 <c_wraith> cabal just likes to break things
07:31:33 <rwbarton> (or at least, I'd have to use more parentheses to do so)
07:32:30 <Saizan> citing sicp, there's a "promiscuous upgrading whore" in cabal :)
07:33:03 <Saizan> but it can only be triggered by a forced upgrade in the past
07:41:13 <geheimdienst> aha. i think i found the initial trigger for the whore ... filepath-1.2.0.1 was in user, with filepath-1.2.0.0 in global. it therefore thought "omg new filepath, i need to reinstall directory and all kindsa things"
07:41:42 <erus`> @hoogle (a -> b -> m c) -> m a -> m b -> m c
07:41:43 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
07:41:43 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
07:41:43 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:43:30 <erus`> liftA2 isnt like bind
07:43:38 <erus`> is there a bind2 ?
07:44:05 <Botje> what would bind2 look like?
07:44:29 <erus`> (a -> b -> m c) -> m a -> m b -> m c   like that?
07:45:07 <quicksilver> erus`: I answered this for you a few hours ago.
07:45:13 <quicksilver> you use >>= twice.
07:45:20 <erus`> with lambdas ?
07:45:23 <quicksilver> but most people tend to use monad notation when using more than one >>=
07:45:35 <Botje> bind2 f ma mb = ma >>= \a -> mb >>= \b -> f a b
07:45:44 <quicksilver> yes, exactly what Botje wrote
07:45:55 <Botje> or you do join (liftM2 f a b)
07:46:11 <quicksilver> but most people would probably write do { a <- ma; b <- mb; f a b}
07:46:18 <erus`> ah liftM2
07:46:27 <quicksilver> erus`: the critical part is the join, though.
07:46:31 <quicksilver> liftM2 isn't what you asked for.
07:46:40 <erus`> quicksilver: i need to make sure and b arnt mzero/left
07:46:48 <quicksilver> Botje: for some reason I don't like join and I never tend to choose solutions using it :)
07:46:57 <quicksilver> erus`: no you don't, the monad does that automatically.
07:47:10 <erus`> what in the do?
07:47:11 <quicksilver> the whole point about those things is you don't have to worry about them :)
07:47:18 <Botje> liftM2 f a b >>= id -- /me ducks
07:47:46 <quicksilver> erus`: Yes. That is the point of mzero-type monads. It is automatically propogated by the do.
07:47:55 <erus`> @undo do { a <- Nothing }
07:47:55 <lambdabot>  Parse error at "}" (column 19)
07:48:03 <matthiasgorgens1> @pl safeReadProcess p xs i = from =<< readProcess' p xs i
07:48:03 <lambdabot> safeReadProcess = (((from =<<) .) .) . readProcess'
07:48:26 <quicksilver> > (Left "problem") >>=\a -> (Right "fine) >>= \b -> return (a,b)
07:48:27 <lambdabot>   <no location info>: parse error on input `->'
07:48:32 <quicksilver> > (Left "problem") >>=\a -> (Right "fine") >>= \b -> return (a,b)
07:48:33 <lambdabot>   <no location info>: parse error on input `->'
07:48:40 <quicksilver> > (Left "problem") >>= \a -> (Right "fine") >>= \b -> return (a,b)
07:48:41 <lambdabot>   Overlapping instances for GHC.Base.Monad
07:48:41 <lambdabot>                              (Data...
07:48:44 <quicksilver> !
07:48:48 <quicksilver> stupid lambdabot :-(
07:48:50 <matthiasgorgens1> @pl safeReadProcess p xs i = from <=< readProcess' p xs
07:48:50 <lambdabot> safeReadProcess = ((const . (from <=<)) .) . readProcess'
07:48:53 <quicksilver> the answer is Left "problem" anyhow.
07:49:21 <hpc> > Left "oh crap" >> Right "yay?" >> return ()
07:49:22 <lambdabot>   Overlapping instances for GHC.Base.Monad
07:49:23 <lambdabot>                              (Data...
07:51:37 <erus`> wow monad notation :)
07:51:42 <erus`> who knew...
07:52:24 <rwbarton> So I'm trying to install repa-devil with ghc 7.2, but repa-devil requires repa 2.0.*, which requires template-haskell 2.5.*, but ghc 7.2 comes with template-haskell 2.6.*, and template-haskell 2.5.* won't build.
07:52:36 <erus`> i love haskell so much i want to cry
07:52:42 <rwbarton> Any suggested course of action?
07:53:18 <rwbarton> do people usually just locally edit the .cabal file to relax a version constraint (like allow repa-devil to use repa 2.2.*) here?
07:53:58 <quicksilver> it's a reasonable thing if you understand what's going on rwbarton
07:54:07 <rwbarton> Yeah, I really don't :P
07:54:19 <quicksilver> without knowing the packages involved I'd expect the repa-devil <=> repa dependency to be the strong one
07:54:25 <rwbarton> I assume trying to get TH 2.5.* is a bad direction to go in, though?
07:54:28 <quicksilver> I *expect* TH-2.6 is back compat with TH-2.5
07:54:40 <quicksilver> so I'd try fixing the deps in repa 2.0
07:54:47 <quicksilver> and forcing repa 2.0 to compile with TH-2.6
07:54:48 <quicksilver> make sense?
07:55:01 <rwbarton> oh I see
07:55:59 <quicksilver> however, repa is tied to dph and dph is pretty tied to specific GHC versions
07:56:03 <quicksilver> so you may well be onto a loser.
07:56:12 <quicksilver> I revise my initial guess.
07:56:16 <Axman6> repa is tied to dph?
07:56:20 <rwbarton> Perhaps repa 2.2 is much better though... and the repa <2.1 constraint is possibly just because that was the latest version at the time, no?
07:56:34 <quicksilver> I would guess your best bet is to see if repa-devil will compile with the latest (everything else)
07:56:44 <quicksilver> Axman6: repa uses DPH
07:56:50 <quicksilver> doesn't it?
07:56:52 <Axman6> are you sure?
07:56:55 <Axman6> i don't think it does
07:57:09 <Axman6> i don't remember it doing so at least the last time i looked at the source code, i could be wrong
07:57:15 <rwbarton> I'm pretty sure there is some kind of relation between them
07:57:18 <quicksilver> I was tipped off by "Author The DPH Team"
07:57:24 <Axman6> the research is related, but it doesn't use DPH
07:57:27 <quicksilver> but also "Functions written with the Repa combinators are automatically parallel"
07:57:45 <Axman6> I don't think it uses DPH for the parallelism though
07:58:09 <rwbarton> is there some command-line way I can tell cabal to relax the version dependency of repa-devil on repa?
07:58:16 <quicksilver> rwbarton: I don't think so.
07:58:21 <quicksilver> I think you have to download it and modify the file
07:58:28 <quicksilver> Axman6: http://pls.posterous.com/?tag=dph
07:58:35 <quicksilver> Axman6: describes repa as a "companion package" to dph
07:58:44 <copumpkin> oh man, rwbarton is playing with repa
07:58:47 <copumpkin> but has he seen DERPA
07:59:35 <rwbarton> no
07:59:39 <Saizan> rwbarton: nope, just cabal unpack
07:59:50 <copumpkin> rwbarton: http://github.com/copumpkin/derpa !!
07:59:54 <Axman6> "In contrast to the DPH libraries, which enable nested data parallelism, Repa implements parallel, shape-polymorphic, regular multi-dimensional arrays."
08:00:22 <rwbarton> Saizan: is that the same as tar xzvf .cabal/packages/hackage.haskell.org/repa-devil/.......tar.gz?
08:00:49 <Saizan> rwbarton: yes + downloading the package if it's not already there
08:01:01 <rwbarton> ah, neat
08:01:30 <rwbarton> Well, it seems to work so far (i.e., it built)
08:01:49 <dolio> Text.Derp
08:01:54 <rwbarton> copumpkin: is the idea to translate it back to haskell eventually?
08:02:08 <rwbarton> once type-level nats are more of a thing
08:02:25 <copumpkin> rwbarton: nope
08:02:30 <Saizan> btw, what is a shape in repa terminology?
08:02:57 <copumpkin> rwbarton: it's just to see what we could do if we had full dependent types for this stuff
08:03:04 <copumpkin> Saizan: a shape?
08:03:12 <alpounet> yeah like in "shape polymorphic"
08:03:24 <Saizan> yeah
08:03:24 <copumpkin> Saizan: oh, repa kind of conflates index and shape because haskell can't discriminate between the concepts
08:03:26 <alpounet> always wondered too
08:03:34 <copumpkin> at least from derpa's perspective
08:03:57 <copumpkin> a shape is basically a list of naturals that specify your dimensions
08:05:31 <Saizan> mh, i guess they mean their array types are not indexed only by the type of indexes but by the size of each dimension too?
08:06:10 <rwbarton> they're not though, the only type-level information is the number of dimensions
08:06:12 <copumpkin> well, on the type-level, you only know the number of dimensions
08:06:22 <copumpkin> in derpa you get it all, of course
08:06:29 <MichaelBurge> Why does Set have the Ord constraint?
08:06:48 <copumpkin> MichaelBurge: you can't find elements efficiently without it
08:07:05 <matthiasgorgens1> Is it possible to remove the points from
08:07:07 <matthiasgorgens1> safeReadProcess p xs i = from =<< readProcess' p xs i where
08:07:07 <matthiasgorgens1>   from (Just r) = return r
08:07:07 <matthiasgorgens1>   from Nothing  = error $ "command: p FAILED."
08:07:14 <matthiasgorgens1> With Control.Applicative?
08:07:46 <matthiasgorgens1> (We can replace the =<< with an fmap easily.)
08:08:01 <shachaf> Wait, you're calling a function "safeReadProcess" when it replaces Maybe with error?
08:08:30 <copumpkin> then you wrap it in spoon
08:08:32 <copumpkin> duh
08:09:13 <matthiasgorgens1> shachaf, oh, in the real code there's a good error message in the Nothing part.
08:09:29 <matthiasgorgens1> but you are right, I should talk to my co-worker about the naming.
08:09:32 <shachaf> I don't *think* that's what people usually mean by "safe".
08:09:50 <geheimdienst> safeLaunchMissiles
08:10:28 <shachaf> safePerformIO
08:10:29 <matthiasgorgens1> Oh, he gave me a good enough reason.
08:10:29 <ben> safePerformIO?
08:10:32 <ben> fffff
08:10:41 <matthiasgorgens1> safePerformIO :: IO a -> Maybe a
08:11:06 <shachaf> extraSafe :: Maybe a -> Maybe (Maybe a)
08:11:50 <copumpkin> purify :: IO a -> a
08:12:14 <imphasing> hah
08:12:25 <shachaf> impurify :: IO a -> IO
08:12:25 <matthiasgorgens1> copumpkin, no we already have pure :: a -> f a
08:12:27 <copumpkin> that's actually taken from a real haskell library
08:12:31 <matthiasgorgens1> for some functor f.
08:12:43 <shachaf> copumpkin: Which one?
08:12:48 <copumpkin> not gonna say :)
08:12:51 <copumpkin> but it's a weird one :)
08:13:00 <matthiasgorgens1> An Applicative one.
08:13:03 <ben> ... is it the spoon one?
08:13:23 <copumpkin> no
08:13:35 <matthiasgorgens1> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=purify
08:13:58 <matthiasgorgens1> there are at least two occurence of the name with the right type.
08:13:59 <copumpkin> matthiasgorgens1: thanks for helping me be discreet
08:14:24 <matthiasgorgens1> You're welcome.
08:14:45 <geheimdienst> "mps package -- DSL that allows one to write Haskell from left to right" <- wha?
08:14:58 <shachaf> purify :: IO a -> a; purify = const undefined
08:15:02 <matthiasgorgens1> ok, it seems we have an alternative definition of the safe... prefix here.
08:15:16 <matthiasgorgens1> geheimdienst, who would do such a thing.
08:15:27 <parcs> they're both by the same author
08:15:29 <ben> ghc extension to mage the RTL text control character a valid operator? :V
08:15:52 <lispy> http://corp.galois.com/haskell-course  <-- tell your friends
08:16:17 <geheimdienst> matthiasgorgens1: i dunno *shrug* i thought we are already writing it left-to-right
08:16:22 <matthiasgorgens1> Haskell programmers have friends?
08:16:50 <copumpkin> yes
08:17:05 <ben> geheimdienst: I figured it was gonna contain flip (.) or flip ($) or something
08:24:34 <lispy> matthiasgorgens1: haskell helps you make friends!
08:24:36 <lispy> :)
08:25:14 <imphasing> That's probably true
08:25:29 <imphasing> You all seem to care about learning cool new stuff as much as I do :D
08:25:36 <matthiasgorgens1> So Lisp is the purer function programming language after all.
08:27:20 <Axman6> eh?
08:27:32 <Axman6> how do you figure that?
08:27:48 <dankna> imphasing, I agree :)
08:28:03 <imphasing> Axman6: Because haskell is hard and you have to care to learn it, probably
08:28:06 <Axman6> can't you arbitrarilly perform IO in functions in lisp?
08:28:07 <matthiasgorgens1> Lisp does a better job of keeping you from the impurity of other humans. ;o)
08:28:18 <jacobian> It's made from unadulterated distilled lambda-juice.
08:28:20 <imphasing> oops, thought that was at me :)
08:28:21 <Axman6> bah
08:28:59 <matthiasgorgens1> OK, the Haskell community seems in general nicer than the Common Lisp guys.
08:29:07 <dankna> the CL people aren't non-nice
08:29:08 <copumpkin> matthiasgorgens1: no no, we hate you
08:29:10 <dankna> but they aren't as nice
08:29:23 <copumpkin> matthiasgorgens1: don't let our superficial niceness fool you!
08:29:24 <matthiasgorgens1> Thanks, you restore my fate in computer science.
08:29:26 <dankna> and we have more libraries for practical tasks :)
08:29:34 <copumpkin> we're here to make you feel terrible about yourself and to correct your questions without answering them
08:29:36 <Axman6> but we hate you like good christians are supposed to, we help you be less hateworthy
08:29:40 <dankna> I was a CLer for like five years
08:30:05 <matthiasgorgens1> the language is mostly fine.
08:30:13 <dankna> yeah, although I do agree with static typing
08:31:28 <quicksilver> however CL certainly isn't particularly pure
08:31:37 <quicksilver> at least, the language makes no attempt to help you keep your functions pure.
08:31:47 <matthiasgorgens1> No.  But it's a nice imperative language with functional features.  Like Python.
08:32:02 <EvanR-work> the only nice imperative language ive ever seen is haskell
08:32:17 <copumpkin> "functional features"
08:32:25 <dankna> yes, exactly - CL is about as nice as a language can possibly be without having a good typesystem :)
08:33:05 <EvanR-work> it escapes me why people think python is good and php isnt
08:33:08 <erus`> too many braces
08:33:11 <EvanR-work> they are basically isomorphic
08:33:26 <EvanR-work> guess it comes down to syntax
08:33:30 <erus`> people are going off python now :)
08:33:44 <Axman6> pythhon has less ugly
08:33:49 <copumpkin> and library naming
08:33:49 <copumpkin> mm
08:33:59 <erus`> Axman6: __main__   __str__
08:34:04 <erus`> yummm
08:34:09 <c_wraith> EvanR-work: a lot of it is culture.  PHP has a culture of "bad programming by copy & paste is the key to success".  Python is...  a bit better than that.
08:34:28 <Axman6> Hello <? something PHPy here ?> world
08:34:43 <Axman6> i dunno, i just find all php code i see to be ugly
08:34:48 <EvanR-work> c_wraith: a bit?
08:35:00 <EvanR-work> Axman6: it is
08:35:07 <lispy> I like what bos said about haskell in his recent talk
08:35:10 <matthiasgorgens1> Python has a working parser.  PHP doesn't.
08:35:17 <lispy> that it can be a helpful filtering criteria
08:35:30 <franny> PHP has awful error handling, and an awful approach to libraries (everything is a global function).
08:35:30 <Axman6> matthiasgorgens1: neither does perl
08:35:46 <quicksilver> EvanR-work: python has much better standard library, and libraries in general. It has slightly nicer syntax and a few neat features.
08:35:47 <matthiasgorgens1> I was bitten by this once: I started out with "a = my_function(); b = a[1];"
08:35:52 <matthiasgorgens1> and transformed that to:
08:36:01 <quicksilver> EvanR-work: combining all four together it is substantially nicer to use in practice.
08:36:02 <dankna> actually CL's exception system is one of the big things I think Haskell should imitate about it (that we haven't already)
08:36:07 <matthiasgorgens1> b = my_function()[1];
08:36:12 <matthiasgorgens1> guess what kill the parser?
08:36:12 <dankna> it's worth reading up on to see a totally different take on exceptions
08:36:18 <matthiasgorgens1> and gives you a very unhelpful error message?
08:36:33 <franny> I haven't used PHP in a few years, but at least as late as a few years ago it also had virtually no Unicode support; everything was a bytestring.
08:36:37 <dankna> "restarts" - places to resume execution at - are first-class, and distinct from "handlers" - code that runs when exceptions are thrown
08:36:44 <EvanR-work> quicksilver: neat features, in a web lang, makes me suspicious
08:36:51 <matthiasgorgens1> axman6, Perl is also evil. ;o)
08:37:13 <quicksilver> EvanR-work: erm I was talking about python. Python is not a web lang.
08:37:16 <franny> Also, PHP 5.3 introduced goto. D:
08:37:32 <erus`> does perl have closures?
08:37:35 <EvanR-work> quicksilver: overruled
08:37:39 <quicksilver> erus`: yes. Always has.
08:41:50 <erus`> does clojure have closures?
08:42:02 <erus`> i hope it doesnt
08:43:08 <c_wraith> a lisp without closures doesn't make much sense. :)
08:43:49 <dolio> You mean, like the original lisps?
08:44:40 <c_wraith> and I bet people thought they made so much more sense when closures were added.
08:44:54 <c_wraith> Except the ones who bemoaned the extra execution overhead, of course :)
08:45:16 <dolio> Dynamic scoping is way better. That's why I only use elisp.
08:45:35 <companion_cube> having both is even better
08:46:22 <c_wraith> how do you have both?  special syntax on free variables that indicates where to look them up?  Heh, just like haskell has.  Ok dumb question :)
08:46:46 <jacobian> CL has both
08:46:55 <companion_cube> clojure also has both, afaik
08:47:14 <companion_cube> and it seems very cool for global vars that are not so global, like stdout
08:47:37 <jacobian> yeah, that's a common CL trick
08:50:27 <mamalujo> dolio: isn't elisp supposed to abandon dynamic scoping? I think w 24 its optional.
08:51:05 <jacobian> local scoping is definitely is a better default position
08:51:40 <buntfalke> @source seq
08:51:41 <lambdabot> seq not available
08:51:48 <buntfalke> @Source seq
08:51:49 <lambdabot> seq not available
08:51:52 <mamalujo> hm, it won't be a default yet. "To use lexical binding, an Emacs-lisp source file must set a file-variable `lexical-binding’ to t in the file header, To use lexical binding, an Emacs-lisp source file must set a file-variable `lexical-binding’ to t in the file header, "
08:51:56 <c_wraith> seq is magical.  it doesn't have haskell source
08:52:04 <buntfalke> oO
08:52:10 <mamalujo> sry, doubleclick
08:56:17 <buntfalke> c_wraith: As in, it's not possible to define seq in Haskell without using seq itself?
08:56:41 <buntfalke> It needs to be a hardcoded in the compiler?
08:56:48 <lispy> buntfalke: it is possible up to polymorphism
08:56:49 <c_wraith> buntfalke: you can define it for any particular algebraic datatype yourself.  You can't define it for *all* types at once.
08:56:53 <hpc> buntfalke: or bang patterns, which desugar to seq, which...
08:57:00 <benmachine> buntfalke: right (or things equivalent to seq, like bang patterns or strict fields)
08:57:09 <benmachine> c_wraith: you can't define it for functions at all
08:57:21 <benmachine> only seq can tell the difference between undefined and const undefined
08:57:22 <c_wraith> benmachine: sure you can.  It's id
08:57:36 <lispy> IMO, the function definition could be to make the parameters strict, eg., apply bang patterns
08:57:36 <benmachine> c_wraith: nope.
08:57:37 <c_wraith> oh, that.  right.
08:57:49 <benmachine> > seq (undefined :: a -> b) ()
08:57:50 <lambdabot>   *Exception: Prelude.undefined
08:57:55 <benmachine> > seq (const undefined :: a -> b) ()
08:57:56 <lambdabot>   ()
08:58:01 <c_wraith> benmachine: but note that I said *algebraic* data types.  functions are not algebraic.
08:58:23 <benmachine> c_wraith: what you said wasn't wrong, but needed clarification, imo
08:58:28 <c_wraith> fair enough
08:58:42 <buntfalke> Hmm.
09:00:31 <Clint> how do i import an instance declaration to a ghc -e one-liner?
09:01:13 <lispy> Clint: I don't think you can unless you ';' in valid there to separate lines
09:01:16 <c_wraith> hah.  http://i.imgur.com/D4QEO.png is prety awesome
09:01:59 <Clint> hmm
09:02:20 <benmachine> c_wraith: welcome to peano arithmetic
09:03:12 <benmachine> now go and define Integer = (Bool,Nat) and Rational = (Integer,Integer) and then Real = Stream Rational (or something)
09:03:29 <lispy> benmachine: I thnk it's the google translate that's funny there
09:03:29 <c_wraith> benmachine: the point was more the language guess from chrome
09:03:38 <benmachine> ohh
09:03:42 <benmachine> I missed that entirely :P
09:11:36 <buntfalke>  > show $ fst (1,undefined)
09:11:53 <buntfalke>  > fst (1,undefined)
09:11:59 <buntfalke> :-(
09:12:28 <buntfalke>  > x = fst (1,undefined)
09:12:41 <buntfalke>  > x = fst (1,undefined) ()
09:12:43 <buntfalke>  > x = fst (1,undefined); x
09:12:45 <buntfalke> ...
09:16:07 <erus`> when do you know to prune the cached results when using call by need?
09:16:48 * hackagebot bitspeak 0.0.3 - Proof-of-concept tool for writing using binary choices.  http://hackage.haskell.org/package/bitspeak-0.0.3 (MauricioAntunes)
09:16:50 * hackagebot gtk2hs-rpn 0.2.1 - Adds a module to gtk2hs allowing layouts to be defined using  reverse polish notation.  http://hackage.haskell.org/package/gtk2hs-rpn-0.2.1 (MauricioAntunes)
09:18:19 <hpaste> buntfalke pasted “Why is the lazy pattern needed?” at http://hpaste.org/51703
09:18:20 <Axman6> buntfalke: no space:
09:18:23 <Axman6> > 1 + 1
09:18:25 <lambdabot>   2
09:18:42 <buntfalke> Axman6: thanks
09:19:10 <armlesshobo> I don't know how to ask this, but I'm trying to use the -fllvm flag with ghc, and it complains that the flag is unrecognised.
09:19:11 <buntfalke> I don't get why I should ever end up in a loop here, as, after all, I just "take 5"?
09:19:19 <armlesshobo> so, is the -fllvm flag a newer addition?
09:20:18 <parcs> armlesshobo: where did you get your ghc from?
09:20:28 <parcs> and yeah it's a relatively new addition
09:21:07 <alpounet> armlesshobo, what's your version of ghc ? (ghc --version)
09:21:19 <armlesshobo> 6.12.3
09:21:22 <armlesshobo> alpounet: ^
09:21:34 <armlesshobo> parcs: i got it from the haskell.org site
09:21:39 <buntfalke> armlesshobo: "It was merged into GHC Head around May of 2010 and has been included in GHC since the 7.0 release." Source: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM
09:21:42 <alpounet> the llvm backend wasn't in ghc at that time
09:21:56 <alpounet> well, it was available as a "patch"
09:21:56 <armlesshobo> yeah, that's what I figured :S
09:22:03 <alpounet> but i strongly advise you to get a newer GHC
09:22:13 <alpounet> there's been quite some improvements since then anyway
09:22:20 <armlesshobo> alpounet: unfortunately I can't
09:22:32 <buntfalke> Wise suggestions for my hpaste, anyone? :-)
09:22:42 <alpounet> what's the problem armlesshobo ?
09:23:03 <armlesshobo> alpounet: i'm learning about the ghc compiler and I wanted to try out the different flags
09:23:15 <armlesshobo> alpounet: learn more about the compiler's bevahior
09:23:36 <armlesshobo> plus, there's a small error on the webpage
09:23:41 <alpounet> why can't you do this with a newer version ?
09:24:06 <armlesshobo> alpounet: because my system doesn't meet all of the dependencies
09:27:30 <parcs> what exactly are you missing?
09:28:20 <buntfalke> > show $ fst (1,undefined)
09:28:21 <lambdabot>   "1"
09:28:58 <buntfalke> > let f=1:f in show (take 1 f, take 1 f)
09:28:59 <lambdabot>   "([1],[1])"
09:30:12 <rostayob> buntfalke: yes, haskell is still lazy today :)
09:30:32 <buntfalke> > let { f=1:g; g=(take 1 f)+1 in show (take 1 f, take 1 g)
09:30:33 <lambdabot>   <no location info>: parse error on input `in'
09:30:37 <buntfalke> > let { f=1:g; g=(take 1 f)+1 } in show (take 1 f, take 1 g)
09:30:38 <lambdabot>   No instance for (GHC.Num.Num [a])
09:30:38 <lambdabot>    arising from a use of `f' at <interact...
09:30:57 <buntfalke> > let { f=1:g; g=(take 1 f)+1 } in show (take 1 f, take 1 [g])
09:30:58 <lambdabot>   No instance for (GHC.Num.Num [a])
09:30:58 <lambdabot>    arising from a use of `f' at <interact...
09:31:05 <buntfalke> Grml
09:31:22 <buntfalke> rostayob: Just trying to figure out why I need the lazy pattern in this http://hpaste.org/51703
09:34:03 <parcs> buntfalke: what happens if you remove it?
09:34:51 <rostayob> buntfalke: well in let patterns are always lazy anyway
09:34:57 <rostayob> in let and where
09:35:04 <rostayob> you need them in function declarations and lambda
09:35:17 <rostayob> basically lazy patterns dont force evaluation
09:36:01 <rostayob> f (x, y) = if x then "foo" else y will throw undefined if called like this: f (True, undefined)
09:36:33 <buntfalke> parcs: output is "<<< loop >>>"
09:36:38 <rostayob> while with lazy patterns it won't
09:36:48 <bd_> > let f (x, y) = if x then "foo" else y in f (True, undefined)
09:36:49 <lambdabot>   "foo"
09:36:49 <rostayob> can't find the alias on this keyboard :|
09:36:55 <bd_> > let f (x, !y) = if x then "foo" else y in f (True, undefined)
09:36:56 <lambdabot>   "*Exception: Prelude.undefined
09:37:06 <rostayob> bd_: yep exactly, in let clauses they're lazy
09:37:31 <parcs> buntfalke: you probably have an error in your logic
09:37:39 <kaboodle> @pl \n -> let s = show n in elemIndex s . sort . permutations $ s
09:37:40 <lambdabot> (elemIndex `ap` (sort . permutations)) . fix . const . show
09:37:51 <rostayob> > let f = \(x, y) -> if x then "foo" else y in f (True, undefined)
09:37:52 <lambdabot>   "foo"
09:37:58 <rostayob> oh.
09:38:28 <buntfalke> parcs: No, works quite well if lazy. It's meant to examplify irrefutable patterns, so if, the error is intentional ;-)
09:39:08 <rwbarton> the lazy pattern allows client to "produce" a (:) constructor before "consuming the (:) constructor in its second argument
09:39:15 <buntfalke> rostayob: That's cause it only eveluates the pattern to whnf, and doesnt care about the actualy components imho
09:39:47 <buntfalke> rwbarton: /me goes think about that
09:40:20 <rwbarton> it might help to write out the version with a ~ in terms of head and tail, and the version without a ~ in terms of case
09:40:38 <parcs> interesting
09:40:39 <rostayob> buntfalke: mhm I'm not sure now, but I was pretty sure that with function declaration pattern matching (undefined, undefined) was equivalent to undefined
09:41:41 <buntfalke> rostayob: Nope, with f (a, b) = 1 in f (undefined, undefined) the pattern "It's a pair" can be matched no matter what the components
09:41:58 <buntfalke> rostayob: and as Haskell is still lazy today, it wont evaluate undefined :-)
09:42:07 <buntfalke> rwbarton: on my way :-)
09:44:00 <rostayob> buntfalke: oh right, it's the other way around
09:44:09 <rostayob> they are the same, with lazy pattern matching, they're not
09:44:28 <rostayob> let f = \(x, y) -> True in f undefined
09:44:40 <rostayob> > let f = \(x, y) -> True in f undefined
09:44:41 <lambdabot>   *Exception: Prelude.undefined
09:45:27 <rostayob> argh i can't find the alias
09:45:34 <rostayob> anyway with lazy pattern matching that would work
09:45:57 <ben> > let f = \~(x, y) -> True in f undefined
09:45:58 <lambdabot>   <no location info>: parse error on input `\~'
09:46:07 <ben> cripes
09:46:17 <rostayob> put a space
09:46:18 <ben> > let f = \ ~(x, y) -> True in f undefined
09:46:19 <lambdabot>   True
09:46:23 <rostayob> ohhh right.
09:46:30 <rostayob> damnit italian keyboard
09:46:31 <Clint> lispy: i cheated with ghc -e '((Graphics.Rendering.Chart.Simple.plotWindow =<< map (fromIntegral :: Int -> Double) . enumFromTo 1 . length) . map (fst . head . (reads :: String -> [(Double, String)]) . head) . filter ([[]] /=) . Data.Either.either (const []) id) =<< Text.CSV.parseCSVFromFile "/tmp/lame.csv"' -x hs =(echo "import Text.CSV")
09:46:41 <rostayob> ben: thanks for the collaboration :P
09:59:31 <Sawyer> Hi, how can I install hoogle data  on Windows?
10:00:38 <Sawyer> I can install hoogle from cabal in windows, but I can't successfully execute "hoogle data" on windows.
10:04:09 <mRoman> Hi
10:04:15 <mRoman> I've got a question
10:04:27 <mRoman> http://codepad.org/V1ofPDCx
10:04:32 <mRoman> ^- I can "manually" chain getSecond calls
10:04:55 <mRoman> but I can not chain them automatically.
10:04:55 <mRoman> Is there any way to achieve that?
10:06:17 <saml> mRoman, what do you mean by "chain" ?
10:06:24 <mRoman> well
10:06:35 <mRoman> getFirst . getSecond . getSecond . getSecond $ l
10:06:37 <copumpkin> mRoman: what would the type of getElem be?
10:06:41 <mRoman> ^- this works perfectly.
10:06:44 <mRoman> but
10:06:46 <copumpkin> if you can tell me what type it has
10:06:51 <saml> > [1,2,3] !! 2
10:06:52 <lambdabot>   3
10:06:54 <saml> you mean this?
10:06:54 <copumpkin> then maybe we can help ;)
10:07:04 <mRoman> getFirst . (times (getSecond) 3)) $ l is not valid
10:07:08 <saml> or, it's like cdr ?
10:07:11 <saml> cdddddr
10:07:15 <erus`> maybe we should have different languages for pure computation and side effects... ?
10:07:26 <copumpkin> erus`: we do
10:07:31 <copumpkin> they just happen to work nicely with each other
10:07:33 <mRoman> getElem == !! yes ;)
10:07:43 <copumpkin> mRoman: give me the type of that function ;)
10:07:44 <saml> mRoman, what should getElemN  do?
10:07:45 <mRoman> at least, that'd be the goal.
10:07:58 <saml> getElem100, for example. what do you want it to return?
10:08:01 <mRoman> saml: getElem list 4 should do the same as getElem4
10:08:03 <saml> 100th element in list?
10:08:09 <mRoman> saml: Yes.
10:08:16 <saml> so, why not use !! ?
10:08:22 <copumpkin> saml: it's a heterogeneous list
10:08:23 <mRoman> because it's not a list.
10:08:30 <mRoman> (not a real list)
10:08:47 <saml> maybe use Dynamic?
10:08:55 <saml> I think haskell can have heterogeneous list
10:09:18 <wavewave> hi.
10:09:29 <mRoman> there are heterogeneous lists yes.
10:09:33 <mRoman> With existential types or so.
10:09:47 <wavewave> I found interesting thing.
10:10:00 * copumpkin wonders if mRoman is ignoring him
10:10:07 <saml> mRoman, why do you want heterogenious list?
10:10:18 <wavewave> in GHC-Prim , lots of functions are defined as let x=x in x
10:10:36 <mRoman> copumpkin: I can't tell you the type of getElem
10:10:40 <copumpkin> wavewave: like what?
10:10:40 <mRoman> because I don't know.
10:10:42 <saml> taht's bottom wavewave
10:10:44 <copumpkin> mRoman: that's because it doesn't have one
10:10:57 <copumpkin> mRoman: you can't use Int there, because the type would depend on which Int you provide
10:11:05 <mRoman> So
10:11:07 <copumpkin> something like what you want can be done
10:11:15 <copumpkin> but it takes a lot more type voodoo
10:11:21 <mRoman> I need the functions to be generated at compile time.
10:11:26 <copumpkin> not really
10:11:39 <copumpkin> but working with runtime types is often complicated
10:11:46 <copumpkin> and probably doesn't provide much benefit to most people
10:12:06 <copumpkin> your whole code working with this stuff would need to live in an existential, basically
10:12:16 <mRoman> if there is some preprocessor magic which turns getElem list i into = getFirst . getSecond . getSecond ... (i times) at compile time that'd work, too.
10:12:30 <wavewave> saml : hmm, is the machine code represented as bottom? what is the purpose of showing a code as bottom here?
10:12:34 <copumpkin> you could write some TH for that
10:12:35 <KirinDave> I was talking about haskell at a coffee roasting thing last night
10:12:43 <Masxmasx{AFK}> Is there a function defined in the prelude that does take m drop (n list)?
10:12:52 <KirinDave> and a guy who is a big fan of Io challenged me with this "OO proxy problem"
10:13:14 <KirinDave> He asked how you could write a piece of code that abstracts over another piece of code seamlessly to shim its functions out to a remote server.
10:13:16 <wavewave> I got to the documentation from GHC documentation.
10:13:34 <wavewave> which is usually /usr/share/doc/ghc/html/index.html
10:13:37 <KirinDave> His example was a proxy object in Io
10:14:00 <KirinDave> that can reflect over any object and, given a hostname, proxy to a remote server and run that object remotely (assuming both ends have an object by that name loaded)
10:14:01 <mRoman> I actually just wanted to experiment with recursive types.
10:14:22 <KirinDave> What's the Haskell answer to that sort of code, besides shuddering revulsion at the messy and imprecise nature of the operation?
10:14:22 <mRoman> and somehow I got a "heterogenous list" with the above said limitation.
10:14:28 <Cale> KirinDave: If it's written over IO, then that shouldn't be too bad. If it's pure code then you plain shouldn't be allowed to do that, but if you think you know better, there's unsafePerformIO :P
10:14:31 <rostayob> KirinDave: what? "run that object remotely"?
10:14:39 <wavewave> get in Libraries and went to Prelude.
10:14:56 <copumpkin> I'd ask why he expects it to be seamless
10:14:58 <KirinDave> rostayob: So basically it reads the interface to an object and dynamically builds a series of proxy methods for that object
10:15:03 <KirinDave> and can call them on a remote server
10:15:05 <copumpkin> I don't want my code secretly sending shit out over a network without me knowing it
10:15:07 <Cale> You can abstract anything over any of the functions/IO actions that it uses.
10:15:12 <KirinDave> copumpkin: Well it wouldn't be secret
10:15:16 <copumpkin> I mean
10:15:17 <KirinDave> it would be for "extension of existing code"
10:15:18 <wavewave> just wanted to see the source code of seq
10:15:22 <Cale> KirinDave: Well, what's an object here? :)
10:15:24 <copumpkin> I don't want to abstract over that aspect of it :P
10:15:31 <copumpkin> I don't consider being able to do it necessarily a good thing
10:15:34 <wavewave> whether it was implemented using case or not..
10:15:35 <copumpkin> but you could do it with a suitable typeclass
10:15:38 <KirinDave> Cale: He was referring to Io, which has a sort of javascripty/selfy object model
10:15:43 <rostayob> KirinDave: so it's automatic RPC? that will *never* work well, unless you agree on a protocol embedded in th  VM of the language, or something along those lines (see erlang)
10:15:45 <KirinDave> ALthough it has dynamic lookup for superclass methods
10:15:52 <KirinDave> rostayob: That is what they did.
10:16:01 <KirinDave> rostayob: The author of Io, Steve Dekorte, is really into that sort of thing.
10:16:04 <rostayob> KirinDave: well then with haskell you can't
10:16:04 <Cale> KirinDave: Yeah, so if you translate that into Haskell, you might get records of (functions computing) IO actions
10:16:29 <DanBurton> @src seq
10:16:29 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:16:30 <KirinDave> You can't even really reflect over records at runtime, right?
10:16:33 <rostayob> for example with haskell you'll never be able to send functions (the actual function) over the internet :P
10:16:33 <Entroacceptor> you could, of course, just embed another language
10:16:37 <rostayob> no matter how hard you try
10:16:39 <Cale> KirinDave: In which case, it's as easy as making a record whose fields are IO actions for accessing the server.
10:16:41 <rostayob> you can do a little DSL
10:16:44 <KirinDave> rostayob: Oh it assumes the code has been pre-shared
10:16:59 <KirinDave> It doesn't ask for code serialization
10:17:02 <Cale> rostayob: At least, right now. There are people working on that.
10:17:16 <copumpkin> KirinDave: I was actually thinking of doing something along those lines for haskell the other day, but in a more haskelly way
10:17:16 <Cale> (Cloud Haskell, etc.)
10:17:22 <copumpkin> so that you could send an infinite list to another machine
10:17:48 <rostayob> KirinDave: mah yeah maybe, but it's mostly agreeing about what to do. serializing and RPC are easy in haskell, but is not completely automatic like in erlang (or maybe this Io which I've never heard of). but I think that is better that way
10:17:49 <KirinDave> copumpkin: Of work requests?
10:17:51 <saati> copumpkin: with infinite bandwith? :)
10:17:57 <rostayob> until we can come up with a way to do that nicely
10:17:57 <copumpkin> no
10:18:04 <copumpkin> because infinite lists are defined by finite code
10:18:07 <rostayob> Cale: oh, cool, who's working on that?
10:18:09 <copumpkin> which is running on the other side
10:18:26 <saati> so what will be sent?
10:18:34 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf
10:18:37 <Cale> Simon :)
10:19:01 <rostayob> oh, then it might actually happen!
10:19:04 <rostayob> i'll read that later, thanks
10:19:10 <Cale> Er, is that the right thing...
10:19:11 <Kaide> trust microsoft to mix "cloud" and "haskell"
10:19:20 <hpaste> buntfalke annotated “Why is the lazy pattern needed?” with “Why is the lazy pattern needed? (annotation)” at http://hpaste.org/51703#a51704
10:19:22 <Cale> I might have Cloud Haskell confused with something else
10:19:28 <copumpkin> saati: a representation of GHC's closure
10:19:30 <rostayob> that'd be great
10:19:33 <buntfalke> rwbarton: you agree with that hpaste?
10:19:41 <rostayob> that's probably erlang coolest feature
10:19:42 <copumpkin> but it looks like cloud haskell already did some of that
10:19:55 <buntfalke> rwbarton: I mean: Did I do it correctly?
10:20:10 <rostayob> KirinDave: btw, that problem has absolutely nothing to do with OO
10:20:19 <KirinDave> rostayob: I know. They think it does tho.
10:20:24 <rostayob> KirinDave: erlang does that and is not OO
10:20:38 <rostayob> it's just about agreeing on some RPC protocol
10:20:40 <KirinDave> rostayob: That's kinda what's frustrating about so many of the dynamic language types. Most of them just kinda aped a previous language with new syntax and some novel failures in their implementation.
10:20:49 <KirinDave> rostayob: It's more about dynamic typing and reflection.
10:21:11 <KirinDave> rostayob: although there is a more natural path to the actor model in dynamically typed OO languages, since the method invocation strongly resembles sending a message.
10:21:24 <Kaide> buntflake: the difference the ~ makes is that if the second argument is _|_ you get initiatilize:_|_ rather than _|_
10:21:33 <rostayob> KirinDave: well with haskell you wouldn't even need much reflection, you just need a data type with NFData in it, and a way to encode functions
10:22:11 <rostayob> or you could even send the expression to send infinite data structure whoooo
10:22:17 <rostayob> *structures
10:22:54 <UBB> Want free ZNC or counter-strike gathers, or free ventrilo channel? join irc.ubb.lt support in #help channel, don't hesitate to /q amex for free bnc or anything else you want
10:22:55 <buntfalke> Kaide: Yeah, well -- the issue wasn't about what happens in cases of bottom, rather why it is needed to begin with and wouldnt function normally without.
10:22:56 <Kaide> oh whoops buntflake sorry
10:23:15 <KirinDave> rostayob: There is no need to encode functions. :)
10:23:15 <Kaide> I just realized at that moment that you were talking about something else, yes
10:23:19 <buntfalke> Kaide: Try it, it'll loop forever if you feed it "normal, well-defined values"
10:23:26 <rostayob> KirinDave: to do what erlang does there is
10:23:36 <KirinDave> rostayob: Ahh...
10:23:40 <KirinDave> rostayob: Yeah, about that.
10:23:46 <rostayob> (I have no idea about Io)
10:23:49 <KirinDave> rostayob: Have you written erlang code that does this and experimented with it?
10:23:52 <buntfalke> Kaide: Use the Tabkey, young padawan ;-)
10:23:58 <rostayob> what a bad name for a programming language anyway
10:24:07 <rostayob> KirinDave: it's pretty common practice in erlang to do remote calls
10:24:09 <KirinDave> rostayob: It is generally considered "bad form" to send funs over the wire.
10:24:35 <rwbarton> buntfalke: Yep, that looks like a good explanation.
10:24:50 <rostayob> KirinDave: i'm not sure about that, i just know that you can :P
10:24:55 <rostayob> i haven't written much erlang anyway
10:25:01 <buntfalke> rwbarton: thanks a lot!
10:25:02 <Kaide> I tend not to use it on names I think I can spell!
10:25:13 <Kaide> didn't realize it wasn't flake until it was too late
10:26:19 <KirinDave> rostayob: I was fulltime erlang for 2 years at powerset & microsoft.
10:26:29 <KirinDave> It was a good gig.
10:26:31 <buntfalke> Kaide: ein Falke is German for a falcon. Don't worry, ppl mix up letters randomly in that nickname all the time :-)
10:26:33 <copumpkin> powerslice > powerset
10:26:52 <KirinDave> copumpkin: poweredmower > *
10:27:05 <Kaide> Falke is male?
10:27:06 <b0fh_ua> Hi! I'm trying to implement Dijkstra algorithm in Haskell, however I'm not sure which implementation of priority queue I should use
10:27:15 <b0fh_ua> please suggest
10:27:16 <rostayob> KirinDave: oh, cool
10:27:25 <Kaide> so used to stuff ending in e not being
10:27:29 <DanBurton> @google priority queue
10:27:30 <lambdabot> http://en.wikipedia.org/wiki/Priority_queue
10:27:30 <lambdabot> Title: Priority queue - Wikipedia, the free encyclopedia
10:27:37 <DanBurton> @google priority queue haskell
10:27:39 <rostayob> KirinDave: I've got a friend that works for vmware doing rabbitmq, so he's my main source regarding erlang :P
10:27:39 <lambdabot> http://hackage.haskell.org/package/priority-queue
10:27:39 <lambdabot> Title: HackageDB: priority-queue-0.2.2
10:28:03 <DanBurton> b0fh_ua: that one looks pretty good ;)
10:28:14 <b0fh_ua> it's not pure thus
10:28:38 <b0fh_ua> or I'm wrong?
10:29:09 <rostayob> b0fh_ua: yes it's pure iirc
10:29:20 <rostayob> why wouldn't it?
10:29:32 <mokus> it's got a monadic interface, it's basically just a wrapper around an abstract reference type containing a Map
10:29:40 <DanBurton> it looks like it uses ModifyRef though
10:29:46 <b0fh_ua> yup
10:30:01 <b0fh_ua> for sake of performance i think
10:30:25 <rostayob> @google psqueue
10:30:26 <lambdabot> http://hackage.haskell.org/package/PSQueue-1.1
10:30:26 <lambdabot> Title: HackageDB: PSQueue-1.1
10:30:34 <rostayob> that's what i had in mind
10:31:10 <rostayob> i think that one is implemented with finger trees
10:31:35 <buntfalke> Kaide: Yes, it's a male noun.
10:31:51 <rostayob> b0fh_ua: but it's more than you're asking for :)
10:32:15 <buntfalke> Kaide: der Adler (eagle) is neuter, though... It's all irregular :-)
10:32:30 <buntfalke> err, all wrong! It's male, too, of course.
10:32:52 * buntfalke seems to need a break
10:32:53 <Kaide> probably better suited to -blah
10:34:03 <elliott> What would you call turning (a :: T) into just a? Removing a type disambiguation? It's not a type signature, but I'm not sure what the actual name is.
10:35:03 <rostayob> elliott: it's not a type signature?
10:35:19 <DanBurton> elliott: I'd call it a type annotation
10:35:22 <elliott> Well, I wouldn't say so. I'd call type signatures a declaration.
10:35:27 <elliott> DanBurton: Ah, that's what I was thinking of; thanks.
10:35:40 <rostayob> oh, ok. i've always called them type signatures eheh
10:36:10 <DanBurton> when I hear "type signature" I think "[of a function]"
10:36:24 <benmachine> you can perfectly well have type signatures of values
10:36:28 <benmachine> e.g. main :: IO a
10:36:31 <Cale> "[what does this indicate?]" :)
10:36:33 <copumpkin> functions are values
10:36:48 <copumpkin> their types just happen to start with (->)
10:36:48 <DanBurton> "[this means what I think in my brain]"
10:36:50 <elliott> DanBurton: Really? so
10:36:51 <elliott> :t pi
10:36:51 <benmachine> copumpkin: right, but not vice versa :P
10:36:52 <lambdabot> forall a. (Floating a) => a
10:36:59 <elliott> DanBurton: "pi :: (Floating a) => a" isn't a type signature?
10:37:00 <benmachine> (not always)
10:37:15 <byorgey> a :: T  is called a type signature if it is a declaration.   It is called a type annotation if it is an expression.
10:37:21 <DanBurton> elliott: yeah I guess.
10:37:33 <benmachine> I think if you called it an expression type signature people would know what you meant
10:37:33 <DanBurton> disclaimer: things my brain thinks are not always authoritative ;)
10:37:37 <byorgey> for example   foo :: Int; foo = 3   is a type signature.   x = (foo :: Int) + 2  is an annotation.
10:38:40 <DanBurton> Personally I'd call   foo :: Int; foo = 3  a "type declaration"
10:39:26 <shachaf> foo :: Int = 3 is an extension. :-)
10:39:47 <DanBurton> shachaf: looks like Scala
10:39:53 <byorgey> DanBurton: the Haskell report calls it a type signature.  Type declaration is a common name too.
10:40:13 <byorgey> however,  x = (foo :: Int) + 2  is definitely neither a signature nor declaration.
10:40:17 <DanBurton> @wiki haskell2010
10:40:17 <lambdabot> http://www.haskell.org/haskellwiki/haskell2010
10:40:45 <DanBurton> @google haskell2010
10:40:46 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
10:40:49 <byorgey> DanBurton: see section 4.4
10:41:08 <DanBurton> byorgey: cool, thanks for the pointer
10:41:08 <shachaf> The Haskell report also calls getLine a function. :-)
10:41:14 <DanBurton> lol
10:41:18 <byorgey> hehe, oops =)
10:41:30 <benmachine> byorgey: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-560003.16
10:41:47 <benmachine> looks like (foo :: Int) + 2 is called an expression type signature by the report
10:41:50 <byorgey> WHAT
10:41:55 <byorgey> heresy!
10:41:55 <elliott> That's awful.
10:42:14 <elliott> They probably changed that in Haskell 98 when they were busy ruining everything.
10:42:17 <benmachine> :P
10:42:25 <byorgey> I must concede the point.  But I have never heard anyone actually call it that.
10:42:52 * shachaf wants (::T) sections.
10:43:00 <djahandarie> Hah
10:43:00 <elliott> shachaf: Ugh, does it really?
10:43:09 <benmachine> shachaf: cute. what about (foo::)? :P
10:43:21 <byorgey> shachaf: hehe, nice, so (::T) :: T -> T ?
10:43:26 <elliott> asType :: (T:Type) -> T -> T
10:43:26 <shachaf> Yep.
10:43:28 <elliott> (::) = flip asType
10:43:40 <shachaf> (::T) = (\x->x::T)
10:43:53 * benmachine wonders how 'flip' interacts with DTs
10:43:54 * DanBurton 's brain exploded
10:44:05 <elliott> shachaf: (9::) :: (Num T) => (T::Type) -> T?
10:44:09 <elliott> (9::) Int
10:44:35 * shachaf wonders what's with the upper-case type variables suddenly.
10:44:38 <byorgey> @type let (:::) = asTypeOf in (:::(undefined :: Int)) 3
10:44:40 <lambdabot> Not in scope: data constructor `:::'
10:44:40 <lambdabot> Not in scope: data constructor `:::'
10:44:42 <DanBurton> I just made this wiki page. Anybody feel like adding a little more info? http://www.haskell.org/haskellwiki/Haskell2010
10:44:53 <elliott> shachaf: I'm not sure.
10:44:55 <shachaf> byorgey: That's a little much.
10:45:07 <byorgey> hehe
10:45:08 <elliott> shachaf: I think it's 'cuz Coq and Agda do it.
10:45:31 <shachaf> DanBurton: Probably just redirect to http://www.haskell.org/haskellwiki/Haskell_2010
10:45:33 <benmachine> we're representing potentially-concrete types rather than variables necessarily
10:45:43 <benmachine> it's a sort of pseudohaskell?
10:45:53 <elliott> benmachine: No, they're variables.
10:45:54 <DanBurton> shachaf: ooh didn't see that one
10:45:56 <elliott> Think dependently-typed.
10:46:01 <elliott> At least that's what I was doing.
10:46:12 <elliott> I probably should have used an asterisk rather than Type.
10:46:18 <benmachine> Set :P
10:46:32 <shachaf> elliott: Next you'll want to put Constraint in there.
10:46:35 <elliott> benmachine: Nah, we need Type[n] for all naturals n, with Set and Prop being subtypes.
10:46:50 <elliott> shachaf: Naturally.
10:48:21 <trinithis> in the ghc, do string literals share the same data?
10:48:39 <copumpkin> no
10:48:49 <shachaf> Well, the share the same []. :-)
10:48:54 <trinithis> ahah
10:49:26 <hpc> literals get compiled as C strings, yes?
10:49:49 <DanBurton> does ghc make a different [] for every [a] type, or does it reuse the same one for all of them?
10:50:09 <copumpkin> hpc: I think so
10:50:34 <elliott> copumpkin: hpc: how does that actually work?
10:50:39 <elliott> Is a closure constructed for each element?
10:50:45 <elliott> Like peek s 0 : peek s ...
10:50:47 <DanBurton> hpc: if so, then how could you perform typical list methods on them like head?
10:50:57 <elliott> DanBurton: by doing the above? It seems wasteful though
10:51:22 <parcs> DanBurton: that sounds like a pretty basic optimization that i'm sure ghc accounts for
10:51:35 <elliott> parcs: You can't optimise passing a literal string to any function.
10:51:44 <elliott> And eliminate all list operations.
10:51:49 <elliott> (Halting problem yadda yadda.)
10:52:13 <parcs> elliott: i was referring to "does ghc make a different [] for every [a] type, or does it reuse the same one for all of them?"
10:52:23 <DanBurton> so I suppose the default would be to optimize only expressions like    putStrLn "foo"
10:53:07 <DanBurton> parcs: my fault for asking two questions at once xD
10:53:10 <elliott> parcs: Ah.
10:53:21 <elliott> parcs: Do you mean different [...] or different []?
10:53:27 <elliott> There's only one [].
10:53:44 <trinithis> That's the most profound thing I've ever heard
10:54:27 * shachaf is sure #haskell can provide you with more profundity than that.
10:54:37 <shachaf> For example, "There's only one _|_."
10:55:03 <trinithis> Equally profound.
10:55:05 <shachaf> @quote prof
10:55:06 <lambdabot> NathanielSBorenstein says:  It should be noted that no ethically-trained software engineer would ever consent to write a DestroyBaghdad procedure. Basic professional ethics would instead require him
10:55:06 <lambdabot> to write a DestroyCity procedure, to which Baghdad could be given as a parameter.
10:55:16 <trinithis> @quote trinithis
10:55:17 <lambdabot> No quotes match. Just what do you think you're doing Dave?
10:57:26 <cheater> quicksilver: hey, still there?
11:01:34 <trinithis> Haha, I tried joining #nazi, and I ended up in ##you_have_got_to_be_kidding
11:01:58 <FredOverflow> Anyone at ICFP?
11:03:37 <copumpkin> trinithis: #haskell-blah is probably better for that sort of stuff :)
11:03:43 <copumpkin> FredOverflow: I thought it was almost over
11:03:47 <copumpkin> or already over, maybe
11:03:56 <byorgey> FredOverflow: also, it is 4am there
11:04:30 <FredOverflow> The "affiliated events" go until Sep 24th
11:05:10 <DanBurton> FredOverflow: my prof Jay McCarthy is back already
11:06:04 <FredOverflow> Jay == John?
11:06:15 <DanBurton> false
11:06:16 <byorgey> FredOverflow: yes, it is 4am on the 24th there, so CUFP Day 3 and the Continuation Workshop are yet to happen
11:06:47 <FredOverflow> You mean False with a capital F, right? ;)
11:07:11 <DanBurton> > let false = False
11:07:12 <lambdabot>   not an expression: `let false = False'
11:07:22 <DanBurton> @let false = False
11:07:23 <lambdabot>  Defined.
11:07:28 <DanBurton> there ;)
11:07:34 <FredOverflow> fair enough :)
11:07:42 <FredOverflow> > false == False
11:07:43 <lambdabot>   True
11:07:59 <FredOverflow> How long will this binding last?
11:07:59 <DanBurton> just don't try to pattern match on   false
11:08:01 <cheater> what is the most current version of ghc that is safe to use?
11:08:12 <byorgey> FredOverflow: until the next time someone calls @unlet
11:08:38 <DanBurton> byorgey: but I imagine lambdabot has to periodically forget things, right?
11:08:43 <byorgey> cheater: um. that depends entirely on your definition of 'safe'.
11:08:47 <shachaf> Less often that people @undefine.
11:08:50 <shachaf> @undefine -- see?
11:09:01 <DanBurton> @unlet
11:09:02 <FredOverflow> > false
11:09:02 <lambdabot>   Not in scope: `false'
11:09:03 <lambdabot>  Defined.
11:09:05 <cheater> byorgey: i don't have to Coerce it to work.
11:09:18 <cheater> packages aren't broken etc. i don't know.
11:09:18 <FredOverflow> @let false = False
11:09:18 <lambdabot>  Defined.
11:09:20 <FredOverflow> @let true = False
11:09:21 <lambdabot>  Defined.
11:09:23 <FredOverflow> > true == false
11:09:25 <lambdabot>   True
11:09:31 <DanBurton> lol
11:09:58 <DanBurton> That's like the python trick where you make (True, False) = (False, True) or something like that
11:10:08 <FredOverflow> I just read about Monad comprehensions. What are they good for? Is there a simple example that demonstrates their usefulness?
11:10:09 <byorgey> cheater: for maximum Things-Just-Work-age, for the moment I'd stick with the version that comes with the latest Haskell Platform release
11:10:27 <cheater> byorgey: ok
11:10:28 <byorgey> which is 7.0.3 or 7.0.4, I forget which
11:10:57 <byorgey> 7.2.1 works fine for me but you still occasionally run into things that heven't been updated to work with it.
11:11:15 <master_of_master> hi, how can I do a map on every second entry of a list?
11:11:30 <DanBurton> every second entry?
11:11:36 <DanBurton> don't lists have only one second entry?
11:11:38 <FredOverflow> Write a function that drops every second element and then use the standard map?
11:11:46 <cheater> byorgey: aha
11:12:02 <FredOverflow> Or do you want to retain the non-mapped elements?
11:12:07 <shachaf> > unsafePerformIO (system "echo foo > /tmp/bar")
11:12:09 <lambdabot>   ExitSuccess
11:12:40 <parcs> i've had a lot of problems with 7.2 and multiple cabal packages
11:12:58 <copumpkin> shachaf is such a l33t hax0r
11:13:01 <dankna> I've had no trouble at all with HEAD as of about a month ago
11:13:13 <dankna> (7.3.datestamp)
11:13:18 <shachaf> copumpkin: High praise!
11:13:30 <DanBurton> @let hopmap f [] = []; hopmap f [x] = []; hopmap f (x:y:xs) = f y : hopmap xs
11:13:32 <lambdabot>  <local>:1:63:
11:13:32 <lambdabot>      Couldn't match expected type `[t]' against inferred type ...
11:13:40 <shachaf> @copsnack
11:13:41 <lambdabot> :)
11:13:51 <master_of_master> FredOverflow: yes, I need to process them at the same time. e.g. call function on 1. and 2. entry and then on 3. and 4. entry and so on
11:13:58 <copumpkin> shachaf: yeah, when a l33t hax0r like me calls you a l33t hax0r, that makes you a l33t hax0r ^2
11:13:59 <DanBurton> hm where did I go wrong..
11:14:04 <parcs> yeah i would suggest skipping 7.2 and installing a snapshot of head alongside whatever ghc version you already have installed
11:14:06 <byorgey> > zipWith ($) (cycle [(+1), id]) [1..10]   -- master_of_master
11:14:07 <lambdabot>   [2,2,4,4,6,6,8,8,10,10]
11:14:22 <shachaf> DanBurton: Didn't pass f along.
11:14:31 <FredOverflow> master_of_master: So the function takes two arguments?
11:14:32 <DanBurton> @let hopmap f [] = []; hopmap f [x] = []; hopmap f (x:y:xs) = f y : hopmap f xs
11:14:33 <lambdabot>  Defined.
11:14:33 <shachaf> DanBurton: Also, didn't split it into two functions "hop" and "map".
11:14:39 <master_of_master> FredOverflow: yes
11:14:50 <DanBurton> hopmap (+1) [1..10]
11:14:54 <DanBurton> > hopmap (+1) [1..10]
11:14:56 <lambdabot>   [3,5,7,9,11]
11:15:08 <DanBurton> nope still wrong xP guess I should ghci this first
11:15:17 <shachaf> Also, this looks like a homework question?
11:15:21 <elliott> :t unsafePerformIO
11:15:22 <lambdabot> Not in scope: `unsafePerformIO'
11:15:38 <elliott> I guess so soon after shachaf my lambdabot prank would be wasted.
11:15:51 <FredOverflow> master_of_master: Well, then use Dan's solution.
11:15:53 <shachaf> elliott: Only people like copumpkin and me can use unsafePerformIO.
11:16:08 <copumpkin> I call it purify
11:16:17 <shachaf> I think master_of_master wants DanBurton's solution with an extra x:
11:16:17 <zachk> whats the point of unsafepermIO? and how does one purify it
11:16:33 <shachaf> One must undergo a cleansing ritual.
11:16:42 <shachaf> Before you can purify you IO actions, you must purify your soul.
11:16:46 <DanBurton> master_of_master use something like what I wrote above; obviously that's still wrong
11:16:55 <shachaf> master_of_master: Is this homework?
11:17:16 <zachk> how does one purify his soul?
11:17:41 <DanBurton> zachk: by reciting the LYAH 10 times daily?
11:18:13 <shachaf> > unsafePerformIO "zachk"
11:18:15 <lambdabot>   your soul is now undergoinN@()&ND#&@&#))HNO CARRIER
11:18:36 <leod> :O
11:18:47 <FredOverflow> Does lambdabot understand function definitions via multiple patterns?
11:18:47 <DanBurton> > unsafePerformIO fireMissiles
11:18:49 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `fireMissiles'
11:19:04 <FredOverflow> You mean launch instead of fire, right? ;)
11:19:09 <zachk> > unsafePerfomIO "buddha"
11:19:10 <lambdabot>   Not in scope: `unsafePerfomIO'
11:19:20 <zachk> hacks
11:19:24 <DanBurton> o_O
11:19:45 <alpounet> > let { f True = False ; f False = True } in f False -- FredOverflow ?
11:19:46 <lambdabot>   True
11:20:15 <elliott> alpounet: So, not?
11:20:18 <elliott> Oh, I see.
11:20:18 <FredOverflow> let { foo f [] = []; foo f (x:y:rest) = f x y : foo f rest } in foo (,) "helloworld"
11:20:26 <FredOverflow> @let { foo f [] = []; foo f (x:y:rest) = f x y : foo f rest } in foo (,) "helloworld"
11:20:26 <lambdabot>   Parse error: in
11:20:39 <FredOverflow> > let { foo f [] = []; foo f (x:y:rest) = f x y : foo f rest } in foo (,) "helloworld"
11:20:39 <lambdabot>   [('h','e'),('l','l'),('o','w'),('o','r'),('l','d')]
11:21:03 <alpounet> i guess you have to remove the braces for @let
11:21:04 <FredOverflow> I really need to read the lambdabot manual :)
11:21:17 <elliott> @let { foo f [] = []; foo f (x:y:rest) = f x y : foo f rest }
11:21:17 <lambdabot>  <local>:1:0: parse error on input `{'
11:21:19 <alpounet> just like the 'hopmap' written a bit earlier here
11:21:29 <alpounet> oh no
11:21:38 <alpounet> when you @let something it must not be an expression
11:21:38 <FredOverflow> hopmap ignored the x
11:21:54 <FredOverflow> foo passes both x and y to f
11:21:57 <alpounet> but your "... in foo (,) "helloworld" is
11:22:00 <elliott> yeah
11:22:00 <KirinDave> Man, I won't get time off and I'd have to pay my own way
11:22:00 <KirinDave> b
11:22:03 <elliott> that's why I tried it without
11:22:08 <KirinDave> But I am SO tempted to go to this galois class
11:22:15 <shachaf> FredOverflow: You can /msg lambdabot to experiment.
11:22:17 <master_of_master> shachaf: I'm out of university
11:22:34 <DanBurton> KirinDave: I SO wish I could. Too poor :(
11:23:10 <FredOverflow> @let { foo f [] = []; foo f (x:y:rest) = f x y : foo f rest }
11:23:10 <lambdabot>  <local>:1:0: parse error on input `{'
11:23:17 <FredOverflow> @let foo f [] = []; foo f (x:y:rest) = f x y : foo f rest
11:23:18 <lambdabot>  Defined.
11:23:22 <FredOverflow> foo (,) "helloworld"
11:23:28 <FredOverflow> > foo (,) "helloworld"
11:23:30 <lambdabot>   [('h','e'),('l','l'),('o','w'),('o','r'),('l','d')]
11:23:51 <leod> > foo (,) "hel"
11:23:52 <lambdabot>   [('h','e')*Exception: <local>:1:0-51: Non-exhaustive patterns in function foo
11:24:14 <FredOverflow> Passing a list with an odd number of elements is a programming error in this case. Yay for the exception :)
11:24:31 <DanBurton> @let foo f [] = []; foo f [x] = []; foo f (x:y:rest) = f x y : foo f rest
11:24:32 <lambdabot>  <local>:1:0:
11:24:32 <lambdabot>      Warning: Pattern match(es) are overlapped
11:24:32 <lambdabot>               In...
11:24:50 <zachk> FredOverflow: you could make it a total function
11:24:59 <DanBurton> > foo (,) "hel"
11:25:01 <lambdabot>   [('h','e')*Exception: <local>:1:0-51: Non-exhaustive patterns in function foo
11:25:44 <DanBurton> @unlet
11:25:45 <lambdabot>  Defined.
11:25:49 <DanBurton> @let foo f [] = []; foo f [x] = []; foo f (x:y:rest) = f x y : foo f rest
11:25:49 <lambdabot>  <local>:1:0:
11:25:50 <lambdabot>      Warning: Pattern match(es) are overlapped
11:25:50 <lambdabot>               In...
11:25:55 <FredOverflow> lol works in my computer :)
11:25:56 <DanBurton> hm...wat?
11:26:09 <FredOverflow> must be a lambdabot error
11:26:16 <DanBurton> trippy
11:26:30 <hpc> @undefine
11:26:34 <hpc> now try
11:26:40 <DanBurton> @let foo f [] = []; foo f [x] = []; foo f (x:y:rest) = f x y : foo f rest
11:26:41 <lambdabot>  Defined.
11:26:53 <DanBurton> so...what does @unlet do then?
11:27:00 <hpc> nothing
11:27:18 <DanBurton> <insert glaring reddit eyes here>
11:27:27 <DanBurton> > foo (,) "hel"
11:27:29 <lambdabot>   [('h','e')]
11:27:43 <FredOverflow> @unlet
11:27:44 <lambdabot>  Defined.
11:27:45 <FredOverflow> > foo (,) "hel"
11:27:47 <lambdabot>   [('h','e')]
11:27:51 <FredOverflow> @unlet foo
11:27:51 <lambdabot>   TemplateHaskell is not enabled
11:28:14 <hpc> o.O
11:28:16 <FredOverflow> ...ok? :)
11:28:28 <elliott> @undefine
11:28:30 * DanBurton smiles and nods at lambdabot
11:28:31 <elliott> There's no unlet.
11:28:34 <elliott> You just have to wipe everything.
11:28:43 <elliott> lambdabot just spell-corrects things.
11:29:31 <FredOverflow> @foobarbaz
11:29:31 <lambdabot> Unknown command, try @list
11:29:40 <FredOverflow> So what is @unlet corrected to?
11:30:42 <DanBurton> to @let I suppose. I'm pm-ing lambdabot with stuff like @ilet and @lett and it keeps responding with "defined"
11:31:20 <buntfalke> Why is '1':'2':'3':..."" so much faster than "1"++"2"++"3"++...?
11:32:04 <DanBurton> buntfalke: ++ has to entirely deconstruct its left-hand argument each time
11:32:18 <danr> (:) is constant time, (++) is linear in the length of the first list
11:32:26 <rwbarton> basically you're constructing and deconstructing a bunch of lists unnecessarily
11:32:28 <FredOverflow> Is ++ left or right associative?
11:32:32 <buntfalke> danr, DanBurton: I know, but why?
11:32:38 <buntfalke> FredOverflow: right associative
11:32:40 <DanBurton> @src (++)
11:32:40 <lambdabot> []     ++ ys = ys
11:32:40 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:32:40 <lambdabot> -- OR
11:32:40 <lambdabot> xs ++ ys = foldr (:) ys xs
11:32:56 <DanBurton> @info (++)
11:32:56 <lambdabot> (++)
11:33:00 <buntfalke> Oh...I see...
11:33:09 <buntfalke> ++ is defined in terms of (:)
11:33:10 <FredOverflow> Then it should not matter that much, both ++ and : should be approximately equally efficient.
11:33:14 <sm> what's a good way to embed build information (ghc version, platform details) into your version string ?
11:33:25 <buntfalke> FredOverflow: nope
11:33:28 <rwbarton> probably even the optimizer won't convert "1"++x to '1':x I would guess
11:33:48 <rwbarton> as (++) is recursive
11:34:06 <DanBurton> rwbarton in the case of "1"++xs, there's really no slowdown since the length of the left argument is 1.
11:34:22 <rwbarton> there's still a (pretty big) constant factor more work, though
11:34:23 <shachaf> DanBurton: FSVO "really"
11:34:50 <DanBurton> shachaf: what does FSVO mean?
11:35:15 <FredOverflow> buntfalke: What do you mean, nope? They certainly have the same asymptotic complexity.
11:35:19 <rwbarton> you have to build the data structure (:) 1 [], then check that it's of the form (:) _ _, then build the actual cons cell '1' ++ ..., then check that [] is of the form []
11:35:19 <shachaf> @whatis fsvo
11:35:20 <lambdabot> for some values of
11:35:44 <rwbarton> so I would guess that '1':x could be 4-8 times as fast, very approximately
11:35:56 <DanBurton> shachaf: nvm googled it
11:36:08 <rwbarton> (to the extent that it's possible to talk about how long such an operation takes)
11:36:14 <buntfalke> FredOverflow: see the rest all the other answers
11:36:33 <FredOverflow> Yes, they account for a constant overhead.
11:36:49 <FredOverflow> But ++ certainly isn't dramatically slower (in the sense of O(n) vs. O(n^2) or something).
11:37:10 <shachaf> They call that "dramatic" nowadays?
11:38:24 <DanBurton> you may be interested in this SO question I asked a while ago: http://stackoverflow.com/questions/5188286/idiomatic-efficient-haskell-append
11:40:49 <DanBurton> also, obligatory spamming: I put a +200 bounty on my SO question regarding Haskell strictness points. No new responses have appeared since the bounty yet. http://stackoverflow.com/questions/7490768/what-are-haskells-strictness-points
11:41:15 <shachaf> 200 whats?
11:41:21 <DanBurton> bunnies
11:41:41 <DanBurton> no, really though, stackoverflow reputation
11:41:56 <elliott> Can I exchange those for BITCOINS?
11:41:56 <shachaf> Oh.
11:42:14 <shachaf> It's the reputable thing to do?
11:42:28 <sm> heh: http://propella.blogspot.com/2011/09/yet-another-alligator-eggs-animation.html
11:42:36 <DanBurton> elliott: you'd have to find a bunny-seller willing to accept bitcoins, but given the reproduction rate of bunnies I'd say that's probably not too hard
11:43:00 <john_r_watson> so I'm trying to play w/ Control.Applicative and implement the instance of Maybe for it (as a learning exercise).  Is there a way to "block" the instance already defined in Control.Applicative in an import?
11:43:07 <elliott> Bunnies: a renewable resource.
11:43:15 <elliott> john_r_watson: No.
11:43:16 <john_r_watson> (instance Applicative Maybe)
11:43:19 <john_r_watson> elliott: :(
11:43:21 <elliott> john_r_watson: Make a newtype wrapper.
11:43:29 <elliott> newtype MyMaybe a = MyMaybe (Maybe a)
11:43:36 <elliott> instance Applicative MyMaybe where pure a = MyMaybe (Just a); ...
11:43:42 <john_r_watson> elliott: thanks
11:43:56 <elliott> (Or just define your own equivalent to Maybe, to avoid wrapping and rewrapping.)
11:44:18 <DanBurton> see also http://blog.tmorris.net/20-intermediate-haskell-exercises/
11:45:29 <shachaf> sm: That's neat.
11:45:56 <sm> shachaf: yes, but I can't make head or tail of it :)
11:46:13 <buntfalke> FredOverflow: I agree with you now :-)
11:46:26 <shachaf> sm: Well, it depends on how you define lists.
11:46:41 <rwbarton> is it bad that i'm evaluating these alligator pictures by translating them back to lambda-notation
11:46:57 <shachaf> sm: If you just define them as Church-encoded cons pairs, head is \p -> p (\x y -> x)
11:47:00 <monochrom> DanBurton: some I/O actions (such as putStrLn), pattern matching and if-then-else, seq, "data X = X !Int", and function application are the drivers of evaluation, and that is all IIRC. in the case of function application, the function is evaluated first (until it's a lambda), e.g., (if b then const 0 else const 1) (if c then 0 else 1) causes evaluation of (if b then const 0 else const 1)
11:47:05 <DanBurton> > data Mebeh a = Nothin | Juzt a
11:47:06 <lambdabot>   <no location info>: parse error on input `data'
11:47:20 <monochrom> I have no SO account and I intend to have none, so nevermind the bonus.
11:47:33 <dolio> Use Picard.
11:47:42 <dolio> data Picard a = MakeItSo a | BelayThat
11:47:50 <danr> Scala style : data Option a = Some a | None
11:47:59 <shachaf> DanBurton: "Scala"-style?
11:48:09 <shachaf> s/D/d/ s/Burton/r/
11:48:12 <elliott> shachaf: s/D/d/ s/Burton/r/
11:48:13 <elliott> ...wow.
11:48:20 <copumpkin> lol
11:48:30 <DanBurton> lol
11:49:10 * shachaf resists the urge to stereo.
11:49:22 <DanBurton> monochrom: thanks, but with the SO question I'm trying to get someone to make a detailed, googleable answer
11:49:41 <monochrom> I am already writing a complete tutorial on lazy evaluation
11:50:08 <DanBurton> links or it didn't happen ;)
11:50:17 <monochrom> phase 1 will be complete in a few days
11:50:33 <monochrom> right, it hasn't happened yet
11:50:58 <hpaste> buntfalke pasted “(:) vs. (++) vs (.)” at http://hpaste.org/51707
11:51:08 <buntfalke> Can anyone explain those runtime claims?
11:51:34 <buntfalke> FredOverflow: This is why I first replied "nope"
11:51:56 <elliott> buntfalke: That example is nothing at all about ("a"++b) vs. ('a':b).
11:52:00 <elliott> It's about the other ++s.
11:52:31 <DanBurton> by using composition, it makes the ++ chain happen from right to left, rather than left to right
11:53:09 <buntfalke> DanBurton: (++) is right-associative, is it not?
11:54:00 <DanBurton> buntfalke: right; scratch that
11:54:09 <dainanaki> Is anyone familiar with both the iteratee and enumerator libraries around?
11:55:13 <elliott> I'm passingly familiar with enumerator and am starting to use iterIO in a project now, but not iteratee.
11:55:18 <elliott> Glad to not help you :P
11:55:38 <dylukes> I've used them both a little, but not enough to really speak about them meaningfully.
11:55:39 <rwbarton> if 'show x' is some fixed other function, these are asymptotically equally efficient
11:56:07 <copumpkin> dylukes: so have you proved the law of excluded middle yet?
11:56:12 <dainanaki> I'm really just trying to figure out what the equivalent is in iteratee to the (>>==) operator in enumerator.
11:56:17 <rwbarton> but if show x could invoke this showList'/showList, say we're showing a value like [[[[[[[[[[]]]]]]]]]], then the claims are right
11:56:22 <DanBurton> @wiki Difference list
11:56:22 <lambdabot> http://www.haskell.org/haskellwiki/Difference_list
11:56:22 <dylukes> copumpkin: But... it doesn't hold in agda does it?
11:56:23 <dolio> I also can't answer your question. Just letting you know.
11:56:25 <shachaf> copumpkin: The law of excluded middle is obviously false.
11:56:28 <dylukes> I mean, if I have a bool type
11:56:34 <elliott> dolio: Let's get the whole channel to join in.
11:56:36 <dylukes> wouldn't that just be proving there isn't a third member?
11:56:38 <dylukes> and I mean, its false
11:56:40 <dylukes> There's bottom.
11:56:41 <dylukes> :|
11:56:45 <elliott> There's not bottom in Agda.
11:56:48 <dylukes> Oh, really?
11:56:52 <elliott> Of course not.
11:56:55 <elliott> Unless you disable the termination checker.
11:56:58 <dylukes> :P
11:56:58 <elliott> Which makes its logic inconsistent.
11:57:01 <copumpkin> dylukes: it's "true" on Bool
11:57:02 <elliott> proof_of_anything :: a
11:57:06 <elliott> proof_of_anything = proof_of_anything
11:57:10 <elliott> (Haskell, but you get the point.)
11:57:25 <shachaf> dylukes: LEM is forall p. Either p (Not p)
11:59:01 <shachaf> I guess Agda would use ∨ and ¬, or something.
11:59:16 <dolio> People have discovered bottom in Agda quite a few times.
11:59:21 <dolio> But then it gets patched.
12:00:01 <Eduard_Munteanu> How do you call \bot?
12:00:17 <Eduard_Munteanu> The terminology seems to overlap a bit.
12:00:28 <Eduard_Munteanu> Well, bottom type vs bottom values.
12:00:39 <copumpkin> :t safeCoerceList
12:00:40 <lambdabot> forall a b. [a] -> [b]
12:00:53 <mkscrg> so i'm trying to learn the attoparsec library. haven't used parsec before, or any other generic parsing library. where can i find good examples?
12:01:06 <Eduard_Munteanu> safeCoarceList _ = [] ? :)
12:01:16 <copumpkin> Eduard_Munteanu :(
12:01:18 <elliott> > safeCoerceList []
12:01:19 <lambdabot>   []
12:01:20 <elliott> > safeCoerceList [99,0]
12:01:21 <lambdabot>   []
12:01:23 <elliott> Laaaaame.
12:01:45 <elliott> dolio: Well, I think you're meant to pretend Agda's bugs don't exist when using it.
12:02:06 <dolio> That isn't very satisfying.
12:02:17 <shachaf> dolio: Mathematics isn't very satisfying.
12:02:19 <elliott> dolio: Use Coq :-P
12:02:31 <Eduard_Munteanu> People routinely pretend naive set theory is ok :P
12:02:34 <dolio> Coq isn't very satisfying, either.
12:03:36 <copumpkin> twss
12:03:48 <elliott> dolio: But it's much less likely to have _|_.
12:05:14 <dolio> I don't really mind Agda. It'd be nice if it didn't have bugs that allow loops, though.
12:05:27 <dolio> It's getting less frequent, though.
12:06:20 <dylukes> dolio: How do you "discover" bottom?
12:06:29 <elliott> dylukes: Fooling the termination checker.
12:06:31 <dylukes> like, does it manifest even if its not built in?
12:06:47 <copumpkin> you find yourself able to prove something you shouldn't be able to prove
12:06:57 <dylukes> how do you prove you shouldn't be able to prove it?
12:06:59 <shachaf> copumpkin: Like the law of excluded middle.
12:07:05 <shachaf> dylukes: Using Agda!
12:07:06 <copumpkin> dylukes: if you can prove false from it
12:07:09 <elliott> dylukes: It wouldn't manifest if they could prove that the programs Agda produces always halt. Which is saying a lot more than it sounds.
12:07:13 <Runar> dylykes: bottom is the answer to a question that doesn't make sense
12:07:19 <elliott> I really don't like Agda's "large kernel" approach.
12:07:19 <dylukes> shachaf: What if you shouldn't be able to prove that you shouldn't be able to prove it?
12:07:30 <shachaf> dylukes: Somehow i works out.
12:07:49 <copumpkin> elliott: I think conor's response to that would be along the lines of "fuck you"
12:07:52 <dylukes> Runar: Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?" ... I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.
12:07:59 <shachaf> dylukes: You can do a proof of LEM from callCC in Haskell, kind of, as kmc has pointed out. It's neat.
12:08:07 <dylukes> LEM?
12:08:09 <dylukes> callCC?
12:08:11 <dylukes> ??
12:08:11 <elliott> copumpkin: Response to what?
12:08:19 <dylukes> Oh by the way,
12:08:20 <copumpkin> elliott: to your dislike of the large kernel approach
12:08:20 <dolio> I like having a test ground for new type theory features.
12:08:20 <dylukes> I blame you guys.
12:08:28 <dylukes> In math we're doing axiomatic real numbers.
12:08:31 <elliott> copumpkin: Well, I could put it on my resume.
12:08:32 <kmc> i've been meaning to blog that
12:08:36 <dolio> Someone else can harden it up later.
12:08:37 <dylukes> And I kept thinking "oh hey, real numbers form a field under + and *!"
12:08:38 <copumpkin> kmc: blog what?
12:08:44 <copumpkin> dolio: harden it the fuck up?
12:08:47 <kmc> the LEM proof
12:08:51 <wavewave> elliott: what's large kernel approach?
12:08:52 <dolio> Yeah.
12:08:56 <copumpkin> kmc: how do you prove LEM?
12:08:56 <dylukes> and then tried to show sets form a field as well.
12:09:02 <dylukes> As far as I can tell they do.
12:09:06 <copumpkin> sets under what?
12:09:06 <kmc> in an accessible form
12:09:08 <dylukes> under union and intersection
12:09:17 <copumpkin> dylukes: boolean algebra
12:09:29 <dylukes> copumpkin: I'd imagine it does as well, off the top of my head.
12:09:31 <dylukes> under & and |
12:09:34 <copumpkin> I mean
12:09:38 <copumpkin> sets form a boolean algebra
12:09:41 <elliott> wavewave: The opposite of the small kernel approach.
12:09:42 <dylukes> oh, yeah
12:09:58 <wavewave> elliott: hmm..... that's cyclic logic.
12:10:00 <elliott> copumpkin: http://okmij.org/ftp/Computation/lem.html
12:10:06 <elliott>      forall a. (forall m. Monad m => ((a -> m F) -> m F)) -> a
12:10:12 <copumpkin> oh, that
12:10:13 <copumpkin> yeah
12:10:15 <dylukes> Isn't a boolean algebra a special case of the field of sets under union/intersect though copumpkin?
12:10:19 <dylukes> specifically, the set {0, 1}
12:10:34 <dylukes> I don't know, that's just my thought, mind you.
12:10:37 <copumpkin> dylukes: a field requires some notion of "division"
12:11:06 <dylukes> I thought multiplication just needs to be a group
12:11:08 <copumpkin> also, it doesn't cover some of the properties that boolean algebras give you, like idempotent operations
12:11:09 <copumpkin> http://en.wikipedia.org/wiki/Boolean_algebra_(structure)
12:11:17 <dylukes> which implies inverses, which doesn't necessarily mean division...
12:11:18 <copumpkin> dylukes: which means you have division
12:11:27 <dylukes> for instance, with sets you could use their inverses.
12:11:28 <rwbarton> sometimes people (probably devious people who are trying to confuse you) use field in another context related to boolean algebra
12:11:42 <djahandarie> Damn those people!
12:11:54 <dylukes> copumpkin: I guess, then you end up with symmetric difference.
12:12:14 <dylukes> no wait
12:12:16 <dylukes> no, just the difference
12:12:58 <copumpkin> dylukes: how do you invert union?
12:13:12 <dylukes> hm true
12:13:31 <tgeeky> copumpkin: disjoint union? :o
12:13:35 <copumpkin> check out the boolean algebra structure
12:13:35 <dylukes> well, if your identity is universe, then A U A^c
12:13:37 <tgeeky> i mean, don't use union
12:13:58 <dylukes> copumpkin: Yeah, if your identity is universe, rather than null, the identity of any set is its complement.
12:14:08 <dylukes> Do the + and * relations have to share their identity?
12:14:09 <copumpkin> dylukes: identity for which operation?
12:14:11 <dylukes> for *
12:14:15 <dylukes> for + it'd be null.
12:14:17 <copumpkin> 0 and 1 aren't the same, are they? :P
12:14:23 <shachaf> copumpkin: Sure they are.
12:14:23 <tgeeky> dylukes: no
12:14:27 <shachaf> Wait, no.
12:14:31 <tgeeky> not in the Reals they aren't
12:14:34 * shachaf curses field axiom "1 /= 0".
12:14:37 <hpc> lol
12:14:43 <shachaf> Who even adds that as an axiom?
12:14:43 <dylukes> ?...
12:14:44 <lambdabot> Not enough arguments to @.
12:14:46 <copumpkin> dylukes: the null set is identity for union, so what set would you union with {1} to make {} ?
12:15:03 <dylukes> copumpkin: Why can't the universe set be the identity for union?
12:15:15 <DanBurton> copumpin: the antimatter universe?
12:15:19 <shachaf> dylukes: Because union it.
12:15:21 <copumpkin> because {1} union {everything} isn't {1}
12:15:30 <dylukes> anything union Un. = Un.
12:15:34 <shachaf> dylukes: Also, there is no universe.
12:15:40 <shachaf> My set theory book says so.
12:15:40 <copumpkin> dylukes: that isn't the definition of identity
12:15:47 <tgeeky> and note that {1} could be {6}, or {1403}, or {19}
12:15:54 <dylukes> copumpkin: ack, true
12:15:58 <copumpkin> dylukes: that's like saying 0 is an identity * because anything * 0 = 0
12:16:01 <dylukes> :P
12:16:04 <dylukes> yeah thats something else
12:16:07 <dylukes> probably a name for it too
12:16:10 <dylukes> So yeah, it'd be null...
12:16:16 <dylukes> so yeah, I guess there aren't inverses :\
12:16:26 <tgeeky> what was the original question?
12:16:32 <dylukes> nothing specfic
12:16:32 <copumpkin> whether finite sets form a field
12:16:37 <dylukes> copumpkin: but this ^
12:16:45 <copumpkin> dylukes: they do form a boolean algebra though :D
12:16:58 <dylukes> what needs to be true for something to be a boolean algenra?
12:16:58 <tgeeky> No, but finite classes can?
12:17:05 <dylukes> finite classes
12:17:06 <dylukes> ?
12:17:16 <tgeeky> the set of all heiarchical sets
12:17:17 <kmc> all finite classes are sets
12:17:24 <mkscrg> anybody know where to find attoparsec examples?
12:17:24 <copumpkin> tgeeky: what are your two operations?
12:17:28 <dylukes> What.
12:17:37 <mkscrg> maybe using it as a monad?
12:17:39 <tgeeky> copumpkin: difference and derivation
12:17:42 <dylukes> tgeeky: can you restate that?
12:17:53 <tgeeky> copumpkin: (kidding, I have no clue)
12:17:55 <tgeeky> dylukes: not really
12:18:19 <tgeeky> dylukes: kmc copumpkin : http://metu.edu.tr/~dpierce/Mathematics/Numbers/ordinals-2.2.pdf
12:18:37 <copumpkin> tgeeky: difference isn't even commutative :P
12:18:41 <tgeeky> that guy's primary research topic are the (model theory) axioms of fields
12:18:56 <dylukes> bookmark'd
12:19:04 <copumpkin> dylukes: pretty much everything you'd expect of booleans
12:19:07 <copumpkin> or sets :)
12:19:15 <tgeeky> copumpkin: I think it can actually be made so, but I'm not sure. You have to choose a set that has an exponential structure inside it
12:19:18 <copumpkin> they're pretty much the perfect structure
12:19:20 <dylukes> copumpkin: So, whats the difference between say, a ring and a boolean algebra?
12:19:29 <tgeeky> copumpkin: certainly no common number systems could be constructed this way
12:19:40 <copumpkin> dylukes: boolean algebra are more orderlike
12:19:43 <dolio> Boolean algebras are lame.
12:19:48 <dylukes> copumpkin: meaning?
12:19:49 <dolio> Heyting algebras are where the hotness is.
12:19:50 <copumpkin> the operations tend to be idempotent
12:19:54 <copumpkin> lol
12:20:09 <dylukes> "A ring in which all elements are idempotent is called a Boolean ring. It can be shown that in every such ring, multiplication is commutative, and every element is its own additive inverse."
12:20:20 <dylukes> "An idempotent element of a ring is, by definition, an element which is idempotent with respect to the ring's multiplication.[3] That is, r2 = r."
12:20:22 <dylukes> that seem right?
12:20:49 <dylukes> oh
12:20:50 <dylukes> "A Boolean ring is almost the same thing as a Boolean algebra, with ring multiplication corresponding to conjunction or meet ∧, and ring addition to exclusive disjunction or symmetric difference (not disjunction ∨), except for the fact that the absorption law is violated."
12:20:54 <dylukes> what is the absorption law?...
12:20:56 <copumpkin> http://en.wikipedia.org/wiki/Boolean_algebra_(structure)
12:20:57 <copumpkin> that thing
12:21:01 <djahandarie> dolio knows where it's at
12:21:02 <tgeeky> dylukes: zeros are absorbers
12:21:05 <rwbarton> a /\ (a \/ b) = a
12:21:13 <rwbarton> etc.
12:21:17 <rwbarton> I think
12:21:18 <dolio> I have my finger on the pulse of popular culture.
12:21:20 <dylukes> tgeeky: Would Un. be an absorber for U?
12:21:31 <copumpkin> tampax pearl
12:21:32 <tgeeky> dylukes: dunno
12:21:42 <tgeeky> dylukes: i'm being general because I'm not an expert :O
12:22:02 <dylukes> this stuff is interesting anyways
12:22:03 <dylukes> :)
12:22:22 <tgeeky> dylukes: that paper you bookmarked
12:22:33 <tgeeky> dylukes: you should read, it specifies a lot of things that are interesting to a haskeller
12:22:40 <dylukes> all my questions will he answered :0
12:22:46 <dylukes> copumpkin: btw how old are you?
12:22:55 <djahandarie> He's 13
12:23:02 <dylukes> djahandarie: ¬_¬
12:23:05 <elliott> djahandarie: oh, happy birthday copumpkin
12:23:09 <tgeeky> but that's human years, and he's a dog, so like 160
12:23:17 <elliott> I must have missed it!
12:23:20 <DanBurton> i thought he was a pumpkin
12:23:25 <elliott> Pumpkins don't age?
12:23:31 <copumpkin> dylukes: I'm 12 and what is this
12:23:47 <copumpkin> I'm actually 27 and what is that
12:24:21 <dylukes> copumpkin: okay so I have a decade to learn as much as you know now, at the very least.
12:24:24 <dylukes> I have time :).
12:24:30 <copumpkin> lol
12:24:53 <copumpkin> around here I'm on the low end of the knowledge accumulation spectrum, sadly (or luckily for me)
12:25:07 <copumpkin> one day I shall know everything though
12:25:32 <tgeeky> which will happen 2 days after neutrinos kill him
12:25:35 <djahandarie> I think you're on the high end of the knowledge accumulation rate specturm though, luckily (or sadly?)
12:25:50 <shachaf> copumpkin: You should always strive to know less than anyone around you.
12:25:53 * shachaf is very good at that.
12:25:56 <copumpkin> shachaf: I try
12:26:05 * shachaf is a little too good. :-(
12:26:08 <Eduard_Munteanu> 12 pumpkin years, of course.
12:26:29 <hpc> 12 copumpkin years
12:26:40 <djahandarie> Does he age backwards?
12:26:57 <shachaf> coage?
12:27:10 <hpc> co-forwards
12:27:17 <DanBurton> shachaf: as long as you are around very intelligent people. I wouldn't want that policy around some people..
12:27:46 <djahandarie> I on the other hand feel like no matter how much I learn I'm still dumb :P
12:27:55 <DanBurton> Haskell does that to you
12:28:01 <hpc> i prefer a channel to make me feel very dumb
12:28:07 <copumpkin> djahandarie: that's good!
12:28:09 <hpc> and another to feel very smart
12:28:19 <Eduard_Munteanu> Heh.
12:28:23 <elliott> hpc: #haskell and ##php?
12:28:30 <hpc> lol
12:28:50 <cgroza> anyone has any experience with Ocaml here? how does it compare to Haskell?
12:28:52 <djahandarie> copumpkin, is it? Learning should make me feel smarter. :(
12:28:54 <shachaf> elliott: There exist smart people who do PHP things!
12:28:54 <hpc> #haskell and -blah? ::trollface::
12:29:12 <elliott> shachaf: We refer to them as "prisoners".
12:29:13 <djahandarie> hpc, probably not a great choice considering they overlap quite a bit :P
12:29:35 <shachaf> djahandarie: It's not about the people, it's about the topic of discussion.
12:29:44 <hpc> nah, i am twice as dumb in blah as i am here
12:29:51 <copumpkin> djahandarie: well yeah, feeling dumb doesn't have to mean being dumb
12:29:55 <monochrom> feeling is illusion. learning makes you smarter, makes you feel dumber.
12:29:59 <azaq23> djahandarie: learning highlights how complex something really is and what connections there possibly may exists with other things, and because you don't have any summary about how much you know at a
12:29:59 <azaq23> given moment, it is going to make you feel dumb. heard of the impostor syndrome and the dunning krüger effect?
12:30:02 <copumpkin> in fact, many actually dumb people don't feel dumb
12:30:12 <copumpkin> that causes lots of problems
12:30:18 <monochrom> lack of learning makes you dumber, makes you feel smarter
12:30:34 <monochrom> that is the summary of all social and political problems. all.
12:30:36 <shachaf> djahandarie: Here it's all burrito tutorials, and in #-blah it's so advanced I don't even understand what's going on half the time.
12:30:42 <rwbarton> cgroza: I used Ocaml for a while before learning Haskell
12:30:43 <shachaf> Well, there might another explanation.
12:30:58 <dylukes> shachaf: I swear if I hear another burrito joke I'll unwrap your ass.
12:31:06 <copumpkin> :O
12:31:15 <djahandarie> Suddenly very erotic in here.
12:31:22 <dylukes> Not what I meant.
12:31:24 <monochrom> anyway, learning haskell requires unlearning some other things, so it makes you smarter, makes you dumber, makes you feel smarter, and makes you feel dumber
12:31:30 <tgeeky> M is for Moenad
12:31:30 <hpc> comonads are like tacos...
12:31:35 <rwbarton> has anyone written a tutorial on making burritos that explains them via the analogy with monads
12:31:43 <copumpkin> comonad
12:31:44 <copumpkin> comonad
12:31:50 <cgroza> rwbarton: and what are the main differences between ocaml and haskell?
12:31:51 <djahandarie> goose?
12:31:52 <shachaf> tacomonad?
12:32:06 <armlesshobo> monadicus
12:32:33 <hpc> shachaf: ta-comonad
12:32:53 <shachaf> rwbarton: That would be a terrible tutorials. Burritos are an abstract thing that you have to understand through consuming (many) concrete examples, not by analogy.
12:32:59 <rwbarton> cgroza: primarily that ocaml is strict and impure, while haskell is lazy and pure, which leads to a certain difference in style between the two languages.
12:33:18 <shachaf> A certain difference in style, namely that Haskell programs have some.
12:33:26 <hpc> lol
12:33:33 <cgroza> rwbarton: thank you.
12:34:01 <rwbarton> cgroza: Their type systems have a lot in common, though, and I think that Ocaml is a good language to learn about Hindley-Milner-style type systems without simultaneously being exposed to everything else that's different about Haskell, if you're used to languages like C or Java.
12:34:10 <monochrom> people make food analogies all the time. I asked "what is fois gra?" they replied "like tofu".
12:34:29 <rwbarton> (also by "Ocaml" I really mean "any language of the ML family")
12:34:36 <kmc> tastes like chicken
12:34:51 <copumpkin> foie gras
12:34:55 <copumpkin> it's nothing like tofu, sadly :(
12:35:01 <cgroza> rwbarton: thank you.
12:37:07 <lispy> Clint: oh right
12:37:23 <lispy> Clint: I've used that too but I forgot about to mention it
12:37:45 <lispy> I'm trying to 'cabal-dev install cabal-install' and it's asking for my password.  It should not need my password.  Any idea why it asks for it?
12:38:00 <lispy> I refuse to give cabal-install my password...
12:38:51 <dylukes> http://cl.ly/AODz
12:39:00 <dylukes> I think I'm pretty happy with my bookmark bar now
12:39:00 <dylukes> :)
12:39:11 <dylukes> pretty icons
12:39:38 <dylukes> I wonder if anyone can guess them all from left to right?
12:39:42 <elliott> dylukes: -blah?
12:39:46 <dylukes> oh, whoops
12:39:48 <dylukes> yeah, sorry
12:40:46 <johnkpaul> Is the best way to learn haskell the open file -> edit file -> ghci -> :l filename -> close ghci -> open file
12:40:47 <johnkpaul> loop?
12:41:04 <shachaf> johnkpaul: Why close ghci?
12:41:08 <osfameron> johnkpaul: you can keep the file and ghci open at the same time
12:41:10 <lispy> :r filename
12:41:12 <dylukes> johnkpaul: just type :r filename
12:41:20 <johnkpaul> oh
12:41:21 <dylukes> and it'll reload whatever is currently saved
12:41:22 <ClaudiusMaximus>  :set editor nano ; ;e
12:41:22 <dylukes> or just type :r
12:41:23 <johnkpaul> :) didn't know that
12:41:26 <osfameron> or just :r ?
12:41:45 <johnkpaul> thanks!
12:41:56 <johnkpaul> that definitely helps my annoyance and time
12:42:34 <johnkpaul> I haven't finishe denough of real world haskell to know why I can't define full functions easily in ghci
12:42:44 <johnkpaul> but I'll get there eventually
12:43:02 <dylukes> think of ghci as an interactive IO monad
12:43:13 <dylukes> hence, if you want to bind functions, you have to use let
12:43:20 <KirinDave> GHCi: "Your IO Monad is showing."
12:44:01 <johnkpaul> oh I see, I have to understand an IO monad first to completely understand that
12:44:23 <elliott> johnkpaul: nah, you just have to understand "do"
12:44:26 <elliott> main = do
12:44:30 <elliott>   ...
12:44:49 <KirinDave> johnkpaul: The only place where the IO monad gets tricky is with types like IO (IO a)
12:44:58 <dylukes> KirinDave: Don't bring that up .__.
12:45:01 <johnkpaul> from what I understand about do, it just takes the output of one function and immediately calls the next function with that output
12:45:17 <yshavit> I think I just had my first "thinking Haskelly" moment :) I'm following the Java lambda-dev list, and they discussed a method Collections.toMap(keyGen) which would go over a set of elements and put them into a map according to some lambda that defines a mapping. And I looked at that and said "sounds like just a fold to me"
12:45:20 <elliott> johnkpaul: No :(
12:45:28 <DanBurton> @hoogle m (m a) -> m a
12:45:29 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
12:45:29 <lambdabot> Prelude concat :: [[a]] -> [a]
12:45:29 <lambdabot> Data.List concat :: [[a]] -> [a]
12:45:37 <KirinDave> johnkpaul: The secret sauce of do is that it's making >>= and >> happen for you.
12:45:40 <dylukes> yshavit: everything with lists is a fold :3
12:45:41 <elliott> johnkpaul: I would suggest reading Learn You a Haskell before Real World Haskell, it helps you get a better handle on the basics and will hopefully make things like do notation pretty clear.
12:45:43 <yshavit> and as an exercise for myself, I tried to write such a function as a fold, and was happy to find out that I can :)
12:45:48 <KirinDave> johnkpaul: What those do depends on the context
12:45:54 <dylukes> elliott: LYAH's monad explanation is very good.
12:45:55 <elliott> KirinDave: I don't think that will help :)
12:46:07 <trinithis> So with the Haskell implementations of C types, are the sizes of them constant? Implementation dependent? For instance, does `sizeOf (0::CInt)` always equal 4?
12:46:11 <elliott> I also don't think GHCi makes more sense if you keep thinking about the word "monad".
12:46:18 <johnkpaul> :D
12:46:19 <johnkpaul> so much to learn
12:46:21 <dylukes> yshavit: You can express almost any significant list transformation (reduction specifically) as a fold .
12:46:27 <elliott> trinithis: If they didn't have the same size as the C types on every system, they'd be useless for FFI declarations.
12:46:28 <KirinDave> Yes
12:46:29 <yshavit> dylukes: yeah, point is though, I think I'm starting to get into the mindset :)
12:46:32 <johnkpaul> I thought lyah and real world hasklell were very similar
12:46:35 <elliott> johnkpaul: LYAH is free online at http://learnyouahaskell.com/ if you want to check it out.
12:46:47 <dylukes> BONUS is never on anymore :<
12:46:50 <DanBurton> RWH too.
12:46:52 * hackagebot data-type 0.1.0 - Basic type wrangling types and classes  http://hackage.haskell.org/package/data-type-0.1.0 (IainAlexander)
12:46:54 <DanBurton> @google Real World Haskell
12:46:56 <lambdabot> http://book.realworldhaskell.org/
12:46:56 <lambdabot> Title: Real World Haskell
12:46:58 <johnkpaul> elliott: I will check it out, I didn't realize it was more beginner
12:47:00 <dylukes> I prefer LYAH.
12:47:05 <johnkpaul> or written with the beginner in mind rather
12:47:10 <dylukes> RWH is better for after LYAH...
12:47:14 <yshavit> dylukes: My implementation was:  insertMap kf vf = foldr (\e-> M.insert (kf e) (vf e))
12:47:21 <yshavit> dylukes: does that look about right?
12:47:27 <elliott> DanBurton: they're already reading RWH :)
12:47:29 <dylukes> @hoogle insert
12:47:30 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
12:47:30 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
12:47:30 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
12:47:33 <lysgaard> Got a quick question: Do i have to activate haddock on my hackage package, because it shows no doc even though I've written it.
12:47:40 <elliott> johnkpaul: I think RWH is a great book, but I also think it jumps in a bit too quickly; it's best to learn the basics first.
12:47:47 <trinithis> Well then, does CDouble have the same exact semantics as Double?
12:47:53 <dylukes> I guess so.
12:47:53 <DanBurton> elliott: that's what I get for only reading half the conversation xD
12:47:57 <dylukes> looks like it, at least.
12:48:10 <johnkpaul> Thanks for all of the input! I just read through the first few paragraphs of LYAH and it is definitely more my pace
12:48:14 <elliott> johnkpaul: And don't worry, monads aren't scary, nor are they a language feature, or anything particularly special -- they're just a particularly kind of pattern/interface seen quite a lot that happen to be good at expressing state and side-effects. :)
12:48:33 <lispy> trinithis: the point of CDouble is to match C's dobule for your platform
12:48:41 <mekeor> whats LYAH?
12:48:41 <dylukes> @hoogle (a -> k) -> (a -> v) -> [a] -> X k v
12:48:42 <lambdabot> Warning: Unknown type X
12:48:42 <lambdabot> No results found
12:48:48 <dylukes> @hoogle (a -> k) -> (a -> v) -> [a] -> m k v
12:48:49 <lambdabot> No results found
12:48:55 <johnkpaul> elliott: yeah, I am not worried, I just think I have a lot to understand first before that pattern is completely innate to me
12:49:01 <elliott> yeah :)
12:49:06 <lispy> trinithis: Whereas Haskell's Double is meant to be IEEE 8 byte float
12:49:09 <johnkpaul> I have a feeling it's like calc and how everyone is worried before they take it ebcause of the culture around calculus
12:49:46 <wavewave> Learn You a Haskell
12:50:19 <wavewave> mekeor: Learn You A Haskell for Great Good!
12:50:27 <wavewave> a title of book
12:50:34 <wavewave> which is free online.
12:50:42 <wavewave> http://learnyouahaskell.com
12:50:59 <wavewave> I bought it though ;-)
12:51:06 <wavewave> for supporting the author.
12:51:45 <mekeor> wavewave: thanks.
12:52:12 <cgroza> I found Orelly book better.
12:52:32 <wavewave> Until now, I have three haskell books. : Learn You a Haskell, Real World Haskell and Pearls of Functional Algorithm Design
12:52:54 <wavewave> cgroza : Orelly book means Real World Haskell?
12:53:04 <cgroza> wavewave: yeah
12:53:21 <cgroza> wavewave: they published that book.
12:53:31 <wavewave> just a few minutes ago, there were discussion about both books.
12:54:06 <wavewave> LYAH for beginner, RWH for middle, pearls of functional algorithm maybe for advanced.
12:54:53 <kmc> @type \x -> if typeOf x == typeOf "x" then x else show x
12:54:54 <lambdabot> String -> String
12:55:05 <wavewave> I want to buy The Algebra of Programming... that's too expensive. hmm
12:55:13 <kmc> @type \x -> if typeOf x == typeOf "x" then fromJust (cast x) else show x
12:55:15 <lambdabot> forall a. (Typeable a, Show a) => a -> String
12:55:35 <kmc> @type \x -> case cast x of Just y -> y; Nothing -> show x
12:55:36 <lambdabot> forall a. (Typeable a, Show a) => a -> String
12:55:47 <cgroza> What do you suggest as a haskell project? I just read a book and need something to try my skills on...
12:55:51 <wavewave> In fact, some scheme books are good for haskell beginer.
12:56:00 <elliott> cgroza: Whatever you feel like coding.
12:56:01 <kmc> cgroza, find some software you want to write
12:56:03 <kmc> then write it in Haskell
12:56:08 <benmachine> @type \x -> liftA2 fromMaybe show cast
12:56:09 <lambdabot> forall t a. (Show a, Typeable a) => t -> a -> String
12:56:12 <benmachine> oh wups
12:56:16 <wavewave> cgroza: what you want to do most..
12:56:20 <elliott> cgroza: I like "Advice to Aimless, Excited Programmers" about this: http://prog21.dadgum.com/80.html
12:56:23 <benmachine> @type liftA2 fromMaybe show cast
12:56:24 <lambdabot> forall a. (Show a, Typeable a) => a -> String
12:56:29 <elliott> cgroza: It's basically about exactly your question.
12:56:32 <wavewave> cgroza: coding needs lots of self motivation.
12:57:18 <wavewave> but if I give you more concrete answer,
12:57:23 <kmc> elliott, nice
12:57:33 <cgroza> Well, when I learned python I made a text editor, when I learned C++ a youtube downloader.
12:57:41 <cgroza> it helped me a lot.
12:57:53 <wavewave> I suggest to have a project having some parsing.
12:58:17 <wavewave> writing a parser in haskell is a  real fun.
12:58:27 <elliott> cgroza: Well, what do you want to do this time? We could probably help point out which of your ideas are more suited to Haskell than others, but making up something from scratch is hard.
12:58:33 <wavewave> I mean using parser library..
12:58:43 <wavewave> not making it from scratch. ;-)
12:59:37 <kmc> heh http://prog21.dadgum.com/55.html
12:59:41 <wavewave> for me, when parsing, I feel real power of haskell.
13:00:08 <cgroza> How about an IRC bot. Lots of IO monad...
13:00:18 <wavewave> of course, that's not the only area where it shines.
13:00:44 <wavewave> cgroza: that would be good.
13:00:46 <kmc> i agree with this thesis; I think Haskell is the compromise the author is looking for
13:00:56 <kmc> but i'm sure 99% of people reading it will see otherwise
13:01:36 <wavewave> making IRC bot using coroutine or something like that.
13:01:44 <copumpkin> my IRC bot is pure
13:01:52 * hackagebot function-combine 0.1.0 - Combining functions  http://hackage.haskell.org/package/function-combine-0.1.0 (IainAlexander)
13:02:02 <Clint> someone should definitely make a generic ircbot library
13:02:04 <nwf> A silly categoric question: what is the common underlying endomorphism capturing IO's unsafeInterleaveIO, Reader's local, Writer's censor, and State's localState (i.e. \a -> do { s <- get; r <- a; put s; return r })?
13:02:04 <copumpkin> it consumes an infinite stream of messages and produces an infinite stream of responses
13:02:07 <wavewave> copumpkin: yes. that's what I mean..
13:02:11 <CosmicRay> Clint: XMPP too
13:02:16 <Clint> sure
13:02:42 <Clint> though i don't know of several non-reusable xmpp bots on hackage
13:02:43 <wavewave> making a seemingly IO-heavy program in pure land..
13:02:44 <nwf> copumpkin: It just happens to be hooked up to a network socket, but that's not its fault? :)
13:02:51 <kmc> it's unfortunate that Haskell is known as that pure functional language for fundamentalist weirdos
13:02:59 <kmc> i think we place too much emphasis on purity
13:03:03 <kmc> or emphasis in the wrong place
13:03:17 <wavewave> kmc: that's also true..
13:03:19 <kmc> it's not that the language *forces* pure FP style but that the libraries *allow* it
13:03:22 <nwf> Immutability Uber Alles!
13:03:27 <shachaf> > (==) "kmc" "conal"
13:03:28 <lambdabot>   False
13:03:50 <dmwit> nwf: Dunno! Let us know when you formalize it.
13:03:51 <copumpkin> I want my (==) to launch missiles
13:04:07 <nwf> dmwit: Well fooey.  I was hoping somebody already had.
13:04:13 <yrlnry> You sound to me like a guy from Massachusetts protesting that he is not a Yankee, that the real Yankees live in New Hampshire.
13:04:13 <KirinDave> I dunno, I feel like I write very imperative code in haskell
13:04:15 <wavewave> we do that since that's where haskell differ from others most.
13:04:17 <KirinDave> Sometimes too much so.
13:04:37 <kmc> yeah, Haskell is a great imperative language
13:04:49 <shachaf> I'm pretty sure Yankees live in Connecticut.
13:04:53 <kmc> i've a related objection to the way people teach and talk about the IO type
13:04:56 <DanBurton> @let _ ==* b = unsafePerformIO b
13:04:56 <lambdabot>  <local>:5:10: Not in scope: `unsafePerformIO'
13:04:56 <wavewave> pure imperative langugae
13:04:59 <copumpkin> kmc: I only program in ContT IO
13:05:28 <kmc> the whole attitude of "it's this box to prevent ugly terrible gross things from the real world from infecting our beautiful functional code"
13:05:37 <kmc> that's stupid
13:05:43 <kmc> it's an EDSL for describing imperative programs
13:05:48 <kmc> just like Parsec is an EDSL for describing parsers
13:06:00 <kmc> neither one is a contagion to be contained
13:06:07 <kmc> parsers are useful, imperative programs are useful
13:06:14 <kmc> let us be thankful that we have functional abstraction over both
13:06:18 <Saizan> kmc++
13:06:20 <yrlnry> Wadler and others have described it as a "sin bin" where we throw everything we don't know how to deal with.
13:06:40 <nwf> Well, we need _something_ to keep the mutable rifraf out of our functional code.
13:06:52 * hackagebot flexiwrap 0.1.0 - Flexible wrappers  http://hackage.haskell.org/package/flexiwrap-0.1.0 (IainAlexander)
13:06:54 * hackagebot flexiwrap-smallcheck 0.0.1 - SmallCheck (Serial) instances for flexiwrap  http://hackage.haskell.org/package/flexiwrap-smallcheck-0.0.1 (IainAlexander)
13:07:02 <copumpkin> nwf: no, we need something to describe the mutability in our functional code
13:07:09 <copumpkin> we're not explicitly keeping it out :P
13:07:13 <wavewave> I feel that our attitude against IO is some kind of insider jokes.
13:07:19 <yrlnry> There's no reason why the fourteen things in IO should all be in the same monad, except that we don't understand monad composition techniques well enough for it to be convenient to program in fourteen monads at once.
13:07:22 <nwf> I mean, I was ineed joking.
13:07:38 <DanBurton> yrlnry++
13:07:38 <nwf> I would be rather sad if IO didn't exist, but I am happy for things like ST and STM.
13:07:41 <copumpkin> yrlnry: speak for yourself
13:07:42 <wavewave> we all know monadic abstraction of IO is great.
13:07:58 <copumpkin> I work with over 9000 monads at once
13:08:05 <lispy> over 9000???
13:08:16 <DanBurton> cool story bro
13:08:16 <dainanaki> all teh monadz
13:08:20 * copumpkin nods his head solemnly
13:08:44 <lispy> copumpkin: are you these days?
13:09:00 <dainanaki> he is.
13:09:02 <trinithis> I want to craete "a/b/c/d", and only "a/b" already exists. I don't see any lib functions that do this. Do I have to use a series of doesDirectoryExist with createDirectory?
13:09:17 <yrlnry> system("mkdir -p a/b/c/d")
13:09:20 <copumpkin> lispy: that's a very existential question
13:09:23 <copumpkin> but yes, I am.
13:09:29 <yrlnry> copumpkin++
13:09:39 <kmc> ∃pumpkin
13:10:08 <wavewave> trinithis: I think you have to do if you want to use only haskell lib.
13:10:11 <lispy> copumpkin: heh, *how* :)
13:10:15 <copumpkin> oh!
13:10:18 <copumpkin> very well
13:10:20 * lispy didn't notice the typo :)
13:10:36 <copumpkin> you? are you teaching the haskell course?
13:10:38 <wavewave> trinithis: or make your own.
13:10:41 <lispy> copumpkin: did you checkout the haskell-verifier thing I showed you?
13:10:55 <lispy> copumpkin: I'm not teaching it (that I know of)
13:11:09 <copumpkin> I'm on the mailing list but the only thing I see on it are meeting announcements that I can't attend :(
13:11:09 <elliott> kmc: prog21 is a good blog indeed (re you replying to that post)
13:11:31 <trinithis> oh wait, I guess I missed System.FileSystem.createTree
13:11:34 <lispy> copumpkin: yeah, that's pretty much all we use the list for.  The github is where the action happens
13:11:36 <ClaudiusMaximus> trinithis: if i couldn't find something on hackage i'd try to create the directory, catching "not exists" exception to recurse upwards and retry
13:12:13 <elliott> I do agree with yrlnry's quote that the IO monad is an unsatisfactory model of imperative programs, though.
13:12:33 <elliott> Especially since we often use it to model not imperative programs, but operations /about/ Haskell that we don't quite understand.
13:12:34 <trinithis> or rather Fylesystem.createTree
13:12:38 <kmc> yeah
13:13:17 <kmc> developing denotational, declarative, composable (i.e. "functional") alternatives to imperative programming is an important research topic
13:13:31 <yrlnry> I would also like to point out that the notion that Haskell devotees are a bunch of crazed purity zealots is not entirely inaccurate, and is held by many Haskell programmers.
13:13:41 <yrlnry> About themselves, I mean.
13:13:48 <wavewave> Hmm. I wasn't aware of FileSystem package.
13:13:49 <kmc> but it's difficult enough that we can't simply wait for this work to be finished
13:13:51 <elliott> I'm definitely a crazed purity zealot.
13:13:51 <yrlnry> Not for nothing is Haskell's motto "failure at any cost."
13:13:55 <kmc> if we want to get anything done
13:14:13 <Nafai> Heh, I was failing at explaining to my roommate last night why purity was necessary
13:14:20 <elliott> kmc: Still, IO is IMO too big a blob.
13:14:38 <lispy> elliott: in that sense, it's a good model for what it represents :)
13:14:46 <elliott> It's nice to be able to use "advanced" techniques that aren't entirely pure before we figure out how to model them properly, but it's not very satisfactory.
13:14:55 <cgroza> Is there a digitToDouble function or I have to use read :: Doubel?
13:15:08 <elliott> And it'd be nice if "IO" meant something other than "whatever you can do in C that you can't do in pure code"; some more stratification of the different types of imperative IO would be nice.
13:15:09 <kmc> yrlnry, there's an Overton window problem.  the norm in the programming world is to use mutation in every data structure and every function for no good reason.  so the idea "let's use mutation only when it captures what we actually mean" is seen as an unreasonable extremist position
13:15:38 <DanBurton> cgroza: digit to double? so you want something with a signature Char -> Double ?
13:15:45 <cgroza> DanBurton: yes.
13:15:49 <lispy> elliott: I wish ST was used more frequently (when it's apporpriate)
13:15:52 <pikhq> elliott: I doubt anyone here disagrees, really.
13:15:54 <DanBurton> @hoogle Char -> Double
13:15:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:15:58 <lambdabot> Prelude error :: [Char] -> a
13:15:58 <lambdabot> Prelude read :: Read a => String -> a
13:16:03 <kmc> and since the Overton window is all about perception and discourse, I'm suggesting that the way *we* talk about IO and Haskell has an effect here
13:16:03 <yrlnry> kmc:  That seems plausible.
13:16:12 <DanBurton> @hoogle Char -> Int
13:16:13 <lambdabot> Data.Char digitToInt :: Char -> Int
13:16:13 <lambdabot> Data.Char ord :: Char -> Int
13:16:13 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
13:16:13 <pikhq> IO is really more of the Single Big Hack in Haskell semantics.
13:16:14 <elliott> lispy: Me too.
13:16:15 <wavewave> I usually follow prototyping in IO conveniently and  refactor repetitive tasks with some abstraction
13:16:27 <elliott> lispy: But most sin-bin operations don't quite fit into ST either.
13:16:30 <elliott> StableNames, for instance.
13:16:42 <kmc> elliott, agreed that IO should be split into various different EDSLs, but that's a separate issue
13:16:46 <elliott> It sucks that observable sharing is only doable from inside IO, too.
13:16:47 <elliott> kmc: Right.
13:16:53 <kmc> they'd all still be EDSLs for imperative programming
13:17:00 <kmc> (in various restricted forms)
13:17:02 <DanBurton> @let digitToNum = fromIntegral . digitToInt
13:17:03 <lambdabot>  Defined.
13:17:06 <kmc> ST and STM are popular examples of that
13:17:11 <elliott> kmc: Still, there's lots of things in IO that aren't about imperative programming at all, they're just impure.
13:17:20 <DanBurton> > digitToNum '3' :: Double
13:17:23 <lambdabot>   3.0
13:17:27 <elliott> Observable sharing isn't imperative by any means, and it doesn't have any "side effects", it's just not referentially transparent.
13:17:33 <kmc> *nod*
13:17:36 <Nafai> elliott: do you think they should be in another Monad instead?
13:17:53 <elliott> Nafai: Would that help? You'd still have to run it somehow, and if you could erase it completely, it'd break referential transparency.
13:18:02 * Nafai nods
13:18:09 <DanBurton> cgroza: how's that for you?
13:18:14 <elliott> I guess it'd be nice if we had a bunch of monads that could be run inside only IO -- random number generation is one example -- but I can't help but feel there's a "real" solution we're missing.
13:18:16 <elliott> I don't know what it is though :)
13:18:20 <kmc> *nod*
13:18:24 <kmc> further study is required :)
13:18:25 <lispy> I guess my mental model is partly to blame too.  I tend to think of things as pure/not-pure and that mapps to non-IO/IO
13:18:28 <elliott> At least, it would be nice if you could unsafePerformObservableSharing.
13:18:35 <elliott> And be guaranteed that no "nasty" IO was happening.
13:18:55 <kmc> you can provide that guarantee with a tiny wrapper module by futzing with the export list
13:18:56 <cgroza> DanBurton: perfect
13:19:00 <cgroza> DanBurton: thanks
13:20:01 <kmc> \x y -> case reallyUnsafePtrEquality# x y of 0# -> False; _ -> True
13:20:04 <wavewave> by the way, in what cases, do we need observable sharing except some debug purposes?
13:20:12 <elliott> kmc: You want StableNames for observable sharing.
13:20:13 <kmc> isn't that effectively "unsafePerformObservableSharing"
13:20:23 <kmc> oh, hmm
13:20:25 <kmc> yeah
13:20:35 <elliott> kmc: And yeah, I was going to use a random number generation monad as an example where having it be a separate monad actually made sense, but for random number generation, unsafePerformIO is... iffy.
13:20:36 <kmc> wavewave, for efficiently implementing EDSLs
13:20:48 <parcs> where can i find reallyUnsafePtrEquality#
13:20:52 <kmc> GHC.Prim
13:20:57 <elliott> kmc: I guess it's OK as long as it's just used as a seed to something which somehow is more efficient given a random number.
13:21:04 <elliott> But it's weird that it mutates something you can observe everywhere in IO.
13:21:29 <parcs> hah, awesome
13:21:51 <kmc> wavewave, if i write «let v = f x in v + v» then in Haskell evaluation this only computes "f x" once.  but if I'm computing EDSL terms then I can't tell that the two sides of (+) are the same term, so my EDSL loses sharing
13:21:52 * hackagebot uuagc-cabal 1.0.0.7 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.7 (ArieMiddelkoop)
13:22:10 <kmc> bbl
13:22:24 <wavewave> kmc: can't we use some memoization there?
13:24:28 <glguy> kmc: You want "observable sharing"
13:24:41 <wavewave> kmc: I guess you are using data-reify for that.
13:25:40 <glguy> OH
13:25:51 <glguy> I didn't actually read more than the last thing you wrote :)
13:26:18 <wavewave> glguy: I was asking in what circumstances we need observable sharing.
13:26:35 <glguy> Did you read this? http://www.ittc.ku.edu/csdl/fpg/sites/default/files/Gill-09-TypeSafeReification.pdf
13:26:38 <wavewave> since that topic came out for discussion about IO
13:27:02 <wavewave> glguy: that's the base paper of data-reify package.
13:27:08 <wavewave> right?
13:27:33 <slack1256> guys , anybody has used lazy-pattern matching?
13:27:42 <glguy> I don't know, I just remembered that Andy had written it. I don't know what library went with it
13:27:43 <slack1256> i dont know when or where to use it
13:27:49 <wavewave> I am thinking of implementing it without IO.
13:28:18 <wavewave> glguy: data-reify is right. now I checked it.
13:29:09 <wavewave> slack1256: I haven't used it, but I saw some example in network programming.
13:30:07 <slack1256> wavewave: don't recall some website or tutorial on the subject
13:30:21 <wavewave> I am looking for it.. so long time ago.
13:30:25 <slack1256> everyone i read just name or avoid it
13:30:34 <slack1256> *name it
13:33:36 <glguy> slack1256: MonadLib uses it to avoid adding unnecessary strictness to its operations if you want some examples
13:33:42 <glguy> http://hackage.haskell.org/packages/archive/monadLib/3.6.2/doc/html/src/MonadLib.html
13:34:36 <kmc> yeah, that's a good paper glguy
13:34:44 <kmc> i was going to recommend it but couldn't remember the author or title :/
13:34:53 <lcfrs> this may be a silly question, but is there a way to determine if two functions are equivalent? kind of like, (+) == (+) would return True, and (+) == (-) would return False?
13:35:06 <c_wraith> There is not
13:35:14 <ciaranm> lcfrs: define equivalent
13:35:36 <kmc> lcfrs, http://hackage.haskell.org/package/enumerable
13:35:37 <lcfrs> ok, thought not
13:35:50 <kmc> one must distinguish "intensional equality" and "extensional equality"
13:35:55 <glguy> lcfrs: you can write that function if you only operate on finitely large types
13:36:03 <slack1256> isn't lcfrs question one about alfa-reduccion?
13:36:13 <glguy> say for boolean functions, you can quickly test them on all inputs
13:36:19 <wavewave> slack1256: I found the example
13:36:20 <kmc> intensional means like the exact same function defined in the same place.... so if i wrote f x y = x + y then you'd have f ≠ (+)
13:36:26 <ciaranm> glguy: why do you think it's quick?
13:36:27 <kmc> which is weird and breaks equational reasoning
13:36:29 <glguy> but for integers you'll only be able to show that they aren't the same through search
13:36:30 <slack1256> glguy: thanks, this is something of "realworld" i can read
13:36:33 <wavewave> slack1256: that's in gentle introduction to haskell.
13:36:36 <lcfrs> ciaranm: right that's the trouble in it
13:36:57 <kmc> lcfrs, extensional means "gives the same output for every input" which is the nicer notion of function equality, but you can't reliably test it
13:37:04 <ciaranm> glguy: what if your functions don't terminate for certain inputs?
13:37:05 <slack1256> wavewave: aaa that tutorial! i will check right now
13:37:13 <wavewave> http://www.haskell.org/tutorial/haskell-98-tutorial.pdf
13:37:17 <lcfrs> kmc ok good to know
13:37:24 <wavewave> some client-server simulation.
13:37:38 <kmc> you can probably get intensional equality with GHC hax
13:37:40 <wavewave> I don't know whether this is realistic, though.
13:37:50 <lcfrs> i think i'm thinking of a reference to a function, though, which is perhaps not a haskell notion
13:37:57 <kmc> something like http://mainisusuallyafunction.blogspot.com/2010/11/obtaining-name-of-function-in-haskell.html
13:38:21 <benmachine> slack1256: you can sometimes get extensional equality of functions on infinite domains
13:38:23 <glguy> ciaranm: They your equality function will be similarly partial
13:38:37 <glguy> ciaranm: which you obviously have no problem with because you went and wrote the partial function in the first place
13:39:01 <benmachine> slack1256: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
13:39:09 <benmachine> slack1256: warning: may break brain
13:39:10 <kmc> «(==) `on` Vac.getInfoPtr» should suffice to tell you if two functions came from the same lambda term in the source code, basically
13:39:21 <kmc> (you probably want to pseq them first)
13:39:41 <kmc> i'm sure there are optimizations which break this as well
13:39:49 <kmc> yeah, that blog post is O_O
13:40:13 <elliott> kmc: it's not so O_O for the nat case once you realise that your function has to be total on conats
13:40:24 <elliott> so you /know/ it can only ever descend down a finite number of Succs
13:40:28 <slack1256> benmachine: don't worry, i have read lolcode
13:40:29 <kmc> right
13:40:38 <elliott> it's still cool though :)
13:41:09 <kmc> total functions of type «(Natural -> Bit) -> Bool» are isomorphic to binary trees where each interior node is labeled with a Natural and the leaves with Bools
13:41:28 <kmc> i think the author gives the explicit isomorphism in a later post
13:41:50 <wavewave> Gentle introduction to haskell, yet another haskell tutorial, Why Functional Programming Matters..
13:42:18 <wavewave> those should have been remarked when talking about good books.
13:43:24 <wavewave> I also found "A History of Haskell: Being Lazy With Class" by SPJ was also quite useful after knowing it.
13:43:27 <glguy> slack1256: lazy patterns come up when tying knots, too. http://www.haskell.org/haskellwiki/MonadFix
13:43:56 <glguy> slack1256: without the lazy pattern in an mfix use on a tuple you'd loop trying to match on the (,) too early
13:44:09 <kmc> or on regular fix
13:44:40 <kmc> > fix (\(~(odds, evens)) -> (map succ evens, 0 : map succ odds))
13:44:41 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
13:44:46 <kmc> > fix (\(odds, evens) -> (map succ evens, 0 : map succ odds))
13:44:50 <lambdabot>   mueval-core: Time limit exceeded
13:44:50 <wavewave> some days ago, I mentioned "Implementation of Functional Programming Languages" by SPJ. That's also a kind of must-read to understand haskell eval model.
13:45:24 <augur> sooo
13:45:27 <augur> ftl neutrinos
13:45:48 <kmc> sooo haskell?
13:46:00 <erus`> I need some good arguments to start with haskell obsessives> any good troll bait?
13:46:01 <wavewave> yet.. we have to wait for real confirmation.
13:46:09 <kmc> erus`, what is wrong with you
13:46:13 <wavewave> in fact, that's my field..
13:46:16 <copumpkin> why is unsafeSTToIO unsafe?
13:46:38 <tac-tics> copumpkin:  I'm gonna guess something something concurrency
13:46:42 <glguy> (guessing) because it isn't atomic?
13:46:50 <slack1256> glguy: you are right, about (,)
13:46:53 <KirinDave> erus`: "Lazy evaluation was haskell's biggest mistake. Name one programmer who hasn't been puzzled by non-evaluating code or crazy memory usage."
13:46:56 <glguy> err, not STM :)
13:46:58 <kmc> it's safe if you instantiate s to RealWorld
13:47:12 <wavewave> KirinDave: I do not agree. ;-)
13:47:19 <KirinDave> wavewave: INDEED SIR
13:47:31 <KirinDave> wavewave: Although why it is fallacious is a subtle point, I believe. :)
13:47:37 <kmc> did erus` just ask #haskell to troll itself? and it's working?
13:47:41 <kmc> this is a new low people
13:47:54 <KirinDave> kmc: if you cannot name the bad parts of your tools, you are not keeping a clear head about them. :)
13:47:57 <c_wraith> but we want to be accomodating
13:47:58 <erus`> people in #haskell seem to be immune
13:48:02 <KirinDave> kmc: Also, laughing at the things you love, etc.
13:48:05 <erus`> but on reddit....
13:48:09 <glguy> copumpkin: did you read this? http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg03555.html
13:48:26 <wavewave> KirinDave: I agree that laziness is difficult. but once knowing it, the pattern is always similar.
13:48:43 <KirinDave> wavewave: Ehh, any of that aside
13:48:53 <KirinDave> wavewave: Laziness is a deign choice that enables some pretty amazing code.
13:49:03 <kmc> erus`, reddit is full of idiots.  don't waste your time with them
13:49:05 <KirinDave> wavewave: The idea that it must be a free lunch to have value is a classic logical fallacy.
13:49:08 <wavewave> KirinDave: I think the fallacy is from lack of good tools.
13:49:15 <kmc> less so /r/haskell but maybe that's just because i agree with them :)
13:49:17 <KirinDave> Excluded middle, it's called.
13:50:13 <copumpkin> glguy: oh, fair enough
13:50:32 <kmc> the Internet is like one of those arcade games where enemies spawn forever at an increasing rate
13:50:34 <kmc> you can't win
13:50:46 <kmc> it's only a question of how many quarters you waste before you get sick of it
13:50:58 <Cale> It's closer to a free lunch than an even tradeoff, I think.
13:50:59 <wavewave> KirinDave: I do not care about 'logical' thing. but I think the lazy evaluation is a valuable thing.
13:51:04 <tac-tics> kmc: The Internet is Nintendo Hard
13:51:07 <KirinDave> wavewave: I do too.
13:51:19 <KirinDave> I just am proud to be able to dismiss the argument on a purely logical basis.
13:51:26 <kmc> trying to educate people on /r/programming about Haskell or really any development in programming languages in the past 40 years is doomed
13:51:29 <KirinDave> Lazy evaluation is not a 'free lunch' but it is a great tool.
13:51:36 <KirinDave> Same with LOTS of ideas.
13:51:45 <wavewave> KirinDave: agree.
13:51:50 <Cale> Well, it's at least 75% free ;)
13:52:01 <erus`> kmc haskell guys get trolled so hard when they post on r/programming
13:52:05 <erus`> it makes me smile
13:52:10 <wavewave> KirinDave: it is actually very very expensive lunch... but very upscale ;D
13:52:20 <tac-tics> Lazy evaluation is a pain in the ass, but Haskell is pretty cool otherwise
13:52:25 * tac-tics ducks
13:52:40 <benmachine> I think it's reasonable to call lazy evaluation controversial
13:52:53 <benmachine> and not in the way that "not being an idiot" is controversial :P
13:53:02 <Cale> In that in more than 3/4 of the possible cases, lazy evaluation either does better than strict evaluation or is equivalent to it.
13:53:03 <monochrom> I am not puzzled by lazy evaluation's non-evaluating thingies and crazy memory thingies. but I am do not call myself a programmer, so I guess I don't qualified
13:53:08 <Cale> So it makes sense as a default
13:53:08 <monochrom> s/qualified/qualify/
13:53:18 <erus`> tbh i would use haskell for everything if it wasnt so awkward to inter-operate with stateful libraries
13:53:42 <tac-tics>  3/4 weighted in regard to usage? Or weighted by constructor count?
13:53:54 <wavewave> erus`: in what sense, is it awkward?
13:54:08 <erus`> like opengl for example
13:54:08 <Cale> Well, I should really explain better :)
13:54:27 <glguy> Cale: funny he should ask, eh?
13:54:36 <wavewave> erus` : would you explain more?
13:54:40 <erus`> sometimes you have to pass a pointer to an integer to a function. And in C you just store the int on the stack
13:54:53 <Cale> We can categorise data as either "small" or "large" according to the number of separately evaluable parts that it has.
13:54:57 <erus`> but with haskell you have to wrap the entire thing in a alloca blah
13:55:04 <erus`> for each new value
13:55:14 <glguy> erus`: but you only have to do that wrapping once, right?
13:55:18 <glguy> and then you just keep reusing it?
13:55:22 <erus`> for each value
13:55:31 <wavewave> erus`: that's actually semantically correct, isn't it?
13:55:46 <erus`> yeah but it just seems ugly
13:55:55 <tac-tics> erus`: Boxing optimization, brohan ;)
13:55:57 <glguy> erus`: I mean you write the wrapper function once which calls the function and you never see the alloca again
13:56:16 <erus`> glguy: well yes i could wrap OpenGL
13:56:25 <wavewave> erus`: yes. I did it before.
13:56:27 <erus`> so thats 1 library and 48 hours down
13:57:00 <wavewave> change String to CString for all
13:57:58 <glguy> erus`:So the question really becomes, are you doing something complicated enough that that 48 hours is going to dominate the project or not
13:58:13 <benmachine> the real question is, isn't OpenGL wrapped already :P
13:58:22 <Cale> So there are 4 cases for any given computation: for small -> small, strict and lazy are about the same, for small -> large, lazily producing a result is better than forcing all the evaluation at once, for large -> large, lazy is better (even if you can't produce the result in a streaming fashion, not having it all in memory at once is going to be good, generally)
13:58:55 <erus`> benmachine: yeah it is but the matrix operations are so confusing now i long for the original api
13:58:58 <glguy> Cale: lazy evaluation is best 50% of time because there are 2 cases, the cases where it is the best and the cases where it is not the best
13:59:02 <Cale> and for large -> small, there are a couple cases -- if you're searching through the large thing for a small part of it, then lazy is better
13:59:13 <Cale> but in other cases, that's where you want strictness
13:59:24 <tac-tics> Cale: You're talking about general data sizes, yeah?
13:59:24 <benmachine> glguy++
13:59:32 <Cale> tac-tics: Roughly
13:59:49 <Cale> tac-tics: I'm really talking about how many separate pieces the data is made of
14:00:02 <Cale> that we could potentially evaluate separately
14:00:32 <wavewave> probably, we can solve the problem using 'optimal evaluation' (sorry for coming up with this subject again. )
14:00:44 <benmachine> hah
14:00:53 <benmachine> we can solve the problem by doing it better
14:01:06 <dolio> Do you mean optimistic?
14:01:10 <tac-tics> Doesn't knowing the best way to evaluate something imply you've already solved it?
14:01:17 <tac-tics> In the general case*
14:01:24 <wavewave> dolio: it's different.. there is optimistic eval, and optimal eval.
14:01:26 <tac-tics> (get off my ass, math people, lol!)
14:01:33 <glguy> tac-tics: I want one of those
14:01:46 <dolio> What is optimal? Always magically choose the right strategy?
14:01:46 <glguy> a language with already solved it evaluation
14:01:53 <Cale> erus`: What's confusing about the OpenGL matrix operations?
14:02:03 <tac-tics> glguy: You could probably use Agda for that.
14:02:11 <wavewave> dolio: see http://thyer.name/phd-thesis/thesis-thyer.pdf
14:02:13 <Cale> erus`: Other than the fact that OpenGL matrices are confusing as fuck to begin with?
14:02:21 <tac-tics> glguy: But you'd never end up writing anything useful under that evaluation strategy ;(
14:02:22 <erus`> i couldnt work out how to setMatrix() last time i tried using hOpenGL
14:02:28 <Cale> oh, really?
14:02:30 <Cale> It's easy
14:02:35 <erus`> because they got rid of that function
14:02:43 <wavewave> dolio: it's maximal reduction of expression with still maximal sharing.
14:03:35 <glguy> maximal sharing sounds like a good way to use more swap space...
14:03:52 <wavewave> if we change our evaluation scheme from WHNF lazy eval to HNF lazy eval,
14:04:07 <wavewave> we can automatically get foldl' from foldl definition.
14:04:18 <Cale> You can just set currentMatrix with $=
14:04:26 <Cale> If that's what you want to do
14:04:35 <slack1256> but we would lose all you (awesome) ADT
14:04:38 <Cale> (That's a little uncommon to actually do though.)
14:04:54 <dolio> wavewave: Okay. Fancy.
14:04:55 <erus`> well it was at the time. the docs were not very clear at all
14:04:56 <slack1256> what kind of lazy person when decide to do something would do it all the way down?
14:05:18 <erus`> i use opengl raw when i need to do anything with graphics these days
14:05:43 <Cale> Odd.
14:05:45 <wavewave> I think some limited scope of higher laziness can be useful.
14:05:59 <slack1256> erus`:spartan
14:06:26 <wavewave> maybe it's rewriting RTS though.
14:06:55 <Cale> I haven't used OpenGL that much before, except that I've written a little bit of OpenGL code for the game we're working on, and the Haskell binding seems pretty straightforward to use, apart from the fact that OpenGL sucks to begin with.
14:07:32 <Cale> (It's way too stateful)
14:07:59 <Cale> OpenGL is so stateful, you can't even read all of the state without changing state :P
14:08:26 <Cale> But thankfully the library provides lots of with* style functions for adjusting things locally.
14:08:33 <parcs> how is directx in comparison?
14:08:40 <Cale> preservingMatrix is really good
14:08:41 <wavewave> openGL is like IO monad?
14:08:56 <tac-tics> Cale: That model is good enough for particle physics, it's good enough for OpenGL ;)
14:09:19 <Cale> wavewave: It's all in the IO monad, of course.
14:09:47 <Cale> wavewave: But there are degrees of statefulness here :P
14:09:53 <wavewave> tac-tics: are you doing particle physics?
14:10:57 <grglr> wavewave: I'm guessing it was just a heisenberg joke.
14:11:27 <wavewave> glglr: ahh. i see.
14:11:46 <Cale> For example, OpenGL has this concept of the "current" matrix which the only operations for reading and updating the matrices will use. So you have to change the current matrix, then read, and then change it back, if you don't want to affect the state.
14:12:02 <wavewave> I am desperately looking for particle physicists who knows haskell.
14:12:02 <Cale> Just to read! :)
14:12:10 <tac-tics> wavewave: No, apparently OpenGL is :)
14:12:19 <tac-tics> Particles are neat, though
14:12:45 <Cale> It kinda has the feel of operating on a Rubik's cube, where to change things in the way you want, you have to change other things, and then put them back again after.
14:13:35 <wavewave> Cale: yeah. we can rearrange OpenGL to several stacks of monad layers.
14:14:03 <Cale> Sure, but I'm not convinced we want a monad at all.
14:14:03 <wavewave> probably
14:14:23 <wavewave> Cale: in fact, we need. before fully lazy evaluation. ;-)
14:14:31 <Cale> ?
14:14:50 <Cale> I can't parse that
14:14:52 <wavewave> a kind of joke.
14:15:01 <wavewave> but i mean...
14:15:09 <wavewave> opengl has lots of matrix operations
14:15:19 <wavewave> which has lots of sharing inside.
14:15:43 <wavewave> if you do not carry global state, losing sharing leads to inefficiency.
14:16:12 <wavewave> just lazy evaluation model is not enough for that.
14:16:15 <Cale> I'm not convinced :)
14:16:21 <Cale> But maybe
14:16:51 <Cale> Maybe an Arrow if you care about sharing.
14:17:06 <wavewave> yeah.. maybe.
14:18:05 <wavewave> for example, if you consider matrix inversion.
14:18:09 <wavewave> for determinant,
14:18:14 <wavewave> for inverse,
14:18:26 <wavewave> or for just simple checking of rank of matrix.. SVD....
14:18:33 <Cale> But a scene to be drawn is more or less a big composition of geometry and textures, and the operations should act on scenes in a compositional way.
14:18:34 <wavewave> you are doing the same operation.
14:18:54 <wavewave> Cale: in fact, that's inefficient.
14:19:03 <Cale> I don't see why it should have to be
14:19:47 <wavewave> I just make an example of matrix inverse.
14:20:03 <wavewave> in some operation, you need det,
14:20:14 <wavewave> some operation, you need full inverse...
14:20:16 <Cale> Store more data?
14:20:32 <wavewave> but they are actually from the same algorithm.
14:20:53 <wavewave> so without sharing, you are doing the same calculation several times.
14:21:04 <wavewave> you need a global state for efficiency.
14:21:13 <wavewave> not truly composable.
14:21:13 <Cale> I don't see why that's true
14:21:28 <Cale> Why not just share those results then?
14:21:44 <wavewave> yes.. that's what I mean... you have to share those result.
14:21:59 <wavewave> you have to keep those global states.
14:22:11 <Cale> If you care about those results, you can locally store a matrix as a record consisting of the plain entries together with the results of all these other operations.
14:22:16 <edwardk> wavewave: "optimal evaluation" is fairly brittle
14:22:43 <Cale> and they'll only be evaluated if they're needed, and once they're evaluated, they'll remain so
14:22:47 <wavewave> Cale: so that's what I mean by losing some composability.
14:23:03 <Cale> Hm?
14:23:18 <wavewave> for example, checking orientation and checking intersection of line and face
14:23:30 <wavewave> can be logically separate step.
14:23:43 <wavewave> so you can implement those separately.
14:23:49 <Cale> yes
14:24:01 <Cale> (I don't see what this has to do with anything)
14:24:06 <wavewave> but later on.. ah.... you realise they should share states...
14:24:28 <Cale> What states?
14:24:32 <wavewave> then you design things with shared states again..
14:25:01 <wavewave> hmm... checking orientation does not have to have determinant calculation exposed outside.
14:25:05 <wavewave> in its meaning.
14:25:28 <wavewave> but for efficiency you need to do that.
14:26:24 <wavewave> since you do not know what calculation will be reused later.
14:26:33 <Cale> So keep the determinant with the matrix.
14:26:44 <wavewave> you should expose every intermediate step outside.
14:26:45 <Cale> In a possibly not-yet-evaluated form
14:26:53 <Cale> and then if it's evaluated, it'll be shared
14:27:03 <wavewave> then it's nothing but global state.
14:27:10 <Cale> Not global state
14:27:29 <Cale> It's as local as can be. It's kept with the matrix being operated on.
14:27:34 <wavewave> problem is haskell lazy evaluation cannot share expression inside function inside function.
14:27:39 <Cale> http://i.imgur.com/WtGEC.jpg
14:27:58 <wavewave> with WHNF evaluation.. it stops when it meets lambda.
14:29:02 <wavewave> i.e. scope of sharing is limited in a single function
14:29:21 <Cale> wavewave: It doesn't evaluate under lambdas, but that doesn't mean sharing can't tie things together in a broader scope.
14:29:40 <wavewave> if  f calls g and inside g, you calculate det. and f need det.. then it will calculate det again.
14:29:42 <edwardk> wavewave: the thunks for things under the lambdas can be constructed in a higher scope
14:29:46 <Cale> Anything which has been passed a reference to something shares evaluation which has been done to that thing.
14:30:18 <edwardk> lifting of common sub-expressions that don't rely on the lambda argument out of the lambda is a fairly common optimization
14:30:21 <Cale> So if you're passing to these functions a reference to the determinant of the matrix in question (perhaps inside the datastructure used to represent the matrix), then they'll share it.
14:30:57 <wavewave> edwardk: I found CSE optimization is not that successful in current ghc.
14:31:15 <Cale> We can guarantee in this way that any matrix has its determinant evaluated at most once as long as it remains in scope.
14:31:20 <edwardk> i would presume that is because in the benchmark suite it doesn't pay off
14:31:28 <Cale> (as long as the matrix does)
14:32:05 <Cale> Even if GHC doesn't do CSE (except in an extremely trivial case), you can do it by hand.
14:32:13 <wavewave> Cale: so I think you are actually talking the same thing as me.. just expose the intermediate calculation as a parameter.
14:32:24 <Cale> and you can design your datastructures such that operations on them get memoised
14:32:33 <wavewave> I am rewrapping that as a state monad.
14:32:38 <Cale> (like the determinant)
14:32:42 <Cale> there's no need for state!
14:32:52 <Cale> You can just use laziness
14:32:52 <wavewave> reader monad..
14:32:59 <Cale> No monads at all :)
14:33:09 <edwardk> wavewave: or just let bind it outside so the shared thunk gets evaluated and reused
14:33:09 <wavewave> anyway..... that's what i mean.
14:33:31 <Cale> The statefulness inside the implementation of lazy evaluation is all the statefulness you need in order to implement memoisation of operations.
14:33:37 <wavewave> edwardk: so you have to expose the shared thunk as a free variable.
14:33:39 <edwardk> foo x = let all the stuff that depends on x in \y -> …
14:34:08 <Cale> wavewave: You *kind of* do, but what I'm proposing is just to add a field to your matrix datatype
14:34:08 <wavewave> I am not considering expression in foo...
14:34:26 <Cale> wavewave: So that all matrices implicitly carry along their determinant (in initially-unevaluated form)
14:34:43 <Cale> and then the code which uses matrices will look the same
14:34:58 <wavewave> I am considering expression only in foo.. expression in function called in foo.
14:35:02 <Cale> but the determinant, once computed, will be shared with all future determinants computed on that matrix
14:36:09 <wavewave> Cale: hmm that's rather overkill.. to make every datatype with accompanied eval memoization.
14:36:18 <Cale> wavewave: Maybe, maybe not.
14:36:42 <Cale> wavewave: If what you're talking about is worth doing in the first place, it's probably reasonable.
14:37:01 <wavewave> Cale: anyway I think I expressed my point and you seem to get it.
14:37:12 <Cale> I think the problem is solved by lazy evaluation :)
14:37:18 <wavewave> how to solve it is the next problem.
14:37:42 <wavewave> I do not object to it. I am explaining my joke in detail. ;-)
14:37:52 <Cale> Also, this is somewhat unrelated, but have you seen Data.MemoCombinators?
14:38:04 <wavewave> Yes. I know of it.
14:38:10 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.2/doc/html/src/Data-MemoCombinators.html
14:38:25 <Cale> yeah, it's a completely pure implementation of function memoisation :)
14:38:34 <wavewave> edwardk: BTW, would you tell me what's the brittle point of optimal evaluation?
14:39:09 <edwardk> have you seen luqui's vatican?
14:39:12 <erus`> haskell should pinch the ... notation from agda
14:39:20 <Cale> which just takes advantage of the fact that under lazy evaluation (and GHC evaluation, which isn't quite the same as lazy), the parameters to a function are evaluated at most once.
14:39:50 * Cale looks for vatican on hackage
14:39:55 <Cale> edwardk: no ;)
14:40:00 <wavewave> edwardk: I was chatting with him last night.
14:40:15 <wavewave> edwardk what's vatican?
14:40:21 <edwardk> https://github.com/luqui/vatican
14:40:30 <edwardk> does thyer style evaluation
14:40:49 <Cale> LUQUI, Y U PUT ON GITHUB BUT NOT HACKAGE?
14:41:19 <wavewave> hmm.... by the way, luqui was luke palmer?
14:41:25 <Cale> yes
14:41:37 <Cale> He's also responsible for the Data.MemoCombinators library
14:41:56 <edwardk> wavewave: yes
14:42:04 <wavewave> I was chatting with him like Luke Palmer was 3rd person. puhaha.
14:42:11 <edwardk> heh
14:42:44 <wavewave> anyway: would you proceed about optimal eval?
14:43:08 <wavewave> this github is really nice.
14:43:08 <clsmith> hmm, i don't seem to be able to add type annotations for '<-' variables in do blocks?
14:43:24 <wavewave> I am also wondering if thyer has his own github.
14:43:27 <danr> clsmith: put them after the <- instead
14:43:36 <wavewave> or whatever..
14:43:39 <danr> or use ScopedTypeVariables (or someone correct me here)
14:43:56 <edwardk> see some notes in http://lukepalmer.wordpress.com/2009/07/07/emphasizing-specialization/ about how fix gradually specializes its way to oblivion. what i'm looking for was a paper i read on the ways it goes wrong, and in particular which interpreter extensions it explodes on
14:44:10 <clsmith> :r
14:44:13 <clsmith> oops, sorry ;p
14:44:52 <benmachine> ScopedTypeVariables is correct, I think
14:45:02 <edwardk> wavewave: there is also a theoretical result that shows that _truly_ optimal order lambda evaluation is impossible or intractable, so be warned you're just trading in one set of limitations for another ;)
14:45:11 <benmachine> or you can annotate the usage site instead
14:45:32 <danr> > do {  x <- return 42 :: IO Double ; print x }
14:45:34 <lambdabot>   <IO ()>
14:45:35 <wavewave> hmmm I see.. I need to think about it.
14:45:51 <edwardk> i'd personally suggest going through the literature, seeing what low hanging fruit you can find, but i would say your best bet is to play with it, but don't bet your career on it ;)
14:46:12 <wavewave> I am considering applying this to some particle physics calculation.
14:46:41 <clsmith> hmm, when i try afterwards, typing as '[Eg]' gives expected 'IO a', and 'IO [Eg]' gives expected '[Eg]' :/
14:46:51 <wavewave> because Feynman diagrams are really sharing its structure recursively
14:46:51 <edwardk> and regarding the determinant case. adding a thunk-valued-slot to memoize across long distances is a good idea.
14:46:51 <clsmith> i'll try ScopedTypeVariables...
14:47:13 <edwardk> i'm about to post an article on using packrat parsing in parsec that is effectively all about that ;)
14:47:16 <wavewave> edwardk, Cale: I admit that in fact.
14:47:37 <wavewave> although I said it's overkill for the sake of argument ;-P
14:47:51 <clsmith> same problem with ScopedTypeVariables
14:48:18 <wavewave> it's like putting value in another box. ;-)
14:48:28 <edwardk> clsmith: get creative with argument plumbing and find a way to bind the two together with asTypeOf
14:48:49 <edwardk> wavewave: more like giving the value a place to go once its needed and a place to go look for it
14:49:38 <wavewave> edwardk: yes, exactly... I have to think about it in my library design.
14:49:46 <edwardk> my charsets in trifecta currently hold onto a lazily computed 'first-set' for which head bytes they accept for instance.
14:50:02 <clsmith> :r
14:50:12 <clsmith> okay, i'm going to move this window so i stop doing that
14:50:16 <edwardk> i also used to use this to compute a bunch of expensive numbers like pop counts, etc for my old bit sets
14:50:50 <wavewave> edwardk: I am looking forward to seeing your comonad typeclassopedia, soon..
14:51:05 <benmachine> clsmith: paste some code!
14:51:09 <edwardk> i should probably try to sit down with byorgey again
14:51:19 <benmachine> make sure the value GHC is objecting to in the error message is actually the same one
14:51:35 <byorgey> edwardk: ?
14:51:54 <edwardk> re accumulating info about all the crazy category theoretic packages i have
14:52:03 <wavewave> edwardk : can this putting-value-with-thunk idea have the corresponding comonad? kk
14:52:06 <byorgey> edwardk: ah, right. still on my list.
14:52:41 <edwardk> wavewave: yes and no. you can carry around extra stuff using the product comonad, but its not tied to the argument which is parametric
14:52:53 <edwardk> so after a map the answers don't make sense
14:54:54 <wavewave> how is it going to make a GUI library using cofree comonad?
14:55:06 <hpaste> erus` pasted “is this ugly code?” at http://hpaste.org/51709
14:55:20 <ddarius> cofree comonad = process tree = model of concurrency
14:55:36 <ddarius> s/concurrency/concurrent computation/
14:56:14 <wavewave> in some sense, GUI is concurrent computation. Every object is autonomous.
14:56:36 <erus`> wow i got my interpreter down to like 100 LOC
14:56:54 <erus`> nice
14:57:26 <wavewave> erus` : for me, it doesn't look particularly ugly.
14:58:04 <wavewave> rather out of context to judge anything , though ..
15:00:47 <wavewave> gotta go have dinner.
15:01:01 <wavewave> good discussion, see ya guys.
15:06:08 <mkscrg> attoparsec question: i've got a (Parser ByteString) that parses off the first two bytes, and a (Parser a). how do i feed those first two bytes to the (Parser a)?
15:08:31 <hpc> \first second -> action?
15:08:48 <ion> @type (>>=) -- mkscrg
15:08:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:08:58 <hpc> yes, that
15:09:55 <mauke> I don't see how that helps
15:10:02 <mkscrg> me neither?
15:10:27 <mkscrg> paste on the way
15:10:30 <mauke> why do you have a Parser ByteString and a Parser a?
15:10:52 <byorgey> what is a Parser a?  It can parse something of any type?
15:10:58 <ion> I assumed the latter is actually ByteString → Parser something.
15:11:17 <byorgey> we all know what assuming does ;)
15:11:49 <mkscrg> by (Parser a) i meant for some type a that doesn't matter
15:11:51 <mauke> I read "a (Parser a)" as exists a. Parser a
15:12:00 <mkscrg> right-o
15:12:01 <parcs> fmap (runParser p2) p1
15:12:01 <byorgey> mkscrg: ah, ok
15:12:01 <ion> :-D
15:12:13 <hpc> Parser WhoGivesACrap?
15:13:19 <byorgey> mkscrg: so you want to "layer" the parsers? so the first parser is parsing some input stream, and the second parser is parsing the output of the first parser?
15:13:32 <hpaste> mkscrg pasted “Parser WhoGivesACrap” at http://hpaste.org/51710
15:13:52 <mkscrg> byorgey: exactly that
15:13:56 <keep_learning> does Linux (x86_64) only works on amd 64 bit architecture or it can also be installed for intel 64 bit ?
15:14:17 <parcs> intel 64 bit is amd 64 bit
15:14:24 <mkscrg> maybe there's an easier way to make hexadecimal only eat the first two bytes
15:14:42 <keep_learning> parcs, thank you
15:14:47 <byorgey> mkscrg: hmm, I don't think this has anything to do with parsers, you just need to convetr the ByteString bs to a Word8
15:14:51 <byorgey> *convert
15:15:40 <mkscrg> wouldn't parsing bs into a Word8 using Attoparsec.Char8.hexadecimal be a good way to do that?
15:15:40 <byorgey> mkscrg: why pack it as a ByteString?  Why not just return [Word8], or (Word8, Word8)?
15:16:41 <byorgey> mkscrg: I don't know exactly what you're trying to do, but you just need to come up with a function of type  ByteString -> Word8  which does the conversion you want
15:16:58 <byorgey> mkscrg: then in place of -- now what?  you can just write   return (myConversionFunction bs)
15:17:58 <mkscrg> right. it would be "easy" to write that conversion function outright. it would have to deal with upper/lowercase hex digits, bounds check the bytes accordingly, etc. i'm trying to leverage the hexadecimal function here
15:18:14 <mkscrg> which parses a bytestring into a Word8 (or any other instance of Bits)
15:18:31 <byorgey> mkscrg: but it might read more than two bytes?
15:18:54 <mkscrg> this is the problem. i want to feed exactly two bytes to hexadecimal and i don't know how
15:19:11 <byorgey> mkscrg: well, how do you run an attoparsec parser?
15:19:24 <mkscrg> (the real idea here is to parse a six-digit hex number into (Word8, Word8, Word8)
15:19:24 <byorgey> is there some  'runParser' function or something like that?
15:19:41 <mkscrg> runParser is defined in the source but i don't think it's exposed
15:19:41 <byorgey> you can just  (runParser hexadecimal bs)  or whatever
15:19:47 <mkscrg> at least not documented
15:19:50 <mkscrg> i'll check
15:20:02 <byorgey> I don't care what it's called, you have to be able to run parsers somehow
15:20:13 <byorgey> how were you planning to run your hexWord8 parser?
15:20:48 <mkscrg> runParser is the accessor for the Parser type
15:20:51 <mkscrg> and it's not exported
15:21:21 <mkscrg> you run a parser with parse :: (Parser a) -> ByteString -> Result a
15:21:21 <byorgey> well don't worry about that.  The point is there must be some function to run a parser, i.e. turn it into a function  input -> output
15:21:47 <byorgey> right, ok.  so you need something like  unsafeProjectFromResult hexadecimal bs
15:21:57 <byorgey> where unsafeProjectFromResult is something appropriate
15:22:03 <mkscrg> yeah, i agree
15:23:06 <mkscrg> gotta run, going to tackle this thing later
15:23:11 <mkscrg> thanks, all
15:40:34 <Masxmasx{AFK}> noob question: how to have something in a guard match anything? eg: f | variable == (0 : xs)
15:40:56 <hpaste> erus` pasted “an error” at http://hpaste.org/51711
15:41:05 <erus`> what am i doing wrong there?
15:41:47 <mauke> erus`: $
15:42:14 <erus`> ah
15:42:19 <erus`> thanks mauke
15:42:55 <glguy> zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
15:43:08 <glguy> Those helpful warnings at the bottom missed this one
15:43:35 <sm> ocharles: hi, did you ever make that org-mode parser for pandoc ?
15:43:41 <kmc> Masxmasx{AFK}, I don't quite follow
15:44:00 <Masxmasx> I'm not AFK
15:45:33 <erus`> zipWIth is nice :)
15:45:46 <Masxmasx> kmc: I want to recognise the way a list is built, I have: function list | list == (0 : anotherFunctionThatGeneratesAListOfInts : xs) = False
15:45:53 <Masxmasx> kmc: I want the xs to be able to match anything
15:46:14 <Masxmasx> I thought I could do that with _, but apparantly I can't do that in expressions.
15:46:20 <kmc> right
15:46:32 <benmachine> Masxmasx: so tell me more about anotherFunction
15:46:35 <kmc> the guard is an expression of type Bool, it's not a pattern
15:46:55 <kmc> maybe you want something like:  function (0 : y : xs) | y == otherFunction  =  False
15:46:59 <Masxmasx> benmachine: just a function creating a list of 0s and 1s
15:47:11 <Masxmasx> hmm
15:47:13 <Masxmasx> that'd work
15:47:16 <Masxmasx> thanks, gonna try :)
15:48:18 <benmachine> Masxmasx: so you want to test if "list" starts with 0 and then a list of some kind?
15:48:30 <benmachine> er, a specified list
15:48:37 <Masxmasx> yes, that's not a problem per se, but I want it to end with anything
15:48:42 <benmachine> right
15:48:44 <Masxmasx> I don't care about how it ends basically
15:48:47 <benmachine> I think I'd do something like
15:48:57 <benmachine> function (0 : xs) = zipWith (==) xs otherFunction
15:49:17 <kmc> Maxdamantus, you can't use (0 : y : 1) to match a list like [0, 2, 4, 5, 1]
15:49:21 <benmachine> the zipWith will automatically only check as many elements are in otherFunction (which isn't actually a function, here, but never mind)
15:49:32 <kmc> (:) is not (++)
15:49:34 <Masxmasx> not, kmc?
15:49:38 <Masxmasx> ah shit.
15:49:44 <kmc> it matches elements one at a time from the left
15:50:01 <kmc> [0,1,2,3]  is sugar for  0 : (1 : (2 : (3 : [])))
15:50:01 <benmachine> kmc is correct
15:50:17 <Masxmasx> wouldn't it be possible to use ++ instead of : then?
15:50:23 <kmc> not in a pattern
15:50:31 <Masxmasx> argh.
15:50:31 <kmc> you can't pattern-match on arbitrary functions
15:50:39 <kmc> only on the constructors of the data type you're interested in
15:50:58 <kmc> Masxmasx, if i wrote f (xs ++ ys)  = ...,  how would it know how to split up the list?
15:50:59 <hpc> more generally, how would you know where to "split" the list with (++)?
15:51:02 <kmc> there's many different possibilities
15:51:13 <kmc> you can do this in logic languages like Prolog
15:51:18 <kmc> but it's kind of a whole different ball game
15:51:20 <Masxmasx> I'd want it to try every possibilities, but i was thinking prolog :p
15:51:25 <hpc> ah
15:51:28 <Masxmasx> possibility*
15:51:38 <kmc> Masxmasx, lists aren't made to be matched / manipulated from the end, anyway
15:51:47 <ddarius> Curry, a functional logic language, does support exactly such patterns.
15:51:54 <copumpkin> factor (x * y) = (x, y)
15:51:57 <hpc> [] is a monad that does more or less what you want that way
15:52:59 <hpc> > (+) <$> [1,2,3,4,5] <*> [10,20] -- also an applicative...
15:53:00 <lambdabot>   [11,21,12,22,13,23,14,24,15,25]
15:53:13 <copumpkin> factor (suc (suc x) * suc (suc y)) = Right (suc (suc x), suc (suc y)); factor x = Left x
15:53:17 <copumpkin> there we go
15:53:32 <Masxmasx> Is there a default function in haskell that would tell me if a list is a sublist of another list?
15:53:42 <kmc> Data.List.isInfixOf
15:54:20 <benmachine> > [1,2,3] `isInfixOf` [4,1,2,3,9]
15:54:21 <lambdabot>   True
15:54:27 <Masxmasx> ah, excellent
15:54:34 <Masxmasx> then I don't have to try to write that myself :)
15:54:36 <Masxmasx> thanks a lot
15:54:46 <hpc> there's also isPrefixOf and isSuffixOf
15:55:02 <kmc> @src isInfixOf
15:55:03 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
15:55:11 <kmc> this is not too efficient
15:55:14 <hpc> as i understand it, isInfixOf and isSuffixOf are both fairly slow
15:55:16 <hpc> yeah
15:55:21 <kmc> smart string-search algorithms are somewhat complicated
15:55:25 <kmc> there are implementations on hackage
15:55:40 <hpc> @src isPrefixOf
15:55:40 <lambdabot> isPrefixOf [] _          = True
15:55:41 <lambdabot> isPrefixOf _  []         = False
15:55:41 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
15:58:01 <Masxmasx> isInfixOf is not in scope, is it not preloaded in the prelude?
15:58:08 <kmc> import Data.List
15:58:24 <Masxmasx> I'm not sure if I'm allowed to do that, it's an exercise
15:58:33 <kmc> then you can write it yourself
15:59:05 <Masxmasx> hmyeah :)
16:14:05 <matthew-_> who's the Haskell guy at City Uni, London?
16:14:10 <matthew-_> patterson?
16:24:37 <ocharles> sm: Hi, I didn't get very far with it :(
16:24:58 <ocharles> just kinda gave up on that project
16:29:22 <DukeDave> Erm, is there anything like a findM ?
16:29:47 <DukeDave> I have: [a], (a -> m Bool)
16:31:36 <hpc> :t find
16:31:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:31:48 <hpc> @src find
16:31:49 <lambdabot> find p          = listToMaybe . filter p
16:31:55 <hpc> :t filterM
16:31:56 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
16:31:59 <DukeDave> It seems someone else agrees: http://www.mail-archive.com/haskell-cafe@haskell.org/msg02242.html
16:32:11 <hpc> findM p = fmap listToMaybe . filterM p
16:32:27 <hpc> er, s/fmap/liftM/ to keep class constraints short
16:32:39 <DukeDave> hpc: Sexy :)
16:32:48 <DukeDave> Although, what do you mean by your last statement?
16:33:11 <hpc> Monad doesn't imply Functor, so the fmap would turn the type to
16:33:18 <hpc> (Monad m, Functor m) => ...
16:33:37 <hpc> it /should/ imply Functor, but hysterical raisins...
16:33:40 <elliott> (Monad does imply functor, just not in Haskell.)
16:33:54 <DukeDave> )
16:34:02 <DukeDave> Oh, I've seen this come up before :)
16:34:28 <hpc> ideally, the heirarchy would go
16:34:32 <hpc> Functor, Pointed
16:34:37 <hpc> Pointed => Applicative
16:34:45 <hpc> Pointed, Functor => Applicative --er, this
16:34:52 <hpc> Applicative => Monad
16:35:01 <elliott> hpc: I'm not sure I agree about Pointed.
16:35:18 <hpc> elliott: it makes it so every class defines only one method
16:35:22 <hpc> which is kind of nice
16:35:46 <hpc> but yeah, pointed's only real property is a free theorem :P
16:35:54 <elliott> hpc: Sure, but that isn't really true in general, so.
16:36:04 <elliott> hpc: Admittedly sometimes you can get ap without pure.
16:36:08 <hpc> elliott: really?
16:36:22 <hpc> i thought there was always an instance where point = pure
16:36:26 <elliott> hpc: Yeah. (,) without Monoid.
16:36:32 <elliott> I mean ap, not Applictive.
16:36:34 <ion> > [pred, id, succ] <*> [10, 20, 30]
16:36:36 <lambdabot>   [9,19,29,10,20,30,11,21,31]
16:36:50 <elliott> At least I think (,) without Monoid. I forget.
16:36:57 <hpc> elliott: oh, right
16:37:03 <ion> Oh, i misinterpreted what elliott said.
16:37:12 <hpc> point x = (mempty, x)
16:37:13 <elliott> :)
16:37:31 <copumpkin> edwardk: looks like a bunch of kind polymorphism commits just went into the ghc-kinds branch on ghc :)
16:37:36 <hpc> good catch; i forget some of these silly exceptions
16:37:39 <edwardk> sweet
16:37:57 <edwardk> we'll have to add it back into our compiler ;)
16:38:30 <copumpkin> lol
16:38:31 <elliott> hpc: but then I'm not sure that has (<*>) either.
16:39:02 <elliott> hpc: Oh, I think it was (Map k).
16:39:13 <elliott> That has a (<*>), but no pure.
16:39:15 <hpc> elliott: wouldn't it be (x, f) <*> (_, y) = (x, f x)?
16:39:27 <elliott> hpc: Does that obey the laws? (Trick question: without pure, what /are/ the laws?)
16:39:38 <elliott> But yeah, (Map k) has (<*>) I think, it's like ZipList.
16:39:47 <elliott> But obviously no pure.
16:40:20 <hpc> elliott: wow, that's annoying
16:40:44 <elliott> Of course, you wanted (Functor, Pointed) => Applicative, so Pointed being separate does not help here :)
16:41:03 <elliott> I think you can come up with laws for (<*>) given fmap, but they won't be as strong as the ones with pure.
16:43:12 <hpc> @let (<.>) f g = pure (.) <*> f <*> g
16:43:13 <lambdabot>  Defined.
16:43:17 <hpc> :t (<.>)
16:43:18 <lambdabot>     Ambiguous occurrence `<.>'
16:43:18 <lambdabot>     It could refer to either `L.<.>', defined at <local>:6:0
16:43:18 <lambdabot>                           or `Data.VectorSpace.<.>', imported from Data.VectorSpace
16:43:23 <DukeDave> Damn, every time I think I understand the Typeclassopedia you guys make me feel stupid again ;)
16:43:25 <hpc> D:
16:43:27 <hpc> @undefine
16:53:17 <freeasjesus> :t showln  = (++ "\n") . show
16:53:18 <lambdabot> parse error on input `='
16:53:46 <freeasjesus> :t tail'   = last
16:53:47 <lambdabot> parse error on input `='
16:54:07 <freeasjesus> :t tr a b = interact (map f) where f c = if c == a then b else c
16:54:08 <lambdabot> parse error on input `='
16:54:23 <shachaf> > (`shows` "\n") "abc"
16:54:24 <lambdabot>   "\"abc\"\n"
16:55:12 <freeasjesus> :t grep = filter (isPrefixOf "foo")
16:55:13 <lambdabot> parse error on input `='
16:56:41 <freeasjesus> :t main = do
16:56:41 <freeasjesus>     who <- getProgName
16:56:41 <freeasjesus>     maybe (return ()) id $ lookup who $
16:56:41 <freeasjesus>         [("blank",       io blank                  )
16:56:41 <freeasjesus>         ,("cksum",       interact (showln . cksum) )
16:56:42 <lambdabot> parse error on input `='
16:56:42 <freeasjesus>         ,("clean",       io clean''                )
16:56:44 <freeasjesus>         ,("echo" ,       interact id               )
16:56:46 <freeasjesus>         ,("drop",        interact drop'            )
16:56:48 <freeasjesus>         ,("grep",        io grep                   )
16:56:50 <freeasjesus>         ,("grep -v",     io grep_v                 )
16:56:52 <freeasjesus>         ,("head",        io (return . head')       )
16:56:54 <freeasjesus>         ,("join",        io join                   )
16:56:56 <freeasjesus>         ,("num",         io num                    )
16:56:58 <ion> ...
16:57:00 <freeasjesus>         ,("remove",      io (remove "str")         )
16:57:02 <freeasjesus>         ,("revw",        io rev_w                  )
16:57:04 <freeasjesus>         ,("reverse",     io rev                    )
16:57:06 <freeasjesus>         ,("reverseword", io rev_w                  )
16:57:08 <freeasjesus>         ,("rpt",         io rpt                    )
16:57:10 <freeasjesus>         ,("sort",        interact sort             )
16:57:13 <freeasjesus>         ,("space",       io space                  )
16:57:14 <freeasjesus>         ,("tac",         interact tac              )
16:57:16 <freeasjesus>         ,("take",        io take'                  )
16:57:18 <freeasjesus>         ,("tail",        io (return . tail')       )
16:57:20 <freeasjesus>     --  ,( "tr"  ,    interact tr)
16:57:22 <freeasjesus>     --  ,( "tr -d",   interact (tr_d . unwords))
16:57:24 <freeasjesus>         ,("unspace",     io unspace                )
16:57:26 <freeasjesus>         ,("upper",       interact upper            )
16:57:31 <freeasjesus>         ,("uniq",        interact uniq             )
16:57:32 <kmc> stop pasting
16:57:33 <freeasjesus>         ,("wc_c",        interact wc_c             )
16:57:34 <freeasjesus>         ,("wc_l",        interact wc_l             )
16:57:35 <freeasjesus>         ,("wc_w",        interact wc_w             )
16:57:37 <freeasjesus>         ]
16:57:40 <freeasjesus> crap!
16:57:40 <kmc> @where ops
16:57:41 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
16:57:41 <freeasjesus> sorry, tried to copy paste something but it went wrong...
16:57:45 <Jafet> Can we kill him for three days?
16:57:46 <kmc> ok, no worries
16:57:47 --- mode: ChanServ set +o copumpkin
16:57:51 --- mode: copumpkin set +b *!~lau@38.72.96.58.static.exetel.com.au
16:57:51 --- kick: freeasjesus was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
16:57:53 <kmc> i think it's over ;P
16:57:55 <kmc> :(
16:57:56 <copumpkin> oh
16:58:07 --- mode: copumpkin set -b *!~lau@38.72.96.58.static.exetel.com.au
16:58:12 <mauke> <freeasjesus> sorry, tried to copy paste something but it went wrong...
16:58:12 <kmc> a kick to get someone's client to shut up should be distinguished from a kick to make the person shut up
16:58:44 --- mode: copumpkin set -o copumpkin
16:58:46 <mauke> yeah, in that case I usually just kick (or mute)
16:59:01 <mauke> (the problem is that some clients autorejoin and continue pasting)
16:59:07 <copumpkin> lol
16:59:16 <mauke> I don't know what their authors were thinking
16:59:17 <monochrom> too bad
16:59:57 <monochrom> not a case of "late action better than no action"! :)
17:00:19 <copumpkin> freeasjesus: sorry about that
17:00:24 <copumpkin> delayed reaction on my part :P
17:00:25 <Eduard_Munteanu> freeasjesus: use a pastebin
17:00:32 <freeasjesus> copumpkin: sorry guys
17:00:50 <Eduard_Munteanu> @where hpaste
17:00:50 <lambdabot> http://hpaste.org/
17:01:02 <freeasjesus> Eduard_Munteanu: Thanks :) Will use this
17:01:20 <Eduard_Munteanu> Some clients actually warn you if you're going to paste more than n lines.
17:01:32 <Eduard_Munteanu> (and wait for confirmation)
17:01:35 <mauke> (paste detection)++
17:01:59 <freeasjesus> Eduard_Munteanu: I should write a module to do it. It'll give me something to do
17:02:17 <Eduard_Munteanu> freeasjesus: oh, heh, what client are you using?
17:02:23 <mauke> xchat
17:02:28 <Eduard_Munteanu> Ah.
17:03:22 <ion> Some clients also display the process of emptying the outgoing buffer in realtime and let you pause or cancel it quickly. I don’t actually know such a client, but if i were to implement one, that would be one of the essential features. :-P
17:03:29 <mauke> I use paste_verify_line_count = 2 in irssi
17:03:51 <mauke> ion: irssi only lets you purge the buffer AFAIK
17:04:40 <ion> It does indeed, but it doesn’t display the outgoing lines when it’s actually sending them.
17:05:31 <mauke> yeah, it's write-only
17:05:32 <elliott> ion: That would be disorienting, having a delay before I see my lines. If it was something you could view separately (with a counting-down progress bar shown everywhere) that would be OK.
17:05:54 <elliott> I guess there'll be no delay unless you're already flooding.
17:06:02 <elliott> Since it's queue-emptying, not network-delay.
17:07:00 <ion> I’d display the lines at the bottom of the window with slightly different formatting and the predicted future timestamps and with a horizontal line between the actual messages. When they’re sent one by one, they’re moved to the normal area.
17:07:19 <ion> between them and the actual messages
17:07:24 <freeasjesus> What's your opinions of open-source?
17:07:41 <Eduard_Munteanu> #haskell-blah might be better for that
17:08:12 <freeasjesus> Eduard_Munteanu: thanks ;)
17:08:12 <elliott> freeasjesus: I think it's terrible. I use absolutely no open source software, which is why I don't use any existing Haskell implementation :-)
17:08:29 <elliott> I'm waiting for the GHC devs to smarten up and start selling it without releasing the source. :p
17:09:47 <ion> Your license doesn’t allow ViewPatterns. Please update to the Advanced Programmer license at http://www.haskell.org/
17:10:24 <elliott> :D
17:10:27 <mauke> did you mean: http://sales.haskell.com/
17:10:40 <elliott> http://haskell.com/en/ <- future sellers of GHC
17:10:54 <MichaelBurge> If I'm using the Writer monad to record events, and I use filterM to select valid elements from a list, do events recorded in invalid elements still get added to the Writer?
17:11:11 <elliott> ion: you have to become a Haskell Certified Engineer to use UndecidableInstances
17:12:41 <monochrom> pay me cdn$100 or us$1000 for a tutorial on lazy evaluation
17:13:10 <mauke> .oO( ... "any questions?" )
17:13:16 <monochrom> haha
17:13:30 <elliott> MichaelBurge: No.
17:13:30 <monochrom> it is not a lazy tutorial!
17:13:33 <elliott> Or, hmm.
17:13:40 <elliott> MichaelBurge: Do you "tell" in the filterM function?
17:13:45 <elliott> Oh, I see.
17:13:48 <elliott> :t filterM
17:13:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
17:14:06 <elliott> MichaelBurge: Yeah, unless you "tell" in the filterM function, nothing monadic will happen.
17:14:37 <mauke> MichaelBurge: yes
17:14:50 <elliott> filterM (\q -> do x <- lookup q; if isGood x then tell x >> return True else return False)) xs -- MichaelBurge: Only the good elements will be added to the Writer here
17:14:54 <elliott> unless lookup adds to the Writer too...
17:23:16 <bzbee> ClaudiusMaximus: ATTENTION: #caretown has moved to #gnaa
17:23:45 <copumpkin> o.O
17:24:28 <byorgey> copumpkin: ATTENTION: #frisbees has moved to #fgpj
17:24:38 <shachaf> That person just finished pinging a few screenfuls of people in #ruby.
17:25:00 <copumpkin> shachaf: pre-emptive ban?
17:25:40 <shachaf> I don't know if they'll be back.
17:25:50 <Eduard_Munteanu> In that case it might be better to take this to Freenode staff.
17:26:42 <Eduard_Munteanu> He's probably going to jump around other channels doing the same thing.
17:29:38 <hpaste> DukeDave pasted “Typeable troubles” at http://hpaste.org/51712
17:29:48 <DukeDave> Is this complete madness ^
17:30:32 <DukeDave> Context: I'm trying to wrap wxAny for wxHaskell
17:30:38 <shachaf> DukeDave: Looks like you're missing a constraint.
17:30:47 <shachaf> DukeDave: Other than that, yes, it probably is madness.
17:31:08 <DukeDave> shachaf: I'm getting: Parse error in pattern: typeOf
17:31:16 <shachaf> Oh, er, yes, that too.
17:31:19 <shachaf> That's not a pattern.
17:31:27 <DukeDave> Yeah, I thought so
17:31:41 <DukeDave> Do you know how I could do this wizardry?
17:31:46 <shachaf> > let x = 4 in case 5 of { x -> "foo" } -- You can only match on patterns, not expressions.
17:31:47 <lambdabot>   "foo"
17:31:53 <DukeDave> I looked at Data.Typeable's 'cast'
17:31:54 <shachaf> DukeDave: You can use cast or something like that.
17:32:06 <DukeDave> But then I got scared
17:32:07 <shachaf> Are you sure you *want* this wizardry?
17:32:21 <shachaf> DukeDave: cast ought to be less scary than typeOf.
17:32:54 <DukeDave> Well, there's this wxAny object, which can be 'anything' in C++ land, and I'm trying to marshall it in to Haskell
17:33:32 <shachaf> "anything"?
17:33:54 <shachaf> How is this object used?
17:34:02 <DukeDave> Read it and weep: http://docs.wxwidgets.org/2.9.2/classwx_any.htmlhttp://docs.wxwidgets.org/2.9.2/classwx_any.html
17:34:09 <DukeDave> I rather like " The wxAny class represents a container for any type.   Its value can be changed at run time, possibly to a different type of value."
17:34:27 <DukeDave> shachaf: Well I've come upon it whilst wrapping something called wxPropertyGrid
17:34:47 <DukeDave> It looks like this: http://wxpropgrid.sourceforge.net/propertygrid_msw.png
17:35:17 <DukeDave> Now when someone changes something on there, a call back is fired, but the value of the thing which changed could be anything
17:35:53 <DukeDave> I.e: Int, string, colour, date, favourite pizza
17:36:03 <shachaf> DukeDave: Why do you need a toAny function?
17:36:17 <shachaf> Assuming you're going to be using the data type Any, i.e., will only need Strings and Ints.
17:36:52 <DukeDave> Well, I'd like to add more to it later
17:36:52 <vermeille> Hail !
17:37:16 <Eduard_Munteanu> All hail hypnotoad!
17:37:29 <byorgey> is there a standard package on Hackage with a semiring type class?
17:37:32 <vermeille> Well, I have an issue, cabal install gtk doesn't installs Glade support
17:37:35 <DukeDave> shachaf: And in any case, wxHaskell's "automagic type marshalling" seems to require a function of that type
17:37:40 <Eduard_Munteanu> Maybe an existential would do?
17:37:44 <byorgey> I found the 'semiring' package but it seems to be somewhat specialized
17:37:47 <shachaf> DukeDave: A function of what type?
17:37:56 <DukeDave> a -> Any
17:38:05 <MichaelBurge> elliott: The "tell" happens if the predicate in filterM returns false.
17:38:22 <DukeDave> shachaf: Then it uses TH to simplify other code
17:38:32 <shachaf> DukeDave: Not even Typeable a =>?
17:38:45 <shachaf> DukeDave: Wait, where the type Any defined? Isn't it in your code?
17:39:36 <DukeDave> shachaf: It is
17:39:44 <byorgey> vermeille: cabal install glade?
17:39:54 <Eduard_Munteanu> byorgey: http://hackage.haskell.org/packages/archive/algebra/2.0.1/doc/html/Numeric-Rig-Class.html    maybe this?
17:40:13 <shachaf> So why does wx require a function of type a -> Any?
17:40:45 <Eduard_Munteanu> edwardk's stuff looks pretty standard to me :P
17:40:49 <vermeille> ( byorgey omg... I'm on this issue for hours... And I didn't even think to that...)
17:41:00 <byorgey> vermeille: oh, I see glade support is now included in gtk, in Graphics.UI.Gtk.Builder
17:41:07 <edwardk> ?
17:41:13 <byorgey> vermeille: what do you mean, it "doesn't install Glade support"?
17:41:38 <byorgey> edwardk: best Hackage package with a semiring type class?
17:41:51 <Eduard_Munteanu> edwardk: oh, byorgey asked for a "standard" package containing semirings
17:41:53 <vermeille> byorgey: It works with cabal install glade. Thanks you.
17:41:53 <edwardk> Numeric.Rig.Class in algebra is my gold standard at the moment
17:42:21 <edwardk> lots of superclasses but it lets me be pedantic
17:42:45 <vermeille> I'm just gutted, I didn't saw and think that a glade package existed
17:42:50 <vermeille> Thank you, really
17:43:08 <byorgey> vermeille: sure.  I didn't know either, I just looked on Hackage and searched for 'glade'
17:43:23 <byorgey> edwardk: cool, thanks.
17:44:25 <copumpkin> who was talking about a goto monad?
17:45:04 <vermeille> byorgey: Yeah, I supposed that it was included with gtk and some mailing lists spoke about configure gtk package etc...
17:45:24 <parcs> edwardk: i see that the superclasses of Semiring are Additive, Abelian, Multiplicative. isn't Additive redundant there given that the superclass of Abelian is Additive?
17:45:39 <edwardk> yes
17:45:50 <parcs> intentional?
17:46:13 <edwardk> for a while Abelian was going to just require a weaker class like power associative or alternative
17:46:26 <parcs> oh
17:46:35 <edwardk> i apparently left a vestige of that around
17:48:57 <Eduard_Munteanu> The semiring/rig distinction seems confusing.
17:49:02 <Eduard_Munteanu> Or rather, lack of.
17:49:33 <kmc> say I want a polymorphic function which acts like id for String, and like 'show' for other types
17:49:42 <kmc> (i know it's kind of the wrong thing to want)
17:49:53 <kmc> should i use OverlappingInstances? Typeable?
17:50:17 <kmc> i vaguely recall seeing this in some package
17:50:25 <shachaf> Typeable seems pretty simple.
17:50:52 <edwardk> Had i thought of it earlier i could have named trifecta kessel run. at this point it looks like it'll contain at least 12 parsecs.
17:51:03 <kmc> haha
17:51:16 <deech`>  I am trying to install the xmonad-contrib package and getting an error about "Ambiguous module Prelude ... found in multiple packages: base haskell98-2.0.0.0". I recently upgraded to 7.2.1. Could this be the cause?
17:51:16 <shachaf> @remember edwardk Had i thought of it earlier i could have named trifecta kessel run. at this point it looks like it'll contain at least 12 parsecs.
17:51:16 <byorgey> kmc: in that particular case (since String is a concrete monomorphic type) OverlappingInstances should work OK too.
17:51:16 <lambdabot> Done.
17:51:21 <hpaste> copumpkin pasted “goto” at http://hpaste.org/51713
17:51:43 <kmc> i'm actually leaning towards Typeable... but it might be my irrational anti-typeclass bias :)
17:51:58 * shachaf decides not to tell kmc what Typeable is.
17:52:06 <Eduard_Munteanu> Heh.
17:52:08 <kmc> ;)
17:52:16 <kmc> what i had earlier was
17:52:23 * shachaf doesn't like OverlappingInstances.
17:52:28 <kmc> :t \x -> case (cast x) of Just y -> y; Nothing -> show x
17:52:29 <lambdabot> forall a. (Typeable a, Show a) => a -> String
17:52:41 <ivanm> edwardk: as in you're implementing 12 different parsing libraries? :/
17:52:50 <byorgey> kmc: yep, that looks reasonable
17:53:03 <edwardk> as in it is designed such that you can swap out the primitive parser type pretty easily
17:53:10 <kmc> :t let f (cast -> Just x) = x; f y = show y in f
17:53:11 <lambdabot>     Illegal view pattern:  (cast -> Just x)
17:53:11 <edwardk> so i'm currently adding packrat, gll, etc.
17:53:11 <lambdabot>     Use -XViewPatterns to enable view patterns
17:53:12 <ivanm> deech`: possibly
17:53:16 <deech`> Whoops, wrong channel.
17:53:36 <ivanm> edwardk: oh?  still try-based semantics rather than commit-based though?
17:53:56 <edwardk> of course
17:54:08 <gienah> deech`: the approach I normally use is to hack the .cabal file to remove haskell98, then hack the source to make it compile
17:54:14 <shachaf> kmc: Oh, that's a nicer implementation than mine.
17:54:17 <edwardk> well, gll will just backtrack and get you all the answers in O(n^3) worst case, but O(n) for the LL(1) fragments
17:54:23 <shachaf> kmc: In the Ruby spirit you could call that function to_s.
17:54:34 <deech`> gienah: The same package just installed this morning on a machine running 6.12.3
17:54:58 <edwardk> i do intend to add a polyparse compatibility layer though
17:55:06 <gienah> deech`: right, its a change in ghc 7.2.1 that it does not seem to like haskell98 anymore
17:55:28 <ivanm> deech`: yeah, but haskell98 didn't used to have Prelude
17:55:37 <ivanm> the new version that ships with 7.2.1 does
17:55:49 <ivanm> (I'm guessing a snapshot for backwards compatability)
17:56:16 <kmc> shachaf, yeah, this is the more common behavior of show-like functions in other languages
17:56:17 <ivanm> deech`: is this when compiling contrib, or just for your xmonad.hs?
17:56:29 <kmc> Python distinguishes str() and repr(), which is nice
17:56:45 <ivanm> because -contrib doesn't ahve a dep on haskell98
17:57:15 <shachaf> kmc: Yes, Ruby has to_s and inspect.
17:57:31 <shachaf> As ugly as to_s is, I must admit it's convenient.
17:57:40 <shachaf> E.g. everything is to_sed in string interpolation.
17:57:49 * shachaf wonders whether kmc is doing string interpolation.
17:57:55 <Jafet> But why do you want a special case for String
18:01:25 <kmc> shachaf, guilty as charged
18:01:36 <kmc> how did you guess?
18:04:40 <shachaf> It's the kmc thing to do.
18:05:06 <kmc> oh dear
18:05:10 <DukeDave> shachaf: Sorry about that afk, in answer to your question: I need a function a -> Any because I'm trying to closely follow the exiting code in wxHaskell..
18:07:14 <shirt> @seen Cale
18:07:14 <lambdabot> Unknown command, try @list
18:07:14 <preflex>  Cale was last seen on #haskell 3 hours, 25 minutes and 43 seconds ago, saying: He's also responsible for the Data.MemoCombinators library
18:09:18 <Cale> hello
18:10:33 <Cale> shirt: hello
18:10:48 <shirt> Cale: hey, i can't seem to find your old monad traffic light tutorial
18:11:01 <shachaf> Monads are like traffic light tutorials?
18:11:19 <edwardk> can someone proofread http://comonad.com/reader/2011/a-parsec-full-of-rats/ ?
18:11:38 <Cale> shirt: Ah, yeah, the machine it was on went down. I still need to see what I can recover from that drive, but it's awkward, since I'd need an adapter to plug it into my new machine.
18:12:16 <kmc> edwardk, s/self-containe/self-contained/
18:12:25 <edwardk> got it
18:12:30 <Eduard_Munteanu> edwardk: "the scala parsing"
18:12:40 <Eduard_Munteanu> Prolly should be Scala.
18:12:53 <shirt> Cale: ok. you mentioned once that you would no longer recommend using the approach in that article, and instead you would recommend the simpler method of just using an IO function that takes paramaters. is this correct?
18:13:08 <kmc> "only backtracking on failure if no input was unconsumed" should that be "was consumed"?
18:13:28 <Cale> shirt: Oh, that too, though the focus in that article was on how to use monad transformers if you're using them
18:13:33 <kmc> your code has a typo, "< |>" instead of "<|>"
18:13:52 <shachaf> Also < *>
18:13:55 <Cale> I normally recommend avoiding ReaderT or StateT transformers over IO
18:14:00 <Cale> (or WriterT)
18:14:01 <kmc> edwardk, btw, what are you using to highlight code?  i want those links for my blog :)
18:14:02 <edwardk> i can't fix those
18:14:07 <shachaf> And < />. Looks like something mangled pseudo-HTML tags.
18:14:10 <edwardk> those are done by my highlighter/blog
18:14:22 <Eduard_Munteanu> Is "lets" correct? /me isn't sure
18:14:24 <edwardk> i keep meaning to move to something else but then i forget about it for 6 months
18:14:49 <Cale> StateT can be good over nondeterminism monads.
18:15:39 <edwardk> updated on all counts mentioned so far
18:15:42 <Eduard_Munteanu> "lets do something"
18:15:45 <shirt> ok, well i'm not using any monad transformers in my code. just a lot of IO, and now i'm trying to add unit tests and i'm finding it really hard
18:15:48 <Eduard_Munteanu> (oh definitely not)
18:15:53 <edwardk> yeah the 3 lets are fixed
18:16:04 <Cale> shirt: What's the trouble?
18:17:15 <shirt> Cale: well, i have one function that sends a message over the network, then waits for a few seconds with threadDelay, then sends another message. i have no idea how to test this
18:17:24 <edwardk> next step is uploading the post with the actual parsec implementation of packrat
18:18:42 <shirt> edwardk: you have a typo "self-containe"
18:18:49 <edwardk> fixed
18:19:40 <shachaf> edwardk: "infixl 3" all on its own.
18:19:46 <shachaf> Presumably another HTML issue.
18:19:57 <edwardk> ah the right hand side got eaten </> was read as an empty tag ;)
18:20:22 <shachaf> Is there no way of doing highlighting that works with HTML?
18:20:43 <edwardk> yeah i can't use &lt; inside of the pre blocks. someone didn't think about representability =(
18:20:44 <shachaf> You'd expect that to be a pretty basic feature of an HTML highlighting module. :-)
18:21:12 <edwardk> the problem is the blog software itself conspires to inject the spaces and the highlighting software conspires to do other things
18:21:18 <Eduard_Munteanu> I'm thinking of starting a Hakyll-based blog, I'm hoping pandoc can take care of converting stuff correctly.
18:21:21 <Cale> shirt: Yeah, that does sound kinda awkward to test... I guess you could do something like make a datatype which represents the stuff to be done in an observable abstract way, and split the thing up into a pure function producing the script to be performed, and an interpreter which runs it and does the actual network stuff.
18:21:22 <Jafet> Then use <tt> and &nbsp; &nbsp; &nbsp; &nbsp;
18:21:23 <shachaf> D { .. } is RecordWildCards, I guess?
18:21:26 <Eduard_Munteanu> (I'll probably use latex as an input format)
18:21:33 * shachaf has never seen that used before.
18:21:35 <edwardk> shachaf: yeah
18:22:01 <kmc> Eduard_Munteanu, yeah, pandoc does a fine job.  it's what i use on my blog
18:22:01 <edwardk> shachaf: one of the reasons why i included it. most people don't use that or view patterns and the two together make for a pretty clean packrat memotable definition
18:22:04 <kmc> Eduard_Munteanu, why LaTeX, though?
18:22:08 <shirt> Cale: this datatype would be a kind of monad?
18:22:15 <edwardk> between the two you remove 2 redundant sets of names
18:23:35 <kmc> Eduard_Munteanu, i've been quite happy with Markdown input to Pandoc, whether I'm generating HTML or LaTeX
18:23:53 <Eduard_Munteanu> kmc: well, I'm a bit used to it, might do for formulas and there's stuff that already does code highlighting for LaTeX.
18:23:54 <kmc> i'm doing my beamer slides this way
18:24:04 <shachaf> Are your slides published yet?
18:24:10 <kmc> no for the upcoming talk
18:24:24 <kmc> Eduard_Munteanu, er, but the code highlighting module for LaTeX does you no good if you're not rendering the TeX but just parsing it and producing HTML
18:24:41 <kmc> meanwhile Pandoc does its own syntax highlighting for HTML with highlighting-kate
18:25:05 <kmc> also i think you can use LaTeX math syntax embedded in Pandoc Markdown
18:25:18 <Eduard_Munteanu> Oh, hm.
18:26:03 <kmc> also your Markdown source for the blog post can double as a literate Haskell file
18:26:22 <kmc> same's true of LaTeX, but it's much less nice to read the code
18:26:31 <Eduard_Munteanu> Yeah, I kinda expected Pandoc to preserve coloring from LaTeX, but I'm really unsure if it does that. After all I still have to choose fonts and all that using CSS.
18:26:50 <kmc> the whole point of Markdown is that it looks like plain text you'd use in an email or something, but has some basic HTML formatting
18:26:57 <kmc> it's not a replacement for HTML or LaTeX
18:27:56 <kmc> Eduard_Munteanu, i strongly advise that you try out Markdown before you conclude LaTeX is nicer
18:28:01 <kmc> (for this application)
18:28:18 <vikramverma> With pandoc, you can embed LaTeX blocks in Markdown.
18:28:20 <kmc> sure you may be used to LaTeX... the typical Haskell beginner is used to Python or Java
18:28:55 <kmc> there *is* a tradeoff between using the tool you know and learning a better tool... and I don't think the other two reasons you gave make sense, so it comes down to that tradeoff
18:29:21 <Eduard_Munteanu> kmc: one additional bonus was I could also publish printable versions as PDFs (which could look like papers), but I'm unsure if that's going to be useful. I'll think about it.
18:29:21 <sam9> hi
18:29:35 <sam9> I had a question about haskell's lazy evaluations
18:29:39 <vikramverma> Eduard_Munteanu: You can do this either way.
18:29:42 <sam9> is there a way that I can force an evaluation
18:29:43 <sam9> ?
18:29:48 <sam9> for instance,
18:29:58 <shachaf> @faq is there a way that I can force an evaluation
18:29:59 <lambdabot> The answer is: Yes! Haskell can do that.
18:30:11 <vikramverma> Eduard_Munteanu: pandoc will parse the markdown blocks, and can output to LaTeX. The LaTeX can then be converted to a pdf.
18:30:14 <sam9> so...
18:30:23 <sam9> I have a function that takes in 5 inputs
18:30:42 <sam9> I just want to precompute function with 4 inputs and leave the 5th input out
18:30:48 <vikramverma> @faq Can Haskell do anything?
18:30:48 <lambdabot> The answer is: Yes! Haskell can do that.
18:30:50 <sam9> so I have a function that take only one input
18:30:59 <sam9> so what is the notation for that?
18:31:01 <Eduard_Munteanu> vikramverma: oh, I see.
18:31:15 <kmc> Eduard_Munteanu, i think the subset of LaTeX that pandoc can parse and understand is not meaningfully more expressive than Markdown... you'll just be stuck writing "\subsection{foo}" instead of "## foo"
18:31:59 <kmc> and yes, if you want to produce pdfs then I would use Pandoc to convert Markdown to LaTeX, since you're already using it to convert Markdown to HTML
18:32:08 <vikramverma> kmc: For diagrams and stuff, I find it to be.
18:32:22 <Jafet> sam9: you can't really
18:32:29 <sam9> you cannot?
18:32:29 <kmc> Eduard_Munteanu, i think that's a dubious reason to use LaTeX as the *source* format
18:32:42 <Jafet> In GHC, you can write the function with four arguments syntactically, and it will be applied once you pass four arguments.
18:33:04 <Jafet> Perhaps f a b c d = ... `seq` \e -> ...
18:33:15 <kmc> Eduard_Munteanu, the catch is that if you write Markdown with embedded HTML you will have to replace that with embedded LaTeX for the pdf version... that's the same catch as if you wrote the document in LaTeX and used bits of TeX markup that pandoc can't convert to HTML
18:33:47 <Jafet> But you cannot generally beta-reduce functions in haskell
18:33:55 <monochrom> #ifdef HTML
18:34:04 <Jafet> Or whatever that reduction rule is called
18:34:10 <monochrom> <a href="haskell.org">haskell.org</a>
18:34:21 <Eduard_Munteanu> kmc: yeah, I haven't actually looked how much LaTeX pandoc actually understands.
18:34:21 <monochrom> #elsifdef LaTeX
18:34:27 <monochrom> \url{haskell.org}
18:34:29 <monochrom> #else
18:34:33 <monochrom> haskell.org
18:34:37 <monochrom> #endif
18:34:46 <sam9> hm... then what kinds of force evalutions are there in haskell?
18:35:11 <Eduard_Munteanu> sam9: there's seq
18:35:13 <Eduard_Munteanu> :t seq
18:35:13 <lambdabot> forall a t. a -> t -> t
18:35:55 <Eduard_Munteanu> For example   a `seq` b   basically says evaluate a when evaluating b
18:36:09 <Eduard_Munteanu> Or bang patterns.
18:36:33 <sam9> I heard about bangs
18:36:38 <sam9> how does it work?
18:37:04 <Jafet> They force evaluation when matched on a value.
18:37:15 <Jafet> > let a = div 0 0 in ()
18:37:16 <lambdabot>   ()
18:37:18 <Jafet> > let !a = div 0 0 in ()
18:37:19 <lambdabot>   *Exception: divide by zero
18:37:40 <Jafet> > let !a = [div 0 0] in () -- but only to WHNF, as with seq
18:37:41 <lambdabot>   ()
18:40:28 <sam9> hm... let me try it out
18:40:54 <sam9> then... for instance, I have a method
18:41:00 <sam9> or function...
18:41:23 <sam9> add a b c = d + c
18:41:34 <sam9> where !d = a + b
18:41:47 <sam9> then when I do... let f = add 3 4
18:42:04 <sam9> would it precompute d?
18:42:11 <sam9> or would it still be lazy
18:42:22 <Jafet> It wouldn't even "precompute" add.
18:42:49 <Jafet> f is (add 3 4) until it is applied
18:43:21 <sam9> so.. there is no way to force evaluation of d = a + b?
18:43:31 <Jafet> Sure there is. Apply f to something.
18:44:11 <sam9> oh... so when I do f c
18:44:22 <sam9> then it will all calculate a + b + c... not d + c
18:44:54 <sam9> because the situation is...
18:45:01 <sam9> I have a function that takes in 4 inputs
18:45:20 <sam9> I wnat to run this function with different 4th inputs
18:45:24 <Jafet> It would evaluate d, because you made it strict, then evaluate d + c.
18:45:32 <sam9> first 3 inputs are same for many applications
18:46:15 <Jafet> It doesn't matter, because the first three would be shared.
18:46:19 <sam9> oh... so if I do let f = add 4 5 then it will force calculate d right?
18:46:31 <mauke> add a b = let d = a + b in \c -> d + c
18:46:36 <Jafet> I told you already that it wouldn't
18:46:40 <mauke> I don't know how automatic that transformation is
18:46:51 <Jafet> Besides, you're asking two different questions.
18:47:15 <sam9> sorry i'm just confused...
18:47:42 <Jafet> > let f xs a = a == last xs in length $ f [1..10000] `map` [1..10000] -- in GHC, (last xs) is recomputed each time
18:47:43 <lambdabot>   10000
18:47:52 <Jafet> > let f xs a = a == last xs in length $ f [1..100000] `map` [1..100000] -- what no
18:47:54 <lambdabot>   100000
18:48:14 <Jafet> > let f xs a = a == last xs in length $ f [1..1000000] `map` [1..1000000] -- last
18:48:16 <lambdabot>   1000000
18:48:21 <Jafet> Ok, I was wrong there
18:48:44 <dolio> > let f x y = x where !z = undefined in f 4
18:48:45 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
18:48:46 <lambdabot>    arising from a use of ...
18:49:00 <dolio> > let f x y = x where !z = undefined in f 4 `seq` ()
18:49:01 <lambdabot>   ()
18:49:28 <dolio> > let f x y = x where !z = undefined in f 4 5 `seq` ()
18:49:29 <lambdabot>   *Exception: Prelude.undefined
18:50:33 <Jafet> > let f a b = (let !d = a+b in \c -> d+c) in f 0 undefined `seq` ()
18:50:34 <lambdabot>   *Exception: Prelude.undefined
18:50:44 <Jafet> Note that this is all ghc haskell
18:51:36 <dolio> > let f a b = let d = a + b in d `seq` \c -> d + c in f 0 undefined `seq` ()
18:51:37 <lambdabot>   *Exception: Prelude.undefined
18:52:55 <sam9> alright... thank you so much for the help
19:02:52 <Jafet> Oh, whoops
19:03:04 <Jafet> > let f xs a = a == last xs in length $ filter (f [1..10000]) `map` [1..10000] -- last
19:03:05 <lambdabot>   No instance for (GHC.Num.Num [t])
19:03:05 <lambdabot>    arising from the literal `1' at <inter...
19:03:28 <Jafet> > let f xs a = a == last xs in length $ f [1..10000] `filter` [1..10000] -- omega
19:03:30 <lambdabot>   1
19:03:55 <Jafet> I r fael
19:04:22 <ivanm> edwardk: in your blog post, is there really meant to be spaces in "< |>" and "< />" ?
19:04:41 <edwardk> ivanm: my blog software puts the spaces in. i can't fix it without switching entirely
19:04:50 <ivanm> that sucks :s
19:06:40 <monochrom> this is why I don't use any blog software. just write my own html. bonus is no spam comments or troll comments to fight.
19:07:01 <ivanm> what's packrat parsing though?
19:07:23 <ivanm> the page you link to doesn't really give a quick info/description
19:07:35 <Jafet> A way to make your haskell program use even more space
19:08:02 <Jafet> Basically, memoized recursive descent
19:09:07 <monochrom> that's fun. otoh that increases sharing.
19:09:27 <edwardk> yeah. in general you should use amdahl's law when deciding to memoize or not
19:10:16 <monochrom> amdahl's law doesn't really distinguish memory growth and cpu growth
19:10:51 <monochrom> oh, maybe amdahl's law originally just talks about memory growth
19:10:55 <edwardk> basically the idea is that packrat parsing memoizes the result of applying each parser at each location so if you have to backtrack, when you go to ask for a parse result a second time, you get it immediately
19:12:10 <edwardk> well, in general it just says that even if you got perfect speedup on something you spend 1% of your time doing it won't help much
19:12:54 * monochrom invents picket parsing: every application of parser to every location requires listening to labour union members explaining their strike :)
19:12:59 <edwardk> if you get perfect memoization of rules but never revisit them to use the memoized form then amdahl laughs at you, since you spent extra time memoizing
19:13:16 <ivanm> *nod*
19:13:28 <ivanm> monochrom: heh
19:14:31 <monochrom> oh! I mixed up amdahl and moore
19:14:40 <edwardk> one of the things i'm exploring with the gll parsers is how to use my speculation framework to intelligently parallelize parsing real context-free-grammars while having good performance on a nicely intuitive class of problems
19:14:43 <edwardk> monochrom: ahh
19:14:49 <edwardk> was wondering what you were talking about =)
19:15:20 <Jafet> I suppose you could model it as a cache
19:15:42 <ivanm> edwardk: so is </> equivalent roughly to polyparse's `onFail` ?
19:15:49 <Jafet> Then pick a cache algorithm and apply it
19:15:51 <edwardk> yeah, ford showed that in the particular case of a java parser he had good returns just retaining the last couple of applications of a given rule
19:16:00 <edwardk> ivanm: yeah
19:16:22 * Jafet tries to subliminally inject into edwardk the notion of abstracting out the cache algorithm from the parser
19:16:25 <edwardk> i think some dylan guys showed that rule didn't work quite so well for c/c++ though, where they had to memoize more
19:16:49 <edwardk> Jafet: heh i was spending a lot of time playing with doing these more intelligently via stable maps, etc.
19:16:59 <edwardk> but the version here was simple enough to blog and explain
19:17:31 <edwardk> it just made me really happy that i could directly bolt a packrat derivation set in as a parsec stream type
19:17:42 <edwardk> oh, if you didn't see it, i just posted the second half
19:17:52 <edwardk> http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/
19:20:50 <edwardk> the gll parsers are why i was really starting to play with packrat-like memoization schemes and stumbled onto this approach
19:23:13 <ivanm> edwardk: I take it "< $" is meant to be "<$" in whitespace?
19:23:19 <edwardk> ivanm: yes
19:23:25 <ivanm> took me a while to figure that one out :p
19:23:27 <edwardk> take a look at the code linked in the article at the bottom
19:23:35 <ivanm> was wondering why you were doing a less-than on () :p
19:23:36 <edwardk> it is easier to read there
19:23:39 <edwardk> =)
19:24:06 <ivanm> what software are you using that it keeps screwing up the symbols?
19:24:16 <ivanm> (and I note that later on there's no extra space in <$ for satisfy)
19:24:51 <edwardk> wordpress combined with the particular highlighting software i'm using
19:25:00 <edwardk> this is the least bad of the bunch that i went through
19:25:04 <ivanm> which is?
19:25:10 <edwardk> i don't recall off hand
19:25:27 <ivanm> have you tried just using pandoc or something to convert it all into HTML for you?
19:25:52 <edwardk> i went through 3-4 highlighting solutions before i just shrugged and moved on.
19:26:19 <edwardk> i haven't been willing to move all my content out of wordpress and start over
19:26:29 <edwardk> since i'm just not looking for a week long ordeal
19:27:42 <ivanm> is there any particular reason you sometimes you Applicative and other times Monadic parsing?
19:27:46 <edwardk> that and i'd have to figure out how to resurrect the old tiddly wiki content, which seem to be dead again
19:27:48 <ivanm> e.g. phrase vs satisfy
19:28:05 <edwardk> as in using the combinators?
19:28:13 <ivanm> as in defining them
19:28:23 <edwardk> oh, well, i tend to use applicative unless its ugly ;)
19:28:35 <ivanm> heh, fair enough
19:28:50 <edwardk> and i don't like excessively pointfree-ing
19:29:40 <dolio> edwardk: Like the operators.
19:29:42 <dolio> < *>
19:29:44 <dolio> < |>
19:29:47 <dolio> Thanks, blog software.
19:29:51 <ivanm> dolio: you're a little slow ;)
19:29:54 <edwardk> also, what would the applicative satisfy be ? =)
19:30:04 <ivanm> no idea, never used applicative
19:30:14 <edwardk> hint, its inherently monadic ;)
19:30:22 <ivanm> edwardk: so the usage of fix means that it will recursively keep parsing until the input is consumed?
19:30:27 <edwardk> no
19:30:45 <edwardk> the fix makes it so the combinators point to d points to the D i'm defining
19:31:03 <ivanm> come again?
19:31:03 <edwardk> its unfortunate but the view patterns used in a destructuring bind can't access other variables defined in the current let or where block
19:31:09 <edwardk> so it was that or make two nested wheres
19:31:31 <edwardk> let bar = …; Foo (bar -> …) = … in … doesn't work
19:31:31 <ivanm> oh, you want the `d' in the view patterns to be the `d' in the lambda expression?
19:31:36 <edwardk> yes
19:31:38 <ivanm> *nod*
19:31:40 <ivanm> that sucks
19:31:46 <ivanm> but using fix magically makes that work?
19:31:53 <edwardk> yeah
19:32:18 <ivanm> though I notice you didn't finish parse off...
19:32:27 <edwardk> i was trying to minimize the number of random names i defined
19:32:29 <edwardk> ?
19:32:35 <edwardk> did i cut the paste short?
19:32:43 <ivanm> you have: in D { .. }
19:32:49 <edwardk> how so?
19:32:54 <edwardk> D { .. } is the way it ends
19:32:55 <ivanm> at the end of parse
19:33:00 <edwardk> record wildcard
19:33:06 <ivanm> oh? never seen that before
19:33:11 <edwardk> yeah thats why i used it
19:33:11 <ivanm> is that an extension?
19:33:15 <edwardk> lots of people have never seen it
19:33:15 <edwardk> yeah
19:33:23 <ivanm> here I was thinking it was "write this later" :p
19:33:26 <edwardk> it binds the names inthe record to the names tht match that are in scope
19:33:28 <dolio> edwardk: So, is the big difference between packrat and GLL Maybe vs. List?
19:33:32 <edwardk> which is why i named stuff _foo
19:33:36 <ivanm> oh, that's right
19:33:38 <ivanm> I've seen that
19:33:42 <ivanm> just never using ..
19:34:03 <rrrrrrrrrrrrrrrr> hey bros
19:34:14 <rrrrrrrrrrrrrrrr> whats haskell
19:34:15 <wavewave> I use RecordWildCard a lot....... very convenient
19:34:15 <kmc> this is not going to end well
19:34:16 <edwardk> List based parsing is O(k^n) packrat is O(n) but recognizes a funny class of languages. GLL = O(n) for LL(1) languages, O(n^3) for any CFG.
19:34:27 <kmc> rrrrrrrrrrrrrrrr, http://haskell.org/haskellwiki/Haskell
19:34:40 <kmc> @google "what is haskell"
19:34:41 <dolio> kmc: Yeah. It only took one message.
19:34:41 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
19:34:42 <lambdabot> Title: Introduction - HaskellWiki
19:34:49 <rrrrrrrrrrrrrrrr> what is it useful for
19:34:52 <Eduard_Munteanu> That's a rather long nick, bro
19:34:54 <rrrrrrrrrrrrrrrr> over other languages
19:34:57 <kmc> @google what is haskell useful for
19:34:59 <lambdabot> http://stackoverflow.com/questions/1604790/what-is-haskell-actually-useful-for
19:34:59 <lambdabot> Title: programming languages - What is Haskell actually useful for? - Stack Overflow
19:35:12 <kmc> rrrrrrrrrrrrrrrr, http://haskell.org/haskellwiki/FAQ#The_real_world
19:35:21 <ivanm> rrrrrrrrrrrrrrrr: you typically use it just as you'd use any other general purpose programming language
19:35:31 <ivanm> kmc: I at first thought you were angry at the wiki page... :p
19:35:39 <rrrrrrrrrrrrrrrr> is it fast?
19:35:45 <edwardk> rrrrrrrrrrrrrrrr: yes
19:35:46 <kmc> languages have no speed
19:35:49 <rrrrrrrrrrrrrrrr> PF
19:35:50 <wavewave> pretty fast.
19:35:55 <kmc> GHC is a compiler for Haskell which produces fast code
19:36:07 <edwardk> the common implementation performs really well
19:36:12 <wavewave> depends on how you program though
19:36:12 <Eduard_Munteanu> rrrrrrrrrrrrrrrr: see here http://shootout.alioth.debian.org/
19:36:23 <Eduard_Munteanu> (if that counts for anything)
19:36:27 <ivanm> kmc: I dunno, I'm sure it's possible to define a language which is guaranteed to be slow...
19:36:38 <wavewave> I feel shootout is somewhat misleading
19:36:45 <rrrrrrrrrrrrrrrr> lol scrubs
19:36:46 <edwardk> ivanm: malbolge? =)
19:36:51 <ivanm> heh
19:37:05 <rrrrrrrrrrrrrrrr> jp thanks guys ;)
19:37:18 <kmc> that was odd
19:37:22 <kmc> why does this keep happening
19:37:24 <kmc> who are these people
19:37:37 <Eduard_Munteanu> kmc: the bros?
19:37:42 <ivanm> uni students in india was the last batch IIRC
19:37:57 <kmc> Eduard_Munteanu, the people who are interested in Haskell but know nothing about it and can't use Google
19:38:03 <ivanm> edwardk: what is the purpose of having (+), (*), etc. inside parse?
19:38:20 <ivanm> your D type doesn't seem to have any usage for actual implementation stuff
19:38:27 <edwardk> ivanm: those are defining the actions of the parsers
19:38:37 <Eduard_Munteanu> Not your typical bro, but still.
19:38:39 <ivanm> oh, is that the `a' type?
19:38:40 <edwardk> eval "(1 + 2 * 3)" will return 7
19:38:57 <edwardk> yes
19:39:00 <ivanm> edwardk: oh, so it actually evaluates the parse tree rather than just returning it?
19:39:04 <edwardk> yep
19:39:12 <edwardk> you could replace that with an actual AST if you wanted
19:39:19 <edwardk> but i just wanted to show an example
19:39:32 <edwardk> so it evaluates as it runs
19:39:33 <ivanm> do something similar to RWH where they define a different instance of Num which keeps the AST around, etc.?
19:39:35 <kmc> in what way does it memoize?
19:39:39 <kmc> perhaps i should read the paper instead
19:40:01 <edwardk> kmc: the result of the parsers is recorded at each location
19:40:11 <ivanm> edwardk: dv = flip ($) ?
19:40:15 <edwardk> km: that way if you ask for the 'decimal' value starting at position 5 a second time it just gives it back
19:40:18 <edwardk> ivanm: yep
19:40:26 <edwardk> defined directly to be more obvious
19:40:46 <ivanm> I didn't realise that view patterns could return functions like that
19:41:00 <ivanm> oh, duh, it returns a field which happens to be a function
19:41:05 * wavewave loves how #haskell treat all kind of people.
19:42:06 <edwardk> well in that case its returning a non-function, just a field.  Rat (dv d -> _foo)   binds foo to a Result D Int or some such
19:42:11 <edwardk> er binds _foo
19:42:32 <ivanm> edwardk: so what exactly makes that parser there a packrat style parser as opposed to a "conventional" monadic parser?
19:42:48 <ivanm> just that - apart from satisfy - you're using Applicative/Alternative instead of Monad?
19:42:56 <edwardk> without the view pattern i'd get Rat bar = .. where bar is a function from D -> Result D Int  -- the view pattern applies it to the d that is in scope, giving something suitable to put IN D.
19:43:13 <edwardk> ivanm: no real reason except for the fact that i don't _need_ the power of the monad
19:43:20 <edwardk> and i felt it was better to showcase it that way
19:43:29 <edwardk> most parser combinators don't need to be monadic
19:43:43 <ivanm> so is that demonstrative of a packrat-style parser?
19:43:50 <ivanm> because if so, it doesn't appear to be that different
19:43:52 <ivanm> :s
19:44:22 <edwardk> for instance: http://hackage.haskell.org/packages/archive/trifecta/0.40/doc/html/Text-Trifecta-Parser-Combinators.html has everything defined using just Applicative (except a few at the bottom)
19:44:26 <edwardk> ivanm: thats the point
19:44:41 <edwardk> packrat parsing isn't HARD
19:44:47 <ivanm> edwardk: OK, so what would I get with polyparse if I started using Applicative/Alternative instead of Monad apart from shorter parsers that contain more symbols than before?
19:44:48 <edwardk> and shouldn't be
19:44:49 <ivanm> *nod*
19:44:54 <edwardk> and you can do it with parsec
19:44:55 <ivanm> so it isn't a different style of prsing then
19:44:58 <ivanm> *parsing
19:45:04 <edwardk> nono
19:45:12 <edwardk> packrat is about the fact that it memoizes
19:45:16 <edwardk> it changes your asymptotics
19:45:20 <edwardk> tht is what matters
19:45:21 <edwardk> not the syntax
19:45:45 <edwardk> packrat parsing an input string of length n for a finite grammar is O(n)
19:46:03 <edwardk> parsec or polyparse can be O(k^n) if you want to go pathological
19:46:09 <edwardk> (actually worse with the monad)
19:46:34 <edwardk> that is a bit of a difference ;)
19:46:36 <ivanm> edwardk: so are those asymptotes from the way you use it, or how the instances/combinators are defined?
19:47:06 <ivanm> i.e. will my parsing magically have better asymptotics just by changing my code without touching polyparse?
19:47:21 <edwardk> the asymptotics come from the fact that if you take one branch and then fail and go back and take another branch it is going to use something from the same finite pool of combinators, and the result of every combinator at every position has been memoized
19:47:33 <edwardk> so if it stumbles across anything that was used before in the previous parse it already knows the answer
19:47:41 <edwardk> yes
19:47:57 <edwardk> you swap to parsec and tabulate using the funny machinery i described and wham
19:47:57 <edwardk> faster
19:48:16 <ivanm> I don't particularly want to switch to parsec though!
19:48:19 <ivanm> I like polyparse
19:48:20 <edwardk> as long as you are writing applicative code using these combinators and have a finite grammar
19:48:35 <edwardk> well, eventually i'll give you a polyparse compatibility layer in trifecta ;)
19:48:47 <ivanm> edwardk: so it's not polyparse per se, it's trifecta?
19:48:51 <monochrom> if you backtrack a lot but ends up redoing 50% (or whatever) of the same things the same way, you want this memoization
19:48:53 <ivanm> i.e. polyparse currently doesn't have this?
19:48:59 <ivanm> monochrom: *nod*
19:49:01 <edwardk> polyparse doesn't do this
19:49:06 <ivanm> I think I've ended up doing a lot of that memoisation by hand
19:49:14 <edwardk> this is packrat, which is in frisby and pappy
19:50:04 <ivanm> e.g. http://hackage.haskell.org/packages/archive/graphviz/2999.12.0.3/doc/html/src/Data-GraphViz-Parsing.html#stringParse
19:50:05 <edwardk> the idea here is that if most of your leaves are context-free you can mix and match this style with monadic style and while you lose the strict O(n) guarantee of packrat you get a lot of convenience in exchange and only pay for the extra power you get when you actually use it
19:50:26 <edwardk> also notice something about the grammar i wrote
19:50:29 <edwardk> i was SLOPPY
19:50:49 <ivanm> ^^ that creates an explicit parse tree on a letter-by-letter basis rather than trying to parse an entire String, failing, then moving on to the next String to try and parse
19:51:06 <ivanm> edwardk: so when you said "you swap to parsec" you meant "swap to parsec-style parsing and use trifecta" ?
19:51:13 <edwardk> (+) <$> mult <* symbol "*" <*> add </> mult    -- notice that both branches replay the mult parser
19:51:23 <edwardk> usually you'd factor that into
19:51:31 <ivanm> hmmm....
19:51:46 <ivanm> edwardk: so this doesn't work for possibly infinite streaming parsing then?
19:51:50 <edwardk> mult <*> optional ((,) <*> symbol "*" <*> add) -- etc.
19:51:55 <edwardk> i didn't say that
19:52:01 <edwardk> in fact i have it working for infinite streams
19:52:16 <ivanm> OK, which part of the machinery in your blog post gives you that?
19:52:25 <augur> haskell has ruined me
19:52:34 <augur> in so many ways
19:52:37 <edwardk> "I leave it as an exercise for the reader to extend this material with the parsec+iteratees approach from my original talk on trifecta to get packrat parsing of streaming input. Either that or you can wait until it is integrated into trifecta."
19:52:43 <edwardk> its not hard
19:52:58 <augur> i find myself having to program in ObjC and hating it
19:53:02 <augur> not because its imperative, mind you
19:53:12 <ivanm> oh, so what's in your blog post won't do the memoisation?
19:53:16 <augur> but because it lacks adt's and higher order functions and cons lists and such
19:53:17 <augur> :\
19:53:20 <ivanm> (and re-factoring)
19:53:24 <edwardk> in trifecta terms you'd store one of the 4 continuations i use in the parser
19:53:27 <ivanm> augur: iOS programming?
19:53:29 <edwardk> um
19:53:35 <edwardk> what is in the post does the memoization
19:53:45 <augur> ivanm: no just MacOS
19:53:48 <edwardk> it doesn't support streaming input that isn't already in a string
19:53:54 <edwardk> because it would complicate the example
19:53:56 <edwardk> not because its hard
19:54:10 <edwardk> it just wasn't the topic i wanted to talk about
19:54:12 <ivanm> edwardk: OK, so which part of it means that the mult isn't re-parsed?
19:54:26 <ivanm> and what's the "original talk on trifecta" ?
19:54:37 <edwardk> data D = D { _mult :: Result D Int, … }
19:54:57 <edwardk> stores the _RESULT_ of the mult parser being applied at each location in the input
19:55:07 <edwardk> view D as the "Input String"
19:55:12 <ivanm> it does? :o
19:55:26 <ivanm> I might have to play with that a bit to get it
19:55:45 <edwardk> which carries along with it 5 extra slots, where the answer of applying add, mult, primary, dec, or char has been stored
19:56:21 <edwardk> and when those parsers succeed and consume they reference forward in skiplist fashion to the D where you resume parsing
19:56:32 <ivanm> oh: for every "sub-input string" D, it stores what the parsing is like for each possible parser?
19:56:47 <edwardk> for every tail of the input
19:56:54 <ivanm> because that `D' isn't referring to the entire original input String, but what it's examing at the moment?
19:56:58 <edwardk> thats what parse is doing
19:57:00 <edwardk> yeah
19:57:00 <ivanm> i.e. no explicit tails
19:57:09 <ivanm> _now_ I get it
19:57:20 <edwardk> notice how we thread a chain of n 'D's in parse through the anyChar parser
19:57:23 <ivanm> you're just being clever with how you define and use your parsers
19:57:28 <edwardk> then the other parsers use it indirectly
19:57:34 <edwardk> so they reference the same n Ds
19:57:53 <edwardk> so if you run one then run another you'll be forcing slots in the chain of Ds that define the parser
19:58:07 <edwardk> so that if you ever ask for those same sub-results again you'll get the same answer
19:58:29 <edwardk> and those answers are themselves built out of other answers made the same way
19:58:40 <ivanm> edwardk: so in essence you're not parsing a String, you're parsing the textual representation of a D expression, with lazily evaluated storing of every possible sub-parser being stored?
19:58:52 <edwardk> so demanding one result demands some subset of the others
19:59:27 <edwardk> yes, D. is a string unrolled into a tabulation of a ribbon of 5 parsers with forward links that act 'skip-list'-like through the ribbon
19:59:48 <ivanm> so the real trick is being clever in how you define your parser, not the actual parsing machinery per-se?
20:00:15 <ivanm> edwardk: and it helps when I realise that </> is missing and a newline inserted in the blog post in the definition of parse :p
20:00:21 <edwardk> well, the trick is defining the stream type to actually contain the parse results from the packrat parser and spotting the fact that this idiom which was well known is a valid parsec stream
20:00:26 <edwardk> hah
20:00:27 <edwardk> which one?
20:00:32 <ivanm> all of them
20:00:41 <edwardk> refresh and look again
20:00:44 <edwardk> check to see if its there
20:00:47 <ivanm> no, wait, I lie: in _primary it puts a newline and then </>
20:00:47 <edwardk> i fixed some at one point
20:00:57 <ivanm> nope
20:01:24 <edwardk> ah a bunch got eaten in the first post as well
20:01:37 <ivanm> so, to use this approach you have to be careful in how you define your parsing types
20:01:46 <ivanm> hmmm....
20:02:12 <edwardk> http://pdos.csail.mit.edu/~baford/packrat/icfp02/ArithPackrat.hs might make sense as a raw example
20:02:25 <edwardk> and perhaps motivates my choice of example
20:02:48 <edwardk> no combinators, no funny extensions, just raw case case case case ...
20:03:03 <ivanm> ouch :s
20:03:21 <ivanm> edwardk: so, what happens with more complicated things you want to parse when you have sub-types, etc.
20:03:31 <ivanm> do you have sub-parsers with different Streams ?
20:03:46 <edwardk> what about it? packrat what makes sense then use parsec for the rest
20:03:47 <ivanm> or do you have one big parsing type with the result of every single individual thing that is parseable?
20:03:58 <edwardk> note the example there where i use the whiteSpace parser, and eof, etc in eval
20:04:03 <edwardk> despite the fact that i didn't packrat them
20:04:17 <edwardk> i could just as easily used other combinators to glue stuff together
20:04:56 <edwardk> you make one bit stream type with the memoization of everything you think will pay off to be able to reparse instantly. crap you expect to try to parse at the exact same location over and over again
20:05:32 <ivanm> edwardk: is the "<* eof" just to force the parser to consume the entire thing?
20:05:37 <edwardk> maybe the result of trying to parse an identifier or keyword at the location, or of parsing a statement or eof
20:05:48 <edwardk> yeah, makes it a parse error to eval "(1 + 2)asdkasjdjlas"
20:06:04 <edwardk> if you didn't reach eof then you failed ;)
20:06:42 <ivanm> and also so that "1 + 2" actually returns 3 rather than 1 ?
20:06:50 <edwardk> each lexeme parser consumes whitespace _after_ it, so "( a + b )     " is fine though
20:07:01 <edwardk> nah, the parser is greedy
20:07:15 <edwardk> that add parser will keep munching as long as precedence allows
20:07:16 <ivanm> oh, because of the ordering in the terms?
20:07:40 <edwardk> yeah
20:08:10 <edwardk> if you want it to optionally be not greedy you have to get creative. (gll would help here for instance)
20:08:45 <ivanm> edwardk: so packrat style parsing is for cases where you want to avoid re-parsing stuff when backtracking and attempting to parse something similar; if you won't be parsing anything similar then you can just use "normal" parsing?
20:08:55 <edwardk> yes
20:09:06 <edwardk> but even dissimilar things tend to parse some subset of the same things
20:09:11 <edwardk> identifiers for instance
20:09:16 <ivanm> *nod*
20:09:28 <edwardk> even if you put the words together in different ways you probably still recognize the same concept as a word ;)
20:09:34 <ivanm> yeah, in graphviz I think I've basically ended up doing explicit stuff to avoid re-parsing
20:10:01 <edwardk> in some sense packrat makes a great lexer even if the rest of your parser is context sensitive
20:10:22 * ivanm probably really should and learn what all that parsing terminology is at some point...
20:11:27 <ivanm> huh, I thought amdahl's law was only for parallel computing; didn't realise that isn't the case in general
20:11:37 <mysticc> is there a redis bindings for haskell
20:11:56 <ivanm> @google haskell redis
20:11:57 <edwardk> well, you can use it as a reasoning tool even for the sequential case saying 'even if i perfectly optimized this, would it make a difference'
20:11:58 <lambdabot> http://hackage.haskell.org/package/redis
20:11:58 <lambdabot> Title: HackageDB: redis-0.11
20:12:04 <ivanm> mysticc: google says yes
20:12:17 <ivanm> edwardk: *nod*
20:12:48 <copumpkin> edwardk: know of any high-performance disk-based queues with nice guarantees? other than the bdb queue implementation, that is
20:13:02 <ivanm> edwardk: I know that you're doing fancy applicative stuff in trifecta and uu-parsinglib has some stuff as well, but in terms of performance, etc. does applicative vs monadic make a difference?
20:13:19 <edwardk> copumpkin: hrmm
20:13:27 <edwardk> ivanm: yeah
20:13:44 <edwardk> ivanm: i can calculate better first-sets, and dispatch only to the right branch based on it
20:13:50 <ivanm> sorry, I meant "does it make a difference in parsec/polyparse?"
20:13:56 <edwardk> no
20:14:01 <ivanm> OK, that's what i thought
20:14:03 <copumpkin> oh, it won't make a difference if you don't make the instance different
20:14:08 <edwardk> they don't have the plumbing to take advantage of it
20:14:12 <ivanm> so there's no real need for me to re-write my parser to use Applicative style then
20:14:12 <ivanm> :p
20:14:22 <copumpkin> ivanm: there is if you want to swap out parsers someday
20:14:23 <copumpkin> :)
20:14:28 <edwardk> until you defect to trifecta ;)
20:14:44 <copumpkin> or trifect to defecta
20:14:47 <ivanm> edwardk: I CAN HAZ DOCS PLZ? KTHNX BYE!
20:14:59 <ivanm> copumpkin: so you split into three pieces? :p
20:15:00 <edwardk> the current parser doesn't do any applicative optimizations though anyways
20:15:19 <edwardk> ivanm: sure, i accept documentation patches ;)
20:15:25 <ivanm> heh
20:15:40 <ivanm> edwardk: if I'm going to work on any of your packages, it'll be graphs
20:15:47 <edwardk> fair nuff
20:16:53 <shachaf> I don't know much about *actual* various fast queue implementations, unfortunately.
20:17:28 <augur> man
20:17:29 * shachaf wrong channel
20:17:48 <augur> er.
20:17:50 <edwardk> copumpkin: oh i should probably answer your question. (got distracted)
20:18:10 <augur> whats a good way to represent a low-dimensional binary space?
20:18:16 <edwardk> copumpkin: what are you trying to queue?
20:18:25 <augur> edwardk: surely you know!
20:18:28 <copumpkin> I basically need a reliable concurrent logfile
20:18:34 <copumpkin> so I don't even need to mutate/dequeue
20:18:42 <edwardk> if you need windows only there is a good api, otherwise it gets hard
20:19:26 <edwardk> http://msdn.microsoft.com/en-us/library/windows/desktop/bb540361(v=vs.85).aspx
20:19:37 <copumpkin> I'd prefer something nice and portable :)
20:20:00 <edwardk> one thing that microsoft got right was giving you access to a good aries style transaction log
20:20:19 <edwardk> that was what my column store hooked into
20:20:55 <edwardk> maybe some open source aries implementation like derby?
20:22:38 <hpaste> kmc pasted “lexer -- can it be improved?” at http://hpaste.org/51721
20:22:55 <copumpkin> edwardk: hmm, I'll look into that
20:23:06 <edwardk> otherwise you could just grab 5 machines and set up a paxos cluster with some kind of crappy local log files ;) and rely on the odds of them all failing the same way to see you through recovery ;)
20:23:09 <kmc> i'm going for clear concise code here above all else
20:23:14 <kmc> so it's not an efficiency concern
20:23:20 <Afzal> hey people....i'm very new to Haskell. I was wondering how to get my program to generate t/f values for a truth table
20:23:25 <kmc> but the line i marked seems clunky
20:23:48 <edwardk> kmc: for your example talk?
20:23:52 <kmc> nah
20:23:53 <kmc> for another project
20:24:03 <kmc> so feel free to bust out the bifuctorial co-lensoids
20:24:13 <edwardk> hahaha
20:24:17 <edwardk> you can trifecta it ;)
20:24:20 <kmc> or tell me i should do this a completely different way
20:24:21 <kmc> haha
20:24:27 <kmc> could do
20:24:34 <kmc> but this is pretty much all the "parsing" i need
20:24:44 <shachaf> kmc: Why \$ instead of e.g. $$ for escaping?
20:25:02 <kmc> shachaf, it matches POSIX shell
20:25:06 <Afzal> help?
20:25:07 <edwardk> ah
20:25:07 <shachaf> Presumably now you also need \\, then?
20:25:12 <kmc> yeah
20:25:12 <kmc> sigh
20:25:14 <kmc> thanks
20:26:02 <kmc> it's for a shell quasiquoter a la Perl backticks, i.e.
20:26:53 <shachaf> Still with the interpolation!
20:26:53 <kmc> do [filename] <- getArgs; sum <- head <$> [sh| sha1sum $filename |]
20:26:56 <kmc> yes
20:26:57 <shachaf> I should've known.
20:27:19 <kmc> (this will sh-escape filename :: String, and will "show" it if it's not a String)
20:27:23 <shachaf> Hmm, are you sure you want to use $?
20:27:29 <kmc> not positive shachaf
20:27:35 <kmc> but it's "standard"
20:27:42 <shachaf> Well, I guess it's simple, which is an advantage.
20:27:49 <shachaf> How difficult is it to embed arbitrary expressions?
20:27:51 <kmc> i know "do what Perl does" is a terrible design guideline but still
20:27:59 <kmc> shachaf, i'm not allowing that
20:28:08 <kmc> i'd have to pull in haskell-src-meta-mwotton or something
20:28:15 <kmc> it's doable but i'm looking to keep this simple
20:28:26 * shachaf likes Ruby's #{expr} syntax.
20:28:31 <shachaf> I suppose it makes thigs more complicated, though.
20:28:40 <kmc> how do you interpolate a single var in Ruby?
20:28:50 <shachaf> Like that.
20:28:55 <kmc> ok
20:29:16 <shachaf> (Unless it's a global or instance variable or something, for which there's a short-hand. But that's a mess.)
20:29:17 <Afzal> truth table anyone?! :/
20:29:27 <shachaf> Afzal: You should probably ask a more specific question.
20:29:38 <shachaf> (Also, if it's a homework question, you should specify that.)
20:29:58 <Afzal> i can't understand how to make the program generate a list of values for each variable in the boolean expression
20:30:12 <Afzal> of course it's a homework, why would i want to write truth tables in haskell? :/
20:30:36 <shachaf> kmc: Optional sh-style ${} might be nice, in case you need to say ${var}blah
20:30:47 <shachaf> Afzal: Well, what have you tried?
20:31:11 <Afzal> i tried using permutations, of course sequence didn't work because they're not numbers i guess
20:31:16 <shachaf> We're not going to write the program for you, but we're usually happy to gently nudge.
20:31:26 <Afzal> yeah i know, that's kinda what i need
20:32:21 <Afzal> but i can't understand how to make sense of it. i have the logical And function, but i need to run permutations on each variable and execute it.
20:33:06 <kmc> hmm yeah shachaf
20:33:33 <CuriousCursor> some people suggested Cartesian products but i don't even know what that is
20:35:40 <shachaf> > cartesianProduct [1,2,3] "abcd" -- This is a cartesian product
20:35:42 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(1,'d'),(2,'a'),(2,'b'),(2,'c'),(2,'d'),(3,'a'),(3...
20:37:03 <shachaf> kmc: You could always do Lit Char instead of Lit String if you want to simplify that *particular* line a bit. :-)
20:37:16 <mauke> a "cartesian product" is a list of pairs with all possible combinations
20:37:26 <copumpkin> you may have heard of powerset
20:37:30 <copumpkin> but have you heard of POWERSLICE
20:37:52 <copumpkin> it reminds me of the shitty ammoless weapon in quake 3
20:37:53 <mauke> like if A = [1,2,3] and B = [X,Y], then A x B = [(1,X), (1,Y), (2,X), (2,Y), (3,X), (3,Y)]
20:38:19 <shachaf> copumpkin: Yours for only three easy payments of $19.99?
20:39:24 <shachaf> kmc: Is there really no simple interpolation quasiquoter?
20:39:36 <kmc> there is one
20:39:44 <kmc> and i thought about using it
20:39:44 <shachaf> kmc: Also, your parser is a bit broken if you want to merge all Lits.
20:39:49 <kmc> i don't
20:40:00 <kmc> i want to do the sh-escaping
20:40:06 <shachaf> parse "abc\\$asdf" -- Oh, OK.
20:40:07 <kmc> but i guess i could wrap an existing interpolation quasiquoter
20:41:50 <copumpkin> :t lit
20:41:51 <lambdabot> Not in scope: `lit'
20:42:02 <copumpkin> :t lex
20:42:03 <lambdabot> String -> [(String, String)]
20:42:34 <dolio> :t luthor
20:42:35 <lambdabot> Not in scope: `luthor'
20:43:19 <kmc> shachaf, do you think i should hook into an existing quasiquoter?
20:43:27 <DevHC> ROFL
20:43:27 <copumpkin> shachaf: yes
20:44:22 <kmc> yeah, redoing this with Parsec... the threshold for throwing out a hand-rolled parser in Haskell is pretty low :)
20:44:26 <shachaf> kmc: That depends on whether there's a good one.
20:44:39 <shachaf> Writing a quasiquoter is presumably not very hard -- I was just surprised that one doing this didn't already exist.
20:44:40 <kmc> seems like every C program contains a 200 line hand-rolled parser because the alternative is lex/yacc
20:44:57 <shachaf> Parsec? Isn't that a bit excessive?
20:45:13 <kmc> shachaf, how do i patch the shell escape quoting into an existing interpolation quasiquoter
20:45:39 <kmc> also in what way is Parsec "excessive"?
20:45:42 <kmc> what would you use?
20:45:43 <shachaf> It's probably simpler to make your own.
20:45:55 <kmc> just because Parsec can do a lot more?
20:45:57 <augur> noone knows :(
20:46:04 <copumpkin> who's noone?
20:46:12 <Axman6> kmc: i'm doing an assignment to write 'compiler' using flex/bison :(
20:46:20 <shachaf> I thought Parsec had some overhead.
20:46:29 <copumpkin> who cares
20:46:32 <shachaf> Maybe I'm just thinking of runParsecT.
20:46:33 <kmc> shachaf, runtime overhead?
20:46:47 <shachaf> No, in terms of imports and functions and types.
20:46:59 <kmc> a little bit
20:47:12 <kmc> the name clash between Parsec and Applicative is annoying
20:47:18 <kmc> but i can copy-paste those import lines from my last quasiquoter ;)
20:47:42 <DevHC> > lex luthor
20:47:44 <lambdabot>   [("WROOOOONG"," !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
20:49:01 <ivanm> is there a version of splitAt that will also indicate the length of the chunk it returns?
20:49:13 <ivanm> (in case the length is less than the specified value)
20:49:41 <shachaf> There's always ReadP.
20:50:21 <hpaste> wavewave pasted “Extend this MatrixStructure more flexibly” at http://hpaste.org/51723
20:50:24 <shachaf> ivanm: I don't think so.
20:50:38 <ivanm> shachaf: didn't think so :s
20:51:27 <ivanm> I want to define chunk :: Int -> [a] -> [([a],Int)], because I need to know the length of each sub-list :/
20:52:37 <wavewave> add some more shared expression in MatrixStructure without hurting other definition.
20:53:18 <wavewave> what would be the best option?
20:54:29 <wavewave> maybe fclabels..
20:56:29 <wavewave> or HList..
21:11:10 <mysticc> are the links in the library code broken ?? http://www.haskell.org/haskellwiki/Example_code
21:12:20 <wavewave> it is linked to dons
21:13:01 <mysticc> wavewave: It is showing access forbidden in unsw site
21:14:08 <wavewave> http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/Prelude.html
21:14:50 <wavewave> the web page must be updated and for the time being, just replace URL using the above.
21:14:54 <ivanm> mysticc: probably because no-one has fixed those links since dons finished his PhD
21:15:07 <ivanm> wavewave: you'd want to use the latest ones from ghc probably
21:15:38 <wavewave> s/4.4.0.0/latest
21:16:05 <mysticc> wavewave: but I wanted to see the source ...
21:16:42 <wavewave> there you can see the source by clicking source
21:16:58 <mysticc> yeah ..thanks
21:17:33 <ivanm> wavewave: no, I meant not on hackage
21:17:36 <ivanm> @where Prelude
21:17:37 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
21:17:39 <ivanm> bah
21:17:57 <ivanm> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
21:18:01 <ivanm> ^^ that's what I mean
21:19:16 <wavewave> library design is hard.
21:25:18 <mysticc> what is the meaning of forall in the type signature ??
21:25:29 <mysticc> >:t build
21:25:53 <Axman6> mysticc: it can be ignored if you're seeing it in lambdabot
21:25:56 <Axman6> :t map
21:25:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:26:03 <kmc> not always
21:26:07 <glguy> mysticc: there is an implicit for all on the left side of a type
21:26:09 <Axman6> you can read that as  (a -> b) -> [a] -> [b]
21:26:11 <Axman6> yeah
21:26:17 <Axman6> :t runST
21:26:18 <lambdabot> forall a. (forall s. ST s a) -> a
21:26:30 <Axman6> that's a case where it can't be ignored
21:26:40 <mysticc> but what does it actually mean ..
21:26:42 <mysticc> ??
21:27:16 <kmc> mysticc, «forall a. T a» means that the value can have type «T A» for *any* choice of A
21:27:18 <mysticc> :t build
21:27:19 <lambdabot> Not in scope: `build'
21:27:46 <kmc> mysticc, in a context like «map :: forall a b. (a -> b) -> [a] -> [b]» it's implicit... the "forall" keyword doesn't even exist in Haskell
21:27:55 <Axman6> mysticc: are you wondering about the fold/build optimisation?
21:28:10 <glguy> kmc: Do you mean "in Haskell 98"?
21:28:10 <mysticc> Axman6: yup
21:28:13 <daaaaaaaaaaaan> @hoogle build
21:28:13 <lambdabot> Data.Graph.Inductive.Internal.Heap build :: Ord a => [(a, b)] -> Heap a b
21:28:14 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
21:28:14 <lambdabot> Text.ParserCombinators.Parsec.Expr buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
21:28:20 <kmc> glguy, or Haskell 2010, or Haskell 1.4
21:28:28 <kmc> mysticc, but when it's in the function *argument* type (i.e. on the left of ->) then it's significant
21:28:55 <Axman6> > (\cons nil -> 1 `cons` 2 `cons` nil) (:) []
21:28:56 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
21:29:05 <Axman6> > (\cons nil -> 1 `cons` (2 `cons` nil)) (:) []
21:29:06 <lambdabot>   [1,2]
21:29:13 <Axman6> > (\cons nil -> 1 `cons` (2 `cons` nil)) (+) 0
21:29:14 <lambdabot>   3
21:29:18 <kmc> mysticc, «forall a. (T a -> B)» is a function which promises that it can be used polymorphically... but «(forall a. T a) -> B» is a function which *demands* that its *argument* be polymorphic
21:29:27 <wavewave> mysticc: forall is especially meaningful combined with parenthesis.
21:29:29 <Axman6> :t (\cons nil -> 1 `cons` (2 `cons` nil))
21:29:30 <lambdabot> forall t t1. (Num t) => (t -> t1 -> t1) -> t1 -> t1
21:29:36 <kmc> mysticc, so it's a question of whether the caller or callee chooses the type 'a'
21:30:04 <Axman6> mysticc: it's functions of this sort that are used in the fold/build optimisation
21:30:06 <wavewave> like f :: (forall a. a -> a ) -> b
21:30:43 <wavewave> it is different from f :: forall a. a -> a -> b
21:31:01 <wavewave> in the latter case, you can just omit forall.
21:31:25 <Axman6> :t \f z -> foldr f z [1,2,3]
21:31:26 <lambdabot> forall a b. (Num a) => (a -> b -> b) -> b -> b
21:32:04 <kmc> how does one specify that a package is UNIX-only in Cabal?
21:32:17 <wavewave> in the former case, (forall a. a -> a)  means a function defined for all a with type signature a -> a
21:32:25 <copumpkin> kmc: you could depend on unix, maybe?
21:32:43 <wavewave> i.e. identity function. the only function which can have that signature.
21:32:49 <copumpkin> unless the unix package works on non-unix too
21:33:17 <ivanm> copumpkin: don't think so
21:33:22 <ivanm> otherwise, why is there unix-compat?
21:33:25 <glguy> unix: The package is not supported under Windows (except under Cygwin).
21:33:34 <wavewave> mysticc: in some sense, forall defines a local scoped type variable.
21:33:38 <ivanm> kmc: a message saying "if you install this on windows you're an idiot"? :p
21:34:08 <shachaf> kmc: Depends: unix. :-)
21:34:13 <shachaf> Oh.
21:34:17 <mysticc> thanks all
21:34:25 * shachaf is outearlied as usual.
21:34:34 <wavewave> mysticc: so  for f :: (forall a. a -> a) -> b, the function is only polymorphic w.r.t b
21:34:55 <wavewave> a is not bindable type variable for f .
21:35:24 <wavewave> rather (forall a. a->a) itself is a type.
21:35:43 <kmc> cabal has syntax for conditionalizing by platform
21:35:45 <kmc> at least by compiler
21:35:48 <wavewave> which we usually say existential type.
21:35:49 <kmc> i was wondering if it had the same thing by OS
21:35:56 <kmc> otherwise i would use #ifdef and #error in one of my files
21:36:32 <kmc> ivanm, the problem is "if you install this on Windows you may introduce subtle security holes"
21:36:48 <kmc> imagine that in some doc 5 packages deep in a dependency chain
21:36:51 <ivanm> oh? what does this package do?
21:37:15 <ivanm> kmc: you can probably do an if in the cabal file to do some kind of breakage if its on windows/cygwin
21:37:20 <kmc> quasiquoting for shell commands
21:37:21 <kmc> do [filename] <- getArgs; sum <- head <$> [sh| sha1sum $filename |]
21:37:25 <ivanm> hmmm
21:37:38 <ivanm> kmc: security hole because of lack of user security on windows?
21:37:41 <kmc> no
21:37:50 <kmc> the algorithm i'm using for escaping the interpolated string is not guaranteed to work on windows
21:38:07 <kmc> the internals of the 'process' package have one which might, but i have no way to test it and no interest in testing it
21:39:26 <kmc> the idea is that it should do the right thing even if the user passes a "filename" of "$(rm -rf /)"
21:39:44 <kmc> i.e. try to sha1sum a file of that name, rather than blowing away the root filesystem ;P
21:41:14 <ivanm> well, doing some kind of deliberate breakage at the cabal level on windows is probably your best bet
21:41:27 <ivanm> maybe ask dcoutts_ if there's any recommended way of doing it?
21:48:08 <wavewave> is there a library providing (Key,Value) store where Key is a type?
21:48:33 <wavewave> O(1) access..
21:48:38 <Axman6> :|
21:48:47 <Axman6> actually, you could do it with Typeable
21:49:07 <Axman6> but, i doubt you would get O(1) access. O(log n) easily though
21:49:09 <wavewave> Axman6: I mean compile time key generation/
21:49:23 <Axman6> not sure what you mean
21:49:44 <zenzike> I'm feeling a bit silly for asking, but, is cabal install base-4.4.0.0 supposed to just work?
21:49:52 <shachaf> zenzike: Probably not.
21:49:57 <shachaf> zenzike: base typically comes with ghc.
21:50:08 <ivanm> zenzike: no
21:50:08 <Axman6> you should not be installing base using cabal
21:50:18 <Axman6> it's heavily tied to each GHC release
21:50:20 <ivanm> if it comes with ghc and isn't called Cabal, don't install it by hand
21:50:22 <zenzike> shachaf: ah cheers, I thought I vaguelly remembered something like that
21:50:29 <ivanm> if it's called Cabal, only install newer versions
21:50:46 <wavewave> Axman6: not sure what I mean, either... what am I talking about..
21:51:19 <wavewave> some kind of type level array.
21:51:31 <ivanm> wavewave: why do you want this?
21:51:52 <wavewave> O(1) access with type safety?
21:53:01 <copumpkin> (Key,Value) where key is a type?
21:53:01 <wavewave> and value can be heterogeneous.
21:53:05 <copumpkin> it's a typeclass
21:53:06 <Axman6> how would that be useful?
21:53:32 <wavewave> Axman6: difficult question. :)
21:53:33 <copumpkin> a typeclass gives you lookup by type :P
21:53:44 <kmc> you can work with such a map in the type system using HList, I think
21:53:56 <kmc> if you want it at runtime, (Map TypeRep Dynamic) is probably your best bet
21:54:07 <kmc> it's a little gross but not too difficult
21:54:15 <wavewave> HList is most similar to what I am thinking.
21:54:18 <kmc> does it have to work for all types ever? or only for a small set?
21:54:20 <Axman6> data TypeableMap a = Map TypeRep a; lookupType :: Typeable t => TypeableMap a -> t -> Matbe a?
21:54:38 <wavewave> HLIist is O(1) access?
21:54:54 <Axman6> why is O(1) access important?
21:55:11 <shachaf> Axman6: Because 1 is the smallest positive integer.
21:55:16 <wavewave> Hmmm. even it provide HArray.
21:55:28 <shachaf> O(1) isn't cool. You know what's cool? O(1000)
21:55:39 <ivanm> wavewave: you're saying what you want, not your use case
21:55:40 <wavewave> I think HList is the best solution... that's actually typeclass solution.
21:56:03 <kmc> shachaf++
21:56:06 <kmc> shachaf+=1000
21:56:28 * Axman6 likes data types with O(0) lookup
21:56:36 * shachaf prefers O(1/n)
21:56:47 <wavewave> ivanm :  I want to have some compile time register .
21:57:08 <Axman6> what? >_<
21:57:08 <ivanm> wavewave: which means what?
21:57:10 <ivanm> and why?
21:57:26 <wavewave> define an operation as a type and register it to a registry.
21:57:37 <ivanm> ........ why?
21:57:38 <shachaf> regedit.exe
21:57:46 * ivanm starts gibbering
21:57:50 <wavewave> great..;-P
21:58:24 <ivanm> wavewave: nah, that was from shachaf's comment
21:58:37 <Axman6> wavewave: i can't make any sense of what you're trying to do
21:58:48 <wavewave> ivanm: I am also responding to shachaf. ;-)
21:58:49 <ivanm> wavewave: your comments just make me wish I drank :s
21:58:54 <ivanm> ahhh
21:59:21 <wavewave> hmm let me make myself more clear. wait.
22:00:06 <wavewave> I am now making a kind of memoization of all expensive operations.
22:00:18 <wavewave> associated with a datatype.
22:00:28 <ivanm> wavewave: in my experience, memoisation usually isn't that worth it
22:00:38 <ivanm> as it can lead to memory blow-ups for no benefits
22:00:55 <wavewave> so that memoisation table is expandable.
22:00:58 <Axman6> shachaf: now O(1/ack(n))?
22:00:59 <Axman6> not*
22:01:13 <wavewave> but I know what operation is needed in compile time.
22:01:14 <shachaf> Axman6: You know what's cool? O(1/1000ack(n))
22:01:26 <ivanm> e.g. in my current project, I got a speed-up and no memory blow-outs by explicitly re-computing some values
22:01:35 <Axman6> I see a constant coefficient there
22:01:37 <ivanm> shachaf: isn't that 1/1000 * ack(n) ?
22:01:38 <wavewave> so I would like to make it array-like, not map-like or list-like..
22:01:47 <shachaf> ivanm: The world may never know.
22:02:03 <ivanm> wavewave: you want it expandable but an array? :/
22:02:08 <ivanm> isn't that kinda contradictory?
22:02:16 <Axman6> wavewave: how does this have anything to do with arrays indexed by type?
22:02:17 <wavewave> ivanm: as I said.. I know it in compile time.
22:02:59 <wavewave> and such operation can have different result in different types.
22:03:05 <ivanm> Axman6: IIUC, he wants to associate each unique function with a unique data type
22:03:10 <ivanm> rather than having one big sum-type
22:03:25 <Axman6> that sounds a hell of a lot like type classes to me. what am i missing?
22:03:37 <wavewave> so it's better as associated with type.
22:03:44 <wavewave> ivanm: correct.
22:03:54 <ivanm> Axman6: agreed
22:04:01 <ivanm> wavewave: why do you need that in an array though?
22:04:03 <wavewave> Axman6: that's right.
22:04:14 <Axman6> when... use type classes >_<
22:04:20 <wavewave> ivanm: not necessarily array.
22:04:27 <ivanm> if you have a unique type to a unique function, why not use an implicit lookup table via a typeclass rather than an explicit lookup table?
22:04:44 <wavewave> Axman6: yes.. I am just wondering if there is good typeclass library.
22:04:57 <Axman6> library? >_<
22:04:58 <Axman6> what?
22:05:03 <wavewave> for generic cases.
22:05:07 <Axman6> they're part of the language >_<
22:05:10 <Axman6> like what?
22:05:25 <Axman6> you can derive classes if you want to
22:05:27 <wavewave> Axman6: I mean Succ, Prev kind of generic operation.
22:05:43 <ivanm> wavewave: wait, you want some kind of locational aspect to your function lookup?
22:05:45 <ivanm> why?
22:05:59 <ivanm> wavewave: do you have some actual application for this, or are you just brainstorming/wishful thinking?
22:06:01 <monochrom> 1/goodstein(n) ftw. ackermann's nothing. http://en.wikipedia.org/wiki/Goodstein%27s_theorem
22:06:01 <Axman6> i still have no idea what you're on about. i think i'm going to stop reading now before i get too frustrated
22:06:06 <kmc> shachaf et al:  should I allow something like "$+foo" to mean "expand variable 'foo' without escaping"?
22:06:13 <kmc> if so, what's the best concrete syntax for it
22:06:13 <wavewave> Axman6: I know, I know.. I am just thinking of what I can do more generically.
22:06:48 <ivanm> wavewave: until you have a use-case, don't bother
22:07:11 <wavewave> ivanm: I am not yet clear what I can do..
22:07:35 <monochrom> goodstein(n) is so large you need a consistency proof of PA for it
22:07:46 <Axman6> PA?
22:07:52 <monochrom> Peano arithmetic
22:08:02 <ivanm> wavewave: find a problem you want to work on and work on it
22:08:09 <ivanm> as in an actual computational problem to solve
22:08:24 <wavewave> ivanm: definitely I have a problem. no wonder for that.
22:08:47 <monochrom> wavewave: implement Goodstein's sequence: http://en.wikipedia.org/wiki/Goodstein%27s_theorem :)
22:08:47 <wavewave> ivanm: I am searching for design options.
22:09:10 <Axman6> heh
22:09:13 <wavewave> and see how others work. that's it.
22:09:22 <ivanm> wavewave: well, what are you wanting to do?
22:09:40 <ivanm> you'd be better off asking for advice on how to solve it than come up with weird brainstorms that don't make much sense ;)
22:10:04 <wavewave> I am making matrix calculation library that's not sharing operations.
22:10:42 <wavewave> hmatrix is not treating sharing operation well.
22:10:47 <Axman6> what do you mean by sharing operations?
22:10:50 <ivanm> what do you mean by sharing operations
22:10:51 <ivanm> ?
22:10:54 <Axman6> heh
22:10:59 <Axman6> jynx!
22:10:59 <ivanm> @quote stereo
22:10:59 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
22:11:17 <wavewave> for example, if you calculate determinant and inverse of a matrix
22:11:41 <Axman6> i'd use a lazy datatype for thay
22:11:46 <wavewave> actually they share lots of operation in LU decomposition.
22:12:25 <ivanm> Axman6: yeah, represent a matrix by a record type with some lazily calculated caching of values embedded within it
22:12:30 <wavewave> so to make LU decompostion shared for inverse and determinant.
22:12:43 <wavewave> yes.. that's exactly what I am doing.
22:12:44 <Axman6> data Mat a = Mat (Matrix a) (Matrix a) a (the matrix, the inverse, and the determinate), then have: mkMat :: Matrix a -> Mat a; mkMat m = Mat m (inverse m) (det m)
22:13:05 <Axman6> then you only ever calculate those values once, and they never get computed if you never use them
22:13:08 <wavewave> now I would like (Mat a) type expandable with
22:13:12 <wavewave> other operations.
22:13:27 <wavewave> Axman6: I already made it like that ;-)
22:13:41 <ivanm> smart constructors ftw!
22:13:41 <Axman6> i think i see now
22:13:49 <ivanm> Axman6: you do? :o
22:13:51 <wavewave> but now I need to add more operation.
22:14:07 <wavewave> if I predefined such a thing..
22:14:22 <ivanm> wavewave: wait, you want to have which operations are stored be "dynamic" rather than having a fixed set of them at library design time?
22:14:23 <Axman6> so, you want something like: data Mat a = Mat (Matrix a) (Map Operation <result>)
22:14:30 <ivanm> I wonder if a tagging approach ala edwardk would work...
22:14:34 <wavewave> later, I will regret.. so now I am thinking of.. what's option.
22:14:55 <wavewave> ivanm: that's why I am thinking compile time operation.
22:15:06 <Axman6> where <result> might be a Matrix a or an a, or something else completely
22:15:15 <wavewave> tagging.. that's good.. I didn't come up with that
22:15:48 <ivanm> Axman6: though that requires Operation to be a sum-type
22:15:55 <Axman6> sure
22:16:00 <wavewave> Axman6, ivanm : did I make clear now what the problem is?
22:16:06 <ivanm> maybe use some kind of existential around a type-class...
22:16:11 <ivanm> wavewave: sure, that makes more sense
22:16:26 <ivanm> I think a tagging approach using type-classes might be another way of doing it
22:16:43 <wavewave> yeah. I am now searching it.
22:17:05 <wavewave> what was the library name?
22:18:04 <Axman6> if it's ala edwardk... you could just ask him =)
22:18:27 <edwardk> hah
22:18:39 <edwardk> its not like i'm ever around or anything
22:18:44 <Axman6> yeah
22:18:51 <Axman6> when was the last time you were on irc?
22:18:55 <Axman6> never
22:20:11 <wavewave> edwardk: hi.
22:20:32 <wavewave> actually I was making a library after I discussed you and Cale.
22:20:59 <joe6> anyone knows how to fix this: http://codepad.org/gHutIobL, error: http://codepad.org/lea0QVip
22:21:38 <ivanm> Axman6: actually... I wonder if using a unordered Map with a newtype around String being used would work
22:21:49 <edwardk> will the set of operations be something you'll set once and could carry around as a phantom type parameter that every matrix shared? or would it be something you'd have to build as you performed each action on each matrix
22:21:54 <ivanm> so you just have to define somewhere what the possible caches are...
22:22:52 <Axman6> wavewave: what are the possible results you want? there's Matrix a, there's a, there's possible Vector a, and maybe some Ints for things like size maybe?
22:22:59 <wavewave> edwardk: having phantom type parameter is good.
22:24:16 <edwardk> the reason i ask is you could use reflection to reflect an hlist worth of slots you want to attach and let a term level version of that hold onto the cached value
22:24:29 <edwardk> kinda hard to explain/get right though
22:25:21 <azaq231> joo: seems like the package you are trying to compile forgot to turn on the BangPattern extension, but I'm guessing
22:25:37 <azaq231> this would be a package bug, though one which is easy to fix
22:25:42 <joe6> azaq231: it has the BangPattern extension
22:25:52 <joe6> at the very top in Language extension
22:26:01 <joe6> it appears something more than that.
22:27:10 <kmc> is there a standard name/library for a polymorphic function which acts like 'id' on String, and like 'show' on other types?
22:27:18 <wavewave> edwardk: a little difficult to understand. what is the context of reflection here?
22:27:28 <Axman6> showList?
22:27:33 <Axman6> maybe not
22:27:33 <ivanm> joe6: I thought that the LANGUAGE pragma had to be before the comments
22:27:42 <joe6> oh, really.
22:27:44 <wavewave> edwardk: although it seems hard to explain here.
22:27:47 <joe6> let me change that and try.
22:27:53 <edwardk> yeah
22:28:05 <edwardk> http://hackage.haskell.org/package/reflection
22:28:17 <edwardk> if you aren't familiar with it, that might be a good starting place for ideas
22:28:28 <azaq231> joe6: that should be the reason, pragma's having to be before anything else, I also retested this just yet
22:28:31 <edwardk> in particular oleg and ken's paper
22:28:39 <ivanm> joe6: if that's not it, just have soemthing like: let r = tk m l in length l `seq` r `seq` r
22:28:50 <wavewave> edwardk: oh, yeah.. also tagged was the library name ivanm mentioned.
22:29:05 <ivanm> wavewave: I didn't mean a particular library, I just meant the approach
22:29:09 <joe6> http://codepad.org/umJDsZZ6, ivanm, error: http://codepad.org/HqineBl2, same error as before.
22:29:17 <joe6> it appears to need something more.
22:29:21 <ivanm> well, remove the bang then
22:29:23 <Axman6> r `seq` r makes no sense
22:29:30 <joe6> ivanm, will do that.
22:29:33 <ivanm> Axman6: doesn't it?
22:29:33 <wavewave> ivanm, Axman6, edwardk: thanks all !!
22:29:35 <ivanm> why not?
22:29:47 <kmc> (r `seq` r) ≡ r
22:29:49 <joe6> i am just trying to install this library.
22:29:57 <Axman6> because it says: "Before you evaluate r, to WHNF, evaluate r to WHNF"
22:30:00 <ion> Unless i’m badly mistaken, that means “when evaluating r, evaluate r first.”
22:30:04 <kmc> not even "before", really
22:30:09 <ivanm> Axman6: does it make any sense to have the bang there then?
22:30:10 <edwardk> i have some unfinished changes to intern that would also work theoretically. the approach being to treat each object as a region of some sort, but it sounds messy
22:30:20 <kmc> evaluating «r `seq` r» evaluates r and r, in either order
22:30:28 <Axman6> ivanm: where's this bang?
22:30:31 <ion> Ah, right.
22:30:46 <ivanm> Axman6: it's currently: let !r = tk m l in length l `seq` r
22:30:55 <ivanm> so I was just trying to duplicate the current behaviour without the bang
22:30:56 <joe6> Axman6: http://codepad.org/1fXanenL
22:31:06 <ivanm> line 140 or something IIRC
22:31:11 <shachaf> Did you people ever decide whether the reverse of an infinite list should be _|_ or an infinite spine of _|_s?
22:31:22 <Axman6> i don't think so
22:31:39 <edwardk> shachaf: i'm not willing to do the reversal twice to get the latter
22:31:53 <shachaf> edwardk: You don't need to do the reversal twice.
22:32:00 <ivanm> edwardk: you want reverse [1..] to be repeat undefined ?
22:32:02 <ivanm> why?
22:32:10 <ivanm> (just curious as to reasoning)
22:32:21 <ivanm> because you want to imply that reverse of an infinite list is an infinite list?
22:32:22 <edwardk> > reverse [1..]
22:32:24 <shachaf> edwardk: When you reverse a list you can start giving n conses immediately as soon as you see n conses, even if you don't have the values yet.
22:32:28 <lambdabot>   mueval-core: Time limit exceeded
22:32:41 <shachaf> kmc argues once that that wasn't valid because of infinite lists.
22:32:45 <shachaf> s/s/d/
22:32:50 <edwardk> thats reverse of an infinite list ;)
22:32:56 <ivanm> shachaf: though how would you change the implementation to make it the latter?
22:33:19 <edwardk> now you can play some games where you do the reverse in a fashion where you can figure out the spine but can never evaluate the elements
22:33:25 <edwardk> but its painful
22:33:29 <ivanm> > length . take 3 $ reverse [1..]
22:33:30 <shachaf> It's not that painful.
22:33:35 <lambdabot>   mueval: ExitFailure 1
22:33:35 <lambdabot>  mueval-core: Time limit exceeded
22:33:41 <shachaf> And for finite list it makes reverse lazier, which is arguably a good thing.
22:34:13 <edwardk> http://hpaste.org/45385 is pretty painful
22:35:08 <edwardk> i would argue that reversing an infinite list is a mistake, like taking its length
22:35:09 <shachaf> edwardk: I seem to remember an implementation that was much less painful than that.
22:36:07 <edwardk> there are several
22:36:27 <edwardk> but in general i don't buy the 'lazy as possible' arguments
22:36:35 <edwardk> they tend to lead to structures that leak like a sieve when used
22:37:20 <edwardk> its cute that you can make a lazy writer monad, but then fmap f _|_ = (_|_,_|_) makes the monad laws hold only questionably
22:38:33 <edwardk> and so you wind up with tension between the strict-enough-to-be-useful and the lazy-enough-to-support-some-fringe-case camp ;)
22:39:19 <shachaf> edwardk: You could make that argument about any level of laziness/strictness. :-)
22:39:48 <cheater> hi
22:39:55 <edwardk> well, the main point at which i diverge is that reverse as it exists is at a good point for being able to compose algorithms
22:39:56 <cheater> how do i get user input in haskell?
22:40:02 <shachaf> getLine
22:40:05 <shachaf> @ty getLine
22:40:07 <lambdabot> IO String
22:40:19 <edwardk> i don't really get much compositionality benefit from a slightly lazier but more expensive reverse
22:40:23 <edwardk> and i pay for it everywhere
22:40:24 <ivanm> @type readLn
22:40:25 <lambdabot> forall a. (Read a) => IO a
22:40:32 <shachaf> edwardk: Fair enough.
22:40:38 <ivanm> @src readLn
22:40:38 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
22:40:48 <ivanm> @src readIO
22:40:48 <lambdabot> Source not found. Are you on drugs?
22:40:52 <ivanm> @type readIO
22:40:53 <lambdabot> forall a. (Read a) => String -> IO a
22:41:08 <ivanm> is readIO just read but with a non-error error message or something?
22:41:24 <kmc> it raises an IO exception
22:41:48 <kmc> and it does the parsing on execution, not on evaluation
22:41:53 <kmc> so the interaction with "catch" is less surprising
22:41:56 <cheater> hmm
22:42:02 <cheater> ok, trying to use readLn then
22:42:29 <shachaf> (\x -> unsafePerformIO $ catch (Just <$> readIO x) (\_ -> return Nothing))
22:42:38 <edwardk> and there is precedent. for instance Control.Monad.ST is the strict version because people kept getting tripped up by the lazy one.
22:43:17 <ivanm> cheater: note that readLn assumes the entire line is indeed a valid representation
22:43:34 <cheater> of?
22:43:57 <ivanm> same as read
22:44:02 <ivanm> > read "1a"
22:44:03 <lambdabot>   *Exception: Prelude.read: no parse
22:44:09 <ivanm> > reads "1a"
22:44:11 <lambdabot>   []
22:44:18 <ivanm> bah, stupid type defaulting
22:44:20 <ivanm> > reads "1a" :: Int
22:44:21 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
22:44:21 <lambdabot>         against inferred type ...
22:44:24 <Axman6> > reads "()"
22:44:25 <lambdabot>   [((),"")]
22:44:29 <cheater> > reads "1"
22:44:29 * Axman6 wins
22:44:30 <lambdabot>   []
22:44:33 <ion> > (reads :: ReadS Int) "1a"
22:44:34 <lambdabot>   [(1,"a")]
22:45:27 <ivanm> > read "1a" :: Int
22:45:28 <lambdabot>   *Exception: Prelude.read: no parse
22:45:38 <ivanm> ^^ readLn would have similar behaviour to that
22:46:41 <cheater> ok let me try readLn
22:47:03 <Axman6> > (reads :: ReadS Word8) "1234"
22:47:04 <lambdabot>   [(210,"")]
22:47:10 <Axman6> > (reads :: ReadS Word8) "12345"
22:47:11 <lambdabot>   [(57,"")]
22:47:16 <cheater> ugh, how do i write a script that gets interpreted by ghci and executes a function?
22:47:18 <Axman6> heh
22:47:28 <Axman6> > (reads :: ReadS Word8) "0xFF"
22:47:29 <lambdabot>   [(255,"")]
22:47:32 <Axman6> > (reads :: ReadS Word8) "0xFFF"
22:47:33 <lambdabot>   [(255,"")]
22:47:39 <Axman6> > (reads :: ReadS Word8) "0xFFA"
22:47:40 <lambdabot>   [(250,"")]
22:48:12 <ivanm> cheater: #!/usr/bin/runhaskell ?
22:48:43 <cheater> and how do i make it choose the function to run?
22:48:46 <cheater> or do i just call it
22:48:47 <ivanm> OK, so I made a change to my code which resulted in the runtime increasing, but the profiling results look identical :s
22:49:10 <ivanm> cheater: wait, you want to pass in a function at runtime?
22:49:21 <cheater> nah
22:49:26 <cheater> i just want it to execute
22:49:36 <ivanm> you have used haskell before, right? :/
22:49:45 <ivanm> I mean, you've been hanging around in -blah for long enough :s
22:50:00 <cheater> before, but not in the last half a year! :D
22:50:10 <cheater> i couldn't get it on my pc in that time
22:51:14 <cheater> is there like a haskell-safe way to do a shebang
22:51:34 <cheater> so that i can also import the same file as a module
22:51:52 <ivanm> sure, just shove the shebang up the top of the file
22:51:58 <cheater> it's at the top
22:52:06 <ivanm> and have a main
22:52:31 <cheater> so i'd do something like define main, and then just call it at the end of the file?
22:52:42 <ivanm> you don't call it
22:52:48 <cheater> oh?
22:52:56 <ivanm> cheater: scripting in haskell isn't like doing so in bash/python: you don't have a list of statements at the end
22:53:00 <cheater> runhaskell does?
22:53:02 <ivanm> you run everything through main
22:53:16 <ivanm> same as a full-blown haskell program
22:56:29 <kmc> woah edwardk publishes blog posts almost as quickly as package releases
22:56:37 <edwardk> heh
22:56:48 <Axman6> D:
22:56:54 <edwardk> they cluster ;)
22:57:43 <ivanm> kmc: wait, what are you talking about? he hasn't written a new one for a couple of hours now!
22:58:15 <edwardk> have to actually do the research to make the next one work
22:58:28 <edwardk> i have an implementation but i want it to feel haskelly
22:58:37 <ivanm> edwardk: your side bar is full of broken links though...
22:58:42 <edwardk> yeah
22:58:48 <ivanm> I mean, the TMR one links to hawiki!
22:59:06 <cheater> hrm
22:59:28 <edwardk> and the tag cloud silently broke at some point when my blog switched machines
22:59:44 <edwardk> as did the old tiddly wiki content
23:00:24 <ivanm> when profiling, the entries column is how many times a function was called, right?
23:00:34 <ivanm> if so, why do my profiling reports say that main was called 5 times?
23:00:55 <edwardk> http://comonad.com/tiddly.php seems to still have the tiddly content, so it seems that upgrading wordpress somewhere along the way ate the hack that i had written to display wiki content inline
23:02:11 <edwardk> its funny looking back on the stuff i wrote even 5 years ago. it seems so… quaint
23:03:01 <ivanm> yet still incomprehensible to the average Haskeller!
23:03:13 <ivanm> (let alone an intelligent Java user :p)
23:03:43 <cheater> hey guys, anyone got lyah as one-big-html?
23:04:32 <ivanm> cheater: there was an unofficial PDF floating around at one stage
23:04:35 <copumpkin> edwardk: now that I look at your flipcode articles, they look slightly familiar. I probably read them back in high school :P
23:04:37 <ivanm> or else you can buy a PDF
23:04:56 <edwardk> heh
23:05:00 <cheater> there's a pdf but it doesn't have source colorization or the images
23:05:08 <cheater> it's available free from the website
23:05:25 <cheater> but it's monochrome and looks like written in 60s TeX
23:06:56 <ivanm> maybe the for-sale one has colours *shrug*
23:08:21 <cheater> no the book doesn't have em either i believe
23:08:24 <cheater> it's bw
23:08:49 <ivanm> I meant the for-sale PDF
23:09:54 <cheater> dunno
23:10:26 <ivanm> is syntax highlighting that big a deal though when reading a tutorial?
23:10:49 <ion> I prefer it.
23:12:03 <ivanm> preferable, yes
23:12:09 <ivanm> but is it a deal-breaker?
23:12:19 <ivanm> cheater: you could always try wget'ing the site...
23:13:43 <cheater> that is what i am doing.
23:13:46 <cheater> except with firefox.
23:19:47 <ivanm> well, wget has a recursive option
23:20:04 <ivanm> or else you could possibly just use DownThemAll from the contents page
23:28:40 <joe6> what could I be doing wrong? http://codepad.org/XBj95YNs
23:28:44 <joe6> the .xmobarrc is a symbolic link.
23:28:48 <joe6> could that make a difference in how xmobar reads the file?
23:28:57 <joe6> does haskell need some kind of library path, if xmobar needs some libraries?
23:29:01 <joe6> i have different ghc's for root and the user joe, could that be making a difference?
23:29:55 <ivanm> joe6: it shouldn't: by default, executables are statically linked (For haskell libraries anyway)
23:30:05 <ivanm> and I don't think xmobar uses ghc after it's compiled
23:30:16 <joe6> main# ls -altr /home/j/.xmobarrc
23:30:16 <joe6> lrwxrwxrwx 1 joe users 25 Sep 24 03:17 /home/j/.xmobarrc -> /home/j/prd/conf/xmobarrc
23:30:27 <joe6> so, the data file is there.
23:30:27 <ivanm> joe6: that error indicates that you might have an encoding issue
23:30:40 <ivanm> do you have any non-ascii characters in there?
23:31:05 <ivanm> and the first error means you may need to have the border and borderColor fields specified
23:31:06 <joe6> http://codepad.org/VtMoEcT5
23:31:22 <joe6> ivanm, that is just a warning
23:31:31 <ivanm> OK
23:31:36 <joe6> i do not think that is responsible for xmobar crashing.
23:31:36 <ivanm> so why are you su'ing though?
23:32:06 <joe6> ivanm, this is how startx runs the xmonad from .xinitrc, I presume.
23:32:26 <ivanm> ummmm.... that output? :/
23:32:39 <joe6> this is run from startx -> .xinitrc (exec /home/j/.cabal/bin/xmonad) -> spawnPipe of xmonad starts this command.
23:32:53 <ivanm> if that's just the output from startx, then it appears your .xinitrc is weird :s
23:34:02 <joe6> http://codepad.org/qKVcNogM is the output from startx
23:35:32 <joe6>  xmproc <- spawnPipe "/home/j/.cabal/bin/xmobar /home/j/.xmobarrc"
23:35:37 <joe6> from xmonad.hs
23:47:21 <cwl> @src fmap
23:47:21 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:47:35 <cwl> :t fmap
23:47:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:48:17 <cwl> @src fmap :: (a -> b) -> (->a) -> (->b)
23:48:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:48:35 <cwl> :t (->)
23:48:36 <lambdabot> parse error on input `->'
23:48:40 <cwl> :t Jus
23:48:42 <lambdabot> Not in scope: data constructor `Jus'
23:48:44 <cwl> :t Just
23:48:45 <lambdabot> forall a. a -> Maybe a
23:48:47 <cwl> :t Maybe
23:48:48 <lambdabot> Not in scope: data constructor `Maybe'
23:48:53 <cwl> :info Maybe
23:49:01 <cwl> :info (->)
