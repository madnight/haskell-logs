00:04:52 <kmc> you can already do something like scoped instances with GHC's ImplicitParams extension
00:05:24 <kmc> the problem is that some libraries depend for correctness on instances being global
00:05:52 <kmc> if I build a (Data.Map K V) under my scoped instance (Ord K) and you build another under another instance, and we union our maps, what happens?
00:07:16 <Veinor> "don't cross the maps"
00:16:13 <kmc> copumpkin, you're such an optimist :)
00:17:45 <companion_cube> a coptimist
00:24:48 <erus`> how can i compile haskell to llvm bytecode and use it with pnacl ?
00:26:26 <Veinor> oh dang, capri looks neat
00:26:31 <Veinor> like virtualenv but haskell
00:27:46 <kmc> erus`, ghc -fllvm -keep-llvm-files
00:27:52 <kmc> this is not nearly enough but it's a place to start
00:58:04 <hpaste> “Per Persson” annotated “IO Monad?!” with “IO Monad?! (annotation)” at http://hpaste.org/51265#a51285
01:02:24 <weltensegler> Hello there, i have two classes "Super SuperClass and i want every type that is an instance of SubClass to be an instance of SuperClass.
01:02:28 <weltensegler> oops.
01:03:08 <weltensegler> please make that "i have two classes Subclass and SuperClass".
01:03:26 <weltensegler> How do i do that?
01:04:09 <weltensegler> i tried  "instance (SubClass a) => SuperClass a" but i get an error.
01:05:02 <quicksilver> make the superclass part of the class declaration of subclass
01:05:11 <quicksilver> class SuperClass a => SubClass a where
01:09:06 <weltensegler> ok, but it seems i still have to add an instance declaration (SuperClass t) for every type t that is an instance of SubClass.
01:10:38 <erus`> when is the FP conference?
01:11:24 <danr> erus`: ICFP is in Tokyo, September 19-21, 2011
01:12:14 <erus`> yey should be a few new videos to watch in bed :)
01:13:16 <erus`> i hope they have some exciting stuff
01:13:40 <erus`> its funny what different things people find 'exciting'
01:13:53 <quicksilver> weltensegler: yes, you do.
01:14:03 <quicksilver> weltensegler: there is nothign which writes automatic instances for you.k
01:14:08 <quicksilver> there are some proposals.
01:20:54 <weltensegler> quicksilver, thank you. I think that this suggests i should rethink my implemenation.
01:36:02 <ruuby> can someone explain to me why pure code is inherently safe with respect to asynchronous exceptions? (a statement that I found while reading "async exceptions in haskell")
01:37:24 <merijn> ruuby: This is a wild ass guess: The problem with exceptions is that they can change global state in unpredictable ways so that when control flow resumes you are not entirely sure about the program state. Pure code has no mutable state so the exception cannot have influenced it
01:37:47 <Veinor> that sounds about right
01:38:24 <merijn> ruuby: So it doesn't matter when an exception occurs during a computation, as long as it happens before the final result the resulting state will always be identical
01:38:34 <quicksilver> and pure code is used to being stopped and started anyway
01:38:40 <quicksilver> because that's what thunking/laziness do
01:38:48 * hackagebot time 1.4 - A time library  http://hackage.haskell.org/package/time-1.4 (AshleyYakeley)
01:38:50 * hackagebot ls-usb 0.1.0.10 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.10 (RoelVanDijk)
01:38:51 * merijn wasn't completely wrong \o/
01:38:58 <quicksilver> so if you go back and try to evalute a thunk which previously got interrupted by an async exception, no harm done.
01:39:39 <ddarius> Pure code has no notion of time.
01:40:03 <merijn> It does if you somehow include a first class notion of time </FRP>
01:40:28 <ddarius> FRP models time.
01:40:39 <quicksilver> ddarius: that's quite true, but the point I was making was that interruptions don't somehow "damage" the evaluation in progress
01:40:57 <quicksilver> it can still continue if that thunk/value gets demanded later after the exception is caught
01:40:59 <merijn> I don't exclude the possibility of being completely wrong about FRP, since I still don't quite get it >.>
01:41:18 <ddarius> quicksilver: My statement wasn't a rebuttal of anything.
01:41:24 * quicksilver nods
01:41:33 <Eduard_Munteanu> I think evaluation is a bit racy, as a sidenote, but it doesn't affect semantics (it *might* just duplicate work).
01:42:07 <ruuby> Hm oke, but then somewhere on the implementation level the evaluation process is protected such that it is not left in a "partial/damaged" state in case of a async exception?
01:43:05 <quicksilver> in a sense, yes
01:43:08 <Eduard_Munteanu> Sure, the implementation has to deal with keeping state, somewhere.
01:43:12 <quicksilver> it's not particularly hard to do
01:43:23 <quicksilver> and it's (almost) the same thing you have to do to make it multi-thread safe, as well
01:46:21 <ruuby> Oke thanks! This all makes it a bit more insightful for me.
01:48:48 * hackagebot tfp 0.3 - Type-level programming library using type families  http://hackage.haskell.org/package/tfp-0.3 (PeterGavin)
01:58:48 * hackagebot secdh 0.1 - SECDH Machine Simulator  http://hackage.haskell.org/package/secdh-0.1 (PeterGavin)
02:23:49 * hackagebot cabal-macosx 0.1.2.1 - Cabal support for creating Mac OSX application bundles.  http://hackage.haskell.org/package/cabal-macosx-0.1.2.1 (AndyGimblett)
02:24:42 <joepatrick> Hi. I'm using Haskell STM. My transactions are aborting every single time. I'm not using any writeTVar, just readTVar, and as far as I can see there's no exceptions being thrown. Is there a good way to figure out why they are aborting?
02:26:18 <Cale> joepatrick: uh, that's odd, and you're not using retry explicitly?
02:27:42 <joepatrick> Cale: no, the only STM operation that I'm using is writeTVar (everything else commented out)
02:27:50 <Cale> You mean read?
02:28:09 <joepatrick> Cale: sorry, yeah read
02:28:23 <joepatrick> Cale: I'm trying to boil the program down the bare basics which still shows the problem, but not managed it yet as it's part of a bigger program
02:28:55 <Cale> So, all that should happen is that you always read the initial values of the TVars since they're not being set anywhere
02:29:01 <joepatrick> Cale: it works with one processor -N1, but with -N2 every transaction retries after about half way through
02:29:12 <Cale> huh
02:29:18 <Cale> That's interesting
02:29:48 <joepatrick> Cale: it's quite memory intensive, but i doubt it's running out of heap, anyway that would throw an exception which i would see (i'm using catchSTM)
02:30:40 <joepatrick> Cale: this is ghc-7.2.1-x86_64-apple-darwin, using the build from haskell.org. It's marked as testing, but the STM libraries aren't new, and everything else is very stable
02:32:59 <Cale> How can you tell that the transactions are aborting halfway through?
02:33:06 <Cale> (Given that they have no effects)
02:34:11 <joepatrick> Cale: using trace. My main recursive function traces when its called and again at the stopping point. When I run -N1 I see x traces and then the stopping point trace, when I run -N2 I see about x/2 traces, and no stopping point trace.
02:35:02 <Cale> hmm, so you're tracing the evaluation of the STM action, rather than its execution.
02:35:37 <Cale> I suppose that should work somewhat
02:36:01 <joepatrick> effecitvely i'm doing "x <- trace "XX" $ readTVar ..."
02:39:13 <Cale> Yeah, and there's probably no reason to suspect GHC should be smart enough to avoid evaluating that.
02:39:50 <Cale> Where does it get stopped?
02:39:57 <Cale> A random place every time?
02:39:58 <Saizan> you could just put a putStrLn after the atomically call, btw
02:41:00 <joepatrick> Cale: it looks like it's happening the same each time, but hard to be sure. the output of the traces is probably the same apart from some reordering which i would expect
02:42:41 <kizzx2> is it possible to put newtype Int in Data.Vector.Unboxed?
02:42:51 <frerich> Are some good examples of when "nesting" monads (like a value '(Monad m1, Monad m) => m (m1 (IO ()))') is useful in practice?
02:43:10 <joepatrick> Cale: ok if this behaviour isn't what you'd expect either, i'll see if i can boil it down to a minimum problem and then i'll put it on the mailing list
02:44:50 <joepatrick> Cale: just to be sure, two reads from the same tvar should never cause an abort, should they? and apart from an exception there is no need for an abort in any other case?
02:45:22 <quicksilver> aborts happen at commit time
02:45:32 <quicksilver> well, I'd call them retrys.
02:46:10 <joepatrick> quicksilver: doesn't haskell do a validate when it resumes a thread? and couldn't it retry based on that? that's what the 2005 paper says
02:46:27 <quicksilver> you could be right
02:46:34 <quicksilver> that wasn't my understanding, but I've been wrong before :)
02:46:42 <Jafet> kizzx2: if you write an MVector instance for the newtype.
02:47:15 <joepatrick> quicksilver: otherwise you get 'zombie' transactions that are operating with inconsistent state and could enter non-terminating loops
02:47:30 <Jafet> Er, or UVector or Vector, whichever it is
02:48:19 <kizzx2> Jafet: it seems quite heavy, trying to see if i can use GenerlaizedNewTypeDeriving or something :P
02:49:03 <kizzx2> i see that VU.fromList has Unbox a => [a] -> Vector a
02:49:45 <kizzx2> but it's definition is quite strange i'm not sure how to properly derive an instance (http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/src/Data-Vector-Unboxed-Base.html#Unbox)
02:50:42 <Jafet> I don't think you can use GNTD, because Int is not the instance head.
02:50:52 <Jafet> You need MPTCs for those.
02:51:04 <Jafet> Er, well, those are MPTCs.
02:53:01 <kizzx2> so it seems like the short answer is "no you can't" :('
02:53:20 <kizzx2> or "no it's not quite supported"
02:53:42 <Cale> frerich: Maybe m = Parser and m1 = Maybe?
02:53:55 <Jafet> Where did you get that notion?
02:53:58 <Cale> frerich: Parser (Maybe (IO ())) seems possibly useful
02:54:36 <Cale> frerich: In general, there are lots of ways to have datastructures of datastructures which are useful, and the fact that they happen to be monads isn't really special?
02:55:09 <Saizan> kizzx2: tried "newtype Foo = Foo Int deriving (Unbox, M.MVector MVector, G.Vector Vector)" ?
02:55:37 <Jafet> Oh cool, that works?
02:55:56 <Saizan> yep
02:56:44 <Jafet> I only know ghc's switches for magic, not for more magic.
02:56:45 <kamaji> Is anyone working on a parallelism library like repa or DPH but for distributed memory systems?
02:57:21 <kizzx2> Saizan: wow that works
02:58:51 * hackagebot typelevel-tensor 0.1 - Tensors whose ranks and dimensions type-inferred and type-checked.  http://hackage.haskell.org/package/typelevel-tensor-0.1 (TakayukiMuranushi)
02:59:53 <kizzx2> heh
03:00:15 <kizzx2> kind of anti-climatic, after knowing that it works it turned out one actually needed to follow GHC's error message as instructions :P
03:00:38 <mauke> how boring
03:02:34 <xil> hello. I'm looking for a graphics library for 2D graphics. I am usably familiar with OpenGL and have created graphics with it before. But I found out about SDL and am wondering if that would be better. Or, is there another recommended library? The important thing is to be able to draw ponits. In OpenGL I suspect that I'll have to do it with textures, which might be computationally wasteful?
03:03:15 <obiwahn> points?
03:03:37 <Jafet> Textures aren't even geometric primitives...
03:03:46 <obiwahn> ponies?
03:03:49 <Starfire> Are you looking for a Haskell library?
03:03:58 <Jafet> Of course OpenGL lets you draw points. Perhaps you should become more familiar with it.
03:04:13 <xil> obiwahn: I'm making a little program to display the mandelbrot set, so I need to be able to set the value of points on screen
03:04:29 <xil> Jafet: really? I thought that everything was in the floating-point space
03:04:29 <Jafet> Okay, people call those pixels.
03:04:36 <obiwahn> if you want really simple graphics you could use dotty
03:05:00 <xil> Starfire: preferably yes
03:05:44 <Jafet> OpenGL has been wasted in bigger ways. Besides, you can probably write to the framebuffer directly.
03:06:01 <xil> Jafet: looking that up now
03:06:14 <obiwahn> olo:)http://xkcd.com/722/
03:06:38 <Starfire> I would think that writing to a texture would be sufficiently fast.
03:07:44 <Entroacceptor> xil: http://glprogramming.com/red/chapter08.html
03:07:49 <xil> Starfire: okay I'll probably do that then, if I can't find a way to set pixels directly
03:08:04 <Entroacceptor> and SDL can do that, too
03:08:19 <Jafet> You can also do that with SDL and OpenGL
03:08:28 <Entroacceptor> and even without opengl
03:08:28 <erus`> its a pain with opengl
03:08:35 <erus`> sdl you can just blit some memory
03:08:46 <Jafet> Unless you were planning to draw mandelbrot in shaders
03:08:50 <erus`> opengl you have to loadTexture2d then draw it etc
03:09:37 <xil> erus`: Entroacceptor actually put me onto glDrawPixels, which should be easier than my original plan, haha
03:09:58 <xil> Jafet: I don't even know what shaders are. The plan was to do it pixel by pixel
03:10:07 <kamaji> xil: SDL is pretty good for 2D though
03:11:05 <Entroacceptor> yeah, the SDL lib looks ok
03:11:32 <erus`> just cant build it on windows :)
03:11:57 <xil> is it significantly faster than OpenGL would be? I mean, the computation may be the overwhelming bottleneck really. Might be easier to figure out glDrawPixels than learn SDL
03:12:25 <Starfire> If you're looking do draw static mandelbrot sets, then anything is probably fast enough.
03:13:06 <erus`> write a webserver and stream data to a canvas html element
03:13:08 <Jafet> SDL usually uses something like OpenGL to actually draw the screen, anyway.
03:13:20 <Starfire> Yeah, probably.
03:13:25 <xil> Starfire: well the user'll be able to navigate around, so speed is sort of important, but I plan on using Integers for theoretically infinite zooming, so the graphics speed might not matter at all
03:14:09 <Jafet> Wait, how do you compute the Julia iteration in Integer?
03:14:12 <Starfire> I'd guess that on a modern computer, the pixel plotting won't be the bottleneck.
03:14:30 <Entroacceptor> Starfire: even more so on older computerss ;)
03:14:54 <xil> Jafet: represent the floating point internal format instead as a few Integers, and do the floating point operations manually using the Integers
03:14:55 <Entroacceptor> I remember writing a mandelbrot set on my 386 sx (WITHOUT math unit)
03:15:00 <erus`> write it as a dos x86 .com file
03:15:01 * Jafet removes Entroacceptor's FPU
03:15:22 <Jafet> Oh, Entroacceptor beat me
03:15:42 <Entroacceptor> then I learned about integer calculations, made stuff a little bit faster =)
03:15:55 <Jafet> Fixed-point?
03:16:00 <Entroacceptor> yep
03:16:27 <Jafet> Does every mandelbrot viewer draw the screen one pixel at a time?
03:16:33 <Jafet> I haven't found one that doesn't
03:17:10 <Entroacceptor> there are renderers that put it in a framebuffer first?
03:17:19 <Entroacceptor> xaos was quite fun, too
03:17:22 <erus`> Jafet: are you talking about drawing the screen or drawing the actual fractal ?
03:17:26 <cwl> anyone know where the answer of All About Monads is ? http://horna.org.ua/books/All_About_Monads.pdf
03:17:33 <Jafet> I mean, that calculate the value at each pixel before drawing it.
03:17:38 <Veinor> Jafet: http://mathworld.wolfram.com/images/eps-gif/MandelbrotLemniscates_1000.gif? :P
03:17:52 <Entroacceptor> oh, nice
03:17:55 <Jafet> Okay, Veinor's got it
03:17:55 <cwl> Exercise 4
03:18:06 <Jafet> I wrote a program to draw it that way, it was nice to watch
03:18:12 <Entroacceptor> and I guess you can get your GPU shaders to do it nowadays
03:18:39 <Jafet> It was also satisfying because there was no arbitrary iteration limit
03:19:05 <obiwahn> cwl: page?
03:19:39 <cwl> obiwahn: 10
03:19:41 <xil> Jafet: how did you get the no iteration limit?
03:20:11 <Jafet> By moving the iteration counting loop outside the pixel drawing loop.
03:21:01 <xil> Jafet: .....how did you do that?
03:21:48 <cwl> I do exercise 2 :  parent s = (mother s) `mplus` (father s) ;  grandparent s = (parent s) >>= parent
03:21:48 <Jafet> Uhh, a text editor.
03:22:32 <cwl> and exercise 3: parent s = (maybeToList $ mother s) `mplus` (maybeToList $ father s)
03:22:35 <xil> Jafet: ...how did you know when to stop though, for black pixels?
03:22:45 <Jafet> It would just keep going.
03:22:48 <cwl> grandparent s = (parent s) >>= parent
03:23:04 <Jafet> (Why should it stop?)
03:23:19 <xil> Jafet: oh and the pixels would just stay black. So did you thread it for each pixel or something?
03:24:00 <Jafet> No, I didn't find it important to optimize the program.
03:24:23 <obiwahn> cwl: i am quite new as well and i like to help learn but could you plase use the hpaste to give me some code that is working so far?
03:24:28 <xil> wait, so it just got stuck on black pixels?
03:25:16 <Jafet> If they were part of the set, yes.
03:25:18 <cwl> obiwahn: what code?
03:25:29 <Entroacceptor> TIL there's something called Buddhabrot
03:25:35 <Jafet> (Or if they appeared to be, due to floating-point error.)
03:25:42 <Entroacceptor> which is highly irritating for me as a german
03:26:13 <Jafet> Zen communion.
03:26:15 <xil> Jafet: but how would it ever get to another pixel that isn't in the set? Wouldn't it just stall on the first pixel in set?
03:26:18 <cwl> obiwahn: there is only fake code, 'father' and 'mother', which returns the mother/father for the Sheep, Nothing if no mother/father
03:26:35 <obiwahn> eg MonadPlus
03:27:02 <Jafet> xil: I moved the pixel drawing loop inside the iteration counting loop.
03:27:04 <obiwahn> or the def o sheep
03:27:34 <cwl> obiwahn: sheep is not defined,
03:27:44 <cwl> obiwahn: just imagine it is defined
03:27:52 <Jafet> Sheep? In a family tree?
03:28:04 <cwl> Jafet: clone sheep
03:28:17 <cwl> Jafet: All About Monads
03:28:23 <merijn> Jafet: I remember a monad tutorial using family trees of sheep, forgot which one, though :p
03:28:36 <Jafet> Oh, er, of course.
03:28:37 <xil> Jafet: too much to take in over IRC right now I think. Thank you for indulging my questions though, haha =]
03:28:55 <Jafet> I was thinking of unsafeCoerce sheep
03:30:29 <cwl> merijn: do you mean http://carlo-hamalainen.net/blog/2011/02/11/monad-motivation/ ?
03:30:51 <merijn> cwl: No
03:33:46 <cwl> @src maybeToList
03:33:46 <lambdabot> maybeToList  Nothing   = []
03:33:46 <lambdabot> maybeToList  (Just x)  = [x]
03:35:57 <int-e> @type catMaybes . return
03:35:57 <lambdabot> forall a. Maybe a -> [a]
03:36:39 <cwl> @src maybeToMonad
03:36:39 <lambdabot> Source not found. There are some things that I just don't know.
03:37:02 <merijn> cwl: That one makes no sense...
03:37:09 <mauke> :t maybe (fail "Nothing") return
03:37:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
03:38:51 <int-e> @hoogle liftMaybe
03:38:53 <lambdabot> No results found
03:39:23 <int-e> Does MissingH or somesuch package have such a function? MonadPlus m => Maybe a -> m a?
03:39:39 <mauke> :t maybe mzero return
03:39:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
03:39:49 <int-e> there's always that, yes.
03:40:05 <Oxfaded> is there a haskell equivelant to INT_MAX?
03:40:11 <quicksilver> > maxBound :: Int
03:40:12 <lambdabot>   9223372036854775807
03:40:13 <int-e> > maxBound :: Int
03:40:13 <lambdabot>   9223372036854775807
03:40:19 <int-e> heh.
03:40:23 <Oxfaded> cheers
03:40:51 <hpc> > logBase 2 (fromIntegral (maxBound :: Int))
03:40:52 <lambdabot>   63.0
03:41:08 <koeien> the range of Int depends on your platform
03:41:37 <hpc> and only guaranteed to be 30 bits
03:43:35 <hpaste> “Per Persson” annotated “IO Monad - still confused” with “IO Monad - still confused (annotation)” at http://hpaste.org/51266#a51289
03:43:49 <cwl> ?MonadPlus
03:43:49 <lambdabot> Unknown command, try @list
03:43:53 <cwl> @list
03:43:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:44:23 <cwl> hoogle MonadPlus
03:44:33 <cwl> @hoogle MonadPlus
03:44:33 <lambdabot> Control.Monad class Monad m => MonadPlus m
03:45:04 <mauke> who is Per Persson?
03:46:03 <kamaji> How do I do "otherwise" or "default" in a case expressioN?
03:46:09 <mm_freak_> when a type synonym is not exported, but used in exported functions, haddock should expand the type
03:46:10 <kamaji> oh, just _ ?
03:46:10 <mauke> kamaji: _
03:46:16 <kamaji> heh, thanks :D
03:46:30 <mm_freak_> it's really inconvenient to have to look into to source code of the particular package all the time
03:49:37 <kamaji> What should readsPrec return on an undefined parse?
03:49:42 <kamaji> should I just use error?
03:50:12 <mauke> what do you mean by "undefined parse"?
03:50:34 <kamaji> so if I do read "a" :: MyType
03:50:44 <kamaji> but "a" isn't a valid expression for a MyType
03:50:47 <mauke> []
03:50:50 <kamaji> oh ok
03:51:12 <kamaji> what's the string you're supposed to return in those pairs?
03:51:23 <kamaji> I've just been doing the rest of the string that I haven't parsed, but i'm not sure that's right
03:51:31 <mauke> it is
03:51:45 <mauke> > reads "123abc" :: ReadS Int
03:51:46 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
03:51:46 <lambdabot>           ...
03:51:48 <kamaji> it seems to error if I do this though: `read "c x" :: MyType`
03:52:07 <mauke> :t reads "123abc"
03:52:08 <lambdabot> forall a. (Read a) => [(a, String)]
03:52:17 <kamaji> oh; 'read' is only for exact tokens?
03:52:18 <mauke> > reads "123 abc" :: [(Int, String)]
03:52:19 <lambdabot>   [(123," abc")]
03:52:23 <mauke> yes
03:52:24 <kamaji> ok
03:52:39 <kamaji> thanks!
03:53:22 <kamaji> ah, awesome... this makes so much more sense now
03:54:09 <Starfire> When would reads return a list of length 2 or more?
03:54:31 <koeien> in case of an ambiguous parse afaik, although i don't have an example
03:57:22 <hpaste> “Per Persson” annotated “how to get type right?” with “how to get type right? (annotation)” at http://hpaste.org/51272#a51290
04:16:01 <tiglionabbit> why does this happen?  http://friendpaste.com/1G0pHess4ncgLhDKyTMAVW
04:17:14 <dmwit> tiglionabbit: In the expression "x:xs", "xs" must be a list.
04:17:21 <mauke> tiglionabbit: because 1 is not a list
04:17:29 <tiglionabbit> ohh
04:17:45 <tiglionabbit> wait
04:17:50 <koeien> what would you like to accomplish?
04:17:52 <tiglionabbit> yeah I see
04:17:56 <obiwahn> cwl: could you solve ex4?
04:17:57 <Jafet> (Unless you make it one!)
04:18:13 <dmwit> > (5:[1,3], map (\set -> [5, set]) [1,3])
04:18:13 <cwl> obiwahn: yes
04:18:13 <lambdabot>   ([5,1,3],[[5,1],[5,3]])
04:18:24 <cwl> obiwahn: how about you
04:19:01 <obiwahn> i have finished some other exercise:)
04:19:16 <cwl> obiwahn: good
04:20:46 <rexim> +
04:21:18 <obiwahn> cwl: id like to have a look at your solution
04:21:32 <cwl> obiwahn: https://gist.github.com/1213655
04:21:53 <Eduard_Munteanu> Where are those exercises from?
04:22:15 <Eduard_Munteanu> I vaguely remember something like that.
04:24:23 <cwl> obiwahn: can you post yours, I'd love to look at it
04:24:26 <dmwit> ?src foldr
04:24:26 <lambdabot> foldr f z []     = z
04:24:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:26:15 <rostayob> is there a "solution" to the problem that record fields must have unique names? That combined with the fact that you can't have recursively dependent modules is quite annoying
04:26:44 <mauke> you can have cyclic references
04:26:47 <kamaji> I have a char, v, how can I avoid this: read ([v] :: String) :: Value
04:26:54 <rostayob> if you have two data types with a date in it, and they contain each other, the only solution is "thisDate" and "thatDate"
04:26:54 <kamaji> because I get an error without casting [v] to String
04:27:09 <obiwahn> cwl:  i had soem other ex mom
04:27:21 <mauke> an ex mom?
04:27:27 <hpc> kamaji: write readChar?
04:27:29 <hpc> :t rad
04:27:30 <lambdabot> Not in scope: `rad'
04:27:31 <hpc> :t read
04:27:32 <lambdabot> forall a. (Read a) => String -> a
04:27:42 <mauke> kamaji: what error and what cast?
04:27:43 <hpc> also you don't need the type annotation
04:27:55 <koeien> kamaji: you cannot "cast"
04:28:01 <kamaji> sorry I mean the type annotation
04:28:05 <koeien> there are no casts in Haskell
04:28:12 <kamaji> I call that cast in my head which is a terrible idea :P
04:28:24 <hpc> there is a cast, but it's called unsafeCoerce, and DON'T EVER USE IT!
04:28:30 <mauke> :t cast
04:28:31 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
04:28:32 <koeien> if v is of type Char, then [v] :: String is always true
04:28:36 <koeien> hpc: shhh
04:28:38 <hpc> also that
04:28:44 <hpc> >.>
04:28:44 <kamaji> I'll pretend I didn't hear that and try to forget it asap :p
04:29:06 <kamaji> oh what
04:29:10 <kamaji> it works now. :|
04:29:12 <mauke> @let x === y = cast x == Just y
04:29:13 <lambdabot>  Defined.
04:29:16 <kamaji> I must have done something else I fixed
04:29:24 <obiwahn> cwl: http://paste.debian.net/129760/
04:29:30 <rostayob> mauke: cyclic references? was that comment directed to me?
04:29:47 <mauke> rostayob: yes
04:30:01 <quicksilver> rostayob: yes, cyclic module dependencie are legal haskell, although fiddly to compile.
04:30:07 <rostayob> mauke: what do you mean? afaik you can't have two modules which depend on each other
04:30:09 <rostayob> ah
04:30:11 <quicksilver> personally I just stop worrying, give the record fields stupid names, and never use them.
04:30:21 <hpc> quicksilver: really? i thought the workaround was just a ghc thing
04:30:34 <quicksilver> hpc: haskell has always required cyclic dependencies to be legal.
04:30:46 <quicksilver> hpc: but it doesn't specify how the compiler should support them.
04:30:50 <hpc> oh
04:31:18 <rostayob> quicksilver, mauke: any pointers on how to do that?
04:31:50 <dmwit> Google "hs-boot file".
04:31:51 <mauke> http://freshpop.ytmnd.com/
04:31:58 <mauke> I mean http://haskell.org/ghc/docs/7.2.1/html/users_guide/separate-compilation.html#mutual-recursion
04:32:19 <dmwit> ...the keys are like, right next to each other.
04:32:29 <mauke> s/keys/tabs/
04:32:35 <rostayob> ok, that's quite ugly
04:32:55 <rostayob> does cabal support that?
04:33:14 <mauke> AFAIK yes
04:34:56 <rostayob> what I'd really like is records fields that are scoped only in relationship with a certain data type, or something like that
04:34:59 <rostayob> similar to class members
04:36:25 <rostayob> I think it would make things less awkward
04:39:50 <quicksilver> rostayob: it's not a simple change.
04:39:58 <quicksilver> the point is that record fields are selector functions
04:40:03 <quicksilver> which are functions like any other
04:40:09 <quicksilver> they are terms they have a unique type.
04:40:47 <rostayob> quicksilver: yes I understand that it would change the scheme of things, but it would be something useful to have, expecially when converting haskell data types to other kind of objects (JSON for example)
04:40:56 <quicksilver> rostayob: it's not "something useful to have"
04:41:08 <quicksilver> rostayob: it's "a major change to the language which completely breaks the type system"
04:41:27 <quicksilver> the solution is (a) don't call them field names (b) don't use them
04:41:49 <quicksilver> instead use something more useful like fclabels (package on hackage) and develop good namespacing policies
04:42:06 <quicksilver> including, possibly, using a typeclass where it makes sense to do adhoc polymorphism over a lens/label.
04:42:21 <rostayob> quicksilver: I know that it wouldn't fit in the type system, I'm just saying that I find myself wanting to have something like that often
04:42:23 <Eduard_Munteanu> Aren't Agda's records like that?
04:42:36 <rostayob> quicksilver: lenses don't really solve the problem, namespacing kind of does
04:42:41 <quicksilver> if you want to see a complete train wreck of a proposal to ruin the language, see http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution
04:42:49 <Eduard_Munteanu> I mean, constructors/accessors can have non-unique names, as long as they're in different datatypes
04:43:02 <koeien> don't we have name-directed type resolution?
04:44:02 <hpaste> cwl pasted “GOA Error” at http://hpaste.org/51291
04:44:26 <cwl> have you met the problem
04:45:38 <rostayob> quicksilver: how exactly would it break and ruin the language?
04:46:30 <hpc> rostayob: not sure how it ruins the language, but the first thing i noticed is that his first example is fixed by typing "qualified" twice
04:46:30 <quicksilver> rostayob: what would be the type of "date"
04:46:42 <quicksilver> rostayob: if you had two fields with the name "date"
04:48:16 <rostayob> quicksilver: you could have a type class similar to "class Record a b c where; get :: a -> b -> c", where b is what you want to get, and b would be a type that you define just on the name, which you can't do now
04:48:51 <Eduard_Munteanu> Class method names are unique too
04:49:01 <Eduard_Munteanu> Actually, unique identifiers.
04:49:53 <Eduard_Munteanu> So it's obvious what the type is.
04:51:01 <quicksilver> rostayob: yes, you can certainly do it with typeclasses
04:51:12 <quicksilver> rostayob: it's not at all problematic to do that and, I do that myself from time to time
04:51:38 <Eduard_Munteanu> Sorry, I misread that :)
04:51:42 <quicksilver> if I feel that the 'semantics' of the field name are good enough matches in the cases involved that the typeclass feels meaningful.
04:52:12 <quicksilver> (although I would always almost always make a typeclass over a lens, not a selector function)
04:52:37 <rostayob> quicksilver: the problem is that I want to be able to have some type to use as the "b" in that type class that is definable "on the fly", without having to create multiple types for each data type
04:53:11 <rostayob> quicksilver: we were talking about this here some time ago and I did this http://hpaste.org/51292 , which of course is absolutely ridicolous
04:53:34 <rostayob> *ridiculous
04:53:40 <rostayob> but you get the idea ehe
04:53:54 <quicksilver> I do, but I don't understand why you feel the need
04:54:02 <quicksilver> namespacing is such a trivial problem
04:54:14 <quicksilver> (we had a very similar discussion in this channel yesterday)
04:54:23 <quicksilver> type names and function names are also in a global scope
04:54:33 <quicksilver> why is it so much more of a problem that field names be in a global scope?
04:54:53 <rostayob> quicksilver: the problem right now is that I'm writing a templating system in which the templates compile to Haskell functions. I want to be able to have record types in the templates, so I can say this.that, but I want all the types to be inferred
04:55:14 <quicksilver> OK, well now we get more of a hint about what your *real* problem is.
04:55:55 <rostayob> this would be really convenient since I'm compiling the same templates to JS functions as well, and I want to compile the same record types to JSON objects
04:56:04 <quicksilver> if you're compiling it anyway, you could just autogenerate a typeclass per JSON field
04:57:22 <rostayob> quicksilver: yes I could hack around the problem with a type class and custom types for each fields but if that's the only way I'll just give up record fields
04:57:24 <rostayob> it's too ugly
04:57:40 <rostayob> and too fragile imho
04:58:02 <quicksilver> I don't think that has to be ugly - typeclasses are the way you ask the type checker to resolve ambiguity.
04:58:48 <Younder> quicksilver, I thought it was used for unions?
04:59:44 <rostayob> well let's say that I have this.that in my template. Let's say I compile that to "get this (undefined :: That)" and the compiler will infer "Record a That Whatever" as the type of "this". Is that more or less what you mean?
05:02:21 <rwbarton> once you are inventing a type for each record name, you may as well invent a type class instead and write getThat this with context HasThat a Whatever
05:02:50 <quicksilver> rwbarton: well it's probably slightly less work to invent one big class (and many instances) than many classes?
05:03:00 <quicksilver> if it's all autogenerated code I'm not sure it makes any difference which you do.
05:03:16 <dmwit> Isn't there a 2010 proposal in this direction?
05:03:28 <quicksilver> rostayob: yes, that is what I was suggesting, anyhow.
05:03:34 <quicksilver> dmwit: http://hackage.haskell.org/trac/haskell-prime/wiki/TypeDirectedNameResolution ?
05:03:39 <quicksilver> but I'm not sure it's really in this direction.
05:04:14 <ben> Cripes, is the tdnr discussion still going on?
05:04:20 <quicksilver> it's more of a work in progress than a concrete proposal as far as I can see
05:04:42 <dmwit> Not the one I was thinking of. Let me see if I can find it.
05:04:47 <quicksilver> I have no idea what they expect the type of "(\f -> f.x)" to be.
05:05:00 <rostayob> quicksilver: Well that's more or less the less ugly solution I could come up with but it's still pretty ugly, and it doesn't solve my templating problem, since I'd generate the type "That" twice, and they wouldn't match
05:05:07 <rostayob> in other words, I'd have to import stuff anyway
05:05:32 <rostayob> rwbarton: btw, that code I posted draws from your suggestin eheh
05:07:19 <dmwit> blech
05:07:31 <dmwit> There are a huge number of proposals for "fixing" records.
05:08:57 <Younder> Lisp has a inheritance method that allows you start with the basics and then change-class once you know more..
05:10:50 <rostayob> dmwit: well but records are slightly annoying in haskell
05:11:00 <dmwit> Totally.
05:14:11 <quicksilver> the thing I find annoying about records is that record update isn't first class
05:14:28 <rostayob> I think that having types with some kind of tags as parameters instead of other types would "fix" the problem, but that would be changing the type system
05:14:42 <quicksilver> this is adequately solved by a good lenses library, at which point I feel in familiar functional programming territory and everything else seems OK to me.
05:15:08 <dmwit> The "top-level"ness of field names is a bit annoying, too.
05:15:20 <quicksilver> I think a huge portion of the annoyance is caused by the "Eeek! This isn't like Java/Python/C#" syndrome; although probably I overstate this.
05:15:38 <Starfire> I should probably update my record field library sometime.
05:15:39 <quicksilver> dmwit: I honestly don't find it any more annoying than the top-levelness of functions, data types, and data constructors.
05:15:50 <quicksilver> I don't even perceive it as any different to those.
05:15:50 <dmwit> I do find it more annoying than those.
05:16:08 <quicksilver> record field names, view as terms, are functions.
05:16:17 <quicksilver> Why should they be any different from other functions in their namespacing?
05:16:18 <dmwit> It's way annoying to have to make three modules for three data types that happen to share a single field like "date".
05:16:23 <koeien> wouldn't dmwit's problem be solved by "nested modules" or optional extra namespacing within .hs-files?
05:16:37 <quicksilver> local/lightweight modules would be nice to have for many reasons, yes.
05:16:43 <rostayob> quicksilver: no trust me, I love Haskell and it's probably the language I've coded more in but sometimes I hit some walls, almost only when having to interoperate with data interchange formats or stuff like that
05:16:50 <koeien> like namespace X { data Pt = Pt { x, y :: Integer } }
05:17:07 <quicksilver> a better import/export/qualified/re-export qualified system would be nice to have as well.
05:18:12 <koeien> then you can use X.x :: Pt -> Integer elsewhere
05:19:23 <rostayob> well but if you can namespace like that, then the next step would be able to namespace on data type names without breaking anything
05:19:40 <quicksilver> sure
05:19:47 <quicksilver> that would be quite logical.
05:19:56 <rostayob> so if you "data Foo = Foo {this :: String, that :: Int}" you would have Foo.this and Foo.that
05:20:15 <quicksilver> although I really don't understand why people consider that significantly different from
05:20:25 <quicksilver> data Foo = Foo { fooThis :: String, fooThat :: Int }
05:20:47 <quicksilver> especially since record fields are too broken to use in substantial programs, anyway, so you should never be typing them in the first place.
05:22:14 <rostayob> quicksilver: the biggest advantage for me is that I could use those data types as JSON objects without constantly having to type stuff like user.userPassword, which just hurts my eyes
05:23:00 <rostayob> and it wouldn't be a convention
05:23:11 <quicksilver> rostayob: syntactic uniformity with a different language is not, for me, an interesting goal in the big picture
05:23:21 <quicksilver> although I can understand why it matters *to you* in your application
05:24:29 <rostayob> quicksilver: the thing is that you don't think that record fields are useful, but when they are, they always represent some internal member, and a label - "username" "date" "password" - is adequate enough. prefixing everything it's not an appropriate solution
05:25:10 <ben> Record fields are too broken?
05:25:20 <quicksilver> rostayob: no, you misinterpret my trolling hyperbole.
05:25:21 <rostayob> I mean stuff like this http://hackage.haskell.org/packages/archive/haskell-src/1.0.1.4/doc/html/Language-Haskell-Syntax.html in which *everything* is prefixed with Hs is just ugly
05:25:38 <quicksilver> ben: yes, they're utterly useless.
05:25:46 <quicksilver> Foo { fooThis = "blah" }
05:25:51 <quicksilver> cannot be abstracted
05:25:58 <Jafet> quicksilver: how can haskell be popular if it doesn't use the name lookup rules of C++.
05:26:05 <quicksilver> anything which cannot be abstracted is a wart
05:26:32 <quicksilver> when you isolate 'fooThis' - turn it into an independent term - it degrades into a selector function
05:26:38 <quicksilver> fooThis :: Foo -> String
05:26:45 <quicksilver> which is fine as far as it goes but it only goes halfway!
05:26:57 <quicksilver> in general, when you're using records, you want record update (and indeed construction) too.
05:27:05 <ben> Oh
05:27:15 <quicksilver> so, you have to use a package like fclabels or data-accessor
05:27:20 <quicksilver> (or roll your own lenses system)
05:27:29 <quicksilver> to feel like you have a record system which is actually worth of haskell
05:27:33 <ben> I've never used those/lenses <:(
05:27:39 <Jafet> I've always wondered why haskell can't just do what ML does
05:27:41 <quicksilver> ...and once you've done that, the actual name in the record is an irrelevance
05:27:44 <ben> I gotta start writing substrantial programs, I suppose
05:27:51 <quicksilver> you only need to use it once, to define the lens
05:28:01 <rostayob> quicksilver: the namespacing problems remains, and the uglyness of TH and prefixing everything with "_" remains
05:28:02 <rwbarton> surely twice :P
05:28:19 <quicksilver> rwbarton: well, only in one line of code :)
05:28:25 <quicksilver> yes, you probably need it at least twice in that line.
05:28:26 <rostayob> Jafet: what does ML do?
05:28:42 <quicksilver> rostayob: I don't find the prefixing by Hs particularly ugly (nor particularly beautiful)
05:29:01 <quicksilver> critically I don't find it any different from the other namespace management challenges in haskell.
05:29:18 <quicksilver> hence earlier discussions about local modules / better import/re-export qualified.
05:29:28 <quicksilver> and I certainly don't find TH ugly.
05:29:33 <rostayob> quicksilver: I think that namespacing is a lot better than prefixing, mainly because everyone decides his own rules when prefixing
05:29:37 <quicksilver> metaprogramming is nothing to be ashamed of.
05:29:49 <quicksilver> I don't understand that distinction.
05:29:54 <quicksilver> prefixing *is* namespacing.
05:30:01 <quicksilver> everyone decides their own rules for both
05:30:05 <quicksilver> like many other things in programming
05:30:09 <quicksilver> we can try to agree on good conventions
05:30:12 <quicksilver> especially with co-workers.
05:30:29 <rostayob> quicksilver: prefixing is not namespacing, since you can take the namespacing away but hnot the prefixing
05:31:23 <rostayob> prefixing everything with something is just a form of hardcoding metadata about the function, which is bad imho
05:31:25 <luite> yeah I agree with rostayob, with static prefixing, the library author necessarily decides everything for you. good conventions may help, but different (size) projects have different needs
05:31:28 <rostayob> see hungarian notation
05:31:52 <quicksilver> OK, so let's be a little more precise :)
05:32:08 <koeien> but if you're generating code it doesn't matter, right?
05:32:16 <quicksilver> what you mean is that, with qualified imports, at least you can choose your own prefix or even import without one.
05:32:19 <quicksilver> sure I agree.
05:32:22 <Jafet> rostayob: nicer records, or so I hear
05:32:43 <quicksilver> Like I said twice already, I'm totally in favour of local modules, local rename of qualifications, and the ability to re-export qualified.
05:33:07 <quicksilver> these help us solve all these namespacing problems which I continue to maintain don't really have anything to do with records :)
05:33:21 <quicksilver> in particular, that solution would be equally applicable to lenses
05:33:23 <quicksilver> and properties
05:33:31 <quicksilver> and other things that might suffer from namespacing problems.
05:33:33 <luite> quicksilver: yeah, but with qualified imports, you still have the overlap problem. you still have to qualify much more than you need in other languages
05:33:48 <quicksilver> luite: that's the price we pay for principal types and first-class terms.
05:33:53 <quicksilver> luite: or, I *think* it is.
05:34:01 <koeien> you can import both qualified and nonqualified, and wait until a clash occurs
05:34:04 <quicksilver> luite: I've yet to see a proposal which convinces me otherwise.
05:34:12 <rostayob> quicksilver: I mostly agree with you, the cons of having everything first class outweight the pros, but we need nicer records anyway
05:34:17 <koeien> although I don't like that approach too much
05:34:22 <rostayob> *the pros outweight the cons :)
05:34:25 <quicksilver> luite: to me, principal types and first class terms are much bigger wins.
05:34:51 <quicksilver> rostayob: I think we need nicer records, but the problems I perceive with records are that update and construction aren't first class
05:34:55 <quicksilver> (which lenses solve)
05:35:02 <quicksilver> I also think we need better namespacing control
05:35:09 <luite> quicksilver: oh I don't know anything that's really better, TDNR looks kind of ugly, but I sure hope that it's possible to improve on the current situation
05:35:24 <quicksilver> perhaps if we solve both of these, the other problems with records - which I continue to deny the existence of - will go away :)
05:35:31 <koeien> i think the namespace improvement quicksilver outlined solve 90% of the problems
05:35:41 <koeien> maybe even 100% :)
05:35:58 <quicksilver> koeien: at least perhaps they would throw the real problem in a stronger light.
05:36:01 <luite> I go for 70% tops ;p
05:36:11 <quicksilver> pschaw
05:36:19 <quicksilver> clearly 94%
05:36:39 <rostayob> quicksilver: what would break when tagging types with strings, with the tags being checked at compile time? I'm sure it does break something but I'm not sure what ehe
05:36:46 <rostayob> because that would solve my problems
05:37:01 <quicksilver> rostayob: can you give a concrete example of what you propose?
05:37:54 <rostayob> quicksilver: right now we can can have parameters with types, representing other types, so types have different kinds
05:38:14 <rostayob> if I could provide "tags" instead of other types as well, I could have a "key" type for my record class
05:38:29 <rostayob> with tags being strings in the end
05:39:13 <rwbarton> basically he wants a less artificial way to embed strings in the type system, like with the proposed Nat kind etc.
05:39:17 <rwbarton> I think.
05:39:28 <rostayob> rwbarton: yes
05:39:32 <rwbarton> Which seems inevitable, some day
05:39:46 <quicksilver> So no different in principle from data Word1; data Word2; data Word3; except you don't need to declare them upfront?
05:39:53 <rostayob> quicksilver: precisely
05:40:05 <quicksilver> I don't think that breaks anything at all.
05:40:07 <rostayob> you can define them on the fly, and they're not actual types, they are just identifiers
05:40:21 <rostayob> so if I write the same strings in different locations, they represent the same type
05:40:25 <quicksilver> although since they're at the type level you'd be limited in the computations you could perform on them.
05:40:29 <koeien> but they are always literal?
05:40:43 <quicksilver> rostayob: you have a namespacing problem of your own there
05:40:46 <koeien> or can you say ("Hello"++"TypeTest")
05:40:58 <byorgey> rostayob: you'll be able to lift strings into types soon.
05:40:59 <rostayob> quicksilver: there would be no namespacing because same string == same type
05:41:03 <quicksilver> in that two modules could use the tag "QuicksilverRocks" with different intended tag meanings.
05:41:09 <quicksilver> rostayob: yes, I understand.
05:41:14 <quicksilver> and I understand why you want that.
05:41:28 <quicksilver> I'm just pointing out that, in principle, that could cause unintended collisions.
05:41:32 <rostayob> my problem in this channel is that I lack the formal language to describe this things :P
05:41:38 <rostayob> quicksilver: yes but you'd be aware of that
05:41:40 <rwbarton> what this "breaks" is the guarantee of the type system being nominative
05:42:05 <quicksilver> you could probably declare that whenever you use a tag, your tag is formally in Astro.Boy.Tags
05:42:08 <rwbarton> well, to some extent, not w.r.t. type constructors as they currently exist, only w.r.t. these new strings
05:42:11 <quicksilver> and then you wouldn't read on other peoples tags.
05:42:15 <quicksilver> tread on.
05:42:30 <quicksilver> just some upfront declaration at the top of your module or even in your cabal file.
05:42:35 <rostayob> hey! rostayob is an anagram of astroboy!
05:42:42 <quicksilver> funny that :)
05:43:26 <quicksilver> Anyhow I don't think there are any deep problems with that idea, and I think it's fairly likely to happen in a future version of GHC.
05:43:38 <rostayob> well, cool
05:43:53 * hackagebot monad-atom 0.1.0 - Monadically convert objects to unique atoms and back.  http://hackage.haskell.org/package/monad-atom-0.1.0 (GrzegorzChrupala)
05:43:58 <quicksilver> although since you're generating code it's pretty easy for you to generate Astro.Boy.Tags explicitly, and put all your void tag declarations in it.
05:45:09 <rostayob> quicksilver: again, that would be dependant on some definition, even if generated. My problem arose in the first place because I'm generating haskell code and I don't want to import anything apart some base function
05:45:22 <rostayob> *functions
05:46:35 <Saizan> but if .Tags only contains these tags what's the difference between having the tags without declaring them and always importing .Tags ?
05:46:56 <quicksilver> rostayob: why don't you want ot import something?
05:47:06 <quicksilver> wanting to import a common file is a natural thing if you're generating code
05:47:23 <quicksilver> Saizan: no difference except the work required to maintain the Tags file
05:47:37 <quicksilver> Saizan: (and the fact that if you autogenerate you can be a victim to a class of unchecked typos)
05:47:58 <quicksilver> Saizan: rostayob is, if I'm following him correctly, trying to avoid generating the list of tags.
05:47:59 <rostayob> quicksilver: yeah but the tags module would vary in each usage of the templates->haskell compiler
05:48:19 <rostayob> so I'd have to say the compiler "Hey my tags are there" which is... ok I guess
05:49:01 <rostayob> of course is possible but I'd just give up record types instead, I like simple things
06:01:37 <Rotsor> What is the reason for not allowing derivation of Data and Typeable instances for types of kind (* -> *) -> *?
06:03:51 <Rotsor> I tried writing such an instance myself and it worked for a simple use case. Will I have problems with it?
06:05:17 <quicksilver> Rotsor: I don't think there is a big theoretical issue
06:05:36 <quicksilver> it's just a pain needing a Data/Typeable pair for each different Kind
06:07:18 <Saizan> what you can't do without making a new class is an instance of Typeable for a kind like ((* -> *) ->*) -> *
06:07:59 <kamaji> Could someone suggest a better way to do this?
06:08:01 <obiwahn> @src argof
06:08:01 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:08:01 <kamaji> isDigit s = map (\(i,unp) -> (toEnum (i-2), unp)) $ reads str
06:08:19 <kamaji> sorry there should be a guard in front of `isDigit s`
06:08:28 <quicksilver> Saizan: you need a new class for each level of kind complexity don't you?
06:08:38 <quicksilver> Typeable1, Typeable11 Typeable101, etc.
06:08:49 <Jafet> Heh
06:08:53 * hackagebot Paraiso 0.1.0.0 - a code generator for partial differential equations solvers.  http://hackage.haskell.org/package/Paraiso-0.1.0.0 (TakayukiMuranushi)
06:09:21 <Jafet> Typeable <jot program> a
06:10:22 <roconnor> what are the laws for Applicative?
06:10:22 <lambdabot> roconnor: You have 4 new messages. '/msg lambdabot @messages' to read them.
06:10:48 <companion_cube> roconnor: at least    pure f <*> x = fmap f x
06:10:55 <hpc> roconnor: https://secure.wikimedia.org/wikibooks/en/wiki/Haskell/Applicative_Functors#Applicative_Functors
06:11:14 <Saizan> quicksilver: but you can make a Typeable for (* -> *) -> * by using Typeable1
06:11:24 <roconnor> ah opps
06:11:33 <roconnor> I mean to ask what the laws for Alterantive are
06:11:37 <roconnor> sorry
06:12:03 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Alternative
06:12:14 <hpc> a monoid on applicative functors
06:12:26 <roconnor> hpc: ah, that is clear
06:12:27 <Saizan> quicksilver: i.e. you can make a Typeable instance given you've TypeableN for the kinds of the types you're parametrized over, so you can always go one step further than the classes you have
06:12:56 <Rotsor> In my case I have (Data (T1 m)) => Data (T2 m) where T1 is a data family and (T2 m) is a simple data structure containing values of type (T1 m).
06:13:34 <roconnor> hpc: wow, (many) really looks like a kleene star operator
06:14:37 <hpaste> “md2perpe+hpaste@gmail.com” annotated “Ambigous type variable” with “Ambigous type variable (annotation)” at http://hpaste.org/51131#a51294
06:15:55 <quicksilver> Saizan: I see what you mean, yes.
06:16:51 <quicksilver> Jafet: what's a jot program?
06:17:48 <Rotsor> quicksilver, that is a program consisting only of U-combinator and parentheses
06:19:28 <Rotsor> It's similar to type kinds in structure (the kinds consist only of * and parentheses), but I don't think they have similar semantics.
06:21:02 * quicksilver nods
06:21:32 <quicksilver> yes. I have been wanting a good word to describe the language of type kinds for a while.
06:22:15 <erus`> whats a good intermediate language for a functional programming lgnauge?
06:22:26 <erus`> compile it down to a stack based thing?
06:22:37 <parcs_> haskell
06:22:51 <quicksilver> that is a fairly well discussed question :) I don't think there is a simple good answer.
06:22:57 <rostayob> erus`: well you can take a look at GHC Core...
06:23:09 <quicksilver> reading SPJ's original book on writing compilers for functional languages discusses a lot of the issues.
06:23:11 <hpc> you might also try scheme
06:23:27 <hpc> at least because it has a very simple interpreter
06:23:28 <quicksilver> (and motivates the design of the STG machine)
06:23:38 <erus`> scheme still seems quite high level
06:24:00 <Rotsor> There is Epic (used by Epigram and now Agda)
06:24:01 <erus`> I feel like i can go deeper
06:24:43 <variax> Suppose I have an enormous data set, say 1 gig, which needs to be updated incrementally. Say, a weather simulation or something. What is the Haskell way to handle this? Are there strict structures that allow you to "cheat" by updating them directly?
06:25:01 <mauke> variax: what's the problem with functional updates?
06:25:13 <hpc> variax: the most naive answer would be ST
06:25:24 <hpc> the most functional answer would be "improve your data structure"
06:26:11 <variax> what is ST?
06:26:25 <mauke> > log 1e9
06:26:25 <lambdabot>   20.72326583694641
06:26:30 <hpc> variax: it's an IO-like monad that doesn't leak side-effects
06:26:39 <mauke> except it's nothing like IO
06:27:05 <hpc> mauke: i meant in the "learn to use it, not what it is" way ;)
06:27:27 <mauke> hpc: so do I
06:27:32 <variax> mauke: by "functional updates", do you mean accumulating operations for the lifetime of the app?
06:27:33 <obiwahn> http://code.haskell.org/HSP/haskell-src-exts not found:(
06:27:36 <rtharper> Is there any  application of data families around that isn't GMap?
06:27:41 <rtharper> that would be interesting to look over
06:27:48 <mauke> variax: what?
06:28:36 <variax> you asked "what's the problem with function updates" and I'm trying to figure out what that means. Functions wouldn't update the data directly, so I guess it means accumulating operations.
06:28:51 <mauke> what do you mean by "accumulating operations"?
06:29:31 <variax> that data set is forever fixed, and you "move" the data set by accumulating functions. I don't know how else to explain it.
06:29:40 <rostayob> variax: functionally updating a data type wouldn't cause all the data to be copied around if that's what you mean
06:29:46 <mauke> I don't know what you're talking about
06:29:57 <rostayob> the shared parts will remain shared
06:30:06 <mauke> I'm talking about (old data)--[update]-->(new data)
06:30:20 <rostayob> and if you won't use the old part if would be garbage collected ofc
06:30:30 <sbrg> mauke: think he means saving every operation. "Edit Offset Data" etc.. then applying them when the program is done running
06:30:31 <Rotsor> @rtharper, I've found data families very useful for abstracting over graphs. Like, class PetriNet p where {data Place p; data Transition p; ...}
06:30:31 <lambdabot> Unknown command, try @list
06:30:53 <rtharper> cheers Rotsor
06:30:57 <variax> rostayob: would your answer change if I said that every data point is updated?
06:32:33 <rostayob> variax: my answer would never change, if you change some data type the shared parts would stay shared, if you completely change the data there would be nothing to share
06:34:07 <variax> OK, but I'm still wondering the practical way of doing this in Haskell: updating every point in a gig of data. I am tempted to find ways of "cheating" somehow, instead of garbage collecting a gig on every update.
06:34:20 <mauke> variax: why?
06:34:30 <mauke> was it too slow?
06:34:36 <hpc> variax: churning through craptons of data is what GHC is made for
06:34:43 <rostayob> variax: have you already encountered problems or are you just fantasizing about performance :P?
06:35:10 <SamB_XP> variax: how much RAM do you have, anyway?
06:35:15 <variax> I'm just fantasizing -- wondering how things are done in Haskell, generally.
06:36:02 <variax> It seems like efficient, fast, incremental updates to large data sets is one issue I see.
06:36:21 <koeien> we tend to avoid ST if possible, we use data structures that are well-suited to pure FP, like maps and difference lists
06:36:32 <koeien> you can have hashtables though, if you really want
06:36:36 <mauke> variax: show me an inefficient update
06:36:46 <rtharper> variax: as koeien said, you usually use things that take advantage of sharing
06:36:59 <rostayob> variax: well the only data structure that "requires" ST seem to be hash tables
06:37:03 <koeien> maps implemented using trees, that is
06:38:37 <roconnor> updating a map only copies log(n) data
06:38:55 <rostayob> variax: if anything you might have problems with data sets that don't fit in ram
06:39:10 <rostayob> but even then people come up with things like this http://hackage.haskell.org/package/swapper
06:39:51 <sbrg> variax: do you incrememnt the data sequentially or are the updates in random places?
06:40:33 <variax> sbrg: it's a large data set animated in real-time. In general, every point changes.
06:40:40 <sbrg> ah
06:44:42 <variax> Next scenario. Suppose I have some serialization scheme in place. I have a Haskell app reading from a socket; it reads an object. What's the way to actually use the object? In a dynamic language you just use it -- how would you do this in Haskell?
06:45:12 <parcs_> you unserialize it
06:45:25 <rostayob> variax: "You just use it"? anyway, there are various serialization libraries, most notably binary and cereal
06:46:18 <mauke> in a dynamic language you don't just use it
06:46:24 <variax> but how do you go from a deserialized object read at run-time to statically checked code?
06:46:33 <rostayob> variax: also, serializing ADT is much easier to serialize things, and to derive serialization functions
06:47:00 <SamB_XP> mauke: well, say you had some JSON data and you wanted to play with it in Javascript...
06:47:00 <mauke> variax: how is this a problem?
06:47:05 <rostayob> variax: you'll have a class similar to "class Serializable a where; serialize :: a -> ByteString; deserialize :: ByteString -> Maybe a"
06:47:06 <mauke> SamB_XP: ok
06:47:50 <rostayob> variax: (ByteString is a vector of bytes)
06:47:59 <variax> Isn't the unserialized object always going to be stuck inside a monad?
06:48:10 <rostayob> variax: what? why?
06:48:14 <mauke> lol wut
06:48:33 <mauke> variax: and what if it was?
06:48:40 <rostayob> variax: you simply have some binary blob to parse, but that's all. I don't understand the complexity here :P
06:48:45 <variax> alright, nevermind. I'll read up on Haskell serialization and I'll shut the fuck up. Thanks for your time.
06:48:57 <sbrg> lol
06:49:01 <parcs_> variax, it will probably be stuck in IO if you are reading the data from a socket
06:49:03 <rostayob> variax: no no haskell is not different from any other language
06:49:04 <sbrg> don't think he was content with the answers
06:49:06 <rostayob> whatever :P
06:49:46 <rostayob> parcs_: this doesn't mean that you can't write pure functions to serialize/deserialize
06:49:55 <terry> variax: reading from the socket is a side effect and would be in the IO monad.  But the data you get (data <- readFromSocket) can be processed in a purely functional way
06:50:06 <sbrg> variax already disconnected people
06:50:13 <rtharper> haha
06:50:24 <rostayob> variax will be missing
06:50:25 <rtharper> but we're so excited!
06:50:27 <rostayob> *missed
06:50:55 <Olathe> For far too long, our data has been imprisoned in the shackles of monadic oppression!
06:58:53 <rnauke> hi, how do monads work?
06:59:05 <Jaxan> :D
06:59:38 <rostayob> rnauke: they don't
06:59:57 <byorgey> they are powered by tiny creatures known as gnomads
07:00:44 <rnauke> byorgey, haha
07:01:34 <Oxfaded> i want a numeric instance of a type which simply wraps another, so I have fromInteger (TWord8 a) = fromInteger a, but the ghc complains Couldn't match expected type `Integer' with actual type `TWord8'. Any ideas?
07:01:44 <byorgey> the recent push towards things like Applicative, Arrow, etc. is because of worries over the Gnomad Liberation Movement
07:01:51 <rostayob> :t fromInteger
07:01:52 <lambdabot> forall a. (Num a) => Integer -> a
07:02:06 <rostayob> Oxfaded: you want toInteger
07:02:08 <rostayob> :t toInteger
07:02:08 <lambdabot> forall a. (Integral a) => a -> Integer
07:02:24 <byorgey> Oxfaded: or perhaps you mean  fromIntegral?
07:02:31 <Oxfaded> sorry im really tired
07:02:40 <Oxfaded> i saw it immediately after you said that
07:02:40 <Oxfaded> thanks
07:02:55 <mauke> Oxfaded: deriving (Num)?
07:02:59 <byorgey> no worries =)
07:03:07 <Oxfaded> loaded
07:03:08 <Oxfaded> thanks
07:03:09 <Cale> I'm kinda starting to hate the "stuck inside a monad" meme.
07:03:15 <roconnor_> I'm pretty unhappy with the answers given to variax.  The questions were reasonable.
07:03:17 <rostayob> byorgey: well, you can't redefine fromIntegral...
07:03:27 <byorgey> rostayob: oh, right.
07:03:52 <roconnor_> Yet no one offered the idea that you could use bind to pass functions manipulating the parsed object
07:03:59 <terry> roconnor_: I agree
07:04:10 <Cale> roconnor_: Well, he left.
07:04:14 <rostayob> roconnor_: I was going to say that but he left :|
07:04:26 <rostayob> I actually said that but it was to laaaaate
07:04:45 <roconnor_> rostayob: oh okay
07:04:46 <roconnor_> sorry
07:04:48 <byorgey> I am not sure whether variax was more worried about being "stuck in a monad" or about how you turn a blob of characters into something with a statically checked type.
07:04:52 <byorgey> or maybe both.
07:05:00 <quicksilver> the communication was poor, whatever
07:05:09 <quicksilver> certainly the answers were less friendly than we sometimes are
07:05:23 <quicksilver> I couldn't quite work out which question he really needed answering, which is why I didn't speak up at all
07:05:25 <terry> which are both reasonable questions
07:05:27 <quicksilver> (and then he left)
07:05:38 <rostayob> I don't think we were unfriendly
07:05:48 <terry> i don't agree
07:05:51 <byorgey> two demerits for everyone.  try harder next time.
07:06:26 <hpaste> “md2perpe+hpaste@gmail.com” annotated “Ambigous type variable” with “Ambigous type variable (annotation)” at http://hpaste.org/51130#a51295
07:06:33 <byorgey> rostayob: it is not a question of not being unfriendly. the goal is to be as friendly as possible.  and there is always room for improvement.
07:07:11 <mauke> http://www.lowbird.com/data/images/2010/08/photobucket-bullshit-ten-points-from-gryffindor.gif
07:07:16 <rostayob> well I try to, I spent so much time on this channel asking questions so I know what it means eheh
07:07:22 <Nafai> I blame xmonad for drawing me back into Haskell
07:07:36 <byorgey> mauke: hehe
07:07:56 <byorgey> Nafai: I've heard that excuse before ;)
07:08:03 <Nafai> :)
07:08:07 <rostayob> I think that he was a bit confused and he knew it
07:08:30 <byorgey> Nafai: welcome back =)
07:08:50 <rostayob> yeah xmonad seems one of the most beloved pieces of software by programmers
07:09:14 <quicksilver> we may not have been unfriendly by the low standards of IRC, but we were unfriendly by the very high standards of #haskell
07:09:27 <Oxfaded> its not possible to shadow instances is it?
07:09:46 <koeien> Oxfaded: you can't even suppress importing them
07:09:46 <quicksilver> not sensible, Oxfaded
07:09:51 <rostayob> Oxfaded: you can overwrite them, but it's messy. there is some language extension
07:09:57 <quicksilver> newtypes if you want different instances
07:10:58 <rostayob> Oxfaded: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
07:12:14 <byorgey> rostayob: that's not quite the same thing.
07:12:45 <rostayob> byorgey: no it's not, but I guess it's relevant to what he want to do
07:14:19 <byorgey> perhaps, but there's probably a better solution.  in my experience, overlapping instances is the best solution in only a very few situations, and those tend to be specialized and involve things like type families.
07:14:24 <quicksilver> @quote overlapping
07:14:24 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
07:14:28 <quicksilver> @quote overlapping
07:14:28 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
07:14:29 <quicksilver> @quote overlapping
07:14:30 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
07:14:30 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
07:14:58 <rostayob> byorgey: true true, that's what I meant with "it's messy"
07:15:03 <Nafai> byorgey: thanks. :)
07:15:21 <rostayob> quicksilver: you like exaggerations :)
07:15:28 <quicksilver> you noticed?
07:15:50 <quicksilver> I like to lace my pedagogy with irritating hyperbole.
07:15:59 <quicksilver> it hasn't got me chucked out yet...
07:16:01 <mm_freak_> i found that with type families you can implement extensible types, which can be useful sometimes…  does that work well between packages?
07:16:17 <rostayob> quicksilver: you should try sarcasm
07:16:23 <rostayob> it's great
07:16:28 <int-e> OverlappingInstances leads to IncoherentInstances which kills little puppies.
07:16:42 <copumpkin> quicksilver desists from eschewing obfuscation, too
07:16:51 <quicksilver> well I think the example above is a little sarcastic
07:16:52 <Nafai> int-e: nooooo, don't kill the puppies!
07:17:05 <quicksilver> but I try pretty hard not to direct sarcasm at people because that's not productive.
07:17:07 <byorgey> mm_freak_: I don't understand what you are asking.
07:17:33 <quicksilver> mm_freak_: it sounds interesting though, can you give an example?
07:17:35 <rostayob> he eschews eschewing obfuscation
07:19:04 <tac-tics> Obfuscate the types!
07:24:30 <stribor> > hello stribor
07:24:31 <lambdabot>   Not in scope: `hello'Not in scope: `stribor'
07:24:39 <rostayob> @hello stribor
07:24:39 <lambdabot> Maybe you meant: help tell
07:24:45 <rostayob> well, I tried
07:25:10 <rostayob> @vixen stribor
07:25:10 <lambdabot> girls masturbate too you know... probably more than guys. we can do it anywhere discretely
07:25:21 <rostayob> mhm.
07:25:43 <SamB_XP> I have my doubts about the veracity of that last bit...
07:25:54 <SamB_XP> Though not, of course, wrt lambdabot herself.
07:26:02 <SamB_XP> (I mean, how would you tell?)
07:27:51 <byorgey> seriously, we ought to remove the @vixen command from lambdabot.
07:28:02 <SamB_XP> why?
07:28:20 <byorgey> because it is inappropriate and certainly does nothing to make women feel welcome in #haskell.
07:28:43 <SamB_XP> maybe restrict it to certain channels?
07:28:46 <rostayob> byorgey: I actually didn't remember what I did, I just remembered that existed
07:28:49 <tac-tics> I disagree. We should add a @macho command instead
07:28:53 * hackagebot monad-atom 0.1.1 - Monadically convert objects to unique atoms and back.  http://hackage.haskell.org/package/monad-atom-0.1.1 (GrzegorzChrupala)
07:29:07 <koeien> what does @vixen do anyway (I remember vaguely that that was a nick of somebody?)
07:29:23 <tac-tics> koeien: It's just a sexy @quote
07:29:25 <rostayob> koeien: spits out quotes like the one above
07:29:25 <monochrom> no, you just modify @vixen so it doesn't talk about girls
07:29:31 <byorgey> no, @vixen is a chatbot that is supposed to simulate a horny 16 year old girl.
07:29:46 <koeien> if that's so, i agree with byorgey
07:30:22 <SamB_XP> @vixen asl
07:30:22 <lambdabot> 19/f/California
07:30:27 <SamB_XP> she says she's 19
07:30:29 <byorgey> ok, 19. whatever.
07:31:03 <rostayob> let's replace @vixen with @cleverbot
07:31:22 <byorgey> sure, that could be fun
07:32:40 <byorgey> @ask Cale can you please remove @vixen from lambdabot, or at least change it so lambdabot does not respond to @vixen in #haskell?
07:32:40 <lambdabot> Consider it noted.
07:32:57 <Axman6> why? :\
07:33:08 <byorgey> Axman6: read the scrollback.
07:33:13 <tac-tics> Let's not forget, where're not all from Europe and America here. Some of us live in countries where political correctness is a pain in our asses.
07:33:33 <hpaste> “md2perpe+hpaste@gmail.com” annotated “data types” with “data types (annotation) (annotation) (annotation)” at http://hpaste.org/51042#a51298
07:33:45 <Cale> wat
07:33:46 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:34:19 <Cale> You're going to make me recompile lambdabot for that?
07:34:33 <byorgey> Cale: yes, sorry.
07:34:57 <Cale> What's the problem with it?
07:35:03 <byorgey> Cale: it's a chatbot that simulates a horny 19 year old girl.  it is inappropriate and I imagine does not make women feel very welcome in #haskell.
07:35:04 <tac-tics> Cale: apparently it's sexist :(
07:35:12 <koeien> it's misogynist
07:36:24 <Cale> Okay, so it's not like there's a security issue or something. I wasn't sure what you were referring to in the scrollback.
07:36:35 <roconnor_> @tell Eduard_Munteanu ya, in Agda I think you can just go ahead and proof uniqueness of equality proofs directly without any assumptions.
07:36:35 <lambdabot> Consider it noted.
07:36:38 <byorgey> no, no security issue.
07:36:49 <rostayob> It's probably better to remove it, but I'd be only amused by some stupid chatterbot
07:37:11 <rostayob> but I guess people get offended easily
07:37:38 <Axman6> there's plenty of male characters in lambdabot too...
07:37:38 <mm_freak_> byorgey: you can add data family instances in other modules, so it sounds reasonable to be able to add them in an external module, too
07:37:56 <mm_freak_> quicksilver: no, but i have an idea how to use it
07:38:26 <byorgey> Axman6: no, lambdabot has lots of commands that quote things crazy people in #haskell have said in the past.  @vixen is the only chatbot that I know of.
07:38:47 <mm_freak_> just as an example in a game:  data family WorldObj a; data Player;  data instance WorldObj Player = PlayerObj Player
07:38:57 <tac-tics> I still say we leave @vixen and add @macho
07:39:02 <Axman6> i'm pretty sure there's others
07:39:19 <Cale> @protontorpedo is a pretty good simulation of protontorpedo though
07:39:19 <lambdabot> as u scale and complexity grows?
07:39:22 <tac-tics> So we can get the 30-year-old body builder on steroids chatbot representing the negative male stereotypes
07:39:26 <Cale> @protontorpedo
07:39:26 <lambdabot> paul graham said static typing is a problem for macros building
07:39:39 <luite> has anyone ever actually been offended by @vixen?
07:39:50 <mm_freak_> @vixen
07:39:50 <lambdabot> Most guys don't understand me, but we really seem to connect.
07:39:53 <Axman6> apparently they just were
07:39:53 <Cale> luite: Not that I've heard of before now
07:39:54 <byorgey> luite: how would we know?
07:40:02 <rostayob> tac-tics: wait why is a horny 19 years old a negative female prototype
07:40:07 <Cale> Because someone would say something?
07:40:21 <byorgey> no they wouldn't.
07:40:36 <Nimatek> Would a horny 19 year old male be problematic?
07:40:41 <rostayob> s/prototype/stereotype....
07:40:43 <byorgey> Nimatek: yes.
07:40:45 <rostayob> I'm tired
07:40:46 <tac-tics> rostayob: if it is negative, then I think @macho would be the dual stereotype
07:40:53 <Nimatek> In that case neither should exist.
07:41:01 <RayNbow> say, did I just join #haskell or...? :p
07:41:03 <Axman6> Nimatek: you could ask them, all 100 hundred of them :P
07:41:30 <rostayob> I think that the main problem here is that this is a 90% male chan with a horny female chatterbot
07:41:38 <rostayob> more than the chatterbot itself
07:41:53 <Cale> Wait, horny 19 year old males are problematic? How many of us are 19?
07:42:01 <rostayob> Cale: I'm 20
07:42:03 <int-e> Especially since 90% of the discussion is still about Haskell anyway.
07:42:10 <byorgey> well, perhaps there ought to be a larger discussion about this.  perhaps I'll post something on my blog and invite comments.
07:42:24 <Axman6> :\
07:42:34 <luite> byorgey: really?
07:42:42 <quicksilver> that particular inappropriate vixen comment is quite unusually inappropriate
07:42:44 <Axman6> if it were a problem, someone would have said something in the however many years lambdabot has been here
07:42:45 <koeien> byorgey: I think the topic is beaten to death in the CS community. but i am fairly PC.
07:42:58 <rostayob> there was a similar case a while ago about the name of a library - http://holdenweb.blogspot.com/2011/07/childish-behavior.html
07:42:58 <Cale> Thankfully, lambdabot is being easy to recompile at the moment, so it was easy to remove
07:43:00 <quicksilver> most of what it says it simply daft, and not really offensive at all.
07:43:11 <Axman6> quicksilver: i'd be happy to see that one removed. but removing the whole thing is uncalled for
07:43:15 <koeien> byorgey: but fwiw i agree with you
07:43:21 <quicksilver> however I also don't think it is paticularly funny, or particularly interesting
07:43:24 <quicksilver> so I won't miss it.
07:43:34 <byorgey> Axman6: I disagree.
07:43:41 <Cale> Yeah, I don't really see much use for the plugin, so I removed it
07:43:51 <Axman6> @vixen chocolate?
07:43:56 <lambdabot> I am not a crook.
07:43:58 <Axman6> :\
07:44:00 <Cale> errr
07:44:01 <Cale> wat
07:44:09 <Cale> ah!
07:44:10 <Axman6> it's used quite a lot actually...
07:44:10 <rostayob> vixen lives
07:44:10 <int-e> @msg still exists, eh?
07:44:11 <Cale> @nixon
07:44:13 <tac-tics> Umm.. did Cale break her already? I @vixen'ed and got: "Government enterprise is the most inefficient and costly way of producing jobs."
07:44:18 <lambdabot> In a flat choice between smoke and jobs, we're for jobs...But just keep me out of trouble on environmental issues.
07:44:22 <Cale> lololol
07:44:22 <byorgey> hahaha
07:44:30 <lambdabot> Plugin `system' failed with: thread killed
07:44:31 <Axman6> @vixen asl
07:44:34 <tac-tics> ;(
07:44:36 <lambdabot> Voters quickly forget what a man says.
07:44:38 <SamB_XP> oh, nixon?
07:44:42 <tac-tics> She's too political for me to be interested in now
07:44:50 <Cale> Now it's even MORE offensive!
07:44:52 <rostayob> I want @billhicks
07:44:58 <Nimatek> A conservative bot is potentially more offensive.
07:45:00 <SamB_XP> I think you'd better put it back
07:45:01 <byorgey> *lol*!
07:45:22 <quicksilver> I think she's funnier this way
07:45:27 * byorgey agrees
07:45:30 <quicksilver> @vixen tell us about dependent types
07:45:35 * Axman6 doesn't
07:45:36 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
07:45:44 <rostayob> wow.
07:45:51 <quicksilver> still inappropriate :)
07:45:53 <tac-tics> Cale: Can we get a modern day American Right-wing Fundamentalist chatbot some time?
07:46:03 <monochrom> vixen/nixon would be a great movie
07:46:07 <tac-tics> @sarapalin? or even @bush would be great
07:46:11 <rostayob> a tender love story
07:46:12 <Axman6> "I can see russia"?
07:46:13 <byorgey> what have I done.
07:46:14 <lambdabot> Unknown command, try @list
07:46:46 <knoc> @list
07:46:54 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:52:15 <rostayob> mhm, there is no chatterbot api. that's sad.
07:52:23 <rostayob> *cleverbot
07:55:21 <dmead> > print "hello " world"
07:55:23 <dmead> > print "hello  world"
07:55:25 <lambdabot>   mueval-core: Time limit exceeded
07:55:28 <lambdabot>   mueval-core: Time limit exceeded
07:55:33 <dmead> >print "hello  world"
07:55:40 <dmead> what the hell?
07:55:50 <dmead> > [1..10]
07:55:54 <lambdabot>   mueval-core: Time limit exceeded
07:56:07 <dmead> shits broken guys
07:56:11 <rostayob> vixen's revenge
07:56:48 <rostayob> @nixon fix lambdabot
07:56:48 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
07:56:53 <tac-tics>  > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 12 fibs
07:57:07 <Cale> errr
07:57:08 <Cale> > 1
07:57:09 <lambdabot>   1
07:57:14 <Cale> > print
07:57:15 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Types.IO ())
07:57:15 <lambdabot>    arising f...
07:57:19 <Cale> > print "hello"
07:57:21 <lambdabot>   <IO ()>
07:57:36 <Cale> > print "hello  world"
07:57:37 <lambdabot>   <IO ()>
07:58:09 <int-e> > fix((0:).scanl(+)1)
07:58:13 <lambdabot>   mueval-core: Time limit exceeded
07:58:18 <Cale> > fix((0:).scanl(+)1)
07:58:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:58:29 <Cale> WORKSFORME
07:58:35 <sbrg> what the hell
07:58:42 <int-e> Cale's privileged.
07:58:42 <sbrg> @ that fibonacci function
07:58:56 <int-e> > 1
07:58:58 <lambdabot>   1
07:59:00 <tac-tics> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 12 fibs
07:59:15 <quicksilver> > fix ("Cale"++)
07:59:15 <Cale> That 001C character can't be good
07:59:17 <lambdabot>   "CaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCaleCa...
07:59:21 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 12 fibs
07:59:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89]
07:59:22 <int-e> tac-tics: still some odd character in front of the >
07:59:28 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:59:29 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:59:39 <tac-tics> int-e: ah. Yeah. I'm using Colloquy for my IRC client... it's shit....
08:00:09 <int-e> sbrg: yeah isn't it pretty? :)
08:00:11 <Cale> tac-tics: When I'm on a mac, I use X-Chat Aqua
08:00:24 <rostayob> tac-tics: use weechat
08:00:37 <tac-tics> Cale: rostayob: I may consider trying those out.
08:01:23 <Jafet> @quote undoubtedly
08:01:23 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
08:01:39 <tac-tics> lolol
08:01:44 <sbrg> lol
08:02:34 <int-e> > scanl(*)1[1..]--factorials too
08:02:35 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
08:02:56 <erus`> lol
08:03:12 <int-e> > scanl(+)0[1,3..]--or squares
08:03:14 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
08:03:41 <rostayob> netsplit go!
08:04:09 <sbrg> OH MY GOD WE'RE ALL GOING TO DIE
08:04:10 <int-e> map(^2)[0..] is simpler and shorter though.
08:04:12 <Cale> > nubBy(((>1).).gcd)[2..]
08:04:14 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:04:17 <Cale> ^^ primes
08:04:39 <rostayob> :t gcd
08:04:42 <lambdabot> forall a. (Integral a) => a -> a -> a
08:04:53 <rostayob> @src gcd
08:04:53 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
08:04:53 <lambdabot> gcd x y = gcd' (abs x) (abs y)
08:04:53 <lambdabot>    where gcd' a 0  =  a
08:04:53 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
08:05:00 <monochrom> > lfoldl
08:05:01 <rostayob> mh
08:05:02 <lambdabot>   Not in scope: `lfoldl'
08:05:18 <monochrom> > take 10 (repeat ())
08:05:19 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
08:05:39 <Cale> I hate that special case for gcd 0 0
08:05:51 <Cale> gcd 0 0 is 0
08:05:53 <int-e> outdated source. we have gcd 0 0 = 0 now. (ghc 7.2.1, whatever base it ships with, 4.4?)
08:06:04 <Cale> > gcd 0 0
08:06:04 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
08:06:15 <Cale> apparently needs an update ;)
08:06:24 <Cale> I'm glad that's fixed
08:06:54 <monochrom> yeah, ghc 7.0 still undefined
08:07:08 <monochrom> oh, lambdabot's ghc is ooolllldddd
08:07:18 <Cale> yep
08:07:24 <Cale> Could probably use an update
08:07:25 <monochrom> so old that impredicativity still worked! XD
08:07:33 <epsilonhalbe> hey can i do sub/superscripts in haddock documentation
08:07:33 <epsilonhalbe> for example -- x<sup>2</sup> ~~> x² or x<sub>0</sub> ~~>x₀
08:07:39 <dmead> > [1..10]
08:07:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:07:57 <rostayob> epsilonhalbe: you can simply use unicode
08:08:06 <dmead> > map (1 +) [1..10]
08:08:07 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
08:08:11 <c_wraith> impredicativity works in ghc 7....  sometimes.
08:08:27 <int-e> And HTML markup should work in Haddock.
08:08:32 <c_wraith> there does appear to be a bug that prevents unification of identical types in some cases in ghc 7, though
08:08:39 <roconnor_> wow I can't beleive they fixed gcd
08:08:47 <monochrom> no, haddock doesn't support superscript and subscript
08:08:49 <roconnor_> there was so much resistance for the last 10 or 20 years
08:09:06 <Cale> I never saw any resistance to changing it
08:09:17 <epsilonhalbe> @ rostayob - i'm not only using ²³ but also ^i _n etc.
08:09:20 <Cale> it's just that even when everyone agrees that the library should change, it seems to take forever to do it
08:09:22 <c_wraith> I think the history was more "agree to change it, don't remember to"
08:09:49 <epsilonhalbe> @int-e <sub>2</sub> didn't work as expected
08:09:49 <lambdabot> Unknown command, try @list
08:09:59 <Cale> It took us literally years to get permutations into Data.List
08:10:12 <dmead> its in now?
08:10:14 <epsilonhalbe> i'll give it another try
08:10:22 <dmead> cale, play starcraft.
08:10:38 <Cale> > permutations [1..5]
08:10:39 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
08:10:43 <Cale> yes
08:10:45 <Cale> okay
08:10:54 <rostayob> epsilonhalbe: I'm not sure then
08:11:09 <Cale> It's been a while since I've played!
08:11:13 <tac-tics> @src permutations
08:11:13 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:11:26 <int-e> > map (take 3) $ permutations [1..]
08:11:27 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4...
08:11:52 <tac-tics> "Maybe if you used more than just two fingers..." <-- I find this comment offensive and demeaning
08:11:54 <tac-tics> :P
08:12:21 <monochrom> I like those insults.
08:12:38 <int-e> monochrom: but you're weird
08:12:44 <Cale> dmead: You're not online
08:13:04 <epsilonhalbe> @int-e  do i have to escape < and >; somehow <sub> ~> link to sub.html
08:13:04 <lambdabot> Unknown command, try @list
08:13:48 <monochrom> the only thing I like is the meta fact that there are too few to choose from, so they tend to repeat quickly and become boring. I want more new ones
08:14:05 <monochrom> err, s/the only thing I like/the only thing I dislike/
08:14:19 <Cale> dmead: I forget, do you play SC2 under Wine, or are you running Windows?
08:14:32 <tac-tics> monochrom: what is the type of a "thing". A meta-meta-fact?
08:14:39 <int-e> epsilonhalbe: I probably misremembered, sorry. "A URL can be included in a documentation comment by surrounding it in angle brackets: <...>. If the output format supports it, the URL will be turned into a hyperlink when rendered." conflicts with the syntax, and I suppose a \< gets turned into &lt;
08:14:55 <monochrom> I don't know. maybe untyped :)
08:15:02 <tac-tics> monochrom: *gasp*
08:15:30 <tac-tics> monochrom: You fix'ing son of a bottom.
08:15:36 <Cale> dmead: btw, I think today is the day that Destiny and Sheth are streaming for Doctors Without Borders
08:15:41 <monochrom> haha
08:16:15 <epsilonhalbe> then i have to leave the thing in latex-like syntax
08:16:58 <tac-tics> So, latex being the massive one-size-fits-all language it is..... is every paper just kind of a copy&paste job from the last one you wrote?
08:17:04 <tac-tics> I was wondering that the other day.....
08:17:12 <monochrom> I have decided to deplore subscripts altogether
08:17:57 <monochrom> you certainly copy code for horrendous formulas if you can reuse them
08:18:11 <int-e> tac-tics: it tends to start out that way, yes. there's an ever growing "common.inc" file that gets copied from one to the next
08:18:32 <tac-tics> I'm wondering about the natural deduction formulas in particular. Those things are a pain in the ass to write by hand.
08:18:34 <Cale> There's a black market for nice looking xypic and TikZ diagrams, from what I understand
08:19:01 <monochrom> anyway, I deplore subscripts because they're simply yet another function arguments. no point writing "a_{b_c}(d)" now that we have learned haskell and know "a (b c) d"
08:19:36 <monochrom> as though some arguments are more equal than some others
08:20:01 <Jafet> monochrom: but can you write (c b) a!?
08:20:01 <Cale> monochrom: It can result in nicely compact 2D layouts, though certainly there are cases where that gets awkward.
08:20:07 <Cale> x_{n_k}
08:20:09 <int-e> subscripts are unintrusive compared to ordinary function composition.
08:20:22 <Jafet> Oh, subscripts in tex.
08:20:27 <tac-tics> Speaking of equality. Can someone explain to me in laymens terms what "uniqueness of equality types" is in dependent type systems?
08:20:42 <int-e> Jafet: well, subscripts in typesetting in general.
08:20:49 <copumpkin> it means roughly that if I have two proofs that x == y, then those proofs are equal
08:21:06 <Peaker_> I want to show a beginner simple file processing.. so I am thinking of doing:  content <- readFile fn ; writeFile fn (process content)      But Lazy IO rears its ugly head again!
08:21:14 <Saizan> in fact it's uniqueness of equality proofs
08:21:15 <Peaker_> I hate Lazy IO
08:21:26 <copumpkin> tac-tics: but it's phrased a bit differently from that
08:21:37 <Cale> I guess dmead just wanted me to play starcraft for my own benefit.
08:21:40 <copumpkin> tac-tics: http://homotopytypetheory.org/2011/04/10/just-kidding-understanding-identity-elimination-in-homotopy-type-theory/ covers it to some degree
08:21:50 <Cale> Because he's not logging in :P
08:21:54 <tac-tics> copumpkin: is it a problem when your system allows them to be non-unique?
08:21:58 <Peaker_> how do I fix this using purely beginner idioms? (seq/etc here are super ugly, and if I was a beginner, I'd run away)
08:22:28 <tac-tics> copumpkin: also, in non-mathy words, what is homotopy type theory?
08:22:32 <parcs_> how does lambdabot evaluate expressions?
08:22:42 <parcs_> in doesn't have mueval/hint in its dependencies
08:22:45 <copumpkin> tac-tics: it's a problem for some forms of fancy dependent pattern matching
08:22:51 <rostayob> are there any haskell internships around for next year? starting from April
08:22:55 <Jafet> parcs: it can't, until you install mueval.
08:22:57 <tac-tics> copumpkin: gotcha
08:23:11 <copumpkin> tac-tics: but if you read blog posts on that site it goes into some of the consequences
08:23:16 <copumpkin> also on bob harper's site
08:23:29 <monochrom> the visual problem with subscripts is that in practice once you have nesting and non-trivial formulas in them they become too small
08:23:46 <parcs_> oh i see
08:23:50 <parcs_> mueval is an executable
08:24:30 <Jafet> lambdabot is a sarcastic irc interface to a few dozen executables
08:24:30 <monochrom> it's all very well to say "x_i is readable" when "i" is just one single character. sure, every unreadable notation has a readable base case.
08:24:51 <Jafet> monochrom: on the other hand, the size difference is visually distinctive.
08:25:01 <Cale> Peaker_: Use (strict) Data.Text?
08:25:06 <Cale> Or Data.ByteString?
08:25:07 <Jafet> And when the simple case accounts for the majority of uses, it may be justified.
08:25:32 <Cale> Peaker_: but really, you shouldn't do that
08:25:38 <quicksilver> monochrom: conversely, almost all notations or diagrams have unreadable cases :)
08:25:53 <quicksilver> using the right notation is quite a large chunk of mathematics, actually.
08:25:55 <Cale> Peaker_: Always write to a new file, and then move the new file over the old one
08:26:06 <quicksilver> express the problem the right way and the solution is much clearer.
08:26:41 <monochrom> well, there is also the semantic problem of making some perfectly normal function arguments as 2nd-class
08:26:57 <Peaker_> Cale: should not process a file in-place?
08:28:01 <Peaker_> Cale: Exposing a beginner to Data.ByteString/Text as a duplicate of String immediately to start things is really making things more difficult than they need to be for beginners.. Lazy IO is supposed to make things easy for beginners (as opposed to iteratees or such) but it really just makes things very difficult
08:28:23 <monochrom> look at the typical real analysis text. "a sequence is a function N->R" cool, so I can write s(n) = 1/n^2 and that defines a sequence called s? no, it has to be "you write it as s_n"
08:28:53 <Jafet> Peaker: then write some strict file IO and introduce that instead, no big deal
08:29:03 <Jafet> I don't see the problem
08:29:07 <tac-tics> monochrom: that is my biggest peeve in math classes
08:29:31 <monochrom> the sillyness continues with "the whole sequence is called {s_n}"
08:29:58 <tac-tics> I spent the majority of my high school calculus class trying to reason about what kind of things dx and dy really were
08:30:04 <Cale> Peaker_: I think overwriting a file in-place is generally considered kind of bad practice.
08:30:06 <absentia> live now -- http://www.buildwindows.com/
08:30:12 <mysticc> Is a tailrecursive call faster than the normal one in haskell or compiler automatically optimizes normal recursive functions??
08:30:14 <absentia> missend, sorry.
08:30:42 <tac-tics> mysticc: optimized tail calls are slightly faster, but their main advantage is they don't consume stack space
08:30:51 <Cale> mysticc: The real answer is that tail calls aren't really a thing
08:31:04 <Jafet> .oO(They seem to re-imagine Windows a lot... couldn't they have gotten it right the first time?)
08:31:07 <Peaker> Cale: I agree -- but bad practice ought to be allowed too (there may special cases where it is good practice)..
08:31:33 <Cale> You would have to introduce some weird additional notion of stack which the Haskell implementation doesn't have in order to be able to talk about tail call optimisation in Haskell.
08:31:33 <mysticc> Cale: I mean does haskell compiler automatically optimizes a normal recursive fun ti a tail recursive fun or not
08:31:44 <monochrom> recursion costs in GHC-generated code is not determined by the false dichotomy of tail vs non-tail
08:31:45 <Peaker> Jafet: The problem is that the default uses the complicated, annoying semantics of lazy IO.. and you have to learn the default. So now, if you want simplicity, you have to learn multiple libraries with differing semantics
08:32:05 <monochrom> recursion costs in Haskell itself is not determined at all
08:32:07 <Cale> mysticc: It doesn't have to do anything special. TCO is meaningless here.
08:32:27 <Cale> at least in most sensible implementations it is
08:32:32 <Jafet> The Haskell implementation, GHC, does have a stack. But not in the usual sense
08:32:49 <Peaker> Counter-example: Python has a simple file API, that exposes strict IO via read/write, and lazy IO via a line iterator.. That's limited, but for beginners, this makes things easy.
08:32:51 <monochrom> Jafet is right
08:33:06 <mysticc> ok .. thanks guys ..
08:33:12 <monochrom> > foldr1 (&&) (repeat False)
08:33:13 <lambdabot>   False
08:33:19 <monochrom> non-tail there
08:33:21 <Jafet> I agree with monochrom.
08:33:32 <monochrom> > foldl' (&&) (repeat False)
08:33:33 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:33:33 <lambdabot>         against inferred type ...
08:33:37 <c_wraith> I agree with monochrom and disagree with Jafet
08:33:38 <tac-tics> mysticc: doesn't it piss you off? You came here asking for an answer to a question, and like a bunch of Buddhist monks, #haskell tells you to unasked your damn question
08:33:40 <monochrom> > foldl' (&&) False (repeat False)
08:33:45 <monochrom> tail there
08:33:51 <lambdabot>   mueval: ExitFailure 1
08:33:59 <Cale> mysticc: Understanding performance of recursive Haskell functions requires a different view of things, because the evaluation order for a lazy evaluator is literally backwards.
08:34:21 <Cale> mysticc: If I write foldl (+) 0 [1,2,3], something like this goes on in memory:
08:34:26 <Cale> @src foldl
08:34:26 <lambdabot> foldl f z []     = z
08:34:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:34:30 <Cale> foldl (+) 0 [1,2,3]
08:34:31 <mysticc> tac-tics: I just needed to know if I should write a tail recursive fun or not ??
08:34:38 <monochrom> to make it more fun, it is not always backwards, because in practice you mix eager and lazy
08:34:39 <Cale> -> foldl (+) (0 + 1) [2,3]
08:34:44 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
08:34:51 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
08:34:52 <tac-tics> mysticc: I wouldn't worry about it unless it becomes a problem
08:34:56 <Cale> -> ((0 + 1) + 2) + 3
08:35:00 <Cale> -> (1 + 2) + 3
08:35:02 <tac-tics> mysticc: lazy evaluation will cover your ass in a lot of cases
08:35:03 <Cale> -> 3 + 3
08:35:04 <Jafet> Peaker: you're unlikely to get everyone to change the semantics of readFile, which is given in the report
08:35:05 <Cale> -> 6
08:35:23 <Cale> mysticc: Usually it's the wrong thing to do, actually
08:35:52 <mysticc> Cale: Thanks dude ...
08:35:52 <tac-tics> mysticc: if you're curious as to how the GHC works in more detail, you might want to check this out some time:
08:35:53 <tac-tics> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
08:35:54 <Cale> A function which returns a data constructor applied to things which are recursive is better whenever you can get it
08:39:47 <nda> @ \pl \(a, Just b) -> Just (a, b)
08:40:01 <nda> @pl \(a, Just b) -> Just (a, b)
08:40:01 <lambdabot> (line 1, column 11):
08:40:01 <lambdabot> unexpected "b"
08:40:01 <lambdabot> expecting operator, "," or ")"
08:40:12 <quicksilver> > sequence (a, Just b)
08:40:14 <lambdabot>   Couldn't match expected type `[m a]'
08:40:14 <lambdabot>         against inferred type `(Simple...
08:40:20 <quicksilver> > sequenceA (a, Just b)
08:40:21 <lambdabot>   Not in scope: `sequenceA'
08:40:27 <quicksilver> > Data.Traversable.sequenceA (a, Just b)
08:40:28 <lambdabot>   No instance for (Data.Traversable.Traversable
08:40:29 <lambdabot>                     ((,) Simp...
08:40:32 <quicksilver> hmm
08:40:51 <byorgey> (a, f b) -> f (a, b)  is often called 'strength'
08:40:54 <Axman6> @pl (\(a, Just b) -> Just (a,b))
08:40:54 <lambdabot> (line 1, column 12):
08:40:54 <lambdabot> unexpected "b"
08:40:54 <lambdabot> expecting operator, "," or ")"
08:41:00 <quicksilver> :t Data.Traversable.sequenceA
08:41:01 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
08:41:08 <byorgey> but I don't know if there's a standard implementation of it in any library
08:41:17 <quicksilver> byorgey: well surely it should be sequenceA ?
08:41:20 <benmachine> :t uncurry (fmap (,))
08:41:20 <lambdabot> benmachine: You have 1 new message. '/msg lambdabot @messages' to read it.
08:41:21 <lambdabot> forall a b b1. (b1 -> a, b1) -> b -> (a, b)
08:41:24 <benmachine> @messages
08:41:24 <lambdabot> ion said 12h 13m 31s ago: It would be nice if each step http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi displayed the definition of the function applied in the step in a column to the right.
08:41:29 <quicksilver> (a,) is Traversable isn't it?
08:41:42 <parcs_> what's an expression that very quickly allocates lots of memory? eg reverse [1..]
08:41:56 <byorgey> quicksilver: no, it isn't
08:43:04 <byorgey> quicksilver: I suppose it should be though, shouldn't it
08:43:10 <quicksilver> byorgey: I think so.
08:43:20 <byorgey> hmm
08:43:32 <quicksilver> :t \(x,a) -> do {y <- a; return (x,y)}
08:43:33 <lambdabot> forall t (m :: * -> *) t1. (Monad m) => (t, m t1) -> m (t, t1)
08:43:49 <quicksilver> :t \(x,a) -> fmap ((,) x) a
08:43:50 <lambdabot> forall t a (f :: * -> *). (Functor f) => (t, f a) -> f (t, a)
08:44:06 <quicksilver> there is your instance of sequenceA
08:44:08 <quicksilver> if I'm not mistaken.
08:44:22 <byorgey> yep
08:44:23 <quicksilver> (with an unnecessarily general type)
08:44:55 <quicksilver> doesn't even require the Monoid context, that way
08:45:09 <quicksilver> (you need the Monoid context to write the Applicative or Monad instances)
08:45:19 <byorgey> right.
08:45:50 <nda> quicksilver: thanks, just figured out it's fmap . (,)
08:45:56 * quicksilver nods at nda
08:48:10 <quicksilver> byorgey: sequenceA is my most frequently answered answer in the last two months, I think
08:48:36 <quicksilver> byorgey: although it's a close second to "No, that is not the problem with the haskell record system. The problem with the haskell record system is *this*: ...."
08:48:41 <byorgey> heh, I think I've answered sequenceA several times recently too
08:48:46 <byorgey> hehe
08:55:40 <Cale> quicksilver: What do you think the problem with the Haskell record system is?
08:56:36 <tac-tics> There's only one problem with it?
08:56:46 <Cale> To be honest, I can't really complain all that much about it. A system for extensible records might be nice, but in practice it's not something that I've found I wanted all that much to be fair.
08:57:21 <Cale> If field names were auto-defined as lenses instead of extractor functions, that might be cool.
08:57:51 <tac-tics> Cale: what do you mean by lens exactly?
08:58:14 <Cale> tac-tics: something like http://hackage.haskell.org/package/fclabels
08:58:26 <rostayob> lens are cool lately
08:59:23 <sbrg> I'm no guru but not being able to do something like: data Foo { bar :: Bar, otherBar :: Bar} ... fn getter barType = let baz = getter barType in doRandomShitWithBaz is annoying
08:59:36 <sbrg> but fclabels fixes that afaik
08:59:49 <sbrg> I've only run into that problem twice or so though
08:59:52 <sbrg> (having to be able to do that)
09:00:37 <rostayob> sbrg: lenses are useful to modify data inside haskell data types with record fields, more than getting it
09:00:58 <rostayob> but they're also useful to get nested data
09:01:00 <Cale> sbrg: I'm not sure what exactly you're saying that you can't do...
09:01:27 <azaq23> sbrg: View patterns
09:02:43 <sbrg> Cale: ah, well. I want to get bar or otherBar. When I decide which, it would be cool to be able to pass the record function on to another function, and use that function to get it from my barType. It's hard to explain, and I don't remember a concrete case where I needed it, but I remember having needed it twice
09:03:04 <sbrg> maybe I needed to restructure my program, but that was what I needed
09:03:18 <benmachine> I played with GHC's record extensions once and for all that they're kind of ew (introducing names implicitly, etc.) I actually find them relatively pleasant to work with
09:04:11 <sbrg> basically, using fn above: fn bar (Foo SomeBar AnotherBar) would use SomeBar when fn otherBar -- || -- would use AnotherBar
09:04:21 <c_wraith> benmachine: have you looked at TREXX?  (I think that was the name of it...  hugs' extensible record mechanism)
09:04:22 <parcs_> sbrg: you're able to do that for record accessors that have the same type. in this case ,they do
09:04:24 <Jafet> Which language's name lookup are the extensions based on?
09:04:28 <benmachine> c_wraith: nope
09:11:00 <obiwahn> is anybody of you commiting to ghci?
09:11:05 <obiwahn> ghc
09:11:52 <parcs_> committing?
09:11:56 <roconnor_> hpc: a monoid on appliative functors would be a monoid in the category of applicative (aka monoidal) functors where objects are applicative functors and arrows are monoidal natural transformations?
09:11:56 <c_wraith> huh.  hlint is not helpful here: http://hpaste.org/51300
09:12:21 <obiwahn> contribute -- commit into scm
09:12:34 <roconnor_> hpc: wait, that cannot be what is meant by Alternative
09:13:06 <c_wraith> obiwahn: several people here occasionally work on ghc.  but if you're looking for ghc developers, try #ghc.  They pay more attention in that channel, as it's more focused than here.
09:17:07 <roconnor_> empty :: Const () a -> f a; (<|>) :: (f :*: f) a -> f a
09:17:49 <roconnor_> hpc: oh maybe it is right.  I was just thinking of the wrong tensor product for applicative functors.
09:19:40 * roconnor_ thinks categories ought to be monoidal in at most one way so as not to be confusing :D
09:23:50 <benmachine> preflex: tell ion https://github.com/benmachine/stepeval/issues/1
09:23:51 <preflex>  Consider it noted.
09:28:20 <roconnor_> hpc: but this still doesn't look right.  if empty' :: Const () a -> f a were required to be a monoidal natural transformation then there would be an Alternative law stating that empty = pure x.
09:28:53 <parcs_> preflex: eval 5 + 5
09:29:30 <Jafet> preflex, seen preflex
09:29:30 <preflex>  what
09:31:37 <Saizan> roconnor_: isn't pure : Id -> f rather than Const () -> f ?
09:32:33 <Saizan> ah i guess x is some unknown constant there
09:32:37 <roconnor_> Saizan: if empty' is required to be a monoidal natural transformation, then we would have the law that empty' . pure = pure
09:33:08 <roconnor_> Saizan: and since empty' is defined to be (const empty), this law would boil down to empty = pure x
09:35:51 <roconnor_> I must still have the wrong tensor product
09:35:58 <rassilon> Hey, whats the URL to the app that shows you the hackage package dependencies?
09:36:24 <rassilon> (I have this crazy notion to figure out how many packages use Control.Concurrent.threadRead/WriteWait
09:36:32 <c_wraith> you mean reverse dependencies?
09:36:37 <rassilon> yep
09:38:42 <roconnor_> Saizan: maybe I should write const empty = pure
09:39:24 <rassilon> Oh, darn that's by package name. I would need a module reverse dependancy view. Ugh.
09:39:38 <rassilon> http://packdeps.haskellers.com/reverse/base that is
09:39:55 <Saizan> roconnor_: or forall x. empty = pure x :) just to know where x comes
09:40:43 <roconnor_> The funny thing is that I think I know what the laws ought to be: empty <*> x = empty and f <*> empty = empty and (f <|> g) <*> x = (f <*> x) <|> (g <*> x) and f <*> (x <|> y) = (f <*> x) <|> (f <*> y).
09:40:46 <rwbarton> I think he means const empty = pure
09:40:57 <roconnor_> I don't know know the fancy categorical way of stating that.
09:41:08 <rwbarton> that is a law if you ask for an Alternative functor to be a lax monoidal functor in (Monoids, x)
09:41:30 <rwbarton> unless I'm very confused
09:42:15 <rwbarton> certainly empty = pure ()
09:42:31 <Saizan> roconnor_: i think they are actually empty <|> x = x = x <|> empty; a <|> (b <|> c) = (a <|> b) <|> c
09:42:38 <rwbarton> anyways, your last two laws don't work for the [] Alternative btw
09:42:50 <rwbarton> well maybe one of them does, but the other doesn't
09:42:57 <roconnor_> Saizan: Well those are the monoid laws that I left out.
09:43:30 <roconnor_> Saizan: but presumably the <|> and empty need to be related to <*> and pure in some way.
09:43:36 <rwbarton> > let { f = (+10); g = (+20); x = [3,4] } in ((f <|> g) <*> x, (f <*> x) <|> (g <*> x))
09:43:38 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
09:43:38 <lambdabot>         against inferred type ...
09:43:57 <rwbarton> > let { f = [(+10)]; g = [(+20)]; x = [3,4] } in ((f <|> g) <*> x, (f <*> x) <|> (g <*> x))
09:43:58 <lambdabot>   ([13,14,23,24],[13,14,23,24])
09:44:20 <Saizan> roconnor_: but i think there's no consensus on which exact way, like MonadPlus
09:44:20 <roconnor_> rwbarton: hmm
09:44:30 <rwbarton> > let { f = [(+10),(+20)]; x = [3]; y = [4] } in (f <*> (x <|> y), (f <*> x) <|> (f <*> y))
09:44:32 <lambdabot>   ([13,14,23,24],[13,23,14,24])
09:44:36 <rwbarton> wait
09:44:59 <rwbarton> hmm what am I doing wrong
09:45:09 <rwbarton> oh
09:45:12 <rwbarton> nothing, those last two are different
09:46:27 <benmachine> heh
09:47:57 <roconnor_> rwbarton: right, in what I was thinking I'd add also the law x <|> y = y <|> x
09:48:06 <roconnor_> rwbarton: which even more clearly isn't satified.
09:48:08 <roconnor_> :(
09:49:24 <roconnor_> Alternative isn't very usefull if we don't have laws for interacting with pure and <*>
09:51:02 <benmachine> there are rules interacting with pure, aren't there?
09:51:13 <benmachine> wait no
09:51:17 <benmachine> I'm thinking of something else
09:52:56 <rwbarton> if you do impose x <|> y = y <|> x then the situation is a lot better and you can require the laws you listed
09:53:15 <sm> join #ghc
09:53:34 <rwbarton> then you are taking applicative functors with values in (commutative monoids, the tensor product of commutative monoids)
09:54:49 <rwbarton> if you plug in (x <|> y) for x in your third law and (f <|> g) for f in your fourth law and continue expanding you can see that you've essentially required <|> to be commutative
09:54:58 <roconnor_> rwbarton: yep
09:55:37 <roconnor_> is Alternative STM?
09:57:14 <roconnor_> well it is MonadPlus, which is close enough I guess
10:03:54 <monochrom> yes, STM is Alternative too
10:05:41 <reallyconfused> .
10:07:03 <roconnor_> monochrom: how many laws do we get?
10:11:08 <kamaji> Is there any way to get the first int from `data Foo = Foo Int Int` without using pattern matching?
10:11:17 <kamaji> or should I use record syntax
10:11:26 <koeien> no. write a helper function or use record syntax.
10:14:02 <tac-tics> What good is a monad when he stops being a monad?
10:16:24 <reallyconfused> god, i don't know how to use irc
10:17:02 <tac-tics> reallyconfused: type @nixon and lambdabot will explain
10:17:04 <tac-tics> @nixon
10:17:05 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
10:18:23 <reallyconfused> thanks, god :)
10:18:55 <monochrom> roconnor_: we only get the associative law x<|>(y<|>z) = (x<|>y)<|>z. STM's <|> is STM's orElse, it documentedly has a bias to the left
10:18:58 * hackagebot yesod-form 0.3.2.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.3.2.1 (MichaelSnoyman)
10:19:19 <reallyconfused> @nixon
10:19:19 <lambdabot> Americans admire a people who can scratch a desert and produce a garden. The Israelis have shown qualities that Americans identify with: guts, patriotism, idealism, a passion for freedom. I have
10:19:19 <lambdabot> seen it. I know. I believe that.
10:19:24 <roconnor_> monochrom: not even left-distributivity?
10:19:34 <monochrom> oh, I don't know
10:21:33 <roconnor_> Isn't Israel inside the "Fertile Crescent"?
10:22:03 <applicative> mesopotamia? not exactly
10:22:48 <roconnor_> applicative: the Fertile Crescent includes mesopotamia but is wider
10:24:07 <parcs> i'm having trouble with hint and exception catching. the following code i suspect should print Right "caught" but instead it behaves as if the exception hasn't been caught and prints Left (WontCompile ...)
10:24:14 <parcs> runInterpreter (eval "foo" `catch` (\(e :: InterpreterError) -> return "caught"))
10:24:37 <applicative> hm, indeed, I was thinking there's just desert between the levant and iraq, but that's why its a crescent
10:27:29 <monochrom> perhaps the exception is not an InterpreterError
10:29:32 <hpaste> int80_h pasted “Typeable not in scope?!” at http://hpaste.org/51301
10:29:57 <koeien> int80_h: import Data.Typeable
10:30:20 <int80_h> I thought it was part of base
10:30:22 <parcs> monochrom: hmm, maybe. what is the catch-all exception again?
10:30:41 <sonoflilit> Hi
10:30:43 <c_wraith> int80_h: it is.  but you still need to import it.
10:30:46 <koeien> int80_h: "being part of base" /= "being part of the Prelude"
10:30:53 <monochrom> SomeException catches them all
10:30:55 <koeien> sonoflilit: hi! how can we help?
10:30:56 <int80_h> gotcha
10:31:03 <sonoflilit> I'm reading http://mainisusuallyafunction.blogspot.com/2011/09/lambda-to-pi.html
10:31:17 <int80_h> One exception to catch them
10:31:18 <sonoflilit> The implementation of Pi-calculus I more or less understood
10:31:19 <int80_h> al
10:31:29 <parcs> not even SomeException catches it
10:31:35 <sonoflilit> but withFresh breaks me completely
10:31:40 <hpaste> applicative annotated “Typeable not in scope?!” with “Typeable not in scope?! (annotation)” at http://hpaste.org/51301#a51302
10:31:54 <sonoflilit> What Functor is that <$> for?
10:31:55 <koeien> sonoflilit: <$> = fmap.
10:32:04 <koeien> (State s)
10:32:10 <sonoflilit> State...
10:32:19 <sonoflilit> ok, I'll try to read it that way and see if it helps :)
10:32:24 <int80_h> applicative, thanks :)
10:32:30 <sonoflilit> koeien, thanks :)
10:35:10 <sonoflilit> Ahhh, I see: f b is M r, (a -> b) is (Name -> r), making b be r and a be Name, and thus f a is M name - which is the type of fresh.
10:35:26 <sonoflilit> now, to figure out how it does what we want it to do...
10:36:21 <koeien> <$> applies a function to the result of the stateful computation
10:36:51 <applicative> > (\x -> x * x) <$> [1..5]
10:36:52 <lambdabot>   [1,4,9,16,25]
10:37:12 <joe6> would it be great if vim's snipmate can dynamically read haskell functions and write haskell functions?
10:37:12 <applicative> where's the stateful computation in that?
10:37:31 <koeien> applicative: the context is the State s-monad
10:38:58 * hackagebot digest-pure 0.0.2 - Pure hash functions for bytestrings  http://hackage.haskell.org/package/digest-pure-0.0.2 (DanielDeKok)
10:39:56 <Nimatek> > liftM (\x -> x * x) [1..5]
10:39:56 <lambdabot>   [1,4,9,16,25]
10:40:06 <sonoflilit> ahhh, I didn't notice that the Name parameters of mkInp2 and mkOut2 were for a returned function
10:40:18 <sonoflilit> I kept looking for "where do we generate those names?!"
10:41:52 <sonoflilit> I now see how we generate the first (called "pair") with the "withFresh" call, and the others are left for calling functions to generate
10:42:16 <sonoflilit> wow, I see now that my ability to think functionally is much less developed that I thought
10:45:04 <sonoflilit> koeien: thanks a lot
10:50:27 <DevHC> lol, i came across http://haskell.org/pipermail/haskell-cafe/2007-May/026108.html
10:50:37 <DevHC> still segfaults in GHC 7.0.3... wtfbbq?
10:51:12 <koeien> does that crash our beloved lambdabot as well?
10:51:39 <koeien> not going to try :)
10:52:04 <tac-tics> @vixen
10:52:05 <lambdabot> I reject the cynical view that politics is a dirty business.
10:52:05 <arcatan> koeien: i think lambdabot executes the code in separate process, so no worries
10:52:12 <JoeyA> I think I crashed lambdabot last time, so I'm not gonna try either.
10:52:20 <DevHC> i'll try
10:52:22 <arcatan> > array (0::Int, maxBound) [(1000000,'x')]
10:52:24 <lambdabot>   array *Exception: Negative range size
10:52:30 <koeien> DevHC: it doesn't crash my 7.0.2
10:52:37 <DevHC> try this:
10:52:40 <DevHC> > array (0::Int, maxBound-1) [(1000000,'x')]
10:52:41 <lambdabot>  Terminated
10:52:48 <JoeyA> > 2+2
10:52:49 <lambdabot>   4
10:52:53 <koeien> 32 bit linux
10:53:01 <JoeyA> @faq Can lambdabot crash?
10:53:01 <lambdabot> The answer is: Yes! Haskell can do that.
10:53:18 <tac-tics> @faq Can I prove (r->r)->r ?
10:53:18 <lambdabot> The answer is: Yes! Haskell can do that.
10:53:24 <JoeyA> > maxBound :: Int
10:53:24 <lambdabot>   9223372036854775807
10:53:38 <DevHC> zomg
10:53:58 <JoeyA> > maxBound :: CInt
10:53:59 <lambdabot>   Not in scope: type constructor or class `CInt'
10:54:02 <applicative> DevHC I  get array *** Exception: Negative range size for the one in the cafe post
10:54:20 <koeien> applicative, DevHC: yeah, me too
10:54:20 <DevHC> applicable: try maxBound-1
10:54:54 <applicative> DevHC, sure enough,  a long delay, then Bus error
10:55:03 <koeien> for me an immediate segfault
10:55:33 <koeien> and now a "GHC internal error"
10:57:50 <c0dz3r0> @type map
10:57:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:58:01 <c0dz3r0> @putStrLn "hi"
10:58:02 <lambdabot> Unknown command, try @list
10:58:04 <c0dz3r0> @list
10:58:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:58:33 <koeien> c0dz3r0: lambdabot won't run IO actions for you
10:59:20 <tac-tics> > print "Oh yeah?"
10:59:21 <lambdabot>   <IO ()>
10:59:21 <c0dz3r0> koeien: just wanted to make sure that I wasn't crazy, working on adding a subset of IO  :)
10:59:23 <tac-tics> :(
10:59:27 <tac-tics> lol
10:59:31 <monochrom> > putStrLn "<IO ()>"
10:59:32 <lambdabot>   <IO ()>
10:59:37 <monochrom> works for me
10:59:40 <tac-tics> monochrom: lol
10:59:59 * c0dz3r0
11:00:02 <koeien> monochrom: nice one
11:07:17 <jimmybirer> fu yeah
11:07:29 <jimmybirer> oh wait i wanted to go to xmonad
11:07:30 <jimmybirer> sorry
11:07:38 <monochrom> haha
11:09:06 * applicative wouldn't have suspected that they greet each other thus on #xmonad
11:09:26 <parcs> yay, i get exception handling to work
11:10:04 <parcs> hint uses ErrorT to handle interpretation errors, so i had to use catchError instead of catch
11:11:37 <parcs> also, ambiguous module name errors are annoying
11:12:11 <JoeyA> Is there a non-blocking version of killThread?
11:12:45 <koeien> forkIO . killThread
11:12:58 <JoeyA> That's what I was about to say :P
11:13:10 <JoeyA> thanks, that'll do, I suppose
11:14:17 <roconnor_> > mfix (forkIO . killThread)
11:14:18 <lambdabot>   Not in scope: `forkIO'Not in scope: `killThread'
11:15:22 <monochrom> virtual particle? :)
11:15:53 <monochrom> warning: executing mfix (forkIO . killThread) near a black hole may produce Hawking radiation!
11:16:37 <roconnor_> monochrom: does my code work?  how lazy is forkIO?
11:16:55 <roconnor_> I'm scared to run it myself
11:17:09 <monochrom> it's pretty tame. no harm running it
11:18:37 <roconnor_> for some reason it prints a threadID in ghci
11:18:52 <monochrom> that's normal behaviour
11:20:49 <roconnor_>  it is?
11:21:38 <kowey> anybody know if Haskell is a registered project on freenode?
11:21:41 <monochrom> the same behaviour as: getLine prints a string when finished in ghci
11:22:08 <monochrom> the same behaviour as: return 1 prints 1 in ghci
11:22:11 <kowey> we're trying to get #haskell.fr to be a registered channel and were first pointed to GRFs and then away from them...
11:22:18 <roconnor_> I thought I disabled that nonsense
11:22:22 <roconnor_> but apparently I didn't
11:22:32 <mmos1127> I want to ask a question about the use of Control.Exception vs a logging/monad like Either....
11:22:49 <mmos1127> In my application, I'm using Control.Exception...
11:23:28 <monochrom> exception is fine for IO
11:23:43 <mmos1127> It's fine for me that exceptions are only caught in the IO monad... I don't need to catch and rethrow at multiple levels (as one could do in order to get more detailed context logging)
11:24:04 <mmos1127> monochrom: well, some of my exceptions arise in pure code...
11:24:29 <mmos1127> In this application, it just doesn't make a big difference..
11:25:22 <mmos1127> But maybe it's still a bad idea to do this by habit
11:27:26 <roconnor_> mmos1127: I try to avoid throwing exceptions from pure code and generally prefer to use Either/Maybe
11:27:58 <JoeyA> For logging (that does not change the flow of program logic), you could use an unsafePerformIO action.
11:28:02 <JoeyA> e.g. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Debug-Trace.html
11:28:02 <roconnor_> mmos1127: I think there is a lot of disagreement on this topic which I could cite if you are interested
11:30:09 <mmos1127> roconnor_: I probably don't have time to get into depth.. I'll look into the unsafePerformIO stuff..
11:30:22 <monochrom> hehe
11:30:36 <sully> what is the deal with reallyUnsafePtrEq?
11:30:49 * roconnor_ bashes his head against his desk multiple times
11:30:59 <sully> I feel like it can't possibly be more unsafe than things like unsafeCoerce...
11:31:34 <monochrom> I don't know but I would first ask "is it atomic? as in concurrency"
11:32:18 <tac-tics> unsafeAtomic
11:32:24 <mmos1127> let me add-- I feel like using exceptions in pure code does not negate the advantages of pure code, at least in my application. I still get transparency at a practical level.
11:32:30 <byorgey> mmos1127: you may be interested in http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors/  and  http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
11:32:34 <JoeyA> unsafePerformIO (writeChan log "Division by zero; using 0" >> return 0)
11:32:55 <byorgey> mmos1127: perhaps a bit more information than you want, but it will give you a good overview of what's possible.
11:32:58 <JoeyA> (I guess that'll work)
11:33:12 <mmos1127> byorgey: thanks. I recall seeing that.. maybe I found a link to it in your blog or Typeclasspedia
11:33:49 <byorgey> it's possible, I link to a lot of things =)
11:34:46 <roconnor_> mmos1127: Many people disagree with ezyang's opinion of #3 in http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
11:35:37 <tac-tics> Needs more exception effect types
11:35:57 <mmos1127> ahh...
11:37:06 * roconnor_ uses Either String a lot
11:37:17 <alpounet> who's in the group contact (wrt Freenode) for #haskell ?
11:39:41 <monochrom> I don't know, but certainly ask dons and shapr
11:41:07 <ion> Either String is rather convenient when you want some information about the error but data MyError = Poop { poopBristolScaleValue :: Integer } | NegativeNumberOfBottlesOfBeerOnTheWallError is overkill.
11:41:08 <preflex>  ion: you have 1 new message. '/msg preflex messages' to read it.
11:42:00 <ion> With its functor/applicative/monad instances and whatnot.
11:47:58 <DevHC_> what is the largest Enum instance defined in haskell98 created by "deriving Enum"?
11:48:16 <DevHC_> where largeness is defined by the number of data constructors
11:48:47 <tac-tics> @instances Enum
11:48:48 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
11:49:07 <DevHC_> lol
11:49:33 <tac-tics> Odd. Integer is in there. Isn't integer an infinite data type?
11:49:44 <tac-tics> @type 12412341234123412341234123412341234
11:49:45 <lambdabot> forall t. (Num t) => t
11:49:51 <tac-tics> errk
11:49:58 <tac-tics> @type 12341234123412341234123412341234123412341234 :: Int
11:49:59 <lambdabot> Int
11:50:08 <tac-tics> damn smartass
11:50:13 <DevHC_> > 123123123123123123123123123123123123123123123123123123123123 :: Int
11:50:14 <lambdabot>   6124679104052589491
11:50:22 <tac-tics> Thank you. That is what I meant
11:50:25 <kmc> yeah, Enum does not imply Bounded
11:50:53 <DevHC_> let f 12312312312312312312 = 1337 in f 12312312312312312312
11:51:06 <DevHC_> > let { f :: Int -> Int ; f 12312312312312312312 = 1337 } in f 12312312312312312312
11:51:07 <lambdabot>   1337
11:51:10 <tac-tics> kmc: apparently, no, it does not
11:51:19 <DevHC_> > let { f :: Int -> Int ; f 123123123123123123123123123123123123123123123123123123123123 = 1337 } in f 123123123123123123123123123123123123123123123123123123123123
11:51:20 <lambdabot>   1337
11:51:21 <DevHC_> wtf?
11:51:39 <copumpkin> what's wrong?
11:51:49 <DevHC_> BUOGZ
11:52:05 <copumpkin> DevHC_: nothing wrong with that
11:52:10 <DevHC_> i used to think that 123123123123123123123123123123123123123123123123123123123123 is a data constructor
11:52:21 <DevHC_> or something like that
11:52:37 <byorgey> you can think of it as one.  But it isn't really under the hood.
11:52:37 <shachaf> DevHC_: Pattern-matching on numeric literals happens with Eq.
11:52:43 <shachaf> Otherwise it couldn't work with arbitrary Num instances.
11:52:55 <DevHC_> :<
11:53:09 <shachaf> When you type a numeric literal x, it really means "fromInteger (x :: Integer)".
11:53:17 <DevHC_> tell me something i don't know
11:53:34 <shachaf> You just said you thought it was a data constructor. :-)
11:53:49 <DevHC_> yes, but only after that u told me something i knew
11:54:42 <DevHC_> > 12345678901234567890 :: Int
11:54:43 <lambdabot>   -6101065172474983726
11:54:51 * shachaf has no idea what DevHC_ is saying anymore.
11:55:48 <tromp> Intel introduced the Haswell micro-architecture at IDF2011
11:55:50 <menace40> http://www.youtube.com/watch?v=tsPQ9RQE6fU
11:55:53 <DevHC_> > let { f :: Int -> Int ; f 12345678901234567890 = 1 ; f (-6101065172474983726) = 2 } in f (-6101065172474983726)
11:55:53 <lambdabot>   1
11:56:46 <DevHC_> shachaf: bah, nvm
11:59:25 <int80_h> asyncExceptions :: Exception -> Maybe AsyncException
11:59:25 <int80_h> asyncExceptions  = const Nothing
11:59:54 <monochrom> haha
11:59:55 <int80_h> to me it looks like this function always returns Nothing, is that right?
12:00:01 <monochrom> yes
12:00:47 <shachaf> > comparing length "\\_->" "const "
12:00:48 <lambdabot>   LT
12:00:54 <int80_h> hmm, not understand why that would be useful.
12:01:26 <monochrom> did anyone swear that it would be useful?
12:02:38 <int80_h> monochrom, well arithExceptions almost looks exactl;y the same. I'm trying to model my own function after these. RWH seems to think arithExceptions is useful.
12:03:09 <parcs> > let f 1.1 = () in f 1.1
12:03:10 <lambdabot>   ()
12:03:59 <int80_h> I'm trying to create a function to pass to handleJust, so thought I could get a clue by looking at functions already made for that purpose.
12:04:16 <int80_h> most of them only return Nothing
12:04:18 <shachaf> int80_h: You're looking at code in a #ifdef for NHC.
12:04:20 <monochrom> I haven't read RWH. does it really define a "arithExceptions = const Nothing"? and does it claim that it is useful?
12:04:30 <shachaf> Assuming you mean http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/src/Control-OldException.html#arithExceptions
12:05:21 <shachaf> Note that the non-NHC definition is much more useful.
12:05:37 <int80_h> monochrom: no the docs on hackage define arithExceptions. RWH uses it as an example
12:05:49 <parcs> > let f 1.3 = x in f 1.0
12:05:49 <lambdabot>   *Exception: <interactive>:3:4-12: Non-exhaustive patterns in function f
12:05:53 <monochrom> well then what shachaf says
12:06:02 <int80_h> shachaf, I clicked on the link named "source" next to the type definition on hackage
12:06:27 <shachaf> int80_h: Did you also read the context?
12:06:41 <int80_h> shachaf: doing that now
12:06:44 <kmc> #ifdef __NHC__
12:07:06 <kmc> i'm not sure why __NHC__ would be defined while Haddock runs.... does Haddock not run CPP at all?
12:07:10 <parcs> so that's why Num instances require an Eq instance. why do they require Show instances?
12:08:10 <applicative> this is the source page, the cpp business is in the source
12:08:16 <shachaf> kmc: Maybe Haddock just takes the first definition it sees.
12:08:22 <shachaf> Without CPP.
12:08:26 * shachaf >>=
12:08:26 <kmc> yeah
12:08:28 <int80_h> shachaf: is the non-NHC definition in the same document?
12:08:33 <kmc> yes int80_h
12:08:35 <kmc> Ctrl-F for it
12:08:38 <monochrom> haddock just calls hscolour or something for the source code html page. does hscolour call up cpp? I think not
12:10:13 <monochrom> if hscolour did, there would be much unrest and vandalisms in protest of "favouristism"
12:12:04 <applicative> hscolour does have special highlighting for cpp lines, it seems -- not visible with this css, I guess
12:12:08 <int80_h> @src arithExceptions
12:12:08 <lambdabot> Source not found. I am sorry.
12:12:30 <sbrg> she lies
12:12:34 <sbrg> sorry she is not
12:13:31 <kmc> haha
12:13:37 <kmc> it's in the file int80_h
12:13:56 * monochrom shakes head. you need better reading skills
12:15:40 <applicative> asyncExceptions (AsyncException e) = Just e ; asyncExceptions _ = Nothing
12:16:06 <kmc> perhaps Ctrl-F should go in my list of important Haskell tools
12:16:32 <int80_h> applicative: that's the pattern I found for most of these types of functions. It didn't make sense to me
12:16:42 <koeien> parcs: historical reasons
12:16:42 <monochrom> no, Ctrl-F alone is not enough. you want to say "repeat Ctrl-F"
12:16:49 <int80_h> oarithExceptions (ArithException e) = Just e
12:16:49 <int80_h> arithExceptions _ = Nothing
12:16:50 <tac-tics> "Uses most powerful statically typed language in history // Most commonly used static analysis tool is CTRL+F"
12:16:52 <int80_h> h wait, just got it
12:16:55 <int80_h> nevermind
12:17:17 <int80_h> @src arithExceptionsI was seeing what I expected to see, not what was there.
12:17:17 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:17:27 <applicative> int80_h: would "isAsyncException: Exception -> Bool" make sense to you?
12:17:55 <monochrom> isAsynException is about as useful as null and isJust
12:18:04 <int80_h> applicative: I got it, I was expecting a type definition for the first line. I had to look at it again, but it's okay now.
12:18:10 <kmc> int80_h, perhaps it will make more sense if you consider catchJust and tryJust
12:18:29 <applicative> int80_h no longer has a problem.
12:18:44 <monochrom> also as useful as asking me "can you explain monads to me?". for I will just say "yes" and not go on to explain monads!
12:19:05 * hackagebot crocodile 0.1 - An offline renderer supporting ray tracing and photon mapping  http://hackage.haskell.org/package/crocodile-0.1 (TomHammersley)
12:19:42 <applicative> hmm, prof. robert harper's blog is down, or gone
12:19:48 * applicative weeps bitter tears
12:19:49 <kmc> is there a portable way to make a temp file from Haskell?
12:20:16 <kmc> ah, yes, openTempFile
12:20:17 <kmc> sorry
12:21:19 <ion> This is nice, too. http://hackage.haskell.org/package/temporary
12:22:17 <parcs> heh, without an (==) definition on Foo 'case Foo of 5 -> ()' hangs indefinitely and eats all your memory
12:22:18 <ion> Although withTempDirectory’s usage of removeDirectoryRecursive is slightly scary as that follows symlinks.
12:22:44 <kmc> sweet
12:22:55 <monochrom> eh? it type-checks?!
12:23:06 <kmc> parcs, did you write an empty Eq instance?
12:23:15 <parcs> kmc: yeah
12:23:19 <kmc> yeah
12:23:19 <engla> ion: eek
12:23:28 <kmc> it's unfortunate that the compiler won't check for minimal instance implementations
12:23:30 <monochrom> oh no wonder. default implementations
12:23:37 <rwbarton> has anyone ever defined an Eq instance in terms of (/=)
12:23:39 <parcs> oh right
12:23:53 <parcs> (==) is defined in terms of (/=) and vice versa
12:23:54 <rwbarton> using the default definition of (==)
12:24:04 <koeien> kmc: even a pragma would do, the compiler wouldn't need to compute anything
12:24:04 <monochrom> I haven't defined /= directly
12:24:38 <koeien> which might be undecidable
12:24:40 <ion> One surely will find it useful to define Eq in terms of (/=), but why would anyone want to define Monad in terms of join?
12:25:01 <kmc> thanks for suggesting 'temporary', ion
12:25:12 <rwbarton> higher order trolling :P
12:25:14 <koeien> ion: /s ?
12:25:27 <koeien> don't forget to close it.
12:26:38 * monochrom prefers to monadize [] by join. (>>=) for [] is a pig to write
12:26:40 <Peaker> join = bind+fmap, and you probably already have fmap.. also  m(m a)->m a      is really simpler than bind
12:26:58 <Peaker> oops, bind=fmap+join
12:27:21 <monochrom> otoh join for StateT may be more difficult than (>>=)
12:27:33 <ion> m (m a) -> m a is *often* simpler than bind. I was about to mention StateT, too.
12:27:52 <koeien> it'd be one extra function pointer in the dictionary, it might be significant
12:27:57 <koeien> unless you'd want to remove >>=
12:28:10 <koeien> what about >=> or something?
12:28:13 <koeien> :t (>=>)
12:28:14 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:28:34 <Peaker> monochrom: I think join for StateT is also easier than (>>=)
12:28:39 <JoeyA> > sequence $ replicate 3 ["<=>"]
12:28:40 <lambdabot>   [["<=>","<=>","<=>"]]
12:28:47 <JoeyA> > sequence $ replicate 3 "<=>"
12:28:48 <lambdabot>   ["<<<","<<=","<<>","<=<","<==","<=>","<><","<>=","<>>","=<<","=<=","=<>","=...
12:28:52 <monochrom> that would be nice
12:28:52 <JoeyA> Try one of those ;-)
12:29:22 <kmc> haha
12:30:01 <Peaker> @djinn (s -> (s, s -> (s, a))) -> s -> (s, a)
12:30:02 <lambdabot> f a b =
12:30:02 <lambdabot>     case a b of
12:30:02 <lambdabot>     (c, d) -> d c
12:30:30 <Peaker> @djinn (s -> (s, a)) -> (a -> s -> (s, b)) -> s -> (s, b)
12:30:31 <lambdabot> f a b c =
12:30:31 <lambdabot>     case a c of
12:30:31 <lambdabot>     (d, e) -> b e d
12:30:34 <kmc> @djinn ((((a -> r) -> r) -> r) -> r) -> ((a -> r) -> r)
12:30:34 <lambdabot> f a b = a (\ c -> c b)
12:30:51 <Peaker> I guess join is virtually always slightly simpler than (>>=)
12:31:07 <kmc> ¬¬¬¬φ → ¬¬φ
12:31:46 <ion> :t let m >>= f = (const m >=> f) undefined in (>>=)
12:31:47 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
12:32:45 <dolio> @djinn (((a -> r) -> r) -> r) -> (a -> r)
12:32:45 <lambdabot> f a b = a (\ c -> c b)
12:32:52 <tac-tics> Negaters gonna negate
12:34:57 <monochrom> yeah, (>>=) is more imperative, join is more "just look at the type and be a djinn"
12:35:39 <tac-tics> Aren't the laws cleaner for djinns than imperators?
12:35:55 <parcs> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
12:35:55 <lambdabot> f a b c = a (\ d -> b d c)
12:36:37 <jsternberg1> given a data type:
12:36:37 <jsternberg1> data YesNoKinda = Yes | No | Kinda
12:36:37 <jsternberg1> is it possible to do something like this?
12:36:37 <jsternberg1> translate :: YesNoKinda -> Bool
12:36:37 <jsternberg1> translate Yes = True
12:36:38 <jsternberg1> translate (Kinda|No) = False
12:36:38 <jsternberg1> (I know it's not a very big deal with this small example, but for what I'm trying to do it would be nice not to have to write the same thing over and over again)
12:36:52 <dolio> Use _
12:37:04 <Rotsor> Don't use _
12:37:04 <tac-tics> translate _ = False
12:37:10 <dolio> There are no or patterns, though.
12:37:14 <koeien> _ matches everything
12:37:21 <jsternberg1> I know I can use _ for the common case, but that's not what I want
12:37:24 <koeien> the order is important, though.
12:37:46 <jsternberg1> I've got a simple data type similar to YesNoKinda (except with more possible data types)
12:38:07 <jsternberg1> and some of them will return the same value, some will return the other value
12:38:11 <koeien> if it's almost always the same, you can do translate x | isSpecial x = ...
12:38:35 <koeien> and isSpecial No = True; isSpecial Kinda = True; isSpecial _ = False
12:38:46 <dolio> That's just moving the problem elsewhere.
12:38:50 <jsternberg1> that still has the same thing I'm trying to avoid
12:38:59 <jsternberg1> except it has one more layer of indirection
12:39:10 <jsternberg1> is there an "or" for pattern matching?
12:39:11 <monochrom> I wouldn't worry about trying to minimize it
12:39:28 <koeien> dolio: yes, but if it occurs repeatedly, it might make sense
12:39:32 <monochrom> no, haskell doesn't have that, that's why I give up
12:39:56 <jsternberg1> okay, just asking to make sure I'm not missing something that could make my life easier
12:40:04 <tac-tics> One thing I honestly can't understand why haskellers don't hate on more is repeating the damn function name in every case
12:40:31 <tac-tics> foo (Lambda x t) = ...; foo (Apply x y) = ...; foo (Var x) = ....;
12:40:49 <parcs> foo x = case x of { ... }
12:40:54 <jsternberg1> tac-tics: it is kind of annoying. I'm just learning the language and that's why I was asking if there was a way for me to minimize the amount of typing I need to do
12:40:58 <tac-tics> We need to keep the mathematicians out of the specs
12:41:16 <tac-tics> jsternberg1: You can use a case statement, but you still have to handle all the cases
12:41:44 <tac-tics> foo x = case x of (Lambda x t ) -> .... ; Apply x y -> ....; Var x = ....;
12:41:46 <koeien> tac-tics: use case. or, editors autocomplete.
12:42:21 <koeien> jsternberg1: be sure to enable compiler warnings, GHC will warn you if you miss some cases
12:42:38 <jsternberg1> koeien: thanks, will do
13:04:32 <Clint> is there an easy way to convert a Data.Map.Map to a Data.Object.Mapping?
13:06:20 <c_wraith> probably some combination of toList and something like fromList
13:06:34 <c_wraith> I doubt there's any direct way.  Though I know nothing about Data.Object.Mapping
13:08:00 <koeien> Clint: Data.Object.Mapping, never heard of it, where did you get it?
13:08:38 <Clint> koeien: i mean the Mapping constructor in Data.Object
13:11:23 <koeien> ah, Mapping . map (id *** Scalar) . Data.Map.toList
13:11:34 <koeien> Clint: I think the above, or a variant of it, should work
13:11:53 <koeien> alternatively, Mapping . map (\(x,y) -> (x, Scalar y)) . toList
13:12:41 <Clint> koeien: ooh, great.  thanks!
13:13:16 <Rotsor> (id *** Scalar) == (second Scalar)
13:13:29 <koeien> Rotsor: ah yes, thanks.
13:13:45 <koeien> i don't know which i think is clearer though.
13:18:12 <JoeyA> Here are some simple benchmarks comparing safe versus unsafe imports: http://hpaste.org/51305
13:18:20 <JoeyA> When the imported function doesn't do anything, unsafe is a LOT faster.
13:18:30 <c_wraith> sure.
13:18:35 <c_wraith> that's because it's unsafe. :)
13:18:58 <koeien> yes, but why would you want to import a function that does not do anything?
13:19:16 <JoeyA> Still, there are cases where you have a function that does very little, and is called a lot: int getField(Result *res, int fieldno) {return res->fields[fieldno];}
13:19:18 <kmc> JoeyA, it's a constant factor
13:19:26 <kmc> a constant *additive* amount
13:19:28 <koeien> yes, profile and then decide.
13:19:39 <kmc> also, ugh, use criterion
13:19:47 <c_wraith> no, don't profile.
13:19:49 <c_wraith> use safe.
13:19:53 <c_wraith> Unless you understand the difference
13:19:59 <kmc> but if you're going to profile, don't use "time"
13:20:08 <c_wraith> And if you understand the difference, you aren't going to use unsafe.
13:20:09 <kmc> here is a better test: http://hpaste.org/51264
13:20:33 <kmc> JoeyA, note that it's less than 200 nanoseconds of overhead
13:20:43 <JoeyA> kmc: Did you compile with -threaded ?
13:20:50 <kmc> are you calling this function millions of times per second?
13:20:52 <kmc> no, i'll try that
13:20:53 <JoeyA> For me, it made the safe overhead three times slower.
13:21:09 <JoeyA> kmc: Potentially, in some cases.
13:21:50 <c_wraith> JoeyA: do you understand the differences between safe and unsafe?  I mean all of them, not just the one or two mentioned in the docs?
13:22:38 <c_wraith> JoeyA: because most of the time, "unsafe" flat out has the wrong behavior, with consequences including potentially corrupting the runtime system.
13:22:51 <kmc> BUT ITS SOOOOO FAST
13:23:31 <hpaste> kmc annotated “safe vs unsafe ffi” with “safe vs unsafe ffi (compiled with -threaded) (for JoeyA)” at http://hpaste.org/51264#a51306
13:23:45 <JoeyA> I understand that if an unsafe function block, it blocks all running threads.  I also understand that unsafe functions should not call back into Haskell.
13:23:49 <JoeyA> What else is there to know?
13:23:52 <kmc> so we're still talking a quarter of a microsecond
13:24:09 <koeien> kmc: so it's 20x for the trivial function with -threaded on your machine
13:24:10 <kmc> http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/ did you read this article?
13:24:13 <c_wraith> JoeyA: The first one of those is only semi-true.
13:24:23 <kmc> don't say "20x" because this is an additive overhead
13:24:41 <kmc> if your function does 1 us of work, now it's a difference of 1.25x
13:24:43 <c_wraith> JoeyA: so...  You don't understand the differences.  Start with ezyang's article
13:25:36 <Rotsor> kmc, 1 microsecond is a lot of time. I think one can compare 100-character strings faster.
13:25:39 <koeien> kmc: 'for the trivial function' is important, yes. if you use "sin" it's no longer 20x
13:25:51 <kmc> yeah, in my benchmarks sin was only like 3x
13:25:57 <kmc> and that's the stated use case for "unsafe"
13:26:00 <koeien> but it might still be significant, or it might not.
13:26:00 <kmc> so even there it's dubious
13:26:10 <c_wraith> yeah, sin is a case where unsafe is actually valid. :)
13:26:11 <kmc> JoeyA, did you consider writing that accessor function in Haskell?
13:26:24 <kmc> i bet there's some fucked-up platform somewhere where sin() blocks very occasionally
13:27:09 <kmc> and now your code has horrible bugs that you will never ever detect
13:27:13 <kmc> but hey, it's really fast, right!
13:27:54 <c_wraith> I've recently helped a co-worker fix a lot of broken FFI wrappers.
13:27:54 <ion> sin() in my cloud operating system makes a SOAP request to the trigonometry cloud.
13:28:00 <kmc> yes
13:28:12 <c_wraith> the first step is always replacing unsafe with safe.
13:28:14 <kmc> it posts an Amazon MTurk request for somebody to draw a right triangle and measure it
13:28:34 <c_wraith> Amazing how many problems that can fix.
13:28:52 <JoeyA> Well, if the GHC rts needs to use sin(), then it'll have the same problem...
13:29:15 <kmc> JoeyA, note that this is a one-token change to the source.  you don't need to architect around it
13:29:19 <kmc> so you really ought to start with safe
13:29:23 <monochrom> sin() calling out for mturk is too far-fetched
13:29:29 <kmc> and switch over if you have *real world evidence* that it matters
13:29:31 <koeien> the writers of the  GHC RTS should be extremely careful as well, yes
13:29:40 <koeien> luckily they are magicians
13:29:45 <kmc> i'll repeat: real world evidence
13:30:14 <koeien> yes and for that accessor into the array, you can use functions in Foreign
13:30:15 <monochrom> but I agree with being scientific about real-world evidence of slowness
13:30:19 <koeien> less work than linking to C
13:30:20 <kmc> not "guessing based on how computers worked in 1970", which is how most performance decisions are made
13:31:35 <kmc> if you want to write incorrect code which runs very fast, i can recommend some languages other than Haskell
13:32:01 <ion> @faq Can Haskell run incorrect code very fast?
13:32:02 <lambdabot> The answer is: Yes! Haskell can do that.
13:32:17 <c_wraith> with properly incorrect code, laziness can be a real time saver.
13:33:38 <Rotsor> Can someone recommend a Haskell library for interfacing with SAT-solvers?
13:34:40 <monochrom> there are some on hackage. I don't know them. I have only heard of them. there are some interfacing with SMT-solvers too
13:34:49 <companion_cube> i think there is one named "satchmo"
13:34:53 <balta2ar> I'm reading http://www.haskell.org/haskellwiki/Package_versioning_policy. A.B is a major number and is supposed to be increased after changing classes/instances. But when do I change A and when B?
13:35:08 <byorgey> Rotsor: also try yices-easy
13:35:25 <byorgey> balta2ar: that is up to you.
13:35:26 <c_wraith> balta2ar: whenever you want.  the PVP doesn't care
13:35:32 <koeien> balta2ar: whenever you think it is appropriate
13:35:36 <monochrom> oh, yices is the one I heard. dons was excited about it
13:35:48 <Nafai> does anyone have a library for interfacing with gdata?
13:36:38 <byorgey> balta2ar: typically A would be changed for a big/exciting/quite disruptive change, or perhaps when you feel the software has reached a certain level of completeness/stability.
13:37:19 <balta2ar> I always thought of version numbers in the following order: <branch>.<major>.<minor>.<bugfix>. We increase branch number on serious archtectural changes. major is for less global, but yet serious. minor is for small additions and bugfix is obvious.
13:37:40 <binsh> anyone here with great knowledge about unification? :)
13:37:41 <monochrom> <joke>change A when a US Republican president replaces a US Democrat president or vice versa</joke>
13:38:12 <monochrom> <joke>change B when Putin quits premier and becomes president</joke>
13:38:21 <balta2ar> but there is a plenty of packages which have only two numbers in their version
13:38:27 <byorgey> binsh: almost certainly someone here does.  do you have a great question about it?
13:38:31 <koeien> balta2ar: yes, the PvP is not followed well. :(
13:38:44 <koeien> widely*
13:39:13 <balta2ar> koeien: PvP also does not clarify that difference between branch and major number, as I expected
13:39:23 <JoeyA> So A.B has to increase even if instances are added only?
13:39:39 <koeien> JoeyA: yes, because instance importing cannot be suppressed, and you might get a clash
13:40:05 <JoeyA> okay, thought so
13:40:06 <monochrom> because adding instances breaks backward compatibility (say, my old code already has my own instances)
13:40:13 <JoeyA> What if foreign imports are changed from unsafe to safe?  ;-)
13:40:20 <monochrom> (my old user code, of course)
13:40:27 <monochrom> ha ha ha
13:40:33 <binsh> { t(X,f(Z)) = t(a,Y) }  ---> t(a, f(Y) }
13:40:38 <binsh> does this look right?
13:40:42 <binsh> im new to this stuff
13:41:03 <koeien> balta2ar: yes, that could be added for clarification. although as is there is no contradiction afaics
13:41:13 <monochrom> semantic change without name/type change may or may not be considered "remove then add", yes that's where the debate is
13:41:27 <byorgey> binsh: that doesn't look right.
13:41:37 <byorgey> binsh: are capital letters unification variables? and lowercase are constants?
13:41:42 <binsh> yeah
13:41:56 <byorgey> binsh: unifying f(Z) with Y does not produce f(Y)
13:42:02 <monochrom> is Y a variable?
13:42:02 <koeien> monochrom: if the old behavior was "incorrect" or "buggy", then you might think it's appropriate to only increase the minor version
13:42:21 <binsh> oh, ok, it doesnt change then?
13:42:31 <binsh> yeah, Y is a variable
13:42:42 <byorgey> binsh: also, the output of unification is a mapping between unification variables and terms, not just a term
13:42:51 <balta2ar> koeien: can you give some examples of changes which increase branch and major numbers? I can't clearly get the difference and adopt it to my project
13:42:55 <monochrom> and "a" is a variable too? is there any significance in upper case and lower case?
13:43:08 <byorgey> so it should be  { t(X,f(Z)) = t(a,Y) } --->  { X -> ... , Z -> ...  } etc.
13:43:12 <binsh> X, Y and Z are variables
13:43:20 <byorgey> monochrom: lowercase are constants/function symbols.
13:43:22 <koeien> balta2ar: the branch might increase, while the major number decreases
13:43:35 <monochrom> eww, that's... why you have to say it!
13:43:35 <koeien> balta2ar: parsec2 vs parsec3
13:44:02 <byorgey> monochrom: ?
13:44:04 <monochrom> X := a, Y := f(Z), Z := Z
13:44:31 <monochrom> as a Haskeller I may use the opposite convention, lower case variable
13:44:39 <binsh> so: { t(X,f(Z)) = t(a,Y) } ----> { X -> a, Y -> f(Z) } then?
13:44:52 <koeien> balta2ar: as byorgey said, a big or very disruptive change, a totally new approach to the problem, or something like this
13:44:53 <byorgey> yes
13:45:01 <koeien> binsh: i think that's right
13:45:13 <binsh> nice thanks!
13:45:14 <tac-tics> Is there a general notion in monad when there's an "undo" primitive?
13:45:21 <balta2ar> koeien: and what about major number? when do I increase it?
13:45:23 <byorgey> monochrom: lowercase for constants and uppercase for variables is more common in the logic community, I believe.
13:45:38 <tac-tics> such that x >> y >> undo = x... or something along those lines?
13:45:43 <monochrom> oh sure, but I am not in ##logic
13:45:43 <koeien> balta2ar: you are required, according to PvP, to increase the major number when you remove functions, change their types, or add/remove instances
13:45:54 <binsh> how about the mgu, how do i tell what that is?
13:46:15 <balta2ar> well, now I think I get it. thanks.
13:46:19 <kmc> tac-tics, wouldn't that mean (x >> y) >> undo  ≠  x >> (y >> undo) ?
13:46:47 <hpc> i was just wondering that myself
13:46:47 <koeien> balta2ar: but 3.0 > 2.1, obviously, and this is a "major version change" according to the PvP
13:47:00 <byorgey> binsh: note that  X := a, Y := f(q), Z := q   is also a unifier for those expressions
13:47:03 <hpc> i would do something like atomic (x >> y) >> undo
13:47:11 <hpc> vs x >> y >> undo
13:47:13 <byorgey> binsh: but intuitively it is "too specific" since the Z := q  is unnecessary
13:47:23 <balta2ar> koeien: 3.0 -> 3.1 is major as well, as far as I get it
13:47:25 <binsh> where do you get q?
13:47:28 <hpc> wait, that still has the same problem
13:47:31 <tac-tics> kmc: I'm not sure. It's just an imagination-space idea in my brain.
13:47:37 <byorgey> binsh: I made it up, that's the point
13:47:42 <koeien> balta2ar: yes.
13:47:43 <binsh> ahh, hehe
13:47:56 <tac-tics> (x >> y) >> undo would equal x
13:48:03 <byorgey> binsh: the "most general unifier" is the mapping which does only what is necessary to unify the expressions, and does not "make up" any extra information
13:48:15 <koeien> tac-tics: does this undo exists for all y?
13:48:17 <tac-tics> and I guess x >>= (\v0 -> y >>= (\v1 -> undo)) would equal x as well
13:48:36 <tac-tics> koeien: yeah. I'm curious what classification of monad it would be.
13:48:36 <byorgey> binsh: you can define it more formally than that, but that's the basic idea.
13:48:55 <binsh> byorgey: ok, so the mapping i made is the mgu?
13:48:56 <shachaf> tac-tics: What's "y"? Some sort of primitive action?
13:48:59 <roconnor_> tac-tics: this doesn't quite work as you want
13:49:01 <byorgey> binsh: yes.
13:49:06 <monochrom> you need "checkpoint >> x >> y >> undo" which undoes to the checkpoint. now everything is clear
13:49:11 <shachaf> tac-tics: (After all, y can't be (w >> z), because then undo would only undo z.)
13:49:26 <koeien> tac-tics: or do you mean, undo :: m a -> m a, and then x >> y >> undo y
13:49:45 <shachaf> koeien: That sounds kind of magical.
13:49:46 <roconnor_> tac-tics: according to your spec (x >> (y >> z)) >> undo would have to equal x but ((x >> y) >> z) >> undo would have to equal (x >> y), but >> is associative.
13:49:51 <shachaf> Way more than e.g. checkpoint.
13:49:53 <tac-tics> monochrom: I think it would probably need a checkpoint, yeah...
13:49:58 <hpc> koeien: that undo would run up against the halting problem i think
13:50:03 <binsh> byorgey: nice, thx^^
13:50:11 <byorgey> binsh: you're welcome.
13:50:17 <tac-tics> Just an idle curiosity
13:50:21 <roconnor_> tac-tics: right, undo would have to undo upto some sort of checkpoint or undo attomic commands.
13:50:26 <tac-tics> yeah
13:50:29 <koeien> hpc: hmm it seems so
13:50:39 <tac-tics> and in that case, it would just be a transaction monad of some sort
13:50:42 <roconnor_> or something like that
13:50:44 <shachaf> tac-tics: There's http://www.haskell.org/haskellwiki/New_monads/MonadUndo
13:50:44 <tac-tics> abusing continuations
13:50:44 <hpc> the checkpoint idea is best though
13:50:58 <monochrom> next, you will conceive: p<-checkpoint; abc; q<-checkpoint; x; y; if blah then undo p else undo q
13:50:58 <hpc> and you can do stuff like atomic act = act >> checkpoint
13:51:13 <hpc> or something like that
13:51:18 * roconnor_ spend week and weeks trying to get undo working in his paint program (C/C++) back in the day.
13:51:24 <monochrom> then you find out about "delimited continuations" and be enlightened!
13:52:32 <shachaf> @quote monochrom
13:52:32 <lambdabot> monochrom says: Well I was writing Windows apps in C since the days of Windows 3.0 and I tell you it's very OO.
13:52:41 <monochrom> haha
13:53:17 <monochrom> I used windows 3.0 on 286s
13:53:52 <tac-tics> That was before the MMU was in common use, wasn't it?
13:53:53 <monochrom> 80MB used to be a lot of hard disk space
13:54:48 <monochrom> 286 had MMU too. just that it's segmentation not paging. somehow people didn't like it
13:54:57 <tac-tics> ah
13:55:21 <tac-tics> When I was in college, I was really interested in assembly programming
13:55:22 <roconnor_> monochrom: whats not to like about two different pointers pointing to the same place. >:(
13:55:22 <shachaf> preflex: be monochrom
13:55:22 <preflex>  Do not try to pronounce haskell code. You are not a modem.
13:55:30 <monochrom> but there were several unixes for 286 protected mode
13:55:34 <tac-tics> I bought a very dusty old book that explained the brand new i386 CPU
13:55:59 <tac-tics> and all its magnificent features
13:56:02 <tac-tics> (like paging)
13:56:20 <tac-tics> it took me a long time to appreciate how brilliant some of that shit actually was
13:56:36 <tac-tics> having isolated contexts for each of your program....
13:57:07 <roconnor_> tac-tics: I think many programers still don't really appreciate isolation.
13:57:12 <roconnor_> for some reason
13:57:22 <tac-tics> Yeah. Tell me about it.
13:57:27 * tac-tics goes back to his PHP codebase
13:57:30 <sbrg> roconnor_: isolation is what all programmers do
13:57:35 <roconnor_> they tend to ask questions like, "why use the reader monad when the state monad can do that and more?"
13:57:38 <sbrg> in cubicles, at home
13:57:38 <sbrg> etc
13:57:59 <roconnor_> This is a fair question, but it is a bit scary to hear so often.
13:58:05 <monochrom> well segmentation does not imply different pointers pointing to the same place. 8088 DOS kind of segmentation does, sure. but if you go protected mode in 286 you can write your OS to not do that
13:58:48 <hpc> roconnor_: not so scary; it's effectively the same question as "what's the point of haskell if you can't change values"
13:58:49 <roconnor_> monochrom: hmm, how does protected mode with segmented memory work?
13:59:05 <hpc> the benefit of Reader is that the internal "state" never changes
13:59:13 <roconnor_> hpc: I think that is a different question
13:59:32 <tac-tics> roconnor_: I think it has to do with people not understanding the whole covariance-contravariance duality
13:59:39 <roconnor_> I'll rephrase with a better example
13:59:42 <hpc> roconnor_: then "why use haskell when scheme has variables you can mutate" or something
13:59:46 <roconnor_> they tend to ask questions like, "why use the writer monad when the state monad can do that and more?"
13:59:50 <hpc> they come from the same conceptual place
14:00:09 <tac-tics> restrictions are the dual of guarantees
14:00:27 <roconnor_> hpc: ah, yes, that is the same question
14:00:31 <monochrom> it has been a long time since last I knew the details of 286 protected mode
14:00:40 <roconnor_> monochrom: heh, it's okay
14:01:19 <tac-tics> Sometimes, I think it's silly how crazy overloaded Haskell is with new innovations.
14:01:35 <tac-tics> Because each new innovation, in a sense, weakens the guarantees of the language
14:01:35 <hpc> tac-tics: most haskell features are old ;)
14:01:44 <tac-tics> yeah
14:01:58 <hpc> and the scariest features in that regard are all extensions
14:02:07 <tac-tics> but no matter how you spell it, adding something to a language is also taking something away
14:02:09 <tac-tics>  /zen
14:02:15 <hpc> heh
14:02:19 <roconnor_> tac-tics: are you refering to the sin-bin called IO?
14:02:38 <roconnor_> because I think outside of IO the features added are not so bad.
14:03:10 * roconnor_ ponders what type guarentess that adding rank2 or rankN polymorphism might remove.
14:03:16 <tac-tics> roconnor_: More general than that. Every time you add something to any language, unless its sugar for already existing feature in the language, you are removing a guarantee of the language
14:03:43 <c_wraith> rankN removes the ability to infer code that doesn't use type classes.
14:03:48 <monochrom> user code sees 3 segments: code, data, stack. if your program counter is 0x300, your stack pointer is 0x300, your BX is 0x300 and you plan to use that as an address to load something into AX, well they all point to different places
14:03:50 <tac-tics> For example, a refactoring tool becomes necessarily more complicated as a consequence of adding a new feature
14:03:55 <c_wraith> I believe rank-2 inference without type classes is still decideable, though.
14:04:20 <copumpkin> c_wraith: I keep hearing that but I've never seen a citation
14:04:24 <copumpkin> do you have one?
14:04:39 <monochrom> OS dictates which segment maps to which physical address
14:04:46 <c_wraith> hmmm.  no.  I'm trying to remember where I first heard it.
14:04:55 <c_wraith> I might be repeating a lie!
14:05:05 <roconnor_> c_wraith: but I mean what guarenteess about functionality do you lose
14:05:16 <roconnor_> c_wraith: like somes sort of free theorem
14:05:35 <c_wraith> roconnor_: you lose some sorts of guarantees like f (a b) is the same as f $ a b
14:05:46 <c_wraith> roconnor_: see the fun of $ and . with runST
14:06:08 <c_wraith> roconnor_: which is really about type checking, not functionality
14:06:14 <c_wraith> roconnor_: but it has a definite impact
14:06:18 <shachaf> c_wrait: Well, not with $. :-)
14:06:21 <roconnor_> yes, but tac-tics is talking about functionality
14:06:27 <hpc> c_wraith: it's about guarantees, was the original point
14:06:38 <shachaf> > runST `id` return 3
14:06:39 <lambdabot>   Couldn't match expected type `m t'
14:06:39 <lambdabot>         against inferred type `forall s....
14:06:39 <roconnor_> right guarentees
14:06:43 <shachaf> > runST $ return 3
14:06:44 <lambdabot>   3
14:06:55 <tac-tics> If you wanted a language with unlimited power, just be done with it and use lisp.
14:06:58 <shachaf> > let foo = ($) in runST `foo` return 3
14:06:59 <lambdabot>   3
14:07:02 <c_wraith> shachaf: yes, that's because $ has magic impredicativity. :)
14:07:03 <hpc> @quote lisp.static
14:07:03 <lambdabot> No quotes match. Do you think like you type?
14:07:05 <shachaf> > let foo = id in runST `foo` return 3
14:07:06 <lambdabot>   Couldn't match expected type `m t'
14:07:07 <lambdabot>         against inferred type `forall s....
14:07:08 <hpc> @quote lisp.*static
14:07:08 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
14:07:09 <monochrom> OS can play this trick: many users are using vi at the same time. so you map multiple code segments to the same physical address, because that's where vi code is sitting now. one copy of code serves many processes. so yes you can still have "different pointers point to the same place", but each user does not have sufficient privilege to find out, so it's alright
14:07:13 <roconnor_> presumably without rank2 polymorphism I can guarentee some fact about the behavour of polymorphic functions that I cannot do without it.
14:07:20 <tac-tics> heh
14:07:25 <roconnor_> *cannot do with it
14:07:35 <shachaf> > let foo x y = x y in runST `foo` return 3
14:07:37 <lambdabot>   3
14:07:40 <copumpkin> c_wraith: it's not $ in particular
14:08:05 <c_wraith> > show . runST $ return 3
14:08:06 <lambdabot>   Cannot match a monotype with `forall s. GHC.ST.ST s a'
14:08:39 <shachaf> Values are overrated.
14:08:46 <shachaf> type a :$ b = a b
14:09:07 <shachaf> No impredicativity problems. :-)
14:09:11 <tac-tics> Another example in haskell....
14:09:14 <copumpkin> > let x = id :: (a -> b) -> (a -> b) in runST `x` return 5
14:09:15 <lambdabot>   5
14:09:18 <tac-tics> Operators
14:09:24 <tac-tics> I don't know what :$ does
14:09:29 <tac-tics> I can't even google it!
14:09:39 <shachaf> tac-tics: I just defined it right there.
14:09:41 <tac-tics> But it's a feature
14:09:44 <tac-tics> ah
14:09:56 <c_wraith> there's still magic impredicativity there.  Even if I don't know where exactly it is.
14:10:00 <tac-tics> well, principle holds in absense of the definition
14:10:15 <shachaf> > let x = id runST in x (return 5)
14:10:16 <lambdabot>   5
14:10:41 <shachaf> > let x y = id runST y in x (return 5)
14:10:42 <lambdabot>   Cannot match a monotype with `forall s. GHC.ST.ST s a'
14:11:17 * shachaf mad
14:11:33 <monochrom> oh, that's strange
14:11:45 <copumpkin> shachaf: that doesn't make sense
14:11:53 <binsh> does this seem completely wrong to you guys? {f(b, s(s(Z)) = f(X,Y), h(z) = h(g(a,b)) } -----> {X -> b, Y -> s(s(Z)), g(a,b) -> z }
14:12:03 <shachaf> copumpkin: Which part?
14:12:11 <monochrom> don't worry too much about it. I don't want to see you becoming insane!
14:12:23 <copumpkin> oh sorry, misread
14:13:33 <monochrom> if z is not a variable, you are not allowed g(a,b)->z or z->g(a,b)
14:13:52 <binsh> hmm okay
14:14:08 <binsh> only capital letters are variables
14:14:37 <binsh> so {X -> b, Y -> s(s(Z)) } is the only right solution?
14:15:10 <monochrom> h(z) = h(g(a,b)) gives you a "no match" error
14:15:38 <binsh> ok, so the whole "expression" is invalid then?
14:15:42 <monochrom> yes
14:15:48 <binsh> nice, thx ;)
14:16:05 <shachaf> > id runST (return 5)
14:16:06 <lambdabot>   Couldn't match expected type `m t'
14:16:06 <lambdabot>         against inferred type `forall s....
14:16:07 * roconnor_ wonders if binsh is programming in O'Cult
14:16:09 <shachaf> > (id runST) (return 5)
14:16:10 <lambdabot>   5
14:16:13 <shachaf> Huh?
14:16:21 <monochrom> if you see {X=a, a=b} you say "no solution", you don't say "let me ignore a=b so I can solve it by X->a"
14:16:28 <c_wraith> I told you.  Magic impredicativity. :P
14:16:38 <shachaf> c_wraith: But... Parentheses?
14:16:42 <c_wraith> magic
14:16:59 <roconnor_> why would they be different?
14:17:15 <shachaf> "Shun magic, and shun the appearance of magic. Shun everything, and then shun shunning."
14:17:19 <binsh> roconnor_: im currently taking a course called functional programming. were going to learn haskell later, but are currently going through some theroy if i can use that term
14:17:42 <tac-tics> binsh: cool (and good luck)
14:17:44 <monochrom> this is why they say GHC 6.12's impredicativity is not quite right
14:17:54 <binsh> thx^^
14:18:01 <c_wraith> I don't even attempt to understand when ghc uses magic impredicativity.  I instead just write code that doesn't depend on it.
14:18:10 <tac-tics> binsh: Just remember. Lambdabot is 90% of what you need to pass any haskell course
14:18:19 <shachaf> Wait, (id runST) (return 5) doesn't work in my ghci.
14:18:31 <c_wraith> shachaf: it's very version-dependent
14:18:36 <binsh> haha ^^ nice, ill try it
14:18:45 <shachaf> c_wraith: Oh, right. Works in 6.12.
14:19:08 <roconnor_> doesn't (id runST) (return 5) and id runST (return 5) represent the same AST?
14:20:26 <shachaf> roconnor_: Apparently not.
14:20:40 <copumpkin> wait, one works and the other doesn't?
14:20:46 <tac-tics> @type runST
14:20:47 <lambdabot> forall a. (forall s. ST s a) -> a
14:20:49 <elliott> > id runST (return 3)
14:20:50 <lambdabot>   Couldn't match expected type `m t'
14:20:50 <lambdabot>         against inferred type `forall s....
14:20:51 <elliott> > (id runST) (return 3)
14:20:52 <lambdabot>   3
14:20:55 <elliott> Please tell me this is a GHC bug.
14:20:59 <roconnor_> oh god
14:21:04 <elliott> Oh, you've already been talking about it.
14:21:08 <elliott> Blame shachaf.
14:21:17 <tac-tics> > id runST
14:21:18 <lambdabot>   Overlapping instances for GHC.Show.Show
14:21:18 <lambdabot>                              ((fora...
14:21:19 <shachaf> elliott: It doesn't happen in GHC 7.
14:21:26 <copumpkin> oh I see
14:21:29 <copumpkin> they aren't the same
14:21:37 <elliott> It should parse identically. >:(
14:21:40 <roconnor_> must be some sort of stupid spine thing :/
14:21:53 <tac-tics> Is it a parse issue or a type issue?
14:21:57 <elliott> They're identical according to the rep- wait, ST isn't even part of the reports.
14:21:58 <copumpkin> a type issue
14:22:10 <tac-tics> yeah. With that second rank type, I could see id screwing up
14:22:12 <elliott> But seriously, why does (f x y) parse differently to ((f x) y)?
14:22:15 <copumpkin> @ty \x -> id runST x
14:22:16 <lambdabot>     Cannot match a monotype with `forall s. ST s a'
14:22:16 <lambdabot>       Expected type: t
14:22:16 <lambdabot>       Inferred type: forall s. ST s a
14:22:18 <copumpkin> @ty id runST
14:22:18 <lambdabot> forall a. (forall s. ST s a) -> a
14:22:22 <elliott> Even apart from rank-N types.
14:22:22 <duairc> On my VPS, whenever I try to cabal install anything, cabal gets killed. I presume because I don't have enough memory. Is there anything I can do about this?
14:22:25 <elliott> They should be the same, shouldn't they?
14:22:26 <copumpkin> one requires instantiating a type variable to a polymorphic value
14:22:28 <copumpkin> the other
14:22:29 <copumpkin> does not
14:22:40 <tac-tics> elliott: They do parse the same. They don't type the same
14:22:53 <roconnor_> tac-tics: that makes no sense
14:22:55 <parcs> duairc: try replacing the default linker with the gold linker
14:22:56 <c_wraith> duairc: you can try disabling split objects.  that should make ld use much less memory.  You can also use gold to link, instead of ld.  I have no experience using either of those, firsthand.
14:22:57 <copumpkin> they don't parse the same
14:22:58 <elliott> tac-tics: That's incoherent :P
14:23:04 <elliott> Unless type-checking is done on strings.
14:23:24 <parcs> split objects i think are disabled by default
14:23:28 <copumpkin> I've explained it
14:23:31 <copumpkin> look at the eta expansion
14:23:51 <roconnor_> But I see what copumpkin is saying, the hidden type parameter arguments are being passed differently somehow.
14:24:10 <roconnor_> which is a little frightening
14:24:10 <copumpkin> the issue arises when you try to instantiate a type variable to a polymorphic value
14:24:21 <copumpkin> id runST doesn't require that
14:24:21 <elliott> copumpkin: Yes, you've explained it, but you haven't explained why (f x y) doesn't /parse/ the same as ((f x) y).
14:24:24 <shachaf> duairc: More memory?
14:24:30 <shachaf> duairc: Swap?
14:24:56 <c_wraith> swap for ld is SLOOOOW.
14:25:04 <tac-tics> elliott: it could be some optimizations are done before type checking
14:25:21 <elliott> tac-tics: Those will also be done on the AST.
14:25:24 <elliott> aka: the result of parsing.
14:25:54 <tac-tics> lawl, fine. If you don't want my nonsensical explanations, quit asking the channel for sensible ones :P
14:26:08 <tac-tics> It's a compiler bug. It's damn near magical to us mortals.
14:27:15 <hpaste> copumpkin pasted “parse” at http://hpaste.org/51309
14:28:22 <monochrom> shouldn't you get rid of the Parens?
14:28:26 <c_wraith> that's a concrete syntax tree.  isn't the idea that the AST strip out some details like Parens?
14:29:05 <JoeyA> If a package used an MIT license instead of the nearly-ubiquitous (at least in Hackage) BSD3 license, would that cause any problems?
14:29:17 <c_wraith> licensing and hackage is a nightmare.
14:29:22 <kmc> JoeyA, the MIT and BSD licenses are very similar
14:29:32 <kmc> it's not hard to comply with the terms of both at the same time
14:29:37 <kmc> read them, though
14:30:13 <kmc> it's not like the "license" field in the .cabal file is legally binding; it's the LICENSE file itself
14:30:18 <kmc> (afaik, but ianal)
14:31:53 <JoeyA> thanks
14:33:03 <kmc> for that matter, a BSD-licensed package can depend on a GPL-licensed package
14:33:11 <kmc> (it is a common misconception that this is not allowed)
14:33:26 <kmc> but if you distribute the two packages *together*, you must comply with the terms of both licenses
14:33:40 <kmc> which includes distributing a binary that is built from the source of both
14:33:51 <c_wraith> Hence, distributing haskell binaries using code from hackage can be really onerous.
14:33:59 <kmc> you're obliged (by the terms of the GPL) to provide all the source for all the code that went into that binary
14:34:04 <c_wraith> It's easy to accidentally depend on 20 different licences
14:34:25 <ben> if only everybody used agpl-3 at all times
14:34:27 <koeien> is the GHC RTS also BSD-licensed?
14:34:30 <kmc> yes
14:34:41 <kmc> there are plenty of valid reasons to BSD-license your code even if it depends on GPL-only code.  however, angry ignorant people will be angry and ignorant at you
14:34:43 <koeien> but it's compiled into my executable
14:35:07 <koeien> so I need to provide the BSD-license for that part
14:35:28 <binsh> {g(X, f(Y)) = Z, h(Z, a) = h(g(X,b), v) } anyone who can give me a hint? this seems like a pretty hard one. can i switch g(X, b) for g(X, f(Y)) ?
14:35:58 <kmc> koeien, yeah.  it's very common that commercial software ships with a big list of BSD attributions buried somewhere
14:36:07 <kmc> my android phone has this in a menu somewhere
14:36:20 <koeien> kmc: that I know, yeah. zlib is particularly common
14:36:26 <kmc> that said, GHC might have an extra license for the RTS which is exempt from that
14:36:28 <kmc> i'd check to be sure
14:36:52 <koeien> the gplv2 explicitly does not claim copyright in such a case afair
14:36:53 <tac-tics> What is the RTS?
14:36:59 <tac-tics> ah
14:37:00 <tac-tics> runtime system
14:37:02 <tac-tics> yeah?
14:37:03 <koeien> the run-time system
14:37:05 <kmc> yes
14:37:15 <tac-tics> It's one of those acronyms you say out loud and it just comes to you
14:37:35 <koeien> kmc: i'm not distributing any binaries atm, but i'll keep it in mind
14:37:55 <koeien> it's easy to miss in any case
14:39:05 <zachk> so is the licensing issues's one of the things holding back killer haskell apps?
14:39:24 <koeien> i doubt it. a lot is BSD-licensed
14:39:38 <koeien> BSD3 is very permissive
14:39:47 <tac-tics> zachk: Haskell doesn't need killer apps. It already has killer types
14:39:51 <kmc> btw, nobody outside the Haskell community says "BSD3"
14:40:01 <osfameron> BSD3?
14:40:10 <koeien> really? oh
14:40:16 <kmc> the killer apps for Haskell are internal tools in use at banks, hedge funds, Facebook, Google, NASA, the NSA, DARPA, biotech firms, ...
14:40:22 <roconnor_> osfameron: http://www.opensource.org/licenses/BSD-3-Clause
14:40:25 <shachaf> BSD4 is clearly a better version of BSD3.
14:40:36 <kmc> the software you can run on your desktop is pretty much the ass end of the software industry
14:41:13 <roconnor_> hmm
14:41:16 <osfameron> ah
14:41:25 <roconnor_> BSD3 means BSD *with* the advertising clause??
14:41:35 <kmc> hardware design, bioinformatics, defense consulting, financial modeling just aren't interesting enough... but if someone would make a GUI app that kind of lets you organize your music collection, or maybe a sliding tile puzzle game, or a thing that downloads pictures of cats and shows them to you
14:41:35 <shachaf> roconnor_: That's BSD4.
14:41:39 <kmc> then Haskell would really take off
14:41:44 <roconnor_> heh
14:41:48 * roconnor_ will stick with MIT
14:42:26 <shachaf> What's the difference between MIT and BSD?
14:42:40 <roconnor_> I don't know but there is no version number confusion :P
14:42:45 <kmc> shachaf, it's an east coast / west coast thing.  like hip hop
14:42:47 <tac-tics> kmc: I WANT THE CAT APP
14:42:47 <shachaf> kmc: I have an odd sense of déjà vu.
14:42:54 <kmc> shachaf, that's because i'm quoting myself
14:43:23 <shachaf> preflex: be kmc
14:43:24 <preflex>  i first learned Haskell because somebody told me "if you like psychedelic drugs, you'll probably like Haskell"
14:43:27 <kmc> haha
14:43:30 <kmc> it's true
14:43:41 <kmc> preflex, be shachaf
14:43:41 <preflex>  There was a study once where they gave one group real placebos and the other group fake placebos, and the effects were exactly the same.
14:44:01 <shachaf> Ugh.
14:44:10 * shachaf is annoyed by that quote.
14:44:12 <zachk> preflex, be zachk
14:44:12 <preflex>  no quotes found for zachk
14:44:15 <monochrom> haha
14:44:21 <coppro>  /win 156
14:44:41 <shachaf> coppro: Alt-... Wait... Never mind.
14:44:41 <tac-tics> preflex: Yes, that was a haskell study. The one group was given a Java. The other was given a "type safe programming language called Haskell". The both made it really easy to write programs that got stuck in infinite loops when you use the wrong variable name.
14:45:26 <preflex> are you talking to me?
14:45:36 <YeOldeFarte> I WANT THE CAT APP 2
14:45:38 <preflex> you? you talkin' to me?
14:46:18 <tac-tics> forall x:User. x WANTS TO SEE THE CAT APP
14:46:27 <YeOldeFarte> Just listening in....
14:46:30 <coppro> shachaf: exactly
14:47:02 <tac-tics> Actually, where's Cale. Could we replace @vixen with a bot that linked to a random picture of a cat instead of nixon?
14:47:02 <shachaf> coppro: I thought 97 was a lot.
14:47:49 <monochrom> or link to the same picture every time
14:48:25 <shachaf> @where lambdacats
14:48:26 <lambdabot> http://tinyurl.com/lambdacats
14:48:38 <tac-tics> monochrom: Wouldn't that be @random always returning the number 4 (ala xkcd?)
14:49:05 <mauke> preflex: help version
14:49:05 <preflex>  version - print a random number
14:49:48 <shachaf> preflex: help mauke
14:49:48 <preflex>  unknown command: mauke
14:51:06 <parcs> @hoogle unblock
14:51:06 <lambdabot> Control.Exception unblock :: IO a -> IO a
14:51:06 <lambdabot> Control.OldException unblock :: IO a -> IO a
14:51:06 <lambdabot> Control.Exception.Base unblock :: IO a -> IO a
14:51:43 <parcs> is there an unblock for MonadIOs
14:53:00 <kmc> you could use monad-peel
14:53:10 <kmc> actually i think there's a newer package of that sort
14:53:28 <monochrom> it's less effort to make @vixen referentially transparent. it's more effort to make it random
14:53:29 <Saizan> monad-control
14:54:17 <mauke> preflex: calc rand
14:54:17 <preflex>  0.8401877167634666
14:55:36 <hpaste> dainanaki pasted “Parallel map enumeratee ” at http://hpaste.org/51310
14:55:43 <dainanaki> hey guys, I'm trying to figure out how to write a parallel map for the enumerator package, but I'm having trouble implementing it. Could someone help me?
14:55:56 <dainanaki> All of the sparks end up getting GC'ed
15:22:01 <Louis11> Working on brushing up on my haskell and ran into this code: map (head:) acc. What does the colon after "head" mean? I understand head to be the start of the list . . .
15:22:22 <hpc> Louis11: it's a section
15:22:23 <tac-tics> Louis11: the colon is cons
15:22:36 <tac-tics> @let f = (1:)
15:22:37 <lambdabot>  Defined.
15:22:39 <tac-tics> > f []
15:22:39 <Louis11> what does it doe exactly?
15:22:40 <lambdabot>   Ambiguous occurrence `f'
15:22:40 <lambdabot>  It could refer to either `L.f', defined at <local...
15:22:40 <hpc> > (+ 1) 5 -- Louis11
15:22:41 <lambdabot>   6
15:22:43 <tac-tics> err
15:22:54 <hpc> > (5 :) [1..3] -- Louis11
15:22:54 <lambdabot>   [5,1,2,3]
15:22:56 <tac-tics> @let c = (1:)
15:22:57 <lambdabot>  Defined.
15:22:59 <tac-tics> > c []
15:23:00 <lambdabot>   Ambiguous occurrence `c'
15:23:00 <lambdabot>  It could refer to either `L.c', defined at <local...
15:23:07 <tac-tics> what is the rest of that error >_>
15:23:07 <hpc> > 5 : [1..3]
15:23:08 <lambdabot>   [5,1,2,3]
15:23:26 <tac-tics> > (1:) ( (2:) [] )
15:23:27 <lambdabot>   [1,2]
15:23:30 <mauke> @undefine
15:23:43 <kmc> Louis11, (x:)  ≡  (\y -> x:y)
15:23:52 <kmc> just like (2+)  ≡  (\y -> 2+y)
15:24:19 <kmc> Louis11, the (:) operator puts a value on the the head of a list
15:24:26 <kmc> > 2 : [1,3,4]
15:24:26 <lambdabot>   [2,1,3,4]
15:24:34 <Louis11> kmc: Ah alright makes more sense then
15:24:35 <kmc> in fact [x,y] is just sugar for (x : y : [])
15:26:13 <stribor> > Hello Stribor:)
15:26:14 <lambdabot>   <no location info>: parse error on input `)'
15:29:28 <Eduard_Munteanu> @vixen stribor says hi
15:29:28 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
15:29:50 <stribor> Eduard_Munteanu: whats @vixen:)
15:30:26 <tac-tics> stribor: Up until certian people decided it was politically incorrect, @vixen used to be a chatbox emulating a horny 19-year old girl
15:30:44 <Eduard_Munteanu> tac-tics: she still is
15:30:45 <tac-tics> However, it was replaced by a different command's behavior this morning. Now it is a synonym for @nixen
15:30:53 <Eduard_Munteanu> @vixen a/s/l
15:30:53 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
15:30:58 <Eduard_Munteanu> Wait... wha...
15:31:06 <Eduard_Munteanu> Nooo!
15:31:10 <tac-tics> Eduard_Munteanu: see? Less horny, more political
15:31:35 <stribor> nice
15:32:04 <Olathe> tac-tics: Hahahaahaha
15:32:14 * Eduard_Munteanu sets up a petition
15:35:32 <dainanaki> lol
15:36:38 <KirinDave> hrrm.
15:36:51 <KirinDave> Some javascript guy is giving me a hard time because haskell doesn't have "callbacks support"
15:37:10 <KirinDave> I corrected him on this, but pointed out that streams are sort of a preferred abstraction for most of that stuff anyways.
15:37:37 <mauke> IO is entirely callback based
15:37:45 <KirinDave> He's asking me when you'd ever want streams instead of callbacks as an abstraction.
15:38:03 <KirinDave> mauke: Indeed. I said as much, I just said conceptually that model is not something that most people prefer to think in.
15:38:08 <Peaker> KirinDave: why change the subject? First settle the first point, then change subjects
15:38:23 <KirinDave> Peaker: Well it's been me being evasive for awhile now.
15:38:41 <Peaker> "Haskell doesn't support callbacks", "yes, it does"
15:38:46 <KirinDave> Peaker: I did that part.
15:38:47 <KirinDave> But I'm wondering if there is some brilliant and default example of how stream abstractions solve problems callbacks don't.
15:38:54 <KirinDave> I mentioned concurrency
15:38:54 <KirinDave> b
15:38:59 <KirinDave> But evidently this gets ignored.
15:39:05 <KirinDave> Since "javascript doesn't have threads."
15:39:15 <dainanaki> no longer true.
15:39:15 <kmc> more trolling by proxy?
15:39:26 <KirinDave> kmc: TBP
15:42:44 <dpiponi> Is there a library that allows me to build an instance of IArray from a pointer to raw data?
15:43:00 <stribor> is it possible for map function to during the executing put elements in certain place in list
15:43:15 <dpiponi> I don't want to copy the data to a new array.
15:43:26 <byorgey> stribor: can you give an example?
15:43:57 <ddarius> dpiponi: You probably want to use ByteString or vector.
15:44:09 <stribor> well lets say we have map func "some string" ["elem1","e;em2","elem3]
15:44:19 <ddarius> I believe that vector has a way to turn a ForeignPtr into a Vector.
15:44:39 <stribor> so lets say func just concatines 2 strings
15:44:43 <Eduard_Munteanu> Maybe you can freeze a StorableArray.
15:45:10 <Olathe> stribor: What would that do?
15:45:18 <byorgey> stribor: that does not type check
15:45:23 <monochrom> (map func "some string" ["elem1","e;em2","elem3]) is a type error
15:45:24 <Eduard_Munteanu> unsafeForeignPtrToStorableArray :: Ix i => ForeignPtr e -> (i, i) -> IO (StorableArray i e)
15:45:38 <Olathe> Well, it depends on the func.
15:45:42 <Saizan> and then unsafeFreeze
15:45:43 <shachaf> KirinDave: Give him a hard time because JavaScript doesn't have "monad support".
15:45:44 <byorgey> stribor: you can do this:
15:45:55 <KirinDave> shachaf: Ha
15:45:57 <byorgey> > map (++"some string") ["elem1", "elem2", "elem3"]
15:45:59 <lambdabot>   ["elem1some string","elem2some string","elem3some string"]
15:46:05 <KirinDave> I don't want to give him a hard time or anything, he's a co-worker.
15:46:12 <Peaker> :t map ?func "some string" []
15:46:13 <lambdabot>     Couldn't match expected type `[a] -> t' against inferred type `[b]'
15:46:13 <lambdabot>     In the expression: map ?func "some string" []
15:46:13 <KirinDave> I'm just not sure of a good compelling example he would understand.
15:46:25 <byorgey> Olathe: technically, I suppose it does.  but I doubt that's what stribor has in mind.
15:46:27 <Olathe> Hmm, never mind.
15:46:30 <monochrom> but your co-worker gives you a hard time
15:46:32 <Peaker> KirinDave: why not take some callback code he likes, and translate it to nicer Haskell?
15:46:37 <KirinDave> I was thinking maybe 'How do you detect double clicks?'
15:46:43 <Olathe> @type map func "" ["", ""]
15:46:44 <lambdabot> Not in scope: `func'
15:46:55 <Saizan> though unsafeFreeze might be copying for StorableArray..
15:46:56 <Olathe> @type \func -> map func "" ["", ""]
15:46:57 <lambdabot>     Couldn't match expected type `[[Char]] -> t'
15:46:57 <lambdabot>            against inferred type `[b]'
15:46:57 <lambdabot>     In the expression: map func "" ["", ""]
15:46:57 <KirinDave> Detecting double clicks in javascript is kind of an eternal hack.
15:47:05 <stribor> byorgey: what i am trying to do is build list of stirngs.....but use map so that when it contacvtines if length is less then 10 puts it into first place in list
15:47:11 <stribor> otherwise puts it in second
15:47:12 <dobblego> KirinDave: how is that giving you a hard time? It's pretty funny if you ask me
15:47:16 <stribor> and so on
15:47:22 <Olathe> Yeah, it can't work.
15:47:31 <KirinDave> dobblego: I do not think he'd get the joke. :)
15:47:35 <shachaf> Olathe: It can if map = fmap.
15:47:44 <dobblego> KirinDave: too bad for him, still funny
15:48:05 <byorgey> stribor: forget about map for a minute, can you just give an example of some inputs and the output you would like?
15:48:11 <stribor> ok give me sec
15:48:25 <shachaf> KirinDave: Where are you working nowadays?
15:49:21 <dpiponi> ddarius: is there a mechanism to construct a vector from a raw pointer?
15:49:58 <shachaf> Huh, it's a dpiponi.
15:50:38 <hpaste> stribor pasted “example” at http://hpaste.org/51311
15:50:40 <Eduard_Munteanu> No, it's a sigfpe
15:50:44 <Eduard_Munteanu> No, it's...
15:50:52 <KirinDave> shachaf: Crowdflower.
15:50:54 <dpiponi> Ah, I just saw the reply about unsafe...Array. I'll look into it.
15:50:57 <dainanaki> grr, I'm still having a hard time getting parallelism and the enumerator library to play nicely together.
15:51:18 <stribor> byorgey: so if length of concat string is less than 11 put it into first place,otherwise start putting it in second place...and so on
15:51:25 <KirinDave> dainanaki: Oh? I was about to tackle this. Mind giving me a heads up on the minefield?
15:51:26 <stribor> but dont write code for me
15:51:40 <stribor> give me somedirectorion so i can try to do it myself
15:52:02 <ddarius> dpiponi: Wrap it in a ForeignPtr and use the mechanism I alluded to.
15:52:10 <dainanaki> KirinDave: I'm just having a tricky time getting sparks to actually get evaluated instead of being garbage collected or fizzling.
15:52:13 <byorgey> stribor: ok, I won't write code for you.  But I am still not sure what you are trying to do.
15:52:19 <monochrom> \∩/
15:52:28 <byorgey> stribor: so does this operation take a string and a list of strings as input?
15:52:34 <stribor> yes
15:52:52 <byorgey> stribor: ok, so what if I input "foo" and ["blah", "baz", "bar"]
15:53:03 <dpiponi> ddarius: Thanks. I'll give it a go.
15:53:04 * ddarius directs stribor at a Haskell introduction.
15:53:06 <byorgey> stribor: and the length of "foo" is less than l1
15:53:22 <KirinDave> dainanaki: I know this is shameful to admit, but…
15:53:29 <byorgey> stribor: what should I get out?
15:53:32 <monochrom> l1? 11?
15:53:37 <KirinDave> dainanaki: I usually wire my enumerators such that they are eager between clicks.
15:53:41 <stribor> well we define what length we want.......lets say 5
15:53:48 <KirinDave> dainanaki: Or rather, my iteratees.
15:54:03 <stribor> so ok 5 wont work too small
15:54:16 <stribor> lets say 7
15:54:16 <dainanaki> KirinDave, how do you mean?
15:54:27 <stribor> ["fooblah","bazbar"]
15:54:32 <stribor> 7 or less
15:54:38 <KirinDave> dainanaki: Well you continue but carry data over? I accumulate it into data with eager fields.
15:55:00 <ddarius> dpiponi: Storable is the way to view a Ptr as an array of something.  StorableArray would then be the obvious thingto consider after that as Eduard_Munteanu mentioned.
15:56:21 <dpiponi> ddarius: Yes, that makes sense.
15:56:29 <byorgey> stribor: ok, interesting.  you definitely cannot do that with map.
15:56:35 <dainanaki> KirinDave: that's not such a bad idea, but I'm looking for a way to evaluate the xs of (Chunks xs) in parallel in enumeratees.
15:56:39 <ptrf> this might be very off topic, but anyone here able to recommend to me a latex package to write derivation trees?
15:56:55 <KirinDave> dainanaki: yeah I am experimenting with that for my irc client.
15:57:03 <stribor> map gets input function right?
15:57:07 <stribor> cant we do something like thius
15:57:11 <KirinDave> dainanaki: Do you want a memgenerator answer? :D
15:57:19 <stribor> function::String->String->Bool
15:57:35 <dainanaki> KirinDave: sure :D
15:58:01 <stribor> so we say if length a++b < 7 ==True else False
15:58:02 <byorgey> stribor: sure, but then you get a list of Bools.
15:58:21 <KirinDave> dainanaki: http://images.memegenerator.net/instances/400x/9971959.jpg
15:58:54 <dainanaki> heh
15:58:56 <stribor> this doesnt seem like trivila problem
15:59:43 <KirinDave> dainanaki: Seriously tho, I don't see how it's a a problem.
15:59:47 <byorgey> it's not particularly trivial, no.
16:00:02 <byorgey> stribor: are you reading any particular tutorials or books?
16:00:02 <stribor> like first string represents line
16:00:08 <KirinDave> dainanaki: One of the points of iteratees is to evaluate streams in constant space. No fair complaining when I guarantee that. :D
16:00:12 <stribor> yes i am ...
16:00:28 <stribor> http://learnyouahaskell.com/chapters
16:00:28 <byorgey> stribor: by the way, 'if X then True else False' is the same as just 'X'
16:00:36 <dainanaki> fair enough.
16:00:59 <stribor> i know i was just trying to tell you my idea..but obviosly wasnt gonna do it
16:01:03 <byorgey> stribor: OK, cool.  I would suggest trying to implement it by writing a recursive function which pattern-matches on the list and decides what to do at each step
16:01:22 <ion> if X then (if True then True else False) else (if False then True else False)
16:01:36 <cmccann> ahahahaha, defining class instances for type classes is fun, this is certainly going to end well
16:01:47 <cmccann> "instance Foo Eq where..."
16:01:54 <monochrom> what?!
16:02:04 <hpc> cmccann: wait, what are you reading?
16:02:06 <ion> > if True then if True then True else False else if False then True else False
16:02:07 <lambdabot>   True
16:02:17 <stribor> yeah but why do i need pattern matching
16:02:20 <cmccann> monochrom, "class Foo (cxt :: * -> Constraint) where ..."
16:02:23 <stribor> all i care is length of the string
16:02:37 <monochrom> "instance Stupid Monad where" :)
16:02:40 * cmccann figures this is one of those "allowed by virtue of not being excluded" things
16:02:55 <cmccann> same goes for type families and all that
16:03:10 <ion> > if True then if True then if True then True else False else if False then True else False else if False then if True then True else False else if False then True else False
16:03:11 <lambdabot>   True
16:03:23 <stribor> i keep adding to first place until reaches my limit....then i start adding to second place until reches limit
16:03:25 <stribor> and so on
16:03:36 <ddarius> cmccann: I'm pretty sure that was intended to be allowed.
16:03:49 <cmccann> hpc, not reading anything, just playing with a GHC snapshot build
16:03:52 <hpaste> dainanaki annotated “Parallel map enumeratee ” with “Parallel map enumeratee  (annotation)” at http://hpaste.org/51310#a51312
16:03:53 <hpc> ah
16:04:18 <dainanaki> KirinDave: this is what I have, but it does nuthin useful.
16:04:42 <KirinDave> dainanaki: Huh.
16:05:06 <KirinDave> dainanaki: Imagine a different version of the image with seq, I guess? :D
16:05:11 <cmccann> ddarius, of course, that's just how at least one thing described constraint synonyms. basically "these really are types now, this is not an extra feature, it's follows automatically"
16:05:51 <dainanaki> And it's funny, because I've asked this question repeatedly here in #haskell, and I can never get a useful answer on parallelising enumerators.
16:06:16 <ion> > let f 0 b = show b; f (pred -> n) b = "if " ++ f n b ++ " then " ++ f n True ++ " else " ++ f n False in f 2 True
16:06:17 <lambdabot>   "if if True then True else False then if True then True else False else if ...
16:06:24 <KirinDave> dainanaki: Does something like result `seq` (\r -> continue r) in your iteratee help?
16:08:00 <ddarius> Types are things that have kind *.
16:08:55 <KirinDave> dainanaki: I think doing that would force the result to be computed before it could be passed out as a continuation.
16:08:59 <Peaker> dainanaki: do you want concurrency or parallelism? Enumerators typically have visible effects, so what semantics do you expect from parallelizing them?
16:09:00 <dainanaki> KirinDave: nope, doesn't have an effect.
16:09:23 <dainanaki> Peaker: I actually want parallelism in enumeratees.
16:09:24 <KirinDave> dainanaki: That's really weird.
16:09:51 <dainanaki> when I said enumerators, I just meant using the enumerator library
16:09:54 <Peaker> dainanaki: but parallelism between things that have effects will have ugly concurrency semantics?
16:10:14 <hpaste> int80_h pasted “Pattern Match Overlap” at http://hpaste.org/51313
16:10:52 <cmccann> ddarius, so things with kind ?? aren't types? :]
16:11:40 <dainanaki> Peaker: not really. enumerators get something from a source. enumeratees are pipes that process the source somehow (which can include side effects). Iteratees are the other end of the pipe that spit out useful data. In my case, I'm wanting to apply pure transformations in parallel over whatever comes down the pipe.
16:12:29 * cmccann has on several occasions seen "type" used for anything with a kind not containing (->), including the new Constraint kind
16:12:30 <KirinDave> Yeah if anything having liftIO in your iteratee makes laziness less of a problem
16:12:30 <Peaker> dainanaki: "pure transformations" on a pipe would basically be fmap on it?
16:12:34 <KirinDave> dainanaki: Hah, there is your solution. WRITE IT TO FILE
16:12:36 <mauke> oh shit, constraint kinds
16:13:08 <cmccann> mauke, did you see what I mentioned earlier about class instances for constraints? :D e.g. "instance Foo Eq where..."
16:13:08 <KirinDave> dainanaki: feel like hpasting the offending iteratee?
16:13:18 <mauke> cmccann: no
16:13:18 <Peaker> dainanaki: If you have a type that restricts the transformations to be pure, then maybe you can parallelize them nicely
16:13:18 <dainanaki> http://hpaste.org/51310
16:13:58 <cmccann> mauke, well, all I really said is that it works, so yeah
16:13:59 <monochrom> "type" is also used for things with kind "* -> *". see the Haskell Reports for examples.
16:14:09 <Peaker> dainanaki: what's the type of parMap ?
16:14:09 <cmccann> monochrom, ah, really? ok, fair enough.
16:14:34 <dainanaki> Peaker: Monad m => (a' -> a) -> Enumeratee a' a m b
16:14:41 <cmccann> monochrom, makes sense to me, I just thought I'd seen that distinction being drawn before
16:14:42 * monochrom conforms to Haskell Report terminologies. for example "type class" not "typeclass"
16:14:58 <monochrom> yes, some other people want to draw a line
16:16:08 <Peaker> dainanaki: the parallelism is just on the chunks?
16:16:13 <ddarius> monochrom: It, however, always uses the form "type of kind K"
16:16:22 <dainanaki> Yes.
16:16:46 <dainanaki> It applies parallelism to a chunk and then operates on the next.
16:16:51 <dainanaki> In theory, anyhow.
16:18:00 <monochrom> "The Maybe type is an instance of classes Functor, Monad, and MonadPlus." that sentence mentions no kind in +/-10 lines
16:18:13 <dainanaki> However, all of my sparks either fizzle or get GC'ed
16:19:21 <JoeyA> Is it possible to wait on multiple file descriptors at a time, without using a thread for each one?
16:19:35 <JoeyA> threadWaitRead and threadWaitWrite can only handle one each.
16:19:48 <monochrom> yes, there is an epoll binding
16:19:52 <Eduard_Munteanu> Some select() equivalent.
16:20:09 <monochrom> the package name is also "epoll"
16:20:46 <mauke> JoeyA: why not use a thread for each one?
16:20:57 <JoeyA> curl_multi_fdset :P
16:21:08 <JoeyA> It expects fd_set pointers
16:21:33 <JoeyA> Though I'm wondering if I should just use the easy interface and threads.
16:21:51 <KirinDave> dainanaki: Well I am definitely interested in your problem, that pattern is exactly what I want for one of my toy projects.
16:22:00 <monochrom> "easy interface" sounds easier to use
16:22:01 <JoeyA> That would be fine for me, as long as they're Haskell threads and not OS threads.
16:22:14 <c_wraith> JoeyA: it'll probably segfault if https is involved.
16:22:27 <dainanaki> KirinDave: I'm getting tempted to fork enumerator and rice it up a bit.
16:22:30 <monochrom> forkIO is going to be haskell threads in practice
16:22:43 <KirinDave> dainanaki: Man, please do not :)
16:22:59 <KirinDave> dainanaki: Enumerator is actually usable, sorta, once you beat your head on it for awhile.
16:23:09 <JoeyA> c_wraith: Why?  Because curl is not thread-safe w.r.t. https?
16:23:18 <KirinDave> dainanaki: And almost everyone supports it AND iteratee. If there was ANOTHER iteratee library...
16:23:20 <KirinDave> Oh man.
16:23:20 <c_wraith> because openssl isn't thread-safe
16:23:36 <dainanaki> yeah, it's useable, but I mean look at it's list code...
16:23:38 <JoeyA> :S
16:23:50 <c_wraith> at least, that's where all the segfaults seem to trace back to in the code that made me stop using curl
16:23:58 <dainanaki> It implements map using concatmap *shudder*
16:24:06 <stribor> byorgey: still there:)
16:24:18 <monochrom> hmm, that almost rules out all multi-threading approaches
16:24:19 <KirinDave> dainanaki: Have you used iteratee?
16:24:38 <dainanaki> nope, because everything else I want uses enumerator.
16:24:50 * JoeyA greps the IRC log for the question about HTTP requests in Haskell
16:24:54 <franny> GnuTLS is supposed to be threadsafe.
16:25:02 <stribor> byorgey: i am thinking about ading head of the list to input string then once it is hit the limit put that into new list
16:25:08 <KirinDave> dainanaki: I found iteratee to be a bit faster but WAY harder to use.
16:25:46 <c_wraith> JoeyA: people mostly seem to use http-enumerator now
16:25:47 <dainanaki> I really want enumerator to work, and it does. I just want parallelism too...
16:26:10 <KirinDave> dainanaki: And tracing the code doesn't reveal any insight?
16:26:26 <KirinDave> dainanaki: Because I know something like that works for forkIO.
16:26:40 <KirinDave> dainanaki: So clearly it's POSSIBLE if the evaluator can get motivated enough
16:26:45 <dainanaki> hrm, I guess I can trace and see.
16:26:54 <JoeyA> dainanaki: What do you mean by parallelism?  Multiple simultaneous downloads?
16:27:14 <JoeyA> (which is what I need)
16:27:24 <dainanaki> JoeyA: no, I'm in a different conversation, sorry.
16:27:29 <JoeyA> ah
16:27:33 <KirinDave> dainanaki: https://github.com/KirinDave/redis-conduit/blob/master/Tap/Redis.hs
16:27:52 <dpiponi> ddarius: That usafe...Array function gives me a mutable array. I could unsafeFreeze it but it looks like it might make a copy. Am I interpreting this correctly: http://goo.gl/v2dIF
16:27:58 <KirinDave> dainanaki: In particular, L35: https://github.com/KirinDave/redis-conduit/blob/master/Tap/Redis.hs#L35
16:28:17 <ddarius> dpiponi: unsafeFreeze shouldn't make a copy.  That is why it is unsafe.
16:28:39 <dpiponi> Docs seems to say say it only avoids making a copy for 4 particular cases.
16:29:24 <ddarius> Are those your cases?
16:29:45 <monochrom> (you also have to turn on optimizations)
16:29:46 <dpiponi> Well I want to go from StorableArray to any kind of immutable array
16:29:58 <KirinDave> Man, sometimes I look at that code and get really stoked I actually wrote it.
16:30:01 <KirinDave> I am learning haskell!
16:30:15 <JoeyA> :-)
16:30:19 <dainanaki> :)
16:31:34 <nafai> KirinDave: Know the feeling.
16:31:42 <nafai> I'm even more stoked when I understand why it works.
16:31:50 <KirinDave> I mean, I understand that code perfectly
16:31:59 <KirinDave> I know it is not great haskell, but I _like_ it. :)
16:32:03 <KirinDave> Which is probably dangerous.
16:32:11 <ddarius> dpiponi: That's not going to be possible without copying because many immutable arrays are contiguous arrays of pointers.  Others are contiguous arrays of whatever GHC represents the data type as.
16:33:12 <dpiponi> Sorry. When I said any, I mean I don't care, not that I need to be able to convert to any. The data is stored contiguously so it should be the same as an unboxed array.
16:34:42 <JoeyA> Data.Vector might have something
16:35:08 <JoeyA> Have you tried using logarithms?  ( http://xkcd.com/451/ )
16:45:48 <stribor> can i write OR like this.....filter (\x->length x > 10 | length x < 15)
16:46:09 <stribor> this is of cource applied to the loist
16:46:45 <monochrom> OR is || not |
16:46:53 <monochrom> > True || False
16:46:54 <lambdabot>   True
16:47:39 <stribor> tx
16:47:51 <c_wraith> I kind of like that zip`ap`tail is only kind of accidentally lazy enough to work correctly on empty lists. :)
16:48:31 <JoeyA> (zip`ap`tail) []
16:48:33 <JoeyA> > (zip`ap`tail) []
16:48:34 <lambdabot>   []
16:48:54 <ddarius> c_wraith: Why do you feel that it is accidental?
16:49:19 <JoeyA> (\xs -> zip xs (tail xs)) []
16:49:22 <JoeyA> > (\xs -> zip xs (tail xs)) []
16:49:23 <lambdabot>   []
16:49:24 <c_wraith> ddarius: Hmm.  I guess both parts of it come from reading right-to-left, if you dig deep enough.
16:49:30 <JoeyA> > (\xs -> zip (tail xs) xs) []
16:49:31 <lambdabot>   *Exception: Prelude.tail: empty list
16:49:36 <c_wraith> ddarius: so that isn't really accidental
16:49:53 <Jafet> It's a total function made from a partial function
16:50:12 <Jafet> I wonder how you can prove it's correct without dependent typing
16:50:12 <mgsloan> hmmm. Is there some hacky way of importing a module that's not exported by a cabal package?  I really want to use Language.Haskell.Exts.Lexer but don't want to make a new version of haskell src exts in order to do so
16:50:59 <c_wraith> Jafet: well, examining multiple cases and structural induction
16:51:05 <c_wraith> Jafet: in this particular case
16:51:59 <c_wraith> hmm.  is there such a thing as structural co-induction?  You'd need that to prove the infinite case
16:52:04 <mgsloan> I guess just including a subset of the haskell src exts code would not be the end of the world
16:53:48 <JoeyA> > nuke :: RealWorld -> IO ()
16:53:49 <lambdabot>   Not in scope: type constructor or class `RealWorld'Not in scope: `nuke'
16:54:26 <c_wraith> that's a bit redundant.  you just need IO ()
16:54:32 <JoeyA> lol
16:55:01 <c_wraith> also, depending on if it destroys the *whole* world or not, a better return type might be IO a
16:55:02 <JoeyA> nuke :: IO (Either String ())
16:55:20 <c_wraith> since IO a implies it will never return successfully
16:55:31 <JoeyA> With cabal, is it possible to list the licenses of a package and all of its dependencies?
16:55:44 <c_wraith> No.  That's been requested a few times
16:55:59 <c_wraith> dcoutts was saying some work had been done towards it, but it was never finished.
16:56:11 <JoeyA> Where does cabal store its configuration?
16:56:19 <JoeyA> (err, its list of available packages)
16:56:27 <c_wraith> ~/.cabal
16:56:35 <c_wraith> is where it stores everything
16:56:48 <JoeyA> Where specifically?  There's a lot of stuff in there.
16:56:59 <JoeyA> 00-index.tar.gz ?
16:57:07 <c_wraith> I'm not sure exactly where.
16:57:10 <c_wraith> that sounds likely
16:57:41 <JoeyA> I guess my best bet would be to alter my copy of cabal.  I just have to find my way around.
16:58:11 <ivanm> 00-index.tar.gz is a tarball of all the .cabal files on hackage
16:58:42 * cmccann ponders using a type-level list of (* -> Constraint)s as a reified call stack for type-level metaprogramming
17:01:54 * JoeyA ponders using lists for value-level programming
17:02:17 <Jafet> Who programs at the value level
17:02:23 <JoeyA> > putStrLn "I do!"
17:02:24 <lambdabot>   <IO ()>
17:02:34 <JoeyA> Don't give me that face, lambdabot.
17:02:43 <cmccann> pf, values
17:02:56 <JoeyA> values are sooo 2000s
17:04:03 <blackdog> can you derive Arbitrary somehow? if a type implements Enum, it seems an obvious step
17:04:04 <JoeyA> Doesn't <IO ()> look like Tin Man?
17:04:14 * hackagebot hledger-vty 0.15.2 - A curses-style console interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-vty-0.15.2 (SimonMichael)
17:04:20 <ddarius> JoeyA: No.
17:05:22 <punk> Hello, I'm working through a problem set but one is bogging me down. Trying to build a list of integers that goes down from given integer---example: CountDown 3 -> [3,2,1]
17:06:06 <JoeyA> > let n = 5 in [n, n-1 .. 1]
17:06:07 <lambdabot>   [5,4,3,2,1]
17:06:10 <shachaf> > putStrLn " <IO ()>"
17:06:11 <lambdabot>   <IO ()>
17:06:59 <JoeyA> If you want more fun, you could use iterate, which applies a function to its argument over and over, returning each successive result.
17:07:07 <JoeyA> > iterate (*2) 1
17:07:08 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
17:07:23 <JoeyA> > iterate (subtract 1) 5
17:07:24 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18...
17:07:38 <Jafet> > [10,9..] :: [Word]
17:07:39 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
17:07:45 <Jafet> > iterate (subtract 1) 10 :: [Word]
17:07:46 <JoeyA> nice
17:07:46 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,18446744073709551615,18446744073709551614,184467440...
17:08:17 <JoeyA> How do you make it stop?  That's for you to figure out.  It should only take a while to figure out.
17:09:10 <hpaste> kmc pasted “Arbitrary for Enum (for blackdog)” at http://hpaste.org/51314
17:09:54 <kmc> blackdog, you can get much further if you use a package like 'derive'
17:10:03 <JoeyA> punk> We gave a few solutions above.  Do you have any constraints on what you can use?
17:10:04 <stribor> can you use zip on same function.....like zip needs 2 parametahrs which is two list
17:10:09 <stribor> how would you use zip on 2 same lists?
17:10:13 <kmc> i bet you could also implement the deriving wit GHC 7.2's new generic programming features
17:10:21 <kmc> stribor, you can just say:  zip xs xs
17:10:26 <kmc> but you can also use 'join'
17:10:28 <kmc> :t join zip
17:10:29 <lambdabot> forall a. [a] -> [(a, a)]
17:10:33 <kmc> > join zip "abc"
17:10:34 <lambdabot>   [('a','a'),('b','b'),('c','c')]
17:10:44 <kmc> > map (\x -> (x,x)) "abc"
17:10:44 <lambdabot>   [('a','a'),('b','b'),('c','c')]
17:10:48 <kmc> > map (join (,)) "abc"
17:10:49 <lambdabot>   [('a','a'),('b','b'),('c','c')]
17:10:59 <punk> It should stop at 1 from any given integer
17:11:32 <JoeyA> punk: I mean, are you required to give a recursive solution?
17:11:44 <punk> yes
17:11:46 <JoeyA> [n, n-1 .. 1] works, but it's not very insightful.
17:11:51 <JoeyA> ah, okay
17:12:10 <JoeyA> punk: How would you do it in an imperative language?
17:12:21 <JoeyA> (i.e. print a list of numbers from n down to 1)
17:13:05 <blackdog> kmc: ok, thanks. i'll look into it.
17:13:26 <stribor> kmc: tx
17:13:35 <blackdog> kmc: man, i'm leaning hard on ndm's stuff today :)
17:13:36 <punk> I'm completely new to this stuff-most of my successful codes have been pure chance
17:13:56 <JoeyA> To programming in general?
17:14:02 <JoeyA> Or to Haskell in particular?
17:14:08 <punk> in general
17:14:11 <JoeyA> ah
17:14:24 <kmc> learning Haskell may be easier if you don't know other languages :)
17:14:29 <kmc> it's very different
17:14:30 <blackdog> punk: yeah, no evil habits to unlearn:)
17:14:46 <kmc> (that said, i've only heard this anecdotally and second-hand; I don't know of any rigorous studies or anything)
17:14:57 <stribor> can anyone give me example of join usage
17:15:09 <JoeyA> > :i join
17:15:10 <lambdabot>   <no location info>: parse error on input `:'
17:15:24 <Peaker> I don't think it's easier to learn the technical stuff, but it's probably easier not to deal with "but I'm a programmer, why is this difficult for me?"
17:16:05 <blackdog> Peaker: there are things like teasing apart variables and mutable references
17:16:06 <JoeyA> Anyway, in an imperative language, you might do (pseudocode): set n to 5.  While n is greater than 5, print n, then subtract 1 from n.
17:16:07 <kmc> stribor, i gave one up there
17:16:26 <stribor> > join zip "abc
17:16:27 <lambdabot>   <no location info>:
17:16:27 <lambdabot>      lexical error in string/character literal at end o...
17:16:39 <stribor> > join zip "abc
17:16:40 <lambdabot>   <no location info>:
17:16:40 <lambdabot>      lexical error in string/character literal at end o...
17:16:42 <stribor> uhh
17:16:59 <Jafet> In haskell, you can get successful code by pure chance too
17:17:05 <JoeyA> punk: So in a functional language, you can use recursion to "update" a value—by passing the new version to the function.
17:17:16 <hpaste> mgsloan pasted “Constructor import issues” at http://hpaste.org/51315
17:17:28 <mgsloan> ^ this is strange
17:17:37 <Peaker> stribor: " opens a string, you have to close it
17:17:41 <JoeyA> > let f n = if n > 0 then n else f (n-1) in f 10
17:17:43 <lambdabot>   10
17:17:47 <JoeyA> oops
17:17:51 <mgsloan> I modified haskell-src-exts to export the ParseMonad module, and it seems to export functions, but not constructors...
17:17:57 <Jafet> @quote ContT
17:17:58 <lambdabot> autrijus says: * autrijus stares at type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x) and feels very lost <shapr> Didn't you write that code? <autrijus> yeah. and it works <autrijus> I
17:17:58 <lambdabot> just don't know what it means.
17:18:01 <JoeyA> > let f n = if n > 0 then f (n-1) else n in f 10
17:18:02 <lambdabot>   0
17:18:05 <kmc> mgsloan, does your export list look like ( T ) or ( T(..) )
17:18:16 <JoeyA> punk: Do you understand how the above line of code works?
17:18:34 <punk> yeah
17:18:42 <mgsloan> kmc: Lex is a newtype with "runL" as its singular field.  the export is T(runL)
17:19:00 <mgsloan> err Lex(runL)
17:19:03 <JoeyA> When we call f with an argument 10, it first sees if n is > 0.  If so, it calls itself with n-1.  Otherwise, it stops and returns n.
17:19:14 <kmc> mgsloan, and what if you change it to (..)
17:19:16 * hackagebot debug-diff 0.1 - Display a colorized diff between two Haskell values  http://hackage.haskell.org/package/debug-diff-0.1 (KeeganMcAllister)
17:19:19 <mgsloan> I guess that only exports the accessor
17:19:27 <kmc> yeah, and not the data constructor
17:19:39 <JoeyA> So your question might be: how do we hang onto each item produced?
17:19:44 <mgsloan> kmc - cool, thanks!
17:19:46 <JoeyA> That can be done with the cons (:) operator.
17:19:51 <JoeyA> > [1,2,3,4,5]
17:19:52 <lambdabot>   [1,2,3,4,5]
17:19:56 <JoeyA> > 1:2:3:4:5:[]
17:19:57 <lambdabot>   [1,2,3,4,5]
17:20:24 <JoeyA> > let f n = n : f n in 10
17:20:25 <lambdabot>   10
17:21:02 <JoeyA> punk: See if you can tweak that to make it count down (no need to worry about making it stop yet).
17:22:19 <cwl> how to read 'class (Monad m) => MonadError e m | m -> e where'
17:22:39 <cwl> especially '| m -> e'
17:23:00 <cmccann> cwl, that's a functional dependency
17:23:17 <JoeyA> Where m functionally determines e.
17:23:31 <Olathe> For each m, you can't have two different es that go with that m.
17:23:31 <JoeyA> For any type m, there is only one type e.
17:23:38 <cmccann> it means that the type "m" uniquely determines "e". so it can't have two instances with the same "m" but different "e"s.
17:23:57 <Jafet> Gee!
17:23:58 <cmccann> you can, however, get multiple explanations for the same concept
17:24:01 <cmccann> it seems
17:25:01 <gwern> like monads
17:25:31 <Olathe> Monads are like metaphors.
17:25:38 <Olathe> Lots and lots of metaphors.
17:26:02 <JoeyA> A monad is like a magic box.  You can put something in it, but you can't (necessarily) get it out.  You can, however, have someone go in, look at what's in the box, and give you a new box; you don't get to see what's inside, though.
17:26:07 <Jafet> Monads are abstractions that produce metaphors.
17:26:09 <kmc> ugh
17:26:13 <kmc> that metaphor sucks JoeyA
17:26:13 <kmc> i'm sorry
17:26:22 <JoeyA> heh
17:26:30 <kmc> monads aren't containers; IO Int is not a container of ints.  neither is (Char -> Int)
17:26:34 <Nafai> metaphors are like monads
17:26:39 <kmc> there's no Int hiding inside the IO Int
17:26:40 <Nafai> not everyone understands them
17:27:20 <kmc> if you think of IO as a "taint tag" applied to "impure values" then you won't understand the full range of what's possible with Haskell's IO type
17:30:05 <shachaf> kmc: (Char -> Int) is just another representation of (Map Char Int). :-)
17:30:11 <kmc> sort of
17:30:19 <kmc> how about ∀r. (Int -> r) -> r
17:30:42 <Jafet> Map Char (Either SomeException Int)
17:31:00 <kmc> heh
17:31:11 <kmc> i can put exception-raising thunks inside the Map, too
17:31:21 <Olathe> We should have a game where someone says "Monads are like _____" and then everyone has to invent an explanation that fits.
17:31:42 <Jafet> @quote monads.are.like
17:31:42 <lambdabot> mtnviewmark says: monads are like a transparent train, moving backward in time... and filled with Jell-O
17:31:52 <JoeyA> Monads are like actions.  You can either "return" a value, or you can bind that action to another action, passing along its value.
17:32:07 <Jafet> I think we can start with that classic one
17:32:09 <blackdog> i wonder if java groups argue this much about strategy patterns.
17:32:14 <Olathe> Let's see.
17:32:26 <cmccann> @quote burrito.category
17:32:26 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
17:32:41 <Olathe> I'm completely stuck, though I will say Jell-O is good and monads contain good things.
17:32:50 <Olathe> Haha
17:32:52 <kmc> monads are like type constructors M of kind (* -> *) which implement two polymorphic functions, return :: a -> M a and (>>=) :: M a -> (a -> M b) -> M b
17:32:57 <kmc> do you like my analogy
17:33:01 <Olathe> Haha
17:33:10 <JoeyA> I took the username monad on Starcraft Battle.net
17:33:11 <Jafet> @quote two-category
17:33:11 <lambdabot> No quotes match. The more you drive -- the dumber you get.
17:33:12 <Peaker> kmc: what about the laws??
17:33:16 <Jafet> @quote 2-category
17:33:16 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
17:33:20 <JoeyA> Problem is, people think it's just "gonad" misspelled.
17:33:21 <kmc> i'm above the law Peaker
17:33:22 <dmwit> I don't know, it doesn't really jive with my intuition of monads as spacesuits.
17:33:26 <duairc> I said this a while ago, but forgot to check back. I'm on a VPS with limited (500MB) memory, and whenever I run cabal-install, it gets killed (I presume because it runs out of memory). I was told to look into using the gold linker. I did, but then I realised that cabal dies at the "resolving dependencies" stage.
17:33:31 <kmc> JoeyA, they don't assume you're a big Leibniz fan?
17:33:35 <Peaker> Monadic emperor kmc
17:33:50 <JoeyA> I don't get it
17:34:13 <dmwit> duairc: You can skip dependency resolution if you're alright with managing the dependencies yourself.
17:34:49 <kmc> duairc, do you have another machine you could compile on?
17:35:06 <duairc> kmc: Unfortunately my server is 32-bit but all my machines are 64-bit.
17:36:10 <blackdog> duairc: from long and painful experience, you'll be much better off running a local vm and uploading a static binary.
17:36:17 <kmc> so run 32-bit binaries on the server duairc
17:37:21 <kmc> er, other way
17:37:33 <kmc> yeah, build the binaries in a 32-bit VM or chroot on your 64-bit workstation
17:37:54 <kmc> or install 32-bit ghc in a non-chrooted prefix, though i bet that's more likely to run into trouble
17:38:06 <duairc> I guess I'll just do the VM thing.
17:39:38 <Peaker> When teaching monads-on-the-go,  I first make sure they understand what *->* means.  Then what covariance means. Then I explain how Functor<=>covariance. Then how Functor cannot touch the "f" of "f a", just the "a". So then I add Applicative to fuse "f"s together. Then I show the restrictive nature of Applicative and add (>>=) for free "m" choice even based on value...
17:44:29 <JoeyA> I think I understand all that, but not the terminology.
17:45:13 <JoeyA> A Functor is like a box with something in it.  You can slip a function in to transform what's in it, but you can't do anything else.
17:45:22 <Cale> How do you explain covariance before explaining what a functor is?
17:45:26 <JoeyA> (of course, that "box" might have a collection of things, or even be an action returning a thing)
17:45:36 <Cale> (and having contravariant functors to compare to)
17:45:46 <cwl> class (Monad m) => MonadError e m | m -> e where
17:45:52 <cwl> instance MonadError (Either e) where
17:45:58 <JoeyA> Applicative lets you do a little more: take two boxes, apply the function in the first box to whatever's in the second box.
17:46:09 <cwl> why the instance lack of one parameter
17:46:12 <Cale> cwl: itym  instance MonadError e (Either e)
17:46:13 <JoeyA> Meh, it's be easier to just say "actions"
17:46:47 <JoeyA> Because then you can say that with Applicative, you can glue together actions, but you can't let their results influence the actions themselves.  Monad lets you do that.
17:47:20 <cwl> Cale: itym?
17:47:55 <ivanm> I think You Mean
17:48:24 <kmc> JoeyA, right.  a functor is like a box, as long as you forget everything you know about boxes and treat it as a term synonymous with "functor"
17:48:45 <bfig> how do you remove a value from a functor? you can't, right?
17:48:46 <kmc> if you pass a candy factory, do you look at it and say "wow, that's a *huge* box of candies"?
17:48:51 <bfig> without breaking the model at least
17:48:53 <kmc> bfig, not in general
17:48:57 <cwl> @src MonadError
17:48:57 <lambdabot> class (Monad m) => MonadError e m | m -> e where
17:48:57 <lambdabot>     throwError :: e -> m a
17:48:57 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
17:48:58 <kmc> you can for some specific functors
17:49:13 <shachaf> The less interesting they are the easier it is. :-)
17:49:17 <bfig> if you have a way to remove the result for a generic functor then you have a monad right?
17:49:21 <kmc> no
17:49:29 <kmc> if you have F (F a) -> F a
17:49:32 <kmc> satisfying certain laws
17:49:34 <kmc> then you have a monad
17:49:38 <kmc> or F a -> (a -> F b) -> F b
17:49:40 <shachaf> And a -> F a
17:49:46 <kmc> but i think "join" is easier conceptually
17:49:51 <Olathe> > throwError "zomg"
17:49:52 <lambdabot>   No instance for (GHC.Show.Show (m a))
17:49:52 <lambdabot>    arising from a use of `M6976802303...
17:49:59 <shachaf> kmc: CandyFactoryFactory?
17:50:07 <bfig> i think with a 'compute' operation that satisfies  compute.pure x = x you have a monad right?
17:50:25 <kmc> :t join . pure
17:50:26 <lambdabot> forall (m :: * -> *) a. (Monad m, Applicative m) => m a -> m a
17:50:43 <cwl> @type throwError "hello"
17:50:44 <lambdabot> forall (m :: * -> *) a. (MonadError [Char] m) => m a
17:51:04 <shachaf> bfig; What's "compute" supposed to be?
17:51:11 <mysticc> Can any one help with this .. if f :: (Either String a)->b->(Either String a) then how f.Right :: a->b->(Either String a)
17:51:22 <cwl> @type throwError "hello" :: (Either String Int)
17:51:23 <lambdabot> Either String Int
17:51:32 <cwl> > throwError "hello" :: (Either String Int)
17:51:33 <lambdabot>   Left "hello"
17:51:34 <bfig> shachaf, 'run the computation and return the result', basically the 'constructor inverse'
17:51:37 <kmc> no
17:51:46 <kmc> there's no (Monad m) => m a -> a
17:51:52 <kmc> just m (m a) -> m a
17:52:00 <kmc> you can unwrap two layers to one, but not one to zero
17:52:11 <blackdog> kmc: thanks heaps for that tip about Derive - i just lost about half the code in my test file. spookily easy.
17:52:20 <cwl> still dont understand instance MonadError (Either e) where
17:52:24 <bfig> mmm it is true
17:52:37 <blackdog> TH is now my BFF
17:52:50 <Olathe> mysticc: Because Right takes an a and makes a Either String a.
17:52:57 <shachaf> bfig: Think of it as a monoid on the category of endofunctors.
17:53:13 * bfig 's mind assploded
17:53:22 <shachaf> bfig: You have M * M -> M, but no M -> 1. That doesn't even make much sense.
17:53:28 <bfig> i don't know much category theory, i'm just testing the water :D
17:53:32 * shachaf wonders if he's not being helpful.
17:53:55 <Olathe> Think of it simply as a zygohistprepomorphistic endocarditisfunctor in the category of left-monadic rheofunctors without identities.
17:53:56 <bfig> shachaf, from a ct point of view you would have to have an 'invertible functor' of some sort right?
17:54:16 <kmc> bfig, is your goal here "learn a little CT" or "write better Haskell programs"?
17:54:23 <Olathe> Then, you'll be on your way.
17:54:27 <bfig> kmc, both :)
17:54:40 <kmc> they are mostly separate goals
17:54:40 <bfig> i don't think i can really do one without the other :)
17:54:48 <kmc> that's absurd
17:55:26 <kniu> whoa
17:55:35 <shachaf> bfig: No, there's no need to know any category theory for this.
17:55:37 <shachaf> For example, I don't.
17:55:37 <bfig> i don't mean you can't do one without the other, i think *i* can't do one without the otehr :p
17:55:40 * roconnor_ finds writing better Haskell programs helps him learn a little CT
17:56:22 <bfig> because i want to do both, i want to learn all the power and expressiveness of haskell and a good deal of mathematics of category theory
17:56:24 <cmccann> category theory is a useful, but entirely optional source for useful terminology when talking about things in haskell
17:56:48 <duairc> Instead of going for the VM option, I just created a large file and mkswap and swapon'd it, and cabal seems to be working now.
17:56:53 <kmc> bfig, i think you're best off treating them as separate pursuits with some interesting side connections
17:56:54 <cmccann> and haskell is a way to build some intuition for some limited bits of category theory, but is as likely to lead you astray as it is to help if you're not careful
17:57:00 <kmc> but then again, i don't know much CT
17:57:20 <shachaf> Haskell is great for learning logic.
17:57:27 <shachaf> undefined is the best axiom.
17:57:27 <kmc> mostly i'm just annoyed at all the "lol Haskell, you need 7 PhDs in monad to do hello world"
17:57:33 <kmc> on reddit etc
17:58:02 <Olathe> Wait. All these PhDs were unnecessary?!
17:58:15 <cmccann> shachaf, http://140.254.101.126/coglab/Miracle.html
17:58:32 <bfig> i want to program haskell because haskell -> cool people :)
17:59:11 <bfig> python has cool people too :)
17:59:14 <ddarius> Olathe: You got them so people would call you Doctor, right?
17:59:17 <Olathe> (Monad cool) => haskell -> cool people
17:59:46 <bfig> mmm i wanna be called Dr. Eng... at some point :)
18:00:00 <bfig> still several years ahead... =)
18:00:10 * bfig stops driving offtopic convos :)
18:00:10 <Olathe> ddarius: Heheh
18:01:08 <Peaker> bfig: The Monad class is a lot about the *lack* of an operation like "compute"
18:01:21 <cmccann> ddarius, there's other reasons for getting a phd?
18:01:45 <shachaf> cmccann: Well, you need them for monads.
18:01:56 <ddarius> cmccann: No.
18:02:14 <ddarius> cmccann: For example, they make horrible napkins.
18:02:19 <cmccann> good point.
18:02:35 <tgeeky> if you frame them, they make good breakfast-in-bed trays
18:02:49 * shachaf is sure there are other reasons.
18:03:46 <cmccann> no, the only reasons for getting any degree basically boil down to "impressing other people"
18:03:52 <tgeeky> they can be burned in small bonfires to demonstrate your vast excess of intelligence (instead of burning money to demonstrate your wealth)
18:03:55 <cmccann> the learning that typically goes with getting the degree is another matter
18:04:11 <tgeeky> cmccann: well, it used to be to learn a subject matter
18:04:44 <cmccann> learning a subject doesn't require getting a phd and I'm not certain getting a phd requires learning a subject deeply, either
18:04:54 <stribor> does function that filter takes as predicate always has to be of this type myFunction :: String -> Bool
18:05:01 <tgeeky> cmccann: i has downgraded to general degrees
18:05:07 <stribor> i mean instead of String it can be Int or any other type
18:05:38 <kmc> stribor, it can be any type; it has to match the type of the elements in the list being filtered
18:05:41 <kmc> > filter (> 7) [1..10]
18:05:42 <lambdabot>   [8,9,10]
18:05:52 <kmc> :t filter
18:05:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
18:06:05 <JoeyA> > filter (< 10) [1..]
18:06:05 <stribor> ok.kmc
18:06:09 <lambdabot>   mueval-core: Time limit exceeded
18:06:20 <stribor> yeah it has to be able to compare them i guess
18:07:18 <mgsloan> seems like getting a degree is the societally accepted way to continue focusing on learning/researching instead of focusing on creating something someone else wants (for money)
18:07:45 <kmc> it's *a* socially accepted way
18:07:56 <mgsloan> (this is particularly relevant to me.. think I'm gonna try to go for a Haskell-ey PhD )
18:08:01 * cmccann isn't convinced that most non-academic jobs have much to do with creating things that people want, either
18:08:11 <kmc> or you can get a job doing what you want anyway
18:08:21 <duairc> Once I realised that getting a degree is just to impress other people, and that I cared not for impressing other people I dropped out of college. I felt "if I drop out of college now, I'll have wasted three years of my life, but if I finish my degree, I'll have wasted four".
18:08:25 <kmc> or you can get a job that pays the bills and learn/research in your free time
18:08:37 <kmc> or you can get a job that pays the bills, save up, quit, and learn/research all lthe time
18:08:39 <mgsloan> you can try.  it's tricky, though
18:08:43 <kmc> yep
18:08:52 <mgsloan> yeah, the latter was my plan
18:08:56 <kmc> it's also tricky to be not miserable as a grad student
18:09:07 <kmc> mgsloan, what phase of education are you at now?
18:09:14 <ddarius> or you can start your own company
18:09:16 <mgsloan> entering senior year of undergrad at UW
18:10:04 <mgsloan> I've got some alright professorly contacts, but haven't done as much research as I'd like, since too much of the PL stuff is java-focused
18:10:09 <cmccann> or you can be a hobo. nice thing about math is that it doesn't require many tools
18:10:14 <kmc> yep
18:10:31 <kmc> if you're a good enough mathematician, people will let you sleep on their sofa in exchange for a co-author credit
18:10:33 <mgsloan> yeah, considering the travel-around-in-tent-minimal-budget lifestyle
18:10:39 <mgsloan> yeah, erdos mode would be fun
18:10:47 <ddarius> I don't think I did all that much math when I was a hobo, though I did have an interesting conversation with some kid considering persuing a mathematics degree.
18:10:48 <kmc> maybe you have to be erdos though ;)
18:10:54 * cmccann thinks this is time for the "erdos is not a role model" PSA
18:11:00 <kmc> haha
18:11:08 <ddarius> cmccann: What?  Every kid should be a speed freak.
18:11:08 <mgsloan> I've saved up enough money from internships to sustain a few years
18:11:22 <kmc> yeah, "homeless meth addict" is generally not a good career choice
18:11:22 <kmc> there are exceptions to anything...
18:11:32 <mgsloan> :D
18:11:46 <duairc> cmccann: That's essentially what I'm doing :D
18:11:48 <ddarius> But yeah, to pull of the Erdos thing, you kind of have to be Erdos.
18:11:59 <cmccann> actually, the amphetamines are probably the most sensible part of the whole plan
18:12:11 <cmccann> assuming enough self-discipline to not overuse them
18:12:14 <kmc> yeah, programming jobs pay well enough that, if you don't have kids or an extravagant lifestyle, you can save a lot of your paycheck
18:12:25 <kmc> (or other big expenses like medical stuff)
18:12:28 <cmccann> they're popular in high-stress professions for a reason
18:12:34 <mgsloan> ddarius - true. I'm no genius, but I think I could make good use of my time if given full control of it
18:12:52 <ddarius> mgsloan: You have full control of your time.
18:13:17 <mgsloan> true, but external influences make certain paths _much_ more convenient
18:13:22 <Nafai> kmc: no kidding.  being a developer is the main reason I'm not completely destitute because of my chronic illness
18:14:26 <gwern> @oeis 1731298478
18:14:26 <lambdabot>  Sequence not found.
18:14:33 <minsa> @unpl foldr
18:14:33 <lambdabot> foldr
18:14:38 <minsa> @src foldr
18:14:38 <lambdabot> foldr f z []     = z
18:14:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:14:44 <mgsloan> I just want to spend my 20s in a way that'll best support my development of skills and knowledge, and would rather not devote much of it to becoming a better OOP/procedural programmer
18:15:13 <kmc> better OOP programmer vs. bitter functional programmer
18:15:20 <mgsloan> kmc - too late ;D
18:15:30 <stribor> anyone here from canada
18:16:22 <kniu> @hoogle unless
18:16:22 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
18:16:37 <kniu> @hoogle Monad m => m Bool -> m () -> m ()
18:16:38 <ddarius> mgsloan: It's not just time unless you live in a commie country or have a rich daddy.
18:16:39 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
18:16:39 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
18:16:39 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
18:16:47 <BMeph> kmc: Thanks to Scala, you can be Both! :D
18:16:53 <ddarius> (And in fact, it's not just time even in those cases.)
18:17:24 <mgsloan> I've become quite religious, I'm afraid.  Though this summer at Google tempered my fervidity
18:18:29 <mgsloan> ddarius - well, my brother managed to live as a nomadic juggler/musician/magician for the majority of his 20s, so could be feasible.
18:18:52 <ddarius> mgsloan: You are completely missing my point.
18:19:03 <bfig> mgsloan, intern at google_
18:19:22 <mgsloan> bfig - aye, in fremont
18:19:28 <kmc> what did you think of Google?
18:19:32 <kmc> also, should we move this to -blah?
18:19:40 <mgsloan> sure
18:19:45 * bfig joins blah
18:19:47 <kmc> anything you say here will be read by Them
18:20:05 <Olathe> It will be stored by Them, at least.
18:20:21 <shachaf> kmc: It's not as if They don't read #-blah.
18:20:37 <BMeph> mgsloan: Busking doesn't count as "nomadic", so much as "full job, with extensive travel". :)
18:20:52 <kmc> true, just because They don't show me #-blah in the public indexing results...
18:22:00 <kmc> i guess the other main thing that sucks up a developer's paycheck is student loans
18:22:36 <mgsloan> BMeph - Hehe, true true, but he isn't exactly dilligent with finding lucrative locations
18:22:54 <ddarius> Olathe has the point.  All this claptrap about many instances of loss of privacy make the unreasonable assumption that there is someone poring over these terabytes/day streams of data.
18:24:25 <ddarius> (Which is not to say -all- the claptrap about loss of privacy is inane.)
18:47:34 <kmc> does anyone have a quasiquoter for ByteString literals in hexadecimal?
18:47:47 <kmc> i'd rather not use string literals with Char8 or IsString
18:49:46 * hackagebot hledger-chart 0.15.2 - A pie chart image generator for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-chart-0.15.2 (SimonMichael)
18:55:29 <shachaf> dpiponi works at Google now?
18:55:50 <shachaf> Ah, I guess he's gone from here.
18:58:19 <parcs> anyone know how to mitigate infinite loops when using hint's interpreter? so far, i tried using `timeout` in conjunction with `unblock` to end a computation after one second, but that doesn't seem to work. what else should i try to do?
18:58:56 <Olathe> parcs: You can perhaps keep a count of how many times you've looped.
18:59:03 <gwern> parcs: have you looked at mueval?
19:00:20 <gwern> parcs: last I knew, you *can't* kill a non-allocating loop
19:01:02 <parcs> Olathe: hint doesn't have access to that kind of information
19:01:31 <parcs> gwern: i looked at mueval but that spawns a new interpreter session for each expression (i believe). i'm trying to avoid that
19:01:38 * ddarius cocks his shotgun.
19:01:45 <gwern> parcs: yeah good luck with that...
19:02:18 <gwern> parcs: you can probably structure it to not instantiate a new Interpeter monad each time, but you can't get away with a single process
19:02:20 * cmccann is still amused to notice that Curry's original combinator basis consisted of the minimal definition of the reader monad, plus the equivalent of traverse for the reader monad over itself
19:02:59 <parcs> gwern: why not?
19:03:04 <gwern> parcs: I already said
19:03:15 <parcs> oh, that
19:04:23 <parcs> gwern: can you kill a non-allocating loop through killing its thread?
19:04:36 <gwern> parcs: nope!
19:05:05 <gwern> imagine my surprise when I found that out. 'what's the point of killing a thread if the thread can choose not do die? jumping jimmikins!'
19:05:27 <ddarius> GHC only fakes pre-emptive concurrency.
19:05:46 <parcs> heh, i should've known better than try to improve on an algorithm that has been tested and worked on for 7 years (mueval/lambdabot)
19:06:00 <cmccann> by sticking "pre-emption" in when something allocates memory
19:06:14 <ddarius> I'm pretty sure mueval isn't 7 years old.
19:06:25 <parcs> lambdabot is
19:06:35 <ddarius> I'm pretty sure even the GHC API as an externally usable interface is 7 years old.
19:06:35 <cmccann> @vixen how old are you?
19:06:35 <lambdabot> You won't have Nixon to kick around anymore, because, gentlemen, this is my last press conference.
19:06:36 <kmc> i thought even a non-allocating Haskell thread could be preempted... what are RTS options -C and -V for otherwise?
19:07:26 <ddarius> kmc: It certainly can by other process level threads.
19:07:31 <shachaf> kmc: I think it'll only get preempted if it allocates or is on an OS thread that gets preempted.
19:07:38 <ddarius> s/interface is/interface isn't/
19:08:29 <ddarius> Did @vixen say something that upset someone?
19:08:50 <parcs> 19/f/florida, i believe it was
19:08:57 <shachaf> @vixen is @nixon now?
19:08:57 <lambdabot> Voters quickly forget what a man says.
19:09:07 <kmc> OS thread that gets preempted by the OS scheduler?
19:09:19 <kmc> i don't think GHC will even notice that
19:09:22 <shachaf> @vixen-on
19:09:23 <lambdabot> Unknown command, try @list
19:09:27 <shachaf> Huh.
19:09:39 <Axman6> someone complained about the vixen quote about 'girls masterbat too, ya know'
19:10:01 <cmccann> nice
19:10:33 <kmc> ah "A context switch will occur at the next heap block allocation after the timer expires (a heap block allocation occurs every 4k of allocation)"
19:10:34 <dainanaki> i've only mastered rodents so far.
19:10:36 <monochrom> vixen is gone. bearing in mind the edit-distance-2 auto-correction, you get nixon. just like...
19:10:40 <monochrom> @ship monochrom
19:10:40 <lambdabot> Maybe you meant: show slap
19:10:45 <monochrom> darn
19:10:51 <cmccann> heh
19:10:55 <monochrom> @slit monochrom
19:10:56 <lambdabot> Maybe you meant: elite let list quit slap
19:11:01 <monochrom> I fail!
19:11:38 <cmccann> @slop monochrom
19:11:38 <monochrom> @snap monochrom
19:11:38 <lambdabot> I don't perform such side effects on command!
19:11:38 * lambdabot beats up monochrom
19:11:38 <dainanaki> @elite ian
19:11:38 <lambdabot> IaN
19:11:38 <shachaf> @botsnake
19:11:38 <lambdabot> :)
19:11:38 <dainanaki> @botsnoke
19:11:38 <lambdabot> Unknown command, try @list
19:11:38 <dainanaki> :/
19:11:53 <monochrom> remember, edit distance 2
19:12:05 <Olathe> @botsnack
19:12:05 <lambdabot> :)
19:12:06 <monochrom> @let monochrom = ()
19:12:07 <lambdabot>  Defined.
19:12:10 <monochrom> > monochrom
19:12:12 <lambdabot>   ()
19:12:21 <shachaf> @let type monochrom = () :: Constraint
19:12:24 <lambdabot>   Illegal test declaration
19:12:27 <dainanaki> Isn't the edit distance of botsnoke just 1?
19:12:28 <monochrom> this is also why if you mistype that as...
19:12:38 <monochrom> @define fff x = x
19:12:41 <shachaf> dainanaki: No, 3.
19:12:43 <monochrom> then you get...
19:12:45 <monochrom> > monochrom
19:12:49 <lambdabot>   Not in scope: `monochrom'
19:12:55 <Olathe> dainanaki: a -> o, c -> k, k -> e
19:13:03 <shachaf> monochrom: @define -> @undefine :-)
19:13:04 <monochrom> because "undefine" and "define" are edit distance 2
19:13:06 <dainanaki> ah
19:13:08 <shachaf> Oh.
19:13:13 <dainanaki> @botsnock
19:13:13 <lambdabot> :)
19:13:14 <shachaf> That was the point.
19:13:29 <monochrom> so basically...
19:13:33 <monochrom> @unslap monochrom
19:13:34 * lambdabot loves monochrom, so no slapping
19:13:38 <monochrom> eh?!
19:13:47 <shachaf> @unslap monochrom
19:13:47 <lambdabot> *SMACK*, *SLAM*, take that monochrom!
19:13:49 <dainanaki> @reslap dainanaki
19:13:49 * lambdabot will count to five...
19:13:55 <monochrom> ok that's better
19:13:59 <shachaf> #haskell-blah
19:14:16 <shachaf> @join #haskell-blah
19:14:16 <lambdabot> Not enough privileges
19:14:21 <dainanaki> @botsnarf
19:14:21 <lambdabot> :)
19:14:48 <cmccann> @bootshack
19:14:48 <lambdabot> :)
19:14:52 <dainanaki> Now all I'm going to want to do is come up with weirder names for commands.
19:16:00 <minsa> foldr (flip (+)) z [a, b, c]  is equal to  foldr (+) [a, b, c] z   ?
19:16:10 * cmccann still thinks that was a dumb reason to turn off @vixen, but eh
19:16:12 <monochrom> no
19:16:23 <dainanaki> @vixen
19:16:23 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
19:16:44 <dainanaki> I think I'm still going to pretend it's a 19 year old girl saying these quotes.
19:17:51 <Eduard_Munteanu> Heh.
19:17:52 <Olathe> Haha
19:18:16 <Jafet> Now we just have to golf vixen in @let.
19:18:34 <dainanaki> @xen
19:18:34 <lambdabot> Maybe you meant: let run wn
19:18:44 <Eduard_Munteanu> I'd be ok if @nixon was interactive
19:18:45 <blackdog> dainanaki: there are some really disturbing quotes in there
19:18:54 <dainanaki> @nixon
19:18:54 <lambdabot> I am not a crook.
19:19:08 <minsa>  > foldr (clip (+)) z [a,b,c]
19:19:13 <dainanaki> Nixon was a really disturbing president, so that's not too surprising.
19:19:23 <minsa> > foldr (clip (+)) z [a,b,c]
19:19:23 <lambdabot>   Not in scope: `clip'
19:19:26 <Eduard_Munteanu> No, I mean like @vixen used to interpret language
19:19:28 <minsa> > foldr (flip (+)) z [a,b,c]
19:19:28 <Eduard_Munteanu> Oh, heh.
19:19:30 <lambdabot>   z + c + b + a
19:19:42 <minsa> > foldr (+) z [a,b,c]
19:19:42 <lambdabot>   a + (b + (c + z))
19:19:46 <Olathe> Nixon was too dull to interpret language, so it's accurate.
19:19:50 <blackdog> heh. i mean in @vixen... i think the original page and VB app disappeared a while ago, i'm kinda glad i grabbed the enormous list of weirdness.
19:19:56 <minsa> > foldr (+) [a,b,c] z
19:19:57 <lambdabot>   Couldn't match expected type `[[SimpleReflect.Expr]]'
19:19:57 <lambdabot>         against infer...
19:20:44 <dainanaki> @eliza
19:20:44 <lambdabot> Say again?
19:21:16 <minsa> foldl (+) z [a,b,c]
19:21:19 <Nimatek> Does lambdabot need any secret rituals before it can be built from cabal?
19:21:21 <minsa> > foldl (+) z [a,b,c]
19:21:21 <lambdabot>   z + a + b + c
19:21:44 <dainanaki> Nimatek: the s
19:21:44 <dainanaki> 
19:21:45 <dainanaki> 
19:21:46 <minsa> ic.
19:21:48 <dainanaki> yes
19:21:55 <int80_h> can I use phantom types to make a data type look like type Exception?
19:23:16 <Nimatek> dainanaki: Please impart that dark knowledge upon me.
19:23:35 <Eduard_Munteanu> @eliza hi there
19:23:36 <lambdabot> Hi ThERE
19:23:39 <Eduard_Munteanu> Bah.
19:24:01 <Eduard_Munteanu> An eliza-like bot would be nice.
19:24:01 <Olathe> @. eliza nixon
19:24:01 <lambdabot> Plugin `compose' failed with: Unknown command: "eliza"
19:24:22 <Olathe> @. elite nixon
19:24:22 <lambdabot> 7|-|EY'RE NO7 like Uz. t|-|3y $me|| Diff3reNt, thEY 10Ok dIfF3r3nt, T|-|ey AC+ dIphfEr3n+. +HE 7rOuB13 Is, you cAn'+ phiNd ONE 7hat'$ h0n3S7.
19:25:00 <dainanaki> Nimatek: the main issue is that the dependencies are really out of date. You might be able to cabal unpack it and then change the dependencies… maybe.
19:25:53 <Nimatek> dainanaki: Hmm, I might look into that tomorrow, after I had some sleep.
19:26:01 <dainanaki> Well, you can definitely unpack it. It's more of a question of whether it will still build afterwards.
19:26:10 <aavogt> int80_h: are you using the old Control.Exception? The newer one has a class for exceptions
19:26:46 <minsa> foldr (+) z [a,b,c]
19:26:51 <minsa> > foldr (+) z [a,b,c]
19:26:51 <lambdabot>   a + (b + (c + z))
19:28:24 <int80_h> aavogt: I just discovered the newer one. I'm trying to use catchJust and having difficulty defining the exception predicate. I've made a custom data type, that is an instance of Exception. Still, I'm doing something wrong.
19:28:58 <aavogt> @hoogle catchJust
19:28:58 <lambdabot> Control.Exception catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
19:28:59 <lambdabot> Control.OldException catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
19:28:59 <lambdabot> Control.Exception.Base catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
19:29:04 <minsa> > foldl (+) z [a,b,c]
19:29:05 <lambdabot>   z + a + b + c
19:29:26 <int80_h> aavogt: I was trying to solve this on my own, but I can show you the broken code if you like
19:29:44 <Oxfaded> whats the name of the Data declaration style where you use { val :: Type } to specify getters?
19:30:11 <aavogt> named fields or (sort of misleadingly) records
19:30:25 <int80_h> aavogt: named fields
19:30:43 <int80_h> I'll hpaste
19:31:37 <Oxfaded> thanks
19:32:48 <joe6> i am not able to get a file running with runghc whereas it runs with ghci -Wall: http://codepad.org/MQqcYg0q
19:33:05 <Nimatek> Mhh it's Plugin.Pl.Common that doesn't build.
19:33:20 <joe6> is there a difference between how ghci runs vs how runghc works?
19:33:39 <JoeyA> Here's a quick hack that makes cabal install list licenses of all dependencies, if anyone's interested: http://hpaste.org/51316
19:34:14 <int80_h> aavogt: I've gotten myself way confused. I know why my code is broken but I cannot write what I want
19:34:34 <hpaste> bfig pasted “weird error” at http://hpaste.org/51317
19:34:36 <int80_h> aavogt: I'll post the data type I an trying to work with
19:35:11 <bfig> isn't the first argument anything? why is it giving me a type error? :|
19:36:46 <hpaste> int80_h pasted “trying to build an exception predicate for catchJust” at http://hpaste.org/51318
19:37:51 <bfig> ahh i get it... nevermind.
19:39:10 <int80_h> aavogt: did you get a chance to look at my hpaste?
19:39:46 * hackagebot pec 0.1 - pec embedded compiler  http://hackage.haskell.org/package/pec-0.1 (BrettLetner)
19:39:52 <int80_h> wanted something like > jobExceptions :: Exception -> Maybe JobException
19:41:57 * ddarius pulls out his shotgun again.
19:42:37 <aavogt> int80_h: no, that's wrong
19:42:54 <joe6> can anyone help me with loading static libraries with ghc? "ghci -Wall" works, but I cannot get "runghc" to work. Can anyone please help?
19:43:07 <joe6> error : http://codepad.org/MQqcYg0q
19:43:25 <int80_h> aavogt: my understanding was I would have to catch all Exceptions, and return a Just x where x was the type I wanted, Nothing for anything else.
19:43:34 <aavogt> you should have something like      catchJust (\x -> case x of PreProcessFail -> Nothing; _ -> Just ())
19:44:07 <aavogt> if you want to catch all exceptions you have to catch   SomeException
19:44:44 <ivanm> that's usually recommended against though
19:44:49 <ivanm> as it will even catch C-c
19:45:06 <int80_h> I was confused about what catchJust wanted from the predicate
19:45:22 <cmccann> just catch all exceptions, then ignore them. it's the industry-proven way
19:45:55 <ivanm> cmccann: heh
19:46:07 <cmccann> none of this ivory-tower error handling stuff
19:46:22 <int80_h> aavogt: If I return Nothing upon catching PreProcessFail, then PreProcessFail dissapears right?
19:46:25 <ivanm> @remember cmccann [on using SomeException] just catch all exceptions, then ignore them. it's the industry-proven way
19:46:25 <lambdabot> I will never forget.
19:46:29 <int80_h> that's the opposite of what I want
19:46:38 <aavogt> I dunno, you can read the docs on catchJust
19:46:55 <int80_h> I have been, okay thanks :)
19:47:15 * Cale envisions a 'catch' wearing a Scumbag Steve cap.
19:47:41 <Cale> "Catch every exception, ignore them all"
19:48:33 <minsa> so in foldr the accumulator has the requirement to stay on the right hand side of the binary function ?
19:48:57 <kmc> scumbag address space, maps a page of zeros at zero
19:49:00 <ivanm> Cale: stop giving people ideas! :p
19:49:44 <kmc> actually in a lot of industry code, the norm is not to ignore errors but to fail hard and quickly
19:49:56 <ddarius> That's the thing to do.
19:50:00 <kmc> because your service will need the ability to auto-restart anyway
19:50:14 <kmc> and it's better to restart from a clean state than to try to fix up and continue with some inconsistent state
19:50:19 <ivanm> kmc: and who cares why it failed? (i.e. no logging or anything)
19:50:26 <Olathe> on error goto explode
19:50:42 <ddarius> Writing no error catching code is less effort than writing error catching code that swallows the errors.
19:50:51 <cmccann> yeah, ignoring errors is about the worst possible thing
19:50:58 <cmccann> either handle them correctly or fall over on the spot
19:51:10 <aavogt> no, hyperbole is the worst possible thing
19:51:35 <Olathe> Hyperbole is so bad, it's caused all the problems in the world.
19:51:43 <cmccann> meh, hyperbole is okay. it's nothing special.
19:53:04 <monochrom> this is why in haskell we don't use exceptions for pure code
19:53:18 <monochrom> we just go, "let it be, let it be, let it be, let it be"
19:53:40 <cmccann> > div 0 0
19:53:41 <lambdabot>   *Exception: divide by zero
19:53:57 <ddarius> Que sera sera
19:54:05 <blackdog> need a division monad
19:54:16 <blackdog> that certainly wouldn't be unbelievably annoying
19:54:24 <dolio> Na na na na na na na, na na na na.
19:55:57 * cmccann has some code with a Maybe-style wrapper for numbers that swallows exceptions from pure code and converts them into a NaN value
19:56:46 <Olathe> > let div' 0 0 = round (0.0/0.0); div' n 0 = round (fromIntegral n/0.0); div' n m = div n m in div 5 0
19:56:47 <lambdabot>   *Exception: divide by zero
19:56:53 <kmc> is a division monad like a division ring
19:56:59 <Olathe> That's unpossible!
19:57:20 <Olathe> > let div' 0 0 = round (0.0/0.0); div' n 0 = round (fromIntegral n/0.0); div' n m = div n m in div' 5 0
19:57:21 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
19:57:30 <Olathe> There we go! No exceptions!
19:57:33 <monochrom> hehe
19:57:43 <Jafet> @quote and.beyond
19:57:43 <lambdabot> identity says: "To " ++ (show $ log (2^1024)) ++ " and beyond!"
19:58:12 <monochrom> > show $ log (2^1024)
19:58:13 <lambdabot>   "Infinity"
19:58:26 <monochrom> neato
19:58:30 <Olathe> Haha
20:00:04 <cmccann> > (2^1024) :: Double
20:00:05 <lambdabot>   Infinity
20:00:27 <parcs> what is the cutoff?
20:00:42 <Jafet> > log $ 2^1023
20:00:43 <lambdabot>   709.0895657128241
20:01:18 <parcs> can computers really calculate log (2^1023) that fast
20:01:31 <Jafet> > 1023 * log 2
20:01:32 <lambdabot>   709.0895657128241
20:01:37 <Jafet> Yes.
20:01:47 <Jafet> Computers are very fast.
20:02:04 <Jafet> > log (2^1024) :: CReal
20:02:04 <lambdabot>   709.7827128933839968432456923731728057093121
20:02:39 <ddarius> It takes a long time to write 1545 into a few bits of memory.
20:02:48 <ddarius> Oops, 1535.
20:03:17 * parcs investigates some stuff
20:03:28 <kmc> @let ꙮ = 0.0/0.0
20:03:28 <lambdabot>   Illegal character ''\42606''
20:03:36 <cmccann> pf
20:03:49 <Jafet> @define
20:04:01 <Jafet> > generalCategory 'ꙮ'
20:04:02 <lambdabot>   OtherLetter
20:04:08 <cmccann> @let (☃) = 0/0
20:04:09 <lambdabot>  Defined.
20:04:15 <int80_h> my confusion was due to a typo in RWH
20:04:19 <int80_h> whew
20:04:40 <int80_h> err, outright erroneous code. It's fixed on the web site.
20:04:53 <kmc> heh
20:04:54 <kmc> which code?
20:05:12 <int80_h> catchIT
20:05:18 <int80_h> catchIt
20:05:33 <int80_h> http://book.realworldhaskell.org/read/error-handling.html
20:05:47 <int80_h> totally confused me about what a exception predicate was supposed to do
20:06:32 <shachaf> I think that's old, not wrong.
20:06:45 <int80_h> I was putting together this elaborate comparison between my code (copying RWH) and saying "hey this is logically like catchIt, why it fail? Then it occured to me I never actually tried to run the book code and it could be wrong.
20:07:22 <int80_h> it's using COntrol.Exception, not Control.OldException
20:08:41 <int80_h> well Ima go fix things and breath a sigh of relief.
20:10:39 <kmc> int80_h, yeah, Control.Exception got renamed to Control.OldException at some point (as you might guess from the names)
20:10:46 <kmc> I guess your copy of RWH predates that
20:10:53 <kmc> so it's not an error per se
20:11:34 <int80_h> kmc: I bought it as soon as it was printed. That was an exciting day :)
20:11:34 <kmc> do they assert which GHC version the code should work on?
20:11:34 <kmc> :)
20:11:35 <int80_h> kmc: hmm, they might. I will look closely.
20:12:37 <kmc> i'd love to see a sequel to RWH
20:12:41 <kmc> with lots of advanced topics
20:12:46 <kmc> i loved the topics chapters of RWH
20:13:17 <monochrom> it can be named Imaginary World Haskell :)
20:13:20 <huh> [1..]
20:13:35 <huh> >[1..]
20:13:35 <int80_h> kmc: What if we assault the authors with massive buckets of money? Do you think they would succumb and write a sequel?
20:14:56 <int80_h> Haskell CookBook : Chapter 1 DSLs
20:15:26 <int80_h> maybe cookbook is the wrong word
20:16:03 <Olathe> Monads are like ovens.
20:16:24 <int80_h> no they aren't. Where have you been! They're like spacesuits now.
20:16:25 <ddarius> Exercise: What does "bake" mean?
20:16:48 <Olathe> Haha
20:17:08 <Olathe> bake :: Monad m => a -> m a
20:17:32 <blackdog> monochrom: it's complex
20:17:39 <ddarius> My exercise is serious.
20:17:42 <Olathe> bake :: Monad oven => food -> oven food
20:17:44 <kmc> they should call it real++ world++ haskell++
20:17:58 <kmc> in high school we used a text called "C++ for You++"
20:18:00 <Olathe> succ $
20:18:09 <monochrom> hahaha
20:18:11 <Olathe> succ $ Real World Haskell
20:18:31 <parcs> so it seems that x^n takes log n multiplications... genius!
20:18:40 <monochrom> it's hard to live up to the name Complex World Haskell
20:18:59 <int80_h> baZing!
20:19:00 <monochrom> while Imaginary World Haskell is much easier if you throw in enough category theory!
20:19:37 <ddarius> parcs: If it was genius it would have type (^) :: Monoid m => m -> Natural -> m
20:19:46 <Jafet> RealWorld Haskell
20:19:59 <Jafet> ddarius: that would make golfing horrible
20:20:05 <Jafet> Littered with Product everywhere
20:20:24 <parcs> > x ^ 5 :: Expr
20:20:24 <lambdabot>   x * x * (x * x) * x
20:20:26 <Jafet> It's bad enough that fromIntegral is so long
20:20:41 <ddarius> @let fI = fromIntegral
20:20:42 <lambdabot>  Defined.
20:20:43 <Jafet> @src (^)
20:20:43 <lambdabot> x ^ 0            =  1
20:20:43 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
20:20:43 <lambdabot>   where f _ 0 y = y
20:20:43 <lambdabot>         f x n y = g x n
20:20:44 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
20:20:46 <lambdabot>                       | otherwise = f x (n-1) (x*y)
20:20:48 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
20:20:57 <KirinDave> Oh fudge.
20:21:00 <parcs> > x ^ 256 :: Expr
20:21:00 <lambdabot>   x * x * (x * x) * (x * x * (x * x)) * (x * x * (x * x) * (x * x * (x * x)))...
20:21:01 <Jafet> Acc!
20:21:03 <KirinDave> I had this wonderful idea for my ircbot
20:21:09 <parcs> hey that's not log n
20:21:16 <Olathe> > gcd 0 0 -- eeevil
20:21:18 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
20:21:19 <KirinDave> And I think, under the cold light of writing out the types
20:21:27 <KirinDave> That my idea was ridiculous.
20:21:34 <parcs> wait it probably is due to cse
20:21:44 <ddarius> Types: Killing Dreams Since 1909
20:21:47 <Olathe> Haskell: the wonderful idea killer.
20:23:45 <KirinDave> I wanted to use the list monad to model responders to IRC messages.
20:24:01 <KirinDave> It's so nice, because then actions could either keep themselves around or introduce new independent responders.
20:24:45 <KirinDave> But, I don't think that I can actually do this unless I ditch a StateT for a ReaderT full of TVars.
20:25:02 <realitygrill> so anyone use the Haskell Road to Logic, Maths, and Programming?
20:27:03 * ddarius considers making an or-parallel monad.
20:29:35 <parcs> is it possible to implement recursion with callCC?
20:29:35 <parcs> i know it's possible in less-typed languages
20:30:08 <parcs> @ping
20:30:08 <lambdabot> pong
20:31:38 <kmc> how do you do it in other languages parcs?
20:32:34 <parcs> kmc: you return the continuation that was given to you, call it later
20:32:54 <parcs> http://stackoverflow.com/questions/2459116/can-continuations-be-used-as-a-replacement-for-recursion
20:33:44 <kmc> "On my machine, which does tail-call optimization by default"
20:33:47 <kmc> man, i gotta buy one of those
20:33:54 <parcs> they are pricey
20:34:03 <KirinDave> kmc: Watch this, this is me being charitable
20:34:06 <int80_h> so I'd like to write something like catchIt from RWH, where all execptions would be evaluated, but only the exceptions I pattern match against return a Just (). Is that possible using catchIt as a model or is that in reference to the old way?
20:34:10 <KirinDave> kmc: Maybe he meant virtual machine?
20:34:26 <kmc> heh
20:34:35 <kmc> i just thought it was funny wording, not obviously wrong
20:35:18 <joe6> can anyone help me with loading static libraries with ghc? "ghci -Wall" works, but I cannot get "runghc" to work. Can anyone please help?
20:35:31 <joe6> error : http://codepad.org/MQqcYg0q
20:35:59 <joe6> ghci works but not runghc or runhaskell
20:38:56 <parcs> joe6: try the latest version of ghc?
20:39:30 <joe6> parcs, the library and the symbol that it is compiling is my own. I am using ffi to generate the bindings
20:39:46 <joe6> .with ghci, it loads the static libaries and everything works fine.
20:39:49 <Oxfaded> is there a shortcut for fromInteger . toInteger ?
20:40:06 <joe6> but with runghic, it cannot seem to load static libraries.
20:40:15 <Jafet> @src fromIntegral
20:40:15 <lambdabot> fromIntegral = fromInteger . toInteger
20:40:16 <joe6> parcs, does that make sense?
20:40:30 <Jafet> That was a weird question..
20:41:18 <parcs> joe6: yeah
20:43:25 <Oxfaded> Jafet: touche
20:44:19 <Chondricthyes> window 2
20:47:42 <freeasjesus> Hi I have a quick questions. Say my girlfriend is a mathematician but knows nothing of computers, but still would like me to introduce a programming language to her. Would Haskell fit well here? As in a good programming language coming from a maths background?
20:48:37 <Olathe> What sort of mathematician?
20:48:52 <freeasjesus> I don't know, just good at maths.
20:49:05 <parcs> joe6: in `runghc -Wall TestUsbUtility.hs ../../staging/usb_utility.linked.o ../../staging/usb_initialize.o` the last two arguments are treated as arguments to your script TestUsbUtility.hs
20:49:10 <KirinDave> freeasjesus: Mathlab, maybe?
20:49:28 <freeasjesus> KirinDave: Isn't that a piece of software? Is it also considered a programming language?
20:49:44 <parcs> thus the object files never get loaded and you end up with unknown symbol error
20:49:52 <Olathe> Haskell's not bad if you like the abstractions.
20:49:55 <joe6> parcs, they are. ok, cool. thanks a lot.
20:50:06 <KirinDave> freeasjesus: It's a toolkit for math, so basically it's a language for doing math.
20:50:09 <Olathe> If she's more into numerical stuff, maybe something else.
20:50:45 <freeasjesus> Olathe: any suggestions if not Haskell?
20:51:03 <dolio> Do you mean matlab?
20:51:23 <KirinDave> Sorry, yeah
20:51:28 <dolio> Because I don't think that's an ideal language for a mathematician, really.
20:51:31 <joe6> parcs, this is what it says now: http://codepad.org/wIC3kS9f
20:51:32 <Olathe> freeasjesus: I like Mathematica, but I haven't used too much of anything, so I can't really compare it to anything.
20:51:44 <Olathe> freeasjesus: I hear people are doing numerical stuff with Python these days.
20:52:07 <Olathe> freeasjesus: If she wants to make normal programs rather than just get numerical results.
20:52:09 <KirinDave> Ugh. Python. :(
20:52:28 <parcs> joe6: now ../../staging/usb_utility.linked.o  is being treated as a script which it is obviously not
20:52:57 <freeasjesus> Alright thanks for the replies. And to kind of flip it around a bit for my case: Would Haskell be an alright language for learning a bit about maths for someone who never did high-school maths and only knows maths from CompSci degree programming concepts?
20:53:00 <dolio> Matlab is more for numerical analysis and stuff. I think it's more popular for engineering and scientific computing.
20:53:00 <parcs> runghc is a simple wrapper that calls ghc. you'll have to find a way to tell ghc to load certain object files (a flag perhaps)
20:53:21 <joe6> parcs, i get that. that is what I am trying to figure out.
20:53:35 <joe6> parcs, thanks a lot, will see if I can hack runghc.
20:53:44 <joe6> parcs:  thanks for your guidance.
20:53:52 <Olathe> freeasjesus: Haskell is not bad if you want to get into abstract stuff.
20:54:26 <freeasjesus> Olathe: what is abstract stuff from a programming point of view? I'm sure you're not talking about OO-type abstraction
20:55:48 <shachaf> freeasjesus: If you want to learn mathematics the best way to go about it is probably to learn mathematics. :-)
20:56:06 <Olathe> freeasjesus: Oh, I mean like abstract math: you don't deal with numbers in particular, but with more general abstractions.
20:56:07 <freeasjesus> shachaf: such as matlab?
20:56:19 <shachaf> Haskell will let you express some things more nicely than other languages, but it can only get so far.
20:56:30 <KirinDave> Although
20:56:37 <shachaf> freeasjesus: ...No, such as actual mathematics from a book. I would presume.
20:56:37 <KirinDave> The idea of teaching someone from square one in a functional world?
20:56:40 <KirinDave> A good idea.
20:56:49 <shachaf> freeasjesus: Are you talking about numerical calculations or something like that?
20:57:00 <joe6> parcs: probably beter of just doing ghc --make ../../staging/usb_utility.linked.o ../../staging/usb_initialize.o TestUsbUtility.hs and then ./executable
20:58:02 <freeasjesus> shachaf: just mathematical concepts. Such as I understand them completely in programming but when it comes to looking at a mathematical formula I cannot understand it in the slightest. Eg, recursion in an imperitive language vs proof mathematically
20:58:04 <ddarius> shachaf: When I'm hungry, I always stab myself in the thigh.  I figure that will resolve it.
20:59:03 * shachaf is unable to figure out this ddarius riddle.
20:59:37 <parcs> joe6: yeah, that's easier and more efficient
21:14:32 <int80_h> now that ChanServ has been dealt with, I can initiate my particular brand of Marxist revolution.
21:14:56 <ivanm> int80_h: too late!
21:14:57 <int80_h> dammit!
21:15:13 <ddarius> Back to being page slaves.
21:17:40 <int80_h> after forgetting completely RWH and sticking exclusively to the official docs, I think I've got my solution. So much easier than I was imagining.
21:46:23 <dthurn> I'm having trouble installing a ghc-7.0.3 binary on a debian system. I get "libgmp.so.3: cannot open shared object file: No such file or directory" after ./configure. Help?
21:47:07 <c_wraith> install gmp
21:47:24 <shachaf> apt-get install libgmp3-dev
21:47:39 <parcs> you have a newer version of gmp
21:47:52 <dthurn> I have libgmp
21:47:53 <dthurn> "libgmp3-dev is already the newest version."
21:48:50 <dthurn> parcs: ? my version of libgmp is too new or something?
21:49:04 <parcs> i assume so
21:49:08 <parcs> at least that's my case
21:49:42 <parcs> libgmp 5 is out, which introduces an so version bump. libgmp 4 is what the binary is linked againts
21:51:28 <dthurn> Well crap. I guess I can try to build ghc from source with the ghc6 package from debian.
21:56:36 <ddarius> Get hbc and bootstrap from the beginning.
22:01:36 <kmc> No instance for (Lift Word8)
22:01:44 <kmc> doing some TH
22:01:54 <kmc> should i just orphan-define it and be done?
22:03:20 <freeasjesus> Any of you gentoo or OS X users?
22:06:37 <kmc> ok, looks like i can just lift [Int] instead of [Word8] and the literals are polymorphic ;P
22:09:26 <Enigmagic> freeasjesus: i use gentoo and OSX
22:09:47 * hackagebot persistent-mongoDB 0.6.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.6.2 (GregWeber)
22:11:52 <freeasjesus> Enigmagic: Apart from the similarities, what do you like about each for Haskell and why?
22:12:04 <Enigmagic> osx is good on a laptop
22:12:05 <Enigmagic> :-)
22:12:34 <Enigmagic> haskell it's pretty much the same for me... i don't do any graphics though
22:12:58 <Enigmagic> gentoo's haskell-updater works well if you use emerge for package management
22:13:20 <Enigmagic> (rebuilds dependencies if you break them, unlike cabal-install)
22:13:50 <freeasjesus> Enigmagic: Would you say that gentoo is faster for Haskell as everything is compiled to specification
22:13:50 <freeasjesus> ?
22:13:57 <Axman6> freeasjesus: i doubt there's much differences between the two, but sometimes strange things happen on OS X because there are less devs working on the OS X version
22:14:08 <Axman6> but it's still a great OS to do haskell work with
22:14:36 <kmc> i thought they totally broke GHC in Lion
22:14:36 <Enigmagic> freeasjesus: well i'd say the haskell compiler generates the same code either way, except for differences in the runtime (particularly around the I/O manager) between linux and osx
22:15:11 <Enigmagic> kmc: we're all running lion (well, except me) with no problems.. originally on 7.0.3 and now with 7.2.1
22:15:23 <Enigmagic> i'm still on snow leopard with 7.2.1
22:33:40 <wavewave> hi.
22:34:26 <wavewave> what is the best way to include some other language's source file in cabal package?
22:35:01 <wavewave> I just want cabal to compile the file with appropriate compiler and link it to my haskell library.
22:35:58 <wavewave> I know that there is a standard way using configure/make/make install but this is too much for me for adding only one file.
22:36:22 <wavewave> the source file is in fortran.
22:36:28 <wavewave> :-(
22:39:16 <Enigmagic> wavewave: might try a custom setup hook
22:39:18 <Enigmagic> http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Distribution-Simple-UserHooks.html
22:40:12 <wavewave> Enigmagic: thnx, actually I am now doing that but cannot figure out how to add xxx.o file to the link option.
22:40:51 * wavewave is reading http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs
22:41:02 <Enigmagic> wavewave: not sure on that one, i use a post-conf hook to generate haskell code
22:42:26 <wavewave> Enigmagic: in the EZYang's blog, he seems to use the preConf and copyHook hooks.
22:42:50 <wavewave> preConf for compilation and copyHook for copy resultant .a file.
22:43:05 <wavewave> building .a file is not a big deal.
22:44:41 <Enigmagic> wavewave: have you tried adding the object file in the ld-options ?
22:45:24 <Enigmagic> or extra-libs (if you have a .a or .so)
22:45:59 <wavewave> Enigmagic: I didn't try ld-option but I tried extra-libs. The problem is how I can know where the compiled library file will be located.
22:46:49 <Enigmagic> wavewave: specify an output path to the fortran compiler?
22:47:45 <wavewave> Enigmagic: that sounds right.. I can use some system temporary directory.
22:48:00 <Enigmagic> wavewave: i use "autogenModulesDir", which i think is defined in Cabal somewhere
22:49:05 <Enigmagic> http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Distribution-Simple-BuildPaths.html#v:autogenModulesDir
22:49:54 <wavewave> Enigmagic: that's great! That's the info I want to have. Thanks!
22:51:04 <Enigmagic> wavewave: np, hope you get it sorted out :-)
22:52:37 <wavewave> Cabal gets better and better.. I would like to use cabal for other language build system and I think that's quite possible.
22:52:57 <Axman6> i see you haven't been using cabal for very long :P
22:54:26 <wavewave> Axman6: I just compare the documents a few years ago with current documents.. looks like progress is constantly being made.
22:55:38 <Axman6> there's still some pretty fundamental problems. but i think they're problems that most package managers have (like the butterfly problem)
22:56:33 <wavewave> Axman6: yeah.. that always bites me.. Mostly this became a big deal for haskeller since we are publishing so many small nice libraries.
22:56:46 <Axman6> yeah
22:58:31 <wavewave> Axman6: but once I understood what's going on, the problem is not so serious as before. I think  a kind error message must be the first for newbies.
22:59:10 <wavewave> inadvertantly upgrading a package causes a real panic to a newbie.
23:00:21 <Axman6> @bf ++++++++++[>+++++++++>++++++++++>+++++++++++<<+++++>+++++>++++++++.—.++++.<+++++.>—.-.
23:00:21 <lambdabot>  Done.
23:00:24 <Axman6> :\
23:00:33 <wavewave> if some warning message or small confirmation step is added for some dangerous procedure, then it will reduce lots of psychological uncomfortableness.
23:00:44 <wavewave> Axman6: what's that?
23:01:03 <Axman6> the title of a blog, but it doesn't seem to do anything...
23:01:14 <ddarius> The real way to increase usability and reduce discomfort is to provide an easy undo mechanism.
23:01:50 <ddarius> @bf probably doesn't work.
23:01:50 <lambdabot>  Done.
23:02:03 <binsh> {h(Z,a) = h (G(X,b),V } --> {h(Z,a) --> h(G(X,b),V) } does that seem correct?
23:02:04 <wavewave> ddarius: yes, I totally agree.
23:02:14 <shachaf> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
23:02:15 <lambdabot>   >
23:02:18 <AtnNn> Axman6: the '[' has no matching ']'
23:02:22 <wavewave> some system similar to NixOS ?
23:02:47 <Axman6> http://viswanathgs.wordpress.com/ was the blog for those interested...
23:03:30 <wavewave> is it in language brainfuck?
23:04:09 <wavewave> http://en.wikipedia.org/wiki/Brainfuck
23:04:14 <Axman6> yes
23:04:47 * hackagebot typelevel-tensor 0.1.0.1 - Tensors whose ranks and dimensions type-inferred and type-checked.  http://hackage.haskell.org/package/typelevel-tensor-0.1.0.1 (TakayukiMuranushi)
23:04:59 <wavewave> can lambdabot understand brainfuck?
23:05:07 <Axman6> yes
23:05:18 <wavewave> @bf means brainfuck.. I see.
23:05:18 <lambdabot>  Done.
23:05:41 <wavewave> sorry. not asking you, lambdabot
23:06:12 <ddarius> @bf +++++++++++++++++++.
23:06:13 <lambdabot>  Done.
23:06:30 <osfameron> what did it do?
23:07:16 <Axman6> > ord 'a'
23:07:17 <lambdabot>   97
23:07:51 <Axman6> @. bf run text ((replicate 97 '+') ++ ".")
23:07:53 <lambdabot>   KKK
23:07:59 <Axman6> o.O
23:08:04 <Axman6> that... um... am i going to hell?
23:08:16 <QinGW> @show 'a'
23:08:16 <lambdabot> "'a'"
23:08:20 <osfameron> ah
23:08:35 <Axman6> > text ((replicate 97 '+') ++ ".")
23:08:37 <lambdabot>   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
23:09:00 <Axman6> @bf +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
23:09:00 <lambdabot>   a
23:09:05 <Axman6> much better
23:09:28 <osfameron> why the 3 dots a bove?
23:09:46 <Axman6> lambdabot truncates output
23:09:55 <osfameron> ah!
23:09:57 <kmc> still no pattern splices in TH?
23:10:03 <kmc> or do i just not know the syntax for?
23:10:25 <ddarius> There are quasiquoters for patterns, I'm pretty sure.
23:10:26 <Veinor> > let f x = head x : x in fix f
23:10:29 <lambdabot>   mueval-core: Time limit exceeded
23:11:07 <Veinor> so i assume fix f = _|_?
23:11:44 <Veinor> oh wait no
23:11:52 <Veinor> fix f = [_|_, _|_, _|_, ...]
23:12:02 <Axman6> > let f x = head x : x in f "Hello"
23:12:03 <lambdabot>   "HHello"
23:12:30 <Veinor> yep
23:12:42 <Veinor> > let f x = head x : x in map (const 0) (fix f)
23:12:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:13:42 <kmc> ddarius, through haskell-src-meta??
23:35:42 <binsh>  {g(X, f(Y)) = Z, h(Z, a) = h(g(X,b), v) } anyone who can give me a hint? this seems like a pretty hard one. can i switch g(X, b) for g(X, f(Y)) ?
23:40:27 <Axman6> that doesn't look like Haskell to me...
23:46:34 <binsh> well, its unification
23:49:10 <erus`> haskell curry's parents must have really liked functional programming to name him something like that :P
23:49:29 <Oxfaded> is Data.Bytestring lazy by default. Did it used to be?
23:51:55 <Axman6> Oxfaded: no, Data.ByteString.Lazy is lazy by default ;)
23:52:14 <kmc> Data.ByteString was never lazy afaik
23:52:33 <kmc> Lazy ByteString is a list of strict ByteStrings, wrapped in a newtype
23:52:40 <kmc> so it's not maximally lazy -- it's lazy down to some chunk size
23:52:50 <Axman6> no, it's always been represented a a contiguous array of bytes
23:53:11 <Axman6> uh, that was agreeing with your first comment =)
23:54:07 <Oxfaded> thanks, I havent touched haskell in about 2 years, having an omg wtf moment
23:56:57 <kmc> heh, i remember that
23:57:19 <kmc> i spent a year doing almost no haskell... came back and everyone was talking about Applicative, which i'd never heard of
23:59:22 <ddarius> If someone comes in and asks where FastPackedString went, that'll be someone who hasn't used Haskell for a while.
23:59:44 <ddarius> erus`: Haskell Curry didn't like the name Haskell.
