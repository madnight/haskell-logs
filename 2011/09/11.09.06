00:11:38 <Phyx-> Hi. Does anyone know if hscTypecheckRename caches any? so in two subsequent calls (without anything changing), does it typecheck both times?
00:19:29 --- mode: ChanServ set +o mauke
00:19:29 --- mode: mauke set -b $a:frendshipismagic
00:20:19 --- mode: mauke set -o mauke
00:20:51 <moroten> is there any good tool to tidy up a source code?
00:22:09 <moroten> i mean, like doing the indentation the in the same way through the whole file
00:22:26 <moroten> inserting extra spaces there where it looks good etc
00:24:51 <Jafet> I always use knuckle grease
00:29:32 <ddarius> You could parse your file and then pretty-print it.
00:46:34 <erus`> this was on reddit
00:46:46 <erus`> i hate the haskell reddit mods
00:46:51 <erus`> power tripping losers
00:47:20 <smiler> :)
00:47:39 <o-_-o> Is there an article/paper/tutorial which explains FRP, in a very simple way ?
00:47:57 <o-_-o> FRP for dummies ?
00:48:52 <erus`> is there a 'learn how to learn haskell' tutorial?
00:56:44 <hpaste> “_Ray_” pasted “Type error?” at http://hpaste.org/51004
00:57:20 <_Ray_> Hi :) As it says, I'm getting a type error there, I don't understand it :( The type of Arbol is "data Arbol a = Nodo a [Arbol a]".
00:57:49 <_Ray_> I thought about the types and they seem to match, but Haskell doesn't seem to like it, and complains about some a1 not being a :s
00:57:54 <Saizan> you should add the type error too
00:58:09 <_Ray_> I thought hpaste was going to do it by itself, sorry, I'll add it as a comment
00:58:18 <Saizan> ah, the problem is the type signature of f
00:58:32 <hpaste> “_Ray_” annotated “Type error?” with “Type error? (annotation)” at http://hpaste.org/51004#a51005
00:59:45 <Saizan> _Ray_: the 'a' in the signature of f is understood by the compiler to be a different type variable, and not the one in the signature of podarFoldable
01:00:03 <_Ray_> How can I tell it it's the same?
01:00:22 <_Ray_> Ack! Removing the type signatures fixed it :(
01:01:19 <hpaste> Saizan annotated “Type error?” with “Type error? (annotation)” at http://hpaste.org/51004#a51006
01:01:41 <_Ray_> ah, scopedtypevariables
01:01:44 <_Ray_> Thanks :)
01:01:57 <Saizan> np
01:02:37 <merijn> Are there binaries for cabal-install or do I need to compile it from source if I'm not installing Haskell Platform?
01:02:59 <Saizan> iirc there's one for windows
01:03:10 <merijn> (OSX)
01:03:26 <Saizan> probably source then
01:03:46 <Saizan> and if you're on 7.2.1 i think you need the darcs version
01:04:26 <merijn> Ironically, I don't have darcs because I just nuked my install for 7.2 >.>
01:05:13 <merijn> oh, there's a patch to fix the source release for 7.2
01:05:40 <Saizan> you should aim your missiles more carefully
01:06:31 <merijn> The entire reason for nuking stuff in the first place was to avoid the carefull upgrading everything in the right order dance
01:07:23 <o-_-o> On linux where does cabal put the packages ?
01:07:35 <Saizan> i've never had a problem with keeping binaries
01:07:38 <Veinor> ~/.cabal
01:07:43 <Veinor> unless you did something to change that
01:07:44 <Saizan> though never touched OSX either
01:07:52 <o-_-o> No if I do sudo cabal install blah
01:08:03 <Saizan> don't do sudo cabal install
01:08:10 <o-_-o> ah
01:08:29 <Saizan> if you really must do "cabal install --root-cmd=sudo .."
01:08:53 <o-_-o> ah...now I have no idea where the packages I installed went
01:09:24 <Saizan> does ghc-pkg list show them?
01:09:42 <o-_-o> Yes, it does
01:09:50 <o-_-o> How do I make it show up
01:10:00 <Saizan> where? in ghci?
01:10:05 <o-_-o> I am getting some error when installing wxcore
01:10:20 <Saizan> how are you installing it?
01:10:33 <o-_-o> cabal install reactive-banana-wx
01:10:51 <o-_-o> I get this error /bin/sh: wxdirect: not found setup: failed
01:10:52 <o-_-o> cabal: Error: some packages failed to install
01:11:07 <o-_-o> How do I find out where it is failing so I can fix this ?
01:11:20 <o-_-o> wxcore-0.12.1.6 failed during the configure step.
01:11:27 <Saizan> that sounds like some part of your wx installation is missing
01:11:55 <o-_-o> Yes but wxdirect is installed, atleast that is what cabal tells me
01:12:05 <o-_-o> so I want to find out how to debug this error
01:12:39 <Saizan> try increasing the verbosity level
01:12:51 <Saizan> also you can get info about your installed packages from ghc-pkg
01:12:55 <Saizan> see ghc-pkg --help
01:13:19 <Saizan> (by wx installation i meant the C part, but icbw)
01:15:01 <Saizan> o-_-o: do you have ~/.cabal/bin in your $PATH ?
01:15:22 <Saizan> o-_-o: maybe the confirue step for wxcore is looking for the wxdirect executable and not finding it
01:15:42 <o-_-o> Ah...that fixed it :-)
01:15:44 <o-_-o> Thanks
01:15:56 <o-_-o> ah...no
01:16:48 <o-_-o> It failed again at a new place now
01:17:04 <o-_-o> This time it says exitfailure 1
01:19:05 <Saizan> there should be a more informative error above
01:19:19 <o-_-o> ignore: parse error : //WXCOLORREF wxColour_GetPixel( TSelf(wxColour) _obj );
01:19:32 <o-_-o> this is all I see, but I have no idea how to fix this
01:20:46 <Saizan> me neither
01:22:20 <merijn> How can I beat cabal packages into accepting libraries outside their accepted range? (i.e. darcs depends on unix <2.5 while GHC7.2 installs 2.5 by default)
01:23:17 <zomg> merijn: spose you could try editing the description file which defines the deps
01:23:28 <zomg> Dunno if there's other ways around it
01:23:51 <Saizan> yeah, cabal unpack; edit the .cabal file bumping the version if it's a lib; "cabal install"
01:24:39 <luite> I usually add an extra minor version number to those packages (so that the next real version will be higher), and publish them to my private hackage repository
01:29:12 <Veinor> maybe cabal install should take a --ignore-dep-versions
01:38:34 <o-_-o> apfelmus
01:38:39 <o-_-o> hmm...
01:39:10 <o-_-o> I am trying to build this https://raw.github.com/HeinrichApfelmus/reactive-banana/master/reactive-banana-wx/src/Counter.hs
01:39:22 <o-_-o> counter.hs:23:15: Not in scope: `compile'
01:39:31 <o-_-o> Anyone have any idea ?
01:42:02 <o-_-o> > compile
01:42:03 <lambdabot>   Not in scope: `compile'
01:47:48 <hpaste> “_Ray_” pasted “Incorrect indentation?” at http://hpaste.org/51008
01:48:38 <_Ray_> (I checked tabbing the else and if differently, no dice. Error seems to be on line 9.)
01:49:02 <c_wraith> _Ray_: "then" and "else" should be aligned
01:50:22 <hpaste> c_wraith annotated “Incorrect indentation?” with “Incorrect indentation? (annotation)” at http://hpaste.org/51008#a51009
01:50:28 <ddarius> c_wraith: There is no layout with if-then-else.
01:50:47 <c_wraith> well.  the problem there is that "else" isn't indented enough
01:51:06 <_Ray_> Is it?
01:51:36 <shachaf> _Ray_: You also might as well use another guard instead of if.
01:51:38 <ddarius> c_wraith: There is no block of layout open, other than the top-level one.
01:52:07 <ddarius> The problem is valor == f game should probably be valor = f game
01:52:23 <_Ray_> ...
01:52:23 <c_wraith> oh, true
01:52:23 <_Ray_> oh.
01:53:12 <_Ray_> Yay, it works. Although had to replace xs == [] with length xs == 0, but OK.
01:53:25 <shachaf> _Ray_: ...null xs
01:53:32 <_Ray_> Thanks :)
01:53:33 <ddarius> xs is apparently not a list.
01:53:42 <ddarius> Oh, I missed length.
01:53:48 <ddarius> Then what shachaf said.
01:54:12 <shachaf> Please, not length xs. genericLength with Nat is semi-justifiable.
01:54:35 <_Ray_> Why not length xs?
01:54:45 <shachaf> Because it forces the entire list.
01:54:54 <shachaf> > length [1..] == 0
01:54:59 <lambdabot>   mueval-core: Time limit exceeded
01:55:05 <_Ray_> oh
01:55:19 <shachaf> _Ray_ accidentally the whole list.
01:55:23 <_Ray_> yeah :o
01:55:29 <_Ray_> accidentally bottom the whole list
01:55:45 <shachaf> Well, even for finite lists non-bottom lists it's a bad idea.
01:56:14 <ddarius> _Ray_: If you have a 1,000,000 item list, it will traverse all of those items, return 1,000,000 and decide that that is not equal to 0.
01:56:24 <_Ray_> yeah, makes sense
01:57:47 <_Ray_> Is there a way to extract the 'fst' pattern out of this? fst jugando_esta >= fst jugando_el_resto
01:57:58 <_Ray_> Something like fmap if (,) were a Functor
01:58:32 * shachaf wonders if the non-English identifiers are strictly necessary.
01:58:58 <_Ray_> :s I just copy+pasted from my code... and my code is a mess wrt languages, yes. Reflects that my head is also a mess.
01:59:17 <_Ray_> (I don't think in one particular language when coding, I'll switch several times a sentence.)
01:59:50 <shachaf> @src on
01:59:51 <lambdabot> (*) `on` f = \x y -> f x * f y
02:00:32 <_Ray_> niiice :)
02:00:51 <ddarius> You can also just pattern match in the where clauses.
02:01:14 <_Ray_> What do you mean?
02:01:46 <erus`> where a 1 = 2; a 2 = 1
02:02:04 <ddarius> jugando_el_resto@(first_element,_) = minimax f el_resto
02:02:23 <_Ray_> ah
02:03:55 <obiwahn> i watch a online cource on haskel and wonder a bit about one of the exercise questions - they ask if equations hold
02:04:30 <obiwahn> now there is something like x:xz:ys = [x] ++ xs ++ ys
02:04:38 <Axman6> no
02:04:56 <obiwahn> hasle complains about both experssions
02:05:29 <obiwahn> x:y prepends x to y
02:05:49 <obiwahn> and ++ appends but has to go to the whole list
02:06:28 <obiwahn> the tutor says that in the fist expression contains xs while the second does not
02:07:43 <obiwahn> i do not get the point why exactly the two are different not only in runtime
02:08:35 <obiwahn> mh must xs in the second be alist?
02:10:39 <Axman6> obiwahn: they mean very different things. x:y:zs means add y to zs, and then add x to that new list. [x] ++ xs ++ ys means make a new list with _all_ of the elements of the _list_ xs followed by the elemens of ys, and then make a new list with all the elements of the list [x] before all the elements of xs and ys
02:10:47 <Axman6> > 1:2:[3,4,5]
02:10:48 <lambdabot>   [1,2,3,4,5]
02:11:06 <Axman6> > [1] ++ [10,12,13] ++ [3,4,5]
02:11:08 <lambdabot>   [1,10,12,13,3,4,5]
02:11:24 <benmachine> in x:xz:ys, x and xz have the same type
02:11:36 <benmachine> in [x] ++ xs ++ ys, x has a different type from xs
02:12:08 <Axman6> you can't do 'a':[''b','c',d'']:['x','y','z']
02:12:18 <Axman6> > 'a':[''b','c',d'']:['x','y','z']
02:12:19 <lambdabot>   <no location info>:
02:12:20 <lambdabot>      lexical error in string/character literal at chara...
02:12:27 <Axman6> > 'a':[''b','c','d']:['x','y','z']
02:12:28 <lambdabot>   <no location info>:
02:12:28 <lambdabot>      lexical error in string/character literal at chara...
02:12:44 <Axman6> > 'a':['b','c','d']:['x','y','z']
02:12:46 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
02:12:46 <lambdabot>         against inferred type...
02:12:49 <Axman6> there we go
02:15:42 <obiwahn> thank you:)
02:17:24 <erus`> > h:"i!"
02:17:25 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Types.Char)
02:17:26 <lambdabot>    arising from a u...
02:17:32 <erus`> > 'h':"i!"
02:17:34 <lambdabot>   "hi!"
02:30:14 <MHD> Any good tutorials on using Yi?
03:04:04 * hackagebot netwire 1.2.1 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.1 (ErtugrulSoeylemez)
03:20:15 <Ke> so according to grep there's a sched_yield in ghc sources
03:20:40 <Ke> where can I send anthax letters to
03:20:49 <merijn> Why?
03:21:29 <Ke> my prgoram busyloops sched_yield with no explicit calls to it
03:22:14 <Ke> and I'm getting paranoid =o(
03:22:54 <Ke> ie. is this normal behaviour and why is there sched_yield in ghc
03:23:41 <merijn> You just said your program is busylooping, why would it matter what's in the GHC sources if your program is going wrong?
03:25:08 <Ke> well the most of the control flow is is in blocking ffi call, but the userland part has some implicit threads that are in sched_yield busyloop
03:25:21 <Ke> and as I said, there are not explicit calls to it
03:26:17 <merijn> Isn't that simply the runtime waiting for the blocking FFI call to finish? Calling sched_yield to let go off the CPU since it has nothing to do?
03:27:22 <Ke> sched_yield does not let go of the cpu
03:27:55 <merijn> eh, yes that is exactly what it does
03:28:03 <Ke> nope
03:28:19 <Ke> it returns immediately, if there is nothing else to run
03:28:21 <merijn> "The sched_yield() system call forces the running process to relinquish the processor until it again becomes the head of its process list."
03:29:30 <merijn> If your OS has nothing else to do, then yes it'll probably get the CPU back quite fast. But if your OS has nothing to do, who cares?
03:29:34 <Saizan> i think it's the nature of spinlocks to be annoying if the OS keeps scheduling the same thread
03:29:40 <Veinor> what do i want to use instead of printf?
03:29:49 <Ke> merijn: anyways you do know that sched_yield should never be used
03:29:58 <ajju> i want to use getInteger function pls help
03:30:06 <merijn> Ke: I beg to differ
03:30:27 <Veinor> ajjo: what do you mean?
03:30:42 <Saizan> Veinor: Text.Printf.printf ? show and ++?
03:30:53 <Ke> merijn: I bet you also think that ghc should use 100% of cputime doing nothing?
03:30:55 <MHD__> Any good Yi tutorials/cheat sheets out htere?
03:31:03 <Veinor> Saizan: yeah, i could just use show and ++
03:31:19 <Ke> merijn: or is there something I'm doing wrong with FFI
03:31:31 <mauke> Veinor: Text.Printf.Mauke.TH
03:31:56 <merijn> Ke: No, it shouldn't. But that's not the same as "you should never use sched_yield". But I'm not familiar enough with the FFI to know what's going on here
03:32:05 <Ke> in some specific realtime systems sched_yield might be useable, but never for generic scheduling
03:32:23 <MHD0> Any good Yi tutorials or cheat sheets out there?
03:33:07 <Veinor> mauke: you look like an impartial recommender!
03:33:18 <mauke> Veinor: inorite
03:34:14 <Ke> merijn: and you probably very well know that there are ways to wait for threads in blocking system calls other than busylooping =oP
03:34:59 <benmachine> Ke: if you send anthrax letters to GHC devs we will be upset
03:35:13 <Saizan> Ke: which version of ghc are you using btw? i thought ghc stopped using spinlocks recently
03:35:16 <Ke> merijn: can you give me a non RT example where sched_yield isn't bad
03:35:29 <Ke> Saizan: 7.0.4
03:35:36 <MHD> Any good Yi tutorials or cheatsheets out there?
03:35:46 <Saizan> MHD: we read you the first time
03:36:46 <Ke> Saizan: sched_yield for spinlocks is absurd while it still requires a system call
03:36:58 <Ke> and scheduling decisions ba the OS
03:37:06 <Ke> by
03:37:09 <merijn> Ke: Well, for one I'm working on a highly threaded runtime system where we want to yield the CPU to different threads after finishing a unit of work.
03:38:24 <Ke> you can switch context within virtual memory without system calls
03:39:47 <merijn> Ke: Oh, with a different design there might be better approaches, I'm painfully aware. I'm doing the best I can within the existing codebase and my limited time :)
03:39:48 <Saizan> i guess the spinlocks might not be relevant then
03:41:43 <Saizan> Ke: http://ghcmutterings.wordpress.com/2010/01/25/yielding-more-improvements-in-parallel-performance/ <- they are indeed relevant
03:42:11 <Saizan> (it mentions sched_yield at the end)
03:44:21 <MHD> Saizan: sorry, my irc was kinda bugging out, so I wans't sure
03:49:04 * hackagebot Hipmunk 5.2.0.3 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.3 (SoenkeHahn)
03:51:17 <gienah> @tell MHD: some Yi notes at: http://andekar.wordpress.com/category/yi/
03:51:17 <lambdabot> Consider it noted.
03:54:46 <Ke> Saizan: seems like a patch on a design failure
03:55:26 <Ke> though adding sched_yield makes things better, they still are pretty bad
03:55:57 <benmachine> Ke: well, do *you* want to redesign the entire thing?
03:56:05 <Ke> =oP
03:56:15 <benmachine> also I wonder how you measure pretty bad
03:56:38 <Ke> sched_yield is mostly pretty bad =oP
03:57:53 <int-e> Ke: That's very easy to say, but I find it hard to suggest anything better in that context. The spinlock tries to acquire the lock a couple of times. When that fails, we can be fairly certain that this happened because some other RTS worker thread is not currently running. So sched_yield() should not return immediately, but rather give that other thread a chance to run.
03:57:54 <Ke> anyways are there ways to see what spinlock causes this
03:58:57 <Ke> int-e: but it would seem obvious that some thread is entering ffi IO holding the spinlock
03:59:04 <int-e> (There are other instances of sched_yield in the RTS that I'm less happy about ... waiting for other worker threads to finish at the end of a GC, for example.)
03:59:29 <charon> pardon the comment from a lurker, but to me it sounds like at least on linux you could work around the pthread/unlock-in-other-thread restriction by using futex directly since it doesn't have such a requirement
04:00:02 <Ke> thanks
04:00:38 <benmachine> charon: the comments on the bug thread seemed to suggest that futexes were tried and found to be slower
04:00:43 <MHD> how do I run Yi with the Gtk frontend?
04:00:44 <lambdabot> MHD: You have 1 new message. '/msg lambdabot @messages' to read it.
04:00:55 <charon> benmachine: ok, never mind then :) back to lurking
04:01:12 * benmachine hugs charon
04:08:07 <Ke>  doesn't make sense to me, but I guess I should read up on nptl to really know
04:08:36 <Ke> anyways is there anyone who actually knows what I could do to solve the actual problem
04:13:50 <Saizan> you could try #ghc
04:14:04 * hackagebot netwire 1.2.2 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.2 (ErtugrulSoeylemez)
04:14:36 <int-e> Ke: well it would be nice to know which of the several yieldThread() calls is responsible. You could start by building with the debugging RTS (ghc -debug -rtsopt) and then run with +RTS -Ds to see if it has a corresponding looping "yielding..." output
04:14:47 <int-e> yeah, #ghc may be better.
04:35:19 <Ke> -Ds gives no yields
04:35:37 <Ke> I guess testing ghc-7.2 might be reasonable though
04:44:30 <int-e> Ke: Oh. If you have FFI calls that can block (or can take long to complete) you should use safe (not unsafe) imports.
04:49:04 * hackagebot X11-rm 0.2 - A binding to the resource management functions missing from X11.  http://hackage.haskell.org/package/X11-rm-0.2 (TroelsHenriksen)
04:49:17 <Ke> int-e: safe seems to be the default according to realworldhaskell
04:52:53 <clsmith> hey. does anyone remember the link to that python quiz thing which demonstrates python's crazy multiple list comp scoping? :p
04:55:50 <int-e> clsmith: http://web.mit.edu/rwbarton/www/python.html
04:56:59 <Snardbafulator> Test Pidgin client
04:57:30 <Botje> we read you five out of five
04:58:06 * Axman6 believes it's Five by Five, and no longer really used... at least if you're using the digital radios we use...
04:58:37 <Botje> I last heard it with the launch of the space shuttle :P
05:00:25 <clsmith> int-e: thanks
05:06:10 <akosch> is there a lazy version of Control.Parallel.Strategies.parMap?
05:07:36 <Jafet> I don't see how it could be lazy
05:07:50 <xiln> hello. Can someone explain Typeable to me? And how the 'cast' function works?
05:08:06 <Jafet> Laziness fixes the evaluation order, and you might as well be using map.
05:08:23 <akosch> Jafet: well now that I think about it...
05:09:11 <akosch> I wanted to use it on an infinite list in combination with takeWhile
05:09:17 <benedikt> what meaning does " >> return ()" have in http://code.haskell.org/xmonad-extras/documentation/XMonad-Actions-Volume.html ?
05:09:44 <hpc> :t (>> return ())
05:09:45 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
05:09:57 <hpc> benedikt: it just says "ignore the result of this monadic action"
05:10:05 <ehamberg> benedikt: it means “i was just called for the side effects”
05:10:16 <Jafet> akosch: oh it's strict in the spine?
05:10:21 <tromp> it means >> /dev/null
05:10:28 <Jafet> Well, that does make sense
05:10:41 <hpc> tromp: hehe
05:10:48 <benedikt> i figured out that it ignores it. But what else can i do with it? Does it work in a similar way to unix pipes? What are they called (so i can read about it, googling "haskell >>" wasnt helpful)
05:10:49 <akosch> Jafet: yes
05:10:57 <Jafet> If you want to evaluate an infinite list in parallel, you might want to consider how to schedule the evaluations explicitly
05:11:12 <tromp> no, it has nothing to do with pipes
05:11:23 <hpc> benedikt: http://learnyouahaskell.com/
05:11:30 <hpc> benedikt: read up on functors, applicative, and monad
05:11:44 <benedikt> if you assume that people in here did not try to find the answer first and just start spoonfeeding them with ":t" outputs from the bot, you'll just train your users not to look themselves :)
05:11:46 <akosch> Jafet: you mean using par for example?
05:11:59 <benedikt> hpc: thanks. thats way more helpful in my case.
05:12:35 <hpc> benedikt: people tend to develop a nasty habit of answering the question that was asked, instead of being helpful ;)
05:12:37 <Jafet> I think you'll get further with pseq.
05:13:04 <Saizan> akosch: maybe you want parBuffer or evalBuffer
05:13:19 <benedikt> hpc: thats a horrible habit :)
05:13:31 <benedikt> (point taken though)
05:13:58 <akosch> Saizan: thanks, I'll check them out
05:14:20 <Jafet> Well, it's often easier to do that than to guess the correct way to be helpful
05:14:38 <Jafet> Eg. open-ended questions like "what is the meaning of x"
05:15:09 <hpc> benedikt: as i understand it, xmonad is one of the worst places to learn haskell from
05:30:25 <Veinor> is there a (Monad m) => (a -> Bool) -> [m a] -> [m a]?
05:30:29 <Veinor> hoogle isn't finding it if it exists
05:30:57 <Veinor> ... oh, that's not possible
05:31:19 <Veinor> otherwise you could have, say, a list of IO Chars and figure out how many were vowels
05:31:23 <Axman6> indeed
05:31:29 <quicksilver> (a -> Bool) -> [m a] -> m [a] looks more promising
05:31:48 <Veinor> well that's just sequence and liftM (filter f)
05:31:52 <Axman6> :t filterM
05:31:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
05:31:57 <Axman6> :\
05:32:10 <Axman6> > filterM (const [True,False]) [1,2,3]
05:32:12 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
05:32:14 <DasIch> quicksilver: but [m a] can't work
05:32:27 <Axman6> DasIch: eh?
05:32:43 <Veinor> :t \f ms -> liftM (filter f) $ sequence ms
05:32:44 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> [m a] -> m [a]
05:33:09 <DasIch> oh, sorry i misunderstood
05:33:33 <Axman6> why don't we have a sequence' which is tail recursive?
05:33:51 <Axman6> i mean, it's very easy to implement
05:34:58 <Veinor> basically, here's my dilemma: i have an [m a], an a -> Bool, an a -> m b, and i want an m [b] that only contains elements corresponding to the a's that pass the filter
05:35:20 <Jafet> What does tail recursive even mean
05:35:53 <Jafet> What properties does it have compared to sequence?
05:35:57 <Saizan> Veinor: do you care if the m a get executed all up front?
05:36:03 <Veinor> Saizan: nah
05:36:14 <Veinor> \xs f k -> sequence $ map k $ liftM (filter f) xs
05:36:23 <Veinor> :t \xs f k -> sequence $ map k $ liftM (filter f) xs
05:36:24 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [[a1]] -> (a1 -> Bool) -> ([a1] -> m a) -> m [a]
05:36:34 <Saizan> you need another sequence in front
05:36:37 <Veinor> right
05:36:45 <Veinor> :t \xs f k -> sequence $ map k $ sequence $ liftM (filter f) xs
05:36:46 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [[a1]] -> (a1 -> Bool) -> ([a1] -> m a) -> m [a]
05:37:05 <Saizan> :t \xs f k -> mapM k $ liftM (filter f) (sequence xs)
05:37:05 <lambdabot> forall (m :: * -> *) b a. (Monad m) => [[a]] -> (a -> Bool) -> ([a] -> m b) -> m [b]
05:37:09 <Axman6> Jafet: avooiding needing to hold onto each intermediate result on the stack
05:37:15 <Veinor> :t \xs f k -> sequence $ map k $ liftM (filter f) $ sequence $ xs
05:37:16 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [[a1]] -> (a1 -> Bool) -> ([a1] -> m a) -> m [a]
05:37:24 <Saizan> :t \xs f k -> mapM k =<< liftM (filter f) (sequence xs)
05:37:25 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [m a] -> (a -> Bool) -> (a -> m b) -> m [b]
05:37:28 <Saizan> there :)
05:37:36 <Veinor> ah, neat
05:38:02 <Veinor> so basically replace the map/sequence with a mapM
05:38:03 <Saizan> :t \xs f k -> mapM k . filter f =<< sequence xs -- if you want
05:38:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [m a] -> (a -> Bool) -> (a -> m b) -> m [b]
05:38:26 <Axman6> > ler sequence ' xs = s xs [] where s [] ys = return (reverse ys); s (z:zs) ys = do {y <- z; s zs (y:ys)} in sequence [Just 4, Just 7, Just 1]
05:38:27 <lambdabot>   <no location info>:
05:38:28 <lambdabot>      lexical error in string/character literal at chara...
05:38:28 <Saizan> Veinor: you also had to use =<<
05:38:42 <Axman6> > let sequence' xs = s xs [] where s [] ys = return (reverse ys); s (z:zs) ys = do {y <- z; s zs (y:ys)} in sequence' [Just 4, Just 7, Just 1]
05:38:42 <Veinor> well, yes
05:38:43 <lambdabot>   Just [4,7,1]
05:38:48 <Veinor> but in my case i'm in a do-block
05:39:39 <Saizan> you could have kept it separate too
05:40:04 <Saizan> :t \xs f k -> sequence . map k =<< liftM (filter f) (sequence xs)
05:40:04 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => [m a1] -> (a1 -> Bool) -> (a1 -> m a) -> m [a]
05:41:13 <Jafet> Axman6: well, that holds when the Monad isn't nondeterministic.
05:41:44 <Saizan> Axman6: in cases like this where the best we can do is move memory use from the stack to the heap i wonder if the problem is just the too low threashold for stack overflow
05:41:48 <Axman6> what do you mean?
05:42:39 <Jafet> Ideally, the stack should be indistinguishable
05:42:43 <Jafet> I wonder why ghc doesn't already make it so
05:42:46 <benedikt> hpc: im inclined to agree with that.
05:43:03 <Jafet> Using eg. Baker's "Cheney on the MTA"
05:43:38 <Jafet> Axman6: consider eg. [], where >>= creates a branch in control flow
05:44:42 <Axman6> well, my point is that it would be useful to have, and people can use it when it's appropriate
05:45:25 <Jafet> Well, I've never had a stack overflow from sequence
05:45:44 <Jafet> And I assure you, I probably have subliminally tried
05:46:33 <Axman6> i believe i have
05:46:53 <Axman6> i can't remember when, but something got me thinking about this =)
05:48:12 <Saizan> i've seen cases where it would have been useful
05:48:39 <Saizan> though i'd try to get more laziness actually
05:49:34 <Jafet> Is there room for more laziness?
05:50:51 <Saizan> it depends on the particular case, sometimes a ListT-done-right (maybe chunked) could work
05:51:31 <Jafet> I'm not sure if this deserves adding yet another Monad method
05:52:13 * Saizan has not proposed new Monad methods
05:52:35 <Jafet> I thought you proposed implementing sequence on a Monad-by-Monad basis
05:53:33 <joe6> is there a better way of representing this without the do: http://codepad.org/qkiZDsTv
05:53:57 <joe6> http://codepad.org/xCIFMUzE
05:54:30 <Saizan> the cases i was talking about were meant to vary according to more than just the monad
05:54:33 <joe6> updated version: http://codepad.org/xCIFMUzE
05:55:13 <quicksilver> joe6: looks like map (\x -> valueOfBit p x) [0..len]
05:55:21 <quicksilver> or it might be 0..(len-1), actually
05:55:30 <quicksilver> mapM, not map.
05:55:42 <joe6> quicksilver: that is smart and simple. thanks.
05:55:43 <ion> Hmm, which one is clearer? The first one (the one from Saizan), i think.
05:55:45 <ion> \f g -> (=<<) (mapM f) . fmap (filter g) . sequence
05:55:45 <ion> \f g -> join . fmap (mapM f . filter g) . sequence
05:55:52 <quicksilver> joe6: mapM (valueOfBit p) [0.. (len-1)]
05:56:00 <hpaste> foo pasted “parse error on input `='” at http://hpaste.org/51013
05:56:24 <buntfalke> What's so wrong with the last line of this http://hpaste.org/51013 function?
05:56:25 <Axman6> dear foo, check yo brackets
05:56:33 <buntfalke> Oooooohhh...
05:56:36 <Axman6> buntfalke: check your brackets
05:56:39 <buntfalke> *facepalm*...
05:56:40 <buntfalke> thanks Axman6
05:56:49 * buntfalke goes to his corner
05:56:51 <buntfalke> :-)
05:57:40 <joe6> quicksilver: mapM (valueOfBit p) . take len $ [bitPos..]
05:57:46 <ion> Or alternatively add {-# LANGUAGE DoWhatIMean #-}
05:57:57 <quicksilver> joe6: that looks plausible, yes ;)
05:57:58 <c_wraith> best pragma ever
05:59:05 <Jafet> DoWhatIMean would cause ghc to avoid doing what you asked for and question your rationale instead
05:59:08 <Jafet> If irc is any precedent
05:59:28 <shachaf> buntfalke: You don't need a tuple for InnerNode, by the way.
06:00:20 <buntfalke> shachaf: If you mean I could remove the outer brackets --> "Equations for `showTree' have different numbers of arguments"
06:00:38 <merijn> Jafet: That would be an excellent compiler feature
06:00:41 <shachaf> buntfalke: No, the inner ones. Right now you have it as a data type containing one tuple.
06:00:50 <merijn> Now we just need to implement strong AI to do it
06:01:09 <buntfalke> shachaf: a triple, yes. the definition of the datatype is fixed; can't change it :-)
06:01:09 <shachaf> I.e., these are all distinct values: undefined, InnerNode undefined, InnerNode (undefined,undefined,undefined), etc.
06:01:13 <Jafet> I don't need strong AI to irc!
06:02:21 <merijn> Jafet: So your plan is to just integrate an IRC client into GHC and have it pastebin code and relay the scolding?
06:03:07 <Nimatek> merijn: Genius!
06:03:09 <Polarina> mm_freak, The haddock documentation doesn't seem to be available on hackage for netwire-1.2.2: http://hackage.haskell.org/package/netwire-1.2.2
06:03:22 <mm_freak> Polarina: it hasn't been built yet
06:03:23 <Jafet> No, but I'll gladly accept credit for it.
06:03:41 <mm_freak> you have to be patient, until the bot rebuilds the hackage docs…  or just install it locally
06:03:54 <mm_freak> make sure to have "documentation: True" in your .cabal/config
06:04:01 <merijn> It serves two purposes, it'll also provide an outlet for grumpy haskell coders who want to yell at people
06:04:06 <Polarina> mm_freak, Oh, didn't know it worked that way. Sorry for bothering you and thanks again for a wonderful library. :)
06:04:18 <mm_freak> Polarina: no problem, and you're welcome =)
06:04:30 <mm_freak> if you have time, i'd really appreciate any feedback
06:06:54 <benedikt> hpc: but i learned (e)lisp by using emacs.
06:08:17 <Polarina> mm_freak, what I feel might be missing are more tutorials or examples of some sort. Not everyone is familiar with the topic of (A)FRP). Right now, it's not the easiest thing to jump into, but this does not necessarily have to do anything with netwire in particular.
06:09:15 <BobFunk> just released a bridge between the HTML5 EventSource API and AMQP written in Haskell
06:09:27 <BobFunk> a few votes on the ycombinator post would be much apreciated!
06:09:27 <BobFunk> http://news.ycombinator.com/item?id=2965587
06:09:31 <BobFunk> :)
06:12:49 <mm_freak> Polarina: i'm planning to update the wiki page, but right now i'd like put the library into use in some practical projects
06:14:12 <mm_freak> also i'm planning to write a gentle introduction into AFRP, because most existing material is either too terse or too theoretical
06:14:22 <mm_freak> the introduction should be tied to netwire
06:14:49 <mm_freak> first project will be a little test combining gloss + instinct + netwire
06:15:11 <mm_freak> a little system of learning ants trying to accomplish some virtual task
06:15:32 <mm_freak> (gloss is btw the main reason why i abstracted out the IO monad and added the additional type parameter to Wire) =)
06:15:53 <mm_freak> gloss gives you no choice as to whether your system is pure or not
06:18:04 <hpaste> Laugarhraun pasted “Euler 14” at http://hpaste.org/51014
06:18:19 <Polarina> mm_freak, That'll be most interesting. :)
06:18:32 <Laugarhraun> Hi! I've got a small problem: I'm currently trying to train my haskell skills through the Euler project
06:19:07 <Laugarhraun> I'm currently doing #14, which is about finding the longest chain with an Int < 1000000 of the Collatz Problem
06:19:21 <Laugarhraun> when I do it with 100 000 or 200 000, it goes fine
06:19:41 <Botje> are you running it in ghci?
06:19:45 <dafis> Laugarhraun: Int overflow, probably (haven't looked yet)
06:19:54 <Laugarhraun> but after 300 000... It starts taking long time and, on linux, the process is rapidly killed due its memory usage
06:19:59 <Botje> oh
06:20:11 <Laugarhraun> Botje:  I'm compiling it (ghc -03 euler14_.hs)
06:20:19 <smiler> You probably have to solve the problem in a more efficient way :)
06:20:26 <Laugarhraun> dafis: I replaced the foldl with foldl' in this goad
06:20:47 <Laugarhraun> smiler:  problem: If I don't remember what I already computed, it is going to take nights
06:20:54 <merijn> Laugarhraun: Probably inefficient use of lists causing huge lists to be kept in memory (and slowness probably due to repeatedly traversing long lists)
06:20:55 <Laugarhraun> and if I do... it takes to much memory
06:21:02 <Laugarhraun> merijn:  I'm using a map
06:21:03 <merijn> Laugarhraun: Can you pastebin the code? hpaste.org
06:21:10 <Laugarhraun> merijn:  I did :)
06:21:13 <Laugarhraun> http://hpaste.org/51014
06:21:14 <merijn> oh, doh
06:21:28 <Laugarhraun> so, an item of the map = 2 Int = 8 bytes
06:21:28 <applicative> ah the dreaded collatz
06:21:55 <Laugarhraun> When the process is killed on my Fedora, it is taking 75% of the memory = 3GiB
06:22:05 <Polarina> Laugarhraun, would you be interested in my solution?
06:22:13 <c_wraith> I feel like the best way to solve this problem is with a graph traversal.  Of course, even naive does pretty well, if you make sure you're sharing properly.
06:22:22 <Laugarhraun> = 300 000 000 elements in the map!!
06:22:40 <mm_freak> i like the project euler problems, but i believe that they don't teach you haskell
06:22:43 <Laugarhraun> Polarina:  why not, but I'd rather know what I am doing wrong :)
06:23:07 <rwbarton> assuming an entry in the Map costs 8 bytes is seriously optimistic ;)
06:23:13 <Polarina> Laugarhraun, http://codepad.org/8TObdo3k
06:23:17 <mm_freak> in particular, you don't learn how to exploit the run-time system, advanced design patterns, etc.
06:23:21 <Laugarhraun> mm_freak:  They are useful to get your hands used to it I'd say... It is a way of producing basic code
06:23:32 <mm_freak> Laugarhraun: yeah, sure, and don't stop =)
06:23:34 <merijn> mm_freak: You're right Euler problems are terrible for learning programming
06:23:44 <Laugarhraun> they are not "real world" problems
06:23:52 <mm_freak> Laugarhraun: just wanted to note that you shouldn't stop after them
06:23:57 <merijn> They're for discovering math tricks to avoid computation, not programming
06:24:13 <quicksilver> merijn: hear hear!
06:24:17 <Laugarhraun> Polarina:  wow that is shorter than mine o_o
06:24:20 <mm_freak> actually PE problems are much better, if you don't know the mathematical solution
06:24:29 <quicksilver> merijn: the euler problems are interesting problems in *maths*; they are dull problems in computer science.
06:24:38 <Polarina> Laugarhraun, it's a naive brute-force solution.
06:24:40 <Jafet> merijn: that's the best description of haskell I've heard in a while
06:24:42 <quicksilver> (well personally I find them dull in maths, too, but then I don't like that kind of maths)
06:24:42 <mm_freak> if you actually have to write the search algorithms
06:24:44 <merijn> mm_freak: Like I said, they're for discovering math tricks
06:25:06 <merijn> Personally I prefer code golfing to Project Euler
06:25:12 <Jafet> Haskell is a language for discovering math tricks to avoid programming
06:25:29 <merijn> Haskell is for discovering programming tricks to avoid programming too
06:26:10 <mm_freak> Jafet: not at all
06:26:27 <mm_freak> haskell solves problems, for which in other languages you would love to know the math tricks, if you don't
06:26:46 <mm_freak> in particular in haskell there are more solutions than problems =)
06:27:07 <Veinor> i need to write a text-specialized version of markov-chain
06:27:08 <Laugarhraun> Polarina:  how long does it take? It is a bit like the first solution I came up with, but after 1 hour of execution, I stopped it ad tried to add some memory...
06:27:23 <cheater> Veinor, are you making a bot
06:27:25 <Jafet> I don't believe that the frustration hierarchy collapses in haskell, for all its goodness
06:27:39 <Veinor> cheater: i'm making something like a bot
06:27:41 <Polarina> Laugarhraun, compile it with -O2. Takes about 5-10 sec. on my computer.
06:27:43 <merijn> Laugarhraun: Most Euler projects should finish within 1 or 2 minutes if you solve them "properly"
06:27:58 <Laugarhraun> so... does anyone see a problem in what I did?
06:27:58 <merijn> s/Most/All
06:28:00 <rwbarton> Laugarhraun: you are trying to remember the values for every number you ever see in a sequence, but there are just too many of them
06:28:21 <Veinor> what rwbarton said
06:28:25 <Laugarhraun> rwbarton:  remembering 1 = 8 bytes
06:28:33 <rwbarton> what works better here is to only remember the values for numbers in some range like 1..1000000, then recomputing ones outside that range
06:28:38 <rwbarton> no, that is not even close to true
06:28:57 <Laugarhraun> so when my program is killed at 3GO of memory, it means it had about 3.10^8 values in memory. Which would be strange
06:29:10 <Laugarhraun> rwbarton:  ?
06:29:11 <rwbarton> I would estimate the cost of an entry in Map Int Int is more like 20 bytes, but some people here probably have better estimates
06:29:18 <Laugarhraun> oh
06:29:36 <Laugarhraun> then it is still 1.5*10^8 values
06:30:03 <Jafet> No need to guess; just look at the source for Map
06:30:05 <rwbarton> Well, how can you know that isn't really the number of values you're trying to insert?
06:30:33 <rwbarton> didn't someone have a blog post that calculated the space usage of Map, actually?
06:30:41 <Veinor> Polarina's solution doesn't actually store collatz lengths at all
06:30:42 <Laugarhraun> mhh
06:30:58 <Laugarhraun> Veinor:  indeed, and it finished within 10 seconds
06:31:02 <dafis> Laugarhraun: your problem is that you're inserting thunks, not values into the map
06:31:06 <rwbarton> ah, here we go: http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html
06:31:14 <Jafet> The interesting constructor is Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a)
06:31:16 <Laugarhraun> so I wonder what I had done really wrong the first time (without memory)
06:31:49 <rwbarton> so if I understand that it is more like 40 bytes per entry
06:32:04 <Laugarhraun> dafis:  so if I wanted to do it this way, I should use an operator such as $! ? (Which, if I'm right, suppresses laziness)
06:32:06 <Jafet> That suggests about 5 words per node, disregarding the size of k and a
06:32:57 <rwbarton> plus one for the constructor?
06:33:13 <Polarina> Laugarhraun, your solution finishes under 30 sec. using ~5 GiB of memory.
06:33:16 <dafis> Laugarhraun: let m' = populate' m n'; l = 1 + m' M.! n'; l `seq` M.insert ...
06:33:16 <rwbarton> or did you count that
06:33:36 <Laugarhraun> Polarina:  oh, tank you! I did not have enough memory to try it then
06:33:44 <merijn> Polarina: If he didn't have that much memory the process was probably so slow because of swap thrashing
06:33:50 <Jafet> Actually, every leaf has two Tips, so that's two additional words
06:33:55 <dafis> Laugarhraun: that makes your thing run in < 400M here
06:34:19 <Laugarhraun> thank you, kind sir
06:34:21 <Jafet> Well, between one and two, since not all nodes are leaves
06:34:44 <dafis> Laugarhraun: however, if you're on a 32-bit system, you'll have Int overflow, so in that case, use Int64 or Integer
06:34:47 <Jafet> Also, !k is polymorphic so it isn't unpacked, even though it's strict
06:34:57 <Laugarhraun> 64bits so that's ok
06:35:12 <rwbarton> oh well then your estimates are REALLY optimistic :P
06:35:33 <rwbarton> a Map Int Int is not a hast table
06:35:35 <rwbarton> or an array
06:35:36 <dafis> Laugarhraun: okay, then just a little more strictness is all you need
06:35:50 <rwbarton> it's some variety of balanced binary tree
06:35:54 <Jafet> On a 64-bit platform, Map Int Int is going to use perhaps about 72 bytes per node, assuming the values are inserted strictly
06:36:24 <Jafet> 6 words according to the linked blog, one for the key, and two for the boxed value
06:40:44 <int-e> But the key will also take 2 words.
06:41:00 <Jafet> D'oh.
06:41:11 <int-e> (Assuming no keys and values are shared.)
06:42:46 <int-e> Jafet: The Tips are shared though - nullary constructors get a statically allocated value.
06:43:57 <Jafet> Oops, then it's six words for the spine and only two for the data
06:44:08 <int-e> and two for the key
06:44:25 <int-e> since it's polymorphic in Data.Map.Map, hence cannot be unboxed.
06:45:11 <Jafet> !k -> k box -> k value, eh
06:45:21 <Jafet> That kind of sucks
06:47:06 <Jafet> I once contemplated a ghc extension that let you specify the layout of your type by using, say, its Storable instance
06:47:07 <quicksilver> this is why tibbe is so keen on data type specialisation
06:47:24 <Jafet> That might not be easily implemented in the STG, though
06:48:19 <Jafet> (But it gets quite interesting if those instances get to overlap)
06:48:37 <int-e> quicksilver: I'd like to see that, too. But it's not obvious how to accomplish this. If you have a specialised Map Int k, and you want to call a function that accepts Map a b, does it have to be specialised, too?
06:48:38 <tibbe> what's the topic?
06:48:40 <c_wraith> hahaha.  I've found a rather amusing way to solve the collatz problem there.  I doubt it's novel, but it's sure amusing.  Though it does depend on the unproven properties of the sequence.
06:48:40 <tibbe> data type sizes?
06:49:09 <tibbe> int-e, yes, everything needs to be specialized, or you need an impedance mismatch wrapper
06:49:10 <lambdabot> that's what i figured
06:49:31 <tibbe> Jafet, the new HashMap is going to be quite a lot smaller than Map
06:49:32 <lambdabot> I'm your huckleberry
06:50:14 <c_wraith> Let me get my thoughts into code..
06:50:14 <lambdabot> I like to pick everything up and smell it... Its a fetish of mine... And i mean everything! Is that cool with you?
06:50:16 <int-e> tibbe: right. so there's a tension between performance and code blowup. (not surprising, but it's a problem.)
06:50:16 <lambdabot> right indeed
06:51:12 <quicksilver> int-e: a wrapper unpacks it into the polymorphic version
06:51:24 <tibbe> int-e, I did some research on the number of unique map<k, v> variations in a large C++ code base, it's not that large O(100)
06:51:27 <quicksilver> but yes, of course, that's the problem
06:51:43 <tibbe> int-e, we can play some clever games with weak symbols to reduce code bloat
06:51:54 <quicksilver> JIT-specialiasiation or link-time specialisation seems like a good avenue too
06:52:41 <Jafet> It's not as bad as C++, where this duplication is the default
06:54:12 <Jafet> On one extreme, you could turn everything into a smalltalk object
06:54:19 <tibbe> we also only need to duplicate code for the functions that are actually used i.e. not for the whole Data.Map API
06:54:29 <Saizan> especially you shouldn't make this duplication trigger other overloading mechanisms like in c++
06:54:37 <Jafet> tibbe: you're researching automatic specialization?
06:54:44 <Jafet> ie. without annotations
06:55:09 <tibbe> Jafet, researching is a bit too strong. I've thought about it and discussed it a bit with the Simons
06:55:10 <mwc> tibbe: isn't a generic version of the code with dictionaries a possibility too? so one instance + specializations
06:55:23 <Jafet> Pre-researching
06:55:24 * tibbe thinks
06:55:27 <tibbe> right
06:55:43 <Jafet> Yeah, you can do this via a magic typeclass
06:55:44 <tibbe> mwc, I'm not quite sure what that means
06:56:07 <tibbe> we could have polymorphic functions and make all function calls indirectly through a dictionary yes
06:56:21 <tibbe> it's similar to a worker-wrapper transform
06:56:54 <Jafet> Also, heh O(100)
06:57:16 <hpc> O(leg)?
06:57:20 <merijn> tibbe: There's no such thing as O(100), that's just O(1)
06:57:52 <tibbe> since we do code generation in different modules we need to teach the type system that Map Int Int is always the same wherever it comes from (say that we generated two separate data type specializations in different modules)
06:58:00 <Jafet> merijn: C++ is so bloated that O(1) is actually O(100)
06:58:00 <tibbe> merijn, you are right
06:58:26 <tibbe> merijn, I am well aware
06:59:00 <tibbe> to be anal there's O(100), it's just in the same class as O(1)
06:59:22 <koeien> shouldn't it be O(const 1) ?
06:59:34 <smiler> koeien: lol
06:59:50 <hpc> :D
07:00:53 <Jafet> koeien: but 1 is const 1!
07:00:58 <Jafet> > 1 2
07:01:02 <lambdabot>   1
07:01:08 <Axman6> > 1 "hello"
07:01:10 <lambdabot>   1
07:01:32 <koeien> which instance is this?
07:01:47 <Starfire> Probably something funny from vector-spaces.
07:01:47 <Axman6> Num (a -> b) i think
07:01:49 <merijn> koeien: The lambdabot is filled with evil lies instance
07:01:54 <obiwahn> let fib n+2 = (fib n+1) +  fib n
07:01:56 <koeien> instance Num a => Num (a->b)
07:02:02 <Jafet> @hackage vector-space
07:02:03 <lambdabot> http://hackage.haskell.org/package/vector-space
07:02:03 <koeien> merijn: yeah i know that :)
07:02:05 <Jafet> @instances Num
07:02:08 <lambdabot> Double, Float, Int, Integer
07:02:11 <koeien> is its prelude available somewhere?
07:02:52 <fryguybob> @instances-importing Data.NumInstances Num
07:02:53 <lambdabot> (a -> b), (a, b), (a, b, c), (a, b, c, d), Double, Float, Int, Integer
07:03:01 <obiwahn> > let fib n+2 = (fib n+1) +  fib n
07:03:02 <lambdabot>   <no location info>: Parse error in pattern
07:03:14 <obiwahn> what is wrong with that?
07:03:34 <koeien> i can only see pointwise Num for a -> b, but that's not it
07:03:49 <Axman6> > 1 :: (Int,Int)
07:03:50 <obiwahn> fib n = fib (n-1) + fib (n-2) works  -- must the pattern be a single variable?
07:03:51 <lambdabot>   (1,1)
07:03:53 <koeien> obiwahn: fib (n+2)  = fib (n+1) + fib n -- you mean most likely
07:03:58 <Axman6> > 1 :: (Int,Double)
07:04:00 <lambdabot>   (1,1.0)
07:04:16 <koeien> obiwahn: although so-called n+k patterns are considered harmful by some. it's on the wiki
07:04:25 <brisingr> they are evil
07:04:40 <benmachine> they were removed
07:04:46 <koeien> in 2010?
07:04:46 <benmachine> in haskell2010 I think
07:04:56 <brisingr> many people still use 98
07:05:10 <koeien> obiwahn: anyway, the more serious error is that function application binds very strongly
07:05:15 <benmachine> most people use GHC haskell :P
07:05:18 <koeien> obiwahn: so fib n +1 means (fib n) + 1
07:06:09 <shachaf> (fib -> n) + 1 = n
07:06:16 <shachaf> n = fib 4
07:07:19 <hpc> > let foo = (*2) in foo 5+1
07:07:21 <lambdabot>   11
07:08:08 <obiwahn> ah ok i had the term right in my sandbox file --- it works with hugs and an older haskel version but not with the lates ghci:)
07:08:19 <Jafet> > (*) (+) 5 2 1
07:08:20 <lambdabot>   15
07:08:43 <ion> > (.) (*) (+) 5 4 3 2 1
07:08:45 * Jafet isn't cut out to be a railway worker.
07:08:47 <hpc> Jafet: it's like RPN, only... not
07:08:48 <lambdabot>   mueval-core: Time limit exceeded
07:09:27 <koeien> obiwahn: ok. hugs might be easier to set up on windows (although probably that's not true anymore/never was), but for "real work" GHC is strongly recommended
07:11:11 <obiwahn> i don't know about windows installation:)) but i prefer ghci because i can use let to bind new stuff:)
07:11:14 <hpc> i think the haskell wiki still says hugs is more popular for "academic work" or something like that, but even that isn't true anymore
07:11:19 <Jafet> Real work, like proving false
07:11:43 <koeien> i heard that the installing haskell platform is relatively painless
07:12:14 <hpc> koeien: it's just download, run, click yes a whole bunch
07:12:22 <Gnidoc> > filter (\x -> x /= ',') "I helped my uncle, jack, off his horse."
07:12:23 <Nimatek> Real work on Windows?
07:12:23 <lambdabot>   "I helped my uncle jack off his horse."
07:13:02 <Nimatek> I thought that OS was for gaming.
07:14:33 <Jafet> It's real work to get the system to work so that you can play games
07:20:26 <obiwahn> is there a way to show the definition of something while running hgci
07:20:41 <obiwahn> or change something once it is defined
07:20:57 <koeien> obiwahn: the former, i believe not, the latter, yes
07:21:00 <Jafet> Scroll through history until you see the definition
07:21:19 <Jafet> Or if you imported it, look at the corresponding source file
07:21:20 <obiwahn> like  let foo a = something that is wrong
07:21:32 <koeien> yes, just redefine it
07:21:35 <Jafet> New bindings shadow old ones
07:21:36 <obiwahn> then let foo a = this is mutch better
07:21:59 <obiwahn> but both are matched
07:22:05 <c_wraith> d'oh.  I underestimated the branching factor
07:22:08 <applicative> > let a = 3 in let a = 0 in a
07:22:09 <koeien> as a warning, let x = 3 and then let x = x + 1 does not define x to be 4 (as usual in Haskell)
07:22:10 <lambdabot>   0
07:23:30 <Jafet> let y = x + 1; let x = y
07:23:48 <Jafet> Using gensym is left as an exercise
07:25:25 <benmachine> x <- return $ x + 1
07:29:39 <Jafet> Oh
07:30:00 <Jafet> Hmm, that notation could really tidy up some of my do-blocks
07:30:25 <Jafet> x'oh'god'why'
07:31:01 <shachaf> Hmm, you can have keywords inside single quotes.
07:31:09 <shachaf> > let x'do' = 5 in x'do'
07:31:11 <lambdabot>   5
07:32:46 <kakos> Hey, does anyone know where I might be able to find usage stats on darks?
07:32:56 <kakos> God dman, autocorrect
07:33:01 <kakos> darcs
07:33:27 <Jafet> Dorks
07:33:45 <Jafet> So Mac OS also minces oaths now
07:33:56 <Jafet> But you can still take His name in vain?
07:35:03 <rwbarton> autocorrecting something to 'darks' is a pretty big position to take
07:40:44 <obiwahn> sorry i was disturbed by some guests .. i was thinking of something like:
07:41:34 <obiwahn> > let foo 0 = 0; let foo a = 1 + foo a; let foo a = 1 + foo (a-1):
07:41:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:41:40 <obiwahn> > let foo 0 = 0; let foo a = 1 + foo a; let foo a = 1 + foo (a-1); foo 3
07:41:42 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:42:16 <hpc> > do let foo 0 = 0; let foo a = 1 + foo a; let foo a = 1 + foo (a-1); foo 3
07:42:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:42:41 <hpc> > let foo 0 = 0; foo a = 1 + foo a; foo a = 1 + foo (a-1); in foo 3
07:42:42 <lambdabot>   *Exception: stack overflow
07:42:44 <obiwahn> like the fist expression will cause my program not to terminate .. but i have a second correct expression.
07:43:12 <hpc> > let foo 0 = 0; foo a = 1 + foo (a-1); in foo 3
07:43:14 <lambdabot>   3
07:43:17 <koeien> obiwahn: i'm not sure what you want to define.
07:43:21 <rwbarton> you intend to overwrite the second definition with the third I guess
07:43:58 <obiwahn> is there a way to make hgci forget about first ... you said the second shadows the fist but sometimes i need multiple lines to define a function.
07:44:17 <obiwahn> rwbarton: rwbarton is that possible somehow?
07:44:19 <rwbarton> the right way is to define your function in a file
07:44:27 <rwbarton> not really
07:44:32 <rwbarton> just write your definition in a file
07:44:34 <hpc> let foo x = blah; foo y = schnozz; foo z = quux
07:44:35 <shachaf> Semicolons.
07:44:40 <hpc> ^
07:44:50 <rwbarton> in principle you can write:
07:45:14 <rwbarton> let foo 0 = 0; foo a = 1 + foo a
07:45:17 <rwbarton> {- oh no! -}
07:45:19 <obiwahn> ok :) would be a nice feature for ghci because i make some mistakes:)
07:45:22 <rwbarton> let foo 0 = 0; foo a = 1 + foo (a-1)
07:46:05 <rwbarton> It's hard for me to see how the interface for such a feature could ever be better than editing the definition in a text editor
07:46:33 <rwbarton> since you might also want to insert cases, reorder cases, etc. etc.
07:46:47 <rwbarton> There's a reason we don't use ed any more :)
07:50:36 <Eduard_Munteanu> Maybe haskell-mode can achieve that?
07:51:00 <Eduard_Munteanu> At least the Agda emacs stuff allows you to evaluate expressions, check types etc.
07:51:25 <obiwahn> what must i do to define the main so i can compile my testfile with ghc and not use it with ghci only - i have tried something like main foo 3
07:51:46 <koeien> main should have type IO ()
07:51:46 <KirinDave> Oh man, this event broker using snap.
07:51:54 <KirinDave> So very happy to see other people working on inf I can use in Haskell.
07:51:57 <rwbarton> main = print (foo 3)
07:52:03 <koeien> obiwahn: so if you want your program to print the value of foo 3, say main = print (foo 3)
07:52:06 <rwbarton> for example
07:52:47 <obiwahn> wah look like monads i'll reach that hopefully towmorrow:)
07:52:57 <Eduard_Munteanu> And you need to ghc --make
07:53:07 <mauke> Eduard_Munteanu: even in ghc 7?
07:53:19 <Eduard_Munteanu> Oh, I dunno, but it became a habit :)
07:54:12 <koeien> obiwahn: IO is a monad, yes, but for printing stuff you can use this. If your program is a bit too slow in ghci, it might help to compile with ghc. ghc --make YourModule.hs -O2
07:55:02 <mauke> obiwahn: you don't need monads to understand IO, btw
07:55:38 <KirinDave> It helps to know io is a functor tho, which is a consequence of it being a monad.
07:56:15 <mauke> but technically you don't need even that
07:56:24 <obiwahn> i have an exam in 6 weeks time and have still a lot to do:) i plan on learning the funktional programming stuff within the next 2 weeks:) and monads are on my list:)
07:57:06 <Eduard_Munteanu> You can further try    main = do; print (foo 3); print (foo 4)     replacing ';' with newline
07:57:09 <KirinDave> obiwahn: If you are new to the functional programming scene, LYAH is highly recommended
07:57:20 <danr> obiwahn: which university are you at?
07:57:21 <KirinDave> obiwahn: Has one of the only good introductory texts on monads ever written, afaict.
07:57:34 <obiwahn> KirinDave: i have that open:)
07:57:42 <Eduard_Munteanu> (and indenting)
07:57:42 <obiwahn> danr: RWTH Aachen
07:58:15 <leod> huh! that's where i'm gonna be studying
07:58:19 <obiwahn> i have video lectures on the course:)
07:58:44 <obiwahn> http://video.s-inf.de/#FP.2005-SS-Giesl.%28COt%29.HD_Videoaufzeichnung
07:58:58 <Eduard_Munteanu> Yep, but in case you need a second exposition on the subject, LYAH might help.
07:59:15 <obiwahn> his script is linked on haskel.org as well
07:59:19 <KirinDave> So I was wondering
07:59:39 <KirinDave> Is there a way to easily make the list monad's ap do its work in parallel
07:59:47 <KirinDave> Seems like a no brainer
07:59:50 <obiwahn> Learn you another haskel has really good example especially for the beginning
07:59:55 <KirinDave> A classic example of scatter gather
08:00:56 <obiwahn> well i have to learn a bit and stop wasting time with the use of ghc:) thank you
08:00:58 <rwbarton> the work of ap in the list monad is mostly creating cons cells and closures
08:01:21 <Philonous> obiwahn:  Btw. there is a German channel as well: #haskell.de
08:01:42 <rwbarton> you can easily evaluate the resulting closures in parallel though
08:01:49 <rwbarton> er, closures? thunks
08:02:50 <obiwahn> Philonous: English literature and and other resources seem to be far more helpful in most cases:)
08:03:02 <int-e> KirinDave: you can decompose it into bind and fmap = map, and replace the fmap by parMap.
08:03:13 <KirinDave> int-e: That's what I figured.
08:03:32 <Eduard_Munteanu> Or have a look at DPH.
08:03:38 <KirinDave> int-e: I was just curious if someone had already done it.
08:03:47 <KirinDave> Eduard_Munteanu: That is tempting. I am rocking the 7.2.1
08:03:49 <Eduard_Munteanu> (though that's more than you described)
08:04:00 <lpsmith> rwbarton: a thunk is a specific kind of closure =)   But this you know, I'm sure.
08:04:06 <Eduard_Munteanu> *than what you
08:04:20 <int-e> Oh yes, dph is a good conceptual fit.
08:04:36 <obiwahn> Philonous: If my spelling etc too bad please /slap me, so that i take more time to write meaningfully sentences.
08:05:21 <lpsmith> I mean,  a thunk that doesn't have a closure is a pretty useless thunk.
08:05:21 <obiwahn> s/ing/ing is/
08:05:31 <lpsmith> At least in Haskell
08:07:01 <Philonous> obiwahn:  What, no, I was merely advertising the channel because it usually is awfully quiet. I'd love to see it become more lively.
08:09:57 <Eduard_Munteanu> I suppose such channels are also nice for organising local events and such stuff. But yeah, as far as learning resources are concerned, it's probably better to consider english materials first.
08:16:49 <Eduard_Munteanu> This channel is also quiet at times, it seems... :)
08:18:17 <dafis> sssh! you're disturbing the peace
08:38:28 <kate_r> in logic, is there a difference between a := b and a = b?
08:40:15 <byorgey> kate_r: it depends on how := and = are defined in a particular context.
08:40:17 <Eduard_Munteanu> kate_r: assignment vs equality?
08:40:39 <roconnor> I try to use a := b as a definition of a, and a = b as a logical proposition about a and b
08:40:49 <byorgey> kate_r: but generally speaking, I would interpret  a := b  as "a is defined to be b" or perhaps "b is assigned to a", whereas  a = b  is the proposition that a and b are equal.
08:40:54 <kate_r> yeah, that's my interpretation. definition vs. equality.
08:41:09 <kate_r> but what does it mean by definition. how is that different to an axiom that asserts a = b
08:41:34 <kate_r> a := b implies a = b, right
08:41:50 <byorgey> kate_r: well, equality might not be defined for whatever sort of things a and b are
08:41:53 <roconnor> kate_r: a := b is implying that this extentsion is definitional and hence it is a conservative extension.
08:41:55 <kate_r> but is there anything else more?
08:41:58 <byorgey> but you can still define a as an alternate name for b
08:42:11 <roconnor> kate_r: where as adding random axioms may not be conservative
08:43:05 <roconnor> so in some sense there is no difference than adding an axiom; but it provides a hint to the reader as to what to expect from this extension.
08:43:19 <kate_r> roconnor, but if a is already an existing symbol in the theory, a := b could be redefining a, thus making it a non-conservative extension
08:43:38 <roconnor> kate_r: if a already exists as a symbol then a := b ought to be an error.
08:44:16 <Eduard_Munteanu> Yes, in   a := b => a = b   that follows from the reflexivity of '='
08:44:29 <kate_r> byorgey, ok, so lhs := rhs is seen as having lhs as an abbreviation of rhs?
08:44:39 <roconnor> a defintional extension does two things: it extends the language, and adds a new defining axiom
08:46:29 <kate_r> roconnor, ok. so if a is a new symbol, a := b makes it a conservative extension. that is despite b being an existing symbol or not?
08:47:26 <roconnor> b should be a term made up of existing symbols
08:48:20 <kate_r> roconnor, it could also be made up of new symbols, right?
08:48:42 <roconnor> kate_r: nope, b should not contain any instances of a
08:48:52 <roconnor> any occurances of a
08:49:02 <kate_r> roconnor, sure. but other new symbols beside a, if any.
08:49:20 <roconnor> kate_r: definitional extensions only add one symbol, 'a', at a time.
08:49:24 <kate_r> oh?
08:49:32 <roconnor> you can make a series of defintionl extensions
08:49:35 <roconnor> one after another
08:50:08 <kate_r> roconnor, why can't a definitional extension introduce multiple new symbols?
08:51:25 <roconnor> kate_r: because each independent occurence of a new symbol somewhere in a term in the new langauge has to be able to be removed by replacing it by its definition
08:51:48 <roconnor> so all the definitional extensions my be of the form "new symbol" := "old term"
08:52:09 <roconnor> with a single new symbol on the LHS
08:53:42 <kate_r> roconnor, if a theory T' extends T with new symbols a,b and a definition a := b and b := a. still T' doesn't prove more theorems in the language of T, right?
08:53:53 <kate_r> roconnor, because a,b aren't in the language of T.
08:54:49 <roconnor> kate_r: that right. That wouldn't be a proper (series of) defintional extension, but it would still be conservative.
08:54:58 <roconnor> kate_r: not every conservative extension is definitional
08:55:05 <roconnor> but every definitional extension is conservative.
08:55:28 * roconnor double checks the definition of conservative extension
08:55:52 <roconnor> yep
08:55:55 <roconnor> I think that is right
08:56:48 <kate_r> roconnor, ok i'm looking at a definition for definitional extension: http://books.google.co.uk/books?id=Rf6GWut4D30C&pg=PA60&lpg=PA60&dq=%22definitional+extension%22&source=bl&ots=IcJAVp61NV&sig=a8WViG6a5PKV6T5qhDfahHj2wdE&hl=en&ei=cU1mTsy5L8PG8QON04WqCg&sa=X&oi=book_result&ct=result&resnum=3&ved=0CCYQ6AEwAg#v=onepage&q=%22definitional%20extension%22&f=false
08:57:16 <kate_r> roconnor, it says that a definitional extension of T to L+ is a theory euqivalent to T U {s : S a symbol in L+ \ L} where for each symbol S in L+\L
08:57:46 <kate_r> so it seems to accept cases where multiple new symbols are introduced in L+
08:57:54 <roconnor> ah okay
08:58:19 <roconnor> that is a bit of a looser definition of definitional extension
08:58:34 <roconnor> but all the terms on the RHS must be from L.
08:58:47 <roconnor> and cannot use any new symbols.
08:58:48 <kate_r> so i guess my example that a,b are introduced with a := b and b := a is a definitional extension?
08:58:53 <roconnor> nope
08:59:01 <kate_r> oh
08:59:03 <kate_r> yes you're right
08:59:11 <kate_r> 6.10 s is an explicit definition of S in terms of L
08:59:50 <rostayob> Is there something like a type safe mapping? So something String -> a, where I can define from time to time which keys I'll have? Is creating a separate data type for the key the only solution?
08:59:51 <roconnor> kate_r: btw ##logic is more appropriate
09:02:13 <kate_r> i think ##logic is invite only
09:02:13 <roconnor> not to my knowledge
09:02:13 <roconnor> but I could be wrong
09:02:13 <kate_r> oh, sorry. #logic is
09:02:13 <kate_r> but ##logic is not.
09:02:13 <roconnor> ah
09:02:13 <roconnor> oh
09:02:13 <roconnor> no #logic is just not a valid channel
09:02:13 <roconnor> for some policy about naming channels on freenode that I don't quite understand
09:02:13 <kate_r> right
09:02:13 <kate_r> it's much clearer now though. thanks a lot.
09:02:13 <Eduard_Munteanu> Topic-related channels are '##' IIRC.
09:02:27 <kate_r> topic-related?
09:02:39 <roconnor> rostayob: something like http://apfelmus.nfshost.com/blog/2011/09/04-vault.html ?
09:02:43 <Eduard_Munteanu> Yeah, a general topic such as logic, electronics etc... ##logic, ##electronics
09:03:01 <kate_r> there's #math
09:03:02 <obiwahn> like ##functionalprogramming:)
09:03:37 <Eduard_Munteanu> Yeah, I'm not sure it's consistently applied.
09:04:31 <kate_r> i see
09:04:44 <obiwahn> ii guess it is only enforced in cases of conflicts -- like if orace would say we create an official #java channel the commuity culd go to ##java
09:04:56 <obiwahn> tippgicht:(
09:06:46 <obiwahn> i guess it is only enforced in cases of conflicts -- like if oracle would say we create an official #java channel the community could go to ##java - excuse the bad spelling:(
09:08:16 <elliott> obiwahn: apparently everyone has to register when the new GMS thing comes out or they get moved to double hashes
09:08:55 <rostayob> roconnor: no, I was looking for something where you can define the range of the keys and it wouldn't compile if you tried to insert something not in range, but I guess that's not possible...
09:09:37 <roconnor> rostayob: I think you will more or less have to make your own data type.
09:10:48 <rostayob> roconnor: yeah I thought so...
09:16:14 <hpaste> obi pasted “match negative numbers” at http://hpaste.org/51019
09:17:01 <elliott> It is an error to use any socket options outside withSocketsDo, right? That is: You can't say (withSocketsDo (return ()) >> networkstuff)
09:17:09 <obiwahn> i am  still playing with fib:) is fib -5 does not make much sense but how could i caputre negative input without getting an error
09:17:21 <elliott> And presumably you can't just do (do socket <- withSocketsDo ...; withSocketsDo (writeToSocket socket)), either.
09:17:25 <mauke> obiwahn: fib (-5)
09:17:37 <mauke> obiwahn: otherwise it thinks you mean fib - 5
09:17:55 <obiwahn> :) thanks
09:18:51 <tromp> fib (-5) should be 5
09:19:39 <tromp> fib (-n) = 1^{n-1) * fib n
09:19:53 <tromp> i mean fib (-n) = -1^{n-1) * fib n
09:30:26 <siracusa> kosmikus: Are you around?
09:31:47 <kosmikus> siracusa: not really ;)
09:32:01 <kosmikus> siracusa: what is it?
09:32:19 <siracusa> I'm having problem building the git version of lhs2tex
09:32:59 <siracusa> It compiles fine but stops reactive on linking, so that I have to kill the lhs2tex process.
09:33:07 <siracusa> *reactiving
09:37:11 <kosmikus> siracusa: interesting
09:37:21 <kosmikus> siracusa: version of ghc?
09:37:57 <siracusa>  6.12.1
09:38:39 <siracusa> The command line of the invoked process is "dist\build\lhs2TeX\lhs2TeX" "-Pdist\build\lhs2TeX;" "-odist\build\lhs2TeX\doc\InteractivePre.tex" "--poly" "-Pdoc;" "dist\build\lhs2TeX\doc\InteractivePre.lhs"
09:39:28 <kosmikus> siracusa: ah, that's not while linking
09:39:58 <kosmikus> siracusa: but while building the users guide
09:40:40 <siracusa> Ah okay, can that be disabled on cabal build?
09:40:52 <kosmikus> siracusa: you can "touch doc/Guide2.dontbuild"
09:40:59 <kosmikus> that should disable it
09:43:02 <kosmikus> siracusa: does this work for you?
09:45:09 <jessica__> hello
09:45:53 <Eduard_Munteanu> jessica__: hi
09:46:20 <siracusa> kosmikus: Sorry, buildng on another system .. No, that doesn't help
09:46:22 <obiwahn> tromp: why does inserting "| n < 0 = n * (-1)" before the recursion not help?
09:47:43 <obiwahn> like i say if my int is smaler than 0 please make it positive
09:49:12 <obiwahn> fib 9 --> 34 , fib (-9) --> 9
09:49:13 <kosmikus> siracusa: so it fails at another point then?
09:49:58 <kosmikus> siracusa: you are building via Cabal, right?
09:50:19 <siracusa> Well, it doesn't fail, it just hangs ... yes
09:50:40 <siracusa> Probably a Windows problem?
09:52:08 <tromp> fib (-9) = fib 9 = 34
09:52:25 <kosmikus> siracusa: well, that one is always a bit tricky. but disabling documentation building as described should just work, independent of OS.
09:52:53 <tromp> you shld say fib n | n < 0 = fib (n+2) - fib (n+1)
09:53:02 <tromp> and have fib 0 = 0; fib 1 = 1
09:53:52 <tromp> > let fib 0 = 0; fib 1 = 1; fib n | n < 0 = fib (n+2) - fib (n+1) in fib (-9)
09:53:53 <lambdabot>   34
09:54:45 <siracusa> kosmikus: Okay, when building in MSYS it fails with "setup.exe: doc\Guide2.pdf: does not exist" which seems to be fine for the moment
09:55:10 <obiwahn> ah ok
09:56:38 <siracusa> kosmikus: thanks so far :-)
09:57:18 <kosmikus> siracusa: oh, right
09:57:28 <kosmikus> siracusa: then just create an empty doc\Guide2.pdf too
09:57:31 <kosmikus> and you're fine
10:02:40 <mkscrg> So what's the best way to go about resolving errors like this: "Couldn't match expected type `network-2.3.0.2:Network.URI.URI' with actual type `URI'"?
10:03:11 <mauke> reinstall some libraries
10:03:27 <mauke> or find out why you have two incompatible versions of network
10:03:36 <mkscrg> I've installed a newer version of network, so when I import Network.URI I get the newer one
10:04:00 <mkscrg> But Network.HTTP (the newest version) expects a URI from network-2.3.0.2
10:04:44 <koeien37> that might be because you're using another library which is still compiled against an older network version
10:05:20 <mkscrg> It looks like Network.HTTP is compiled against the older network
10:07:09 <mkscrg> So how does one normally deal with this kind of conflict? Is there a way to explicitly import the older Network.URI? Recompile Network.HTTP?
10:08:26 <kmc> there's PackageQualifiedImports
10:08:29 <kmc> but it's a hack
10:08:59 <kmc> sorry just PackageImports
10:09:53 <literus_maximus> Does anyone know why isInfixOf is only provided in Data.Bytestring and not Data.Bytestring.Lazy?
10:10:18 <yitz> @hoodle isInfixOf
10:10:19 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
10:10:19 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
10:10:19 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
10:10:49 <yitz> @hoogle isPostfixOf
10:10:50 <lambdabot> No results found
10:11:00 <literus_maximus> As far as I can tell, those only work on strict bytestrings or lists, no?
10:11:48 <yitz> @hoogle isSuffixOf
10:11:49 <lambdabot> Data.ByteString isSuffixOf :: ByteString -> ByteString -> Bool
10:11:49 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
10:11:49 <lambdabot> Data.ByteString.Char8 isSuffixOf :: ByteString -> ByteString -> Bool
10:12:05 <koeien37> mkscrg: best solution is to recompile all dependencies of network, I'd wager
10:12:42 <yitz> hmm, not reported by hoogle, but they all exist for both lazy and strict text.
10:13:27 <mkscrg> koeien37: i'm pretty new to cabal / haskell module management. how would i do that?
10:14:16 <koeien37> mkscrg: in this case, try cabal install http --reinstall
10:14:28 <kmc> so i was trying to find an example where GHC's {-# SPECIALIZE #-} could make a big difference, which doesn't involve type classes in the un-specialized type
10:14:35 <kmc> i wonder now if there's no such example
10:14:57 <literus_maximus> From messing with ghci, I know there's an isSuffixOf and isPrefixOf in Data.Bytestring.Lazy, but no isInfixOf.
10:15:01 <kmc> because pure parametric polymorphism can't care about the representation anyway
10:15:04 <kmc> @src isInfixOf
10:15:05 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
10:15:28 <kmc> i think there's a package that provides a more intelligent string search algorithm on ByteString
10:15:32 <dafis> literus_maximus: you can easily fake it
10:15:41 <dafis> @hackage stringsearch
10:15:42 <lambdabot> http://hackage.haskell.org/package/stringsearch
10:15:46 <mkscrg> koeien37: that did it! thanks
10:15:54 <dafis> literus_maximus: ^^^ not . null . indices
10:16:08 <kmc> http://hackage.haskell.org/package/stringsearch
10:16:34 <yitz> weird - ByteString.Lazy does have isSuffix
10:16:40 <yitz> Of
10:16:55 <literus_maximus> Cool, I'll go with that then.
10:16:58 <literus_maximus> Thanks!
10:17:13 <yitz> dafis: but is that subject to fusion?
10:17:43 <yitz> dafis: all the built-in ByteString functions are very fast
10:18:04 <dafis> yitz: dunno, it's pretty fast too, anyway
10:18:52 <yitz> dafis: truth is, since you're only lazily looking for the first index, it's probably just about as fast as isSuffixOf would be. just not inlined maybe.
10:19:47 <dafis> yitz: how fast it is depends on where the first match occurs
10:21:14 <yitz> dafis: right but that will also be true of isInfixOf.
10:22:22 <yitz> dafis: indicies has to keep track of the index, besides the list iteration. neither of those will add much by itself, the only question is how much those affect the code generated by fusion.
10:22:28 <obiwahn> let succ = (+) 1; let monica = 0 in succ (succ (monica))
10:22:38 <dafis> yitz: sure, the point is that the naive search would've been too slow for the bytestring authors' liking, and complicated because of chunk boundaries, so it's not in
10:23:33 <yitz> dafis: dunno. isSuffixOf is in. probably just an oversight.
10:23:36 <obiwahn> how do i change the succ so that i can write succ succ monica - i have tried infixl 8 succ
10:23:42 <yitz> preflex: seen bos
10:23:43 <preflex>  bos was last seen on #haskell 3 days, 19 hours, 3 minutes and 46 seconds ago, saying: kjslag: no, it's not a reasonable request. that's a huge change.
10:24:06 <dafis> yitz: isSuffixOf needle haystack = isPrefixOf (reverse needle) (reverse haystack)
10:24:41 <dafis> yitz: reverse is O(chunks), so it's good enough for them
10:24:49 <dafis> (and it's simple)
10:25:00 <bos> yitz: ?
10:29:47 <Yrogirg> Hello! What's the difference between terms 'pairwise' and 'mutually' in mathematics?
10:30:13 <azaq23> obiwahn: infixl exists to declare the associativity of an binary operator, where operator means specificially haskell operators - that is, an arrangement of special chars which's operation you
10:30:14 <azaq23> declare like x $$$ y, using $$$ as an example - infixl means x $$$ y $$$ z is parsed as (x $$$ y) $$$ z, infixr means x $$$ (y $$$ z) - you can't use infixl on an one-argument function and it doesn't
10:30:14 <azaq23> make sense. Function application looks always like in your first example. The most you could do was write succ (succ x) as an composition, succ . succ
10:30:21 <obiwahn> is there a way to make haskel to evaluate the innermost exp?
10:30:36 <obiwahn> haskell
10:30:58 <hvr> obiwahn: something like deepseq?
10:31:00 <koeien37> Yrogirg: it's kind of subtle. "pairwise" means looking at only two. "mutually" means looking at all of them
10:31:21 <pcavs> obiwahn: this at all helpful? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-36--33-
10:31:35 <simon> is there a standard function such as 'foo f x _ = f x'?
10:31:54 <koeien37> @pl (\f x _ -> f x)
10:31:55 <lambdabot> (const .)
10:32:30 <simon> cool
10:33:20 <koeien37> Yrogirg: googling tells me that in probability theory, pairwise independent is weaker than mutually independent
10:34:07 <obiwahn> pcavs: the call by value look good but im not good enough to understand the rest:) ill come back to that later.
10:36:11 <elliott> How does one cast a Word32 to an Int32 such that the former is interpreted in two's complement?
10:36:19 <yitz> dafis, literus_maximus: there isn't anything called indices in D.BS.Lazy. D.BS has findSubstring and findSubstring, but those are also missing from Lazy.
10:37:22 <yitz> dafis: looking at the source code, I think you're right. for lazy BS, isSuffix is just reverse . isPrefixOf . reverse, with a TODO comment.
10:37:23 <tromp> > (-1) :: Word32
10:37:25 <lambdabot>   4294967295
10:37:37 <tromp> > fromIntegral ((-1) :: Word32) :: Int32
10:37:38 <lambdabot>   -1
10:38:27 <yitz> oh hi bos!
10:38:39 <dafis> yitz: indices is in Data.ByteString.[Lazy.]Search, in the stringsearch package
10:38:54 <yitz> literus_maximus was just asking why isInfixOf is missing from Data.ByteString.Lazy
10:38:54 <dmwit> elliott: unsafeCoerce?
10:39:00 <yitz> bos ^
10:39:18 <elliott> dmwit: :(
10:39:29 <elliott> tromp: oh, thanks
10:39:31 <yitz> bos: and now i see that isSuffixOf is effectively missing too, since its implementation there is just reverse . isPrefixOf . reverse.
10:39:34 <elliott> I didn't realise fromIntegral was so lax :)
10:39:34 <dafis> elliott: fromIntegral not doing what you want?
10:39:38 <dmwit> fromIntegral seems cleaner.
10:39:38 <dmwit> yeah
10:39:46 <elliott> fromIntegral: cleaner than unsafeCoerce.
10:40:18 <dmwit> Well, really, all we know so far is that fromIntegral is cleaner for -1. ;-)
10:40:37 <yitz> bos: is it correct that this is still a TODO item?
10:40:52 <dmwit> surely not reverse . isPrefixOf . reverse
10:40:56 <dmwit> How would you reverse a Bool?
10:41:14 <yitz> dmwit: speaking loosely of course
10:41:27 <dmwit> > ap f g x
10:41:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:41:28 <lambdabot>    `GHC.Show.Show a'
10:41:29 <lambdabot>      a...
10:41:52 <dmwit> ?pl \reverse x y -> f (reverse x) (reverse y)
10:41:53 <lambdabot> flip =<< (((.) . f) .)
10:42:02 <dmwit> isPrefixOf `on` reverse
10:42:03 <dmwit> yes
10:42:06 <bos> yitz: which?
10:42:21 <elliott> dmwit: reverse True = eruT; reverse False = eslaF
10:42:40 <yitz> bos: well especially isInfixOf which is completely missing, and what literus_maximus needs
10:42:57 <bos> it's missing? oops
10:43:11 <yitz> bos: but i suppose isSuffixOf too, whose implementation is let's say quite far from optimal
10:43:20 <bos> yitz: i'm too busy to address that at at the moment, alas
10:43:26 <dmwit> > (eruT, eslaF)
10:43:27 <lambdabot>   Not in scope: `eslaF'
10:43:46 <dmwit> um
10:43:50 <bos> yitz: please either file bugs (to remind me) or send patches
10:44:26 <dmwit> > (eurT, eslaF) -- yikes on typos lol
10:44:28 <lambdabot>   (eurT,eslaF)
10:44:29 <yitz> bos: ok thanks. literus_maximus you heard it from the author right here on #haskell
10:44:36 <yitz> bos: where to file bugs?
10:44:52 <dafis> yitz: is bos involved in bytestring, btw? the .cabal file mentions only dons and duncan
10:45:14 <literus_maximus> Thanks, yitz. :)
10:45:14 <elliott> dmwit: Thank god for the looB type.
10:45:18 <dcoutts> dafis: no, he works on text
10:45:27 <dafis> thought so
10:45:37 <bos> oh, these are bytestring questions? yeah, can't help with those.
10:45:55 <dmwit> literus_maximus: isInfixOf s1 s2 = any (isPrefixOf s1) (tails s2)
10:46:27 <dmwit> Text seems to offer an isInfixOf, though, so what gives?
10:46:30 <literus_maximus> Isn't that pretty inefficient?
10:46:35 <yitz> dcoutts: is dmwit's implementation going to be decent for lazy BS? (my guess: not really)
10:46:49 <bos> dmwit: i wrote text after bytestring, and wanted a more comprehensive API
10:47:16 <dmwit> literus_maximus: Yep. Did you definitely profile and discover that isInfixOf is the bottleneck?
10:47:30 <kmc> http://hackage.haskell.org/package/stringsearch
10:47:42 <elliott> I wish isInfixOf was my bottleneck.
10:47:43 <dafis> literus_maximus: have you tried stringsearch?
10:48:01 <dcoutts> yitz: it'll work ok, and should not cause space leaks, but it's not the fastest certainly.
10:48:02 <literus_maximus> dmwit: No, it's not a huge deal. I was just hoping someone had already implemented an efficient algorithm.
10:48:21 <bos> the text package supplies fast string searching
10:48:25 <literus_maximus> dafis: Yeah, I'm trying that now.
10:48:53 <dcoutts> doing fast string searching in chunked strings is a little more tricky, that's probably why we didn't implement it
10:48:58 <dafis> literus_maximus: stringsearch uses Boyer-Moore, that should be pretty efficient
10:49:13 <Cale> Laziness makes Knuth-Morris-Pratt really easy to implement
10:49:23 <yitz> dcoutts: bos does it in text. would it be easy to port back?
10:49:34 <bos> yitz: relatively easy.
10:49:38 <Cale> http://twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell
10:49:39 <dcoutts> yitz: if there's code available I'd be happy to add it
10:49:53 <mwc> vim-fugitive pretty much made my life complete
10:49:56 <dcoutts> looks like we could steal something from the stringsearch package too
10:49:58 <bos> however, there's a subtle bug in the fast lazy search code in text.
10:50:09 <kmc> i think stringsearch has both KMP and BM
10:50:14 <mwc> If you're in the union of vim and git users, definitely check it out
10:50:16 <bos> which i haven't had time to fix.
10:50:49 <mkscrg> i notice the platform doesn't build the docs for every included package. is this intentional?
10:50:57 <literus_maximus> dafis: Yeah, that would be exactly what I was looking for.
10:50:59 <dafis> bos: any indication of what the bug might be?
10:51:01 <bos> chunked strings make many algorithms a pain in the ass to get right.
10:51:24 <dmwit> Thank Truth I don't have to think about how to get string search right for Unicode strings.
10:51:27 <dmwit> I hear it might be tricky.
10:51:29 <bos> dafis: basically the skip table isn't built correctly if you pass a specially crafted lazy string to it
10:51:42 <bos> dmwit: it depends
10:51:44 <kmc> dcoutts, oh, I had a question about bytestring which maybe you can answer.... if I convert a ByteString to a Vector.Storable (via ForeignPtr), will I run into trouble from the two libraries using different allocators?
10:52:32 <dcoutts> kmc: no, they both happen to use pinned byte arrays
10:52:46 <dcoutts> kmc: note that I don't promise to keep that in future
10:53:21 <yitz> bos: what happens when you hit the bad case?
10:54:01 <dafis> bos: and how does the bad case look?
10:54:19 <Cale> Has anyone tried copying the KMP implementation there and using it for Data.Text? It shouldn't be too hard to adapt.
10:54:46 <yitz> Cale: might not be so simple due to Unicode issues.
10:54:51 <bos> searches that should match don't.
10:55:07 <yitz> bos: ok. no segfault exploitable to root then.
10:55:16 <Cale> Well, sure. That'll be tricky regardless of which algorithm you're using.
10:55:23 <bos> Cale: text already uses boyer-moore, so there's not much value in trying KMP
10:56:49 <Cale> Well, there's some value in comparing them, perhaps, given how easy it should be to try it :)
10:57:19 * kmc waits 18 months for RAM to double, uses UTF-32, problem solved
10:57:38 <dafis> Cale: I have KMP and BM in stringsearch, excepting *very* short needles, BM outperforms KMP by  a factor > 2
10:57:58 <yitz> kmc: ah, but which normalizations have you applied?
10:58:08 <dcoutts> kmc: nah, everyone always wants it to be "fast"
10:58:42 <kmc> yeah, have to wait for cache and memory bandwidth to double too :(
10:58:49 <kmc> yitz, all of them!
10:58:54 <kmc> over and over to a fixedpoint
10:58:54 <dafis> dcoutts: wasn't "fast" one of the main points of bytestring?
10:59:06 <kmc> ByteString doesn't store Unicode text though
10:59:13 <kmc> it doesn't even begin to attempt to solve these problems
10:59:19 <kmc> some people want fast Unicode text handling
10:59:26 <dafis> kmc: sure, unicode is just a string of bytes too
10:59:37 <kmc> dafis, but you can't search Unicode text by searching its encoding as bytes
10:59:48 <kmc> not unless you've carefully normalized it
10:59:59 <dcoutts> dafis: that's how all data is represented, but that's not how you want to manipulate it
11:00:05 <yitz> dafis: no it isn't. an encoding of Unicode in a specific normalization is.
11:00:13 <dafis> kmc: you can search utf-8 text in utf-8 encoded bytestrings
11:00:20 <kmc> dafis, only if you've normalized it
11:00:35 <kmc> there are multiple ways to encode the same character in utf-8
11:00:38 <elliott> Does GHC's fancy new-ish IO system expose any nice way to find out whether a Socket has any data to be read (preferably portably), or will I have to use a low-level binding to select?
11:00:38 <kmc> e.g. combining characters
11:00:53 <kmc> System.Timeout?
11:01:01 <kmc> that might be too heavyweight, though
11:01:07 <kmc> i think it does expose
11:01:35 <kmc> bos was here a second ago ;)
11:01:36 <dcoutts> elliott: hWaitForInput ?
11:01:49 <dcoutts> elliott: or you can do non-blocking reads
11:02:00 <dcoutts> or use blocking reads + a timeout
11:02:07 <elliott> dcoutts: I'm working with SOckets, not handles, but that might work.
11:02:10 <kmc> in general, if you have to poll a socket for data, you're doing it wrong.  but there are some legit use cases
11:02:24 <elliott> kmc: Not my choice, it's part of the API.
11:02:24 <kmc> doesn't the socket expose a handle? isn't that how you do IO on it?
11:02:35 <elliott> I'm using Network.Socket.
11:02:45 <elliott> You're not meant to use the Socket after socketToHandle.
11:02:50 <kmc> ah
11:02:51 <kmc> sad
11:02:58 <elliott> Otherwise hWaitForInput would indeed work.
11:03:17 <elliott> The problem with a non-blocking read or a 0-timeout read or whatever is that I have to keep my own buffer for the read data.
11:03:26 <elliott> I'll just try and use select if there's nothing for it.
11:03:41 <dcoutts> elliott: what are you trying to do exactly?
11:03:51 <dcoutts> using select sounds wrong
11:04:41 <elliott> dcoutts: hasDataToRead :: Socket -> IO Bool.
11:04:45 <elliott> select would be used with a timeout of 0.
11:04:56 <Eduard_Munteanu> elliott: you do need some buffer management anyway to separate message boundaries, at least in some cases
11:05:16 <elliott> Eduard_Munteanu: I need no buffer management to implement what I'm implementing, happily.
11:06:19 <dcoutts> elliott: and why do you want to check if there's data without retrieving any?
11:06:32 <elliott> dcoutts: That's literally the API I'm implementing.
11:07:25 <obiwahn> what is NaN
11:07:40 <obiwahn> and how do i find out what is going wrong?
11:07:48 <incluye> it's not a number
11:07:50 <kosmikus> http://en.wikipedia.org/wiki/NaN
11:07:55 <elliott> obiwahn: floating point error
11:08:16 <elliott> you might want to try using Rationals, at least to diagnose the problem
11:09:07 <dafis> > log (-1)
11:09:08 <lambdabot>   NaN
11:09:16 <dcoutts> elliott: then perhaps the simplest thing is just to convert it to a handle
11:09:21 <dafis> obiwahn: ^^^ like that, perhaps?
11:09:28 <elliott> dcoutts: Handles don't expose the socket operations I'm doing.
11:09:34 <ion> When skipping to the beginning of a video, Youtube often says NaN:NaN instead of <MM>:<SS>.
11:09:42 <ion> </relevant-information>
11:10:33 <rostayob> Let's say I want to construct haskell expressions and type check them, is the ghc api the only way?
11:10:56 <dcoutts> elliott: in that case, I'd ask tibbe
11:10:57 <elliott> rostayob: you may be interested in http://hackage.haskell.org/package/hint
11:11:12 <elliott> dcoutts: Eh, I'm fine using the FFI to get at select(), it's just a bit of a shame.
11:11:35 <hpaste> obiwahn pasted “don't see the error” at http://hpaste.org/51021
11:12:43 <obiwahn> it was to practise the where and see if it possible to use just defined local vars within the where
11:12:49 <kmc> elliott, see also http://hackage.haskell.org/package/epoll, http://hackage.haskell.org/package/kqueue
11:13:04 <elliott> kmc: Not really relevant since I'm only using it with a timeout of 0, but thanks anyway.
11:13:28 <koeien37> obiwahn: what's the error?
11:13:32 <dafis> obiwahn: probably 0/0 or sqrt (negative number)
11:13:34 <dcoutts> elliott: it's not a bad idea to ask tibbe, he's maintainer of the package.
11:14:08 <dcoutts> elliott: ask him if it'd be a good idea to have a non-blocking recv, which would do what you want (if you use a buffer size of 0)
11:14:32 <rostayob> elliott: mhm, thanks
11:14:34 <elliott> dcoutts: Yeah, I'll put it on the TODO :-P
11:14:48 <dafis> obiwahn: add a test whether b*b-4*a*c < 0
11:14:54 <ion> obiwahn: QuickCheck might be a boon in this situation. Make a “isNotNaN” property and let QuickCheck tell you which parameters cause that.
11:14:57 <elliott> dcoutts: I don't think a non-blocking recv would do it with a 0-byte read, at least in C, but I guess the API could be generalised.
11:16:39 <dankna> dcoutts: btw, I hate to nag, but I'd like to ask you again to look at my ObjC-related cabal patches when you get the chance.  I've got two people here now who are interested in helping with one of my projects that uses them, and walking them through installing the patches is quite tedious :)
11:17:09 <dankna> I know that you're a volunteer and will have to find a chunk of free time, so I do understand that it takes a while
11:17:27 <dcoutts> dankna: mm, I'm not quite sure when I'll have the time. I'm off to ICFP soonish
11:17:35 <dankna> all right :/ that's fair
11:17:43 <ion> prop_roots_finite :: Float -> Float -> Float -> Bool; prop_roots_finite a b c = let (i,j) = roots a b c in isFinite i && isFinite j where { isFinite = not . liftA2 (||) isNaN isInfinite }
11:17:44 <dcoutts> and I've also got two GSoC project results to integrate
11:17:47 <dankna> ahh
11:17:58 <dcoutts> dankna: how big is your patch?
11:18:17 <dankna> it's split up into I think nine separate patches, each quite small individually
11:18:33 <dcoutts> I seem to recall last time we talked about it that I wasn't entirely happy with all of it
11:18:34 <dankna> some of them are just one-line corrections to regressions in my own code that I caused ><
11:18:39 <dcoutts> but I don't recall the details
11:18:53 <dcoutts> dankna: ok, well that's good
11:18:55 <dankna> well, I didn't actually do the bits that we didn't reach consensus on :)
11:18:59 <dankna> this was just preparatory work
11:19:11 <dcoutts> dankna: ah, that simplifies things :-)
11:19:13 <dankna> hehe yeah
11:19:30 <dcoutts> then perhaps it will not take as long as I was thinking
11:19:50 <dankna> I hope that's the case :)
11:20:21 <dankna> the documentation/rationale, as I said, is in the issue-tracker, and I referenced trac ticket numbers from the commit messages
11:20:35 <dcoutts> ok
11:20:54 <dcoutts> dankna: did you send the patch to me directly or the list, or is it in a ticket?
11:21:02 <dankna> to the list
11:21:05 <dcoutts> ok
11:41:06 <bos> elliott: what is it you're actually trying to do?
11:41:27 <elliott> bos: The socket stuff?
11:41:36 <bos> elliott: right
11:42:11 <elliott> bos: The API I'm implementing literally requires me to provide `isThereAnyDataToRead :: Socket -> IO Bool`.
11:42:18 <elliott> There's not any overarching goal to the use beyond that.
11:43:12 <bos> i see. i wonder why such an API.
11:44:00 <elliott> bos: It's old and not very well thought-out; the designer admits as much :)
11:44:13 <brisingr> can I somehow derive Monad on a non-homogenous data structure?
11:44:22 <bos> elliott: so why implement it?
11:44:54 <sbrg> bos: the world runs on legacy systems
11:45:23 <bos> sbrg: but why would someone want to implement a legacy API in haskell?
11:45:30 <sbrg> dealing with old, badly designed crap isn't so uncommon
11:45:41 <sbrg> bos: I don't know.. just wait for his answer
11:45:46 <hnsz> bos: There is still lots of cobol out there
11:46:13 <elliott> bos: So that my software can run the things that use it.
11:46:38 <bos> elliott: so you have an existing application in haskell? i'm confused.
11:47:05 <elliott> bos: No. I mean, the `isThereAnyDataToRead :: Socket -> IO Bool` function is then wrapped around so that the program being run can use it.
11:47:52 <bos> is that program written in some other language, then?
11:48:01 <elliott> Yes.
11:48:17 <bos> and it's interacting with haskell via the FFI, or something?
11:49:02 <elliott> bos: No. Like I said, the function is wrapped around so that the program being run can use it; my program implements an interface that the program being run utilises.
11:50:12 <bos> okay, i'll stop asking about it, since i can't follow your answers.
11:51:49 <elliott> bos: It's just non-Haskell program → talks to Haskell program → creates sockets through it → requests can-read information on those sockets.
11:52:04 <bos> ah.
11:53:44 <bos> elliott: the internals of a Socket are available to you, so you can write a function that does a zero-length non-blocking recv with just a few lines of code
11:53:57 <elliott> I thought recv of 0 bytes was invalid?
11:54:04 <elliott> Or just always returned 0.
11:55:44 <bos> elliott: it's not invalid to call with a length of zero
11:56:10 <elliott> Hmm, okay
11:57:38 <bos> elliott: it does mean that you won't be able to distinguish between "there is data to read" and "the connection has been closed" until the next time you really try to read
11:58:08 <dainanaki> quick question, how does one convert between lazy/strict bytestrings?
11:58:09 <bos> i.e. the "isDataAvailable" thing that you're being asked to do can't be written reliably without actually consuming the data
11:58:31 <elliott> bos: I think select() distinguishes it, although it might consider connection closed a read condition...
11:58:37 <bos> no, select doesn't.
11:59:04 <elliott> Right.
12:00:07 <ketil_> dainanaki, to/fromChunks?
12:01:35 <dainanaki> yes, that's what I need.
12:01:41 <dainanaki> thanks.
12:02:16 <obiwahn> is it possible to have different things in a list?
12:02:29 <obiwahn> [1,2,3,"Dog"]
12:02:33 <pcavs> obiwahn: not of different types, no
12:02:36 <obiwahn> k
12:02:40 <dafis> obiwahn: yes, but they must all have the same type
12:03:04 <pcavs> obiwahn: I don't know if this is Haskell convention/idiom but you could do a list of Either if it's just going to be two different types
12:03:18 <obiwahn> is there something like a conatianer that can keep everything?
12:04:00 <kmc> obiwahn, http://haskell.org/haskellwiki/FAQ#How_do_I_make_a_list_with_elements_of_different_types.3F
12:04:02 <pcavs> obiwahn: tuples can have different types, maybe you can store tuples in a list, not sure about the common haskell idiom here.
12:04:12 * hackagebot git-annex 3.20110906 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110906 (JoeyHess)
12:04:13 <obiwahn> like casted to void .. dump question .. i have the feeling that is against haskells nature
12:04:31 <kmc> it is, but you can do it
12:04:46 <kmc> it's more common that you'd want to make a new type and use that
12:04:49 <kmc> the link explains more
12:06:27 <obiwahn> thank you:) puh 6 hours of haskell i am done for today:)
12:07:27 <elliott> existentials are sometimes useful there, obiwahn
12:07:33 <Cale> obiwahn: The problem with a value which could have any type at all is that there is precisely nothing which you can rightfully do with it.
12:07:39 <elliott> data Showable = forall a. (Show a) => Showable a
12:07:46 <Cale> (apart from pass it around like a black box)
12:07:51 <elliott> printAll :: [Showable] -> IO (); printAll = mapM_ (\(Showable a) -> print a)
12:08:03 <elliott> most of the time, though, you probably don't want that
12:08:08 <Eduard_Munteanu> kmc: maybe you also want to mention HList among the options there
12:08:26 <Eduard_Munteanu> (or some other package that might deal with the issue)
12:08:48 <acowley> I quite enjoyed apfelmus' recent article on a kind of heterogenous collection
12:08:58 <elliott> me too, but that's not quite related to a list
12:08:59 <Eduard_Munteanu> Yeah, there's a page on that too.
12:10:03 <acowley> The problem with the existential example everyone finds first with Google is that you almost certainly want to use [String] instead
12:10:32 <elliott> acowley: Well, you might want to apply them with a bunch of different precedences :P
12:10:36 <acowley> It's a clear example for its simplicity, but, at least when I was first learning Haskell, it seemed more important than it is
12:11:05 <acowley> coming from something like Python, homogenous lists seem outrageously useless
12:11:53 <elliott> I dunno about that; most of my lists in other languages were homogeneous, even before I learned Haskell
12:12:17 <Veinor> they seem useless until you realize you don't actually care
12:12:31 <Veinor> because, yeah, pretty much all your lists are going to be homogeneous
12:12:36 <dankna> yeah.
12:12:39 <acowley> I would usually use some kind of array for a homogenous collection
12:12:50 <acowley> or vector, array-list, what have you
12:12:56 <elliott> acowley: oh, I didn't interpret list as linked list
12:13:02 <elliott> Python calls its arrays lists too, after all
12:13:08 <acowley> but the point is not that you never encounter a homogenous list, instead that it seems a crazy restriction
12:13:36 <elliott> yeah
12:13:49 <acowley> In something like Python, even if 9 out of 10 of your lists are homogenous, that last 1 seems like Mr. Johnny-on-the-Spot
12:13:58 <acowley> then you come to Haskell and you must install permanent plumbing
12:15:13 <kmc> most of the heterogeneous lists in Python are unnecessarily so
12:15:19 <kmc> i talk about that in the FAQ too
12:15:34 <kmc> in dynamically-typed languages, you abuse the type system as a single ad-hoc variant type
12:15:41 <kmc> that's because they don't provide nice ways to declare variants
12:15:49 <kmc> even though they could, without being statically typed
12:15:49 <Cale> Why put things of types which have nothing in common in a list? If you're collecting data into a list, they must have something in common, and the things they have in common can be expressed as a datatype.
12:15:59 <acowley> kmc: yes, precisely
12:16:02 <Cale> and then values of that type can be put in a list instead
12:16:09 <wavewave> hi.
12:16:31 <wavewave> Has anyone tried eclipseFP ?
12:16:52 <acowley> Cale: what they have in common is either reflection or an unwritten positional protocol
12:17:21 <wavewave> I would like to know how to browse packages installed locally.
12:18:15 <Cale> In the first case, you could instead store reflections of the values, in the second, you shouldn't be using a list at all.
12:18:28 <wavewave> I am following the videos on http://serras-haskell-gsoc.blogspot.com/2011/06/some-videos-on-haskell-browser.html
12:19:09 <kmc> Cale, right, but both of those options require you to figure out what you're doing before you write the code
12:19:24 <wavewave> it browses packages that appear in hackage but not in local package.
12:19:28 <kmc> they're incompatible with the "bang on the keyboard mindlessly until it kind of works" approach to software development
12:19:34 <Cale> heh
12:19:41 <acowley> Cale: to the first part, you're doing type-case and then possibly taking wildly different actions. To the second, it's more ad hoc
12:19:49 <kmc> there are fundamental psychological reasons why that approach will always be popular
12:20:12 <kmc> though i don't think the correct-up-front approach need be unpopular
12:20:15 <Cale> Eclipse seems really wasteful with screen real estate to me.
12:20:39 <acowley> kmc: I agree, which is why I think Haskell education has to tread around the issue carefully
12:20:46 <Cale> I don't understand why IDEs always seem to want to fill half your screen with 18 different sidebars
12:21:05 <acowley> Cale: situational awareness that trades the trees for the forest
12:21:11 <wavewave> Cale: I used emacs until now, so I agree with you to some degree but now I really want eclipseFP's browser feature. ;-)
12:21:13 <kmc> type Forest a = [Tree a]
12:21:43 <wavewave> Cale: after all, work on eclipseFP looks nice.
12:21:54 <luite> I would like to have the "type of thing at cursor" feature in emacs
12:22:02 <hvr> wavewave: yeah, I'd like that too, but w/o the eclipse brick
12:22:57 <ion> type Forest a = [Either (Stump a) (Tree a)]
12:22:59 <wavewave> anyway, I really want to use it for my local package. not global package. For them I can just use a web browser and google.
12:23:10 <Cale> I would give up syntax colouring to have correct handling of block indentation for Haskell.
12:23:30 <hvr> wavewave: it should be possible to implement something like that i emacs too
12:23:31 <acowley> kmc: I guess the point is that the editors most of use are more like a Zipper Tree
12:23:46 <acowley> Cale: that is a bold claim!
12:23:56 <ion> An editor based on Trifecta might be nice.
12:25:09 <wavewave> hvr: yes, by scion-browser or something like that.
12:25:35 <wavewave> infrastructure that EclipseFP is using is not only Eclipse specific.
12:25:38 <joachi> ion: isn't it possible to have nestled type definitions so you wouldn't need Either there?
12:26:01 <wavewave> anyway.. simply I cannot use it for my local packages.. ahh...
12:26:50 <wavewave> I thought that there must be some way to turn on some options that it automatically searches my local haddock documentations..
12:27:47 <wavewave> hopefully, I guess this will be added very soon
12:28:09 <Cale> There should be a configurable list of keywords (initially: let, do, of, where) such that any edit which causes the position of the first non-whitespace character after one of those keywords to move should cause the entire block (every line up to a line whose first non-whitespace character starts in a shallower column) to move in a corresponding fashion.
12:29:17 <simon> I have a function with several function bodies that all use the same helper functions, but 'where' apparently only applies to the last function body. should I just put the helper functions before this function?
12:29:22 <acowley> Cale: doesn't chris done's new haskell-mode do something like that?
12:30:31 <elliott> I think haskell-emacs does that, yes.
12:31:24 <Cale> oh, does it?
12:32:18 <elliott> http://chrisdone.com/posts/2011-08-21-haskell-emacs.html says yes, unless I misunderstand.
12:32:49 <KirinDave> BobFunk: Hullo.
12:33:07 <BobFunk> KirinDave: Hey!
12:33:27 <Cale> It seems to say no.
12:34:06 <Cale> It has some keys for manually reindenting blocks (C-left and C-right), but it doesn't know how to fix up the indentation automatically
12:34:24 <acowley> Ah, you're right.
12:34:35 <acowley> At least it has a notion of blocks
12:34:41 <applicative> hmm, simon, what does the function look like? can you paste something?
12:35:17 <koeien37> simon: you can put it before or after.
12:35:28 <Cale> simon: One option would be to use case for pattern matching, perhaps.
12:35:33 <acowley> Cale: Chris was here some time ago asking for input about indentation mode preferences, and he got N different answers from N different peopl who seemed to have installations of normal haskell-mode working (N/2) different ways
12:35:43 <Cale> (though that may be inconvenient if you're pattern matching on multiple parameters)
12:35:44 <koeien37> simon: if you have two functions, say f and g, you can define them in any order.
12:36:06 <simon> koeien37, I realize that that's possible even if they are mutually recursive.
12:36:15 <simon> thanks.
12:36:20 <wavewave> I just emailed to the eclipseFP developer for adding local browsing support.
12:36:42 <kmc> sweet, threadscope now shows the size of the spark pool, and other such infos
12:37:03 <Cale> acowley: One thing I've hated about emacs' haskell-mode in the past is that it seems to expect you to type part of your line before hitting tab, which I can't be bothered trying to get used to.
12:37:13 <wavewave> it is very nice that we have some decent IDEs in haskell (including haskell-mode ;) )
12:37:51 <Cale> I'm reasonably happy with just about any text editor which can convert tabs to spaces, and does a bit of syntax highlighting.
12:37:55 <acowley> Cale: yeah that's bitten me in the past, too. I honestly find myself idly typing "undefined" sometimes when my fingers are left idle by my brain
12:38:15 <Cale> But it's stupid that none of the Haskell support for stuff gets indentation handling right.
12:39:09 <applicative> simon, oh i see, I thought it was some subtlety about where clauses.  In haskell, basically everything in the module is 'mutually recursive' if need be, so order doesn't have the same significance it has elsewhere
12:39:16 <acowley> I've been quite happy with haskell-mode for the past few years, but I'm willing to believe there's a degree of Stockholm Syndrome at play
12:40:01 * applicative thinks this is the most pleasing part of haskell, it distances the module from seeming like a series of commands
12:41:06 <tac-tics> order sure does matter for piece-wise function defs
12:41:15 <Cale> I mostly use vim, and often gobby these days.
12:41:41 <Cale> I used emacs for a while, a few years back.
12:41:45 <pcavs> my only beef with haskell atm is that it doesn't have strict indentation, doesn't need to be pythonic, but I'd love it if I could just tab, and have it indent for to some largely accepted indentatin scheme
12:41:58 <pcavs> minor grievance though
12:42:11 <Cale> What do you mean by "strict indentation"?
12:42:26 <Cale> Do you mean the support for {;} block syntax?
12:43:13 <Cale> It's useful for blind people to have an whitespace-insensitive way of writing code.
12:43:41 <Cale> and for code generators (though really it's not usually such a big deal there, since prettyprinters can get indentation "right")
12:43:42 <applicative> tic tacs, of course it  matters, but, I was thinking,  not in the 'do this then do this' sort of way.   That even Agda is unrelenting on this point gives an imperative cast to the module, in my experience, close to M
12:43:44 <applicative> ML
12:44:03 <applicative> tac-tics: tac-tics rather :)
12:44:20 <acowley> the thing that drives me nuts about Python syntax these days is that I basically write code in two passes where the second pass is adding colons where needed :(
12:44:45 <Cale> Yeah, what are the colons for in Python's syntax?
12:45:05 <acowley> gotcha dots
12:45:08 <dankna> yeah, I have the same issue with Inform 7 syntax
12:45:15 <ion> The ability to write structure unambiguously in one line is great in ghci and in some actual code as well.
12:48:22 <Cale> Yeah, that too
12:48:35 <Cale> also for lambdabot
12:49:12 * hackagebot hakyll 3.2.0.6 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.6 (JasperVanDerJeugt)
12:49:14 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p * p <= n) $ primes in primes
12:49:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
12:49:33 <Cale> Nice to be able to smash things like that onto one line where needed :)
12:50:10 <ion> Not to mention adding where { … } to the bindings.
12:51:08 <Cale> Inform 7's concrete syntax seems absurdly verbose.
12:51:46 <kmc> is the Haskell Platform logo on http://en.wikipedia.org/wiki/Haskell_Platform still in use?
12:51:57 <kmc> i don't see it on http://haskell.org/platform
12:52:25 <kmc> but it is on http://haskell.org/haskellwiki/Haskell_Platform
12:53:59 <hvr> Cale: does vim have Haskell support beyond syntax highlighting and indentation?
12:54:11 <Cale> hvr: Not much.
12:54:12 * hackagebot secure-sockets 1.2.3 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.3 (DavidAnderson)
12:54:15 <Cale> (if anything)
12:54:23 <Cale> I don't know what else I'd want though.
12:54:33 <hvr> Cale: wasn't there some scion addon?
12:54:34 <Cale> So it's not like I've really explored that.
12:55:17 <hpaste> Cale pasted “highlight bad whitespace” at http://hpaste.org/51026
12:55:29 <Cale> ^^ I put that in my .vimrc though
12:55:37 <Cale> along with some other stuff
12:55:46 <Cale> set expandtab  is pretty important
12:55:53 <hvr> Cale: I do the equivalent whitespace-highlighting in emacs too :)
12:57:50 <applicative> kmc hadn't seen that logo for a while, perhaps it is being quietly dropped?
13:03:07 <hvr> what does it depend on, whether the primary git repo is on github.com or darcs.haskell.org?
13:03:20 <hvr> (for core libraries)
13:04:17 * hackagebot BerkeleyDB 0.8.4 - Berkeley DB binding  http://hackage.haskell.org/package/BerkeleyDB-0.8.4 (StephenBlackheath)
13:08:17 <dafis> hvr: I think, primarily it depends on whether it's maintained by the GHC team or individuals
13:09:12 <hvr> the stuff on https://github.com/haskell  is maintained by individuals or the ghc team?
13:09:17 * hackagebot BerkeleyDBXML 0.7.2 - Berkeley DB XML binding  http://hackage.haskell.org/package/BerkeleyDBXML-0.7.2 (StephenBlackheath)
13:09:23 <rostayob> Is there a way to parse a single, out of context haskell expression, apart from TH? I think that lambdabot does something similar
13:09:37 <rostayob> Ideally I'd like to get a HsExp (from haskell-src)
13:09:46 <rostayob> @type x + 4
13:09:47 <lambdabot> Expr
13:10:09 <rostayob> I'm not sure what "Expr" is here, but something like that
13:10:11 <dafis> hvr: methinks the stuff maintained by the GHC team has stayed at d.h.o, with mirrors on github
13:10:14 <hpc> @hoogle Expr
13:10:15 <lambdabot> module Text.Parsec.Expr
13:10:15 <lambdabot> module Text.ParserCombinators.Parsec.Expr
13:10:15 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
13:10:28 <rwbarton> that Expr is something different
13:10:31 <azaq23> Expr here is from simple-reflect
13:10:35 <hpc> ah
13:10:35 <azaq23> @hackage simple-reflect
13:10:35 <lambdabot> http://hackage.haskell.org/package/simple-reflect
13:11:00 <dafis> hvr: stuff like containers that has been taken over by individuals may have migrated to github
13:11:35 <rostayob> simple-reflect is pretty cool, but it's not what I need
13:12:20 <hvr> dafis: but curiously, containers lists "libraries@haskell.org" as its maintainer
13:12:56 <rostayob> what I'd like to have is a parser that gives me this: http://hackage.haskell.org/packages/archive/haskell-src/1.0.1.4/doc/html/Language-Haskell-Syntax.html#t:HsExp but without having to have an entire module, but out of context expressions
13:13:38 <dafis> hvr: out of date, it's now maintained by Johan Tibell and Milan Straka, cf. http://www.haskell.org/haskellwiki/Library_submissions
13:13:46 <rostayob> I can build it myself pretty easily, but I was wondering if something like that exists already
13:14:10 <dafis> hvr: I don't know whether it has migrated, though
13:14:12 <hvr> dafis: ic
13:17:24 <mwc> Is there a way to configure a library to require that all dependent executables be compiled with -threaded or similar? I have blocking FFI calls to deal with.
13:18:04 <applicative> rostayob: what is it too opaque that parseExp "x+y"   yields ParseOk (InfixApp (Var (UnQual (Ident "x"))) (QVarOp (UnQual (Symbol "+"))) (Var (UnQual (Ident "y"))))
13:18:27 <b_jonas> mwc: isn't there a way you can check at runtime at least?
13:18:53 <mwc> Guess so. Create an init :: IO () that kills the app
13:19:18 * hackagebot hexpat-pickle 0.5 - XML picklers based on hexpat, source-code-similar to those of the HXT package  http://hackage.haskell.org/package/hexpat-pickle-0.5 (StephenBlackheath)
13:19:43 <b_jonas> something like that, yes
13:19:57 <b_jonas> though I'm unsure how to test in runtime in a nice way
13:21:39 <mwc> It's mostly an irritation because you can't Ctrl-C the app when it's blocked on a 4 minute processing function because all threads are blocked from receiving signals
13:22:11 <rostayob> @hoogle parseExp
13:22:11 <lambdabot> No results found
13:22:12 <b_jonas> in runtime, it's GHC.Conc.numCapabilities
13:22:31 <rostayob> applicative: I'm not sure I understand what you mean, is parseExp a function?
13:23:14 <applicative> yeah, in Language.Haskell.Exts.Parser  there's also e.g. parseDecl and so forth
13:24:00 <rostayob> applicative: oh, I guess I should have looked at haskell-src-exts. thanks
13:24:52 <applicative> it's just that the type has to take account of so much it's a little hard to read the parse result.
13:24:55 <applicative> eg parseDecl "sq x = x*x" =  ParseOk (FunBind [Match (SrcLoc {srcFilename = "<unknown>.hs", srcLine = 1, srcColumn = 1}) (Ident "sq") [PVar (Ident "x")] Nothing (UnGuardedRhs (InfixApp (Var (UnQual (Ident "x"))) (QVarOp (UnQual (Symbol "*"))) (Var (UnQual (Ident "x"))))) (BDecls [])])
13:26:01 <rostayob> applicative: I won't be parsing functions, just simple expressions. it should be enough.
13:26:14 <rostayob> (functions declarations)
13:26:54 <rostayob> I'm coding a templating system, and I just need to parse haskell expressions of type Bool or IsString or something like that for conditionals and to embed things in the html
13:26:56 <mwc> regions is pretty nice, finally got to use impredicative types in anger
13:34:51 <gusan0r> Hi exist any chan in spanish lenguaje ?
13:35:01 <copumpkin> #haskell.es maybe
13:35:14 <copumpkin> pero no hay nadie
13:35:15 <gusan0r> thx =)
13:35:48 <gusan0r> copumpkin, privete ?
13:35:54 <gusan0r> private* ?
13:47:26 <ddarius> Cale: There is/was a rather involved Haskell mode for vim that does far more than syntax highlighting.
13:50:04 <applicative> is it easy to install the new talk-of-the-town haskell-mode for emacs, the chrisdone one?
13:50:59 <elliott> applicative: I gather you're not meant to use it yet; all that's provided is a script that sets up its own special Emacs configuration for you to try it out in
13:51:40 <ddarius> Cale: http://projects.haskell.org/haskellmode-vim/screencasts.html is one of them.
13:52:19 <applicative> hmm, maybe I will wait then, my .emacs is the most loathesome incompetent elisp soup already...
13:53:03 <nyingen> ddarius: but it doesn't do auto-indent?
13:53:22 <nyingen> that was half the reason I installed it, and I was pretty disappointed
13:54:28 <ddarius> Unless you universally used braces and semicolons, Haskell code can't be auto-indented.
13:54:45 <nyingen> the emacs mode supports two kinds of auto-indent
13:54:56 <nyingen> it's not perfect, but it's better than whaling on the tab key all the time
13:55:34 <ddarius> http://www.vim.org/scripts/script.php?script_id=1968
13:55:57 <nyingen> maybe I'll give that a try
13:56:01 <ddarius> I just use ai.  It works fine for me.
13:56:04 <elliott> nyingen: Funny, repeatedly pressing the tab key is what I usually do with haskell-mode's indentation.
13:56:10 <elliott> It seems to try and pick the worst indentation possible.
13:57:31 <nyingen> I realize it's not going to be possible to auto-indent arbitrary haskell code perfectly, but in many cases a good guess can be made
13:58:07 <Cale> Pressing the tab key for the second line of each block isn't so bad. As long as following lines are indented the same as the previous, you don't have to do much.
13:58:31 <nyingen> Yeah, I guess any auto-indent function has to be measured against an "autoindent" baseline
13:58:54 <Cale> But preserving relative alignment while moving code around would be really nice, and yet no haskell editor mode I'm aware of does it.
13:59:05 <nyingen> hmm
13:59:06 <Cale> Yi makes an attempt at it, but ultimately gets it wrong.
13:59:31 <applicative> i think the best approach is to view matters of indentation as artistic; everything must be determined, in the writer's imagination, by the meaning of the expression being defined.
14:00:00 <Cale> (but what it does is good enough to solve the problem of adding parameters to a function where a block starts on the LHS of the definition)
14:04:47 <ddarius> Neil's C# tip might actually be useful for me.
14:05:17 <ddarius> Collapsing Brill waves: http://www.youtube.com/watch?v=CMm_LNKMwz4
14:09:43 <xenocryst> I have a list :: [[Int]] and I want to find the longest element in it. I was thinking of doing maximumBy (\a b -> max (length a) (length b)) but then I'd have to go through the list again to find the matching element
14:09:49 <xenocryst> it also seems really ugly
14:09:53 <mwc> I'm using impredicative types. I have a value of [forall a. ClassConstaint a b => Foo a] and a function [forall a. Foo a] -> [b]. Why can't I apply the former to the later without a type error complainin that it expected forall a. Foo a but actually got forall a. Constraint a b => Foo a?
14:10:28 <mwc> The constraint should be irrelevent here, no?
14:10:28 <Botje> xenocryst: you could compute the length once.
14:10:40 <sbrg> > maximumBy (comparing length) [[1,2,3],[1,2]]
14:10:41 <lambdabot>   [1,2,3]
14:10:44 <sbrg> @ xenocryst
14:11:00 <Cale> or:
14:11:05 <Botje> xenocryst: maximumBy (compare `on` snd) $ map (\x -> (x, length x)) list
14:11:19 <xenocryst> comparing! I had never heard of that
14:11:20 <xenocryst> thanks guys
14:11:27 <sbrg> xenocryst: aye, it's a beauty
14:11:36 <sbrg> @hoogle comparing
14:11:37 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:11:42 <elliott> comparing is just (compare `on`)
14:11:53 <elliott> (f `on` g) = \x y -> f (g x) (g y)
14:11:53 <sbrg> :t compare
14:11:54 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
14:11:56 <Cale> Yeah, it's a little function I invented. It just does  comparing p x y = compare (p x) (p y)
14:12:10 <sbrg> Cale: you invented it?
14:12:13 <Cale> yep
14:12:14 <xenocryst> elliott: I had never heard of compare either
14:12:16 <sbrg> wicked
14:12:26 <acowley> It took me some time to get going, but the new test suite support in cabal in conjunction with test-framework is quite nice!
14:12:32 <elliott> xenocryst: heh :)
14:12:35 <sbrg>  http://www.hackforums.net/showthread.php?tid=1641992
14:12:39 <sbrg> ugh
14:12:41 <sbrg> ignore that link
14:12:43 <sbrg> mispaste
14:12:50 <sbrg> and it's a retarded site
14:12:58 <elliott> Cale: I don't like comparing because hlint tells me to use it instead of (compare `on`) :(
14:13:16 <mux> rightly so
14:13:39 <mux> I love on, but I'm not going to write compare `on` snd when I can write comparing snd
14:14:00 <sbrg> comparing is more idiomatic
14:14:04 <sbrg> it reads like english
14:14:10 <mux> and shorter; and it's just one token
14:14:12 <elliott> "compare on second"
14:14:17 <elliott> mux: I prefer generality :P
14:14:23 <elliott> on is a generalisation of comparing, IMO
14:14:23 <mux> and it's visually lighter too, because of the backquotes you have to use on 'on'
14:14:30 <mux> yes it is
14:16:10 <Cale> foldr is a generalisation of map as well ;)
14:17:14 <mike-burns> I only use lambdas, for maximum generalizations.
14:17:29 <Cale> But I don't really care what you use. I came up with comparing, and posted about it on the mailing list, and then people eventually wanted to generalise it to other cases, specifically with (==), and so someone came up with on for that
14:17:38 <pcavs> single argument lambdas at that
14:18:14 <Dashkal> λa.b
14:20:51 <Dashkal> Or "λf.(λx.f (x x)) (λx.f (x x))"  That's always fun. (I so wish I could wrap my head around fix...)
14:21:14 <ddarius> fix f = f (fix f), what's so complicated?
14:21:24 * ddarius used fix today in his work C# code.
14:21:53 <Botje> fix("ALL THE THINGS!")
14:21:58 <Dashkal> ddarius: I have yet to grok that function.  I have no idea how to make it work
14:22:00 * ddarius also has a continuation monad, but that was less unexpected.
14:22:00 <mike-burns> Your coworkers must love that.
14:22:04 <mux> ddarius: for legitimate reasons, or just to annoy the coworkers?
14:22:32 <ddarius> For legitimate reasons.
14:22:49 <sbrg> mux: The use was probably legitimate. The lengthy comment he attached to it which no one grokked but him was to annoy the coworkers :P
14:25:06 <ddarius> Choice of prefix or infix leads to the awkward situation of having the exact same function named both After and Before.
14:25:39 <KitB> What would be a function that had this type signature:
14:26:09 <KitB> (Monad m) => (a -> m b) -> m [a] -> m [b]
14:26:20 <elliott> :t fmap . mapM
14:26:21 <lambdabot> forall (f :: * -> *) a (m :: * -> *) b. (Functor f, Monad m) => (a -> m b) -> f [a] -> f (m [b])
14:26:23 <elliott> Or, hmm
14:26:30 <shachaf> @ty (:[cake])
14:26:31 <Veinor> @hoogle (a -> m b) -> m [a] -> m [b]
14:26:32 <lambdabot> [[Char]] -> [[[Char]]]
14:26:32 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:26:32 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:26:32 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:26:35 <ddarius> :t join . liftM . mapM
14:26:36 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
14:26:37 <lambdabot>     Probable cause: `liftM' is applied to too few arguments
14:26:37 <lambdabot>     In the first argument of `(.)', namely `liftM'
14:26:46 <elliott> KitB: You probably want (a -> m b) -> [a] -> m b
14:26:47 <elliott> which is mapM
14:26:48 <ddarius> :t join . liftM .: mapM
14:26:50 <lambdabot> forall a1 b. (a1 -> a1 -> b) -> [a1] -> [[b]]
14:26:58 <ddarius> :t join .: liftM .: mapM
14:27:00 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
14:27:00 <lambdabot>     Probable cause: `liftM' is applied to too few arguments
14:27:00 <lambdabot>     In the first argument of `(.:)', namely `liftM'
14:27:02 <shachaf> @ty (:[mmm, cake])
14:27:03 <lambdabot> [[Char]] -> [[[Char]]]
14:27:17 <Saizan> ?ty (=<<) . mapM
14:27:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m [b]
14:27:18 <elliott> > mmm
14:27:19 <ddarius> :t join .: liftM . mapM
14:27:20 <elliott> > cake
14:27:20 <lambdabot>   ["delicious"]
14:27:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m [b]
14:27:22 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
14:28:03 <Botje> KitB: \f m -> m >>= mapM f
14:28:46 <Veinor> @pl \f m -> m >>= mapM f
14:28:46 <lambdabot> (=<<) . mapM
14:28:51 <Veinor> @pl \m f -> m >>= mapM f
14:28:52 <lambdabot> (. mapM) . (>>=)
14:29:57 <dafis> @pl \f l -> join (liftM sequence $ mapM f l)
14:29:58 <lambdabot> ((sequence =<<) .) . mapM
14:30:16 <dafis> @ty ((sequence =<<) .) . mapM
14:30:17 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m (m a)) -> [a1] -> m [a]
14:30:50 <dafis> @pl \f l -> join (liftM sequence $ liftM mapM f l)
14:30:51 <lambdabot> fmap ((sequence =<<) . mapM)
14:31:03 <ddarius> :t join .: liftM . sequence .: map
14:31:04 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> m [a1] -> m [a]
14:31:07 <dafis> @ty fmap ((sequence =<<) . mapM)
14:31:09 <lambdabot>     Couldn't match expected type `[a1] -> a'
14:31:09 <lambdabot>            against inferred type `[a]'
14:31:09 <lambdabot>       Expected type: [a1] -> [[a1] -> a]
14:31:12 <ddarius> That's ridiculous.
14:39:27 <dafis> @ty ((sequence =<<) .) . fmap . map
14:39:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m [a1] -> m [a]
14:44:24 <KitB> I love how a simple question about a type can result in that ^_^
14:44:51 <keep_learning> hello all
14:44:57 <Botje> hallo
14:45:00 <kmc> hi keep_learning
14:45:23 <keep_learning> i was going through this page http://www.cs.york.ac.uk/fp/darcs/tagsoup/tagsoup.htm
14:45:31 <keep_learning> and after reading it
14:45:52 <keep_learning> i tried to install tagsoup using cabal install tagsoup
14:46:25 <keep_learning> its showing Text.HTML.TagSoup
14:46:39 <keep_learning> but its not showing Text.HTML.Download
14:46:58 <keep_learning> how can i install this package ?
14:47:10 <shachaf> @ty fmap (fmap (fmap (fmap join (fmap sequence))) fmap) fmap
14:47:12 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m [a1] -> m [a]
14:47:16 <elliott> keep_learning: http://hackage.haskell.org/package/tagsoup shows that module.
14:47:19 <elliott> You should already have it.
14:47:50 <elliott> Ah, hmm.
14:47:51 <elliott> keep_learning:
14:47:58 <elliott>     /DEPRECATED/: Use the HTTP package instead:
14:47:59 <elliott>     > import Network.HTTP
14:47:59 <elliott>     > openURL x = getResponseBody =<< simpleHTTP (getRequest x)
14:48:04 <elliott> keep_learning: So do that :)
14:48:32 <keep_learning> elliott, thank you
14:48:44 <shachaf> @ty fmap (fmap (fmap join (fmap sequence))) (fmap fmap fmap)
14:48:45 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m [a1] -> m [a]
14:49:32 <kmc> so what are the Haskell tools i should mention in a "why learn Haskell" talk?  i have ghc, ghci, QuickCheck, hpc, -prof, hp2ps, threadscope, haddock, cabal, hayoo
14:49:47 <kmc> QuickCheck is a library, not a tool, but it fits the theme pretty well
14:50:08 <ddarius> hayoo, not hoogle?
14:50:08 <kmc> i also mentioned some of the FFI helper tools in passing
14:50:23 <kmc> hayoo searches all of Hackage, which is more impressive imo
14:50:29 <Eduard_Munteanu> kmc: haven't I mentioned DPH once upon a time?
14:50:31 <kmc> they're both good tools but it seemed redundant to include both
14:50:32 <shachaf> @ty fmap fmap fmap fmap fmap fmap fmap (fmap join) (fmap sequence) (fmap fmap fmap)
14:50:33 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f [a1] -> f [a]
14:50:33 <kmc> yeah Eduard_Munteanu
14:50:40 <elliott> cabal-dev? I guess that doesn't much inspire people to learn Haskell - "this solves Haskell packaging being horrific!"
14:50:44 <ddarius> kmc: lambdabot!
14:50:49 <Eduard_Munteanu> Probably not what you want if you're looking for stuff that works today.
14:50:51 <kmc> yeah, I have a slide on lambdabot
14:50:56 <dalaing> kmc: what's the target audience like?
14:50:59 <kmc> she's in with TryHaskell and Haskell Platform
14:51:06 <kmc> Eduard_Munteanu, i don't think DPH fits that theme at all
14:51:17 <kmc> it could fit in the section where I talk about forkIO, STM, and pure parallelism
14:51:18 <elliott> kmc: you might want to show how emacs/inferior-haskell make interactive development and debugging awesome? i dunno the crowd
14:51:30 <Eduard_Munteanu> Ah, you're looking for some sort of tools.
14:51:30 <elliott> I mean, compared to tabbing to a terminal and recompiling :P
14:51:36 <kmc> i expect a lot of emacsers as I'm giving the talk at MIT
14:51:48 <kmc> but i'm not personally familiar with any fancy Haskell editor mode / IDE
14:52:02 <elliott> fair enough, but they might not know about the ghci integration
14:52:13 * ddarius is pretty sure emacs and a haskell-mode would not impress most mainstream developers.
14:52:13 <kmc> cabal-dev is cool, though
14:52:15 <elliott> it's not really fancy, it just opens ghci in a split screen on C-c C-l / reloads if it's already open, and links the errors, but it's really useful :)
14:52:20 <kmc> maybe it deserves a bullet point on the cabal slide
14:52:23 <elliott> ddarius: I dunno, Python developers...
14:52:40 <kmc> fortunately i'm not talking to "mainstream developers"
14:52:48 <kmc> but i do want the slides to be generally useful
14:52:50 <elliott> kmc: I guess if they know Ruby or Python cabal-dev might interest them, because it's similar to RVM/virtualenv
14:53:04 <elliott> dunno if it'd interest any given random programmer though
14:53:28 <ddarius> kmc: The statement was more a counterpoint to elliott's enthusiasm about emacs and a haskell mode.
14:53:47 <dalaing> kmc: is there a place for Criterion in teh talk?
14:53:50 <dalaing> kmc: I kept reading about haskell, but one of my two tipping points towards actually using it was when I learnt about QuickCheck and Criterion
14:53:55 <kmc> hmm
14:53:57 <elliott> I'm not that enthusiastic, I just think it's much nicer than most other languages offer :)
14:53:58 <kmc> that's a very good suggestion
14:54:01 <elliott> Lisp has the same stuff of course.
14:54:08 <shachaf> @ty fmap (fmap fmap fmap fmap) fmap fmap fmap fmap fmap fmap fmap fmap (fmap fmap fmap fmap) fmap fmap fmap fmap join (fmap sequence) (fmap fmap fmap)
14:54:09 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f [a1] -> f [a]
14:54:10 <ddarius> Lisps have much more.
14:54:11 <shachaf> :-(
14:54:23 <ddarius> C# and Java have much more in some respects, less in others.
14:54:25 <elliott> ddarius: It's true, SLIME > inferior-haskell.
14:55:16 <ddarius> shachaf: Almost there.
14:55:47 <shachaf> I'd say that ddarius is making fun of me, but it's more that I'm making fun of myself.
14:56:24 <elliott> shachaf: What are you even doing.
14:56:26 <elliott> Oh.
14:56:30 <shachaf> I do wonder if I've missed something, though, with my mechanical fmapping procedure.
14:56:42 <shachaf> elliott: I was hoping to eliminate all the parentheses.
14:56:55 <elliott> shachaf: Godspeed.
14:57:14 <ddarius> @google okasaki flattening combinators
14:57:17 <lambdabot> http://portal.acm.org/citation.cfm?id=967785
14:57:18 <lambdabot> Title: THEORETICAL PEARLS: Flattening combinators: surviving without parentheses
14:58:13 <shachaf> Oh, hmm.
14:58:37 <keep_learning> is there any haskell library which converts the html ot pdf ?
14:58:40 <shachaf> acm.org isn't very download-friendly, is it.
14:58:56 <elliott> keep_learning: pandoc
14:59:05 <elliott> I think it goes via LaTeX so YMMV as far as how much HTML it can do.
14:59:31 <elliott> Prince XML charge quite a lot to being able to do that well and quickly, so I understand it's rather non-trivial.
14:59:45 <elliott> (Irrelevantly but interestingly: apparently written in Mercury.)
15:00:02 <Axman6> keep_learning: any decent browser should be able to do it via pdf printing
15:00:10 <elliott> oh, that's a good idea
15:00:20 <elliott> might be hard to automate that from haskell though
15:00:34 <Axman6> indeed
15:00:45 <ddarius> putStrLN "Open browser.  Print." >> exitSuccess
15:00:56 <keep_learning> elliott, actually i am trying to write a small script which downloads a html page
15:01:07 <keep_learning> and converts it into pdf
15:01:27 <keep_learning> *haskell script
15:01:48 <ddarius> @google "small programming language"
15:01:49 <lambdabot> http://www.csci.csusb.edu/dick/samples/small.html
15:01:50 <lambdabot> Title: Sample: The SMALL Programming Language
15:02:03 <elliott> keep_learning: Well, you probably want to use an existing tool for that, really.
15:03:12 <keep_learning> elliott,  actually i just wanted to do it using haskell
15:03:45 <elliott> Well, OK, but it's not like you'll necessarily find a Haskell library so that you can write your very complex task in a few lines :)
15:03:47 <keep_learning> elliott, it may be possible to do more easily using python but i am not sure
15:03:59 <elliott> Why don't you want to use any existing tool that might exist?
15:03:59 <Lajla> Twey, my beloved.
15:04:07 <elliott> keep_learning: But hey, you could give Pandoc a try.
15:04:11 <keep_learning> elliott, :)
15:04:14 <elliott> That's written in Haskell, and has a library, and purports to do that.
15:04:33 * hackagebot BiobaseXNA 0.5.2.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.2.0 (ChristianHoener)
15:04:37 <keep_learning> elliott, sure i will give a try Pandoc
15:11:09 * shachaf can't find a free download of the paper ddarius mentioned.
15:12:23 <elliott> I think I read that paper.
15:12:31 <elliott> Or at least one paper that presented a paren-less combinator set.
15:13:13 <elliott> shachaf: http://www.eecs.usma.edu/webs/people/okasaki/jfp03.ps
15:13:25 <elliott> Doesn't seem to load here; ymmv.
15:14:30 <elliott> Oh, it does.
15:14:31 <shachaf> Ah, thanks. http://www.google.com/search?q=cache:www.eecs.usma.edu/webs/people/okasaki/jfp03.ps
15:15:20 <elliott> shachaf: Loads without cache for me, just high latency.
15:16:07 <elliott> Oh, nice, it's even a two-combinator paren-less base.
15:17:18 * kmc -fforce-recomp -prof -rtsopts -auto-all -caf-all
15:17:23 <kmc> MOAR FLAGZ
15:17:35 <elliott> hmm, what does -caf-all do?
15:17:47 <kmc> puts cost centers on CAFs
15:17:49 <kmc> not very well
15:22:01 <Itkovian> how do I 'map' an m (Int -> a) onto a [Int]?
15:22:18 <Itkovian> I cannot seem to wrap my head around it, though that may be because it's late
15:22:22 <Axman6> as in m is some monad?
15:22:31 <shachaf> Itkovian: That depends on what m is. In general, you don't.
15:22:38 <rwbarton> :type fmap fmap
15:22:45 <shachaf> If you can get an (Int -> a), you can map it over [Int] using map.
15:22:48 <Itkovian> yeah, m is some monad
15:23:04 <Itkovian> maybe I need to rethink the rest of my code.
15:23:15 <Axman6> you can have something of type m (Int -> a) -> [Int] -> m [a] easily enough
15:23:42 <copumpkin> assuming m is a functor
15:24:33 <Itkovian> Axman6: yes?
15:24:38 <copumpkin> :t \ff xs -> fmap (\f -> map f xs) ff
15:24:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> [a] -> f [b]
15:24:44 <Axman6> > let foo mf xs = mapM (\x -> mf >>= \f -> return f x) xs
15:24:46 <lambdabot>   not an expression: `let foo mf xs = mapM (\x -> mf >>= \f -> return f x) xs'
15:24:51 <Axman6> :t let foo mf xs = mapM (\x -> mf >>= \f -> return f x) xs in foo
15:24:53 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m (m b) -> [a] -> m [b]
15:25:02 <Axman6> hmm
15:25:07 <benmachine> :t (mapM =<<)
15:25:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ([a] -> a -> m b) -> [a] -> m [b]
15:25:21 <Axman6> :t let foo mf xs = mapM (\x -> mf >>= \f -> return (f x)) xs in foo
15:25:21 <copumpkin> mine works better :P
15:25:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> [a] -> m [b]
15:25:49 <Axman6> owst: ah, but yours assumes you only want to pull out one function :P
15:26:00 <copumpkin> huh?
15:26:02 <Axman6> uh, copumpkin. c is wight next to o >_>
15:26:29 <Axman6> copumpkin: what if the mf in my example returns a new function in each invocation?
15:26:32 <elliott> Itkovian: why is the function inside a monad?
15:26:40 <Itkovian> good question.
15:26:42 <copumpkin> Axman6: a functor does that too
15:26:55 <Axman6> does it? hmm
15:27:01 <rwbarton> Axman6 mean you might want to apply the effects of m (Int -> a) once per list element
15:27:04 <Axman6> no it doesn't
15:27:05 <rwbarton> *means
15:27:09 <Axman6> rwbarton: yes
15:27:10 <copumpkin> oh
15:27:17 <copumpkin> I see
15:27:20 <Itkovian> elliott: right, right
15:27:25 <rwbarton> so that's some other operation
15:27:37 <Axman6> but, that's probably pretty unlikely =)
15:27:47 <copumpkin> Itkovian: which semantics do you need? :D
15:27:48 <Itkovian> Well, I have some m [a] that's the result of a previous operation. Maybe I just need to drop it all in the m and be done with it.
15:27:57 <Itkovian> sec guys, it's late
15:28:08 <Itkovian> *facepalm*
15:28:22 <Itkovian> trying to explain things really helps, I think
15:28:24 <Itkovian> lemme see
15:28:25 <Eduard_Munteanu> :t \mf x -> mf >>= ($ x)
15:28:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> a -> m b
15:35:17 <Itkovian> I really ought to go sleep
15:41:41 <hkarim> Can't figure out how to do heterogeneous list, can someone please help on this: http://pastebin.com/NQaGjtG2
15:41:44 <mauke> The paste NQaGjtG2 has been copied to http://hpaste.org/51027
15:42:42 <elliott> hkarim: You probably don't want that.
15:43:10 <elliott> hkarim: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ might help.
15:43:25 <elliott> Hmm, you do have the parameter there though.
15:43:30 <elliott> hkarim: How are you trying to do the existential list?
15:43:44 <elliott> Oh, I see. hkarim: You need to create an existential wrapper for each class you want an existential list of.
15:43:52 <shachaf> What's with all the classes?
15:43:57 <elliott> e.g. data AnyNamedElement = forall n. (NamedElement n) => AnyNamedElement n
15:43:59 <elliott> Then a list of that.
15:44:02 <elliott> But yeah, I'm sceptical of this.
15:44:04 <shachaf> You can use an existential type, but it's very possibly not what you want.
15:44:34 <hkarim> but I don't want to define ADTs (yet)
15:44:48 <elliott> Why not? They're simpler than typeclasses.
15:45:33 <hkarim> because I would possibly have several data types, don't want to add the restrictions on them
15:45:50 <shachaf> hkarim: You can do the same thing with an ADT as you can do with classes.
15:45:59 <elliott> hkarim: The record solution is literally identical to the typeclass solution. Did you read the post I linked?
15:46:01 <shachaf> See elliott's link.
15:46:20 <hkarim> No, not yet, OK will read that now
15:46:24 <elliott> We should try hiding the existence of typeclasses from people until they've used Haskell for like six months.
15:46:44 <shachaf> <kmc> s/ like six months/ever/
15:48:21 <roconnor> elliott: Helium has no type classes
15:48:26 <Eduard_Munteanu> Typeclasses can be open.
15:48:38 <Eduard_Munteanu> Unlike ADTs
15:48:47 <elliott> Eduard_Munteanu: you didn't read the post either, I take it? :)
15:48:51 <hkarim> OK, so just for my info, can I use existential annotation on a typeclass
15:48:56 <roconnor> actually the definition of Helium is something like Haskell with no typeclasses.
15:49:05 <elliott> hkarim: No. You can make an existential data type using a typeclass.
15:49:09 <elliott> But you really almost certainly don't want to.
15:49:15 <Eduard_Munteanu> Hm, I don't think I did.
15:49:45 <Eduard_Munteanu> I'm not arguing heterogenous collections might be the right thing, just noted that difference
15:49:59 <shachaf> hkarim: You can, but you probably don't want to.
15:50:00 <hkarim> elliott: Thanks
15:50:10 <elliott> hkarim: Really. You don't want to. Really. :P
15:50:17 <elliott> How long until we're yelling "don't do it"?
15:50:18 <Peaker> quicksilver's first rule of type-classes: You think you want a typeclass, you probably don't want a typeclass.
15:50:29 <hkarim> elliott: I here you :)
15:50:31 <shachaf> Eduard_Munteanu: ADTs can be open too, because they contain data. :-)
15:50:33 <mwc> Why don't you? I always thought a class constraint was the only useful way to use them
15:50:38 * shachaf there elliott.
15:50:40 <hpc> the second rule of type-classes: you don't talk about the typeclasses?
15:50:46 <Eduard_Munteanu> Heh.
15:50:47 <elliott> shachaf: You there me indeed.
15:50:57 * shachaf hird you, all right.
15:51:09 <hkarim> shachaf: Did you say I can?
15:51:20 <Peaker> hkarim: Since you have a hetero-type in a list, when you extract an element from the list -- you can only do with it what *all* of the list elements allow doing, right?
15:51:37 <hkarim> yes
15:51:39 <shachaf> Data.Dynamic
15:51:47 <mrakan> I'm using the OverloadedStrings extension, but GHC still complains a ByteString isn't an instance of IsString.
15:51:55 <mwc> Well, if you constrain on a type class you can use any typeclass operation, which is often all you need
15:52:00 <Peaker> hkarim: So what you can often do in Haskell, is *first* do all that you can do with the type, and put the results in the list, and then the list is homogenous
15:52:20 <Peaker> hkarim: since Haskell is lazy, this will not actually cause anything to get done until it is actually needed/used
15:52:28 <shachaf> For example, instead of a list of things which can be Shown, you can just use a list of Strings.
15:52:43 <elliott> Peaker: honestly, I think he has to rethink his typeclass structure before worrying about lists of them.
15:52:55 <Peaker> yeah, if the only thing common to a list of things is that you can "show" on them, you just *first* do "show" on all the list elements, and put the homogenous result (String) in the list, instead
15:52:55 <hkarim> well, that's what I am trying to do, extract list of type e where Element e
15:53:01 <elliott> that's a valid approach for good typeclasses like Show and the like, but it doesn't help if you do not want a typeclass at all.
15:53:25 <Peaker> hkarim: Type-classes are for overloading/ad-hoc polymorphism, not for coercing types into a single mold
15:54:02 <Peaker> hkarim: A record is far more appropriate if you just want to get a common thing from various differing things
15:54:38 <hkarim> Peaker: I see, just coming from OO world, but I have to think differently
15:55:00 <Peaker> hkarim: your Special/Namespace sub-classes will not be usable at all -- if you have a list of unknown-typed Element instances, anyway
15:55:06 <elliott> Yeah, typeclasses are _not_ like classes at all.
15:55:21 <elliott> It should be quite easy to convert your typeclasses into an ADT solution; the blog post I linked shows a fairly involved example of that.
15:55:48 <shachaf> elliott: Is kmc secretly training you as a replacement?
15:55:49 <shachaf> C/C++
15:56:11 <elliott> shachaf: I don't know; he _was_ part of that invasion...
15:56:17 * elliott checks for brain bugs
15:56:20 <Peaker> hkarim: if you have a list of unknown Element instances, all you can do with them is use the Element methods, which means you can just call "identifier" on them. Which means you might as well have a list of identifiers, rather than a list of Elements, and then it's a simple [String]
15:57:31 <hkarim> Peaker: Well, that's just an example of the problem I am having, Element will probably evolve
15:57:50 <benmachine> I disliked classes before it was cool
15:58:00 <roconnor> Pfft: ``A programmable electronic safety product is as safe as the process that developed it.''
15:58:07 <roconnor> what nonsense
15:58:24 <elliott> hkarim: I strongly encourage you to try doing it without typeclasses at all... it won't be hard, and you really will see everything be a lot simpler :P
15:58:29 <hkarim> Which means that I have to evolve an ADT instead of a typeclass, which enforces the contract
15:58:38 <elliott> Yeah, but the ADT is literally identical.
15:58:46 <elliott> If anything, it's more flexible.
15:59:05 <mrakan> Is there some problem with using OverloadedStrings and ByteStrings as the Map's keys? When using (lookup "key" dict where dict :: Map ByteString a) with OverloadedStrings, I get an error that ByteString is not an instance of IsString.
15:59:05 <shachaf> hkarim: What's the difference between evolving the ADT and the type class?
15:59:22 <benmachine> mrakan: weird.
15:59:32 <elliott> mrakan: Did you import Data.ByteString? p
15:59:32 <elliott> :p
15:59:40 <elliott> Is your ByteString new enough? Maybe it is too old to have that instance.
15:59:41 <Cale> Well, data Element = Element { eName :: String }
15:59:47 <Peaker> hkarim: Whatever you add to Element will be add-able to your String type. Say you add another method like:  blarg :: e -> Int   then you can use a (String, Int),  instead. If you add:  bleh :: Int -> e     then it becomes equivalent to:  (Int -> String)
15:59:47 <Peaker> hkarim: In OO, sometimes you use something like "isinstance" on the list elements -- which means your list is a "closed" set of types, and not "open", so a type-class makes no sense, and you should use an ADT
15:59:48 <mrakan> elliott: I did.
15:59:48 <hkarim> If you change a typeclass, all ADTs have to change their instances to comply, nothing other than that enforces a contract
15:59:56 <shachaf> mrakan: ByteStrings don't have an OverloadedString instance.
15:59:58 <Cale> ^^ do something like that, and then you can add those fields when you need them
15:59:59 <Peaker> hkarim: All types enforce contracts
16:00:12 <elliott> hkarim: Eh?
16:00:19 <elliott> hkarim: If you change a typeclass the instances must change too.
16:00:23 <Peaker> hkarim: f :: [Int] -> String     <-- f enforces a contract that it is given a list of Ints
16:00:29 <benmachine> Data.ByteString.Char8 has IsString
16:00:36 <benmachine> probably truncates though
16:00:49 <elliott> Ah.
16:01:02 <elliott> mrakan: yeah, import a Char8 module
16:01:27 <mrakan> shachaf, benmachine and elliott: Thank you, that did the trick!
16:01:45 <hkarim> In my code, Element should have several instances, but all my code will only reference Element type, anyone can implement a complying ADT, that was the rationale
16:02:27 <Cale> hkarim: It's possible to do a really nice approximation of OO in Haskell, I think it's actually a better approximation of OO than most typed OO languages manage, though you can't really do inheritance all that easily (it's possible, but awkward). But inheritance isn't actually all that important.
16:02:38 <Peaker> hkarim: laziness means you shouldn't have to worry about calling functions that convert your various hetero-types into a common homo-type "preemptively" (before putting into the list)
16:02:44 <elliott> hkarim: basically, you want Element to be an ADT. and if your Foo type is a Widget but has more state, then you have, e.g. in your Foo module "toWidget :: Foo -> Widget"
16:02:54 <Peaker> strict languages make existential types more useful (to defer that work)
16:02:57 <elliott> oops, forgot to translate the typenames when copying the blog post :P
16:03:28 <Peaker> (though I guess they could just suspend evaluation using an explicit suspension, too)
16:03:31 <Cale> hkarim: What you do is instead of using sum types, with different constructors for the different cases you want to have, use a product type instead, containing the operations on the data.
16:03:57 <hkarim> elliott: I still get it, the problem is the same in Scala BTW, so what you're saying makes sense
16:03:59 <Cale> What is an object if not a value which is determined by its responses to some messages?
16:04:09 <elliott> hkarim: right
16:04:16 <shachaf> Cale: Uh-oh, you're starting down a slippery slope there.
16:04:26 <Cale> shachaf: ?
16:04:29 <elliott> Alan Kayle
16:04:31 <Peaker> Cale: it's responses include self-mutations
16:04:32 <elliott> Cayle?
16:04:43 <Cale> Peaker: maaaybe :)
16:04:46 <shachaf> Cale: "what is an object if not ..."
16:05:01 <shachaf> Deckard Cale?
16:05:06 <Cale> But instead of self-mutations, it can return different versions of itself instead, if that suits us better.
16:05:15 <Cale> (it'll keep us out of IO anyway)
16:05:52 <benmachine> Cale is a replicant?
16:06:27 <Cale> So instead of something like  data GameObject = SpaceShip { position, velocity, accel :: Vector, shields :: Double, ...} | Asteroid { ...} | every other dang thing.
16:07:06 <Cale> We instead decide what operations on those things we consider important, and encode our objects as a record of the implementation of those operations.
16:07:12 <elliott> hkarim: welcome to the light side, btw :P
16:07:42 <hkarim> elliott: Oh, thanks
16:07:44 <Cale> data GameObject = GO { display :: Drawing, timeStep :: Delta Time -> GameInput -> GameObject, ... }
16:08:08 <Cale> and then we can have things like:
16:08:16 <acowley`> anyone know of an Arbitrary instance that will give me Doubles in the range [0,1]?
16:08:27 <Cale> asteroid size pos vel acc = GO { .. }
16:08:43 <Cale>   where display = ... draw an asteroid with the right size at the right place ...
16:09:22 <hpaste> geheimdienst pasted “crazy-or-useful-or-both” at http://hpaste.org/51028
16:09:44 <geheimdienst> o hai #haksell. i maked u guise sum funktions
16:09:46 <geheimdienst> u likes?
16:09:58 <Cale>         timeStep dt _ = asteroid size (pos ^+^ dt *^ vel ^+^ dt^2/2 *^ acc) (vel ^+^ dt *^ acc) acc
16:10:46 <elliott> Cale: Oh, (^+^) is the common name for that
16:10:56 <roconnor> backwards euler's method would be more stable.
16:10:58 <Cale> Yeah, I just mean some vector addition operation.
16:10:59 <hpc> :t \x y -> x <$> pure y
16:11:00 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> a -> f b
16:11:04 <elliott> geheimdienst: (>$<) = (return .)
16:11:21 <Cale> hkarim: That's a pretty rough sketch, but hopefully you get the idea.
16:11:37 <elliott> Cale: No, I mean, I was trying to figure out what the common name was recently when implementing my own vector type for various reasons
16:11:43 <Cale> ah
16:11:50 <elliott> I settled on (.+.) and (.-.) but you've reminded me of the common name :P
16:11:54 <geheimdienst> elliott: fair enough. i'm not much of a pointless fan
16:11:55 <Cale> Yeah ^+^ or .+. are pretty common
16:11:55 <Peaker> Cale: I'd add that not only is inheritance not important, it is actively harmful :)
16:12:11 <elliott> geheimdienst: Well, using fmap is just silly, even if you don't make it pointless :P
16:12:24 <elliott> Cale: Oh, (.+.) is common? I'll keep it then, it's nicer :P
16:12:29 <shachaf> elliott: How about ⁺?
16:12:35 <Peaker> Interface inheritance is useful, and Haskell has far better interface inheritance implementations than OO languages.  Implementation inheritance is harmful
16:12:42 <shachaf> ⊕
16:12:51 <hkarim> Cale: Thanks alot, I think I got it
16:12:53 <shachaf> ⊞
16:13:02 <elliott> shachaf: Buy my a keyboard with those on and sure
16:13:10 <Cale> Well, you can do implementation inheritance if instead of defining things directly in a recursive way, you separate out taking the fixed point.
16:13:18 * shachaf buys elliott a compose key.
16:13:27 <drdo> elliott: You can rebind keys you know? :P
16:13:27 <elliott> Thanks
16:13:36 <elliott> drdo: Don't have enough modifier keys for a compose key
16:13:56 <drdo> elliott: do you really use all your keyboard with AltGr?
16:14:17 <hkarim> Peaker: Implementation inheritance is harmful, will remember that :)
16:14:27 <elliott> drdo: I don't type much Unicode
16:14:57 <drdo> elliott: what keyboard layout do you use?
16:14:59 <hkarim> Peaker: But the guys on the dark side will strongly disagree :)
16:15:32 <Peaker> hkarim: sure they will, they've not been enlightened by pure functional programming yet :)
16:16:08 <elliott> drdo: qwerty
16:16:12 <Jafet> The guys in the dark ages
16:16:29 <geheimdienst> i think there's enough ridiculous keys that nobody needs. scroll lock, menu, caps lock, insert ... you can easily put compose on one of those
16:16:29 <drdo> elliott: there's dozens of qwerty variations
16:16:30 <Cale> It introduces subtle bugs when people shirk their responsibilities, where things can compile, but have subtly wrong behaviour because the superclass method is perhaps almost, but not quite right.
16:16:44 <hkarim> Peaker: I believe so. Literally, I am currently LOLing inside when someone discusses the template pattern at work
16:16:45 <drdo> geheimdienst: What's compose?
16:16:47 <elliott> drdo: It's either US or UK, I forget
16:16:52 <Peaker> FP is sort of a super-set of other kinds of programming, but when you use imperative style, OO style, etc, you encode it using simple FP primitives, rather than built-in primitives. In Haskell, these encoded primitives also get useful types.  This exposes the true meaning and structure behind these styles, and gives insights that are not immediately apparent in those other languages
16:17:08 <elliott> geheimdienst: I don't have any of those. Well, I have caps lock, but I use it occasionally.
16:17:09 <drdo> elliott: How many modifiers do you have?
16:17:25 <elliott> drdo: Five. I could reassign right super or right alt, but they're really awkward to type.
16:17:34 <elliott> Well, six, but one is not rebindable.
16:17:36 <Peaker> hkarim: yeah, lots of fancy names for higher-order functions (which I guess is its own fancy name :-)
16:17:43 <elliott> Oh, and not counting shift, which I of course use.
16:17:43 <hkarim> I think I have a lot to learn :)
16:17:49 <hkarim> Oh, yeah
16:18:10 <drdo> elliott: What are they? I only have five :S
16:18:13 <geheimdienst> drdo, it lets you do things like "compose < <" to make «, "compose / o" to make ø and so on. it's quite intuitive i think
16:18:25 <geheimdienst> i have compose mapped to menu, which i never ever need
16:18:35 <elliott> drdo: Ctrl, alt, super, right super, right alt. Also left shift, right shift, fn.
16:18:38 * Cale has caps lock mapped to compose
16:18:50 <drdo> fn doesn't count :P
16:18:56 <mm_freak> geheimdienst: how do you do that?  i use xmodmap, which only allows me to use key combinations
16:18:56 <drdo> caps lock is control here
16:18:57 <elliott> That's why I left it off the count.
16:19:04 * acowley` has space bar mapped to function application
16:19:13 <mm_freak> i would love to have key sequences instead for some things
16:19:20 <elliott> acowley`: :D
16:19:25 <Cale> IF I WANT CAPSLOCK I"M USUALLY TRYING TO LOOK DUMB ANYWAY SO QUOTES CAN BE DOUBLE QUOTES
16:19:46 <drdo> elliott: I just realised i have that right super thing as well
16:19:56 <Cale> B1FF!!!!1
16:19:57 <elliott> By super I mean windows key :P
16:20:01 <drdo> yes i know
16:20:12 <elliott> Cale: YOU DON'T KNOW THE KIND OF PEOPLE I HAVE TO YELL AT
16:20:14 <elliott> Also, COBOL CODING.
16:20:25 <mm_freak> who ever named that stupid windows key "super"…
16:20:36 <elliott> mm_freak: People who had those keys before Windows existed.
16:20:42 <elliott> And people who don't use Windows.
16:21:12 <mm_freak> i find it kinda hard to connect the word "super" with the windows logo on that key
16:21:46 <drdo> mm_freak: it doesn't have a windows logo on some keyboards
16:21:49 <elliott> I don't look at my keys
16:22:02 <elliott> Do you have a hard time relating the name shift to uppercasing things?
16:22:04 <mm_freak> i prefer to call that key "dumbass"…  i close my windows with dumbass-X
16:22:23 <drdo> i close my windows with dumbass-C
16:22:25 <geheimdienst> mm_freak: to try it out, say "setxkbmap -option compose:menu" in a terminal. will be gone at reboot. for the permanent setting, put something like this in xorg.conf:  «Option "XkbOptions" "compose:menu"»
16:22:43 <geheimdienst> ... at least that's how i did it. not sure if there's some gnome interface to set that
16:23:15 <drdo> geheimdienst: How can you map key sequences to characters then?
16:23:33 <mm_freak> i mean, how in the world can anyone use "super" and "windows" in the same sentence and still sleep well?
16:23:44 <mm_freak> ok, enough rants for today =)
16:24:11 <Cale> "Windows is super-unstable."
16:24:12 <mm_freak> geheimdienst: thanks…  will that command overwrite my current layout?
16:24:36 <Cale> ACHIEVEMENT UNLOCKED
16:24:41 <mm_freak> Cale: could be interpreted as (windows is super)-unstable (which would still be kinda right)
16:25:08 <drdo> can we bash unix now?
16:25:09 <geheimdienst> drdo: there's a bunch already mapped in /usr/share/X11/locale/en_US.UTF-8/Compose . i think there's also some way of adding to that, if you really need to
16:25:26 <geheimdienst> mm_freak: i'm pretty sure it will only change the meaning of the menu key
16:25:32 <mm_freak> drdo: sure…  i don't like unix/linux either =)
16:26:00 <drdo> no one does, except masochists
16:26:09 <benmachine> everything is terrible
16:26:15 <sebz> is ap usually used infix?
16:26:23 <acowley> sebz: yes
16:26:30 <shachaf> sebz: It's often called <*> when it's used infix.
16:26:31 <mm_freak> sebz: yes, and usually you would prefer <*> instead of 'ap'
16:26:37 <elliott> sebz: I usually call it ... dammit, shachaf.
16:26:43 <Jafet> Except Haskell-OS
16:26:43 <sebz> ok thanks :)
16:26:48 * shachaf cackles at mm_freak and elliott.
16:26:55 <Jafet> It will be the bestest system ever
16:27:03 <mm_freak> shachaf: actually on my client i was faster =P
16:27:33 <shachaf> We need third-party neutral arbitration.
16:27:39 <shachaf> geheimdienst: You'll do.
16:27:57 <Jafet> irc features relativity of simultaneity.
16:28:08 <geheimdienst> i like you all equally
16:28:11 <mm_freak> i was about to write: "you can also use liftA*", but then i felt like finishing my line to be the first =P
16:28:17 * geheimdienst tries to capture various people in a group hug
16:28:34 <Jafet> @hug geheimdienst
16:28:34 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:28:42 <benmachine> ...
16:28:50 <benmachine> lambdabot, are you implying something
16:28:54 <acowley> you guys need to take the SO approach: Start with a one word answer to be first, then edit in details at your leisure
16:29:29 <mm_freak> geheimdienst: geheimdienste always like everybody equally…  but some likings are more equal than others
16:29:57 <mm_freak> acowley: doesn't work on IRC
16:30:06 <mm_freak> you can do that on SO
16:30:17 <elliott> Sure it does, just use s///
16:30:27 <acowley> exactly
16:30:28 <Peaker> apparently the main(?) Java author was asked what he'd do differently in Java, and he said "remove implementation inheritance"
16:30:35 <mm_freak> true
16:30:37 <geheimdienst> sebz: by the way, if you're looking for uses of (<*>) or ap, check out this: http://en.wikibooks.org/wiki/Haskell/Applicative_Functors i only kinda got it after reading that page
16:30:47 <acowley> s/yes/you should probably use <*> from the Applicative type class. Now I shall discourse on Functors...
16:30:47 <geheimdienst> the haddocks never made sense to me
16:30:48 <benmachine> s/.*/something interesting/
16:31:38 <mm_freak> geheimdienst: luckily in haddocks for anything based on functors or categories you usually only have to look at the type signatures
16:31:54 <geheimdienst> peaker: istr it was james gosling, and he said something like "well if i could do it all over again, i'd remove classes"
16:31:55 <mm_freak> and perhaps at the function names
16:32:01 <Peaker> geheimdienst: yeah
16:32:07 <Peaker> geheimdienst: I'd remove Java :)
16:32:18 <sebz> thanks geheimdienst
16:32:23 <benmachine> Peaker: the empty language
16:32:23 <Jafet> C with coffee.
16:32:28 <benmachine> programs guaranteed bug-free :o
16:32:29 <mm_freak> i'd remove sun (the corporation)
16:32:43 <mm_freak> or oracle
16:32:49 <mm_freak> both probably
16:32:52 <ryb> MissingPy users: Is there some way to have multiple Haskell threads running Python code at the same time?
16:33:49 <geheimdienst> peaker: at least it made GC palatable. i guess without java, serious programmers would still be arguing that there's really no good alternative to manual memory mucking-around
16:34:26 <mm_freak> geheimdienst: common lispers are not serious?
16:34:46 <mm_freak> or did CL work without GC?
16:35:47 <Peaker> geheimdienst: Java gave GC a slow name :)
16:35:49 <geheimdienst> i mainly meant the c++ crowd. sure GC has been around, but i think the mainstream saw it as exotic or risky until java
16:35:55 <Peaker> (may have been corrected years later)
16:35:56 <Jafet> Nah, common lispers are gay old kookies.
16:36:56 <Peaker> Lisp has some nice properties.. CL seemed like quite a mess to me, from a cursory glance (lisp-2, yuck. Multiple return values hack.  Extremely verbose pattern matching on tuples.  Very ugly let scoping syntax.. etc)
16:37:03 <mm_freak> i prefer haskell over lisp, but i would totally prefer lisp over XML/HTML/CSS/…
16:37:16 <elliott> <Peaker> geheimdienst: Java gave GC a slow name :)
16:37:18 <elliott> Peaker: nah, it's Swing
16:37:29 <elliott> Java's GC was made by space aliens, it's too good
16:37:39 <mm_freak> (html (head …) (body …))  ; how cool would that be?
16:37:42 <elliott> the JVM in general, really, in everything but startup time
16:37:46 <elliott> mm_freak: Oleg's SXML
16:38:02 <mm_freak> elliott: theory or is there some code?
16:39:14 <elliott> mm_freak: It's Oleg, there's tons of code and it's used in practice :P
16:39:18 <elliott> For Scheme.
16:39:22 <Peaker> elliott: Java hasn't performed well in benchmarks..  All of my experiences with Java have been terribly negative..
16:39:26 <elliott> There's even SXPath, SXSLT, etc.
16:39:28 <Peaker> elliott: (as a user of Java programs)
16:39:36 <elliott> Peaker: That's language, culture, etc.
16:39:49 * hackagebot gps2htmlReport 0.2 - GPS to HTML Summary Report  http://hackage.haskell.org/package/gps2htmlReport-0.2 (RobStewart)
16:39:50 <drdo> mm_freak: That's what everyone does in lisp
16:39:56 <elliott> Peaker: As JITting VMs go, it's incredibly good, and especially its GC, which is basically better than every other GC ever.
16:39:58 <Jafet> (a { href="example.com", alt="" } img { src="hello.jpg" })
16:40:03 <elliott> Except maybe Azul Systems', but that runs on Java too :-)
16:40:07 <elliott> Well, below java.
16:40:14 <mm_freak> elliott: i was going to write an s-exp-based template engine for HTML5/XML and CSS, but if there is already existing code, that would be great
16:40:18 <Peaker> Java seems to have really bad distribution issues -- Java programs never tended to work on my computer, despite the "run anywhere" thingie..  Some big-name Java things did work (e.g: Eclipse) but very slowly
16:40:19 <drdo> mm_freak: see: http://weitz.de/cl-who/ for example
16:40:31 <jeffcutsinger> I heard Java had made a lot of gains on the performance front.
16:40:36 <mm_freak> drdo: yeah, but lisp doesn't really help me =)
16:41:10 <Peaker> elliott: Java GUIs (non-Swing too) seem to have responsiveness issues which strengthens the "java is slow" feel
16:41:11 <elliott> Peaker: I'm not defending anything about Java other than its VM and GC.
16:41:23 <elliott> Yes, Java GUIs and Java programs are basically universally terrible
16:41:23 <geheimdienst> jafet: what syntax is that?
16:41:27 <elliott> And it's a horrible language
16:41:27 <kmc> i want a good JIT for Haskell
16:41:28 <Peaker> elliott: well, I don't know much about Java's implementation except my experiences as a user :)
16:41:32 <elliott> But its implementation is amazing.
16:41:49 <Peaker> elliott: It's weird that a horrible language would attract amazing implementors
16:41:55 <kmc> money
16:41:59 <drdo> eh
16:42:02 <drdo> was going to say that
16:42:03 <kmc> also Java isn't horrible in the sense PHP is horrible
16:42:06 <kmc> (i lose godwin's law)
16:42:16 <Peaker> btw, Java 7 was released with critical JIT bugs, wasn't it?
16:42:24 <kmc> the things Java lets you do are mostly pretty sane, they just aren't enough
16:42:29 <elliott> Peaker: Yeah, money. Sun basically put the smartest people and millions of dollars into Java and it worked.
16:42:32 <drdo> kmc: Java is a common benchmark of horribleness
16:42:34 <elliott> :p
16:42:45 <kmc> it's designed to bring all programmers to a common level
16:42:51 <kmc> so that software development becomes a more predictable process
16:42:55 <jeffcutsinger> How to get a brisk conversation going in #haskell: mention Java.
16:42:59 <kmc> indeed
16:43:10 <mm_freak> i'm not sure whether java is that bad…  after all it got some things right, which C++ got wrong
16:43:21 <Peaker> kmc: Making it predictable by putting huge upper bounds on everything isn't very good :)
16:43:31 <mm_freak> although i would prefer the other java called C#
16:43:32 <kmc> Peaker, businesses will often accept that tradeoff
16:43:42 <kmc> it depends on the factors though
16:43:54 <drdo> mm_freak: being better than horrible doesn't make you great, just less horrible
16:43:58 <Jafet> geheimdienst: a made-up one
16:44:03 <geheimdienst> oh i see :)
16:44:12 <kmc> but for many, it's better to have projects that cost 5x as much as they should, if it avoids the "two years and $10 million down the drain" outcomes
16:44:17 <kmc> which are so common in software development
16:44:21 <simon> I've got: sometree = foldl (\t (c, xs) -> insert t c xs) Leaf somelist -- and I wonder if there's a neat way to express 'insert' by currying its second argument.
16:44:22 <Peaker> mm_freak: Java was released much after C++, and yet while C++ tried to add non-nullable references, Java made the nullability error. While C++ allowed operator names, Java had only hard-coded fixed operators. Java has the primitive type dichotomy, and various "downgrades" from C++
16:44:41 <Peaker> mm_freak: also, C++ has an excuse for many of the limitations:  Low-level compatibility.. Java doesn't have that excuse
16:44:57 <geheimdienst> i guess the "downgrades" were seen as "don't repeat c++'s mistakes"
16:45:22 <Peaker> kmc: I doubt Java projects are more predictably successful in practice
16:45:24 <kmc> Java is designed to limit the damage done by bad programmers
16:45:25 <mm_freak> drdo: java, being less horrible than PHP, is WAY an improvement over PHP
16:45:29 <benmachine> it is bitch-about-inferior-languages-half-hour again, is it
16:45:43 <kmc> Peaker, maybe so, but it's a logically consistent goal for a language design
16:45:46 <mm_freak> Peaker: huh?  C++ allows operator names?
16:45:54 <Peaker> mm_freak: sometimes called "operator overloading"
16:45:57 <kmc> and i think it is consistent with Java's design to a large part
16:45:58 <geheimdienst> benmachine: we're moving the schedule forward, we're trying to get it over with earlier this week
16:45:58 <drdo> mm_freak: sure, but why should anyone care when there were already much better languages available?
16:45:59 <Jafet> Half-hour hate
16:46:03 <kmc> C++ lets you overload existing operators only
16:46:10 <benmachine> Jafet: :)
16:46:10 <mm_freak> Peaker: ah, you mean that java has no operator overloading?
16:46:23 <kmc> Java may have failed at this goal; I wouldn't know
16:46:25 <mm_freak> i'd find that surprising
16:46:26 * benmachine doesn't really like operator overloading
16:46:34 <mm_freak> benmachine: you use it in haskell
16:46:36 <Peaker> benmachine: You're sitting in #haskell :-)
16:46:38 <kmc> as I haven't had the pleasure of managing a team of 100 Java programmers writing boring business software
16:46:42 <mm_freak> and you love it in haskell =)
16:46:55 <benmachine> mm_freak: hey, don't go making assumptions about what I love :P
16:47:05 <mm_freak> benmachine: am i wrong?
16:47:12 <kmc> all i'm saying is that replaceable-part programmers and predictable outcomes are worth a lot to some businesses
16:47:13 <benmachine> hmmm
16:47:17 <mm_freak> benmachine: ;)
16:47:21 <Dashkal> small sample size is small: I've been on more than one Java project that went into code/fix/repeat hell
16:47:21 <kmc> worth a huge decrease in overall efficiency
16:47:25 <benmachine> haskell's operators are good because you can define your own
16:47:26 <drdo> kmc: It doesn't really work like that in the real world
16:47:29 <benmachine> and because they're not "magic"
16:47:39 <benmachine> but they suffer from some of the same problems
16:47:41 <Peaker> benmachine: C++ operators are just names too, not magic
16:47:52 <geheimdienst> simon: are you aware of flip? it might do what you want
16:47:54 <Jafet> They are pretty magical in C++.
16:47:57 <benmachine> Peaker: they're magic in that they're all predefined
16:47:57 <geheimdienst> > let m = flip map [1..5] in m succ
16:47:58 <Peaker> Jafet: why?
16:47:59 <lambdabot>   [2,3,4,5,6]
16:48:01 <kmc> Peaker, they're magic in that the set of allowed names is very small and each one has hardcoded precedence and associativity
16:48:02 <mm_freak> benmachine: i think the only difference in C++ is that you can't define arbitrary operators
16:48:16 <Jafet> There are very particular rules on how you can define them, and you can't change their fixity.
16:48:19 <mm_freak> (which also appeals to some people — not to me though)
16:48:26 <Peaker> kmc, benmachine: Haskell also has arbitrary restrictions on operator names
16:48:39 <mm_freak> Jafet: you can't change their fixity in haskell either
16:48:45 <benmachine> Peaker: yeah, it's kind of annoying how many good operators are syntax
16:48:47 <Peaker> kmc, benmachine: Associativity/precedence being predefined is kind of orthogonal
16:49:10 <mm_freak> Jafet: and in haskell you have the same rules…  only that those rules are not magic, but defined by the particular type class
16:49:16 <kmc> now that everyone's paying attention to the channel: what are the Haskell tools i should mention in a "why learn Haskell" talk?  i have ghc, ghci, QuickCheck, hpc, -prof, hp2ps, threadscope, haddock, cabal, hayoo, Criterion, lambdabot
16:49:46 <Peaker> kmc: I think hoogle is nicer than hayoo (and you can build databases for third parties)
16:49:49 <benmachine> Peaker: but the fact that you can't define new operators is probably why someone decided the bitshift operator was a sensible way to do IO
16:49:54 <Jafet> Peaker: for example, you can only define the array subscript operator inside a class, not outside it
16:49:55 <kmc> also is there no longer an official logo for Haskell Platform?
16:49:58 <Peaker> kmc: hayoo won't even search flipped functions
16:50:04 <kmc> Peaker, but the online hayoo instance searches all of Hackage
16:50:07 <simon> geheimdienst, yes. yes, I'll flip.
16:50:10 <mm_freak> kmc: darcs, yesod (or happstack), innovative design patterns
16:50:13 <elliott> mm_freak: java has no operator overloading
16:50:23 <kmc> Hoogle's unification is nice, but sometimes counterproductive (i.e. suggesting unsafeCoerce for everything)
16:50:28 <Peaker> Jafet: arbitrary restrictions are not "magical" though
16:50:35 <kmc> mm_freak, ah, i'll consider it but i don't think they really fit
16:50:39 <kmc> mm_freak, which design patterns?
16:50:43 <Jafet> There are like fifty or so rules you have to remember for all the operators in C++. I think that adds up to magic.
16:50:44 <geheimdienst> kmc: highlight ghc. it's a damn helpful fellow
16:50:55 <benmachine> I think hoogle's unification is more often helpful than not
16:50:57 <Peaker> darcs isn't exactly a successful Haskell tool, imo (being abandoned due to low performance)
16:51:00 <kmc> darcs isn't really a Haskell tool
16:51:04 <mm_freak> kmc: FRP seems to be something, which only haskell people seem to use
16:51:22 <kmc> you can use darcs to manage code in any language; the fact that it's implemented in Haskell doesn't really matter
16:51:22 <mm_freak> kmc: also laziness can be a design pattern
16:51:26 <Peaker> I think FRP is too research-y/cutting-edge to show beginners
16:51:33 <drdo> kmc: What kind of audience is it?
16:51:38 <kmc> MIT students
16:51:43 <Peaker> kmc: except as evidence that Haskell makes slow programs :-P
16:51:44 <drdo> students of what?
16:51:45 <kmc> and various hangers-on
16:51:50 <kmc> probably mostly CS, but who knows
16:52:08 <mm_freak> kmc: the concurrency system and the various abstractions around it…  i would stress that one a lot
16:52:12 <kmc> darcs could go along xmonad and pandoc as "Haskell software people use in the real world"... except it's hard to make the case that it's actually better than git and hg and bzr
16:52:16 <mm_freak> like STM, cheap threads, etc.
16:52:17 <kmc> yeah, i have a lot on that
16:52:23 <kmc> that's not what i meant by "tools" though
16:52:26 <kmc> but the suggestions are helpful
16:52:41 <mm_freak> you mean tools in the literal sense?
16:52:53 <kmc> i gave a long list of them already
16:53:01 <kmc> i'm wondering if anything is missing from that list
16:53:14 <kmc> things that generally help you develop Haskell software, irrespective of what that software does
16:53:18 <geheimdienst> kmc: add runhaskell. it's a smallish, trivialish thing, but whenever i need to whip up a little c program to test something, i miss it
16:53:22 <drdo> kmc: emacs? :P
16:53:25 <acowley> kmc: #haskell is a pretty good tool
16:53:32 <mm_freak> kmc: you may mention the various editor modes available
16:53:34 <kmc> geheimdienst, thc can be used with a shebang line
16:53:35 <Eduard_Munteanu> So you're like.. looking for a wrench instead of a car?
16:53:41 <mm_freak> the emacs haskell-mode is quite powerful
16:54:05 <dibblego> hoogle/hayoo is painfully missing in other languages and it becomes quite apparent once you've tasted both sides
16:54:21 * shachaf awaits Hing.
16:54:23 <HugoDaniel> :)
16:54:28 <HugoDaniel> hing ?
16:54:30 <mm_freak> kmc: also cabal-install, if that's not what you meant by "cabal"
16:54:32 <acowley> I also think hackage and cabal/cabal-install are great despite their issues
16:54:34 <Eduard_Munteanu> dibblego: parametricity is painfully missing in other languages
16:54:44 <geheimdienst> kmc: interesting :) thanks. but seems obscure
16:54:47 <dibblego> Eduard_Munteanu: yepper
16:54:49 <Eduard_Munteanu> The nice thing is you can search for types.
16:54:56 <Eduard_Munteanu> *functions matching types
16:55:43 <mm_freak> and finally i use the cabal+make combination a lot, which can do some neat stuff for me
16:55:59 <mm_freak> for example when deploying a web app, i usually just say "make upload"
16:56:24 <mm_freak> it darcs-pushes, SSHs to the server, rebuilds, restarts
16:57:16 <acowley> kmc: RULES are also incredible
16:57:19 <geheimdienst> kmc: i'd add hlint, and i'd definitely add both tryhaskell and #haskell. the channel is really half of the language's attractiveness
16:57:32 <acowley> kmc: admittedly it's a stretch to call it a tool
16:57:34 <dibblego> what are we adding to by the way?
16:57:49 <mm_freak> dibblego: the list of useful tools for haskell development
16:57:57 <dibblego> oh that's a *long* list
16:58:13 <mm_freak> kmc already came with a long list…  we're just appending =)
16:58:21 <dibblego> consing I hope
16:58:27 <mm_freak> or prepending, since we're haskellers
16:58:30 <kmc> i cover Cabal and cabal-install, though i gloss over the distinction between them
16:58:47 <kmc> i have a slide on RULES and SPECIALIZE
16:59:01 <kmc> hlint is another good one
16:59:03 <dibblego> * first-class IO actions
16:59:08 <kmc> i'm not sure i'll have time for this
16:59:09 <mm_freak> kmc: i would make it, because cabal itself is a great build system…  cabal-install on the other hand is an interface to many other things, too
16:59:16 <simon> geheimdienst, I'm not sure I see how to achieve this with flip and curry/uncurry alone, since I'm trying to uncurry the second and third argument.
16:59:42 <mm_freak> kmc: cabal-dev can also be useful sometimes
16:59:43 <kmc> yeah, I'm covering first-class IO... i don't mean to shoot down helpful suggestions, but I wasn't asking for "list all of the good things about Haskell" because that will keep us here all night
16:59:46 <kmc> and drown out useful conversation
16:59:53 <kmc> yeah
16:59:55 <kmc> i may add cabal-dev
17:00:10 <mm_freak> and firefox =)
17:00:12 <dibblego> I also use pointful/pointfree a lot
17:00:31 <mm_freak> dibblego: development tools, not language features
17:00:43 <dibblego> when I am developing haskell, as a development tool
17:00:56 <mm_freak> kmc: a few people might find djinn interesting, although its practical use is very limited =)
17:01:04 <rwbarton> how about vacuum
17:01:07 <dibblego> I occasionally use djinn during development
17:01:08 <kmc> it's in there
17:01:08 <rwbarton> is that on the list?
17:01:30 <kmc> not yet
17:02:13 <kmc> mm_freak, how do you use Cabal and make together?
17:02:13 <mm_freak> kmc: for web developers, yesod has quite a powerful scaffolding tool
17:02:35 <mm_freak> kmc: simply invoke cabal-install from the makefile
17:02:53 <kmc> what advantages does make give you, then?
17:03:02 <simon> geheimdienst, ah, I think I can do it if I change my foldl to a foldr. :)
17:03:15 <mm_freak> kmc: fully automatic deployment mainly
17:03:34 <kmc> compared to a shell script which invokes cabal-install?
17:03:53 <mm_freak> kmc: but also the simple fact that i can just press F9 in my emacs and have my Makefile call 'cabal configure' when necessary and then 'cabal build'
17:03:59 <elliott> Peaker: it is not really the code that makes darcs slow but the algorithms
17:04:12 <mm_freak> kmc: Makefiles are better at expressing when to invoke 'cabal configure'
17:04:25 <Peaker> elliott: perhaps, but it is the code that makes it stack overflow
17:04:27 <kmc> ok
17:04:40 <elliott> Peaker: It does that?
17:04:50 <kmc> in my projects, configure takes almost no time
17:04:53 <kmc> i'd rather not represent a dependency graph if i don't need to
17:04:54 <mm_freak> generally i find Makefiles much easier to write than shellscripts
17:04:58 <kmc> heh
17:05:01 <Peaker> elliott: I heard that ghc abandoned darcs because it would stack overflow after a long wait when trying to annotate a file
17:05:02 <kmc> they are a bit more declarative
17:05:11 <kmc> but make has enough weird corners and traps
17:05:16 <Peaker> If only GNU make wasn't completely broken
17:05:26 <kmc> a shell script that's just "run these 5 commands in order" is not hard to write
17:05:28 <elliott> tup :)
17:05:38 * drdo trembles in fear just thinking of autotools
17:05:51 <Peaker> I wonder if openshake is mature by now
17:06:01 <mm_freak> kmc: sometimes i don't recompile until after writing pages of code, but sometimes i recompile a lot after smallest changes
17:06:01 <kmc> is GNU make really completely broken? that seems a bit overstating the case
17:06:02 <Peaker> Last I looked, it didn't yet implement header file scanning for C correctly
17:06:22 <kmc> i've noticed programmers tend to consider each program in the world as either "completely broken beyond repair, utter shit" or "the third coming of jesus"
17:06:24 <mm_freak> one of the latter cases is when i try to find out where it's best to put 'seq' =)
17:06:34 <elliott> Peaker: nicer to have language-agnostic dependency tracking
17:06:36 <Peaker> kmc: Make is an Applicative, when a build system should be a Monad
17:06:41 <kmc> i guess it's just the general problem where moderate opinions get drowned out
17:06:46 <mm_freak> kmc: i like GNU make
17:06:48 <Peaker> kmc: My dependencies depend on my build results
17:06:52 <acowley> Does anyone know of a Ring type class that builds on the vector-space package's AdditiveGroup class?
17:06:58 <Peaker> (e.g: #include scan on auto-generated code)
17:07:00 <geheimdienst> kmc: i'd put "ghc" in a huge font. it's really helpful. "ghc bitches around forever, but once it compiles, it works"
17:07:00 <elliott> kmc: for me it's "utter crap" or "bearable... for now"
17:07:09 <geheimdienst> > let f a b c = a ++ b ++ c in (flip (flip f "2nd") "3rd") "1st"
17:07:11 <lambdabot>   "1st2nd3rd"
17:07:14 <Peaker> the only valid use of make is to "make clean all" every time
17:07:18 <mm_freak> acowley: wouldn't that be the other way around?
17:07:27 <Peaker> or use it very tediously on very small projects
17:07:29 <geheimdienst> simon: ^^ maybe not extremely nice, but i think doable ...
17:07:30 <kmc> geheimdienst, i'm actually downplaying the type system... I just don't think you can convince people of that fact in a few slides
17:07:34 <mm_freak> acowley: oh wait, ignore me =)
17:07:35 <kmc> there's enough other stuff that's self-evidently cool
17:07:38 <dmwit> There's a couple of things that make does badly. Small projects tend not to hit these things.
17:07:48 <dmwit> Unfortunately, most big projects of today started as small projects yesterday.
17:07:51 <kmc> like recursive make
17:08:36 <dmwit> So deciding to use make because the project currently does not hit make's sore spots is somewhat questionable, especially if you're actually trying to do something successful.
17:08:39 <dmwit> That's my take.
17:08:56 <kmc> successful software is not necessarily big software
17:08:58 <kmc> but i agree
17:09:06 <acowley> can hayoo not search for operators?
17:09:14 <kmc> a lot of massively successful projects are still basically a few c files and a header
17:09:27 * dmwit nods agreeably
17:09:32 <kmc> :)
17:11:07 <HugoDaniel> kmc: and in the future, a few lines of javascript and some strange js lib bellow
17:11:27 <elliott> HugoDaniel: it's not nice to give people nightmares :(
17:12:22 <mm_freak> i wonder what people find broken about (GNU) make
17:12:43 <kmc> meh, there are more projects written in C which would benefit from a rewrite in Javascript than the other way around
17:12:55 <kmc> particularly if you care about security
17:13:10 * kmc knows some IRC channels where he would be banned for saying that
17:13:17 <HugoDaniel> :D
17:13:54 <kmc> remember, good programmers never make mistakes.  if you find a good programmer i'll trade you for a unicorn
17:13:59 <mm_freak> C is not broken…  only its users are broken for using it
17:14:08 <kmc> some of them, yes
17:14:14 <kmc> some of them have good reasons
17:14:25 <kmc> and efforts to make a better systems programming language have largely failed
17:14:30 <kmc> though i still hold out hope
17:14:42 <mm_freak> yes, but considering that people write entire application servers in C…  i really don't understand how you can be that irresponsible
17:14:59 <elliott> or whole desktop environments
17:15:37 <drdo> not just irresponsible, but masochist
17:16:03 <mm_freak> application servers are worse, because when they have security problems and you are a company, you may find yourself facing hackers breaking into your server
17:16:49 <kmc> "but other languages can have security problems too, so C is just as good"
17:17:02 <kmc> people have made this argument to me on many occasions
17:17:05 <mm_freak> yeah, that's the usual argument
17:17:34 <elliott> sometimes it's "with C, you're in control, other languages have more potential for security bugs because of the extra layers". but seriously, this half hour of hate is way overdue.
17:17:40 <kmc> if you go skydiving you might die even if you have a parachute
17:17:42 <elliott> erm, not overdue. what's the word.
17:17:45 <kmc> so might as well not bother
17:17:54 <elliott> (I wonder if those people have ever looked at a C compiler)
17:18:03 <mm_freak> you can counterargument that by the same argument there is nothing wrong with using assembly
17:18:15 <mm_freak> for some reason people don't let that count
17:18:21 <mm_freak> "because that's ridiculous"
17:18:30 <kmc> yeah, #haskell is basically a support group for professional programmers
17:18:31 <drdo> mm_freak: they will answer "portability"
17:18:34 <kmc> i wonder what i'm doing here, then
17:18:50 <mm_freak> drdo: true, that's another way
17:19:02 <mm_freak> anyway…  us knowing it doesn't help the poor apache users =)
17:19:13 <Eduard_Munteanu> I think performance is also a concern.
17:19:28 <mm_freak> Eduard_Munteanu: i get comparable performance in haskell
17:19:39 <drdo> Eduard_Munteanu: You very often end up with less performance in big projects
17:19:41 <Eduard_Munteanu> Besides, Bob the Hacker usually wants to understand the whole codebase.
17:19:46 <kmc> so is it like really bad if i put the old Haskell Platform logo on my slides?
17:19:48 <kmc> i kinda like it
17:19:56 <Eduard_Munteanu> (or claims to)
17:20:04 <elliott> kmc: you'll be arrested by the haskell police
17:20:07 <mm_freak> also in large projects the performance is just a hack, whereas writing well-performing programs is natural in haskell
17:20:21 <mm_freak> you may find yourself with better performance in haskell for shorter development times
17:20:24 <Eduard_Munteanu> mm_freak: a 2-3x slowdown can scare people, even if it's not relevant to their application
17:21:16 <mm_freak> Eduard_Munteanu: by comparable i mean that i generally run at 60-70% of C speed for simple applications and likely outperform C in complicated applications
17:21:24 <roconnor> mm_freak: well-preforming?
17:21:27 <mm_freak> unless the C programmer takes lots and lots of time to optimize
17:21:27 <kmc> writing# {-# UNPACK #-} unsafeWellPerforming# (# programs, is #) -> natural `unsafeIn#' GHC_Haskell_7_0_3
17:21:27 <HugoDaniel> i find haskell performance to be hugely lagging behind C, even with common optimizations, profiling and criterion tests
17:21:34 <Eduard_Munteanu> Similarly gcc devs don't want people using all C++ features.
17:21:45 <Eduard_Munteanu> even if they made that switch
17:21:55 <elliott> kmc: {-# UNPACK #-} needs a nicer syntax
17:21:58 <HugoDaniel> hugely lagging means about 8 to 10x slower
17:22:05 <kmc> i suggest {-# {-# UNPACK #-} UNPACK #-}
17:22:21 <elliott> HugoDaniel: ten times slower than C is good in my book
17:22:25 <elliott> what's Python, ten thousand times slower?
17:22:28 <mm_freak> roconnor: in terms of processing power and memory usage
17:22:47 <HugoDaniel> elliott: sure :) i also dont mind, but it can be a problem if performance is a requirement
17:23:21 <mm_freak> HugoDaniel: it's often because haskell programmers don't use the right libraries and abstractions
17:23:35 <Eduard_Munteanu> In the meanwhile the high performance crowd is annoyed by 1% slowdowns, mispredicted branches and whatnot
17:23:41 <kmc> and it only takes 10 years of concentrated study to find the right libraries and abstractions!
17:23:47 <kmc> lazy bums
17:23:47 <elliott> mispredicted branches ahahaha
17:23:57 <mm_freak> main reason for me to write 'instinct'…  the existing ANN library works with lists and is extremely slow
17:24:10 <Eduard_Munteanu> elliott: if (likely(...)) ...
17:24:35 <kmc> old C libraries are fast and very unsafe... old Haskell libraries are safe and very slow
17:24:43 <shachaf> So I have a thread that reads a bunch of TVars and writes out their value to a file. I want to do something like: forever $ do { state <- atomically (getAllState); writeFile file state }, except I only want to write out the state to the file if nothing has changed since the previous atomically call.
17:24:44 <elliott> Eduard_Munteanu: yeah, but come on :)
17:24:50 <Eduard_Munteanu> Or even unnecessary checks in fastpaths
17:24:52 <acowley> I usually use {-# OPTIONS_GHC -funbox-strict-fields #-} instead of {#- UNPACK #-}
17:24:54 <shachaf> Is there a simple way to do that? STM should have the information required, after all.
17:25:07 <HugoDaniel> kmc: its a no solution problem, there can only be a compromise
17:25:08 <elliott> acowley: that slowed my program down by a few points of a second, as opposed to judicious unpacking of a few strict fields
17:25:20 <elliott> I think unboxing strict fields is usually a pessimisation especially if you make a record with strict fields.
17:25:28 <acowley> elliott: really? Wow. I did my own tests and didn't see anything like that
17:25:33 <elliott> It would be nice to have a heuristic for small data types.
17:25:47 <Cale> shachaf: It's impossible to observe the STM log.
17:25:53 <elliott> acowley: Well, I have some like seven element records with all the elements strict that are basically accessed only through elements and I constantly take elements out and put things back.
17:26:01 <acowley> oh
17:26:05 <elliott> Whereas there's only e.g. my coordinate type I really want to unpack
17:26:09 <mm_freak> kmc: not sure if that's right…  i'm not sure how long i've been using haskell now, but certainly much less than ten years, and i can say i got very good at writing fast haskell code without using any pragmas or ugly code =)
17:26:15 <mm_freak> and also without unboxing strict fields
17:26:23 <roconnor> mm_freak: how?
17:26:25 <acowley> mm_freak: the correct term is "funboxing"
17:26:29 <elliott> acowley: But I think it's an option for a reason, at least for now :P
17:26:34 <elliott> It's not so hard to unpack what should be unpacked.
17:26:34 <mm_freak> lol acowley
17:26:45 <mm_freak> roconnor: as said, use the right libraries, abstractions and data structures
17:26:50 <roconnor> oh
17:26:50 <shachaf> Cale: So the only option I have is to regenerate the state, compare, and fail if it's identical?
17:26:56 <Eduard_Munteanu> So those are actually "undeps"? :P
17:27:07 <elliott> mm_freak: That works, but sometimes you just have a huge amount of work to do, and that boxing and laziness piles up a thousand times over.
17:27:07 <mm_freak> don't exaggerate with code beauty (doesn't hurt performance that much, but can hurt your development time a lot)
17:27:09 * roconnor can't even write fast C code.
17:27:12 <acowley> I saw a bunch of punks down on the corner, they were just funboxing and not following my indirections.
17:27:16 * Peaker is writing C code in another window as we speak.. I use a bunch of techniques in C for type-safety that gets me 30% towards the kind of safety in Haskell (for 10-20 times the verbosity, though, but with much nicer resource use :)
17:27:28 <Cale> shachaf: Well, you can retain a copy of it
17:27:34 <elliott> My program went from like two, three seconds to under one for a small workload just with strictness and unboxing.
17:27:38 <shachaf> I guess what I want is pretty much "whenever any of these TVars change, run this IO action".
17:27:41 <Eduard_Munteanu> roconnor: it's not even a challenge if you pick a CPU-intensive task
17:27:45 <elliott> That scales up to larger things, it's never slower.
17:27:58 <roconnor> Eduard_Munteanu: what isn't a challenge?
17:28:00 <elliott> shachaf: sounds like you want a structure built on top of a TVar
17:28:08 <Eduard_Munteanu> It happened to me on a few occasions, and I really didn't try to optimize the C code.
17:28:11 <mm_freak> elliott: depends…  it seems to me like most people find that laziness gets in your way rather than helps you…  but that's only true, until you learn how to use it
17:28:12 <elliott> type NotifyVar a = (TVar a, IO ())
17:28:14 <Eduard_Munteanu> It ended up much faster than Haskell code.
17:28:14 <acowley> shachaf: twilight STM has something like that
17:28:19 <Eduard_Munteanu> roconnor: writing fast C code.
17:28:27 <Eduard_Munteanu> fast wrt Haskell in some cases.
17:28:27 <elliott> mm_freak: Sure, I utilise laziness quite a bit in my program, to avoid redundant work, and especially some infinite lists to simplify the logic a lot.
17:28:32 <acowley> Eduard_Munteanu: I agree
17:28:44 <Cale> Peaker: You should write something which performs these techniques for you, and takes as input a more abstract specification... oh wait, never mind.
17:28:45 <mm_freak> elliott: for example i find myself using nonstrict Data.Vector much more often than strict Data.Vector.Unboxed
17:28:49 <elliott> But there is always going to be unnecessary laziness that you can't just make into something good, and it's a really easy performance game just to add some exclamation marks.
17:28:51 <drdo> Eduard_Munteanu: now mix parallelism, do you still think it's easy?
17:28:53 <elliott> s/game/gain/
17:28:54 <acowley> C often corrals you into efficient representations for simple structures
17:28:55 <mm_freak> even for Double or Int elements
17:28:56 <Peaker> Cale: :-) I actually do plan to implement a nicer C
17:28:57 <Eduard_Munteanu> Then I spent about a week or more optimizing Haskell code so I could say it was about 3x as slow.
17:29:12 <Peaker> Cale: I want to cram every bit of Haskell into it that doesn't lose out the nice operational semantics
17:29:44 <Eduard_Munteanu> drdo: hm, good point, parallelism might win there
17:29:46 <Peaker> Cale: (laziness and probably purity will probably not fit in.. Type-classes and nice parameteric polymorphism, etc, can definitely have nice op. semantics)
17:29:48 <Cale> acowley: and often the opposite too
17:29:50 <Eduard_Munteanu> *Haskell might
17:29:58 <mm_freak> elliott: the same can be said about eager code…  when i have to write PHP at work, the eagerness mostly gets in my way, and i'm serious about that
17:30:02 <Cale> acowley: (depending on what you consider simple)
17:30:08 <elliott> mm_freak: Sure.
17:30:12 <Eduard_Munteanu> Though maybe I have more experience with C than Haskell.
17:30:16 <Jafet> C often corrals you into representations for structures that happen to be simple in C
17:30:19 <drdo> Eduard_Munteanu: now mix memory fragmentation due to heap allocated memory never moving
17:30:34 <Peaker> The design space around C has: C, C++, ADA, D, ATS, And a few more.. it's very sparsely covered
17:30:37 <elliott> mm_freak: I'm just saying that while the right data structures, etc., obviously come first, there is no reason to not put a few exclamation marks in your data structure and bottlenecks, and get instant speed improvements at no cost.
17:30:55 <Peaker> Jafet: and "simple in C" often correlates to "has desirable operational semantics"
17:30:58 <roconnor> mm_freak: I've been writing ML and I agree.  I basically have to CPS everything
17:31:03 <rwbarton> "heap allocated memory"? surely one just uses a global char buf[1000]? :P
17:31:13 <Cale> C often corrals you into using algorithms that you know are bad because implementing the better algorithm in C is too annoying.
17:31:25 <Peaker> Cale: C has libraries too :)
17:31:26 <roconnor> s/ML/ocaml
17:31:32 <drdo> Cale: that's pretty much what happens in large C programs
17:31:38 <mm_freak> elliott: i never put them there, because they tend to give you worse performance in general
17:31:43 <Cale> Peaker: haha, sort of.
17:31:48 <mm_freak> better to use seq and deepseq properly
17:31:49 <Peaker> People don't write nice C libraries much, though
17:31:57 <acowley> Cale: that is true!
17:32:19 <acowley> I echo drdo
17:32:19 <roconnor> mm_freak: Data.Map has lots of !'s in it
17:32:26 <acowley> this is why FFI from Haskell into C is so great
17:32:27 <benmachine> I always thought that the standard C library was much worse than it needed to be
17:32:32 <Peaker> There are some things that are very hard to abstract into good libraries (e.g: You can make a nice red black tree library, but then it will use ptrs, and if you need compact indexes for your huge array, you'll have to rewrite or adapt yuckily)
17:32:36 <Jafet> rwbarton: char bugs[42][1000]
17:32:42 <Eduard_Munteanu> It's also something like... "oh I didn't write this cool container myself, maybe it's not 100% optimized. Maybe I'll use a dumb list for now..." :)
17:32:45 <Jafet> Errr
17:32:45 <elliott> mm_freak: Nah, that's not true. Adding exclamation marks has improved the performance of this program always, unless I'm actually using laziness explicitly.
17:32:47 <benmachine> like, if I was setting out to write a helpful library, I feel I could do better without even trying that hard
17:32:54 <Jafet> You know what, let's just say I did mean to type that
17:32:55 <elliott> mm_freak: I mean, it might be true for your programs, but it isn't for mine :)
17:32:57 <mm_freak> roconnor: if you're talking about the internals, i don't know and neither do i care =)
17:33:07 <mm_freak> roconnor: if you're talking about (!), then haha, funny =P
17:33:10 <Peaker> Parameteric polymorphism would help so much in C.. Templates are so badly implemented PP though
17:33:21 <elliott> mm_freak: Well, you should care because it's an example of strictness helping performance :)
17:33:39 <elliott> You do use lots of exclamation marks, implicitly, through the fast libraries you utilise.
17:33:40 <roconnor> mm_freak: I guess I've been thinking about my need to add similar !'s to Data.PSQueue to reduce heap use.
17:33:41 <mm_freak> elliott: depends on the application…  in general strict fields will decrease performance instead of increasing it
17:34:03 <Eduard_Munteanu> Templates... C...? kmc will smite you!
17:34:04 <Eduard_Munteanu> :P
17:34:05 <elliott> mm_freak: s/in general/in my applications/
17:34:15 <elliott> It really isn't true for just about everything I write, and I do utilise laziness.
17:34:16 <mm_freak> elliott: of course if you have just a data Point a = Point a a, then strict fields are reasonable, because you seldomly use only one of the values alone
17:34:36 <roconnor> whew.  /me feels better about strict fields in his RGB code
17:34:52 <Cale> Peaker: Yeah, no parametric polymorphism, no particularly well-enforced conventions for memory-allocation,...
17:35:14 <Peaker> Cale: In a single project, you generally have well-enforced conventions for memory
17:35:26 <elliott> Twenty-four out of twenty-five fields of the ADTs I define are strict in this project. :p
17:35:35 <Cale> Yeah, but it destroys your ability to arbitrarily use libraries.
17:35:36 <elliott> Oh, add two to both totals.
17:35:39 <Peaker> Cale: I'm working on a large C project in practice, and manual memory management has not costed us much in development/debugging time, but has given us great operational benefits
17:35:42 <mm_freak> elliott: it's not actually about /using/ laziness in this case…  if you have two fields, but one changed often, but referred to seldomly, then strict fields will be worse
17:35:52 <elliott> (Yes, after adding them and seeing they improved performance.)
17:35:57 <elliott> mm_freak: Sure.
17:35:58 <Eduard_Munteanu> Now if only people were more eager to mix languages.
17:36:02 <Eduard_Munteanu> Like Haskell and C.
17:36:05 <Peaker> Cale: Yeah, for large projects, you have a half-assed common-lisp in there anyway :-)  (i.e: a lot of your own libraries)
17:36:22 <Eduard_Munteanu> Usually such an option is dismissed by C people.
17:36:27 <Peaker> Using arbitrary NIH C code is hard, most C code around the internet is bad
17:36:27 <Cale> Libraries which use the wrong conventions can force memory leaks, which make them unusable.
17:36:34 <Jafet> Wie makes sense das?
17:36:42 <mm_freak> elliott: anyway, in general it's better to force at the right place…  even if strict fields give you higher performance, explicit intelligent forcing will give you even more
17:36:59 <elliott> Mmf, no way to go from a CInt or whatever to a SocketOption in Network.Socket?
17:37:06 <elliott> I might have to use the FFI directly...
17:37:10 <Peaker> Cale: well, good libraries document the memory allocation use.. And great libraries just take their allocations as arguments and document what lifespans they should have
17:37:24 <Peaker> Cale: (i.e: great libraries generally defer allocations to their caller and do not allocate)
17:37:25 <Eduard_Munteanu> But yeah, I guess it'd be nice to see a program begin his life as Haskell code and getting progressively refined to C.
17:37:33 <Eduard_Munteanu> (not that you need to reach that point)
17:38:04 <mm_freak> elliott: no, there is no way to convert directly, unless you find conversion functions in Network.Socket
17:38:21 <elliott> mm_freak: I don't :)
17:38:27 <elliott> But you'd think it'd derive Enum or something.
17:38:32 <elliott> Or have its own implementation I guess.
17:39:15 <mm_freak> might be a deliberate choice not to derive it
17:39:30 <elliott> Strange for a low-level interface.
17:40:06 <mm_freak> actually not so strange…  safety may be a rationale
17:40:27 <elliott> How does it give safety?
17:40:44 <mm_freak> Enum-based conversion can go wrong badly
17:40:51 <mm_freak> where do you get the CInt from anyway?
17:41:05 <elliott> Well, it's not a CInt, it's just an int, but the module seems to use CInts a lot
17:41:10 <elliott> it's the same API as before
17:41:32 <mm_freak> my question is what gives you socket option identifiers as integers in the first place
17:41:40 <mm_freak> some FFI library?
17:41:59 <elliott> The API I mentioned implementing before, another program communicating with mine
17:42:16 <mm_freak> i see
17:42:26 <Jafet> Fix the program?
17:42:39 <elliott> Jafet: It's a defined API.
17:42:44 <Jafet> Fix the API?
17:42:57 <elliott> "I have a problem." "Why not ignore it?"
17:43:08 <mm_freak> i'm sensing this could go all the way down to "fix the boss"
17:43:13 <drdo> elliott: That often works well in practice!
17:43:32 <elliott> It's my go-to method.
17:43:41 <Jafet> The values of the socket options are probably unspecified
17:43:45 <mm_freak> bosses are generally quite strong, static and lazy
17:43:51 <Jafet> The API has no business specifying them
17:44:04 <elliott> Jafet: The API isn't mine.
17:44:15 <elliott> Oh wait, it does define them.
17:44:19 <elliott> Disregard me, I'm an idiot.
17:44:28 <Jafet> @remember mm_freak bosses are generally quite strong, static and lazy
17:44:29 <lambdabot> Good to know.
17:44:44 <Cale> packSocketOption :: SocketOption -> CInt
17:44:45 <Cale> lol
17:44:51 <Cale> only I don't think it's exported
17:44:57 <elliott> Wrong way around :P
17:45:06 <mm_freak> it's not
17:45:08 <elliott> But yeah, my problem doesn't exist. Thanks Jafet, you made it go away, with your mind.
17:45:27 <mm_freak> packSocketType is there, but no packSocketOption
17:45:34 * Jafet bows
17:45:56 * mm_freak gone
17:46:00 <Jafet> There's always unsafeCoerce
17:46:14 <kmc> maybe you've only worked for shitty bosses
17:46:21 <roconnor> mm_freak: thanks
17:46:36 <mm_freak> roconnor: for what?
17:46:46 <roconnor> mm_freak: this conversation
17:47:14 <mm_freak> ah, there you go =)
17:47:42 <mm_freak> my thanks…  and good night, fellows
17:47:55 <benmachine> are we talking about socket options
17:48:16 <elliott> We were. Now w're not.
17:48:19 <benmachine> oh
17:48:22 <benmachine> noted
17:48:56 <benmachine> I had a plan for a new network library
17:49:02 <benmachine> turns out writing good FFIs is dull
17:49:11 <roconnor> benmachine: does it include being able to set socket timeouts?
17:49:31 <benmachine> roconnor: yes
17:49:39 <roconnor> I want!
17:49:42 <benmachine> :P
17:49:53 <benmachine> I also started writing a patch against network that did that
17:49:56 <benmachine> but it's a big API change
17:49:59 <roconnor> I can't believe we've gone 10 years without being able to set socket timeouts
17:50:06 <benmachine> on account of how the current API is inadequate
17:50:14 <benmachine> yeah we need a strike force or something
17:50:20 <benmachine> I blame Twey for not turning up to CamHac :P
17:50:37 <roconnor> I'd sort of like to do it, but I'm toally unqualified.
17:54:58 <Peaker> roconnor: can't socket timeouts be done via async timeout exceptions?
17:55:25 <roconnor> hmm
18:08:32 <roconnor> Peaker: what are async timeout exceptions?
18:09:12 <elliott> roconnor: spawn a thread to cause an exception in the thread reading, start blocking read, handle exception?
18:09:19 <Peaker> roconnor: something like:  timeoutOn timeout action = forkIO (threadDelay timeout >> throwTo ..) ..
18:09:25 <elliott> yay, I was right
18:09:37 <elliott> bye nets
18:16:56 <drdo> Hmm, why won't cabal install install an older version of a package as a dependency to some other package?
18:17:51 <dcoutts> drdo: in general it can do, so it must be something specific to your situation
18:18:16 <drdo> I'm trying to install Agda that depends on alex <3 and it says it can't find a suitable alex version
18:18:28 <drdo> cabal: The program alex version >=2.0.1 && <3 is required but it could not be found
18:18:44 <dcoutts> drdo: ah, that's an instance of the problem that cabal doesn't actually track dependencies on tools, only libs
18:18:52 <dcoutts> (currently)
18:18:54 <elliott> cabal install alex
18:19:14 <drdo> elliott: that installs a > 3 version
18:19:24 <dcoutts> cabal install 'alex < 3'
18:19:29 <elliott> oh
18:19:32 <elliott> yeah what dcoutts said
18:19:35 <drdo> oh cool
18:19:56 <drdo> dcoutts: i also had to install happy, the same thing happened
18:20:09 <dcoutts> yep, like I said, it doesn't track deps on tools
18:20:13 <dcoutts> yet
18:20:18 <drdo> What exactly is a tool?
18:20:23 <drdo> versus a lib
18:21:20 <dcoutts> drdo: tools are programs, binaries, you can run them.  libs are Haskell libraries, you use them in other libs & progs
18:21:26 <dcoutts> they're registered with ghc-pkg
18:21:34 <kmc> for a lib it would add a -package flag to the ghc command line
18:21:53 <drdo> dcoutts: that's a very trivial difference
18:22:14 <dcoutts> drdo: tools include non-Haskell tools, e.g. perl
18:22:24 <dcoutts> so it doesn't correspond 1:1 with cabal packages
18:22:48 <drdo> oh that's another matter then
18:23:06 <Eduard_Munteanu> Why not add it as a fake lib dependency?
18:23:19 <dcoutts> Eduard_Munteanu: the plan is just to do it properly
18:23:19 <Eduard_Munteanu> It makes sense for alex
18:24:07 <Eduard_Munteanu> Yeah, but that's stepping on distro package management toes anyway.
18:24:15 <dcoutts> not really
18:24:23 <elliott> You want to keep the alex modules hidden though
18:24:29 <Eduard_Munteanu> I mean, there's a fair bit of overlap in goals.
18:24:32 <Eduard_Munteanu> Ah.
18:24:37 <elliott> That's kind of minor though :P
18:24:42 <elliott> But you don't really want it linked in.
18:24:43 <dcoutts> Eduard_Munteanu: it'd just handle the case that a tool is provided by a cabal package, it's not going to install perl for you
18:25:19 <dcoutts> Eduard_Munteanu: so it's the same as how we only handle Haskell libs, not platform C libs
18:26:33 <dcoutts> well, the cabal tool anyway, tools that translate .cabal -> native can of course have proper dependencies on non-haskell packages
18:27:25 <Eduard_Munteanu> Yeah.
18:29:43 <Peaker> drdo: I scrolled back, and thought you were expressing your love for alex with a heart: <3
18:37:27 <siracusa> Is there a function :: IsString s => s -> s -> s to concatenate two string-like values?
18:37:38 <elliott> Monoid?
18:37:45 <elliott> You can't do that with just IsString.
18:38:10 <Jafet> :t (++)
18:38:12 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:38:23 <elliott> Caleskell...
18:38:45 <dibblego> as I understand it, IsString a is like (a -> String) which is also a Monoid
18:39:12 <shachaf> dibblego: IsString is String -> a
18:39:20 <dibblego> oh right
18:39:27 <shachaf> (It should be both, really.)
18:39:30 <Jafet> Dionom
18:40:53 <shachaf> class IsString a where isString :: a -> Bool
18:41:02 <shachaf> instance IsString String where isString _ = True
18:41:08 <elliott> haha
18:41:12 <elliott> so useful
18:41:24 <elliott> instance isString (Either String a) where isString = isLeft
18:42:01 <Jafet> instance isString (Either String String) where isString = const True
18:42:26 <elliott> instance IsString Dynamic where isString x = isJust (fromDyn x :: String)
18:42:27 <elliott> erm
18:42:29 <elliott> instance IsString Dynamic where isString x = isJust (fromDyn x :: Maybe String)
18:43:22 <shachaf> instance Typeable a => IsString a where isString x = isJust (cast x :: Maybe String) --, why not?
18:43:32 <shachaf> Of course, that defeats the purpose of having it work for Eithers and such.
18:43:54 <kmc> haha shachaf
18:43:58 <kmc> that's a pro instance
18:44:14 <elliott> class IsValue a where isValue :: a -> Bool
18:44:19 <elliott> instance IsValue a where isValue _ = True
18:44:22 <kmc> No match for "THATSAPROINSTANCE.COM".
18:44:23 <elliott> go home everyone
18:44:34 <elliott> that saproin stance
18:44:40 <kmc> this would be something like http://enterprise-js.com/
18:45:34 <shachaf> instance Newtype a String => IsString a where isString _ = True
18:46:04 <kmc> instance IsValue (a -> b) where isValue _ = False  -- for enterprise compliance
18:46:33 <Peaker> shachaf: Newtype is probably a bad class name, because it doesn't matter if it is a newtype or if it is another kind of equivalence/wrapper
18:46:47 <elliott> Peaker: it's an existing name
18:46:52 <elliott> one I'd like to see changed though
18:46:55 <Peaker> too bad :)
18:46:59 <elliott> http://hackage.haskell.org/package/newtype
18:47:03 <elliott> :t ala
18:47:05 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
18:47:05 <Peaker> it's a name that will lie
18:47:07 <shachaf> class IsFunction a where isFunction :: a -> Bool; instance IsFunction a where isFunction _ = True
18:47:18 <Peaker> because people will inevitably make  useful instances that are not newtypes
18:47:20 <elliott> shachaf: lies
18:47:22 <parcs> there should be an IsFromListable
18:47:23 <kmc> on bno no no on on bnbo no!
18:47:34 <kmc> on bonobo: no!
18:47:35 <shachaf> instance IsFunction everything where isFunction anything = True
18:49:51 * shachaf doesn't like the keyword "where".
18:49:54 <shachaf> Haskell has too many keywords.
18:50:14 <elliott> What would you call it?
18:51:10 <Peaker> I like "where"
18:51:32 <Peaker> I don't like "let" very much
18:52:01 <elliott> let is a code smell imo
18:52:02 <Peaker> maybe "where" could be allowed in arbitrary sub-expressions
18:52:19 <Peaker> so there's just one way to scope local definitions like that
18:52:40 <elliott> That would be nice.
18:52:59 <Peaker> maybe it could cause some ambiguity
18:53:08 <Peaker> (where does this where apply?)
18:54:07 <elliott> it applies where it applies
18:54:11 <elliott> the where applies where the where applies
19:04:08 <NemesisD> anyone know the status on test suites in cabal? i tried a while ago and the docs indicated the type: field could be exitcode-stdio-1.0 and detailed-1.0 but that one of those was not completed, deprecated or something like that
19:04:59 <dcoutts> NemesisD: the detailed type is still work in progress, though it's getting nearer
19:05:14 <dcoutts> we accidentally documented it prematurely in the user guide
19:06:02 <NemesisD> dcoutts: i was looking to use hspec. is it still adviseable that i use exitcode-stdio-1.0 then?
19:06:17 <dcoutts> NemesisD: yep
19:09:30 <NemesisD> dcoutts: project organization question, perhaps a silly one. i typically put a directory/module in project foo called Foo.Testing (in dir foo/Testing/Main.hs) where i put my test suite. if my project is not a library but just an executable, need i worry that any of that code will be compiled in the executable that cabal generates?
19:11:51 <dcoutts> NemesisD: I'm not sure I follow
19:12:02 * dcoutts reads that again
19:13:04 <dcoutts> NemesisD: if your package has an exe, then if that exe doesn't import your testing code then it will not get compiled into that exe
19:13:16 <dcoutts> and you could use that extra module in your testsuite
19:13:25 <dcoutts> NemesisD: is that what you were getting at?
19:14:32 <dalaing> NemesisD: apparently there's a new enumeratee tutorial coming soon
19:20:05 <frio> hey all, reasonably new user here and looking for some style advice
19:20:25 <kmc> hi frio
19:20:47 <frio> i want to generate a UUID, write a file using that UUID as the filename, and then write to beanstalk that the file has been written (for some delayed processing) :)
19:20:53 <frio> gday kmc
19:21:03 <frio> so, i can see how to do that, but all three are IO actions
19:21:12 <frio> so the temptation is to just wrap it all in one big IO action and leave it at that
19:21:21 <frio> is there, perhaps, a better way of doing that?
19:21:42 <kmc> that seems fine to me
19:21:52 <frio> cool then
19:22:10 <kmc> do { u <- genUUID; writeFile (nameFor u) filecontents; writeToBeanstalk }
19:22:34 <frio> yeah, thats essentially what ive got currently
19:23:08 <frio> im just mindful of doing as much as i can purely, but being that none of those are pure actions, was wondering what the style is
19:23:21 <frio> (so far working through RWH and learn you a haskell, most of the code is pure)
19:23:44 <frio> thanks kmc
19:25:01 * hackagebot system-filepath 0.4.1 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.1 (JohnMillikin)
19:25:02 * hackagebot system-filepath 0.3.2 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.3.2 (JohnMillikin)
19:43:46 <KirinDave> I'm trying to figure out
19:43:48 <KirinDave> https://github.com/KirinDave/Fanboy/blob/master/Fanboy/Parser.hs#L25
19:44:07 <KirinDave> Why can't I write this as "where takeN = B.pack <$> replicateM"
19:44:13 <KirinDave> It then stops typechecking
19:49:22 <kmc> why could you?
19:49:40 <kmc> note that «B.pack <$> replicateM count repeatedParser» is «B.pack <$> (replicateM count repeatedParser)»
19:50:19 <Axman6> KirinDave: haskell can't magically fill in missing parameters
19:50:39 <kmc> if i write «takeN x y = a + f x y» i can't replace that with «takeN = a + f»
19:50:48 <KirinDave> Huh.
19:51:00 <KirinDave> I figured it'd apply to f not to a + f.
19:51:00 <aavogt> > (sin + cos) 2
19:51:01 <lambdabot>   0.4931505902785393
19:51:11 <kmc> haha
19:51:15 <kmc> aavogt, not helping ;)
19:51:16 <sam___> What code would I need to do to make this work: Combine 4 6 = 46?
19:51:24 <kmc> sam___, s/Combine/combine/
19:51:30 <rwbarton> KirinDave, if you wrote "takeN = a + f" it would be the same as "takeN = (a + f) x y"
19:51:34 <rwbarton> er
19:51:36 <kmc> > let combine x y = read (show x ++ show y) :: Int in combine 4 5
19:51:37 <rwbarton> "takeN x y = (a + f) x y"
19:51:38 <lambdabot>   45
19:51:42 <rwbarton> not "takeN x y = a + (f x y)"
19:51:42 <KirinDave> Ahh
19:51:46 <kmc> > let combine x y = x*10 + y in combine 4 5
19:51:48 <lambdabot>   45
19:52:00 <KirinDave> Is there a way to write that point free?
19:52:19 <kmc> @pl takeN count repeatedParser = B.pack <$> replicateM count repeatedParser
19:52:20 <lambdabot> takeN = ((B.pack <$>) .) . replicateM
19:52:31 <kmc> not so good
19:52:31 <elliott> KirinDave: fmap F.pack .: replicateM
19:52:40 <rwbarton> (and please don't write ((B.pack <$>) .) . replicateM)
19:52:52 <KirinDave> rwbarton: Writing it now. u mad? ;)
19:52:53 <kmc> @hoogle (.:)
19:52:53 <lambdabot> No results found
19:52:57 <kmc> hmm, what package? sec?
19:53:06 <KirinDave> Yeah I dunno what .: is.
19:53:09 <copumpkin> jelly
19:53:16 <elliott> (.:) = (.) . (.)
19:53:26 <elliott> just define it anywhere :P
19:53:35 <kmc> i don't see it in any package :/
19:53:38 <elliott> hayoo says it's in, uh, Synthesizer.ApplicativeUtility
19:53:48 <elliott> but it's so short that i guess most people just define it in a file and call it a day
19:53:50 <elliott> :t (.:)
19:53:51 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
19:53:53 <kmc> somehow don't think that's the right think to depend on
19:53:55 <elliott> lambdabot has it. over-general as usual
19:53:58 <kmc> sec must have something analygous
19:54:02 <kmc> gah
19:54:07 <kmc> replace all the words i say with correct ones
19:54:12 <elliott> algnaygus
19:54:16 <Clint> analigious
19:54:52 <kmc> analicious
19:54:58 * kmc cough
19:55:00 <KirinDave> I guess I still don't fully understand how to reduce an expression.
19:55:06 <KirinDave> (.) . (.)
19:55:10 <dmwit> Is this a bad time to come back?
19:55:11 <KirinDave> Just… I cannot even figure it.
19:55:15 <dmwit> This seems like a bad time to come back.
19:55:20 <kmc> paging dr. Cale
19:55:26 <monochrom> @pl \x y -> a + f x y
19:55:27 <lambdabot> ((a +) .) . f
19:55:27 <kmc> @unpl f = (.) . (.)
19:55:28 <lambdabot> f i b c f = i (b c f)
19:55:42 <kmc> KirinDave, start with  ((.) . (.)) f g x
19:55:52 <dmwit> KirinDave: Reduction is easy. (\x -> e1) e2 reduces to e1, but with every x replaced by e2.
19:56:10 <Eduard_Munteanu> :t (Prelude..) Prelude.. (Prelude..)
19:56:11 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:56:13 <dmwit> (...okay, so laziness makes this a bit more complicated. So sue me.)
19:56:20 <kmc> dmwit, only operationally
19:56:24 <kmc> but you forgot to mention variable capture!
19:56:39 <kmc> @src (.)
19:56:39 <lambdabot> (f . g) x = f (g x)
19:56:39 <lambdabot> NB: In lambdabot,  (.) = fmap
19:56:40 <dmwit> Barendregt variable convention! Barendregt variable convention!
19:56:48 * dmwit wards off the capture monsters
19:56:53 <kmc> ((.) . (.)) f  ⇒ (.) ((.) f)
19:56:58 <kmc> according to the source of (.)
19:57:04 <coppro> z/win 2
19:57:12 <dmwit> zomg it didn't work
19:57:32 <KirinDave> kmc: I am not sure how you mae that step.
19:57:37 <kmc> @src (.)
19:57:37 <lambdabot> (f . g) x = f (g x)
19:57:37 <lambdabot> NB: In lambdabot,  (.) = fmap
19:57:42 <kmc> let f = (.), g = (.)
19:57:43 <KirinDave> Ahh
19:57:59 <kmc> now (.) ((.) f) g  ≡ ((.) f) . g
19:58:22 <kmc> (((.) f) . g) x  ⇒ ((.) f) (g x)
19:58:26 <kmc> by the same rule
19:58:36 <dmwit> (.) . (.) => (.) (.) (.) => (\f g x -> f (g x)) (.) (.) => (\g x -> (.) (g x)) (.) => (\x -> (.) ((.) x))
19:58:38 * kmc wonders if he's made a typo anywhere
19:58:40 <Eduard_Munteanu> @unpl (.) . (.)
19:58:41 <lambdabot> (\ i b c f -> i (b c f))
19:58:55 <dmwit> We can substitute in definitions at the end, there, too.
19:59:33 <dmwit> \x -> (\f g y -> f (g y)) ((\h j z -> h (j z)) x))
20:00:07 <dmwit> \x -> (\f g y -> f (g y)) (\j z -> x (j z))
20:00:26 <dmwit> \x -> (\g y -> (\j z -> x (j z)) (g y))
20:00:56 <dmwit> I think I screwed up somewhere.
20:01:26 <dmwit> Ah, no.
20:01:40 <dmwit> \x -> (\g y -> (\z -> x (g y z)))
20:01:49 <dmwit> And now condensing lambdas, that's
20:01:55 <dmwit> \x g y z -> x (g y z)
20:02:20 <dmwit> yaaaay
20:02:52 <dmwit> And since (.) is actually linear, we didn't run into any problems vis-a-vis representing laziness.
20:06:18 <KirinDave> I can follow the logic
20:06:25 <KirinDave> But I don't have an intuition for it.
20:06:36 <dmwit> Oh, well, you didn't ask for intuition.
20:06:40 <dmwit> That's a very different question.
20:07:16 <dmwit> Let's see here...
20:08:10 <dmwit> Okay, the intuition comes from imagining feeding this thing two functions.
20:08:17 <dmwit> ((.) . (.)) f g
20:08:32 <dmwit> The first pass gobbles up f:
20:09:07 <dmwit> ((.) . (.)) f => ((f .) .)
20:09:41 <dmwit> ((f .) .) g => (f .) . g
20:10:39 <dmwit> Hm, I guess that doesn't help, unless you first already had the intuition about what (f .) . g does.
20:10:42 <dmwit> =P
20:11:00 <dmwit> But again, the way you get an intuition for (f .) . g is by tracing through what it does when you hand it a bunch of arguments.
20:11:14 <dmwit> ((f .) . g) x => f . g x
20:11:21 <dmwit> (f . g x) y => f (g x y)
20:11:30 <dmwit> so ((f .) . g) x y => f (g x y)
20:12:03 <kmc> KirinDave, I think it's pretty hard to have intuition for things like ((.) . (.))
20:12:07 <kmc> that's a specific case people remember
20:12:24 <kmc> using it in "real code" is suspect
20:12:26 <dmwit> Your understanding has to go in little steps.
20:12:34 <KirinDave> kmc: I wonder.
20:12:35 <kmc> like someone said, i would write (f .: g) x y = f (g x y)
20:12:37 <kmc> and then use it
20:12:44 <dmwit> Oh, here's another way to understand it!
20:12:49 <KirinDave> Yeah
20:12:53 <KirinDave> that's very comprensible.
20:12:59 <dmwit> Maybe you'll like this one better, kmc + KirinDave.
20:13:00 <KirinDave> in fact, I even like the sort of shape of the .:
20:13:11 <KirinDave> "func with 1 eats func with 2"
20:13:19 <dmwit> (.) is a combinator that takes a function, and applies it to the result of another function.
20:13:27 <dmwit> Let's call it "result" instead.
20:13:54 <dmwit> result :: (a -> b) -> ((input ->) a) -> ((input ->) b)
20:14:13 <dmwit> So, "result" goes under functions in some sense.
20:14:23 <dmwit> result . result goes into the result of the result.
20:14:54 <djahandarie> > iterate "a result in "
20:14:55 <lambdabot>   Couldn't match expected type `a -> a'
20:14:56 <lambdabot>         against inferred type `[GHC.T...
20:15:06 <copumpkin> faildjahandarie
20:15:10 <djahandarie> Gah
20:15:10 <djahandarie> Haha
20:15:15 <dmwit> ?where sec
20:15:16 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
20:15:16 <djahandarie> Out of shape :(
20:16:40 <KirinDave> I remember this post
20:16:45 <KirinDave> a few months ago I wasn't ready fo rit.
20:19:19 <copumpkin> the Chan documentation is laughably inadequate
20:20:22 <kmc> oh yeah?
20:20:26 <kmc> what's there to say about chans
20:20:32 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
20:20:51 <kmc> ok, "Build and returns a new instance of Chan." is kind of tautological
20:20:51 <copumpkin> say which operations block, if any
20:20:54 <kmc> hmm
20:21:04 <copumpkin> isEmptyChan is deprecated
20:21:04 <kmc> i would say "it's obvious" but, meh, it's not really
20:21:07 <copumpkin> but the documentation says nothing
20:21:07 <kmc> i see
20:21:14 <kmc> bug report?
20:21:14 <dmwit> copumpkin: You're supposed to read the paper, probably.
20:21:39 <copumpkin> of course :)
20:21:42 <kmc> "read the paper" was probably a reasonable view for concurrency primitives in, like, 1995
20:21:47 <copumpkin> kmc: who do I file it against?
20:22:12 <kmc> file a meta-bugreport on the difficulty of filing bugreports on 'base'
20:22:21 <kmc> anyway base.cabal sez http://hackage.haskell.org/trac/ghc/newticket?component=libraries/base
20:23:20 <KirinDave> ha
20:24:28 <dmwit> copumpkin: The entire implementation is like 50 lines. I just counted them by hand, that's how tiny the implementation is.
20:24:30 <kmc> if the GHC project were starting today, I wonder if they'd still target native code, or pick something like JVM or CLR
20:24:41 <copumpkin> probably a custom VM
20:24:56 <copumpkin> since neither the jvm or clr support hooking the GC for the shit that haskell needs
20:25:03 <kmc> i think still no, because popularity was never a goal, and lots of the early research is on micro-optimizations
20:25:05 <copumpkin> nor do they have super cheap allocation, like haskell needs
20:25:07 <kmc> yeah
20:25:26 <kmc> but what's the benefit of a custom STG VM, versus compiling out the STG
20:25:32 <kmc> i guess there are some; YHC does it this way
20:25:44 <kmc> but you don't get the huge practical benefit of easily calling Java / .NET libraries
20:25:52 <kmc> you can still get that with extra effort, though
20:26:15 <copumpkin> there's actually (apparently) a major GC issue with a lazy language on a conventional GC
20:26:24 <copumpkin> that ed keeps mentioning to me but I keep forgetting
20:26:40 <copumpkin> that's what I was talking about when I said you needed to hook the GC
20:26:41 <KirinDave> Yeah
20:26:55 <KirinDave> Haskell's evaluation strategy would be pretty tough to accomplish efficiently in the JVM.
20:27:08 <KirinDave> At least as I understand the internals of both environments.
20:27:14 <copumpkin> I mean even just the memory thing
20:27:21 <copumpkin> it's something to do with letting the GC see through thunks/accessors in funky ways
20:27:30 <kmc> like selector thunks?
20:27:33 <copumpkin> so that unused halves of tuples don't get retained unnecessarily and such
20:27:37 <kmc> yeah
20:27:38 <copumpkin> can't remember the details :)
20:27:55 <kmc> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks
20:28:17 <kmc> apparently there's a Wadler paper on it
20:28:22 <copumpkin> I see
20:28:37 <kmc> "Some functional programs may use more space than would be expected. A modification to the garbage collector is suggested which solves this problem in some cases. Related work is discussed."
20:28:42 <kmc> that's a nicely vague yet to-the-point abstract
20:29:10 <copumpkin> the garbage collector sees all, knows all.
20:29:25 <KirinDave> kmc: "Read on, and come with me through the roots of the world."
20:29:33 <copumpkin> but anyway
20:29:38 <copumpkin> that's what's missing from jvm/clr
20:29:43 <copumpkin> or so I'm told
20:29:44 <kmc> i see
20:29:46 <int80_h> copumpkin, is that you on reddit?!
20:29:52 <copumpkin> int80_h: which?
20:30:00 * hackagebot iptables-helpers 0.4 - Static checking of iptables rules  http://hackage.haskell.org/package/iptables-helpers-0.4 (EvgenyTarasov)
20:30:05 <copumpkin> int80_h: probably, though
20:30:13 <int80_h> the TChan versus MChan thread.
20:30:17 <copumpkin> yeah
20:30:20 <int80_h> that's me
20:30:24 <copumpkin> ah :)
20:30:27 <int80_h> anyway I thought we could continue here
20:30:27 <copumpkin> cool
20:30:34 <KirinDave> Where is this?
20:30:35 <elliott> a copumpkin is the god of pumpkins?
20:30:37 <copumpkin> anyway, no exceptions
20:30:38 <elliott> sounds problematic
20:31:16 <int80_h> copumpkin: if I block that means nothing happens until the block is removed right?
20:31:33 <copumpkin> that particular thread will stop until someone sticks something else into the chan
20:31:50 <dmwit> (No guarantees it will start back up when that happens, either.)
20:32:26 <copumpkin> no guarantees your computer won't get hit by cosmic rays and fill your hard drive with beatles songs
20:32:33 <int80_h> hmm, okay I think I need TChan then
20:32:51 <KirinDave> int80_h: TChan DOES have some pretty good cosmic ray protection.
20:33:12 <elliott> copumpkin: that happened to me the other day
20:33:13 <int80_h> ASUS guarantees my hard drive won't be filled with beetles songs.
20:33:20 <int80_h> so, there's that.
20:33:49 <KirinDave> int80_h: So what are you hoping to have happen with a tchan vs a mchan?
20:33:54 <dmwit> Seems like the real distinction between TChan and MChan is whether it uses STM or not.
20:34:04 <dmwit> Both of them block occasionally, so that's not really a distinction.
20:34:14 <dmwit> (specifically on reads)
20:34:14 <KirinDave> dmwit: Yeah, but… they use totally different mechanisms to accomplish what they're doing. :)
20:34:19 <int80_h> KirinDave: MChan's isEmptyChan is depracated, ghc itself ordered me to use a TChan if I need to check for an empty Chan.
20:34:31 <KirinDave> Hah
20:34:36 <KirinDave> Yeah
20:34:49 <c_wraith> int80_h: isEmptyChan can deadlock - stm prevents that
20:34:53 <KirinDave> Yeah
20:35:02 * hackagebot iptadmin 1.1.0 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.1.0 (EvgenyTarasov)
20:35:19 <KirinDave> int80_h: This is one of those things tho where people gently ask why you'd want to check if the chan is empty
20:35:23 <int80_h> copumpkin made me re-evaluate weather or not I really needed to do that. After some thought I think I do. But I had to stop and think a minute first.
20:35:56 <int80_h> KirinDave: because I can't have it waiting for something to happen to an empty Chan when I try to read form one. If it's empty I won't read from it.
20:36:24 <KirinDave> int80_h: THere are methods for doing timeouts
20:36:25 <bos> preflex: seen dons
20:36:26 <preflex>  dons was last seen on #haskell 1 day, 12 hours, 53 minutes and 54 seconds ago, saying: cheers byorgey
20:36:44 <KirinDave> int80_h: You can just set a short timeout
20:36:50 <dmwit> int80_h: If you can continue without reading from the channel, why are you reading from the channel in the first place?
20:36:54 <bos> preflex: tell dons we really need a new HP release for people using OS X Tiger
20:36:55 <preflex>  Consider it noted.
20:37:09 <dmwit> Asked another way: why don't you have more threads?
20:37:31 <int80_h> dmwit: ah, I thought I may have to make more threads. That may be the real answer. I was trying to avoid that.
20:37:34 <shachaf> bos: Isn't Tiger an old version?
20:37:48 <dmwit> int80_h: Haskell threads are very, very cheap.
20:37:50 <bos> uh, Mac OS OX "some fucking cat or other"
20:37:54 <KirinDave> Lion
20:37:55 <copumpkin> lion
20:38:00 <KirinDave> The nemesis to haskellers
20:38:06 <KirinDave> Or really anyone doing inf dev too. :(
20:38:08 <elliott> can't wait for OS X Cat
20:38:11 <KirinDave> So much is broken. Been making my life hell.
20:38:14 <elliott> OS X Some Bloody Feline
20:38:14 <KirinDave> elliott: OSX Feline.
20:38:46 <elliott> OS X.9 "Uhh... Hyena I guess... we really need a new naming scheme"
20:39:03 <kmc> yeah, the "avoid threads at all costs" mentality is really unfortunate
20:39:23 <kmc> it might be up there with pervasive mutation
20:39:32 <dmwit> OSX Flame Leopard, OSX Lightning Leopard, OSX IceRa Leopard...
20:39:46 <kmc> in terms of ubiquitous habits that have to be un-learned to become effective at using Haskell
20:40:18 <kmc> i think the computational expense of OS threads is only part of it
20:40:38 <dmwit> The programming effort of managing lots of threads is probably a big part of it.
20:40:51 <kmc> the bigger issue is that people are used to languages where threads are either incredibly cumbersome (C with pthreads) or fundamentally broken (CPython)
20:40:55 <aspect> shared-state threads suck if you use mutation heavily
20:40:57 <KirinDave> kmc: Actually, one of the things os thread users have to unlearn to use os threads effectively is the historic cost of os threads.
20:41:01 <copumpkin> I wonder whether we could "unapply" partially applied data constructors in haskell
20:41:05 <kmc> KirinDave, yeah
20:41:09 <KirinDave> kmc: At least on os's with good modern impls like ntpd.
20:41:12 <kmc> copumpkin, you can with vacuum! maybe.
20:41:13 <KirinDave> err, nptd.
20:41:14 <copumpkin> (5:)
20:41:16 <KirinDave> You just
20:41:19 <copumpkin> I want to get that 5 back
20:41:29 <dmwit> head . ($[])
20:41:30 <KirinDave> You just don't have to worry about inactive threads that much anymore.
20:41:31 <copumpkin> it'd have to be horribly unsafe
20:41:38 <copumpkin> dmwit: I mean for any data constructor
20:41:53 <pikhq> KirinDave: It's still extraordinarily painful.
20:41:55 <copumpkin> I guess we could do it by applying the rest to undefined, then projecting
20:42:00 <dmwit> right
20:42:03 <KirinDave> pikhq: ?
20:42:04 <Axman6> int80_h: you can easily have thousands of threads in haskell without much worry (when using GHC)
20:42:05 <copumpkin> but that'd break if some fields are strict
20:42:11 <pikhq> KirinDave: Dealing with POSIX threads.
20:42:17 <kmc> the other *other* problem is that threading is harder to get right when you have pervasive mutation
20:42:22 <copumpkin> and some data constructors contain unboxed things
20:42:22 <KirinDave> pikhq: I had a java app with 10k threads running just the other day.
20:42:24 <dmwit> copumpkin: Apply to def if it happens to be a Default instance, undefined otherwise.
20:42:28 <KirinDave> pikhq: You can't treat them like erlang actors
20:42:30 <kmc> it's not so hard when you have isolated mutation and prefer message channels
20:42:31 <dmwit> Breaks a little less. =)
20:42:32 <copumpkin> dmwit: :P
20:42:34 <kmc> right
20:42:44 <pikhq> KirinDave: No, you have to micromanage everything.
20:42:50 <kmc> so we have a) threads are expensive, b) threads are hard to use, c) threads will break because you're mutating global state everywhere
20:42:51 <KirinDave> pikhq: Oh, I see what you're saying.
20:42:56 <kmc> all of which go away in GHC Haskell
20:43:17 <pikhq> It's up there with cooperative multitasking, as seen in classic Mac OS and Win16, in terms of painfulness.
20:43:27 <dmwit> copumpkin: I mean, if we're already restricting ourselves to partially-applied constructors magically, why not assume a bit more magic somehow?
20:43:43 <kmc> (lazy evaluation is mutating global state everywhere, but in a sound, idempotent, race-free way)
20:43:45 <KirinDave> pikhq: Eh, I do a lot of thread stuff in scala right now. Without resorting to their broken actors lib
20:43:50 <copumpkin> dmwit: basically, just inspect the contents of any value's closure, if it contains something?
20:43:58 <KirinDave> pikhq: I think people underestimate how much that's all improved
20:44:06 <copumpkin> there's that unpackClosure# function but it needs some massaging to get what I'm interested in
20:44:08 <KirinDave> pikhq: Non-blocking hash tables with absurdly good constants, atomic vars, etc.
20:44:18 <dmwit> copumpkin: Wow, there's really a function named that?
20:44:21 <elliott> copumpkin: I was about to say unpackClosure#, yeah.
20:44:26 <elliott> dmwit: In GHC.Prim, for the debugger apparently.
20:44:30 <KirinDave> pikhq: SOME classes of problems, with very simple dataflow, are quite easy to write now.
20:44:33 <elliott> It has the most terrifying type.
20:44:34 <dmwit> That's kind of scary.
20:44:42 <mike-burns> Code that uses threads are harder to integration test.
20:44:42 <elliott> Quoth:
20:44:46 <elliott> unpackClosure# :: a -> (#Addr#, Array# b, ByteArray##)
20:44:49 <KirinDave> Now when you have complex interactions and decisions in your dataflow, then i agree. It's still a nightmare.
20:44:57 <pikhq> KirinDave: I was discussing POSIX threads in particular.
20:45:01 <elliott> dmwit: Another WTF one: getApStackVal# :: a -> Int# -> (#Int#, b#)
20:45:14 <dmwit> a -> Array# b -- wut.
20:45:19 <pikhq> Though the threads, mutex, etc. model *in general* is pretty nightmareish, POSIX threads are horrifying.
20:45:26 <copumpkin> the biggest WTF type in GHC.Prim though
20:45:28 <elliott> dmwit: I presume it just gets something out of this aforementioned stack without any checking.
20:45:33 <pikhq> (not that you can do much better in C)
20:45:33 <elliott> So good luck with that.
20:45:39 <copumpkin> atomicModifyMutVar# :: MutVar# s a -> (a -> b) -> State# s -> (#State# s, c#)
20:45:45 <copumpkin> let that type soak in a moment
20:45:54 <elliott> copumpkin: Wait... where did the c come from?
20:45:58 <copumpkin> exactly
20:46:03 <elliott> help?
20:46:07 <pikhq> copumpkin: *blink* *blink*
20:46:07 <elliott> I'm scared?
20:46:11 <copumpkin> that b is not a b
20:46:15 <KirinDave> copumpkin: c: random
20:46:15 <copumpkin> that b is a pair
20:46:16 <elliott> What... what is it.
20:46:18 <elliott> What.
20:46:23 <KirinDave> copumpkin: Hold me.
20:46:28 <elliott> I'm going to cry a bit now.
20:46:33 <copumpkin> pairs haven't been defined yet when GHC.Prim is built
20:46:36 <copumpkin> so they treat it as a pair
20:46:37 <KirinDave> Guys I am freakout out over a type signature what do I dooooooo?
20:46:41 <copumpkin> but they can't talk about pairs yet
20:46:42 <elliott> copumpkin: it hurts
20:46:44 <dmwit> elliott: Go on, you're okay with (a -> Array# b), but not with (a -> b) -> c?
20:46:58 <elliott> dmwit: Well, at least I can reason about the former.
20:47:01 <elliott> It's just unsafeCoerce.
20:47:09 <elliott> This is... unsafeCoerce propagated to the caller.
20:47:12 <dmwit> ...so is the latter
20:47:18 <elliott> Look, it's visceral.
20:47:22 <elliott> I can't reason about my horror.
20:47:26 <KirinDave> Haha
20:47:27 <dmwit> heh
20:47:37 <pikhq> dmwit: unsafeCoerce is already frightening.
20:47:39 <Jafet> How does one reason about unsafeCoerce
20:47:45 <KirinDave> Damnit guys I wanted to work on adding iteratee and tchan support to that haskell event reflector that got released today
20:47:52 <pikhq> Jafet: With a bottle of vodka.
20:47:53 <KirinDave> And here you are all so interesting I totally don't go in and code.
20:47:54 <elliott> Jafet: "if it's right, it works, otherwise, everything goes wrong"
20:47:58 <elliott> Jafet: It's how you reason about C programs
20:48:07 <frio> is there any way to make a constructor for an already defined type data record? I've a common use case where 4 of the fields in an 8 field record type aren't going to change, so want to cut my code a bit shorter by not defining them each time i create the record
20:48:15 <Jafet> unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
20:48:26 <elliott> ?remember Jafet unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
20:48:26 <lambdabot> I will never forget.
20:48:30 <frio> but somehow partialConstructor :: Text -> Text -> Text -> UTCTime -> Photo feels ugly
20:48:42 <dmwit> "if it's right, it always works, otherwise, it breaks when you've got 16 days of CPU time on a 16.5-CPU-time job that needs to be done one day from now"
20:48:44 <elliott> frio: Try defining defaultPhoto :: Photo.
20:48:49 <elliott> defaultPhoto{ a = b, c = d }
20:49:07 <Jafet> That's only sensible when there is a default Photo
20:49:15 <Jafet> Otherwise I'd rather write partialConstructor
20:49:21 <frio> well, it is essentially a defaultPhoto ;)
20:49:24 <elliott> "I've a common use case where 4 of the fields in an 8 field record type aren't going to change"
20:49:33 <elliott> Admittedly a and c might not have defaults.
20:49:35 <KirinDave> elliott: True story
20:49:38 <elliott> In which case partialConstructor is better.
20:49:43 <frio> its a queueablePhoto, basically, thatll then be post-processed by a separate process in the background
20:49:55 <KirinDave> elliott: See also that crazy bug in the c impl of the ruby implementation.
20:50:04 <frio> but until its been removed from the queue and processed, a good chunk of the associated fields are Nothing
20:50:16 <dmwit> instance Default DefaultableFields; partialConstructor :: DefaultableFields -> UndefaultableFields -> Photo
20:50:26 <KirinDave> Correct until observed wrong.
20:50:46 <elliott> KirinDave: What bug?
20:50:52 <Jafet> EnterprisePhoto
20:50:58 <frio> hah Jafet :p
20:50:59 <elliott> frio: Does feel like you need to split up the Photo type.
20:51:06 <KirinDave> elliott: Oh it is basically a fundamental bug in ruby's gc that will randomly segfault on you.
20:51:13 <KirinDave> elliott: Because they rely on undefined behavior.
20:51:25 <frio> essentially i cant elliott, because its defined by the Yesod database record that it represents
20:51:32 <shachaf> When a bug segfaults on you, that means it's dead, right? So it's a good thing?
20:51:54 <dmwit> frio: Define your own extra types that break Photo in half.
20:52:02 <KirinDave> elliott: http://timetobleed.com/the-broken-promises-of-mrireeyarv/
20:52:16 <dmwit> Model it how it's convenient for you, not how it's convenient for Yesod's codegen.
20:53:16 <frio> fwiw this is how its convenient for me; i model the lifecycle of a Photo moving through my system with a series of UTCTimes as columns; as it gets processed, they get changed from null (Nothing) to a stamp
20:53:25 <elliott> KirinDave: Nice.
20:53:31 <KirinDave> Man
20:53:40 <KirinDave> The difference in haskell vs. ruby community is amazing
20:53:42 <KirinDave> http://www.yesodweb.com/blog/2011/09/limitations-of-haskell
20:53:50 <KirinDave> Gets a generally positive reception
20:53:54 <KirinDave> I wrote basically the same thing
20:54:07 <KirinDave> for ruby 2 years ago, and got threats of physical violence.
20:54:20 <KirinDave> And got prominent rubyists calling me the "Joe Lieberman of ruby"
20:54:42 <kmc> http://haskell.org/haskellwiki/FAQ#How_can_I_do_X_without_resorting_to_threads.3F whee
20:54:49 <elliott> physical violence? lol
20:54:56 <KirinDave> elliott: Yeah
20:54:57 <kmc> haha KirinDave
20:54:58 <Jafet> This is because Haskell is populated with people who know the limitations of other languages
20:55:09 <elliott> KirinDave: I'm only laughing because you haven't see what /we/ do to traitors yet.
20:55:15 <KirinDave> elliott: ha.
20:55:16 <kmc> Jafet, that, and people who started learning a week ago and think Haskell is the third coming of Jesus
20:55:24 <elliott> That Yesod post caused... some inconvenience for its author, but it could be better; it /did/ have a few praises in there.
20:56:05 <KirinDave> One thing he did say
20:56:06 <KirinDave> "Ever since the Bundler Ruby tool matured, I have never once been on a Ruby project where the libraries could not be immediately installed."
20:56:07 <KirinDave> HA.
20:56:09 <KirinDave> HAHA.
20:56:19 <kmc> Haskell beginners sometimes have an unrealistically high opinion of Haskell
20:56:27 <KirinDave> Bundler is the premier tool for publishing ruby apps. Sometimes it even works!
20:56:27 <kmc> however, Haskell beginners usually know what they don't know
20:56:32 <kmc> heh
20:56:38 <kmc> KirinDave, can I see your Ruby article?
20:56:54 <KirinDave> kmc: http://kirindave.tumblr.com/post/60776407/the-opposite-of-momentum
20:57:23 <frio> kmc: for the most part though, that's because haskell is so momentously different to any language your average programmer has come across before
20:57:30 <frio> so you're pretty aware you're starting right at the bottom
20:57:35 <byorgey> preflex: seen dcoutts
20:57:35 <preflex>  dcoutts was last seen on #haskell 1 hour, 44 minutes and 13 seconds ago, saying: NemesisD: is that what you were getting at?
20:57:47 <sebz> is there a cleaner way to write y x = x >>= f >>= g >>= h?
20:57:49 <KirinDave> Yeah, also, haskell makes no bones about having experimental features out there
20:58:01 <KirinDave> Like, you could never use arrows and no one would be mad at you
20:58:04 <frio> moving from java to python, for instance, leaves you with a bunch of preconceived notions about how shit should work that make you angry when they don't
20:58:20 <KirinDave> Because arrows are there, but just not that important. The language is modular, do what you need to do.
20:58:25 <kmc> KirinDave, do you think these things have improved in the 3 years since you wrote the article?
20:58:26 <elliott> sebz: that looks very clear to me
20:58:31 <KirinDave> kmc: Nope.
20:59:07 <frio> but elliott dmwit - thanks for your input, i'll have a play :)
20:59:07 <dmwit> ?src (>=>)
20:59:07 <lambdabot> Source not found. It can only be attributed to human error.
20:59:14 <KirinDave> kmc: No one can use rubinius yet. Jruby is only just now becoming viable and not for rails. Even Yehuda, the guy who called me Lieberman, is doing node.js stuff and javascript now.
20:59:32 <kmc> Haskell is stagnant too.  2 language releases in 13 years? come on
21:00:07 <kmc> ;)
21:00:07 <KirinDave> kmc: Most people still use REE, which is a slightly fixed version of the same ruby interpreter I was writing about.
21:00:07 <kmc> hey, Javascript is pretty cutting-edge... I hear it has closures
21:00:07 <kmc> ;)
21:00:11 <pikhq> I hear C is pretty cutting-edge... I hear it has continuations.
21:00:15 <KirinDave> kmc: You wait. I am nearly done with an iteratee-like-pattern implementation for node.js
21:00:31 <KirinDave> kmc: Just so that I can fight back against the INSANE callback soup people craft from pure hate.
21:00:32 <kmc> "Most of the really interesting new features in ruby (real threads, better continuations, type inference, restarting from crashes in third party code, better FFI in general) are all happening in the byzantine pre-alpha world of independent ruby implementations"
21:00:36 <kmc> that's a key difference from Haskell
21:00:47 <elliott> node.js is the most amazing cargo cult type thing I've ever seen.
21:00:58 <kmc> GHC's extensions can be weird and experimental, but they're still present in ~everyone's compiler
21:00:58 <elliott> "It's fast because you have to write your program in CPS style!"
21:01:09 <KirinDave> elliott: Except… it's not fast.
21:01:15 <KirinDave> In fact, it's not really that fast at all.
21:01:17 <elliott> KirinDave: Dude. Dude. Events.
21:01:22 <frio> KirinDave: strongly agreeing with the start of your blog post; the memory leaking interpreter is what killed ruby for me :/
21:01:30 <elliott> It's so fast. No threads. Continuation passing style. Ignore the right-leaning indentation behind the curtain. Asynchronous.
21:01:42 <dmwit> It's like... we miss GUI programming, let's do more of that! Even when we're not doing GUIs.
21:01:53 <kmc> GHC Haskell programs also tend to leak memory like woah
21:02:14 <elliott> dmwit: If there's one thing I love, it's traditional GUI programming!
21:02:23 <kmc> i guess V8 doesn't have a GHC-style IO manager just because client-side Javascript doesn't do IO on thousands of sockets
21:02:31 <KirinDave> kmc: Excellent use of "like woah." 8 points.
21:02:37 <kmc> thx
21:02:43 <kmc> can i redeem my points for valuable prizes?
21:02:57 <frio> really kmc? I thought GHC was pretty good with memory management (so long as you profiled your program and spotted any obvious leaks)
21:03:10 <kmc> perhaps "leak" by a different definition
21:03:19 <kmc> not actually unreachable garbage piling up
21:03:27 <KirinDave> kmc: Have I shown you my "closures and scope" chatlog?
21:03:30 <kmc> but building piles of thunks when you wanted strict evaluation
21:03:31 <KirinDave> I am proud of this
21:03:33 <kmc> KirinDave, no
21:03:37 <frio> ah, i see
21:03:48 <KirinDave> kmc: Google in quotes, "closures and scope"
21:04:00 <KirinDave> First hit
21:04:05 <elliott> KirinDave: that... have you heard of URLs?
21:04:16 <KirinDave> elliott: Look dude I am proud of my google juice.
21:04:21 <elliott> in quotes
21:04:27 <KirinDave> http://kirindave.tumblr.com/post/24570389/incredibly-stupid-people-on-freenode-ruby
21:04:31 <kmc> heh
21:04:36 <pikhq> Sadly, GHC can't magically make programs do what you want, not what you say.
21:04:42 <elliott> "leaks are to be proven, not disproven" haha
21:04:47 <kmc> here's a URL:  google://"closures and scope"/hit_number_two
21:04:49 <elliott> it doesn't leak until you prove it leaks
21:04:54 <KirinDave> kmc: Oh man. :\
21:04:55 <elliott> in Coq, plz
21:05:19 <KirinDave> I came in with the example http://pastie.org/142875
21:05:27 <KirinDave> Which is like pretty much the perfect reproducible leak
21:05:29 <kmc> pikhq, yeah.  the problem is just that, sometimes, what i want is easy to express in a strict language and hard / cumbersome to express under lazy eval
21:05:35 <KirinDave> it happened because ruby had this "functional" optimization
21:05:42 <elliott> kmc: Exclamation marks, everywhere
21:05:47 <KirinDave> Where if it didn't detect any assignment syntax, it used a single shared stack frame
21:05:49 <elliott> Hope this helps
21:05:51 <KirinDave> but regex's hacked this scheme.
21:06:02 <KirinDave> And so would leak like woah.
21:06:18 <elliott> KirinDave: -8, too soon after previous like woah
21:06:27 <elliott> please hand over the coins
21:06:38 <pikhq> KirinDave: Yeah, wow.
21:06:58 <monochrom> don't put exclamation marks everywhere. memory growth is not due to laziness alone. some eagerness causes memory growth too.
21:07:21 <monochrom> memory growth is due to making wrong bets on laziness and eagerness
21:07:37 <elliott> I made too many wrong bets and now I'm in memory debt
21:07:40 <ccc> how to create this function in :: Int -> Int format  -- combine a b = ab  ?
21:08:00 <mauke> ccc: huh?
21:08:06 <KirinDave> ccc: combine 1 2 = 12?
21:08:12 <ccc> yes
21:08:20 <KirinDave> ccc: What is combine 10 10?
21:08:26 <mauke> combine a b = read (show a ++ show b)
21:08:31 <monochrom> isn't that question answered like two hours ago? combine x y = 10*x + y
21:08:42 <dmwit> KirinDave: If I were you, I wouldn't be proud of that conversation. You sound like a dick.
21:08:48 <KirinDave> dmwit: I am a dick.
21:08:49 <monochrom> and mauke's answer also happened two hours ago
21:09:07 <KirinDave> dmwit: I'm beyond frustrated with the ruby community at large, tbh.
21:09:24 <monochrom> don't be a dick. at most, be a computer
21:09:29 <mauke> KirinDave: I support your actions and confirm that RubyPanther is a stupid asshole
21:09:59 <KirinDave> dmwit: At some point I can't, man, I just gotta draw a line in the sand. It was a rough day, so maybe I could handled it better.
21:10:41 <kmc> monochrom, school's starting!!
21:10:43 <elliott> "besides, memory leaks by definition don't happen in Ruby" ;; I give up on reading this
21:10:57 <pikhq> I didn't realise Ruby was defined.
21:11:12 <KirinDave> elliott: That is where most people pull the d-ring and punch out of the conversation. I was just in a bad mood.
21:11:21 <kmc> didn't you hear, Ruby's garbage collector solves the halting problem
21:11:30 <kmc> yeah, you probably haven't heard of it... still pretty underground
21:11:30 <elliott> Ruby literally rewrites your program to use constant space.
21:11:38 <int80_h> KirinDave: I read the article you mentioned. He says all these problems are solvable. If the problems are solvable, are we looking at a limitation of the language or features waiting to be developed?
21:11:52 <elliott> KirinDave: your html is broken in the last line
21:12:00 <kmc> maybe i should add answers like the "combine 1 2" to the FAQ
21:12:11 <KirinDave> elliott: It has been through many blogs. That may be so.
21:12:15 <kmc> haskell.org/haskellwiki/How_to_cheat_at_your_Haskell_class
21:12:24 <KirinDave> haha, let's be honest. ;)
21:12:41 <elliott> hey guys, how can I write combine a b such that combine 9 9 is 99 :-D
21:12:45 <KirinDave> int80_h: Well, the problem is that the way ruby's gc is written, to interface with it you need to be very very careful
21:12:57 <KirinDave> int80_h: So many extensions can trigger this bug. The zip extension was not special.
21:12:59 <dmwit> > let combine 9 9 = 99 in combine 9 9
21:12:59 <lambdabot>   99
21:13:04 <elliott> dmwit: thx
21:13:07 * elliott gets full marks
21:13:15 <KirinDave> dmwit: I was really tempted to do that.
21:13:16 <pikhq> s/very careful/willing to beat the compiler into compliance/
21:13:17 <kmc> A+++++++ would TA again
21:13:21 <int80_h> KirinDave: I was referring to the Yesod article...lagging behind the conversation :)
21:13:25 <KirinDave> int80_h: Oh
21:13:26 <dmwit> Wait, what is this referring to?
21:13:35 <KirinDave> int80_h: Besides the records
21:13:40 <dmwit> Did I miss the most asinine of all StackOverflow questions or something?
21:13:41 <elliott> dmwit: two people have come in asking how to define that in like an hour
21:13:42 <KirinDave> int80_h: I think it's all not bad.
21:13:49 <KirinDave> int80_h: There are these things called lenses. :)
21:13:52 <elliott> dmwit: two people who are _obviously_ not in the same class or anything
21:13:55 <Axman6> > let combine a b = (10 ^ (logBase 10 b + 1) * a + b) in combine 9 9
21:13:56 <moroten> elliott: show a ++ show b ?
21:13:57 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:13:57 <lambdabot>    `GHC.Float.Floating a'
21:13:57 <lambdabot>  ...
21:13:58 <KirinDave> int80_h: So maybe that's the solution?
21:14:03 <kmc> i shouldn't say "cheat", though... that's up to the prof to decide
21:14:04 <monochrom> oh! I see why kmc reminds me that school is starting. it means multiple students ask the same question
21:14:05 <Axman6> :t logBase
21:14:06 <elliott> Axman6: so efficient
21:14:06 <lambdabot> forall a. (Floating a) => a -> a -> a
21:14:10 <kmc> i'm happy with people asking questions
21:14:22 <Axman6> > let combine a b = (10 ^ ((round $ logBase 10 b) + 1) * a + b) in combine 9 9
21:14:24 <lambdabot>   909.0
21:14:24 <elliott> kmc: what if they're in an IRC class
21:14:32 <Axman6> > let combine a b = (10 ^ ((round $ logBase 10 b)) * a + b) in combine 9 9
21:14:33 <elliott> "now let's see how to get IRC for help when programming, go into the haskell channel ..."
21:14:34 <lambdabot>   99.0
21:14:40 <Axman6> > let combine a b = (10 ^ ((round $ logBase 10 b)) * a + b) in combine 10 10
21:14:41 <lambdabot>   110.0
21:14:44 <Axman6> :(
21:14:56 <Axman6> > let combine a b = (10 ^ ((round $ logBase 10 b) + 1) * a + b) in combine 10 10
21:14:57 <lambdabot>   1010.0
21:15:02 <int80_h> I refer other people to this channel all the time
21:15:06 <copumpkin> dmwit: I wouldn't say he came off as a dick
21:15:09 <monochrom> I know one haskell instructor showed this channel to the whole class. the instructor was and is a regular in this channel too
21:15:16 <Axman6> > let combine a b = (10 ^ ((floor $ logBase 10 b) + 1) * a + b) in combine 10 10
21:15:18 <int80_h> and will be advertising this place when I do my presentation at Code Camp.
21:15:18 <lambdabot>   1010.0
21:15:21 <Axman6> > let combine a b = (10 ^ ((floor $ logBase 10 b) + 1) * a + b) in combine 10 9
21:15:23 <lambdabot>   109.0
21:15:26 <copumpkin> came across as a dick, rather
21:15:27 <Axman6> > let combine a b = (10 ^ ((floor $ logBase 10 b) + 1) * a + b) in combine 9 9
21:15:29 <lambdabot>   99.0
21:15:29 <dmwit> copumpkin: *shrug*
21:15:32 <Axman6> better
21:15:37 <dmwit> beholder's eyes and all that, I guess
21:15:55 <dmwit> I'm not claiming the other guys sounded reasonable, of course.
21:15:56 <copumpkin> I mean, there's liking your language and then saying things like "ruby doesn't have memory leaks by definition"
21:16:43 <copumpkin> things like that make people frustrated :P
21:16:43 <dmwit> For sure.
21:16:43 <dmwit> Rightly so.
21:16:43 <copumpkin> I used to be a big ruby fan and hung out in the channels on freenode a lot
21:16:43 <copumpkin> then I found that when I created around 2^20 symbols
21:16:43 <copumpkin> they started colliding
21:16:43 <copumpkin> so I asked people about it
21:16:44 <dmwit> The cargo-culting "_why told me to do this" is also a bad sign.
21:16:44 <copumpkin> and then said it seemed like a bug
21:16:51 <copumpkin> and at that point got called a troll and ignored by at last one person
21:16:51 <kmc> "you're an idiot for wanting to make more than 2^20 symbols and you should die in a fire"
21:16:55 <elliott> copumpkin: haha
21:17:09 <elliott> I suspect symbols are simply hashed, which is reasonable?
21:17:10 <copumpkin> so I said fuck it and stopped hanging out with that part of the ruby community
21:17:12 <elliott> or maybe it's a hash table
21:17:25 <copumpkin> elliott: they're hashed, but they don't check beyond that
21:17:28 <mauke> how do I interned strings
21:17:47 <elliott> I dunno, it seems reasonable to just hash strings rather than interning them, if symbols are a bottleneck and your hash function is good
21:17:53 <Axman6> :t let combine a b = (10 ^ ((floor $ logBase 10 b) + 1) * a + b) in combine
21:17:54 <lambdabot> forall a. (RealFrac a, Floating a) => a -> a -> a
21:17:56 <kmc> #haskell concludes: #haskell is the best community on Freenode
21:18:07 <Axman6> :t let combine a b = (10 ^ ((floor $ logBase 10 (fromIntegral b)) + 1) * a + b) in combine
21:18:07 <copumpkin> kmc: haskell doesn't do anything wrong, by definition
21:18:08 <lambdabot> forall a. (Integral a) => a -> a -> a
21:18:12 <kmc> elliott, it does not seem reasonable to me
21:18:17 <Axman6> > let combine a b = (10 ^ ((floor $ logBase 10 (fromIntegral b)) + 1) * a + b) in combine 9 9
21:18:18 <kmc> if you're marketing it as a string-equality function
21:18:18 <lambdabot>   99
21:18:22 <monochrom> unhelpful #haskell is by definition impossible
21:18:23 <Axman6> > let combine a b = (10 ^ ((floor $ logBase 10 (fromIntegral b)) + 1) * a + b) in combine 100 7
21:18:24 <lambdabot>   1007
21:18:26 <mauke> @faq can Haskell do anything wrong?
21:18:27 <lambdabot> The answer is: Yes! Haskell can do that.
21:18:31 <kmc> the overhead from hash-tabling properly should be very low
21:18:41 <Axman6> > let combine a b = (10 ^ ((floor $ logBase 10 (fromIntegral b)) + 1) * a + b) in combine 100 700
21:18:41 <elliott> kmc: Well, sure.
21:18:42 <lambdabot>   100700
21:18:46 <elliott> I wouldn't market symbols as a string-equality function.
21:18:53 <kmc> so what good are they
21:19:05 <elliott> Unique identifiers. Just relax your definition of unique.
21:19:16 <mauke> haha
21:19:16 <elliott> But yeah, interning probably doesn't have a big overhead.
21:19:20 * kmc relaxes his definition of "correct"
21:19:24 <kmc> now i can program in Ruby!
21:19:30 <elliott> there, your definition of "correct" will feel much better in a day or two
21:19:39 <elliott> after you get over the cognitive dissonance
21:19:51 <monochrom> ruby programs have no bugs by definition
21:20:05 <kmc> the little bit of ruby i did was perfectly cromulent
21:20:12 <mauke> nothing can be faster than c by definition
21:20:13 <kmc> seemed like Python with different syntax
21:20:26 <monochrom> @quote monochrom einstein
21:20:26 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
21:20:27 <kmc> but i didn't interact with "the community" or even try to use any libraries beyond Rails
21:20:46 <copumpkin> elliott: so say I'm unlucky enough to have created the symbol :zomagsafklsajg
21:20:49 <elliott> kmc: that's only the face of it
21:21:00 <copumpkin> and ask for the methods in an object, and get back a map from symbols
21:21:01 <elliott> underneath there's a huge, huge hack of badly-specified monkeypatching "metaprogramming"
21:21:05 <copumpkin> one of those symbols will be :zomgasgjaklgj
21:21:07 <kmc> i was a little disgusted when I learned that Rails uses a big list of irregular English plurals for naming database tables, and that they can't fix errors in this list anymore because it would break stuff
21:21:20 <copumpkin> kmc: it's awesome
21:21:21 <elliott> copumpkin: relax your definition of unique, man
21:21:32 * copumpkin relaxes
21:21:34 <elliott> > read "0x"
21:21:36 <lambdabot>   *Exception: Prelude.read: no parse
21:21:36 <elliott> > read "0x" :: Int
21:21:37 <lambdabot>   *Exception: Prelude.read: no parse
21:21:39 <elliott> meh
21:21:41 <elliott> > reads "0x" :: Int
21:21:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:21:42 <lambdabot>         against inferred type ...
21:21:45 <elliott> oh
21:21:47 <kmc> basically you pile on magic until the language becomes popular, then the magic ossifies and becomes bugs to be worked around
21:21:48 <dmwit> dude
21:21:50 <kmc> fabulous
21:21:55 <dmwit> You forgot the Int bit.
21:21:57 <kmc> great job guys, Perl 2.0
21:22:00 <elliott> the ReadS bit
21:22:02 <copumpkin> KirinDave!
21:22:05 <dmwit> > read "0x20" :: Int
21:22:06 <lambdabot>   32
21:22:10 <elliott> dmwit: oh no, that actually works?
21:22:12 <kmc> (Perl 5 2.0?)
21:22:15 <elliott> I just meant x as trailing garbage :(
21:22:37 <dmwit> > reads "0x" :: [(Int, String)]
21:22:38 <lambdabot>   [(0,"x")]
21:22:46 <elliott> yay, that works
21:22:51 <elliott> > reads "0x99" :: [(Int, String)]
21:22:52 <lambdabot>   [(153,"")]
21:22:53 <elliott> that doesn't.
21:23:10 <elliott> eh, I can filter it myself
21:23:15 <monochrom> "read" has trailing garbage detection built in
21:23:17 <dmwit> I agree, that should result in [(153, ""), (0, "x99")]
21:23:43 <elliott> monochrom: I want the trailing garbage to just be ignored :P
21:23:43 <dmwit> > lex "0x99"
21:23:44 <lambdabot>   [("0x99","")]
21:23:50 <shachaf> Does reads *ever* return a list with more than one element?
21:23:53 <dmwit> ...and that's why
21:24:06 <dmwit> shachaf: Not for any of the built-in Read instances.
21:24:17 <kmc> worst parser combinator library ever
21:24:19 <monochrom> yeah, you have to write your own wrapper around "reads" to ignore garbage, or even, to give you a nice Maybe
21:24:49 <elliott> gross
21:25:05 <elliott> hmm, I swear I've had an ambiguous parse message from stdlib instances before though
21:25:22 <elliott> > reads "" :: [(Int,String)]
21:25:23 <lambdabot>   []
21:25:26 <elliott> good
21:25:48 <dmwit> :t reads
21:25:49 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:25:57 <dmwit> :k ReadS
21:25:58 <lambdabot> * -> *
21:26:03 <monochrom> if you have a slightly bigger task, take comfort in the fact that most of GHC's "reads"s are wrappers of ReadP stuff, so you may as well go all out and use ReadP yourself
21:26:11 <dmwit> :t reads :: Read a => String -> ReadS a
21:26:12 <lambdabot>     Couldn't match expected type `ReadS a'
21:26:12 <lambdabot>            against inferred type `[(a1, String)]'
21:26:12 <lambdabot>     In the expression: reads :: (Read a) => String -> ReadS a
21:26:13 <kmc> but portability!
21:26:34 <dmwit> :t reads :: Read a => ReadS a
21:26:35 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:26:40 <monochrom> well ReadP is portable
21:27:21 <dmwit> That's what the P is for!
21:27:40 <kmc> > "ReadS" > "ReadP"
21:27:42 <lambdabot>   True
21:28:05 <dmwit> > eurT
21:28:06 <lambdabot>   eurT
21:28:12 <elliott> huh, never heard of ReadP
21:30:02 <dmwit> > rеverse False
21:30:04 <lambdabot>   eslaF
21:30:53 <elliott> beautiful
21:31:04 <elliott> > reverse eslaF
21:31:06 <lambdabot>   Couldn't match expected type `[a]'
21:31:06 <lambdabot>         against inferred type `Text.Pret...
21:31:08 <elliott> dmwit, it's broken
21:31:10 <shachaf> @ty rеverse
21:31:12 <lambdabot> Expr
21:31:20 <shachaf> Huh, how is it implemented?
21:31:35 <elliott> No.
21:31:39 <elliott> ?ty fails at unicode.
21:31:40 <lambdabot> parse error (possibly incorrect indentation)
21:31:42 <elliott> It's cutting off at the fisrt "e".
21:31:44 <elliott> ?ty r
21:31:45 <lambdabot> Expr
21:31:54 <elliott> > rеverse
21:31:56 <lambdabot>   Overlapping instances for GHC.Show.Show
21:31:56 <lambdabot>                              (GHC.B...
21:32:00 <elliott> > rеverse eslaF
21:32:01 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:32:01 <lambdabot>         against inferred type ...
21:34:58 <dmwit> :t text
21:34:59 <lambdabot> String -> Doc
21:35:05 <dmwit> rеverse :: Bool -> Doc
21:36:33 <dmwit> wow
21:36:43 <dmwit> That seems... a bit harsh.
21:38:03 <copumpkin> unauthorized proxies
21:38:10 <Cale> lpsmith?!
21:38:10 <elliott> Holy crap.
21:38:19 <elliott> K-LINE EVERYONE
21:38:23 <kmc> ouch
21:38:31 <elliott> copumpkin: what constitutes one of those?
21:38:34 <elliott> Tor?
21:38:48 <copumpkin> ones that don't provide an easy mechanism to identify the underlying user, I guess
21:38:51 <elliott> Hmm, Tor looks allowed.
21:39:38 <kmc> shit just got real
22:00:30 <kmc> damn it, people keep uploading packages to Hackage, and I have to update my "how many packages are there" slide :)
22:00:48 <shachaf> kmc: Don't worry, I keep downloading packages from Hackage.
22:00:56 <shachaf> That undoes the effect of uploading, right?
22:01:02 <kmc> i think that's how it works
22:02:08 <Jafet> Just update it to "how many packages are used"
22:02:26 <kmc> haha
22:02:36 <kmc> hackage still doesn't have reverse-deps...
22:06:30 <dmwit> I don't think that's what he meant by "used".
22:08:30 <dmwit> Best Stack Overflow question title: "Haskell random generator sucks?"
22:08:33 <dmwit> answer: nope.avi
22:08:56 <kmc> doesn't it though
22:09:15 <dmwit> Maybe, but definitely not in the way the question-asker meant it.
22:09:26 <kmc> if that unpacks as "Does GHC's default implementation of System.Random run slowly and produce low-quality randomness?"
22:09:40 <dmwit> No, it unpacks as, "Waaaah, monads."
22:09:53 <kmc> i see
22:10:11 <kmc> well, insulting the thing you want help with is a common internet strategy
22:10:32 <kmc> "Linux sucks because sound doesn't work, I'm going back to Windows"
22:10:45 <MdxBhmt> at least he put a question mar
22:10:47 <MdxBhmt> k*
22:10:48 <kmc> 9,000 beardos jump over each other to tell you how to remove pulseaudio
22:11:19 <elliott> http://stackoverflow.com/questions/7329361/haskell-random-generator-sucks wow this really is bad
22:11:23 <kmc> mwc-random 4 lyfe
22:11:40 <elliott> actually http://stackoverflow.com/questions/7267760/how-can-a-time-function-exist-in-functional-programming quite annoyed me when I saw it because some of the answers are pretty bad
22:12:03 <kmc> yeah
22:12:16 <elliott> and nobody seems to have really explained it :/
22:12:37 <kmc> this is one obstacle to learning Haskell
22:12:44 <kmc> bad explanations abound
22:13:01 <kmc> what do you think are the main obstacles to learning Haskell?
22:13:13 * kmc not-so-subtly making #haskell write his talk
22:13:14 <elliott> knowing other languages
22:13:22 <elliott> specifically, impure languages
22:13:29 <elliott> and non-functional languages
22:13:32 <elliott> also, any language
22:13:35 <kmc> dysfunctional
22:13:42 <smop> scala
22:13:48 <kmc> Haskell's an impure language, though
22:14:01 <elliott> it is, but how much pure python code do you see
22:14:12 <kmc> the relevant point is that Haskell's designed so that pure functions are a viable alternative
22:14:21 <kmc> whereas other languages basically force you to use mutation everywhere
22:14:34 <kmc> of course the rest of the world sees Haskell as the crazy fanatics and the other as the moderate position
22:14:36 <elliott> But seriously, it's definitely a problem of preconceptions.
22:14:37 <kmc> but *shrug* they're wrong
22:15:00 <kmc> i guess i'm wondering more specifically "what are the obstacles to learning Haskell which could be fixed by the Haskell community"
22:15:04 <elliott> People just can't comprehend how writing code in Haskell can be possible; "how come I'm meant to write the bulk of my program with _no_ _escape_ into side effects?"
22:15:18 <elliott> kmc: Maybe LYAH should start with a mind wipe.
22:16:57 <Jafet> What? Why should the community fix the obstacles?
22:17:24 <elliott> So more people learn Haskell?
22:17:28 <Jafet> They're like... social... write barriers. They aid garbage collection.
22:17:37 <koeien> but we want to avoid success? :(
22:17:37 <kmc> well for example "there's no good tutorials" is fixed by writing good tutorials
22:17:49 <elliott> Jafet: CLEANSE THE HASKELLER POPULATION
22:17:52 <elliott> CLEAAANSE
22:18:12 * Jafet is reading the Storage commentary
22:18:15 <dmwit> I liked it better when people who couldn't handle the Gentle Introduction left! CLEAAAANSE
22:18:42 <copumpkin> dmwit: remember how annoying I was when I was first learning?
22:18:54 <dmwit> Nope!
22:18:55 * copumpkin hopes not
22:18:58 <copumpkin> oh good
22:19:03 <kmc> it's logged
22:19:04 <copumpkin> don't look at the logs
22:19:08 <kmc> hehe
22:19:10 <dmwit> Could you handle the Gentle Introduction?
22:19:11 <copumpkin> I remember thinking "man, dmwit must hate me"
22:19:21 <copumpkin> never looked at it :o
22:19:25 <dmwit> GET OUT
22:19:28 <dmwit> ;-)
22:19:32 <copumpkin> onoes
22:19:48 <elliott> The Gentle Introduction isn't that un-gentle.
22:19:52 <dmwit> Sometimes, I like to pretend I have authority.
22:19:53 <elliott> I mean, of the first chapter or two I read.
22:19:59 <elliott> It was pretty... strange though.
22:20:09 <copumpkin> dmwit: great intellectual authority!
22:20:18 <elliott> I think the target market was the author's imagined years-ago self.
22:20:26 <_Ray_> Hi. Is there a difference between filter and takeWhile?
22:20:29 <elliott> Yes.
22:20:35 <kmc> _Ray_, yes, takeWhile stops once it gets one False
22:20:37 <elliott> takeWhile stops on the first false.
22:20:38 <copumpkin> dmwit: you can tell me I'm wrong about something I'm right about and confuse me to no end!
22:20:42 <_Ray_> Oh, right.
22:20:42 <kmc> i think the Gentle Introduction does not even claim to be a tutorial
22:20:50 <dmwit> copumpkin: hahaha
22:20:50 <kmc> URL notwithstanding
22:20:52 <_Ray_> Thanks.
22:20:54 <elliott> "Our purpose in writing this tutorial is not to teach programming"
22:20:55 <dmwit> that is an awesome troll idea
22:20:56 <elliott> kmc: First words.
22:21:00 <kmc> whatever
22:21:03 <kmc> it's a supplement to the Haskell 98 Report
22:21:08 <copumpkin> oh shit
22:21:12 <kmc> which is like "so you're an experienced ML programmer"
22:21:15 <copumpkin> I should stop hanging out around here until he forgets about it
22:21:27 <elliott> I think the Gentle Introduction would be a great introduction to Haskell if you already know it.
22:21:44 <chrisdone> 11:17:44 <edwardk> wow, i can't paste code tp hpaste i get 'a web handler threw an exception. Details: Ambiguous infix expression.
22:21:45 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
22:21:59 <dmwit> The Gentle Intro is still my first love.
22:22:03 <chrisdone> @tell edwark i think your " Ambiguous infix expression." comes from hscolour
22:22:03 <lambdabot> Consider it noted.
22:22:16 <dmwit> Succinct, and covers all the good stuff right away.
22:27:51 <elliott> Hmm. Is there no way to construct an "unsafeRunST :: ST s a -> a" without using unsafeSTToIO?
22:27:54 <elliott> (And unsafePerformIO.)
22:28:12 <Jafet> @hoogle ST s a -> a
22:28:13 <lambdabot> Control.Monad.ST runST :: ST s a -> a
22:28:13 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
22:28:13 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
22:28:20 <Jafet> @hoogle ST s a -> s -> a
22:28:22 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
22:28:22 <lambdabot> Data.Graph.Inductive.Graph deg :: Graph gr => gr a b -> Node -> Int
22:28:22 <lambdabot> Data.Graph.Inductive.Graph indeg :: Graph gr => gr a b -> Node -> Int
22:28:23 <kmc> you can import GHC's data constructor for the ST monad
22:28:24 <mauke> why so unsafe?
22:28:30 <kmc> hehe, hoogle has the wrong type for runST
22:28:34 <dmwit> What is unsafeRunST supposed to do?
22:28:42 <kmc> i think it's clear from the type
22:28:43 <elliott> dmwit: unsafePerformIO . unsafeSTToIO :p
22:29:26 <dmwit> What does that do?
22:30:00 <Jafet> Why so desert
22:30:15 <elliott> dmwit: Exactly what it says on the tin.
22:30:23 <dmwit> What does it say on the tin?
22:30:25 <dmwit> Really, though.
22:30:30 <dmwit> What does it do differently from runST?
22:30:41 <elliott> Nothing, it just has a laxer and therefore unsafe type.
22:30:44 <kmc> it's the same operationally
22:30:53 <kmc> it lacks the type-level safety check
22:30:55 <Jafet> It steals s
22:31:00 <Peaker> what's the point?
22:31:00 <Jafet> Useful for debugging, sometimes
22:31:04 <kmc> hmm elliott... unsafeRunST = unsafeCoerce runST
22:31:06 <kmc> clearly
22:31:08 <kmc> this is the best way
22:31:15 <dmwit> Yes, I was just going to suggest this.
22:31:21 <elliott> haha
22:31:31 <kmc> What Could Go Wrong ™
22:31:33 <dmwit> or unsafeRunST st = runST (unsafeCoerce st), maybe
22:31:45 <kmc> i bet you run into impredicativity problems
22:31:49 <kmc> possibly either way
22:31:56 <Jafet> Hm, that might actually happen to work
22:32:01 <Jafet> It just turns s to s'
22:32:07 <kmc> anyway unsafeSTToIO (ST m) = IO (unsafeCoerce# m)
22:33:52 <kmc> that's an operational no-op
22:33:53 <elliott> yeah, then unpack it
22:34:01 <kmc> because ST and IO are both newtypes
22:34:02 <elliott> right
22:34:09 <kmc> watch out for the noDuplicate business
22:34:23 <kmc> make sure you understand the difference between unsafePerformIO and unsafeDupablePerformIO before you reimplement one of them
22:35:30 <elliott> Hmm, there's no atomicModifySTRef. I suppose from ST you can implement it without worry for multithreading, but it's annoying when you want to sometimes convert the ST to IO and maintain the atomicity.
22:35:47 <kmc> isn't it annoying to have an STRef in IO, anyway?
22:35:50 <kmc> just coerce the ref ;)
22:35:55 <kmc> what are you actually doing, by the way?
22:36:18 <dmwit> These questions have a horrible smell to them.
22:36:23 <kmc> oh, right.  it would be annoying with the (safe) stToIO
22:36:29 <elliott> They do to me, too, but I'm in smelly territory.
22:36:31 <elliott> kmc: Right.
22:36:47 <elliott> It's OK, I can just write my function twice :P
22:36:57 <kmc> CPP
22:37:00 <kmc> CPP CPP CPP CPP CPP
22:37:10 <kmc> elliott, all your questions made a lot more sense once i noticed that you're an #esoteric regular
22:37:29 <elliott> hahahahaha
22:37:38 <Peaker> elliott: write your function twice??
22:38:08 <elliott> Peaker: yep, except one using atomicModifyIORef
22:38:36 <Peaker> elliott: why not make a type-class/pass a dict manually?
22:38:47 <elliott> Peaker: I'd need to stToIO anyway
22:38:51 <elliott> The function is tiny, so it's no big deal
22:46:28 <KirinDave> Man, I wish I could find some way to give -w to every ld run that I do with haskell
22:47:29 <kmc> you mean -optl-w ?
22:47:33 <kmc> or am i missing something
22:47:37 <KirinDave> kmc: Well
22:47:44 <KirinDave> kmc: cabal-dev install-deps
22:48:01 <kmc> does it get ld from your path?
22:48:09 <KirinDave> I dunno. That's clever.
22:48:10 <KirinDave> Still
22:48:18 <KirinDave> I wish my cabal config had an entry for that.
22:48:31 <dmwit> So hack cabal-install and send them a patch.
22:48:40 <kmc> just ptrace the cabal binary and intercept its calls to execve(2)
22:48:53 <kmc> just write a kernel module
22:48:53 <KirinDave> kmc: You got moxie, kmc. I like that.
22:48:57 <kmc> thanx
22:52:08 <gavino> is there haskell on adm64 baremtal?
22:52:26 <kmc> @where house
22:52:27 <lambdabot> http://programatica.cs.pdx.edu/House/
22:52:30 <kmc> @where HaLVM
22:52:30 <lambdabot> I know nothing about halvm.
22:52:40 <kmc> @where+ HaLVM http://halvm.org/wiki/
22:52:40 <lambdabot> It is stored.
22:52:57 <dmwit> Do you just mean, "does GHC compile for x86_64"? Because yes, it does.
22:53:08 <kmc> "bare metal" usually means "no OS"
22:53:12 <dmwit> ok
22:53:20 <kmc> for fairly arbitrary definitions of what counts as an OS
22:53:32 <dmwit> Of course.
22:56:28 <KirinDave> Oh fooie.
22:56:29 <KirinDave> http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/logs/failure/ghc-7.2
22:57:07 <dmwit> MissingH is such a monolithic package.
22:57:50 <KirinDave> Snap wants it.
22:58:35 <Jafet> Does that make Snap palaeolithic?
22:58:46 <dmwit> KirinDave: It should be easy to fix.
22:58:52 <dmwit> Just don't depend on the haskell98 package.
22:59:12 <dmwit> (Or don't depend on base, your choice on whether you want to be forward-looking or backward-compatible.)
23:00:14 <KirinDave> dmwit: Sadly it's not as simple as modifying the cabal package. Working on it.
23:00:32 <dmwit> Well, it's never as simple as you might wish, I guess.
23:01:35 * hackagebot repa 2.2.0.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.2.0.1 (BenLippmeier)
23:01:37 * hackagebot repa-bytestring 2.2.0.1 - Conversions between Repa Arrays and ByteStrings.  http://hackage.haskell.org/package/repa-bytestring-2.2.0.1 (BenLippmeier)
23:01:39 * hackagebot repa-io 2.2.0.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-2.2.0.1 (BenLippmeier)
23:03:30 <KirinDave> I've never done this before
23:03:41 <KirinDave> If I do update a package to work with a new version of ghc
23:03:49 <KirinDave> what's the best way to push those back out?
23:04:00 <dmwit> Send a patch to the package's maintainer.
23:04:32 <dmwit> Bonus points if you use their revision-control system of choice to generate the patch.
23:06:35 * hackagebot repa-algorithms 2.2.0.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-2.2.0.1 (BenLippmeier)
23:09:36 <Kaidelong> what warning does fno-warn-orphans disable
23:09:47 <Kaidelong> well perhaps I should ask that in ##ghc
23:09:56 <Jafet> It doesn't warn orphans
23:10:13 <Kaidelong> yeah but orphan... whats?
23:10:16 <Jafet> GHC sometimes abducts orphans
23:10:21 <Kaidelong> judging by the module I guess it's orphan instances
23:10:31 <Jafet> Correct
23:10:31 <Kaidelong> but I don't know what orphan instance means
23:11:02 <Jafet> @google orphan instance
23:11:04 <lambdabot> http://www.haskell.org/haskellwiki/Orphan_instance
23:11:04 <lambdabot> Title: Orphan instance - HaskellWiki
23:11:37 * hackagebot repa-examples 2.2.0.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-2.2.0.1 (BenLippmeier)
23:13:10 <Kaidelong> ah okay
23:13:25 <Kaidelong> so the whole reason why orphan instances are a problem seems to have to do with how imports work in haskell
23:13:43 <Jafet> More like, how instances respect scoping in haskell
23:13:51 <Jafet> (Whee, they don't)
23:14:14 <Kaidelong> hmm are instances implicitly exported too?
23:14:18 <elliott> yep
23:14:22 <Kaidelong> that's terrible
23:14:26 <Jafet> This is also why -X*Instances are nasty
23:14:28 <elliott> yep
23:14:35 <elliott> Jafet: even Flexible?
23:14:45 <Kaidelong> well I meant re-exported
23:14:55 <Jafet> Eh, who uses only Flexible?
23:14:59 <elliott> me
23:15:03 <Jafet> You are weak
23:15:13 <elliott> my project used to have about ten language extensions... now it has flexibleinstances and bangpatterns
23:20:05 <AfC> Is it bad that I keep wanting to "import Prelude hiding (blah)"?
23:20:34 <Jafet> Yes, because there is no such thing as Prelude.blah
23:20:51 <AfC> [there should be!]
23:21:01 <AfC> s/blah/pick your favourite Prelude function/
23:22:02 <elliott> no
23:22:07 <elliott> unless you're shadowing them yourself
23:22:10 <elliott> then it might be bad
23:23:40 <Jafet> hiding (catch, lookup, length, take, drop, takeWhile, dropWhile, replicate)
23:23:49 <elliott> hiding (everything)
23:25:04 <Jafet> s = filter (not . (`elem` s)) everything
23:25:51 <Kaidelong> the prelude is kind of evil
23:27:11 <shachaf> Just wait until you see the fugue.
23:27:27 <Jafet> I'm not synaesthetic
23:29:35 <kmc> bang bang patterns
23:32:14 <elliott>   where unsafeRunST (ST s) = case s realWorld# of (# _, a #) -> a
23:32:14 <elliott> nice.
23:34:15 <kmc> unsafeDupableRunST
23:34:25 <elliott> lol
23:34:43 <kmc> did you read about unsafePerformIO and unsafeDupablePerformIO
23:34:52 <elliott> i think i saw those in internal ghc modules once.
23:35:38 <kmc> basically there's a small race condition where two threads might force the same thunk at the same time and end up both evaluating it
23:35:40 <elliott> lol, my function is literally runSTRep
23:35:43 <elliott> but with a laxer type
23:35:44 <elliott> and with the unpacking
23:35:49 <elliott> kmc: haha
23:36:07 <kmc> normally this only results in duplicated computational work
23:36:26 <kmc> but unsafePerformIO lets you build thunks whose evaluation has observable effects
23:36:34 <kmc> and those effects could get duplicated
23:36:48 <kmc> so unsafePerformIO uses a global lock
23:36:50 <kmc> or something
23:36:57 <elliott> wow
23:37:01 <elliott> unsafePerformIO: Not safe
23:37:02 <elliott> ?
23:37:08 <elliott> damn, that enter key really ruined my gag
23:37:22 <Jafet> safeUnsafePerformIO
23:37:31 <kmc> yeah, there are different levels of 'safe'
23:37:41 <kmc> the official guarantees on unsafePerformIO are very weak
23:37:58 <kmc> but unofficially, people want it to make "IO thunks" that happen only once
23:38:00 <Jafet> unsafePerformIO has semantics, even though it's politically incorrect to document those semantics
23:38:07 <Nisstyre> notSafeUnsafePerformIO ?
23:38:08 <elliott> wow, my crazy thing actually works
23:38:19 <kmc> if a semantic rule is undocumented does it exist?
23:38:31 <kmc> or is it just an implementation detail?
23:38:42 <Jafet> kmkmc: nc: noo
23:38:47 <kmc> uh
23:38:52 <kmc> zalgo
23:38:53 <kmc> anyway
23:39:07 <kmc> the documented semantics of unsafePerformIO are useful, but still much narrower than what people use it for
23:39:19 <elliott> STRefs are lazy in their contained value, right?
23:39:23 <c_wraith> yes
23:39:26 <elliott> right
23:39:32 <c_wraith> they'll happily hold a thunk.
23:50:40 <elliott> I was right. That Vault structure on reddit recently? it's isomorphic to (ST s ())
23:50:45 <elliott> Keys are (STRef s (Maybe a))
23:51:06 <elliott> I have a feeling this implementation will be pretty efficient, at least moreso than implementations using maps
