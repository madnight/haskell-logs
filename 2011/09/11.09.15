00:02:18 <elliott> Is repa-devil my best option for doing some basic analysis of the pixel data in some jpegs?
00:06:00 <elliott> Oh, hmm, repa-devil doesn't support reading from _anything_ but a filename? :/
01:24:00 <niteria> foldr (.) id [next | _ <- [0..8]]
01:24:10 <niteria> this looks clumsy for me
01:24:51 <niteria> is there a better way to compose function with itself n times?
01:25:34 <Veinor> > (iterate (+1) 0) !! 5
01:25:34 <mux> > iterate (*2) 1 !! 10
01:25:35 <lambdabot>   5
01:25:35 <lambdabot>   1024
01:26:06 <mux> you might need to write your own stricter version of iterate though (at least I had to some day)
01:26:10 <Phyx-> @type \n -> foldr (.) id . replicate n
01:26:11 <lambdabot> forall b. Int -> (b -> b) -> b -> b
01:28:00 <niteria> cool, thanks, forgot about iterate
01:28:24 <koeien> mux: yes, that's a common gotcha
01:29:46 <mux> ISTR sending a proposal for iterate' in libraries@ but that probably got lost in the noise
01:30:35 <Phyx-> isn't the type of iterate not what you want?
01:31:09 <rtharper> :t iterate
01:31:10 <lambdabot> forall a. (a -> a) -> a -> [a]
01:31:29 <rtharper> I mean, it doesn't the same thing, doesn't it, it just does it an infinite number of times and collects the intermediate results
01:31:35 <koeien> iterate (.f) id !! n
01:31:54 <mux> rtharper: which is why we suggested using it along with (!!)
01:31:55 <Phyx-> ug..
01:32:07 <Phyx-> i'll stick to my foldr variant
01:32:07 <rtharper> mux: aye, that makes sense
01:32:17 <mux> :t \f n x -> iterate f x !! n
01:32:17 <lambdabot> forall a. (a -> a) -> Int -> a -> a
01:32:24 <rtharper> mux: sorry, i meant s/doesn't/does for the first one, heh
01:37:41 <johnsonbutton> Hello. I'm trying to install darcs using cabal. I'm told "cannot configure unix-2.4.2.0. It requires base >=4.2 && <4.4". However I can't install 4.2.x as I have 4.4 installed! What the hell do I do here? Why can't it use 4.4, it's a point release so it's backwards compatible surely. Why do I do to solve this?
01:38:31 <koeien> johnsonbutton: which ghc version are you using?
01:38:44 <Yrogirg> Hello! What is the markup for urls in the cabal Description section?
01:38:50 <johnsonbutton> koeien: 7.2.1
01:39:18 <koeien> johnsonbutton: it might be that darcs requires 7.0.x at the moment. I am not sure.
01:39:26 <koeien> the haskell platform has 7.0.3
01:40:23 <johnsonbutton> koeien - ah i see. but it should all be backwards compatible for any 7.x shouldn't it? what's what a version number is there for?
01:41:23 <koeien> the 'base' package is tied to GHC
01:41:44 <koeien> it's not possible to install another version of it (only by installing another GHC)
01:42:07 <johnsonbutton> koeien, but any package that works for 7.x must work for 7.(x+1) - isn't that what the point part of a version number means?
01:42:57 <koeien> johnsonbutton: i'm not familiar with the internals of the unix package. I can't say.
01:44:02 <koeien> johnsonbutton: i suppose there is a good reason for this behavior.
01:45:01 <osfameron> morninal all.  Could I get a style-check / pointers for refactoring on a function?
01:45:06 <koeien> johnsonbutton: you can get the official answer wre darcs + GHC 7.2.x in the darcs channel or the darcs mailing list.
01:45:18 <koeien> osfameron: sure, paste it
01:45:19 <osfameron> it's to do gaussian elimination in a matrix
01:45:19 <koeien> @hpaste
01:45:20 <lambdabot> Haskell pastebin: http://hpaste.org/
01:46:36 <hpaste> osfameron pasted “Gaussian elimination” at http://hpaste.org/51371
01:47:27 <osfameron> (it doesn't do the back-substitution bit yet)
01:49:16 <koeien> osfameron: looks quite ok. I think you might want to divide the whole row by the first nonzero coefficient as well, though.
01:49:29 <koeien> osfameron: of course, it's not going to be efficient
01:49:55 <koeien> osfameron: nor numerically stable
01:50:04 <osfameron> koeien: yeah, the algorithm is the first one in the Gilbert Strang videos (MIT opencourseware)... I'm sure he'll show a more efficient algorithm down the line ;-)
01:50:21 <koeien> e.g., what happens if p1 is zero
01:50:29 <osfameron> oh yeah, I'm not doing any trapping for zero-pivots...
01:50:41 <koeien> (or close to zero)
01:51:58 <osfameron> oh, close-to-zero is a problem too?
01:52:19 <koeien> osfameron: if you want efficiency, look at hmatrix. but this being an exercise of course you want to implement it yourself :)
01:52:38 <osfameron> oh, I went to the effort of putting let zs in case x of... and then forgot to use zs in the second case ;-)
01:52:54 <osfameron> koeien: yeah!  I'm thinking hmatrix (or SciPy or PDL) for actually doing the ai-class exercises
01:53:06 <osfameron> but for the purpose of understanding linear algebra, implementing it seems useful
01:53:26 <koeien> osfameron: well, you should typically select "large" values as pivots.
01:54:09 <koeien> so if you're currently in column j, take as pivot the (i,j) element such that |A_ij| is maximized
01:54:20 <koeien> (where A is the matrix and |.| is absolute value)
01:54:29 <osfameron> koeien: presumably there are heuristics for choosing which order it's best to put the rows in?  Or would you have to start and possibly backtrack if you ended up with a zero/small pivot ?
01:54:40 <koeien> this makes it a bit more stable. but i'm not sure that it's enough
01:55:26 <deef> is there a way to find out when a particular function was included for the first time in ghc? so I can use the preprocessor to conditionally compile
01:55:42 <koeien> depending on the course, the prof might go into numerical stability
01:56:36 <koeien> osfameron: i'm sure that s/he knows more about it than i do
01:57:08 <osfameron> well, Strang does mention the possible failure modes (like zeros in pivot position) and I think from the hints, it looks like we'll come back to it
02:36:53 <augur> whats the variation of a catamorphism where the base case is also a function?
02:42:11 <herself> uhhhh... starting to learn haskell, I see recurency eveywhere: cabal install cabal-install
02:42:13 <herself> ;-p
02:42:25 <b_jonas> heh
02:42:43 * dcoutts is going to rename it so it'll be even more recursive
02:42:46 <dcoutts> cabal install cabal
02:43:29 <koeien> ghc can only be compiled by ghc!
02:43:31 <rostayob> http://images.memegenerator.net/instances/400x/10021603.jpg
02:44:08 * merijn is no intrigued by what the old text used to say
02:44:49 <rostayob> mhm. mee to.
02:45:05 <rostayob> ah, right. dicks.
02:47:22 <rostayob> ahah did I just write "mee to"?
02:48:44 <Jafet> Mee thre.
02:56:17 <whald> hmm, I have a custom "Rand" monad which allows to draw random numbers, and I have prototyped a function to shuffle a MVector -- can anyone help me to marry the two? the code is at http://hpaste.org/51372
02:57:14 <ion> Why a custom monad for randomness, btw?
02:57:25 <whald> the shuffle' function is "something -> ST (PrimState m) ()", but I'd rather have a "vector -> Rand ()"
02:58:36 <merijn> btw
02:58:37 <whald> ion: it's for historic reasons mainly, i started the project using the StdGen, and because I've hidden that fact in my Rand monad I could later swap that for the System.Random.MWC gen for great speedups
02:58:53 <whald> ion: so i thought it might be a good idea to stick with it
02:58:59 <merijn> A proper randomize function using "swap" is non trivial to write
02:59:51 <whald> merijn: i'm currently using the perfect-shuffle package, but it works only on lists and is responsible for 25% allocations and 12% time for me
02:59:56 <merijn> The easiest (correct) approach is to assign a random number to every list entry, then just sort the assigned numbers
03:00:23 <whald> merijn: so i want to move away from that, and however my shuffle will ultimately look, i'd rather have it in-place
03:00:39 <rostayob> whald: the usual way to shuffle vectors is to get the first element and swap it with one of the others, and progress throught the list like that
03:00:59 <koeien> rostayob: one of the FOLLOWING.
03:00:59 <merijn> rostayob: Yeah, that is not properly random, though
03:01:11 <rostayob> koeien: yes, one of the following elements
03:01:12 <koeien> rostayob: otherwise it is not uniformly distributed!
03:01:28 <pyrtsa> Huh? http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
03:01:30 <rostayob> merijn: why wouldn't it be properly random?
03:01:43 <pyrtsa> Sure it's properly random like that.
03:01:43 <koeien> so in step i, swap x_i with x_j, where j in [i..n)
03:01:44 <merijn> rostayob: Well, not uniformly distributed as koeien pointed out
03:02:00 <rostayob> yes sorry if I wasn't unclear
03:02:06 <rostayob> *I was unclear
03:02:44 <whald> I'm currently more fighting the type system, not the bias of the shuffle, though :-)
03:03:26 <rostayob> whald: what is "create"?
03:03:42 <merijn> Fighting the type system usually results from writing in the wrong order (i.e. code first, types second) :p
03:03:53 <whald> rostayob: it's from system.random.mwc, and creates a new RNG (always the same)
03:05:25 <whald> one thing that seems as it might help me is to create an "instance PrimMonad Rand" -- if that's possible at all. ultimately, Rand is backed by ST anyway -- so maybe?
03:05:59 <whald> my problem is that i really don't understand ST at all :-/
03:06:03 <Jafet> PrimMonad only exists because people are too lazy to write two instances...
03:07:07 <Jafet> whald: what type do you want shuffle to be?
03:07:30 <rostayob> whald: shouldn't shuffle be -> ST ()?
03:07:35 <rostayob> either that
03:07:44 <rostayob> you you have do do "gen <- return create"
03:07:47 <rostayob> or something like that
03:08:06 <whald> Jafet: rostayob: for me, something with "-> Rand ()" seems to fit nicely
03:08:21 <rostayob> whald: but create :: St s (Gen s)
03:08:26 <Jafet> What is Rand (), again?
03:08:40 <Jafet> Oh, something like RandomGen?
03:08:48 <Jafet> That is, RandomGen ()
03:09:11 <rostayob> whald: I don't really understand what you're trying to do, but if shuffle' is defined like that it's -> ST ()
03:10:05 <rostayob> whald: also, you have no operations on your Rand monad apart from rnd
03:10:21 <rostayob> and you're not using it in shuffle'
03:10:34 <rostayob> an no, rndInt, andIntList etc
03:10:55 <whald> rostayob: I'd like to use rndInt in shuffle' -- but that causes type errors
03:11:16 <rostayob> whald: what errors? I can't test that code right now
03:11:34 <rostayob> but I don't understand why you're doing things how you're doing them
03:11:56 <Jafet> Whoops, it is indeed called Rand.
03:12:21 <rostayob> whald: can't you just embed a RandomGen in a ReaderT (or similar) and then have the ST as inner monad?
03:12:53 <whald> rostayob: when i remove the "gen <- .." line, and replace the "uniformR.." with rndInt, it gives
03:12:55 <whald> Couldn't match expected type `Rand b0'
03:12:56 <whald>                 with actual type `ST (PrimState m0) ()'
03:13:25 <whald> rostayob: RandomGen is really slow compared to MWC
03:14:22 <Jafet> RandomGen is a class; did you mean StdGen?
03:14:36 <hpaste> whald pasted “random shuffle 2” at http://hpaste.org/51373
03:14:52 <whald> ... gives
03:14:54 <whald> No instance for (PrimMonad Rand)
03:14:55 <whald>       arising from a use of `MV.swap'
03:15:13 <whald> Jafet: yes, i meant StdGen
03:15:18 * frerich2 wonders whether QuickCheck could be used to test the correctness of some random number source. I guess you need some statistical analysis?
03:15:54 <Jafet> swap returns an action in ST, or whatever the PrimMonad is.
03:16:43 <Jafet> Again, quit programming-by-guessing and write the type first.
03:17:10 <rostayob> whald: still, can't you just have the Gen in the StateT?
03:17:23 <ksf> those dbus bindings can do almost everything... but remove objects.
03:17:23 <rostayob> and then you can use uniform/uniformR in your monad
03:17:29 <rostayob> *ReaderT
03:17:38 <Jafet> A StateT over ST? Sounds horrid
03:17:50 <whald> Jafet:[12:56] <merijn> Fighting the type system usually results from writing in the wrong order (i.e. code first, types second) :p
03:17:50 <Jafet> I would just dispense with the excess polymorphism and write the whole thing for ST.
03:18:16 <Jafet> Then you can get rid of the obfuscating PrimMonad stuff.
03:18:30 <merijn> whald: That's exactly what Jafet just said
03:18:43 <rostayob> Jafet: yeah right, since you have ST you don't even need that
03:18:56 <whald> merijn: damn! :-)
03:18:59 <Jafet> He doesn't have ST, he's trying to write for PrimMonad
03:19:21 <Jafet> Oh, but part of the rest of his code uses ST!
03:19:21 <whald> I'd happily go with ST if it just works :-)
03:19:24 <merijn> whald: i.e. write types first, then write code to fit the types, instead of writing code first then struggling to find the proper types
03:19:55 <rostayob> Jafet: well he'll need ST to shuffle vectors in place anyway
03:20:11 <Jafet> You can do it in the other PrimMonad, IO.
03:20:11 <ksf> do people *have* to hide internal stuff?
03:20:17 * ksf thinks that's bad practice.
03:20:30 <Eduard_Munteanu> If you think of types as pseudocode in some sense, then it's not so scary anymore ;)
03:20:32 <ksf> ...just put them into some internal module, but export that.
03:20:49 <Jafet> ksf: but good theory!
03:20:51 <rostayob> Jafet: my problem here is that I have no idea about PrimMonad, so I'll probably turn silent and read about it :)
03:21:12 <Jafet> I don't have any idea about PrimMonad either, which is part of why I'd rather whald not use it
03:21:28 <rostayob> Jafet: well MWC seems to require it
03:21:35 <quicksilver> hiding internal stuff gives you a proof that if you refactor maintaining the behaviour of exported functions, your clients will have the same behaviour.
03:21:41 <ksf> If I see a module named "Internal", I know that I've got no guarantees. If I don't see any of it, I know that I'm going to have guaranteed pain ahead of me exposing what I need.
03:22:13 <Jafet> Also, PrimState m isn't a type, but a type family iirc, so you'd need (PrimState m ~ s) => v s a
03:22:16 <ksf> quicksilver, not hiding it but exporting it as "Internal" gives you the same guarantees.
03:22:23 <rostayob> Jafet: also, "instance PrimMonad (ST s)", so yeah the best idea is to solve everything in ST
03:22:29 <ksf> and you don't make me hack up your source.
03:22:54 <quicksilver> ksf: except that programmers are bad people, so they will code using the internals anyway for bad reasons, and then *their* users will blame you when you refactor and their shiney toys break.
03:23:39 <merijn> quicksilver: Meh
03:23:49 <Jafet> whald: you can't really use Rand for shuffle, because you need ST to perform the shuffle. You can use RandT over ST, or just throw the generator in the ST state.
03:23:52 <ksf> well, my reason is that I'd have to re-implement whole swathes of functionality when I don't get at the internals in strategic places.
03:23:58 <merijn> That's what Java and C++ programmers always say about python and I've never seen it by an actual issue
03:24:07 <Jafet> whald: also see Control.Monad.Random for better definitions of Rand and RandT.
03:24:19 <ksf> could become a patch, but otoh, I guess I have to re-implement everything in an ever so slightly different way, anyway.
03:24:30 <ksf> still, it'd be nice to have a painless way to *try*.
03:24:52 <quicksilver> merijn, ksf : sure, I agree with almost everything you're saying.
03:25:20 <whald> Jafet: ok, thanks, maybe this will mentally clear thinks up for me as well
03:25:22 <quicksilver> except the part where merijn says he hasn't seen an actual issue :) I certainly have seen software break by relying on undocumented/internal structure.
03:25:30 <quicksilver> it's not particularly common, I agree.
03:25:47 <ksf> undocumented /= clearly documented as internal.
03:25:54 <merijn> I've seen it, I just never seen it become a problem big enough to qualify as an issue
03:26:00 <Eduard_Munteanu> ksf: I wonder whether that's some strategy to attract patches exposing functionality in a sane manner :)
03:26:16 <rostayob> whald: I@m reading here http://hackage.haskell.org/packages/archive/mwc-random/0.10.0.1/doc/html/System-Random-MWC.html , and you have everything you need already, you can work directly in ST, all the instances are there
03:26:18 <Jafet> #include the module into a TH splice!
03:27:23 <rostayob> whald: you can just "create" in the ST monad, put it somewhere, and then use it with unform etc.
03:27:34 <ksf> luckily, all that dbus introspection stuff is properly exposed.
03:30:51 <Jafet> whald: I might choose to write shuffle :: forall s. (RandomGen g, MVector v a) => v s a -> STRef s g -> ST s ()
03:31:35 <Jafet> The actual definition should follow easily from that.
03:33:17 <rostayob> Jafet: I think that his point is that he wants MWC because it's fast while the RandomGen instances are slow
03:33:49 <Jafet> Oh, it's not an instance.
03:34:20 <rostayob> he probably needs shuffle :: forall s. Mvector v a => v s a -> GenST s -> ST s ()
03:34:30 <ksf> faster than mersenne?
03:34:52 <Jafet> I think it is.
03:34:57 <rostayob> ksf: I don't know, but he wants to use MWC. I remember some bos blog posts about this
03:34:58 <ksf> umpossible
03:35:48 * Jafet throws a book of RANDU digits at ksf
03:36:02 <rostayob> "Due to its simplicity, MWC256 is also very fast, and under appropriate circumstances (e.g. on a 64-bit machine) it can be even faster than the well known Mersenne Twister algorithm (which also fails some statistical tests that MWC256 passes)."
03:36:08 <ksf> ...though the haskell bindings don't even use the array functions.
03:36:21 <JuanDaugherty> bos?
03:36:30 <rostayob> JuanDaugherty: bryan o'sullivan
03:36:36 <JuanDaugherty> ah
03:37:17 <ksf> hackage needs some way to prune such stuff, btw.
03:37:46 <ksf> if nothing else, someone do a package called "gimmeh-fast-random"
03:41:10 <eyebloom> Is anyone familiar with "Compiling Embedded Languages" by Elliott et al?
03:43:59 <Yrogirg> Is "Exposed modules use unallocated top-level names: Math" warning in hackage something serious?
03:47:16 <romildo> For those who speak Portuguese: how do you translate the phrase "proper tail call" to Portuguese?
03:56:10 * earthy doesn't speak nearly enough portuguese to translate that
03:56:31 <earthy> otoh, I wouldn't even know how to translate it into my native dutch
03:58:44 <merijn> That's because something like tail call wouldn't be translated to Dutch :p
03:58:59 <koeien> "staartaanroep"
03:59:03 <koeien> :)
03:59:13 <geheimdienst> Schwanzruf
03:59:41 <earthy> koeien: *proper* tail call?
03:59:48 <merijn> koeien: "echte staart aanroep", you forgot proper :p
04:01:41 <earthy> well, actually, a better translation to Dutch would be 'zuivere rechtsrecursieve aanroep'
04:02:47 <earthy> that might give hints to translating it into portuguese, as 'zuivere rechtsrecursieve aanroep' would be literally translated into 'pure right-recursive call'
04:03:02 <earthy> which may well be directly translatable into portuguese
04:03:45 <earthy> of course, this hails back to the terminology used by the Algol group at CWI
04:04:42 <earthy> (er, mathematisch centrum, as it was known back then)
04:11:02 <erus`> whats a unicode character thats a w but more curly?
04:11:51 <mux> omega?
04:11:51 <Nimatek> The omega? ω
04:11:53 <Entroacceptor> erus`: you mean the small omega?
04:11:57 <erus`> yup
04:11:59 <Entroacceptor> damn :)
04:12:00 <rostayob> aha
04:12:06 <erus`> what does it mean in an electrical diagram?
04:12:12 <mux> resistance IIRC
04:12:16 <mux> oh, no.
04:12:18 * mux hids
04:12:19 <koeien> wasn't that capital omega?
04:12:25 <mux> it's Ohm :)
04:12:27 <rostayob> yeah ohm is capital omega
04:12:29 <erus`> yeah thats ohms
04:12:31 <mux> and yeah, it's capital
04:12:35 <earthy> oh, i would've guessed U+1D464 Mathematical Italic Small w
04:12:36 <rostayob> IT'S OHM
04:12:40 <koeien> (the unit)
04:12:42 <mux> I have no idea what the small omega is supposed to mean
04:12:48 <rostayob> angular velocity
04:12:53 <rostayob> :D
04:13:22 <Nimatek> Natural frequency.
04:13:30 <ziman_> omega is 2πf
04:13:54 <Entroacceptor> erus`: does it have some value?
04:14:20 <erus`> i duno, i will ask my boss for some more context
04:17:44 <erus`> it was ω = 2πf
04:17:49 <erus`> so natural frequency :)
04:18:04 <erus`> mystery solved. Next!
04:26:29 <obiwahn> why is eta rduction useful for haskell?
04:26:59 <obiwahn> dont't we stop when whnf is reached?
04:27:30 <born2code> Hello all
04:30:27 <ziman> whnf is related to beta-reduction.
04:31:16 <quicksilver> eta reduction is possibly a (tiny) optimisation that the compiler will perform in some cases
04:31:26 <quicksilver> it's not of much practical interest. (It is of theoretical interest)
04:32:07 <born2code> i have file name Amn.hs in which includes a module name " module Data.Spatial.Index.Sim where " but when i am trying to load it :l Sim.hs , i am getting error " Could not find module `Data.Spatial.Index' "
04:32:21 <born2code> Sorry file name is Sim.hs
04:33:02 <born2code> I have other file Index.hs which defines " module Data.Spatial.Index where "
04:33:36 <ClaudiusMaximus> born2code: directory structure should be something like .../Data/Spatial/Index.hs and .../Data/Spatial/Index/Sim.hs
04:34:01 <born2code> ClaudiusMaximus: Thank you
04:36:32 <born2code> ClaudiusMaximus: and what if i have one more module Snowfall.Binay and my Data.Spatial module import import Snowfall.Binary ?
04:37:11 <obiwahn> quicksilver: \x -> f x  =eta=>> f but \x-> f x is in whnf?! and if have to evaluate it i can do it with 1 step beta.
04:37:17 <born2code> ClaudiusMaximus: should i make root directory let say abc and in which i create Data and Snowfall directory
04:37:27 <quicksilver> obiwahn: what is your question?
04:37:47 <bluelizard> test
04:37:48 <quicksilver> obiwahn: yes, certainly, things in whnf can admit eta reduction.
04:38:22 <born2code> ClaudiusMaximus: and then put corresponding function to their respective directory
04:38:39 <born2code> ClaudiusMaximus:  am i correct ?
04:39:45 <rostayob> Is there any package for JavaScript code generation? so basicaly a Syntax data type + a pretty printer
04:39:56 <ClaudiusMaximus> born2code: yes, i think so
04:40:16 <erus`> rostayob: writing a haskell -> Javascript compiler? :D
04:40:25 <born2code> ClaudiusMaximus: thank you
04:40:27 <rostayob> erus`: no, writing templates that compile to haskell and javascript
04:40:51 <ClaudiusMaximus> born2code: you could 'cabal unpack' some packages from hackage to see how they arrange their files, or browse some repositories online
04:42:13 <ClaudiusMaximus> born2code: i'm not sure how ghci handles being started inside the heirarchy, if you experience problems probable easiest to start ghci from inside your abc and :l Data/Spatial/Index/Sim.hs or similar
04:42:32 <rostayob> wow the ECMA spec is 250 pages :(
04:43:23 <obiwahn> quicksilver: i have no particular question i try to understand delta reduction and why the restriction of the term arguments can be lifted from normalfom to whnf and why that is usefull for patternmatching
04:44:20 <erus`> rostayob: this is why everyone hates JS :)
04:44:29 <rostayob> erus`: because the specification is long?
04:44:37 <erus`> yeah so much bloat
04:45:06 <erus`> and no integers
04:45:19 <rostayob> well, the haskell report is 300 pages
04:45:41 <erus`> how many people use haskell? case closed. checkmate
04:45:46 <rostayob> ahah
04:46:19 <osfameron> I was just saying on #otherchan that we need a purely functional web scripting language ;-)
04:46:37 <merijn> osfameron: Why?
04:46:38 * osfameron waits to be flooded with links to research papers implementing such
04:46:44 <mux> let's call it HaskellScript; this way we'll rival the stupidity of the JavaScript name
04:46:51 <merijn> Oh, webscripting
04:47:03 <osfameron> merijn: oh, mostly to troll someone who was talkig about the Dillo browser (which doesn't implement js, becasue it's a security risk)
04:47:07 <merijn> osfameron: There's a haskell to JS compiler in UHC by UU
04:47:15 <rostayob> well they are trying to do hs->js
04:47:23 <rostayob> there was a compiler from YHC core to js
04:47:26 <rostayob> and there is ghcjs
04:47:27 <erus`> i was gonna write a mozilla plugin that uses safe haskell
04:47:31 <mux> js isn't a security risk per self, that just sounds like a lame excuse for not implementing it, or some over the top pedantism
04:47:44 <mux> by itself*
04:47:44 <rostayob> and there is emscripten! never forget emscripten ahah
04:47:47 <osfameron> ah, U == Utrecht
04:47:53 <merijn> mux: Depends on which security we're discussing
04:48:22 <rostayob> emscripten is one of the most amusing projects recently
04:48:27 <merijn> mux: JS is a horrible security risk in the context of cookies, XSRF, XSS, etc
04:48:30 <raichoo> h/window 11
04:48:33 <raichoo> arg
04:48:35 <osfameron> ooo, emscripten looks fun
04:49:12 <mux> merijn: I couldn't disagree more; first JS has strictly nothing to do with cookies, then... I'm not sure I even want to discuss this.
04:49:22 <rostayob> osfameron: emscripten is loads of fun.
04:49:28 <mux> to each his own I guess.
04:49:51 <mux> but blaming JS for security is like blaming ethernet cards because an offline PC would be more secure.
04:50:04 <merijn> mux: Ok, JS itself is not the issue, I agree
04:50:18 <rostayob> cpython compiled to llvm bytecode compiled to javascript yo http://syntensity.com/static/python.html
04:50:41 <merijn> The web's security model is fundamentally broken and JS makes it easier to exploit, nuanced enough?
04:50:58 <mux> makes a whole lot more sense to me, at least
04:51:16 <koeien> somebody in #snapframework said that s/he was working on a UHC-based hs -> javascript compiler
04:51:50 <rostayob> I think that the only developed hs->js compiler right now is https://github.com/sviperll/ghcjs
04:51:51 <osfameron> it potentially makes the advantage od node.js (single stack) redundant
04:51:52 <merijn> koeien: At the Dutch Functional Programming day they said they already had some basic stuff working
04:52:05 <koeien> merijn: in January?
04:52:27 <Phyx-> koeien: yeah
04:52:34 <rostayob> ah no, the UHC one as well
04:53:22 <merijn> koeien: Yeah
04:53:33 <Phyx-> koeien: Atze didn't really blog much but http://utrechthaskellcompiler.wordpress.com/2010/10/18/haskell-to-javascript-backend/
04:53:41 <erus`> i hope googles dash will be easier to target
04:53:49 <erus`> for purely functional code
04:54:05 <Phyx-> yeah, good luck getting anyone but google to use it
04:54:08 <rostayob> erus`: I don't think it will
04:54:20 <Phyx-> they're already pissing off everyone on the standards committee
04:56:17 <koeien> Phyx-: interesting. any idea how performant it is?
04:57:57 <Phyx-> koeien: unfortunately no, don't have access to the logs/benchmarks anymore either
04:59:34 <koeien> it would be possible to run the google closure compiler over it afterwards
04:59:52 <koeien> i do not know if it can do tricks like eta-reduction :)
05:00:46 <koeien> it also has optional type declarations afaik
05:01:05 <Phyx-> could be interesting to see the performance difference
05:01:12 <erus`> Phyx-: Is it just another static typed OO language?
05:01:48 <koeien> there's also NaCl
05:02:26 <Phyx-> erus`: dash? dunno, I haven't looked at it. I just read an article that said they cauzed a stir, since they want everyone to use it, and it to be an open standard, but they developed it completely behind closed doors taking only their ideals in considerations
05:02:34 <erus`> koeien: i like the look of pNaCl more
05:03:56 <ben> is pnacl the one that's based on llvm bytecode?
05:04:02 <erus`> yeh
05:04:34 <osfameron> what's good for Google is good for America
05:05:09 <ben> So for haskell you'd still ship the entire ghc rts?
05:09:29 <erus`> ben, maybe there is shared libraries or something
05:11:46 <born2code> A haskell file contains import Data.Key ((!), mapWithKey) but when i am trying to cabal install key then it says cabal: There is no package named 'key'.
05:11:58 <born2code> How to install this package .
05:12:15 <opqdonut> use hoogle to find the package
05:12:59 <ece> hi there
05:13:07 <opqdonut> oh, hoogle doesn't find it
05:13:51 <benmachine> born2code: do you have cabal-install?
05:14:09 <born2code> yes
05:14:37 <born2code> benmachine: i think so
05:14:54 <benmachine> so, cabal update
05:15:00 <benmachine> oh wait
05:15:02 <benmachine> you said
05:15:03 <benmachine> thing
05:15:07 <benmachine> ok sorry I misread
05:15:19 <born2code> benmachine:  i think i don't have cabal-install
05:15:37 <benmachine> born2code: cabal install keys
05:15:56 <benmachine> born2code: I googled Data.Key and it comes from the keys package
05:15:58 <benmachine> http://hackage.haskell.org/package/keys
05:18:12 <born2code> benmachine: thank you . Now its working
05:22:23 <LazyAxe> rostayob: Did you install ghcjs  or uhc with ghc7? I couldn't compile them. And projects look like dead.
05:24:49 <rostayob> LazyAxe: no, I never compiled and run ghcjs but I asked chrisdone a few days ago and it should work with ghc 7 on a 32bit machine
05:25:10 <rostayob> oh right, of course it interests you :)
05:25:24 <rostayob> you want to do something similar
05:26:56 <LazyAxe> rostayob: Hm, it is interesting. Yes, I want haskell in the web too.
05:27:44 <LazyAxe> rostayob: Btw, it seems there no way to obtain function clauses by its name in TH.
05:28:33 <rostayob> LazyAxe: of course there is, by it's Name
05:28:50 <LazyAxe> rostayob: So I need quasi-quote code.
05:28:52 <rostayob> not the string name, but you can reference functions with " ' " and constructors with " '' "
05:28:59 <rostayob> no you don't need to quasi quote
05:29:28 <LazyAxe> rostayob: How? reify knows only type of function.
05:30:04 <rostayob> LazyAxe: what do you mean? you can derive the name a of a function "foo" simply doing 'foo
05:31:12 <LazyAxe> rostayob: Yes, but there are no  function :: Name -> Q [Dec] which can tell me clauses of foo.
05:31:54 <rostayob> LazyAxe: there isn't? oh.
05:32:05 <rostayob> ah right you need the actual syntax tree
05:32:07 <rostayob> mhm...
05:33:31 <rostayob> LazyAxe: yeah you're right, sorry. there should be a way
05:33:37 <LazyAxe> rostayob: Yes. Of course, I can quasi-quote it and derive both js and hs variants. But if I use another function in the definition of foo, I fail.
05:34:40 <rostayob> LazyAxe: yeah, annoying
05:35:25 <quicksilver> rostayob: well, there can't be a way, can there?
05:35:30 <quicksilver> the source of other modules is not available to TH
05:35:40 <quicksilver> only the (limited parts of) the source of the current module.
05:36:16 <rostayob> quicksilver: yes, which is why you can use TH at all
05:36:31 * quicksilver nods
05:37:04 <LazyAxe> quicksilver: But from current module we cannot take AST too, while it is technically possible.
05:37:25 <drbean>  
05:37:37 <quicksilver> LazyAxe: it would only be technically possible for definitons already complete
05:37:50 <quicksilver> since TH is strictly top-to-bottom in the file
05:38:02 <quicksilver> certainly it's an interesting point.
05:39:35 <LazyAxe> quicksilver: Yes. This is impossible in current implementation (we need multiple passes). But it seems to be possible theoretically.
05:41:31 <LazyAxe> However, even simple "case..of" construction with using haskell types for parameters (instead of non-typed js objects) may do our life simpler, so I'll try implement this.
05:42:33 <LazyAxe> Moreover, haskell types can be parameters of widgets (haskell-macros for js), and this is good.
05:42:50 <rostayob> LazyAxe: Again, I'd use a DSL for stuff like that, but ok :D
05:43:09 <rostayob> which is what HJavaScript does already, but HJavaScript is a pain to use
05:44:27 <LazyAxe> rostayob: This _is_ DSL de-facto, but it is already type-checked haskell code and familiar syntax.
05:44:55 <rostayob> LazyAxe: yeah but the scope of haskell syntax makes it super easy to write stuff that you won't be able to compile
05:46:49 <rostayob> LazyAxe: I don't know I just wouldn't like the feeling of writing an extreme subset of haskell with haskell syntax :P
05:47:04 <hpaste> “Mukesh Tiwari” pasted “Error in Installing Data.deriveTH ” at http://hpaste.org/51376
05:47:18 <LazyAxe> rostayob: Hmm, may be. Than I will use special compiler DSL -> Haskell instead of id :: Q [Dec] -> Q [Dec].
05:47:23 * hackagebot yaml 0.4.1.1 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.4.1.1 (MichaelSnoyman)
05:48:31 <born2code> I am trying to install derive but i am getting error
05:48:45 <born2code> could some one please tell me how to avoid this error ?
05:49:28 <rostayob> born2code: what does ghc-pkg check give?
05:51:02 <born2code> rostayob: no output
05:51:48 <rostayob> born2code: anyway, the problem seems to be that Cabal relies on a broken package, try to reinstall containers (cabal install --reinstall containers) and then cabal
05:53:13 <born2code> rostayob: it installed with no error
05:54:37 <born2code> but cabal install haskell-src-exts giving same error
05:56:36 <benmachine> don't reinstall containers!
05:56:47 <benmachine> probably a bad idea
05:57:12 <born2code> benmachine: i already reinstalled
05:57:20 <born2code> but its not working
05:57:35 <benmachine> born2code: if ghc-pkg check doesn't say anything then it's not too late :P
05:58:06 <rostayob> oh right it'll probably break packages depending on the previous containers install
05:58:27 <born2code> benmachine: yes its giving no output
05:59:02 <benmachine> rostayob: where did you get the idea that it related to containers?
05:59:24 <rostayob> Cabal-1.10.2.0-072fce39d68f011c6a364057a3d15270 is unusable due to missing or recursive dependencies:
05:59:27 <rostayob>       containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379
05:59:50 <rostayob> I'm Cabal-1.10.2.0-072fce39d68f011c6a364057a3d15270 is unusable due to missing or recursive dependencies:
05:59:53 <rostayob> ops
06:00:26 <rostayob> I'm desensitized towards cabal, I just tend to use brute force too much I guess
06:02:11 <born2code> rostayob: should i use cabal install --reinstall containers-0.3.0.0-ee442470d8dcc9e45f31677c400c5379 ?
06:02:57 <rostayob> born2code: to be honest I don't know, mine was just a guess (and probably a bad one), so you're better off waiting for help from someone else :P
06:03:52 <born2code> rostayob: Thank you :)
06:04:02 <Saizan> @where sicp
06:04:02 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
06:04:02 <lambdabot> classes/6.001/abelson-sussman-lectures/>
06:04:41 <Saizan> http://www.vex.net/~trebla/haskell/sicp.xhtml <- i meant this one
06:04:55 <benmachine> rostayob: where did you get *that* from?
06:05:00 <benmachine> is there a paste I'm missing
06:05:08 <rostayob> benmachine: http://hpaste.org/51376
06:05:27 <benmachine> oh, those are the same person
06:05:57 <benmachine> hm
06:06:15 <benmachine> weird
06:09:11 <benmachine> born2code: what does ghc-pkg list look like?
06:09:38 <benmachine> born2code: do ghc-pkg list | cat and hpaste the result
06:11:01 <hpaste> “Mukesh Tiwari” annotated “Error in Installing Data.deriveTH ” with “Error in Installing Data.deriveTH  (annotation)” at http://hpaste.org/51376#a51377
06:11:05 <aavogt> isn't   | cat   id?
06:11:12 <mauke> aavogt: no
06:11:23 <rwbarton> it's a type-restricted form of id
06:11:51 <benmachine> aavogt: in this case I'm tricking ghc-pkg into thinking stdout is not a tty, so it won't use colours
06:11:56 <born2code> benmachine: i posted it on hpaste
06:12:05 <benmachine> born2code: yeah one sec
06:18:16 <benmachine> born2code: I think you want to unregister the local version of anything that appears in the global package list
06:18:33 <benmachine> born2code: so ghc-pkg unregister --user array, for example
06:18:45 <benmachine> if it comes up with an error, stop and tell us before doing anything
06:19:18 <born2code> benmachine: ok
06:19:46 <obiwahn> i am trying to install lambdabot and cabal compalins about missing haskell-src-ext
06:20:13 <obiwahn> i use a debian sid and there is only a haskell-src-ext-doc package :(
06:20:19 <obiwahn> what can i do?
06:20:24 <hpaste> “Mukesh Tiwari” annotated “Error in Installing Data.deriveTH ” with “Error in Installing Data.deriveTH  (annotation) (annotation)” at http://hpaste.org/51376#a51378
06:21:00 <born2code> benmachine: its showing that it will some packages
06:22:08 <benmachine> born2code: ouch.
06:22:29 <obiwahn> happy was missing ...
06:22:49 <benmachine> born2code: try ghc-pkg unregister --user template-haskell
06:24:02 <born2code> benmachine: it goes smooth without any output
06:24:11 <benmachine> ok good start
06:24:35 <benmachine> ghc-pkg unregister --user containers-0.4.1.0
06:26:23 <born2code> benmachine: it shows that it will break uniplate-1.6.2
06:26:41 <benmachine> that's all?
06:26:54 <benmachine> what about ghc-pkg unregister --user containers-0.3.0.0
06:28:15 <hpaste> “Mukesh Tiwari” annotated “Error in Installing Data.deriveTH ” with “Error in Installing Data.deriveTH  (annotation) (annotation) (annotation)” at http://hpaste.org/51376#a51379
06:28:44 <born2code> benmachine: its showing couple of packages will be breaked
06:29:30 <benmachine> born2code: sigh. I'm not sure what to do; I think it basically comes down to you've got to unregister them all anyway, and then reinstall whatever breaks
06:29:34 <benmachine> but I don't know
06:30:02 <benmachine> born2code: http://www.vex.net/~trebla/haskell/sicp.xhtml explains why it is bad to have local installations of global packages
06:31:07 <born2code> benmachine: so i should always do any installation from root
06:31:15 <born2code> benmachine: to prevent these kind of things
06:32:10 <benmachine> born2code: no
06:32:22 <benmachine> cabal-install should always be in the user database
06:32:43 <benmachine> that way if everything goes horribly wrong it's easy to start from scratch without damaging the GHC install
06:32:57 <benmachine> but you shouldn't install new versions of packages that came with GHC
06:33:04 <benmachine> (packages in the global database)
06:34:16 <born2code> benmachine: one more thing i want to let you know  , cabal-install in not installed on my pc
06:35:01 <benmachine> born2code: ...but you installed keys with it
06:35:23 <benmachine> the 'cabal' command comes from cabal-install
06:35:35 <born2code> benmachine: i used cabal install keys
06:35:54 <benmachine> born2code: yeah, that's cabal-install
06:37:06 <born2code> benmachine: but my home machine , when i put caba and press tab then its show both cabal and cabal-install
06:37:23 <born2code> benmachine: today i will check it
06:37:50 <benmachine> born2code: I've never heard of a program called cabal-install
06:38:52 <born2code> benmachine: should i uninstall the whole ghc and reinstalling will help  ?
06:40:04 <benmachine> born2code: that shouldn't be necessary. if you want to do something drastic, you can wipe ~/.ghc/ to get rid of all user packages, that should be enough
06:40:46 <born2code> benmachine: i do this but if it helps to install derive
06:41:38 <benmachine> born2code: it should be possible to fix your installation without doing that, but it will take more work
06:41:42 <born2code> benmachine: will it erase all the package both in local and global space
06:41:46 <benmachine> no
06:41:56 <benmachine> wiping ~/.ghc will make ghc forget about all local packages
06:42:08 <benmachine> the global ones will be fine
06:42:13 <benmachine> imo you should leave the global ones alone
06:42:16 <benmachine> and only install local ones
06:42:21 <benmachine> so that you can do this when things go wrong
06:44:22 <born2code> benmachine: Actually i got a my first real world Haskell project and trying to finish it .
06:45:39 <born2code> benmachine: so i do wipe ~/.ghc it will erase all the local packages
06:45:58 <born2code> benmachine: after that i should install every package one by one
06:46:03 <benmachine> born2code: strictly speaking, it will just erase the package database, the actual packages are stored in ~/.cabal
06:46:24 <benmachine> born2code: you should not install containers, array, or template-haskell, and if cabal tries to install any of them you should stop it
06:46:44 <benmachine> (likewise any other package that is already installed globally, but those are the ones that tripped you up this time)
06:47:12 <LazyAxe> born2code: you may try cabal-dev — for me it prevents from such errors. It install packages in ./cabal-dev instead ~/.cabal, so you may avoid dependency conflicts. (At this moment you possibly need clear ~/.cabal firstly.)
06:48:21 <obiwahn> > 4 + 5
06:48:21 <lambdabot>   9
06:48:49 <obiwahn> 16:40 < obiwahn> > 4 + 5
06:48:49 <obiwahn> 16:40 < hbot>  Terminated
06:48:51 <obiwahn> :((
06:49:12 <born2code> benmachine: If i got u correctly , i should stop installing those libraries locally  which are already in global space  like container , array . Am i correct ?
06:49:36 <benmachine> born2code: yes
06:49:47 <benmachine> obiwahn: have you got mueval installed and working?
06:49:54 <born2code> LazyAxe: cabal-dev install pkg-name ?
06:51:01 <LazyAxe> born2code: Yes. It is similar to cabal, but more clever in resolving conflicts.
06:51:14 <benmachine> I don't think it is more clever, really
06:51:25 <benmachine> it just isn't so likely to cause them because it installs stuff locally
06:51:36 <benmachine> hmm
06:51:45 <benmachine> ok I don't know much about cabal-dev
06:51:49 <benmachine> so I won't comment
06:53:35 <born2code> benmachine: on final note , i am going to do wipe ~/.ghc so it will uninstall all my local package and after that i should install all the packages one by one using cabal-dev install pkg-name .
06:54:03 <benmachine> born2code: I don't know about cabal-dev, I don't know how it works
06:54:10 <LazyAxe> benmachine: maybe; it doesnot matter :)
06:55:01 <born2code> benmachine: so should i take chances or should wait for some reply ?
06:55:13 <LazyAxe> born2code: if you can install cabal-dev now, maybe you need not clear cache.
06:56:47 <benmachine> born2code: I don't think cabal-dev is what you want, but LazyAxe does
06:56:47 * benmachine shrug
06:56:56 <born2code> LazyAxe: i did not get you ?
06:57:22 <born2code> benmachine: i am not sure how to resolve this issue
06:57:48 <benmachine> born2code: in my opinion, you should do exactly what you just said, but with cabal and not cabal-dev
06:59:19 <born2code> benmachine:  wipe ~/.ghc and use cabal install pkg-name for each package .
06:59:44 <born2code> benmachine: you also told me i should stop it when its try to install array to haskell-template
06:59:53 <benmachine> born2code: right (template-haskell)
07:00:04 <benmachine> (and containers, and anything else global)
07:00:55 <born2code> born2code: So you mean any library which is inside /var/lib/ghc-6.12.3/package.conf.d . Am i correct ?
07:01:13 <born2code> benmachine: So you mean any library which is inside /var/lib/ghc-6.12.3/package.conf.d . Am i correct ?
07:01:25 <benmachine> yes
07:02:33 <born2code> benmachine: And how to stop if i am trying to install a package which is not globally but depends on global package .
07:02:51 <born2code> benmachine: it generally installs that package locally
07:03:14 <born2code> benmachine: So how to stop it
07:03:17 <erus`> I feel like google is way too big for its boots now. Its scary
07:03:38 <benmachine> born2code: oh, um, ctrl-C? I guess?
07:04:12 <benmachine> born2code: you can run cabal install keys --dry-run to see what cabal wants to install to install keys
07:06:17 <benmachine> and then decide whether to run it or not
07:07:23 * hackagebot GaussQuadIntegration 0.1 - Non-adaptive Gaussian quadrature for numeric integraton  http://hackage.haskell.org/package/GaussQuadIntegration-0.1 (GrigorySarnitsky)
07:07:52 <born2code> benmachine: so it shows all the libraries which it will install .
07:08:13 <benmachine> born2code: right
07:08:26 <born2code> benmachine: and if any library show that it will install a library which is in the global space
07:08:52 <benmachine> born2code: if that happens come back here and ask for help :P
07:09:36 <born2code> benmachine:  :) pardon me for so many questions .
07:10:02 <born2code> benmachine: but i am just a beginner in the feild of Haskell software development
07:10:23 <benmachine> born2code: I feel like I should apologise on behalf of cabal, it's really annoying when it does this
07:10:38 <obiwahn> benmachine: mueval: Most RTS options are disabled. Link with -rtsopts to enable them?!
07:10:53 <obiwahn> i have no ide how to enable that ...
07:11:06 <benmachine> obiwahn: that doesn't sound like a problem?
07:11:40 <obiwahn> happen when i ask to evaluate 4 + 5
07:12:22 <born2code> benmachine: so i should be sure that if i am installing a library and if it depends on library which is in the global space then it will not install  the library locally .
07:12:38 <benmachine> born2code: yes, I think so
07:12:46 <benmachine> obiwahn: does it then say 9 as well?
07:13:15 <born2code> born2code: thank you for such a detailed help and bearing with me :)
07:13:29 <obiwahn> no:(
07:13:36 <born2code> benmachine: i learned lot today
07:13:52 <born2code> benmachine: thank you for such a detailed help and bearing with me :)
07:14:03 <benmachine> obiwahn: hm. iono.
07:14:08 <benmachine> born2code: np :)
07:14:23 <ion> benmachineo
07:27:38 <KirinDave> I was trying to solve an iteratee problem last night and I realized there is a deficiency in my understanding of how to write monadic code. Was hoping someone here would have some pointers.
07:27:58 <KirinDave> I want to write an iteratee for a stream, and this iteratee must carry decryption state.
07:28:33 <KirinDave> This isn't so hard, but what I don't get is how to offer it as the fully composable sort of abstraction that iteratees make possible.
07:29:55 <KirinDave> Do I just have to accept that clients of my code can't have their own stateful operations? I can bury IO in my monad and they can always use side effects to aggregate things, I suppose. But that's hardly what I think of as beautiful haskell code.
07:30:36 <KirinDave> How do people write reusable code in this situation?
07:30:45 <KirinDave> Even an example would be sufficient. :)
07:33:13 <dankna> KirinDave, I'd try to help except I've never used iteratees, so...
07:33:25 <KirinDave> dankna: Well we could ignore iteratees
07:33:30 <dankna> well,
07:33:36 <KirinDave> dankna: Let's say I've got a stateful set of code that will call a continuation of your
07:33:52 <KirinDave> And then you will yieldback to me later without me having any regard for what you are doing.
07:33:53 <dankna> are continuations fundamental to the problem
07:33:56 <KirinDave> (which suggests I/O)
07:34:26 <KirinDave> I _think_ so, but you may have noticed I am a haskell newbie so...
07:34:29 <dankna> okay
07:34:30 <dankna> well
07:35:23 <dankna> the way I would handle an encrypted stream is to have a type EncryptionState and then a type Encrypted = StateT EncryptionState IO, right
07:35:30 <KirinDave> Sure.
07:35:47 <KirinDave> And we keep IO in there because we want to be flexible
07:35:51 <dankna> well
07:35:56 <dankna> I'm not sure we need the IO, actually
07:36:08 <KirinDave> Well what if client code wants to liftIO? :)
07:36:12 <dankna> the important thing is that the code that does the higher-level control, instead of being in this monad
07:36:15 <KirinDave> Oh wait, unsafePerformIO.
07:36:16 <dankna> is in ANY monad
07:36:19 <dankna> ugh no :)
07:36:25 <KirinDave> *wwwiiiinnnk*
07:36:34 <dankna> Monad m => EncryptionState -> m
07:36:43 <dankna> er
07:36:47 <dankna> Monad m => EncryptionState -> m a
07:37:19 <dankna> that is, the code that runs "inside" the encryption is actually not really inside, not really outside, but parallel to it
07:37:41 <dankna> it takes the encryption state as a balled-up type
07:37:46 <dankna> or even
07:37:55 <KirinDave> Right, I could newtype the encryption state
07:38:02 <dankna> Monad m => EncryptionState -> (EncryptionState -> ?) -> m a
07:38:11 <dankna> it takes a callback, or even a set of callbacks
07:38:20 <dankna> that perform the operations on the stream and return new EncryptionStates
07:38:21 <KirinDave> So they they do StateT TheirAppState (MyAppEnvironmentWhichBtwIncludesIO)
07:38:29 <dankna> this is similar to how I actually architected my encryption code :)
07:38:38 <dankna> (which isn't ready and doesn't work)
07:38:41 <dankna> (or I'd show it)
07:39:11 <dankna> (I actually hpasted a snippet of it some months ago and that resulted in a slew of emails from people who had found the hpaste via google and jumped to the conclusion that it was significantly more complete than it was)
07:39:24 <dankna> yeah, exactly
07:39:31 <dankna> they can be in anything that's an instance of Monad
07:39:47 <KirinDave> Okay
07:40:08 <KirinDave> I get this general idea
07:40:10 * dankna nods
07:40:15 <KirinDave> I'm just trying to figure how now how to apply it to iteratees.
07:40:25 <dankna> okay.  well, you need someone who knows them for that :)
07:40:34 <KirinDave> Because the way enumeratees work when you want to compose a big lazy infinite stream is by nesting them sort of inside each other.
07:40:41 <dankna> hmm
07:40:42 <KirinDave> But even in this idea
07:41:01 <KirinDave> Isn't it the case that your encryption method is going to spit back (DecryptedBytes, DecryptionState)?
07:41:08 <dankna> certainly
07:41:11 <KirinDave> Okay.
07:41:52 <KirinDave> I guess if you just newtype a data that is the union of the state and the bytes
07:41:58 <KirinDave> and then expose ONE method to get at the bytes
07:42:24 <dankna> I'm not sure that's necessary or useful
07:42:39 <dankna> the state doesn't include the bytes logically, does it?
07:42:51 <KirinDave> No
07:43:00 <KirinDave> But it'd make it easier for them to pass it back without caring about the structure.
07:43:13 <KirinDave> I guess there is a memory overhead there, but it shouldn't be huge.
07:43:21 <dankna> no, newtypes don't have memory overhead
07:43:25 <KirinDave> Well
07:43:26 <dankna> they don't exist at runtime
07:43:35 <KirinDave> Passing the bytes you just got back to the parent code
07:43:54 <KirinDave> If it's hidden in a newtype'd structure
07:44:16 <dankna> I think since this is a fundamental of this type of layering
07:44:19 <dankna> it's wrong to hide it
07:44:23 <KirinDave> Hmm
07:44:24 <dankna> I see that there's some room for personal preference, though
07:44:43 <dankna> you are kinda trying to define the concept of stateful stream-transformer
07:44:53 <dankna> any stateful stream transformer is going to have a) state, b) data :)
07:44:59 <KirinDave> Yeah
07:45:47 <Artit> why a get "Not in scope: data constructor `Ord" error when i type "Ord 'a'"?
07:46:02 <dankna> Ord is not a type
07:46:04 <dankna> it's a type-class
07:46:14 <Artit> how can i use it?
07:46:19 <dankna> what are you trying to do with it?
07:46:34 <KirinDave> Artit: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Ord
07:46:36 <Artit> print a's code
07:47:01 <KirinDave> Artit: Ord is a group of functions that can accept a variety of argument types.
07:47:12 <KirinDave> Artit: You don't "make an instance of Ord"
07:47:19 <KirinDave> you have things that are already instances of Ord.
07:47:35 <dankna> Artit: can you be more descriptive about why you want to print the code and what you mean by the code and whether this is for debugging or real use and what the phase of the moon is and in general more explicit?
07:47:53 <KirinDave> > compare 'a' 'b'
07:47:54 <lambdabot>   LT
07:47:56 <KirinDave> See?
07:48:10 <KirinDave> > max 1 2
07:48:10 <lambdabot>   2
07:48:12 <KirinDave> See?
07:48:13 <Artit> i see :)
07:48:42 <KirinDave> Huh, () is an Ord?
07:48:47 <KirinDave> > max (1) (2)
07:48:47 <lambdabot>   2
07:48:55 <dankna> (a) is not a type
07:48:58 <KirinDave> > max (1,2) (3,4)
07:48:59 <lambdabot>   (3,4)
07:49:07 <dankna> (a) is just parenthesized a
07:49:12 <KirinDave> > max (99,1) (98,1000)
07:49:13 <lambdabot>   (99,1)
07:49:18 <KirinDave> Yeah I just typo'd
07:49:25 <KirinDave> Fingers all derpin'
07:49:26 <dankna> that said, for 2-tuples and larger, yes, there's an Ord instance
07:49:28 <yrlnry> KirinDave:  if a and b are Ords, then (a,b) is an Ord.
07:50:23 <mauke> > max () ()
07:50:24 <lambdabot>   ()
07:50:39 <yrlnry> But is that the left () or the right ()?
07:50:41 <osfameron> oh, that's quite magical.  It does deriving Ord, but only if all of its component slots are Ord?  And likewise for (Eq, etc.) ?
07:50:48 <KirinDave> yrlnry: Don't make me freak out.
07:50:59 <dankna> osfameron, it's not magical, you can do it yourself for your own typeclasses, like so
07:51:06 <mauke> > max () (error "")
07:51:06 <dankna> (Ord a, Ord b) => Ord (a, b)
07:51:07 <lambdabot>   *Exception:
07:51:11 <KirinDave> Hah
07:51:25 <osfameron> dankna: sure.  But you can have a tuple of (NotOrd, Ord) for example ?
07:51:29 <KirinDave> I figured the code for that would be ugly.
07:51:43 <KirinDave> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Classes.html#Ord
07:51:46 <dankna> osfameron: the context (Ord a, Ord b) means that the definition is only valid when the context is satisfied
07:51:57 <yrlnry> osfameron:  yes, and such a tupe would not be of a type that was an instance of Ord unless you defined the instance yourself.
07:52:55 <osfameron> dankna: oh, that declaration is conditional (but doesn't error if it's not met) ?
07:53:28 <Gracenotes> I might be able to talk about system f-omega-sub to a bunch of grad students
07:53:40 <dankna> osfameron: yeah; it simply ? isn't found when looking for relevant definitions, except when the context is satisfied
07:53:55 <osfameron> where do you put that declaration?
07:53:59 <dankna> like this:
07:54:18 <Gracenotes> and how it's undecidable under certain conditions and stuff >_>
07:54:19 <osfameron> yrlnry: yeah, fair enough
07:54:35 <osfameron> I kinda "knew" it did this, but hadn't really thought about *how* ;-)
07:54:57 <dankna> instance (Ord a, Ord b) => Ord (a, b) where { compare (aL, aR) (bL, bR) = case compare aL bL of { EQ -> compare aR bR ; other -> other } }
07:55:26 <dankna> in other words it's exactly like writing "instance Ord (a, b) where ?" except you tack the context onto the type
07:55:41 <osfameron> oh!
07:55:45 * osfameron faints
07:55:47 <dankna> :)
07:56:09 <mauke> compare (x1, y1) (x2, y2) = compare x1 x2 `mappend` compare y1 y2
07:56:09 * Gracenotes catches osfameron 
07:56:15 <Gracenotes> unless you're sitting
07:56:26 <osfameron> so it doesn't quite use deriving.  but it's very cute that you can write instances using pattern matching like that
07:56:35 <monochrom> @type \ x y -> x < Just undefined && y < id
07:56:36 <lambdabot> forall a a1. (Ord a, Ord a1) => Maybe a -> (a1 -> a1) -> Bool
07:56:49 <dankna> yes, precisely
07:56:56 <dankna> it doesn't use deriving at all, not just not quite :)
07:57:04 <dankna> deriving is a special case that isn't very extensible
07:57:15 <dankna> this is a much more general mechanism that you can use for your own typeclasses as well, as I said above
07:58:35 * monochrom enters "@type" into ghci!
07:58:53 <dankna> and I have to remember mauke's mappend trick
07:58:57 <dankna> I hadn't realized Ord was a monoid :)
07:59:01 <dankna> er Ordering
07:59:05 <monochrom> strange, plain ghci infers context Ord (a1->a1) rather than Ord a1
07:59:09 <dankna> Ordering being the result of comparing Ords
07:59:29 <mauke> > compare id id
07:59:29 <lambdabot>   *Exception: (==): No overloading for function
07:59:45 <dankna> :t compare id id
07:59:46 <lambdabot> Ordering
07:59:50 <dankna> :t id
07:59:51 <lambdabot> forall a. a -> a
08:00:03 <dankna> > compare (id :: Int -> Int) id
08:00:04 <lambdabot>   *Exception: (==): No overloading for function
08:00:06 <dankna> hm
08:00:10 <dankna> > compare (id :: Int -> Int) (id :: Int -> Int)
08:00:11 <lambdabot>   *Exception: (==): No overloading for function
08:00:17 <dankna> then I don't understand that error message
08:00:42 <mauke> why not?
08:01:20 <dankna> because I don't understand which function it's saying is not overloaded.  (==) or id?
08:01:31 <dankna> I mean I understand that you can't compare functions, haha
08:01:32 <mauke> id can't be overloaded
08:01:49 <obiwahn> i guess it is defined for class eq
08:02:03 <mauke> > id < id
08:02:04 <lambdabot>   *Exception: (==): No overloading for function
08:02:15 <mauke> I wonder why it ends up calling ==
08:02:21 <dankna> @src compare
08:02:21 <lambdabot> compare x y | x == y    = EQ
08:02:22 <lambdabot>             | x <= y    = LT
08:02:22 <lambdabot>             | otherwise = GT
08:02:24 * hackagebot ligd 0.1 - Lightweight Implementation of Generics and Dynamics  http://hackage.haskell.org/package/ligd-0.1 (SeanLeather)
08:02:42 <dankna> yeah that is weird
08:02:45 <dankna> @src Ord
08:02:46 <lambdabot> class  (Eq a) => Ord a  where
08:02:46 <lambdabot>     compare      :: a -> a -> Ordering
08:02:46 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:02:46 <lambdabot>     max, min         :: a -> a -> a
08:02:50 <dankna> oh okay
08:02:55 <b_jonas> but why is there an Ord instance?
08:03:03 <dankna> b_jonas: hmm, indeed, why :)
08:03:11 <dankna> :t id
08:03:11 <lambdabot> forall a. a -> a
08:03:11 <b_jonas> > is <= is
08:03:12 <lambdabot>   Not in scope: `is'Not in scope: `is'
08:03:19 <born2code> what is difference between IntMap and Map
08:03:19 <b_jonas> > id <= id
08:03:20 <lambdabot>   *Exception: (==): No overloading for function
08:03:23 <monochrom> the strange part is someone wrote an Ord instance but made sure every method bottoms
08:03:24 <dankna> > id == id
08:03:25 <lambdabot>   *Exception: (==): No overloading for function
08:03:26 <b_jonas> > id > id
08:03:27 <lambdabot>   *Exception: (==): No overloading for function
08:03:37 <dankna> this may be a lambdabot peculiarity
08:03:40 <dankna> rather than standard GHC
08:03:43 <b_jonas> quite likely
08:03:46 <dankna> ie someone may have defined something clever
08:03:51 <dankna> "clever"
08:03:52 <b_jonas> > f < 5
08:03:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:03:53 <lambdabot>    `GHC.Classes.Ord a'
08:03:53 <lambdabot>     ...
08:03:56 <b_jonas> > x < 5
08:03:57 <lambdabot>   False
08:04:00 <dankna> lol
08:04:01 <dankna> > x
08:04:02 <lambdabot>   x
08:04:02 <b_jonas> > f x < f 5
08:04:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:04:03 <lambdabot>    `SimpleReflect.FromExpr ...
08:04:05 <dankna> :t x
08:04:06 <lambdabot> Expr
08:04:06 <obiwahn> but id say that you cannot compare functions is related to the halting problem:)
08:04:24 <dankna> obiwahn: oh certainly :) we know that it shouldn't work :) but the error message is mystifying to me
08:04:30 <dolio> I don't think it's quite lambdabot specific. Something it imports has the odd instances.
08:04:37 <monochrom> > (\ () -> ()) < (\ () -> ())
08:04:38 <lambdabot>   *Exception: (==): No overloading for function
08:04:38 <b_jonas> obiwahn: in my head, it's related to haskell being a pure language. in an impure language, you can compare functions.
08:04:47 <dolio> The same thing that gives it functions-as-nums.
08:04:56 <b_jonas> though maybe...
08:04:57 <dankna> ahhhh
08:04:58 <rwbarton> > x < x + 1
08:04:59 <lambdabot>   True
08:05:00 <dankna> that would make some sense
08:05:02 <rwbarton> > x < x - 1
08:05:03 <lambdabot>   True
08:05:04 <b_jonas> maybe a pure language could compare functions too
08:05:06 <dolio> > (sin^2 + cos^2) 8
08:05:07 <lambdabot>   1.0
08:05:13 <b_jonas> by recursively comparing their source definitions or something
08:05:20 <dolio> No.
08:05:32 <balta2ar> guys, how do I export a module with qualified name? e.g. http://ix.io/1SS
08:05:32 <monochrom> I think I see. someone wanted Num etc for functions. so they had to add Eq Ord etc
08:05:33 <b_jonas> probably it shouldn't do that though
08:05:42 <dolio> Comparing source breaks the function abstraction.
08:05:55 <b_jonas> monochrom: ah
08:06:01 <monochrom> > (id + 5) 6
08:06:02 <lambdabot>   11
08:06:26 <b_jonas> dolio: we guarantee the function abstractions?
08:06:37 <monochrom> > toRational id
08:06:38 <lambdabot>   No instance for (GHC.Real.Real (a -> a))
08:06:38 <lambdabot>    arising from a use of `GHC.Real...
08:06:40 <dolio> I hope so. It's a good abstraction.
08:06:53 <b_jonas> okay
08:07:37 <b_jonas> (well, seqable function abstraction, I think, but that's a nit)
08:07:43 <monochrom> actually, Num explains Eq only. Real would explain Ord, but functions are not made Real
08:08:15 <monochrom> well, I guess figuring out Eq is good enough. I hate function Num anyway
08:08:47 <dolio> I just hate Num.
08:08:55 <rostayob> @pl \(k, v) -> text k <> colon <+> expr v
08:08:56 <lambdabot> uncurry ((. expr) . (<+>) . (<> colon) . text)
08:09:36 <monochrom> @type (\() -> ()) + 1
08:09:37 <lambdabot>     No instance for (Num ())
08:09:37 <lambdabot>       arising from the literal `1' at <interactive>:1:14
08:09:37 <lambdabot>     Possible fix: add an instance declaration for (Num ())
08:09:42 <monochrom> hehe
08:10:06 <monochrom> @type (\() -> True) + 1
08:10:06 <lambdabot>     No instance for (Num Bool)
08:10:06 <lambdabot>       arising from the literal `1' at <interactive>:1:16
08:10:06 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
08:10:20 <monochrom> @type (\() -> 5) + 1
08:10:20 <lambdabot> forall t. (Num t) => () -> t
08:11:21 <joe6> i have some c code that i want to test. I am thinking of using gdb to run the code and use haskell (Test.HUnit) to control the process. Is that a good idea?
08:11:27 <obiwahn> > compare (\f x -> f x) ((\n f x -> f (n f x)) (\f x ->x)
08:11:28 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:11:29 <joe6> has anyone done anything like that?
08:11:40 <obiwahn> > compare (\f x -> f x) ((\n f x -> f (n f x)) (\f x ->x))
08:11:41 <lambdabot>   *Exception: (==): No overloading for function
08:11:57 <joe6> initially, I built-up haskell bindings for the c code and tried to test them directly by calling the ffi code.
08:12:17 <joe6> but, it appears that to be more flexible if I interface with gdb instead.
08:12:27 <joe6> any thoughts, please?
08:14:32 <monochrom> going through gdb has the advantage of battling with infinite loops in the testee
08:15:27 <joe6> ok, thanks.
08:15:50 <joe6> any suggestions on how to structure such an interface? just some high-level thoughts/advice?
08:17:41 <joe6> uri: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hgdbmi
08:27:05 <dainanaki> Is there a relatively simple ipc library around that's any good?
08:27:58 <obiwahn> > let true = \x y -> x; flase = \ x y -> y; myif = id in myif (true 1 2)
08:27:59 <lambdabot>   1
08:28:06 <obiwahn> > let true = \x y -> x; flase = \ x y -> y; myif = id in myif (false 1 2)
08:28:07 <lambdabot>   Not in scope: `false'
08:28:16 <obiwahn> > let true = \x y -> x; flase = \ x y -> y; myif = id in myif (flase 1 2)
08:28:17 <lambdabot>   2
08:28:30 <b_jonas> dainanaki: what for?
08:29:04 <dainanaki> hrm, actually, I think I just came up with a better way of doing it anyways.
08:29:10 <dainanaki> nevermind.
08:39:04 <obiwahn> fix (\x -> 3)
08:39:07 <obiwahn> > fix (\x -> 3)
08:39:07 <lambdabot>   3
08:39:20 <tgeeky> fix (:3)
08:39:25 <tgeeky> > fix (:3)
08:39:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:39:35 <tgeeky> > fix (\x -> :3)
08:39:36 <lambdabot>   <no location info>: parse error on input `:'
08:39:40 <tgeeky> bah
08:40:08 <obiwahn> > (\x y -> y (x x y)) (\x y -> (x x y)) (\x -> 3)
08:40:09 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
08:40:34 <obiwahn> > (\x y -> y (x x y)) (\x y -> y (x x y)) (\x -> 3)
08:40:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
08:41:24 * benmachine pretty sure that a monomorphic x can never be applied to itself
08:41:35 <erus`> anyone see that new statically typed OO language on /r/programming? i was looking throught the examples thinking "i could write this in a line of haskell and it would be readable"
08:41:59 <erus`> and (s)he was defining classes with iterators in about 10 lines :|
08:42:11 <Entroacceptor> linky?
08:42:49 <elliott> man, there's a new language out and it's /inferior to haskell/? you don't see that every day :P
08:43:55 <obiwahn> b_jonas: what does a pure language mean?
08:45:23 <erus`> oh boy here we go...
08:45:25 <buntfalke> Can someone explain this to me http://hpaste.org/51383 ?
08:45:41 <buntfalke> I dont get how the compile can resolve this recrusion...
08:47:10 <buntfalke> The exact point I'm stuck with is: Why is zs justified by enough spaces in case the first element of the list is the longest?
08:48:07 <obiwahn> where is the recursion?
08:48:51 <rwbarton> besides the recursion in pass there's also the fact that m and pass are mutually recursive
08:49:26 <buntfalke> Yeah, so...?
08:49:55 <rwbarton> but it's ok because only the first element of the result of pass depends on m, and m only depends on things from the second element of pass
08:50:49 <hpc> :t ($) ($) ($)
08:50:50 <lambdabot> forall a b. (a -> b) -> a -> b
08:51:29 <buntfalke> Still: How come zs is aligned with enough spaces?
08:52:00 <buntfalke> If the first element is the longest, m will be larger than n, and no element of zs wil be rjustified by enough spaces, right?
08:52:27 <rwbarton> note that n in the definition of rjustify is shadowed
08:52:38 <rwbarton> and what's passed in is m
08:52:49 <rwbarton> is that the confusion?
08:53:43 <rwbarton> m is going to end up being the maximum length of any element
08:56:46 <buntfalke> rwbarton: Aaahh...thanks!
08:57:34 <qubodup> hi
08:57:53 <qubodup> sfml-audio needs pthreads, even on windows
08:57:56 <qubodup> this seems weird
08:58:39 <monochrom> does sfml-audio support windows even?
08:59:49 <hpaste> buntfalke annotated “ralign” with “ralign (annotation)” at http://hpaste.org/51383#a51390
08:59:50 <monochrom> oh, it seems intended to support windows
09:00:03 <buntfalke> This seems alot clearer :-)
09:00:37 <buntfalke> What's the advantage of writing such an interwoven function?
09:01:08 <monochrom> to ensure that readers like me don't understand
09:01:31 <hpc> buntfalke: that paste is pretty awful, as haskell style goes
09:01:33 <tac-tics> I thought the whole point of writing stuff in haskell was to impress people with your knowledge of well-founded recursion
09:02:00 <tac-tics> recurring between recurrences is pretty impressive to me
09:02:05 <monochrom> no, that will be system f etc
09:02:26 * hackagebot egison 0.4.0.0 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.4.0.0 (SatoshiEgi)
09:02:35 <hpc> lambda calculus is for impressing people with your ability to write lisp without parens
09:02:52 <buntfalke> hpc: Regarding formatting? Or "actual code"?
09:02:56 <monochrom> http://hpaste.org/50940 is my entry :)
09:03:11 <hpc> buntfalke: both, but mostly the first
09:03:22 <obiwahn> mh where do all those cool functions like pass replicatem etc come from
09:03:29 <buntfalke> hpc: What's bad about the latter?
09:03:32 <hpc> f(x,y) is totally defeating the point of haskell
09:03:36 <hpc> and that nested where...
09:03:38 <obiwahn> my ghci does not know about any of them
09:04:06 <obiwahn> and is there an overview of nice functions that should be know?
09:04:24 <obiwahn> known:)
09:04:30 <hpc> obiwahn: import Control.Applicative; import Control.Monad; import Control.Arrow
09:04:35 <monochrom> replicate is in Prelude
09:04:37 <hpc> obiwahn: that's pretty much 90% of the good stuff
09:04:50 <monochrom> pass is defined in the paste
09:05:23 <buntfalke> hpc: Well, rjustify doesnt have to have a tupel as a parameter, but as for pass, it's not that simple to expess it -- in that way -- without using one, I'd say
09:05:35 <obiwahn> do i put that as it is in the top of my hs files? and in the ghcirc
09:06:12 <monochrom> maybe both
09:06:30 <hpaste> buntfalke annotated “ralign” with “ralign (annotation) (annotation)” at http://hpaste.org/51383#a51391
09:06:35 * roconnor thinks rjustify should be floated out one level since it's first parameter, n, is constantly m.
09:06:38 <hpc> obiwahn: i personally would ghci file.hs
09:06:53 <hpc> obiwahn: and edit the file, then :r when i make changes
09:06:57 <BrianHV> at the risk of being somewhat off topic, I'm trying to follow the haskell records discussion on reddit, but can't figure out a good way to view the newest comments. sorting by new only sorts root comments. anyone know any reddit tricks for that?
09:07:54 <rostayob> is it possible to nest relatively to the beginning of the current line in pretty?
09:07:58 <roconnor> @type (***)
09:07:59 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:08:01 <tac-tics> BrianHV: Sorted by "new"
09:08:22 <BrianHV> tac-tics: as I mentioned, that seems to only sort the root comments. responses still seem to get buried.
09:08:30 <tac-tics> ah
09:08:42 <tac-tics> well, that's reddit for you X-|
09:08:53 <hpaste> roconnor annotated “ralign” with “floating out rjustify” at http://hpaste.org/51383#a51392
09:09:34 <roconnor> oops
09:09:48 <roconnor> I think I went too far
09:09:57 <rwbarton> needs more \x ->
09:10:02 <roconnor> ya
09:10:07 <buntfalke> roconnor: whats ***?
09:10:22 <rwbarton> @pl \x -> (rjustify x :) *** (max (length x)
09:10:22 <lambdabot> (line 1, column 41):
09:10:22 <lambdabot> unexpected end of input
09:10:22 <lambdabot> expecting variable, "(", operator or ")"
09:10:23 <hpc> > (succ *** id) (1, 3)
09:10:24 <lambdabot>   (2,3)
09:10:27 <hpc> > (succ *** id) (1, 1)
09:10:28 <lambdabot>   (2,1)
09:10:31 <obiwahn> how do i dsable the module list in the ghci promt? google is not very helpful:(
09:10:34 <rwbarton> @pl \x -> (rjustify x :) *** (max (length x))
09:10:34 <lambdabot> ap ((***) . (:) . rjustify) (max . length)
09:10:35 <hpc> > (succ *** id) (1.5, "bacon")
09:10:36 <lambdabot>   (2.5,"bacon")
09:10:46 <hpc> buntfalke: ^^
09:11:11 <monochrom> I agree with tac-tics. that's reddit for you, generally that's web forums for you. in the usenet world, client-side software already tracks which posts you have read and which posts you haven't read.
09:11:16 <hpc> obiwahn: :set prompt ghci>
09:11:21 <hpc> or something like that
09:12:40 <tac-tics> Reddit was based on a technique that allowed you to reduce the standard O(n) time for a circlejerk or flamewar to break out on an internet form to O(1)
09:12:46 <hpaste> roconnor annotated “ralign” with “floating out rjustify (annotation)” at http://hpaste.org/51383#a51393
09:13:29 <roconnor> a better name than f should be used
09:14:41 <buntfalke> hpc: it applies two functions to the element found at their respective position in a tupel?
09:14:52 <buntfalke> does it have a name?
09:15:10 <hpc> buntfalke: probably, but i don't know it
09:15:23 <roconnor> (*** id) is not the clearest way to illustrate *** :)
09:16:25 <roconnor> this ralign function is a nice example of tying-the-knot
09:19:34 <buntfalke> What does "tying the knot" mean in this context?
09:20:19 <buntfalke> "to marry"?!
09:20:42 <buntfalke> Why would the ralign with pass be faster than the 2nd one I pasted?
09:21:12 <Eduard_Munteanu> Not sure of the context, but it usually means a general technique of creating
09:22:21 <Eduard_Munteanu> ... self-referential data structures in lazy languages.
09:22:40 <Eduard_Munteanu> An example would be implementing doubly-linked lists using fix.
09:23:37 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/Tying_the_Knot
09:24:36 <buntfalke> Yes, just noticed. didnt really expect a haskell.org entry on that, rather thought it be a fixed expression in English neither me nor my dictionary were aware of :-)
09:24:39 <buntfalke> thanks Eduard_Munteanu
09:24:42 <c_wraith> fix isn't necessary for knot-tying
09:24:52 <c_wraith> > let tied = 1 : tied in tied
09:24:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
09:25:15 <c_wraith> That creates a linked list by tying the knot
09:25:25 <roconnor> buntfalke: the one with pass may be faster because it processes each cons constructor only once ... onceish
09:25:51 <roconnor> buntfalke: actually I find it plausible that they run in about the same speed
09:26:14 <Eduard_Munteanu> Fix, or more generally recursion, yeah.
09:27:28 <Eduard_Munteanu> Usually, when people say knot-tying, they refer to interesting stuff that's a bit less obvious to wrap your head around.
09:27:42 <Eduard_Munteanu> I guess.
09:27:44 <tac-tics> A marriage of ideas*
09:27:49 <buntfalke> roconnor: same speed because of the recrusion-overhead?
09:27:56 <buntfalke> roconnor: But "
09:28:09 <buntfalke> roconnor: But "cons only once" might be the idea of it, thanks.
09:31:07 <roconnor> ya, the only place I really see potential savings is that each cons cell only needs to be pattern matched once, instead of twice.
09:31:26 <roconnor> But I don't really know how much overhead this will save.
09:31:36 <roconnor> It doesn't seem like it would be very much.
09:33:31 <friggle> I apologise if this isn't the right place to ask, but I'm trying to cabal install gitit and am running out of memory on my VPS at the linking stage (512MB ram and 256MB swap). Is there anything I can do?
09:34:11 <Saizan> you could try using the gold linker
09:34:14 <Eduard_Munteanu> friggle: maybe you could compile it on another machine?
09:34:21 <ClaudiusMaximus> friggle: try gold instead of ld (on debian it's aptitude install binutils-gold  if i remember correctly)
09:34:43 <c_wraith> when does gold become the default linker?
09:34:48 <jca1981> Is haskell any good at web mining?
09:34:56 <ClaudiusMaximus> c_wraith: when you install it, debian alternatives/diversions mechanism
09:35:04 <c_wraith> x.org took over from xfree86 really fast
09:35:10 <friggle> Eduard_Munteanu: the VPS is 10.04 and I think I only have access to 10.10/11.04. Might not be an issue though
09:35:14 <friggle> ClaudiusMaximus: I'll give that a go, thanks
09:35:30 <ClaudiusMaximus> c_wraith: oh you mean in general.  i don't know, maybe when it supports enough architectures/formats
09:35:39 <Eduard_Munteanu> Doesn't cabal install generate static binaries anyway?
09:35:52 <Eduard_Munteanu> (or just plain ghc --make ?)
09:36:09 <c_wraith> yes.  but ld is what combines all the object files into a static binary
09:36:10 <Eduard_Munteanu> by default
09:36:13 <c_wraith> and does it poorly. :P
09:36:20 <Eduard_Munteanu> Ah.
09:36:39 <c_wraith> (also, ghc creates many more object files than you have modules)
09:36:44 <ClaudiusMaximus> disabling splitobjs may help too, i've heard
09:37:23 <koeien> jca1981: there are curl bindings afaik
09:37:46 <ClaudiusMaximus> i had some problems with gold when trying to compile/link ghc with it, some weird issue with different path defaults for linker scripts
09:38:19 * Eduard_Munteanu wonders if the linker script issues have been solved
09:38:42 <Eduard_Munteanu> I mean, opening such .so's at runtime.
09:38:53 <friggle> binutils-gold does the trick, thanks!
09:39:00 <c_wraith> koeien, jca1981: the curl bindings are not especially good, though.  I got a lot of segfaults out of them when using multiple threads and ssl
09:39:02 <parcs> Eduard_Munteanu: with dlopen? nope
09:39:11 <Eduard_Munteanu> Yeah, I know dlopen() can't handle them.
09:39:22 <Eduard_Munteanu> (which is a bit strange)
09:39:24 * ClaudiusMaximus also wonders about the libstc++ issue - i changed one package to link to it explicitly because someone had problems, but then i noticed that it caused problems with ghci
09:39:28 <friggle> I didn't realise it was better with memory too, though I've made a lot of use of its speed boost for building llvm/clang
09:39:38 <c_wraith> ClaudiusMaximus: supposedly, that will be fixed in 7.4
09:39:50 <Eduard_Munteanu> I actually thought this was a GHC problem, I couldn't believe dlopen() didn't work :)
09:41:51 <ClaudiusMaximus> c_wraith: right; but i don't know whether this package should be linking to libstdc++ at all - it links to the C abi of a library that internally uses C++
09:42:06 <c_wraith> ClaudiusMaximus: oh.  that's a good point.
09:43:00 <ClaudiusMaximus> c_wraith: i think one distro might have had bugs in its packaging of the upstream library
09:43:18 * ClaudiusMaximus needs to recheck the emails - was quite some time ago..
09:47:41 <obiwahn> Cale?!
09:51:25 <buntfalke> Not in scope: `***' <-- I can't find any reference to ***, how do I get it?
09:51:42 <alpounet> buntfalke, import Control.Arrow
09:51:45 <alpounet> @index (***)
09:51:45 <lambdabot> Control.Arrow
09:52:23 <wavewave> hi..
09:52:27 <byorgey> @hoogle ***
09:52:28 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
09:52:35 <byorgey> buntfalke: hoogle is your friend
09:52:36 <wavewave> how can cabal detect system architecture?
09:52:53 <byorgey> buntfalke: also see haskell.org/hoogle
09:53:03 <buntfalke> Hoogle. okay.
09:53:14 <dcoutts> wavewave: it relies on ghc knowing, via System.Info
09:53:27 <wavewave> dcoutts: thanks!
09:53:49 <buntfalke> 'Cause +"***" in google / haskel.org search field is pretty much useless
09:54:20 <Cale> http://www.haskell.org/hoogle/?hoogle=***
09:54:20 <wavewave> dcoutts: is there a convenience function in Cabal package if cabal already detected the architecture?
09:54:26 <Eduard_Munteanu> Hoogle can also search for functions matching types.
09:54:36 <ClaudiusMaximus> > 1700 / 70
09:54:37 <lambdabot>   24.285714285714285
09:54:46 <tac-tics> > 22 / 7
09:54:47 <lambdabot>   3.142857142857143
09:54:53 <Eduard_Munteanu> @hoogle f (t a) -> t (f a)
09:54:53 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
09:54:53 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:54:53 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:56:29 <wavewave> dcoutts: never mind. it seems that System.Info is simple enough.. I am writing a custom Setup.lhs for a package..
09:58:17 <dcoutts> wavewave: oh, in that case you want to use the Distribution.Platform.os / .arch which uses enumerations and are easier to work with
09:58:59 <dcoutts> wavewave: erm, sorry, Distribution.System and it's buildOS / buildArch
09:59:40 <wavewave> dcoutts: AHA... Great! thanks.
10:02:56 <Reaganomicon> What's the function that applies a function n times? I thought it was called repeat, but apparently not. Hoogle isn't giving me anything useful either. :(
10:03:13 <Peaker> Reaganomicon: iterate f x !! n
10:03:20 <Reaganomicon> Cheers
10:05:19 <ClaudiusMaximus> may cause problems for large n; if f is strict it might be better to use iterate' f !x = x : iterate' f (f x)
10:05:31 <Reaganomicon> That creates a list though. Does lazy magic kick in if I only care about the last one?
10:05:50 <monu> how can i make a program in haskell
10:06:03 <mauke> monu: write code; compile
10:06:37 <monu> coding syntax
10:07:15 <ksf> so... wrapping up some reddit discussion, is anyone of you paper-generating geeks willing to design a record system solving all three of namespacing, lensing and extensibility at the same time?
10:07:48 <ClaudiusMaximus> as i understand it, the list is consumed by !! at the same rate as iterate generates it, so the list is ephemeral - the difference between iterate and iterate' is that iterate builds up a thunk with f(f(f...(f x)...)) whereas iterate' applies f as it goes (from "inside" out)
10:07:59 <mauke> monu: learn haskell
10:09:10 <monu> ok
10:09:10 <Reaganomicon> ClaudiusMaximus: Ah, ok. I'm still wary of Haskell's arcane ways. :(
10:09:46 <buntfalke> roconnor: Are you sure the pass-ralign evaluates every cons just once?
10:10:04 <ClaudiusMaximus> > iterate (const 1) 2 !! 1000000
10:10:05 <lambdabot>   1
10:10:11 <ClaudiusMaximus> > iterate (subtract 1) 2 !! 1000000
10:10:12 <lambdabot>   *Exception: stack overflow
10:10:13 <monochrom> @where lyah
10:10:13 <lambdabot> http://www.learnyouahaskell.com/
10:10:45 <monochrom> http://www.learnyouahaskell.com/ is a good online book on haskell. you can also buy a paper one
10:10:46 <buntfalke> roconnor: I call ralign ["abc", "x"], so it recurrs down in where, to find m -- how come the calls '
10:10:52 <ClaudiusMaximus> > let iterate' f x = x `seq` (x : iterate' f (f x)) in iterate' (subtract 1) 2 !! 1000000
10:10:53 <lambdabot>   -999998
10:11:52 <Reaganomicon> monochrom: You tree killer. >:|
10:12:04 <buntfalke> roconnor: ...the calls pass ["x"] and pass [] aren't done twice, how come the functions aren't "opened" twice: once to satisfy the search for m in the initial rjustify(m,"abc") and once to satisfy the need for all the zs?
10:12:17 <monochrom> I haven't killed trees for a while
10:12:34 <monochrom> except daily use of toilet paper
10:17:09 <obiwahn> Cale: yeahy you are here at last:)
10:17:32 <obiwahn> i can not get the lamdabot running
10:18:14 <obiwahn> Plugin `offlinerc' failed with: passwd.rc: openFile: does not exist (No such file or directory) that does not seem to matter much
10:18:49 <obiwahn> > 4+5
10:18:49 <lambdabot>   9
10:18:50 <obiwahn> 20:11 < hbot>   mueval: Most RTS options are disabled. Link with -rtsopts to enable them.
10:19:07 <buntfalke> http://hpaste.org/51393 <-- Why won't this call f (2*length xs) times? once to evaluate m as lazy as possible, and hence close the f-call again without caring for the first element of the tuple, and a 2nd run for said first element...
10:21:14 <obiwahn> ["-E","-XBangPatterns","-XNoMonomorphismRestriction","-XViewPatterns","--no-imports","-l","~/.lambdabot/State/L.hs","--expression=4+5","+RTS","-N2","-RTS"]
10:21:36 <roconnor> buntfalke: it will more or less traverse the list twice
10:21:40 <roconnor> I think
10:21:50 <Cale> buntfalke: what?
10:22:12 <Cale> buntfalke: foldr f ... xs  will only ever apply f as many times as there are elements of f
10:22:15 <Cale> er, of xs
10:22:18 <roconnor> buntfalke: this example makes clear that the order of evalutation is not at all the order of the call structure of your code.
10:22:27 <Cale> > foldr f z [1,2,3,4,5]
10:22:28 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
10:22:32 <Cale> ^^ it evaluates to that
10:22:41 <Cale> see?
10:22:55 <roconnor> Cale: buntfalke's example has knot-tying confusion
10:22:58 <Cale> foldr f z replaces each (:) in the list with f and the [] at the end with z
10:24:15 <Cale> I don't understand :)
10:24:20 <Phyx-> is there a tool that can generate Arbitrary instances from a datatype?
10:24:24 <buntfalke> Cale: You will if you look at the example ;-)
10:24:28 <buntfalke> Cale: make it more specific
10:24:32 <elliott> Phyx-: syb?
10:24:34 <Cale> I did look...
10:24:41 <elliott> you might be able to write a garbitrary
10:24:55 <Phyx-> elliott: the problem is with recursive types,
10:25:01 <Phyx-> it would potentially never stop
10:25:07 <Cale> (ys, m) = foldr f ([],0) xs
10:25:21 <Cale> There's no way that applies f more than length xs times.
10:25:22 <elliott> Phyx-: weeell... you could keep a manual stack of seen types :P
10:25:25 <elliott> it'd be really ugly though
10:25:36 <Cale> and that's the only place where f is used
10:25:43 <Cale> so f must be called exactly length xs times
10:25:45 <roconnor> Cale: the m is used in rjustify which is in turn used in f
10:25:52 <Cale> Who cares?
10:26:04 <Cale> That doesn't change how many times f is used
10:26:17 <Phyx-> elliott: well, I've already started making one that works by creating a directed graph of types in the datatype and some extra annotation, but i was just wondering before i write all this code if it already existed
10:26:25 <buntfalke> Cale: Think lazy, and explain why the function call should stay open
10:26:40 <Cale> What's a function call?
10:26:46 <elliott> Phyx-: sounds cool
10:26:53 <Cale> (and what does it mean for one of those to be open?)
10:26:58 <roconnor> well in lazy langauges there are no "function calls" in any way that is like function calls in a strict langauge
10:27:18 <Cale> My mental model is graph reduction
10:27:39 <Cale> Evaluating the program is rewriting a graph over and over.
10:27:47 <buntfalke> Cale: Which rjustify will be evaluated first if xs = ["abc", "x"]?
10:27:51 <Cale> (an expression graph)
10:28:45 <buntfalke> as in, which side of the : operator is evaluated first?
10:28:57 <roconnor> buntfalke: it depends on what part of (ralign xs) is demanded
10:29:27 <koeien> for example, if you print a list to the screen in order, the head will be evaluated first
10:29:29 <Cale> ralign ["abc", "x"] = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in foldr f ([],0) xs } in ys
10:29:30 <buntfalke> I call "putStrLn $ show $ ralign ["abc","x"]"
10:29:31 <obiwahn> Cale: would you help me to get the hbot running?
10:30:10 <Cale> oh, derp, forgot to sub in xs :)
10:30:27 <Cale> ralign ["abc", "x"]
10:30:30 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in foldr f ([],0) ["abc",x"] } in ys
10:30:57 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in f "abc" (foldr f ([],0) ["x"]) } in ys
10:32:22 <Cale> Now we have to reduce foldr f ([],0) ["x"] again, because f needs to pattern match the pair in its second parameter
10:32:38 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in f "abc" (f "x" (foldr f ([],0) [])) } in ys
10:32:47 <Cale> and then again, for the same reason
10:33:06 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in f "abc" (f "x" ([],0)) } in ys
10:33:20 <Cale> and now we can evaluate f "x" ([],0)
10:33:21 <roconnor> Cale: f returns a pair without question
10:33:45 * buntfalke reformats locally to multiline for readability
10:33:51 <roconnor> Cale: oh wait you are right
10:33:55 <roconnor> Nevermind
10:34:00 <Cale> f x p = case p of (zs,n) -> (rjustify x : zs, max (length x) n)
10:34:07 <Cale> it's a case expression really
10:34:08 <roconnor> stupid non-lazy tuples
10:35:04 <TheLemonMan> 'evening
10:35:33 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in f "abc" (rjustify "x" : [], max (length "x") 0) } in ys
10:35:44 <Cale> and now the outer f can pattern match
10:36:39 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in (rjustify "abc" : rjustify "x" : [], max (length "abc") (max (length "x") 0)) } in ys
10:37:20 <Cale> and now finally ys is in the form of a list
10:37:36 <leod> may i ask what's happening here?
10:37:39 <Cale> So we can start to evaluate its first element if we wish
10:37:52 <Cale> I'm evaluating a program of buntfalke's by hand
10:38:01 <leod> oh, ok
10:38:17 * buntfalke still reads
10:38:31 <benmachine> known haskell interpreters: ghci, hugs, cale
10:38:36 <Cale> and I'm doing it as closely as possible to how the machine would do it (except keeping it in Haskell syntax)
10:38:53 <leod> sounds fun
10:40:37 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ((replicate (m - length "abc") ' ' ++ "abc") : rjustify "x" : [], max (length "abc") (max (length "x") 0)) } in ys
10:40:39 <obiwahn> let and recursice stuff gets ugly :P
10:40:44 <Cale> yes?
10:42:28 <Cale> and then to evaluate the ++, we need to pattern match the left argument, and to evaluate the replicate, we need to evaluate the first argument of that (because it's pattern matching that to see if 0)
10:42:34 * hackagebot numerals-base 0.3 - Convert numbers to number words  http://hackage.haskell.org/package/numerals-base-0.3 (RoelVanDijk)
10:42:47 <Cale> and to evaluate the (-), we need to evaluate m
10:43:30 <Cale> and of course max here is strict as well
10:43:44 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in (rjustify "abc" : rjustify "x" : [], max (length "abc") (max 1 0)) } in ys
10:43:49 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in (rjustify "abc" : rjustify "x" : [], max (length "abc") 1) } in ys
10:43:59 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in (rjustify "abc" : rjustify "x" : [], max 3 1) } in ys
10:44:03 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in (rjustify "abc" : rjustify "x" : [], 3) } in ys
10:44:27 <Cale> oops!
10:44:38 <Cale> I de-evaluated the rjustify "abc" by accident there
10:44:55 <Cale> (picked the wrong line from scrollback :P)
10:45:13 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ((replicate (m - length "abc") ' ' ++ "abc") : rjustify "x" : [], 3) } in ys
10:45:23 <Cale> so, just put that back how it really was :)
10:45:47 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ((replicate (m - 3) ' ' ++ "abc") : rjustify "x" : [], 3) } in ys
10:45:58 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ((replicate 0 ' ' ++ "abc") : rjustify "x" : [], 3) } in ys
10:46:05 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in (([] ++ "abc") : rjustify "x" : [], 3) } in ys
10:46:12 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : rjustify "x" : [], 3) } in ys
10:46:22 <Cale> whee! the first element of ys has become available
10:46:28 <Cale> and will be printed
10:47:21 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : (replicate (m - length "x") ' ' ++ "x") : [], 3) } in ys
10:47:29 <Cale> so we go to work on the second element
10:47:36 * hackagebot numerals 0.3 - Convert numbers to number words  http://hackage.haskell.org/package/numerals-0.3 (RoelVanDijk)
10:47:43 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : (replicate (m - 1) ' ' ++ "x") : [], 3) } in ys
10:47:48 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : (replicate 2 ' ' ++ "x") : [], 3) } in ys
10:48:10 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : ((' ' : replicate 1 ' ') ++ "x") : [], 3) } in ys
10:48:22 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : ((' ' : ' ' : replicate 0 ' ') ++ "x") : [], 3) } in ys
10:48:27 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : ((' ' : ' ' : []) ++ "x") : [], 3) } in ys
10:49:13 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : (' ' : ((' ' : []) ++ "x")) : [], 3) } in ys
10:49:27 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : (' ' : ' ' : ([] ++ "x")) : [], 3) } in ys
10:49:37 <Cale> = let { rjustify s = replicate (m - length s) ' ' ++ s; (ys,m) = let { f x (zs,n) = (rjustify x : zs, max (length x) n)} in ("abc" : (' ' : ' ' : "x") : [], 3) } in ys
10:49:51 <Cale> and now it's fully evaluated
10:50:05 <Cale> various things will have become garbage along the way there
10:50:27 <Cale> we could have discarded the definition of f after subbing it in the last time
10:50:31 <Cale> and then rjustify
10:50:37 <Cale> (probably should have done that)
10:51:26 * buntfalke still reads along (fell back ~10mins worth of lines meanwhile) (thanks Cale!)
10:51:38 <erus`> has anyone tried frege yet?
10:51:47 <erus`> (haskell type language on the jvm)
10:53:23 <parcs> i tried to build it from svn but the makefile is malformed
10:54:05 <obiwahn> Cale: will you help me with the lambdabot?
10:54:41 <Cale> obiwahn: I guess...
10:55:10 <Cale> obiwahn: I haven't run into the problem you're having before.
10:55:37 <obiwahn> mayby you know how to pass hgc via cable linker options:)
10:55:48 <obiwahn> cabal
10:57:57 <Cale> Um, there's some syntax in the .cabal file for that
10:58:31 <mm_freak_> what's the preferred way to generate cryptographically strong random numbers?
10:58:35 <Cale> ghc-options: -lwhatever
10:59:11 <obiwahn> should ghc-options be in .cabal/config?
11:00:05 <benmachine> obiwahn: no, in lambdabot.cabal
11:02:01 <obiwahn> mh where should that file be? i habe installed everything via cabal in d .cabal/packages/hack.../mueval/there is only a tar.gz
11:02:28 <hpaste> Cale pasted “Evaluation!” at http://hpaste.org/51395
11:03:15 <Cale> obiwahn: unpack that
11:03:21 <Cale> or cabal fetch mueval
11:03:26 <benmachine> wait
11:03:37 <benmachine> what linker optionsa are you trying to pass to what
11:03:51 <Cale> I don't know :)
11:03:53 <ClaudiusMaximus> -rtsopts to mueval executable afaik
11:04:13 <Cale> Ah, not quite a linker option
11:04:24 <obiwahn> mueval: Most RTS options are disabled. Link with -rtsopts to enable them. wo iguess i nedd -with-rtsopts
11:04:54 <kmc> it's -rtsopts and it's a compile-time option
11:04:55 <Cale> obiwahn: mueval.cabal just needs ghc-options: -rtsopts
11:05:15 <Cale> obiwahn: You may want to know that the lambdabot that I'm running is on GHC 6.12.3
11:05:30 <Cale> So I haven't had to deal with updating anything
11:05:30 <obiwahn> where should that file be located?
11:05:37 <Cale> obiwahn: inside the mueval package
11:06:10 <Cale> cabal fetch mueval
11:06:17 <Cale> cd mueval-*
11:06:18 <obiwahn> will cabal use the unpacked stuff or check a hashsum?
11:06:23 <buntfalke> Cale: How do you know to evaluate the right side of a (-) first? (still reading... :-))
11:06:34 <Cale> buntfalke: oh, did I do that?
11:06:51 <Cale> buntfalke: It doesn't really matter, both args to (-) have to be evaluated for it to proceed
11:06:52 <buntfalke> in (m - length "x") you evaluate to (m -1)
11:06:56 <obiwahn> No packages need to be fetched....
11:07:10 <buntfalke> Cale: True, but for the sake of it, would m be first?
11:07:20 <Cale> Really, it's up to the compiler
11:07:32 <buntfalke> Okay :-)
11:07:35 <Cale> The compiler reorders a lot of stuff, and my ordering is not necessarily accurate
11:07:52 <TheLemonMan> mmh, where can i find a explanation of the just keyword ?
11:07:53 <Cale> I tried to be a lazy evaluator, but I wasn't careful about the order of arguments.
11:08:17 <Cale> TheLemonMan: just isn't a keyword
11:08:44 <koeien> Just is a data constructor. It's written with a capital.
11:08:49 <koeien> @src Maybe
11:08:49 <lambdabot> data Maybe a = Nothing | Just a
11:08:50 <shachaf> Cale: I think "just" was used as an adjective there.
11:09:04 <obiwahn> aah:)
11:09:34 <shachaf> Clearly the most just of all keywords is forall.
11:09:37 <TheLemonMan> what's the use of just ?
11:09:41 <koeien> this means, a value of type Maybe a, is either Nothing, or Just x, where x is of type a
11:09:53 <danr> There is a just keyword? oO
11:09:56 <obiwahn> mh no
11:10:01 <kmc> nope
11:10:04 <Cale> TheLemonMan: Do you mean Just?
11:10:13 <Cale> (with a capital J)
11:10:25 <TheLemonMan> yes, didn't know that you were so nazi about capitals :)
11:10:28 <Cale> Just :: a -> Maybe a
11:10:36 <Cale> Nothing :: Maybe a
11:10:39 <koeien> TheLemonMan: well, it's actually important in Haskell.
11:10:40 <saati> TheLemonMan: haskell cares about capitals
11:10:40 <benmachine> TheLemonMan: case is important in, well, most programming langauges
11:10:43 <obiwahn> Cale: i have untared the mueval tgz, cahnged the file and cabal install mueval.cabal
11:10:58 <Cale> The values of type Maybe t are the constant Nothing
11:11:01 <koeien> TheLemonMan: you cannot name a variable with a capital.
11:11:03 <obiwahn> must i rebuild the bot as well?
11:11:05 <Cale> and Just x whenever x is of type t
11:11:16 <kmc> @where keywords
11:11:16 <lambdabot> case class data default deriving do else foreign if import in infix infixl infixr instance let module newtype of then type where _
11:11:32 <benmachine> obiwahn: no, that shouldn't be necessary
11:11:34 * mike-burns tries to picture a Nazi about capitals, still thinks it's too soon.
11:11:46 <koeien> TheLemonMan: you might have noticed that all types in Haskell (Integer, Int, String) are starting with a capital
11:11:48 <kmc> @where reserved_symbols
11:11:48 <lambdabot> .. : :: = \ | <- -> @ ~ =>
11:11:50 <Cale> TheLemonMan: You can use Maybe to indicate potential failure or absence of a value
11:12:06 <kmc> 'default' is the one which really bugs me
11:12:15 <Cale> TheLemonMan: Values starting with a capital letter are data constructors which can be pattern matched on
11:12:35 <TheLemonMan> so it's basically for error checking purposes
11:12:51 <kmc> TheLemonMan, it's just a simple data structure; it's useful for a lot of different things
11:13:01 <obiwahn> benmachine: is there something like make clean?
11:13:06 <TheLemonMan> Just defines a variable as non-nullable and the compiler warns about potential failures ?
11:13:06 <obiwahn> distclean?
11:13:08 <koeien> obiwahn: cabal clean
11:13:08 <benmachine> obiwahn: cabal clean?
11:13:13 <kmc> rm -r dist/
11:13:16 <ClaudiusMaximus> > let mdo = 42 ; rec = 123 ; proc = 999 in (mdo, rec, proc)
11:13:17 <lambdabot>   <no location info>: Empty 'do' construct
11:13:23 <koeien> TheLemonMan: no.
11:13:49 <Cale> TheLemonMan: You can think of Maybe a as being similar to [a], except that there are only ever 0 or 1 elements. The 0 element case is indicated by Nothing, and the one element case is Just x
11:13:53 <mike-burns> > Just 1
11:13:54 <lambdabot>   Just 1
11:13:56 <koeien> > Nothing :: Maybe Integer
11:13:57 <lambdabot>   Nothing
11:13:57 <mike-burns> It makes that.
11:14:01 <koeien> > Just 10 :: Maybe Integer
11:14:02 <monochrom> you write your own code to detect "am I receiving Nothing" and deal with it
11:14:02 <lambdabot>   Just 10
11:14:17 <mike-burns> It's a data constructor. It makes data.
11:14:22 <Cale> > lookup 3 [(1, "hello"), (2, "there"), (3, "world")]
11:14:23 <lambdabot>   Just "world"
11:14:26 <Cale> > lookup 7 [(1, "hello"), (2, "there"), (3, "world")]
11:14:27 <lambdabot>   Nothing
11:14:35 <mike-burns> Keep your imagination in check with regards to what else Just does.
11:14:38 <shachaf> default is a weird keyword.
11:14:40 <buntfalke> Cale: How come you do []++"x" first, instead of first evaluating the inside of (' ' : ' ' : []) to "  "?
11:14:45 <Cale> > case lookup 7 [(1, "hello"), (2, "there"), (3, "world")] of Nothing -> "oops!"; Just x -> x
11:14:46 <lambdabot>   "oops!"
11:14:48 <kmc> yeah, that was just Haskell keywords... I'm not even going to try to list all the things considered keywords by some version of GHC with some particular options
11:14:54 <djahandarie> TheLemonMan, let's make a type...   data People = Bob | Alice | Joe    so, the type   People   only has values Bob, Alice and Joe.   However, the type   Maybe People  has Just Bob, Just Alice, Just Joe, and Nothing.
11:14:55 <shachaf> Is it *only* for Num?
11:14:58 <buntfalke> Cale: that happens right after you evaluated replicate 0 ' '
11:15:19 <hpc> shachaf: you are better off pretending default didn't exist
11:15:31 <shachaf> hpc: That's what I've done up until today.
11:15:34 <koeien> I *never* used it (the default keyword)
11:15:39 <Cale> buntfalke: Well, that's not real evaluation
11:15:44 <hpc> shachaf: now you have to try harder :P
11:15:44 <djahandarie> TheLemonMan, so it basically just a new type based on your old one, which also adds the 'Nothing' value in the type.
11:15:52 * shachaf knew vaguely what it did but had to look up how it's used.
11:15:55 <kmc> defaulting is a stupid feature, but you have to use the "default" keyword to turn it off
11:15:58 <Cale> "   " is syntax sugar for ' ' : (' ' : (' ' : []))
11:16:06 <koeien> @src lookup
11:16:07 <lambdabot> lookup _key []          =  Nothing
11:16:07 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
11:16:07 <lambdabot>                         | otherwise = lookup key xys
11:16:12 <benmachine> kmc: or -fwarn-defaulting -Werror :)
11:16:17 <kmc> hehe
11:16:55 <monochrom> yes, "default" is for Num only
11:17:29 <buntfalke> Cale: What do you mean by that? What would the compiler have done? You do some shifting of braces there which dont alter sematics, but still look "too human-like as fo match the algorithm" :-P
11:17:47 <TheLemonMan> what if i do let (Just var) = <value> ?
11:17:50 <Cale> buntfalke: what did I do?
11:17:58 <Cale> buntfalke: Which line are you talking about
11:18:11 <TheLemonMan> i presume i define it to be everything but Nothing, right ?
11:18:38 <Cale> oh, I lost a line in my paste :P
11:18:39 <monochrom> "let (Just var) = <value>" is rare
11:18:44 <saati> Just var is Just var, i don't think you can define it to something else
11:18:47 <hpc> TheLemonMan: 'let' is a very different way of pattern-matching than function patterns
11:19:00 <BobFunk> running into some weird problem with Monad Control
11:19:01 <BobFunk> https://gist.github.com/1220176
11:19:01 <shachaf> monochrom: I know someone who does it pretty frequently, for the sake of getting more helpful error messages than fromJust's.
11:19:05 <Cale> buntfalke: (x:xs) ++ ys = x : (xs ++ ys)
11:19:05 <koeien> TheLemonMan: what happens is, as soon as you the value of  var is needed, value will be evaluated. if it matches Just ..., then var has the value "inside" the Just. Otherwise, a run-time error occurs
11:19:09 <buntfalke> ((' ' : ' ' : replicate 0 ' ') ++ "x") --> still clear --> ((' ' : ' ' : []) ++ "x") --> not clear anymore --> (' ' : ((' ' : []) ++ "x"))
11:19:15 <BobFunk> any ideas?
11:19:20 <hpc> > let f (Just v) = v in f (Just 5)
11:19:21 <lambdabot>   5
11:19:29 <hpc> > let (Just v) = (Just 5) in v
11:19:29 <lambdabot>   5
11:19:36 <hpc> > let (Just v) = Nothing in v
11:19:37 <lambdabot>   *Exception: <interactive>:3:4-21: Irrefutable pattern failed for pattern (D...
11:19:38 <Cale> buntfalke: (x:xs) ++ ys = x : (xs ++ ys)
11:19:44 <Cale> that's the rule I applied
11:19:54 <buntfalke> Cale: Why is that?
11:19:55 <Cale> It's part of the definition of (++)
11:20:11 <Cale> and (++) is the outermost non-dataconstructor function left to apply there
11:20:34 <buntfalke> Why not (x:xs) ++ ys = [x,xs] ++ ys
11:20:40 <Cale> what?
11:20:44 <Cale> That doesn't typecheck
11:20:53 <koeien> [x,xs] = x:xs:[]
11:20:55 <monochrom> there is something wrong with the bigger design if you have to do "fromJust" or "let Just v = expr" frequently
11:21:30 <shachaf> monochrom: Well, true.
11:21:37 <shachaf> I meant relatively frequently.
11:22:07 <c_wraith> monochrom: LANGUAGE TrustMeImAgda
11:22:48 <monochrom> the same bigger design problem as "why are you doing the schemish if null x then ... else f (car x) (cdr x)" when you can just case it
11:22:53 <obiwahn> when i use cabal install --reinstall mueval.cabal in the dir of the mueval downlaod will it then install from that dir? guess nothing is happening really
11:23:17 <benmachine> one common case is
11:23:26 <benmachine> let Just x = lookup k infiniteList
11:23:27 <obiwahn> is see in the bots stdout something like +RTS -N2 -RTS
11:23:33 <buntfalke> Cale: ++ is the outermost which is left, but then why not evaluate it's left parameter (' ' : ' ' : []) to a single element first so we can apply ++ to that?
11:23:42 <buntfalke> eval. to "  "?
11:23:50 <Cale> ' ' : ' ' : [] is fully evaluated
11:24:03 <koeien> buntfalke: "  " and ' ': ' ':[] is *exactly* the same. the former is syntactic sugar for the latter.
11:24:06 <buntfalke> oh strings are lists....
11:24:08 <buntfalke> yes...
11:24:09 <Cale> and "  " is literally the same thing as it
11:24:13 <buntfalke> *facepalm*
11:24:24 <koeien> buntfalke: since it would be painful to write 'H':'e':'l':'l':'o':[]
11:24:46 <monochrom> well, that's a common use among rare uses, sure, i.e., P(let Just x = lookup k infiniteList | let Just x = expr) = 0.7, sure, but P(let Just x = expr) = 0.05
11:25:26 <Cale> buntfalke: Moreover, if "  " and ' ' : (' ' : []) were two separate things, the former would have to evaluate to the latter for (++)'s sake
11:25:30 <monochrom> or at least P(let Just x = expr | you really need it) = 0.05
11:25:36 <Cale> buntfalke: so that it could pattern match (x:xs) against it
11:27:32 <parcs> has anyone successfully installed the xhtml package with ghc 7.2?
11:27:37 <b_jonas> come on, it's not so obvious because for example in standard ML, strings are IArrays of characters
11:27:43 <b_jonas> not lists
11:28:27 <chrisdone> evening
11:28:27 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:28:58 <parcs> never mind; version 3000.2.0.2 seems to install fine
11:29:26 <chrisdone> kmc: cuz those are the only ones that are supported highlighting-wise. which ones do you wants?
11:30:32 <hpaste> buntfalke annotated “Evaluation!” with “Evaluation; reformat” at http://hpaste.org/51395#a51397
11:30:50 <obiwahn> Cale: ok that works:) now i am missing show io
11:30:59 <kmc> hey chrisdone
11:31:25 <kmc> chrisdone, you're not using a big highlighting library like highlighting-kate
11:31:26 <chrisdone> so my colleague started learning haskell last thursday (one week) and has since written a packages multi threaded server that closes with asyncronous extensible exceptions, takes in queries from clients and returns foursquare results via curl, parsing the json. who says haskell is hard to get going with? ;p
11:31:26 <kmc> ?
11:31:27 <obiwahn> and what should the password.rc look like? must it be in the same dir as the online.rc?
11:31:47 <kmc> "results are not typical"
11:32:32 <mah_b> do anyone knbows how to make the haskell platform portable ie it can be put on a usb drive
11:32:44 <chrisdone> kmc: i'm using highlight.js for the… other languages
11:32:51 <wavewave> hi.
11:32:53 <obiwahn> Cale: and where should the stunnel.conf be?
11:33:06 <wavewave> aeson is changed to aeson-native?
11:33:12 <Cale> obiwahn: I have no idea what that file is
11:33:34 <obiwahn> http://code.haskell.org/lambdabot/READMEhttp://code.haskell.org/lambdabot/README -- SSL MODE
11:33:52 <monochrom> perhaps don't try SSL mode yet
11:33:55 <hpc> mah_b: if you are feeling crazy, you could compile ghc to javascript
11:34:00 <Cale> (Please note that I'm not lambdabot's maintainer and have hardly touched its code)
11:34:04 <dylukes> mah_b: The haskell platform is just the GHC compiler, as well as a large set of cabal packages.
11:34:07 <Cale> I just run lambdabot
11:34:09 <BobFunk> any ideas on how to figure out whats up with my haskell platform install when getting a message like this? https://gist.github.com/1220176
11:34:13 <obiwahn> ah:)
11:34:16 <dylukes> mah_b: The compiler is compiled to native assembly, it's not really portable.
11:34:16 <Cale> I don't actually work on the code at all.
11:34:25 <chrisdone> Cale: nice try, caleskell
11:34:33 <dylukes> @src (.)
11:34:33 <lambdabot> (f . g) x = f (g x)
11:34:33 <lambdabot> NB: In lambdabot,  (.) = fmap
11:34:35 <dylukes> Caleskell!
11:34:44 <obiwahn> :P
11:35:10 <mah_b> I just has to run on windows (at school). "portable" that it does not uses files other than on the drive (paths relative to usb drives root...)
11:35:15 <dylukes> Cale: If the name GCC wasn't taken I'd suggest you fork GHC to make the Glasgow Caleskell Compiler.
11:35:17 <Cale> pff, that's just editing some user state files :P
11:35:19 <wavewave> it seems that aeson's last version is 0.3.2.11 and aeson-native first version is 0.3.3
11:35:24 <obiwahn> Bug reports, patches, new modules etc, contact: Cale:P
11:35:29 <Cale> dylukes: lol
11:35:45 <monochrom> I attribute chrisdone's success story to not hearing about existential types. I know cases of hearing about existential types early and resulting in struggling for months.
11:35:46 <Cale> dylukes: I should do it anyway, just to troll them. I'd release it under BSD of course.
11:35:49 <dylukes> :P
11:35:51 <chrisdone> did anyone write an agda syntax highlighther next?
11:35:56 <hpc> mah_b: http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html -- ;)
11:36:02 <dylukes> chrisdone: emacs has one.
11:36:08 <dylukes> Well, the emacs-mode does :\.
11:36:10 <Cale> obiwahn: Whoever wrote that is a liar.
11:36:12 <chrisdone> dylukes: i mean for hpaste. there're a lot of agda pastes
11:36:16 <dylukes> oooh
11:36:30 <chrisdone> copumpkin: where's my agda syntax highlighter?
11:36:33 <mah_b> hpc: I can't see how this helps?
11:36:48 <hpc> mah_b: ssh into another computer that already has ghc installed
11:37:10 <hpc> putty itself works swimmingly on a flash drive
11:37:20 <parcs> hpc: no it doesn't
11:37:29 <parcs> it stores its configuration in the registry
11:37:32 <obiwahn> Cale: now stop lying and give me some pointers:) 0x004...
11:37:51 <hpc> parcs: yeah, but it at least runs
11:38:00 <dankna> it actually only stores a single registry key
11:38:04 <Cale> obiwahn: I swear, all I did to get it running was download the code for it, unpack it and build it.
11:38:05 <dankna> telling it where to find the config file
11:38:08 <dankna> at least that's my recollection
11:38:29 <parcs> where is the config file located by default?
11:38:38 <dankna> unsure, check docs.  haven't used it (or Windows?) in years.
11:38:51 <monochrom> you can put GHC on a usb flash drive. as long as its drive letter is stable.
11:38:59 <dankna> ha
11:39:04 <applicative> wavewave, I think 'aeson-native' is a pure Haskell way around a C++ library that is strouble on some platforms?
11:39:14 <monochrom> i.e., it's assigned the same drive letter every time
11:39:26 <mah_b> monochrom: ok, that is one batch file. what about cabal?
11:39:36 <parcs> "PuTTY does not currently support storing its configuration in a file instead of the Registry."
11:39:44 <dankna> oh, drat
11:39:59 <parcs> there's portablePutty that comes with xming, but that's donationware
11:40:01 <obiwahn> swear to "god" or "your moms tits":) http://www.youtube.com/watch?v=gaa9iw85tW8
11:40:01 <dankna> I was once paid a small amount to modify Putty's code, heh
11:40:10 <dankna> and I thought I remembered that
11:40:12 <monochrom> cabal is even easier
11:40:13 <dankna> maybe I was thinking of Emacs
11:40:29 <parcs> lol
11:40:42 <buntfalke> Cale: Thanks alot for that eval
11:41:04 <buntfalke> Made it quite clear how it works :-)
11:41:23 <mah_b> monochrom: could you explain this please?
11:41:35 <monochrom> I don't know what is there to explain
11:41:46 <obiwahn> anybody someidea what i could do to fix:  hbot>   Could not find module `ShowIO':
11:41:49 <obiwahn> 21:29 < hbot>    Use -v to see a list of the files search...
11:42:13 <mah_b> monochrom: ok, think I got it, will try it out. Thank you.
11:42:31 <Cale> It was alot of evaluation: http://hyperboleandahalf.blogspot.com/2010/04/alot-is-better-than-you-at-everything.html
11:42:41 <chrisdone> monochrom: yeah, that and he could ask me for help regarding the boring details like the easiest quickest working setup, which exception lib to use. but other than that i was surprised, he got working with the libs fine, used threads off the bat. he really enjoyed LYAH, said it explains everything very clearly.
11:42:41 <chrisdone> monochrom: i've been thinking that it might be useful to somehow document the questions he asked in order to compile a more comprehensive "How to write a Haskell program" doc
11:45:25 <obiwahn> Cale: hwo do build modules for the bot?
11:45:48 <Cale> obiwahn: cabal install
11:46:05 <chrisdone> ah that reminds me
11:46:07 <Cale> They get built along with everything else
11:48:31 <obiwahn> is ShowIO some normal haskell lib?
11:49:30 <c_wraith> *sigh*.  I've been failing to release an update to one of the libraries I maintain because I don't know the right way to handle it.
11:49:55 <c_wraith> is there a right way to add instances to your library that will add new package dependencies?
11:50:04 <monochrom> ShowIO is very abnormal
11:50:22 <monochrom> it enables this kind of depravity:
11:50:30 <monochrom> > putStrLn "<IO ()>"
11:50:31 <lambdabot>   <IO ()>
11:50:42 <c_wraith> that's not depravity. :P
11:50:53 <chrisdone> > putStrLn ""
11:50:54 <lambdabot>   <IO ()>
11:50:59 <chrisdone> cheeky
11:51:44 <chrisdone> hm
11:51:48 <chrisdone> dist/build/lambdabot/lambdabot -e "rc online.rc"
11:51:48 <chrisdone> Initialising plugins ................................................... done.
11:51:48 <chrisdone> it just waits
11:52:02 <c_wraith> chrisdone: sounds like you didn't tell it to connect to any servers
11:52:08 <chrisdone> is there a verbose mode for lb or does it output the IRC response by default?
11:52:21 <c_wraith> it does log IRC server responses
11:52:32 <chrisdone> $ cat online.rc
11:52:32 <chrisdone> irc-connect dev 127.0.0.1 6666 lambdabot lambdabot:lambdabotpass
11:52:32 <chrisdone> admin + dev:cin
11:52:35 <chrisdone> join dev:#lambdabot
11:52:36 <buntfalke> Cale: Ah, I'm trying to unlearn this Alot since quite some time ;-) (English isnt my mother tongue)
11:52:46 <chrisdone> c_wraith: see anything wrong with that?
11:53:39 <c_wraith> chrisdone: I don't know.  I have trouble remembering how it works. :)
11:53:57 <obiwahn> chrisdone: lambdabot if you try to connect to feenode
11:54:15 <chrisdone> obiwahn: huh?
11:54:28 <obiwahn> are you trying to run an lamdabot as well?
11:54:37 <rwbarton> > mfix putStrLn
11:54:38 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:54:38 <lambdabot>         against inferred ty...
11:54:52 <monochrom> "127.0.0.1" doesn't seem to be a freenode server
11:54:56 <chrisdone> obiwahn: yeah. i've done it before but somehow i'm missing something this time
11:55:16 <rwbarton> > mfix print
11:55:16 <lambdabot>   <IO ()>
11:55:30 <chrisdone> $ echo 'USER test * * *' | nc 127.0.0.1 6666
11:55:30 <chrisdone> :dev.icstweb.eu NOTICE * :Connection lost.
11:55:33 <chrisdone> it does exist… hm
11:56:04 <monochrom> oh? does it mean you have a bouncer?
11:56:18 <chrisdone> no it's my irc server running at work
11:56:32 <monochrom> alright, then my bad
11:56:55 <chrisdone> i'll try freenode to see if it's a config format or actual connection issue
11:57:38 <obiwahn> chrisdone: irc-connect netname server port nick ircname
11:57:39 * hackagebot mtree 0.0 - Tree with Meta and Content parameters  http://hackage.haskell.org/package/mtree-0.0 (RahulGopinath)
11:57:56 <obiwahn> i guess the pass should be in the passwd.rc
11:57:58 <bscarlet> Why is the Monoid instance for Map left-biased instead of requiring the value type to be a Monoid?
11:58:21 <chrisdone> obiwahn: the default online.rc file in lambdabot's distribution has the user:password syntax :/
11:58:49 <obiwahn> i have installed mine via cabal
11:59:08 <obiwahn> but it chokes on some show function
11:59:27 <obiwahn> > 4+ 5
11:59:28 <hbot>   Could not find module `ShowIO':
11:59:28 <lambdabot>   9
11:59:29 <hbot>    Use -v to see a list of the files search...
12:00:21 <chrisdone> obiwahn: i think showio comes with an old version of the show package on hackage
12:00:35 <chrisdone> obiwahn: you can just comment out the import from pristine.hs & l.hs in State
12:01:27 <obiwahn>  chrisdone i am new to haskel and cabal where should those files be? in .lambdabot or somewhere in .cabal?
12:02:26 <applicative> bscarlet: i take it you saw the haskell-cafe disputes about this not long ago?
12:02:53 <bscarlet> nope
12:02:58 <chrisdone> obiwahn: in the lambdabot project it's in the lambdabot directory State/L.hs and State/Pristine.hs
12:05:05 <obiwahn> ok i have those files open and waht should i commetn out?
12:05:21 <obiwahn> import ShowIO?!
12:05:33 <applicative> http://haskell.org/pipermail/haskell-cafe/2011-June/093482.html  then http://haskell.org/pipermail/haskell-cafe/2011-June/093490.html not much light is shed though
12:06:08 <applicative> bscarlet ^^^ for what it's worth
12:07:15 <chrisdone> hmm, ok, good. my syntax was correct, it's a server problem. it connects to freenode and displays notices. the user:pass syntax is fictional. the sample online.rc, the : is part of the username
12:07:25 <chrisdone> what is supposed to be the contents of passwd.rc?
12:07:52 <chrisdone> obiwahn: do you have a passwd.rc?
12:07:58 <chrisdone> obiwahn: yes, comment out the import
12:08:17 <bscarlet> applicative: Thanks. I suppose a better question might be by what process it might be changed, and whether it could ever happen in practice.
12:08:41 <obiwahn> not jet:( i asked Cale -- he runs the bot here but he is not very chatty
12:09:47 <applicative> bscarlet, oh I see wren makes some better remarks http://haskell.org/pipermail/haskell-cafe/2011-June/093501.html
12:10:00 <obiwahn> > 4+5
12:10:01 <hbot>   Could not find module `Control.Parallel.Strategies':
12:10:01 <hbot>    Use -v to see a lis...
12:10:01 <lambdabot>   9
12:10:22 <Cale> obiwahn: Oh, create ~/.lambdabot/passwd.rc and put in it   msg freenode:nickserv identify <your bot's password>
12:10:55 <cheater> hi
12:11:12 <applicative> bscarlet, from what he says it would be a nightmare involving some of the kindred libraries.  There is the Libraries list on which one used to argue such things, but procedures have changed lately if I understand
12:11:13 <chrisdone> hm. i think i'll need to patch lambdabot. i need to send a PASS command
12:12:40 * hackagebot haskdogs 0.2 - Generate ctags file for haskell project directory and it's deps  http://hackage.haskell.org/package/haskdogs-0.2 (SergeyMironov)
12:13:47 <Cale> bscarlet: Whoa! That is interesting
12:14:11 <Cale> bscarlet: There was a point at which it was decided that lifting instances would be favoured over more direct things.
12:14:13 <obiwahn> > 4+5
12:14:14 <hbot>   Could not find module `Control.Parallel.Strategies':
12:14:14 <lambdabot>   9
12:14:16 <hbot>    Use -v to see a lis...
12:14:26 <Cale> bscarlet: But maybe that was forgotten or renegotiated.
12:14:53 <obiwahn> chrisdone: commenting out the import did not fix my bot
12:14:55 <krawczyk> @:t split
12:14:56 <lambdabot> Done.
12:15:29 <benmachine> Cale: that seems to be what they did with Maybe
12:15:43 <benmachine> (lift the instance I mean)
12:15:52 <krawczyk> @type split
12:15:52 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
12:16:01 <obiwahn> chrisdone: http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/89409
12:16:26 <benmachine> obiwahn: are you editing the right file? try ~/.lambdabot/State/L.hs
12:16:27 <obiwahn> must is change ShowIO ot ShowFun
12:17:06 <obiwahn> benmachine: i have changed it in the source and deleteed the ~/.lamda.. dir
12:17:20 <benmachine> oh, that seems a strange way to do it
12:17:26 <benmachine> it'll just recreate it again
12:17:52 * bscarlet just got bitten by the left-biased default, despite being quite conscious of the issue at the time.
12:18:33 <krawczyk> @type splitAt
12:18:33 <lambdabot> forall a. Int -> [a] -> ([a], [a])
12:18:46 <obiwahn> benmachine: then i installed the changed version and it has copied the file from share to ~/.l
12:18:50 <krawczyk> @splitAt 4 "0123456789"
12:18:51 <lambdabot> Unknown command, try @list
12:19:02 <obiwahn> what is that state dir?
12:19:14 <obiwahn> it contais only one of the files
12:19:17 <krawczyk> >splitAt 4 "0123456789"
12:19:24 <obiwahn> L.hs
12:20:06 <obiwahn> damn - i can not waste any more time over this:( fuck the bot
12:28:44 <tac-tics> obiwahn: noooooo booooot
12:29:42 <TubeSteak> hello!
12:37:02 <epsilonhalbe> hey people - i read, in learnyouahaskell, that Tuples are types - i understand that this is a language design decision and a philosophical question - why this has been done. but where do i find answer to this "why", and similar ones.
12:37:53 <benmachine> epsilonhalbe: I don't understand your question - what's the decision?
12:38:15 <epsilonhalbe> why tuples are types and not functors like lists
12:38:34 <Botje> epsilonhalbe: because tuples can contain different types
12:38:49 <Botje> and a functor only allows you one "hole" to fill with a type
12:38:55 <epsilonhalbe> and this would not be able to design with a functor
12:39:00 <Botje> yes.
12:39:17 <Botje> if you decide up front which part of the tuple is a "hole", you can make tuples a functor
12:39:20 <Botje> eg:
12:39:29 <Botje> > fmap (+1) ("this is static", 5)
12:39:30 <lambdabot>   ("this is static",6)
12:39:47 <Botje> the default functor instance changes the second part of the tuple
12:40:12 <chrisdone> who's that haskeller that writes blog posts with lots of little drawings?
12:40:26 <Botje> ezyang
12:40:29 <chrisdone> thanks
12:40:41 <epsilonhalbe> oh - i thought that, such a thing is "clearly" a design decision, but it is not
12:41:06 <benmachine> Botje: you can't make the first part the hole without newtypes
12:41:50 <Botje> i wasn't sure if i should go into that :)
12:42:09 <obiwahn> chrisdone Cale yeahy it works:)
12:42:35 <benmachine> Botje: well, with that fact in mind, there's really no decision at all
12:42:41 <benmachine> there's exactly one way tuples can be a functor, and they are
12:43:11 <b_jonas> in standard haskell at least
12:43:14 <benmachine> (if you import the right things)
12:43:16 <JoeyA> What extension do you need to enable so identifiers like Int# don't produce a syntax error?
12:43:18 <Botje> agree
12:43:23 <erus`> how are tuples functors?
12:43:38 <Botje> erus`: see above. fmap works on the second field
12:43:47 <b_jonas> on the last field, right?
12:43:47 <benmachine> JoeyA: the interestingly-named MagicHash
12:43:57 <shachaf> erus`: Using fmap = second.
12:44:05 <benmachine> b_jonas: right. you can't do anything else
12:44:06 <b_jonas> it works with larger tuples too, doesn't it?
12:44:09 <shachaf> > fmap succ (1,2,3)
12:44:10 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
12:44:10 <lambdabot>    arising from a use of `e_...
12:44:10 <b_jonas> yep
12:44:12 <shachaf> b_jonas: In theory.
12:44:14 <JoeyA> benmachine: Thanks
12:44:17 <benmachine> b_jonas: it would do, but the instance isn't in the standard libraries
12:44:25 <b_jonas> not even for 3 and 4 tuples?
12:44:29 <b_jonas> I don't mean very large tuples
12:44:30 <shachaf> However, you have no business fmappin' larger tuples.
12:44:52 <b_jonas> hmm, indeed
12:44:53 <b_jonas> strange
12:44:59 <epsilonhalbe> > fmap (+1) ("a","b",1)
12:45:00 <lambdabot>   No instance for (GHC.Base.Functor
12:45:00 <lambdabot>                     ((,,) [GHC.Types.Char...
12:45:03 <b_jonas> it doesn't seem to work for 3-tuples
12:45:09 <benmachine> b_jonas: the instance for 2-tuples isn't even in anywhere standard, it's squirrelled away in Control.Monad.Instances
12:45:15 <Cale> You're probably better off using ((a,b),c) instead
12:45:25 <shachaf> FSVO "better off"
12:45:34 <shachaf> It would be nice if all tuples worked that way, though.
12:45:45 <shachaf> I guess the objection is extra _|_s?
12:45:50 <b_jonas> Cale: why?
12:46:04 <benmachine> I think extra bottoms is a small price to pay for better consistency
12:46:09 <obiwahn> Cale: the bot does not use the passed.rc
12:46:31 <obiwahn> where should the file be?
12:46:33 <epsilonhalbe> but again to my basic question - where do i find an explanation why haskell is the way it is?
12:46:33 <Cale> b_jonas: More operations are available for pairs, and it's easier to decompose
12:46:37 <shachaf> benmachine: n-tuples aren't really inconsistent.
12:46:55 <benmachine> shachaf: but it's kind of annoying how you can't do any of the instances generically
12:46:56 <obiwahn> in ~/.lamamdabot
12:47:02 <obiwahn> damn
12:47:04 <benmachine> shachaf: I could argue that 'number of supported tuples' is inconsistent
12:47:04 <Cale> b_jonas: Especially in the case where you're using the functor instance to treat the last value specially, and the rest as "tags"
12:47:09 <yrlnry> epsilonhalbe:  have you looked at the haskell report?  There is some rationale in there.
12:47:20 <Cale> b_jonas: structuring it that way means that the tags are nicely bundled together
12:47:22 <yrlnry> A lot of the rationale is folklore, however.
12:47:29 <benmachine> ghc seems to support them arbitrarily-large, but the number that are Eq is whatever, the number that are Functor is whatever else
12:47:29 <b_jonas> Cale: okay
12:47:41 * hackagebot numerals 0.3.0.1 - Convert numbers to number words  http://hackage.haskell.org/package/numerals-0.3.0.1 (RoelVanDijk)
12:47:49 <shachaf> I guess HList is cons-style tuples?
12:47:50 <yrlnry> Often the answer is that it is the way it is because of engineering compromises between what people would like to do and what they actually know how to calculate.
12:48:20 <b_jonas> > fmap (+10) (3,4,5)
12:48:20 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
12:48:21 <lambdabot>    arising from a use of `e_...
12:48:32 <b_jonas> benmachine: that latter number seems to be 2
12:48:35 <benmachine> shachaf: I guess that too
12:48:42 <benmachine> b_jonas: yeah
12:49:07 <benmachine> the number of Eq instances displayed by :info seems to be, umm
12:49:09 <b_jonas> well, I'm mostly okay with very large tuples not working
12:49:15 <benmachine> > ord 'o' - ord 'a' + 1
12:49:15 <lambdabot>   15
12:49:19 <benmachine> 15
12:49:46 <epsilonhalbe> i guess i'll have a look at the haskell report - thx
12:49:59 <b_jonas> by the way, what version of ghc is lambdabot running?
12:50:16 <shachaf> 6.12, I believe.
12:50:36 <shachaf> @ty id runST undefined
12:50:37 <lambdabot>     Cannot match a monotype with `forall s. ST s a'
12:50:37 <lambdabot>       Expected type: a1
12:50:37 <lambdabot>       Inferred type: forall s. ST s a
12:50:38 <shachaf> @ty (id runST) undefined
12:50:39 <lambdabot> forall a. a
12:51:04 <b_jonas> shachaf: thanks
12:52:11 <shachaf> Hmm, now I know why ghci starts so slowly for me.
12:52:16 <shachaf> I have 53 imports in .ghci.
12:52:19 <rwbarton> wait what happened there?
12:52:33 <shachaf> rwbarton: Magic. Look the other way.
12:52:42 <rwbarton> :/
12:53:07 <benmachine> @ty runST
12:53:08 <lambdabot> forall a. (forall s. ST s a) -> a
12:53:41 <benmachine> shachaf: that frightens me, also, I can't reproduce it
12:53:44 <benmachine> what is the deal
12:53:49 <obiwahn> Cale: how do i find out what is wrong of if the bot is sending the connetion command
12:53:50 <shachaf> benmachine: It's different under GHC 7.
12:53:56 <benmachine> shachaf: ah, devious
12:54:02 <shachaf> That behavior is consistent with 6.12, though.
12:56:10 <benmachine> shachaf: ah, got it with 6.12.3
12:56:12 <benmachine> weeeeeeird
12:56:21 <benmachine> super-weird
12:58:04 <Cale> What?
12:58:50 <JoeyA> What's a good way to test functions in a module that aren't exported?  Define QuickCheck properties within the module and export them?
12:59:26 <Cale> JoeyA: Sure, or if you load the module in ghci, you can test them directly
12:59:46 <byorgey> JoeyA: the problem with that approach is that now your module depends on QuickCheck
12:59:53 <JoeyA> Ah, I see.
13:00:00 <Cale> Just make sure there's no .o file hanging around, or else it'll load that, and only see the exported things
13:00:03 <byorgey> JoeyA: so anyone that installs it will have to install QuickCheck, even if they don't care about testing it.
13:00:21 <glguy> There's always CPP...
13:00:25 <glguy> :-/
13:00:37 <byorgey> JoeyA: do you just want to test informally, or create an actual test suite?
13:00:57 <Cale> CPP is a kinda ugly preprocessor. We need HPP :P
13:01:05 <b_jonas> JoeyA: define two modules: an implementation module that exports everything but is not recommended for daily use, and a normal module that imports the implementation and reexports the functions you want. Then quickcheck importing the implementation module.
13:01:21 <byorgey> what I often do is create "implementation" mod... what b_jonas said.
13:01:43 <JoeyA> b_jonas: That sounds like a good idea.
13:02:05 <JoeyA> Thanks
13:02:46 <byorgey> that way you also make happy both new users (who just want to see the "recommended" API without extra stuff to confuse them) and power users (who want access to the internals for some reason).
13:02:54 <applicative> I see byorgey said what I was going to:  I remember some packages failing because of quickcheck curiosities when they took this approach.  But I can't remember it happening lately.
13:03:49 <JoeyA> Does anyone find it annoying how Google searching for a library frequently returns results for various versions, often outdated?
13:03:56 <JoeyA> Granted, there's hoogle...
13:04:12 <JoeyA> PostgreSQL has the same problem, by the way.
13:04:32 <chrisdone> yeah. always 8.2 or 9.1
13:04:35 <JoeyA> Documentation for multiple versions is hosted on the web, and Google searches don't default.
13:04:37 <chrisdone> mostly 8
13:04:49 <applicative> yes, but i just don't think we have the kind of sway with Google, Inc that would be needed to divert them from figuring out what country I'm in, etc and other more pressing things
13:04:53 <JoeyA> It'd be nice if robots.txt could specify version precedence or something.
13:05:09 <benmachine> applicative: and what you had for breakfast this morning
13:05:29 <JoeyA> That can be inferred from your location, though?
13:06:13 <byorgey> JoeyA: this is why I never use Google to search for documentation.
13:06:44 <byorgey> I either use hoogle if I don't know what package I want, or look up the package on Hackage
13:06:49 <applicative> byorgey, what do you use? memory?
13:07:46 * Cale uses a combination of his local haddock index, and hackage's
13:08:14 <applicative> its surprisingly fast for a lot of modules "Data.Vector.Unboxed"
13:09:31 <applicative> i used to use the google code search if I wanted to see how people used a module, but it has deteriorated incredibly
13:10:32 <applicative> its nice because it has looked at old tarballs linked on forgotten pages at obscure universities.
13:11:23 <Corrupted> how to get ghc in ubuntu?
13:11:46 <Cale> Corrupted: My recommendation is to not use the Ubuntu packages
13:11:52 <Cale> At least, if you care about GHC :P
13:12:08 <applicative> isn't there haskell-platform?
13:12:16 <Clint> so make a debian chroot ;p
13:12:26 <JoeyA> Do Module/Copyright/License/Maintainer/etc. comments in a source file have any purpose when there's a cabal file that says the same thing?
13:12:37 <Cale> I just install the generic linux binary from the GHC website
13:12:58 <Cale> and then download cabal-install from hackage and run the bootstrap.sh script from that
13:13:27 <Cale> and that gets me a working cabal-install, after which I can install any libraries I need using cabal
13:13:34 <applicative> JoeyA, the more important question is, even if they do have a purpose is it equally well served by putting them at the bottom of the file so I don't have to be reminded constantly of the terms of the gpl
13:15:04 * applicative thinks you should retype the GPL before each function definition, data type declaration and above all before each class instance
13:15:40 <JoeyA> I'm referring to the practice of putting module synopsis information at the top of a source file, e.g. http://www.haskell.org/ghc/docs/latest/html/libraries/containers/src/Data-Map.html
13:15:57 <JoeyA> After the Module, etc., there's documentation, which Haddock does pick up and use.
13:16:15 * applicative thinks this way the writer has ample time to think before hazarding his or her next definition, as Alonzo Church would spend the first half of class erasing the board
13:16:31 <roconnor> JoeyA: not all files, or even functions, in a piece of software are always under the same license
13:17:01 * roconnor agrees with applicative
13:17:33 * applicative takes roconnors point and proposes to elegantly vary licensing throughout his module
13:17:51 <chrisdone> hmmm. lambdabot is responding to PM, but not responding to commands in a channel
13:18:03 <applicative> -- my next definition is BSD3!
13:18:09 * Cale just ignores licensing concerns as hard as he possibly can.
13:18:14 <chrisdone> is there a common cause for that?
13:18:29 <Cale> apparently that's known as BSD3
13:18:31 <roconnor> applicative: exactly, some functions are more reusable in various legal contexts
13:18:44 <chrisdone> Cale: do you know?
13:18:52 <Cale> wat
13:18:58 <roconnor> applicative: for example, if you use unsafePerformIO somewhere, you may *not* want to freely license it, else someone might use the code.
13:18:58 <Cale> > 1
13:18:58 <lambdabot>   1
13:19:05 <chrisdone> sorry. my own lambdabot
13:19:10 <Clint> MIT is better for ignoring licensing concerns
13:19:12 <Cale> hmmm
13:19:13 <chrisdone> > 23 => <lambdabot>   23. but in the channel, no reply
13:19:14 <lambdabot>   <no location info>: parse error on input `=>'
13:19:20 <Cale> oh
13:19:28 <Cale> @run 1
13:19:29 <lambdabot>   1
13:19:29 <chrisdone> although when i do > 123 in the channel, i *do* see this in lambdabot's output:
13:19:29 <chrisdone> ["-E","-XBangPatterns","-XNoMonomorphismRestriction","-XViewPatterns","--no-im\
13:19:29 <chrisdone> ports","-l","State/L.hs","--expression=123","+RTS","-N2","-RTS"]
13:19:34 <Cale> Try @run
13:19:38 <chrisdone> same result
13:19:47 <Cale> cute
13:19:48 <Cale> hmm
13:20:04 <Cale> So it's doing the evaluation and not displaying the result somehow?
13:20:13 <Cale> that's really odd, I've never seen that
13:20:16 <chrisdone> it seems so
13:20:21 <Cale> Is the channel +m or something?
13:20:31 <Cale> Or is your lambdabot quieted in the channel?
13:20:33 <chrisdone> i once had this problem when i had lambdabot join #lambdabot, but it worked in another channel. so this time i thought ahead and joined #lbot instead
13:20:41 <chrisdone> there're no modes set in the channel
13:21:00 <chrisdone> hm
13:23:06 <chrisdone> oh WHAT
13:23:27 <chrisdone> i don't believe it -_-
13:23:33 <chrisdone> i got it to join #demo and it works
13:23:39 <chrisdone> close, rejoin #lbot, no response
13:24:01 <chrisdone> you are tearing me apart, lambdabot!!
13:24:07 <benmachine> she does it to spite you
13:24:13 <benmachine> @vixen are you trolling chris
13:24:14 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
13:24:18 <chrisdone> ( http://www.youtube.com/watch?v=Plz-bhcHryc )
13:24:26 <benmachine> um, that was unsettling
13:24:30 <monochrom> she is a <censored> 19 year old <censored> after all
13:24:59 <monochrom> @nixos
13:24:59 <lambdabot> Any change is resisted because bureaucrats have a vested interest in the chaos in which they exist.
13:25:13 * chrisdone greps the lambdabot source for lbot
13:25:40 <applicative> uh, can we get rid of the pope-emperor sexuality texts
13:26:01 <chrisdone> bah, this makes no sense at all
13:27:51 <chrisdone> http://i.imgur.com/Q9Omg.jpg
13:27:56 <chrisdone> sense. it makes none
13:28:13 <tgeeky> can someone email me the PDF of http://webcache.googleusercontent.com/search?q=cache:http://www.iis.sinica.edu.tw/~scm/pub/icfp055fp-mu.pdf ?
13:28:17 <tgeeky> if you have saved it?
13:28:31 <chrisdone> and god knows where this comes from: "sending message to bogus server: IrcMessage {msgServer = "freenode", msgLBName = "urk!<outputmessage>", msgPrefix = "", msgCommand = "TOPIC", msgParams = ["weird#"]}"
13:33:17 <hpaste> sdasadsad pasted “sadsad” at http://hpaste.org/51400
13:34:32 <JoeyA> Pretty
13:54:25 <siracusa> Is there a function to get a single character from an UTF-8-encoded string plus the information if that char was encoded correctly? The utf8string functions only seem to replace incorrectly encoded chars.
13:57:44 * hackagebot ligd 0.2 - Lightweight Implementation of Generics and Dynamics  http://hackage.haskell.org/package/ligd-0.2 (SeanLeather)
13:57:49 <b_jonas> siracusa: well, the iconv library has functions to decode part of a function and detect where it can't be decoded
13:58:06 <b_jonas> but you need something else then to get the characters, so that might not be the best
13:59:46 <b_jonas> but I don't know an easier solution, sorry
14:00:56 <b_jonas> so using iconv, you'd convert the text from utf-8 to utf-8, which finds you the location of the error, then you use some other module like Data.Encoding to get the characters of the portion that's successfully converted
14:02:16 <siracusa> b_jonas: convertLazily seems to be what I was looking for, I'll try that. Thanks so far!
14:08:24 <rostayob> does anybody have experience with the pretty library?
14:08:50 <rostayob> because I have a problem with indentation, and I can't solve it in a nice way
14:09:01 <monochrom> I used it a bit. but I haven't done what you wanted
14:09:17 <monochrom> maybe I have but not sure
14:09:54 <rostayob> well my problem is in rendering stuff like "var foo = { this: that }" in JavaScript. I want the this: that to be indented in respect to foo, and I can
14:10:24 <rostayob> the problem is that I am processing the LHS and the RHS separately
14:10:48 <monochrom> paste the desired indented outcome?
14:11:06 <rostayob> so I have a data type like "Assignment String Expr" and I do expr (Statement var e) = text var <> expr e
14:11:08 <rostayob> monochrom: just a sec
14:14:26 <hpaste> rostayob pasted “indentation and pretty” at http://hpaste.org/51402
14:14:36 <rostayob> monochrom: http://hpaste.org/51402
14:15:50 <rostayob> monochrom: now it's not that I can't produce the desired outcome, buf If I separe the rendering of "var factorial" and the rest, it's kind of ugly
14:16:25 <rostayob> (the code)
14:16:52 <rostayob> I have to pass the partial line to the next step in the rendering in some way
14:17:04 <monochrom> must you separate them?
14:17:19 <rostayob> monochrom: well it's natural to separate the rendering of the LHS and of the RHS
14:18:51 <rostayob> I could create a little monad to add and remove indentation levels...
14:26:03 <kmc> doesn't 'pretty' already handle that?
14:26:06 <kmc> :t nest
14:26:07 <lambdabot> Int -> Doc -> Doc
14:26:13 <kmc> > nest 4 (text "hello")
14:26:13 <lambdabot>       hello
14:26:21 <kmc> > text "hi" $$ nest 4 (text "hello")
14:26:22 <lambdabot>   hi  hello
14:26:25 <rostayob> kmc: yes, but nest works on the current thing that you're rendering as start of the indentation
14:26:33 <monochrom> I would parameterize my Function prettier with a Doc. f d (Function vs bs) = (d <+> text "function(" <> blah blah vs <> text ") {") $+$ nest 2 (blah blah ss) $+$ text "};"
14:26:34 <rostayob> > text "hi" $+$ nest 4 (text "hello")
14:26:35 <lambdabot>   hi
14:26:35 <lambdabot>      hello
14:27:01 <Dashkal> mmm, monad puns.  action :: SKIO a (State, Kelski, IO)
14:27:06 <rostayob> monochrom: yes, that was my solution as well but it's kind of ugly passing all those Docs around
14:27:19 <rostayob> also because 90% of the time we don't need it
14:27:32 <hpaste> siracusa pasted “iconv installation problem” at http://hpaste.org/51403
14:27:53 <siracusa> ^ How can that be fixed?
14:28:23 * bfig downloads template haskell...
14:28:51 * bfig has the wildest dream of programming a generic zipN function :)
14:29:14 <dmwit> bfig: Doesn't ZipList do that already, with no generic programming?
14:29:24 <rostayob> bfig: well your dream is not so wild :P
14:29:38 <rostayob> dmwit: with tuples?
14:30:05 <bfig> rostayob, it is on the very first TH paper buuuut :p
14:30:34 <dmwit> rostayob: With your favorite n-ary combining function, including the tuple constructor if you like.
14:30:48 <dmwit> :t (<*)
14:30:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:31:00 <bfig> what does this mean? http://hackage.haskell.org/packages/archive/template-haskell/2.5.0.0/logs/failure/ghc-7.2
14:31:21 <bfig> dmwit, i don't want to have (a,(b,(c,...) i want to have (a,b,c...) :D
14:31:23 <rostayob> dmwit: yeah fair enough, but you can't create a zipN that works with tuples for obvious reasons
14:31:26 <dmwit> :t (<*>)
14:31:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:32:05 <dmwit> > (,,,) <$> ZipList [0, 1] <*> ZipList "like" <*> ZipList "this" <*> ZipList "bfig?"
14:32:07 <lambdabot>   No instance for (GHC.Show.Show
14:32:07 <lambdabot>                     (Control.Applicative.Zip...
14:32:13 <dmwit> > getZipList $ (,,,) <$> ZipList [0, 1] <*> ZipList "like" <*> ZipList "this" <*> ZipList "bfig?"
14:32:14 <lambdabot>   [(0,'l','t','b'),(1,'i','h','f')]
14:32:54 <dmwit> bfig, rostayob: ?
14:33:06 <rostayob> dmwit: yeah my point is that you'll never be able to have something like "zipN 3 [1,2,3] [4,5,6] [7,8,9]"
14:33:18 <rostayob> you can't even write it's type
14:33:24 <bfig> dmwit, i don't want to use the tuple constructor :D
14:33:26 <dmwit> Nope, you have something like zipN (,,) [1,2,3] [4,5,6] [7,8,9] instead.
14:33:28 <bfig> (explicitly)
14:33:29 <dmwit> That's not so bad.
14:33:36 <rostayob> dmwit: no it's not :)
14:33:46 <bfig> zip25 = (,,,,,,,,,,,,,,,,,,,,,,,,,,) <$> .,,,
14:34:02 <bfig> not that i plan to zip 25 lists anytime soon anyway...
14:34:17 <bfig> i'm having that error i posted before, any ideaS?
14:34:32 <bfig> (while cabal install template-haskell)
14:36:18 <bfig> actually the error is not exactly that one. it is on this line: Language/Haskell/TH/PprLib.hs:55:0
14:38:03 <monkyyy> hello
14:39:03 <monkyyy> anyone here?
14:39:12 <benmachine> bfig: pretty sure you're not supposed to cabal install template-haskell
14:39:35 <bfig> benmachine, that would be pretty weird since it is a cabal package
14:39:40 <bfig> what am i missing?
14:39:43 <benmachine> bfig: it's pretty weird
14:39:47 <benmachine> hope this helps
14:39:49 * bfig googles how to install template-haskell
14:39:54 <benmachine> bfig: it comes with GHC
14:40:02 <dcoutts> benmachine: I think in principle it's ok, I think :-)
14:40:02 <benmachine> it can't be upgraded without upgrading GHC
14:40:11 <bfig> mmm. (*lol*)
14:40:25 <benmachine> dcoutts: hmm, well, you'd know better than I do, but that wasn't my impression
14:40:38 <Nafai> dcoutts: So how is Well-Typed going?
14:40:42 <bfig> benmachine, well, thanks for saving me a headache :D
14:41:15 <dcoutts> Nafai: ok thanks :-)
14:41:42 <bfig> dcoutts, the other day i didn't realize you wrote the stream fusion paper, that was pretty cool :).
14:42:05 <bfig> i read it some weeks ago :]
14:42:11 <monkyyy> can someone tell me why this isnt changing the keybindings http://pastebin.com/ALrvfWsG
14:42:13 <mauke> The paste ALrvfWsG has been copied to http://hpaste.org/51404
14:42:24 <dcoutts> bfig: oh thanks, if you're interested in that stuff I'm about to publish my thesis which is on the same topic
14:42:30 <dcoutts> (but in a lot more detail)
14:43:04 <bfig> cool, is that for a PhD?
14:43:54 <bfig> i'm just a puny undergrad, will i be able to handle it? maybe it could be an interesting topic for the functional programming course i'm taking... we've covered your other paper so.. >_>
14:44:11 <dcoutts> bfig: yes
14:44:15 <benmachine> monkyyy: the important bit is main = xmonad gnomeConfig, which is still using the default gnomeConfig, and not any of the values you defined
14:44:43 <dcoutts> bfig: well the introduction chapter I think should be understandable by undergraduates
14:44:52 <monkyyy> so? how do i fix w/o removing the gnome stuff?
14:45:18 <dcoutts> bfig: the theory is a little frightening at first
14:45:27 <bfig> well, by all means i'm up for it :)
14:46:04 <byorgey> bfig: don't worry about whether you can "handle" this or that paper, just try reading it, work through the parts you understand and don't worry about the other parts.  Then go learn something else and come back to it.
14:46:22 <byorgey> bfig: there's no magical point at which you're suddenly able to understand all academic papers =)
14:46:53 <dcoutts> bfig: btw when I say introduction chapter, I don't just mean a few paragrahps and the rest being incomprehensible :-) it's a ~50 page intro chapter covering build/foldr, unfoldr/unbuild and stream fusion
14:47:42 <bfig> byorgey, of course, but in a general sense, papers vary from easily readable, to mildly confusing to absolutely incomprehensible
14:47:53 <siracusa> Aha, "hsiconv.h not found" actually means iconv.h not found -.-
14:47:58 <bfig> dcoutts, do you have an url or want my email?
14:48:06 <byorgey> bfig: yes, that's true.
14:48:20 <benmachine> monkyyy: using record update syntax is the usual way
14:48:22 <dcoutts> bfig: I'll probably mention it on my company blog or twitter feed
14:48:37 <dcoutts> bfig: but feel free to email me
14:49:06 <benmachine> monkyyy: e.g. xmonad gnomeConfig { modMask = mod4Mask } and stuff like that
14:49:30 <benmachine> (actually I'm a little surprised that your version compiles at all... might want to check that)
14:49:46 <monkyyy> k, i'll try what i think u mean
14:49:46 <bfig> dcoutts, i'll be around :), whenever you publish your thesis i'll check it out
14:50:13 * Nafai installs GHC 7.0.3 and the latest Haskell Platform
15:08:27 <dmwit> monkyyy: Did you know there's an #xmonad?
15:09:08 <monkyyy> ummm no, the wiki pointed me here
15:09:15 <mamalujo> really? how odd
15:10:04 <dmwit> If you tell me where, I'll update it.
15:10:43 <mamalujo> monkyyy: well it is clearly stated on the site: http://xmonad.org/community.html
15:11:08 <monkyyy> http://www.google.com/cse?cx=015832023690232952875%3A_-jd7fuydxw&q=irc&sa=Search&siteurl=xmonad.org%2Fdocumentation.html one of the links pointed me here
15:12:11 <mamalujo> hmm
15:12:38 <monkyyy> does the custom search thing favor the "haskell" site?
15:13:42 <monkyyy> hmmm must have searched for something other then irc
15:15:26 <monkyyy> hmmm oh well going to the other irc channel
15:33:39 <dainanaki> are there any lightweight memory tracking facilities for ghc that don't require building with profiling enabled?
15:42:29 <mm_freak_> dainanaki: there are some statistics flags, when you compile with -rtsopts
15:42:53 <mm_freak_> those are only overall statistics, though
15:43:00 <cadabra> Can I do pattern matching yet remain agnostic of the fields of the ctor? E.g. I just want ``f c@(Ctor ...) = accessor c''
15:43:13 <mauke> {}
15:43:21 <cadabra> ?
15:44:18 <parcs> c@(Ctor{})
15:44:21 <cadabra> I know I can do data D = Ctor { accessor :: T }... But I still need to fill in the fields at the pattern match site, e.g. f (Ctor _) = ...;
15:44:23 <cadabra> Oh!
15:47:26 <monochrom> you can do this too:
15:47:40 <monochrom> case Just 0 of Just{} -> "cool"
15:47:44 <monochrom> > case Just 0 of Just{} -> "cool"
15:47:45 <lambdabot>   "cool"
15:49:59 <monochrom> there are many things wrong with haskell's record system, but this aspect delights me, that even "non-records" enjoy applicable record syntax
15:50:15 <shachaf> > Just {}
15:50:16 <lambdabot>   Just *Exception: <interactive>:3:0-6: Missing field in record construction
15:50:48 <monochrom> as a value, it's the same as Just undefined
15:50:51 <shirt> is there a way to check if an executable that was compiled with ghc was compiled with optimizations enabled?
15:51:38 <monochrom> generally, the Haskell Report says that if you write {...} and omit fields, they are filled with undefined
15:52:48 <monochrom> or rather filled with ⊥
15:53:38 <shachaf> shirt: Not as far as I know.
15:55:18 <monochrom> "The expression F {}, where F is a data constructor, is legal whether or not F was declared with record syntax (provided F has no strict fields — see the fourth bullet above); it denotes F ⊥1 … ⊥n, where n is the arity of F." :)
15:57:47 <rwbarton> if F has strict fields is it "not legal" or just ⊥?
15:58:14 <shachaf> I would assume _|_.
15:58:24 <monochrom> the 4th bullet says it's a compile-time error
15:58:40 <monochrom> "A compile-time error occurs when any strict fields (fields whose declared types are prefixed by !) are omitted during construction."
15:58:42 <shachaf> Oh, no, it's required.
15:59:11 <monochrom> of course nothing stops you from F{x = let y=y in y}
15:59:34 <mauke> or just 'undefined'
15:59:43 <mauke> the whole thing is bottom anyway
15:59:59 <monochrom> so the check is just a pretty weak sanity check
16:06:14 <cadabra> Is there a convenient way to globally disable Debug.Trace output?
16:06:38 <shachaf> cadabra: Yes: Don't use Debug.Trace.
16:06:56 <shachaf> The whole point Debug.Trace is that it's, ahem, untraceable.
16:12:05 <ddarius> class Debug where trace :: String -> a -> a
16:12:29 <shachaf> Nullary type classes!
16:12:43 <Jafet> Debugging with class.
16:13:09 * shachaf isn't quite sure what the advantage of that over a regular function would be, though...
16:14:12 <ddarius> shachaf: Because I don't need a -definition- of trace in scope to use it.
16:14:40 <shachaf> ddarius: But won't people typically test the behavior of trace in standalone modules?
16:53:19 <stribor> hello stribor:)
17:21:46 <kmc> if I have an executable that was compiled by GHC, is there any way to find all the info tables in that binary file?
17:22:07 <kmc> short of looking for all symbols named *_info?
17:22:30 <ddarius> Probably not.
17:22:50 <Peaker> you mean in the objdump -t sense?
17:23:02 <Peaker> ddarius: nullary classes are valid H98, or some extension?
17:23:22 <shachaf> Peaker: Not in GHC, as far as I know.
17:23:31 <ddarius> Peaker: Neither, but they should be allowed as a special case of multiparameter type classes.
17:23:35 <kmc> Peaker, yeah, that's what i mean by symbols
17:23:36 <shachaf> ddarius is lobbying for them, though.
17:23:44 <Peaker> ddarius: Yeah, it has never occurred to me before :)
17:23:49 <edwardk> kmc: nothing i can think of
17:24:04 <kmc> class Unsafe where unsafePerformIO :: IO a -> a
17:24:24 <kmc> :/
17:25:06 <edwardk> kmc: then you can exploit the infectiousness of instances, to know that any module for which an instance of Unsafe isn't being exported can't have called unsafePerformIO ;)
17:25:31 <Peaker> ddarius: but I guess the nullary constraints disappear from the using values' types (just like class constraints disappear if the type variables disappear)
17:25:53 <Peaker> ddarius: so you probably can't use it to "taint" function types who use these functions (still maybe useful, though)
17:26:00 <ddarius> Peaker: Only if there is an instance in scope, but yes, they do disappear.
17:26:59 <ddarius> Several days ago I brought this "idea" up again (it first occurred to me that this should be allowed, probably over a year ago.)  People came up with several interesting potential uses.
17:31:04 <edwardk> i do find classes with empty fundeps like class Closed a | -> a where … to be very useful
17:31:55 <edwardk> so going a step further and allowing the arg list to be empty would be kinda neat. separating interface from implementation
17:32:18 <shirt> who is luke palmer?
17:32:30 <edwardk> a programmer who kinda likes haskell
17:32:35 <gwern> @quote
17:32:35 <lambdabot> bakert says: [On text editors] The best plan is to install them all and switch between them typing one line at a time in each until you know which is best for you.  Usually it can be decided within
17:32:35 <lambdabot> a few months.
17:32:49 <kmc> write your own editor!
17:32:55 <Peaker> Yi!
17:33:33 <edwardk> kmc: i'm still waiting for you to build a vim clone wired up to trifecta ;)
17:33:44 <kmc> haha
17:33:45 <kmc> one day
17:33:47 <ddarius> Peaker: See 20:41 and onward here: http://tunes.org/~nef/logs/haskell/11.09.04
17:34:52 <shirt> http://neugierig.org/content/unix/
17:37:51 <Peaker> ddarius: What are the benefits of e.g: Unsafe as a nullary class?
17:38:09 <Peaker> ddarius: It would be nice if you had:  f :: Unsafe => ...  but that goes away :(
17:39:29 <edwardk> lets say you write the code using Unsafe without the instance in scope. then you can't actually elide them. then have some main module that imports the actual unsafe implementation module.
17:41:31 <edwardk> module UnsafeInterface where class Unsafe where unsafePerformIO :: IO a -> a      -- module UsesUnsafe where import UnsafeInterface; foo :: Unsafe => … -> IO (); foo = … unsafePerformIO …      -- module Main where import UsesUnsafe; import UnsafeImplementation; main = foo
17:41:59 <edwardk> now the code in UsesUnsafe can't drop the Unsafe annotations because they don't know the implementation you are using.
17:43:17 <edwardk> of course you could use parametricity but that scares people, and this has the "benefit" of ensuring only one Unsafe instance is brought in transitively by the main module.
17:43:52 <Peaker> edwardk: so the Unsafe=> constraint remains if there was no instance in scope? Is that akin to having a   Num String =>   constraint remain on a function in a library?  It's weird if H98 can cause that -- because that requires FlexibleContexts to express
17:43:55 <edwardk> perhaps something better would be a platform class that provided generic file handling routines with modules for Windows, flavors of Unix, etc. such that you can only import one of them
17:44:52 <edwardk> it'd probably require FlexibleContexts, yes.
17:45:22 <edwardk> but since we're varying the number of parameters on the type class its already pretty far outside of 98 ;)
17:45:38 <Peaker> interesting, this is basically another case of required type annotations that I wasn't aware of
17:46:14 <Peaker> @type let x = "hi"+5 in "hello"
17:46:15 <lambdabot>     No instance for (Num [Char])
17:46:15 <lambdabot>       arising from the literal `5' at <interactive>:1:13
17:46:15 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
17:46:51 <Peaker> @type let f :: Num String => String ; f = "hello" where x = "hi"+5   in f
17:46:51 <lambdabot>     No instance for (Num String)
17:46:52 <lambdabot>       arising from a use of `f' at <interactive>:1:66
17:46:52 <lambdabot>     Possible fix: add an instance declaration for (Num String)
17:47:05 <Peaker> I guess this is relevant only for a "library compilation"?
17:47:39 <edwardk> probably
17:47:54 <edwardk> might not work, but that was the thought i had when ddarius mentioned the idea to me
17:48:24 <Peaker> actually, with FlexibleContexts, ghc allows:  f :: Num String => String ; f = "hello" where x = 5+"hello"     and it compiles, even in main!  Unless you use f
17:48:34 <edwardk> =)
17:48:35 <Peaker> I didn't know that instance lookups were delayed until actual use
17:48:39 <edwardk> yeah
17:48:47 <edwardk> that matches with what i expected
17:48:51 <Peaker> I thought type-checking covered all instance finding
17:50:15 <edwardk> anyways that should make it so you can write functions like foo :: PlatformDependent => …   -- and only be able to run them when you commit to a particular platform
17:50:23 <edwardk> singletons come to haskell ;)
17:50:33 <edwardk> mind you you can already express that to a degree
17:51:01 <Peaker> ok, I agree, nullary classes would be awesome :)
17:51:03 <edwardk> foo :: Platform a => …   for a class class Platform a | -> a where ...
17:51:23 <edwardk> so i guess it doesn't add power
17:51:49 <edwardk> then you can make modules like module WindowsPlatform where instance Platform Windows where …  ;
17:51:54 <Peaker> but what if you use unsafePerformIO, safely, and you don't expose the unsafety?
17:52:02 <Peaker> if you import the instance, you taint all your importers with the instance too
17:52:09 <edwardk> yep
17:52:12 <edwardk> muahahah
17:54:13 <shachaf> I wonder why you can't stop yourself from re-exporting instances.
17:54:15 <Peaker> so it doesn't work that well for the Unsafe case
17:54:21 <shachaf> I guess it makes some sense.
17:54:34 <shachaf> E.g. if you had conflicting instances of Ord with a Map, or something like that.
17:54:37 <Peaker> I guess to be consistent about instances-are-global-dont-try-to-pretend-otherwise
17:54:50 <Peaker> though enforcing no-conflicting-instances could be good enough, probably
17:54:58 <edwardk> shachaf: because if you could you could violate confluence. leading to Sets of Ints which use one ordering being hedged merged with one using the opposite order, etc.
17:55:13 <hpc> Peaker: i would argue that you shouldn't be doing scary stuff with instances anyway
17:55:35 <Peaker> shachaf: it could force a re-export only of the allowed-instance, rather than the instance itself.. the only effect of exporting allowed-instance is that if someone else needs an instance, they must import the allowed instance specifically..
17:55:57 <Peaker> (that way you can easily show that you can't get inconsistent instances)
17:55:58 <cmccann> Peaker, that way lies madness
17:56:10 <Peaker> cmccann: why?
17:56:22 <cmccann> because you have magic implicit stuff flying around in unclear ways
17:56:29 <Peaker> just like now? :)
17:56:51 <cmccann> yes, but at least now you only have magic implicit stuff that barges in and won't leave
17:56:51 <Peaker> you'd export instances explicitly -- the "allowed instance" is an implementation detail of the mechanism that enforces consistency
17:57:22 <cmccann> at some point, why not just use explicit implementations? higher-order functions are still a thing that exists, that didn't change :]
17:57:30 <shachaf> kmccann
17:57:56 <Peaker> cmccann: passing unsafePerformIO in an explicit dictionary is going to be somewhat annoying, though
17:57:57 <shachaf> edwardk: Right.
17:58:35 <cmccann> Peaker, making it more convenient to use unsafePerformIO isn't really my biggest concern :P
17:58:49 <Peaker> edwardk: but the prevention of instance re-export can be implemented as merely a lip-service.. something to force the syntax of importers to also import the same instances (but otherwise has the same mechanism as today)
17:58:50 <cmccann> but I was mostly speaking in general, not that particular trickl
17:58:58 <shachaf> It would be nice if Haskell had an unlifted unit type.
17:59:10 <shachaf> ...Maybe it wouldn't be nice.
17:59:13 <shachaf> That doesn't even make sense.
17:59:36 <cmccann> an unlifted unit type would be nice, because it wouldn't even need a runtime representation :P
17:59:40 <michaelbaker>  /window balance
17:59:55 <Peaker> () :: () ; _|_ :: ()   -- you could have an unlifted one, it just means all pattern matches of () are irrefutable
18:00:23 <dolio> That isn't sufficient.
18:00:23 <Peaker> My comment was unclear, I was trying to demonstrate that it was indeed lifted, so it does make sense
18:00:33 <Peaker> dolio: what am I missing?
18:00:36 <dolio> seq
18:00:40 <edwardk> peaker: but now you expose a ton of implementation details to anyone who wants to use your module. they need to know every module you imported. your cure not only cures nothing, it introduces new complicatons to the disease ;)
18:00:42 <Peaker> screw seq :)
18:00:50 <dolio> It exists.
18:01:08 <Peaker> dolio: not in the hypothetical haskell that has unlifted products :)
18:01:15 <Peaker> (my fictional haskell)
18:01:18 <edwardk> cmccann: newtype ReallyUnit = ReallyUnit ReallyUnit
18:01:28 <dolio> That's not available to program in.
18:01:41 <shachaf> edwardk: That's unlifted in the sense that it's only inhabited by _|_...
18:01:54 <Peaker> edwardk: they already need to know all that -- I just have a way to force the import syntax or placement of constraints
18:01:55 <edwardk> peaker: we eagerly await your implementation
18:01:55 <cmccann> edwardk, can't you still force that and get _|_ out of it?
18:02:23 <cmccann> not by regular pattern matching, obviously
18:02:30 <Peaker> I think unlifted-product-Haskell with Seq-class rather than seq, would be nicer
18:02:48 <edwardk> cmccann: sure, seq will still bomb on it
18:02:54 <shachaf> Peaker: Apparently that class is called Eval.
18:02:59 * cmccann points Peaker to a road sign saying "Agda 2.4 km ==>"
18:03:21 <Peaker> cmccann: more like   2.4 LY ==>
18:03:24 <edwardk> but thats all you can do in kind *. you can probably come up with something in kind # that has no representation like State# RealWorld ;)
18:03:31 <shachaf> GHC autoderives a Show instance for that newtype. :-)
18:04:14 <dolio> shachaf: The seq in Eval was still magic.
18:04:17 <dolio> Worked even on functions.
18:04:17 <edwardk> peaker: well this leads you to weird side-effects like having to reintroduce class contexts on data types =(
18:04:42 <shachaf> dolio: Oh.
18:04:52 <dolio> You could make it not magic, of course.
18:05:25 <dolio> I guess it makes sense that they got rid of the class in that case.
18:05:27 <edwardk> data Eval a => Foo a = Foo !a !a  -- because you need to know you can seq the a.
18:05:42 <dolio> There's really no point in having the class if the implementation is magic enough to use in bad ways.
18:19:20 <mamalujo> hm, so could one hope if enough noise/traffic is made about records, as in the current reddit discussion, something might actually happen? or is this just something that produces such noise every few years to no effect...
18:20:01 <kmc> mamalujo, Hugs already has an extensible records system.  nobody ever talks about it here
18:20:19 <copumpkin> that's cause it's immoral
18:20:22 <mamalujo> I know, but hugs is dead, I gather
18:20:29 <kmc> so? the design is still a design
18:20:36 <kmc> and nobody feels like talking about that design
18:21:08 <edwardk> mamalujo: no, its mostly noise
18:21:39 <cmccann> I'd be more optimistic about record syntax fixes if the primary motivation of many people wasn't trying to find ways to write bad code with familiar idioms
18:22:14 <cmccann> that, and the only approaches that seem satisfactory to me are pretty drastic and thus less likely to be implemented
18:22:29 <mamalujo> true. but yes, I don't know why exactly, but apparently Trex design was described as (too) costly to implement in ghc already in 2003 paper
18:22:52 <mamalujo> sry, proposal, not paper
18:22:54 <edwardk> mamalujo: trex-like approaches mean you wind up paying a lot to do every field dereference
18:23:34 <edwardk> ohori-style records work a lot nicer, but would require a LOT of changes to the way we store data, need hooks into the gc, etc.
18:24:57 <edwardk> and its hard to justify the overhead when one can always make the case that the hlist/oohaskell encoding is available and 'good enough' to satisfy the theory-obsessed, whereas those with less concern for theory lack the requisite background knowledge
18:25:08 <cmccann> I suspect that if someone bashed out a decent implementation as a fork of GHC, put it out there for people to try, and it got positive feedback that'd go a long way toward moving things forward
18:25:16 <kmc> yep
18:25:23 <copumpkin> sounds like something Max Bolingbroke would do
18:25:53 <cmccann> copumpkin, he wrote the Constraint kind stuff, right? :]
18:26:00 <copumpkin> yep
18:26:20 <cmccann> which continues to be awesome, now that I've actually tried it out
18:26:38 * cmccann was unreasonably entertained by making classes and instances for constraints
18:26:45 <edwardk> the constraint kinds are my favorite change since we got type and data families
18:27:05 <cmccann> I mean, just looking at "instance Foo Eq where ..." makes me smile
18:27:11 <edwardk> i'm hoping to exploit them very heavily in my algebra package
18:27:30 <edwardk> Ordered Ring, etc.
18:27:37 <cmccann> edwardk, I actually already had some vague notions bouncing around in my head about that
18:27:46 <cmccann> well, similar uses in corners of my own random libraries
18:27:52 <edwardk> *nods*
18:28:13 <cmccann> but your algebra package also occurred to me as an excellent target for some of this
18:28:19 <edwardk> i had an earlier version that had a hand-hacked user-level version of those things, FooTag, representing a Foo => constraint, etc.
18:28:23 <mamalujo> cmccann, well, fair point, but I'm not sure that enforcing good style is something a lang should strive to do, esp not by eschewing features that are of some importance even in good code. from the trac wiki I gather the motivation of the current discussion was issues encountered in yesoid design, so presumably this is an issue in something decently designed too.
18:28:25 <Nafai> Does anyone here have an example of porting code from using DBus-0.4 to dbus-core or dbus-client?
18:28:25 <edwardk> but it was too cumbersome so i put it down
18:28:38 <edwardk> but the constraint kinds make it a LOT easier
18:28:43 <mamalujo> *yesod
18:28:52 <cmccann> mamalujo, the current design is admittedly kinda terrible, nobody really disagrees with that
18:29:40 <cmccann> the sticking point is lack of agreement on what better approach to use, and motivation to find one given that only some uses and idioms really feel the pain from it
18:30:05 <cmccann> it just doesn't come up that much for a lot of people
18:30:17 <edwardk> mamalujo: honestly lenses have largely relieved the pressures i was feeling towards having a better record system in haskell.
18:30:27 <kmc> records and modules are two places where the Haskell committee decided to go for something simple and conservative
18:30:50 <cmccann> edwardk, the discussion mamalujo is talking about is more concerning namespaces and name clashes
18:31:00 <ddarius> mamalujo: You do realize that you are talking about Haskell.
18:31:01 <ddarius> ?
18:31:04 <kmc> and i think both are reasonable designs if you don't expect much out of it
18:31:18 <edwardk> Once I drop a class HasFoo t where foo :: Lens t Foo I can get in and edit the fields of Foo pretty easily, and deal with multiple-single inheritance pressures, etc.
18:31:36 <cmccann> kmc, they're both local maxima for power vs. complexity. They're just one of the lowest-power maxima :T
18:31:39 <mamalujo> ddarius: sry? you mean re 'enforcing good style' or? I don't think designing a good language is that
18:31:42 <mamalujo> :)
18:32:11 <ddarius> mamalujo: Haskell eschews mutable state which is of some importance even in good code.
18:32:19 <kmc> i think lenses are a good example of how "design pattern" pain points in Haskell get fixed with libraries, even if they're very fancy libraries
18:32:47 <kmc> if GHC tried to solve that problem with a language extension, we might get something worse and we'd be stuck with it
18:33:02 <cmccann> unfortunately modules and namespaces are about as non-first-class as you can get in Haskell, so fixing it with libraries is tricky
18:33:11 <kmc> i'm not super happy that there are 4+ lens libraries on hackage, but it does mean people are exploring this design space quickly
18:33:23 <ddarius> edwardk: That's essentially what I suggested on Greg's blog.
18:33:37 <edwardk> hahah i just spent 15 minutes staring at a line because my brain refused to see that Text/Trifecta/Parser/Language/Monad.hs  and Text/Trifecta/Parser/Layout/Monad.hs are different files
18:33:38 <cmccann> the lens libraries all have virtually identical APIs for the main features as well, which helps
18:34:16 <edwardk> cmccann: well, the design i was working on for data-lens 3.0 or so removes any care for the particular lens implementation
18:34:21 <cmccann> edwardk, if it helps I had to read that three times just now before it registered
18:34:46 <cmccann> edwardk, yeah, it and sounded like a good idea when you mentioned it before :]
18:35:18 <edwardk> i should check back in with the snap guys and see if they got a chance to benchmark
18:36:08 <ddarius> It's starting to actually get cold.  I might have to close one of my windows.
18:36:14 <mamalujo> ddarius: interesting analogy, but its not like hs strives to make effects less practical than it could just so ppl wouldn't use them too much; but tries to make it as practical as possible given a commitment to tracking them in the type system, no?
18:37:16 <cmccann> if Haskell was really serious about making it difficult to write problematic code, it wouldn't have general recursion
18:37:33 <cmccann> which is overrated anyhow
18:37:35 <ddarius> mamalujo: No, I wouldn't say that.  There are also many people that take exactly the first view of Haskell.  The real reason is simply that laziness+side-effects=badness and Haskell was about studying laziness.
18:37:54 <ddarius> cmccann: s/problematic//
18:38:15 <dolio> edwardk: Does the underlying implementation matter that much for people futzing around with the end view?
18:38:20 <cmccann> ddarius, yes, I suppose that was redundant
18:38:35 <mamalujo> right, then you agree :)
18:39:07 <edwardk> dolio: no. i was kinda hoping to just benchmark a bunch of them and pick one or two as winners and move on
18:39:28 <cmccann> also, laziness+side-effects=bad is not limited to Haskell, you can cause yourself massive headaches with various kinds of on-demand evaluation in other languages as well
18:40:15 <dolio> My main problem with HList is that it's a rather ugly mess, not that it's probably also slow for really big records or something.
18:41:09 <cmccann> I don't see any reason HList couldn't be optimized if it was too slow, anyhow. might make it uglier and messier, though...
18:41:43 <dolio> HList records are heterogeneous lists, as the name implies.
18:41:44 <cmccann> though there's really no reason for the ugly mess of something like HList to be visible externally
18:41:52 <kmc> Haskell isn't really "tracking effects in the type system", anyway
18:41:53 <dolio> So accessing the nth piece is O(n).
18:42:04 <adit> Undefined symbols: "_iconv_close"
18:42:16 <adit> Has anyone seen that on a mac?
18:42:34 <cmccann> dolio, right, but no reason you couldn't build a tree instead
18:42:58 <adit> I'm getting that from libHSbase when I try to compile...but I don't see it if I use runhaskell
18:43:10 <cmccann> it would make certain kinds of indexing into the structure trickier, but mostly the ones that aren't practical to use anyhow
18:43:11 <mamalujo> edwardk: I think I saw your comments on some prior record discussion re HList & similar (sry if I'm remembering incorrectly) - you (or that person) seemed to think anything of that kind was just a non-starter as long as it was so slow for big records. But, how much of help would it be required from the runtime/compiler etc to make these fast enough; you almost started explaining earlier?
18:43:53 <mamalujo> I mean, could a substantial portion of that still be libraries, or would that be just building in the extensible record system entirely
18:44:01 <edwardk> mamalujo: well, any such system will have more overhead than the current trivial approach
18:44:13 <shirt> anyone good with haskell-src-exts?
18:44:31 <kmc> just ask your question :)
18:44:39 <shachaf> shirt: "good" in the sense of "had enough"? :-)
18:44:42 <cmccann> the biggest performance hit of doing stuff with HList-ish things is at compile time. at least last time I tried anything complicated, type-hackery gets slow real quick
18:44:55 <mamalujo> hmm
18:44:56 <shachaf> Oh, hello, adit.
18:45:13 <adit> Hello shachaf :)
18:45:23 <edwardk> the ohori-style records basically use some tricky lambdas to figure out field offsets into a buffer of slots. to fit that with ghc you'd need to have a small array-like set of slots, but then you'd want to support unboxed fields like we can support now, so you need gc support, etc.
18:45:41 <shirt> is there a way to get the actual String contents of a SrcSpan?
18:46:43 <mamalujo> i'll google a bit about those, thx
18:46:45 <edwardk> Plus then you'd have to survive the bikeshedding, and the system isn't simple enough to get the other haskell implementations on board even if you built it
18:47:10 <edwardk> MLPolyR is probably your best bet for a well thought out system for extensible records
18:47:37 <edwardk> but you couldn't just lift it up and drop it in haskell
18:48:43 <dolio> Anyhow, whether or not you can make access O(log n) for HList or whatever doesn't really address the problems I have with it.
18:49:11 <mamalujo> well, re bikeshedding and other compilers, I think any more ambitious record system would need to be basically a library. and any sintax would need to desugar into some rebindable functions, so ppl could choose whatever library is fine for them. and something much simpler by default, probably (say lens-based, but that's it)
18:49:34 <cmccann> dolio, what specific problems are those, anyway? I'm curious
18:49:40 <edwardk> well, done right the ohori style records get you toward O(1) access
18:49:41 <rwbarton> my problem with HList is the existence of things with names like TypeCast''
18:49:44 <dolio> That it's a huge type hack.
18:49:59 <dolio> It's impressive that HList is possible, but that doesn't make it a good solution to use.
18:50:02 <cmccann> rwbarton, TypeCast is equivalent to ~, it's not even needed anymore
18:50:07 <edwardk> mamalujo: well then you already have it. HLists exist. they just suck
18:50:30 <edwardk> mamalujo: i know people who are using them to type check sql and do all sorts of crazy things
18:50:45 <edwardk> they also deal with 30 minute compile times
18:50:45 <dolio> It potentially uses a bunch of details of exactly how GHC implements type classes, because that's what oleg does for giggles.
18:50:58 <rwbarton> oh, well that's not so bad then, though does it have an equivalent to /~ also?
18:51:01 <edwardk> forgive me if i'm not in a hurry to sign up ;)
18:51:15 <mamalujo> well, yes, I guess, delta some sugar. but as you say, they aren't that great :)
18:51:21 <cmccann> most of the hackishness of HList could actually be eliminated by removing a few general cases that aren't very useful and cleaning up some of oleg's sillier code
18:51:24 <edwardk> rwbarton: cmccann showed how to build /~ on stack overflow
18:51:39 <kmc> what sugar does fclabels etc need?
18:51:54 <cmccann> of course, /~ still requires type hackery, but it's also nearly useless
18:52:15 <cmccann> and a type equality predicate, instead of a constraint, continues to require oleg's typeeq nonsense
18:52:40 <mamalujo> kmc: not much, just say deriving them w/o TH and silly underscores, and namespaces for labels.
18:52:47 <dolio> So, I don't want a bunch of hacks in a system that wasn't even close to designed for that type programming.
18:53:25 <cmccann> dolio, basically everything useful in HList doesn't require hacks outside the intended use of stuff
18:53:28 <cmccann> at least not these days
18:53:44 <dolio> I want a nicely specified, theoretically grounded record system, with a direct implementation.
18:53:51 <mamalujo> are grapefruit's records as slow at compile time?
18:53:56 <dolio> cmccann: GHC doesn't even have a kind for labels.
18:54:00 <kmc> i'm not sure namespaces for labels is just sugar
18:54:09 <dolio> You just define empty types for that purpose.
18:54:13 <kmc> i do wish Haskell had arbitrarily scoped openable namespaces
18:54:22 <dolio> data MyLabel1 ; data MyLabel2 ; ....
18:54:31 <cmccann> dolio, well, HList isn't really ideal for implementing records in general, if that's what you mean :P
18:54:59 <cmccann> it's just a way to have ad-hoc product types that you can work with recursively
18:55:01 <kmc> cmccann, which instances of writing bad code with familiar idioms relate to records?
18:55:32 <kmc> 'records' is vaguely HList-like and is more record-oriented
18:55:43 <cmccann> kmc, just more "one-size-fits-all" approaches. expecting everything to be records with named fields, instead of structured data
18:55:54 <cmccann> same reason people use head and tail instead of pattern matching on lists
18:56:02 <kmc> hmm
18:56:15 <kmc> i think it's far more common that beginners use type classes when they should be using records
18:56:19 <cmccann> like overuse of type classes, it's a bad habit that people get by trying to impose idioms from other languages without understanding
18:56:34 <kmc> yeah
18:56:35 <cmccann> yes, the type class misuse is more egregious
18:56:40 <mamalujo> kmc: yes, well agreed - I just said any *syntax* better desugar in a rebindable way so ppl could use fclabels or data.record or whatever else - but some support for all or any of them needs to be there - like namespaces, or perhaps whatever gc support is needed for more efficient extensible records etc
18:56:59 <kmc> "extensible records" sounds like subtyping to me
18:57:03 <kmc> and subtyping is a huge can of worms
18:57:09 <kmc> maybe it's unfair to conflate the two
18:57:16 <cmccann> structural subtyping is a really nice idea
18:57:20 <edwardk> kmc: the issue is that a good record system with row types allows you to cons fields, etc.
18:57:21 <kmc> i'm really glad that Haskell has no subtyping
18:57:23 <cmccann> don't know if we want it in haskell, though
18:57:27 <edwardk> kmc: which goes beyond simple subtyping
18:57:40 <kmc> not that subtyping is universally bad, but just that it's nice to see how much you can do without it
18:57:52 <edwardk> addColor c = { color = red .. c }
18:57:56 <edwardk> and the ilk
18:58:21 <cmccann> kmc, anyway, I still like my heavy-handed suggestion of generalizing namespaces :]
18:58:25 <edwardk> er addColor col r = { color = col .. r }
18:58:55 <edwardk> setColor col r = { color = col .. r \ color }
18:59:12 <dolio> I think row polymorphism is generally a lot less problematic than subtyping.
18:59:19 <jsternberg> is there any function already written to enumerate over a list and apply a function to it, while keeping the first value as the first element of a tuple (I'm looking for a function signature of (a -> b) -> [a] -> [(a, b)]
18:59:24 <copumpkin> subtyping is the devil
18:59:32 <edwardk> well, i just mean that neither really subsumes the other
18:59:45 <jsternberg> (I know how to write the function, I just don't want to if it's already been done)
18:59:47 <dolio> As long as you don't try doing union of rows. That's terrible.
18:59:47 <cmccann> subtyping would be less evil if it existed in languages that didn't botch it up badly
19:00:25 <edwardk> java gives me subtyping, but it doesn't make it easy to parametrically add fields to something, the structure of classes is pretty rigid and the shapes of things are known at compile time.
19:00:31 <edwardk> dolio: hahahah
19:00:50 <edwardk> i like inheritance. without mutation its really nice
19:01:41 * cmccann personally likes the idea of defining a subtyping relation by the existence of a conversion to the superclass that preserves uniqueness, and is subject to some sort of reasonable quasi-uniqueness constraints itself
19:02:09 <dolio> In other words, you like coercive subtyping.
19:02:18 <copumpkin> I have a shitty pdf for you, I think
19:02:20 <dolio> Which has a bunch of theory behind it.
19:02:29 <cmccann> copumpkin, do tell
19:02:50 <dolio> I suppose there's theory behind regular subtyping as well.
19:02:56 <cmccann> dolio, mostly I hate purely nominal subtyping. I'm willing to consider most everything else!
19:03:19 <dolio> Although, from what I've skimmed of, say, TAPL....
19:03:33 <dolio> It looks like Pierce just talks about type systems with a subtyping relation.
19:04:03 <dolio> But doesn't get much into theory about, like, how concrete things become subtypes of each other.
19:04:33 <dolio> Which is what actually gets you into problems in Scala and the like, I think.
19:04:35 <wavewave> hi.
19:05:07 <cmccann> I would have assumed Scala to be basically nominal subtypes, since it tries to play nice with java
19:05:29 <wavewave> how can I link external library statically in cabal package?
19:05:54 <wavewave> I have a package with .a but without .dylib
19:06:29 <wavewave> cabal sometimes link it statically, sometimes dynamically..
19:06:31 <monochrom> what does external library mean? c library? haskell library?
19:06:36 <wavewave> c library.
19:06:44 <wavewave> in fact, fortran library
19:07:03 <dolio> Yes, but it has subtyping in places that get in the way in certain situations, at least if you don't really play into the subtyping.
19:07:34 <cmccann> dolio, I'm not aware of nominal subtyping doing anything other than, generally speaking, getting in the way somehow
19:07:46 <cmccann> so that doesn't really surprise me
19:08:12 <dolio> With the standard definitions you get into situations where it can't figure out the type of the equivalent of 'if b then Left 5 else Right "s"'.
19:08:23 <wavewave> link it with extra-libraries: xxx    in .cabal file
19:08:56 <copumpkin> oh I guess luo's book isn't actually about coercive subtyping?
19:08:59 <copumpkin> or is it
19:09:01 <copumpkin> I haven't read it
19:09:17 <wavewave> I think this is potentially a legal problem since static library and dynamic library are differently treated legally in copyright.
19:09:24 <dolio> Because Left 5 has type Left Int B, and Right "s" has type Right A String, A and B both default to a bottom type, and it can't figure out that the common supertype should be Either Int String.
19:09:43 <cmccann> dolio, oh that sounds like all kinds of fun
19:09:47 <dolio> copumpkin: His book doesn't have anything about it as far as I know. Just a bunch of his papers.
19:10:34 <copumpkin> yeah
19:10:34 * cmccann is reading one such paper now trying to see if it matches what he had in mind
19:11:05 <cmccann> so far it seems to be missing one of the constraints I gave but I'm not sure if I'm just missing something there
19:11:24 <dolio> cmccann: Technically, the definition of Either is wrong, because it should have variance specifications, and the constructors should only be parameterized by the argument they take.
19:11:43 <dolio> But that means that you have to be meticulous in thinking about subtyping just to use algebraic datatypes.
19:12:00 <cmccann> dolio, yes, subtyping is much more difficult to use overall
19:12:16 <cmccann> which is proabbly part of why so many languages bungle it badly
19:12:18 <dolio> And Scala technically has GADTs, but they simply fail to work if you do the proper subtyping stuff.
19:12:23 <cmccann> nice
19:13:14 * cmccann skims the paper a bit more
19:14:57 <dolio> Actually, I was thinking a bit....
19:15:12 <dolio> Directed type theory might have some similarities with subtyping.
19:15:18 <dolio> I should really read the papers on it.
19:15:38 <dolio> But, if you have a directed identity type Id A x y....
19:16:03 * ddarius wouldn't call it an "identity type."
19:16:04 <dolio> Then you shouldn't get P x -> P y forall P, as you do with regular identities.
19:16:26 <dolio> You should only get it for covariant Ps.
19:16:33 <dolio> And get P y -> P x for contravariant Ps.
19:16:58 <dolio> Make up your own name for the directed equivalent of an identity type, then.
19:17:54 <cmccann> what's directed type theory?
19:18:40 <dolio> It's what you get when the identity types don't allow you to get Id A y x from Id A x y.
19:18:56 <dolio> Essentially.
19:19:33 * cmccann isn't sure what the notation being used there means in context
19:20:03 <ddarius> Get ye to a Martin Lfery!
19:20:26 <dolio> cmccann: You know what a groupoid and a category are?
19:20:40 <ddarius> dolio: That's an interesting tack to take.
19:20:48 <cmccann> dolio, sure
19:21:15 <dolio> Types in type theory have a groupoid-like structure, with the arrows being identity types.
19:21:43 <cmccann> hm, ok
19:21:45 <dolio> For any two elements x, y : A, there's an identity type Id A x y.
19:21:59 <dolio> Which one normally thinks about as x and y being equal.
19:22:14 <dolio> But there's other schools of thought developing.
19:22:59 <dolio> The groupoid-ness comes from every p : Id A x y having an inverse sym p : Id A y x.
19:23:04 <dolio> If x = y then y = x.
19:23:35 <cmccann> hm
19:23:42 <dolio> Directed type theory is what you get when you consider that types might just have category structure, not groupoid structure.
19:23:58 <Saizan> mny question is, in directed type theory can you also talk about equality?
19:24:07 <cmccann> in some ways that almost sounds closer to what I had in mind than this coercive subtyping stuff does
19:25:01 <ddarius> Saizan: Why wouldn't you be able to?
19:25:04 <dolio> (Small) types with subtyping are probably an example of a (large) directed type.
19:25:59 <Saizan> ddarius: i need a type for it, unless Id A x y /\ Id A y x can be a valid replacement
19:26:19 <dolio> Looks all right to me.
19:26:38 <dolio> Except the Id part, if that isn't your bag.
19:28:22 <dolio> Well, I suppose it might not be.
19:29:12 <dolio> You'd need a superior eliminator than you could get with my naive two functorial versions above.
19:30:04 <dolio> Because being able to get P x -> P y for covariant P and P y -> P x for contravariant P doesn't imply that you can get P x -> P y for all P.
19:30:05 <Saizan> yeah, otherwise you need a decider for the variance of P
19:30:20 <dolio> Some P might not have either variance.
19:31:20 <Saizan> yeah, also i still wouldn't always get P x -> P y
19:31:55 <dolio> You need the 'exponential' eliminator.
19:31:57 <ddarius> Σf : Hom A x y. Σg : Hom A y x. f ∘ g = id ∧ g ∘ f = id
19:32:30 <ddarius> Er, s/Σ/Π/
19:32:56 <ddarius> Well, the second Σ
19:33:13 <ddarius> er first
19:33:21 <ddarius> Jesus Christos
19:33:49 <EvanR> im trying to represent a subset of real numbers with a data structure such that each element has exactly one unique respresentation. the set is reals between 0 and 1 of the form n/10^m
19:34:34 <cmccann> continued fraction representations are often unique
19:34:56 <cmccann> depending on the scheme used
19:35:02 <ddarius> http://www.cs.bham.ac.uk/~mhe/papers/lics2001-revised.pdf is probably not useful for you, but I felt like referencing it anyway.
19:35:21 <roconnor> if you have unique representations of real numbers then addition is uncomputable
19:35:22 <copumpkin> isn't that a subset of rationals, even?
19:35:31 <EvanR> yes
19:35:48 <copumpkin> so none of the ugly real issues
19:35:56 <roconnor> whew
19:36:04 <EvanR> not even any repeating decimals ;)
19:36:19 <ddarius> Actually, what I referenced could be used for that by instead of having a "midpoint" operation you formulate something more "decimal."
19:36:20 <EvanR> so it should be easy
19:36:21 <monochrom> (n,m) seems to be a fine representation
19:36:29 <copumpkin> EvanR: can't you just store it as an Integer?
19:36:35 <copumpkin> well, a single natural
19:36:40 <monochrom> for individual numbers anyway. not sure about a wholesome subset
19:36:47 <ddarius> monochrom: (10, 1), (1, 2)
19:37:08 <EvanR> i should have said, in haskell
19:37:10 <ddarius> So you need to restrict n to be 0-9
19:37:23 <copumpkin> data EvanR = EvanR Natural
19:37:31 <copumpkin> where said natural is interpreted as something with a dot in front of it
19:37:35 <EvanR> ok
19:37:38 <copumpkin> and you have a distinguished value for 1
19:37:38 <cmccann> roconnor, I think it's possible to get addition that works in all but carefully pathological cases, though
19:37:39 <EvanR> thats missing 1.000000
19:37:42 <ddarius> Even then, 0 is not uniquely representable, so you'd need to restrict 1-9 and handle 0 specially.
19:37:55 <copumpkin> so Maybe Natural
19:38:03 <copumpkin> where Nothing = 1
19:38:16 * EvanR thinks to make sure that works
19:38:34 <ddarius> copumpkin: You should briefly check out the paper I linked abovee
19:39:07 <EvanR> im looking at the paper
19:39:46 <EvanR> copumpkin: is it possible to add them somehow?
19:39:58 <copumpkin> ddarius: looks interesting :) but is it relevant to EvanR's question?
19:40:20 <copumpkin> EvanR: I'm sure it is, but it might be tricky :P and of course addition isn't closed
19:40:23 <copumpkin> multiplication is though
19:40:38 <ddarius> copumpkin: Possibly, but I waived relevance when I posted the link.
19:40:43 <EvanR> addition isnt closed, thats ok
19:40:45 <copumpkin> ddarius: true that
19:40:51 <copumpkin> so hmm
19:41:15 <copumpkin> to add them, you'd need to shift then add, a bit like what they do for floats
19:41:18 <EvanR> if you add 8/10 to 8/10 ... ERROR
19:41:29 <copumpkin> it sounds a little hairy
19:41:56 <EvanR> ewwuuhg... shift then add ? :)
19:42:10 <copumpkin> trying to think
19:42:20 <EvanR> or do they just add
19:42:42 <EvanR> if you get 10 -> Nothing
19:42:43 <copumpkin> no, because having "more digits" makes you more important
19:42:53 <EvanR> oh
19:42:56 <EvanR> shift the other way
19:43:35 <copumpkin> oh wait, hmm
19:44:08 <copumpkin> say you have 0.49 and 0.5
19:44:09 <EvanR> also what does 1000 mean
19:44:12 <copumpkin> > 49 + 5
19:44:13 <lambdabot>   54
19:44:25 <copumpkin> EvanR: gah, there goes your unique representation :P
19:44:25 <EvanR> im thinking its leaking representations
19:44:35 * copumpkin pulls out his quotienting axe
19:44:38 <copumpkin> BAM
19:44:51 <copumpkin> there, 10 == 100 == 1000 and so on
19:45:01 <EvanR> this rep is now questionable
19:45:06 * copumpkin weeps
19:45:11 <EvanR> back to the drawing board
19:46:10 <EvanR> i stumped #haskell
19:46:21 <tgeeky> EvanR: what are we working on, I just joined?
19:46:25 <tgeeky> numeric representation?
19:46:26 <cmccann> EvanR, achievement unlocked!
19:46:47 <copumpkin> > 1 : fix ((1 % 1 :) >=> \x -> [1+x, 1 / (1 + x)])
19:46:48 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
19:47:23 <EvanR> i want a haskell data structure to represent numbers between 0 and 1 of the form n/10^m, where each element has exactly one unique representation (no invalid things, no duplicates)
19:47:31 <cmccann> copumpkin, isn't that the encoding someone posted on reddit a while ago?
19:47:46 <copumpkin> of what?
19:48:13 <cmccann> the 1+x, 1/(1+x) thing to represent numbers
19:48:17 <tgeeky> EvanR: try doing it using the polynomial of the smallest salem number :o
19:48:21 <tgeeky> http://en.wikipedia.org/wiki/Salem_number
19:48:30 * EvanR checks
19:49:04 <tgeeky> x^10 + x^ 9 - x^([7,6,..3]) + x +1
19:50:16 <tgeeky> that would be pretty specific to x^10
19:51:04 <EvanR> the smalleset known salem number. got it. how does this help?
19:51:42 <tgeeky> bird's pearls book has a function: i :: Integral a => ((a, a) -> a) -> a -> [(a, a)]
19:51:46 <tgeeky> that's very fast
19:51:49 <tgeeky> you could try to invert it
19:51:57 <tgeeky> (n/x^10)
19:52:00 <ddarius> I already gave a representation.
19:52:03 <tgeeky> err, the other way around
19:52:14 <tgeeky> ddarius: an exact soluton?
19:52:18 * EvanR checks ddarius
19:52:41 <ddarius> Maybe (D10, Natural)
19:52:54 <EvanR> ok, that doesnt satisfy uniqueness
19:53:10 <ddarius> EvanR: Why not?
19:53:32 <ddarius> Though, it should be D9 since I only want 1-9 not 0-9.
19:53:56 <EvanR> ok nevermind
19:54:04 <EvanR> so how would you show 0.93
19:55:08 <ddarius> Curses.
19:55:25 * monochrom recurses
19:55:30 <EvanR> lol
19:55:33 * ddarius ncurses.
19:55:56 * monochrom ωcurses
19:56:32 * cmccann prefers to corecurse
19:56:42 <copumpkin> Maybe (m : Fin (10^n), n : 10^n), interpreted as suc m / n, with 0 = nothing
19:56:52 * monochrom is plagued by ordinals smaller than ϵ0 lately
19:57:01 <copumpkin> you can represent all that in haskell with enough pain
19:57:15 <copumpkin> I mean
19:57:18 <EvanR> what language is that
19:57:20 <copumpkin> not that
19:57:37 <copumpkin> Maybe (m : Fin (10^n), n : Nat), interpreted as suc m / 10^n, with 0 = nothing
19:57:42 <copumpkin> EvanR: no real language
19:58:02 <EvanR> whats Fin
19:58:23 <ddarius> Maybe ([D9], Natural)
19:58:42 <copumpkin> ddarius: then you can have way more digits in the numerator than the denominator allows
19:58:57 <EvanR> also whats Just ([0], 1)
19:58:58 <copumpkin> you could have a numerator with infinite digits!
19:59:06 <cmccann> copumpkin, that's the best kind
19:59:06 <ddarius> 0 isn't a D9
19:59:09 <EvanR> er
19:59:28 <EvanR> then where is 0.101
19:59:37 <ddarius> Curses.
19:59:49 <monochrom> i have a better idea. represent it in hardware, then add a primop to GHC
19:59:55 <cmccann> ok
19:59:56 <copumpkin> EvanR: I'm gonna write mine in agda and then you can translate it to haskell
20:00:04 <EvanR> lol
20:00:23 <cmccann> but don't hold your breath, it'll probably take a few hours to compile
20:00:38 <EvanR> about your original complain with the infinite numerator, is there a 'finite list' in haskell?
20:00:49 <ddarius> No.
20:00:53 <copumpkin> make a tail-strict list
20:00:58 <copumpkin> it's sort it
20:01:01 <copumpkin> sort of it
20:01:01 <monochrom> you can make one, but I doubt its value
20:01:13 <monochrom> it's sod it, really
20:01:19 <cmccann> EvanR, the usual implemention is something like "[a] -- n.b. this should be finite"
20:01:26 <EvanR> nice
20:01:56 <ddarius> Yeah, copumpkin's solution is pretty much there, as there as you'll get in Haskell.
20:02:26 * monochrom has long embraced that you can't use merely algebraic data types to represent everything uniquely, you have to accept data invariants and quotients etc
20:02:50 <ddarius> Maybe ([D10], D9)
20:02:52 <cmccann> you can also make a finite list by encoding the list length in the type. infinite types are rejected, so you're safe there
20:03:03 <cmccann> actually using such lists is left as an exercise for the reader
20:03:22 <EvanR> ddarius: o_O
20:03:47 <copumpkin> http://snapplr.com/m9c1
20:04:00 <kmc> if all you care about is that it's finite, can't you hide the length parameter under an existential?
20:04:33 <copumpkin> it's also gotta be shorter than the denominator
20:04:38 <cmccann> kmc, possibly. not sure how that would work out.
20:04:52 <monochrom> an array has finite size
20:04:56 <copumpkin> EvanR: you see that?
20:05:05 <EvanR> copumpkin: i see it, i dont know what it says
20:05:08 <EvanR> Fin?
20:05:14 <copumpkin> Fin 3 = 0, 1, 2
20:05:20 <copumpkin> Fin 5 = 0, 1, 2, 3, 4
20:05:39 <ddarius> The D10 is 0-9, the D9 is 1-9, Nothing is 0, you may need to switch to Either Bool to get 1 though.
20:05:53 * tgeeky doesn't buy this being best
20:06:15 * cmccann votes just use floating point values and vigorous hand-waving
20:06:16 <EvanR> ddarius: is the D9 the order? what about 0.1234567891 ?
20:06:25 <ddarius> EvanR: No, D9 is the last digit.
20:06:27 <EvanR> cmccann: lol
20:06:28 <tgeeky> cmccann: I figured that's what would be the "solution"
20:06:35 <EvanR> ddarius: ooooh
20:06:36 <tgeeky> but this is somehow more disappointing :o
20:06:40 <copumpkin> oh, clever
20:07:11 * EvanR pours water in and sees if anything leaks
20:07:13 <copumpkin> so you might as well just use the representation I was talking about before
20:07:19 <tgeeky> EvanR: is this a [general, class, solved, unsolved, ...] problem?
20:07:21 <copumpkin> with a natural
20:07:32 <EvanR> tgeeky: no idea, i just made it up
20:07:33 <copumpkin> a list of D10 is basically a natural
20:07:48 <copumpkin> then you stick an artificial digit on the end and have distinguished 0 and 1
20:07:57 <monochrom> except that you can't tell 0 from 000 in naturals
20:08:03 <copumpkin> oh, true
20:08:03 <tgeeky> copumpkin: yes, but one can also just as easily have a distinguished 0 and 9
20:08:08 <ddarius> copumpkin: Yeah, [D10] could be replaced with a Natural that represents its successor.
20:08:18 <tgeeky> copumpkin: so that's not unique
20:08:41 <EvanR> copumpkin: also theres no natural for 'nothing'
20:08:53 <EvanR> Just ([], 1)
20:09:45 <EvanR> so Either Bool ([D10], D9)
20:10:00 <EvanR> gnarly?
20:10:35 <copumpkin> why Bool then?
20:10:40 <copumpkin> and not just Maybe
20:10:44 <EvanR> because i dont see a way to have 0 or 1
20:10:49 <tgeeky> http://www.wolframalpha.com/input/?i=x+%2F+10^y
20:10:58 <copumpkin> EvanR ([], 1)
20:11:00 <copumpkin> you just gave it
20:11:01 <tgeeky> that is the fuctiion of interest, yes?
20:11:05 <EvanR> thats 0.1
20:11:07 <copumpkin> oh yeah
20:11:30 <EvanR> tgeeky: interesting function for certain values of x and y ;)
20:11:42 <dobblego> I'm sure it is asked regularly, but does anyone got a haskell->javascript compiler that produces usable output yet?
20:11:58 <tgeeky> dobblego: ghcjs, ask chrisdone
20:12:04 <tgeeky> dobblego: otherwise jmacro
20:12:10 <dobblego> great thanks
20:12:11 <tgeeky> (which is not a compiler, but a template haskell thing)
20:12:27 <c_wraith> Isn't UHC's js backend useable, also?
20:12:38 * tgeeky knows nothing about except GHC
20:12:52 * hackagebot trifecta 0.45 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.45 (EdwardKmett)
20:13:06 <kmc> meh, i want a postmodern parser combinator library
20:13:18 <tgeeky> EvanR: In all seriousness, you may very well be able to *exactly* solve this
20:13:26 <tgeeky> without using the naturals :O
20:13:45 <c_wraith> kmc: how would you ever know if it was working as designed?
20:13:59 <edwardk> kmc: its called Read ;)
20:14:10 <ddarius> c_wraith: You wouldn't ask such questions.
20:14:15 <EvanR> tgeeky: but when x < 10^y and x is natural and y is natural, the points on the surface arent 1 to 1 with the suspects
20:14:41 <EvanR> theres duplicates
20:14:45 <monochrom> postmodern parsers and grammars belong to no one
20:14:50 <EvanR> 10/100 1/10
20:17:52 * hackagebot netwire 1.2.5 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.5 (ErtugrulSoeylemez)
20:17:54 * hackagebot webwire 0.1.0 - Functional reactive web framework  http://hackage.haskell.org/package/webwire-0.1.0 (ErtugrulSoeylemez)
20:26:02 <djahandarie> Hmm, is there a dead-simple library for ICMP echo requests?
20:29:05 <miyako> hello
20:29:34 <EvanR> ddarius: so, in your ([D10],D9) is it possible to use Natural somehow
20:29:46 <EvanR> to help with addition
20:30:35 <copumpkin> Maybe (Natural of leading 0s, Natural of "significand", last digit) ?
20:30:50 <copumpkin> I guess you have some overlap there
20:30:55 <copumpkin> might need some successor somewhere
20:31:39 <copumpkin> or just Natural of leading 0s, Natural of significand (interpreted as +1) ?
20:31:56 * copumpkin shrugs
20:32:22 <miyako> anyone mind helping me figure out what's going awry with my xmonad config?
20:33:04 * cmccann has never used xmonad
20:33:35 <miyako> https://github.com/timskinner/xmonad/blob/master/xmonad.hs config file is there.  The result of getVimResizeMap does not seem to be correct
20:34:02 <miyako> cmccann: I suspect its a haskell problem more than an xmonad problem
20:34:37 <EvanR> copumpkin: actually a natural might make more theoretical sense, given [D10] ability to be infinite ;)
20:35:21 <cmccann> miyako, what's it doing incorrectly?
20:35:28 <ddarius> Yes, copumpkin's description was what I was thinking of earlier when he suggested replacing the [D10] with Natural.
20:35:59 <copumpkin> so this can be reduced to Zero | One | SomethingInBetween Natural Natural ?
20:36:02 <edwardk> gah, forgot to package a few files with that last release =/
20:36:13 <miyako> cmccann: it seems like the call to getVimResizeMap is always returning vimResizeMap even when it should return vimResizeMapMirror
20:36:25 <cmccann> edwardk, a perfect excuse to reupload and keep bumping that version number
20:36:30 <edwardk> yep
20:36:51 <ddarius> copumpkin: Not with a direct mapping from the previous representation.
20:37:17 <copumpkin> no?
20:37:23 <cmccann> miyako, that suggests the compareLayouts expression is always returning False, then
20:37:24 <miyako> when I switch the layout to mirrorTall XMonad should call keysList with mirrorTall and get back a list of keymappings
20:37:26 <EvanR> copumpkin: Natural Natural, except the second natural could be 1 10 or 100...
20:37:40 <miyako> cmccann: according to ghci it seems to be working properly
20:37:47 <copumpkin> EvanR: the second natural is interpreted to be +1
20:38:00 <copumpkin> oh
20:38:08 <copumpkin> still doesn't fix it, does it
20:38:09 <EvanR> 2 11 or 101 ?
20:38:16 <copumpkin> 0, 9, or 99
20:38:17 <copumpkin> :P
20:38:31 <copumpkin> okay, so two naturals and a digit?
20:38:41 <EvanR> interesting
20:38:49 <EvanR> should be fun to add ;)
20:39:05 <ddarius> copumpkin: Yes.
20:39:11 <miyako> the two likely scenarios seem to be that either ghc is optimizing my call to getVimResizeMap and always returning vimResizeMap, or that XMonad isn't calling keysList when I think it should
20:39:21 <copumpkin> EvanR: I'll leave that beauty to you
20:39:53 <cmccann> miyako, I don't think that would be an optimization if it gave incorrect results :]
20:40:32 <miyako> cmccann: true, but I haven't been using haskell that long so I wondered if I might be using the language incorrectly ;)
20:40:48 <EvanR> copumpkin: in light of serialization and deserialization, which has unavoidable 'invalid representations (parse errors)', it seems like the following is a better rep
20:40:49 <cmccann> probably better off asking someone familiar with xmonad
20:40:52 <EvanR> "0"
20:40:53 <EvanR> "1"
20:40:57 <EvanR> "0.5234"
20:40:58 <EvanR> ;)
20:41:22 <miyako> yeah, I tried #xmonad first but everyone seemed to be afk so I thought I'd try here on the off chance someone knew
20:41:29 <miyako> thanks for at least giving it a shot :)
20:41:29 <EvanR> (troll haskell)
20:42:05 <copumpkin> EvanR: :P
20:42:27 <cmccann> miyako, if you hang around a bit you might catch someone, but nothing obvious jumps out at me (with the caveat that it's after midnight and I've never used xmonad)
20:43:57 <miyako> cmccann: I'll stick around for a bit- I try not to idle here too long, the sorts of questions other people ask tends to make me feel quite dumb :P
20:44:42 <cmccann> miyako, I think almost everyone feels that way in here sometimes :P
20:44:52 <cmccann> ddarius probably doesn't. but everyone else
20:45:30 <djahandarie> I'm sure there is some question that could make ddarius feel dumb
20:45:47 <djahandarie> Like, "What question would make ddarius feel dumb?"
20:46:23 <miyako> I swear one day I'm going to come in trying to figure out why my indentation is wrong and someone will be asking how to get haskell to format their proof that P = NP just right
20:46:48 <cmccann> haha
20:47:23 <djahandarie> PeqNP = undefined
20:48:56 <miyako> still, I do feel that haskell has helped me be smarter, and I finally got to use it at work the other day
20:49:13 <cmccann> oh?
20:49:28 <djahandarie> Something that many of us still strive to do
20:50:03 <miyako> yeah, nothing big, just used System.INotify to throw together a program to watch a bunch of files and print out when they were accessed
20:50:24 <cmccann> I've done similar stuff
20:50:29 <miyako> but they gave me 2 hours to do it, and I got it done in 30 minutes, so +1 for haskell
20:50:42 <cmccann> couple little haskell programs floating around the office that I wrote as quick one-off hacks
20:50:53 <cmccann> that of course are still being used because one-off hacks always are
20:51:29 <miyako> I figured a one-off hack done in haskell is slightly less likely to come back and bite me later compared to a quick one-off hack written in C
20:52:02 <cmccann> at least one was a bit of convoluted data munging to get something into a format that Expensive Machines can use which saved the company a crapton of money due to not having to send the jobs off to people who had slightly different kinds of Expensive Machines available
20:52:06 <cmccann> that was pretty fun
20:52:07 <jsternberg> well, I can make miyako feel a little smarter with a dumb question
20:52:15 <jsternberg> is there an equivalent of mapM for Data.Map?
20:52:28 <cmccann> jsternberg, equivalent in which way?
20:52:39 <copumpkin> traverse
20:52:42 <jsternberg> one that operates on a Map
20:52:47 <cmccann> that is, do you want the Map to replace the monad or the list
20:52:59 <miyako> I actually did a pretty substantial project at my last job in Haskell, but then I got laid off.
20:53:29 <copumpkin> :t Data.Traversable.traverse `asTypeIn` \t -> t id M.empty
20:53:30 <lambdabot> forall (f :: * -> *) b k. (Applicative f) => (f b -> f b) -> M.Map k (f b) -> f (M.Map k b)
20:53:32 <blackdog> cmccann: they're kind of easier to package, i find.
20:53:43 <copumpkin> :t \f -> Data.Traversable.traverse `asTypeIn` \t -> t f M.empty
20:53:44 <lambdabot> forall a (f :: * -> *) b k. (Applicative f) => (a -> f b) -> (a -> f b) -> M.Map k a -> f (M.Map k b)
20:53:52 <blackdog> had a similar sort of program written in perl and run on windows at my last job that was the bane of my existence...
20:53:52 <copumpkin> whoops
20:54:20 <copumpkin> anyway, you get the idea
20:54:27 <jsternberg> cmccann: I don't know... I just want to be able to apply a function to every element in the map, and have a map come out with the changed data
20:54:52 <cmccann> yeah, my reasoning was pretty much the same as miyako's, figured that since it'll hang around and keep being used but officially nobody cared about a cheap hack, might as well save myself some future headaches...
20:55:12 <jsternberg> and the action that is occurring inside of the function is an IO action (I need to read from disk)
20:55:17 <blackdog> jsternberg: fold?
20:55:42 <blackdog> wait, i mean Data.Map.map...
20:56:02 <blackdog> (you're mapping over values only, right?)
20:56:03 <cmccann> jsternberg, ok, then see what copumpkin said above
20:56:22 <blackdog> ah, missed the io
20:56:52 <siracusa> Any UTF-8 experts arround? The utf8-string package yields toString (fromString "\xD800")  ==>  "\xFFFD" which I don't understand. All characters \xD800 to \xDFFF are marked as error. Is that correct?
20:57:44 <kmc> there are no characters from \xD800 to \xDFFF
20:58:33 <kmc> really it should be a compile-time error to use such an escape in a string literal
20:59:17 <jsternberg> that seems to be what I want, too bad I just realized that mapM isn't what I wanted to begin with >_<
20:59:18 * cmccann would love to be able to have compile-time errors for overloaded literals based on value
20:59:42 <copumpkin> cmccann: come to #agda ;)
20:59:48 <copumpkin> not real literals
20:59:52 <siracusa> kmc: Aha, so the problem is that already "\xD800" is already wrong?
20:59:59 <copumpkin> but # 4 will turn yellow if it won't fit the Fin
21:00:09 <copumpkin> there's talk of making real literals, too
21:00:26 <kmc> siracusa, yeah, but Haskell (or at least GHC) erroneously accepts it
21:00:31 <cmccann> copumpkin, I dunno, I still like running programs :P
21:00:39 <cmccann> and compiling them in less than an hour
21:00:45 <siracusa> I see
21:00:48 <kmc> there are no Unicode characters in that range
21:01:10 <kmc> the corresponding 2-byte sequences are used in pairs in UTF-16 to encode code points larger than 16 bits
21:01:24 <cmccann> you know what really annoys me? as far as I can tell, when fromInteger is used to handle literals, it will only ever be applied to positive numbers
21:01:30 <cmccann> so it could easily have been fromNatural
21:02:19 <cmccann> but no, and the type is fixed to take an Integer, and if you use rebindable syntax you have to use that name
21:02:38 <copumpkin> yeah
21:02:39 <cmccann> so you can handle natural literals safely, but only by having a function named fromInteger in scope to do it
21:02:43 <copumpkin> they construct Integers in a funky way
21:03:03 <copumpkin> for literals
21:03:04 * cmccann rants more
21:03:24 <cmccann> I want natural numbers, is that so much to ask
21:03:29 <miyako> I want a really good haskell wallpaper
21:03:56 <cmccann> GHC is probably going to have type-level naturals before it has sensible term-level naturals, I mean seriously, WTF guys :[
21:04:17 <kmc> miyako, i recommend the word "HASKELL" in huge Comic Sans letters in bright yellow on a bright blue background
21:04:35 <cmccann> kmc, gotta toss a lambda or two in there
21:05:26 <miyako> kmc: what about "lolhaskell" in pink on a green background?
21:05:37 <kmc> sounds good to me
21:05:49 <KirinDave> kmc: Don't forget the comic sans.
21:05:52 <dalaing> maybe an animated gif that alternates between the two
21:05:59 <shachaf> KirinDave: I don't believe kmc did.
21:06:26 * cmccann makes crudely drawn commutative diagrams with grammatically mangled captions
21:06:28 <cmccann> lolcategory theory
21:06:36 <KirinDave> I'm having trouble lining up some types on a piece of iteratee code.
21:07:04 <copumpkin> @quote moarphisms
21:07:04 <lambdabot> tensorpudding says: lolcategory demands moarphisms
21:07:15 <cmccann> hahaha
21:07:23 <KirinDave> How am I supposed to use my wrapping monad in iteratee?
21:07:23 <mamalujo> rofl
21:07:24 <KirinDave> https://gist.github.com/fca51d09d697dd697b06
21:07:51 <kmc> this paper "Yield: Mainstream Delimited Continuations" is like... anthropology
21:08:03 <cmccann> kmc, haven't looked at it yet, how so?
21:08:19 <kmc> PL theorists descend into the untamed jungle of "mainstream languages", figure out what all those Real Programmers are doing, then un-fuck the theory and reimplement it in Haskell
21:08:56 <cmccann> haha
21:09:42 <KirinDave> Anyone have any idea how I line that up?
21:10:08 <dalaing> no google results for "i put an endofunctor in your endofunctor"
21:10:11 <cmccann> kmc, in the process turning something that a bunch of programmers use but don't really understand into abstractions that a bunch of academics understand but don't use, right? :P
21:10:24 <shachaf> dalaing: I would've said "keep it that way", but it's too late.
21:10:38 <kmc> exactly
21:10:53 <dalaing> 2000+ results for lolcategory, I had to know
21:11:06 <kmc> @quote lolcategory
21:11:06 <lambdabot> tensorpudding says: lolcategory demands moarphisms
21:11:34 * cmccann once had some abstract algebra-ish type classes in a library where one was documented as "yo heard you like multiplication so we put a ring over your ring so you can multiply while you multiply"
21:11:37 <copumpkin> dalaing: I used to own (or maybe still do) 2naturaltransformations1functor
21:11:40 <copumpkin> .com
21:11:55 <cmccann> copumpkin, ahahaha
21:12:11 <dalaing> and I figured if someone had done something with endofunctor the punchline would be something I was unfamiliar with and could google to extend my mental concept coverage
21:17:17 <dalaing> on reflection that's a pretty good summary with where I am with Haskell - randomly googling stuff to try to work out if I've heard of some decent proportion of the concepts
21:19:11 <miyako> learning haskell has made me want to study category theory
21:19:22 <dalaing> it's been fun, but I'm starting to get paranoid that I might end up learning the concepts at a slower rate than they get developed
21:20:04 <cmccann> dalaing, nah, once you reach a certain critical mass of understanding that's not a concern
21:20:26 <cmccann> then the problem just becomes the sheer amount of things you could be learning :]
21:20:32 <kmc> "To be presented at Continuation Workshop 2011"  o_O
21:20:46 <cmccann> people could stop creating new concepts tomorrow and it'd still take forever to catch up :T
21:20:52 <kmc> i called those guys but they never returned
21:21:49 <shachaf> kmc: I think you're supposed to provide the callback.
21:21:59 <ddarius> cmccann: So instead of just killing people, you need to kill concepts too.
21:22:01 <miyako> I need to go back to school and get a real CS degree
21:22:18 <ddarius> miyako: Why?
21:22:19 <cmccann> ddarius, a promising strategy. not sure how to do that though.
21:22:49 <dalaing> one day, when I'm confident I'm mostly caught up, I'll put together some kind of documentation on the bits and pieces I've come across
21:23:01 <cmccann> miyako, that's expensive and probably slower than learning it independently, assuming a sensible strategy for the latter
21:23:02 <KirinDave> Okay, got it to compile.
21:23:11 <miyako> ddarius: I enjoy CS, but I feel like there are things I'm missing out on by being self-taught, and I'd eventually like to get a masters degree in CS, but with a BS in CIS I doubt I'd get into a CS masters program
21:23:15 <KirinDave> Man, writing monadic code meant to be used in the MIDDLE of a monad stack is _difficult_
21:23:33 <ddarius> miyako: You're totally missing out on incurring significant life-crushing debt.
21:23:54 <KirinDave> I guess if you have your own state, you _must_ newtype it, then make your own custom class and custom lift method?
21:23:56 <dalaing> depends on the country you're in, right?
21:23:57 <shachaf> Does getting a CS degree typically involve that?
21:24:14 <KirinDave> shachaf: I couldn't go for a phd because of my debt
21:24:29 <KirinDave> shachaf: After all, in America you're free to let the market decide if you finish school.
21:24:40 <cmccann> setting foot in a university at all typically involves crushing debt in the USA
21:24:44 <miyako> ddarius: well, I have a degree, so hopefully I won't have to retake a bunch of classes, and work will pay for a few classes a year, so not much more debt, and I can make more with a masters degree
21:25:13 <KirinDave> At least a reasonably taleneted software engineer can hope to cover $50k USD of debt within 5 years in the US
21:25:34 <kmc> KirinDave, http://tomschrijvers.blogspot.com/2010/03/bruno-oliveira-and-i-are-working-on.html
21:25:35 <dalaing> I got an Australian degree and it didn't cost too much, PhD didn't cost anything, just needed a scholarship in order to eat and pay rent
21:25:51 <kmc> mind you, this might be a cool solution for the wrong problem
21:26:01 * cmccann managed to BS through his BS degree with a scholarship and ended with no debt (and little knowledge)
21:26:35 <KirinDave> kmc: Am I going to regret the theoretical door this is gonna open for me
21:26:47 <KirinDave> kmc: I am still struggling to learn how to use comondas.
21:26:56 <KirinDave> s/monda/monad/
21:27:00 <shachaf> KirinDave: First learn how to use regular mondas.
21:27:06 <ddarius> comoderos
21:27:11 <shachaf> A monad is like a burriot.
21:27:14 <confab> cmccann, in what field?
21:27:15 <shachaf> s/ad/da/
21:27:16 * shachaf sighs.
21:27:32 <cmccann> comonads are pretty much like monads, except in an evil mirror universe
21:27:38 <miyako> I think I understand monads, but I haven't actually implemented any myself yet so I'm not sure
21:27:38 <cmccann> so basically just grow a goatee and you're set
21:27:45 <edwardk> its not evil
21:27:48 <edwardk> wait. i have a goatee
21:27:51 <cmccann> hahaha
21:27:52 * hackagebot dingo-core 0.0.2 - Dingo is a Rich Internet Application platform based on the Warp web server.  http://hackage.haskell.org/package/dingo-core-0.0.2 (BardurArantsson)
21:27:55 <edwardk> i guess i am the evil mirror universe me
21:27:56 <KirinDave> shachaf: I mean, with the exception of this "float in the middle of the stack" thing that iteratees are introducing, I think I have them basically down.
21:28:12 <dalaing> miyako: I'm in the same place with comonads (and half a dozen other things)
21:28:17 <shachaf> KirinDave: (I was only making a joke about "mondas".)
21:28:34 <cmccann> confab, computer science
21:28:38 <shachaf> I have the feeling moand transformers are wrong somehow.
21:28:40 <KirinDave> my bad.
21:28:41 <kmc> edwardk is self-dual, like a photon
21:29:01 <miyako> well it's going on 1am so I suppose I should get to bed
21:29:02 <ddarius> Just like photons are powered by Diet Coke.
21:29:05 <miyako> g'nite all
21:29:10 <KirinDave> If you are not trying to live in the middle of a stack (i.e., write composable code), I rather like monad stacks.
21:29:14 * edwardk does the wave.
21:29:20 <KirinDave> I still don't really know how to make a reusable transformer.
21:29:47 * cmccann has pretty much decided that doing anything nontrivial with monad transformers leads to the Pit of Despair
21:29:59 <kmc> there is only one electron; it moves back and forth between the beginning and end of time, and when it's going backwards it's a positron
21:30:28 <ddarius> kmc: Consequence: We are all the same person.
21:30:47 * shachaf isn't sure how that's a consequence.
21:31:41 <kmc> i am he as you are he as you are me and we are all together
21:32:43 * cmccann decides that kmc singing a beatles song is a good sign that it's time to call it a night
21:33:22 <kmc> no i was just quoting
21:33:25 <kmc> singing would be:
21:33:28 <kmc> ♫ i am he as you are he as you are me and we are all together ♫
21:33:31 <cmccann> ok
21:33:47 <cmccann> anyway, I'm out, seeya folks :P
21:33:59 <kmc> ♫♬♩♪
21:34:01 <kmc> see ya cmccann
21:34:17 <shachaf> kmc sure enjoys his mpose key.
21:34:48 <ddarius> So that he can mpose his 6/8 time on us.
21:35:12 <kmc> κǒmρø§∃
21:35:12 <KirinDave> kmc: This monad zipper thing is…
21:35:23 <KirinDave> kmc: I cannot tell if it is brilliant or mad yet. But it's definitely new to me.
21:35:34 <kmc> i'm gonna go with brilliant *and* mad
21:38:18 <tgeeky> i was impressed with the paper :O
22:12:06 <copumpkin> ...
22:12:06 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/5492
22:14:05 <copumpkin> > let powers = 2:map (2^) powers :: [Expr]
22:14:06 <lambdabot>   not an expression: `let powers = 2:map (2^) powers :: [Expr]'
22:14:13 <copumpkin> > let powers = 2:map (2^) powers in powers :: [Expr]
22:14:14 <lambdabot>   [2,2 * 2,2 * 2 * (2 * 2),2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2 * (2 ...
22:17:46 <ddarius> copumpkin: Why does that person think that should be legal?  Also, why are you following GHC's trac?
22:18:00 <copumpkin> ddarius: it's interesting
22:18:08 <copumpkin> ddarius: yeah, that's what I don't understand
22:18:24 <copumpkin> why people learning a language seem to think that their misunderstandings are bugs
22:19:03 <Jafet> They are bugs; just misdiagnosed.
22:19:11 <ddarius> copumpkin: At least if you are going to claim that a compiler rejects a valid program, you should be able to demonstrate that it is a valid program.
22:19:37 <ddarius> Jafet: I think that stretches the already stretchy meaning of "bug."
22:19:45 <shachaf> GHC even reports a reasonable error message for it.
22:20:04 <shachaf> Reasonable enough that I'd check the language spec for what "variable name" means rather than file a GHC bug, anyway.
22:20:10 <Jafet> I don't have any context, so I won't bug you further.
22:20:10 <ddarius> copumpkin: Or at least give -some- justification why you think it is a valid program.
22:20:16 <copumpkin> yeah...
22:21:04 <ddarius> shachaf: In this particular case, you'd think the first thing you'd try to do is use _ as a variable name in any other context.
22:21:22 <shachaf> ddarius: When you type "_ = 5", it looks like it works if you don't try to use it.
22:21:34 <ddarius> But I'm pretty sure _ :: Int doesn't.
22:21:47 <ddarius> But yes, in this case, a super superficial attempt could seem to work.
22:22:10 <shachaf> supersuperficial? How many levels above ficial can you go?
22:24:14 <ddarius> Of course, if they had tried _ :: Int, I'm sure they just would have filed another bug.
22:37:50 <kmc> remember the bug about "GHC doesn't accept C++ comment syntax"?
22:38:08 <mauke> wat
22:38:08 <ddarius> No, because I don't follow GHC's trac.
22:38:18 <copumpkin> you're missing out
22:38:50 <shachaf> "I do believe that c++ and c-styled comments are not big deal to add, but they are big deal in making haskell more rapid typing programming language."
22:39:04 <shachaf> I am.
22:39:05 <kmc> link?
22:39:08 <ddarius> copumpkin: On hastening the day when I eliminate 99.99%+ of the human population?
22:39:09 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/4864
22:39:30 <shachaf> Ooh, who's going to stay?
22:40:01 <applicative> wow, the rejected underscore is a great bug.  i'm putting one up for my rejected hyphen
22:40:05 <ddarius> shachaf: The ones that survive.
22:40:10 <kmc> "In Haskell we think for quite a long time before starting typing."   ←   ice burn
22:40:16 <ddarius> Though many of them will no doubt die shortly thereafter.
22:40:34 <ddarius> kmc: I know I do all my programming from the numeric pad.
22:41:51 <ddarius> kmc: The person who closed it forgot to mention that /* and */ and // are all legal identifiers and one of them is in the Standard libraries.
22:42:19 <kmc> haha, that's true
22:42:28 <kmc> @hoogle (/*)
22:42:28 <lambdabot> No results found
22:42:34 <shachaf> @hoogle (//)
22:42:34 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
22:42:48 <ddarius> kmc: Proof that x86 assembly is a better language than Haskell.
22:43:41 <ddarius> Or maybe proof that it is 2:37 on the east coast.
22:44:11 <kmc> 2a2f   sub ch, [rdi]
22:45:03 <applicative> hm, the better response would be to recommend combinators /* and */ such that f /* a */ b = f b; then they would have  been happy
22:45:26 <kmc> yes
22:46:03 <ddarius> @let f /* a = f; a */ b = b; infixl 8 */ in f /* a */ b :: Expr
22:46:03 <lambdabot>   Parse error: in
22:46:20 <ddarius> > let f /* a = f; a */ b = b; infixl 8 */ in f /* a */ b :: Expr
22:46:21 <lambdabot>   Ambiguous type variable `a' in the constraint:
22:46:21 <lambdabot>    `SimpleReflect.FromExpr a...
22:46:25 <mamalujo> why would they buy that
22:46:26 <ddarius> Point lambdabot.
22:46:38 <Oxfaded> I have a function which spits out a lazy bytestring, but as the byte string is built up byte by byte I wind up with a huge list of chunks. Is there an efficient way to concatenate them into a single chunk, im assuming pack(unpack(xs)) is rather inefficent
22:47:03 <ddarius> Oxfaded: Use a Builder.
22:48:51 <applicative> Oxfaded: eg http://www.haskell.org/ghc/docs/7.0.1/html/libraries/ghc-binary-0.5.0.2/Data-Binary-Builder.html
22:49:06 <edwardk> Data.Binary.Builder or blaze-builder are your friends
22:49:17 <Oxfaded> thanks
22:55:00 <applicative> Oxfaded here is a little overview remark by donshttp://stackoverflow.com/questions/5971855/when-do-i-use-bytestring-and-when-do-i-not
22:58:26 <ddarius> Computer science students know high school math right?
22:58:45 <bradshjg> ...indeed?
22:58:53 <edwardk> ddarius: i think you overestimate the average computer science student
22:59:26 <Oxfaded> is the idea to concat a series of singletons or am I missing something?
23:00:31 <Oxfaded> append singletons *
23:01:11 <edwardk> 0xfaded: you typically want to build up a lazy bytestring out of chunks of a decent size
23:01:30 <edwardk> Builder builds up bytestrings by accumulating enough bytes to make it worth spitting out a chunk
23:01:36 <ddarius> edwardk: I think you meant Θxfaded.
23:01:57 <kmc> Oxfaded, to answer your direct question, you can glue together the chunks with Lazy.fromChunks . pure . Strict.concat . Lazy.toChunks
23:02:39 <Oxfaded> unfortunately i cant. i'm implementing xtea which works on 4 byte chunks, so the resulting byte string is nicely chopped up
23:02:51 * hackagebot trifecta 0.46 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.46 (EdwardKmett)
23:03:21 <Oxfaded> kmc: thanks, thats good enough for my purposes
23:03:32 <edwardk> Oxfaded: 4 byte chunks is rather below the threshold that bytestrings are efficient
23:04:07 <edwardk> Oxfaded: with blaze builder or builder you'd probably get much better throughput with something closer to 4k chunks than 4 byte chunks ;)
23:05:42 <Oxfaded> edwardk: im working on a binary protocol, so once its all unencrypted using the binary monad makes things nice. I'm not die hard about performance, but the messy chunking seems a bit iffy
23:05:57 <kmc> ah i thought Lazy.ByteString was a newtype for [Strict.ByteString], but that's not actually true
23:06:01 <kmc> data ByteString = Empty | Chunk {-# UNPACK #-} !S.ByteString ByteString
23:06:28 <kmc> i guess this explains why fromChunks / toChunks are not "O(1)"
23:06:30 <edwardk> kmc: yeah. they have to traverse the list anyways to filter empty leaves
23:06:50 <edwardk> there is a productivity invariant that says each chunk contributes at least one byte
23:06:58 <kmc> yeah
23:07:19 <kmc> i wonder how much it matters to unpack S.ByteString into the Chunk constructor
23:07:30 <Oxfaded> kmc: where is pure defined?
23:07:32 <edwardk> well, it cuts the indirections by half
23:07:44 <kmc> Oxfaded, Control.Applicative.  "return" will work just as well
23:07:50 <edwardk> and once it inlines away you don't incur the repacking overhead too often
23:07:59 <kmc> Oxfaded, for our purposes it's just a function to turn a value into a singleton list of that value
23:08:03 <applicative> @src pure
23:08:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
23:08:19 <kmc> or:  \x -> [x]
23:08:26 <kmc> or (:[])
23:08:33 <kmc> :t (:[])
23:08:34 <lambdabot> forall a. a -> [a]
23:09:33 <edwardk> without it you'd pay for an extra 2 pointers (one to the :: info table, one to the bytestring) per chunk, a significant fraction of the overhead you already incur
23:21:00 <buntfalke> Hi
23:22:47 <buntfalke> Isn't foldL faster than foldR because it can start the applying f right away without building a long callstack down to [] first?
23:22:59 <ddarius> buntfalke: Your premise is false.
23:23:38 <erus`> foldR is the fastest fold
23:24:38 <buntfalke> Well -- why/
23:24:49 <slack1256> this is true just only if the function applicated is lazy on it's second argument (example &&)
23:24:59 <shachaf> It's still often not true there.
23:25:07 <shachaf> Comparing the speed of foldl and foldr is usually silly.
23:26:12 <buntfalke> slack1256: Which statement is true in that case? "foldl is faster" or "foldr is faster"?
23:26:27 <slack1256> as a rule of a thumb: if you are going to evaluate all the argument use foldl', on the other hand if the function applicated is lazy on the 2º arg, use foldr
23:26:53 <buntfalke> Okay, I see
23:28:04 <shachaf> slack1256: That's not necessarily a good rule of thumb.
23:28:14 <slack1256> buntfalke: this little txt helped me a lot http://pastebin.com/NRBUJJUb
23:28:17 <mauke> The paste NRBUJJUb has been copied to http://hpaste.org/51408
23:28:29 <buntfalke> slack1256: will read
23:28:33 <buntfalke> shachaf: explain plz
23:28:42 <slack1256> shachaf explain please?
23:28:42 <shachaf> Laziness is helpful even if you consume the entire argument.
23:28:57 <slack1256> for the sharing part?
23:30:48 <shachaf> E.g. you probably want map to be lazy even if you use the entire list it gives you.
23:31:51 <applicative> buntfalke: there is also the strict left fold foldl'
23:32:07 <buntfalke> shachaf: I still don't see how this makes a point to the actual topic...
23:32:24 <slack1256> type map
23:32:39 <ddarius> slack1256: The first line in that paste came from this page: http://haskell.org/haskellwiki/Stack_overflow
23:33:15 <slack1256> yes!, i usually copy the answers that i like to make little resume on subjects
23:33:23 <slack1256> @map
23:33:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:34:02 <slack1256> shachaf: map :: (a -> b) -> [a] -[b]
23:34:33 <shachaf> map f = foldr ((:).f) []
23:34:42 <slack1256> notice how it just requieres a Function with one argument, so it can consume the list from outside to inside
23:34:46 <shachaf> I guess that's not a perfect example, though.
23:34:53 <applicative> buntfalke: http://www.slideshare.net/tibbe/highperformance-haskell has a nice discussion of folds
23:35:02 <slack1256> that is why make sense to map be lazy
23:35:16 <applicative> it has a nice discussion of everything it discusses
23:35:27 <slack1256> also map has pretty heavy deforestation with -O2 and {-# Rules directives
23:36:08 <slack1256> applicative: reading
23:37:54 <slack1256> how much do you think #haskell users has decreased because of the CUFP?
23:41:05 <kmc> CUFP has the best logo
23:45:42 <OLiverr> hello, I'm using Haskell with ghc 7.03 on windows and I get very huge executables (19 MB) though I have just some few lines of code, does anyone know how I could avoid that?
23:46:10 <ddarius> OLiverr: Use Virgil.
23:46:40 <kmc> OLiverr, GHC produces huge executables.  is it actually a problem for your application?
23:47:02 <kmc> 19 MB is bigger than I expect; a small program on my Linux system is like 1 MB
23:47:19 <OLiverr> yeah, unfournately yes because my customer don't want such a big executable
23:47:22 <kmc> OLiverr, Haskell libraries are statically linked by default, so a few lines of code might pull in a lot of libraries
23:47:28 <kmc> why do they care?
23:48:02 <slack1256> OLiverr: when building use : ghc -dynamic flag to dynamically use libraries
23:48:06 <OLiverr> don't ask me, I have to write a plugin for word with vba (*urgh*) and it has to be tiny ;)
23:48:14 <OLiverr> and I use an external haskell program
23:48:23 <ion> kmc: Because they store the executable on floppy disks.
23:48:35 <kmc> you can use -dynamic but then you have to ship the haskell libraries as dlls too...
23:48:36 <slack1256> OLiverr: I've passed from 5Mb to 40 Kb with that flag
23:48:53 <slack1256> true kmc
23:49:02 <OLiverr> hm ok
23:49:39 <ddarius> You can strip and use executable compressors as well.
23:50:07 <kmc> sometimes people have legitimate needs for small binaries, and other times they're just offended on principle that GHC would produce something which consumes 0.01% of the cheapest hard drive you can buy
23:50:53 <OLiverr> yeah sure but 19mb is a bit extreme..
23:50:59 <OLiverr> i dont expect 6kb but 19mb..
23:51:02 <kmc> shrug
23:51:11 <ddarius> kmc: I actually had a problem recently because every time I run VS's built-in test web server, it generates at least 20MB of IntelliTrace files pretty much immediately.
23:51:24 <ddarius> kmc: I was losing a gig or so a day.
23:51:35 <shachaf> OLiverr: Did you try stripping it?
23:51:40 <kmc> OLiverr, it'd be nice if it were smaller, but I don't think it's a big deal... I don't think GHC HQ should spend their time on this, personally
23:51:47 <kmc> like i said, 0.01% of the cheapest hard drive you can buy
23:51:59 <kmc> code size matters a lot if you're talking about the fast path
23:52:06 <kmc> dead or cold code in the exe doesn't matter much
23:52:11 <kmc> dead code won't ever hit RAM
23:52:28 <slack1256> kmc: we shouldn't be addressing the people desires. just providing a option
23:53:01 <OLiverr> shachaf,  not yet
23:53:02 <kmc> OLiverr, by the way, I hear JHC produces small binaries... but it's lacking a lot of things GHC has
23:53:04 <OLiverr> this one? http://www.mkssoftware.com/docs/man1/strip.1.asp
23:53:14 <slack1256> OLiver: use ghc -dynamic flag you could pass from 6Mb to 90kb, but the PC where you run the programm will need the haskell plataform
23:53:35 <slack1256> otherwise you should just use the 19Mb binary
23:53:49 <OLiverr> yeah but I think that he doesn't like this either
23:54:33 <shachaf> strip -s reduces my ghc binary from 41M to 27M
23:54:37 <slack1256> also if I recall right, haskell plataform on windows doesn't provide dynamic libraries (ghc 6.10 maybe?)
23:55:08 <kmc> i don't think GHC 6.10 supported dynamic libraries at all
23:56:10 <OLiverr> is this strip thing available for windows at all?
23:56:23 <mrcarrot> i wish ghc would have full support for dynamic libraries
23:56:45 <kmc> OLiverr, i'm sure something analogous is
23:56:46 <mrcarrot> at least with elf, it is not possible (amd64)
23:57:03 <kmc> maybe MinGW or cygwin has it
23:57:05 <kmc> mrcarrot, why not?
23:57:48 <slack1256> mrcarrot: elaborate please?
23:58:18 <slack1256> mrcarrot: I'm on amd64 and linux, all my executables are dynamic :S
23:58:36 <mrcarrot> kmc, slack1256: it is not implemented yet... at least when i am trying, it is saying that there is no dynamic prelude. and according to the wiki, it is not possible
23:58:55 <kmc> wiki link?
23:58:56 <mrcarrot> slack1256: i am on openbsd amd64...
23:59:28 <mrcarrot> kmc: http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport?redirectedfrom=DynamicLinking
