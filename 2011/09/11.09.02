00:09:03 <ion> Is there a better way to refer to the return type of “this definition” than this <https://gist.github.com/1188115> or ScopedTypeVariables?
00:20:13 <yitz> ion: yuck. could be though.]
00:21:49 <yitz> ion: any reason not to use res instead of a?
00:22:31 <ion> yitz: That would work, but would in my opinion be less clear as the functions don’t use the value.
00:22:55 <ion> And aren’t supposed to use it.
00:23:13 <yitz> ion: ar you sure base^digits-1 doesn't cause problems?
00:23:50 <ion> What kind of problems? It’s an Integer.
00:24:21 <yitz> @type enccoeFloa
00:24:22 <lambdabot> Not in scope: `enccoeFloa'
00:24:23 <yitz> @type enccoeFloat
00:24:24 <lambdabot> Not in scope: `enccoeFloat'
00:24:34 <yitz> @type encodeFloat
00:24:35 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
00:24:59 <yitz> hmm wireless kb acting up today. perhaps time for new batteries.
00:54:14 <Accidus> Can I define ternary infix operators?
00:54:26 <opqdonut> no
00:54:31 <Accidus> Oh well.
00:54:33 <Accidus> thanks
00:54:35 <opqdonut> you can sometimes define two binary operators and have it work
00:55:18 <opqdonut> like (-|) :: a -> b -> Intermediate a b; (|-) :: Intermediate a b -> c -> Something a b c
00:55:30 <Accidus> Aye, figured as much.
00:57:27 <taotree> I'm looking for something like this: (a -> Bool) -> [a] -> Int that returns the index of the first item for which the function returns true
00:58:18 <taotree> ah, found it.
00:58:24 <taotree> should have been Maybe Int at the end
00:58:28 <taotree> List.findIndex
01:04:13 <mrsleepy> could anyone point me to a very, very simple example like the classic game "Guess the number"
01:06:54 <mrsleepy> what i would want is the smallest possible "game" that has simple input and output and something repeated
01:07:40 <mrsleepy> the guess the number game would be something like: i am thinking about a number between 1 and 10 and you have 4 guesses left. your guess:
01:08:15 <mrsleepy> and the response would be either "too high", or "too low"
01:08:26 <mrsleepy> or "correct"
01:09:00 <Saizan> http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics/Solutions#Interactivity <- something like this?
01:09:19 <yitz> @hoogle (a -> Bool) -> [a] -> Int
01:09:20 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
01:09:20 <lambdabot> Data.List findIndices :: (a -> Bool) -> [a] -> [Int]
01:09:20 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
01:09:44 <leino> mrsleepy: have you ever done IO in haskell?
01:09:48 <yitz> taotree: as you see ^, you can ask hoogle question like that. it will even remind you about the Maybe.
01:11:22 <leino> (IO meaning input/output)
01:12:03 <mrsleepy> leino: some very minor... but the thing is, how do i put it all together into a program. "guess the number would have some kind of state too, as it keeps track of how many guesses you have been doing
01:12:48 <leino> how would you write the program if you had a "getGuess" function?
01:13:03 <leino> say getGuess = 42 for purposes of concreteness
01:13:11 <leino> start with that
01:13:37 <Saizan> getGuess = return 42
01:13:48 <Saizan> so that it'll have the right type at least
01:13:49 <leino> oh and does your program generate a random number?
01:14:07 <leino> Saizan: the point was to avoid IO :)
01:14:34 <Saizan> don't call it getGuess then
01:14:54 <leino> why not?
01:14:55 <frerich> Does it make sense to generalize a function 'f :: (String -> Int) -> Int' to 'f :: Monad m => (String -> m Int) -> m Int' in order to allow a wider range of functions? If people want to pass a pure function, they could use the identity monad - but they might also use IO or anything else?
01:15:01 <Saizan> mrsleepy: check this example  http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics/Solutions#Interactivity
01:15:15 <mrsleepy> thanks
01:15:40 <dave1231> mrsleepy: it doesn't necessarily need state, since you can write the bit of the code that lets you have 4 guess in terms of a bit of code that lets you have 3 guesses etc...
01:15:59 <yitz> Saizan: that is a rather archaic example, as seen by the inclusion of "import IO"
01:16:56 <Saizan> yitz: it's an old example but still valid
01:17:32 <Saizan> frerich: yes, see how we have mapM and not just map
01:17:32 <quicksilver> frerich: yes, it makes perfect sense although it's a pain to use
01:18:11 <quicksilver> frerich: it is a minor but often mentioned annoyance, the need to provide 'monadified' versions of functions.
01:19:25 <quicksilver> but Identity/runIdentity noise just isn't very convenient
01:19:45 <quicksilver> (and may, just possibly, inhibit the compiler from getting hte optimisations right, too)
01:20:26 <yitz> Saizan: perhaps we should be helpful and delete that?
01:20:33 <Saizan> a often overlooked problem when writing the monadified versions is that the monad can change the strictness properties
01:20:59 <frerich> Hmm.
01:21:51 <Saizan> yitz: if you have an account..
01:22:43 <yitz> Saizan: yeah, i see it's separate from wikipedia. i've made changes to the wikibook before, but now i recall that it was always by submitting them to one of the authors.
01:23:17 <frerich> Is there a 'half' version of liftM, like 'Monad m => (a -> b) -> (a -> m b)' ? So that if I have a function 'f :: Monad m => (String -> m Int) -> Int' I can easily call it with a '(Strng -> Int)' function by lifting half of it into a monad?
01:23:41 <Saizan> ?type (return .)
01:23:42 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
01:24:00 <Saizan> ?type (return P.)
01:24:00 <lambdabot> Not in scope: data constructor `P'
01:24:06 <Saizan> ?type (return Prelude.)
01:24:06 <lambdabot> Not in scope: data constructor `Prelude'
01:24:31 <Saizan> ?type \f x -> return (f x)
01:24:32 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> a) -> t -> m a
01:24:39 <azaq23> @src liftM
01:24:40 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:25:07 <Saizan> liftM f m = m >>= return . f, in fact
01:25:45 <frerich> Hm indeed, so I guess I can just say
01:26:06 <frerich> \f -> return . f
01:26:30 <Saizan> yes, see my first (return .)
01:26:49 <dave1231> I was wondering how much effect the monadified way of doing things effected strictness etc... yesterday - still working through "write a scheme in 48 hours"
01:26:55 <Saizan> (it has a more general type in lambdabot though)
01:27:05 <frerich> Saizan: To be honest, that type scared me away.
01:27:15 <yitz> frerich: the monadified version can sometimes be fundamentally different than the original, not just in strictness.
01:27:16 <taotree> yitz: I searched hayoo for it but it gave no results. Apparently hoogle is a little more fuzzy in its searching
01:27:30 <dave1231> hit the error monad - which I'd read about before but never used properly - was wondering how much impact it was going to have
01:27:49 <Saizan> frerich: take "f x = r -> x"
01:27:54 <yitz> frerich: for example, your function probably calls the parameter function one or more times with some String.
01:28:21 <yitz> frerich: in a monadic context, that can have side effects, depending on how many times you do that and in what order.
01:28:25 <Saizan> yitz: itym dave1231:
01:29:20 <dave1231> I took the point anyway - confirms what I was wondering
01:29:23 <frerich> yitz: Right; I didn't want to impose a 'purity' requirement on the caller. By allowing some monad, I hoped to improve the flexiblity of the function - it might start having side effects, but then that's what the caller asked for. :-)
01:29:37 <Cale> dave1231: It's kind of like asking how the use of libraries affects strictness ;)
01:29:37 <mauke> preflex: seen djahandarie
01:29:38 <preflex>  djahandarie was last seen on #haskell-blah 4 hours, 26 minutes and 38 seconds ago, saying: I suck at languages :(
01:29:42 <frerich> yitz: I looked for the most general way to say 'This function needs a way to get an Int given a String'.
01:29:56 <yitz> frerich: whereas the pure version can ignore that problem, perhaps being more efficient that way, for example
01:30:06 <dave1231> between that, finger trees and the beginnings of an understanding of what comonads are used for it's been an interesting time for my ol' brain
01:30:33 <frerich> yitz: Hm, so if it influences possible optimizations, then implementing the pure version in terms of the monadified version (by simply adding some Identity here and there) is not such a good idea?
01:30:34 <Cale> dave1231: "Monad" is basically a name for a common pattern in the APIs of various libraries which we've managed to recognise and pull out into its own library, so we can abstract over it and use a bit of code in a lot of different settings.
01:31:20 <Cale> (all the things in Control.Monad, for one)
01:31:40 <yitz> frerich: it all depends on what the function does. sometimes you can generatlize in that way for free. other times, you would like to emphasize that is should called in a pure context.
01:31:40 <mauke> can anyone tell me why Control.Newtype.op exists?
01:32:12 <Cale> mauke: it exists?
01:32:25 <mauke> Cale: yes
01:32:35 <Cale> oh, I see, found it on Hackage :)
01:32:47 <yitz> frerich: personally, i usually find it easier and neater to write as much as possible without a monadic context, then monadify only what i need to.
01:32:48 <Cale> This function serves two purposes:
01:32:49 <Cale>     Giving you the unpack of a newtype without you needing to remember the name.
01:32:49 <Cale>     Showing that the first parameter is completely ignored on the value level, meaning the only reason you pass in the constructor is to provide type information. Typeclasses sure are neat.
01:32:52 <dave1231> Cale: I think I've more or less got that part of the theory down, I was just surprised by how much the Error Monad effected things
01:33:00 <mauke> Cale: what does that mean?
01:33:06 <dave1231> probably should have been expecting it in retrospect
01:34:26 <Cale> mauke: So, if you have the newtype data constructor, you can apply op to it, and get the opposite, which extracts the value of the original type from the new one.
01:35:00 <mauke> Cale: but I can already do that with unpack
01:35:13 <Cale> But it might be ambiguous.
01:35:40 <Cale> op gives you a way to specify which newtype you're using by providing the data constructor for it as an (albeit not really used) parameter
01:36:53 * hackagebot egison 0.3.0.3 - An Interpreter for the Programming Language Egison  http://hackage.haskell.org/package/egison-0.3.0.3 (SatoshiEgi)
01:45:54 <kizzx2> dave1231: what kind of uses of comonads have you found? i only know ppl can use it for some kind of stream processing, but i dont even know some practical examples (most things i've read cite some contrived examples which just serve to demonstrate what a comonad is)
01:48:20 <dave1231> kizzx2: the simple version of my _really_ simplified understanding is that if you're doing computations on a neighbourhood of a datastructure you might (should?) be able to do it with a comonad
01:49:40 <kizzx2> dave1231: sounds to me like convolutions (ala game of life style neighborhood checking)
01:49:50 <dave1231> pretty similar
01:50:16 <dave1231> that's one of the uses, in fact
01:50:23 <kizzx2> mabye i can try writing a GoL that uses comonads
01:50:51 <dave1231> with a zipper into a pixmap you can do blurs and other convolutions with comonads (apparently)
01:51:19 <dave1231> the disclaimer is I haven't used them and only got a fuzzy understanding of them in the last 24 hours
01:51:24 <kizzx2> ok i think my imagination kind of stopped there :P
01:51:42 <kizzx2> ^ i mean can't get to really visualize how that can be done
01:52:23 <kizzx2> dave1231: where did you learn comonds? last time i looked resources are kind of scarce, many are algebraic Mars speak that serve to bruise the writer's ego
01:54:50 <dave1231> kizzx2: yeah, that's a lot of them - I'll try to re-google what I was reading at work today
01:56:53 * hackagebot sundown 0.2.1 - Binding to upskirt  http://hackage.haskell.org/package/sundown-0.2.1 (FrancescoMazzoli)
01:56:55 * hackagebot sundown 0.2.2 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.2.2 (FrancescoMazzoli)
02:21:08 <Eduard_Munteanu> dave1231: sigfpe's blog has some nice stuff on comonads
02:21:43 <Eduard_Munteanu> Say, http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
02:21:58 * hackagebot sundown 0.2.3 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.2.3 (FrancescoMazzoli)
02:23:23 <ion> eduard_munteanu: Thanks for the link.
02:24:29 <ion> Now if i could just find a good-in-LYAH-way tutorial about FRP. :-)
02:26:48 <jarkko^> hi doesn't this page have a small mistake in documentation:
02:26:51 <jarkko^> http://zvon.org/comp/r/ref-Haskell.html#Functions~Prelude.foldr
02:27:20 <jarkko^> for example if I have something like foldr (\x y -> x / y) 1 [1, 2, 3]
02:28:00 <jarkko^> and follow the documentation word by word it would evaluate to (/) 1 ((/) 2 ((/) 1 3)) (when evaluating in head) but in reality it is (/) 1 ((/) 2 ((/) 3 1))
02:28:46 <jarkko^> first iteration is last item and second argument, not second argument and last item as documentation says..
02:29:27 <incluye>  > foldr (x y -> x / y) 1 [1, 2, 3]
02:29:32 <incluye> aw, whoops
02:29:53 <companion_cube> > foldr (/) 1 [1,2,3]
02:29:54 <lambdabot>   1.5
02:30:01 <shachaf> jarkko^: I'm not sure what this zvon.org thing is.
02:30:09 <incluye> I did poorly on several levels there
02:30:30 <shachaf> jarkko^: I keep seeing it in Google results, but it's not associated with Haskell in any official way, as far as I know.
02:30:39 <shachaf> Its documentation is typically pretty bad, I think.
02:31:10 <jarkko^> ok :)
02:31:26 <jarkko^> just wanted to verify my thoughts, thanks
02:32:08 <Eduard_Munteanu> ion: I'd like to know that too
02:33:05 <ion> > foldr (/) z [a,b,c]
02:33:06 <lambdabot>   a / (b / (c / z))
02:33:10 <ion> > foldl (/) z [a,b,c]
02:33:10 <lambdabot>   z / a / b / c
02:37:52 <companion_cube> :t z
02:37:53 <lambdabot> Expr
02:39:32 <taiyal> how does the absolute beginner [grounded in imperative OO languages] start learning Haskell?
02:39:33 <dave1231> Eduard_Munteanu: I was going to link to 3 of his posts and one or two other pages
02:39:38 <rostayob> taiyal: LYAH
02:39:40 <rostayob> @where LYAH
02:39:40 <lambdabot> http://www.learnyouahaskell.com/
02:39:49 <taiyal> thank you
02:39:55 <rostayob> you're welcome!
02:40:14 <rostayob> always nice to advertise that book eheh
02:40:59 <shachaf> taiyal: You might do best to unground yourself a little. :-)
02:41:15 <taiyal> I actually have dipped my toe in functional programming a bit, I studied a bit of LISP for a few months
02:41:27 <taiyal> Lisp* sorry
02:41:48 <klapaucius> The Haskell School of Expression
02:44:49 <klapaucius> implying, LISP is somehow relevant to functional programming
02:45:33 <rostayob> klapaucius: lisp is very relevant to functional programming
02:48:45 <ousado> huh, isn't lisp based on the untyped lambda calculus?
02:52:26 <shachaf> Common Lisp is pretty different from McCarthy-LISP.
02:55:21 <mm_freak> i don't think that common lisp is very functional
02:55:37 <taiyal> holy heck ghc6 is huge
02:56:31 <benmachine> taiyal: to be fair it comes with a whole buncha libraries (I think)
02:57:10 <rostayob> taiyal: also, go for ghc 7 directly
02:57:59 <klapaucius> http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
02:58:03 <rostayob> the size of ghc is mainly due to the fact that each library is compiled for dynamic/static linking and for debugging
02:58:07 <taiyal> rostayob: is that stable or a nightly?
02:58:36 <rostayob> taiyal: ghc 7 has been stable for something like 10 months
02:58:48 <rostayob> the haskell platform comes with ghc 7.0.something
02:58:55 <rostayob> which is what you should go for
02:59:14 <taiyal> I'll go grab the 7 source
02:59:30 <rostayob> taiyal: you shouldn't build ghc yourself
02:59:40 <rostayob> just download the binaries
02:59:40 <taiyal> and why not!?
03:00:04 <rostayob> taiyal: well first, you need ghc to compile ghc
03:00:10 <rostayob> it's big and complex
03:00:27 <Eidel> Can anyone tell me how to do this in haskell? http://pastebin.com/TFfK2SWV
03:00:28 <rostayob> i mean you can compile ghc but why?
03:00:28 <mauke> The paste TFfK2SWV has been copied to http://hpaste.org/50885
03:01:41 <sbrg> Eidel: mapM print $ zipWith (++) arr1 arr2, or something like that
03:01:45 <rostayob> Eidel: mapM_ (\(a, b) -> putStrLn (show a ++ " " ++ show b)) (zip [1,2,3] [4,5,6])
03:01:54 <mauke> Eidel: forM_ (zip arr1 arr2) $ \(x, y) -> printf "%d %d\n" x y
03:02:10 <Eidel> :D yäy. Thanks guys.
03:02:56 <rostayob> Eidel: how do you type that great a with dots on it?
03:03:03 <rostayob> :D
03:03:30 <ion> altgr-q with the US International (AltGr dead keys) layout.
03:04:09 <ion> Or altgr-" a. Or compose " a with any layout.
03:04:11 <Eidel> With years of stuborness and an obsolete language.
03:04:46 <rostayob> ion: mh. I never knew that altgr did this. @łe¶.
03:04:56 <rostayob> but I guess my UK layout is different
03:06:09 <rostayob> @pl \(a, b) -> putStrLn (show a ++ " " ++ show b)
03:06:09 <lambdabot> uncurry ((putStrLn .) . (. ((' ' :) . show)) . (++) . show)
03:06:14 <ehamberg> rostayob: use a ©ómρ☺sə key :)
03:06:16 <rostayob> yay for pointfree ahaha
03:10:24 <ion> Hah. I didn’t expect ☺☹ to be available with compose, too.
03:10:48 <ion> ρ doesn’t seem to be here, though.
03:11:17 <klapaucius> putStrLn . uncurry (++) . first (++" ") . (show *** show)
03:11:32 <rostayob> klapaucius: yeah, pl doesn't know about ***
03:13:51 <ion> putStrLn . mconcat [show . fst, pure " ", show . snd]
03:16:36 <rostayob> I think an obfuscated haskell contest would be nice
03:17:45 <rostayob> but types probably prefent the level of obfuscation reachable in C/perl
03:17:57 <ion> unsafeCoerce
03:18:02 <rostayob> ah! right
03:26:45 <Cale> rostayob: You've obviously never read any of Oleg's code ;)
03:27:06 <ion> :-)
03:28:23 <klapaucius> mapM_ putStrLn $ zipWith (printf "%d %d") [1,2,3] [4,5,6]
03:32:30 <Cale> Or for that matter, that damn regex library, which shows that Haskell can really give perl a run for its money for obscene levels of context sensitivity in code meaning. :)
03:33:02 <Cale> http://hackage.haskell.org/packages/archive/regex-base/0.93.2/doc/html/Text-Regex-Base-RegexLike.html#t:RegexContext
03:33:39 <Cale> It's not as bad as it used to be at least -- they've introduced newtypes for unlocking many of the instances.
03:33:50 <rostayob> Cale: yes, I have read a lot of Oleg's code actually, but that's not obfuscated, that's evil
03:34:50 <rostayob> I often wonder if that kind of code is actually natural to him, because I'd never come up with the stuff he does
03:34:58 <Cale> I'm pretty sure it is
03:35:10 <Cale> I think he just treats the Haskell type system as Prolog.
03:35:35 <Cale> It's pretty close to a Prolog-like language if you look at it the right way
03:35:50 <Cale> (and turn on enough extensions)
03:36:01 <rostayob> Cale: mah. if you say so :)
03:36:47 <ion> I just treat the Haskell type system as INTERCAL.
03:37:01 <rostayob> it's similar in the sense that you declare what should be. that's all
03:37:20 <klapaucius> If it's true, he probably never use TF. Am I right?
03:37:40 <rostayob> klapaucius: TF?
03:37:48 <benmachine> type families?
03:37:49 <klapaucius> type families
03:37:54 <benmachine> he probably uses everything
03:37:54 <benmachine> twice
03:37:56 <benmachine> and backwards
03:38:17 <rostayob> no but the thing that bugs me about oleg is stuff like "type FK a = a"
03:38:20 <Cale> Well, also in the way in which unification drives forward computation and typeclasses look pretty much just like Prolog predicates.
03:38:31 <rostayob> *why* would that be clearer.
03:38:32 <klapaucius> But TF does't look like prolog at all
03:38:45 <Cale> haha, where was that?
03:38:58 <rostayob> Cale: the paper about a backtracking monad
03:39:02 <taiyal> rostayob: I'll have to build from source because I'm still running Ubuntu 10.10 and I don't feel like breaking my apt with packages from oneiric; surely you can build GHC 7 from GHC 6 though?
03:39:14 <rostayob> taiyal: just download the binaries
03:39:14 <ion> type Foo a = a; type Bar a = Foo a; type Baz a = Foo (Bar a)
03:39:17 <Cale> ah, about LogicT
03:39:22 <rostayob> Cale: yes
03:39:35 <Cale> clearly, that's the type of the Failure Kontinuation
03:39:54 <Cale> lol
03:40:07 <rostayob> Cale: yes it is, together iwth Success Kontinuation
03:41:23 <rostayob> Cale: unification? in the type inference?
03:41:38 <Cale> yeah
03:41:48 <rostayob> mh
03:41:52 <rostayob> bah
03:41:56 <Saizan> and instance resolution
03:41:56 <rostayob> lunch
03:42:03 <Cale> and instance resolution, yes :)
03:42:22 <Cale> (perhaps the latter more critically for his sort of stuff)
03:43:11 <Saizan> the main difference is the lack of backtracking
03:46:14 <ion> @type let foo = (undefined :: Ratio Word8) `asTypeOf` bar; bar = 42 in bar
03:46:15 <lambdabot> forall t. (Num t) => t
03:46:45 <ion> Ah, NoMonomorphismRestriction
03:53:36 <joe6> if I had a choice between using GADT's vs type families, which is recommended?
03:55:20 <hpc> the two are used for different things
03:55:37 <joe6> ok, thanks. i thought they were similar.
03:56:00 <joe6> not exactly, but with overlapping functionalities..
03:56:10 <joe6>  a few overlapping functionalities..
03:56:23 <hpc> kind of, but only in the "make the type system way cooler" sense
03:56:26 <hpc> :P
03:56:52 <benmachine> it's type families and functional dependencies that are very similar
04:02:08 <klapaucius> TF and GADT similar in a way that they both can be used to declare that type constructor depend on type parameter. Main difference is: families open, GATD close
04:12:07 <joe6> klapaucius: that explains it. thanks.
04:17:31 <tomh> is there some pragma to surpress warnings?
04:19:52 <chrisdone> tomh: {-# OPTIONS -fno-whatever-warning #-}
04:20:29 <tomh> cool thanks
04:22:32 <joe6> "Without functional dependencies or associated types, these multi-parameter type classes may cause too much ambiguity to pass the type-checker."
04:22:54 <joe6> if I have a situation where I need multip-parameter type classes, should I use associated type?
04:23:23 <joe6> /multip/multi/
04:24:13 <joe6> what is the recommended method?
04:28:06 <zong_sharo> joe6: http://www.haskell.org/haskellwiki/Functional_dependencies -- here is a small motivational example on fundeps
04:28:26 <joe6> zong_sharo: thanks.
04:28:32 <zong_sharo> also applies to tf
04:30:31 <klapaucius> Associated types are recommended
04:30:54 * balta2ar has just found two nice examples of how to stack monad transformers: https://gist.github.com/1080612, https://gist.github.com/1080915. For those (these include me) who aren't satisfied with the examples supplied in 18th chapter.
04:33:40 <zong_sharo> joe6: iirc, associated type synonyms with equality constraints is equivalent to fundeps
04:34:05 <joe6> ok, thanks.
04:34:09 <zong_sharo> and yeah, tf's is "preffered" because they are less obscure
04:34:11 <joe6> klapaucius: thanks.
04:34:28 <joe6> ok, good to know. reading up on them, nom.
04:34:31 <joe6> s/nom/now/
04:35:00 <zong_sharo> joe6: http://www.haskell.org/haskellwiki/Type_families -- this may help too
04:35:31 <quicksilver> zong_sharo: I don't think that is known to be true; or at least some edge cases require complex encodings.
04:35:45 <quicksilver> however they are certainly in practical equivalence for typical uses.
04:36:17 <klapaucius> imo "Fun with type functions" is good introduction material
04:36:26 <zong_sharo> quicksilver: i would like to see an example, could you?
04:37:38 <quicksilver> I think it's things like class Weird a b c | a b -> c, c b -> a
04:37:43 <quicksilver> however I forget the details
04:41:52 <klapaucius> btw TF and FD not exactly equivalent, at least up to ghc 7.2.1 where are eq constraints in superclass declarations.
04:42:07 <mm_freak> does the .cabal file have to be named after the project name?
04:42:47 <tai> is GHC 7 different enough from 6 that learning 6 first would cause me to stumble on 7?
04:43:14 <mm_freak> tai: go with GHC 7, if you can
04:43:22 <mm_freak> there is little reason to go with GHC 6
04:44:12 <quicksilver> tai: still, the answer to your question is "No".
04:44:27 <tai> okay
04:44:34 <quicksilver> what you mostly want to learn is haskell (haskell2010, perhaps) which is well supported by GHC 6.12 and GHC 7.0.
04:44:49 <quicksilver> And there are a few interesting GHC extensions but they are for the most part supported by both.
04:44:56 <tai> I might just build 7 myself
04:45:16 <mm_freak> tai: the haskell platform is available for most relevant platforms
04:46:15 <dcoutts> mm_freak: the .cabal file name matches the package name (but if your package is called something different from your "project" name then that's fine)
04:56:45 <XniX23> is there a way to control a remote control in haskell? (or some piece of hardware similar or whatsoever)
04:57:09 <hpc> XniX23: you'll want to look at the FFI perhaps?
04:58:58 <mm_freak> dcoutts: thanks
04:59:15 <XniX23> hpc: so you actually need C? (i dont really know how these things work)
04:59:32 <benmachine> tai: new people are mostly recommended to go with the haskell platform
04:59:35 <benmachine> which includes a GHC of some sort
04:59:50 <benmachine> be warned that building GHC takes like an hour :)
04:59:54 <benmachine> (or can do)
04:59:59 <hpc> XniX23: no, i suck
05:00:01 <hpc> XniX23: http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network-Socket.html
05:00:01 <flux> xnix23, what do you actually mean by that?
05:00:06 <quicksilver> benmachine: 8 hours!
05:00:10 <quicksilver> benmachine: (on a 800Mhz ppc)
05:00:13 <flux> xnix23, controlling a remote control?
05:00:21 <hpc> XniX23: hardware that communicates over a socket can be controlled that way
05:00:36 <hpc> which is all the hardware i have had to deal with ever
05:00:38 <benmachine> quicksilver: eep.
05:00:41 <hpc> which is exactly one roomba
05:00:45 <hpc> so ymmv :P
05:01:04 <XniX23> flux: im not really sure, i remember my professor controlled his recorder (or atleast programmed something for it to record at certain times) in python
05:01:09 <benmachine> I started writing a binding to the bluez API once
05:01:15 <benmachine> but I got bored before I finished it
05:01:32 <benmachine> it was up to the point where I could connect a wii controller and find its name
05:02:29 <flux> xnix23, how was it connected to PC?
05:03:09 <flux> (or was there a pc involved?)
05:03:49 <XniX23> flux: unfortunately, i have no idea about this. Was hopping you guys could tell me hah
05:04:54 <flux> xnix23, well, it basically boils down to if the remote control can be programmed itself (very doubtful that would happen with python) or if it is remote controlled for example via serial port
05:05:23 <flux> for the former you may find that running GHC or GHC-compiled programs on 8-bit microcontrollers will be a difficult task..
05:05:34 <flux> for the latter you can just use serial port libraries (of any language)
05:06:15 <flux> maybe there are other ways as well, it could be connected to a printer port..
05:06:31 <XniX23> flux: what exactly does it mean via serial port? i dont get it how can it compile python code on that processor
05:06:59 <XniX23> flux: woops, i meant haskell (or even python as it doesn't matter)
05:07:16 <hpc> XniX23: the computer runs python code or whatever, then sends some hypothetical "0110" or whatever data over the socket
05:07:17 <flux> xnix23, ..serial port does not compile anything. serial port means that there are three wires connected from a computer to the remote control (receive, transmit, ground).
05:07:33 <hpc> the remote is built to understand that "0110" means "press the off button"
05:07:41 <hpc> or whatever
05:09:02 <XniX23> hpc: is there a sequence that represents "if" statement also? or is it just regulat commands for actions
05:09:41 <hpc> XniX23: read some information about the thing you want to control
05:10:13 <flux> xnix23, typically you cannot send programs over wire if one is talking about remote control ("if" would quality)
05:10:24 <flux> an alternative would be sending programs, that would be called programming
05:10:59 <hpc> XniX23: do you even know what thing you would be controlling?
05:11:48 <XniX23> hpc: I'm actually trying to get to know stuff a bit
05:12:35 <tai> benmachine: what do you mean by the "haskell platform"?  By the way, I'm running Ubuntu 10.10
05:12:55 <benmachine> tai: search for a haskell-platform package, I forget if one exists
05:12:58 <hpc> XniX23: you should start with an actual thing; if you have a wii remote and a laptop with bluetooth, there's APIs in other languages that are well documented
05:13:06 <hpc> start with something easy like that
05:13:25 <benmachine> tai: http://hackage.haskell.org/platform/
05:13:44 <XniX23> hpc: yeah i heard about wiimote, too bad i dont have any of those stuff
05:14:16 <benmachine> tai: looks like there is a package
05:22:34 <joe6> i want to understand associated types and it appears that the Type-Level Instant Insanity
05:22:39 <joe6> is a good start
05:22:53 <joe6> of "the monad reader" issue 8.
05:23:39 <joe6> just curious, if there are any other better reads to understand the haskell type system to be able to use associated types without winging it.
05:24:17 <jarkko^> what's the problem creating composite of not and > meaning not . (>) ?
05:24:42 <jarkko^> i mean other is function from a -> a -> Bool and not takes Bool
05:25:42 <benmachine> jarkko^: a -> a -> Bool is equivalent to a -> (a -> Bool)
05:25:51 <benmachine> so (>) takes a to a -> Bool
05:25:56 <benmachine> and not doesn't take a -> Bool
05:26:26 <benmachine> the easiest way to get what you want is to use a lambda
05:26:36 <benmachine> alternatively, you can define 'result = (.)'
05:26:44 <jarkko^> ah, right
05:26:49 <benmachine> and then 'result not' *does* take a -> Bool
05:26:57 <tai> benmachine: the newest version of GHC available from the Canonical repos for 10.10 is v6, and if I wanted to get the v7 package out of oneiric I'd probably have to do some crazy apt source voodoo and honestly I'd rather just build it than do that [I build programs all the time anyway]
05:27:10 <tai> I build my own kernels
05:27:19 <benmachine> tai: I'd say get v6 and don't worry about it too much
05:27:31 <benmachine> tai: v7 is nice but mostly only for developers
05:27:37 <benmachine> well
05:27:39 <jarkko^> benmachine: thanks, makes sense
05:27:45 <benmachine> v7 is nice for lots of people, I suppose
05:27:49 <benmachine> but v6 is fine too
05:28:04 <benmachine> getting the platform will save you some considerable headaches finding and installing libraries
05:28:04 <rostayob> tai: why don't you just download the binaries?
05:28:14 <rostayob> i don't understand. no one likes the ghc binaries.
05:32:19 <tai> I try to avoid running binaries that aren't signed by canonical
05:32:46 <rostayob> tai: why?
05:32:59 <rostayob> i really don't understand, I trust distributions less then developers personally
05:33:00 <Phyx-> benmachine: "considerable" ?
05:33:04 <tai> I really don't have any justification for it, that's just how i was "raised" by my linux friends
05:33:17 <rostayob> tai: ah so now ubuntu is a religion!
05:33:31 <tai> every OS is a religion
05:33:32 <ion> Mark is our Steve!
05:33:33 <tai> hehe
05:33:56 <rostayob> tai: fyi, debian constantly messes up with upstream, they actually introduced a bug in openssl some time ago
05:34:05 <rostayob> distributions are bad, apart from slackware
05:34:14 <rostayob> but this is the wrong chan eheh
05:34:30 <kmc> Type-Level Instant Noodles
05:34:38 <kmc> also 'morning #haskell
05:35:11 <ion> kmc: That should be generalized. There’s also the use case of Type-Level Instant Coffee.
05:36:06 <kmc> if we can just establish how to boil water at type level
05:36:10 <kmc> that should cover most situations
05:36:24 <ion> True
05:36:39 <mokus> unsafeContemplateIO :: IO a -> * -> * ?
05:37:02 <jeffcutsinger> You could put a pot of water on a CPU while it's compiling the right program.
05:37:03 <byorgey> boiling water at the type level is not hard, just enable UndecidableInstances, turn up the context stack, and write a loop
05:37:19 <byorgey> jeffcutsinger: exactly =)
05:37:21 <kmc> mokus, i'm sure they'll add that in Haskell 2999
05:37:49 <mokus> agda's really good for that, i know of a module that takes about an hour to compile on my system, and keeps it quite toasty the whole time
05:38:47 <byorgey> Agda: is it a dependently-typed programming language? Is it a proof-assistant based on intuitionistic type theory? Is it the world's most elaborate way to boil a pot of water?
05:39:01 * mokus thinks it's all 3!
05:39:04 <byorgey> =D
05:39:08 <kmc> someone should implement a dependently-typed programming language as a DSL for TeX
05:39:20 <kmc> that way, rendering your paper also proves it correct!
05:39:28 <mokus> kmc: sounds painful
05:39:49 <hpc> kmc: this sounds like a job for... Oleg!
05:40:01 <byorgey> Section 6. Metatheory.  This paper was typeset with ProofTeX.  QED.
05:40:18 <byorgey> I like it
05:41:48 <ion> We could just implement Haskell in TeX and use Agda.
05:42:19 <hpc> "just"
05:43:05 <rostayob> tex is turing complete right?
05:43:16 <ion> yeah
05:43:22 <mokus> or implement a javascript interpreter in TeX and compile agda with ghcjs
05:43:26 <mokus> ;)
05:44:05 <hpc> oh, #haskell, you have the best worst ideas
05:44:38 <ion> Or implement a TeX code generator for LLVM.
05:44:55 <hpc> ion: and compile ghc with itself into tex?
05:44:58 <kmc> or implement a MIPS emulator in TeX
05:46:10 <hpc> or write a tex viewer that converts tex to haskell and executes it
05:46:43 <hpc> er, tex to agda
05:47:20 <kmc> yeah, the actual reasonable option is Literate Agda
05:47:25 <kmc> i wonder if it exists
05:47:30 <kmc> i've seen a few nice pdfs with agda code
05:47:55 <byorgey> lhs2TeX can typeset Agda
05:47:56 <mokus> it probably wouldn't be hard to use lhs2tex
05:48:45 <byorgey> I don't know whether the Agda typechecker can read literate Agda, but you can also use lhs2TeX to strip out everything but code
05:48:59 <copumpkin> it can
05:49:04 <copumpkin> but only latex style
05:49:26 <kmc> does it know how to turn all the Unicode characters into TeX codes?
05:49:54 <ion> At least XeTeX and LuaTeX support Unicode natively.
06:21:10 <FredOverflow> Coming from C++, I thought `Functor` was something like a function, but it seems it is rather a container of elements which can be fed into a map function? If so, I find the naming confusing.
06:21:40 <mux> it's some kind of a container which supports lifting pure functions into it
06:22:04 <mux> the "functor" term is indeed wildly used with several different meanings depending on the language
06:22:21 <FredOverflow> mux: With fmap playing the lift part?
06:22:23 <mux> I'm not sure Haskell is to blame for this
06:22:29 <mux> FredOverflow: yup
06:22:59 <FredOverflow> So fmap takes an ordinary function (a -> b) and "lifts" it into the Functor (f a -> f b)... seems to make sense...
06:23:21 <mux> yes
06:23:55 <Botje> FredOverflow: it lifts it to work *on* the functor
06:24:13 <Botje> because you also have applicative functors, centered around types like f (a -> b)
06:24:16 <mux> any enlgish imprecisiosn are my own fault ;-)
06:24:37 <Botje> which gives you neat chains like f <$> a <*> b <*> c
06:24:46 <FredOverflow> So isn't map just a special "instance" of fmap for lists? Does that mean that lists are functors?
06:24:52 <Entroacceptor> yes
06:24:54 <mux> FredOverflow: yes and yes
06:24:54 <Botje> yes and yes :)
06:25:02 <FredOverflow> I see.
06:25:28 <mux> I seem to remember people saying that in early Haskell, map was just fmap
06:25:55 <Botje> FredOverflow: but if map === fmap by default, you get confusing errors
06:25:57 <Botje> and types
06:26:25 <Botje> plusOne = map (+1) -- is suddenly Functor f, Num a => f a -> f a instead of [a] -> [a]
06:26:40 <FredOverflow> @type map (+1)
06:26:41 <lambdabot> forall a. (Num a) => [a] -> [a]
06:26:55 <Botje> @type fmap (+1)
06:26:56 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
06:27:04 <Botje> ^ ^ a lot more scary :)
06:27:05 <FredOverflow> Can I actually write this "forall a." thing in my source code? I once tried, but it didn't compile.
06:27:21 <Botje> there's an extension for that
06:27:27 <mux> ExplicitForall
06:27:29 <Botje> usually you don't need it
06:27:29 <mux> IIRC
06:27:50 <mux> you mostly need it for rank-n types and for emulating existentials
06:28:14 <FredOverflow> I have no idea what that means.
06:28:22 <mux> but it's quite confusing, you can find forall in different places for different usages
06:28:52 <Botje> FredOverflow: basically, moving the forall into parens.
06:29:01 <mux> that's rank-n types
06:29:10 <FredOverflow> Well, as long as I don't have to move in with my parents...
06:29:13 <Botje> @info ST
06:29:13 <lambdabot> ST
06:29:15 <byorgey> hehehe
06:29:15 <Botje> buh :)
06:29:30 <mux> now for datatype definitions, you can use forall to do that kind of thigns: "data Showable = forall a. Show a => a"
06:29:37 <zygoloid> @type runST
06:29:38 <lambdabot> forall a. (forall s. ST s a) -> a
06:29:43 <byorgey> forall b. (forall a. a -> a -> Bool) -> [(a,b)] -> [(a,b)]  -- a "rank-2 type"
06:29:55 <byorgey> ah yes, runST is a good example of a rank-2 type as well
06:30:05 <FredOverflow> Is ST that transaction thing?
06:30:10 <Botje> ah, i was thinking of runST.
06:30:10 <FredOverflow> Or state?
06:30:17 <byorgey> FredOverflow: I think you're thinking of STM
06:30:23 <Botje> FredOverflow: you're thinking of STM and State, respectively
06:30:23 <byorgey> Software Transactional Memory
06:30:24 <zygoloid> FredOverflow: it's delimited mutable state
06:30:48 <Axman6> FredOverflow: ST is mutation without IO
06:31:03 <byorgey> ST is pretty cool, it gives you "local" state that is guaranteed to not affect anything else
06:31:19 <byorgey> like if you wanted to implement an in-place quicksort using a mutable array
06:31:24 <Axman6> and lets you write algorithms that 'need' mutable state
06:31:29 <byorgey> from the outside, it looks pure
06:32:02 <FredOverflow> Are hash tables feasible/useful in Haskell? I guess not due to the absence of mutable arrays?
06:32:26 <byorgey> Haskell does have mutable arrays.
06:32:38 <Axman6> many of them actually
06:33:00 <Axman6> but there are better structures to use in haskell, that avoid the need for mutation, which is a very good thing
06:33:01 <FredOverflow> Do I need some complicated MutableArrayMonad for that? :)
06:33:13 <byorgey> FredOverflow: yes!  but it's not that complicated =)
06:33:31 <Axman6> or you can just use IO
06:33:33 <byorgey> for a long time we did not have a good hash table implementation
06:33:35 <luite> FredOverflow: usually it's just ST
06:33:46 <byorgey> but IIRC someone recently uploaded one
06:33:47 <FredOverflow> It's just that I love hash tables, but I guess binary search trees are fast enough in practice, too.
06:34:07 <byorgey> FredOverflow: yes, for most things the extra log(n) factor is not really going to hurt that much
06:34:18 <Axman6> especially if they have bounded depth, like HAMT's
06:34:48 <FredOverflow> Actually, wouldn't comparing a couple of strings be much faster than first computing their hash values if the strings are long?
06:34:55 <Axman6> in practice, i think you get a maximum of about 7 levels deep with a completely full HAMT
06:35:13 <Axman6> FredOverflow: depends on what you're doing
06:35:32 <byorgey> http://hackage.haskell.org/package/hashtables   http://hackage.haskell.org/package/hamtmap   -- a few implementations of hash tables in Haskell
06:35:32 <Axman6> strings are something that can be compared quite efficiently using something like a trie
06:35:34 <mux> FredOverflow: most likely, but you only compute the hash value once, whereas with other data structures, you're likely to compare your string several times
06:35:40 <quicksilver> FredOverflow: depends how likely they are to have a very long common prefix, too.
06:35:47 <FredOverflow> Does Haskell cache hashes?
06:35:56 <Axman6> haskell doesn't use hashes
06:35:57 <mux> we do have nice trie implementations
06:36:04 <Axman6> untell you decide to use them
06:36:06 <FredOverflow> Ah you meant in general.
06:36:16 <byorgey> FredOverflow: no, but that's a nice tongue twister ;)
06:36:45 <FredOverflow> Does Flash cache hashes?
06:37:01 <zygoloid> a hash table implementation could choose to cache hashes, as in any language
06:37:17 <Axman6> you could easily define a type something like: data HashString = HS String Hash, and makeHS :: String -> HashString; makeHS str = HS str (hash str)
06:37:33 <FredOverflow> right
06:37:44 <Axman6> the runtime will make sure the hash is only computed once, or never if it's never needed
06:37:45 <quicksilver> zygoloid: but what kind of data structure would the hash cache be? :)
06:37:50 <Axman6> laziness win!
06:37:57 <Axman6> that's actually a pretty cool idea...
06:37:59 <Axman6> hmmmmmmm
06:38:02 <Axman6> maybe i should make that
06:38:47 <quicksilver> data Hashed a = HS a Hash; makeHS :: Hashable a => a -> Hashed a;
06:38:51 <Axman6> man, laziness is awesome
06:39:06 <Axman6> quicksilver: yeah, the obvious next step
06:39:16 <Axman6> which is where i was thinking of taking it
06:39:58 <Axman6> bleh, if only there were a nice way to have laziness with strict (/unboxed) values
06:40:14 <FredOverflow> What does a Haskell programmer mean when he speaks of a "kind"?
06:40:32 <Axman6> then you could have data Hashed a = HS !Hash a, but still have the advantage laziness gives you
06:40:34 <byorgey> FredOverflow: kinds classify types, just like types classify values
06:41:16 <byorgey> FredOverflow: things like Int, Char, [Int], etc. have kind *
06:41:17 <Axman6> Int has kind *, Maybe has kind * -> *, Either has kind * -> * -> *
06:41:37 <FredOverflow> Okay, so a kind is the signature of a type?
06:41:40 <byorgey> FredOverflow: type constructors have higher kinds; for example  Maybe  has kind  * -> *  which means it takes as an argument something of kind * and produces something of kind *
06:41:44 <Axman6> would it be correct to say kinda talk about the arrity of a type?
06:41:53 <byorgey> FredOverflow: yes
06:41:59 <ion> The type of the type.
06:41:59 <Saizan> not just the arity
06:42:01 <kmc> Axman6, yes, as much as the arity of a function, but it's not the whole story
06:42:01 <byorgey> Axman6: well, they're more than just arity
06:42:07 <kmc> :k StateT
06:42:07 <lambdabot> * -> (* -> *) -> * -> *
06:42:15 <kmc> :k (,,)
06:42:16 <lambdabot> * -> * -> * -> *
06:42:22 <Axman6> ah yes, good point
06:42:25 <kmc> these are both 3-ary type constructors, but they have different kinds
06:42:35 <FredOverflow> So in Java, the kind of Map would be <K, V>?
06:42:50 <kmc> FredOverflow, there's no notation for it in Java
06:42:50 <mux> :k Map
06:42:51 <lambdabot> Not in scope: type constructor or class `Map'
06:42:58 <kmc> the variables are irrelevant
06:43:00 <kmc> :k Data.Map.Map
06:43:01 <lambdabot> * -> * -> *
06:43:02 <mux> :k Data.Map.Map
06:43:03 * Axman6 feels uneasy talking about anything to do with types when talking about Java
06:43:03 <byorgey> FredOverflow: since Map takes two type arguments, the kind would be  * -> * -> *
06:43:03 <lambdabot> * -> * -> *
06:43:17 <byorgey> same as it is in Haskell, as others have just demonstrated =)
06:43:33 <kmc> we heard you like polymorphism so we put type constructors in your type constructors so you can abstract while you abstract
06:43:37 <FredOverflow> Ah, so * -> * -> * means "takes two types and delivers a type"?
06:43:42 <kmc> yes
06:43:52 <mux> two concrete types and delivers a concrete type
06:43:54 <FredOverflow> okay that makes sense
06:43:54 <kmc> * -> (* -> *)
06:44:04 <mux> you cannot use Map Maybe [] for instance
06:44:07 <FredOverflow> Ah so currying also works for kinds? :)
06:44:09 <kmc> yeah, the terminology sucks... sometimes people say "type" to mean only things with kind * and "type constructor" for the rest
06:44:13 <byorgey> FredOverflow: yep =)
06:44:15 <kmc> currying works for types
06:44:20 <mux> but you can have Map (Maybe Int) [Char]
06:44:22 <kmc> sometimes they use "type" to mean all things with kinds
06:44:30 <Axman6> so Map ::: * -> * -> *, Map Int ::: * -> *, and Map Int Bool ::: *
06:44:36 <FredOverflow> Is there another level above kinds?
06:44:37 <kmc> and you can't have StateT Int Char Int, but you can have StateT Int Maybe Int
06:44:38 <Eliel> what obstacles are there that would complicate compiling haskell into jvm bytecode?
06:44:41 <Axman6> (where ::: is me being lazy and making up notation)
06:44:50 <kmc> FredOverflow, not in Haskell, because there are no functions or application at kind level
06:44:52 <Axman6> Eliel: probably the runtime
06:44:57 <kmc> except for the kind-constructor (->)
06:44:59 <byorgey> FredOverflow: good question.  In Haskell there is not, because it is not needed
06:45:01 <kmc> Eliel, it's been done more than once
06:45:07 <Axman6> i think compiling haskell for the JVM has been done before
06:45:14 <byorgey> FredOverflow: if there were another level, we could say there is one "sort" called BOX and all kinds have sort BOX.
06:45:31 <byorgey> FredOverflow: kinds are not interesting enough to need different classifications.
06:45:45 <byorgey> FredOverflow: however there do exist languages with more levels.
06:45:46 <zygoloid> (->) at kind level is not first-class. if it were, we'd need a sort system
06:45:55 * mux wonders if people are going to introduce the GHC-specific ? and ?? kinds
06:46:00 <benmachine> mux: nope
06:46:02 <benmachine> :P
06:46:02 <mux> :k (->)
06:46:03 <lambdabot> ?? -> ? -> *
06:46:08 * mux whistles innocently
06:46:20 <kmc> ⊢ * :: □   ;   k₁ :: □, k₂ :: □ ⊢ k₁ → k₂ :: □
06:46:23 <Axman6> D:
06:46:27 <byorgey> pay no attention to the man behind the curtain
06:46:41 <Axman6> his name is Simon
06:46:42 <kmc> mux, and # and (#) !
06:46:57 <Axman6> # AND (#)? o.O
06:47:10 <kmc> # is the kind of unboxed types
06:47:11 <Axman6> argh, that's quite painful to read
06:47:28 <Eliel> kmc: is there a non-dead compilerproject that can compile to jvm?
06:47:29 <kmc> (#) is the kind of unboxed-tuple types (which aren't unboxed types, or anything else)
06:47:39 <kmc> Eliel, don't know.  you could look at the dead ones to find the difficulties
06:47:44 <FredOverflow> Is there a function like "condCons cond x xs = if cond then (x:xs) else xs" in the prelude?
06:47:47 <balta2ar> what are ?? and ?
06:47:57 <FredOverflow> question marks
06:47:58 <kmc> ?? is "# or ?"
06:47:58 <lambdabot>  is "# or ?"
06:48:04 <ukl> Has anybody built atomo successfully, recently?  Fails for me...
06:48:05 <kmc> ? is "# or ? or (#)"
06:48:14 <Axman6> ha
06:48:16 <benmachine> FredOverflow: unfortunately not. however you can do (if cond then (x:) else id) xs
06:48:17 <Axman6> thanks lambdabot
06:48:18 <mux> (# Int, Int #)
06:48:49 <kmc> so "(->) :: ?? -> ? -> *" is saying that functions take boxed or unboxed arguments, and can return boxed or unboxed values or unboxed tuples, and that functions themselves are boxed
06:48:58 <magicman> And with "# or ? or (#)" you mean "# or * or (#)", I hope?
06:49:01 <Botje> condCons cond x = if cond then (x:) else id
06:49:02 <FredOverflow> @pl \cond x xs -> if cond then (x:xs) else xs
06:49:02 <lambdabot> flip flip id . (ap .) . (. (:)) . (.) . if'
06:49:04 <FredOverflow> I see...
06:49:05 <kmc> er yeah
06:49:06 <kmc> sorry
06:49:16 <kmc> ?? is "# or *";  ? is "# or * or (#)"
06:49:16 <lambdabot> Plugin `compose' failed with: Unknown command: ""
06:49:28 <benmachine> FredOverflow: note that for that, lambdabot is cheating and using an if' function
06:49:31 <kmc> i misspoke before
06:49:34 <benmachine> that isn't in the standard libraries
06:49:44 <FredOverflow> benmachine: So the real result would be even uglier? :)
06:50:01 <benmachine> FredOverflow: well, you can't do if statements pointfree using only library functions
06:50:05 <FredOverflow> @pl \f x -> f x x
06:50:05 <lambdabot> join
06:50:08 <FredOverflow> interesting
06:50:11 <mm_freak> slightly off-topic:  which of scala and clojure has the more powerful type system?
06:50:12 <FredOverflow> @src join
06:50:12 <lambdabot> join x =  x >>= id
06:50:21 <kmc> mm_freak, clojure's dynamically typed so...
06:50:29 <mm_freak> kmc: ok, that answers it for me
06:50:30 <mm_freak> thanks
06:50:33 <benmachine> you have to define something like 'cond True t f = t; cond False t f = f'
06:50:39 <benmachine> or possibly cond t f True
06:50:41 <benmachine> = t
06:50:42 <benmachine> etc.
06:50:49 <kmc> i think dynamic type systems are worth talking about, but usually people mean static types when they talk about "power"
06:51:15 <kmc> @pl \b t f -> [f, t] !! fromEnum b
06:51:15 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
06:51:28 <kmc> there's your points-free 'if'
06:51:30 <mux> dynamic types: the power to crash at runtime
06:51:32 * benmachine pokes kmc in the eyes
06:52:27 <kmc> :t flip (flip . ((!!) .) . flip (:) . return) . fromEnum
06:52:27 <lambdabot> forall a a1. (Enum a1) => a1 -> a -> a -> a
06:52:48 <danr> @unpl  flip (flip . ((!!) .) . flip (:) . return) . fromEnum
06:52:48 <lambdabot> (\ m c f -> ((:) f (return c)) !! (fromEnum m))
06:52:49 <ion> (\b t f -> [f, t] !! fromEnum b) GT "foo" "bar"
06:52:51 <ion> > (\b t f -> [f, t] !! fromEnum b) GT "foo" "bar"
06:52:52 <lambdabot>   "*Exception: Prelude.(!!): index too large
06:53:00 <jeffcutsinger> Dynamic types: programs working on first run is for other people.
06:53:31 <Botje> Dynamic types: we'll replace type systems by unit tests. MOAR CODE!
06:53:32 <benmachine> jeffcutsinger: see, with dynamic types I write programs that run fine on the first run
06:53:35 <benmachine> and the second
06:53:38 <benmachine> and then break on the 400th
06:53:44 <benmachine> long after I remember what that bit of code was supposed to do
06:53:51 <mm_freak> kmc: i never liked dynamic type systems, and i probably never will
06:53:57 <Axman6> me either
06:54:08 <Axman6> even before i knew that there was a difference
06:54:26 <byorgey> @slap dynamic types
06:54:26 * lambdabot secretly deletes dynamic types' source code
06:54:28 <mux> scumbag interpreter: "oh look, you're trying to call a function which I don't know about - I could have told you from the start, but..."
06:54:34 <benmachine> I prefer dynamic strong to static weak, though
06:54:43 <kmc> well you can have dynamic types with early binding
06:55:00 <kmc> you can have dynamic types with algebraic data and pattern-matching, too
06:55:04 <benmachine> implicit coercion makes me cry
06:55:05 <kmc> there are lots of nearly-unexplored points
06:55:15 <byorgey> mux: "... but I thought perhaps you might not actually end up calling it, so I decided to wait and see."
06:55:25 <mux> byorgey: pretty much ;-)
06:55:28 <byorgey> =)
06:55:39 <kmc> dynamically typed haskell would still be a pretty good language, in my opinion
06:55:53 <shachaf> How would type classes work?
06:55:55 <rostayob> it wouldn't be haskell
06:56:10 <benmachine> rostayob: no, it would be dynamically typed haskell instead
06:56:14 <benmachine> hence the name
06:56:15 <Saizan> type classes wouldn't work
06:56:15 <kmc> shachaf, dictionary-passing!
06:56:29 <benmachine> who needs type classes anyway >_>
06:56:31 <mux> quack typing
06:56:31 <Axman6> ... which is actually how it works now >_<
06:56:32 * shachaf suddenly sees why kmc likes the idea of dynamically-typed Haskell.
06:56:36 <byorgey> shachaf: it wouldn't be hard.  at call-time you know what concrete types are being used, and you can select the proper dictionary
06:56:43 <kmc> in most dyn-typed languages you can get the 'type' of a value as a run-time value
06:56:49 <kmc> and that could have all the relevant instances attached
06:57:19 <ion> Dynamically Typed Haskell could finally have method_missing!
06:57:26 <Axman6> while we're sort of on the subject, i hear a lot of hate for java, but is it really hate for the language itself, or something else?
06:57:42 <kmc> the language and the people who use it, especially our stereotypcial conception of those people
06:57:46 <Botje> the crappy type system and the way it makes everything verbose.
06:57:51 <balta2ar> kmc: can you think of any examples when dyn-typed langs are worth to use instead of static ones? if any
06:57:54 <Botje> and the lack of proper closures
06:57:59 <benmachine> I've never used java, I just enjoy hating things
06:58:02 <mux> did Java Generic make it into the standard, btw?
06:58:03 <benmachine> (jk)
06:58:10 <kmc> benmachine++
06:58:16 <mux> the lack of proper parametric polymorphism used to be one of my main annoyances with Java
06:58:29 <Saizan> yes, generics are in
06:58:39 <mux> whoa, I might give it another try then.
06:58:40 <dumael> shachaf: kmc: or take the Jhc route and have types as sort of first values, then match the object's type with the appropiate function.
06:59:09 <kmc> my objections: it has only one kind of abstraction and makes it horribly verbose; it's ruined the reputation of static types for a generation of programmers; it's an incomplete design by a committee that looks down on their target audience
06:59:17 <mm_freak> i just don't know how dynamic typing is any more useful than static typing, unless you want to produce bugs deliberately
06:59:39 <kmc> C# starts with a similar design premise, but actually carries it through to its logical conclusion
06:59:54 <osfameron> mm_freak: dynamic typing is good if you like to think *after* writing code, instead of before
06:59:55 <zhulikas> @type ``
06:59:56 <lambdabot> parse error on input ``'
07:00:02 <zhulikas> @type (``)
07:00:03 <lambdabot> parse error on input ``'
07:00:49 <balta2ar> it's not that I'm defending dyn-typed, but why are they in use around the world if they are so bad?
07:00:59 <koeien> zhulikas: ` ` is used to make things infix
07:00:59 <kmc> because people are stupid
07:01:07 <koeien> > (+2) `map` [0,1,2]
07:01:08 <lambdabot>   [2,3,4]
07:01:13 <kmc> that may not be fair or true but it's the answer you're going to get from #haskell
07:01:16 <zhulikas> koeien, I know/ I thought maybe it's a function which does that :)
07:01:18 <osfameron> dynamic typing allows you to do many things that seem "hard" in static types
07:01:18 <mm_freak> osfameron: when would you do that?
07:01:28 <osfameron> mm_freak: well, you can assume ";-)" up to a point
07:01:29 <mm_freak> produce stupid code at first, only to rewrite it?
07:01:33 <mm_freak> ok
07:01:41 <koeien> zhulikas: nope it's not a function, it's syntactic sugar
07:01:46 <zhulikas> ok.
07:01:51 <mm_freak> osfameron: couldn't take that as a joke, because i know too many people actually thinking that way
07:01:52 <osfameron> mm_freak: but also, yes.  If you don't understand a problem well, sometimes it is possible to start writing code, and then massage it till it does something
07:02:22 <osfameron> I have to admit to sometimes writing code that I only intuitively understand (or worse) ;-)
07:02:34 <mm_freak> osfameron: it's better to write the types first…  if they don't match, then you haven't understood the problem…  if they do, you've got yourself an auto-provable specification for free
07:02:51 <mm_freak> static typing doesn't get in the way of intuitive coding
07:03:01 <mm_freak> sometimes i do that, too
07:03:12 <osfameron> up to a point, sure
07:03:12 <kmc> writin' buggy code and gettin' shit done! leet ninja hunting bugs up all night!  vs:  staring at a blank screen, thinking very hard, feeling dumb and then getting it right the first time
07:03:44 <kmc> which of these is going to appeal to most programmers
07:03:50 <koeien> sometimes you cannot prove a property within a static type system that you know is true
07:03:52 <osfameron> kmc: I have the same issue (in my dynamic programming language that pays me $$$) with writing or not writing tests.
07:04:50 <monochrom> dynamic typing buys you only these over haskell-like static typing: dependent type, subtype
07:05:06 <s0807922> kmc++
07:05:14 <dolio> No.
07:05:45 <osfameron> sometimes the former (just writing code) is more fun.  You can't underestimate the role of psychology in your working life.
07:05:51 <kmc> exactly
07:06:12 <dolio> Not proving anything is not the same thing as proving fancy stuff.
07:06:13 <osfameron> it's also important to know when you *have* to slow down and write types/tests/etc. because you'll be a) more productive and b) much happier if you do so.
07:06:19 <benmachine> maintaining statically typed code is way more fun though
07:06:28 <koeien> benmachine: oh god yes
07:06:39 <rostayob> I think it depends on the person. most of the times I enjoy thinking about the problem more eheh
07:06:41 <kmc> sometimes getting it right the first time is not important — but sometimes, even when it's important, it's psychologically unattractive
07:06:46 <benmachine> I hated staring at javascript trying to work out how often and where the variables were jumping between number and string and back again
07:07:05 <osfameron> benmachine: just because types are dynamic doesn't mean you *have* to use them like that, of course ;-)
07:07:25 <kmc> another backwards psychological bit is that "programmers hate error messages" so let's have a language like Perl which will just chug along on any old garbage rather than saying "you're dumb, try again"
07:07:25 <benmachine> osfameron: sure, but if you're maintaining code that's not yours, you may not get a choice
07:07:29 <ion> benmachine: That’s weak typing.
07:07:34 <benmachine> ion: oh, true
07:07:35 <osfameron> there is that, yeah ;-)
07:07:36 <rostayob> kmc: I like error messages
07:07:40 <benmachine> sorry I am confusing my terms
07:07:43 <monochrom> I actually like thinking hard, feeling dumb when I get it, getting it right the first time. but that doesn't require staring at blank screen.
07:08:54 <benmachine> I guess I could make a similar argument wrt seeing that someone has written a python function and helpfully provided the signature func(*args)
07:09:06 <kmc> the only reason for a language which tries (and fails) to hide the difference between numbers and strings is if you expect code to be written by easily-offended idiots
07:09:11 <benmachine> I don't even know how many there are let alone what types there are :(
07:09:31 <kmc> even with dynamic typing, you want to catch type errors earlier in runtime.  that's the big difference between Perl and Python, say
07:09:38 <benmachine> kmc: typing the letters "toString" costs valuable developer time
07:09:43 <benmachine> and keyboard wear
07:09:48 <osfameron> kmc: or for magic flags.  I have a routine which accepts [Int] for most cases or "BUNDLE" for a specific exception
07:09:56 <kmc> ugh
07:09:58 <osfameron> that's bad code admittedly
07:10:05 <kmc> data Arg = Normal [Int] | MagicBundle
07:10:09 <mm_freak> monochrom: i think in a haskell-style type system subtyping is just a DSL
07:10:21 <kmc> see if dynamically typed languages had algebraic data then people wouldn't abuse dynamic typing so much
07:10:26 <mm_freak> dependent types are more problematic
07:10:54 <kmc> but what i meant by "tries (and fails) to hide the difference" is implicit conversion
07:10:55 <mm_freak> also i don't think that subtyping and static typing are mutually exclusive
07:11:05 <osfameron> kmc: is Python more or less rigorous with types than Perl?
07:11:06 <mux> they're clearly not
07:11:20 <kmc> osfameron, a lot more rigorous.  if you try to add a string and an int in Python, it throws an exception
07:11:20 <monochrom> I had "haskell-like static typing" there
07:11:45 <kmc> in Perl it will silently truncate the string to contain only digit characters and then interpret that as a decimal number
07:12:02 <monochrom> but yes, after you have seen ocaml, dependent type is the only thing left for dynamic typing
07:12:07 <mm_freak> kmc: and show a warning
07:12:19 <kmc> it does?
07:12:20 <osfameron> kmc: ah.  that's about implicit conversions.  Yeah, Perl tries to be "helpful" (and sometimes it is)
07:12:29 <mm_freak> if you follow good coding style and use warnings;
07:12:34 <dolio> You mean, if you don't know anything about dependent typing?
07:12:48 <kmc> it's rarely helpful in a broad sense.  the language should obey a simple set of rules; it should not second-guess me so i have to third-guess it
07:13:12 <kmc> it papers over a little localized confusion by the programmer, at the expense of much larger global confusion
07:13:18 <ion> data Usually a where { A :: a -> Usually a; ThisTime :: b -> Usually a }
07:13:36 <kmc> Haha
07:14:20 <mux> having to call fromInteger and the like seems tedious at first, but then when you go back to a language with implicit coercions, you realize the many ways an arithmetic expression could overflow, and I find myself in need of re-reading coercion rules for C, for instance
07:15:06 <mm_freak> actually i don't find myself using conversions too much
07:15:09 * mux wonders if he's being intelligible at all
07:15:12 <monochrom> this is why I say that Perl is a write-only language. it sure make perfect sense when you rashly write it
07:15:25 <mm_freak> haskell helped me to think more about proper types and data structures, requiring less conversions
07:15:32 <monochrom> s/make perfect sense/make perfect sense to you/
07:16:00 <mm_freak> monochrom: perl can well be a read/write language, but it's easy to use it in a write-only manner
07:16:08 <mm_freak> the same is true for haskell
07:16:11 <ion> I love the fact that implicit numeric type conversions don’t happen.
07:16:24 <mm_freak> if you're good at haskell, you can very well write code, which no human can comprehend
07:16:31 <kmc> yeah, the 5 people who still write large Perl programs have a big set of rules to follow to produce clean code
07:16:56 <Saizan> do they use the same rules?
07:17:01 <zachk> perl has it's uses
07:17:09 <copumpkin> its
07:17:23 <kmc> monty python's flying circus!
07:17:24 <copumpkin> </asshole>
07:17:36 <dino-> But when I see incomprehensible Haskell, I want to learn what it does and how. With incomprehensible Perl.. not so much.
07:17:53 <ion> Keeping track of what numeric type each part of a mathematical expression is takes much more coder cycles than typing explicit conversions.
07:18:02 <dolio> > let omgDependent 0 = Left "hello" ; omgDependent n = Right (n-1) in omgDependent 5
07:18:03 <lambdabot>   Right 4
07:18:06 <dolio> > let omgDependent 0 = Left "hello" ; omgDependent n = Right (n-1) in omgDependent 0
07:18:07 <lambdabot>   Left "hello"
07:18:09 <mm_freak> dino-: mostly it's just exaggerated point-free style…  there is nothing to learn here
07:18:29 <mm_freak> using combinators for pointfree style is perfectly fine, but if you exaggerate, the code is totally incomprehensible
07:18:43 <mm_freak> even for experienced haskellers
07:18:53 <Saizan> dolio: pack a function in those constructors and you also have typeclasses!
07:19:16 <kmc> 'The BBC had rejected some other names put forward by the group including "Whither Canada?", "Ow! It's Colin Plint", "A Horse, a Spoon and a Bucket", "The Toad Elevating Moment" and "Owl Stretching Time"'
07:19:22 <ion> Pointless code should only be used if it makes it *more* comprehensible.
07:19:43 <mm_freak> ion: easier to read
07:20:00 <ion> That’s what i said. :-P
07:20:09 <osfameron> kmc: the people who write large Perl programs use a large set of clean, well built, and well documented libraries on CPAN, such as Moose, Catalyst, Template::Toolkit, etc., as well as a great set of testing and code quality infrstructure
07:20:17 <mm_freak> ion: probably what you meant =)
07:20:18 <osfameron> kmc: there are significantly more than 5 of them ;-)
07:21:30 <monochrom> it's exactly the same problem with some mathematicians writing "every x satisfies P(x,y) for some y". makes perfect sense to whoever wrote it. of course, because he wrote it. do you know how other mathematicians figure out whether it is ∀x∃y or ∃y∀x? here is how: spawn two threads, one thread tries to prove or disprove ∀x∃y, the other thread tries to prove or disprove ∃y∀x. whichever one is true and has the mo
07:21:30 <monochrom> st non-trivial proof is the one intended by the author. see the parallel with perl? parsing and disambiguating perl is just as undecidable too
07:22:32 <osfameron> yes.  perl is not quite as elegant as haskell, granted ;-)
07:22:37 <quicksilver> monochrom: four threads, in a way.
07:22:54 <monochrom> yeah, 4 threads actually
07:23:09 <dolio> If any x satisfies P(x) then any y satisfies Q(y).
07:23:09 <kmc> threads = grad students?
07:23:21 <benmachine> heheh
07:23:38 <hpc> monochrom: in your example, forall x. exists y. is a superset of exists y. forall x.
07:23:48 <monochrom> no, this kind of thing usually happens during talks on the fly, so it's really each mathematician working on his/her own
07:23:52 <hpc> so you only need half the grad students :D
07:32:09 <brisbin> so, i've put ghc 7.2 on os x 10.6 via the .pkg, installing cabal 0.10.2 fails with odd version bounds on base and unix: base >= 4 && < 3 (wtf?) && >=2 && <5, unix >= 2.0 && < 2.5 (i have == 2.5 installed) -- what did i screw up?
07:32:24 <brisbin> installing cabal-install 0.10.2*
07:32:31 <brisbin> via the ./bootstrap.sh
07:32:46 <benmachine> brisbin: hm. probably the dependencies disagree on what they need
07:32:52 <KirinDave> Have more packages in hackage been updated to work with 4.2.1 yet?
07:33:09 <Saizan> brisbin: you need the darcs version of cabal-install
07:33:10 <KirinDave> My haskell learning has been on pause while these osx lion issues get sorted, and I'm getting antsy.
07:33:21 <KirinDave> err, 7.2.1
07:33:26 <benmachine> all mine have
07:33:27 <KirinDave> Sounds like
07:33:31 <KirinDave> The answer is no.
07:33:32 <benmachine> unfortunately no-one cares about my packages :P
07:33:38 <brisbin> Saizan: is there a wiki for pulling that on os x?
07:33:52 <KirinDave> benmachine: We love you repackages, we just need base. :)
07:34:19 <Saizan> brisbin: darcs get http://darcs.haskell.org/cabal-install -- if i got the url right
07:34:36 <brisbin> Saizan: i didn't know if there was a preferred way to get darcs itself... i guess macports should have it
07:34:37 <benmachine> Saizan: it's in the cabal repo nowadays
07:34:41 <brisbin> Saizan: thank yo uthough
07:34:52 <benmachine> brisbin: http://darcs.haskell.org/cabal instead
07:35:12 <brisbin> thank you all
07:44:37 <KirinDave> Ugh, recompiling gch 7.2.1 with 7.0 on OSX Lion
07:44:42 <KirinDave> ld warnings like woah
07:45:07 <Botje> i'll upgrade to ghc 7.2 in the winter
07:45:35 <KirinDave> I just want a ghci that works
07:45:40 <kmc> install Linux in a VM
07:45:46 <copumpkin> Botje: by then there'll be 7.4
07:45:50 <KirinDave> kmc: Yeah, nooo.
07:45:52 <copumpkin> 7.4 is very soon
07:46:04 <kmc> KirinDave, why not? it's not a great solution, but it will work
07:46:12 <KirinDave> kmc: Please do not be absurd.
07:46:21 <KirinDave> I use vagrant every day, with increasing levels of regret.
07:46:40 <dolio> I'm planning on upgrading to GHC 6.6 in a few days.
07:46:45 <KirinDave> I lost a whole work day to subtle vagrant bugs earlier this week.
07:46:48 <dolio> On my Debian Potato machine.
07:46:53 <copumpkin> dolio, the conservative haskeller
07:46:58 <kmc> i use kvm and virt-manager and it's really slick
07:47:00 <KirinDave> I am not a fan of virtualized development right now.
07:47:05 <kmc> does OS X really not have virtualization that just works?
07:47:20 <hpc> kmc: i think it does, but only for other OS Xs
07:47:26 <KirinDave> kmc: VirtualBox's kernel mod still has issues.
07:47:27 <hpc> or something
07:47:34 <KirinDave> hpc: Opposite
07:47:47 <KirinDave> kmc: I get about 2 kernel panics a week with virtual box under lion.
07:47:58 <kmc> it sounds like Apple decided to break everything in Lion just for shits
07:48:04 * KirinDave sighs
07:48:08 <kmc> anyway, maybe this is another reason not to use their platform for software development
07:48:10 <KirinDave> Yeah, and I was a fool who upgraded.
07:48:25 <kmc> sorry to be That Guy, but Linux is free and these days it seems to be the "just works" option for developers
07:48:28 <KirinDave> kmc: Well, if I could find decent hardware outside of the apple vendor stovepipe..
07:48:36 <kmc> hardware for what?
07:48:39 <KirinDave> Laptops
07:48:47 <KirinDave> Lenovo's x300 looks interesting
07:48:47 <kmc> well, for starters, you can run Linux on your macbook or whatever
07:48:57 <KirinDave> Doesn't work very well, from all accounts.
07:48:59 <KirinDave> i invesitgated.
07:48:59 <kmc> ooh, i didn't know there was an x300
07:49:03 <KirinDave> kmc: Just announced.
07:49:09 <kmc> i've always been pretty happy with the lenovo x-series laptops
07:49:19 <dolio> Get an apple and run linux on it.
07:49:19 <KirinDave> Has some design flaws, but they're finally ditching the hyper masculine designs
07:49:22 <kmc> but there's a lot of options for hardware that will run Linux -- more options than hardware than will run OS X, of course
07:49:32 <kmc> "hyper masculine"?
07:49:34 <KirinDave> Yes
07:50:00 <KirinDave> I dunno why, but lenovo has had some sort of segmented alien vs. predator vs. the monolith fetishism in their design these last 5 years.
07:50:06 <kmc> 5 years?
07:50:11 <KirinDave> Okay, 10
07:50:22 <kmc> thinkpads have been matte black monoliths since the dawn of time
07:50:29 <KirinDave> They're hardly monoliths
07:50:40 <KirinDave> Their port arrangement is deleterious to the structure of the computer, for starters.
07:50:51 <KirinDave> The X200 is where they started to take structural stability really seriously
07:50:57 <copumpkin> yay, computer wars in #haskell
07:51:02 <KirinDave> (that laptop is absurdly durable)
07:51:16 <copumpkin> no u
07:51:59 <KirinDave> copumpkin: Less wars, more lament. :(
07:52:11 <copumpkin> no no, ur computr sux
07:52:32 <dolio> I only buy Packard Bell computers.
07:53:30 <luite> bah thinkpad
07:54:02 <Yrogirg> Hey guys! Is there a way to add a data constructor to an existing type?
07:54:07 <roconnor> I only buy sandstone computers
07:54:12 <roconnor> Yrogirg: nope
07:54:12 <robbe-> Hewlett Packard is the only decent kind of Packard!
07:54:46 <Yrogirg> roconnor, not even an ugly kack?
07:54:51 <roconnor> Yrogirg: you can build a new type consisting of either the old type or a new constructor.
07:54:51 <Yrogirg> *hack
07:54:59 <byorgey> Yrogirg: no, but you can make a type like   data ExtendedFoo = Extended Blah | Original Foo
07:55:03 <dolio> I don't think HP has the kind of reputation for low quality that Packard Bell does. And that's what I look for.
07:55:17 <Yrogirg> I see
07:55:20 <dolio> Of course, HP computers don't exist anymore.
07:55:30 <hpc> dolio: that's why you go with gateway
07:55:33 <hpc> or possibly acer
07:56:13 <dolio> Wikipedia says that Packard Bell is a subsidiary of Acer.
07:56:50 <robbe-> Types of the same kind.
07:57:25 <Axman6> Yrogirg: being able to do that would mean that every single function already defined for that type would now be less defined, which is a bad thing
07:58:02 <Axman6> if you could say that Maybe a = <Maybe a> | Lol a a, the the maybe function would now be pretty useless
07:58:13 <Yrogirg> yeah, good point
07:58:30 <Axman6> it would need to be redefined, in a way that would likely change its type
07:58:41 <Maxdamantus> Hm. People here tend to be good at knowing/creating names of/for interfaces .. what would you call a collection of things that you can add to, obtaining a handle to use to remove that element from; and take a "random" element from?
07:58:53 <hpc> i don't think the compiled representation of haskell values could handle extension like that either
07:59:16 <Axman6> indeed
07:59:27 <hpc> Maxdamantus: clarify what you mean by handle?
07:59:45 <Maxdamantus> add :: t -> Thing t -> (Thing t -> Thing t)
07:59:57 <Axman6> also, what happens if you do Maybe a = <Maybe a> | Lol aa and Maybe a = <Maybe a> | ERRORNULLPOINTEREXCEPTION
08:00:31 <Maxdamantus> So the add operation here results in a function that lets you remove the item you just added (assuming it hasn't already been removed)
08:00:51 <roconnor> Maxdamantus: you mean add :: t -> Thing t -> (Thing t, Thing t -> Thing t)
08:01:00 <Maxdamantus> roconnor: ah, yes.
08:01:53 <Maxdamantus> Also: get :: Thing t -> (Thing t, t)
08:02:06 <roconnor> that is the randomized get?
08:02:10 <Maxdamantus> Yes.
08:02:13 <hpc> Maxdamantus: that can be made into a MonadState with a bit of parameter ordering
08:02:16 <Maxdamantus> (get also removes the element)
08:02:22 <roconnor> you need another randomization parameter or a monad
08:02:24 <hpc> i think
08:02:34 <Maxdamantus> Mm .. regardless of implementation .. is there some name for something like this?
08:02:58 <roconnor> or is get completely deterministic, but simply unspecified?
08:03:27 <Maxdamantus> It should really be assumed to be random, so there should probably be some other paramater to help with that.
08:03:49 <Maxdamantus> Well, assuming you use the interface correctly.
08:03:58 <roconnor> Maxdamantus: I'd call it an urn
08:04:23 <Maxdamantus> Like .. an oven thing in the ground?
08:04:49 <Maxdamantus> Meh, I'm thinking of something else.
08:04:50 <roconnor> Maxdamantus: no like a vase, ordinarily covered, that usually has a narrowed neck above a footed pedestal.
08:04:58 <dafis> Is anybody here familiar with Windows, specifically quoting arguments?
08:05:07 <Maxdamantus> Why would you call it that?
08:05:23 <Maxdamantus> Because you can't see what you're getting?
08:05:33 <roconnor> Maxdamantus: because in probablility theory we are always drawing randomly from urns.
08:05:44 <Maxdamantus> Heh.
08:09:34 <byorgey> Urns have only two uses: storing ashes, and storing small identical colored balls.
08:10:19 <monochrom> wait, those things in men's washrooms are called urns too
08:10:43 <byorgey> are they? not in my dialect of English
08:11:43 <monochrom> interesting, what do you call them?
08:11:55 <quicksilver> urinals
08:11:56 * hackagebot hmatrix 0.12.0.0 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.12.0.0 (AlbertoRuiz)
08:12:11 <quicksilver> where monochrom lives, Is, As, and Ls are too valuable to waste in a word like that
08:12:14 <quicksilver> so it's shortened.
08:12:57 <monochrom> hahaha
08:13:13 <n0den1te> Ur in a Ls ?
08:13:20 <Maxdamantus> It probably had to urn that shorter name.
08:13:37 <Axman6> urin-als. not fun when you'r name's Alex :(
08:14:23 <roconnor> byorgey: usually not all the balls are identically coloured
08:14:43 <ion> That’s what she observed.
08:14:49 <byorgey> heh, indeed, I meant "identical except for their color" =)
08:15:27 <n0den1te> lol. Leave it to #haskell to come up with different contexts on jokes.
08:26:56 * hackagebot gps 0.8 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.8 (ThomasDuBuisson)
08:28:30 <n0den1te> @info seq
08:28:31 <lambdabot> seq
08:28:39 <n0den1te> @src seq
08:28:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:28:59 <n0den1te> hey guys, why is seq defined with a fixity as infix ?
08:30:02 <monochrom> so that "f x `seq` g y" sucks less than "seq (f x) (g y)"
08:30:23 <parcs> so a `seq` b `seq` f a b works
08:30:48 <n0den1te> monochrom: that one bit me this mornings. :(
08:31:06 <monochrom> how? why?
08:31:07 <n0den1te> I tried using composition and application, failed.
08:31:21 <parcs> oh i thought you were talking about the fact that it's infixr
08:32:04 <monochrom> composition and application mix well as expected. "map f . map g" sucks less than "o (map f) (map g)"
08:32:15 <n0den1te> parcs: yes. (1 +) . seq  -- doesn't work . ghci complains looking for Num types.
08:32:23 <parcs> what
08:32:52 <n0den1te> > foldr ((1 +) . seq ) 0 [1..5]
08:32:53 <lambdabot>   5
08:32:57 <n0den1te> heh.
08:33:11 <n0den1te> it fails, on 6.12.3
08:33:24 <monochrom> not sure what (1 +) . seq is supposed to mean
08:33:37 <monochrom> (1 +) . seq x, I can see what that means
08:34:13 <n0den1te> monochrom: I was simply looking for a way of skipping the first arg to seq and pass the second over to (1 +)
08:34:46 <monochrom> it's going to be the same with everything that can take 2 arguments. (1 +) . (+) for example
08:34:53 <parcs> > foldr ((+1) .) . seq) 0 [1..5]
08:34:54 <lambdabot>   <no location info>: parse error on input `)'
08:34:55 <n0den1te> monochrom: I was simply playing with folds from ch 4 of RWH this morning. (that particular eg computes the length of a list)
08:34:56 <roconnor> fixity of seq has nothing to do with the expression (1 +) . seq
08:35:37 <roconnor> fixity of seq only effects expressions with `seq` in it.
08:35:52 <roconnor> *affects
08:38:39 <rwbarton> also what does seq have to do with computing the length of a list?
08:38:42 <monochrom> you are better off writing explicit lambda expressions first
08:38:44 <n0den1te> roconnor: sorry, I thought fixity had something to do with it when I saw the error msg from ghci on that line.
08:39:04 <n0den1te> monochrom: sure, that's what I did the first time. :)
08:39:14 <rwbarton> what explicit lambda did you have?
08:39:25 <roconnor> rwbarton: it stops stack overflows
08:39:25 <n0den1te> > foldr (\_ x -> 1 + x) 0 [1..5]
08:39:26 <lambdabot>   5
08:39:44 <monochrom> then you transform the lambda expression to other forms by mechanical formula manipulation only. do not "intuit".
08:39:56 <rwbarton> n0den1te, where does seq come from then
08:40:21 <rwbarton> roconnor: well it is hard to tell what is intended, I thought seq was evaluating elements of the list though
08:40:24 <n0den1te> rwbarton: what roconnor said. the way I could do composition.
08:40:59 <EvanR-work> whats 'the' way to use mysql from haskell
08:41:01 <monochrom> well write the lambda expression that includes seq first
08:41:03 <n0den1te> monochrom: "intuit"? Did I make a mistake?
08:41:05 <EvanR-work> these days
08:42:09 <rwbarton> > foldr (((+1).) . seq) 0 [1..5]
08:42:11 <lambdabot>   5
08:42:17 <rwbarton> > foldr (((+1).) . seq) 0 [1,undefined,3]
08:42:19 <lambdabot>   *Exception: Prelude.undefined
08:42:24 <rwbarton> roconnor: that is what I thought was intended
08:42:32 <rwbarton> since it is a common error
08:42:53 <roconnor> I see
08:43:35 <n0den1te> > foldr (\x y -> seq x y + 1) 0 [1..5]
08:43:35 <lambdabot>   5
08:44:07 <monochrom> @pl (\x y -> seq x y + 1)
08:44:07 <lambdabot> flip flip 1 . ((+) .) . seq
08:44:24 <n0den1te> monochrom: well, I got to the point of using composition by placing over these.
08:44:26 <monochrom> not entirely optimal but at least more correct than human guesses
08:44:29 <roconnor> rwbarton: yes it is now very confusing what n0den1te intends
08:44:45 <vokoda> how do I represent a Word8 constant in my code? I just want to `mod` an unsigned 8-bit integer with 256, but if I type 256 right in I get a 'divide by zero' error which I assume is because 256 gets interpreted as an Int16
08:44:55 <roconnor> n0den1te: your use of seq there has nothing to do with the stack overflow usually associated with computing lengths of lists
08:45:12 <rwbarton> vokoda: why would you need to `mod` an unsigned 8-bit integer by 256? isn't that the identity?
08:45:13 <roconnor> n0den1te: arguably that code is worse than the naive code.
08:45:22 <n0den1te> monochrom: similar to how I could do: foldl (const . (1 +)) 0 [1..5]
08:46:02 <roconnor> n0den1te: what is your purpose for using seq?
08:46:16 <n0den1te> roconnor: Sure, as I said I was just playing with folds.
08:46:18 <rwbarton> (since unsigned 8-bit integers represent 0..255)
08:46:22 <n0den1te> > seq 42 58
08:46:23 <lambdabot>   58
08:46:31 <roconnor> n0den1te: it would be better to play with const
08:46:35 <vokoda> rwbarton: hmm sorry, it's the addition of two Word8s that I want to `mod`. i.e. (x+y)`mod`256, where x and y are both Word8s
08:46:54 <n0den1te> roconnor: foldr and const?
08:46:56 <rwbarton> that should happen automatically
08:47:10 <roconnor> n0den1te: if you ignore partial values, then seq = const.
08:47:14 <rwbarton> i.e. just write x+y
08:47:21 <n0den1te> > const 42 58
08:47:21 <lambdabot>   42
08:47:26 <roconnor> ah crap
08:47:26 <tromp> > 256::Word8
08:47:27 <lambdabot>   0
08:47:30 <roconnor> flip const
08:47:30 <pumpkin> roconnor: const id
08:47:36 <roconnor> or const id
08:47:39 <roconnor> as pumpkin notes
08:47:40 <tromp> > (1+2) `mod` 0 ::Word8
08:47:41 <lambdabot>   *Exception: divide by zero
08:47:50 <tromp> > (1+2) `mod` 256 ::Word8
08:47:51 <lambdabot>   *Exception: divide by zero
08:47:52 <rwbarton> > 128 + 129 :: Word8
08:47:53 <lambdabot>   1
08:47:57 <rostayob> haskell.org is downl aahhhhh
08:48:00 <rwbarton> of course 256 :: Word8 is 0
08:48:08 <rwbarton> so you can't `mod` by it
08:48:30 * roconnor thinks x `mod` 0 should be x, but that is another story.
08:49:02 <n0den1te> roconnor: ah, I didn't think of flip.
08:49:10 <n0den1te> > flip const 42 58
08:49:10 <EvanR-work> is hsql dead
08:49:11 <lambdabot>   58
08:49:37 <hpc> EvanR-work: i think so; hdbc seems to be the primary database package
08:49:56 <roconnor> n0den1te: if you want to write pointless code you will need to familiarize yourself with your weapons: ap, const, id, (.), and join.
08:49:56 <EvanR-work> is haskelldb ready
08:50:14 <roconnor> oh and flip
08:50:15 <roconnor> heh
08:50:29 <n0den1te> roconnor: ap is applicative?
08:50:37 <hpc> who needs flip when you have (. x) :P
08:50:49 <roconnor> hpc: :O
08:50:57 <EvanR-work> :t (. x)
08:50:58 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
08:50:58 <lambdabot>     In the second argument of `(.)', namely `x'
08:50:58 <lambdabot>     In the expression: (. x)
08:51:09 <hpc> :t \x-> (. x)
08:51:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
08:51:16 <hpc> :t flip
08:51:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:51:19 <roconnor> n0den1te: sounds reasonable.
08:51:19 <EvanR-work> not pointless anymore
08:51:39 <rostayob> EvanR-work: (. x) makes no sense to lambdabot because x is not a function...
08:51:41 <rwbarton> well you normally apply flip to some constant
08:51:52 <rwbarton> also it would really help if lambdabot knew the actual types of things
08:51:57 * hackagebot hsfcsh 0.0.1 - Incremental builder for flash  http://hackage.haskell.org/package/hsfcsh-0.0.1 (YurasShumovich)
08:51:58 <n0den1te> rwbarton: flip to some constant?
08:52:00 <n0den1te> @type flip
08:52:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:52:09 <mux> lambdabot has a very special definition for (.) :-)
08:52:17 <rwbarton> that's... not a constituent phrase in what I said
08:52:18 <hpc> mux: fmap is special?
08:52:20 <n0den1te> I thought it was a -> b -> c turned to c -> b -> a ?
08:52:25 <rostayob> @type flip head
08:52:26 <lambdabot> forall a b. a -> [a -> b] -> b
08:52:30 <rostayob> @type (. head)
08:52:31 <lambdabot> forall a b. (a -> b) -> [a] -> b
08:52:32 <hpc> n0den1te: this flip is generalized
08:52:39 <mux> hpc: I don't remember the specifics, this is Caleskell
08:52:42 <rwbarton> :t \x -> (P.. x)
08:52:43 <lambdabot> Couldn't find qualified module.
08:52:43 <mux> :t (.)
08:52:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:52:45 <rwbarton> how do I
08:52:52 <rwbarton> :t \x -> (Prelude.. x)
08:52:54 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
08:52:59 <rwbarton> :t Prelude.flip
08:53:00 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:53:12 <hpc> :t \f x -> ($ x) <$> f
08:53:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
08:53:23 <hpc> n0den1te: that's flip ^^
08:53:25 <rwbarton> I see
08:53:43 <vokoda> rwbarton: you're right, thanks. i'm working from a cipher spec that wrote out the function as `Rot2((X1 + X2) mod 256)` but I think the `mod 256` is basically a formalism
08:54:03 <rwbarton> but I might not apply flip to two arguments
08:54:18 <nemo_> hey
08:54:35 <rwbarton> I suppose I might not even apply it to one argument, given @pl's use of "flip flip"
08:54:59 <hpc> :t flip flip
08:55:00 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
08:55:10 <hpc> :t (<$)
08:55:11 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:55:17 <tromp> > succ 255 :: Word8
08:55:18 <lambdabot>   *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
08:55:20 <hpc> :t (<**>)
08:55:21 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
08:55:23 <n0den1te> hpc: props for craziness in ap.
08:55:24 <n0den1te> :)
08:55:28 <hpc> hmm
08:55:41 <EvanR-work> >succ 255 :: Integer
08:55:46 <EvanR-work> > succ 255 :: Integer
08:55:47 <lambdabot>   256
08:55:48 <rwbarton> :t (<**>) . pure
08:55:49 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => a -> f (a -> b) -> f b
08:56:02 <hpc> :t (<*)
08:56:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:56:14 <EvanR-work> k succ doesnt require bounded
08:56:16 <tromp> > succ 256 :: Word8
08:56:18 <lambdabot>   1
08:56:27 <hpc> :t succ -- EvanR-work :P
08:56:27 <lambdabot> forall a. (Enum a) => a -> a
08:56:38 <EvanR-work> hpc: just funny to see the error message mention it
08:58:40 <acowley> :( http://www.downforeveryoneorjustme.com/haskell.org
08:58:48 <EvanR-work> its just you
08:59:06 <EvanR-work> you and downforeveryoneorjustme ;)
08:59:13 <acowley> just my luck
08:59:22 <n0den1te> roconnor: can you tell me why I should prefer other ways to seq? from the type, it looks harmless. ;)
08:59:25 <n0den1te> @type seq
08:59:26 <lambdabot> forall a t. a -> t -> t
08:59:45 <roconnor> n0den1te: seq is anything but harmless :)
08:59:49 <n0den1te> roconnor: Oh, btw.. writing pointless code is harmless too.
08:59:50 <rwbarton> you have hit upon a touchy subject
09:00:03 <roconnor> n0den1te: back in the day seq used to come with its own type class constraints
09:00:39 <hpc> n0den1te: it's better style to use bang patterns
09:00:51 <n0den1te> rwbarton: well, I just thought I could settle down to a nice reading of typeclasses in RWH. What we discussed so far, sleep is already a lost hope. :P
09:00:55 <rwbarton> hpc, he means why use flip const rather than seq
09:01:01 <hpc> ah
09:01:01 <rwbarton> when he doesn't mean seq
09:01:10 <roconnor> n0den1te: writing pointelss code should be harmless, and it would be too if seq weren't around :^)
09:01:14 <hpc> seq is not even remotely flip const
09:01:34 <rwbarton> surely it "remotely" is
09:01:37 <n0den1te> hpc: what's bang patterns?
09:01:48 <roconnor> hpc: yes, but I think n0den1te was trying to use it as a replacement for (flip const)
09:01:48 <kmc> another not harmless function of that type:  «f _ _ = undefined»
09:01:52 <roconnor> @type (flip const)
09:01:53 <lambdabot> forall b a. a -> b -> b
09:01:55 <roconnor> @type seq
09:01:56 <lambdabot> forall a t. a -> t -> t
09:02:05 <hpc> n0den1te: a replacement for what seq is generally used for, but ignore me
09:02:07 <acowley> hah! seq instead of flip const is devious
09:02:08 <kmc> n0den1te, (seq x y) will force x to be evaluated, even though it's not used
09:02:15 <kmc> that's weird
09:02:47 <DukeDave> Any word on what's happening with haskell.org? :|
09:02:57 <acowley> now we must figure out a way to use unsafeCoerce that will *usually* evaluate the same way as flip const
09:03:00 <n0den1te> roconnor: you mean to say seq has hidden code? something that's not obvious from the type?
09:03:07 <kmc> yes, many functions do
09:03:18 <kmc> seq is strange though, in that it's so polymorphic and yet has hidden code
09:03:21 <acowley> n0den1te: "seq" is short for "secret"
09:03:24 <roconnor> n0den1te: yes
09:03:25 <quicksilver> seq is worse than many functions
09:03:27 <kmc> you can't write it polymorphically in plain Haskell
09:03:30 <quicksilver> seq cannot be implemnted in haskell
09:03:36 <quicksilver> it's a primitive
09:03:45 <n0den1te> kmc: well, from the POV of laziness, forcing evaluation isn't something "many" functions do.
09:03:54 <roconnor> primative and evil
09:04:05 <kmc> lots of functions force their arguments
09:04:05 <EvanR-work> is it there purely for performance tweaking
09:04:09 <kmc> lots of functions in Haskell are strict
09:04:27 <acowley> roconnor: you mean "primitive and eval"
09:04:30 <kmc> EvanR-work, mostly, and pseq is better for that
09:04:37 <kmc> (pseq x y) guarantees that x will be forced *first*
09:04:45 <mzero> primiative and evil => primeval
09:04:53 <mzero> which nicely has "eval" in it!
09:04:53 <rwbarton> n0den1te: consider the difference between these two functions of type Bool -> a -> a:   f _ x = x; g b x = case b of { False -> x; True -> x }
09:04:58 <roconnor> mzero: primative and eval => primeval
09:04:58 <acowley> mzero: I like it!
09:05:06 <kmc> the only guarantee on seq is that «seq ⊥ y = ⊥»; it doesn't say whether x or y gets forced first
09:05:16 <kmc> so for many types of performance tweaking, pseq is what you need
09:05:32 <acowley> Haskellers are so abstract they can't even spell primitive
09:05:34 * mzero can't wait to write in some text... "seq is primeval"
09:05:43 <acowley> mzero: I think it's a keeper
09:06:13 <n0den1te> rwbarton: they seem equivalent to me... unless I'm missing something.
09:06:18 <kmc> the latter forces its bool argument
09:06:18 <hpc> @remember acowley Haskellers are so abstract they can't even spell primitive
09:06:18 <lambdabot> Done.
09:06:30 <kmc> > let f _ x = x; g b x = case b of { False -> x; True -> x } in (f undefined 3, g undefined 3)
09:06:31 <lambdabot>   (3,*Exception: Prelude.undefined
09:07:04 <rwbarton> by the definition of a case statement, g has to evaluate b enough to determine which branch to take, even though in this case the RHSs are equal
09:07:06 <n0den1te> kmc: Nice.
09:07:27 <n0den1te> rwbarton: I got your point. case forces it.
09:07:29 <rwbarton> here f is flip const, and g is seq, both at type Bool -> a -> a
09:07:38 <edwardk> preflex: xseen cmccann
09:07:44 <edwardk> preflex: xseen preflex
09:07:45 <edwardk> ;)
09:07:54 <kmc> in Haskell (unlike GHC Core), "case" does not *always* force.  it forces far enough to check all the constructors you used
09:07:58 <quicksilver> maurer_:
09:08:09 <quicksilver> mauke: xseen preflex
09:09:11 <acowley> cmccann was last seen 8 hours ago saying, "I'm gonna go overflow some stacks."
09:09:14 <acowley> close enough?
09:09:27 <kmc> n0den1te, so:   seq x y = case x of { C {} -> y: _ -> y }   -- where C is magically one of the constructors of x's type
09:09:28 <rwbarton> n0den1te: what's magical about seq is that it works at any type t -> a -> a, without even a class context on t
09:09:30 <joe6> associated data type or associated type synonym = GADT? Data (Type) Family or (Type) Synonym Family = Type Families? is this correct?
09:09:45 <kmc> no joe6
09:10:07 <rwbarton> GADT is one thing and everything else you mentioned is another thing
09:10:10 <kmc> associated {data, type synonym} are just {data, type synonym} families attached to a type class
09:10:15 <kmc> GADTs are something else entirely
09:10:20 <joe6> oh, ok.
09:10:29 <kmc> GADTs are the types you can declare with "data Foo where ..." which you can't declare without it
09:10:29 <Rmx> Hi, I have some packages installed via cabal install, I successfully compiled some code, and I can't anymore, after reboot, as if package lsit index was deleted
09:10:41 <Rmx> I got "can't find ...." on compiilation
09:11:04 <Rmx> is there a way to rebuil packages index, or anything?
09:11:06 <n0den1te> rwbarton: surely, that holds for any function of that signature?
09:11:14 <rwbarton> well of course
09:11:16 <Rmx> I don't especially want to rebuild all packages I have
09:11:16 <rwbarton> by definition
09:11:22 <Rmx> especially wx,...
09:11:23 <joe6> kmc, i am trying to understand associated types, but I am getting lost while reading this http://www.haskell.org/haskellwiki/GHC/Type_families
09:11:36 <rwbarton> but you can't implement it yourself with the general type, only for specific types t
09:11:37 <joe6> is there a better way of learning them?
09:11:39 <kmc> n0den1te, so you can't write seq yourself in plain Haskell because a) you can't magically pick a constructor for any arbitrary type, and b) you can't pick a constructor for function types at all
09:11:48 <joe6> should I first learn about type families ?
09:12:05 <joe6> haskell.org seems to be down?
09:12:28 <kmc> joe6, associated types are just type families attached to a type class
09:12:28 <n0den1te> kmc: you guys seem to be reading my mind... Sleep is now down the pipe. :(
09:12:35 <edwardk> acowley: botsnack
09:12:46 <acowley> :D
09:13:00 <joe6> kmc, should I first learn type families to understand associated types?
09:13:00 <kmc> joe6, fundamentally they work the same way.  asstypes are a more restricted case with different syntax
09:13:07 <copumpkin> asstypes?
09:13:09 <copumpkin> o.O
09:13:10 <kmc> i don't think the order matters
09:13:16 <EvanR-work> bryan o'sullivan are you here
09:13:17 <kmc> just realize that they're basically the same
09:13:25 <copumpkin> EvanR-work: his nick is bos
09:13:31 <acowley> Motion: kmc is never to be put in charge of naming things
09:13:33 <joe6> copumpkin: i am still trying to understand the code that you wrote.
09:13:36 <EvanR-work> bos: ping
09:13:38 <mzero> joe6: I found associated types hard, and type families easy
09:13:46 <mzero> just go play with type families
09:13:46 <kmc> «class C t where { data D t }»  ⇒  «data family D t; class C t»
09:13:48 <joe6> it is my comprehension that is at fault.
09:14:00 <kmc> except that the former requires the instances for C and D to come together
09:14:01 <EvanR-work> copumpkin: seems like hes the mysql guy now, and chris waters is not
09:14:02 <kmc> you can't have one without the other
09:14:12 <mzero> well, I didn't mean "easy", I meant "easier of the two"
09:14:49 <kmc> n0den1te, the weirdest thing about seq in Haskell is that you can use it to distinguish (undefined :: () -> ()) from (const undefined :: () -> ())
09:15:15 <EvanR-work> lol i made him quit
09:15:21 <n0den1te> kmc: well then, if seq can never be seen to be implemented in plain haskell, how is it done in the compiler? Magic!
09:15:26 <kmc> sure
09:15:37 <kmc> just like putChar and (3 :: Int) and...
09:15:39 <copumpkin> mzero: why?
09:15:43 <copumpkin> they're exactly the same
09:15:52 <copumpkin> mzero `mplus` mzero
09:15:55 <kmc> though you *could* implement Int as an algebraic data type; it would just be woefully inefficient
09:16:11 <roconnor> seq is a bit more magical than putChar IMHO.
09:16:17 <acowley> mzero is his own identity
09:16:40 <roconnor> maybe seq is about as magical as case
09:16:42 <acowley> putChar's magic is plainly visible behind the RTS curtain
09:16:45 <n0den1te> MZero is his own Identity. SCNR.
09:16:55 <kmc> yeah, seq screws with evaluation itself; putChar is just a constructor in the algebraic type of inert descriptions of IO actions
09:16:56 <mzero> d'oh - I'm a clod
09:16:58 <mzero> ignore me
09:17:04 <mzero> this is why I shouldn't be in IRC when I'm at work
09:17:06 <kmc> but anyway my point is just that there's lots of built-ins
09:17:10 <roconnor> acowley: yep, and seq's magic appears to be in front of the RTS curtain
09:17:23 <kmc> which in GHC are usually implemented in terms of other, non-standard but truly primitive things
09:17:24 <acowley> seq's greatest trick is having a type that convinces you it doesn't exist
09:17:33 <mzero> I meant that I found type families easier to understand and use than ....  Functional Deps.
09:17:36 <mzero> my bad
09:17:49 <EvanR-work> kmc: hehe truly primitive
09:17:53 <n0den1te> acowley: The Usual Suspects. :D
09:18:08 <EvanR-work> chris waterson*
09:20:38 <parcs> @src seq
09:20:40 <lambdabot> Source not found. Take a stress pill and think things over.
09:20:42 <kmc> reallyUnsafePtrEq#
09:20:47 * n0den1te tries to get back to RWH, with whatever's left of him
09:20:49 <kmc> is a truly primitive thing :)
09:21:09 <roconnor> n0den1te: Don't feel badly
09:21:27 <EvanR-work> kmc: implemented with eq instruction ;)
09:21:34 <EvanR-work> which is 'truly primitive'
09:21:47 <roconnor> it's seq's fault for being such an ass.
09:21:56 <ezyang> Anyone know of an implementation of the game semantics interpretation of logic, i.e. you can play the proposer/verifier game?
09:23:42 <n0den1te> roconnor: No, I have already come so far. Ain't so easy to quit, mate. :)
09:26:45 <kmc> eq instruction?
09:26:55 <sm> morning all
09:26:58 * hackagebot word24 1.0.2 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.2 (JohnLato)
09:27:48 <sm> I made a release with a file missing from the .cabal, even though I tested a local cabal clean; cabal install first. Cabal used the file on disk even though its not in the .cabal. I guess this is normal ?
09:28:55 <sm> to test accurately, do I need to cabal sdist, unpack the tarball and cabal install that ?
09:43:49 <bscarlet> sorry if I'm the umpteenth person to ask this, but is haskell.org down?
09:44:27 <parcs> looks like it
09:44:41 <parcs> no ping response :(
09:44:44 <Phyx-> it seems so
09:44:49 <Phyx-> http://www.downforeveryoneorjustme.com/http://www.haskell.org/
09:44:50 <Phyx-> :P
09:45:14 <bos> EvanR-work: saw your mail
09:45:24 <EvanR-work> great
09:45:30 <byorgey> sm: yes, that's normal, and yes, that's the only way to test that it will build from Hackage properly
09:45:53 <n0den1te> Then could someone please change the Channel topic ? We could remove it when the site's back up.
09:46:13 <parcs> does any actually read the topic?
09:46:14 <n0den1te> erm, change the channel topic to note that haskell.org is down.
09:46:17 <parcs> anyone*
09:46:21 * edwardk is sad. i was happy that i had the 4th entry on google for a topic… but then i realized it was only for me, not for everyone that searches for it
09:46:24 <n0den1te> parcs: yeah, when logging in.
09:46:37 <edwardk> parcs: some times new people do
09:46:52 <acowley> edwardk: I've had that happen to me a couple times, too
09:46:54 <Phyx-> parcs: i don't, it scrolls by too fast and i forget to type /topic
09:46:56 <Jafet> @remember edwardk i was happy that i had the 4th entry on google for a topic… but then i realized it was only for me, not for everyone that searches for it
09:46:56 <lambdabot> I will never forget.
09:47:00 <acowley> edwardk: it's a good shot to the ego
09:47:27 <edwardk> acowley: yeah. i was just curious to see how 'trifecta' was holding up to the actual racing term, and on my screen it showed up 4th
09:47:32 <parcs> google search is pretty personalized now
09:47:34 <n0den1te> edwardk: but how do you know? :)
09:47:49 <edwardk> n0den1te: someone else looked and poked fun =)
09:48:05 <acowley> It is somewhat annoying. One used to be able to tell people search terms instead of specific URLs, but that doesn't work anymore.
09:48:09 <n0den1te> edwardk: ah, that sucks, mate.
09:48:18 <edwardk> n0den1te: meh, no worries, its all in fun
09:48:34 <acowley> search terms used to be fuzzy URLs, now they're social networking bitcoin
09:48:43 <edwardk> my usual problem is the opposite. i'll google kan extensions and find my own !@# blog posts.
09:48:47 <n0den1te> acowley: look at goo.gl. :)
09:49:24 <byorgey> edwardk: for me a PDF about your trifecta comes up at the bottom of the first page... but it specifically notes that it's showing it to me because you shared it
09:50:10 <acowley> edwardk: that's the answer, just explicitly share it with *everyone*
09:50:21 <edwardk> at least when i vanity search for my own name i don't find the Edward Kmett patent attorney who lives in california any more
09:50:38 <edwardk> byorgey: that one at least seems to show up for everyone actually
09:55:34 <n0den1te> edwardk: I had a similar experience a while back. Some bloke was randomly throwing quotes and at one point of time (out of context), he said "He lies here, somewhere". I laughed and there were blank stares around me. (alone immediately) :(
09:57:47 <n0den1te> edwardk: I don't consider myself a geek, just a quiz enthusiast. That one's a famous epitaph.
10:03:31 <Dirrrk> @hoogle MonadIO
10:03:31 <lambdabot> Control.Monad.Trans class Monad m => MonadIO m
10:05:56 <ezyang> @hoogle !
10:05:56 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
10:05:57 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
10:05:57 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
10:06:04 <ezyang> @hoogle [a] -> Int -> a
10:06:05 <lambdabot> Prelude (!!) :: [a] -> Int -> a
10:06:05 <lambdabot> Data.List (!!) :: [a] -> Int -> a
10:06:05 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
10:06:51 <Jafet> There should be a genericness-ness symbol we can put in operators.
10:09:00 <ion> ꙮ
10:09:09 <kmc> unfortunately not a symbol :/
10:09:33 <kmc> > generalCategory 'ꙮ'
10:09:34 <lambdabot>   OtherLetter
10:10:15 <monochrom> it looks like a lot of scary cancer cells to me :)
10:10:44 <kmc> yeah
10:10:50 <kmc> it's a fairly unsettling letter
10:11:00 <luite> looks like grapes
10:11:10 <luite> maybe I'm just hungry :)
10:11:34 <mux> looks like \ua66e
10:11:42 <ion> The hand-written rendition in what kmc linked on #-blah recently was more scary than what my font has.
10:12:26 <kmc> yeah, it has 10 eyes, not 7
10:13:14 <kmc> http://www.stsl.ru/manuscripts/big.php?col=1&manuscript=308&pagefile=308-0249
10:13:53 <kmc> thanks to nus for doing some of the detective work (and being able to read Russian)
10:15:04 <luite> what does it mean?
10:15:17 <kmc> http://en.wikipedia.org/wiki/Multiocular_O here is everything i know about this letter
10:15:54 <kmc> see also http://i.imgur.com/CMR8Y.png
10:16:37 <kmc> as far as i can tell, this letter was used once, as a joke, in 1429
10:16:41 <kmc> and now it's in unicode
10:16:50 <luite> interesting mitosis on the left
10:17:19 <mux> kmc: I'm not surprised, there's an emoticon block in unicode 6.0 with cat faces after all :-P
10:17:33 <luite> or maybe it's a map of apple security screws
10:19:43 <monochrom> haha apple security screws
10:20:16 <mkscrg> Anybody know anything about the upcoming 2011.4.0.0 platform release? Is it going to use GHC 7.2? ETA?
10:22:00 * hackagebot hledger-web 0.15.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.15.1 (SimonMichael)
10:22:03 <parcs> the next hp will most likely include ghc 7.4
10:24:01 <mkscrg> Ah, good to know. Any knowledge of the timeline?
10:25:14 <gwern> security screws, securing apple's profits since the 90s
10:25:43 <kmc> in soviet cupertino, apple screws you
10:25:46 <parcs> well 7.4 is slated for release in early october. the hp shortly after that
10:26:03 <kmc> why releasing so fast?
10:26:06 <kmc> what is this, firefox
10:26:09 <saml> will llvm be part of haskell platform?
10:26:21 <parcs> why would it?
10:26:39 <saml> because doesn't ghc already use llvm as backend?
10:27:27 <saml> it'd be useful.. justl ike HTTP is useful
10:28:01 <parcs> maybe on windows
10:32:00 * hackagebot gps 0.8.0.1 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.8.0.1 (ThomasDuBuisson)
10:32:02 * hackagebot hledger-interest 1.3 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.3 (PeterSimons)
10:34:06 <Phyx-> < kmc> what is this, firefox
10:34:10 <Phyx-> ^^^^ This
10:37:00 * hackagebot board-games 0.1 - Three games for inclusion in a web server  http://hackage.haskell.org/package/board-games-0.1 (HenningThielemann)
10:39:36 <acowley`> Finally our web servers have built-in games. Eat that anti-bloat activists!
10:40:36 <Phyx-> web servers get bored too
10:42:01 * hackagebot Hs2lib 0.5.5 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.5.5 (TamarChristina)
10:43:12 <EvanR-work> lol
10:44:04 <EvanR-work> bos: so have you heard of that problem?
10:45:49 <bos> EvanR-work: nope, new to me
10:46:09 <Younder> Just joined www.haskellers.org
10:46:18 <EvanR-work> then its probably still there. how long have you been the maintainer of hdbc-mysql? am i imagining chris waterson?
10:47:05 <Younder> EvanR-work, I use postgresql myself. Need a interface?
10:47:20 <bos> EvanR-work: i took it over a few months ago
10:47:31 <EvanR-work> cool so maybe actual progress will be made ;)
10:47:39 <bos> EvanR-work: could you please file a bug against it?
10:47:46 <bos> http://github.com/mailrank/hdbc-mysql/issues
10:47:47 <EvanR-work> on github?
10:47:54 * EvanR-work grumbles about having to register
10:49:52 <EvanR-work> Younder: to postgres?
10:50:01 <Younder> My interest's Haskell, Mathematics, Machine intelligence and Compiler theory
10:50:06 <Younder> EvanR-work, yes
10:50:12 <EvanR-work> im using mysql
10:50:18 <acowley> github is great except for the too onerous price for private repos
10:51:49 <bos> EvanR-work: just be aware that there's no prospect i'll get near that bug for at least a month, if not several
10:52:12 <EvanR-work> currently we do not critically depend on the fix to that bug
10:52:22 <Younder> acowley, how about sourceforge?
10:52:24 <EvanR-work> we worked around it about a year ago
10:52:43 <EvanR-work> but now im revisiting using haskell and mysql for a new project, and was checking on this
10:52:50 <hpaste> vokoda pasted “No instance for...” at http://hpaste.org/50898
10:52:57 <bos> i just avoid using stored procedures, and avoid using HDBC
10:53:08 <bos> so i don't get bit by that
10:53:26 <EvanR-work> do you mean prepared statements
10:53:39 <vokoda> I have a question in that paste ^
10:53:48 <bos> EvanR-work: right
10:53:57 <acowley> Younder: I haven't used SF to host a project for a few years. Back then (and from what I've seen when downloading something from them), my preference for github was based on the rich integration of git (forking) and the much better aesthetics, performance, and usability.
10:54:02 <bos> EvanR-work: they're handled by the same machinery in the library
10:54:03 <Younder> Great fan Of Simon P. Jones. I have found his work invaluable in creating Formula.
10:54:14 <EvanR-work> ive come to that conclusion several months ago, but my managers will scream bloody hell if i try to implement that
10:54:44 <EvanR-work> because 'performance' and 'substitution sanitization'
10:54:51 <Saizan> ?pl s0 x1 x2 = rotate (x1 + x2) (-2)
10:54:51 <lambdabot> s0 = flip flip -2 . (rotate .) . (+)
10:54:56 <Saizan> heh
10:55:03 <bos> EvanR-work: the performance thing is mostly a red herring
10:55:04 <acowley> vokoda: you're asking for function bits
10:55:08 <EvanR-work> bos: really
10:55:13 <bos> EvanR-work: yep
10:55:25 <Saizan> vokoda: s0 = ((\x -> rotate x (-2)) .) . (+) -- this would work
10:55:32 <acowley> vokoda: (+) is a binary operation, so you need to be careful plumbing through it with function composition
10:55:35 <bos> and in fact the mysql-simple library is *much* faster than HDBC-mysql
10:55:47 <EvanR-work> i was wondering about that, is mysql-simple ready?
10:56:03 <EvanR-work> the api doc doesnt seem to work on hackage
10:56:38 <Younder> postgresql is vastly superior to MySql
10:56:38 <bos> EvanR-work: i've been using it in production for months
10:56:52 <bos> it doesn't support prepared statements or stored procedures
10:56:56 <bos> but that's about it
10:57:05 <vokoda> acowley, Saizan: I see, what does that extra dot do? I've never seen one appear before a closing bracket like that
10:57:53 <acowley> vokoda: follow the types!
10:58:19 <EvanR-work> Younder: yes but nowadays im so skeptical of mainstream RDBMS systems that i used them for only the most super basic-ass storage
10:58:40 <byorgey> vokoda: have you seen operator sections like  (2 +)  ?
10:58:48 <EvanR-work> i dont even try to use the RDBMS to enforce data
10:59:23 <RichardBarrell> EvanR-work: why so sceptical of them?
10:59:29 <byorgey> (e +) is equivalent to \x -> e + x, and likewise (+ e) is  \x -> x + e
10:59:42 <byorgey> so (foo .) is just a partial application of the (.) operator to foo
10:59:44 <EvanR-work> RichardBarrell: because relative to haskell, its a joke
11:00:29 <EvanR-work> mainstream RDBMS is the php of relational
11:00:54 <vokoda> byorgey: ahh, ok I understand. thanks
11:01:05 <RichardBarrell> What have you seen that's better?
11:01:43 <EvanR-work> haskell
11:01:54 <_habnabit> 'mainstream' RDBMSes? what do you use that's not mainstream
11:02:00 * hackagebot hfd 0.0.2 - Flash debugger  http://hackage.haskell.org/package/hfd-0.0.2 (YurasShumovich)
11:02:03 <EvanR-work> nothing
11:02:09 <EvanR-work> im using fuckin mysql right now
11:02:32 <maurer_> quicksilver: ?
11:02:55 <EvanR-work> bos: submitted 'issue'
11:03:13 <bos> EvanR-work: thanks
11:04:21 <EvanR-work> also im going to check out mysql-simple
11:04:52 <EvanR-work> bos: where can i find a manual about it?
11:06:00 <bos> EvanR-work: for now, just look at the haddocks. i'm in the exciting position of being too busy to blog about it.
11:06:01 <EvanR-work> i see comments in the code but hackage doesnt have links
11:06:46 <bos> EvanR-work: that's because the build failed on haskell.org
11:07:03 <EvanR-work> :S
11:07:08 <bos> EvanR-work: so do a "cabal haddock" on your machine and read the docs ther
11:07:14 <EvanR-work> ok
11:15:22 <EvanR-work> hehe newtype Only a
11:15:34 <EvanR-work> fromOnly :: Only a -> a
11:16:01 <EvanR-work> brilliant
11:16:13 <kmc> fromOnly? sounds unsafe
11:16:34 <kmc> better use pattern matching instead
11:16:34 <kmc> ;)
11:16:35 <RichardBarrell> Constructing a finite value of type (Mu Only) is left as an exercise for the reader.
11:16:39 <EvanR-work> lol
11:16:49 <kmc> RichardBarrell, i, too, enjoy assigning impossible exercises
11:18:06 <EvanR-work> and so, it finally becomes apparent that you need a 1ple
11:18:22 <kmc> but (,), (,,) and friends are lifted products
11:18:31 <kmc> so shouldn't it be "data Only a = Only a"?
11:18:33 <kmc> not newtype?
11:18:43 <EvanR-work> hm
11:18:46 <EvanR-work> tell bos
11:18:49 <bos> nope
11:20:51 <benford> Hi everyone - is anyone using eclipsefp on osx? I'm having some trouble getting it set up
11:21:16 <EvanR-work> bos: can you use In at the same time as normal substitutions
11:21:44 <bos> EvanR-work: yes
11:22:20 <EvanR-work> (99, In []) like this?
11:22:46 <kmc> :t (99, In [])
11:22:46 <lambdabot> forall t. (Num t) => (t, Mu [])
11:22:51 <EvanR-work> but (Only (In [])) is unnecessary? ;)
11:23:09 <EvanR-work> apparently In was taken
11:25:43 <joe6> copumpkin, with your modifications: http://codepad.org/xsdhcLy7, code I endeup up with: http://codepad.org/dcciYIBb
11:26:05 <joe6> any suggestions on making this better, please : http://codepad.org/dcciYIBb
11:30:38 <MHD> Is Yi available for fedora?
11:32:07 <hpc> MHD: try searching for it in the yum package database?
11:32:13 <hpc> i forget the command to do that
11:32:40 <MHD> I don't actually have fedora yet. Just checking
11:32:53 <EvanR-work> bos: looks pretty amazing, writing it in my list of amazing haskell libs
11:33:38 <hpc> MHD: doesn't look like it has yi
11:33:56 <hpc> don't let that stop you from compiling from source :P
11:34:59 <MHD> hpc: heh, I'll do that.
11:41:12 <EvanR-work> bos: is autocommit for connection default False ?
11:43:57 <DukeDave> Hello all, so I have three data structures (two maps and a graph) which I need to keep synchronised. They are all being used within a WX app, so there's a timer updating one map, and various callbacks which can update the other map and the graph at any time.
11:43:57 <DukeDave> Each time an 'update' happens I update exactly one of the three things, and I'm looking for some 'strategy' to nicely encapsulate each update and ensure the other two data structures are kept in synchronisation.
11:43:58 <DukeDave> Any suggestions?
11:44:44 <EvanR-work> heh
11:44:59 <EvanR-work> 'when one changes, change the other two' leads to an infinite loop ;)
11:45:35 <EvanR-work> so you need to change the problem
11:45:43 <DukeDave> EvanR-work: Ah, well, yes, I see what you mean.
11:45:45 <DukeDave> Except..
11:46:01 <DukeDave> The update does only go one way..
11:46:42 <EvanR-work> usually two of the things are based on the third, like a tree
11:47:39 <DukeDave> For example, I update the position of things, the positions are stored in two maps (yes, duplication, bad), one map belongs to a layout algorithm and one to the UI. Sometimes the layout algorithm updates the position, and sometimes the UI does it.
11:48:09 <DukeDave> So I need to replicate the 'most recently updated' position to the other map
11:48:44 <EvanR-work> so its model model view controller ;)
11:48:53 <DukeDave> I'm in this position because I was trying to keep multiple systems separate..
11:49:29 <EvanR-work> where model = model
11:50:08 <acowley`> DukeDave: so where exactly are you stuck?
11:50:33 <DukeDave> acowley: I just sense a bad smell in the design
11:50:55 <EvanR-work> factor out the common parts of your state
11:51:22 <EvanR-work> make it simpler so it can be used by both systems and theres no chance of one requiring a core change that is incompatible with the other
11:51:33 <EvanR-work> additional features can still be separate
11:51:42 <DukeDave> EvanR-work: I thought about that, but keeping them separate really does make the rest of the system much simpler, I don't parts of one object 'bleeding' into another.
11:51:42 <EvanR-work> but they dont overlap
11:51:48 <byorgey> DukeDave: you may be interested in http://hackage.haskell.org/package/pointless-lenses
11:52:01 * hackagebot hledger 0.15.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.15.1 (SimonMichael)
11:52:03 * hackagebot hledger-vty 0.15.1 - A curses-style console interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-vty-0.15.1 (SimonMichael)
11:52:05 * hackagebot hledger-chart 0.15.1 - A pie chart image generator for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-chart-0.15.1 (SimonMichael)
11:52:07 * hackagebot hledger-web 0.15.2 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.15.2 (SimonMichael)
11:52:11 <acowley> TVar == Febreze
11:52:39 <DukeDave> byorgey: This looks complicated :|
11:52:52 <byorgey> DukeDave: well don't blame me!
11:53:04 <byorgey> bidirectional programming is not simple
11:53:22 <DukeDave> Hmm, I'll write a simple case of the problem in hpaste, to save spamming the channel :)
11:53:35 <byorgey> any other way of doing it is going to be even more complicated, trust me
11:53:39 <acowley> If you have a timer whose effects should be coordinated with user interaction, put the pieces in TVars and write your handlers as needed
11:54:09 <DukeDave> acowley: But, TVars are bad? :|
11:54:18 <acowley> Why?
11:55:01 <acowley> You're coordinating mutations between different subsystems
11:55:04 <acowley> TVars are great for this
11:55:12 <DukeDave> acowley: They scare me :)
11:55:21 <acowley> do MVars scare you?
11:55:38 <acowley> or IORefs?
11:55:58 <EvanR-work> MVars scare me in a good way
11:56:14 <acowley> The "T" stands for thrilling?
11:57:04 <kmc> ♥ STM
11:57:07 <kmc> RWH's chapter is good
11:57:33 <joe6> any suggestions on this code, please? BitField.hs http://codepad.org/7rU69YPY, Trnif.hs (instance of BitField): http://codepad.org/sqiPKbJP, usage of Trnif: http://codepad.org/LUiOYfkN
11:58:52 <DukeDave> Perhaps it's just time I embraced it, I actually flirted with using STM before in this project..
11:59:18 <EvanR-work> still doesnt solve your triple dependent graph updater ;)
11:59:39 <EvanR-work> i guess you can just have three event handlers, update 1 2, update 1 3, and update 2 3
11:59:48 <acowley> DukeDave: Now is the time! If you've got multiple threads hitting the same state, you must stare concurrency in the eye without blinking!
12:02:19 <EvanR-work> i do not understand mysql timestamp datatype
12:03:03 <EvanR-work> it seems to represent time in the same range as unix time, yet when you store 'now' in the db, it shows with a timezone adjustment (and mysql has no concept of timezones)
12:03:59 <hpaste> DukeDave pasted “Synchronising data structures” at http://hpaste.org/50899
12:05:09 <Eduard_Munteanu> EvanR-work: maybe it stores now@UTC?
12:05:18 <EvanR-work> that would make sense
12:05:26 <DukeDave> acowley: Well, I don't really consider it a multi-threaded problem, e.g. it doesn't *have* to be a multi-threaded problem...
12:05:27 <EvanR-work> because thats what unix time is
12:05:40 <EvanR-work> but it shows my local time in the db
12:05:41 <DukeDave> Everything can happen in lock-step..
12:06:22 <DukeDave> EvanR-work: Yeah, the three event handler solution is more or less what I have at the moment, but it feels a little un-elegant.
12:06:36 <DukeDave> But then I don't see the need to go down the STM route either.
12:06:43 <EvanR-work> KISS
12:06:58 <Eduard_Munteanu> Well, whether it has proper timezone support or not is different from whether it converts time to local time when you query it, I'd guess.
12:07:26 <EvanR-work> Eduard_Munteanu: if it converts to local time when you query it, that would be insane
12:07:59 <EvanR-work> that would make the data (that any client sees) depending on the location of the server
12:08:03 <acowley> DukeDave: Oh, I thought you had multiple things that could update the state in overlapping time intervals (layout and UI)
12:08:14 <EvanR-work> and if there are replicating slaves in differnt time zones... then LOL
12:08:48 <Eduard_Munteanu> EvanR-work: no, I mean maybe the internal representation is UTC time, but when you query it you get local time. Anyway, this was just a wild guess.
12:08:56 <DukeDave> acowley: I don't believe so, although I'm not sure
12:08:57 <EvanR-work> see what i said about that
12:09:00 <Eduard_Munteanu> (since nobody else replied)
12:09:13 <DukeDave> Doing UI in Haskell makes my brain hurt a little
12:09:22 <DukeDave> I'm used to one nice flow of control
12:09:41 <Eduard_Munteanu> EvanR-work: hm? If every server deals in UTC time internally, then nothing wrong could happen.
12:10:05 <EvanR-work> Eduard_Munteanu: the internal representation almost certainly has to be in UTC, since its a unix timestamp (maybe thats my flawed assumption), but then... <cancel message to reply>
12:11:02 <EvanR-work> not nothing wrong can happen, if clients 'see' the data as converted to <some time zone> then that makes no sense except a single server that never moves
12:11:11 <acowley> DukeDave: GUIs usually suggest multithreading
12:11:14 <Eduard_Munteanu> Try setting a different timezone and querying it, or look in the manual, dunno.
12:11:22 <EvanR-work> acowley: i refuse to accept that
12:11:30 <Phyx-> bleh, ever since hackage got ghc 7.2 my stuff doesn't build anymore
12:11:30 <acowley> DukeDave: You want to be responsive to UI and do your own thing, too
12:11:55 <acowley> EvanR-work: I think one needs to make a distinction between implementation and API
12:12:27 <EvanR-work> acowley: green threads are enough for a GUI
12:12:46 <EvanR-work> in which case you dont need to know about them from your perspective, just write event handlers
12:13:01 <acowley> EvanR-work: if DukeDave is interfacing with WX, then he's at the implementation level. It is a good idea for him to build as small a component as possible that cares about the potential existence of multiple threads.
12:13:01 <EvanR-work> so not only does it appear non threaded, it really isnt
12:13:16 <EvanR-work> well thats WX, not GUI
12:13:27 <acowley> even with green threads and event handlers
12:13:43 <EvanR-work> so i reject GUI 'usually implying' that
12:13:43 <acowley> if you want your event handlers to be able to interrupt each other and share state, you must deal with their interactions
12:14:03 <EvanR-work> big if
12:14:10 <acowley> I maintain it. If you run business logic on the same CPU thread as animation you have a bad GUI application.
12:14:18 <EvanR-work> tell that to the entire www
12:14:36 <acowley> My browser uses one CPU thread?
12:14:38 <EvanR-work> in this bizarre instance i actually agree with them
12:14:54 <EvanR-work> a webpage running js uses one thread, yes
12:15:10 <EvanR-work> the event handlers cant interrupt each other
12:15:31 <acowley> so I come back to what I said earlier
12:15:35 <DukeDave> acowley: Well, in the code I'm working on there is one TVar (tuple of my three data structures), and this TVar is passed to each of the event handler functions. So I *presume* when a handler function is called it's allowed to complete before another one is called?
12:15:49 <Eduard_Munteanu> Well, it's not like threads are the only solution.
12:15:55 <EvanR-work> ye
12:16:01 <DukeDave> I'm open to suggestions :)
12:16:03 <acowley> you're arguing that given a multithreaded GUI platform, you can write logic in a single-threaded style
12:16:20 <EvanR-work> i dont think i am
12:16:33 <Eduard_Munteanu> You can avoid concurrency altogether if your CPU-intensive task can yield to the GUI lib for updates and redraws.
12:16:40 <acowley> saying that a web browser doesn't use multiple threads just because they're not exposed at the JS level is disingenuous
12:16:40 <EvanR-work> js isnt a multithreaded gui platform, its not even green threaded
12:16:56 <EvanR-work> im talking about 'GUI', you apparently want to talk about something else
12:17:21 <acowley> No, I'm talking about how a GUI-based application is implemented because that's what DukeDave is doing.
12:17:21 <joe6> how do I find the (sizeOf CUInt)?
12:17:32 <EvanR-work> acowley: 'a' implying 'all' ?
12:17:39 <EvanR-work> im trying to tell you it isnt
12:18:02 <joe6> > (sizeOf (1::CUInt))
12:18:03 <lambdabot>   Not in scope: `sizeOf'Not in scope: type constructor or class `CUInt'
12:18:52 <byorgey> joe6: like that
12:19:40 <Eduard_Munteanu> joe6: http://www.haskell.org/ghc/docs/7.2.1/html/libraries/base-4.4.0.0/Foreign-Storable.html#v:sizeOf
12:20:19 <Eduard_Munteanu> Though   sizeOf (undefined :: CUInt)   would work too.
12:20:54 <joe6> Eduard_Munteanu: thanks, just figured that out, too.
12:22:02 <DukeDave> Soooo, there's no existing 'model' for what I'm trying to do then? :|
12:22:40 <Eduard_Munteanu> DukeDave: what are you trying to do?
12:22:49 <EvanR-work> DukeDave: i was saying factor out the common parts of your state.
12:23:07 <joe6> anyone kind of enough to give some feedback on this, please? BitField.hs: http://codepad.org/xYKaiEhX, instance: http://codepad.org/ALiv1tNu, usage: http://codepad.org/rO4kfCCi
12:23:12 <DukeDave> Eduard_Munteanu: I have this arrangement, and it's fugly: http://hpaste.org/50899
12:23:29 <EvanR-work> as far as keeping identical different models synchronized is a problem that is dealt with in distributed databases
12:23:41 <EvanR-work> but it seem inappropriate for a gui app
12:24:24 <DukeDave> EvanR-work: Mm, well I'd like to keep different 'view's of the state, rather than share a common one
12:24:41 <EvanR-work> DukeDave: if they are different views of the same raw data, then thats that
12:24:47 <EvanR-work> not two copies of data
12:25:10 <EvanR-work> when you want a view, recompute from the raw data
12:25:20 <EvanR-work> when you want to change the data, change the raw data
12:25:24 <EvanR-work> both views will update
12:25:50 <EvanR-work> this is often diregarded because of 'performance'
12:25:59 <Eduard_Munteanu> I'm not sure you really need any concurrency / latency provisions for that.
12:26:01 <EvanR-work> i.e. fear uncertainty and doubt
12:26:15 <EvanR-work> yeah i dont recommend any concurrency here
12:27:16 <DukeDave> EvanR-work: That makes a lot of sense, I'm just not sure how to express it in Haskell such that each of the three systems (graph, layout, UI) can exist autonomously..
12:27:37 <DukeDave> I figure that since they can exist autonomously, they should be able to..
12:27:44 <EvanR-work> DukeDave: well they cant exist automonomously, the way i described it is the views are dependent on the underlying data model
12:27:58 <EvanR-work> so you at least need your data model
12:28:02 <EvanR-work> even if its invisible
12:29:06 <DukeDave> But I don't like the idea that the three systems are 'bound together' by a common data model; I'd rather express all three separately and then bring them together in a module which imports all three.
12:29:15 <DukeDave> I suspect this may be where interfaces come in..
12:29:20 * EvanR-work scratches head
12:29:59 <EvanR-work> do you disagree that they are already dependent on the same underlying model?
12:30:53 <EvanR-work> import the three views, each of which takes data as a parameter, what that data is can be in a fourth module
12:30:54 <Eduard_Munteanu> DukeDave: they're not tied by a common data model, but by conversions between each two components.
12:31:35 <DukeDave> Eduard_Munteanu: Yes! That's a good way of expressing it..
12:31:38 <EvanR-work> Eduard_Munteanu: that assumes full two way conversion potential, and sounds more like what DukeDave wants to do, which makes it more complex
12:31:49 <EvanR-work> but 'views' may lose information, generally
12:31:52 <DukeDave> EvanR-work: Aha, okay, that sounds like a good idea
12:32:44 <Eelis> is there a wiki page somewhere for Haskell projects/packages that could use some help?
12:34:04 <Eduard_Munteanu> No, but there could be shortcuts depending on how your application behaves.
12:34:47 <Eduard_Munteanu> You could even set up your chain of conversions like a triangle 1 -> 2 -> 3 -> 1.
12:34:48 <Eelis> was that a response to me or to EvanR-work ?
12:34:59 <EvanR-work> Eduard_Munteanu: uhg
12:35:02 <DukeDave> I suppose the crucial thing is that each system can read and write to the common data model, but in a way which doesn't require it to know anything about the common data model..
12:35:08 <Eduard_Munteanu> Eelis: EvanR-work and DukeDave
12:35:11 <Eelis> ok
12:35:20 <EvanR-work> 1 -> 2 -> 3 -> 1 requires ability of two way conversion
12:35:22 <EvanR-work> ;)
12:35:39 <DukeDave> Oh, none of my updates will be cyclical..
12:36:01 <DukeDave> It really is just: read from model, change something, write to model.
12:36:04 <EvanR-work> rather than 6 conversions (3 two way), just have 3 one way
12:36:33 <DukeDave> EvanR-work: Yeah, that'll be the three I list at the bottom of here: http://hpaste.org/50899
12:36:50 <joe6> copumpkin, the associated type that you recommended yesterday worked like a  charm. Thanks a lot for your help.
12:44:44 <hpaste> DukeDave annotated “Synchronising data structures” with “Bad looking synchronisation code” at http://hpaste.org/50899#a50900
12:45:10 <DukeDave> EvanR-work: That's what it looks like at the moment^
12:45:10 <EvanR-work> haha
12:45:23 <DukeDave> So you see, it's not idea :|
12:45:25 <DukeDave> *ideal
12:45:33 <EvanR-work> your three event handlers i would keep it the way it is
12:45:38 <EvanR-work> because its done
12:45:49 <EvanR-work> if you want to do it right use model view distiction
12:45:55 <EvanR-work> distinction
12:46:57 <DukeDave> EvanR-work: There is a way I could do that, without having my model 'leak' into the individual systems?
12:47:18 <EvanR-work> i hate 'system'
12:47:42 <DukeDave> 'modules' :)
12:47:45 <DukeDave> 'namespaces' :)
12:47:57 <EvanR-work> exactly what problem then are you trying to avoid
12:48:07 <DukeDave> 'orthogonal system components'
12:48:20 <DukeDave> Well the three parts really don't need to know about each other
12:48:35 <EvanR-work> three views of the same data, no, i agree
12:48:46 <EvanR-work> dont need to know about each other and i dont see how they could
12:49:16 <DukeDave> Cool. I'm just wondering how to model that in Haskell
12:49:26 <EvanR-work> the important part if figuring out what that data form is behind it all and get that right
12:50:04 <DukeDave> EvanR-work: Yeah, that's obvious if you look at a union of the three systems views
12:50:06 <EvanR-work> DukeDave: as i said, a view is just a function, so if your model is D, then views could be D->A D->B and D->C
12:50:30 <DukeDave> EvanR-work: Right, but how could I go back the other way? :|
12:50:35 <EvanR-work> why would you want to
12:50:53 <EvanR-work> modifying D is another story entirely
12:51:07 <DukeDave> There you go
12:51:27 <DukeDave> Are we about to get back to TVars? :)
12:51:27 <EvanR-work> just expose some modifier 'methods' for D and use them
12:51:32 <EvanR-work> hell no
12:52:16 <DukeDave> Each part will have to know about D then though, right?
12:52:35 <EvanR-work> yes, thats the point
12:52:50 <DukeDave> They can't just say setPosition (c :: C) newPosition
12:53:07 <EvanR-work> if the core model here is 'position' that would make sense
12:53:36 * elliott wonders if DukeDave wants lenses.
12:53:38 <EvanR-work> i dont know your details so i dont know what it is
12:54:19 * byorgey already suggested lenses
12:55:02 <byorgey> which are exactly what let you "go back the other way" after updating a view
12:55:26 <EvanR-work> weird
12:55:40 <byorgey> what's weird about it?
12:56:00 <EvanR-work> "go back the other way" after "updating a view"
12:56:06 <byorgey> there are tons of scenarios in which you want to do that
12:56:13 <EvanR-work> i just dont understand what it means
12:56:43 <byorgey> for example, imagine a document or database where some parts are classified, but you want to enable people with no security clearance to edit the non-classified portions
12:56:53 <DukeDave> Ah, sorry guys, I should have scanned this lenses PDF linked on the pointless-lenses package earlier :|
12:56:55 <byorgey> and for their edits to be propagated back to the master document
12:57:17 <DukeDave> There you go, what byorgey said :)
12:57:28 <DukeDave> EvanR-work: Sorry for leading you in circles there :|
12:57:32 * EvanR-work scratches head
12:57:46 <EvanR-work> DukeDave: i realize what you want, im questioning whether its good
12:58:03 <EvanR-work> byorgey: what do you mean classified
12:58:11 <byorgey> secret
12:58:43 <EvanR-work> ok so when you say 'update a view' you mean *modify a view* like, without giving it a different source
12:58:49 <byorgey> right
12:58:52 <EvanR-work> thats weird
12:59:02 <elliott> It sounds like DukeDave just wants to modify record fields. Am I naive?
12:59:11 <elliott> Or at least, something close to it.
12:59:30 <EvanR-work> byorgey: its not a view anymore xD
12:59:44 <DukeDave> EvanR-work: I see three systems, each of which could exist on their own (pretend they're all on hackage already), but I want to provide the 'glue' use them together, using the same underlying data model..
12:59:58 <byorgey> EvanR-work: it depends on how you define the term.  let's call it an "editable view" if you like =)
13:00:08 <EvanR-work> DukeDave: from what i heard, you want to glue them together *without* any underlying model
13:00:23 <EvanR-work> byorgey: brain explodes
13:00:45 <DukeDave> I have an underlying model, but I don't want that model to bleed into each of the component systems
13:01:01 <EvanR-work> if you call it bleeding, no wonder why you are scared
13:01:05 <DukeDave> :D
13:01:13 <EvanR-work> how about 'depending on'
13:01:35 <DukeDave> ... Is an equivalent, less scary term..
13:01:41 <EvanR-work> great
13:02:02 <EvanR-work> its like parsec is bleeding into the json lib
13:02:16 <EvanR-work> not something to fix, because its not a problem
13:03:04 <EvanR-work> DukeDave: three hackage packages? so make a fourth with this model ;)
13:03:55 <DukeDave> Lenses to seem to be the approach I'm looking for
13:04:50 <EvanR-work> byorgey: im imagining defining a view in phpmyadmin, and being able to edit the fields ;)
13:05:00 <EvanR-work> having who-knows-what effects
13:10:39 <byorgey> EvanR-work: actually, the first research on this problem was actually done in the database community
13:10:54 <EvanR-work> yeah sounds like it
13:11:06 <roconnor> did someone say lens?
13:11:21 <byorgey> =)
13:11:43 <byorgey> roconnor: DukeDave has three data structures he wants to keep in sync
13:11:46 <EvanR-work> im going to call this a reverse view, i.e. not a view at all, i.e. why the hell is it called lens
13:11:54 <joe6> is there any way that I can derive type CType Trnif    =  CUInt
13:12:03 <joe6> from p'U1IR: type CType Trnif    =  CUInt
13:12:09 <joe6> http://codepad.org/91isIGvp
13:12:29 <byorgey> EvanR-work: a lens is a view along with a way to propagate changes to the view back to the source.
13:12:31 <joe6> in this file, http://codepad.org/91isIGvp, I generate foreign import ccall "&U1IR" p'U1IR :: Ptr (CUInt)
13:12:40 <joe6> using bindings-dsl macro.
13:12:42 <byorgey> EvanR-work: obviously this can't work for just any old view.
13:12:43 <EvanR-work> 'changes to the view' sounds insane
13:13:20 <roconnor> EvanR-work: is exactly the same as updating a field in a record.
13:13:35 <joe6> is there a way of assigning the Ctype of p'U1IR auotmatically to  type CType Trnif    =  CUInt
13:13:55 <EvanR-work> roconnor: i dont think of views as something that can be 'editted'
13:14:09 <EvanR-work> 2 + 2
13:14:13 <EvanR-work>  > 4
13:14:18 <EvanR-work> can i edit the 4 ?
13:14:31 <EvanR-work> 5
13:14:34 <EvanR-work> 2 + 3
13:14:34 <roconnor> sure, by themselves a views cannot be edited
13:14:37 <EvanR-work> lol
13:14:53 <roconnor> thats why lenses are not views
13:15:06 <EvanR-work> stupid name
13:15:07 <roconnor> or at least they are not just views
13:15:12 <joe6> in an associated type, is there a way to read the type from a function, instead of statically defining it with "type CType bitField :: *", as I did in my case?
13:15:13 <roconnor> ya well
13:15:20 <roconnor> blame Peirce
13:15:31 <Enigmagic> joe6: might have to create another header file that does that, i don't think bindings-DSL supports arbitrary type classes/type families
13:15:37 <roconnor> EvanR-work: we can call them functional-references instead
13:15:40 <roconnor> I'm okay with that
13:16:34 <joe6> Enigmagic: I am generating the type class instance from a different script and I append it to the .hsc file, so that the bindings-dsl can process it.
13:16:52 <EvanR-work> roconnor: that terminology frightens me
13:17:08 <joe6> my problem is that I want some way of reading the CUInt automatically from the type of p'U1IR
13:17:29 <joe6> maybe, I can use TH for this.
13:17:34 <roconnor> EvanR-work: how about coalgebra-of-store-comonad?
13:17:47 <EvanR-work> thats better
13:18:22 <roconnor> you can use coalgebra-of-store-comonad to provide updatable views ... kinda like looking through a lens.
13:18:32 <roconnor> wait that isn't at all like looking through a lens.
13:18:39 <EvanR-work> right
13:18:56 <EvanR-work> maybe its like looking through a lens at the same time as doing something completely different
13:19:06 <Enigmagic> joe6: who is deciding the type is CUInt?
13:19:28 <joe6> a sed script that is reading from a .h file
13:19:59 <Enigmagic> joe6: why don't you just set the type in the sed script?
13:21:03 <joe6> unfortunately, the sed script does not know about the existence of the Trnif instance.
13:21:30 <Enigmagic> hsc2hs/bindings-DSL don't really know about types either
13:21:32 <joe6> i get the Trnif instance from a different script, which does not know the type of p'U1IR
13:21:41 <Enigmagic> neither does CPP
13:21:43 <joe6> i understand that.
13:22:06 <joe6> I am thinking about getting the type dynamically from p'U1IR (something like TH).
13:22:19 <Enigmagic> TH can do it but now you'll need two modules instead of one
13:22:22 <joe6> at compile time.
13:22:51 <EvanR-work> lenses use comonad?
13:22:56 <joe6> yes, that's true.
13:24:40 <Enigmagic> otherwise it'll work... bit more work though imo unless you're already comfortable with uniplate
13:28:53 <accel> what is the closest thign to a variatn of haskell that runs on the JVM?
13:29:44 <tech2> accel: there used to be Jaskell iirc.
13:31:16 <tech2> accel: there was also CAL a while ago, but that's not _quite_ haskell.
13:31:42 <accel> so basically nothign modern?
13:32:36 <parcs> scala
13:32:50 <accel> scala is close to haskell?
13:32:55 <EvanR-work> not really
13:33:08 <Dashkal> The JVM doesn't play all that well with how haskell does things.  Scala is the clest I've seen in that scala does FP type things, but it's a very pale shadow
13:33:15 <parcs> accel: it's the closest thing to a variation of haskell that runs on the jvm
13:33:30 <EvanR-work> 'variants of haskell' basically means 'haskell'
13:33:37 <EvanR-work> close to haskell means... clean
13:34:23 <quicksilver> maurer_: tab complete failure that's all :)
13:44:56 <maurer_> OK
13:45:11 <brad_> [hi]
13:52:46 <byorgey> hi brad_
13:57:52 <Dashkal> Huh, never would have thought of that.  The Monoid for Ordering is pretty handy
14:04:09 <EvanR-work> Dashkal: interesting
14:04:20 <EvanR-work> whats mappend?
14:06:25 <zzo38> http://sprunge.us/cDPR
14:06:28 <shachaf> > map (\[x,y] -> (x,y,mappend x y)) $ replicateM 2 [LT,EQ,GT]
14:06:29 <lambdabot>   [(LT,LT,LT),(LT,EQ,LT),(LT,GT,LT),(EQ,LT,LT),(EQ,EQ,EQ),(EQ,GT,GT),(GT,LT,G...
14:06:45 <gabor> I have a tricky typeclass question, can anybody help me?
14:06:45 <rwbarton> it's so that compare (a1, b1) (a2, b2) = compare a1 a2 `mappend` compare b1 b2
14:07:08 <Dashkal> EvanR-work: mappend combines two monoid values into another.  For example, the Sum Monoid for Ints combines using + (1 + 2) = 3, (Sum 1 `mappend` Sum 2) is Sum 3
14:07:11 <shachaf> gabor: Only if you ask.
14:07:11 <rwbarton> where tuples use lexicographical ordering
14:07:12 <zzo38> Is this program the Obfuscated Haskell Contest program? Not quite.
14:07:13 <geheimdienst> shachaf: yeah that clears everything up ...
14:07:22 <EvanR-work> Dashkal: i know, what is it for Ordering
14:07:56 <Dashkal> oh, misunderstood.  Lexicographical ordering.  : http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Monoid.html
14:08:15 <EvanR-work> > LT `mappend` LT
14:08:16 <lambdabot>   LT
14:08:19 <EvanR-work> > LT `mappend` GT
14:08:20 <lambdabot>   LT
14:08:26 <copumpkin> zzo38: that's doing lots of unnecessary stuff
14:08:27 <EvanR-work> > GT `mappend` LT
14:08:28 <lambdabot>   GT
14:08:31 <Dashkal> So you can mconcat a bunch of orderings to get one.  First non-EQ takes priority
14:08:34 <EvanR-work> weird
14:09:05 <copumpkin> > do { a<- Just False; Just a }
14:09:06 <lambdabot>   Just False
14:09:07 <zzo38> copumpkin: Probably it is......you write a better program if you like to do so, please.
14:09:12 <EvanR-work> > EQ `mappend` EQ
14:09:13 <lambdabot>   EQ
14:09:27 <EvanR-work> strange
14:09:47 <hpaste> gabor pasted “recursing in smaller instance errors out” at http://hpaste.org/50904
14:09:54 <EvanR-work> which finite group does that correspond to
14:10:02 <EvanR-work> S3 i guess
14:10:05 <rwbarton> it's not a group, it's a monoid
14:10:16 <gabor> shachaf: I pasted it
14:10:17 * EvanR-work scratches head
14:10:34 <EvanR-work> ah, theres strictly more monoid operators for 3 elements than group operations
14:10:40 <EvanR-work> since it doesnt need to be invertible
14:10:42 <Dashkal> EvanR-work: It'll let you do interesting things like compare [(String, String)]
14:10:50 <shachaf> It's nice how the (->) Monoid instance works with it.
14:12:10 <shachaf> > sortBy (comparing length ++ comparing head) ["abcde","cd","abre","qn"]
14:12:12 <lambdabot>   ["cd","qn","abre","abcde"]
14:12:29 <EvanR-work> head explode
14:12:43 <ddarius> > (mconcat . map compare) "cat" "car"
14:12:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
14:12:44 <lambdabot>         against inferred type...
14:12:55 <ddarius> > (mconcat . map compare) "cat" <$> "car"
14:12:55 <Dashkal> hmm, for that matter, it lends itself to a really cool sorting of String (aka [Char])
14:12:57 <lambdabot>   [LT,GT,LT]
14:14:27 <byorgey> gabor: squelch b (dc undefined)  is supposed to be of type  (d -> c),  but it is of type c
14:14:46 <byorgey> gabor: perhaps you mean something like   \d -> squelch b (dc d)
14:14:49 <rwbarton> really cool sorting?
14:14:55 <byorgey> aka  squelch b . dc
14:15:08 <gabor> yeah spotted that already
14:15:18 <gabor> but still problems
14:15:26 <byorgey> gabor: ok, what error do you get now?
14:17:13 <hpaste> gabor annotated “recursing in smaller instance errors out” with “recursing in smaller instance errors out (annotation)” at http://hpaste.org/50904#a50905
14:17:46 <gabor> byorgey: strangeness :-(
14:18:02 <gabor> where does that equality constraint come from?
14:19:48 <byorgey> gabor: the error says something about squelch (f Nothing)
14:19:56 <byorgey> which looks like it's coming from somewhere else
14:20:23 <joe6> i have something like this: :t p'U1IR = p'U1IR :: GHC.Ptr.Ptr CUInt ; typeOf p'U1IR = Ptr CUInt;
14:20:28 <gabor> aaaah, wait a sec
14:20:30 <byorgey> about ten lines later
14:20:38 <joe6> how do I extract the CUInt from the above: :t (\(Ptr x) -> x) $ typeOf p'U1IR
14:20:55 <joe6> i tried this, it says: <interactive>:1:4: Not in scope: data constructor `Ptr'
14:21:50 <byorgey> joe6: easiest way is to write  getPtr :: Ptr t -> t; getPtr = undefined;  then use  typeOf (getPtr p'U1IR)
14:22:04 <joe6> byorgey, that was easy. thanks a lot.
14:22:30 <byorgey> basically you want to do some computation on the *type* to extract the part you want before calling typeOf
14:22:44 <byorgey> and you can do that by writing undefined functions of the proper types
14:22:46 <gabor> byorgey: thanks: Ok, modules loaded: Foo.
14:22:52 <byorgey> gabor: great =)
14:24:25 <joe6> byorgey, quick question: i have this module: http://codepad.org/scX6RHkM , and I want to derive the CUInt of "type CType Trnif    =  CUInt" from the type of p'U1IR.
14:24:39 <joe6> I plan on using TH to do it. Just wondering if there is a better way than that?
14:25:35 <MHD> EQ mappend x -> x. y mappend _ -> y
14:26:43 <byorgey> joe6: oh, if you're using TH, then don't go via typeOf/TypeRep.  Use 'reify' to get information about p'U1IR, including its type
14:27:07 <byorgey> then you can directly pattern match on the type to extract the part you want
14:27:26 <byorgey> TH uses a different data type to represent types, called simply Type
14:27:27 <joe6> let me try reify again. I did not understand it the first time.
14:27:34 <joe6> TH is my only option, is it?
14:27:48 <joe6> Is there any way that I can derive the type from the function pointer?
14:27:56 <byorgey> I don't know of any other way to do that.
14:28:07 <joe6> ok, thanks.
14:37:23 <hpaste> int80_h pasted “ghci hangs, why?” at http://hpaste.org/50906
14:38:32 <int80_h> hey-o
14:38:54 <int80_h> I submitted my hpaste before actually coming to the channel, would it still work?
14:39:08 <int80_h> or should I just paste the url here?
14:39:27 <c_wraith> it worked
14:39:30 <hpc> apparently
14:39:31 <int80_h> cool
14:40:11 <int80_h> playing with Mvars makes me feel like I levelled.
14:40:27 <c_wraith> the most likely reason is that one of the MVars it's writing to isn't empty
14:41:11 <c_wraith> since fillState just writes to three MVars
14:41:18 <hpaste> “@quote” pasted “channel spam” at http://hpaste.org/50907
14:41:23 <c_wraith> and writing to an MVar blocks when the MVar is full
14:41:25 <ddarius> Kuso.
14:41:38 <c_wraith> swearing in japanese now?
14:41:45 <int80_h> ah
14:41:47 <c_wraith> quotes defeated your attempt at exploitation :)
14:42:33 <int80_h> I couldn't figure out how to create am empty MVar, without getting complaints about types
14:42:54 <c_wraith> newEmptyMVar is polymorphic.  Either use it in such a way that the type can be inferred, or annotate it
14:45:03 <c_wraith> ...  Annotating that is something makes me wish I could use wildcards in type annotation.  IO (MVar Int) would be much more fun to write as _ (_ Int)
14:45:29 <byorgey> c_wraith: even better: explicit type application, so you could write  newEmptyMVar @Int
14:45:45 <ddarius> Java programmers should love Haskell.  It lets you annotate every -expression-.  You can't do that in Java unless you program in ANF.  Admittedly, Java programmer's would probably love ANF.
14:45:47 <c_wraith> that's a more complicated operation, semantically
14:46:15 <byorgey> c_wraith: why?
14:46:21 <c_wraith> it involves applying a type to a value
14:46:29 <c_wraith> there's more to keep in your mind
14:46:30 <byorgey> but that already happens in the core language.
14:46:39 <c_wraith> I'm not saying it's more work to implement
14:46:40 <byorgey> I think it's *simpler*, semantically.
14:46:43 <ddarius> (((f :: Int -> Int -> Bool) (3 :: Int)) :: Int -> Bool) (4 :: Int)) True :: Bool
14:47:13 <shachaf> ddarius: ...(True :: Bool) :: Bool
14:47:30 <shachaf> I guess the compiler would be able to infer that, though.
14:47:33 <hpc> > True :: Bool :: Bool
14:47:33 <lambdabot>   <no location info>: parse error on input `::'
14:47:44 <hpc> > (True :: Bool) :: Bool
14:47:44 <lambdabot>   True
14:47:59 <hpc> (::) should be infixr :P
14:48:08 <c_wraith> yes, that makes sense. :P
14:48:11 <monochrom> "newMVar True" is emphatically creating a full MVar at the onset. use "newEmptyMVar" next time
14:48:21 <shachaf> No way, what if you want to specify a kind?
14:48:25 <jeffcutsinger> > ((True :: Bool) :: Bool) :: Bool -- does it just keep going?
14:48:26 <lambdabot>   True
14:48:30 <shachaf> > True :: Bool :: *
14:48:31 <lambdabot>   <no location info>: parse error on input `::'
14:48:35 <shachaf> Hmph.
14:48:55 <hpc> shachaf: sadly you can't have values of a higher kind
14:49:00 <shachaf> > True :: forall (a :: * -> (* -> *) -> * -> *). Bool
14:49:01 <lambdabot>   True
14:49:08 <hpc> oh
14:49:18 <hpc> heh
14:49:20 <shachaf> That has nothing to do with infixity, of course.
14:49:39 <ddarius> > True :: (Bool :: *)
14:49:40 <lambdabot>   True
14:50:18 <shachaf> Oh, it does work.
14:50:25 <shachaf> It would be nice if you could take sections of ::.
14:50:27 <hpc> > ((1 :: Monad m => m Int) :: Int -> Int) 5
14:50:27 <lambdabot>   Could not deduce (GHC.Num.Num (m GHC.Types.Int))
14:50:28 <lambdabot>    from the context (GHC.B...
14:50:28 <c_wraith> with enough extensions turned on
14:51:38 <shachaf> Hmph, you can't say \Con x -> ...
14:52:03 <ddarius> > (\True x -> x) True 3
14:52:04 <lambdabot>   3
14:52:12 <joe6> how can I get the type of a function using TH / reify: http://codepad.org/neJE7XX0
14:52:49 <Enigmagic> reify doesn't work in ghci
14:52:59 <hpc> :t reify
14:53:00 <lambdabot> Not in scope: `reify'
14:53:01 <joe6> whereas the same function works on Test
14:53:13 <shachaf> ddarius: That's just annoying.
14:53:17 <Enigmagic> joe6: you'd need to use a single quote for a function
14:53:32 * shachaf is foiled by technical correctness.
14:53:43 <joe6> Enigmagic: it does: http://codepad.org/XcrXPr8I
14:54:18 * ddarius is good at being annoying through technical correctness.
14:54:23 <Enigmagic> joe6: oh because you have it in a splice.
14:54:26 <Enigmagic> it doesn't work in runQ
14:54:26 <joe6> Enigmagic: http://codepad.org/jbZKDPUE
14:54:36 <monochrom> to create MVars and have them empty and have the right types provided for you and create a ProcessState to contain them, don't do those steps separately by hand, write one action to do it all: do { x <- newEmptyMVar; y <- newEmptyMvar; z <- newEmptyMVar; return (PS x y z) }. That will figure out the types for you because of PS
14:54:57 <joe6> i think it is the single-quote in the function name that is messing things up
14:55:08 <joe6> is there a way to quote it out oslt.
14:55:23 <Enigmagic> try some parens ?
14:55:41 <Enigmagic> or just use mkName
14:56:00 <monochrom> typing commands one by one into ghci is not a substitute for writing coherent code
14:56:02 <joe6> like this: http://codepad.org/49cLv8bQ
14:56:27 <Enigmagic> guess not
14:56:43 <geheimdienst> -XIncoherentCode
14:56:56 <ddarius> monochrom: If only that were the only alternative.
14:57:18 <Enigmagic> joe6: use mkName "p'U1IR"
14:57:37 <joe6> Enigmagic: ok, thanks. hat seems to help
14:58:54 <Enigmagic> joe6: then you'll probably end up with something like a TyConI (FunD ...)
14:59:42 <joe6> @ hoogle Q Info -> String
14:59:45 <joe6> @hoogle Q Info -> String
14:59:45 <lambdabot> Prelude show :: Show a => a -> String
14:59:45 <lambdabot> Text.Show show :: Show a => a -> String
14:59:45 <lambdabot> Language.Haskell.TH pprint :: Ppr a => a -> String
15:00:36 <byorgey> it's annoying trying to play around with anything involving reify in ghci since you can't do reify in the IO monad
15:01:39 <joe6> Enigmagic: got it thanks: http://codepad.org/jGMiDDWW
15:02:23 <Enigmagic> joe6: np
15:04:03 <byorgey> joe6: there you go.  now you can just pattern match on that (AppT (ConT Ptr) ...
15:04:04 <int80_h> if there are multiple putMVars, do they queue up?
15:04:21 <Enigmagic> int80_h: yes
15:04:29 <int80_h> how big of a queue?
15:04:37 <Enigmagic> iirc it's just a linked list
15:04:47 <hpc> int80_h: one less than you actually need ;)
15:05:21 <int80_h> hpc: Ah yes, somehow I knew that but didn't want to face it. ;)
15:05:37 <joe6> byorgey: ok, thanks. doing that.
15:06:35 <Enigmagic> int80_h: should be limited by memory
15:06:49 <Enigmagic> unless there is thread limit defined somewhere
15:08:13 <JoeyA> What command should I get into the habit of using to compile single-file Haskell programs?
15:08:13 <JoeyA> I normally use ghc -Wall -O2.
15:08:13 <JoeyA> I'm on version 7.0.2
15:08:14 <JoeyA> I'm about to ping out... brb
15:08:28 <dmwit> ghc --make
15:08:45 <JoeyA> Why --make ?
15:08:55 <Enigmagic> isn't --make the default now?
15:08:58 <dmwit> To grab all the libraries it depends on.
15:08:58 <acowley> because he's old school
15:09:03 <dmwit> --make may indeed be default now
15:09:08 <geheimdienst> JoeyA: if you're on ghc 7, you can leave out --make, it's the default
15:09:10 <acowley> dmwit grew up in the 6s
15:09:11 <JoeyA> Indeed.
15:09:22 <JoeyA> I've been using --make too, but apparently I don't need it anymore.
15:09:27 <dmwit> neat
15:09:35 <JoeyA> What is the highest optimization number GHC 7 supports?
15:10:06 <acowley> pratically speaking, 2
15:10:09 <JoeyA> (Even if size takes a hit with high optimization, I prefer to use it in testing in case optimization introduces bugs.  That's mostly a C argument, though.)
15:10:19 <acowley> but there are many flag combination options
15:10:29 <acowley> so, something like -Odph still exists
15:13:49 <JoeyA> I wasn't sure if LLVM introduced any change to the maximum optimization.
15:14:17 <acowley> there are seperate options you can pass through to LLVM
15:18:56 <kjslag> is there a way to tell GHC that a function shouldn't require memory allocation on the heap (and if the heap is needed, then it's a compile warning or error)?
15:19:51 <bos> no.
15:19:55 <kjslag> eg, if   "n = sum [1..9]", I may want to assert that nothing is goes into the heap for performance reasons
15:20:05 <kjslag> would this be a reasonable feature request?
15:20:15 <joe6> any thoughts on how to fix this error, please: http://codepad.org/gJ8BKfEd , the TH file: http://codepad.org/17mY9Kou, usage: http://codepad.org/SrcbqxV3
15:20:29 <kjslag> it would mean i wouldn't have to check the core to make sure that my function run efficiently
15:21:04 <joe6> http://codepad.org/mLxZvUmS
15:22:06 <Enigmagic> joe6: try fully qualifying the function name
15:22:08 <Enigmagic> otherwise i don't know
15:22:18 <kjslag> joe6: isn't that a ghc bug?
15:22:41 <kjslag> joe6: "GHC internal error: `p'U1IR' is not in scope during type checking, but it passed the renamer"
15:22:43 <bos> kjslag: no, it's not a reasonable request. that's a huge change.
15:22:58 <kmc> imo that doesn't make it an unreasonable request
15:22:59 <acowley> kjslag: I think the best you can hope for is an RTS hook that would let you write a good test for it
15:23:12 <kmc> there can be reasonable requests which are unlikely to be fulfilled
15:23:15 <kjslag> acowley: that's a good idea
15:23:23 <joe6> with the name fully qualified: http://codepad.org/3uY207Vc
15:23:51 <Enigmagic> kjslag: or, if you can easily detect this from core, perhaps the core2core plugins in ghc 7.2 (or is it 7.4?) would allow you to detect this at compile time
15:24:13 <joe6> is it a ghc bug, then?
15:24:33 <kmc> Enigmagic, that sounds promising.  is it true that the only Core construct which allocates is "let"?
15:24:33 <kjslag> Enigmagic: it's not easy for me, but maybe it could be easy. that would be even better and would essentually implement my request
15:24:55 <Enigmagic> joe6: does it work on a function without a quote in it?
15:26:05 <Enigmagic> kjslag: maybe there is a sample plugin that you could start from
15:26:21 <joe6> Enigmagic: like this, you mean: http://codepad.org/MnskJ1ba , error: http://codepad.org/dMIizIm5
15:26:54 <joe6> Enigmagic: qualified: http://codepad.org/T8coDbvF
15:27:52 <Enigmagic> joe6: yah i don't know... looks like it could be a bug in ghc
15:28:01 <joe6> ghc error: http://codepad.org/4LmQ6LNd
15:28:07 <Enigmagic> i've never used type splices
15:28:19 <joe6> http://codepad.org/riGMP6j2
15:28:35 <joe6> should I ask in #ghc?
15:29:00 <Enigmagic> the "GHC internal error" message leads me to say yes
16:37:08 <saml> hey, i'm trying to install llvm binding on windows.
16:37:23 <saml> should I compile llvm with mingw that comes with haskell platform?
16:37:38 <saml> but it's hard to do so because mingw does not come with make.exe
16:38:16 <saml> so, i can't do  cmake -DCMAKE_MAKE_PROGRAM=$GHC\mingw\make.exe -G "MinGW Makefiles"
16:39:03 <saml> I have c:MinGW\bin\make.exe  .. and compiled llvm   and installed it to C:\MinGW .   but cabal cannot find -lLLVM*
16:39:38 <saml> even with cabal install --configure-option=--with-llvm-prefix=c:\MinGW
16:39:54 <dcoutts> saml: if gcc cannot find llvm then cabal cannot either
16:40:23 <saml> C:\MinGW's gcc can find llvm
16:40:33 <dcoutts> is that the gcc you're using with ghc?
16:40:35 <saml> C:\haskell\mingw's gcc cannot
16:40:46 <saml> how can I configure ghc to use different gcc?
16:40:48 <dcoutts> and that's the gcc that ghc & cabal are using
16:41:08 <dcoutts> saml: or alternatively, tell cabal about the extra include and lib dirs
16:41:24 <saml> oh let me try that. thanks doc
16:41:44 <dcoutts> --extra-lib-dirs= --extra-include-dirs=
16:42:02 <saml> dcoutts, thanks. saves google :P
16:42:22 <dcoutts> saml: cabal configure --help  is a handy reference here
16:43:44 <saml> -Lc:\MinGW/lib  hrm.. would this be errorsome?
16:48:30 <saml> so my llvm is compiled with ghc 4.6.0  but ghc's gcc is 4.5.0  maybe that's why
16:50:18 <accel> http://i.imgur.com/oZMpr.gif holy shit
16:50:23 <accel> how do cats jump that high
16:50:26 <accel> wrong channel, sorry
16:50:32 <hpc> accel: with their legs
16:52:35 <geheimdienst> kitti!! :-D
16:52:48 <lep-delete> cats are always relevant
16:58:33 <monochrom> cats can jump high so they can be ceiling cats watching you unsafePerformIO
16:59:17 <geheimdienst> i always thought they became a ceiling cat by  SPJ lift'ing them?
16:59:41 <parcs> > ceiling cat
16:59:42 <lambdabot>   No instance for (GHC.Real.RealFrac
16:59:43 <lambdabot>                     ([Text.PrettyPrint.H...
17:01:19 <Dashkal> :t cat
17:01:20 <lambdabot> [Doc] -> Doc
17:03:34 <Axman6> > ceiling (cat [c,a,t])
17:03:35 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
17:03:35 <lambdabot>         agains...
17:03:39 <Axman6> :(
17:04:58 <kmc> :t ceiling cat
17:04:59 <lambdabot>     No instance for (RealFrac ([Doc] -> Doc))
17:04:59 <lambdabot>       arising from a use of `ceiling' at <interactive>:1:0-10
17:04:59 <lambdabot>     Possible fix:
17:08:32 <bobzhang> hi, all, it is possible to typing fix using high-rank polymorphism?
17:08:45 <bobzhang> fix = \ f ->  (\x -> f (x x)) (\x -> f (x x))
17:09:52 <Eduard_Munteanu> bobzhang: I don't think anything Haskell can type that
17:09:59 <Cale> It's possible using an isorecursive type
17:10:13 <parcs> :t \
17:10:14 <lambdabot> parse error (possibly incorrect indentation)
17:10:21 <Eduard_Munteanu> Yeah, though it's not really Y anymore.
17:10:25 <parcs> :t \f -> (\x -> f (x x)) (\x -> f (x x))
17:10:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:10:26 <lambdabot>     Probable cause: `x' is applied to too many arguments
17:10:26 <lambdabot>     In the first argument of `f', namely `(x x)'
17:10:26 <bobzhang> Eduard_Munteanu: using high-rank still can not do it?
17:10:27 <Cale> sure it is
17:10:40 <Cale> You've just stuck some isomorphisms into it
17:10:45 <Cale> to make it typecheck
17:10:50 <Cale> but they're the identity at runtime
17:10:51 <Eduard_Munteanu> I guess that's fair.
17:11:11 <bobzhang> Eduard_Munteanu: you can typing \x -> x x with rank-2 polymorphism
17:11:11 <Eduard_Munteanu> bobzhang: nah, that won't help
17:11:18 <bobzhang> why not fix?
17:12:10 <parcs> :t \x -> x x
17:12:11 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
17:12:12 <lambdabot>     Probable cause: `x' is applied to too many arguments
17:12:12 <lambdabot>     In the expression: x x
17:12:12 <bobzhang> let {f :: (forall a . a -> a) -> b -> b ; f x = x x }
17:12:23 <bobzhang> you can do it with rank-2
17:12:36 <bobzhang> so I guess I can also typing fix with higher-rank
17:12:42 <parcs> :t (\x -> x x) :: (forall a. a -> a) -> (a -> a)
17:12:43 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
17:13:04 <hpc> > let {f :: (forall a . a -> a) -> b -> b ; f x = x x } in f (const 1)
17:13:05 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
17:13:05 <lambdabot>    arising from the li...
17:13:10 <hpc> aw
17:13:38 <parcs> haskell sux
17:15:21 <bobzhang> hpc: (const 1) is not of type forall a . a -> a
17:15:29 <kmc> @pl \m n f -> n (m f)
17:15:29 <lambdabot> flip (.)
17:15:35 <bobzhang> only one total function for forall a . a -> a, id
17:16:37 <kmc> http://okmij.org/ftp/Haskell/Fix.hs
17:16:48 <parcs> :t \f -> (\(x :: a -> a) -> f (x x)) (\(x :: a -> a) -> f (x x)) :: (forall a. a -> a) -> a
17:16:49 <lambdabot>     A pattern type signature cannot bind scoped type variables `a'
17:16:50 <lambdabot>       unless the pattern has a rigid type context
17:16:50 <lambdabot>     In the pattern: x :: a -> a
17:17:33 <bobzhang> kmc: yeap, oleg did it
17:17:36 <bobzhang> thank you
17:18:09 <bobzhang> kmc: another stupid question, can I typing fix in System F
17:18:11 <bobzhang> ?
17:18:14 <kmc> "oleg did it" is like "simpsons did it"?
17:18:23 <kmc> bobzhang, no; System F has strong normalization
17:19:26 <parcs> "Haskell is inconsistent in yet another way.
17:19:54 <bobzhang> kmc: so how System F is more expressive than simply lambda calculus?
17:20:01 <djahandarie> You can type it in F omega
17:20:08 <kmc> bobzhang, it has polymorphism
17:20:24 <kmc> you can write the identity function once and for all
17:20:24 <Eduard_Munteanu> djahandarie: how so?
17:20:30 <bobzhang> polymorphism doe not mean more expressive
17:20:36 <djahandarie> The way you do it in Haskell
17:20:38 <bobzhang> I can hand-code all the functions
17:20:42 <elliott> kmc: you can in lambda calculus too, really
17:20:44 <kmc> what do you mean by "expressive" then?
17:20:49 <kmc> elliott, not in STLC
17:20:49 <elliott> it works for all of the one types LC has
17:20:51 <elliott> oh
17:20:53 <elliott> alright then
17:20:56 <bobzhang> kmc: I mean computability
17:21:10 <elliott> bobzhang: lc is tc. it can't be more expressive without being uncomputable
17:21:11 <kmc> oh, i don't know anything about that
17:21:11 <Eduard_Munteanu> djahandarie: well, Haskell is already F_omega plus recursion
17:21:14 <kmc> that's an interesting question
17:21:22 <kmc> STLC is not Turing complete!
17:21:24 <kmc> neither is System F
17:21:38 <bobzhang> I mean any computation that can be computed in System F could not be computed in Symple lambda calculus?
17:21:39 <hpc> if either of them was turing complete they would be inconsistent
17:21:41 <kmc> bobzhang's question is how they compare to each other and I'm not sure
17:22:10 <bobzhang> since nither have fix, right?
17:22:19 <bobzhang> neither, sorry
17:22:27 <kmc> neither has fix, though you can talk about STLC+fix or SysF+fix
17:22:40 <djahandarie> Eduard_Munteanu, newtype Dream a = In { dream :: Dream a -> a }; y :: (a -> a) -> a; y = \f -> (\x -> f (dream x x)) (In (\a -> f (dream a a)))
17:23:20 <kmc> dream, eh?
17:23:25 <djahandarie> Dream in a Dream
17:23:27 <djahandarie> Is what I was going for
17:23:31 <Eduard_Munteanu> Heh.
17:23:33 <bobzhang> kmc: yeap, I see. but when neither has fix, is SysF still more expressive than STLC?
17:23:48 <bobzhang> if both have fix, both are turing complete, right?
17:23:54 <bobzhang> they are still the same expressive
17:24:06 <int80_h>  /quit
17:24:07 <int80_h> exit
17:24:13 <djahandarie> int80_h, /fail :)
17:24:14 <elliott> int80_h: no
17:24:16 <Eduard_Munteanu> I'm not sure that qualifies for System F_omega having fix.
17:24:21 <int80_h> bah
17:24:23 <kmc> yeah, with fix you can write in STLC an interpreter for (church-encoded) terms of the untyped lambda calculus
17:24:30 <int80_h> \quit
17:24:32 <djahandarie> Eduard_Munteanu, it does. All you need is recursive types and you can type fix
17:24:37 <elliott> int80_h: would you like a guide on quitting irc?
17:24:39 <elliott> ah, good.
17:24:45 <kmc> pull the plug!
17:25:07 <Eduard_Munteanu> kmc: you should add that to the FAQ
17:25:15 <kmc> (i'm not 100% sure of that claim but it seems pretty likely)
17:25:23 <kmc> heh Eduard_Munteanu
17:25:30 <kmc> right next to "How do I shot web?"
17:25:40 <Eduard_Munteanu> :)
17:26:13 <bobzhang> I still don't understand why somebody claim that SystemF is more expressive than Simple typed lambda calculus?
17:26:21 <kmc> who claimed this?
17:26:34 <djahandarie> bobzhang, they were most likely using a different defintion of 'expressive' than you.
17:26:52 <bobzhang> expressive means computability, right?
17:27:00 <kmc> most programmers use it to mean something fuzzy about how much you can do in a given amount of code
17:27:06 <monochrom> can you write the ackermann function in simply typed lambda calculus?
17:27:28 <Eduard_Munteanu> djahandarie: hrm, interesting. So I suppose stuff like Agda or Coq indeed need explicit termination checking.
17:28:03 <bobzhang> monochrom: can you explain it more clearly, I remembered it need high order?
17:28:16 <bobzhang> monochrom: but I forgot more detail
17:28:27 <kmc> Eduard_Munteanu, correct; they check that recursion always uses a strictly smaller parameter, or that co-recursion is always under a codata constructor
17:28:29 <kmc> (coconstructor?)
17:28:31 <Eduard_Munteanu> As in, everything at least as powerful as System F_omega can't rely just on the language semantics to prevent unbounded recursion.
17:28:36 <monochrom> I'm guessing it can't be done.
17:28:38 <mux> I don't think you can write ackermann in stlc, you don't even have recursion there
17:29:17 <monochrom> otoh you can write the ackermann function in System F. that establishes the difference.
17:29:45 <kmc> there's probably a way to implement bounded recursion in stlc
17:29:45 <mux> you cannot type fix in plain System F either as kmc was saying
17:29:58 <mux> you need either a letrec or a fix primitive
17:30:12 <monochrom> no fix needed for ackermann in System F
17:30:39 <kmc> can i see this f-ackermann
17:30:45 <bobzhang> monochrom: I can write ackermann function in system F?
17:30:48 <mux> yes I'd like to see it too
17:31:17 <bobzhang> monochrom: I remembered I can not write ackerman function in System T?
17:32:06 <monochrom> I can't write it yet. But I read the claim in Mitchell's Foundations for Programming Languages yesterday. the claim states the exact class of things writable
17:32:22 <bobzhang> oh, I am totally confused...
17:33:34 <hpaste> Tinned_Tuna pasted “FSMonad issues” at http://hpaste.org/50909
17:33:52 <Tinned_Tuna> Hi, I'm having a couple of issues with FSMonad
17:34:11 <Tinned_Tuna> i.e. I'm not entirely sure what the error even really means, let alone how to fix it.
17:34:24 <Axman6> what is FSMonad?
17:34:31 <Eduard_Munteanu> Flying Spagetti Monad.
17:34:48 <Axman6> also it would help a lot if you added types to those functions. they're pretty meaningless at the moment
17:34:51 <Eduard_Munteanu> @google fsmonad
17:34:54 <lambdabot> http://hackage.haskell.org/packages/archive/FileSystem/1.0.0/doc/html/System-FileSystem.html
17:34:54 <lambdabot> Title: System.FileSystem
17:34:57 <Tinned_Tuna> it's part of the System.FileSystem module
17:36:01 <monochrom> recursive functions that are provably total in 2nd-order peano arithmetic are exactly the numeric functions definable in System F
17:36:36 <Tinned_Tuna> Axman6: They're mostly Some variation of M m => String -> [String] -> m ()
17:36:40 <Tinned_Tuna> Where M is FSMonad
17:37:00 <bobzhang> monochrom: you mean total recursive function in 2nd-order can be defined in System F?
17:37:10 <Tinned_Tuna> files is usually of type [[String]]
17:37:20 <Tinned_Tuna> stagDir & procDir are Strings.
17:38:36 <Tinned_Tuna> If I comment out extractCompletedFiles, it happily compiles, but I'm not entirely sure why. I know Tar.extract :: IO ()
17:38:39 <monochrom> it means if you just need 2nd-order peano arithmetic to prove that f is total, you can write f in System F
17:38:43 <Tinned_Tuna> (well, once it's had it's arguments.)
17:40:19 <Tinned_Tuna> So, I my best guess is that extractCompletedFiles is basically the wrong type, but I've no real idea how to fix it.
17:42:17 <bobzhang> yeap, so System F > System T > STLC
17:43:14 <bobzhang> what are those could be computed in System T but not in STLC?
17:46:15 <elliott> Tinned_Tuna: you need to lift it
17:46:24 <elliott> FSMonad is presumably a monad stack with IO at the bottom?
17:46:33 <elliott> liftIO :: (MonadIO m) => IO a -> m a
17:46:36 <elliott> use that
17:46:52 <elliott> e.g. liftIO $ extractCompletedFiles ...
17:46:59 <elliott> Tinned_Tuna: btw, you probably want mapM not mapM_.
17:48:01 <Tinned_Tuna> elliott: I've been trying to use liftIO, but I seem to be doing it wrong.
17:48:41 <elliott> hpaste?
17:49:34 <Tinned_Tuna> give me a moment, I deleted the import that I was using a short while ago when I went to persue other possible solutions.
17:51:14 <Tinned_Tuna> elliott: do you mean this liftIO : http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-IO-Class.html#t:MonadIO ?
17:51:23 <roastbird> can i make "a -> m b" a Kleisli Arrow? is there any reason why it must be wrapped in a newtype Kleisli?
17:51:26 <monochrom> oh, I read the ackermann claim in Theorems for Free instead.
17:51:38 <elliott> Tinned_Tuna: "import Control.Monad.Trans" will give you it.
17:51:46 <elliott> it's not a hard problem :)
17:52:03 <copumpkin> roastbird: if you want a separate instance (of Arrow or Category) for it, you need it to be wrapped
17:52:04 <bobzhang> monochrom: you mean walder's paper? thanks I will check it out
17:52:06 <Tinned_Tuna> Ah ha! It built :-D
17:52:10 <copumpkin> otherwise it looks just like (->)
17:52:14 * hackagebot git-annex 3.20110902 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110902 (JoeyHess)
17:52:43 <Tinned_Tuna> elliott: For someone who has only every written haskell programs with no usage of Monads, this is like rocket science :-p
17:52:51 <monochrom> it just makes the claim (2nd page) and cites a Reynold's paper
17:53:06 <Tinned_Tuna> well, no blatantly specific usages of monads ;-)
17:53:08 <elliott> Tinned_Tuna: monads are not magic
17:53:55 <shachaf> Monads are a lot like magicians, though.
17:54:12 <Olathe> Monads are like a box of chocolates
17:54:16 <Axman6> eatng burritos
17:54:18 <shachaf> You can stuff nuclear waste in them and get chocolates as a result.
17:54:33 <shachaf> This is called "application".
17:54:38 <Tinned_Tuna> Monads are like things which are often described using tenuous analogies?
17:54:39 <elliott> monads are like horses that don't know what to do with their life.
17:54:44 <elliott> they ask themselves every day, can I bind?
17:54:46 <monochrom> Theorems for Free also repeats the claim about System F and functions provably total in 2nd-order peano arithmetic
17:54:49 <elliott> and the answer is yes. yes they can.
17:54:52 <elliott> but they never truly live up to their potential.
17:54:55 <elliott> Tinned_Tuna: I hope this helps.
17:55:09 <parcs> monad is danom spelled backwards
17:55:19 <shachaf> Monads are like horses that can always -- aw, monochrom is talking about actual things in here.
17:55:27 <shachaf> monochrom++ us--
17:55:31 <Tinned_Tuna> elliott: haha, I've been trying with Monads for a while now, and this is the first time I've had an opportunity to do something using a variety of things with monads :-p
17:55:54 <monochrom> Theorems for Free brings up System F because the paper briefly proves the parametericity theorem for System F
17:56:33 <monochrom> (it's called Girard/Reynold System and Polymorphic Lambda Calculus there)
17:56:55 <elliott> shachaf: always what???
17:57:02 <elliott> I'm on the verge of understanding!
17:57:39 <Tinned_Tuna> monochrom strikes me as the kind of person with only one or two PhDs...
17:58:02 <shachaf> elliott: They can always return!
17:58:06 <shachaf> They never get lost.
17:58:07 <elliott> shachaf: I am at peace.
17:58:10 * shachaf >>= undefined
17:58:36 <bobzhang> monochrom: thank you
17:58:36 <Tinned_Tuna> I've moved my error elsewhere :-p
17:58:36 <monochrom> in reality I have 0 PhDs. is that good or sad? :)
17:59:27 <Tinned_Tuna> monochrom: a multitude of MSc' or MRes' ?
17:59:33 <monochrom> 1 MSc
18:00:32 <kmc> i wonder about the least to most educated #haskell regulars
18:00:48 <kmc> we have some people with no high school diploma
18:01:18 <monochrom> w00t I have the Proofs and Types book in pdf, which is cited as the goto place for System F vs 2nd-order peano arithmetic
18:01:28 <kmc> if you have a PhD does that make institutions less likely to accept you into a PhD program to get another one?
18:01:31 <Tinned_Tuna> So, what even is the type signature of my do-block?
18:01:34 <Tinned_Tuna> I'm trying
18:01:55 <elliott> Tinned_Tuna: hpaste?
18:01:57 <Tinned_Tuna> MonadIO m => String -> String -> [String] -> m ()
18:04:20 <hpaste> Tinned_Tuna pasted “Further Herp-Derpage” at http://hpaste.org/50911
18:05:12 <Tinned_Tuna> What hpaste is doing (ofering random eta-conversions and such)... is there an app I can just run on my box at home that does that?
18:05:30 <kmc> hlint?
18:06:01 <joe6> is there a way to hide a function in a module? export everything, but hide one specific function.
18:06:17 <kmc> write the export list yourself
18:06:43 <joe6> kmc, you mean write every function, but for the one that needs to be hidden?
18:07:04 <hpaste> Tinned_Tuna pasted “The associated build error” at http://hpaste.org/50912
18:07:26 <Tinned_Tuna> Do I need to do something similar here with liftIO
18:07:44 <kmc> yeah joe6
18:08:26 <roastbird> Why are monads like a box of chocolates?
18:08:50 <Axman6> because, depending on the monad, you never know what you're going to get
18:08:52 <Tinned_Tuna> because occasionally you get one with nuts in it
18:08:59 <Tinned_Tuna> and you're allergic to nuts
18:09:02 <Tinned_Tuna> so you swell up
18:09:32 <Tinned_Tuna> and require medical attention
18:11:08 <roastbird> Why why why can't I do this: "instance Monad m => Arrow ( \ a b -> (a -> m b))"
18:11:25 <Axman6> because you can't have type level lambdas?
18:11:48 <Eduard_Munteanu> roastbird: use Kleisli
18:11:51 <Eduard_Munteanu> @src Kleisli
18:11:51 <lambdabot> Source not found. Where did you learn to type?
18:11:56 <Eduard_Munteanu> @hoogle Kleisli
18:11:57 <lambdabot> Control.Arrow newtype Kleisli m a b
18:11:58 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
18:11:58 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
18:12:48 <Eduard_Munteanu> With the TypeSynonyms extension, a type synonym might also do, but I'm unsure if it has icky implications.
18:14:24 <Jafet> s/ms/mInstances/
18:14:34 <kmc> type synonym would not work
18:14:37 <kmc> family or otherwise
18:14:47 <roastbird> doesn't work
18:14:47 <kmc> a partially-applied synonym is not a first-class type-constructor
18:15:01 <Tinned_Tuna> elliott: Any ideas?
18:15:19 <elliott> Tinned_Tuna: oh, you pasted it.
18:15:24 <Tinned_Tuna> elliott: do I need to just edit the type signature?
18:15:29 <kmc> roastbird, if you allow instances like that, then it becomes very hard to tell which instance to use in a given situation
18:15:47 <elliott> Tinned_Tuna: the error is in moveExtractFiles.
18:15:52 <elliott> you need to add , MonadIO m to the typeclass context.
18:16:50 <Tinned_Tuna> moveExtractFiles :: MonadIO m => String -> String -> [String] -> m ()
18:17:59 <Tinned_Tuna> hmm, using (FSMonad m, MonadIO m) => ... seems to stop it complaining about the actual function itself, and it moves on to complaining about my main
18:18:24 <elliott> then your main is wrong.
18:19:54 <roastbird> kmc: hm... ok :(
18:20:08 <Tinned_Tuna> urgh...
18:21:22 <mauke> why is I/O so broken in Haskell?
18:22:13 <kmc> to what do you refer?
18:22:20 <elliott> mauke: it is? I mean, apart from being impure
18:22:35 <Tinned_Tuna> I sense a troll.
18:22:46 <kmc> it's not "impure" at all, other than "lazy IO" hacks
18:22:47 <drdo> obvious troll
18:23:08 <kmc> mauke is a regular and typically doesn't troll us in obvious ways
18:23:15 <kmc> so i'm guessing this is going somewhere specific
18:23:41 <elliott> kmc: well, it's certainly _imperative_.
18:23:49 <kmc> yeah
18:23:50 <elliott> but we don't yet have FRP OSes :P
18:23:57 <mauke> threadWaitRead works on Fd. hGetBufNonBlocking works on Handle. fdRead returns a String. connect works on Socket.
18:23:57 <Tinned_Tuna> I'm tempted to go to bed and come back to this in a couple hours
18:24:08 <Tinned_Tuna> I may bother you guys again :-p
18:24:13 <elliott> mauke: functions in Network don't return Socket
18:24:43 <kmc> well, sockets are fairly different from other files in POSIX
18:24:44 <Tinned_Tuna> See you later guys, thanks for the assistance :-)
18:24:54 <mauke> elliott: listenOn does
18:24:54 <kmc> you can work at a level that exposes that, or a level that attempts to hide it
18:25:05 <kmc> if you're working with Fd's, you're working at the level which does not hide POSIX
18:25:13 <drdo> kmc: The trouble with posix is that they try to force fit everything into the file hole
18:25:25 <drdo> and the result isn't pretty
18:25:27 <mauke> kmc: so how do I work with Fds?
18:25:52 <elliott> mauke: Meh, ok then
18:26:01 <elliott> There's Fd stuff in some Posix module
18:26:07 <elliott> I think
18:26:32 <kmc> drdo, no, the trouble is that they're bad at it
18:27:01 <kmc> a lot of things in POSIX are not fd's and would be nicer if they were
18:28:11 <kmc> for example, PIDs are terrible.  fork() should return an open fd referring to the forked process; you can wait for completion by reading a struct from it, or kill the process with write.  it prevents the PID aliasing problem, and gives you a simple existing capability-like mechanism for controlling who can interact with processes
18:28:52 <mauke> kmc: how do you write kill(1) in that system?
18:28:55 <drdo> kmc: i don't agree with that
18:28:58 <kmc> i'm not sure yet mauke
18:29:27 <Jafet> You have a kill file, of course!
18:29:41 <elliott> kmc: I have a Plan 9 to sell you.
18:29:41 <drdo> I have no trouble with an fd just being a name for some resource
18:29:54 <kmc> you can use PIDs for kill(1)-like things, via some /proc-like filesystem
18:29:55 <elliott> mauke: clearly unlink() has to work on pids
18:30:07 <drdo> but trying to force everything to be like doing IO on a file is not nice
18:30:35 <kmc> drdo, i disagree.  fundamentally most system calls are either sending or receiving a struct from/to the kernel
18:30:46 <adrake> kmc: you really would enjoy plan 9
18:30:51 <kmc> there are too many different ways to do that, when read(2) and write(2) are good enough
18:30:51 <elliott> The problem with fds is that they're byte-oriented.
18:30:54 <kmc> yeah, i've heard plan 9 works this way
18:31:01 <elliott> That's an untyped, morally bankrupt IPC system. :p
18:31:02 <kmc> yes, the lack of types in UNIX is a separate problem
18:31:18 <elliott> I have a my-OS to sell you. I'm rolling in the money today.
18:31:30 <kmc> none of the innumerable other kernel interfaces in, say, Linux come out much better on the "types" front
18:31:31 <drdo> elliott: yes, that's a big problem
18:31:35 * shachaf return
18:31:45 <kmc> shachaf, did you call the current continuation?
18:31:46 <Jafet> Nah, it's a huge advantage. Programmers aren't shoehorned into some type system, so they're free to reinvent their own.
18:32:06 <elliott> Jafet: Um, the bytes need to take a certain form.
18:32:11 <elliott> They're typed, just weakly and loosely and badly.
18:32:14 <elliott> And ad-hocly.
18:32:20 <shachaf> kmc: You got a problem with that?
18:32:23 <Jafet> But it's their own! That's the huge advantage.
18:32:36 * Jafet garbage-collects shachaf
18:32:36 <drdo> Jafet: Let's do with filesystems then?
18:32:40 <drdo> *do away
18:32:40 <elliott> And they force the waste of serialising just so it can be immediately deserialised.
18:32:58 <Jafet> Serialisation isn't the issue here
18:33:19 <elliott> It is, unless you program without types too; but this is rather off-topic.
18:33:21 <Jafet> I'm pretty sure PowerShell serializes records
18:35:57 <kmc> Haskell trivia: what's the fixity of an infix operator when not declared
18:36:02 <mauke> is there any way to read bytes from a Fd other than fdReadBuf?
18:36:03 <kmc> (no peeking)
18:36:11 <parcs> infixl 10
18:36:19 <copumpkin> over 9000
18:36:20 <drdo> kmc: no idea, but infix is evil
18:36:41 <Peaker> drdo: #lisp is <-- that way :-)
18:36:45 <parcs> what do i win?
18:37:06 <Jafet> mauke: BS.hGet!
18:37:07 <kmc> haha
18:37:14 <Peaker> parcs: isn't 10 the precedence of prefix funcs?
18:37:15 <drdo> Peaker: We can all be friends!
18:37:18 <elliott> kmc: infixlr 9.9
18:37:20 <kmc> it's infixl 9 but i do like copumpkin's answer
18:37:26 * ski thought it was `infixl 9', but isn't sure
18:37:39 <mauke> Jafet: wrong
18:37:46 <shachaf> It's actually infixlr(1)
18:37:57 <ski> hehe
18:38:21 <Jafet> I replaced Fd with Handle for your benefit
18:38:51 <mauke> that's nice. unfortunately Haskell is a strongly typed language, so you can't do that
18:38:57 <parcs> Peaker: is it?
18:39:23 <parcs> why do prefix functions have precedence?
18:39:50 <ski> `10' is the precedence of the left-associative syntactic application operator
18:39:59 * copumpkin turns it up to 11
18:40:02 <mauke> is there any way to get a Fd for a network connection?
18:40:05 <copumpkin> with his record selectors
18:40:14 <shachaf> copumpkin: Are those infixl or infixr?
18:40:37 <copumpkin> l probably!
18:40:41 <Peaker> do you think that maybe Haskell's function application syntax could invoke a class method (e.g: Apply) such that it can be used in place of idiom brackets?
18:40:52 <elliott> Peaker: that upsets me slightly
18:40:54 <Peaker> (probably not a good idea, but I'm wondering if it could be made to work)
18:41:11 <ski> Peaker : no, better to have explicit quote and unquote, imo
18:41:16 <elliott> it could, as long as the (->) method was primitive
18:41:20 <elliott> but ...
18:41:23 <kmc> Claskell would be a good esolang
18:41:24 <Peaker> ski: better, yeah, I'm wondering if it is possible
18:41:26 <parcs> like rebindable syntax for function application?
18:41:33 <elliott> we need _some_ concreteness, or all typechecking is pointless :P
18:41:41 <parcs> how would you define it without going into an infinite loop
18:41:49 <ski> Peaker : it needs an extension to the type system -- i've been pondering this a little bit
18:42:18 <Peaker> elliott: ST's phantom type would beg to differ :)
18:42:20 <shachaf> <elliott> we need _some_ concreteness </elliott> -- just get out of this channel.
18:42:47 <shachaf> We don't want your kind in here.
18:42:50 <Peaker> Oh my, shachaf, you've just made the connection between IRC and XML. I think I might just leave now
18:43:06 <elliott> shachaf: I'm sorry, I feel as bad as the people who ruined Haskell 98 in the name of the children :-
18:43:07 <elliott> :-(
18:43:08 * shachaf cackles.
18:43:20 <elliott> ?remember Peaker Oh my, shachaf, you've just made the connection between IRC and XML. I think I might just leave now
18:43:20 <lambdabot> Done.
18:43:51 <Jafet> Peaker: unfortunately, that may introduce way too much polymorphism
18:44:12 <Jafet> Especially when you consider that all functions are unary
18:44:28 <Axman6> polywolymorphism
18:45:55 <ski> .. in Racket Scheme, you can rebind the implicit `#%app' syntax that is present in every procedure application
18:47:06 <elliott> I think the Racket folks would object to "Racket Scheme"
18:47:15 <Jafet> That sounds horrible. It voids the hacker's inclination to write a macro for the same.
18:47:24 <ski> (i.e. in `(foo bar baz)', unless `foo' is a syntax, that really means `(#%app foo bar baz)')
18:47:47 <shachaf> I hope #%app is dynamically scoped.
18:47:48 <ski> elliott : well, i don't think you can do this in e.g. Racket Algol
18:48:22 <ski> i think it is dynamically scoped at the syntax level, yes
18:48:41 <elliott> ski: Racket Racket perhaps?
18:48:55 <ski> well, it seemed a bit tautologous
18:49:01 <shachaf> Type error.
18:49:29 * ski gives a `fix' to shachaf
18:49:40 <mauke> I wish I could hate the Haskell libraries to death
18:49:56 <Jafet> {-# LANGUAGE perl #-}
18:50:33 <shachaf> mauke: You can!
18:50:44 <mauke> how :-(
18:50:45 <shachaf> Which libraries do you want to hate today?
18:50:53 <mauke> none
18:51:12 <shachaf> Usually what you do is write a better library. And then you murder everyone who used the old libraries.
18:51:29 <Jafet> With barbed wire.
18:51:40 <mauke> I don't feel like rewriting base and unix
18:51:46 <mauke> and ghc internals
18:51:55 <shachaf> Oh, well, now you're just being lazy.
18:51:57 <mauke> and bytestring
18:52:12 <shachaf> What do you want to change about ByteString?
18:52:14 <Peaker> mauke: I too hate the stupid partiality, the stupid String type, the lack of polymorphism between BS types, ...
18:52:41 <mauke> shachaf: it shouldn't do I/O on Handles
18:52:54 <mauke> and offer a Fd interface
18:53:00 <shachaf> Fds are overrated.
18:53:04 <shachaf> Handles are the future.
18:53:20 <Peaker> mauke: aren't the Fds relatively hidden?  I'd suppose Handle ~= FILE*,  Fd ~= int fd
18:53:28 <mauke> Peaker: no
18:53:34 <Jafet> Handle is Handle; Fd is CInt.
18:53:42 <shachaf> Peaker: Handle is much more complicated than FILE. :-)
18:53:43 <mauke> and Fd being hidden is exactly the problem
18:53:54 <mauke> I need Fds here
18:53:59 <drdo> Fd should be hidden
18:54:05 <mauke> no buffering, no encoding bullshit
18:54:26 <Jafet> foreign import ccall read
18:54:51 <mauke> Jafet: how is that different from fdReadBuf?
18:54:55 <Peaker> shachaf: how is it more complicated?
18:55:06 <Jafet> mauke isn't doing very well at his two minute hate
18:55:19 <Jafet> mauke: it probably isn't
18:55:25 <mauke> Jafet: correct
18:55:34 <kmc> Jafet++
18:55:58 <kmc> itym foreign import ccall syscall
18:56:02 <shachaf> Hmm, FILE is more complicated than I thought.
18:56:15 <kmc> except it's variadic, so sad
18:56:29 <kmc> and the user-side of the syscall interface on Linux is complicated these days
18:56:38 <mauke> is there any way to get a Fd for a network connection?
18:56:43 <shachaf> Even so, I seem to remember that Handle was pretty weird.
18:56:48 <kmc> though i think int $0x80 will usually work anyway
18:56:53 <Jafet> It's not linux, you buffoon kmc. It's POSIX
18:57:02 <kmc> s/buffoon/insensitive clod/
18:57:05 <kmc> ftfy
18:57:24 <shachaf> In Soviet Russia, that fixes for you!
18:57:56 <mauke> Peaker: a Handle consists of a String and one or two MVars
18:58:20 <mauke> Peaker: each MVar points to a Handle__
18:58:48 <mauke> that's an existential type, a record with 13 fields
18:59:03 <Peaker> mauke: what's the point of all of that?
18:59:15 <mauke> don't ask me
18:59:18 <mauke> I just want Fds
19:01:36 <Peaker> I like the buffering of FILE*'s, though not the annoying fwrite/fread interfaces
19:01:53 <mauke> what's annoying about them?
19:04:23 <dave1231> kmc: it's been a while since I've used int 80 - what's gotten complicated since I've been (far far) away?
19:04:46 <mauke> yay, let's use mfix with signal handlers
19:05:32 <kmc> dave1231, on some x86 chips you have the SYSENTER or SYSCALL instruction, which can make a system call potentially much faster than an interrupt
19:05:57 <kmc> and you could have userspace detect which to use, but this is messy for a variety of reasons
19:05:58 <dave1231> kmc: nice
19:06:19 <dave1231> nice-ish I guess
19:06:27 <kmc> so instead the kernel builds a few pages of userspace machine code ("the VDSO") and maps them for every process
19:06:41 <kmc> and "ordinary" userspace code makes a syscall by calling a function in that region
19:07:56 <shachaf> kmc: There was also a thing where SYSENTER doesn't save where it was called from, wasn't there?
19:08:08 <kmc> iirc the address is passed using some ELF auxiliary vector, and saved by libc into the %gs segment register
19:08:11 <kmc> yeah
19:08:31 <kmc> you effectively can only have one SYSENTER instruction in the entirety of a userspace process
19:08:43 <kmc> and furthermore the kernel needs to know where it is ahead of time
19:08:52 <kmc> so it really makes sense for the kernel to generate this code, even if it's executed in ring 3
19:09:23 <kmc> there's another trick, which is that some calls like gettimeofday() are only reading data, so they can be implemented entirely in userspace
19:09:41 <kmc> presuming the kernel will map for userspace (read-only!) the page containing the relevant timer variables
19:09:56 <dave1231> about 8 years ago I was told to do all kinds of stuff via x86 assembly and int 80 - I'm now wondering if I was being shielded from extra complexity or if the people telling me what to do didn't know about this stuff
19:10:13 <kmc> i think this stuff did not exist 8 years ago
19:10:34 <dave1231> I feel a little better now
19:10:41 <kmc> the direct int 0x80 interface is still supported for 32-bit code, for compatibility reasons
19:10:57 <kmc> and on some processors (very old ones) the vdso code will just invoke int 0x80
19:11:06 <kmc> i don't remember what the situation is on amd64
19:12:27 <Peaker> mauke: the count,size dichotomy
19:12:33 <Peaker> mauke: instead of a single buffer size
19:12:59 <Peaker> mauke: I don't really understand the semantics of that, how does it differ from  count*size ?
19:13:11 <mauke> Peaker: you forgot to check for overflow
19:13:31 <Peaker> why do I need to check that?
19:13:40 <mauke> because you like to write bug-free code
19:13:42 <Peaker> I have a buffer of that size, it's kind of proof that there's no overflow?
19:14:19 <mauke> I'll only believe that when I see it
19:14:30 <mauke> the other difference is partial reads
19:14:59 <mauke> fread will always give you an integral number of size sized chunks
19:15:50 <Peaker> mauke: so it will basically just round down any extra partially read data?
19:16:08 <Peaker> (yet the effect of reading it will have occurred, it doesn't have a time machine and it uses POSIX)
19:16:46 <shachaf> kmc: int 0x80 works in amd64 as far as I know.
19:17:24 <kmc> but is it supported? and does it give you the amd64 or the i386 syscalls?
19:21:15 <shachaf> kmc: Ah, the i386 syscalls, it seems.
19:23:26 <kmc> yeah, when the CVE-2010-3081 exploit came out, a suggested mitigation was to disable support for 32-bit binaries... then some people discovered you could still make the exploitable 32-bit syscalls from 64-bit code
19:25:27 <mauke> fdRead :: Fd -> Int -> IO S.ByteString
19:25:38 <mauke> might work but feels a bit disgusting
19:25:52 <mauke> is there an obviously superior interface for read?
19:27:45 <shachaf> Word instead of Int?
19:27:57 <mauke> CSize actually
19:28:05 <shachaf> Ah. Yes.
19:29:07 <shachaf> Fd -> CSize -> Ptr CChar -> IO CSize? :-)
19:29:51 <mauke> that's fdReadBuf
19:29:58 <shachaf> Ah. Yes.
19:29:59 <mauke> I want something slightly nicer
19:30:41 <mauke> ah, but I like how the System.Posix.IO documentation lies
19:30:52 <mauke> "This is exactly equivalent to the POSIX read function."
19:31:29 <shachaf> Hmm, posix.io isn't registered.
19:31:55 <shachaf> mauke: Why is it not exactly equivalent?
19:32:24 <kmc> shachaf, you should get it!
19:32:26 <mauke> read returns a signed integer, fdReadBuf an unsigned integer
19:32:42 <mauke> reason: fdReadBuf checks for errors and converts them to IO exceptions
19:32:42 <shachaf> Oh.
19:32:52 <kmc> make a website describing the POSIX APIs in the breathless, masturbatory tone of selling a hot new web framework
19:32:53 <mauke> unless it's EINTR, then it retries the read
19:33:02 <kmc> make sure to use the word "awesome" in every sentence
19:33:21 <shachaf> How about Web 2.0 RESTful POSIX APIs?
19:35:16 <shachaf> mauke: Wait, exceptions aren't in POSIX?
19:35:49 <mauke> what
19:36:57 <shachaf> It's pretty expected of a modern C++ API to use exceptions.
19:37:07 <mauke> POSIX is neither modern nor C++
19:37:14 <shachaf> That's neither here nor there.
19:37:18 <shachaf> It should have exceptions.
19:37:40 * shachaf isn't sure how RESTful you can get without that.
19:37:42 <kmc> shachaf, now I'm sure you're trolling
19:38:01 <mauke> heh, read should return HTTP status codes
19:38:18 <shachaf> kmc: Sorry. :-(
19:38:26 * shachaf should save it for -blah.
19:38:54 <mauke> shit, this is totally sweet
19:39:10 <mauke> I can't use fdReadBuf!
19:39:27 <shachaf> Can't you catch the exceptions?
19:39:49 <mauke> I need to detect the case where no data is available
19:40:02 <mauke> i.e. where read gave me EAGAIN or EWOULDBLOCK
19:40:12 <shachaf> Ah.
19:40:27 <mauke> pop quiz, hotshot: what does Foreign.C.Error turn those into?
19:40:50 * shachaf has no idea.
19:41:25 <kmc> usually you want to abstract that away with GHC's IO managerd
19:41:30 <mauke> it's obvious, really: EAGAIN becomes ResourceExhausted, EWOULDBLOCK becomes OtherError
19:41:46 <mauke> $#@%?!
19:42:06 <shachaf> You know, if Haddock generated syntax-highlighted HTML with built-in cross-referencing, I doubt anyone would ever use the HTML version without the source.
19:42:11 <shachaf> mauke: Oh, well, that makes sense.
19:43:10 <mauke> ResourceExhausted could also mean E2BIG, EMFILE, EMLINK, EMSGSIZE, ENFILE, ENOBUFS, ENOLCK, ENOLINK, ENOSPC, ENOSR, ETOOMANYREFS, or EUSERS
19:43:45 <mauke> OtherError could also mean EOK, EADV, EBADRPC, ECONNABORTED, EFAULT, or anything else
19:43:55 <shachaf> It doesn't give you the actual errno?
19:44:14 <elliott> shachaf: Syntax-highilighted HTML?
19:44:17 <shachaf> Well, that's nice.
19:44:17 <elliott> It does with HsColour.
19:44:28 <shachaf> elliott: As in http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.5.0.0/src/System-Posix-IO.html#fdReadBuf
19:44:48 <elliott> shachaf: Install HsColour.
19:45:03 <shachaf> elliott: How will that insert links into the HTML on haskell.org?
19:45:12 <elliott> Oh. Well, it won't.
19:45:15 <elliott> But it's syntax highlighted.
19:45:54 <shachaf> It's already syntax-highlighted.
19:46:08 <shachaf> "syntax-highlighted" was a handle to specify what I'm referring to.
19:46:16 <elliott> Ah.
19:47:42 <mauke> shachaf: it sort of does give you the actual errno
19:48:23 <mauke> you need to catch the IOError, import GHC.IO.Exception, use the nonstandard ioe_errno accessor, then wrap the resulting CInt back into an Errno
19:49:02 <mauke> fuck this shit, I'mma FFI everything
19:49:11 <elliott> what are you even writing?
19:49:33 <mauke> bits and pieces
19:49:39 <mauke> may turn into an IRC client at some point
19:50:13 <shachaf> All this for an IRC client?
19:50:17 <mauke> yes
19:50:18 <elliott> mauke: You can write an IRC client without meddling with Fds, dude.
19:50:22 <mauke> elliott: how?
19:50:45 <shachaf> mauke: How many Fds do you ever have open?
19:50:46 <elliott> mauke: Is there something wrong with Network.connectTo?
19:50:53 <mauke> elliott: yes
19:50:56 <elliott> What? Are you doing DCC or something?
19:51:05 <mauke> elliott: not yet
19:51:30 <elliott> What's wrong with Network.connectTo then?
19:51:51 <mauke> elliott: doesn't give me a Fd
19:51:56 <elliott> (And for DCC, the Network functions that use Sockets and result in Handles at the end?)
19:51:57 <mauke> shachaf: minimum 5
19:52:00 <elliott> mauke: Oh come on.
19:52:03 <elliott> mauke: Why do you need Fds?
19:52:04 <mauke> shachaf: probably more in some cases
19:52:07 <elliott> What's wrong with the Handle interface?
19:52:53 <elliott> <elliott> What's wrong with the Handle interface?
19:53:17 <mauke_> elliott: can you guarantee that operations on Handles won't buffer anything?
19:53:39 <Eduard_Munteanu> Why do you care?
19:53:49 <elliott> mauke_: hSetBuffering? But I don't see why that stops you writing an IRC client.
19:53:58 <elliott> I understand plenty of people have written network code in Haskell.
19:54:05 <mauke_> because I want to be able to restart the program on the fly, like xmonad or irssi
19:54:06 <Eduard_Munteanu> @hoogle flush
19:54:07 <lambdabot> System.IO hFlush :: Handle -> IO ()
19:54:13 <elliott> hFlush, then?
19:54:23 <mauke_> hFlush is an output operation
19:54:27 <elliott> xmonad is a network program too, technically.
19:54:49 <mauke_> again, does this guarantee that nothing will buffer even a single byte anywhere?
19:55:23 <elliott> Well, your needs are strange, so of course it's not going to be trivial.
19:55:29 <elliott> Why not just write a simple C wrapper to maintain the connections?
19:55:56 <mauke> I don't think having precise control over who reads what when is strange
19:56:07 <mauke> and this is trivial in C or Perl or nearly anything else
19:56:30 <mauke> want to read N bytes? call read. want to not read N bytes? don't call read.
19:56:41 <duairc> mauke: You can recover an Errno from an IOError
19:56:49 <mauke> duairc: how?
19:56:55 <mauke> elliott: how do you mean?
19:57:12 <elliott> mauke: How do you mean, how do you mean?
19:57:30 <mauke> elliott: what do you mean by "C wrapper to maintain the connections"?
19:57:51 <duairc> mauke: Oops, I see you've discovered how (the nonstandard ioe_errno thing). I'm on a ridiculously slow connection at the moment.
19:58:16 <elliott> mauke: write simple C program to handle connections/reads/writes/etc. on a bunch of fds, communicate with it from haskell
19:58:29 <elliott> Before Haskell quits, send "stop <timestamp>"
19:58:37 <elliott> Wrapper then buffers anything sent after that
19:58:43 <elliott> Haskell program reconnects, server sends what it missed
19:58:45 <elliott> No?
19:59:18 <mauke> how does that solve anything?
19:59:29 <mauke> I'd communicate with it over Fds
20:00:25 <dmwit> Huh, does hSetBuffering NoBuffering not actually stop a handle from buffering?
20:00:32 <dmwit> Or if it does, what's the complaint?
20:00:36 <mauke> dmwit: I don't know
20:00:52 <mauke> the documentation kinda likes to contradict itself
20:01:02 <elliott> It sounds like you're coding around a problem you don't actually know exists yet
20:01:03 <mauke> and isn't trustworthy anyway, as seen in fdReadBuf
20:01:11 <elliott> That seems counterproductive
20:01:56 <mauke> no, Fds are actually simpler than Handles
20:02:09 <dmwit> Wow, cool, where does it contradict itself?
20:02:10 <mauke> I'm not coding around things
20:02:20 <elliott> mauke: Simpler? Sounds like you're getting quite frustrated
20:02:22 <elliott> So not simpler
20:03:30 <mauke> dmwit: "The System.IO.hLookAhead operation implies that even a no-buffered handle may require a one-character buffer."
20:03:51 <dmwit> cute
20:04:47 <dmwit> Also, I can understand how that would be frustrating.
20:06:16 <dmwit> mauke: From the source of hLookAhead_, it looks like it only creates a buffer when you actually call hLookAhead.
20:06:25 <dmwit> i.e. it's unbuffered so long as you avoid calling that.
20:06:33 <Cale> Isn't it just the semantics which matter? If there's a buffer that you can't actually tell is there, is it really a buffer?
20:06:46 <mauke> Cale: yes
20:07:05 <mauke> hello and welcome to the world of multitasking OSes, where multiple programs may run at the same time
20:07:11 <mauke> also: networks!
20:07:18 <mauke> that other program may not even be on the same machine
20:07:56 <elliott> Yeah, I think it's unfair to say that hLookAhead is contradictory
20:08:02 <Cale> Maybe I don't understand the context very well.
20:08:04 <elliott> You use it explicitly when you want to read a character and then save it for later
20:08:30 <elliott> So unless mauke hLookAheads and then doesn't actually read it, which seems unlikely, it's fine to use Handles
20:08:33 <Cale> I've never found a reason to not just use GHC's higher level IO stuff, and ignore how it implemented things with nonblocking operations.
20:08:34 <dmwit> Cale: He doesn't want to drop data on the floor by reading it into a buffer right before his app restarts.
20:08:46 <Cale> hmm
20:08:55 <dmwit> (Presumably reading it into non-buffer memory and then restarting is a reasonable way to drop data, though.)
20:09:17 <elliott> dmwit: Presumably he handles the data when it comes in before restarting
20:09:32 <dmwit> Right.
20:09:42 <dmwit> I think we're saying the same thing.
20:09:43 <elliott> mauke: TBH, it sounds like what you want is just an IRC bouncer running locally :P
20:09:53 <elliott> dmwit: I thought "reasonable way to drop data" was sarcastic.
20:10:52 <Cale> After you restart the program, aren't you going to have to reopen all the connections again anyway?
20:11:04 <mauke> Cale: no
20:11:11 <mauke> but that's a good point
20:11:13 <Cale> Why not just do it that way?
20:11:19 <mauke> I can't preserve Handles across a restart
20:11:28 <mauke> Cale: what?
20:11:41 <Cale> Close all the connections, restart the program, reopen them again.
20:11:53 <shachaf> Cale: As far as I understand, mauke wants an IRC client that can be reconfigured xmonad-style.
20:12:04 <mauke> well, irssi-style is more appropriate here
20:12:07 <mauke> it came first
20:12:14 <kmc> you can preserve open file descriptors across a restart, with the help of another program which does not restart
20:12:32 <mauke> kmc: I can preserve open file descriptors by doing nothing
20:12:36 <mauke> they preserve themselves
20:12:41 <kmc> ?
20:12:46 <dmwit> (...or even without a helper program, by just not shutting down until you've handed off the fd's)
20:12:48 <kmc> oh, because the ap execs itself
20:12:49 <kmc> app*
20:13:04 <kmc> yeah i see
20:13:05 <kmc> cool
20:13:44 <kmc> i've still not decided whether the fact that fd's are inherited across execve is a good or bad design
20:13:45 <shachaf> mauke: irssi execs itself?
20:13:53 <mauke> shachaf: yes, when you /upgrade
20:13:58 <Cale> So ditch portability and just use low-level posix stuff to handle this when there's a pretty reasonable way to do things which doesn't require it?
20:14:18 <shachaf> Cale: What's the pretty reasonable way?
20:14:24 <Cale> What I said before
20:14:25 <mauke> I can't parse the second half of that sentence
20:14:38 <elliott> mauke: Really though, what you're writing sounds like an IRC bouncer plus an IRC client, awkwardly moulded into the same executable.
20:14:47 <shachaf> Cale: You mean closing the connections?
20:14:50 <elliott> And less flexible because of it.
20:14:56 <Cale> Yeah, why not? It's IRC anyway.
20:15:17 <Cale> That or take kmc's suggestion.
20:15:27 <mauke> yes, I'm sure everyone enjoys watching preflex quitting and reconnecting 10 times in a row, in all channels
20:15:28 <elliott> What is kmc's suggestion?
20:15:38 <shachaf> elliott: The same as yours.
20:15:49 <elliott> mauke: Bouncer.
20:15:55 <Cale> Have a separate program stay open and handle the connections, and communicate with that program.
20:16:02 <mauke> elliott: loses state
20:16:03 <kmc> oh, my suggestion was to hand off the fd's directly through a UNIX socket
20:16:08 <kmc> but that's probably silly
20:16:10 <elliott> mauke: Does that matter?
20:16:10 <elliott> <mauke> yes, I'm sure everyone enjoys watching preflex quitting and reconnecting 10 times in a row, in all channels
20:16:14 <elliott> Obviously that works modulo annoyance.
20:16:16 <shachaf> kmc: Oh, I misunderstood.
20:16:16 <kmc> i just like the fact that fd's can be passed through a unix socket
20:16:30 <elliott> So if you eliminate the annoyance with a bouncer, taa.
20:16:31 <elliott> tada.
20:16:47 <mauke> no
20:16:53 <shachaf> @remember kmc <kmc> oh, my suggestion was to hand off the fd's directly through a UNIX socket <kmc> but that's probably silly <kmc> i just like the fact that fd's can be passed through a unix socket
20:16:54 <lambdabot> It is forever etched in my memory.
20:17:01 <elliott> mauke: No? Then what's your real objection to dropping connections, if not annoyance?
20:17:07 <kmc> shachaf, tl;dr
20:17:19 <elliott> shachaf: Remove all the vowels for length.
20:17:43 <shachaf> But then you end up with awkward three-letter words like "kmc".
20:17:51 <elliott> :D
20:18:06 * elliott resists temptation to ?remember that too.
20:18:15 <shachaf> I wonder what the longest quote in lambdabot's database is.
20:18:17 <elliott> How many quotes does lambdabot even have?
20:18:19 <shachaf> Easy enough to find out.
20:18:26 <elliott> How?
20:18:55 <shachaf> @quote syntaxfree Many.people
20:18:56 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
20:18:58 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
20:19:00 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
20:19:04 <shachaf> That's the one.
20:19:06 <Cale> I guess you can ask me to gunzip the quote file and put it online?
20:19:10 <shachaf> Apparently it's so long it got cut off.
20:19:19 <mauke> elliott: it feels morally wrong
20:19:24 <shachaf> Cale: Nah, I just did a binary search with @quote .{300,}, etc.
20:19:30 <elliott> mauke: Anyway, if you use acid-state you won't lose state.
20:19:31 <elliott> So ha.
20:19:38 <mauke> elliott: one issue is that the running instance may have other local state
20:19:40 <Cale> shachaf: ah :)
20:19:43 <mauke> elliott: er, what?
20:19:52 <elliott> Well, assuming you resume into the correct codepath.
20:20:02 <ski> hm, a pattern which is either `_' or `<variable>' or `<variable> @ <pattern>' where `<pattern>' has the same property recursively - is this irrefutable patterns ?
20:20:06 <elliott> Presumably you can't restart mid-message-handler.
20:20:25 <Cale> ski: or a pattern starting with ~
20:20:35 <shachaf> Cale: You should gunzip the quotes file and put it online, though!
20:20:41 <shachaf> Imagine what would happen if Linode crashed.
20:20:55 <shachaf> At least commit lambdabot to darcs once in a while, or something.
20:21:06 <Cale> We would lose literally months of precious lambdabot state!
20:21:19 <elliott> lambdabot doesn't persist its state?
20:21:24 <ski> Cale : yeah, i'm looking for a name for the case with only those three variants (there's no `~', because SML is strict)
20:21:27 <Cale> elliott: It does, to a file
20:21:52 <mauke> but not if you enable the @seen plugin!
20:22:04 <Cale> ski: Irrefutable seems fine
20:22:11 <ski> i was thinking maybe tuple patterns would be irrefutable then .. but i don't want those included
20:22:31 <Cale> Tuple patterns aren't considered irrefutable in Haskell
20:22:38 <Cale> But they were considered unfailable
20:22:41 <ski> yes, but this is actually SML, so strict
20:22:44 <Cale> Back when that was a thing
20:22:51 <ski> (or really, MetaML, but it's mostly SML)
20:23:28 <Cale> ski: you could just call it a simple pattern or something
20:23:44 <ski> iirc GHC doesn't allow matching an input of type `forall a. (f a,g a)' on a pattern `(p,q)' -- in any case MetaML doesn't either
20:24:56 <ski> Cale : i'll think some more. ty for the input
20:25:11 <Cale> ski: What is this for?
20:25:51 <ski> (i'm not really sure *why* GHC doesn't allow that kind of matching, except possibly conservatism -- though maybe the semantic consequences aren't well-understood)
20:26:11 <copumpkin> > let f :: (forall a. (f a, g a)) -> (f Int, g Int); f (x, y) = (x, y) in f ([], [])
20:26:11 <lambdabot>   Couldn't match expected type `forall a. (f a, g a)'
20:26:12 <lambdabot>         against inferre...
20:26:32 <ski> Cale : i'm hacking the MetaML implementation, trying to improve some irritating deficiences, to start with
20:27:15 <mauke> revised type: fdRead :: Fd -> CSize -> IO (Maybe S.ByteString)
20:27:43 <shachaf> mauke: Not Either Errno S.ByteString?
20:28:06 <mauke> no, I'm actually fine with exceptions
20:28:53 <mauke> hmm. but I'll do it your way anyway
20:29:01 <mauke> it just feels good
20:29:14 <parcs> :t Data.Traversable.sequence
20:29:15 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
20:29:38 <elliott> sequenceÄ?
20:29:41 <elliott> Nice.
20:29:41 * shachaf sometimes secretly wishes data Maybe a = Nothing String | Just a
20:29:57 <elliott> shachaf: data Maybe a = Nothing (forall a. a) | Just a
20:30:13 <elliott> shachaf: Isomorphic to our current Maybe type, except you can smuggle an error in by using the fact that Haskell has many, many _|_s.
20:30:17 <elliott> BEAUTIFUL.
20:30:38 <parcs> elliott: i don't even know where that character came from
20:30:47 <mauke> shachaf: what would you return for n == 0?
20:31:03 <elliott> mauke: Whatever the syscall does
20:31:07 <elliott> (I'm shachaf)
20:31:28 <shachaf> mauke: Hmm. Empty ByteString? :-)
20:31:35 <elliott> shachaf: Incidentally, how is your name actually pronounced?
20:31:46 <shachaf> elliott: Exactly the way it's spelled.
20:31:50 <mauke> shachaf: I'm leaning towards Left eAGAIN
20:31:52 <elliott> I'm pronouncing it kind of like "shut you off" said really quickly but with a lot more shhing in it.
20:31:57 <keepguessing> hi ai am newbee and I am with a background of OO. I have tried understanding the functional programming but could not. someone suggested gogin and learning haskel. Any suggestions on what should be the best way to learn Haskel for a OO guy
20:32:16 <elliott> keepguessing: Forget everything you know then go read http://learnyouahaskell.com/.
20:32:23 <shachaf> mauke: No, Left eAGAIN? read() returning zero means the opposite of eAGAIN, no?
20:32:28 <elliott> Yes, literally everything.
20:32:41 <elliott> shachaf: eNOTAGAIN?
20:32:47 <shachaf> elliott: שחף.
20:32:50 <elliott> "Please, make the readings stop."
20:32:54 <Jafet> I would begin with strunk & white.
20:32:57 <parcs> don't forget how to read though
20:32:59 <shachaf> The "ch" is a voiceless uvular fricative.
20:33:02 <mauke> shachaf: huh?
20:33:23 <shachaf> Wait, did I misunderstand your question?
20:33:42 <hpaste> wdr pasted “drwd” at http://hpaste.org/50914
20:33:59 <keepguessing> elliott: Thank you
20:34:08 <mauke> shachaf: fdRead fd n | n == 0 = ?
20:34:23 <shachaf> Oh.
20:34:58 <shachaf> Well, making up errnos isn't that nice.
20:35:30 <elliott> shachaf: Can't you just omit the check?
20:35:32 <mauke> do I have a choice?
20:35:33 <elliott> The syscall will handle it.
20:35:35 <Jafet> mauke should write an operating system for haskell
20:35:44 <shachaf> mauke: Why not just do what the system call does?
20:35:58 <mauke> I don't know what the syscall does but it can't be right
20:36:05 <shachaf> I think it just returns 0.
20:36:13 <mauke> which means end-of-file
20:36:15 <mauke> which is wrong
20:36:31 <elliott> "Haskell's IO is too high level!" "These syscalls are too ugly!"
20:36:44 <shachaf> Isn't it the caller's responsibility to check that the argument isn't 0, then?
20:36:52 <mauke> I suppose so
20:37:01 <shachaf> elliott: mauke is in the process of solving both of these problems with his API. :-)
20:37:11 <mauke> but I'm already providing an improved interface with out-of-band errors, etc
20:37:34 <elliott> mauke: data PosFinNat = PosNat Int
20:37:42 <elliott> Implement appropriate constructors; 0 eliminated
20:38:38 <shachaf> mauke: If someone's not checking that the argument they're giving the system call isn't 0, I'm not sure if EAGAIN is that much help to them.
20:39:12 <elliott> mauke: But really, empty bytestring sounds right
20:39:30 <elliott> Since by returning 0 read is trying to say "0 bytes successfully read"
20:39:30 <elliott> Not EOF
20:39:34 <mauke> shachaf: why?
20:39:38 <elliott> And it's exactly what you asked for, so
20:39:42 <mauke> elliott: yes, and that's evil
20:39:59 <elliott> mauke: What's evil about an empty bytestring
20:40:14 <elliott> That perfectly models reading 0 bytes, and if you don't check what length you're passing but just handle the result generically, everything will work out fine
20:40:16 <mauke> elliott: the evil part is doubly overloading read's return value
20:40:31 <elliott> mauke: Yes, which you avoid in your API
20:40:31 <mauke> elliott: if you just handle the result generically, everything will break
20:40:35 <shachaf> mauke: Doesn't eAGAIN imply "you'll be notified when there's more data on this socket" or something of the sort?
20:40:36 <elliott> Um
20:40:40 <elliott> I'm advocating for returning an empty bytestring
20:40:41 <mauke> shachaf: no
20:40:42 <elliott> Not returning EOF
20:40:48 <mauke> elliott: empty bytestring means EOF
20:40:55 <elliott> Make that a separate errno, then
20:40:59 <elliott> EOF isn't a success situation
20:41:01 <mauke> I can't make errnos
20:41:12 <shachaf> Either (Maybe Errno) S.ByteString? :-)
20:41:16 <elliott> Either SocketError S.ByteString
20:41:20 <elliott> SocketError = EOF | Errno Errno
20:41:29 <mauke> no, I don't think EOF is an error
20:41:29 <kmc> indicate errors with a ByteString whose ForeignPtr is NULL
20:41:37 <shachaf> kmc++
20:41:40 <elliott> mauke: Reading from an EOF socket is a success?
20:41:42 <elliott> Okayyyy
20:41:51 <mauke> elliott: what's an EOF socket?
20:41:55 <elliott> A socket at EOF
20:41:59 <mauke> also, who's talking about sockets?
20:42:04 <elliott> s/socket/fd/
20:42:07 <copumpkin> elliott: I don't consider EOF to be an error either
20:42:08 <kmc> better yet, whose ForeignPtr is -errno
20:42:11 <mauke> I haven't reimplemented Network.Socket yet
20:42:15 <shachaf> @slap kmc
20:42:15 * lambdabot hits kmc with an assortment of kitchen utensils
20:42:26 <shachaf> Even you can go too far.
20:42:43 <kmc> surely you wouldn't accuse the Linux kernel of using ugly internal APIs
20:42:48 <elliott> Just segfault, don't return anything
20:42:51 <elliott> THat'll teach everyone to pass in 0
20:42:58 <elliott> Try to remove the programmer's code beforehand
20:43:14 <elliott> Also send out an automated request to an assassin service (stalk the programmer's name down first)
20:43:15 * kmc handles SIGSEGV, calls a stashed-away continuation
20:43:20 <mauke> fdRead fd n | n == 0 = unsafeCoerce n
20:43:24 <elliott> kmc: You can escape segfaults...
20:43:27 <elliott> BUT CAN YOU ESCAPE DEATH???
20:43:35 <elliott> The Read of 0. In cinemas December.
20:43:45 <Jafet> @faq Can you escape death?
20:43:46 <lambdabot> The answer is: Yes! Haskell can do that.
20:43:50 <shachaf> mauke: Not even return . Right? Brutal.
20:43:55 <kmc> glad that's settled
20:44:32 <shachaf> elliott: How is *your* name pronounced?
20:44:44 <elliott> shachaf: Exactly the way it's spelled.
20:44:48 <elliott> shachaf: Elliott.
20:44:58 <incluye> so if you're spanish there's some trippy shit going on
20:45:00 <shachaf> elliott: Double letters are held for longer?
20:45:07 <elliott> shachaf: Yes. Five minutes on a good day.
20:45:20 <shachaf> I was actually referring to "Hird".
20:45:31 <elliott> Like a herd of cats. The most common type of herd.
20:45:39 <elliott> Also, the Free(tm) OS everybody uses.
20:45:56 <shachaf> <kmc> lrn2composekey
20:46:45 <Eduard_Munteanu> Which is also just as fast as Linux.
20:47:12 <elliott> My surname is actually Lunix.
20:48:19 <Jafet> ↄ⃝™
20:50:57 <mauke> http://hpaste.org/50916
20:51:24 <Eduard_Munteanu> Jafet: what did you just do?
20:52:33 <elliott> mauke: Disappointed in your partial actions
20:52:49 <shachaf> mauke: read(2) says that it returns ssize_t.
20:52:58 <shachaf> Oh, but I guess that's undefined anyway.
20:53:27 <Jafet> Well, I don't think you'll find COMBINING ENCLOSING CIRCLE in any compose key lists.
20:53:55 <shachaf> a⃝
20:53:57 <shachaf> Neat.
20:54:04 <elliott> ssize_t is an abomination. :-(
20:54:12 <Eduard_Munteanu> I wonder if irssi should sanitize this.
20:55:31 <shachaf> mauke: Are you sure S.empty is a reasonable API for EOF?
20:55:47 <elliott> shachaf: I tried to convince him but noooooooo.
20:56:14 <mauke> shachaf: what else would S.empty mean?
20:56:35 <shachaf> mauke: That you successfully read 0 bytes! :-)
20:57:00 <mauke> can't happen
20:57:05 <ion> ɔ⃝
20:57:14 <elliott> Sure it can.
20:57:18 <elliott> You pass 0, 0 bytes are read.
20:57:20 <elliott> Everyone is happy.
20:57:28 <shachaf> elliott: Nope, mauke changed that.
20:58:01 <elliott> shachaf: We all have bad ideas sometimes.
20:58:06 <ion> Curiously, in this font ɔ U+0254 LATIN SMALL LETTER OPEN O looks more like a reversed c than ↄ U+2184 LATIN SMALL LETTER REVERSED C.
20:58:16 <shachaf> כ
20:58:25 <shachaf> כ⃝
20:58:32 <shachaf> Hrm.
20:58:36 <ion> Hebrew letter *cough*
20:58:54 <shachaf> ion: Hah.
20:59:29 * shachaf tries to figure out whether that was a clever joke or an accident.
20:59:52 <ion> (Not an accident.)
21:00:25 <shachaf> A⃟h⃟a⃟.
21:01:10 <Cale> （╯°□°）╯︵ ↄ
21:01:59 <ion> ＃ｈａｓｋｅｌｌ－ｂｌａｈ？
21:02:09 <shachaf> ヽ（ ﾟヮﾟ）ﾉ.・ﾟ*｡・+☆C
21:03:00 <Cale> （╯°□°）╯︵ɥɐlq-llǝʞsɐɥ#
21:04:31 <ion> ן looks slightly better than l but it’s still not the real thing.
21:05:50 <shachaf> יון
21:22:33 * ski . o O ( LUnix <http://lng.sourceforge.net/> )
21:24:28 <elliott> ski: that thing's great, have you seen how they handle errors for performance on the commodore
21:24:45 <elliott> you put a nop after and it uses self-modifying code to turn it into a jump or something, I forget exactly
21:25:59 * ski recently wrote some code which modified code which modified code which modified code, for C64
21:27:02 <ski> i haven't looked in detail how LUnix does things, though
21:27:59 <ski> (i've been playing somewhat more with <http://craig.cubewerx.com/cbm/ace/>)
21:39:16 <kniu> so how do I enable syntax highlighting in eclipsefp"
21:39:18 <kniu> ?
21:40:03 <roastbird> does eclipsefp work?
21:40:13 <roastbird> i tried it in windows and it hangs on me
21:42:24 <joe6> can I add haskell code to .hsc file?
21:42:33 <joe6> is there any way to do that?
21:42:50 <kmc> yes, a .hsc file is mostly haskell code
21:42:51 <mauke> can I add html code to .php file?
21:43:44 <joe6> kmc, I added some haskell code to a .hsc file and it was not getting processed.
21:44:00 <kmc> oh?
21:44:07 <joe6> this is a .hsc file with bindings-dsl macros
21:57:16 * hackagebot gps 0.8.1 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.8.1 (ThomasDuBuisson)
22:17:08 <Principe_Dei_Sog> ǡ  ǡ
