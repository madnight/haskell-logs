00:01:50 <getlikeme> does it matter where the import XMonad.* stuff go in the xmonad.hs file? i'm assuming they should all go to the top of the file
00:01:55 <getlikeme> or for haskell files in general
00:02:48 <ddarius> Top.
00:03:01 <ddarius> Kind of an arbitrary restriction though.
00:06:43 * shachaf wonders if there's a reason for that restriction.
00:06:56 <shachaf> I guess ddarius just answered that.
00:07:43 <shachaf> let import ... in ... would be neat.
00:08:24 <Jafet> But instances should still be imported to the rest of the file, to annoy people
00:08:45 <shachaf> Of course.
00:09:04 <shachaf> More than one module in a file would also be neat, but that's a slippery slope.
00:09:31 <kosmikus> so basically all that Agda allows should be allowed in Haskell, too :)
00:09:33 <dmwit> Well, the report itself doesn't say anything about the mapping between modules and files, I guess.
00:09:49 <dmwit> You could write a compliant compiler that grabbed its source from a database instead of a filesystem. =)
00:09:53 <shachaf> Right.
00:10:14 <shachaf> It's kind of silly that "module" has a "where" keyword. :-)
00:10:51 <elliott> module A (b, c, d) seems uneven somehow,
00:11:41 <shachaf> It's different from "where" used anywhere else in Haskell.
00:11:49 * shachaf isn't a big fan of overloaded keywords.
00:11:51 <elliott> module A (b,c,d) whence
00:11:58 <frerich> Does anybody have suggestions how to express the tiny 'Int -> [a] -> Bool' function at http://hpaste.org/51089 more elegantly? I use it instead of "flip $ (>) . length" so that I don't force evaluation of long lists.
00:12:02 <shachaf> I guess the rationale is "people won't use this as an identifier anywhere".
00:12:14 <Jafet> whereby
00:12:24 <shachaf> frerich: null . drop n
00:12:34 <shachaf> frerich: Or genericLength with lazy naturals.
00:12:50 <frerich> shachaf: Oh, drop is a safe function, I didn't realize that!
00:14:02 <jaspervdj> Is Siniša Biđin on here by any chance?
00:14:03 <frerich> shachaf: Hm except that "not . null . drop 10 $ [1..10]" yields False instead of True
00:14:25 <shachaf> Drop the not, then.
00:14:29 <shachaf> Oh, use 9 instead of 10.
00:14:37 <shachaf> Or something like that.
00:14:45 * shachaf was leaving the exact implementation as an exercise.
00:14:49 <frerich> shachaf: Heh m point is - the function should yield True if the given list is at least n elements long
00:15:07 <koeien> null . drop n . (undefined:)
00:15:08 <frerich> So I guess I should drop n-1
00:15:23 <koeien> frerich: that fails if n = 0.
00:15:36 <frerich> True
00:16:14 <ddarius> shachaf: A slippery slope to what?
00:16:39 <shachaf> I'm not quite sure.
00:16:44 <ddarius> 'where' opens a block of layout.  It's basically a {.
00:16:52 <frerich> koeien: Prepending an undefined value is a nice trick :)
00:17:39 <ddarius> It's pretty much the same in GADTs and classes.  Less so for functional declarations
00:18:23 <shachaf> I thought module's where was treated as a special case.
00:18:34 <ddarius> No.
00:18:50 <shachaf> Hmm.
00:19:08 * shachaf will gripe about the use of "then" in comprehensive comprehensions, in that case.
00:19:11 <shachaf> Actually I won't.
00:19:46 * ddarius just gripes about comprehensive comprehensions in general.
00:22:30 * hackagebot deepseq-th 0.1.0.0 - Template Haskell based deriver for optimised NFData instances  http://hackage.haskell.org/package/deepseq-th-0.1.0.0 (HerbertValerioRiedel)
00:28:43 <ddarius> Luckily, as far as I know, no one uses comprehensive comprehensions at all.
00:29:02 <Cale> The ones with sorting?
00:29:38 <ddarius> and grouping and god knows what else
00:29:40 * shachaf 's coworker has used them.
00:30:17 <Jafet> Coworkers aren't people
00:30:28 <shachaf> The syntax is horrid. You can say "then f by g", except if f happens to be "group".
00:32:00 <_Ray_> Coworkers are just workers with the arrows inverted.
00:32:56 <shachaf> Does there exist a sort of intuitionist that doesn't believe in the axiom cocox => x?
00:33:42 <_Ray_> I think that those were paraconsistent logics or something, but that was sometimes denying that ¬(¬x) = x.
00:33:45 <ddarius> The op construction is as constructive as the thing you are oppositing(?)
00:35:17 <DrTeggy> ddarius, hmm
00:35:19 <shachaf> But is it as nstructive?
00:35:39 <DrTeggy> ddarius, we use comprehensive comprehensions is DSH to express database queries in Haskell.
00:36:19 <DrTeggy> http://hackage.haskell.org/package/DSH
00:36:51 <Eduard_Munteanu> How do they interact with generalized monad comprehensions? That'd be fun.
00:37:17 <shachaf> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/Control-Monad-Group.html
00:38:04 * ddarius should read that paper on Kleisli he downloaded many, many, many years ago.
00:38:26 <DrTeggy> Eduard_Munteanu, details on that interaction here: http://www-db.informatik.uni-tuebingen.de/files/giorgidze/haskell2011.pdf
00:38:42 <elliott> _Ray_: ~(~x) -/-> x is just standard intuitionism.
00:38:50 <_Ray_> Ah.
00:39:22 <shachaf> elliott: Not "-/->". :-)
00:39:31 <shachaf> (Well, it depends on what you mean by -/->, I guess.)
00:39:52 <shachaf> And where your quantifiers are. Never mind, actually.
00:40:22 <elliott> shachaf: It's the DWIM operator.
00:40:25 <Eduard_Munteanu> DrTeggy: interesting
00:40:33 <ddarius> shachaf: More like what your quantifiers are.
00:40:42 <elliott> forall p, ~(~~p -> p) sure would be interesting though.
00:41:01 <Eduard_Munteanu> ddarius: oh, link?
00:41:23 <Eduard_Munteanu> (to the Kleisli paper, I mean)
00:41:26 <shachaf> If "inconsistent" counts as "interesting".
00:41:56 <elliott> shachaf: I'm sure there's a paraconsistent logic that permits it.
00:42:28 <ddarius> Eduard_Munteanu: It may be this one.  I don't really know.  I downloaded the paper in like 2002. http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.4942
00:42:30 * Eduard_Munteanu should start adding this stuff to the wiki so lambdabot doesn't lose CT links again
00:42:38 <elliott> "While in dual-intuitionistic logic, A |- ~~A is not derivable."
00:42:56 <elliott> It might even apply directly to dual-intuitionistic logic. But anyway.
00:43:03 <Eduard_Munteanu> ddarius: thanks... oh, ok, not what I thought
00:43:03 <shachaf> That's a thing?
00:43:23 <elliott> shachaf: Well, insofar as something maybe a hundred people worldwide take seriously can be a thing, sure.
00:43:38 <shachaf> elliott: So it's like Haskell?
00:43:48 <elliott> I mean, there are people with PhDs who actually think that the liar paradox can only be resolved properly by paraconsistent logics.
00:44:04 <elliott> (Vaguely relevant PhDs, even.)
00:44:08 <shachaf> I meant dual-intuitionistic logic.
00:44:16 <elliott> shachaf: Precisely! (re Haskell)
00:44:34 <ddarius> PhDs certify little.
00:44:38 <elliott> Well, Wikipedia presents dual-intuitionistic logic as the poster boy of paraconsistent logics. Take that with an adequately-sized grain of salt.
00:44:45 <ddarius> Seems like there's more than 100 people just here alone.
00:44:48 <elliott> I have an atom smasher if you can't find a grain small enough.
00:44:53 <Eduard_Munteanu> Hah.
00:45:06 <ddarius> @google "atom forge"
00:45:22 <lambdabot> Plugin `search' failed with: thread killed
00:45:25 <ddarius> @google "atom forge"
00:45:27 <lambdabot> http://www.halocharts.com/reach_gl.php?games=651586483
00:45:27 <lambdabot> Title: Halo Reach Game Aggregate Stat Sorter by HaloCharts
00:45:45 <ddarius> Bloody cripes.
00:45:56 <Eduard_Munteanu> A PhD means you did research... for whatever notion of research the issuing institution considers.
00:47:02 <ddarius> "My sociology PhD was on the topic of how to convince boards of people."
00:47:25 <_Ray_> My psychology PhD was o -- ALL GLORY TO THE HYPNOTOAD.
00:47:49 <elliott> ddarius: :-D
00:47:56 <Eduard_Munteanu> :)
00:48:03 <elliott> Maybe the paraconsistent logic folks just fought really huge snakes. (http://www.mcsweeneys.net/articles/faq-the-snake-fight-portion-of-your-thesis-defense)
00:48:04 <shachaf> ☺
01:03:52 <erus`> Most irritating meme of all time: X ALL of the things!
01:04:14 <opqdonut> isn't it "ALL the things!"?
01:04:30 <opqdonut> or rather, "X ALL the Y!"
01:04:36 <opqdonut> </offtopic>
01:05:13 <Eduard_Munteanu> < erus`> Most irritating meme of all time: X ALL of the things!  -- first world problems
01:05:24 <elliott> erus`: You appear to have forgotten about the existence of "u mad?".
01:05:33 <elliott> Sorry to ruin your life again.
01:06:07 <erus`> umad i can deal with
01:07:04 <erus`> second: like a boss. But other than that im ok :)
01:08:36 <dmwit> < Eduard_Munteanu> < erus`> Most irritating meme of all time: X ALL of the  things!  -- first world problems -- Michael Scott -- dmwit
01:08:59 <Eduard_Munteanu> :D
01:26:38 <ski> elliott : how about `~(forall p. ~p \/ p)' ?
01:26:58 <elliott> ski: Hm?
01:27:04 <elliott> I think you can actually prove ~~(forall p. ~p \/ p) in intuitionistic logic.
01:27:14 <opqdonut> yes
01:27:49 <opqdonut> @djinn ((Either (p->Void) p) -> Void) -> Void
01:27:50 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
01:28:22 <Luam> hi
01:28:24 <Luam> can someone explain me what is going there : let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) . Sorry for this nubie question ))))
01:28:45 <Luam> im new in haskell
01:29:03 <ski> opqdonut : that's a proof of `forall a. NotNot (Either (NotNot a) a)' -- which is a different thing
01:29:38 <Schalken> Does anybody know how to get HaXml to work with bytestrings?
01:31:31 <Saizan> ski: you've a Not too many it seems
01:32:00 <ski> er, i am
01:32:14 <ski> that should've been
01:32:25 <ski> @djinn NotNot (Either (Not a) a)
01:32:26 <lambdabot> f a = void (a (Left (\ b -> a (Right b))))
01:33:43 <ski> elliott,opqdonut : you can't prove `(forall a. NotNot (f a)) -> NotNot (forall a. f a)' in intuitinistic logic (the other direction works fine)
01:34:21 <elliott> @djinn Not (Either (Not a) (Either a (NotNot a))
01:34:22 <lambdabot> Cannot parse command
01:34:25 <elliott> @djinn Not (Either (Not a) (Either a (NotNot a)))
01:34:26 <lambdabot> -- f cannot be realized.
01:34:29 <elliott> What fun.
01:34:42 <ski> (this is related to being able to not being able to prove `NotNot (exists a. f a) -> (exists a. NotNot (f a))', the other direction here also works fine)
01:34:53 <msx> are strings in haskell implemented as a linked list?
01:36:06 <ski> elliott,opqdonut : *anyway*, in Brouwers' intuitionistic school, as well as in Markov's russian constructive school (buf for different reasons), you can prove `~(forall p. ~p \/ p)' (but you can't prove `forall p. ~(~p \/ p)')
01:36:25 <elliott> Right.
01:36:30 <ski> msx : yes
01:36:38 <elliott> ?djinn Not (Either (Not p) p)
01:36:38 <lambdabot> -- f cannot be realized.
01:36:41 <msx> interesting
01:36:47 <elliott> msx: Yes, unfortunately.
01:36:56 <elliott> No, there are no special tricks that makes it not terrible.
01:37:03 <msx> why unfortunately?
01:37:07 <elliott> Take a look at the bytestring and text packages for any kind of serious use.
01:37:11 <ski> (s/being able to not being able to/not being able to/)
01:37:22 <elliott> msx: They gobble up tons of memory and are slow.
01:37:31 <elliott> (bytestring is for when you want bytes, text is for Unicode.)
01:38:18 <msx> i liked how you can treat lists and strings the same, but yeah I guess memory penalty is large
01:38:40 <msx> extra pointer per char
01:38:53 <Eduard_Munteanu> Luam: hi, you don't understand how it works?
01:38:56 <elliott> msx: It's worse.
01:39:12 <elliott> msx: The Chars aren't unboxed and are lazy.
01:39:25 <ski> opqdonut,elliott : those two schools can prove that because they assume non-classical axiom (functions are continuous, resp. functions are algorithmic), in plain intuitionistic logic, you can neither prove `forall p. ~p \/ p' nor its negation
01:39:34 <elliott> msx: (As are the tails, of course.)
01:39:44 <Eduard_Munteanu> > let x = [1,2,3,4] in (x, tail x)
01:39:46 <lambdabot>   ([1,2,3,4],[2,3,4])
01:41:21 <Luam> Eduard_Munteanu : Now i draw this in the my note and understand it )
01:41:47 <Luam> now its all fine )
01:42:43 <Luam> but for newbie in haskell it's hard ) to understand from first view
01:43:36 <Eduard_Munteanu> Yeah, you have to keep in mind it's a lazy language.
01:45:05 <opqdonut> ski: right
01:45:07 <Eduard_Munteanu> > zipWith (+) [1..] [10..]
01:45:08 <lambdabot>   [11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59...
01:45:45 <Luam> i understand zipWith func
01:47:04 <msx> how did the bot print that instead of ending up in infinite loop?
01:47:20 <elliott> Laziness.
01:47:51 <elliott> It only takes the first hundred or so characters of the resulting (infinite) string display of the list.
01:47:55 <Luam> is there someone use Haskell for web site development?
01:48:02 <elliott> Plenty of people.
01:48:06 <msx> ah so it did osmething like take 100 $ zipWith (+) [1..] [10..]
01:48:15 <Eduard_Munteanu> msx: the result is productive, that is, even if it has an infinite number of steps, each step completes in finite time. So it can compute only a part of it.
01:48:18 <elliott> http://snapframework.com/ and http://www.yesodweb.com/ are the popular libraries.
01:48:30 <Luam> i know frameworks this )
01:48:38 <elliott> msx: More like (take 100 . show $ zipWith (+) [1..] [10..])
01:48:39 <elliott> But yeah
01:48:40 <Luam> i just ask who use there )
01:48:54 <Eduard_Munteanu> Luam: yeah, take Yesod for example
01:48:56 <Eduard_Munteanu> @google Yesod
01:48:57 <engla> msx: IO is also lazy in haskell
01:48:57 <lambdabot> http://www.yesodweb.com/
01:48:58 <lambdabot> Title: Yesod :: Homepage
01:49:24 <Luam> i picked up yesod )
01:49:31 <Luam> already
01:49:34 <elliott> engla: Well, putStr is.
01:49:41 <elliott> And it's not really lazy, it just handles infinite lists.
01:49:52 <koeien> engla: IO is not always lazy
01:50:07 <shachaf> engla: Lazy IO is evil.
01:50:09 <Eduard_Munteanu> > show (cycle "abc")
01:50:10 <lambdabot>   "\"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
01:50:11 <koeien> in fact, most people don't like lazy I/O
01:50:26 <elliott> shachaf: I think engla is just referring to the fact that putStr can print infinite lists.
01:50:44 <shachaf> Oh. Well, that's not lazy IO.
01:50:55 <shachaf> It's also not relevant in lambdabot's case. :-)
01:51:15 <Eduard_Munteanu> Ouch, two K-lines
01:52:23 <Eduard_Munteanu> Luam: there's also Hakyll which is a static website generator
01:53:18 <Eduard_Munteanu> Luam: you might want to take a look here http://www.haskell.org/haskellwiki/Applications_and_libraries and on http://hackage.haskell.org
01:54:32 <Luam> i read this
02:10:41 <msx> about the http://paste.lisp.org/display/124547 code, I can't use switch macro in a different package, getting "The variable DEFAULT is unbound." error.  I guess that's what flip214 was talking about.   should I use :default instead? ( if so how? just replacing 'default with :default doesn't work). or should I export default symbol?
02:10:59 <msx> ops sorry I thought i was in different channel
02:14:37 <kennyd_> what crossplatform GUIs for haskell is most usable?  *nix/osx/windows
02:15:28 <kennyd_> getting overwhelmed by the choice in here. http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
02:15:30 <Jafet> For particular values of "GUI" and "usable", gtk2hs or wx.
02:18:28 <Kaidelong> good luck building wxhaskell
02:18:32 <Kaidelong> it is possible
02:18:35 <Kaidelong> but it's not going to be easy
02:18:38 <Kaidelong> especially on windows
02:19:01 <Jafet> Come on, I was trying to give the illusion of variety.
02:19:23 <Kaidelong> GUI development in haskell is in a pretty poor state
02:20:11 <Kaidelong> hmm perhaps it would be worth considering installers for the haskell platform that bless gtk2hs or wxhaskell
02:22:12 <Jafet> Haskell programmers consider GUI development to be in a pretty poor state
02:27:21 <engla> is the gtk binding defect? I can imagine it being incomplete and not up to date
02:28:52 <elliott> engla: It's perfectly good.
02:28:52 <lambdabot> good? not great?
02:29:07 <elliott> Well, I'm not qualified to say.
02:29:07 <lambdabot> What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
02:29:38 <elliott> lambdabot: Sorry, are you in the right channel?
02:30:05 <lambdabot> elliott: u mad?
02:30:53 <engla> elliott: ok great
02:38:18 <kizzx2> this page (http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue3/Functional_Programming_vs_Object_Oriented_Programming#OO_and_FP_Styles_Contrasted) says "The functional style ensures that adding another data-consumer (a function) is a strictly local change, whereas adding a new data-producer requires extending a datatype with a new constructor, and thus a major overhaul of every pattern-matching function definition. "
02:38:30 <kizzx2> can't that be solved simply by not using concrete types but type classes?
02:38:52 <kizzx2> and only use pattern matching for internal non abstract types?
02:39:16 <elliott> No.
02:39:23 <elliott> It's the expression problem.
02:39:31 <elliott> (http://en.wikipedia.org/wiki/Expression_problem, http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt)
02:40:33 <kizzx2> but why not?
02:40:51 <kizzx2> for example, if Haskell added a new operation to Show
02:40:54 <kizzx2> nobody would be affected
02:41:08 <elliott> Sure they would; they would have to define that operation in every Show instance.
02:41:48 <kizzx2> oic
02:43:01 <kizzx2> so using the terminology of that page, uses type classes baisaclly turns FP "problems" to OO ones
02:43:32 <elliott> That's a fair assessment, yes.
02:43:40 <elliott> It's more row vs. column than FP vs. OO.
03:08:11 <shaggy-> how to send a null pointer to a C function accepting a String?  passing nullPtr gives me this; Expected type: String Actual type: GHC.Ptr.Ptr a0
03:08:33 <elliott> C functions don't take Strings, String is a Haskell type
03:08:41 <elliott> if some FFI wrapper wants a String, you pass a String, no null pointer about it
03:08:47 <elliott> you'll have to get at the underlying function to do that
03:11:58 <shaggy-> C function takes char *, and expects either a null terminated string or null pointer. it was declared as accepting String in haskell. how can I pass a null pointer?
03:12:44 <shachaf> shaggy-: You can't, presumably.
03:12:57 <shachaf> Use a function accepting Maybe String, or something.
03:13:59 <merijn> Wouldn't [] be an empty string and thus equivalent to passing NULL?
03:14:00 <shaggy-> it would seem odd if I can't, because haskell itself declared that C function not me
03:15:24 <shaggy-> merijn just tried, seems that NULL wasn't passed because I'm not getting expected result
03:16:13 <shachaf> merijn: NULL /= pointer to 0.
03:16:33 <mauke> "haskell itself" doesn't declare functions
03:16:40 <mauke> that's the programmer's job
03:17:31 <elliott> shaggy-: What is the function being declared?
03:18:14 <shaggy-> haskell for windows declares winapi functions. and poorly too if there's no way to pass a null pointer to a function accepting a string
03:18:23 <shaggy-> Graphics.Win32 Graphics.Win32.Window.findWindow
03:20:02 <Eduard_Munteanu> Hm? Aren't you importing some module for that?
03:20:33 <shaggy-> I just installed haskell a couple of hours ago, I did not download any third party modules
03:21:00 <merijn> Did you install Haskell Platform?
03:21:08 <shaggy-> yes
03:21:10 <merijn> That comes with tons of third party modules
03:21:13 <shaggy-> http://www.haskell.org/ghc/docs/7.2.1/html/libraries/Win32-2.2.1.0/Graphics-Win32-Window.html
03:21:15 <mauke> shaggy-: you did not install "haskell"
03:21:34 <merijn> Graphics.* is not part of the language. It's just a third party wrapper around whatever
03:22:37 <born2code> hello all
03:22:50 <Eduard_Munteanu> Hi.
03:23:07 <born2code> i am looking for substring function
03:23:23 <mauke> yeah, that looks misdeclared
03:23:34 <born2code> lets say  i have a string "hello worlds how are you       doing "
03:23:58 <mauke> it should be something like findWindow :: Maybe (Either ATOM String) -> Maybe String -> IO (Maybe HWND)
03:24:12 <shaggy-> no way to get around it? I have to redeclare it myself?
03:24:43 <mauke> shaggy-: well, according to those docs it also exports c_FindWindow
03:24:50 <born2code> now i need a function in which take this string and target string and return the starting of target string
03:25:23 <born2code> myFun :: String -> String -> Maybe Int
03:25:35 <merijn> @hoogle String -> String -> Maybe Int
03:25:35 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
03:25:35 <lambdabot> Data.Time.Format parseTime :: ParseTime t => TimeLocale -> String -> String -> Maybe t
03:25:35 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
03:26:33 <merijn> Pretty sure there is one, but no clue what it's called...
03:27:11 <born2code> if i use elemIndex then i will lost space information
03:27:22 <born2code> i can do words on String
03:27:34 * hackagebot DSH 0.6.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.6.1 (GeorgeGiorgidze)
03:27:36 * hackagebot graph-rewriting 0.5.3 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.5.3 (JanRochel)
03:27:56 <obiwahn> > concat (map f [1..5]) where f x = [x*x| odd x]
03:27:57 <lambdabot>   <no location info>: parse error on input `where'
03:28:21 <born2code> its more like isInfixOf
03:28:41 <born2code> but returing Bool , i am looking for index
03:28:44 <mauke> @hoogle (a -> Bool) -> [a] -> Maybe Int
03:28:45 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
03:28:45 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:28:45 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
03:29:00 <merijn> mauke: That won't work
03:29:16 <mauke> :t \n -> findIndex (n `isPrefixOf`) . tails
03:29:17 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe Int
03:29:24 <elliott> Hmph, mauke beat me to it.
03:29:40 <hvr> ...is the "type: detailed-1.0"-test-suites feature of Cabal supposed to work currently?
03:32:25 <elliott> hvr: lemme parrot what i heard a few days ago
03:32:28 <obiwahn> what is wrong with the where
03:32:30 <elliott> hvr: prematurely documented keep using the old one for now
03:32:54 <Schalken> There's like a dozen regular expression libraries. Which one am I supposed to use?
03:33:46 <shachaf> Text.Regex.Mauke would be good.
03:33:48 <shachaf> If it existed.
03:34:41 <hvr> elliott: old one == "detailed-0.9"?
03:35:11 <Schalken> shachaf: Explain...
03:35:22 <elliott> hvr: No, the exit-code thing, I think.
03:35:28 <elliott> Maybe I'm wrong.
03:35:32 <elliott> I'm just parroting.
03:37:34 * hackagebot graph-rewriting-layout 0.4.5 - Force-directed node placement intended for incremental graph drawing  http://hackage.haskell.org/package/graph-rewriting-layout-0.4.5 (JanRochel)
03:37:40 <obiwahn> > concat (map (\x -> [x*x]) [1..5])
03:37:41 <lambdabot>   [1,4,9,16,25]
03:37:47 <elliott> obiwahn: concatMap
03:37:53 <elliott> erm, quite pointless use though
03:38:39 <obiwahn> > [x*x | x <-[1..5], odd x]
03:38:41 <lambdabot>   [1,9,25]
03:39:52 <merijn> obiwahn: Why did you use "\x -> [x*x]" there?
03:40:13 <shachaf> merijn: Presumably porting a list comprehension.
03:40:31 <merijn> shachaf: But that makes no sense if you're just going to concat afterwards
03:40:40 <obiwahn> i am playing with higherorder functions to get an better understanding and i try to define the list comprehension
03:40:48 <obiwahn> but i fail here:
03:41:07 <obiwahn> > concat (map f [1..5]) where f x = [x*x| odd x]
03:41:07 <merijn> obiwahn: My point was that you could just do "map (\x -> x*x) [1..5]" to achieve the same
03:41:08 <lambdabot>   <no location info>: parse error on input `where'
03:41:52 <kennyd_> > map (^2) [1..5]
03:41:54 <lambdabot>   [1,4,9,16,25]
03:42:11 <b_jonas> > let { f x = [x*x | odd x] } in concatMap f [1..5]
03:42:12 <lambdabot>   [1,9,25]
03:42:33 <obiwahn> > concatMap (map f [1..5]) where f x = [x*x| odd x]
03:42:35 <lambdabot>   <no location info>: parse error on input `where'
03:42:46 <elliott> no where in expressions
03:43:56 <obiwahn> > let {f x = [x*x | odd ]} in concat (map f [1..5])
03:43:57 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
03:43:58 <lambdabot>         against inferred type ...
03:44:04 <merijn> > let f x = [x*x | odd x] in concat (map f [1..5])
03:44:04 <lambdabot>   [1,9,25]
03:44:11 <b_jonas> > (\x -> do { guard (odd x); return (x*x) }) =<< [1..5] -- looks ugly
03:44:11 <lambdabot>   [1,9,25]
03:44:15 <obiwahn> > let {f x = [x*x | odd x]} in concat (map f [1..5])
03:44:15 <merijn> > let f x = [x*x | odd x] in concatMap f [1..5]
03:44:16 <lambdabot>   [1,9,25]
03:44:17 <lambdabot>   [1,9,25]
03:44:30 <obiwahn> yeahy so it was not all wrong after all:)
03:44:45 <mux> > concat . filter odd . map (^2) $ [1..5]
03:44:46 <lambdabot>   No instance for (GHC.Real.Integral [a])
03:44:46 <lambdabot>    arising from a use of `e_1215' a...
03:45:13 * merijn hits mux
03:45:17 <mux> > map (^2) . filter odd $ [1..5]
03:45:18 <merijn> That's wrong
03:45:18 <lambdabot>   [1,9,25]
03:45:22 <mux> indeed it was :-)
03:45:22 <merijn> Exactly :p
03:45:33 <mux> hey, it's still morning for me, don't be so harsh :D
03:45:55 <obiwahn> why let but no where?
03:46:06 <obiwahn> i thought of it as the same
03:46:31 <merijn> obiwahn: Probably for parse reasons
03:46:36 <DrTeggy> let builds expressions, where is syntax used in declarations
03:46:46 <mux> where desugars to let
03:47:35 * hackagebot graph-rewriting-gl 0.6.6 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.6.6 (JanRochel)
03:48:01 <qnikst> hello, can smb advice simpliest package for working with postgres database?
03:52:06 <obiwahn> > [(a,b)| a <-[1..9], b <- [a+1..4] ]
03:52:07 <lambdabot>   [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
03:52:37 * hackagebot graph-rewriting-lambdascope 0.4.9 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.4.9 (JanRochel)
03:52:39 * hackagebot graph-rewriting-ski 0.5.7 - Two implementations of the SKI combinators as interactive graph rewrite systems  http://hackage.haskell.org/package/graph-rewriting-ski-0.5.7 (JanRochel)
03:53:45 <obiwahn> > [(a,b)| a <-[1..4],even a, b <- [a+1..4], odd b ]
03:53:47 <lambdabot>   [(2,3)]
03:54:51 <FUZxxl> Hello!
03:55:14 <sbrg> Hail!
03:55:24 <FUZxxl> Is there a way to implement the function swap :: [a] -> Int -> Int -> [a] in a streaming way,
03:55:54 <mauke> what does it do?
03:56:07 <qnikst> swaps two values of array
03:56:09 <mux> swap two elements in a list by their index?
03:56:22 <mux> [a] is not an array by any meaningful reasoning
03:56:34 <Eduard_Munteanu> (what do you mean by "streaming" though?)
03:56:35 <FUZxxl> Yes, I know.
03:56:40 <FUZxxl> But sometimes it is needed,
03:56:46 <FUZxxl> streaming:
03:56:57 <merijn> Eduard_Munteanu: Not repeatedly running over the entire list, I suppose
03:57:08 <Eduard_Munteanu> Ah.
03:57:16 <FUZxxl> If the list has 10000 entries and I want to swap entry #1 and #12, the function should not evaluate any more elements than needed.
03:57:24 <mauke> FUZxxl: sure, why not?
03:57:34 <mux> if you code carefully, laziness gives you that for free
03:57:51 <FUZxxl> mux: And how to code careful in this case?
03:58:05 <FUZxxl> I couldn't find a way by myself.
03:58:22 <FUZxxl> The problem is, that I also want the algorithm to traverse the list at most once.
03:58:33 <Eduard_Munteanu> You could start by making it    swap xs i j | i > j = swap xs j i
03:58:33 <FUZxxl> I come back later.
03:58:44 <FUZxxl> Eduard_Munteanu:  Indeed.
03:59:01 <FUZxxl> I am going to post this on StackOverflow if I find no solution by myself.
03:59:06 <mux> FUZxxl: I'd take a look at splitAt if I were you
03:59:16 <Eduard_Munteanu> You can ask here as well.
03:59:16 <quicksilver> the obviously solution has the property FUZxxl wanted, surely.
03:59:19 <mux> oh well, I suppose we can't compare to SO
03:59:48 <merijn> mux: #haskell doesn't give out karma yet :p
04:00:01 <merijn> Well, I guess lambdabot does, but it takes more effort to earn it
04:00:06 <merijn> @karma merijn
04:00:06 <lambdabot> You have a karma of 9
04:00:15 <mux> right - merijn++
04:00:15 <merijn> \o/
04:00:16 <hpc> @karma c
04:00:17 <lambdabot> c has a karma of 5
04:00:22 <mux> @karma
04:00:22 <lambdabot> You have a karma of 6
04:00:25 <mux> dang.
04:00:29 <hpc> @karma
04:00:30 <lambdabot> You have a karma of 5
04:00:36 <merijn> I'm winning ;)
04:00:38 <hpc> really, that much? :D
04:00:43 <mux> @karma dons -- resistance is futile
04:00:43 <lambdabot> dons has a karma of 14
04:00:45 <mauke> preflex: karma mux
04:00:45 <preflex>  mux: 7
04:00:46 <hpc> i thought i still had zero ;)
04:00:49 <mauke> preflex: karma hpc
04:00:50 <preflex>  hpc: 5
04:00:50 <mux> oh, I expected more
04:00:56 <quicksilver> the karma's got reset a while ago
04:00:58 <hpc> preflex: karma hpc
04:00:58 <preflex>  hpc: 5
04:01:02 <merijn> @karma lyah
04:01:02 <lambdabot> lyah has a karma of 1
04:01:04 <quicksilver> but after dons stopped coming here regularly
04:01:09 <mauke> preflex: karma dons
04:01:09 <preflex>  dons: 39
04:01:12 <mux> I see
04:01:16 <mux> @karma quicksilver
04:01:17 <lambdabot> quicksilver has a karma of 25
04:01:21 <mauke> preflex: karma C
04:01:22 <preflex>  C: 173872
04:01:22 <quicksilver> hmm looks like they've been reset more recently than I thought
04:01:24 <mux> we've got a winner
04:01:32 <quicksilver> @karma Cale
04:01:33 <lambdabot> Cale has a karma of 54
04:01:34 <mux> @karma Cale
04:01:34 <lambdabot> Cale has a karma of 54
04:01:38 <mux> heh, you beat me to it
04:01:38 <merijn> I wonder if that's related to a certain language :p
04:01:41 <merijn> @karma java
04:01:41 <lambdabot> java has a karma of -10
04:01:44 <mux> @karam dcoutts
04:01:45 <lambdabot> Maybe you meant: karma karma+ karma-
04:01:47 <hpc> mux: it helps when your evil twin is C++ ;)
04:01:49 <mux> @karma dcoutts
04:01:49 <lambdabot> dcoutts has a karma of 22
04:02:05 <Cale> @karma C
04:02:06 <lambdabot> C has a karma of 5
04:02:08 <mux> @karma lambdabot
04:02:08 <lambdabot> lambdabot has a karma of 11
04:02:18 <Eduard_Munteanu> That's balanced against C-- I guess :)
04:02:35 <Eduard_Munteanu> @karma C/C
04:02:35 <int-e> @karma pmichaud
04:02:35 <lambdabot> pmichaud has a karma of 1018
04:02:36 <lambdabot> C/C has a karma of 646
04:02:41 <Cale> preflex: karma Cale
04:02:42 <preflex>  Cale: 84
04:03:00 <int-e> @karma lwall
04:03:00 <lambdabot> lwall has a karma of 530
04:03:16 <int-e> pugs really messes up the statistics.
04:03:19 <mauke> lambdabot: have you been hanging out in #perl6 again?
04:06:15 <merijn> Oh lord, what did I start? >.>
04:06:35 <sbrg> who are pmichaud and lwall?
04:06:38 <elliott> <Eduard_Munteanu> That's balanced against C-- I guess :)
04:06:41 <elliott> lambdabot ignores C++ and C-- :P
04:06:54 <elliott> apparently not preflex though
04:06:55 <merijn> sbrg: I'm guessing lwall == Larry Wall the creator of perl
04:07:02 <sbrg> ah
04:07:22 <merijn> The other guy I have no clue
04:07:24 <elliott> @karma TimToady
04:07:25 <lambdabot> TimToady has a karma of 95
04:07:31 <Eduard_Munteanu> @karma C--
04:07:32 <lambdabot> C-- has a karma of 4
04:07:36 <elliott> @karma C++
04:07:37 <lambdabot> C++ has a karma of -2
04:07:50 <Eduard_Munteanu> C++--
04:08:03 <elliott> @karma C++
04:08:04 <lambdabot> C++ has a karma of -3
04:08:10 <elliott> Wow, that actually works.
04:08:13 <int-e> yes, it has a special hack for that
04:08:36 <elliott> haha
04:08:38 <elliott> C----
04:08:39 <elliott> ?karma C--
04:08:40 <lambdabot> C-- has a karma of 3
04:08:43 <elliott> C--++
04:08:45 <elliott> ?karma C--
04:08:46 <lambdabot> C-- has a karma of 4
04:08:48 <elliott> wonderful
04:08:56 <int-e> (or had some time ago. I haven't looked at the code of the karma module in years.)
04:10:18 <Entroacceptor> ?karma
04:10:19 <lambdabot> You have a karma of 2
04:10:26 <Entroacceptor> yay
04:10:39 <elliott> @karma
04:10:40 <lambdabot> You have a karma of 2
04:10:47 <elliott> so mainstream
04:10:49 <Entroacceptor> high two! ;)
04:13:08 <obiwahn> > let {l1=[y| y<-xs,y<x]; l2=[y|y<-xs,y>=x]} in  f (x:xs) = f (l1 ++ [x] ++ f l2)
04:13:09 <lambdabot>   <no location info>: parse error on input `='
04:14:06 <Eduard_Munteanu> > let l1=[y| y<-xs,y<x]; l2=[y|y<-xs,y>=x]; f (x:xs) = f (l1 ++ [x] ++ f l2) in f [1,2,3,4]
04:14:07 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
04:17:27 <obiwahn> > let {l1=[y| y<-xs,y<x]; l2=[z|z<-xs,z>=x]} in  f (x:xs) = f (l1 ++ [x] ++ f l2)
04:17:28 <lambdabot>   <no location info>: parse error on input `='
04:17:57 <obiwahn> how do i debug haskell code or find my errors?
04:20:32 <efie> i dont see why runState (put 5) 1 evaluates to ((),5); can anyone explain me step by step? http://hpaste.org/51095 thanks..
04:20:43 <merijn> obiwahn: Step 1) is usually trying to understand the compiler error and trying to fix the issue from there, Step 2) is pastebin the error + code here and ask for help, Step 3) start learning haskell's debug tools, Step 4) stop writing errors in the first place :)
04:20:44 <Eduard_Munteanu> > let {f [] = []; f (x:xs) = let l1=[y| y<-xs,y<x]; l2=[y|y<-xs,y>=x] in f (l1 ++ [x] ++ f l2)} in f [1,2,3,4]
04:20:49 <lambdabot>   mueval-core: Time limit exceeded
04:20:53 <merijn> obiwahn: Also, by testing lots of small things in ghci
04:21:01 <born2code> I am looking for library to download a html file including images .
04:21:02 <Eduard_Munteanu> But you're better off doing that using GHC
04:21:08 <mauke> efie: did you expect a different result?
04:22:12 <Eduard_Munteanu> > execState (put 5) 1
04:22:13 <lambdabot>   5
04:22:17 <merijn> efie: Because the returntype of runState is (a,s)?
04:22:29 <efie> mauke: i did not expect anything at all since i have not understood it completelty; i now try to just dissolve the functions
04:22:58 <Eduard_Munteanu> > runState (put 5 >> get >>= return) 1
04:22:59 <lambdabot>   (5,5)
04:23:15 <hpc> :t runState
04:23:17 <lambdabot> forall s a. State s a -> s -> (a, s)
04:23:25 <Eduard_Munteanu> :t execState
04:23:26 <lambdabot> forall s a. State s a -> s -> s
04:23:29 <Eduard_Munteanu> :t evalState
04:23:30 <lambdabot> forall s a. State s a -> s -> a
04:23:32 <mauke> efie: State 5 () is nonsensical
04:24:00 <born2code> will curl download the images in html ?
04:24:26 <hpc> born2code: try the command line tool and see if it does
04:25:07 <mauke> efie: put 5 = State (\_ -> ((), 5))
04:26:02 <hpc> efie: that is, put 5 returns a stateful computation that ignores the current state, sets the state to 5, and returns ()
04:26:30 <efie> um ok
04:27:11 <hpc> get = State (\s -> (s, s)) -- a stateful computation that keeps the current state the same, and returns it
04:27:35 * hackagebot uuagc-cabal 1.0.0.6 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.6 (ArieMiddelkoop)
04:27:36 <mauke> efie: 'State' is a box with one input and two outputs
04:27:37 * hackagebot graph-rewriting-trs 0.1.3 - Evaluate a first-order term rewrite system interactively using graph reduction  http://hackage.haskell.org/package/graph-rewriting-trs-0.1.3 (JanRochel)
04:27:43 <mauke> and by "box" I mean "function"
04:28:00 <hpc> hypothetical: succState = State (\s -> ((), s+1)) -- increments the current state and returns ()
04:28:06 <hpc> efie: see the pattern?
04:28:38 <efie> yes
04:28:42 <hpc> :D
04:29:36 <int-e> @type modify
04:29:37 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
04:29:45 <hpc> you should take a look at the Functor instance for State, and then the Monad instance
04:29:59 <mauke> modify f = State (\s -> ((), f s))
04:30:00 <hpc> so you can see how it all comes together with it sequencing states and stuff
04:30:19 <efie> okay, thanks
04:30:47 <int-e> (Sorry, the type is not very helpful for learning because of the MonadState s m constraint.)
04:31:12 <mauke> @src State modify
04:31:13 <lambdabot> Source not found. There are some things that I just don't know.
04:34:30 <calee2005> anyone upgrading to EclipseFP 2.1? I have some problems using the new SourceGraph feature
04:35:27 <calee2005> eclipse says "Could not start process" when I clicked "Run SourceGraph"
04:41:44 <flamingspinach> :O
04:41:56 <flamingspinach> .lhs - Literate HaSkell? or Left Hand Side? :O
04:47:35 * hackagebot deepseq 1.2.0.0 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.2.0.0 (IanLynagh)
04:51:21 <NewbieCoder> how goes
04:55:44 <NewbieCoder> noone alive?
04:55:48 <NewbieCoder> how fun
04:57:57 <mauke> fun is off-topic here
04:58:26 <NewbieCoder> good to know
04:58:27 <mauke> did I say "here"? I meant "in ##C++"
04:58:44 <NewbieCoder> in ##C++?
04:59:09 <NewbieCoder> #haskell*?
05:00:09 <NewbieCoder> alright then
05:00:40 <mauke> did you have a haskell question?
05:00:45 <NewbieCoder> nope
05:00:56 <mauke> well, it seems like everyone else is asleep right now
05:00:57 <NewbieCoder> its pretty simple coming form other languages
05:01:01 <NewbieCoder> i see
05:01:14 <NewbieCoder> im just here seein whats goin on is all
05:01:32 <mauke> @quote
05:01:33 <lambdabot> MissPiggy says: iPad...? apples gone into santiary products
05:01:40 <mauke> @quote
05:01:41 <lambdabot> megeria says: i am so new to haskell that i still have the new car smell
05:02:05 <TobyGoodwin> "car" is spelled "head" in haskell
05:02:16 <mrcarrot> @quote
05:02:17 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
05:02:35 * hackagebot deepseq 1.2.0.1 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.2.0.1 (IanLynagh)
05:03:11 <mauke> TobyGoodwin: or fst
05:04:12 <obiwahn> re lost connetion:(
05:04:22 <mrcarrot> not necessary... you could have ["car1","car2","car3"] in rush hour
05:04:24 <NewbieCoder> lol
05:05:16 <obiwahn> let {l1=[y| y<-xs,y<x]; l2=[z|z<-xs,z>=x]} in  f (x:xs) = f (l1 ++ [x] ++ f l2) -- what is wrong with my quicksort?
05:05:42 <mauke> xs is undefined
05:06:05 <mauke> f is missing a base case
05:07:18 <kalven> it's not in-place
05:19:53 <erus`> so you guys on the other side
05:20:24 <opqdonut> what side?
05:21:19 <erus`> net split :O
05:24:11 <qnikst> can smb consult me about acid-state usage
05:29:52 <obiwahn> who is master of the lambdabot?
05:31:03 <quicksilver> Cale runs it
05:31:12 <quicksilver> various people have coded it; more recently gwern I think.
05:32:42 <Jaak> so.. Sensei Cale -- master of the lambdabot
05:32:47 <Entroacceptor> wasn't there someone who wrote haskell for androids or iphones?
05:32:52 <obiwahn> is it free? i'd like the bot to join my channel or run another instance:)
05:32:59 <Entroacceptor> @help
05:33:00 <quicksilver> obiwahn: you can download it from hackage
05:33:12 <Eduard_Munteanu> Not sure if it builds though
05:33:15 <quicksilver> it may not be entirely straightforward to get it running
05:41:39 <erus`> Entroacceptor: yes
05:41:46 <erus`> i forget who
05:45:13 <quicksilver> Entroacceptor: the company that Cale works for - which also employs a few other #haskellers - is writing an iPhone game in haskell
05:45:17 <quicksilver> or, partly in haskell
05:46:52 <Entroacceptor> partly?
05:47:45 <obiwahn> ist there a prelude funktion to merge infinite lists?
05:48:15 <simon> can lambdas have guards?
05:48:45 <simon> oh, I'd use a case.
05:48:50 <byorgey> obiwahn: not that I know of
05:48:54 <hpc> simon: i think so, but in those cases you should just let foo ... | ... in ...
05:49:00 <hpc> or a case
05:49:26 <hpc> obiwahn: what do you mean by merge?
05:49:41 <hpc> > zip [1..] ['\0' ..]
05:49:49 <quicksilver> Entroacceptor: part of the main graphics loop is in C++ or C.
05:50:03 <hpc> anyhoo, zip may be what you want
05:50:22 <Starfire> quicksilver: Do you embed Haskell into a C++ program or is it the other way around?
05:50:35 <quicksilver> Starfire: not me :)
05:50:37 <quicksilver> them.
05:50:39 <Starfire> Oh.
05:50:48 <hpc> Starfire: i think you would embed both into C
05:50:49 <quicksilver> there isn't really a significant difference between those two approaches
05:50:58 <hpc> i understand haskell and c++ don't mix very well at all
05:51:02 <quicksilver> it doesn't matter much who owns main()
05:51:16 <quicksilver> hpc: they're fine. They both understand the C ABI.
05:51:52 <obiwahn> [1 3 5 7 9 11 13...] [ 3 9 12 ...] --> [1 3 5 7 9 11 12 13 ...]
05:52:23 <obiwahn> like keep Ord in the resulting list and eliminate duplicates
05:52:26 <Starfire> I think Haskell would be a great language for embedding into programs, if there was a good API for it and if linking was easy.
05:52:54 <Starfire> Especially if there was some nice high-level interop API like boost::python or luabind.
05:52:58 <mauke> obiwahn: I don't think so
05:55:32 <erus`> Starfire: i agree
05:55:40 <erus`> all non IO code should be in haskell
05:55:47 <erus`> the rest in C(++)
05:56:27 <Starfire> Though I suspect writing a Haskell <-> C++ interop library would be somewhat involved, because both languages are statically typed.
05:56:46 <Starfire> Lua and Python are dynamically typed, which makes interop simpler.
05:57:21 <Eduard_Munteanu> CPU-intensive code might be accomodated better by C, too.
05:57:29 <Eduard_Munteanu> Some algorithms at least.
05:58:16 <favonia> +1 for C for more stable ABI (usually)
05:58:52 <erus`> I wonder if there would be a market for a dynamically typed pure functional language with no IO that you can use as a scripting language from C...
05:59:40 <Entroacceptor> it could be of some use
05:59:41 <confound> "haskellscript"
05:59:52 <quicksilver> erus`: there is no reason to put the rest in C(++)
05:59:59 <quicksilver> haskell is a much better imperative language than C or C++
06:00:10 <erus`> quicksilver: not for me
06:00:11 <Starfire> For some values of 'better'.
06:00:13 <obiwahn> ..
06:00:20 <Eduard_Munteanu> You probably mean weakly-typed.
06:00:23 <erus`> writing opengl calls in haskell is a pain
06:00:46 <quicksilver> writing opengl calls in C is a pain
06:00:51 <quicksilver> at least in haskell you can abstract the pain away
06:01:05 <Starfire> What I really like about imperative haskell is how IO actions are first-class like everything else and can be passed around freely.
06:01:17 <quicksilver> yes
06:01:49 <erus`> trying to use state-full libraries from haskell ...
06:02:55 <Eduard_Munteanu> It's not really that bad.
06:03:32 <Eduard_Munteanu> I just doesn't look a lot like Haskell.
06:04:22 <favonia> erus`: hmm... I think there are two separate issues here. Haskell core language is great (compared to C/C++) but unfortunately some libs/wraps still need more manpower to clean up.
06:05:20 <merijn> I wouldn't call really compare Haskell to C and say its better. Its just *different*
06:05:28 <Starfire> I'd guess that Haskell also has problems in the raw number crunching territory.
06:05:41 <merijn> Starfire: Not as bad as you'd think
06:06:09 <Starfire> merijn: My understanding is that it's rather good compared to everything else, but not as good as say, C++ or Fortran.
06:06:13 <merijn> Starfire: But it requires dark magic to coax the raw speed out of Haskell. But some numeric code can be faster in haskell then in C
06:06:42 <merijn> C/Fortran can be faster in the majority of cases, yeah
06:07:09 <benmachine> in order to make haskell *really* fast you have to start giving up most of the benefits of using haskell
06:07:25 <merijn> Of course only like 0.001% of all software written needs to be that fast
06:07:33 <balta2ar> guys, what do you think might be an approximate correlation between LOC in haskell and C++? e.g. I have a program which is ~1000 LOC in haskell. How many LOCs it could be in C++? (LOC = Lines of Code) I know it does heavily depend on the code, but anyway.
06:07:37 <Starfire> My view is that both languages have their strengths. It would be nice to have a good interop library so you could easily combine those strengths.
06:08:10 <merijn> Haskell's C interoperability is already pretty nice, I though?
06:08:15 <merijn> s/though/thought
06:08:20 <balta2ar> ratio, I mean
06:08:29 <benmachine> yeah, haskell-C interop isn't too bad
06:08:38 <benmachine> calling haskell from C is a little more painful than vice versa
06:08:38 <Starfire> C interop is fine, but somewhat manual in my experience.
06:08:55 <merijn> Starfire: Well, obviously, how else would you do it?
06:09:28 <erus`> merijn: make some bastardized hybrid language
06:09:33 <Starfire> merijn: Well, for example, you could conceivably have some template haskell thingy that would generate Storable instances for you.
06:09:48 <favonia> merijn: well personally I hate plenty of undefinedness among C/C++ standards. still need to remind others of undefinedness in C/C++ when cooperating with others :-(
06:09:52 <benmachine> oh, there are plenty of things which generate storable instances for you
06:10:00 <benmachine> I use bindings-DSL to generate mine
06:10:56 <obiwahn> well personally I hate plenty of undefinedness among C/C++ STL implementations / compilers
06:10:56 <Starfire> benmachine: Hmm, I haven't checked out bindings-DSL. Thanks.
06:11:59 <favonia> obiwahn: yes, all the major implementations too!
06:13:17 <quicksilver> merijn: first class IO actions and anonymous functions make it easy to abstract repeating patterns; some of which are hard to abstract in C (requiring you to create lots of little functions) and some are almost impossible.
06:13:32 <quicksilver> (the 'blocks' thing that apple invented help a bit in this regard)
06:13:47 <quicksilver> merijn: and, secondly, haskells type checking helps more often than in hinders, even in imperative code.
06:14:05 <quicksilver> those two points make more precise what I meant when I say 'haskell is better for writing imperative code than C'
06:14:16 <quicksilver> even *ocaml* is better for imperative code than C, and that's a horrid language ;)
06:15:03 <benmachine> quicksilver: it surprises me that you'd highlight anonymous functions in particular as tools for abstraction - do you just mean lightweight functions?
06:15:23 <erus`> could one do static type checking with polymorphic typed?
06:15:51 <benmachine> erus`: ...haskell has polymorphic types, and static type checking
06:16:05 <erus`> monomorphic?
06:16:40 <quicksilver> benmachine: it's things like being able to do map (\c -> drawCube c 5) [Red,Green,Blue]
06:17:00 <merijn> quicksilver: I didn't say anything about which was an imperative language. I just don't think you can call Haskell better then C because they just have such completely different applications
06:17:11 <favonia> anyway, after all the troubles I realized C/C++ trust programmers too much, and people are usually careful enough. I think they should be fixed, for example disallowing dangerous pointer conversions. well currently I still speak Haskell/C despite complaining C
06:17:15 <merijn> Now, of course there's people writing general purpose applications in C, but we call those "idiots"
06:17:20 <quicksilver> merijn: I don't think they have different applications, because I apply them to the same problems.
06:17:37 <merijn> quicksilver: Your mistake? :D
06:17:49 <erus`> linus is an idiot now?
06:17:53 <favonia> s/careful/not careful/
06:17:55 <benmachine> quicksilver: ok, I can see how that makes sense
06:17:57 <confound> linus writes general purpose applications?
06:18:06 <erus`> yep
06:18:09 <erus`> in C too
06:18:50 <merijn> erus`: Just because he wrote a popular OS doesn't mean he's not an idiot
06:19:13 <obiwahn> > :t putChar
06:19:28 <merijn> obiwahn: Lambdabot doesn't need a > before ":t"
06:19:30 <merijn> :t putChar
06:19:31 <erus`> hes a git but i dont think hes an idiot.
06:19:42 <merijn> Especially when you consider the quality of the linux code :p
06:19:48 <ben> git being written in C seems like a fairly sound decision
06:20:05 <quicksilver> benmachine: it's fiddly abstracting stuff like that in C. Often people just don't bother, and leave the repeated code
06:20:16 <obiwahn> it has to  so it can be used on most platforms
06:20:16 <quicksilver> benmachine: if they do bother, it involves making lots of little functions or using macros.
06:20:26 <benmachine> quicksilver: yeah, I suppose so
06:20:39 <erus`> https://github.com/torvalds/diveclog general purpose app
06:20:39 <merijn> quicksilver: Or implementing "templates" using CPP like I had to >.>
06:20:41 <obiwahn> git used to be shellscript + rsync in the beginning
06:20:42 <benmachine> I thought git was perly
06:20:44 <quicksilver> merijn: yes.
06:20:49 <quicksilver> merijn: CPP is actually very powerful
06:20:59 <quicksilver> merijn: CPP + C has more abstraction power than haskell
06:21:04 <quicksilver> merijn: but it's a bitch to work with and debug
06:21:15 <quicksilver> as you will certainly know, if you implemented templates in it :)
06:21:23 <merijn> Tell me about it
06:21:36 <merijn> Now add pthreads and mutexes and you know my joy :)
06:22:08 <erus`> use channels :)
06:22:35 <merijn> Since when does C have channels?
06:22:52 <benmachine> include a haskell interpreter in your program, and then use channels
06:22:54 <erus`> use a library
06:23:02 * benmachine nods
06:23:37 <erus`> C++ would be nicer
06:23:42 <erus`> templates and whatnot
06:24:50 <merijn> erus`: I'm implementing a runtime for channels (well, streaming networks), so that'd kinda defeat the purpose of my work
06:25:23 <erus`> ah :P
06:25:24 <merijn> And just tossing out the entire codebase and rewriting in C++ or something else that is nice didn't/doesn't fit my time availability :p
06:26:31 <obiwahn> :t printChar 'a' >> printChar 'b'
06:26:32 <erus`> does all template code still have to be in header files in c++0x ?
06:26:40 <obiwahn> > printChar 'a' >> printChar 'b'
06:26:42 <ben> yep
06:26:53 <favonia> yes
06:27:07 <obiwahn> > putChar 'f'
06:27:09 <merijn> obiwahn: I'm pretty sure lambdabot doesn't accept IO actions
06:27:27 <obiwahn> ok
06:27:28 <favonia> erus`: they even remove the semantics of "export"
06:27:33 <mauke> merijn: it does
06:28:27 <erus`> well that sucks...
06:29:11 <zhasha> http://en.wikipedia.org/wiki/C++11#Extern_template
06:29:29 <zhasha> although I don't know the implications of that
06:32:52 <favonia> zhasha: this is related, but I guess erus` is asking about "export", which is more powerful. :) http://en.wikipedia.org/wiki/Export_(C%2B%2B)#Exported_templates
06:33:42 <dibblego> if it is true that ¬(P ∧ Q) ⇒ (¬P ∨ ¬Q) then why can't I inhabit ((p, q) -> Void) -> Either (p -> Void) (q -> Void) ?
06:34:17 <luite> hmm, got a new laptop but now I can't switch channels in irssi anymore? what are the keys for that on apple? :p
06:34:28 <mauke> it's a terminal option somewhere
06:34:29 <roconnor> dibblego: that statement isn't constructive
06:34:40 <companion_cube> +1
06:34:42 <Botje> luite: escape + number
06:34:47 <Botje> or alt+number
06:35:15 <luite> Botje: the option key says alt, but it doesn't work with a number
06:35:16 <roconnor> dibblego: perhaps you would like a topological counter example?
06:35:18 <companion_cube> a specialisation is ¬(P /\ ¬P) -> (¬P \/ ¬¬P)
06:35:25 <Axman6> luite: esc-#
06:35:27 <mauke> luite: http://quadpoint.org/articles/irssi#using_the_alt_key_as_meta
06:35:28 <Jafet> In unix land, apple bites you
06:35:38 <Axman6> not really...
06:35:52 <Botje> luite: yeah. I use escape
06:35:57 <Botje> (or caps lock, since i bound it to escape)
06:36:24 <Axman6> it's just that option already has a defined usage, for typing extended characters: é, ü, œ∑´®†\¨ˆ etc.
06:36:37 <mauke> that's what the compose key is for
06:36:46 <mauke> also AltGr
06:37:11 <Axman6> in iTerm 2 at least, you can set one of your option keys to be the meta key. i use left option for meta and switching irssi windows
06:37:13 <favonia> dibblego: You could have ((((p, q) -> Void) -> Either (p -> Void) (q -> Void)) -> Void) -> Void in constructive logic
06:37:17 <Axman6> ... compose key? o.O
06:37:27 <mauke> how can you live without a compose key?
06:37:31 <luite> Axman6: yeah that's apparently what it does
06:37:54 <roconnor> @djinn  ((((p, q) -> Void) -> Either (p -> Void) (q -> Void)) -> Void) -> Void
06:38:08 <luite> also why doesn't this thing have a PgUp :p
06:38:24 <mauke> alt+p, alt+n
06:38:42 <Axman6> luite: fn-up/down
06:38:43 <luite> yeah that works
06:38:51 <Axman6> or fm-shift-up/down
06:38:55 <merijn> There's just a simple checkbox to set alt to be the meta key, btw
06:38:58 <Axman6> fn*
06:39:17 <luite> ok got the channel switching workign, so I can ask further questions in a more appropriate channel
06:39:21 <benmachine> heh
06:39:23 <Axman6> merijn: shush, you'll interrupt the Apple haters
06:39:33 <benmachine> I think I remember doing some fairly perverse things on my mac
06:39:37 <benmachine> to get irssi behaving how I wanted
06:39:38 <Axman6> luite: /win <number> :P
06:39:50 <dibblego> ah yes thanks, my mistake was earlier
06:39:58 <merijn> Cmd-, to enter the Preferences menu, select keyboard tab and click "Use option as meta", seems fairly intuitive... >.<
06:40:05 <Axman6> benmachine: it pretty much just works now, unicode and everything
06:41:03 <Axman6> merijn: but it's Apple, so of course it's wrong -_-
06:41:12 <luite> Axman6: hehe yeah I'm not used to typing those commands :p
06:46:52 <qubodup> hello
06:47:46 <simon> http://hpaste.org/51098 -- I think I'm specifying the instance wrongly. it isn't explicit that a must be of a Sizeable type, though.
06:49:20 <simon> specifically: instance Sizeable (Tree a) where
06:49:20 <simon>   size = treefold (\x acc -> size x + acc) 0
06:50:59 <mux> simon: in your Sizeable instance for Tree a, you recursively call size on the elements of the tree (the a's); yet there is no instance for it
06:51:12 <Axman6> simon: instance Sizeable a => Sizeable (Tree a) where ...
06:51:13 <rwbarton> that instance only works if a is Sizeable, so you should write  instance (Sizeable a) => Sizeable (Tree a) where ...
06:51:14 <mux> either you change your instance to
06:51:22 <mux> instance Sizeable a => Sizeable (Tree a)
06:51:36 <mux> either you consider all elements in the tree are of size 1 (and thus only really compute the size of the tree)
06:51:50 <mux> or you could just have a Foldable instance which gives you length for free
06:52:00 <Eduard_Munteanu> qubodup: hi
06:52:19 <simon> mux, yeah, I should make my Tree Foldable.
06:52:19 * _Ray_ was sort of surprised Foldable didn't mean that it had a foldr or foldl :p
06:52:33 <benmachine> :t Data.Foldable.foldr
06:52:40 <simon> _flow_, oh :) well, for binary trees you can fold more than two ways.
06:52:59 <tew88> I'm trying to work my way through 99 Haskell Problems. I've managed to confuse myself on problem 13. Can anyone correct it and explain what I'm doing wrong? http://codepad.org/voUX1FY9
06:53:49 <simon> thanks, mux.
06:54:13 <mux> simon: you're welcome
06:54:18 <Axman6> tew88: you want : instead of ++ i think
06:54:26 <Axman6> yeah
06:54:29 <mux> :t length . Data.Foldable.toList
06:54:47 <mux> lambdabot went shopping again?
06:55:03 <roconnor> repLens :: Representable f => Lens a b -> Lens (f a) (f b) -- crazy
06:55:05 <Axman6> wait...
06:55:35 <dibblego> roconnor: @src Representable
06:55:43 <Axman6> yeah, that is quite confused, heh. you don't want map at all, just rle (x:takeWhile...) : h99_...
06:56:08 <roconnor> dibblego: it is a functor f that is isomorphic to (k ->) for some k
06:56:16 <Eduard_Munteanu> The indentation there seems a bit confusing, though maybe I'm not used to it.
06:59:14 <tew88> Axman6: You're dead right it's confused! ;) What I *think* it should be doing is: the takeWhile generates a list (possibly a singleton), I map this with rle to wrap it up in my 'Item a' data structure, and I append the rest of the as yet unprocessed list with ++.
06:59:40 <obiwahn> what is worng with:
06:59:43 <obiwahn> echo :: IO()
06:59:47 <obiwahn> echo = getChar >>= putChar()
06:59:54 <Axman6> tew88: how does map do that? map just takes a function, and applies it to every element of a given list
06:59:59 <benmachine> obiwahn: what's the () for after putChar?
07:00:03 <obiwahn> ()
07:00:11 <Eduard_Munteanu> @hoogle putChar
07:00:16 <tew88> Axman6: Facepalm!
07:00:29 <Axman6> you need to drop the map :)
07:00:54 <Eduard_Munteanu> obiwahn: how about getChar >>= putChar
07:01:10 <byorgey> roconnor: why is that crazy?
07:01:32 <roconnor> byorgey: it is an operation of lenses that I hadn't considered before.
07:01:56 <Axman6> echo.hs: main = forever (getChar >>= putChar) -- >_>
07:01:59 <roconnor> byorgey: I was just thinking how life would be different if lenses were part of Haskell 1.2
07:02:00 <byorgey> roconnor: oh, that sense of 'crazy', I see =)
07:03:36 <tew88> Axman6: Thanks for the reality-check.
07:03:43 <Axman6> no worries
07:03:57 <byorgey> roconnor: I finally read your star-semiring post, freaking awesome stuff =)
07:04:20 <roconnor> :)
07:04:36 <roconnor> Dioids are pretty neat
07:05:10 <byorgey> I guess next time I want to implement some algorithm I will just have to figure out what star-semiring to use
07:05:22 <roconnor> yep
07:05:22 <byorgey> roconnor: what's a dioid?
07:05:39 <roconnor> A dioid is an idemponent semiring
07:05:47 <byorgey> oh, ok
07:05:47 <roconnor> monoids are so last year
07:05:50 <byorgey> hehe
07:05:53 <mux> that makes everything clear
07:05:59 <roconnor> today it is all about *di*oids
07:06:18 * byorgey buys stock in trioids for next year
07:06:19 <benmachine> idempotent means that a*a*b = a*b?
07:06:25 <benmachine> or does it just mean that a*a = a?
07:06:30 <roconnor> benmachine: in this case it means that a + a  = a
07:06:34 <benmachine> oh right
07:06:38 <benmachine> oh yeah, semiring
07:07:00 <roconnor> in CS we want to think of + as parallel composition or parallel "wiring"
07:07:06 <benmachine> wait, which one is semiring
07:07:39 <roconnor> benmachine: ring without negation
07:07:40 <byorgey> semiring = commutative monoid + monoid, with distributive and absorption properties
07:07:43 <byorgey> right?
07:07:50 <roconnor> byorgey: yes
07:08:04 <benmachine> absorption is that 0*x = 0, and is now an axiom since we don't have negation anymore?
07:08:13 <benmachine> wait
07:08:19 <roconnor> benmachine: yes
07:08:21 <benmachine> right
07:08:40 <roconnor> and without commutativity of * we also state that x*0 = 0
07:08:58 <benmachine> ah, okay
07:11:10 <jpcooper> how do I convert something which is an instance of show, to a ByteString?
07:11:43 <quicksilver> pack . show
07:11:47 <quicksilver> typically
07:11:49 <jpcooper> thanks
07:11:53 <quicksilver> if ascii-encoded bytes are what you want
07:12:00 <quicksilver> (and show output is generally ascii only)
07:12:34 <Jafet> pack . unpack . utf8encode . show
07:12:55 <jpcooper> ascii-encoded Int64
07:12:57 <obiwahn> @src getLine
07:12:59 <Jafet> Why are all the useful encoders squirreled away under Data.Text
07:13:25 <Jafet> Where people who don't know what encoding is will never find them
07:14:02 <Jafet> pack.show won't typecheck anyway, you need pack.map(toEnum.ord).show
07:14:43 <Jafet> That will at least throw an exception, if you were wrong and show didn't produce ascii text
07:15:49 <quicksilver> Jafet: pack . show typechecks with the Char8 bytestring
07:16:36 <quicksilver> Jafet: and no standard show instance produces anything on which utf8encode wouldn't be a (type-changing) nop
07:17:14 <Jafet> I ignore anyone who recommends Char8, because there's like a 99.99% chance they're wrong
07:17:22 <Jafet> Summarily.
07:18:11 <quicksilver> reasonable strategy but it is not an insane choice when you know you're dealing with 7bit data
07:19:39 <Jafet> I've used ellipsis in show before, for recursive structures, precisely because it isn't an ascii string
07:20:00 <Jafet> Anyway yeah, I should summarily ignore this "strategy" starting now
07:23:47 <osaunders> I’m interested in getting started with generics. What should I read first?
07:24:46 <obiwahn_> ?
07:25:24 <osaunders> obiwahn_: What are you confused about
07:25:34 <obiwahn_> oh:) http://www.haskell.org/haskellwiki/Generics
07:25:42 <jpcooper> is it possible to have understand "asdfadf" as a bytestring when needed?
07:26:11 <obiwahn_> i wondered if you are in the right channel
07:26:30 <roconnor_> jpcooper: there is an extension that will do that
07:26:50 <koeien> {-# LANGUAGE OverloadedStrings #-}
07:27:08 <jpcooper> thanks
07:27:53 <jpcooper> also pack seems to want [Word8] and I was told to use pack . show to convert an Int64 to a ByteString. Should I use show from somewhere else?
07:28:04 <osaunders> Uniplate seems to claim it is better than SYB
07:28:33 <Jafet> jpcooper: do you understand that Chars aren't bytes?
07:29:02 <jpcooper> Jafet: I do
07:29:45 <Jafet> Then you have to encode the characters into bytes. Unfortunately, the best ways to do this don't take String, but Text. See Data.Text.Encoding
07:29:58 <benmachine> jpcooper: the evilwrong way is to use Data.ByteString.Char8.pack
07:30:09 <jpcooper> I just want an ascii representation of an Int64
07:30:29 <Jafet> If you don't mind getting exceptions when your characters aren't 8-bit, use map (toEnum.ord) to force it into Word8
07:31:00 <jpcooper> hmm
07:31:07 <Jafet> You can then stuff all this into your IsString instance, if you want.
07:31:11 <benmachine> or just use Data.ByteString.Char8 that effectively does that for you
07:31:24 <benmachine> (except it silently truncates instead of exceptioning)
07:31:27 <Jafet> Nope, Char8 silently drops higher characters
07:31:36 <Jafet> I can't think of any case where you'd want that
07:31:44 <mux> s/8-bit/7-bit/
07:31:55 <benmachine> Jafet: in the case where you already know you dn't have any higher characters, for example
07:31:59 <benmachine> +o
07:32:37 <Jafet> "don't" is one thing—"won't" is another
07:32:38 <jpcooper> I don't know what you mean about dropping higher characters. Is this related to Int64?
07:33:11 <Jafet> If you only print Int64, then you'll always get ascii characters and it's fine.
07:33:17 <jpcooper> okay
07:33:55 <roconnor_> jpcooper: techinically Ascii is 7-bit
07:34:27 <jpcooper> roconnor_: good point
07:34:30 <Jafet> Well, technically we're using unicode
07:35:02 <Jafet> It just happens to start with Latin-1, which just happens to start with ascii.
07:35:31 <roconnor_> jpcooper: but I presume you mean you want an iso-latin-1 encoding of Int64
07:35:42 <jpcooper> roconnor_: indeed
07:36:14 <roconnor_> (or maybe you want a CodePage 437 encoding)
07:37:40 <mux> Jafet: actually latin1 (aka iso-8859-1) is not a proper subset of utf-8, only ASCII is
07:38:14 <quicksilver> latin1 is nothing remotely like a subset of utf-8
07:38:21 <quicksilver> but it is very very close to being a subset of 'unicode points'
07:38:31 <mux> everything is a subset of unicode points
07:38:32 <mux> :-)
07:38:46 <quicksilver> well a subset with the same numbering
07:38:57 <quicksilver> and jafet said unicode as far as I can see, not utf8
07:39:38 <mux> I may have misinterpreted what he said, sure
07:39:47 <Jafet> Oh, I thought the first 255 code points correspond to some other character set
07:39:53 <mux> but since there potential confusion, I thought I'd add some precision
07:39:55 <Jafet> Or 256
07:40:50 <confound> bytes with values 00-7f are interpreted same as either ascii or utf-8. maybe that's what you're thinking of?
07:41:19 <mux> confound: are you talking to me?
07:41:23 <confound> no, jafet
07:42:05 <Jafet> "ISO-8859-1 was incorporated as the first 256 code points of ISO/IEC 10646 and Unicode."
07:42:13 <Jafet> Seems I was correct
07:42:51 <quicksilver> Jafet: you were right
07:43:05 <confound> sort of
07:43:10 <quicksilver> Jafet: although pedants make some point about control characters which I don't particularly follow or care about
07:43:29 <quicksilver> but latin1 is certainly very close to a numerical initial segmant of unicode code points.
07:43:36 <confound> I didn't see the original context, so you might have been wrong if you were saying that those first 256 are represented by the same bytes in both iso-8859-1 and utf8
07:43:57 <Jafet> The control characters match up exactly. It is Microsoft that substituted the control characters to make code page 1252
07:44:15 <fabbomelker> hey all
07:44:21 <confound> right, that's incompat between iso-8859-1 and cp1252, not iso-8859-1 and unicode
07:45:02 <fabbomelker> I was wondering if anyone has experience of using Haskell for developing Numerical solvers for eg. PDE's
07:46:03 <quicksilver> ah ok
07:46:21 <rtharper> dcoutts: ping?
07:46:31 <fabbomelker> anyone?
07:47:03 <rtharper> fabbomelker: I'm afraid I don't, you might want to search the HAskell-cafe lists, I have a feeling you are not alone on this one
07:47:24 <fabbomelker> cafe lists?
07:47:37 <rtharper> Haskell-cafe is the main mailing list
07:47:39 <rtharper> for haskell
07:47:45 <rtharper> gets all sorts of questions/answers
07:47:46 <fabbomelker> aha ok, thanx man
07:47:59 <fabbomelker> is there a FAQ?
07:48:02 <rtharper> the folks are usually pretty helpful, and you will get a wider audience than the IRC
07:48:05 <jlouis> @pl (\_ acc -> acc + 1)
07:48:07 <rtharper> for haskell or the mailing list? =)
07:48:24 <jlouis> somebody, help me with lambdabot >:)
07:48:38 <_Ray_> :t 1
07:48:43 <fabbomelker> ok I see
07:48:44 <_Ray_> He may be dead.
07:48:46 <jlouis> Lambdabot isn't here
07:48:55 <_Ray_> That would explain it.
07:49:00 <jlouis> but but... Haskell is stable!
07:49:07 <fabbomelker> for haskell. but I'll scan the webpage
07:49:34 <Jafet> const (1 +)
07:49:47 <Jafet> Silly lambdabot, it should be const succ
07:50:06 <jlouis> ah yes
07:50:09 <Jafet> @quote const.succ
07:50:13 <Jafet> Oh, nevermind.
07:50:20 <_Ray_> Silly humans.
07:50:33 <Eduard_Munteanu> fabbomelker: http://haskell.org/haskellwiki/FAQ
07:51:05 <fabbomelker> ty Eduard
07:57:37 * hackagebot binary-communicator 1.0.2.1 - Flexible way to ease transmission of binary data.  http://hackage.haskell.org/package/binary-communicator-1.0.2.1 (SoenkeHahn)
08:26:30 <tac-tics> @type runST
08:26:52 <tac-tics> Is lambdabot down??
08:27:46 <osfamero1> can we get a hand with https://gist.github.com/1203752 ?
08:28:30 <osfamero1> oh, I'm banned... was I bouncing?
08:29:17 <leod> how can you speak if you're banned?
08:29:35 <osfamero1> good point
08:29:59 <osfamero1> I appear to be banned on #mysql and #git... can't change my nick
08:30:04 <leod> ah
08:30:08 <osfameron> there we go
08:30:22 <hpc> why are you banned?
08:30:28 <osfameron> ok.  So, that snippet.  We're trying to make stepIt recursive
08:30:37 <osfameron> and I'm getting code-vertigo
08:30:48 <osfameron> no idea.  I'm guessing I was bouncing at some point...
08:32:40 * hackagebot Webrexp 1.1 - Regexp-like engine to scrap web data  http://hackage.haskell.org/package/Webrexp-1.1 (VincentBerthoux)
08:33:57 <osfameron> I thought we'd want a fold, but we seem to a) want to compare 2 adjacent values (like zipWith fib implementation), b) keep the list of values to the left (like an accumulator in foldl) and c) be able to concatenate an arbitrary number of values from the step function
08:34:28 <osfameron> ah, never mind, I have to head - I'll have more of a think about this problem later...
08:44:03 <Guest24336> Hi
08:44:11 <Guest24336> Anybody here?
08:44:20 <Axman6> no
08:47:01 <confab> i think he took your seriously
09:16:53 <osfameron> aha!  it's scanl that I want!  (I think)
09:18:02 <byorgey> > scanl f z [a,b,c]
09:19:13 <kmc> where's lambdabot :/
09:19:22 <kmc> Cale, ?
09:20:36 * byorgey whines plaintively
09:21:02 <byorgey> osfameron: what are you trying to do?
09:21:12 <dainanaki> lambdabot is no Rick Astley.
09:22:13 <copumpkin> Cale: oi!
09:23:29 <luite> http://hpaste.org/51100 <- anyone know how to fix this?
09:24:17 <KirinDave> luite: Is it asking for Signal.h in /usr/include?
09:24:31 <KirinDave> err, signal.h
09:24:43 <KirinDave> luite: Because otherwise I'd say you're missing a file or something.
09:25:18 <luite> my /usr/include doesn't have a Signals.h
09:25:24 <KirinDave> Right
09:25:28 <KirinDave> It has signal.h
09:25:54 <luite> yes
09:26:15 <int-e> this one I suppose: <path to ghc-7.2.1>/lib/ghc-7.2.1/include/rts/Signals.h (possibly different version)
09:27:12 <luite> hmm, I've installed the 64 bit ghc, haven't changed or removed anything
09:27:15 <int-e> which should be installed by ghc. perhaps ghc-dev, if this is a distro package
09:27:41 <int-e> but I'm guessing.
09:27:51 <luite> no I just downloaded the binaries from haskell.org
09:28:36 <patricio_major> as i have understood it, haskell makes use of recurisive functions quite often. how does this affect the memory usage and execution speed?
09:28:49 <monochrom> does not affect at all
09:28:51 <KirinDave> So I am probably going to regret exposing myself as the haskell charlatan that I am...
09:28:53 <int-e> oh unix-2.3 seems rather old.
09:29:07 <KirinDave> But does anyone have any advice on how to make this code better? https://gist.github.com/b84dd568ed62e38ab763
09:29:27 <KirinDave> This takes a stream of output from iostat -x
09:29:30 <dainanaki> KirinDave: still working on your parser, eh?
09:29:32 <KirinDave> And creates a running average.
09:29:35 <KirinDave> dainanaki: I finished last night
09:29:40 <KirinDave> But I am not happy with the results.
09:29:46 <dainanaki> How so?
09:30:02 <luite> int-e: ah, hmm, you're right, some package must have outdated dependencies
09:30:05 <KirinDave> It's just long. And I feel like my "reduceNums" function must be awkward somehow.
09:30:30 <luite> unix-2.5.0.0 is already installed
09:30:32 <int-e> luite: yeah, I get the same build failure with 2.3.2.0
09:31:27 <kmc> patricio_major, that's an extremely vague question... a function calling itself is no more or less efficient than a function calling a different function
09:31:41 <dainanaki> KirinDave: I think it's reasonably elegant
09:32:12 <KirinDave> dainanaki: I think were I to do it again I'd just ditch the use of parsec, for sure.
09:32:14 <luite> int-e: oh it looks like an indirect dep of cabal-dev on an older Cabal
09:32:42 * hackagebot happstack-server 6.2.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-6.2.3 (JeremyShaw)
09:32:46 <dainanaki> KirinDave, you could probably clean up reduceNums by not using ZipList and just doing foldl' (zipWith (+))
09:33:07 <KirinDave> dainanaki: Hum, indeed so
09:33:26 <dainanaki> incidentally, you should always use foldl' instead of foldl
09:33:28 <luite> looks like it's already been fixed in the github repository
09:33:34 <luite> so I'll install that
09:33:57 <int-e> luite: wow. I mean cabal-dev is rather newer than unix-2.4 :)
09:35:05 <KirinDave> dainanaki: Ignoring the mass of import statements, that'd actually make it comparable in length to the ruby version.
09:35:20 <KirinDave> dainanaki: dropping the use of the parser would work too.
09:35:45 <patricio_major> kmc: you are right. but what is it then that sometimes makes recurisive functions calls memory consuming? Is it only when the first function call requires returned values from the calls deeper in the recursion?
09:35:49 <KirinDave> dainanaki: Ty.
09:36:16 <kmc> patricio_major, yeah, you're talking about tail recursion vs. not tail recursion?
09:36:19 <dainanaki> KirinDave: You're welcome. I forked your code and am tweaking it a bit now.
09:36:28 <kmc> things work differently in Haskell, because of laziness
09:36:53 <kmc> a non-tail-recursive function can be a lazy producer of, say, list elements
09:37:06 <kmc> and if it's composed with a lazy consumer, they will form a kind of co-routine and run in constant space
09:37:10 <KirinDave> I guess this is also not a bad time to ask...
09:37:25 <kmc> whereas a tail-recursive function can't be a lazy producer
09:37:28 <KirinDave> Recently someone admonished me for not realizing that "the real start of the show" in the MapReduce process is unfoldr.
09:37:34 <KirinDave> I'm still kinda trying to figure this out.
09:37:43 <KirinDave> Anyone know what they might have meant by that?
09:39:00 <patricio_major> ah interesting. how does for example Java deal with tail vs non-tail recursions?
09:39:11 <monochrom> it does not at all
09:39:22 <monochrom> at least all current implementations
09:39:30 <kmc> Java is screwed here.  languages like Closure which want to do tail-calls on the JVM need special hacks
09:39:49 <kmc> in general compilers can optimize tail calls (recursive or no) into jumps
09:39:58 <kmc> sometimes it's required by the language spec that you do this
09:40:14 <kmc> as in Scheme, which (like Haskell) uses recursion to implement looping primitives as library functions
09:40:30 <kmc> sometimes it's not required and is a best-effort optimization, like in GCC
09:42:21 <b_jonas> (but there are also some Scheme implementations that don't always keep that promise of the spec, though only in cases that aren't too relevant in practice, like with mutual recursion among two separately compiled modules involved)
09:46:37 <kmc> interesting
09:52:43 * hackagebot ixset 1.0.2 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/ixset-1.0.2 (JeremyShaw)
09:57:42 <dmoctezuma> is there an equivalent to 'show' for that return a IO String type?
09:57:50 <dmoctezuma> hShow seems to work only with files
09:57:53 <mauke> return . show
09:58:08 <dmoctezuma> ahh 'return' that's it
09:58:10 <dmoctezuma> thanks mauke
10:05:55 <maurer_> Is there really no way for me to just say to Cabal "I understand that my system will be on fire, but just ignore all upper bounds on packages for this particular ghc"
10:05:58 <maurer_> ?
10:07:43 * hackagebot cryptohash 0.7.2 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.2 (VincentHanquez)
10:08:10 <maurer_> Upper bounds are the worst :(
10:10:10 <hpaste> obiwahn pasted “simple eval” at http://hpaste.org/51101
10:11:02 <mauke> x is not a Float
10:12:26 <obiwahn_> eval1 returns Value Float
10:13:01 <mauke> correct
10:13:23 <obiwahn_> mmh i have to insert Result before x and y then it works but i do not really understand why
10:13:43 <mauke> no, the solution is to get rid of Value
10:13:49 <mauke> why does that thing exist at all?
10:14:42 <byorgey> obiwahn_: in  ... x = eval1 a,  what is the type of x?
10:15:27 <byorgey> oh, mauke already went over that.
10:15:37 <byorgey> well, you cannot divide two Value Floats.
10:15:47 <byorgey> however, you can divide to Floats.
10:15:52 <obiwahn_> i am not suer ihave hte feeling that i now confuse type and data constructors
10:16:26 <mauke> eval1 should be Term -> Float
10:16:31 <atomie> I'm the author of a package released on Hackage. How do I enable another person to be able to upload new versions of this package?
10:16:42 <byorgey> obiwahn_: quiz: Value is an (a) data constructor  (b) type constructor ?
10:16:47 <mauke> atomie: oh, that's not possible by default?
10:16:51 <obiwahn_> data
10:17:03 <mauke> nope.jpg
10:17:09 <atomie> mauke: I don't know, I haven't really tried. I assumed it's not possible by default.
10:17:12 <byorgey> atomie: in fact, you cannot stop them.
10:17:35 <byorgey> unfortunately, Hackage as of yet has no authentication for uploads at all.
10:17:44 <atomie> byorgey: This is a pleasant surprise then! :) Thanks.
10:18:16 <copumpkin> mokus: you should write an addition to that graham's number module in agda that computes the last n digits of graham's number, and prove it correct ;)
10:18:24 <byorgey> obiwahn_: no.  Value is a type constructor.  It constructs types.  If  a is a type, then  Value a  is also a type.
10:18:33 <copumpkin> then figure out an awesome method to compute the _first_ n digits of graham's number ;) ;)
10:19:31 <byorgey> the first two digits of Graham's number are 10
10:19:32 <monochrom> Hackage is "everyone belongs to everyone" a la Brave New World :)
10:19:36 <byorgey> in base Graham's number
10:19:41 <copumpkin> lol
10:19:49 <monochrom> also "every package is happy"
10:20:17 <erus`> If any of you guys work out you should try fitocracy; its awesome. Integrates with runkeeper too if you use that.
10:20:58 <monochrom> but is there a haskellocracy?
10:22:38 <Eduard_Munteanu> No, seriously, so anybody could upload anything on Hackage? :/
10:22:53 <Eduard_Munteanu> (like, replace a package covertly)
10:23:00 <copumpkin> yeah
10:23:04 <copumpkin> not covertly
10:23:22 <Eduard_Munteanu> Well, incrementing the version number and perhaps letting #haskell know
10:23:41 <Eduard_Munteanu> It's still pretty bad :(.
10:23:44 <obiwahn_> x = Result (eval1 a) does not work as well - i am so confused:(
10:24:25 <kmc> Eduard_Munteanu, i think this was fixed in the big Hackage 2.0 project which we're never, ever going to see the results of
10:25:08 <copumpkin> dcoutts: is there any news on that by the way?
10:26:23 <benmachine> I worked on it a bit at camhac
10:26:40 <benmachine> it looks like it's coming along nicely except that everyone who was working on it is doing other things atm
10:26:43 <benmachine> or something like that
10:26:46 <monochrom> I agree that the type Value (and therefore the data constructor Result) is completely unnecessary
10:27:17 <kmc> oh, it's good that people are still working on it
10:27:21 <benmachine> they were working on first making local (e.g. company-local) hackages work nicely before making the big switch
10:27:21 <kmc> i should be less sarcastic and bitter
10:27:27 <monochrom> is it so hard to conceive "eval1 :: Term -> Float" "eval (Con x) = x" etc instead?
10:27:40 <mauke> obiwahn_: have you tried removing Value?
10:27:55 <benmachine> kmc: :P it is kind of frustrating that it's not going faster
10:29:21 <benmachine> I seriously think hackage 2.0 is one of the most important haskell things around so it's a bit strange that more isn't happening to it
10:29:35 <monochrom> (yes, I know how to keep the Value-Result garbage and "fix" it. but I hate to. it is not a fix; it is piling more complications over dysfunctional complications)
10:30:45 <obiwahn_> mauke: yes/no i get it working that way and it seems easier but id like to undrstnad why need an extra Result when i want to keep Value for nicer printing or other reasons
10:31:24 <mauke> there are no other reasons
10:31:46 <mauke> for "nicer printing" you simply do putStrLn ("Result: " ++ show (eval1 t))
10:31:54 <monochrom> because eval1 blah gives you a return value of the form "Result <number here>" rather than just "<number here>"
10:32:33 <mokus> copumpkin: it seems like it'd be a lot harder to get the first n digits - the last n is relatively easy because it only depends on the lowest digits of the inputs, but the more significant digits will probably depend on all the less-significant ones
10:32:48 <monochrom> if you receive a "Result 0.1" and you want to extract the 0.1, well you have to do work
10:32:51 <copumpkin> mokus: yeah, just kidding about thte first digits :)
10:32:55 <Eduard_Munteanu> A newtype would be better anyway.
10:32:58 <copumpkin> you can compute the last ones easily with fast modular exponentiation
10:33:05 <copumpkin> but proving they're correct might be harder :)
10:33:07 <obiwahn_> mauke: yes/no - i get it working that way and it seems easier. But I'D like to understand why an extra Result is needed, when i want to keep Value for nicer printing or other reasons.  -- sorry my spelling becomes so bad when i am excited...
10:33:07 <mokus> copumpkin: sounds like a fun project though
10:33:37 <copumpkin> yeah
10:33:46 <copumpkin> even writing modular exponentiation is a bit of a pain
10:33:47 <mauke> obiwahn_: what
10:33:51 <copumpkin> especially if you want it to be efficient
10:35:19 <obiwahn_> monochrom: i got it - i think:)
10:40:39 <hpaste> “Mukesh Tiwari” pasted “Extract html link” at http://hpaste.org/51102
10:42:43 <obiwahn_> mauke: how would you handle an error like div by zero without an additional data type?
10:43:13 <mauke> it's not an error
10:43:45 <monochrom> depends on why I divide
10:43:51 <dainanaki> KirinDave: you still around?
10:43:59 <KirinDave> dainanaki: yes
10:44:29 <hpaste> “Mukesh Tiwari” annotated “Extract html link” with “Extract html link (annotation)” at http://hpaste.org/51102#a51103
10:44:53 <dainanaki> KirinDave: https://gist.github.com/caf52a69d4af42a3428a
10:44:53 <copumpkin> obiwahn_: require a proof that the parameter is not 0
10:45:10 <keep_learning> hello all
10:45:12 <mauke> preflex: seen Cale
10:45:12 <preflex>  Cale was last seen on #haskell 6 hours, 42 minutes and 43 seconds ago, saying: preflex: karma Cale
10:45:20 <KirinDave> dainanaki: Much shorter. :)
10:45:30 <keep_learning> This is my first time with tagsoup.
10:45:31 <dainanaki> KirinDave: I think it'll work, but I didn't have anything to test it on since OS X's version gives a different format of output
10:45:54 <keep_learning> how can i extract the url link from tag . http://hpaste.org/51102
10:46:07 <KirinDave> dainanaki: the least I can do is check for you
10:47:42 <KirinDave> dainanaki: https://gist.github.com/d3d2fd5a7765e7efb30d
10:47:48 <KirinDave> dainanaki: Run fails.
10:47:57 <dainanaki> Aw bummer
10:48:08 <KirinDave> dainanaki: I put up a short data cap
10:48:22 <dainanaki> Thanks, it's always fun to play with other people's code.
10:48:24 <KirinDave> dainanaki: Why Text?
10:48:33 <dainanaki> It's faster.
10:48:48 <dainanaki> And it worked out to be more concise for some reason
10:49:19 <KirinDave> dainanaki: Line 14 is cute. :)
10:49:27 <KirinDave> I gotta remember to fmap io objects more. It's cleaner
10:50:21 <KirinDave> dainanaki: Also I see you went to attoparsec. I think in general I like attoparsec more than parsec now, if only because the batteries it includes seem to come up more for me.
10:50:40 <kmc> attoparsec doesn't handle text, does it?
10:50:49 <dainanaki> there is a version which does.
10:51:01 <kmc> oh, cool.  i see
10:51:03 <dainanaki> namely, attoparsec-text
10:51:39 <kmc> does it handle non-BMP characters correctly?
10:51:53 <k0ral> is anyone working on a html5 combinator library ?
10:52:11 <dainanaki> kmc: no idea
10:53:32 <kmc> probably
10:53:45 <obiwahn_> uplicate instance declarations:  .. instance Show a => Show (Maybe a) -- Defined in GHC.Show is there a way to tell that my show should be ysed?
10:53:50 <obiwahn_> used
10:54:14 <monochrom> no
10:54:17 <kmc> no, why are you trying to redefine things from the standard library?
10:54:37 <trinithis_> @faq Can Haskell do your mom?
10:54:49 <monochrom> is dead
10:54:50 <kmc> womp womp
10:55:05 <obiwahn_> id like to have div by zero instead of nothing and Result: instead of just
10:55:08 <SamB_XP> preflex: seen lambdabot
10:55:08 <preflex>  lambdabot was last seen on #haskell 5 hours, 53 minutes and 2 seconds ago, saying: largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
10:55:08 <kmc> obiwahn_, write a new MyMaybe type and an instance for it
10:55:21 <obiwahn_> kmc: ok:)
10:55:22 <kmc> data Result = Finite Int | DivbyZero
10:55:31 <copumpkin> trinithis_: your mom "jokes" typically don't work well on IRC when you don't know people
10:55:49 <kmc> obiwahn_, in general you should create new types when you have a new concept like that
10:55:52 <trinithis_> That's fine. I wanted lambdabot to say "Yes! Haskell can do that!"
10:55:52 <Kaidelong> obiwahn_: You might also actually want an exception
10:56:05 <Kaidelong> there may be an exception to do just that
10:56:07 <kmc> you'll catch more errors and your code will be more readable
10:56:21 <copumpkin> don't forget to make a monad out of it
10:56:35 <copumpkin> and also, instead of catching the divisor of 0, just use spoon
10:56:37 <copumpkin> to catch the error
10:56:48 <kmc> and MonadPlus and Applicative and Traversable and... uh
10:56:50 <SamB_XP> preflex: hoogle spoon
10:56:53 <kmc> this ends up being kind of a pain
10:57:10 <kmc> the alternative is to newtype Maybe and GeneralizedNewtypeDeriving all those classes
10:57:12 <kmc> if you really need them all
10:57:21 <kmc> but i think the first solution is probably better here
10:57:59 <Kaidelong> well Show and Read aren't just to print things
10:58:13 <Kaidelong> you want
10:58:21 <Kaidelong> (read . show) === id
10:58:41 <kmc> usually
10:58:52 <kmc> i guess that's the other solution, obiwahn_
10:59:01 <copumpkin> > read . show $ mkStdGen 1
10:59:01 <kmc> showResult (Maybe x) = "Result: " ++ show x
10:59:05 <kmc> err
10:59:08 * ski likes when the string representation is valid Haskell source
10:59:09 <kmc> showResult (Just x) = "Result: " ++ show x
10:59:14 <Kaidelong> so you may want a different function, yeah
10:59:16 <kmc> showResult Nothing = "Divide by zero"
10:59:34 <kmc> functions returning String are not required to be named "show"
10:59:42 <Kaidelong> you generally want to derive Show and Read rather than implement them yourself
11:01:17 <monochrom> at the end of the day, Show is just for viewing stuff when you're testing in ghci, and Read is just for toy programs
11:03:25 <dainanaki> KirinDave: https://gist.github.com/6a43cc1a438e2e76b096#file_parserspiff.hs
11:03:36 <dainanaki> Turns out it was a small issue.
11:03:51 <KirinDave> dainanaki: Also you cleaned up some.
11:04:14 <dainanaki> Yeah, generally speaking it's best to keep the pure bits pure.
11:04:17 <SamB_XP> deriving Read and Show is more efficient, anyway
11:04:20 <dainanaki> It makes it longer but easier to test.
11:04:39 <kmc> is it SamB_XP?
11:04:50 <kmc> Show and Read are going to be very inefficient, anyway
11:04:54 <SamB_XP> well, Read especially
11:04:58 <monochrom> omg it's a SamB_XP!
11:05:00 <KirinDave> dainanaki: I had no idea you could use trace that way
11:05:07 <dainanaki> aw snap
11:05:11 <dainanaki> forgot to get rid of that
11:05:33 <monochrom> deriving (Show,Read) is certainly more efficient in programmer time
11:05:35 <dainanaki> you don't want that in production code naturally, but yeah.
11:05:38 <kmc> you can write your own Read instance using ReadP...
11:05:42 <kmc> you probably don't want to
11:05:46 <KirinDave> Hardly matters
11:05:59 <dainanaki> It's handy for debugging at times.
11:06:27 <KirinDave> I've used the version where you trace as you calculate something
11:06:28 <SamB_XP> but deriving Read uses ReadP automatically, does it not?
11:06:34 <kmc> yeah (in GHC)
11:06:48 <KirinDave> But never at the top of a where like that. Neat shape.
11:07:10 <kmc> yeah, you can use it on any expression
11:08:33 <KirinDave> I suspect if we stopped being stubborn about actually PARSING the lines
11:08:38 <KirinDave> And instead just used words
11:08:51 <KirinDave> But who thinks that is fun AMIRITE? ;)
11:09:05 <KirinDave> It is kinda nice to get to skip empty lines for free, too
11:09:12 <dainanaki> Yeah, you could code-golf it down more, but I think this is the more elegant solution.
11:10:18 <KirinDave> I do kinda miss that replicateM trick, but this is way easier to read.
11:10:57 <byorgey> anyone know what the state-of-the-art is in generating cross-package module links with Haddock?
11:12:24 <dainanaki> what do you mean by state of the art?
11:12:43 <kmc> with Cabal it Just Works
11:12:54 <kmc> cabal haddock --hyperlink-source
11:13:47 <SamB_XP> does that chase dependencies, too?
11:13:56 <dainanaki> yep
11:14:41 <dainanaki> alternatively, set Documentation: True in your ~/.cabal/config file
11:14:57 <dainanaki> and give it an index file locatio
11:15:01 <dainanaki> *location
11:15:32 <KirinDave> dainanaki: Thank you for your time, btw.
11:15:37 <KirinDave> dainanaki: Very interesting.
11:15:58 <dainanaki> Oh no problem. I love playing with parsers and cleaning Haskell code up.
11:18:46 <kmc> this is one feature i'm pimping in my Haskell talk
11:19:24 <kmc> many languages have html doc generators, but it's rarely the norm that all the docs for all your libraries get installed together and hyperlinked
11:19:51 <kmc> ...or maybe I'm just not cool enough to know how to make this happen for other languages
11:20:39 <byorgey> hmm, when I do  cabal haddock --hyperlink-source  in the directory of a package I'm working on, it does not correctly generate links for modules in other packages
11:20:49 <SamB_XP> no, it's just not normal
11:20:56 <byorgey> it generates a link as if the module were in the current package, which obviously does not work
11:21:34 <SamB_XP> odd
11:21:51 <byorgey> does it only work if you are installing the package to a package database, rather than just building the documentation locally?
11:22:03 <dainanaki> byorgey, you can use --html-location to specify where the other docs are
11:23:22 <hpaste> obiwahn pasted “simple eval -- next try” at http://hpaste.org/51104
11:23:34 <byorgey> oh, wait, I think I know why
11:24:03 <byorgey> when developing I do cabal install --disable-documentation, so the documentation for the package I was trying to link to was not there =P
11:25:43 <byorgey> hmm, it still does not work
11:27:19 <byorgey> cross-package links to functions work great, but cross-package *module* links do not
11:28:00 <byorgey> http://trac.haskell.org/haddock/ticket/13
11:30:49 <kmc> ah
11:30:54 <kmc> i understand now
11:32:22 <sbrg> I will silently toast to you, fellow haskellers, tonight!
11:33:44 <Clint> how silently
11:34:15 <dainanaki> ()
11:34:49 <dainanaki> Is lambdabot still crapped out, btw?
11:35:01 <dainanaki> > putStrLn "Hi, lambdabot!"
11:35:09 <tennisquest> :(
11:35:15 <engla> silent like lambdabot
11:35:44 <yitz> preflex: seen lambdabot
11:35:44 <preflex>  lambdabot was last seen on #haskell 6 hours, 33 minutes and 39 seconds ago, saying: largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
11:35:54 <dainanaki> lol
11:36:09 <yitz> preflex: seen cale
11:36:10 <preflex>  cale was last seen on #haskell 7 hours, 33 minutes and 42 seconds ago, saying: preflex: karma Cale
11:36:36 <byorgey> such a narcissist
11:37:13 <yitz> preflex: karma byorgey
11:37:13 <preflex>  byorgey: 74
11:37:23 <Clint> @pl head $ splitOn "..." $ head $ drop 1 (splitOn "--YAML--" x)
11:37:32 <Clint> dammit
11:37:34 <Clint> where's lambdabot
11:37:50 <byorgey> error: not in scope: x
11:38:02 <b_jonas> Clint: I think he got quit when some irc servers restarted
11:38:19 * Clint runs a local copy.
11:38:41 <byorgey> Clint:  head . splitOn "..." . head . drop 1 . splitOn "--YAML--"
11:38:49 <yitz> head . splitON "..." . head . drop 1 . splitOn "--YANL--"
11:38:57 <yitz> head . splitON "..." . head . drop 1 . splitOn "--YAML--"
11:39:16 <yitz> head . splitOn "..." . head . drop 1 . splitOn "--YAML--"
11:39:18 <yitz> there!
11:39:22 <byorgey> whew
11:39:25 <dainanaki> :/
11:39:25 <Clint> byorgey: thanks
11:39:28 <engla> why thrice
11:39:37 <yitz> engla: different bugs
11:39:41 <byorgey> Clint: you ought to thank yitz too, he worked harder ;)
11:39:54 <engla> yitz: oh, hard to spot
11:40:02 <yitz> engla: i guess i'm just not built to be a lambdabot
11:40:02 <Clint> byorgey: i could..
11:40:24 <engla> yitz: takes some time to get into it I guess. You'd do fine!
11:40:29 <byorgey> heh, lambdabot would be more fun if she occasionally inserted random errors =)
11:41:20 <dainanaki> Or insulted poor/lazy code.
11:41:31 <dainanaki> Not *that* kind of lazy.
11:43:57 <mux> http://2.bp.blogspot.com/-nPo8up-CfXc/TmjmkzfY5NI/AAAAAAAAA2o/UD2OM-M1kDI/s1600/haskell.jpg
11:44:01 <mux> this made ma laugh for some reason :-)
11:44:05 <jpcooper> how do I use runGet of Data.Binary.Get with strict ByteStrings?
11:44:33 <jpcooper> or just normal Data.ByteString.ByteStrings
11:45:09 <dainanaki> jpcooper: normal bytestrings *are* strict bytestrings
11:45:15 <elliott> cereal uses strict bytestrings
11:45:19 <elliott> and is otherwise like binary
11:45:37 <jpcooper> okay
11:45:43 <dainanaki> jpcooper: Data.ByteString.Lazy.fromChunks [strictBs]
11:46:13 <jpcooper> I'll just use cereal
11:46:26 <elliott> Why do you want strict bytestrings, out of curiosity?
11:46:41 * copumpkin cracks his whip
11:49:16 <jpcooper> elliott: they're returned by Network.Pcap
11:49:44 <elliott> jpcooper: alright. but like dainanaki said you could just wrap it :P
11:49:54 <elliott> I like cereal more though in genreal
11:49:57 <elliott> general
11:50:11 <jpcooper> does it make a big difference?
11:50:31 <yitz> copumpkin was caught in the act of switching nicks from pumpkin 10 minutes ago
11:50:37 <elliott> To what, performance?
11:50:40 <elliott> Probably not :)
11:50:40 <jpcooper> yes
11:50:50 <jpcooper> I'd like the fastest option
11:51:51 <elliott> Well, if anything cereal will be faster because it's doing strictly less, but ... it's probably going to be negligible if you're just wrapping and unwrapping lazy/strict. Premature optimisation and all that.
11:52:20 <jpcooper> okay
11:53:21 <dainanaki> jpcooper: what are you working on?
11:53:53 <jpcooper> taking a packet dump and parsing and printing it in a nice way
11:54:05 <dainanaki> haha, is it for a job opportunity?
11:54:18 <jpcooper> it may be for a specific job opportunity related to haskell, yes :)
11:54:26 <tgeeky> is anyone aware of a way of simply renaming (functions, type constructors, etc) from some arbitrary cabal package?
11:54:38 <tgeeky> like with systeem-fileio, just renaming every function it exports
11:54:50 <dainanaki> jpcooper: I had a lot of fun working on that project. best of luck.
11:55:06 <jpcooper> and you didn't get in? Should I give up now?
11:55:17 <tgeeky> Handle -> H, IOMode -> M, isFile -> file?, getSize -> size, etc
11:55:26 <jpcooper> regardless, I'm rather enjoying it as well
11:56:03 <dainanaki> jpcooper: they said they'd like to interview me closer to when I'd be available to move.
11:56:12 <jpcooper> oh very nice
11:56:17 <dainanaki> So I'm just working on beefing up my code portfolio now.
11:56:49 <keep_learning> Hello all
11:57:12 <keep_learning> i am trying to write haskell script to download pdf files from wiki.
11:57:48 <keep_learning> its generating the rendering url correctly but
11:58:10 <keep_learning> when i am trying to find the tag then its empty .
11:58:27 <keep_learning> http://hpaste.org/51105
11:59:14 <mmi> Hi, are there any build in functions to perform a SSSP search on a directed graph where each edge cost is 1 with a gives list of nodes and a function that determines whether there is an edge in between?
12:01:53 <trinithis> rm -rf /home/user/Programs/Mukesh_Tiwari/Haskell/
12:02:25 <byorgey> mmi: no, but you can use http://hackage.haskell.org/packages/archive/fgl/5.4.2.4/doc/html/Data-Graph-Inductive-Query-SP.html
12:02:46 <byorgey> mmi: it will be a tiny bit of work to turn the list of nodes and edge function into a graph data structure, but shouldn't be too hard
12:03:37 <mmi> byorgey: thank you, I just hoped for something more easy/elegant I just wasnt able to find
12:04:40 <byorgey> mmi: well, you might also be interested in http://r6.ca/blog/20110808T035622Z.html
12:05:11 <byorgey> unfortunately I don't think roconnor_ has packaged that up and put it on Hackage yet
12:05:31 <roconnor_> nor do I have plans
12:06:26 <roconnor_> what is SSSP search?
12:07:02 <tgeeky> single source, shortest path
12:07:37 <byorgey> roconnor_: are you against it on principle, or just can't be bothered?
12:08:07 * hackagebot dbus-core 0.9.2.1 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.9.2.1 (JohnMillikin)
12:08:36 <roconnor_> can't be bothered
12:08:48 <roconnor_>  / don't know how best to modularise this
12:09:41 <byorgey> fair enough
12:10:18 <dainanaki> woohoo
12:10:23 <roconnor_> mmi: what type of output are you expecting?
12:10:31 <dainanaki> Objective-C bindings are coming along a little bit.
12:13:22 <mmi> I'm actually searching a shortest path from one node to another.
12:14:06 <roconnor_> mmi: and a path is?
12:27:59 <dainanaki> question: If I make CString out of a String, will it still be unicode encoded?
12:28:56 <keep_learning> trinithis, Hi i did not get you .
12:29:04 <keep_learning> trinithis, rm -rf /home/user/Programs/Mukesh_Tiwari/Haskell
12:29:11 <kmc> dainanaki, er, Strings aren't unicode "encoded", in that they aren't in any particular encoding
12:29:20 <kmc> anyway i think the answer is "no"
12:29:24 <dainanaki> uh, yeah, that was poorly phrased
12:29:32 <trinithis> Lets just say I deleted your entire hdd
12:29:33 <dainanaki> sorry about that.
12:30:39 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Foreign-C-String.html#v:castCharToCChar "This function is only safe on the first 256 characters."
12:31:24 <kmc> if you want to send Unicode text to a C library that expects a particular Unicode encoding, I'd convert it to ByteString with an explicit "encode" function first
12:31:44 <kmc> if you want to send Unicode text to a C library that uses wchar, god help you
12:31:49 <kmc> (but i think you can do it)
12:31:56 <dainanaki> nope, don't wanna
12:32:03 <kmc> wchar is not guaranteed to be unicode correct, and it's often not
12:32:51 <dainanaki> That's fine, I'm just dealing with strings.
12:33:29 <dainanaki> I still haven't figured out how to register Haskell functions as Obj-C methods though.
12:33:36 <dainanaki> on an unrelated note.
12:34:27 <dainanaki> the varargs bit is killing me.
12:34:29 <b_jonas> dainanaki: could you just use C functions as an intermediate step?
12:35:14 <b_jonas> wait, you have an existing objective C method and want to make it visible to haskell? or is it the other way?
12:35:25 <dainanaki> the latter.
12:35:57 <dainanaki> however, the type of the function pointer has a varargs segment, which haskell functions don't do.
12:36:23 <dainanaki> unfortunately, the calling convention for varargs is different from normal functions.
12:36:33 <kmc> it is?
12:36:48 <kmc> well, C99 doesn't guarantee that it's the same
12:36:50 <kmc> or so i'm told
12:36:54 <kmc> but i thought it usually was the same, in practice
12:37:53 <dainanaki> No, at least it's not with x86_64.
12:37:58 <elliott> it is
12:38:55 <dmwit> dainanaki: Did you see http://stackoverflow.com/questions/5989457/haskell-ffi-support-for-functions-with-variadic-arguments ?
12:38:58 <elliott> consider that gcc can call any libc function without a full prototype on x86_64
12:39:42 <copumpkin_> elliott: :O
12:39:50 <kmc> http://blog.nelhage.com/2010/10/amd64-and-va_arg/
12:40:25 <copumpkin> elliott: how about functions that take or return floats?
12:40:50 <kmc> i don't get why va_arg madness was ever preferable to "fill out an array and pass a pointer to that"
12:40:57 <kmc> maybe there's a real efficiency concern, though
12:41:01 <dainanaki> seriously.
12:41:10 <elliott> "One could imagine simplifying the problem by stipulating a different calling convention for variadic functions, but unfortunately, for historical reasons and otherwise, C requires that code be able to call functions even if their prototype is not visible, which means the compiler doesn’t necessarily know if it’s calling a variadic function at any given call site."
12:41:13 <copumpkin> think how much of a pain printf would be
12:41:19 <elliott> there, now if i'm wrong blame that guy
12:41:22 <copumpkin> elliott: how about floats?
12:41:26 <copumpkin> or doubles
12:41:27 <elliott> dunno :P
12:41:38 <copumpkin> they get converted to ints
12:41:42 <copumpkin> so YOU'RE WRONG BITCH
12:41:44 <dmwit> printf("%d doesn't seem that hard %s", { &32, "copumpkin is so silly" });
12:41:48 <kmc> printf sucks anyway
12:41:48 <dmwit> thank goodness for void*
12:42:32 <leod> is that supposed to be C?
12:42:38 <dmwit> yes
12:42:39 * roconnor wonders why copumpkin's name changed colour
12:42:46 <copumpkin> roconnor: I lost my underscore
12:42:46 <dmwit> roconnor: he dropped an _
12:42:57 <dmwit> leod: Did you know you can initialize arrays with {} syntax? =)
12:43:05 <roconnor> nope, that isn't it
12:43:13 <leod> dmwit: yes, it's the &32 that is confusing me
12:43:15 <copumpkin> roconnor: well, I did get a color change operation
12:43:24 <dmwit> leod: 32 is a number on the stack, surprise
12:43:42 <byorgey> copumpkin is still orange for me
12:43:45 <dmwit> I could be wrong about that, actually.
12:43:46 <byorgey> which seems appropriate
12:43:54 <dmwit> But I don't think it's that common to pass constants to printf anyway.
12:43:57 <copumpkin> dmwit: I've never seen that before, but that doesn't mean anything
12:44:09 <leod> i've never seen someone take the address of an integer literal, heh
12:44:13 <roconnor> copumpkin: anything change in the last hour?  moved cities, moved computers?
12:44:21 <copumpkin> roconnor: I got disconnected a couple of times
12:44:34 <dmwit> gcc seems to complain, so I'm wrong
12:44:42 <roconnor> copumpkin: same computer as usual though?
12:44:46 <copumpkin> yep
12:44:54 <copumpkin> dmwit--
12:45:01 <copumpkin> dmwit++
12:45:05 <copumpkin> dmwit++--
12:45:12 <copumpkin> preflex: karma dmwit++
12:45:12 <preflex>  dmwit++: -1
12:45:12 <dmwit> ?karma dmwit++
12:45:17 <dainanaki> --dmwit++
12:45:17 <roconnor> copumpkin: You've been tan on my computer for months, and now, as of an hour ago, you are purple.
12:45:27 <dainanaki> oh heavens
12:45:31 <copumpkin> roconnor: your computer's losing its sense of color
12:45:36 <copumpkin> or colour
12:45:41 <copumpkin> you should fix your colour library
12:46:55 <roconnor> hmm
12:46:57 <byorgey> roconnor: perhaps it is your eyes that have changed
12:47:04 <roconnor> I haven't worked on my colour library for a while
12:47:11 <leod> perhaps it is your perception of colour that has changed
12:47:11 <copumpkin> needz moar colour
12:47:23 <roconnor> byorgey: I don't think so.  I can scroll back and see copumpkin's old colour.
12:47:50 <copumpkin> roconnor: the only answer lies in your IRC client's color-determination algorithm
12:48:00 <dmwit> Perhaps there is a bug in your IRC client that causes it to modify the RealWorld corresponding to how your eyes work.
12:48:02 <roconnor> aye
12:48:13 * copumpkin slaps dmwit 
12:48:26 <dainanaki> woobwoobwoob
12:48:32 <byorgey> roconnor: what would you do if you did work on your colour library?
12:49:20 <roconnor> I have no idea
12:49:26 <roconnor> it is perfect!
12:49:57 <dainanaki> needs more colours.
12:50:55 <roconnor> byorgey: how about I reexport every module under the same name but with the u dropped from colour?
12:51:29 <copumpkin> you should make a #define for that
12:51:32 <copumpkin> and then a cabal flag
12:51:39 <copumpkin> ;)
12:51:42 <roconnor> :O
12:51:47 <copumpkin> of course, you can't depend on flags
12:51:48 <byorgey> roconnor: hahaha
12:51:52 <copumpkin> so most people who depend on you would be screwed
12:52:27 <obiwahn_> how do i set the edior for ghci permanently?
12:52:30 <dmwit> Huh, cairo blends things incorrectly?
12:52:59 <dmwit> obiwahn_: ~/.ghci I think
12:53:07 <obiwahn_> cat "..." ~/.ghc/ ?!
12:53:09 <byorgey> cairo seems like a nice graphics engine... but WILL IT BLEND??
12:53:24 <roconnor> dmwit: depends on your point of view, but more or less it does not
12:53:28 <dmwit> echo :set editor whatever >> ~/.ghci
12:53:37 <b_jonas> roconnor++ :-) what if those modules export "grey" or "gray"?
12:53:57 <roconnor> b_jonas: ya, I was thinking of that
12:54:16 <obiwahn_> jep:)
12:54:54 <byorgey> for the record, it exports both
12:55:10 <b_jonas> sure, they often do that
12:55:37 <roconnor> byorgey: we will change is so Data.Color.Names exports gray and Data.Colour.Names exports grey
12:55:46 <byorgey> hehehe, I see
12:55:54 <b_jonas> could you just define a module that reexports it?
12:56:06 <roconnor> b_jonas: that's my original proposal
12:56:13 <dmwit> Even Americans use both spellings interchangeably.
12:56:29 <b_jonas> roconnor: no way. think of people like me who don't use either of American or British spellings consistently
12:56:35 <dmwit> exactly
12:56:39 <b_jonas> just use whichever I'm used to for each individual word
12:56:45 <roconnor> b_jonas: I think you can import both modules
12:56:58 <b_jonas> though I at least want to be consistent with the same word within one document
12:57:03 <roconnor> b_jonas: I don't think reexported functions collide
12:57:09 <roconnor> I'm not sure though
12:57:13 <byorgey> no, they don't
12:57:21 <b_jonas> I had to change color to colour (or the other way, I don't remember) in an article because the co-author used the other word.
12:57:22 <osaunders> I try to use all American spelling most of the time but I’m British
12:57:45 <b_jonas> I always use "favourite" for example, which is Brit
12:57:55 <dmwit> You could use Dewey spelling for everything...
12:58:21 <osaunders> dmwit: What’s that?
12:59:15 <dmwit> http://en.wikipedia.org/wiki/Melvil_Dewey#Lake_Placid_Club_and_spelling_reform
13:03:07 * hackagebot deepseq-th 0.1.0.1 - Template Haskell based deriver for optimised NFData instances  http://hackage.haskell.org/package/deepseq-th-0.1.0.1 (HerbertValerioRiedel)
13:03:53 <roconnor> dmwit: nys
13:13:07 * hackagebot deepseq-th 0.1.0.2 - Template Haskell based deriver for optimised NFData instances  http://hackage.haskell.org/package/deepseq-th-0.1.0.2 (HerbertValerioRiedel)
13:15:27 <jgroszko> anybody using hsmagick these days? keep getting malloc/free type errors with it :/
13:20:03 <mdwright_laptop> I'm reading in a binary file and unpacking it to a list of Word8s. Since I know that the instruction set has 16 bit wide instructions, I'd like to convert the array to Word16s and work with those. Is there a function that takes a pair of Word8s and converts to a Word16 or something?
13:20:15 <mdwright_laptop> Hoogle suggests no, but I'm wondering if it might be more general than I'm searching for
13:22:50 <byorgey> mdwright_laptop: something like \x y -> shift (fromIntegral x) 8 + fromIntegral y  ought to work, I think?
13:23:21 <originaldemo> #linuxcnc
13:23:35 <originaldemo_> hey
13:23:42 <byorgey> hi originaldemo_
13:23:49 <originaldemo_> whats up?
13:23:59 <byorgey> originaldemo_: writing some documentation, you?
13:24:11 <originaldemo_> in class
13:40:33 <mdwright_laptop> byorgey: works perfectly. thanks!
13:40:49 <byorgey> mdwright_laptop: great! you're welcome
13:47:34 <hpaste> ian___ pasted “Any way to write this more simply?” at http://hpaste.org/51108
13:50:04 <byorgey> ian___: zipWith3 (\b x y -> if b then x else y)
13:56:55 <hpaste> ian___ pasted “Any way to write this more simply?” at http://hpaste.org/51109
13:58:30 <applicative> zipWith3 is out of fashion, use ParallelListComp ian
13:58:37 <monochrom> haha
13:58:54 <applicative> takeFrom bs xs ys = [if b then x else y | b <- bs | x <- xs | y <- ys]
13:59:33 <ian___> !recap
13:59:39 <ian___> damn internet
14:00:04 * applicative recommended takeFrom bs xs ys = [if b then x else y | b <- bs | x <- xs | y <- ys]
14:00:29 <applicative> which uses {-#LANGUAGE ParallelListComp#-}
14:02:03 <applicative> zipWith3, as byorgey said, is the natural answer.
14:02:45 <roconnor> [17:38] <byorgey> ian___: zipWith3 (\b x y -> if b then x else y)
14:03:31 <applicative> ian___: Your definition is missing a few cases, what if you run out of xs or ys but the bools keep coming. Or am I wrong
14:03:44 <ian___> yeah
14:05:00 <originaldemo_> hey
14:05:05 <originaldemo_> whats going on guys?
14:05:15 <originaldemo_> anyone from ny?
14:05:21 <applicative> the zip functions, zipWith zipWith17 all stop when one of the lists stop; likewise with ParallelListComp
14:05:50 <trinithis> In Parsec, is there something like (x <|> y) except that y is only tried when x fails AND x does not consume any input?
14:06:48 <trinithis> wait nvm
14:07:03 <trinithis> that would be (<|>) as is...
14:07:23 <originaldemo_> ?
14:07:57 <ion> What does the v in nvm stand for?
14:08:04 <monochrom> "ver"
14:08:17 <ion> I’m ver-y thirsty.
14:08:18 <originaldemo_> va
14:08:31 <zzo38> Why does it accept type families in a constraint of a instance declaration but seems not working?
14:09:05 <originaldemo_> trinithis where r u from?
14:09:52 <monochrom> don't you think that's a bit too personal?
14:10:36 <zzo38> Do you know what is going wrong? Did I do something wrong?
14:11:14 <applicative> monochrom, what's personal about zzo38's type family
14:12:33 <rwbarton> zzo38: I suggest rephrasing your question in the form of an hpaste with the offending code and the compiler error
14:12:37 <monochrom> dunno. perhaps it turns out to be the corleone type family? then you will regret asking :)
14:13:49 <zzo38> type instance Subt t (Succ u) = Subt (Pred t) u; instance DoesNotDivide t (Subt u t) => DoesNotDivide t u;
14:14:17 <zzo38> The error is "No instance for (GreaterThan Zero (Succ Zero))". Compiling this code works but then when I try to use it in GHCi by using :type this is the error I get.
14:14:34 <rwbarton> um
14:15:09 <rwbarton> I highly doubt the compiler made up the name "GreaterThan" based on that line of code
14:15:40 <monochrom> the complete code is 2014 lines long. no one wants to paste it. no one wants to read it if pasted
14:16:24 <zzo38> rwbarton: Yes it is true. I also wrote the class for GreaterThan.
14:16:42 <zzo38> class GreaterThan t u; instance GreaterThan (Succ Zero) Zero; instance GreaterThan t u => GreaterThan (Succ t) u; instance GreaterThan t u => GreaterThan (Succ t) (Succ u);
14:17:05 <zzo38> So what is wrong now?
14:17:27 <rwbarton> what's wrong now is you still haven't hpasted the offending code
14:17:34 <zzo38> I did paste the code.
14:17:37 <hpaste> applicative annotated “Any way to write this more simply?” with “Any way to write this more simply? (annotation)” at http://hpaste.org/51109#a51110
14:18:19 <zzo38> OK here is the entire code:   http://sprunge.us/dREf
14:19:07 <trinithis> Can you quiet a parsec error message? This is to simplify a "expecting X or Y" where I know either X or Y covers the other.
14:19:10 <applicative> ian___: ^^^ I pasted the standard library version of zipWith3. It's the same idea as the one you use, but they solve the cases in an obvious elegant way
14:19:30 <zzo38> Now do you know what wrong with this code?
14:19:43 <trinithis> :r
14:19:50 <applicative> yes, too many language pragmas
14:20:02 <rwbarton> zzo38: it looks like you are expecting instance resolution to backtrack when the contexts cannot be satisfied, which it does not
14:20:47 <zzo38> rwbarton: OK. Then how does it do properly?
14:21:04 <rwbarton> for example instead of instance GreaterThan t u => GreaterThan (Succ t) u you want instance GreaterThan (Succ t) Zero
14:21:30 <monochrom> trinithis: you can change parsec error messages by <?> and other provisions. I can't say more because I don't use them enough
14:21:30 <rwbarton> btw get rid of OverlappingInstances
14:21:45 <trinithis> mm
14:22:12 <rwbarton> perhaps that one will work due to OverlappingInstances
14:22:16 <zzo38> rwbarton: OK, but that doesn't help.
14:22:22 <rwbarton> btw you still haven't said what you are taking :type of
14:22:39 <rwbarton> so you haven't really shown the code
14:22:58 <bfig> i'm having trouble understanding the state monad, any good site i should check?
14:23:43 <zzo38> Type of is:  :type undefined :: DoesNotDivide (Succ (Succ Zero)) (Succ (Succ (Succ Zero))) => Zero
14:23:44 <roconnor> bfig: if it helps it's full name is "state-transformer monad"
14:24:03 <rwbarton> ok
14:24:18 <rwbarton> instance GreaterThan t u => DoesNotDivide (Succ t) (Succ u) -- this matches anything of the form DoesNotDivide (Succ _) (Succ _)
14:24:21 <applicative> it would actually help if the standard libraries included a just plain State type
14:24:21 <dmwit> bfig: http://scienceblogs.com/goodmath/2007/01/more_monads_stateful_programmi_1.php
14:24:36 <bfig> roconnor, dmwit thanks :)
14:24:39 <roconnor> @quote spoon
14:25:08 <dmwit> no \bot
14:25:09 <zzo38> rwbarton: It doesn't seem to match anything, when I try it.
14:25:30 <rwbarton> so in particular it matches DoesNotDivide (Succ (Succ Zero)) (Succ (Succ (Succ Zero))), and gives you a GreaterThan (Succ Zero) (Succ (Succ Zero)) context
14:25:39 <rwbarton> which fails for obvious reasons (1 is not greater than 2)
14:25:43 <rwbarton> with the error you see
14:25:53 <zzo38> But that context doesn't match. So why doesn't it try the other one?
14:25:55 <applicative> bfig there is an amusing very simple State + IO example, of an irc bot on the haskell wiki, if that's to your taste.  someone was making a pleasant version the other day.
14:26:03 <rwbarton> < rwbarton> zzo38: it looks like you are expecting instance resolution to backtrack when the contexts cannot be satisfied, which it does not
14:26:21 <zzo38> Why doesn't it?
14:26:23 <monochrom> it never tries "the other one"
14:26:28 <bfig> applicative, gonna check that too =)
14:26:42 <zzo38> Why is it designed not to try the other one?
14:26:56 <rwbarton> it seems that it would lead to incoherent instance selection
14:26:57 <applicative> http://hpaste.org/51068  --original http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:27:12 <rwbarton> or maybe it's just part of the design of the system
14:27:43 <zzo38> O, do I need -XIncoherentInstance?
14:28:03 <rwbarton> no
14:28:15 <rwbarton> you need to fix your "program" to not rely on this kind of backtracking
14:28:38 <monochrom> because it does not want you to do this kind of type-level programming
14:28:57 <ashp> my brain upon reading any single haskell thing on learnyouahaskell: fffffff
14:29:07 <ashp> i can barely put together a shell script, I don't know why I thought this would be a good idea
14:29:14 <shachaf> ashp: It's a good idea.
14:29:29 <ashp> shachaf: It's actually making a little bit of sense, as long as I take it slowly.
14:29:30 <shachaf> Just don't act like it's a shell script.
14:29:38 <Eduard_Munteanu> ashp: some say it's easier if you don't have a background in other languages... easier to unlearn some habits and thought processes.
14:29:42 <shachaf> > nubBy(((>1).).gcd)[2..] -- See, easy.
14:29:45 <monochrom> when I learned pascal, I could barely put together a shell script either. I don't think it matters
14:29:49 <ashp> shachaf: This might just be because I'm literally too dumb for imperative programming but it seems like it makes _more_ sense
14:29:52 <shachaf> Aw, no lambdabot.
14:30:22 <shachaf> ashp: In several ways it's simpler than imperative programming.
14:31:25 <ashp> because as soon as regular languages stray from simple if/else/then I get confused and discouraged, whereas I am beginning to make sense of how to put things together by telling it what it is rather than how to get there
14:31:29 <drdo> ashp: everyone is too dumb for imperative programming, otherwise no one would bother and would be happy just programming register machines
14:31:34 <ormaaj> Who needs haskell, you have shell scripts.
14:31:44 <parcs> @hoogle gcd
14:31:47 <ormaaj> scanl () if [[ -n ${3+_} ]]; then printf '%d ' "$(${@:1:3})" $(scanl "${1}" "${@:3}"); fi;
14:31:50 <ormaaj> etc
14:32:13 <shachaf> ashp: Will you get mad if you find out that Haskell's "if" keyword requires an "else" clause?
14:32:16 <parcs> is there a library that implements common functions on numbers like gcd
14:32:17 <ashp> I managed to write tail' and have it work for the first of the haskell problems and last time I tried this I couldn't even begin to see how to do that.  I should retire, successful. :D
14:32:22 * shachaf knows someone who got really annoyed at that.
14:32:24 <monochrom> haha, but why printf there instead of just returning a value
14:32:24 <drdo> ashp: http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/
14:32:29 <ashp> shachaf: Haha, no.  That makes sense to me.
14:32:30 <drdo> I strongly recommend these
14:32:39 <ashp> drdo: Will take a look, thanks!
14:32:48 <zzo38> Yes, it is true, -XIncoherentInstances doesn't make it work.
14:33:08 <ashp> Mostly what lets me down when I try to get my head around haskell is my lack of any math background so terminology can throw me.  (Like trying to grasp curried functions, I'm still trying to get to grips with that)
14:33:33 <shachaf> ashp: "curried functions" is a bit of a misnomer, maybe.
14:34:01 <ormaaj> ashp: You can curry functions in just about any language. Pretty basic concept.
14:34:17 <shachaf> ormaaj: It's not very easy without closures. :-)
14:34:18 <ashp> shachaf: I just mean how functions only take one argument and how that actually works in practice, because this was a new concept to me.
14:34:21 <monochrom> I became annoyed that some languages let you write "if" without "else", actually. sure sure, it's a shorthand. but in my view, in order to reason about "if-then", you always have to put back the "else nop" first. a shorthand that doesn't survive reasoning is a useless shorthand
14:34:21 <ormaaj> It's more obvious in other languages
14:34:42 <applicative> ormaaj, can you define the curry and uncurry functions in most languages?
14:34:56 <shachaf> ashp: Does it make sense that "f a b" means "((f a) b)"?
14:35:22 <parcs> if in other languages is like haskell's when/unless
14:35:31 <ashp> shachaf: It does in an abstract way, I'm just trying to understand how the language evaluates (f a) and then passes b into it
14:35:34 <drdo> applicative: You certainly can in most reasonable languages
14:35:35 <ormaaj> Especially like python where you have parens for function application. (lambda x: lambda y: stuff)(x)(y)
14:35:41 <shachaf> ashp: If you have add = \x -> (\y -> x + y), then (add 5) = (\y -> 5 + y)
14:35:49 * applicative wonders how many reasonable languages there are
14:35:53 <shachaf> (Are you familiar with the \ lambda syntax?)
14:36:09 <ashp> no, I don't know a thing about lambda, another of the million things I need to figure out
14:36:25 <dmwit> ashp: It makes a closure. What shachaf said is sort of true, except it's more like if add = \x -> \y -> x + y, then add 5 = let x = 5 in \y -> x + y
14:36:27 <ashp> my math knowledge is limited to adding numbers together and vague memories of algabra
14:36:46 <shachaf> dmwit: I was trying to simplify it by substitution. :-)
14:36:47 <incluye> f a returns a function that returns a result when you pass it to b
14:36:49 <applicative> lambdas are a distraction, you are writing definitions:  square n = n * n
14:36:58 <drdo> ashp: i seriously recommend you go watch the SICP lectures and/or read the book, it's really good
14:36:59 <ormaaj> applicative: You pretty much always can, though it becomes impractical without first-class functions.
14:37:06 <erus`> information overload :D
14:37:17 <ashp> drdo: I'l watch the lectures definitely, I commute for ~4 hours a day, so plenty of time for that.
14:37:36 <drdo> outch and i thought i had it bad
14:37:41 <drdo> i commute for around 3
14:37:45 <ashp> bbl, back to baby functions and meddling with ghci
14:38:46 <drdo> ashp: Don't be discouraged though, even though most things are quite simple it takes quite a bit of practice and thinking to get a good intuition
14:39:40 <ashp> If I got discouraged easily I wouldn't be the sysadmin I am today (because I'm bad at things, you see, but I keep chugging)
14:40:49 <mike-burns> And you don't need to know much actual math to do programming, despite what it seems.
14:41:34 <obiwahn_> is there somewhere a collection of small haskell programs like echo server file parser etc where i can see how libs are used and io is handled when not using ghci
14:41:47 <monochrom> you need logic. some people consider that math; some people don't
14:42:30 <incluye> hehehe, schönfinkeling
14:42:30 <obiwahn_> ls
14:42:57 <parcs> is there a concurrent abstraction that's essentially a Chan (Query, MVar Result) where query :: Chan (Query, MVar Result) -> Query -> IO Result ?
14:42:59 <mike-burns> obiwahn_: http://goo.gl/Zpk5p - here are a bunch of programs to consider.
14:43:07 <shachaf> incluye: The Little Schemer?
14:43:46 <incluye> schroedinbug: wikipedia
14:44:07 <shachaf> Ah.
14:51:18 <ian___> why isn't there an if function
14:51:34 <ian___> i could do "zipWith3 if" instead of "zipWith3 (\a b c -> if a then b else c) "
14:51:59 <ski> some people define an `if_' function
14:53:49 * roconnor considers all of math a form of programming.
14:54:07 <roconnor> a degenerate form of programming :)
14:54:17 <ion> either :: (a → c) → (b → c) → Either a b → c
14:54:18 * monochrom too
14:54:31 <ion> maybe :: b → (a → b) → Maybe a → b
14:54:43 <ion> bool :: a → a → Bool → a  -- Would make sense
14:54:50 <ski> *nod*
14:54:52 <roconnor> unit :: b -> () -> b
14:54:56 <ion> hehe
14:55:03 <ski>   void :: Void -> a
14:55:24 <mike-burns> http://www.haskell.org/haskellwiki/If-then-else - there's some stuff about this here already.
14:55:34 <ski>   uncurry :: (a -> b -> c) -> ((a,b) -> c)
14:57:11 <roconnor> foldr :: (a -> b -> b) -> b -> [a] -> b
15:00:24 <b_jonas> list :: b -> (a -> [a] -> b) -> [a] -> b
15:00:35 <roconnor> b_jonas: nope
15:01:03 <roconnor> b_jonas: what you are looking for is foldr (flip foldr would also be acceptable)
15:01:45 <roconnor> bilinearMap :: (a -o b -o c) -> (a ⊗ b) -o c
15:01:49 <b_jonas> (though in all these cases I'd prefer to put the algebraic type as the first argument, but that's opposed by the precedent (maybe) and (either) makes)
15:01:57 <mike-burns> The ability to define things in terms of foldr doesn't mean they shouldn't have names.
15:02:45 <b_jonas> (well, actually both ways make sense)
15:03:07 * hackagebot bson 0.1.5 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1.5 (TonyHannan)
15:03:08 <b_jonas> (the way maybe works is certainly more practical for pointfree programming)
15:03:14 <ski>   (Endo .) . flip . foldr . (appEndo .) :: (a -> Endo b) -> ([a] -> Endo b)
15:04:07 <ski> (b_jonas : putting the scrutinee argument first is nicer for yoneda, yes)
15:05:17 <b_jonas> (ski: the reason I'm thinking is that they should be a function that takes an algebraic type and returns the corresponding church-encoded value.)
15:05:40 <ski>   build :: (forall o. (a -> o -> o) -> o -> o) -> [a]
15:05:57 <ski>   foldr' :: [a] -> (forall o. (a -> o -> o) -> o -> o)
15:06:28 <b_jonas> I don't get that. what's build?
15:06:39 <ski> @index build
15:06:47 <ski>   GHC.Exts
15:07:09 <ski> it's used for `foldr'-`build'-fusion, in GHC
15:07:54 <ski> expressions like `foldr cons nil (build (\cons nil -> e))' are relaced by `e', thereby eliminating the intermediate datastructure
15:08:23 <ski> so operations like `map' which produces lists can often be written to use `build'
15:08:46 <b_jonas> oh, I see
15:09:32 <b_jonas> nice
15:10:22 <ski> so something like `map f as0 = build (loop as0) where loop [    ] cons nil = nil; loop (a:as) cons nil = cons (f a) (loop as cons nil)'
15:11:17 <b_jonas> ski: right
15:12:51 <ski> <http://blog.sigfpe.com/2006/11/yoneda-lemma.html> has some related info
15:18:07 * hackagebot mongoDB 1.1.0 - Driver (client) for MongoDB, a free, scalable, fast, document DBMS  http://hackage.haskell.org/package/mongoDB-1.1.0 (TonyHannan)
15:36:08 <iwtu> Hi guys! Probably it's trivial but I can't see right know. Maybe is too late for me but I need it. Can you see what's wrong? http://codepad.org/5wRsvEE0
15:36:18 <insane> hi, is it possible to get the current hour from System.Time.ClockTime instance?
15:37:55 <benmachine> iwtu: the error message describes it pretty well; you're matching a list against a Just pattern
15:38:24 <benmachine> but Just a is type Maybe a
15:38:28 <benmachine> i.e. not a list
15:38:58 <benmachine> I'm not sure what the fix is without knowing more about your code
15:39:42 <iwtu> benmachine: but a should be [String] ..
15:39:49 <benmachine> iwtu: why?
15:40:42 <iwtu> nouput :: Node -> Set String
15:40:52 <iwtu> *noutput
15:41:15 <iwtu> and S.elems make a list
15:41:37 <benmachine> ok so you're pattern matching against a thing of type [String]
15:41:51 <benmachine> so where does Just come into it?
15:42:07 <iwtu> :D
15:42:13 <iwtu> too late for me :D
15:42:15 <iwtu> lol
15:43:38 <hpaste> Куклотюня pasted “RegexValidator ” at http://hpaste.org/51112
15:43:38 <iwtu> benmachine: I am sorry. .. better go to sleep :)
15:44:02 <benmachine> :P
15:44:05 <benmachine> sleep well
15:44:24 <iwtu> benmachine: thanks man :) you too
15:56:05 <iwtu> benmachine: I've got (129,1)-(134,24): Non-exhaustive patterns in function Main.algorithm
15:56:15 <iwtu> any silly bug?
15:56:25 <iwtu> *next
15:57:11 <benmachine> iwtu: uh, you've changed that since the paste, so I dunno
15:57:15 <benmachine> oh
15:57:24 <benmachine> have you catered for the string being empty?
15:57:47 <iwtu> for [String]
15:58:04 <benmachine> hm?
15:58:15 <iwtu> I've just removed Just :)
15:58:20 <benmachine> oh right
15:58:31 <iwtu> Set.elems returns array
15:58:33 <byorgey> iwtu: that error message is pretty good too. "Non-exhaustive patterns" means there is some case you did not pattern match against
15:58:39 <benmachine> you need a clause for what happens if the third argument is empty
15:58:46 <benmachine> of 'algorithms'
15:58:55 <benmachine> algorithms step state (x:xs) <-- that one
15:59:32 <iwtu> I am embarhed ...
15:59:42 <iwtu> embarashed of somehow
16:03:06 <HugoDaniel> localhost :)
16:03:21 <kmc> iwtu, Set.elems doesn't return an array; it returns a list
16:04:46 <iwtu> kmc I am sorry.
16:05:13 <iwtu> benmachine: thanks . It seems to be working. What is your local time?
16:05:14 <mmos1127> how do you write a functon that takes a variable number of arguments?
16:05:15 <benmachine> iwtu: you needn't apologise so much
16:05:19 <benmachine> also, nearly 1am
16:05:23 <benmachine> but I'm on holiday
16:05:26 <benmachine> and also sitting on my bed
16:05:31 <iwtu> :D
16:05:45 <iwtu> you must love the haskell :)
16:06:10 <kmc> mmos1127, you can't really
16:06:16 <iwtu> or be very bored on holiday. How long is your holiday?
16:06:21 <mmos1127> how does printf work then?
16:06:22 <kmc> mmos1127, consider writing a function that takes a list, instead
16:06:41 <mike-burns> I hate using printf in Haskell. Just take a list.
16:06:47 <kmc> mmos1127, it's typeclass-overloaded
16:07:04 <kmc> it's a family of functions, one for each type
16:07:07 <kmc> and it's kind of a mess
16:07:09 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/Text-Printf.html
16:07:12 <benmachine> iwtu: until october, ish
16:07:20 <kmc> printf is really not the right abstraction in haskell
16:07:37 <benmachine> also, both :)
16:08:00 <iwtu> benmachine: if it is quick. can you tell me how can pass error in main if the program doen't have exactly one argument?
16:08:19 <benmachine> iwtu: pass error?
16:08:21 <mmos1127> kmc: here's the issue.. I  have an interface to a system that takes arguments in the normal command-line style. I could write a haskell program that reads its arguments, BUT the problem is that I think it has to be compiled and can't be interpreted. Is that true?
16:08:27 <benmachine> well ok there's crude ways and there's good ways
16:08:39 <iwtu> nice and quick :P
16:08:51 <benmachine> replace file <- getArgs
16:08:55 <benmachine> with [file] <- getArgs
16:08:56 <mmos1127> kmc: that is, a haskell program one runs from the cmd line has to be a compiled program
16:09:05 <benmachine> that will throw an IO exception with a possibly silly message
16:09:14 <benmachine> when you have other-than-one argument
16:09:40 <mike-burns> mmos1127: Does it matter whether it's compiled?
16:09:49 <mike-burns> mmos1127: You can use runhaskell as the #! if you'd like.
16:09:49 <iwtu> can it throw an exception with my message?
16:10:13 <mmos1127> mike-burns: exactly, I'm getting to that... this program is under development and the quick modification-run-test cycle of the interpreter is nice.
16:10:18 <benmachine> iwtu: sure, just takes a bit more doing
16:10:23 <benmachine> one sec
16:10:28 <mike-burns> mmos1127: And what does getArgs have to do with functions taking a variable number of arguments?
16:10:38 <iwtu> benmachine: I love your holiday :D
16:10:39 <kmc> you should specify formats with a set of typed combinators, not with a completely opaque string
16:10:40 <kmc> @quote stark
16:10:40 <kmc> lambdabot noooooo
16:10:40 <kmc> it would be a bit more verbose, but someone could then write a Template Haskell quasi-quoter for it
16:10:44 <kmc> yeah, i don't see why compiled vs interpreted matters
16:10:44 <benmachine> (by a bit more doing, I mean, "more than two characters added" :P)
16:10:46 <mike-burns> mmos1127: Sure, pass it through runhaskell if you'd like.
16:11:02 <kmc> if you want to run haskell code from the command line using GHCi's bytecode interpreter, use runhaskell
16:11:07 <mmos1127> mike-burns: it would be one way to simulate a traditional cmd-line interface but at the ghci prompt. what does runhaskll do?
16:11:11 <kmc> that has nothing to do with variadic functions
16:11:24 <kmc> if you want to run system commands from ghci you can use :!
16:11:37 <iwtu> benmachine: Hope souce code looks ok. It's my first Haskell's program
16:11:40 <mike-burns> mmos1127: runhaskell is the Haskell compiler that acts like what you think an interpreter acts like.
16:12:04 <kmc> there's also ghc -e
16:12:07 <mmos1127> kmc: not system commands. a program I write that has a cmd-line interface in the traditional style
16:12:12 <kmc> ghc -e 'print (2+2)'
16:12:14 <mike-burns> Yeah, use getArgs.
16:12:18 <hpaste> benmachine pasted “error checking” at http://hpaste.org/51116
16:12:22 <benmachine> iwtu: ^
16:12:30 <mike-burns> This has nothing to do with functions taking variable numbers of arguments.
16:12:39 <mmos1127> okay, so use getArgs and use runHaskell or ghc -e?
16:12:44 <mike-burns> Right.
16:13:29 <iwtu> benmachine: oh no! :D
16:13:33 <mike-burns> mmos1127: http://goo.gl/Igxqk - here are a ton of examples.
16:13:40 <iwtu> funny night
16:13:46 <mike-burns> (Amusingly, that's the second time today I've pasted that link.)
16:14:05 <mmos1127> okay, I think the important thing here for me, or the thing I most like, is that I can interpret a program while providing it with arguments (getArgs)
16:14:06 <kmc> haha
16:14:09 <kmc> that's a cool way to find examples
16:14:19 <kmc> mmos1127, compiled versus interpreted really does not matter
16:14:26 <kmc> what if it compiled it behind the scenes, and then ran the compiled binary
16:14:34 <kmc> it would still work the same way
16:14:42 <kmc> a haskell implementation is allowed to implement runhaskell this way
16:15:01 <kmc> i wonder what ghc does on platforms without ghci
16:15:12 <mike-burns> ghc cries alone at night without ghci.
16:17:34 <mike-burns> For command line tools I like to use the cmdargs package, though. It does a little more work for me.
16:18:32 <iwtu> benmachine: how the souce code look like?
16:18:43 <benmachine> iwtu: source code to what
16:18:44 <benmachine> oh
16:18:48 <benmachine> you mean in general?
16:18:56 <iwtu> yes
16:19:16 <iwtu> my first program. I dunno how ..
16:33:07 <shachaf> @get-Cale
16:33:09 <shachaf> Cale!!
16:34:52 <Eduard_Munteanu> @bot
16:36:52 <siracusa> she seems to be away for hours
16:37:59 <azaq23> So the people above were right, she went shopping
16:44:29 <iwtu> benmachine: last words? :)
16:45:25 <benmachine> iwtu: something came up, sry :P
16:47:55 <iwtu> benmachine: maybe holiday? :P
16:49:00 <benmachine> iwtu: if you try putting it on hpaste.org, hlint will have plenty of suggestions for you, I am sure
16:49:07 <benmachine> also, compile with -Wall and pay attention to them
16:50:21 <iwtu> benmachine: thanks! have a nice holiday :)
16:50:29 <benmachine> :)
16:50:34 <benmachine> have a nice whatever it is that you have
16:50:50 <iwtu> time would be enough :)
16:51:47 <iwtu> in any case, it's quite strange I can read and write in English.. totally foregin language
17:02:51 * copumpkin is performing dark voodoo
17:05:03 <shachaf> @elaborate copumpkin
17:05:07 <saml> for llvm binding on windows, why does it try to link to MS libraries?
17:05:10 <shachaf> Any dead chickens involved?
17:05:34 <copumpkin> nah, just deep dark GHC internals
17:06:58 <Eduard_Munteanu> Be careful if you go into a GHC within a GHC.
17:07:12 <copumpkin> :O
17:07:44 <monochrom> I put core in your core so you can cmm while you cmm
17:07:51 <copumpkin> :O
17:08:03 <dylukes> Hm
17:08:05 <roconnor> copumpkin: oh, nice to see you back in your usual colour
17:08:08 <dylukes> I feel like propositional logic kind of just clicks.
17:08:20 <dylukes> Like, the rules (so far) as so simple... but difficult to kind of grasp.
17:08:23 <monochrom> yes, propositional logic is easy
17:08:27 <dylukes> But once you do, they're easy.
17:08:46 <dylukes> My brain is just totally unused to thinking this way, which is kind of depressing to me personally.
17:08:49 <Eduard_Munteanu> dylukes: what are you reading? TTFP?
17:08:54 <dylukes> Eduard_Munteanu: yar.
17:09:03 <cwl> when is `fail` of `Monad` called
17:09:05 <copumpkin> dylukes: depressing? that should be exciting
17:09:05 <dylukes> It's pretty easy so far, just trying to really *understand* it, not just skim.
17:09:15 <copumpkin> cwl: when you have irrefutable pattern matches
17:09:16 <dylukes> copumpkin: No no, its depressing that my brain isn't used to it.
17:09:18 <copumpkin> in monadic binds
17:09:33 <dylukes> i.e, It's exciting as it starts clicking :P.
17:09:36 <copumpkin> :)
17:10:14 <copumpkin> so anyway, I'm writing reifyClosure :: a -> IO Closure
17:10:16 <monochrom> do { [x] <- blah; m x } is when fail is called. blah >>= \v -> case v of [x] -> m x; _ -> fail "pattern matching problem etc etc"
17:10:43 <monochrom> hmm, maybe it doesn't use "case". I have to check again
17:12:04 <cwl> copumpkin: I define a function  has type  eval1 :: Env -> Exp -> Eval1 Value,   eval1 env (var n) = Map.lookup n env
17:12:05 <monochrom> alright, it uses "case" indirectly
17:12:34 <cwl> copumpkin: will fail be called if lookup returns Nothing
17:12:37 <shachaf> monochrom: Is five a metaphor for death?
17:12:45 <shachaf> Or is it four?
17:12:51 <monochrom> 4
17:12:56 <copumpkin> cwl: only in old GHCs
17:13:48 <cwl> copumpkin: in old GHCs, who's fail is called, Eval1 or Maybe
17:13:58 <copumpkin> Eval1
17:14:07 <monochrom> 9413 is 10% probability of survival :)
17:16:41 <cwl> copumpkin: In the latest GHC, it is a compile error to write eval1 env (var n) = Map.lookup n env for unmatched type
17:16:53 <copumpkin> yes
17:16:55 <cwl> how to fix it
17:17:17 <cwl> to call fail if it returns Nothing
17:17:28 <copumpkin> a case expression?
17:17:32 <copumpkin> or maybe
17:17:37 <cwl> and return (fromJust it) if not Nothing
17:18:03 <byorgey> fromMaybe (fail "blarg")
17:18:04 <copumpkin> maybe return (fail "ugh") (Map.lookup n env)
17:18:40 <cwl> copumpkin: cool
17:18:51 <byorgey> copumpkin: I think you have those switched
17:18:55 <copumpkin> oh
17:19:00 <kmc_> :t fromMaybe (fail "blarg")
17:19:02 <kmc_> lambdabot!!!!
17:19:03 <byorgey> mine was missing a return
17:19:04 <copumpkin> well, I'll let cwl figure that out
17:19:11 <byorgey> sure =)
17:19:18 <copumpkin> too lazy to fix it!
17:19:38 <copumpkin> I wonder if I can unreify a closure too
17:19:49 <copumpkin> I'll need to level up my voodoo powers
17:20:25 <kmc> what?
17:20:49 <kmc> vacuum stuff?
17:20:53 <copumpkin> kmc: I'm doing dark GHC voodoo: reifyClosure :: a -> IO Closure
17:21:02 <copumpkin> nah, similar but a bit cleaner and safer
17:21:34 <kmc> where Closure is like a record of info table ptr, fields, etc?
17:21:50 <copumpkin> yeah
17:21:55 <copumpkin> I have an ADT with 60 constructors
17:22:00 <copumpkin> going through and implementing the
17:22:01 <copumpkin> m
17:22:22 <copumpkin> many of the closure types you probably can't even get ahold of in haskell code
17:22:24 <copumpkin> but I might as well
17:23:13 <copumpkin> or maybe it's 61 constructors
17:24:09 <cwl> @src maybe
17:24:51 <cwl> lambdabot is sleeping
17:25:39 <A1kmm> Has anyone had problems with Haskell98 System.system on ghc-compiled programs under Wine?
17:26:08 <A1kmm> It seems to invoke cmd.exe in a way that causes it to run in interactive mode instead of running the command.
17:27:36 <A1kmm> e.g. running this program: main = system "ghc --version" -- results in a cmd.exe prompt.
17:27:38 <kmc> copumpkin, so what makes it cleaner and safer than vacuum?
17:28:31 <copumpkin> kmc: I'm using GHC's own constructs to pull shit out, in cmm
17:28:37 <copumpkin> also, I'm doing it all in cmm
17:28:37 <Eduard_Munteanu> A1kmm: did you get a chance to try the resulting executable on Windows?
17:28:55 <copumpkin> kmc: I think the storable loads that vacuum does (iirc) aren't entirely safe if the closure moves
17:29:05 <copumpkin> unless he took special measures to make it work
17:29:22 <kmc> ah, cool
17:29:33 <copumpkin> it doesn't have to be in cmm, but cmm has built-in support for finding some of the fields
17:29:33 <A1kmm> Eduard_Munteanu: haven't tried that, I don't have a Windows box handy right now.
17:29:40 <copumpkin> without me having to ask whether tables are next to code, etc.
17:30:37 <A1kmm> Eduard_Munteanu: It affects compiling things like gtk using gtk2hsC2hs under Wine, so even if it works on Windows, I think some kind of work around is needed.
17:32:48 <Eduard_Munteanu> A1kmm: I remember having some trouble with gtk2hs under wine
17:33:24 <Eduard_Munteanu> About a year ago or so. I could only fix it using an old gtk2hs package.
17:33:27 <A1kmm> Eduard_Munteanu: Were you getting command prompts coming up? Probably the same issue.
17:33:49 <Eduard_Munteanu> No, not really, it's cabal failed to build gtk2hs
17:34:04 <A1kmm> Eduard_Munteanu: I built gtk2hs-buildtools fine.
17:34:12 <A1kmm> Eduard_Munteanu: with the latest version from Cabal
17:34:35 <A1kmm> but it hits this issue when trying to run cpp
17:37:16 <Eduard_Munteanu> A1kmm: can you try   rawSystem :: String -> [String] -> IO ExitCode    instead?
17:38:02 <Eduard_Munteanu> The first arg is supposed to be 'ghc' (or possible the complete path to ghc), then the args go in the second
17:38:35 <A1kmm> Eduard_Munteanu: trying now... I don't think that invokes cmd so I expect it will work.
17:39:01 <A1kmm> I think it is in a different package though.
17:39:09 <Eduard_Munteanu> System.Cmd
17:40:02 <A1kmm> I used System.Process, and it invokes the program correctly.
17:40:19 <A1kmm> import System.Process\r\n\r\nmain = rawSystem "ghc" ["--version"]
17:40:31 <A1kmm> wine ghc.exe test.hs -o test.exe
17:40:44 <Eduard_Munteanu> Yup.
17:40:45 <A1kmm> wine test.exe yields "The Glorious Glasgow Haskell Compilation System, version 7.0.4"
17:41:14 <Eduard_Munteanu> Does it fix your problem? (This supposedly was just a testcase.)
17:42:07 <A1kmm> Well, I could put forward a fix for gtk2hs that used rawSystem, but I think fixing system might be a better approach.
17:42:25 <A1kmm> Actually, I could see if it is just a problem with Haskell98 and try system from System.Process.
17:42:57 <kmc> out of curiosity, why are you running this code under Wine?
17:43:15 <A1kmm> kmc: I'm trying to compile Windows programs on a Linux build system.
17:43:28 <A1kmm> kmc: including the cabal package dependencies.
17:43:38 <A1kmm> kmc: which involves running gtk2hsC2hs
17:43:56 <kmc> i see
17:44:39 <Eduard_Munteanu> I used to do that to work on some homework/projects I was writing in Haskell, and teachers usually wanted a Windows .exe
17:45:05 <kmc> i see
17:45:08 <A1kmm> BTW the same thing happens with system from System.Process
17:45:11 <Clint> those teachers should be disbarred
17:45:20 <kmc> i don't understand why teachers would have you learn to program in Windows
17:45:39 <kmc> but microsoft puts a lot of effort towards ensuring they do
17:45:46 <kmc> because people stick with what they learn
17:45:56 <Eduard_Munteanu> kmc: well, it was either that (well, an exception), or doing it in Matlab *bam*
17:47:09 <Eduard_Munteanu> Not that the teacher actually understood any of the Haskell code but...
17:47:24 <Eduard_Munteanu> At least he wanted to see it worked.
17:47:56 <monochrom> receiving an exe is the dumbest thing a teacher can do
17:48:06 <Cale> lol
17:48:07 <Eduard_Munteanu> Yeah.
17:48:10 <kmc> my homework is COMET_CURSOR.EXE
17:48:18 <Clint> ThisIsNotAVirus.exe
17:48:31 <Cale> ThisIsNotARootKit.exe
17:49:08 <Eduard_Munteanu> I could have used my lappy to show it, but nah, he still wanted an .exe
17:49:08 <shachaf> monochrom: True. They should've asked for a .scr.
17:49:59 <A1kmm> So do they run each executable in an isolated virtual machine?
17:50:15 <Eduard_Munteanu> Anyway I only had to get to a Windows computer to check it actually worked outside Wine, and it did.
17:50:17 <kmc> send them a VM breakout exploit exe
17:50:22 <Eduard_Munteanu> A1kmm: nope
17:51:05 <Eduard_Munteanu> Seemingly control engineers don't know much about this stuff.
17:51:25 <benmachine> oh my goodness do they actually trust you or something, what a bizarre concept :P
17:52:06 <A1kmm> You can just do the assignment once with a program that connects over the network, connects to an implementation on a sane operating system, and sends back the results.
17:52:07 <Eduard_Munteanu> The Windows machines in the labs were rather plagued by viruses.
17:52:22 <kmc> i'm shocked to hear that
17:52:49 <A1kmm> If you have a faster computer, you can even make them wonder how it produces results in the time it does :P
17:55:35 <Eduard_Munteanu> Actually, I've had some teacher check my homework by opening a cmd (of course, I told him), then writing prog(x, y, z) as I was telling him the arguments.
17:56:04 <monochrom> about 20 years ago, it was fashionable to send exe's to friends by email. "hey here is a cool exe of 5 seconds of funny animation, I got it from yet another friend"
17:57:11 <A1kmm> hmmm "return (cmd, translate cmd ++ "/c " ++ string)"
17:57:16 <kmc> before that by floppy disk
17:57:22 <monochrom> there was much confusion between "you do not intend to send a virus to me" and "you are competent enough to ensure you do not send a virus to me"
17:57:29 <A1kmm> I'm going to try compiling that with a space before the /c to see if it works on Wine.
17:58:17 <Eduard_Munteanu> Maybe Wine's cmd doesn't take /c ok?
17:58:31 <A1kmm> Eduard_Munteanu: It does... I've tested it.
17:58:34 <monochrom> the floppy disk era was actually ok because it was dos 3.3 and everyone had to reboot with clean boot disks every half an hour anyway
17:58:58 <A1kmm> "wine cmd.exe /c ghc --version" works fine
17:59:11 <Eduard_Munteanu> Ah.
17:59:32 <monochrom> by the time of the email era, it became a real problem, because you could not write-protect your hard disk, and you booted from it
18:01:15 <monochrom> anyway, I say this because teachers who accept exe's are obviously from that era
18:01:54 <ddarius> Code: The ultimate compressed format
18:09:42 <copumpkin> how can I ask ghci for an explicit forall'd type of something?
18:10:17 <monochrom> I was looking for it yesterday too but couldn't find one
18:14:29 <mithos28> If the documentation on hackage for a package  isn't built  because of a build failure, should I contact the Author or Hackage?
18:14:54 <monochrom> the author first
18:15:19 <azaq23> copumpkin: You mean when using :t? :set -fprint-explicit-foralls
18:15:22 <mithos28> ok, thanks
18:16:52 <monochrom> yikes, that is not listed in the ghc user guide, not listed in ":help set" either, only listed in ":set"
18:18:10 <kmc> woah
18:18:25 <kmc> it's not in my manpage either
18:18:38 <kmc> good to know
18:19:35 <ion> Yeah, i tried to find it in the man page some time ago, too.
18:20:26 <cmccann> it's in the release notes for 6.8.1, that's something
18:20:33 <monochrom> haha
18:21:08 <copumpkin> omg cmccann is back!
18:21:26 <ion> I noticed it was turned on by -fglasgow-exts which lead me to see what *that* turns on, leading to the actual answer. :-)
18:21:44 <cmccann> copumpkin, eh what now
18:22:32 <copumpkin> welcome back!
18:23:00 <copumpkin> azaq23: thanks!
18:23:03 <cmccann> I didn't know I was gone :?
18:23:11 <cmccann> guess I hadn't been on IRC for a few days
18:23:20 <copumpkin> yep, was wondering if you'd disappeared!
18:23:56 <cmccann> nah, just hanging out with friends over the holiday weekend, then bogged down with too much work and not enough sleep afterwards :P
18:24:29 <copumpkin> :)
18:25:34 <cmccann> hm, looks like you actually used your mod powers on reddit, I'm impressed
18:25:49 * cmccann thinks someone was a bit confused there
18:26:06 <copumpkin> lol
18:28:27 <QinGW`> hi morning
18:28:49 <zachk> good evening
18:31:09 <kmc> ♥ -fglasgow-exts
18:36:34 <NemesisD> hi all. i'm trying to test some enumeratees. i figure the best way is to surround it with an enumerator that just enumerates some input string and an iteratee that just collects all the output until done and then inspects that. is that sensible?
18:37:24 * cmccann considers the merits of extending arbitrary Num types with a NaN value by catching arithmetic exceptions behind unsafePerformIO and sticking the results in a Maybe-like type
18:37:43 <copumpkin> spoon!
18:37:49 <cmccann> yes
18:37:57 <cmccann> well, teaspoon actually
18:38:03 <cmccann> to avoid the extra constraint
18:38:40 <bscarlet> copumpkin: spoon?
18:38:42 <cmccann> is what I'm currently doing at any rate, the considering part is about whether it was actually a good idea
18:39:03 <cmccann> bscarlet, http://hackage.haskell.org/package/spoon
18:39:11 <copumpkin> spoon is an abomination
18:39:38 <ddarius> spoon eats kittens
18:40:38 * cmccann mostly can't decide whether using teaspoon bothers him less than pure code throwing exceptions for no good reason in the first place
18:41:11 <copumpkin> well, it's intended to be used only in that case
18:41:25 <copumpkin> just as a workaround for bad "pure" code
18:41:27 <Cale> Arithmetic is srs biz.
18:41:34 <cmccann> yeah, it's inherently a dirty hack
18:41:53 <Cale> Probably just not dividing by 0 in the first place is the better answer.
18:42:13 <cmccann> but there's a reason why IEEE floats include NaN, and it's not because they wanted to confuse newbies forever
18:42:17 <kmc> that's a stunning endorsement from its maintainer
18:43:01 <bscarlet> why "spoon"?
18:44:00 <Cale> I guess if unsafePerformIO is a knife, then...
18:44:31 <cmccann> bscarlet, because "fork" would just confuse people
18:45:40 <copumpkin> it was something dumb mmorrow said about "there is no spoon"
18:45:42 <copumpkin> and it stuck
18:45:54 <copumpkin> I can't remember the exact circumstances
18:47:13 <cmccann> in a package where around 20% of the lines of actual code contain unsafePerformIO having a dumb name isn't really the first thing I'd worry about
18:48:36 <copumpkin> :(
18:49:01 <bscarlet> worrying /= asking :-)
18:49:25 <cmccann> really, that's got to be a record for highest density of unsafePerformIO in a module
18:49:31 <cmccann> I least I sure hope it is
18:49:56 <copumpkin> there are only two of them!
18:50:34 <cmccann> yes, in barely a dozen lines of code
18:50:41 <cmccann> quality, not quantity!
18:50:53 <shachaf> cmccann: There's always dmead-style.
18:50:57 <copumpkin> lol
18:51:00 <shachaf> http://www.reddit.com/r/haskell/comments/jarp0/hi_guys_i_made_a_haskell_to_clojure_translator/c2ajxtn
18:51:08 <copumpkin> preflex: seen dmead
18:51:08 <preflex>  dmead was last seen on #ghc 20 days, 7 hours, 10 minutes and 48 seconds ago, saying: :D
18:51:09 <magicman> If you count acme-now...
18:51:12 <magicman> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html >_>
18:51:18 <cmccann> haha I forgot about that
18:51:24 <jmcarthur> preflex: seen mmorrow
18:51:24 <preflex>  mmorrow was last seen on #ghc 1 year, 233 days, 23 hours, 42 minutes and 15 seconds ago, saying: * mmorrow is rtfm'ing
18:52:24 <cmccann> of course, the difference is that spoon is actually useful, and sensible to use
18:57:51 <SamB_XP> pumpking od?
18:58:09 <SamB_XP> someone overdosed on being the lord of Perl?
18:58:43 <copumpkin> ?
18:59:24 <SamB_XP> preflex: google pumpking
18:59:45 <incluye> nyan | cat
19:00:47 <copumpkin> http://www.pumpking.com/
19:00:49 <blackdog> i'd like to parse json from a socket - what's my best way of structuring it?
19:02:23 <parcs> lots of json?
19:02:30 <blackdog> many messages, yes
19:02:32 <ddarius> parseJsonFromSocket :: Socket -> IO Json; parseJsonFromSocket = return undefined
19:03:17 <blackdog> ddarius: so that'd be a blocking function that would return once i've got enough?
19:03:35 <parcs> probably with network-enumerator, aeson and attorparsec-enumerator
19:03:38 <scooty-puff> is it possible to create a shared object exposing a c function void parser(<...>) that initializes the haskell runtime (and deinitializes) that contains all the requirements statically?
19:03:49 <scooty-puff> i.e. i'm getting an error related to undefined symbol: hs_init currently
19:03:54 <ddarius> blackdog: What do you want to do with this JSON once you've parsed it?
19:03:54 <blackdog> scooty-puff: yes
19:04:11 <scooty-puff> using cabal with --enable-shared to create the .so, the calling as a plugin to gtags/global
19:04:13 <blackdog> send the information over a channel that may update the state of my game world
19:04:34 <scooty-puff> blackdog, currently, using cabal and --enable-shared during compilation
19:04:43 <scooty-puff> *compilation -> cabal configure
19:05:21 <blackdog> the way i'm thinking about it is to have one thread for listening for client messages, and send that over the channel to the world-manager, then have another thread writing to the client whenever the world-manager decides to
19:05:25 <blackdog> scooty-puff: sorry, hang on a tic
19:05:33 <scooty-puff> k
19:05:56 <SamB_XP> http://lmgtfy.com/?q=pumpking
19:06:03 <blackdog> scooty-puff: i did this: https://github.com/mwotton/Hubris/blob/master/ext/stub/stub.c
19:06:33 <blackdog> some of it's for ruby compatibility, but it should be obvious what i've done
19:07:03 <scooty-puff> k
19:07:05 <scooty-puff> thanks!
19:10:21 <blackdog> scooty-puff: np
19:10:25 <hpaste> int80_h pasted “finalizing daemon design” at http://hpaste.org/51117
19:13:11 * hackagebot archiver 0.5.1 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.5.1 (GwernBranwen)
19:15:34 <jesse99> so is Text.Printf the recommended way to do formatted io?
19:16:04 <Cale> jesse99: I don't really use it
19:16:21 <jesse99> well I want something better than ++
19:16:27 <Cale> concat? :)
19:16:30 <int80_h> http://hpaste.org/51117
19:16:39 <copumpkin> @bot
19:16:42 <krey_> o/, I'm trying to find the connected components of a grid, and the code I wrote is basically imperative. is this because of the nature of the problem or does my code need to improve? https://github.com/krey/Bubble-Breaker/blob/6fb893606271afad97286d251c7f1f58badce0d4/beast.hs
19:16:44 <Cale> I usually put things together with concat and show
19:16:45 <copumpkin> Cale: we've been missing her all day!
19:17:10 * copumpkin hugs lambdabot 
19:17:26 <Cale> krey_: That doesn't sound like a very imperative problem :)
19:17:28 <Jafet> @quote hugs
19:17:35 <lambdabot> Igloo says:  Did hugs' ./configure always end with "config.status: executing ultra-evil commands"?
19:17:46 <int80_h> I just ordered this book http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
19:18:19 <Cale> krey_: Though I guess keeping track of the state of which vertices are visited is kind of imperative-esque.
19:18:20 <krey_> Cale: o/, well it's still the same problem as yesterday, but using a bit less mutable state. any suggestions?
19:20:32 <krey_> Cale: well, no way around that really
19:20:45 <Cale> yeah
19:20:52 <Cale> The State monad usage there isn't so bad
19:21:02 <Cale> It's only a thin wrapper around some parameter passing.
19:21:21 <krey_> Cale: verdict? functional enough? :P
19:21:32 <Cale> Yeah, seems fine
19:21:57 <krey_> Cale: thanks :)
19:22:31 <Cale> Though... do both the result and the visited nodes need to be in the state?
19:22:42 <Cale> hmm
19:23:05 <Cale> Or in your case, the unvisited nodes :)
19:23:11 * hackagebot hmatrix-gsl-stats 0.1.2.11 - GSL Statistics interface  http://hackage.haskell.org/package/hmatrix-gsl-stats-0.1.2.11 (VivianMcPhail)
19:24:12 <krey_> Cale: which one in particular?
19:24:59 <roconnor> Help, HTTP Response has changed it's kind
19:26:29 <copumpkin> this voodoo is kind of fun
19:26:33 <copumpkin> I love poking around GHC's innards
19:28:24 <roconnor> oh I have a choice between String and ByteString
19:28:43 * cmccann is still disappointed that you can't use the GHC API from the same process as GHC
19:28:51 <int80_h> copumpkin messing with dark forces beyond his ken, at the same time HTTP Response changes it's type. Coinicidence? I don't think so.
19:29:02 <cmccann> or at least not in any obvious way
19:29:03 <ddarius> Kind.
19:29:23 <monochrom> use s/Response/Response String/ to migrate
19:29:23 <monochrom> the upshot is that rspBody could be ByteString instead of String
19:29:31 <c_wraith> yeah, the lack of thread-safety in the GHC api is a bit silly.
19:29:41 <scooty-puff> so the problem i was having with .so files - looks like the rts or base .so isn't being linked in statically - is there  a way to force this?
19:29:54 <scooty-puff> or is there otherwise a workaround (not well versed in commands related to .a and .so files..)
19:30:02 <monochrom> you also need s/Request/Request String/ and again it could be ByteString too
19:30:07 <scooty-puff> http://www.haskell.org/pipermail/glasgow-haskell-users/2010-February/018480.html
19:30:23 <cmccann> c_wraith, it was just the dynamic linker that gave me trouble, complained about duplicate symbols and I couldn't find any obvious fix :[
19:30:33 <scooty-puff> that thread explains a lot of my troubles - but i don't know how to combine the .so or .a files like the poster did
19:31:23 <cmccann> admittedly what I was trying to do was terrible and not really reasonable in any way
19:32:20 <int80_h> cmccann: that's been me all week.
19:33:06 <cmccann> int80_h, oh? dare I ask?
19:33:31 <int80_h> cmccann : I just discovered concurrency and don't really know what I'm doing
19:33:55 <cmccann> int80_h, sounds fun
19:34:01 <int80_h> cmccann: But I've calmed down, came up with a simpler design, and am working out some details.
19:34:02 <ddarius> int80_h has spent his whole life living in a world where everything takes turns.
19:34:22 * ddarius needs to up the crazy in his C# code.
19:34:57 <monochrom> use delimited continuation passing style to up the craziness in your c# code
19:35:08 <ddarius> monochrom: That may be soon.
19:35:12 <monochrom> hehe
19:35:15 <int80_h> ddarius: my crazy design came from not thinking about the problem xcorrectly. Once I did, the solution simplified significantly.
19:35:36 * cmccann seems to recall that you can start a thread from a TH splice and then talk to it from later splices, that's a fun use of concurrency 
19:36:12 <int80_h> that does sound fun, to a crazy person. But in my case I was just being stupid.
19:36:44 <Cale> Yeah, that's sort of a funny thing about writing Haskell, it's often 90% thinking and 10% typing.
19:36:44 * ddarius wishes C# "events" were more first-class.
19:37:03 <cmccann> int80_h, template haskell gives you all kinds of new ways to do stupid things
19:38:23 <Cale> cmccann: rofl
19:38:40 <monochrom> that's more krad than my "use TH to play movies"
19:38:58 <Cale> come up with a program which does a different thing every time you compile it due to differences in thread interleaving
19:39:07 <cmccann> monochrom, which is why it annoys me that the one thing I couldn't easily do with TH was use the GHC API :[
19:40:49 <Jafet> Wrap it into a macro and call it fforceRecomp
19:43:00 <dainanaki> Could anyone advise me on what xml libraries are pleasant to use for heavy xml reading/processing?
19:43:38 <dainanaki> I'm looking at hexpat, but I don't know what options are considered to be better/worse than others.
19:44:16 <blackdog> dainanaki: stephen blackheath is behind hexpat - i'd expect it to be good.
19:45:53 <int80_h> what is the difference between
19:45:53 <int80_h> main :: IO ()
19:45:57 <int80_h> grrr
19:46:05 <int80_h> I'll post it
19:46:12 <hpaste> copumpkin pasted “closures” at http://hpaste.org/51118
19:47:04 <deech> Are type classes+type families pretty equivalent to ML's modules?
19:47:05 <hpaste> int80_h pasted “STM question” at http://hpaste.org/51119
19:47:28 <ddarius> deech: No, they are more "powerful" (in one sense.)
19:47:40 <Cale> dainanaki: If you're going to use hexpat, I recommend using it exclusively through hexpat-pickle
19:47:51 <dainanaki> Cale: why is that?
19:48:05 <ddarius> int80_h: The type.
19:48:18 <Cale> It's much nicer to work with Haskell datastructures than it is to work with XML directly, usually.
19:49:13 <deech> ddarius: A cursory glance at Ocaml's modules suggest they are parameterized by a type and contain a bunch of functions that work on that type. How are they more powerful?
19:49:16 <Cale> It gives you a nice way to define correspondences between Haskell datatypes and XML trees, and then go back and forth.
19:49:50 <dainanaki> I see. I'm primarily interested in just going from XML -> Haskell
19:50:19 <deech> dainanaki: I've had good luck with hxt.
19:50:22 <ddarius> deech: You can (relatively reasonably) encode SML's and O'Caml's module systems into type classes and then some.  You can go the other direction as well, but the encoding the other direction is not reasonable (namely it is a global transformation.)
19:51:16 <deech> ddarius: Oh you meant Haskell's type classes are more powerful. I misinterpreted.
19:56:00 <Cale> ddarius: I'd hate to see what happens to code which, e.g. uses more than one monad at a time.
19:58:14 <_Ray_> That's a very simple question I have - is the do-notation specified for one monad a time? What if I want to use bind and return for different monad types?
19:58:41 <deech> _Ray_: Monad transformers are your friend.
19:58:53 <parcs> do desugars to >>=
19:58:56 <parcs> :t (>>=)
19:58:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:59:07 <deech> _Ray_: http://book.realworldhaskell.org/read/monad-transformers.html
20:00:04 <rata_> hi
20:00:07 <deech> _Ray_: Monad transformers are monads that take other monads as their parameter
20:00:15 <_Ray_> yo dawg :s
20:00:56 <rata_> how can I tell ghci to use .hi files instead of .hs files?
20:01:20 * edwardk waves hello.
20:01:20 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
20:01:26 * copumpkin is working on an unapply function that lets me write unapply (f x) ==> x
20:01:47 <_Ray_> copumpkin, what do you have to ask of f?
20:01:53 <copumpkin> nothing
20:02:20 <edwardk> copumpkin: using your shiny happy closure inspection machinery?
20:02:22 <_Ray_> so unapply(const False y) = y?
20:02:34 <copumpkin> edwardk: yep, still lots of holes to fit in
20:02:51 <copumpkin> _Ray_: well, you will have to specify an index to unapply at
20:02:59 <copumpkin> still workign on it :)
20:03:00 <edwardk> _Ray_ unless you have evaluated the thunk or the optimizer has had its way with it
20:03:18 <copumpkin> yeah, this will only get you stuff that's actually present at runtime :P
20:03:20 <edwardk> its deep voodoo
20:04:09 <copumpkin> indeed!
20:04:32 <bscarlet> and breaks equational reasoning?
20:04:34 <copumpkin> edwardk: do you have a stablename map lying around by the way? one that uses the hashcode to look one up and then tests for equality?
20:04:45 <copumpkin> bscarlet: it will eventually live in IO
20:04:50 <edwardk> stable-maps
20:05:11 <copumpkin> perfect, thanks
20:05:16 <copumpkin> I might need that later
20:05:25 <edwardk> https://github.com/ekmett/stable-maps
20:05:31 <edwardk> its handy
20:06:00 <bscarlet> copumpkin: what's it's type?
20:06:18 <copumpkin> um
20:06:25 <copumpkin> unapply :: a -> Int -> b
20:06:30 * copumpkin hides
20:06:34 * edwardk laughs
20:06:54 <copumpkin> although I probably won't put that API in here
20:06:56 <copumpkin> it's just playing around
20:07:05 <copumpkin> here I just provide a reified closure type
20:07:14 <copumpkin> and a way to build one
20:07:36 <copumpkin> (one day I hope to be able to take a value of that type and make real closures out of it again, at least in some circumstances)
20:08:51 * bscarlet thinks voodoo leads to zombies
20:09:14 <copumpkin> bscarlet: one of the goals is to be able to serialize fix (1:)
20:09:23 <copumpkin> in finite time
20:10:50 <bscarlet> copumpkin: why?
20:11:12 <cmccann> copumpkin does what he must, because he can
20:11:26 <copumpkin> so you can send arbitrary haskell closures over the wire and be webscale with cloud power
20:11:48 <copumpkin> (whoever deserializes your closure should have been compiled from the same code in a similar environment)
20:12:21 <edwardk> i would really like to see serializable closures
20:12:43 <copumpkin> yeah
20:13:08 <edwardk> toss the computation over the wire, get back results? sign me up
20:13:22 <copumpkin> I obviously can't serialize the code in a meaningful manner, but I can serialize everything but the code
20:13:30 <copumpkin> my only concern is if symbols get stripped
20:13:37 <copumpkin> that I won't be able to find my way
20:13:55 <copumpkin> but then it's your fault and you deserve to not be able to load your serialized closures
20:14:28 <edwardk> heh
20:14:59 <copumpkin> or we could ask GHC to mark certain symbols as essential or something
20:15:00 * copumpkin shrugs
20:15:00 <copumpkin> that stuff comes later :)
20:15:00 * cmccann suspects that copumpkin actually just invents dirty hacks first, then searches for ways to use them afterwards so he has an excuse
20:15:01 <copumpkin> cmccann: lol
20:15:07 <copumpkin> no no, I've wanted serializable closures for ages
20:17:08 <edwardk> that isn;t to say that he didn't say 'it'd be cool if i could serialize closures' six months before he started trying to find excuses for them ;)
20:17:11 <rata_> how can I tell ghci to use .hi files instead of .hs files?
20:17:16 <copumpkin> lol
20:18:04 <roconnor> copumpkin: aren't serializable closures like wanting 2^N to be isomorphic to N?
20:18:25 <roconnor> I mean sure, I can see 2^(2^N) being isomorphic to N, but 2^N?!
20:18:43 <Cale> wat
20:18:50 <copumpkin> roconnor: don't worry, it'll be swept under the IO rug
20:19:13 <roconnor> oh
20:19:15 <copumpkin> Cale: http://en.wikipedia.org/wiki/File:Wat_Mahathat_temple_(Laos2009).jpg
20:19:18 <roconnor> interesting
20:19:52 <tgeeky> that's very beautiful
20:19:59 <edwardk> copumpkin: great now cale will spend the next 9 months building it out of magnets
20:20:00 <tgeeky> and looks deadly to very tall people who jump
20:21:20 <bscarlet> copumpkin: I'd have expected such a beast to be more inside the compiler, rather than what I _think_ I understand you're doing exposing parts of what I think of as implementation internals.
20:21:35 <copumpkin> it's definitely compiler-specific
20:21:36 <Cale> lol
20:21:42 <copumpkin> that's why I stuck it under the GHC namespace
20:21:47 <copumpkin> and it depends on ghc-prim and such
20:21:54 <copumpkin> and a lot of it is written in cmm
20:22:25 * cmccann wonders if edwardk has noticed that he's the third google hit for "trigonometric coalgebra"
20:22:43 <edwardk> cmccann: occupational hazard
20:22:55 <shachaf> Cmm /= C--?
20:23:01 <shachaf> How many intermediate languages does GHC use?
20:23:09 <edwardk> cmccann: it gets frustrating when half the links on google about the topics i care about are by me
20:23:14 <cmccann> hahaha
20:23:20 <Cale> http://upload.wikimedia.org/wikipedia/commons/4/41/Angkor_Wat.jpg
20:23:29 <copumpkin> shachaf: it's almost the same
20:23:43 <tgeeky> shachaf: 2 more than GHC uses
20:23:45 <copumpkin> shachaf: cmm is a ghc-specific c-- that's missing some of the c-- stuff
20:23:48 <tgeeky> shachaf: 2 more than GHC uses
20:23:50 <tgeeky> ...
20:24:09 <Cale> edwardk: You just need to put a strange word onto each page that you write, which can then easily be excluded in your google queries.
20:24:16 <shachaf> Cale++
20:24:29 * shachaf suspects that "kmett" is pretty strange a word.
20:24:38 <cmccann> Cale, I think the problem is that the strange words are the stuff he's looking for
20:24:47 <edwardk> shachaf: heh
20:26:02 <Cale> http://en.wikipedia.org/wiki/File:Central_Chedi_at_Wat_Doi_Suthep1.jpg -- wow :)
20:27:09 <shachaf> So this one time I saw a talk by conal about working with images in a nice way.
20:27:38 <shachaf> Are there any usable libraries that implement the sort of thing he worked on?
20:32:15 <rata_> is there a way to use .hi files in GHCI?
20:33:25 <Axman6> rata_: if there's compiled code for a modukle you load, ghci should automatically use it. .hi files are just the interface file for the module.
20:33:50 <rata_> Axman6: what's the extension of compiled code?
20:33:55 <Axman6> .o
20:34:01 <rata_> there is
20:34:05 <rata_> but it doesn't find it
20:34:09 <Axman6> but if you load Foo.hs and Foo.o exists, ghsi sbhould use irt
20:34:21 <byorgey> shachaf: maybe the Chalkboard package from KU?
20:34:27 <shachaf> rata_: Did you lose a .hs file or something of the sort?
20:34:31 <Axman6> ghci*
20:34:51 <byorgey> shachaf: http://www.ittc.ku.edu/csdl/fpg/Tools/ChalkBoard
20:34:59 <rata_> there exists /usr/lib/ghc-7.0.2/site-local/MonadRandom-0.1.6/Control/Monad/Random.h and /usr/lib/ghc-7.0.2/site-local/MonadRandom-0.1.6/HSMonadRandom-0.1.6.o
20:35:11 <shachaf> byorgey: I saw that. It doesn't seem to compile on GHC >= 6.12, according to Hackage, so I wondered if it was unmaintained.
20:35:22 <rata_> should I import it like "import HSMonadRandom"?
20:35:32 <shachaf> rata_: What are you trying to do?
20:35:52 <rata_> shachaf: import Monad.Control.Random
20:35:57 <byorgey> shachaf: oh really? hmm, I don't know.
20:36:00 <shachaf> rata_: If you installed the package "random", you should be able to import it from a program with "import Control.Monad.Random".
20:36:20 <byorgey> shachaf: I don't know whether any of conal's packages are still maintained, but I guess he can tell you that
20:36:28 <shachaf> rata_: "Monad.Control.Random" won't work. You shouldn't have to worry about whether the actual file is .hi or .o or anything like that.
20:36:46 <shachaf> byorgey: I suppose I can ask when he's next online. :-)
20:37:24 <rata_> sorry, it was actually Control.Monad.Random
20:37:28 <rata_> not the other way around
20:37:37 <byorgey> shachaf: I bet if you email the people at KU they
20:37:42 <shachaf> Well, if it's installed properly, it should just work.
20:37:43 <byorgey> 'll respond
20:38:05 <byorgey> looks like it's just an issue with package version upper bounds needing to be bumped
20:38:05 <rata_> shachaf: it doesn't
20:38:19 <rata_> it's probably not installed properly then
20:38:26 <rata_> but that's weird
20:39:01 <byorgey> shachaf: what do you want to do with images, out of curiosity?
20:39:07 <shachaf> byorgey: I tried to install it locally and there was an ambiguity of some sort.
20:39:32 * cmccann marvels at GHCi loading about two dozen modules in order to evaluate "1 + 1" in the REPL
20:39:36 <shachaf> byorgey: Nothing in particular. I saw some snippets of C++ code dealing with images and it looked neat on the one hand and horribly low-level on the other.
20:39:54 <shachaf> So I thought I'd see if I can try some things out in Haskell, and remembered conal's talk.
20:40:09 <byorgey> right
20:40:15 <tgeeky> shachaf: he said he's looking for people to help do "TV 2.0" or something of that sort
20:40:32 <shachaf> tgeeky: Isn't that about UIs or something?
20:40:48 <tgeeky> shachaf: yes, I think so. Sorry. Wrong thing.
20:41:07 * cmccann has been playing with some graphics stuff in Haskell recently, but not really stuff involving raster images
20:41:18 <shachaf> cmccann: What have you been doing?
20:41:26 * shachaf has never done any graphics things ever, really.
20:41:34 <tgeeky> there's raster or vector :o
20:41:45 <byorgey> shachaf: but IIRC there's some image processing stuff involved as well.
20:42:13 <tgeeky> shachaf: his first love was the image processing stuff, TVs were the animation component
20:42:15 <cmccann> playing with some geometric algebra mostly, then just tossing the results on the screen in whatever hackish way comes to mind
20:42:42 * cmccann was using diagrams at one point, then switched to hacking some messy OpenGL stuff
20:43:20 <byorgey> cmccann: was there something in particular that diagrams didn't let you do?
20:43:27 <byorgey> I've been hacking on it a bunch recently
20:43:32 <byorgey> and writing a user manual
20:43:46 <tgeeky> byorgey: speaking of which, I'll get started on that tomorrow morning. Too late tonight.
20:43:55 <byorgey> tgeeky: heh, no rush =)
20:44:15 <cmccann> byorgey, be OpenGL? I was just using it because it was simple and easy to get visual output at all, getting animation and 3D polygons was my real goal to begin with
20:44:32 <byorgey> cmccann: ah, fair enough
20:44:35 <cmccann> unless you've added an OpenGL backend to it or something :]
20:44:50 <byorgey> well, there IS an OpenGL backend, but it's rather bit-rotted
20:44:57 <tgeeky> cmccann: I really, really want to write a [d3.js] backend to diagrams
20:45:06 <byorgey> I don't know how far it got in the first place anyway
20:45:39 <int80_h> the docs say newEmptyTMVarIO is useful for creating top-level TMVars using unsafePerformIO. I'm not using unsafePerformIO, should I just stick withnewEmptyTMVar instead?
20:45:47 <byorgey> cmccann: certainly animation and 3D polygons is something I'd like for diagrams to support, but it doesn't yet
20:46:13 <tgeeky> byorgey: the "web3.0" support for 3D is in such a state of flux right now...
20:46:13 <cmccann> tgeeky, I'm not familiar with that
20:46:15 <byorgey> but not because of any fundamental limitation, just because no one's gotten around to writing the code yet
20:46:49 <osfameron> is there something like scanl, but where *multiple* intermediate values can e generated by each iteration?
20:46:50 <edwardk> cale: my wife is in awe of your magnet sculptures
20:46:53 <tgeeky> cmccann: it's not 3d, but it has excellent animation support (in certain circumstances) http://mbostock.github.com/d3/
20:47:08 <Cale> edwardk: :)
20:47:18 <byorgey> osfameron: scanl with a tuple type?
20:47:40 <osfameron> byorgey: but where I want the scan to go over each intermediate value too
20:48:07 <byorgey> osfameron: I'm not sure I understand.  can you give an example?
20:48:15 <osfameron> something like:  primes = 2 : scanl getNextPrimes 3 primes
20:48:21 <edwardk> she has started constructing elaborate fantasies about you turning them into jewelry. she doesn't even wear jewelry. i've tried to put the scale in perspective to no avail ;)
20:48:29 <chomp> playing around with parsec, there doesn't seem to be a standard combinator that simply applies a parser once and discards the result?
20:48:38 <osfameron> where getNextPrimes might return [7] or maybe [11,13]
20:48:38 <tgeeky> edwardk: not to mention the cost
20:48:48 <edwardk> tgeeky: heh
20:48:49 <osfameron> but I want the scan to consider each pair of primes in turn
20:49:38 <byorgey> chomp: you don't really need a combinator for that, just say something like   do { runThisParserAndIgnoreTheResult; someOtherPArser }
20:49:45 <cmccann> tgeeky, oh, hm. I was actually planning on doing SVG output somehow for the stuff I'm doing
20:49:53 <byorgey> chomp: or, if you're using Applicative style,  runThisParserAndIgnore *> someOtherParser
20:50:15 <tgeeky> cmccann: yeah, d3 uses SVG in many places, but it has a good model for time, color, and various scales
20:50:16 <shachaf> int80_h: You might as well use it if you don't care.
20:50:22 <chomp> hmm i need this parser to succeed for an optional parser to be applied successfully
20:50:39 <osfameron> byorgey: does that example ^^ make any sense?  This problem broke my brain yesterday, so I mihgt still be jibbering ;-)
20:50:56 <dmwit> osfameron: No, there's no built-in function like that.
20:50:58 <aaandroid> is anyone familiar with this article http://ertes.de/articles/monads.html
20:50:58 <chomp> e.g. foo <- optionMaybe (some >> stuff >> charThatMustBeHereButShouldntBeReturned)
20:51:06 <dmwit> You could have a go at writing it yourself if you like.
20:51:12 <int80_h> shachaf: I was wondering if there was a stylistic reason for newEmptyTMVar instead of newEmptyTMVarIO
20:51:15 <byorgey> osfameron: hmm, not really
20:51:35 <cmccann> tgeeky, yeah, I'm going to at least use it as a point of comparison for my stuff, I think
20:51:36 <osfameron> dmwit: thanks.  my limited hoogle skills couldn't fine it either.  It is *possible* to write it though?
20:51:41 <byorgey> chomp: ok, and what should be returned? the output from stuff?
20:51:44 <osfameron> *find
20:51:45 <dmwit> Seems feasible.
20:51:47 <int80_h> lke, if I used newEmptyTMVar at the top level, would it make people think 'wtf'?
20:51:49 <chomp> some and stuff
20:51:52 <tgeeky> cmccann: there are lots of examples (many more than the ones that are on the 'Examples' page
20:52:08 <tgeeky> cmccann: https://github.com/mbostock/d3/wiki
20:52:24 <byorgey> chomp: foo <- optionMaybe (some >> stuff <* charThatMustBeHere)
20:52:31 <chomp> ah, <*
20:52:35 <chomp> thanks :)
20:52:50 <byorgey> chomp: or  foo <- optionMaybe (do { some ; x <- stuff ; charThatMustBeHere; return x })
20:52:52 * osfameron will have a go at writing it later on then
20:53:00 <osfameron> concatScanl or something like that
20:53:08 <cmccann> tgeeky, I doubt my stuff would work well as a backend for diagrams though, since the whole point of what I'm doing is to model geometry in a very different (read: nicer) way
20:53:21 <shachaf> int80_h: At the top level? What do you mean?
20:53:31 <chomp> ahh.  though i like the <* syntax better.  but it's nice to see the equivalence
20:53:34 <tgeeky> cmccann: what kind of geometry, and what kind of way?
20:53:52 <ion> Might as well use *> since you’re working in the Applicative world. :-)
20:54:01 <cmccann> tgeeky, the geometric algebra stuff I mentioned earlier
20:54:12 <tgeeky> cmccann: oh. Hm.
20:54:18 <tgeeky> cmccann: -> PM
20:54:35 <byorgey> aaandroid: I'm not familiar with that article, but I am familiar with monads
20:54:42 <byorgey> aaandroid: do you have a particular question?
20:55:00 <cmccann> roughly a way of generalizing complex numbers to subsume a lot of other stuff and give a much nicer interface for geometric computation
20:55:16 <int80_h> shachaf : main :: IO ()
20:55:16 <byorgey> cmccann: sounds awesome =)
20:55:46 <int80_h> shachaf: main :: IO ()
20:55:47 <aaandroid> byorgey: I was wondering what the author meant by 'It allows you to create complex computations from simpler parts intrinsically, i.e. without requiring a notion of running computations.'
20:56:31 <cmccann> byorgey, catch ddarius sometime, I imagine he'd love to tell you about how much better it is :P
20:56:32 <BMeph> cmccann: Read Hestenes much? ;)
20:57:02 <shachaf> int80_h: Any reason not to use atomically there?
20:57:14 <shachaf> (That's not "top level".)
20:57:48 <byorgey> aaandroid: well, I think the point is that the Monad operation >>= gives you a way to combine two computations into one
20:57:56 <int80_h> shachaf: no reason I can see except it's less typing not using it.
20:57:59 <cmccann> BMeph, not that much actually, just a handful of things I found online and some tinkering with Haskell implementions
20:58:07 <byorgey> aaandroid: I am not sure why the emphasis on "without requiring a notion of running computations"
20:58:46 <int80_h> shachaf: but if it's better form to use it unless you have a good reason ( I don't), then I can just do it that way.
20:59:09 <aaandroid> byorgey: me neither
20:59:37 <byorgey> aaandroid: I'd suggest not to worry about it too much, just go start reading about and playing with examples
20:59:37 <shachaf> int80_h: I assume that it is indeed better form, but I don't really know.
20:59:45 <aaandroid> byorgey: ok...can you suggest any other articles/videos?
21:00:13 <byorgey> aaandroid: I am biased, but I recommend reading the Typeclassopedia
21:00:20 <byorgey> @where typeclassopedia
21:00:21 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
21:00:57 <shachaf> aaandroid: That article seems to use the World -> (a,World) metaphor, which isn't a very helpful one.
21:01:26 <aaandroid> byorgey: thanks
21:01:39 <aaandroid> shachaf: which article?
21:01:45 <shachaf> The one you linked to.
21:01:56 <shachaf> getChar :: Universe -> (Char, Universe)
21:02:17 <shachaf> Thinking about things that way will probably be more confusing than clarifying.
21:02:34 <aaandroid> shachaf: what's a better way to think about it?
21:02:59 <shachaf> aaandroid: IO is an abstract type with some primitives that can be combined in certain ways.
21:03:16 <shachaf> It happens to be a monad but that isn't even that important. You could easily use it if it wasn't.
21:03:38 <shachaf> As monads go it's an unusual one, so if you're trying to figure out the "monad" type class there are probably better examples you could look at.
21:03:49 <Veinor> how would you use IO without the monadic structure?
21:04:23 <shachaf> Veinor: Well, not the IO Haskell type, but a similar one. And I mean if it wasn't a member of the type class, specifically.
21:04:29 <Jafet> mybind :: IO a -> (a -> IO b) -> IO b; myreturn :: a -> IO a
21:04:48 <Veinor> oh, yeah
21:04:54 <shachaf> E.g. something like data IO = Exit | PutChar Char IO | GetChar (Char -> IO)
21:05:05 <Veinor> i was just trying to imagine doing IO in haskell without using do-blocks or equivalent structures
21:05:49 <shachaf> aaandroid: A good way to understand how IO works in Haskell is to try to figure out for yourself how it could be done.
21:06:06 <Veinor> specifically using the existing IO structure
21:06:16 <shachaf> Veinor: Right, that's not what I meant.
21:06:20 <Veinor> right
21:06:48 <shachaf> There are really simple and not very flexible ways of doing IO in a Haskell-like language, e.g. main :: String (output-only IO), or main :: String -> String (text-transforming UNIX utility IO)
21:07:10 <shachaf> And then there are more complicated ones like main :: [Response] -> [Request] or something CPSy like is actually used in Haskell.
21:08:57 <zzo38> I read about Curry-Howard, and how you can use that to implement intuitionistic logic in Haskell. But I have two questions. One is, is there a program, possibly make up a pragma, allowing checking that the output is defined for all inputs? (Sometimes it is not solvable due to halting problem, though.)
21:09:15 <zzo38> Second question is, can it be used to make Typographical Number Theory?
21:09:40 <tgeeky> zzo38: those are very general. Yes, you can exhaustively search the a valid range of inputs
21:10:15 <Jafet> Typographical number theory has the potential for some explosive discoveries.
21:10:31 <byorgey> har har =)
21:10:45 <tgeeky> Jafet--, terrible puns.
21:10:50 <zzo38> tgeeky: It can be known, for example, if you do no looping, you have no "undefined", and you have exhaustive patterns, then you have proved it is defined output for all defined inputs.
21:11:54 <cmccann> zzo38, I think the program you're looking for is called "Agda"
21:12:17 <zzo38> Sometimes it is not known. It is the case that the theorem is true if the program halts with a defined output? I don't know. There could be pragma PROVE that checks this property and is a compile error if it doesn't go, and ASSUME which is used only with PROVE.
21:14:29 <zzo38> (The PROVE pragma would not affect the semantics of the program, except perhaps optimization. If you use ASSUME though, it would assume it is halts and no undefined, and possibly be able to use that information for optimization, but might cause the program to execute incorrectly in case of errors.)
21:15:21 <zzo38> So when I said ASSUME is only used with PROVE, I lied because ASSUME might also be able to be used for optimization.
21:17:23 <byorgey> zzo38: yes, this could be done, but it probably won't be done in Haskell, because people who want that sort of thing just use Agda or Coq.
21:17:34 <tgeeky> zzo38: haskell is a little bit weaker than theorem provers and such -- Agda or Coq or (something similar)
21:17:59 <cmccann> Haskell is better at proving theorems, though
21:18:02 <cmccann> particularly false ones
21:18:11 <byorgey> zzo38: Agda is a Haskell-like language which basically has an implicit PROVE pragma on every function =)
21:19:49 <cmccann> byorgey, oh btw, good choice on using τ in diagrams
21:20:01 <byorgey> cmccann: heh, thanks =)
21:20:16 <byorgey> just doing my bit of implicit evangelism
21:21:05 <cmccann> well, it really does make more sense
21:21:19 * cmccann is happy to throw out tradition for the sake of elegance
21:21:37 <byorgey> indeed
21:23:03 <cmccann> same reason I prefer geometric algebra to the usual nonsense with vectors vs. points and keeping track of which things change how under various transformations, actually :P
21:23:12 * hackagebot hstatistics 0.2.2.10 - Statistics  http://hackage.haskell.org/package/hstatistics-0.2.2.10 (VivianMcPhail)
21:23:27 <rata_> is there something like (Monad m) => Int -> (a -> m a) -> a -> m [a]... something like take n . iterate for monads
21:23:30 <rata_> ?
21:24:23 <zzo38> cmccann: That is why you need the PROVE pragma so that you can avoid proving false ones unless you force it to do so. (There might be some cases you want to use it even if you are not trying to prove anything; although in some cases it won't help, and in a few cases I think more-notation with Template Haskell can help)
21:24:37 <cmccann> rata_, well, there's replicateM, but that's not really the same
21:25:03 <ClaudiusMaximus> :t foldM
21:25:05 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:25:13 <zzo38> And the ASSUME pragma, which could be used not only for proofs but also for optimization. (It simply assumes the property which the PROVE pragma checks.)
21:25:44 <byorgey> cmccann: fair enough, I will have to learn more about geometric algebra
21:25:59 <byorgey> cmccann: any good starting places you can recommend?
21:26:15 * cmccann is pretty sure he's always ended up writing his own unfoldM, iterWhileM, and such for doing monadic corecursion
21:27:14 <zzo38> Curry-Howard allows you to make intuitionistic logic, but can you do something to allow you to make classical logic as well? Typographical Number Theory is based on classical logic using Propositional Calculus.
21:27:29 <cmccann> byorgey, hm, not really off the top of my head. but the basic idea is pretty simple. you familiar with quaternions as rotation operators in 3D?
21:27:41 <byorgey> cmccann: vaguely
21:28:11 <chomp> mmmm quaternions
21:28:20 <cmccann> byorgey, well, you know how imaginary numbers are rotation operators in 2D, right
21:28:25 <byorgey> cmccann: right
21:29:24 <cmccann> for me at least it was easiest to look at geometric algebra as a generalization of complex numbers, quaternions, etc.
21:29:43 <tgeeky> cmccann: that's called "clifford algebras"
21:29:45 <cmccann> and that gets you pretty far in low dimensions
21:30:02 <cmccann> tgeeky, yeah, of which GA is a particular flavor/interpretation
21:30:04 <rata_> cmccann: that's close to what I need
21:30:18 * aleator would really like to have a G-A library for haskell
21:30:35 <tgeeky> aleator: we should formalize a group and a project
21:30:43 <tgeeky> cmccann is in the lead :O
21:30:46 <cmccann> aleator, http://hackage.haskell.org/packages/archive/algebra/2.0.2/doc/html/Numeric-Coalgebra-Geometric.html not enough for you? ;]
21:31:10 <cmccann> eh, I just have two very bad implementations and some hacks built on top of edwardk's stuff
21:31:33 <aleator> cmccann: There is one already?
21:33:10 <byorgey> zzo38: you can, it turns out that moving from intuitionistic to classical logic corresponds (in some spooky way I don't quite understand) to adding call/cc
21:33:14 <cmccann> byorgey, anyway to get GA you take the basis vectors for your space and work with their power set instead. Things multiply out in various ways that end up including complex numbers and quaternions as special cases
21:33:43 <byorgey> cmccann: interesting.
21:33:49 <cmccann> so you multiply vectors to get a bivector which represents a rotation in the plane they span
21:34:21 <cmccann> in 3D the dual of a bivector is a vector giving the normal to the plane, and that's roughly what the cross product gives you
21:34:33 <byorgey> aha, OK
21:34:38 <cmccann> the nice thing here is that transformations work correctly for bivectors
21:35:10 <cmccann> instead of having to track whether some vector represents, say, a surface normal or angular momentum
21:35:22 <cmccann> which are derived from bivectors and thus flip signs under reflection
21:35:33 <byorgey> cool
21:36:05 <cmccann> so you get a uniform way to treat all your geometric objects instead of special cases for what things represent
21:36:14 <byorgey> right
21:36:14 <aleator> diagrams-lib + geometric algebra = great :)
21:36:27 <byorgey> I bet it would be
21:36:30 <cmccann> I'm eliding plenty of detail here as you might imagine, but I expect you can see the appeal
21:36:41 <cmccann> are you familiar with homogeneous coordinate systems?
21:36:45 <byorgey> yes, I can.  I'll have to read up on it.
21:36:59 <zzo38> byorgey: I have read too in Wikipedia, that it has something to do with continuation.
21:37:03 <byorgey> cmccann: yes, I think so
21:37:22 <zzo38> Is there continuation monad that can make such things?
21:37:34 <byorgey> cmccann: that's where you add an extra dimension and take the equivalence class of scalar multiples, right?
21:38:09 <cmccann> byorgey, yes, though I find it clearer to think of it as projecting rays from the origin
21:38:10 <zzo38> And how does that work anyways? I don't quite understand either; it is not only you that don't quite understand.
21:38:12 * hackagebot hsignal 0.2.3.3 - Signal processing and EEG data analysis  http://hackage.haskell.org/package/hsignal-0.2.3.3 (VivianMcPhail)
21:38:19 <AtnNn> is this useful for anyone else? http://code.atnnn.com/projects/cabal-ghci/wiki
21:38:32 <byorgey> zzo38: it is deeply mysterious
21:38:57 <byorgey> zzo38: one time this summer I saw deeper into the mystery than ever before; for one shining moment all was clear.  and then it was gone.
21:39:12 <byorgey> I guess it was just something I ate.
21:39:52 <cmccann> zzo38, you can represent "not A" as "A -> False", and False proves everything
21:40:03 <cmccann> so if you wave your hands and treat "not A" as "A -> a", but let the type variable be bound in some outer scope, you can cheat a bit
21:40:22 <byorgey> AtnNn: I think 'cabal ghci' is (or will soon be) integrated into the development version of the cabal tool
21:40:31 <cmccann> giving you ((A -> r) -> r) for some value of r to represent double negation
21:40:48 <cmccann> and if you apply that to id you get the A back
21:41:09 <AtnNn> byorgey: good news :)
21:41:32 <cmccann> in order to use classical proofs you need to let the continuation's result be chosen externally, so that you can use call/cc to mess with flow control
21:41:40 <zzo38> If you do add that, how can you then add that to make stuff corresponding to Typographical Number Theory?
21:42:33 <scooty-puff> is this expected: i am trying to make a shared object involving c code and an initialized haskell runtime; it never works if i have a call to hs_init from a nonstatic function (even if that function is never called), but always works if a make the function that calls hs_init static
21:42:38 <byorgey> AtnNn: but in the meantime I expect some people will find it useful, you should announce it on the haskell-cafe mailing list
21:42:52 <scooty-puff> (static but still not called)
21:42:56 <cmccann> zzo38, given a result type of "r" you build a classical proof by contradiction by providing a tentative proof of the negative "A -> r", then if anything actually uses that function (contradicting it) they have to do so by applying it to a value of type A
21:43:35 <cmccann> zzo38, if that happens you steal the value of type A and use call/cc to jump back to the other branch so you can provide it as the proof that A is true
21:43:44 <cmccann> so that gets you excluded middle and whatnot
21:46:15 <byorgey> cmccann: yes, OK, what I said and projecting rays from the origin are interchangeable in my head.  so what about homogeneous coordinate systems?
21:46:29 <zzo38> cmccann: Can you show some simple examples of such a code?
21:46:58 <cmccann> zzo38, http://okmij.org/ftp/Computation/lem.html
21:47:40 <cmccann> byorgey, right, yes. you can do the same thing in geometric algebra and extend the same uniformity you get in 2D and 3D
21:47:52 <cmccann> since another nice thing is that GA works just as well in arbitrary dimensions
21:48:04 <cmccann> unlike, say, the cross product only being defined in 3D and 7D
21:48:19 <byorgey> I see, cool
21:49:02 <byorgey> hmm, I tried reading the wikipedia page on GA but it is rather hopelessly uninformative
21:49:16 <cmccann> the clifford algebra page is actually better in some ways
21:49:23 <byorgey> ok, I'll take a look at that
21:49:26 <cmccann> in terms of presenting the math
21:50:40 <cmccann> clifford algebra being mostly the same thing in every way you're likely to care about for going graphics
21:51:22 <zzo38> Just to note, I would have used <xmp> on that document instead of <pre>, which among other things allows the program to be loaded directly into Haskell.
21:51:26 <cmccann> I'm not clear on to what extent clifford algebras include things that wouldn't be called geometric algebra, but in the general case it's the same structures
21:52:35 <cmccann> byorgey, as a simple example in 2D you'd have two basis vectors {x, y}, and arbitrary terms would be of the form (a + bx + cy + dxy)
21:53:26 <byorgey> cmccann: a, b, c, d are elements of some field?
21:53:33 <BMeph> byorgey: The best place for GA/CA info is David Hestenes' ASU site.
21:53:38 <cmccann> because of how the geometric product works, xy * xy = -1, so scalars and the xy term together give the complex numbers
21:53:48 <byorgey> BMeph: thanks!
21:54:08 * BMeph nods
21:54:16 <cmccann> byorgey, not sure what the underlying structure needs to be. probably a ring is fine?
21:54:31 <byorgey> OK. and is xy just a formal product?
21:54:53 <scooty-puff> can a haskell .so file be loaded with dlopen?
21:55:20 <copumpkin> sure
21:55:57 <cmccann> byorgey, strictly speaking I think it would imply the exterior product here
21:56:11 <cmccann> whereas a * xy would be scalar multiplication
21:56:44 <byorgey> OK, well, I think I get the basic idea
21:56:50 <cmccann> but the uniformity of the full GA means that you can pretty much see everything as the generic geometric product and do fine
21:57:02 <scooty-puff> copumpkin, when using dlopen, i am currently getting NULL as a response
21:57:22 <scooty-puff> if i comment out or make static (and uncalled) the code that calls hs_init, it works
21:57:47 <cmccann> byorgey, the end results looks like kind of like having a vector space over the power set of the basis elements, with extra rules about how multiplying terms with basis elements in common works
21:59:05 <chomp> scooty-puff, so let me get this straight.  you have a call to dlopen whose behavior changes based on the presence or absence of unrelated code?
22:00:11 <zzo38> Can the compiler automatically optimize stuff into unsafeCoerce?
22:00:32 <cmccann> byorgey, the biggest downside to all of this, which you may already be noticing, is that for an N-dimensional space you need 2^N coefficients
22:00:53 <byorgey> cmccann: hehe, I see
22:01:30 <cmccann> my current favorite is a doubly-homogeneous approach that introduces an extra non-euclidean dimension that sounds confusing but makes things very nice to work with
22:02:08 <byorgey> zzo38: that's essentially what it does with newtypes.  What other things should be optimized to unsafeCoerce?
22:02:10 <cmccann> the short version is that the extra dimension represents a point at infinity, so you can unify rotations and translations by treating the latter as rotations around infinity
22:02:31 <cmccann> you also get circles and spheres as basic primitives
22:02:34 <byorgey> cmccann: hah, neat =)
22:02:50 <scooty-puff> chomp, it would appear so
22:02:51 <cmccann> (the only primitives actually; lines are circles through infinity, &c.)
22:03:02 <byorgey> of course
22:03:04 <scooty-puff> chomp, i assume dlopen is being called - this is for a gtags/global plugin
22:03:13 * hackagebot cabal-ghci 0.1 - Set up ghci with options taken from a .cabal file  http://hackage.haskell.org/package/cabal-ghci-0.1 (EtienneLaurin)
22:03:15 <aleator> cmccann: What about point pairs? I never figured those out.
22:03:18 <zzo38> byorgey: For example:  f :: [a] -> Bool; f [] = False; f (_:_) = True;   or   f :: [a] -> Bool; f = unsafeCoerce;
22:03:37 <scooty-puff> chomp, and the dlopen call fails for me if i have void parser(<...>) { ... } ... void call_to_hs_init(void) {...}
22:03:45 <scooty-puff> but does not fail if static void call_to_hs_init
22:03:51 <zzo38> Or this:  f :: [a] -> Maybe a; f [] = Nothing; f (x:_) = Just x;
22:03:56 <cmccann> aleator, point pairs are mostly a side effect of intersections between circles and such
22:03:57 <byorgey> zzo38: ah. I doubt it does that, but I don't know
22:03:57 <scooty-puff> http://web.archiveorange.com/archive/v/2B0uXoCd0ooQaxazIq9J
22:04:02 <scooty-puff> that sounds like a similar case
22:04:21 <zzo38> Both definitions of "f" could also be replaced with "f = unsafeCoerce;" (together with a type declaration)
22:04:32 <byorgey> zzo38: that depends a lot on the particular in-memory representations which are generated
22:04:33 <cmccann> aleator, you can actually have your points be point pairs with one side at infinity, which makes things more consistent in some ways
22:04:36 <zzo38> If it cannot optimize by itself, you might use a RULES pragma?
22:04:54 <byorgey> zzo38: sure, you could, but I wouldn't
22:05:19 <byorgey> zzo38: there is no guarantee that those will work.  they may happen to work with ghc currently.
22:05:30 <aleator> cmccann: Ah. Never thought of the last one. I was just curious since everything seemed to be a circle, except pairs.
22:05:49 <cmccann> aleator, pairs are circles too :]
22:06:12 <cmccann> a circle in 2D is all points on the plane equidistant from the center
22:06:20 <aleator> cmccann: Ah. So 1D?
22:06:26 <cmccann> what would you get for all points on a 1D number line equidistant from a center?
22:06:40 <byorgey> a circle!
22:06:42 <aleator> That was too obvious.. :/
22:07:02 <zzo38> byorgey: Can you specify a rule of unsafeCoerce for specific version?
22:07:13 <cmccann> byorgey, anyway, so rotations are just bivectors which can be transformed like any other element, and can be composed by multiplication, and include translations as well
22:07:23 <cmccann> I think you can compose sphere inversions and scaling as well
22:07:23 <byorgey> zzo38: for a specific version of GHC you mean?
22:07:45 <cmccann> so you really can unify huge amounts of things that would all need special handling otherwise
22:07:58 <byorgey> cmccann: very cool!
22:08:06 <zzo38> byorgey: Yes, so that it will only activate the rule to change it to unsafeCoerce if you use a version of a Haskell compiler that it is known to work
22:08:21 <byorgey> zzo38: well, you could with some CPP pragmas I suppose
22:08:25 <cmccann> the downside is that the conformal model adds two dimensions, so for 3D space you have 5D, which means 2^5 coefficients which is kinda :[ :[ :[
22:08:50 <byorgey> zzo38: I feel like you are asking me "is it possible to cut off your own arm with a saw?" and I am like "well... technically, yes..."
22:09:02 <zzo38> byorgey: I suppose so.
22:09:17 <zzo38> What does it have to do with arm and saw?
22:09:52 <byorgey> zzo38: just something that is very painful and has no benefit =)
22:10:23 <zzo38> I would never want to use unsafeCoerce directly in a Haskell code, except for RULES pragma, and possibly in a few cases dealing with FFI codes.
22:10:40 <byorgey> cmccann: oh come on, 2^5 is not that big =)
22:11:02 <aleator> cmccann: I recall some authors claiming that if you simplify the formulas enough (automatically) you'd get something basically as efficient as you'd get with linear algebra.
22:11:07 <byorgey> zzo38: I don't understand why you want to use unsafeCoerce at all
22:11:28 <zzo38> byorgey: For optimization purpose. That is why it should be used in RULES pragma instead of directly.
22:11:33 <aleator> cmccann: Thought to myself back then, that this would make a nice haskell programming exercise.
22:11:48 <cmccann> byorgey, keep in mind that the full geometric product has to multiply every combination of terms from each :P it gets painful fast if you don't track which ones are nonzero
22:11:52 <byorgey> zzo38: and you are sure that using unsafeCoerce would actually save you a lot of time?
22:12:52 <cmccann> aleator, well, in many cases you know in advance that you want something of a single grade, or even a pure blade
22:12:56 <byorgey> cmccann: oh, I see.
22:13:08 <cmccann> it probably wouldn't be too hard to track some simple stuff using phantom types or GADTs
22:13:35 <zzo38> byorgey: Well, that it should sometimes make the program faster and/or smaller but sometimes a little bit, possibly a lot in some cases.
22:13:44 <aleator> cmccann: Or adding a compilation pass like people do with regexps?
22:13:46 <cmccann> to both ensure that if you need a consistent grade you have one, and to narrow down dramatically which terms need to be examined in a multiplication
22:13:57 <byorgey> zzo38: ok. well, have fun =)
22:14:02 <zzo38> Also in a few cases with FFI codes you might want to use unsafeCoerce.
22:15:09 <cmccann> aleator, if you look at edwardk's approach he uses covectors for a geometric coalgebra, e.g. sort of a quasi-CPS with a linearity constraint, then uses memoization functions to avoid recomputation
22:16:34 <cmccann> so that gives you both lazy calculation (if you filter by grade, the stuff you ignore will never get calculated at all) and a sort of two-pass system in the sense of building computations which you can restructure then only evaluating at the end
22:16:44 <aleator> cmccann: I'll try. But covectors and coalgebra words scare me :)
22:16:59 <cmccann> it also lets him do frightening things like not require a finite basis
22:17:18 <cmccann> aleator, well, do you know what a covector means in the usual sense?
22:17:22 <cmccann> e.g., a row vector
22:17:59 <behelit> ok, so I just started using records. How do you typically deal with multiple declarations? Is there some commonly used prefix or something?
22:18:07 <aleator> cmccann: Vaguely yes.
22:18:40 <cmccann> aleator, you can sort of think of covectors as being partially-applied dot products :P
22:19:09 <cmccann> isomorphic to a vector of the same size, but only existing directly in terms of what they do to vectors
22:19:27 <aleator> cmccann: Ah.
22:19:29 <kmc> so you can write the monad laws with return and (>>=), which is ugly
22:19:37 <kmc> and you can write them with return and (>=>), which is nicer
22:19:42 <kmc> but can you write them with return and join?
22:19:44 <kmc> (and fmap)
22:20:48 <kmc> i suppose one is: join (return x) = x
22:21:12 <cmccann> and since you can represent (ha, ha, that was a pun) a vector as a function from the basis elements to the scalar ring (A -> R), the covector is a function that takes whatever elements it cares about from the vector, multiplies them by its own elements, and sums the results
22:21:51 <copumpkin> kmc: sure you can
22:21:52 <pikhq_> kmc: I thought the standard category theory definition of "monad" used return and join.
22:21:57 <copumpkin> kmc: that's how the categorists usually write them
22:22:05 <pikhq_> (I could be wrong, though; I don't know category theory)
22:22:18 <cmccann> yes, return and join are the usual definition
22:22:28 <aleator> cmccann: Hmm.. I think I basically follow you, but my education on the topic seems to have a big hole in it.
22:22:30 <cmccann> fmap is assumed because you already said it was a functor, usually
22:23:28 <kmc> okay so i should translate from http://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition
22:23:33 <cmccann> :t \f g -> join . fmap f . g
22:23:34 <lambdabot> forall (m :: * -> *) a a1 (f :: * -> *). (Monad m, Functor m, Functor f) => (a1 -> m a) -> f (m a1) -> f (m a)
22:23:59 <cmccann> n.b. that makes more sense without Caleskell
22:24:02 <copumpkin> :t fmap join
22:24:04 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Monad m, Functor f) => f (m (m a)) -> f (m a)
22:24:08 <copumpkin> :t liftM join
22:24:08 <shachaf> The monad laws are just like the monoid laws the way category theorists usually write them. :-)
22:24:09 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => m1 (m (m a)) -> m1 (m a)
22:24:26 <copumpkin> :t [join, liftM join]
22:24:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (m (m a)) -> m (m a)]
22:24:48 <copumpkin> :t join . join, join . liftM join
22:24:50 <lambdabot> parse error on input `,'
22:24:53 <copumpkin> :t [join . join, join . liftM join]
22:24:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (m (m a)) -> m a]
22:25:04 <kmc> so one of them is:  join . fmap join ≡ fmap join . join  -- ?
22:25:18 <kmc> no
22:25:41 <cmccann> kmc, it's a monoid on type constructors
22:25:55 <copumpkin> monoid object
22:26:11 <copumpkin> not quite the same as algebraic monoid
22:26:38 <cmccann> unfortunately the actual descriptions map poorly onto Haskell
22:26:44 <copumpkin> kmc: here, this will make it super clear to you! https://github.com/copumpkin/categories/blob/master/Categories/Monad.agda
22:26:44 <copumpkin> ;)
22:26:54 <copumpkin> kmc: I also have the kleisli construction there
22:27:06 <copumpkin> and the construction of a monad from an adjunction
22:27:23 <kmc> join . join ≡ fmap join . join -- ?
22:27:37 <copumpkin> sadly, I don't have that a monad is just a monoid object in the category of endofunctors, what's the problem :(
22:27:58 <shachaf> Lax functor from a terminal bicategory?
22:28:42 <cmccann> anyway, for a monad M you get a sort of monoid (modulo copumpkin's nitpicking) with the identity being going from the identity functor to M, and the monoid operation is going from functor composition of M with itself to a single M
22:28:52 <copumpkin> cmccann :(
22:29:02 <cmccann> but it's all pretty confusing in Haskell for various reasons
22:29:18 <cmccann> such as not being able to talk about functor composition OR an identity functor directly
22:29:47 <cmccann> or that everything morphism-like tends to get flattened to just functions in "Hask"
22:30:00 <shachaf> You can sort of see it in Haskell, though.
22:30:02 <copumpkin> kmc: join . join == join . liftM join
22:30:06 <shachaf> It's join . join = join . fmap join, isn't it?
22:30:11 <shachaf> Curses.
22:30:33 <cmccann> since in categorical terms the (->)s in the types for fmap and join mean all kinds of different things
22:33:56 <copumpkin> shachaf: in that sense, I'd say the monad laws are just like the category laws :P
22:34:02 <copumpkin> [02:12:27 AM] <shachaf> The monad laws are just like the monoid laws the way category theorists usually write them. :-)
22:34:05 <copumpkin> concerning that
22:34:21 <copumpkin> since it's really just saying that the kleisli construction on a monad is a category
22:34:39 <copumpkin> it's like monoids, except with moar typez
22:34:41 <shachaf> The category laws look a lot like the monoid laws to me.
22:34:45 <copumpkin> which cmccann calls nicpicking
22:34:51 <copumpkin> they are
22:35:18 <cmccann> copumpkin, :]
22:35:30 <copumpkin> :D
22:35:38 <cmccann> I only grumble because it's so awkward to do things right in Haskell
22:36:04 <copumpkin> shachaf: one way to think of it is that a category is a typed monoid. It gives you a mappend that isn't homogeneous, but still promotes some notion of compatibility
22:36:21 <copumpkin> I'm not sure the typed monoid idea gets you very far in the long run though
22:36:46 <kmc> well, i could be wrong, but i think there's not much to say about monoids in general
22:37:00 <copumpkin> yeah :)
22:37:07 <kmc> compared to groups say
22:37:11 <kmc> but as far as understanding the definition of a category, "typed monoid" did it for me
22:37:25 <copumpkin> the view of it as a generalized preorder seems more fruitful, in general
22:37:26 * cmccann suspects that edwardk could talk about monoids for quite a while, actually
22:37:38 <shachaf> «"Monoid" is the name of a generic API that applies to many different types.»
22:37:39 <copumpkin> there are craploads of examples of them, certainly
22:38:10 <cmccann> monoids are arguably the simplest and most common algebraic structure that has enough stuff going on to be interesting at all
22:38:43 <cmccann> I mean, who ever talks about unital magmas?
22:41:22 <copumpkin> associative ones still retain some goodness :)
22:41:23 <cmccann> I was actually amused to notice something (fairly trivial) about magmas the other day
22:41:58 <cmccann> free magmas are basically tree structures, right?
22:41:58 <shachaf> edwardk is a big supporter of associative magmas recently.
22:42:14 <kmc> shachaf, well, it is...
22:42:14 <cmccann> take the identities you'd have for associativity and apply them to a non-associative magma
22:42:26 <cmccann> then draw the expression as trees with values at the leaves
22:43:00 <cmccann> the associativity identities look rather familiar in that form
22:43:34 <shachaf> kmc: That's true of every type class, isn't it? :-)
