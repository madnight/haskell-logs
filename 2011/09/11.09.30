00:00:48 <chra> rostayob: I have mapped the keys on my keyboard and avoid using any conversion: →⇝⇒∷
00:00:56 <kmc> rostayob, i use http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
00:02:04 <osfameron> why would you want to type some complicated sequence of modifier keys to get the unicode character instead of "::" or "->" ?
00:02:36 * osfameron doesn't really get why you'd want to *display* them either, but that's probably just Luddism
00:03:31 <q0tw4> or use withCString :: String -> ReaderT CString m a -> m a
00:03:47 <rostayob> chra, kmc: that's cool, and you can also use latex mode in emacs, but it would be easier to have emacs inserting them for me
00:03:58 <rostayob> and it shouldn't be hard since it's displaying them already anyway
00:04:24 <chra> osfameron: Because I use the IM-module for japanese, typing shift-space for switching gets tiring, and it's not that complicated.
00:05:46 <kmc> typing "<Compose> ->" is not much harder than typing "->"
00:05:51 <kmc> and it works in every app
00:05:59 <kmc> it's not a "complicated sequence of modifier keys"
00:06:02 <osfameron> chra: ah - you mean the Japanese keyboard mappings don't have ":" and ">" and so on?
00:06:02 <hvr> what's the current upstream repository/issue-tracker for http://hackage.haskell.org/package/bytestring ?
00:06:14 <kmc> it's a single key you press before the other two
00:06:20 <osfameron> kmc: except that your keyboard doesn't even *have* a Compose key ;-)
00:06:26 <kmc> mine does
00:06:43 <osfameron> oh?  gosh.  Old unix keyboard?
00:06:54 <kmc> it's easy to designate any key as the compose key
00:07:09 <kmc> i'm using the ThinkPad "Fn" key for reasons which are explained in the post
00:07:10 <rostayob> kmc: yeah but having the editor do everything for you is sitll better imo
00:07:17 <kmc> but you could use any spare key
00:08:05 * osfameron prefers to read and see "::" and "->" in tutorials etc., because that's what the actual compiler/interpreter uses
00:08:15 <aninhumer> Is there that much benefit to using the unicode symbols anyway?
00:08:23 <MatrixFrog> they LOOK COOL
00:08:26 <MatrixFrog> and they are FANCY
00:08:32 <rostayob> osfameron: the unicode simbols work perfectly with the compiler/interpreter
00:08:32 <MatrixFrog> what more benefit do you need? :)
00:08:55 <rostayob> well at least with ghc
00:10:12 <kmc> i think the benefits of → over -> and ∷ over :: are small to nil
00:10:28 <kmc> if you are defining many infix operators, it might be better to use non-ASCII symbols
00:10:33 <kmc> rather than incomprehensible mixtures of ASCII symbols
00:10:42 <rostayob> kmc: i like the forall
00:10:52 <aninhumer> Yeah I can see the advantage for using different symbols
00:11:02 <zomg> kmc: how do you type -> ? :P
00:11:25 <osfameron> the danger is that you'll post the code on email/internet/somewhere and somebody that you wanted to share the code with will see incomprehensible boxes
00:11:32 <aninhumer> but -> is just as readable as → if not more so, since font renderers are more likely to handle it properly
00:11:59 <rostayob> osfameron: mah, maybe you're right. i have the cool fonts in emacs anyway.
00:12:54 <kmc> osfameron, maybe this makes me That Guy, but I'm sorry, it's 2011, if your computer does not support Unicode then your computer is broken
00:13:25 <kmc> i'd like to move past the era where speaking English is a prerequisite for using technology
00:13:53 <osfameron> kmc: my "computer" does.  But every time I have a new laptop, and need to set up irc (via ssh to a webhost) then I have to lookup what obscure terminal and ssh and screen settings are needed to make unicode work all the way along the chain
00:14:01 <osfameron> it's still not automatic, out of the box, and unproblematic
00:14:46 <kmc> so you can a) complain loudly and submit patches, or b) adopt regressive attitudes because you can avoid these problems personally
00:14:57 <aninhumer> at worst you just need to change your locale
00:14:58 <kmc> i've not had major problems with this
00:15:11 <osfameron> to be fair, I'm not especially good at configuring Linux
00:15:12 <aninhumer> ssh/screen/irssi support everything fine
00:15:32 <osfameron> I also wouldn't know what to patch
00:20:39 <aninhumer> Uh oh looks like the establishment has launched an attack on #haskell idlers...
00:37:50 <chrisdone> it's like babylon 5
00:38:17 <ivanm> chrisdone: dammit, you're actually online now, but I can't remember what I wanted to poke you about!
00:39:13 <aleator> How do I get more sparks? I have list with expensively (ffi) evaluated doubles and by using parList rnf I get only 18 sparks in total. The list has 500 elements.
00:39:33 <ivanm> aleator: do you have enough processors/cores allocated?
00:39:45 <kmc> only 18 created or only 18 converted?
00:39:54 <ivanm> but IIRC, parList isn't recommended for FFI
00:40:17 <hpaste_> aleator pasted “How to get more sparks out of this?” at http://hpaste.org/51954
00:40:28 <aleator> kmc: created
00:41:19 <aleator> ivanm: If strategies are not good for foreing but pure stuff, what is?
00:41:40 <ivanm> aleator: explicit OS-level threads I think
00:42:01 <aleator> ivanm: But those don't really mesh with pure computations.
00:42:21 <ivanm> well, yes
00:42:28 <ivanm> split your pure stuff out from your impure stuff
00:42:37 <aleator> There is no impure stuff :)
00:42:41 <ivanm> aleator: are you wanting to do the parallel stuff on the FFI or the pure stuff?
00:42:57 <aleator> The FFI is pure.
00:42:58 <ivanm> aleator: are you unsafePerformIO'ing the FFI or something?
00:43:19 <aleator> Yes. It has no side effects even in c.
00:43:32 <elliott__> ivanm: OS-leveL? forkIO isn't os-level
00:43:40 <elliott__> or is forkOS actually needed here
00:43:41 <ivanm> elliott__: isn't it? thought it was...
00:43:50 <ivanm> well, forkIO is what I meant
00:43:55 <elliott__> no, forkIO starts a haskell thread and GHC maintains OS threads in a pool to schedule 'em
00:44:03 <quicksilver> elliott__: and forkOS is exactly the same.
00:44:06 <ivanm> aleator: if you're using lazy I/O with multiple sources, that _could_ be a problem
00:44:06 <elliott__> forkOS forces an actual binding to an OS thread which is only needed for FFI stuff that cares about threads
00:44:16 <elliott__> quicksilver: except it binds it to only one new thread...
00:44:18 <quicksilver> this is not the difference between forkIO and forkOS
00:44:19 <elliott__> (OS thread)
00:44:36 <quicksilver> forkIO will *potentially* use a new OS thread
00:44:39 <ivanm> aleator: where is the FFI in there?
00:44:43 <elliott__> quicksilver: sure
00:44:54 <quicksilver> and there is no better primitive ot use than forkIO.
00:45:01 <quicksilver> forkIO is what you want to use if you want to use OS thread.
00:45:06 <quicksilver> btu you do need enough capabilities.
00:45:07 <elliott__> forkOS guarantees it'll create a new OS thread
00:45:12 <elliott__> but like I said, it's only useful for FFI ofc
00:45:22 <aleator> ivanm: (see the hpaste) in the crossvalidateClassifier function. It eventually calls libsvm c-library
00:45:39 <ivanm> aleator: what's the point of doing "take 1 ress" rather than just "head" when minimumBy will bitch about an empty list anyway?
00:46:00 <quicksilver> elliott__: I don't think it does guarantee to create a new one. Certainly that's not part of the documented behaviour.
00:46:02 <kmc> forkOS does not guarantee a *new* OS thread
00:46:08 <elliott__> hmm, well right
00:46:14 <quicksilver> elliott__: it just makes the haskell thread bound.
00:46:18 <elliott__> but it guarantees you'll get an OS thread all to yourself :P
00:46:21 <aleator> ivanm: Ah, sorry, that is just leftover where I tried to scale the problem.
00:46:27 <quicksilver> elliott__: no, not all to yourself.
00:46:33 <quicksilver> you still share it with other haskell threads.
00:46:35 <elliott__> hmm right
00:46:35 <quicksilver> you just get bound to it.
00:46:40 <kmc> it guarantees your FFI calls will consistently come from the same OS thread.  that is all
00:46:44 <elliott__> is there a way to kick other threads off an OS thread, I wonder
00:46:45 <ivanm> aleator: you seem to be mixing up a lot of stuff in there though, which doesn't make it that easy to read :p
00:46:50 <kmc> it might not be "your" OS thread
00:47:28 <ivanm> aleator: how long do you expect that list to be?
00:47:33 <aleator> ivanm: Well, after trying everything I could think of things usually look quite messy. I'll se if I can clear it up
00:47:57 <aleator> ivanm: about 400 elements
00:48:42 <ivanm> aleator: have you tried using some kind of stub function to replace crossvalidateClassifier to see if it _is_ the FFI at fault?
00:50:16 <chrisdone> mauke: can you tell me roughly what this line of perl is doing?
00:50:16 <chrisdone> /\G([\sa-zA-Z0-9\.,:;'"\(\)=\-\/\[\]\*\+]+)/gc and ($tex .= $1, next);
00:50:16 <chrisdone> i'm guessing that it's taking any character that matches these characters and appending them to $tex and then continuing the loop that it's in
00:50:21 <aleator> ivanm: Well, hmm. no :) Will do that next.
00:50:32 <ivanm> aleator: how long are the two sublists (that c and sigma come from) ?
00:50:45 <mauke> argh
00:51:05 <ivanm> aleator: does using something apart from rdeepseq work?
00:51:24 <ivanm> what's the CPU utilisation of the runtime? how many cores/CPUs are you using it with?
00:51:47 <mauke> if (m{\G([\sa-zA-Z0-9,.:;'"()=\-/\[\]*+]+)}/gc) { $tex .= $1; next }
00:51:50 <mauke> hmm
00:52:07 <mauke> chrisdone: it's part of a string stepper
00:52:26 <mauke> the string is in $_ and it has an associated "current position"
00:52:28 <aleator> ivanm: Lists are of length 21 and 19 respectively
00:52:49 <ivanm> aleator: I wonder if that's the cause: it's only doing the parList stuff on one of those
00:52:55 <mauke> it's checking the current position for 1 or more characters from the listed set (\s is "any whitespace char")
00:53:02 <chrisdone> mauke: ah, with pos($_)
00:53:15 <mauke> if found, those characters are appended to $tex, the position is advanced, and the next iteration starts
00:53:26 <chrisdone> got it. thanks :)
00:53:58 <aleator> ivanm: One of them?
00:54:29 <aleator> Well, at the start it nicely ups the cpu consumption to 5500% where I expect it to be and then it quickly drops.
00:54:50 <ivanm> chrisdone: right, I remember what I wanted to ask: it seems that the TAGS file isn't being updated; I add a function, then try and use anything-c-etags-select to look it up, and it doesn't appear there :/
00:55:03 <ivanm> aleator: :o how many processors/cores do you have? :o
00:55:12 <chrisdone> ivanm: it gets updated when you save the buffer. did you do that?
00:55:18 <ivanm> yup
00:55:30 <aleator> ivanm: 64, why? ;)
00:55:48 <ivanm> chrisdone: I note that I have to create the first TAG file manually (by explicitly running hasktags); could that be the same problem?
00:55:54 <ivanm> aleator: because I'm envious? :P
00:56:02 <ivanm> I just have 4...
00:56:11 <ivanm> no, wait, HT means I have 8 virtual cores
00:56:48 <Blkt> good day everyone
00:57:24 * ivanm waves idly in Blkt's general direction
00:57:25 <chrisdone> ivanm: i think you said it had trouble launching hasktags. (setq hs-config-echo-all t) to see if it is. i think perhaps a newer or older version of hasktags that i'm using doesn't like something
00:57:37 <chrisdone> $ hasktags --version
00:57:37 <chrisdone> unrecognized option `--version'
00:57:42 <chrisdone> um. /me slaps the author
00:57:45 <chrisdone> errr
00:57:56 <aleator> ivanm: It's an university machine. Should be 64 actual cores.
00:58:10 <aleator> But only three of the bloody buggers are working for me :/
00:59:09 <chrisdone> ivanm: appears i'm using hasktags 0.68.1. try that?
00:59:24 <ivanm> how did you figure that out?
00:59:39 <chrisdone> ls /home/chris/.cabal/packages/hackage.haskell.org/hasktags/
00:59:48 <ivanm> yeah, I appear to have that as well
00:59:50 <aleator> ivanm: top, mostly.
01:00:00 <ivanm> chrisdone: OK, I opened one of my projects that I haven't used with haskell-emacs before
01:00:06 <ivanm> (i.e. no TAGS file)
01:00:14 <chrisdone> ivanm: with hs-config-echo-all set t?
01:00:14 <ivanm> I add an alias for id in (just to have something)
01:00:19 <ivanm> save the buffer
01:01:09 <ivanm> and in the minibuffer it says: error in process filter: File /home/ivan/Haskell/data/clist/src/TAGS is not a valid tags table
01:01:20 <hpaste_> aleator pasted “Why is my work not parallelizing nicely” at http://hpaste.org/51956
01:01:28 <ivanm> that should be data-clist, not data/clist
01:01:42 <chrisdone> ivanm: with hs-config-echo-all set t?
01:01:42 <aleator> Now it actually does something different when I took the rdeepseq and replaced with rpar.
01:01:46 <ivanm> chrisdone: there is no TAGS file in either data-clist/ or data-clist/src/
01:01:55 <ivanm> chrisdone: where do I set that? in my init stuff?
01:02:07 <chrisdone> ivanm: sure. or M-: (setq hs-config-echo-all t)
01:02:13 <ivanm> C-h v says it's nil
01:02:24 <chrisdone> set it to t
01:02:33 <chrisdone> then you can see the output of the call to hasktags in your *Messages*
01:02:43 <chrisdone> i.e. why it's not working
01:02:52 <ivanm> xargs: hasktags: No such file or directory
01:02:57 <ivanm> so is that a PATH problem?
01:03:22 <aleator> How am I supposed to read +RTS -s output? what is GC time and what is (elapsed)?
01:03:39 <chrisdone> ivanm: hm, seems like it. i guess ~/.cabal isn't in the PATH for emacs
01:03:48 <ivanm> aleator: GC time is how long was spent on garbage collection
01:03:57 <ivanm> aleator: elapsed is how long it actually spent I think
01:04:27 <ivanm> OK, lemme kill emacs and try again, I tried shifting where I define PATH in my .bashrc
01:04:28 <chrisdone> i guess you're launching emacs directly rather than via a shell
01:04:39 <ivanm> yup
01:04:49 <ivanm> via a systemd unit to create a daemon
01:04:49 <aleator> ivanm: So if gc time is huge and elapsed is small, is it still bad?
01:04:52 <chrisdone>  (setenv "PATH" (concat  "/home/chris/.cabal/bin:" (getenv "PATH")))
01:05:04 <chrisdone> maybe this helps, but i'm not sure
01:05:27 <ivanm> (which doesn't seem to remember my recentf list though :@)
01:05:39 <ivanm> aleator: if GC time is huge, that sounds like a problem
01:06:24 <ivanm> chrisdone: OK, that seems to have done it
01:06:37 <chrisdone> ivanm: the setenv? good to know
01:06:38 <Nafai> ivanm: Shouldn't you define your PATH in your .bash_profile?  Isn't that what is evaluated for non-login shells?
01:06:50 <ivanm> I was setting my PATH _after_ the bit in the .bashrc that quit non-interactive shells :s
01:06:54 <aleator> ivanm: ok. So I'm just collecting garbage with my 64 cores :)
01:06:57 <chrisdone> oh, ok
01:07:02 <ivanm> Nafai: .bash_profile calls .bashrc
01:07:10 <tactics> @where parser
01:07:10 <lambdabot> I know nothing about parser.
01:07:14 <tactics> @where parser
01:07:14 <lambdabot> I know nothing about parser.
01:07:21 <tactics> damn typing
01:07:27 <tactics> @where parsers
01:07:28 <lambdabot> I know nothing about parsers.
01:07:30 <ivanm> so it's easier for me to just change .bashrc, especially if I want to update the PATH and then source it in a running terminal
01:07:33 <tactics> >__>
01:07:34 <ivanm> tactics: what do you want?
01:07:37 <ivanm> a parsing library?
01:07:41 <ivanm> @hackage uu-parsinglib
01:07:41 <lambdabot> http://hackage.haskell.org/package/uu-parsinglib
01:07:46 <ivanm> @hackage polyparse
01:07:46 <lambdabot> http://hackage.haskell.org/package/polyparse
01:07:48 <ivanm> @hackage parsec
01:07:49 <lambdabot> http://hackage.haskell.org/package/parsec
01:07:54 <ivanm> @google real world haskell parsec
01:07:56 <lambdabot> http://book.realworldhaskell.org/read/using-parsec.html
01:07:56 <lambdabot> Title: Chapter 16. Using Parsec
01:07:57 <Nafai> ivanm: *nods*
01:07:58 <tactics> I remember seeing a paper on parsers a long time ago, I thought maybe LB could help me remember it
01:08:12 <Nafai> ls
01:08:13 <ivanm> tactics: there are _lots_ of papers on parsers :p
01:08:15 <Nafai> whoops
01:08:19 <ivanm> Nafai: heh
01:08:20 <tactics> ah, monadic parsers is the word I'm thinking of
01:08:25 <tactics> I wanna say it was... Wadler?
01:08:48 <ivanm> chrisdone: OK, next question: any way to try and get it to prompt me to create a project if I open a .hs file before creating said project?
01:08:54 <Nafai> ivanm: you would have thought I would have noticed I was looking at the window not surrounded by the red border...
01:08:55 <ivanm> @google "monadic parsers"
01:08:56 <lambdabot> http://blogs.msdn.com/b/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
01:09:01 <ivanm> heh
01:09:04 <ivanm> @google "monadic parsers" wadler
01:09:06 <lambdabot> http://eprints.nottingham.ac.uk/archive/00000223/01/pearl.pdf
01:09:07 <lambdabot> Title: FUNCTIONAL PEARLS Monadic Parsing in Haskell
01:09:13 <ivanm> tactics: still a rather broad scope
01:09:22 <chrisdone> ivanm: it should do that. it doesn't?
01:09:29 <ivanm> nope
01:09:33 <chrisdone> ivanm: what does it do?
01:09:36 <ivanm> unless there's some setting you added
01:09:40 <ivanm> chrisdone: just bitches usually
01:09:56 <chrisdone> i can't do anything with that
01:10:05 <ivanm> chrisdone: OK, _now_ it does :s
01:10:07 <ivanm> never did before
01:10:14 <chrisdone> ._.
01:10:27 <ivanm> chrisdone: then again, I don't have a default project running like your init.el does
01:10:30 <ivanm> maybe that's why
01:11:16 <ivanm> chrisdone: OK, and that reminds me about something else: can't it remember which dir ghci was in when it restarts?
01:11:28 <tactics> Found the one I remember, Nottingham, it looks like
01:11:35 <ivanm> having to "change directory" when it reloads and then re-load again gets old rather quickly :s
01:11:41 <chrisdone> i don't have any default projects running in my own use either
01:11:45 <ivanm> tactics: that's the uni AFAIK...
01:11:47 <ivanm> chrisdone: huh
01:12:07 <chrisdone> i open a file and it prompts me to create a project based on the cabal file if there is one otherwise the directory
01:12:33 <ivanm> chrisdone: do you have hs-config-echo-all set to t by default?
01:12:43 <ivanm> maybe that's the difference
01:12:57 <ivanm> wait... it just bitched about hasktags not existing still...
01:13:19 <chrisdone> ivanm: i could remember it, yeah. it's mostly a problem of queueing. i don't have a queue for communicating with the inferior process… on account of elisp not having closures, partly
01:13:22 <ivanm> OK, I guess my fix didn't end up working after all
01:13:33 <ivanm> chrisdone: *nod* fair enough
01:13:36 <tactics> ivanm so it is... I really should go to sleep soon.... lol
01:13:37 * ivanm tries setenv
01:13:38 <chrisdone> i have it set to nil
01:13:52 <chrisdone> i only set it to t when i have problems and want to see the unfiltered output
01:15:27 <ivanm> chrisdone: OK, even after using setenv it _still_ can't find hasktags :s
01:16:23 <ivanm> maybe I need to completely log out and in again for the change where PATH is defined to propagate through
01:16:24 <ivanm> *sigh*
01:16:32 <ivanm> chrisdone: so I might bug you about it later this weekend :p
01:16:36 <quicksilver> chrisdone, ivanm : I don't think that emacs searches the env variable PATH after being loaded
01:16:45 <quicksilver> I think it searches the emacs variable exec-path
01:17:05 <quicksilver> (the initial value of exec-path is probably taken from $PATH as you'd expect, but that has to be in place when emacs starts)
01:17:51 <ivanm> OK, setting exec-path doesn't change it either
01:18:27 <ivanm> chrisdone: and if I start the project from the source file rather than the cabal file, it seems to look for the TAGS file in the wrong place (i.e. the location of the source file rather than the location of the project)
01:19:17 * ivanm -> dinner
01:20:36 <Leif_Bork> I need to use a hashmap implementation where the lookup is less than O(n) for small n, like n < 100
01:21:06 <ivanm> Leif_Bork: unordered-containers ?
01:21:32 <Leif_Bork> ivanm: lookup is O(min(n,W))
01:21:54 <ivanm> wait, what's `n' here?
01:22:05 <ivanm> number of values in the map/table ?
01:22:15 <Leif_Bork> Yep!
01:22:16 <ivanm> or number of values with the same hash ?
01:22:35 <Leif_Bork> number of values in the map/table I believe
01:23:14 <ivanm> oh, W is the size of the Int
01:23:25 <ivanm> Leif_Bork: I guess worst case is when everything has the same hash
01:23:40 <ivanm> which is unlikely if you have a good hash, isn't it?
01:23:46 <Leif_Bork> Yep
01:23:58 <ivanm> yet that still isn't good enough for you?
01:24:33 <Leif_Bork> But, I don't understand, W may be like 32 or 64
01:24:44 <ivanm> Leif_Bork: depends upon architecture
01:25:06 <ivanm> on 32bit machines, the maximum number of hashes is the size of a 32bit integer
01:25:12 <ivanm> ditto for 64bit
01:25:22 <ivanm> Leif_Bork: so it places bounds on the maximum number of hashes available
01:25:28 <Leif_Bork> Yep, but if I have a n less than 32 or 64, then the lookup will still be linear time?
01:25:43 <ivanm> Leif_Bork: in the _worst case_
01:25:52 <ivanm> which is when you have all values hashing to the same value
01:26:01 <quicksilver> Leif_Bork: you said n < 100?
01:26:04 <ivanm> and it isn't a matter of n < 32/64
01:26:06 <Leif_Bork> Yep!
01:26:11 <quicksilver> why are you caring about asymptotic complexity if n < 100
01:26:16 <quicksilver> your provlem is not asymptotic
01:26:17 <ivanm> > maxBound :: Int
01:26:17 <lambdabot>   9223372036854775807
01:26:21 <quicksilver> just run it and see if it's fast enough.
01:26:32 <ivanm> Leif_Bork: ^^ I believe that's W for 64
01:26:38 <quicksilver> unordered-containers is probably the fasted, but Data.Map is also quite fast for n < 100
01:26:42 <ivanm> > maxBound :: Word
01:26:43 <lambdabot>   18446744073709551615
01:26:47 <quicksilver> and Data.IntMap too.
01:26:48 <ivanm> ^^ though it could be that
01:26:59 <ivanm> quicksilver: yeah
01:27:04 <Leif_Bork> http://gregorycollins.net/posts/2011/06/11/announcing-hashtables
01:27:18 <ivanm> and even then, unordered-containers is only good for Strings, etc. where comparisons are expensive
01:27:22 <ivanm> Leif_Bork: what is your key type?
01:27:57 <Leif_Bork> I saw some benchmarks, but that's for elements large than 256 or something, on that page
01:28:08 <Leif_Bork> ByteStrings and ids
01:28:13 <ivanm> Leif_Bork: yeah, but note that that's using a mutable data structure
01:28:13 <Leif_Bork> ints
01:28:23 <ivanm> Leif_Bork: for Ints, you don't want a hash table
01:28:28 <ivanm> use IntMap or regular old Map
01:28:36 <Leif_Bork> Aah
01:29:11 <ivanm> Leif_Bork: the whole point of unordered-containers is: "Map String a" is expensive because the definition of compare for Strings is expensive
01:29:34 <ivanm> hashing to an Int and then looking up an Int is cheaper than trying to look up a String
01:29:40 <ivanm> similarly for Bytestring, Text, etc.
01:29:48 <ivanm> anything with that kind of recursive comparison
01:30:02 <chrisdone> hackage is buggered at the moment. where can i get a markdown→html encoder?
01:30:24 <chrisdone> preferrably not pandoc…
01:30:30 <akosch> I'm trying to write a small app that uses a database connection. Normally I would consider a global variable (or a singleton pattern) for storing the connection since its usage is nearly ubiquitous in the application and I don't want to pass it around explicitly to all my functions, but I've heard one can use the reader monad to do the plumbing: could you give me some hints (maybe examples) on this?
01:30:48 <Leif_Bork> Are hashing slow for bytestrings?
01:31:01 <ivanm> yes
01:31:07 <ivanm> wait, I mean no
01:31:12 <ivanm> not compared to repeated comparisons
01:31:19 <ivanm> chrisdone: not for me it isn't
01:31:23 * hackagebot bpann 0.1 - backpropagation neuronal network  http://hackage.haskell.org/package/bpann-0.1 (RobertSteuck)
01:31:28 <ivanm> chrisdone: though burp was having trouble earlier
01:31:34 <ivanm> chrisdone: why not pandoc? license?
01:31:48 <chrisdone> yes, license
01:32:03 <ivanm> chrisdone: http://hackage.haskell.org/package/sundown
01:32:07 <quicksilver> I think it's quite debate
01:32:19 <quicksilver> debatable whether hashing is faster than comparisons for bytestrings
01:32:33 <ivanm> quicksilver: is it? I thought the issue was _repeated_ comparisons
01:32:37 <quicksilver> if bytestrings differ in the first byte (which might be very likely indeed) then comparison is really quite fast.
01:32:42 <ivanm> especially when you may have a lot of similar data
01:32:55 <ivanm> which is the situation that tibbe had
01:32:58 <quicksilver> hashing has to process the entire string.
01:33:04 <quicksilver> sure, there are definitely cases when it's a win
01:33:06 <hjulle> lambdabot
01:33:08 <quicksilver> but it's quite subtle.
01:33:46 <engla> hashing doesn't *have* to process the entire string
01:33:56 <ivanm> quicksilver: right, so it's a matter of benchmarking and comparing data structures
01:34:07 <ivanm> same as any choice of data structure
01:34:21 <ivanm> e.g. I found in my case that IntMap was if anything slightly more expensive than Map Int
01:34:55 <ivanm> probably because by design I tend to have keys of 1, 2, 3, 4, ... with very few gaps if any
01:36:02 <chrisdone> ivanm: thanks, i'll try it
01:36:21 <chrisdone> ivanm: er. hackage is buggered here. it just hangs
01:36:24 <ivanm> chrisdone: why, what's your use case that you can't use GPL'd libraries?
01:36:47 <ivanm> chrisdone: as in you can't even see the web page?
01:36:52 <ivanm> it's bindings to a C markdown library
01:36:54 <ivanm> is that OK?
01:36:57 <chrisdone> ivanm: yeah, it's just a white page hanging
01:37:06 <quicksilver> hackage doesn't work for me eitehr this morning
01:37:12 <ivanm> weird
01:37:14 <quicksilver> hackage ---> UK is borked.
01:37:15 <chrisdone> ivanm: uh, no, that sucks. nevermind. i just need String -> Html where links are replaced with actual links. i'll do it myself
01:37:42 <ivanm> well, one of the string templating libraries might work
01:37:51 <ivanm> and I can give you the github link for sundown if you want it
01:38:14 <ivanm> https://github.com/rostayob/sundown
01:38:24 <chrisdone> it's ok, thanks. i'll just do a replacement myself
01:38:31 <ivanm> dcoutts: do you know of any problem not being able to access Hackage?
01:38:37 <chrisdone> licenses are problematic due to management
01:38:44 <ivanm> chrisdone: *nod*
01:39:06 <ivanm> burp: you're not the only one having hackage problems
01:40:20 <burp> yeah, I checked it from some other location through ssh earlier, where it did not work either
01:45:11 <Leif_Bork> ivanm, quicksilver: Thanks for the discussion!
01:45:17 <chrisdone> ivanm: we will be releasing this one open sores anyway, but i'd prefer to maintain my BSD purity
01:45:32 <burp> I'm using this right now http://anonymouse.org/cgi-bin/anon-www.cgi/http://hackage.haskell.org/packages/hackage.html
01:45:33 <rostayob> o
01:45:49 <rostayob> i've heard a lot of complains regarding pandoc & GPL
01:45:51 <rostayob> *complaints
01:46:10 <rostayob> maybe someone should convince jmc to released it with BSD?
01:47:01 <moriramar> Excuse me, when I check ":i Eq" in ghci, I found things like "instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) => Eq (a, b, c, d, e, f, g, h)", are those tuple instances defined in this way one by one?
01:47:18 <rostayob> moriramar: yes
01:47:56 <shachaf> moriramar: Well, I doubt they're defined by hand.
01:48:14 <rostayob> but there is no way to define them all
01:48:18 <rostayob> in the same instance
01:48:20 <shachaf> moriramar: But they're derived only up to a finite tuple size in GHC.
01:49:18 <moriramar> shachaf, So there is some tricks in GHC to handle this?
01:49:54 <rostayob> moriramar: as far as i know for your own classes the most common way is to do it manually
01:50:07 <rostayob> maybe you can play some tricks with TH
01:50:19 <shachaf> moriramar: Don't use tuples that big ever.
01:50:32 <moriramar> rostayob, shachaf: Thanks.
01:52:48 <burp> @hoogle punycode
01:52:48 <lambdabot> No results found
01:56:01 <quicksilver> moriramar, rostayob, shachaf: recent GHCs have support for 'deriving Generic' and then, I think, Eq instances can be automatically derived for instances of Generic.
01:56:39 <quicksilver> the declarate looks something like data (,,,,,,,) a b c d e f g h = (,,,,,,,) a b c d e f g h deriving Generic
01:56:44 <quicksilver> it's in GHC/Tuple.hs
01:56:54 <shachaf> quicksilver: Right, but that's no different from deriving Eq, is it?
01:57:23 <rostayob> quicksilver: yeah but there is no easy solution with user defined type classes
01:57:28 <quicksilver> rostayob: yes, there is
01:57:32 <quicksilver> for some values of 'Easy'
01:57:43 <rostayob> quicksilver: to derive instances for all tuple sizes in one go?
01:57:43 <quicksilver> you can use the generic instance to write them.
01:57:59 <quicksilver> well you still need to write the deriving command, but not the methods.
01:58:20 <rostayob> with generic you mean Data and Typeable?
01:58:31 <quicksilver> no
01:58:35 <quicksilver> I mean 'Generic'.
01:58:40 <rostayob> @hoogle Generic
01:58:41 <lambdabot> Data.Generics.Aliases type Generic c = a -> c a
01:58:41 <lambdabot> Data.Generics.Aliases data Generic' c
01:58:41 <lambdabot> Data.Generics.Aliases Generic' :: Generic c -> Generic' c
01:58:56 <quicksilver> that's why I said recent GHCs have support for 'deriving Generic'
01:59:01 <quicksilver> and why I didn't mention Data or Typeable.
01:59:06 <quicksilver> (sorry, I'm grouchy this morning)
01:59:10 <beroal> hello. how can I find which installed package a specified module belongs to? ghci or cabal or ghc-pkg?
01:59:20 <quicksilver> http://www.google.co.uk/search?gcx=w&ix=c2&sourceid=chrome&ie=UTF-8&q=GHC+Generic+deriving
01:59:36 <quicksilver> ^^ none of the relevant pages load for me due to hackage being down for me, but the stuff is there.
01:59:46 <quicksilver> I don't remember how easy it is to write instance decls; I've never played with it.
02:00:06 <rostayob> quicksilver: ok, never used that. you can derive write something that derives instances for n-size tuples?
02:00:40 <rostayob> it sounds strange because afaik to write an instance you have to go through writing "instance ... where ..."
02:00:49 <rostayob> maybe it makes writing those easier
02:00:54 <rostayob> but still, that's not a big advantage
02:01:16 <rostayob> i think what moriramar was complaining about is that you have to instantiate for every single tuple size
02:01:39 <quicksilver> it doesn't solve that
02:01:45 <quicksilver> but it does mean you don't have to actually write the methods
02:01:53 <quicksilver> you just have to say "Make me an instance"
02:02:05 <rostayob> yeah
02:02:16 <rostayob> still quite tedious
02:03:04 <moriramar> quicksilver, you typed so fast that I just finished reading first page... thank you very much, and i think i need some time to learn this... :)
02:03:18 <rostayob> ah, Generic c = forall a. Data a => c a
02:03:18 <quicksilver> rostayob: pretty trivial to solve with m4 or cpp or TH
02:03:30 <rostayob> quicksilver: yep
02:03:43 <quicksilver> rostayob: oh, is that all it is? boggle
02:03:54 <rostayob> but it's probably not worth it, you should just stop at a 5 tuple or whatever
02:04:12 <quicksilver> rostayob: I don't think it is
02:04:21 <quicksilver> rostayob: http://haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/src/GHC-Generics.html
02:04:37 <quicksilver> type Rep a :: * -> *; from  :: a -> (Rep a) x; to    :: (Rep a) x -> a
02:04:51 <quicksilver> this is something more than just forall a . Data a => c a
02:04:56 <quicksilver> it's nicer to work with.
02:05:03 <rostayob> quicksilver: ok, hoogle is failing me
02:05:24 <quicksilver> it's all new
02:05:36 <quicksilver> the links on the googl esearch I posted have the details as far as I can recall but I can't read them :)
02:06:01 <rostayob> quicksilver: yep reading now, thanks
02:06:08 <rostayob> new = 7.2.x?
02:06:15 <quicksilver> probably is this is the 3rd (?) thing that GHC has had called 'generics'
02:06:16 <quicksilver> so it's quite confusing
02:06:19 <rostayob> yeah, it's confusing
02:06:20 <quicksilver> you find old docs and new docs
02:06:26 <quicksilver> and they are talking about different things
02:06:31 <quicksilver> although, all trying to solve related problems
02:06:34 <quicksilver> (but in different ways!)
02:07:17 <rostayob> mah, there's too much stuff floating around regarding that
02:07:31 <rostayob> syb, whatever-plate
02:08:07 <rostayob> i personally don't really know the difference between all those and just use syb
02:08:11 <rostayob> but i'm probably missing out
02:09:11 <rostayob> but we should decide for a "final" library to do generic operations
02:09:27 <quicksilver> the problem is nobody has found a way everyone can agree is the best
02:09:32 <quicksilver> Data was pretty horrendous to use
02:09:41 <quicksilver> uniplate was simpler but limited in scope.
02:09:57 <quicksilver> this new one is the first time (AFAIK?) that people have tried to use type families to make it more convenient
02:11:04 <rostayob> mhm, Data is not too bad imho
02:42:15 <Johannes2> Hi! I'm kind of new. Is it possible to define the == operation across different data types? Say... if I have a datastructure of kingdoms and a datastructure of phyla, I'd like to be able to have Animalia == Chordata evaluate as True
02:44:04 <Johannes2> Rather than just Animalia == Animalia, or Chordata == Chordata
02:44:09 <Johannes2> Supposing, for instance...
02:44:12 <rostayob> Johannes2: yes, you want to read up about type classes
02:44:17 <rostayob> wait
02:44:27 <rostayob> you want to use == across different data types?
02:44:32 <Johannes2> Yep. Does that work?
02:44:34 <rostayob> :t (==)
02:44:35 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:44:41 <rostayob> nope
02:44:43 <Johannes2> Oh :(
02:44:46 <Johannes2> What a pity.
02:44:48 <Johannes2> Thank you.
02:44:53 <Guest50756> you're not modelling equality anyway
02:45:05 <Guest50756> so you may want to make your own operator instead
02:45:09 <rostayob> yeah
02:45:10 <Guest50756> and a typeclass to match
02:45:41 <Guest50756> what you're trying is model is 'is-subset-of'
02:45:54 <Guest50756> i.o.w., ancestory
02:48:42 <cheater> updated: http://cheater.posterous.com/why-haskell-talk
02:50:46 <Chaze> cheater: no video? maybe i'm missing the link
02:51:07 <cheater> i think edwardk has recorded something
02:51:17 <cheater> i'll put it up when he has uploaded it
02:58:02 <cheater> updated: http://cheater.posterous.com/first-haskell-script
02:59:36 <quicksilver> cheater: that's cool stuff.
02:59:44 <quicksilver> I'm not sure #!...runhaskell is a good idea, though.
03:00:14 <flux> quicksilver, how come?
03:00:40 <cheater> quicksilver: why?
03:07:08 <quicksilver> cheater: well, it is unoptimised
03:07:24 <quicksilver> so it will be a bit slow for some things. I would always compile my haskells scripts myself
03:07:26 <cheater> so what
03:07:30 <kmc> premature optimization
03:07:36 <cheater> premature ejaculation
03:07:40 <kmc> we're comparing to sh or perl scripts here
03:07:54 <kmc> the start-up time is worse than sh or perl, though
03:08:02 <cheater> who cares
03:08:02 <rostayob> yeah
03:08:24 <kmc> would be nice to have a #! wrapper which caches compilation results
03:08:33 <rostayob> cheater: well if you run the same haskel script a lot of times, runhaskell is quite bad
03:08:35 <kmc> transparently
03:08:36 <kmc> without shitting all over the directory where you're storing the scripts
03:08:36 <cheater> kinda like python's caching hell?
03:08:42 <cheater> rostayob: or is it
03:08:50 <quicksilver> kmc: it is premature optimisation, you're right.
03:09:05 <rostayob> but yeah it's good for exercising i guess
03:09:10 <quicksilver> but there are cases where the even the asymptotic behaviour is worse (fusion etc)
03:09:24 <quicksilver> and generally speaking, most haskell libraries are tested and debugged for the compiled case.
03:11:26 <quicksilver> so what's the tradeoff?
03:11:35 <quicksilver> having to manage a source directory separately, I suppose
03:11:48 <quicksilver> I've just never really considered using runhaskell scripts
03:11:55 <quicksilver> to me, using runhaskell seems a premature optimsation
03:12:01 <quicksilver> (optimising for deployment time, or something)
03:12:33 <engla> is there a nicer way to write  let h = ((f .) . g)  (composing so that h x y = f (g x y)) or a nice name to give this as infix operator?
03:12:57 <rostayob> h x = f . (g x)?
03:12:58 <engla> kmc: I'm pretty sure such a cached version of runhaskell exists, even though I can't link it
03:14:43 <quicksilver> engla: it has been called .: by some people
03:14:56 <quicksilver> I must admit I don't think it's worth naming, myself.
03:19:44 <cheater> how on earth do i make my .hs script into a module now?
03:19:54 <cheater> i tried putting module Greet where at the top of the file
03:21:49 <cheater> that does not work though
03:21:58 <quicksilver> cheater: what does "does not work though" mean?
03:22:00 <kmc> is it named Greet.hs?
03:22:02 <quicksilver> give us more information.
03:22:04 <cheater> yes kmc
03:22:15 <cheater> i go into ghci and do :m + Greet
03:22:26 <quicksilver> :m doesn't load modules
03:22:29 <int-e> :load Greet.hs
03:22:55 <quicksilver> :m just alters the scope of the interpreter
03:23:01 <quicksilver> as int-e says, :load
03:23:08 <cheater> oh
03:23:57 <int-e> (the .hs is optional)
03:23:58 <cheater> cool thank you
03:24:07 <cheater> int-e: yeah i have noticed :)
03:24:12 <int-e> (and :l works, too.)
03:24:37 <cheater> yup very nice
03:24:37 <int-e> and btw it was a module before, too -- called Main, implicitely.
03:25:04 <cheater> yeah but that was only accessible when Greet.hs was being executed
03:25:10 <cheater> and not from external scripts or ghci right?
03:25:54 <quicksilver> you could have :loaded Greet.hs without a module decl
03:25:59 <int-e> you'd have trouble 'import'ing it from anywhere else. yes.
03:58:55 <engla> quicksilver: thanks for the info anyway
04:00:05 <cheater> http://cheater.posterous.com/type-diff
04:00:08 <cheater> any thoughts, guys?
04:00:21 <cheater> "Idea: type-diff, a tool for managing code in Haskell and other type-inferred languages"
04:01:42 <ivanm> cheater: I don't know about having it at the SCM level
04:02:00 <ivanm> I keep changing types of my functions all the time, and I wouldn't want my SCM to bitch at me about it
04:02:23 <ivanm> but something on hackage that says "O HAI, here are the backwards-incompatible changes!" would be cool
04:02:24 <engla> rostayob: thanks also, h x = f . (g x)  is a good "picture"
04:02:26 <cheater> why would it bitch?
04:02:32 <ivanm> cheater: well, whatever it does
04:02:32 <cheater> it's just a new kind of diff
04:02:38 <cheater> you can see it if you want
04:02:46 <cheater> you can not-see it if you don't
04:02:48 <ivanm> hmmm
04:02:56 <cheater> just like when you use hg diff
04:02:58 <cheater> or hg blame
04:03:00 <cheater> etc
04:03:01 <ivanm> it also means IIUC that the SCM is really only aimed at source code
04:03:12 <cheater> well, not really
04:03:16 <ivanm> not as much at other textual stuff
04:03:21 <ivanm> e.g. documentation
04:03:27 <cheater> there's no reason hg couldn't have a plugin that does that
04:03:36 <cheater> and the plugin could only be invoked on hs files
04:03:41 <ivanm> it would also need to have per-language specific stuff to get the types
04:03:47 <ivanm> it's an interesting concept though
04:03:47 <cheater> yes, it would
04:03:53 <ivanm> so when are you going to implement it? :p
04:03:56 <cheater> no u
04:05:09 <ivanm> yeah, no
04:05:16 <ivanm> I do stuff with graphs
04:05:34 <ivanm> text-based stuff sounds boring ;)
04:05:34 <cheater> it's graphs
04:05:39 <cheater> you need to diff graphs
04:05:50 <ivanm> O Wow!
04:05:57 <cheater> see
04:06:03 <cheater> now you're devving
04:06:10 <ivanm> or not
04:06:23 <cheater> is there actually a good way to diff graphs?
04:06:48 <ivanm> not really AFAIK
04:06:53 <cheater> why?
04:07:07 <cheater> i mean you can easily reason about graphs being subgraphs of others
04:07:17 <ivanm> sure
04:07:28 <cheater> and delta-Y transformations
04:07:33 <ivanm> but for starters, most graph serialisation formats only care about undirected unlabelled graphs
04:07:37 <ivanm> so you're limited right there
04:07:47 <cheater> aha
04:07:55 <cheater> why do they?
04:08:08 <ivanm> because the people that implemented them wanted them that way
04:08:17 <cheater> ok
04:08:20 <ivanm> we're talking about graph theoreticians here
04:08:36 <ivanm> and in terms of algorithmic development, etc. you normally consider undirected graphs
04:09:00 <hjulle> > take 10 $ fix$(<$>)<$>(:)<*>((<$>((:[])<$>))(=<<)<$>(*)<$>(*2))$1
04:09:00 <ivanm> the recursive nature of graphs make it difficult
04:09:00 <lambdabot>   [1,2,4,8,16,32,64,128,256,512]
04:09:28 <ivanm> cheater: even something as simple as an Ord definition for a graph: how do you compare graphs that have no commonalities?
04:09:45 <cheater> how do you diff files that have no commonalities?
04:09:46 * ivanm gibbers at hjulle's fragment
04:09:49 <cheater> that question is answered for you
04:09:51 <ivanm> cheater: true
04:10:14 <hjulle> (Source
04:10:18 <ivanm> cheater: but, say you have two graphs on n vertices
04:10:41 <ivanm> because you usually normalise graphs before serialising, etc. they both use the vertices 1..n
04:10:53 <cheater> yeah you don't do that
04:11:01 <ivanm> it so happens that they have an edge 1-2
04:11:02 <hjulle> (Source: http://uncyclopedia.wikia.com/wiki/Haskell)
04:11:09 <cheater> you find common vertices by comparing the values of vertices
04:11:12 <ivanm> even though they otherwise they're completely different
04:11:16 <ivanm> e.g. a star graph vs a cycle
04:11:28 <ivanm> cheater: that's just it: what is the "value" of a vertex?
04:11:36 <ivanm> cheater: then you have to consider isomorphic copies
04:11:41 <cheater> something that you put on that vertex
04:11:46 <ivanm> maybe the two graphs _are_ the same isomorphically speaking
04:12:02 <ivanm> cheater: as I said: representation wise on what a graph is, most don't
04:12:13 <cheater> yeah that's more advanced, for a start it's enough if the same values are seen as the same and different values are seen as different
04:12:14 <ivanm> cheater: OK another example
04:12:27 <ivanm> let's consider contacts
04:12:34 <ivanm> no, wait, that's a bad example
04:13:02 <ivanm> cheater: OK, let's consider call graphs
04:13:06 <ivanm> we could have two call graphs
04:13:12 <cheater> this is not a call graph
04:13:26 <ivanm> cheater: you're the one who said diffing of graphs!
04:13:37 <ivanm> and I'm trying to demonstrate that it doesn't make sense in general!
04:13:38 <cheater> you're the one who's taking things out of context :)
04:13:45 <ivanm> O RLY?
04:13:47 <cheater> who cares about the general?
04:13:56 <cheater> he can fuck off to the war room
04:14:04 <ivanm> ummmm..... I do?
04:14:16 <cheater> do you want a medal? ;)))
04:14:16 <ivanm> well, not about some particular individual with a title/rank of "General"
04:14:22 <ivanm> nope
04:14:27 <ivanm> already got too many
04:14:28 <cheater> ok :))
04:14:46 <ivanm> and I should hit the sack anyway
04:14:48 <ivanm> g'night all
04:15:00 <cheater> eheh
04:15:05 <cheater> thanks for the chat ivanm
04:15:09 <ivanm> np
04:15:17 <cheater> good night to you :)
04:41:14 <Twey> Hm… I'm trying to create an interface with Glade, but I keep getting an error ‘Expected <glade-interface>.  Got <interface>.’
04:42:05 <Twey> Glade doesn't seem to be producing the output the glade package expects… how can I fix this?
04:46:23 <Twey> I've tried choosing GtkBuilder or Libglade format in the save dialogue for Glade, but it produces the same output either way
04:46:32 * hackagebot binary-state 0.1.1 - Simple wrapper around Data.Binary, which adds StateT to Get/Put monads.  http://hackage.haskell.org/package/binary-state-0.1.1 (IlyaPortnov)
04:54:51 <Twey> http://projects.haskell.org/gtk2hs/docs/tutorial/glade/ — I'm basically just doing this
05:17:03 <AfC> Twey: are you using Glade >= 3 and GTK >= 3.0?
05:19:45 <Twey> AfC: Yes
05:26:32 * hackagebot hs-java 0.2 - Java .class files assembler/disassembler  http://hackage.haskell.org/package/hs-java-0.2 (IlyaPortnov)
05:30:23 <Twey> AfC: Is that a problem?
05:30:52 <AfC> Twey: and, is gtk2hs actually a GTK 3 app?
05:31:07 <AfC> s/app/library/
05:31:26 <AfC> (I should know the answer to that, but)
05:35:50 <Twey> AfC: I *believe* so.  The tutorial says it was updated for GTK3+Glade3.
05:40:16 <saml> hello, i'm here to help with you with haskell questions
05:41:30 <antihoax> hi
05:41:32 <antihoax> :)
05:41:35 <antihoax> where to start?
05:42:19 <saati_> antihoax: http://learnyouahaskell.com/chapters
05:45:24 <antihoax> ;<
05:45:43 <antihoax> why do i need capital first letter for True and False ?
05:46:01 <saati_> all constructors need capital letters
05:46:23 <antihoax> its uncomfortable to write those
05:46:43 <saati_> i suggest using another language if it really bothers you
05:46:51 <wunki> is there someone willing to proof read a post I just wrote about currying. http://s3.wunki.org/posts/2011-09-30-curry-and-its-partial-application.html
05:47:01 <wunki> I'm new to Haskell and there could be some mistakes.
05:47:11 <wunki> or some things left out.
05:47:21 <dibblego> not all constructors need to start with capital letters, but no constructors start with lower-case letters
05:47:34 <AfC> Twey: anyway, libglade expects <glade-interface> and GtkBuilder expects <interface>
05:47:34 <antihoax> or i may parse the constant list with a bash script and lowercase all if there is any
05:47:45 <Twey> antihoax: [true, false] = [True, False]
05:48:10 <Twey> True and False aren't ‘constants’ in the sense you probably mean it — they're constructors for the Bool type
05:48:14 <Twey> (hence the capitals)
05:48:27 <Twey> AfC: Hm
05:49:02 <Twey> AfC: The problem is that I can't find a way to use GtkBuilder with Gtk2Hs, and I can't find a way to make Glade3 output libglade format :-\
05:49:03 <AfC> Twey: so the error you're getting implies that it is [old] libglade being used, not [new since Gtk 2.20 or so] GtkBuilder
05:49:19 <Twey> Yeah
05:49:22 <AfC> Twey: are you already experienced with GTK hacking?
05:49:26 <Twey> Not really
05:49:30 <AfC> Twey: ok
05:49:52 <Twey> I have GTK2.24 and GTK3.0 installed
05:50:08 <AfC> Twey: I recommend (and, for context, I am the lead author and maintainer of the java-gnome bindings; I've been helping people new to GTK in not-C languages for a *long* time)
05:50:20 <Twey> My libglade is 2.6.4
05:50:38 <AfC> Twey: that you just work directly with widgets (ie instantiate them yourself) rather than worrying about the Glade designer at this point.
05:51:08 <AfC> Glade is fascinating, but in my experience it is a layer of complexity that gets in the way of GTK beginners.
05:51:11 <Twey> I assumed that by ‘GTK hacking’ you meant delving deep into its guts :þ
05:51:19 <Twey> I'm relatively competent with actually just using GTK
05:51:23 <AfC> Ah
05:51:31 <AfC> Well, then you know what I'm talking about :)
05:51:38 <AfC> Right, in that case:
05:52:02 <AfC> Twey: the problem is that libglade links against libgtk 2.x you can't use it in a GTK 3.x program
05:52:35 <Twey> Hm, okay
05:52:38 <AfC> The mere fact that gtk2hs is [still] presenting libglade bindings would suggest to me that it's not built against GTK 3.
05:52:44 <AfC> But I am inferring here.
05:53:04 <AfC> As I said, finding out about the _actual_ state of play is on my TODO list
05:53:26 <Twey> Aha!
05:53:31 <Twey> I see, I think
05:53:44 <AfC> $ apt-cache depends libghc6-gtk-dev
05:53:50 <AfC>   Depends: libgtk2.0-dev
05:53:54 <Twey> So I should just be using Builder, direct from Gtk2Hs (which includes Builder bindings) rather than using libglade at all?
05:54:05 <AfC> Twey: close
05:54:13 <AfC> Twey: "Glade" is the program, the UI designer.
05:54:24 <AfC> Twey: originally, it just wrote out prototype stubs of .c files
05:54:50 <AfC> Twey: then, about ~2001?, James Henstridge wrote libglade which parsed Glade's internal project files and at runtime instantiated widgets
05:55:50 <AfC> Twey: it is libglade 2.6.x [library] external to GTK that was replaced/superseded  by GtkBuilder [class] in GTK directly.
05:56:04 <Twey> Right
05:56:09 <AfC> GtkBuilder does what libglade did
05:56:12 <llano> then, can glade be used in haskell's UI design?
05:56:15 <antihoax> would there be any negative effects of enabling all lowercase function names ?
05:56:19 <AfC> <interface> and <glade-interface> respectively
05:56:28 <saml> antihoax, what do you mean?
05:56:48 <antihoax> parse the ghc source with dd conv=lcase for example
05:57:02 <AfC> llano: yes, assuming you are a) writing an old style .glade file with Glade, and b) assuming gtk2hs is still a GTK 2.x bindings.
05:57:09 <tdammers> haskell is case-sensitive, and whether an identifier starts with an uppercase or lowercase character is syntactically significant
05:57:20 <antihoax> i know
05:57:27 <tdammers> changing everything to lowercase would simply break it
05:57:35 <antihoax> and what if i change all function names to lowercase?
05:57:43 <tdammers> why would you want to do that?
05:57:51 <AfC> [if someone who hacks on gtk2hs can comment on whether / if they are going to bump their coverage to GTK 3.x, that would be lovely]
05:57:54 <antihoax> so i dont have to reach for the shift every time
05:58:01 <Twey> AfC: I need to run to a lecture, but thank you for your help — I may pester you some more at a later date ☺
05:58:02 <AfC> [I'd be happy to advise them based on what I did with the Java bindings]
05:58:09 <AfC> Twey: feel free.
05:58:38 <antihoax> i assume there isnt any tRue and trUe reserved keys ...
05:58:48 <antihoax> or TRuE
05:59:29 <tdammers> look, Haskell has a pretty decent convention in place; it's best to just stick with that
06:00:26 <antihoax> so rather write a script to change function names to required case then compile?
06:00:54 <tdammers> no - jsut write your code to fit the accepted standard
06:01:11 <AfC> antihoax: it's the language's lexical convention. You should stick with it, especially since the compiler enforces some of it
06:02:02 <quicksilver> in fact, function names can be all lowercase, which was what antihoax first said
06:02:10 <quicksilver> it's constructors that have to start with a capital letter
06:02:14 <antihoax> does not accepting value "true" as true sounds lame
06:02:29 <quicksilver> without that, you wouldn't know how to parse "case x of nothing -> ... "
06:02:47 <quicksilver> antihoax: you can certainly write "true = True" if that annoys you ;)
06:02:55 <quicksilver> although you won't be able to pattern match on true.
06:02:58 <igstan> antihoax: for how long are you studying Haskell? You should give it some time until you understand more of it.
06:03:11 <antihoax> well many hours
06:03:16 <llano> AFC: so after using glade to design, then gtk2hs makes it binding with other haskell code?
06:03:30 <AfC> llano: sure
06:04:03 <antihoax> but dont see a reason why it is required to write "Char" "True" "False"
06:04:13 <igstan> antihoax: studying more you'll find many reason for having type constructors start with an uppercase letter, like the fact that having them otherwise will cause clases with type variables
06:04:31 <igstan> I meant "clashes"
06:04:35 <tdammers> maybe you just need to study for many more hours
06:04:36 <AfC> llano: you can use Glade to do the outer structure & layout of a Window. Quite effective for that, and makes it handy when you have complicated container nesting. It's also good for GtkLabels
06:04:37 <AfC> [which a) you don't want to bother coding, and b) you have the text there in once place making translation a little easier]
06:05:11 <AfC> llano: BUT, in my experience, Glade has been more trouble than it has helped, because, frankly, almost everything I code involves dynamics layout.
06:05:24 <AfC> You've got to write code eventually. So just write code.™
06:06:11 <AfC> ie, You can still make lovely GTK UI without using Glade to build the outer structure.
06:06:16 <AfC> but it is *awesome* for prototyping.
06:06:36 <antihoax> btw wanted to study haskell 2 years ago but there is a never fixed floating point exception bug that i had
06:06:49 <AfC> But you can decide for yourself; plenty of projects use it heavily for main GtkWindows, GtkDialogs, you name it
06:06:50 <antihoax> and couldnt recompile
06:08:37 <antihoax> actually its not the true that bothers me, i have always used 1 instead
06:08:56 <tdammers> that won't work in haskell
06:09:01 <tdammers> :t True
06:09:02 <lambdabot> Bool
06:09:02 <antihoax> eh
06:09:05 <tdammers> :t 1
06:09:06 <lambdabot> forall t. (Num t) => t
06:09:53 <malorie> `bin s = sum $ zipWith (*) (fmap (2 ^) [0..]) $ reverse $ fmap digitToInt s' <- can somebody think of a more elegant implementation?
06:10:56 <bscarlet> on the other hand Haskell can understand that 0 might be an Int, and Integer, a Float, etc. (e.g. no need for different 0, 0f, 0.0, etc).
06:11:32 * hackagebot dvdread 0.1 - A monadic interface to libdvdread  http://hackage.haskell.org/package/dvdread-0.1 (NicolaSquartini)
06:12:18 <moriramar> @pl \x -> f x (g x)
06:12:18 <lambdabot> ap f g
06:12:45 <antihoax> and the 800MB library is needed to assume what will the type be right?
06:12:48 <ion> > foldl' (\acc x -> acc*2+x) 0 [1,0,1,0,1]
06:12:49 <lambdabot>   21
06:13:21 <ion> > (foldl' (\acc x -> acc*2+x) 0 . map digitToInt) "10101"
06:13:23 <lambdabot>   21
06:15:07 <bscarlet> malorie: how about using readInt?
06:15:57 <malorie> ion: nice. what's the difference between foldl and foldl' though?
06:16:38 <saati> strictness
06:16:55 <ion> malorie: foldl' is the strict version of foldl. Always use it unless you have a good reason not to.
06:17:15 <malorie> what does 'strict' mean?
06:17:28 <saati> malorie: not lazy evaled
06:18:59 <malorie> bscarlet: I wasn't aware of readInt, thanks
06:19:13 <moriramar> ion, Does strictness analysis help when using foldl?
06:19:16 <ion> Upon evaluation, foldl (\acc x -> acc*2+x) 0 [1,0,1,0,1] first creates a thunk for ((((0*2+1)*2+0)*2+1)*2+0)*2+1 and that can be evaluated by the caller. foldl' forces the evaluation of the accumulator during each step.
06:19:32 <malorie> ah. I see
06:24:28 <ion> moriramar: Perhaps, it depends. Better to use foldl' explicitly to make sure.
06:26:12 <antihoax> if i write any formula in haskell functions calling each other will haskell optimize it ?
06:26:25 <antihoax> or run them recursively
06:26:33 <dylukes> could someone help me derive Data for
06:26:33 <dylukes> newtype Process s a = Process { runProcess :: StateT s Remote.ProcessM a }
06:26:33 <dylukes>   deriving (Functor, Applicative, Monad, MonadIO, MonadState s, Typeable)
06:26:48 <dylukes> if I try to derive Data it complains that theres no Data instance for StateT s m a.
06:26:55 <dylukes> And I'm not sure what context I need.
06:27:48 <dylukes> I'm trying
06:27:49 <dylukes> deriving instance (Data s, Data m, Data a) => Data (StateT s m a)
06:27:57 <dylukes> but
06:27:58 <dylukes>     Kind mis-match
06:27:58 <dylukes>     The second argument of `StateT' should have kind `* -> *',
06:27:58 <dylukes>     but `m' has kind `*'
06:27:59 <moriramar> antihoax, tail-recursive optimization might help, depending on the actual function you implemented.
06:28:05 <dylukes> I guess m shouldn't be Data
06:28:10 <saml> antihoax, haskell is optimize for web scale
06:28:36 <antihoax> saml<< what do you mean by that?
06:29:10 <saml> antihoax, it means you write haskell programs for the cloud
06:29:24 <bscarlet> saml: you're not helping.
06:29:33 <saml> what was the question?
06:29:57 <moriramar> saml, "if i write any formula in haskell functions calling each other will haskell optimize it  or run them recursively? "
06:30:06 <tdammers> antihoax: http://book.realworldhaskell.org/read/profiling-and-optimization.html
06:30:20 <saml> lol
06:30:32 <tdammers> also: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
06:30:34 <saml> antihoax, how will you optimize infinite loop?
06:30:54 <antihoax> wasnt meaning any loops, just logic functions
06:31:09 <tdammers> I think what antihoax means is whether ghc will optimize redundant function calls away
06:31:29 <bscarlet> antihoax: Are you thinking in terms of the costs of running recursive functions in a language like C? Haskell execution doesn't really work like that.
06:32:22 <tdammers> there are these two things, lazy evaluation and purity
06:32:26 <bscarlet> antihoax: which is one way of saying it will be optimized.
06:32:28 <cheater> "if i write any formula in haskell functions calling each other will haskell optimize it  or run them recursively? " << what you're talking about is fusion
06:32:33 <tdammers> the combination allows for pretty aggressive optimizations
06:32:38 <cheater> i think haskell does that well but i'm not sure
06:32:49 <cheater> talk to roconnor_
06:32:59 <antihoax> i was thinking about if i need to optimize my function or no matter how many functions i define, it will not have unnecessary logical ands, nots for example
06:33:38 <bscarlet> antihoax: in general, you can just trust the optimizer for stuff like that.
06:33:46 <antihoax> ok thanks
06:34:11 <cheater> trying to optimize away basic logic functions?
06:34:18 <cheater> you're doing something wrong.
06:34:33 <dylukes> :<
06:34:36 <tdammers> read the first thing I linked
06:34:37 <dylukes> so
06:34:38 <dylukes> deriving instance Typeable (StateT s m a)
06:34:43 <dylukes>     Can't make a derived instance of `Typeable (StateT s m a)':
06:34:43 <dylukes>       `StateT' must only have arguments of kind `*'
06:34:46 <saml> so, let's talk about something interesting
06:34:49 <dylukes> how can fix this.
06:35:16 <saml> wow what are you doing? that's advanced stuff
06:35:24 <saml> @info Typeable
06:35:24 <lambdabot> Typeable
06:35:51 <antihoax> tdammers<< aham i see;> multicore programming, will look into that, but first i need to get use of at least 1 core :)
06:36:18 <tdammers> I meant the profiling one
06:36:25 <dylukes> "An instance of Typeable can only be derived if the data type has seven or fewer type parameters, all of kind *. The reason for this is that the Typeable class is derived using the scheme described in Scrap More Boilerplate: Reflection, Zips, and Generalised Casts . "
06:36:30 <dylukes> ugh, so I have to do it myself, somehow?
06:36:35 <dylukes> I have no idea how to implement Typeable.
06:37:10 <tsousa> can you guys recommend me some exercices to improve my recursivity skills?
06:37:38 <saml> tsousa, find a fixpoint
06:37:43 <antihoax> solve resistor networks
06:37:46 <tsousa> fixpoint?
06:37:54 <tdammers> antihoax: that chapter explains a lot about how haskell works under the hood
06:38:00 <antihoax> okey
06:38:30 <tsousa> saml, there is exercices a bit less math?
06:38:45 <saml> tsousa, do you want to learn recursion?
06:38:51 <tsousa> yes i do
06:38:53 <saml> what's recursivity skills?
06:39:00 <tdammers> tsousa: anything that involves tree structures
06:39:12 <saml> yah write a tree iteration method
06:39:21 <saml> or factorial and fibonacci
06:39:57 <tsousa> well i read the chapter of recursion on learn haskell for a great good and i dont want to read the next one without understanding recursivity well
06:40:12 <jakeskik> tsousa: http://codingdojo.org/cgi-bin/wiki.pl?KataRomanNumerals
06:40:25 <saml> tsousa, read the next one please.
06:40:45 <tsousa> saml, why do you said that?
06:41:15 <saml> tsousa, why not read the entire book first?
06:41:36 <saml> then if you find weak spots, practice those..
06:41:50 <tsousa> saml, meh
06:41:53 <saml> or you can perfect each spots... but it's not enjoyable that way
06:41:53 <tsousa> could work
06:42:10 <saml> for example, if you are learning a piano piece... you can listen to the entire song..
06:42:15 <saml> or you can go by measure by measure
06:42:48 <saml> i tend to prefer learn the rough sketch first.. then practice detailed and isolated spots
06:42:52 <tsousa> ok i will do that
06:44:35 <tdammers> how to check if someone understands recursion.
06:44:55 <tdammers> have them solve a problem that involves tree structures.
06:45:02 <tdammers> if they fail, they do not understand recursion.
06:45:08 <saml> what the..
06:45:12 <tdammers> if they succeed, check if they understand recursion.
06:45:18 <saml> u craz
06:45:22 <tdammers> :>
06:45:32 <ion> To understand recursion, you must first understand recursion.
06:45:41 <mauke> or know someone who understands recursion
06:45:53 <tdammers> or admit that you don't
06:45:59 <tdammers> (need a terminating case)
06:46:14 <saml> ion sums it up eloquently
06:46:19 <saml> i'm gonna tweet this
06:46:31 <ion> I’ve read that somewhere.
06:46:47 <tsousa> i am still in school. but no one that i know knows recursion
06:47:09 <mauke> is saml a parody?
06:47:12 <saml> isn't recursion calling itself?
06:47:29 <tdammers> not necessarily
06:47:40 <saml> A recursive process is one in which objects are defined in terms of other objects of the same type.
06:48:07 <saml> if  f :: a -> b   and g :: a -> b    f can be defined in terms of g for recursion
06:48:15 <saml> because their types match
06:48:35 <mauke> that doesn't really follow
06:48:50 <ion> f = g
06:49:17 <saml> in a job interview, someone asks you "what is recursion?"
06:49:33 <saml> you say, natural number.
06:49:39 <tdammers> I'd probably come up with an example
06:49:51 <mercury^> saml: x = y + 3 defines an int in terms of another int. It is not a recursive process.
06:49:59 <mercury^> At least, it need not be.
06:50:18 <saml> that sounds like recursion to me.
06:50:39 <tensorpudding> it wouldn't be that strange for your employer to know know about peano's axioms
06:50:41 <saml> at some level
06:51:01 <mercury^> It is recursion to define an object in terms of itself.
06:51:19 <mercury^> Where in that equation is anything defined in terms of itself?
06:51:41 <tdammers> not necessarily
06:51:55 <tdammers> I can define f in terms of g, and then g in terms of f, and still have a recursion
06:52:08 <mercury^> Yes, because you defined f in terms of f then. :/
06:52:10 <saml> 4 = 3 + 1  is perfectly recursive
06:52:18 <mercury^> saml: no, it is not.
06:52:19 <tensorpudding> that's called mutual recursion
06:52:19 <saml> 3 = 2 + 1
06:52:25 <saml> 2 = 1 + 1
06:52:30 <saml> you see? natural number
06:52:37 <hpc> saml: by your definition of recursion, emptylist = [] is recursion
06:52:59 <saml> what's succ of your list type?
06:53:02 <hpc> because emptylist :: [a] and [] :: [a]
06:53:25 <saml> if there is succ, it's recursion
06:53:30 <mercury^> saml: this is a vague guess, but perhaps you confuse induction and recursion.
06:53:47 <Johannes2> Of course, most people don't solve 3 + 1 in terms of successors of n \in N :)
06:54:40 <saml> induction is recursive
06:54:50 <Johannes2> I think that you are confusing the method with the object which you are exerting the method upon!
06:54:53 <saml> The truth of an infinite sequence of propositions P_i for i=1, ..., infty is established if (1) P_1 is true, and (2) P_k implies P_(k+1) for all k. This principle is sometimes also known as the method of induction.
06:55:12 <saml> that sounds like recursion
06:55:27 <Johannes2> Superficially, yes.
06:55:43 <mercury^> saml: induction and recursion are dual, not equal.
06:56:58 <ohwow> What is the proper way to get UTF8 support in Haskell (in GHC in particular)?
06:57:01 <saml> it's so complicated. let's not talk about this
06:57:09 <saml> ohwow, what do you mean by UTF8 support?
06:57:17 <saml> I think Char is utf8 encoded by default?
06:57:31 <saml> or you mean you want to use UTF8 characters as function names or something?
06:57:33 <hpc> Char is utf8, but IO is ascii
06:57:47 <hpc> and GHC will let you put unicode in a file by default
06:57:53 <ohwow> Well, first of all: Prelude> "тест"
06:57:53 <ohwow> "\1090\1077\1089\1090"
06:57:58 <hpc> > let λ = 'l' in λ
06:57:59 <lambdabot>   'l'
06:58:12 <ohwow> > "λ"
06:58:13 <lambdabot>   "\955"
06:58:26 <saml> i think you need to decode
06:58:32 <ohwow> hpc: what do you mean by "IO is ascii"?
06:58:35 <bscarlet> hpc: what do you mean by "IO is ascii"?
06:58:35 <hpc> ohwow: that's just how strings are `show`-ed
06:58:44 <Jaak> ohwow: try putStrLn "тест"
06:58:47 <saml> > putStr "안녕"
06:58:48 <lambdabot>   <IO ()>
06:59:11 <hpc> ohwow: you have to hSetEncoding stdout utf8 in order to print unicode
06:59:17 <ohwow> Jaak: hm I see
06:59:30 <hpc> ohwow: you can also hSetEncoding stdin utf8, but i think you crash if you get malformed input
06:59:30 <ohwow> hpc: ah, so it's ASCII by default, but you can change that?
06:59:52 * hpc hasn't tested and the docs didn't say last i checked
07:00:33 <ohwow> Ok :)
07:00:53 <ohwow> Also, not really a Haskell question: what is faster, appending to the end, or cons'ing and then reversing?
07:02:12 <hpc> ohwow: neither option is spectacular, but it's faster to cons a bunch, then reverse once
07:02:19 <hpc> ohwow: you can also take a look at difference lists
07:02:21 <hpc> @hoogle DList
07:02:21 <lambdabot> Text.Html dlist :: Html -> Html
07:02:22 <lambdabot> Text.XHtml.Frameset dlist :: Html -> Html
07:02:22 <lambdabot> Text.XHtml.Strict dlist :: Html -> Html
07:02:32 <hpc> ...the REAL DList
07:02:38 <ohwow> When constructing a list via appending to the end you need to preform n + n-1 + n-2 + .. operations, right?
07:02:58 <erus`> ohwow: yar
07:02:59 <ohwow> and when consing and reversing it's 2*n only?
07:03:20 <ohwow> (n consing operations and n for reversing)?
07:03:33 <erus`> you can reverse a list in O(n) ?
07:03:33 <bscarlet> ohwow: Personally I prefer mappending (Endo [a])'s like (Endo (x:)). It's like difference lists.
07:03:44 <cheater> anyone know how to build a .deb from the redistributable GHC and the haskell platform?
07:03:50 <cheater> on ubuntu 10.04
07:04:01 <Jaak> mercury^: what do you mean by dual? afaiu induction is just a case of using recursion to define a proof
07:04:02 <cheater> (only 10.10 and up are supported)
07:04:39 <ohwow> erus`: hm now that you asked that, i am not sure
07:04:57 <hpc> Jaak: it kind of is, kind of isn't
07:05:07 <ski> mercury^ : induction and coinduction are dual
07:05:34 <hpc> Jaak: recursion and induction have very specific definitions; very casually, induction is "start from base case, find consequences to infinity"
07:05:46 <hpc> recursion is "start from a big thing, reduce to tiny thing"
07:06:10 <Jaak> i think that's very informal definition at best
07:06:10 <hpc> i recommend going to wikipedia to find definitions that don't suck
07:07:37 <Jaak> http://scienceblogs.com/goodmath/2007/01/basics_recursion_and_induction_1.php
07:08:11 <antihoax> Q: if i paste "doubleUs x y = x*2 + y*2" from example webpage into ghci then error
07:08:24 <antihoax> <interactive>:0:14: parse error on input `='
07:08:38 <antihoax> if i write let before it works
07:08:49 <antihoax> why?
07:09:26 <hpc> antihoax: "let blah = blahblah"
07:09:44 <hpc> antihoax: the simple explanation is that ghci behaves like a giant do-block
07:09:50 <ocharles> hrm, does base not export anything that's Read a => String -> Maybe a?
07:09:56 <hpc> if you don't know what a do-block is yet, don't worry about it ;)
07:11:03 <antihoax> http://learnyouahaskell.com/starting-out#ready-set-go
07:11:16 <antihoax> there isn let before the examples
07:11:30 <erus`> whats that website with the programming horror stories?
07:11:39 <saml> erg, yourcompany.com
07:11:40 <tac-tics> dialywtf?
07:11:45 <tac-tics> daily*
07:11:46 <tdammers> www.thedailywtf.com
07:11:51 <tac-tics> erus`: That or php.net
07:11:53 <saml> reddit.com
07:11:56 <hpc> antihoax: oh! i see where you are confused
07:12:00 <hpc> antihoax: "Open up your favorite text editor and punch in this function that takes a number and multiplies it by two."
07:12:09 <ski> "A Tutorial on (Co)Algebras and (Co)Induction" by Bart Jacobs,Jan Rutten at <http://www.cs.ru.nl/B.Jacobs/PAPERS/JR.pdf>
07:12:27 <hpc> antihoax: then the next thingy down shows you how to load the file in ghci
07:12:35 <ocharles> ski: is this you recommending this tutorial?
07:12:38 <ocharles> if so, *bookmarks*
07:12:59 <ski> ocharles : istr that one was nice, yes
07:14:11 <absentia> along the lines of the daily wtf -- here's my son's iphone -->  http://www.spy.org/tmp/iforever.jpg
07:16:30 <antihoax> hpc<< thanks so in a source file i dont need let, in ghci i need let
07:19:09 <hpc> antihoax: yeah, until lyah introduces more syntax
07:19:44 <ski> ocharles : also, imo "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>, "Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/kyoto97.pdf>, "A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf> and <http://www.cs.ru.nl/E.Poll/papers/ita01.pdf> (later version in 2001), all by Erik Poll, are interestin
07:19:58 <ocharles> ski: excellent, thank you!
07:20:06 <ocharles> I'm trying to get much more proper reading in recently
07:20:14 <ocharles> so my to read pile is starting to fill up nicely :)
07:33:41 <ocharles> http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/src/Text-Read.html#read grr, why is readEither not exported?
07:34:03 <cheater> so that you can enjoy writing it yourself
07:36:41 <antihoax> awesome http://s3.amazonaws.com/lyah/listmonster.png
07:36:49 <antihoax> shes a monster
07:37:07 <antihoax> ( from http://learnyouahaskell.com/starting-out#ready-set-go )
07:40:18 * ski . o O ( <http://web.archive.org/web/20051229041118/http://www.niksula.cs.hut.fi/~candolin/scheme/> )
07:41:11 <moriramar> Excuse me. I am writing Euler's sieve to practise. Which one should I use, STArray or State s (Array Int Bool) ?
07:41:27 <monochrom> STArray is faster
07:42:20 <ski> (also it is ephemerous .. which shouldn't be an issue here)
07:47:02 <moriramar> monochrom, What's the difference? I looked into RWH and it only said ST has some advantages like thaw/freeze that I am not that familiar and strictness. State would keep all the intermediate arrays?
07:47:27 <monochrom> STArray is in-place destructive update
07:53:08 <moriramar> monochrom, I see. Thank you.
07:53:38 <parcs> anyone know into what package has http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed.html been moved to?
07:56:18 <byorgey> parcs: edwardk would know
07:56:19 * ski suspects edwardk might know
07:56:31 * hackagebot seqloc 0.3 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.3 (NicholasIngolia)
08:02:36 <tac-tics> Someone should come up with a problemset for reasoning about space usage in haskell
08:03:00 <antihoax> one thing i dont understand, tutorial states "replaces" but no replacement has been done, a new list has been created with new elements
08:03:03 <tac-tics> When I look at Haskell code, I have absolutely no idea how it evaluates >___>
08:03:12 <tac-tics> yet, somehow, I can write most simple programs
08:03:26 <rostayob> I'm trying to use a preprocessor with -pgmF, but it doesn't work, what are exactly the rules? This preprocessor produces valid haskell files and outputs it to stdout
08:03:47 <aspect> I didn't know >___> was an operator .. but it doesn't surprise me
08:03:51 <rostayob> tac-tics: yeah the semantics of haskell evaluation are kind of confusing
08:04:11 <rostayob> let x >___> y = error "yay"
08:04:15 <rostayob> > let x >___> y = error "yay"
08:04:16 <lambdabot>   <no location info>: Parse error in pattern
08:04:25 <rostayob> > let (>___>) = error "yay"
08:04:26 <lambdabot>   <no location info>: parse error on input `)'
08:04:30 <tac-tics> almost :P
08:04:30 <rostayob> mhm.
08:04:33 <rostayob> too bad
08:04:40 <tac-tics> let (^.^) = error "yay
08:04:42 <moriramar> antihoax, where?
08:04:50 <antihoax> like http://learnyouahaskell.com/starting-out#ready-set-go
08:04:52 <tac-tics> @let (^.^) = error "Yay!"
08:04:54 <lambdabot>  Defined.
08:05:00 <tac-tics> > (^.^)
08:05:02 <lambdabot>   *Exception: Yay!
08:05:07 <rostayob> lovely
08:05:08 <antihoax>  Let's say we want a comprehension that replaces each odd number greater than 10 with "BANG!" and each odd number that's less than 10 with "BOOM!".
08:05:20 <bscarlet> antihoax: it means a sort of abstract replacement, not physical replacement of an in-memory structure.
08:05:50 <antihoax> i'd say represents instead
08:05:56 <monochrom> tac-tics: have you seen my http://www.vex.net/~trebla/haskell/lazy.xhtml ?
08:05:57 <antihoax> is it more correct?
08:06:04 <bscarlet> antihoax: when nothing or little is actually changed in place, it's often convenient to talk about "changing" somthing instead of saying "make a modified copy" all the time.
08:06:33 <antihoax> so how do i really replace X with X+1 ?
08:06:39 <antihoax> (increment variable)
08:06:46 <bscarlet> antihoax: you don't.
08:06:46 <mauke> it's a bit like saying 2 + 2 doesn't add two numbers because no adding has been done, a new number has been created
08:06:49 <moriramar> good, still loading...
08:07:10 <bscarlet> antihoax: I know that sounds weird and constraining, but it's not.
08:07:45 <bscarlet> antihoax: alternate answer: you recurse, calling yourself with a different value of x, say (x+2).
08:08:56 <bscarlet> antihoax (okay, saying it's not weird and constraining isn't really fair. It's just that it's different which may seem weird, but once you get used to it, it's more freeing than constraining.)
08:09:46 <antihoax> mauke<< no, adding done, and stored in a variable then printed out
08:10:34 <antihoax> ahm
08:11:06 <antihoax> so in functional programming i dont increment any variables
08:11:16 <rostayob> is it possible to define pre-build scripts with cabal?
08:11:41 <bscarlet> antihoax: nope. You compute new quantities which are one greater than previous ones, but you don't update variables.
08:13:06 <monochrom> I agree with bscarlet. "increment 2 to 3" is just convenient white lie
08:13:16 <bscarlet> antihoax: you recurse a whole lot (which is much cheaper than you might think), and in doing so a given symbol may mean x, then x+1, then x+2, etc. But it's not a variable being changed. It's a symbol referring to successive values in different contexts.
08:14:32 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/4c1cb17ded810ea0
08:14:35 <bscarlet> antihoax: you can then trust that the same symbol in the same context _always_ refers to the same value. There is no "come back later and it's changed".
08:16:14 <antihoax> i have no problem with reading an array from file then applying vectorgraphic functions to display onto screen, just wondering how will i change the properties of the primitives according to user input, then redisplay it
08:26:32 * hackagebot email-postmark 0.1 - A simple wrapper to send emails via the api of the service postmark (http://postmarkapp.com/)  http://hackage.haskell.org/package/email-postmark-0.1 (DanielPatterson)
08:43:21 <monochrom> http://queue.acm.org/detail.cfm?id=2038036&ref=fullrss  "OCaml for the masses: why the next language you learn should be functional", by Yaron Minsky, Jane Street
08:47:07 <monochrom> eh? Java is even harder to reason about than VBA? XD
08:47:33 <tac-tics> monochrom: Which functional language should I learn? I'm running out of them >__>
08:47:41 <tac-tics> Haven't actually ever used one for serious work either <___<
08:48:26 <yrlnry> tac-tics:  https://secure.wikimedia.org/wikipedia/en/wiki/Id_(programming_language) ?
08:48:35 <hpc> tac-tics: stop learning! pick a project you always wanted to code and make it
08:48:44 <hpc> then learn more :P
08:48:48 <monochrom> is your goal a killing^W learning spree? or to find one language to use regularly?
08:48:54 <tac-tics> hpc: But I can learn so much faster than I can use what I learned
08:48:55 <tac-tics> lol
08:49:00 <hpc> lol
08:49:03 <tac-tics> All the cool projects are already done
08:49:10 <tac-tics> by college kids who don't have jobs
08:49:13 <RichardBarrell> Not even slightly.
08:49:15 <tac-tics> I'm basically SOL :)
08:49:26 <RichardBarrell> Only with that attitude.
08:49:55 <monochrom> screw "cool" projects. do a useful project. even just a small program you can write and you can use
08:49:55 <hpc> tac-tics: the project doesn't have to be amazing, just the code :P
08:50:11 <tac-tics> hpc: I actually started a list of projects I think would be fun
08:50:16 <hpc> my goal for my website was to write scripts as near to HTML style as i could
08:50:29 <hpc> the website is totally boring, but the code is kickass
08:50:50 <monochrom> http://www.vex.net/~trebla/portfolio/index.html  all small projects but most I actually use for myself
08:51:34 <monochrom> in any case, if you're on a killing spree, I suggest Clean as the next target. a solution to IO and IORef without monad
08:52:34 <tac-tics> monochrom: have you ever tried Disciple?
08:52:38 <monochrom> no
08:52:45 * ski can't recall seeing mutable references in Clean
08:52:46 <tac-tics> Same sort of goals
08:53:28 <tac-tics> Disciple basically annotates all function arrows with what side effects they can perform (which references they can write and read to and if they can touch the dirty "real world")
08:53:52 <tac-tics> Then, there are constructs that allow you to erase side effects that don't escape the function def
08:54:16 <tac-tics> So you can write a totally pure function in a side-effectful way (as long as those side effects remain local)
08:54:47 <ski> *nod* an effect system
08:54:59 <tac-tics> yep
08:55:07 <Cale> I don't know why, but I find disciple's approach kinda boring given what we already know.
08:55:11 <ski> uniqueness types in Clean (and uniqueness modes in Mercury) is another thing, though
08:55:44 <tac-tics> Cale: When you say "given what we already know" do you mean "given what we already know with Haskell"?
08:55:47 <Cale> yes
08:56:01 <monochrom> you get mutable variables in Clean by not asking for it, but by marking and ensuring uniqueness
08:56:23 <ski> that's not the same thing as references, though
08:56:32 <monochrom> ok fine
08:56:47 <plathrop> I recommend writing "something you'll use" over "something cool" any day
08:56:49 <ski> Mercury has both uniqueness modes and a special reference type
08:56:58 <tac-tics> Disciple obviously can't do anything Haskell can't, but the type system lets you choose how tight you want your straightjacket
08:57:45 <ski> basically references must be used together with an abstract, unique state (think internal state of `ST'), so you still have to pass around the state
08:58:20 <tac-tics> ski: Once a great programmer, now a great plumber :P
08:58:55 <Cale> ski: Does Mercury have constructor classes?
08:58:58 <tac-tics> The next great functional language with come with a well-designed sewer system.
08:59:35 <ski> see "mutvars" at <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_library/store.html>
08:59:56 <ski> Cale : no, but it has multiparameter type classes
09:00:03 <benmachine> aw, when I heard there was a functional programming language called Id I was hoping it was a language that compiled to C, and had C as input >_>
09:00:11 <ski> (and first-class existentials :)
09:00:17 <Cale> hmm
09:00:39 <Cale> ski: I was hoping you could just define a Monad class, obviously :)
09:00:57 <conal> I'm going to be helping a group of Java/C++ programmers learn to work in Haskell. I'd appreciate suggestions on resources & practices to use.
09:00:57 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:01:15 <ski> unfortunately it doesn't have higher kinds (afaik) (just like SML and O'Caml)
09:01:19 <monochrom> hahahaha benmachine
09:02:26 * ski wonders whether the "Haskell for C programmers tutorial" thing might be useful
09:02:59 <MarkDBlackwell> Is there a config file that WinGHCi reads (I already googled and looked in the usual place)? I seem to have put it into a state where I just get a white window on load, even after rebooting.
09:03:04 <cheater> conal: teach them python first
09:03:16 <ski> (i.e. <http://ccfit.nsu.ru/~ikuznecov/doc/Haskell%20Tutorial%20for%20C%20Programmers/intro.html>)
09:03:25 * tac-tics feels that going from C to Haskell is like learning to fly a plane when all you know is how to drive a car.
09:03:31 <conal> cheater: i hadn't considered that option. what appeals to you about it?
09:03:32 <monochrom> w00t conal, perhaps http://queue.acm.org/detail.cfm?id=2038036&ref=fullrss has a suggestion! I don't mean the "switch to OCaml" part. I mean the example further down, basically "screw class hierarchy, just use an algebraic data type", i.e., marvel at all the "class True", "class False", "class And" business!
09:04:07 <zzo38> I wrote the http://sprunge.us/NXXi it is document about my idea related to specifying preparing printouts of literate Haskell program in a Cabal package. Read it please make opinion/suggestion/question/complain
09:04:11 <conal> monochrom: thx. i've stashed that article to read soon.
09:04:15 <ski> @quote very.weird
09:04:16 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
09:04:18 <Cale> MarkDBlackwell: Does Ctrl-o get you options?
09:04:18 <cheater> conal: python is a functional language with some functional control flow and with exceptions as well as the ability to do strong typing (which is discouraged by the language but still exists)
09:04:32 <mauke> python is not a particularly functional language
09:04:41 <tac-tics> cheater: I wouldn't call python functional
09:04:45 * ski imagines conal slipping denotative programming into poor(?) Java/C++ minds
09:04:46 <mauke> "strong typing" is meaningless
09:04:47 <cheater> does it have first class functions?
09:04:51 <cheater> yes
09:04:53 <tac-tics> Crippled lambdas, only in the latest versions did they add non-local variables
09:04:56 <conal> BTW, i don't have to sell haskell. just help them learn it.
09:04:56 <cheater> it does.
09:04:59 <mauke> cheater: kind of, yes
09:05:03 <mauke> cheater: but not function literals
09:05:10 <cheater> does it have first class functions?
09:05:14 <cheater> yes
09:05:18 <mauke> depends
09:05:22 <cheater> are you broken?
09:05:25 <monochrom> conal: the quote "In 2003, Jane Street  began a rewrite of its core trading systems in Java. The rewrite was  eventually abandoned, in part because the resulting code was too difficult  to read and reason about—far more difficult, indeed, than the VBA  that was being replaced" is also golden :)
09:05:49 <conal> monochrom: :)
09:05:52 <int-e> VBA++
09:05:56 <cheater> monochrom: i like this
09:06:04 <cheater> monochrom: jane street use what nowadays?
09:06:09 <cheater> ml?
09:06:11 <MarkDBlackwell> Cale, after loading WinGHCi, it goes white, and Ctrl-o doesn't do anything. However, mouse-clicking produces 'Not Responding'.
09:06:12 <cheater> haskell?
09:06:19 <int-e> (and here I was thinking that the main purpose of VBA was for non-programmers to prove that they can't program)
09:06:22 <Cale> MarkDBlackwell: oh, hrm
09:06:43 <conal> any pros & cons for "Learn You a Haskell" vs "Real World Haskell"?
09:06:53 <conal> as well as other suggestions?
09:06:58 <cheater> conal: "learn you" is a bit paternizing
09:07:09 <benmachine> MarkDBlackwell: I don't think strong typing is meaningless - I like that python doesn't typically have automatic conversions
09:07:17 <conal> cheater: meaning some readers might take offense?
09:07:17 <Cale> MarkDBlackwell: I'm not on windows, so I'm not sure where the configuration goes. Maybe somewhere under %APPDATA% ?
09:07:17 <int-e> cheater: was this intentional? you mean patronizing.
09:07:31 <MarkDBlackwell> Conal, Rubyists seem to love LYAH.
09:07:52 <MarkDBlackwell> benmachine, that wasn't me.
09:07:52 <Cale> LYAH seems better suited to beginners to me
09:08:00 <conal> LYAH looks fun for people who don't take themselves too seriously.
09:08:03 <benmachine> MarkDBlackwell: oh, so it wasn't, forgive me
09:08:07 <benmachine> I meant mauke and didn't even notice
09:08:21 <Cale> RWH seems like a steeper hill to climb
09:08:34 <MarkDBlackwell> Cale, what's the file or directory? Probably the same; I know the places, but I don't recognize the file.
09:08:36 <mauke> benmachine: how do you define "strong typing"?
09:08:38 <hpc> rwh isnt a tutorial either
09:08:44 <hpc> more of a reference
09:08:48 <conal> Cale: ah. that's my (first) impression as well.
09:08:52 <conal> i'd also like to give homework assignments along with the reading.
09:08:55 <MarkDBlackwell> Cale, I am looking in %APPDATA%
09:08:58 <Cale> MarkDBlackwell: Well, for ghci on linux (and windows...) there's supposed to be a .ghci file
09:09:00 <benmachine> mauke: vaguely.
09:09:04 <mauke> meh
09:09:07 <benmachine> mauke: lack of implicit coercions, mostly?
09:09:17 <Cale> (that's literally the entire filename)
09:09:30 <benmachine> so that "foo" + 4 doesn't work
09:09:32 <Cale> But I don't know if winghci has something in addition to that
09:10:03 <benmachine> (although, embarassingly, python still lets "foo" + "bar" work, sigh)
09:10:16 <hpc> benmachine: i would define it as lack of any coercion syntax
09:10:28 <hpc> or implicit conversions
09:10:34 <antihoax> ye
09:10:35 <antihoax> let padd pa pb = (fst pa + fst pb, snd pa + snd pb)
09:10:38 <benmachine> hpc: C has coercion syntax, but in some cases it's optional
09:10:44 <Cale> conal: My recommendation about teaching beginners is to make them familiar with the main features of types right away. It's important that as early as possible they know what typeclasses *are*, even if they don't necessarily learn how to make instances until later.
09:10:52 <benmachine> I'm not sure if that proves my point or not
09:10:54 <mauke> hpc: every language has coercion syntax
09:10:56 <cheater> int-e: indeed that is what i mean
09:11:14 <benmachine> well, whatever you call it, I don't like it when strings are parsed to ints or ints converted to doubles without anyone notifying me
09:11:19 <hpc> benmachine: i would consider that to be weak typing, because it says that on some level the types are the same
09:11:23 <cheater> conal: offense.. not necessarily, but some might get put off by feeling like they're in a cartoon for 4 year olds
09:11:26 <conal> Cale: sounds good to me. thanks.
09:11:33 <hpc> mauke: haskell doesn't
09:11:47 <hpc> (it has a compiler function though...)
09:12:00 <MarkDBlackwell> Cale, Now, I see directory ghc there which has file, ghc_history, which I deleted; but still I get the white hang. ;(
09:12:09 <mauke> hpc: fromIntegral
09:12:17 <hpc> still not syntax
09:12:22 <mauke> define "syntax"
09:12:27 <Cale> MarkDBlackwell: Well, ghc_history is just what it scrolls through when you press the up-arrow key
09:12:39 <conal> cheater: so they might think they won't learn efficiently?
09:12:45 <benmachine> when people say "syntax" it makes me think of things defined in the grammar
09:12:53 <hpc> mauke: fromIntegral is a function
09:13:04 <hpc> floor() is a function
09:13:06 <cheater> conal: anyways, i am learning haskell now - i've been using C-like languages before only, then python, now haskell. when reasoning about haskell stuff i think a lot about python things that seem similar: for .. in loops, list comprehensions, generators (as coroutines/yield), lambdas (even though theyre not as powerful in python), map, etc
09:13:24 <mauke> hpc: (int) is an operator, ok
09:13:26 <benmachine> hpc: but wait so, weak typing is lack of coercion syntax, and haskell doesn't have coercion syntax...
09:13:27 <cheater> conal: no, they might think like they're taking part in something embarassing :p
09:13:29 <MarkDBlackwell> Cale, I should say that GHCi starts without problem for me; it's just WinGHCi that makes the white screen.
09:13:33 <cheater> conal: but that's only my impression
09:13:51 <Cale> MarkDBlackwell: Yeah, I'm afraid I don't have much experience with WinGHCi.
09:13:53 <hpc> benmachine: weak typing is lack of coercion as a language feature
09:14:03 <hpc> be it implicit or syntax
09:14:06 <MarkDBlackwell> Cale, thanks, anyway. I'll reinstall. :)
09:14:08 <benmachine> hpc: I confuse
09:14:16 <hpc> i said it poorly
09:14:24 <benmachine> first of all, (lack of coercion) as a language feature or lack of (coercion as a language feature)
09:14:29 <benmachine> secondly, what does that even mean anyway
09:14:43 <MarkDBlackwell> Cale, the ghc directory was then empty, BTW.
09:14:46 <hpc> and class is starting, so i can try and explain it better later
09:15:01 <conal> cheater: i ask because it's hard for me to relate to that mindset. i think of children as being the best & most passionate learners there are.
09:15:26 <conal> "The creative adult is the child who has survived." - Ursula K LeGuin
09:16:52 <conal> cheater: ah, so python was a helpful stepping stone for you, in crossing the chasm from C to Haskell?
09:17:09 <cheater> conal: yes, it's nicely on the border
09:17:17 <conal> cool
09:17:31 <conal> a gateway drug
09:18:16 <cheater> conal: and sure, children are cool, but if your boss came up to you and said "Oh hi, Conal! Look what I have here: we call this a Paper! Let's read it together, shall we??" then you'd feel a bit stupid yourself :p
09:18:35 <cheater> <conal> a gateway drug << i thought that exactly :)
09:18:59 <conal> cheater: i wouldn't feel that way, but i get your point that many others would.
09:19:58 <Cale> I think for the most part if you already know how to program in imperative languages the important thing while learning Haskell is to forget that you already know how to program. :)
09:20:22 <conal> Cale: amen.
09:20:23 <MarkDBlackwell> benmachine, same pronunciation: Mark, mauke, so for an aural mind, they have one association key ;/
09:20:40 <benmachine> MarkDBlackwell: ma<tab>, more like :P
09:23:29 <MarkDBlackwell> benmachine, I see! My Chatzilla doesn't do that (yet), how interesting. I guess people helping on IRC find it very useful. :)
09:25:38 <cheater> conal: another thing that was a big breakthrough for me when learning haskell was when i remembered synthetic vs analytic geometry
09:25:59 <cheater> conal: i describe that in that blog post that i think i linked you to some time ago
09:26:20 <conal> cheater: i don't remember. url?
09:26:34 <cheater> http://cheater.posterous.com/first-haskell-script
09:26:49 <MarkDBlackwell> conal, much depends on whether they are self-selected or pushed as to whether to go from where they are, or show them first the extremely different, I suppose.
09:27:32 <conal> cheater: thx
09:27:38 <cheater> conal: yw
09:28:01 <cheater> conal: you can thank me by telling me some situations where a language is declarative but not denotative :)
09:28:33 <conal> cheater: i know what "denotative" means precisely but not what "denotative" means.
09:29:10 <cheater> i think you don't.
09:29:15 <conal> MarkDBlackwell: ah, yeah. they're self-selected.
09:29:22 <cheater> :)
09:29:37 <MarkDBlackwell> Because they love the differentness?
09:29:48 <cheater> conal: re-read that sentence ;)
09:30:08 <conal> cheater: ah, thanks.
09:30:22 <conal> i know what "denotative" means precisely but not "declarative".
09:30:43 <conal> i guess i have resistance to using words when i don't know their meaning.
09:31:35 <MarkDBlackwell> conal, isn't declarative used to describe Prolog?
09:31:53 <hpc> conal: afaik, "declarative" has a fuzzy definition that applies to languages where you describe "what" instead of "how"
09:32:39 <cheater> conal:  :))
09:32:53 <conal> MarkDBlackwell: hm. it's probably a mixture. mostly i think people are eager, but there might be a few who have mild internal resistance. i guess i'll find out.
09:33:08 <cheater> conal: my definition is that you declare what things are
09:33:26 <cheater> sort of like SQL SELECT versus filtering in a for loop
09:33:33 <cheater> in SQL you declare what your result is
09:34:08 <conal> hpc: yeah. which is very fuzzy indeed, since languages generally combine what & how. even x86 and haskell (or prolog).
09:34:39 <hpc> i personally wouldn't attribute "declarative" to a language, and more to a programming style
09:35:00 <MarkDBlackwell>  Conal, in Prolog you match A and B, and B and C, and Prolog figures out to match A and C. So, Haskell has it.
09:35:02 <conal> cheater: have you read landin's definition of "denotative"? you might be able to answer your own question.
09:35:05 <hpc> you can write declarative C, if you have a powerful enough mental illness :P
09:35:09 <cheater> conal: i was told prolog was declarative but not denotative
09:35:16 <cheater> conal: i have not, no
09:35:25 <cheater> conal: i believe it's only available in books, right?
09:36:08 <conal> cheater: it's in landin's seminal paper "the next 700 programming languages".
09:36:29 <conal> cheater: if you don't know what "denotative" means, why do you care whether prolog is denotative or not?
09:36:33 <cheater> ok, i will try to find it
09:36:50 <cheater> conal: i have read some other definitions of denotative
09:36:55 <cheater> but they were not clear
09:37:15 <conal> cheater oh? would you share those refs with me? i'd like to know what other people are saying.
09:37:20 <tac-tics> What's the "point" of Prolog
09:37:27 <tac-tics> That's something I never understood
09:37:35 <saml> is floating point number monad?
09:37:54 <c_wraith> saml: it doesn't have the right kind to even be a candidate
09:38:10 <cheater> conal: the wikipedia page on denotational programming
09:38:13 <saml> :k Monad
09:38:13 <lambdabot>     Class `Monad' used as a type
09:38:14 <lambdabot>     In the type `Monad'
09:38:43 <c_wraith> @instances Monad
09:38:44 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:38:49 <c_wraith> @kind []
09:38:50 <lambdabot> * -> *
09:39:04 <c_wraith> @kind Double
09:39:06 <lambdabot> *
09:39:07 <cheater> conal: http://en.wikipedia.org/wiki/Denotational_semantics
09:39:11 <conal> i'm joining landin in recommending "denotative" as a replacement for the fuzzy term "functional", to help clear up the typical confusions arising in discussions about what's "functional" and what's not.
09:39:19 <plathrop> What's with the T appended to a bunch of those? ErrorT and ReaderT, etc.?
09:39:35 <c_wraith> conal: functional programs are ones that work.  of course. :)
09:39:45 <c_wraith> plathrop: it means they're transformers
09:39:55 <conal> cheater: thx. i don't see anything about denotative programming on that page.
09:39:57 <MarkDBlackwell> conal, "Basically, denotative programming is programming with the precision and simplicity of mathematics", per http://creativelad.wordpress.com/2011/04/03/dctp-model/
09:40:19 <cheater> conal: i was using "declarative" like this but now i am thinking whether "denotational" or "denotative" is better
09:40:50 <conal> for pointers to Peter Landin's definition of "denotative", see http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882
09:41:09 <MarkDBlackwell> conal, and google came up with http://conal.net/blog/posts/is-haskell-a-purely-functional-language
09:41:24 <conal> MarkDBlackwell: i like that informal characterization (not as a definition)
09:41:26 <cheater> conal: if you read the wikipedia article they are talking about how to define values
09:41:38 <cheater> or actually in the article's case functions
09:42:28 <MarkDBlackwell> conal, one of the big appeals to me of Haskell, naturally, is the mathematical syntax -- perhaps it's obvious.
09:42:51 <conal> MarkDBlackwell: i like that about haskell also.
09:43:36 <cheater> i think what you mean by mathematical i call declarative and conal calls denotative
09:43:45 <conal> one thing i appreciate about Landin's article is that he gives "a test for whether the notation is genuinely functional or merely masquerading."
09:44:02 <antihoax> circle = [ [x,y] | x <- [-100..100], y <- [-100..100], ((x-0)^2+(y-0)^2) == (8^2)]
09:44:07 <cheater> interesting
09:44:10 <antihoax> whats the problem with the syntax?
09:44:53 <cheater> ^ ?
09:45:45 <ski> antihoax : what's the error ?
09:45:54 <antihoax> the output
09:46:05 <antihoax> only 8
09:46:17 <antihoax> values
09:46:19 <MarkDBlackwell> conal & cheater, probably 'denotative' is from, 'of the notation,' whereas 'declarative' is from, 'of the clear' or making one's wish clear.
09:46:19 <antihoax> ;/
09:46:22 <Johannes2> Well, obviously!
09:46:38 <Johannes2> You're dealing with all INTEGER values which fall along the perimiter of the circle
09:46:41 <ski> > [ [x,y] | x <- [-100..100], y <- [-100..100], ((x-0)^2+(y-0)^2) == (8^2)]
09:46:42 <lambdabot>   [[-8,0],[0,-8],[0,8],[8,0]]
09:46:42 <Johannes2> perimeter*
09:46:54 <ski> looks like four, to me
09:46:59 <cheater> yeah
09:47:01 <cheater> heheh
09:47:07 <antihoax> four doubles nah
09:47:21 <antihoax> and meant (x,y)
09:47:46 <Johannes2> What are you after?
09:47:50 <plathrop> c_wraith: thanks
09:47:56 <Johannes2> Do you want floating point values?
09:48:08 <antihoax> this is the function of a circle
09:48:13 <Johannes2> Because you're never going to get integer values out of the other points of your circle >_>
09:48:14 <ski> antihoax : instead of comparing for equality, you could maybe somehow compare that they are close enough
09:48:31 <Johannes2> Well!
09:48:37 <Johannes2> There is probably a better way of going about this
09:48:46 <antihoax> im starting out ;<
09:49:02 <Johannes2> If you want a set of the values around your circle, you can try calculating x and y in terms of sine and cosine
09:49:14 <MarkDBlackwell> tit-tac, I have heard the point of Prolog is analysis of natural language grammar -- the field of its creator.
09:49:16 <antihoax> good point
09:49:21 * ski thinks bresenham-like algorithms for circles might be what antihoax is after
09:49:22 <Johannes2> Just determine how close you want your points to be together.
09:49:47 <ski> MarkDBlackwell : well, that was why it was initially created, yes
09:50:03 <Cale> > [(cos t, sin t) | t <- [0,0.1..2*pi]]
09:50:04 <lambdabot>   [(1.0,0.0),(0.9950041652780258,9.983341664682815e-2),(0.9800665778412416,0....
09:50:27 <Johannes2> Or how many points you need, even, since you can't iterate over all the real values in the arc of a circle in an enumerable fashion
09:50:35 <Cale> > [(8*cos t, 8*sin t) | t <- [0,0.1..2*pi]]
09:50:36 <lambdabot>   [(8.0,0.0),(7.960033322224207,0.7986673331746252),(7.840532622729933,1.5893...
09:50:48 <Johannes2> Well. Enumerable and finite.
09:51:03 <Johannes2> That works!
09:51:10 <antihoax> :)
09:51:16 <Johannes2> That's just a circle of radius 1 though
09:51:18 <Cale> You can enumerate all the rational points on a circle (though it's infinite)
09:51:31 <Cale> I also did a circle of radius 8 there
09:51:59 <antihoax> i'd prefer a fully closed circle
09:52:09 <Cale> Closed?
09:52:10 <ski> antihoax : i.e. <http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm> and <http://en.wikipedia.org/wiki/Midpoint_circle_algorithm>
09:52:41 <Cale> antihoax: You can adjust the 0.1 in that range syntax there to set the step size
09:52:53 <antihoax> Cale<< yeah, pixels touching each other, no holes
09:53:28 <Cale> antihoax: The usual approach to that if you're drawing things is to just set the step size to something reasonably low, but then draw lines joining adjacent points.
09:53:42 <Johannes2> You CAN enumerate all of the rational points in a circle
09:53:48 <Johannes2> Which is why I had to qualify that with finite
09:53:52 <Johannes2> <_>
09:55:30 <mm_freak> Cale: may i ask for which platforms your company is developing?  android?  iOS?
09:56:17 <Cale> mm_freak: iOS initially, we also plan on having Android support.
09:56:59 <hpc> Cale: how do we know you aren't vaporware? :P
09:57:13 <mm_freak> Cale: going through xcode?
09:57:23 <Cale> hpc: Um, I guess you don't?
09:57:57 <cheater> cale what company is that?
09:58:22 <MarkDBlackwell> cheater, your tutorial is quite good: http://cheater.posterous.com/first-haskell-script
09:58:24 <Cale> hpc: But Stephen Blackheath, who is one of us, is contributing the cross-compiling toolchain stuff to GHC, so you'll be able to see that soon :)
09:58:33 <hpc> Cale: YAAAY!
09:58:33 <Cale> cheater: iPwn Studios
09:58:49 <cheater> Cale: ah right, the one kmc did a compiler or something like that for?
09:58:55 <cheater> MarkDBlackwell: thanks :)
09:59:03 <cheater> MarkDBlackwell: did you find the link in here?
09:59:08 <rostayob> Cale: ah right, you work for them. is it vc funded?
09:59:14 <missingfaktor> in scala, i can make one typeclass an instance of other typeclass. for example, see this file: https://github.com/scalaz/scalaz/blob/bb6616245cb91cd46f4f4c5e8f23768864562d5d/core/src/main/scala/scalaz/Contravariant.scala. Here typeclasses Show, Equal, and Order are made instances of typeclass Contravariant. How can i do the same in haskell?
09:59:15 <MarkDBlackwell> Yes, last 10 mins.
09:59:28 <cheater> MarkDBlackwell: cool :)
09:59:34 <cheater> MarkDBlackwell: anything you'd add?
09:59:41 <Cale> rostayob: I actually don't know the details of how it's funded.
10:00:01 <rostayob> Cale: because i was wondering how they manage to employ so many people with no products out
10:00:03 <cheater> Cale: drug money, blood diamonds, and slave labour?
10:00:31 <MarkDBlackwell> I could say, it's quite good for bringing people in from the procedural world in a friendly and practical way! ;)
10:00:34 <MarkDBlackwell> :)
10:01:13 <Cale> rostayob: Ryan and I are the only programmers working full time.
10:01:15 <MarkDBlackwell> cheater, showing the practical side of Haskell.
10:01:44 <rostayob> MarkDBlackwell: you might be interested in Real World Haskell, that's an entire book about the practical side
10:01:49 <rostayob> @where RWH
10:01:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:01:56 <cheater> MarkDBlackwell: can you elaborate a bit?
10:01:58 <MarkDBlackwell> I heard a guy, even after reading Real World Haskell, say that Haskell isn't any use! :(
10:01:58 <Cale> missingfaktor: I'm not quite sure I understand what you're after, as I'm not terribly familiar with the syntax of Scala.
10:02:09 <rostayob> MarkDBlackwell: he didn't actually read it
10:02:23 <DanBurton> I demand a sequel: Fake World Haskell. And I expect lots and lots of monads and arrows and categories.
10:02:38 <cheater> and comonads and functors?
10:02:41 <Cale> DanBurton: I really want to write that one.
10:02:41 <DanBurton> oh yes
10:02:58 <rostayob> bremner`: braided categories too
10:02:58 <MarkDBlackwell> cheater, I'll keep going, sure... Naturally, a lot of people want to do scripting things, but think Haskell is unsuited.
10:03:03 <rostayob> ooops, DanBurton
10:03:05 <hpc> DanBurton: nah, just a link to all of edwardk's packages
10:03:15 <rostayob> yeah, a book about category-extras
10:03:29 <Cale> Edward Kmett and I may eventually end up doing a book.
10:03:42 <rostayob> Cale: i'd buy it
10:03:44 <raichoo> nice
10:03:45 <cheater> MarkDBlackwell: so you want the article to show more practical uses for haskell?
10:03:48 <raichoo> me too
10:03:49 <MarkDBlackwell> rostayob, you might think so, but he talked extensively about it and likes Haskell -- he's into Node.js and Javascript and Ruby.
10:04:21 <rostayob> MarkDBlackwell: Node.js/JS and ruby are very far from haskell :)
10:04:27 <mm_freak> Cale: so your variant of GHC compiles directly to native code runnable on iOS?
10:04:33 <MarkDBlackwell> cheater, that article or your new one? I read that one, and practicality, like how to get scripts working, is what I noticed. :)
10:04:34 <rostayob> MarkDBlackwell: anyway i'd love to elaborate but i have to go ehe
10:04:53 <Cale> mm_freak: XCode is involved for signing stuff.
10:05:01 * mux would have thought Cale's variant of GHC used the LLVM ARM backend
10:05:02 <Cale> mm_freak: But yeah, other than that.
10:05:05 <cheater> MarkDBlackwell: ohhhh, i thought you meant the article does not show enough of that
10:05:09 <Cale> It's not *mine* :)
10:05:15 <mux> yeah yeah :-)
10:05:15 <cheater> MarkDBlackwell: what would you change or add to the article?
10:05:28 <mm_freak> Cale: ok, thanks for the clarification…  i was wondering how you do it =)
10:05:30 <MarkDBlackwell> rostayob, yes, far, and he's got Ocaml and Scala among his interests, also -- a very intuitive fellow, and a leader.
10:05:50 <Cale> There's some new LLVM stuff being worked on as well. I don't really know what the state of that stuff is in, because I've mainly been working on the game just as it builds on Linux.
10:06:23 <Cale> (It's far more convenient to test things on linux than having to deal with VMware and the iPhone Simulator.
10:06:24 <Cale> )
10:06:29 <mux> oh yeah I bet
10:06:34 <MarkDBlackwell> cheater, I have no changes or additions that I noticed.
10:06:43 <cheater> nice :)
10:07:02 <missingfaktor> Cale: In Scala, typeclasses are also types themselves. And instances of these typeclasses are actually values of those types.
10:07:04 <Cale> missingfaktor: Can you give an example in Haskell of what you wanted?
10:07:06 <Cale> oh
10:07:17 <Cale> missingfaktor: Typeclasses are not types in Haskell.
10:07:22 <missingfaktor> So I can have an instance of 'Contravariant Show' in Haskell-speak.
10:07:26 <antihoax> how do i check if a floatingpoint number is close?
10:07:38 <missingfaktor> Cale: Alright. Any work-around for that?
10:07:50 <mux> the closest I can think of in terms of meaning would be a Show a => Contravariant a instance
10:07:55 <Cale> missingfaktor: Though, *constraints*, including typeclass constraints, are types in GHC HEAD.
10:08:04 <Cale> (of a distinct kind)
10:08:11 <Cale> missingfaktor: But that's not in released GHC.
10:08:18 <Cale> (yet)
10:08:18 <missingfaktor> Cale: I don't understand. Can you please give an example?
10:08:32 <Cale> http://blog.omega-prime.co.uk/?p=127
10:08:42 <missingfaktor> mux: No, that's not quite the same.
10:09:03 <missingfaktor> Since Scala treats typeclass instances as values, it's possible to obtain these values and perform operations on them.
10:09:31 <missingfaktor> Example: s = implicitly[Show[Int]] // s is an instance of Show for Int.
10:09:50 <Cale> Yeah, typeclass instances are not Haskell values.
10:10:17 <MarkDBlackwell> cheater, right, Ruby web developers, which he is one of, like me, are into a certain kind of hard-to-describe accessibility and readability in their programs. And rapid adoption of new, fast things.
10:10:22 <bscarlet> antihoax: how about your basic: abs (x - y) < threshold ? Or do you mean something else?
10:10:28 <Cale> They are (perhaps) in some intermediate language in the compiler, but not as exposed to the programmer
10:10:41 <elliott__> perhaps? they definitely are in GHC Core :)
10:10:59 <cheater> MarkDBlackwell: then you'll like snap framework
10:10:59 <antihoax> i cant take fractional of floatingpoint number yet
10:11:04 <missingfaktor> Cale, mux: For the specific example of Show typeclass, if I have a Show instance available for type a, and have a function b -> a, then I can create an instance of Show for type b, since Show is a contravariant functor.
10:11:09 <cheater> MarkDBlackwell: i'll be writing a short tutorial on using that soon
10:11:29 <plathrop> for the record, automatic currying is badass
10:11:54 <Cale> missingfaktor: Well, I guess you *kind of* can do that:)
10:11:57 <MarkDBlackwell> cheater, right, Snap, already found it after attending a Node.js meeting.
10:12:02 <missingfaktor> Cale, mux: s0: Show[B] = implicitly[Show[A]] contramap (f)
10:12:13 <Cale> missingfaktor: The Show instance you get that way will be "wrong" though.
10:12:15 <MarkDBlackwell> cheater, will you (Snap)! That's great!
10:12:15 <missingfaktor> Cale, mux: yeah, I need a way to do that in Haskell. :)
10:12:25 <mux> Cale: using explicit dictionaries, I guess he can
10:12:28 <DanBurton> imho JS is surprisingly functional, what with first-class functions and all
10:12:44 <mux> otherwise I don't know
10:12:47 <DanBurton> Node.js is all about the callbacks
10:12:57 <cheater> MarkDBlackwell: i plan to write one on how to make a simple stateless app and after 0.6 is out one about how to make modules (snaplets) for it
10:13:05 <Cale> missingfaktor: You can always just write  instance Show B where show = show . f
10:13:09 <mux> or ugly newtypes wrapping
10:13:12 <Cale> where f :: B -> A
10:14:50 <MarkDBlackwell> cheater, sounds very good -- like webapps are stateless? Good to include REST, it occurs to me.
10:15:29 <missingfaktor> Cale: Yeah, but is there some way to in general represent typeclasses as types, and instances as values? Maybe with some wrapping and stuff...
10:16:09 <MarkDBlackwell> cheater, as in, state is carried in the URL.
10:16:12 <Cale> missingfaktor: You can instead of using typeclasses, just use values in the first place.
10:16:27 <Cale> missingfaktor: You can construct record types with functions and such in them.
10:17:02 <cheater> MarkDBlackwell: yup
10:17:46 <ski> (imo, one of the points of type classes is that there should be at most one instance of a class for any type)
10:18:00 <missingfaktor> Cale: How will having record types with functions help?
10:18:16 <Cale> missingfaktor: Because those are equivalent to typeclass dictionaries.
10:18:40 <missingfaktor> Cale: Alright, thanks. I will try that, and come back if I have more questions.
10:18:58 <Cale> missingfaktor: Apart from the fact that you have to pass them around explicitly, but that's the price you pay for not having at most one instance per type.
10:19:25 <hpc> isn't that how GHC compiles type classes?
10:19:26 <ski> (that, or risk incoherence)
10:20:39 <wuch> what is the easiest way to read n integers from stdin ?
10:20:57 <monochrom> how are the n integers separated?
10:21:03 <Veinor> one at a time, or all on one line?
10:21:10 <MarkDBlackwell> ski, I might say that I took your suggestion about corner cases in Each Consecutive from a couple days ago and it now handles by each 0 and also by each negative, all with infinite lists.
10:21:13 <Cale> If they're all on separate lines, you could  replicateM 10 readLn
10:21:24 <Cale> (and use the result as a list of Integers)
10:21:24 <wuch> separated by whitespace (space or new line)
10:21:27 <Cale> ah, okay
10:21:43 <monochrom> do you know n before reading?
10:22:06 <monochrom> or rather, does the program know
10:22:31 <wuch> it does know
10:22:42 <Cale> fmap (read . words) getContents  is a pretty quick way to read the entire input as a bunch of whitespace separated readable things of the same type
10:22:42 <antihoax> can someone point out an example how can i draw my circle out?
10:22:56 <Cale> er, map read . words
10:23:14 <Cale> antihoax: Using which drawing library?
10:23:23 <antihoax> something simple
10:23:24 <Veinor> replicateM 10 $ read getLine :: IO Integer -- will read 10 ints from stdin
10:23:33 <Veinor> er, that should be IO [Integer]
10:23:35 <antihoax> i have points
10:23:58 <antihoax> format [(x,y),(x,y)]
10:24:04 <Cale> Let's use... gloss
10:24:08 <hpc> :t let (.:) = fmap fmap fmap in read .: words .: getContents
10:24:08 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
10:24:08 <lambdabot>       Expected type: IO [String]
10:24:08 <lambdabot>       Inferred type: IO String
10:24:15 <hpc> :t let (.:) = fmap fmap fmap in (read .: words) .: getContents
10:24:18 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `Char'
10:24:20 <lambdabot>       Expected type: IO [String]
10:24:22 <lambdabot>       Inferred type: IO String
10:24:40 <Cale> cabal install gloss -- to make sure the library is installed
10:24:45 <hpc> oh well
10:24:47 <hpaste_> MarkDBlackwell pasted “eachCons” at http://hpaste.org/51969
10:26:40 <MarkDBlackwell> ski, I pasted it up now
10:27:50 <Cale> er, well, this is sad, gloss isn't working for me right now... maybe something is wrong with the state of my X server.
10:29:45 <DanBurton> :t (read . words) `fmap` getContents
10:29:46 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
10:29:46 <lambdabot>       Expected type: String
10:29:46 <lambdabot>       Inferred type: [String]
10:30:00 <DanBurton> :t (map read . words) `fmap` getContents
10:30:00 <lambdabot> forall a. (Read a) => IO [a]
10:30:49 <Cale> oh! It works, but oddly not from ghci
10:31:09 <Cale> antihoax: If you have Gloss installed, you should be able to write something like:
10:31:41 <MarkDBlackwell> cheater, from http://ccfit.nsu.ru/~ikuznecov/doc/Haskell%20Tutorial%20for%20C%20Programmers/intro.html , "Haskell's real power is the fact that all of its pieces fit so well together, not just that they are good pieces." That's the way I feel, learning that type declarations are functions, too. Parsimony. :)
10:32:26 <Cale> import Graphics.Gloss
10:32:26 <Cale> main = displayInWindow "My Window" (200, 200) (10, 10) white (Line [(80*cos t, 80*sin t) | t <- [0,0.1..2*pi]])
10:32:33 <Cale> or just:
10:32:41 <Cale> main = displayInWindow "My Window" (200, 200) (10, 10) white (Circle 80)
10:33:11 <ben_m> Can Gloss do animation?
10:33:22 <Cale> yes
10:33:34 <ben_m> Oh, cool. Will check it out then :)
10:34:11 <ski> MarkDBlackwell : hm ok .. did you ponder laws for it ?
10:34:29 <cheater> MarkDBlackwell: hmm, what do you mean by that? type declarations are functions?
10:34:38 <MarkDBlackwell> ski, good question. Not to be naive, but what are they?
10:35:26 <Cale> main = animateInWindow "My Window" (200, 200) (10, 10) white $
10:35:27 <Cale>           \t -> Line [(80 * cos t, 80 * sin t), (-80 * cos t, -80 * sin t)]
10:35:41 <Cale> ^^ easy :)
10:35:55 <Cale> t there is time
10:36:15 <Cale> http://hackage.haskell.org/packages/archive/gloss/1.3.4.1/doc/html/Graphics-Gloss-Interface-Game.html -- it also has some basic support for interactivity
10:36:44 <ben_m> That's awesme.
10:36:53 <saml> you're welcome
10:36:54 <ben_m> Thanks for letting me know about it!
10:37:47 <ski> MarkDBlackwell : well, interesting (usually) general statements about the operation(s) that are true
10:37:51 <Cale> I don't know why it won't work in GHCi on my machine
10:37:54 <ski> > eachCons 2 "abcdefgh"
10:37:56 <lambdabot>   ["ab","bc","cd","de","ef","fg","gh"]
10:37:58 <ski> > eachCons 3 "abcdefgh"
10:37:58 <MarkDBlackwell> cheater, in LYAH, data Shape = Circle (Point x1, y1) | Rectangle ((Point x2, y2) (Point x3, y3)) deriving (Show)  he says is a function in the world of types, like after :: .
10:38:00 <lambdabot>   ["abc","bcd","cde","def","efg","fgh"]
10:38:04 <SirFrancisDrake> could a considerably slower solution be regarded as a more elegant one?
10:38:15 <Cale> SirFrancisDrake: sure
10:38:31 <SirFrancisDrake> Cale: that's a shame. Thanks
10:38:43 <cheater> MarkDBlackwell: ah ok
10:38:55 <Cale> SirFrancisDrake: Often making things fast will also make them ugly, because you end up relying on details of the underlying architecture.
10:38:58 <cheater> MarkDBlackwell: yeah, there's a lot to be said about programming in the types.
10:38:59 <ski> MarkDBlackwell : i suppose i'm really asking because i'm not sure passing negative numbers really fits in very well
10:39:24 <Cale> SirFrancisDrake: Though it depends on just how fast you make them. Often there is an elegant solution which is fast enough.
10:39:51 <MarkDBlackwell> ski, I know you called 0 the corner case; I'm not sure why? I have:
10:39:54 <MarkDBlackwell> > eachCons -2 "abc"
10:39:55 <lambdabot>   Overlapping instances for GHC.Show.Show
10:39:55 <lambdabot>                              (GHC.T...
10:40:09 <ski> > eachCons (-2) "abcdefgh"
10:40:10 <lambdabot>   ["ba","cb","dc","ed","fe","gf","hg"]
10:40:43 <MarkDBlackwell> ski, seems useful to me, and covers all the integers.
10:40:50 <Cale> antihoax: Oh, also, you should be aware of lineLoop :: Path -> Picture
10:41:07 <Cale> antihoax: Which adds a segment to close the loop.
10:41:29 <MarkDBlackwell> > take 4 $ eachCons (-3) [1..]
10:41:30 <lambdabot>   [[3,2,1],[4,3,2],[5,4,3],[6,5,4]]
10:41:36 <ski> i would probably expect `forall n as. all ((n ==) . length) (eachCons n as)' .. which (obviously) doesn't hold if `n' is negative
10:42:10 <ski> (well, add a ` = True' at the end of that)
10:43:37 <MarkDBlackwell> ski, I don't grok, do you mean your point about length (eachCons n) == (n+ 1) ?
10:45:17 <Veinor> ... i feel like I'm missing something obvious. In HaskellDB, how do I get a Table r value corresponding to a table?
10:45:26 <MarkDBlackwell> ski, I suppose it works for absolute value of n, right? I truly am interested in knowing what is better idiomatic Haskell.
10:46:35 * hackagebot seqloc 0.3.1 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.3.1 (NicholasIngolia)
10:46:37 * hackagebot seqloc-datafiles 0.2 - Read and write BED and GTF format genome annotations  http://hackage.haskell.org/package/seqloc-datafiles-0.2 (NicholasIngolia)
10:47:42 <ski> > (eachCons 3 "abcdefghij")
10:47:44 <lambdabot>   ["abc","bcd","cde","def","efg","fgh","ghi","hij"]
10:47:50 <ski> > (eachCons 4 "abcdefghij")
10:47:51 <lambdabot>   ["abcd","bcde","cdef","defg","efgh","fghi","ghij"]
10:47:59 <ski> > take (10 - 4) (eachCons 3 "abcdefghij")
10:48:01 <lambdabot>   ["abc","bcd","cde","def","efg","fgh"]
10:48:03 <ski> > drop 3 (eachCons 4 "abcdefghij")
10:48:03 <ben_m> :src eachCons
10:48:05 <lambdabot>   ["defg","efgh","fghi","ghij"]
10:48:10 <ski> > zipWith (++) (take (10 - 4) (eachCons 3 "abcdefghij")) (drop 3 (eachCons 4 "abcdefghij"))
10:48:11 <lambdabot>   ["abcdefg","bcdefgh","cdefghi","defghij"]
10:48:13 <ski> > eachCons 7 "abcdefghij"
10:48:15 <lambdabot>   ["abcdefg","bcdefgh","cdefghi","defghij"]
10:48:19 <ski> this suggests a law, to me
10:48:33 <ben_m> eachCons isn't in prelude, is it?
10:48:43 <ski> ben_m : MarkDBlackwell's <http://hpaste.org/51969>
10:48:56 <ben_m> Thanks
10:50:11 <ski> MarkDBlackwell : the law being `forall m n as. eachCons (m + n) as = zipWith (++) (take (length as - n) (eachCons m as)) (drop m (eachCons n as))'
10:51:31 <ski> @check \m n as -> eachCons (m + n) (as :: [Bool]) == zipWith (++) (take (length as - n) (eachCons m as)) (drop m (eachCons n as))
10:51:32 <lambdabot>   Not in scope: `eachCons'Not in scope: `eachCons'Not in scope: `eachCons'
10:51:40 <ski> @check \m n as -> L.eachCons (m + n) (as :: [Bool]) == zipWith (++) (take (length as - n) (L.eachCons m as)) (drop m (L.eachCons n as))
10:51:41 <lambdabot>   Not in scope: `L.eachCons'Not in scope: `L.eachCons'Not in scope: `L.eachCo...
10:51:43 <ski> bah !
10:52:59 <ski> MarkDBlackwell : the idea being that if you piece together pieces from `eachCons m as' and `eachCons n as' in the right was (i.e. as above), you should get the pieces of `eachCons (m + n)'
10:53:04 <MarkDBlackwell> ski, I don't even know the forall function or why there's a period after as.  .
10:53:17 <ski> `forall' is not a function
10:53:24 <ski>   forall m n as. eachCons (m + n) as = zipWith (++) (take (length as - n) (eachCons m as)) (drop m (eachCons n as))
10:53:36 <ski> is a statement *about* the function `eachCons'
10:53:42 <ski> it's not Haskell code itself
10:54:01 <ski> (though one can put it in a comment, of course)
10:54:41 <ski> read the start as "for any valus of `m',`n',`as' (of the right types), the following holds : ..."
10:54:58 <MarkDBlackwell> ski, so it works in the right way for positive consecutives, but I think you are saying it would be better to reject negatives. What if you do add two negatives?
10:55:19 <ski> MarkDBlackwell : some similar, but simpler laws, to show the idea are :
10:55:38 <ski>   forall as. length (reverse as) = length as
10:55:50 <ski>   forall as bs. length (as ++ bs) = length as + length bs
10:56:44 <ski> (laws are used to reason about code, often one does that more or less without a thought for what the general law actually is, though)
10:57:06 <ski> MarkDBlackwell : well, i suspect i can break the law by using one positive and one negative number
10:57:31 <ski> let's say `n' is `- m', then the law says
10:57:57 <ski>   forall m as. eachCons (m - m) as = zipWith (++) (take (length as + m) (eachCons m as)) (drop m (eachCons (- n) as))
10:58:11 <ski> (er, s/- n/- m/)
10:58:27 <ski> we can try to simplify that, to get a feel for what it claims
10:58:49 <newsham> http://i.imgur.com/UsfGk.jpg
10:58:52 <newsham> oops, wrong channel
10:59:08 <ski>   forall m as. eachCons 0 as = zipWith (++) (take (length as + m) (eachCons m as)) (drop m (map reverse (eachCons m as)))
11:00:06 <ski>   forall m as. [] : [ [] | _ <- as] = zipWith (++) (take (length as + m) (eachCons m as)) (drop m (map reverse (eachCons m as)))
11:00:51 <ski> and it is pretty clear that since each element list in `eachCons m as' will have `m' elements (remember, `m' was assumed to be positive, or at least not negative)
11:01:17 <ski> and so the `zipWith (++) (...) (...)' will be a list where each element has `2*m' elements
11:01:42 <ski> while `[] : [ [] | _ <- as]' obviously is a list where each element list has zero elementsb
11:01:52 <MarkDBlackwell> ski, catching up, now I see as is like xs, not a keyword, and I see lists can't have negative length
11:02:34 <Cale> What is this eachCons?
11:02:49 <ski> this means that the only ways for the two to be equal is either if both are the empty list of lists (and the left one is never empty, so discard that case), or if `m' is zero, so that `2*m' is also zero
11:03:03 <ski> Cale : MarkDBlackwell's <http://hpaste.org/51969>
11:03:31 <ski> Cale : i'm attempting to argue that the case for negative integers there doesn't fir nicely into it
11:04:51 <MarkDBlackwell> ski, Cale,  I didn't even like the 0 integer, at first. I'm just trying to be idiomatic Haskell-like, whatever that will turn out to be!
11:05:13 <ski> MarkDBlackwell : *nod* .. and the above didn't need to assume "lists" with negative number of elements either (note how i only used that each element list of `eachCons m as' should have `m' elements in the case when `m' is non-negative, so side-stepping that problem)
11:05:16 <Cale> > eachCons 2 "Hello"
11:05:18 <lambdabot>   ["He","el","ll","lo"]
11:05:20 <Cale> oh
11:05:36 <ski> > (eachCons 3 "abcdefghij")
11:05:37 <lambdabot>   ["abc","bcd","cde","def","efg","fgh","ghi","hij"]
11:05:39 <ski> > (eachCons 4 "abcdefghij")
11:05:40 <lambdabot>   ["abcd","bcde","cdef","defg","efgh","fghi","ghij"]
11:05:45 <ski> > take (10 - 4) (eachCons 3 "abcdefghij")
11:05:46 <lambdabot>   ["abc","bcd","cde","def","efg","fgh"]
11:05:50 <ski> > drop 3 (eachCons 4 "abcdefghij")
11:05:52 <lambdabot>   ["defg","efgh","fghi","ghij"]
11:05:55 <ski> > zipWith (++) (take (10 - 4) (eachCons 3 "abcdefghij")) (drop 3 (eachCons 4 "abcdefghij"))
11:05:55 <ion> > eachCons 3 "0123"
11:05:57 <lambdabot>   ["012","123"]
11:05:57 <lambdabot>   ["abcdefg","bcdefgh","cdefghi","defghij"]
11:05:58 <mekeor> hey guys. i'm looking for a haskell-library which allows me to draw pictures as simple/comfortable as i was using "Logo" or "KTurtle". -- ideas/suggestions ?
11:05:59 <ski> > eachCons 7 "abcdefghij"
11:06:01 <lambdabot>   ["abcdefg","bcdefgh","cdefghi","defghij"]
11:06:08 <ski> Cale : those ^ suggested the law to me
11:06:24 <paolino> hello, I'm trying gloss library. I'm asked to write a simulation as a direct function of time. Is that an FRP example?
11:06:59 <Cale> paolino: Well...
11:07:09 <Cale> paolino: It's functional, at least :)
11:07:18 <Cale> There's not much that's reactive about it
11:07:20 <MarkDBlackwell> ski, I suppose this distributive-like property is useful in Haskell?
11:07:23 <paolino> :-)
11:07:35 <ski> MarkDBlackwell : note that i'm not claiming that it is wrong to add this kind of ad-hoc case -- in some cases it might be worth it -- i'm only claiming that it doesn't by itself extrapolate the pattern
11:08:01 <ski> (MarkDBlackwell : otoh, the `0' case *does* extrapolate the original pattern, in a nice way)
11:08:20 <MarkDBlackwell> Cale, and ski suggested to me that eachCons 0 "abc" should be [[],[],[],[]]
11:08:27 <Cale> > let eachCons n xs = zipWith (flip const) xs . map (take n) . takeWhile (not . null) . iterate (drop 1) $ xs
11:08:28 <lambdabot>   not an expression: `let eachCons n xs = zipWith (flip const) xs . map (take...
11:08:28 <MarkDBlackwell> > eachCons 0 [1,2,3]
11:08:29 <lambdabot>   [[],[],[],[]]
11:08:35 <ski> MarkDBlackwell : i'm sorry if i'm not able to explain more clearly why i think the negative case doesn't fit in the pattern
11:08:36 <Cale> > let eachCons n xs = zipWith (flip const) xs . map (take n) . takeWhile (not . null) . iterate (drop 1) $ xs in eachCons 2 "hello"
11:08:37 <lambdabot>   ["he","el","ll","lo","o"]
11:08:40 <paolino> Cale , what is missing to be reactive?
11:08:42 <Cale> oh, doh
11:09:13 <antihoax> cant test ut currently
11:09:17 <MarkDBlackwell> ski, it's my fault that I am not as mathematical, but I am trying to follow you more
11:09:21 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 2 "hello" -- perhaps this?
11:09:22 <antihoax> ;/
11:09:22 <DanBurton> paolino: unpredictable inputs, e.g. user input
11:09:23 <lambdabot>   ["he","el","ll","lo"]
11:09:35 <Cale> yeah
11:09:41 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 0 "hello"
11:09:42 <lambdabot>   ["","","","",""]
11:09:43 <ski> as an example of where allowing negative integers fits the pattern, consider
11:09:49 <ski> @type shift
11:09:51 <lambdabot> forall a. (Bits a) => a -> Int -> a
11:09:56 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 3 "hello"
11:09:58 <lambdabot>   ["hel","ell","llo"]
11:10:43 <Cale> How's that? :)
11:11:03 <MarkDBlackwell> So, Cale, what do you think of ski's wanting each consecutive 0 to be like this?
11:11:11 <MarkDBlackwell> > eachCons 0 [1,2,3]
11:11:13 <lambdabot>   [[],[],[],[]]
11:11:14 <ski> `shift n i' considers `n' as a bit-string, and shifts it `i' bits towards the more significant bits
11:11:16 <Cale> MarkDBlackwell: Well, my implementation makes its own proposal
11:11:19 <ski> > shift 16 0 :: Integer
11:11:20 <lambdabot>   16
11:11:22 <ski> > shift 16 1 :: Integer
11:11:23 <lambdabot>   32
11:11:23 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 0 "hello"
11:11:24 <ski> > shift 16 2 :: Integer
11:11:25 <lambdabot>   ["","","","",""]
11:11:25 <lambdabot>   64
11:11:29 <ski> but note how
11:11:33 <ski> > shift 16 (-1) :: Integer
11:11:35 <lambdabot>   8
11:11:36 <ski> > shift 16 (-2) :: Integer
11:11:38 <lambdabot>   4
11:11:40 <DanBurton> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in take 10 $ eachCons 3 [1..]
11:11:42 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
11:11:42 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 0 [1,2,3]
11:11:44 <ski> also work in a sensible way
11:11:44 <lambdabot>   [[],[],[]]
11:12:28 <MarkDBlackwell> ski, so in shift, negative left shift is right shift, very familiar and useful.
11:12:46 <ski> indeed
11:12:48 <ski> MarkDBlackwell : regarding the `0' case -- it's often the case than when designing some datastructure one has the option of including or excluding an "empty case"
11:13:00 <MarkDBlackwell> Cale, what did your implementation propose?
11:13:45 <ski> MarkDBlackwell : even though one might not think such an "empty case" to be very useful on its own, it is useful as a starting place to starting building more complex values out of
11:14:10 <Cale> MarkDBlackwell: That it's a list of length 0 lists the same length as the original.
11:14:13 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 0 [1,2,3]
11:14:15 <MarkDBlackwell> ski, shift Integer, right.
11:14:15 <lambdabot>   [[],[],[]]
11:14:17 <Cale> ^^ like that
11:14:27 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 2 [1,2,3]
11:14:28 <lambdabot>   [[1,2],[2,3]]
11:14:31 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 1 [1,2,3]
11:14:33 <lambdabot>   [[1],[2],[3]]
11:14:34 <ski> MarkDBlackwell : e.g. it might have been that lists couldn't be empty, but intead either `[a]' (singleton list), or `a:as' (list with at least two elements)
11:14:55 <Cale> It also makes some amount of sense for it to be one longer
11:15:04 <edwardk> tibbe: all set
11:15:13 <MarkDBlackwell> ski, I hear you about the important empty case, and counting on length of 4 with the empty case on a list of three.
11:15:14 <ski> but then one would typically have to repeat code for the `a' in the `[a]' case, and the `a' in the `a:as' case, when looping on lists
11:15:29 <DanBurton> @src enumFromTo
11:15:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:15:33 <Cale> because  length (eachCons n xs) = length xs - n + 1 is a nice property to have.
11:15:42 <ski> so, it pays off to look for "empty cases", when they exist
11:15:47 <MarkDBlackwell> ski because of a law. And, the eachCOns is inconsistent when given negative consecutives. :)
11:15:55 <tibbe> edwardk, thanks!
11:16:04 <ski> MarkDBlackwell : of course, you can saw that you don't like that particular law :)
11:16:14 <ski> s/saw/say/
11:16:47 <ski> MarkDBlackwell : but it appeared pretty natural to me, with no apparent reason why it should work in all sensible cases
11:16:58 <ski> s/should/shouldn't/
11:17:03 <MarkDBlackwell> ski, I hear you that the empty case is greatly important, and believe you! And there might be some way to build on the n+1 length of it, like just subtracting 1 from the length to find the original n, I guess.
11:17:14 <ohwow> Hm, what's the difference between ">>" and ";"?
11:17:28 <dmwit> ohwow: ; is sometimes >>=
11:17:31 <dmwit> =)
11:17:33 <ion> >> is an operator, ; is syntax.
11:17:33 <ski> ohwow : `(>>)' is a value, `;' is layout syntax
11:17:37 <Cale> ohwow: One is an infix operator, the other is syntax
11:17:39 <dmwit> And sometimes it's neither.
11:17:44 <ohwow> hm
11:17:46 <ohwow> syntax?
11:17:54 <ohwow> i thought it was a compositional operator
11:17:57 <ion> > let a = 5; b = 6 in a+b
11:17:57 <Cale> ohwow: ; is part of the syntax of do-expressions
11:17:57 <lambdabot>   11
11:18:02 <engla> ohwow: only inside do
11:18:04 <dmwit> ohwow: Not in Haskell. In math, yes.
11:18:10 <ohwow> ah
11:18:11 <ski> > let {x = y + 1; y = 4} in x
11:18:12 <lambdabot>   5
11:18:17 <ohwow> so you can't use `;' as a HOF?
11:18:17 <Cale> ohwow: and the syntax of case, let/where, and some other stuff
11:18:21 <ohwow> you have to use >>?
11:18:22 <dmwit> ohwow: no
11:18:25 <dmwit> ohwow: yes
11:18:27 <dmwit> in order
11:18:33 <ohwow> ok
11:18:34 <ohwow> :)
11:18:34 <ohwow> thanks
11:18:35 <MarkDBlackwell> ski & Cale, = n+1 is generally true, so why throw it out for 0 consecutive, I get it. How about negative 1? Can I make a list of length 0?
11:18:56 <ohwow> > Can I make a list of length 0?
11:18:56 <lambdabot>   <no location info>: parse error on input `of'
11:18:58 <ohwow> yes?
11:19:04 <dmwit> > ([], length [])
11:19:05 <lambdabot>   ([],0)
11:19:09 <engla> ohwow: you don't need do notation, just learn about >>= and >> first
11:19:23 <dmwit> psh, you don't need >>= and >>, just learn do notation
11:19:25 <dmwit> ;-)
11:19:26 <ski> MarkDBlackwell : are you talking about the `[] : [ [] | _ <- x]' case, or something else ?
11:19:34 <engla> ... :-)
11:19:45 <ion> psh, you don’t need >>= and >> and do notation, just learn fmap and join.
11:19:53 <Cale> MarkDBlackwell: [] has length 0
11:20:02 <ion> psh, you don’t need >>= and >> and do notation and fmap and join, just use monad comprehensions.
11:20:08 <MarkDBlackwell> ohwow, no, I mean
11:20:15 <ski> @undo do {x <- foo; bar x; [y,z] <- baz x; quux x y z}
11:20:16 <lambdabot> foo >>= \ x -> bar x >> baz x >>= \ a -> case a of { [y, z] -> quux x y z; _ -> fail ""}
11:20:18 <MarkDBlackwell> > eachCons (-1) "abc"
11:20:20 <lambdabot>   ["a","b","c"]
11:20:30 <dmwit> (Actually, for teaching/learning purposes, I prefer =<< to >>=.)
11:20:58 <cheater> dmwit: why
11:21:02 <MarkDBlackwell> should have a length of 5  -- I guess not.
11:21:12 <ski> @type ContT . (>>=)
11:21:13 <lambdabot> forall a (m :: * -> *) r. (Monad m) => m a -> ContT r m a
11:21:20 <dmwit> mekeor: Did you ever get an answer?
11:21:28 <Cale> MarkDBlackwell: well, maybe it should...
11:21:35 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons (-5) [1,2,3]
11:21:36 <lambdabot>   [[],[],[]]
11:21:40 <Cale> heh
11:21:42 <dmwit> cheater: It encourages the nice thought pattern of "lifting": (=<<) :: (a -> m b) -> (m a -> m b)
11:21:46 <ski> MarkDBlackwell : anyway, laws are important regardless of whether you state them explicitly or not
11:21:49 <MarkDBlackwell> Cale, when you asked me what I thought of your proposal, I didn't follow what it was.
11:22:01 <Cale> MarkDBlackwell: ^^ I wrote my own version of eachCons there
11:22:11 <Cale> (Did you not see my lines talking to lambdabot?)
11:22:12 <ski> MarkDBlackwell : when you refactor your code, changing the form in which it is written, you're using laws all the time
11:22:19 <dmwit> cheater: The "You Could Have Invented Monads" tutorial is a nice introduction that uses this intuition.
11:22:23 <cheater> dmwit: hm
11:22:27 <cheater> dmwit: got a link?
11:22:31 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 3 [1..10]
11:22:32 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
11:22:36 <MarkDBlackwell> ski, I agree, I use laws, too; you're good at it!
11:22:37 <dmwit> ?google you could have invented monads and maybe you already did sigfpe
11:22:38 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
11:22:38 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
11:22:52 <cheater> thank you
11:23:10 <ski> MarkDBlackwell : and it generally helps if the laws are "natural" with a minimum of strange special cases
11:23:12 <antihoax> what cancause Graphics/Rendering/OpenGL/Raw/ARB/Sync.hs:57:16:
11:23:12 <antihoax>     parse error on input `CALLCONV'
11:23:49 <MarkDBlackwell> ski, I agree with the use of laws, just am slower at grasping the Haskell notation and mathematics than you. :) But what about length 5? Will that make it fit into your laws, which I'm still trying to grasp for mixed negative and positive consecutives?
11:23:49 <Cale> antihoax: I suspect that someone expected the C preprocessor to be run over the file and it didn't get run.
11:23:53 <dmwit> antihoax: Did you look at Graphics/Rendering/OpenGL/Raw/ARB/Sync.hs:57:16 ?
11:24:14 <antihoax> dmwit<< not yet
11:24:41 <ski> MarkDBlackwell : one doesn't have to reason explicitly about laws much of the time, but i think it helps to try to design operations such that they satisfy nicer laws (especially ones which "could be expected", which is a fuzzy criterion, i know :/ )
11:25:17 <MarkDBlackwell> Cale, I see your expression, and I see the drop 1, and I see the result, quite the same as eachCons 3 [1..10], so, I guess you mean your code is terse?
11:25:29 <ski> MarkDBlackwell : e.g. i'm appalled at how in Matlab often several completely (or subtly) different operations are lumped together into the same function
11:25:32 <Cale> MarkDBlackwell: I mean, maybe it should do what this code does
11:25:36 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons 0 [1..10]
11:25:38 <lambdabot>   [[],[],[],[],[],[],[],[],[],[]]
11:25:44 <antihoax> EXTENSION_ENTRY(glFenceSync,GLenum -> GLbitfield -> IO GLsync)
11:26:09 <ski> MarkDBlackwell : what about when *what* list has length `5' ?
11:26:21 <Cale> antihoax: That looks like C preprocessor shenanigans.
11:26:33 <Cale> antihoax: Maybe CALLCONV didn't get set.
11:26:50 <ski> Cale : btw, i assume you agree that allowing `n' in `eachCons n as' to be negative doesn't fit it ..
11:27:01 <antihoax> i've just downloaded the latest lib
11:27:04 <MarkDBlackwell> ski, as above, eachCons (-1) [1..3] might have a length of 5.
11:27:18 <Cale> ski: Well, my program is okay with the negative case, but it does the same thing as the 0 case
11:27:24 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons (-2) [1..10]
11:27:26 <lambdabot>   [[],[],[],[],[],[],[],[],[],[]]
11:27:29 <Cale> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in eachCons (-100) [1..10]
11:27:31 <lambdabot>   [[],[],[],[],[],[],[],[],[],[]]
11:27:36 <ski> yeah, so it's truncating
11:28:00 <antihoax> OpenGLRaw-1.1.0.1 OpenGLRaw21-1.2.0.0
11:28:10 <Cale> But does it really matter what it does in this case?
11:28:27 <Cale> I don't think so.
11:28:58 <ski> Cale : well, MarkDBlackwell wanted to add (i might say "showhorn" ;) extra functionality in there :
11:29:11 <ski> > eachCons (-3) "abcdefgh"
11:29:13 <lambdabot>   ["cba","dcb","edc","fed","gfe","hgf"]
11:29:16 <ski> > eachCons 3 "abcdefgh"
11:29:18 <Cale> I think it should do whatever the code for the function happens to do without adding any additional effort.
11:29:18 <lambdabot>   ["abc","bcd","cde","def","efg","fgh"]
11:29:20 <MarkDBlackwell> Cale, Actually, I have your other-day, fine suggestion recorded in my source file: "(zipWith const <*> drop 4) . map (take 4) . tails $ [1..10]" I'm trying to follow you, now.
11:29:39 <Cale> MarkDBlackwell: oh, that works too :)
11:29:50 <Cale> tails = iterate (drop 1)
11:30:04 <MarkDBlackwell> Does it produce a list of 10 empty lists with eachCons 0 [1..10]  ? I haven't followed your code, yet.
11:30:25 <Cale> > let f n = (zipWith const <*> drop n) . map (take n) . tails in f 0 [1..10]
11:30:26 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[]]
11:30:27 <ski> > let eachCons n xs = map (take n) . takeWhile (not . null . drop (n-1)) . iterate (drop 1) $ xs in length (eachCons 0 [1..10])
11:30:29 <lambdabot>   10
11:30:34 <Cale> > let f n = (zipWith const <*> drop n) . map (take n) . tails in length (f 0 [1..10])
11:30:35 <lambdabot>   11
11:30:38 <Cale> ah, okay
11:30:43 <Cale> so that's a little nicer
11:30:46 <Cale> > let f n = (zipWith const <*> drop n) . map (take n) . tails in length (f (-1) [1..10])
11:30:48 <lambdabot>   11
11:30:49 <ski> eleven sounds as it should be
11:30:55 <Cale> and that truncates moar
11:31:01 <Cale> but whatever
11:31:12 <Veinor> hmm
11:31:15 <Veinor> haskelldb seems... complicated
11:31:29 <Cale> Veinor: It's a little complicated, but it's also kinda nice.
11:31:58 <Veinor> it feels like it could really use Template Haskell
11:32:18 <Cale> Maybe
11:32:25 <Cale> It does have some explicit code generation stuff
11:32:33 <ski> MarkDBlackwell : another point re laws -- i think usually a type class with operations but no laws they are meant to follow aren't that nice
11:32:37 <dmwit> > drop (-1) [1..10] == [0..10] -- WHERE ARE YOUR LAWS NOW??
11:32:37 <lambdabot>   False
11:32:42 <Cale> Where you build a simple program and it spits out some static definitions for you.
11:32:53 <Cale> > drop (-1) [1..10]
11:32:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:33:00 <Cale> interesting
11:33:02 <Cale> > drop (-2) [1..10]
11:33:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
11:33:17 <Cale> That makes a certain amount of sense
11:33:25 <dmwit> yes, just a joke =)
11:34:03 <dmwit> drop n [1..10] = [n+1..10], right? ;-)
11:34:09 <Cale> There was a paper arguing that truncating subtraction on naturals is often the right one
11:34:13 <ski> MarkDBlackwell : the laws sortof enforce (well, if the programmer honours them, Haskell can't check it) that the instances of the class have something in more in common than just having a couple of operations what could do wildly different things in different instances
11:34:25 <ski> Cale : yeah, it's an adjunction
11:34:46 <Cale> Does anyone know which paper?
11:34:57 <tac-tics> can someone explain what an adjunction is in humanspeak?
11:35:00 * ski can't recall seeing such a paper, though
11:35:23 <Cale> tac-tics: No. Nobody can do it. :)
11:35:40 <tac-tics> Cale: Can you give me a formal proof of that statement?
11:36:08 <tac-tics> It's something like x -> y z turns into x y* -> z or something, isn't it?
11:36:12 <hpc> an adjunction is like a vending machine that only accepts coins...
11:36:21 <Cale> tac-tics: They can wave their hands wildly and say a bunch of junk which might or might not satisfy you while giving almost no idea of what an adjunction is though.
11:36:42 <Cale> tac-tics: If you want to know, you kinda have to have some proper definitions of things :)
11:36:44 <ski> tac-tics : in this *specific* case, it's that `forall m,n,o.  m =< n + o  <=>  m - o =< n', where `(+)' is addition on naturals, and `(-)' is truncating subtraction (sometimes called "monus")
11:37:19 <Cale> tac-tics: It's that Hom(FX,Y) ~= Hom(X,GY)
11:37:23 <ski> tac-tics : so, it's kind of a weaker form of the useful law `forall m,n,o.  m = n + o  <=>  m - o = n'
11:37:38 <tac-tics> Cale: I have a hard time believing every concept needs a strong, concrete definition for a human to get the gist of it :)
11:38:09 <ski> tac-tics : in this case you'd better believe Cale, as regards the general concept of adjunction
11:38:11 <tac-tics> ski: So monus the adjunct of plus? Or how do you put it in words?
11:38:25 <SirFrancisDrake> is there a left handed cons? leftHandedCons :: [a] -> a -> [a]
11:38:45 <ski> tac-tics : yes, `(+ o)' is the right adjoint of `(- o)'
11:38:53 <DanBurton> :t flip (:)
11:38:54 <lambdabot> forall a. [a] -> a -> [a]
11:38:54 <tac-tics> ok
11:39:21 <SirFrancisDrake> thanks. I think that means "no"
11:39:22 <tac-tics> Cale ~= means isomorphic there?
11:39:23 <DanBurton> SirFrancisDrake: or do you want "snoc" that appends to the end of the list?
11:39:25 <ski> (and `(- o)' is the left adjoint of `(+ o)', together we say that they form an adjunction situation)
11:39:40 <Cale> tac-tics: actually, it means a little more... it means that two bifunctors are naturally isomorphic
11:39:43 <ski> tac-tics : (re `~='), yes
11:39:53 <Cale> but yeah
11:39:54 <SirFrancisDrake> DanBurton: yes
11:39:57 <tac-tics> kk
11:40:21 <DanBurton> SirFrancisDrake: that's not really recommended on the built-in list type, since it has to traverse the whole list
11:40:25 <ddarius> Cale: Maybe you are thinking about Turner's Total Functional Programming?
11:40:40 <DanBurton> SirFrancisDrake: Data.Sequence has an operation to append at the end
11:40:44 <MarkDBlackwell> ski, so my question about 5 is, for all eachCons n xs, where n>=0, it is true that, as you pointed out, the length of the resulting list is length(xs) - n + 1. So, if I use -1 for n, I could fit into *that* law by making a list of length one bigger than if n is 0. So, if n is -1 and xs is [1,2,3], my resulting list should have length 5, right?
11:40:57 <DanBurton> @hoogle Sequence a -> a -> Sequence a
11:40:57 <lambdabot> Warning: Unknown type Sequence
11:40:57 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:40:57 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:41:04 <ski> Cale : but i think one could state that as `forall X,Y. Hom(FX,Y) ~= Hom(X,GY)', for a suitable interpretation of `forall' :(
11:41:05 <SirFrancisDrake> DanBurton: DanBurton: I'm aware of that, thanks. My case is somewhat specific and doesn't deal with long lists
11:41:11 <ski> s/:(/:)/
11:41:50 <DanBurton> SirFrancisDrake: in that case  "snoc xs x = xs ++ [x]" should work for you, hideous though it is
11:42:19 <juliohm> Dear all, how Haskell executables are linked? It's safe to copy it for another Linux machine?
11:42:45 <DanBurton> erm...probably safe if the machines are identical..
11:42:46 <ski> MarkDBlackwell : yes, i agree that appears to fit
11:43:03 <ski> MarkDBlackwell : i'm not sure one can actually do it, though
11:43:04 <SirFrancisDrake> DanBurton: kewl.
11:43:38 <MarkDBlackwell> ski and Cale, I can tell you that in the Rails world, readability is 'king', and adjunctive functions (with the same name but different arrangements of parameters) is considered very useful. :)
11:43:44 <juliohm> DanBurton, they are dynamically linked?
11:44:10 <Cale> MarkDBlackwell: Except that has nothing to do with the sort of adjunction we're talking about, as far as I know :)
11:44:15 <DanBurton> juliohm: I'm not entirely sure
11:44:20 <juliohm> There is a way to build a nifty portable tool? :-)
11:44:22 <ski> (we lose the `forall n as. all ((n ==) . length) (eachCons n as) = True' for `-1', though)
11:44:22 <DanBurton> @google haskell dynamic link
11:44:23 <MarkDBlackwell> ski, is that coterminous with what your law was about? or just another dimension?
11:44:25 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking
11:44:25 <lambdabot> Title: SharedLibraries/PlatformSupport – GHC
11:44:33 <saml> r u looking for a jbo?
11:44:49 <Cale> tac-tics: If we have a pair of categories C and D, then an adjunction is a pair of functors F: C <- D and G: C -> D (called the left and right adjoint respectively), together with a pair of natural transformations: epsilon: FG -> 1 called the counit, and eta: 1 -> FG called the unit
11:45:07 <Cale> such that a couple natural laws hold with regard to putting epsilon and eta together
11:45:14 <MarkDBlackwell> Cale, are you talking about the reversed lists in eachCons for negative consecutives being bad? or was it just the length, or something else?
11:45:18 <ski> @all-dicts coterminous
11:45:19 <lambdabot> *** "Coterminous" gcide "The Collaborative International Dictionary of English v.0.48"
11:45:19 <lambdabot> Coterminous \Co*ter"mi*nous\ (k?-t?r"m?-n?s), a. [Cf.
11:45:19 <lambdabot>    {Conterminous}.]
11:45:20 <lambdabot>    Bordering; conterminous; -- followed by with.
11:45:22 <lambdabot>    [1913 Webster]
11:45:23 <lambdabot> [17 @more lines]
11:45:39 <MarkDBlackwell> ski, I can add empty lists to both ends to make the result length right.
11:45:40 <Cale> Specifically, that epsilon F . F eta = 1_F, and G epsilon . eta G = 1_G
11:45:43 <tac-tics> Cale: Can you give me a concrete example of a natural transformation? I kinda lose it at category theory right after Functors
11:45:50 <Cale> tac-tics: oh, sure
11:45:59 <MarkDBlackwell> saml, I, too, am looking for a jbo ;/
11:46:05 <Cale> tac-tics: Let's start with Haskell :)
11:46:19 <ski> MarkDBlackwell : "this" referring to the "in the Rails world, ..." part, or to the `n = -1' case ?
11:46:24 <tac-tics> Haskell? That washed up language? :P
11:46:26 <Cale> In Haskell, all parametrically polymorphic functions are natural transformations in one way or another
11:46:27 <tac-tics> Cale: Sure
11:46:35 * hackagebot samtools 0.2 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.2 (NicholasIngolia)
11:46:40 <Cale> So, if we have some function  forall a. F a -> G a
11:46:43 <ski> @type maybeToList
11:46:44 <lambdabot> forall a. Maybe a -> [a]
11:46:47 <Cale> that constitutes a natural transformation F -> G
11:46:53 <ski> @type listToMaybe
11:46:54 <lambdabot> forall a. [a] -> Maybe a
11:46:59 <MarkDBlackwell> Cale, okay, I see what you mean about the term adjunction, that it's not just a guard clause for different parameters.
11:47:00 <tac-tics> @src listToMaybe
11:47:01 <lambdabot> listToMaybe []        =  Nothing
11:47:01 <lambdabot> listToMaybe (a:_)     =  Just a
11:47:15 <tac-tics> Cale: Thanks, that makes more sense
11:47:35 <Cale> tac-tics: Do you know much linear algebra?
11:47:44 <tac-tics> I know more than most people
11:47:47 <Cale> Okay
11:48:02 <bscarlet> juliohm: ghc binaries aren't particularly different from other binaries. They're ELF libraries, and you can look at their dynamic library dependencies with ldd, as with any linux ELF binary. ghc does use libgmp, so that's usually a dependency.
11:48:09 <MarkDBlackwell> ski, <searching backward for the word, 'this'...>
11:48:24 <ski> tac-tics : note however that if a function of type `forall a. F a -> G a' could somehow do different things depending on what type `a' was (such as looking inside the inputs of type `a'), then it would fail to be a natural transformation
11:48:44 <Cale> So, if we have a field F, we can form from it the ring of n by n matrices over F, yeah? GL_n(F)
11:49:14 <Cale> GL_n happens to be a functor from the category of fields to the category of rings
11:49:27 <Cale> oh, sorry, invertible matrices
11:49:31 <tac-tics> ski: I remember reading that somewhere a long time ago. Obviously, in a pure enough language, that's impossible, since there's no information on the type of a until after a is already applied
11:49:36 <Cale> er, and that should be groups :)
11:49:41 <Cale> I'm messing this up :)
11:49:51 <Cale> So, if we have a field F, we can form from it the group of invertible n by n matrices over F, yeah? GL_n(F)
11:49:56 <Cale> *there*
11:49:57 <tac-tics> Cale: gotcha,
11:50:02 <Cale> okay
11:50:14 * tac-tics always messes up math on first explanations as well, so he understands
11:50:27 <ski> tac-tics : maybe you mean s/in a pure enough language/in a language which can be implemented using type-erasure/
11:50:34 <juliohm> Thank you bscarlet and DanBurton :-)
11:50:36 <Cale> So now another thing we can do is to form the group of units of the field F, F*, which just has all the elements of F except 0, and the group operation is multiplication
11:50:39 <MarkDBlackwell> ski, was it where I said, "  So, Cale, what do you think of ski's wanting each consecutive 0 to be like this?  >  eachCons 0 [1,2,3] lambdabot	[[],[],[],[]]  ?
11:51:01 <Cale> and that's another functor Field -> Group
11:51:17 <Cale> So we have these two functors, each of which turns a field into a group
11:51:25 <Cale> GL_n and *
11:51:35 * hackagebot haddock 2.9.3 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.9.3 (DavidWaern)
11:51:48 <Cale> Now there's a natural transformation GL_n -> *
11:51:49 <MarkDBlackwell> ski, maybe it wasn't me.
11:52:08 <Cale> which for each field F, is a group homomorphism GL_n(F) -> F*
11:52:16 <Cale> can you guess what it is? :)
11:52:27 <Cale> (Here's where linear algebra comes in)
11:52:31 <tac-tics> hold on
11:52:42 <tac-tics> I had a soda blow up in my face, but I really do want to try this out
11:52:50 <Cale> okay :)
11:53:02 <ski> MarkDBlackwell : re "readability is 'king'", that is noble, though i would maybe want to strive for "reasonability" (which might not be quite the same thing, at least in initial understandings of the code)
11:53:14 <ski> MarkDBlackwell : i'm not sure what "adjunctive functions" are, though
11:56:39 <Johannes2> Wait, what? Homomorphism between F and F*?
11:56:41 <tac-tics> Cale and you said by GL_n, it's the functor from the Field to the RING of nxn invertbl mats, right?
11:56:46 <tac-tics> (not the ring, right?)
11:56:57 <Johannes2> That sounds absurd :(
11:57:05 <MarkDBlackwell> ski, people differ, right? I respect mathematicians for the way they are. :) I'm saying, my goal being idiomatic Haskell, if eachCons (-1) [1,2,3] were [[],[[1],[2],[3],[]] , would that make you happy or fit the laws you see?
11:57:15 <Cale> tac-tics: yeah, I corrected that definition
11:57:21 <tac-tics> kk, just making sure
11:57:29 <Cale> So, if we have a field F, we can form from it the group of invertible n by n matrices over F, called GL_n
11:57:43 <Cale> So GL_n: Field -> Group
11:57:49 <Cale> and *: Field -> Group
11:57:54 <MarkDBlackwell> ski, oops, the length differs, so it's very bad!
11:57:59 <bscarlet> Johannes2: Didn't he say homomorphism from GL_n(F) to F*?
11:58:02 <tac-tics> Cale: Yeah, I follow that much
11:58:04 <MarkDBlackwell> ski, of each element.
11:58:05 <Cale> and so because we have a pair of parallel functors, we can ask if there's a natural transformation
11:58:19 <Johannes2> Sorry, he did. I didn't catch the context on that GL_n though
11:58:31 <Cale> Johannes2: I said homomorphism from GL_n(F) -> F*, for each field F
11:58:53 <MarkDBlackwell> ski, I can make eachCons (-1) [1,2,3] be [[3],[1],[2],[3],[1]] , how about that?
11:59:24 <Cale> MarkDBlackwell: cute
11:59:31 <Cale> MarkDBlackwell: (but I don't know how useful it is)
12:00:00 <tac-tics> Cale: I want to say something something determinant of the matrix, but only because you said it was a linear algebra question, and F* doesn't contain a 0 element (which corresponds to invertibility, I think)
12:00:00 <Cale> It's a bit odd to think of lists as circular
12:00:02 <ddarius> f(I)I^-1
12:00:03 <ski> MarkDBlackwell : well, according to the other law, each element ought to have `-1' elements ..
12:00:27 <ddarius> Cale: Just integrate them.
12:00:54 <ski> MarkDBlackwell : i think i would conclude that the `-1' doesn't work out fully either (even though i grant that it appeared to fit the pattern you found above)
12:01:36 * hackagebot seqloc 0.3.1.1 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.3.1.1 (NicholasIngolia)
12:02:09 <Cale> tac-tics: right!
12:02:28 <Cale> tac-tics: It's a group homomorphism, because det(M N) = det(M) det(N)
12:02:34 <Cale> and det(I) = 1
12:02:54 <tac-tics> Cale: lol, maybe I don't suck at math as much as I think I do
12:02:55 <ski> (MarkDBlackwell : generally, i'm all for including "neglected cases", but only when they seem to fit in fully .. e.g. i'd want `gcd 0 0' to return `0', instead of erroring out)
12:02:58 <ski> > gcd 0 0
12:02:59 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
12:03:18 <Cale> tac-tics: and moreover it's natural in the sense that if you apply any field homomorphism to the elements of the matrix, it'll be as if you applied that field homomorphism to the result
12:03:22 <MarkDBlackwell> ski & Cale, and eachCons (-2) [1,2,3] be [[1,[]],[2,1],[3,2],[[],3],[[],[]]]
12:03:32 <ski> (.. because returning `0' fits the (better version of the) definition of "greatest common divisor")
12:03:35 <Cale> tac-tics: (because the determinant is a polynomial in the entries of the matrix)
12:03:44 <tac-tics> Cale: I will have to sleep on that example so it has time to grow
12:03:52 <ski> MarkDBlackwell : that's unfortunately badly typed
12:04:00 <Cale> tac-tics: I have some more stuff written about natural transformations and adjunctions...
12:04:08 <incluye> why can't lambdabot handle @pl with a 3-tuple as an argument
12:04:09 <ski> > [[1 :: Integer,[]],[2,1],[3,2],[[],3],[[],[]]]
12:04:10 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
12:04:10 <lambdabot>         against inf...
12:04:14 <tac-tics> Cale: You should blog about them
12:04:21 <Cale> tac-tics: http://analogical-engine.com/wordpress/?page_id=232
12:04:24 <Cale> I already have
12:04:29 <tac-tics> heh
12:04:58 <tac-tics> Haskell's greatest outputs, in order of volume: PhD theses, Blogs, Compilers
12:05:20 <ski> incluye : it would need to know about `curry3', or `fst3',`snd3',`thd3', or something similar
12:05:32 <incluye> oh
12:06:13 <ski> hm, actually i meant `uncurry3'
12:07:58 <tac-tics> Cale: wait a sescond, do functions, functors, and natural transformations all correspond in some way to functions in different universes in DT languages?
12:08:13 <Cale> tac-tics: mmmm...
12:08:19 <tac-tics> Functions belong in Set, Functors are Set -> Set which is Set 1,
12:08:22 <Cale> tac-tics: I don't know enough about DT languages
12:08:33 <MarkDBlackwell> ski, okay, that makes a lot of sense, 'only when they fit in, fully.' :) Thanks for your help! :)
12:08:46 <tac-tics> and Forall a : Set. F a -> G a is in Set 1... too... so almost
12:09:03 <Cale> tac-tics: Well, arrows belong to individual categories, functors go between categories, and natural transformations go between functors
12:09:18 <tac-tics> yeah
12:09:22 <ski> MarkDBlackwell : btw, note that other people might not worry as much about these issues -- this is only my opinion
12:09:31 <tac-tics> I think there's probably a relation of some kind between them and universes in DT
12:09:49 <Cale> Another way to say that is that there is a 2-category of categories, whose objects are categories, whose 1-cells are functors, and whose 2-cells are natural transformations
12:09:49 <tac-tics> I always found it weird that morphisms, functors, and nt's were all so damn similar, yet they had three different names
12:10:02 <tac-tics> and that would explain it
12:10:14 <ski> tac-tics : "DT" ?
12:10:17 <Cale> They're all arrows in respective categories
12:10:19 <roconnor> some people call natural transformations, functor morphisms instead
12:10:20 <tac-tics> ski: dependent types
12:10:29 <ski> ah, ok
12:11:05 <tac-tics> I think I just got a little closer to not totally and utterly rejecting category theory :P
12:11:22 <Cale> Functors are the arrows of the category of categories, Natural transformations are the arrows of the category of functors between a specific pair of categories.
12:11:34 <Cale> tac-tics: why?
12:11:48 * roconnor likes the 2-cell view of natural transformations ... mostly because he is now found of omega-catgories.
12:12:02 <MarkDBlackwell> ski, yes, badly typed; whereas with your suggestion, as the result of experience, well-typed (a list of empty lists). Okay, I'm good with it! in other words, I'll disallow negative consecutives.
12:12:09 <MarkDBlackwell> ski, Good! :)
12:12:36 * ski founds roconnor on lax monoidal omega-categories
12:12:46 <Cale> tac-tics: You can picture categories as vertices in the category of categories (0-dimensional things), and then functors are 1-dimensional things joining those vertices up, and then natural transformations are 2-dimensional sheets which connect the 1-dimensional functors.
12:13:06 <roconnor> oops
12:13:09 <roconnor> :D
12:13:22 <MarkDBlackwell> ski, because of the length of the resulting list being too short. :)
12:13:23 <ski> MarkDBlackwell : hehe :)
12:13:32 <Cale> Or, you can take the dual of this picture
12:13:35 <tac-tics> Cale: Just the idea that you could treat a category as an object in another category, when I first starting learning about CT, seemed a little out there
12:14:07 <Cale> tac-tics: Well, to fix up the formalities of it all is tedious, but there's an obvious way in which the laws are being respected.
12:14:09 <tac-tics> Just a bad perspective when I began to learn it, I think
12:14:12 <ski> (as long as you've convinced yourself of why it's not that good to include, i'm happy)
12:14:40 <Cale> tac-tics: If you want to avoid much of the trouble, you can talk about the category of all small categories instead
12:15:01 <Cale> (small categories being ones with just a set of objects and set of arrows)
12:15:45 * ski . o O ( Grothendieck-universes )
12:16:02 <tac-tics> I think it was just that I assumed that a category was the complete" universe of discourse" intuitively
12:16:17 <tac-tics> and it didn't make sense to talk about how "one universe of discourse maps to another"
12:17:08 <ski> one of the points of CT is to allow each category (or at least many of them) to be seen as specialized mathematical universes
12:17:28 <Cale> So another thing we can do is to turn the dimensions of objects in our picture of the category of categories upside down. So categories get represented as 2-dimensional cells, functors are represented by the 1-dimensional boundaries between them, and natural transformations are 0-dimensional points where two 1-d edges meet.
12:17:32 <tac-tics> I think it would have made more sense if I knew what it was good for before I came to #Haskell
12:18:23 <Cale> http://analogical-engine.com/wordpress/?p=13 -- with this kind of picture, the laws for adjunctions are particularly natural looking
12:18:32 <roconnor> Cale: I'm interested in this turned around version, but I don't understand it.  I was hoping it would help me understand pi_{-1} and pi_{-2} homotopy.
12:19:02 <ski> MarkDBlackwell : anyway, i'm glad if i've been able to elucidate anything -- i assume you don't have any more questions/code atm ?
12:19:07 <Cale> http://analogical-engine.com/wordpress/?p=12 -- there are some examples of it here too
12:19:34 <tac-tics> I'm convinced whatever you see inside your head, Cale, is entirely different from what I see :)
12:19:35 * ski recalls the Catsters talking about that upside-down thing
12:19:46 <tac-tics> Both heads are filled with great things, of course
12:20:09 <Cale> ski: Yeah, there's a whole series on this string diagram notation
12:20:19 <MarkDBlackwell> ski, that's true, you did, and I don't, at this moment; thank you! (I'm adjusting my code). :)
12:20:31 <Cale> It turns out to be abstractly the same thing as Feynman diagrams. (A notation for weak-2-categories)
12:20:52 * tac-tics 's ears perk up
12:20:57 <ski> MarkDBlackwell : that's good for me, since i'm starting to drift asleep (or ought to, anyway) ;)
12:21:03 <tac-tics> I always wanted to better understand Feynman diagrams
12:21:06 <Cale> There's apparently a 2-category in which Feynman diagrams live, I don't know the details
12:21:32 <MarkDBlackwell> ski, you surely did elucidate something for me, and I see it as the way things are done in Haskell, and good night! :)
12:22:21 <ohwow> So, would it be correct to say that tuples are used to represent cartesian product?
12:22:29 <tac-tics> is C -> D a synonym for D <- C?
12:22:41 <ohwow> or rather an element from a cartesian product?
12:22:53 <Cale> tac-tics: they mean the same thing
12:22:55 <roconnor> tac-tics: yes
12:23:01 <Cale> tac-tics: they're the same diagram :)
12:23:09 <Cale> Just drawn the other way around
12:23:12 <ski> tuples are elements of the cartesian product of the respective types/sets, yes
12:23:22 <tac-tics> Cale: I'm trying to figure out what the diagram means
12:23:30 <tac-tics> are the lines boundaries to territory?
12:23:34 <ohwow> Ok, so what about the cartesian product of 3 sets?
12:23:39 <tac-tics> Or are they avenues between endpoints?
12:23:41 <ohwow> Just use (a, (b, c))?
12:23:44 <Cale> tac-tics: Well, F: C <- D means that F is a functor from D to C
12:24:26 <Cale> So it sends objects X of D to objects FX of C, and arrows a: X -> Y of D to arrows Fa: FX -> FY in C
12:24:35 <MarkDBlackwell> ski, well, it occurs to me another thing: eachCons 4 of [1,2,3] , should it error out, or return an empty list? I'm thinking error out.
12:24:45 <Cale> in such a way that F(a.b) = Fa . Fb, and F(id_X) = id_(FX)
12:24:52 <ohwow> oh nevermind my questions, there are triples in haskell
12:25:08 <roconnor> ohwow: (a,b,c) is a type in Haskell
12:25:30 <Cale> tac-tics: In the diagram, F is represented as the red line boundary between two sheets representing C and D
12:25:50 <tac-tics>  ok, then I'm reading this right
12:25:54 <Cale> (in the string diagrams)
12:25:56 <roconnor> ohwow: the space of total values of (a,b,c) is (naturally) isomorphic to the space of total values of ((a,b),c) and (a,(b,c))
12:26:33 <Cale> tac-tics: the identity functor is left out in those diagrams
12:27:18 <Cale> tac-tics: So epsilon, for example, takes in the lines for F and G on the bottom, and has an identity functor coming out the top
12:27:35 <Cale> tac-tics: but we elide that, because an identity functor is as good as no functor at all :)
12:27:47 <ohwow> roconnor: yeah i understand that but it's just nicer to write (a,b,c) then ((a,b),c) :)
12:27:51 <Cale> (at least, when you're talking about composing things)
12:28:16 <ohwow> Q is isomorphic to Z, but it's sill nice to have fractions  :)
12:28:55 <tac-tics> hmm
12:29:05 <tac-tics> I should stick to programming -.-;;
12:29:05 <tac-tics> heh
12:29:09 <Cale> ohwow: yeah, somewhat, but sometimes ((a,b),c) is actually more convenient, because there are more operations which act on pairs
12:29:27 <Cale> tac-tics: Ask questions :)
12:29:33 <ohwow> ah
12:29:43 <Cale> tac-tics: I'd already introduced string diagrams on the blog before this
12:29:44 <ohwow> Cale: it's because of the type system
12:29:59 <tac-tics> Cale: I'll take a look at it in deeper detail some time
12:30:05 <ohwow> in lisp i can car on any list hehe
12:30:12 <ohwow> which is a horrible analogy since
12:30:24 <ohwow> lists in lisp are lists and not tupels
12:30:25 <tac-tics> Cale: To be fair, math is hard at the moment because I'm at work, and I need to look like I'm programming ;)
12:30:26 <ohwow> nevermind me
12:30:27 <Cale> ohwow: Yeah, lisp lists are closer to nested pairs than wholesale tuples too
12:30:39 <Cale> tac-tics: hehe
12:30:42 <ohwow> yeah in haskell you can `head' every list you want too
12:30:53 <waern> who do you contact about accounts on www.haskell.org nowadays?
12:31:16 <Cale> http://haskell.org/haskellwiki/index.php?title=Special:Userlogin&type=signup&returnto=Haskell ?
12:31:26 <tac-tics> Cale: I always felt weird at my last job. We'd go into these two hour weekly death meetings, and when I came out, my boss would stop by my desk and see all the math I had been thinking about all throughout the meeting
12:31:28 <ohwow> Are you guys talking about cat theory? It looks interesting, maybe I'll pick it up after I finish my Algebra thingy
12:31:34 <Cale> ohwow: yeah
12:34:31 <Cale> tac-tics: you might want to take a quick look through the examples of adjunctions to get an idea anyway: http://en.wikipedia.org/wiki/Adjoint_functors#Examples
12:35:28 <Cale> tac-tics: An overarching theme to many of them is that whenever you have a functor which "forgets" that some structure is present, and another functor which "adds" that structure back in some canonical way, they might be adjoint to each other
12:36:24 <tac-tics> Cale: gotcha. As in monus's truncation property, or listToMaybe's chopping off the rest of the list
12:36:28 <Cale> For example, the functor which forgets the unit of a monoid in order to think of it as a semigroup, and the functor which adds an element to a semigroup to make a monoid from it are adjoint to each other
12:36:55 <Cale> yeah
12:39:07 <eacameron> Has anyone tried to mimic Python's generators in Haskell. I have a program that quickly eats 15+ GB of memory because it's leaving a memory trail of all the combinations its tried. If it could "generate" each result individually, it wouldn't eat all that memory. Of course, it would probably be impure.
12:40:00 <MarkDBlackwell> eacameron, sometimes it does that even before evaluating them. I think there's a way to force evaluation.
12:40:08 <ski> MarkDBlackwell : i would agree, i think
12:40:17 <tac-tics> eacameron: Lists should emulate generators in Python. The only thing is that you can't hold onto the reference to the whole list, or else the GC won't take care of it
12:40:23 <MarkDBlackwell> Then, unless you remember that value, it gets garbage-collected.
12:41:04 <dmwit> eacameron: Is the "because it's leaving a memory trail of all the combinations its tried" a fact gleaned from profiling, or a guess?
12:41:16 <eacameron> a guess
12:41:18 <MarkDBlackwell> ski, thanks, I've coded it up already, with   n  > (length $ take n x) = errorOut
12:41:40 <MarkDBlackwell> ski, guard clause
12:42:15 <dbpatterson> is there a way to force cabal-dev to rebuild one of the things added via add-source? Most of the dependencies I have there are from github repos, and they change frequently even while the actual version numbers stay the same
12:42:32 <dbpatterson> or even just to selectively remove what it has built, so it has to rebuild them
12:43:08 <eacameron> My program is pretty simple (rubix-cube brute-force solver), so I can't imagine it's using the memory for anyting else
12:43:15 <dmwit> eacameron: 1. Your guess is probably wrong. 2. Laziness subsumes generators. 3. Post some code. 4. Do some real profiling.
12:43:35 <tac-tics> eacameron:  @hpaste
12:43:39 <tac-tics> @hpaste
12:43:40 <lambdabot> Haskell pastebin: http://hpaste.org/
12:43:56 <MarkDBlackwell> eacameron, could you benefit from constructing a list instead of recursing? Is that the problem? Like in the fast solution to Fibonacci, fibs. :)
12:44:08 <dmwit> We can help with each of those things. =)
12:44:45 <MarkDBlackwell> eacameron, brute forcing imperatively? or functionally?
12:45:06 <eacameron> functionaly: here's the file on github: https://github.com/3noch/square1/blob/master/square1.hs
12:46:21 <MarkDBlackwell> eacameron, I should say, denotatively (nods to -- now, who was it?) :)
12:46:33 <hii> Hai
12:46:34 <MarkDBlackwell> eacameron, to cheater.
12:46:42 <ddarius> Iie
12:47:08 <hii> Hey guys, do you know if the function -: defined as  x -: f = f x   is defined in any module?
12:47:28 <hii> just curious since it is a kinda useful function
12:48:05 <eacameron> mind you...I'm fairly new at Haskell, so I'm probably blind to some blatant problem
12:48:17 <tac-tics> eacameron: These things can be hard to pinpoint
12:48:25 <dmwit> :t ($) -- hii
12:48:26 <lambdabot> forall a b. (a -> b) -> a -> b
12:48:41 <dmwit> :t flip ($) -- what you asked for
12:48:42 <lambdabot> forall a b. a -> (a -> b) -> b
12:48:53 <hii> hmm
12:48:59 <dmwit> I don't believe flip ($) is given a name anywhere.
12:49:10 <hii> well ok , typing flip ($) isnt shorter than defining x :- f = f x
12:49:20 <hii> ok nvm
12:49:21 <hii> ty anyway
12:50:24 <MarkDBlackwell> eacameron, when you say 'goal', I am reminded of Prolog. Maybe that intuition will be useful.
12:51:38 <dmwit> eacameron: That code looks pretty reasonable. How are you compiling?
12:51:43 <eacameron> (I wish I could laugh if I got that... ;)
12:52:03 <eacameron> ghc --make and that is all :)
12:52:49 <dmwit> ?src replicateM
12:52:49 <lambdabot> replicateM n x = sequence (replicate n x)
12:53:59 <MarkDBlackwell> eacameron, to me, I mean.  Well, I just read something today about forcing evaluation, can't remember where.
12:54:40 <aavogt> eacameron: it might be better to make sure that "allPaths = concat [pathsOfLen n | n <- [1..]]" gets re-computed rather than saved
12:54:42 * ski might have called it `$>', once
12:54:43 <dmwit> eacameron: I've got to run home. But you should definitely take a look at the documentation here:
12:54:47 <dmwit> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
12:54:59 <eacameron> thanks!
12:55:11 <aavogt> you can get that to happen by writing it as   allPaths () = ...
12:55:25 <aavogt> then calling   (allPaths ()), wherever you had allPaths
12:55:44 <dmwit> aavogt: nice spot
12:56:25 <MarkDBlackwell> eacameron, in general, as I see it, pattern matching list comprehensions can obviate generating all possibilities in memory.
12:56:27 <dmwit> So eacameron was right after all.
12:57:43 <aavogt> maybe there are other things you'll catch by profiling (though in my experience it isn't so easy to fix or recognize leaks)
12:58:04 <tac-tics> ack, I should have caught the allPaths thing. I just read about that common mistake >___>
12:58:23 <eacameron> allPaths () ?
12:58:24 <dmwit> aavogt++
12:58:27 <eacameron> never heard of that
12:58:59 <tac-tics> eacameron: as I had said, the problem with lists not being collected is you keep a reference to them. And since allPaths is a global, it must be kept alive eternally
12:59:03 <aavogt> eacameron: in ghc functions get recomputed but values like your   allPaths = ...    get saved
12:59:31 <eacameron> how incredibly interesting
12:59:39 <eacameron> all news to me
12:59:41 <eacameron> very good to know
12:59:52 <dmwit> tac-tics: Well, I suppose that's an implementation detail. GHC happens to keep top-level non-functions around, but I suppose another implementation might not do that.
12:59:55 <tac-tics> Personally, I think allPaths is better to be defined as a local let binding, because then the compiler doesn't really get a say in the matter
13:00:04 <aavogt> tac-tics: I think it could get garbage collected in ghc if it's clear that it'll never be used again
13:00:05 <tac-tics> dmwit: yeah.
13:00:43 <dmwit> Agreed on the local binding. That seems cleaner than turning it into a spurious function.
13:01:01 <aavogt> @hackage primes
13:01:02 <lambdabot> http://hackage.haskell.org/package/primes
13:01:06 <tac-tics> Lesson: be wary of large (especially infinitely large) global definitions
13:01:11 <eacameron> haha
13:01:14 <eacameron> too true
13:01:47 <eacameron> that little [1..] is a nasty bugger
13:03:02 <Cale> Well, it is if it's defined as a constant and kept in scope such that it can't be garbage collected :)
13:03:08 <ion> OTOH, polymorphic values aren’t memoized AFAIU. nats :: Num a => [a]; nats = [0..]
13:03:11 <ion> for instance
13:03:36 <ion> Since nats is kind of a function to which you pass a dictionary of Num functions.
13:07:27 <btutt> llvm aliasing pass. woo!
13:10:41 <MarkDBlackwell> eacameron, in general, instead of generating all paths, then filtering, one could generate each valid state from the previous valid state, filtering as you go, in a function, and make an abstract list starting from the initial state. I assume the final, pruned tree is not going to blow your memory?
13:11:58 <eacameron> naw, I just need one result of probably 10-12 pairs
13:12:15 <eacameron> that's why `find` does `head $ reach ...`
13:14:06 <missingfaktor> How do I write a Show instance for ZipList?
13:14:45 <mekeor> @hoogle instance
13:14:46 <lambdabot> Language.Haskell.TH InstanceD :: Cxt -> Type -> [Dec] -> Dec
13:14:46 <lambdabot> Language.Haskell.TH.Syntax InstanceD :: Cxt -> Type -> [Dec] -> Dec
13:14:46 <lambdabot> Language.Haskell.TH instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
13:15:08 <Saizan> instance Show a => Show (ZipList a) where show (ZipList xs) = "ZipList " ++ show xs -- e.g.
13:15:48 <missingfaktor> Saizan: Oh I was missing the `Show a` constraint. Thanks a bunch!
13:15:55 <ski> s/show xs/showsPrec 11 xs/
13:16:37 <ski> well, also a trailing `""', in this case
13:17:10 <byorgey> missingfaktor: alternatively, if you enable the StandaloneDeriving extension, you can just write  'deriving instance Show a => Show (ZipList a)'
13:17:46 <byorgey> I'm not sure why there isn't a Show instance already defined in Control.Applicative.  a simple oversight, no doubt.
13:18:10 <missingfaktor> byorgey: Nice tip. Thanks.
13:18:11 <ski>   instance Show a => Show (ZipList a) where showsPrec p (ZipList xs) = showParen (p > 10) $ showString "ZipList " . showsPrec 11 xs
13:18:17 <missingfaktor> byorgey: Agree about the oversight.
13:19:09 <missingfaktor> @hoogle showsPrec
13:19:09 <lambdabot> Prelude showsPrec :: Show a => Int -> a -> ShowS
13:19:09 <lambdabot> Text.Show showsPrec :: Show a => Int -> a -> ShowS
13:19:17 <ski> @src Show
13:19:18 <lambdabot> class  Show a  where
13:19:18 <lambdabot>     showsPrec :: Int -> a -> ShowS
13:19:18 <lambdabot>     show      :: a   -> String
13:19:18 <lambdabot>     showList  :: [a] -> ShowS
13:19:51 <missingfaktor> ski: Wow, cool. Didn't know about all these show functions.
13:20:18 <ski> also `showChar' for single characters
13:20:44 <ski> there's a corresponding `readParen' to be used in definitions of `readsPrec' in `Read'
13:23:11 <Seraphon> how do infix type constructors associate?
13:23:28 <MarkDBlackwell> eacameron, I did a little reading about the square 1 puzzle. I see you take 'goal' on the command line, but I assume that's the randomized state, and you find paths to the solved state?
13:24:32 <ski> Seraphon : depends on how you declare them with `infix',`infix',`infixr'
13:24:44 <MarkDBlackwell> eacameron, in reverse, I mean. How is the solved state represented?
13:25:02 <ski> (presumably the default is `infixl 9', as for usual operators)
13:25:45 <Seraphon> ok thanks
13:28:33 <absence> is there an infinite (lazy) data structure with o(1) lookup?
13:29:04 <c_wraith> sounds awfully difficult to sort through infinite data in O(1) time
13:29:07 <tac-tics> absence: If there were, I'd be using it to make millions of dollars, not helping people out in #haskell :)
13:29:43 <byorgey> absence: what exactly are you trying to do?
13:30:22 <int-e> absence: beware, o(1) means that it goes to 0 for large sizes. O(1) means bounded by a constant.
13:30:44 <absence> int-e: oh, i meant O(1)
13:31:14 <absence> i'm always sloppy with the caps :/
13:31:20 <eacameron> MarkDBlackwell: The `goal` is a mapping from current state to the goal. Each number represents a square, and each pair in the mapping is "from"->"to". For example, (1,2) says that square 1 needs to end up in square 2's place.
13:32:28 <MarkDBlackwell> eacameron, what you give it in argument 0, what is an example of that?
13:32:28 <absence> byorgey: say there's a bunch of files with numbers for filenames. i thought it would be nice to lazily stuff all their contents into a data structure to keep stuff out of the io monad
13:33:38 <MarkDBlackwell> eacameron, the parts have different shapes; what do you mean by a, 'square'?
13:34:14 <MarkDBlackwell> eacameron, and you have used the word goal, in defining 'goal,' there, right?
13:34:14 <byorgey> absence: I don't understand what you mean about keeping stuff out of the IO monad.  What would happen when you looked up the contents of one of the files?
13:34:26 <eacameron> MarkDBlackwell: I know they have different shapes...but I define "square" loosely. Perhaps "piece" like you said is a better name. Here's the command that killed my machine before: ./square1 "[(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(10,30),(20,70),(30,40),(40,20),(50,50),(60,60),(70,80),(80,10)]"
13:35:02 <absence> byorgey: a lazy data structure containing all the files could be used by a pure function
13:35:06 <MarkDBlackwell> eacameron, what do this high numbers mean?
13:35:27 <absence> byorgey: if i looked up the contents they'd be read i guess?
13:35:58 <eacameron> 1-8 are pieces that can be on the top and bottom. 10-80 are pieces that be only on the sides.
13:36:01 <byorgey> absence: so you want pure computations to trigger actual disk I/O
13:36:08 <byorgey> absence: this way lies madness.
13:36:30 <absence> byorgey: it does? i've seen plenty of examples that use e.g. hGetContents that way
13:37:01 <int-e> absence: it's probably a bad idea, in Haskell ... you can load the files lazily, but the memory will probably not be freed before you're done processing all the files.
13:37:12 <MarkDBlackwell> eacameron, 1-8 could number the top face, and what numbers for the bottom face?
13:37:13 <byorgey> absence: it's true, this is indeed how getContents and friends work, but it's tricky to get it to do what you want
13:37:51 <MarkDBlackwell> eacameron, like if you wrote numbers on all the parts, right?
13:38:10 <eacameron> MarkDBlackwell: 1-8 can be either on the top or bottom. Right, if you just wrote a number of all the faces and started moving them around.
13:38:57 <ddarius> byorgey: That way lies virtual memory.
13:39:06 <byorgey> absence: in any case, to answer your original question, I'd say if the files are represented by Ints to use an IntMap
13:40:57 <MarkDBlackwell> eacameron, in this data format, these number pairs don't survive motion, do they? Or, is the second number of each pair the final, solved position?
13:41:21 <eacameron> MarkDBlackwell: the second number is the desired (solved) position
13:42:03 <MarkDBlackwell> eacameron, is it that the other 8, on the bottom, are unconstrained?
13:42:10 <dmwit> Functions are O(1) infinite data structures, provided the implementation is O(1).
13:42:22 <absence> well, if it's not a good idea, i'll reconsider. still quite new to haskell and trying to wrap my head around laziness and how it can/should be used :)
13:42:27 <dmwit> :t unsafeInterleaveIO
13:42:28 <lambdabot> Not in scope: `unsafeInterleaveIO'
13:42:33 <MarkDBlackwell> eacameron, I notice that 10 is the last snd in your goal list.
13:42:36 <dmwit> ?hoogle unsafeInterleaveIO
13:42:36 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
13:43:11 <dmwit> Though I would probably prefer an Array here.
13:43:14 <ddarius> const True, the set of all anythings.
13:43:22 <MarkDBlackwell> eacameron, could they be reordered without making a difference?
13:43:31 <dmwit> (On the off chance that you happen to know at runtime how many such numbered files there are.)
13:43:52 <eacameron> MarkDBlackwell: yeah, changing the order doesn't matter; its the starting and ending pairs that matter
13:44:20 <eacameron> MarkDBlackwell: potentially, changing the order could change the performance of the program, if one order finds the solution sooner
13:44:49 <dmwit> absence: do { fileContents <- mapM (unsafeInterleaveIO . readFile . show) [1..30]; return (listArray (1,30) fileContents) }
13:45:18 <MarkDBlackwell> eacameron, when you say the starting and ending pairs, I presume you mean a list of fst and one of snd?
13:45:31 <ddarius> For arbitrary values of 30.
13:45:52 <tac-tics> > 30 :: Int
13:45:53 <lambdabot>   30
13:45:55 <tac-tics> > 30 :: Float
13:45:57 <lambdabot>   30.0
13:46:31 <eacameron> MarkDBlackwell: yes, my mistake, not pairs; starting and ending positions
13:46:34 <ddarius> > (30 :: IO a -> Int) (return 3)
13:46:36 <lambdabot>   30
13:48:49 <eacameron> MarkDBlackwell: I have to leave, but I just pushed some of my changes to the github repo. Feel free to fork and modify at will!
13:49:16 <MarkDBlackwell> yes, hm, I'm thinking about how to represent intermediate states. Is it true that the nice, cube shape, but with the wrong colors, is the starting state?
13:49:30 <MarkDBlackwell> eacameron, okay, I might.
13:52:22 <absence> dmwit: hmm, interesting
13:56:10 <dmwit> I can't believe how many people put me in their circles on G+.
13:56:16 <dmwit> I feel obligated to make posts about Haskell now...
13:57:08 <Cale> dmwit: yeah, it's ridiculous for me too
13:57:18 <Cale> I should just spam everyone with more pictures of magnets
13:57:26 * plathrop searches on G+...
13:57:36 <dmwit> plathrop: plus.google.com
13:57:49 <dmwit> Cale: Probably nobody would complain.
13:57:52 <Cale> I don't even know how I ended up in all these people's circles. I only posted a bunch of pictures of magnets, and don't know who most of these people are.
13:57:52 <plathrop> No, I mean searching for you guys. To add ya :-P
13:57:58 <dmwit> Those pictures are pretty. =)
13:58:03 <plathrop> magnets are awesome
13:58:04 <dmwit> plathrop: ah =)
13:58:11 <copumpkin> dmwit: you should hack G+ to make your picture "interactive" like it is on your website :)
13:58:15 <Cale> Probably they're people from here, but I have no way of knowing.
13:58:19 <dmwit> Cale: 2-3 highly-followed people shared their Haskell circle with the world
13:58:29 <copumpkin> dons for example
13:58:39 <dmwit> Cale: And G+'s UI doesn't allow you to add only part of somebody else's circle to your own circles, even though it looks like it does.
13:58:56 <dmwit> So lots of people ended up adding everyone in those circles to their own circles (even if they didn't want to).
13:59:01 <plathrop> Seriously though I mostly don't circle people I don't know. Mostly. I mean, Felicia Day is an understandable exception, right?
14:00:55 <dmwit> I feel like we need a meta-social-networking site that lets us link to our profiles on all the social networking sites we frequent.
14:00:59 <Cale> dmwit: I still don't really understand G+ despite someone explaining it to me at some point. It seems kinda like twitter, and I don't really watch what goes on there anyway.
14:01:20 <dmwit> It's like twitter, except you can differentiate between colleagues and family.
14:06:05 <Cale> It does a really bad job of posting photo albums. You apparently can't comment on the photos individually without having them turn into separate postings.
14:11:16 * ddarius mollifies diracdelta.
14:26:42 <MarkDBlackwell> (saying to anybody) I think it's a good thing that Haskell does reach out to procedural programmers with its procedural aspect; good because that's a good way to grow the userbase. I'm thinking of how Ruby was attractive to Perl, Smalltalk, Lisp, and some other languages'  programmers from the start.
14:28:47 <MarkDBlackwell> This partly based on this link I got from this channel today: http://lambda-the-ultimate.org/node/724
14:29:05 <MarkDBlackwell> on Haskell for C programmers.
14:32:39 <ddarius> Haskell has "procedural aspects"?
14:32:41 <MarkDBlackwell> I still don't know what to do about the fact that my WinGHCi is broken, and only gives me a white window, even after rebooting and reinstalling Haskel.Platform.2011.2.0.1; I've been using GHCi instead, so it's not a big problem, I guess!
14:33:04 <MarkDBlackwell> ddarius, I guess using 'do' a lot.
14:51:01 <ozataman> Hi all. Would an SCC annotation to the left of a do token capture the entire do block? It doesn't seem so.
15:05:21 <antilect> :D
15:05:22 <antilect> http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
15:05:24 <antilect> Challenge accepted.
15:05:28 <Cale> Haha, my mom accidentally ordered large combos in the Wendy's drive thru. Apparently Wendy's sizes are "small", "medium", and "I hate myself".
15:06:09 <Dashkal> I'm looking for the name for a construct I've running into a lot.  class NameMe a b where squash :: a -> b -> a
15:06:46 <Cale> Should it really be an typeclass? Usually there are a lot of those...
15:06:50 <Cale> a*
15:07:02 <Cale> But, I'd call it accumulate
15:07:09 <Dashkal> Just the syntax I'm using to describe the pattern
15:07:11 <Cale> and probably flip the order of the parameters to squash
15:07:22 <Dashkal> I mean the pair of two types and that operation is all
15:07:43 <Cale> It's the function you'd pass to a fold which constructs a value of type a
15:07:47 <Cale> from a list of b's
15:08:14 <Dashkal> THAT'S why it feels so familiar
15:08:24 <zygoloid> feels like you would also want a zero :: a  (which suggests a fundep a -> b)
15:08:37 <Dashkal> I have a data value (lots of fields, but just a value) and a list of other values that describe changes to make to the first.
15:08:43 <Dashkal> No zero
15:09:05 <Cale> actually, there probably is a zero in that case
15:09:19 <Cale> (the empty set of changes?)
15:09:20 <Dashkal> No zer for a.  There may be one for b
15:09:23 <kmc> antilect, oh dear
15:09:28 <Cale> yeah, for b
15:09:29 <Dashkal> But there doesn't have to be
15:09:36 <zygoloid> if you model 'a' as a transformation, there should be a zero. that might be more natural
15:09:44 <antilect> kmc :)
15:09:48 <Cale> Dashkal: There kinda does if you want to apply foldl
15:09:50 <kmc> Learn Haskell in ZWANZIG MINUTEN!?!?
15:10:00 <Cale> Dashkal: though you could always use foldl1
15:10:10 <Cale> but that's not quite right :)
15:10:15 <Dashkal> Example of a case where there is no zero b:
15:10:17 <Eduard_Munteanu> antilect: that page could have a list of fancy words you can memorize in 10 minutes to appear like you've programmed in Haskell for years :P
15:10:35 <zygoloid> antilect: you're half-way. how's it going?
15:10:43 <Dashkal> For a: data Versioned v = V String [v]
15:10:48 <antilect> I think I win :)
15:10:50 <Dashkal> Any b I apply will add a new thing to that list
15:10:52 <antilect> Haha
15:10:54 <Dashkal> Even if its a noop
15:11:05 <Cale> grr... uninstalling Ubuntu's firefox makes Ubuntu think that I want to use Chrome as my default browser.
15:11:33 <Veinor> hmm
15:11:35 <antilect> [x^2 | x <- y [1..], x /= even x]
15:11:39 <Veinor> yesod's persistent looks pretty neat
15:11:47 <Cale> and its little applet for choosing preferred applications doesn't let me put in a custom commandline.
15:12:09 <kmc> Eduard_Munteanu, that could be pretty useful... since employers love to hire people who "know Haskell" but usually have no way to assess this
15:13:12 <Eduard_Munteanu> kmc: mmm! Think what happens if you mention "Agda" :P
15:13:25 <Cale> ah, good, there's an xml file I can edit to change it anyway :P
15:33:45 <jon4892> Hi. I'm having trouble using the redis package, I always run into this problem with bytestrings: Ambiguous s2 in `Database.Redis.ByteStringClass.BS s2'
15:35:28 <jon4892> any ideas on how to fix this?
15:35:39 <shachaf> jon4892: You should probably provide more context.
15:36:37 <jon4892> Well this works when I compile without OverloadedStrings, but then when I try it in GHCI I get the error: reply <- smembers r "asdf"
15:37:01 <shachaf> jon4892: Oh, ghci has issues with OverloadedStrings.
15:37:21 <shachaf> Just specify a explicitly or something like that.
15:37:29 <jon4892> Oh, is there any way to turn off OverloadedStrings in ghci?
15:37:42 <shachaf> It's off by default, isn't it?
15:37:52 <shachaf> :set -XNoOverloadedStrings
15:38:24 <Saizan> i think the problem is that it doesn't know which type reply should have, add a type annotation to the RHS of <-
15:39:02 <jon4892> what's RHS?
15:39:07 <shachaf> Right-hand side.
15:39:26 <jon4892> oh lol. What type can I use?
15:39:43 <shachaf> You can also put it on the left-hand side with -XScopedTypeVariables.
15:44:11 <Saizan> jon4892: it has to be compatible with the result type of smembers so look at its signature
15:46:32 <jberryman> while I try to grok MonadFix, can anyone tell me if this can be defined?: instance (MonadFix m)=> MonadFix (MaybeT m) where ...
15:46:53 <malorie> I'm working through "write yourself a scheme" and I'm getting this warning: http://ideone.com/39OpZ how are those pattern matches overlapped?
15:49:51 <benmachine> jberryman: I've heard yes
15:50:06 <benmachine> jberryman: there's a way that typechecks and is also wrong, and a way that is correct
15:50:30 <benmachine> http://www.haskell.org/pipermail/libraries/2011-April/016202.html
15:52:32 <jberryman> benmachine: you rock, thanks.
15:52:59 <absence> is there a library function for getting rid of empty strings in a list of strings?
15:53:35 <tromp> there's filter
15:54:12 <jberryman> malorie: they don't look overlapped to me! perhaps that's an old GHC bug?
15:54:13 <tromp> > filter (not.empty) ["hi","","there"]
15:54:13 <lambdabot>   Ambiguous occurrence `empty'
15:54:14 <lambdabot>  It could refer to either `Control.Applicative...
15:54:34 <malorie> jberryman: I'm using ghc 7.0.3
15:54:35 <tromp> > filter (not.null) ["hi","","there"]
15:54:36 <lambdabot>   ["hi","there"]
15:56:15 <absence> tromp: ah, of course :) thanks
15:57:48 <absence> hm, out of curiosity, is there something monadic that will work on other things than strings too, e.g. remove Nothing from a list of Maybe, etc
15:58:27 <shachaf> absence: What would it do for a list of IO values?
16:00:59 <absence> shachaf: they throw exceptions when they fail, so .. crash i guess? :D
16:01:54 <jberryman> absence: those things are MonadPlus, but I can't think of how you'd test for mzero at the moment
16:02:31 <shachaf> absence: What type do you want? [m a] -> [m a]?
16:03:12 <absence> shachaf: yes
16:03:14 * shachaf doubts whatever absence wants is possible.
16:03:28 <shachaf> In that case, no. What would it do?
16:04:24 <absence> keep stuff that isn't mzero
16:04:52 <malorie> changing the order of the patterns fixed it *shrug*
16:05:06 <aninhumer> I suspect you'd need an Eq constraint? to test for mzero
16:10:07 <stianhj> [x | x <- [Just 3, Just 4, Nothing, Just 5], x /= Nothing]
16:10:12 <stianhj> > [x | x <- [Just 3, Just 4, Nothing, Just 5], x /= Nothing]
16:10:13 <lambdabot>   [Just 3,Just 4,Just 5]
16:10:24 <hpc> :t catMaybes
16:10:25 <lambdabot> forall a. [Maybe a] -> [a]
16:10:42 <hpc> > [x | Just x <- [Just 3, Just 4, Nothing, Just 5]]
16:10:42 <lambdabot>   [3,4,5]
16:12:56 <stianhj> absence: like that?
16:14:17 <bfig> what's a good place to learn parsec?
16:15:27 <absence> stianhj: i was curious about a general function that works on any monad(plus). i guess there isn't one, so i'll work some more on the routine that generates my list. probably sneak a guard in somewhere :)
16:16:53 <Dashkal> bfig: I'm not sure it qualifies for your definiton of "good", but I learned Parsec by implementing a parser for the SKI calculus
16:17:07 <bfig> Dashkal, as in, place to get informatino about parsec
16:17:34 <Dashkal> bfig: Real World Haskell
16:17:40 <stianhj> bfig: http://book.realworldhaskell.org/read/using-parsec.html
16:17:52 <bfig> ok, ty
16:18:47 <bfig> i really don't know what's wrong with me, i've been having too manny troubles understanding monads
16:19:17 <Dashkal> If it's anything like the issues I had, you're overcomplicating it.  Monads really are just a type constructor, a return function, and a bind function.
16:19:17 <bfig> it doesn't make any sense, but i feel like an idiot. ok, i managed to get past monads. reader and state? urggh.. transformers? kaboom
16:20:02 <bfig> i'm having trouble with the reader monad, how the hell am i supposed to know where i'm standing?
16:20:16 <bfig> i mean, ask makes absolutely no sense :S
16:20:24 <Dashkal> Reader is actally some fancy sugar around a simple function.
16:20:31 <bfig> one sec brb
16:21:12 <slack1256> looking at the problems of bfig
16:21:25 <slack1256> i wonder if a monad tutorial the first teaches you to use them
16:21:32 <slack1256> and then theory would be useful
16:21:37 <bfig> back
16:21:58 <bfig> Dashkal, how would the sugar be?
16:22:08 <Dashkal> I'm pretty convinced that a single tutorial can't teach monads.  Not unless it's tailored towards the specific reader.  People tend to approach the concept a little differently
16:22:15 <bfig> how are parameters passed?
16:22:25 <Dashkal> bfig: Ok, so the reader monad lets you carry around this piece of information and you can pull it up when you need it.
16:22:27 <bfig> i hate syntactic sugar, i HATE IT
16:22:28 * shachaf isn't even sure what "teach monads" means.
16:22:50 <bfig> syntactic sugar makes simple things difficult
16:22:56 * Kaidelong is wondering if higher order functions like foldr should be rewritten so that they take arrows rather than functions
16:23:10 <slack1256> shachaf: usage rather than meaning
16:23:10 <Dashkal> bfig: not syntax sugar.  It's a pattern, and one you're already using.
16:23:19 <Kaidelong> there is no way to turn "a -> IO b" into "IO (a -> b)"
16:23:27 <hpc> Kaidelong: they would have to be class methods
16:23:39 <Kaidelong> would they?
16:24:02 <hpc> :t foldr
16:24:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:24:14 <hpc> what would the type of the arrowy foldr be?
16:24:19 <bfig> Dashkal, let's start simple. a reader takes a single argument, right?
16:24:34 <bfig>  r->a
16:24:35 <Dashkal> bfig: yes.  and actions you make in the Reader monad can pull that up if required
16:24:39 <shachaf> bfig: Reader r a === r -> a
16:24:50 <shachaf> bfig: Just ignore the Reader newtypr.
16:24:54 <Dashkal> ^^^
16:24:58 <Dashkal> That's really all there is to it
16:25:10 <bfig> ok that is just fine. now what the hell does ask do?
16:25:16 <Kaidelong> (Arrow m) => (m a (m b b)) -> b -> m [a] b
16:25:17 <Kaidelong> perhaps?
16:25:24 <Kaidelong> wonder how you would implement it though
16:25:29 <Dashkal> ask === r -> r
16:25:39 <bfig> but it is in a context
16:25:41 <Dashkal> Takes that value that every action is being passed, and returns it
16:25:43 <hpc> Kaidelong: ooh, that could work
16:25:50 <hpc> Kaidelong: it would have to be ArrowApply though
16:26:31 <hpc> and it would be nasty, and probably only make much sense at all for the function instance
16:26:40 <hpc> or some sort of Kleisli-ish lift over Foldable
16:27:05 <Kaidelong> IO is ArrowApply I think
16:27:10 <Kaidelong> well
16:27:12 <Kaidelong> all monads are
16:27:13 <Kaidelong> aren't they?
16:27:20 <Kaidelong> because kleisi arrows are
16:27:35 <bfig> Dashkal, how do you chain several readers?
16:27:38 <hpc> indeed
16:27:58 <Dashkal> bfig: That's where bind comes into play
16:28:13 <bfig> ie,  firstreader >>= secondreader >>= ... what about firstreader >>= (secondreader >>= (thirdreader >>= fourthreader)) ?
16:28:15 <Dashkal> bfig: bind for Reader takes the r from the previous reader and passes it to the next
16:28:22 <bfig> that's it?
16:28:25 <Dashkal> that's it
16:28:54 <bfig> how is local used?
16:29:17 <Dashkal> local lets you "change" the r.  local passes whatever you give it to the reader you give it.  But once local is done, the new value goes poof
16:29:47 <bfig> what is the scope of local?
16:30:03 <bfig> is it like a return ?
16:30:06 <Dashkal> the scope of the new value you give local is the action you give local.
16:30:15 <Dashkal> :t local
16:30:16 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
16:30:40 <Dashkal> yeah, the function you pass it lets you change the value, but only the reader you give it as a second argument can see it
16:31:06 <bfig> how do you distinguish with associativity?
16:31:28 <bfig> which ask are you calling? doesn't it depend whether you associate from left or from right?
16:31:53 <Dashkal> not applicable. ex:  local (_ -> 5) LocalReader >>= NotLocalReader
16:31:56 <Dashkal> LocalReader will see 5
16:32:03 <Dashkal> NotLocalReader will see whatever it was beforehand
16:32:41 <aninhumer> bfig: if you want LocalReader to be composed, you need to use a do block for it, so that gives you your scope
16:33:01 <aninhumer> well you don't "need" to I suppose
16:33:17 <bfig> how is the other value passed?
16:33:19 <Dashkal> LocalReader itself can be composed of multiple readers joined by >>=
16:33:46 <bfig> ie, local (abc >>= def >>= .. ) ?
16:34:01 <bfig> but local is inside a monad, it is not a return statement, it doesn't create a monad
16:34:20 <bfig> it is not a type constructor or type constructor wrapper of some sort
16:34:23 <Dashkal> Careful.  Note I'm using "action" when talking about the things you feed to >>=
16:34:23 <bfig> _
16:34:30 <Dashkal> The monad is Reader, not the individual action
16:35:05 <hpc> technically, the monad is 'Reader r' :P
16:35:10 <Dashkal> ^^
16:35:17 <bfig> the action would be all inside the parenthesis, since (abc >>= def >>= ..) should have r->M b for some b?
16:35:41 <ddarius> instance Category Reader where ...
16:36:06 <bfig> ok, so no other value is passed around except the reader context?
16:36:19 <bfig> ie, all the things chained have r->M b for some b ?
16:36:24 <Dashkal> bfig: well, that and the returned value from each action.
16:36:31 <bfig> what happens with all those b's?
16:36:42 * bfig 's mind explodes
16:36:43 <Dashkal> They're available in scope
16:36:52 <Dashkal> Reader hides the r.  the bs are explicit
16:36:54 <Dashkal> :t >>=
16:36:55 <lars_> does GHC has lower level api to do this: typeEqual :: a -> b -> bool  ?
16:36:55 <lambdabot> parse error on input `>>='
16:37:00 <Dashkal> :t (>>=)
16:37:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:37:09 <Dashkal> a -> m b
16:37:15 <Dashkal> Or in your case, a -> Reader r b
16:37:38 <bfig> see, this makes no sense, why would you want to hide that? it makes the whole syntax make no goddamn sense
16:37:38 <Dashkal> r is fixed.  but a and b are yours to work with
16:37:45 <hpc> lars_: not that i know of
16:37:52 <hpc> lars_: my suspicion is that it isn't possible
16:38:03 <Dashkal> bfig: so you don't need to explicitly thread r around.  You can hide it in bind and only pull it out when required.
16:38:09 <hpc> not without scary extension tricks
16:38:40 <bfig> Dashkal, so, what ask and local do is hide the whole passing of parameters right?
16:38:50 <Dashkal> they hide the passing of the r
16:38:57 <Dashkal> ask pulls r up for when you need it
16:39:07 <Dashkal> local lets you change r in its scope
16:39:15 <lars_> hpc: just need to check type equality, tapeable is too slow and not always correct
16:39:27 <bfig> ok. how do i work with all this values in arbitrary monads?
16:39:53 <Dashkal> bfig: well, r ceases to exist in the general case.  In that case all you care about are the a and b in the a -> m b
16:40:21 <bfig> what is readerT useful for?
16:40:34 <hpc> bfig: the T means it is a transformer
16:40:43 <bfig> that far i understand
16:40:50 <hpc> bfig: it basically lets you put the reader "inside another monad"
16:40:50 <Dashkal> bfig: combining reader's ability to hide a context value with another monad.  That's where it gets interesting.
16:41:14 <bfig> i don't understand how this makes sense
16:41:20 <bfig> isn't this a reader monad period?
16:41:26 <stianhj> I'm having some problems grokking an exercise in LYAH. I'm not sure how to approach the problem, if someone could have look.
16:41:30 <hpaste_> stianhj pasted “Knights” at http://hpaste.org/51988
16:41:34 <bfig> what can i do with readerT that i can't with reader?
16:41:40 <hpc> bfig: if you are having trouble, totally forget about transformers
16:41:47 <Dashkal> bfig: ReaderT can combine with another monad to give you a new monad that combines the hidden context of Reader with whatever the other monad does.
16:42:12 <bfig> hpc, it is not that simple, i have to use them for my practice sheet >_>
16:42:23 <hpc> oh
16:42:30 <bfig> (due in 4 days >_> )
16:42:37 <Dashkal> bfig: Set it aside for now.  You can get this in 4 days :P
16:42:43 <ion> What’s a reader monad period?
16:42:47 <ion> (Does it involve blood?)
16:42:50 <bfig> reader monad '.'
16:42:54 <Dashkal> bfig: It would help to understand at least one more monad before you get into ReaderT
16:43:41 <bfig> i'm listening
16:43:53 <hpc> (Writer would be a good next monad)
16:44:17 <bfig> does that have the same absurd syntax  but with a write only variable, whatever that means?
16:44:21 * ddarius never, ever uses Writer.
16:44:27 <hpc> bfig: indeed
16:44:34 <bfig> ie, write "something that overwrites whatever is here"
16:44:34 <hpc> bfig: except more "append-only"
16:44:41 <lars__> hpc: excuse me i just got disconnected, did you say something else?
16:44:44 <bfig> that makes more sense
16:44:57 <hpc> lars__: no; i don't really know much more than i said
16:44:57 <bfig> Dashkal, which monad are you talking about?
16:45:19 <Dashkal> bfig: I wasn't talking about any in particular.  Just that if you don't know at least two monads, it's hard to describe how a transformer works
16:45:33 <hpc> bfig: so say you wanted to compute something, and record any errors you had along the way
16:45:37 <lars__> hpc: got it, thanks
16:45:55 <hpc> bfig: you would have a Writer String something
16:46:31 <hpc> bfig: in addition to the usual stuff, there's a function write :: w -> Writer w ()
16:46:42 <hpc> (probably wrong)
16:46:47 <bfig> Dashkal, i know some monads... i just don't understand how it makes sense to embed an arbitrary reading context
16:47:03 <ddarius> If you choose the Last monoid, the Writer will behave like a write-only variable.
16:47:15 <ddarius> :t tell
16:47:17 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
16:47:20 <Dashkal> bfig: the really short form is that ReaderT adds ask and local to another monad.
16:47:21 <bfig> say, i'll be embedding monads that take a a context r, right ?
16:47:29 <hpc> bfig: and with String, "write s" = "do a plain old 'return ()', but append s to the current 'log'"
16:47:42 <hpc> (append using (++))
16:47:52 <bfig> Dashkal, but why would it make sense to use ask and local on a monad that doesn't used them?
16:48:25 <Dashkal> bfig: Because the result of applying ReaderT to another monad (say Writer) is a monad that DOES use it, as well as the write functionality
16:48:41 <hpc> bfig: then 'runWriter blah' returns (log, value)
16:49:04 <aninhumer> bfig: for example if you want to route a read only value through a computation, but also want potential to fail with Maybe, you can do both at once
16:49:55 <bfig> say i have a computation Maybe a. for it to be syntactically correct, it can't do weird crap like asking for stuff inside
16:50:26 <Dashkal> bfig: Maybe won't let you, but (ReaderT r Maybe) will
16:50:28 <bfig> so however i embed it inside a state, the state won't have an effect on the computation
16:51:06 <Dashkal> (ReaderT r Maybe) is a new monad that combines threading a value through a computation with a computation that might or might not return a value.
16:51:37 <hpc> bfig: to compare the results of the computations
16:51:45 * hackagebot hspec 0.9.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-0.9.0 (TrystanSpangler)
16:51:50 <hpc> runReader :: r -> Reader r a -> a
16:52:00 <bfig> i'm still not understanding how you can suddenly access in a meaningful way the state
16:52:05 <hpc> runReaderTMaybe :: r -> ReaderT r Maybe a -> Maybe a
16:52:35 <hpc> (i think that's right)
16:52:49 <Dashkal> @unmtl ReaderT r Maybe
16:52:50 <lambdabot> err: `ReaderT r Maybe' is not applied to enough arguments, giving `/\A. r -> Maybe A'
16:52:54 <Dashkal> @unmtl ReaderT r Maybe a
16:52:54 <lambdabot> r -> Maybe a
16:53:32 <bfig> can you show me a simple example?
16:53:59 <bfig> suppose i want to compute a simple Maybe a that takes a value from an environment, how do i do it?
16:55:33 <hpc> bfig: hpasting...
16:56:35 <hpc> bfig: http://hpaste.org/51989
16:57:12 <hpc> bfig: the only new thing in that paste is 'lift'
16:57:27 <hpc> in this case, lift :: Maybe a -> ReaderT r Maybe a
16:57:41 <bfig> so lift will 'remember the context' in the return value, right?
16:58:04 <hpc> yeah
16:58:18 <hpc> it just says "take this action, and put some extra context around it"
16:58:38 <bfig> ok, so you first have to *know* you have a ReaderT, you don't build it out of computations already there
16:58:41 <hpc> in this case, the context we are giving it is "the Maybe action has failed"
16:59:41 <bfig> ie, if i have a monad m a, and i lift it, then this will make it 'pass the context' of whatever reader catches it?
16:59:47 <hpc> yeah
17:00:09 <aninhumer> I think lift is not specific to reader though?
17:00:12 <bfig> say i have putStrLn "abc", then for it to pass the context i have to ReaderTize it?
17:00:13 <hpc> it isn't
17:00:17 <bfig> it's generic for monadtrans
17:00:28 <hpc> exactly
17:00:58 <bfig> so the lift will generally make the reasonable try to make the monad act as reasonable as possible
17:01:24 <hpc> yeah; in this case, the example is simple enough that you could get by with a (Reader String (Maybe Int))
17:01:39 <bfig> let's take a MaybeT, in that case lift will only move the value inside, right? ie, lift m = runMaybe $ Just m  ?
17:02:10 <hpc> uh
17:02:27 <hpc> let's look at the MaybeT source (aka, i can't remember)
17:02:42 <hpc> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-Maybe.html#MaybeT
17:02:45 <bfig> maybe runMaybeT doesn't make sense in that context and it should be just return
17:03:27 <bfig> my head is still spinning with all the transformer syntax, coupled with the reader stuff
17:03:28 <hpc> lift = MaybeT . liftM Just -- yuck; let's give it some points
17:03:54 <hpc> lift m = MaybeT (fmap Just m)
17:04:16 <bfig> what the hell is it fmapping?
17:04:37 <bfig> isn't that  m >>= Just ?
17:04:49 <dibblego> m >>= return . Just
17:05:10 <hpc> what dibblego said
17:05:17 <bfig> i mean just the (fmap Just)
17:05:32 <dibblego> lift m = MaybeT (m >>= return . Just)
17:05:39 <hpc> (fmap Just) :: m a -> m (Just a) -- bfig
17:05:49 <bfig> why are you returning twice?
17:05:50 <dibblego> (fmap Just) :: m a -> m (Maybe a)
17:05:55 <hpc> er, you know what i mean
17:06:11 <hpc> it takes an action and applies 'Just' to the "inside"
17:08:26 <bfig> how is the record used in general for transformers?
17:09:26 <hpc> the record?
17:09:38 <hpc> you mean the 'a' part?
17:09:50 <dankna> > fmap Just (do { return 4 })
17:09:51 <lambdabot>   No instance for (GHC.Show.Show (f (Data.Maybe.Maybe a)))
17:09:51 <lambdabot>    arising from a ...
17:10:12 <dankna> > fmap Just (do { return 4 } :: IO Int)
17:10:13 <lambdabot>   <IO (Maybe Int)>
17:10:20 <bfig> you usually define a record to access the inner monad, i don't really understand the syntax
17:10:30 <dankna> > fmap Just (do { putStrLn "4" } :: IO Int)
17:10:30 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
17:10:30 <lambdabot>         against inferred type ...
17:10:36 <dankna> > fmap Just (do { putStrLn "4" ; return 4 } :: IO Int)
17:10:37 <lambdabot>   <IO (Maybe Int)>
17:10:37 <hpc> oh, derp
17:11:04 <dankna> hm, right, okay.  so the way it interacts with >>= is that it works on the right-hand parameter.
17:11:05 <hpc> the record syntax is just laziness; the author didn't feel like defining runMaybeT by hand
17:11:45 * hackagebot seqloc 0.3.1.2 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.3.1.2 (NicholasIngolia)
17:12:16 <bfig> if i write runSomethingT whatever, do i create a SomethingT transformer object?
17:12:30 <bfig> > runMaybeT $ Just 4
17:12:31 <lambdabot>   Not in scope: `runMaybeT'
17:13:00 <kmc> bfig, then 'whatever' is already a SomethingT
17:13:02 <kmc> broadly speaking
17:13:21 <bfig> what do you mean?
17:13:41 <hpc> bfig: runSomethingT takes a SomethingT m a and 'unwraps' it into something similar to an m a
17:13:50 <kmc> well i only just joined the conversation
17:13:57 <kmc> runMaybeT :: MaybeT m a -> m (Maybe a)
17:14:09 <bfig> hwo do i do the opposite? MaybeT whatever ?
17:14:12 <kmc> therefore if you write «runMaybeT whatever» then 'whatever' is already a «MaybeT m a»
17:14:24 <kmc> yeah, you can use the MaybeT data constructor
17:14:34 <kmc> MaybeT :: m (Maybe a) -> MaybeT m a
17:14:35 <bfig> or MaybeT.fmap Just ?
17:14:43 <hpc> bfig: you mean you want runMaybeT' :: MaybeT m a -> Maybe (m a)?
17:14:57 <kmc> can't do
17:15:07 <kmc> because you'd get e.g.  IO (Maybe Int) -> Maybe (IO Int)
17:15:11 <bfig> actually the other way around, i think the signature of MaybeT
17:15:24 <hpc> oh, yeah
17:15:47 <bfig> how does it work for reader transformers then?
17:15:48 <hpc> yeah, MaybeT is the constructor, and you put the "unwrapped" action inside with it
17:16:01 <hpc> @unmtl ReaderT r m a
17:16:01 <lambdabot> r -> m a
17:16:05 <dibblego> you can for Traversable n
17:16:08 <bfig> you need something that takes a readerlike object and makes a transformer of it?
17:16:08 <dibblego> s/n/m
17:16:17 <hpc> bfig: so to wrap a ReaderT, you pass it a value of type (r -> m a)
17:16:30 <hpc> to unwrap it, runReaderT action :: (r -> m a)
17:18:19 <bfig> how do you chain up computations then?
17:18:29 <bfig> sorry if this question seems redundant
17:18:50 <bfig> what i mean is, if you have objects of type r-> m a then they are all independent?
17:19:04 <bfig> ie, you can execute reader transformers in any order?
17:20:05 <hpc> bfig: no; the (>>=) for the ReaderT has to call the (>>=) for m somewhere inside
17:20:24 <hpc> on top of the sequencing that Reader already has
17:20:39 <hpc> the function definitions get nasty pretty quick
17:20:39 <bfig> the implicit parameters, they are killing me
17:20:55 <bfig> i can't make any sense of the implicit parameters
17:22:01 <hpc> it took me a month or so to really get comfortable with how to read monadic code
17:22:34 <bfig> i don't mind monads except when they are not passing things explicitly
17:22:55 <hpc> it helps to write a bunch of monadic code and run it over and over in ghci
17:23:19 <hpc> until you can write a piece of code (or roll your own monad), and tell exactly what it will produce as a final value
17:23:37 <bfig> i think i can handle 'just monads'
17:23:50 <bfig> also, i hate the implicit reader syntax
17:24:07 <hpc> me too
17:24:29 <hpc> you have to mentally replace all the (Reader r a) with (r -> a)
17:24:48 <hpc> well, unwrap, not replace
17:25:20 <bfig> brb
17:25:26 <bfig> thansk for the time to explain this
17:26:14 <hpc> np
17:26:30 <hpc> (though you did nerd-snipe me so i missed the start of Fringe)
17:28:48 <cheater> :t >>=
17:28:49 <lambdabot> parse error on input `>>='
17:28:58 <cheater> :t (>>=)
17:28:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:29:13 <kmc> lambdabot gives an excessively confusing type for (>>=)
17:29:19 <kmc> in H98 it's just (Monad m) => m a -> (a -> m b) -> m b
17:29:35 <cheater> i ignored the first part
17:29:49 <cheater> because i couldn't make sense of it
17:29:56 <cheater> it looked like a space suit
17:31:00 <cheater> reading: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:31:13 <cheater> which implies that
17:31:13 <cheater> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
17:31:19 <cheater> how does that relate?
17:31:23 <cheater> does it relate at all?
17:32:03 <cheater> oh, the first two args are swapped i think
17:32:08 <hpc> :t (=<<) -- start by comparing to this
17:32:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
17:32:18 <hpc> and our monad here is Writer String
17:32:42 <hpc> and he likes to add currying parens :P
17:33:35 <cheater> is =<< the same as >>= but with the first two parameters swapped?
17:33:49 <ddarius> @src (=<<)
17:33:49 <lambdabot> f =<< x = x >>= f
17:33:58 <cheater> heh
17:34:22 <Eduard_Munteanu> Or   flip (>>=)
17:34:38 <edwardk> cheater: yep
17:34:41 <hpc> cheater: exercise: figure out why there isn't a (<<) for (>>)
17:34:50 <edwardk> @type (<*)
17:34:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
17:35:07 <edwardk> @type (<<)
17:35:07 <lambdabot> Not in scope: `<<'
17:35:17 <shachaf> However, (<*) isn't (flip (*>))
17:35:27 <edwardk> i was heading there, but yes =)
17:35:45 <hpc> now now, don't spoil the answer
17:36:03 <edwardk> =<< is awkward because the monadic effects flow right to left. convenient for analogy to (.) but less useful for the intuitive order of effects
17:36:22 <Eduard_Munteanu> :t flip (>>)
17:36:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
17:37:04 <kmc> if i had a time machine one of my first priorities would be to find whoever popularized function composition in maths and make them flip it around
17:37:18 <shachaf> kmc: Application, too?
17:37:23 <kmc> maybe
17:37:44 <ion> shachaf: Stack-based programming languages already did that. :-P
17:39:08 <hpc> kmc: i think my first priority would be to slap the guy who invented lisp, and make him add types
17:39:20 <hpc> *static types
17:39:29 <hpc> (/ them, probably)
17:39:32 <shachaf> ion: Right, but that's distinct from just reversing the order of application.
17:39:54 <dibblego> lisp is easily forgiven given what was known at the time, but what about successors who refuse to not repeat mistakes?
17:40:07 <Eduard_Munteanu> shachaf: you think   x f   makes more sense?
17:40:13 <kmc> meh, I appreciate Lisp for what it is, I don't think we need to make Lisp into Haskell
17:40:26 <ion> eduard_munteanu: OOP languages do that (but usually with more syntactic noise).
17:40:31 <shachaf> Eduard_Munteanu: Possibly.
17:40:39 <Eduard_Munteanu> Hrm, good point.
17:41:15 <ion> But instead of “x y f” or “y x f” they have “x f y”. :-) Single dispatch only ftw.
17:41:16 <Eduard_Munteanu> x (f ; g ; h) isn't that bad
17:41:36 <hpc> Eduard_Munteanu: yeah it is :P
17:42:05 <hpc> Eduard_Munteanu: you have to remember what PHP programmers will do with that calling convention
17:42:14 <Eduard_Munteanu> Aww. :)
17:43:34 <cheater> how do you pronounce =<<
17:44:10 <cheater> ibnd?
17:44:26 <Eduard_Munteanu> 'dnib' would be fun :)
17:44:32 <ion> While y’all are surfing around with your time machines, would you mind swinging by SPJ in the past and telling him what the Functor/Applicative/Monad/MonadFail, Semigroup/Monoid etc. classes should look like? Thanks.
17:44:45 <hpc> if i had to pronounce it, i think i might just reverse the arguments and say bind
17:44:49 <shachaf> ion: I'm pretty sure he already kind of knew in Haskell 1.4.
17:45:04 <dibblego> Functor/Apply/Bind/PointedFunctor/Applicative/Monad/Semigroup/Monoid
17:45:07 <ion> cheater: Middle-endian?
17:45:13 <shachaf> ion: http://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/standard-prelude.html
17:45:20 <cheater> wat?
17:45:31 <ion> ibnd
17:46:14 <cheater> heh
17:46:52 <kmc> i'm told that Galois pronounces (<$>) and (<*>) as "money" and "splat"
17:47:02 <hpc> kmc: that's awesome
17:47:16 <cheater> i thought he got splatted a long time ago
17:47:23 <dibblego> if fmap is all that needed for money, then all the type-class hierarchy?
17:47:49 <kmc> cheater, clever
17:48:00 <kmc> money for nothing, theorems for free
17:48:31 <shachaf> Why is "." so horribly abused in Haskell?
17:48:37 <kmc> conor mcbride should hire me to name his papers
17:48:41 <ion> <$>: map, <*>: ap
17:48:42 <kmc> is it?
17:50:00 <shachaf> <vixey> ~ money for nothing, theorems for free, I want my GHC ~
17:50:02 <Eduard_Munteanu> :t (>>>)
17:50:03 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
17:50:14 <kmc> shachaf, googled it?
17:50:42 * Eduard_Munteanu misses vixen :P
17:50:50 <cheater> :t lift
17:50:51 <lambdabot>     Ambiguous occurrence `lift'
17:50:51 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
17:50:51 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
17:50:58 <shachaf> kmc: Yes, trying to understand the reference.
17:51:01 <shachaf> Apparently it's a song.
17:51:03 <cheater> :t liftN
17:51:04 <lambdabot> Not in scope: `liftN'
17:51:10 <cheater> :t liftM
17:51:11 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:51:23 <cheater> hm
17:53:00 <ion> :t (fmap, liftA, liftM)
17:53:01 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *) a11 r (m :: * -> *). (Functor f, Applicative f1, Monad m) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1, (a11 -> r) -> m a11 -> m r)
17:53:26 <Eduard_Munteanu> @hoogle lift
17:53:27 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
17:53:27 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
17:53:27 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
17:54:59 <shachaf> @ty [fmap,liftA,liftM]
17:55:00 <lambdabot> forall a b (f :: * -> *). (Applicative f, Monad f) => [(a -> b) -> f a -> f b]
17:58:45 <cheater> what is the "lift" they talk about here? http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:59:00 <cheater> lift f = unit . f
18:02:09 <Eduard_Munteanu> :t liftM
18:02:10 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:02:30 <ion> > let lift f = pure . f in runWriter (tell "o hai" *> lift (+1) 42)
18:02:32 <lambdabot>   (43,"o hai")
18:03:11 <Eduard_Munteanu> Ah, no.
18:24:52 <djanatyn> Hey, does anyone have any suggestions on fun things to do with haskell, for beginners?
18:25:03 <djanatyn> Besides reading over tutorials and solving programming problems? ^_^
18:25:13 <parcs> factorial
18:25:17 <dankna> debug my code for me
18:25:18 <djanatyn> Are there any fun libraries that are pretty easy to use, or very well documented that people can just jump into?
18:25:36 <djanatyn> And I don't mean like learning haskell, I mean actual practical stuff
18:25:44 <djanatyn> or at the very least just fun sutff
18:25:50 <dankna> it really depends on what you want to do
18:25:53 <dankna> browse around hackage a bit
18:25:56 <dankna> see if it inspires you
18:26:05 <djanatyn> dankna: Sounds like a good idea, thanks
18:26:13 <dankna> sure
18:26:18 <djanatyn> I used to do that with CPAN a lot :)
18:26:26 <dankna> nodnod
18:31:20 <cheater> Eduard_Munteanu: ok cool thanks
18:31:24 <cheater> ion: thanks
18:31:46 <cheater> <Eduard_Munteanu> Ah, no. << are you saying that it's *not* liftM?
18:32:25 <Eduard_Munteanu> cheater: it's not.
18:32:35 <cheater> why?
18:32:49 <Eduard_Munteanu> It's something of type  (a -> b) -> m (a -> b)
18:33:12 <cheater> why?
18:33:37 <Eduard_Munteanu> erm, (a -> b) -> a -> m b, sorry
18:33:38 <kmc> djanatyn, http://prog21.dadgum.com/80.html
18:33:47 * Eduard_Munteanu is a bit tired, should sleep :)
18:34:26 <Eduard_Munteanu> cheater: suppose f :: a -> b. What sort of values do you give it?
18:35:28 <djanatyn> kmc: thanks :)
18:36:01 <djanatyn> Hey, is there a quick and easy way for me to update ghc, using cabal or something?
18:36:16 <kmc> no
18:36:24 <Eduard_Munteanu> @type return Prelude.. f
18:36:25 <lambdabot> forall b (m :: * -> *) a. (Monad m, Show a, SimpleReflect.FromExpr b) => a -> m b
18:36:44 <ion> @type \f -> pure . f
18:36:45 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Applicative f, Functor f1) => f1 a -> f1 (f a)
18:36:52 <ion> @type \f -> pure Prelude.. f
18:36:53 <lambdabot> forall b (f :: * -> *) a. (Applicative f) => (a -> b) -> a -> f b
18:37:31 <Eduard_Munteanu> Caleskell bites again :)
18:38:02 <cheater> Eduard_Munteanu: i give it values of type a
18:38:40 <cheater> what is next?
18:41:03 <ion> Say, you’re using the Maybe monad to chain potentially failing computations (such as database queries). Are you familiar with that?
18:42:38 <Eduard_Munteanu> cheater: then it goes through f, and you get a 'b'. And then you 'return' the value.
18:45:06 <Eduard_Munteanu> So you give it 'a', and it gives you back an 'm b'
18:47:45 <cheater> Eduard_Munteanu: and this is the lift that they use in that article?
18:47:49 <cheater> or not?...
18:48:16 <Eduard_Munteanu> cheater: yeah
18:49:25 <Eduard_Munteanu> cheater: unit being return
18:50:06 <cheater> Eduard_Munteanu: so then the type would be (a->b) -> a -> mb        and not (a -> b) -> m (a -> b)   like you said
18:50:19 <cheater> i think
18:50:36 <Eduard_Munteanu> Yep.
18:50:45 <cheater> hmm
18:50:54 <Eduard_Munteanu> < Eduard_Munteanu> erm, (a -> b) -> a -> m b, sorry
18:51:52 <Eduard_Munteanu> @type return (f :: a -> b)  -- for contrast
18:51:53 <lambdabot>     Could not deduce (Show a, SimpleReflect.FromExpr b)
18:51:53 <lambdabot>       from the context ()
18:51:53 <lambdabot>       arising from a use of `f' at <interactive>:1:8
18:52:19 <cheater> oh, sorry, missed that
18:53:06 <Eduard_Munteanu> @type \f -> return (f :: a -> b)
18:53:07 <lambdabot>     Inferred type is less polymorphic than expected
18:53:07 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
18:53:07 <lambdabot>         f :: a -> b (bound at <interactive>:1:1)
18:53:29 <Eduard_Munteanu> Bah.
19:01:35 <djanatyn> "Preprocessing library gtk-0.12.1..." -- is it normal for this to run a long time?
19:01:43 <djanatyn> oh, never mind. It finished after about five minutes.
19:01:50 * djanatyn is installing the dependencies for LamdbaHack
19:01:56 <djanatyn> then I want to mess with the source code for fun.
19:02:48 <monochrom> 5 minutes is longer than what it took me, though
19:03:11 <cheater> :t liftM
19:03:12 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:03:21 <djanatyn> Woo! :D
19:03:44 <monochrom> hacking lambdahack sounds pretty meta :)
19:03:45 <djanatyn> It was quite an adventure. I had a bunch of packages that just wouldn't install at all, so I went and got the packages from the fedora repos using yum
19:03:53 <djanatyn> but, almost all of the packages that I got weren't up to date
19:04:00 <djanatyn> So I updated cabal and that got a few more packages to install
19:04:09 <djanatyn> for the ones that were left over, I tried installing them individually
19:04:17 <djanatyn> when they returned an error, they usually gave hints
19:04:35 <djanatyn> like, "you should go install gtk2hs-buildtools" which was in the fedora repos
19:04:40 <djanatyn> woo! :D
19:04:47 <djanatyn> it finally finished, time to try out LamdbaHack
19:05:14 <monochrom> you could "cabal install gtk2hs-buildtools". in fact when the gtkhs webpage existed, it was documented there
19:05:56 <parcs> i think the build script specifically complains about the lack of gtk2hs-buildtools
19:06:28 <monochrom> otoh gtk2hs-buildtools is just an exe, so it doesn't matter too much how you get it
19:09:15 <djanatyn> Well, wow
19:09:26 <djanatyn> LambdaHack is a lot more mature than I thought, it was almost like playing Nethack
19:09:50 <djanatyn> I'm going to download hscurses so that I can mess with it later
19:09:59 <djanatyn> anyway, thanks for your help guys
19:10:02 <djanatyn> haskell is fun :D
19:11:36 <donri> "mark p jones"; he related to simon?
19:13:13 <bfig> :t return
19:13:14 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:13:33 <bfig> :t (>=>)
19:13:34 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:17:45 <EvanR> :t (<=<)
19:17:46 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
19:18:04 <EvanR> o\-<
19:18:06 <EvanR> o|-<
19:18:08 <EvanR> o/-<
19:19:30 <absentia> bah, bash.org seems to be gone
19:19:34 <absentia> I was gonna link to one of my favs
19:20:33 <absentia> http://webcache.googleusercontent.com/search?q=cache:kbNowrMCkzIJ:bash.org/%3F4281+&cd=1&hl=en&ct=clnk&gl=us
19:24:17 <monochrom> California Monad: http://www.vex.net/~trebla/tmp/monad.jpg :)
19:25:21 <bfig> where is the monad?
19:25:28 <monochrom> the burritos!
19:25:38 <donri> hahaha
19:25:47 * bfig shrugs
19:25:55 <monochrom> @quote burritos
19:25:56 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
19:26:57 <monochrom> it originated with a satirical blog article "monads are like burritos", satire on far-stretched analogies
19:27:04 <kmc> @where burrito
19:27:05 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
19:27:10 <monochrom> yeah, that
19:27:12 <donri> http://blog.plover.com/prog/burritos.html
19:27:29 <monochrom> since then we s/monad/burrito/ and vice versa!
19:27:54 <donri> Burritarian IO
19:35:45 <antihoax> mov ax;$a000;mov es,ax
19:35:46 <cheater> so guys
19:35:54 <cheater> what's the least shitty curses thing for haskell
19:36:07 <antihoax> hi cheater whatzup?
19:36:30 <cheater> no u
19:39:42 <cheater> The Princess Curse by Merrie Haskell – Advance Review
19:39:51 <cheater> that's where google takes me
19:40:14 <cheater> kmc: my foot shall never step into that search engine again.
19:40:16 <donri> hey isn't the example here wrong http://www.haskell.org/haskellwiki/Haskell_IO_for_Imperative_Programmers#Laziness or am i brainfarting
19:40:56 <kmc> antihoax, doing some real-mode graphics programming are we?
19:40:57 <donri> no wait i totally misread that
19:41:05 <antihoax> :)
19:41:15 <antihoax> no, it was long time ago, on dos
19:41:30 <donri> didn't spot the consequtive ='s
19:41:30 <antihoax> i had to leave it behind when i moved to linux :(
19:41:48 <antihoax> no more easy video memory access
19:41:56 <antihoax> and millions of libraries
19:43:36 <kmc> antihoax, you should still do it for fun!
19:44:04 <antihoax> btw i have made line, circle, putpixel, triangle and other functions in asm
19:44:08 <antihoax> now that was fast
19:44:11 <kmc> i recently made a little MBR graphics demo http://ugcs.net/~keegan/phosphene/
19:44:21 <kmc> for http://io.smashthestack.org:84/intro/
19:44:21 <antihoax> :)
19:44:39 <antihoax> i remember when on turbo pascal
19:45:10 <antihoax> wrote assembly routines instead of the graph unit, it was blazingly fast compared
19:46:17 <antihoax> line, circle, putpixel at random positions looks like random noise in asm
19:46:57 <antihoax> there was 256b.com
19:47:09 <antihoax> for 256 byte intros
19:47:15 <antihoax> maybe its still there
19:47:38 <antihoax> and there were 64k competitions too
19:48:14 <cheater> finally a haskell tutorial that can be understood: http://d.hatena.ne.jp/itchyny/20110902/1314965062
19:48:25 <cheater> antihoax: but did you take part in the boot sector compo
19:48:55 <kmc> pouet has a lot of good demos
19:49:01 <donri> related http://i.imgur.com/D4QEO.png
19:49:04 <kmc> though not so many in the really small size range
19:49:20 <antihoax> ahaha
19:49:20 <antihoax> http://www.theprodukkt.com/
19:49:25 <antihoax> kkrieger
19:49:30 <antihoax> 3d fps in 64k
19:49:42 <cheater> 3d is overrated
19:49:47 <cheater> 2.5d is where it's at
19:49:57 <kmc> after writing a 446b demo, 64k sounds like an incredible amount of space
19:49:58 <antihoax> have you seen it?
19:50:18 <antihoax> look at the screenshots
19:50:19 <antihoax> <;
19:50:50 <kmc> i've seen it :)
19:50:56 <kmc> btw we could continue this discussion in #haskell-blah?
19:52:55 <antihoax> sure
19:52:58 <NemesisD> i'm having a hard time designing the enumerator system for a pattern i'm trying to model
19:53:37 <antihoax> im having a hard time installing ghc
19:53:38 <antihoax> <;
19:53:51 <NemesisD> overall this code will be an Enumerator that produces parsed JSON values, however it has to paginate through a resource on the internet
19:53:57 <antihoax> too bad it does not have all libraries installed properly by default
19:54:22 <kmc> antihoax, did you install Haskell Platform?
19:54:31 <antihoax> its already 800MB+ what would it take to include the libraries too...
19:54:34 <NemesisD> so it's got to make an initial request and then basically feed the next page link from the result back into itself to know whether or not to continue
19:54:41 <antihoax> i have installed ghc
19:54:50 <NemesisD> antihoax: platform sounds like what you're after
19:54:51 <kmc> Haskell Platform = GHC with some libraries included
19:54:59 <antihoax> hmmm
19:55:02 <antihoax> i dont know
19:55:04 <NemesisD> i don't know ghc to be 800mb
19:55:05 <antihoax> will llok
19:55:07 <kmc> obviously installing all the libraries from Hackage would be a bit much
19:55:44 <antihoax> i grabbed ghc-7.2.1-x86_64-unknown-linux.tar.bz2
19:55:50 <antihoax> 111MB compressed
19:55:55 <kmc> that's just ghc, not platform
19:55:59 <antihoax> ;/
19:56:09 <antihoax> so i need the platform and i have the libraries
19:56:23 <kmc> also Platform is still on 7.0
19:56:28 <kmc> GHC 7.0 i mean
19:57:02 <antihoax> well this did not compile my simple graphic drawing example so...
19:57:16 <antihoax> if it works then it should do
19:57:40 <kmc> if you use 7.2 you will have more problems
19:57:48 <antihoax> ok
19:57:54 <antihoax> then i will wait with upgrade
19:58:04 <kmc> you'll have to install cabal-install yourself and use that to get the rest of the libraries from the Platform
19:58:14 <antihoax> yes i see
19:58:25 <antihoax> its '"+'!+%!+%+
19:58:58 <shachaf> @bf '"+'!+%!+%+
19:58:58 <lambdabot>  Done.
19:59:14 <antihoax> <;
19:59:47 <NemesisD> kmc, how familiar are you with the enumerator package?
19:59:55 <kmc> not
20:00:01 <NemesisD> shoot
20:03:23 <cheater> given that i am on this page, how do i figure out what package to install to get this module?  http://hackage.haskell.org/packages/archive/hscurses/1.3.0.2/doc/html/UI-HSCurses-Curses.html
20:03:52 <antihoax> http://haskell.org/ghc/dist/7.0.3/ghc-7.0.3-x86_64-unknown-linux.tar.bz2
20:03:56 <antihoax> so i download this
20:04:00 <antihoax> install
20:04:01 <antihoax> then
20:04:06 <antihoax> wtf
20:04:19 <antihoax> and compile the platform
20:04:31 <antihoax> http://lambda.galois.com/hp-tmp/2011.2.0.1/haskell-platform-2011.2.0.1.tar.gz
20:04:49 <parcs> cheater: 'ncurses' is the best curses package
20:04:59 <parcs> see also vty and vty-ui
20:05:48 <antihoax> but it wont be perfect since i dont have that much free space on / now
20:06:03 <antihoax> 8GB partition and already full
20:07:33 <NemesisD> ...8gb partition?
20:07:44 <antihoax> for /
20:07:59 <antihoax> 2gb for var and 2gb for home
20:08:10 <antihoax> +4gb swap
20:08:21 <antihoax> thats 16GB already
20:08:32 <antihoax> and i have a 4gb /tmp too
20:09:24 <antihoax> additionally a similar setup with another linux system added to bootmenu
20:09:37 <cheater> parcs: why is it better than hscurses?
20:09:52 <NemesisD> are you doing this on a netbook or something?
20:09:55 <antihoax> thought 8GB would be enough for / ;/
20:10:40 <antihoax> NemesisD<< no
20:10:59 <antihoax> its a little faster than that
20:13:21 <antihoax> its LVM2 btw
20:16:28 <antihoax> is there a switch for runinplace?
20:16:51 <antihoax> make install to same directory sounds insane
20:18:40 <antihoax> or at least ln instead of cp
20:29:39 <KirinDave> NemesisD, I'd love to see how you're going to solve that enumerator problem.
20:32:15 * edwardk waves hello.
20:32:32 <edwardk> Slowly uploading many hours of video to youtube
20:32:42 <edwardk> First clip: http://www.youtube.com/user/edwardkmett?feature=mhee#p/u/0/Oz-7aWHQABQ
20:33:42 <NemesisD> KirinDave: im thinking i create an enumeratee that consumes tuples of JSON results and a type like data PageToken = NextPage URL | NoneLeft
20:34:07 <KirinDave> NemesisD, yeah,.
20:34:13 <NemesisD> haven't worked out the types yet though
20:34:17 <KirinDave> I think I've been doing iteratees wrong
20:34:20 <parcs> cheater: it's a better interafce
20:34:34 <KirinDave> In that I keep making increasingly complex enumeratees.
20:34:52 <cheater> parcs: oh, ok, let me check it out
20:35:27 <NemesisD> KirinDave: i've only used them once really in an application. i'm not sure if i did it wrong but the application processed stdin -> stdout so i made an enumerator on one end, iteratee on the other and a big pipeline of enumeratees in the middle
20:35:58 <KirinDave> NemesisD, see, I think maybe we don't always have to do that
20:36:11 <KirinDave> NemesisD, I keep forgetting to leverage iteratees as monads.
20:36:21 <kmc> leverage :(
20:36:33 <KirinDave> Which is just a sign of what a wretched haskell programmer I am, still
20:37:11 <NemesisD> im not sure i know enough to know what you mean. i did, however, find writing that pipeline pretty straightforward though since it used Data.Enumerator.List pretty heavily
20:37:29 <NemesisD> possibly to my detriment. i didn't *really* have to know what i was doing to get the job done
20:38:24 <KirinDave> I want to try it, but shonldn't repeatM work for an iteratee?
20:38:37 <KirinDave> I know >> works, so...
20:39:36 <KirinDave> kmc: Think about them like a rational person and not like a tard. Is that better than leverage? :)
20:40:34 <parcs> edwardk: yay
20:40:36 <kmc> i think the fact that you're using iteratees at all puts you ahead of the pack
20:40:39 <kmc> or maybe i'm just behind :(
20:40:47 <edwardk> parcs: video?
20:40:56 <KirinDave> kmc: Yeah well you got dat comonad.
20:41:34 <edwardk> parcs: i have a 65 minute or so chunk by winterkoninkje going up next about a probability smoothing DSL
20:42:21 <edwardk> then ~2.5 hours of me talking about automatic differentiation as a DSL and building a train track DSL on top
20:44:00 <parcs> interesting, looking forward to watching it
20:44:14 <parcs> hurry up and upload! :P
20:44:31 <edwardk> i have some misc clips from the rest of the first day including a dsl in java for doing inter-system conversions for linguistic data and a couple of 'how much category theory you need to know to follow along the gist of what we're saying' bit, but i may cut those, as they jump around a lot
20:44:55 <edwardk> parcs: the interwebs are too slow
20:45:31 <copumpkin> you need some draino
20:45:33 <copumpkin> drano?
20:46:42 <edwardk> day 2 will be a bit messier to edit
20:47:53 <Veinor> so my current project is this: build a working CSRF-(resistant|proof) site with user registration and login
20:47:57 <edwardk> that day has a lot of stuff on how to use codensity transformed free monads to make efficint DSLs, which i've largely replaced in my current approach of just using church encoded free monads
20:49:13 <Veinor> wish me luck, #haskell o7
20:49:18 * copumpkin wishes Veinor luck
20:49:27 <copumpkin> Veinor: will it be troll-proof?
20:49:36 <copumpkin> that's harder to guarantee statically
20:49:51 <Veinor> well i mean the sole functionality is going to be 'create an account, log in, and set the contents of some text variable associated with your account'
20:50:50 <copumpkin> see, that's already vulnerable
20:50:58 <copumpkin> the text variable could be ascii art of a trollface
20:51:00 <Veinor> haha
20:51:18 <Veinor> is there a decision procedure for whether a message is a troll?
20:51:34 <kmc> Veinor, you should write your app in Agda!
20:51:47 <kmc> there's even an Agda web framework
20:51:48 <Veinor> do it all in javascript using that agda to js compiler!
20:51:51 <kmc> https://github.com/larrytheliquid/Lemmachine
20:53:10 <edwardk> parcs: based on current upload speed the next segment will be up on the channel in a bit over an hour
20:53:16 <copumpkin> that's the future
20:54:04 <KirinDave> I really want to see a haskell implementation of enlive.
20:54:09 <KirinDave> Do that, Veinor.
20:54:59 <cheater> edwardk: have you uploaded kmc's video yet? i wanted to post it on my blog
20:55:16 <KirinDave> I want to see kmc in a video.
20:55:30 <kmc> i think we're going to get a better video when i give the talk next
20:55:33 <kmc> and we'll upload that one
20:55:34 <edwardk> cheater: he asked me to hold onto it so he could see if he could get the 'main' presentation of it captured. if not then we'll use the video i grabbed
20:56:01 <KirinDave> kmc: Then let #haskell preview. :)
20:56:13 <cheater> what does it mean to capture the main presentation?
20:56:14 <KirinDave> Maybe we can give some feedback on how to improve the next one?
20:56:22 <kmc> i got plenty of feedback at the event
20:56:24 <edwardk> cheater: he was using this as a dry run for another talk
20:56:39 <kmc> i'm giving the talk again at MIT on the 11th to a different audience
20:56:45 <cheater> let's have both
20:56:52 <cheater> because hey, alternatives are better than just one thing
20:56:55 <kmc> no
20:56:56 <edwardk> and since rwbarton had to cancel we basically opened the floor to a longer q&a session for trying to find ways to better sell the talk to a wider audience, etc.
20:57:09 <cheater> and unless the first one is factually incorrect it's a good addition
20:57:21 <cheater> although i understand why you'd want to release the better one first
20:57:49 <cheater> kmc: no 1 askd u
20:57:51 <edwardk> nah, i'm with kmc, i think the more polished talk would be better. though if it doesn't get captured, having this one is better than none at all ;)
20:57:52 <cheater> :p
20:58:01 <cheater> i guess
20:58:14 <edwardk> and its blackmail material to get him to release the good one ;)
20:58:29 <edwardk> (actually the talk was pretty good)
21:01:38 <cheater> :t finally
21:01:39 <lambdabot> Not in scope: `finally'
21:01:51 <cheater> isn't that like a standard thing?
21:01:56 <cheater> @type finally
21:01:57 <lambdabot> Not in scope: `finally'
21:02:03 <edwardk> !@&*# chrome crashed most o the way through uploading
21:02:24 <cheater> that's chrome for you
21:02:29 <kmc> cheater, http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Control-Exception.html
21:02:45 <cheater> thx2u
21:02:53 <kmc> @hoogle finally
21:02:54 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
21:02:54 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
21:02:54 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
21:07:17 <KirinDave> NemesisD, http://hackage.haskell.org/packages/archive/monad-loops/0.3.1.1/doc/html/Control-Monad-Loops.html 's whileM is what I had in mind.
21:11:23 <cheater> parcs what do i do? Configuring ncurses-0.2... cabal: The program c2hs version >=0.15 is required but it could not be found.
21:12:45 <cheater> hm
21:13:02 <kmc> cabal install c2hs
21:13:05 <kmc> or get it from your distro's repos
21:13:13 <cheater> yeah i'm doing cabal install
21:13:14 <cheater> hence hm
21:13:20 <kmc> cabal-install will autochase library deps but not build tools
21:13:23 <cheater> because i wouldn't have imagined such deficiency from cabal
21:13:38 <cheater> why do i care if it's a library dep or a build tool?
21:13:45 <kmc> CABAL SUX FIX MY BUG OR I WILL HATE U FOREVAR
21:13:58 <cheater> yes
21:14:16 <kmc> you can ask dcoutts et al why it works this way
21:15:14 <cheater> am i prohibited from asking you
21:15:20 <kmc> i don't know
21:15:47 <jeff_s_> You could make a linux distribution that used cabal for installing everything.
21:15:53 <cheater> @faq am i prohibited from asking kmc about that?
21:15:54 <lambdabot> The answer is: Yes! Haskell can do that.
21:16:03 <cheater> :(
21:16:48 * hackagebot persistent-equivalence 0.3 - Persistent equivalence relations (aka union-find)  http://hackage.haskell.org/package/persistent-equivalence-0.3 (ChrisSmith)
21:16:52 <cheater> nice i have ncurses install'd
21:17:38 <cheater> and hscurses
21:17:46 <cheater> feelzgoodman
21:28:14 <bfig> is there a thing as a parsec user guide for the last version?
21:30:29 <cheater> i guess it's called Cale
21:31:28 <bfig> i have no idea why i'm failing to write the code i need. maybe i'm suffering from burnout already
21:31:44 <kmc> where are you having trouble?
21:31:49 <bfig> everywhere
21:32:00 <bfig> i feel like an idiot, this has never happened before in my life
21:32:03 <kmc> can you be more specific?
21:32:48 <kmc> heh, Haskell makes most people feel like idiots at some point or another
21:32:49 <bfig> i just... can't do anything. everything is a source of confusion
21:32:56 <bfig> *everything*
21:33:01 <kmc> okay
21:33:08 <kmc> well i've used Parsec 3 a fair bit
21:33:12 <kmc> and can answer questions
21:33:36 <kmc> have you written any working parser yet?
21:33:43 <bfig> it's not really a matter of parsec, i feel i'm trying to write for the linux kernel without actually knowing what a kernel is
21:33:53 <bfig> i've written a handcrafted haskell parser, let me paste it
21:33:53 <kmc> haskell in general, then?
21:33:55 <bfig> it works damn well
21:34:08 <bfig> but has like zero monads in it (just the thing that handles the input)
21:34:54 <kmc> what's the relevance of the monad count?
21:35:12 <hpaste_> bfig pasted “the best parser ever, ie, one i can goddamn understand” at http://hpaste.org/51994
21:35:33 <bfig> that it is a parser, it is in 'monadic style', but it is not a monadic parser
21:36:31 <kmc> but you've not written any Parsec parser yet?
21:36:38 <bfig> nope
21:36:48 <kmc> okay
21:36:56 <kmc> did you try writing a very simple Parsec parser?
21:37:26 <bfig> i've been trying to find how to do a parser for the " " string or something similar but all i get is completely absurd examples
21:37:50 <bfig> i know how to use parser combinators, if i could only find where is the parser definition, and where are the combinators
21:37:55 <mzero> as in using Parsec - or your trying to writ your own
21:37:58 <kmc> http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Char.html
21:38:04 <bfig> no, i want to use parsec
21:38:07 <kmc> http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Combinator.html
21:38:16 <mzero> then what kmc said
21:38:27 <kmc> in particular Text.Parsec.Char.string " "
21:38:35 <bfig> what is ParsecT s u m a ?
21:38:35 <kmc> or just Text.Parsec.Char.char ' '
21:38:50 <JoeyA> In Attoparsec, is it possible to peek at the next character without consuming it?
21:38:50 <bfig> where the hell is all this explained in a human readable form? :|
21:39:04 <kmc> in #haskell if you'll stop being so bitchy about it
21:39:22 <bfig> sorry, i don't want to bother you all, i just want a source where i can read
21:39:26 <kmc> http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Prim.html#t:ParsecT
21:39:32 <kmc> "ParsecT s u m a is a parser with stream type s, user state type u, underlying monad m and return type a."
21:39:44 <kmc> see also "type Parser" at http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-String.html
21:40:36 <kmc> you'll want to import that module to get the Stream instance for String
21:40:36 <mzero> just use Parser from Test.Parsec.String
21:40:57 <bfig> sorry for acting like an asshole, i think i just need to sleep and clear my mind.
21:42:07 <bfig> you've been very helpful, this is not the place for complains. It's just so hard to follow examples. i need to code something and incorporate tools, one at a time
21:42:34 <kmc> it's definitely true that the docs could be better
21:42:42 <kmc> (or maybe i can't find the good docs)
21:43:08 <kmc> the main thing is to ask specific questions like 'how do I parse the string " "'
21:43:15 <cheater> parcs: ncurses doesn't work :(
21:43:33 <bfig> i found a reference but it's from 2001, and since it imports Parsec instead of Text.... i figure it is not enough up to date
21:43:52 <kmc> yeah, that's quite old
21:43:55 <kmc> before Parsec 2 even
21:44:28 <hpaste_> cheater pasted “ncurses doesn't work” at http://hpaste.org/51995
21:45:03 <parcs> cheater: in what way does it not work
21:45:20 <cheater> prints garbage, breaks terminal
21:45:33 <cheater> try yourself
21:46:08 <parcs> i don't have it installed atm and i have to jump through hoops to install it on arch linux and i'm lazy
21:46:21 <parcs> but it worked for me
21:46:29 <Dashkal> bfig: From someone who very much remembers the feeling you're describing:  You're not dumb, these concepts just take readjustment and time.
21:46:32 <mzero> cheater - I've successfully used UI.HSCurses
21:47:45 <bfig> well, gonna sleep, tomorrow will be another day of screaming at ghci
21:47:56 <bfig> good night..
21:48:04 <cheater> so have i
21:48:04 <Dashkal> goodnight :)
21:48:09 <cheater> but i was told ncurses is better
21:48:13 <cheater> although right now i doubt it
21:48:17 <cheater> not really sure of it
21:49:33 <parcs> cheater: :/ i guess try hscurses or vty
21:49:35 <mzero> gosh - I remember going through that choice earlier this summer
21:49:43 <parcs> the latter is a pure-haskell ncurses-like library
21:49:56 <mzero> can't remember why I ended up with HSCurses - but it definitely works for me (running on Mac OS X)
21:50:03 <mzero> https://github.com/mtnviewmark/ICFP-2011-FluShot/blob/master/src/Main/Live.hs
21:50:06 <cheater> not sure if i want something that's pure haskell
21:50:18 <cheater> simply because curses stuff is like black magic
21:50:19 <mzero> that's a file that uses it -- look at liveMain for all the stuff you need to do setup and tear down
21:50:22 <cheater> you don't want to redo it
21:50:40 <cheater> parcs: what was the better part about ncurses over hscurses?
21:50:52 <cheater> i am comparing the APIs but not seeing any differences yet
21:50:59 <mzero> hscurses isn't pure haskell
21:51:12 <parcs> cheater: really?
21:51:20 <parcs> hscurses is way more low-level than ncurses
21:51:30 <parcs> 'type Window = Ptr WindowTag'
21:51:58 <parcs> waddchnstr :: Window -> CString -> CInt -> IO CInt
21:52:00 <parcs> :P
21:52:00 <cheater> mhm
21:54:53 <cheater>   -- wAddStr :: Window -> String -> IO ()    標準の画面に文字を出力
21:55:02 <cheater> maybe you're looking at the wrong parts?
21:56:31 <parcs> still not as nice as ncurses
21:56:44 <parcs> btw i recall you looking at tutorials for hscurses
21:57:13 <parcs> hscurses is low-level enough to be able to follow a generic ncurses tutorial
21:58:08 <parcs> hmm maybe s/generic/c/
21:58:21 <cheater> yeah it seems
21:58:37 <cheater> i dunno can it be that i'm running ncurses interpreted and not compiled?
21:58:40 <cheater> via runhaskell
21:58:52 <parcs> yes
21:58:56 <cheater> why
21:59:10 <parcs> cuz idk
21:59:17 <cheater> how do i compile
21:59:31 <parcs> ghc foo.hs && ./foo
21:59:31 <cheater> i tried ghc --make foo.hs
21:59:46 <parcs> and it failed?
21:59:51 <cheater> that only creates .hi and .o
22:00:04 <parcs> it should have created a ./foo executable
22:00:24 <cheater> does my module need to be named something special
22:00:42 <Olathe> Main
22:00:50 <cheater> why can it not be something else?
22:01:06 <Olathe> Because that would just be some library rather than an Application.
22:01:23 <Olathe> Or some other reason similar to that.
22:01:32 <mzero> so foo.hs should either have no module declaration -- or module Main where... at the top
22:01:55 <cheater> yes compiling worked
22:02:07 <cheater> but runhaskell doesn't
22:02:08 <mzero> I think because they didn't want to make 'main' a special name in all modules
22:02:08 <parcs> Main is implied if there is no explicit module name. ghc uses Main.main as the entry point of a program
22:02:08 <cheater> why?
22:02:37 <mzero> Haskell tends to very minimal design
22:02:46 <mzero> very few reserved words, special things, etc...
22:03:05 <parcs> cheater: it probably has to do with dynamic loading
22:03:08 <mzero> most of us wish there were even fewer!  (if-then-else I'm looking at you!)
22:03:12 <cheater> suckage
22:03:35 <parcs> runhaskell uses dlopen to load ncurses.so
22:03:43 <cheater> why is that bad
22:03:50 <cheater> and can i fix it
22:04:06 <parcs> i don't know and probably not
22:04:17 <cheater> :(
22:04:18 <parcs> hmm
22:05:22 <davean_> additionally ghc supports -main-is
22:06:01 <cheater> but stracing my ncurses bin also shows:
22:06:01 <cheater> open("/lib/libncurses.so.5", O_RDONLY)  = 3
22:07:12 <cheater> i think i know what's going on
22:07:28 <cheater> i think i compiled haskell's ncurses against libncursesw
22:07:38 <cheater> but it's running against libncurses.so
22:08:56 <cheater> can that be?
22:08:57 <cheater> hmm.
22:38:14 <robzy> hello sexy people
22:44:53 <rostayob> robzy: hello
22:45:29 <m42a> does anyone know why Haskell is telling me minBound==maxBound?
22:45:46 <robzy> i've read a fair bit of Learn You a Haskell, but now I'm wondering how i should go about practicing what I learnt
22:45:47 <Gracenotes> it defaults to a type with only one value
22:46:00 <Gracenotes> if you just type in minBound==maxBound into GHCI
22:46:03 <m42a> robzy: Project Euler
22:46:11 <robzy> oh, thanks :)
22:46:18 <kmc> > (minBound :: Int) == maxBound
22:46:19 <lambdabot>   False
22:46:24 <kmc> > [minBound :: Int, maxBound]
22:46:26 <lambdabot>   [-9223372036854775808,9223372036854775807]
22:46:32 <shachaf> robzy: Project Euler problems probably won't teach you much about Haskell.
22:46:41 <Gracenotes> it you want, say, Integer instead of (), you can do that :) or help it guess by doing numerical things with it
22:46:45 <rostayob> is there a standard name for mutable streams to indicate the operation that removes the head?
22:46:54 <shachaf> rostayob: shift?
22:47:03 <rostayob> shachaf: ok
22:47:03 <mzero> because if you type minBound into ghci, it'll have to guess some Bounded type, and I think it picks... tad a... ()
22:47:04 <shachaf> Not really for streams, I guess.
22:47:07 <rostayob> mhm
22:47:11 <Gracenotes> beheading
22:47:24 <JoeyA> lol
22:47:25 <robzy> just took a quick look at project euler... i think im looking for "applied" haskell problems, as oposed to coming up with theoretical algorithms
22:47:28 <robzy> i think
22:47:59 <rostayob> robzy: write a simple parser with parsec
22:48:09 <mzero> robzy - just take whatever your next personal programming project is... and do it in haskell
22:48:11 <kmc> robzy, pick a program you want to write, then write it in Haskell
22:48:12 <mzero> !
22:48:35 <robzy> heh, fair point :P
22:48:41 <mzero> code up your favorite card game
22:48:41 <robzy> thanks for the suggestions :) it really is appreciated it
22:48:49 <robzy> -it
22:48:53 <JoeyA> Write a program to hardlink duplicate files in a given directory.
22:48:59 <kmc> robzy, http://prog21.dadgum.com/80.html
22:49:07 <mzero> my first more-than-5-line-program was coding up Uno, and then coding up different strategies for it
22:49:14 <mzero> and finally pitting them against eachother
22:50:05 <robzy> Thanks kmc, I've read that before, the thing is I'm not looking for a "big project", I've got projects in mind, but I Was wanting some simpler stuff to cut my teeth on beforehand
22:50:20 <robzy> Project Euler and some googling ought to give me some stuff, though :) thanks
22:50:25 <JoeyA> Then my suggestion would not be good
22:50:47 <monochrom> kmc++
22:50:56 <robzy> tbh JoeyA, I think that's kinda cool as a small simple applied programming challenge
22:51:09 <robzy> (ftr, the project I have in mind is a JPEG encoder)
22:51:22 <kmc> robzy, ah
22:51:34 <kmc> implementing games and implementing toy programming languages are both good ones
22:51:49 <kmc> my first nontrivial haskell projects were all languages stuff
22:51:55 <monochrom> toy programming language games :)
22:52:04 <kmc> it's probably the field where you get the most advantage from using a language like Haskell
22:52:09 <kmc> so you can do things that sound very impressive / hard
22:52:18 <robzy> what do you mean by implementing toy programming languages? is that related to the parsec suggestion?
22:52:25 <kmc> not necessarily
22:52:30 <kmc> your language might not even have concrete syntax
22:52:36 <kmc> it might just be Haskell terms
22:52:44 <kmc> parsing isn't really the interesting part of implementing languages
22:53:30 <robzy> it's funny you guy should mention that, because i have an idea for a (non-turing-complete, i believe) programming language brewing in the back of my mind :P
22:53:40 <mzero> robzy - try the ICFP 2011 programming contest - http://www.icfpcontest.org/2011/06/task-description-contest-starts-now.html
22:53:41 <monochrom> do that!
22:54:00 <Gracenotes> :o someone from stony brook
22:54:10 <kmc> yeah, look at the older ICFP contests too
22:54:12 <mzero> at least it is fun to write to code to make the mechanics of that problem work - even if figuring out an AI is beyond simple
22:54:14 <robzy> thanks mzero, added to the list
22:55:44 <robzy> let (a:b:c:[]) = "xyz" in a <-- What's with the brackets around a:b:c:[]? It does not seem like they are required
22:55:56 <monochrom> not required
22:56:02 <kmc> > let a:b:c:[] = "xyz" in a
22:56:03 <lambdabot>   'x'
22:56:16 <robzy> so just for readability's sake?
22:56:39 <monochrom> but if you define a function like "let f (a:b:c:[]) = ..." then it's required
22:57:28 <robzy> if i leave them out, what would it be interpreted as? would it be like C?
22:57:43 <kmc> f a : b   ≡   (f a) : b
22:58:00 * shachaf wonders what "like C" would be.
22:58:02 <robzy> ah, i see!
22:58:18 <robzy> shachaf: by "like C" i meant that it evaluates the "=" and passes it as an argument to f
22:58:24 <robzy> obviously not though, thanks kmc :)
22:59:06 <shachaf> robzy: Function application -- i.e. "a b" -- binds the tightest in Haskell, other than two other things (record syntax).
22:59:57 <robzy> thanks guys
23:01:40 <Gracenotes> shurane: sup
23:05:14 <rostayob> is there something that provides operations with Handle with ByteString instead of String?
23:05:37 <kmc> Data.ByteString has some
23:05:38 <Cale> The ByteString library itself does, doesn't it?
23:06:06 <rostayob> oh, stupid of me
23:06:09 <rostayob> thanks
23:08:07 <robzy> where would be the best place to look for a definition of the '@' character?
23:08:36 <kmc> the pattern x@p matches the same things as the pattern p
23:08:49 <kmc> it binds the same variables as p, and binds the variable x to the whole thing matched
23:09:10 <robzy> so it's only for pattern matching?
23:09:23 <kmc> yes
23:09:27 <robzy> great, thanks :)
23:09:28 <kmc> it's part of the syntax of patterns
23:09:38 <kmc> which means you can't define your own operator named (@)
23:09:56 <robzy> for future reference, if a terribly asteroid had hit the earth and killed all of you guys, where would be the best place for me to go for this info?
23:10:12 <robzy> (i mean that in a loving i-dont-want-to-bother-you-guys-too-much way :P)
23:10:12 <kmc> well it's in the Haskell Report
23:10:23 <kmc> and i bet it's covered in some of the tutorials, but i can't say where specifically
23:10:33 <kmc> also there's a "haskell cheat sheet" somewhere which might have it
23:11:08 <Gracenotes> the cool haskell symbols are in http://haskell.org/haskellwiki/Keywords
23:11:10 <robzy> i see :) thanks again... in that way it would be a bit like looking up the definition of some of C's operators... which is tougher than looking up function definitinos etc.
23:11:15 <robzy> fantastic, thanks :)
23:11:39 <kmc> yeah
23:11:47 <kmc> there aren't that many reserved keywords / operators in Haskell
23:11:50 <Gracenotes> the uncool ones have been left out
23:12:05 <kmc> for patterns there's @, ~, and ! (the last one being a GHC extension)
23:12:51 <robzy> i see
23:13:20 <kmc> ~p always matches, and forces nothing
23:13:36 <robzy> with almost all programming languages in the past (BASIC, PHP, Perl, Python, C, C++, etc.) I have been able to understand whats going on just be reading it... the syntax is all roughly the same.... with Haskell this is not the case :P
23:13:36 <kmc> if you use any of the variables bound by p, only then does it check the pattern
23:13:55 <robzy> i see
23:13:58 <kmc> yeah, Haskell is very different... and it's not just syntax
23:14:31 <robzy> i come from a mathematical background, so i can handle that it requires a non-imperative way of thinking
23:14:52 <kmc> though you may be understating the differences between e.g. Python and C++
23:15:13 <robzy> that's true, i was being somewhat pompous in what i said... but it's vaguely true
23:15:17 <kmc> in my mind those two are about as far apart as Python and Haskell, in a totally different direction
23:15:29 <kmc> but it's true that you can follow *simple* C++ with only a general imperative programming background
23:16:02 <robzy> exactly, but I find it difficult to follow Haskell, simply because i don't understand the syntax
23:16:16 <kmc> maybe that cheat sheet will help
23:16:49 <robzy> http://blog.codeslower.com/static/CheatSheet.pdf found one
23:16:55 <Gracenotes> writing syntax is a great way to absorb it
23:17:34 <Gracenotes> and we can sort out any kinks
23:18:05 <robzy> thanks, i appreciate it
23:18:08 <Gracenotes> ..that you discover
23:18:48 <Gracenotes> compare this to, say, C, where the philosophy seems to be that if you make mistakes, it's because you didn't read a 1000-page C bible before asking for help.
23:19:29 <robzy> yeah, i rather like programming in C, but sometimes dealing with multiple layers of pointers and arrays can be a royal PITA
23:20:19 <kmc> programming ordinary applications code in C is criminal negligence
23:20:33 <kmc> if you're writing an OS kernel or the very inner loop of a numerical app, that's different
23:20:53 <robzy> i'd hesitate to go that far :P but i get where you're coming from
23:21:19 <kmc> a language where a subtle mistake doing simple string manipulations will allow random assholes from the internet to take over my computer
23:21:44 <robzy> valid point
23:21:57 <kmc> i've discussed this with die-hard C programmers in detail and their arguments always boil down to "if you don't use C you have a small penis"
23:22:27 <kmc> "good programmers don't make mistakes"
23:22:30 <kmc> yeah right
23:22:45 <AfC> especially not subtle ones.
23:22:50 <kmc> my company hires only unicorns for software dev
23:23:39 <robzy> lol
23:25:36 <cheater> @src headMay
23:25:37 <lambdabot> Source not found. Do you think like you type?
23:25:38 * hackagebot bpann 0.1.1 - backpropagation neuronal network  http://hackage.haskell.org/package/bpann-0.1.1 (RobertSteuck)
23:25:52 <cheater> @src readMay
23:25:52 <lambdabot> Source not found. You speak an infinite deal of nothing
23:26:02 <cheater> what is it with the lambdabot insults
23:26:47 <Gracenotes> they're all in a list somewhere
23:31:55 <robzy> how can i find out what typeclasses a type belongs to?
23:32:10 <JoeyA> :i Bool
23:32:28 <JoeyA> robzy: That'll do it in GHCi.
23:32:33 <robzy> hrm, tryhaskell.org doesn't like that
23:32:36 <robzy> no worries though
23:33:04 <kmc> it's kind of an unusual question to want to ask
23:33:07 <kmc> not unreasonable though
23:33:14 <Twey> Is it?  I do that all the time
23:33:20 <kmc> why?
23:33:22 <desaiu> http://i.imgur.com/G7xly.png
23:33:31 <desaiu> How do you remove that garbage at the bottom of the screen?
23:33:34 <robzy> im just reading Learn You a Haskell and was curious
23:33:34 <Twey> Because sometimes you want to know if something is e.g. an Ord
23:33:46 <Twey> (or a GTK.Editable, most recently)
23:33:52 <robzy> desaiu: sudo apt-get install vim ;)
23:34:08 <Twey> robzy: *thwack*
23:34:43 <Twey> desaiu: Maybe try upgrading your haskell-mode version… I don't think that's supposed to happen :þ
